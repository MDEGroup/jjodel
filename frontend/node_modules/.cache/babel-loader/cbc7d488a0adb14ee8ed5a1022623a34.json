{"ast":null,"code":"import { maximePlaceHolderId, placeHolderStyle } from \"./DockData\";\nlet _watchObjectChange = new WeakMap();\nexport function getUpdatedObject(obj) {\n  let result = _watchObjectChange.get(obj);\n  if (result) {\n    return getUpdatedObject(result);\n  }\n  return obj;\n}\nfunction clearObjectCache() {\n  _watchObjectChange = new WeakMap();\n}\nfunction clone(value, extra) {\n  let newValue = Object.assign(Object.assign({}, value), extra);\n  if (Array.isArray(newValue.tabs)) {\n    newValue.tabs = newValue.tabs.concat();\n  }\n  if (Array.isArray(newValue.children)) {\n    newValue.children = newValue.children.concat();\n  }\n  _watchObjectChange.set(value, newValue);\n  return newValue;\n}\nlet _idCount = 0;\nexport function nextId() {\n  ++_idCount;\n  return `+${_idCount}`;\n}\nlet _zCount = 0;\nexport function nextZIndex(current) {\n  if (current === _zCount) {\n    // already the top\n    return current;\n  }\n  return ++_zCount;\n}\nfunction findInPanel(panel, id, filter) {\n  if (panel.id === id && filter & Filter.Panel) {\n    return panel;\n  }\n  if (filter & Filter.Tab) {\n    for (let tab of panel.tabs) {\n      if (tab.id === id) {\n        return tab;\n      }\n    }\n  }\n  return null;\n}\nfunction findInBox(box, id, filter) {\n  let result;\n  if (filter | Filter.Box && box.id === id) {\n    return box;\n  }\n  for (let child of box.children) {\n    if ('children' in child) {\n      if (result = findInBox(child, id, filter)) {\n        break;\n      }\n    } else if ('tabs' in child) {\n      if (result = findInPanel(child, id, filter)) {\n        break;\n      }\n    }\n  }\n  return result;\n}\nexport var Filter;\n(function (Filter) {\n  Filter[Filter[\"Tab\"] = 1] = \"Tab\";\n  Filter[Filter[\"Panel\"] = 2] = \"Panel\";\n  Filter[Filter[\"Box\"] = 4] = \"Box\";\n  Filter[Filter[\"Docked\"] = 8] = \"Docked\";\n  Filter[Filter[\"Floated\"] = 16] = \"Floated\";\n  Filter[Filter[\"Windowed\"] = 32] = \"Windowed\";\n  Filter[Filter[\"Max\"] = 64] = \"Max\";\n  Filter[Filter[\"EveryWhere\"] = 120] = \"EveryWhere\";\n  Filter[Filter[\"AnyTab\"] = 121] = \"AnyTab\";\n  Filter[Filter[\"AnyPanel\"] = 122] = \"AnyPanel\";\n  Filter[Filter[\"AnyTabPanel\"] = 123] = \"AnyTabPanel\";\n  Filter[Filter[\"All\"] = 127] = \"All\";\n})(Filter || (Filter = {}));\nexport function find(layout, id) {\n  let filter = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Filter.AnyTabPanel;\n  let result;\n  if (filter & Filter.Docked) {\n    result = findInBox(layout.dockbox, id, filter);\n  }\n  if (result) return result;\n  if (filter & Filter.Floated) {\n    result = findInBox(layout.floatbox, id, filter);\n  }\n  if (result) return result;\n  if (filter & Filter.Windowed) {\n    result = findInBox(layout.windowbox, id, filter);\n  }\n  if (result) return result;\n  if (filter & Filter.Max) {\n    result = findInBox(layout.maxbox, id, filter);\n  }\n  return result;\n}\nexport function addNextToTab(layout, source, target, direction) {\n  let pos = target.parent.tabs.indexOf(target);\n  if (pos >= 0) {\n    if (direction === 'after-tab') {\n      ++pos;\n    }\n    return addTabToPanel(layout, source, target.parent, pos);\n  }\n  return layout;\n}\nexport function addTabToPanel(layout, source, panel) {\n  let idx = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : -1;\n  if (idx === -1) {\n    idx = panel.tabs.length;\n  }\n  let tabs;\n  let activeId;\n  if ('tabs' in source) {\n    // source is PanelData\n    tabs = source.tabs;\n    activeId = source.activeId;\n  } else {\n    // source is TabData\n    tabs = [source];\n  }\n  if (tabs.length) {\n    let newPanel = clone(panel);\n    newPanel.tabs.splice(idx, 0, ...tabs);\n    newPanel.activeId = tabs[tabs.length - 1].id;\n    for (let tab of tabs) {\n      tab.parent = newPanel;\n    }\n    if (activeId) {\n      newPanel.activeId = activeId;\n    }\n    layout = replacePanel(layout, panel, newPanel);\n  }\n  return layout;\n}\nexport function converToPanel(source) {\n  if ('tabs' in source) {\n    // source is already PanelData\n    return source;\n  } else {\n    let newPanel = {\n      tabs: [source],\n      group: source.group,\n      activeId: source.id\n    };\n    source.parent = newPanel;\n    return newPanel;\n  }\n}\nexport function dockPanelToPanel(layout, newPanel, panel, direction) {\n  let box = panel.parent;\n  let dockMode = direction === 'left' || direction === 'right' ? 'horizontal' : 'vertical';\n  let afterPanel = direction === 'bottom' || direction === 'right';\n  let pos = box.children.indexOf(panel);\n  if (pos >= 0) {\n    let newBox = clone(box);\n    if (dockMode === box.mode) {\n      if (afterPanel) {\n        ++pos;\n      }\n      panel.size *= 0.5;\n      newPanel.size = panel.size;\n      newBox.children.splice(pos, 0, newPanel);\n    } else {\n      let newChildBox = {\n        mode: dockMode,\n        children: []\n      };\n      newChildBox.size = panel.size;\n      if (afterPanel) {\n        newChildBox.children = [panel, newPanel];\n      } else {\n        newChildBox.children = [newPanel, panel];\n      }\n      panel.parent = newChildBox;\n      panel.size = 200;\n      newPanel.parent = newChildBox;\n      newPanel.size = 200;\n      newBox.children[pos] = newChildBox;\n      newChildBox.parent = newBox;\n    }\n    return replaceBox(layout, box, newBox);\n  }\n  return layout;\n}\nexport function dockPanelToBox(layout, newPanel, box, direction) {\n  let parentBox = box.parent;\n  let dockMode = direction === 'left' || direction === 'right' ? 'horizontal' : 'vertical';\n  let afterPanel = direction === 'bottom' || direction === 'right';\n  if (parentBox) {\n    let pos = parentBox.children.indexOf(box);\n    if (pos >= 0) {\n      let newParentBox = clone(parentBox);\n      if (dockMode === parentBox.mode) {\n        if (afterPanel) {\n          ++pos;\n        }\n        newPanel.size = box.size * 0.3;\n        box.size *= 0.7;\n        newParentBox.children.splice(pos, 0, newPanel);\n      } else {\n        let newChildBox = {\n          mode: dockMode,\n          children: []\n        };\n        newChildBox.size = box.size;\n        if (afterPanel) {\n          newChildBox.children = [box, newPanel];\n        } else {\n          newChildBox.children = [newPanel, box];\n        }\n        box.parent = newChildBox;\n        box.size = 280;\n        newPanel.parent = newChildBox;\n        newPanel.size = 120;\n        newParentBox.children[pos] = newChildBox;\n      }\n      return replaceBox(layout, parentBox, newParentBox);\n    }\n  } else if (box === layout.dockbox) {\n    let newBox = clone(box);\n    if (dockMode === box.mode) {\n      let pos = 0;\n      if (afterPanel) {\n        pos = newBox.children.length;\n      }\n      newPanel.size = box.size * 0.3;\n      box.size *= 0.7;\n      newBox.children.splice(pos, 0, newPanel);\n      return replaceBox(layout, box, newBox);\n    } else {\n      // replace root dockbox\n      let newDockBox = {\n        mode: dockMode,\n        children: []\n      };\n      newDockBox.size = box.size;\n      if (afterPanel) {\n        newDockBox.children = [newBox, newPanel];\n      } else {\n        newDockBox.children = [newPanel, newBox];\n      }\n      newBox.size = 280;\n      newPanel.size = 120;\n      return replaceBox(layout, box, newDockBox);\n    }\n  } else if (box === layout.maxbox) {\n    let newBox = clone(box);\n    newBox.children.push(newPanel);\n    return replaceBox(layout, box, newBox);\n  }\n  return layout;\n}\nexport function floatPanel(layout, newPanel, rect) {\n  let newBox = clone(layout.floatbox);\n  if (rect) {\n    newPanel.x = rect.left;\n    newPanel.y = rect.top;\n    newPanel.w = rect.width;\n    newPanel.h = rect.height;\n  }\n  newBox.children.push(newPanel);\n  return replaceBox(layout, layout.floatbox, newBox);\n}\nexport function panelToWindow(layout, newPanel) {\n  let newBox = clone(layout.windowbox);\n  newBox.children.push(newPanel);\n  return replaceBox(layout, layout.windowbox, newBox);\n}\nexport function removeFromLayout(layout, source) {\n  if (source) {\n    let panelData;\n    if ('tabs' in source) {\n      panelData = source;\n      layout = removePanel(layout, panelData);\n    } else {\n      panelData = source.parent;\n      layout = removeTab(layout, source);\n    }\n    if (panelData && panelData.parent && panelData.parent.mode === 'maximize') {\n      let newPanel = layout.maxbox.children[0];\n      if (!newPanel || newPanel.tabs.length === 0 && !newPanel.panelLock) {\n        // max panel is gone, remove the place holder\n        let placeHolder = find(layout, maximePlaceHolderId);\n        if (placeHolder) {\n          return removePanel(layout, placeHolder);\n        }\n      }\n    }\n  }\n  return layout;\n}\nfunction removePanel(layout, panel) {\n  let box = panel.parent;\n  if (box) {\n    let pos = box.children.indexOf(panel);\n    if (pos >= 0) {\n      let newBox = clone(box);\n      newBox.children.splice(pos, 1);\n      return replaceBox(layout, box, newBox);\n    }\n  }\n  return layout;\n}\nfunction removeTab(layout, tab) {\n  let panel = tab.parent;\n  if (panel) {\n    let pos = panel.tabs.indexOf(tab);\n    if (pos >= 0) {\n      let newPanel = clone(panel);\n      newPanel.tabs.splice(pos, 1);\n      if (newPanel.activeId === tab.id) {\n        // update selection id\n        if (newPanel.tabs.length > pos) {\n          newPanel.activeId = newPanel.tabs[pos].id;\n        } else if (newPanel.tabs.length) {\n          newPanel.activeId = newPanel.tabs[0].id;\n        }\n      }\n      return replacePanel(layout, panel, newPanel);\n    }\n  }\n  return layout;\n}\nexport function moveToFront(layout, source) {\n  if (source) {\n    let panelData;\n    let needUpdate = false;\n    let changes = {};\n    if ('tabs' in source) {\n      panelData = source;\n    } else {\n      panelData = source.parent;\n      if (panelData.activeId !== source.id) {\n        // move tab to front\n        changes.activeId = source.id;\n        needUpdate = true;\n      }\n    }\n    if (panelData && panelData.parent && panelData.parent.mode === 'float') {\n      // move float panel to front\n      let newZ = nextZIndex(panelData.z);\n      if (newZ !== panelData.z) {\n        changes.z = newZ;\n        needUpdate = true;\n      }\n    }\n    if (needUpdate) {\n      layout = replacePanel(layout, panelData, clone(panelData, changes));\n    }\n  }\n  return layout;\n}\n// maximize or restore the panel\nexport function maximize(layout, source) {\n  if (source) {\n    if ('tabs' in source) {\n      if (source.parent.mode === 'maximize') {\n        return restorePanel(layout, source);\n      } else {\n        return maximizePanel(layout, source);\n      }\n    } else {\n      return maximizeTab(layout, source);\n    }\n  }\n  return layout;\n}\nfunction maximizePanel(layout, panel) {\n  let maxbox = layout.maxbox;\n  if (maxbox.children.length) {\n    // invalid maximize\n    return layout;\n  }\n  let placeHodlerPanel = Object.assign(Object.assign({}, panel), {\n    id: maximePlaceHolderId,\n    tabs: [],\n    panelLock: {}\n  });\n  layout = replacePanel(layout, panel, placeHodlerPanel);\n  layout = dockPanelToBox(layout, panel, layout.maxbox, 'middle');\n  return layout;\n}\nfunction restorePanel(layout, panel) {\n  layout = removePanel(layout, panel);\n  let placeHolder = find(layout, maximePlaceHolderId);\n  if (placeHolder) {\n    let {\n      x,\n      y,\n      z,\n      w,\n      h\n    } = placeHolder;\n    panel = Object.assign(Object.assign({}, panel), {\n      x,\n      y,\n      z,\n      w,\n      h\n    });\n    return replacePanel(layout, placeHolder, panel);\n  } else {\n    return dockPanelToBox(layout, panel, layout.dockbox, 'right');\n  }\n}\nfunction maximizeTab(layout, tab) {\n  // TODO to be implemented\n  return layout;\n}\n// move float panel into the screen\nexport function fixFloatPanelPos(layout, layoutWidth, layoutHeight) {\n  let layoutChanged = false;\n  if (layout && layout.floatbox && layoutWidth > 200 && layoutHeight > 200) {\n    let newFloatChildren = layout.floatbox.children.concat();\n    for (let i = 0; i < newFloatChildren.length; ++i) {\n      let panel = newFloatChildren[i];\n      let panelChange = {};\n      if (panel.w > layoutWidth) {\n        panelChange.w = layoutWidth;\n      }\n      if (panel.h > layoutHeight) {\n        panelChange.h = layoutHeight;\n      }\n      if (panel.y > layoutHeight - 16) {\n        panelChange.y = Math.max(layoutHeight - 16 - (panel.h >> 1), 0);\n      } else if (panel.y < 0) {\n        panelChange.y = 0;\n      }\n      if (panel.x + panel.w < 16) {\n        panelChange.x = 16 - (panel.w >> 1);\n      } else if (panel.x > layoutWidth - 16) {\n        panelChange.x = layoutWidth - 16 - (panel.w >> 1);\n      }\n      if (Object.keys(panelChange).length) {\n        newFloatChildren[i] = clone(panel, panelChange);\n        layoutChanged = true;\n      }\n    }\n    if (layoutChanged) {\n      let newBox = clone(layout.floatbox);\n      newBox.children = newFloatChildren;\n      return replaceBox(layout, layout.floatbox, newBox);\n    }\n  }\n  return layout;\n}\nexport function fixLayoutData(layout, loadTab) {\n  function fixpanelOrBox(d) {\n    if (d.id == null) {\n      d.id = nextId();\n    } else if (d.id.startsWith('+')) {\n      let idnum = Number(d.id);\n      if (idnum > _idCount) {\n        // make sure generated id is unique\n        _idCount = idnum;\n      }\n    }\n    if (!(d.size >= 0)) {\n      d.size = 200;\n    }\n    d.minWidth = 0;\n    d.minHeight = 0;\n  }\n  function fixPanelData(panel) {\n    fixpanelOrBox(panel);\n    let findActiveId = false;\n    if (loadTab) {\n      for (let i = 0; i < panel.tabs.length; ++i) {\n        panel.tabs[i] = loadTab(panel.tabs[i]);\n      }\n    }\n    for (let child of panel.tabs) {\n      child.parent = panel;\n      if (child.id === panel.activeId) {\n        findActiveId = true;\n      }\n      if (child.minWidth > panel.minWidth) panel.minWidth = child.minWidth;\n      if (child.minHeight > panel.minHeight) panel.minHeight = child.minHeight;\n    }\n    if (!findActiveId && panel.tabs.length) {\n      panel.activeId = panel.tabs[0].id;\n    }\n    if (panel.minWidth <= 0) {\n      panel.minWidth = 1;\n    }\n    if (panel.minHeight <= 0) {\n      panel.minHeight = 1;\n    }\n    if (panel.panelLock) {\n      if (panel.minWidth < panel.panelLock.minWidth) {\n        panel.minWidth = panel.panelLock.minWidth;\n      }\n      if (panel.minHeight < panel.panelLock.minHeight) {\n        panel.minHeight = panel.panelLock.minHeight;\n      }\n    }\n    if (panel.group == null && panel.tabs.length) {\n      panel.group = panel.tabs[0].group;\n    }\n    if (panel.z > _zCount) {\n      // make sure next zIndex is on top\n      _zCount = panel.z;\n    }\n    return panel;\n  }\n  function fixBoxData(box) {\n    fixpanelOrBox(box);\n    for (let i = 0; i < box.children.length; ++i) {\n      let child = box.children[i];\n      child.parent = box;\n      if ('children' in child) {\n        fixBoxData(child);\n        if (child.children.length === 0) {\n          // remove box with no child\n          box.children.splice(i, 1);\n          --i;\n        } else if (child.children.length === 1) {\n          // box with one child should be merged back to parent box\n          let subChild = child.children[0];\n          if (subChild.mode === box.mode) {\n            // sub child is another box that can be merged into current box\n            let totalSubSize = 0;\n            for (let subsubChild of subChild.children) {\n              totalSubSize += subsubChild.size;\n            }\n            let sizeScale = child.size / totalSubSize;\n            for (let subsubChild of subChild.children) {\n              subsubChild.size *= sizeScale;\n            }\n            // merge children up\n            box.children.splice(i, 1, ...subChild.children);\n          } else {\n            // sub child can be moved up one layer\n            subChild.size = child.size;\n            box.children[i] = subChild;\n          }\n          --i;\n        }\n      } else if ('tabs' in child) {\n        fixPanelData(child);\n        if (child.tabs.length === 0) {\n          // remove panel with no tab\n          if (!child.panelLock) {\n            box.children.splice(i, 1);\n            --i;\n          } else if (child.group === placeHolderStyle && (box.children.length > 1 || box.parent)) {\n            // remove placeHolder Group\n            box.children.splice(i, 1);\n            --i;\n          }\n        }\n      }\n      // merge min size\n      switch (box.mode) {\n        case 'horizontal':\n          if (child.minWidth > 0) box.minWidth += child.minWidth;\n          if (child.minHeight > box.minHeight) box.minHeight = child.minHeight;\n          break;\n        case 'vertical':\n          if (child.minWidth > box.minWidth) box.minWidth = child.minWidth;\n          if (child.minHeight > 0) box.minHeight += child.minHeight;\n          break;\n      }\n    }\n    // add divider size\n    if (box.children.length > 1) {\n      switch (box.mode) {\n        case 'horizontal':\n          box.minWidth += (box.children.length - 1) * 4;\n          break;\n        case 'vertical':\n          box.minHeight += (box.children.length - 1) * 4;\n          break;\n      }\n    }\n    return box;\n  }\n  if (layout.floatbox) {\n    layout.floatbox.mode = 'float';\n  } else {\n    layout.floatbox = {\n      mode: 'float',\n      children: [],\n      size: 1\n    };\n  }\n  if (layout.windowbox) {\n    layout.windowbox.mode = 'window';\n  } else {\n    layout.windowbox = {\n      mode: 'window',\n      children: [],\n      size: 1\n    };\n  }\n  if (layout.maxbox) {\n    layout.maxbox.mode = 'maximize';\n  } else {\n    layout.maxbox = {\n      mode: 'maximize',\n      children: [],\n      size: 1\n    };\n  }\n  fixBoxData(layout.dockbox);\n  fixBoxData(layout.floatbox);\n  fixBoxData(layout.windowbox);\n  fixBoxData(layout.maxbox);\n  if (layout.dockbox.children.length === 0) {\n    // add place holder panel when root box is empty\n    let newPanel = {\n      id: '+0',\n      group: placeHolderStyle,\n      panelLock: {},\n      size: 200,\n      tabs: []\n    };\n    newPanel.parent = layout.dockbox;\n    layout.dockbox.children.push(newPanel);\n  } else {\n    // merge and replace root box when box has only one child\n    while (layout.dockbox.children.length === 1 && 'children' in layout.dockbox.children[0]) {\n      let newDockBox = clone(layout.dockbox.children[0]);\n      layout.dockbox = newDockBox;\n      for (let child of newDockBox.children) {\n        child.parent = newDockBox;\n      }\n    }\n  }\n  layout.dockbox.parent = null;\n  layout.floatbox.parent = null;\n  layout.windowbox.parent = null;\n  layout.maxbox.parent = null;\n  clearObjectCache();\n  return layout;\n}\nfunction replacePanel(layout, panel, newPanel) {\n  for (let tab of newPanel.tabs) {\n    tab.parent = newPanel;\n  }\n  let box = panel.parent;\n  if (box) {\n    let pos = box.children.indexOf(panel);\n    if (pos >= 0) {\n      let newBox = clone(box);\n      newBox.children[pos] = newPanel;\n      return replaceBox(layout, box, newBox);\n    }\n  }\n  return layout;\n}\nfunction replaceBox(layout, box, newBox) {\n  for (let child of newBox.children) {\n    child.parent = newBox;\n  }\n  let parentBox = box.parent;\n  if (parentBox) {\n    let pos = parentBox.children.indexOf(box);\n    if (pos >= 0) {\n      let newParentBox = clone(parentBox);\n      newParentBox.children[pos] = newBox;\n      return replaceBox(layout, parentBox, newParentBox);\n    }\n  } else {\n    if (box.id === layout.dockbox.id || box === layout.dockbox) {\n      return Object.assign(Object.assign({}, layout), {\n        dockbox: newBox\n      });\n    } else if (box.id === layout.floatbox.id || box === layout.floatbox) {\n      return Object.assign(Object.assign({}, layout), {\n        floatbox: newBox\n      });\n    } else if (box.id === layout.windowbox.id || box === layout.windowbox) {\n      return Object.assign(Object.assign({}, layout), {\n        windowbox: newBox\n      });\n    } else if (box.id === layout.maxbox.id || box === layout.maxbox) {\n      return Object.assign(Object.assign({}, layout), {\n        maxbox: newBox\n      });\n    }\n  }\n  return layout;\n}\nexport function getFloatPanelSize(panel, tabGroup) {\n  if (!panel) {\n    return [300, 300];\n  }\n  let panelWidth = panel.offsetWidth;\n  let panelHeight = panel.offsetHeight;\n  let [minWidth, maxWidth] = tabGroup.preferredFloatWidth || [100, 600];\n  let [minHeight, maxHeight] = tabGroup.preferredFloatHeight || [50, 500];\n  if (!(panelWidth >= minWidth)) {\n    panelWidth = minWidth;\n  } else if (!(panelWidth <= maxWidth)) {\n    panelWidth = maxWidth;\n  }\n  if (!(panelHeight >= minHeight)) {\n    panelHeight = minHeight;\n  } else if (!(panelHeight <= maxHeight)) {\n    panelHeight = maxHeight;\n  }\n  return [panelWidth, panelHeight];\n}\nexport function findNearestPanel(rectFrom, rectTo, direction) {\n  let distance = -1;\n  let overlap = -1;\n  let alignment = 0;\n  switch (direction) {\n    case 'ArrowUp':\n      {\n        distance = rectFrom.top - rectTo.bottom + rectFrom.height;\n        overlap = Math.min(rectFrom.right, rectTo.right) - Math.max(rectFrom.left, rectTo.left);\n        break;\n      }\n    case 'ArrowDown':\n      {\n        distance = rectTo.top - rectFrom.bottom + rectFrom.height;\n        overlap = Math.min(rectFrom.right, rectTo.right) - Math.max(rectFrom.left, rectTo.left);\n        break;\n      }\n    case 'ArrowLeft':\n      {\n        distance = rectFrom.left - rectTo.right + rectFrom.width;\n        overlap = Math.min(rectFrom.bottom, rectTo.bottom) - Math.max(rectFrom.top, rectTo.top);\n        alignment = Math.abs(rectFrom.top - rectTo.top);\n        break;\n      }\n    case 'ArrowRight':\n      {\n        distance = rectTo.left - rectFrom.right + rectFrom.width;\n        overlap = Math.min(rectFrom.bottom, rectTo.bottom) - Math.max(rectFrom.top, rectTo.top);\n        alignment = Math.abs(rectFrom.top - rectTo.top);\n        break;\n      }\n  }\n  if (distance < 0 || overlap <= 0) {\n    return -1;\n  }\n  return distance * (alignment + 1) - overlap * 0.001;\n}","map":{"version":3,"names":["maximePlaceHolderId","placeHolderStyle","_watchObjectChange","WeakMap","getUpdatedObject","obj","result","get","clearObjectCache","clone","value","extra","newValue","Object","assign","Array","isArray","tabs","concat","children","set","_idCount","nextId","_zCount","nextZIndex","current","findInPanel","panel","id","filter","Filter","Panel","Tab","tab","findInBox","box","Box","child","find","layout","arguments","length","undefined","AnyTabPanel","Docked","dockbox","Floated","floatbox","Windowed","windowbox","Max","maxbox","addNextToTab","source","target","direction","pos","parent","indexOf","addTabToPanel","idx","activeId","newPanel","splice","replacePanel","converToPanel","group","dockPanelToPanel","dockMode","afterPanel","newBox","mode","size","newChildBox","replaceBox","dockPanelToBox","parentBox","newParentBox","newDockBox","push","floatPanel","rect","x","left","y","top","w","width","h","height","panelToWindow","removeFromLayout","panelData","removePanel","removeTab","panelLock","placeHolder","moveToFront","needUpdate","changes","newZ","z","maximize","restorePanel","maximizePanel","maximizeTab","placeHodlerPanel","fixFloatPanelPos","layoutWidth","layoutHeight","layoutChanged","newFloatChildren","i","panelChange","Math","max","keys","fixLayoutData","loadTab","fixpanelOrBox","d","startsWith","idnum","Number","minWidth","minHeight","fixPanelData","findActiveId","fixBoxData","subChild","totalSubSize","subsubChild","sizeScale","getFloatPanelSize","tabGroup","panelWidth","offsetWidth","panelHeight","offsetHeight","maxWidth","preferredFloatWidth","maxHeight","preferredFloatHeight","findNearestPanel","rectFrom","rectTo","distance","overlap","alignment","bottom","min","right","abs"],"sources":["C:/d/Programming/web/jodel-mde/node_modules/rc-dock/es/Algorithm.js"],"sourcesContent":["import { maximePlaceHolderId, placeHolderStyle } from \"./DockData\";\nlet _watchObjectChange = new WeakMap();\nexport function getUpdatedObject(obj) {\n    let result = _watchObjectChange.get(obj);\n    if (result) {\n        return getUpdatedObject(result);\n    }\n    return obj;\n}\nfunction clearObjectCache() {\n    _watchObjectChange = new WeakMap();\n}\nfunction clone(value, extra) {\n    let newValue = Object.assign(Object.assign({}, value), extra);\n    if (Array.isArray(newValue.tabs)) {\n        newValue.tabs = newValue.tabs.concat();\n    }\n    if (Array.isArray(newValue.children)) {\n        newValue.children = newValue.children.concat();\n    }\n    _watchObjectChange.set(value, newValue);\n    return newValue;\n}\nlet _idCount = 0;\nexport function nextId() {\n    ++_idCount;\n    return `+${_idCount}`;\n}\nlet _zCount = 0;\nexport function nextZIndex(current) {\n    if (current === _zCount) {\n        // already the top\n        return current;\n    }\n    return ++_zCount;\n}\nfunction findInPanel(panel, id, filter) {\n    if (panel.id === id && (filter & Filter.Panel)) {\n        return panel;\n    }\n    if (filter & Filter.Tab) {\n        for (let tab of panel.tabs) {\n            if (tab.id === id) {\n                return tab;\n            }\n        }\n    }\n    return null;\n}\nfunction findInBox(box, id, filter) {\n    let result;\n    if ((filter | Filter.Box) && box.id === id) {\n        return box;\n    }\n    for (let child of box.children) {\n        if ('children' in child) {\n            if (result = findInBox(child, id, filter)) {\n                break;\n            }\n        }\n        else if ('tabs' in child) {\n            if (result = findInPanel(child, id, filter)) {\n                break;\n            }\n        }\n    }\n    return result;\n}\nexport var Filter;\n(function (Filter) {\n    Filter[Filter[\"Tab\"] = 1] = \"Tab\";\n    Filter[Filter[\"Panel\"] = 2] = \"Panel\";\n    Filter[Filter[\"Box\"] = 4] = \"Box\";\n    Filter[Filter[\"Docked\"] = 8] = \"Docked\";\n    Filter[Filter[\"Floated\"] = 16] = \"Floated\";\n    Filter[Filter[\"Windowed\"] = 32] = \"Windowed\";\n    Filter[Filter[\"Max\"] = 64] = \"Max\";\n    Filter[Filter[\"EveryWhere\"] = 120] = \"EveryWhere\";\n    Filter[Filter[\"AnyTab\"] = 121] = \"AnyTab\";\n    Filter[Filter[\"AnyPanel\"] = 122] = \"AnyPanel\";\n    Filter[Filter[\"AnyTabPanel\"] = 123] = \"AnyTabPanel\";\n    Filter[Filter[\"All\"] = 127] = \"All\";\n})(Filter || (Filter = {}));\nexport function find(layout, id, filter = Filter.AnyTabPanel) {\n    let result;\n    if (filter & Filter.Docked) {\n        result = findInBox(layout.dockbox, id, filter);\n    }\n    if (result)\n        return result;\n    if (filter & Filter.Floated) {\n        result = findInBox(layout.floatbox, id, filter);\n    }\n    if (result)\n        return result;\n    if (filter & Filter.Windowed) {\n        result = findInBox(layout.windowbox, id, filter);\n    }\n    if (result)\n        return result;\n    if (filter & Filter.Max) {\n        result = findInBox(layout.maxbox, id, filter);\n    }\n    return result;\n}\nexport function addNextToTab(layout, source, target, direction) {\n    let pos = target.parent.tabs.indexOf(target);\n    if (pos >= 0) {\n        if (direction === 'after-tab') {\n            ++pos;\n        }\n        return addTabToPanel(layout, source, target.parent, pos);\n    }\n    return layout;\n}\nexport function addTabToPanel(layout, source, panel, idx = -1) {\n    if (idx === -1) {\n        idx = panel.tabs.length;\n    }\n    let tabs;\n    let activeId;\n    if ('tabs' in source) {\n        // source is PanelData\n        tabs = source.tabs;\n        activeId = source.activeId;\n    }\n    else {\n        // source is TabData\n        tabs = [source];\n    }\n    if (tabs.length) {\n        let newPanel = clone(panel);\n        newPanel.tabs.splice(idx, 0, ...tabs);\n        newPanel.activeId = tabs[tabs.length - 1].id;\n        for (let tab of tabs) {\n            tab.parent = newPanel;\n        }\n        if (activeId) {\n            newPanel.activeId = activeId;\n        }\n        layout = replacePanel(layout, panel, newPanel);\n    }\n    return layout;\n}\nexport function converToPanel(source) {\n    if ('tabs' in source) {\n        // source is already PanelData\n        return source;\n    }\n    else {\n        let newPanel = { tabs: [source], group: source.group, activeId: source.id };\n        source.parent = newPanel;\n        return newPanel;\n    }\n}\nexport function dockPanelToPanel(layout, newPanel, panel, direction) {\n    let box = panel.parent;\n    let dockMode = (direction === 'left' || direction === 'right') ? 'horizontal' : 'vertical';\n    let afterPanel = (direction === 'bottom' || direction === 'right');\n    let pos = box.children.indexOf(panel);\n    if (pos >= 0) {\n        let newBox = clone(box);\n        if (dockMode === box.mode) {\n            if (afterPanel) {\n                ++pos;\n            }\n            panel.size *= 0.5;\n            newPanel.size = panel.size;\n            newBox.children.splice(pos, 0, newPanel);\n        }\n        else {\n            let newChildBox = { mode: dockMode, children: [] };\n            newChildBox.size = panel.size;\n            if (afterPanel) {\n                newChildBox.children = [panel, newPanel];\n            }\n            else {\n                newChildBox.children = [newPanel, panel];\n            }\n            panel.parent = newChildBox;\n            panel.size = 200;\n            newPanel.parent = newChildBox;\n            newPanel.size = 200;\n            newBox.children[pos] = newChildBox;\n            newChildBox.parent = newBox;\n        }\n        return replaceBox(layout, box, newBox);\n    }\n    return layout;\n}\nexport function dockPanelToBox(layout, newPanel, box, direction) {\n    let parentBox = box.parent;\n    let dockMode = (direction === 'left' || direction === 'right') ? 'horizontal' : 'vertical';\n    let afterPanel = (direction === 'bottom' || direction === 'right');\n    if (parentBox) {\n        let pos = parentBox.children.indexOf(box);\n        if (pos >= 0) {\n            let newParentBox = clone(parentBox);\n            if (dockMode === parentBox.mode) {\n                if (afterPanel) {\n                    ++pos;\n                }\n                newPanel.size = box.size * 0.3;\n                box.size *= 0.7;\n                newParentBox.children.splice(pos, 0, newPanel);\n            }\n            else {\n                let newChildBox = { mode: dockMode, children: [] };\n                newChildBox.size = box.size;\n                if (afterPanel) {\n                    newChildBox.children = [box, newPanel];\n                }\n                else {\n                    newChildBox.children = [newPanel, box];\n                }\n                box.parent = newChildBox;\n                box.size = 280;\n                newPanel.parent = newChildBox;\n                newPanel.size = 120;\n                newParentBox.children[pos] = newChildBox;\n            }\n            return replaceBox(layout, parentBox, newParentBox);\n        }\n    }\n    else if (box === layout.dockbox) {\n        let newBox = clone(box);\n        if (dockMode === box.mode) {\n            let pos = 0;\n            if (afterPanel) {\n                pos = newBox.children.length;\n            }\n            newPanel.size = box.size * 0.3;\n            box.size *= 0.7;\n            newBox.children.splice(pos, 0, newPanel);\n            return replaceBox(layout, box, newBox);\n        }\n        else {\n            // replace root dockbox\n            let newDockBox = { mode: dockMode, children: [] };\n            newDockBox.size = box.size;\n            if (afterPanel) {\n                newDockBox.children = [newBox, newPanel];\n            }\n            else {\n                newDockBox.children = [newPanel, newBox];\n            }\n            newBox.size = 280;\n            newPanel.size = 120;\n            return replaceBox(layout, box, newDockBox);\n        }\n    }\n    else if (box === layout.maxbox) {\n        let newBox = clone(box);\n        newBox.children.push(newPanel);\n        return replaceBox(layout, box, newBox);\n    }\n    return layout;\n}\nexport function floatPanel(layout, newPanel, rect) {\n    let newBox = clone(layout.floatbox);\n    if (rect) {\n        newPanel.x = rect.left;\n        newPanel.y = rect.top;\n        newPanel.w = rect.width;\n        newPanel.h = rect.height;\n    }\n    newBox.children.push(newPanel);\n    return replaceBox(layout, layout.floatbox, newBox);\n}\nexport function panelToWindow(layout, newPanel) {\n    let newBox = clone(layout.windowbox);\n    newBox.children.push(newPanel);\n    return replaceBox(layout, layout.windowbox, newBox);\n}\nexport function removeFromLayout(layout, source) {\n    if (source) {\n        let panelData;\n        if ('tabs' in source) {\n            panelData = source;\n            layout = removePanel(layout, panelData);\n        }\n        else {\n            panelData = source.parent;\n            layout = removeTab(layout, source);\n        }\n        if (panelData && panelData.parent && panelData.parent.mode === 'maximize') {\n            let newPanel = layout.maxbox.children[0];\n            if (!newPanel || (newPanel.tabs.length === 0 && !newPanel.panelLock)) {\n                // max panel is gone, remove the place holder\n                let placeHolder = find(layout, maximePlaceHolderId);\n                if (placeHolder) {\n                    return removePanel(layout, placeHolder);\n                }\n            }\n        }\n    }\n    return layout;\n}\nfunction removePanel(layout, panel) {\n    let box = panel.parent;\n    if (box) {\n        let pos = box.children.indexOf(panel);\n        if (pos >= 0) {\n            let newBox = clone(box);\n            newBox.children.splice(pos, 1);\n            return replaceBox(layout, box, newBox);\n        }\n    }\n    return layout;\n}\nfunction removeTab(layout, tab) {\n    let panel = tab.parent;\n    if (panel) {\n        let pos = panel.tabs.indexOf(tab);\n        if (pos >= 0) {\n            let newPanel = clone(panel);\n            newPanel.tabs.splice(pos, 1);\n            if (newPanel.activeId === tab.id) {\n                // update selection id\n                if (newPanel.tabs.length > pos) {\n                    newPanel.activeId = newPanel.tabs[pos].id;\n                }\n                else if (newPanel.tabs.length) {\n                    newPanel.activeId = newPanel.tabs[0].id;\n                }\n            }\n            return replacePanel(layout, panel, newPanel);\n        }\n    }\n    return layout;\n}\nexport function moveToFront(layout, source) {\n    if (source) {\n        let panelData;\n        let needUpdate = false;\n        let changes = {};\n        if ('tabs' in source) {\n            panelData = source;\n        }\n        else {\n            panelData = source.parent;\n            if (panelData.activeId !== source.id) {\n                // move tab to front\n                changes.activeId = source.id;\n                needUpdate = true;\n            }\n        }\n        if (panelData && panelData.parent && panelData.parent.mode === 'float') {\n            // move float panel to front\n            let newZ = nextZIndex(panelData.z);\n            if (newZ !== panelData.z) {\n                changes.z = newZ;\n                needUpdate = true;\n            }\n        }\n        if (needUpdate) {\n            layout = replacePanel(layout, panelData, clone(panelData, changes));\n        }\n    }\n    return layout;\n}\n// maximize or restore the panel\nexport function maximize(layout, source) {\n    if (source) {\n        if ('tabs' in source) {\n            if (source.parent.mode === 'maximize') {\n                return restorePanel(layout, source);\n            }\n            else {\n                return maximizePanel(layout, source);\n            }\n        }\n        else {\n            return maximizeTab(layout, source);\n        }\n    }\n    return layout;\n}\nfunction maximizePanel(layout, panel) {\n    let maxbox = layout.maxbox;\n    if (maxbox.children.length) {\n        // invalid maximize\n        return layout;\n    }\n    let placeHodlerPanel = Object.assign(Object.assign({}, panel), { id: maximePlaceHolderId, tabs: [], panelLock: {} });\n    layout = replacePanel(layout, panel, placeHodlerPanel);\n    layout = dockPanelToBox(layout, panel, layout.maxbox, 'middle');\n    return layout;\n}\nfunction restorePanel(layout, panel) {\n    layout = removePanel(layout, panel);\n    let placeHolder = find(layout, maximePlaceHolderId);\n    if (placeHolder) {\n        let { x, y, z, w, h } = placeHolder;\n        panel = Object.assign(Object.assign({}, panel), { x, y, z, w, h });\n        return replacePanel(layout, placeHolder, panel);\n    }\n    else {\n        return dockPanelToBox(layout, panel, layout.dockbox, 'right');\n    }\n}\nfunction maximizeTab(layout, tab) {\n    // TODO to be implemented\n    return layout;\n}\n// move float panel into the screen\nexport function fixFloatPanelPos(layout, layoutWidth, layoutHeight) {\n    let layoutChanged = false;\n    if (layout && layout.floatbox && layoutWidth > 200 && layoutHeight > 200) {\n        let newFloatChildren = layout.floatbox.children.concat();\n        for (let i = 0; i < newFloatChildren.length; ++i) {\n            let panel = newFloatChildren[i];\n            let panelChange = {};\n            if (panel.w > layoutWidth) {\n                panelChange.w = layoutWidth;\n            }\n            if (panel.h > layoutHeight) {\n                panelChange.h = layoutHeight;\n            }\n            if (panel.y > layoutHeight - 16) {\n                panelChange.y = Math.max(layoutHeight - 16 - (panel.h >> 1), 0);\n            }\n            else if (panel.y < 0) {\n                panelChange.y = 0;\n            }\n            if (panel.x + panel.w < 16) {\n                panelChange.x = 16 - (panel.w >> 1);\n            }\n            else if (panel.x > layoutWidth - 16) {\n                panelChange.x = layoutWidth - 16 - (panel.w >> 1);\n            }\n            if (Object.keys(panelChange).length) {\n                newFloatChildren[i] = clone(panel, panelChange);\n                layoutChanged = true;\n            }\n        }\n        if (layoutChanged) {\n            let newBox = clone(layout.floatbox);\n            newBox.children = newFloatChildren;\n            return replaceBox(layout, layout.floatbox, newBox);\n        }\n    }\n    return layout;\n}\nexport function fixLayoutData(layout, loadTab) {\n    function fixpanelOrBox(d) {\n        if (d.id == null) {\n            d.id = nextId();\n        }\n        else if (d.id.startsWith('+')) {\n            let idnum = Number(d.id);\n            if (idnum > _idCount) {\n                // make sure generated id is unique\n                _idCount = idnum;\n            }\n        }\n        if (!(d.size >= 0)) {\n            d.size = 200;\n        }\n        d.minWidth = 0;\n        d.minHeight = 0;\n    }\n    function fixPanelData(panel) {\n        fixpanelOrBox(panel);\n        let findActiveId = false;\n        if (loadTab) {\n            for (let i = 0; i < panel.tabs.length; ++i) {\n                panel.tabs[i] = loadTab(panel.tabs[i]);\n            }\n        }\n        for (let child of panel.tabs) {\n            child.parent = panel;\n            if (child.id === panel.activeId) {\n                findActiveId = true;\n            }\n            if (child.minWidth > panel.minWidth)\n                panel.minWidth = child.minWidth;\n            if (child.minHeight > panel.minHeight)\n                panel.minHeight = child.minHeight;\n        }\n        if (!findActiveId && panel.tabs.length) {\n            panel.activeId = panel.tabs[0].id;\n        }\n        if (panel.minWidth <= 0) {\n            panel.minWidth = 1;\n        }\n        if (panel.minHeight <= 0) {\n            panel.minHeight = 1;\n        }\n        if (panel.panelLock) {\n            if (panel.minWidth < panel.panelLock.minWidth) {\n                panel.minWidth = panel.panelLock.minWidth;\n            }\n            if (panel.minHeight < panel.panelLock.minHeight) {\n                panel.minHeight = panel.panelLock.minHeight;\n            }\n        }\n        if (panel.group == null && panel.tabs.length) {\n            panel.group = panel.tabs[0].group;\n        }\n        if (panel.z > _zCount) {\n            // make sure next zIndex is on top\n            _zCount = panel.z;\n        }\n        return panel;\n    }\n    function fixBoxData(box) {\n        fixpanelOrBox(box);\n        for (let i = 0; i < box.children.length; ++i) {\n            let child = box.children[i];\n            child.parent = box;\n            if ('children' in child) {\n                fixBoxData(child);\n                if (child.children.length === 0) {\n                    // remove box with no child\n                    box.children.splice(i, 1);\n                    --i;\n                }\n                else if (child.children.length === 1) {\n                    // box with one child should be merged back to parent box\n                    let subChild = child.children[0];\n                    if (subChild.mode === box.mode) {\n                        // sub child is another box that can be merged into current box\n                        let totalSubSize = 0;\n                        for (let subsubChild of subChild.children) {\n                            totalSubSize += subsubChild.size;\n                        }\n                        let sizeScale = child.size / totalSubSize;\n                        for (let subsubChild of subChild.children) {\n                            subsubChild.size *= sizeScale;\n                        }\n                        // merge children up\n                        box.children.splice(i, 1, ...subChild.children);\n                    }\n                    else {\n                        // sub child can be moved up one layer\n                        subChild.size = child.size;\n                        box.children[i] = subChild;\n                    }\n                    --i;\n                }\n            }\n            else if ('tabs' in child) {\n                fixPanelData(child);\n                if (child.tabs.length === 0) {\n                    // remove panel with no tab\n                    if (!child.panelLock) {\n                        box.children.splice(i, 1);\n                        --i;\n                    }\n                    else if (child.group === placeHolderStyle && (box.children.length > 1 || box.parent)) {\n                        // remove placeHolder Group\n                        box.children.splice(i, 1);\n                        --i;\n                    }\n                }\n            }\n            // merge min size\n            switch (box.mode) {\n                case 'horizontal':\n                    if (child.minWidth > 0)\n                        box.minWidth += child.minWidth;\n                    if (child.minHeight > box.minHeight)\n                        box.minHeight = child.minHeight;\n                    break;\n                case 'vertical':\n                    if (child.minWidth > box.minWidth)\n                        box.minWidth = child.minWidth;\n                    if (child.minHeight > 0)\n                        box.minHeight += child.minHeight;\n                    break;\n            }\n        }\n        // add divider size\n        if (box.children.length > 1) {\n            switch (box.mode) {\n                case 'horizontal':\n                    box.minWidth += (box.children.length - 1) * 4;\n                    break;\n                case 'vertical':\n                    box.minHeight += (box.children.length - 1) * 4;\n                    break;\n            }\n        }\n        return box;\n    }\n    if (layout.floatbox) {\n        layout.floatbox.mode = 'float';\n    }\n    else {\n        layout.floatbox = { mode: 'float', children: [], size: 1 };\n    }\n    if (layout.windowbox) {\n        layout.windowbox.mode = 'window';\n    }\n    else {\n        layout.windowbox = { mode: 'window', children: [], size: 1 };\n    }\n    if (layout.maxbox) {\n        layout.maxbox.mode = 'maximize';\n    }\n    else {\n        layout.maxbox = { mode: 'maximize', children: [], size: 1 };\n    }\n    fixBoxData(layout.dockbox);\n    fixBoxData(layout.floatbox);\n    fixBoxData(layout.windowbox);\n    fixBoxData(layout.maxbox);\n    if (layout.dockbox.children.length === 0) {\n        // add place holder panel when root box is empty\n        let newPanel = { id: '+0', group: placeHolderStyle, panelLock: {}, size: 200, tabs: [] };\n        newPanel.parent = layout.dockbox;\n        layout.dockbox.children.push(newPanel);\n    }\n    else {\n        // merge and replace root box when box has only one child\n        while (layout.dockbox.children.length === 1 && 'children' in layout.dockbox.children[0]) {\n            let newDockBox = clone(layout.dockbox.children[0]);\n            layout.dockbox = newDockBox;\n            for (let child of newDockBox.children) {\n                child.parent = newDockBox;\n            }\n        }\n    }\n    layout.dockbox.parent = null;\n    layout.floatbox.parent = null;\n    layout.windowbox.parent = null;\n    layout.maxbox.parent = null;\n    clearObjectCache();\n    return layout;\n}\nfunction replacePanel(layout, panel, newPanel) {\n    for (let tab of newPanel.tabs) {\n        tab.parent = newPanel;\n    }\n    let box = panel.parent;\n    if (box) {\n        let pos = box.children.indexOf(panel);\n        if (pos >= 0) {\n            let newBox = clone(box);\n            newBox.children[pos] = newPanel;\n            return replaceBox(layout, box, newBox);\n        }\n    }\n    return layout;\n}\nfunction replaceBox(layout, box, newBox) {\n    for (let child of newBox.children) {\n        child.parent = newBox;\n    }\n    let parentBox = box.parent;\n    if (parentBox) {\n        let pos = parentBox.children.indexOf(box);\n        if (pos >= 0) {\n            let newParentBox = clone(parentBox);\n            newParentBox.children[pos] = newBox;\n            return replaceBox(layout, parentBox, newParentBox);\n        }\n    }\n    else {\n        if (box.id === layout.dockbox.id || box === layout.dockbox) {\n            return Object.assign(Object.assign({}, layout), { dockbox: newBox });\n        }\n        else if (box.id === layout.floatbox.id || box === layout.floatbox) {\n            return Object.assign(Object.assign({}, layout), { floatbox: newBox });\n        }\n        else if (box.id === layout.windowbox.id || box === layout.windowbox) {\n            return Object.assign(Object.assign({}, layout), { windowbox: newBox });\n        }\n        else if (box.id === layout.maxbox.id || box === layout.maxbox) {\n            return Object.assign(Object.assign({}, layout), { maxbox: newBox });\n        }\n    }\n    return layout;\n}\nexport function getFloatPanelSize(panel, tabGroup) {\n    if (!panel) {\n        return [300, 300];\n    }\n    let panelWidth = panel.offsetWidth;\n    let panelHeight = panel.offsetHeight;\n    let [minWidth, maxWidth] = tabGroup.preferredFloatWidth || [100, 600];\n    let [minHeight, maxHeight] = tabGroup.preferredFloatHeight || [50, 500];\n    if (!(panelWidth >= minWidth)) {\n        panelWidth = minWidth;\n    }\n    else if (!(panelWidth <= maxWidth)) {\n        panelWidth = maxWidth;\n    }\n    if (!(panelHeight >= minHeight)) {\n        panelHeight = minHeight;\n    }\n    else if (!(panelHeight <= maxHeight)) {\n        panelHeight = maxHeight;\n    }\n    return [panelWidth, panelHeight];\n}\nexport function findNearestPanel(rectFrom, rectTo, direction) {\n    let distance = -1;\n    let overlap = -1;\n    let alignment = 0;\n    switch (direction) {\n        case 'ArrowUp': {\n            distance = rectFrom.top - rectTo.bottom + rectFrom.height;\n            overlap = Math.min(rectFrom.right, rectTo.right) - Math.max(rectFrom.left, rectTo.left);\n            break;\n        }\n        case 'ArrowDown': {\n            distance = rectTo.top - rectFrom.bottom + rectFrom.height;\n            overlap = Math.min(rectFrom.right, rectTo.right) - Math.max(rectFrom.left, rectTo.left);\n            break;\n        }\n        case 'ArrowLeft': {\n            distance = rectFrom.left - rectTo.right + rectFrom.width;\n            overlap = Math.min(rectFrom.bottom, rectTo.bottom) - Math.max(rectFrom.top, rectTo.top);\n            alignment = Math.abs(rectFrom.top - rectTo.top);\n            break;\n        }\n        case 'ArrowRight': {\n            distance = rectTo.left - rectFrom.right + rectFrom.width;\n            overlap = Math.min(rectFrom.bottom, rectTo.bottom) - Math.max(rectFrom.top, rectTo.top);\n            alignment = Math.abs(rectFrom.top - rectTo.top);\n            break;\n        }\n    }\n    if (distance < 0 || overlap <= 0) {\n        return -1;\n    }\n    return distance * (alignment + 1) - overlap * 0.001;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}