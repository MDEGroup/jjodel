{"ast":null,"code":"import React,{useRef}from'react';import{connect}from'react-redux';import{Defaults,Keystrokes,LPointerTargetable,MultiSelect,U,UX}from'../../joiner';import{useStateIfMounted}from'use-state-if-mounted';import'./inputselect.scss';import{Tooltip}from'./Tooltip';import{Fragment as _Fragment}from\"react/jsx-runtime\";import{jsx as _jsx}from\"react/jsx-runtime\";import{jsxs as _jsxs}from\"react/jsx-runtime\";export function getSelectOptions_raw(data,field){if(!data)return[];switch(field){default:case'extends':case'type':case'values':return data.validTargetOptions;}return[];}export function getSelectOptions(data,field,options,children){if(options)return options;// children is auto-filled to empty array even if it is not set explicitly in jsx\nif(Array.isArray(children)&&children.length>0)return children;let ret;switch(field){default:case'extends':case'type':case'values':return data.validTargetsJSX;break;}console.log('msel ret opt',{ret,data,vt:data.validTargetJSX,field});return ret;}/*\r\n    export function getSelectOptions_raw(data: LPointerTargetable, field: string): MultiSelectOptGroup[] {\r\n        if (!data) return [];\r\n        // console.log(\"select options\", {data, field, children, options});\r\n        let returns: LClass[] | undefined;\r\n        let primitives: LClass[] | undefined;\r\n        let classes: LClass[] | undefined;\r\n        let enumerators: LEnumerator[] | undefined;\r\n        let objects: (LObject | LEnumLiteral)[] | undefined;\r\n        let m2classname: string | undefined;\r\n        let hasPrimitives: boolean = false;\r\n        let hasReturnTypes: boolean = false;\r\n        let cname = data.className;\r\n        if (!field) switch(cname) {\r\n            case 'DAttribute':  case 'DReference': case 'DOperation': case 'DParameter': field = 'type'; break;\r\n            case 'DValue': field = 'values'; break;\r\n            case 'DClass': field = 'extends'; break;\r\n        }\r\n    /*\r\n        let newmode = true;\r\n        if (newmode){\r\n            switch(field){\r\n                case 'extends': case 'type': return data.validTargetOptions;\r\n            }\r\n            return [];\r\n        }* /\r\n        switch(field) {\r\n            case 'type':\r\n                let model = (data as LStructuralFeature).model;\r\n                switch (cname) {\r\n                    default: break;\r\n                    case 'DAttribute': enumerators = model.enums; hasPrimitives = true; break;\r\n                    case 'DReference': classes = model.classes; break;\r\n                    case 'DOperation': classes = model.classes; enumerators = model.enums; hasPrimitives = hasReturnTypes = true; break;\r\n                    case 'DParameter': classes = model.classes; enumerators = model.enums; hasPrimitives = true; break;\r\n                }\r\n                break;\r\n            case 'value': case 'values':\r\n                if (cname !== 'DValue') break;\r\n                objects = (data as LValue).validTargets;\r\n                /*\r\n                let m2: LReference | LAttribute | undefined = (data as LValue).instanceof;\r\n                if (!m2) {\r\n                    objects = (data as LValue).model.allSubObjects;\r\n                    break;\r\n                }\r\n                let dm2 = m2.__raw;\r\n                if (dm2.className === \"DAttribute\") break;\r\n                let type: LClass = m2.type as LClass;\r\n                if (!type) break;\r\n                m2classname = type.name;\r\n                let m1modelid = data.model.id;\r\n                objects = (type.allInstances || []).filter( o => o.model.id === m1modelid);* /\r\n        }\r\n        let state: DState | undefined;\r\n        // todo: all this stuff might be better moved in mapstatetoprops, or the select list won't update properly.\r\n        if (hasPrimitives) {\r\n            if (!state) state = store.getState();\r\n            primitives = LPointerTargetable.fromPointer(state.primitiveTypes);\r\n        }\r\n        if (hasReturnTypes) {\r\n            if (!state) state = store.getState();\r\n            returns = LPointerTargetable.fromPointer(state.returnTypes);\r\n        }\r\n\r\n        // console.log(\"select options\", {data, field, returns, primitives, classes, enumerators});\r\n\r\n        let ret:MultiSelectOptGroup[] = [];\r\n        if (returns && returns.length) ret.push({label: 'Defaults', options: returns.map((r, i)=>({value: r.id, label:r.name}))});\r\n        if (primitives && primitives.length) ret.push({label: 'Primitives', options: primitives.map((r, i)=>({value: r.id, label:r.name}))});\r\n        if (enumerators && enumerators.length) ret.push({label: 'Enumerators', options: enumerators.map((r, i)=>({value: r.id, label:r.name}))});\r\n        if (classes && classes.length) ret.push({label: 'Classes#', options: classes.map((r, i)=>({value: r.id, label:r.name}))});\r\n        if (objects && objects.length) ret.push({label: m2classname ? 'Instances of ' + m2classname : \"All objects\", options:\r\n                [{value: undefined as any, label: '_empty_'}, ...objects.map((r, i)=>({value: r.id, label:r.name}))]});\r\n        return ret;\r\n    }\r\n    export function getSelectOptions(data: LPointerTargetable, field: string, options: ReactNode, children?: ReactNode): ReactNode {\r\n        if (options) return options;\r\n        // children is auto-filled to empty array even if it is not set explicitly in jsx\r\n        if (Array.isArray(children) && children.length > 0) return children;\r\n        let ret: ReactNode | undefined;\r\n        let newmode = true;\r\n        if (newmode){\r\n            switch(field){\r\n                case 'extends': case 'type': ret = (data as any).validTargetJSX; break;\r\n            }\r\n            console.log('msel ret opt', {ret, data, vt: (data as any).validTargetJSX, field})\r\n        }\r\n        if (ret) return ret;\r\n        let opts = getSelectOptions_raw(data, field); // old to remove?\r\n        return UX.options(opts); // selectOptionsToJSX(opts);\r\n    }\r\n    function selectOptionsToJSX(ret: MultiSelectOptGroup[]): ReactNode{\r\n        return(\r\n            <>{\r\n                ret.map(optgrp => <optgroup label={optgrp.label}>{\r\n                    optgrp.options.map((e, i) => <option key={i} value={e.value}>{e.label}</option>)\r\n                }</optgroup>).filter(e=>!!e)\r\n            }</>);\r\n    }*/export function InputComponent(props){var _data;const data=props.data;const getter=props.getter;const setter=props.setter;const field=props.field;const oldValue=getter?getter(data,field):data?data[field]:undefined;// !== undefined); ? data[field] : 'undefined'\nlet[value,setValue]=useStateIfMounted(oldValue);const[isTouched,setIsTouched]=useStateIfMounted(false);const inputRef=useRef(null);if(props.tag==='select')value=oldValue;// select does not use state.\nlet serializeValue=function(val){let maxDepth=arguments.length>1&&arguments[1]!==undefined?arguments[1]:1;let currDepth=arguments.length>2&&arguments[2]!==undefined?arguments[2]:0;if(Array.isArray(val)){if(props.isMultiSelect&&currDepth<maxDepth){// return val.map(e => serializeValue(e, maxDepth, currDepth + 1)) as PrimitiveType[];\nreturn val.map(e=>(e===null||e===void 0?void 0:e.id)||e);}if(currDepth<maxDepth)return serializeValue(val[0],maxDepth,currDepth+1);else return undefined;}return(val===null||val===void 0?void 0:val.id)||val;};function valueDidChange(v1,v2){return serializeValue(v1)!==serializeValue(v2);/*\r\n        let rawv1 = v1?.__raw || v1;\r\n        let rawv2 = v2?.__raw || v2;\r\n        if (rawv1 !== v1 || rawv2 !== v2) { return v1?.clonedCounter !== v2?.clonedCounter; }\r\n        return v1 !== v2;*/}// I check if the value that I have in my local state is being edited by other <Input />\nif(props.tag!=='select'&&!isTouched&&valueDidChange(value,oldValue)){setValue(serializeValue(oldValue));setIsTouched(false);}if(!(data&&field||getter&&setter))return/*#__PURE__*/_jsx(_Fragment,{children:\"Either props.data & field or both getter & setter are required.\"});let readOnly;if(props.readonly!==undefined)readOnly=props.readonly;// else if (props.disabled !== undefined) readOnly = props.disabled;\nelse readOnly=props.debugmodee!=='true'&&Defaults.check(data===null||data===void 0?void 0:data.id);let type=props.type?props.type:'text';let subtype=type;switch(type){case'toggle':type='checkbox';subtype='switch';break;case'checkbox3':case'switch':type='checkbox';break;case'slider':type='range';break;}let label=props.jsxLabel||props.label;let postlabel=props.postlabel;let tooltip=(props.tooltip===true?data===null||data===void 0?void 0:(_data=data['__info_of__'+field])===null||_data===void 0?void 0:_data.txt:props.tooltip)||'';let css='';//'my-auto input ';\n//css += (jsxLabel) ? 'ms-1' : (label) ? 'ms-auto' : '';\ncss+=props.hidden?' hidden-input':'';let autosize=props.autosize===undefined?false:props.autosize;// props.type==='text'\ncss+=autosize?' autosize-input':'';const isBoolean=['checkbox','radio'].includes(type);const onChange=evt=>{var _onChange,_ref;(_onChange=(_ref=props).onChange)===null||_onChange===void 0?void 0:_onChange.call(_ref,evt);if(readOnly)return;if(isBoolean){let target=evt.target.checked;if(subtype==='checkbox3'&&!value){target=undefined;}if(setter)setter(target,data,field);else data[field]=target;setValue(target);return;}if(props.tag===\"select\"){confirmValue(evt);}else{//console.log(\"setValue\", {value, nv: getValueFromEvent(evt), evt, ev: evt.target.value});\nsetValue(getValueFromEvent(evt));setIsTouched(true);// I'm editing the element in my local state.\n// the actual set is done in onBlur\n}};const onKeyDown=evt=>{var _onKeyDown,_ref2;(_onKeyDown=(_ref2=props).onKeyDown)===null||_onKeyDown===void 0?void 0:_onKeyDown.call(_ref2,evt);if(props.tag==='select')return;if(evt.key===Keystrokes.enter)confirmValue(evt);if(evt.key===Keystrokes.escape){const oldValue=getter?getter(data,field):data[field];writeHtmlValueFromEvent(evt,oldValue);setValue(serializeValue(oldValue));setIsTouched(false);evt.target.blur();// to optimize: probably can remove a large part of this function because this should trigger blur event as well. or move \"change\" event contents here\n// optimize 2: memoize the whole component, so it won't update unless the displayed value changed. this would also fix cursor going to input end when pressing enter.\n}};const getValueFromEvent=evt=>{switch(props.tag){case\"textarea\":case\"input\":case\"select\":case\"\":case null:case undefined:return evt.target.value;default:return evt.target.innerText;}};const writeHtmlValueFromEvent=(evt,value)=>{value=serializeValue(value);switch(props.tag){case\"textarea\":case\"input\":case\"select\":case\"\":case null:case undefined:return evt.target.value=value;default:return evt.target.innerText=value;}};const onBlur=evt=>{var _onBlur,_ref3;(_onBlur=(_ref3=props).onBlur)===null||_onBlur===void 0?void 0:_onBlur.call(_ref3,evt);if(props.tag==='select')return;confirmValue(evt);};const confirmValue=(evt,val)=>{if(readOnly||isBoolean)return;const newValue=val||evt&&getValueFromEvent(evt);const oldValue=getter?getter(data,field):data[field];console.log(\"onChange confirm\",{evt,newValue,oldValue,field,changed:valueDidChange(newValue,oldValue),readOnly,isBoolean,setter,nnv:serializeValue(newValue)});if(valueDidChange(newValue,oldValue)){if(setter)setter(newValue,data,field);else data[field]=serializeValue(newValue);}// I terminate my editing, so I communicate it to other <Input /> that render the same field.\nsetIsTouched(false);};const otherprops={...props};delete otherprops.data;delete otherprops.field;delete otherprops.getter;delete otherprops.setter;delete otherprops.label;delete otherprops.postlabel;delete otherprops.jsxLabel;delete otherprops.tooltip;delete otherprops.hidden;delete otherprops.inputStyle;delete otherprops.children;delete otherprops.autosize;// because react complains is bool in dom attribute or unknown attrib name\nlet checked=undefined;if(isBoolean)checked=typeof value===\"boolean\"?value:typeof value===\"string\"?U.fromBoolString(value):!!value;let cursor;if(tooltip)cursor='help';else if(readOnly)cursor='not-allowed';else if(isBoolean)cursor='pointer';else cursor='auto';let inputProps={...otherprops,className:[props.inputClassName||'',css].join(' '),style:props.inputStyle||{},spellCheck:props.spellCkeck||false,readOnly,disabled:readOnly,type,value:serializeValue(value),checked,onChange,onBlur,onKeyDown};// key:`${field}.${data?.id}`\nif(!inputProps.style.cursor&&cursor==='not-allowed'){inputProps.style.cursor=cursor;}switch(subtype){case'checkbox3':case'switch':case'slider':inputProps.className+=' '+subtype+(oldValue===undefined?'undetermined':'');break;default:break;}let input;let rootprops={className:otherprops.className||'',style:otherprops.style||{}};switch(typeof rootprops.ref){default:rootprops.ref=inputRef;break;case\"object\":let oldref=rootprops.ref;rootprops.ref=v=>{oldref.current=inputRef.current=v;};break;case\"function\":let oldreff=rootprops.ref;rootprops.ref=v=>{oldreff(v);inputRef.current=v;};break;}if(props.autosize)rootprops['data-value']=inputProps.value;if(tooltip){rootprops.onMouseEnter=()=>{var _rootprops$ref;return Tooltip.show(tooltip,'b',((_rootprops$ref=rootprops.ref)===null||_rootprops$ref===void 0?void 0:_rootprops$ref.current)||rootprops.ref);};rootprops.onMouseLeave=()=>Tooltip.hide();}/*let rootkeys = new Set(...Object.keys(rootprops));\r\n    //  merge events: might want to distinguish which events are merged between root and input and which not.\r\n    //  onChange surely needs merge. onMouseHover might not to let it trigger on label too.\r\n    for (let k of rootkeys) {\r\n        if (!(k[0] === 'o' && k[1] === 'n' && k[2] && k[2].toUpperCase() === k[2])) continue;\r\n        if (inputProps[k]) inputProps[k] = function(...a:any) { inputProps[k](arguments); rootprops[k](arguments); }\r\n        else inputProps[k] = rootprops[k];\r\n        delete rootprops[k];\r\n    }*/let wrap=true;if(autosize)rootprops.className=(rootprops.className||'')+' autosize-input-container';else if(!label&&!postlabel&&!props.isMultiSelect){if(rootprops.className)inputProps.className=rootprops.className+' '+inputProps.className;if(rootprops.style)U.objectMergeInPlace(inputProps.style,rootprops.style);inputProps={...rootprops,...inputProps};wrap=false;}switch(props.tag){case\"textarea\":input=/*#__PURE__*/_jsx(\"textarea\",{...inputProps,children:inputProps.value});break;case\"select\":if(props.isMultiSelect){let options=props.options||getSelectOptions_raw(data,field);let multiOptions=options;console.log('setting multiselect pre',{multiOptions,value,ivalue:inputProps.value,options,data,df:data[field],field});let valuesMap=U.objectFromArrayValues(inputProps.value||[]);delete valuesMap[undefined];inputProps.value=[];for(let optgrp of multiOptions)for(let opt of optgrp.options)if(valuesMap[opt.value])inputProps.value.push(opt);// rootprops.className = (rootprops.className || '') + ' clearfix';\nlet old={...rootprops};rootprops.onMouseMove=e=>{var _old$onMouseMove;UX.stopEvt(e);(_old$onMouseMove=old.onMouseMove)===null||_old$onMouseMove===void 0?void 0:_old$onMouseMove.call(old);console.log('multiselect onmove');};/*rootprops.onMouseDown = (e:any) => { UX.stopEvt(e); old.onMouseDown?.(); console.log('multiselect onMouseDown'); };\r\n                rootprops.onMouseUp = (e:any) => { UX.stopEvt(e); old.onMouseUp?.(); console.log('multiselect onMouseUp'); };\r\n                rootprops.onClick = (e:any) => { UX.stopEvt(e); old.onClick?.(); console.log('multiselect onClick'); };\r\n                rootprops.onMouseLeave = (e:any) => { UX.stopEvt(e); old.onMouseLeave?.(); console.log('multiselect onMouseLeave'); };*/ // @ts-ignore\ninput=/*#__PURE__*/_jsx(MultiSelect,{...inputProps,isMulti:true,options:options,onChange:v0=>{let v=v0.map(v=>v.value);confirmValue(undefined,v);console.log('setting multiselect onchange',{v,v0,value,ivalue:inputProps.value,options});}});}else{let options=getSelectOptions(data,field,props.options,props.children);input=/*#__PURE__*/_jsx(\"select\",{...inputProps,children:options});}break;case null:case undefined:case\"\":case\"input\":input=/*#__PURE__*/_jsx(\"input\",{...inputProps});break;default:inputProps.contentEditable=inputProps.contentEditable!==false;input=/*#__PURE__*/React.createElement(props.tag,inputProps,props.children);break;}if(!wrap)return input;if(typeof label===\"string\")label=/*#__PURE__*/_jsx(\"span\",{children:label});if(typeof postlabel===\"string\")postlabel=/*#__PURE__*/_jsx(\"span\",{children:postlabel});const openSelect=e=>{/*\r\n        tried to make label click open the select but does not work easily in js, a solution was here but with css padding.\r\n        https://stackoverflow.com/questions/15249958/once-i-click-on-label-select-button-should-get-open\r\n        */if(props.tag!==\"select\")return;let t=e.target;let select=t.tagName==='select'?t:t.querySelector('select');console.log(\"click select root\",{t,select});select===null||select===void 0?void 0:select.click();};return/*#__PURE__*/_jsxs(\"label\",{className:'input-container',...rootprops,children:[label||undefined,input,postlabel||undefined]});/*\r\n    return(<label className={'p-1'} {...otherprops}\r\n                  style={rootStyle}>\r\n\r\n        {label && <span className={'my-auto'} onMouseEnter={e => setShowTooltip(true)}\r\n                        onMouseLeave={e => setShowTooltip(false)}>{label}\r\n        </span>}\r\n\r\n        {jsxLabel && <span onMouseEnter={e => setShowTooltip(true)}\r\n                           onMouseLeave={e => setShowTooltip(false)} style={{width: '100%'}}>{jsxLabel}\r\n        </span>}\r\n\r\n        {(tooltip && showTooltip) && <div className={'my-tooltip'}>\r\n            <b className={'text-center text-capitalize'}>{field}</b>\r\n            <br />\r\n            <label>{tooltip}</label>\r\n        </div>}\r\n\r\n        {autosize ? <div className={(autosize ? 'autosize-input-container' : '') + (props.asLabel ? ' labelstyle' : '')}\r\n                         data-value={value}>{input}\r\n        </div> : input}\r\n    </label>);\r\n    */}export function InputMapStateToProps(state,ownProps){var _ownProps$data;const ret={};const pointer=typeof ownProps.data==='string'?ownProps.data:(_ownProps$data=ownProps.data)===null||_ownProps$data===void 0?void 0:_ownProps$data.id;ret.debugmodee=state.debug?'true':'false';if(pointer)ret.data=LPointerTargetable.fromPointer(pointer);return ret;}function mapDispatchToProps(dispatch){const ret={};return ret;}export const InputConnected=// @ts-ignore\nconnect(InputMapStateToProps,mapDispatchToProps)(InputComponent);// export function Input(props: InputOwnProps, children: (string | React.Component)[] = []): ReactElement { return 'input' as any; }\nexport function Input(props){// @ts-ignore\nreturn/*#__PURE__*/_jsx(InputConnected,{...props,children:props.children});}// export function TextArea(props: InputOwnProps, children: (string | React.Component)[] = []): ReactElement { return 'textarea' as any; }\nexport function TextArea(props,c){// @ts-ignore\nreturn/*#__PURE__*/_jsx(InputConnected,{...props,tag:\"textarea\",children:props.children||c});}//export function Select(props: SelectOwnProps, children: (string | React.Component)[] = []): ReactElement { return 'select' as any; }\nexport function Select(props,c){// @ts-ignore\nreturn/*#__PURE__*/_jsx(InputConnected,{...props,tag:\"select\",children:props.children||c});}export const Edit=Input;// @ts-ignore\nInputComponent.cname='InputComponent';// @ts-ignore\nInputConnected.cname='InputConnected';Input.cname='Input';TextArea.cname='TextArea';Select.cname='Select';Edit.cname='Edit';","map":{"version":3,"names":["React","useRef","connect","Defaults","Keystrokes","LPointerTargetable","MultiSelect","U","UX","useStateIfMounted","Tooltip","Fragment","_Fragment","jsx","_jsx","jsxs","_jsxs","getSelectOptions_raw","data","field","validTargetOptions","getSelectOptions","options","children","Array","isArray","length","ret","validTargetsJSX","console","log","vt","validTargetJSX","InputComponent","props","_data","getter","setter","oldValue","undefined","value","setValue","isTouched","setIsTouched","inputRef","tag","serializeValue","val","maxDepth","arguments","currDepth","isMultiSelect","map","e","id","valueDidChange","v1","v2","readOnly","readonly","debugmodee","check","type","subtype","label","jsxLabel","postlabel","tooltip","txt","css","hidden","autosize","isBoolean","includes","onChange","evt","_onChange","_ref","call","target","checked","confirmValue","getValueFromEvent","onKeyDown","_onKeyDown","_ref2","key","enter","escape","writeHtmlValueFromEvent","blur","innerText","onBlur","_onBlur","_ref3","newValue","changed","nnv","otherprops","inputStyle","fromBoolString","cursor","inputProps","className","inputClassName","join","style","spellCheck","spellCkeck","disabled","input","rootprops","ref","oldref","v","current","oldreff","onMouseEnter","_rootprops$ref","show","onMouseLeave","hide","wrap","objectMergeInPlace","multiOptions","ivalue","df","valuesMap","objectFromArrayValues","optgrp","opt","push","old","onMouseMove","_old$onMouseMove","stopEvt","isMulti","v0","contentEditable","createElement","openSelect","t","select","tagName","querySelector","click","InputMapStateToProps","state","ownProps","_ownProps$data","pointer","debug","fromPointer","mapDispatchToProps","dispatch","InputConnected","Input","TextArea","c","Select","Edit","cname"],"sources":["C:/0Programmi/Dev/projects/frontend/jjodel/frontend/src/components/forEndUser/Input.tsx"],"sourcesContent":["import React, {Dispatch, KeyboardEvent, LegacyRef, ReactElement, ReactNode, useRef} from 'react';\r\nimport {connect} from 'react-redux';\r\nimport {DState} from '../../redux/store';\r\nimport {\r\n    Any,\r\n    Defaults,\r\n    DObject,\r\n    DPointerTargetable,\r\n    GObject,\r\n    Keystrokes, LAttribute,\r\n    LClass, LEnumerator, LEnumLiteral, LModel, LObject,\r\n    LPointerTargetable, LReference, LStructuralFeature, LValue, MultiSelect, MultiSelectOptGroup,\r\n    MultiSelectOption,\r\n    Overlap,\r\n    Pointer, PrimitiveType, Selectors,\r\n    store,\r\n    U,\r\n    UX\r\n} from '../../joiner';\r\nimport {useStateIfMounted} from 'use-state-if-mounted';\r\nimport './inputselect.scss';\r\nimport { Tooltip } from './Tooltip';\r\n\r\nexport function getSelectOptions_raw(data: LPointerTargetable, field: string): MultiSelectOptGroup[] {\r\n    if (!data) return [];\r\n    switch (field){\r\n        default:\r\n        case 'extends':\r\n        case 'type':\r\n        case 'values': return (data as LValue | LStructuralFeature | LClass).validTargetOptions;\r\n    }\r\n    return [];\r\n}\r\n\r\nexport function getSelectOptions(data: LPointerTargetable, field: string, options: ReactNode, children?: ReactNode): ReactNode {\r\n    if (options) return options;\r\n    // children is auto-filled to empty array even if it is not set explicitly in jsx\r\n    if (Array.isArray(children) && children.length > 0) return children;\r\n    let ret: ReactNode | undefined;\r\n    switch (field) {\r\n        default:\r\n        case 'extends':\r\n        case 'type':\r\n        case 'values': return (data as LValue | LStructuralFeature | LClass).validTargetsJSX; break;\r\n    }\r\n    console.log('msel ret opt', {ret, data, vt: (data as any).validTargetJSX, field})\r\n    return ret;\r\n}\r\n    /*\r\n    export function getSelectOptions_raw(data: LPointerTargetable, field: string): MultiSelectOptGroup[] {\r\n        if (!data) return [];\r\n        // console.log(\"select options\", {data, field, children, options});\r\n        let returns: LClass[] | undefined;\r\n        let primitives: LClass[] | undefined;\r\n        let classes: LClass[] | undefined;\r\n        let enumerators: LEnumerator[] | undefined;\r\n        let objects: (LObject | LEnumLiteral)[] | undefined;\r\n        let m2classname: string | undefined;\r\n        let hasPrimitives: boolean = false;\r\n        let hasReturnTypes: boolean = false;\r\n        let cname = data.className;\r\n        if (!field) switch(cname) {\r\n            case 'DAttribute':  case 'DReference': case 'DOperation': case 'DParameter': field = 'type'; break;\r\n            case 'DValue': field = 'values'; break;\r\n            case 'DClass': field = 'extends'; break;\r\n        }\r\n    /*\r\n        let newmode = true;\r\n        if (newmode){\r\n            switch(field){\r\n                case 'extends': case 'type': return data.validTargetOptions;\r\n            }\r\n            return [];\r\n        }* /\r\n        switch(field) {\r\n            case 'type':\r\n                let model = (data as LStructuralFeature).model;\r\n                switch (cname) {\r\n                    default: break;\r\n                    case 'DAttribute': enumerators = model.enums; hasPrimitives = true; break;\r\n                    case 'DReference': classes = model.classes; break;\r\n                    case 'DOperation': classes = model.classes; enumerators = model.enums; hasPrimitives = hasReturnTypes = true; break;\r\n                    case 'DParameter': classes = model.classes; enumerators = model.enums; hasPrimitives = true; break;\r\n                }\r\n                break;\r\n            case 'value': case 'values':\r\n                if (cname !== 'DValue') break;\r\n                objects = (data as LValue).validTargets;\r\n                /*\r\n                let m2: LReference | LAttribute | undefined = (data as LValue).instanceof;\r\n                if (!m2) {\r\n                    objects = (data as LValue).model.allSubObjects;\r\n                    break;\r\n                }\r\n                let dm2 = m2.__raw;\r\n                if (dm2.className === \"DAttribute\") break;\r\n                let type: LClass = m2.type as LClass;\r\n                if (!type) break;\r\n                m2classname = type.name;\r\n                let m1modelid = data.model.id;\r\n                objects = (type.allInstances || []).filter( o => o.model.id === m1modelid);* /\r\n        }\r\n        let state: DState | undefined;\r\n        // todo: all this stuff might be better moved in mapstatetoprops, or the select list won't update properly.\r\n        if (hasPrimitives) {\r\n            if (!state) state = store.getState();\r\n            primitives = LPointerTargetable.fromPointer(state.primitiveTypes);\r\n        }\r\n        if (hasReturnTypes) {\r\n            if (!state) state = store.getState();\r\n            returns = LPointerTargetable.fromPointer(state.returnTypes);\r\n        }\r\n\r\n        // console.log(\"select options\", {data, field, returns, primitives, classes, enumerators});\r\n\r\n        let ret:MultiSelectOptGroup[] = [];\r\n        if (returns && returns.length) ret.push({label: 'Defaults', options: returns.map((r, i)=>({value: r.id, label:r.name}))});\r\n        if (primitives && primitives.length) ret.push({label: 'Primitives', options: primitives.map((r, i)=>({value: r.id, label:r.name}))});\r\n        if (enumerators && enumerators.length) ret.push({label: 'Enumerators', options: enumerators.map((r, i)=>({value: r.id, label:r.name}))});\r\n        if (classes && classes.length) ret.push({label: 'Classes#', options: classes.map((r, i)=>({value: r.id, label:r.name}))});\r\n        if (objects && objects.length) ret.push({label: m2classname ? 'Instances of ' + m2classname : \"All objects\", options:\r\n                [{value: undefined as any, label: '_empty_'}, ...objects.map((r, i)=>({value: r.id, label:r.name}))]});\r\n        return ret;\r\n    }\r\n    export function getSelectOptions(data: LPointerTargetable, field: string, options: ReactNode, children?: ReactNode): ReactNode {\r\n        if (options) return options;\r\n        // children is auto-filled to empty array even if it is not set explicitly in jsx\r\n        if (Array.isArray(children) && children.length > 0) return children;\r\n        let ret: ReactNode | undefined;\r\n        let newmode = true;\r\n        if (newmode){\r\n            switch(field){\r\n                case 'extends': case 'type': ret = (data as any).validTargetJSX; break;\r\n            }\r\n            console.log('msel ret opt', {ret, data, vt: (data as any).validTargetJSX, field})\r\n        }\r\n        if (ret) return ret;\r\n        let opts = getSelectOptions_raw(data, field); // old to remove?\r\n        return UX.options(opts); // selectOptionsToJSX(opts);\r\n    }\r\n    function selectOptionsToJSX(ret: MultiSelectOptGroup[]): ReactNode{\r\n        return(\r\n            <>{\r\n                ret.map(optgrp => <optgroup label={optgrp.label}>{\r\n                    optgrp.options.map((e, i) => <option key={i} value={e.value}>{e.label}</option>)\r\n                }</optgroup>).filter(e=>!!e)\r\n            }</>);\r\n    }*/\r\n\r\nexport function InputComponent(props: AllProps) {\r\n    const data = props.data;\r\n    const getter = props.getter;\r\n    const setter = props.setter;\r\n    const field: string = props.field as string;\r\n    const oldValue: PrimitiveType | PrimitiveType[] | LPointerTargetable = (getter) ? getter(data, field) : (data ? data[field] : undefined); // !== undefined); ? data[field] : 'undefined'\r\n    let [value, setValue] = useStateIfMounted<PrimitiveType | PrimitiveType[] | LPointerTargetable>(oldValue);\r\n\r\n    const [isTouched, setIsTouched] = useStateIfMounted(false);\r\n    const inputRef = useRef<Element | null>(null);\r\n    if (props.tag === 'select') value = oldValue; // select does not use state.\r\n    let serializeValue = (val: LPointerTargetable | PrimitiveType | PrimitiveType[], maxDepth=1, currDepth = 0): string | PrimitiveType | PrimitiveType[] => {\r\n        if (Array.isArray(val)) {\r\n            if (props.isMultiSelect && currDepth < maxDepth) {\r\n                // return val.map(e => serializeValue(e, maxDepth, currDepth + 1)) as PrimitiveType[];\r\n                return val.map(e => (e as any)?.id||e) as PrimitiveType[];\r\n            }\r\n            if (currDepth < maxDepth) return serializeValue(val[0], maxDepth, currDepth + 1);\r\n            else return undefined;\r\n        }\r\n        return (val as LPointerTargetable)?.id || (val as any);\r\n    };\r\n\r\n    function valueDidChange(v1: any, v2: any): boolean {\r\n        return serializeValue(v1) !== serializeValue(v2);\r\n        /*\r\n        let rawv1 = v1?.__raw || v1;\r\n        let rawv2 = v2?.__raw || v2;\r\n        if (rawv1 !== v1 || rawv2 !== v2) { return v1?.clonedCounter !== v2?.clonedCounter; }\r\n        return v1 !== v2;*/\r\n    }\r\n\r\n    // I check if the value that I have in my local state is being edited by other <Input />\r\n    if (props.tag !== 'select' && !isTouched && valueDidChange(value, oldValue)){\r\n        setValue(serializeValue(oldValue));\r\n        setIsTouched(false);\r\n    }\r\n\r\n\r\n    if (!((data && field) || (getter && setter))) return(<>Either props.data & field or both getter & setter are required.</>);\r\n    let readOnly: boolean;\r\n    if (props.readonly !== undefined) readOnly = props.readonly;\r\n    // else if (props.disabled !== undefined) readOnly = props.disabled;\r\n    else readOnly = props.debugmodee !== 'true' && Defaults.check(data?.id)\r\n\r\n    let type = (props.type) ? props.type : 'text';\r\n    let subtype: string = type;\r\n    switch (type) {\r\n        case 'toggle': type = 'checkbox'; subtype = 'switch'; break;\r\n        case 'checkbox3': case 'switch': type = 'checkbox'; break;\r\n        case 'slider': type = 'range'; break;\r\n    }\r\n    let label: ReactNode | undefined = props.jsxLabel || props.label;\r\n    let postlabel: ReactNode | undefined = props.postlabel;\r\n    let tooltip: ReactNode|string|undefined = ((props.tooltip === true) ? data?.['__info_of__' + field]?.txt : props.tooltip) || '';\r\n\r\n    let css = '';//'my-auto input ';\r\n    //css += (jsxLabel) ? 'ms-1' : (label) ? 'ms-auto' : '';\r\n    css += (props.hidden) ? ' hidden-input' : '';\r\n    let autosize: boolean = props.autosize === undefined ? false : props.autosize; // props.type==='text'\r\n    css += autosize ? ' autosize-input' : '';\r\n    const isBoolean = (['checkbox', 'radio'].includes(type));\r\n\r\n\r\n    const onChange = (evt: React.ChangeEvent<HTMLInputElement>) => {\r\n        (props as any).onChange?.(evt);\r\n        if (readOnly) return;\r\n        if (isBoolean) {\r\n            let target = evt.target.checked;\r\n            if (subtype === 'checkbox3' && !value) { target = undefined as any; }\r\n            if (setter) setter(target, data, field);\r\n            else data[field] = target;\r\n            setValue(target);\r\n            return;\r\n        }\r\n        if (props.tag === \"select\") {\r\n            confirmValue(evt as any);\r\n        } else {\r\n            //console.log(\"setValue\", {value, nv: getValueFromEvent(evt), evt, ev: evt.target.value});\r\n            setValue(getValueFromEvent(evt));\r\n            setIsTouched(true);     // I'm editing the element in my local state.\r\n            // the actual set is done in onBlur\r\n        }\r\n    }\r\n    const onKeyDown = (evt: React.KeyboardEvent<HTMLInputElement>) => {\r\n        (props as any).onKeyDown?.(evt);\r\n        if (props.tag === 'select') return;\r\n        if (evt.key === Keystrokes.enter) confirmValue(evt as any);\r\n        if (evt.key === Keystrokes.escape) {\r\n            const oldValue = getter ? getter(data, field) : data[field];\r\n            writeHtmlValueFromEvent(evt as any, oldValue);\r\n            setValue(serializeValue(oldValue));\r\n            setIsTouched(false);\r\n            (evt.target as HTMLInputElement).blur();\r\n            // to optimize: probably can remove a large part of this function because this should trigger blur event as well. or move \"change\" event contents here\r\n            // optimize 2: memoize the whole component, so it won't update unless the displayed value changed. this would also fix cursor going to input end when pressing enter.\r\n        }\r\n    }\r\n    const getValueFromEvent = (evt: { target: HTMLInputElement | HTMLSelectElement | HTMLTextAreaElement }) => {\r\n        switch (props.tag){\r\n            case \"textarea\": case \"input\": case \"select\": case \"\": case null: case undefined: return evt.target.value;\r\n            default: return evt.target.innerText;\r\n        }\r\n    }\r\n    const writeHtmlValueFromEvent = (evt: { target: HTMLInputElement | HTMLSelectElement | HTMLTextAreaElement }, value: any) => {\r\n        value = serializeValue(value);\r\n        switch (props.tag){\r\n            case \"textarea\": case \"input\": case \"select\": case \"\": case null: case undefined: return evt.target.value = value;\r\n            default: return evt.target.innerText = value;\r\n        }\r\n    }\r\n\r\n    const onBlur = (evt: { target: HTMLInputElement | HTMLSelectElement | HTMLTextAreaElement }) => {\r\n        (props as any).onBlur?.(evt);\r\n        if (props.tag === 'select') return;\r\n        confirmValue(evt);\r\n    }\r\n    const confirmValue = (evt: { target: HTMLInputElement | HTMLSelectElement | HTMLTextAreaElement }|undefined, val?: PrimitiveType|PrimitiveType[]) => {\r\n        if (readOnly || isBoolean) return;\r\n        const newValue = val || (evt && getValueFromEvent(evt));\r\n        const oldValue = getter ? getter(data, field) : data[field];\r\n        console.log(\"onChange confirm\", {evt, newValue, oldValue, field, changed: valueDidChange(newValue, oldValue), readOnly, isBoolean, setter, nnv:serializeValue(newValue)});\r\n        if (valueDidChange(newValue, oldValue)){\r\n            if (setter) setter(newValue as any, data, field);\r\n            else data[field] = serializeValue(newValue);\r\n        }\r\n        // I terminate my editing, so I communicate it to other <Input /> that render the same field.\r\n        setIsTouched(false);\r\n    }\r\n\r\n    const otherprops: GObject = {...props};\r\n    delete otherprops.data;\r\n    delete otherprops.field;\r\n    delete otherprops.getter;\r\n    delete otherprops.setter;\r\n    delete otherprops.label;\r\n    delete otherprops.postlabel;\r\n    delete otherprops.jsxLabel;\r\n    delete otherprops.tooltip;\r\n    delete otherprops.hidden;\r\n    delete otherprops.inputStyle;\r\n    delete otherprops.children;\r\n    delete otherprops.autosize; // because react complains is bool in dom attribute or unknown attrib name\r\n\r\n    let checked: boolean | undefined = undefined;\r\n    if (isBoolean) checked = typeof value === \"boolean\" ? value : (typeof value === \"string\" ? U.fromBoolString(value) : !!value);\r\n\r\n    let cursor: string;\r\n    if (tooltip) cursor = 'help';\r\n    else if (readOnly) cursor = 'not-allowed';\r\n    else if (isBoolean) cursor = 'pointer';\r\n    else cursor = 'auto';\r\n\r\n    let inputProps: GObject = {...otherprops,\r\n        className: [props.inputClassName||'', css].join(' '),\r\n        style: (props.inputStyle || {}),\r\n        spellCheck: (props as any).spellCkeck || false, readOnly, disabled: readOnly, type,\r\n        value: serializeValue(value),\r\n        checked,\r\n        onChange, onBlur, onKeyDown} // key:`${field}.${data?.id}`\r\n    if (!inputProps.style.cursor && cursor === 'not-allowed') { inputProps.style.cursor = cursor; }\r\n    switch(subtype){\r\n        case 'checkbox3': case 'switch': case 'slider': inputProps.className += ' ' + subtype + (oldValue===undefined?'undetermined':''); break;\r\n        default: break;\r\n    }\r\n\r\n    let input: ReactNode;\r\n    let rootprops: GObject = {className: otherprops.className||'', style: otherprops.style||{}};\r\n    switch (typeof rootprops.ref) {\r\n        default: rootprops.ref = inputRef; break;\r\n        case \"object\":\r\n            let oldref = rootprops.ref;\r\n            rootprops.ref = (v: Element | null) => { oldref.current = inputRef.current = v; }\r\n            break;\r\n        case \"function\":\r\n            let oldreff = rootprops.ref;\r\n            rootprops.ref = (v: Element | null) => { oldreff(v); inputRef.current = v; }\r\n            break;\r\n    }\r\n    if (props.autosize) rootprops['data-value'] = inputProps.value;\r\n\r\n    if (tooltip) {\r\n        rootprops.onMouseEnter = () => Tooltip.show(tooltip, 'b', (rootprops.ref?.current) || rootprops.ref);\r\n        rootprops.onMouseLeave = () => Tooltip.hide();\r\n    }\r\n    /*let rootkeys = new Set(...Object.keys(rootprops));\r\n    //  merge events: might want to distinguish which events are merged between root and input and which not.\r\n    //  onChange surely needs merge. onMouseHover might not to let it trigger on label too.\r\n    for (let k of rootkeys) {\r\n        if (!(k[0] === 'o' && k[1] === 'n' && k[2] && k[2].toUpperCase() === k[2])) continue;\r\n        if (inputProps[k]) inputProps[k] = function(...a:any) { inputProps[k](arguments); rootprops[k](arguments); }\r\n        else inputProps[k] = rootprops[k];\r\n        delete rootprops[k];\r\n    }*/\r\n\r\n    let wrap = true;\r\n    if (autosize) rootprops.className = (rootprops.className || '') + ' autosize-input-container';\r\n    else if (!label && !postlabel && !props.isMultiSelect) {\r\n        if (rootprops.className) inputProps.className = rootprops.className + ' ' + inputProps.className;\r\n        if (rootprops.style) U.objectMergeInPlace(inputProps.style, rootprops.style);\r\n        inputProps = {...rootprops, ...inputProps};\r\n        wrap = false;\r\n    }\r\n\r\n    switch (props.tag){\r\n        case \"textarea\": input = <textarea {...inputProps}>{inputProps.value}</textarea>; break;\r\n        case \"select\":\r\n            if (props.isMultiSelect){\r\n                let options = props.options as any || getSelectOptions_raw(data, field);\r\n                let multiOptions = options as MultiSelectOptGroup[];\r\n                console.log('setting multiselect pre', {multiOptions, value, ivalue: inputProps.value, options, data, df:data[field], field});\r\n                let valuesMap = U.objectFromArrayValues((inputProps.value||[]));\r\n                delete valuesMap[undefined as any];\r\n                inputProps.value = [];\r\n                for (let optgrp of multiOptions) for (let opt of optgrp.options) if (valuesMap[opt.value]) inputProps.value.push(opt);\r\n                // rootprops.className = (rootprops.className || '') + ' clearfix';\r\n                let old = {...rootprops};\r\n                rootprops.onMouseMove = (e:any) => { UX.stopEvt(e); old.onMouseMove?.(); console.log('multiselect onmove'); };\r\n                /*rootprops.onMouseDown = (e:any) => { UX.stopEvt(e); old.onMouseDown?.(); console.log('multiselect onMouseDown'); };\r\n                rootprops.onMouseUp = (e:any) => { UX.stopEvt(e); old.onMouseUp?.(); console.log('multiselect onMouseUp'); };\r\n                rootprops.onClick = (e:any) => { UX.stopEvt(e); old.onClick?.(); console.log('multiselect onClick'); };\r\n                rootprops.onMouseLeave = (e:any) => { UX.stopEvt(e); old.onMouseLeave?.(); console.log('multiselect onMouseLeave'); };*/\r\n                // @ts-ignore\r\n                input = <MultiSelect {...inputProps} isMulti={true} options={options}\r\n                    onChange={((v0: MultiSelectOption[]) => {\r\n                        let v = v0.map(v => v.value);\r\n                        confirmValue(undefined, v);\r\n                        console.log('setting multiselect onchange', {v, v0, value, ivalue: inputProps.value, options});\r\n                    }) as any}\r\n                />;\r\n            }\r\n            else {\r\n                let options = getSelectOptions(data, field, props.options, props.children);\r\n                input = <select {...inputProps}>{options}</select>;\r\n            }\r\n            break;\r\n        case null: case undefined: case \"\": case \"input\": input = <input {...inputProps} />; break;\r\n        default:\r\n            inputProps.contentEditable = inputProps.contentEditable !== false;\r\n            input = React.createElement(props.tag, inputProps, props.children); break;\r\n    }\r\n    if (!wrap) return input;\r\n\r\n    if (typeof label === \"string\") label = <span>{label}</span>;\r\n    if (typeof postlabel === \"string\") postlabel = <span>{postlabel}</span>;\r\n\r\n    const openSelect = (e: any)=>{\r\n        /*\r\n        tried to make label click open the select but does not work easily in js, a solution was here but with css padding.\r\n        https://stackoverflow.com/questions/15249958/once-i-click-on-label-select-button-should-get-open\r\n        */\r\n        if (props.tag !== \"select\") return;\r\n        let t: HTMLElement = (e.target) as any;\r\n        let select = (t.tagName === 'select') ? t : t.querySelector('select');\r\n        console.log(\"click select root\", {t, select});\r\n        select?.click();\r\n    }\r\n    return <label className={'input-container'} {...rootprops} /*onClick={openSelect}*/>\r\n        {label || undefined}{input}{postlabel || undefined}</label>;\r\n    /*\r\n    return(<label className={'p-1'} {...otherprops}\r\n                  style={rootStyle}>\r\n\r\n        {label && <span className={'my-auto'} onMouseEnter={e => setShowTooltip(true)}\r\n                        onMouseLeave={e => setShowTooltip(false)}>{label}\r\n        </span>}\r\n\r\n        {jsxLabel && <span onMouseEnter={e => setShowTooltip(true)}\r\n                           onMouseLeave={e => setShowTooltip(false)} style={{width: '100%'}}>{jsxLabel}\r\n        </span>}\r\n\r\n        {(tooltip && showTooltip) && <div className={'my-tooltip'}>\r\n            <b className={'text-center text-capitalize'}>{field}</b>\r\n            <br />\r\n            <label>{tooltip}</label>\r\n        </div>}\r\n\r\n        {autosize ? <div className={(autosize ? 'autosize-input-container' : '') + (props.asLabel ? ' labelstyle' : '')}\r\n                         data-value={value}>{input}\r\n        </div> : input}\r\n    </label>);\r\n    */\r\n}\r\n\r\nexport interface InputOwnProps {\r\n    data?: LPointerTargetable | DPointerTargetable | Pointer<DPointerTargetable, 1, 1, LPointerTargetable>;\r\n    field?: string;\r\n    // DANGER: use the data provided in parameters instead of using js closure, as the proxy accessed from using closure won't be updated in rerenders.\r\n    getter?: (data: any/*LPointerTargetable*/, field: string) => string | boolean | undefined;\r\n    setter?: (value: string|boolean, data: any, field: string) => void;\r\n    label?: string | ReactNode;\r\n    postlabel?: string | ReactNode;\r\n    jsxLabel?: ReactNode; // @deprecated, use label\r\n    type?: 'checkbox'|'color'|'date'|'datetime-local'|'email'|'file'|'image'|'month'|'number'|'password'\r\n        |'radio'|'range'|'tel'|'text'|'time'|'url'|'week'\r\n        |'checkbox3'|'toggle'|'switch'|'slider';\r\n    className?: string;\r\n    style?: GObject;\r\n    readonly?: boolean;\r\n    tooltip?: boolean | ReactNode;\r\n    hidden?: boolean;\r\n    autosize?: boolean;\r\n    inputClassName?: string;\r\n    inputStyle?: GObject;\r\n    key?: React.Key | null;\r\n    placeholder?: string;\r\n    tag?: string;\r\n    children?: ReactNode;\r\n}\r\n\r\nexport interface SelectOwnProps extends Omit<InputOwnProps, 'setter'> {\r\n    options?: JSX.Element;\r\n    setter?: (value: string/*|PrimitiveType[]*/, data: any, field: string) => void; // parent select has value: string | boolean\r\n    isMultiSelect?: boolean;\r\n}\r\ninterface RealOwnProps extends Omit<SelectOwnProps, 'setter'>{\r\n    setter: InputOwnProps['setter'];\r\n}\r\n\r\ninterface StateProps {\r\n    debugmodee: string;\r\n    data: LPointerTargetable & GObject;\r\n    // selected: Dictionary<Pointer<DUser>, LModelElement | null>;\r\n}\r\ninterface DispatchProps { }\r\ntype AllProps = Overlap<RealOwnProps, Overlap<StateProps, DispatchProps>>;\r\n\r\n\r\nexport function InputMapStateToProps(state: DState, ownProps: RealOwnProps): StateProps {\r\n    const ret: StateProps = {} as any;\r\n    const pointer: Pointer | undefined = typeof ownProps.data === 'string' ? ownProps.data : ownProps.data?.id;\r\n    ret.debugmodee = state.debug ? 'true' : 'false';\r\n    if (pointer) ret.data = LPointerTargetable.fromPointer(pointer);\r\n    return ret;\r\n}\r\n\r\nfunction mapDispatchToProps(dispatch: Dispatch<any>): DispatchProps {\r\n    const ret: DispatchProps = {};\r\n    return ret;\r\n}\r\n\r\nexport const InputConnected =\r\n    // @ts-ignore\r\n    connect<StateProps, DispatchProps, RealOwnProps, DState>(InputMapStateToProps, mapDispatchToProps)(InputComponent);\r\n\r\n\r\n// export function Input(props: InputOwnProps, children: (string | React.Component)[] = []): ReactElement { return 'input' as any; }\r\nexport function Input(props: InputOwnProps): ReactElement {\r\n    // @ts-ignore\r\n    return <InputConnected {...props as any}>{props.children}</InputConnected>;\r\n}\r\n\r\n// export function TextArea(props: InputOwnProps, children: (string | React.Component)[] = []): ReactElement { return 'textarea' as any; }\r\nexport function TextArea(props: InputOwnProps, c: any): ReactElement {\r\n    // @ts-ignore\r\n    return <InputConnected {...{...props, tag:\"textarea\"} as any}>{props.children||c}</InputConnected>;\r\n}\r\n//export function Select(props: SelectOwnProps, children: (string | React.Component)[] = []): ReactElement { return 'select' as any; }\r\nexport function Select(props: SelectOwnProps, c: any): ReactElement {\r\n    // @ts-ignore\r\n    return <InputConnected {...{...props, tag:\"select\"} as any}>{props.children||c}</InputConnected>;\r\n}\r\nexport const Edit = Input;\r\n\r\n// @ts-ignore\r\nInputComponent.cname = 'InputComponent';\r\n// @ts-ignore\r\nInputConnected.cname = 'InputConnected';\r\nInput.cname = 'Input';\r\nTextArea.cname = 'TextArea';\r\nSelect.cname = 'Select';\r\nEdit.cname = 'Edit';\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}