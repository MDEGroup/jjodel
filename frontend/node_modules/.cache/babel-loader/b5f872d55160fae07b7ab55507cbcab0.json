{"ast":null,"code":"var _dec, _class, _class2, _dec2, _class3, _dec3, _class5, _dec4, _class7, _class8, _dec5, _class9, _class10, _dec6, _class11, _dec7, _class13, _class14, _dec8, _class15, _class16;\nimport { U } from \"../joiner\";\nimport { DPointerTargetable, RuntimeAccessible, windoww, Log, RuntimeAccessibleClass } from \"../joiner\";\nexport let IPoint = (_dec = RuntimeAccessible('IPoint'), _dec(_class = (_class2 = class IPoint extends RuntimeAccessibleClass {\n  // @ts-ignore static getM is not null but must be declared nullable to achieve subclass mixing\n  // public static getM? = function(firstPt: IPoint, secondPt: IPoint): number { return (firstPt.y - secondPt.y) / (firstPt.x - secondPt.x); }\n  static getM(firstPt, secondPt) {\n    return (firstPt.y - secondPt.y) / (firstPt.x - secondPt.x);\n  }\n  static getQ(firstPt, secondPt, m) {\n    if (m === undefined) m = IPoint.getM(firstPt, secondPt);\n    return firstPt.y - m * firstPt.x;\n  }\n  constructor() {\n    let x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    let y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    super(); // super('dwc');\n    this.x = void 0;\n    this.y = void 0;\n    IPoint.init_constructor(this, x, y);\n  }\n  static init_constructor(thiss) {\n    let x = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    let y = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    thiss.id = \"POINT_\" + DPointerTargetable.maxID++ + \"_\" + new Date().getTime();\n    thiss.className = thiss.constructor.name;\n    if (x === null || x === undefined) thiss.x = undefined;else if (isNaN(+x)) {\n      thiss.x = 0;\n    } else thiss.x = +x;\n    if (y === null || y === undefined) thiss.y = undefined;else if (isNaN(+y)) {\n      thiss.y = 0;\n    } else thiss.y = +y;\n    thiss.className = this.cname;\n  }\n  static printDiff(s1, s2) {\n    return ISize.printDiff(s1, s2, true);\n  }\n  raw() {\n    return {\n      x: this.x,\n      y: this.y\n    };\n  }\n  toString() {\n    let letters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    let separator = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \" \";\n    if (letters) return JSON.stringify({\n      x: this.x,\n      y: this.y\n    });else return this.x + separator + this.y + separator;\n  }\n  clone(other) {\n    this.x = other.x;\n    this.y = other.y;\n    return this;\n  }\n  duplicate() {\n    const ret = this.new();\n    ret.clone(this);\n    return ret;\n  }\n  distanceFromPoint(tentativeEnd) {\n    let skipSqrt = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    let d_pow2 = (this.x - tentativeEnd.x) ** 2 + (this.y - tentativeEnd.y) ** 2;\n    return skipSqrt ? d_pow2 : Math.sqrt(d_pow2);\n    // return this.subtract(tentativeEnd, true).absolute();\n  }\n  subtract(p2, newInstance) {\n    Log.e(!p2, 'subtract argument must be a valid point: ', p2);\n    let p1;\n    if (!newInstance) {\n      p1 = this;\n    } else {\n      p1 = this.duplicate();\n    }\n    if (p2.x !== undefined) p1.x -= p2.x;\n    if (p2.y !== undefined) p1.y -= p2.y;\n    return p1;\n  }\n  add(p2, newInstance) {\n    Log.e(!p2, 'add argument must be a valid point: ', p2);\n    let p1;\n    if (!newInstance) {\n      p1 = this;\n    } else {\n      p1 = this.duplicate();\n    }\n    if (p2.x !== undefined) p1.x += p2.x;\n    if (p2.y !== undefined) p1.y += p2.y;\n    return p1;\n  }\n  addAll(p, newInstance) {\n    let i;\n    let p0;\n    if (!newInstance) {\n      p0 = this;\n    } else {\n      p0 = this.duplicate();\n    }\n    for (i = 0; i < p.length; i++) {\n      p0.add(p[i], true);\n    }\n    return p0;\n  }\n  subtractAll(p, newInstance) {\n    let i;\n    let p0;\n    if (!newInstance) {\n      p0 = this;\n    } else {\n      p0 = this.duplicate();\n    }\n    for (i = 0; i < p.length; i++) {\n      p0.subtract(p[i], true);\n    }\n    return p0;\n  }\n  multiply(pt) {\n    let newInstance = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    let ret = newInstance ? this.duplicate() : this;\n    if (typeof pt === \"number\") {\n      ret.x *= pt;\n      ret.y *= pt;\n    } else {\n      if (pt.x !== undefined) ret.x *= pt.x;\n      if (pt.y !== undefined) ret.y *= pt.y;\n    }\n    return ret;\n  }\n  divide(pt) {\n    let newInstance = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    let ret = newInstance ? this.duplicate() : this;\n    if (typeof pt === \"number\") {\n      ret.x /= pt;\n      ret.y /= pt;\n    } else {\n      ret.x /= pt.x;\n      ret.y /= pt.y;\n    }\n    return ret;\n  }\n  multiplyScalar(scalar, newInstance) {\n    Log.e(isNaN(+scalar), 'IPoint.multiply()', 'scalar argument must be a valid number: ', scalar);\n    let p1;\n    if (!newInstance) {\n      p1 = this;\n    } else {\n      p1 = this.duplicate();\n    }\n    p1.x *= scalar;\n    p1.y *= scalar;\n    return p1;\n  }\n  divideScalar(scalar, newInstance) {\n    Log.e(isNaN(+scalar), 'IPoint.divide()', 'scalar argument must be a valid number: ', scalar);\n    let p1;\n    if (!newInstance) {\n      p1 = this;\n    } else {\n      p1 = this.duplicate();\n    }\n    p1.x /= scalar;\n    p1.y /= scalar;\n    return p1;\n  }\n  isInTheMiddleOf(firstPt, secondPt, tolleranza) {\n    const rectangle = Size.fromPoints(firstPt, secondPt);\n    const tolleranzaX = tolleranza; // actually should be cos * arctan(m);\n    const tolleranzaY = tolleranza; // actually should be sin * arctan(m);\n    if (this.x < rectangle.x - tolleranzaX || this.x > rectangle.x + rectangle.w + tolleranzaX) {\n      return false;\n    }\n    if (this.y < rectangle.y - tolleranzaX || this.y > rectangle.y + rectangle.h + tolleranzaY) {\n      return false;\n    }\n    // const m = IPoint.getM(firstPt, secondPt);\n    // const q = IPoint.getQ(firstPt, secondPt);\n    const lineDistance = this.distanceFromLine(firstPt, secondPt);\n    // console.log('distance:', lineDistance, ', this:', this, ', p1:', firstPt, ', p2:', secondPt);\n    return lineDistance <= tolleranza;\n  }\n  distanceFromLine(p1, p2) {\n    const top = +(p2.y - p1.y) * this.x - (p2.x - p1.x) * this.y + p2.x * p1.y - p1.x * p2.y;\n    const bot = (p2.y - p1.y) * (p2.y - p1.y) + (p2.x - p1.x) * (p2.x - p1.x);\n    return Math.abs(top) / Math.sqrt(bot);\n  }\n  equals(pt) {\n    let tolleranzaX = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    let tolleranzaY = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    if (pt === null) {\n      return false;\n    }\n    return Math.abs(this.x - pt.x) <= tolleranzaX && Math.abs(this.y - pt.y) <= tolleranzaY;\n  }\n  moveOnNearestBorder(startVertexSize, clone, graph) {\n    let debug = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n    const pt = clone ? this.duplicate() : this;\n    const tl = startVertexSize.tl();\n    const tr = startVertexSize.tr();\n    const bl = startVertexSize.bl();\n    const br = startVertexSize.br();\n    const L = pt.distanceFromLine(tl, bl);\n    const R = pt.distanceFromLine(tr, br);\n    const T = pt.distanceFromLine(tl, tr);\n    const B = pt.distanceFromLine(bl, br);\n    const min = Math.min(L, R, T, B);\n    if (min === L) {\n      pt.x = tl.x;\n    }\n    if (min === R) {\n      pt.x = tr.x;\n    }\n    if (min === T) {\n      pt.y = tr.y;\n    }\n    if (min === B) {\n      pt.y = br.y;\n    }\n    if (debug && graph && pt instanceof GraphPoint) {\n      graph.markg(pt, false, 'purple');\n    }\n    return pt;\n  }\n  getM(pt2) {\n    var _IPoint$getM;\n    return (_IPoint$getM = IPoint.getM) === null || _IPoint$getM === void 0 ? void 0 : _IPoint$getM.call(IPoint, this, pt2);\n  }\n  degreeWith(pt2, toRadians) {\n    const directionVector = this.subtract(pt2, true);\n    const ret = Math.atan2(directionVector.y, directionVector.x);\n    return toRadians ? ret : windoww.U.RadToDegree(ret);\n  }\n  absolute() {\n    return Math.sqrt(this.x * this.x + this.y * this.y);\n  }\n  set(x, y) {\n    this.x = x;\n    this.y = y;\n  }\n\n  // move the point by a vector with direction and distance (module)\n  move(rad, distance) {\n    let clone = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    let pt = clone ? this.duplicate() : this;\n    pt.x += distance * Math.cos(rad);\n    pt.y += distance * Math.sin(rad);\n    return pt;\n  }\n  static stringify(ptlike) {\n    if (!ptlike) return ptlike;\n    let str;\n    return '(' + U.cropNum(ptlike.x || 0) + ', ' + U.cropNum(ptlike.y || 0) + ')';\n  }\n}, _class2.subclasses = [], _class2._extends = [], _class2)) || _class);\nexport let GraphPoint = (_dec2 = RuntimeAccessible('GraphPoint'), _dec2(_class3 = class GraphPoint extends IPoint {\n  constructor() {\n    super(...arguments);\n    this.dontmixwithPoint = void 0;\n  }\n  static fromEvent(e) {\n    if (!e) {\n      return null;\n    }\n    const p = new Point(e.pageX, e.pageY);\n    const g = null;\n    throw new Error(\"todo: const g: IGraph = Status.status.getActiveModel().graph;\");\n    return g.toGraphCoord(p);\n  }\n  new() {\n    return new GraphPoint();\n  }\n  toSize(w, h) {\n    return new GraphSize(this.x, this.y, w, h === undefined ? w : h);\n  }\n}) || _class3);\nexport let Point = (_dec3 = RuntimeAccessible('Point'), _dec3(_class5 = class Point extends IPoint {\n  constructor() {\n    super(...arguments);\n    this.dontmixwithGPoint = void 0;\n  }\n  /// https://stackoverflow.com/questions/6073505/what-is-the-difference-between-screenx-y-clientx-y-and-pagex-y\n  static fromEvent(e) {\n    const p = new Point(e.pageX, e.pageY);\n    return p;\n  }\n  new() {\n    return new Point();\n  }\n  toSize(w, h) {\n    return new Size(this.x, this.y, w, h === undefined ? w : h);\n  }\n}) || _class5);\nRuntimeAccessibleClass.set_extend(RuntimeAccessibleClass, IPoint);\nRuntimeAccessibleClass.set_extend(IPoint, GraphPoint);\nRuntimeAccessibleClass.set_extend(IPoint, Point);\nexport let ISize = (_dec4 = RuntimeAccessible('ISize'), _dec4(_class7 = (_class8 = class ISize extends RuntimeAccessibleClass {\n  constructor() {\n    let x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    let y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    let w = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    let h = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n    super(); // super('dwc');\n    // do not override any fields from the DPointerTargetable, otherwise the ! in the override will reinizialize the attribute\n    // erasing the value set in super or in the functions called by the constructor as side effect (static_init called from constructor will be overridden too)\n    // if need to override types, build the \"new\" static function like in DModelElement\n    this.x = void 0;\n    this.y = void 0;\n    this.w = void 0;\n    this.h = void 0;\n    ISize.init_constructor(this, x, y, w, h);\n  }\n  static printDiff(s1, s2) {\n    var _s1$w, _s1$h, _s1$x, _s1$y, _s2$w, _s2$h;\n    let asPoints = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    s1 = {\n      ...s1,\n      w: (_s1$w = s1.w) !== null && _s1$w !== void 0 ? _s1$w : s1.width,\n      h: (_s1$h = s1.h) !== null && _s1$h !== void 0 ? _s1$h : s1.height\n    };\n    s1.x = (_s1$x = s1.x) !== null && _s1$x !== void 0 ? _s1$x : s2.x;\n    s1.y = (_s1$y = s1.y) !== null && _s1$y !== void 0 ? _s1$y : s2.y;\n    s2 = {\n      ...s2,\n      w: (_s2$w = s2.w) !== null && _s2$w !== void 0 ? _s2$w : s2.width,\n      h: (_s2$h = s2.h) !== null && _s2$h !== void 0 ? _s2$h : s2.height\n    };\n    if (!asPoints) {\n      var _s1$w2, _s1$h2;\n      s1.w = (_s1$w2 = s1.w) !== null && _s1$w2 !== void 0 ? _s1$w2 : s2.w;\n      s1.h = (_s1$h2 = s1.h) !== null && _s1$h2 !== void 0 ? _s1$h2 : s2.h;\n    }\n    let s1coords = [];\n    s1coords.push(U.isNumber(s1.x) ? '' : U.cropNum(s1.x));\n    s1coords.push(U.isNumber(s1.y) ? ',' : ', ' + U.cropNum(s1.y));\n    if (!asPoints) {\n      s1coords.push(U.isNumber(s1.w) ? ',' : ', ' + U.cropNum(s1.w));\n      s1coords.push(U.isNumber(s1.h) ? ',' : ', ' + U.cropNum(s1.h));\n    }\n    let s2coords = [];\n    s2coords.push(s2.x === s1.x || !U.isNumber(s2.x) ? '' : U.cropNum(s2.x));\n    s2coords.push(s2.y === s1.y || !U.isNumber(s2.y) ? ',' : ', ' + U.cropNum(s2.y));\n    if (!asPoints) {\n      s2coords.push(s2.w === s1.w || !U.isNumber(s2.w) ? ',' : ', ' + U.cropNum(s2.w));\n      s2coords.push(s2.h === s1.h || !U.isNumber(s2.h) ? ',' : ', ' + U.cropNum(s2.h));\n    }\n    return `(` + s1coords.join('') + `)(` + s2coords.join('') + `)`;\n  }\n  static stringify(ptlike) {\n    if (!ptlike) return ptlike;\n    let str = [];\n    if (ptlike.x && !isNaN(ptlike.x) || ptlike.x === 0) str.push('x:' + U.cropNum(ptlike.x));\n    if (ptlike.y && !isNaN(ptlike.y) || ptlike.y === 0) str.push('y:' + U.cropNum(ptlike.y));\n    if (ptlike.w && !isNaN(ptlike.w) || ptlike.w === 0) str.push('w:' + U.cropNum(ptlike.w));\n    if (ptlike.h && !isNaN(ptlike.h) || ptlike.h === 0) str.push('h:' + U.cropNum(ptlike.h));\n    if (ptlike.width && !isNaN(ptlike.width) || ptlike.width === 0) str.push('W:' + U.cropNum(ptlike.width));\n    if (ptlike.height && !isNaN(ptlike.height) || ptlike.height === 0) str.push('H:' + U.cropNum(ptlike.height));\n    // if (str.length === 0) return '{}';\n    return '{' + str.join(', ') + '}';\n  }\n  static init_constructor(thiss) {\n    let x = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    let y = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    let w = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n    let h = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n    thiss.id = \"SIZE_\" + DPointerTargetable.maxID++ + \"_\" + new Date().getTime();\n    thiss.className = thiss.constructor.cname;\n    if (x === null || x === undefined) thiss.x = undefined;else if (isNaN(+x)) {\n      thiss.x = 0;\n    } else thiss.x = +x;\n    if (y === null || y === undefined) thiss.y = undefined;else if (isNaN(+y)) {\n      thiss.y = 0;\n    } else thiss.y = +y;\n    if (w === null || w === undefined) thiss.w = undefined;else if (isNaN(+w)) {\n      thiss.w = 0;\n    } else thiss.w = +w;\n    if (h === null || h === undefined) thiss.h = undefined;else if (isNaN(+h)) {\n      thiss.h = 0;\n    } else thiss.h = +h;\n    thiss.className = this.cname;\n  }\n  toString() {\n    let letters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    let separator = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \" \";\n    if (letters) return JSON.stringify({\n      x: this.x,\n      y: this.y,\n      w: this.w,\n      h: this.h\n    });else return this.x + separator + this.y + separator + this.w + separator + this.h;\n  }\n  set(x, y, w, h) {\n    if (x !== undefined) this.x = +x;\n    if (y !== undefined) this.y = +y;\n    if (w !== undefined) this.w = +w;\n    if (h !== undefined) this.h = +h;\n  }\n  clone(json) {\n    this.x = json.x;\n    this.y = json.y;\n    this.w = json.w;\n    this.h = json.h;\n    return this;\n  }\n  duplicate() {\n    return this.new().clone(this);\n  }\n  add(pt2, newInstance) {\n    let thiss = newInstance ? this.duplicate() : this;\n    if (typeof pt2 === \"number\") {\n      thiss.x += pt2;\n      thiss.y += pt2;\n      thiss.w += pt2;\n      thiss.h += pt2;\n      return thiss;\n    }\n    if (pt2.x !== undefined) thiss.x += pt2.x;\n    if (pt2.y !== undefined) thiss.y += pt2.y;\n    if (pt2.w !== undefined) thiss.w += pt2.w;\n    if (pt2.h !== undefined) thiss.h += pt2.h;\n    return thiss;\n  }\n  subtract(pt2, newInstance) {\n    let thiss = newInstance ? this.duplicate() : this;\n    if (typeof pt2 === \"number\") {\n      thiss.x -= pt2;\n      thiss.y -= pt2;\n      thiss.w -= pt2;\n      thiss.h -= pt2;\n      return thiss;\n    }\n    if (pt2.x !== undefined) thiss.x -= pt2.x;\n    if (pt2.y !== undefined) thiss.y -= pt2.y;\n    if (pt2.w !== undefined) thiss.w -= pt2.w;\n    if (pt2.h !== undefined) thiss.h -= pt2.h;\n    return thiss;\n  }\n  multiply(pt2, newInstance) {\n    let thiss = newInstance ? this.duplicate() : this;\n    if (typeof pt2 === \"number\") {\n      thiss.x *= pt2;\n      thiss.y *= pt2;\n      thiss.w *= pt2;\n      thiss.h *= pt2;\n      return thiss;\n    }\n    if (pt2.x !== undefined) thiss.x *= pt2.x;\n    if (pt2.y !== undefined) thiss.y *= pt2.y;\n    if (pt2.w !== undefined) thiss.w *= pt2.w;\n    if (pt2.h !== undefined) thiss.h *= pt2.h;\n    return thiss;\n  }\n  divide(pt2, newInstance) {\n    let thiss = newInstance ? this.duplicate() : this;\n    if (typeof pt2 === \"number\") {\n      thiss.x /= pt2;\n      thiss.y /= pt2;\n      thiss.w /= pt2;\n      thiss.h /= pt2;\n      return thiss;\n    }\n    if (pt2.x !== undefined) thiss.x /= pt2.x;\n    if (pt2.y !== undefined) thiss.y /= pt2.y;\n    if (pt2.w !== undefined) thiss.w /= pt2.w;\n    if (pt2.h !== undefined) thiss.h /= pt2.h;\n    return thiss;\n  }\n  tl() {\n    return this.makePoint(this.x, this.y);\n  }\n  tr() {\n    return this.makePoint(this.x + this.w, this.y);\n  }\n  bl() {\n    return this.makePoint(this.x, this.y + this.h);\n  }\n  br() {\n    return this.makePoint(this.x + this.w, this.y + this.h);\n  }\n  center() {\n    return this.makePoint(this.x + this.w / 2, this.y + this.h / 2);\n  }\n  relativePoint(xPercent, yPercent) {\n    return this.makePoint(this.x + this.w * xPercent, this.y + this.h * yPercent);\n  }\n  equals(size) {\n    return this.x === size.x && this.y === size.y && this.w === size.w && this.h === size.h;\n  }\n\n  /// field-wise Math.min()\n  min(minSize, clone) {\n    const ret = clone ? this.new() : this;\n    if (!isNaN(minSize.x) && ret.x < minSize.x) {\n      ret.x = minSize.x;\n    }\n    if (!isNaN(minSize.y) && ret.y < minSize.y) {\n      ret.y = minSize.y;\n    }\n    if (!isNaN(minSize.w) && ret.w < minSize.w) {\n      ret.w = minSize.w;\n    }\n    if (!isNaN(minSize.h) && ret.h < minSize.h) {\n      ret.h = minSize.h;\n    }\n    return ret;\n  }\n  max(maxSize, clone) {\n    const ret = clone ? this.new() : this;\n    if (!isNaN(maxSize.x) && ret.x > maxSize.x) {\n      ret.x = maxSize.x;\n    }\n    if (!isNaN(maxSize.y) && ret.y > maxSize.y) {\n      ret.y = maxSize.y;\n    }\n    if (!isNaN(maxSize.w) && ret.w > maxSize.w) {\n      ret.w = maxSize.w;\n    }\n    if (!isNaN(maxSize.h) && ret.h > maxSize.h) {\n      ret.h = maxSize.h;\n    }\n    return ret;\n  }\n  intersection(size) {\n    if (!size) return null;\n    // anche \"isinside\"\n    let startx, starty, endx, endy;\n    startx = Math.max(this.x, size.x);\n    starty = Math.max(this.y, size.y);\n    endx = Math.min(this.x + this.w, size.x + size.w);\n    endy = Math.min(this.y + this.h, size.y + size.h);\n    const intersection = this.new();\n    // intersection.set(0, 0, 0, 0);\n    intersection.x = startx;\n    intersection.y = starty;\n    intersection.w = endx - startx;\n    intersection.h = endy - starty;\n    const doesintersect = intersection.w > 0 && intersection.h > 0;\n    return doesintersect ? intersection : null;\n  }\n  contains(pt) {\n    return pt.x >= this.x && pt.x <= this.x + this.w && pt.y >= this.y && pt.y <= this.y + this.h;\n  }\n  isOverlapping(size2) {\n    return !!this.intersection(size2);\n  }\n  isOverlappingAnyOf(sizes) {\n    if (!sizes) return false;\n    for (let size of sizes) {\n      if (this.isOverlapping(size)) return true;\n    }\n    return false;\n  }\n  multiplyPoint(other, newInstance) {\n    const ret = newInstance ? this.new() : this;\n    ret.x *= other.x;\n    ret.w *= other.x;\n    ret.y *= other.y;\n    ret.h *= other.y;\n    return ret;\n  }\n  dividePoint(other, newInstance) {\n    const ret = newInstance ? this.new() : this;\n    ret.x /= other.x;\n    ret.w /= other.x;\n    ret.y /= other.y;\n    ret.h /= other.y;\n    return ret;\n  }\n  boundary(size2) {\n    /*let minx, maxx, miny, maxy;\r\n    if (size2.y < this.y) { miny = size2.y; /*maxy = this.y;* / } else { miny = this.y; /*maxy = size2.y;* / }\r\n    if (size2.x < this.x) { minx = size2.y; /*maxx = this.x;* / } else { minx = this.x; /*maxy = size2.x;* / }\r\n    if (size2.y + size2.h < this.y + this.h) maxy = this.y + this.h; else maxy = size2.y + size2.h;\r\n    if (size2.x + size2.w < this.x + this.w) maxx = this.x + this.w; else maxx = size2.x + size2.w;\r\n    */\n    this.h = size2.y + size2.h > this.y + this.h ? size2.y + size2.h : this.y + this.h; // -miny\n    this.w = size2.x + size2.w > this.x + this.w ? size2.x + size2.w : this.x + this.w; // -minx\n    if (this.y < size2.y) this.y = size2.y;\n    if (this.x < size2.x) this.x = size2.x;\n    this.h -= this.y;\n    this.w -= this.x;\n  }\n}, _class8.subclasses = [], _class8._extends = [], _class8)) || _class7);\nexport let Size = (_dec5 = RuntimeAccessible('Size'), _dec5(_class9 = (_class10 = class Size extends ISize {\n  constructor() {\n    super(...arguments);\n    this.dontMixWithGraphSize = void 0;\n  }\n  /**\r\n   * measure a node size\r\n   * @param {Element} element0 - the emelemnt to measure;\r\n   * @param {boolean} sizePostTransform - includes css transform instructions for computing his size. like transform: scale(1.5)\r\n   * */\n  static of(element0) {\n    var _element$ownerDocumen;\n    let sizePostTransform = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    let element = element0;\n    if (element === document) {\n      Log.ww('trying to measure document, rerouted to measuring body.');\n      element = document.body;\n    }\n    const $element = $(element);\n    Log.ex(!element || element.tagName === 'foreignObject', 'sizeof()', 'SvgForeignElementObject have a bug with size, measure a child instead.', element);\n    let tmp;\n    let size;\n    if (!Size.sizeofvar) {\n      Size.sizeofvar = document.createElement('div');\n      document.body.append(Size.sizeofvar);\n    }\n    const isOrphan = element.parentNode === null;\n    // var visible = element.style.display !== 'none';\n    // var visible = $element.is(\":visible\"); crea bug quando un elemento è teoricamente visibile ma orfano\n    const ancestors = windoww.U.ancestorArray(element);\n    const displayStyles = ancestors.map(e => {\n      var _e$style;\n      return e === null || e === void 0 ? void 0 : (_e$style = e.style) === null || _e$style === void 0 ? void 0 : _e$style.display;\n    });\n    if (isOrphan) {\n      Size.sizeofvar.append(element);\n    }\n    // show all and saveToDB visibility to restore it later\n    for (let i = 0; i < ancestors.length; i++) {\n      var _ancestors$i, _ancestors$i$style;\n      // document has undefined style\n      displayStyles[i] = (_ancestors$i = ancestors[i]) === null || _ancestors$i === void 0 ? void 0 : (_ancestors$i$style = _ancestors$i.style) === null || _ancestors$i$style === void 0 ? void 0 : _ancestors$i$style.display;\n      if (displayStyles[i] === 'none' || displayStyles[i] === '' && getComputedStyle(ancestors[i]).display === 'none') {\n        ancestors[i].style.display = 'block';\n      }\n    }\n    // size = new Size(tmp.left, tmp.top, 0, 0);\n    let rect = element.getBoundingClientRect();\n    size = new Size(0, 0, 0, 0);\n    let win = ((_element$ownerDocumen = element.ownerDocument) === null || _element$ownerDocumen === void 0 ? void 0 : _element$ownerDocumen.defaultView) || window;\n    size.x = rect.left + win.scrollX;\n    size.y = rect.top + win.scrollY;\n    if (sizePostTransform) {\n      size.w = rect.width;\n      size.h = rect.height;\n    } else {\n      size.w = element.offsetWidth; // element.scrollWidth;\n      size.h = element.offsetHeight;\n    }\n    // restore visibility\n    for (let i = 0; i < ancestors.length; i++) {\n      var _ancestors$i$style2;\n      if (displayStyles[i] === ((_ancestors$i$style2 = ancestors[i].style) === null || _ancestors$i$style2 === void 0 ? void 0 : _ancestors$i$style2.display)) continue;\n      if (displayStyles[i]) ancestors[i].style.display = displayStyles[i];else ancestors[i].style.removeProperty('display');\n    }\n    if (isOrphan) {\n      windoww.U.clear(Size.sizeofvar);\n    }\n    // Status.status.getActiveModel().graph.markS(size, false);\n    return size;\n  }\n  static fromPoints(firstPt, secondPt) {\n    const minX = Math.min(firstPt.x, secondPt.x);\n    const maxX = Math.max(firstPt.x, secondPt.x);\n    const minY = Math.min(firstPt.y, secondPt.y);\n    const maxY = Math.max(firstPt.y, secondPt.y);\n    return new Size(minX, minY, maxX - minX, maxY - minY);\n  }\n  makePoint(x, y) {\n    return new Point(x, y);\n  }\n  new() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    return new Size(...args);\n  }\n}, _class10.subclasses = [], _class10.sizeofvar = void 0, _class10.$sizeofvar = void 0, _class10)) || _class9);\nexport let GraphSize = (_dec6 = RuntimeAccessible('GraphSize'), _dec6(_class11 = class GraphSize extends ISize {\n  constructor() {\n    super(...arguments);\n    this.dontMixWithSize = void 0;\n  }\n  static fromPoints(firstPt, secondPt) {\n    const minX = Math.min(firstPt.x, secondPt.x);\n    const maxX = Math.max(firstPt.x, secondPt.x);\n    const minY = Math.min(firstPt.y, secondPt.y);\n    const maxY = Math.max(firstPt.y, secondPt.y);\n    return new GraphSize(minX, minY, maxX - minX, maxY - minY);\n  }\n\n  // both pt and targetPt are readonly-safe parameters\n  static closestIntersection(size, pt, targetPt, gridAlign, m0, q0) {\n    // let pt: GraphPoint = pt0.duplicate();\n    const m = m0 || GraphPoint.getM(targetPt, pt);\n    const q = q0 || GraphPoint.getQ(targetPt, pt);\n    // console.log(\"closestIntersection()\", {size, pt0, targetPt, m, q});\n    // if perfectly vertical line\n    if (m === Number.POSITIVE_INFINITY /* && q === Number.NEGATIVE_INFINITY*/) {\n      // top center\n      if (Math.abs(targetPt.y - size.y) <= Math.abs(targetPt.y - size.y - size.h)) return pt;\n      // bottom center\n      else return new GraphPoint(pt.x, size.y + size.h);\n    }\n    let tl = size.tl(),\n      tr = size.tr(),\n      bl = size.bl(),\n      br = size.br();\n    let allowT, allowB, allowL, allowR;\n    /*let distanceT: number = Number.POSITIVE_INFINITY, distanceB: number = Number.POSITIVE_INFINITY,\r\n        distanceL: number = Number.POSITIVE_INFINITY, distanceR: number = Number.POSITIVE_INFINITY;*/\n    let intersectionT, intersectionB, intersectionL, intersectionR;\n    allowT = Geom.isNumberBetween(tl.y, bl.y, targetPt.y);\n    allowB = Geom.isNumberBetween(bl.y, tl.y, targetPt.y);\n    allowL = Geom.isNumberBetween(tl.x, tr.x, targetPt.x);\n    allowR = Geom.isNumberBetween(tr.x, tl.x, targetPt.x);\n    // console.log(\"closestIntersection pt0\", {size, targetPt, pt0:pt0.raw(), gridAlign,\n    //     corners:{tl:tl.raw(), tr:tr.raw(), bl:bl.raw(), br:br.raw()}, allows:{allowT, allowB, allowL, allowR}});\n    if (!(allowT || allowB || allowL || allowR)) return undefined; // point is internal to size\n    if (allowT) intersectionT = Geom.lineToSegmentIntersection(tl, tr, q, m);else if (allowB) intersectionB = Geom.lineToSegmentIntersection(bl, br, q, m); // NOT else, (T|B) AND (L|R) can happen, or just 1 or 0 of those.\n    if (allowL) intersectionL = Geom.lineToSegmentIntersection(tl, bl, q, m);else if (allowR) intersectionR = Geom.lineToSegmentIntersection(tr, br, q, m);\n\n    // console.log(\"closestIntersection pt2\", {intersectionT, intersectionB, intersectionL, intersectionR});\n    // only 1 intersection can happen\n    return intersectionT || intersectionB || intersectionL || intersectionR;\n  }\n  static closestIntersection_old(size, prevPt, pt0, gridAlign) {\n    let ret = GraphSize.closestIntersection0(size, prevPt, pt0, gridAlign);\n    // Log.exDev(!Geom.isOnEdge(ret, size), 'ClosestIntersection failed. not on Vertex edge.', {ret, size, prevPt, pt0, gridAlign});\n    return ret;\n  }\n  static closestIntersection0(vertexGSize, prevPt, pt0, gridAlign) {\n    let pt = pt0.duplicate();\n    const m = GraphPoint.getM(prevPt, pt);\n    const q = GraphPoint.getQ(prevPt, pt);\n    // U.pe( Math.abs((pt.y - m * pt.x) - (prevPt.y - m * prevPt.x)) > .001, 'wrong math in Q:', (pt.y - m * pt.x), ' vs ', (prevPt.y - m * prevPt.x));\n    /*const isL = prevPt.x < pt.x;\r\n    const isT = prevPt.y < pt.y;\r\n    const isR = !isL;\r\n    const isB = !isT; */\n    if (m === Number.POSITIVE_INFINITY && q === Number.NEGATIVE_INFINITY) {\n      // bottom middle\n      return new GraphPoint(vertexGSize.x + vertexGSize.w / 2, vertexGSize.y + vertexGSize.h);\n    }\n    // console.log('pt:', pt, 'm:', m, 'q:', q);\n    let L = new GraphPoint(0, 0);\n    let T = new GraphPoint(0, 0);\n    let R = new GraphPoint(0, 0);\n    let B = new GraphPoint(0, 0);\n    L.x = vertexGSize.x;\n    L.y = m * L.x + q;\n    R.x = vertexGSize.x + vertexGSize.w;\n    R.y = m * R.x + q;\n    T.y = vertexGSize.y;\n    T.x = (T.y - q) / m;\n    B.y = vertexGSize.y + vertexGSize.h;\n    B.x = (B.y - q) / m;\n    // prendo solo il compreso pt ~ prevPt (escludo così il \"pierce\" sulla faccia opposta), prendo il più vicino al centro.\n    // console.log('4 possibili punti di intersezione (LTBR):', L, T, B, R);\n    /* this.owner.mark(this.owner.toHtmlCoord(T), true, 'blue');\r\n    this.owner.mark(this.owner.toHtmlCoord(B), false, 'violet');\r\n    this.owner.mark(this.owner.toHtmlCoord(L), false, 'red');\r\n    this.owner.mark(this.owner.toHtmlCoord(R), false, 'orange');*/\n    console.log(\"intersect pt1:\", {\n      T,\n      B,\n      L,\n      R\n    });\n    if (B.x >= pt.x && B.x <= prevPt.x || B.x >= prevPt.x && B.x <= pt.x) {} else {\n      B = null;\n    }\n    if (T.x >= pt.x && T.x <= prevPt.x || T.x >= prevPt.x && T.x <= pt.x) {} else {\n      T = null;\n    }\n    if (L.y >= pt.y && L.y <= prevPt.y || L.y >= prevPt.y && L.y <= pt.y) {} else {\n      L = null;\n    }\n    if (R.y >= pt.y && R.y <= prevPt.y || R.y >= prevPt.y && R.y <= pt.y) {} else {\n      R = null;\n    }\n    console.log(\"intersect pt2:\", {\n      T,\n      B,\n      L,\n      R\n    });\n    function closestmix(pt, closest, segStart, segEnd, mode) {\n      // changes pt\n      pt.x = closest.x;\n      pt.y = closest.y;\n      return;\n      let main, sub;\n      if (mode === \"TB\") {\n        main = \"y\";\n        sub = \"x\";\n      } else {\n        main = \"x\";\n        sub = \"y\";\n      }\n      pt[main] = closest[main];\n      // if T[sub] is inside the top segment, take T[sub], otherwise closest between size.tl[sub] and size.tr[sub]\n      // pt[sub] = Math.max(segStart[sub], Math.min(segStart[sub], closest[sub]));\n      if (closest[sub] <= segEnd[sub] && closest[sub] >= segStart[sub]) pt[sub] = closest[sub];else if (Math.abs(closest[sub] - segEnd[sub]) < Math.abs(closest[sub] - segStart[sub])) pt[sub] = segEnd[sub];else pt[sub] = segStart[sub];\n    }\n    function closestmix2(pt, closest, segStart, segEnd, mode) {\n      // changes closest\n      let main, sub;\n      if (mode === \"TB\") {\n        main = \"y\";\n        sub = \"x\";\n      } else {\n        main = \"x\";\n        sub = \"y\";\n      }\n      // closest[main] = pt[main];\n      // if T[sub] is inside the top segment, take T[sub], otherwise closest between size.tl[sub] and size.tr[sub]\n      // pt[sub] = Math.max(segStart[sub], Math.min(segStart[sub], closest[sub]));\n      if (closest[sub] <= segEnd[sub] && closest[sub] >= segStart[sub]) {/*no-op*/} else if (Math.abs(closest[sub] - segEnd[sub]) < Math.abs(closest[sub] - segStart[sub])) closest[sub] = segEnd[sub];else closest[sub] = segStart[sub];\n    }\n    console.log(\"intersect pt2.5:\");\n    try {\n      if (T) closestmix2(pt, T, vertexGSize.tl(), vertexGSize.tr(), \"TB\");\n      if (B) closestmix2(pt, B, vertexGSize.bl(), vertexGSize.br(), \"TB\");\n      if (R) closestmix2(pt, R, vertexGSize.tr(), vertexGSize.br(), \"LR\");\n      if (L) closestmix2(pt, L, vertexGSize.tl(), vertexGSize.bl(), \"LR\");\n    } catch (e) {\n      console.error(\"intersect error\", e);\n    }\n    // console.log('superstiti step1: (LTBR):', L, T, B, R);\n    console.log(\"intersect pt2.9:\");\n    const vicinanzaT = !T ? Number.POSITIVE_INFINITY : (T.x - pt.x) * (T.x - pt.x) + (T.y - pt.y) * (T.y - pt.y);\n    const vicinanzaB = !B ? Number.POSITIVE_INFINITY : (B.x - pt.x) * (B.x - pt.x) + (B.y - pt.y) * (B.y - pt.y);\n    const vicinanzaL = !L ? Number.POSITIVE_INFINITY : (L.x - pt.x) * (L.x - pt.x) + (L.y - pt.y) * (L.y - pt.y);\n    const vicinanzaR = !R ? Number.POSITIVE_INFINITY : (R.x - pt.x) * (R.x - pt.x) + (R.y - pt.y) * (R.y - pt.y);\n    const closest = Math.min(vicinanzaT, vicinanzaB, vicinanzaL, vicinanzaR);\n    console.log(\"intersect pt3:\", {\n      vicinanzaT,\n      vicinanzaB,\n      vicinanzaL,\n      vicinanzaR,\n      closest\n    });\n\n    // console.log( 'closest:', closest);\n    // succede quando pt e prevPt sono entrambi all'interno del rettangolo del vertice.\n    // L'edge non è visibile e il valore ritornato è irrilevante.\n\n    if (closest === Number.POSITIVE_INFINITY) {\n      /* top center */\n      pt = vertexGSize.tl();\n      pt.x += vertexGSize.w / 2;\n    } else if (closest === Number.POSITIVE_INFINITY) {\n      /* bottom center */\n      pt = vertexGSize.br();\n      pt.x -= vertexGSize.w / 2;\n    } else if (closest === vicinanzaT && T) {\n      closestmix(pt, T, vertexGSize.tl(), vertexGSize.tr(), \"TB\");\n      /*pt.y = T.y;\r\n      // if T.x is inside the top segment, take T.x, otherwise closest between size.tl.x and size.tr.x\r\n      if ((T.x <= tr.x && T.x >= tl.x)) pt.x = T.x;\r\n      else if (Math.abs(T.x-tr.x) < Math.abs(T.x-tl.x)) pt.x = tr.x;\r\n      else pt.x = tl.x;*/\n    }\n    if (closest === vicinanzaB) {\n      closestmix(pt, B, vertexGSize.bl(), vertexGSize.br(), \"TB\");\n    } else if (closest === vicinanzaR) {\n      closestmix(pt, R, vertexGSize.tr(), vertexGSize.br(), \"LR\");\n    } else if (closest === vicinanzaL) {\n      closestmix(pt, L, vertexGSize.tl(), vertexGSize.bl(), \"LR\");\n    }\n    if (!gridAlign) {\n      return pt;\n    }\n    if (!pt) return null;\n    if (gridAlign.x && (pt === T || pt === B || isNaN(closest))) {\n      const floorX = Math.floor(pt.x / gridAlign.x) * gridAlign.x;\n      const ceilX = Math.ceil(pt.x / gridAlign.x) * gridAlign.x;\n      let closestX;\n      let farthestX;\n      if (Math.abs(floorX - pt.x) < Math.abs(ceilX - pt.x)) {\n        closestX = floorX;\n        farthestX = ceilX;\n      } else {\n        closestX = ceilX;\n        farthestX = floorX;\n      }\n\n      // todo: possibile causa del bug che non allinea punti fake a punti reali. nel calcolo realPT questo non viene fatto.\n      // if closest grid intersection is inside the vertex.\n      if (closestX >= vertexGSize.x && closestX <= vertexGSize.x + vertexGSize.w) {\n        pt.x = closestX;\n      } else\n        // if 2° closer grid intersection is inside the vertex.\n        if (closestX >= vertexGSize.x && closestX <= vertexGSize.x + vertexGSize.w) {\n          pt.x = farthestX;\n          // if no intersection are inside the vertex (ignore grid)\n        } else {/* do nothing */}\n    } else if (gridAlign.y && (pt === L || pt === R)) {\n      const floorY = Math.floor(pt.y / gridAlign.y) * gridAlign.y;\n      const ceilY = Math.ceil(pt.y / gridAlign.y) * gridAlign.y;\n      let closestY;\n      let farthestY;\n      if (Math.abs(floorY - pt.y) < Math.abs(ceilY - pt.y)) {\n        closestY = floorY;\n        farthestY = ceilY;\n      } else {\n        closestY = ceilY;\n        farthestY = floorY;\n      }\n\n      // if closest grid intersection is inside the vertex.\n      if (closestY >= vertexGSize.y && closestY <= vertexGSize.y + vertexGSize.h) {\n        pt.y = closestY;\n      } else\n        // if 2° closer grid intersection is inside the vertex.\n        if (closestY >= vertexGSize.y && closestY <= vertexGSize.y + vertexGSize.h) {\n          pt.y = farthestY;\n          // if no intersection are inside the vertex (ignore grid)\n        } else {/* do nothing */}\n    }\n    return pt;\n  }\n  new() {\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n    return new GraphSize(...args);\n  }\n  makePoint(x, y) {\n    return new GraphPoint(x, y);\n  }\n  closestPoint(pt) {\n    return Geom.closestPoint(this, pt);\n  }\n}) || _class11);\nRuntimeAccessibleClass.set_extend(RuntimeAccessibleClass, ISize);\nRuntimeAccessibleClass.set_extend(ISize, Size);\nRuntimeAccessibleClass.set_extend(ISize, GraphSize);\nexport let PositionStr = (_dec7 = RuntimeAccessible('PositionStr'), _dec7(_class13 = (_class14 = class PositionStr {\n  // left, centered, right\n\n  constructor(x, y) {\n    this.x = void 0;\n    this.y = void 0;\n    this.x = x !== null && x !== void 0 ? x : 0;\n    this.y = y !== null && y !== void 0 ? y : -1;\n  }\n  toString() {\n    return PositionStr.toPosString(this);\n  }\n  invert() {\n    let x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    let y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    if (x) this.x = -this.x;\n    if (y) this.y = -this.y;\n    return this;\n  }\n  static toPosString(o) {\n    let s;\n    if (o.y === -1) s = 't';else if (o.y === 1) s = 'b';else s = '';\n    if (o.x === -1) s += 'l';else if (o.x === 1) s += 'r';\n    // else s = +'';\n    // if (!s) return \"c\";\n    return s;\n  }\n  static fromPosString(position) {\n    let ret = new PositionStr(0, 0);\n    let posarr = (position !== null && position !== void 0 ? position : 't').split(' '); // .map(s=>s[0]);\n    for (let p of posarr) switch (p) {\n      default:\n      case \"t\":\n      case \"top\":\n        ret.y = -1;\n        break;\n      case \"b\":\n      case \"bottom\":\n        ret.y = 1;\n        break;\n      case \"l\":\n      case \"left\":\n        ret.x = -1;\n        break;\n      case \"r\":\n      case \"right\":\n        ret.x = 1;\n        break;\n      case \"tl\":\n      case \"lt\":\n      case \"top left\":\n        ret.y = -1;\n        ret.x = -1;\n        break;\n      case \"tr\":\n      case \"rt\":\n      case \"top right\":\n        ret.y = -1;\n        ret.x = 1;\n        break;\n      case '':\n      case 'c':\n        ret.x = 0;\n        ret.y = 0;\n        break;\n      case \"bl\":\n      case \"lb\":\n      case \"bottom left\":\n        ret.y = 1;\n        ret.x = -1;\n        break;\n      case \"br\":\n      case \"rb\":\n      case \"bottom right\":\n        ret.y = 1;\n        ret.x = 1;\n        break;\n    }\n    return ret;\n  }\n  static invertPosStr(pos) {\n    return PositionStr.fromPosString(pos).invert().toString();\n  }\n  static toFullLabelSingle(position) {\n    switch (position === null || position === void 0 ? void 0 : position.trim()[0]) {\n      case 'c':\n      case '':\n        return 'center';\n      case 't':\n        return 'top';\n      default:\n        if (position.trim() === '') return 'center';\n        return 'bottom';\n      case 'b':\n        return 'bottom';\n      case 'l':\n        return 'left';\n      case 'r':\n        return 'right';\n    }\n  }\n  // tl -> top left\n  static toSeparateFullLabels(position) {\n    let pos = (position !== null && position !== void 0 ? position : 'b').trim();\n    if (pos.length === 2) {\n      return PositionStr.toFullLabelSingle(pos[0]) + ' ' + PositionStr.toFullLabelSingle(pos[1]);\n    } else if (pos.indexOf(' ')) {\n      return pos.split(' ').map(s => PositionStr.toFullLabelSingle(s)).join(' ');\n    } else return PositionStr.toFullLabelSingle(pos[0]);\n    return \"\";\n  }\n}, _class14.cname = 'PositionStr', _class14)) || _class13);\nexport let Geom = (_dec8 = RuntimeAccessible('Geom'), _dec8(_class15 = (_class16 = class Geom extends RuntimeAccessibleClass {\n  static unmark(key) {\n    if (!Geom.markings[key]) return false;\n    let e = Geom.markings[key];\n    U.removeFromDom(e);\n    delete Geom.markings[key];\n    return true;\n  }\n  static markPt(key, pt, color, label) {\n    return Geom.mark(key, pt.x, pt.y, 1, 1, color, label);\n  }\n  static markSize(key, pt, color, label) {\n    var _pt$w, _pt$h;\n    return Geom.mark(key, pt.x, pt.y, (_pt$w = pt.w) !== null && _pt$w !== void 0 ? _pt$w : 1, (_pt$h = pt.h) !== null && _pt$h !== void 0 ? _pt$h : 1, color, label);\n  }\n  static mark(key, x, y) {\n    let w = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;\n    let h = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 1;\n    let color = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 'red';\n    let label = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : '';\n    if (Geom.markings[key]) Geom.unmark(key);\n    let e;\n    let pre = '<div class=\"debug-mark\" data-key=\"' + key + '\" data-label=\"' + label + '\" style=\"position: absolute; z-index:99999; left:' + x + 'px; top:' + y + 'px; width: ' + w + 'px; height: ' + h + 'px;';\n    let post = '\"/>';\n    if (w + h > 2) {\n      e = U.toHtml(pre + 'border-radius:0; background: transparent;' + post);\n    } else {\n      e = U.toHtml(pre + 'border-radius:100%; background: ' + color + '; outline: 1px solid ' + color + '; outline-offset: 5px;' + post);\n    }\n    document.body.append(e);\n    Geom.markings[key] = e;\n    return e;\n  }\n  // warning: nodes from other iframes will say are not instance from Element of the current frame, in that case need duck typing.\n  static isHtmlNode(element) {\n    return element instanceof Element || element instanceof HTMLDocument || element instanceof SVGElement;\n  }\n  static isPositiveZero(m) {\n    if (!!Object.is) {\n      return Object.is(m, +0);\n    }\n    return 1 / m === Number.POSITIVE_INFINITY;\n  }\n  static isNegativeZero(m) {\n    if (!!Object.is) {\n      return Object.is(m, -0);\n    }\n    return 1 / m === Number.NEGATIVE_INFINITY;\n  }\n  static TanToRadian(n) {\n    return Geom.DegreeToRad(Geom.TanToDegree(n));\n  }\n  static TanToDegree(n) {\n    if (Geom.isPositiveZero(n)) {\n      return 0;\n    }\n    if (n === Number.POSITIVE_INFINITY) {\n      return 90;\n    }\n    if (Geom.isNegativeZero(n)) {\n      return 180;\n    }\n    if (n === Number.POSITIVE_INFINITY) {\n      return 270;\n    }\n    return Geom.RadToDegree(window.Math.atan(n));\n  }\n  static RadToDegree(radians) {\n    return Geom.radToDeg(radians);\n  }\n  static DegreeToRad(degree) {\n    return Geom.degToRad(degree);\n  }\n  static radToDeg(radians) {\n    return radians * (180 / Math.PI);\n  }\n  static degToRad(degree) {\n    return degree * (Math.PI / 180);\n  }\n  // 0.001;\n  static isOnEdge(pt, shape) {\n    let tolerance = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Geom.GeomTolerance;\n    return Geom.isOnHorizontalEdges(pt, shape, tolerance) || Geom.isOnVerticalEdges(pt, shape, tolerance);\n  }\n  static isOnVerticalEdges(pt, shape) {\n    let tolerance = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Geom.GeomTolerance;\n    return Geom.isOnLeftEdge(pt, shape, tolerance) || Geom.isOnRightEdge(pt, shape, tolerance);\n  }\n  static isOnHorizontalEdges(pt, shape) {\n    let tolerance = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Geom.GeomTolerance;\n    return Geom.isOnTopEdge(pt, shape, tolerance) || Geom.isOnBottomEdge(pt, shape, tolerance);\n  }\n  static isOnRightEdge(pt, shape) {\n    let tolerance = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Geom.GeomTolerance;\n    if (!pt || !shape) {\n      return false;\n    }\n    if (tolerance) return Math.abs(pt.x - (shape.x + shape.w)) < tolerance && pt.y - shape.y > tolerance && pt.y - (shape.y + shape.h) < tolerance;\n    return pt.x === shape.x + shape.w && pt.y >= shape.y && pt.y <= shape.y + shape.h;\n  }\n  static isOnLeftEdge(pt, shape) {\n    let tolerance = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Geom.GeomTolerance;\n    if (!pt || !shape) {\n      return false;\n    }\n    if (tolerance) return Math.abs(pt.x - shape.x) < tolerance && pt.y - shape.y > tolerance && pt.y - (shape.y + shape.h) < tolerance;\n    return pt.x === shape.x && pt.y >= shape.y && pt.y <= shape.y + shape.h;\n  }\n  static isOnTopEdge(pt, shape) {\n    let tolerance = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Geom.GeomTolerance;\n    if (!pt || !shape) {\n      return false;\n    }\n    if (tolerance) return Math.abs(pt.y - shape.y) < tolerance && pt.x - shape.x > tolerance && pt.x - (shape.x + shape.w) < tolerance;\n    return pt.y === shape.y && pt.x >= shape.x && pt.x <= shape.x + shape.w;\n  }\n  static isOnBottomEdge(pt, shape, tolerance) {\n    if (!pt || !shape) {\n      return false;\n    }\n    if (tolerance) return Math.abs(pt.y - shape.y + shape.h) < tolerance && pt.x - shape.x > tolerance && pt.x - (shape.x + shape.w) < tolerance;\n    return pt.y === shape.y + shape.h && pt.x >= shape.x && pt.x <= shape.x + shape.w;\n  }\n  static closestPoint(size, pt) {\n    let top_closest = Geom.closestPointToSegment(size.tl(), size.tr(), pt);\n    let bot_closest = Geom.closestPointToSegment(size.bl(), size.br(), pt);\n    let left_closest = Geom.closestPointToSegment(size.tl(), size.bl(), pt);\n    let right_closest = Geom.closestPointToSegment(size.tr(), size.br(), pt);\n    let top_distance = top_closest.distanceFromPoint(pt, false);\n    let bot_distance = bot_closest.distanceFromPoint(pt, false);\n    let left_distance = left_closest.distanceFromPoint(pt, false);\n    let right_distance = right_closest.distanceFromPoint(pt, false);\n    let min_distance = Math.min(top_distance, bot_distance, left_distance, right_distance);\n    if (min_distance === top_distance) return top_closest;\n    if (min_distance === bot_distance) return bot_closest;\n    if (min_distance === left_distance) return left_closest;\n    return right_closest;\n  }\n  static isMinusZero(number) {\n    return 1 / number == -Infinity;\n  }\n  static closestPointToSegment(segStart, segEnd, pt) {\n    // 1) find equation of line passing for start, end.\n    // 2) then find all perpendicular lines, then the perpendicular line that pass through pt\n    // 3) find intersection between Line(s,e) and line of point 2.\n    // 4A) IF intersection is part of segment(s,e) that is closest.\n    // 4B) ELSE, one of the 2 extremes of the segment is closest.\n\n    let x_intersect, y_intersect;\n    let s = segStart;\n    let e = segEnd;\n    let mse = (e.y - s.y) / (e.x - s.x);\n    if (mse === Number.POSITIVE_INFINITY || mse === Number.NEGATIVE_INFINITY) {\n      // s and e are both on the same y vertical line (same x)      // new GraphPoint(segStart.x, pt.y);\n      x_intersect = segStart.x;\n      y_intersect = pt.y;\n      // 1), 2), 3) all done shortcut\n    } else if (mse === 0 || Geom.isNegativeZero(mse)) {\n      // s and e are both on the same x horizontal line (same y)    // new GraphPoint(pt.x, segStart.y);\n      x_intersect = pt.x;\n      y_intersect = segStart.y;\n      // 1), 2), 3) all done shortcut\n    } else {\n      let q = s.y - mse * s.x; // y = mx + q           q = y-mx\n      // 1) done\n      let pmse = -1 / mse; // perpendicular to mse\n      let pq = pt.y - pmse * pt.x;\n      // 2) done\n      //  m1 * x + q1 = y    -->   m1 * x + q1 = m2 * x + q2    -->    (m1-m2)x = q2-q1      -->     x=(q2-q1)/(m1-m2)\n      x_intersect = (pq - q) / (mse - pmse);\n      y_intersect = mse * x_intersect + q; //  y = mx +q\n      // 3) done\n    }\n    let maxX, minX;\n    let maxY, minY;\n    if (s.x > e.x) {\n      maxX = s.x;\n      minX = e.x;\n    } else {\n      maxX = e.x;\n      minX = s.x;\n    }\n    if (s.y > e.y) {\n      maxY = s.y;\n      minY = e.y;\n    } else {\n      maxY = e.y;\n      minY = s.y;\n    }\n    if (x_intersect >= minX && x_intersect <= maxX && y_intersect >= minY && y_intersect <= maxY) return new GraphPoint(x_intersect, y_intersect);\n    // 4A) IF done\n\n    let sdist = (s.x - x_intersect) ** 2 + (s.y - y_intersect) ** 2; // actual distance is sqrt() of this, but i just need to find closest, not correct distance.\n    let edist = (e.x - x_intersect) ** 2 + (e.y - y_intersect) ** 2;\n    return sdist < edist ? new GraphPoint(s.x, s.y) : new GraphPoint(e.x, e.y);\n    // 4B) ELSE done\n  }\n  static lineToSegmentIntersection(segStart, segEnd, q, m) {\n    if (segStart.x === segEnd.x) {\n      let y = m * segStart.x + q;\n      if (Geom.isNumberBetween(y, segStart.y, segEnd.y)) return new GraphPoint(segStart.x, y);else return undefined;\n    } else if (segStart.y === segEnd.y) {\n      let x = (segStart.y - q) / m;\n      if (Geom.isNumberBetween(x, segStart.x, segEnd.x)) return new GraphPoint(x, segStart.y);else return undefined;\n      //\n    }\n    let m2 = segStart.getM(segEnd);\n    let q2 = IPoint.getQ(segStart, segEnd);\n    if (m === m2) {\n      if (q2 === q) return segStart; // line and segment coincident\n      return undefined; // parallel\n    }\n    let intersect = Geom.lineToLineIntersection(m, q, m2, q2);\n    if (intersect && Geom.isNumberBetween(intersect.x, segStart.x, segEnd.x) && Geom.isNumberBetween(intersect.y, segStart.y, segEnd.y)) return intersect;else return undefined;\n  }\n  static isNumberBetween(target, s, e) {\n    let max = Math.max(s, e);\n    let min = Math.min(s, e);\n    return target >= min && target <= max;\n  }\n  static lineToLineIntersection(m, q, m2, q2) {\n    let retIfParallel = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : undefined;\n    let retIfCoincident = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : undefined;\n    if (m === m2) {\n      if (q === q2) return retIfCoincident;\n      return retIfParallel;\n    }\n    if (m === Number.POSITIVE_INFINITY || m === Number.NEGATIVE_INFINITY || m2 === Number.POSITIVE_INFINITY || m2 === Number.NEGATIVE_INFINITY) {\n      // m or m2 are a vertical line, Q must be invalid too and i don't have a single point of the line.\n      // it's actually infinite possible vertical parallel lines.\n      return undefined;\n    }\n    /*\r\n        y = mx + q\r\n        y = nx + w\r\n        -->\r\n        mx + q = nx + w\r\n        -->\r\n        mx - nx = w - q\r\n        -->\r\n        x (m - n) = w - q\r\n        -->\r\n        x = (w - q)/(m - n)\r\n    */\n    let x = (q2 - q) / (m - m2);\n    return new GraphPoint(x, m * x + q);\n  }\n  // @param start, end: are for determining direction. every m is a line that can be seen in 2 direction\n  static mToRad(m, start, end) {\n    let rad;\n    if (start.x === end.x) {\n      rad = start.y < end.y ? Math.PI * 3 / 2 : Math.PI / 2;\n    } else {\n      // console.log(\"rad diagonal\", {base:  Math.atan(m), add: start.x > end.x, sx: start.x, ex: end.x});\n      rad = Math.atan(m) + (start.x > end.x ? 0 : Math.PI);\n    }\n    return rad;\n  }\n\n  // intersect a rectangle with a line or segment (if end parameter is specified)\n  // @return: [0, 2] intersections\n  static lineToSizeIntersection_TODO(size, m, startLine, endIfSegment) {\n    // todo: use GraphSize.closestIntersection which is close. it is size-segment returning only the closest intersection\n    return [];\n  }\n}, _class16.markings = {}, _class16.GeomTolerance = 0, _class16)) || _class15);\nRuntimeAccessibleClass.set_extend(RuntimeAccessibleClass, Geom);","map":{"version":3,"names":["U","DPointerTargetable","RuntimeAccessible","windoww","Log","RuntimeAccessibleClass","IPoint","_dec","_class","_class2","getM","firstPt","secondPt","y","x","getQ","m","undefined","constructor","arguments","length","init_constructor","thiss","id","maxID","Date","getTime","className","name","isNaN","cname","printDiff","s1","s2","ISize","raw","toString","letters","separator","JSON","stringify","clone","other","duplicate","ret","new","distanceFromPoint","tentativeEnd","skipSqrt","d_pow2","Math","sqrt","subtract","p2","newInstance","e","p1","add","addAll","p","i","p0","subtractAll","multiply","pt","divide","multiplyScalar","scalar","divideScalar","isInTheMiddleOf","tolleranza","rectangle","Size","fromPoints","tolleranzaX","tolleranzaY","w","h","lineDistance","distanceFromLine","top","bot","abs","equals","moveOnNearestBorder","startVertexSize","graph","debug","tl","tr","bl","br","L","R","T","B","min","GraphPoint","markg","pt2","_IPoint$getM","call","degreeWith","toRadians","directionVector","atan2","RadToDegree","absolute","set","move","rad","distance","cos","sin","ptlike","str","cropNum","subclasses","_extends","_dec2","_class3","dontmixwithPoint","fromEvent","Point","pageX","pageY","g","Error","toGraphCoord","toSize","GraphSize","_dec3","_class5","dontmixwithGPoint","set_extend","_dec4","_class7","_class8","_s1$w","_s1$h","_s1$x","_s1$y","_s2$w","_s2$h","asPoints","width","height","_s1$w2","_s1$h2","s1coords","push","isNumber","s2coords","join","json","makePoint","center","relativePoint","xPercent","yPercent","size","minSize","max","maxSize","intersection","startx","starty","endx","endy","doesintersect","contains","isOverlapping","size2","isOverlappingAnyOf","sizes","multiplyPoint","dividePoint","boundary","_dec5","_class9","_class10","dontMixWithGraphSize","of","element0","_element$ownerDocumen","sizePostTransform","element","document","ww","body","$element","$","ex","tagName","tmp","sizeofvar","createElement","append","isOrphan","parentNode","ancestors","ancestorArray","displayStyles","map","_e$style","style","display","_ancestors$i","_ancestors$i$style","getComputedStyle","rect","getBoundingClientRect","win","ownerDocument","defaultView","window","left","scrollX","scrollY","offsetWidth","offsetHeight","_ancestors$i$style2","removeProperty","clear","minX","maxX","minY","maxY","_len","args","Array","_key","$sizeofvar","_dec6","_class11","dontMixWithSize","closestIntersection","targetPt","gridAlign","m0","q0","q","Number","POSITIVE_INFINITY","allowT","allowB","allowL","allowR","intersectionT","intersectionB","intersectionL","intersectionR","Geom","isNumberBetween","lineToSegmentIntersection","closestIntersection_old","prevPt","pt0","closestIntersection0","vertexGSize","NEGATIVE_INFINITY","console","log","closestmix","closest","segStart","segEnd","mode","main","sub","closestmix2","error","vicinanzaT","vicinanzaB","vicinanzaL","vicinanzaR","floorX","floor","ceilX","ceil","closestX","farthestX","floorY","ceilY","closestY","farthestY","_len2","_key2","closestPoint","PositionStr","_dec7","_class13","_class14","toPosString","invert","o","s","fromPosString","position","posarr","split","invertPosStr","pos","toFullLabelSingle","trim","toSeparateFullLabels","indexOf","_dec8","_class15","_class16","unmark","key","markings","removeFromDom","markPt","color","label","mark","markSize","_pt$w","_pt$h","pre","post","toHtml","isHtmlNode","Element","HTMLDocument","SVGElement","isPositiveZero","Object","is","isNegativeZero","TanToRadian","n","DegreeToRad","TanToDegree","atan","radians","radToDeg","degree","degToRad","PI","isOnEdge","shape","tolerance","GeomTolerance","isOnHorizontalEdges","isOnVerticalEdges","isOnLeftEdge","isOnRightEdge","isOnTopEdge","isOnBottomEdge","top_closest","closestPointToSegment","bot_closest","left_closest","right_closest","top_distance","bot_distance","left_distance","right_distance","min_distance","isMinusZero","number","Infinity","x_intersect","y_intersect","mse","pmse","pq","sdist","edist","m2","q2","intersect","lineToLineIntersection","target","retIfParallel","retIfCoincident","mToRad","start","end","lineToSizeIntersection_TODO","startLine","endIfSegment"],"sources":["C:/0Programmi/Dev/projects/frontend/jjodel/frontend/src/common/Geom.ts"],"sourcesContent":["import {GObject, Temporary, TODO, U} from \"../joiner\";\r\nimport {DPointerTargetable, RuntimeAccessible, windoww, Log, RuntimeAccessibleClass, Dictionary} from \"../joiner\";\r\nimport React from \"react\";\r\nimport {radian} from \"../joiner/types\";\r\n\r\n@RuntimeAccessible('IPoint')\r\nexport abstract class IPoint extends RuntimeAccessibleClass {\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    public x!: number;\r\n    public y!: number;\r\n\r\n    // @ts-ignore static getM is not null but must be declared nullable to achieve subclass mixing\r\n    // public static getM? = function(firstPt: IPoint, secondPt: IPoint): number { return (firstPt.y - secondPt.y) / (firstPt.x - secondPt.x); }\r\n    public static getM(firstPt: IPoint, secondPt: IPoint): number { return (firstPt.y - secondPt.y) / (firstPt.x - secondPt.x); }\r\n    public static getQ(firstPt: IPoint, secondPt: IPoint, m?: number): number {\r\n        if (m === undefined) m = IPoint.getM(firstPt, secondPt);\r\n        return firstPt.y - (m * firstPt.x);\r\n    }\r\n\r\n    public constructor(x: number = 0, y: number = 0) {\r\n        super(); // super('dwc');\r\n        IPoint.init_constructor(this, x, y);\r\n    }\r\n\r\n    static init_constructor(thiss: GObject, x: any = 0, y: any = 0, ...a: any): void {\r\n        thiss.id = \"POINT_\" + (DPointerTargetable.maxID++) + \"_\" + new Date().getTime();\r\n        thiss.className = thiss.constructor.name;\r\n        if (x === null || x === undefined) thiss.x = undefined as Temporary;\r\n        else if (isNaN(+x)) { thiss.x = 0; }\r\n        else thiss.x = +x;\r\n        if (y === null || y === undefined) thiss.y = undefined as Temporary;\r\n        else if (isNaN(+y)) { thiss.y = 0; }\r\n        else thiss.y = +y;\r\n        thiss.className = this.cname;\r\n    }\r\n\r\n\r\n    static printDiff(s1: SizeLike, s2: SizeLike) {\r\n        return ISize.printDiff(s1, s2, true);\r\n    }\r\n    public raw(): {x: number, y: number} { return {x: this.x, y: this.y}; }\r\n\r\n    public toString(letters: boolean=true, separator: string = \" \"): string {\r\n        if (letters) return  JSON.stringify({x:this.x, y: this.y});\r\n        else return this.x + separator + this.y + separator;\r\n    }\r\n    public clone(other: { x: number, y: number }): this { this.x = other.x; this.y = other.y; return this; }\r\n\r\n    protected abstract new(): this;\r\n    abstract toSize(w: number, h?: number): ISize;\r\n    public duplicate(): this { const ret = this.new(); ret.clone(this); return ret; }\r\n\r\n    public distanceFromPoint(tentativeEnd: IPoint, skipSqrt: boolean = false): number {\r\n        let d_pow2 = (this.x - tentativeEnd.x)**2 + (this.y - tentativeEnd.y)**2;\r\n        return skipSqrt ? d_pow2 : Math.sqrt(d_pow2);\r\n        // return this.subtract(tentativeEnd, true).absolute();\r\n    }\r\n\r\n    public subtract(p2: { x?: number, y?: number }, newInstance: boolean): this {\r\n        Log.e(!p2, 'subtract argument must be a valid point: ', p2);\r\n        let p1: this;\r\n        if (!newInstance) { p1 = this; } else { p1 = this.duplicate(); }\r\n        if (p2.x !== undefined) p1.x -= p2.x;\r\n        if (p2.y !== undefined) p1.y -= p2.y;\r\n        return p1; }\r\n\r\n    public add(p2: { x?: number, y?: number }, newInstance: boolean): this {\r\n        Log.e(!p2, 'add argument must be a valid point: ', p2);\r\n        let p1: this;\r\n        if (!newInstance) { p1 = this; } else { p1 = this.duplicate(); }\r\n        if (p2.x !== undefined) p1.x += p2.x;\r\n        if (p2.y !== undefined) p1.y += p2.y;\r\n        return p1; }\r\n\r\n    public addAll(p: IPoint[], newInstance: boolean): this {\r\n        let i;\r\n        let p0: this;\r\n        if (!newInstance) { p0 = this; } else { p0 = this.duplicate(); }\r\n        for (i = 0; i < p.length; i++) { p0.add(p[i], true); }\r\n        return p0; }\r\n\r\n    public subtractAll(p: this[], newInstance: boolean): this {\r\n        let i;\r\n        let p0: this;\r\n        if (!newInstance) { p0 = this; } else { p0 = this.duplicate(); }\r\n        for (i = 0; i < p.length; i++) { p0.subtract(p[i], true); }\r\n        return p0; }\r\n\r\n    public multiply(pt: {x?: number, y?: number} | number, newInstance: boolean = false): this {\r\n        let ret: this = (newInstance ? this.duplicate() : this);\r\n        if (typeof pt === \"number\") {\r\n            ret.x *= pt;\r\n            ret.y *= pt;\r\n        }\r\n        else {\r\n            if (pt.x !== undefined) ret.x *= pt.x;\r\n            if (pt.y !== undefined) ret.y *= pt.y;\r\n        }\r\n        return ret; }\r\n\r\n    public divide(pt: Partial<this> | number, newInstance: boolean = false): this {\r\n        let ret = (newInstance ? this.duplicate() : this);\r\n        if (typeof pt === \"number\") {\r\n            ret.x /= pt;\r\n            ret.y /= pt;\r\n        }\r\n        else {\r\n            ret.x /= pt.x as number;\r\n            ret.y /= pt.y as number;\r\n        }\r\n        return ret; }\r\n\r\n    public multiplyScalar(scalar: number, newInstance: boolean): this {\r\n        Log.e(isNaN(+scalar), 'IPoint.multiply()', 'scalar argument must be a valid number: ', scalar);\r\n        let p1: this;\r\n        if (!newInstance) { p1 = this; } else { p1 = this.duplicate(); }\r\n        p1.x *= scalar;\r\n        p1.y *= scalar;\r\n        return p1; }\r\n\r\n    public divideScalar(scalar: number, newInstance: boolean): this {\r\n        Log.e(isNaN(+scalar), 'IPoint.divide()', 'scalar argument must be a valid number: ', scalar);\r\n        let p1: this;\r\n        if (!newInstance) { p1 = this; } else { p1 = this.duplicate(); }\r\n        p1.x /= scalar;\r\n        p1.y /= scalar;\r\n        return p1; }\r\n\r\n    public isInTheMiddleOf(firstPt: this, secondPt: this, tolleranza: number): boolean {\r\n        const rectangle: Size = Size.fromPoints(firstPt, secondPt);\r\n        const tolleranzaX = tolleranza; // actually should be cos * arctan(m);\r\n        const tolleranzaY = tolleranza; // actually should be sin * arctan(m);\r\n        if (this.x < rectangle.x - tolleranzaX || this.x > rectangle.x + rectangle.w + tolleranzaX) { return false; }\r\n        if (this.y < rectangle.y - tolleranzaX || this.y > rectangle.y + rectangle.h + tolleranzaY) { return false; }\r\n        // const m = IPoint.getM(firstPt, secondPt);\r\n        // const q = IPoint.getQ(firstPt, secondPt);\r\n        const lineDistance = this.distanceFromLine(firstPt, secondPt);\r\n        // console.log('distance:', lineDistance, ', this:', this, ', p1:', firstPt, ', p2:', secondPt);\r\n        return lineDistance <= tolleranza; }\r\n\r\n    public distanceFromLine(p1: IPoint, p2: IPoint): number {\r\n        const top: number =\r\n            + (p2.y - p1.y) * this.x\r\n            - (p2.x - p1.x) * this.y\r\n            + p2.x * p1.y\r\n            - p1.x * p2.y;\r\n        const bot =\r\n            (p2.y - p1.y) * (p2.y - p1.y) +\r\n            (p2.x - p1.x) * (p2.x - p1.x);\r\n        return Math.abs(top) / Math.sqrt(bot);  }\r\n\r\n    public equals(pt: {x:number, y:number}, tolleranzaX: number = 0, tolleranzaY: number = 0): boolean {\r\n        if (pt === null) { return false; }\r\n        return Math.abs(this.x - pt.x) <= tolleranzaX && Math.abs(this.y - pt.y) <= tolleranzaY; }\r\n\r\n    public moveOnNearestBorder(startVertexSize: ISize, clone: boolean, graph: TODO/*IGraph*/, debug: boolean = true): IPoint {\r\n        const pt: IPoint = clone ? this.duplicate() : this;\r\n        const tl: IPoint = startVertexSize.tl();\r\n        const tr: IPoint = startVertexSize.tr();\r\n        const bl: IPoint = startVertexSize.bl();\r\n        const br: IPoint = startVertexSize.br();\r\n        const L: number = pt.distanceFromLine(tl, bl);\r\n        const R: number = pt.distanceFromLine(tr, br);\r\n        const T: number = pt.distanceFromLine(tl, tr);\r\n        const B: number = pt.distanceFromLine(bl, br);\r\n        const min: number = Math.min(L, R, T, B);\r\n        if (min === L) { pt.x = tl.x; }\r\n        if (min === R) { pt.x = tr.x; }\r\n        if (min === T) { pt.y = tr.y; }\r\n        if (min === B) { pt.y = br.y; }\r\n        if (debug && graph && pt instanceof GraphPoint) { graph.markg(pt, false, 'purple'); }\r\n        return pt; }\r\n\r\n    public getM(pt2: IPoint): number { return IPoint.getM?.(this, pt2) as unknown as number; }\r\n\r\n    public degreeWith(pt2: IPoint, toRadians: boolean): number {\r\n        const directionVector: IPoint = this.subtract(pt2, true);\r\n        const ret: number = Math.atan2(directionVector.y, directionVector.x);\r\n        return toRadians ? ret : windoww.U.RadToDegree(ret); }\r\n\r\n    public absolute(): number { return Math.sqrt(this.x * this.x + this.y * this.y); }\r\n    public set(x: number, y: number) { this.x = x; this.y = y; }\r\n\r\n    // move the point by a vector with direction and distance (module)\r\n    move(rad: radian /*in radians!*/, distance: number, clone:boolean = true): this{\r\n        let pt = clone ? this.duplicate() : this;\r\n        pt.x += distance * Math.cos(rad);\r\n        pt.y += distance * Math.sin(rad);\r\n        return pt;\r\n    }\r\n\r\n    static stringify(ptlike: {x?:number, y?:number}): string {\r\n        if (!ptlike) return ptlike;\r\n        let str: string[];\r\n        return '('+U.cropNum(ptlike.x||0)+', '+U.cropNum(ptlike.y||0)+')';\r\n    }\r\n}\r\n\r\n@RuntimeAccessible('GraphPoint')\r\nexport class GraphPoint extends IPoint{\r\n    private dontmixwithPoint: any;\r\n    public static fromEvent(e: JQuery.ClickEvent | JQuery.MouseMoveEvent | JQuery.MouseUpEvent | JQuery.MouseDownEvent | JQuery.MouseEnterEvent | JQuery.MouseLeaveEvent | JQuery.MouseEventBase)\r\n        : GraphPoint | null {\r\n        if (!e) { return null; }\r\n        const p: Point = new Point(e.pageX, e.pageY);\r\n        const g: any = null;\r\n        throw new Error(\"todo: const g: IGraph = Status.status.getActiveModel().graph;\");\r\n        return g.toGraphCoord(p); }\r\n\r\n    protected new(): this { return new GraphPoint() as this;}\r\n    public toSize(w: number, h?: number): GraphSize {\r\n        return new GraphSize(this.x, this.y, w, (h === undefined) ? w : h);\r\n    }\r\n\r\n}\r\n\r\n\r\n@RuntimeAccessible('Point')\r\nexport class Point extends IPoint{\r\n    private dontmixwithGPoint: any;\r\n    /// https://stackoverflow.com/questions/6073505/what-is-the-difference-between-screenx-y-clientx-y-and-pagex-y\r\n    public static fromEvent(e: JQuery.ClickEvent | JQuery.MouseMoveEvent | JQuery.MouseUpEvent | JQuery.MouseDownEvent\r\n        | JQuery.MouseEnterEvent | JQuery.MouseLeaveEvent | JQuery.MouseEventBase | React.MouseEvent)\r\n        : Point {\r\n        const p: Point = new Point(e.pageX, e.pageY);\r\n        return p; }\r\n\r\n    protected new(): this { return new Point() as this;}\r\n    public toSize(w: number, h?: number): Size {\r\n        return new Size(this.x, this.y, w, (h === undefined) ? w : h);\r\n    }\r\n}\r\n\r\nRuntimeAccessibleClass.set_extend(RuntimeAccessibleClass, IPoint);\r\nRuntimeAccessibleClass.set_extend(IPoint, GraphPoint);\r\nRuntimeAccessibleClass.set_extend(IPoint, Point);\r\n\r\n@RuntimeAccessible('ISize')\r\nexport abstract class ISize<PT extends IPoint = IPoint> extends RuntimeAccessibleClass {\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    public x!: number;\r\n    public y!: number;\r\n    public w!: number;\r\n    public h!: number;\r\n    public constructor(x: number = 0, y: number = 0, w: number = 0, h: number = 0) {\r\n        super(); // super('dwc');\r\n        // do not override any fields from the DPointerTargetable, otherwise the ! in the override will reinizialize the attribute\r\n        // erasing the value set in super or in the functions called by the constructor as side effect (static_init called from constructor will be overridden too)\r\n        // if need to override types, build the \"new\" static function like in DModelElement\r\n        ISize.init_constructor(this, x, y, w, h);\r\n    }\r\n\r\n\r\n    static printDiff(s1: SizeLike, s2: SizeLike, asPoints:boolean = false) {\r\n        s1 = {...s1, w: s1.w ?? s1.width, h: s1.h ?? s1.height};\r\n        s1.x = s1.x ?? s2.x;\r\n        s1.y = s1.y ?? s2.y;\r\n        s2 = {...s2, w: s2.w ?? s2.width, h: s2.h ?? s2.height};\r\n        if (!asPoints) {\r\n            s1.w = s1.w ?? s2.w;\r\n            s1.h = s1.h ?? s2.h;\r\n        }\r\n        let s1coords: (number | string)[] = [];\r\n        s1coords.push(U.isNumber(s1.x) ? '' : U.cropNum(s1.x));\r\n        s1coords.push(U.isNumber(s1.y) ? ',' : ', '+U.cropNum(s1.y));\r\n        if (!asPoints) {\r\n            s1coords.push(U.isNumber(s1.w) ? ',' : ', '+U.cropNum(s1.w));\r\n            s1coords.push(U.isNumber(s1.h) ? ',' : ', '+U.cropNum(s1.h));\r\n        }\r\n        let s2coords: (number | string)[] = [];\r\n        s2coords.push(s2.x === s1.x || !U.isNumber(s2.x) ? '' : U.cropNum(s2.x));\r\n        s2coords.push(s2.y === s1.y || !U.isNumber(s2.y) ? ',' : ', '+U.cropNum(s2.y));\r\n        if (!asPoints) {\r\n            s2coords.push(s2.w === s1.w || !U.isNumber(s2.w) ? ',' : ', '+U.cropNum(s2.w));\r\n            s2coords.push(s2.h === s1.h || !U.isNumber(s2.h) ? ',' : ', '+U.cropNum(s2.h));\r\n        }\r\n\r\n        return `(`+s1coords.join('')+`)(`+s2coords.join('')+`)`;\r\n    }\r\n    static stringify(ptlike: {x?:number, y?:number, w?:number, h?:number, width?:number, height?:number}): string {\r\n        if (!ptlike) return ptlike as any;\r\n        let str: string[] = [];\r\n        if (ptlike.x && !isNaN(ptlike.x)|| ptlike.x === 0) str.push('x:'+U.cropNum(ptlike.x));\r\n        if (ptlike.y && !isNaN(ptlike.y)|| ptlike.y === 0) str.push('y:'+U.cropNum(ptlike.y));\r\n        if (ptlike.w && !isNaN(ptlike.w)|| ptlike.w === 0) str.push('w:'+U.cropNum(ptlike.w));\r\n        if (ptlike.h && !isNaN(ptlike.h)|| ptlike.h === 0) str.push('h:'+U.cropNum(ptlike.h));\r\n        if (ptlike.width && !isNaN(ptlike.width) || ptlike.width === 0) str.push('W:'+U.cropNum(ptlike.width));\r\n        if (ptlike.height && !isNaN(ptlike.height) || ptlike.height === 0) str.push('H:'+U.cropNum(ptlike.height));\r\n        // if (str.length === 0) return '{}';\r\n        return '{'+str.join(', ')+'}';\r\n    }\r\n\r\n    static init_constructor(thiss: GObject, x: any = 0, y: any = 0, w: any = 0, h: any = 0, ...a: any): void {\r\n        thiss.id = \"SIZE_\" + (DPointerTargetable.maxID++) + \"_\" + new Date().getTime();\r\n        thiss.className = (thiss.constructor as typeof RuntimeAccessibleClass).cname;\r\n        if (x === null || x === undefined) thiss.x = undefined as Temporary;\r\n        else if (isNaN(+x)) { thiss.x = 0; }\r\n        else thiss.x = +x;\r\n        if (y === null || y === undefined) thiss.y = undefined as Temporary;\r\n        else if (isNaN(+y)) { thiss.y = 0; }\r\n        else thiss.y = +y;\r\n        if (w === null || w === undefined) thiss.w = undefined as Temporary;\r\n        else if (isNaN(+w)) { thiss.w = 0; }\r\n        else thiss.w = +w;\r\n        if (h === null || h === undefined) thiss.h = undefined as Temporary;\r\n        else if (isNaN(+h)) { thiss.h = 0; }\r\n        else thiss.h = +h;\r\n        thiss.className = this.cname; }\r\n\r\n    public toString(letters: boolean=true, separator: string = \" \"): string {\r\n        if (letters) return JSON.stringify({x: this.x, y: this.y, w: this.w, h: this.h});\r\n        else return this.x + separator + this.y + separator + this.w + separator + this.h;\r\n    }\r\n\r\n    public set(x?: number, y?: number, w?: number, h?: number): void {\r\n        if (x !== undefined) (this.x = +x);\r\n        if (y !== undefined) (this.y = +y);\r\n        if (w !== undefined) (this.w = +w);\r\n        if (h !== undefined) (this.h = +h);\r\n    }\r\n\r\n    protected abstract makePoint(x: number, y: number): PT;\r\n    protected abstract new(...args:any): this;\r\n    public clone(json: this): this { this.x = json.x; this.y = json.y; this.w = json.w; this.h = json.h; return this; }\r\n    public duplicate(): this { return this.new().clone(this); }\r\n\r\n    public add(pt2: number | {x?:number, y?:number, w?:number, h?:number}, newInstance?: boolean): this {\r\n        let thiss = newInstance ? this.duplicate() : this;\r\n        if (typeof pt2 === \"number\") { thiss.x += pt2; thiss.y += pt2; thiss.w += pt2; thiss.h += pt2; return thiss; }\r\n        if (pt2.x !== undefined) thiss.x += pt2.x;\r\n        if (pt2.y !== undefined) thiss.y += pt2.y;\r\n        if (pt2.w !== undefined) thiss.w += pt2.w;\r\n        if (pt2.h !== undefined) thiss.h += pt2.h;\r\n        return thiss; }\r\n\r\n    public subtract(pt2: number | {x?:number, y?:number, w?:number, h?:number}, newInstance?: boolean): this {\r\n        let thiss = newInstance ? this.duplicate() : this;\r\n        if (typeof pt2 === \"number\") { thiss.x -= pt2; thiss.y -= pt2; thiss.w -= pt2; thiss.h -= pt2; return thiss; }\r\n        if (pt2.x !== undefined) thiss.x -= pt2.x;\r\n        if (pt2.y !== undefined) thiss.y -= pt2.y;\r\n        if (pt2.w !== undefined) thiss.w -= pt2.w;\r\n        if (pt2.h !== undefined) thiss.h -= pt2.h;\r\n        return thiss; }\r\n\r\n    public multiply(pt2: number | {x?:number, y?:number, w?:number, h?:number}, newInstance?: boolean): this {\r\n        let thiss = newInstance ? this.duplicate() : this;\r\n        if (typeof pt2 === \"number\") { thiss.x *= pt2; thiss.y *= pt2; thiss.w *= pt2; thiss.h *= pt2; return thiss; }\r\n        if (pt2.x !== undefined) thiss.x *= pt2.x;\r\n        if (pt2.y !== undefined) thiss.y *= pt2.y;\r\n        if (pt2.w !== undefined) thiss.w *= pt2.w;\r\n        if (pt2.h !== undefined) thiss.h *= pt2.h;\r\n        return thiss; }\r\n\r\n    public divide(pt2: number | {x?:number, y?:number, w?:number, h?:number}, newInstance?: boolean): this {\r\n        let thiss = newInstance ? this.duplicate() : this;\r\n        if (typeof pt2 === \"number\") { thiss.x /= pt2; thiss.y /= pt2; thiss.w /= pt2; thiss.h /= pt2; return thiss; }\r\n        if (pt2.x !== undefined) thiss.x /= pt2.x;\r\n        if (pt2.y !== undefined) thiss.y /= pt2.y;\r\n        if (pt2.w !== undefined) thiss.w /= pt2.w;\r\n        if (pt2.h !== undefined) thiss.h /= pt2.h;\r\n        return thiss; }\r\n\r\n\r\n    public tl(): PT {     return this.makePoint(   this.x,                 this.y             ); }\r\n    public tr(): PT {     return this.makePoint(this.x + this.w,        this.y             ); }\r\n    public bl(): PT {     return this.makePoint(   this.x,              this.y + this.h    ); }\r\n    public br(): PT {     return this.makePoint(this.x + this.w,     this.y + this.h    ); }\r\n    public center(): PT { return this.makePoint(this.x + this.w / 2, this.y + this.h / 2); }\r\n    public relativePoint(xPercent: number, yPercent: number): PT { return this.makePoint(this.x + this.w * xPercent, this.y + this.h * yPercent); }\r\n    public equals(size: this): boolean { return this.x === size.x && this.y === size.y && this.w === size.w && this.h === size.h; }\r\n\r\n    /// field-wise Math.min()\r\n    public min(minSize: this, clone: boolean): this {\r\n        const ret: this = clone ? this.new() : this;\r\n        if (!isNaN(minSize.x) && ret.x < minSize.x) { ret.x = minSize.x; }\r\n        if (!isNaN(minSize.y) && ret.y < minSize.y) { ret.y = minSize.y; }\r\n        if (!isNaN(minSize.w) && ret.w < minSize.w) { ret.w = minSize.w; }\r\n        if (!isNaN(minSize.h) && ret.h < minSize.h) { ret.h = minSize.h; }\r\n        return ret; }\r\n    public max(maxSize: this, clone: boolean): this {\r\n        const ret: this = clone ? this.new() : this;\r\n        if (!isNaN(maxSize.x) && ret.x > maxSize.x) { ret.x = maxSize.x; }\r\n        if (!isNaN(maxSize.y) && ret.y > maxSize.y) { ret.y = maxSize.y; }\r\n        if (!isNaN(maxSize.w) && ret.w > maxSize.w) { ret.w = maxSize.w; }\r\n        if (!isNaN(maxSize.h) && ret.h > maxSize.h) { ret.h = maxSize.h; }\r\n        return ret; }\r\n\r\n    public intersection(size: this): this | null {\r\n        if (!size) return null;\r\n        // anche \"isinside\"\r\n        let startx, starty, endx, endy;\r\n        startx = Math.max(this.x, size.x);\r\n        starty = Math.max(this.y, size.y);\r\n        endx = Math.min(this.x + this.w, size.x + size.w);\r\n        endy = Math.min(this.y + this.h, size.y + size.h);\r\n        const intersection: this = this.new();\r\n        // intersection.set(0, 0, 0, 0);\r\n        intersection.x = startx;\r\n        intersection.y = starty;\r\n        intersection.w = endx - startx;\r\n        intersection.h = endy - starty;\r\n        const doesintersect: boolean = intersection.w > 0 && intersection.h > 0;\r\n        return (doesintersect) ? intersection: null; }\r\n\r\n    public contains(pt: PT): boolean {\r\n        return  pt.x >= this.x && pt.x <= this.x + this.w && pt.y >= this.y && pt.y <= this.y + this.h; }\r\n\r\n    public isOverlapping(size2: this): boolean { return !!this.intersection(size2); }\r\n    public isOverlappingAnyOf(sizes: this[]): boolean {\r\n        if (!sizes) return false;\r\n        for (let size of sizes) { if (this.isOverlapping(size)) return true; }\r\n        return false;\r\n    }\r\n\r\n    public multiplyPoint(other: PT, newInstance: boolean): this {\r\n        const ret: this = newInstance ? this.new() : this;\r\n        ret.x *= other.x;\r\n        ret.w *= other.x;\r\n        ret.y *= other.y;\r\n        ret.h *= other.y;\r\n        return ret; }\r\n\r\n    public dividePoint(other: PT, newInstance: boolean): this {\r\n        const ret: this = newInstance ? this.new() : this;\r\n        ret.x /= other.x;\r\n        ret.w /= other.x;\r\n        ret.y /= other.y;\r\n        ret.h /= other.y;\r\n        return ret; }\r\n\r\n    public boundary(size2: this): void {\r\n        /*let minx, maxx, miny, maxy;\r\n        if (size2.y < this.y) { miny = size2.y; /*maxy = this.y;* / } else { miny = this.y; /*maxy = size2.y;* / }\r\n        if (size2.x < this.x) { minx = size2.y; /*maxx = this.x;* / } else { minx = this.x; /*maxy = size2.x;* / }\r\n        if (size2.y + size2.h < this.y + this.h) maxy = this.y + this.h; else maxy = size2.y + size2.h;\r\n        if (size2.x + size2.w < this.x + this.w) maxx = this.x + this.w; else maxx = size2.x + size2.w;\r\n        */\r\n        this.h = (size2.y + size2.h > this.y + this.h ? size2.y + size2.h : this.y + this.h); // -miny\r\n        this.w = (size2.x + size2.w > this.x + this.w ? size2.x + size2.w : this.x + this.w); // -minx\r\n        if (this.y < size2.y) this.y = size2.y;\r\n        if (this.x < size2.x) this.x = size2.x;\r\n        this.h -= this.y;\r\n        this.w -= this.x;\r\n    }\r\n}\r\ntype SizeLike = {x?: number, y?: number, w?: number, h?:number, width?: number, height?: number}\r\ntype PointLike = {x?: number, y?: number}\r\n\r\n@RuntimeAccessible('Size')\r\nexport class Size extends ISize<Point> {\r\n    static subclasses: any[] = [];\r\n    private static sizeofvar: HTMLElement;\r\n    private static $sizeofvar: JQuery<HTMLElement>;\r\n    private dontMixWithGraphSize: any;\r\n\r\n    /**\r\n     * measure a node size\r\n     * @param {Element} element0 - the emelemnt to measure;\r\n     * @param {boolean} sizePostTransform - includes css transform instructions for computing his size. like transform: scale(1.5)\r\n     * */\r\n    public static of(element0: Element, sizePostTransform: boolean = true): Size {\r\n        let element: HTMLElement = element0 as HTMLElement;\r\n        if (element as unknown === document) {\r\n            Log.ww('trying to measure document, rerouted to measuring body.');\r\n            element = document.body as any;\r\n        }\r\n        const $element = $(element);\r\n        Log.ex(!element || element.tagName === 'foreignObject', 'sizeof()', 'SvgForeignElementObject have a bug with size, measure a child instead.', element);\r\n        let tmp;\r\n        let size: Size;\r\n        if (!Size.sizeofvar) {\r\n            Size.sizeofvar = document.createElement('div');\r\n            document.body.append(Size.sizeofvar); }\r\n\r\n        const isOrphan = element.parentNode === null;\r\n        // var visible = element.style.display !== 'none';\r\n        // var visible = $element.is(\":visible\"); crea bug quando un elemento è teoricamente visibile ma orfano\r\n        const ancestors =  windoww.U.ancestorArray(element);\r\n        const displayStyles: string[] = ancestors.map( (e: HTMLElement) => e?.style?.display);\r\n        if (isOrphan) { Size.sizeofvar.append(element); }\r\n        // show all and saveToDB visibility to restore it later\r\n        for (let i = 0; i < ancestors.length; i++) { // document has undefined style\r\n            displayStyles[i] = ancestors[i]?.style?.display;\r\n            if (displayStyles[i] === 'none' || (displayStyles[i] === '' && getComputedStyle(ancestors[i]).display === 'none')) { ancestors[i].style.display = 'block' }\r\n        }\r\n        // size = new Size(tmp.left, tmp.top, 0, 0);\r\n        let rect = element.getBoundingClientRect();\r\n        size = new Size(0, 0, 0, 0);\r\n\r\n        let win = (element.ownerDocument?.defaultView || window);\r\n        size.x = rect.left + win.scrollX;\r\n        size.y = rect.top + win.scrollY;\r\n        if (sizePostTransform) {\r\n            size.w = rect.width;\r\n            size.h = rect.height;\r\n        }\r\n        else {\r\n            size.w = element.offsetWidth; // element.scrollWidth;\r\n            size.h = element.offsetHeight;\r\n        }\r\n        // restore visibility\r\n        for (let i = 0; i < ancestors.length; i++) {\r\n            if (displayStyles[i] === ancestors[i].style?.display) continue;\r\n            if (displayStyles[i]) ancestors[i].style.display = displayStyles[i];\r\n            else ancestors[i].style.removeProperty('display');\r\n        }\r\n        if (isOrphan) {  windoww.U.clear(Size.sizeofvar); }\r\n        // Status.status.getActiveModel().graph.markS(size, false);\r\n        return size;\r\n    }\r\n\r\n    public static fromPoints(firstPt: IPoint, secondPt: IPoint): Size {\r\n        const minX = Math.min(firstPt.x, secondPt.x);\r\n        const maxX = Math.max(firstPt.x, secondPt.x);\r\n        const minY = Math.min(firstPt.y, secondPt.y);\r\n        const maxY = Math.max(firstPt.y, secondPt.y);\r\n        return new Size(minX, minY, maxX - minX, maxY - minY); }\r\n\r\n    protected makePoint(x: number, y: number): Point { return new Point(x, y); }\r\n    protected new(...args:any): this { return new Size(...args) as this; }\r\n}\r\n@RuntimeAccessible('GraphSize')\r\nexport class GraphSize extends ISize<GraphPoint> {\r\n    private dontMixWithSize: any;\r\n\r\n    public static fromPoints(firstPt: GraphPoint, secondPt: GraphPoint): GraphSize {\r\n        const minX = Math.min(firstPt.x, secondPt.x);\r\n        const maxX = Math.max(firstPt.x, secondPt.x);\r\n        const minY = Math.min(firstPt.y, secondPt.y);\r\n        const maxY = Math.max(firstPt.y, secondPt.y);\r\n        return new GraphSize(minX, minY, maxX - minX, maxY - minY); }\r\n\r\n    // both pt and targetPt are readonly-safe parameters\r\n    public static closestIntersection(size: GraphSize, pt: GraphPoint, targetPt: GraphPoint, gridAlign?: GraphPoint, m0?:number, q0?:number): GraphPoint | undefined {\r\n        // let pt: GraphPoint = pt0.duplicate();\r\n        const m = m0 || GraphPoint.getM(targetPt, pt);\r\n        const q = q0 || GraphPoint.getQ(targetPt, pt);\r\n        // console.log(\"closestIntersection()\", {size, pt0, targetPt, m, q});\r\n        // if perfectly vertical line\r\n        if (m === Number.POSITIVE_INFINITY/* && q === Number.NEGATIVE_INFINITY*/) {\r\n            // top center\r\n            if (Math.abs(targetPt.y - size.y) <= Math.abs(targetPt.y - size.y - size.h)) return pt;\r\n            // bottom center\r\n            else return new GraphPoint(pt.x, size.y + size.h);\r\n        }\r\n        let tl = size.tl(), tr = size.tr(),\r\n            bl = size.bl(), br = size.br();\r\n        let allowT: boolean, allowB: boolean,\r\n            allowL: boolean, allowR: boolean;\r\n        /*let distanceT: number = Number.POSITIVE_INFINITY, distanceB: number = Number.POSITIVE_INFINITY,\r\n            distanceL: number = Number.POSITIVE_INFINITY, distanceR: number = Number.POSITIVE_INFINITY;*/\r\n        let intersectionT: GraphPoint | undefined, intersectionB: GraphPoint | undefined,\r\n            intersectionL: GraphPoint | undefined, intersectionR: GraphPoint | undefined;\r\n\r\n\r\n        allowT = Geom.isNumberBetween(tl.y, bl.y, targetPt.y);\r\n        allowB = Geom.isNumberBetween(bl.y, tl.y, targetPt.y);\r\n        allowL = Geom.isNumberBetween(tl.x, tr.x, targetPt.x);\r\n        allowR = Geom.isNumberBetween(tr.x, tl.x, targetPt.x);\r\n        // console.log(\"closestIntersection pt0\", {size, targetPt, pt0:pt0.raw(), gridAlign,\r\n        //     corners:{tl:tl.raw(), tr:tr.raw(), bl:bl.raw(), br:br.raw()}, allows:{allowT, allowB, allowL, allowR}});\r\n        if (!(allowT || allowB || allowL || allowR)) return undefined; // point is internal to size\r\n        if (allowT) intersectionT = Geom.lineToSegmentIntersection(tl, tr, q, m); else\r\n        if (allowB) intersectionB = Geom.lineToSegmentIntersection(bl, br, q, m); // NOT else, (T|B) AND (L|R) can happen, or just 1 or 0 of those.\r\n        if (allowL) intersectionL = Geom.lineToSegmentIntersection(tl, bl, q, m); else\r\n        if (allowR) intersectionR = Geom.lineToSegmentIntersection(tr, br, q, m);\r\n\r\n        // console.log(\"closestIntersection pt2\", {intersectionT, intersectionB, intersectionL, intersectionR});\r\n        // only 1 intersection can happen\r\n        return intersectionT || intersectionB || intersectionL || intersectionR;\r\n    }\r\n    public static closestIntersection_old(size: GraphSize, prevPt: GraphPoint, pt0: GraphPoint, gridAlign?: GraphPoint): GraphPoint | null {\r\n        let ret = GraphSize.closestIntersection0(size, prevPt, pt0, gridAlign) as any;\r\n        // Log.exDev(!Geom.isOnEdge(ret, size), 'ClosestIntersection failed. not on Vertex edge.', {ret, size, prevPt, pt0, gridAlign});\r\n        return ret;\r\n    }\r\n    private static closestIntersection0(vertexGSize: GraphSize, prevPt: GraphPoint, pt0: GraphPoint, gridAlign?: GraphPoint): GraphPoint | null {\r\n        let pt: GraphPoint | null = pt0.duplicate();\r\n        const m = GraphPoint.getM(prevPt, pt) as number;\r\n        const q = GraphPoint.getQ(prevPt, pt) as number;\r\n        // U.pe( Math.abs((pt.y - m * pt.x) - (prevPt.y - m * prevPt.x)) > .001, 'wrong math in Q:', (pt.y - m * pt.x), ' vs ', (prevPt.y - m * prevPt.x));\r\n        /*const isL = prevPt.x < pt.x;\r\n    const isT = prevPt.y < pt.y;\r\n    const isR = !isL;\r\n    const isB = !isT; */\r\n        if (m === Number.POSITIVE_INFINITY && q === Number.NEGATIVE_INFINITY) { // bottom middle\r\n            return new GraphPoint(vertexGSize.x + vertexGSize.w / 2, vertexGSize.y + vertexGSize.h); }\r\n        // console.log('pt:', pt, 'm:', m, 'q:', q);\r\n        let L: GraphPoint | null = new GraphPoint(0, 0);\r\n        let T: GraphPoint | null = new GraphPoint(0, 0);\r\n        let R: GraphPoint | null = new GraphPoint(0, 0);\r\n        let B: GraphPoint | null = new GraphPoint(0, 0);\r\n        L.x = vertexGSize.x;\r\n        L.y = m * L.x + q;\r\n        R.x = vertexGSize.x + vertexGSize.w;\r\n        R.y = m * R.x + q;\r\n        T.y = vertexGSize.y;\r\n        T.x = (T.y - q) / m;\r\n        B.y = vertexGSize.y + vertexGSize.h;\r\n        B.x = (B.y - q) / m;\r\n        // prendo solo il compreso pt ~ prevPt (escludo così il \"pierce\" sulla faccia opposta), prendo il più vicino al centro.\r\n        // console.log('4 possibili punti di intersezione (LTBR):', L, T, B, R);\r\n        /* this.owner.mark(this.owner.toHtmlCoord(T), true, 'blue');\r\n    this.owner.mark(this.owner.toHtmlCoord(B), false, 'violet');\r\n    this.owner.mark(this.owner.toHtmlCoord(L), false, 'red');\r\n    this.owner.mark(this.owner.toHtmlCoord(R), false, 'orange');*/\r\n        console.log(\"intersect pt1:\", {T, B, L, R});\r\n        if ( (B.x >= pt.x && B.x <= prevPt.x) || (B.x >= prevPt.x && B.x <= pt.x) ) { } else { B = null; }\r\n        if ( (T.x >= pt.x && T.x <= prevPt.x) || (T.x >= prevPt.x && T.x <= pt.x) ) { } else { T = null; }\r\n        if ( (L.y >= pt.y && L.y <= prevPt.y) || (L.y >= prevPt.y && L.y <= pt.y) ) { } else { L = null; }\r\n        if ( (R.y >= pt.y && R.y <= prevPt.y) || (R.y >= prevPt.y && R.y <= pt.y) ) { } else { R = null; }\r\n        console.log(\"intersect pt2:\", {T, B, L, R});\r\n        function closestmix(pt: GraphPoint, closest: GraphPoint, segStart: GraphPoint, segEnd: GraphPoint, mode: \"TB\" | \"LR\"): void {\r\n            // changes pt\r\n            pt.x = closest.x; pt.y = closest.y; return;\r\n            let main: \"x\" | \"y\", sub: \"x\" | \"y\";\r\n            if (mode === \"TB\") { main = \"y\"; sub = \"x\"; } else { main = \"x\"; sub = \"y\"; }\r\n            pt[main] = closest[main];\r\n            // if T[sub] is inside the top segment, take T[sub], otherwise closest between size.tl[sub] and size.tr[sub]\r\n            // pt[sub] = Math.max(segStart[sub], Math.min(segStart[sub], closest[sub]));\r\n            if (closest[sub] <= segEnd[sub] && closest[sub] >= segStart[sub]) pt[sub] = closest[sub];\r\n            else if (Math.abs(closest[sub]-segEnd[sub]) < Math.abs(closest[sub]-segStart[sub])) pt[sub] = segEnd[sub];\r\n            else pt[sub] = segStart[sub];\r\n        }\r\n        function closestmix2(pt: GraphPoint, closest: GraphPoint, segStart: GraphPoint, segEnd: GraphPoint, mode: \"TB\" | \"LR\"): void {\r\n            // changes closest\r\n            let main: \"x\" | \"y\", sub: \"x\" | \"y\";\r\n            if (mode === \"TB\") { main = \"y\"; sub = \"x\"; } else { main = \"x\"; sub = \"y\"; }\r\n            // closest[main] = pt[main];\r\n            // if T[sub] is inside the top segment, take T[sub], otherwise closest between size.tl[sub] and size.tr[sub]\r\n            // pt[sub] = Math.max(segStart[sub], Math.min(segStart[sub], closest[sub]));\r\n            if (closest[sub] <= segEnd[sub] && closest[sub] >= segStart[sub]) {/*no-op*/}\r\n            else if (Math.abs(closest[sub]-segEnd[sub]) < Math.abs(closest[sub]-segStart[sub])) closest[sub] = segEnd[sub];\r\n            else closest[sub] = segStart[sub];\r\n        }\r\n        console.log(\"intersect pt2.5:\");\r\n        try{\r\n            if(T) closestmix2(pt, T, vertexGSize.tl(), vertexGSize.tr(), \"TB\");\r\n            if(B) closestmix2(pt, B, vertexGSize.bl(), vertexGSize.br(), \"TB\");\r\n            if(R) closestmix2(pt, R, vertexGSize.tr(), vertexGSize.br(), \"LR\");\r\n            if(L) closestmix2(pt, L, vertexGSize.tl(), vertexGSize.bl(), \"LR\");\r\n        } catch(e){ console.error(\"intersect error\",e)}\r\n        // console.log('superstiti step1: (LTBR):', L, T, B, R);\r\n        console.log(\"intersect pt2.9:\");\r\n        const vicinanzaT = !T ? Number.POSITIVE_INFINITY : ((T.x - pt.x) * (T.x - pt.x)) + ((T.y - pt.y) * (T.y - pt.y));\r\n        const vicinanzaB = !B ? Number.POSITIVE_INFINITY : ((B.x - pt.x) * (B.x - pt.x)) + ((B.y - pt.y) * (B.y - pt.y));\r\n        const vicinanzaL = !L ? Number.POSITIVE_INFINITY : ((L.x - pt.x) * (L.x - pt.x)) + ((L.y - pt.y) * (L.y - pt.y));\r\n        const vicinanzaR = !R ? Number.POSITIVE_INFINITY : ((R.x - pt.x) * (R.x - pt.x)) + ((R.y - pt.y) * (R.y - pt.y));\r\n        const closest = Math.min(vicinanzaT, vicinanzaB, vicinanzaL, vicinanzaR);\r\n        console.log(\"intersect pt3:\", {vicinanzaT, vicinanzaB, vicinanzaL, vicinanzaR, closest});\r\n\r\n        // console.log( 'closest:', closest);\r\n        // succede quando pt e prevPt sono entrambi all'interno del rettangolo del vertice.\r\n        // L'edge non è visibile e il valore ritornato è irrilevante.\r\n\r\n        if (closest === Number.POSITIVE_INFINITY) {\r\n            /* top center */\r\n            pt = vertexGSize.tl();\r\n            pt.x += vertexGSize.w / 2; } else\r\n        if (closest === Number.POSITIVE_INFINITY) {\r\n            /* bottom center */\r\n            pt = vertexGSize.br();\r\n            pt.x -= vertexGSize.w / 2; } else\r\n        if (closest === vicinanzaT && T) {\r\n            closestmix(pt, T as any, vertexGSize.tl(), vertexGSize.tr(), \"TB\");\r\n            /*pt.y = T.y;\r\n            // if T.x is inside the top segment, take T.x, otherwise closest between size.tl.x and size.tr.x\r\n            if ((T.x <= tr.x && T.x >= tl.x)) pt.x = T.x;\r\n            else if (Math.abs(T.x-tr.x) < Math.abs(T.x-tl.x)) pt.x = tr.x;\r\n            else pt.x = tl.x;*/\r\n        }\r\n        if (closest === vicinanzaB) { closestmix(pt, B as any, vertexGSize.bl(), vertexGSize.br(), \"TB\"); } else\r\n        if (closest === vicinanzaR) { closestmix(pt, R as any, vertexGSize.tr(), vertexGSize.br(), \"LR\"); } else\r\n        if (closest === vicinanzaL) { closestmix(pt, L as any, vertexGSize.tl(), vertexGSize.bl(), \"LR\"); }\r\n\r\n        if (!gridAlign) { return pt; }\r\n        if (!pt) return null;\r\n        if (gridAlign.x && (pt === T || pt === B || isNaN(closest))) {\r\n            const floorX: number = Math.floor(pt.x / gridAlign.x) * gridAlign.x;\r\n            const ceilX: number = Math.ceil(pt.x / gridAlign.x) * gridAlign.x;\r\n            let closestX;\r\n            let farthestX;\r\n            if (Math.abs(floorX - pt.x) < Math.abs(ceilX - pt.x)) {\r\n                closestX = floorX; farthestX = ceilX;\r\n            } else { closestX = ceilX; farthestX = floorX; }\r\n\r\n            // todo: possibile causa del bug che non allinea punti fake a punti reali. nel calcolo realPT questo non viene fatto.\r\n            // if closest grid intersection is inside the vertex.\r\n            if (closestX >= vertexGSize.x && closestX <= vertexGSize.x + vertexGSize.w) { pt.x = closestX; } else\r\n                // if 2° closer grid intersection is inside the vertex.\r\n            if (closestX >= vertexGSize.x && closestX <= vertexGSize.x + vertexGSize.w) { pt.x = farthestX;\r\n                // if no intersection are inside the vertex (ignore grid)\r\n            } else { /* do nothing */ }\r\n        } else if (gridAlign.y && (pt === L || pt === R)) {\r\n            const floorY: number = Math.floor(pt.y / gridAlign.y) * gridAlign.y;\r\n            const ceilY: number = Math.ceil(pt.y / gridAlign.y) * gridAlign.y;\r\n            let closestY;\r\n            let farthestY;\r\n            if (Math.abs(floorY - pt.y) < Math.abs(ceilY - pt.y)) {\r\n                closestY = floorY; farthestY = ceilY;\r\n            } else { closestY = ceilY; farthestY = floorY; }\r\n\r\n            // if closest grid intersection is inside the vertex.\r\n            if (closestY >= vertexGSize.y && closestY <= vertexGSize.y + vertexGSize.h) { pt.y = closestY; } else\r\n                // if 2° closer grid intersection is inside the vertex.\r\n            if (closestY >= vertexGSize.y && closestY <= vertexGSize.y + vertexGSize.h) { pt.y = farthestY;\r\n                // if no intersection are inside the vertex (ignore grid)\r\n            } else { /* do nothing */ }\r\n        }\r\n        return pt; }\r\n\r\n\r\n    protected new(...args: any): this { return new GraphSize(...args) as this; }\r\n    protected makePoint(x: number, y: number): GraphPoint { return new GraphPoint(x, y) as GraphPoint; }\r\n\r\n    closestPoint(pt: GraphPoint): GraphPoint { return Geom.closestPoint(this, pt); }\r\n}\r\n\r\nRuntimeAccessibleClass.set_extend(RuntimeAccessibleClass, ISize);\r\nRuntimeAccessibleClass.set_extend(ISize, Size);\r\nRuntimeAccessibleClass.set_extend(ISize, GraphSize);\r\n\r\n\r\n\r\nexport type PositionStrTypes =\r\n    \"top\" | \"bottom\" | \"left\" | \"right\" | \"\" | // '' = x&y center, undefined = top\r\n    \"top right\" | \"top left\" | \"bottom left\" | \"bottom right\" |\r\n    \"right top\" | \"left top\" | \"left bottom\" | \"right bottom\" |\r\n    \"t\" | \"b\" | \"l\" | \"r\" |\r\n    \"tl\" | \"tr\" | \"bl\" | \"br\" |\r\n    \"lt\" | \"rt\" | \"lb\" | \"rb\";\r\n\r\n@RuntimeAccessible('PositionStr')\r\nexport class PositionStr{\r\n    public static cname = 'PositionStr';\r\n\r\n    x: -1 | 0 | 1; // left, centered, right\r\n    y: -1 | 0 | 1;\r\n    constructor(x?: PositionStr['x'], y? :PositionStr['y']){\r\n        this.x = x ?? 0;\r\n        this.y = y ?? -1;\r\n    }\r\n    toString(): PositionStrTypes{\r\n        return PositionStr.toPosString(this);\r\n    }\r\n    invert(x = true, y = true): this {\r\n        if (x) this.x = -this.x as 1|0|-1;\r\n        if (y) this.y = -this.y as 1|0|-1;\r\n        return this;\r\n    }\r\n    public static toPosString(o: PositionStr): PositionStrTypes{\r\n        let s: string;\r\n        if (o.y === -1) s = 't';\r\n        else if (o.y === 1) s = 'b';\r\n        else s = '';\r\n\r\n        if (o.x === -1) s += 'l';\r\n        else if (o.x === 1) s += 'r';\r\n        // else s = +'';\r\n        // if (!s) return \"c\";\r\n        return s as PositionStrTypes;\r\n    }\r\n    public static fromPosString(position?: PositionStrTypes): PositionStr{\r\n        let ret = new PositionStr(0, 0);\r\n        let posarr = (position ?? 't').split(' '); // .map(s=>s[0]);\r\n        for (let p of posarr)\r\n            switch (p) {\r\n                default:\r\n                case \"t\": case \"top\":                       ret.y = -1; break;\r\n                case \"b\": case \"bottom\":                    ret.y =  1; break;\r\n                case \"l\": case \"left\":                      ret.x = -1; break;\r\n                case \"r\": case \"right\":                     ret.x =  1; break;\r\n                case \"tl\": case \"lt\": case \"top left\":      ret.y = -1; ret.x = -1; break;\r\n                case \"tr\": case \"rt\": case \"top right\":     ret.y = -1; ret.x =  1; break;\r\n                case '': case 'c':                          ret.x =  0; ret.y =  0; break;\r\n                case \"bl\": case \"lb\": case \"bottom left\":   ret.y =  1; ret.x = -1; break;\r\n                case \"br\": case \"rb\": case \"bottom right\":  ret.y =  1; ret.x =  1; break;\r\n            }\r\n        return ret;\r\n    }\r\n    public static invertPosStr(pos?: PositionStrTypes): PositionStrTypes{\r\n        return PositionStr.fromPosString(pos).invert().toString() as any;\r\n    }\r\n\r\n    private static toFullLabelSingle(position: string | \"\" | \"c\" | \"t\" | \"b\" | \"l\" | \"r\"): \"top\" | \"bottom\" | \"left\" | \"right\" | \"center\" {\r\n        switch (position?.trim()[0]){\r\n            case 'c': case '': return 'center';\r\n            case 't': return 'top';\r\n            default: if (position.trim() === '') return 'center'; return 'bottom';\r\n            case 'b': return 'bottom';\r\n            case 'l': return 'left';\r\n            case 'r': return 'right';\r\n        }\r\n    }\r\n    // tl -> top left\r\n    static toSeparateFullLabels(position?: PositionStrTypes): string {\r\n        let pos = (position ?? 'b').trim();\r\n\r\n        if (pos.length === 2) {\r\n            return PositionStr.toFullLabelSingle(pos[0]) + ' ' + PositionStr.toFullLabelSingle(pos[1]);\r\n        } else if (pos.indexOf(' ')) { return pos.split(' ').map(s => PositionStr.toFullLabelSingle(s as any)).join(' '); }\r\n        else return PositionStr.toFullLabelSingle(pos[0]);\r\n        return \"\";\r\n    }\r\n}\r\n\r\n@RuntimeAccessible('Geom')\r\nexport class Geom extends RuntimeAccessibleClass {\r\n\r\n    static markings: Dictionary<string, HTMLElement> = {};\r\n    static unmark(key: string): boolean{\r\n        if (!Geom.markings[key]) return false;\r\n        let e = Geom.markings[key];\r\n        U.removeFromDom(e);\r\n        delete Geom.markings[key];\r\n        return true;\r\n    }\r\n    static markPt(key: string, pt: Point, color?: string, label?: string): HTMLElement{ return Geom.mark(key, pt.x, pt.y, 1, 1, color, label); }\r\n    static markSize(key: string, pt: Size, color?: string, label?: string): HTMLElement{ return Geom.mark(key, pt.x, pt.y, pt.w??1, pt.h??1, color, label); }\r\n    static mark(key: string, x: number, y: number, w: number=1, h: number=1, color: string='red', label: string=''): HTMLElement{\r\n        if (Geom.markings[key]) Geom.unmark(key);\r\n        let e: HTMLElement;\r\n        let pre = '<div class=\"debug-mark\" data-key=\"'+key+'\" data-label=\"'+label+'\" style=\"position: absolute; z-index:99999; left:'+x+'px; top:'+y+'px; width: '+w+'px; height: '+h+'px;';\r\n        let post = '\"/>';\r\n        if (w + h > 2) {\r\n            e = U.toHtml(pre+'border-radius:0; background: transparent;'+post) as HTMLElement;\r\n        }\r\n        else {\r\n            e = U.toHtml(pre+'border-radius:100%; background: '+color+'; outline: 1px solid '+color+'; outline-offset: 5px;'+post) as HTMLElement;\r\n        }\r\n        document.body.append(e);\r\n        Geom.markings[key] = e;\r\n        return e;\r\n    }\r\n    // warning: nodes from other iframes will say are not instance from Element of the current frame, in that case need duck typing.\r\n    public static isHtmlNode(element: any): element is Element {\r\n        return element instanceof Element || element instanceof HTMLDocument || element instanceof SVGElement;\r\n    }\r\n\r\n\r\n    static isPositiveZero(m: number): boolean {\r\n        if (!!Object.is) { return Object.is(m, +0); }\r\n        return (1 / m === Number.POSITIVE_INFINITY); }\r\n\r\n    static isNegativeZero(m: number): boolean {\r\n        if (!!Object.is) { return Object.is(m, -0); }\r\n        return (1 / m === Number.NEGATIVE_INFINITY); }\r\n\r\n    static TanToRadian(n: number): number { return Geom.DegreeToRad(Geom.TanToDegree(n)); }\r\n    static TanToDegree(n: number): number {\r\n        if (Geom.isPositiveZero(n)) { return 0; }\r\n        if (n === Number.POSITIVE_INFINITY) { return 90; }\r\n        if (Geom.isNegativeZero(n)) { return 180; }\r\n        if (n === Number.POSITIVE_INFINITY) { return 270; }\r\n        return Geom.RadToDegree((window as any).Math.atan(n)); }\r\n\r\n    static RadToDegree(radians: number): number { return Geom.radToDeg(radians); }\r\n    static DegreeToRad(degree: number): number { return Geom.degToRad(degree); }\r\n    static radToDeg(radians: number): number { return radians * (180 / Math.PI); }\r\n    static degToRad(degree: number): number { return degree * (Math.PI / 180); }\r\n\r\n\r\n\r\n    private static GeomTolerance = 0; // 0.001;\r\n    static isOnEdge(pt: GraphPoint, shape: GraphSize, tolerance: number = Geom.GeomTolerance): boolean {\r\n        return Geom.isOnHorizontalEdges(pt, shape, tolerance) || Geom.isOnVerticalEdges(pt, shape, tolerance); }\r\n\r\n    static isOnVerticalEdges(pt: GraphPoint, shape: GraphSize, tolerance: number = Geom.GeomTolerance): boolean {\r\n        return Geom.isOnLeftEdge(pt, shape, tolerance) || Geom.isOnRightEdge(pt, shape, tolerance); }\r\n\r\n    static isOnHorizontalEdges(pt: GraphPoint, shape: GraphSize, tolerance: number = Geom.GeomTolerance): boolean {\r\n        return Geom.isOnTopEdge(pt, shape, tolerance) || Geom.isOnBottomEdge(pt, shape, tolerance); }\r\n\r\n    static isOnRightEdge(pt: GraphPoint, shape: GraphSize, tolerance: number = Geom.GeomTolerance): boolean {\r\n        if (!pt || !shape) { return false; }\r\n        if (tolerance) return Math.abs(pt.x - (shape.x + shape.w)) < tolerance\r\n            && ( pt.y - shape.y > tolerance && pt.y - (shape.y + shape.h) < tolerance);\r\n        return (pt.x === shape.x + shape.w) && (pt.y >= shape.y && pt.y <= shape.y + shape.h);\r\n    }\r\n\r\n    static isOnLeftEdge(pt: GraphPoint, shape: GraphSize, tolerance: number = Geom.GeomTolerance): boolean {\r\n        if (!pt || !shape) { return false; }\r\n        if (tolerance) return Math.abs(pt.x - shape.x) < tolerance\r\n            && (pt.y - shape.y > tolerance && pt.y - (shape.y + shape.h) < tolerance);\r\n        return (pt.x === shape.x) && (pt.y >= shape.y && pt.y <= shape.y + shape.h);\r\n    }\r\n\r\n    static isOnTopEdge(pt: GraphPoint, shape: GraphSize, tolerance: number = Geom.GeomTolerance): boolean {\r\n        if (!pt || !shape) { return false; }\r\n        if (tolerance) return Math.abs(pt.y - shape.y) < tolerance\r\n            && (pt.x - shape.x > tolerance && pt.x - (shape.x + shape.w) < tolerance);\r\n        return (pt.y === shape.y) && (pt.x >= shape.x && pt.x <= shape.x + shape.w);\r\n    }\r\n\r\n    static isOnBottomEdge(pt: GraphPoint, shape: GraphSize, tolerance?: number): boolean {\r\n        if (!pt || !shape) { return false; }\r\n        if (tolerance) return Math.abs(pt.y - shape.y + shape.h) < tolerance\r\n            && (pt.x - shape.x > tolerance && pt.x - (shape.x + shape.w) < tolerance);\r\n        return (pt.y === shape.y + shape.h) && (pt.x >= shape.x && pt.x <= shape.x + shape.w);\r\n    }\r\n\r\n    static closestPoint(size: GraphSize, pt: GraphPoint): GraphPoint {\r\n        let top_closest = Geom.closestPointToSegment(size.tl(), size.tr(), pt);\r\n        let bot_closest = Geom.closestPointToSegment(size.bl(), size.br(), pt);\r\n        let left_closest = Geom.closestPointToSegment(size.tl(), size.bl(), pt);\r\n        let right_closest = Geom.closestPointToSegment(size.tr(), size.br(), pt);\r\n\r\n        let top_distance = top_closest.distanceFromPoint(pt, false);\r\n        let bot_distance = bot_closest.distanceFromPoint(pt, false);\r\n        let left_distance = left_closest.distanceFromPoint(pt, false);\r\n        let right_distance = right_closest.distanceFromPoint(pt, false);\r\n\r\n        let min_distance = Math.min(top_distance, bot_distance, left_distance, right_distance);\r\n        if (min_distance === top_distance) return top_closest;\r\n        if (min_distance === bot_distance) return bot_closest;\r\n        if (min_distance === left_distance) return left_closest;\r\n        return right_closest;\r\n    }\r\n    static isMinusZero(number: number) {return 1/number == -Infinity;}\r\n    static closestPointToSegment(segStart: GraphPoint, segEnd:GraphPoint, pt: GraphPoint): GraphPoint{\r\n        // 1) find equation of line passing for start, end.\r\n        // 2) then find all perpendicular lines, then the perpendicular line that pass through pt\r\n        // 3) find intersection between Line(s,e) and line of point 2.\r\n        // 4A) IF intersection is part of segment(s,e) that is closest.\r\n        // 4B) ELSE, one of the 2 extremes of the segment is closest.\r\n\r\n        let x_intersect: number, y_intersect: number;\r\n        let s = segStart;\r\n        let e = segEnd;\r\n        let mse = (e.y - s.y) / (e.x - s.x);\r\n        if (mse === Number.POSITIVE_INFINITY || mse === Number.NEGATIVE_INFINITY) {\r\n            // s and e are both on the same y vertical line (same x)      // new GraphPoint(segStart.x, pt.y);\r\n            x_intersect = segStart.x;\r\n            y_intersect = pt.y;\r\n            // 1), 2), 3) all done shortcut\r\n        } else if (mse === 0 || Geom.isNegativeZero(mse)) {\r\n            // s and e are both on the same x horizontal line (same y)    // new GraphPoint(pt.x, segStart.y);\r\n            x_intersect = pt.x;\r\n            y_intersect = segStart.y\r\n            // 1), 2), 3) all done shortcut\r\n        }\r\n        else {\r\n            let q = s.y - mse*s.x; // y = mx + q           q = y-mx\r\n            // 1) done\r\n            let pmse = -1/mse; // perpendicular to mse\r\n            let pq = pt.y - pmse*pt.x;\r\n            // 2) done\r\n            //  m1 * x + q1 = y    -->   m1 * x + q1 = m2 * x + q2    -->    (m1-m2)x = q2-q1      -->     x=(q2-q1)/(m1-m2)\r\n            x_intersect = (pq-q)/(mse-pmse);\r\n            y_intersect = mse*(x_intersect) + q; //  y = mx +q\r\n            // 3) done\r\n        }\r\n\r\n        let maxX: number, minX: number;\r\n        let maxY: number, minY: number;\r\n        if (s.x > e.x) { maxX = s.x; minX = e.x; } else {  maxX = e.x; minX = s.x; }\r\n        if (s.y > e.y) { maxY = s.y; minY = e.y; } else {  maxY = e.y; minY = s.y; }\r\n        if (x_intersect >= minX && x_intersect <= maxX && y_intersect >= minY && y_intersect <= maxY) return new GraphPoint(x_intersect, y_intersect);\r\n        // 4A) IF done\r\n\r\n        let sdist = (s.x - x_intersect)**2 + (s.y - y_intersect)**2;  // actual distance is sqrt() of this, but i just need to find closest, not correct distance.\r\n        let edist = (e.x - x_intersect)**2 + (e.y - y_intersect)**2;\r\n        return (sdist < edist) ? new GraphPoint(s.x, s.y) : new GraphPoint(e.x, e.y);\r\n        // 4B) ELSE done\r\n    }\r\n\r\n    static lineToSegmentIntersection(segStart: GraphPoint, segEnd: GraphPoint, q: number, m: number): GraphPoint | undefined {\r\n        if (segStart.x === segEnd.x){\r\n            let y = m*segStart.x + q;\r\n            if (Geom.isNumberBetween(y, segStart.y, segEnd.y)) return new GraphPoint(segStart.x, y);\r\n            else return undefined;\r\n        }\r\n        else if (segStart.y === segEnd.y) {\r\n            let x = (segStart.y-q)/m;\r\n            if (Geom.isNumberBetween(x, segStart.x, segEnd.x)) return new GraphPoint(x, segStart.y);\r\n            else return undefined;\r\n            //\r\n        }\r\n\r\n        let m2 = segStart.getM(segEnd);\r\n        let q2 = IPoint.getQ(segStart, segEnd);\r\n        if (m === m2) {\r\n            if (q2 === q) return segStart; // line and segment coincident\r\n            return undefined; // parallel\r\n        }\r\n        let intersect = Geom.lineToLineIntersection(m, q, m2, q2);\r\n        if (intersect && Geom.isNumberBetween(intersect.x, segStart.x, segEnd.x) && Geom.isNumberBetween(intersect.y, segStart.y, segEnd.y)) return intersect;\r\n        else return undefined;\r\n    }\r\n\r\n    static isNumberBetween(target: number, s: number, e: number): boolean {\r\n        let max = Math.max(s, e);\r\n        let min = Math.min(s, e);\r\n        return target >= min && target <= max; }\r\n\r\n    private static lineToLineIntersection(m: number, q: number, m2: number, q2: number, retIfParallel: any = undefined, retIfCoincident: any = undefined): undefined | GraphPoint {\r\n        if (m === m2) {\r\n            if (q === q2) return retIfCoincident;\r\n            return retIfParallel;\r\n        }\r\n        if (m === Number.POSITIVE_INFINITY || m === Number.NEGATIVE_INFINITY || m2 === Number.POSITIVE_INFINITY || m2 === Number.NEGATIVE_INFINITY) {\r\n            // m or m2 are a vertical line, Q must be invalid too and i don't have a single point of the line.\r\n            // it's actually infinite possible vertical parallel lines.\r\n            return undefined;\r\n        }\r\n        /*\r\n            y = mx + q\r\n            y = nx + w\r\n            -->\r\n            mx + q = nx + w\r\n            -->\r\n            mx - nx = w - q\r\n            -->\r\n            x (m - n) = w - q\r\n            -->\r\n            x = (w - q)/(m - n)\r\n        */\r\n        let x = (q2-q)/(m-m2);\r\n        return new GraphPoint(x, m*x+q); }\r\n    // @param start, end: are for determining direction. every m is a line that can be seen in 2 direction\r\n    static mToRad(m: number, start: GraphPoint, end: GraphPoint): number {\r\n        let rad: number;\r\n        if (start.x === end.x) {\r\n            rad = (start.y < end.y) ? Math.PI * 3/2 :  Math.PI / 2;\r\n        } else {\r\n            // console.log(\"rad diagonal\", {base:  Math.atan(m), add: start.x > end.x, sx: start.x, ex: end.x});\r\n            rad = Math.atan(m) + (start.x > end.x ? 0 : Math.PI);\r\n        }\r\n        return rad; }\r\n\r\n    // intersect a rectangle with a line or segment (if end parameter is specified)\r\n    // @return: [0, 2] intersections\r\n    static lineToSizeIntersection_TODO(size: GraphSize, m: number, startLine: GraphPoint, endIfSegment?: GraphPoint): [] | [GraphPoint] | [GraphPoint, GraphPoint] {\r\n         // todo: use GraphSize.closestIntersection which is close. it is size-segment returning only the closest intersection\r\n        return [];\r\n    }\r\n}\r\n\r\nRuntimeAccessibleClass.set_extend(RuntimeAccessibleClass, Geom);\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}