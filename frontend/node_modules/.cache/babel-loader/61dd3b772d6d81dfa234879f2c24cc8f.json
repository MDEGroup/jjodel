{"ast":null,"code":"var _class;\nimport { LModelElement, DModel, LModel, DModelElement, DPointerTargetable, DViewElement, LObject, Log, LPointerTargetable, LValue, MyProxyHandler, OCL, RuntimeAccessible, RuntimeAccessibleClass, store, U } from \"../../joiner\";\nimport { LViewPoint } from \"../../view/viewPoint/viewpoint\";\nvar ViewEClassMatch;\n(function (ViewEClassMatch) {\n  ViewEClassMatch[ViewEClassMatch[\"MISMATCH\"] = 0] = \"MISMATCH\";\n  ViewEClassMatch[ViewEClassMatch[\"IMPLICIT_MATCH\"] = 1] = \"IMPLICIT_MATCH\";\n  ViewEClassMatch[ViewEClassMatch[\"INHERITANCE_MATCH\"] = 2] = \"INHERITANCE_MATCH\";\n  ViewEClassMatch[ViewEClassMatch[\"EXACT_MATCH\"] = 3] = \"EXACT_MATCH\";\n})(ViewEClassMatch || (ViewEClassMatch = {}));\nexport let Selectors = RuntimeAccessible(_class = class Selectors {\n  static getActiveModel() {\n    var _state$_lastSelected;\n    let metamodel;\n    let state = store.getState();\n    const selected = (_state$_lastSelected = state._lastSelected) === null || _state$_lastSelected === void 0 ? void 0 : _state$_lastSelected.modelElement;\n    if (selected) {\n      const me = LModelElement.fromPointer(selected);\n      metamodel = me ? me.model : null;\n    } else metamodel = null;\n    return metamodel;\n  }\n  static getLastSelectedModel(state) {\n    var _state$_lastSelected2;\n    state = state || store.getState();\n    let me = (_state$_lastSelected2 = state._lastSelected) === null || _state$_lastSelected2 === void 0 ? void 0 : _state$_lastSelected2.modelElement;\n    if (!me) return {};\n    let ret = {\n      element: LPointerTargetable.fromPointer(me, state)\n    };\n    ret.model = ret.element.model;\n    if (ret.model.isMetamodel) ret.m2 = ret.model;else {\n      ret.m1 = ret.model;\n      ret.m2 = ret.m1.instanceof;\n    }\n    return ret;\n  }\n  static getAllViewElements() {\n    // return Object.values(store.getState().idlookup).filter(v => v.className === DViewElement.name) as DViewElement[];\n    let state = store.getState();\n    const ptrs = Object.values(state.viewelements);\n    let views = ptrs.map(ptr => state.idlookup[ptr]);\n    return views;\n  }\n  //Giordano: start\n\n  static getViewpoints() {\n    const state = store.getState();\n    return LViewPoint.fromPointer(state.viewpoints);\n  }\n  static getViewpoint() {\n    const state = store.getState();\n    return LViewPoint.fromPointer(state.viewpoint);\n  }\n  static getObjects() {\n    let state = store.getState();\n    const ptrs = Object.values(state.objects);\n    const dObjects = ptrs.map(ptr => state.idlookup[ptr]);\n    const lObjects = [];\n    for (let dObject of dObjects) {\n      lObjects.push(LObject.fromPointer(dObject.id));\n    }\n    return lObjects;\n  }\n  static getValues() {\n    let state = store.getState();\n    const ptrs = Object.values(state.values);\n    const dValues = ptrs.map(ptr => state.idlookup[ptr]);\n    const lValues = [];\n    for (let dValue of dValues) {\n      if (dValue === null || dValue === void 0 ? void 0 : dValue.id) {\n        lValues.push(LValue.fromPointer(dValue.id));\n      }\n    }\n    return lValues;\n  }\n  static getDeleted() {\n    const state = store.getState();\n    return state.deleted;\n  }\n  static getState() {\n    const state = store.getState();\n    return state;\n  }\n  static removeEdge(id) {\n    const state = store.getState();\n    const edges = [];\n    for (let edge of state.edges) {\n      if (edge.id !== id) {\n        edges.push(edge);\n      }\n    }\n    return edges;\n  }\n  static getAllPrimitiveTypes() {\n    let state = store.getState();\n    const ptrs = Object.values(state.primitiveTypes);\n    const classifiers = ptrs.map(ptr => state.idlookup[ptr]);\n    return classifiers;\n  }\n  static getFirstPrimitiveTypes() {\n    return Selectors.getAllPrimitiveTypes()[0];\n  }\n  static getRefEdges() {\n    const state = store.getState();\n    const pointers = Object.values(state.refEdges);\n    const dRefEdges = pointers.map(ptr => state.idlookup[ptr]);\n    return dRefEdges;\n  }\n  static getField(field) {\n    let state = store.getState();\n    const pointers = Object.values(state[field]);\n    return pointers;\n  }\n  static getAllAttributes() {\n    const state = store.getState();\n    return Object.values(state.attributes);\n  }\n  static getAllEnumLiterals() {\n    const state = store.getState();\n    return Object.values(state.enumliterals);\n  }\n  static getAllReferences() {\n    const state = store.getState();\n    return Object.values(state.references);\n  }\n  static getAllReferenceEdges() {\n    const state = store.getState();\n    return Object.values(state.refEdges);\n  }\n  static getAllClasses() {\n    const state = store.getState();\n    return Object.values(state.classs);\n  }\n  static getReturnTypes() {\n    const state = store.getState();\n    return LPointerTargetable.from(Object.values(state.returnTypes));\n  }\n  static getAllClassesWithoutPrimitive() {\n    // this solution does not look good. what if a primitive type is inserted at runtime in between?\n    // coould reach the same goal by taking all Classes of a model (m2), excluding classes from other models (types are classes from m3 model)\n    const state = store.getState();\n    const classList = Object.values(state.classs);\n    classList.splice(0, Selectors.getAllPrimitiveTypes().length);\n    /* todo: need to change it in something like this once cross-references between models and instances are implemented\r\n    const m2: LModel;\r\n    m2.isInstanceOf = m3 as LModel;\r\n    m2.isInstanceOf.classes;*/\n\n    return classList;\n  }\n  static getAllEnumerators() {\n    let flag = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    const state = store.getState();\n    return Object.values(state.enumerators);\n  }\n  static getAllPackages() {\n    const state = store.getState();\n    return Object.values(state.packages);\n  }\n  static getAllParameters() {\n    const state = store.getState();\n    return Object.values(state.parameters);\n  }\n  static getAllOperations() {\n    const state = store.getState();\n    return Object.values(state.operations);\n  }\n  static getDElement(pointer) {\n    const state = store.getState();\n    const dElement = state.idlookup[pointer];\n    return dElement;\n  }\n  static getAllMetamodels() {\n    const state = store.getState();\n    const dModels = Object.values(state.m2models);\n    return LModel.fromPointer(dModels);\n  }\n  static getAllModels() {\n    const state = store.getState();\n    const dModels = Object.values(state.m1models);\n    return LModel.fromPointer(dModels);\n  }\n\n  //Giordano: end\n\n  static getVertex(wrap, resolvePointers) {\n    const state = store.getState();\n    let ptrs = [];\n    U.ArrayMerge0(false, ptrs,\n    // Object.values(state.graphs || {}),\n    Object.values(state.voidvertexs || {}), Object.values(state.vertexs || {}), Object.values(state.graphvertexs || {}), Object.values(state.edgepoints || {}));\n    console.log('selector getvertex: ', {\n      ptrs,\n      g: Object.values(state.graphs || {}),\n      vv: Object.values(state.voidvertexs || {}),\n      v: Object.values(state.vertexs || {}),\n      gv: Object.values(state.graphvertexs || {}),\n      ep: Object.values(state.edgepoints || {})\n    });\n    if (wrap === undefined || wrap === true) return ptrs.map(p => DPointerTargetable.wrap(p));\n    if (resolvePointers === undefined || resolvePointers === true) return ptrs.map(r => state.idlookup[r]);\n    return ptrs;\n  }\n  static getAll(Classe, condition, state, resolvePointers, wrap) {\n    if (!state) state = store.getState();\n    let GClass = Classe || {\n      name: \"idlookup\"\n    };\n    const className = ((GClass === null || GClass === void 0 ? void 0 : GClass.staticClassName) || GClass.name).toLowerCase();\n    const allIdByClassName = state[className] || state[className.substr(1)] || state[className + 's'] || state[className.substr(1) + 's'];\n    Log.exDev(!allIdByClassName, 'cannot find store key:', {\n      state,\n      className,\n      Classe\n    });\n    let allDByClassName = null;\n    let allLByClassName = null;\n    if (resolvePointers || wrap) {\n      allDByClassName = allIdByClassName.map(e => state.idlookup[e]);\n      if (wrap) {\n        allLByClassName = allDByClassName.map(e => DPointerTargetable.wrap(e));\n      }\n    }\n    let ret = resolvePointers || wrap ? wrap ? allLByClassName : allDByClassName : allIdByClassName;\n    if (!Array.isArray(ret)) ret = Object.values(ret).filter(e => e instanceof Object);\n    if (condition) return ret.filter(e => condition(e));\n    return ret;\n  }\n  /*\r\n      static getModels(condition?: (m: DModel) => boolean): DModel[] {\r\n          /*\r\n          const className: Pointer<DPointerTargetable, 1, 1> = DViewElement.name.substr(1).toLowerCase() + 's';\r\n          const allByClassName: DPointerTargetable[] = state[className as string];\r\n          let models: DModel[] = state[className as string].map((mid) => state.idlookup[mid as string]) as DModel[];\r\n          if (condition) models = models.filter(condition);\r\n          return models; * /\r\n          return Selectors.getAll(DModel, undefined, undefined, resolvePointers, wrap); }*/\n\n  static getModel(name) {\n    let caseSensitive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    let wrap = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    if (!caseSensitive) name = name.toLowerCase();\n    let ret = Selectors.getAll(DModel, d => (caseSensitive ? d.name : d.name.toLowerCase()) === name, undefined, true, wrap)[0];\n    return ret;\n  }\n  static getByName(classe, name) {\n    let caseSensitive = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    let wrap = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    return Selectors.getByField(classe, 'name', name, caseSensitive, wrap);\n  }\n  static getByField(classe, field, value) {\n    let caseSensitive = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    let wrap = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n    if (!caseSensitive) value = value.toLowerCase();\n    let condition = d => {\n      var _d$field;\n      let ret = (caseSensitive ? d[field] : (_d$field = d[field]) === null || _d$field === void 0 ? void 0 : _d$field.toLowerCase()) === value;\n      console.log('filtering getall by field:', {\n        d,\n        dfield: d[field],\n        value,\n        ret\n      });\n      return ret;\n    };\n    let ret = Selectors.getAll(classe, condition, undefined, true, wrap)[0];\n    return ret;\n  }\n  static getViews(condition) {\n    return Selectors.getAll(DViewElement);\n  }\n  static queryJS(model, query) {\n    try {\n      return eval(query);\n    } catch (e) {\n      return [];\n    }\n  }\n  /*static getCurrentView(data: LModelElement): DViewElement {\r\n      Log.exDevv('todo');\r\n      return undefined as any;\r\n  }*/\n\n  // 2 = explicit exact match (===), 1 = matches a subclass, 0 = implicit match (any *), -1 = not matches\n  static matchesOclCondition(v, data) {\n    if (!v.query) return ViewEClassMatch.IMPLICIT_MATCH;\n    const query = v.query;\n    const viewpoint = Selectors.getViewpoint();\n    if (v.viewpoint !== viewpoint.id) {\n      return ViewEClassMatch.IMPLICIT_MATCH;\n    }\n    let constructors = RuntimeAccessibleClass.getAllClasses();\n    try {\n      const flag = OCL.filter(false, \"src\", [data], query, constructors);\n      console.clear();\n      console.log(flag);\n      if (flag.length > 0) return ViewEClassMatch.EXACT_MATCH + v.explicitApplicationPriority;else return ViewEClassMatch.MISMATCH;\n    } catch (e) {\n      console.error('invalid ocl query');\n    }\n    return ViewEClassMatch.MISMATCH;\n  }\n  static matchesMetaClassTarget(v, data) {\n    if (!v.appliableToClasses || !v.appliableToClasses.length) return ViewEClassMatch.IMPLICIT_MATCH;\n    if (!data) return ViewEClassMatch.MISMATCH;\n    let ThisClass = RuntimeAccessibleClass.get(data === null || data === void 0 ? void 0 : data.className);\n    Log.exDev(!ThisClass, 'unable to find class type:', {\n      v,\n      data\n    }); // todo: v = view appliable to DModel, data = proxy<LModel>\n    let gotSubclassMatch = false;\n    for (let classtarget of v.appliableToClasses) {\n      const ClassTarget = RuntimeAccessibleClass.get(classtarget);\n      if (ThisClass === ClassTarget) return ViewEClassMatch.EXACT_MATCH; // explicit exact match\n      if (!gotSubclassMatch && U.classIsExtending(ThisClass, ClassTarget)) gotSubclassMatch = true; // explicit subclass match\n      if (gotSubclassMatch) return ViewEClassMatch.INHERITANCE_MATCH;\n    }\n    return ViewEClassMatch.MISMATCH;\n  }\n  static isOfSubclass(data, classTarget) {\n    let acceptEquality = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    let ThisClass = RuntimeAccessibleClass.get(data.className);\n    Log.exDev(!ThisClass, 'isOfSubclass() unable to find class type:', {\n      data\n    });\n    const ClassTarget = typeof classTarget === \"string\" ? RuntimeAccessibleClass.get(classTarget) : classTarget;\n    if (ThisClass === ClassTarget) return acceptEquality;\n    return U.classIsExtending(ThisClass, ClassTarget);\n  }\n  static scoreView(v1, data, hisnode, graph) {\n    let sameViewPointViews = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [];\n    // 1° priority: matching by EClass type\n    let v1MatchingEClassScore = this.matchesMetaClassTarget(v1, data === null || data === void 0 ? void 0 : data.__raw);\n    // Log.l('score view:', {v1, data, v1MatchingEClassScore});\n    if (v1MatchingEClassScore === ViewEClassMatch.MISMATCH) return ViewEClassMatch.MISMATCH;\n    // 2° priority: by ocl condition matching\n    let v1OclScore = Selectors.matchesOclCondition(v1, data);\n    if (v1OclScore === ViewEClassMatch.MISMATCH) return ViewEClassMatch.MISMATCH;\n    // 3° priority by sub-view\n    let v1SubViewScore = Selectors.matchesOclCondition(v1, data);\n    if (v1SubViewScore === ViewEClassMatch.MISMATCH) return ViewEClassMatch.MISMATCH;\n    // second priority: matching by viewpoint / subViews\n    return v1MatchingEClassScore * v1OclScore * v1SubViewScore * v1.explicitApplicationPriority;\n  }\n  static getAppliedViews(data, hisnode, graph, selectedViewId, parentViewId) {\n    const state = store.getState();\n    const allViews = [...Selectors.getAllViewElements()];\n    const selectedView = null; // selectedViewId ? state.idlookup[selectedViewId] as DViewElement : null;\n    const parentView = parentViewId ? state.idlookup[parentViewId] : null;\n    const sameViewPointSubViews = parentView ? parentView.subViews : []; // a viewpoint is a simple view that is targeting a model\n    if (selectedView) U.arrayRemoveAll(allViews, selectedView);\n    let sortedPriority = allViews.map(\n    // v => new Scored<DViewElement>(Selectors.scoreView(v, data as any as DModelElement, hisnode, graph, sameViewPointSubViews), v)) as Scored<DViewElement>[];\n    v => {\n      return new Scored(Selectors.scoreView(v, data, hisnode, graph, sameViewPointSubViews), v);\n    });\n    sortedPriority.sort((e1, e2) => e2.score - e1.score);\n    // todo: prioritize views \"childrens\" of the view of the graph, so they will display differnet views for the same element in different graphs\n    // then sort by  view selector matching: on classtype (eattribute, eoperation, eclass...), on values, upperbound...\n    if (selectedView) sortedPriority = [new Scored('manually assigned', selectedView), ...sortedPriority];\n    // sortedPriority = sortedPriority.map( s=> s.element) as any] : sortedPriority.map( s=> s.element) as any;\n\n    // Log.exDevv('viewscores', {data, sp:sortedPriority});\n    return sortedPriority;\n  }\n  static getAllMP(state) {\n    if (!state) state = store.getState();\n    let allD = Object.values(state.idlookup);\n    return allD.filter(d => U.isObject(d) && Selectors.isOfSubclass(d, DModelElement));\n  }\n  static toObject(ptrs, state) {\n    if (!state) state = store.getState();\n    return ptrs.map(p => state.idlookup[p]);\n  }\n  static wrap(arr, state) {\n    if (!arr.length) return [];\n    if (!state) state = store.getState();\n    let objarr;\n    if (typeof arr[0] === \"string\") {\n      objarr = Selectors.toObject(arr, state);\n    } else objarr = arr;\n    return objarr.map(p => RuntimeAccessibleClass.wrap(p));\n  }\n  static unwrap(arr) {\n    return arr.map(a => a.__raw);\n  }\n  static getSubNodeElements(forGraph) {\n    let asPointers = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    let wrap = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    const state = store.getState();\n    const g = state.idlookup[forGraph];\n    if (asPointers) return g.subElements;\n    const subelements = g.subElements.map(geid => state.idlookup[geid]);\n    if (wrap) return subelements.map(ge => MyProxyHandler.wrap(ge));\n    return subelements;\n  }\n\n  //// giordano part\n\n  static getAllPackageClasses(id) {\n    const data = MyProxyHandler.wrap(id);\n    let lPackage;\n    const classes = [];\n    if (data.className === \"DReference\") {\n      const lClass = MyProxyHandler.wrap(data.father);\n      lPackage = MyProxyHandler.wrap(lClass.father);\n    }\n    if (data.className === \"DParameter\") {\n      const lOperation = MyProxyHandler.wrap(data.father);\n      const lClass = MyProxyHandler.wrap(lOperation.father);\n      lPackage = MyProxyHandler.wrap(lClass.father);\n    }\n    if (data.className === \"DOperation\") {\n      const lClass = MyProxyHandler.wrap(data.father);\n      lPackage = MyProxyHandler.wrap(lClass.father);\n    }\n    if (lPackage) {\n      for (let classifier of lPackage.classifiers) {\n        const lClassifier = MyProxyHandler.wrap(classifier);\n        if (lClassifier.className === \"DClass\") classes.push(lClassifier);\n      }\n    }\n    return classes;\n  }\n  static getAllPackageEnumerators(id) {\n    const data = MyProxyHandler.wrap(id);\n    let lPackage;\n    const enumerators = [];\n    if (data.className === \"DAttribute\") {\n      const lClass = MyProxyHandler.wrap(data.father);\n      lPackage = MyProxyHandler.wrap(lClass.father);\n    }\n    if (data.className === \"DParameter\") {\n      const lOperation = MyProxyHandler.wrap(data.father);\n      const lClass = MyProxyHandler.wrap(lOperation.father);\n      lPackage = MyProxyHandler.wrap(lClass.father);\n    }\n    if (data.className === \"DOperation\") {\n      const lClass = MyProxyHandler.wrap(data.father);\n      lPackage = MyProxyHandler.wrap(lClass.father);\n    }\n    if (lPackage) {\n      for (let classifier of lPackage.classifiers) {\n        const lClassifier = MyProxyHandler.wrap(classifier);\n        if (lClassifier.className === \"DEnumerator\") enumerators.push(lClassifier);\n      }\n    }\n    return enumerators;\n  }\n}) || _class;\nclass Scored {\n  constructor(score, element) {\n    this.score = score;\n    this.element = element;\n  }\n}","map":{"version":3,"names":["LModelElement","DModel","LModel","DModelElement","DPointerTargetable","DViewElement","LObject","Log","LPointerTargetable","LValue","MyProxyHandler","OCL","RuntimeAccessible","RuntimeAccessibleClass","store","U","LViewPoint","ViewEClassMatch","Selectors","_class","getActiveModel","_state$_lastSelected","metamodel","state","getState","selected","_lastSelected","modelElement","me","fromPointer","model","getLastSelectedModel","_state$_lastSelected2","ret","element","isMetamodel","m2","m1","instanceof","getAllViewElements","ptrs","Object","values","viewelements","views","map","ptr","idlookup","getViewpoints","viewpoints","getViewpoint","viewpoint","getObjects","objects","dObjects","lObjects","dObject","push","id","getValues","dValues","lValues","dValue","getDeleted","deleted","removeEdge","edges","edge","getAllPrimitiveTypes","primitiveTypes","classifiers","getFirstPrimitiveTypes","getRefEdges","pointers","refEdges","dRefEdges","getField","field","getAllAttributes","attributes","getAllEnumLiterals","enumliterals","getAllReferences","references","getAllReferenceEdges","getAllClasses","classs","getReturnTypes","from","returnTypes","getAllClassesWithoutPrimitive","classList","splice","length","getAllEnumerators","flag","arguments","undefined","enumerators","getAllPackages","packages","getAllParameters","parameters","getAllOperations","operations","getDElement","pointer","dElement","getAllMetamodels","dModels","m2models","getAllModels","m1models","getVertex","wrap","resolvePointers","ArrayMerge0","voidvertexs","vertexs","graphvertexs","edgepoints","console","log","g","graphs","vv","v","gv","ep","p","r","getAll","Classe","condition","GClass","name","className","staticClassName","toLowerCase","allIdByClassName","substr","exDev","allDByClassName","allLByClassName","e","Array","isArray","filter","getModel","caseSensitive","d","getByName","classe","getByField","value","_d$field","dfield","getViews","queryJS","query","eval","matchesOclCondition","data","IMPLICIT_MATCH","constructors","clear","EXACT_MATCH","explicitApplicationPriority","MISMATCH","error","matchesMetaClassTarget","appliableToClasses","ThisClass","get","gotSubclassMatch","classtarget","ClassTarget","classIsExtending","INHERITANCE_MATCH","isOfSubclass","classTarget","acceptEquality","scoreView","v1","hisnode","graph","sameViewPointViews","v1MatchingEClassScore","__raw","v1OclScore","v1SubViewScore","getAppliedViews","selectedViewId","parentViewId","allViews","selectedView","parentView","sameViewPointSubViews","subViews","arrayRemoveAll","sortedPriority","Scored","sort","e1","e2","score","getAllMP","allD","isObject","toObject","arr","objarr","unwrap","a","getSubNodeElements","forGraph","asPointers","subElements","subelements","geid","ge","getAllPackageClasses","lPackage","classes","lClass","father","lOperation","classifier","lClassifier","getAllPackageEnumerators","constructor"],"sources":["C:/0Programmi/Dev/projects/frontend/jjodel/src/redux/selectors/selectors.ts"],"sourcesContent":["import type {\r\n    DAttribute,\r\n    DClass,\r\n    DGraph,\r\n    DClassifier,\r\n    DEnumerator,\r\n    DGraphElement,\r\n    DRefEdge,\r\n    DVoidVertex,\r\n    GObject,\r\n    IStore,\r\n    LClass,\r\n    LEnumerator,\r\n    LGraphElement,\r\n    LOperation,\r\n    LPackage,\r\n    LRefEdge,\r\n    LViewElement,\r\n    LVoidVertex,\r\n    Pointer,\r\n} from \"../../joiner\";\r\nimport {\r\n    AbstractConstructor,\r\n    Constructor,\r\n    LModelElement,\r\n    DModel, LModel,\r\n    DModelElement, DNamedElement, DObject,\r\n    DPointerTargetable, DValue,\r\n    DViewElement, LNamedElement, LObject,\r\n    Log,\r\n    LPointerTargetable, LValue,\r\n    MyProxyHandler, OCL,\r\n    RuntimeAccessible,\r\n    RuntimeAccessibleClass,\r\n    store,\r\n    U, windoww, Pointers,\r\n} from \"../../joiner\";\r\nimport {EdgeOptions} from \"../store\";\r\nimport {DViewPoint, LViewPoint} from \"../../view/viewPoint/viewpoint\";\r\n\r\nenum ViewEClassMatch { // this acts as a multiplier for explicit priority\r\n    MISMATCH = 0,\r\n    IMPLICIT_MATCH = 1,\r\n    INHERITANCE_MATCH = 2,\r\n    EXACT_MATCH = 3,\r\n}\r\n\r\n@RuntimeAccessible\r\nexport class Selectors{\r\n\r\n    static getActiveModel(): null|LModel {\r\n        let metamodel: null|LModel;\r\n        let state: IStore & GObject = store.getState();\r\n        const selected = state._lastSelected?.modelElement;\r\n        if(selected) {\r\n            const me = LModelElement.fromPointer(selected)\r\n            metamodel = (me) ? me.model : null;\r\n        } else metamodel = null;\r\n        return metamodel;\r\n    }\r\n\r\n    public static getLastSelectedModel<RET extends {m1?:LModel, m2?:LModel, model?:LModel, element?:LModelElement}>(state? :IStore): RET {\r\n        state = state || store.getState();\r\n        let me = state._lastSelected?.modelElement;\r\n        if (!me) return {} as RET;\r\n        let ret: RET = {element: LPointerTargetable.fromPointer(me, state)} as RET;\r\n        ret.model = ret.element!.model\r\n        if (ret.model.isMetamodel) ret.m2 = ret.model;\r\n        else {\r\n            ret.m1 = ret.model;\r\n            ret.m2 = ret.m1.instanceof;\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    static getAllViewElements(): DViewElement[] {\r\n        // return Object.values(store.getState().idlookup).filter(v => v.className === DViewElement.name) as DViewElement[];\r\n        let state: IStore & GObject = store.getState();\r\n        const ptrs: Pointer<DViewElement, 0, 'N'> = Object.values((state).viewelements);\r\n        let views: DViewElement[] = ptrs.map<DViewElement>( (ptr) => state.idlookup[ptr] as DViewElement);\r\n        return views;\r\n    }\r\n    //Giordano: start\r\n\r\n    public static getViewpoints() : LViewPoint[] {\r\n        const state: IStore & GObject = store.getState();\r\n        return LViewPoint.fromPointer(state.viewpoints);\r\n    }\r\n    public static getViewpoint() : LViewPoint  {\r\n        const state: IStore & GObject = store.getState();\r\n        return LViewPoint.fromPointer(state.viewpoint);\r\n    }\r\n\r\n    public static getObjects(): LObject[] {\r\n        let state: IStore & GObject = store.getState();\r\n        const ptrs: Pointer<DObject, 0, 'N'> = Object.values((state).objects);\r\n        const dObjects: DObject[] = ptrs.map<DObject>( (ptr) => state.idlookup[ptr] as DObject);\r\n        const lObjects: LObject[] = [];\r\n        for(let dObject of dObjects) {\r\n            lObjects.push(LObject.fromPointer(dObject.id));\r\n        }\r\n        return lObjects;\r\n    }\r\n    public static getValues(): LValue[] {\r\n        let state: IStore & GObject = store.getState();\r\n        const ptrs: Pointer<DValue, 0, 'N'> = Object.values((state).values);\r\n        const dValues: DValue[] = ptrs.map<DValue>( (ptr) => state.idlookup[ptr] as DValue);\r\n        const lValues: LValue[] = [];\r\n        for(let dValue of dValues) {\r\n            if(dValue?.id) {\r\n                lValues.push(LValue.fromPointer(dValue.id));\r\n            }\r\n        }\r\n        return lValues;\r\n    }\r\n\r\n    public static getDeleted(): string [] {\r\n        const state: IStore & GObject = store.getState();\r\n        return state.deleted;\r\n    }\r\n\r\n    public static getState(): any {\r\n        const state: IStore & GObject = store.getState();\r\n        return state;\r\n    }\r\n\r\n    static removeEdge(id: number): EdgeOptions[] {\r\n        const state: IStore & GObject = store.getState();\r\n        const edges: EdgeOptions[] = [];\r\n        for(let edge of state.edges) {\r\n            if(edge.id !== id) {\r\n                edges.push(edge);\r\n            }\r\n        }\r\n        return edges;\r\n    }\r\n\r\n    static getAllPrimitiveTypes(): DClassifier[] {\r\n        let state: IStore & GObject = store.getState();\r\n        const ptrs: Pointer<DClassifier, 0, 'N'> = Object.values((state).primitiveTypes);\r\n        const classifiers: DClassifier[] = ptrs.map<DClassifier>( (ptr) => state.idlookup[ptr] as DClassifier);\r\n        return classifiers;\r\n    }\r\n    static getFirstPrimitiveTypes(): DClassifier {\r\n        return Selectors.getAllPrimitiveTypes()[0];\r\n    }\r\n    static getRefEdges(): DRefEdge[] {\r\n        const state: IStore & GObject = store.getState();\r\n        const pointers: Pointer<DRefEdge, 0, 'N', LRefEdge> = Object.values((state).refEdges);\r\n        const dRefEdges: DRefEdge[] = pointers.map<DRefEdge>( (ptr) => state.idlookup[ptr] as DRefEdge);\r\n        return dRefEdges;\r\n    }\r\n    static getField(field: string): string[] {\r\n        let state: IStore & GObject = store.getState();\r\n        const pointers: Pointer<DModelElement, 0, 'N'> = Object.values((state)[field]);\r\n        return pointers;\r\n    }\r\n\r\n    static getAllAttributes(): string[] {\r\n        const state: IStore = store.getState();\r\n        return Object.values((state).attributes);\r\n    }\r\n    static getAllEnumLiterals(): string[] {\r\n        const state: IStore = store.getState();\r\n        return Object.values((state).enumliterals);\r\n    }\r\n    static getAllReferences(): string[] {\r\n        const state: IStore = store.getState();\r\n        return Object.values((state).references);\r\n    }\r\n    static getAllReferenceEdges(): string[] {\r\n        const state: IStore = store.getState();\r\n        return Object.values((state).refEdges);\r\n    }\r\n    static getAllClasses(): string[] {\r\n        const state: IStore = store.getState();\r\n        return Object.values((state).classs);\r\n    }\r\n    static getReturnTypes(): LClass[] {\r\n        const state: IStore = store.getState();\r\n        return LPointerTargetable.from(Object.values((state).returnTypes));\r\n    }\r\n\r\n    static getAllClassesWithoutPrimitive(): string[] {\r\n        // this solution does not look good. what if a primitive type is inserted at runtime in between?\r\n        // coould reach the same goal by taking all Classes of a model (m2), excluding classes from other models (types are classes from m3 model)\r\n        const state: IStore = store.getState();\r\n        const classList: string[] = Object.values((state).classs);\r\n        classList.splice(0, Selectors.getAllPrimitiveTypes().length);\r\n        /* todo: need to change it in something like this once cross-references between models and instances are implemented\r\n        const m2: LModel;\r\n        m2.isInstanceOf = m3 as LModel;\r\n        m2.isInstanceOf.classes;*/\r\n\r\n        return classList;\r\n    }\r\n\r\n    static getAllEnumerators(flag = false): string[] {\r\n        const state: IStore = store.getState();\r\n        return Object.values((state).enumerators);\r\n    }\r\n    static getAllPackages(): string[] {\r\n        const state: IStore = store.getState();\r\n        return Object.values((state).packages);\r\n    }\r\n\r\n    static getAllParameters(): string[] {\r\n        const state: IStore = store.getState();\r\n        return Object.values((state).parameters);\r\n    }\r\n    static getAllOperations(): string[] {\r\n        const state: IStore = store.getState();\r\n        return Object.values((state).operations);\r\n    }\r\n\r\n    static getDElement<T extends DModelElement>(pointer: string): T {\r\n        const state: IStore & GObject = store.getState();\r\n        const dElement: T = state.idlookup[pointer] as T;\r\n        return dElement;\r\n    }\r\n\r\n    static getAllMetamodels(): LModel[] {\r\n        const state: IStore = store.getState();\r\n        const dModels = Object.values((state).m2models);\r\n        return LModel.fromPointer(dModels);\r\n    }\r\n\r\n    static getAllModels(): LModel[] {\r\n        const state: IStore = store.getState();\r\n        const dModels = Object.values((state).m1models);\r\n        return LModel.fromPointer(dModels);\r\n    }\r\n\r\n    //Giordano: end\r\n\r\n    static getVertex<W extends boolean = true, RP extends boolean = true>(wrap?: W /* = true */, resolvePointers?: RP /**/):\r\n        W extends false ? (RP extends false ? Pointer<DVoidVertex, 1, 1, LVoidVertex>[] : DVoidVertex[]) : LVoidVertex[] {\r\n        const state: IStore = store.getState();\r\n        let ptrs: Pointer<DVoidVertex>[] = [];\r\n\r\n        U.ArrayMerge0(false, ptrs,\r\n            // Object.values(state.graphs || {}),\r\n            Object.values(state.voidvertexs || {}),\r\n            Object.values(state.vertexs || {}),\r\n            Object.values(state.graphvertexs || {}),\r\n            Object.values(state.edgepoints || {}));\r\n\r\n        console.log('selector getvertex: ', {ptrs, g: Object.values(state.graphs || {}), vv:Object.values(state.voidvertexs || {}), v:Object.values(state.vertexs || {}), gv:Object.values(state.graphvertexs || {}), ep:Object.values(state.edgepoints || {})});\r\n        if (wrap === undefined || wrap === true) return ptrs.map( p => DPointerTargetable.wrap(p)) as any[];\r\n        if (resolvePointers === undefined || resolvePointers === true) return ptrs.map( r => state.idlookup[r]) as any[];\r\n        return ptrs as any[];\r\n    }\r\n\r\n    static getAll<D extends DPointerTargetable, L extends LPointerTargetable, DT extends typeof DPointerTargetable = typeof DPointerTargetable,\r\n        W extends undefined | true | false = false, RP extends undefined | true | false = true, RET = W extends false ? (RP extends false ? Pointer<D, 1, 1, L> : D) : L>\r\n        (Classe?: DT, condition?: (e:RET) => boolean, state?: IStore, resolvePointers?: RP /**/, wrap?: W /* = true */): RET[] {\r\n        if (!state) state = store.getState();\r\n        let GClass = (Classe as GObject) || {name:\"idlookup\"};\r\n        const className: string = (GClass?.staticClassName || GClass.name).toLowerCase();\r\n        const allIdByClassName: Pointer<D, 1, 1, L>[]\r\n            = (state as GObject)[className]\r\n            || (state as GObject)[className.substr(1)]\r\n            || (state as GObject)[className + 's']\r\n            || (state as GObject)[className.substr(1) + 's'];\r\n        Log.exDev(!allIdByClassName, 'cannot find store key:', {state, className, Classe});\r\n        let allDByClassName: D[] | null = null;\r\n        let allLByClassName: L[] | null = null;\r\n        if (resolvePointers || wrap) {\r\n            allDByClassName = allIdByClassName.map( (e) => (state as IStore).idlookup[e] ) as D[];\r\n            if (wrap) {\r\n                allLByClassName = allDByClassName.map( e => DPointerTargetable.wrap(e)) as any as L[];\r\n            }\r\n        }\r\n        let ret: RET[] = (resolvePointers || wrap ? (wrap ? allLByClassName : allDByClassName) : allIdByClassName) as any[] as RET[];\r\n        if (!Array.isArray(ret)) ret = Object.values(ret).filter(e => e instanceof Object) as RET[];\r\n        if (condition) return ret.filter( e => condition(e));\r\n        return ret;\r\n    }\r\n/*\r\n    static getModels(condition?: (m: DModel) => boolean): DModel[] {\r\n        /*\r\n        const className: Pointer<DPointerTargetable, 1, 1> = DViewElement.name.substr(1).toLowerCase() + 's';\r\n        const allByClassName: DPointerTargetable[] = state[className as string];\r\n        let models: DModel[] = state[className as string].map((mid) => state.idlookup[mid as string]) as DModel[];\r\n        if (condition) models = models.filter(condition);\r\n        return models; * /\r\n        return Selectors.getAll(DModel, undefined, undefined, resolvePointers, wrap); }*/\r\n\r\n    static getModel(name: string, caseSensitive: boolean = false, wrap: boolean = false): DModel | LModel | null {\r\n        if (!caseSensitive) name = name.toLowerCase();\r\n        let ret = Selectors.getAll<DModel, LModel>(DModel, (d) => (caseSensitive ? d.name : d.name.toLowerCase()) === name, undefined, true, wrap as any)[0];\r\n        return ret;\r\n    }\r\n\r\n    static getByName(classe: typeof DPointerTargetable, name: string, caseSensitive: boolean = false, wrap: boolean = false): DPointerTargetable | LPointerTargetable | null {\r\n        return Selectors.getByField(classe, 'name', name, caseSensitive, wrap); }\r\n\r\n    static getByField(classe: typeof DPointerTargetable, field: string, value: string, caseSensitive: boolean = false, wrap: boolean = false): DPointerTargetable | LPointerTargetable | null {\r\n        if (!caseSensitive) value = value.toLowerCase();\r\n        let condition = (d: any) => {\r\n            let ret = (caseSensitive ? d[field] : d[field]?.toLowerCase()) === value;\r\n            console.log('filtering getall by field:', {d, dfield:d[field], value, ret});\r\n            return ret;\r\n        }\r\n        let ret = Selectors.getAll(classe, condition, undefined, true, wrap as any)[0];\r\n        return ret; }\r\n\r\n    static getViews(condition?: (m: DModel) => boolean): DViewElement[] { return Selectors.getAll(DViewElement); }\r\n\r\n\r\n\r\n    private static queryJS(model: LModel, query: string): LPointerTargetable[] {\r\n        try {\r\n            return eval(query);\r\n        } catch (e) { return []; }\r\n    }\r\n    /*static getCurrentView(data: LModelElement): DViewElement {\r\n        Log.exDevv('todo');\r\n        return undefined as any;\r\n    }*/\r\n\r\n\r\n    // 2 = explicit exact match (===), 1 = matches a subclass, 0 = implicit match (any *), -1 = not matches\r\n    private static matchesOclCondition(v: DViewElement, data: DModelElement | LModelElement): ViewEClassMatch.MISMATCH | ViewEClassMatch.IMPLICIT_MATCH | ViewEClassMatch.EXACT_MATCH {\r\n        if (!v.query) return ViewEClassMatch.IMPLICIT_MATCH;\r\n        const query = v.query;\r\n        const viewpoint = Selectors.getViewpoint();\r\n        if(v.viewpoint !== viewpoint.id) { return ViewEClassMatch.IMPLICIT_MATCH; }\r\n        let constructors: Constructor[] = RuntimeAccessibleClass.getAllClasses() as (Constructor|AbstractConstructor)[] as Constructor[];\r\n        try {\r\n            const flag = OCL.filter(false, \"src\", [data], query, constructors);\r\n            console.clear(); console.log(flag)\r\n            if(flag.length > 0) return ViewEClassMatch.EXACT_MATCH + v.explicitApplicationPriority;\r\n            else return ViewEClassMatch.MISMATCH;\r\n        } catch (e) { console.error('invalid ocl query'); }\r\n        return ViewEClassMatch.MISMATCH;\r\n    }\r\n\r\n\r\n    private static matchesMetaClassTarget(v: DViewElement, data: DModelElement): ViewEClassMatch {\r\n        if (!v.appliableToClasses || !v.appliableToClasses.length) return ViewEClassMatch.IMPLICIT_MATCH;\r\n        if (!data) return ViewEClassMatch.MISMATCH;\r\n        let ThisClass: typeof DPointerTargetable = RuntimeAccessibleClass.get(data?.className);\r\n        Log.exDev(!ThisClass, 'unable to find class type:', {v, data}); // todo: v = view appliable to DModel, data = proxy<LModel>\r\n        let gotSubclassMatch: boolean = false;\r\n        for (let classtarget of v.appliableToClasses) {\r\n            const ClassTarget: typeof DPointerTargetable = RuntimeAccessibleClass.get(classtarget);\r\n            if (ThisClass === ClassTarget) return ViewEClassMatch.EXACT_MATCH; // explicit exact match\r\n            if (!gotSubclassMatch && U.classIsExtending(ThisClass, ClassTarget)) gotSubclassMatch = true; // explicit subclass match\r\n            if (gotSubclassMatch) return ViewEClassMatch.INHERITANCE_MATCH;\r\n        }\r\n        return ViewEClassMatch.MISMATCH;\r\n }\r\n\r\n    private static isOfSubclass(data: DPointerTargetable, classTarget: string | typeof DPointerTargetable, acceptEquality: boolean = false): boolean {\r\n        let ThisClass: typeof DPointerTargetable = RuntimeAccessibleClass.get(data.className);\r\n        Log.exDev(!ThisClass, 'isOfSubclass() unable to find class type:', {data});\r\n        const ClassTarget: typeof DPointerTargetable = typeof classTarget === \"string\"? RuntimeAccessibleClass.get(classTarget) : classTarget;\r\n        if (ThisClass === ClassTarget) return acceptEquality;\r\n        return U.classIsExtending(ThisClass, ClassTarget);\r\n    }\r\n\r\n\r\n\r\n    private static scoreView(v1: DViewElement, data: LModelElement, hisnode: DGraphElement | undefined, graph: LGraphElement, sameViewPointViews: Pointer<DViewElement, 1, 1>[] = []): number {\r\n        // 1° priority: matching by EClass type\r\n        let v1MatchingEClassScore: ViewEClassMatch = this.matchesMetaClassTarget(v1, data?.__raw);\r\n        // Log.l('score view:', {v1, data, v1MatchingEClassScore});\r\n        if (v1MatchingEClassScore === ViewEClassMatch.MISMATCH) return ViewEClassMatch.MISMATCH;\r\n        // 2° priority: by ocl condition matching\r\n        let v1OclScore = Selectors.matchesOclCondition(v1, data);\r\n        if (v1OclScore === ViewEClassMatch.MISMATCH) return ViewEClassMatch.MISMATCH;\r\n        // 3° priority by sub-view\r\n        let v1SubViewScore = Selectors.matchesOclCondition(v1, data);\r\n        if (v1SubViewScore === ViewEClassMatch.MISMATCH) return ViewEClassMatch.MISMATCH;\r\n        // second priority: matching by viewpoint / subViews\r\n        return (v1MatchingEClassScore * v1OclScore * v1SubViewScore) * v1.explicitApplicationPriority; }\r\n\r\n\r\n    static getAppliedViews(data: LModelElement, hisnode: DGraphElement | undefined, graph: LGraphElement,\r\n                           selectedViewId: Pointer<DViewElement, 0, 1, LViewElement>, parentViewId: Pointer<DViewElement, 0, 1, LViewElement>): Scored<DViewElement>[] {\r\n        const state : IStore = store.getState();\r\n        const allViews: DViewElement[] = [...Selectors.getAllViewElements()];\r\n        const selectedView: DViewElement | null = null; // selectedViewId ? state.idlookup[selectedViewId] as DViewElement : null;\r\n        const parentView: DViewElement | null = parentViewId ? state.idlookup[parentViewId] as DViewElement : null;\r\n        const sameViewPointSubViews: Pointer<DViewElement, 1, 1>[] = parentView ? parentView.subViews : []; // a viewpoint is a simple view that is targeting a model\r\n        if (selectedView) U.arrayRemoveAll(allViews, selectedView);\r\n        let sortedPriority: Scored<DViewElement>[] = allViews.map(\r\n            // v => new Scored<DViewElement>(Selectors.scoreView(v, data as any as DModelElement, hisnode, graph, sameViewPointSubViews), v)) as Scored<DViewElement>[];\r\n            (v) => {\r\n                return new Scored<DViewElement>(Selectors.scoreView(v, data, hisnode, graph, sameViewPointSubViews), v);}\r\n        ) as Scored<DViewElement>[];\r\n        sortedPriority.sort( (e1, e2) => e2.score - e1.score);\r\n        // todo: prioritize views \"childrens\" of the view of the graph, so they will display differnet views for the same element in different graphs\r\n        // then sort by  view selector matching: on classtype (eattribute, eoperation, eclass...), on values, upperbound...\r\n        if (selectedView) sortedPriority = [new Scored<DViewElement>('manually assigned' as any, selectedView), ...sortedPriority];\r\n        // sortedPriority = sortedPriority.map( s=> s.element) as any] : sortedPriority.map( s=> s.element) as any;\r\n\r\n        // Log.exDevv('viewscores', {data, sp:sortedPriority});\r\n        return sortedPriority;\r\n    }\r\n\r\n    static getAllMP(state?: IStore): DModelElement[] {\r\n        if (!state) state = store.getState();\r\n        let allD: DPointerTargetable[] = Object.values(state.idlookup);\r\n        return allD.filter( (d: DPointerTargetable) => U.isObject(d) && Selectors.isOfSubclass(d, DModelElement)) as DModelElement[]; }\r\n\r\n    static toObject<D extends DPointerTargetable>(ptrs: Pointer<D>[], state?: IStore):D[] {\r\n        if (!state) state = store.getState();\r\n        return ptrs.map(p => (state as IStore).idlookup[p]) as D[]; }\r\n\r\n    static wrap<D extends DPointerTargetable, L extends LPointerTargetable>(arr: (Pointer<D, 1, 1, L> | D)[], state?: IStore): L[] {\r\n        if (!arr.length) return [];\r\n        if (!state) state = store.getState();\r\n        let objarr: D[];\r\n        if (typeof arr[0] === \"string\") { objarr = Selectors.toObject(arr as string[], state); }\r\n        else objarr = arr as D[];\r\n        return objarr.map(p => RuntimeAccessibleClass.wrap(p)) as L[]; }\r\n\r\n    static unwrap<D extends DPointerTargetable, L extends LPointerTargetable>(arr:L[]): D[] { return arr.map( (a)=> a.__raw) as any[]; }\r\n    static getSubNodeElements(forGraph: Pointer<DGraph, 1, 1>, asPointers: boolean = false, wrap: boolean = false): Pointer<DGraphElement>[] | DGraphElement[] | LGraphElement[] {\r\n        const state : IStore = store.getState();\r\n        const g: DGraph = state.idlookup[forGraph] as DGraph;\r\n        if (asPointers) return g.subElements;\r\n        const subelements: DGraphElement[] = g.subElements.map( geid => state.idlookup[geid]) as DGraphElement[];\r\n        if (wrap) return subelements.map<LGraphElement>( (ge) => MyProxyHandler.wrap(ge));\r\n        return subelements; }\r\n\r\n\r\n\r\n\r\n    //// giordano part\r\n\r\n\r\n\r\n    public static getAllPackageClasses(id: string): LClass[] {\r\n        const data = MyProxyHandler.wrap(id) as GObject;\r\n        let lPackage : LPackage | undefined;\r\n        const classes: LClass[] = [];\r\n        if (data.className === \"DReference\") {\r\n            const lClass: LClass = MyProxyHandler.wrap(data.father);\r\n            lPackage = MyProxyHandler.wrap(lClass.father);\r\n        }\r\n        if (data.className === \"DParameter\") {\r\n            const lOperation: LOperation = MyProxyHandler.wrap(data.father);\r\n            const lClass: LClass = MyProxyHandler.wrap(lOperation.father);\r\n            lPackage = MyProxyHandler.wrap(lClass.father);\r\n        }\r\n        if (data.className === \"DOperation\") {\r\n            const lClass: LClass = MyProxyHandler.wrap(data.father);\r\n            lPackage = MyProxyHandler.wrap(lClass.father);\r\n        }\r\n        if (lPackage) {\r\n            for(let classifier of lPackage.classifiers) {\r\n                const lClassifier: LClass | LEnumerator = MyProxyHandler.wrap(classifier);\r\n                if(lClassifier.className === \"DClass\") classes.push(lClassifier as LClass);\r\n            }\r\n        }\r\n        return classes;\r\n    }\r\n    public static getAllPackageEnumerators(id: string): LEnumerator[] {\r\n        const data = MyProxyHandler.wrap(id) as GObject;\r\n        let lPackage : LPackage | undefined;\r\n        const enumerators: LEnumerator[] = [];\r\n        if(data.className === \"DAttribute\") {\r\n            const lClass: LClass = MyProxyHandler.wrap(data.father);\r\n            lPackage = MyProxyHandler.wrap(lClass.father);\r\n        }\r\n        if(data.className === \"DParameter\") {\r\n            const lOperation: LOperation = MyProxyHandler.wrap(data.father);\r\n            const lClass: LClass = MyProxyHandler.wrap(lOperation.father);\r\n            lPackage = MyProxyHandler.wrap(lClass.father);\r\n        }\r\n        if(data.className === \"DOperation\") {\r\n            const lClass: LClass = MyProxyHandler.wrap(data.father);\r\n            lPackage = MyProxyHandler.wrap(lClass.father);\r\n        }\r\n        if(lPackage) {\r\n            for(let classifier of lPackage.classifiers) {\r\n                const lClassifier: LClass | LEnumerator = MyProxyHandler.wrap(classifier);\r\n                if(lClassifier.className === \"DEnumerator\") enumerators.push(lClassifier as LEnumerator);\r\n            }\r\n        }\r\n        return enumerators;\r\n    }\r\n}\r\n\r\nclass Scored<T extends GObject> {\r\n    constructor(public score: number, public element: T) {}\r\n}\r\n"],"mappings":";AAqBA,SAGIA,aAAa,EACbC,MAAM,EAAEC,MAAM,EACdC,aAAa,EACbC,kBAAkB,EAClBC,YAAY,EAAiBC,OAAO,EACpCC,GAAG,EACHC,kBAAkB,EAAEC,MAAM,EAC1BC,cAAc,EAAEC,GAAG,EACnBC,iBAAiB,EACjBC,sBAAsB,EACtBC,KAAK,EACLC,CAAC,QACE,cAAc;AAErB,SAAoBC,UAAU,QAAO,gCAAgC;AAAC,IAEjEC,eAAe;AAAA,WAAfA,eAAe;EAAfA,eAAe,CAAfA,eAAe;EAAfA,eAAe,CAAfA,eAAe;EAAfA,eAAe,CAAfA,eAAe;EAAfA,eAAe,CAAfA,eAAe;AAAA,GAAfA,eAAe,KAAfA,eAAe;AAOpB,WACaC,SAAS,GADrBN,iBAAiB,CAAAO,MAAA,GAAlB,MACaD,SAAS;EAElB,OAAOE,cAAcA,CAAA,EAAgB;IAAA,IAAAC,oBAAA;IACjC,IAAIC,SAAsB;IAC1B,IAAIC,KAAuB,GAAGT,KAAK,CAACU,QAAQ,CAAC,CAAC;IAC9C,MAAMC,QAAQ,IAAAJ,oBAAA,GAAGE,KAAK,CAACG,aAAa,cAAAL,oBAAA,uBAAnBA,oBAAA,CAAqBM,YAAY;IAClD,IAAGF,QAAQ,EAAE;MACT,MAAMG,EAAE,GAAG5B,aAAa,CAAC6B,WAAW,CAACJ,QAAQ,CAAC;MAC9CH,SAAS,GAAIM,EAAE,GAAIA,EAAE,CAACE,KAAK,GAAG,IAAI;IACtC,CAAC,MAAMR,SAAS,GAAG,IAAI;IACvB,OAAOA,SAAS;EACpB;EAEA,OAAcS,oBAAoBA,CAA8ER,KAAc,EAAO;IAAA,IAAAS,qBAAA;IACjIT,KAAK,GAAGA,KAAK,IAAIT,KAAK,CAACU,QAAQ,CAAC,CAAC;IACjC,IAAII,EAAE,IAAAI,qBAAA,GAAGT,KAAK,CAACG,aAAa,cAAAM,qBAAA,uBAAnBA,qBAAA,CAAqBL,YAAY;IAC1C,IAAI,CAACC,EAAE,EAAE,OAAO,CAAC,CAAC;IAClB,IAAIK,GAAQ,GAAG;MAACC,OAAO,EAAE1B,kBAAkB,CAACqB,WAAW,CAACD,EAAE,EAAEL,KAAK;IAAC,CAAQ;IAC1EU,GAAG,CAACH,KAAK,GAAGG,GAAG,CAACC,OAAO,CAAEJ,KAAK;IAC9B,IAAIG,GAAG,CAACH,KAAK,CAACK,WAAW,EAAEF,GAAG,CAACG,EAAE,GAAGH,GAAG,CAACH,KAAK,CAAC,KACzC;MACDG,GAAG,CAACI,EAAE,GAAGJ,GAAG,CAACH,KAAK;MAClBG,GAAG,CAACG,EAAE,GAAGH,GAAG,CAACI,EAAE,CAACC,UAAU;IAC9B;IACA,OAAOL,GAAG;EACd;EAEA,OAAOM,kBAAkBA,CAAA,EAAmB;IACxC;IACA,IAAIhB,KAAuB,GAAGT,KAAK,CAACU,QAAQ,CAAC,CAAC;IAC9C,MAAMgB,IAAmC,GAAGC,MAAM,CAACC,MAAM,CAAEnB,KAAK,CAAEoB,YAAY,CAAC;IAC/E,IAAIC,KAAqB,GAAGJ,IAAI,CAACK,GAAG,CAAiBC,GAAG,IAAKvB,KAAK,CAACwB,QAAQ,CAACD,GAAG,CAAiB,CAAC;IACjG,OAAOF,KAAK;EAChB;EACA;;EAEA,OAAcI,aAAaA,CAAA,EAAkB;IACzC,MAAMzB,KAAuB,GAAGT,KAAK,CAACU,QAAQ,CAAC,CAAC;IAChD,OAAOR,UAAU,CAACa,WAAW,CAACN,KAAK,CAAC0B,UAAU,CAAC;EACnD;EACA,OAAcC,YAAYA,CAAA,EAAiB;IACvC,MAAM3B,KAAuB,GAAGT,KAAK,CAACU,QAAQ,CAAC,CAAC;IAChD,OAAOR,UAAU,CAACa,WAAW,CAACN,KAAK,CAAC4B,SAAS,CAAC;EAClD;EAEA,OAAcC,UAAUA,CAAA,EAAc;IAClC,IAAI7B,KAAuB,GAAGT,KAAK,CAACU,QAAQ,CAAC,CAAC;IAC9C,MAAMgB,IAA8B,GAAGC,MAAM,CAACC,MAAM,CAAEnB,KAAK,CAAE8B,OAAO,CAAC;IACrE,MAAMC,QAAmB,GAAGd,IAAI,CAACK,GAAG,CAAYC,GAAG,IAAKvB,KAAK,CAACwB,QAAQ,CAACD,GAAG,CAAY,CAAC;IACvF,MAAMS,QAAmB,GAAG,EAAE;IAC9B,KAAI,IAAIC,OAAO,IAAIF,QAAQ,EAAE;MACzBC,QAAQ,CAACE,IAAI,CAACnD,OAAO,CAACuB,WAAW,CAAC2B,OAAO,CAACE,EAAE,CAAC,CAAC;IAClD;IACA,OAAOH,QAAQ;EACnB;EACA,OAAcI,SAASA,CAAA,EAAa;IAChC,IAAIpC,KAAuB,GAAGT,KAAK,CAACU,QAAQ,CAAC,CAAC;IAC9C,MAAMgB,IAA6B,GAAGC,MAAM,CAACC,MAAM,CAAEnB,KAAK,CAAEmB,MAAM,CAAC;IACnE,MAAMkB,OAAiB,GAAGpB,IAAI,CAACK,GAAG,CAAWC,GAAG,IAAKvB,KAAK,CAACwB,QAAQ,CAACD,GAAG,CAAW,CAAC;IACnF,MAAMe,OAAiB,GAAG,EAAE;IAC5B,KAAI,IAAIC,MAAM,IAAIF,OAAO,EAAE;MACvB,IAAGE,MAAM,aAANA,MAAM,uBAANA,MAAM,CAAEJ,EAAE,EAAE;QACXG,OAAO,CAACJ,IAAI,CAAChD,MAAM,CAACoB,WAAW,CAACiC,MAAM,CAACJ,EAAE,CAAC,CAAC;MAC/C;IACJ;IACA,OAAOG,OAAO;EAClB;EAEA,OAAcE,UAAUA,CAAA,EAAc;IAClC,MAAMxC,KAAuB,GAAGT,KAAK,CAACU,QAAQ,CAAC,CAAC;IAChD,OAAOD,KAAK,CAACyC,OAAO;EACxB;EAEA,OAAcxC,QAAQA,CAAA,EAAQ;IAC1B,MAAMD,KAAuB,GAAGT,KAAK,CAACU,QAAQ,CAAC,CAAC;IAChD,OAAOD,KAAK;EAChB;EAEA,OAAO0C,UAAUA,CAACP,EAAU,EAAiB;IACzC,MAAMnC,KAAuB,GAAGT,KAAK,CAACU,QAAQ,CAAC,CAAC;IAChD,MAAM0C,KAAoB,GAAG,EAAE;IAC/B,KAAI,IAAIC,IAAI,IAAI5C,KAAK,CAAC2C,KAAK,EAAE;MACzB,IAAGC,IAAI,CAACT,EAAE,KAAKA,EAAE,EAAE;QACfQ,KAAK,CAACT,IAAI,CAACU,IAAI,CAAC;MACpB;IACJ;IACA,OAAOD,KAAK;EAChB;EAEA,OAAOE,oBAAoBA,CAAA,EAAkB;IACzC,IAAI7C,KAAuB,GAAGT,KAAK,CAACU,QAAQ,CAAC,CAAC;IAC9C,MAAMgB,IAAkC,GAAGC,MAAM,CAACC,MAAM,CAAEnB,KAAK,CAAE8C,cAAc,CAAC;IAChF,MAAMC,WAA0B,GAAG9B,IAAI,CAACK,GAAG,CAAgBC,GAAG,IAAKvB,KAAK,CAACwB,QAAQ,CAACD,GAAG,CAAgB,CAAC;IACtG,OAAOwB,WAAW;EACtB;EACA,OAAOC,sBAAsBA,CAAA,EAAgB;IACzC,OAAOrD,SAAS,CAACkD,oBAAoB,CAAC,CAAC,CAAC,CAAC,CAAC;EAC9C;EACA,OAAOI,WAAWA,CAAA,EAAe;IAC7B,MAAMjD,KAAuB,GAAGT,KAAK,CAACU,QAAQ,CAAC,CAAC;IAChD,MAAMiD,QAA6C,GAAGhC,MAAM,CAACC,MAAM,CAAEnB,KAAK,CAAEmD,QAAQ,CAAC;IACrF,MAAMC,SAAqB,GAAGF,QAAQ,CAAC5B,GAAG,CAAaC,GAAG,IAAKvB,KAAK,CAACwB,QAAQ,CAACD,GAAG,CAAa,CAAC;IAC/F,OAAO6B,SAAS;EACpB;EACA,OAAOC,QAAQA,CAACC,KAAa,EAAY;IACrC,IAAItD,KAAuB,GAAGT,KAAK,CAACU,QAAQ,CAAC,CAAC;IAC9C,MAAMiD,QAAwC,GAAGhC,MAAM,CAACC,MAAM,CAAEnB,KAAK,CAAEsD,KAAK,CAAC,CAAC;IAC9E,OAAOJ,QAAQ;EACnB;EAEA,OAAOK,gBAAgBA,CAAA,EAAa;IAChC,MAAMvD,KAAa,GAAGT,KAAK,CAACU,QAAQ,CAAC,CAAC;IACtC,OAAOiB,MAAM,CAACC,MAAM,CAAEnB,KAAK,CAAEwD,UAAU,CAAC;EAC5C;EACA,OAAOC,kBAAkBA,CAAA,EAAa;IAClC,MAAMzD,KAAa,GAAGT,KAAK,CAACU,QAAQ,CAAC,CAAC;IACtC,OAAOiB,MAAM,CAACC,MAAM,CAAEnB,KAAK,CAAE0D,YAAY,CAAC;EAC9C;EACA,OAAOC,gBAAgBA,CAAA,EAAa;IAChC,MAAM3D,KAAa,GAAGT,KAAK,CAACU,QAAQ,CAAC,CAAC;IACtC,OAAOiB,MAAM,CAACC,MAAM,CAAEnB,KAAK,CAAE4D,UAAU,CAAC;EAC5C;EACA,OAAOC,oBAAoBA,CAAA,EAAa;IACpC,MAAM7D,KAAa,GAAGT,KAAK,CAACU,QAAQ,CAAC,CAAC;IACtC,OAAOiB,MAAM,CAACC,MAAM,CAAEnB,KAAK,CAAEmD,QAAQ,CAAC;EAC1C;EACA,OAAOW,aAAaA,CAAA,EAAa;IAC7B,MAAM9D,KAAa,GAAGT,KAAK,CAACU,QAAQ,CAAC,CAAC;IACtC,OAAOiB,MAAM,CAACC,MAAM,CAAEnB,KAAK,CAAE+D,MAAM,CAAC;EACxC;EACA,OAAOC,cAAcA,CAAA,EAAa;IAC9B,MAAMhE,KAAa,GAAGT,KAAK,CAACU,QAAQ,CAAC,CAAC;IACtC,OAAOhB,kBAAkB,CAACgF,IAAI,CAAC/C,MAAM,CAACC,MAAM,CAAEnB,KAAK,CAAEkE,WAAW,CAAC,CAAC;EACtE;EAEA,OAAOC,6BAA6BA,CAAA,EAAa;IAC7C;IACA;IACA,MAAMnE,KAAa,GAAGT,KAAK,CAACU,QAAQ,CAAC,CAAC;IACtC,MAAMmE,SAAmB,GAAGlD,MAAM,CAACC,MAAM,CAAEnB,KAAK,CAAE+D,MAAM,CAAC;IACzDK,SAAS,CAACC,MAAM,CAAC,CAAC,EAAE1E,SAAS,CAACkD,oBAAoB,CAAC,CAAC,CAACyB,MAAM,CAAC;IAC5D;AACR;AACA;AACA;;IAEQ,OAAOF,SAAS;EACpB;EAEA,OAAOG,iBAAiBA,CAAA,EAAyB;IAAA,IAAxBC,IAAI,GAAAC,SAAA,CAAAH,MAAA,QAAAG,SAAA,QAAAC,SAAA,GAAAD,SAAA,MAAG,KAAK;IACjC,MAAMzE,KAAa,GAAGT,KAAK,CAACU,QAAQ,CAAC,CAAC;IACtC,OAAOiB,MAAM,CAACC,MAAM,CAAEnB,KAAK,CAAE2E,WAAW,CAAC;EAC7C;EACA,OAAOC,cAAcA,CAAA,EAAa;IAC9B,MAAM5E,KAAa,GAAGT,KAAK,CAACU,QAAQ,CAAC,CAAC;IACtC,OAAOiB,MAAM,CAACC,MAAM,CAAEnB,KAAK,CAAE6E,QAAQ,CAAC;EAC1C;EAEA,OAAOC,gBAAgBA,CAAA,EAAa;IAChC,MAAM9E,KAAa,GAAGT,KAAK,CAACU,QAAQ,CAAC,CAAC;IACtC,OAAOiB,MAAM,CAACC,MAAM,CAAEnB,KAAK,CAAE+E,UAAU,CAAC;EAC5C;EACA,OAAOC,gBAAgBA,CAAA,EAAa;IAChC,MAAMhF,KAAa,GAAGT,KAAK,CAACU,QAAQ,CAAC,CAAC;IACtC,OAAOiB,MAAM,CAACC,MAAM,CAAEnB,KAAK,CAAEiF,UAAU,CAAC;EAC5C;EAEA,OAAOC,WAAWA,CAA0BC,OAAe,EAAK;IAC5D,MAAMnF,KAAuB,GAAGT,KAAK,CAACU,QAAQ,CAAC,CAAC;IAChD,MAAMmF,QAAW,GAAGpF,KAAK,CAACwB,QAAQ,CAAC2D,OAAO,CAAM;IAChD,OAAOC,QAAQ;EACnB;EAEA,OAAOC,gBAAgBA,CAAA,EAAa;IAChC,MAAMrF,KAAa,GAAGT,KAAK,CAACU,QAAQ,CAAC,CAAC;IACtC,MAAMqF,OAAO,GAAGpE,MAAM,CAACC,MAAM,CAAEnB,KAAK,CAAEuF,QAAQ,CAAC;IAC/C,OAAO5G,MAAM,CAAC2B,WAAW,CAACgF,OAAO,CAAC;EACtC;EAEA,OAAOE,YAAYA,CAAA,EAAa;IAC5B,MAAMxF,KAAa,GAAGT,KAAK,CAACU,QAAQ,CAAC,CAAC;IACtC,MAAMqF,OAAO,GAAGpE,MAAM,CAACC,MAAM,CAAEnB,KAAK,CAAEyF,QAAQ,CAAC;IAC/C,OAAO9G,MAAM,CAAC2B,WAAW,CAACgF,OAAO,CAAC;EACtC;;EAEA;;EAEA,OAAOI,SAASA,CAAsDC,IAAQ,EAAeC,eAAoB,EACI;IACjH,MAAM5F,KAAa,GAAGT,KAAK,CAACU,QAAQ,CAAC,CAAC;IACtC,IAAIgB,IAA4B,GAAG,EAAE;IAErCzB,CAAC,CAACqG,WAAW,CAAC,KAAK,EAAE5E,IAAI;IACrB;IACAC,MAAM,CAACC,MAAM,CAACnB,KAAK,CAAC8F,WAAW,IAAI,CAAC,CAAC,CAAC,EACtC5E,MAAM,CAACC,MAAM,CAACnB,KAAK,CAAC+F,OAAO,IAAI,CAAC,CAAC,CAAC,EAClC7E,MAAM,CAACC,MAAM,CAACnB,KAAK,CAACgG,YAAY,IAAI,CAAC,CAAC,CAAC,EACvC9E,MAAM,CAACC,MAAM,CAACnB,KAAK,CAACiG,UAAU,IAAI,CAAC,CAAC,CAAC,CAAC;IAE1CC,OAAO,CAACC,GAAG,CAAC,sBAAsB,EAAE;MAAClF,IAAI;MAAEmF,CAAC,EAAElF,MAAM,CAACC,MAAM,CAACnB,KAAK,CAACqG,MAAM,IAAI,CAAC,CAAC,CAAC;MAAEC,EAAE,EAACpF,MAAM,CAACC,MAAM,CAACnB,KAAK,CAAC8F,WAAW,IAAI,CAAC,CAAC,CAAC;MAAES,CAAC,EAACrF,MAAM,CAACC,MAAM,CAACnB,KAAK,CAAC+F,OAAO,IAAI,CAAC,CAAC,CAAC;MAAES,EAAE,EAACtF,MAAM,CAACC,MAAM,CAACnB,KAAK,CAACgG,YAAY,IAAI,CAAC,CAAC,CAAC;MAAES,EAAE,EAACvF,MAAM,CAACC,MAAM,CAACnB,KAAK,CAACiG,UAAU,IAAI,CAAC,CAAC;IAAC,CAAC,CAAC;IACxP,IAAIN,IAAI,KAAKjB,SAAS,IAAIiB,IAAI,KAAK,IAAI,EAAE,OAAO1E,IAAI,CAACK,GAAG,CAAEoF,CAAC,IAAI7H,kBAAkB,CAAC8G,IAAI,CAACe,CAAC,CAAC,CAAC;IAC1F,IAAId,eAAe,KAAKlB,SAAS,IAAIkB,eAAe,KAAK,IAAI,EAAE,OAAO3E,IAAI,CAACK,GAAG,CAAEqF,CAAC,IAAI3G,KAAK,CAACwB,QAAQ,CAACmF,CAAC,CAAC,CAAC;IACvG,OAAO1F,IAAI;EACf;EAEA,OAAO2F,MAAMA,CAERC,MAAW,EAAEC,SAA8B,EAAE9G,KAAc,EAAE4F,eAAoB,EAAOD,IAAQ,EAAsB;IACvH,IAAI,CAAC3F,KAAK,EAAEA,KAAK,GAAGT,KAAK,CAACU,QAAQ,CAAC,CAAC;IACpC,IAAI8G,MAAM,GAAIF,MAAM,IAAgB;MAACG,IAAI,EAAC;IAAU,CAAC;IACrD,MAAMC,SAAiB,GAAG,CAAC,CAAAF,MAAM,aAANA,MAAM,uBAANA,MAAM,CAAEG,eAAe,KAAIH,MAAM,CAACC,IAAI,EAAEG,WAAW,CAAC,CAAC;IAChF,MAAMC,gBAAuC,GACtCpH,KAAK,CAAaiH,SAAS,CAAC,IAC3BjH,KAAK,CAAaiH,SAAS,CAACI,MAAM,CAAC,CAAC,CAAC,CAAC,IACtCrH,KAAK,CAAaiH,SAAS,GAAG,GAAG,CAAC,IAClCjH,KAAK,CAAaiH,SAAS,CAACI,MAAM,CAAC,CAAC,CAAC,GAAG,GAAG,CAAC;IACpDrI,GAAG,CAACsI,KAAK,CAAC,CAACF,gBAAgB,EAAE,wBAAwB,EAAE;MAACpH,KAAK;MAAEiH,SAAS;MAAEJ;IAAM,CAAC,CAAC;IAClF,IAAIU,eAA2B,GAAG,IAAI;IACtC,IAAIC,eAA2B,GAAG,IAAI;IACtC,IAAI5B,eAAe,IAAID,IAAI,EAAE;MACzB4B,eAAe,GAAGH,gBAAgB,CAAC9F,GAAG,CAAGmG,CAAC,IAAMzH,KAAK,CAAYwB,QAAQ,CAACiG,CAAC,CAAE,CAAQ;MACrF,IAAI9B,IAAI,EAAE;QACN6B,eAAe,GAAGD,eAAe,CAACjG,GAAG,CAAEmG,CAAC,IAAI5I,kBAAkB,CAAC8G,IAAI,CAAC8B,CAAC,CAAC,CAAe;MACzF;IACJ;IACA,IAAI/G,GAAU,GAAIkF,eAAe,IAAID,IAAI,GAAIA,IAAI,GAAG6B,eAAe,GAAGD,eAAe,GAAIH,gBAAmC;IAC5H,IAAI,CAACM,KAAK,CAACC,OAAO,CAACjH,GAAG,CAAC,EAAEA,GAAG,GAAGQ,MAAM,CAACC,MAAM,CAACT,GAAG,CAAC,CAACkH,MAAM,CAACH,CAAC,IAAIA,CAAC,YAAYvG,MAAM,CAAU;IAC3F,IAAI4F,SAAS,EAAE,OAAOpG,GAAG,CAACkH,MAAM,CAAEH,CAAC,IAAIX,SAAS,CAACW,CAAC,CAAC,CAAC;IACpD,OAAO/G,GAAG;EACd;EACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;EAEI,OAAOmH,QAAQA,CAACb,IAAY,EAAiF;IAAA,IAA/Ec,aAAsB,GAAArD,SAAA,CAAAH,MAAA,QAAAG,SAAA,QAAAC,SAAA,GAAAD,SAAA,MAAG,KAAK;IAAA,IAAEkB,IAAa,GAAAlB,SAAA,CAAAH,MAAA,QAAAG,SAAA,QAAAC,SAAA,GAAAD,SAAA,MAAG,KAAK;IAC/E,IAAI,CAACqD,aAAa,EAAEd,IAAI,GAAGA,IAAI,CAACG,WAAW,CAAC,CAAC;IAC7C,IAAIzG,GAAG,GAAGf,SAAS,CAACiH,MAAM,CAAiBlI,MAAM,EAAGqJ,CAAC,IAAK,CAACD,aAAa,GAAGC,CAAC,CAACf,IAAI,GAAGe,CAAC,CAACf,IAAI,CAACG,WAAW,CAAC,CAAC,MAAMH,IAAI,EAAEtC,SAAS,EAAE,IAAI,EAAEiB,IAAW,CAAC,CAAC,CAAC,CAAC;IACpJ,OAAOjF,GAAG;EACd;EAEA,OAAOsH,SAASA,CAACC,MAAiC,EAAEjB,IAAY,EAAyG;IAAA,IAAvGc,aAAsB,GAAArD,SAAA,CAAAH,MAAA,QAAAG,SAAA,QAAAC,SAAA,GAAAD,SAAA,MAAG,KAAK;IAAA,IAAEkB,IAAa,GAAAlB,SAAA,CAAAH,MAAA,QAAAG,SAAA,QAAAC,SAAA,GAAAD,SAAA,MAAG,KAAK;IACnH,OAAO9E,SAAS,CAACuI,UAAU,CAACD,MAAM,EAAE,MAAM,EAAEjB,IAAI,EAAEc,aAAa,EAAEnC,IAAI,CAAC;EAAE;EAE5E,OAAOuC,UAAUA,CAACD,MAAiC,EAAE3E,KAAa,EAAE6E,KAAa,EAAyG;IAAA,IAAvGL,aAAsB,GAAArD,SAAA,CAAAH,MAAA,QAAAG,SAAA,QAAAC,SAAA,GAAAD,SAAA,MAAG,KAAK;IAAA,IAAEkB,IAAa,GAAAlB,SAAA,CAAAH,MAAA,QAAAG,SAAA,QAAAC,SAAA,GAAAD,SAAA,MAAG,KAAK;IACpI,IAAI,CAACqD,aAAa,EAAEK,KAAK,GAAGA,KAAK,CAAChB,WAAW,CAAC,CAAC;IAC/C,IAAIL,SAAS,GAAIiB,CAAM,IAAK;MAAA,IAAAK,QAAA;MACxB,IAAI1H,GAAG,GAAG,CAACoH,aAAa,GAAGC,CAAC,CAACzE,KAAK,CAAC,IAAA8E,QAAA,GAAGL,CAAC,CAACzE,KAAK,CAAC,cAAA8E,QAAA,uBAARA,QAAA,CAAUjB,WAAW,CAAC,CAAC,MAAMgB,KAAK;MACxEjC,OAAO,CAACC,GAAG,CAAC,4BAA4B,EAAE;QAAC4B,CAAC;QAAEM,MAAM,EAACN,CAAC,CAACzE,KAAK,CAAC;QAAE6E,KAAK;QAAEzH;MAAG,CAAC,CAAC;MAC3E,OAAOA,GAAG;IACd,CAAC;IACD,IAAIA,GAAG,GAAGf,SAAS,CAACiH,MAAM,CAACqB,MAAM,EAAEnB,SAAS,EAAEpC,SAAS,EAAE,IAAI,EAAEiB,IAAW,CAAC,CAAC,CAAC,CAAC;IAC9E,OAAOjF,GAAG;EAAE;EAEhB,OAAO4H,QAAQA,CAACxB,SAAkC,EAAkB;IAAE,OAAOnH,SAAS,CAACiH,MAAM,CAAC9H,YAAY,CAAC;EAAE;EAI7G,OAAeyJ,OAAOA,CAAChI,KAAa,EAAEiI,KAAa,EAAwB;IACvE,IAAI;MACA,OAAOC,IAAI,CAACD,KAAK,CAAC;IACtB,CAAC,CAAC,OAAOf,CAAC,EAAE;MAAE,OAAO,EAAE;IAAE;EAC7B;EACA;AACJ;AACA;AACA;;EAGI;EACA,OAAeiB,mBAAmBA,CAACnC,CAAe,EAAEoC,IAAmC,EAA2F;IAC9K,IAAI,CAACpC,CAAC,CAACiC,KAAK,EAAE,OAAO9I,eAAe,CAACkJ,cAAc;IACnD,MAAMJ,KAAK,GAAGjC,CAAC,CAACiC,KAAK;IACrB,MAAM5G,SAAS,GAAGjC,SAAS,CAACgC,YAAY,CAAC,CAAC;IAC1C,IAAG4E,CAAC,CAAC3E,SAAS,KAAKA,SAAS,CAACO,EAAE,EAAE;MAAE,OAAOzC,eAAe,CAACkJ,cAAc;IAAE;IAC1E,IAAIC,YAA2B,GAAGvJ,sBAAsB,CAACwE,aAAa,CAAC,CAAyD;IAChI,IAAI;MACA,MAAMU,IAAI,GAAGpF,GAAG,CAACwI,MAAM,CAAC,KAAK,EAAE,KAAK,EAAE,CAACe,IAAI,CAAC,EAAEH,KAAK,EAAEK,YAAY,CAAC;MAClE3C,OAAO,CAAC4C,KAAK,CAAC,CAAC;MAAE5C,OAAO,CAACC,GAAG,CAAC3B,IAAI,CAAC;MAClC,IAAGA,IAAI,CAACF,MAAM,GAAG,CAAC,EAAE,OAAO5E,eAAe,CAACqJ,WAAW,GAAGxC,CAAC,CAACyC,2BAA2B,CAAC,KAClF,OAAOtJ,eAAe,CAACuJ,QAAQ;IACxC,CAAC,CAAC,OAAOxB,CAAC,EAAE;MAAEvB,OAAO,CAACgD,KAAK,CAAC,mBAAmB,CAAC;IAAE;IAClD,OAAOxJ,eAAe,CAACuJ,QAAQ;EACnC;EAGA,OAAeE,sBAAsBA,CAAC5C,CAAe,EAAEoC,IAAmB,EAAmB;IACzF,IAAI,CAACpC,CAAC,CAAC6C,kBAAkB,IAAI,CAAC7C,CAAC,CAAC6C,kBAAkB,CAAC9E,MAAM,EAAE,OAAO5E,eAAe,CAACkJ,cAAc;IAChG,IAAI,CAACD,IAAI,EAAE,OAAOjJ,eAAe,CAACuJ,QAAQ;IAC1C,IAAII,SAAoC,GAAG/J,sBAAsB,CAACgK,GAAG,CAACX,IAAI,aAAJA,IAAI,uBAAJA,IAAI,CAAE1B,SAAS,CAAC;IACtFjI,GAAG,CAACsI,KAAK,CAAC,CAAC+B,SAAS,EAAE,4BAA4B,EAAE;MAAC9C,CAAC;MAAEoC;IAAI,CAAC,CAAC,CAAC,CAAC;IAChE,IAAIY,gBAAyB,GAAG,KAAK;IACrC,KAAK,IAAIC,WAAW,IAAIjD,CAAC,CAAC6C,kBAAkB,EAAE;MAC1C,MAAMK,WAAsC,GAAGnK,sBAAsB,CAACgK,GAAG,CAACE,WAAW,CAAC;MACtF,IAAIH,SAAS,KAAKI,WAAW,EAAE,OAAO/J,eAAe,CAACqJ,WAAW,CAAC,CAAC;MACnE,IAAI,CAACQ,gBAAgB,IAAI/J,CAAC,CAACkK,gBAAgB,CAACL,SAAS,EAAEI,WAAW,CAAC,EAAEF,gBAAgB,GAAG,IAAI,CAAC,CAAC;MAC9F,IAAIA,gBAAgB,EAAE,OAAO7J,eAAe,CAACiK,iBAAiB;IAClE;IACA,OAAOjK,eAAe,CAACuJ,QAAQ;EACtC;EAEG,OAAeW,YAAYA,CAACjB,IAAwB,EAAEkB,WAA+C,EAA4C;IAAA,IAA1CC,cAAuB,GAAArF,SAAA,CAAAH,MAAA,QAAAG,SAAA,QAAAC,SAAA,GAAAD,SAAA,MAAG,KAAK;IAClI,IAAI4E,SAAoC,GAAG/J,sBAAsB,CAACgK,GAAG,CAACX,IAAI,CAAC1B,SAAS,CAAC;IACrFjI,GAAG,CAACsI,KAAK,CAAC,CAAC+B,SAAS,EAAE,2CAA2C,EAAE;MAACV;IAAI,CAAC,CAAC;IAC1E,MAAMc,WAAsC,GAAG,OAAOI,WAAW,KAAK,QAAQ,GAAEvK,sBAAsB,CAACgK,GAAG,CAACO,WAAW,CAAC,GAAGA,WAAW;IACrI,IAAIR,SAAS,KAAKI,WAAW,EAAE,OAAOK,cAAc;IACpD,OAAOtK,CAAC,CAACkK,gBAAgB,CAACL,SAAS,EAAEI,WAAW,CAAC;EACrD;EAIA,OAAeM,SAASA,CAACC,EAAgB,EAAErB,IAAmB,EAAEsB,OAAkC,EAAEC,KAAoB,EAAkE;IAAA,IAAhEC,kBAAiD,GAAA1F,SAAA,CAAAH,MAAA,QAAAG,SAAA,QAAAC,SAAA,GAAAD,SAAA,MAAG,EAAE;IAC5K;IACA,IAAI2F,qBAAsC,GAAG,IAAI,CAACjB,sBAAsB,CAACa,EAAE,EAAErB,IAAI,aAAJA,IAAI,uBAAJA,IAAI,CAAE0B,KAAK,CAAC;IACzF;IACA,IAAID,qBAAqB,KAAK1K,eAAe,CAACuJ,QAAQ,EAAE,OAAOvJ,eAAe,CAACuJ,QAAQ;IACvF;IACA,IAAIqB,UAAU,GAAG3K,SAAS,CAAC+I,mBAAmB,CAACsB,EAAE,EAAErB,IAAI,CAAC;IACxD,IAAI2B,UAAU,KAAK5K,eAAe,CAACuJ,QAAQ,EAAE,OAAOvJ,eAAe,CAACuJ,QAAQ;IAC5E;IACA,IAAIsB,cAAc,GAAG5K,SAAS,CAAC+I,mBAAmB,CAACsB,EAAE,EAAErB,IAAI,CAAC;IAC5D,IAAI4B,cAAc,KAAK7K,eAAe,CAACuJ,QAAQ,EAAE,OAAOvJ,eAAe,CAACuJ,QAAQ;IAChF;IACA,OAAQmB,qBAAqB,GAAGE,UAAU,GAAGC,cAAc,GAAIP,EAAE,CAAChB,2BAA2B;EAAE;EAGnG,OAAOwB,eAAeA,CAAC7B,IAAmB,EAAEsB,OAAkC,EAAEC,KAAoB,EAC7EO,cAAyD,EAAEC,YAAuD,EAA0B;IAC/J,MAAM1K,KAAc,GAAGT,KAAK,CAACU,QAAQ,CAAC,CAAC;IACvC,MAAM0K,QAAwB,GAAG,CAAC,GAAGhL,SAAS,CAACqB,kBAAkB,CAAC,CAAC,CAAC;IACpE,MAAM4J,YAAiC,GAAG,IAAI,CAAC,CAAC;IAChD,MAAMC,UAA+B,GAAGH,YAAY,GAAG1K,KAAK,CAACwB,QAAQ,CAACkJ,YAAY,CAAC,GAAmB,IAAI;IAC1G,MAAMI,qBAAoD,GAAGD,UAAU,GAAGA,UAAU,CAACE,QAAQ,GAAG,EAAE,CAAC,CAAC;IACpG,IAAIH,YAAY,EAAEpL,CAAC,CAACwL,cAAc,CAACL,QAAQ,EAAEC,YAAY,CAAC;IAC1D,IAAIK,cAAsC,GAAGN,QAAQ,CAACrJ,GAAG;IACrD;IACCiF,CAAC,IAAK;MACH,OAAO,IAAI2E,MAAM,CAAevL,SAAS,CAACoK,SAAS,CAACxD,CAAC,EAAEoC,IAAI,EAAEsB,OAAO,EAAEC,KAAK,EAAEY,qBAAqB,CAAC,EAAEvE,CAAC,CAAC;IAAC,CAChH,CAA2B;IAC3B0E,cAAc,CAACE,IAAI,CAAE,CAACC,EAAE,EAAEC,EAAE,KAAKA,EAAE,CAACC,KAAK,GAAGF,EAAE,CAACE,KAAK,CAAC;IACrD;IACA;IACA,IAAIV,YAAY,EAAEK,cAAc,GAAG,CAAC,IAAIC,MAAM,CAAe,mBAAmB,EAASN,YAAY,CAAC,EAAE,GAAGK,cAAc,CAAC;IAC1H;;IAEA;IACA,OAAOA,cAAc;EACzB;EAEA,OAAOM,QAAQA,CAACvL,KAAc,EAAmB;IAC7C,IAAI,CAACA,KAAK,EAAEA,KAAK,GAAGT,KAAK,CAACU,QAAQ,CAAC,CAAC;IACpC,IAAIuL,IAA0B,GAAGtK,MAAM,CAACC,MAAM,CAACnB,KAAK,CAACwB,QAAQ,CAAC;IAC9D,OAAOgK,IAAI,CAAC5D,MAAM,CAAGG,CAAqB,IAAKvI,CAAC,CAACiM,QAAQ,CAAC1D,CAAC,CAAC,IAAIpI,SAAS,CAACiK,YAAY,CAAC7B,CAAC,EAAEnJ,aAAa,CAAC,CAAC;EAAqB;EAElI,OAAO8M,QAAQA,CAA+BzK,IAAkB,EAAEjB,KAAc,EAAM;IAClF,IAAI,CAACA,KAAK,EAAEA,KAAK,GAAGT,KAAK,CAACU,QAAQ,CAAC,CAAC;IACpC,OAAOgB,IAAI,CAACK,GAAG,CAACoF,CAAC,IAAK1G,KAAK,CAAYwB,QAAQ,CAACkF,CAAC,CAAC,CAAC;EAAS;EAEhE,OAAOf,IAAIA,CAA6DgG,GAAgC,EAAE3L,KAAc,EAAO;IAC3H,IAAI,CAAC2L,GAAG,CAACrH,MAAM,EAAE,OAAO,EAAE;IAC1B,IAAI,CAACtE,KAAK,EAAEA,KAAK,GAAGT,KAAK,CAACU,QAAQ,CAAC,CAAC;IACpC,IAAI2L,MAAW;IACf,IAAI,OAAOD,GAAG,CAAC,CAAC,CAAC,KAAK,QAAQ,EAAE;MAAEC,MAAM,GAAGjM,SAAS,CAAC+L,QAAQ,CAACC,GAAG,EAAc3L,KAAK,CAAC;IAAE,CAAC,MACnF4L,MAAM,GAAGD,GAAU;IACxB,OAAOC,MAAM,CAACtK,GAAG,CAACoF,CAAC,IAAIpH,sBAAsB,CAACqG,IAAI,CAACe,CAAC,CAAC,CAAC;EAAS;EAEnE,OAAOmF,MAAMA,CAA6DF,GAAO,EAAO;IAAE,OAAOA,GAAG,CAACrK,GAAG,CAAGwK,CAAC,IAAIA,CAAC,CAACzB,KAAK,CAAC;EAAW;EACnI,OAAO0B,kBAAkBA,CAACC,QAA+B,EAAoH;IAAA,IAAlHC,UAAmB,GAAAxH,SAAA,CAAAH,MAAA,QAAAG,SAAA,QAAAC,SAAA,GAAAD,SAAA,MAAG,KAAK;IAAA,IAAEkB,IAAa,GAAAlB,SAAA,CAAAH,MAAA,QAAAG,SAAA,QAAAC,SAAA,GAAAD,SAAA,MAAG,KAAK;IACzG,MAAMzE,KAAc,GAAGT,KAAK,CAACU,QAAQ,CAAC,CAAC;IACvC,MAAMmG,CAAS,GAAGpG,KAAK,CAACwB,QAAQ,CAACwK,QAAQ,CAAW;IACpD,IAAIC,UAAU,EAAE,OAAO7F,CAAC,CAAC8F,WAAW;IACpC,MAAMC,WAA4B,GAAG/F,CAAC,CAAC8F,WAAW,CAAC5K,GAAG,CAAE8K,IAAI,IAAIpM,KAAK,CAACwB,QAAQ,CAAC4K,IAAI,CAAC,CAAoB;IACxG,IAAIzG,IAAI,EAAE,OAAOwG,WAAW,CAAC7K,GAAG,CAAkB+K,EAAE,IAAKlN,cAAc,CAACwG,IAAI,CAAC0G,EAAE,CAAC,CAAC;IACjF,OAAOF,WAAW;EAAE;;EAKxB;;EAIA,OAAcG,oBAAoBA,CAACnK,EAAU,EAAY;IACrD,MAAMwG,IAAI,GAAGxJ,cAAc,CAACwG,IAAI,CAACxD,EAAE,CAAY;IAC/C,IAAIoK,QAA+B;IACnC,MAAMC,OAAiB,GAAG,EAAE;IAC5B,IAAI7D,IAAI,CAAC1B,SAAS,KAAK,YAAY,EAAE;MACjC,MAAMwF,MAAc,GAAGtN,cAAc,CAACwG,IAAI,CAACgD,IAAI,CAAC+D,MAAM,CAAC;MACvDH,QAAQ,GAAGpN,cAAc,CAACwG,IAAI,CAAC8G,MAAM,CAACC,MAAM,CAAC;IACjD;IACA,IAAI/D,IAAI,CAAC1B,SAAS,KAAK,YAAY,EAAE;MACjC,MAAM0F,UAAsB,GAAGxN,cAAc,CAACwG,IAAI,CAACgD,IAAI,CAAC+D,MAAM,CAAC;MAC/D,MAAMD,MAAc,GAAGtN,cAAc,CAACwG,IAAI,CAACgH,UAAU,CAACD,MAAM,CAAC;MAC7DH,QAAQ,GAAGpN,cAAc,CAACwG,IAAI,CAAC8G,MAAM,CAACC,MAAM,CAAC;IACjD;IACA,IAAI/D,IAAI,CAAC1B,SAAS,KAAK,YAAY,EAAE;MACjC,MAAMwF,MAAc,GAAGtN,cAAc,CAACwG,IAAI,CAACgD,IAAI,CAAC+D,MAAM,CAAC;MACvDH,QAAQ,GAAGpN,cAAc,CAACwG,IAAI,CAAC8G,MAAM,CAACC,MAAM,CAAC;IACjD;IACA,IAAIH,QAAQ,EAAE;MACV,KAAI,IAAIK,UAAU,IAAIL,QAAQ,CAACxJ,WAAW,EAAE;QACxC,MAAM8J,WAAiC,GAAG1N,cAAc,CAACwG,IAAI,CAACiH,UAAU,CAAC;QACzE,IAAGC,WAAW,CAAC5F,SAAS,KAAK,QAAQ,EAAEuF,OAAO,CAACtK,IAAI,CAAC2K,WAAqB,CAAC;MAC9E;IACJ;IACA,OAAOL,OAAO;EAClB;EACA,OAAcM,wBAAwBA,CAAC3K,EAAU,EAAiB;IAC9D,MAAMwG,IAAI,GAAGxJ,cAAc,CAACwG,IAAI,CAACxD,EAAE,CAAY;IAC/C,IAAIoK,QAA+B;IACnC,MAAM5H,WAA0B,GAAG,EAAE;IACrC,IAAGgE,IAAI,CAAC1B,SAAS,KAAK,YAAY,EAAE;MAChC,MAAMwF,MAAc,GAAGtN,cAAc,CAACwG,IAAI,CAACgD,IAAI,CAAC+D,MAAM,CAAC;MACvDH,QAAQ,GAAGpN,cAAc,CAACwG,IAAI,CAAC8G,MAAM,CAACC,MAAM,CAAC;IACjD;IACA,IAAG/D,IAAI,CAAC1B,SAAS,KAAK,YAAY,EAAE;MAChC,MAAM0F,UAAsB,GAAGxN,cAAc,CAACwG,IAAI,CAACgD,IAAI,CAAC+D,MAAM,CAAC;MAC/D,MAAMD,MAAc,GAAGtN,cAAc,CAACwG,IAAI,CAACgH,UAAU,CAACD,MAAM,CAAC;MAC7DH,QAAQ,GAAGpN,cAAc,CAACwG,IAAI,CAAC8G,MAAM,CAACC,MAAM,CAAC;IACjD;IACA,IAAG/D,IAAI,CAAC1B,SAAS,KAAK,YAAY,EAAE;MAChC,MAAMwF,MAAc,GAAGtN,cAAc,CAACwG,IAAI,CAACgD,IAAI,CAAC+D,MAAM,CAAC;MACvDH,QAAQ,GAAGpN,cAAc,CAACwG,IAAI,CAAC8G,MAAM,CAACC,MAAM,CAAC;IACjD;IACA,IAAGH,QAAQ,EAAE;MACT,KAAI,IAAIK,UAAU,IAAIL,QAAQ,CAACxJ,WAAW,EAAE;QACxC,MAAM8J,WAAiC,GAAG1N,cAAc,CAACwG,IAAI,CAACiH,UAAU,CAAC;QACzE,IAAGC,WAAW,CAAC5F,SAAS,KAAK,aAAa,EAAEtC,WAAW,CAACzC,IAAI,CAAC2K,WAA0B,CAAC;MAC5F;IACJ;IACA,OAAOlI,WAAW;EACtB;AACJ,CAAC,KAAA/E,MAAA;AAED,MAAMsL,MAAM,CAAoB;EAC5B6B,WAAWA,CAAQzB,KAAa,EAAS3K,OAAU,EAAE;IAAA,KAAlC2K,KAAa,GAAbA,KAAa;IAAA,KAAS3K,OAAU,GAAVA,OAAU;EAAG;AAC1D","ignoreList":[]},"metadata":{},"sourceType":"module"}