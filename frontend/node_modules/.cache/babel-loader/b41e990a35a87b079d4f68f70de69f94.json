{"ast":null,"code":"var _class, _class3, _class5, _class7, _class8, _class9, _class11;\nimport { DPointerTargetable, JsType, Log, LPointerTargetable, RuntimeAccessible, RuntimeAccessibleClass, SetFieldAction, SetRootFieldAction, U } from \"../joiner\";\n// (DX extends DUser ? LUser : (DX extends DPointerTargetable ? LPointerTargetable : (ERROR))\n// (DX extends DUser ? LUser : (DX extends DPointerTargetable ? LPointerTargetable : (           WViewElement\n//\n// (IN extends WViewElement ? LViewElement : (IN extends WViewTransientProperties ? LWiewTransientProperties : (ERROR)))\n// ))\n// type WtoL<WX extends WPointerTargetable> ='';\n\nexport let LogicContext = RuntimeAccessible(_class = class LogicContext extends RuntimeAccessibleClass {\n  // public proxyfyFunction: PF;\n\n  // & GObject;\n\n  constructor(proxyObject, data) {\n    super();\n    this.proxyObject = void 0;\n    this.data = void 0;\n    this.write = void 0;\n    this.className = this.constructor.name;\n    this.data = data;\n    this.proxyObject = proxyObject;\n    this.write = proxyObject;\n  }\n  /*\r\n      saveToRedux(propkey: \"keyof data\" | string, val: \"typeof data[path]\" | any): void { // todo: ask non stackoverflow\r\n          // todo, put data in redux store, path is \"obj1.obj2.obj3...\" might replace it with a path funciton that return the foremost nested object container\r\n          if (!propkey) {\r\n              // todo: set whole object instead of a property\r\n          }\r\n      }*/\n}) || _class;\nexport let MapLogicContext = RuntimeAccessible(_class3 = class MapLogicContext extends LogicContext {\n  constructor(proxy, data, path) {\n    let subMaps = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];\n    super(proxy, data);\n    // this.proxyfyFunction = proxyfyFunction;\n    this.data = void 0;\n    this.path = void 0;\n    this.subMaps = void 0;\n    this.proxyObject = proxy;\n    this.data = data;\n    this.path = path;\n    this.subMaps = subMaps;\n    this.className = this.constructor.name;\n  }\n}) || _class3;\nexport let MyProxyHandler = RuntimeAccessible(_class5 = class MyProxyHandler extends RuntimeAccessibleClass {\n  constructor() {\n    super(...arguments);\n    this.s = 'set_';\n    this.g = 'get_';\n  }\n  /*get(target: T, p: string | number | symbol, proxyitself: Proxyfied<T>): boolean {\r\n      switch (p) {\r\n          case '_isProxy': return true;\r\n          case 'init': return (this as any).init;\r\n          case 'init0': return (this as any).init0;\r\n          default: throw new Error('proxy get must be overridden, called for key: ' + (p as string));\r\n      }}*/\n  set(target, p, value, proxyitself) {\n    throw new Error('proxy set must be overridden');\n  }\n  deleteProperty(target, p) {\n    throw new Error('proxy delete must be overridden');\n  }\n  ownKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  }\n  static wrap(data, baseObjInLookup) {\n    let path = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n    let canThrow = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    //    static wrap<D extends RuntimeAccessibleClass, L extends LPointerTargetable, RET extends boolean = false>\n    //        (data: D | Pointer<DViewElement>, baseObjInLookup?: DPointerTargetable, path: string = '', canthrow: RET = false as RET): RET {\n    return DPointerTargetable.wrap(data, baseObjInLookup, path);\n  }\n  static isProxy(data) {\n    return (data === null || data === void 0 ? void 0 : data.__isProxy) || false;\n  }\n}) || _class5;\n/*\r\n* handling proxy += and proxy -=\r\n*\r\n* will become var = var + add; which will call Symbol.getPrimitive\r\nconsole.log(+obj2);     // 10        — hint is \"number\"         NaN with +array with multiple vals, +array[0] with array of size 1, NaN with functions & objects\r\nconsole.log(`${obj2}`); // \"hello\"   — hint is \"string\"         array => array.join(','), object => \"[object Object]\", function => function.toString() whole func definition with body code\r\nconsole.log(obj2 + \"\"); // \"true\"    — hint is \"default\"        array, object, function => same as with hint \"string\"\r\n*\r\n* */\n// NB: lclass.extends += somepointer will become: lclass.extends = lclass.extends + somepointer;\n// array + string will cause getPrimitive(\"default\") to array, then .join(',') on it, and finally and toString() to be called on all array members.\n// so pointers cannot include \",\" char and toString() must return a pointer to keep lclass.extends += somepointer as a valid expression;\n// -= will call getPrimitive(\"number\") which will result in array -> NaN, so NaN = NaN - pointer and cannot be done.\nlet GetPathHandler = RuntimeAccessible(_class7 = (_class8 = class GetPathHandler extends MyProxyHandler {\n  constructor() {\n    super();\n    this.strbuilder = '';\n    this.array = [];\n    this.calls = [];\n  }\n  get(targetObj, propKey, proxyitself) {\n    // console.log('GetPathHandler', {targetObj, propKey, proxyitself});\n    if (propKey === \"start\") {\n      this.strbuilder = '';\n      this.array = [];\n    }\n    if (propKey === '$') {\n      const ret = GetPathHandler.__asCalls ? this.calls : GetPathHandler.__asArray ? this.array : this.strbuilder;\n      this.array = [];\n      this.strbuilder = '';\n      return ret;\n    }\n    this.array.push(propKey);\n    this.calls.push(arguments);\n    if (propKey === Symbol.toPrimitive) {\n      console.log(\"toprimitive\");\n      return function () {\n        for (var _len = arguments.length, a = new Array(_len), _key = 0; _key < _len; _key++) {\n          a[_key] = arguments[_key];\n        }\n        console.log(\"toprimitive called with parameters\", a);\n      };\n    }\n    if (!GetPathHandler.__asArray && !GetPathHandler.__asCalls) {\n      if (typeof propKey === \"symbol\") {\n        this.strbuilder += propKey.toString();\n      } else {\n        // Giordano: add ignore for webpack\n        //@ts-ignore\n        this.strbuilder += (this.strbuilder ? '.' : '') + propKey;\n      }\n    }\n    return GetPathHandler.__nested ? proxyitself : {};\n  }\n  set(target, p, value, proxyitself) {\n    switch (p) {\n      case '__asArray':\n      case '__asCalls':\n      case '__nested':\n        GetPathHandler[p] = value;\n        return true;\n      default:\n        throw new Error('getPath proxy cannot be written');\n    }\n  }\n}, _class8.__asCalls = false, _class8.__asArray = false, _class8.__nested = true, _class8)) || _class7;\nexport let TargetableProxyHandler = RuntimeAccessible(_class9 = class TargetableProxyHandler extends MyProxyHandler {\n  // permette di fare cose tipo: user.name_surname che ritorna la concatenazione di nome e cognome anche se il campo name_surname non esiste.\n  // to disable type check easily and access 'set_' + varname dynamically\n\n  constructor(d, baseObjInLookup) {\n    let additionalPath = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n    let l = arguments.length > 3 ? arguments[3] : undefined;\n    super();\n    this.lg = void 0;\n    this.l = void 0;\n    this.d = void 0;\n    this.additionalPath = void 0;\n    this.baseObjInLookup = void 0;\n    this.d = d;\n    if (!l) {\n      var _RuntimeAccessibleCla, _RuntimeAccessibleCla2;\n      l = (_RuntimeAccessibleCla = RuntimeAccessibleClass.get(d.className)) === null || _RuntimeAccessibleCla === void 0 ? void 0 : (_RuntimeAccessibleCla2 = _RuntimeAccessibleCla.logic) === null || _RuntimeAccessibleCla2 === void 0 ? void 0 : _RuntimeAccessibleCla2.singleton;\n      Log.exDev(!l, 'Trying to wrap class without singleton or logic mapped', {\n        object: d\n      });\n    }\n    this.baseObjInLookup = baseObjInLookup || d;\n    this.additionalPath = additionalPath;\n    this.l = l;\n    this.lg = this.l;\n    this.className = this.constructor.name;\n  }\n\n  // damiano todo: this does not work\n  concatenableHandler(targetObj, propKey, proxyitself) {\n    console.log(\"concatenableHandler 1\", {\n      targetObj,\n      propKey,\n      proxyitself\n    });\n    if (propKey in targetObj) return null;\n    const propKeyStr = U.asString(propKey, null);\n    let _index = propKeyStr ? propKeyStr.indexOf('_') : -1;\n    console.log(\"concatenableHandler 2\", {\n      targetObj,\n      propKey,\n      propKeyStr,\n      proxyitself,\n      _index\n    });\n    if (_index < 0) return null;\n    let isConcatenable = true;\n    let ret = propKey.split('_').map(subKey => {\n      console.log(\"concatenableHandler 3.0\", {\n        targetObj,\n        subKey,\n        propKeyStr,\n        proxyitself\n      });\n      // se trovo multipli ___ li tratto come spazi aggiuntivi invece che come proprietà '' che ritornano undefined, così posso fare name___surname --> \"damiano   di vincenzo\"\n      let val = subKey === '' ? ' ' : this.get(targetObj, subKey, proxyitself);\n      console.log(\"concatenableHandler 3.1\", {\n        targetObj,\n        subKey,\n        val,\n        propKeyStr,\n        proxyitself,\n        isConcatenable\n      });\n      isConcatenable = isConcatenable && JsType.isPrimitive(val);\n      console.log(\"concatenableHandler 3.2\", {\n        targetObj,\n        subKey,\n        val,\n        propKeyStr,\n        proxyitself,\n        isConcatenable\n      });\n      return val;\n    });\n    console.log(\"concatenableHandler 4\", {\n      targetObj,\n      propKey,\n      propKeyStr,\n      proxyitself,\n      ret,\n      isConcatenable\n    });\n    return isConcatenable ? ret.join(' ') : ret;\n  }\n  get(targetObj, propKey, proxyitself) {\n    let ret;\n    let isError = false;\n    // console.error('_proxy get PRE:', {targetObj, propKey, proxyitself, arguments});\n    try {\n      ret = this.get0(targetObj, propKey, proxyitself);\n    } catch (e) {\n      ret = e;\n      isError = true;\n    }\n\n    // if (isError) throw ret;\n    // console.error('_proxy get POST:', {targetObj, propKey, ret, isError});\n    return ret;\n  }\n  get0(targetObj, propKey, proxyitself) {\n    // console.log('proxy keysearch', {propKey, targetObj, l: this.l, proxyitself, d: this.d});\n    let canThrowErrors = true;\n    if (propKey === \"__raw\") return targetObj;\n    if (typeof propKey === \"symbol\") {\n      switch (String(propKey)) {\n        default:\n          Log.exDevv('unexpected symbol:', propKey);\n          break;\n        case \"Symbol(Symbol.toPrimitive)\":\n          return targetObj[propKey];\n        //  || typeof targetObj;\n      }\n    }\n    //\n    switch (propKey) {\n      case '__raw':\n        return targetObj;\n      case '__serialize':\n        return JSON.stringify(targetObj);\n      case '__isProxy':\n        return true;\n      case '__random':\n        return Math.random();\n      case 'editCount':\n      case 'clonedCounter':\n        return targetObj.clonedCounter || 0;\n    }\n    const proxyacceptables = {\n      typeName: '',\n      $$typeof: ''\n    };\n    // check if exist directly in D.key, L.key or through a get_key\n    if (propKey in this.l || propKey in this.d || this.l[this.g + propKey] || propKey in proxyacceptables) {\n      // todo: il LogicContext passato come parametro risulta nell'autocompletion editor automaticamente generato, come passo un parametro senza passargli il parametro? uso arguments senza dichiararlo?\n      if (typeof propKey !== 'symbol' && this.g + propKey in this.lg) return this.lg[this.g + propKey](new LogicContext(proxyitself, targetObj));\n      if (typeof propKey !== 'symbol' && this.g + propKey in this.lg) {\n        let getterMethod = this.lg[this.g + propKey]; // || this.defaultGetter;\n        return getterMethod ? getterMethod(new LogicContext(proxyitself, targetObj)) : this.defaultGetter(targetObj, propKey, proxyitself);\n      }\n      switch (propKey) {\n        default:\n          //constructor.prototype.typeName\n          // se esiste la proprietà ma non esiste il getter, che fare? do errore?\n          // Log.eDevv(\"dev error: property exist but getter does not: \", propKey, this);\n          // console.error('proxy GET direct match', {targetObj, propKey, ret: this.d[propKey as keyof ME]});\n          // console.error('proxy GET direct match', {l:this.l});\n          return this.d[propKey];\n        case '$$typeof':\n        case \"typeName\":\n          return this.d.className;\n      }\n    }\n\n    // if not exist check for children names\n\n    if (typeof propKey === \"string\" && propKey !== \"childrens\") {\n      let lchildrens = this.get(targetObj, 'childrens', proxyitself);\n      // let dchildrens: DPointerTargetable[] = lchildrens.map<DPointerTargetable>(l => l.__raw as any);\n      let lc;\n      if (propKey[0] === \"@\") {\n        propKey = propKey.substring(1);\n        canThrowErrors = false;\n      }\n      for (lc of lchildrens) {\n        if (lc.name === propKey) return lc;\n      }\n    }\n\n    // if property do not exist, try a concatenation\n    let concatenationTentative = null;\n    try {\n      concatenationTentative = this.concatenableHandler(targetObj, propKey, proxyitself);\n    } catch (e) {}\n    if (concatenationTentative !== null) return concatenationTentative;\n    Log.ex(canThrowErrors, 'GET property \"' + propKey + '\" do not exist in object of type \"' + U.getType(this.l) + \" DType:\" + U.getType(this.l), {\n      logic: this.l,\n      data: targetObj\n    });\n    return undefined;\n    // todo: credo che con espressioni sui tipi siano tipizzabili tutti i return di proprietà note eccetto quelle ottenute per concatenazione.\n  }\n  defaultGetter(targetObj, key, proxyitself) {\n    if (!targetObj) return targetObj;\n    if (!targetObj._subMaps || !targetObj._subMaps[key]) return targetObj[key];\n    // if is a nexted subobject\n    let context = new MapLogicContext(proxyitself, targetObj, key, []);\n    let retRaw = this.lg[this.s + key];\n    return MapProxyHandler.mapWrap(targetObj[key], targetObj, this.additionalPath + '.' + key);\n  }\n  defaultSetter(targetObj, propKey, value, proxyitself) {\n    SetFieldAction.new(targetObj, propKey, value);\n    return true;\n  }\n  set(targetObj, propKey, value, proxyitself) {\n    let enableFallbackSetter = true;\n\n    // console.error('_proxy set PRE:', {targetObj, propKey, value, proxyitself, arguments});\n    // if (propKey in this.l || propKey in this.d || (this.l as GObject)[this.s + (propKey as string)] || (this.l as GObject)[(propKey as string)]) {\n    if (propKey in this.l || propKey in this.d || this.l[this.s + propKey]) {\n      // todo: il LogicContext passato come parametro risulta nell'autocompletion editor automaticamente generato, come passo un parametro senza passargli il parametro? uso arguments senza dichiararlo?\n      if (typeof propKey !== 'symbol' && this.s + propKey in this.lg) return this.lg[this.s + propKey](value, new LogicContext(proxyitself, targetObj));\n      if (enableFallbackSetter) {\n        return this.defaultSetter(targetObj, propKey, value, proxyitself);\n        // new SetFieldAction(new LogicContext(proxyitself as any, targetObj).data as any, propKey as string, value); return true;\n      }\n      // se esiste la proprietà ma non esiste il setter, che fare? do errore.\n      Log.eDevv(\"dev error: property exist but setter does not: \", propKey, this);\n      return false;\n    }\n    // if property do not exist\n    let breakpoint = 1;\n    if (enableFallbackSetter && typeof (propKey === \"string\") && (propKey[0] === '_' || propKey.indexOf('tmp') > 0)) {\n      return this.defaultSetter(targetObj, propKey, value, proxyitself);\n      // new SetFieldAction(new LogicContext(proxyitself as any, targetObj).data as any, propKey as string, value); return true;\n    }\n    Log.exx('SET property \"set_' + propKey + '\" do not exist in object of type \"' + U.getType(this.l) + \" DType:\" + U.getType(this.l), {\n      'this': this,\n      targetObj\n    });\n    return false;\n  }\n  /*      problema: ogni oggetto deve avere multipli puntatori, quando ne modifico uno devo modificarli tutti, come tengo traccia?\r\n          ipotesi 1: lo memorizzo in un solo posto (store.idlookup) e uso Pointer<type, lb, ub> che è una stringa che simula un puntatore\r\n          problema 1: se fornisco l'intero store ai componenti si aggiornano ad ogni singola modifica, se estraggo i campi interesasti le stringhe puntatore sono invariate ma il contenuto puntato è cambiato e il componente non lo sa...\r\n          problemone 2: non so a quali proprietà dello store devo abbonarmi, devo leggere sempre tutto lo store?\r\n          !!!!! soluzione 2?: dovrei dichiarare le variabili a cui mi abbono, salvarle nello stato e precaricarle tramite mapStateToProps*/\n\n  deleteProperty(target, key, proxyItself) {\n    if (typeof key === \"symbol\") return false;\n    this.set(target, key, undefined, proxyItself);\n    delete target[key];\n    return true;\n  }\n  ownKeys(target) {\n    return U.arrayMergeInPlace(Object.keys(target), Object.keys(this.l).filter(k => k.indexOf('set_') !== 0 || k.indexOf('get_') !== 0));\n  }\n\n  /*\r\n  apply(target: DModelElement, thisArg: any, argArray: any[]): any {\r\n      // will i ever use it? dovrei pasare una funzione invece di una classe, quindi in questo caso credo wrappi solo il costruttore\r\n  }*/\n}) || _class9;\nexport let MapProxyHandler = RuntimeAccessible(_class11 = class MapProxyHandler extends TargetableProxyHandler {\n  // todo: sposta alcune funzioni da TargetableProxy a MyProxy e fai estendere direttamente MyProxy a questa classe\n\n  constructor(d, baseObjInLookup) {\n    let additionalPath = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n    let subMapKeys = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    super(d, baseObjInLookup, additionalPath, LPointerTargetable.singleton);\n    this.subMapKeys = void 0;\n    this.subMapKeys = subMapKeys;\n  }\n  get(target, key, proxyitself) {\n    if (typeof key === \"symbol\") return this.d[key];\n    let val = this.d[key];\n    if (key in this.subMapKeys && !(key in target)) {\n      Log.exx('property not found in dictionary', {\n        target,\n        key,\n        thiss: this,\n        proxyitself,\n        submapkeys: this.subMapKeys\n      });\n      return undefined;\n    }\n    if (key in this.subMapKeys) {\n      this.additionalPath += '.';\n      return MapProxyHandler.mapWrap(this.d, this.baseObjInLookup, this.additionalPath, this.subMapKeys[key]);\n      Log.exDevv('todo: wrap sub-map', {\n        thiss: this\n      });\n    }\n    return target[key];\n  }\n  set(target, key, value, proxyitself) {\n    if (typeof key === \"symbol\") {\n      Log.exx('cannot set a symbol in dictionary', {\n        target,\n        key,\n        value,\n        proxyitself\n      });\n      return false;\n    }\n    SetRootFieldAction.new(this.additionalPath + '.' + key, value, '', false);\n    return true;\n  }\n  deleteProperty(target, key, proxyItself) {\n    if (typeof key === \"symbol\") return false;\n    this.set(target, key, undefined, proxyItself);\n    delete target[key];\n    return true;\n  }\n}) || _class11;\n\n// 15-20 min + 5 di domande entro il 1° ottobre, discussione 10-12 ottobre\nexport const getPath = new Proxy({}, new GetPathHandler());\nwindow.getPath = getPath;\n// usage: pathstring = ((getPath as DType).some.path.to.follow as any).$; // = \"some.path.to.follow\" with compilation-time validation","map":{"version":3,"names":["DPointerTargetable","JsType","Log","LPointerTargetable","RuntimeAccessible","RuntimeAccessibleClass","SetFieldAction","SetRootFieldAction","U","LogicContext","_class","constructor","proxyObject","data","write","className","name","MapLogicContext","_class3","proxy","path","subMaps","arguments","length","undefined","MyProxyHandler","_class5","s","g","set","target","p","value","proxyitself","Error","deleteProperty","ownKeys","Object","getOwnPropertyNames","wrap","baseObjInLookup","canThrow","isProxy","__isProxy","GetPathHandler","_class7","_class8","strbuilder","array","calls","get","targetObj","propKey","ret","__asCalls","__asArray","push","Symbol","toPrimitive","console","log","_len","a","Array","_key","toString","__nested","TargetableProxyHandler","_class9","d","additionalPath","l","lg","_RuntimeAccessibleCla","_RuntimeAccessibleCla2","logic","singleton","exDev","object","concatenableHandler","propKeyStr","asString","_index","indexOf","isConcatenable","split","map","subKey","val","isPrimitive","join","isError","get0","e","canThrowErrors","String","exDevv","JSON","stringify","Math","random","clonedCounter","proxyacceptables","typeName","$$typeof","getterMethod","defaultGetter","lchildrens","lc","substring","concatenationTentative","ex","getType","key","_subMaps","context","retRaw","MapProxyHandler","mapWrap","defaultSetter","new","enableFallbackSetter","eDevv","breakpoint","exx","proxyItself","arrayMergeInPlace","keys","filter","k","_class11","subMapKeys","thiss","submapkeys","getPath","Proxy","window"],"sources":["C:/0Programmi/Dev/projects/frontend/jjodel/src/joiner/proxy.ts"],"sourcesContent":["import type {DocString, DtoL, DtoW, GObject, Proxyfied, WPointerTargetable,} from \"../joiner\";\r\nimport {\r\n    Dictionary,\r\n    DModelElement,\r\n    DPointerTargetable,\r\n    JsType,\r\n    LModelElement,\r\n    Log,\r\n    LPointerTargetable,\r\n    Pointer,\r\n    RuntimeAccessible,\r\n    RuntimeAccessibleClass,\r\n    SetFieldAction,\r\n    SetRootFieldAction,\r\n    U\r\n} from \"../joiner\";\r\n\r\ntype NotAConcatenation = null;\r\ntype ERROR = \"_Type_Error_\";\r\n\r\n// (DX extends DUser ? LUser : (DX extends DPointerTargetable ? LPointerTargetable : (ERROR))\r\n// (DX extends DUser ? LUser : (DX extends DPointerTargetable ? LPointerTargetable : (           WViewElement\r\n//\r\n// (IN extends WViewElement ? LViewElement : (IN extends WViewTransientProperties ? LWiewTransientProperties : (ERROR)))\r\n// ))\r\n// type WtoL<WX extends WPointerTargetable> ='';\r\n\r\n@RuntimeAccessible\r\nexport class LogicContext<\r\n    DX extends GObject = DModelElement,\r\n    LX = DtoL<DX>,\r\n    // PF extends MyProxyHandler<DX> = MyProxyHandler<DX>,\r\n    WX = DtoW<DX>\r\n    > extends RuntimeAccessibleClass{\r\n    // public proxyfyFunction: PF;\r\n    public proxyObject: LX;\r\n    public data: DX;// & GObject;\r\n    public write: WX;\r\n    constructor(proxyObject: LX, data: DX) {\r\n        super();\r\n        this.className = this.constructor.name;\r\n        this.data = data;\r\n        this.proxyObject = proxyObject;\r\n        this.write = proxyObject as any;\r\n    }\r\n    /*\r\n        saveToRedux(propkey: \"keyof data\" | string, val: \"typeof data[path]\" | any): void { // todo: ask non stackoverflow\r\n            // todo, put data in redux store, path is \"obj1.obj2.obj3...\" might replace it with a path funciton that return the foremost nested object container\r\n            if (!propkey) {\r\n                // todo: set whole object instead of a property\r\n            }\r\n        }*/\r\n}\r\n\r\n@RuntimeAccessible\r\nexport class MapLogicContext extends LogicContext<GObject, LPointerTargetable, WPointerTargetable> {\r\n    data: GObject;\r\n    path: string;\r\n    subMaps: string[];\r\n    constructor(proxy: LPointerTargetable, data: GObject, path: string, subMaps: string[] = []) {\r\n        super(proxy, data);\r\n        // this.proxyfyFunction = proxyfyFunction;\r\n        this.proxyObject = proxy;\r\n        this.data = data;\r\n        this.path = path;\r\n        this.subMaps = subMaps;\r\n        this.className = this.constructor.name;\r\n    }\r\n}\r\n\r\n@RuntimeAccessible\r\nexport abstract class MyProxyHandler<T extends GObject> extends RuntimeAccessibleClass implements ProxyHandler<T>{\r\n    s: string = 'set_';\r\n    g: string = 'get_';\r\n    /*get(target: T, p: string | number | symbol, proxyitself: Proxyfied<T>): boolean {\r\n        switch (p) {\r\n            case '_isProxy': return true;\r\n            case 'init': return (this as any).init;\r\n            case 'init0': return (this as any).init0;\r\n            default: throw new Error('proxy get must be overridden, called for key: ' + (p as string));\r\n        }}*/\r\n    set(target: T, p: string | number | symbol, value: any, proxyitself: Proxyfied<T>): boolean { throw new Error('proxy set must be overridden'); }\r\n    deleteProperty(target: T, p: string | symbol): boolean { throw new Error('proxy delete must be overridden'); }\r\n\r\n    ownKeys(target: T): ArrayLike<string | symbol>{ return Object.getOwnPropertyNames(target); }\r\n    static wrap<D extends RuntimeAccessibleClass, L extends LPointerTargetable = LPointerTargetable, CAN_THROW extends boolean = false,\r\n        RET extends CAN_THROW extends true ? L : L | undefined  = CAN_THROW extends true ? L : L>\r\n    (data: D | Pointer | undefined, baseObjInLookup?: DPointerTargetable, path: string = '', canThrow: CAN_THROW = false as CAN_THROW): RET{\r\n\r\n//    static wrap<D extends RuntimeAccessibleClass, L extends LPointerTargetable, RET extends boolean = false>\r\n//        (data: D | Pointer<DViewElement>, baseObjInLookup?: DPointerTargetable, path: string = '', canthrow: RET = false as RET): RET {\r\n        return DPointerTargetable.wrap(data, baseObjInLookup, path) as RET; }\r\n\r\n    static isProxy(data: GObject): boolean { return data?.__isProxy || false; }\r\n}\r\n\r\nexport type GetPath<T = GObject> = T;\r\n/*\r\n* handling proxy += and proxy -=\r\n*\r\n* will become var = var + add; which will call Symbol.getPrimitive\r\nconsole.log(+obj2);     // 10        — hint is \"number\"         NaN with +array with multiple vals, +array[0] with array of size 1, NaN with functions & objects\r\nconsole.log(`${obj2}`); // \"hello\"   — hint is \"string\"         array => array.join(','), object => \"[object Object]\", function => function.toString() whole func definition with body code\r\nconsole.log(obj2 + \"\"); // \"true\"    — hint is \"default\"        array, object, function => same as with hint \"string\"\r\n*\r\n* */\r\n\r\n// NB: lclass.extends += somepointer will become: lclass.extends = lclass.extends + somepointer;\r\n// array + string will cause getPrimitive(\"default\") to array, then .join(',') on it, and finally and toString() to be called on all array members.\r\n// so pointers cannot include \",\" char and toString() must return a pointer to keep lclass.extends += somepointer as a valid expression;\r\n// -= will call getPrimitive(\"number\") which will result in array -> NaN, so NaN = NaN - pointer and cannot be done.\r\n\r\n@RuntimeAccessible\r\nclass GetPathHandler<T extends GObject> extends MyProxyHandler<T>{\r\n    strbuilder: string = '';\r\n    array: (string | number | symbol)[] = [];\r\n    calls: (GObject<'parameters of get calls'>)[] = [];\r\n    public static __asCalls: boolean = false;\r\n    public static __asArray: boolean = false;\r\n    public static __nested: boolean = true;\r\n\r\n    public constructor() { super(); }\r\n\r\n    get(targetObj: T, propKey: keyof T | string, proxyitself: Proxyfied<T>): any {\r\n        // console.log('GetPathHandler', {targetObj, propKey, proxyitself});\r\n        if (propKey === \"start\") { this.strbuilder = ''; this.array = []; }\r\n        if (propKey === '$') {\r\n            const ret = GetPathHandler.__asCalls ? this.calls : (GetPathHandler.__asArray ? this.array : this.strbuilder);\r\n            this.array = [];\r\n            this.strbuilder = '';\r\n            return ret; }\r\n        this.array.push(propKey);\r\n        this.calls.push(arguments);\r\n        if (propKey === Symbol.toPrimitive) {\r\n            console.log(\"toprimitive\");\r\n            return (...a: any)=> {console.log(\"toprimitive called with parameters\", a); }\r\n        }\r\n        if (!GetPathHandler.__asArray && !GetPathHandler.__asCalls) {\r\n            if (typeof propKey === \"symbol\") { this.strbuilder += propKey.toString(); }\r\n            else {\r\n                // Giordano: add ignore for webpack\r\n                //@ts-ignore\r\n                this.strbuilder += (this.strbuilder ? '.' : '') + propKey;\r\n            }\r\n        }\r\n        return GetPathHandler.__nested ? proxyitself : {};\r\n    }\r\n\r\n    set(target: T, p: string | number | symbol, value: any, proxyitself: Proxyfied<T>): boolean {\r\n        switch(p){\r\n            case '__asArray':\r\n            case '__asCalls':\r\n            case '__nested':\r\n                (GetPathHandler as any)[p] = value;\r\n                return true;\r\n            default:\r\n                throw new Error('getPath proxy cannot be written');\r\n        }\r\n    }\r\n}\r\n\r\n\r\n@RuntimeAccessible\r\nexport class TargetableProxyHandler<ME extends GObject = DModelElement, LE extends LPointerTargetable = LModelElement> extends MyProxyHandler<ME> {\r\n// permette di fare cose tipo: user.name_surname che ritorna la concatenazione di nome e cognome anche se il campo name_surname non esiste.\r\n    lg: LE & GObject; // to disable type check easily and access 'set_' + varname dynamically\r\n    l: LE;\r\n    d: ME;\r\n    additionalPath: string;\r\n\r\n    public baseObjInLookup: DPointerTargetable;\r\n\r\n    constructor(d: ME, baseObjInLookup?: DPointerTargetable, additionalPath: string = '', l?: LE) {\r\n        super();\r\n        this.d = d;\r\n        if (!l) {\r\n            l = RuntimeAccessibleClass.get(d.className)?.logic?.singleton as LE;\r\n            Log.exDev(!l, 'Trying to wrap class without singleton or logic mapped', { object: d })\r\n        }\r\n        this.baseObjInLookup = baseObjInLookup || d as any;\r\n        this.additionalPath = additionalPath;\r\n        this.l = l as LE;\r\n        this.lg = this.l;\r\n        this.className = this.constructor.name;\r\n    }\r\n\r\n    // damiano todo: this does not work\r\n    private concatenableHandler(targetObj: ME, propKey: number | string | symbol, proxyitself: Proxyfied<ME>): NotAConcatenation | any[] | string {\r\n        console.log(\"concatenableHandler 1\", {targetObj, propKey, proxyitself});\r\n        if (propKey in targetObj)  return null as NotAConcatenation;\r\n        const propKeyStr: null | string = U.asString(propKey, null);\r\n        let _index: number = propKeyStr ? propKeyStr.indexOf('_') : -1;\r\n        console.log(\"concatenableHandler 2\", {targetObj, propKey, propKeyStr, proxyitself, _index});\r\n        if (_index < 0) return null as NotAConcatenation;\r\n\r\n        let isConcatenable = true;\r\n        let ret: any[] = (propKey as string).split('_').map( (subKey: string) => {\r\n            console.log(\"concatenableHandler 3.0\", {targetObj, subKey, propKeyStr, proxyitself});\r\n            // se trovo multipli ___ li tratto come spazi aggiuntivi invece che come proprietà '' che ritornano undefined, così posso fare name___surname --> \"damiano   di vincenzo\"\r\n            let val: any = subKey === '' ? ' ' : this.get(targetObj, subKey, proxyitself);\r\n            console.log(\"concatenableHandler 3.1\", {targetObj, subKey, val, propKeyStr, proxyitself, isConcatenable});\r\n            isConcatenable = isConcatenable && JsType.isPrimitive(val);\r\n            console.log(\"concatenableHandler 3.2\", {targetObj, subKey, val, propKeyStr, proxyitself, isConcatenable});\r\n            return val;\r\n        });\r\n        console.log(\"concatenableHandler 4\", {targetObj, propKey, propKeyStr, proxyitself, ret, isConcatenable});\r\n        return isConcatenable ? ret.join(' ') : ret; }\r\n\r\n    public get(targetObj: ME, propKey: string | symbol, proxyitself: Proxyfied<ME>): any {\r\n        let ret;\r\n        let isError = false;\r\n        // console.error('_proxy get PRE:', {targetObj, propKey, proxyitself, arguments});\r\n        try { ret = this.get0(targetObj, propKey, proxyitself); } catch(e) { ret = e; isError = true;}\r\n\r\n        // if (isError) throw ret;\r\n        // console.error('_proxy get POST:', {targetObj, propKey, ret, isError});\r\n        return ret;\r\n    }\r\n\r\n    public get0(targetObj: ME, propKey: string | symbol, proxyitself: Proxyfied<ME>): any {\r\n        // console.log('proxy keysearch', {propKey, targetObj, l: this.l, proxyitself, d: this.d});\r\n        let canThrowErrors = true;\r\n        if (propKey === \"__raw\") return targetObj;\r\n\r\n        if (typeof propKey === \"symbol\") {\r\n            switch(String(propKey)){\r\n                default: Log.exDevv('unexpected symbol:', propKey); break;\r\n                case \"Symbol(Symbol.toPrimitive)\": return (targetObj as any)[propKey];//  || typeof targetObj;\r\n            }\r\n        }\r\n//\r\n        switch(propKey){\r\n            case '__raw': return targetObj;\r\n            case '__serialize': return JSON.stringify(targetObj);\r\n            case '__isProxy': return true;\r\n            case '__random': return Math.random();\r\n            case 'editCount':\r\n            case 'clonedCounter':\r\n                return targetObj.clonedCounter || 0;\r\n        }\r\n\r\n\r\n        const proxyacceptables = {typeName:'', $$typeof:''};\r\n        // check if exist directly in D.key, L.key or through a get_key\r\n        if (propKey in this.l || propKey in this.d || (this.l as GObject)[this.g + (propKey as string)] || propKey in proxyacceptables) {\r\n            // todo: il LogicContext passato come parametro risulta nell'autocompletion editor automaticamente generato, come passo un parametro senza passargli il parametro? uso arguments senza dichiararlo?\r\n            if (typeof propKey !== 'symbol' && this.g + propKey in this.lg) return this.lg[this.g + propKey](new LogicContext(proxyitself as any, targetObj));\r\n\r\n\r\n\r\n            if (typeof propKey !== 'symbol' && this.g + propKey in this.lg) {\r\n                let getterMethod: Function = this.lg[this.g + propKey]; // || this.defaultGetter;\r\n                return getterMethod ? getterMethod(new LogicContext(proxyitself as any, targetObj)) : this.defaultGetter(targetObj, propKey, proxyitself);\r\n\r\n            }\r\n\r\n\r\n            switch (propKey){\r\n                default:\r\n                    //constructor.prototype.typeName\r\n                    // se esiste la proprietà ma non esiste il getter, che fare? do errore?\r\n                    // Log.eDevv(\"dev error: property exist but getter does not: \", propKey, this);\r\n                    // console.error('proxy GET direct match', {targetObj, propKey, ret: this.d[propKey as keyof ME]});\r\n                    // console.error('proxy GET direct match', {l:this.l});\r\n                    return this.d[propKey as keyof ME];\r\n                case '$$typeof':\r\n                case \"typeName\":\r\n                    return this.d.className;\r\n            }\r\n        }\r\n\r\n        // if not exist check for children names\r\n\r\n        if (typeof propKey === \"string\" && propKey !== \"childrens\") {\r\n            let lchildrens: LPointerTargetable[] = this.get(targetObj, 'childrens', proxyitself);\r\n            // let dchildrens: DPointerTargetable[] = lchildrens.map<DPointerTargetable>(l => l.__raw as any);\r\n            let lc: GObject;\r\n            if (propKey[0] === \"@\") { propKey = propKey.substring(1); canThrowErrors = false; }\r\n            for (lc of lchildrens) {\r\n                if (lc.name === propKey) return lc;\r\n            }\r\n        }\r\n\r\n        // if property do not exist, try a concatenation\r\n        let concatenationTentative = null;\r\n        try {concatenationTentative = this.concatenableHandler(targetObj, propKey, proxyitself); } catch(e) {}\r\n        if (concatenationTentative !== null) return concatenationTentative;\r\n        Log.ex(canThrowErrors,'GET property \"'+ (propKey as any)+ '\" do not exist in object of type \"' + U.getType(this.l) + \" DType:\" +  U.getType(this.l), {logic: this.l, data: targetObj});\r\n        return undefined;\r\n        // todo: credo che con espressioni sui tipi siano tipizzabili tutti i return di proprietà note eccetto quelle ottenute per concatenazione.\r\n    }\r\n\r\n    public defaultGetter(targetObj: ME, key: string, proxyitself: Proxyfied<ME>): any {\r\n        if (!targetObj) return targetObj;\r\n        if (!targetObj._subMaps || !targetObj._subMaps[key]) return (targetObj as Dictionary)[key];\r\n        // if is a nexted subobject\r\n        let context: MapLogicContext = new MapLogicContext(proxyitself as any, targetObj, key, []);\r\n        let retRaw: Dictionary = this.lg[this.s + key]\r\n        return MapProxyHandler.mapWrap((targetObj as Dictionary)[key], targetObj as any, this.additionalPath + '.' + key)\r\n    }\r\n\r\n    public defaultSetter(targetObj: DPointerTargetable, propKey: string, value: any, proxyitself?: Proxyfied<ME>): boolean {\r\n        SetFieldAction.new(targetObj, propKey as any, value);\r\n        return true;\r\n    }\r\n\r\n    public set(targetObj: ME, propKey: string | symbol, value: any, proxyitself?: Proxyfied<ME>): boolean {\r\n        let enableFallbackSetter = true;\r\n\r\n        // console.error('_proxy set PRE:', {targetObj, propKey, value, proxyitself, arguments});\r\n        // if (propKey in this.l || propKey in this.d || (this.l as GObject)[this.s + (propKey as string)] || (this.l as GObject)[(propKey as string)]) {\r\n        if (propKey in this.l || propKey in this.d || (this.l as GObject)[this.s + (propKey as string)]) {\r\n            // todo: il LogicContext passato come parametro risulta nell'autocompletion editor automaticamente generato, come passo un parametro senza passargli il parametro? uso arguments senza dichiararlo?\r\n            if (typeof propKey !== 'symbol' && this.s + propKey in this.lg) return this.lg[this.s + propKey](value, new LogicContext(proxyitself as any, targetObj));\r\n\r\n\r\n            if (enableFallbackSetter) {\r\n                return this.defaultSetter(targetObj as any as DPointerTargetable, propKey as string, value, proxyitself);\r\n                // new SetFieldAction(new LogicContext(proxyitself as any, targetObj).data as any, propKey as string, value); return true;\r\n            }\r\n            // se esiste la proprietà ma non esiste il setter, che fare? do errore.\r\n            Log.eDevv(\"dev error: property exist but setter does not: \", propKey, this);\r\n            return false;\r\n        }\r\n        // if property do not exist\r\n        let breakpoint = 1;\r\n\r\n        if (enableFallbackSetter && typeof (propKey === \"string\") && ((propKey as string)[0] === '_' || (propKey as string).indexOf('tmp') > 0)) {\r\n            return this.defaultSetter(targetObj as any as DPointerTargetable, propKey as string, value, proxyitself);\r\n            // new SetFieldAction(new LogicContext(proxyitself as any, targetObj).data as any, propKey as string, value); return true;\r\n        }\r\n        Log.exx('SET property \"set_' + (propKey as any) + '\" do not exist in object of type \"' + U.getType(this.l) + \" DType:\" +  U.getType(this.l), {'this': this, targetObj});\r\n        return false; }\r\n    /*      problema: ogni oggetto deve avere multipli puntatori, quando ne modifico uno devo modificarli tutti, come tengo traccia?\r\n            ipotesi 1: lo memorizzo in un solo posto (store.idlookup) e uso Pointer<type, lb, ub> che è una stringa che simula un puntatore\r\n            problema 1: se fornisco l'intero store ai componenti si aggiornano ad ogni singola modifica, se estraggo i campi interesasti le stringhe puntatore sono invariate ma il contenuto puntato è cambiato e il componente non lo sa...\r\n            problemone 2: non so a quali proprietà dello store devo abbonarmi, devo leggere sempre tutto lo store?\r\n            !!!!! soluzione 2?: dovrei dichiarare le variabili a cui mi abbono, salvarle nello stato e precaricarle tramite mapStateToProps*/\r\n\r\n    public deleteProperty(target: ME, key: string | symbol, proxyItself?: Proxyfied<any>): boolean {\r\n        if (typeof key === \"symbol\") return false;\r\n        this.set(target, key, undefined, proxyItself);\r\n        delete target[key];\r\n        return true; }\r\n\r\n    ownKeys(target: ME): ArrayLike<string | symbol>{\r\n        return U.arrayMergeInPlace(Object.keys(target), Object.keys(this.l).filter(k => k.indexOf('set_') !== 0 || k.indexOf('get_') !== 0));\r\n    }\r\n\r\n    /*\r\n    apply(target: DModelElement, thisArg: any, argArray: any[]): any {\r\n        // will i ever use it? dovrei pasare una funzione invece di una classe, quindi in questo caso credo wrappi solo il costruttore\r\n    }*/\r\n}\r\n\r\n@RuntimeAccessible\r\nexport class MapProxyHandler extends TargetableProxyHandler<Dictionary, LPointerTargetable> {\r\n    // todo: sposta alcune funzioni da TargetableProxy a MyProxy e fai estendere direttamente MyProxy a questa classe\r\n    public subMapKeys: Dictionary<string, any | Dictionary<DocString<'nested map keys'>>>;\r\n\r\n    constructor(d: Dictionary, baseObjInLookup: DPointerTargetable, additionalPath: string = '', subMapKeys: Dictionary<string, any | Dictionary<DocString<'nested map keys'>>> = {}) {\r\n        super(d, baseObjInLookup, additionalPath, LPointerTargetable.singleton);\r\n        this.subMapKeys = subMapKeys;\r\n    }\r\n\r\n    get(target: Dictionary, key: string | number | symbol, proxyitself: Proxyfied<Dictionary>): any {\r\n        if (typeof key === \"symbol\") return this.d[key as any];\r\n        let val: any = this.d[key];\r\n        if (key in this.subMapKeys && !(key in target)) { Log.exx('property not found in dictionary', {target, key, thiss:this, proxyitself, submapkeys: this.subMapKeys}); return undefined; }\r\n        if (key in this.subMapKeys) {\r\n            this.additionalPath += '.';\r\n            return MapProxyHandler.mapWrap( this.d, this.baseObjInLookup, this.additionalPath, this.subMapKeys[key]);\r\n            Log.exDevv('todo: wrap sub-map', {thiss: this});\r\n        }\r\n        return target[key as string]; }\r\n\r\n    set(target: Dictionary, key: string | number | symbol, value: any, proxyitself: Proxyfied<Dictionary>): boolean {\r\n        if (typeof key === \"symbol\") { Log.exx('cannot set a symbol in dictionary', {target, key, value, proxyitself}); return false; }\r\n        SetRootFieldAction.new(this.additionalPath + '.' + key, value, '',false)\r\n        return true;\r\n    }\r\n\r\n    public deleteProperty(target: Dictionary, key: string | symbol, proxyItself?: Proxyfied<any>): boolean {\r\n        if (typeof key === \"symbol\") return false;\r\n        this.set(target, key, undefined, proxyItself);\r\n        delete target[key];\r\n        return true; }\r\n}\r\n\r\n\r\n\r\n// 15-20 min + 5 di domande entro il 1° ottobre, discussione 10-12 ottobre\r\nexport const getPath: GetPath = new Proxy( {}, new GetPathHandler());\r\n(window as any).getPath = getPath;\r\n// usage: pathstring = ((getPath as DType).some.path.to.follow as any).$; // = \"some.path.to.follow\" with compilation-time validation\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}