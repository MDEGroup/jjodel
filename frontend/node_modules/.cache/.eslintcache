[{"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\index.tsx":"1","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\App.tsx":"2","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\joiner\\index.ts":"3","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\alert\\Alert.tsx":"4","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\loader\\Loader.tsx":"5","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\pathChecker\\PathChecker.tsx":"6","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\forEndUser\\ExternalLibraries.tsx":"7","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\forEndUser\\Tooltip.tsx":"8","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\common\\libraries\\prj_json2xml.js":"9","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\common\\libraries\\prj_xml2json.js":"10","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\joiner\\classes.ts":"11","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\joiner\\types.ts":"12","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\joiner\\proxy.ts":"13","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\redux\\reducer\\reducer.ts":"14","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\joiner\\ExecuteOnRead.ts":"15","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\common\\UObj.ts":"16","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\common\\Log.ts":"17","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\common\\Defaults.ts":"18","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\common\\Geom.ts":"19","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\common\\Uhtml.ts":"20","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\api\\data.ts":"21","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\redux\\createStore.ts":"22","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\redux\\action\\action.ts":"23","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\redux\\selectors\\selectors.ts":"24","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\common\\U.tsx":"25","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\common\\DV.tsx":"26","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\redux\\store.tsx":"27","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\model\\classes\\L.ts":"28","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\model\\classes\\D.ts":"29","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\view\\viewPoint\\viewpoint.ts":"30","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\graph\\graphElement\\GraphDragHandler.ts":"31","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\joiner\\components.tsx":"32","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\pages\\index.ts":"33","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\pages\\components\\index.ts":"34","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\common\\UX.tsx":"35","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\model\\logicWrapper\\LModelElement.tsx":"36","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\debugtools\\debug.tsx":"37","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\ocl\\ocl.tsx":"38","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\model\\dataStructure\\GraphDataElements.tsx":"39","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\view\\viewElement\\view.tsx":"40","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\graph\\graphElement\\sharedTypes\\sharedTypes.tsx":"41","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\common\\Dummy.ts":"42","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\data\\storage.ts":"43","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\common\\SimpleTree.ts":"44","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\collaborative\\Collaborative.ts":"45","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\DSL\\DSL.ts":"46","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\iot\\IoT.ts":"47","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\redux\\defaults\\views.ts":"48","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\graph\\graphElement\\graphElement.tsx":"49","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\forEndUser\\Input.tsx":"50","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\forEndUser\\Selector.tsx":"51","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\pages\\Account.tsx":"52","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\pages\\AllProjects.tsx":"53","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\pages\\Auth.tsx":"54","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\pages\\Project.tsx":"55","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\pages\\Updates.tsx":"56","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\pages\\components\\Dashboard.tsx":"57","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\pages\\components\\LeftBar.tsx":"58","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\pages\\components\\Project.tsx":"59","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\pages\\components\\Navbar.tsx":"60","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\pages\\components\\BottomBar.tsx":"61","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\forEndUser\\Aliases.tsx":"62","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\forEndUser\\GenericInput.tsx":"63","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\forEndUser\\Try.tsx":"64","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\forEndUser\\ControlPanel.tsx":"65","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\forEndUser\\Overlap.tsx":"66","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\forEndUser\\Control.tsx":"67","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\pages\\Archive.tsx":"68","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\forEndUser\\Measurable.tsx":"69","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\pages\\Community.tsx":"70","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\pages\\Profile.tsx":"71","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\pages\\Settings.tsx":"72","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\pages\\Notes.tsx":"73","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\pages\\Recent.tsx":"74","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\pages\\Error.tsx":"75","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\pages\\Templates.tsx":"76","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\pages\\News.tsx":"77","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\pages\\UsersInfo.tsx":"78","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\pages\\ProjectsInfo.tsx":"79","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\graph\\vertex\\Vertex.tsx":"80","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\graph\\damedges\\damedge.tsx":"81","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\graph\\vertex\\Shapes.tsx":"82","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\graph\\defaultNode\\DefaultNode.tsx":"83","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\graph\\graph\\graphContainer.tsx":"84","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\logger\\DataOutput.tsx":"85","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\logger\\loggerComponent.tsx":"86","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\api\\persistance\\index.ts":"87","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\forEndUser\\SizeInput.tsx":"88","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\pages\\components\\cards\\Cards.tsx":"89","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\pages\\components\\menu\\Menu.tsx":"90","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\pages\\components\\catalog\\Catalog.tsx":"91","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\abstract\\DockManager.ts":"92","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\pages\\components\\about\\About.tsx":"93","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\topbar\\undoredocomponent.tsx":"94","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\api\\persistance\\admin.ts":"95","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\abstract\\tabs\\TabDataMaker.tsx":"96","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\editors\\languages\\index.ts":"97","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\api\\persistance\\projects.ts":"98","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\api\\persistance\\users.ts":"99","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\api\\persistance\\auth.ts":"100","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\topbar\\SaveManager.ts":"101","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\abstract\\Dock.tsx":"102","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\hooks\\useQuery.ts":"103","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\pages\\components\\popups\\index.ts":"104","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\commandbar\\CommandBar.tsx":"105","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\pages\\components\\icons\\Icons.tsx":"106","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\collaborative\\CollaborativeAttacher.tsx":"107","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\pages\\components\\LatestUpdates.tsx":"108","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\pages\\components\\Edit\\Edit.tsx":"109","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\data\\api.ts":"110","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\abstract\\tabs\\MetamodelTab.tsx":"111","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\abstract\\tabs\\ModelTab.tsx":"112","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\editors\\languages\\Ocl.tsx":"113","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\editors\\languages\\Jsx.tsx":"114","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\editors\\languages\\Js.tsx":"115","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\editors\\PermissionModelTab.tsx":"116","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\pages\\components\\popups\\Model.tsx":"117","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\pages\\components\\popups\\Metamodel.tsx":"118","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\abstract\\tabs\\ModelsSummaryTab.tsx":"119","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\editors\\Broker.tsx":"120","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\editors\\NodeEditor.tsx":"121","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\dock\\MyRcDock.tsx":"122","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\metrics\\Metrics.tsx":"123","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\contextMenu\\ContextMenu.tsx":"124","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\toolbar\\ToolBar.tsx":"125","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\editors\\languages\\Javascript.tsx":"126","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\editors\\index.ts":"127","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\editors\\Empty.tsx":"128","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\dock\\MyDock.tsx":"129","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\forEndUser\\ModellingIcon.tsx":"130","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\model\\logicWrapper\\index.ts":"131","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\editors\\Collaborative.tsx":"132","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\editors\\views\\NestedView.tsx":"133","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\editors\\MetaData.tsx":"134","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\editors\\Info.tsx":"135","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\editors\\Logger.tsx":"136","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\editors\\Settings.tsx":"137","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\editors\\Console.tsx":"138","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\editors\\Skeleton.tsx":"139","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\api\\memorec\\index.ts":"140","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\editors\\views\\ViewData.tsx":"141","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\forEndUser\\Tree.tsx":"142","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\editors\\views\\data\\ComponentsTab.tsx":"143","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\editors\\views\\data\\PermissionViewpointTab.tsx":"144","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\editors\\views\\data\\PermissionViewTab.tsx":"145","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\editors\\views\\data\\PaletteData.tsx":"146","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\editors\\views\\data\\GenericNodeData.tsx":"147","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\editors\\views\\data\\CustomData.tsx":"148","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\editors\\views\\data\\TemplateData.tsx":"149","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\editors\\views\\data\\InfoData.tsx":"150","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\tooltip\\MyTooltip.tsx":"151","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\forEndUser\\Color.tsx":"152","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\editors\\views\\data\\EdgePointData.tsx":"153","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\editors\\views\\data\\EdgeData.tsx":"154","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\editors\\views\\data\\FieldData.tsx":"155","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\editors\\views\\data\\GraphData.tsx":"156","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\forEndUser\\FunctionComponent.tsx":"157","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\editors\\views\\data\\NodeData.tsx":"158","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\widgets\\Widgets.tsx":"159","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\alert\\Dialog.tsx":"160","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\logo.tsx":"161","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\common\\libraries\\projectModified.ts":"162","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\editors\\MTM.tsx":"163","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\redux\\VersionFixer.tsx":"164","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\forEndUser\\MTM.tsx":"165"},{"size":725,"mtime":1738290096843,"results":"166","hashOfConfig":"167"},{"size":6723,"mtime":1741744097120,"results":"168","hashOfConfig":"167"},{"size":12022,"mtime":1743115990523,"results":"169","hashOfConfig":"167"},{"size":2667,"mtime":1739235522320,"results":"170","hashOfConfig":"167"},{"size":583,"mtime":1738290096680,"results":"171","hashOfConfig":"167"},{"size":520,"mtime":1738290096701,"results":"172","hashOfConfig":"167"},{"size":822,"mtime":1741490917141,"results":"173","hashOfConfig":"167"},{"size":11289,"mtime":1741490626461,"results":"174","hashOfConfig":"167"},{"size":1524,"mtime":1738290096552,"results":"175","hashOfConfig":"167"},{"size":6369,"mtime":1738290096554,"results":"176","hashOfConfig":"167"},{"size":190698,"mtime":1743115895858,"results":"177","hashOfConfig":"167"},{"size":10343,"mtime":1742929587746,"results":"178","hashOfConfig":"167"},{"size":23839,"mtime":1742929587744,"results":"179","hashOfConfig":"167"},{"size":68442,"mtime":1743130669811,"results":"180","hashOfConfig":"167"},{"size":4961,"mtime":1739235522429,"results":"181","hashOfConfig":"167"},{"size":9575,"mtime":1742929587714,"results":"182","hashOfConfig":"167"},{"size":10071,"mtime":1741827759173,"results":"183","hashOfConfig":"167"},{"size":1670,"mtime":1738290096531,"results":"184","hashOfConfig":"167"},{"size":57748,"mtime":1742929587705,"results":"185","hashOfConfig":"167"},{"size":1234,"mtime":1738290096544,"results":"186","hashOfConfig":"167"},{"size":62293,"mtime":1741531970871,"results":"187","hashOfConfig":"167"},{"size":357,"mtime":1738290096950,"results":"188","hashOfConfig":"167"},{"size":32197,"mtime":1742929587771,"results":"189","hashOfConfig":"167"},{"size":41587,"mtime":1743116026651,"results":"190","hashOfConfig":"167"},{"size":148454,"mtime":1742929587710,"results":"191","hashOfConfig":"167"},{"size":32386,"mtime":1742929587695,"results":"192","hashOfConfig":"167"},{"size":21060,"mtime":1742929587782,"results":"193","hashOfConfig":"167"},{"size":341,"mtime":1738290096864,"results":"194","hashOfConfig":"167"},{"size":514,"mtime":1738290096863,"results":"195","hashOfConfig":"167"},{"size":2365,"mtime":1738290097087,"results":"196","hashOfConfig":"167"},{"size":1505,"mtime":1738290096821,"results":"197","hashOfConfig":"167"},{"size":4631,"mtime":1743127909361,"results":"198","hashOfConfig":"167"},{"size":653,"mtime":1738290096944,"results":"199","hashOfConfig":"167"},{"size":186,"mtime":1738290096931,"results":"200","hashOfConfig":"167"},{"size":25678,"mtime":1741829112163,"results":"201","hashOfConfig":"167"},{"size":355219,"mtime":1743130854523,"results":"202","hashOfConfig":"167"},{"size":8477,"mtime":1738290096717,"results":"203","hashOfConfig":"167"},{"size":10417,"mtime":1741873320091,"results":"204","hashOfConfig":"167"},{"size":162187,"mtime":1742929587751,"results":"205","hashOfConfig":"167"},{"size":86585,"mtime":1743118347262,"results":"206","hashOfConfig":"167"},{"size":9569,"mtime":1741743750555,"results":"207","hashOfConfig":"167"},{"size":10931,"mtime":1742929587699,"results":"208","hashOfConfig":"167"},{"size":886,"mtime":1739235522414,"results":"209","hashOfConfig":"167"},{"size":5395,"mtime":1738290096538,"results":"210","hashOfConfig":"167"},{"size":292,"mtime":1738290096570,"results":"211","hashOfConfig":"167"},{"size":2011,"mtime":1738290096520,"results":"212","hashOfConfig":"167"},{"size":173,"mtime":1738290096845,"results":"213","hashOfConfig":"167"},{"size":25370,"mtime":1743131932587,"results":"214","hashOfConfig":"167"},{"size":78361,"mtime":1743130854557,"results":"215","hashOfConfig":"167"},{"size":25597,"mtime":1743120224002,"results":"216","hashOfConfig":"167"},{"size":7815,"mtime":1739235522361,"results":"217","hashOfConfig":"167"},{"size":9651,"mtime":1739235522591,"results":"218","hashOfConfig":"167"},{"size":5224,"mtime":1740619196662,"results":"219","hashOfConfig":"167"},{"size":31683,"mtime":1739800898768,"results":"220","hashOfConfig":"167"},{"size":5812,"mtime":1740712786332,"results":"221","hashOfConfig":"167"},{"size":9772,"mtime":1739235522610,"results":"222","hashOfConfig":"167"},{"size":20298,"mtime":1742929587763,"results":"223","hashOfConfig":"167"},{"size":9554,"mtime":1739235522623,"results":"224","hashOfConfig":"167"},{"size":11059,"mtime":1739235522629,"results":"225","hashOfConfig":"167"},{"size":29294,"mtime":1741491134451,"results":"226","hashOfConfig":"167"},{"size":3290,"mtime":1739235522614,"results":"227","hashOfConfig":"167"},{"size":595,"mtime":1743000386706,"results":"228","hashOfConfig":"167"},{"size":13671,"mtime":1741875618642,"results":"229","hashOfConfig":"167"},{"size":9890,"mtime":1738290096668,"results":"230","hashOfConfig":"167"},{"size":810,"mtime":1738290096639,"results":"231","hashOfConfig":"167"},{"size":2707,"mtime":1738290096653,"results":"232","hashOfConfig":"167"},{"size":8290,"mtime":1738290096639,"results":"233","hashOfConfig":"167"},{"size":326,"mtime":1738290096890,"results":"234","hashOfConfig":"167"},{"size":28019,"mtime":1743000365350,"results":"235","hashOfConfig":"167"},{"size":332,"mtime":1738290096894,"results":"236","hashOfConfig":"167"},{"size":1273,"mtime":1738290096900,"results":"237","hashOfConfig":"167"},{"size":329,"mtime":1738290096905,"results":"238","hashOfConfig":"167"},{"size":10129,"mtime":1738290096899,"results":"239","hashOfConfig":"167"},{"size":3153,"mtime":1738290096904,"results":"240","hashOfConfig":"167"},{"size":125,"mtime":1738290096897,"results":"241","hashOfConfig":"167"},{"size":10159,"mtime":1738290096906,"results":"242","hashOfConfig":"167"},{"size":328,"mtime":1738290096898,"results":"243","hashOfConfig":"167"},{"size":945,"mtime":1738290096909,"results":"244","hashOfConfig":"167"},{"size":1110,"mtime":1738290096902,"results":"245","hashOfConfig":"167"},{"size":27571,"mtime":1741743790536,"results":"246","hashOfConfig":"167"},{"size":5597,"mtime":1738290096798,"results":"247","hashOfConfig":"167"},{"size":12251,"mtime":1738290096831,"results":"248","hashOfConfig":"167"},{"size":9443,"mtime":1741743219166,"results":"249","hashOfConfig":"167"},{"size":4713,"mtime":1738290096818,"results":"250","hashOfConfig":"167"},{"size":4963,"mtime":1738290096682,"results":"251","hashOfConfig":"167"},{"size":13580,"mtime":1740522455639,"results":"252","hashOfConfig":"167"},{"size":144,"mtime":1738290096527,"results":"253","hashOfConfig":"167"},{"size":6162,"mtime":1738290096660,"results":"254","hashOfConfig":"167"},{"size":2165,"mtime":1739235522643,"results":"255","hashOfConfig":"167"},{"size":3137,"mtime":1739235522676,"results":"256","hashOfConfig":"167"},{"size":7181,"mtime":1739235522656,"results":"257","hashOfConfig":"167"},{"size":864,"mtime":1738290096560,"results":"258","hashOfConfig":"167"},{"size":2012,"mtime":1739235522636,"results":"259","hashOfConfig":"167"},{"size":17178,"mtime":1742929587730,"results":"260","hashOfConfig":"167"},{"size":854,"mtime":1738290096526,"results":"261","hashOfConfig":"167"},{"size":923,"mtime":1738290096566,"results":"262","hashOfConfig":"167"},{"size":148,"mtime":1738290096615,"results":"263","hashOfConfig":"167"},{"size":8911,"mtime":1741490554906,"results":"264","hashOfConfig":"167"},{"size":2611,"mtime":1739235522262,"results":"265","hashOfConfig":"167"},{"size":1080,"mtime":1739674741958,"results":"266","hashOfConfig":"167"},{"size":8318,"mtime":1739764234305,"results":"267","hashOfConfig":"167"},{"size":6656,"mtime":1741831139369,"results":"268","hashOfConfig":"167"},{"size":276,"mtime":1738290096842,"results":"269","hashOfConfig":"167"},{"size":82,"mtime":1738290096940,"results":"270","hashOfConfig":"167"},{"size":4193,"mtime":1739235522330,"results":"271","hashOfConfig":"167"},{"size":6488,"mtime":1740885769728,"results":"272","hashOfConfig":"167"},{"size":1419,"mtime":1738290096572,"results":"273","hashOfConfig":"167"},{"size":910,"mtime":1738290096916,"results":"274","hashOfConfig":"167"},{"size":23162,"mtime":1739235522620,"results":"275","hashOfConfig":"167"},{"size":1771,"mtime":1738290096715,"results":"276","hashOfConfig":"167"},{"size":3532,"mtime":1740023410122,"results":"277","hashOfConfig":"167"},{"size":2725,"mtime":1740024262056,"results":"278","hashOfConfig":"167"},{"size":4091,"mtime":1741875618613,"results":"279","hashOfConfig":"167"},{"size":7351,"mtime":1741875618626,"results":"280","hashOfConfig":"167"},{"size":6214,"mtime":1741875618591,"results":"281","hashOfConfig":"167"},{"size":2209,"mtime":1738290096606,"results":"282","hashOfConfig":"167"},{"size":2310,"mtime":1738290096939,"results":"283","hashOfConfig":"167"},{"size":1891,"mtime":1738290096938,"results":"284","hashOfConfig":"167"},{"size":4081,"mtime":1742929587714,"results":"285","hashOfConfig":"167"},{"size":4379,"mtime":1738290096595,"results":"286","hashOfConfig":"167"},{"size":12429,"mtime":1741874801034,"results":"287","hashOfConfig":"167"},{"size":25322,"mtime":1740922104887,"results":"288","hashOfConfig":"167"},{"size":11650,"mtime":1739235522403,"results":"289","hashOfConfig":"167"},{"size":15667,"mtime":1742929587719,"results":"290","hashOfConfig":"167"},{"size":18680,"mtime":1743120474036,"results":"291","hashOfConfig":"167"},{"size":6865,"mtime":1738290096612,"results":"292","hashOfConfig":"167"},{"size":309,"mtime":1738290096610,"results":"293","hashOfConfig":"167"},{"size":304,"mtime":1738290096598,"results":"294","hashOfConfig":"167"},{"size":21692,"mtime":1738290096582,"results":"295","hashOfConfig":"167"},{"size":2658,"mtime":1738290096651,"results":"296","hashOfConfig":"167"},{"size":928,"mtime":1738290096883,"results":"297","hashOfConfig":"167"},{"size":4041,"mtime":1739235522343,"results":"298","hashOfConfig":"167"},{"size":13275,"mtime":1742014192805,"results":"299","hashOfConfig":"167"},{"size":2349,"mtime":1738290096602,"results":"300","hashOfConfig":"167"},{"size":25790,"mtime":1742929518702,"results":"301","hashOfConfig":"167"},{"size":13420,"mtime":1740578380159,"results":"302","hashOfConfig":"167"},{"size":1797,"mtime":1738290096607,"results":"303","hashOfConfig":"167"},{"size":27443,"mtime":1741830247970,"results":"304","hashOfConfig":"167"},{"size":1484,"mtime":1738290096608,"results":"305","hashOfConfig":"167"},{"size":2391,"mtime":1738290096524,"results":"306","hashOfConfig":"167"},{"size":5512,"mtime":1738290096620,"results":"307","hashOfConfig":"167"},{"size":11171,"mtime":1741829615826,"results":"308","hashOfConfig":"167"},{"size":1216,"mtime":1738290096621,"results":"309","hashOfConfig":"167"},{"size":2425,"mtime":1738290096631,"results":"310","hashOfConfig":"167"},{"size":2707,"mtime":1738290096630,"results":"311","hashOfConfig":"167"},{"size":45736,"mtime":1741875618578,"results":"312","hashOfConfig":"167"},{"size":2608,"mtime":1738290096625,"results":"313","hashOfConfig":"167"},{"size":5188,"mtime":1741875618493,"results":"314","hashOfConfig":"167"},{"size":2588,"mtime":1741875618602,"results":"315","hashOfConfig":"167"},{"size":6014,"mtime":1741875618665,"results":"316","hashOfConfig":"167"},{"size":1427,"mtime":1738290096706,"results":"317","hashOfConfig":"167"},{"size":6403,"mtime":1741875618654,"results":"318","hashOfConfig":"167"},{"size":2210,"mtime":1738290096624,"results":"319","hashOfConfig":"167"},{"size":2166,"mtime":1738290096622,"results":"320","hashOfConfig":"167"},{"size":2654,"mtime":1738290096625,"results":"321","hashOfConfig":"167"},{"size":1437,"mtime":1738290096626,"results":"322","hashOfConfig":"167"},{"size":17629,"mtime":1741875618517,"results":"323","hashOfConfig":"167"},{"size":5226,"mtime":1741874801049,"results":"324","hashOfConfig":"167"},{"size":2285,"mtime":1738290096713,"results":"325","hashOfConfig":"167"},{"size":2795,"mtime":1739235522322,"results":"326","hashOfConfig":"167"},{"size":975,"mtime":1739540532618,"results":"327","hashOfConfig":"167"},{"size":559,"mtime":1739764171299,"results":"328","hashOfConfig":"167"},{"size":9048,"mtime":1740445390678,"results":"329","hashOfConfig":"167"},{"size":19573,"mtime":1743112915252,"results":"330","hashOfConfig":"167"},{"size":7222,"mtime":1743132460240,"results":"331","hashOfConfig":"167"},{"filePath":"332","messages":"333","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"334"},"cto063",{"filePath":"335","messages":"336","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"334"},{"filePath":"337","messages":"338","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"334"},{"filePath":"339","messages":"340","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"334"},{"filePath":"341","messages":"342","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"334"},{"filePath":"343","messages":"344","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"345","usedDeprecatedRules":"334"},{"filePath":"346","messages":"347","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"334"},{"filePath":"348","messages":"349","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"334"},{"filePath":"350","messages":"351","errorCount":0,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"352","usedDeprecatedRules":"353"},{"filePath":"354","messages":"355","errorCount":0,"fatalErrorCount":0,"warningCount":16,"fixableErrorCount":0,"fixableWarningCount":0,"source":"356","usedDeprecatedRules":"353"},{"filePath":"357","messages":"358","errorCount":0,"fatalErrorCount":0,"warningCount":21,"fixableErrorCount":0,"fixableWarningCount":0,"source":"359","usedDeprecatedRules":"334"},{"filePath":"360","messages":"361","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"334"},{"filePath":"362","messages":"363","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"364","usedDeprecatedRules":"334"},{"filePath":"365","messages":"366","errorCount":0,"fatalErrorCount":0,"warningCount":11,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"367","messages":"368","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"334"},{"filePath":"369","messages":"370","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"334"},{"filePath":"371","messages":"372","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"373","usedDeprecatedRules":"334"},{"filePath":"374","messages":"375","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"334"},{"filePath":"376","messages":"377","errorCount":0,"fatalErrorCount":0,"warningCount":24,"fixableErrorCount":0,"fixableWarningCount":0,"source":"378","usedDeprecatedRules":"334"},{"filePath":"379","messages":"380","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"334"},{"filePath":"381","messages":"382","errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"383","usedDeprecatedRules":"334"},{"filePath":"384","messages":"385","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"334"},{"filePath":"386","messages":"387","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"334"},{"filePath":"388","messages":"389","errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"390","usedDeprecatedRules":"334"},{"filePath":"391","messages":"392","errorCount":0,"fatalErrorCount":0,"warningCount":41,"fixableErrorCount":0,"fixableWarningCount":0,"source":"393","usedDeprecatedRules":"334"},{"filePath":"394","messages":"395","errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"396","usedDeprecatedRules":"334"},{"filePath":"397","messages":"398","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"334"},{"filePath":"399","messages":"400","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"334"},{"filePath":"401","messages":"402","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"334"},{"filePath":"403","messages":"404","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"334"},{"filePath":"405","messages":"406","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"334"},{"filePath":"407","messages":"408","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"409","messages":"410","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"334"},{"filePath":"411","messages":"412","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"334"},{"filePath":"413","messages":"414","errorCount":0,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"415","usedDeprecatedRules":"334"},{"filePath":"416","messages":"417","errorCount":0,"fatalErrorCount":0,"warningCount":21,"fixableErrorCount":0,"fixableWarningCount":5,"source":null},{"filePath":"418","messages":"419","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"334"},{"filePath":"420","messages":"421","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"334"},{"filePath":"422","messages":"423","errorCount":0,"fatalErrorCount":0,"warningCount":11,"fixableErrorCount":0,"fixableWarningCount":0,"source":"424","usedDeprecatedRules":"334"},{"filePath":"425","messages":"426","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"334"},{"filePath":"427","messages":"428","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"429","usedDeprecatedRules":"334"},{"filePath":"430","messages":"431","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"432","usedDeprecatedRules":"334"},{"filePath":"433","messages":"434","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"334"},{"filePath":"435","messages":"436","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"437","usedDeprecatedRules":"334"},{"filePath":"438","messages":"439","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"334"},{"filePath":"440","messages":"441","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"334"},{"filePath":"442","messages":"443","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"334"},{"filePath":"444","messages":"445","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"446","messages":"447","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"448","messages":"449","errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"450","usedDeprecatedRules":"334"},{"filePath":"451","messages":"452","errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"453","usedDeprecatedRules":"334"},{"filePath":"454","messages":"455","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"334"},{"filePath":"456","messages":"457","errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"458","usedDeprecatedRules":"334"},{"filePath":"459","messages":"460","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"461","usedDeprecatedRules":"334"},{"filePath":"462","messages":"463","errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"464","usedDeprecatedRules":"334"},{"filePath":"465","messages":"466","errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"467","usedDeprecatedRules":"334"},{"filePath":"468","messages":"469","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"470","usedDeprecatedRules":"334"},{"filePath":"471","messages":"472","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"473","usedDeprecatedRules":"334"},{"filePath":"474","messages":"475","errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"476","usedDeprecatedRules":"334"},{"filePath":"477","messages":"478","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"479","usedDeprecatedRules":"334"},{"filePath":"480","messages":"481","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"482","usedDeprecatedRules":"334"},{"filePath":"483","messages":"484","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"334"},{"filePath":"485","messages":"486","errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"487","usedDeprecatedRules":"334"},{"filePath":"488","messages":"489","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"490","usedDeprecatedRules":"334"},{"filePath":"491","messages":"492","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"334"},{"filePath":"493","messages":"494","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"334"},{"filePath":"495","messages":"496","errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"497","usedDeprecatedRules":"334"},{"filePath":"498","messages":"499","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"334"},{"filePath":"500","messages":"501","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"502","usedDeprecatedRules":"334"},{"filePath":"503","messages":"504","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"334"},{"filePath":"505","messages":"506","errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"507","usedDeprecatedRules":"334"},{"filePath":"508","messages":"509","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"334"},{"filePath":"510","messages":"511","errorCount":0,"fatalErrorCount":0,"warningCount":11,"fixableErrorCount":0,"fixableWarningCount":0,"source":"512","usedDeprecatedRules":"334"},{"filePath":"513","messages":"514","errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"515","usedDeprecatedRules":"334"},{"filePath":"516","messages":"517","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"334"},{"filePath":"518","messages":"519","errorCount":0,"fatalErrorCount":0,"warningCount":11,"fixableErrorCount":0,"fixableWarningCount":0,"source":"520","usedDeprecatedRules":"334"},{"filePath":"521","messages":"522","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"334"},{"filePath":"523","messages":"524","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"334"},{"filePath":"525","messages":"526","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"334"},{"filePath":"527","messages":"528","errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"529","usedDeprecatedRules":"334"},{"filePath":"530","messages":"531","errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"532","usedDeprecatedRules":"334"},{"filePath":"533","messages":"534","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"535","usedDeprecatedRules":"334"},{"filePath":"536","messages":"537","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"538","usedDeprecatedRules":"334"},{"filePath":"539","messages":"540","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"541","usedDeprecatedRules":"334"},{"filePath":"542","messages":"543","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"544","usedDeprecatedRules":"334"},{"filePath":"545","messages":"546","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"334"},{"filePath":"547","messages":"548","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"334"},{"filePath":"549","messages":"550","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"551","usedDeprecatedRules":"334"},{"filePath":"552","messages":"553","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"334"},{"filePath":"554","messages":"555","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"334"},{"filePath":"556","messages":"557","errorCount":0,"fatalErrorCount":0,"warningCount":11,"fixableErrorCount":0,"fixableWarningCount":0,"source":"558","usedDeprecatedRules":"334"},{"filePath":"559","messages":"560","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"334"},{"filePath":"561","messages":"562","errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"563","usedDeprecatedRules":"334"},{"filePath":"564","messages":"565","errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"566","usedDeprecatedRules":"334"},{"filePath":"567","messages":"568","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"334"},{"filePath":"569","messages":"570","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"334"},{"filePath":"571","messages":"572","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"334"},{"filePath":"573","messages":"574","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"334"},{"filePath":"575","messages":"576","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"334"},{"filePath":"577","messages":"578","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"334"},{"filePath":"579","messages":"580","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"581","usedDeprecatedRules":"334"},{"filePath":"582","messages":"583","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"334"},{"filePath":"584","messages":"585","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"334"},{"filePath":"586","messages":"587","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"334"},{"filePath":"588","messages":"589","errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"590","usedDeprecatedRules":"334"},{"filePath":"591","messages":"592","errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"593","usedDeprecatedRules":"334"},{"filePath":"594","messages":"595","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"596","usedDeprecatedRules":"334"},{"filePath":"597","messages":"598","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"334"},{"filePath":"599","messages":"600","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"334"},{"filePath":"601","messages":"602","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"334"},{"filePath":"603","messages":"604","errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"605","usedDeprecatedRules":"334"},{"filePath":"606","messages":"607","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"334"},{"filePath":"608","messages":"609","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"334"},{"filePath":"610","messages":"611","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"612","usedDeprecatedRules":"334"},{"filePath":"613","messages":"614","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"334"},{"filePath":"615","messages":"616","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"334"},{"filePath":"617","messages":"618","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"334"},{"filePath":"619","messages":"620","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"334"},{"filePath":"621","messages":"622","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"334"},{"filePath":"623","messages":"624","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"334"},{"filePath":"625","messages":"626","errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"627","usedDeprecatedRules":"334"},{"filePath":"628","messages":"629","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"334"},{"filePath":"630","messages":"631","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"334"},{"filePath":"632","messages":"633","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"334"},{"filePath":"634","messages":"635","errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"636","usedDeprecatedRules":"334"},{"filePath":"637","messages":"638","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"334"},{"filePath":"639","messages":"640","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"334"},{"filePath":"641","messages":"642","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"334"},{"filePath":"643","messages":"644","errorCount":0,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"645","usedDeprecatedRules":"334"},{"filePath":"646","messages":"647","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"648","usedDeprecatedRules":"334"},{"filePath":"649","messages":"650","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"334"},{"filePath":"651","messages":"652","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"653","usedDeprecatedRules":"334"},{"filePath":"654","messages":"655","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"334"},{"filePath":"656","messages":"657","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"334"},{"filePath":"658","messages":"659","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"334"},{"filePath":"660","messages":"661","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"334"},{"filePath":"662","messages":"663","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"334"},{"filePath":"664","messages":"665","errorCount":0,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"666","usedDeprecatedRules":"334"},{"filePath":"667","messages":"668","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"334"},{"filePath":"669","messages":"670","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"334"},{"filePath":"671","messages":"672","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"334"},{"filePath":"673","messages":"674","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"334"},{"filePath":"675","messages":"676","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"334"},{"filePath":"677","messages":"678","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"334"},{"filePath":"679","messages":"680","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"334"},{"filePath":"681","messages":"682","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"683","usedDeprecatedRules":"334"},{"filePath":"684","messages":"685","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"334"},{"filePath":"686","messages":"687","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"688","usedDeprecatedRules":"334"},{"filePath":"689","messages":"690","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"334"},{"filePath":"691","messages":"692","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"334"},{"filePath":"693","messages":"694","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"334"},{"filePath":"695","messages":"696","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"334"},{"filePath":"697","messages":"698","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"334"},{"filePath":"699","messages":"700","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"334"},{"filePath":"701","messages":"702","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"334"},{"filePath":"703","messages":"704","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"334"},{"filePath":"705","messages":"706","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"334"},{"filePath":"707","messages":"708","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"334"},{"filePath":"709","messages":"710","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"334"},{"filePath":"711","messages":"712","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"334"},{"filePath":"713","messages":"714","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"334"},{"filePath":"715","messages":"716","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"334"},{"filePath":"717","messages":"718","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"334"},{"filePath":"719","messages":"720","errorCount":0,"fatalErrorCount":0,"warningCount":11,"fixableErrorCount":0,"fixableWarningCount":1,"source":"721","usedDeprecatedRules":"334"},{"filePath":"722","messages":"723","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\index.tsx",[],["724","725"],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\App.tsx",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\joiner\\index.ts",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\alert\\Alert.tsx",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\loader\\Loader.tsx",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\pathChecker\\PathChecker.tsx",["726"],"import {useLocation} from \"react-router-dom\";\r\nimport {useEffect, useState} from \"react\";\r\nimport {U} from \"../../joiner\";\r\n\r\ntype Props = {};\r\nfunction PathChecker(props: Props) {\r\n    const {pathname} = useLocation();\r\n    const [renders, setRenders] = useState(0);\r\n\r\n    useEffect(() => {\r\n        const newRenders = renders + 1;\r\n        if(/*pathname === '/project' && */newRenders > 1) U.resetState();\r\n        setRenders(newRenders);\r\n    }, [pathname]);\r\n\r\n    return(<></>);\r\n}\r\n\r\nexport default PathChecker;\r\n","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\forEndUser\\ExternalLibraries.tsx",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\forEndUser\\Tooltip.tsx",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\common\\libraries\\prj_json2xml.js",["727","728","729","730","731","732"],"/*\tThis work is licensed under Creative Commons GNU LGPL License.\r\n\r\n\tLicense: http://creativecommons.org/licenses/LGPL/2.1/\r\n   Version: 0.9\r\n\tAuthor:  Stefan Goessner/2006\r\n\tWeb:     http://goessner.net/ \r\n*/\r\nexport function json2xml(o, tab/*string, string*/) {\r\n   var toXml = function(v, name, ind) {\r\n      var xml = \"\";\r\n      if (v instanceof Array) {\r\n         for (var i=0, n=v.length; i<n; i++)\r\n            xml += ind + toXml(v[i], name, ind+\"\\t\") + \"\\n\";\r\n      }\r\n      else if (typeof(v) == \"object\") {\r\n         var hasChild = false;\r\n         xml += ind + \"<\" + name;\r\n         for (var m in v) {\r\n            if (m.charAt(0) == \"@\")\r\n               xml += \" \" + m.substr(1) + \"=\\\"\" + v[m].toString() + \"\\\"\";\r\n            else\r\n               hasChild = true;\r\n         }\r\n         xml += hasChild ? \">\" : \"/>\";\r\n         if (hasChild) {\r\n            for (var m in v) {\r\n               if (m == \"#text\")\r\n                  xml += v[m];\r\n               else if (m == \"#cdata\")\r\n                  xml += \"<![CDATA[\" + v[m] + \"]]>\";\r\n               else if (m.charAt(0) != \"@\")\r\n                  xml += toXml(v[m], m, ind+\"\\t\");\r\n            }\r\n            xml += (xml.charAt(xml.length-1)==\"\\n\"?ind:\"\") + \"</\" + name + \">\";\r\n         }\r\n      }\r\n      else {\r\n         xml += ind + \"<\" + name + \">\" + v.toString() +  \"</\" + name + \">\";\r\n      }\r\n      return xml;\r\n   }, xml=\"\";\r\n   for (var m in o)\r\n      xml += toXml(o[m], m, \"\");\r\n   return tab ? xml.replace(/\\t/g, tab) : xml.replace(/\\t|\\n/g, \"\");\r\n}\r\n",["733","734"],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\common\\libraries\\prj_xml2json.js",["735","736","737","738","739","740","741","742","743","744","745","746","747","748","749","750"],"/*\tThis work is licensed under Creative Commons GNU LGPL License.\r\n\r\n\tLicense: http://creativecommons.org/licenses/LGPL/2.1/\r\n   Version: 0.9\r\n\tAuthor:  Stefan Goessner/2006\r\n\tWeb:     http://goessner.net/\r\n*/\r\nvar X = {\r\n   toObj: function(xml) {\r\n      var o = {};\r\n      if (xml.nodeType==1) {   // element node ..\r\n         if (xml.attributes.length)   // element with attributes  ..\r\n            for (var i=0; i<xml.attributes.length; i++)\r\n               o[\"@\"+xml.attributes[i].nodeName] = (xml.attributes[i].nodeValue||\"\").toString(); // dam: qua parsa attribs\r\n         if (xml.firstChild) { // element has child nodes ..\r\n            var textChild=0, cdataChild=0, hasElementChild=false;\r\n            for (var n=xml.firstChild; n; n=n.nextSibling) {\r\n               if (n.nodeType==1) hasElementChild = true;\r\n               else if (n.nodeType==3 && n.nodeValue.match(/[^ \\f\\n\\r\\t\\v]/)) textChild++; // non-whitespace text\r\n               else if (n.nodeType==4) cdataChild++; // cdata section node\r\n            }\r\n            if (hasElementChild) {\r\n               if (textChild < 2 && cdataChild < 2) { // structured element with evtl. a single text or/and cdata node ..\r\n                  X.removeWhite(xml);\r\n                  for (var n=xml.firstChild; n; n=n.nextSibling) {\r\n                     if (n.nodeType == 3)  // text node\r\n                        o[\"#text\"] = X.escape(n.nodeValue);\r\n                     else if (n.nodeType == 4)  // cdata node\r\n                        o[\"#cdata\"] = X.escape(n.nodeValue);\r\n                     else if (o[n.nodeName]) {  // multiple occurence of element ..\r\n                        if (o[n.nodeName] instanceof Array)\r\n                           o[n.nodeName][o[n.nodeName].length] = X.toObj(n);\r\n                        else\r\n                           o[n.nodeName] = [o[n.nodeName], X.toObj(n)];\r\n                     }\r\n                     else  // first occurence of element..\r\n                        o[n.nodeName] = X.toObj(n); // damiano: qua parsa sottonodi\r\n                  }\r\n               }\r\n               else { // mixed content\r\n                  if (!xml.attributes.length)\r\n                     o = X.escape(X.innerXml(xml));\r\n                  else\r\n                     o[\"#text\"] = X.escape(X.innerXml(xml));\r\n               }\r\n            }\r\n            else if (textChild) { // pure text\r\n               if (!xml.attributes.length)\r\n                  o = X.escape(X.innerXml(xml));\r\n               else\r\n                  o[\"#text\"] = X.escape(X.innerXml(xml));\r\n            }\r\n            else if (cdataChild) { // cdata\r\n               if (cdataChild > 1)\r\n                  o = X.escape(X.innerXml(xml));\r\n               else\r\n                  for (var n=xml.firstChild; n; n=n.nextSibling)\r\n                     o[\"#cdata\"] = X.escape(n.nodeValue);\r\n            }\r\n         }\r\n         if (!xml.attributes.length && !xml.firstChild) o = null;\r\n      }\r\n      else if (xml.nodeType==9) { // document.node\r\n         o = X.toObj(xml.documentElement);\r\n      }\r\n      else alert(\"unhandled node type: \" + xml.nodeType);\r\n      return o;\r\n   },\r\n   toJson: function(o, name, ind) {\r\n      var json = name ? (\"\\\"\"+name+\"\\\"\") : \"\";\r\n      if (o instanceof Array) {\r\n         for (var i=0,n=o.length; i<n; i++)\r\n            o[i] = X.toJson(o[i], \"\", ind+\"\\t\");\r\n         json += (name?\":[\":\"[\") + (o.length > 1 ? (\"\\n\"+ind+\"\\t\"+o.join(\",\\n\"+ind+\"\\t\")+\"\\n\"+ind) : o.join(\"\")) + \"]\";\r\n      }\r\n      else if (o == null)\r\n         json += (name&&\":\") + \"null\";\r\n      else if (typeof(o) == \"object\") {\r\n         var arr = [];\r\n         for (var m in o)\r\n            arr[arr.length] = X.toJson(o[m], m, ind+\"\\t\");\r\n         json += (name?\":{\":\"{\") + (arr.length > 1 ? (\"\\n\"+ind+\"\\t\"+arr.join(\",\\n\"+ind+\"\\t\")+\"\\n\"+ind) : arr.join(\"\")) + \"}\";\r\n      }\r\n      else if (typeof(o) == \"string\")\r\n         json += (name&&\":\") + \"\\\"\" + o.toString() + \"\\\"\";\r\n      else\r\n         json += (name&&\":\") + o.toString();\r\n      return json;\r\n   },\r\n   innerXml: function(node) {\r\n      var s = \"\"\r\n      if (\"innerHTML\" in node)\r\n         s = node.innerHTML;\r\n      else {\r\n         var asXml = function(n) {\r\n            var s = \"\";\r\n            if (n.nodeType == 1) {\r\n               s += \"<\" + n.nodeName;\r\n               for (var i=0; i<n.attributes.length;i++)\r\n                  s += \" \" + n.attributes[i].nodeName + \"=\\\"\" + (n.attributes[i].nodeValue||\"\").toString() + \"\\\"\";\r\n               if (n.firstChild) {\r\n                  s += \">\";\r\n                  for (var c=n.firstChild; c; c=c.nextSibling)\r\n                     s += asXml(c);\r\n                  s += \"</\"+n.nodeName+\">\";\r\n               }\r\n               else\r\n                  s += \"/>\";\r\n            }\r\n            else if (n.nodeType == 3)\r\n               s += n.nodeValue;\r\n            else if (n.nodeType == 4)\r\n               s += \"<![CDATA[\" + n.nodeValue + \"]]>\";\r\n            return s;\r\n         };\r\n         for (var c=node.firstChild; c; c=c.nextSibling)\r\n            s += asXml(c);\r\n      }\r\n      return s;\r\n   },\r\n   escape: function(txt) {\r\n      return txt.replace(/[\\\\]/g, \"\\\\\\\\\")\r\n          .replace(/[\\\"]/g, '\\\\\"')\r\n          .replace(/[\\n]/g, '\\\\n')\r\n          .replace(/[\\r]/g, '\\\\r');\r\n   },\r\n   removeWhite: function(e) {\r\n      e.normalize();\r\n      for (var n = e.firstChild; n; ) {\r\n         if (n.nodeType == 3) {  // text node\r\n            if (!n.nodeValue.match(/[^ \\f\\n\\r\\t\\v]/)) { // pure whitespace text node\r\n               var nxt = n.nextSibling;\r\n               e.removeChild(n);\r\n               n = nxt;\r\n            }\r\n            else\r\n               n = n.nextSibling;\r\n         }\r\n         else if (n.nodeType == 1) {  // element node\r\n            X.removeWhite(n);\r\n            n = n.nextSibling;\r\n         }\r\n         else                      // any other node\r\n            n = n.nextSibling;\r\n      }\r\n      return e;\r\n   }\r\n};\r\nexport function xml2json(xml, tab = '    '/*XML_DOM, string*/) {\r\n   if (xml.nodeType == 9) // document node\r\n      xml = xml.documentElement;\r\n   var json = X.toJson(X.toObj(X.removeWhite(xml)), xml.nodeName, \"\\t\");\r\n   return \"{\\n\" + tab + (tab ? json.replace(/\\t/g, tab) : json.replace(/\\t|\\n/g, \"\")) + \"\\n}\";\r\n}\r\nexport function xml2jsonobj(xml, tab= '    '){\r\n   return X.toObj(X.removeWhite(xml));\r\n}\r\n// damiano: i needX.toObj(X.removeWhite(xml))\r\n","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\joiner\\classes.ts",["751","752","753","754","755","756","757","758","759","760","761","762","763","764","765","766","767","768","769","770","771"],"import {Mixin} from \"ts-mixer\";\r\nimport type {\r\n    DEdge,\r\n    DEdgePoint,\r\n    DExtEdge,\r\n    DGraph,\r\n    DGraphElement,\r\n    DGraphVertex,\r\n    DRefEdge,\r\n    DVertex,\r\n    DVoidEdge,\r\n    DVoidVertex,\r\n    LEdge,\r\n    LEdgePoint,\r\n    LExtEdge,\r\n    LGraphElement,\r\n    LGraphVertex,\r\n    LRefEdge,\r\n    LVertex,\r\n    LVoidEdge,\r\n    LVoidVertex,\r\n    WEdge,\r\n    WEdgePoint,\r\n    WExtEdge,\r\n    WGraph,\r\n    WGraphElement,\r\n    WGraphVertex,\r\n    WRefEdge,\r\n    WVertex,\r\n    WVoidEdge,\r\n    WVoidVertex\r\n} from \"../model/dataStructure\";\r\nimport type {Class, Longest} from \"ts-mixer/dist/types/types\";\r\nimport type {\r\n    DAnnotation,\r\n    DAttribute,\r\n    DClass,\r\n    DClassifier,\r\n    DDataType,\r\n    DEnumerator,\r\n    DEnumLiteral,\r\n    DMap,\r\n    DModel,\r\n    DModelElement,\r\n    DNamedElement,\r\n    DObject,\r\n    DOperation,\r\n    DPackage,\r\n    DParameter,\r\n    DReference,\r\n    DStructuralFeature,\r\n    DTypedElement,\r\n    DValue,\r\n    LAnnotation,\r\n    LAttribute,\r\n    LClass,\r\n    LClassifier,\r\n    LDataType,\r\n    LEnumerator,\r\n    LEnumLiteral,\r\n    LMap,\r\n    LModelElement,\r\n    LNamedElement,\r\n    LObject,\r\n    LOperation,\r\n    LPackage,\r\n    LParameter,\r\n    LReference,\r\n    LStructuralFeature,\r\n    LTypedElement,\r\n    LValue,\r\n    WAnnotation,\r\n    WAttribute,\r\n    WClass,\r\n    WClassifier,\r\n    WDataType,\r\n    WEnumerator,\r\n    WEnumLiteral,\r\n    WMap,\r\n    WModel,\r\n    WModelElement,\r\n    WNamedElement,\r\n    WObject,\r\n    WOperation,\r\n    WPackage,\r\n    WParameter,\r\n    WReference,\r\n    WStructuralFeature,\r\n    WTypedElement,\r\n    WValue\r\n} from \"../model/logicWrapper\";\r\nimport {\r\n    CClass,\r\n    Constructor, Dependency,\r\n    Dictionary,\r\n    DocString,\r\n    GObject, type Info,\r\n    InitialVertexSize,\r\n    InitialVertexSizeFunc,\r\n    InitialVertexSizeObj,\r\n    orArr,\r\n    Proxyfied,\r\n    unArr\r\n} from \"./types\";\r\nimport {EdgeBendingMode, EdgeGapMode, NodeTypes, PrimitiveType} from \"./types\";\r\nimport type {\r\n    DViewElement,\r\n    DViewTransientProperties,\r\n    LViewTransientProperties,\r\n    WViewElement,\r\n    WViewTransientProperties\r\n} from \"../view/viewElement/view\";\r\nimport type {LogicContext} from \"./proxy\";\r\nimport {\r\n    Action,\r\n    CreateElementAction,\r\n    Defaults,\r\n    DeleteElementAction,\r\n    DLog,\r\n    DState,\r\n    DViewPoint,\r\n    EdgeSegment,\r\n    GraphPoint,\r\n    GraphSize, IPoint, ISize,\r\n    LGraph,\r\n    LLog,\r\n    LModel,\r\n    Log,\r\n    LViewElement,\r\n    LViewPoint,\r\n    ParsedAction, Selectors,\r\n    SetFieldAction,\r\n    SetRootFieldAction,\r\n    ShortAttribETypes,\r\n    statehistory,\r\n    store,\r\n    TRANSACTION,\r\n    U\r\n} from \"./index\";\r\nimport {OclEngine} from \"@stekoe/ocl.js\";\r\nimport {ReactNode} from \"react\";\r\nimport {ProjectsApi} from \"../api/persistance\";\r\nimport {labelfunc} from \"../model/dataStructure/GraphDataElements\";\r\nimport {Dummy} from \"../common/Dummy\";\r\nimport Storage from \"../data/storage\";\r\n\r\nvar windoww = window as any;\r\n// qui dichiarazioni di tipi che non sono importabili con \"import type\", ma che devono essere davvero importate a run-time (eg. per fare un \"extend\", chiamare un costruttore o usare un metodo statico)\r\n\r\n\r\n//console.warn('ts loading classes');\r\n\r\n\r\n// annotation @RuntimeAccessible\r\n// import {store} from \"../redux/createStore\";\r\n\r\nabstract class AbstractMixedClass {\r\n    // superclass!: Dictionary<DocString<'parent class name', Class>>;\r\n    static logic: typeof LPointerTargetable;\r\n    static structure: typeof DPointerTargetable;\r\n    static singleton: LPointerTargetable;\r\n    // static [key: string]: any;\r\n    static init_constructor(...constructorArguments: any): void{}\r\n}\r\n\r\nexport abstract class RuntimeAccessibleClass extends AbstractMixedClass {\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    //static extendTree: TreeModel.Node<typeof RuntimeAccessibleClass>// Tree<string, typeof RuntimeAccessibleClass>;\r\n    static extendMatrix: Dictionary<string, Dictionary<string, boolean>>;\r\n    // static name: never; // it breaks with minification, don't use it\r\n    static cname: string;\r\n    private static OCL_Constructors: Dictionary<Pointer<DModel>, Dictionary<DocString<\"DClass name\">, GObject<\"Fake constructors for ocl \\\"Context\\\"\">>> = {};\r\n\r\n    static set_extend(superclass: typeof RuntimeAccessibleClass, subclass: typeof RuntimeAccessibleClass): void{\r\n        if (!superclass.hasOwnProperty(\"subclasses\")) superclass.subclasses = [subclass];\r\n        else if (superclass.subclasses.indexOf(subclass) === -1) superclass.subclasses.push(subclass);\r\n        if (!subclass.hasOwnProperty(\"_extends\")) subclass._extends = [superclass];\r\n        else if (subclass._extends.indexOf(superclass) === -1) subclass._extends.push(superclass);\r\n    }\r\n\r\n    static extendPrototypes(){\r\n        (Array.prototype as any).contains = function (o:any): boolean{\r\n            return this.indexOf(o) !== -1;\r\n        };\r\n        // (Array.prototype as any).joinOriginal = Array.prototype.join;\r\n        // @ts-ignore\r\n        Array.prototype.first = function(){ return this[0]; }\r\n        // @ts-ignore\r\n        eval(\"Array.prototype.last = function(){ return this[this.length-1]; }\");// without eval it still gives typescript error even with tsignore\r\n        // @ts-ignore\r\n        (Array.prototype as any).separator = function(...separators: any[]/*: orArr<(PrimitiveType | null | undefined | JSX.Element)[]>*/): (string|JSX.Element)[]{\r\n            if (Array.isArray(separators[0])) separators = separators[0]; // case .join([1,2,3])  --> .join(1, 2, 3)\r\n            // console.log(\"separators debug\", this, separators, this[0], typeof this[0]);\r\n            // if (typeof this[0] !== \"object\") return (this as any).joinOriginal(separators);\r\n            // if JSX\r\n            // it handles empty cells like it handles '', but this is how native .join() handles them too: [emptyx5, \"a\", emptyx1, \"b\"].join(\",\") ->  ,,,,,a,,b\r\n            let ret/*:JSX.Element[]*/ = [];\r\n            for (let i = 0; i < this.length; i++){\r\n                if (i === 0) {ret.push(this[i]); continue;}\r\n                ret.push(...separators);\r\n                ret.push(this[i]);\r\n            }\r\n            return ret;\r\n        }\r\n    }\r\n    static fixStatics() {\r\n        this.extendPrototypes();\r\n        for (let classs of Object.values(RuntimeAccessibleClass.annotatedClasses)) {\r\n            let gclass = classs as GObject;\r\n            for (let statickey in gclass.s) { gclass[statickey] = gclass.s[statickey]; }\r\n        }\r\n\r\n    }\r\n    // static allRuntimeClasses: string[] = [];\r\n    static classes: Dictionary<string, typeof RuntimeAccessibleClass> = {};\r\n    static annotatedClasses: Dictionary<string, typeof RuntimeAccessibleClass> = {};\r\n\r\n    static getAllNames(annotated = false): string[] {\r\n        return Object.keys(annotated ? RuntimeAccessibleClass.annotatedClasses : RuntimeAccessibleClass.classes); }\r\n    static getAllClasses(annotated = false): typeof RuntimeAccessibleClass[] {\r\n        return Object.values(annotated ? RuntimeAccessibleClass.annotatedClasses : RuntimeAccessibleClass.classes); }\r\n    static getAllClassesDictionary(annotated = false): Dictionary<string, typeof RuntimeAccessibleClass> {\r\n        return annotated ? RuntimeAccessibleClass.annotatedClasses : RuntimeAccessibleClass.classes; }\r\n\r\n    static wrapAll<D extends RuntimeAccessibleClass, L extends LPointerTargetable = LPointerTargetable, CAN_THROW extends boolean = false,\r\n        RET extends CAN_THROW extends true ? L[] : L[] = CAN_THROW extends true ? L[] : L[] >\r\n    (data: D[] | Pointer<DPointerTargetable, 0, 'N'>, baseObjInLookup?: DPointerTargetable, path: string = '', canThrow: CAN_THROW = false as CAN_THROW, state?: DState, filter:boolean=true): CAN_THROW extends true ? L[] : L[] {\r\n        if (!Array.isArray(data)) return [];\r\n        if (!data.length) return [];\r\n        if (!state) state = windoww.store.getState() as DState;\r\n        if (!filter) return data.map( d => DPointerTargetable.wrap(d, baseObjInLookup, path, canThrow, state)) as L[];\r\n        let ret = [];\r\n        for (let o of data) { if (o) ret.push( DPointerTargetable.wrap(o, baseObjInLookup, path, canThrow, state))}\r\n        return ret;\r\n    }\r\n\r\n    static wrap<D extends RuntimeAccessibleClass, L extends LPointerTargetable = LPointerTargetable, CAN_THROW extends boolean = false,\r\n        RET extends CAN_THROW extends true ? L : L | undefined = CAN_THROW extends true ? L : L | undefined>\r\n    (data: D | Pointer | undefined | null, baseObjInLookup?: DPointerTargetable, path: string = '', canThrow: CAN_THROW = false as CAN_THROW, state?: DState): CAN_THROW extends true ? L : L | undefined{\r\n        if (!data || (data as any).__isProxy) return data as any;\r\n        if (typeof data === 'string') {\r\n            data = DPointerTargetable.from(data, state) as D;\r\n            if (!data) {\r\n                windoww.Log.e(canThrow, 'Cannot wrap:', {data, baseObjInLookup, path});\r\n                return undefined as RET;\r\n            }\r\n        }\r\n        if (Array.isArray(data)) {\r\n            console.error('use WrapAll instead for arrays', {data, baseObjInLookup, path, canThrow});\r\n            if (canThrow) throw new Error(\"use WrapAll instead for arrays\");\r\n            else return undefined as any;\r\n        }\r\n        if (!data) return data;\r\n        // @ts-ignore\r\n        if (!data.className) return undefined;\r\n        // console.log('ProxyWrapping:', {data, baseObjInLookup, path});\r\n        return new Proxy(data, new windoww.TargetableProxyHandler(data, baseObjInLookup, path)) as L;\r\n    }\r\n\r\n    // if v can be wrapped, wrap it. otherwise return the parameter v.\r\n    public static attemptWrap(v: any, s?: DState): any{\r\n        let ret: any = undefined;\r\n        switch (typeof v){\r\n            case \"string\": s = store.getState(); ret = LPointerTargetable.fromPointer(v, s); break\r\n            case \"object\":\r\n                if(v.__isProxy) return v;\r\n                if (v.className) {\r\n                    if (!RuntimeAccessibleClass.get(v?.className)?.logic?.singleton) break;\r\n                    ret = LPointerTargetable.fromD(v);\r\n                }\r\n                break;\r\n            default: break;\r\n        }\r\n        return ret || v;\r\n    }\r\n    /*\r\n        static mapWrap2<D extends DPointerTargetable, L extends LPointerTargetable>(map: RuntimeAccessibleClass, container: D, baseObjInLookup?: DPointerTargetable, path: string = ''): L{\r\n            if (!map || (map as any).__isProxy) return map as any;\r\n            if (typeof container === 'string') {\r\n                container = store.getState().idlookup[container] as unknown as D;\r\n                if (!container) { return Log.exx('Cannot wrap map:', {map, container, baseObjInLookup, path}); }\r\n            }\r\n            // console.log('ProxyWrapping:', {data, baseObjInLookup, path});\r\n            return new Proxy(map, new MapProxyHandler(map, baseObjInLookup, path));\r\n        }\r\n\r\n    */\r\n\r\n    static mapWrap(data: Dictionary, baseObjInLookup: DPointerTargetable, path: string, subMapKeys: string[] = []): Proxyfied<Dictionary> {\r\n        if (!data || (data as any).__isProxy) return data as any;\r\n        // console.error('GETMAP', {data, logicContext, path});\r\n        return new Proxy(data, new windoww.MapProxyHandler(data, baseObjInLookup, path));\r\n    }\r\n\r\n    className!: string;\r\n    protected constructor(...a:any) {\r\n        super();\r\n        // RuntimeAccessibleClass.init_constructor(this, ...a);\r\n        // this.className = this.constructor.name;\r\n        // nb: per i mixin questo settaggio viene sovrascritto. perchè il mixin crea le 2 classi ereditate separatamente con i loro costruttori e le incrocia. quindi devo settarlo dall'annotazione @ tramite prototype\r\n        // RuntimeAccessibleClass.allRuntimeClasses.push(this.className);\r\n    }\r\n\r\n    static init_constructor(thiss: any, ...args: any): void {\r\n\r\n        // this.className = this.constructor.name;\r\n        // let finalObject = this;\r\n        // if (finalObject.constructor.name === \"DVoidVertex\" || finalObject.constructor.name === \"DGraphElement\") { let breakp = true; }\r\n        // this.init0(...arguments);\r\n        // thiss.className = this.name;\r\n    }\r\n\r\n    public static get<T extends typeof RuntimeAccessibleClass = typeof RuntimeAccessibleClass>(dclassname: string, mode?: string )\r\n        : T & {logic?: typeof LPointerTargetable} {\r\n\r\n        // believe it or not there are actually 3 different versions generated, with different static method contexts, it's a mess.\r\n        return this.classes[dclassname] as any;\r\n        /*\r\n        switch(mode) {\r\n            case \"annotated version\":\r\n                /* it is like this in console\r\n                () {\r\n                    var _obj$initBase;\r\n                    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\r\n                ...* /\r\n                return RuntimeAccessibleClass.annotatedClasses[dclassname] as any;\r\n            case \"local definition version\":\r\n            default: // same as window.classname\r\n            case \"module export version\":\r\n                /* it was like this in console, it is not anymore after reworking cname\r\n                // don't know how to get it now, but default version should be always the correct one,\r\n                    class DClassifier extends _joiner__WEBPACK_IMPORTED_MODULE_0__[\"DPointerTargetable\"]\r\n                which is even wrong as i asked for DPointerTargetable and not DClassifier. * /\r\n            return null as any;\r\n        }*/\r\n    }\r\n\r\n    public static extends(className?: string | typeof RuntimeAccessibleClass, superClassName?: string| typeof RuntimeAccessibleClass, returnIfEqual: boolean = true): boolean {\r\n        if (!className || !superClassName) return false;\r\n        const superclass = typeof superClassName === \"string\" ? RuntimeAccessibleClass.get(superClassName) : superClassName;\r\n        const thisclass = typeof className === \"string\" ? RuntimeAccessibleClass.get(className) : className;\r\n        if (!superclass || !thisclass) return false;\r\n        //console.trace(\"extends.1:\", {thisclass, superclass});\r\n        // console.log(\"extends.2:\", {iof:(thisclass instanceof superclass),\r\n        //     tree: !!(RuntimeAccessibleClass.extendTree.first((node) => node.model === superclass)?.first((node) => node.model === thisclass))});\r\n        if (superclass === thisclass) return returnIfEqual;\r\n        // for (let aaa in RuntimeAccessibleClass.extendTree.find(superClassName)) { }\r\n\r\n        return (thisclass instanceof superclass)\r\n            || RuntimeAccessibleClass.extendMatrix[superclass.cname]?.[thisclass.cname]\r\n        // !!(RuntimeAccessibleClass.extendTree.first((node) => node.model === superclass)?.first((node) => node.model === thisclass))\r\n        // || true;\r\n    }\r\n\r\n    getAllPrototypeSuperClasses(): GObject[] {\r\n        let currentlevel = this;\r\n        let ret: GObject[] = [];\r\n        while (true) {\r\n            if (!currentlevel) break;\r\n            ret.push(currentlevel);\r\n            // @ts-ignore\r\n            currentlevel = currentlevel.__proto__;\r\n        }\r\n        console.log('constructor chain:', ret);\r\n        return ret;\r\n    }\r\n    /*initBase(){\r\n        let superclasses = this.getAllPrototypeSuperClasses();\r\n        for (let sc of superclasses) {\r\n            if (!sc.hasOwnProperty('init0')) continue;\r\n            console.log('initbase calling ', {thiss: this, sc, init0: sc.init0, args:sc.constructorArguments});\r\n            sc.init0.apply(this, ...(sc.constructorArguments || []));\r\n        }\r\n    }*/\r\n    // protected abstract init(...constructorParameters: any): void;\r\n    // NB: per colpa della limitazione #3 di ts-mixer,\r\n    // DEVO chiamare init su ogni oggetto per settargli il corretto this.className, altrimenti prende quello dell'ultima superclasse\r\n    /*protected init0(...constructorParameters: any): void {\r\n        let a = this;\r\n        let finalObject = this;\r\n        console.log('creation of___ ', {thiss: this, finalObject});\r\n        if (finalObject.constructor.name === \"DVoidVertex\" || finalObject.constructor.name === \"DGraphElement\") {\r\n            let breakp = true; }\r\n\r\n        (window as any)[finalObject.constructor.name] =\r\n            RuntimeAccessibleClass.classes[finalObject.constructor.name] = finalObject.constructor as any;\r\n        // @ts-ignore\r\n        // delete this.className;\r\n        this.className = (finalObject as any).__proto__.className;\r\n    }*/\r\n\r\n    static makeOCLConstructor(data: DClass, state: DState, oldState: DState): GObject<\"fake constructor of m2-class for ocl's Context\"> {\r\n        let rootModel: DModel = data as any;\r\n        while (rootModel && rootModel.className !== \"DModel\") rootModel = DPointerTargetable.fromPointer(rootModel.father, state);\r\n        let mid: Pointer<DModel> = rootModel?.id; // NB: for EBoolean etc, primitive type meteclasses don't have a model;\r\n        if (!RuntimeAccessibleClass.OCL_Constructors[mid]) {\r\n            RuntimeAccessibleClass.OCL_Constructors[mid] = {...RuntimeAccessibleClass.classes};\r\n        }\r\n        const OclConstructor: GObject = data;\r\n        let namefixed: string;\r\n\r\n        if (oldState && oldState.idlookup[data.id]) {\r\n            let oldname = (oldState.idlookup[data.id] as DClass).name;\r\n            namefixed = U.replaceAll(U.replaceAll(oldname, '-', '_'), ' ', '_');\r\n            delete RuntimeAccessibleClass.OCL_Constructors[mid][oldname];\r\n            delete RuntimeAccessibleClass.OCL_Constructors[mid][namefixed];\r\n\r\n        }\r\n        namefixed = U.replaceAll(U.replaceAll(data.name, '-', '_'), ' ', '_');\r\n        RuntimeAccessibleClass.OCL_Constructors[mid][data.name] = OclConstructor;\r\n        RuntimeAccessibleClass.OCL_Constructors[mid][namefixed] = OclConstructor;\r\n\r\n        return data;\r\n    }\r\n\r\n    static getOCLClasses(model_id: Pointer<DModel>): GObject {\r\n        // return { ...(RuntimeAccessibleClass.OCL_Constructors[model_id] || {}), ...RuntimeAccessibleClass.classes}\r\n        return RuntimeAccessibleClass.OCL_Constructors[model_id] || RuntimeAccessibleClass.classes;\r\n    }\r\n}\r\nexport function Obsolete<T extends any>( constructor: T & GObject): T { return constructor; }\r\nexport function Leaf<T extends any>( constructor: T & GObject): T { return constructor; }\r\nexport function Node<T extends any>( constructor: T & GObject): T { return constructor; }\r\nexport function Abstract<T extends any>( constructor: T & GObject): T { return constructor; }\r\nexport function Instantiable<T extends any>(constructor: T & GObject, instanceConstructor?: Constructor): T { return constructor; } // for m2 cklasses that have m1 instances\r\n// export function RuntimeAccessible<T extends any>(cname: string): ((constructor: T & GObject) => T) {\r\nexport function RuntimeAccessible(cname: string) {\r\n    return (ctor: any) => RuntimeAccessible_inner(ctor, cname);\r\n}\r\n\r\nfunction RuntimeAccessible_inner<T extends any>(constructor: T & GObject, cname: string): T {\r\n    // console.log('DecoratorTest', {constructor, arguments});\r\n    (constructor as GObject).cname = cname;\r\n    if (!constructor.hasOwnProperty(\"subclasses\")) (constructor as GObject).subclasses = [];\r\n    // @ts-ignore\r\n    RuntimeAccessibleClass.classes[constructor.cname] = constructor as any as typeof RuntimeAccessibleClass;\r\n    // console.log(\"setting runtime accessible\", {key: constructor.cname, constructor, pre: predebug, post: {...RuntimeAccessibleClass.classes}});\r\n    if (!windoww[constructor.cname]) (windoww[constructor.cname] as any) = constructor;\r\n    constructor.prototype.className = constructor.cname;\r\n    //constructor.prototype.$$typeof = constructor.cname;\r\n    //constructor.prototype.typeName = constructor.cname;\r\n    (constructor as any).staticClassName = constructor.cname;\r\n    // @ts-ignore\r\n    // console.log('runtimeaccessible annotation:', {thiss:this, constructor});\r\n    //    const classnameFixedConstructor = constructor; //  function (...args) { let obj = new constructor(...args); obj.init?.(); obj.init0?.(); return obj; }\r\n\r\n    // @ts-ignore\r\n    let outerthis = this;\r\n    // @ts-ignore\r\n    const classnameFixedConstructorDoNotRenameWithoutSearchStrings = function (...args) {\r\n        // @ts-ignore\r\n        // console.log('runtimeaccessible annotation inner:', {thiss:this, outerthis, constructor});\r\n        // @ts-ignore\r\n        let obj = new constructor(...args);\r\n        obj.classNameFromAnnotation = constructor.cname;\r\n        obj.className = constructor.cname;\r\n        //obj.prototype.$$typeof = constructor.name;\r\n        // obj.prototype.typeName = constructor.name;\r\n        // obj.init?.();\r\n        // obj.init0?.();\r\n        obj.initBase?.();\r\n        // @ts-ignore\r\n        // console.log('runtimeaccessible annotation inner end:', {thiss:this, outerthis, constructor, obj});\r\n        return obj; }\r\n    RuntimeAccessibleClass.annotatedClasses[constructor.cname] = classnameFixedConstructorDoNotRenameWithoutSearchStrings as any as typeof RuntimeAccessibleClass;\r\n\r\n    for (let key in constructor) (classnameFixedConstructorDoNotRenameWithoutSearchStrings as GObject)[key] = constructor[key];\r\n    // constructor.constructor = classnameFixedConstructorDoNotRenameWithoutSearchStrings; return constructor;\r\n\r\n    // @ts-ignore\r\n    // for (let staticKey of constructor as GObject) { classnameFixedConstructorDoNotRenameWithoutSearchStrings[staticKey] = constructor[staticKey]; }\r\n    classnameFixedConstructorDoNotRenameWithoutSearchStrings.prototype = constructor.prototype;\r\n    classnameFixedConstructorDoNotRenameWithoutSearchStrings.prototype.constructor = constructor.prototype.constructor;\r\n\r\n    // required for inheriting static methods\r\n    classnameFixedConstructorDoNotRenameWithoutSearchStrings.__proto__ = constructor.__proto__;\r\n    classnameFixedConstructorDoNotRenameWithoutSearchStrings.s = constructor;\r\n    // return classnameFixedConstructorDoNotRenameWithoutSearchStrings as any;\r\n    return constructor;\r\n}\r\n\r\n\r\n(window as any).RuntimeAccessibleClass = RuntimeAccessibleClass;\r\n// todo: problema: per creare un PointerTargetable ho bisogno dell'userid, e devo generarlo prima che venga generato l'initialState... dovrebbe venir servito con la pagina dal server. o passato come navigation props dalla pagina di login\r\n\r\n\r\n\r\nexport type DtoL<DX extends GObject, LX =\r\n    DX extends DEnumerator ? LEnumerator : (DX extends DAttribute ? LAttribute : (DX extends DReference ? LReference : (DX extends DRefEdge ? LRefEdge : (DX extends DExtEdge ? LExtEdge : (DX extends DDataType ? LDataType : (DX extends DClass ? LClass : (DX extends DStructuralFeature ? LStructuralFeature : (DX extends DParameter ? LParameter : (DX extends DOperation ? LOperation : (DX extends DEdge ? LEdge : (DX extends DEdgePoint ? LEdgePoint : (DX extends DGraphVertex ? LGraphVertex : (DX extends DModel ? LModel : (DX extends DValue ? LValue : (DX extends DObject ? LObject : (DX extends DEnumLiteral ? LEnumLiteral : (DX extends DPackage ? LPackage : (DX extends DClassifier ? LClassifier : (DX extends DTypedElement ? LTypedElement : (DX extends DVertex ? LVertex : (DX extends DVoidEdge ? LVoidEdge : (DX extends DVoidVertex ? LVoidVertex : (DX extends DGraph ? LGraph : (DX extends DNamedElement ? LNamedElement : (DX extends DAnnotation ? LAnnotation : (DX extends DGraphElement ? LGraphElement : (DX extends DMap ? LMap : (DX extends DModelElement ? LModelElement : (DX extends DUser ? LUser : (DX extends DPointerTargetable ? LPointerTargetable :\r\n        (DX extends DUser ? LUser : (DX extends DLog ? LLog : (ERROR)))\r\n        ))))))))))))))))))))))))))))))> = LX;\r\nexport type DtoW<DX extends GObject, WX = DX extends DEnumerator ? WEnumerator : (DX extends DAttribute ? WAttribute : (DX extends DReference ? WReference : (DX extends DRefEdge ? WRefEdge : (DX extends DExtEdge ? WExtEdge : (DX extends DDataType ? WDataType : (DX extends DClass ? WClass : (DX extends DStructuralFeature ? WStructuralFeature : (DX extends DParameter ? WParameter : (DX extends DOperation ? WOperation : (DX extends DEdge ? WEdge : (DX extends DEdgePoint ? WEdgePoint : (DX extends DGraphVertex ? WGraphVertex : (DX extends DModel ? WModel : (DX extends DValue ? WValue : (DX extends DObject ? WObject : (DX extends DEnumLiteral ? WEnumLiteral : (DX extends DPackage ? WPackage : (DX extends DClassifier ? WClassifier : (DX extends DTypedElement ? WTypedElement : (DX extends DVertex ? WVertex : (DX extends DVoidEdge ? WVoidEdge : (DX extends DVoidVertex ? WVoidVertex : (DX extends DGraph ? WGraph : (DX extends DNamedElement ? WNamedElement : (DX extends DAnnotation ? WAnnotation : (DX extends DGraphElement ? WGraphElement : (DX extends DMap ? WMap : (DX extends DModelElement ? WModelElement : (DX extends DUser ? WUser : (DX extends DPointerTargetable ? WPointerTargetable : (ERROR)))))))))))))))))))))))))))))))> = WX;\r\n// export type DtoW<DX extends GObject, WX = Omit<DtoW0<DX>, 'id'>> = WX;\r\nexport type LtoD<LX extends LPointerTargetable, DX = LX extends LEnumerator ? DEnumerator : (LX extends LAttribute ? DAttribute : (LX extends LReference ? DReference : (LX extends LRefEdge ? DRefEdge : (LX extends LExtEdge ? DExtEdge : (LX extends LDataType ? DDataType : (LX extends LClass ? DClass : (LX extends LStructuralFeature ? DStructuralFeature : (LX extends LParameter ? DParameter : (LX extends LOperation ? DOperation : (LX extends LEdge ? DEdge : (LX extends LEdgePoint ? DEdgePoint : (LX extends LGraphVertex ? DGraphVertex : (LX extends LModel ? DModel : (LX extends LValue ? DValue : (LX extends LObject ? DObject : (LX extends LEnumLiteral ? DEnumLiteral : (LX extends LPackage ? DPackage : (LX extends LClassifier ? DClassifier : (LX extends LTypedElement ? DTypedElement : (LX extends LVertex ? DVertex : (LX extends LVoidEdge ? DVoidEdge : (LX extends LVoidVertex ? DVoidVertex : (LX extends LGraph ? DGraph : (LX extends LNamedElement ? DNamedElement : (LX extends LAnnotation ? DAnnotation : (LX extends LGraphElement ? DGraphElement : (LX extends LMap ? DMap : (LX extends LModelElement ? DModelElement : (LX extends LUser ? DUser : (LX extends LPointerTargetable ? DPointerTargetable : (ERROR)))))))))))))))))))))))))))))))> = DX;\r\nexport type LtoW<LX extends LPointerTargetable, WX = LX extends LEnumerator ? WEnumerator : (LX extends LAttribute ? WAttribute : (LX extends LReference ? WReference : (LX extends LRefEdge ? WRefEdge : (LX extends LExtEdge ? WExtEdge : (LX extends LDataType ? WDataType : (LX extends LClass ? WClass : (LX extends LStructuralFeature ? WStructuralFeature : (LX extends LParameter ? WParameter : (LX extends LOperation ? WOperation : (LX extends LEdge ? WEdge : (LX extends LEdgePoint ? WEdgePoint : (LX extends LGraphVertex ? WGraphVertex : (LX extends LModel ? WModel : (LX extends LValue ? WValue : (LX extends LObject ? WObject : (LX extends LEnumLiteral ? WEnumLiteral : (LX extends LPackage ? WPackage : (LX extends LClassifier ? WClassifier : (LX extends LTypedElement ? WTypedElement : (LX extends LVertex ? WVertex : (LX extends LVoidEdge ? WVoidEdge : (LX extends LVoidVertex ? WVoidVertex : (LX extends LGraph ? WGraph : (LX extends LNamedElement ? WNamedElement : (LX extends LAnnotation ? WAnnotation : (LX extends LGraphElement ? WGraphElement : (LX extends LMap ? WMap : (LX extends LModelElement ? WModelElement : (LX extends LUser ? WUser : (LX extends LPointerTargetable ? WPointerTargetable : (ERROR)))))))))))))))))))))))))))))))> = WX;\r\nexport type WtoD<IN extends WPointerTargetable, OUT = IN extends WEnumerator ? DEnumerator : (IN extends WAttribute ? DAttribute : (IN extends WReference ? DReference : (IN extends WRefEdge ? DRefEdge : (IN extends WExtEdge ? DExtEdge : (IN extends WDataType ? DDataType : (IN extends WClass ? DClass : (IN extends WStructuralFeature ? DStructuralFeature : (IN extends WParameter ? DParameter : (IN extends WOperation ? DOperation : (IN extends WEdge ? DEdge : (IN extends WEdgePoint ? DEdgePoint : (IN extends WGraphVertex ? DGraphVertex : (IN extends WModel ? DModel : (IN extends WValue ? DValue : (IN extends WObject ? DObject : (IN extends WEnumLiteral ? DEnumLiteral : (IN extends WPackage ? DPackage : (IN extends WClassifier ? DClassifier : (IN extends WTypedElement ? DTypedElement : (IN extends WVertex ? DVertex : (IN extends WVoidEdge ? DVoidEdge : (IN extends WVoidVertex ? DVoidVertex : (IN extends WGraph ? DGraph : (IN extends WNamedElement ? DNamedElement : (IN extends WAnnotation ? DAnnotation : (IN extends WGraphElement ? DGraphElement : (IN extends WMap ? DMap : (IN extends WModelElement ? DModelElement : (IN extends WUser ? DUser : (IN extends WPointerTargetable ? DPointerTargetable : (IN extends WViewElement ? DViewElement : (IN extends WViewTransientProperties ? DViewTransientProperties : (ERROR)))))))))))))))))))))))))))))))))> = OUT;\r\nexport type WtoL<IN extends WPointerTargetable, OUT = IN extends WEnumerator ? LEnumerator : (IN extends WAttribute ? LAttribute : (IN extends WReference ? LReference : (IN extends WRefEdge ? LRefEdge : (IN extends WExtEdge ? LExtEdge : (IN extends WDataType ? LDataType : (IN extends WClass ? LClass : (IN extends WStructuralFeature ? LStructuralFeature : (IN extends WParameter ? LParameter : (IN extends WOperation ? LOperation : (IN extends WEdge ? LEdge : (IN extends WEdgePoint ? LEdgePoint : (IN extends WGraphVertex ? LGraphVertex : (IN extends WModel ? LModel : (IN extends WValue ? LValue : (IN extends WObject ? LObject : (IN extends WEnumLiteral ? LEnumLiteral : (IN extends WPackage ? LPackage : (IN extends WClassifier ? LClassifier : (IN extends WTypedElement ? LTypedElement : (IN extends WVertex ? LVertex : (IN extends WVoidEdge ? LVoidEdge : (IN extends WVoidVertex ? LVoidVertex : (IN extends WGraph ? LGraph : (IN extends WNamedElement ? LNamedElement : (IN extends WAnnotation ? LAnnotation : (IN extends WGraphElement ? LGraphElement : (IN extends WMap ? LMap : (IN extends WModelElement ? LModelElement : (IN extends WUser ? LUser : (IN extends WPointerTargetable ? LPointerTargetable : (IN extends WViewElement ? LViewElement : (IN extends WViewTransientProperties ? LViewTransientProperties : (ERROR)))))))))))))))))))))))))))))))))> = OUT;\r\nexport enum CoordinateMode {\r\n    \"absolute\"              = \"absolute\",\r\n    \"relativePercent\"       = \"relative%\",\r\n    \"relativeOffset\"        = \"relativeOffset\",\r\n    \"relativeOffsetStart\"   = \"relativeOffsetStart\",\r\n    \"relativeOffsetEnd\"     = \"relativeOffsetEnd\",\r\n}\r\n\r\nexport type EPSize = GraphSize & {currentCoordType: CoordinateMode};\r\nexport enum EdgeHead {\r\n    composition = \"Composition\",\r\n    aggregation = \"Aggregation\",\r\n    reference   = \"Association\",\r\n    extend      = \"Extension\"\r\n}\r\n\r\n\r\n@RuntimeAccessible('UserHistory')\r\nexport class UserHistory{\r\n    static cnamne: string = 'UserHistory';\r\n    constructor(public undoable:GObject<\"delta\">[] = [], public redoable: GObject<\"delta\">[] = []){\r\n\r\n    }\r\n}\r\n\r\nlet canFireActions: boolean = true;\r\n@RuntimeAccessible('Constructors')\r\nexport class Constructors<T extends DPointerTargetable = DPointerTargetable>{\r\n    public static paused: boolean = false;\r\n    private thiss: T;\r\n    private persist: boolean;\r\n    // private callbacks: Function[];\r\n    private nonPersistentCallbacks: Function[];\r\n    fatherType?: typeof RuntimeAccessibleClass;\r\n    private fatherPtr?: Pointer // T['father'];\r\n    private state?: DState; // set only if requested by setWithSideEffect\r\n    private parentgraphID?: Pointer<DGraph>; // only present for DGraphElements\r\n    /*\r\n    problem: if isPersistent is set to false, but the object is later made persistent with an action, you lose all the callback effects afecting other elements (as setting opposite relations like instances-typeof or losing pointedBy's)\r\n    solution 1: store in the D-object a function executing the callbacks called by CreateNewElement action, then delete that field before persisting.\r\n    continued: instead of setting the pointedBy's this way (and increasing clonedcounter for nothing) erase all PointedBy mentionings here, and make all pointer values assigned separately with a SetAction,' +\r\n    '         if new2 is used that set manually a d-field, set it to undefined in the in the .end() part, then trigger the setaction with correct value.\r\n    continued: sort actions by path, but always make sure CreateElement are first in the sort regardless of path. make also sure 2 actions with the same path keep the order they are launched/created (oldest first)\r\n    */\r\n    constructor(t:T, father?: Pointer, persist: boolean = true, fatherType?: Constructor, id?: string, isUser:boolean = false) {\r\n        persist = persist && canFireActions;\r\n        this.thiss = t;\r\n        this.setID(id, isUser);\r\n        // the same thing is done in reducer/createelementaction, but if the object is destructured before then, it will lose the constructor and reducer will fail to assign classname\r\n        t.className = t.className || (t.constructor as typeof RuntimeAccessibleClass).cname || t.constructor.name;\r\n        DPointerTargetable.pendingCreation[t.id] = t;\r\n        this.persist = persist;\r\n        t._persistCallbacks = [];\r\n        t._derivedSubElements = [];\r\n        this.nonPersistentCallbacks = [];\r\n        this.fatherPtr = father;\r\n\r\n        if (this.thiss.hasOwnProperty(\"father\")) {\r\n            this.fatherType = fatherType as any;\r\n            // console.log('x6 addchild() set ptr father', {father, thiss:this.thiss});\r\n            this.setPtr(\"father\", father);\r\n        }\r\n    }\r\n\r\n    static makeID(isUser:boolean=false): Pointer { return \"Pointer\" + new Date().getTime() + \"_\" + (isUser ? DUser.current : 'USER') + \"_\" + (DPointerTargetable.maxID++) }\r\n    private setID(id?: string, isUser:boolean = false){\r\n        this.thiss.id = id || Constructors.makeID(isUser);\r\n    }\r\n\r\n    // cannot use Lobjects as they will set PointedBy in persistent state, also might access an incomplete version of the object crashing\r\n    private setPtr(property: string, value: any, checkPointerValidity?: DState) {\r\n        (this.thiss as GObject)[property] = value;\r\n        if (!value) return;\r\n        if (Array.isArray(value)) for (let v of value) {\r\n            if (!value) continue;\r\n            if (typeof v === \"object\") v = v.id;\r\n            if (!v || checkPointerValidity && !Pointers.isPointer(v, checkPointerValidity)) continue;\r\n            this.thiss._persistCallbacks.push(SetFieldAction.create(v, \"pointedBy\", PointedBy.fromID(this.thiss.id, property as any), '+='));\r\n        }\r\n        else {\r\n            if (typeof value === \"object\") value = value.id;\r\n            value && this.thiss._persistCallbacks.push(SetFieldAction.create(value, \"pointedBy\", PointedBy.fromID(this.thiss.id, property as any), '+='));\r\n        }\r\n        // todo: in delete if the element was not persistent, just do nothing.\r\n    }\r\n\r\n    private setExternalRootProperty<D extends DPointerTargetable>(path: string, val: any, accessModifier: \"[]\" | \"+=\" | \"\", isPointer: boolean): this {\r\n        this.thiss._persistCallbacks.push(SetRootFieldAction.create(path, val, accessModifier, isPointer));\r\n        return this;\r\n    }\r\n\r\n    private setExternalPtr<D extends DPointerTargetable>(target: D | Pointer<any>, property: string, accessModifier: \"[]\" | \"+=\" | \"\" = \"\", val?: any): this {\r\n        if (!target) return this;\r\n        if (typeof target === \"object\") target = target.id;\r\n        if (!val) val = this.thiss.id;\r\n        this.thiss._persistCallbacks.push(SetFieldAction.create(target, property, val, accessModifier, true));\r\n        return this;\r\n        // PointedBy is set by reducer directly in this case.\r\n        // this.thiss._persistCallbacks.push(SetFieldAction.create(this.thiss.id, \"pointedBy\", PointedBy.fromID(target, property as any), '+='));\r\n    }\r\n\r\n    private setWithSideEffect<D extends DPointerTargetable>(property: string, val: any): this {\r\n        if (!val) return this;\r\n        if (!this.state) this.state = store.getState();\r\n        if (typeof val === \"object\") val = val.id;\r\n        this.thiss._persistCallbacks.push( () => {\r\n            (LPointerTargetable.from(this.thiss, this.state) as GObject<\"L\">)[property] = val;\r\n        });\r\n        return this;\r\n    }\r\n\r\n    //static pause(): void { canFireActions = false; }\r\n    //static resume(): void { canFireActions = true; }\r\n    static persist(d: DPointerTargetable, fromCreateAction?: boolean): void;\r\n    static persist(d: DPointerTargetable[]): void;\r\n    static persist(d: orArr<DPointerTargetable>, fromCreateAction?: boolean): void {\r\n        if (Constructors.paused) return;\r\n        TRANSACTION('Create element', ()=> {\r\n            if (!Array.isArray(d)) d = [d];\r\n            // first create \"this\"\r\n            for (let e of d) {\r\n                let subElements = e._derivedSubElements;\r\n                let callbacks = e._persistCallbacks;\r\n                delete (e as Partial<DPointerTargetable>)._derivedSubElements;\r\n                delete (e as Partial<DPointerTargetable>)._persistCallbacks;\r\n                // then create subelements (object -> values) and fire their actions.\r\n                if (!fromCreateAction) CreateElementAction.new(e, false);\r\n                for (let c of subElements) Constructors.persist([c]);\r\n                // finally fire the actions for \"this\"\r\n\r\n                // console.log('x6 addchild pre firing act()', {callbacks, d:e});\r\n                for (let c of callbacks) (c as Action).fire ? (c as Action).fire() : (c as () => void)();\r\n                SetRootFieldAction.new('ELEMENT_CREATED', e.id, '+=', false); // here no need to IsPointer because it only affects Transient stuff\r\n            }\r\n        })\r\n    }\r\n    // start(thiss: any): this { this.thiss = thiss; return this; }\r\n    end(simpledatacallback?: (d:T, c: this) => void): T {\r\n        const deleteDState = false; // don't save DState in idlookup\r\n        if (this.thiss.className === 'DState' && deleteDState) return this.thiss;\r\n        if (simpledatacallback) simpledatacallback(this.thiss, this); // callback for setting primitive types, not pointers not context-dependant values (name being potentially invalid / chosen according to parent)\r\n        if (this.nonPersistentCallbacks.length) {\r\n            for (let cb of this.nonPersistentCallbacks) cb();\r\n        }\r\n        if (!this.persist) return this.thiss;\r\n        Constructors.persist(this.thiss);\r\n        /// todo: warning: there is a transaction at .persist method, do not use BEGIN+END/TRANSACTION inside\r\n\r\n        return this.thiss; }\r\n\r\n\r\n    DState(): this {\r\n        let thiss: DState = this.thiss as any;\r\n        thiss.debug = !!localStorage.getItem('debug');\r\n        return this;\r\n    }\r\n\r\n    DModelElement(): this {\r\n        let thiss: GObject<DModelElement> = this.thiss as any;\r\n        if ('instances' in thiss) thiss.instances = [];\r\n        return this; }\r\n    DClassifier(): this { return this; }\r\n    DParameter(defaultValue?: any): this {\r\n        let thiss: DParameter = this.thiss as any;\r\n        thiss.defaultValue = defaultValue;\r\n        this.setExternalPtr(thiss.father, \"parameters\", \"+=\");\r\n        return this; }\r\n    DStructuralFeature(): this {\r\n        if (this.thiss.className === 'DOperation') return this;\r\n        // if (!this.persist) return this;\r\n        let thiss = this.thiss as any;\r\n        const _DClass: typeof DClass = windoww.DClass;\r\n        const _DValue: typeof DValue = windoww.DValue;\r\n\r\n\r\n        let targets: DClass[] = [(_DClass as typeof DPointerTargetable).from(thiss.father, this.state)];\r\n        let alreadyParsed: Dictionary<Pointer, DClass> = {};\r\n        /*\r\n        todo: build a Tree<DClass> of all superclasses tree nested by level.\r\n            only then instantiate DValues by depth level, if same level from right to left (last extend on right takes priority) and erase this stuff below.*/\r\n        // let superClassesByLevel: Dictionary<Pointer, DClass> = ;\r\n        while(targets.length) { // gather superclasses in map \"alreadyParsed\"\r\n            let nextTargets = [];\r\n            for (let target of targets) {\r\n                if (!target) { Log.ww(\"Invalid father pointer in DStructuralFeature\", {feature: thiss, father:target, superclasses: alreadyParsed}); continue; }\r\n                if (alreadyParsed[target.id]) continue;\r\n                alreadyParsed[target.id] = target;\r\n                for(let ext of target.extendedBy) nextTargets.push((_DClass as typeof DPointerTargetable).from(ext));\r\n            }\r\n            targets = nextTargets;\r\n        }\r\n        //(thiss as DPointerTargetable)._persistCallbacks.push(()=>{\r\n        // When a feature is added in m2, i loop instanced m1 objects to add that feature as a DValue.\r\n        console.log('adding feature to existing objects 0 ', {alreadyParsed})\r\n        let state = store.getState();\r\n        for (let pointer in alreadyParsed) {\r\n            for (let instanceObjPtr of alreadyParsed[pointer].instances) {\r\n                console.log('adding feature to existing objects 1 ', {alreadyParsed, instanceObjPtr, idl:state.idlookup[instanceObjPtr]})\r\n\r\n                // this._derivedSubElements.push(_DValue.new(thiss.name, thiss.id, undefined, instanceObjPtr));\r\n                thiss._derivedSubElements.push(_DValue.new3({name: undefined, instanceof: thiss.id, father: instanceObjPtr}, undefined, false));\r\n            }\r\n            //}\r\n        }\r\n\r\n\r\n        return this;\r\n    }\r\n    DReference(): this {\r\n        let thiss: DReference = this.thiss as any;\r\n        thiss.aggregation = false;\r\n        thiss.composition = false;\r\n        thiss.rootable = undefined;\r\n        this.setExternalPtr(thiss.father, \"references\", \"+=\");\r\n        return this; }\r\n\r\n    DAttribute(): this {\r\n        let thiss: DAttribute = this.thiss as any;\r\n        this.setExternalPtr(thiss.father, \"attributes\", \"+=\");\r\n        return this; }\r\n\r\n    DDataType(): this { return this; }\r\n\r\n    DObject(instanceoff?: DObject[\"instanceof\"]): this {\r\n        let thiss: DObject = this.thiss as any;\r\n        if (thiss.father) {\r\n            if (this.fatherType!.cname === \"DModel\") {\r\n                this.setExternalPtr(thiss.father, \"objects\", \"+=\");\r\n            }\r\n            else {\r\n                // object containing object is not in any direct child collection. access through values\r\n                this.setExternalPtr(thiss.father, \"values\", \"+=\");\r\n            }\r\n        }\r\n        instanceoff && this.setWithSideEffect( \"instanceof\", instanceoff);\r\n        return this; }\r\n\r\n    DValue(instanceoff?: DValue[\"instanceof\"], val?: DValue[\"values\"], isMirage?: DValue[\"isMirage\"]): this {\r\n        let thiss: DValue = this.thiss as any; thiss.edges = [];\r\n        // thiss.values = val || [];\r\n        thiss.instanceof = instanceoff;\r\n        thiss.isMirage = isMirage || false;\r\n        if (val === undefined) val = [];\r\n        else if(!Array.isArray(val)) val = [val];\r\n        thiss.values = [];// because reducer calculating newly added pointedby must find something to start comparison\r\n        thiss.allowCrossReference = false;\r\n        this.setPtr(\"values\", val, this.state);\r\n\r\n        // update father's collections (pointedby's here are set automatically)\r\n        if (instanceoff) {\r\n            this.setPtr(\"instanceof\", instanceoff);\r\n            this.setExternalPtr(instanceoff, \"instances\", \"+=\");\r\n        }\r\n        this.setExternalPtr(thiss.father, \"features\", \"+=\");\r\n        return this; }\r\n\r\n    DAnnotation(source?: DAnnotation[\"source\"], details?: DAnnotation[\"details\"]): this {\r\n        const thiss: DAnnotation = this.thiss as any;\r\n        thiss.source = source || '';\r\n        thiss.details = details || [];\r\n        this.setExternalPtr(thiss.father, \"annotations\", \"+=\");\r\n\r\n        if (details) for (let det of details)\r\n            thiss._persistCallbacks.push(SetFieldAction.create(det, \"pointedBy\", PointedBy.fromID(thiss.id, \"details\"), '+='));\r\n\r\n        return this; }\r\n\r\n    DPointerTargetable(): this {\r\n        const thiss: DPointerTargetable = this.thiss as any;\r\n        thiss.className = (thiss.constructor as typeof RuntimeAccessibleClass).cname;\r\n        // this.className = thiss.className;\r\n        return this; }\r\n\r\n    DUser(name: string, surname: string, nickname: string, affiliation: string, country: string, newsletter: boolean, email: string, token: string): this {\r\n        const _this: DUser = this.thiss as unknown as DUser;\r\n        _this.name = name;\r\n        _this.surname = surname;\r\n        _this.nickname = nickname;\r\n        _this.affiliation = affiliation;\r\n        _this.country = country;\r\n        _this.newsletter = newsletter;\r\n        _this.email = email;\r\n        _this.token = token;\r\n        // statehistory[_this.id] = new UserHistory();\r\n        // todo: make it able to combine last 2 changes with a keystroke.\r\n        //  reapeat N times to combine N actions.\r\n        //  let it \"redo\" multiple times, it's like recording a macro.\r\n\r\n        if (this.persist) {\r\n            // no pointedBy\r\n        }\r\n        return this;\r\n    }\r\n\r\n    DNamedElement(name?: DNamedElement[\"name\"]): this {\r\n        const thiss: DNamedElement = this.thiss as any;\r\n        thiss.name = (name !== undefined) ? name || '' : thiss.constructor.name.substring(1) + \" 1\";\r\n        return this; }\r\n\r\n    DTypedElement(type?: DTypedElement[\"type\"]): this {\r\n        const thiss: DTypedElement = this.thiss as any;\r\n        thiss.allowCrossReference = false;\r\n\r\n        let dtype = Selectors.getByName2(type) as DClassifier | null;\r\n        switch (dtype?.className){\r\n            default: type = undefined; break;\r\n            case 'DClass':\r\n                switch (thiss.className) {\r\n                    case 'DReference':\r\n                    case 'DOperation':\r\n                    case 'DParameter':\r\n                        type = dtype.id;\r\n                        break;\r\n                    case 'DAttribute':\r\n                    default: type = dtype.id; break;\r\n                }\r\n                break;\r\n            case 'DEnumerator':\r\n                switch (thiss.className) {\r\n                    case 'DAttribute':\r\n                    case 'DOperation':\r\n                    case 'DParameter':\r\n                        type = dtype.id;\r\n                        break;\r\n                    case 'DReference':\r\n                    default: type = undefined; break;\r\n                }\r\n                break;\r\n        }\r\n\r\n        if (!type) {\r\n            switch (thiss.className) {\r\n                default:\r\n                case 'DReference':\r\n                    type = this.fatherPtr as Pointer<DClass> || undefined;\r\n                    break;\r\n                case 'DOperation':\r\n                case 'DParameter':\r\n                    type = this.fatherPtr as Pointer<DClass> || Pointers.ESTRING;\r\n                    break;\r\n                case 'DAttribute':\r\n                type = Pointers.ESTRING; break;\r\n            }\r\n        }\r\n        this.setPtr(\"type\", type);\r\n        return this; }\r\n\r\n    DPackage(uri?: DPackage[\"uri\"], prefix?: DPackage[\"prefix\"]): this {\r\n        const thiss: DPackage = this.thiss as any;\r\n        thiss.uri = uri || '';// || 'org.jodel-react.username';\r\n        thiss.prefix = prefix || '';\r\n        if (thiss.father) {\r\n            if (this.fatherType!.cname === \"DModel\") {\r\n                this.setExternalPtr(thiss.father, \"packages\", \"+=\");\r\n            }\r\n            else {\r\n                this.setExternalPtr(thiss.father, \"subpackages\", \"+=\");\r\n            }\r\n        }\r\n        return this; }\r\n\r\n    DModel(instanceoff?: DModel[\"instanceof\"], isMetamodel?: DModel[\"isMetamodel\"]): this {\r\n        const thiss: DModel = this.thiss as any;\r\n        thiss.packages = []; // packages;\r\n        thiss.isMetamodel = isMetamodel || false;\r\n        thiss.dependencies = [];\r\n        this.setPtr(\"instanceof\", instanceoff || null);\r\n        let lmodel: LModel | undefined = instanceoff ? LPointerTargetable.fromPointer(instanceoff) : undefined;\r\n        this.thiss._persistCallbacks.push(()=>{\r\n            if (lmodel){\r\n                let lthis: LModel = LPointerTargetable.fromD(this.thiss);\r\n                for (let c of lmodel.classes) {\r\n                    let d: DClass = c.__raw;\r\n                    if (d.isSingleton) lthis.addObject({name: d.name}, c, true);\r\n                }\r\n            }\r\n        });\r\n        instanceoff && this.setExternalPtr(instanceoff, \"instances\", \"+=\");\r\n        // todo: check all D.new calls to make sure there are not actions in callbacks in new2() versions that will go outside the Transaction of persist(),, better move ptrs as .new() parameters\r\n        // or make it so new2 splits pointer and non-pointer declarations (or just allow non-ptrs and ptrs must be DSomething.new() explicit parameters)\r\n        thiss._persistCallbacks.push(SetRootFieldAction.create(isMetamodel ? \"m2models\" : \"m1models\", thiss.id, \"+=\", true));\r\n        return this;\r\n    }\r\n\r\n    DOperation(exceptions: DOperation[\"exceptions\"] = [], implementation?: string/*, parameters: DOperation[\"parameters\"] = []*/): this {\r\n        const thiss: DOperation = this.thiss as any;\r\n        // thiss.parameters = parameters;\r\n        thiss.implementation = implementation || 'return \"default placeholder function called\";'\r\n        this.setPtr(\"exceptions\", exceptions);\r\n        this.setExternalPtr(thiss.father, \"operations\", \"+=\");\r\n        return this; }\r\n\r\n    DClass(isInterface: DClass[\"interface\"] = false, isAbstract: DClass[\"abstract\"] = false, isPrimitive: LClassifier[\"isPrimitive\"] = false,\r\n           partial: DClass[\"partial\"] = false, partialdefaultname: DClass[\"partialdefaultname\"] = ''): this {\r\n        const thiss: DClass = this.thiss as any;\r\n        thiss.interface = isInterface;\r\n        thiss.abstract = isAbstract;\r\n        thiss.isPrimitive = isPrimitive;\r\n        thiss.partial = partial;\r\n        thiss.partialdefaultname = partialdefaultname;\r\n        thiss.isSingleton = false;\r\n        thiss.rootable = undefined;\r\n        thiss.sealed = [];\r\n        thiss.final = false;\r\n        thiss.allowCrossReference = false;\r\n        this.setExternalPtr(thiss.father, \"classifiers\", \"+=\");\r\n        this.setExternalRootProperty('ClassNameChanged.'+thiss.id, thiss.name, '', false);\r\n\r\n        // thiss.isClass = !isPrimitive;\r\n        // thiss.isEnum = false;\r\n        return this; }\r\n\r\n    DEnumLiteral(value?: DEnumLiteral[\"value\"]): this { // vv4\r\n        const thiss: DEnumLiteral = this.thiss as any;\r\n        thiss.value = value as any; // undef is ok, handled in getter as automatic ordinal index\r\n        thiss.literal = thiss.name;\r\n        this.setExternalPtr(thiss.father, \"literals\", \"+=\");\r\n        return this; }\r\n\r\n    DEnumerator(literals: DEnumerator[\"literals\"] = []): this {\r\n        const thiss: DEnumerator = this.thiss as any;\r\n        this.setExternalPtr(thiss.father, \"classifiers\", \"+=\");\r\n        this.setPtr(\"literals\", literals);\r\n        // thiss.literals = literals;\r\n        // thiss.isClass = false;\r\n        // thiss.isEnum = true;\r\n        return this; }\r\n    DEdgePoint(): this { return this; }\r\n    DEdge(): this {\r\n        let thiss: DVoidEdge = this.thiss as any;\r\n        return this; }\r\n    DVertex(): this { return this; }\r\n    DVoidEdge(start: DGraphElement[\"id\"] | DGraphElement | LGraphElement | DModelElement[\"id\"] | DModelElement | LModelElement,\r\n              end: DGraphElement[\"id\"] | DGraphElement | LGraphElement | DModelElement[\"id\"] | DModelElement | LModelElement,\r\n              longestLabel?: DEdge[\"longestLabel\"], labels?: DEdge[\"labels\"]): this {\r\n        const thiss: DVoidEdge = this.thiss as any;\r\n        let startid: DGraphElement[\"id\"] = (windoww.LGraphElement as typeof LGraphElement).getNodeId(start);\r\n        let endid: DGraphElement[\"id\"] = (windoww.LGraphElement as typeof LGraphElement).getNodeId(end);\r\n        Log.ex(!startid || !endid, \"cannot create an edge without start or ending nodes\", {start, end, startid, endid});\r\n        thiss.anchorStart = '0';\r\n        thiss.anchorEnd = '0';\r\n        // thiss.startFollow = false;\r\n        // thiss.endFollow = false;\r\n        thiss.midnodes = [];\r\n        thiss.midPoints = []; // the logic part which instructs to generate the midnodes\r\n        // if (!thiss.model && isDModelElementPointer(startid)) thiss.model = startid;\r\n        // thiss.labels = undefined;\r\n        let ll: labelfunc = (e: LVoidEdge, s: EdgeSegment, allNodes: LGraphElement[], allSegments: EdgeSegment[]\r\n        ) => /*defining the edge label (e.start.model as any)?.name + \" ~ \" + (e.end.model as any)?.name */\" (\" + s.length.toFixed(1) + \")\";\r\n        // complex edge label func example: (thiss.longestLabel = ll) but assign to transientnodeproperties or in jsx props instead on this.longestLabel\r\n        thiss.longestLabel = longestLabel;\r\n        this.setPtr(\"start\", startid);\r\n        this.setPtr(\"end\", endid);\r\n        this.setExternalPtr(startid, \"edgesOut\", \"+=\");\r\n        this.setExternalPtr(endid, \"edgesIn\", \"+=\");\r\n\r\n        let gthis: Partial<DVoidEdge> = thiss;\r\n        delete gthis.x;\r\n        delete gthis.y;\r\n        delete gthis.w;\r\n        delete gthis.h;\r\n        delete gthis.edgesIn;\r\n        delete gthis.edgesOut;\r\n        delete gthis.anchors;\r\n        delete gthis.__isDVoidEdge;\r\n        delete (gthis as Partial<DEdge>).__isDEdge;\r\n        return this; }\r\n\r\n    DExtEdge(): this { return this; }\r\n    DRefEdge(): this { return this; }\r\n\r\n    DGraphElement(model: DGraphElement[\"model\"]|null|undefined, parentgraphID: DGraphElement[\"graph\"]|undefined,\r\n                  htmlindex: number = 1): this {\r\n        const thiss: DGraphElement = this.thiss as any;\r\n        thiss.subElements = [];\r\n        thiss.favoriteNode = false;\r\n        thiss.zIndex = htmlindex;\r\n        thiss.isSelected = {};\r\n        thiss.edgesIn = [];\r\n        thiss.edgesOut = [];\r\n        thiss.subElements = [];\r\n        // thiss.state = {id: thiss.id+\".state\", className: thiss.className};\r\n        // 5-way anchors thiss.anchors = {'0':{x:0.5, y:0.5}, '1':{x:0.5, y:0}, '2':{x:1, y:0.5}, '3':{x:0.5, y:1}, '4':{x:0, y:0.5}} as any;\r\n        thiss.anchors = {'0':{x:0.5, y:0.5}, 't':{x:0.5, y:0},\r\n            'tr':{x:1, y:0}, 'r':{x:1, y:0.5}, 'br':{x:1, y:1},\r\n            'b':{x:0.5, y:1},\r\n            'bl':{x:0, y:1}, 'l':{x:0, y:0.5}, 'tl':{x:0, y:0},\r\n        } as any;\r\n        for (let k in (thiss.anchors as GObject)) {\r\n            let a: GObject = thiss.anchors[k];\r\n            if (!a.name) a.name = k;\r\n            if (!a.w) a.w = 15;\r\n            if (!a.h) a.h = 15;\r\n        }\r\n\r\n        this.parentgraphID = parentgraphID;\r\n        this.setPtr(\"model\", model);\r\n        this.setPtr(\"graph\", parentgraphID);\r\n        this.setExternalPtr(thiss.father, \"subElements\", \"+=\");\r\n\r\n        Log.eDev(thiss.father&&DPointerTargetable.fromPointer(thiss.father).subElements.indexOf(thiss.id)!==-1, \"subelemnts+= addition have duplicates\",\r\n            {adding:thiss, d:thiss.father&&DPointerTargetable.fromPointer(thiss.father).subElements.indexOf(thiss.id)});\r\n\r\n        return this;\r\n    }\r\n\r\n    DViewElement(name: string, jsxString: string, vp?: Pointer<DViewPoint>,\r\n                 defaultVSize?: GraphSize, usageDeclarations: string = '', constants: string = '',\r\n                 preRenderFunc: string = '', appliableToClasses: string[] = [], oclCondition: string = '', priority?: number): this {\r\n        const thiss: DViewElement = this.thiss as any;\r\n        const vid = thiss.id;\r\n        let tv = transientProperties.view[vid];\r\n        if (!tv) transientProperties.view[vid] = tv = {} as any;\r\n\r\n        thiss.name = name;\r\n        thiss.appliableToClasses = appliableToClasses;\r\n        thiss.appliableTo = 'Any';\r\n        thiss.jsxString = jsxString;\r\n        thiss.usageDeclarations = usageDeclarations;\r\n        thiss.constants = undefined; // '{}';\r\n        thiss.preRenderFunc = ''; // '() => {return{}}';\r\n        thiss.onDragEnd = thiss.onDragStart = thiss.whileDragging =\r\n        thiss.onResizeEnd = thiss.onResizeStart = thiss.whileResizing = '';\r\n        thiss.onRotationEnd = thiss.onRotationStart = thiss.whileRotating = '';\r\n        thiss.onDataUpdate = '';\r\n        thiss.events = {};\r\n        // thiss.__transient = new DViewTransientProperties();\r\n        thiss.subViews = {};\r\n        thiss.oclCondition = oclCondition || '';\r\n        thiss.jsCondition = '';\r\n        thiss.oclUpdateCondition = '';\r\n        thiss.OCL_NEEDS_RECALCULATION = true;\r\n        thiss.explicitApplicationPriority = undefined as any; //priority as any as number;\r\n        thiss.isExclusiveView = true;\r\n        thiss.size = {};\r\n        thiss.storeSize = false;\r\n        thiss.lazySizeUpdate = true;\r\n        thiss.isValidation = false;\r\n        //thiss.constraints = [];\r\n        thiss.palette = {\r\n            'color-': U.hexToPalette(), //['#ffffff', '#ff0000', '#00ff00', '#0000ff','#aaaaaa', '#ffaaaa', '#aaffaa', '#aaaaff'],\r\n            'background-': U.hexToPalette() // ['#000000', '#33333', '#777777']};\r\n        };\r\n        thiss.css = '';\r\n        thiss.compiled_css = '';\r\n        thiss.css_MUST_RECOMPILE = true;\r\n        thiss.cssIsGlobal = false;\r\n        // thiss.palette = {};\r\n\r\n        // thiss.useSizeFrom = EuseSizeFrom.node;\r\n        // thiss.adaptHeight = false;\r\n        // thiss.adaptWidth = false;\r\n\r\n\r\n        thiss.draggable = true;\r\n        thiss.resizable = true;\r\n        //thiss.display = 'flex' as any;\r\n        thiss.defaultVSize = defaultVSize || new GraphSize(0, 0, 140.6818084716797, 32.52840805053711);\r\n        thiss.adaptWidth = false;\r\n        thiss.adaptHeight = true; //'fit-content';\r\n\r\n        thiss.edgeStartOffset = new GraphPoint(50, 50);\r\n        thiss.edgeEndOffset = new GraphPoint(50, 50);\r\n        thiss.edgeStartOffset_isPercentage = true;\r\n        thiss.edgeEndOffset_isPercentage = true;\r\n        thiss.edgeStartStopAtBoundaries = true;\r\n        thiss.edgeEndStopAtBoundaries = true;\r\n        thiss.bendingMode = EdgeBendingMode.Bezier_quadratic;\r\n        thiss.edgeGapMode = EdgeGapMode.center;\r\n        thiss.edgePointCoordMode = CoordinateMode.relativeOffset;\r\n        thiss.usageDeclarations = undefined;\r\n\r\n        /// edge only\r\n\r\n        thiss.edgeHeadSize = new GraphPoint(20, 20);\r\n        thiss.edgeTailSize = new GraphPoint(20, 20);\r\n        if (thiss.className !== 'DViewElement') return this;\r\n        const user = LUser.fromPointer(DUser.current);\r\n        // const project = user?.project; if(!project) return this;\r\n        if (!vp) vp = user?.project?.activeViewpoint.id || Defaults.viewpoints[0];\r\n        if (vp !== 'skip') {\r\n            // let dvp = DPointerTargetable.fromPointer(vp);\r\n            // let subviews = {...dvp.subViews}; subviews[thiss.id] = 1.5;\r\n            // this.setExternalPtr(vp, 'subViews', '', subviews);\r\n            this.setPtr('viewpoint', vp);\r\n        }\r\n\r\n        this.setExternalPtr(this.fatherPtr as Pointer<DViewElement>, 'subViews', '+=', {[thiss.id]: 1.5});\r\n        transientProperties.view[thiss.id] = {} as any;\r\n\r\n        // let trview = transientProperties.view[thiss.id];\r\n        // trview.?? = ???\r\n\r\n        TRANSACTION('recompile jsx & more', () => {\r\n            // add relation to vp\r\n            for(let key of (windoww.DViewElement as typeof DViewElement).RecompileKeys)\r\n                this.setExternalRootProperty('VIEWS_RECOMPILE_'+key, thiss.id, '+=', false) // is pointer, but no need to set pointedby\r\n        })\r\n\r\n        // this.setExternalPtr(project.id, 'views', '+=');\r\n        // this.setExternalPtr(project.id, 'stackViews', '+=');\r\n        return this;\r\n    }\r\n\r\n    DViewPoint(): this {\r\n        const thiss: DViewPoint = (this.thiss) as any;\r\n        const user = LUser.fromPointer(DUser.current);\r\n        const project = user?.project;\r\n        if (!project) return this;\r\n        this.setExternalPtr(project.id, 'viewpoints', '+=');\r\n        // thiss.cssIsGlobal = true;\r\n        // thiss._persistCallbacks.push( SetFieldAction.create(project.id, 'stackViews', [], '', false) );\r\n        return this;\r\n    }\r\n\r\n    DProject(type: DProject['type'], name: string, state: DProject['state'], m2: DProject['metamodels'], m1: DProject['models'], id?: DProject['id']): this {\r\n        const _this: DProject = U.wrapper<DProject>(this.thiss);\r\n        _this.metamodels = m2;\r\n        _this.models = m1;\r\n        _this.type = type;\r\n        _this.name = name;\r\n        _this.state = state || '';\r\n        if(id) _this.id = id;\r\n        _this.favorite = {};\r\n        _this.description = 'A new Project. Created by ' + (DPointerTargetable.from(DUser.current) as DUser).nickname + ' @' + new Date().toLocaleString();\r\n        this.setExternalPtr(DUser.current, 'projects', '+=');\r\n        return this;\r\n    }\r\n\r\n    static DGraph_maxID: number = 0;\r\n    public static DGraph_makeID(modelid: DGraph[\"model\"]): Pointer<DGraph, 1, 1, LGraph> {\r\n        if (!modelid) modelid = \"shapeless\";\r\n        return modelid + '_graph' + Constructors.DGraph_maxID++;\r\n    }\r\n    DGraph(): this {\r\n        const thiss: DGraph = this.thiss as any;\r\n        thiss.graph = thiss.id; // no setPtr because i want to avoid circular pointedby reference\r\n        thiss.zoom = new GraphPoint(1, 1);\r\n        thiss.offset = new GraphSize(0, 0);  // GraphSize.apply(this, [0, 0, 0 ,0]);\r\n        thiss._subMaps = {zoom: true, graphSize: true}\r\n\r\n        const user: LUser = LUser.fromPointer(DUser.current);\r\n        if (thiss.className === 'DGraph') { // to exclude GraphVertex\r\n            user.project && this.setExternalPtr(user.project.id, 'graphs', \"+=\");\r\n            thiss.x = 0;\r\n            thiss.y = 0;\r\n            thiss.w = 0;\r\n            thiss.h = 0;\r\n        }\r\n        return this; }\r\n\r\n    DVoidVertex(defaultVSize?: InitialVertexSize): this {\r\n        const thiss: DVoidVertex = this.thiss as any;\r\n        /*[]{}<>\r\n?'^~\r\n&&||\\+\r\n6nb*/\r\n\r\n        if (!defaultVSize) {\r\n            let graph = this.parentgraphID ? D.from(this.parentgraphID) as DGraph : undefined;\r\n            if (graph) switch (thiss.className) {\r\n                case 'DGraphVertex':\r\n                case 'DVertex':\r\n                    thiss.x = -graph.offset.x + graph.offset.w/2;\r\n                    thiss.y = -graph.offset.y + graph.offset.h/2;\r\n                    break;\r\n            }\r\n        }\r\n        let defaultVSizeObj: InitialVertexSizeObj | undefined;\r\n        let defaultVSizeFunc: InitialVertexSizeFunc;\r\n        thiss.isResized = false;\r\n\r\n        let lvertex: LVoidVertex = LPointerTargetable.fromD(thiss);\r\n        if (typeof defaultVSize !== \"function\") { defaultVSizeObj = defaultVSize; }\r\n        else {\r\n            defaultVSizeFunc = defaultVSize;\r\n            try { defaultVSizeObj = defaultVSizeFunc(lvertex.father, lvertex); }\r\n            catch (e) { Log.exx(\"Error in user DefaultVSize function:\", {e, defaultVSizeFunc, txt:defaultVSizeFunc.toString()}); }\r\n        }\r\n        if (defaultVSizeObj) {\r\n            if (defaultVSizeObj.x !== undefined) thiss.x = defaultVSizeObj.x;\r\n            if (defaultVSizeObj.y !== undefined) thiss.y = defaultVSizeObj.y;\r\n            if (defaultVSizeObj.w !== undefined) thiss.w = defaultVSizeObj.w;\r\n            if (defaultVSizeObj.h !== undefined) thiss.h = defaultVSizeObj.h;\r\n\r\n            if ((defaultVSizeObj as any).index >= 0 && thiss.className === \"DEdgePoint\") {\r\n                let updateEPindex = () => {\r\n                    let lep = lvertex as LEdgePoint;\r\n                    let le: LVoidEdge = lep.father;\r\n                    let de: DVoidEdge = le.__raw;\r\n                    let subelements = [...de.subElements];\r\n                    U.arrayRemoveAll(subelements, thiss.id);\r\n                    subelements.splice(defaultVSizeObj?.index as number, 0, thiss.id);\r\n                    // console.log(\"setting subelements\", {oldsubelements, subelements, de, le, thiss});\r\n                    le.subElements = subelements as any;\r\n                    // todo: this might break \"pointedBy\" x984\r\n                }\r\n                // updateEPindex();\r\n                // it's already wrapped in a callback\r\n                // but needs a second one because after node is created, id is auto-appended to this collection\r\n                // and i need to rewrite that append by inserting my own customized index position\r\n                console.log(\"setting subelements 0\", {updateEPindex});\r\n                setTimeout(updateEPindex, 0);\r\n                // NB: do not use this.callbacks.push because the body of this func is executed after Constructors.end() so end() can never find and execute it.\r\n            }\r\n        }\r\n\r\n        return this; }\r\n\r\n\r\n}\r\n// export const Constructors = new _Constructors();\r\n\r\n@RuntimeAccessible(\"DPointerTargetable\")\r\nexport class DPointerTargetable extends RuntimeAccessibleClass {\r\n    static defaultComponent: (ownProps: GObject, children?: (string | React.Component)[]) => React.ReactElement; //\r\n    public static maxID: number = 0;\r\n    public static logic: typeof LPointerTargetable;\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static pendingCreation: Record<Pointer<DPointerTargetable, 1, 1>, DPointerTargetable> = {};\r\n    clonedCounter?: number;\r\n    _storePath?: string[];\r\n    _subMaps?: Dictionary<string, boolean>;\r\n    id!: Pointer<DPointerTargetable, 1, 1, LPointerTargetable>;\r\n    // pointedBy: DocString<'path in store'>[] = []; // NB: potrebbe contenere puntatori invalidi.\r\n    // se viene cancellato un intero oggetto A che contiene una lista di puntatori, gli oggetti che puntano ad A rimuovono A dai loro \"poitnedBy\",\r\n    // ma gli oggetti puntati da A tramite sotto-oggetti o attributi (subviews...) non vengono aggiornati in \"pointedby\"\r\n    pointedBy: PointedBy[] = [];\r\n    public className!: string;\r\n    public __readonly!: boolean;\r\n    _state: GObject = {};\r\n    name?:string;\r\n\r\n    static defaultname<L extends LModelElement = LModelElement>(startingPrefix: string | ((meta:L)=>string), father?: Pointer | DPointerTargetable | ((a:string)=>boolean), metaptr?: Pointer | null): string {\r\n        let lfather: LModelElement;\r\n        // startingPrefix = \"model_\", father = ((name: string) => !dmodelnames.includes(name))\r\n        if (father) {\r\n            if (typeof father === \"string\" || (father as any).className) { // Pointer or D\r\n                lfather = LPointerTargetable.wrap(father as DModelElement) as LModelElement;\r\n                if (!lfather) return (typeof startingPrefix === \"string\" ? startingPrefix : \"unnamed_elem\"); // can happen during parse when father ptr exist but it's not in store yet. not a prob\r\n                if (typeof startingPrefix !== \"string\") {\r\n                    let meta = LPointerTargetable.from(metaptr as Pointer);\r\n                    startingPrefix = startingPrefix(meta as L);\r\n                }\r\n                const childrenNames: (string)[] = lfather.children.map(c => (c as LNamedElement)?.name);\r\n                return U.increaseEndingNumber(startingPrefix + '0', false, false, (newname) => childrenNames.indexOf(newname) >= 0);\r\n            }\r\n            else {\r\n                let condition: (a:string)=>boolean = father as any;\r\n                return U.increaseEndingNumber(startingPrefix + '0', false, false, condition);\r\n            }\r\n        }\r\n        return startingPrefix + \"1\"; }\r\n\r\n    public static new(...a:any): DPointerTargetable { //father?: Pointer, persist: boolean = false, fatherType?: Constructor, ...a:any): DPointerTargetable {\r\n        Log.exx(\"cannot instantiate abstract class DPointerTargetable\");\r\n        return null as any;\r\n        // return new Constructors(new DPointerTargetable('dwc'), father, persist, fatherType).DPointerTargetable().end();\r\n    }\r\n    constructor(fakearg_detectwrongcalls:'dwc') {\r\n        super();\r\n        if (!fakearg_detectwrongcalls) throw new Error( \"cannot build D-objects using new keyword, use the static D-Class.new method instead\");\r\n    }\r\n\r\n    static fromL<LX extends LPointerTargetable,\r\n        DX = LX extends LEnumerator ? LEnumerator : (LX extends LAttribute ? LAttribute : (LX extends LReference ? LReference : (LX extends LRefEdge ? LRefEdge : (LX extends LExtEdge ? LExtEdge : (LX extends LDataType ? LDataType : (LX extends LClass ? LClass : (LX extends LStructuralFeature ? LStructuralFeature : (LX extends LParameter ? LParameter : (LX extends LOperation ? LOperation : (LX extends LEdge ? LEdge : (LX extends LEdgePoint ? LEdgePoint : (LX extends LGraphVertex ? LGraphVertex : (LX extends LModel ? LModel : (LX extends LValue ? LValue : (LX extends LObject ? LObject : (LX extends LEnumLiteral ? LEnumLiteral : (LX extends LPackage ? LPackage : (LX extends LClassifier ? LClassifier : (LX extends LTypedElement ? LTypedElement : (LX extends LVertex ? LVertex : (LX extends LVoidEdge ? LVoidEdge : (LX extends LVoidVertex ? LVoidVertex : (LX extends LGraph ? LGraph : (LX extends LNamedElement ? LNamedElement : (LX extends LAnnotation ? LAnnotation : (LX extends LGraphElement ? LGraphElement : (LX extends LMap ? LMap : (LX extends LModelElement ? LModelElement : (LX extends LUser ? LUser : (LX extends LPointerTargetable ? LPointerTargetable : (ERROR)))))))))))))))))))))))))))))))\r\n        >(data: LX): DX {\r\n        return data.__raw as any;\r\n    }\r\n\r\n\r\n    static fromPointer<// LOW extends number, UPP extends number | 'N',\r\n        T extends Pointer | Pointer[], // <DPointerTargetable, 1, 'N', LPointerTargetable>,\r\n        DDD extends (T extends Pointer<infer D> ? D : 'undefined D'),\r\n        LOW extends (T extends Pointer<any, infer LO> ? LO : 'undefined_upp'),\r\n        UPP extends (T extends Pointer<any, number, infer UP> ? UP : 'undefined_low'),\r\n\r\n        DDDARR extends (T extends Pointer<infer D>[] ? D : 'undefined_DARR'),\r\n        LOWARR extends (T extends Pointer<any, infer LO>[] ? LO : 'undefined_uppARR'),\r\n        UPPARR extends (T extends Pointer<any, number, infer UP>[] ? 'UP_is_N' : 'undefined_lowARR'),\r\n\r\n        RET = UPPARR extends 'UP_is_N' ?\r\n            (DDDARR[]) : // 0...N\r\n            (UPP extends 1 ? (LOW extends 0 ? DDD | null : DDD) : // 0...1 && 1...1\r\n                (LOW extends 1 ? DDD : undefined)  //1...1\r\n                ),\r\n        INFERRED = {ret: RET, upp: UPP, low:LOW, ddd: DDD, dddARR: DDDARR, lowARR: LOWARR, uppARR: UPPARR},>(ptr: T, s?: DState)\r\n        : RET {\r\n        s = s || store.getState();\r\n        if (!ptr) { return ptr as any; }\r\n        if (Array.isArray(ptr)) {\r\n            return ptr.map( (p: Pointer) => DPointerTargetable.fromPointer(p, s)) as any;\r\n        }\r\n        if (typeof ptr !== \"string\") {\r\n            console.error(\"wrong parameter in DPointerTargetable.fromPointers()\", ptr);\r\n            throw new Error(\"wrong parameter in DPointerTargetable.fromPointers()\");\r\n        }\r\n        if (s && s.idlookup[ptr as string]) return s.idlookup[ptr as string] as any;\r\n        return (DPointerTargetable.pendingCreation[ptr as string] || s.idlookup[ptr as string]) as any;\r\n        // return ((s || store.getState()).idlookup[ptr as string] || DPointerTargetable.pendingCreation[ptr as string]) as any;\r\n    }\r\n\r\n    static from<// LOW extends number, UPP extends number | 'N',\r\n        PTR extends Pointer | Pointer[], // <DPointerTargetable, 1, 'N', LPointerTargetable>,\r\n        DDD extends (PTR extends Pointer<infer D> ? D : 'undefined D'),\r\n        LOW extends (PTR extends Pointer<any, infer LO> ? LO : 'undefined_upp'),\r\n        UPP extends (PTR extends Pointer<any, number, infer UP> ? UP : 'undefined_low'),\r\n\r\n        DDDARR extends (PTR extends Pointer<infer D>[] ? D : 'undefined_DARR'),\r\n        LOWARR extends (PTR extends Pointer<any, infer LO>[] ? LO : 'undefined_uppARR'),\r\n        UPPARR extends (PTR extends Pointer<any, number, infer UP>[] ? 'UP_is_N' : 'undefined_lowARR'),\r\n\r\n        LX extends LPointerTargetable,\r\n\r\n        RETPTR = UPPARR extends 'UP_is_N' ?\r\n            (DDDARR[]) : // 0...N\r\n            (UPP extends 1 ? (LOW extends 0 ? DDD | null : DDD) : // 0...1 && 1...1\r\n                (LOW extends 1 ? DDD : undefined)  //1...1\r\n                ),\r\n        // DX = LX extends LEnumerator ? DEnumerator : (LX extends LAttribute ? DAttribute : (LX extends LReference ? DReference : (LX extends LDataType ? DDataType : (LX extends LClass ? DClass : (LX extends LStructuralFeature ? DStructuralFeature : (LX extends LParameter ? DParameter : (LX extends LOperation ? DOperation : (LX extends LModel ? DModel : (LX extends LValue ? DValue : (LX extends LObject ? DObject : (LX extends LEnumLiteral ? DEnumLiteral : (LX extends LPackage ? DPackage : (LX extends LClassifier ? DClassifier : (LX extends LTypedElement ? DTypedElement : (LX extends LNamedElement ? DNamedElement : (LX extends LAnnotation ? DAnnotation : ('ERROR'))))))))))))))))),\r\n        DX = LX extends LEnumerator ? DEnumerator : (LX extends LAttribute ? DAttribute : (LX extends LReference ? DReference : (LX extends LRefEdge ? DRefEdge : (LX extends LExtEdge ? DExtEdge : (LX extends LDataType ? DDataType : (LX extends LClass ? DClass : (LX extends LStructuralFeature ? DStructuralFeature : (LX extends LParameter ? DParameter : (LX extends LOperation ? DOperation : (LX extends LEdge ? DEdge : (LX extends LEdgePoint ? DEdgePoint : (LX extends LGraphVertex ? DGraphVertex : (LX extends LModel ? DModel : (LX extends LValue ? DValue : (LX extends LObject ? DObject : (LX extends LEnumLiteral ? DEnumLiteral : (LX extends LPackage ? DPackage : (LX extends LClassifier ? DClassifier : (LX extends LTypedElement ? DTypedElement : (LX extends LVertex ? DVertex : (LX extends LVoidEdge ? DVoidEdge : (LX extends LVoidVertex ? DVoidVertex : (LX extends LGraph ? DGraph : (LX extends LNamedElement ? DNamedElement : (LX extends LAnnotation ? DAnnotation : (LX extends LGraphElement ? DGraphElement : (LX extends LMap ? DMap : (LX extends LModelElement ? DModelElement : (LX extends LUser ? DUser : (LX extends LPointerTargetable ? DPointerTargetable : (ERROR))))))))))))))))))))))))))))))),\r\n        RET = DX extends 'ERROR' ? RETPTR : (RETPTR extends DX ? RETPTR : DX),\r\n        INFERRED = {ret: RET, RETPTR:RETPTR, upp: UPP, low:LOW, ddd: DDD, dddARR: DDDARR, lowARR: LOWARR, uppARR: UPPARR, LX:LX, DX:DX}>(ptr: PTR | LX, s?: DState)\r\n        : RET {\r\n        if (!ptr) return ptr as any;\r\n        if (Array.isArray(ptr)) return DPointerTargetable.fromArr(ptr, true, s) as any;\r\n        if ((ptr as LX).__isProxy) return (ptr as LX).__raw as any;\r\n        if (typeof ptr === \"string\") {\r\n            if (s && s.idlookup[ptr as string]) return s.idlookup[ptr as string] as any;\r\n            return (DPointerTargetable.pendingCreation[ptr as string] || store.getState().idlookup[ptr as string]) as any;\r\n        }\r\n        else if ((ptr as any as GObject<DX>).className) return ptr as any;\r\n        else return undefined as any;\r\n    }\r\n    public static fromArr(arr:any[], filter: boolean = true, s?: DState): DPointerTargetable[]{\r\n        let ret: (DPointerTargetable)[] = [];\r\n        s = s || store.getState();\r\n        for (let a of arr) {\r\n            let d = DPointerTargetable.from(a, s);\r\n            if (!filter || d) ret.push(d as DPointerTargetable);\r\n        }\r\n        return ret;\r\n    }\r\n    //static from0(a: any, ...aa: any): any { return null; }\r\n    static writeable<LX extends LPointerTargetable, WX = LtoW<LX>>(l: LX): WX { return l as any; }\r\n\r\n    _persistCallbacks!: ((() => void) | Action)[]; // deleted when it becomes persistent\r\n    _derivedSubElements!: DModelElement[]; // deleted when it becomes persistent\r\n    // persist(): void { Constructors.persist(this); }// deleted when it becomes persistent\r\n\r\n\r\n    /*protected */derivedMap!: Dictionary<string, DerivedD>;\r\n}\r\n\r\nRuntimeAccessibleClass.set_extend(RuntimeAccessibleClass, DPointerTargetable);\r\n/*\r\nlet d0: LClassifier = null as any;\r\nlet ptrr: Pointer<DPackage, 1, 'N', LPackage> = null as any;\r\nlet ptr1: Pointer<DPackage, 1, 1, LPackage> = null as any;\r\nlet dd = DPointerTargetable.from(d0.id);\r\n*/\r\n\r\n\r\n/*\r\ntype Pack1<D extends DPointerTargetable, L extends LPointerTargetable = DtoL<D>, P extends Pointer<D, 0, 1, L> = Pointer<D, 0, 1, L>, R = {D:D, L:L, P:P} > = P|D|L\r\ntype PackArr<D extends DPointerTargetable, L extends LPointerTargetable = DtoL<D>, P extends Pointer<D, 0, 1, L> = Pointer<D, 0, 1, L> , ARR = Pack1<D>> = (ARR)[];\r\ntype Pack<D extends DPointerTargetable, L extends LPointerTargetable = DtoL<D>, P extends Pointer<D, 0, 1, L> = Pointer<D, 0, 1, L> , ARR = Pack1<D>> = ARR | (ARR)[];*/\r\n\r\n\r\n\r\n@RuntimeAccessible('Pointers')\r\nexport class Pointers{\r\n    public static ESTRING = 'Pointer_ESTRING';\r\n\r\n    static filterValid<P extends (Pointer | Pointer[]) = any, RET = P extends Pointer[] ? P : P | null>\r\n    (p: P): P | null {\r\n        const pointerval: DPointerTargetable | DPointerTargetable[] = DPointerTargetable.from(p);\r\n        if (Array.isArray(pointerval)) return pointerval.filter( p => !!p).map( p => p.id) as P;\r\n        if (!pointerval) return null;\r\n        return pointerval.id as P; }\r\n\r\n    static fromArr<D extends DPointerTargetable, L extends LPointerTargetable, P extends Pointer> (val: (P | D | L | null | undefined)[] |  (P | D | L | null | undefined)): P[] {\r\n        if (!val) val = [];\r\n        if (!Array.isArray(val)) { val = [val]; }\r\n        if (!val.length) { return []; }\r\n        if ((val[0] as any).id) { val = (val as any as (LModelElement | DModelElement)[]).filter(v => !!v).map( (v) => v.id) as any[]; }\r\n        return val.filter( v => !!v) as any[]; }\r\n\r\n    fromm<D extends DPointerTargetable, L extends LPointerTargetable, P extends Pointer> (val: (P | D | L)): P | null { return !val ? null : (val as any).id; }\r\n\r\n    from0<// LOW extends number, UPP extends number | 'N',\r\n        PTR extends Pointer | Pointer[], // <DPointerTargetable, 1, 'N', LPointerTargetable>,\r\n        // DDD extends (PTR extends Pointer<infer D> ? D : 'undefined_D'),\r\n        LOW extends (PTR extends Pointer<any, infer LO> ? LO : 'undefined_upp'),\r\n        UPP extends (PTR extends Pointer<any, number, infer UP> ? UP : 'undefined_low'),\r\n        DDD extends (PTR extends Pointer<any, number, any, infer LL> ? LL : 'undefined_L'),\r\n\r\n        LOWARR extends (PTR extends Pointer<any, infer LO>[] ? LO : 'undefined_uppARR'),\r\n        UPPARR extends (PTR extends Pointer<any, number, infer UP>[] ? 'UP_is_N' : 'undefined_lowARR'),\r\n        DDDARR extends (PTR extends Pointer<any, any, any, infer LL>[] ? LL : 'undefined_LARR'),\r\n\r\n        DX extends DPointerTargetable,\r\n        LX extends LPointerTargetable,\r\n        WX extends WPointerTargetable,\r\n        RETPTR = UPPARR extends 'UP_is_N' ?\r\n            (DDDARR[]) : // 0...N\r\n            (UPP extends 1 ? (LOW extends 0 ? DDD | null : DDD) : // 0...1 && 1...1\r\n                (LOW extends 1 ? DDD : undefined)  //1...1\r\n                ),\r\n\r\n\r\n        // DX = LX extends LEnumerator ? DEnumerator : (LX extends LAttribute ? DAttribute : (LX extends LReference ? DReference : (LX extends LDataType ? DDataType : (LX extends LClass ? DClass : (LX extends LStructuralFeature ? DStructuralFeature : (LX extends LParameter ? DParameter : (LX extends LOperation ? DOperation : (LX extends LModel ? DModel : (LX extends LValue ? DValue : (LX extends LObject ? DObject : (LX extends LEnumLiteral ? DEnumLiteral : (LX extends LPackage ? DPackage : (LX extends LClassifier ? DClassifier : (LX extends LTypedElement ? DTypedElement : (LX extends LNamedElement ? DNamedElement : (LX extends LAnnotation ? DAnnotation : ('ERROR'))))))))))))))))),\r\n        LXX = DtoL<DX>,\r\n        DXX = LtoD<LX>,\r\n        LXFinal = LXX extends 'ERROR' ? LX : LXX,\r\n        DXFinal = DXX extends 'ERROR' ? DX : DXX,\r\n        RET = {d: DXFinal, l:LXFinal}, // Pointer<DX, 0 | 1, 1 | 'N', LX>\r\n        INFERRED = {ret: RET, RETPTR: RETPTR, LXX: LXX, DXX: DXX, upp: UPP, low:LOW, ddd: DDD, dddARR: DDDARR, lowARR: LOWARR, uppARR: UPPARR, LX:LX, DX:DX}>(data: LX | DX | WX)\r\n        : INFERRED {\r\n        return null as any;\r\n    }\r\n\r\n\r\n    static from00<\r\n        // LOW extends number, UPP extends number | 'N',\r\n        // DDD extends (PTR extends Pointer<infer D> ? D : 'undefined_D'),\r\n        DWL extends {id: any},\r\n        // PCK extends (T extends Pack<infer PPP> ? PPP : never),\r\n        //ISARR extends (T extends any[] ? true : false),\r\n        // PCK1 extends (T extends any[] ? null : T extends Pack1<infer PPP> ? PPP : never), //         PCK1 extends (T extends any[] ? true : false),\r\n        // PCKA extends (T extends PackArr<infer PPP> ? PPP : 'undefined_arrpack'),\r\n        // PTR extends DWL[\"id\"], // <DPointerTargetable, 1, 'N', LPointerTargetable>,\r\n        // T extends DWL | DWL[] | null | undefined,\r\n        /*DX extends (PTR extends Pointer<infer D0> ? D0 : 'undefined_D'),\r\n        LOW extends (PTR extends Pointer<any, infer LO> ? LO : 'undefined_upp'),\r\n        UPP extends (PTR extends Pointer<any, number, infer UP> ? UP : 'undefined_low'),\r\n        LX extends (PTR extends Pointer<any, number, any, infer LL> ? LL : 'undefined_L'),\r\n\r\n        LOWARR extends (PTR extends Pointer<any, infer LO>[] ? LO : 'undefined_uppARR'),\r\n        UPPARR extends (PTR extends Pointer<any, number, infer UP>[] ? 'UP_is_N' : 'undefined_lowARR'),\r\n        DDDARR extends (PTR extends Pointer<any, any, any, infer LL>[] ? LL : 'undefined_LARR'),\r\n        RET = DX extends DPointerTargetable ? ( LOW extends number ? ( UPP extends number ? ( LX extends LPointerTargetable ? Pointer<DX, LOW, UPP, LX> : '_notret_L_') : '_notret_UPP_') : '_notret_LOW_') : '_notret_D_'\r\n        */\r\n        PTRPARAM = Pointer | Pointer[],\r\n        T = Exclude<DWL | DWL[] | PTRPARAM, unknown[]>,\r\n        // @ts-ignore\r\n        PTR = T extends null ? null : T extends undefined ? null : (T extends PTRPARAM ? T : (T extends any[] ? T[number]['id'][] : T['id'])),\r\n        // RET extends Pointer<DPointerTargetable, any, any, LPointerTargetable> = T extends DWL ? DWL[\"id\"] : (T extends DWL[] ? DWL[\"id\"] : null),\r\n        // INF = { PCK:PCK, ISARR: ISARR,  PTR: PTR, DWL: DWL, RET: RET}, // {DD:DD, LL: LL}//\r\n        >(data: T | T[] ): PTR { // RET | RET[] {\r\n        if (Array.isArray(data)) return data.filter(d => !!d).map(d => (typeof d === \"string\" ? d : (d as any as DWL).id)) as any;\r\n        else return (data ? (data as any).id : null);\r\n    } // stavolta fai infer so D|l.id\r\n\r\n\r\n    public static from<DX extends DPointerTargetable>(data:DX): DX[\"id\"]; // | {D:any};\r\n    public static from<DX extends DPointerTargetable>(data:DX[]): DX[\"id\"][]; // | {DD:any};\r\n    public static from<LX extends LPointerTargetable>(data:LX): LX[\"id\"]; // | {L:any};\r\n    public static from<LX extends LPointerTargetable>(data:LX[]): LX[\"id\"][]; // | {LL:any};\r\n    public static from<WX extends WPointerTargetable>(data:WX): WX[\"id\"]; // | {W:any};\r\n    public static from<WX extends WPointerTargetable>(data:WX[]): WX[\"id\"][]; // | {WW:any};\r\n    public static from<PTR extends Pointer<DPointerTargetable, 1, 1, LPointerTargetable>>(data:PTR): PTR; // | {P:any};\r\n    public static from<PTR extends Pointer<DPointerTargetable, 1, 1, LPointerTargetable>>(data:PTR[]): PTR[]; // | {PP:any};\r\n    public static from<T extends LPointerTargetable>(data:Pack1<T>): Pointer<LtoD<T>, 1, 1, T>; //{TEST1:any};\r\n    public static from<T extends LPointerTargetable>(data:Pack1<T>[]): Pointer<LtoD<T>, 1, 1, T>[]; //{TEST111:any};\r\n    public static from<T extends LPointerTargetable>(data:Pack<T>): Pointer<LtoD<T>, 1, 1, T>[]; //{TEST0:any};\r\n    public static from<P extends Pack<T> | undefined, T extends LPointerTargetable>(data: P): Pointer<LtoD<T>, 1, 1, T>[]; //{TEST0:any};\r\n    public static from<T extends LPointerTargetable>(data:PackArr<T>): Pointer<LtoD<T>, 1, 1, T>[]; //{TESTARR:any};\r\n    public static from<T extends LPointerTargetable>(data:Pack1<T[]>): Pointer<LtoD<T>, 1, 1, T>; //{TEST1:any};\r\n    public static from<T extends LPointerTargetable>(data:Pack1<T[]>[]): Pointer<LtoD<T>, 1, 1, T>[]; //{TEST111:any};\r\n    public static from<T extends LPointerTargetable>(data:Pack<T[]>): Pointer<LtoD<T>, 1, 1, T>[]; //{TEST0:any};\r\n    public static from<T extends LPointerTargetable>(data:PackArr<T[]>): Pointer<LtoD<T>, 1, 1, T>[]; //{TESTARR:any};\r\n\r\n    /*\r\n        public static from(data:undefined): undefined; // | {D:any};\r\n        public static from<DX extends DPointerTargetable | undefined | null>(data:DX): DX extends DPointerTargetable ? DX[\"id\"] : DX; // | {D:any};\r\n        public static from<DX extends DPointerTargetable | undefined | null>(data:DX[]): DX extends DPointerTargetable ? DX[\"id\"][] : DX; // | {DD:any};\r\n        public static from<LX extends LPointerTargetable | undefined | null>(data:LX): LX extends LPointerTargetable ? LX[\"id\"] : LX; // | {L:any};\r\n        public static from<LX extends LPointerTargetable | undefined | null>(data:LX[]): LX extends LPointerTargetable ? LX[\"id\"][] : LX; // | {LL:any};\r\n        public static from<WX extends WPointerTargetable | undefined | null>(data:WX): WX extends WPointerTargetable ? WX[\"id\"] : WX; // | {W:any};\r\n        public static from<WX extends WPointerTargetable | undefined | null>(data:WX[]): WX extends WPointerTargetable ? WX[\"id\"][] : WX; // | {WW:any};\r\n        public static from<PTR extends Pointer<DPointerTargetable, 1, 1, LPointerTargetable> | undefined | null>(data:PTR): PTR extends Pointer<DPointerTargetable, 1, 1, LPointerTargetable> ? PTR : PTR; // | {P:any};\r\n        public static from<PTR extends Pointer<DPointerTargetable, 1, 1, LPointerTargetable> | undefined | null>(data:PTR[]): PTR extends Pointer<DPointerTargetable, 1, 1, LPointerTargetable> ? PTR[] : PTR; // | {PP:any};\r\n        public static from<T extends LPointerTargetable | undefined | null>(data:Pack1<T>): T extends LPointerTargetable ? Pointer<LtoD<T>, 1, 1, T> : T; //{TEST1:any};\r\n        public static from<T extends LPointerTargetable | undefined | null>(data:Pack1<T>[]): T extends LPointerTargetable ? Pointer<LtoD<T>, 1, 1, T>[] : T; //{TEST111:any};\r\n        public static from<T extends LPointerTargetable | undefined | null>(data:Pack<T>): T extends LPointerTargetable ? Pointer<LtoD<T>, 1, 1, T>[] : T; //{TEST0:any};\r\n        public static from<T extends LPointerTargetable | undefined | null>(data:PackArr<T>): T extends LPointerTargetable ? Pointer<LtoD<T>, 1, 1, T>[] : T; //{TESTARR:any};\r\n        // public static from<T extends LPointerTargetable | undefined | null>(data:Pack1<T[]>): T extends LPointerTargetable ? Pointer<LtoD<T>, 1, 1, T> : T; //{TEST1:any};\r\n        // public static from<T extends LPointerTargetable | undefined | null>(data:Pack1<T[]>[]): T extends LPointerTargetable ? Pointer<LtoD<T>, 1, 1, T>[] : T; //{TEST111:any};\r\n        // DDD extends (T extends Pointer<infer D> ? D : 'undefined D'),*/\r\n    // returns:\r\n    // if ptr is unvalid = undefined;\r\n    // if [ptr] is unvalid = []\r\n    public static from<TT extends Pack<LPointerTargetable[]> | undefined | null,\r\n        // @ts-ignore\r\n        T extends (TT extends Pack<infer PTYPE> ? PTYPE : undefined)>(data:T): T extends null | undefined ? T : Pointer<LtoD<T>, 1, 1, T>[]; //{TEST0:any};\r\n    // @ts-ignore\r\n    public static from<T extends LPointerTargetable | undefined | null>(data: PackArr<T[]>): T extends null | undefined ? T : Pointer<LtoD<T>, 1, 1, T>[]; //{TESTARR:any};\r\n    public static from(data:null | undefined): null; // | {Dn:any};\r\n    public static from(data:(null | undefined)[]): []; // | {Dnn:any};\r\n    public static from(data:(null | undefined) | (null | undefined)[]): []; // | {Dn0:any};\r\n\r\n    // function from<PTR extends Pointer<DPointerTargetable, 1, 1, LPointerTargetable>>(data:unknown | unknown[]): PTR | PTR[] | GObject {\r\n    public static from<T extends LClass, PTR extends Pointer<DPointerTargetable, 1, 1, LPointerTargetable>>(data:unknown | unknown[]): null | PTR | PTR[]{\r\n        if (!data) return null;\r\n        if (Array.isArray(data)) return data.filter(d => !!d).map(d => (typeof d === \"string\" ? d : (d as any)?.id)) as any;\r\n        return typeof data === \"string\" ? data : (data as any)?.id;\r\n    }\r\n\r\n    static isPointer(val: any, state?: DState, doArrayCheck: boolean = false): val is Pointer {\r\n        // might cause endless loop if there are subarrays in a containment loop.\r\n        if (doArrayCheck && Array.isArray(val)) return (val as any[]).some((v) => Pointers.isPointer(val, state, true));\r\n        if (state) return DPointerTargetable.from(val, state);\r\n        return typeof val === \"string\" ? val.includes(\"Pointer\") : false;\r\n    }\r\n}\r\n\r\n/*\r\nexport type Pack1<L extends LPointerTargetable | undefined | null,\r\n    // L extends LPointerTargetable | undefined | null = LL extends LPointerTargetable[] ? LPointerTargetable : null | undefined,\r\n    D extends (L extends LPointerTargetable ? LtoD<L> : undefined | null) = (L extends LPointerTargetable ? LtoD<L> : undefined | null)> =\r\n    L extends LPointerTargetable ? ( D extends DPointerTargetable ? D | L /*| LtoW<L>* / | Pointer<D, 1, 1, L> : L) : undefined;\r\nexport type PackArr<LL extends orArr<LPointerTargetable> | undefined | null,\r\n    L extends LPointerTargetable | undefined | null = LL extends undefined | null ? undefined : unArr<LL>> = Pack1<L>[];\r\nexport type Pack<\r\n    LL extends orArr<LPointerTargetable> | undefined | null,\r\n    L extends unArr<LL> = unArr<LL>,\r\n    // L extends (LL extends orArr<LPointerTargetable> ? LPointerTargetable : undefined | null) = (LL extends orArr<LPointerTargetable> ? unArr<LL> : undefined)\r\n    >\r\n    = LL extends undefined ? undefined : Pack1<L> | PackArr<L>;\r\n*/\r\nexport type Pack1<LL extends orArr<LPointerTargetable> | undefined, L extends LPointerTargetable | undefined = unArr<LL>,\r\n    D extends (L extends LPointerTargetable ? LtoD<L> : undefined) = (L extends LPointerTargetable ? LtoD<L> : undefined)> =\r\n    L extends LPointerTargetable ? ( D extends DPointerTargetable ? D | L | Pointer<D, 1, 1, L> : undefined) : undefined;\r\nexport type PackArr<LL extends orArr<LPointerTargetable> | undefined, L extends LPointerTargetable | undefined = unArr<LL>> = Pack1<L>[];\r\nexport type Pack<LL extends orArr<LPointerTargetable> | undefined, L extends LPointerTargetable | undefined = unArr<LL>> = L extends undefined ? undefined : Pack1<L> | PackArr<L>;\r\n/*\r\nlet n: any = null;\r\nlet aa: DClass = n;\r\nlet ptrr = Pointers.from(aa.parent);\r\naa.parent = ptrr;*/\r\n\r\n@RuntimeAccessible('PendingPointedByPaths')\r\nexport class PendingPointedByPaths{\r\n    static all: PendingPointedByPaths[] = [];\r\n    // static pendingMoreThanTwice: ParsedAction[] = [];\r\n    static maxSolveAttempts: number = 2099999;\r\n    public solveAttempts: number = 1;\r\n    private stackTrace: string[];\r\n\r\n    // tmp fields, not sure what i need\r\n    public action!: ParsedAction; // todo: remove\r\n    // the mistake was: i was getting the val from action, and the val was an array.\r\n    // i can either: manually pass it (better?)\r\n    // or: calculate array difference but risk duplicate entries (for 2 difference gets called 2 times and add both twice)\r\n    static new(action: ParsedAction, oldState: DState, ptr: Pointer, casee: \"+=\" | \"-=\" | undefined = undefined): PendingPointedByPaths {\r\n        //const ptr: Pointer = action.value;\r\n        // const target: DPointerTargetable | null = oldState.idlookup[ptr as string];\r\n        let pendingPointedBy = new PendingPointedByPaths(action.path, ptr, casee);\r\n        pendingPointedBy.action = action;\r\n        return pendingPointedBy;\r\n    }\r\n\r\n    private constructor(\r\n        public from: DocString<\"full Path in store including field key\">,\r\n        public holder: Pointer,\r\n        public casee: \"+=\" | \"-=\" | undefined = undefined){\r\n        this.stackTrace = U.getStackTrace();\r\n    }\r\n    static attemptimplementationdelete(pb: PointedBy) {\r\n        let state: DState = store.getState();\r\n        let objectChain = U.followPath(state, pb.source);\r\n    }\r\n\r\n    public attemptResolve(state: DState): ParsedAction | null {\r\n        if (this.canBeResolved(state)) return this.resolve();\r\n        return null;\r\n    }\r\n    public attemptResolveDirectly(state: DState, oldState: DState): DState {\r\n        if (this.canBeResolved(state)) state = this.resolveDirectly(state, oldState);\r\n        return state;\r\n    }\r\n\r\n    private resolve(state?: DState, oldState?: DState): ParsedAction{\r\n        U.arrayRemoveAll(PendingPointedByPaths.all, this);\r\n        return Action.parse(SetRootFieldAction.create(\"idlookup.\" + this.holder + '.pointedBy', PointedBy.new(this.action.path, this.casee), '+=', false));\r\n    }\r\n\r\n    private resolveDirectly(state: DState, oldState: DState): DState {\r\n        U.arrayRemoveAll(PendingPointedByPaths.all, this);\r\n        if (state === oldState) state = {...state} as any;\r\n        if (state.idlookup === oldState.idlookup) state.idlookup = {...state.idlookup};\r\n        if (state.idlookup[this.holder] === oldState.idlookup[this.holder]) state.idlookup[this.holder] = {...state.idlookup[this.holder]} as any;\r\n        let dobj = state.idlookup[this.holder];\r\n        let oldobj = state.idlookup[this.holder];\r\n        if (dobj.pointedBy === oldobj.pointedBy) dobj.pointedBy = [...dobj.pointedBy]\r\n        dobj.pointedBy.push(PointedBy.new(this.action.path, this.casee));\r\n\r\n        //Action.parse(SetRootFieldAction.create(\"idlookup.\" + this.holder + '.pointedBy', '+=', false));\r\n        return state;\r\n    }\r\n\r\n    public saveForLater(): void { PendingPointedByPaths.all.push(this); }\r\n    private canBeResolved(state: DState): boolean {\r\n        this.solveAttempts++;\r\n        Log.w(this.solveAttempts >= 3 /*PendingPointedByPaths.maxSolveAttempts*/,\r\n            \"pending PointedBy action is not revolved for too long, some pointer was wrongly set up.\", this.stackTrace, this, state);\r\n        return !!state.idlookup[this.holder];\r\n    }\r\n\r\n    static getSolveableActions(oldState: DState): ParsedAction[] {\r\n        let allClone = [...this.all]; // necessary because the array will remove some elements during iteration as they are solved.\r\n        return allClone.map( p => p.attemptResolve(oldState)).filter(p => (!!p)) as ParsedAction[];\r\n    }\r\n    static getSolveableActions2(state: DState, oldState: DState): DState {\r\n        let allClone = [...this.all]; // necessary because the array will remove some elements during iteration as they are solved.\r\n        for (let p of allClone) state = p.attemptResolveDirectly(state, oldState); //.filter(p => (!!p));\r\n        return state;\r\n    }\r\n}\r\n\r\n@RuntimeAccessible('PointedBy')\r\nexport class PointedBy {\r\n    static list: string[] = [\"father\", \"parent\", \"annotations\", \"packages\", \"type\", \"subpackages\", \"classifiers\", \"exceptions\", \"parameters\", \"defaultValue\", \"instances\", \"operations\", \"features\", \"attributes\", \"references\", \"extends\", \"extendedBy\", \"implements\", \"implementedBy\", \"instanceof\", \"edges\", \"target\", \"opposite\", \"parameters\", \"exceptions\", \"literals\", \"values\"];\r\n    source: string; // elemento da cui parte il puntatore\r\n    // field: keyof DPointerTargetable;\r\n    // il bersaglio non c'è qui, perchè è l'oggetto che contiene questo dentro l'array pointedBy\r\n\r\n    /*private constructor(source: DPointerTargetable, field: any) {\r\n        this.source = source;\r\n        this.field = field;\r\n    }*/\r\n\r\n    static getPath(p: PointedBy) : string { return p.source.substring(0, p.source.lastIndexOf(\".\")); }\r\n    static getLastKey(p: PointedBy) : string { return p.source.substring(p.source.lastIndexOf(\".\")); }\r\n    static getPathArr(p: PointedBy) : string[] { return p.source.split('.'); }\r\n    private constructor(source: string) {\r\n        this.source = source;\r\n    }\r\n    // don't use modifiers here,\r\n    static fromID<D extends DPointerTargetable>(ptr: Pointer<D>, field: keyof D, NoAccessModifiersHere?: never & (\"-=\" | \"+=\")) {\r\n        return PointedBy.new(\"idlookup.\" + ptr + \".\" + field);\r\n    }\r\n    static new(source: DocString<\"full path in store including key. like \\'idlookup.id.extends+=\\'\">, modifier: \"-=\" | \"+=\" | undefined = undefined, action?: ParsedAction): PointedBy {\r\n        // let source: DocString<\"full path in store including key\"> = action.path;\r\n        // if (source.includes(\"true\")) { console.error(this, action); throw new Error(\"mixed a bool\"); }\r\n        if (modifier) source = source.substring(0, source.length - (modifier?.length || 0));\r\n        return new PointedBy(source);\r\n    }\r\n    // static new0<D extends DPointerTargetable> (source: D, field: keyof D): PointedBy { return new PointedBy(source, field); }\r\n\r\n\r\n\r\n    public static remove(oldValue: Pointer | undefined, action: ParsedAction, state: DState, casee: \"+=\" | \"-=\" | undefined = undefined, oldState?:DState): DState {\r\n        if (!oldValue) return state;\r\n        let oldtarget: DPointerTargetable = state.idlookup[oldValue];\r\n        if (!oldtarget) return state;\r\n        let index = -1;\r\n        let actionpath: string = action.path.substring(0, action.path.length -(casee?.length || 0))\r\n        for (let i = 0; i < oldtarget.pointedBy.length; i++) { if (oldtarget.pointedBy[i].source === actionpath) { index = i; break; } }\r\n        if (index < 0) return state;\r\n\r\n        if (oldState === state) state = {...state} as DState;\r\n        if (oldState?.idlookup === state.idlookup) state.idlookup = {...state.idlookup};\r\n        if (oldState?.idlookup[oldValue] === state.idlookup[oldValue]) {\r\n            state.idlookup[oldValue] = {...oldtarget} as any;\r\n        }\r\n        else {\r\n            // no need\r\n        }\r\n        state.idlookup[oldValue].pointedBy.splice(index, 1) // in-place edit\r\n\r\n        // console.warn('pointedby remove:', {from: oldtarget.pointedBy, to: state.idlookup[oldValue].pointedBy, obj: state.idlookup[oldValue], index, oldValue, actionpath});\r\n        return state;\r\n    }\r\n\r\n    // important! must be called only in reducer\r\n    public static add(pointed_val: Pointer | undefined, action: ParsedAction, state: DState, casee: \"+=\" | \"-=\" | undefined = undefined, oldState?:DState): DState {\r\n\r\n        if (!Pointers.isPointer(pointed_val)) {\r\n            // this is the case when the pointed element is not in the value, but in the key of a terminal part of the path,\r\n            // like idlookup.viewid.subviews.subviewid = 5 (score);\r\n            let newtargetptrarr: Pointer[] = (action.pathArray.filter(e => Pointers.isPointer(e)) as any);\r\n            // Log.eDev(!newtargetptr, 'cannot find pointer in pointedby', {newtargetptr, action});\r\n            if (newtargetptrarr.length < 2) return state;\r\n            let pval: string = (newtargetptrarr as any).last();\r\n\r\n            let len = pval.length;\r\n            if (pval[len-1] === ']' &&  pval[len-2] === '[' ||\r\n                pval[len-1] === '=' && (pval[len-2] === '-' || pval[len-2] === '+')) {\r\n                pval = pval.substring(0, len-2);\r\n            }\r\n            pointed_val = pval;\r\n        }\r\n        if (!pointed_val) return state;\r\n\r\n        // todo: if can't be done because newtarget doesn't exist, build an action from this and set it pending.\r\n        let newtarget: DPointerTargetable = state.idlookup[pointed_val];\r\n        if (!newtarget) {\r\n            PendingPointedByPaths.new(action,state,pointed_val, casee).saveForLater(); // {from: action.path, field: action.field, to: target});\r\n            return state;\r\n        }\r\n        /* simpler version but does unnecessary shallow copies\r\n        state = {...state} as DState;\r\n        state.idlookup = {...state.idlookup};\r\n        state.idlookup[newtargetptr] = {...newtarget, pointedBy:  [...newtarget.pointedBy, PointedBy.new(action.path, casee)]} as any;*/\r\n        if (oldState === state) state = {...state} as DState;\r\n        if (oldState?.idlookup === state.idlookup) state.idlookup = {...state.idlookup};\r\n        if (oldState?.idlookup[pointed_val] === newtarget) { state.idlookup[pointed_val] = {...newtarget} as any; }\r\n        let newpb = PointedBy.new(action.path, casee);\r\n        state.idlookup[pointed_val].pointedBy = [...newtarget.pointedBy, newpb];\r\n\r\n        // console.warn('pointedby add:', {to: newtarget, from: state.idlookup[pointed_val], newpb, pby: state.idlookup[pointed_val].pointedBy});\r\n        return state;\r\n    }\r\n}\r\n\r\nclass DerivedD{\r\n    read: string;\r\n    write: string;\r\n    target: string[];\r\n    constructor() {\r\n        this.read = '';\r\n        this.write = '';\r\n        this.target = [];\r\n    }\r\n}\r\nclass DerivedL{\r\n    read!: Function;\r\n    write!: Function;\r\n    target!: string[];\r\n    constructor(target: string[], read: Function, write: Function) {\r\n        this.target = target;\r\n        this.read = read;\r\n        this.write = write;\r\n    }\r\n}\r\n\r\ntype AnyPointer = Pointer<DPointerTargetable, number, number|'N', LPointerTargetable>;\r\n\r\n@RuntimeAccessible('LPointerTargetable')\r\nexport class LPointerTargetable<Context extends LogicContext<DPointerTargetable> = any, D extends DPointerTargetable = DPointerTargetable> extends DPointerTargetable {\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    public static structure: typeof DPointerTargetable;\r\n    public static singleton: LPointerTargetable;\r\n    public __raw!: D;\r\n    public clonedCounter?: number;\r\n\r\n    public __isProxy!: boolean;\r\n    public __serialize!: DocString<\"json\">;\r\n    private inspect!: D;\r\n    private __random!: number;\r\n    public __readonly!: boolean;\r\n    public state!: any;\r\n    public r!:any;\r\n\r\n    private test(){\r\n        let a: LPointerTargetable = null as any as LEnumLiteral;\r\n        let c: LPointerTargetable = null as any as LParameter;\r\n        let b: LPointerTargetable = null as any as LVertex;\r\n    }\r\n    // public r!: this;\r\n\r\n    private __info_of__id = {type:\"Pointer&lt;this&gt;\",\r\n        txt:\"<a href=\\\"https://github.com/DamianoNaraku/jodel-react/wiki/identifiers\\\">\" +\r\n            \"<span>Unique identifier, and value used to point this object.</span></a>\"};\r\n\r\n    private __info_of____readonly = {type:\"boolean\", txt:\"prevent any change to the current object.\"};\r\n    project!: LProject|null;\r\n    protected get_project(c: GObject<Context>): LProject | null {\r\n        return LPointerTargetable.fromPointer(DUser.current as Pointer<DUser>)?.project || null;\r\n    }\r\n    protected set___readonly(val: any, c: Context): boolean {\r\n        val = !!val;\r\n        let thiss: GObject = this;\r\n        let childrens = (thiss.get_children && thiss.get_children(c)) || [];\r\n        let annotations = (thiss.get_annotations && thiss.get_annotations(c)) || [];\r\n        if (val === c.data.__readonly) return true;\r\n        TRANSACTION('readonly ' + + this.get_name(c), ()=>{\r\n            for (let c of childrens) { c.__readonly = val; }\r\n            for (let c of annotations) { c.__readonly = val; }\r\n            SetFieldAction.new(c.data, '__readonly', val);\r\n        }, val, !val);\r\n        return true;\r\n    }\r\n\r\n    /*protected derivedMap!: Dictionary<DocString<\"propertyName\">, DerivedL>;*/\r\n    /*protected*/ __info_of__derivedMap: Info = {type: 'Dictionary<propertyName, {read: function, write: function}>', txt:'todo'}\r\n\r\n    get_derivedMap(c: Context): LPointerTargetable[\"derivedMap\"] {\r\n        let map: Dictionary<DocString<\"propertyName\">, DerivedL> = (c.data.derivedMap ? {...c.data.derivedMap} : {}) as GObject;\r\n        for (let k in map) {\r\n            if (!map[k] || !map[k].target?.length) { delete map[k]; continue; }\r\n            map[k] = new DerivedL(map[k].target, ()=>'Derived attributes todo', ()=>'Derived attributes todo');\r\n        }\r\n        return map as GObject;\r\n    }\r\n\r\n    protected setderivedMap(val0: this[\"derivedMap\"] & GObject, c: Context): boolean {\r\n        let val: GObject = val0 || {};\r\n        if (!Object.keys(val).length) return true;\r\n        TRANSACTION('update derived expressions on ' + this.get_name(c), ()=>{\r\n            SetFieldAction.new(c.data.id, 'derivedMap', val, '+=');\r\n        })\r\n        return true;\r\n    }\r\n\r\n\r\n    public pointedBy!: PointedBy[];\r\n    // pointedBy!: LPointerTargetable[];\r\n    get_pointedBy(context: Context): LPointerTargetable[\"pointedBy\"] {\r\n        let state: DState = store.getState();\r\n        let targeting: LPointerTargetable[] = LPointerTargetable.fromArr(context.data.pointedBy.map( p => {\r\n            let s: GObject = state;\r\n            for (let key of PointedBy.getPathArr(p)) {\r\n                s = s[key];\r\n                if (!s) return null;\r\n                if (s.className) return s.id;\r\n            }\r\n        }));\r\n        return targeting as any;\r\n    }\r\n\r\n    private _jjdependencies!: Dependency[]; // used in delete to find all objects referencing this, not meant to be used by users.\r\n    public get__jjdependencies(context: any): Dependency[] {\r\n        const data = context.data;\r\n        const dependencies: Dependency[] = [];\r\n        let s = store.getState();\r\n        for (let pointedBy of data.pointedBy) {\r\n            let pbyString = pointedBy.source;\r\n            const pathArr: string[] = pbyString.split('.');\r\n            let lastKey = pathArr[pathArr.length-1];\r\n            switch (pbyString.substring(pbyString.length - 2)){\r\n                default: break;\r\n                case '-=':\r\n                case '+=':\r\n                case '[]': pbyString = pbyString.substring(0, pbyString.length - 2); break;\r\n            }\r\n            let firstKey = pathArr[0];\r\n            let ptr = pathArr.find(e=>Pointers.isPointer(e));\r\n            let followPath = U.followPath(s, pathArr); // it should be either: a Pointer, array of pointers, object with Pointers as keys\r\n            let lastVal = followPath.lastval;\r\n            let isArr = Array.isArray(lastVal);\r\n            let arrIndex: number = Number.NaN;\r\n            if (U.isNumber(+lastKey)) {\r\n                arrIndex = (+lastKey as number);\r\n                lastKey = pathArr[pathArr.length-2];\r\n                // Log.eDev(U.isNumber(arrIndex), 'unexpected index in pointedBy: ', {arrIndex, pointedBy, context});\r\n            }\r\n            let lastValArr: Pointer[];\r\n            if (!lastVal) {\r\n                // was deleted?\r\n                continue;\r\n            }\r\n            else if (isArr) {\r\n                lastValArr = lastVal;\r\n            }\r\n            else if (typeof lastVal === 'object') {\r\n                Log.eDevv('unexpected pointedBy case ending with an object, still not supported', {lastVal, pointedBy, context});\r\n                continue;\r\n            }\r\n            else {\r\n                lastValArr = [lastVal];\r\n            }\r\n            for (let v of lastValArr){\r\n                // if (!v || Pointer.isPointer(v)) continue;\r\n                if (v !== context.data.id) continue;\r\n                const dependency: Dependency = {firstKey: firstKey as keyof DState, lastKey: lastKey as keyof DPointerTargetable,\r\n                    lastVal, isArr, arrIndex: +(arrIndex as any), obj: ptr, pathArr, pointedBy, path: pbyString};\r\n                dependencies.push(dependency);\r\n            }\r\n        }\r\n        return dependencies;\r\n    }\r\n\r\n    name!:string;\r\n    protected get_name(c: Context): this[\"name\"] {\r\n        let nameattribute = (c.proxyObject as any).$name;\r\n        let ret: string = undefined as any;\r\n        if (nameattribute && nameattribute.className === 'LValue') {\r\n            ret = nameattribute.value;\r\n        }\r\n        if (ret === undefined) ret = c.data.name || c.data.className;\r\n        return ret;\r\n    }\r\n\r\n    protected set_name(val: this[\"name\"], c: Context): boolean {\r\n        let name = val;\r\n        const father: LPointerTargetable = (c.proxyObject as LModelElement).father;\r\n        if (father) {\r\n            const check = (father as LModelElement).children?.filter((child) => {\r\n                return (D.fromPointer(child.id) as DNamedElement).name === name;\r\n            });\r\n            if (check.length > 0) {\r\n                U.alert('e', 'Cannot rename the selected element since this name is already taken.');\r\n                return true;\r\n            }\r\n        }\r\n\r\n        TRANSACTION(this.get_name(c)+'.name', ()=>{\r\n            let nameattribute = (c.proxyObject as any).$name;\r\n            if (nameattribute && nameattribute.className === 'LValue') {\r\n                nameattribute.value = val;\r\n            }\r\n            SetFieldAction.new(c.data, 'name', name, '', false);\r\n        }, undefined, val)\r\n        return true;\r\n    }\r\n\r\n\r\n    fullname!:string;\r\n    protected get_fullname(c: Context): this[\"name\"] { return this.get_name(c); } // fallback\r\n\r\n    protected wrongAccessMessage(str: string): any {\r\n        let msg = \"Method \"+str+\" should not be called directly, attempting to do so should trigger get_\"+str+\"(). This is only a signature for type checking.\";\r\n        Log.ex(true, msg);\r\n        throw new Error(msg); }\r\n\r\n    public toString(): string { throw this.wrongAccessMessage(\"toString\"); }\r\n    protected get_toString(context: Context): () => string {\r\n        const data = context.data as DNamedElement;\r\n        return () => ( data.name || data.className.substring(0));\r\n        // return () => data.id;\r\n    }\r\n    public toPrimitive(): string { throw this.wrongAccessMessage(\"toPrimitive\"); }\r\n    protected get_toPrimitive(c: Context): ((hint?: \"number\" | \"string\" | \"default\" ) => (number | string)) {\r\n        return (hint?: \"number\" | \"string\" | \"default\") => {\r\n            switch (hint){\r\n                default:\r\n                case \"number\":\r\n                    return c.data.clonedCounter || -1;\r\n                case \"string\":\r\n                case \"default\":\r\n                    return this.get_toString(c)();\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    protected cannotSet(field: string, msg?:string): any { return Log.exx('\"' + field + '\" field is read-only.' + (msg ? '\\n'+msg : '')); }\r\n    protected get_id(context: Context): this[\"id\"] { return context.data.id; }\r\n    protected set_id(): boolean { return this.cannotSet('id'); }\r\n\r\n    protected _get_default< DD extends DPointerTargetable, T extends string & keyof (DD) & keyof (L), L extends LModelElement = LModelElement>(data: DD, key: T): L[T]{\r\n        // @ts-ignore\r\n        return LPointerTargetable.from(data[key]);\r\n    }\r\n\r\n    _state!: GObject;\r\n    __info_of___state = {type:\"GObject\", txt: `<div>A space where the user can store informations for their operations/views.<br/>\r\nExample: The Validation viewpoint uses it to store validation messages.<br/>\r\nWARNING! do not set proxies in the state, set pointers instead.<br/>\r\n<a href='https://github.com/MDEGroup/jjodel/wiki/L%E2%80%90Object-state'>Learn more on the wiki</a></div>`};\r\n\r\n    // get__state(c: Context): any { return this.wrongAccessMessage('_state',', use obj.state instead.'); }\r\n    // set__state(val: this[\"_state\"], c: Context): boolean { return this.cannotSet('_state', 'use obj.state instead.'); }\r\n    get_state(context: any): any /*this['_state']*/ {\r\n        if (!context.data._state) return {};\r\n        return this.__shallowSolver(context.data._state, true, true); // to solve pointers in state\r\n        // return LPointerTargetable.wrap(context.data._state); // this should work, because data._state have id = this.id+\"._state\"\r\n    }\r\n    set_state(val: any, c: Context): boolean {\r\n        // todo: put those lobjects -> pointer checks into defaultsetter to improve it\r\n\r\n        // 3 options:\r\n        // 1) if state === node, then setting whole state is invalid\r\n        // 2) if state is a proxified obj with id = node.id+\".state\" so actions and proxy getters/setters will act on the subobject properties still invalid setting whole obj.\r\n        // 3) forbid to set the whole state, merge old state with new one, if val === undefined, state is reset.\r\n\r\n        // i choose 3)\r\n        let newState: GObject;\r\n        let oldState = c.data._state ? {...c.data._state} : {};\r\n        let changed: boolean = false;\r\n        if (val === undefined) {\r\n            if (!oldState || !Object.keys(oldState).length) return true;\r\n            newState = {};\r\n            changed = true;\r\n        }\r\n        else if (typeof val !== \"object\") { Log.ee(\"state can only be assigned with an object or undefined\"); return true; }\r\n        else {\r\n            val = this.__sanitizeValue(val);\r\n            newState = {...oldState};\r\n            for (let k in val) {\r\n                if (val[k] === undefined) {\r\n                    if (oldState[k] === undefined) continue;\r\n                    delete newState[k];\r\n                    changed = true;\r\n                    continue;\r\n                }\r\n\r\n                if (oldState[k] === val[k]) continue;\r\n                newState[k] = val[k];\r\n                changed = true;\r\n            }\r\n        }\r\n\r\n        if (!changed) return true;\r\n\r\n        TRANSACTION(this.get_name(c)+'.state', ()=>{\r\n            SetFieldAction.new(c.data, \"_state\", newState, undefined, false);\r\n        })\r\n        return true;\r\n    }\r\n    protected __sanitizeValue(val: any, canEditVal: boolean = true, canEditValDeep:boolean = false): any{\r\n        if (!val) { return val; }\r\n        let className = val.className;\r\n        if ((val.__isProxy || val.id && className)\r\n            && !RuntimeAccessibleClass.extends(className, IPoint.cname)\r\n            && !RuntimeAccessibleClass.extends(className, ISize.cname)) {\r\n            return val.id;\r\n        }\r\n        // if (typeof val === \"string\") { return val; } else\r\n        if (typeof val !== \"object\") { return val; }\r\n        else if (Array.isArray(val)) { return val.map(v => this.__sanitizeValue(v, canEditValDeep, canEditValDeep)); }\r\n        // case val is object not array, not proxy, not D. just a POJO\r\n        let ret = canEditVal ? val : {...val};\r\n        for (let k in val) {\r\n            if (Array.isArray(val[k])) ret[k] = val[k].map((v: any)=> v && (v.__isProxy || v.id && v.className) ? v.id : v);\r\n            else if (val[k] && (val[k].__isProxy || val[k].id && val[k].className)) ret[k] = val[k].id;\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    // protected _defaultCollectionGetter(c: Context, k: keyof Context[\"data\"]): LPointerTargetable[] { return LPointerTargetable.fromPointer((c.data as any)[k]); }\r\n    protected _defaultGetter(c: Context, k: keyof Context[\"data\"]): any {\r\n        return this.__defaultGetter(c, k);\r\n    }\r\n    protected _defaultSetter(v0: any, c: Context, k: keyof Context[\"data\"]): boolean {\r\n        this.__defaultSetter(v0, c, k);\r\n        return true;\r\n    }\r\n    protected __defaultGetter(c: Context, k: keyof Context[\"data\"]): any {\r\n        // console.log(\"default Getter\");\r\n        let v = (c.data as any)[k];\r\n        return this.__shallowSolver(v, true, false);\r\n    }\r\n    protected __shallowSolver<T>(val: any, solveArrayValues: boolean, solveObjectKeys: boolean): any {\r\n        if (!val) return val;\r\n        let state: DState = store.getState();\r\n        if (solveArrayValues && Array.isArray(val)) {\r\n            if (val.length === 0) return [];\r\n            return val.map(v => LPointerTargetable.attemptWrap(v));\r\n            // else if (Pointers.isPointer(val[0] as any)) return LPointerTargetable.fromArr(val, state);\r\n            // return val;\r\n        }\r\n        if (solveObjectKeys && typeof val === \"object\"){\r\n            let ret = {...val};\r\n            for (let key in val){\r\n                ret[key] = LPointerTargetable.attemptWrap(val[key]);\r\n            }\r\n            return ret;\r\n        }\r\n        return val && Pointers.isPointer(val as any, undefined) ? LPointerTargetable.fromPointer(val, state) : val;\r\n    }\r\n\r\n    protected __defaultSetter(v0: any, c: Context, k: keyof Context[\"data\"]): boolean {\r\n        // todo: get the those lobjects -> pointer checks from set_state\r\n        let v: any = this.__sanitizeValue(v0, false, false);\r\n        if (!k) return Log.exx('a key is mandatory for default setter', {v0, k, c});\r\n        if (true || k in c.data) {\r\n            // check if is pointer\r\n            let isPointer: boolean;\r\n            if (Array.isArray(v)) {\r\n                if (v.length === 0) isPointer = true; // assumed, should not cause harm if it is not.\r\n                    // it will delete remove an entry in pointedBy from all oldValue entries in the array that should not be present anyway.\r\n                // like oldVal.map( id => U.arrayRemove(LData.wrap(id).pointedBy, c.data.this_id)\r\n                else isPointer = v.some(p=>Pointers.isPointer(p)); //Pointers.isPointer(v[0] as any);\r\n            } else isPointer = Pointers.isPointer(v);\r\n\r\n            // autofix value\r\n            let bytes = 0;\r\n            let type: string = (this as any)[\"__info_of__\"+k]?.type;\r\n            if (type) type = U.multiReplaceAll(type, [\"array\", \"Array\", \"<\", \">\", \"[]\"], []);\r\n            switch(type){\r\n                case ShortAttribETypes.EDate: break;\r\n                default: break;\r\n                case ShortAttribETypes.EBoolean: v = !!v; break;\r\n                case ShortAttribETypes.EByte: bytes = 8; break;\r\n                case ShortAttribETypes.EShort: bytes = 16; break;\r\n                case ShortAttribETypes.EInt: bytes = 32; break;\r\n                case ShortAttribETypes.ELong: bytes = 64; break;\r\n                case ShortAttribETypes.EString: v = \"\"+v; break;\r\n                case ShortAttribETypes.EChar: v = (\"\"+v)[0]; break;\r\n                case ShortAttribETypes.EVoid: Log.exx(\"cannot set a void-typed value\", {c, d:c.data, k, v}); return true;\r\n                case ShortAttribETypes.EDouble:\r\n                case ShortAttribETypes.EFloat: v = +v; break;\r\n            }\r\n            if (bytes) {\r\n                v = Math.round(+v);\r\n                let max = v << bytes; // left shift is the same as multiplying by a power of 2, but binary and more efficient.\r\n                let min = -max + 1\r\n                if (v > max) v = max;\r\n                else if (v < min) v = min;\r\n            }\r\n            console.log(\"default Setter[\"+k+\"] = \" + v , {type, v, v0, oldv:(c.data as any)[k], isPointer});\r\n\r\n            let oldv = c.data[k as keyof DPointerTargetable];\r\n            let newv = v;\r\n            if (!U.isPrimitive(oldv)) oldv = undefined;\r\n            if (!U.isPrimitive(newv)) newv = undefined;\r\n            TRANSACTION(this.get_name(c)+'.'+k, ()=>{\r\n                SetFieldAction.new(c.data, k as any, v, '', isPointer);\r\n            }, oldv, newv)\r\n            return true;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    public get__extends(superClassName: string, context: LogicContext<DPointerTargetable>): boolean {\r\n        return RuntimeAccessibleClass.extends(context.data.className, superClassName);\r\n    }\r\n\r\n    /*\r\n    public get_pointedBy(superClassName: string, context: LogicContext<DPointerTargetable>): LPointerTargetable[] {\r\n        let state: GObject = windoww.store.getState();\r\n        function getForemostObjectInPath(path: DocString<'storePath'>): undefined | LPointerTargetable {\r\n            let lastPointableObject: undefined | DPointerTargetable;\r\n            let pathArray = path.split('.');\r\n            for (let key of pathArray) {\r\n                let currentObj: GObject = state[key];\r\n                if (!currentObj) break;\r\n                if (currentObj && currentObj.id && state.idlookup[currentObj.id]) lastPointableObject = state.idlookup[currentObj.id];\r\n            }\r\n            return lastPointableObject && DPointerTargetable.wrap(lastPointableObject);\r\n        }\r\n        return (context.data.pointedBy || []).map(getForemostObjectInPath).filter( lobj => !!lobj) as LPointerTargetable[];\r\n    }*/\r\n\r\n    public set_pointedBy(val: never, context: LogicContext<DPointerTargetable>): boolean {\r\n        windoww.Log.exx('pointedBy field should never be directly edited.', {context, val});\r\n        return false;\r\n    }\r\n\r\n\r\n\r\n\r\n    static fromD<DX extends DPointerTargetable,\r\n        LX = DX extends DEnumerator ? LEnumerator : (DX extends DAttribute ? LAttribute : (DX extends DReference ? LReference : (DX extends DRefEdge ? LRefEdge : (DX extends DExtEdge ? LExtEdge : (DX extends DDataType ? LDataType : (DX extends DClass ? LClass : (DX extends DStructuralFeature ? LStructuralFeature : (DX extends DParameter ? LParameter : (DX extends DOperation ? LOperation : (DX extends DEdge ? LEdge : (DX extends DEdgePoint ? LEdgePoint : (DX extends DGraphVertex ? LGraphVertex : (DX extends DModel ? LModel : (DX extends DValue ? LValue : (DX extends DObject ? LObject : (DX extends DEnumLiteral ? LEnumLiteral : (DX extends DPackage ? LPackage : (DX extends DClassifier ? LClassifier : (DX extends DTypedElement ? LTypedElement : (DX extends DVertex ? LVertex : (DX extends DVoidEdge ? LVoidEdge : (DX extends DVoidVertex ? LVoidVertex : (DX extends DGraph ? LGraph : (DX extends DNamedElement ? LNamedElement : (DX extends DAnnotation ? LAnnotation : (DX extends DGraphElement ? LGraphElement : (DX extends DMap ? LMap : (DX extends DModelElement ? LModelElement : (DX extends DUser ? LUser : (DX extends DPointerTargetable ? LPointerTargetable : (ERROR))))))))))))))))))))))))))))))),\r\n        >(data: DX): LX;\r\n    static fromD<DX extends DPointerTargetable,\r\n        LX = DX extends DEnumerator ? LEnumerator : (DX extends DAttribute ? LAttribute : (DX extends DReference ? LReference : (DX extends DRefEdge ? LRefEdge : (DX extends DExtEdge ? LExtEdge : (DX extends DDataType ? LDataType : (DX extends DClass ? LClass : (DX extends DStructuralFeature ? LStructuralFeature : (DX extends DParameter ? LParameter : (DX extends DOperation ? LOperation : (DX extends DEdge ? LEdge : (DX extends DEdgePoint ? LEdgePoint : (DX extends DGraphVertex ? LGraphVertex : (DX extends DModel ? LModel : (DX extends DValue ? LValue : (DX extends DObject ? LObject : (DX extends DEnumLiteral ? LEnumLiteral : (DX extends DPackage ? LPackage : (DX extends DClassifier ? LClassifier : (DX extends DTypedElement ? LTypedElement : (DX extends DVertex ? LVertex : (DX extends DVoidEdge ? LVoidEdge : (DX extends DVoidVertex ? LVoidVertex : (DX extends DGraph ? LGraph : (DX extends DNamedElement ? LNamedElement : (DX extends DAnnotation ? LAnnotation : (DX extends DGraphElement ? LGraphElement : (DX extends DMap ? LMap : (DX extends DModelElement ? LModelElement : (DX extends DUser ? LUser : (DX extends DPointerTargetable ? LPointerTargetable : (ERROR))))))))))))))))))))))))))))))),\r\n        >(data: DX[]): LX[];\r\n    static fromD(data: any): any {\r\n        // return null as any;\r\n        if (Array.isArray(data)) return LPointerTargetable.wrapAll(data) as any;\r\n        return LPointerTargetable.wrap(data) as any;\r\n    }\r\n\r\n\r\n    static fromPointer<\r\n        T extends AnyPointer | AnyPointer[], // <DPointerTargetable, 1, 'N', LPointerTargetable>,\r\n        DDD extends (T extends Pointer<any, any, any, infer D> ? D : 'undefined L'),\r\n        LOW extends (T extends Pointer<any, infer LO> ? LO : 'undefined_upp'),\r\n        UPP extends (T extends Pointer<any, number, infer UP> ? UP : 'undefined_low'),\r\n\r\n        DDDARR extends (T extends Pointer<any, any, any, infer D>[] ? D : 'undefined_DARR'),\r\n        LOWARR extends (T extends Pointer<any, infer LO>[] ? LO : 'undefined_uppARR'),\r\n        UPPARR extends (T extends Pointer<any, number, infer UP>[] ? 'UP_is_N' : 'undefined_lowARR'),\r\n\r\n        RET = UPPARR extends 'UP_is_N' ?\r\n            (DDDARR[]) : // 0...N\r\n            (UPP extends 1 ? (LOW extends 0 ? DDD | null : DDD) : // 0...1 && 1...1\r\n                (LOW extends 1 ? DDD : undefined)  //1...1\r\n                ),\r\n        INFERRED = {ret: RET, upp: UPP, low:LOW, ddd: DDD, dddARR: DDDARR, lowARR: LOWARR, uppARR: UPPARR},>(ptr: T | undefined, state?: DState)\r\n        : RET {\r\n        // return null as any;\r\n        if (Array.isArray(ptr)) return LPointerTargetable.wrapAll(ptr as any, undefined, '', false, state) as any;\r\n        return LPointerTargetable.wrap(ptr) as any;\r\n    }\r\n    static fromArr(...a:any): any; // because otherwise it complains about inheriting from DPointerTargetable.fromArr\r\n    static fromArr<\r\n        PTR extends Pointer | Pointer[], // <DPointerTargetable, 1, 'N', LPointerTargetable>,\r\n        // DDD extends (PTR extends Pointer<infer D> ? D : 'undefined_D'),\r\n        LOW extends (PTR extends Pointer<any, infer LO> ? LO : 'undefined_upp'),\r\n        UPP extends (PTR extends Pointer<any, number, infer UP> ? UP : 'undefined_low'),\r\n        DDD extends (PTR extends Pointer<any, number, any, infer LL> ? LL : 'undefined_L'),\r\n\r\n        LOWARR extends (PTR extends Pointer<any, infer LO>[] ? LO : 'undefined_uppARR'),\r\n        UPPARR extends (PTR extends Pointer<any, number, infer UP>[] ? 'UP_is_N' : 'undefined_lowARR'),\r\n        DDDARR extends (PTR extends Pointer<any, any, any, infer LL>[] ? LL : 'undefined_LARR'),\r\n\r\n        DX extends DPointerTargetable,\r\n\r\n        RETPTR = UPPARR extends 'UP_is_N' ?\r\n            (DDDARR[]) : // 0...N\r\n            (UPP extends 1 ? (LOW extends 0 ? DDD | null : DDD) : // 0...1 && 1...1\r\n                (LOW extends 1 ? DDD : undefined)  //1...1\r\n                ),\r\n\r\n        // DX = LX extends LEnumerator ? DEnumerator : (LX extends LAttribute ? DAttribute : (LX extends LReference ? DReference : (LX extends LDataType ? DDataType : (LX extends LClass ? DClass : (LX extends LStructuralFeature ? DStructuralFeature : (LX extends LParameter ? DParameter : (LX extends LOperation ? DOperation : (LX extends LModel ? DModel : (LX extends LValue ? DValue : (LX extends LObject ? DObject : (LX extends LEnumLiteral ? DEnumLiteral : (LX extends LPackage ? DPackage : (LX extends LClassifier ? DClassifier : (LX extends LTypedElement ? DTypedElement : (LX extends LNamedElement ? DNamedElement : (LX extends LAnnotation ? DAnnotation : ('ERROR'))))))))))))))))),\r\n        LX = DX extends DEnumerator ? LEnumerator : (DX extends DAttribute ? LAttribute : (DX extends DReference ? LReference : (DX extends DRefEdge ? LRefEdge : (DX extends DExtEdge ? LExtEdge : (DX extends DDataType ? LDataType : (DX extends DClass ? LClass : (DX extends DStructuralFeature ? LStructuralFeature : (DX extends DParameter ? LParameter : (DX extends DOperation ? LOperation : (DX extends DEdge ? LEdge : (DX extends DEdgePoint ? LEdgePoint : (DX extends DGraphVertex ? LGraphVertex : (DX extends DModel ? LModel : (DX extends DValue ? LValue : (DX extends DObject ? LObject : (DX extends DEnumLiteral ? LEnumLiteral : (DX extends DPackage ? LPackage : (DX extends DClassifier ? LClassifier : (DX extends DTypedElement ? LTypedElement : (DX extends DVertex ? LVertex : (DX extends DVoidEdge ? LVoidEdge : (DX extends DVoidVertex ? LVoidVertex : (DX extends DGraph ? LGraph : (DX extends DNamedElement ? LNamedElement : (DX extends DAnnotation ? LAnnotation : (DX extends DGraphElement ? LGraphElement : (DX extends DMap ? LMap : (DX extends DModelElement ? LModelElement : (DX extends DUser ? LUser : (DX extends DPointerTargetable ? LPointerTargetable : (ERROR))))))))))))))))))))))))))))))),\r\n        RET = LX extends 'ERROR' ? RETPTR : (RETPTR extends LX ? RETPTR : LX),\r\n        INFERRED = {ret: RET, RETPTR: RETPTR, upp: UPP, low:LOW, ddd: DDD, dddARR: DDDARR, lowARR: LOWARR, uppARR: UPPARR, LX:LX, DX:DX}>(ptr: PTR[] | DX[], state?: DState)\r\n        : RET[] {\r\n        return LPointerTargetable.from(ptr as any, state); }\r\n\r\n    static from<// LOW extends number, UPP extends number | 'N',\r\n        PTR extends Pointer<DPointerTargetable, 0|1, 1|'N', LPointerTargetable> | Pointer[], // <DPointerTargetable, 1, 'N', LPointerTargetable>,\r\n        // DDD extends (PTR extends Pointer<infer D> ? D : 'undefined_D'),\r\n        LOW extends (PTR extends Pointer<any, infer LO> ? LO : 'undefined_upp'),\r\n        UPP extends (PTR extends Pointer<any, number, infer UP> ? UP : 'undefined_low'),\r\n        DDD extends (PTR extends Pointer<any, number, any, infer LL> ? LL : 'undefined_L'),\r\n\r\n        LOWARR extends (PTR extends Pointer<any, infer LO>[] ? LO : 'undefined_uppARR'),\r\n        UPPARR extends (PTR extends Pointer<any, number, infer UP>[] ? 'UP_is_N' : 'undefined_lowARR'),\r\n        DDDARR extends (PTR extends Pointer<any, any, any, infer LL>[] ? LL : 'undefined_LARR'),\r\n\r\n        DX extends DPointerTargetable,\r\n\r\n        RETPTR = UPPARR extends 'UP_is_N' ?\r\n            (DDDARR[]) : // 0...N\r\n            (UPP extends 1 ? (LOW extends 0 ? DDD | null : DDD) : // 0...1 && 1...1\r\n                (LOW extends 1 ? DDD : undefined)  //1...1\r\n                ),\r\n\r\n\r\n        // DX = LX extends LEnumerator ? DEnumerator : (LX extends LAttribute ? DAttribute : (LX extends LReference ? DReference : (LX extends LDataType ? DDataType : (LX extends LClass ? DClass : (LX extends LStructuralFeature ? DStructuralFeature : (LX extends LParameter ? DParameter : (LX extends LOperation ? DOperation : (LX extends LModel ? DModel : (LX extends LValue ? DValue : (LX extends LObject ? DObject : (LX extends LEnumLiteral ? DEnumLiteral : (LX extends LPackage ? DPackage : (LX extends LClassifier ? DClassifier : (LX extends LTypedElement ? DTypedElement : (LX extends LNamedElement ? DNamedElement : (LX extends LAnnotation ? DAnnotation : ('ERROR'))))))))))))))))),\r\n        LX = DX extends DEnumerator ? LEnumerator : (DX extends DAttribute ? LAttribute : (DX extends DReference ? LReference : (DX extends DRefEdge ? LRefEdge : (DX extends DExtEdge ? LExtEdge : (DX extends DDataType ? LDataType : (DX extends DClass ? LClass : (DX extends DStructuralFeature ? LStructuralFeature : (DX extends DParameter ? LParameter : (DX extends DOperation ? LOperation : (DX extends DEdge ? LEdge : (DX extends DEdgePoint ? LEdgePoint : (DX extends DGraphVertex ? LGraphVertex : (DX extends DModel ? LModel : (DX extends DValue ? LValue : (DX extends DObject ? LObject : (DX extends DEnumLiteral ? LEnumLiteral : (DX extends DPackage ? LPackage : (DX extends DClassifier ? LClassifier : (DX extends DTypedElement ? LTypedElement : (DX extends DVertex ? LVertex : (DX extends DVoidEdge ? LVoidEdge : (DX extends DVoidVertex ? LVoidVertex : (DX extends DGraph ? LGraph : (DX extends DNamedElement ? LNamedElement : (DX extends DAnnotation ? LAnnotation : (DX extends DGraphElement ? LGraphElement : (DX extends DMap ? LMap : (DX extends DModelElement ? LModelElement : (DX extends DUser ? LUser : (DX extends DPointerTargetable ? LPointerTargetable : (ERROR))))))))))))))))))))))))))))))),\r\n        RET = LX extends 'ERROR' ? RETPTR : (RETPTR extends LX ? RETPTR : LX),\r\n        INFERRED = {ret: RET, RETPTR: RETPTR, upp: UPP, low:LOW, ddd: DDD, dddARR: DDDARR, lowARR: LOWARR, uppARR: UPPARR, LX:LX, DX:DX}>(ptr: PTR | DX, s?: DState)\r\n        : RET {\r\n        // return null as any;\r\n        if (Array.isArray(ptr)) return LPointerTargetable.wrapAll(ptr) as any;\r\n        return LPointerTargetable.wrap(ptr as any) as any;\r\n    }\r\n\r\n    // static from0(a: any, ...aa: any): any { return null; }\r\n\r\n    /* OLD DELETE\r\n    public delete(): void { throw this.wrongAccessMessage(\"delete\"); }\r\n    public _delete(context: Context): void { new DeleteElementAction(context.data); }\r\n    protected get_delete(context: Context): () => void {\r\n        return () => {\r\n            alert(\"Delete in LPOINTER\")\r\n            this._delete(context);\r\n        }\r\n    }\r\n    */\r\n    /*\r\n*/\r\n    public delete(): void {}\r\n    protected get_delete(c: Context): () => void {\r\n        return ()=>TRANSACTION('delete '+this.get_name(c), Dummy.get_delete(this, c));\r\n    }\r\n}\r\nRuntimeAccessibleClass.set_extend(RuntimeAccessibleClass, LPointerTargetable);\r\n\r\n@RuntimeAccessible('D') export class D extends DPointerTargetable{}\r\n@RuntimeAccessible('L') export class L extends LPointerTargetable{}\r\n@RuntimeAccessible('P') export class P extends Pointers{}\r\n\r\n/*\r\nlet pttr: Pointer<DClassifier, 0, 1, LClassifier> = null as any;\r\nlet ptrany: Pointer<DClassifier, 0|1, 1|'N'>[] = null as any;\r\nlet ptrarr: Pointer<DClassifier>[] = null as any;\r\nlet ptrarr2: Pointer<DClassifier, 1, 'N'> = null as any;\r\nlet d: DClassifier = null as any;\r\nlet darr: DClassifier[] = null as any;\r\n\r\ntype VoidPtr = null | undefined | '';\r\nfunction dfrom<\r\n    PARAM extends orArr<AnyPointer | VoidPtr>,//orArr<WPointerTargetable | LPointerTargetable | DPointerTargetable | AnyPointer>,\r\n\r\n\r\n    DDD extends (PARAM extends Pointer<infer DD> ? DD : 'undefined_D'),\r\n    LOW extends (PARAM extends Pointer<any, infer LO> ? LO : 'undefined_low'),\r\n    LOW0 extends (PARAM extends Pointer<any, 0, any, any> ? 0 : never),\r\n    LOW1 extends (PARAM extends Pointer<any, 1, any, any> ? 1 : never),\r\n    LOW2 extends (VoidPtr extends PARAM ? 0 | 'first' : (PARAM extends VoidPtr ? 0 | 1 | 'second': 1|'third')),\r\n    UPP extends (PARAM extends Pointer<any, number, infer UP> ? UP : 'undefined_upp'),\r\n    LLL extends (PARAM extends Pointer<any, number, any, infer LL> ? LL : 'undefined_L'),\r\n\r\n\r\n\r\n    ISVOID extends PARAM extends VoidPtr  ? 'isvoid' : never,\r\n    ISARR extends PARAM extends [] ? true : false,\r\n    ISPTR extends (PARAM extends AnyPointer | VoidPtr ? 'ptr' : never),\r\n    ISPTRARR extends (PARAM extends (AnyPointer | VoidPtr)[] | Pointer<DPointerTargetable, 1|0, 'N', LPointerTargetable> ? 'ptr_arr' : never),\r\n    ISD extends (PARAM extends DPointerTargetable ? 'd' : never),\r\n    ISDARR extends (PARAM extends DPointerTargetable[] ? 'd_arr' : never),\r\n    ISL extends (PARAM extends LPointerTargetable ? 'l' : never),\r\n    ISLARR extends (PARAM extends LPointerTargetable[] ? 'l_arr' : never),\r\n    ISW extends (PARAM extends WPointerTargetable ? 'w' : never),\r\n    ISWARR extends (PARAM extends WPointerTargetable[] ? 'w_arr' : never),\r\n    // INFER = {LOW:LOW, UPP:UPP, DDD:DDD, LLL:LLL, LOW2:LOW2},\r\n    INFER = { LOW2:LOW2},\r\n    RET = ISVOID | ISPTR | ISPTRARR | ISD | ISDARR | ISL | ISLARR | ISW | ISWARR | INFER\r\n    >\r\n(ptr: PARAM): RET { return null as any; }\r\nlet Lptr = dfrom(pttr as Pointer<DClassifier, 0, 1, LClassifier> );\r\nlet Lptrany = dfrom(ptrany);\r\nlet Lptrarr = dfrom(ptrarr);\r\nlet Lptrarr2 = dfrom(ptrarr2);\r\nlet Ld = dfrom(d);\r\nlet Ldarr = dfrom(darr);*/\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n@RuntimeAccessible('WPointerTargetable')\r\nexport class WPointerTargetable extends DPointerTargetable{\r\n    id!: never;\r\n    _storePath!: never;\r\n    _subMaps!: never;\r\n    pointedBy!: never;\r\n    // todo: WfromD, WfromL, WfromPointer, Wfrom\r\n\r\n    static fromD<DX extends DPointerTargetable, WX extends DtoW<DX>>(data: DX): WX { return LPointerTargetable.fromD(data) as any; }\r\n}\r\nRuntimeAccessibleClass.set_extend(DPointerTargetable, LPointerTargetable);\r\nRuntimeAccessibleClass.set_extend(DPointerTargetable, WPointerTargetable);\r\nfunction fffff<DX, LX = DX extends DRefEdge ? LRefEdge : 'not'>( t: DX): LX { return null as any; }\r\nlet a: DGraphElement = null as any;\r\nlet bbb = LPointerTargetable.from(a);\r\nlet bb2 = fffff(a);\r\n\r\n@Leaf\r\n@RuntimeAccessible('DUser')\r\nexport class DUser extends DPointerTargetable {\r\n    //public static offlineMode: boolean = !!localStorage.getItem(\"offlineMode\");\r\n    public static isStateMachine = false;\r\n    // static current: Pointer<DUser> = 'Pointer_AnonymousUser';\r\n    static current: Pointer<DUser> = undefined as any;\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    id!: Pointer<DUser>;\r\n    name!: string;\r\n    surname!: string;\r\n    nickname!: string;\r\n    country!: string;\r\n    affiliation!: string;\r\n    newsletter!: boolean;\r\n    email!: string;\r\n    token!: string;\r\n    projects: Pointer<DProject, 0, 'N', LProject> = [];\r\n    project: Pointer<DProject, 0, 1, LProject> = '';\r\n    __isUser: true = true; // necessary to trick duck typing to think this is NOT the superclass of anything that extends PointerTargetable.\r\n    /*public static new(id?: DUser[\"id\"], triggerActions: boolean = true): DUser {\r\n        return new Constructors(new DUser('dwc'), undefined, false, undefined, id, true).DPointerTargetable().DUser().end(); }*/\r\n    public static new(name: string, surname: string, nickname: string, affiliation: string, country: string, newsletter: boolean, email: string, token: string, id?: DUser['id'], persist: boolean = true): DUser {\r\n        return new Constructors(new DUser('dwc'), undefined, persist, undefined, id).DPointerTargetable().DUser(name, surname, nickname, affiliation, country, newsletter, email, token).end();\r\n    }\r\n\r\n    /*\r\n    static async loadOffline(): Promise<void> {\r\n        if (DUser.current) return;\r\n        const user = Storage.read<DUser>('user');\r\n        if (user) {\r\n            DUser.new(user.name, user.surname, user.nickname, user.affiliation, user.country, user.newsletter, user.email, user.token, user.id);\r\n            DUser.current = user.id;\r\n            statehistory[user.id] = new UserHistory();\r\n        } else DUser.current = '';\r\n    }*/\r\n\r\n    static offline(allowOffline:boolean=true, allowOnline: boolean = false): DUser | null {\r\n        let ptr: Pointer<DUser> = 'Pointer_OfflineUser';\r\n        let isOffline = U.isOffline();\r\n        if (!isOffline) allowOffline = false;\r\n        let isValid = (d: DUser)=>{\r\n            if (!d) return false;\r\n            let savedUserIsOffline = d.id === ptr;\r\n            if (savedUserIsOffline){\r\n                if (!allowOffline) return false;\r\n            } else if (!allowOnline) return false;\r\n            return true;\r\n        }\r\n\r\n        let d: DUser = D.from(DUser.current);\r\n        if (d && isValid(d)) return d;\r\n        let state = store.getState();\r\n        let timer: any = -1;\r\n        let saveToState = ()=>{\r\n            state = store.getState();\r\n            if (!state) return;\r\n            state.idlookup[d.id] = d;\r\n            clearInterval(timer);\r\n        }\r\n\r\n        if (state){\r\n            d = state.idlookup[ptr] as DUser;\r\n            if (d && isValid(d)) return d;\r\n        }\r\n\r\n        d = Storage.read<DUser>('user') as DUser;\r\n        if (d && isValid(d)) {\r\n            if (state?.idlookup) saveToState(); //state.idlookup[d.id] = d;\r\n            else {\r\n                timer = setInterval(saveToState, 1);\r\n            }\r\n            return d;\r\n        }\r\n\r\n        if (!allowOffline) return null; // load offline user only if in offline mode\r\n        d = DUser.new('Offline', 'User', 'Unknown', 'Unknown', 'Unknown', false, 'Unknown', 'Unknown', ptr);//`Pointer${Date.now()}_OfflineUser`);\r\n\r\n        if (d && isValid(d)){\r\n            Storage.write('user', d);\r\n            return d as DUser;\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    static load(): DUser | null {\r\n        return DUser.offline(true, true);\r\n    }\r\n}\r\n\r\n@RuntimeAccessible('LUser')\r\nexport class LUser<Context extends LogicContext<DUser> = any, D extends DUser = DUser> extends LPointerTargetable {\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    public __raw!: DUser;\r\n    id!: Pointer<DUser>;\r\n    name!: string;\r\n    surname!: string;\r\n    nickname!: string;\r\n    country!: string;\r\n    affiliation!: string;\r\n    newsletter!: boolean;\r\n    email!: string;\r\n    token!: string;\r\n    projects!: LProject[];\r\n    project!: LProject|null;\r\n    __isUser!: true;\r\n\r\n    protected get_name(context: Context): this['name'] {\r\n        return context.data.name;\r\n    }\r\n    protected set_name(val: this['name'], c: Context): boolean {\r\n        TRANSACTION(this.get_name(c)+'.name', ()=>{\r\n            SetFieldAction.new(c.data.id, 'name', val, '', false);\r\n        }, undefined, val)\r\n        return true;\r\n    }\r\n\r\n    protected get_surname(context: Context): this['surname'] {\r\n        return context.data.surname;\r\n    }\r\n    protected set_surname(val: this['surname'], c: Context): boolean {\r\n        TRANSACTION(this.get_name(c)+'.surname', ()=>{\r\n            SetFieldAction.new(c.data.id, 'surname', val, '', false);\r\n        }, c.data.surname, val)\r\n        return true;\r\n    }\r\n\r\n    protected get_nickname(context: Context): this['nickname'] {\r\n        return context.data.nickname;\r\n    }\r\n    protected set_nickname(val: this['nickname'], c: Context): boolean {\r\n        TRANSACTION(this.get_name(c)+'.nickname', ()=>{\r\n            SetFieldAction.new(c.data.id, 'nickname', val, '', false);\r\n        }, c.data.nickname, val)\r\n        return true;\r\n    }\r\n\r\n    protected get_affiliation(context: Context): this['affiliation'] {\r\n        return context.data.affiliation;\r\n    }\r\n    protected set_affiliation(val: this['affiliation'], c: Context): boolean {\r\n        TRANSACTION(this.get_name(c)+'.affiliation', ()=>{\r\n            SetFieldAction.new(c.data.id, 'affiliation', val, '', false);\r\n        }, c.data.affiliation, val)\r\n        return true;\r\n    }\r\n\r\n    protected get_country(context: Context): this['country'] {\r\n        return context.data.country;\r\n    }\r\n    protected set_country(val: this['country'], c: Context): boolean {\r\n        TRANSACTION(this.get_name(c)+'.country', ()=>{\r\n            SetFieldAction.new(c.data.id, 'country', val, '', false);\r\n        }, c.data.country, val)\r\n        return true;\r\n    }\r\n\r\n    protected get_newsletter(context: Context): this['newsletter'] {\r\n        return context.data.newsletter;\r\n    }\r\n    protected set_newsletter(val: this['newsletter'], c: Context): boolean {\r\n        TRANSACTION(this.get_name(c)+'.newsletter', ()=>{\r\n            SetFieldAction.new(c.data.id, 'newsletter', val, '', false);\r\n        }, c.data.newsletter, val)\r\n        return true;\r\n    }\r\n\r\n    protected get_email(context: Context): this['email'] {\r\n        return context.data.email;\r\n    }\r\n    protected set_email(val: this['email'], c: Context): boolean {\r\n        TRANSACTION(this.get_name(c)+'.email', ()=>{\r\n            SetFieldAction.new(c.data.id, 'email', val, '', false);\r\n        }, c.data.email, val)\r\n        return true;\r\n    }\r\n\r\n    protected get_token(context: Context): this['token'] {\r\n        return context.data.token;\r\n    }\r\n    protected set_token(val: this['token'], c: Context): boolean {\r\n        TRANSACTION(this.get_name(c)+'.token', ()=>{\r\n            SetFieldAction.new(c.data.id, 'token', val, '', false);\r\n        }, c.data.token, val)\r\n        return true;\r\n    }\r\n\r\n    protected get_projects(context: Context): this['projects'] {\r\n        return (LProject.fromPointer(context.data.projects) as this['projects']).filter(p=>!!p);\r\n    }\r\n    protected set_projects(val: PackArr<this['projects']>, c: Context): boolean {\r\n        let ptrs = Pointers.from(val)||[];\r\n        TRANSACTION(this.get_name(c)+'.projects', ()=>{\r\n            SetFieldAction.new(c.data.id, 'projects', ptrs, '', true);\r\n        })\r\n        return true;\r\n    }\r\n\r\n    protected get_project(context: Context): this['project'] {\r\n        const project = context.data.project;\r\n        return project && LProject.fromPointer(project) || null;\r\n    }\r\n    protected set_project(val: Pack<Exclude<this['project'], null>>|null, c: Context): boolean {\r\n        let ptr: Pointer<LProject> = Pointers.from(val as any);\r\n        if (!ptr) ptr = '';\r\n        if (ptr === c.data.project) return true;\r\n\r\n        TRANSACTION(this.get_name(c)+'.project', ()=>{\r\n            SetFieldAction.new(c.data.id, 'project', ptr, '', true);\r\n        })\r\n        return true;\r\n    }\r\n}\r\n\r\nRuntimeAccessibleClass.set_extend(DPointerTargetable, DUser);\r\nRuntimeAccessibleClass.set_extend(LPointerTargetable, LUser);\r\nexport type WUser = getWParams<LUser, DUser>;\r\n\r\n@Leaf\r\n@RuntimeAccessible('DProject')\r\nexport class DProject extends DPointerTargetable {\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n\r\n    id!: Pointer<DProject, 1, 1, LProject>;\r\n    type: 'public'|'private'|'collaborative' = 'public';\r\n    name!: string;\r\n    author: Pointer<DUser> = DUser.current;\r\n    collaborators: Pointer<DUser, 0, 'N'> = [];\r\n    onlineUsers : number = 0;\r\n    metamodels: Pointer<DModel, 0, 'N'> = [];\r\n    models: Pointer<DModel, 0, 'N'> = [];\r\n    graphs: Pointer<DGraph, 0, 'N'> = [];\r\n    // views: Pointer<DViewElement, 0, 'N'> = []; // can be retrieved from viewpoints.subviews\r\n    // stackViews: Pointer<DViewPoint, 0, 'N'> = []; // ??\r\n    viewpoints: Pointer<DViewPoint, 0, 'N'> = [];\r\n    activeViewpoint: Pointer<DViewPoint, 1, 1> = Defaults.viewpoints[0];\r\n    favorite!: Dictionary<Pointer<DUser>, true | undefined>;\r\n\r\n    description!: string;\r\n    creation: number = Date.now();\r\n    lastModified: number = Date.now();\r\n    viewpointsNumber: number = 0;\r\n    metamodelsNumber: number = 0;\r\n    modelsNumber: number = 0;\r\n    isFavorite: boolean = false;\r\n\r\n    // collaborators dict user: priority\r\n\r\n    state!: string;\r\n\r\n    public static new(type: DProject['type'], name?: string, state?: DProject['state'],\r\n                      m2?: DProject['metamodels'], m1?: DProject['models'], id?: DProject['id'], otherProjects?:LProject[]): DProject {\r\n\r\n        // fix name\r\n        if (!otherProjects) otherProjects = LPointerTargetable.fromPointer(DUser.current).projects;\r\n        if (!name) {\r\n            // autofix default name\r\n            let regexp = /Project (\\d+)/;\r\n            const matches = otherProjects.map(p=>(+(regexp.exec(p.name)?.[1] as any) || 0));\r\n            let maxnum = Math.max(...matches, 0);\r\n            name = 'Project ' + (1 + maxnum);\r\n        }\r\n        else {\r\n            // autofix manually inputted name\r\n            let allProjectNames: Dictionary<string, LProject> = U.objectFromArray(otherProjects, (p)=>p.name);\r\n            name = U.increaseEndingNumber(name, false, false, (s)=>!!allProjectNames[s]);\r\n        }\r\n\r\n        return new Constructors(new DProject('dwc'), undefined, true, undefined)\r\n            .DPointerTargetable().DProject(type, name, state || '', m2 || [], m1 || [], id).end(); }\r\n}\r\n\r\n@RuntimeAccessible('LProject')\r\nexport class LProject<Context extends LogicContext<DProject> = any, D extends DProject = DProject> extends LPointerTargetable {\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n\r\n    readonly id!: Pointer<DProject>;\r\n    type!: 'public'|'private'|'collaborative';\r\n    author!: LUser;\r\n    collaborators!: LUser[];\r\n    onlineUsers!: number;\r\n    name!: string;\r\n    metamodels!: LModel[];\r\n    models!: LModel[];\r\n    graphs!: LGraph[];\r\n    // stackViews!: LViewElement[];\r\n    viewpoints!: LViewPoint[];\r\n    activeViewpoint!: LViewPoint;\r\n    favorite!: boolean;\r\n\r\n    description!: string;\r\n    creation!: number;\r\n    lastModified!: number;\r\n    viewpointsNumber!: number;\r\n    metamodelsNumber!: number;\r\n    modelsNumber!: number;\r\n    isFavorite!: boolean;\r\n\r\n    // stringify state\r\n    state!: string;\r\n\r\n    /* DATA */\r\n    readonly packages!: LPackage[];\r\n    readonly classes!: LClass[];\r\n    readonly attributes!: LAttribute[];\r\n    readonly references!: LReference[];\r\n    readonly operations!: LOperation[];\r\n    readonly parameters!: LParameter[];\r\n    readonly enumerators!: LEnumerator[];\r\n    readonly literals!: LEnumLiteral[];\r\n    readonly objects!: LObject[];\r\n    readonly values!: LValue[];\r\n\r\n    /* NODES */\r\n    readonly allNodes!: NodeTypes[];\r\n    readonly graphVertexes!: LGraphVertex[];\r\n    readonly voidVertexes!: LVoidVertex[];\r\n    readonly vertexes!: LVertex[];\r\n    readonly fields!: LGraphElement[];\r\n    readonly edges!: LEdge[];\r\n    readonly edgePoints!: LEdgePoint[];\r\n\r\n    /* UTILS */\r\n    readonly children!: LPointerTargetable[];\r\n    readonly views!: LViewElement[]; // derived from viewpoints.subView\r\n\r\n    /* Functions */\r\n\r\n    protected get_description(context: Context): this['description'] {\r\n        return context.data.description;\r\n    }\r\n    protected set_description(val: this['description'], c: Context): boolean {\r\n        TRANSACTION(this.get_name(c)+'.description', ()=>{\r\n            SetFieldAction.new(c.data.id, 'description', val, '', false);\r\n        }, c.data.description, val)\r\n        return true;\r\n    }\r\n\r\n    protected get_creation(context: Context): this['creation'] {\r\n        return context.data.creation;\r\n    }\r\n    protected set_creation(val: this['creation'], c: Context): boolean {\r\n        TRANSACTION(this.get_name(c)+'.creation', ()=>{\r\n            SetFieldAction.new(c.data.id, 'creation', val, '', false);\r\n        }, c.data.creation, val)\r\n        return true;\r\n    }\r\n\r\n    protected get_lastModified(context: Context): this['lastModified'] {\r\n        return context.data.lastModified;\r\n    }\r\n    protected set_lastModified(val: this['lastModified'], c: Context): boolean {\r\n        TRANSACTION(this.get_name(c)+'.lastModified', ()=>{\r\n            SetFieldAction.new(c.data.id, 'lastModified', val, '', false);\r\n        }, c.data.lastModified, val)\r\n        return true;\r\n    }\r\n\r\n    protected get_viewpointsNumber(c: Context): this['viewpointsNumber'] {\r\n        return c.data.viewpointsNumber;\r\n    }\r\n    protected set_viewpointsNumber(val: this['viewpointsNumber'], c: Context): boolean {\r\n        TRANSACTION(this.get_name(c)+'.viewpointsNumber', ()=>{\r\n            SetFieldAction.new(c.data.id, 'viewpointsNumber', val, '', false);\r\n        }, c.data.viewpointsNumber, val)\r\n        return true;\r\n    }\r\n\r\n    protected get_metamodelsNumber(c: Context): this['metamodelsNumber'] {\r\n        return c.data.metamodelsNumber;\r\n    }\r\n    protected set_metamodelsNumber(val: this['metamodelsNumber'], c: Context): boolean {\r\n        TRANSACTION(this.get_name(c)+'.metamodelsNumber', ()=>{\r\n            SetFieldAction.new(c.data.id, 'metamodelsNumber', val, '', false);\r\n        }, c.data.metamodelsNumber, val)\r\n        return true;\r\n    }\r\n\r\n    protected get_modelsNumber(context: Context): this['modelsNumber'] {\r\n        return context.data.modelsNumber;\r\n    }\r\n    protected set_modelsNumber(val: this['modelsNumber'], c: Context): boolean {\r\n        TRANSACTION(this.get_name(c)+'.modelsNumber', ()=>{\r\n            SetFieldAction.new(c.data.id, 'modelsNumber', val, '', false);\r\n        }, c.data.modelsNumber, val)\r\n        return true;\r\n    }\r\n\r\n    protected get_isFavorite(context: Context): this['isFavorite'] {\r\n        return context.data.isFavorite;\r\n    }\r\n    protected set_isFavorite(val: this['isFavorite'], context: Context): boolean {\r\n        const data = context.data;\r\n        return SetFieldAction.new(data.id, 'isFavorite', val, '', false);\r\n    }\r\n\r\n    protected get_favorite(c: Context): this['favorite'] {\r\n        const uid = DUser.current;\r\n        if (!c.data.favorite) return false;\r\n        return !!c.data.favorite[uid];\r\n    }\r\n    protected set_favorite(v: boolean, c: Context): true {\r\n        let favMap = c.data.favorite;\r\n        const uid = DUser.current;\r\n        v = !!v;\r\n        if (!v && !favMap || v === favMap[uid]) return true;\r\n        TRANSACTION(this.get_name(c)+'.favorite', ()=>{\r\n            SetFieldAction.new(c.data.id, 'favorite', {[uid]: v ? true : undefined}, v ? '+=' : '-='); //!favMap ? '' : (v ? '+=' : '-=');\r\n        }, !!favMap?.[uid], v)\r\n        return true;\r\n    }\r\n    protected get_name(context: Context): this['name'] {\r\n        return context.data.name;\r\n    }\r\n    protected set_name(val: this['name'], c: Context): boolean {\r\n        if (c.data.name === val) return true;\r\n        TRANSACTION(this.get_name(c)+'.name', ()=>{\r\n            SetFieldAction.new(c.data.id, 'name', val, '', false);\r\n        }, undefined, val)\r\n        return true;\r\n    }\r\n\r\n    protected get_author(context: Context): this['author'] {\r\n        return LUser.fromPointer(context.data.author);\r\n    }\r\n    protected set_author(val0: Pack<this['author']>, c: Context): boolean {\r\n        let val: Pointer<LUser> = Pointers.from(val0) as any;\r\n        TRANSACTION(this.get_name(c)+'.author', ()=> {\r\n            SetFieldAction.new(c.data.id, 'author', val, '', true);\r\n        })\r\n        return true;\r\n    }\r\n\r\n    public get_state(context: Context): this['state'] {\r\n        return context.data.state;\r\n    }\r\n    public set_state(val: this['state'], c: Context): boolean {\r\n        TRANSACTION(this.get_name(c)+'.state', ()=>{\r\n            SetFieldAction.new(c.data.id, 'state', val, '', false);\r\n        })\r\n        return true;\r\n    }\r\n\r\n    protected get_collaborators(context: Context): this['collaborators'] {\r\n        return LUser.fromPointer(context.data.collaborators) || [];\r\n    }\r\n    protected set_collaborators(val0: PackArr<this['collaborators']>, c: Context): boolean {\r\n        let val: Pointer<LUser> = Pointers.from(val0) as any;\r\n        TRANSACTION(this.get_name(c)+'.collaborators', ()=>{\r\n            SetFieldAction.new(c.data.id, 'collaborators', val, '', true);\r\n        })\r\n        return true;\r\n    }\r\n\r\n    protected get_onlineUsers(context: Context): this['onlineUsers'] {\r\n        return context.data.onlineUsers;\r\n    }\r\n    protected set_onlineUsers(val: this['onlineUsers'], c: Context): boolean {\r\n        TRANSACTION(this.get_name(c)+'.onlineUsers', ()=>{\r\n            SetFieldAction.new(c.data.id, 'onlineUsers', val, '', false);\r\n        }, c.data.onlineUsers, val)\r\n        return true;\r\n    }\r\n\r\n    protected get_metamodels(context: Context): this['metamodels'] {\r\n        return LModel.fromPointer(context.data.metamodels) || [];\r\n    }\r\n    protected set_metamodels(val0: PackArr<this['metamodels']>, c: Context): boolean {\r\n        let val = Pointers.from(val0);\r\n        TRANSACTION(this.get_name(c)+'.metamodels', () => {\r\n            SetFieldAction.new(c.data.id, 'metamodels', val, '', true);\r\n        })\r\n        return true;\r\n    }\r\n\r\n    protected get_models(c: Context): this['models'] {\r\n        let ret = (L.fromPointer(c.data.models) || []).filter(e=>!!e) as LModel[];\r\n        if (ret.length !== c.data.models.length) this.set_models(ret.map(e=>e.id) as any, c); // fix for older projects\r\n        return ret;\r\n    }\r\n    protected set_models(val0: PackArr<this['models']>, c: Context): boolean {\r\n        let val = Pointers.from(val0);\r\n        TRANSACTION(this.get_name(c)+'.models', () => {\r\n            SetFieldAction.new(c.data.id, 'models', val, '', true);\r\n        })\r\n        return true;\r\n    }\r\n\r\n    protected get_graphs(context: Context): this['graphs'] {\r\n        return LGraph.fromPointer(context.data.graphs) || [];\r\n    }\r\n    protected set_graphs(val0: PackArr<this['graphs']>, c: Context): boolean {\r\n        let val = Pointers.from(val0);\r\n        TRANSACTION(this.get_name(c)+'.graphs', () => {\r\n            SetFieldAction.new(c.data.id, 'graphs', val, '', true);\r\n        })\r\n        return true;\r\n    }\r\n\r\n    protected get_views(c: Context): this['views'] {\r\n        // return LViewElement.fromPointer([...c.data.views, ...Defaults.views]);\r\n        let duplicateRemover: Dictionary<Pointer, LViewElement> = {};\r\n        let varr = this.get_viewpoints(c).flatMap(vp => vp.allSubViews);\r\n        for (let v of varr) duplicateRemover[v.id] = v;\r\n        return Object.values(duplicateRemover);\r\n    }\r\n\r\n    protected set_views(val: PackArr<this['views']>, context: Context): boolean {\r\n        return Log.exx(\"cannot set project.views, set them as subviews of a project viewpoint.\");\r\n        /*\r\n        const data = context.data;\r\n        let ptrs = Pointers.from(val);\r\n        let defaultViewsMap: Dictionary<Pointer, boolean> = U.objectFromArrayValues(Defaults.views);\r\n        ptrs = ptrs.filter(ptr => !defaultViewsMap[ptr]);\r\n        SetFieldAction.new(data.id, 'views', ptrs, '', true);\r\n        return true;*/\r\n    }\r\n    /*\r\n        protected get_stackViews(context: Context): this['stackViews'] {\r\n            return LViewElement.fromPointer(context.data.stackViews || []);\r\n        }\r\n        protected set_stackViews(val: PackArr<this['stackViews']>, context: Context): boolean {\r\n            const data = context.data;\r\n            SetFieldAction.new(data.id, 'stackViews', Pointers.from(val), '', true);\r\n            return true;\r\n        }*/\r\n\r\n    protected get_viewpoints(context: Context): this['viewpoints'] {\r\n        return LViewPoint.fromPointer([...Defaults.viewpoints, ...(context.data.viewpoints || [])]);\r\n    }\r\n    protected set_viewpoints(val0: PackArr<this['viewpoints']>, c: Context): boolean {\r\n        let val = Pointers.from(val0);\r\n        TRANSACTION(this.get_name(c)+'.viewpoints', ()=>{\r\n            SetFieldAction.new(c.data.id, 'viewpoints', val, '', true);\r\n        })\r\n        return true;\r\n    }\r\n\r\n    protected get_activeViewpoint(context: Context): this['activeViewpoint'] {\r\n        return LViewPoint.fromPointer(context.data.activeViewpoint || Defaults.viewpoints[0]);\r\n    }\r\n    protected set_activeViewpoint(val0: Pack1<this['activeViewpoint']>, c: Context): boolean {\r\n        let val = Pointers.from(val0);\r\n        TRANSACTION(this.get_name(c)+'.activeViewpoint', ()=>{\r\n            SetFieldAction.new(c.data.id, 'activeViewpoint', val, '', true);\r\n        })\r\n        return true;\r\n    }\r\n\r\n    /* DATA Getter */\r\n    protected get_packages(c: Context): this['packages'] {\r\n        const data = c.proxyObject as LProject;\r\n        return data.metamodels.flatMap(m => m.allSubPackages);\r\n    }\r\n    protected get_classes(context: Context): this['classes'] {\r\n        const data = context.proxyObject as LProject;\r\n        return data.packages.flatMap(p => p.classes);\r\n    }\r\n    protected get_attributes(context: Context): this['attributes'] {\r\n        const data = context.proxyObject as LProject;\r\n        return data.classes.flatMap(c => c.attributes);\r\n    }\r\n    protected get_references(context: Context): this['references'] {\r\n        const data = context.proxyObject as LProject;\r\n        return data.classes.flatMap(c => c.references);\r\n    }\r\n    protected get_operations(context: Context): this['operations'] {\r\n        const data = context.proxyObject as LProject;\r\n        return data.classes.flatMap(c => c.operations);\r\n    }\r\n    protected get_parameters(context: Context): this['parameters'] {\r\n        const data = context.proxyObject as LProject;\r\n        return data.operations.flatMap(o => o.parameters);\r\n    }\r\n    protected get_enumerators(context: Context): this['enumerators'] {\r\n        const data = context.proxyObject as LProject;\r\n        return data.packages.flatMap(p => p.enumerators);\r\n    }\r\n    protected get_literals(context: Context): this['literals'] {\r\n        const data = context.proxyObject as LProject;\r\n        return data.enumerators.flatMap(e => e.literals);\r\n    }\r\n    protected get_objects(context: Context): this['objects'] {\r\n        const data = context.proxyObject as LProject;\r\n        return data.models.flatMap(m => m.allSubObjects);\r\n    }\r\n    protected get_values(context: Context): this['values'] {\r\n        const data = context.proxyObject as LProject;\r\n        return data.models.flatMap(m => m.allSubValues);\r\n    }\r\n\r\n    /* NODES Getter */\r\n    protected get_allNodes(context: Context): this['allNodes'] {\r\n        const data = context.proxyObject as LProject;\r\n        const nodes: NodeTypes[] = [];\r\n        // nodes.push(...(data.metamodels.flatMap(m => m.node).filter(n => n !== undefined) as NodeTypes[]));\r\n        nodes.push(...(data.packages.flatMap(m => m.node).filter(n => n !== undefined) as NodeTypes[]));\r\n        nodes.push(...(data.classes.flatMap(m => m.node).filter(n => n !== undefined) as NodeTypes[]));\r\n        nodes.push(...(data.attributes.flatMap(m => m.node).filter(n => n !== undefined) as NodeTypes[]));\r\n        nodes.push(...(data.references.flatMap(m => m.node).filter(n => n !== undefined) as NodeTypes[]));\r\n        nodes.push(...(data.operations.flatMap(m => m.node).filter(n => n !== undefined) as NodeTypes[]));\r\n        nodes.push(...(data.parameters.flatMap(m => m.node).filter(n => n !== undefined) as NodeTypes[]));\r\n        nodes.push(...(data.enumerators.flatMap(m => m.node).filter(n => n !== undefined) as NodeTypes[]));\r\n        nodes.push(...(data.literals.flatMap(m => m.node).filter(n => n !== undefined) as NodeTypes[]));\r\n        // nodes.push(...(data.models.flatMap(m => m.node).filter(n => n !== undefined) as NodeTypes[]));\r\n        nodes.push(...(data.objects.flatMap(m => m.node).filter(n => n !== undefined) as NodeTypes[]));\r\n        nodes.push(...(data.values.flatMap(m => m.node).filter(n => n !== undefined) as NodeTypes[]));\r\n        return nodes;\r\n    }\r\n    protected get_graphVertexes(context: Context): this['graphVertexes'] {\r\n        const data = context.proxyObject as LProject;\r\n        return data.allNodes.filter(n => n.className === 'DGraphVertex') as LGraphVertex[];\r\n    }\r\n    protected get_voidVertexes(context: Context): this['voidVertexes'] {\r\n        const data = context.proxyObject as LProject;\r\n        return data.allNodes.filter(n => n.className === 'DVoidVertex') as LVoidVertex[];\r\n    }\r\n    protected get_vertexes(context: Context): this['vertexes'] {\r\n        const data = context.proxyObject as LProject;\r\n        return data.allNodes.filter(n => n.className === 'DVertex') as LVertex[];\r\n    }\r\n    protected get_fields(context: Context): this['fields'] {\r\n        const data = context.proxyObject as LProject;\r\n        return data.allNodes.filter(n => n.className === 'DGraphElement') as LGraphElement[];\r\n    }\r\n    protected get_edges(context: Context): this['edges'] {\r\n        const data = context.proxyObject as LProject;\r\n        return data.graphs.flatMap(g => g.subElements.filter(e => e.className === 'DEdge')) as LEdge[];\r\n    }\r\n    protected get_edgePoints(context: Context): this['edgePoints'] {\r\n        const data = context.proxyObject as LProject;\r\n        return data.edges.flatMap(e => e.subElements) as LEdgePoint[];\r\n    }\r\n\r\n    /* CUSTOM Functions */\r\n    protected get_children(context: Context): this['children'] {\r\n        const data = context.proxyObject as LProject;\r\n        return [\r\n            /* Data */\r\n            ...data.metamodels,\r\n            ...data.packages,\r\n            ...data.classes,\r\n            ...data.attributes,\r\n            ...data.references,\r\n            ...data.operations,\r\n            ...data.parameters,\r\n            ...data.enumerators,\r\n            ...data.literals,\r\n            ...data.models,\r\n            ...data.objects,\r\n            ...data.values,\r\n            /* Views & Viewpoints */\r\n            ...data.views.filter(v => v && !Defaults.views.includes(v.id)),\r\n            ...data.viewpoints.filter(vp => vp && !Defaults.viewpoints.includes(vp.id)),\r\n            /* Nodes */\r\n            ...data.allNodes\r\n        ];\r\n    }\r\n\r\n    /*\r\n        public pushToStackViews(view: Pack<LViewElement>): void {\r\n            throw new Error('cannot be called directly, should trigger getter. this is only for correct signature');\r\n        }\r\n        protected get_pushToStackViews(context: Context): (view: Pack<LViewElement>) => void {\r\n            return (view) => {\r\n                const data = context.data;\r\n                SetFieldAction.new(data.id, 'stackViews', Pointers.from(view), ', true);\r\n            }\r\n        }\r\n    /*\r\n        public popFromStackViews(): void {\r\n            throw new Error('cannot be called directly, should trigger getter. this is only for correct signature');\r\n        }\r\n        protected get_popFromStackViews(context: Context): () => void {\r\n            return () => {\r\n                const data = context.data;\r\n                const view = data.stackViews?.at(-1);\r\n                if(!view) return;\r\n                SetFieldAction.new(data.id, 'stackViews', view as any, '-=', true);\r\n            }\r\n        }\r\n    */\r\n    public delete(): void {\r\n        throw new Error('cannot be called directly, should trigger getter. this is only for correct signature');\r\n    }\r\n    protected get_delete(c: Context): () => void {\r\n        const data = c.proxyObject as LProject;\r\n        return () => {\r\n            TRANSACTION('delete ' + this.get_name(c), ()=> {\r\n                SetFieldAction.new(DUser.current, 'projects', c.data.id as any, '-=', true);\r\n                DeleteElementAction.new(data.id);\r\n                SetRootFieldAction.new('projects', c.data.id, '-=', true);\r\n\r\n                // project can only be deleted in homepage, project list is not even present in editor state.\r\n                // if (windoww.location.hasg.includes('project') windoww.location.href = windoww.location.origin; use R.navigate\r\n            });\r\n        }\r\n    }\r\n\r\n    duplicate(): LProject{ return this.wrongAccessMessage('LProject.duplicate()')};\r\n    get_duplicate(c: Context): ()=>LProject{\r\n        return () => {\r\n            let clone: DProject = DProject.new(c.data.type, c.data.name + ' Copy');\r\n            for (let key in c.data){\r\n                switch (key){\r\n                    case 'id':\r\n                    case 'pointedBy':\r\n                    case 'name':\r\n                        continue;\r\n                    default:\r\n                        // @ts-ignore\r\n                        clone[key] = c.data[key];\r\n                        break;\r\n            }\r\n        }\r\n        clone.author = DUser.current;\r\n        clone.onlineUsers = 0;// i think this should not be a presistent data, but a fake attribute available only on LProject\r\n        // todo per giordano: assign project to user & set persistent stuff with ProjectsAPI ?\r\n        return LPointerTargetable.fromD(clone); }\r\n    }\r\n}\r\n\r\nRuntimeAccessibleClass.set_extend(DPointerTargetable, DProject);\r\nRuntimeAccessibleClass.set_extend(LPointerTargetable, LProject);\r\nexport type WProject = getWParams<LProject, DProject>;\r\n\r\n\r\n@RuntimeAccessible('MyError')\r\nexport class MyError extends Error {\r\n    constructor(message?: string, ...otherMsg: any[]) {\r\n        // 'Error' breaks prototype chain here\r\n        super(message);\r\n        const proto = (this as any).__proto__;\r\n\r\n        console.error(proto.constructor.cname || proto.constructor.name, message, ...otherMsg);\r\n        // restore prototype chain\r\n        const actualProto = new.target.prototype;\r\n\r\n        if (Object.setPrototypeOf) { Object.setPrototypeOf(this, actualProto); }\r\n        else { (this as any).__proto__ = actualProto; }\r\n        (this as any).className = (this.constructor as typeof RuntimeAccessibleClass).cname;\r\n    }\r\n}\r\n\r\n// @RuntimeAccessible\r\nexport class JsType{\r\n    public static all: JsType[] = [];\r\n    public static object: JsType = new JsType(\"object\", JsType.isObject, false);\r\n    public static function: JsType = new JsType(\"function\", JsType.isFunction, false);\r\n    public static array: JsType = new JsType(\"array\", JsType.isArray, false);\r\n    public static date: JsType = new JsType(\"Date\", JsType.isDate, false);\r\n\r\n    public static lambdaFunction: JsType = new JsType(\"lambda-function\", JsType.isLambdaFunction, true);\r\n    public static nonLambdaFunction: JsType = new JsType(\"non-lambda-function\", JsType.isNonLambdaFunction, true);\r\n    public static symbol: JsType = new JsType(\"symbol\", JsType.isSymbol, true);\r\n    public static undefined: JsType = new JsType(\"undefined\", JsType.isUndefined, true);\r\n    public static null: JsType = new JsType(\"null\", JsType.isNull, true);\r\n    public static boolean: JsType = new JsType(\"boolean\", JsType.isBoolean, true);\r\n    public static number: JsType = new JsType(\"number\", JsType.isNumber, true);\r\n    public static bigint: JsType = new JsType(\"bigint\", JsType.isBigint, true);\r\n    public static string: JsType = new JsType(\"string\", JsType.isString, true);\r\n\r\n    private constructor(public printableTypeName: string, public check: (data: any) => boolean, public isExclusiveType: boolean){\r\n        JsType.all.push(this);\r\n    }\r\n    public toString(): string { return this.printableTypeName; }\r\n    /*\r\n    * example: isObject but not Date, not function...\r\n    * */\r\n    public static isOnlyType(data: any, type: JsType): boolean { return !JsType.getTypes(data, type).length; }\r\n    public static isAnyOfTypes(data: any, ...acceptables: JsType[]): boolean { return !!windoww.Uarr.arrayIntersection(JsType.getTypes(data), acceptables).length; }\r\n    public static getTypes(data: any, stopIfTypeIsNot?: JsType): JsType[]{\r\n        const ret: JsType[] = [];\r\n        for (const type of JsType.all) {\r\n            if (type.check(data)) {\r\n                ret.push(data);\r\n                if (stopIfTypeIsNot !== type) { return []; }\r\n                if (type.isExclusiveType) return ret;\r\n            }\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    /// is...\r\n    public static isObject(data: GObject | any, returnIfNull: boolean = false): boolean { return data === null ? returnIfNull : typeof data === \"object\"; }\r\n    public static isFunction(data: Function | any): boolean { return typeof data === \"function\"; }\r\n    public static isLambdaFunction(data: Function | any): boolean {\r\n        if (!JsType.isFunction(data)) return false;\r\n        return windoww.U.getFunctionSignatureFromComments(data).isLambda; }\r\n    public static isNonLambdaFunction(data: Function | any): boolean { return JsType.isFunction(data) && !JsType.isNonLambdaFunction(data); }\r\n    public static isArray(data: Array<any> | any): boolean { return Array.isArray(data); }\r\n    public static isSymbol(data: symbol | any): boolean { return typeof data === \"symbol\"; }\r\n    public static isBoolean(data: symbol | any): boolean { return !!data === data; }\r\n    public static isNumber(data: number | any): boolean { return typeof data === \"number\"; }\r\n    public static isBigint(data: bigint | any): boolean { return typeof data === \"bigint\"; }\r\n    public static isString(data: string | any): boolean { return typeof data === \"string\"; }\r\n    public static isNull(data: null | any): boolean { return data === null; }\r\n    public static isUndefined(data: undefined | any): boolean { return data === undefined; }\r\n    public static isDate(data: Date | any): boolean { return data instanceof Date; }\r\n\r\n    /// as...\r\n    public static asObject<T>(data: GObject | any, fallbackReturn: T): T | GObject { return JsType.isObject(data) ? data : fallbackReturn; }\r\n    public static asFunction<T>(data: Function | any, fallbackReturn: T): T | Function { return JsType.isFunction(data) ? data : fallbackReturn; }\r\n    public static asLambdaFunction<T>(data: Function | any, fallbackReturn: T): T | Function { return JsType.isLambdaFunction(data) ? data : fallbackReturn; }\r\n    public static asNonLambdaFunction<T>(data: Function | any, fallbackReturn: T): T | Function { return JsType.isNonLambdaFunction(data) ? data : fallbackReturn; }\r\n    public static asArray<T, A>(data: Array<A> | any, fallbackReturn: T): T | Array<A> { return JsType.isArray(data) ? data : fallbackReturn; }\r\n    public static asSymbol<T>(data: symbol | any, fallbackReturn: T): T | symbol { return JsType.isSymbol(data) ? data : fallbackReturn; }\r\n    public static asBoolean<T>(data: boolean | any, fallbackReturn: T): T | boolean { return JsType.isBoolean(data) ? data : fallbackReturn; }\r\n    public static asNumber<T>(data: number | any, fallbackReturn: T): T | number { return JsType.isNumber(data) ? data : fallbackReturn; }\r\n    public static asBigint<T>(data: bigint | any, fallbackReturn: T): T | bigint { return JsType.isBigint(data) ? data : fallbackReturn; }\r\n    public static asString<T>(data: string | any, fallbackReturn: T): T | string { return JsType.isString(data) ? data : fallbackReturn; }\r\n    public static asNull<T>(data: null | any, fallbackReturn: T): T | null { return JsType.isNull(data) ? data : fallbackReturn; }\r\n    public static asUndefined<T>(data: undefined | any, fallbackReturn: T): T | undefined { return JsType.isUndefined(data) ? data : fallbackReturn; }\r\n    public static asDate<T>(data: Date | any, fallbackReturn: T): T | Date { return JsType.isDate(data) ? data : fallbackReturn; }\r\n    public static isPrimitive(data: any) { return !JsType.isAnyOfTypes(data, JsType.object, JsType.function, JsType.array); }\r\n}\r\n\r\n\r\nfunction invalidSuperClassError(/*callee: Class,*/ scname: string, superclass: Class): (() => never) {\r\n    return () => { windoww.Log.exDevv('parent super class \"' + scname + '\" is not implementing init_constructor', {scname, superclass, }); throw new Error(); }\r\n}\r\n// @ts-ignore\r\nfunction MixinFakeConstructor() { this.isMixinFakeConstructor = true; }\r\nexport function MixOnlyFuncs2<A1 extends any[], I1, S1, A2 extends any[], I2, S2>(c1: Class<A1, I1, S1> & typeof RuntimeAccessibleClass, c2: Class<A2, I2, S2> & typeof RuntimeAccessibleClass):\r\n    Class<A1, I1, S1> & Class<A2, I2, S2>{\r\n    return MixOnlyFuncs(c1, c2) as any;\r\n}\r\nexport function MixOnlyFuncs3<A1 extends any[], I1, S1, A2 extends any[], I2, S2>(c1: Class<A1, I1, S1> & typeof RuntimeAccessibleClass, c2: Class<A2, I2, S2> & typeof RuntimeAccessibleClass):\r\n    Class<A1&A2, I1&I2, S1&S2>{\r\n    return MixOnlyFuncs(c1, c2) as any;\r\n}\r\nexport function MixOnlyFuncs<A1 extends any[], I1, S1, A2 extends any[], I2, S2>(c1: Class<A1, I1, S1> & typeof RuntimeAccessibleClass, c2: Class<A2, I2, S2> & typeof RuntimeAccessibleClass):\r\n    CClass<Longest<A1, A2>, I1 & I2\r\n        & {\r\n        // superclass: Dictionary<string, (/*thiss: I1 & I2,* / ...superConstructorParams:ConstructorParameters<Class<A1, I1, S1>> | ConstructorParameters<Class<A2, I2, S2>>) => void>,\r\n        superclass1: Dictionary<DocString<'constructor name to make sure the user knows what superclass constructor is calling'>,  (...superConstructor1Params:ConstructorParameters<Class<A1, I1, S1>>) => void>,\r\n        superclass2: Dictionary<DocString<'constructor name to make sure the user knows what superclass constructor is calling'>,  (...superConstructor2Params:ConstructorParameters<Class<A2, I2, S2>>) => void>,\r\n        // initt: Class<A1, I1, S1>\r\n    } & AbstractMixedClass\r\n        // , Omit<Omit<Omit<S1 & S2, 'init_constructor'>, 'logic'>, 'maxID'> & typeof AbstractMixedClass> {\r\n        , S1 & S2 & GObject & typeof AbstractMixedClass> {\r\n    // strategia: passo dei finti valori che copiano i prototipi delle classi sovrascrivendo i costruttori per evitare che chiami i costruttori delle superclassi\r\n    // ma che comunque erediti campi e funzioni\r\n    // @ts-ignore\r\n    let c1noconstructor: any = MixinFakeConstructor;\r\n    let c2noconstructor: any = MixinFakeConstructor;\r\n    c1noconstructor.prototype = c1.prototype;\r\n    c2noconstructor.prototype = c2.prototype;\r\n\r\n    let disableconstructor = false;\r\n    if (!disableconstructor) {\r\n        c1noconstructor = c1;\r\n        c2noconstructor = c2; }\r\n\r\n\r\n    let ret = Mixin(c1noconstructor, c2noconstructor);\r\n    let c1name = (c1.cname || c1.name) === 'classnameFixedConstructorDoNotRenameWithoutSearchStrings' ? c1.prototype.className : c1.cname || c1.name;\r\n    let c2name = (c2.cname || c2.name) === 'classnameFixedConstructorDoNotRenameWithoutSearchStrings' ? c2.prototype.className : c2.cname || c2.name;\r\n    //ret.prototype['superclass'] = {};\r\n    // ret.prototype['superclass'][c1name] = c1.prototype.init_constructor || invalidSuperClassError(c1name, c1);\r\n    // ret.prototype['superclass'][c2name] = c2.init_constructor || invalidSuperClassError(c2name, c2);\r\n    ret.prototype['superclass1'] = {};\r\n    ret.prototype['superclass2'] = {};\r\n    ret.prototype['superclass1'][c1name] = c1.init_constructor || invalidSuperClassError(c1name, c1);\r\n    ret.prototype['superclass2'][c2name] = c2.init_constructor || invalidSuperClassError(c2name, c2);\r\n    return ret;\r\n}\r\n// console.info('ts loaded classes');\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n//*********************************************************************************************\r\n//*********************************************************************************************\r\n///////                              type juggling starts here                          ///////\r\n//*********************************************************************************************\r\n//*********************************************************************************************\r\n\r\n// export type NotAString<T extends any = 'uselessval'> = Omit<string, 'bold'> & {big: T};\r\n// export type NotAString<T extends any = 'uselessval'> = Omit<string, 'bold'>;\r\n// export type NotAString<T extends any = 'uselessval', T2 extends any = any, T3 extends any = any, T4 extends any = any> = string & Omit<string, 'bold'> & {bold: ()=>string};\r\nexport type NotAString<T extends any = 'uselessval', T2 extends any = any, T3 extends any = any, T4 extends any = any> = string & Omit<string, 'bold'> & {bolda?: T};\r\n// export type NotAString<T> = string;\r\n// type Pointer<T> = NotAString<T>;\r\nexport type Pointer<T extends DPointerTargetable = DPointerTargetable, lowerbound extends number = 1, upperbound extends number|'N' = 1,\r\n    RET extends LPointerTargetable = DtoL<T>> =\r\n    upperbound extends 'N' ? NotAString<T, lowerbound, upperbound, RET>[] : (\r\n        upperbound extends 0 ? never : (\r\n            lowerbound extends 0 ? (NotAString<T, lowerbound, upperbound, RET> | null) : NotAString<T, upperbound, lowerbound, RET>));\r\n\r\n\r\nexport type PtrString = any; // to convert Pointers to strings more explicitly then using as any\r\n// let ptr: Pointer<Object> = null as any;\r\n/*\r\nclass D extends DPointerTargetable{\r\n    parent!: Pointer<D>;\r\n    dattrib!: boolean;\r\n    juststring!: string;\r\n    nattrib!: number;\r\n    ddattrib!: Date\r\n}\r\n\r\nclass D2 extends D{\r\n    d2!: string;\r\n}\r\nclass D3 extends D{\r\n    d3!: string;\r\n}\r\n\r\n\r\n\r\ntype OverrideTypes<M, N> = { [P in keyof M]: P extends keyof N ? N[P] : M[P] }; // usage:  OverrideTypes<A, { x: number }>;\r\n\r\ninterface LFix {\r\n    parent: L;\r\n}\r\ninterface L { // no instances ever\r\n    parent: L;\r\n    lattrib: boolean;\r\n}\r\ninterface L2 extends L { // no instances ever\r\n    l2: string;\r\n}\r\ninterface L3 extends L{ // no instances ever\r\n    l3: string;\r\n}\r\n\r\nclass P { // singleton\r\n    get_parent(){}\r\n    set_parent(){}\r\n}\r\nclass P2 extends P { // singleton\r\n    get_d2() {}\r\n}\r\nclass P3 extends P { // singleton\r\n    get_d3() {}\r\n}*/\r\n\r\ntype ERROR = \"_TYPE_ERROR_\";\r\n// RegExp extends Animal ? number : string\r\n\r\n\r\nfunction buildWrapSignature(maxdepth = 100) {\r\n    let arr = windoww[\"DPointerTargetable\"].subclasses;\r\n    /*\r\n    let dict0 = arr.reduce((a, v) => ({ ...a, [v.name]: v}), {});\r\n    let dict = {}\r\n    for (let name in dict0) { let n = name.substring(1); dict[n] = {\"D\":dict0[\"D\"+n], \"L\":dict0[\"L\"+n]}; dict[\"D\"+n] = dict0[\"L\"+n]; dict[\"L\"+n] = dict0[\"D\"+n]; }\r\n    console.log(\"dict\", dict);\r\n    console.table(dict);\r\n    */\r\n    function onlyUnique(value: any, index: number, self: any) { return self.indexOf(value) === index; }\r\n\r\n    let dep = arr; // .map( (me) => { return {\"name\": me.name, \"me\": me, \"Derror\": (dict[me.name] || me).name, \"Lerror\": (dict[me.name] || me).name, \"subclasses\": [...me.subclasses]}});\r\n    let depsorted = [];\r\n\r\n    let byLevels = [];\r\n    let loopdetecter: any[] = [arr];\r\n    while (dep.length && maxdepth--) {\r\n        let namelist = dep.map((e: any) => e.name).filter(onlyUnique);\r\n        depsorted.push(...namelist);\r\n        byLevels.push([...namelist]);\r\n        let olddep = dep;\r\n        dep = dep.flatMap((d: any) => d.subclasses).filter(onlyUnique);\r\n        for (let d of dep) {\r\n            windoww.loopdetecter = loopdetecter;\r\n            windoww.dep = dep;\r\n            windoww.olddep = olddep;\r\n            windoww.byLevels = byLevels;\r\n            windoww.d = d;\r\n            if ( loopdetecter.includes(d.subclasses) ) throw new Error(\"class is not redefining subclasses static array: \" + d.name);\r\n            loopdetecter.push(d.subclasses);\r\n        }\r\n    }\r\n    console.log(\"byLevels\");\r\n    console.table(byLevels);\r\n\r\n    console.log(\"depsorted\", depsorted);\r\n\r\n    // console.log(\"map\");\r\n    // console.table(depsorted.map(dn => {let d = window[dn]; return !d ? \"\" :{name:d.name, scount: d.subclasses.length, subclasses:d.subclasses}}));\r\n\r\n\r\n    let goalSignature = \"function wrap<DX extends D, LX = DX extends D2 ? L2: (DX extends D3 ? L3: (DX extends D ? L : ERROR))>(data: DX): LX {\";\r\n    let lparam = \"ERROR\";\r\n    let epsorted = depsorted.map( e => e.substring(1)).filter(onlyUnique);\r\n    console.table(epsorted)\r\n    for (let e of epsorted) {\r\n        let D = \"D\" + e;\r\n        let L = \"L\" + e;\r\n        lparam = \"DX extends \" + D + \" ? \"  + L + \" : (\" + (lparam) + \")\";\r\n    }\r\n    let signature = \"function wrap<DX extends DPointerTargetable, LX = \" + lparam + \">(data: DX): LX {\";\r\n    return signature;\r\n}\r\nwindoww.buildWrapSignature = buildWrapSignature;\r\n// function wrap<DX extends D, LX = DX extends D2 ? L2: (DX extends D3 ? L3: (DX extends D ? L : ERROR))>(data: DX): LX {\r\n\r\n/*\r\n* NO    L -> D    /// l.__raw\r\n* NO    L -> Ptr  /// l.id\r\n*\r\n* NO    D -> Ptr   // d.id\r\n* YES   D -> L     // wrap\r\n*\r\n* NO    Ptr -> D\r\n* NO    Ptr -> L\r\n*\r\n*\r\n*\r\n*\r\n* DpointerTargetable.from( L or pointer )\r\n* LpointerTargetable.from( D or pointer )\r\n*\r\n* MyProxyHandler.wrap = LpointerTargetable.from;\r\n*\r\n* DpointerTargetable.toPointer( d );\r\n*\r\n\r\ntype subtractDL = subtract<D, L>;\r\n* */\r\n\r\n\r\n\r\ntype subtract<P, C> = { [F in keyof P]: keyof C extends undefined ? undefined : P[F] };\r\ntype Exclude3<T, U> = T & {[T in keyof U]: never};\r\ntype Override<A, B> = Omit<A, keyof B> & B; //////////////////////////////////////////// best solution so far\r\n\r\ntype Exclude2<Type, field> = {\r\n    [Property in keyof Type as Exclude<Property, keyof field>]: Type[Property]      /////////////////////////equally best solution\r\n};\r\n\r\n\r\ntype OnlyKeysOfTypeTmp<T, IncludeType> = ({[P in keyof T]: T[P] extends IncludeType ? P : never })[keyof T];\r\ntype OnlyKeysOfType<T, IncludeType> = Pick<T, OnlyKeysOfTypeTmp<T, IncludeType>>;\r\ntype RemoveKeysOfType<T, ExcludeType> = Exclude2<T, OnlyKeysOfType<T, ExcludeType>>;\r\n\r\n// todo: can't automatically convert D to L (generating the type instead of manual defining L) rules are: LClass <--- Pointer<LClass>, LClass[] <-- Pointer<LClass, 0, 'N'>, subobject = ? should not be there\r\n\r\n/**\r\n i have a documentation type that is actually a string, but it\\'s have a different purpose from the others, and i made a type to keep documentally separated.\r\n let's say it's\r\n type StringOf<P> = string; // regardless of P\r\n\r\n and i use it to define objects\r\n\r\n class C {\r\n           str: StringOf<Date>;\r\n           str2: StringOf<number>;\r\n           purestring: string;\r\n           num: number\r\n         }\r\n now i want to crete a derivate type that excludes all properties of type StringOf from C\r\n\r\n\r\n\r\n type OnlyKeysOfTypeTmp<T, IncludeType> = ({[P in keyof T]: T[P] extends IncludeType ? P : never })[keyof T];\r\n type OnlyKeysOfType<T, IncludeType> = Pick<T, OnlyKeysOfTypeTmp<T, IncludeType>>;\r\n type RemoveKeysOfType<T, ExcludeType> = Exclude2<T, OnlyKeysOfType<T, string>>;\r\n\r\n type D = RemoveKeysOfType<C, StringOf<any>>\r\n due to duck typing, this removes all StringOf attributes, but also \"purestring\" attribute.\r\n how can i remove only StringOf attributes?\r\n\r\n\r\n */\r\n\r\n\r\n\r\nexport type getWParams<L extends LPointerTargetable, D extends Object> ={\r\n    // [Property in keyof ValidObj<L>]: L[Property] extends never ? never : L[Property]\r\n    [Property in keyof L]:/*\r\n            Property extends \"opposite\" ? LReference | DReference | Pointer<DReference> :\r\n            Property extends \"parent\" ? LModelElement | DModelElement | Pointer<DModelElement> :\r\n            Property extends \"annotations\" ? LAnnotation | DAnnotation | Pointer<DAnnotation> :*/\r\n    (Property extends string ? (\r\n        Property extends \"id\" ? 'id is read-only' :\r\n            //@ts-ignore\r\n            (L[`set_${Property}`] extends (a:any, b: any, ...b:any)=> any ? // at least 2 params: 1 for val and 1 for Context\r\n                // if a set_ first parameter is Context it means the set_ is ill-defined, need to change actual method signature.\r\n                //@ts-ignore\r\n                Parameters<L[`set_${Property}`]>[0] // if set_X function is defined, get first param\r\n                //@ts-ignore\r\n                : never ///D[Property] | `todo: should define set_${Property}` // default type if it's not assigned = type in the D version\r\n                )): never)\r\n} // & L\r\n\r\n\r\nexport enum EGraphElements {\r\n    \"GraphElement\"=  \"GraphElement\",\r\n    \"Field\" =\"GraphElement\", // just an alias for now.\r\n    \"Vertex\"= \"Vertex\",\r\n    \"todo\" = \"todo\"\r\n}\r\nexport enum EModelElements{\r\n    // concrete m2\r\n    \"(m2) Model\" = \"DModel\",\r\n    \"(m2) Package\" = \"DPackage\",\r\n    \"(m2) Class\" = \"DClass\",\r\n    \"(m2) Enum\" = \"DEnumerator\",\r\n    \"(m2) Literal\" = \"DEnumLiteral\",\r\n    \"(m2) Operation\" = \"DOperation\",\r\n    \"(m2) Parameter\" = \"DParameter\",\r\n    \"(m2) Attribute\" = \"DAttribute\",\r\n    \"(m2) Reference\" = \"DReference\",\r\n    \"(m2) Annotation\" = \"DAnnotation\",\r\n    // abstract m2\r\n    \"(abstract m2) Feature\" = \"DStructuralFeature\",\r\n    \"(abstract m2) Classifier\" = \"DClassifier\",\r\n    // concrete m1\r\n    \"(m1) Object\" = \"DObject\",\r\n    \"(m1) Value\" = \"DValue\",\r\n}\r\nexport class ViewEClassMatch {\r\n    static NOT_EVALUATED_YET = undefined;\r\n    static MISMATCH = Number.NEGATIVE_INFINITY;\r\n    static MISMATCH_PRECONDITIONS = Number.NEGATIVE_INFINITY;\r\n    static MISMATCH_JS = false;\r\n    static MISMATCH_OCL = false;\r\n    static IMPLICIT_MATCH = 1;\r\n    static INHERITANCE_MATCH = 1.5;\r\n    static EXACT_MATCH = 2;\r\n    static VP_MISMATCH: number = Number.NEGATIVE_INFINITY;\r\n    static VP_Default = 1;\r\n    static VP_Decorative = 1;\r\n    static VP_Explicit = 2;\r\n}\r\n\r\nexport class ViewScore {\r\n    viewPointMatch!: number;\r\n    jsxOutput?: React.ReactNode | React.ReactElement | undefined;\r\n    metaclassScore!: number;\r\n    jsScore!: number | boolean;\r\n    OCLScore!: boolean;\r\n    finalScore!: number;\r\n    usageDeclarations!: GObject;\r\n    evalContext!: GObject; // with added usageDeclarations for the current view\r\n    shouldUpdate!: boolean; // computed along usageDeclarations in shouldComponentUpdate\r\n    shouldUpdate_reason!: GObject;\r\n    nodeidcounter: Dictionary<number/*jsx char index*/, number/*counter:how many nodes generated by that jsx string line until now*/>\r\n    jsxChanged!: boolean;\r\n    constructor() {\r\n        this.nodeidcounter = {};\r\n    }\r\n\r\n    // usageDeclarations!: DefaultUsageDeclarations;\r\n    // oldNode: DGraphElement; moved to viewSorted_nodeused // ref to the actual node, not pointer. so even if it's modified through redux,\r\n    // it is still possible to compare old version and new version to check if view.oclUpdateCondition should trigger\r\n}\r\n\r\nexport class NodeTransientProperties{\r\n    viewSorted_modelused?: LModelElement; // L-version because it is used in oclUpdate function\r\n    viewSorted_pvid_used?: DViewElement;\r\n    viewSorted_nodeused?: LGraphElement;\r\n    stackViews!: LViewElement[]; // for each parentview, an array of Decorative Views[] sorted by score (including parent view influence).\r\n    validMainViews!: LViewElement[]; // an array of Main Views[] sorted by score (including parent view influence).\r\n    mainView!: LViewElement;\r\n    viewScores: Dictionary<Pointer<DViewElement>, ViewScore> = {} as any;\r\n    evalContext!: GObject; // global for this node (without view-specific usageDeclaration)\r\n    needSorting!: boolean;\r\n    longestLabel!: LVoidEdge['longestLabel'];\r\n    labels!: LVoidEdge['labels'];\r\n    src: any;\r\n    //force1Update!: boolean;\r\n    onDelete?: (node: LGraphElement)=>boolean; // return false to prevent deletion\r\n    constructor(){\r\n        // this.stackViews = []; this.validMainViews = [];\r\n        this.viewScores = {};\r\n        this.src = U.getStackTrace();\r\n    }\r\n}\r\nexport class ViewTransientProperties {\r\n    // css_MUST_RECOMPILE: boolean;\r\n    // compiled_css: string; maye those are better shared in sessions\r\n    events!: Dictionary<DocString<\"functionName\">, ((...a:any)=>any)>;\r\n    oclChanged!: boolean;\r\n    jsConditionChanged!: boolean;\r\n    oclUpdateCondition_PARSED!: (oldData: LModelElement, newData:LModelElement) => boolean;// not used anymore? was like UD+shouldcompoupdate for jsx, a pre-ocl check\r\n    oclEngine!: OclEngine;\r\n    jsCondition!: undefined | ((context:GObject) => boolean);\r\n    JSXFunction!: (scope: GObject)=>ReactNode;\r\n    UDFunction!: (scope: GObject, ret: GObject)=>void;\r\n    constantsList!: string[];\r\n    UDList!: string[];\r\n    constants!: GObject;\r\n    onDataUpdate!: undefined | ((context:GObject)=>void);\r\n    onDragStart!: undefined | ((context:GObject)=>void);\r\n    onDragEnd!: undefined | ((context:GObject)=>void);\r\n    whileDragging!: undefined | ((context:GObject)=>void);\r\n    onResizeStart!: undefined | ((context:GObject)=>void);\r\n    onResizeEnd!: undefined | ((context:GObject)=>void);\r\n    whileResizing!: undefined | ((context:GObject)=>void);\r\n    onRotationStart!: undefined | ((context:GObject)=>void);\r\n    onRotationEnd!: undefined | ((context:GObject)=>void);\r\n    whileRotating!: undefined | ((context:GObject)=>void);\r\n\r\n    longestLabel!: LVoidEdge['longestLabel'];\r\n    labels!: LVoidEdge['labels'];\r\n\r\n    constructor(){\r\n        this.events = {};\r\n    }\r\n\r\n\r\n}\r\nexport class DataTransientProperties {\r\n    nodes!: Dictionary<Pointer<DGraphElement>, LGraphElement>;\r\n    node?: LGraphElement;\r\n    derived_read?: (data: LModelElement, originalValues: any[]) => any; // derived attributes and references\r\n    derived_write?: (value:any, data:LModelElement, oldValue:any[]) => any; // derived attributes and references\r\n    constructor(){\r\n        this.nodes = {};\r\n    }\r\n}\r\n\r\n// score for all view ocl + sorted views by best match\r\ntype TransientPropertiesByGraphTab = Dictionary<Pointer<DViewElement, number>> & {\r\n    /*\r\n    need_sorting: boolean;\r\n    sorted: Pointer<DViewElement>[];\r\n    // viewMatchings: Scored<DViewElement>[];\r\n    when to update?\r\n    1) data.parent.view.id: when \"suviews\" in place are changed by a view on a container element has changed (if pkg view changed, class view might change as well)\r\n    2) data.any --> when a direct value of the doject changed, amd that value was declared in ocl\r\n    3) view.appliableto --> when d-type changes (never, a class cannot become a enum or reference\r\n    4) node stuff never? or maybe entire nodes?\r\n    other data or view properties?*/\r\n};\r\nexport const transientProperties = {\r\n    node: {} as Dictionary<Pointer<DGraphElement>, NodeTransientProperties>,\r\n    view: {} as Dictionary<Pointer<DViewElement>, ViewTransientProperties>,\r\n    modelElement: {} as Dictionary<Pointer<DModelElement>, DataTransientProperties>,\r\n};\r\n(window as any).transient = (window as any).transientProperties = transientProperties;\r\n// transientProperties.nodes[nid].viewScores[vid]?.[pvid as string];\r\n/*\r\nexport const transientPropertiesByGraphTab: {viewMatchings: Dictionary<Pointer<DGraph>, Dictionary<Pointer<DModelElement>, TransientPropertiesByGraphTab>>} = {\r\n viewMatchings: {}\r\n};*/\r\n","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\joiner\\types.ts",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\joiner\\proxy.ts",["772"],"import type {DocString, DtoL, DtoW, GObject, Proxyfied, WPointerTargetable,} from \"../joiner\";\r\nimport {\r\n    ABORT,\r\n    Dictionary,\r\n    DModelElement,\r\n    DPointerTargetable,\r\n    JsType,\r\n    LModelElement,\r\n    Log,\r\n    LPointerTargetable,\r\n    Pointer,\r\n    RuntimeAccessible,\r\n    RuntimeAccessibleClass,\r\n    SetFieldAction,\r\n    SetRootFieldAction,\r\n    U\r\n} from \"../joiner\";\r\n\r\ntype NotAConcatenation = null;\r\ntype ERROR = \"_Type_Error_\";\r\n\r\n// (DX extends DUser ? LUser : (DX extends DPointerTargetable ? LPointerTargetable : (ERROR))\r\n// (DX extends DUser ? LUser : (DX extends DPointerTargetable ? LPointerTargetable : (           WViewElement\r\n//\r\n// (IN extends WViewElement ? LViewElement : (IN extends WViewTransientProperties ? LWiewTransientProperties : (ERROR)))\r\n// ))\r\n// type WtoL<WX extends WPointerTargetable> ='';\r\n\r\n@RuntimeAccessible('LogicContext')\r\nexport class LogicContext<\r\n    DX extends GObject = DModelElement,\r\n    LX = DtoL<DX>,\r\n    // PF extends MyProxyHandler<DX> = MyProxyHandler<DX>,\r\n    WX = DtoW<DX>\r\n    > extends RuntimeAccessibleClass{\r\n    public proxyObject: LX;\r\n    public data: DX;// & GObject;\r\n    public write: WX;\r\n    constructor(proxyObject: LX, data: DX) {\r\n        super();\r\n        this.className = (this.constructor as typeof RuntimeAccessibleClass).cname || this.constructor.name;\r\n        this.data = data;\r\n        this.proxyObject = proxyObject;\r\n        this.write = proxyObject as any;\r\n    }\r\n    /*\r\n        saveToRedux(propkey: \"keyof data\" | string, val: \"typeof data[path]\" | any): void { // todo: ask non stackoverflow\r\n            // todo, put data in redux store, path is \"obj1.obj2.obj3...\" might replace it with a path funciton that return the foremost nested object container\r\n            if (!propkey) {\r\n                // todo: set whole object instead of a property\r\n            }\r\n        }*/\r\n}\r\n\r\nRuntimeAccessibleClass.set_extend(RuntimeAccessibleClass, LogicContext);\r\n@RuntimeAccessible('MapLogicContext')\r\nexport class MapLogicContext extends LogicContext<GObject, LPointerTargetable, WPointerTargetable> {\r\n    data: GObject;\r\n    path: string;\r\n    subMaps: string[];\r\n    constructor(proxy: LPointerTargetable, data: GObject, path: string, subMaps: string[] = []) {\r\n        super(proxy, data);\r\n        // this.proxyfyFunction = proxyfyFunction;\r\n        this.proxyObject = proxy;\r\n        this.data = data;\r\n        this.path = path;\r\n        this.subMaps = subMaps;\r\n        this.className = (this.constructor as typeof RuntimeAccessibleClass).cname || this.constructor.name;\r\n    }\r\n}\r\nRuntimeAccessibleClass.set_extend(LogicContext, MapLogicContext);\r\n\r\n@RuntimeAccessible('MyProxyHandler')\r\nexport abstract class MyProxyHandler<T extends GObject> extends RuntimeAccessibleClass implements ProxyHandler<T>{\r\n    s: string = 'set_';\r\n    g: string = 'get_';\r\n    /*get(target: T, p: string | number | symbol, proxyitself: Proxyfied<T>): boolean {\r\n        switch (p) {\r\n            case '_isProxy': return true;\r\n            case 'init': return (this as any).init;\r\n            case 'init0': return (this as any).init0;\r\n            default: throw new Error('proxy get must be overridden, called for key: ' + (p as string));\r\n        }}*/\r\n    set(target: T, p: string | number | symbol, value: any, proxyitself: Proxyfied<T>): boolean { throw new Error('proxy set must be overridden'); }\r\n    deleteProperty(target: T, p: string | symbol): boolean { throw new Error('proxy delete must be overridden'); }\r\n\r\n    ownKeys(target: T): ArrayLike<string | symbol>{\r\n        // return Object.getOwnPropertyNames(target);\r\n        console.log(\"ownkeys trap 1\", {thiss:this, target})\r\n        console.log(\"ownkeys trap 2\", {thiss:this, target, ret:Reflect.ownKeys(target)});\r\n        return Reflect.ownKeys(target);\r\n    }\r\n    /// proxy methods not used\r\n    /* setPrototypeOf(target: T, v: object | null): boolean { ?? }\r\n    apply(target: T, thisArg: any, argArray: any[]): any { }\r\n    defineProperty(target: T, p: string | symbol, attributes: PropertyDescriptor): boolean { }\r\n    construct(target: T, argArray: any[], newTarget: Function): object { }\r\n    getOwnPropertyDescriptor(target: T, p: string | symbol): PropertyDescriptor | undefined { }\r\n    has(target: T, p: string | symbol): boolean { return p in target; }\r\n    getPrototypeOf(target: T): object | null { }\r\n    isExtensible(target: T): boolean { }\r\n    preventExtensions(target: T): boolean { }*/\r\n\r\n    static wrap<D extends RuntimeAccessibleClass, L extends LPointerTargetable = LPointerTargetable, CAN_THROW extends boolean = false,\r\n        RET extends CAN_THROW extends true ? L : L | undefined  = CAN_THROW extends true ? L : L>\r\n    (data: D | Pointer | undefined | null, baseObjInLookup?: DPointerTargetable, path: string = '', canThrow: CAN_THROW = false as CAN_THROW): RET{\r\n\r\n//    static wrap<D extends RuntimeAccessibleClass, L extends LPointerTargetable, RET extends boolean = false>\r\n//        (data: D | Pointer<DViewElement>, baseObjInLookup?: DPointerTargetable, path: string = '', canthrow: RET = false as RET): RET {\r\n        return DPointerTargetable.wrap(data, baseObjInLookup, path) as RET; }\r\n\r\n    static isProxy(data: GObject): boolean { return data?.__isProxy || false; }\r\n}\r\nRuntimeAccessibleClass.set_extend(RuntimeAccessibleClass, MyProxyHandler);\r\nexport type GetPath<T = GObject> = T;\r\n/*\r\n* handling proxy += and proxy -=\r\n*\r\n* will become var = var + add; which will call Symbol.getPrimitive\r\nconsole.log(+obj2);     // 10        — hint is \"number\"         NaN with +array with multiple vals, +array[0] with array of size 1, NaN with functions & objects\r\nconsole.log(`${obj2}`); // \"hello\"   — hint is \"string\"         array => array.join(','), object => \"[object Object]\", function => function.toString() whole func definition with body code\r\nconsole.log(obj2 + \"\"); // \"true\"    — hint is \"default\"        array, object, function => same as with hint \"string\"\r\n*\r\n* */\r\n\r\n// NB: lclass.extends += somepointer will become: lclass.extends = lclass.extends + somepointer;\r\n// array + string will cause getPrimitive(\"default\") to array, then .join(',') on it, and finally and toString() to be called on all array members.\r\n// so pointers cannot include \",\" char and toString() must return a pointer to keep lclass.extends += somepointer as a valid expression;\r\n// -= will call getPrimitive(\"number\") which will result in array -> NaN, so NaN = NaN - pointer and cannot be done.\r\n// or maybe it can because if getPrimitive fails it calls toString as fallback, and viceversa\r\n\r\n@RuntimeAccessible('GetPathHandler')\r\nclass GetPathHandler<T extends GObject> extends MyProxyHandler<T>{\r\n    public static __asCalls: boolean = false;\r\n    public static __asArray: boolean = false;\r\n    public static __nested: boolean = true;\r\n    private strbuilder: string = '';\r\n    private array: (string | number | symbol)[] = [];\r\n    private calls: (GObject<'parameters of get calls'>)[] = [];\r\n\r\n    public constructor() { super(); }\r\n\r\n    get(targetObj: T, propKey: keyof T | string, proxyitself: Proxyfied<T>): any {\r\n        // console.log('GetPathHandler', {targetObj, propKey, proxyitself});\r\n        if (propKey === \"start\") { this.strbuilder = ''; this.array = []; }\r\n        if (propKey === '$') {\r\n            const ret = GetPathHandler.__asCalls ? this.calls : (GetPathHandler.__asArray ? this.array : this.strbuilder);\r\n            this.array = [];\r\n            this.strbuilder = '';\r\n            return ret; }\r\n        this.array.push(propKey);\r\n        this.calls.push(arguments);\r\n        if (propKey === Symbol.toPrimitive) {\r\n            console.log(\"toprimitive\");\r\n            return (...a: any)=> {console.log(\"toprimitive called with parameters\", a); }\r\n        }\r\n        if (!GetPathHandler.__asArray && !GetPathHandler.__asCalls) {\r\n            if (typeof propKey === \"symbol\") { this.strbuilder += propKey.toString(); }\r\n            else {\r\n                // Giordano: add ignore for webpack\r\n                //@ts-ignore\r\n                this.strbuilder += (this.strbuilder ? '.' : '') + propKey;\r\n            }\r\n        }\r\n        return GetPathHandler.__nested ? proxyitself : {};\r\n    }\r\n\r\n    set(target: T, p: string | number | symbol, value: any, proxyitself: Proxyfied<T>): boolean {\r\n        switch(p){\r\n            case '__asArray':\r\n            case '__asCalls':\r\n            case '__nested':\r\n                (GetPathHandler as any)[p] = value;\r\n                return true;\r\n            default:\r\n                throw new Error('getPath proxy cannot be written');\r\n        }\r\n    }\r\n}\r\nRuntimeAccessibleClass.set_extend(MyProxyHandler, GetPathHandler);\r\n@RuntimeAccessible('TargetableProxyHandler')\r\nexport class TargetableProxyHandler<ME extends GObject = DModelElement, LE extends LPointerTargetable = LModelElement> extends MyProxyHandler<ME> {\r\n// permette di fare cose tipo: user.name_surname che ritorna la concatenazione di nome e cognome anche se il campo name_surname non esiste.\r\n    lg: LE & GObject; // to disable type check easily and access 'set_' + varname dynamically\r\n    l: LE;\r\n    d: ME;\r\n    additionalPath: string;\r\n\r\n    public baseObjInLookup: DPointerTargetable;\r\n    static childKeys: Dictionary<string, true> = {'$': true, '@': true};\r\n\r\n    constructor(d: ME, baseObjInLookup?: DPointerTargetable, additionalPath: string = '', l?: LE) {\r\n        super();\r\n        this.d = d;\r\n        if (!l) {\r\n            l = RuntimeAccessibleClass.get(d.className)?.logic?.singleton as LE;\r\n            Log.exDev(!l, 'Trying to wrap class without singleton or logic mapped: ' + d.className, { object: d, className: d.className })\r\n        }\r\n        this.baseObjInLookup = baseObjInLookup || d as any;\r\n        this.additionalPath = additionalPath;\r\n        this.l = l as LE;\r\n        this.lg = this.l;\r\n        this.className = (this.constructor as typeof RuntimeAccessibleClass).cname || this.constructor.name;\r\n    }\r\n\r\n    // damiano todo: this does not work\r\n    private concatenableHandler(targetObj: ME, propKey: number | string | symbol, proxyitself: Proxyfied<ME>): NotAConcatenation | any[] | string {\r\n        //console.log(\"concatenableHandler 1\", {targetObj, propKey, proxyitself});\r\n        if (propKey in targetObj)  return null as NotAConcatenation;\r\n        const propKeyStr: null | string = U.asString(propKey, null);\r\n        let _index: number = propKeyStr ? propKeyStr.indexOf('_') : -1;\r\n        //console.log(\"concatenableHandler 2\", {targetObj, propKey, propKeyStr, proxyitself, _index});\r\n        if (_index < 0) return null as NotAConcatenation;\r\n\r\n        let isConcatenable = true;\r\n        let ret: any[] = (propKey as string).split('_').map( (subKey: string) => {\r\n            //console.log(\"concatenableHandler 3.0\", {targetObj, subKey, propKeyStr, proxyitself});\r\n            // se trovo multipli ___ li tratto come spazi aggiuntivi invece che come proprietà '' che ritornano undefined, così posso fare name___surname --> \"damiano   di vincenzo\"\r\n            let val: any = subKey === '' ? ' ' : this.get(targetObj, subKey, proxyitself);\r\n            isConcatenable = isConcatenable && JsType.isPrimitive(val);\r\n            return val;\r\n        });\r\n        //console.log(\"concatenableHandler 4\", {targetObj, propKey, propKeyStr, proxyitself, ret, isConcatenable});\r\n        return isConcatenable ? ret.join(' ') : ret; }\r\n\r\n    public get(targetObj: ME, propKey: string | symbol, proxyitself: Proxyfied<ME>): any {\r\n        let ret;\r\n        let isError = false;\r\n        // console.error('_proxy get PRE:', {targetObj, propKey, proxyitself, arguments});\r\n        try { ret = this.get0(targetObj, propKey, proxyitself); } catch(e) { ret = e; isError = true;}\r\n\r\n        // if (isError) throw ret;\r\n        // console.error('_proxy get POST:', {targetObj, propKey, ret, isError});\r\n        return ret;\r\n    }\r\n\r\n    public get0(targetObj: ME, propKey: string | symbol, proxyitself: Proxyfied<ME>): any {\r\n        // console.log('proxy keysearch', {propKey, targetObj, l: this.l, proxyitself, d: this.d});\r\n        let canThrowErrors = true;\r\n\r\n        switch(typeof propKey) {\r\n            case \"symbol\":\r\n                propKey = String(propKey);\r\n                // console.log('get symbol', {propKey});\r\n                switch (propKey) {\r\n                    default: Log.exDevv('unexpected symbol in proxy getter:', propKey); break;\r\n                    case 'Symbol(Symbol.toStringTag)': propKey = 'toString'; break; //return (()=>\"[Proxy]\");\r\n                    case \"Symbol(Symbol.toPrimitive)\": propKey = 'toPrimitive'; break;\r\n                }\r\n                break;\r\n            // case \"number\": return null;\r\n        }\r\n\r\n        switch (propKey) {\r\n            case '__l': return this.l;\r\n            case '__d': return this.d;\r\n            case 'inspect': // node.js util\r\n            case \"r\":\r\n            case \"_refresh\":\r\n            case \"_reload\": return LPointerTargetable.wrap(targetObj.id);\r\n            case '__Raw':\r\n            case '__raw': return targetObj;\r\n            case '__serialize': return JSON.stringify(targetObj);\r\n            case '__isproxy':\r\n            case '__isProxy': return true;\r\n            case '__random': return Math.random();\r\n            case 'editCount':\r\n            case 'clonedcounter':\r\n            case 'clonedCounter':\r\n                return targetObj.clonedCounter || 0;\r\n            case '$$typeof':\r\n            case \"typeName\":\r\n                return this.d.className;\r\n            case 'parent': propKey = 'father'; break;\r\n        }\r\n        if (propKey[0] === \"_\" && propKey.indexOf(\"__info_of__\")===0) {\r\n            return (this.l as GObject)[propKey];\r\n        }\r\n\r\n\r\n        // check if exist directly in D.key, L.key or through a get_key\r\n        if (propKey in this.l || propKey in this.d || (this.l as GObject)[this.g + (propKey as string)]) {\r\n            // todo: il LogicContext passato come parametro risulta nell'autocompletion editor automaticamente generato, come passo un parametro senza passargli il parametro? uso arguments senza dichiararlo?\r\n            if (typeof propKey !== 'symbol' && this.g + propKey in this.lg) return this.lg[this.g + propKey](new LogicContext(proxyitself as any, targetObj));\r\n\r\n\r\n\r\n            // if specific custom getter exist\r\n            if (typeof propKey !== 'symbol' && this.g + propKey in this.lg) {\r\n                let getterMethod: Function = this.lg[this.g + propKey]; // || this.defaultGetter;\r\n                // console.log(\"gets method\", {getterMethod, lg:this.lg, thiss: this});\r\n                if (getterMethod) return getterMethod(new LogicContext(proxyitself as any, targetObj));\r\n            }\r\n\r\n        }\r\n        // @ts-ignore\r\n        //console.trace(\"proxy $getter 2\", {targetObj, n:targetObj.name, propKey, l:this.lg, dg:this.lg._defaultGetter});\r\n\r\n\r\n        // if custom generic getter exist\r\n        // @ts-ignore\r\n        if (this.lg._defaultGetter) return this.lg._defaultGetter(new LogicContext(proxyitself as any, targetObj), propKey);\r\n\r\n        // if property do not exist, try a concatenation\r\n        /*let concatenationTentative = null;\r\n        try {concatenationTentative = this.concatenableHandler(targetObj, propKey, proxyitself); } catch(e) {}\r\n        if (concatenationTentative !== null) return concatenationTentative;\r\n        */\r\n        Log.e(canThrowErrors, 'GET property \"'+ (propKey as any)+ '\" do not exist in object of type \"' + U.getType(this.l) + \" DType:\" +  U.getType(this.d), {data: targetObj});\r\n        return undefined;\r\n        // todo: credo che con espressioni sui tipi siano tipizzabili tutti i return di proprietà note eccetto quelle ottenute per concatenazione.\r\n    }\r\n\r\n    public defaultGetter(targetObj: ME, key: string, proxyitself: Proxyfied<ME>): any {\r\n        if (!targetObj) return targetObj;\r\n        if (!targetObj._subMaps || !targetObj._subMaps[key]) return (targetObj as Dictionary)[key];\r\n        // if is a nexted subobject\r\n        let context: MapLogicContext = new MapLogicContext(proxyitself as any, targetObj, key, []);\r\n        let retRaw: Dictionary = this.lg[this.s + key]\r\n        return MapProxyHandler.mapWrap((targetObj as Dictionary)[key], targetObj as any, this.additionalPath + '.' + key)\r\n    }\r\n\r\n    public defaultSetter(targetObj: DPointerTargetable, propKey: string, value: any, proxyitself?: Proxyfied<ME>): boolean {\r\n        SetFieldAction.new(targetObj, propKey as any, value);\r\n        return true;\r\n    }\r\n\r\n    public set(targetObj: ME, propKey: string | symbol, value: any, proxyitself?: Proxyfied<ME>): boolean {\r\n        // console.error('_proxy set PRE:', {targetObj, propKey, value, proxyitself, arguments});\r\n        // if (propKey in this.l || propKey in this.d || (this.l as GObject)[this.s + (propKey as string)] || (this.l as GObject)[(propKey as string)]) {\r\n\r\n        if ((this.d as GObject).__readonly && propKey !== '__readonly') {\r\n            //todo if there is a transaction open i should throw exception?\r\n            if (ABORT()){\r\n                Log.ee('Transaction aborted because an object is readonly:', this.d);\r\n            }\r\n            return true;\r\n        }\r\n        switch (typeof propKey) {\r\n            case \"symbol\":\r\n                propKey = String(propKey);\r\n                Log.exDevv('unexpected symbol in proxy setter:', propKey);\r\n                break;\r\n            default: break;\r\n        }\r\n\r\n        switch (propKey) {\r\n            case 'parent': propKey = 'father'; break;\r\n        }\r\n\r\n        if (propKey in this.l || propKey in this.d || (this.l as GObject)[this.s + (propKey as string)]) {\r\n            // todo: il LogicContext passato come parametro risulta nell'autocompletion editor automaticamente generato, come passo un parametro senza passargli il parametro? uso arguments senza dichiararlo?\r\n            if (typeof propKey !== 'symbol' && this.s + propKey in this.lg) {\r\n                this.lg[this.s + propKey](value, new LogicContext(proxyitself as any, targetObj));\r\n                return true;\r\n            }\r\n\r\n\r\n            // se esiste la proprietà ma non esiste il setter?\r\n            // Log.eDevv(\"dev error: property exist but setter does not: \", propKey, this);\r\n            // return false;\r\n        }\r\n        // if property do not exist\r\n\r\n        // if custom generic setter exist\r\n        // @ts-ignore private property\r\n        if (this.lg._defaultSetter) { // @ts-ignore private property\r\n            this.lg._defaultSetter(value, new LogicContext(proxyitself as any, targetObj), propKey);\r\n            return true;\r\n        }\r\n        /*if (enableFallbackSetter && typeof (propKey === \"string\") && ((propKey as string)[0] === '_' || (propKey as string).indexOf('tmp') > 0)) {\r\n            return this.defaultSetter(targetObj as any as DPointerTargetable, propKey as string, value, proxyitself);\r\n            // new SetFieldAction(new LogicContext(proxyitself as any, targetObj).data as any, propKey as string, value); return true;\r\n        }*/\r\n        let canThrowErrors = true;\r\n        Log.ex(canThrowErrors,'SET property \"set_' + (propKey as any) + '\" do not exist in object of type \"' + U.getType(this.l) + \" DType:\" +  U.getType(this.l), {'this': this, targetObj});\r\n        return false; }\r\n    /*      problema: ogni oggetto deve avere multipli puntatori, quando ne modifico uno devo modificarli tutti, come tengo traccia?\r\n            ipotesi 1: lo memorizzo in un solo posto (store.idlookup) e uso Pointer<type, lb, ub> che è una stringa che simula un puntatore\r\n            problema 1: se fornisco l'intero store ai componenti si aggiornano ad ogni singola modifica, se estraggo i campi interesasti le stringhe puntatore sono invariate ma il contenuto puntato è cambiato e il componente non lo sa...\r\n            problemone 2: non so a quali proprietà dello store devo abbonarmi, devo leggere sempre tutto lo store?\r\n            !!!!! soluzione 2?: dovrei dichiarare le variabili a cui mi abbono, salvarle nello stato e precaricarle tramite mapStateToProps*/\r\n\r\n    public deleteProperty(target: ME, key: string | symbol, proxyItself?: Proxyfied<any>): boolean {\r\n        if (typeof key === \"symbol\") return false;\r\n        this.set(target, key, undefined, proxyItself);\r\n        delete target[key];\r\n        return true; }\r\n\r\n    private mergedObject(target: ME): GObject{\r\n        let ret: GObject = {...target}; // U.arrayMergeInPlace(Object.keys(target), Object.keys(this.l).filter(k => k.indexOf('set_') !== 0 && k.indexOf('get_') !== 0));\r\n        for (let k in this.l) {\r\n            if (!(k in ret) && k.lastIndexOf('get_', 4) !== 0 && k.lastIndexOf('set_', 4) !== 0) ret[k] = true;\r\n        }\r\n        return ret;\r\n    }\r\n    ownKeys(target: ME): ArrayLike<string | symbol>{\r\n        const ret: GObject = this.mergedObject(target);\r\n        // ret = Reflect.ownKeys(ret);\r\n        return Reflect.ownKeys(ret);\r\n    }\r\n\r\n    // has(target: ME, p: string | symbol): boolean { return p in this.mergedObject(target); }\r\n    has(target: ME, p: string | symbol): boolean { return (p in target) || (p in this.l); }\r\n\r\n    /*\r\n    apply(target: DModelElement, thisArg: any, argArray: any[]): any {\r\n        // will i ever use it? dovrei pasare una funzione invece di una classe, quindi in questo caso credo wrappi solo il costruttore\r\n    }*/\r\n}\r\nRuntimeAccessibleClass.set_extend(MyProxyHandler, TargetableProxyHandler);\r\n@RuntimeAccessible('MapProxyHandler')\r\nexport class MapProxyHandler extends TargetableProxyHandler<Dictionary, LPointerTargetable> {\r\n    // todo: sposta alcune funzioni da TargetableProxy a MyProxy e fai estendere direttamente MyProxy a questa classe\r\n    public subMapKeys: Dictionary<string, any | Dictionary<DocString<'nested map keys'>>>;\r\n\r\n    constructor(d: Dictionary, baseObjInLookup: DPointerTargetable, additionalPath: string = '', subMapKeys: Dictionary<string, any | Dictionary<DocString<'nested map keys'>>> = {}) {\r\n        super(d, baseObjInLookup, additionalPath, LPointerTargetable.singleton);\r\n        this.subMapKeys = subMapKeys;\r\n    }\r\n\r\n    get(target: Dictionary, key: string | number | symbol, proxyitself: Proxyfied<Dictionary>): any {\r\n        if (typeof key === \"symbol\") return this.d[key as any];\r\n        let val: any = this.d[key];\r\n        if (key in this.subMapKeys && !(key in target)) { Log.exx('property not found in dictionary', {target, key, thiss:this, proxyitself, submapkeys: this.subMapKeys}); return undefined; }\r\n        if (key in this.subMapKeys) {\r\n            this.additionalPath += '.';\r\n            return MapProxyHandler.mapWrap( this.d, this.baseObjInLookup, this.additionalPath, this.subMapKeys[key]);\r\n            Log.exDevv('todo: wrap sub-map', {thiss: this});\r\n        }\r\n        return target[key as string]; }\r\n\r\n    set(target: Dictionary, key: string | number | symbol, value: any, proxyitself: Proxyfied<Dictionary>): boolean {\r\n        if (typeof key === \"symbol\") { Log.exx('cannot set a symbol in dictionary', {target, key, value, proxyitself}); return false; }\r\n        SetRootFieldAction.new(this.additionalPath + '.' + key, value, '',false)\r\n        return true;\r\n    }\r\n\r\n    public deleteProperty(target: Dictionary, key: string | symbol, proxyItself?: Proxyfied<any>): boolean {\r\n        if (typeof key === \"symbol\") return false;\r\n        this.set(target, key, undefined, proxyItself);\r\n        delete target[key];\r\n        return true; }\r\n}\r\nRuntimeAccessibleClass.set_extend(MyProxyHandler, MapProxyHandler);\r\n// 15-20 min + 5 di domande entro il 1° ottobre, discussione 10-12 ottobre\r\nexport const getPath: GetPath = new Proxy( {}, new GetPathHandler());\r\n(window as any).getPath = getPath;\r\n// usage: pathstring = ((getPath as DType).some.path.to.follow as any).$; // = \"some.path.to.follow\" with compilation-time validation\r\n","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\redux\\reducer\\reducer.ts",["773","774","775","776","777","778","779","780","781","782","783"],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\joiner\\ExecuteOnRead.ts",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\common\\UObj.ts",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\common\\Log.ts",["784"],"import {Dictionary, MyError, RuntimeAccessible, windoww} from \"../joiner\";\r\nimport {U} from \"./U\";\r\nimport {NotBool} from \"../joiner/types\";\r\n\r\nexport type LoggerType = \"l\" | \"i\" | \"w\" | \"e\" | \"ex\" | \"eDev\" | \"exDev\";\r\nexport class LoggerCategoryState{\r\n    static counter: number = 0;\r\n    category: LoggerType;\r\n    time: number;\r\n    expireTime?: number; // set dynamically during display phase, it is just a cache.\r\n    raw_args: any[];\r\n    short_string: string;\r\n    long_string: string;\r\n    exception?: Error\r\n    key: string | number;\r\n    toastHidden?: undefined | true;\r\n\r\n\r\n    constructor(args: any[], short_string: string, cat: LoggerType, exception?: Error) {\r\n        this.raw_args = args;\r\n        this.time = new Date().getTime();\r\n        this.category = cat;\r\n        this.short_string = short_string;\r\n        this.long_string = '';\r\n        this.exception = exception;\r\n        this.key = (LoggerCategoryState.counter++); // + '_' + this.time + '_' + this.short_string;\r\n\r\n        // this.long_string = JSON.stringify(U.cropDeepObject(args, 10, 20, 45, 35, 5), null, '\\t');\r\n        /*\r\n        const maxChars: Dictionary<string, [number, number]> = {\r\n            function: [50, 0],\r\n            object: [100, 0],\r\n            string: [80, 20],\r\n        }\r\n        let ansiConvert = (window as any).ansiConvert;\r\n        if (!ansiConvert) {\r\n            (window as any).ansiconvert = ansiConvert = new Convert();\r\n        }\r\n        for (let a of args){\r\n            let s: string;\r\n            let ta: string = typeof a;\r\n            switch(ta){\r\n                case \"function\": s = a.toString(); break;\r\n                case \"object\":\r\n                    let outstr = U.inspect(a, true, 2, true);\r\n                    outstr = U.replaceAll(ansiConvert.toHtml(outstr), \"style=\\\"color:#FFF\\\"\", \"style=\\\"color:#000\\\"\");\r\n                    let regexpCloseTags = new RegExp(\"(\\\\<span style\\\\=\\\"color\\\\:\\\\#)\", \"gm\");\r\n                    outstr = U.replaceAll( outstr, \"$\", \"£\");\r\n                    outstr = outstr.replace(regexpCloseTags,  \"</span>$1\");\r\n                    outstr = U.replaceAll(outstr, \"£\", \"$\");\r\n                    s = outstr;\r\n                    break;\r\n                default: s = ''+a;\r\n            }\r\n            if (maxChars[ta]) s = U.cropStr(s, maxChars[ta][0], maxChars[ta][1]);\r\n            this.long_string += s;\r\n        }*/\r\n    }\r\n}\r\n\r\n@RuntimeAccessible('Log')\r\nexport class Log{\r\n    // public static history: Dictionary<string, Dictionary<string, any[]>> = {}; // history['pe']['key'] = ...parameters\r\n    public static lastError: any[];/*\r\n    public static last_e: LoggerCategoryState[] = [];\r\n    public static last_eDev: LoggerCategoryState[] = [];\r\n    public static last_ex: LoggerCategoryState[] = [];\r\n    public static last_exDev: LoggerCategoryState[] = [];\r\n    public static last_w: LoggerCategoryState[] = [];\r\n    public static last_i: LoggerCategoryState[] = [];*/\r\n    // private static loggerMapping: Dictionary<string, LoggerInterface[]> = {} // takes function name returns logger list\r\n    public static allMessages: LoggerCategoryState[] = []\r\n    public static messageMapping: Dictionary<LoggerType, LoggerCategoryState[]> = {\r\n        l: [],\r\n        i: [],\r\n        w: [],\r\n        e: [],\r\n        ex: [],\r\n        eDev: [],\r\n        exDev: [],\r\n    } // takes function name returns log messages list\r\n\r\n\r\n    static disableConsole(){\r\n        // @ts-ignore\r\n        console['logg'] = console.log;\r\n        console.log = () => {}; }\r\n\r\n    static enableConsole() {\r\n        // @ts-ignore\r\n        if (console['logg']) console.log = console['logg']; }\r\n\r\n    private static log(prefix: string, category: LoggerType, originalFunc: typeof console.log, b: boolean, canthrow: boolean, ...restArgs: any[]): string {\r\n        if (!b) { return ''; }\r\n        const key: string = windoww.U.getCaller(1); // todo: remove replace heavy fumc\r\n        if (restArgs === null || restArgs === undefined) { restArgs = []; }\r\n        let str = key + ': ';\r\n        for (let i = 0; i < restArgs.length; i++) {\r\n            // console.log(prefix, {i, restArgs, curr:restArgs[i]});\r\n            str += '' +\r\n                (typeof restArgs[i] === 'symbol' ?\r\n                    '' + String(restArgs[i]) :\r\n                    restArgs[i])\r\n                + '\\t\\r\\n'; }\r\n        let prefixedstr = '[' + prefix + ']' + str;\r\n\r\n        let exception: Error | undefined = (canthrow ? new MyError(prefixedstr, ...restArgs) : undefined);\r\n\r\n        Log.updateLoggerComponent(category, restArgs, str, category, exception);\r\n        // merged loggers if (Log.loggerMapping[category]) for (const logger of Log.loggerMapping[category]) { logger.log(category, key, restArgs, str); }\r\n        originalFunc(key, ...restArgs);\r\n        if (exception) throw exception;\r\n        return prefixedstr;\r\n    }\r\n\r\n    public static e(b: boolean, ...restArgs: any[]): string {\r\n        if (!b) return '';\r\n        const str = Log.log('Error', 'e', console.error, b, false, ...restArgs);\r\n        Log.lastError = restArgs;\r\n        return str;\r\n        // throw new Error(str);\r\n    }\r\n\r\n    public static eDev(b: boolean, ...restArgs: any[]): string {\r\n        if (!b) return '';\r\n        Log.lastError = restArgs;\r\n        windoww.ee = restArgs;\r\n        windoww.e1 = restArgs[1];\r\n        return Log.log('Dev Error','eDev', console.error, b, false, ...restArgs);\r\n    }\r\n\r\n    public static ex(b: boolean, ...restArgs: any[]): null | never | any {\r\n        if (!b) return null;\r\n        Log.lastError = restArgs;\r\n        windoww.ee = restArgs;\r\n        windoww.e1 = restArgs[1];\r\n        Log.log('Error', 'e', console.error, b, true, ...restArgs);}\r\n\r\n    public static exDev(b: boolean, ...restArgs: any[]): null | never | any {\r\n        if (!b) return null;\r\n        Log.lastError = restArgs;\r\n        windoww.ee = restArgs;\r\n        windoww.e1 = restArgs[1];\r\n        Log.log('Dev Error','eDev', console.error, b, true, ...restArgs);\r\n    }\r\n\r\n    public static i(b: boolean, ...restArgs: any[]): string | null {\r\n        if (!b) return null;\r\n        return Log.log('Info', 'i', console.log, b, false, ...restArgs);\r\n    }\r\n    public static _loggerComponent: any = undefined as any;\r\n    private static get_loggercomponent(): any { return Log._loggerComponent; }\r\n    private static updateLoggerComponent(type: LoggerType, args: any[], short_str: string, cat: LoggerType, exception?: Error): void {\r\n        let c = Log.get_loggercomponent();\r\n        let update: LoggerCategoryState = new LoggerCategoryState(args, short_str, cat, exception);\r\n        Log.messageMapping[type].push(update);\r\n        Log.allMessages.push(update);\r\n        if (!c) return;\r\n        c.setState({[type+\"_counter\"]: c.state[type+\"_counter\"]+1}); // so it doesn't pass through redux\r\n    }\r\n    public static l(b: boolean, ...restArgs: any[]): string | null {\r\n        if (!b) return null;\r\n        return Log.log('Log', 'l', console.log, b, false, ...restArgs);\r\n    }\r\n    public static w(b: boolean, ...restArgs: any[]): string | null {\r\n        if (!b) return null;\r\n        return Log.log('Warn', 'w', console.warn, b, false, ...restArgs); }\r\n\r\n\r\n    public static eDevv<T extends any = any>(firstParam?: NotBool<T>, ...restAgs: any): string { return Log.eDev(true, ...[firstParam, ...restAgs]); }\r\n    public static ee(...restAgs: any): string { return Log.e(true, ...restAgs); }\r\n    public static exDevv<T extends any = any>(firstParam?: NotBool<T>, ...restAgs: any): never | any { return Log.exDev(true, ...[firstParam, ...restAgs]); }\r\n    public static exx(...restAgs: any): never | any { return Log.ex(true, ...restAgs); }\r\n    public static ii(...restAgs: any): string { return Log.i(true, ...restAgs) as string; }\r\n    public static ll(...restAgs: any): string { return Log.l(true, ...restAgs) as string; }\r\n    public static ww(...restAgs: any): string { return Log.w(true, ...restAgs) as string; }\r\n\r\n\r\n    static getByError(error: Error) {\r\n        for (let m of Log.allMessages){\r\n            if (m.exception === error) return m;\r\n            /*\r\n            switch (m.category){\r\n                case 'l': case 'i': case 'w': continue;\r\n                default: break;\r\n            }\r\n            if (U.deepFindInObject(m.raw_args, error, undefined, 3)) return m;*/\r\n        }\r\n\r\n    }\r\n\r\n    static filterMessages() {\r\n        let err = console.error;\r\n        let warn = console.warn;\r\n        console.warn = (...e): void => {\r\n            let e0 = e[0];\r\n            if (e0 && (e0[0] === 's' && e0[14] === 's' && e0.substring(0,15) === 'src\\\\api\\\\data.ts')) {\r\n                console.info(...e);\r\n                return;\r\n            }\r\n            /*switch (e[0]) { // [0] {} bn\r\n            }*/\r\n            return warn(...e);\r\n        }\r\n        console.error = (...e): void => {\r\n            switch (e[0]) { // [0] {} bn\r\n                case \"Warning: The tag <%s> is unrecognized in this browser. If you meant to render a React component, start its name with an uppercase letter.%s\":\r\n                    switch (e[1]) {\r\n                        case 'view':\r\n                            return;\r\n                    }\r\n                    break;\r\n                case \"Warning: React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.%s\":\r\n                    return;\r\n                case \"Warning: Each child in a list should have a unique \\\"key\\\" prop.%s%s See https://reactjs.org/link/warning-keys for more information.%s\":\r\n                case \"Warning: Each child in a list should have a unique \\\"key\\\" prop.%s%s See https://reactjs.org/link/warning-keys for more information.%s\":\r\n                    warn(...e, {args: e});\r\n                    return;\r\n                default:\r\n                    break;\r\n            }\r\n            err(...e);\r\n        }\r\n    }\r\n}\r\n// (window as any).Log = Log;\r\n","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\common\\Defaults.ts",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\common\\Geom.ts",["785","786","787","788","789","790","791","792","793","794","795","796","797","798","799","800","801","802","803","804","805","806","807","808"],"import {GObject, Temporary, TODO, U} from \"../joiner\";\r\nimport {DPointerTargetable, RuntimeAccessible, windoww, Log, RuntimeAccessibleClass, Dictionary} from \"../joiner\";\r\nimport React from \"react\";\r\nimport {radian} from \"../joiner/types\";\r\n\r\n@RuntimeAccessible('IPoint')\r\nexport abstract class IPoint extends RuntimeAccessibleClass {\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    public x!: number;\r\n    public y!: number;\r\n\r\n    // @ts-ignore static getM is not null but must be declared nullable to achieve subclass mixing\r\n    // public static getM? = function(firstPt: IPoint, secondPt: IPoint): number { return (firstPt.y - secondPt.y) / (firstPt.x - secondPt.x); }\r\n    public static getM(firstPt: IPoint, secondPt: IPoint): number { return (firstPt.y - secondPt.y) / (firstPt.x - secondPt.x); }\r\n    public static getQ(firstPt: IPoint, secondPt: IPoint, m?: number): number {\r\n        if (m === undefined) m = IPoint.getM(firstPt, secondPt);\r\n        return firstPt.y - (m * firstPt.x);\r\n    }\r\n\r\n    public constructor(x: number = 0, y: number = 0) {\r\n        super(); // super('dwc');\r\n        IPoint.init_constructor(this, x, y);\r\n    }\r\n\r\n    static init_constructor(thiss: GObject, x: any = 0, y: any = 0, ...a: any): void {\r\n        thiss.id = \"POINT_\" + (DPointerTargetable.maxID++) + \"_\" + new Date().getTime();\r\n        thiss.className = thiss.constructor.name;\r\n        if (x === null || x === undefined) thiss.x = undefined as Temporary;\r\n        else if (isNaN(+x)) { thiss.x = 0; }\r\n        else thiss.x = +x;\r\n        if (y === null || y === undefined) thiss.y = undefined as Temporary;\r\n        else if (isNaN(+y)) { thiss.y = 0; }\r\n        else thiss.y = +y;\r\n        thiss.className = this.cname;\r\n    }\r\n\r\n\r\n    static printDiff(s1: SizeLike, s2: SizeLike) {\r\n        return ISize.printDiff(s1, s2, true);\r\n    }\r\n    public raw(): {x: number, y: number} { return {x: this.x, y: this.y}; }\r\n\r\n    public toString(letters: boolean=true, separator: string = \" \"): string {\r\n        if (letters) return  JSON.stringify({x:this.x, y: this.y});\r\n        else return this.x + separator + this.y + separator;\r\n    }\r\n    public clone(other: { x: number, y: number }): this { this.x = other.x; this.y = other.y; return this; }\r\n\r\n    protected abstract new(): this;\r\n    abstract toSize(w: number, h?: number): ISize;\r\n    public duplicate(): this { const ret = this.new(); ret.clone(this); return ret; }\r\n\r\n    public distanceFromPoint(tentativeEnd: IPoint, skipSqrt: boolean = false): number {\r\n        let d_pow2 = (this.x - tentativeEnd.x)**2 + (this.y - tentativeEnd.y)**2;\r\n        return skipSqrt ? d_pow2 : Math.sqrt(d_pow2);\r\n        // return this.subtract(tentativeEnd, true).absolute();\r\n    }\r\n\r\n    public subtract(p2: { x?: number, y?: number }, newInstance: boolean): this {\r\n        Log.e(!p2, 'subtract argument must be a valid point: ', p2);\r\n        let p1: this;\r\n        if (!newInstance) { p1 = this; } else { p1 = this.duplicate(); }\r\n        if (p2.x !== undefined) p1.x -= p2.x;\r\n        if (p2.y !== undefined) p1.y -= p2.y;\r\n        return p1; }\r\n\r\n    public add(p2: { x?: number, y?: number }, newInstance: boolean): this {\r\n        Log.e(!p2, 'add argument must be a valid point: ', p2);\r\n        let p1: this;\r\n        if (!newInstance) { p1 = this; } else { p1 = this.duplicate(); }\r\n        if (p2.x !== undefined) p1.x += p2.x;\r\n        if (p2.y !== undefined) p1.y += p2.y;\r\n        return p1; }\r\n\r\n    public addAll(p: IPoint[], newInstance: boolean): this {\r\n        let i;\r\n        let p0: this;\r\n        if (!newInstance) { p0 = this; } else { p0 = this.duplicate(); }\r\n        for (i = 0; i < p.length; i++) { p0.add(p[i], true); }\r\n        return p0; }\r\n\r\n    public subtractAll(p: this[], newInstance: boolean): this {\r\n        let i;\r\n        let p0: this;\r\n        if (!newInstance) { p0 = this; } else { p0 = this.duplicate(); }\r\n        for (i = 0; i < p.length; i++) { p0.subtract(p[i], true); }\r\n        return p0; }\r\n\r\n    public multiply(pt: {x?: number, y?: number} | number, newInstance: boolean = false): this {\r\n        let ret: this = (newInstance ? this.duplicate() : this);\r\n        if (typeof pt === \"number\") {\r\n            ret.x *= pt;\r\n            ret.y *= pt;\r\n        }\r\n        else {\r\n            if (pt.x !== undefined) ret.x *= pt.x;\r\n            if (pt.y !== undefined) ret.y *= pt.y;\r\n        }\r\n        return ret; }\r\n\r\n    public divide(pt: Partial<this> | number, newInstance: boolean = false): this {\r\n        let ret = (newInstance ? this.duplicate() : this);\r\n        if (typeof pt === \"number\") {\r\n            ret.x /= pt;\r\n            ret.y /= pt;\r\n        }\r\n        else {\r\n            ret.x /= pt.x as number;\r\n            ret.y /= pt.y as number;\r\n        }\r\n        return ret; }\r\n\r\n    public multiplyScalar(scalar: number, newInstance: boolean): this {\r\n        Log.e(isNaN(+scalar), 'IPoint.multiply()', 'scalar argument must be a valid number: ', scalar);\r\n        let p1: this;\r\n        if (!newInstance) { p1 = this; } else { p1 = this.duplicate(); }\r\n        p1.x *= scalar;\r\n        p1.y *= scalar;\r\n        return p1; }\r\n\r\n    public divideScalar(scalar: number, newInstance: boolean): this {\r\n        Log.e(isNaN(+scalar), 'IPoint.divide()', 'scalar argument must be a valid number: ', scalar);\r\n        let p1: this;\r\n        if (!newInstance) { p1 = this; } else { p1 = this.duplicate(); }\r\n        p1.x /= scalar;\r\n        p1.y /= scalar;\r\n        return p1; }\r\n\r\n    public isInTheMiddleOf(firstPt: this, secondPt: this, tolleranza: number): boolean {\r\n        const rectangle: Size = Size.fromPoints(firstPt, secondPt);\r\n        const tolleranzaX = tolleranza; // actually should be cos * arctan(m);\r\n        const tolleranzaY = tolleranza; // actually should be sin * arctan(m);\r\n        if (this.x < rectangle.x - tolleranzaX || this.x > rectangle.x + rectangle.w + tolleranzaX) { return false; }\r\n        if (this.y < rectangle.y - tolleranzaX || this.y > rectangle.y + rectangle.h + tolleranzaY) { return false; }\r\n        // const m = IPoint.getM(firstPt, secondPt);\r\n        // const q = IPoint.getQ(firstPt, secondPt);\r\n        const lineDistance = this.distanceFromLine(firstPt, secondPt);\r\n        // console.log('distance:', lineDistance, ', this:', this, ', p1:', firstPt, ', p2:', secondPt);\r\n        return lineDistance <= tolleranza; }\r\n\r\n    public distanceFromLine(p1: IPoint, p2: IPoint): number {\r\n        const top: number =\r\n            + (p2.y - p1.y) * this.x\r\n            - (p2.x - p1.x) * this.y\r\n            + p2.x * p1.y\r\n            - p1.x * p2.y;\r\n        const bot =\r\n            (p2.y - p1.y) * (p2.y - p1.y) +\r\n            (p2.x - p1.x) * (p2.x - p1.x);\r\n        return Math.abs(top) / Math.sqrt(bot);  }\r\n\r\n    public equals(pt: {x:number, y:number}, tolleranzaX: number = 0, tolleranzaY: number = 0): boolean {\r\n        if (pt === null) { return false; }\r\n        return Math.abs(this.x - pt.x) <= tolleranzaX && Math.abs(this.y - pt.y) <= tolleranzaY; }\r\n\r\n    public moveOnNearestBorder(startVertexSize: ISize, clone: boolean, graph: TODO/*IGraph*/, debug: boolean = true): IPoint {\r\n        const pt: IPoint = clone ? this.duplicate() : this;\r\n        const tl: IPoint = startVertexSize.tl();\r\n        const tr: IPoint = startVertexSize.tr();\r\n        const bl: IPoint = startVertexSize.bl();\r\n        const br: IPoint = startVertexSize.br();\r\n        const L: number = pt.distanceFromLine(tl, bl);\r\n        const R: number = pt.distanceFromLine(tr, br);\r\n        const T: number = pt.distanceFromLine(tl, tr);\r\n        const B: number = pt.distanceFromLine(bl, br);\r\n        const min: number = Math.min(L, R, T, B);\r\n        if (min === L) { pt.x = tl.x; }\r\n        if (min === R) { pt.x = tr.x; }\r\n        if (min === T) { pt.y = tr.y; }\r\n        if (min === B) { pt.y = br.y; }\r\n        if (debug && graph && pt instanceof GraphPoint) { graph.markg(pt, false, 'purple'); }\r\n        return pt; }\r\n\r\n    public getM(pt2: IPoint): number { return IPoint.getM?.(this, pt2) as unknown as number; }\r\n\r\n    public degreeWith(pt2: IPoint, toRadians: boolean): number {\r\n        const directionVector: IPoint = this.subtract(pt2, true);\r\n        const ret: number = Math.atan2(directionVector.y, directionVector.x);\r\n        return toRadians ? ret : windoww.U.RadToDegree(ret); }\r\n\r\n    public absolute(): number { return Math.sqrt(this.x * this.x + this.y * this.y); }\r\n    public set(x: number, y: number) { this.x = x; this.y = y; }\r\n\r\n    // move the point by a vector with direction and distance (module)\r\n    move(rad: radian /*in radians!*/, distance: number, clone:boolean = true): this{\r\n        let pt = clone ? this.duplicate() : this;\r\n        pt.x += distance * Math.cos(rad);\r\n        pt.y += distance * Math.sin(rad);\r\n        return pt;\r\n    }\r\n\r\n    static stringify(ptlike: {x?:number, y?:number}): string {\r\n        if (!ptlike) return ptlike;\r\n        let str: string[];\r\n        return '('+U.cropNum(ptlike.x||0)+', '+U.cropNum(ptlike.y||0)+')';\r\n    }\r\n}\r\n\r\n@RuntimeAccessible('GraphPoint')\r\nexport class GraphPoint extends IPoint{\r\n    private dontmixwithPoint: any;\r\n    public static fromEvent(e: JQuery.ClickEvent | JQuery.MouseMoveEvent | JQuery.MouseUpEvent | JQuery.MouseDownEvent | JQuery.MouseEnterEvent | JQuery.MouseLeaveEvent | JQuery.MouseEventBase)\r\n        : GraphPoint | null {\r\n        if (!e) { return null; }\r\n        const p: Point = new Point(e.pageX, e.pageY);\r\n        const g: any = null;\r\n        throw new Error(\"todo: const g: IGraph = Status.status.getActiveModel().graph;\");\r\n        return g.toGraphCoord(p); }\r\n\r\n    protected new(): this { return new GraphPoint() as this;}\r\n    public toSize(w: number, h?: number): GraphSize {\r\n        return new GraphSize(this.x, this.y, w, (h === undefined) ? w : h);\r\n    }\r\n\r\n}\r\n\r\n\r\n@RuntimeAccessible('Point')\r\nexport class Point extends IPoint{\r\n    private dontmixwithGPoint: any;\r\n    /// https://stackoverflow.com/questions/6073505/what-is-the-difference-between-screenx-y-clientx-y-and-pagex-y\r\n    public static fromEvent(e: JQuery.ClickEvent | JQuery.MouseMoveEvent | JQuery.MouseUpEvent | JQuery.MouseDownEvent\r\n        | JQuery.MouseEnterEvent | JQuery.MouseLeaveEvent | JQuery.MouseEventBase | React.MouseEvent)\r\n        : Point {\r\n        const p: Point = new Point(e.pageX, e.pageY);\r\n        return p; }\r\n\r\n    protected new(): this { return new Point() as this;}\r\n    public toSize(w: number, h?: number): Size {\r\n        return new Size(this.x, this.y, w, (h === undefined) ? w : h);\r\n    }\r\n}\r\n\r\nRuntimeAccessibleClass.set_extend(RuntimeAccessibleClass, IPoint);\r\nRuntimeAccessibleClass.set_extend(IPoint, GraphPoint);\r\nRuntimeAccessibleClass.set_extend(IPoint, Point);\r\n\r\n@RuntimeAccessible('ISize')\r\nexport abstract class ISize<PT extends IPoint = IPoint> extends RuntimeAccessibleClass {\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    public x!: number;\r\n    public y!: number;\r\n    public w!: number;\r\n    public h!: number;\r\n    public constructor(x: number = 0, y: number = 0, w: number = 0, h: number = 0) {\r\n        super(); // super('dwc');\r\n        // do not override any fields from the DPointerTargetable, otherwise the ! in the override will reinizialize the attribute\r\n        // erasing the value set in super or in the functions called by the constructor as side effect (static_init called from constructor will be overridden too)\r\n        // if need to override types, build the \"new\" static function like in DModelElement\r\n        ISize.init_constructor(this, x, y, w, h);\r\n    }\r\n\r\n\r\n    static printDiff(s1: SizeLike, s2: SizeLike, asPoints:boolean = false, maxDigits:number = 5) {\r\n        s1 = {...s1, w: s1.w ?? s1.width, h: s1.h ?? s1.height};\r\n        s1.x = s1.x ?? s2.x;\r\n        s1.y = s1.y ?? s2.y;\r\n        s2 = {...s2, w: s2.w ?? s2.width, h: s2.h ?? s2.height};\r\n        if (!asPoints) {\r\n            s1.w = s1.w ?? s2.w;\r\n            s1.h = s1.h ?? s2.h;\r\n        }\r\n        let s1coords: (number | string)[] = [];\r\n        s1coords.push(!U.isNumber(s1.x) ? '' : U.cropNum(s1.x, maxDigits));\r\n        s1coords.push(!U.isNumber(s1.y) ? ',' : ', '+U.cropNum(s1.y, maxDigits));\r\n        if (!asPoints) {\r\n            s1coords.push(!U.isNumber(s1.w) ? ',' : ', '+U.cropNum(s1.w, maxDigits));\r\n            s1coords.push(!U.isNumber(s1.h) ? ',' : ', '+U.cropNum(s1.h, maxDigits));\r\n        }\r\n        let s2coords: (number | string)[] = [];\r\n        s2coords.push(s2.x === s1.x || !U.isNumber(s2.x) ? '' : U.cropNum(s2.x, maxDigits));\r\n        s2coords.push(s2.y === s1.y || !U.isNumber(s2.y) ? ',' : ', '+U.cropNum(s2.y, maxDigits));\r\n        if (!asPoints) {\r\n            s2coords.push(s2.w === s1.w || !U.isNumber(s2.w) ? ',' : ', '+U.cropNum(s2.w, maxDigits));\r\n            s2coords.push(s2.h === s1.h || !U.isNumber(s2.h) ? ',' : ', '+U.cropNum(s2.h, maxDigits));\r\n        }\r\n\r\n        // → 🡲\r\n        return `(`+s1coords.join('')+`)🡲(`+s2coords.join('')+`)`;\r\n    }\r\n    static stringify(ptlike: {x?:number, y?:number, w?:number, h?:number, width?:number, height?:number}): string {\r\n        if (!ptlike) return ptlike as any;\r\n        let str: string[] = [];\r\n        if (ptlike.x && !isNaN(ptlike.x)|| ptlike.x === 0) str.push('x:'+U.cropNum(ptlike.x));\r\n        if (ptlike.y && !isNaN(ptlike.y)|| ptlike.y === 0) str.push('y:'+U.cropNum(ptlike.y));\r\n        if (ptlike.w && !isNaN(ptlike.w)|| ptlike.w === 0) str.push('w:'+U.cropNum(ptlike.w));\r\n        if (ptlike.h && !isNaN(ptlike.h)|| ptlike.h === 0) str.push('h:'+U.cropNum(ptlike.h));\r\n        if (ptlike.width && !isNaN(ptlike.width) || ptlike.width === 0) str.push('W:'+U.cropNum(ptlike.width));\r\n        if (ptlike.height && !isNaN(ptlike.height) || ptlike.height === 0) str.push('H:'+U.cropNum(ptlike.height));\r\n        // if (str.length === 0) return '{}';\r\n        return '{'+str.join(', ')+'}';\r\n    }\r\n\r\n    static init_constructor(thiss: GObject, x: any = 0, y: any = 0, w: any = 0, h: any = 0, ...a: any): void {\r\n        thiss.id = \"SIZE_\" + (DPointerTargetable.maxID++) + \"_\" + new Date().getTime();\r\n        thiss.className = (thiss.constructor as typeof RuntimeAccessibleClass).cname;\r\n        if (x === null || x === undefined) thiss.x = undefined as Temporary;\r\n        else if (isNaN(+x)) { thiss.x = 0; }\r\n        else thiss.x = +x;\r\n        if (y === null || y === undefined) thiss.y = undefined as Temporary;\r\n        else if (isNaN(+y)) { thiss.y = 0; }\r\n        else thiss.y = +y;\r\n        if (w === null || w === undefined) thiss.w = undefined as Temporary;\r\n        else if (isNaN(+w)) { thiss.w = 0; }\r\n        else thiss.w = +w;\r\n        if (h === null || h === undefined) thiss.h = undefined as Temporary;\r\n        else if (isNaN(+h)) { thiss.h = 0; }\r\n        else thiss.h = +h;\r\n        thiss.className = this.cname; }\r\n\r\n    public toString(letters: boolean=true, separator: string = \" \"): string {\r\n        if (letters) return JSON.stringify({x: this.x, y: this.y, w: this.w, h: this.h});\r\n        else return this.x + separator + this.y + separator + this.w + separator + this.h;\r\n    }\r\n\r\n    public set(x?: number, y?: number, w?: number, h?: number): void {\r\n        if (x !== undefined) (this.x = +x);\r\n        if (y !== undefined) (this.y = +y);\r\n        if (w !== undefined) (this.w = +w);\r\n        if (h !== undefined) (this.h = +h);\r\n    }\r\n\r\n    protected abstract makePoint(x: number, y: number): PT;\r\n    protected abstract new(...args:any): this;\r\n    public clone(json: this): this { this.x = json.x; this.y = json.y; this.w = json.w; this.h = json.h; return this; }\r\n    public duplicate(): this { return this.new().clone(this); }\r\n\r\n    public add(pt2: number | {x?:number, y?:number, w?:number, h?:number}, newInstance?: boolean): this {\r\n        let thiss = newInstance ? this.duplicate() : this;\r\n        if (typeof pt2 === \"number\") { thiss.x += pt2; thiss.y += pt2; thiss.w += pt2; thiss.h += pt2; return thiss; }\r\n        if (pt2.x !== undefined) thiss.x += pt2.x;\r\n        if (pt2.y !== undefined) thiss.y += pt2.y;\r\n        if (pt2.w !== undefined) thiss.w += pt2.w;\r\n        if (pt2.h !== undefined) thiss.h += pt2.h;\r\n        return thiss; }\r\n\r\n    public subtract(pt2: number | {x?:number, y?:number, w?:number, h?:number}, newInstance?: boolean): this {\r\n        let thiss = newInstance ? this.duplicate() : this;\r\n        if (typeof pt2 === \"number\") { thiss.x -= pt2; thiss.y -= pt2; thiss.w -= pt2; thiss.h -= pt2; return thiss; }\r\n        if (pt2.x !== undefined) thiss.x -= pt2.x;\r\n        if (pt2.y !== undefined) thiss.y -= pt2.y;\r\n        if (pt2.w !== undefined) thiss.w -= pt2.w;\r\n        if (pt2.h !== undefined) thiss.h -= pt2.h;\r\n        return thiss; }\r\n\r\n    public multiply(pt2: number | {x?:number, y?:number, w?:number, h?:number}, newInstance?: boolean): this {\r\n        let thiss = newInstance ? this.duplicate() : this;\r\n        if (typeof pt2 === \"number\") { thiss.x *= pt2; thiss.y *= pt2; thiss.w *= pt2; thiss.h *= pt2; return thiss; }\r\n        if (pt2.x !== undefined) thiss.x *= pt2.x;\r\n        if (pt2.y !== undefined) thiss.y *= pt2.y;\r\n        if (pt2.w !== undefined) thiss.w *= pt2.w;\r\n        if (pt2.h !== undefined) thiss.h *= pt2.h;\r\n        return thiss; }\r\n\r\n    public divide(pt2: number | {x?:number, y?:number, w?:number, h?:number}, newInstance?: boolean): this {\r\n        let thiss = newInstance ? this.duplicate() : this;\r\n        if (typeof pt2 === \"number\") { thiss.x /= pt2; thiss.y /= pt2; thiss.w /= pt2; thiss.h /= pt2; return thiss; }\r\n        if (pt2.x !== undefined) thiss.x /= pt2.x;\r\n        if (pt2.y !== undefined) thiss.y /= pt2.y;\r\n        if (pt2.w !== undefined) thiss.w /= pt2.w;\r\n        if (pt2.h !== undefined) thiss.h /= pt2.h;\r\n        return thiss; }\r\n\r\n\r\n    public tl(): PT {     return this.makePoint(   this.x,                 this.y             ); }\r\n    public tr(): PT {     return this.makePoint(this.x + this.w,        this.y             ); }\r\n    public bl(): PT {     return this.makePoint(   this.x,              this.y + this.h    ); }\r\n    public br(): PT {     return this.makePoint(this.x + this.w,     this.y + this.h    ); }\r\n    public center(): PT { return this.makePoint(this.x + this.w / 2, this.y + this.h / 2); }\r\n    public relativePoint(xPercent: number, yPercent: number): PT { return this.makePoint(this.x + this.w * xPercent, this.y + this.h * yPercent); }\r\n    public equals(size: this): boolean { return this.x === size.x && this.y === size.y && this.w === size.w && this.h === size.h; }\r\n\r\n    /// field-wise Math.min()\r\n    public min(minSize: this, clone: boolean): this {\r\n        const ret: this = clone ? this.new() : this;\r\n        if (!isNaN(minSize.x) && ret.x < minSize.x) { ret.x = minSize.x; }\r\n        if (!isNaN(minSize.y) && ret.y < minSize.y) { ret.y = minSize.y; }\r\n        if (!isNaN(minSize.w) && ret.w < minSize.w) { ret.w = minSize.w; }\r\n        if (!isNaN(minSize.h) && ret.h < minSize.h) { ret.h = minSize.h; }\r\n        return ret; }\r\n    public max(maxSize: this, clone: boolean): this {\r\n        const ret: this = clone ? this.new() : this;\r\n        if (!isNaN(maxSize.x) && ret.x > maxSize.x) { ret.x = maxSize.x; }\r\n        if (!isNaN(maxSize.y) && ret.y > maxSize.y) { ret.y = maxSize.y; }\r\n        if (!isNaN(maxSize.w) && ret.w > maxSize.w) { ret.w = maxSize.w; }\r\n        if (!isNaN(maxSize.h) && ret.h > maxSize.h) { ret.h = maxSize.h; }\r\n        return ret; }\r\n\r\n    public intersection(size: this): this | null {\r\n        if (!size) return null;\r\n        // anche \"isinside\"\r\n        let startx, starty, endx, endy;\r\n        startx = Math.max(this.x, size.x);\r\n        starty = Math.max(this.y, size.y);\r\n        endx = Math.min(this.x + this.w, size.x + size.w);\r\n        endy = Math.min(this.y + this.h, size.y + size.h);\r\n        const intersection: this = this.new();\r\n        // intersection.set(0, 0, 0, 0);\r\n        intersection.x = startx;\r\n        intersection.y = starty;\r\n        intersection.w = endx - startx;\r\n        intersection.h = endy - starty;\r\n        const doesintersect: boolean = intersection.w > 0 && intersection.h > 0;\r\n        return (doesintersect) ? intersection: null; }\r\n\r\n    public contains(pt: PT): boolean {\r\n        return  pt.x >= this.x && pt.x <= this.x + this.w && pt.y >= this.y && pt.y <= this.y + this.h; }\r\n\r\n    public isOverlapping(size2: this): boolean { return !!this.intersection(size2); }\r\n    public isOverlappingAnyOf(sizes: this[]): boolean {\r\n        if (!sizes) return false;\r\n        for (let size of sizes) { if (this.isOverlapping(size)) return true; }\r\n        return false;\r\n    }\r\n\r\n    public multiplyPoint(other: PT, newInstance: boolean): this {\r\n        const ret: this = newInstance ? this.new() : this;\r\n        ret.x *= other.x;\r\n        ret.w *= other.x;\r\n        ret.y *= other.y;\r\n        ret.h *= other.y;\r\n        return ret; }\r\n\r\n    public dividePoint(other: PT, newInstance: boolean): this {\r\n        const ret: this = newInstance ? this.new() : this;\r\n        ret.x /= other.x;\r\n        ret.w /= other.x;\r\n        ret.y /= other.y;\r\n        ret.h /= other.y;\r\n        return ret; }\r\n\r\n    public boundary(size2: this): void {\r\n        /*let minx, maxx, miny, maxy;\r\n        if (size2.y < this.y) { miny = size2.y; /*maxy = this.y;* / } else { miny = this.y; /*maxy = size2.y;* / }\r\n        if (size2.x < this.x) { minx = size2.y; /*maxx = this.x;* / } else { minx = this.x; /*maxy = size2.x;* / }\r\n        if (size2.y + size2.h < this.y + this.h) maxy = this.y + this.h; else maxy = size2.y + size2.h;\r\n        if (size2.x + size2.w < this.x + this.w) maxx = this.x + this.w; else maxx = size2.x + size2.w;\r\n        */\r\n        this.h = (size2.y + size2.h > this.y + this.h ? size2.y + size2.h : this.y + this.h); // -miny\r\n        this.w = (size2.x + size2.w > this.x + this.w ? size2.x + size2.w : this.x + this.w); // -minx\r\n        if (this.y < size2.y) this.y = size2.y;\r\n        if (this.x < size2.x) this.x = size2.x;\r\n        this.h -= this.y;\r\n        this.w -= this.x;\r\n    }\r\n}\r\ntype SizeLike = {x?: number, y?: number, w?: number, h?:number, width?: number, height?: number}\r\ntype PointLike = {x?: number, y?: number}\r\n\r\n@RuntimeAccessible('Size')\r\nexport class Size extends ISize<Point> {\r\n    static subclasses: any[] = [];\r\n    private static sizeofvar: HTMLElement;\r\n    private static $sizeofvar: JQuery<HTMLElement>;\r\n    private dontMixWithGraphSize: any;\r\n\r\n    /**\r\n     * measure a node size\r\n     * @param {Element} element0 - the emelemnt to measure;\r\n     * @param {boolean} sizePostTransform - includes css transform instructions for computing his size. like transform: scale(1.5)\r\n     * */\r\n    public static of(element0: Element, sizePostTransform: boolean = true): Size {\r\n        let element: HTMLElement = element0 as HTMLElement;\r\n        if (element as unknown === document) {\r\n            Log.ww('trying to measure document, rerouted to measuring body.');\r\n            element = document.body as any;\r\n        }\r\n        const $element = $(element);\r\n        Log.ex(!element || element.tagName === 'foreignObject', 'sizeof()', 'SvgForeignElementObject have a bug with size, measure a child instead.', element);\r\n        let tmp;\r\n        let size: Size;\r\n        if (!Size.sizeofvar) {\r\n            Size.sizeofvar = document.createElement('div');\r\n            document.body.append(Size.sizeofvar); }\r\n\r\n        const isOrphan = element.parentNode === null;\r\n        // var visible = element.style.display !== 'none';\r\n        // var visible = $element.is(\":visible\"); crea bug quando un elemento è teoricamente visibile ma orfano\r\n        const ancestors =  windoww.U.ancestorArray(element);\r\n        const displayStyles: string[] = ancestors.map( (e: HTMLElement) => e?.style?.display);\r\n        if (isOrphan) { Size.sizeofvar.append(element); }\r\n        // show all and saveToDB visibility to restore it later\r\n        for (let i = 0; i < ancestors.length; i++) { // document has undefined style\r\n            displayStyles[i] = ancestors[i]?.style?.display;\r\n            if (displayStyles[i] === 'none' || (displayStyles[i] === '' && getComputedStyle(ancestors[i]).display === 'none')) { ancestors[i].style.display = 'block' }\r\n        }\r\n        // size = new Size(tmp.left, tmp.top, 0, 0);\r\n        let rect = element.getBoundingClientRect();\r\n        size = new Size(0, 0, 0, 0);\r\n\r\n        let win = (element.ownerDocument?.defaultView || window);\r\n        size.x = rect.left + win.scrollX;\r\n        size.y = rect.top + win.scrollY;\r\n        if (sizePostTransform) {\r\n            size.w = rect.width;\r\n            size.h = rect.height;\r\n        }\r\n        else {\r\n            size.w = element.offsetWidth; // element.scrollWidth;\r\n            size.h = element.offsetHeight;\r\n        }\r\n        // restore visibility\r\n        for (let i = 0; i < ancestors.length; i++) {\r\n            if (displayStyles[i] === ancestors[i].style?.display) continue;\r\n            if (displayStyles[i]) ancestors[i].style.display = displayStyles[i];\r\n            else ancestors[i].style.removeProperty('display');\r\n        }\r\n        if (isOrphan) {  windoww.U.clear(Size.sizeofvar); }\r\n        // Status.status.getActiveModel().graph.markS(size, false);\r\n        return size;\r\n    }\r\n\r\n    public static fromPoints(firstPt: IPoint, secondPt: IPoint): Size {\r\n        const minX = Math.min(firstPt.x, secondPt.x);\r\n        const maxX = Math.max(firstPt.x, secondPt.x);\r\n        const minY = Math.min(firstPt.y, secondPt.y);\r\n        const maxY = Math.max(firstPt.y, secondPt.y);\r\n        return new Size(minX, minY, maxX - minX, maxY - minY); }\r\n\r\n    protected makePoint(x: number, y: number): Point { return new Point(x, y); }\r\n    protected new(...args:any): this { return new Size(...args) as this; }\r\n}\r\n@RuntimeAccessible('GraphSize')\r\nexport class GraphSize extends ISize<GraphPoint> {\r\n    private dontMixWithSize: any;\r\n\r\n    public static fromPoints(firstPt: GraphPoint, secondPt: GraphPoint): GraphSize {\r\n        const minX = Math.min(firstPt.x, secondPt.x);\r\n        const maxX = Math.max(firstPt.x, secondPt.x);\r\n        const minY = Math.min(firstPt.y, secondPt.y);\r\n        const maxY = Math.max(firstPt.y, secondPt.y);\r\n        return new GraphSize(minX, minY, maxX - minX, maxY - minY); }\r\n\r\n    // both pt and targetPt are readonly-safe parameters\r\n    public static closestIntersection(size: GraphSize, pt: GraphPoint/*segment start*/, targetPt: GraphPoint/*segment end*/, gridAlign?: GraphPoint, m0?:number, q0?:number): GraphPoint | undefined {\r\n        // let pt: GraphPoint = pt0.duplicate();\r\n        const m = m0 || GraphPoint.getM(targetPt, pt);\r\n        const q = q0 || GraphPoint.getQ(targetPt, pt);\r\n        // console.log(\"closestIntersection()\", {size, pt0, targetPt, m, q});\r\n        // let mrecalc = GraphPoint.getM(targetPt, pt);\r\n        // if (mrecalc !== m) console.error('closestIntersection err', {size, pt, targetPt, mrecalc, m, q, mcorrect: mrecalc == m, qcorrect: GraphPoint.getQ(targetPt, pt) === q})\r\n        // else  console.log('closestIntersection 0', {size, pt, targetPt, m, q, mcorrect: mrecalc == m, mrecalc, qcorrect: GraphPoint.getQ(targetPt, pt) === q})\r\n        // if perfectly vertical line\r\n        if (U.isInfinite(m)) {\r\n            // top center\r\n            if (Math.abs(targetPt.y - size.y) <= Math.abs(targetPt.y - size.y - size.h)) return new GraphPoint(pt.x, size.y);\r\n            // bottom center\r\n            else return new GraphPoint(pt.x, size.y + size.h);\r\n        }\r\n        let tl = size.tl(), tr = size.tr(),\r\n            bl = size.bl(), br = size.br();\r\n        let allowT: boolean, allowB: boolean,\r\n            allowL: boolean, allowR: boolean;\r\n        /*let distanceT: number = Number.POSITIVE_INFINITY, distanceB: number = Number.POSITIVE_INFINITY,\r\n            distanceL: number = Number.POSITIVE_INFINITY, distanceR: number = Number.POSITIVE_INFINITY;*/\r\n        let intersectionT: GraphPoint | undefined, intersectionB: GraphPoint | undefined,\r\n            intersectionL: GraphPoint | undefined, intersectionR: GraphPoint | undefined;\r\n\r\n\r\n        allowT = Geom.isNumberBetween(tl.y, bl.y, targetPt.y);\r\n        allowB = Geom.isNumberBetween(bl.y, tl.y, targetPt.y);\r\n        allowL = Geom.isNumberBetween(tl.x, tr.x, targetPt.x);\r\n        allowR = Geom.isNumberBetween(tr.x, tl.x, targetPt.x);\r\n        // console.log(\"closestIntersection pt0\", {size, targetPt, pt0:pt0.raw(), gridAlign,\r\n        //     corners:{tl:tl.raw(), tr:tr.raw(), bl:bl.raw(), br:br.raw()}, allows:{allowT, allowB, allowL, allowR}});\r\n        // console.log(\"closestIntersection 1\", {isInternal:!(allowT || allowB || allowL || allowR), allowT, allowB, allowL, allowR});\r\n        if (!(allowT || allowB || allowL || allowR)) return undefined; // point is internal to size\r\n        if (allowT) intersectionT = Geom.lineToSegmentIntersection(tl, tr, q, m); else\r\n        if (allowB) intersectionB = Geom.lineToSegmentIntersection(bl, br, q, m); // NOT else, (T|B) AND (L|R) can happen, or just 1 or 0 of those.\r\n        if (allowL) intersectionL = Geom.lineToSegmentIntersection(tl, bl, q, m); else\r\n        if (allowR) intersectionR = Geom.lineToSegmentIntersection(tr, br, q, m);\r\n\r\n        // console.log(\"closestIntersection 2\", {intersectionT, intersectionB, intersectionL, intersectionR});\r\n        // only 1 intersection can happen\r\n        return intersectionT || intersectionB || intersectionL || intersectionR;\r\n    }\r\n    public static closestIntersection_old(size: GraphSize, prevPt: GraphPoint, pt0: GraphPoint, gridAlign?: GraphPoint): GraphPoint | null {\r\n        let ret = GraphSize.closestIntersection0(size, prevPt, pt0, gridAlign) as any;\r\n        // Log.exDev(!Geom.isOnEdge(ret, size), 'ClosestIntersection failed. not on Vertex edge.', {ret, size, prevPt, pt0, gridAlign});\r\n        return ret;\r\n    }\r\n    private static closestIntersection0(vertexGSize: GraphSize, prevPt: GraphPoint, pt0: GraphPoint, gridAlign?: GraphPoint): GraphPoint | null {\r\n        let pt: GraphPoint | null = pt0.duplicate();\r\n        const m = GraphPoint.getM(prevPt, pt) as number;\r\n        const q = GraphPoint.getQ(prevPt, pt) as number;\r\n        // U.pe( Math.abs((pt.y - m * pt.x) - (prevPt.y - m * prevPt.x)) > .001, 'wrong math in Q:', (pt.y - m * pt.x), ' vs ', (prevPt.y - m * prevPt.x));\r\n        /*const isL = prevPt.x < pt.x;\r\n    const isT = prevPt.y < pt.y;\r\n    const isR = !isL;\r\n    const isB = !isT; */\r\n        if (U.isInfinite(m)) { // bottom middle\r\n            return new GraphPoint(vertexGSize.x + vertexGSize.w / 2, vertexGSize.y + vertexGSize.h); }\r\n        // console.log('pt:', pt, 'm:', m, 'q:', q);\r\n        let L: GraphPoint | null = new GraphPoint(0, 0);\r\n        let T: GraphPoint | null = new GraphPoint(0, 0);\r\n        let R: GraphPoint | null = new GraphPoint(0, 0);\r\n        let B: GraphPoint | null = new GraphPoint(0, 0);\r\n        L.x = vertexGSize.x;\r\n        L.y = m * L.x + q;\r\n        R.x = vertexGSize.x + vertexGSize.w;\r\n        R.y = m * R.x + q;\r\n        T.y = vertexGSize.y;\r\n        T.x = (T.y - q) / m;\r\n        B.y = vertexGSize.y + vertexGSize.h;\r\n        B.x = (B.y - q) / m;\r\n        // prendo solo il compreso pt ~ prevPt (escludo così il \"pierce\" sulla faccia opposta), prendo il più vicino al centro.\r\n        // console.log('4 possibili punti di intersezione (LTBR):', L, T, B, R);\r\n        /* this.owner.mark(this.owner.toHtmlCoord(T), true, 'blue');\r\n    this.owner.mark(this.owner.toHtmlCoord(B), false, 'violet');\r\n    this.owner.mark(this.owner.toHtmlCoord(L), false, 'red');\r\n    this.owner.mark(this.owner.toHtmlCoord(R), false, 'orange');*/\r\n        console.log(\"intersect pt1:\", {T, B, L, R});\r\n        if ( (B.x >= pt.x && B.x <= prevPt.x) || (B.x >= prevPt.x && B.x <= pt.x) ) { } else { B = null; }\r\n        if ( (T.x >= pt.x && T.x <= prevPt.x) || (T.x >= prevPt.x && T.x <= pt.x) ) { } else { T = null; }\r\n        if ( (L.y >= pt.y && L.y <= prevPt.y) || (L.y >= prevPt.y && L.y <= pt.y) ) { } else { L = null; }\r\n        if ( (R.y >= pt.y && R.y <= prevPt.y) || (R.y >= prevPt.y && R.y <= pt.y) ) { } else { R = null; }\r\n        console.log(\"intersect pt2:\", {T, B, L, R});\r\n        function closestmix(pt: GraphPoint, closest: GraphPoint, segStart: GraphPoint, segEnd: GraphPoint, mode: \"TB\" | \"LR\"): void {\r\n            // changes pt\r\n            pt.x = closest.x; pt.y = closest.y; return;\r\n            let main: \"x\" | \"y\", sub: \"x\" | \"y\";\r\n            if (mode === \"TB\") { main = \"y\"; sub = \"x\"; } else { main = \"x\"; sub = \"y\"; }\r\n            pt[main] = closest[main];\r\n            // if T[sub] is inside the top segment, take T[sub], otherwise closest between size.tl[sub] and size.tr[sub]\r\n            // pt[sub] = Math.max(segStart[sub], Math.min(segStart[sub], closest[sub]));\r\n            if (closest[sub] <= segEnd[sub] && closest[sub] >= segStart[sub]) pt[sub] = closest[sub];\r\n            else if (Math.abs(closest[sub]-segEnd[sub]) < Math.abs(closest[sub]-segStart[sub])) pt[sub] = segEnd[sub];\r\n            else pt[sub] = segStart[sub];\r\n        }\r\n        function closestmix2(pt: GraphPoint, closest: GraphPoint, segStart: GraphPoint, segEnd: GraphPoint, mode: \"TB\" | \"LR\"): void {\r\n            // changes closest\r\n            let main: \"x\" | \"y\", sub: \"x\" | \"y\";\r\n            if (mode === \"TB\") { main = \"y\"; sub = \"x\"; } else { main = \"x\"; sub = \"y\"; }\r\n            // closest[main] = pt[main];\r\n            // if T[sub] is inside the top segment, take T[sub], otherwise closest between size.tl[sub] and size.tr[sub]\r\n            // pt[sub] = Math.max(segStart[sub], Math.min(segStart[sub], closest[sub]));\r\n            if (closest[sub] <= segEnd[sub] && closest[sub] >= segStart[sub]) {/*no-op*/}\r\n            else if (Math.abs(closest[sub]-segEnd[sub]) < Math.abs(closest[sub]-segStart[sub])) closest[sub] = segEnd[sub];\r\n            else closest[sub] = segStart[sub];\r\n        }\r\n        console.log(\"intersect pt2.5:\");\r\n        try{\r\n            if(T) closestmix2(pt, T, vertexGSize.tl(), vertexGSize.tr(), \"TB\");\r\n            if(B) closestmix2(pt, B, vertexGSize.bl(), vertexGSize.br(), \"TB\");\r\n            if(R) closestmix2(pt, R, vertexGSize.tr(), vertexGSize.br(), \"LR\");\r\n            if(L) closestmix2(pt, L, vertexGSize.tl(), vertexGSize.bl(), \"LR\");\r\n        } catch(e){ console.error(\"intersect error\",e)}\r\n        // console.log('superstiti step1: (LTBR):', L, T, B, R);\r\n        console.log(\"intersect pt2.9:\");\r\n        const vicinanzaT = !T ? Number.POSITIVE_INFINITY : ((T.x - pt.x) * (T.x - pt.x)) + ((T.y - pt.y) * (T.y - pt.y));\r\n        const vicinanzaB = !B ? Number.POSITIVE_INFINITY : ((B.x - pt.x) * (B.x - pt.x)) + ((B.y - pt.y) * (B.y - pt.y));\r\n        const vicinanzaL = !L ? Number.POSITIVE_INFINITY : ((L.x - pt.x) * (L.x - pt.x)) + ((L.y - pt.y) * (L.y - pt.y));\r\n        const vicinanzaR = !R ? Number.POSITIVE_INFINITY : ((R.x - pt.x) * (R.x - pt.x)) + ((R.y - pt.y) * (R.y - pt.y));\r\n        const closest = Math.min(vicinanzaT, vicinanzaB, vicinanzaL, vicinanzaR);\r\n        console.log(\"intersect pt3:\", {vicinanzaT, vicinanzaB, vicinanzaL, vicinanzaR, closest});\r\n\r\n        // console.log( 'closest:', closest);\r\n        // succede quando pt e prevPt sono entrambi all'interno del rettangolo del vertice.\r\n        // L'edge non è visibile e il valore ritornato è irrilevante.\r\n\r\n        if (closest === Number.POSITIVE_INFINITY) {\r\n            console.error('x01 case +inf, this case should not be possible', {closest, T, B, L, R, vertexGSize, prevPt, pt0});\r\n            /* top center */\r\n            pt = vertexGSize.tl();\r\n            pt.x += vertexGSize.w / 2; } else\r\n        if (closest === Number.NEGATIVE_INFINITY) {\r\n            console.error('x01 case -inf, this case should not be possible', {closest, T, B, L, R, vertexGSize, prevPt, pt0});\r\n            /* bottom center */\r\n            pt = vertexGSize.br();\r\n            pt.x -= vertexGSize.w / 2; } else\r\n        if (closest === vicinanzaT && T) {\r\n            closestmix(pt, T as any, vertexGSize.tl(), vertexGSize.tr(), \"TB\");\r\n            /*pt.y = T.y;\r\n            // if T.x is inside the top segment, take T.x, otherwise closest between size.tl.x and size.tr.x\r\n            if ((T.x <= tr.x && T.x >= tl.x)) pt.x = T.x;\r\n            else if (Math.abs(T.x-tr.x) < Math.abs(T.x-tl.x)) pt.x = tr.x;\r\n            else pt.x = tl.x;*/\r\n        }\r\n        if (closest === vicinanzaB) { closestmix(pt, B as any, vertexGSize.bl(), vertexGSize.br(), \"TB\"); } else\r\n        if (closest === vicinanzaR) { closestmix(pt, R as any, vertexGSize.tr(), vertexGSize.br(), \"LR\"); } else\r\n        if (closest === vicinanzaL) { closestmix(pt, L as any, vertexGSize.tl(), vertexGSize.bl(), \"LR\"); }\r\n\r\n        if (!gridAlign) { return pt; }\r\n        if (!pt) return null;\r\n        if (gridAlign.x && (pt === T || pt === B || isNaN(closest))) {\r\n            const floorX: number = Math.floor(pt.x / gridAlign.x) * gridAlign.x;\r\n            const ceilX: number = Math.ceil(pt.x / gridAlign.x) * gridAlign.x;\r\n            let closestX;\r\n            let farthestX;\r\n            if (Math.abs(floorX - pt.x) < Math.abs(ceilX - pt.x)) {\r\n                closestX = floorX; farthestX = ceilX;\r\n            } else { closestX = ceilX; farthestX = floorX; }\r\n\r\n            // todo: possibile causa del bug che non allinea punti fake a punti reali. nel calcolo realPT questo non viene fatto.\r\n            // if closest grid intersection is inside the vertex.\r\n            if (closestX >= vertexGSize.x && closestX <= vertexGSize.x + vertexGSize.w) { pt.x = closestX; } else\r\n                // if 2° closer grid intersection is inside the vertex.\r\n            if (closestX >= vertexGSize.x && closestX <= vertexGSize.x + vertexGSize.w) { pt.x = farthestX;\r\n                // if no intersection are inside the vertex (ignore grid)\r\n            } else { /* do nothing */ }\r\n        } else if (gridAlign.y && (pt === L || pt === R)) {\r\n            const floorY: number = Math.floor(pt.y / gridAlign.y) * gridAlign.y;\r\n            const ceilY: number = Math.ceil(pt.y / gridAlign.y) * gridAlign.y;\r\n            let closestY;\r\n            let farthestY;\r\n            if (Math.abs(floorY - pt.y) < Math.abs(ceilY - pt.y)) {\r\n                closestY = floorY; farthestY = ceilY;\r\n            } else { closestY = ceilY; farthestY = floorY; }\r\n\r\n            // if closest grid intersection is inside the vertex.\r\n            if (closestY >= vertexGSize.y && closestY <= vertexGSize.y + vertexGSize.h) { pt.y = closestY; } else\r\n                // if 2° closer grid intersection is inside the vertex.\r\n            if (closestY >= vertexGSize.y && closestY <= vertexGSize.y + vertexGSize.h) { pt.y = farthestY;\r\n                // if no intersection are inside the vertex (ignore grid)\r\n            } else { /* do nothing */ }\r\n        }\r\n        return pt; }\r\n\r\n\r\n    protected new(...args: any): this { return new GraphSize(...args) as this; }\r\n    protected makePoint(x: number, y: number): GraphPoint { return new GraphPoint(x, y) as GraphPoint; }\r\n\r\n    closestPoint(pt: GraphPoint): GraphPoint { return Geom.closestPoint(this, pt); }\r\n}\r\n\r\nRuntimeAccessibleClass.set_extend(RuntimeAccessibleClass, ISize);\r\nRuntimeAccessibleClass.set_extend(ISize, Size);\r\nRuntimeAccessibleClass.set_extend(ISize, GraphSize);\r\n\r\n\r\n\r\nexport type PositionStrTypes =\r\n    \"top\" | \"bottom\" | \"left\" | \"right\" | \"\" | // '' = x&y center, undefined = top\r\n    \"top right\" | \"top left\" | \"bottom left\" | \"bottom right\" |\r\n    \"right top\" | \"left top\" | \"left bottom\" | \"right bottom\" |\r\n    \"t\" | \"b\" | \"l\" | \"r\" |\r\n    \"tl\" | \"tr\" | \"bl\" | \"br\" |\r\n    \"lt\" | \"rt\" | \"lb\" | \"rb\";\r\n\r\n@RuntimeAccessible('PositionStr')\r\nexport class PositionStr{\r\n    public static cname = 'PositionStr';\r\n\r\n    x: -1 | 0 | 1; // left, centered, right\r\n    y: -1 | 0 | 1;\r\n    constructor(x?: PositionStr['x'], y? :PositionStr['y']){\r\n        this.x = x ?? 0;\r\n        this.y = y ?? -1;\r\n    }\r\n    toString(): PositionStrTypes{\r\n        return PositionStr.toPosString(this);\r\n    }\r\n    invert(x = true, y = true): this {\r\n        if (x) this.x = -this.x as 1|0|-1;\r\n        if (y) this.y = -this.y as 1|0|-1;\r\n        return this;\r\n    }\r\n    public static toPosString(o: PositionStr): PositionStrTypes{\r\n        let s: string;\r\n        if (o.y === -1) s = 't';\r\n        else if (o.y === 1) s = 'b';\r\n        else s = '';\r\n\r\n        if (o.x === -1) s += 'l';\r\n        else if (o.x === 1) s += 'r';\r\n        // else s = +'';\r\n        // if (!s) return \"c\";\r\n        return s as PositionStrTypes;\r\n    }\r\n    public static fromPosString(position?: PositionStrTypes): PositionStr{\r\n        let ret = new PositionStr(0, 0);\r\n        let posarr = (position ?? 't').split(' '); // .map(s=>s[0]);\r\n        for (let p of posarr)\r\n            switch (p) {\r\n                default:\r\n                case \"t\": case \"top\":                       ret.y = -1; break;\r\n                case \"b\": case \"bottom\":                    ret.y =  1; break;\r\n                case \"l\": case \"left\":                      ret.x = -1; break;\r\n                case \"r\": case \"right\":                     ret.x =  1; break;\r\n                case \"tl\": case \"lt\": case \"top left\":      ret.y = -1; ret.x = -1; break;\r\n                case \"tr\": case \"rt\": case \"top right\":     ret.y = -1; ret.x =  1; break;\r\n                case '': case 'c':                          ret.x =  0; ret.y =  0; break;\r\n                case \"bl\": case \"lb\": case \"bottom left\":   ret.y =  1; ret.x = -1; break;\r\n                case \"br\": case \"rb\": case \"bottom right\":  ret.y =  1; ret.x =  1; break;\r\n            }\r\n        return ret;\r\n    }\r\n    public static invertPosStr(pos?: PositionStrTypes): PositionStrTypes{\r\n        return PositionStr.fromPosString(pos).invert().toString() as any;\r\n    }\r\n\r\n    private static toFullLabelSingle(position: string | \"\" | \"c\" | \"t\" | \"b\" | \"l\" | \"r\"): \"top\" | \"bottom\" | \"left\" | \"right\" | \"center\" {\r\n        switch (position?.trim()[0]){\r\n            case 'c': case '': return 'center';\r\n            case 't': return 'top';\r\n            default: if (position.trim() === '') return 'center'; return 'bottom';\r\n            case 'b': return 'bottom';\r\n            case 'l': return 'left';\r\n            case 'r': return 'right';\r\n        }\r\n    }\r\n    // tl -> top left\r\n    static toSeparateFullLabels(position?: PositionStrTypes): string {\r\n        let pos = (position ?? 'b').trim();\r\n\r\n        if (pos.length === 2) {\r\n            return PositionStr.toFullLabelSingle(pos[0]) + ' ' + PositionStr.toFullLabelSingle(pos[1]);\r\n        } else if (pos.indexOf(' ')) { return pos.split(' ').map(s => PositionStr.toFullLabelSingle(s as any)).join(' '); }\r\n        else return PositionStr.toFullLabelSingle(pos[0]);\r\n        return \"\";\r\n    }\r\n}\r\n\r\n@RuntimeAccessible('Geom')\r\nexport class Geom extends RuntimeAccessibleClass {\r\n\r\n    static markings: Dictionary<string, HTMLElement> = {};\r\n    static unmark(key: string): boolean{\r\n        if (!Geom.markings[key]) return false;\r\n        let e = Geom.markings[key];\r\n        U.removeFromDom(e);\r\n        delete Geom.markings[key];\r\n        return true;\r\n    }\r\n    static markPt(key: string, pt: Point, color?: string, label?: string): HTMLElement{ return Geom.mark(key, pt.x, pt.y, 1, 1, color, label); }\r\n    static markSize(key: string, pt: Size, color?: string, label?: string): HTMLElement{ return Geom.mark(key, pt.x, pt.y, pt.w??1, pt.h??1, color, label); }\r\n    static mark(key: string, x: number, y: number, w: number=1, h: number=1, color: string='red', label: string=''): HTMLElement{\r\n        if (Geom.markings[key]) Geom.unmark(key);\r\n        let e: HTMLElement;\r\n        let pre = '<div class=\"debug-mark\" data-key=\"'+key+'\" data-label=\"'+label+'\" style=\"position: absolute; z-index:99999; left:'+x+'px; top:'+y+'px; width: '+w+'px; height: '+h+'px;';\r\n        let post = '\"/>';\r\n        if (w + h > 2) {\r\n            e = U.toHtml(pre+'border-radius:0; background: transparent;'+post) as HTMLElement;\r\n        }\r\n        else {\r\n            e = U.toHtml(pre+'border-radius:100%; background: '+color+'; outline: 1px solid '+color+'; outline-offset: 5px;'+post) as HTMLElement;\r\n        }\r\n        document.body.append(e);\r\n        Geom.markings[key] = e;\r\n        return e;\r\n    }\r\n    // warning: nodes from other iframes will say are not instance from Element of the current frame, in that case need duck typing.\r\n    public static isHtmlNode(element: any): element is Element {\r\n        return element instanceof Element || element instanceof HTMLDocument || element instanceof SVGElement;\r\n    }\r\n\r\n\r\n    static isPositiveZero(m: number): boolean {\r\n        if (!!Object.is) { return Object.is(m, +0); }\r\n        return (1 / m === Number.POSITIVE_INFINITY); }\r\n\r\n    static isNegativeZero(m: number): boolean {\r\n        if (!!Object.is) { return Object.is(m, -0); }\r\n        return (1 / m === Number.NEGATIVE_INFINITY); }\r\n\r\n    static TanToRadian(n: number): number { return Geom.DegreeToRad(Geom.TanToDegree(n)); }\r\n    static TanToDegree(n: number): number {\r\n        if (Geom.isPositiveZero(n)) { return 0; }\r\n        if (n === Number.POSITIVE_INFINITY) { return 90; }\r\n        if (Geom.isNegativeZero(n)) { return 180; }\r\n        if (n === Number.NEGATIVE_INFINITY) { return 270; }\r\n        return Geom.RadToDegree((window as any).Math.atan(n)); }\r\n\r\n    static RadToDegree(radians: number): number { return Geom.radToDeg(radians); }\r\n    static DegreeToRad(degree: number): number { return Geom.degToRad(degree); }\r\n    static radToDeg(radians: number): number { return radians * (180 / Math.PI); }\r\n    static degToRad(degree: number): number { return degree * (Math.PI / 180); }\r\n\r\n\r\n\r\n    private static GeomTolerance = 0; // 0.001;\r\n    static isOnEdge(pt: GraphPoint, shape: GraphSize, tolerance: number = Geom.GeomTolerance): boolean {\r\n        return Geom.isOnHorizontalEdges(pt, shape, tolerance) || Geom.isOnVerticalEdges(pt, shape, tolerance); }\r\n\r\n    static isOnVerticalEdges(pt: GraphPoint, shape: GraphSize, tolerance: number = Geom.GeomTolerance): boolean {\r\n        return Geom.isOnLeftEdge(pt, shape, tolerance) || Geom.isOnRightEdge(pt, shape, tolerance); }\r\n\r\n    static isOnHorizontalEdges(pt: GraphPoint, shape: GraphSize, tolerance: number = Geom.GeomTolerance): boolean {\r\n        return Geom.isOnTopEdge(pt, shape, tolerance) || Geom.isOnBottomEdge(pt, shape, tolerance); }\r\n\r\n    static isOnRightEdge(pt: GraphPoint, shape: GraphSize, tolerance: number = Geom.GeomTolerance): boolean {\r\n        if (!pt || !shape) { return false; }\r\n        if (tolerance) return Math.abs(pt.x - (shape.x + shape.w)) < tolerance\r\n            && ( pt.y - shape.y > tolerance && pt.y - (shape.y + shape.h) < tolerance);\r\n        return (pt.x === shape.x + shape.w) && (pt.y >= shape.y && pt.y <= shape.y + shape.h);\r\n    }\r\n\r\n    static isOnLeftEdge(pt: GraphPoint, shape: GraphSize, tolerance: number = Geom.GeomTolerance): boolean {\r\n        if (!pt || !shape) { return false; }\r\n        if (tolerance) return Math.abs(pt.x - shape.x) < tolerance\r\n            && (pt.y - shape.y > tolerance && pt.y - (shape.y + shape.h) < tolerance);\r\n        return (pt.x === shape.x) && (pt.y >= shape.y && pt.y <= shape.y + shape.h);\r\n    }\r\n\r\n    static isOnTopEdge(pt: GraphPoint, shape: GraphSize, tolerance: number = Geom.GeomTolerance): boolean {\r\n        if (!pt || !shape) { return false; }\r\n        if (tolerance) return Math.abs(pt.y - shape.y) < tolerance\r\n            && (pt.x - shape.x > tolerance && pt.x - (shape.x + shape.w) < tolerance);\r\n        return (pt.y === shape.y) && (pt.x >= shape.x && pt.x <= shape.x + shape.w);\r\n    }\r\n\r\n    static isOnBottomEdge(pt: GraphPoint, shape: GraphSize, tolerance?: number): boolean {\r\n        if (!pt || !shape) { return false; }\r\n        if (tolerance) return Math.abs(pt.y - shape.y + shape.h) < tolerance\r\n            && (pt.x - shape.x > tolerance && pt.x - (shape.x + shape.w) < tolerance);\r\n        return (pt.y === shape.y + shape.h) && (pt.x >= shape.x && pt.x <= shape.x + shape.w);\r\n    }\r\n\r\n    static closestPoint(size: GraphSize, pt: GraphPoint): GraphPoint {\r\n        let top_closest = Geom.closestPointToSegment(size.tl(), size.tr(), pt);\r\n        let bot_closest = Geom.closestPointToSegment(size.bl(), size.br(), pt);\r\n        let left_closest = Geom.closestPointToSegment(size.tl(), size.bl(), pt);\r\n        let right_closest = Geom.closestPointToSegment(size.tr(), size.br(), pt);\r\n\r\n        let top_distance = top_closest.distanceFromPoint(pt, false);\r\n        let bot_distance = bot_closest.distanceFromPoint(pt, false);\r\n        let left_distance = left_closest.distanceFromPoint(pt, false);\r\n        let right_distance = right_closest.distanceFromPoint(pt, false);\r\n\r\n        let min_distance = Math.min(top_distance, bot_distance, left_distance, right_distance);\r\n        if (min_distance === top_distance) return top_closest;\r\n        if (min_distance === bot_distance) return bot_closest;\r\n        if (min_distance === left_distance) return left_closest;\r\n        return right_closest;\r\n    }\r\n    static isMinusZero(number: number) {return 1/number == -Infinity;}\r\n    static closestPointToSegment(segStart: GraphPoint, segEnd:GraphPoint, pt: GraphPoint): GraphPoint{\r\n        // 1) find equation of line passing for start, end.\r\n        // 2) then find all perpendicular lines, then the perpendicular line that pass through pt\r\n        // 3) find intersection between Line(s,e) and line of point 2.\r\n        // 4A) IF intersection is part of segment(s,e) that is closest.\r\n        // 4B) ELSE, one of the 2 extremes of the segment is closest.\r\n\r\n        let x_intersect: number, y_intersect: number;\r\n        let s = segStart;\r\n        let e = segEnd;\r\n        let mse = (e.y - s.y) / (e.x - s.x);\r\n        if (mse === Number.POSITIVE_INFINITY || mse === Number.NEGATIVE_INFINITY) {\r\n            // s and e are both on the same y vertical line (same x)      // new GraphPoint(segStart.x, pt.y);\r\n            x_intersect = segStart.x;\r\n            y_intersect = pt.y;\r\n            // 1), 2), 3) all done shortcut\r\n        } else if (mse === 0 || Geom.isNegativeZero(mse)) {\r\n            // s and e are both on the same x horizontal line (same y)    // new GraphPoint(pt.x, segStart.y);\r\n            x_intersect = pt.x;\r\n            y_intersect = segStart.y\r\n            // 1), 2), 3) all done shortcut\r\n        }\r\n        else {\r\n            let q = s.y - mse*s.x; // y = mx + q           q = y-mx\r\n            // 1) done\r\n            let pmse = -1/mse; // perpendicular to mse\r\n            let pq = pt.y - pmse*pt.x;\r\n            // 2) done\r\n            //  m1 * x + q1 = y    -->   m1 * x + q1 = m2 * x + q2    -->    (m1-m2)x = q2-q1      -->     x=(q2-q1)/(m1-m2)\r\n            x_intersect = (pq-q)/(mse-pmse);\r\n            y_intersect = mse*(x_intersect) + q; //  y = mx +q\r\n            // 3) done\r\n        }\r\n\r\n        let maxX: number, minX: number;\r\n        let maxY: number, minY: number;\r\n        if (s.x > e.x) { maxX = s.x; minX = e.x; } else {  maxX = e.x; minX = s.x; }\r\n        if (s.y > e.y) { maxY = s.y; minY = e.y; } else {  maxY = e.y; minY = s.y; }\r\n        if (x_intersect >= minX && x_intersect <= maxX && y_intersect >= minY && y_intersect <= maxY) return new GraphPoint(x_intersect, y_intersect);\r\n        // 4A) IF done\r\n\r\n        let sdist = (s.x - x_intersect)**2 + (s.y - y_intersect)**2;  // actual distance is sqrt() of this, but i just need to find closest, not correct distance.\r\n        let edist = (e.x - x_intersect)**2 + (e.y - y_intersect)**2;\r\n        return (sdist < edist) ? new GraphPoint(s.x, s.y) : new GraphPoint(e.x, e.y);\r\n        // 4B) ELSE done\r\n    }\r\n\r\n    // @param: lineX = only required if m === (+-)infinite, is the X coord where the vertical line lies.\r\n    static lineToSegmentIntersection(segStart: GraphPoint, segEnd: GraphPoint, q: number, m: number, lineX?: number): GraphPoint | undefined {\r\n        let lineIsVertical = m === Number.POSITIVE_INFINITY || m === Number.NEGATIVE_INFINITY;\r\n        let lineIsHorizontal = +m === 0; // unary plus operator is required because: +(-0)  === 0, but not sure if -0 === 0\r\n        let isNaNm = isNaN(m);\r\n        let isNaNq = isNaN(q);\r\n        Log.eDev(isNaNm && isNaNq || isNaNm && !isNaNq, 'Error in Geom lineSegmentIntersection, m and q are not coherent', {m, q});\r\n        Log.w((isNaNm || isNaNq) && lineX === undefined, 'Error in Geom lineSegmentIntersection, m is infinite and no points were provided', {m, q});\r\n        if (segStart.x === segEnd.x){ // vertical segment |\r\n            if (lineIsVertical) {\r\n                if (lineX !== undefined && lineX === segStart.x) return new GraphPoint(lineX, (segStart.y + segEnd.y)/2); // complete overlap of segment and line, i take middle\r\n                return undefined; // parallel vertical segment-line\r\n            } else { // vertical segment, skewed or horizontal line\r\n                let y = m*segStart.x + q;\r\n                if (Geom.isNumberBetween(y, segStart.y, segEnd.y)) return new GraphPoint(segStart.x, y);\r\n                else return undefined;\r\n            }\r\n        }\r\n        else if (segStart.y === segEnd.y) { // horizontal segment -------------------\r\n            if (lineIsVertical) {\r\n                if (lineX !== undefined && Geom.isNumberBetween(lineX, segStart.x, segEnd.x)) return new GraphPoint(lineX, segStart.y); // perpendicular and intersecating\r\n                return undefined; // perpendicular but outside segment width\r\n            }\r\n            else if (lineIsHorizontal) { // horizontal line\r\n                if (Geom.isNumberBetween(q, segStart.y, segEnd.y)) return new GraphPoint((segStart.x + segEnd.x), q); // complete overlap of segment and line, i take middle\r\n                return undefined; // parallel horizontal line-segment\r\n            } else {\r\n                let x = (segStart.y-q)/m;\r\n                if (Geom.isNumberBetween(x, segStart.x, segEnd.x)) return new GraphPoint(x, segStart.y);\r\n                else return undefined;\r\n            }\r\n        }\r\n\r\n        let m2 = segStart.getM(segEnd);\r\n        let q2 = IPoint.getQ(segStart, segEnd);\r\n        // NB: at this point m2 cannot be infinite | -infinite, but can be -0, m can be anything\r\n        if (+m === +m2) {\r\n            if (+q === +q2) return segStart; // line and segment coincident\r\n            return undefined; // parallel\r\n        }\r\n        let intersect: GraphPoint | undefined;\r\n        if (U.isInfinite(m)) {\r\n            if (lineX !== undefined) intersect = new GraphPoint(lineX, m2*lineX + q2);\r\n            return undefined;\r\n        } else {\r\n            intersect = Geom.lineToLineIntersection(m, q, m2, q2, undefined);\r\n        }\r\n        if (intersect && Geom.isNumberBetween(intersect.x, segStart.x, segEnd.x) && Geom.isNumberBetween(intersect.y, segStart.y, segEnd.y)) return intersect;\r\n        else return undefined;\r\n    }\r\n\r\n    static isNumberBetween(target: number, s: number, e: number): boolean {\r\n        let max = Math.max(s, e);\r\n        let min = Math.min(s, e);\r\n        return target >= min && target <= max; }\r\n\r\n\r\n    // NB invalid if any of the lines are verytical, in which case need to take the X of the vertical line (xVertical) and intersection is: new Point(xVertical, m_otherLine * xVertical + q_otherLine)\r\n    private static lineToLineIntersection(m: number, q: number, m2: number, q2: number, retIfInvalid: any, retIfParallel: any = undefined, retIfCoincident: any = undefined): undefined | GraphPoint {\r\n\r\n        if (+m === +m2 || U.isInfinite(m) && U.isInfinite(m2)) {\r\n            if (+q === +q2 || U.isInfinite(q) && U.isInfinite(q2)) return retIfCoincident; // line and segment coincident\r\n            return retIfParallel; // parallel\r\n        }\r\n\r\n        if (m === Number.POSITIVE_INFINITY || m === Number.NEGATIVE_INFINITY || m2 === Number.POSITIVE_INFINITY || m2 === Number.NEGATIVE_INFINITY) {\r\n            // m or m2 are a vertical line, Q must be invalid too and i don't have a single point of the line.\r\n            // it's actually infinite possible vertical parallel lines.\r\n            return retIfInvalid;\r\n        }\r\n        /*\r\n            y = mx + q\r\n            y = nx + w\r\n            -->\r\n            mx + q = nx + w\r\n            -->\r\n            mx - nx = w - q\r\n            -->\r\n            x (m - n) = w - q\r\n            -->\r\n            x = (w - q)/(m - n)\r\n        */\r\n        let x = (q2-q)/(m-m2);\r\n        return new GraphPoint(x, m*x+q); }\r\n    // @param start, end: are for determining direction. every m is a line that can be seen in 2 direction\r\n    static mToRad(m: number, start: GraphPoint, end: GraphPoint): number {\r\n        let rad: number;\r\n        if (start.x === end.x) {\r\n            rad = (start.y < end.y) ? Math.PI * 3/2 :  Math.PI / 2;\r\n        } else {\r\n            // console.log(\"rad diagonal\", {base:  Math.atan(m), add: start.x > end.x, sx: start.x, ex: end.x});\r\n            rad = Math.atan(m) + (start.x > end.x ? 0 : Math.PI);\r\n        }\r\n        return rad; }\r\n\r\n    // intersect a rectangle with a line or segment (if end parameter is specified)\r\n    // @return: [0, 2] intersections\r\n    static lineToSizeIntersection_TODO(size: GraphSize, m: number, startLine: GraphPoint, endIfSegment?: GraphPoint): [] | [GraphPoint] | [GraphPoint, GraphPoint] {\r\n         // todo: use GraphSize.closestIntersection which is close. it is size-segment returning only the closest intersection\r\n        return [];\r\n    }\r\n}\r\n\r\nRuntimeAccessibleClass.set_extend(RuntimeAccessibleClass, Geom);\r\n","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\common\\Uhtml.ts",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\api\\data.ts",["809","810","811","812"],"import type {\r\n    Json,\r\n    Pointer,\r\n    GObject,\r\n    Dictionary,\r\n    DocString} from \"../joiner\";\r\nimport {\r\n    Log,\r\n    DModelElement,\r\n    DModel,\r\n    LModel,\r\n    DValue,\r\n    LValue,\r\n    DObject,\r\n    LObject,\r\n    DEnumerator,\r\n    DEnumLiteral,\r\n    DAttribute,\r\n    LAttribute,\r\n    DReference,\r\n    LReference,\r\n    DClassifier,\r\n    DClass,\r\n    LClass,\r\n    DParameter,\r\n    DOperation,\r\n    DPackage,\r\n    LPackage,\r\n    DTypedElement,\r\n    LTypedElement,\r\n    DAnnotation,\r\n    AttribETypes,\r\n    U,\r\n    CreateElementAction,\r\n    Selectors,\r\n    PointedBy,\r\n    LPointerTargetable,\r\n    windoww,\r\n    SetRootFieldAction,\r\n    Constructors,\r\n    store,\r\n    SetFieldAction,\r\n    DPointerTargetable, ShortAttribETypes, toLongEType, DState, Debug\r\n} from \"../joiner\";\r\nimport {DefaultEClasses, ShortDefaultEClasses, toLongEClass} from \"../common/U\";\r\n\r\ntype RET<T = boolean> = T | Promise<T>;\r\ntype Ret = RET;\r\n\r\nclass SavePack{\r\n    model: string;\r\n    vertexpos: string;\r\n    view: string;\r\n    constructor(model: string='', vertexpos: string='', view:string='') {\r\n        this.model = model;\r\n        this.vertexpos = vertexpos;\r\n        this.view = view;\r\n    }\r\n}\r\n\r\ntype JsonSavePack = {[key in keyof SavePack]: Json | null }\r\n\r\n\r\nexport abstract class IStorage{\r\n    static get():IStorage { return Log.exx(\"IStorage.get (static) should be overridden\"); }\r\n    public prefix: string;\r\n    public autosave: boolean;\r\n    constructor(prefix: string, autosave: boolean) {\r\n        this.prefix = prefix;\r\n        this.autosave = autosave;\r\n    }\r\n\r\n\r\n    public del(key: string | number): boolean{\r\n        let isOverwrite = this.get(key) !== null;\r\n        this.set(key, '');\r\n        return isOverwrite; }\r\n    public abstract set(key: string | number, val: string | any): RET;\r\n    get<T extends boolean>(key: string | number, parse: T = false as any): T extends false ? null | string : null | any{ return Log.exx(\"IStorage.get should be overridden\"); }\r\n\r\n    protected serialize(val: any): string { // serialize\r\n        try { return JSON.stringify(val); } catch(e){ return \"\"+val; }\r\n    }\r\n    protected deserialize(val: string): any{ // de-serialize\r\n        try { return JSON.parse(val); } catch(e){ return val; }\r\n    }\r\n    protected set0(val: any): string { return this.serialize(val); }\r\n    protected get0(val: any): string { return this.deserialize(val); }\r\n    protected parse(val: any): string { return this.deserialize(val); }\r\n}\r\n\r\nexport class LocalStorage extends IStorage{\r\n    public static get():LocalStorage {return new LocalStorage(\"_j\", true); }\r\n    private constructor (prefix: string, autosave: boolean) { super(prefix, autosave); }\r\n\r\n    private static KeyList= {lastOpenedModel: \"lastOpenedModel\",lastOpenedView: \"lastOpenedView\",lastOpenedPosition: \"lastOpenedPosition\",}\r\n\r\n\r\n    get<T extends boolean>(key: string | number, parse: T = false as any): T extends false ? null | string : null | any{\r\n        let val = localStorage.getItem(this.prefix+key);\r\n        return parse ? this.parse(val) : val;\r\n    }\r\n\r\n    set(key?: string | number, val?: string | any): boolean {\r\n        val = this.serialize(val);\r\n        // let isOverwrite = localStorage.getItem(this.prefix+key);\r\n        localStorage.set(this.prefix+key, val);\r\n        return true;\r\n    }\r\n\r\n\r\n    public getLastOpened(modelNumber: 1 | 2): SavePack {\r\n        let modelname = \"m\" + modelNumber + \"_\";\r\n        const ret: SavePack = new SavePack();\r\n        ret.model = this.get(modelname + LocalStorage.KeyList.lastOpenedModel, false) || '';\r\n        ret.view = this.get(modelNumber + LocalStorage.KeyList.lastOpenedView, false) || '';\r\n        ret.vertexpos = this.get(modelNumber + LocalStorage.KeyList.lastOpenedPosition, false) || '';\r\n        return ret; }\r\n\r\n    public deleteLastOpened(modelNumber: 1 | 2): void { this.setLastOpened(modelNumber, '', '', ''); }\r\n\r\n    public setLastOpened(modelNumber: 1 | 2, model: string = '', view: string = '', vertex: string = ''): void {\r\n        let modelname = \"m\" + modelNumber + \"_\";\r\n        if (model) this.set(modelname + LocalStorage.KeyList.lastOpenedModel, model);\r\n        else this.del(modelname +  LocalStorage.KeyList.lastOpenedModel);\r\n        if (view) this.set(modelname + LocalStorage.KeyList.lastOpenedView, view);\r\n        else this.del(modelname +  LocalStorage.KeyList.lastOpenedView);\r\n        if (vertex) this.set(modelname + LocalStorage.KeyList.lastOpenedPosition, vertex);\r\n        else this.del(modelname +  LocalStorage.KeyList.lastOpenedPosition); }\r\n\r\n\r\n}\r\n\r\nexport class EcoreParser{\r\n    static supportedEcoreVersions = [\"http://www.eclipse.org/emf/2002/Ecore\"];\r\n    static prefix:string = '@';\r\n\r\n    static parse(ecorejson: GObject | string | null, isMetamodel: boolean, filename: string | undefined, persist: boolean = true): DModelElement[]{\r\n        if (!ecorejson) return [];\r\n        let parsedjson: GObject;\r\n        if (typeof ecorejson === \"string\") try { parsedjson = JSON.parse(ecorejson); } catch(e) { windoww.temp = ecorejson; Log.exx(\"error while parsing json:\", e, ecorejson.substring(0, 1000)); throw e; }\r\n        else parsedjson = ecorejson;\r\n        console.log(\"root parse\", {ecorejson, parsedjson});\r\n        // isMetamodel = !!parsedjson[ECoreRoot.ecoreEPackage];\r\n\r\n        Constructors.paused = true;\r\n        let parsedElements: DModelElement[] = isMetamodel ? EcoreParser.parseM2Model(parsedjson, filename) : EcoreParser.parseM1Model(parsedjson, undefined, filename);\r\n        console.warn(\"parse.result D\", parsedElements);\r\n        this.LinkAllNamesToIDs(parsedElements);\r\n        this.fixNamingConflicts(parsedElements);\r\n        Constructors.paused = false;\r\n        // if (persist) CreateElementAction.newBatch(parsedElements);\r\n        // update m1 object pointers (need them to be persistent to navigate .fathers and get ecore pointer strings using LObject)\r\n        this.fixObjectPointers(parsedElements); // updates dvalue.values from ecore reference to pointers.\r\n        Constructors.persist(parsedElements);\r\n\r\n        windoww.tmpparse = () => LPointerTargetable.wrapAll(parsedElements);\r\n\r\n        this.tempfix_untilopennewtabisdone(parsedElements, isMetamodel);\r\n\r\n        console.log('parsedElem', parsedElements)\r\n        return parsedElements;\r\n    }\r\n\r\n    private static fixObjectPointers(parsedElements: DModelElement[]): void {\r\n        let dobjects: DObject[] = parsedElements.filter(e=>e.className === DObject.cname) as any[];\r\n        let values: DValue[] = parsedElements.filter(e=>e.className === DValue.cname) as any[];\r\n        let lobjects: LObject[] = LPointerTargetable.fromArr(dobjects);\r\n        let m1pointermap: Dictionary<string, LObject> = { }; //    \"//@rootrefname.index@/refname.index/@....etc\"\r\n        for (let o of lobjects){ m1pointermap[o.ecorePointer()] = o; }\r\n        for (let v of values) {\r\n            if (v.isMirage) continue;\r\n            let modified = false;\r\n            let newvalues = v.values.map((e) => {\r\n                if (!m1pointermap[e as any]) return e;\r\n                modified = true;\r\n                console.log(\"m1 pointer resolved:\", {from:e, to:m1pointermap[e as any].id});\r\n                return m1pointermap[e as any].id;\r\n            });\r\n            if (!modified) continue;\r\n            //let lv: LValue = LPointerTargetable.from(v);\r\n            v.values = newvalues;\r\n        }\r\n\r\n    }\r\n    private static tempfix_untilopennewtabisdone(parsedElements: DModelElement[], isMetamodel: boolean) {\r\n        // replaces current model with parsed model. this needs to be removed to open a new tab later on.\r\n        let model: DModel = null as any;\r\n        for (let elem of parsedElements) { if (elem.className === DModel.cname) { model = elem as any; break; } }\r\n        SetRootFieldAction.new(isMetamodel ? \"m2models\" : \"m1models\", model.id, '+=', false); // it is pointer but no need to update pointedby's this time\r\n    }\r\n\r\n    // resolve eCore pointers to Jodel pointers and set the PointedBy\r\n    private static LinkAllNamesToIDs(parsedElements: DModelElement[]): void {\r\n        // todo: è post-parse che legga i nomi e assegni gli id aggiustando le references e extends settati by name. trova i campi temporanei cercando i @ts-ignore\r\n        // update mref, attribute, parameter type\r\n        // update operation exception\r\n        // replace those names with id's\r\n\r\n        let idMap: Dictionary<Pointer, DModelElement> = {};\r\n        let nameMap: Dictionary<string, DModelElement> = {};\r\n        let replacePrimitiveMap: Dictionary<string, DClassifier> = {};\r\n        let d_Estring: DClassifier = Selectors.getAllPrimitiveTypes()[1];\r\n        replacePrimitiveMap[AttribETypes.EString] = d_Estring;\r\n        // todo: do the same for all other primitives\r\n        let state: DState = store.getState();\r\n\r\n        // let longprefixlength = 'ecore:EDataType http://www.eclipse.org/emf/2002/Ecore'.length;\r\n        const typeprefix = \"#//\";\r\n        for (let shortkey in ShortAttribETypes) {\r\n            if (shortkey === ShortAttribETypes.EVoid) continue;\r\n            let shortetype: ShortAttribETypes = (ShortAttribETypes as GObject)[shortkey];\r\n            let longetype: AttribETypes = toLongEType(shortetype);\r\n            let dClassType: DClassifier = Selectors.getPrimitiveType(shortetype, state);\r\n            Log.exDev(!dClassType, \"missing primitive type: \" + shortkey, {shortkey, shortetype, longetype, dClassType, state});\r\n            // the correct one\r\n            replacePrimitiveMap[typeprefix + shortkey] = dClassType; // like \"#//EChar\"\r\n            // fallbacks for missing type instead of crash\r\n            if (!replacePrimitiveMap[shortkey]) replacePrimitiveMap[shortkey] = dClassType;\r\n            if (!replacePrimitiveMap[shortetype]) replacePrimitiveMap[shortetype] = dClassType;\r\n            if (!replacePrimitiveMap[longetype]) replacePrimitiveMap[longetype] = dClassType;\r\n        }\r\n        for (let shortkey in ShortDefaultEClasses) {\r\n            let shortetype: ShortDefaultEClasses = (ShortDefaultEClasses as GObject)[shortkey];\r\n            let longetype: DefaultEClasses = toLongEClass(shortetype);\r\n            let dClassType: DClassifier = Selectors.getDefaultEcoreClass(shortetype, state);\r\n            Log.exDev(!dClassType, \"missing ecore native class: \" + shortkey, {shortkey, shortetype, longetype, dClassType, state});\r\n\r\n            // the correct one\r\n            replacePrimitiveMap[longetype] = dClassType;\r\n            // fallbacks for missing type instead of crash\r\n            if (!replacePrimitiveMap[shortkey]) replacePrimitiveMap[shortkey] = dClassType;\r\n            if (!replacePrimitiveMap[shortetype]) replacePrimitiveMap[shortetype] = dClassType;\r\n            if (!replacePrimitiveMap[longetype]) replacePrimitiveMap[typeprefix + shortkey] = dClassType; // like \"#//EObject\"\r\n        }\r\n\r\n\r\n        for (let ecorename in replacePrimitiveMap) {\r\n            // duplicates are very likely becuase of fallback alias like \"EChar\", but they shouldn't override user-defined class EChar if it exist, so don't throw error.\r\n            if (idMap[replacePrimitiveMap[ecorename].id]) continue;\r\n            idMap[replacePrimitiveMap[ecorename].id] = replacePrimitiveMap[ecorename];\r\n        }\r\n\r\n        // let prereplace = (name: string) => name.replaceAll(\"#//\", \"\");\r\n        let replaceRules = [\"extends\", /*\"extendedBy\",*/ \"exceptions\", \"type\", \"values\"];\r\n        let dobj: GObject & DModelElement;\r\n\r\n        for (dobj of parsedElements) {\r\n            idMap[dobj.id] = dobj;\r\n            if (!dobj.name || dobj.className === DModel.cname) continue; // Model name can be reused internally\r\n            let name = (dobj as GObject).__fullname;\r\n            delete (dobj as GObject).__fullname;\r\n            if (dobj.className === DOperation.cname || dobj.className === DParameter.cname) {\r\n                // operation overload, in this case i create N separate operations, but all references will point to the last operation.\r\n                // empty on purpose, just avoid naming check\r\n            }\r\n                // todo: problem, uml.ecore have \"isComposite\" operation and attribute on sme class \"property\", so who is referenced by \"#//property/isComposite\" ??\r\n            // else Log.exDev(nameMap[typeprefix + name], \"found 2 elements with same name\", {nameMap, dobj, name, shortname: dobj.name, typeprefix});\r\n            else Log.w(!!nameMap[typeprefix + name], \"found 2 elements with same name\", {nameMap, new:dobj, old:nameMap[typeprefix + name], name, shortname: dobj.name, typeprefix});\r\n            nameMap[typeprefix + name] = dobj;\r\n            // nameMap[typeprefix + dobj.name] = dobj; // <eAnnotations source=\"subsets\" references=\"#//Activity/group\"/>\r\n        }\r\n\r\n        for (let replacekey of replaceRules){\r\n            for (dobj of parsedElements) {\r\n                let valtmp: string | string[] = dobj[replacekey] as string | string[];\r\n                if (valtmp === undefined) continue; // for missing properties in a d-object like looking for extends on a dmodel.\r\n                let values: string[]\r\n                let isArray = Array.isArray(valtmp);\r\n                if (isArray) {\r\n                    values = valtmp as string[];\r\n                    dobj[replacekey] = [];\r\n                }\r\n                else {\r\n                    values = [valtmp as string];\r\n                }\r\n                for (let value of values) {\r\n                    if (!value) continue;\r\n                    // console.log(\"fixalltypes\", {replacekey, dobj, value, values});\r\n                    let target: DModelElement = replacePrimitiveMap[value];\r\n                    if (!target) target = nameMap[value];\r\n                    if (!target && value.indexOf(\"ecore:EDataType\") === 0) {\r\n                        Log.ww('found unknown EDataType \"' + value + '\", remapping it to string');\r\n                        target = replacePrimitiveMap[AttribETypes.EString];\r\n                    }\r\n                    /*\r\n                    if (!target && value === \"ecore:EClass platform:/plugin/org.eclipse.emf.ecore/model/Ecore.ecore#//EObject\"){\r\n                        Log.ww('found type Object is not supported yet in metamodel, remapped to EString');\r\n                        target = replacePrimitiveMap[AttribETypes.EString];\r\n                    }*/\r\n                    // if (Pointers.isPointer(value)) { target = value;  if it happen to be a pointer it's a mistake in parser }\r\n                    // (value.indexOf(\"#//\") == 0) && console.log(\"attempt to replace primitive type to his id\", {target, dobj, replacekey, value, replacePrimitiveMap, nameMap, idMap, parsedElements});\r\n\r\n                    if (replacekey === \"extends\") {\r\n                        if (!target) continue;\r\n                        Log.ex(target.className !== DClass.cname, \"found a class attempting to extend an object that is not a class\", {target, dobj, replacePrimitiveMap, nameMap, idMap});\r\n                        (target as DClass).extendedBy.push((dobj as DClass).id);\r\n                    }\r\n                    Log.ex(!target, \"LinkAllNames() can't find type target:\", {value, nameMap, replacePrimitiveMap, dobj, replacekey});\r\n                    if (isArray) dobj[replacekey].push(target.id);\r\n                    else dobj[replacekey] = target.id;\r\n                }\r\n            }\r\n        }\r\n\r\n        // fix from ordinals to Pointer<DEnumLiteral>\r\n        function DfromPtr<T extends DPointerTargetable>(id: Pointer<T>|null|undefined): T{ return !id ? undefined as any : (DPointerTargetable.fromPointer(id, state)); }\r\n        function getLiteral(id: Pointer<DEnumerator>, ordinal: number): DEnumLiteral { return LPointerTargetable.fromD(DfromPtr(id))?.ordinals[ordinal]?.__raw; }\r\n        for (let elem of parsedElements) {\r\n            if (elem.className !== DValue.cname) continue;\r\n            let dval: DValue = elem as DValue;\r\n            let meta: DAttribute | DReference = DfromPtr(dval.instanceof as Pointer<DAttribute|DReference>);\r\n            if (!meta) continue;\r\n            let type: DEnumerator = DfromPtr(meta.type) as DEnumerator;\r\n            if (!type || type.className !== DEnumLiteral.cname) continue;\r\n            let mapper = (v: unknown): Pointer<DEnumLiteral> => {\r\n                if (typeof v !== \"number\") { Log.ee(\"found non-numeric value in a literal value.\", v, dval); return v as any; }\r\n                let l = getLiteral(type.id, v);\r\n                return l ? l.id : v as any;\r\n            }\r\n            dval.values = dval.values.map( mapper );\r\n        }\r\n\r\n        // finally: set all pointedby\r\n        for (let ptrkey of PointedBy.list) for(dobj of parsedElements) {\r\n            let valtmp: string | string[] = dobj[ptrkey] as string | string[];\r\n            let values: string[];\r\n            if (Array.isArray(valtmp)) {\r\n                values = valtmp as string[];\r\n            }\r\n            else {\r\n                if (valtmp === undefined) values = [];\r\n                // if (valtmp === \"modeltmp\") { dobj[ptrkey] = null; values = []; } // because model.father is null, but i want to error check others and let them crash if missing father\r\n                else values = [valtmp as string];\r\n            }\r\n            for (let value of values) {\r\n                if (!value) continue;\r\n                // errore: per operazione.type l'import mi restituisce puntatore a oggetto stringa, ma non è tra gli oggetti parsed\r\n                let target: DModelElement = idMap[value];\r\n                if (target) {\r\n                    target.pointedBy.push(PointedBy.new(\"idlookup.\" + dobj.id + \".\" + ptrkey));\r\n                } else {\r\n                    target = DfromPtr(value);\r\n                    console.log(\"fixalltypes\", {ptrkey, valtmp, dobj, value, values, target, idMap});\r\n                    if (!target) throw new Error(\"target undefined\");\r\n                    SetFieldAction.new(target, \"pointedBy\", PointedBy.new(\"idlookup.\" + dobj.id + \".\" + ptrkey),'+=', false);\r\n                }\r\n            }\r\n        }\r\n        // update superclasses\r\n        this.updateSuperClasses(parsedElements);\r\n    }\r\n\r\n    private static todoGetPrimitiveTypenope(type: AttribETypes.EString | string): Pointer<DClass, 1, 1, LClass> {\r\n        // akready fixed in LinkAllNamesToID\r\n        return 'todoGetPrimitiveType from parser';\r\n    }\r\n\r\n    private static updateSuperClasses(parsedElements: DModelElement[]): void {\r\n        // todo:3\r\n\r\n    }\r\n    private static fixNamingConflicts(parsedElements: DModelElement[]): void {\r\n        // todo:4 final\r\n    }\r\n\r\n    static parseM2Model(json: Json, filename: string | undefined): DModelElement[] {\r\n        let generated: DModelElement[] = [];\r\n        if (!json) { json = {}; }\r\n        let modelname = json[ECoreNamed.namee] as string;\r\n        if (!modelname && filename) {\r\n            let pos = filename.indexOf(\".\");\r\n            modelname = pos === -1 ? filename : filename.substring(0, pos); }\r\n        let dObject: DModel = DModel.new( modelname || \"imported_metamodel_1\", undefined, true, true);\r\n        console.log(\"made model\", json);\r\n        generated.push(dObject); // dObject.father = 'modeltmp' as any;\r\n        // const annotations: Json[] = this.getAnnotations(json); i set them on root package\r\n        // for (let child of annotations) EcoreParser.parseDAnnotation(dObject, child, generated, (dObject as GObject).__fullname + \"/\");\r\n        /// *** specific  *** ///\r\n        // let defPackage: DPackage = DPackage.new(json)\r\n        EcoreParser.parseRootPackage(dObject, json, generated);\r\n        return generated;\r\n    }\r\n\r\n    static parseM2Model_old(json: Json, filename: string | undefined): DModelElement[] {\r\n        let generated: DModelElement[] = [];\r\n        if (!json) { json = {}; }\r\n        let modelname = json[ECoreNamed.namee] as string;\r\n        if (!modelname && filename) {\r\n            let pos = filename.indexOf(\".\");\r\n            modelname = pos === -1 ? filename : filename.substring(0, pos); }\r\n        let dObject: DModel = DModel.new( modelname || \"imported_metamodel_1\", undefined, true, true);\r\n        console.log(\"made model\", json);\r\n        generated.push(dObject); // dObject.father = 'modeltmp' as any;\r\n        /// *** specific  *** ///\r\n        const children = EcoreParser.getChildren(json);\r\n        const annotations = EcoreParser.getAnnotations(json);\r\n        // dObject.name = json[ECoreNamed.namee] as string || \"imported_metamodel_1\";\r\n        console.log(\"made model 2\", children, annotations);\r\n        for (let child of annotations) {\r\n            EcoreParser.parseDAnnotation(dObject, child, generated, 'aaaaaaaaaaaaaaaaaaaaaaaaaaaa');\r\n        }\r\n        console.log(\"made annotations\");\r\n        for (let child of children) {\r\n            EcoreParser.parseRootPackage(dObject, child, generated);\r\n        }\r\n        console.log(\"made packages\");\r\n        return generated;\r\n    }\r\n\r\n    static parseM1Model(json: Json, meta?: LModel, filename?: string): DModelElement[] {\r\n        let generated: DModelElement[] = [];\r\n        if (!json) { json = {}; }\r\n        /// *** specific  *** ///\r\n        // this.parseDObject(json, dObject, DModel,undefined, generated);\r\n        let allmodels: DModel[];\r\n        if (!meta && filename) {\r\n            allmodels = Selectors.getAll(DModel);\r\n            allmodels = allmodels.filter( (m) => m.name === filename);\r\n            meta = LPointerTargetable.fromD(allmodels[0]);\r\n        } else allmodels = [];\r\n\r\n        let xmlns =  EcoreParser.XMLinlineMarker + \"xmlns:\";\r\n        let ns: string | undefined = undefined as any;\r\n        function findns(key: string): false | string {\r\n            let pos = key.indexOf(\":\");\r\n            if (pos <= 0) return false;\r\n            return ns = key.substring(0, pos); // through namespace before the name of the root objects;\r\n            // additional method: through xmlns key\r\n            // if (key.indexOf(xmlns)) continue; // \"-xmlns:org.eclipse.example.modelname\": \"https://org/eclipse/example/modelname\",\r\n            // ns = key.substring(xmlns.length); break;\r\n        }\r\n        outerloop: for (let key0 in json) { // ns can be at most in sublevel 3, this is annoying but i need it at beginning of parsing\r\n            if (findns(key0)) break;\r\n            let val0 = json[key0];\r\n            if (typeof val0 === \"object\") for (let key1 in val0) {\r\n                if (findns(key0)) break outerloop;\r\n            }\r\n        }\r\n        if (ns && !meta) {\r\n            let allpkgs: LPackage[] = Selectors.getAll(DPackage, undefined, undefined, true, true);\r\n            let matchpkg: LPackage[] = allpkgs.filter( (d) => d.uri === ns);\r\n            meta = matchpkg[0]?.model;\r\n            // Log.exDev(!meta, \"metamodel not found: \", {ns, json, filename, allmodels, allpkgs, matchpkg}) // todo: after tests remove this check and allow shapeless models.\r\n        }\r\n\r\n        let modelname = '';\r\n        if (!modelname && filename) {\r\n            let pos = filename.indexOf(\".\");\r\n            modelname = (pos === -1 ? filename : filename.substring(0, pos)); }\r\n        let dObject: DModel = DModel.new( modelname || \"imported_model_1\", meta?.id, false, true);\r\n        console.log(\"made model\", json);\r\n        generated.push(dObject);\r\n\r\n        for (let key in json) {\r\n            switch(key) {\r\n                case ECoreObject.xmi_version: // this is only on roots\r\n                    Log.ex(json[key] !== \"2.0\",\"The only supported ecore version is \\\"2.0\\\", found instead: \\\"\"+json[key] +\"\\\"\");\r\n                    break;\r\n                // case ECoreObject.xmlnsecore:\r\n                case ECoreObject.xmlns_xmi:\r\n                    let expected = \"http://www.omg.org/XMI\";\r\n                    Log.ex(json[key] !== expected,\"Unexpected XMI schema. Should be \\\"\"+expected+\"\\\", found instead: \\\"\"+json[key] +\"\\\"\");\r\n                    break;\r\n                default: // a feature name\r\n                    let val = json[key];\r\n                    if (!val) continue;\r\n                    if (key.indexOf(xmlns) === 0) continue; // \"-xmlns:org.eclipse.example.modelname\": \"https://org/eclipse/example/modelname\",\r\n                    if (key[0] === EcoreParser.XMLinlineMarker) key = key.substring(EcoreParser.XMLinlineMarker.length);\r\n\r\n                    const namespacedclass: string = key;\r\n                    const mmclass: LClass | undefined = meta && meta.getClassByNameSpace(namespacedclass);\r\n                    if (!mmclass) console.log(\"failed to get mmclass\", {meta, key, mmclass})\r\n                    const roots_for_this_metaclass: Json[] = Array.isArray(val) ? val : [val]; // there might be N roots of class A, M of type B...\r\n                    for(let rootjson of roots_for_this_metaclass) {\r\n                        // DObject.new(mmclass.id, dObject.id, DModel, undefined, true)\r\n                        EcoreParser.parseDObject(rootjson, dObject, DModel, mmclass, generated);\r\n                    }\r\n            }\r\n        }\r\n        return generated;\r\n    }\r\n    /*\r\n    {\r\n      \"org.eclipse.example.bowling:League\": { <-- :classroot\r\n        \"-xmlns:xmi\": \"http://www.omg.org/XMI\",\r\n        \"-xmlns:org.eclipse.example.bowling\": \"https://org/eclipse/example/bowling\",\r\n        \"-xmi:version\": \"2.0\",\r\n        \"Players\": [\r\n          { \"-name\": \"tizio\" },\r\n          { \"-name\": \"asd\" }\r\n        ]\r\n      }\r\n    }\r\n    */\r\n\r\n\r\n    /// In Ecore parsing when you find a value list, it is possible to recover only the type for the meta-feature,<br>\r\n    /// but an array of Mammals might have some Whales, Pigs, etc mixed in. and you have to get the correct subclass for each\r\n    static getobjectmetaclass(json: Json, metaSuperClass: LClass): LClass {\r\n        return metaSuperClass; // todo: comment this and execute below\r\n        let subclasses: LClass[] | [] = !metaSuperClass ? [] : [metaSuperClass];\r\n        let subclasseshapes: Dictionary<Pointer<DClass>, {l: LClass } & Dictionary<DocString<\"feature name\">,  LTypedElement[\"type\"]/*feature type*/>> = {}\r\n        for (let sc of subclasses) {\r\n            subclasseshapes[sc.id] = {l: sc};\r\n            let row = subclasseshapes[sc.id];\r\n            for (let feat of sc.children) {\r\n                let lfeat: LTypedElement = feat as any;\r\n                let dfeat: DTypedElement = lfeat.__raw as any;\r\n                if (!dfeat.name || !dfeat.type) continue;\r\n                row[dfeat.name] = lfeat.type;\r\n            }\r\n        }\r\n        return this.findBestMatch(subclasseshapes, json);\r\n    }\r\n    static findBestMatch(\r\n        m2classes: Dictionary<Pointer<DClass>,  {l: LClass } & Dictionary<DocString<\"feature name\">, LTypedElement[\"type\"]>>,\r\n        json: Dictionary<DocString<\"feature name\">, any/*actual val instead of type*/>): LClass{\r\n        throw new Error(\"todo\");\r\n        return null as any;\r\n    }\r\n    static parseDObject(json: Json, parent: DModel | DValue, parentType: typeof DModel | typeof DValue, meta: LClass | undefined, generated: DModelElement[]): DModelElement[]{\r\n        if (!json) { json = {}; }\r\n        meta = meta && this.getobjectmetaclass(json, meta);\r\n        // let dObject: DObject = DObject.new(meta?.id, parent.id, parentType, json[\"name\"] as string || \"obj_1\");\r\n        // let data: Partial<DObject> = {};\r\n        let dObject: DObject = DObject.new(meta?.id, parent.id, parentType, json[\"name\"] as string || \"obj_1\");\r\n        generated.push(dObject); dObject.father = parent.id;\r\n        if (parent) {\r\n            if (parentType === DModel) (parent as DModel).objects.push(dObject.id);\r\n            else (parent as DValue).values.push(dObject.id);\r\n        }\r\n        console.log(\"made dobject\", {json, dObject, meta, metaname: meta?.name});\r\n        /// *** specific  *** ///\r\n        for (let key in json) {\r\n            switch(key) {\r\n                case ECoreObject.xmi_version: // this is only on roots\r\n                    Log.ex(json[key] !== \"2.0\",\"The only supported ecore version is \\\"2.0\\\", found instead: \\\"\"+json[key] +\"\\\"\");\r\n                    break;\r\n                // case ECoreObject.xmlnsecore:\r\n                case ECoreObject.xmlns_xmi:\r\n                    let expected = \"http://www.omg.org/XMI\";\r\n                    Log.ex(json[key] !== expected,\"Unexpected XMI schema. Should be \\\"\"+expected+\"\\\", found instead: \\\"\"+json[key] +\"\\\"\");\r\n                    break;\r\n                default: // a feature name\r\n                    let val = json[key];\r\n                    if (!val) continue;\r\n                    if (key[0] === EcoreParser.XMLinlineMarker) key = key.substring(1);\r\n                    if (key.indexOf(\"xmlns:\") === 0) continue; // \"-xmlns:org.eclipse.example.modelname\": \"https://org/eclipse/example/modelname\",\r\n                    let metafeature: LAttribute | LReference | undefined = meta && (meta as any)[\"@\"+key];\r\n                    console.log(\"feature meta\", {json, dObject, key, val, metafeature, classmeta: meta});\r\n                    let values: any[];\r\n                    if (Array.isArray(val)) values = val;\r\n                    else if (val as unknown === undefined) values = [];\r\n                    else values = [val];\r\n                    EcoreParser.parseDValue(key, values, dObject/*father*/, metafeature/*meta*/, generated);\r\n                // DValue.new(key, metafeature?.id, values, dObject, true, false);\r\n            }\r\n        }\r\n        return generated;\r\n    }\r\n\r\n    private static parseDValue(name:string | undefined, jsonvalues: any[], parent: DObject, meta: LAttribute | LReference | undefined, generated: DModelElement[]): DModelElement[] {\r\n        if (!jsonvalues) { jsonvalues = []; }\r\n        // let dObject: DObject = DObject.new(meta?.id, parent.id, parentType, json[\"name\"] as string || \"obj_1\");\r\n        console.log(\"DValue.new(meta ? undefined : name, meta?.id, jsonvalues, parent.id, true, false)\")\r\n        console.log(\"DValue.new(\", meta ? undefined : name, \",\",meta?.id, \",\",jsonvalues, \",\",parent.id);\r\n        let dValue: DValue = DValue.new(meta ? undefined : name, meta?.id, [], parent.id, true, false);\r\n        generated.push(dValue); dValue.father = parent.id;\r\n        parent.features.push(dValue.id);\r\n        console.log(\"made dValue\", {jsonvalues, dValue, meta, metaname: meta?.name});\r\n        if (meta && meta.className === DAttribute.cname) { dValue.values = jsonvalues; return generated; }\r\n\r\n        for (let v of jsonvalues) {\r\n            if (typeof v !== \"object\") { dValue.values.push(v); continue; }\r\n            // let subdObject: DObject = DObject.new((meta as LReference)?.type.id, parent.id, DValue, undefined);\r\n            // generated.push(subdObject);\r\n            EcoreParser.parseDObject(v, dValue, DValue, (meta as LReference)?.type, generated);\r\n        }\r\n        return generated;\r\n    }\r\n\r\n    static parseDAnnotation(parent: DModelElement, json: Json, generated: DModelElement[], fullnamePrefix: string): DModelElement[] {\r\n        return []; // todo\r\n        if (!generated) generated = [];\r\n        if (!json) { json = {}; }\r\n        let dObject: DAnnotation = DAnnotation.new();\r\n        generated.push(dObject); dObject.father = parent.id;\r\n        (dObject as any).name = this.read(json, ECoreNamed.namee, undefined);\r\n        dObject.father = parent.id;\r\n        if (parent) parent.annotations.push(dObject.id);\r\n        const annotations: Json[] = this.getAnnotations(json);\r\n        for (let child of annotations) EcoreParser.parseDAnnotation(dObject, child, generated, (dObject as GObject).__fullname + \"/\");\r\n        (dObject as GObject).__fullname = undefined; // fullnamePrefix + \"/\" + (dObject as any).name; // if annotation is not named (and it shouldn't) i don't wanna override container name\r\n        /// *** specific  *** ///\r\n        let key: string;\r\n        for (key in json){\r\n            const value = json[key];\r\n            switch (key) { //todo\r\n                default: Log.exx('unexpected field in EAnnotation:  ' + key + ' => |' + value + '|', {key, value, json}); break;\r\n                // case ECoreAnnotation.annotations: break; // todo: enable, yes annotations can have annotations\r\n                case ECoreAnnotation.details: break;\r\n                case ECoreAnnotation.references: break;\r\n                case ECoreAnnotation.source: break;\r\n            }\r\n        }\r\n        // annotation.referencesStr = this.read(json, ECoreAnnotation.source, '#/');\r\n        // annotation.name = this.read(json, ECoreAnnotation.name, 'EAnnotation_1');\r\n        // const details: Json[] = this.getDetails(json);\r\n        // for (let i = 0; i < details.length; i++) { new EAnnotationDetail(this, details[i]); }\r\n        return generated; }\r\n\r\n    static parseRootPackage(parent: DModel, json: Json, generated: DModelElement[]): DModelElement[] {\r\n        if (!generated) generated = [];\r\n        if (!json) { json = {}; }\r\n        const childs = this.getChildren(json);\r\n\r\n        let dObject: DPackage = DPackage.new();\r\n        generated.push(dObject); dObject.father = parent.id;\r\n        if (parent) parent.packages.push(dObject.id);\r\n\r\n        let version = (json[EcoreParser.prefix+\"xmlns:ecore\"] || '') as string;\r\n        // model.xmi = json[EcoreParser.prefix+\"xmlns:xmi\"]; // http://www.omg.org/XMI\r\n        // model.xsi = json[EcoreParser.prefix+\"xmlns:xsi\"]; // http://www.w3.org/2001/XMLSchema-instance\r\n        Log.ex(!EcoreParser.supportedEcoreVersions.includes(version), \"unsupported ecore version, must be one of:\" + EcoreParser.supportedEcoreVersions + \" found instead: \"+version);\r\n        dObject.name = this.read(json, ECoreNamed.namee, 'default');\r\n        // root package name is \"transparent\" and not applied in \"#//reference/paths/...\", if referenced i guess his name is \"#//\"\r\n        (dObject as GObject).__fullname = ''; // fullnamePrefix + \"/\" + dObject.name;\r\n        const annotations: Json[] = this.getAnnotations(json);\r\n        for (let child of annotations) EcoreParser.parseDAnnotation(dObject, child, generated, (dObject as GObject).__fullname + \"/\");\r\n        /// *** specific start *** ///\r\n        const subPackages: Json[] = this.getSubPackages(json);\r\n        dObject.uri = this.read(json, ECorePackage.nsURI, null);\r\n        dObject.prefix = this.read(json, ECorePackage.nsPrefix, null);\r\n        console.warn(\"parseRootPackage.children\", {childs, annotations, subPackages, dObject, generated});\r\n        // if (!parent.uri) parent.uri = dObject.uri;\r\n        // if (!parent.prefix) parent.prefix = dObject.prefix; // namespace\r\n        for (let child of childs) {\r\n            switch (child[ECoreClass.xsitype]) {\r\n                default: Log.exx('unexpected xsitype:', child[ECoreClass.xsitype], ' found in jsonfragment:', child, ', in json:', json, ' package:', dObject); break;\r\n                case 'ecore:EClass': this.parseDClass(dObject, child, generated, ''); break;\r\n                case 'ecore:EEnum': this.parseDEnum(dObject, child, generated, ''); break;\r\n            }\r\n        }\r\n        for (let child of subPackages) EcoreParser.parseSubPackage(dObject, child, generated, '');\r\n        /// *** specific end *** ///\r\n        return generated; }\r\n\r\n    static parseSubPackage(parent: DPackage, json: Json, generated: DModelElement[], fullnamePrefix: string): DModelElement[] {\r\n        if (!generated) generated = [];\r\n        if (!json) { json = {}; }\r\n        const childs = this.getChildren(json);\r\n        let dObject: DPackage = DPackage.new();\r\n        generated.push(dObject); dObject.father = parent.id;\r\n        if (parent) parent.subpackages.push(dObject.id);\r\n        dObject.name = this.read(json, ECoreNamed.namee, 'subPackage_1');\r\n        (dObject as GObject).__fullname = fullnamePrefix + dObject.name;\r\n        const annotations: Json[] = this.getAnnotations(json);\r\n        for (let child of annotations) EcoreParser.parseDAnnotation(dObject, child, generated, (dObject as GObject).__fullname + \"/\");\r\n        /// *** specific start *** ///\r\n        dObject.uri = this.read(json, ECoreSubPackage.nsURI, null);\r\n        dObject.prefix = this.read(json, ECoreSubPackage.nsPrefix, null);\r\n        const subPackages: Json[] = this.getSubPackages(json);\r\n        console.warn(\"parseSubPackage.children\", {childs, annotations, subPackages, dObject, generated});\r\n        // if (!dObject.uri) dObject.uri = dObject.name + \".\" + parent.uri;\r\n        // if (!dObject.prefix) dObject.prefix = dObject.name + \".\" + parent.prefix; // namespace\r\n        for (let child of childs) {\r\n            switch (child[ECoreClass.xsitype]) {\r\n                default: Log.exx('unexpected xsitype:', child[ECoreClass.xsitype], ' found in jsonfragment:', child, ', in json:', json, ' package:', dObject); break;\r\n                case 'ecore:EClass': this.parseDClass(dObject, child, generated, (dObject as GObject).__fullname + \"/\"); break;\r\n                case 'ecore:EEnum': this.parseDEnum(dObject, child, generated, (dObject as GObject).__fullname + \"/\"); break;\r\n            }\r\n        }\r\n        for (let child of subPackages) EcoreParser.parseSubPackage(dObject, child, generated, (dObject as GObject).__fullname + \"/\");\r\n        /// *** specific end *** ///\r\n        return generated; }\r\n\r\n    static parseDClass(parent: DPackage, json: Json, generated: DModelElement[], fullnamePrefix: string): DModelElement[] {\r\n        if (!generated) generated = [];\r\n        if (!json) { json = {}; }\r\n        let dObject: DClass = DClass.new(\r\n            this.read(json, ECoreNamed.namee, 'Concept 1'),\r\n            undefined as any, undefined as any, undefined as any, undefined as any, undefined, parent.id,\r\n        );\r\n        generated.push(dObject);// dObject.father = parent.id;\r\n        //if (parent) parent.classifiers.push(dObject.id);\r\n        //dObject.name = this.read(json, ECoreNamed.namee, 'Class_1');\r\n        (dObject as GObject).__fullname = fullnamePrefix + dObject.name;\r\n        const annotations: Json[] = this.getAnnotations(json);\r\n        for (let child of annotations) EcoreParser.parseDAnnotation(dObject, child, generated, (dObject as GObject).__fullname + \"/\");\r\n        /// *** specific start *** ///\r\n        for (let key in json) {\r\n            switch (key) {\r\n                default: Log.exx('unexpected field in parseDClass() |' + key + '|', json); break;\r\n                case ECoreClass.eAnnotations:\r\n                case ECoreClass.instanceTypeName:\r\n                case ECoreClass.eSuperTypes:\r\n                case ECoreClass.xsitype:\r\n                case ECoreClass.eOperations:\r\n                case ECoreClass.eStructuralFeatures:\r\n                case ECoreClass.abstract:\r\n                case ECoreClass.interface:\r\n                case ECoreClass.namee: break; } }\r\n        dObject.instanceClassName = this.read(json, ECoreClass.instanceTypeName, '');\r\n        dObject.interface = this.read(json, ECoreClass.interface, 'false') === 'true';\r\n        dObject.abstract = this.read(json, ECoreClass.abstract, 'false') === 'true';\r\n        let tmps: string = this.read(json, ECoreClass.eSuperTypes, '');\r\n        dObject.extends = tmps.split(' ');\r\n        const features: Json[] = this.getChildren(json);\r\n        const functions: Json[] = this.getChildren(json, false, true);\r\n\r\n        for (let child of functions) this.parseDOperation(dObject, child, generated, (dObject as GObject).__fullname + \"/\");\r\n        for (let child of features) {\r\n            const xsiType = this.read(child, ECoreAttribute.xsitype);\r\n            switch (xsiType) {\r\n                default: Log.exx( 'unexpected xsi:type: ', xsiType, ' in feature:', child); break;\r\n                case 'ecore:EAttribute':\r\n                    this.parseDAttribute(dObject, child, generated, (dObject as GObject).__fullname + \"/\"); break;\r\n                case 'ecore:EReference':\r\n                    this.parseDReference(dObject, child, generated, (dObject as GObject).__fullname + \"/\"); break;\r\n            }\r\n        }\r\n        /// *** specific end *** ///\r\n        return generated; }\r\n\r\n    static parseDEnum(parent: DPackage, json: Json, generated: DModelElement[], fullnamePrefix: string): DModelElement[] {\r\n        if (!generated) generated = [];\r\n        if (!json) { json = {}; }\r\n        const childs = this.getChildren(json);\r\n        let dObject: DEnumerator = DEnumerator.new();\r\n        generated.push(dObject); dObject.father = parent.id;\r\n        if (parent) parent.classifiers.push(dObject.id);\r\n        dObject.name = this.read(json, ECoreNamed.namee, 'Enum_1');\r\n        (dObject as GObject).__fullname = fullnamePrefix + dObject.name;\r\n        const annotations: Json[] = this.getAnnotations(json);\r\n        for (let child of annotations) EcoreParser.parseDAnnotation(dObject, child, generated, (dObject as GObject).__fullname + \"/\");\r\n        /// *** specific start *** ///\r\n        for (let key in json) {\r\n            const value = json[key];\r\n            switch (key) {\r\n                default: Log.exx('Enum.parse() unexpected key:', key, 'in json:', json); break;\r\n                case ECoreEnum.eAnnotations:\r\n                case ECoreEnum.xsitype: case ECoreNamed.namee: break;\r\n                case ECoreEnum.eLiterals: break;\r\n                case ECoreEnum.serializable: dObject.serializable = value === 'true'; break;\r\n                case ECoreEnum.instanceTypeName: dObject.instanceClassName = value + ''; break;\r\n            }\r\n        }\r\n        for (let child of childs) {\r\n            this.parseDEnumLiteral(dObject, child, generated, (dObject as GObject).__fullname + \"/\");\r\n        }\r\n\r\n        /// *** specific end *** ///\r\n        return generated; }\r\n\r\n\r\n\r\n    static parseDEnumLiteral(parent: DEnumerator, json: Json, generated: DModelElement[], fullnamePrefix: string): DModelElement[] {\r\n        if (!generated) generated = [];\r\n        if (!json) { json = {}; }\r\n        const childs = this.getChildren(json);\r\n        let dObject: DEnumLiteral = DEnumLiteral.new();\r\n        generated.push(dObject); dObject.father = parent.id;\r\n        if (parent) parent.literals.push(dObject.id);\r\n        const annotations: Json[] = this.getAnnotations(json);\r\n        for (let child of annotations) EcoreParser.parseDAnnotation(dObject, child, generated, (dObject as GObject).__fullname + \"/\");\r\n        /// *** specific start *** ///\r\n        dObject.value = +this.read(json, EcoreLiteral.value, Number.NEGATIVE_INFINITY);//vv4\r\n        dObject.literal = this.read(json, EcoreLiteral.literal, '');\r\n        dObject.name = this.read(json, ECoreNamed.namee,  dObject.literal || 'literal_1');\r\n        (dObject as GObject).__fullname = fullnamePrefix + dObject.name;\r\n        /// *** specific end *** ///\r\n        return generated; }\r\n\r\n    static parseDAttribute(parent: DClass, json: Json, generated: DModelElement[], fullnamePrefix: string): DModelElement[] {\r\n        if (!generated) generated = [];\r\n        if (!json) { json = {}; }\r\n        const childs = this.getChildren(json);\r\n        // done: old approach does not set pointedBy, i should set father and all pointers in .new() parameters\r\n        let dObject: DAttribute = DAttribute.new(\r\n            this.read(json, ECoreNamed.namee, 'attr_1'),\r\n            this.read(json, ECoreAttribute.eType, AttribETypes.EString),\r\n            parent.id,\r\n        );\r\n        generated.push(dObject);// dObject.father = parent.id;\r\n        // if (parent) parent.attributes.push(dObject.id);\r\n        //dObject.name = this.read(json, ECoreNamed.namee, 'attr_1');\r\n        (dObject as GObject).__fullname = fullnamePrefix + dObject.name;\r\n        const annotations: Json[] = this.getAnnotations(json);\r\n        for (let child of annotations) EcoreParser.parseDAnnotation(dObject, child, generated, (dObject as GObject).__fullname + \"/\");\r\n        /// *** specific start *** ///\r\n        dObject.lowerBound = +this.read(json, ECoreAttribute.lowerbound, 0);\r\n        dObject.upperBound = +this.read(json, ECoreAttribute.upperbound, 1);\r\n        //dObject.type = this.read(json, ECoreAttribute.eType, AttribETypes.EString);\r\n        /// *** specific end *** ///\r\n        return generated; }\r\n\r\n    static parseDReference(parent: DClass, json: Json, generated: DModelElement[], fullnamePrefix: string): DModelElement[] {\r\n        if (!generated) generated = [];\r\n        if (!json) { json = {}; }\r\n        const childs = this.getChildren(json);\r\n        let dObject: DReference = DReference.new();\r\n        generated.push(dObject); dObject.father = parent.id;\r\n        if (parent) parent.references.push(dObject.id);\r\n        dObject.name = this.read(json, ECorePackage.namee, 'Ref_1');\r\n        (dObject as GObject).__fullname = fullnamePrefix + dObject.name;\r\n        const annotations: Json[] = this.getAnnotations(json);\r\n        for (let child of annotations) EcoreParser.parseDAnnotation(dObject, child, generated, (dObject as GObject).__fullname + \"/\");\r\n        /// *** specific start *** ///\r\n        dObject.composition = U.fromBoolString(this.read(json, ECoreReference.containment, false), false);\r\n        dObject.container = U.fromBoolString(this.read(json, ECoreReference.container, false), false);\r\n        dObject.lowerBound = +this.read(json, ECoreAttribute.lowerbound, 0);\r\n        dObject.upperBound = +this.read(json, ECoreAttribute.upperbound, 1);\r\n        dObject.type = this.read(json, ECoreReference.eType, this.getEcoreTypeName(parent));\r\n        /// *** specific end *** ///\r\n        return generated; }\r\n\r\n    static parseDParameter(parent: DOperation, json: Json, generated: DModelElement[], fullnamePrefix: string): DModelElement[] {\r\n        if (!generated) generated = [];\r\n        if (!json) { json = {}; }\r\n        const childs = this.getChildren(json);\r\n        let dObject: DParameter = DParameter.new();\r\n        generated.push(dObject); dObject.father = parent.id;\r\n        if (parent) parent.parameters.push(dObject.id);\r\n        dObject.name = this.read(json, ECoreNamed.namee, 'arg1');\r\n        (dObject as GObject).__fullname = fullnamePrefix + dObject.name;\r\n        const annotations: Json[] = this.getAnnotations(json);\r\n        for (let child of annotations) EcoreParser.parseDAnnotation(dObject, child, generated, (dObject as GObject).__fullname + \"/\");\r\n        /// *** specific start *** ///\r\n        dObject.lowerBound = +this.read(json, ECoreAttribute.lowerbound, 0);\r\n        dObject.upperBound = +this.read(json, ECoreAttribute.upperbound, 1);\r\n        dObject.type = this.read(json, ECoreAttribute.eType, AttribETypes.EString);\r\n        dObject.ordered = U.fromBoolString(this.read(json, ECoreOperation.ordered, 'false'), false);\r\n        dObject.unique = U.fromBoolString(this.read(json, ECoreOperation.unique, 'false'), false);\r\n        /// *** specific end *** ///\r\n        return generated; }\r\n\r\n    static parseDOperation(parent: DClass, json: Json, generated: DModelElement[], fullnamePrefix: string): DModelElement[] {\r\n        if (!generated) generated = [];\r\n        if (!json) { json = {}; }\r\n        const childs = this.getChildren(json);\r\n        let dObject: DOperation = DOperation.new();\r\n        generated.push(dObject); dObject.father = parent.id;\r\n        if (parent) parent.operations.push(dObject.id);\r\n        dObject.name = this.read(json, ECoreNamed.namee, 'operation_1');\r\n        (dObject as GObject).__fullname = fullnamePrefix + dObject.name;\r\n\r\n        const annotations: Json[] = this.getAnnotations(json);\r\n        for (let child of annotations) EcoreParser.parseDAnnotation(dObject, child, generated, (dObject as GObject).__fullname + \"/\");\r\n        /// *** specific start *** ///\r\n        dObject.lowerBound = +this.read(json, ECoreAttribute.lowerbound, 1);\r\n        dObject.upperBound = +this.read(json, ECoreAttribute.upperbound, 1);\r\n        dObject.type = this.read(json, ECoreAttribute.eType, AttribETypes.EString);\r\n        dObject.exceptions = [this.read(json, ECoreOperation.eexceptions, '')];\r\n        dObject.ordered = U.fromBoolString(this.read(json, ECoreOperation.ordered, 'false'));\r\n        dObject.unique = U.fromBoolString(this.read(json, ECoreOperation.unique, 'false'));\r\n        dObject.visibility = AccessModifier.package;\r\n        for (let child of childs) {\r\n            this.parseDParameter(dObject, child, generated, (dObject as GObject).__fullname + \"/\");\r\n        }\r\n        /// *** specific end *** ///\r\n        return generated; }\r\n\r\n\r\n    /*\r\n    static parseTEMPLATE(parent: DSomething, json: Json, generated: DModelElement[], fullnamePrefix: string): DModelElement[] {\r\n        if (!generated) generated = [];\r\n        if (!json) { json = {}; }\r\n        const childs = this.getChildren(json);\r\n        let dObject: DSomething = DSomething.new();\r\n        generated.push(dObject); dObject.father = parent.id;\r\n        if (parent) parent.CHILDCOLLECTION.push(dObject.id);\r\n        dObject.name = this.read(json, ECoreNamed.namee, defaultNameTODO);\r\n        (dObject as GObject).__fullname = fullnamePrefix + dObject.name;\r\n        const annotations: Json[] = this.getAnnotations(json);\r\n        for (let child of annotations) EcoreParser.parseDAnnotation(dObject, child, generated, (dObject as GObject).__fullname + \"/\");\r\n        /// *** specific start *** ///\r\n        for (let child of childs) {\r\n            this.parseDSOMETHING(dObject, child, generated, (dObject as GObject).__fullname + \"/\");\r\n        }\r\n        /// *** specific end *** ///\r\n        return generated; }*/\r\n\r\n\r\n\r\n\r\n\r\n    /////////////////////////////////// generic\r\n    static XMLinlineMarker: string = '@';\r\n    static classTypePrefix: string = '#//'\r\n    private static getSubPackages(thiss: Json): Json[] {\r\n        const ret: any = thiss[ECoreSubPackage.eSubpackages];\r\n        if (!ret || U.isEmptyObject(ret)) { return []; }\r\n        if (Array.isArray(ret)) { return ret; } else { return [ret]; } }\r\n\r\n    private static getAnnotations(thiss: Json): Json[] {\r\n        const ret: any = thiss[ECorePackage.eAnnotations];\r\n        if (!ret || U.isEmptyObject(ret)) { return []; }\r\n        if (Array.isArray(ret)) { return ret; } else { return [ret]; } }\r\n\r\n    private static getDetails(thiss: Json): Json[] {\r\n        const ret: any = thiss[ECoreAnnotation.details];\r\n        if (!ret || U.isEmptyObject(ret)) { return []; }\r\n        if (Array.isArray(ret)) { return ret; } else { return [ret]; } }\r\n\r\n    private static getChildren(thiss: Json, throwError: boolean = false, functions: boolean = false): Json[] {\r\n        if (!thiss && !throwError) { return []; }\r\n        const mod = thiss[ECoreRoot.ecoreEPackage];\r\n        const pkg = thiss[ECorePackage.eClassifiers];\r\n        const cla = thiss[functions ? ECoreClass.eOperations : ECoreClass.eStructuralFeatures];\r\n        const fun = thiss[ECoreOperation.eParameters];\r\n        const lit = thiss[ECoreEnum.eLiterals];\r\n\r\n        const ret: any = mod || pkg || cla || fun || lit;\r\n        /*if ( ret === undefined || ret === null ) {\r\n          if (thiss['@name'] !== undefined) { ret = thiss; } // if it's the root with only 1 child arrayless\r\n        }*/\r\n        Log.ex( throwError && !ret, 'getChildren() Failed: ', thiss, ret);\r\n        // console.log('ret = ', ret, ' === ', {}, ' ? ', (U.isEmptyObject(ret) ? [] : [ret]));\r\n        if (!ret || U.isEmptyObject(ret)) { return []; }\r\n        if (Array.isArray(ret)) { return ret; } else { return [ret]; }\r\n    }\r\n\r\n    private static read(json: Json, field: string, valueIfNotFound: any = 'read<T>()CanThrowError'): string {\r\n        let ret: any = json ? json[field] : null;\r\n        if (ret !== null && ret !== undefined && field.indexOf(this.XMLinlineMarker) !== -1) {\r\n            Log.ex(U.isObject(ret, false, false, true), 'inline value |' + field + '| must be primitive.', ret);\r\n            ret = U.multiReplaceAll('' + ret, ['&amp;', '&#38;', '&quot;'], ['&', '\\'', '\"']);\r\n        }\r\n        if ((ret === null || ret === undefined)) {\r\n            Log.ex(valueIfNotFound === 'read<T>()CanThrowError', 'this.read<',  '> failed: field[' + field + '], json: ', json);\r\n            return valueIfNotFound; }\r\n        return ret; }\r\n\r\n    static write(json: Json, field: string, val: string | any[]): string | any[] {\r\n        if (val !== null && field.indexOf(EcoreParser.XMLinlineMarker) !== -1) {\r\n            Log.ex(val !== '' + val, 'inline value |' + field + '| must be a string.', val);\r\n            val = U.multiReplaceAll(val as string, ['&', '\\'', '\"'], ['&amp;', '&#38;', '&quot;']);\r\n        }\r\n        else Log.ex(val !== '' + val || !U.isObject(val, true), 'primitive values should be inserted only inline in the xml:', field, val);\r\n        json[field] = val;\r\n        return val; }\r\n\r\n    private static getEcoreTypeName(parent: DClassifier): string {\r\n        if (parent.className === DEnumerator.cname || parent.className === DClass.cname) return this.classTypePrefix + this.name;\r\n        // return Type.classTypePrefix + parent.parent.name; problem: need L-object to navigate\r\n        return Log.exx(\"getEcoreTypeName failed\", parent);\r\n    }\r\n\r\n}\r\n\r\nexport enum AccessModifier {\r\n    public = 'public',\r\n    private = 'private',\r\n    protected = 'protected',\r\n    internal = 'internal',\r\n    package = 'package',\r\n    protectedinternal = 'protected internal',\r\n    protectedprivate = 'protected private', }\r\n\r\nexport class ECoreRoot {\r\n    static ecoreEPackage: string;\r\n}\r\n\r\nexport class ECoreAnnotation {\r\n    static source: string;\r\n    static references: string;\r\n    static details: string;}\r\n\r\nexport class ECoreNamed {\r\n    static namee: string; }\r\n\r\nexport class ECoreDetail {\r\n    static key: string;\r\n    static value: string; }\r\n\r\nexport class ECoreSubPackage { // <eSubpackages\r\n    static eSubpackages: string;\r\n    static eAnnotations: string;\r\n    static eClassifiers: string;\r\n    static nsURI: string;\r\n    static nsPrefix: string;\r\n    static namee: string;\r\n}\r\n\r\nexport class ECorePackage extends ECoreSubPackage {\r\n    static eAnnotations: string;\r\n    static eSubpackages: string;\r\n    static eClassifiers: string;\r\n    static xmlnsxmi: string;\r\n    static xmlnsxsi: string;\r\n    static xmiversion: string;\r\n    static xmlnsecore: string;\r\n    static nsURI: string;\r\n    static nsPrefix: string;\r\n    static namee: string;\r\n}\r\n\r\nexport class ECoreClass {\r\n    static eAnnotations: string;\r\n    static eStructuralFeatures: string;\r\n    static xsitype: string;\r\n    static namee: string;\r\n    static eOperations: string;\r\n    static instanceTypeName: string;\r\n    static eSuperTypes: string;\r\n    static abstract: string;\r\n    static interface: string;\r\n\r\n    // static defaultValue = EcoreParser.XMLinlineMarker + 'defaultValue';  // visualizzato in ecore ma mai salvato dentro il file. inutilizzato\r\n    // nelle classi, assume il valore di \"[name] = [NumericValue]\" senza le [] negli enum.\r\n}\r\n\r\nexport class ECoreEnum {\r\n    static eAnnotations: string;\r\n    static xsitype: string;\r\n    static namee: string;\r\n    static instanceTypeName: string;\r\n    static serializable: string;\r\n    static eLiterals: string;\r\n}\r\n\r\nexport class EcoreLiteral {\r\n    static eAnnotations: string;\r\n    static namee: string;\r\n    static value: string;\r\n    static literal: string;\r\n}\r\n\r\n\r\nexport class ECoreReference {\r\n    static eAnnotations: string;\r\n    static xsitype: string;\r\n    static eType: string;\r\n    static containment: string;\r\n    static container: string;\r\n    static upperbound: string;\r\n    static lowerbound: string;\r\n    static namee: string; }\r\n\r\nexport class ECoreAttribute {\r\n    static eAnnotations: string;\r\n    static xsitype: string;\r\n    static eType: string;\r\n    static namee: string;\r\n    static lowerbound: string;\r\n    static upperbound: string;\r\n}\r\n\r\nexport class ECoreOperation {\r\n    static eAnnotations: string;\r\n    static eType: string;\r\n    static eexceptions: string;\r\n    static upperBound: string;\r\n    static lowerBound: string;\r\n    static unique: string;\r\n    static ordered: string;\r\n    static namee: string;\r\n    static eParameters: string; }\r\n\r\nexport class ECoreParameter {\r\n    static eAnnotations: string;\r\n    static namee: string;\r\n    static ordered: string;\r\n    static unique: string;\r\n    static lowerBound: string;\r\n    static upperBound: string;\r\n    static eType: string;\r\n}\r\n\r\nexport class ECoreObject{\r\n    static xmlns_xmi: string;\r\n    static xmlns_uri: never; // \"-xmlns:org.eclipse.example.modelname\": \"https://org/eclipse/example/modelname\", <b>key is dynamic</b>\r\n    static xmi_version: string;\r\n}\r\nexport class XMIModel {\r\n    static type: string;\r\n    static namee: string; }\r\n\r\n\r\n///////////////\r\n\r\nECoreRoot.ecoreEPackage = 'ecore:EPackage'; // this is root tag but not in xml->json, just his attributes/childrens\r\nECoreNamed.namee = EcoreParser.XMLinlineMarker + 'name';\r\n\r\nECorePackage.eAnnotations = ECoreSubPackage.eAnnotations = ECoreClass.eAnnotations =\r\n    ECoreEnum.eAnnotations = EcoreLiteral.eAnnotations =  ECoreReference.eAnnotations =\r\n        ECoreAttribute.eAnnotations = ECoreOperation.eAnnotations = ECoreParameter.eAnnotations = 'eAnnotations';\r\n\r\nECoreAnnotation.source = EcoreParser.XMLinlineMarker + 'source';\r\nECoreAnnotation.references = EcoreParser.XMLinlineMarker + 'references'; // \"#/\" for target = package.\r\nECoreAnnotation.details = 'details'; // arr\r\nECoreDetail.key = EcoreParser.XMLinlineMarker + 'key'; // can have spaces\r\nECoreDetail.value = EcoreParser.XMLinlineMarker + 'value';\r\n\r\nECorePackage.eSubpackages = 'eSubpackages';\r\nECorePackage.eClassifiers = 'eClassifiers';\r\nECorePackage.xmlnsxmi = EcoreParser.XMLinlineMarker + 'xmlns:xmi'; // typical value: http://www.omg.org/XMI\r\nECorePackage.xmlnsxsi = EcoreParser.XMLinlineMarker + 'xmlns:xsi'; // typical value: http://www.w3.org/2001/XMLSchema-instance\r\nECorePackage.xmiversion = EcoreParser.XMLinlineMarker + 'xmi:version'; // typical value: \"2.0\"\r\nECorePackage.xmlnsecore = EcoreParser.XMLinlineMarker + 'xmlns:ecore';\r\nECorePackage.nsURI = EcoreParser.XMLinlineMarker + 'nsURI'; // typical value: \"http://org/eclipse/example/modelname\"\r\nECorePackage.nsPrefix = EcoreParser.XMLinlineMarker + 'nsPrefix'; // typical value: org.eclipse.example.modelname\r\nECorePackage.namee = EcoreParser.XMLinlineMarker + 'name';\r\n\r\nECoreSubPackage.eSubpackages = 'eSubpackages';\r\nECoreSubPackage.eClassifiers = 'eClassifiers';\r\nECoreSubPackage.nsURI = EcoreParser.XMLinlineMarker + 'nsURI'; // typical value: \"http://org/eclipse/example/modelname\"\r\nECoreSubPackage.nsPrefix = EcoreParser.XMLinlineMarker + 'nsPrefix'; // typical value: org.eclipse.example.modelname\r\nECoreSubPackage.namee = EcoreParser.XMLinlineMarker + 'name';\r\n\r\n\r\nECoreClass.eStructuralFeatures = 'eStructuralFeatures';\r\nECoreClass.eOperations = 'eOperations';\r\nECoreClass.xsitype = EcoreParser.XMLinlineMarker + 'xsi:type'; // \"ecore:EClass\"\r\nECoreClass.namee = ECorePackage.namee;\r\nECoreClass.eSuperTypes = EcoreParser.XMLinlineMarker + 'eSuperTypes'; // space separated: \"#name1 #name2\"...\r\nECoreClass.instanceTypeName = EcoreParser.XMLinlineMarker + 'instanceTypeName';  // raw str\r\nECoreClass.instanceTypeName = EcoreParser.XMLinlineMarker + 'instanceTypeName';\r\nECoreClass.abstract = EcoreParser.XMLinlineMarker + 'abstract'; // bool\r\nECoreClass.interface = EcoreParser.XMLinlineMarker + 'interface'; // bool\r\n\r\nECoreEnum.instanceTypeName = ECoreClass.instanceTypeName;\r\nECoreEnum.serializable = 'serializable'; // \"false\", \"true\"\r\nECoreEnum.xsitype = ECoreClass.xsitype; // \"ecore:EEnum\"\r\nECoreEnum.eLiterals = 'eLiterals';\r\nECoreEnum.namee = ECorePackage.namee;\r\n\r\nEcoreLiteral.literal = 'literal';\r\nEcoreLiteral.namee = ECorePackage.namee;\r\nEcoreLiteral.value = 'value'; // any integer (-inf, +inf), not null. limiti = a type int 32 bit? vv4\r\n\r\nECoreReference.xsitype = EcoreParser.XMLinlineMarker + 'xsi:type'; // \"ecore:EReference\"\r\nECoreReference.eType = EcoreParser.XMLinlineMarker + 'eType'; // \"#//Player\"\r\nECoreReference.containment = EcoreParser.XMLinlineMarker + 'containment'; // \"true\"\r\nECoreReference.upperbound = EcoreParser.XMLinlineMarker + 'upperBound'; // \"@1\"\r\nECoreReference.lowerbound = EcoreParser.XMLinlineMarker + 'lowerBound'; // does even exists?\r\nECoreReference.namee = EcoreParser.XMLinlineMarker + 'name';\r\n\r\nECoreAttribute.xsitype = EcoreParser.XMLinlineMarker + 'xsi:type'; // \"ecore:EAttribute\",\r\nECoreAttribute.eType = EcoreParser.XMLinlineMarker + 'eType'; // \"ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EString\"\r\nECoreAttribute.namee = EcoreParser.XMLinlineMarker + 'name';\r\nECoreAttribute.lowerbound = EcoreParser.XMLinlineMarker + 'lowerBound';\r\nECoreAttribute.upperbound = EcoreParser.XMLinlineMarker + 'upperBound';\r\n\r\n\r\nECoreOperation.eParameters = 'eParameters';\r\nECoreOperation.namee = EcoreParser.XMLinlineMarker + 'name'; // \"EExceptionNameCustom\",\r\nECoreOperation.ordered = EcoreParser.XMLinlineMarker + 'ordered'; // \"false\",\r\nECoreOperation.unique = EcoreParser.XMLinlineMarker + 'unique'; // \"false\",\r\nECoreOperation.lowerBound = EcoreParser.XMLinlineMarker + 'lowerBound'; // \"5\", ma che senso ha su una funzione?? è il return?\r\nECoreOperation.upperBound = EcoreParser.XMLinlineMarker + 'upperBound';\r\nECoreOperation.eType = EcoreParser.XMLinlineMarker + 'eType'; // \"#//Classname\",\r\nECoreOperation.eexceptions = EcoreParser.XMLinlineMarker + 'eExceptions';\r\n// \"#//ClassnameException1 #//ClassNameException2 (also custom classes) ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EInt\r\n\r\nECoreParameter.namee = EcoreParser.XMLinlineMarker + 'name';\r\nECoreParameter.ordered = EcoreParser.XMLinlineMarker + 'ordered'; // \"false\";\r\nECoreParameter.unique = EcoreParser.XMLinlineMarker + 'unique'; // \"false\"\r\nECoreParameter.lowerBound = EcoreParser.XMLinlineMarker + 'lowerBound'; // \"1\"\r\nECoreParameter.upperBound = EcoreParser.XMLinlineMarker + 'upperBound'; // \"2\"\r\nECoreParameter.eType = EcoreParser.XMLinlineMarker + 'eType'; // \"ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EDoubl\r\n\r\nECoreObject.xmlns_xmi = EcoreParser.XMLinlineMarker + 'xmlns:xmi'; // \"http://www.omg.org/XMI\"\r\n// ECoreObject.xmlns_uri = EcoreParser.XMLinlineMarker + 'xmlns:org.eclipse.example.modelname'; // \"https://org/eclipse/example/modelname\"\r\nECoreObject.xmi_version = EcoreParser.XMLinlineMarker + 'xmi:version'; // \"2.0\"\r\n\r\nXMIModel.type = EcoreParser.XMLinlineMarker + 'type';\r\nXMIModel.namee = EcoreParser.XMLinlineMarker + 'name';\r\n\r\n","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\redux\\createStore.ts",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\redux\\action\\action.ts",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\redux\\selectors\\selectors.ts",["813","814","815"],"import {\r\n    AbstractConstructor,\r\n    AttribETypes,\r\n    Constructor,\r\n    DAttribute,\r\n    DClass,\r\n    DClassifier,\r\n    DEnumerator,\r\n    DGraph,\r\n    DGraphElement,\r\n    DObject,\r\n    DRefEdge,\r\n    DState,\r\n    DValue,\r\n    DVoidVertex,\r\n    GObject,\r\n    LClass,\r\n    LEnumerator,\r\n    LGraphElement,\r\n    LModel,\r\n    LModelElement,\r\n    LObject,\r\n    LOperation,\r\n    LPackage,\r\n    LRefEdge,\r\n    LValue,\r\n    LViewElement,\r\n    LViewPoint,\r\n    LVoidVertex,\r\n    Pointer,\r\n    ShortAttribETypes,\r\n    Dictionary,\r\n    LUser,\r\n    DUser,\r\n    Defaults,\r\n    LProject,\r\n    ViewScore,\r\n    DViewElement,\r\n    DPointerTargetable,\r\n    DModel,\r\n    DModelElement,\r\n    OCL,\r\n    Log,\r\n    LPointerTargetable,\r\n    RuntimeAccessible,\r\n    RuntimeAccessibleClass,\r\n    store,\r\n    U,\r\n    toShortEType,\r\n    NodeTransientProperties,\r\n    transientProperties,\r\n    ViewEClassMatch,\r\n    ViewTransientProperties,\r\n    DProject,\r\n    DViewPoint,\r\n    DNamedElement\r\n} from \"../../joiner\";\r\nimport {DefaultEClasses, ShortDefaultEClasses, toShortEClass} from \"../../common/U\";\r\n\r\n\r\n@RuntimeAccessible('Selectors')\r\nexport class Selectors{\r\n\r\n    static getActiveModel(): null|LModel {\r\n        let metamodel: null|LModel;\r\n        let state: DState & GObject = store.getState();\r\n        const selected = state._lastSelected?.modelElement;\r\n        if(selected) {\r\n            const me = LPointerTargetable.fromPointer(selected)\r\n            metamodel = (me) ? me.model : null;\r\n        } else metamodel = null;\r\n        return metamodel;\r\n    }\r\n\r\n    public static getLastSelectedModel<RET extends {m1?:LModel, m2?:LModel, model?:LModel, element?:LModelElement}>(state?: DState): RET {\r\n        state = state || store.getState();\r\n        let me = state._lastSelected?.modelElement;\r\n        if (!me) return {} as RET;\r\n        let ret: RET = {element: LPointerTargetable.fromPointer(me, state)} as RET;\r\n        ret.model = ret.element!.model\r\n        if (ret.model.isMetamodel) ret.m2 = ret.model;\r\n        else {\r\n            ret.m1 = ret.model;\r\n            ret.m2 = ret.m1.instanceof;\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    static getAllViewElements(state0?: DState): DViewElement[] {\r\n        // return Object.values(store.getState().idlookup).filter(v => v.className === DViewElement.name) as DViewElement[];\r\n        const state: GObject<DState> = state0 || store.getState();\r\n        const ptrs: Pointer<DViewElement>[] = Object.values((state).viewelements);\r\n        let views: DViewElement[] = ptrs.map<DViewElement>( (ptr) => DPointerTargetable.fromPointer(ptr, state) as DViewElement);\r\n        return views;\r\n    }\r\n    //Giordano: start\r\n\r\n    public static getViewpoints() : LViewPoint[] {\r\n        const state: DState & GObject = store.getState();\r\n        return LPointerTargetable.fromPointer(state.viewpoints);\r\n    }\r\n    public static getViewpoint() : LViewPoint {\r\n        const state: DState & GObject = store.getState();\r\n        return LPointerTargetable.fromPointer(state.viewpoint);\r\n    }\r\n\r\n    public static getObjects(): LObject[] {\r\n        let state: DState & GObject = store.getState();\r\n        const ptrs: Pointer<DObject, 0, 'N'> = Object.values((state).objects);\r\n        const dObjects: DObject[] = ptrs.map<DObject>( (ptr) => state.idlookup[ptr] as DObject);\r\n        const lObjects: LObject[] = [];\r\n        for(let dObject of dObjects) {\r\n            lObjects.push(LPointerTargetable.fromPointer(dObject.id));\r\n        }\r\n        return lObjects;\r\n    }\r\n    public static getValues(): LValue[] {\r\n        let state: DState & GObject = store.getState();\r\n        const ptrs: Pointer<DValue, 0, 'N'> = Object.values((state).values);\r\n        const dValues: DValue[] = ptrs.map<DValue>( (ptr) => state.idlookup[ptr] as DValue);\r\n        const lValues: LValue[] = [];\r\n        for(let dValue of dValues) {\r\n            if(dValue?.id) {\r\n                lValues.push(LPointerTargetable.fromPointer(dValue.id));\r\n            }\r\n        }\r\n        return lValues;\r\n    }\r\n\r\n    public static getDeleted(): string [] {\r\n        const state: DState & GObject = store.getState();\r\n        return state.deleted;\r\n    }\r\n\r\n    public static getState(): any {\r\n        const state: DState & GObject = store.getState();\r\n        return state;\r\n    }\r\n\r\n    static getDefaultEcoreClass(type: DefaultEClasses | ShortDefaultEClasses, state?: DState): DClassifier {\r\n        let shorttype: string = (toShortEClass(type as any) || type).toUpperCase();\r\n        if (!state) state = store.getState();\r\n        // todo: make other m3 classes and make this generic like getPrimitiveType\r\n        return state.idlookup[\"Pointer_\"+ShortDefaultEClasses.EObject.toUpperCase()] as DClassifier;\r\n    }\r\n    static getPrimitiveType(type: AttribETypes | ShortAttribETypes, state?: DState): DClassifier {\r\n        let shorttype: string = (toShortEType(type as any) || type).toUpperCase();\r\n        if (!state) state = store.getState();\r\n        return state.idlookup[\"Pointer_\"+shorttype] as DClassifier;\r\n    }\r\n    static getAllPrimitiveTypes(): DClassifier[] {\r\n        let state: DState & GObject = store.getState();\r\n        const ptrs: Pointer<DClassifier, 0, 'N'> = Object.values((state).primitiveTypes);\r\n        const classifiers: DClassifier[] = ptrs.map<DClassifier>( (ptr) => state.idlookup[ptr] as DClassifier);\r\n        return classifiers;\r\n    }\r\n    static getFirstPrimitiveTypes(): DClassifier {\r\n        return Selectors.getAllPrimitiveTypes()[0];\r\n    }\r\n    static getRefEdges(): DRefEdge[] {\r\n        const state: DState & GObject = store.getState();\r\n        const pointers: Pointer<DRefEdge, 0, 'N', LRefEdge> = Object.values((state).refEdges);\r\n        const dRefEdges: DRefEdge[] = pointers.map<DRefEdge>( (ptr) => state.idlookup[ptr] as DRefEdge);\r\n        return dRefEdges;\r\n    }\r\n    static getField(field: string): string[] {\r\n        let state: DState & GObject = store.getState();\r\n        const pointers: Pointer<DModelElement, 0, 'N'> = Object.values((state)[field]);\r\n        return pointers;\r\n    }\r\n\r\n    static getAllAttributes(): string[] {\r\n        const state: DState = store.getState();\r\n        return Object.values((state).attributes);\r\n    }\r\n    static getAllEnumLiterals(): string[] {\r\n        const state: DState = store.getState();\r\n        return Object.values((state).enumliterals);\r\n    }\r\n    static getAllReferences(): string[] {\r\n        const state: DState = store.getState();\r\n        return Object.values((state).references);\r\n    }\r\n    // static getAllReferenceEdges(): string[] { const state: DState = store.getState(); return Object.values((state).refEdges); }\r\n    static getAllClasses(): string[] {\r\n        const state: DState = store.getState();\r\n        return Object.values((state).classs);\r\n    }\r\n    static getReturnTypes(): LClass[] {\r\n        const state: DState = store.getState();\r\n        return LPointerTargetable.from(Object.values((state).returnTypes));\r\n    }\r\n\r\n    static getAllClassesWithoutPrimitive(): string[] {\r\n        // this solution does not look good. what if a primitive type is inserted at runtime in between?\r\n        // coould reach the same goal by taking all Classes of a model (m2), excluding classes from other models (types are classes from m3 model)\r\n        const state: DState = store.getState();\r\n        const classList: string[] = Object.values((state).classs);\r\n        classList.splice(0, Selectors.getAllPrimitiveTypes().length);\r\n        /* todo: need to change it in something like this once cross-references between models and instances are implemented\r\n        const m2: LModel;\r\n        m2.isInstanceOf = m3 as LModel;\r\n        m2.isInstanceOf.classes;*/\r\n\r\n        return classList;\r\n    }\r\n\r\n    static getAllEnumerators(flag = false): string[] {\r\n        const state: DState = store.getState();\r\n        return Object.values((state).enumerators);\r\n    }\r\n    static getAllPackages(): string[] {\r\n        const state: DState = store.getState();\r\n        return Object.values((state).packages);\r\n    }\r\n\r\n    static getAllParameters(): string[] {\r\n        const state: DState = store.getState();\r\n        return Object.values((state).parameters);\r\n    }\r\n    static getAllOperations(): string[] {\r\n        const state: DState = store.getState();\r\n        return Object.values((state).operations);\r\n    }\r\n\r\n    static getDElement<T extends DModelElement>(pointer: string): T {\r\n        const state: DState & GObject = store.getState();\r\n        const dElement: T = state.idlookup[pointer] as T;\r\n        return dElement;\r\n    }\r\n\r\n    static getAllMetamodels(): LModel[] {\r\n        const state: DState = store.getState();\r\n        const dModels = Object.values((state).m2models);\r\n        return LPointerTargetable.fromPointer(dModels);\r\n    }\r\n\r\n    static getAllModels(): LModel[] {\r\n        const state: DState = store.getState();\r\n        const dModels = Object.values((state).m1models);\r\n        return LPointerTargetable.fromPointer(dModels);\r\n    }\r\n\r\n    //Giordano: end\r\n\r\n    static getVertex<W extends boolean = true, RP extends boolean = true>(wrap?: W /* = true */, resolvePointers?: RP /**/):\r\n        W extends false ? (RP extends false ? Pointer<DVoidVertex, 1, 1, LVoidVertex>[] : DVoidVertex[]) : LVoidVertex[] {\r\n        const state: DState = store.getState();\r\n        let ptrs: Pointer<DVoidVertex>[] = [];\r\n\r\n        U.ArrayMerge0(false, ptrs,\r\n            // Object.values(state.graphs || {}),\r\n            Object.values(state.voidvertexs || {}),\r\n            Object.values(state.vertexs || {}),\r\n            Object.values(state.graphvertexs || {}),\r\n            Object.values(state.edgepoints || {}));\r\n\r\n        console.log('selector getvertex: ', {ptrs, g: Object.values(state.graphs || {}), vv:Object.values(state.voidvertexs || {}), v:Object.values(state.vertexs || {}), gv:Object.values(state.graphvertexs || {}), ep:Object.values(state.edgepoints || {})});\r\n        if (wrap === undefined || wrap === true) return ptrs.map( p => DPointerTargetable.wrap(p)) as any[];\r\n        if (resolvePointers === undefined || resolvePointers === true) return ptrs.map( r => state.idlookup[r]) as any[];\r\n        return ptrs as any[];\r\n    }\r\n\r\n    static getAll<D extends DPointerTargetable, L extends LPointerTargetable, DT extends typeof DPointerTargetable = typeof DPointerTargetable,\r\n        W extends undefined | true | false = false, RP extends undefined | true | false = true, RET = W extends false ? (RP extends false ? Pointer<D, 1, 1, L> : D) : L>\r\n        (Classe?: DT, condition?: (e:RET) => boolean, state?: DState, resolvePointers?: RP /**/, wrap?: W /* = true */): RET[] {\r\n        if (!state) state = store.getState();\r\n        let GClass = (Classe as GObject) || {name:\"idlookup\", cname:\"idlookup\"};\r\n        const className: string = (GClass?.staticClassName || GClass.cname).toLowerCase();\r\n        const allIdByClassName: Pointer<D, 1, 1, L>[]\r\n            = (state as GObject)[className]\r\n            || (state as GObject)[className.substr(1)]\r\n            || (state as GObject)[className + 's']\r\n            || (state as GObject)[className.substr(1) + 's'];\r\n        Log.exDev(!allIdByClassName, 'cannot find store key:', {state, className, Classe});\r\n        let allDByClassName: D[] | null = null;\r\n        let allLByClassName: L[] | null = null;\r\n        if (resolvePointers || wrap) {\r\n            allDByClassName = allIdByClassName.map( (e) => (state as DState).idlookup[e] ) as D[];\r\n            if (wrap) {\r\n                allLByClassName = allDByClassName.map( e => DPointerTargetable.wrap(e)) as any as L[];\r\n            }\r\n        }\r\n        let ret: RET[] = (resolvePointers || wrap ? (wrap ? allLByClassName : allDByClassName) : allIdByClassName) as any[] as RET[];\r\n        if (!Array.isArray(ret)) ret = Object.values(ret).filter(e => e instanceof Object) as RET[];\r\n        if (condition) return ret.filter( e => condition(e));\r\n        return ret;\r\n    }\r\n\r\n    static getModels(condition?: (m: DModel) => boolean): DModel[] { return Selectors.getAll(DModel, undefined, undefined, true, false); }\r\n\r\n    static getModel(name: string, caseSensitive: boolean = false, wrap: boolean = false): DModel | LModel | null {\r\n        if (!caseSensitive) name = name.toLowerCase();\r\n        let ret = Selectors.getAll<DModel, LModel>(DModel, (d) => (caseSensitive ? d.name : d.name.toLowerCase()) === name, undefined, true, wrap as any)[0];\r\n        return ret;\r\n    }\r\n\r\n    static getName(d: DPointerTargetable | LPointerTargetable | string, s: DState): string {\r\n        if (!d) return d;\r\n        if (typeof d === 'string') return d;\r\n        d = (d as LPointerTargetable).__raw || d;\r\n        if (d.className !== DObject.cname) return (d as DNamedElement).name;\r\n        let dobject: DObject = d as DObject;\r\n        for (let feat_id of dobject.features) {\r\n            let feat: DNamedElement | undefined = s.idlookup[feat_id] as any;\r\n            if (feat && feat.name.toLowerCase() === 'name') return feat.name;\r\n        }\r\n        return dobject.name;\r\n    }\r\n    static getByName2(name?: string | DPointerTargetable | LPointerTargetable, dtype?: typeof DPointerTargetable | undefined | string, caseSensitive: boolean = false, s?:DState): DPointerTargetable | null {\r\n        console.log('getByName2', {name, dtype, caseSensitive});\r\n        if (!name) { return null; }\r\n        if (typeof name === 'object') { return name as DPointerTargetable; }\r\n        if (!s) s = store.getState();\r\n        //let ret: DPointerTargetable[];\r\n        let classname: string | undefined = (dtype as typeof DClass)?.cname || dtype as string; // Selectors.getName(dtype, s); this was if dtype was allowed to be a class (filter Humans instead of filter DObjects)\r\n        if (!caseSensitive) {\r\n            name = name.toLowerCase();\r\n            classname = classname?.toLowerCase();\r\n        }\r\n        for (let id in s.idlookup) {\r\n            let d = s.idlookup[id];\r\n            if (!d || typeof d !== 'object') continue;\r\n            console.log('getByName2 crash2', {d, name, dtype, caseSensitive});\r\n            if (classname !== (caseSensitive ? d.className : d.className.toLowerCase())) continue;\r\n            let dname = Selectors.getName(d, s);\r\n            if (!caseSensitive) dname = dname?.toLowerCase();\r\n            if (dname === name) return d;\r\n        }\r\n        return null;\r\n    }\r\n    static getByName(classe: typeof DPointerTargetable, name: string, caseSensitive: boolean = false, wrap: boolean = false): DPointerTargetable | LPointerTargetable | null {\r\n        return Selectors.getByField(classe, 'name', name, caseSensitive, wrap); }\r\n\r\n    static getByField(classe: typeof DPointerTargetable | undefined, field: string, value: string, caseSensitive: boolean = false, wrap: boolean = false): DPointerTargetable | LPointerTargetable | null {\r\n        if (!caseSensitive) value = value.toLowerCase();\r\n        let condition = (d: any) => {\r\n            let ret = (caseSensitive ? d[field] : d[field]?.toLowerCase()) === value;\r\n            console.log('filtering getall by field:', {d, dfield:d[field], value, ret});\r\n            return ret;\r\n        }\r\n        let ret = Selectors.getAll(classe, condition, undefined, true, wrap as any)[0];\r\n        return ret; }\r\n\r\n    static getViewIDs(condition?: (m: DModel) => boolean): Pointer<DViewElement>[] { return Selectors.getAll(DViewElement); }\r\n\r\n\r\n\r\n    private static queryJS(model: LModel, query: string): LPointerTargetable[] {\r\n        try {\r\n            return eval(query);\r\n        } catch (e) { return []; }\r\n    }\r\n    /*static getCurrentView(data: LModelElement): DViewElement {\r\n        Log.exDevv('todo');\r\n        return undefined as any;\r\n    }*/\r\n\r\n    private static matchesMetaClassTarget(v: DViewElement, data?: DModelElement | DGraphElement | undefined): number {\r\n        if (!v) return ViewEClassMatch.MISMATCH_PRECONDITIONS;\r\n        if (!v.appliableToClasses || !v.appliableToClasses.length) return ViewEClassMatch.IMPLICIT_MATCH;\r\n        if (!data) return ViewEClassMatch.MISMATCH_PRECONDITIONS;\r\n        let ThisClass: typeof DPointerTargetable = RuntimeAccessibleClass.get(data.className);\r\n        Log.exDev(!ThisClass, 'unable to find class type:', {v, data}); // todo: v = view appliable to DModel, data = proxy<LModel>\r\n        let gotSubclassMatch: boolean = false;\r\n        for (let classtarget of v.appliableToClasses) {\r\n            const ClassTarget: typeof DPointerTargetable = RuntimeAccessibleClass.get(classtarget);\r\n            if (ThisClass === ClassTarget) return ViewEClassMatch.EXACT_MATCH; // explicit exact match\r\n            if (!gotSubclassMatch && U.classIsExtending(ThisClass, ClassTarget)) gotSubclassMatch = true; // explicit subclass match\r\n            if (gotSubclassMatch) return ViewEClassMatch.INHERITANCE_MATCH;\r\n        }\r\n        return ViewEClassMatch.MISMATCH_PRECONDITIONS;\r\n }\r\n\r\n    private static isOfSubclass(data: DPointerTargetable, classTarget: string | typeof DPointerTargetable, acceptEquality: boolean = false): boolean {\r\n        let ThisClass: typeof DPointerTargetable = RuntimeAccessibleClass.get(data.className);\r\n        Log.exDev(!ThisClass, 'isOfSubclass() unable to find class type:', {data});\r\n        const ClassTarget: typeof DPointerTargetable = typeof classTarget === \"string\"? RuntimeAccessibleClass.get(classTarget) : classTarget;\r\n        if (ThisClass === ClassTarget) return acceptEquality;\r\n        return U.classIsExtending(ThisClass, ClassTarget);\r\n    }\r\n\r\n\r\n    static getViewByIDOrNameD(name: string | DViewElement | LViewElement, state?: DState): undefined | DViewElement {\r\n        if (!state) state = store.getState();\r\n        if (typeof name === \"object\") { return (name as any).__raw || name as any; }\r\n        if (state.idlookup[name]?.className === DViewElement.cname) return state.idlookup[name] as DViewElement;\r\n        let id = Selectors.getViewIdFromName(name, state);\r\n        if (id && state.idlookup[id]?.className === DViewElement.cname) return state.idlookup[id] as DViewElement;\r\n        return undefined;\r\n    }\r\n\r\n\r\n    // input: \"subview.subview2.targetview\"\r\n    // output: returns pointer to targetview\r\n    // path is not required to start with a root, it's also possible to start navigating from a subview (notviewpoint/model view)\r\n    // in case multiple matches are given due to incomplete path not starting from a viewpoint, the oldest matching view is returned.\r\n    static getViewIdFromName(namepath: string, state?: DState): undefined | Pointer<DViewElement> {\r\n        if (!state) state = store.getState();\r\n        let names: string[] = namepath.split(\".\");\r\n        let eligibleContainers: Pointer<DViewElement>[] = state.viewelements;\r\n        for (let i = 0; i < names.length; i++) {\r\n            let name = names[i];\r\n            eligibleContainers = eligibleContainers.filter(v => ((state as DState).idlookup[v] as DViewElement).name === name);\r\n            if (i === names.length-1 || eligibleContainers.length === 0) return eligibleContainers[0];\r\n            eligibleContainers = eligibleContainers.flatMap(v => Object.keys(((state as DState).idlookup[v] as DViewElement).subViews));\r\n        }\r\n        return undefined;\r\n    }\r\n\r\n    static getAllGraphElementPointers(): Pointer<DGraphElement>[] {\r\n        // graphelements = fields;\r\n        let state: DState = store.getState();\r\n        return [...state.graphs, ...state.graphvertexs, ...state.graphelements, ...state.vertexs, ...state.edgepoints, ...state.edges];\r\n    }\r\n\r\n    private static getFinalScore(entry: ViewScore, vid: Pointer<DViewElement>, parentView: DViewElement | undefined, dview: DViewElement): number {\r\n        if (entry.metaclassScore === ViewEClassMatch.MISMATCH_PRECONDITIONS) return ViewEClassMatch.MISMATCH;\r\n        if (entry.viewPointMatch === ViewEClassMatch.VP_MISMATCH) return ViewEClassMatch.MISMATCH;\r\n        if (entry.jsScore === ViewEClassMatch.MISMATCH_JS || entry.OCLScore === ViewEClassMatch.MISMATCH_JS) return ViewEClassMatch.MISMATCH;\r\n        let pvMatch: boolean = parentView ? vid in parentView.subViews : false;\r\n        let pvScore: number = pvMatch ? (parentView as DViewElement).subViews[vid] : 1;\r\n        let explicitprio: number;\r\n        if (typeof entry.jsScore === 'number') {\r\n            explicitprio = entry.jsScore;\r\n        } else if (dview.explicitApplicationPriority === undefined) {\r\n            // in editor put placeholder with computed expression\r\n            explicitprio = (dview.jsCondition?.length || 1) + (dview.oclCondition?.length || 1);\r\n        } else explicitprio = dview.explicitApplicationPriority;\r\n\r\n        //console.log(\"getFinalScore\", {entry, vid, dview, explicitprio, ep:dview.explicitApplicationPriority})\r\n\r\n        let defualtViewMalus = dview.id.indexOf('View') >= 0 ? 0 : 0.1;\r\n        return entry.viewPointMatch * entry.metaclassScore * pvScore * explicitprio + defualtViewMalus;\r\n        //score = precoditiom * paremtview(comfiguravle) * (explicitprio = jsValid*jslemgth + oclvalid*ocllemgth)\r\n        // or if jscomditiom returmed mumver --> * jsscore\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n/*\r\n    //this function handles: what i do when view changes? do i recompute the score?\r\n    static updateViewMatchings(dview: DViewElement, updatePreconditions: boolean, updateOCLScore: boolean, store: DState, updateManualViews: boolean = false, forcedUpdateViews: boolean = false): void {\r\n\r\n        //  event           observed change         ignore change\r\n        //  ocl             data                    node, view (except view.ocl)\r\n        //  jsCondition     all                     none\r\n        //  appliableTo     view.appliableto\r\n        // if (!forcedUpdateViews && (dview.oclUpdateCondition === 'manual') !== updateManualViews) return;\r\n        // modularize getscoresnew split in setpreconditionscore, setoclscorem, setjscscore, and call those only if observed stuff changed\r\n\r\n        const allNodes: DGraphElement[] = DPointerTargetable.fromPointer(Selectors.getAllGraphElementPointers());\r\n        //let dview = view.__raw;\r\n        let vid = dview.id; // optimize searching multiple usages and replacing\r\n\r\n        // filter alldata to exclude modelpieces that didn't pass the view.appyto check\r\n        // let oclData: (LModelElement)[] = allData.filter(l => {\r\n        let oclnodes: (DGraphElement)[] = allNodes.filter((dg: DGraphElement) => {\r\n            if (!dg) return false;\r\n            if (true) {\r\n                let d: DModelElement | undefined = dg.model ? DPointerTargetable.fromPointer(dg.model) : undefined;\r\n                let firstEvaluationForNodeView: boolean = false;\r\n                if (!transientProperties.node[dg.id]) { transientProperties.node[dg.id] = {viewScores: {}} as any; firstEvaluationForNodeView = true; }\r\n                if (!transientProperties.node[dg.id].viewScores[vid]) { transientProperties.node[dg.id].viewScores[vid] = {score: undefined} as any; firstEvaluationForNodeView = true; }\r\n\r\n                if (firstEvaluationForNodeView || updatePreconditions) {\r\n                    const oldScore = transientProperties.node[dg.id].viewScores[vid].score;\r\n                    const newScore = transientProperties.node[dg.id].viewScores[vid].score = this.matchesMetaClassTarget(dview, d);\r\n                    if (oldScore !== newScore) transientProperties.node[dg.id].stackViews = undefined as any; // force re-sorting\r\n                    // 67{}[]'?^&&||nb>\r\n                } /* else {\r\n                    if (!transientProperties.view[dview.id].oclUpdateCondition_PARSED( transientProperties.node[dg.id].viewScores[vid].)) return;\r\n                }* /\r\n                // no need to check if parentview changed as well. i optimized by not having parentview affect the numeric scores, but only the view queue array sorting\r\n\r\n                // transient.node[dg.id].viewScores[vid].score = MISSING (hasOwnProperty);    if the view or model is new and they are not yet evaluated.\r\n                // transient.node[dg.id].viewScores[vid].score = Number.NEGATIVE_INFINITY;    if pre-ocl conditions failed (view.appliableTo)\r\n                // transient.node[dg.id].viewScores[vid].score = 0;                           if preconditions are met, but ocl failed\r\n                // transient.node[dg.id].viewScores[vid].score = number ocl score;            if preconditions are met and ocl matched\r\n                // transient.node[dg.id].viewScores[vid].score = number precondition score;   if preconditions are met, and there is no ocl condition\r\n                // changed: matching score and ocl score are summed.\r\n                return transientProperties.node[dg.id].viewScores[vid].score !== undefined;\r\n            }\r\n\r\n            // if (model_viewstack[vid]) { filledElementsInOclData++; return l; } return undefined;\r\n        });\r\n        function mergeViewScores(preconditionScore: number, oclScore: number): number{ return preconditionScore + oclScore; }\r\n    }*/\r\n\r\n\r\n\r\n\r\n    static updateScores(data0: LModelElement | undefined, node: LGraphElement | undefined, nid: Pointer<DGraphElement>, pv: DViewElement | undefined, state: DState){\r\n        let needsorting: boolean = false;\r\n        let firstEvaluationForNode: boolean = false;\r\n        let firstEvaluationForNodeView: boolean = false;\r\n        let tn = transientProperties.node[nid];\r\n        //console.log('2302 0, getviews evaluating view ', {tn:(tn ? {...tn} : tn), nid});\r\n        if (!tn) { transientProperties.node[nid] = tn = new NodeTransientProperties(); firstEvaluationForNode = true; }\r\n        //console.log('2302 1, getviews evaluating view ' , {tn:(tn ? {...tn} : tn), nid});\r\n        let olddata = tn.viewSorted_modelused as LModelElement;\r\n        //let oldnode = transientProperties.node[nid]?.viewSorted_nodeused as LGraphElement;\r\n        const data: LModelElement = data0 as LModelElement;\r\n        // console.error('changed', {data, olddata, node, oldnode, cdata:data?.clonedCounter, colddata:olddata?.clonedCounter})\r\n        const pvid: Pointer<DViewElement> | undefined = pv?.id;\r\n        const oldpv: DViewElement | undefined = tn.viewSorted_pvid_used;\r\n        let datachanged: boolean = (!!data !== !!olddata) || !!(data && olddata) && (data.clonedCounter !== olddata.clonedCounter);\r\n        //let nodechanged: boolean = (!!node !== !!oldnode) || !!(node && oldnode) && (node.clonedCounter !== oldnode.clonedCounter);\r\n        let parentViewChanged: boolean = (pvid !== oldpv?.id || (!!(pv && oldpv) && oldpv.subViews !== pv.subViews)); // shallow comparison is fine.\r\n        if (parentViewChanged) tn.viewSorted_pvid_used = pv;\r\n        //if (nodechanged) transientProperties.node[nid].viewSorted_nodeused = node;\r\n        if (datachanged) tn.viewSorted_modelused = data;\r\n\r\n        // let nodechanged: boolean\r\n        // important to remember: how i'm using parentView in score and storage.\r\n        // i'm calculating and storing every score without parentView, then i apply it right before sorting the array,\r\n        // the enhanced value is not sored anyway but affects array sorting.\r\n        // so if parentView changes, or if his subviews changed, need to resort array without recomputing any score value.\r\n\r\n        //console.log('2302, getviews 2', {datachanged, nodechanged, olddata, oldnode, data, node, allViews: Selectors.getAllViewElements()});\r\n\r\n        if (!state) state = store.getState();\r\n        const allViews: DViewElement[] = Selectors.getAllViewElements(state);\r\n\r\n        const user = LUser.fromPointer(DUser.current);\r\n        const project = user.project as LProject;\r\n        let activevpid: Pointer<DViewElement> = project.activeViewpoint.id;\r\n        // check if scores needs to be updated\r\n        for (const dview of allViews) {\r\n            let vid = dview.id;\r\n            let tv = transientProperties.view[vid];\r\n            if (!tv) transientProperties.view[vid] = tv = {} as any;\r\n            //console.log('2302 2, getviews evaluating view ' + vid, {vid, dview, tn});\r\n            if (!tn?.viewScores) console.error('2302 3, getviews evaluating view ' + vid, {vid, dview, tn});\r\n            let tnv: ViewScore = tn.viewScores[vid];\r\n\r\n            // check initialization\r\n\r\n            if (!tnv) {\r\n                tn.viewScores[vid] = tnv = new ViewScore();\r\n                /*{\r\n                    score: ViewEClassMatch.NOT_EVALUATED_YET,\r\n                    metaclassScore: ViewEClassMatch.NOT_EVALUATED_YET,\r\n                    //jsScore:ViewEClassMatch.NOT_EVALUATED_YET,\r\n                    //OCLScore: ViewEClassMatch.NOT_EVALUATED_YET\r\n                } as any;*/\r\n                firstEvaluationForNodeView = true;\r\n            } else firstEvaluationForNodeView = tnv.metaclassScore === ViewEClassMatch.NOT_EVALUATED_YET; // todo: when changing view.appliableTo, delete all tnv using that view.\r\n\r\n            // don't match exclusive views from other vp\r\n            let dvp: DViewPoint = DPointerTargetable.fromPointer(dview.viewpoint, state);\r\n            let oldVpMatch: number = tnv.viewPointMatch;\r\n            // console.log(\"vp matching \" +vid, {vid, dvp, activevpid });\r\n            if (dvp.id === activevpid) tnv.viewPointMatch = ViewEClassMatch.VP_Explicit;\r\n            else if (dvp.id === 'Pointer_ViewPointDefault') tnv.viewPointMatch = ViewEClassMatch.VP_Default;\r\n            else if (!dvp.isExclusiveView) tnv.viewPointMatch = ViewEClassMatch.VP_Decorative;\r\n            else tnv.viewPointMatch = ViewEClassMatch.VP_MISMATCH;\r\n\r\n            if (!needsorting && (oldVpMatch !== tnv.viewPointMatch)) needsorting = true;\r\n            if (tnv.viewPointMatch === ViewEClassMatch.VP_MISMATCH) {\r\n                tnv.finalScore = ViewEClassMatch.VP_MISMATCH;\r\n                continue;\r\n            }\r\n\r\n\r\n            // check preconditions\r\n            if (firstEvaluationForNodeView) {\r\n                const oldScore = tnv.metaclassScore;\r\n                tnv.metaclassScore = this.matchesMetaClassTarget(dview, data?.__raw);\r\n                needsorting = true; // sorting is mandatory here because it's the first evaluation of node-vie\r\n                // if mismatch i stop computing the score.\r\n                if (tnv.metaclassScore === ViewEClassMatch.MISMATCH_PRECONDITIONS) {\r\n                    tnv.finalScore = ViewEClassMatch.MISMATCH;\r\n                    continue;\r\n                }\r\n            } else if (tnv.metaclassScore === ViewEClassMatch.MISMATCH_PRECONDITIONS) continue;\r\n\r\n            if (true) {\r\n                // this needs to be called not only if datachanged || nodechanged, but everytime in case it is a reference like data.$value.name.length\r\n                // also his performances are so fast that it might be more costly to check if it's supposed to be reevaluated than just calling it.\r\n                let jsScoreChanged: boolean = Selectors.updateJSScore(node, data, dview, tv, tnv);\r\n                if (!needsorting && jsScoreChanged) needsorting = true;\r\n                // if mismatch i stop computing the score.\r\n                if (tnv.jsScore === ViewEClassMatch.MISMATCH_JS) { tnv.finalScore = ViewEClassMatch.MISMATCH; continue; }\r\n            }\r\n\r\n            // check pre-ocl guard\r\n            // if (!tv.oclUpdateCondition_PARSED(data, olddata)) continue;\r\n\r\n            if (datachanged || tnv.OCLScore === ViewEClassMatch.NOT_EVALUATED_YET) {\r\n                // check ocl: this can lead to mis-updating if ocl queries a reference.\r\n                // but OCL is computationally heavy, so i decided it is now a requirement to update the model to reevaluate ocl.\r\n                let oldScore = tnv.OCLScore;\r\n                tnv.OCLScore = OCL.test(data, dview, node)//Selectors.calculateOCLScore({data, node, dview});\r\n                if (vid === 'Pointer_fallback'){\r\n                    console.log('fallback ocl', {oldScore, newScore:tnv.OCLScore, data, dview});\r\n                }\r\n                tv.oclChanged = false;\r\n                if (!needsorting && tnv.OCLScore !== oldScore) needsorting = true;\r\n                if (tnv.OCLScore === ViewEClassMatch.MISMATCH_OCL) { tnv.finalScore = ViewEClassMatch.MISMATCH; continue; }\r\n            }\r\n        }\r\n\r\n        if (parentViewChanged) needsorting = true; // scores saved in dictionaries are the same, but score in final sorted array changed.\r\n        return needsorting;\r\n    }\r\n\r\n    // get final viewstack for a node, also updates OCL scores if needed because of a change in model or parentView (NOT from a change in view)\r\n    static getAppliedViewsNew({data:data0, node, pv, nid}:{ node: LGraphElement | undefined; data: LModelElement | undefined; pv: DViewElement | undefined; nid: Pointer<DGraphElement>}): NodeTransientProperties {\r\n        // console.trace('2302, getviews', {tnode: transientProperties.node[nid], nid, pv})\r\n        let state = store.getState();\r\n        let needsorting: boolean = Selectors.updateScores(data0, node, nid, pv, state);\r\n\r\n        let tn: NodeTransientProperties = transientProperties.node[nid]; // needs to be placed after updateScores() which will initialize it.\r\n        if (!needsorting && tn.needSorting) needsorting = tn.needSorting;\r\n\r\n\r\n\r\n        type ViewScoreEntry = {element: Pointer<DViewElement>, score: number, view: LViewElement};\r\n        if (needsorting || !tn.stackViews) {\r\n            let mainViews: ViewScoreEntry[] = [];\r\n            let decorativeViews: ViewScoreEntry[] = [];\r\n            for (let vid of Object.keys(tn.viewScores)) {\r\n                let tnv = tn.viewScores[vid];\r\n                const dview: DViewElement = DPointerTargetable.fromPointer(vid, state);\r\n                if (!dview) console.error('missing view, is it an old save with less default views?', {dview, vid, state});\r\n                if (!dview) continue;\r\n\r\n                const score = tnv.finalScore = Selectors.getFinalScore(tnv, vid, pv, dview);\r\n                if (!(score > 0)) continue; // do not flip to <=, because undefined and NEGATIVE_INFINITY always compute to false.\r\n                (dview.isExclusiveView ? mainViews : decorativeViews).push( {element:vid, score, view: LPointerTargetable.fromD(dview)} );\r\n            }\r\n            decorativeViews.sort((s1, s2)=> s2.score - s1.score); // sorted from biggest to smallest\r\n            mainViews.sort((s1, s2)=> s2.score - s1.score); // sorted from biggest to smallest\r\n\r\n            // Log.exDev(!mainViews[0], 'cannot find a matching main view', {mainViews, decorativeViews, data0, scores: tn.viewScores})\r\n            tn.mainView = mainViews[0]?.view;\r\n            tn.validMainViews = mainViews.map((s)=> s.view); // this have duplicates of newly created elements\r\n            tn.stackViews = decorativeViews.map((s)=> s.view);\r\n        }\r\n        // chamges to view or ocl comditiom are mot hamdled here, ut om multple mp/modes a omce\r\n        //nb{}[]\r\n\r\n        // if data or view changed update the score dict, them re-sort the view arr first, fimally update Sorted_modelused, Sorted_modelused\r\n        // console.log('2302 getviews ret', {dn: data?.name, data, stack: transientProperties.node[nid].stackViews, stackn: transientProperties.node[nid].stackViews.map(v => v.name), scores: transientProperties.node[nid]});\r\n\r\n        // throw new Error(\"stop debug\");\r\n        return tn;\r\n\r\n    }\r\n\r\n    static getAllMP(state?: DState): DModelElement[] {\r\n        if (!state) state = store.getState();\r\n        let allD: DPointerTargetable[] = Object.values(state.idlookup);\r\n        return allD.filter( (d: DPointerTargetable) => U.isObject(d) && Selectors.isOfSubclass(d, DModelElement)) as DModelElement[]; }\r\n\r\n    static toObject<D extends DPointerTargetable>(ptrs: Pointer<D>[], state?: DState):D[] {\r\n        if (!state) state = store.getState();\r\n        return ptrs.map(p => (state as DState).idlookup[p]) as D[]; }\r\n\r\n    static wrap<D extends DPointerTargetable, L extends LPointerTargetable>(arr: (Pointer<D, 1, 1, L> | D)[], state?: DState): L[] {\r\n        if (!arr.length) return [];\r\n        if (!state) state = store.getState();\r\n        let objarr: D[];\r\n        if (typeof arr[0] === \"string\") { objarr = Selectors.toObject(arr as string[], state); }\r\n        else objarr = arr as D[];\r\n        return objarr.map(p => RuntimeAccessibleClass.wrap(p)) as L[]; }\r\n\r\n    static unwrap<D extends DPointerTargetable, L extends LPointerTargetable>(arr:L[]): D[] { return arr.map( (a)=> a.__raw) as any[]; }\r\n    static getSubNodeElements(forGraph: Pointer<DGraph, 1, 1>, asPointers: boolean = false, wrap: boolean = false): Pointer<DGraphElement>[] | DGraphElement[] | LGraphElement[] {\r\n        const state : DState = store.getState();\r\n        const g: DGraph = state.idlookup[forGraph] as DGraph;\r\n        if (asPointers) return g.subElements;\r\n        const subelements: DGraphElement[] = g.subElements.map( geid => state.idlookup[geid]) as DGraphElement[];\r\n        if (wrap) return subelements.map<LGraphElement>( (ge) => LPointerTargetable.from(ge));\r\n        return subelements; }\r\n\r\n\r\n\r\n\r\n    //// giordano part\r\n\r\n\r\n\r\n    public static getAllPackageClasses(id: string): LClass[] {\r\n        const data = LPointerTargetable.from(id) as GObject;\r\n        let lPackage : LPackage | undefined;\r\n        const classes: LClass[] = [];\r\n        if (data.className === \"DReference\") {\r\n            const lClass: LClass = LPointerTargetable.from(data.father);\r\n            lPackage = LPointerTargetable.from(lClass.father);\r\n        }\r\n        if (data.className === \"DParameter\") {\r\n            const lOperation: LOperation = LPointerTargetable.from(data.father);\r\n            const lClass: LClass = LPointerTargetable.from(lOperation.father);\r\n            lPackage = LPointerTargetable.wrap(lClass.father);\r\n        }\r\n        if (data.className === \"DOperation\") {\r\n            const lClass: LClass = LPointerTargetable.from(data.father);\r\n            lPackage = LPointerTargetable.wrap(lClass.father);\r\n        }\r\n        if (lPackage) {\r\n            for(let classifier of lPackage.classifiers) {\r\n                const lClassifier: LClass | LEnumerator = LPointerTargetable.from(classifier);\r\n                if(lClassifier.className === \"DClass\") classes.push(lClassifier as LClass);\r\n            }\r\n        }\r\n        return classes;\r\n    }\r\n    public static getAllPackageEnumerators(id: string): LEnumerator[] {\r\n        const data = LPointerTargetable.from(id) as GObject;\r\n        let lPackage : LPackage | undefined;\r\n        const enumerators: LEnumerator[] = [];\r\n        if(data.className === \"DAttribute\") {\r\n            const lClass: LClass = LPointerTargetable.from(data.father);\r\n            lPackage = LPointerTargetable.from(lClass.father);\r\n        }\r\n        if(data.className === \"DParameter\") {\r\n            const lOperation: LOperation = LPointerTargetable.from(data.father);\r\n            const lClass: LClass = LPointerTargetable.from(lOperation.father);\r\n            lPackage = LPointerTargetable.from(lClass.father);\r\n        }\r\n        if(data.className === \"DOperation\") {\r\n            const lClass: LClass = LPointerTargetable.from(data.father);\r\n            lPackage = LPointerTargetable.from(lClass.father);\r\n        }\r\n        if(lPackage) {\r\n            for(let classifier of lPackage.classifiers) {\r\n                const lClassifier: LClass | LEnumerator = LPointerTargetable.from(classifier);\r\n                if(lClassifier.className === \"DEnumerator\") enumerators.push(lClassifier as LEnumerator);\r\n            }\r\n        }\r\n        return enumerators;\r\n    }\r\n\r\n    private static updateJSScore(node: LGraphElement | undefined, data: LModelElement | undefined, dview: DViewElement, tv: ViewTransientProperties, tnv: ViewScore) {\r\n        let oldjsScore = tnv.jsScore;\r\n        let jsConditionChanged: boolean = tv.jsConditionChanged;\r\n        tv.jsConditionChanged = false;\r\n\r\n        // tnv.jsScore = ViewEClassMatch.NOT_EVALUATED_YET as any as number;\r\n        let printstuff = {name: data?.name, jsc:tv.jsCondition, tv:{...tv}, data:data&&data.__raw, node:node&&{...node.__raw}, nerr: (node as any)?.errors}\r\n        if (tv.jsCondition) {\r\n            try {\r\n                tnv.jsScore = tv.jsCondition({data, node, view: LPointerTargetable.fromD(dview), constants: tv.constants});\r\n                // if (tnv.jsScore === true) tnv.jsScore = dview.jsCondition.length;\r\n                switch (typeof tnv.jsScore) {\r\n                    case \"boolean\": // bool is fine if true\r\n                        if (!tnv.jsScore) tnv.jsScore = ViewEClassMatch.MISMATCH_JS;\r\n                        break;\r\n                    case \"number\": // number is fine if not NaN and > 0\r\n                        if (isNaN(tnv.jsScore) || tnv.jsScore < 0) tnv.jsScore = ViewEClassMatch.MISMATCH_JS;\r\n                        break;\r\n                    default:\r\n                        tnv.jsScore = ViewEClassMatch.MISMATCH_JS;\r\n                        break;\r\n                }\r\n            }\r\n            catch (e:any) { // crash = mismatch\r\n                Log.ee(\"failed to evaluate jsCondition: \" + e.message?.split(\"\\n\")[0], {e, data, node, tnv, jsc:tv.jsCondition+''});\r\n                tnv.jsScore = ViewEClassMatch.MISMATCH_JS;\r\n            }\r\n        } else tnv.jsScore = true; // missing condition = match\r\n\r\n        // jsConditionChanged: because even if score didn't change, if jsc.length changed the final computed score is affected\r\n        return jsConditionChanged || tnv.jsScore !== oldjsScore;\r\n    }\r\n}\r\n\r\n(window as any).Selectors = Selectors;\r\n\r\nclass Scored<T extends GObject> {\r\n    constructor(public score: number, public element: T) {}\r\n}\r\n","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\common\\U.tsx",["816","817","818","819","820","821","822","823","824","825","826","827","828","829","830","831","832","833","834","835","836","837","838","839","840","841","842","843","844","845","846","847","848","849","850","851","852","853","854","855","856"],"// import * as detectzoooom from 'detect-zoom'; alternative: https://www.npmjs.com/package/zoom-level\r\n// import {Mixin} from \"ts-mixer\";\r\nimport {Any, DGraphElement, LGraphElement} from \"../joiner\";\r\nimport {\r\n    AbstractConstructor,\r\n    Constructor,\r\n    Dictionary,\r\n    DocString,\r\n    GObject,\r\n    Pointer,\r\n    PrimitiveType,\r\n    Temporary,\r\n    LPointerTargetable,\r\n    DPointerTargetable,\r\n    Log,\r\n    EMeasurableEvents,\r\n    TRANSACTION,\r\n    SetRootFieldAction,\r\n    LoadAction,\r\n    KeyDownEvent, KeyUpEvent,\r\n    stateInitializer,\r\n    DUser,\r\n    DProject, D, L, ClickEvent,\r\n} from \"../joiner\";\r\nimport {\r\n    DClassifier,\r\n    DModelElement, DState,\r\n    Json,\r\n    JsType,\r\n    LClassifier,\r\n    LModelElement,\r\n    LNamedElement,\r\n    LogicContext,\r\n    MyError,\r\n    RuntimeAccessible,\r\n    RuntimeAccessibleClass, store,\r\n    windoww\r\n} from \"../joiner\";\r\nimport Swal from \"sweetalert2\";\r\nimport Storage from '../data/storage';\r\nimport {compressToUTF16, decompressFromUTF16} from \"async-lz-string\";\r\nimport {NumberControl, PaletteControl, PaletteType, PathControl, StringControl} from \"../view/viewElement/view\";\r\nimport tinycolor from \"tinycolor2\";\r\nimport util from \"util\";\r\nimport Convert from \"ansi-to-html\";\r\nimport React, {isValidElement} from \"react\";\r\nimport IoT from \"../iot/IoT\";\r\nimport Collaborative from \"../components/collaborative/Collaborative\";\r\nimport {Await, NavigateFunction} from \"react-router-dom\";\r\n// var Convert = require('ansi-to-html');\r\n// import KeyDownEvent = JQuery.KeyDownEvent; // https://github.com/tombigel/detect-zoom broken 2013? but works\r\n\r\n// console.warn('ts loading U log');\r\n\r\n@RuntimeAccessible('Color')\r\nexport class Color {\r\n    r: number;\r\n    g: number;\r\n    b: number;\r\n\r\n    constructor(r: number, g: number, b: number) {\r\n        this.r = r;\r\n        this.g = g;\r\n        this.b = b;\r\n    }\r\n\r\n    static fromHex(hex:string): Color {\r\n        return undefined as any;\r\n    }\r\n    static fromHLS({h, l, s}:{h: number, l:number, s: number}): Color {\r\n        return undefined as any;\r\n    }\r\n    getHex(): string {\r\n        return undefined as any;\r\n    }\r\n    mixWith(c: Color): void {\r\n\r\n    }\r\n    getHLS(): {h: number, l:number, s: number} {\r\n        return undefined as any;\r\n    }\r\n    duplicate(): Color {\r\n        return undefined as any;\r\n    }\r\n}\r\n\r\n@RuntimeAccessible('R')\r\nexport class R{\r\n    public static cname: string = 'R';\r\n\r\n    // from: 1.com/2/3\r\n    // /5       --> 1.com/5/\r\n    // ./5      --> 1.com/1/2/3/5\r\n    // 5        --> 1.com/1/2/3/5\r\n    //\r\n    public static open_new_page(url: string): void {\r\n        window.open(url, '_blank');\r\n    }\r\n    public static replace(path: string): void {\r\n        window.location.replace(path);\r\n    }\r\n\r\n    public static navigate(path: string, refresh: (true|NavigateFunction) = true): void {\r\n        // window.location.assign = window.location = window.location.href = window.open(url, '_self')\r\n        console.warn('R.navigate()', {path, refresh})\r\n        //if (path.indexOf('allProject') >= 0) return;\r\n        let debug: false = true as any;\r\n        if (debug || refresh === true ) {\r\n            if (path[0] !== '/') path = '/'+path;\r\n            path = '/#' + path;\r\n            console.log('navigating: ', {path, url:window.location.origin + path, currHash:window.location.hash});\r\n            if ('/'+window.location.hash === path) return;\r\n            U.navigating = true;\r\n            window.location.href = window.location.origin + path;\r\n            window.location.reload(); // i think this is causing a firefox bug, it refreshes old url\r\n        }\r\n        else refresh(path); // useNavigator()(path);\r\n    }\r\n}\r\n\r\n@RuntimeAccessible('U')\r\nexport class U {\r\n    private static clickedOutsideMap: WeakMap<Element, (e: Element, evt: JQuery.ClickEvent)=>void> = null as any;\r\n    private static clickedOutsideMapEntries: Element[] = null as any; // because weak maps are not iterable and cannot get a list of keys\r\n\r\n\r\n    // to register call with both parameters. to remove a listener call with callback=undefined\r\n    public static navigating: boolean = false; // if i'm changing page, i stop rendering to prevent meaningless errors.\r\n    static debug: boolean = false;\r\n    static clickedOutside(currentTarget0: Element|Any<Event>, callback: undefined | ((e: Element, evt: JQuery.ClickEvent) => void)) {\r\n        if (!currentTarget0) return;\r\n        let currentTarget: Element = (currentTarget0 as any)?.currentTarget || currentTarget0 as any;\r\n        if (!currentTarget) return;\r\n        let map = U.clickedOutsideMap;\r\n        let arr = U.clickedOutsideMapEntries;\r\n        if (!map) {\r\n           U.clickedOutsideMap = map = new WeakMap();\r\n           U.clickedOutsideMapEntries = arr = [];\r\n           document.addEventListener('click', U.clickedOutsideCallback, true); // bubbling event! called before normal events.\r\n           // $(document).on('click', U.clickedOutsideCallback);\r\n        }\r\n        console.log('clickedOutside registering', {currentTarget, callback, map, arr});\r\n        if (callback) {\r\n            map.set(currentTarget, callback);\r\n            if (!arr.includes(currentTarget)) arr.push(currentTarget);\r\n        }\r\n        else {\r\n            map.delete(currentTarget);\r\n            U.arrayRemoveAll(arr, currentTarget);\r\n        }\r\n    }\r\n\r\n    //private static lastClicked?: Element;\r\n    private static lastClickedAncestors: Element[] = [];\r\n    private static lastClickedTime: number = 0;\r\n    public static userHasInteracted: boolean = false;\r\n    public static isProjectModified: boolean = false;\r\n    private static clickedOutsideCallback(e: any & ClickEvent){\r\n        let target = e.target as Element;\r\n        let clickedAncestors = U.ancestorArray(target, undefined, true);\r\n\r\n        // when i click on something containined in a label+input, the event fires twice:\r\n        // once for actually clicked element and 1 emulating a click on input/select\r\n        if ((Date.now() - U.lastClickedTime < 300)){\r\n            let labelAncestors = clickedAncestors.filter((e, i) => i>0 && e.tagName === 'LABEL');\r\n            if (U.lastClickedAncestors.filter(e=>labelAncestors.includes(e))) return;\r\n            //if (labelAncestors.includes(U.lastClicked)) return;\r\n        }\r\n        //U.lastClicked = target;\r\n        U.lastClickedAncestors = clickedAncestors;\r\n        U.lastClickedTime = Date.now();\r\n        let map = U.clickedOutsideMap;\r\n        let arr = U.clickedOutsideMapEntries;\r\n\r\n        // console.log('clickedOutside callback exec', {e, target, clickedAncestors, arr, map, callbacks: arr.map(e=>map.get(e))});\r\n        for (let elem of arr) {\r\n            let callback = map.get(elem);\r\n            if (!callback) continue;\r\n            // if (target === elem) continue;\r\n            if (clickedAncestors.includes(elem)) continue;\r\n            callback(target, e);\r\n        }\r\n    }\r\n\r\n    static publish(topic: string, value: unknown) {\r\n        if(!IoT.client.connected) {\r\n            SetRootFieldAction.new('alert', '3:Cannot connect to broker!:','');\r\n            return;\r\n        }\r\n        IoT.client.emit('push-action', {\r\n            topic: topic,\r\n            value: JSON.stringify(value)\r\n        });\r\n        SetRootFieldAction.new('alert', '1:Publish done!:','');\r\n    }\r\n\r\n    static extractValueFromTopic(obj: Dictionary, path: string) {\r\n        const keys = path.split('.');\r\n        let result = obj;\r\n        for (let key of keys) {\r\n            result = result[key];\r\n            if (result === undefined) return undefined;\r\n        }\r\n        return result;\r\n    }\r\n\r\n    static extractTopics(obj: Dictionary, parentKey = ''): string[] {\r\n        let keys: string[] = [];\r\n        for (let key in obj) {\r\n            if (typeof obj[key] === 'object' && !Array.isArray(obj[key]))\r\n                keys = keys.concat(this.extractTopics(obj[key], `${parentKey}${key}.`));\r\n            else keys.push(parentKey + key);\r\n        }\r\n        return keys.filter(k => k !== 'clonedCounter');\r\n    }\r\n\r\n    static keepKeys(dict: GObject, keys: string[]): Dictionary {\r\n        return Object.fromEntries(\r\n            Object.entries(dict).filter(([key]) => keys.includes(key))\r\n        );\r\n    }\r\n\r\n    static alert(type: 'i'|'w'|'e', title: string, message: string = ''): void {\r\n        SetRootFieldAction.new('alert', `${type}:${title}:${message}`, '');\r\n    }\r\n\r\n    static dialog(message: string, label: string, action: () => any): void {\r\n        windoww.dialog_action = action;\r\n        SetRootFieldAction.new('dialog', `${message}:${label}`, '');\r\n    }\r\n\r\n    static async decompressState(state: string): Promise<string> {\r\n        return await decompressFromUTF16(state);\r\n    }\r\n    static async compressedState(id: Pointer<DProject>): Promise<string> {\r\n        const state = store.getState();\r\n        const idlookup: Record<Pointer<DPointerTargetable>, DPointerTargetable> = {};\r\n        for(const [pointer, object] of Object.entries(state.idlookup)) {\r\n            if(object.className === DProject.name && pointer !== id) continue;\r\n            idlookup[pointer] = object;\r\n        }\r\n        (state.idlookup[id] as DProject).state = '';\r\n        state.projects = [id];\r\n        state.idlookup = idlookup;\r\n        return await compressToUTF16(JSON.stringify(state));\r\n    }\r\n    static isOffline(): boolean {\r\n        return Storage.read('offline') === true;\r\n    }\r\n    static resetState(): void {\r\n        LoadAction.new({...DState.new(), 'isLoading':true});\r\n        stateInitializer().then(() => SetRootFieldAction.new('isLoading', false));\r\n    }\r\n\r\n    public static inspect(object: any, showHidden?: boolean, depth?: number | null, color?: boolean): string {\r\n        let o0 = object;\r\n        object = object?.__raw || object;\r\n        if (Array.isArray(object)) object = object.map(o => o?.__raw || o);\r\n        // todo: use lodash \"clonedeepwith\" to clean proxies\r\n        console.error(\"inspect\", {o0, object});\r\n        return util.inspect(object, showHidden, depth, color);\r\n    }\r\n\r\n    public static objectInspect(val: GObject, depth: number = 2, color: boolean = true, showHidden = true): string{\r\n        if (typeof val === 'string') return val;\r\n        let ansiConvert = (window as any).ansiConvert;\r\n        if (!ansiConvert) (window as any).ansiconvert = ansiConvert = new Convert();\r\n        return U.replaceAll(ansiConvert.toHtml(U.inspect(val, showHidden, depth, color)),\r\n            \"style=\\\"color:#FFF\\\"\", \"style=\\\"color:#000\\\"\");\r\n    }\r\n\r\n    // exponential: undefined = only if it's over digits. false = never, true = always.\r\n    public static cropNum(num: number|undefined|null, digits: number=5, exponential?: boolean, atLeast1Decimal:boolean=true): number | string{\r\n        if (!digits || num === null || num === undefined || isNaN(num)) return num as any;\r\n        let sign = (num < 0 ? '-' : '');\r\n        if (sign.length) digits--;\r\n        if (exponential) return num.toExponential(digits-1);\r\n        else if (exponential === undefined) {\r\n            if (digits <= 4) digits = 4; // 4 extra chars for .e+x\r\n            // NB: i'm not checking if exponent is over 1 char (tens of billions)\r\n            let limit = 10**(digits);\r\n            if (num >= limit || -num >= limit) return num.toExponential(Math.max(0, digits-5));\r\n        }\r\n        let intpart: number = Math.trunc(num);\r\n        if (intpart === num) { return num; }\r\n        /*let s = ''+num;\r\n        let excess = (s.length - digits);\r\n        if (excess <= 0) return num;*/\r\n        // must cut decimals\r\n        let intpart_s = intpart + '';\r\n        let allowedDecimals = digits - intpart_s.length - 1;\r\n\r\n        // console.log('cropnum', {digits,num, intpart, is:intpart_s.length, allowedDecimals});\r\n        if (allowedDecimals <= 0) {\r\n            if (!atLeast1Decimal) return intpart;\r\n            else allowedDecimals = 1;\r\n        }\r\n        let decimalPart = num%1;\r\n        //console.log('cropnum', {allowedDecimals, decimalPart});\r\n\r\n        // nb: here in concatenation ((-0)+'') --> '0'. it will lose sign on cropNum(x) with x € (-1, 0)\r\n        // so need to check if it was negative\r\n        // let exp = (10**allowedDecimals);\r\n        // return sign + (intpart_s)+'.'+ (Math.round(decimalPart * exp)/exp).substring(2, allowedDecimals+2);\r\n        let decimal_s = decimalPart+'';\r\n        let firsti = sign.length + 2; // 0. in decimal string\r\n        let lasti = allowedDecimals + firsti;\r\n        while (--lasti > firsti && decimal_s[lasti] === '0') {   }\r\n        if (++lasti <= firsti) return intpart;\r\n        let ret = +((num < 0 && intpart === -0 ? '-' : '') + (intpart_s)+'.'+ (decimal_s.substring(firsti, lasti)));\r\n        // console.log('cropNum', {num, ret, oth:{sign, firsti, lasti, decimal_s, intpart_s}});\r\n        return ret;\r\n    }\r\n    public static cropStr(msg: string, linesStart: number = 5, linesEnd: number = 5, stringRowStart: number = 25, stringRowEnd: number = 25): string{\r\n        let arr = msg.split('\\n');\r\n        if (linesEnd + linesStart + 1 < arr.length) {\r\n            //arr = arr.slice(0, 10) + arr.slice(10, 0);\r\n            arr.splice(linesStart, arr.length - linesStart - linesEnd, '...')\r\n        }\r\n        let ret: string = '';\r\n        let i = 0;\r\n        for (let line of arr){\r\n            if (stringRowEnd + stringRowStart + 1 < line.length) {\r\n                ret += line.substring(0, stringRowStart) + '...' + line.substring(line.length - stringRowEnd) + (i === arr.length-1 ?'':'\\n');\r\n            }\r\n            else ret += line + (i === arr.length-1 ?'':'\\n');\r\n            i++;\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    // eseguire una funzione costa in performance, anche se è brutto fare questi cast\r\n    static wrapper<T>(obj: any): T {\r\n        return obj as unknown as T;\r\n    }\r\n    // mi sa che c'era un metodo l.__serialize or something\r\n    static json(dElement: GObject): Json {\r\n        return JSON.parse(JSON.stringify(dElement.__raw));\r\n    }\r\n\r\n    static hexToPalette(...hexs: string[]): PaletteControl{\r\n        return {type: \"color\", value: hexs.map( hex => {\r\n                if (hex[0] === '#') hex = hex.substring(1);\r\n                let r: number, g: number, b: number, a: number = 1;\r\n                if (hex.length === 4) {\r\n                    a = Number.parseInt('0x' + hex[3] + hex[3])/255;\r\n                    hex = hex.substring(0, 3);\r\n                }\r\n                if (hex.length === 7) {\r\n                    a = Number.parseInt('0x' + hex[5] + hex[6])/255;\r\n                    hex = hex.substring(0, 6);\r\n                }\r\n                Log.exDev(hex.length !== 3 && hex.length !== 6, \"invalid hex length\", {hex, a});\r\n                let i: number = 0;\r\n                if (hex.length === 3) {\r\n                    r =  Number.parseInt('0x' + hex[i] + hex[i++]);\r\n                    g =  Number.parseInt('0x' + hex[i] + hex[i++]);\r\n                    b =  Number.parseInt('0x' + hex[i] + hex[i]);\r\n                }\r\n                else {\r\n                    r =  Number.parseInt('0x' + hex[i++] + hex[i++]);\r\n                    g =  Number.parseInt('0x' + hex[i++] + hex[i++]);\r\n                    b =  Number.parseInt('0x' + hex[i++] + hex[i]);\r\n                }\r\n                return {r,g,b,a} as tinycolor.ColorFormats.RGBA;\r\n            })};\r\n    }\r\n    public static fatherChain(me: LModelElement): Pointer<DModelElement, 0, 'N', LModelElement> {\r\n        if(!me) return [];  // without this line go through delete error\r\n        const fathers: Pointer<DModelElement, 0, 'N', LModelElement>= [me.id];\r\n        const toCheck: LModelElement[] = [me];\r\n        while(toCheck.length > 0) {\r\n            const element = toCheck.pop();\r\n            if(element && element.father) {\r\n                fathers.push(element.father.id);\r\n                toCheck.push(element.father);\r\n            }\r\n        }\r\n        return fathers;\r\n    }\r\n\r\n    /// maxDepth = 2 is the minimum to check the content of objects inside usageDeclarations or node state. like node.errors.naming\r\n    static isShallowEqualWithProxies(obj1?: any, obj2?: any, skipKeys: Dictionary<string>={}, out?: {reason?: string},\r\n                                     depth: number = 0, maxDepth: number = 2, returnIfMaxDepth:boolean = false): boolean {\r\n        if (obj1 === obj2) {\r\n            // if (out) { out.reason = \"identical objects\"; }\r\n            return true; }\r\n        let tobj1 = obj1 === null ? 'null' : typeof obj1;\r\n        let tobj2 = obj2 === null ? 'null' : typeof obj2;\r\n        if (tobj1 !== tobj2) { if (out) { out.reason = \"type changed: \" + tobj1 + \" --> \" + tobj2; } return false; }\r\n\r\n        //\r\n        // at this point: same type, but different values\r\n        //\r\n\r\n        if (!obj1 || !obj2) return false; // cannot happen but compiler wants it to narrow types\r\n        switch (tobj1) {\r\n            default: // primitive with different values\r\n                console.error(\"unexpected case in isshallowequal:\", {tobj1, obj1, obj2});\r\n                if (out) {\r\n                    if (undefined === tobj1) out.reason = 'primitive value newly introduced';\r\n                    else if (undefined === tobj2) out.reason = 'primitive value got deleted';\r\n                    else out.reason = 'primitive value changedd';\r\n                }\r\n                return false;\r\n            case 'string': case 'boolean': // primitive with different values\r\n                if (out) {\r\n                    if (undefined === tobj1) out.reason = 'primitive value newly introduced';\r\n                    else if (undefined === tobj2) out.reason = 'primitive value got deleted';\r\n                    else out.reason = 'primitive value changedd';\r\n                }\r\n                return false;\r\n            case \"number\": // if both re nan it fails\r\n                // NB: infinities are not nan, and they compare with === like normal numbers. weird js...\r\n                if (isNaN(obj1 as any) && isNaN(obj2 as any)) return true;\r\n                if (out) out.reason = 'number changed';\r\n                return false;\r\n\r\n            case \"function\":\r\n                if (obj1.toString() === obj2.toString()) break;\r\n                if (out) out.reason = 'function body changed';\r\n                return false;\r\n\r\n            case \"object\":\r\n                let o1Raw = obj1.__raw;\r\n                let o2Raw = obj2.__raw;\r\n                if (o1Raw) {\r\n                    if (!o2Raw) {\r\n                        if (out) out.reason = o1Raw.className + 'replaced by another object type:' + o2Raw?.className;\r\n                        return false;\r\n                    }\r\n                    obj1 = o1Raw as GObject;\r\n                    obj2 = o2Raw as GObject;\r\n                }\r\n                // for proxies and DObjects\r\n                if (obj1.clonedCounter !== undefined && obj2.clonedCounter !== obj1.clonedCounter) {\r\n                    if (out) out.reason = 'clonedCounter difference ' + obj1.clonedCounter+ ' != ' + obj2.clonedCounter;\r\n                    return false;\r\n                }/*\r\n                if (obj1.className !== obj2.className) {\r\n                 removed: too unlikely to happen that a DObject is raplaced in the same path with another type of DObject with same clonedCounter\r\n                 nd it's checked anyway in for(let key in obj1)\r\n                    if (out) out.reason = o1Raw.className + 'replaced by another object type:' + o2Raw?.className;\r\n                    return false;\r\n                }*/\r\n                if (Array.isArray(obj1)) {\r\n                    if (obj1.length !== obj2.length) {\r\n                        if (out) out.reason = 'array length different: ' + obj1.length + \" !== \" + obj2.length;\r\n                        return false;\r\n                    }\r\n                    if (!Array.isArray(obj2)){\r\n                        if (out) out.reason = 'array became an object';\r\n                        return false;\r\n                    }\r\n                }\r\n\r\n                if (obj1.className !== obj2.className) {\r\n                    if (out) out.reason = o1Raw.className + 'replaced by another object type:' + o2Raw?.className;\r\n                    return false;\r\n                }\r\n                switch(obj1.className) {\r\n                    default: break;\r\n                    case \"ISize\": case \"IPoint\": case \"GraphPoint\": case \"Point\": case \"Size\":\r\n                        skipKeys.id = true;\r\n                        skipKeys.dontMixWithGraphSize = true;\r\n                        skipKeys.dontMixWithSize = true;\r\n                        skipKeys.dontmixwithGPoint = true;\r\n                        skipKeys.dontmixwithPoint = true;\r\n                        skipKeys.rad = true;\r\n                        break;\r\n                }\r\n                // if EdgeSegment is changed, this needs update too: search in IDE for \"5khi2\"\r\n                if (U.objectIncludeKeys(obj1, 'd', 'dpart', 'svgLetter')){\r\n                    let ret = obj1.d === obj2.d && obj1.dpart === obj2.dpart;\r\n                    if (out && !ret) out.reason = 'EdgeSegment changed:' + obj1.d +' --> ' + obj2.d;\r\n                    return ret;\r\n                }\r\n\r\n                // if it is any kind of unknown object type, do deep check on every subkey\r\n                if (depth > maxDepth) {\r\n                    // to debug and see where is too deep, make returnIfMaxDepth = false, so the path is displayed in out.reason\r\n                    if (out) out.reason = 'max depth reached, assumed ' + returnIfMaxDepth;\r\n                    return returnIfMaxDepth;\r\n                }\r\n                for (let key in obj1) {\r\n                    if (key in skipKeys) continue;\r\n                    let oldp: any = obj2[key];\r\n                    let newp: any = obj1[key];\r\n                    if (oldp === newp) continue;\r\n                    if (!U.isShallowEqualWithProxies(newp, oldp, skipKeys, out, depth +1, maxDepth, returnIfMaxDepth)) {\r\n                        if (out) out.reason = '['+key+']'+out.reason;\r\n                        return false;\r\n                    }\r\n                }\r\n                // just check for keys that were in props and are not in nextProps\r\n                for (let key in obj2) {\r\n                    if ((key in skipKeys) || (key in obj1)) continue;\r\n                    if (out) out.reason = \"deleted subobject property: \" + key;\r\n                    return false;\r\n                }\r\n            // else retIfMaxDepthReached; split the above if\r\n        }\r\n\r\n\r\n\r\n        return true;\r\n    }\r\n\r\n    public static deepEqual (x: GObject, y: GObject): boolean {\r\n        const tx = typeof x, ty = typeof y;\r\n        return x && y && tx === 'object' && tx === ty ? (\r\n            Object.keys(x).length === Object.keys(y).length && Object.keys(x).every(key => U.deepEqual(x[key], y[key]))\r\n        ) : (x === y);\r\n    }\r\n\r\n    public static sleep(s: number): Promise<void> {\r\n        return new Promise((resolve) => setTimeout(resolve, s * 1000));\r\n    }\r\n\r\n    public static getRandomString(length: number): string {\r\n        const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';\r\n        let randomString = '';\r\n        let index = 0;\r\n        while(index < length) {\r\n            const randomNumber = Math.floor(Math.random() * characters.length);\r\n            randomString += characters.charAt(randomNumber);\r\n            index += 1;\r\n        }\r\n        return randomString;\r\n    }\r\n\r\n    public static popup(element: any) {\r\n        let html = '<style>body.swal2-no-backdrop .swal2-container {background-color: rgb(0 0 0 / 60%) !important}</style>'+ element;\r\n        const result = Swal.fire({\r\n            html: html,\r\n            backdrop: false,\r\n            showCloseButton: true,\r\n            showConfirmButton: false\r\n            //confirmButtonText: 'GOT IT'\r\n        })\r\n    }\r\n    public static filteredPointedBy(data: LModelElement, label: string): LModelElement[] {\r\n        const models: LModelElement[] = [];\r\n        for(let dict of data.pointedBy) {\r\n            const pointedBy = dict.source.split('.');\r\n            if(pointedBy.length === 3 && pointedBy[2] === label) {\r\n                models.push(LModelElement.fromPointer(pointedBy[1]));\r\n            }\r\n        }\r\n        return models;\r\n    }\r\n\r\n    public static getFatherFieldToDelete(data: LModelElement): keyof DModelElement|null {\r\n        const father = data.father;\r\n        let field = '';\r\n        switch(father.className + '|' + data.className) {\r\n            // DPackage\r\n            case 'DModel|DPackage': field = 'packages'; break;\r\n            case 'DPackage|DPackage': field = 'subpackages'; break;\r\n            // DEnumerator and DClass\r\n            case 'DPackage|DEnumerator':\r\n            case 'DPackage|DClass': field = 'classifiers'; break;\r\n            // DAttribute\r\n            case 'DClass|DAttribute': field = 'attributes'; break;\r\n            // DReference\r\n            case 'DClass|DReference': field = 'references'; break;\r\n            // DOperation\r\n            case 'DClass|DOperation': field = 'operations'; break;\r\n            // DEnumLiteral\r\n            case 'DEnumerator|DEnumLiteral': field = 'literals'; break;\r\n            // DObject\r\n            case 'DModel|DObject': field = 'objects'; break;\r\n            // DParameter\r\n            case 'DOperation|DParameter': field = 'parameters'; break;\r\n            // DValue\r\n            case 'DObject|DValue': field = 'features'; break;\r\n            // Error\r\n            default: return null;\r\n        }\r\n        return field as keyof DModelElement;\r\n    }\r\n\r\n    public static initializeValue(typeclassifier: undefined|DClassifier|LClassifier|Pointer<DClassifier, 1, 1, LClassifier>): string {\r\n        // if(!classifier) return 'null';\r\n        const pointer: Pointer = typeof typeclassifier === 'string' ? typeclassifier : (typeclassifier as DClassifier)?.id;\r\n        const me: LNamedElement = LNamedElement.fromPointer(pointer);\r\n        switch(me?.name) {\r\n            default:\r\n            case 'EString': return '';\r\n            case 'EChar':  return 'a';\r\n            case 'EInt': return '0';\r\n            case 'ELong': return '0';\r\n            case 'EShort': return '0';\r\n            case 'Byte': return '0';\r\n            case 'EFloat': return '0';\r\n            case 'EDouble': return '0';\r\n            case 'EBoolean': return 'false';\r\n            case 'EDate': return new Date().toJSON().slice(0,10);\r\n        }\r\n        return 'null';\r\n    }\r\n\r\n    public static orderChildrenByTimestamp(context: LogicContext): LModelElement[] {\r\n        const children = context.proxyObject.children;\r\n        if(children && children.length > 0) {\r\n            let orderedChildren = new Map<number, LModelElement>();\r\n            for(let child of children) {\r\n                let timestamp = child.id.slice(-13);\r\n                orderedChildren.set(+timestamp, child);\r\n            }\r\n            orderedChildren = new Map([...orderedChildren.entries()].sort());\r\n            return [...orderedChildren.values()];\r\n        } else return [];\r\n    }\r\n\r\n\r\n    public static followPath(base: GObject, path: string|string[]): {chain: GObject[], lastObject: GObject, keys:string[], lastkey: string, lastval: any, failedRemainingPath: string[]} {\r\n        let ret: {chain: GObject[], lastObject: GObject, keys: string[], lastkey: string, lastval: any, failedRemainingPath: string[]}\r\n            = {lastObject:base, chain:[base], keys:[], failedRemainingPath:[]} as any;\r\n        if (!path) return ret;\r\n        let patharr: string[] = Array.isArray(path) ? path : (path+'').split('.');\r\n        ret.keys = patharr;\r\n        if (!base) return ret;\r\n\r\n        let lastObject = base;\r\n        for (let i = 0; i < patharr.length; i++) {\r\n            let path = ret.lastkey = patharr[i];\r\n            lastObject = base;\r\n            base = base[path];\r\n            ret.chain.push(base);\r\n            if (typeof base !== \"object\" || i + 1 === patharr.length) {\r\n                ret.failedRemainingPath = patharr.slice(i);\r\n                ret.lastval = base;\r\n                ret.lastObject = lastObject;\r\n                return ret;\r\n            }\r\n        }\r\n        throw new Error(\"followPath should never reach here\");\r\n        return ret;\r\n    }\r\n\r\n    static multiReplaceAllKV(a: string, kv: string[][] = []): string {\r\n        const keys: string[] = [];\r\n        const vals: string[] = [];\r\n        let i: number;\r\n        for (i = 0; i < kv.length; i++) { keys.push(kv[i][0]); vals.push(kv[i][0]); }\r\n        return U.multiReplaceAll(a, keys, vals); }\r\n\r\n    // if replacement is empty, it will be filled with '';\r\n    // if replacement length < searchText, replacement will be filled with copies of his elements cycling from 0 to his length until his length matches searchText.length\r\n    static multiReplaceAll(a: string, searchText: string[] = [], replacement: string[] = []): string {\r\n        // Log.ex(searchText.length !== replacement.length, 'search and replacement must be have same length: ' + searchText.length + \"vs\" + replacement.length + \" \" +JSON.stringify(searchText) + \"   \" + JSON.stringify(replacement));\r\n        let i = -1;\r\n        while (replacement.length !== 0 && replacement.length < searchText.length) replacement.push(replacement[++i]);\r\n        i = -1;\r\n        while (++i < searchText.length) { a = U.replaceAll(a, searchText[i], replacement[i]); }\r\n        return a; }\r\n\r\n    static replaceAll(str: string, searchText: string, replacement: string | undefined, debug: boolean = false, warn: boolean = true): string {\r\n        if (!str) { return str; }\r\n        return str.split(searchText).join(replacement||''); }\r\n\r\n    static toFileName(a: string = 'nameless.txt'): string {\r\n        if (!a) { a = 'nameless.txt'; }\r\n        a = U.multiReplaceAll(a.trim(), ['\\\\', '//', ':', '*', '?', '<', '>', '\"', '|'],\r\n            ['[lslash]', '[rslash]', ';', '°', '_', '{', '}', '\\'', '!']);\r\n        return a;\r\n    }\r\n\r\n\r\n    // warn: this check if the scope containing the function is strict, to check if a specific external scope-file is strict\r\n    // you have to write inline the code:        var isStrict = true; eval(\"var isStrict = false\"); if (isStrict)...\r\n    // @ts-ignore\r\n    public static isStrict: boolean = ( function() { return !this; })();\r\n\r\n    // merge properties with first found first kept (first parameters have priority on override). only override null|undefined values, not (false|0|'') values\r\n    static objectMergeInPlace<A extends object, B extends object>(output: A, ...objarr: B[]): void {\r\n        const out: GObject = output;\r\n        if (objarr)\r\n            for (let o of objarr) {\r\n                if (o && typeof o === \"object\")\r\n                    for (let key in o) {\r\n                        // noinspection BadExpressionStatementJS,JSUnfilteredForInLoop\r\n                        out[key] ?? (out[key] = o[key]);\r\n                    }\r\n            }\r\n    }\r\n/*\r\n    public static log(obj: unknown, label: string = '###') {\r\n        console.clear();\r\n        console.log(label, obj);\r\n    }*/\r\n\r\n    static removeEmptyObjectKeys(obj: GObject): void{\r\n        for (let key of Object.keys(obj)) {\r\n            if (obj[key] === null || obj[key] === undefined) delete obj[key];\r\n        }\r\n    }\r\n\r\n    // usage example: objectMergeInPlace_conditional(baseobj, (out, key, current) => !out[key] && current[key];\r\n    // culprit of \"couldn't find intersection\" problem: condition type: (out:A&B, key: string | number, current:B, objarr?: B[], indexOfCurrent?: number) => boolean\r\n    static objectMergeInPlace_conditional<A extends GObject, B extends GObject>(output: A, condition: (...a:any)=>any, ...objarr: B[]): A & B {\r\n        const out: GObject<\"A & B\"> = output;\r\n        let i: number = 0;\r\n        for (let o of objarr) for (let key in o) { if (condition(out, key, o, objarr, i++)) out[key] = o[key]; }\r\n        return out as  A & B; }\r\n\r\n    static buildFunctionDocumentation(f: Function): {fullSignature: string, parameters: {name: string, defaultVal: string | undefined, typedesc: string | null}[], returns: string | undefined, f: Function, fname: string | undefined, isLambda: boolean, signature: string} {\r\n        Log.e(!JsType.isFunction(f), 'getFunctionSignature() parameter must be a function', f);\r\n        // let parameters: {name: string, defaultVal: string, typedesc: string}[] = []; //{name: '', defaultVal: undefined, typedesc: ''};\r\n        let ret: {fullSignature: string, parameters: {name: string, defaultVal: string | undefined, typedesc: string | null}[], returns: string | undefined, f: Function, fname: string | undefined, isLambda: boolean, signature: string}\r\n            = {fullSignature: '', fname: undefined, signature: '', parameters: [], returns: undefined, f: f, isLambda: null as Temporary};\r\n        let str: string = f.toString();\r\n        let starti: number = str.indexOf('(');\r\n        let endi: number;\r\n        let parcounter: number = 1;\r\n        for (endi = starti + 1; endi < str.length; endi++) {\r\n            if (str[endi] === ')' && --parcounter === 0) break;\r\n            if (str[endi] === '(') parcounter++; }\r\n\r\n        let parameterStr = str.substring(starti + 1, endi);\r\n        // console.log('getfuncsignature starti:', starti, 'endi', endi, 'fname:', str.substr(0, starti), 'parameterStr:', parameterStr);\r\n        ret.fname = str.substr(0, starti).trim();\r\n        ret.fname = ret.fname.substr(0, ret.fname.indexOf(' ')).trim();\r\n        // 2 casi: anonimo \"function (par1...){}\" e \"() => {}\", oppure nominato: \"function a1(){}\"\r\n        if (ret.fname === '' || ret.fname === 'function') ret.fname = undefined; // 'anonymous function';\r\n\r\n\r\n\r\n        let returnstarti: number = str.indexOf('/*', endi + 1);\r\n        let returnendi: number = -1;\r\n        let bodystarti: number = str.indexOf('{', endi + 1);\r\n        if (returnstarti === -1 || bodystarti !== -1 && bodystarti < returnstarti) {\r\n            // no return type or comment is past body\r\n            ret.returns = undefined;\r\n        } else {\r\n            returnendi = str.indexOf('*/', returnstarti + 2);\r\n            ret.returns = str.substring(returnstarti + 2, returnendi).trim();\r\n            bodystarti = str.indexOf('{', returnendi); }\r\n        if (ret.returns === '') ret.returns = undefined;\r\n\r\n        // is lambda if do not have curly body or contains => between return comment and body\r\n        // console.log('isLambda:', bodystarti, str.substring(Math.max(endi, returnendi)+1, bodystarti));\r\n        ret.isLambda =  bodystarti === -1 || str.substring((window as any).Math.max(endi, returnendi)+1, bodystarti).trim() === '=>';\r\n\r\n        let regexp = /([^=\\/\\,]+)(=?)([^,]*?)(\\/\\*[^,]*?\\*\\/)?,/g; // only problem: the last parameter won't match because it does not end with \",\", so i will append it everytime.\r\n        let match;\r\n        while ((match = regexp.exec(parameterStr + ','))) {\r\n            // match[0] is always the full match (not a capture group)\r\n            // match[2] can only be \"=\" or empty string\r\n            // nb: match[4] can be \"/*something*/\" or \",\" a single , without spaces.\r\n            let par: {name: string, defaultVal: string | undefined, typedesc: string | null} = {name: match[1], defaultVal: match[3], typedesc: match[4] && match[4].length > 1 ? match[4] : null};\r\n            par.name = par.name.trim();\r\n            par.defaultVal = par.defaultVal ? par.defaultVal.trim() : undefined;\r\n            par.typedesc = par.typedesc && par.typedesc && par.typedesc.length > 1 ? par.typedesc.substring(2, par.typedesc.length - 2).trim() || null : null;\r\n            ret.parameters.push(par); }\r\n        // set signature\r\n\r\n        ret.signature = '' + (ret.fname ? '/*' + ret.fname + '*/' : '') + '(';\r\n        let i: number;\r\n        for (i = 0; i < ret.parameters.length; i++) {\r\n            let par = ret.parameters[i];\r\n            ret.signature += (i === 0 ? '' : ', ') + par.name + (par.typedesc ? '/*' + par.typedesc + '*/' : '') + (par.defaultVal ? ' = ' + par.defaultVal : '');\r\n        }\r\n        ret.signature += ')' + (ret.returns ? '/*' + ret.returns + '*/' : '');\r\n\r\n        ret.fullSignature = ret.isLambda? ret.signature + '=>' + ret.returns : (ret.fname ||'function') + ret.signature+': '+ret.returns;\r\n        return ret; }\r\n\r\n\r\n\r\n    // NB: need to use result.apply(context) to have a usable \"this\"\r\n    // if you want to pass a parameter to the function, pass it through scope insteand !! AND UNDECLARE the parameter in function string signature !!\r\n    //if inner funcstr have parameters, need to declare them as codestrParamNames arr, and pass them in that order, after the scope which is fixed as first argument.\r\n    // rest values are declared with ellipsis in codestrParamNames\r\n    // !!! scope passed here, is only used for keys. values are not bound. scope is set as first parameter when you call the function.\r\n    // context is bound, but can be re-assigned by calling .bind(), .call() or .apply(), so neither context nor scope assigned in parsing phase are final.\r\n    // innerfunc params do not have to match the name on the string function, but only the correct amount. they can have any name i think, but i list them correctly to documentate.\r\n    public static parseFunctionWithContextAndScope<ParamNames extends string[], T extends Function = Function, TT extends GObject | undefined = GObject>(\r\n        codeStr0: string | Function, context0: GObject | undefined, scope0: TT, codestrParamNames?: ParamNames, protectShallowValues: boolean = false, doIdentifierValidation: boolean = false):\r\n        (TT extends undefined ? (...params: any)=>any : (scopee:TT, ...paramss: { [K in keyof ParamNames]: any;})=>any){\r\n        if (!codestrParamNames) codestrParamNames = [] as any;\r\n\r\n        let codeStr: string = typeof codeStr0 === \"function\" ? codeStr0.toString() : codeStr0;\r\n        let scopeParams: string = '';\r\n        let scope: GObject | undefined;\r\n        let context: GObject | undefined;\r\n        if (protectShallowValues) {\r\n            if (scope0) { //scope = {...scope0}; scope.__proto__ = scope0.__proto__; // for...in gets values in __proto__ too, {...o} instead gets only hasOwnProperty copied\r\n                scope = {};\r\n                for (let k in scope0) scope[k] = scope0[k];\r\n            } else scope = undefined;\r\n            if (context0) { // context = {...context0}; context.__proto__ = context0.__proto__;\r\n                context = {};\r\n                for (let k in context0) context[k] = context0[k];\r\n            } else context = undefined;\r\n        } else { scope = scope0; context = context0; }\r\n\r\n\r\n        if (scope) {\r\n            let scopekeys: string[] = Object.keys(scope);\r\n            if (doIdentifierValidation) scopekeys.map((key)=>{\r\n                key = key?.trim() || '';\r\n                if (!key || !U.validIdentfierRegexp.test(key)) return undefined;\r\n                return key;\r\n            }).filter(k=>!!k);\r\n            scopeParams = '{'+scopekeys.join(',')+'}';\r\n        }\r\n\r\n        let innerFuncParams = (codestrParamNames as string[]).join(',');\r\n        let _jevalfunc = undefined as any; // is set by eval\r\n        const evalmode = false;\r\n        console.log('parseFunctionWithContextAndScope', {codeStr, scope, context, params:{scopeParams, innerFuncParams}});\r\n        scopeParams = scopeParams && innerFuncParams ? scopeParams + ',' + innerFuncParams : scopeParams + innerFuncParams;\r\n        if (evalmode) {\r\n            codeStr = \"_jevalfunc = function (\"+scopeParams+\") { return (\"+codeStr+\")(\"+innerFuncParams+\") }\";\r\n            eval(codeStr);\r\n        } else {\r\n            _jevalfunc = new Function(scopeParams, \" return (\"+codeStr+\")(\"+innerFuncParams+\")\");\r\n        }\r\n\r\n        console.log('parseFunctionWithContextAndScope', {_jevalfunc, params:{scopeParams}});\r\n\r\n        if (context) return _jevalfunc.bind(context);\r\n        else return _jevalfunc;\r\n    }/*\r\n    public static evalInContextAndScope<T = any>(...a:any):any {return undefined}\r\n    public static evalInContextAndScopeNew<T = any>(...a:any):any {return undefined}*/\r\n    public static evalInContextAndScopeNew<T = any>(codeStr: string | ((...a:any)=>any), context0: GObject, injectScopeToo: boolean,\r\n                                                    protectShallowValues?: boolean, doIdentifierValidation?: boolean): T {\r\n        return U.evalInContextAndScope(codeStr, context0, injectScopeToo ? context0 : undefined, protectShallowValues, doIdentifierValidation);\r\n    }\r\n\r\n    // important! this is a simplified version. the correct one allows unicode chars and is 11kb long of regex expression\r\n    public static validIdentfierRegexp = /^[a-zA-Z_$][0-9a-zA-Z_$]*$/;\r\n\r\n    // warn: if return is not explicitly inserted (if that's the case set imlicitReturn = false) with a scope and the code have multiple statemepts it will fail.\r\n    // can modify scope AND context\r\n    // warn: can access global scope (window)\r\n    // if the context (this) is missing it will take the scope as context.\r\n    // warn: cannot set different scope and context, \"this\" della funzione sovrascrive anche il \"this\" interno allo scope come chiave dell'oggetto\r\n    // warn: !context && scope is impossible, so it gets autofixed by assigning context = scope; check Log messages inside function for details.\r\n    // warn: context && scope is impossible if context !== scope and cannot be hotfixed, that will cause a crash.\r\n    public static evalInContextAndScope<T = any>(codeStr: string | ((...a:any)=>any), scope0: GObject | undefined, context0?: GObject,\r\n                                                 protectShallowValues?: boolean, doIdentifierValidation?:boolean): T {\r\n        // console.log('evalInContextAndScope', {codeStr, scope, context});\r\n        // scope per accedere a variabili direttamente \"x + y\"\r\n        // context per accedervi tramite this, possono essere impostati come diversi.\r\n        if (!scope0 && !context0) { Log.ex(true, 'evalInContextAndScope: must specify at least one of scope || context', {codeStr, scope0, context0}); }\r\n\r\n        // scope.this = scope.this || context || scope; non funziona\r\n        // console.log('\"with(this){ return eval( \\'\" + codeStr + \"\\' ); }\"', \"with(this){ return eval( '\" + codeStr + \"' ); }\");\r\n        // eslint-disable-next-line no-restricted-syntax,no-with\r\n        // if (allowScope && allowContext) { return function(){ with(this){ return eval( '\" + codeStr + \"' ); }}.call(scopeAndContext); }\r\n        // if (allowScope && allowContext) { return new Function( \"with(this){ return eval( '\" + codeStr + \"' ); }\").call(scopeAndContext); }\r\n        let _ret: T = null as any;\r\n        let scope: GObject | undefined;\r\n        let context: GObject | undefined;\r\n        if (protectShallowValues) {\r\n            if (scope0) { scope = {...scope0, __proto__: scope0.__proto__}; scope.__proto__ = scope0.__proto__; } else scope = undefined;\r\n            if (context0) { context = {...context0, __proto__: context0.__proto__}; context.__proto__ = context0.__proto__; } else context = undefined;\r\n        } else { scope = scope0; context = context0; }\r\n\r\n        Log.w(!!(!context && scope),\r\n            \"evalInContextAndScope() Context is mandatory, as scope && !context case is not working properly \\n\" +\r\n            \"because scope is simulated by declaring variables pointing to \\\"this\\\" objects instead of doing a full deep copy.\\n\" +\r\n            \"Autofixed by assigning context = scope;\");\r\n        Log.eDev(!!((context && scope) && (context !== scope)),\r\n            \"evalInContextAndScope() Context and scope cannot be different if both present.\\n\" +\r\n            \"Because scope is simulated by declaring variables pointing to \\\"this\\\" objects instead of doing a full deep copy.\");\r\n        if (!context) context = scope; // se creo un nuovo contesto pulisco anche lo scope dalle variabili locali di questa funzione.\r\n\r\n\r\n        /*\r\n        if (allowScope && allowContext) { return new Function( \"with(this){ return eval( '\" + codeStr.replace(/'/g, \"\\\\'\") + \"' ); }\").call(scopeAndContext); }\r\n        if (!allowScope && allowContext) { return new Function( \"return eval( '\" + codeStr + \"' );\").call(scopeAndContext); }\r\n        if (allowScope && !allowContext) { return eval(\"with(scopeAndContext){ \" + codeStr + \" }\"); }*/\r\n//      U.pe(!!scope && U.isStrict(), 'cannot change scope while in strict mode (\"use strict\")');\r\n        let prefixDeclarations: string = \"\", postfixDeclarations: string = '';\r\n        if (scope) {\r\n            if (U.isStrict) {\r\n                for (let key in scope) {\r\n                    if (doIdentifierValidation) {\r\n                        key = key.trim();\r\n                        if (!key || !U.validIdentfierRegexp.test(key)) continue;\r\n                    }\r\n                    // anche se li assegno non cambiano i loro valori nel contesto fuori dall'eval, quindi lancio eccezioni con const.\r\n                    prefixDeclarations += \"const \" + key + \"=this.\" + key + \";\";\r\n                    postfixDeclarations = \"\";\r\n                }\r\n            } else {\r\n                prefixDeclarations = \"with(\" + (context ? \"this._eval.\" : \"\") + \"scope){ \";\r\n                postfixDeclarations = \" }\";\r\n            }\r\n        }\r\n\r\n        if (scope && context) {\r\n            if (typeof codeStr === \"function\") { codeStr = codeStr.toString(); } // functions cannot change scope (with statement is deprecated)\r\n            (context as any)._eval = {__codeStr: codeStr}; // necessary to reach this._eval.codeStr inside the eval()\r\n            // console.log(\"evalincontextandscope: \", {fullCodeStr: prefixDeclarations + \"return eval( this._eval._codeStr );\" + postfixDeclarations, codeStr});\r\n            _ret = new (Function as any)(prefixDeclarations + \"; return eval( this._eval.__codeStr );\" + postfixDeclarations).call(context);\r\n            delete (context as any)._eval;\r\n        } else\r\n        if (!scope && context) {\r\n            if (typeof codeStr === \"function\") {\r\n                _ret = (function(...a: any){ return (codeStr as Function).call(context, ...a)}) as any;\r\n                // _ret = (...a: any)=>codeStr.call(context, ...a);\r\n            } else {\r\n                // cannot just eval(codeStr).call(context) because the result might not be a function but only a piece of code or an expression\r\n                (context as any)._eval = {__codeStr: codeStr}; // necessary to reach this._eval.codeStr inside the eval()\r\n                _ret = new (Function as any)(\"return eval( this._eval.__codeStr );\").call(context);\r\n                delete (context as any)._eval;\r\n                // this below  is not good, as i need to quote the expanded result of codeStr,\r\n                // but since it might contain quotes as well i would need to escape them too.\r\n                // _ret = new (Function as any)(\"return eval( \" + codeStr + \" );\").call(context);\r\n            }\r\n        } else\r\n        if (scope && !context) {\r\n            // NB: potrei creare lo scope con \"let key = value;\" per ogni chiave, ma dovrei fare json stringify e non è una serializzazione perfetta e può dare eccezioni(circolarità)\r\n            // console.log({isStrict: U.isStrict, eval: \"eval(\" + prefixDeclarations + codeStr + postfixDeclarations + \")\"});\r\n            if (typeof codeStr === \"function\") { codeStr = codeStr.toString(); } // functions cannot change scope (with statement is deprecated)\r\n            _ret = eval(prefixDeclarations + codeStr + postfixDeclarations); }\r\n\r\n        return _ret; }\r\n\r\n    //T extends ( ((...args: any[]) => any) | (() => any)\r\n    public static execInContextAndScope<T extends (...args: any) => any>(func: T, parameters: Parameters<T>, scope?: GObject, context?: GObject): ReturnType<T>{\r\n        Log.l(false, 'execInCtxScope', {func, parameters, scope, context});\r\n        let ret: any;\r\n        const _eval = {context, scope, func, parameters: parameters || []};\r\n        let prefixDeclarations: string = \"\", postfixDeclarations: string = '';\r\n        if (scope) {\r\n            if (U.isStrict) {\r\n                for (let key in scope) {\r\n                    // anche se li assegno non cambiano i loro valori nel contesto fuori dall'eval, quindi lancio eccezioni con const.\r\n                    prefixDeclarations += \"const \" + key + \" = this.\" + key + \"; \";\r\n                    postfixDeclarations = \"\";\r\n                }\r\n            } else {\r\n                prefixDeclarations = \"with(\" + (context ? \"this._eval.\" : \"\") + \"scope){ \";\r\n                postfixDeclarations = \" }\";\r\n            }\r\n        }\r\n        if (!scope && !context) { Log.ex(true, 'execInContextAndScope: must specify at least one of scope || context', {func, scope, context}); }\r\n        if (!context) context = scope; // se creo un nuovo contesto pulisco anche lo scope dalle variabili locali di questa funzione.\r\n        if (scope && context) {\r\n            context._eval = _eval;\r\n            // will the scope work with \"with\" outside the function body?\r\n            ret = new Function( prefixDeclarations + \"return this._eval.func.apply(this._eval.context, this._eval.parameters);\" + postfixDeclarations).call(context);\r\n            delete context._eval;\r\n        }\r\n        if (!scope && context) { return _eval.func.apply(_eval.context, _eval.parameters); }\r\n        if (scope && !context) {\r\n            // todo: non credo funzioni, _eval non dovrebbe essere accessibile dopo la \"with\" forse devo fare scope._eval = _eval;\r\n            return eval(prefixDeclarations + \"return _eval.func(..._eval.parameters);\" + postfixDeclarations); }\r\n        return ret; }\r\n\r\n    // warn: aggiunge un layer di scope ma ha accesso anche agli scope precedenti (del chiamante della funzione e superiori)\r\n    // warn2: può modificare lo scope internamente all'eval ma ogni cambiamento è perso all'uscita dell'esecuzione (modifica copie)\r\n    // warn3: gli oggetti nested variabili dentro oggetti dello scope) sono modificabili con modifiche persistenti perchè vengono pasate per puntatore.\r\n    // warn4: richiede un return per leggere il valore\r\n    // insomma: sta funzione fa schifo ma non c'è di meglio e non puoi nè permettere nè vietare completamente le modifiche allo scope.\r\n    private static execInScope_DO_NOT_USE(codeStr: string, scope: GObject) {\r\n        return (new Function(...Object.keys(scope), codeStr))(...Object.values(scope));\r\n    }\r\n\r\n    // can modify context in-place, requires \"this\" before variable\r\n    private static evalInContext(js: string, context: GObject): unknown {\r\n        //# Return the results of the in-line anonymous function we .call with the passed context\r\n        return function() { return eval(js); }.call(context);\r\n    }/*\r\n    / *\r\n    // NO: ha 2 problemi: il contesto non è persistente e puoi accedere al contesto solo con \"this\" ma non direttamente usando i nomi delle variabili\r\n    public static evalInContext(contextObj: GObject, code: string): any{\r\n        return U.evalContextFunction.call(contextObj || {}, code);\r\n    }\r\n\r\n    // only create a context for \"this\", wich is bound by .call(), should never be called without .call()\r\n    private static evalContextFunction(code: string): any { eval(code); }\r\n*/\r\n    public static highOrderFunctionExampleTyped<T extends (...args: any[]) => ReturnType<T>>(func: T): (...funcArgs: Parameters<T>) => ReturnType<T> {\r\n        const funcName = (func as any).cname || func.name;\r\n\r\n        // Return a new function that tracks how long the original took\r\n        return (...args: Parameters<T>): ReturnType<T> => {\r\n            console.time(funcName);\r\n            const results = func(...args);\r\n            console.timeEnd(funcName);\r\n            return results; };\r\n    }\r\n\r\n    static asClass<T extends Function>(obj: any, classe: T, elseReturn: T | null = null): null | T { return obj instanceof classe ? obj as any as T: elseReturn; }\r\n    static asString<T>(propKey: unknown, elseReturn: T | null = null): string | null | T { return typeof propKey === 'string' ? propKey : elseReturn; }\r\n    static isString(propKey: unknown): boolean { return typeof propKey === 'string'; }\r\n\r\n    static loadScript(path: string, useEval: boolean = false): void {\r\n        const script = document.createElement('script');\r\n        script.src = path;\r\n        script.type = 'text/javascript';\r\n        Log.eDev(useEval, 'loadScript', 'useEval','useEval todo. potrebbe essere utile per avviare codice fuori dalle funzioni in futuro.');\r\n        document.body.append(script); }\r\n\r\n    static ancestorArray<T extends Element>(domelem: T | null | undefined, stopNode?: Node, includeSelf: boolean = true): Array<T> {\r\n        // [0]=element, [1]=father, [2]=grandfather... [n]=document\r\n        if (!domelem) { return []; }\r\n        const arr = includeSelf ? [domelem] : [];\r\n        let tmp: T = domelem.parentNode as T;\r\n        while (tmp !== null && tmp !== stopNode) {\r\n            arr.push(tmp);\r\n            tmp = tmp.parentNode as T; }\r\n        return arr; }\r\n\r\n    public static monitorObjectProperty(o: GObject, key: string, callback:((k:string, v:any, isWrite: boolean, oldVal: any)=>void),\r\n                                        read: boolean=true, write: boolean=true): void{\r\n        if (!o || !callback || !read && !write) return;\r\n        let propDescriptor: GObject = {};\r\n        let prefixed = '_monitorObject_' + key;\r\n        o[prefixed] = o[key];\r\n        if (read) propDescriptor.get = () => { callback(key, o[prefixed], false, undefined); return o[prefixed]; };\r\n        if (write) propDescriptor.set = (newVal: any) => { callback(key, newVal, true, o[prefixed]); o[prefixed] = newVal; };\r\n        Object.defineProperty(o, key, propDescriptor);\r\n    }\r\n\r\n    static toHtml<T extends Element>(html: string, container?: Element, containerTag: string = 'div'): T {\r\n        if (!container) { container = document.createElement(containerTag); }\r\n        Log.e(!html || html === '', 'toHtml', 'require a non-empty string', html);\r\n        container.innerHTML = html;\r\n        const ret: T = container.firstChild as any;\r\n        if (ret) container.removeChild(ret);\r\n        return ret; }\r\n\r\n    public static levenshtein(a: string, b: string): number {\r\n        if (!a.length) return b.length;\r\n        if (!b.length) return a.length;\r\n        let cost = (a.charAt(a.length - 1) === b.charAt(b.length - 1)) ? 0 : 1;\r\n        return (window as any).Math.min(\r\n            U.levenshtein(a.substring(0, a.length - 1), b) + 1,\r\n            U.levenshtein(a, b.substring(0, b.length - 1)) + 1,\r\n            U.levenshtein(a.substring(0, a.length - 1), b.substring(0, b.length - 1)) + cost,\r\n        );\r\n    }\r\n\r\n    public static getClosestPropertyName(names: string[], name: string): string {\r\n        let lowest = Infinity;\r\n        return names.reduce(function(previous, current) {\r\n            let distance = U.levenshtein(current, name);\r\n            if (distance < lowest) {\r\n                lowest = distance;\r\n                return current;\r\n            }\r\n            return previous;\r\n        }, '');\r\n    }\r\n\r\n    public static getClosestPropertyNames(names: string[], name: string): string[] {\r\n        let distances: {distance: number, value: string}[] = names.map( value => { return {distance: U.levenshtein(value, name), value}; });\r\n        return distances.sort( (a, b) => a.distance - b.distance).map( e => e.value);\r\n    }\r\n\r\n    //todo for console\r\n    public static autoCorrectProxy<T extends GObject>(target: T, recursive: boolean, logger: Console): ProxyHandler<T> {\r\n        return new Proxy(target, {\r\n            get: function(target, name) {\r\n                let namestr = U.asString(name, null);\r\n                if (!namestr) return undefined;\r\n                if (name in target) return target[namestr];\r\n                const suggestions: string[] = U.getClosestPropertyNames(Object.getOwnPropertyNames(target), namestr);\r\n                logger.warn(`${namestr} is not defined, did you meant ${suggestions[0]}?\\t\\nother suggestions:`, suggestions);\r\n                return namestr && target[suggestions[0]];\r\n            },\r\n        });\r\n    }\r\n\r\n    static arrayRemoveAll<T>(arr: Array<T>, elem: T, debug: boolean = false): void {\r\n        let index;\r\n        if (!arr) return;\r\n        while (true) {\r\n            index = arr.indexOf(elem);\r\n            Log.l(debug, 'ArrayRemoveAll: index: ', index, '; arr:', arr, '; elem:', elem);\r\n            if (index === -1) { return; }\r\n            arr.splice(index, 1);\r\n            Log.l(debug, 'ArrayRemoveAll RemovedOne:', arr);\r\n        }\r\n    }\r\n\r\n    static arrayUnique<T>(arr: T[]): Array<T> { return [ ...new Set<T>(arr)]; }\r\n\r\n    static fileReadContent(file: File, callback: (content :string) => void): void {\r\n        const textType = /text.*/;\r\n        try { if (!file.type || file.type.match(textType)) {\r\n            let reader = new FileReader();\r\n            reader.onload = function(e) { callback( '' + reader.result ); };\r\n            reader.readAsText(file);\r\n            return;\r\n        } } catch(e) { Log.e(true, \"Exception while trying to read file as text. Error: |\", e, \"|\", file); }\r\n        Log.e(true, \"Wrong file type found: |\", file ? file.type : null, \"|\", file); }\r\n\r\n    static fileRead(onChange: (e: Event, files: FileList | null, contents?: string[]) => void, extensions: string[] | FileReadTypeEnum[], readContent: boolean): void {\r\n        // $(document).on('change', (e) => console.log(e));\r\n        console.log(\"importEcore: pre file reader\");\r\n        myFileReader.show(onChange, extensions, readContent);\r\n    }\r\n\r\n    public static clear(htmlNode: Element): void {\r\n        if (htmlNode) while (htmlNode.firstChild) { htmlNode.removeChild(htmlNode.firstChild); }\r\n    }\r\n\r\n    static clearAllTimeouts(): void {\r\n        const highestTimeoutId: number = setTimeout(() => {}, 1) as any;\r\n        for (let i = 0 ; i < highestTimeoutId ; i++) { clearTimeout(i); }\r\n    }\r\n\r\n    static getStackTrace(sliceCalls: number = 2): string[] {\r\n        const ret: string | undefined = Error().stack;\r\n        // try { var a = {}; a.debug(); } catch(ex) { ret = ex.stack; }\r\n        // if (Array.isArray(ret)) return ret;\r\n        if (!ret) return ['UnknownStackTrace'];\r\n        const arr: string[] = ret.split('\\n');\r\n        // first 2 entries are \"Erorr\" and \"getStackTrace()\"\r\n        return sliceCalls > 0 ? arr.slice( sliceCalls ) : arr; }\r\n\r\n    // 0 for caller, 1 for caller of caller, -1 for current function, up to -4 to see internal layers (useless)\r\n    public static getCaller(stacksToSkip: number = 0): string {\r\n        const stack: string[] = this.getStackTrace(4);\r\n        // erase getStackTrace() and isFirstTimeCalled() + Error() first stack + n° of layer the caller wants.\r\n        return stack[stacksToSkip]; }\r\n\r\n    private static gotcalledby: Dictionary<string, boolean> = {};\r\n\r\n    // todo: use in Log.once\r\n    // returns true only the first time this line is reached, false in loops >1 loop, false in recursion >1 recursion, false even days after the first execution unless the page is reloaded\r\n    public static isFirstTimeCalledByThisLine(stacksToSkip: number = 0): boolean {\r\n        const caller: string = this.getCaller(stacksToSkip);\r\n        if (U.gotcalledby[caller]) return false;\r\n        return U.gotcalledby[caller] = true; }\r\n\r\n    public static lineKey(): string { return this.getCaller(0); }\r\n\r\n    // Prevent the backspace key from navigating back.\r\n    static preventBackSlashHistoryNavigation(event: JQuery.KeyDownEvent): boolean {\r\n        if (!event || !event.key || event.key.toLowerCase() !== 'backspace') { return true; }\r\n        const types: string[] = ['text', 'password', 'file', 'search', 'email', 'number', 'date',\r\n            'color', 'datetime', 'datetime-local', 'month', 'range', 'search', 'tel', 'time', 'url', 'week'];\r\n        const srcElement: JQuery<any> = $((event as any)['srcElement'] || event.target);\r\n        const disabled = srcElement.prop('readonly') || srcElement.prop('disabled');\r\n        if (!disabled) {\r\n            if (srcElement[0].isContentEditable || srcElement.is('textarea')) { return true; }\r\n            if (srcElement.is('input')) {\r\n                const type = srcElement.attr('type');\r\n                if (!type || types.indexOf(type.toLowerCase()) > -1) { return true; }\r\n            }\r\n        }\r\n        event.preventDefault();\r\n        return false; }\r\n\r\n    static SetMerge<T>(modifyFirst: boolean = true, ...iterables: Iterable<T>[]): Set<T> {\r\n        const set: Set<T> = modifyFirst ? iterables[0] as Set<T>: new Set<T>();\r\n        Log.e(!(set instanceof Set), 'U.SetMerge() used with modifyFirst = true requires the first argument to be a set');\r\n        for (let iterable of iterables) { for (let item of iterable) { set.add(item); } }\r\n        return set; }\r\n\r\n    // merge in-place with unique elements\r\n    static ArrayMergeU(arr1: any[], ...arr2: any[]): any[] { return U.ArrayMerge0(true, arr1, arr2); }\r\n    // merge in-place without unique check\r\n    static ArrayMerge(arr1: any[], ...arr2: any[]): any[] { return U.ArrayMerge0(false, arr1, arr2); }\r\n    // implementation\r\n    static ArrayMerge0(unique: boolean, arrtarget: any[], ...arrays: any[]): any[] {\r\n        if (!arrtarget || !arrays) return arrtarget as any;\r\n\r\n        if (unique) { for (let arri of arrays) for (let e of arri) U.ArrayAdd(arrtarget, e); }\r\n        else { for (let arri of arrays) Array.prototype.push.apply(arrtarget, arri); }\r\n        return arrtarget;\r\n    }\r\n\r\n    static ArrayAdd<T>(arr: Array<T>, elem: T, unique: boolean = true, throwIfContained: boolean = false): boolean {\r\n        Log.ex(!arr || !Array.isArray(arr), 'ArrayAdd arr null or not array:', arr);\r\n        if (!unique) { arr.push(elem); return true; }\r\n        if (arr.indexOf(elem) === -1) { arr.push(elem); return true; }\r\n        Log.ex(throwIfContained, 'ArrayAdd element already contained:', arr, elem);\r\n        return false; }\r\n\r\n\r\n    private static maxID: number = 0;\r\n    public static idPrefix: string = '';\r\n    // static getID(): string { return U.idPrefix + U.maxID++; }\r\n    static getID: Generator<number> = function* idgenerator(): Generator<number> { let i: number = 0; while(true) yield i++; }();\r\n\r\n\r\n    static getType(param: any): string {\r\n        switch (typeof param) {\r\n            default: return typeof param;\r\n            case 'object':\r\n                return (param?.constructor as typeof RuntimeAccessibleClass)?.cname || param?.className || \"{_rawobject_}\";\r\n            case 'function': // and others\r\n                return \"geType for function todo: distinguish betweeen arrow and classic\";\r\n        }\r\n    }\r\n\r\n    static stringCompare(s1: string, s2: string): -1 | 0 | 1 { return (s1 < s2) ? -1 : (s1 > s2) ? 1 : 0; }\r\n\r\n    static endsWith(str: string, suffix: string | string[]): boolean {\r\n        if (Array.isArray(suffix)) {\r\n            for (let suf of suffix) {\r\n                if (U.endsWith(str, suf)) return true;\r\n            }\r\n            return false;\r\n        }\r\n        return str.length >= suffix.length && str.lastIndexOf(suffix) === str.length - suffix.length;\r\n    }\r\n\r\n\r\n    static arrayMergeInPlace<T>(arr1: T[], ...otherArrs: T[][]): T[] {\r\n        for (const arr of otherArrs) arr1.push.apply(arr1, arr || []);\r\n        return arr1; }\r\n\r\n    static getEndingNumber(s: string, ignoreNonNumbers: boolean = false, allowDecimal: boolean = false): number {\r\n        let i = s.length;\r\n        let numberEnd = -1;\r\n        while (--i > 0) {\r\n            if (!isNaN(+s[i])) { if (numberEnd === -1) { numberEnd = i; } continue; }\r\n            if (s[i] === '.' && !allowDecimal) { break; }\r\n            if (s[i] === '.') { allowDecimal = false; continue; }\r\n            if (!ignoreNonNumbers) { break; }\r\n            if (numberEnd !== -1) { ignoreNonNumbers = false; }\r\n        }\r\n        s = numberEnd === -1 ? '1' : s.substring(i, numberEnd);\r\n        return +parseFloat(s); }\r\n\r\n    static increaseEndingNumber(s: string, allowLastNonNumberChars: boolean = false, allowDecimal: boolean = false, increaseWhile?: ((x: string) => boolean)): string {\r\n        if (increaseWhile && !increaseWhile(s)) return s;\r\n        let regexpstr = '([0-9]+' + (allowDecimal ? '|[0-9]+\\\\.[0-9]+' : '') + ')' + (allowLastNonNumberChars ? '[^0-9]*' : '') + '$';\r\n        const matches: RegExpExecArray | null = new RegExp(regexpstr, 'g').exec(s); // Global (return multi-match) Single line (. matches \\n).\r\n        // S flag removed for browser support (firefox), should work anyway.\r\n        let prefix: string;\r\n        let num: number;\r\n        if (!matches) {\r\n            prefix = s;\r\n            num = 2;\r\n        } else {\r\n            Log.ex(matches.length > 2, 'parsing error: /' + regexpstr + '/gs.match(' + s + ')');\r\n            let i = s.length - matches[0].length;\r\n            prefix = s.substring(0, i);\r\n            num = 1 + (+matches[1]);\r\n        }\r\n        if (increaseWhile) while (increaseWhile(prefix + num)) { num++; }\r\n        return prefix + num; }\r\n\r\n\r\n    public static shallowEqual(objA: GObject, objB: GObject): boolean {\r\n        if (objA === objB) { return true; }\r\n\r\n        if (!objA || !objB || typeof objA !== 'object' || typeof objB !== 'object') { return false; }\r\n\r\n        var keysA = Object.keys(objA);\r\n        var keysB = Object.keys(objB);\r\n        if (keysA.length !== keysB.length) return false;\r\n\r\n        // if (keysA.length !== keysB.length) { return false; }\r\n        // Test for A's keys different from B.\r\n        // var bHasOwnProperty = hasOwnProperty.bind(objB);\r\n        for (let keya in objA) if (!Object.is(objA[keya], objB[keya])) return false;\r\n\r\n        // for (var i = 0; i < keysA.length; i++) if (!bHasOwnProperty(keysA[i]) || objA[keysA[i]] !== objB[keysA[i]]) { return false; }\r\n        return true;\r\n    }\r\n\r\n    // returns true only if parameter is already a number by type. UU.isNumber('3') will return false\r\n    static isNumber(o: any): o is number { return typeof o === \"number\" && !isNaN(o); }\r\n    static isPrimitive(o: any, returnIfNull=true, returnIfUndefined=true, returnIfSymbol = false): o is PrimitiveType {\r\n        switch (typeof o) {\r\n            case 'symbol': return returnIfSymbol; // it is primitive by definition, but behaves too much differently\r\n            case 'undefined': return returnIfUndefined;\r\n            case 'function':\r\n            case 'object':\r\n                if (o === null) return returnIfNull;\r\n                return false;\r\n            default: return true;\r\n            // case 'bigint':\r\n        }\r\n    }\r\n\r\n    public static getAllPrototypes(constructor: Constructor, chainoutoutrecursive: GObject[] = [], currentRecursion = 0, maxRecursion = 20, cache: boolean = true): GObject[] {\r\n        // console.log('getAllPrototypes:', {name: constructor.name, currentRecursion, constructor, chainoutoutrecursive});\r\n        if (cache && (constructor as any).__allprototypes) return (constructor as any).__allprototypes;\r\n        let prototype = (constructor.prototype?.name) && constructor.prototype;\r\n        let __proto__ = (constructor.__proto__?.name) && constructor.__proto__;\r\n        if (!prototype && !__proto__ || currentRecursion >= maxRecursion) return chainoutoutrecursive;\r\n        if (prototype) chainoutoutrecursive.push(prototype);\r\n        if (__proto__) chainoutoutrecursive.push(__proto__);\r\n        if (prototype) U.getAllPrototypes(prototype, chainoutoutrecursive, currentRecursion + 1, maxRecursion);\r\n        if (__proto__) U.getAllPrototypes(__proto__, chainoutoutrecursive, currentRecursion + 1, maxRecursion);\r\n        if (cache) (constructor as any).__allprototypes = chainoutoutrecursive;\r\n        return chainoutoutrecursive;\r\n    }\r\n\r\n    public static classIsExtending(subconstructor: Constructor | AbstractConstructor, superconstructor: Constructor | AbstractConstructor): boolean {\r\n        return (superconstructor as typeof DPointerTargetable)?._extends?.includes(subconstructor as any) || false;\r\n        // return U.getAllPrototypes(subconstructor).includes(superconstructor);\r\n    }\r\n\r\n    static isObject(v: GObject|any, returnIfNull: boolean = true, returnIfUndefined: boolean = false, retIfArray: boolean = false): boolean {\r\n        if (v === null) { return returnIfNull; }\r\n        if (v === undefined) { return returnIfUndefined; }\r\n        if (Array.isArray(v)) { return retIfArray; }\r\n        // nb: mind that typeof [] === 'object'\r\n        return typeof v === 'object'; }\r\n\r\n    static objectFromArray<V extends any>(arr: V[], getKey: keyof V|((entry:V) => string)): Dictionary<string, V>{\r\n        // @ts-ignore\r\n        return arr.reduce((acc, val) => {\r\n            // @ts-ignore\r\n            let key = typeof getKey === 'string' ? val[getKey] : getKey(val);\r\n            // @ts-ignore\r\n            acc[key] = val;\r\n            return acc;\r\n        }, {});\r\n    }\r\n\r\n    static objectFromArrayValues<T extends any>(arr: (string | number)[], val: T = true as T): Dictionary<string | number, T> {\r\n        // @ts-ignore\r\n        return arr.reduce((acc, v) => { acc[v] = val; return acc; }, {});\r\n        /*let ret: Dictionary = {};\r\n        for (let val of arr) { ret[val] = true; }\r\n        return ret;*/\r\n    }\r\n\r\n    static toBoolString(bool: boolean, ifNotBoolean: boolean = false): string { return bool === true ? 'true' : (bool === false ? 'false' : '' + ifNotBoolean); }\r\n    static fromBoolString<T extends any>(str: string | boolean): boolean;\r\n    static fromBoolString<T extends any>(str: string | boolean, defaultVal?: T): boolean | T;\r\n    static fromBoolString<T extends any>(str: string | boolean, defaultVal?: T, allowNull?: boolean): boolean | null | T;\r\n    static fromBoolString<T extends any>(str: string | boolean, defaultVal: T = false as any, allowNull: boolean = false, allowUndefined: boolean = false): boolean | null | undefined | T {\r\n        str = ('' + str).toLowerCase();\r\n        if (allowNull && (str === 'null')) return null;\r\n        if (allowUndefined && (str === 'undefined')) return undefined;\r\n\r\n        if (str === \"true\" || str === 't' || str === '1') return true;\r\n        // if (defaultVal === true) return str === \"false\" || str === 'f' || str === '0'; // false solo se è esplicitamente false, true se ambiguo.\r\n        if (str === \"false\" || str === 'f' || str === '0') return false;\r\n        return defaultVal;\r\n    }\r\n\r\n    static arrayDifference<T>(starting: T[], final: T[]): {added: T[], removed: T[], starting: T[], final: T[]} { return Uarr.arrayDifference(starting, final); }\r\n\r\n    /*  {a: { b: { c1: 1, c2:2, c3:3 } }, d: 1 }     ---->  {\"a.b.c1\":1, \"a.b.c2\":2, \"a.b.c3\":3. \"d\":1}*/\r\n    public static flattenObjectToRoot(obj: GObject, prefix: string = '', pathseparator: string = '.'): GObject{\r\n        if (!obj) { Log.ee('invalid flattenobject call', {obj, prefix}); return obj; }\r\n        return Object.keys(obj).reduce((acc: GObject, k: string) => {\r\n            const pre = prefix.length ? prefix + pathseparator : '';\r\n            if (typeof obj[k] === 'object') Object.assign(acc, U.flattenObjectToRoot(obj[k], pre + k, pathseparator));\r\n            else acc[pre + k] = obj[k];\r\n            return acc;\r\n        }, {});\r\n    }\r\n\r\n    // from {a:{aa:true, ab:\"ab\"}, b:4} to [\"a.aa = true\", \"a.ab = \\\"ab\\\"\", \"a.b = 4\"]\r\n    // maxkeylength is max length of any individual key, after it it will become: superlongpath --> supe...path\r\n    // maxsubpaths is how many subpaths are displayed at most. after it it will be: super.rea.lly.long.pa.th --> super.rea.pa.th\r\n    /*public static ObjectToAssignementStrings2<R extends {str: string, fullstr: string, path:string[], fullpath:string[], val: string, fullvalue: string, pathlength?: number}>\r\n    (obj: GObject, maxkeylength: number = 10, maxsubpaths: number = 6, maxvallength: number = 20, toolongreplacer: string = \"…\", out?:{best: R}&R[], quotestrings: boolean = true): {best: string}&string[] {\r\n        out.__jjsplitstrings = true;\r\n        let ret = U.ObjectToAssignementStrings(obj, maxkeylength, maxsubpaths, maxvallength, toolongreplacer, out, quotestrings)\r\n        delete out.__jjsplitstrings;\r\n        return ret;\r\n    }*/\r\n         public static ObjectToAssignementStrings<R extends {str: string, fullstr: string, path:string[], fullpath:string[],\r\n             val: string, fullvalue: string, pathlength?: number}>\r\n    (obj: GObject, maxkeylength: number = 10, maxsubpaths: number = 6, maxvallength: number = 20, toolongreplacer: string = \"…\",\r\n     out?:{best: R, obj: GObject}&R[], quotestrings: boolean = true, filterFunction?: (e:R)=>boolean): {best: string}&string[] {\r\n        const pathseparator = \".\";\r\n        const valueseparator = \" = \";\r\n        //const filterrow = (rowpaths: string[]) => { return (!rowpaths.includes(\"clonedCounter\") && !rowpaths.includes(\"pointedBy\")); };\r\n        let flatten = U.flattenObjectToRoot(obj, '', pathseparator);\r\n        let i = -1;\r\n        let tmp;\r\n        const ret: {best: string, obj: GObject} & string[] = [] as any;\r\n        ret.obj = obj;\r\n        tmp = (maxkeylength - toolongreplacer.length)/2;\r\n        let halfpath = { start: (window as any).Math.floor(tmp), end: (window as any).Math.ceil(tmp) };\r\n        tmp = (maxvallength - toolongreplacer.length)/2;\r\n        let halfval = { start: (window as any).Math.floor(tmp), end: (window as any).Math.ceil(tmp) };\r\n        tmp = (maxsubpaths - toolongreplacer.length)/2;\r\n        let halfsubpaths = { start: (window as any).Math.floor(tmp), end: (window as any).Math.ceil(tmp) };\r\n\r\n\r\n        let bestpathsize = 0;\r\n        let best: R | null = null;\r\n        let countsize = (total: number, arrelem: string): number => total + arrelem.length;\r\n        const filterbest = (row: R) => {\r\n            row.pathlength = row.fullstr.length; // row.fullpath.reduce<number>(countsize, 0);\r\n            if (!best || bestpathsize < row.pathlength) { // && filterrow(row.fullpath)) {\r\n                best = row;\r\n                bestpathsize = row.pathlength;\r\n                if (out) out.best = best;\r\n                ret.best = best.str;\r\n            }\r\n        }\r\n\r\n\r\n        for (let key in flatten) {\r\n            let row: R = {fullpath: key.split(pathseparator), fullstr: key} as R;\r\n            if (filterFunction && !filterFunction(row)) continue;\r\n            // stringify(undefined) = undefined, so i add + \"\"\r\n            try {\r\n                if (!quotestrings && typeof flatten[key] === \"string\") row.fullvalue = flatten[key];\r\n                else row.fullvalue = JSON.stringify(flatten[key]) + \"\";\r\n            } catch(e) { row.fullvalue = \"⁜not serializable⁜\"; }\r\n            // console.log(\"U get assignements loop\", {row, key, flatten, obj});\r\n            row.val = row.fullvalue.length <= maxvallength ? row.fullvalue : row.fullvalue.substring(0, halfval.start) + toolongreplacer + row.fullvalue.substring(halfval.start);\r\n            if (row.fullpath.length > maxsubpaths) {\r\n                row.path = [...row.fullpath];\r\n                row.path.splice( halfsubpaths.start, row.fullpath.length - halfsubpaths.start - halfsubpaths.end, toolongreplacer);\r\n            } else row.path = row.fullpath;\r\n\r\n            // row.path = row.fullpath.length <= maxsubpaths ? row.fullpath : [...row.fullpath.slice(0, halfsubpaths.start), ...row.fullpath.toomanyarraycopies];\r\n            row.path = row.path.map((p: string) => (p.length <= maxkeylength ? p : p.substring(0, halfpath.start) + toolongreplacer + p.substring(p.length - halfpath.end)));\r\n            if (out) { out.push(row); }\r\n\r\n            if (row.val === '__jjObjDiffEmptyElem') row.str = 'DELETE '+row.path.join(pathseparator)+';';\r\n            else row.str = row.path.join(pathseparator) + valueseparator + row.val;\r\n            ret.push( row.str );\r\n            filterbest(row);\r\n        }\r\n        return ret;\r\n    }\r\n\r\n\r\n    static download(filename: string = 'nameless.txt', text: string = '', debug: boolean = true): void {\r\n        if (!text) return;\r\n        filename = U.toFileName(filename);\r\n        const htmlA: HTMLAnchorElement = document.createElement('a');\r\n        const blob: Blob = new Blob([text], {type: 'text/plain', endings: 'native'});\r\n        const blobUrl: string = URL.createObjectURL(blob);\r\n        htmlA.style.display = 'none';\r\n        htmlA.href = blobUrl;\r\n        htmlA.download = filename;\r\n        document.body.appendChild(htmlA);\r\n        htmlA.click();\r\n        window.URL.revokeObjectURL(blobUrl);\r\n        document.body.removeChild(htmlA);\r\n    }\r\n\r\n    static formatXml(xml: string): string {\r\n        const reg = /(>)\\s*(<)(\\/*)/g;\r\n        const wsexp = / *(.*) +\\n/g;\r\n        const contexp = /(<.+>)(.+\\n)/g;\r\n        xml = xml.replace(reg, '$1\\n$2$3').replace(wsexp, '$1\\n').replace(contexp, '$1\\n$2');\r\n        const pad: string = '' || '\\t';\r\n        let formatted = '';\r\n        const lines = xml.split('\\n');\r\n        let indent = 0;\r\n        let lastType = 'other';\r\n        // 4 types of tags - single, closing, opening, other (text, doctype, comment) - 4*4 = 16 transitions\r\n        const transitions: GObject = {\r\n            'single->single': 0,\r\n            'single->closing': -1,\r\n            'single->opening': 0,\r\n            'single->other': 0,\r\n            'closing->single': 0,\r\n            'closing->closing': -1,\r\n            'closing->opening': 0,\r\n            'closing->other': 0,\r\n            'opening->single': 1,\r\n            'opening->closing': 0,\r\n            'opening->opening': 1,\r\n            'opening->other': 1,\r\n            'other->single': 0,\r\n            'other->closing': -1,\r\n            'other->opening': 0,\r\n            'other->other': 0\r\n        };\r\n        let i = 0;\r\n        for (i = 0; i < lines.length; i++) {\r\n            const ln = lines[i];\r\n\r\n            // Luca Viggiani 2017-07-03: handle optional <?xml ... ?> declaration\r\n            if (ln.match(/\\s*<\\?xml/)) {\r\n                formatted += ln + '\\n';\r\n                continue;\r\n            }\r\n            // ---\r\n\r\n            const single = Boolean(ln.match(/<.+\\/>/)); // is this line a single tag? ex. <br />\r\n            const closing = Boolean(ln.match(/<\\/.+>/)); // is this a closing tag? ex. </a>\r\n            const opening = Boolean(ln.match(/<[^!].*>/)); // is this even a tag (that's not <!something>)\r\n            const type = single ? 'single' : closing ? 'closing' : opening ? 'opening' : 'other';\r\n            const fromTo = lastType + '->' + type;\r\n            lastType = type;\r\n            let padding = '';\r\n\r\n            indent += transitions[fromTo];\r\n            let j: number;\r\n            for (j = 0; j < indent; j++) {\r\n                padding += pad;\r\n            }\r\n            if (fromTo === 'opening->closing') {\r\n                formatted = formatted.substr(0, formatted.length - 1) + ln + '\\n'; // substr removes line break (\\n) from prev loop\r\n            } else {\r\n                formatted += padding + ln + '\\n';\r\n            }\r\n        }\r\n\r\n        return formatted.trim(); }\r\n\r\n\r\n    // https://stackoverflow.com/questions/13861254/json-stringify-deep-objects  implementation with depth\r\n    static circularStringify(obj: GObject, replacer?: null | ((key: string, value: any) => any), space?: string | number, maxDepth_unsupported: number = 100): string {\r\n        const cache: any[] = [];\r\n        return JSON.stringify(obj, (key, value: any) => {\r\n            if (typeof value === 'object' && value !== null) {\r\n                // Duplicate reference found, discard key\r\n                if (cache.includes(value)) return \"[Circular Reference]\"; // might happen both before and after the replacer func\r\n                if (replacer){\r\n                    value = replacer(key, value);\r\n                    if (cache.includes(value)) return \"[Circular Reference]\"; // might happen both before and after the replacer func\r\n                }\r\n                // Store value in our collection\r\n                cache.push(value);\r\n            }\r\n            return value;\r\n        }, space);\r\n    }\r\n\r\n    static getFirstNumber(s: string, allowDecimalDot: boolean = true, allowDecimalComma: boolean = true, valueifmismatch: any = null): number {\r\n        let commamode = (allowDecimalComma ? (allowDecimalDot ?\"(\\\\.|\\\\,)\" : \"\\\\,\") : (allowDecimalDot ? \"\\\\.\" : \"will not use this regex\"));\r\n        let floatregex = new RegExp(\"-?\" + commamode  + \"?\\\\d+(\" + commamode + \"\\\\d{1,2})?\");\r\n        let intregex = /-?\\d+/;\r\n        let ret: any;\r\n        if (allowDecimalDot || allowDecimalComma) ret = floatregex.exec(s);\r\n        else ret = intregex.exec(s);\r\n        ret = ret && ret[0]; // first match\r\n        if (ret === null) return valueifmismatch;\r\n\r\n        let tmpindex:number;\r\n        if (allowDecimalComma) ret = U.replaceAll(ret, \",\", \".\");\r\n        // while (allowDecimalComma && (tmpindex = ret.indexOf(\",\")) !== ret.lastIndexOf(\",\")) ret.substring(tmp+1) // ret.indexOf(.)\r\n        while ((allowDecimalDot || allowDecimalComma) && (tmpindex = ret.indexOf(\".\")) !== ret.lastIndexOf(\".\")) ret = ret.substring(tmpindex+1) // ret.indexOf(.)\r\n        // if (ret[0]===\"-\" && (ret[1]===\",\" || ret[1]===\".\")) ret = \"-0.\"+ret.substring(2); automatically done bu js.    +\"-.5\" = -0.5\r\n        return +ret;\r\n    }\r\n\r\n    // faster than jquery, underscore and many native methods checked https://stackoverflow.com/a/59787784\r\n    public static isEmptyObject(obj: GObject | undefined): boolean {\r\n        if (typeof obj !== \"object\") return false;\r\n        for (var i in obj) return false;\r\n        return true;\r\n    }\r\n\r\n    private static pairArrayElementsRepeatFunc<T>(val: T, index: number, arr:T[]): T[]{ return [arr[index], arr[index+1]] }\r\n    private static pairArrayElementsReducerFunc<T>(accumulator: T[][], value: T, index: number, array: T[]):T[][] {\r\n        if (index % 2 === 0) accumulator.push(array.slice(index, index + 2));\r\n        return accumulator; }\r\n\r\n    // from arr[] to arr[][]. if is with repetitions is: [1,2], [2,3], [3,4]... (ret.length = source.length-1)\r\n    // if without repetitions is: [1,2], [3,4].... (ret.length = Math.ceil(source.length/2);\r\n    public static pairArrayElements<T>(arr:T[], withRepetitions:boolean = false):T[][] {\r\n        if (withRepetitions) { return arr.map(U.pairArrayElementsRepeatFunc).slice(0, arr.length-1); }\r\n        return arr.reduce( U.pairArrayElementsReducerFunc as ((accumulator: T[][], value: T, index: number, array: T[]) => T[][]), []); }\r\n\r\n    // removes line // and block /**/ comments  todo: can likely be improved by a regular expression\r\n    public static decomment_all(str: string): string { return this.decomment_line(this.decomment_block(str)); }\r\n    // removes line comments //\r\n    public static decomment_line(str: string, trimLines: boolean = true): string {\r\n        return str\r\n            .split(\"\\n\")\r\n            .map(s=> { let i = s.indexOf(\"//\"); s = (i === -1 ? s : s.substring(i)); return trimLines ? s.trim() : s; } )\r\n            .join(\"\\n\");\r\n    }\r\n    // removes block comments /**/\r\n    public static decomment_block(str: string): string {\r\n        // let maxcomments = 100;\r\n        while(true){\r\n            // if (--maxcomments===0) break;\r\n            let s: number = str.indexOf(\"/*\");\r\n            if (s === -1) break;\r\n            let e: number = str.indexOf(\"*/\", s+1);\r\n            if (e === -1) e = str.length;\r\n            str = str.substring(0, s) + str.substring(e+2);\r\n        }\r\n        return str; }\r\n\r\n    static uppercaseFirstLetter<T extends (string | GObject<\"jsx\">)>(str: T): T {\r\n        if (typeof str !== \"string\") return str;\r\n        return str.charAt(0).toUpperCase() + str.slice(1) as T;\r\n    }\r\n\r\n    // CAREFUL! it's imperfect.\r\n    // Does not handle strings starting with ( that are not ()=> arrow functions\r\n    // or codes whose last chars are () but not in (function)() form\r\n    static wrapUserFunction(str: string): string {\r\n        str = str.trim();\r\n        if (str[0]!=='(' || str.indexOf(\"function\") !== 0) {\r\n            str = \"()=>{\" + str + \"\\n}\"; // last \\n important for line comments //\r\n        }\r\n        if (str[str.length - 2] !== \"(\" || str[str.length - 1] !== \")\") str = \"(\" + str + \")()\";\r\n        return str;\r\n    }\r\n\r\n    // adds ellipsis in the middle of a string to truncate it when it's too long.\r\n    public static stringMiddleCut<T extends boolean | undefined, RET extends string | string[] = T extends true ? string[] : string>\r\n    (str: string, maxLength: number, ellipsisChar: string = '…', asArray?: T): RET{\r\n        if (!str as unknown || maxLength < 0 || str.length <= maxLength) return (asArray ? [str] : str) as RET;\r\n        var midpoint = Math.ceil(str.length / 2);\r\n        var toremove = str.length - maxLength + ellipsisChar.length; // makes room for the additional ellipsis too\r\n        var lstrip = Math.ceil(toremove/2); // left strip is the bigger one if odd chars\r\n        var rstrip = toremove - lstrip;\r\n        if (asArray) return [str.substring(0, midpoint-lstrip), ellipsisChar, str.substring(midpoint+rstrip)] as RET;\r\n        else return str.substring(0, midpoint-lstrip) + ellipsisChar + str.substring(midpoint+rstrip) as RET;\r\n    }\r\n\r\n    // transform grays: if the color is <20% different from gray, transform it instead in black or white, 0 = don't, 1 = always black or white\r\n    public static invertHex(s: string, prefix: string='#', transformGrays: number = 0.2): string {\r\n        if (s.indexOf(prefix) === 0) s = s.substring(prefix.length);\r\n        let r: number, g: number, b: number, h: number | undefined; // might be NaN if parseInt fails\r\n        if (s.length === 3 || s.length === 4) {\r\n            r = parseInt('0x'+s[0]);// works with hex numbers\r\n            g = parseInt('0x'+s[1]);\r\n            b = parseInt('0x'+s[2]);\r\n            h = s.length === 4 ? parseInt('0x'+s[4]) : undefined;\r\n        } else if (s.length === 6 || s.length === 8){\r\n            r = parseInt('0x'+s.substring(0, 2));\r\n            g = parseInt('0x'+s.substring(2, 4));\r\n            b = parseInt('0x'+s.substring(4, 6));\r\n            h = s.length === 8 ? parseInt('0x'+s.substring(6, 8)) : undefined;\r\n        } else return Log.ee(\"cannot invert hex color \" + s + \", invalid length\", {s});\r\n        if (isNaN(r)) return Log.ee(\"cannot invert hex color \" + s +\", invalid red\", {s});\r\n        if (isNaN(g)) return Log.ee(\"cannot invert hex color \" + s +\", invalid green\", {g});\r\n        if (isNaN(b)) return Log.ee(\"cannot invert hex color \" + s +\", invalid blue\", {b});\r\n\r\n        transformGrays = transformGrays * 128;\r\n        r = Math.abs(r-128) <= transformGrays ? (r >= 128 ? 0 : 255) : 255 - r;\r\n        g = Math.abs(g-128) <= transformGrays ? (g >= 128 ? 0 : 255) : 255 - g;\r\n        b = Math.abs(b-128) <= transformGrays ? (b >= 128 ? 0 : 255) : 255 - b;\r\n        if (h || h === 0) h = 255 - h;\r\n\r\n        let rs = r.toString(16);\r\n        if (rs.length === 1) rs = '0'+rs;\r\n        let gs = g.toString(16);\r\n        if (gs.length === 1) gs = '0'+gs;\r\n        let bs = b.toString(16);\r\n        if (bs.length === 1) bs = '0'+bs;\r\n        let hs = h ? h.toString(16) : '';\r\n        if (hs.length === 1) hs = '0'+hs;\r\n\r\n        return (prefix) + rs+gs+bs+hs;\r\n    }\r\n\r\n    public static parentUntil(tagName: string, p: Element | null): Element | null {\r\n        while (p && p.tagName !== tagName) p = p.parentElement;\r\n        return p;\r\n    }\r\n\r\n    static paletteSplit(palette: Readonly<PaletteType>): {\r\n        color: Dictionary<string, PaletteControl>,\r\n        number: Dictionary<string, NumberControl>,\r\n        text: Dictionary<string, StringControl>,\r\n        path: Dictionary<string, PathControl>,\r\n    } {\r\n        type clist = PaletteControl | NumberControl | StringControl | PathControl;\r\n        let ret = {\r\n            color: {} as Dictionary<string, PaletteControl>,\r\n            number: {} as Dictionary<string, NumberControl>,\r\n            text: {} as Dictionary<string, StringControl>,\r\n            path: {} as Dictionary<string, PathControl>,\r\n        } as Dictionary<(clist)[\"type\"], Dictionary<string, any>>;\r\n        for (let entry of Object.entries(palette)) {\r\n            let k = entry[0];\r\n            let v = entry[1];\r\n            ret[(v as clist).type][k] = v;\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    static mergeNamedArray<T extends GObject>(ret: T[] & Dictionary<DocString<\"$name\">, T>, classes: T[] & Dictionary<DocString<\"$name\">, T>) {\r\n        for (let key of Object.getOwnPropertyNames(classes)) { // ownPropertyNames skips \"first, last, separator\" created by extending array prototype\r\n            if (key === \"length\") continue;\r\n            if (!isNaN(+key)) ret.push(classes[key]);\r\n            // not else, if a class is named like a number it can be accessed by name until is overwrite by index being reached.\r\n            if (!ret[key]) ret[key] = classes[key];\r\n        }\r\n    }\r\n\r\n    private static prefix = 'ULibrary_';\r\n    private static clipboardinput: HTMLInputElement;\r\n    static async clipboardCopy<T>(text: string, onSuccess?:()=>T, onFailure?:()=>T): Promise<T | undefined> {\r\n        let ret: boolean = false;\r\n        return navigator.clipboard.writeText(text).then(() => {\r\n            ret = true;\r\n            if (onSuccess) return onSuccess();\r\n        },() => {\r\n            ret = U.clipboardCopy_old(text);\r\n            return ret ? onSuccess && onSuccess() : onFailure && onFailure();\r\n        });\r\n    }\r\n    static clipboardCopy_old(text: string): boolean {\r\n        try{\r\n        if (!U.clipboardinput) {\r\n            U.clipboardinput = document.createElement('input');\r\n            U.clipboardinput.id = U.prefix + 'CopyDataToClipboard';\r\n            U.clipboardinput.type = 'text';\r\n            U.clipboardinput.style.display = 'block';\r\n            U.clipboardinput.style.position = 'absolute';\r\n            U.clipboardinput.style.top = '-100vh'; }\r\n        document.body.appendChild(U.clipboardinput);\r\n        U.clipboardinput.value = text;\r\n        U.clipboardinput.select();\r\n        if (!document.execCommand) return false;\r\n        let ret = document.execCommand('copy');\r\n        document.body.removeChild(U.clipboardinput);\r\n        U.clearSelection();\r\n        return ret;\r\n        }\r\n        catch(e){ return false; }\r\n    }\r\n\r\n    static clearSelection() {}\r\n\r\n    static isError(obj: unknown): obj is Error{\r\n        // obj istanceof Error // this is not iframe-safe, Errors from different iframes are considered different instances\r\n        // this is iframe-safe and catches all error types\r\n        return Object.prototype.toString.call(obj) === \"[object Error]\";\r\n        // or err.toString --> \"Error: message\" dunno if stack is printed too i tested with a fake error.\r\n    }\r\n\r\n    static toNamedArray<D extends DPointerTargetable, L extends LPointerTargetable>(larr:L[], darr?:D[]): L[] & Dictionary<DocString<\"$name\">, L>{\r\n        if (!darr || darr.length !== larr.length) darr = larr.map(l=>l.__raw as D);\r\n\r\n        for (let i = 0; i < larr.length; i++) if (darr[i] && larr[i]) (larr as GObject)[\"$\"+(darr[i] as GObject).name] = larr[i];\r\n        /*for (let index of Object.getOwnPropertyNames(larr)) { // ownPropertyNames skips \"first, last, separator\" created by extending array prototype\r\n            if (index === \"length\") continue;\r\n            let d = darr[index as any as number];\r\n            let l = larr[index as any as number];\r\n            if (!d || !l) continue;\r\n            (larr as any)[\"$\" + (d as any).name] = l;\r\n        }*/\r\n        return larr as any;\r\n    }\r\n    public static isDPointerTargetable(e: any): e is (DPointerTargetable | LPointerTargetable){\r\n        return e && (e.__isProxy || (e.className && e.id && e.pointedBy && e._state));\r\n    }\r\n    public static arrayCount<T extends any>(arr: T[], find: T | ((e:T)=>boolean)): number{\r\n        if (typeof find === \"function\") return arr.reduce((total,x) => total+( (find as any as ((a:any)=>boolean) )(x) ? 1:0), 0);\r\n        return arr.reduce((total,x) => total+(x===find?1:0), 0);\r\n    }\r\n    /*public static cropDObject(o: any): GObject{\r\n        if (!o) return o as any;\r\n        let d: any & Partial<DPointerTargetable> = {...(o.__raw || o)};\r\n        // delete d.pointedBy;\r\n        // defaultValue, instanceClassName, isPrimitive, partialdefault_ame, _storePath, _su_maps, OCL__EEDS_RECALCULATIO_, compiled_css, css, cssISGlo_al, isValidatio_, oclUpdateCo_ditio_, everythimg empty str or 0 or empty arr or empty ovj, palette,\r\n\r\n        // remove all falsy properties, just knowing they are not there i know they are falsy, save space.\r\n        for (let k in o){\r\n            let v = o[k];\r\n            //  v === \"\" || v === null || v === undefined\r\n            if (!v || U.isEmptyObject(v) || Array.isArray(v) || v.lemgth === 0) delete o[k];\r\n        }\r\n        return d;\r\n    }*/\r\n\r\n    public static cropDeepObject(o: any, lines_start_crop: number=20, lines_end_crop: number=10, string_start_crop: number=45, string_end_crop: number=35, num_digit_crop: number=5): any{\r\n        if (!o) return o;\r\n        let replacer = (key: string | number | undefined, o: GObject, fullpath:string[], depth: number) => {\r\n            switch (key) {\r\n                case \"props\": return \"[_props_]\";\r\n            }\r\n            switch (typeof o) {\r\n                default: return o;\r\n                case \"string\":\r\n                    return U.cropStr(o, lines_start_crop, lines_end_crop, string_start_crop, string_end_crop);\r\n                case \"function\":\r\n                    return U.cropStr(o.toString(), lines_start_crop, lines_end_crop, string_start_crop, string_end_crop);\r\n                case \"number\":\r\n                    return U.cropNum(o, num_digit_crop);\r\n                case \"object\":\r\n                    if (o === null) return null;\r\n                    if (U.isHtmlNode(o)) return '[HTMLElement]';\r\n                    if (isValidElement(o)) return '[ReactElement]';\r\n                    // because native Error properties are not iterable. need to take them out manually.\r\n                    if (U.isError(o)) return {...o, message:o.message, stack:o.stack};\r\n                    /*if (Array.isArray(o)) {\r\n                        let delements = U.arrayCount(o, U.isDPointerTargetable);\r\n                        if (delements > 0){\r\n                            o = o.map(e=>(U.isDPointerTargetable(e) ? U.cropDObject(o) : e));\r\n                        }\r\n                    }*/\r\n                    if (U.isDPointerTargetable(o)) {\r\n                        if (depth >= 5) return o.id;\r\n                        // if (depth >= 2) return U.cropDObject(o);\r\n                        else o = (o as LPointerTargetable).__raw || o;\r\n                    }\r\n                    if (o.className === 'IPoint') return {x:o.x, y:o.y};\r\n                    if (o.className === 'ISize') return {x:o.x, y:o.y, w:o.w, h:o.h};\r\n\r\n                    // remove all falsy properties, just knowing they are not there i know they are falsy, save space.\r\n                    let isArr = Array.isArray(o);\r\n                    o = isArr ? [...(o as any[])] : {...o};\r\n                    for (let k in o) {\r\n                        let v = o[k];\r\n                        /*if (isArr) switch(k){ default: break;\r\n                            case 'contains': case 'joinOriginal': case 'first': case 'last': case 'separator': delete o[k]; continue;\r\n                        }*/\r\n                        //  v === \"\" || v === null || v === undefined\r\n                        if (!v || U.isEmptyObject(v) || (Array.isArray(v) && v.length === 0)) delete o[k];\r\n                    }\r\n                    // if (U.isDate(o)) return \"[Date \"+o.getTime()+\"]\";\r\n                    return o;\r\n            }\r\n        }\r\n        return U.deepReplace(o, replacer);\r\n    }\r\n\r\n    static deepCopy(obj: any, circularReferenceValue?: any | ((obj_alreadymet: GObject)=>any)): any {\r\n        return U.deepReplace(obj, undefined, circularReferenceValue);\r\n    }\r\n\r\n    // does make a deep copy too.\r\n    static deepReplace(obj: any, replacer?: ((key: undefined | string | number, o: any, fullpath:string[], depth: number) => any),\r\n                       circularReferenceValue: any | ((obj_alreadymet: GObject)=>any) = (o: GObject)=>((o.__raw || o).id || '_circular_ref_')): any {\r\n\r\n        const avoidloop: WeakMap<any, true> = new WeakMap();\r\n        return U.deepReplace_rec(obj, avoidloop, replacer, circularReferenceValue);\r\n    }\r\n\r\n    /**\r\n     replacing always preserves same reference statuses. eg, when  {a:\"x\", b:\"x\"} -> {a:\"y\", b:\"y\"}\r\n     if the original x,y values are the same reference (not just value),\r\n     in the output object a,b will also be the same reference (replacer will not be called twice on the same string)\r\n\r\n     note that let arr = [\"a\", \"a\"] is an array with 2 equal values but different references.\r\n     while let a = \"a\"; let arr = [a, a] have equal references.\r\n\r\n     circularReferenceValue === \"__preserve\" causes any duplicate reference causing a loop to be replaced\r\n     with the target of the first reference instead of the \"__preserve\" string.\r\n\r\n     todo: add parameter eagerLoopReturn (current behaviour is eagerLoopReturn = true)\r\n     eagerLoopReturn = true returns as soon a duplicate objects is found, the returned structure is guaranteed to not have duplicates. [a,a] => [a,'loop','loop']\r\n     eagerLoopReturn = false returns 'loop' only if an object is already found AND have subobjects.\r\n     let a = {id:\"a1\", l:{b:1}};    [a,a] --> [{id:\"a1\", l:{b:1}, {id:\"a1\", l:'_loop_']\r\n     finaly eagerLoopReturn = 'inline' replaces with '_loop_' only when there is really a circular ref\r\n     (found an object already found in the current \"path\" from root to current obj)\r\n     so i need to copy the current map and pass a new copy every time i go deep on a new subobject, branching a tree.\r\n     let a = {id:\"a1\", l:{b:1}};    [a,a] will still return [a,a] with no '_loop_' tags\r\n     instead let a = {l:{b:1}, a:a};    [a,a] will return [{l:{b:1}, a:'_loop_'}, {l:{b:1}, a:'_loop_'}] with no '_loop_' tags\r\n\r\n     replacer func:\r\n         @obj is the current object.\r\n         @key is the last key followed to reach obj from the root.\r\n         @fullpath is the full path from root to obj\r\n     */\r\n    static weakmapSet(m: WeakMap<any, any>, k: any, v: any): void { // because weakmaps cannot store non-object keys, if i try to store a primitive key i use it as a pojo\r\n        if (k && typeof k === 'object') m.set(k, v)\r\n        else (m as GObject)[k] = v;\r\n    }\r\n    static weakmapGet(m: WeakMap<any, any>, k: any): any { // because weakmaps cannot store non-object keys, if i try to get from a primitive key i use it as a pojo\r\n        if (k && typeof k === 'object') return m.get(k)\r\n        else return (m as GObject)[k];\r\n    }\r\n    static weakmapHas(m: WeakMap<any, any>, k: any): boolean {\r\n        if (k && typeof k === 'object') return m.has(k);\r\n        else return !!(m as GObject)[k];\r\n    }\r\n\r\n    static debugcounter = 0;\r\n    static deepReplace_rec(obj: any, avoidloop: WeakMap<any, true>, replacer?: ((key: undefined | string | number, o: any, fullpath: string[], depth: number) => any),\r\n                           circularReferenceValue?: any | ((obj_alreadymet: GObject)=>any), key?: number | string, fullpath:string[]=[], curdept:number=0, eagerLoopReturn: boolean = false): any {\r\n\r\n        if (U.debugcounter % 100) console.warn('possible loop in deepreplace', {fullpath, obj})\r\n        switch (typeof obj) {\r\n            case \"symbol\": // don't know what really do with symbols and funcs\r\n            case \"function\":\r\n                return replacer ? replacer(key, obj, fullpath, curdept) : obj;\r\n            default: // because primitive types cannot be used as WeakMap.set(key), but can as Object keys\r\n                /*if (obj in avoidloop) return U.weakmapGet(avoidloop, obj);\r\n                else U.weakmapSet(avoidloop, obj, obj); */\r\n                break;\r\n\r\n            case \"object\":\r\n                if (obj === null) {\r\n                    /*if (avoidloop.has(obj)) return avoidloop.get(obj);\r\n                    else avoidloop.set(obj, obj);*/\r\n                    break;\r\n                }\r\n                if (avoidloop.has(obj)) { // for objects\r\n                    // for duplicate empty arr or objects, i avoid printing the {__circular_reference__} message and just display the empty obj, pretending is not duped.\r\n                    // if (!replacer && ((Array.isArray(obj) && obj.length === 0) || Object.keys(obj).length === 0)) break; // return obj;\r\n\r\n                    if (circularReferenceValue === \"__preserve\" || typeof obj !== \"object\") return avoidloop.get(obj);\r\n                    else return typeof circularReferenceValue === \"function\" ? circularReferenceValue(obj) : circularReferenceValue;\r\n                } else avoidloop.set(obj, obj);\r\n                break;\r\n        }\r\n\r\n        let old_obj = obj;\r\n        if (replacer) obj = replacer(key, obj, fullpath, curdept);\r\n        switch (typeof obj){\r\n            default: break; // obj = obj; return obj; // for any leaf type\r\n            case \"object\":\r\n                if (U.isHtmlNode(obj)) return obj;\r\n                if (isValidElement(obj)) return obj;\r\n                if (U.isError(obj)) return obj;\r\n                if (Array.isArray(obj)) {\r\n                    obj = obj.map((o, i) => U.deepReplace_rec(o, avoidloop, replacer, circularReferenceValue, i, [...fullpath, ''+i], curdept+1));\r\n                    break;\r\n                }\r\n                let o: GObject = {};\r\n                for (let k in obj) {\r\n                    o[k] = U.deepReplace_rec(obj[k], avoidloop, replacer, circularReferenceValue, k, [...fullpath, k], curdept+1);\r\n                }\r\n                obj = o;\r\n                break;\r\n        }\r\n\r\n        return obj;\r\n    }\r\n\r\n\r\n\r\n    // returns path to that object to find\r\n    public static deepFindInObject(obj: any, subobject: any, compareFunc?:(a:any,b:any)=>boolean, maxDepth: number = Number.POSITIVE_INFINITY): string | undefined {\r\n        const avoidloop: WeakMap<any, true> = new WeakMap();\r\n        let ret = U.deepFindInObject_rec(obj, subobject, avoidloop, maxDepth, compareFunc);\r\n        if (ret === '') return 'this';\r\n        else return ret;\r\n    }\r\n    private static deepFindInObject_rec(obj: any, subobject: any, avoidloop: GObject & WeakMap<any, true>, maxDepth: number, compareFunc?:((a:any,b:any)=>boolean), curdepth:number=0): string | undefined {\r\n        if (compareFunc ? compareFunc(obj, subobject) : obj === subobject) return ''\r\n        if (curdepth >= maxDepth) return undefined;\r\n\r\n        let old_obj = obj;\r\n        switch (typeof old_obj) {\r\n            default: return undefined;\r\n            case \"object\":\r\n                if (old_obj === null) return undefined;\r\n                if (avoidloop.has(obj)) { // for objects\r\n                    return undefined;\r\n                } else avoidloop.set(old_obj, obj);\r\n                break;\r\n        }\r\n\r\n        switch (typeof obj){\r\n            default: return undefined;\r\n            case \"object\":\r\n                if (U.isHtmlNode(obj)) return undefined;\r\n                if (isValidElement(obj)) return undefined; // ReactElement\r\n                if (U.isError(obj)) return undefined;\r\n\r\n                if (Array.isArray(obj)) {\r\n                    for (let i = 0; i < obj.length; i++) {\r\n                        let found = U.deepFindInObject_rec(obj[i], subobject, avoidloop, maxDepth, compareFunc, curdepth+1);\r\n                        if (found === '') return i+'';\r\n                        else if (found !== undefined) return i+'.'+found;\r\n                    }\r\n                    return undefined;\r\n                }\r\n                for (let k in obj) {\r\n                    let found = U.deepFindInObject_rec(obj[k], subobject, avoidloop, maxDepth, compareFunc, curdepth+1);\r\n                    if (found === '') return k+'';\r\n                    if (found !== undefined) return k+'.'+found;\r\n                }\r\n                return undefined;\r\n        }\r\n        return undefined;\r\n    }\r\n\r\n\r\n    public static mailerror(recipients: string[], title: string, msgbody_notencoded: string, canUseClipboard: boolean, clipboardSuccess?: ()=>any, clipboardFailure?: ()=>any) {\r\n\r\n        const msgbody: string = encodeURIComponent(msgbody_notencoded);\r\n        const mailtitle: string =  encodeURIComponent(title);\r\n        // \"mailto:no-one@snai1mai1.com?subject=look at this website&body=Hi,I found this website and thought you might like it http://www.geocities.com/wowhtml\"\r\n        const gitissue = \"https://github.com/MDEGroup/jjodel/issues/new?title=\"+mailtitle+\"&body=\"+msgbody;\r\n        let mailto: string | undefined = \"mailto:\"+recipients.join(';')+\"?subject=\"+mailtitle+\"&body=\"+msgbody;\r\n        const mailtolimit = 2042 - 23/*for safety*/;\r\n        /*\r\n            git uri limit: the requests start failing at exactly 8202 characters.\r\n\r\n            mailto: limits\r\n            2042 characters on Chrome 64.0.3282.186\r\n            2046 characters on Edge 16.16299\r\n            approximately 32700 characters on Firefox 58.0\r\n\r\n            max URI lengths:\r\n            chrome: 15613 chars\r\n            firefox: 15708\r\n        */\r\n        if (mailto.length > mailtolimit){\r\n            if (canUseClipboard) {\r\n                const mailfallback = encodeURIComponent(\"mail body exceeded maximum mailto: link length.\\n\" +\r\n                    \"It has been copied to your clipboard, please past it here or use github issue report.\");\r\n                U.clipboardCopy(msgbody_notencoded, clipboardSuccess, clipboardFailure);\r\n                mailto =  \"mailto:\"+recipients.join(';')+\"?subject=\"+mailtitle+\"&body=\" + mailfallback;\r\n            }\r\n            else mailto = undefined;\r\n        }\r\n        return {gitissue, mailto};\r\n    }\r\n\r\n\r\n\r\n    // NB: does not owrk if there is an overflow of pos:absolute elements needs to be updated before use.\r\n    public static findOverflowingNodes_broken(element : Element) : {element: Element, overflowingFrom: string }[] {\r\n        if (!element) return [];\r\n        // type Direction = {v: number, e: Element};\r\n        // const biggestChilds: Partial<{[k: keyof DOMRect]: {v: number, e: Element}}> = {};\r\n        //const biggestChilds: Partial<{[k: keyof DOMRectReadOnly]: {v: number, e: Element}}> = {};\r\n        const biggestChilds: Record<keyof DOMRectReadOnly, {v: number, e: Element}> = {} as any;\r\n        let childarr: {element: Element, size: DOMRect}[] = [];\r\n        let ret: {element: Element, overflowingFrom: string }[] = [];\r\n        while (element) {\r\n            const size = element.getBoundingClientRect();\r\n            childarr.push({element, size});\r\n            let k: keyof DOMRectReadOnly;\r\n            for (k in size) {\r\n                let v = size[k] as number;\r\n                if (!biggestChilds[k] || v > biggestChilds[k].v) biggestChilds[k] = {e: element, v};\r\n            }\r\n            if (childarr.length <= 1) continue;\r\n            let {element: child, size: childSize} = childarr[childarr.length -1];\r\n\r\n            for (k in size) {\r\n                let v = size[k];\r\n                if (childSize[k] > v) ret.push({element, overflowingFrom:k});\r\n            }\r\n            element = element.parentElement as Element;\r\n        }\r\n        return ret;\r\n    }\r\n/*\r\n    public static makeDraggable(e: HTMLElement, v: LViewElement, n: LGraphElement, type: \"draggable\" | \"resizable\" | \"rotatable\" = \"draggable\"): boolean {\r\n        let draggableOptions: string = e.dataset[type];\r\n        let disabled = !!e.attributes.disabled;\r\n\r\n        let options: GObject;\r\n        switch (typeof draggableOptions){\r\n            case \"string\":\r\n                try{ options = JSON.parse(draggableOptions); }\r\n                catch(e) { Log.ee(\"JSX error in \" + type + \", cannot parse options. Make sure they are a valid JSON object in string format.\"); return false; }\r\n                break;\r\n            case \"object\": options = draggableOptions; break;\r\n            default: Log.ee(\"JSX error in \" + type + \", unexpected type of options, only strings and objects are allowed, found instead: \" + typeof draggableOptions); return false;\r\n        }\r\n\r\n        let $measurable: GObject<'JQuery + ui plugin'> = $(e);\r\n        if (disabled && $measurable.data(\"uiDraggable\")) { $measurable.draggable('disable'); return false; }\r\n        if ($measurable.data(\"uiDraggable\")) $measurable.draggable('enable');\r\n        // todo: change options, put disable then remove disable attr and check if changing options at runtime works\r\n\r\n        let defaultoptions = {\r\n            cursor: 'grabbing',\r\n            // containment: 'parent',\r\n            opacity: 0.0,\r\n            distance: 5,\r\n            helper: 'clone', // 'original' or 'csselector'? or func=>html\r\n            // disabled: !(view.draggable),\r\n            drag: (event: GObject, obj: GObject) => {\r\n                TRANSACTION(()=>{\r\n                    if (!this.props.view.lazySizeUpdate) this.setSize({x:obj.position.left, y:obj.position.top});\r\n                    for (let vid of allviews) this.doMeasurableEvent(EMeasurableEvents.whileDragging, vid);\r\n                })\r\n            },\r\n            stop: (event: GObject, obj: GObject) => {\r\n                TRANSACTION(()=>{\r\n                    this.setSize({x:obj.position.left, y:obj.position.top});\r\n                    for (let vid of allviews) this.doMeasurableEvent(EMeasurableEvents.onDragEnd, vid);\r\n                })\r\n            }\r\n        };\r\n\r\n        let aval: string;\r\n        let eventmap = {\r\n            's':    {'draggable': 'onDragStart',    'rotatable': 'onRotateStart',   'resizable': 'onResizeStart'},\r\n            'ing':  {'draggable': 'whileDragging',  'rotatable': 'whileRotating',   'resizable': 'whileResizing'},\r\n            'e':    {'draggable': 'onDragEnd',      'rotatable': 'onRotateEnd',     'resizable': 'onResizeEnd'  },\r\n        }\r\n        let event = {'s': eventmap.s[type], 'ing': eventmap.ing[type], 'e': eventmap.e[type]};\r\n        let jqui_ing: string;\r\n        switch (type){\r\n            default: jqui_ing = Log.eDevv(\"unexpected measurable event: \" + type); return false;\r\n            case \"draggable\": jqui_ing = 'drag'; break;\r\n            case \"resizable\": jqui_ing = 'resize'; break;\r\n            case \"rotatable\": jqui_ing = 'rotate'; break;\r\n        }\r\n        let jquievent = {'s': 'start', 'ing': jqui_ing, 'e':'end'};\r\n        for (let evtkey in jquievent) {\r\n            // @ts-ignore\r\n            aval = e.attributes[event[evtkey]]?.value || '';\r\n            if (aval) defaultoptions[jquievent[evtkey]] = (event: GObject, obj: GObject) => {\r\n                // jqui event callback\r\n                // 1) call html-defined events (onDragStart=\"my_custom_event_name\")\r\n                // todo: currently only support jqui default parameters, not custom ones. make an eval and allow using stuff like whileDragging=\"(coords)=>myevent(coords, 1,2,3)\"\r\n                v.events[aval](event, obj);\r\n                let evt = options[evtkey];\r\n                delete options[evtkey];\r\n                switch(evt){\r\n                    case \"string\": v.events[evt]?.(event, obj);break;\r\n                    case \"function\": evt(); break;\r\n                    default: break;\r\n                }\r\n            }\r\n            U.objectMergeInPlace(options, defaultoptions);\r\n            $measurable[type](options);\r\n        }\r\n\r\n        return true;\r\n    }\r\n*/\r\n\r\n    static getOSBrowserData(){\r\n        /**\r\n         * JavaScript Client Detection\r\n         * (C) viazenetti GmbH (Christian Ludwig)\r\n         */\r\n        /** source: https://stackoverflow.com/a/18706818/24978590\r\n         author comment:\r\n         I started to write a Script to read OS and browser version that can be tested on Fiddle.\r\n         Feel free to use and extend.\r\n        */\r\n        var unknown = '-';\r\n\r\n        // screen\r\n        var screenSize = '';\r\n        let screen = window.screen;\r\n        if (screen?.width) {\r\n            let width = (screen.width) ? screen.width : '';\r\n            let height = (screen.height) ? screen.height : '';\r\n            screenSize += '' + width + \" x \" + height;\r\n        }\r\n\r\n        // browser\r\n        var nVer = navigator?.appVersion || '';\r\n        var nAgt = navigator?.userAgent || '';\r\n        var browser = navigator?.appName || '';\r\n        var version = '' + parseFloat(nVer);\r\n        var nameOffset, verOffset, ix;\r\n\r\n        // Yandex Browser\r\n        if ((verOffset = nAgt.indexOf('YaBrowser')) != -1) {\r\n            browser = 'Yandex';\r\n            version = nAgt.substring(verOffset + 10);\r\n        }\r\n        // Samsung Browser\r\n        else if ((verOffset = nAgt.indexOf('SamsungBrowser')) != -1) {\r\n            browser = 'Samsung';\r\n            version = nAgt.substring(verOffset + 15);\r\n        }\r\n        // UC Browser\r\n        else if ((verOffset = nAgt.indexOf('UCBrowser')) != -1) {\r\n            browser = 'UC Browser';\r\n            version = nAgt.substring(verOffset + 10);\r\n        }\r\n        // Opera Next\r\n        else if ((verOffset = nAgt.indexOf('OPR')) != -1) {\r\n            browser = 'Opera';\r\n            version = nAgt.substring(verOffset + 4);\r\n        }\r\n        // Opera\r\n        else if ((verOffset = nAgt.indexOf('Opera')) != -1) {\r\n            browser = 'Opera';\r\n            version = nAgt.substring(verOffset + 6);\r\n            if ((verOffset = nAgt.indexOf('Version')) != -1) {\r\n                version = nAgt.substring(verOffset + 8);\r\n            }\r\n        }\r\n        // Legacy Edge\r\n        else if ((verOffset = nAgt.indexOf('Edge')) != -1) {\r\n            browser = 'Microsoft Legacy Edge';\r\n            version = nAgt.substring(verOffset + 5);\r\n        }\r\n        // Edge (Chromium)\r\n        else if ((verOffset = nAgt.indexOf('Edg')) != -1) {\r\n            browser = 'Microsoft Edge';\r\n            version = nAgt.substring(verOffset + 4);\r\n        }\r\n        // MSIE\r\n        else if ((verOffset = nAgt.indexOf('MSIE')) != -1) {\r\n            browser = 'Microsoft Internet Explorer';\r\n            version = nAgt.substring(verOffset + 5);\r\n        }\r\n        // Chrome\r\n        else if ((verOffset = nAgt.indexOf('Chrome')) != -1) {\r\n            browser = 'Chrome';\r\n            version = nAgt.substring(verOffset + 7);\r\n        }\r\n        // Safari\r\n        else if ((verOffset = nAgt.indexOf('Safari')) != -1) {\r\n            browser = 'Safari';\r\n            version = nAgt.substring(verOffset + 7);\r\n            if ((verOffset = nAgt.indexOf('Version')) != -1) {\r\n                version = nAgt.substring(verOffset + 8);\r\n            }\r\n        }\r\n        // Firefox\r\n        else if ((verOffset = nAgt.indexOf('Firefox')) != -1) {\r\n            browser = 'Firefox';\r\n            version = nAgt.substring(verOffset + 8);\r\n        }\r\n        // MSIE 11+\r\n        else if (nAgt.indexOf('Trident/') != -1) {\r\n            browser = 'Microsoft Internet Explorer';\r\n            version = nAgt.substring(nAgt.indexOf('rv:') + 3);\r\n        }\r\n        // Other browsers\r\n        else if ((nameOffset = nAgt.lastIndexOf(' ') + 1) < (verOffset = nAgt.lastIndexOf('/'))) {\r\n            browser = nAgt.substring(nameOffset, verOffset);\r\n            version = nAgt.substring(verOffset + 1);\r\n            if (browser.toLowerCase() == browser.toUpperCase()) {\r\n                browser = navigator?.appName;\r\n            }\r\n        }\r\n        // trim the version string\r\n        if ((ix = version.indexOf(';')) != -1) version = version.substring(0, ix);\r\n        if ((ix = version.indexOf(' ')) != -1) version = version.substring(0, ix);\r\n        if ((ix = version.indexOf(')')) != -1) version = version.substring(0, ix);\r\n\r\n        let majorVersion = parseInt('' + version, 10);\r\n        if (isNaN(majorVersion)) {\r\n            version = '' + parseFloat(nVer);\r\n            majorVersion = parseInt(nVer, 10);\r\n        }\r\n\r\n        // mobile version\r\n        var mobile = /Mobile|mini|Fennec|Android|iP(ad|od|hone)/.test(nVer);\r\n\r\n        // cookie\r\n        var cookieEnabled = (navigator?.cookieEnabled) ? true : false;\r\n\r\n        if (typeof navigator?.cookieEnabled === 'undefined' && !cookieEnabled) {\r\n            document.cookie = 'testcookie';\r\n            cookieEnabled = document.cookie.indexOf('testcookie') !== -1;\r\n        }\r\n\r\n        // system\r\n        var clientStrings = [\r\n            {s:'Windows 10', r:/(Windows 10.0|Windows NT 10.0)/},\r\n            {s:'Windows 8.1', r:/(Windows 8.1|Windows NT 6.3)/},\r\n            {s:'Windows 8', r:/(Windows 8|Windows NT 6.2)/},\r\n            {s:'Windows 7', r:/(Windows 7|Windows NT 6.1)/},\r\n            {s:'Windows Vista', r:/Windows NT 6.0/},\r\n            {s:'Windows Server 2003', r:/Windows NT 5.2/},\r\n            {s:'Windows XP', r:/(Windows NT 5.1|Windows XP)/},\r\n            {s:'Windows 2000', r:/(Windows NT 5.0|Windows 2000)/},\r\n            {s:'Windows ME', r:/(Win 9x 4.90|Windows ME)/},\r\n            {s:'Windows 98', r:/(Windows 98|Win98)/},\r\n            {s:'Windows 95', r:/(Windows 95|Win95|Windows_95)/},\r\n            {s:'Windows NT 4.0', r:/(Windows NT 4.0|WinNT4.0|WinNT|Windows NT)/},\r\n            {s:'Windows CE', r:/Windows CE/},\r\n            {s:'Windows 3.11', r:/Win16/},\r\n            {s:'Android', r:/Android/},\r\n            {s:'Open BSD', r:/OpenBSD/},\r\n            {s:'Sun OS', r:/SunOS/},\r\n            {s:'Chrome OS', r:/CrOS/},\r\n            {s:'Linux', r:/(Linux|X11(?!.*CrOS))/},\r\n            {s:'iOS', r:/(iPhone|iPad|iPod)/},\r\n            {s:'Mac OS X', r:/Mac OS X/},\r\n            {s:'Mac OS', r:/(Mac OS|MacPPC|MacIntel|Mac_PowerPC|Macintosh)/},\r\n            {s:'QNX', r:/QNX/},\r\n            {s:'UNIX', r:/UNIX/},\r\n            {s:'BeOS', r:/BeOS/},\r\n            {s:'OS/2', r:/OS\\/2/},\r\n            {s:'Search Bot', r:/(nuhk|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask Jeeves\\/Teoma|ia_archiver)/}\r\n        ];\r\n        var os = unknown;\r\n        for (var id in clientStrings) {\r\n            var cs = clientStrings[id];\r\n            if (cs.r.test(nAgt)) {\r\n                os = cs.s;\r\n                break;\r\n            }\r\n        }\r\n        if (os === unknown){\r\n            let s = nAgt.toLowerCase();\r\n            if (s.indexOf('windows')) os = 'Windows';\r\n            if (s.indexOf('mac')) os = 'Mac OS';\r\n        }\r\n\r\n        var osVersion = unknown;\r\n\r\n        if (/Windows/.test(os)) {\r\n            osVersion = /Windows (.*)/.exec(os)?.[1] || 'unknown';\r\n            os = 'Windows';\r\n        }\r\n\r\n        switch (os) {\r\n            case 'Mac OS':\r\n            case 'Mac OS X':\r\n            case 'Android':\r\n                osVersion = /(?:Android|Mac OS|Mac OS X|MacPPC|MacIntel|Mac_PowerPC|Macintosh) ([\\.\\_\\d]+)/.exec(nAgt)?.[1] || 'unknown';\r\n                break;\r\n\r\n            case 'iOS':\r\n                let match = /OS (\\d+)_(\\d+)_?(\\d+)?/.exec(nVer);\r\n                if (match) osVersion = match[1] + '.' + match[2] + '.' + (match[3] || 0);\r\n                else osVersion = 'unknown';\r\n                break;\r\n        }\r\n\r\n        return {\r\n            screen: screenSize,\r\n            browser: browser,\r\n            browserVersion: version,\r\n            browserMajorVersion: majorVersion,\r\n            mobile: mobile,\r\n            os: os,\r\n            osVersion: osVersion,\r\n            cookies: cookieEnabled,\r\n            userAgent: navigator.userAgent,\r\n        };\r\n    }\r\n\r\n    // warning: nodes from other iframes will say are not instance from Element of the current frame, in that case need duck typing.\r\n    public static isHtmlNode(element: any): element is Element {\r\n        return element instanceof Element || element instanceof HTMLDocument || element instanceof SVGElement;\r\n    }\r\n\r\n    private static objectIncludeKeys(obj1: GObject, ...keys: string[]): boolean {\r\n        for (let k of keys) if (!(k in obj1)) return false;\r\n        return true;\r\n    }\r\n\r\n    static removeFromDom(e: Node): boolean {\r\n        let p = e.parentNode;\r\n        if (!p) return false;\r\n        p.removeChild(e);\r\n        return true;\r\n    }\r\n\r\n    static findInChildProperties<T extends D|L>(initialArr: (T)[], getChildrens: ((e:T) => (T)[]),\r\n                                                getID:((e:T)=>PrimitiveType)|undefined, returnWhenFound:((e:T)=>boolean), filter?:((e:T)=>boolean)): (T) {\r\n        return U.iterateChildProperties(initialArr, getChildrens, getID, returnWhenFound, filter)[0];\r\n    }\r\n    static iterateChildProperties<T extends D|L>(initialArr: (T)[], getChildrens: ((e:T) => (T)[]),\r\n                                                 getID?:((e:T)=>PrimitiveType), returnWhenFound?:((e:T)=>boolean), filter?:((e:T)=>boolean)): (T)[] {\r\n        let targets = initialArr;\r\n        let alreadyParsed: Dictionary<string|number, (T)> = {};\r\n        /*if (includeSelf) {\r\n            for (let t of targets) {\r\n                includeSelf\r\n            }\r\n        }*/\r\n        while (targets.length) {\r\n            let nextTargets: (T)[] = [];\r\n            for (let target of targets) {\r\n                if (!target) continue;\r\n                let tid = (getID ? getID(target) : (target?.id)) as any as (string | number);\r\n                if (alreadyParsed[tid]) continue;\r\n                if (filter && !filter(target)) continue;\r\n                alreadyParsed[tid] = target;\r\n                if (returnWhenFound && returnWhenFound(target)) return [target];\r\n                U.arrayMergeInPlace(nextTargets, getChildrens(target));\r\n            }\r\n            targets = nextTargets;\r\n        }\r\n        return Object.values(alreadyParsed);\r\n\r\n    }\r\n\r\n    static categorizeNode(c: LGraphElement|DGraphElement): {vertex: boolean, purevertex:boolean, field: boolean, graphvertex:boolean, puregraph: boolean, graph: boolean, edge:boolean, edgepoint: boolean}{\r\n        let ret = {} as any;\r\n        if (!c) return ret;\r\n        switch (c.className) {\r\n            case 'DEdge':\r\n            case 'DVoidEdge': ret.edge = true; break;\r\n            case 'DEdgePoint': ret.vertex = ret.edgepoint = true; ret.purevertex = false; break;\r\n            case 'DVertex':\r\n            case 'DVoidVertex': ret.vertex = ret.purevertex = true; break;\r\n            case 'DGraphVertex': ret.graph = true; ret.puregraph = ret.purevertex = false; break;\r\n            case 'DGraph': ret.graph = ret.puregraph = true; break;\r\n            case 'DGraphElement': ret.field = true; break;\r\n            default: Log.ee('unexpected node type:'+c.className); break;\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    // returns: isFullscreen\r\n    static toggleFullscreen(elem: HTMLElement): boolean {\r\n        if (U.fullscreenElement() === elem) { U.exitFullscreen(); return false; }\r\n        else { U.fullscreen(elem); return true; }\r\n    }\r\n\r\n    static fullscreen(elem: HTMLElement): Promise<void> {\r\n        // Find the right method, call on correct element\r\n        let e: any = elem;\r\n        if (e.requestFullscreen) return e.requestFullscreen();\r\n        if (e.mozRequestFullScreen) return e.mozRequestFullScreen();\r\n        if (e.webkitRequestFullscreen) return e.webkitRequestFullscreen();\r\n        if (e.msRequestFullscreen) return e.msRequestFullscreen();\r\n        return Promise.reject('unsupported');\r\n\r\n    }\r\n    static isFullscreen(): boolean {\r\n        let d: any = window.document;\r\n        return d.fullscreenEnabled || d.mozFullScreenEnabled || d.webkitFullscreenEnabled;\r\n    }\r\n    static fullscreenElement(): Element {\r\n        let d: any = window.document;\r\n        return d.fullscreenElement || d.mozFullScreenElement || d.webkitFullscreenElement;\r\n    }\r\n\r\n    static exitFullscreen(): Promise<void> {\r\n        let d: any = window.document;\r\n        if (d.exitFullscreen) return d.exitFullscreen();\r\n        if (d.mozCancelFullScreen) return d.mozCancelFullScreen();\r\n        if (d.webkitExitFullscreen) return d.webkitExitFullscreen();\r\n        return Promise.reject('unsupported');\r\n    }\r\n\r\n    static flattenObjectByKey<T extends GObject>(arr: (T|null|undefined)[], childKey: string):T[] {\r\n        let isArray = Array.isArray(arr);\r\n        if (!isArray) arr = [arr] as any;\r\n        let ret: T[] = [...arr as any];\r\n        for (let e of ret) {\r\n            let children = (e as any)?.[childKey];\r\n            if (!children || children.length === 0) continue;\r\n            U.arrayMergeInPlace(ret, U.flattenObjectByKey(children, childKey));\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    static isInfinite(m: number, positive = true, negative = true): m is (typeof NaN) {\r\n        if (m === Number.POSITIVE_INFINITY) return positive;\r\n        if (m === Number.NEGATIVE_INFINITY) return negative;\r\n        return false;\r\n    }\r\n\r\n    public static getHashParams(value: string): Dictionary<string, string>{\r\n        let search = window.location.hash;\r\n        let _index = search.indexOf('?');\r\n        if (_index >= 0) search = search.substring(_index+1);\r\n        let ret: Dictionary<string, string> = {};\r\n        for (let [key, entry] of new URLSearchParams(search).entries()) ret[key] = entry;\r\n        return ret;\r\n    }\r\n    public static getHashParam(arg_name: string): string | null {\r\n        let search = window.location.hash;\r\n        let _index = search.indexOf('?');\r\n        if (_index >= 0) search = search.substring(_index+1);\r\n        return new URLSearchParams(search).get(arg_name);\r\n    }\r\n}\r\nexport class DDate{\r\n    static cname: string = \"DDate\";\r\n\r\n    public static addDay(date: Date, offset: number, inplace: boolean): Date {\r\n        const ret: Date = inplace ? date : new Date(date);\r\n        ret.setDate(date.getDate() + offset);\r\n        return ret;\r\n    }\r\n    public static addMonth(date: Date, offset: number, inplace: boolean): Date {\r\n        const ret: Date = inplace ? date : new Date(date);\r\n        ret.setMonth(date.getMonth() + offset);\r\n        return ret;\r\n    }\r\n    public static addYear(date: Date, offset: number, inplace: boolean): Date {\r\n        const ret: Date = inplace ? date : new Date(date);\r\n        ret.setFullYear(date.getFullYear() + offset);\r\n        return ret;\r\n    }\r\n}\r\n\r\nexport class myFileReader {\r\n    private static input: HTMLInputElement = null as any;\r\n    private static fileTypes: string[] = null as any;\r\n    private static onchange: (e: Event) => void = null as any;\r\n    // constructor(onchange: (e: ChangeEvent) => void = null, fileTypes: FileReadTypeEnum[] | string[] = null) { myFileReader.setinfos(fileTypes, onchange); }\r\n    private static setinfos(fileTypes: undefined | FileReadTypeEnum[] | string[], onchange: (e: Event, files: FileList | null, contents: string[] | undefined ) => void, readcontent: boolean) {\r\n        myFileReader.fileTypes = (fileTypes || myFileReader.fileTypes) as string[];\r\n        const debug: boolean = false;\r\n        debug&&console.log('fileTypes:', myFileReader.fileTypes, fileTypes);\r\n        myFileReader.input = document.createElement('input');\r\n        const input: HTMLInputElement = myFileReader.input;\r\n        myFileReader.onchange = function (e: Event): void {\r\n            if (!readcontent) { onchange(e, input.files, undefined); return; }\r\n            let contentObj: Dictionary<number, string> = {};\r\n            let fileLetti: number = 0;\r\n            for (let i: number = 0; input.files && i <input.files.length; i++) {\r\n                const f: File = input.files[i];\r\n                debug&&console.log('filereadContent['+i+']( file:', f, ')');\r\n                U.fileReadContent(f, (content: string) => {\r\n                    debug&&console.log('file['+i+'] read complete. done: ' + ( 1 + fileLetti) + ' / ' + input.files?.length, 'contentObj:', contentObj);\r\n                    contentObj[i] = content; // cannot use array, i'm not sure the callbacks will be called in order. using push is safer but could alter order.\r\n                    // this is last file to read.\r\n                    if (input.files && ++fileLetti === input.files.length) {\r\n                        const contentArr: string[] = [];\r\n                        for (let j: number = 0; j < input.files.length; j++) { contentArr.push(contentObj[j]); }\r\n                        onchange(e, input.files, contentArr);\r\n                    }\r\n                });\r\n            }\r\n        } || myFileReader.onchange;\r\n    }\r\n    private static reset(): void {\r\n        myFileReader.fileTypes = undefined as any;\r\n        myFileReader.onchange = undefined as any;\r\n        myFileReader.input = undefined as any;\r\n    }\r\n    public static show(onChange: (e: Event, files: FileList | null, contents?: string[]) => void, extensions: undefined | string[] | FileReadTypeEnum[] = undefined, readContent: boolean): void {\r\n        console.log(\"importEcore: pre file reader\", myFileReader.input);\r\n        myFileReader.setinfos(extensions, onChange, readContent);\r\n        //if (!myFileReader.input) return;\r\n        myFileReader.input.setAttribute('type', 'file');\r\n        if (myFileReader.fileTypes) {\r\n            myFileReader.input.setAttribute('accept', myFileReader.fileTypes.join(','));\r\n        }\r\n        //console.log('fileTypes:', myFileReader.fileTypes, 'input:', myFileReader.input);\r\n        $(myFileReader.input).on('change.custom' as any, myFileReader.onchange).trigger('click');\r\n        myFileReader.reset();\r\n    }\r\n\r\n}\r\n@RuntimeAccessible('Uarr')\r\nexport class Uarr{\r\n    // filter can either be a value or a filter function\r\n    static findAllIndexes<T extends any>(arr: T[], filter: T | ((val: T, index: number, arr: T[]) => boolean)): number[] {\r\n        const ret: number[] = [];\r\n        let isFunc = typeof filter === 'function';\r\n        for (let i = 0; i < arr.length; i++) {\r\n            if (isFunc ? (filter as Function)(arr[i], i, arr) : arr[i] === filter) ret.push(i);\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    static arrayShallowCopy<T extends any | undefined | null>(arr: T, includeCustomKeys: boolean = true): T{\r\n        if (!arr) return arr;\r\n        if (!Array.isArray(arr)) return arr;\r\n        let ret: T&any[] = [] as any;\r\n        if (!includeCustomKeys) ret = arr.map(e=>e) as any; // because [...arr] is transforming empty positions in undefined\r\n        else {\r\n            for (let k in arr) {\r\n                if (!(arr as any[]).hasOwnProperty(k)) continue;\r\n                ret[k] = arr[k]; // it takes array custom keys\r\n            }\r\n        }\r\n        ret.length = (arr as any[]).length;\r\n        return ret;\r\n    }\r\n\r\n    public static isSubArray(array: any[], subarray: any[]): boolean {\r\n        return subarray.every((el) => array.includes(el));\r\n    }\r\n\r\n    static arrayDifference<T>(starting: T[], final: T[]): {added: T[], removed: T[], starting: T[], final: T[]} {\r\n        let ret: {added: T[], removed: T[], starting: T[], final: T[]} = {} as any;\r\n        ret.starting = starting;\r\n        ret.final = final;\r\n        if (!starting) starting = [];\r\n        if (!final) final = [];\r\n        ret.removed = Uarr.arraySubtract(starting, final, false); // start & !end\r\n        ret.added = Uarr.arraySubtract(final, starting, false); // end & !start\r\n        return ret;\r\n    }\r\n\r\n    public static arrayIntersection<T>(arr1: T[], arr2: T[]): T[]{\r\n        if (!arr1 || ! arr2) return null as any;\r\n        return arr1.filter( e => arr2.indexOf(e) >= 0);\r\n    }\r\n\r\n    static arraySubtract(arr1: any[], arr2: any[], inPlace: boolean): any[]{\r\n        let i: number;\r\n        const ret: any[] = inPlace ? arr1 : [...arr1];\r\n        for (i = 0; i < arr2.length; i++) { U.arrayRemoveAll(ret, arr2[i]); }\r\n        return ret; }\r\n\r\n    static equals<T extends any>(a1: T[], a2: T[], deep: boolean): boolean {\r\n        Log.ex(deep, \"deep array comparison is not supported yet\");\r\n        if (!a1 || !a2) return false;\r\n        if (a1.length !== a2.length) return false;\r\n        for (let i = 0; i < a1.length; i++) if (a1[i] !== a2[i]) return false;\r\n        return true;\r\n    }\r\n\r\n    static equalsUnsorted(a1: any[], a2: any[]): boolean {\r\n        let diff = Uarr.arrayDifference(a1, a2);\r\n        return (diff.removed.length === 0 && diff.added.length === 0);\r\n    }\r\n}\r\n\r\nexport class FocusHistoryEntry {\r\n    static cname: string = \"FocusHistoryEntry\";\r\n    time: Date;\r\n    evt: JQuery.FocusInEvent;\r\n    element: Element;\r\n    constructor(e: JQuery.FocusInEvent, element?: Element, time?: Date) {\r\n        this.evt = e;\r\n        this.element = element || e.target;\r\n        this.time = time || new Date();\r\n    }\r\n}\r\nexport enum ShortDefaultEClasses{\r\n    EObject = \"EObject\",\r\n    EAnnotation = \"EAnnotation\",\r\n    EClass = \"EClass\",\r\n    EPackage = \"EPackage\",\r\n    ENamedElement = \"ENamedElement\",\r\n}\r\nexport enum ShortAttribETypes {\r\n    EVoid = 'EVoid',\r\n    EChar  = 'EChar',\r\n    EString  = 'EString',\r\n    EDate  = 'EDate',\r\n    EBoolean = 'EBoolean',\r\n    EByte  = 'EByte',\r\n    EShort  = 'EShort',\r\n    EInt  = 'EInt',\r\n    ELong  = 'ELong',\r\n    EFloat  = 'EFloat',\r\n    EDouble  = 'EDouble',\r\n    // EDiagnosticChain = \"EDiagnosticChain\", // present in uml.ecore, without definition. i guess it's a custom installed package which is commonly used\r\n    /*\r\n  ECharObj  = 'ECharObj',\r\n  EStringObj  = 'EStringObj',\r\n  EDateObj  = 'EDateObj',\r\n  EFloatObj  = 'EFloatObj',\r\n  EDoubleObj  = 'EDoubleObj',\r\n  EBooleanObj = 'EBooleanObj',\r\n  EByteObj  = 'EByteObj',\r\n  EShortObj  = 'EShortObj',\r\n  EIntObj  = 'EIntObj',\r\n  ELongObj  = 'ELongObj',\r\n  EELIST  = 'EELIST',*/\r\n\r\n}\r\nwindoww.ShortAttribETypes = ShortAttribETypes;\r\n\r\nexport const ShortAttribSuperTypes: Dictionary<ShortAttribETypes, ShortAttribETypes[]> = {\r\n    \"EVoid\"    : [],\r\n    \"EChar\"    : [ShortAttribETypes.EString],\r\n    \"EString\"  : [],\r\n    \"EDate\"    : [],\r\n    \"EBoolean\" : [ShortAttribETypes.EByte, ShortAttribETypes.EShort, ShortAttribETypes.EInt, ShortAttribETypes.ELong, ShortAttribETypes.EFloat, ShortAttribETypes.EDouble],\r\n    \"EByte\"    : [ShortAttribETypes.EShort, ShortAttribETypes.EInt, ShortAttribETypes.ELong, ShortAttribETypes.EFloat, ShortAttribETypes.EDouble],\r\n    \"EShort\"   : [ShortAttribETypes.EInt, ShortAttribETypes.ELong, ShortAttribETypes.EFloat, ShortAttribETypes.EDouble],\r\n    \"EInt\"     : [ShortAttribETypes.ELong, ShortAttribETypes.EFloat, ShortAttribETypes.EDouble],\r\n    \"ELong\"    : [ShortAttribETypes.EFloat, ShortAttribETypes.EDouble],\r\n    \"EFloat\"   : [ShortAttribETypes.EDouble],\r\n    \"EDouble\"  : []\r\n};\r\nlet ecoreprefix = \"ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//\";\r\nlet ecoreclasprefix = \"ecore:EClass platform:/plugin/org.eclipse.emf.ecore/model/Ecore.ecore#//\";\r\nexport function toShortEType(a: AttribETypes): ShortAttribETypes{ return a.substring(ecoreprefix.length) as any; }\r\nexport function toLongEType(a: ShortAttribETypes): AttribETypes {\r\n    return AttribETypes[a];\r\n    // return ecoreprefix + a as any;\r\n}\r\n\r\nexport function toShortEClass(a: DefaultEClasses): ShortDefaultEClasses{ return a.substring(ecoreclasprefix.length) as any; }\r\nexport function toLongEClass(a: ShortDefaultEClasses): DefaultEClasses { return DefaultEClasses[a]; }\r\n\r\nexport class SelectorOutput {\r\n    jqselector!: string;\r\n    attrselector!: string;\r\n    attrRegex!: RegExp;\r\n    exception!: any;\r\n    resultSetAttr!: Attr[];\r\n    resultSetElem!: JQuery<Element>;\r\n}\r\n// compare it with event.key\r\nexport type Key = string;\r\n@RuntimeAccessible('Keystrokes')\r\nexport class Keystrokes {\r\n    static cname: string = 'Keystrokes'\r\n    public static clickLeft = 0;\r\n    public static clickWheel = 1;\r\n    public static clickRight = 2;\r\n    public static clickBackMouseButton = 3;\r\n    public static clickForwardMouseButton = 4;\r\n\r\n    // keyboard\r\n    public static escape = 'Escape';\r\n    public static capsLock = 'CapsLock';\r\n    public static shift = 'Shift';\r\n    public static tab = 'Tab';\r\n    public static alt = 'Alt';\r\n    public static cmd = 'Control';\r\n    public static control = 'Control';\r\n    public static end = 'End';\r\n    public static home = 'Home';\r\n    public static pageUp = 'PageUp';\r\n    public static pageDown = 'PageDown';\r\n    public static enter = 'Enter'; // event.code = 'NumpadEnter' se fatto da numpad, oppure \"numpad3\", \"NumpadMultiply\", ShiftLeft, etc...\r\n    public static numpadEnter = 'NumpadEnter';\r\n    public static audioVolumeMute = 'AudioVolumeMute';\r\n    public static audioVolumeUp = 'AudioVolumeUp';\r\n    public static audioVolumeDown = 'AudioVolumeDown';\r\n    public static mediaTrackPrevious = 'MediaTrackPrevious';\r\n    public static delete = 'Delete'; // canc\r\n    public static backspace = 'Backspace';\r\n    public static space = ' ';\r\n    public static altGraph = 'AltGraph';\r\n    public static arrowLeft = 'ArrowLeft';\r\n    public static arrowRight = 'ArrowRight';\r\n    public static arrowUp = 'ArrowUp';\r\n    public static arrowDown = 'ArrowDown';\r\n    public static insert = 'Insert';\r\n    public static f1 = 'F1';\r\n    // weird ones:\r\n    public static meta = 'Meta'; // f1, or other f's with custom binding and windows key\r\n    public static unidentified = 'Unidentified'; // brightness\r\n    public static __NotReacting__ = 'fn, print, maybe others'; // not even triggering event?\r\n    private static RegisteredKeyStrokes: Dictionary<DocString<'selector'>, {keyup: (e:any)=>any, keydown: (e:any)=>any}> = {};\r\n    public static register(selector: string, arr: {function?: ()=>any, keystroke?: Key[]}[]): void{\r\n        if (Keystrokes.RegisteredKeyStrokes[selector]) return;\r\n        let $elems = $(selector);// sort from most \"uncommon\" to most common key\r\n        let metakeysmap = {\r\n            [Keystrokes.alt]: 'altKey',\r\n            [Keystrokes.shift]: 'shiftKey',\r\n            [Keystrokes.control]: 'ctrlKey',/*\r\n            'altKey': Keystrokes.alt,\r\n            'shiftKey': Keystrokes.shift,\r\n            'ctrlKey': Keystrokes.control,*/\r\n        }; //  '??': 'metaKey'];*/\r\n        // let metakeys = ['altKey', 'shiftKey', 'ctrlKey'];\r\n\r\n\r\n        Log.exDev(!($elems.on as any), 'jQuery is required for Keystrokes.register');\r\n        let optimizedKeyPaths: GObject = {\r\n            [Keystrokes.alt]: {},\r\n            [Keystrokes.shift]: {},\r\n            [Keystrokes.control]: {},\r\n        }\r\n        for (let entry of arr) {\r\n            if (!entry || !entry.function || !entry.keystroke || !entry.keystroke.length) continue;\r\n            let keymap = U.objectFromArrayValues(entry.keystroke);\r\n            let root = optimizedKeyPaths\r\n            if (keymap[Keystrokes.alt]) {\r\n                if (!root[Keystrokes.alt]) root = root[Keystrokes.alt] = {};\r\n                else root = root[Keystrokes.alt];\r\n            }\r\n            if (keymap[Keystrokes.shift]) {\r\n                if (!root[Keystrokes.shift]) root = root[Keystrokes.shift] = {};\r\n                else root = root[Keystrokes.shift];\r\n            }\r\n            if (keymap[Keystrokes.control]) {\r\n                if (!root[Keystrokes.control]) root = root[Keystrokes.control] = {};\r\n                else root = root[Keystrokes.control];\r\n            }\r\n            let terminalKeys = entry.keystroke.filter(k => !(k in metakeysmap));\r\n            Log.eDev(terminalKeys.length !== 1, \"found a keystroke combination with multiple terminal keys\", {entry, selector});\r\n            let terminal = terminalKeys[0].toLowerCase();\r\n            root[terminal] = entry.function;\r\n        }\r\n        let keyup = (e: KeyUpEvent) => {\r\n            // skip events happened in graph\r\n            let curr = e.target;\r\n            while (curr) {\r\n                if (curr.classList.contains('Graph')) return;\r\n                curr = curr.parentElement;\r\n            }\r\n            // handle event\r\n            if (e.altKey) { $elems.removeClass('key-alt'); }\r\n            if (e.shiftKey) { $elems.removeClass('key-shift'); }\r\n            if (e.ctrlKey) { $elems.removeClass('key-ctrl'); }\r\n        }\r\n        let keydown = (e: KeyDownEvent) => {\r\n            // skip events happened in graph\r\n            let curr = e.target;\r\n            console.log('keydown', {selector, e, curr, ct:e.currentTarget});\r\n            while (curr) {\r\n                if (curr.classList.contains('Graph')) return;\r\n                curr = curr.parentElement;\r\n            }\r\n            // handle event\r\n            let root = optimizedKeyPaths;\r\n            if (e.altKey) { root = root[Keystrokes.alt] || {}; $elems.addClass('key-alt'); }\r\n            if (e.shiftKey) { root = root[Keystrokes.shift] || {}; $elems.addClass('key-shift'); }\r\n            if (e.ctrlKey) { root = root[Keystrokes.control] || {}; $elems.addClass('key-ctrl'); }\r\n            let f = root[e.key];\r\n            console.log(\"execute keystrokes\", {e, root, optimizedKeyPaths, up:{$elems, keydown, optimizedKeyPaths, arr}});\r\n            Log.exDev(f && typeof f !== 'function','found keystroke with invalid func', {f, root, e})\r\n            f?.();\r\n        };\r\n        /// todo: for graph can attack evt to graph root and use selector in on() lieke $graphcontainer.on('keydown', '.Class', classkeystrokehandler...)\r\n        Keystrokes.RegisteredKeyStrokes[selector] = {keydown, keyup, arr, optimizedKeyPaths} as any;\r\n        // $elems.off('keydown').on('keydown', null, keydown);\r\n        // $elems.off('keydown').on('keyup', null, keyup);\r\n        let $doc = $(document.body);\r\n        $doc.off('keydown', selector, keydown).on('keydown', selector, keydown);\r\n        $doc.off('keyup', selector, keyup).on('keyup', selector, keyup);\r\n\r\n    }\r\n    public static unregister(selector: string): void{\r\n        if (!Keystrokes.RegisteredKeyStrokes[selector]) return;\r\n        //$(selector).off('keydown', null as any, Keystrokes.RegisteredKeyStrokes[selector].keydown);\r\n        //$(selector).off('keyup', null as any, Keystrokes.RegisteredKeyStrokes[selector].keyup);\r\n\r\n        let $doc = $(document.body);\r\n        $doc.off('keydown', selector, Keystrokes.RegisteredKeyStrokes[selector].keydown);\r\n        $doc.off('keyup', selector, Keystrokes.RegisteredKeyStrokes[selector].keyup);\r\n\r\n        delete Keystrokes.RegisteredKeyStrokes[selector];\r\n    }\r\n\r\n\r\n    public static getKeystrokeJsx(key: string, allowBootIcons: boolean = true, allowBoxIcons: boolean=true, allowTextIcons: boolean = true){\r\n        let os = U.getOSBrowserData().os.substring(0, 3).toLowerCase();\r\n        let obj = iconKeys['bi_' + os];\r\n        if (!obj) return Log.eDevv('Found unexpected OS: ' + os, {data:U.getOSBrowserData()}) && '';\r\n        if (allowBootIcons && key in obj) { let val = obj[key]; return <i key={key} className={\"bi \" + val} title={key}/>; }\r\n        //obj = iconKeys['box_' + os];\r\n        // if (!obj) return Log.eDevv('Found unexpected OS: ' + os, {data:U.getOSBrowserData()}) && '';\r\n        //if (allowBoxIcons && key in obj) { let val = obj[key]; return <span><i className={\"box-icons?? \" + val todo} title={key}/></span>; }\r\n        obj = iconKeys['text_' + os];\r\n        if (!obj) return Log.eDevv('Found unexpected OS: ' + os, {data:U.getOSBrowserData()}) && '';\r\n        if (allowTextIcons && key in obj) { let val = obj[key]; return <i key={key} className={\"text-icon \" + val} title={key} data-val={val} data-content={key}/>; }\r\n        return <span key={key}>{key.toUpperCase()}</span>;\r\n    }\r\n    public static NamedKeys: Dictionary<string, boolean>;\r\n}\r\n\r\nconst iconKeys: Dictionary<string, Dictionary<string, string>> = {\r\n        bi_win: {\r\n            [Keystrokes.shift] : \"bi-shift\"\r\n        },\r\n        bi_mac: {\r\n            [Keystrokes.cmd]   : \"bi-command\",\r\n            [Keystrokes.control]   : \"bi-command\",\r\n            [Keystrokes.alt]   : \"bi-alt\",\r\n            [Keystrokes.shift] : \"bi-shift\"\r\n        },\r\n    box_win: {},\r\n    box_mac: {},\r\n    text_win: {\r\n        [Keystrokes.cmd]   : \"ctrl\",\r\n        [Keystrokes.control]   : \"ctrl\",\r\n        [Keystrokes.alt]   : \"alt\",\r\n        [Keystrokes.shift] : \"shift\"\r\n    },\r\n    text_mac: {},\r\n};\r\n\r\n// Keystrokes.NamedKeys: Dictionary<string, boolean> = Object.values(Keystrokes).reduce((acc, v) => { acc[v] = true; return acc; }, Keystrokes.NamedKeys as GObject);\r\n/*const windowsKeys: Dictionary<string, string> = {\r\n    [Key.cmd]: \"ctrl\", //'windows'; // <i className=\"bi bi-windows\"></i>\r\n    [Key.shift]: \"shift\",\r\n    [Key.alt]: \"alt\",\r\n}*/\r\n\r\n\r\nexport enum DefaultEClasses{\r\n    EObject = \"ecore:EClass platform:/plugin/org.eclipse.emf.ecore/model/Ecore.ecore#//EObject\",\r\n    EAnnotation = \"ecore:EClass platform:/plugin/org.eclipse.emf.ecore/model/Ecore.ecore#//EAnnotation\",\r\n    EClass = \"ecore:EClass platform:/plugin/org.eclipse.emf.ecore/model/Ecore.ecore#//EClass\",\r\n    EPackage = \"ecore:EClass platform:/plugin/org.eclipse.emf.ecore/model/Ecore.ecore#//EPackage\",\r\n    ENamedElement = \"ecore:EClass platform:/plugin/org.eclipse.emf.ecore/model/Ecore.ecore#//ENamedElement\",\r\n}\r\nexport enum AttribETypes {\r\n    EVoid = 'ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EVoid', // ??? i invented this.\r\n    EChar = 'ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EChar',\r\n    EString = 'ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EString',\r\n    EDate = 'ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EDate',\r\n    EFloat = 'ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EFloat',\r\n    EDouble = 'ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EDouble',\r\n    EBoolean = 'ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EBoolean',\r\n    EByte = 'ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EByte',\r\n    EShort = 'ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EShort',\r\n    EInt = 'ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EInt',\r\n    ELong = 'ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//ELong',\r\n    // present in uml.ecore, without definition. i guess it's a custom installed package which is commonly used\r\n    // EDiagnosticChain = 'ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EDiagnosticChain',\r\n    /*\r\n  ECharObj = 'ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//ECharObject',\r\n  EStringObj = 'ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EStringObject',\r\n  EDateObj = 'ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EDateObject',\r\n  EFloatObj = 'ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EFloatObject',\r\n  EDoubleObj = 'ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EDoubleObject',\r\n  EBooleanObj = 'ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EBooleanObj',\r\n  EByteObj = 'ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EByteObject',\r\n  EShortObj = 'ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EShortObject',\r\n  EIntObj = 'ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EIntegerObject',\r\n  ELongObj = 'ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//ELongObject', */\r\n    // EELIST = 'ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EEList', // List<E> = List<?>\r\n}\r\n\r\n// export type Json = object;\r\n\r\nexport class ParseNumberOrBooleanOptions{\r\n    defaultValue?: any;\r\n    allowNull?: boolean; nullValue?: any;\r\n    allowUndefined?: boolean; undefinedValue?: any;\r\n    allowedNan?: boolean; nanValue?: any;\r\n    allowBooleans?: boolean; trueValue?: any; falseValue?: any;\r\n    constructor(\r\n        defaultValue: any = null, allowNull: boolean = false, nullValue: any = null,\r\n        allowUndefined: boolean = false, undefinedValue: any = undefined,\r\n        allowedNan: boolean = false, nanValue: any = NaN,\r\n        allowBooleans: boolean = true, trueValue : any = 1, falseValue: any = 0) {\r\n        this.defaultValue = defaultValue; this.allowNull = allowNull; this.nullValue = nullValue;\r\n        this.allowUndefined = allowUndefined; this.undefinedValue = undefinedValue;\r\n        this.allowedNan = allowedNan; this.nanValue = nanValue;\r\n        this.allowBooleans = allowBooleans; this.trueValue = trueValue; this.falseValue = falseValue;\r\n    }\r\n}\r\n/*\r\ninterface LoggerInterface{\r\n    log: (category: string, key: string, data: any[], fullconcat?: string, stringified?: string) => any;\r\n}*/\r\n\r\n\r\n\r\nexport class FileReadTypeEnum {\r\n    public static image: FileReadTypeEnum = \"image/*\" as any;\r\n    public static audio: FileReadTypeEnum = \"audio/*\" as any;\r\n    public static video: FileReadTypeEnum = \"video/*\" as any;\r\n    /// a too much huge list https://www.iana.org/assignments/media-types/media-types.xhtml\r\n    public static AndManyOthersButThereAreTooMuch: string = \"And many others... https://www.iana.org/assignments/media-types/media-types.xhtml\";\r\n    public static OrJustPutFileExtension: string = \"OrJustPutFileExtension\";\r\n}\r\n\r\n// console.info('loaded ts U');\r\n","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\common\\DV.tsx",["857","858","859","860","861"],"import {\r\n    DGraphElement, Dictionary,\r\n    DModelElement,\r\n    DViewElement,\r\n    DViewPoint,\r\n    DVoidEdge,\r\n    EdgeBendingMode,\r\n    EdgeHead,\r\n    GObject,\r\n    GraphPoint, LPointerTargetable, LViewElement,\r\n    Pointer,\r\n    RuntimeAccessible,\r\n    ShortAttribETypes as SAType,\r\n    U, Draggable, Measurable\r\n} from '../joiner';\r\nimport React, {ReactNode, useState} from \"react\";\r\nimport {PaletteType} from \"../view/viewElement/view\";\r\nimport \"./error.scss\";\r\n\r\nconst notificationType: 'classic'|'alert'|'notification' = 'notification';\r\n\r\n// const beautify = require('js-beautify').html; // BEWARE: this adds some newline that might be breaking and introduce syntax errors in our JSX parser\r\nconst beautify = (s: string) => s;\r\nlet ShortAttribETypes: typeof SAType = (window as any).ShortAttribETypes;\r\n\r\n@RuntimeAccessible('DV')\r\nexport class DV {\r\n    public static invisibleJsx(): string { return ''; }\r\n    public static modelView(): string { return beautify(DefaultView.model()); }\r\n    public static packageView(): string { return beautify(DefaultView.package()); }\r\n    public static classView(): string { return beautify(DefaultView.class()); }\r\n    public static attributeView(): string { return beautify(DefaultView.feature()); }\r\n    public static referenceView(): string { return beautify(DefaultView.feature()); }\r\n    public static enumeratorView(): string { return beautify(DefaultView.enum()); }\r\n    public static literalView(): string { return beautify(DefaultView.literal()); }\r\n    public static fallbackView(): string { return beautify(DefaultView.void()); }\r\n    public static operationView(): string { return beautify(DefaultView.operation()); }\r\n    public static parameterView(): string { return beautify(DefaultView.parameter()); }\r\n\r\n    // i want to keep it because it will be useful for a candidate next feature in m1 & layoutable elements\r\n    // it is still work in progress.\r\n    public static operationViewm1(): string { return beautify(DefaultView.operationm1()); }\r\n    public static objectView(): string { return beautify(DefaultView.object()); }\r\n    public static valueView(): string { return beautify(DefaultView.value()); }\r\n    public static singletonView(): string { return beautify(DefaultView.singleton()); }\r\n    public static defaultPackage(): string { return beautify(DefaultView.defaultPackage()); }\r\n\r\n    public static errorView(publicmsg: ReactNode, debughiddenmsg:any, errortype: string, data?: DModelElement | undefined, node?: DGraphElement | undefined, v?: LViewElement|DViewElement): React.ReactNode {\r\n        let visibleMessage = publicmsg && typeof publicmsg === \"string\" ? U.replaceAll(publicmsg, \"Parse Error:\", \"\").trim() : publicmsg;\r\n        console.error(\"error in view:\", {publicmsg, debuginfo:debughiddenmsg});\r\n        return DefaultView.error(visibleMessage, errortype, data, node, v); }\r\n    public static errorView_string(publicmsg: string, debughiddenmsg:any, errortype: string, data?: DModelElement | undefined, node?: DGraphElement | undefined, v?: LViewElement|DViewElement): React.ReactNode {\r\n        let visibleMessage = publicmsg && typeof publicmsg === \"string\" ? U.replaceAll(publicmsg, \"Parse Error:\", \"\").trim() : publicmsg;\r\n        console.error(\"error in view:\", {publicmsg, debuginfo:debughiddenmsg});\r\n        return DefaultView.error_string(visibleMessage, errortype, data, node, v); }\r\n\r\n    // {ancors.map( a => <EdgePoint view={\"aaaaa\"} initialSize={{x: node.w * a.x, y: node.h * a.y}}/>)}\r\n    public static anchorJSX(): string { return (`\r\n<div className={\"overlap\"}>\r\n{Object.keys(anchors).map( (k) => { let a = anchors[k]; return(\r\n<div className={\"anchor draggable resizable\"} data-anchorName={a.name} data-anchorKey={k}\r\n    onDragEnd={(coords/*Point*/)=>node.events.dragAnchor(coords, k)} onMouseUp={()=>{node.events.assignAnchor(k)}}\r\n    style={{left: 100*a.x+'%', top:100*a.y+'%', width:a.w+'px', height:a.h+'px'}} />)})\r\n}</div>\r\n`);}\r\n    static edgePointView(): string { return beautify((\r\n`<div className={\"edgePoint\"} tabIndex=\"-1\">\r\n    {decorators}\r\n</div>`\r\n))}\r\n    static edgePointViewSVG(): string { return beautify(\r\n        `<ellipse stroke={\"black\"} fill={\"red\"} cx={\"50\"} cy={\"50\"} rx={\"20\"} ry={\"20\"} />`\r\n        //`<ellipse stroke={\"black\"} fill={\"red\"} cx={props.node.x} cy={props.node.y} rx={props.node.w} ry={props.node.h} />`\r\n    )}\r\n\r\n    static svgHeadTail(head: \"head\" | \"tail\", type: EdgeHead): string | undefined {\r\n        let ret: string;\r\n        let headstr = head===\"head\" ? \"segments.head\" : \"segments.tail\";\r\n        let styleTranslateRotate = 'transform:\"translate(\" + ' + headstr + '.x + \"px, \" + ' + headstr + '.y + \"px) rotate(\" + (' + headstr + '.rad) + \"rad)\",' +\r\n            ' \"transformOrigin\":'+headstr+'.w/2+\"px \"+ '+headstr+'.h/2+\"px\"';\r\n        let attrs = `\\n\\t\\t\\t\\tstyle={{`+styleTranslateRotate +`}}\\n\\t\\t\\t\\tclassName={\"` + head + ` ` + type +` preview\"} />\\n`;\r\n        let path: string;\r\n        let hoverAttrs = `\\n\\t\\t\\t\\tstyle={{`+styleTranslateRotate +`}}\\n\\t\\t\\t\\tclassName={\"` + head + ` ` + type +` clickable content\"} tabIndex=\"-1\" />\\n`;\r\n        let d: string;\r\n        switch (type) {\r\n            default:\r\n                ret = \"edge '\" + head + \"' with type: '\" +type + \"' not found\";\r\n                break;\r\n            case EdgeHead.extend:\r\n                //if (head === \"tail\") return undefined;\r\n                d = `M 0 0   L x y/2   L 0 y   Z`;\r\n                path = `<path  `;\r\n                ret = path + attrs + \"\\n\\t\\t\\t\\t\" + path + hoverAttrs;\r\n                break;\r\n            case EdgeHead.reference:\r\n                //if (head === \"tail\") return undefined;\r\n                d = `M 0 0   L x y/2   L 0 y`;\r\n                path = `<path  `;\r\n                ret = path + attrs + \"\\n\\t\\t\\t\\t\" + path + hoverAttrs;\r\n                break;\r\n            case EdgeHead.aggregation:\r\n                //if (head === \"head\") return undefined;\r\n                d = `M 0 y/2   L x/2 0   L x y/2   L x/2 y   Z`;\r\n                path = `<path  `;\r\n                ret = path + attrs + \"\\n\\t\\t\\t\\t\" + path + hoverAttrs;\r\n                break;\r\n            case EdgeHead.composition:\r\n                //if (head === \"head\") return undefined;\r\n                d = `M 0 y/2   L x/2 0   L x y/2   L x/2 y   Z`;\r\n                path = `<path  `;\r\n                ret = path + attrs + \"\\n\\t\\t\\t\\t\" + path + hoverAttrs;\r\n                break;\r\n                /* `<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" style={overflow: \"visible\"}>\r\n                                            <path d={\"M 10 0 L 0 20 L 20 20 Z\"} fill=\"#ffffff\" stroke=\"#808080\" strokeWidth=\"1\"></path>\r\n                                         </svg>`;*/\r\n                //  style={transform: \"rotate3d(xcenter, ycenter, zcenter??, 90deg)\"}\r\n        }\r\n        //  transform={\"rotate(\"+`+headstr+`.rad+\"rad \"+ segments.all[0].start.pt.toString(false, \" \")}\r\n        return ret; // no wrap because of .hoverable > .preview  on root & subelements must be consecutive\r\n        // return `<g className=\"edge`+head + ` ` + type +`\" style={` + styleTranslate + `}>\\n`+ ret +`</g>`\r\n    }\r\n\r\n    // about label rotation in .edge > foreignObect > div (label)\r\n    // first transform is h-center. second is rotate, third adds [0, 50%] of 50% vertical offset AFTER rotation to take label out of edge. fourth is to add a margin.\r\n    static edgeView(modename: EdgeHead, headSize: GraphPoint, tailSize: GraphPoint, dashing: string | undefined, vp: DViewElement, name: string): DViewElement {\r\n        let fill: string;\r\n        switch (modename){\r\n            case EdgeHead.reference:\r\n            default: fill = '#fff0'; break;\r\n            case EdgeHead.composition: fill = '#000'; break;\r\n            case EdgeHead.aggregation:\r\n            case EdgeHead.extend: fill = '#fff'; break;\r\n        }\r\n\r\n        const agglabel = \"◇ Aggregation / Composition\";\r\n        const extendlabel = \"△ \"+EdgeHead.extend;\r\n        const asslabel = \"Λ \"+EdgeHead.reference;\r\n        let headdict: Dictionary<string, string> = {\r\n            [asslabel]: 'M 0 0   L x y/2   L 0 y',\r\n            [extendlabel]: 'M 0 0   L x y/2   L 0 y   Z',\r\n            [agglabel]: 'M 0 y/2   L x/2 0   L x y/2   L x/2 y   Z',\r\n        };\r\n        let predefinedPaths: {k:string, v:string}[] = Object.entries(headdict).map((e)=>({k:e[0], v:e[1]}));\r\n\r\n        let headPath: string = '', tailPath: string = '';\r\n        switch (modename) {\r\n            default: break;\r\n            case EdgeHead.extend: headPath = extendlabel; break;\r\n            case EdgeHead.reference: headPath = asslabel; break;\r\n            case EdgeHead.aggregation: tailPath = agglabel; break;\r\n            case EdgeHead.composition: tailPath = agglabel; break;\r\n        }\r\n        headPath = headdict[headPath] || '';\r\n        tailPath = headdict[tailPath] || '';\r\n\r\n        let palette: PaletteType = {\r\n            'anchorSize': {type: 'number', value:20, unit:'px'},\r\n            'dashing': {value:dashing || '', type: \"text\"},\r\n            'stroke-color': U.hexToPalette('#777'),\r\n            'stroke-width': {value:1, type: 'number', unit: 'px'},\r\n            'stroke-color-hover': U.hexToPalette('#000'),\r\n            'stroke-width-hover': {value:3, type: 'number', unit: 'px'},\r\n            'head': {type:'path', value:headPath, options: predefinedPaths, x:'edgeHeadSize.x', y:'edgeHeadSize.y'},\r\n            'tail': {type:'path', value:tailPath, options: predefinedPaths, x:'edgeTailSize.x', y:'edgeTailSize.y'},\r\n            'fill': U.hexToPalette(fill),\r\n        };\r\n\r\n        let css = \".edge-anchor{\" +\r\n        \"\\n\\tcursor: crosshair;\" +\r\n        \"\\n\\tstroke: transparent;\" +\r\n        \"\\n\\tfill: none;\" +\r\n        \"\\n\\tr:var(--anchorSize);\" +\r\n        \"\\n\\toutline: var(--stroke-width) solid var(--stroke-color);\"+\r\n        \"\\n\\toutline-offset: calc(var(--stroke-width) * -1);\" +\r\n        \"\\n\\tborder-radius: 100%;\" +\r\n        \"\\n}\" +\r\n        \"\\n.clickthrough, .unclickable{\" +\r\n        \"\\n\\tpointer-events: none;\" +\r\n        \"\\n}\" +\r\n        \"\\n.clickable{\" +\r\n        \"\\n\\tpointer-events: all;\" +\r\n        \"\\n}\" +\r\n        \"\\n.fullscreen{\" +\r\n        \"\\n\\toverflow: visible;\" +\r\n        \"\\n\\twidth: 100vw;\" +\r\n        \"\\n\\theight: 100vh;\" +\r\n        \"\\n}\" +\r\n        \"\\npath{\" +\r\n        \"\\n\\tfill: none;\" +\r\n        \"\\n\\tstroke-dasharray: var(--dashing);\" +\r\n        \"\\n\\t&.head{\" +\r\n        \"\\n\\t\\td: path(var(--head));\" +\r\n        \"\\n\\t}\" +\r\n        \"\\n\\t&.tail{\" +\r\n        \"\\n\\t\\td: path(var(--tail));\" +\r\n        \"\\n\\t}\" +\r\n        \"\\n}\" +\r\n        \"\\npath.edge.full, path.tail, path.head{\" +\r\n        \"\\n\\tstroke: var(--stroke-color);\" +\r\n        \"\\n\\tstroke-width: var(--stroke-width);\" +\r\n        \"\\n}\" +\r\n        \"\\npath.tail, path.head{\" +\r\n        \"\\n\\tfill:var(--fill);\" +\r\n        \"\\n}\" +\r\n        \"\\npath.edge.full.hover-activator{\" +\r\n        \"\\n\\tstroke-width: var(--stroke-width-hover);\" +\r\n        \"\\n\\tstroke: none;\" +\r\n        \"\\n}\" +\r\n        \"\\npath.content{\" +\r\n        \"\\n\\tstroke: var(--stroke-color-hover);\" +\r\n        \"\\n\\tstroke-width: var(--stroke-width-hover);\" +\r\n        \"\\n}\" +\r\n        \"\\n.label-text{\" +\r\n        \"\\n\\tcolor: var(--stroke-color);\" +\r\n        \"\\n}\" +\r\n        \"\\nforeignObject.label{\" +\r\n        \"\\n\\toverflow: visible;\" +\r\n        \"\\n\\tcolor: var(--stroke-color);\" +\r\n        \"\\n\\twidth: 0;\" +\r\n        \"\\n\\theight: 0;\" +\r\n        \"\\n\\twhite-space: pre;\" +\r\n        \"\\n\\t> div{\" +\r\n        \"\\n\\t\\twidth: fit-content;\" +\r\n        \"\\n\\t}\" +\r\n        \"\\n}\" +\r\n        \"\\n\\t\" +\r\n        \"\\n\\t\" +\r\n        \"\";\r\n        let head = DV.svgHeadTail(\"head\", modename) || '';\r\n        let tail = DV.svgHeadTail(\"tail\", modename) || '';\r\n        let jsx = beautify(\r\n        `<div className={\"edge hoverable hide-ep clickthrough fullscreen ` + modename + `\"}>\r\n            <svg className={\"clickthrough fullscreen\"}>\r\n                { /* edge full paths\r\n               \r\n                 first is preview path, normally seen\r\n                 third (segmented) is path onHover\r\n                 second is to enlarge the hover area of path.preview to the same as path.content, so i avoid hover loop enter-leave and graphical flashing\r\n                \r\n                */ }\r\n                <path className={\"preview edge full` + (dashing ? ' dashed' : '') + `\"} d={this.edge.d} />\r\n                <path className={\"preview edge full hover-activator\"} d={this.edge.d} />\r\n                { /* edge separate segments */ }\r\n                {segments && segments.all && segments.all.flatMap((s, i) => [\r\n                    <path key={i} tabIndex=\"-1\" className={\"clickable content segment\"} d={s.dpart} />,\r\n                    s.label && <foreignObject key={'label'} className=\"label\" x={(s.start.pt.x + s.end.pt.x)/2+\"px\"} y={(s.start.pt.y + s.end.pt.y)/2+\"px\"}>\r\n                    <div className={\"label-text\"}\r\n                     style={{transform: \"translate(-50%, 0%) rotate(\"+s.radLabels+\"rad) translate(0%, -\"+(1-0.5*Math.abs(Math.abs(s.radLabels)%Math.PI)/(Math.PI/2))*100+\"%)\"+\r\n                     \" translate(0%, -5px\"}}>{s.label}</div>\r\n                    </foreignObject>\r\n                ])}\r\n                { /* edge head */ }\r\n                ` + head + `\r\n                { /* edge tail */ }\r\n                ` + tail + `\r\n                { /* edge anchor start */ }\r\n                {edge.start && <circle className=\"edge-anchor content clickable no-drag\"\r\n                 style={{transform: \"translate(\" + segments.all[0].start.pt.x +\"px, \" + segments.all[0].start.pt.y +\"px)\"}}\r\n                 onMouseDown={()=> edge.startFollow=true}\r\n                 onMouseUp={()=> edge.startfollow=false} />}\r\n                { /* edge anchor end */ }\r\n                {edge.end && <circle className=\"edge-anchor content clickable no-drag\" `+ // cx={0*segments.all.last().end.pt.x} cy={0*segments.all.last().end.pt.y}\r\n                `style={{transform: \"translate(\" + segments.all.last().end.pt.x +\"px, \" + segments.all.last().end.pt.y +\"px)\"}}\r\n                 onMouseDown={()=> edge.endFollow=true}\r\n                 onMouseUp={()=> edge.endfollow=false} />}\r\n\r\n            </svg>\r\n            { /* interactively added edgepoints */ }\r\n            {\r\n                edge.midPoints.map( m => <EdgePoint data={edge.father.model.id} initialSize={m} key={m.id} view={\"EdgePoint\"} /> )\r\n            }\r\n            {decorators}\r\n        </div>`\r\n    );\r\n        let edgePrerenderFunc: string = \"(ret)=>{\\n\" +\r\n            \"// ** preparations and default behaviour here ** //\\n\" +\r\n            \"// add preparation code here (like for loops to count something), then list the dependencies below.\\n\" +\r\n            \"// ** declarations here ** //\\n\" +\r\n            \"\\n\"+\r\n            \"}\";\r\n\r\n        let edgeUsageDeclarations = \"(ret)=>{\\n\" +\r\n            \"// ** preparations and default behaviour here ** //\\n\" +\r\n            \"// ret.data = data\\n\" +\r\n            \"ret.edgeview = edge.view.id\\n\" +\r\n            \"ret.view = view\\n\" +\r\n            \"// data, edge, view are dependencies by default. delete them above if you want to remove them.\\n\" +\r\n            \"// add preparation code here (like for loops to count something), then list the dependencies below.\\n\" +\r\n            \"// ** declarations here ** //\\n\" +\r\n            \"ret.start = edge.start\\n\"+\r\n            \"ret.end = edge.end\\n\"+\r\n            \"ret.segments = edge.segments\\n\"+\r\n            \"}\";\r\n        let ev = DViewElement.new2(\"Edge\"+name, jsx, vp,\r\n            (v: DViewElement) => {\r\n                // v.appliableToClasses = [DVoidEdge.cname];\r\n                v.appliableTo = 'Edge';\r\n                v.bendingMode = EdgeBendingMode.Line;\r\n                v.edgeHeadSize = headSize;\r\n                v.edgeTailSize = tailSize;\r\n                //v.constants = edgeConstants;\r\n                v.palette = palette;\r\n                v.css = css\r\n                v.usageDeclarations = edgeUsageDeclarations;\r\n                v.preRenderFunc = edgePrerenderFunc;\r\n            }, false, 'Pointer_ViewEdge' + name);\r\n        return ev;\r\n    }\r\n    /*\r\n    {\r\n        false && edge.end.model.attributes.map( (m, index, arr) => <EdgePoint data={m.id} initialSize={(parent) => {\r\n            let segs = parent.segments.segments;\r\n            let pos = segs[0].start.pt.multiply(1-(index+1)/(arr.length+1), true).add(segs[segs.length-1].end.pt.multiply((index+1)/(arr.length+1), true));\r\n            // console.trace(\"initial ep\", {segs, pos, ratio:(index+1)/(arr.length+1), s:segs[0].start.pt, e:segs[segs.length-1].end.pt});\r\n            return {...pos, w:55, h:55}}} key={m.id} view={\"Pointer_ViewEdgePoint\"} /> )\r\n    }{\r\n        false && <EdgePoint key={\"midnode1\"} view={\"Pointer_ViewEdgePoint\"} />\r\n    }{\r\n        false && <EdgePoint key={\"midnode2\"} view={\"Pointer_ViewEdgePoint\"} />\r\n    }{\r\n        false && props.children && \"this would cause loop no idea why, needs to be fixed to allow passing EdgeNodes here\" || []\r\n    }\r\n    */\r\n    static semanticErrorOverlay_old() { return (\r\n`<section className=\"overlap\">\r\n    <div className=\"error-message\">Lowerbound violation</div>\r\n</section>`\r\n)}    static semanticErrorOverlay() { return (\r\n`<section className=\"overlap\">\r\n    {\r\n    /* how it works: when a validated property changes to an invalid state (let's say lowerbound)\r\n     - lowerbound updated, this cause an update on both the main and lowerbound views (due to usageDeclarations)\r\n     - the update triggers \"onDataUpdate\" event of main and lowerbound views, the latter updates the state setting the invalid message.\r\n     - this triggers another update of main and generic error views (not working??)\r\n     - \r\n     */\r\n     !errors.length ? null : <div className=\"error-message\">{errors.separator(<br/>)}</div>\r\n    }\r\n    \r\n</section>`\r\n)}\r\n\r\n\r\n} // DV class end\r\n\r\nlet valuecolormap: GObject = {};\r\nvaluecolormap[ShortAttribETypes.EBoolean] = \"orange\";\r\nvaluecolormap[ShortAttribETypes.EByte] = \"orange\";\r\nvaluecolormap[ShortAttribETypes.EShort] = \"orange\";\r\nvaluecolormap[ShortAttribETypes.EInt] = \"orange\";\r\nvaluecolormap[ShortAttribETypes.ELong] = \"orange\";\r\nvaluecolormap[ShortAttribETypes.EFloat] = \"orange\";\r\nvaluecolormap[ShortAttribETypes.EDouble] = \"orange\";\r\nvaluecolormap[ShortAttribETypes.EDate] = \"green\";\r\nvaluecolormap[ShortAttribETypes.EString] = \"green\";\r\nvaluecolormap[ShortAttribETypes.EChar] = \"green\";\r\nvaluecolormap[ShortAttribETypes.EVoid] = \"gray\";\r\n\r\nlet valuecolormap_str = JSON.stringify(valuecolormap); // can this be declared inside view.constants ?\r\n\r\n\r\ntype ErrorProps = {\r\n    dname: any,\r\n    nodename: any,\r\n    errortype: any,\r\n    on: any,\r\n    v: any,\r\n    msg: any\r\n};\r\n\r\n\r\n\r\n\r\n\r\nexport class DefaultView {\r\n\r\n    /* MODEL */\r\n\r\n    public static model(): string { return (\r\n`<View className={\\`root model ` + \"${grid && 'grid'}\" + `\\`}>\r\n<Scrollable graph={node}>\r\n    {!data && \"Model data missing.\"}\r\n    <div className={'edges'}>\r\n        {[\r\n            refEdges.map(se => <Edge data={se.start} start={se.startVertex} end={se.endVertex} anchorStart={0} anchorEnd={0} key={se.id} isReference={true} \r\n            view={'Edge' + (se.start.composition ? 'Composition' : (se.start.aggregation ? 'Aggregation' : 'Association'))} />),\r\n            extendEdges.map(se => <Edge data={se.start} start={se.startVertex} end={se.endVertex} view={'EdgeInheritance'} isExtend={true} key={se.id} />)\r\n        ]}\r\n    </div>\r\n    {/* metamodel only */}\r\n    {[\r\n        otherPackages.filter(p => p).map(pkg => <DefaultNode key={pkg.id} data={pkg} />),\r\n        level >= 1 && firstPackage && firstPackage.children.filter(c => c).map(classifier => <DefaultNode key={classifier.id} data={classifier} />)\r\n    ]}\r\n\r\n    {/* model only */}\r\n    {level >= 1 && m1Objects.filter(o => o).map(m1object => <DefaultNode key={m1object.id} data={m1object} />)}\r\n    {decorators}\r\n</Scrollable>\r\n\r\n{/* language designer defined controls */}\r\n<Control title={'Workbench'} payoff={'Options'}>\r\n    <Slider name={'level'} title={'Detail level '} node={node} max={3} />\r\n    <Toggle name={'grid'} title={'Grid'} node={node} />\r\n</Control>\r\n</View>`\r\n);}\r\n\r\n\r\n    public static void(): string { return (\r\n`<div className={'root void model-less round bg-white p-1'}>\r\n    <div>{data ? data.name : \"Shapeless\"} element</div>\r\n    <div>This element didn't match any primary view.</div>\r\n    {decorators}\r\n</div>`\r\n);}\r\n\r\n    /* PACKAGE */\r\n\r\n    public static package(): string { return (\r\n`<View className={'root package'}>\r\n    <Measurable draggable={true} resizable={true}><div>draggable resizable</div></Measurable>\r\n    <Measurable draggable={true}><div>draggable</div></Measurable>\r\n    <div className={'package-children'}>\r\n        {upperLevel >= 1 ? [\r\n            <label className={\"detail-level\"}>\r\n                <input onChange={(e)=>{node.state = {level:+e.target.value}}} min=\"0\" max=\"3\" type=\"range\" step=\"1\" value={level}/>\r\n                <div>Detail level:{level}</div>\r\n            </label>,\r\n            data.children.map(c => <DefaultNode key={c.id} data={c} />)\r\n        ] :\r\n        [\r\n            <div className={\"summary\"}><b>URI:</b><span className={\"ms-1\"}>{data.uri}</span></div>,\r\n            <div className={\"summary\"}>{[\r\n                data.classes.length ? data.classes.length + \" classes\" : '',\r\n                data.enumerators.length ? data.enumerators.length + \" enumerators\" : ''\r\n               ].filter(v=>!!v).join(',')}</div>\r\n        ]}\r\n    </div>\r\n    {decorators}\r\n</View>`\r\n);}\r\n\r\n    public static defaultPackage(): string { return (\r\n`<div className={'root package'}>\r\n    <div className={'package-children'}>\r\n        {data.children.map(c => <DefaultNode key={c.id} data={c} />)}\r\n    </div>\r\n    {decorators}\r\n</div>`\r\n);}\r\n\r\n    /* CLASS */\r\n\r\n// <View className={\"root class \" + (level === 1 && abstract ? \"abstract\")} + onClick={()=>{/*node.events.e1(Math.random().toFixed(3))*/}}>\r\n\r\npublic static class(): string { return (`<View className={\"root class\"} onClick={()=>{/*node.events.e1(Math.random().toFixed(3))*/}}>\r\n<div className={'header'}>\r\n    {data.isSingleton && <i className='bi bi-1-square'>&nbsp;</i>}\r\n    {level > 1 && <b className={'class-name'}>{interface ? 'Interface' : abstract ? 'Abstract Class' : 'Class'}: </b>}    \r\n    {level === 1 && <i className=\"bi bi-c-square-fill\"></i>}<Input data={data} field={'name'} hidden={true} autosize={true} />\r\n</div>\r\n\r\n{level > 2 && data.children.length > 0 && <hr/>}\r\n\r\n{level > 2 && \r\n    <div className={'class-children'}>\r\n        {level >= 2 && [\r\n            attributes.map(c => <DefaultNode key={c.id} data={c} />),\r\n            references.map(c => <DefaultNode key={c.id} data={c} />),\r\n            operations.map(c => <DefaultNode key={c.id} data={c} />)\r\n        ]\r\n        || [\r\n        <div className={\"summary\"}>{[\r\n            attributes.length ? attributes.length + \" attributes\" : '',\r\n            references.length ? references.length + \" references\" : '',\r\n            operations.length ? operations.length + \" operations\" : '',\r\n            !(attributes.length + references.length + operations.length) ? '- empty -' : ''\r\n            ].filter(v=>!!v).join(',')}</div>\r\n        ]\r\n        }\r\n    </div>\r\n}\r\n\r\n{decorators}\r\n</View>`);}\r\n\r\n\r\n    /* ENUM */\r\n\r\npublic static enum(): string { return (\r\n`<View className={'root enumerator'}>\r\n    <div className={'header'}>\r\n        {level > 1 && <b className={'enumerator-name'}>Enum:</b>}\r\n        {level == 1 && <i className=\"bi bi-explicit-fill\"></i>}<Input data={data} field={'name'} hidden={true} autosize={true} />\r\n    </div>\r\n    {level > 1 && <hr />}\r\n    <div className={'enumerator-children'}>\r\n        {level >= 2 && literals.map(c => <DefaultNode key={c.id} data={c}/>)}\r\n    </div>\r\n    {decorators}\r\n</View>`\r\n);}\r\n\r\n    /* FEATURE */\r\n\r\n    public static feature(): string { return (\r\n`<View className={'root feature w-100'}>\r\n    <span className={'feature-name'}>{data.name}:</span>\r\n    <Select data={data} field={'type'} />\r\n    {decorators}\r\n</View>`\r\n);}\r\n\r\n    /* LITERAL */\r\n\r\n    public static literal(): string { return (\r\n`<label className={'root literal d-block text-center'}>\r\n    {data.name}\r\n    {decorators}\r\n</label>`\r\n);}\r\n\r\n    /* OPERATION */\r\n\r\n    public static operation(): string { return (\r\n`<View className={'root operation w-100 hoverable'}>\r\n        <span className={'feature-name'}>{data.name + ' =>'}</span>\r\n        <Select data={data} field={'type'} />\r\n    <div className={\"parameters content\"}>\r\n    {data.exceptions.length ? \" throws \" + data.exceptions.join(\", \") : ''}\r\n    {\r\n        level >= 3 && data.parameters.map(p => <DefaultNode data={p} key={p.id} />)\r\n    }</div>\r\n    {decorators}\r\n</View>`\r\n);}\r\n\r\n    /* PARAMETER */\r\n\r\npublic static parameter(): string { return (\r\n`<View className={'root parameter w-100'}>\r\n    <span className={'feature-name'}>\r\n        {data.name + '' + (data.lowerBound === 0 ? '?:' : ':' )}\r\n    </span>\r\n    <Select data={data} field={'type'} />\r\n    <span className={\"modifier\"}>{data.upperBound > 1 || data.upperBound === -1 ? '[]' : ''}</span>\r\n    {decorators}\r\n</View>`\r\n);}\r\n\r\n    // i want to keep it because it will be useful for a candidate next feature in m1 & layoutable elements\r\n    // it is still work in progress.\r\n    public static operationm1(): string { return (\r\n`<div className={'d-flex root operationm1'} style={{paddingRight: \"6px\"}}>\r\n    <label className={'d-block ms-1'}>{this.props.data.instanceof.name}</label>\r\n    <label className={'d-block ms-auto hover-root'} style={{color:` + valuecolormap_str + `[this.props.data.values.type] || \"gray\"}}>\r\n        →→→\r\n        <div className=\"hover-content\">\r\n            <ParameterForm operation={this.props.data.id} vertical={true} />\r\n        </div>\r\n    </label>\r\n    {decorators}\r\n</div>`\r\n);}\r\n\r\n    public static objectOld(): string { return (\r\n`<div className={'round bg-white root class'}>\r\n    <label className={'ms-1'}>\r\n        <Input jsxLabel={<b className={'object-name'}>{data.instanceof ? data.instanceof.name : \"Object\"}:</b>} \r\n           data={data} field={'name'} hidden={true} autosize={true}/>\r\n    </label>\r\n    <hr />\r\n    <div className={'object-children'}>\r\n        { features.map(c => <DefaultNode key={c.id} data={c} />) }\r\n    </div>\r\n    {decorators}\r\n</div>`);\r\n}\r\n\r\n//     public static object(): string { return (\r\n// `<View className={'root object'}>\r\n//     <b className={'object-name'}>{data.instanceof ? data.instanceof.name : 'Object'}:</b>\r\n//     <Input data={data} field={'name'} hidden={true} autosize={true} />\r\n//     <hr/>\r\n//     <div className={'object-children'}>\r\n//         {level >= 2 && data.features.map(f => <DefaultNode key={f.id} data={f} />)}\r\n//     </div>\r\n//     {decorators}\r\n// </View>`\r\n// );}\r\n\r\n/* OBJECT */\r\n\r\npublic static object(): string { return (\r\n`<View className={'root object'}>\r\n    <b className={'object-name'}>{data.instanceof ? data.instanceof.name : 'Object'}:</b>\r\n    <Input data={data} field={'name'} hidden={true} autosize={true} />\r\n    <hr/>\r\n    <div className={'object-children'}>\r\n        {level >= 2 && data.features.map(f => <DefaultNode key={f.id} data={f} />)}\r\n    </div>\r\n    {decorators}\r\n</View>`\r\n);}\r\n\r\n    /* VALUE */\r\n\r\n    public static value() { return (\r\n`<View className={'root value d-flex'}>\r\n    {instanceofname && <label className={'d-block ms-1 name'}>{instanceofname}</label>}\r\n    {!instanceofname && <Input className='name' data={data} field={'name'} hidden={true} autosize={true} />}\r\n    <label className={'d-block m-auto values_str'} style={{color: constants[typeString] || 'gray'}}>\r\n        : {valuesString}\r\n    </label>\r\n    {decorators}\r\n</View>`\r\n);}\r\n\r\n    /* SINGLETON OBJECT */\r\n\r\n    public static singleton(): string { return (\r\n    `<div className={'singleton'}>\r\n        <div className={'header'}>\r\n            {data.name}        \r\n        </div>\r\n    </div>`);}\r\n\r\n    /* ERROR */\r\n\r\n    \r\n\r\n    public static error(msg: undefined | ReactNode, errortype: string | \"SYNTAX\" | \"RUNTIME\",\r\n                        data?: DModelElement | undefined, node?: DGraphElement | undefined, v?: LViewElement|DViewElement): React.ReactNode {\r\n\r\n        let dname: string | undefined = data && ((data as any).name || data.className.substring(1));\r\n        if (dname && dname.length >= 10) dname = dname.substring(0, 7) + '…';\r\n        let nodename: string = (node?.className || '').replace(/[^A-Z]+/g, \"\").substring(1);\r\n        let on = dname && nodename ? \" on \" + dname + \" / \" + nodename : (dname || nodename ? \" on \" + (dname || nodename) : '');\r\n\r\n        let lv: LViewElement | undefined = v ? ((v as any).__isProxy ? v as LViewElement : LPointerTargetable.wrap(v)) : undefined;\r\n        let viewpointname = lv?.viewpoint?.name ||'';\r\n\r\n        function openNotification(e: any) {\r\n            U.alert('e', 'Error in ' + v?.name + (viewpointname ? ' > '+viewpointname : ''), dname);\r\n            e.target.classList.add('opened');\r\n        }\r\n\r\n        switch (notificationType) {\r\n            case 'classic':\r\n                return (<Measurable draggable={true} resizable={true}><div className={'error-notification'}>\r\n                        <h1>Something Went Wrong...</h1>\r\n                        {v && <h2>Error in \"{v?.name}\" syntax view definition{viewpointname? ' in viewpoint ' + viewpointname : ''}.</h2>}\r\n                        <div className={'error-type'}>\r\n                            <b data-dname={dname} data-nodename={nodename} data-str={false}>\r\n                                {errortype} Error {on}\r\n                                {false && v && <div>While applying view \"{v?.name}\"</div>}\r\n                            </b>\r\n                        </div>\r\n                        <div className={'error-details'}>{msg}</div>\r\n                    </div></Measurable>);\r\n                break;\r\n            case 'alert':\r\n                U.alert('e', 'Error in ' + v?.name + (viewpointname ? 'of '+viewpointname : ''), dname);\r\n                break;\r\n            case 'notification':\r\n                return (<div className='notification-icon' onClick={(e) => openNotification(e)}/>);\r\n                break;\r\n        }\r\n    }\r\n\r\n    public static error_string(msg: undefined | ReactNode, errortype: string | \"SYNTAX\" | \"RUNTIME\", data?: DModelElement | undefined,\r\n                               node?: DGraphElement | undefined, v?: LViewElement|DViewElement) {\r\n        let dname: string | undefined = data && ((data as any).name || data.className.substring(1));\r\n        if (dname && dname.length >= 10) dname = dname.substring(0, 7) + '…';\r\n        let nodename: string = (node?.className || '').replace(/[^A-Z]+/g, \"\").substring(1);\r\n        let on = dname && nodename ? \" on \" + dname + \" / \" + nodename : (dname || nodename ? \" on \" + (dname || nodename) : '');\r\n\r\n        let lv: LViewElement | undefined = v ? ((v as any).__isProxy ? v as LViewElement : LPointerTargetable.wrap(v)) : undefined;\r\n        let viewpointname = lv?.viewpoint?.name ||'';\r\n        // <div className={'w-100 h-100 round bg-white border border-danger'} style={{minHeight:\"50px\", overflow:\"scroll\"}}>\r\n        //     <div className={'text-center text-danger'} tabIndex={-1} style={{background:\"#fff\", overflow: 'visible', zIndex:100, minWidth:\"min-content\"}}>\r\n        //         <b>{errortype}_ERROR` + on + `</b>\r\n        //         <hr/>\r\n        //         <label className={'text-center mx-1 d-block'}>\r\n        //             While applying view \"${v?.name}\"\r\n        //         </label>\r\n        //         {${msg} && <label className={'text-center mx-1 d-block'} style={{color:\"black\"}}>${msg}</label>}\r\n        //     </div>\r\n        // </div>\r\n        return `<Measurable draggable={true} resizable={true}><div className={'error-notification'}>\r\n            <h1>Something Went Wrong...</h1>\r\n            `+ (v && `<h2>Error in \"${v?.name}\" syntax view definition${viewpointname ? ' in viewpoint ' + viewpointname : ''}.</h2>`)+`\r\n            <div className={'error-type'}>\r\n                <b data-dname=${dname} data-nodename=${nodename} data-str={true}>\r\n                    ${errortype} Error ${on}\r\n                    {false && v && <div>While applying view \"${v?.name}\"</div>}\r\n                </b>\r\n            </div>\r\n            <div className={'error-details'}>${msg}</div>\r\n        </div></Measurable>)`;\r\n    }\r\n\r\n\r\n}\r\n","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\redux\\store.tsx",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\model\\classes\\L.ts",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\model\\classes\\D.ts",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\view\\viewPoint\\viewpoint.ts",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\graph\\graphElement\\GraphDragHandler.ts",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\joiner\\components.tsx",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\pages\\index.ts",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\pages\\components\\index.ts",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\common\\UX.tsx",["862","863","864","865","866","867"],"import ReactJson from 'react-json-view' // npm i react-json-view\r\nimport React, {ReactElement, ReactNode} from \"react\";\r\nimport withReactContent from \"sweetalert2-react-content\";\r\nimport Swal from \"sweetalert2\";\r\nimport {GraphElementOwnProps, GObject, Dictionary, DocString, Pointer, LGraph, MultiSelectOptGroup} from \"../joiner\";\r\nimport type { InputOwnProps, SelectOwnProps } from '../components/forEndUser/Input';\r\nimport type {  } from '../components/forEndUser/Select';\r\nimport {\r\n    LPointerTargetable,\r\n    U,\r\n    Log,\r\n    GraphElementComponent,\r\n    windoww,\r\n    RuntimeAccessible,\r\n    EdgeComponent,\r\n    RuntimeAccessibleClass,\r\n    EdgeOwnProps,\r\n    DGraphElement,\r\n    DModelElement,\r\n    transientProperties, JSXT, DViewElement\r\n} from \"../joiner\";\r\nimport {AllPropss} from \"../graph/vertex/Vertex\";\r\n\r\nvar Convert = require('ansi-to-html');\r\n\r\n// U-functions that require jsx\r\n@RuntimeAccessible('UX')\r\nexport class UX{\r\n\r\n    static recursiveMap<T extends ReactNode | ReactNode[] | null | undefined>(children: T, fn: (rn: T, i: number, depthIndices: number[])=>T, depthIndices: number[] = []): T {\r\n        // NB: depthIndices is correct but if there is an expression children evaluated to false like {false && <jsx>},\r\n        // it counts as children iterated regardless. so html indices might be apparently off, but like this is even safer as indices won't change when conditions are changed.\r\n        const innermap = (child: ReactNode, i1: number, depthIndices: number[]): T => {\r\n            if (!React.isValidElement(child)) {\r\n                if (Array.isArray(child)) return React.Children.map(child as T, (c: T, i3: number)=>innermap(c, i3, [...depthIndices,i3])) as T;\r\n                if (child && typeof child === \"object\") {\r\n                    if (!windoww.invalidObjsReact) windoww.invalidObjsReact = [];\r\n                    windoww.invalidObjsReact.push(child);\r\n                    return \"<! Objects cannot be rendered in jsx : \" + (child as any)?.name + \">\" as T;\r\n                }\r\n                return child as T; }\r\n            if (child.props.children) {\r\n                // let deeperDepthIndices = [...depthIndices, i1];  // depthIndices; //\r\n                // should probably change deeperDepthIndices in [...deeperDepthIndices, i] in next uncommented line.\r\n                // Giordano: add ignore for webpack\r\n                //@ts-ignore\r\n                child = React.cloneElement(child, { children: UX.recursiveMap(child.props.children,\r\n                        (e: T, i2: number, ii) => fn(e, i2, ii), depthIndices) });\r\n                // this can be optimized, and i think i can avoid cloning here, as the nodes are already cloned in \"fn\" = ux.injectprops\r\n            }\r\n            return fn(child as T, i1, depthIndices);\r\n        };\r\n        if (!Array.isArray(children)) return innermap(children as ReactNode, 0, [...depthIndices, 0]) as T;\r\n        // if (typeof children[0] === \"object\") return (children).map( (c: T, i3: number)=>innermap(c, i3, [...depthIndices,i3])) as any as T;\r\n        return React.Children.map(children, (c: T, i3: number)=>innermap(c, i3, [...depthIndices,i3])) as T;\r\n    }\r\n    /*\r\n    public static draggable_eventmap = {\r\n        's':    {'draggable': 'onDragStart',    'rotatable': 'onRotateStart',   'resizable': 'onResizeStart'},\r\n        'ing':  {'draggable': 'whileDragging',  'rotatable': 'whileRotating',   'resizable': 'whileResizing'},\r\n        'e':    {'draggable': 'onDragEnd',      'rotatable': 'onRotateEnd',     'resizable': 'onResizeEnd'  },\r\n    };\r\n    public static draggable_eventprops= UX.initMeasurable();\r\n    static initMeasurable(): Dictionary<string, boolean>{\r\n        return U.objectFromArrayValues(Object.values(UX.draggable_eventmap).flatMap(v=>Object.values(v)), true);\r\n    }*/\r\n\r\n    static injectProp(parentComponent: GraphElementComponent, e: ReactNode, gvidmap_useless: Dictionary<DocString<'VertexID'>, boolean>,\r\n                      parentnodeid: string, index: number, indices: number[], injectOffset?: LGraph): ReactNode {\r\n        let re: ReactElement | null = UX.ReactNodeAsElement(e);\r\n\r\n        // injectOffset&&console.log(\"inject offset props 1:\", {e, re, injectOffset});\r\n        if (!re) return e;\r\n        // @ts-ignore this\r\n        // const parentComponent = this;\r\n        const type = (re.type as any).WrappedComponent?.name || re.type;\r\n        let injectProps: GraphElementOwnProps = {} as any;\r\n        /* if (false && injectOffset) {\r\n            const style = {...(re.props?.style || {})};\r\n            let offset = injectOffset.offset;\r\n            let scale = injectOffset.zoom;\r\n            style.position = \"absolute\";\r\n            style.left = offset.x;\r\n            style.top = offset.y;\r\n            style.transform = \"scale(\" + scale.x + \",\" + scale.y + \")\"\r\n            injectProps.style = style;\r\n            console.log(\"inject offset props:\", {re, injectProps});\r\n        }*/\r\n        //  fix the injection somehow. override Edge() Vertex() Asterisk() ...\r\n        // const windoww = window as any;\r\n        // console.log('ux.injectingProp pre ', {type: (re.type as any).WrappedComponent?.name || re.type}, {mycomponents: windoww.mycomponents, re, props:re.props});\r\n        // add \"view\" (view id) prop as default to sub-elements of any depth to inherit the view of the parent unless the user forced another view to apply\r\n        switch (type) {\r\n            default:\r\n                // console.count('ux.injectingProp case default: ' + type);\r\n                if (indices.length <= 2 && (parentComponent?.props?.childStyle)) {\r\n                    // if first non-component child of a GraphElement with a clipPath shape, i assign clip path to it.\r\n                    console.log('injecting to first child (A):', {re, indices, il: indices.length, pc: parentComponent, injectProps, cs:parentComponent.props.childStyle});\r\n                    let istyle: GObject = injectProps.style = {...(injectProps.style || {})};\r\n                    injectProps.style = injectProps.style ? {...injectProps.style} : {};\r\n                    U.objectMergeInPlace(injectProps.style, parentComponent.props.childStyle);\r\n                } else return re;\r\n                break;\r\n            /*\r\n            case windoww.Components.Input.name:\r\n            case windoww.Components.Textarea.name:\r\n                const objid =  re.props.obj?.id || re.props.obj || parentComponent.props.data.id;\r\n                const ret = React.cloneElement(re, {key: UX.getKey(re) || parentComponent.props.view.id + '_' + parentComponent.props.data.id + '_' + re.props.field, obj: objid, obj2: objid});\r\n                //console.log('relement Input set props',\r\n                //    {'re.props.obj.id': re.props.obj?.id, 're.props.obj': re.props.obj, 'thiss.props.data.id': thiss.props.data.id, thiss, re, objid, ret, 'ret.props': ret.props});\r\n                return ret;*/\r\n            // case windoww.Components.GraphElement.name:\r\n            case windoww.Components.Input.cname+\"Component\":\r\n            case windoww.Components.Select.cname+\"Component\":\r\n            case windoww.Components.TextArea.cname+\"Component\":\r\n                // todo: can i do a injector that if the user provides a ModelElement list raw <div>{this.children}</div> it wraps them in DefaultNode?\r\n                const injectProps2: InputOwnProps | SelectOwnProps = {} as any;\r\n                const parentnodeid = parentComponent.props.node?.id;\r\n                injectProps2.data = re.props.data || (typeof parentComponent.props.data === \"string\" ? parentComponent.props.data : parentComponent.props.data?.id);\r\n                // !IMPORTANT! this key does not remove the responsability of adding keys to <GraphElement>s. this is assigning the key to the first returned element by component A,\r\n                // but react needs to distinguish component A from other components, and he still doesn't have a key. in fact this is useless as this component can only have 1 child\r\n                injectProps2.key = UX.getKey(re) || (parentnodeid + \"_input_\"+index);\r\n                return React.cloneElement(re, injectProps2);\r\n            case windoww.Components.GraphElementComponent.cname:\r\n            // case windoww.Components.DefaultNode.name:\r\n            case windoww.Components.DefaultNodeComponent.cname:\r\n            // case windoww.Components.Graph.name:\r\n            // case windoww.Components.GraphComponent.cname:\r\n            case \"Graph\": case \"GraphComponent\":\r\n            // case windoww.Components.Field.name:\r\n            // case windoww.Components.FieldComponent.cname:\r\n            // case windoww.Components.Vertex.name:\r\n            case EdgeComponent.cname:\r\n            case windoww.Components.VertexComponent.cname:\r\n                injectProps.parentViewId = parentComponent.props.view.id || (parentComponent.props.view as any); // re.props.view ||  thiss.props.view\r\n                injectProps.parentnodeid = parentComponent.props.node?.id;\r\n                injectProps.graphid = parentComponent.props.graphid;\r\n                // const vidmap = GraphElementRaw.graphVertexID_counter;\r\n                // if (!vidmap[injectProps.graphid]) vidmap[injectProps.graphid] = {};\r\n                // const gvidmap = vidmap[injectProps.graphid];\r\n                // const validVertexIdCondition = (id: string): boolean => gvidmap_useless[id];\r\n                // todo: come butto dei sotto-vertici dentro un vertice contenitore? o dentro un sotto-grafo? senza modificare il jsx ma solo draggando? React-portals?\r\n                const dataid = (typeof re.props.data === \"string\" ? re.props.data : re.props.data?.id) || \"shapeless\";\r\n                let idbasename: string;\r\n\r\n                //console.log('injecting props ' + type, {re, pc: parentComponent, injectProps, ownProps: re.props});\r\n                if (re.props.initialSize?.id) { idbasename = re.props.initialSize?.id; } else\r\n                if (re.props.nodeid) { idbasename = re.props.nodeid; } else\r\n                if (re.props.id) { idbasename = re.props.id; } else\r\n                if (UX.getKey(re)) {\r\n                    idbasename = injectProps.parentnodeid + \"_\" +UX.getKey(re);\r\n                    // console.log(\"keyid: \", {idbasename});\r\n                }\r\n                else switch (type) {\r\n                    default:\r\n                        idbasename = injectProps.parentnodeid + \"_\" + dataid + \"N\";\r\n                        break;\r\n                    case windoww.Components.EdgePoint.cname:\r\n                        idbasename = injectProps.parentnodeid + \"_\" + (dataid || re.props.startingSize?.id || indices.join(\"_\")) + \"EP\";\r\n                        break;\r\n                    case EdgeComponent.cname: case \"Edge\":\r\n                        //console.log('injecting props ' + type + \" without key\", {re, pc: parentComponent, injectProps, ownProps: re.props});\r\n                        let edgeProps:EdgeOwnProps = re.props;\r\n                        let edgestart_id: Pointer<DGraphElement> | Pointer<DModelElement> = (edgeProps.start as any).id || edgeProps.start;\r\n                        let edgeend_id: Pointer<DGraphElement> | Pointer<DModelElement> = (edgeProps.end as any).id || edgeProps.end;\r\n                        idbasename = injectProps.parentnodeid + \"_\" + edgestart_id + \"-\" + edgeend_id;\r\n                }\r\n                // (injectProps.parentnodeid)+\"_\"+(dataid)+indices.join(\"_\");//injectProps.graphid + '_' + dataid;\r\n                // console.log(\"setting nodeid\", {injectProps, props:re.props, re});\r\n                // Log.exDev(!injectProps.graphid || !dataid, 'vertex is missing mandatory props.', {graphid: injectProps.graphid, dataid, props: re.props});\r\n                Log.exDev(!injectProps.graphid, 'vertex is missing mandatory props (graphid).', {graphid: injectProps.graphid, dataid, props: re.props});\r\n                if (false && indices.length === 2) {\r\n                    // if first component child, of a component? like (DefaultNode -> Vertex)?\r\n                    console.log('injecting to first child (B):', {re, pc: parentComponent, injectProps});\r\n                    if (parentComponent?.props.style?.clipPath) injectProps.style = {...(injectProps.style || {}), clipPath: parentComponent?.props.style?.clipPath||''}\r\n                }\r\n                injectProps.nodeid = idbasename; // U.increaseEndingNumber(idbasename, false, false, validVertexIdCondition);\r\n                injectProps.htmlindex = indices[indices.length - 1]; // re.props.node ? re.props.node.htmlindex : indices[indices.length - 1];\r\n                injectProps.key = UX.getKey(re) || injectProps.nodeid;\r\n                // console.log(\"cloning jsx:\", re, injectProps);\r\n                Log.ex((injectProps.nodeid === injectProps.graphid||injectProps.nodeid === injectProps.parentnodeid) && type !== \"GraphComponent\", \"User manually assigned a invalid node id. please remove or change prop \\\"nodeid\\\"\", {type: (re.type as any).WrappedComponent?.cname || re.type}, {mycomponents: windoww.mycomponents, re, props:re.props});\r\n        }\r\n        //console.log('injecting props ' + type, {id: injectProps.nodeid, re, pc: parentComponent, injectProps});\r\n        return React.cloneElement(re, injectProps);\r\n    }\r\n\r\n    static ReactNodeAsElement(e: React.ReactNode): React.ReactElement | null {\r\n        return e && (e as ReactElement).type ? e as ReactElement : null;\r\n    }\r\n    static getKey(e: ReactNode): string | undefined {\r\n        return (e as any)?.key; // NOT e.props.key, key is not a part of props in ReactNode.\r\n    }\r\n\r\n    public static async deleteWithAlarm(lItem: LPointerTargetable) {\r\n        const MySwal = withReactContent(Swal);\r\n        const confirm = await MySwal.fire({\r\n            title: \"Delete \" + lItem.toString() + \"?\",\r\n            showCancelButton: true,\r\n            confirmButtonText: \"Yes\",\r\n            cancelButtonText: \"No\",\r\n            showLoaderOnConfirm: true\r\n        });\r\n        if (confirm.value === true) {\r\n            lItem.delete();\r\n        }\r\n    }\r\n    public static async info(text: string) {\r\n        const MySwal = withReactContent(Swal);\r\n        const confirm = await MySwal.fire({\r\n            title: text,\r\n            showCancelButton: false,\r\n            confirmButtonText: \"Got It\"\r\n        });\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    private static initPropInjectionStuff(): string[]{\r\n        UX.graphComponents = ['GraphElement', '...more'];\r\n        UX.inputComponents = ['Input', 'Select', 'TextArea','...more'];\r\n        UX.graphComponentsRegexp = new RegExp(UX.graphComponents.map(s=>'(?:;\\\\}\\\\)\\\\]\\\\,\\\\;\\\\s)'+s+'\\\\(').join('|'));\r\n        UX.inputComponentRegexp = new RegExp(UX.graphComponents.map(s=>'(?:;\\\\}\\\\)\\]\\\\,\\\\;\\\\s)'+s+'\\\\(').join('|'));\r\n        UX.viewRootProps = '\"data-viewid\": props.viewid,' +\r\n            ' addStyle: (offset ? {position:\"absolute\", left:offset.x, top:offset.y/*,transform:\"scale(\"+zoom.x+\",\"+zoom.y+\")\"*/} : undefined)';\r\n        UX.mainViewRootProps = 'ref: component.html, id: props.nodeid, \"data-nodeid\": props.nodeid, \"data-dataid\": props.dataid,\\n' +\r\n            '\"data-modelname\": data?.className || \"model-less\",' +\r\n            '\"data-userselecting\": JSON.stringify(node.isSelected || {}),' +\r\n            '\"data-nodetype\": node.className, ' +\r\n            '\"data-parentview\": props.parentviewid, ' +\r\n            //'\"data-order\": node.zIndex,' +\r\n            'onClick: component.onClick,' +\r\n            'onContextMenu: component.onContextMenu,' +\r\n            'onMouseDown: component.onMouseDown,' +\r\n            'onMouseUp: component.onMouseUp,' +\r\n            'onWheel: component.onScroll,' +\r\n            'onMouseEnter: component.onEnter,' +\r\n            'onMouseLeave: component.onLeave,' +\r\n            'tabIndex: (props as any).tabIndex || node.zIndex || -1,' +\r\n            '\"data-countrenders\": component.countRenders++,' +\r\n            'decorators: otherViews,'+// used in user jsx to inject decorator views\r\n            'classNameAdd: [(component.countRenders%2 ? \"animate-on-update-even\" : \"animate-on-update-odd\"),\"mainView\", props.viewid, ...props.viewsid].join(\",\"),' +\r\n            '...this.props';\r\n        UX.decorativeViewRootProps +='classNameAdd: \"decorativeView \" + props.viewid, \"data-mainview\": mainviewid';\r\n        return UX.graphComponents\r\n    }\r\n    private static graphComponents: string[] = UX.initPropInjectionStuff();\r\n    private static inputComponents: string[] = undefined as any;\r\n    private static graphComponentsRegexp: RegExp = undefined as any;\r\n    private static inputComponentRegexp: RegExp = undefined as any;\r\n    private static GC_propsAdder(index: number): string { return \"nodeid: window._assignnodeid(props, \"+index+\"), key:\"+index; }\r\n    private static Input_propsAdder(index: number):string { return \"key:\"+index; }\r\n    private static injectPropsToString_addstuff(s: string, index: number, props: string, type: string, propsAdder?:((index: number)=>string) | undefined): string { // move out in global scope\r\n        switch (s[index]) {\r\n            case '{': // props object\r\n                // let propstr = JSON.stringify(propsToInjectAtRoot);\r\n                // propstr = propstr.substring(1, propstr.length-2);\r\n                s = s.substring(0, index+1) + props + (propsAdder ? ','+propsAdder(index) : '') + ',' + s.substring(index+1);\r\n                break;\r\n            case 'n': // null:\r\n                // let propstr = JSON.stringify(propsToInjectAtRoot)\r\n                s = s.substring(0, index) + '{'+props+(propsAdder ? ','+propsAdder(index) : '') + '}' + s.substring(index+4);\r\n                break;\r\n            default: Log.exDevv('unexpected string in '+type+' props injection parser',\r\n                {s_pre:s.substring(index-10, 10), s_post:s.substring(index, index+10), index, c:s[index], fullstr:s});\r\n                break;\r\n        }\r\n        return s;\r\n    }\r\n    private static viewRootProps: string;\r\n    private static decorativeViewRootProps: string;\r\n    private static mainViewRootProps: string;\r\n// propsToInject cannot be an object because i need variable names as prop values, NOT strings, not their immediate values. so i pass a string with a list of props\r\n    static injectPropsToString(s: string, asMainView:boolean, graphComponentsProps: string, inputComponentProps: string){\r\n        // non-root props are injected through Component constructors instead\r\n        // plan B instead: make it  \"DefaultNde({pa: \"pa\"}, [\"a\", [b,c]])\" ---> \"Root(DefaultNde, {pa: \"pa\"}, [\"a\", [b,c]]) and handle injection in Root func\r\n        const propsToInjectAtRoot = UX.viewRootProps + ','+(asMainView ? UX.mainViewRootProps : UX.decorativeViewRootProps);\r\n        //add in context: component = (this as GraphElementComponent), otherViews\r\n        // 'style: {...viewStyle, ...styleoverride},' + need to fix this\r\n        // 'className: classes.join(\\' \\'),' + and this\r\n        // and otherViews as ReactNode[]\r\n        // context.mainviewid (different from context.view in decorative views)\r\n        s = s.trim();\r\n        if (propsToInjectAtRoot.length) {\r\n            let argStartIndex = s.indexOf('(', 1) + 1;//.match(/[A-Za-z_$0-9]+\\(/)\r\n            // todo: hamdle props.addstyle\r\n            // add im props: offset: this.props.isGraph ££ this.props.ode.offset, zoom: this.props.isGraph ££ this.props.ode.zoom\r\n\r\n            if (s[argStartIndex] === \"'\") argStartIndex = s.indexOf(\"'\", argStartIndex+1);// it is a lowercase component with name as string in first param\r\n            s = UX.injectPropsToString_addstuff(s, argStartIndex, propsToInjectAtRoot, 'root');\r\n\r\n            // used in GC_propsAdder as a string to be eval-ed\r\n            (window as any)._assignnodeid = function _assignnodeid(props: AllPropss, index:number): string {\r\n                const tnv = transientProperties.node[props.nodeid].viewScores[props.viewid];\r\n                if (!tnv.nodeidcounter) tnv.nodeidcounter = {};\r\n                if (tnv.nodeidcounter[index] === undefined) tnv.nodeidcounter[index] = 0;\r\n                else tnv.nodeidcounter[index]++;\r\n\r\n                return props.nodeid+'_'+index+'_'+tnv.nodeidcounter[index];\r\n                // every time before jsx render, \" let nc = transientProperties.node[props.nodeid].viewScores[props.viewid].nodeidcounter; for (let k of nc) nc[k]=0; or just nodeidcounter={}\r\n            }\r\n        }\r\n\r\n        // lowercase, no props          React.createElement('defaultNde', null, [\"a\", [a,b,c]])\r\n        // uppercase, ++ props          DefaultNde({pa: \"pa\", pb: b, pc: \"c\"}, [\"a\", [a,b,c]])\r\n        // lowercase, ++ props          React.createElement('defaultNde', {a: \"1\"}, [\"a\", [a,b,c]])\r\n        // uppercase, no props          DefaultNde(null, [\"a\", [a,b,c]])\r\n        // might have () wrapping all\r\n        // or array wrapping all\r\n        // or comments (both inline and line)\r\n        // or even a string at beginning\r\n        // nightmare case is:          `([\"a()\", /*comment()*/ React.createElement('defaultNde', {a: \"1\"}, [\"a\", [a,b,c]]),2])`\r\n        // !! fix: force users to have < as first char?? and editor tells it's wrong if this is not the case?\r\n        // that forces mono-root, but arrays would be hard to inject root-level props and prone to break anyway\r\n        let match: RegExpExecArray | null;\r\n        //here i give up, because i cannot compute nodeid without htmlindex[] from root to component\r\n        // cannot even get nodeid according to jsxstr position because of loops / map generate multiple nodes from same string index\r\n        // NO! i can do srtindex+counters[strindex]++?\r\n        //\r\n\r\n        graphComponentsProps = 'parentnodeid: props.nodeid, graphid:this.props.node.className.indexOf(\"Graph\")>=0 ? props.nodeid : props.graphid,' +\r\n            ' parentViewId:props.viewid';// + dynamically: 'nodeid, key' // - removed: htmlindex\r\n        inputComponentProps = 'data: props.data, field:\"name\"'; // + dynamically: 'key'\r\n\r\n        if (graphComponentsProps.length > 0) while (match = UX.graphComponentsRegexp.exec(s)) {\r\n            let matchstr: string = match[0];\r\n            //let pre = s.substring(0, match.index) + matchstr;\r\n            let argStartIndex = match.index + matchstr.length;\r\n            s = UX.injectPropsToString_addstuff(s, argStartIndex, graphComponentsProps, 'graphElement', UX.GC_propsAdder);\r\n        }\r\n        if (inputComponentProps.length > 0) while (match = UX.inputComponentRegexp.exec(s)) {\r\n            let matchstr: string = match[0];\r\n            //let pre = s.substring(0, match.index) + matchstr;\r\n            let argStartIndex = match.index + matchstr.length;\r\n            s = UX.injectPropsToString_addstuff(s, argStartIndex, inputComponentProps, 'inputComponent', UX.Input_propsAdder);\r\n        }\r\n        return s;\r\n    }\r\n\r\n    static parseAndInject(jsxString: string, v: DViewElement): string {\r\n        let jsxCompiled: DocString<ReactNode>;\r\n        let e: any;\r\n        try { jsxCompiled = JSXT.fromString(jsxString, {factory: 'React.createElement'}); }\r\n        catch (ee: any) { e = ee; jsxCompiled = GraphElementComponent.displayError(e, \"JSX Syntax\", v, undefined, undefined, true) as any; }\r\n        return jsxCompiled;\r\n    }\r\n    static stopEvt(e: GObject<React.SyntheticEvent>): void{\r\n        if (!e) return;\r\n        e.persist?.();\r\n        (e as any).stopImmediatePropagation?.();\r\n        e.stopPropagation?.();\r\n        let ne: any = e.nativeEvent;\r\n        e._jjIsStopped = true;\r\n        if (!ne) return;\r\n        ne.stopImmediatePropagation?.();\r\n        ne.stopPropagation?.();\r\n        if (!ne.isPropagationStopped) ne.isPropagationStopped = ()=>true;\r\n        ne._jjIsStopped = true;\r\n    }\r\n    static isStoppedEvt(e: GObject<React.SyntheticEvent>): boolean{\r\n        if (!e) return true;\r\n        if (e._jjIsStopped || e.isPropagationStopped?.()) return true;\r\n        let ne: any = e.nativeEvent;\r\n        if (!ne) return false;\r\n        return !!(ne._jjIsStopped || ne.isPropagationStopped?.());\r\n    }\r\n\r\n    static options(validTargets: MultiSelectOptGroup[]): JSX.Element[] {\r\n        return validTargets\r\n            .filter(e=>!!e)\r\n            .map(e => <optgroup label={e.label} key={e.label}>\r\n                { e.options.filter(o=>!!o).map(o=>(\r\n                    <option value={o.value} key={o.value} title={o.title}>{o.label}</option>\r\n                )) }\r\n            </optgroup>);\r\n    }\r\n    /*\r\n    does not catch: visibility: hidden, opacity:0, invisible stuff inside a overflow:scroll element, overlapping z-index (returns true)\r\n    does catch display:none, top:-999999px, width:0 (returns false)\r\n    possibly zoom can mess it up\r\n    */\r\n    static isElementInViewport(el?: Element, includePartiallyVisible: boolean = true): boolean {\r\n        if (!el) return false;\r\n        var rect = el.getBoundingClientRect(); // safely returns a 0-filled struct for non-in-dom elements\r\n        return (\r\n            rect.top + (includePartiallyVisible ? rect.height : 0) >= 0 &&\r\n            rect.left + (includePartiallyVisible ? rect.width : 0)  >= 0 &&\r\n            rect.bottom <= (window.innerHeight || document.documentElement.clientHeight) &&\r\n            rect.right <= (window.innerWidth || document.documentElement.clientWidth)\r\n        );\r\n    }\r\n    static onVisibilityChange(el: Element, callback: ()=>any):(()=>void) {\r\n        var old_visible: boolean;\r\n        return function () {\r\n            var visible = UX.isElementInViewport(el);\r\n            if (visible === old_visible) return;\r\n            old_visible = visible;\r\n            if (typeof callback == 'function') { callback(); }\r\n        }\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\model\\logicWrapper\\LModelElement.tsx",["868","869","870","871","872","873","874","875","876","877","878","879","880","881","882","883","884","885","886","887","888"],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\debugtools\\debug.tsx",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\ocl\\ocl.tsx",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\model\\dataStructure\\GraphDataElements.tsx",["889","890","891","892","893","894","895","896","897","898","899"],"// import {Mixin} from \"ts-mixer\";\r\nimport {isDeepStrictEqual} from \"util\";\r\nimport {\r\n    Constructors,\r\n    CoordinateMode,\r\n    Debug,\r\n    Dictionary,\r\n    DModelElement,\r\n    DocString,\r\n    DPointerTargetable,\r\n    DState,\r\n    DUser,\r\n    DViewElement,\r\n    EdgeBendingMode,\r\n    EPSize,\r\n    getWParams,\r\n    GObject,\r\n    GraphElementComponent,\r\n    GraphPoint,\r\n    GraphSize,\r\n    Info, IPoint, Keystrokes, L,\r\n    Leaf,\r\n    LModelElement,\r\n    Log,\r\n    LogicContext,\r\n    LPointerTargetable,\r\n    LViewElement,\r\n    MixOnlyFuncs,\r\n    Node, orArr,\r\n    Pack1,\r\n    PackArr,\r\n    Point,\r\n    Pointer,\r\n    Pointers,\r\n    PrimitiveType,\r\n    RuntimeAccessible,\r\n    RuntimeAccessibleClass,\r\n    SetFieldAction, SetRootFieldAction,\r\n    ShortAttribETypes,\r\n    Size,\r\n    store,\r\n    TargetableProxyHandler, TRANSACTION,\r\n    transientProperties,\r\n    U,\r\n    Uarr, UX,\r\n    windoww\r\n} from \"../../joiner\";\r\nimport type {Tooltip} from \"../../components/forEndUser/Tooltip\";\r\nimport type {RefObject} from \"react\";\r\nimport type {SVGPathElementt, SVGPathSegment} from '../../common/libraries/pathdata';\r\nimport {EdgeGapMode, InitialVertexSize} from \"../../joiner/types\";\r\nimport {Geom, ISize} from \"../../common/Geom\";\r\n\r\n\r\n//console.warn('ts loading graphDataElement');\r\n\r\n@Node\r\n@RuntimeAccessible('DGraphElement')\r\nexport class DGraphElement extends DPointerTargetable {\r\n    // static _super = DPointerTargetable;\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // static singleton: LGraphElement;\r\n    // static logic: typeof LGraphElement;\r\n    // static structure: typeof DGraphElement;\r\n    id!: Pointer<DGraphElement, 1, 1, LGraphElement>;\r\n    graph!: Pointer<DGraph, 1, 1, LGraph>;\r\n    model?: Pointer<DModelElement, 0, 1, LModelElement>;\r\n    isSelected!: Dictionary<DocString<Pointer<DUser>>, boolean>;\r\n    // containedIn!: Pointer<DGraphElement, 0, 1, LGraphElement>;\r\n    subElements!: Pointer<DGraphElement, 0, 'N', LGraphElement>;\r\n    state!: GObject; // DMap\r\n    father!: Pointer<DGraphElement, 1, 1, LGraphElement>;\r\n    x!: number;\r\n    y!: number;\r\n    zIndex: number = 100;\r\n    w!: number;\r\n    h!: number;\r\n    // width: number = 300;\r\n    // height: number = 400;\r\n    view!: Pointer<DViewElement, 1, 1, LViewElement>;\r\n    favoriteNode!: boolean;\r\n    edgesIn!: Pointer<DEdge>[];\r\n    edgesOut!: Pointer<DEdge>[];\r\n    anchors!: Dictionary<string, GraphPoint/* as % of node size.*/>;\r\n\r\n\r\n    public static new(htmlindex: number, model: DGraphElement[\"model\"]|null|undefined, parentNodeID: DGraphElement[\"father\"],\r\n                      graphID: DGraphElement[\"graph\"], nodeID?: DGraphElement[\"id\"]|undefined, a?: any, b?:any, ...c:any): DGraphElement {\r\n        return new Constructors(new DGraphElement('dwc'), parentNodeID, true, undefined, nodeID)\r\n            .DPointerTargetable()\r\n            .DGraphElement(model, graphID, htmlindex).end();\r\n    }\r\n\r\n    static nodeLFromHtml(target?: Element | null): LGraphElement | undefined { return LPointerTargetable.fromPointer(DGraphElement.nodePtrFromHtml(target) as Pointer); }\r\n    static nodeDFromHtml(target?: Element | null): DGraphElement | undefined { return DPointerTargetable.fromPointer(DGraphElement.nodePtrFromHtml(target) as Pointer); }\r\n    static nodePtrFromHtml(target?: Element | null): Pointer<DGraphElement> | undefined {\r\n        while (target) {\r\n            if ((target.attributes as any).nodeid) return (target.attributes as any).nodeid.value;\r\n            target = target.parentElement;\r\n        }\r\n        return undefined;\r\n    }\r\n    static graphLFromHtml(target?: Element | null): LGraph | undefined { return LPointerTargetable.fromPointer(DGraphElement.graphPtrFromHtml(target) as Pointer); }\r\n    static graphDFromHtml(target?: Element | null): DGraph | undefined { return DPointerTargetable.fromPointer(DGraphElement.graphPtrFromHtml(target) as Pointer); }\r\n    static graphPtrFromHtml(target?: Element | null): Pointer<DGraph> | undefined {\r\n        while (target) {\r\n            if ((target.attributes as any).graphid) return (target.attributes as any).graphid.value;\r\n            target = target.parentElement;\r\n        }\r\n        return undefined;\r\n    }\r\n}\r\n@RuntimeAccessible('LGraphElement')\r\nexport class LGraphElement<Context extends LogicContext<DGraphElement> = any, C extends Context = Context> extends LPointerTargetable {\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static getNodeId<L extends LGraphElement, D extends DGraphElement>(o?:L | D | Pointer<D> | LModelElement | DModelElement | Pointer<DModelElement>): Pointer<D> {\r\n        if (!o) return undefined as any;\r\n        let node: any = o;\r\n        // from L to D\r\n        // let cname = (node.__raw || node).className;\r\n        // from DModelE to LGraphE\r\n        if (RuntimeAccessibleClass.extends((o as any).className, \"DModelElement\")) node = LPointerTargetable.from(o as DModelElement).node as LGraphElement;\r\n        return (typeof node === \"string\") ? node : node?.id;\r\n    }\r\n    // static singleton: LGraphElement;\r\n    // static logic: typeof LGraphElement;\r\n    // static structure: typeof DGraphElement;\r\n    __raw!: DGraphElement;\r\n    id!: Pointer<DGraphElement, 1, 1, LGraphElement>;\r\n    father!: LGraphElement;\r\n    model?: LModelElement;\r\n    // protected isSelected!: Dictionary<DocString<Pointer<DUser>>, boolean>; //  & ((forUser?: Pointer<DUser>) => boolean);\r\n\r\n    // containedIn?: LGraphElement;\r\n    _state!: GObject<\"proxified\">; // LMap;\r\n    x!: number;\r\n    y!: number;\r\n    width!: number;\r\n    height!: number\r\n\r\n    z!:number;\r\n    zIndex!: number;\r\n    __info_of__z__: Info = {type:ShortAttribETypes.EInt, txt: \"alias for zIndex\"};\r\n    __info_of__zIndex__: Info = {type:ShortAttribETypes.EInt,\r\n        txt: \"Determine the z-axis priority of the element.<br/>Higher value tende to overlap other elements.<br/>Lower value tends to be on background.\"};\r\n    zoom!: GraphPoint;\r\n    html?: Element;\r\n    __info_of__html: Info = {type: 'HTMLElement', txt:'The DOM element generated by this node.'}\r\n    text?: string;\r\n    __info_of__text: Info = {type: 'string', txt: 'the text extracted from the output html, excluding the tags'}\r\n\r\n    // fittizi\r\n    w!:number;\r\n    h!:number;\r\n    size!: GraphSize;\r\n    position!: GraphPoint;\r\n    htmlSize!: Size; // size and position in global document coordinates.\r\n    htmlPosition!: Point;\r\n    view!: LViewElement;\r\n    component!: GraphElementComponent;\r\n    favoriteNode!: boolean;\r\n    vertex?: LVoidVertex;\r\n    __info_of__vertex: Info = {type: \"LVoidVertex\", txt: \"the foremost vertex containing this graphElement, or undefiened.\"}\r\n    __info_of__favoriteNode: Info = {type: ShortAttribETypes.EBoolean,\r\n        txt: \"<span>Indicates this is the primarly used (by default) node to refer to a modelling element that might have multiple representations.\" +\r\n            \"<br> Can be used as favorite target for edges or other.\"}\r\n\r\n    startPoint!: GraphPoint;\r\n    endPoint!: GraphPoint;\r\n    __info_of__startPoint: Info = {type: \"GraphPoint\", txt:<span>Where the outgoing edges should start their paths.\r\n            <br/>Obtained by combining anchoring point offset specified in view, before snapping to a Vertex border.\r\n            <br/>Defaults in outer coordinates.</span>};\r\n    __info_of__endPoint: Info = {type: \"GraphPoint\", txt:<span>Where the incoming edges should end their paths.\r\n            <br/>Obtained by combining anchoring point offset specified in view, before snapping to a Vertex border.\r\n            <br/>Defaults in outer coordinates.</span>};\r\n\r\n    graph!: LGraph | LGraphVertex;\r\n    __info_of__graph: Info = {type:\"LGraph | LGraphVertex\", txt:\"Alias for innerGraph\"};\r\n    get_graph(context: Context): LGraph | LGraphVertex { return this.get_innerGraph(context); }\r\n    innerGraph!: LGraph|LGraphVertex;\r\n    __info_of__innnerGraph: Info = {type:\"LGraph | LGraphVertex\", txt:\"Gets the nearest-level graph (it might be a Sub-graph like a package usually is)\"};\r\n    outerGraph!: LGraph;\r\n    __info_of__outerGraphGraph: Info = {type:\"LGraph\", txt:\"Gets the root-level graph\"};\r\n    root!: LGraph;\r\n\r\n    __info_of__root: Info = {type:\"LGraph\", txt:\"Alias for outerGraph\"};\r\n    get_root(context: Context): LGraph { return this.get_outerGraph(context); }\r\n\r\n    rendered!: boolean;\r\n    __info_of__rendered: Info = {type: 'boolean', txt:'If the node is currently displayed somewhere in the graph.'}\r\n    get_rendered(c: Context): this[\"rendered\"] { return !!this.get_html(c);}\r\n    visible!: boolean;\r\n    __info_of__visible: Info = {type: 'boolean', txt:'If the node is currently visible on the user screen.'}\r\n    get_visible(c: Context): this[\"visible\"] { return UX.isElementInViewport(this.get_html(c)); }\r\n    firstRenderedNode!: LGraphElement;\r\n    __info_of__firstRenderedNode:Info={type: 'LGraphElement', txt: \"The first currently rendered node in the collection: [this.node, this.father.node, this.father.father.node , ...]\"};\r\n    protected get_firstRenderedNode(c: Context): this[\"firstRenderedNode\"] {\r\n        let arr = [c.proxyObject];\r\n        return U.findInChildProperties(arr, (e)=>[e.father], undefined, (e)=>e.rendered);\r\n    }\r\n    name!:string;\r\n    public get_name(c: Context): string{ return c.data.model && this.get_model(c)?.name || (c.data as any).name || c.data.className; }\r\n    /*firstRenderedNodes!: LGraphElement;\r\n    __info_of__firstRenderedNodes:Info={type: 'LGraphElement', txt: \"The first currently rendered node in the collection: [this.nodes, this.father.nodes, this.father.father.nodes , ...]\"};\r\n    protected get_firstRenderedNodes(c: Context): this[\"firstRenderedNodes\"] {\r\n        let arr = this.get_nodes(c);\r\n        // return U.findInChildProperties(arr, (e)=>e.model.father.nodes, undefined, (e)=>e.rendered);\r\n        return U.findInChildProperties(arr, (e)=>[e.father], undefined, (e)=>e.rendered);\r\n    }*/\r\n\r\n\r\n    __info_of__graphAncestors: Info = {type:\"LGraph[]\",\r\n        txt:\"<span>collection of the stack of Graphs containing the current element where [0] is the most nested graph, and last is root graph.</span>\"};\r\n    graphAncestors!: LGraph[];\r\n\r\n    anchors!: Dictionary<string, GraphPoint/* as % of node size.*/>;\r\n    __info_of__anchors: Info = {type:\"Dictionary<string, point>\", txt: <div>A named list of all anchor points where edges are allowed to land or depart from.<br/>\r\n            {/*When reading it is in absolute sizes.<br/>*/}\r\n            When writing it must be done in percentages, with the same rules as node.state.</div>}\r\n    get_anchors(c: Context): this[\"anchors\"]{ return c.data.anchors; }\r\n    set_anchors(v: this[\"anchors\"], c: Context):boolean{\r\n        if (v !== undefined && (typeof v !== \"object\" || Array.isArray(v))){\r\n            Log.ee('cannot set anchors: invalid value provided');\r\n            return true;\r\n        }\r\n        if (v){ // if !v it means clear all anchors?\r\n            for (let ka in v){//for each anchor\r\n                if (!v[ka]) continue;\r\n\r\n                if (c.data.anchors[ka]) {\r\n                    for (let kk in v[ka]) { //for each key within an anchor (x, y, w, h)\r\n                        // if i was attempting to set a partial size, complete it with the old size values.\r\n                        if ((v[ka][kk] === undefined) && (c.data.anchors[ka][kk] !== undefined)) v[ka][kk] = c.data.anchors[ka][kk];\r\n                    }\r\n                }\r\n                if (v[ka].x === undefined || isNaN(v[ka].x)) v[ka].x = 0.5;\r\n                if (v[ka].y === undefined || isNaN(v[ka].y)) v[ka].y = 0.5;\r\n                // if (v[ka].w === undefined || isNaN(v[ka].w)) v[ka].w = 5;\r\n                // if (v[ka].h === undefined || isNaN(v[ka].h)) v[ka].h = 5;\r\n            }\r\n        }\r\n        TRANSACTION(this.get_name(c)+'.anchors', ()=> {\r\n            SetFieldAction.new(c.data, \"anchors\", v, '', false)\r\n        });\r\n        return true; }\r\n\r\n    edgesIn!: LVoidEdge[];\r\n    edgesOut!: LVoidEdge[];\r\n    __info_of__edgesIn: Info = {type:\"LEdge[]\", txt:<div>Edges incoming into this element. <code>this.edgesOut[i].end</code> always equals to <code>this</code>.</div>}\r\n    __info_of__edgesOut: Info = {type:\"LEdge[]\", txt:<div>Edges outgoing from this element. <code>this.edgesIn[i].start</code> always equals to <code>this</code>.</div>}\r\n    __info_of__edgesStart: Info = {type:\"LEdge[]\", txt:<div>Alias for this.edgesOut</div>}\r\n    __info_of__edgesEnd: Info = {type:\"LEdge[]\", txt:<div>Alias for this.edgesIn</div>}\r\n    public get_edgesIn(context: Context): this[\"edgesIn\"] { return LPointerTargetable.fromArr(context.data.edgesIn); }\r\n    public get_edgesOut(context: Context): this[\"edgesOut\"]  { return LPointerTargetable.fromArr(context.data.edgesOut); }\r\n    public set_edgesIn(val: PackArr<LVoidEdge>, c: Context): boolean {\r\n        TRANSACTION(this.get_name(c)+'edgesIn', ()=> {\r\n            SetFieldAction.new(c.data.id, \"edgesIn\", Pointers.fromArr(val), '', true);\r\n        })\r\n        return true;\r\n\r\n    }\r\n    public set_edgesOut(val: PackArr<LVoidEdge>, c: Context): boolean {\r\n        TRANSACTION(this.get_name(c)+'.edgesOut', ()=> {\r\n            SetFieldAction.new(c.data.id, \"edgesOut\", Pointers.fromArr(val), '', true);\r\n        })\r\n        return true;\r\n    }\r\n    public get_edgesStart(context: Context): this[\"edgesIn\"]  { return this.get_edgesIn(context); }\r\n    public get_edgesEnd(context: Context): this[\"edgesOut\"]  { return this.get_edgesOut(context); }\r\n    public set_edgesStart(val: PackArr<LVoidEdge>, context: Context): boolean { return this.set_edgesIn(val, context); }\r\n    public set_edgesEnd(val: PackArr<LVoidEdge>, context: Context): boolean { return this.set_edgesOut(val, context); }\r\n\r\n\r\n    protected _defaultGetter(c: Context, k: keyof Context[\"data\"]): any {\r\n        if (k in c.data) return this.__defaultGetter(c, k);\r\n        // if value not found in node, check in view.\r\n        return (this.get_view(c) as any)[k];\r\n        /*let ret: any;\r\n        let view = this.get_view(c);\r\n        try { ret = (view as any)[k] } catch (e) { Log.ee(\"Could not find get_ property \\\"\" + k + \"\\\" in node or view.\", {c, view, k}); return undefined; }\r\n        return ret;*/\r\n    }\r\n\r\n    protected _defaultSetter(v: any, c: Context, k: keyof Context[\"data\"]): true {\r\n        this.__defaultSetter(v, c, k);\r\n        return true;\r\n    }\r\n\r\n    get_graphAncestors(c: Context): LGraph[] {\r\n        let current = c.proxyObject;\r\n        let next = current.father;\r\n        let ret: LGraph[] = [];\r\n        while(next) {\r\n            if (RuntimeAccessibleClass.extends(next.className, DGraph.cname)) ret.push(next as LGraph);\r\n            if (current.id === next.id) break;\r\n            current = next;\r\n            next = next.father;\r\n        }\r\n        return ret;\r\n    }\r\n    get_outerGraph(context: Context): LGraph {\r\n        // todo: this relies on the fact that GraphVertex are not passing their own id to their childrens, but the parent graph id\r\n        return TargetableProxyHandler.wrap(context.data.graph);\r\n    }\r\n    get_vertex(context: Context): this[\"vertex\"] {\r\n        let lcurrent: LGraphElement = LPointerTargetable.fromPointer(context.data.id);\r\n        let dcurrent = lcurrent.__raw;\r\n        // iterate parents.\r\n        while(dcurrent){\r\n            switch(dcurrent.className){\r\n                case DVertex.cname:\r\n                case DVoidVertex.cname:\r\n                case DGraphVertex.cname: return (lcurrent || LPointerTargetable.fromD(dcurrent)) as LVoidVertex;\r\n                default:\r\n                    if (!dcurrent.father || dcurrent.id === dcurrent.father) return undefined;\r\n                    Log.exDev(!dcurrent.father || dcurrent.id === dcurrent.father, \"node failed to get containing vertex\", context.data, dcurrent, lcurrent);\r\n                    lcurrent = LPointerTargetable.fromPointer(dcurrent.father);\r\n                    dcurrent = lcurrent.__raw;\r\n            }\r\n        }\r\n        return undefined;\r\n    }\r\n\r\n    get_innerGraph(context: Context): LGraph {\r\n        let dcurrent = DPointerTargetable.fromPointer(context.data.father);\r\n\r\n        // if no parent, but it's a graph, return itself.\r\n        if (!dcurrent) {\r\n            dcurrent = context.data;\r\n            switch(dcurrent.className){\r\n                case DGraph.cname:\r\n                case DGraphVertex.cname: return (LPointerTargetable.fromD(dcurrent)) as LGraph;\r\n                default: return Log.exDevv(\"root node failed to get containing graph\", {cdata:context.data, dcurrent});\r\n            }\r\n        }\r\n\r\n        // if it have a parent, iterate parents.\r\n        while(true){\r\n            switch(dcurrent?.className){\r\n                case DGraph.cname:\r\n                case DGraphVertex.cname: return (LPointerTargetable.fromD(dcurrent)) as LGraph;\r\n                default:\r\n                    Log.exDev(!dcurrent.father, \"node failed to get containing graph\", {cdata:context.data, dcurrent});\r\n                    Log.exDev(dcurrent.id === dcurrent.father, \"node failed to get containing graph, found loop\",\r\n                        {cdata:context.data, dcurrent, father: LPointerTargetable.from(dcurrent)?.father});\r\n                    dcurrent = DPointerTargetable.fromPointer(dcurrent.father);\r\n            }\r\n        }\r\n    }\r\n\r\n    // set_x(val: this[\"x\"], context: Context): boolean { SetFieldAction.new(context.data.id, \"x\", val, undefined, false); return true; }\r\n    // get_x(context: Context): this[\"x\"] { return context.data.x; }\r\n    get_x(context: Context): this[\"x\"] { return this.get_size(context).x; }\r\n    set_x(val: this[\"x\"], context: Context): boolean { return this.set_size({x:val}, context); }\r\n    get_y(context: Context): this[\"y\"] { return this.get_size(context).y; }\r\n    set_y(val: this[\"y\"], context: Context): boolean { return this.set_size({y:val}, context); }\r\n\r\n    get_w(context: Context): this[\"w\"] { return this.get_size(context).w; }\r\n    set_w(val: this[\"w\"], context: Context): boolean { return this.set_size({w:val}, context); }\r\n    get_h(context: Context): this[\"h\"] { return this.get_size(context).h; }\r\n    set_h(val: this[\"h\"], context: Context): boolean { return this.set_size({h:val}, context); }\r\n\r\n    get_width(context: Context): this[\"w\"] { return this.get_w(context); }\r\n    set_width(val: this[\"w\"], context: Context): boolean { return this.set_w(val, context); }\r\n    get_height(context: Context): this[\"h\"] { return this.get_h(context); }\r\n    set_height(val: this[\"h\"], context: Context): boolean { return this.set_h(val, context); }\r\n\r\n    get_position(context: Context): this[\"position\"] { return new GraphPoint(context.data.x, context.data.y); }\r\n    set_position(val: this[\"position\"], c: Context): boolean {\r\n        TRANSACTION('drag' + this.get_name(c), ()=>{\r\n            SetFieldAction.new(c.data.id, \"x\", val.x, undefined, false);\r\n            SetFieldAction.new(c.data.id, \"y\", val.y, undefined, false);\r\n        }, IPoint.printDiff(c.data, val))\r\n        return true; }\r\n\r\n    get_sizeold(context: Context): this[\"size\"] { return new GraphSize(context.data.x, context.data.y, context.data.w, context.data.h); }\r\n    get_component(context: Context): this[\"component\"] {\r\n        // switch(context.data.className) { case DEdgePoint.name: return GraphElementComponent.map[context.data.father]; }\r\n        return GraphElementComponent.map[context.data.id]; }\r\n    // get_view(context: Context): this[\"view\"] { return this.get_component(context).props.view; }\r\n    get_view(context: Context): this[\"view\"] {\r\n        return transientProperties.node[context.data.id]?.mainView?.r || LPointerTargetable.fromPointer(context.data.view) || this.get_component(context)?.props.view?.r;\r\n    }\r\n    set_view(val: Pack1<this[\"view\"]>, context: Context){\r\n        Log.eDevv(\"node.view is readonly, change it through props or the model\");\r\n        // let ptr: DGraphElement[\"view\"] = Pointers.from(val as this[\"view\"]);\r\n        // return SetFieldAction.new(context.data.id, \"view\", ptr, '', true);\r\n    }\r\n\r\n    outerSize!: LGraphElement[\"size\"];\r\n    __info_of__outerSize: Info = {type:\"GraphSize\", txt:\"the size of the current element relative to the first (root) graph level.\"};\r\n    innerSize!: LGraphElement[\"size\"];\r\n    __info_of__innerSize: Info = {type:\"GraphSize\", txt:\"the size of the current element relative to the last (most nested) graph level.\"};\r\n    __info_of__size: Info = {type:\"GraphSize\", txt: \"same as innerSize.\"};\r\n\r\n\r\n    getSize(outer: boolean = false, canTriggerSet: boolean = true): Readonly<GraphSize> { return this.wrongAccessMessage(\"getSize()\"); }\r\n    get_getSize(c: Context): ((outer?: boolean, canTriggerSet?: boolean) => Readonly<GraphSize>) {\r\n        return (outer: boolean = true, canTriggerSet: boolean = true) => this.get_innerSize(c, canTriggerSet, outer); }\r\n\r\n    get_outerSize(context: Context, canTriggerSet: boolean = true): Readonly<GraphSize> {\r\n        return this.get_innerSize(context, canTriggerSet, true);\r\n    }\r\n    get_size(context: Context, canTriggerSet: boolean = true): Readonly<GraphSize> { return this.get_innerSize(context, canTriggerSet, false); }\r\n    get_innerSize(context: Context, canTriggerSet: boolean = true, outerSize: boolean = false): Readonly<GraphSize> {\r\n        let r = this.get_innerSize_impl(context, canTriggerSet, outerSize);\r\n        return new GraphSize(r.x, r.y, r.w, r.h);\r\n    }\r\n    protected get_innerSize_impl(context: Context, canTriggerSet: boolean = true, outerSize: boolean = false): Readonly<GraphSize> {\r\n        canTriggerSet = canTriggerSet && !Debug.lightMode;\r\n        let cname = context.data.className;\r\n        // cname = DGraphElement.cname;\r\n        switch (cname){\r\n            default: return Log.exDevv(\"unexpected classname in get_size switch: \" + context.data.className);\r\n            case DEdge.cname:\r\n            case DVoidEdge.cname:\r\n            case DGraph.cname: return nosize as any;\r\n            // case DField.cname:\r\n            case DGraphElement.cname:\r\n                let graph = outerSize ? this.get_outerGraph(context) : this.get_innerGraph(context);\r\n                return graph.coord(this.get_htmlSize(context));\r\n            case DVoidVertex.cname:\r\n            case DVertex.cname:\r\n            case DEdgePoint.cname:\r\n            case DGraphVertex.cname: break;\r\n        }\r\n\r\n        // low prio todo: memoization in proxy, as long state does not change keep a collection Dictionary[object][key] = returnval. it gets emptied when state is updated.\r\n\r\n        // when loading a save, edge segements and edgepoints/nodes are computed before creating the edgepoint component\r\n        let view: LViewElement = this.get_view(context);\r\n        // (window as any).retry = ()=>view.getSize(context.data.id);\r\n        let ret: EPSize = view.getSize(context.data.id) as any; // (this.props.dataid || this.props.nodeid as string)\r\n\r\n        if (!ret) {\r\n            ret = new GraphSize() as EPSize;\r\n            ret.x = context.data.x;\r\n            ret.y = context.data.y;\r\n            ret.w = context.data.w;\r\n            ret.h = context.data.h;\r\n            let def: GraphSize | undefined;\r\n            if (undefined===(ret.x)) { if (!def) def = view.defaultVSize; ret.x = def.x || 0;}\r\n            if (undefined===(ret.y)) { if (!def) def = view.defaultVSize; ret.y = def.y || 0;}\r\n            if (undefined===(ret.w)) { if (!def) def = view.defaultVSize; ret.w = def.w || 10;}\r\n            if (undefined===(ret.h)) { if (!def) def = view.defaultVSize; ret.h = def.h | 10;}\r\n            ret.currentCoordType = (context.data as DEdgePoint).currentCoordType as any;\r\n        }\r\n        if (context.data.className === DEdgePoint.cname) {\r\n            ret = (this as any as LEdgePoint).decodePosCoords(context, ret, view);\r\n        }\r\n\r\n        /*\r\n                if ((context.data as DVoidVertex).isResized) {\r\n                    return ret;\r\n                }*/\r\n        if (!canTriggerSet) {\r\n            if (outerSize) ret = this.get_outerGraph(context).translateSize(ret, this.get_innerGraph(context));\r\n            return ret;\r\n        }\r\n        let html: HTMLElement | undefined | null = this.get_component(context)?.html?.current;\r\n        let actualSize: Partial<Size> & {w:number, h:number} = html ? Size.of(html) : {w:0, h:0};\r\n        let isOldElement = (context.data.clonedCounter as number) > 3;\r\n        // if w = 0 i don't auto-set it as in first render it has w:0 because is not reredered and not resized.\r\n        // console.log(\"getSize() cantriggerset html size\", {ret: ret ? {...ret} : ret, html, actualSize, hcc:html?.dataset?.clonedcounter, ncc: context.data.clonedCounter});\r\n        if (!html || +(html.dataset.clonedcounter as string) !== context.data.clonedCounter) canTriggerSet = false;\r\n        let updateSize: boolean = false;\r\n        if (view.adaptWidth && ret.w !== actualSize.w) {\r\n            if (canTriggerSet && (isOldElement || actualSize.w !== 0)) {\r\n                ret.w = actualSize.w;\r\n                updateSize = true;\r\n            }\r\n        }\r\n        if (view.adaptHeight && ret.h !== actualSize.h) {\r\n            if (canTriggerSet && (isOldElement || actualSize.h !== 0)) {\r\n                ret.h = actualSize.h;\r\n                updateSize = true;\r\n            }\r\n        }\r\n        // console.log(\"getSize() from node merged with actualSize\", {ret: {...ret}});\r\n\r\n        if (updateSize) this.set_size(ret, context);\r\n        if (outerSize) ret = this.get_outerGraph(context).translateSize(ret, this.get_innerGraph(context));\r\n        return ret;\r\n    }\r\n    // set_size(size: Partial<this[\"size\"]>, context: Context): boolean {\r\n    set_size(size0: Partial<GraphSize>, c: Context): boolean {\r\n        // console.log(\"setSize(\"+(this.props?.data as any).name+\") thisss\", this);\r\n        if (!size0) return false;\r\n        let size = size0 as Partial<EPSize>;\r\n        let view = this.get_view(c);\r\n        let testmode: boolean = false;\r\n        if (c.data.className === DEdgePoint.cname && size.currentCoordType !== CoordinateMode.absolute) size = (this as any as LEdgePoint).encodePosCoords(c as any, size, view);\r\n\r\n        if (view.updateSize(c.data.id, size)) return true;\r\n\r\n        TRANSACTION('resize '+this.get_name(c), ()=>{\r\n            if (size.x !== c.data.x && size.x !== undefined) SetFieldAction.new(c.data.id, \"x\", size.x, undefined, false);\r\n            if (size.y !== c.data.y && size.y !== undefined) SetFieldAction.new(c.data.id, \"y\", size.y, undefined, false);\r\n            if (size.w !== c.data.w && size.w !== undefined) SetFieldAction.new(c.data.id, \"w\", size.w, undefined, false);\r\n            if (size.h !== c.data.h && size.h !== undefined) SetFieldAction.new(c.data.id, \"h\", size.h, undefined, false);\r\n            let epdata: DEdgePoint = c.data as DEdgePoint;\r\n            if (size.currentCoordType !== epdata.currentCoordType && size.currentCoordType !== undefined) SetFieldAction.new(epdata.id, \"currentCoordType\", size.currentCoordType, undefined, false);\r\n        }, undefined, ISize.printDiff(c.data, size))\r\n        return true; }\r\n\r\n    get_text(c: Context): this['text'] {\r\n        // Performance: innerText triggers reflow which might be intensive. consider using .textContent\r\n        // https://developer.mozilla.org/en-US/docs/Web/API/Node/textContent\r\n        return (this.get_html(c) as HTMLElement)?.innerText;\r\n    }\r\n    get_html(c: Context): this[\"html\"] {\r\n        let component = this.get_component(c);\r\n        let html = component?.html.current;\r\n        if (html) return html;\r\n        html = document.getElementById(c.data.id);//$('[nodeid=\"' + c.data.id + '\"]')[0];\r\n        if (!html) return undefined;\r\n        if (component) (component.html as any).current = html;\r\n        return html;\r\n    }\r\n    set_html(val: this[\"html\"], context: Context): boolean { return this.cannotSet(\"set_html(). html is generated through jsx. edit the view instead.\"); }\r\n    set_text(val: this[\"text\"], context: Context): boolean { return this.cannotSet(\"set_text(). text is generated through jsx. edit the view instead.\"); }\r\n\r\n    get_htmlSize(context: Context): this[\"htmlSize\"] {\r\n        let html = this.get_html(context);\r\n        return html ? Size.of(html) : new Size(0, 0, 0, 0);\r\n        /*\r\n        let graph = this.get_graph(context);\r\n        if (!html) return nosize as any;\r\n        let size = Size.of(html);\r\n        let zoom = graph.zoom;\r\n        size.x /= zoom.x;\r\n        size.y /= zoom.y;\r\n        return size;*/}\r\n    set_htmlSize(val: this[\"htmlSize\"], context: Context): boolean {\r\n        // might be useful for fixed display size/location elements that stay in place even if you move tab or change zoom. debatable if needed\r\n        this.cannotSet(\"set_htmlSize(): todo extra low priority. set GraphSize through set_size instead.\");\r\n        return true; }\r\n    get_htmlPosition(context: Context): this[\"htmlPosition\"] { return this.get_htmlSize(context).tl(); }\r\n    set_htmlPosition(val: this[\"htmlPosition\"], context: Context): boolean {\r\n        // might be useful for fixed display size/location elements that stay in place even if you move tab or change zoom. debatable if needed\r\n        this.cannotSet(\"set_htmlPosition(): todo extra low priority. set graph position through set_position instead.\");\r\n        return true; }\r\n\r\n\r\n    /* how z-index work, it's really messy.\r\n    * cannot move html position. node id depends on it, and a node moving position would need to change id.\r\n    * so i use css order.\r\n    * first order is assigned through node constructor called by parent component injectProps, according to his last index in html.\r\n    * now z-index is set in node and updated properly.\r\n    * z-index is passed to a prop, rendered as html attribute.\r\n    * css takes the attribute value and uses it in \"order\" css rule.\r\n    * problem: updating node.z doesn't trigger the parent injectprops, so he inject html index and\r\n    * the outernmost html root cannot update his attribute without refreshing the parent and recalling injectprops\r\n    * fixed: by updating it directly in GraphElement.render()\r\n    * */\r\n    get_zIndex(context: Context): this[\"zIndex\"] { return (+context.data.zIndex || 0); }\r\n    set_zIndex(val: this[\"zIndex\"], c: Context): boolean {\r\n        val = +val ?? 0;\r\n        if (val === c.data.zIndex) return true;\r\n        TRANSACTION(this.get_name(c)+'.zIndex', ()=> {\r\n            SetFieldAction.new(c.data.id, \"zIndex\", val, undefined, false);\r\n        }, c.data.zIndex, val)\r\n        return true; }\r\n    get_z(context: Context): this[\"zIndex\"] { return context.data.zIndex; }\r\n    set_z(val: this[\"zIndex\"], context: Context): boolean { return this.set_zIndex(val, context); }\r\n    /*\r\n        get_containedIn(context: Context): this[\"containedIn\"] {\r\n            return context.data.containedIn ? LPointerTargetable.fromPointer(context.data.containedIn) : undefined; }\r\n        set_containedIn(val: Pack1<this[\"containedIn\"]>, context: LogicContext<DGraphElement>): boolean {\r\n            let ptr: DGraphElement[\"containedIn\"] = Pointers.from(val) as any;\r\n            SetFieldAction.new(context.data, 'containedIn', ptr, undefined, true);\r\n            if (ptr) SetFieldAction.new(ptr as any, 'subElements+=', context.data.id);\r\n            return true; }*/\r\n\r\n    nodes!:LVoidVertex[];\r\n    __info_of__nodes:Info = {type:'LVertex[]', txt: \"all direct sub-nodes. not including deep subelements (subelements of subelements)\"};\r\n    get_nodes(c: Context): this['nodes'] { return this.get_subElements(c).filter(c => c && c.className.indexOf('Vertex') >= 0) as any; }\r\n    set_nodes(val: never, c: Context): boolean { return this.cannotSet('nodes'); }\r\n    edges!:LVoidVertex[];\r\n    __info_of__edges:Info = {type:'LEdge[]', txt: \"all direct sub-edges. not including deep subelements (subelements of subelements)\"};\r\n    get_edges(c: Context): this['edges'] { return this.get_subElements(c).filter(c => c && c.className.indexOf('Edge') >= 0) as any; }\r\n    set_edges(val: never, c: Context): boolean { return this.cannotSet('edges'); }\r\n    graphs!:LVoidVertex[];\r\n    __info_of__graphs:Info = {type:'LGraph[]', txt: \"all direct sub-graphs. not including deep subelements (subelements of subelements)\"};\r\n    get_graphs(c: Context): this['graphs'] { return this.get_subElements(c).filter(c => c && c.className.indexOf('Graph') >= 0) as any; }\r\n    set_graphs(val: never, c: Context): boolean { return this.cannotSet('graphs'); }\r\n\r\n    allSubNodes!: LVoidVertex[];\r\n    __info_of__allSubNodes:Info = {type:'LVertex[]', txt: \"all deep sub-nodes. including subelements of subelements.\"};\r\n    get_allSubNodes(c: Context): this['allSubNodes'] { return this.get_allSubElements(c).filter(c => c && c.className.indexOf('Vertex') >= 0) as any; }\r\n    set_allSubNodes(val: never, c: Context): boolean { return this.cannotSet('allSubNodes'); }\r\n    allSubEdges!: LVoidEdge[];\r\n    __info_of__allSubEdges:Info = {type:'LEdge[]', txt: \"all deep sub-edges. including subelements of subelements.\"};\r\n    get_allSubEdges(c: Context): this['allSubEdges'] { return this.get_allSubElements(c).filter(c => c && c.className.indexOf('Edge') >= 0) as any; }\r\n    set_allSubEdges(val: never, c: Context): boolean { return this.cannotSet('allSubEdges'); }\r\n    allSubGraphs!: (LGraph | LGraphVertex)[];\r\n    __info_of__allSubGraphs:Info = {type:'LGraph[]', txt: \"all deep sub-graphs. including subelements of subelements.\"};\r\n    get_allSubGraphs(c: Context): this['allSubGraphs'] { return this.get_allSubElements(c).filter(c => c && c.className.indexOf('Graph') >= 0) as any; }\r\n    set_allSubGraphs(val: never, c: Context): boolean { return this.cannotSet('allSubGraphs'); }\r\n\r\n    subElements!: LGraphElement[]; // shallow, direct subelements\r\n    __info_of__subElements: Info = {type: 'LGraphElement[]',\r\n        txt: \"all direct subelements (nodes, edges, edgepoints, subgraphs...). not including deep subelements (subelements of subelements)\"}\r\n    get_subElements(context: Context): this[\"subElements\"] {\r\n        return LPointerTargetable.fromArr([...new Set(context.data.subElements)]).filter((e:L)=>!!e);\r\n    }\r\n    set_subElements(val: PackArr<this[\"subElements\"]>, context: LogicContext<DGraphElement>): boolean {\r\n        if (true as boolean) return this.cannotSet('subElements', 'set .father properties from subelements instead.');\r\n        /*\r\n         this code updates the parent of removed subelements, but it risks to go in conflict if subelem.father is in a pending action\r\n                so i choose to handle this safely from set_father instead, and never use set_subElements directly;\r\n        */\r\n        console.log(\"isDeepStrictEqual\", {isDeepStrictEqual});\r\n        Log.eDev([...new Set(val)].length !== val.length, \"subelemnts setter have duplicates\", {val, context});\r\n        // if (isDeepStrictEqual(context.data.subElements, val)) return true;\r\n        let pointers: Pointer<DGraphElement, 0, 'N', LGraphElement> = Pointers.from(val) || [];\r\n        if (Uarr.equals(pointers, context.data.subElements, false)) return true;\r\n\r\n        TRANSACTION(this.get_name(context as any)+'.subElements', ()=> {\r\n            SetFieldAction.new(context.data, 'subElements', pointers, '', true);\r\n            const idlookup = store.getState().idlookup;\r\n            let arrdiff = U.arrayDifference(context.data.subElements, pointers);\r\n            // old subelements\r\n            for (let oldsubelementid of arrdiff.removed) {\r\n                /*\r\n                let subelement: DGraphElement = (oldsubelementid && DPointerTargetable.fromPointer(oldsubelementid)) as DGraphElement;\r\n                if (!subelement || subelement.father !== context.data.id) continue;\r\n                let lsubelement = LPointerTargetable.fromD(subelement);\r\n                lsubelement.father = this.get_graph(context)?.id as any;*/\r\n            }\r\n            // new subelements\r\n            for (let newsubelementid of arrdiff.added) {\r\n                let subelement: DGraphElement = (newsubelementid && idlookup[newsubelementid]) as DGraphElement;\r\n                if (subelement.father === context.data.id) continue;\r\n                LPointerTargetable.from(subelement).father = context.data.id as any; // trigger side-action\r\n            }\r\n        })\r\n        return true;\r\n    }\r\n\r\n    allSubElements!: LGraphElement[]; // deep, nested subelements\r\n    __info_of__allSubElements: Info = {type: 'LGraphElement[]',\r\n        txt: \"all deep subelements (nodes, edges, edgepoints, subgraphs...). including subelements of subelements.\"}\r\n    private get_allSubElements(context: Context, state?: DState): this[\"allSubElements\"] {\r\n        // return context.data.packages.map(p => LPointerTargetable.from(p));\r\n        state = state || store.getState();\r\n        let tocheck: Pointer<DGraphElement>[] = context.data.subElements || [];\r\n        let checked: Dictionary<Pointer, true> = {};\r\n        let dblcheck: Dictionary<Pointer, Pointer> = {}; // <child, parent>  // debug only\r\n        for (let e of tocheck) dblcheck[e] = context.data.id; // debug only\r\n        checked[context.data.id] = true;//nb6[]{}&\r\n        while (tocheck.length) {\r\n            let newtocheck: Pointer<DGraphElement>[] = [];\r\n            for (let ptr of tocheck) {\r\n                Log.eDev(checked[ptr], \"loop in GraphElements containing themselves\", {\r\n                    dblcheck,\r\n                    context,\r\n                    ptr,\r\n                    checked,\r\n                    fistContainer: dblcheck[ptr]\r\n                });\r\n                if (checked[ptr]) continue;\r\n                checked[ptr] = true;\r\n                let subnode: DGraphElement = DPointerTargetable.from(ptr, state);\r\n                let se = subnode?.subElements;\r\n                //for (let e of se) dblcheck[e] = ptr; // debug only\r\n                U.arrayMergeInPlace(newtocheck, se);\r\n            }\r\n            tocheck = newtocheck;\r\n        }\r\n        delete checked[context.data.id];\r\n        return LPointerTargetable.from(Object.keys(checked), state);\r\n    }\r\n\r\n    set_allSubElements(val: never, c: Context): boolean {\r\n        return this.cannotSet('allSubElements');\r\n    }\r\n\r\n    get_isResized(context: LogicContext<DVoidVertex>): DVoidVertex[\"isResized\"] { return (context.data as DVertex).isResized; }\r\n    set_isResized(val: DVoidVertex[\"isResized\"], c: LogicContext<DVoidVertex>): DVoidVertex[\"isResized\"] {\r\n        val = !!val;\r\n        if (!!c.data.isResized === val) return true;\r\n        TRANSACTION(this.get_name(c as any as Context)+'.isResized', ()=> {\r\n            SetFieldAction.new(c.data.id, \"isResized\", val);\r\n        }, c.data.isResized, val)\r\n        return true;\r\n    }\r\n\r\n    get_model(context: Context): this[\"model\"] {\r\n        const modelElementId = context.data.model; //$('[id=\"' + context.data.id + '\"]')[0].dataset.dataid;\r\n        const lModelElement: LModelElement = LPointerTargetable.from(modelElementId as string);\r\n        return lModelElement;\r\n    }\r\n\r\n    assignEdgeAnchor!: ((anchorName?: string)=>void);\r\n    __info_of__assignEdgeAnchor!: {hidden:true, type:\"(anchorName?: string)=>void\", txt: \"Assign a specific anchor of this node to the edge currently following the cursor, if any.\"};\r\n    get_assignEdgeAnchor(c: Context): ((anchorName?: string)=>void) {\r\n        return (anchorName?: string)=>{\r\n            if (anchorName && !c.data.anchors[anchorName]) anchorName = undefined;\r\n            if (LVoidEdge.startFollow) {\r\n                let de: DEdge = DPointerTargetable.fromPointer(LVoidEdge.startFollow);\r\n                if (de.start !== c.data.id) return; // cannot change edge targets, only an anchor within the current targets\r\n                let le: LVoidEdge = LPointerTargetable.fromD(de);\r\n                le.anchorStart = anchorName;\r\n                le.startFollow = false;\r\n\r\n            }\r\n            if (LVoidEdge.endFollow) {\r\n                let de = DPointerTargetable.fromPointer(LVoidEdge.endFollow);\r\n                if (de.end !== c.data.id) return; // cannot change edge targets, only an anchor within the current targets\r\n                let le = LPointerTargetable.fromD(de);\r\n                le.anchorEnd = anchorName;\r\n                le.endFollow = false;\r\n            }\r\n        }\r\n    }\r\n    get_events(c: Context): LViewElement[\"events\"] {\r\n        const tn = transientProperties.node[c.data.id];\r\n        let mainview: DViewElement = tn.mainView.__raw;\r\n        let otherViews: DViewElement[] = tn.stackViews.map(v=>v.__raw);\r\n        let allviews: DViewElement[] = [mainview, ...otherViews].reverse();\r\n        const keep_for_closure_original_funcs: LViewElement[\"events\"] = {};\r\n        const ret: LViewElement[\"events\"] = {};\r\n        for (let dv of allviews) U.objectMergeInPlace(keep_for_closure_original_funcs, transientProperties.view[dv.id].events);\r\n\r\n        const lastContext: GObject = tn.viewScores[mainview.id].evalContext;\r\n        const keys = Object.keys(keep_for_closure_original_funcs);\r\n        // for (let k of keys) ret['_raw_'+k] = keep_for_closure_original_funcs[k];\r\n        for (let k of keys) {\r\n            if (!keep_for_closure_original_funcs[k]) continue;\r\n            ret[k] = (..._params: any) => keep_for_closure_original_funcs[k](lastContext, ..._params);\r\n        }\r\n\r\n        return ret; }\r\n\r\n\r\n    get_father(context: Context): this[\"father\"] { return LPointerTargetable.fromPointer(context.data.father); }\r\n    set_father(val: Pack1<this[\"father\"]>, c: Context): boolean {\r\n        let ptr: DGraphElement[\"father\"] = Pointers.from(val) as any;\r\n        TRANSACTION(this.get_name(c)+'.father', ()=> {\r\n            SetFieldAction.new(c.data, 'father', ptr, undefined, true);\r\n            if (ptr) SetFieldAction.new(ptr as any, 'subElements+=', c.data.id);\r\n        }, this.get_father(c).name, L.fromPointer(ptr).name)\r\n        return true; }\r\n\r\n    __info_of__isselected: Info = {type: \"Dictionary<Pointer<User>, true>\",\r\n        txt:<div>A map that contains all the users selecting this element as keys, and always true as a value (if present).\r\n            <br/>Edit it through node.select() and node.deselect()</div>}\r\n    __info_of__select: Info = {type:\"function(forUser?:Pointer<User>):void\", txt:\"Marks this node as selected by argument user.\"};\r\n    __info_of__deselect: Info = {type:\"function(forUser?:Pointer<User>):void\", txt:\"Un-marks this node as selected by argument user.\"};\r\n    __info_of__toggleSelect: Info = {type:\"function(usr?:Pointer<User>):void\", txt:\"Calls this.select(usr) if the node is selected by argument user, this.deselect(usr) otherwise. If omitted, argument \\\"usr\\\" is the current user id.<br>Returns the result of this.isSelected() after the toggle.\"};\r\n    __info_of__isSelected: Info = {type:\"function(forUser?:Pointer<User>):void\", txt:\"Tells if this node is selected by argument user.\"};\r\n    select(forUser?: Pointer<DUser>): void { return this.wrongAccessMessage(\"node.select()\"); }\r\n    deselect(forUser?: Pointer<DUser>): void { return this.wrongAccessMessage(\"node.deselect()\"); }\r\n    toggleSelected(forUser?: Pointer<DUser>): void { return this.wrongAccessMessage(\"node.toggleSelected()\"); }\r\n    isSelected(forUser?: Pointer<DUser>): boolean { return this.wrongAccessMessage(\"node.isSelected()\"); }\r\n    get_select(c: Context): (forUser?: Pointer<DUser>)=>void {\r\n        return (forUser?: Pointer<DUser>)=>{\r\n            if (!forUser) forUser = DUser.current;\r\n            Log.exDev(typeof forUser !== 'string', 'unexpected parameter in select()', {forUser});\r\n            if (c.data.isSelected[forUser]) return; // no-op\r\n            let map = {...c.data.isSelected};\r\n            map[forUser] = true;\r\n            let duser = DPointerTargetable.fromPointer(forUser);\r\n            TRANSACTION(this.get_name(c)+'.select('+ duser.name+')', ()=>{\r\n                SetFieldAction.new(c.data.id, \"isSelected\", map, undefined, false);\r\n            }, false, true)\r\n            // todo: actually they are pointer to users, but i'm assuming users are not erased at runtime. on deselect too\r\n        }\r\n    }\r\n    get_deselect(c: Context): (forUser?: Pointer<DUser>)=>void {\r\n        return (forUser?: Pointer<DUser>)=>{\r\n            if (!forUser) forUser = DUser.current;\r\n            Log.exDev(typeof forUser !== 'string', 'unexpected parameter in deselect()', {forUser});\r\n            if (!c.data.isSelected[forUser]) return; // no-op\r\n            let map = {...c.data.isSelected};\r\n            delete map[forUser];\r\n            let duser = DPointerTargetable.fromPointer(forUser);\r\n\r\n            TRANSACTION(this.get_name(c)+'.select('+ duser.name+')', ()=>{\r\n                // todo: actually they are pointer to users, but i'm assuming users are not erased at runtime. on deselect too\r\n                SetFieldAction.new(c.data.id, \"isSelected\", map, undefined, false);\r\n            })\r\n        }\r\n    }\r\n    get_toggleSelected(context: Context): ((forUser?: Pointer<DUser>) => boolean) {\r\n        return (forUser?: Pointer<DUser>): boolean => {\r\n            if (!forUser) forUser = DUser.current;\r\n            if (this.get_isSelected(context)(forUser)) {\r\n                this.get_deselect(context)(forUser);\r\n                return false;\r\n            } else {\r\n                this.get_select(context)(forUser);\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    get_isSelected(context: Context): ((forUser?: Pointer<DUser>) => boolean) {\r\n        return (forUser?: Pointer<DUser>): boolean => {\r\n            if (!forUser) forUser = DUser.current;\r\n            return !!context.data.isSelected[forUser];\r\n        }\r\n    }\r\n    set_isSelected(val: this[\"isSelected\"], context: Context): boolean {\r\n        return this.cannotSet(\"graphElement.isSelected(): use this.select() or this.deselect() instead.\");\r\n    }\r\n    /*\r\n    get_isSelected(context: LogicContext<DVoidVertex>): GObject {\r\n        return DPointerTargetable.mapWrap(context.data.isSelected, context.data, 'idlookup.' + context.data.id + '.isSelected', []);\r\n    }*/\r\n\r\n\r\n\r\n    // for edges\r\n    public get_startPoint(c: Context|undefined, size?: GraphSize, view?: LViewElement): GraphPoint { return this.get_startEndPoint(c, size, view, true); }\r\n    public get_endPoint(c: Context|undefined, size?: GraphSize, view?: LViewElement): GraphPoint { return this.get_startEndPoint(c, size, view, false); }\r\n    private get_startEndPoint(c: Context|undefined, size?: GraphSize, view?: LViewElement, isStart:boolean=true): GraphPoint {\r\n        if (!size) {\r\n            if (c) size = this.get_size(c) as any; else size = Log.exDevv(\"invalid arguments in get_startEndPoint\", {arguments});\r\n        }\r\n        if (!view) {\r\n            // if (c) view = this.get_view(c); else view = Log.exDevv(\"invalid arguments in get_startPoint\", {arguments});\r\n            view = c && this.get_view(c) || Log.exDevv(\"invalid arguments in get_startEndPoint\", {arguments});\r\n        }\r\n        let offset: GraphPoint = (view as LViewElement)[isStart ? \"edgeStartOffset\" : \"edgeEndOffset\"];\r\n        let isPercentage: boolean = (view as LViewElement)[isStart ? \"edgeStartOffset_isPercentage\" : \"edgeEndOffset_isPercentage\"];\r\n        if (!size) size = new GraphSize(0, 0, 0, 0);\r\n        if (isPercentage) offset = new GraphPoint(offset.x/100*(size.w), offset.y/100*(size.h));\r\n        return size.tl().add(offset, false);\r\n    }\r\n\r\n}\r\nRuntimeAccessibleClass.set_extend(DPointerTargetable, DGraphElement);\r\nRuntimeAccessibleClass.set_extend(LPointerTargetable, LGraphElement)\r\n\r\n\r\n@RuntimeAccessible('DGraph')\r\nexport class DGraph extends DGraphElement {\r\n    // static _super = DGraphElement;\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // static singleton: LGraph;\r\n    // static logic: typeof LGraph;\r\n    // static structure: typeof DGraph;\r\n\r\n    // inherit redefine\r\n    father!: Pointer<DGraphElement, 1, 1, LGraphElement>;\r\n    id!: Pointer<DGraph, 1, 1, LGraph>;\r\n    graph!: Pointer<DGraph, 1, 1, LGraph>;\r\n    model!: Pointer<DModelElement, 1, 1, LModelElement>;\r\n    isSelected!: Dictionary<DocString<Pointer<DUser>>, boolean>;\r\n    // containedIn!: Pointer<DGraphElement, 0, 1, LGraphElement>;\r\n\r\n    state!: GObject;\r\n    // personal attributes\r\n    zoom!: GraphPoint;\r\n    offset!: GraphSize; // in-graph scrolling offset\r\n\r\n    public static new(htmlindex: number, model: DGraph[\"model\"],\r\n                      parentNodeID?: DGraphElement[\"father\"], // immediate parent\r\n                      parentgraphID?: DGraphElement[\"graph\"], // graph containing this subgraph (redudant? could get it from father chain)\r\n                      nodeID?: DGraphElement[\"id\"] // this id\r\n    ): DGraph {\r\n        return new Constructors(new DGraph('dwc'), parentNodeID, true, undefined, nodeID || Constructors.DGraph_makeID(model))\r\n            .DPointerTargetable()\r\n            .DGraphElement(model, parentgraphID, htmlindex).DGraph().end();\r\n    }\r\n\r\n\r\n    static getNodes(dmp: import(\"../logicWrapper/LModelElement\").DModelElement[], out: {$matched: JQuery<HTMLElement>; $notMatched: JQuery<HTMLElement>; }): JQuery<HTMLElement> {\r\n        let $allnodes = $('[data-dataid]');\r\n        let matchedids: Pointer[] = (dmp || []).map(d => d.id);\r\n        let matchedidmap:Dictionary<string, boolean> = U.objectFromArrayValues(matchedids);\r\n        if (!out) out = {} as any;\r\n\r\n        let allnodesarr = [...$allnodes];\r\n        let filternode = (d: HTMLElement) => {\r\n            if (!d?.dataset?.dataid) return false;\r\n            let id: string = ''+d?.dataset?.dataid;\r\n            return matchedidmap[id]; };\r\n        out.$matched = $(allnodesarr.filter(filternode));\r\n        out.$notMatched = $(allnodesarr.filter((n) => !filternode(n)));\r\n        return out.$matched;\r\n        // throw new Error(\"Method not implemented.\");\r\n    }\r\n\r\n}\r\nvar nosize: GraphSize = {x:0, y:0, w:0, h:0, nosize:true} as any;\r\nvar defaultEdgePointSize: GraphSize = undefined as any; // = {x:0, y:0, w:5, h:5};\r\nvar defaultVertexSize: GraphSize = undefined as any; // {x:0, y:0, w:140.6818084716797, h:32.52840805053711};\r\n\r\n\r\n@RuntimeAccessible('LGraph')\r\nexport class LGraph<Context extends LogicContext<DGraph> = any, D extends DGraph = any> extends LGraphElement {\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // static singleton: LGraph;\r\n    // static logic: typeof LGraph;\r\n    // static structure: typeof DGraph;\r\n\r\n    // inherit redefine\r\n    __raw!: DGraph;\r\n    id!: Pointer<DGraph, 1, 1, LGraph>;\r\n    graph!: LGraph;\r\n    model?: LModelElement;\r\n    // isSelected: Dictionary<DocString<Pointer<DUser>>, boolean> = {};\r\n    isSelected(forUser?: Pointer<DUser>): boolean { return this.wrongAccessMessage(\"node.isSelected()\"); }\r\n    // containedIn?: LGraphElement;\r\n    subElements!: LGraphElement[];\r\n    _state!: GObject<\"proxified\">; // LMap;\r\n    // personal attributes\r\n    zoom!: GraphPoint;\r\n    graphSize!: GraphSize; // derived attribute: bounding rect containing all subnodes, while \"size\" is instead external size of the vertex holding the graph in GraphVertexes\r\n    offset!: GraphSize; // Scrolling position inside the graph\r\n\r\n    // get_graphSize(context: LogicContext<DGraph>):  Readonly<GraphSize> { return todo: get bounding rect containing all subnodes.; }\r\n    get_offset(context: LogicContext<DGraph>):  Readonly<GraphSize> {\r\n        let offset: Partial<GraphSize> = (context.data.offset || new GraphSize()) as any;\r\n        return new GraphSize(offset.x, offset.y, offset.w, offset.h);\r\n    }\r\n    set_offset(val: Partial<GraphSize>, context: Context): boolean {\r\n        if (!val) val = {x:0, y:0, w:0, h:0};\r\n        //if (val.x === undefined && val.y === undefined && val.w === undefined && val.h === undefined) return true;\r\n        let offset: Partial<GraphSize> = (context.data.offset || new GraphSize()) as any\r\n        if (val.x === undefined && offset.x !== val.x) val.x = offset.x;\r\n        if (val.y === undefined && offset.y !== val.y) val.y = offset.y;\r\n        if (val.w === undefined && offset.w !== val.w) val.w = offset.w;\r\n        if (val.h === undefined && offset.h !== val.h) val.h = offset.h;\r\n        if (offset.x === val.x && offset.y === val.y && offset.w === val.w && offset.h == val.h) return true;\r\n\r\n        TRANSACTION(this.get_name(context)+'.offset', ()=>{\r\n            SetFieldAction.new(context.data, \"offset\", val as any);\r\n        }, IPoint.stringify(offset), IPoint.stringify(val))\r\n        return true;\r\n    }\r\n\r\n    public cumulativeZoom!: GraphPoint;\r\n    public __info_of__cumulativeZoom: Info = {type: GraphPoint.cname, txt: \"the product of all the ownZoom of containing ancestor graphs.\"};\r\n    private get_cumulativeZoom(c:Context): this['cumulativeZoom']{\r\n        let ancestors = [c.proxyObject, ...this.get_graphAncestors(c)];\r\n        let zoom: GraphPoint = new GraphPoint(1,1);\r\n        for (let g of ancestors) zoom.multiply(g.ownZoom, false);\r\n        return zoom;\r\n    }\r\n\r\n    get_zoom(c: Context): GraphPoint {\r\n        return this.get_cumulativeZoom(c);\r\n    }\r\n    public ownZoom!: GraphPoint;\r\n    __info_of__ownZoom: Info = {type:GraphPoint.cname, label:\"zoom\", txt:\"The individual zoom applied to this graph.\"};\r\n    __info_of__zoom: Info = {type:GraphPoint.cname, label:\"zoom\", txt:\"Scales the graph and all subelements by a factor.\"};\r\n    get_ownZoom(context: Context): GraphPoint {\r\n        const zoom: GraphPoint = context.data.zoom;\r\n        let ret = new GraphPoint(zoom.x||1, zoom.y||1); // NB: do not use (??1), zero is not a valid value for zoom.\r\n        // (zoom as any).debug = {rawgraph: context.data.__raw, zoomx: context.data.zoom.x, zoomy: context.data.zoom.y}\r\n        return ret; }\r\n    set_zoom(val: Partial<GraphPoint>, c: Context): boolean{\r\n        if (!val) val = {x:1, y:1};\r\n        //if (val.x === undefined && val.y === undefined) return true;\r\n        let zoom: Partial<GraphSize> = (c.data.zoom || new GraphSize()) as any;\r\n        if (!val.x) val.x = zoom.x; // remember zero is not allowed value\r\n        if (!val.y) val.y = zoom.y;\r\n        if (zoom.x === val.x && zoom.y === val.y) return true;\r\n\r\n        TRANSACTION(this.get_name(c)+'.zoom', ()=>{\r\n            SetFieldAction.new(c.data, 'zoom', val as any, '+=', false);\r\n        }, IPoint.stringify(zoom), IPoint.stringify(val))\r\n        return true;\r\n    }\r\n\r\n    toGraphSize(...a:Parameters<this[\"coord\"]>): ReturnType<this[\"coord\"]>{ return this.wrongAccessMessage(\"toGraphSize\"); }\r\n    coord(htmlSize: Size): GraphSize { return this.wrongAccessMessage(\"toGraphSize\"); }\r\n    get_coord(context: Context): (htmlSize: Size) => GraphSize {\r\n        return (htmlSize: Size)=> {\r\n            let graphHtmlSize: Size = this.get_htmlSize(context);\r\n            let zoom: GraphPoint = this.get_zoom(context);\r\n            return new GraphSize(\r\n                (htmlSize.x - graphHtmlSize.x) / zoom.x,\r\n                (htmlSize.y - graphHtmlSize.y) / zoom.y,\r\n                htmlSize.w/zoom.x,\r\n                htmlSize.h/zoom.y);\r\n        }\r\n    }\r\n    // get_htmlSize(context: Context): Size { }\r\n    translateSize<T extends GraphSize|GraphPoint>(ret: T, innerGraph: LGraph): T { return this.wrongAccessMessage(\"translateSize()\"); }\r\n    translateHtmlSize<T extends Size|Point, G = T extends Size ? GraphSize : GraphPoint>(size: T): G { return this.wrongAccessMessage(\"translateHtmlSize()\"); }\r\n\r\n    __info_of__offset: Info = {type:GraphPoint.cname, label:\"offset\", txt:\"In-graph scrolling position.\"};\r\n    __info_of__graphSize: Info = {type:GraphSize.cname, label:\"graphSize\", txt:\"size internal to the graph, including internal scroll and panning.\"};\r\n    __info_of__translateSize: Info = {type:\"(T, Graph)=>T where T is GraphSize | GraphPoint\", txt:\"Translates a coordinate set from the local coordinates of a SubGraph to this Graph containing it.\"};\r\n    __info_of__translateHtmlSize: Info = {type:\"(Size|Point) => GraphSize|GraphPoint\", txt:'Translate page\\'s viewport coordinate set to this graph coordinate set.'};\r\n    get_translateHtmlSize<T extends Size|Point, G = T extends Size ? GraphSize : GraphPoint>(c: Context): ((size: T) => G) {\r\n        return (size: T): G => {\r\n            let rootGraph: LGraph = this.get_root(c);\r\n            if (rootGraph.id === c.data.id) return this.get_translateHtmlSize_fromRoot<T, G>(c)(size);\r\n            let fakeRootSize = rootGraph.translateHtmlSize_fromRoot<T, G>(size) as any as ISize;\r\n            let screenOffset = this.get_screenOffset(c);//cumulative (g.size.tl()-offset.tl()*cumulativezoom)\r\n\r\n            // distance from the origin of the subgraph in rendered pixels\r\n            let ret = new GraphSize(fakeRootSize.x - screenOffset.x, fakeRootSize.y - screenOffset.y, fakeRootSize.w, fakeRootSize.h);\r\n            return ret.divide(this.get_cumulativeZoom(c) as any, false) as any;\r\n\r\n            /*\r\n            // fake because it assumes all subgraphs have the same zoom level of current graph.\r\n            let ancestors = this.get_graphAncestors(c).reverse().slice(1);\r\n            let cumulativeZoom: GraphPoint = new GraphPoint(1, 1); // = this.get_ownZoom(c);\r\n            for (let g of ancestors){\r\n                let offset = g.offset;\r\n                let ownZoom = g.ownZoom;\r\n                cumulativeZoom.multiply(ownZoom);\r\n                // let a, b, c be graphs\r\n                // size is =  a.zoom + a.offset\r\n\r\n            }\r\n            */\r\n        }\r\n    }\r\n    screenOffset!: GraphPoint;\r\n    __info_of__screenOffset: Info = {type: GraphPoint.cname, txt:\"Distance of the subgraph origin in rendered pixels. to the top-left of graph container.\"}\r\n    private get_screenOffset(c: Context): GraphPoint{\r\n        let ancestors = [c.proxyObject, ...this.get_graphAncestors(c)].reverse();\r\n        let ret = new GraphPoint(0, 0);\r\n        let cumulativeZoom: GraphPoint = new GraphPoint(1, 1); // = this.get_ownZoom(c);\r\n        for (let g of ancestors){\r\n            let offset = g.offset;\r\n            let ownZoom = g.ownZoom;\r\n            let size = g.size;\r\n            ret\r\n                .add(size.tl().multiply(cumulativeZoom, false), false)\r\n                .subtract(offset, false);\r\n            cumulativeZoom.multiply(ownZoom);\r\n            ret\r\n                .multiply(cumulativeZoom, false);\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    private translateHtmlSize_fromRoot<T extends Size|Point, G = T extends Size ? GraphSize : GraphPoint>(size: T):G {\r\n        return this.wrongAccessMessage('translateHtmlSize_fromRoot');\r\n    }\r\n\r\n    /**\r\n     *  IMPORTANT!\r\n     *  this is a wrong partial result, do not call this function directly outside translateHtmlSize.\r\n     *  this is outercoord without zoom, needs ti be translated to container graph coords & de-apply zoom\r\n     */\r\n    private get_translateHtmlSize_fromRoot<T extends Size|Point, G = T extends Size ? GraphSize : GraphPoint>(c: Context): ((size: T) => G) {\r\n        return (size: T): G => {\r\n            let graphHtmlSize = this.get_htmlSize(c);\r\n            let a = size.subtract(graphHtmlSize.tl(), true);\r\n            let offset = {x:c.data.offset.x, y:c.data.offset.y};\r\n            let b = a.subtract(offset, true);\r\n            let r = b.divide(c.data.zoom as any, false) as any as G;\r\n            return r;\r\n        }\r\n    }\r\n\r\n    // graph_of_size, the size parameter have coordinates based on this graph.\r\n    get_translateSize<T extends GraphSize|GraphPoint>(c: Context): ((size: T, graph_of_size: LGraph) => T) {\r\n        return (size: T, graph_of_size: LGraph): T => {\r\n            let targetGraph: LGraph = c.proxyObject;\r\n            let currGraph: LGraph = graph_of_size;\r\n            if (currGraph.id === c.data.id) return size;\r\n            let currAncestors: LGraph[] = [currGraph, ...currGraph.graphAncestors];\r\n            let targetAncestors: LGraph[] = [targetGraph, ...targetGraph.graphAncestors];\r\n            let currAncestorsPtr: Pointer<DGraph>[] = currAncestors.map(l=>l.id).reverse();\r\n            let targetAncestorsPtr: Pointer<DGraph>[] = targetAncestors.map(l=>l.id).reverse();\r\n            Log.ex(targetAncestorsPtr[0] !== currAncestorsPtr[0],\r\n                'translateSize() The root graph of 2 elements should always be the same, are you comparing nodes from different graphs?',\r\n                {currGraph, targetGraph});\r\n            let i: number = 1;\r\n            while (currAncestorsPtr[i] === targetAncestorsPtr[i]) { i++; }\r\n            let commonAncestor: Pointer<DGraph> = targetAncestorsPtr[i-1];\r\n            currAncestors = currAncestors.slice(0, currAncestors.length - i).filter(e=>!!e);\r\n            targetAncestors = targetAncestors.slice(0, currAncestors.length - i).filter(e=>!!e);\r\n            // d, c, b, a           currAncestors\r\n            // d, c, x, y           targetAncestors\r\n            // undo a,b, redo x,y        i = [2]\r\n\r\n            Log.exDev(!currAncestors.length && !targetAncestors.length, \"translateSize() found invalid intersection in container graphs\",\r\n                {currGraph, targetGraph, currAncestors, targetAncestors});\r\n            // @ts-ignore\r\n            let ret: T = 'w' in size ? new GraphSize(size.x, size.y, size.w, size.h) : new GraphPoint(size.x, size.y, size.w, size.h);\r\n            console.log(\"translateSizee pre\", (this.get_model(c) as any).name, size.x, size.y, {size, ret, currAncestors, targetAncestors} )\r\n            for (let g of currAncestors){\r\n                ret.subtract(g.offset, false);\r\n                ret.divide(g.cumulativeZoom, false);\r\n                ret.add(g.size.tl(), false);\r\n            }\r\n            for (let g of targetAncestors){\r\n                ret.subtract(g.size.tl(), false);\r\n                ret.multiply(g.cumulativeZoom, false);\r\n                ret.add(g.offset, false);\r\n            }\r\n            console.log(\"translateSizee ret\", (this.get_model(c) as any).name, size.x, size.y, {size, ret, currAncestors, targetAncestors} )\r\n\r\n            return ret; }\r\n        //todo: check how many passes you need to go down or up, and make the up version too\r\n\r\n    }\r\n    get_translateSize_down_old<T extends GraphSize|GraphPoint>(c: Context): ((size: T, innerGraph: LGraph) => T) {\r\n        return (size: T, graph_of_size: LGraph): T => {\r\n            graph_of_size = LPointerTargetable.wrap(graph_of_size) as LGraph;\r\n            let ret: T = (size.hasOwnProperty(\"w\") ? new GraphSize(size.x, size.y, (size as GraphSize).w, (size as GraphSize).h) : new GraphPoint(size.x, size.y)) as T;\r\n            Log.ex(!graph_of_size, \"translateSize() graph parameter is invalid: \"+graph_of_size, graph_of_size, c);\r\n            let ancestors: LGraph[] = [graph_of_size, ...graph_of_size.graphAncestors];\r\n            console.log(\"translateSize\", {innerGraph: graph_of_size, ret, ancestors, c});\r\n            Log.ex(ancestors.indexOf(c.proxyObject) !== -1, \"translateSize() graph parameter is invalid: it must be a graph containing the current one.\", graph_of_size, c);\r\n            for (let g of ancestors) ret.add(g.size.tl(), false);\r\n            // for (let g of ancestors) ret.subtract(g.offset, false);\r\n            // console.log(\"translateSize\", {c, thiss:c.proxyObject, ancestors, ancestorSizes: ancestors.map(a=> a.size.tl()), size, ret});\r\n            return ret; }\r\n    }\r\n    contains(elem: LGraphElement): boolean{ return this.wrongAccessMessage(\"contains()\"); }\r\n    get_contains(c: Context): ((elem: LGraphElement)=> boolean) {\r\n        return (elem: LGraphElement): boolean => {\r\n            let current = elem;\r\n            let next = elem.father;\r\n            let targetid = c.proxyObject.id;\r\n            if (current.id !== targetid) return true;\r\n            while(next && current.id !== next.id) {\r\n                current = next;\r\n                next = next.father;\r\n                if (current.id !== targetid) return true;\r\n            }\r\n            return false;\r\n        }}\r\n}\r\nRuntimeAccessibleClass.set_extend(DGraphElement, DGraph);\r\nRuntimeAccessibleClass.set_extend(LGraphElement, LGraph);\r\n// export const defaultVSize: GraphSize = new GraphSize(0, 0, 300, 160); // useless, now it's in view.DefaultVSize\r\n// export const defaultEPSize: GraphSize = new GraphSize(0, 0, 15, 15); // useless, now it's in view.DefaultVSize\r\n\r\n\r\n@RuntimeAccessible('DVoidVertex')\r\nexport class DVoidVertex extends DGraphElement {\r\n    // static _super = DGraphElement;\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // static singleton: LVoidVertex;\r\n    // static logic: typeof LVoidVertex;\r\n    // static structure: typeof DVoidVertex;\r\n\r\n    // inherit redefine\r\n    id!: Pointer<DVoidVertex, 1, 1, LVoidVertex>;\r\n    graph!: Pointer<DGraph, 1, 1, LGraph>;\r\n    model!: Pointer<DModelElement, 0, 1, LModelElement>;\r\n    isSelected!: Dictionary<DocString<Pointer<DUser>>, boolean>;\r\n    // containedIn!: Pointer<DGraphElement, 0, 1, LGraphElement>;\r\n    subElements!: Pointer<DGraphElement, 0, 'N', LGraphElement>;\r\n    state!: GObject;\r\n    zoom!: GraphPoint;\r\n    // personal attributes\r\n    x!: number;\r\n    y!: number;\r\n    w!: number;\r\n    h!: number;\r\n    isResized!: boolean;\r\n    // size?: GraphSize; // virtual, gets extracted from this. x and y are stored directly here as it extends GraphSize\r\n\r\n    public static new(htmlindex: number, model: DGraphElement[\"model\"], parentNodeID: DGraphElement[\"father\"], graphID: DGraphElement[\"graph\"], nodeID?: DGraphElement[\"id\"],\r\n                      size?: InitialVertexSize): DVoidVertex {\r\n        return new Constructors(new DVoidVertex('dwc'), parentNodeID, true, undefined, nodeID)\r\n            .DPointerTargetable()\r\n            .DGraphElement(model, graphID, htmlindex)\r\n            .DVoidVertex(size || defaultVertexSize).end();\r\n    }\r\n\r\n}\r\n\r\n@RuntimeAccessible('LVoidVertex')\r\nexport class LVoidVertex<Context extends LogicContext<DVoidVertex> = any, C extends Context = Context> extends LGraphElement {// <D extends DVoidVertex = any>\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // static singleton: LVoidVertex;\r\n    // static logic: typeof LVoidVertex;\r\n    // static structure: typeof DVoidVertex;\r\n\r\n    // inherit redefine\r\n    __raw!: DVoidVertex;\r\n    id!: Pointer<DVoidVertex, 1, 1, LVoidVertex>;\r\n    graph!: LGraph;\r\n    model?: LModelElement;\r\n    // isSelected: Dictionary<DocString<Pointer<DUser>>, boolean> = {};\r\n    isSelected(forUser?: Pointer<DUser>): boolean { return this.wrongAccessMessage(\"node.isSelected()\"); }\r\n    // containedIn?: LGraphElement;\r\n    subElements!: LGraphElement[];\r\n    _state!: GObject<\"proxified\">; // LMap;\r\n    zoom!: GraphPoint;\r\n    isResized!: boolean;\r\n\r\n    // personal attributes\r\n    x!: number;\r\n    y!: number;\r\n    w!: number;\r\n    h!: number;\r\n    size!: GraphSize; // virtual, gets extracted from this. x and y are stored directly here as it extends GraphSize\r\n    __info_of__size = {type: \"?GraphSize\", txt: \"Size of the vertex, if null it means is utilizing the defaultSize from view. recommended to read component.getSize() instead of this.\"};\r\n\r\n    get_isResized(context: LogicContext<DVoidVertex>): DVoidVertex[\"isResized\"] { return context.data.isResized; }\r\n    set_isResized(val: DVoidVertex[\"isResized\"], context: LogicContext<DVoidVertex>): DVoidVertex[\"isResized\"] {\r\n        val = !!val;\r\n        if (!!context.data.isResized === val) return true;\r\n        TRANSACTION(this.get_name(context)+'.isResized', ()=>{\r\n            SetFieldAction.new(context.data.id, \"isResized\", val);\r\n        }, context.data.isResized, val)\r\n        return true;\r\n    }\r\n\r\n\r\n\r\n}\r\n\r\nRuntimeAccessibleClass.set_extend(DGraphElement, DVoidVertex);\r\nRuntimeAccessibleClass.set_extend(LGraphElement, LVoidVertex);\r\n@RuntimeAccessible('DEdgePoint')\r\nexport class DEdgePoint extends DVoidVertex { // DVoidVertex\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // static singleton: LEdgePoint;\r\n    // static logic: typeof LEdgePoint;\r\n    // static structure: typeof DEdgePoint;\r\n\r\n    // inherit redefine\r\n    id!: Pointer<DEdgePoint, 1, 1, LEdgePoint>;\r\n    father!: Pointer<DVoidEdge, 1, 1, LVoidEdge>;\r\n    graph!: Pointer<DGraph, 1, 1, LGraph>;\r\n    model!: Pointer<DModelElement, 0, 1, LModelElement>; // todo: if null gets model from this.father (edge)?\r\n    isSelected!: Dictionary<DocString<Pointer<DUser>>, boolean>;\r\n    // containedIn!: Pointer<DGraphElement, 0, 1, LGraphElement>;\r\n    subElements!: Pointer<DGraphElement, 0, 'N', LGraphElement>;\r\n    zoom!: GraphPoint;\r\n    x!: number;\r\n    y!: number;\r\n    w!: number;\r\n    h!: number;\r\n    size?: GraphSize; //／／ virtual, gets extracted from this. x and y are stored directly here as it extends GraphSize\r\n    // personal attributes\r\n    __isDEdgePoint!: true;\r\n    currentCoordType?: CoordinateMode;\r\n\r\n    public static new(htmlindex: number, model: DEdgePoint[\"model\"] | undefined, parentNodeID: DEdgePoint[\"father\"], graphID?: DEdgePoint[\"graph\"], nodeID?: DGraphElement[\"id\"],\r\n                      size?: InitialVertexSize): DEdgePoint {\r\n        return new Constructors(new DEdgePoint('dwc'), parentNodeID, true, undefined, nodeID)\r\n            .DGraphElement(undefined, graphID, htmlindex)\r\n            .DVoidVertex(size || defaultEdgePointSize).DEdgePoint().end();\r\n    }\r\n\r\n}\r\n\r\n@RuntimeAccessible('LEdgePoint')\r\nexport class LEdgePoint<Context extends LogicContext<DEdgePoint> = any, C extends Context = Context> extends LVoidVertex {\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // static singleton: LEdgePoint;\r\n    // static logic: typeof LEdgePoint;\r\n    // static structure: typeof DEdgePoint;\r\n\r\n    // inherit redefine\r\n    father!: LVoidEdge;\r\n    // __raw!: DEdgePoint;\r\n    id!: Pointer<DEdgePoint, 1, 1, LEdgePoint>;\r\n    graph!: LGraph;\r\n    model?: LModelElement;\r\n    // isSelected: Dictionary<DocString<Pointer<DUser>>, boolean> = {};\r\n    isSelected(forUser?: Pointer<DUser>): boolean { return this.wrongAccessMessage(\"node.isSelected()\"); }\r\n    // containedIn?: LGraphElement;\r\n    subElements!: LGraphElement[];\r\n    zoom!: GraphPoint;\r\n    x!: number;\r\n    y!: number;\r\n    w!: number;\r\n    h!: number;\r\n    size!: GraphSize; // virtual, gets extracted from this. x and y are stored directly here as it extends GraphSize\r\n    // personal attributes\r\n    __isLEdgePoint!: true;\r\n    edge!: LVoidEdge; // returns container edge\r\n    __info_of__edge: Info = {type:\"?LEdge\", txt:\"returns the containing edge if called on an EdgePoint, \\\"this\\\" if called on an edge, undefined otherwise.\"}\r\n\r\n    public get_edge(c: Context): LVoidEdge { return c.proxyObject.father; }\r\n    public set_edge(v: Pack1<LVoidEdge>, c: Context): boolean { return this.set_father(v as any, c); }\r\n\r\n\r\n\r\n\r\n    static decodeCoords<T extends Partial<EPSize>>(size0: T, sp:GraphPoint, ep: GraphPoint): T/*absolute*/{\r\n        let size: any = size0;\r\n        let ret: any = ((\"w\" in size || \"h\" in size) ? new GraphSize() : new GraphPoint()); // GObject<Partial<GraphSize>>;\r\n        switch (size.currentCoordType) {\r\n            default: return Log.exDevv(\"translatePosCoords() invalid coordinate mode\", {mode:size.currentCoordType});\r\n            // case CoordinateMode.absolute: return size;\r\n            case CoordinateMode.absolute: case undefined: case null:\r\n                if (size.x !== undefined) ret.x = size.x;\r\n                if (size.y !== undefined) ret.y = size.y;\r\n                break;\r\n            case CoordinateMode.relativePercent:\r\n                //maybe do: dampening factor on relative % offset? is it possible?\r\n                // let s = this.getBasicSize(c);\r\n                // MATH:\r\n                // size.x = sp.x*x% + ep.x*(1-x%)\r\n                // size.x = sp.x*x% + ep.x - ep.x*x%\r\n                // size.x - ep.x= (sp.x - ep.x)*x%\r\n                // (size.x - ep.x) / (sp.x - ep.x) = x% // actually i inverted <sp, ep> in first equation, so reverse them in result too.\r\n                if (size.x !== undefined) ret.x = (1 - size.x) * sp.x + (size.x) * ep.x;\r\n                if (size.y !== undefined) ret.y = (1 - size.y) * sp.y + (size.y) * ep.y;\r\n                break;\r\n            case CoordinateMode.relativeOffset:\r\n            case CoordinateMode.relativeOffsetStart:\r\n            case CoordinateMode.relativeOffsetEnd:\r\n                let useStart: boolean;\r\n                let useEnd: boolean;\r\n                switch (size.currentCoordType) {\r\n                    default:\r\n                    case CoordinateMode.relativeOffset: useStart = true; useEnd = true; break;\r\n                    case CoordinateMode.relativeOffsetStart: useStart = true; useEnd = false; break;\r\n                    case CoordinateMode.relativeOffsetEnd: useStart = false; useEnd = true; break;\r\n                }\r\n                // offset = sp - size\r\n                // size = offset - sp\r\n                // in reverse: actualsize = offset, size=offset\r\n\r\n                // if coords are already in absolute mode.\r\n                let xIsAbsolute: number | undefined = (size.x&&!Array.isArray(size.x)) ? size.x : undefined;\r\n                let yIsAbsolute: number | undefined = (size.x&&!Array.isArray(size.x)) ? size.x : undefined;\r\n                Log.w(!!(xIsAbsolute || yIsAbsolute), \"decoding relative offset require an array size coordinate system. x=[x1, x2] --> x\", {size});\r\n\r\n                let offsetsp = useStart ? new GraphPoint(xIsAbsolute || size.x[0] + sp.x, yIsAbsolute || size.y[0] + sp.y) : new GraphPoint();\r\n                let offsetep = useEnd ? new GraphPoint(xIsAbsolute || size.x[1] + ep.x, yIsAbsolute || size.y[1] + ep.y) : new GraphPoint();\r\n                // if the start and endpoint of the edge didn't move, offsetsp = offsetep.\r\n                // if they moved, those 2 are discordant --> i pick middle\r\n                offsetsp.add(offsetep, false);\r\n                if (useStart && useEnd) offsetsp.divide(2, false);\r\n                if (!xIsAbsolute && size.x !== undefined) ret.x = offsetsp.x;\r\n                if (!yIsAbsolute && size.y !== undefined) ret.y = offsetsp.y;\r\n                if (xIsAbsolute) {\r\n                    ret.x = size.x;\r\n                }\r\n                if (yIsAbsolute) {\r\n                    ret.y = size.y;\r\n                }\r\n                break;\r\n        }\r\n        if (size.x === undefined) delete ret.x;\r\n        if (size.y === undefined) delete ret.y;\r\n        if ((size as any).w === undefined) delete ret.w; else ret.w = size.w;\r\n        if ((size as any).h === undefined) delete ret.h; else ret.h = size.h;\r\n        ret.currentCoordType = CoordinateMode.absolute;\r\n        // console.log(\"decode coords\", {size, sp, ep, ret});\r\n        return ret;\r\n    }\r\n    // from x,y as coords, to x%,y% as % of ((1-val)%*startpt) + ((val)%*endpt)\r\n    public decodePosCoords<T extends Partial<GraphSize> | Partial<GraphPoint>>(c: Context, size: T&any, view: LViewElement, sp0?: GraphPoint, ep0?: GraphPoint): T {\r\n        let le: LVoidEdge = c&&c.proxyObject.father;\r\n        // console.log(\"decodepos:\", {le, sp0, lesp:le?.startPoint});\r\n        let sp: GraphPoint = sp0||le.startPoint;\r\n        let ep: GraphPoint = ep0||le.endPoint;\r\n        return LEdgePoint.decodeCoords(size, sp, ep);\r\n    }\r\n\r\n    static testCoords(range: number = 30){\r\n        outer: for (let mode of [\"absolute\", \"relative%\", \"relativeOffset\", \"relativeOffsetStart\", \"relativeOffsetEnd\"])\r\n            for (let i = -range; i < range; i++)\r\n                for (let j = -range; j < range; j++){\r\n                    var s0 = {x:i, y:j};\r\n                    var sp = {x:10, y:10};\r\n                    var ep = {x:10, y:-10};\r\n                    // @ts-ignore\r\n                    var s1 = LEdgePoint.encodeCoords(s0, mode, sp, ep)\r\n                    // @ts-ignore\r\n                    var s00 = LEdgePoint.decodeCoords(s1, sp, ep);\r\n                    // @ts-ignore\r\n                    var error = Object.keys(s0).map( k=> s0[k].toFixed(3) === s00[k].toFixed(3) ? '' : k).join('');\r\n                    (mode != \"relative%\" && error ? console.error : console.log)({diff:[s00.x-s0.x, s00.y-s0.y].join(), i, j, mode, s1:[s1.x, s1.y].join(), s0, s00, error});\r\n                    if (mode != \"relative%\" && error ) break outer;\r\n                }\r\n    }\r\n    // @ts-ignore a\r\n\r\n    static encodeCoords<T extends Partial<EPSize>>(size0: T, edgePointCoordMode: CoordinateMode, sp:GraphPoint, ep: GraphPoint): T/*absolute*/{\r\n        let size: T = size0 as any;\r\n        if (edgePointCoordMode === size.currentCoordType ||\r\n            !size.currentCoordType && edgePointCoordMode === CoordinateMode.absolute) return size;\r\n        if (size.currentCoordType && size.currentCoordType !== CoordinateMode.absolute) size = LEdgePoint.decodeCoords(size, sp, ep);\r\n\r\n        let ret: any = ((\"w\" in size || \"h\" in size) ? new GraphSize() : new GraphPoint()); // GObject<Partial<GraphSize>>;\r\n        switch (edgePointCoordMode) {\r\n            default: return Log.exDevv(\"translatePosCoords() invalid coordinate mode\", {mode:edgePointCoordMode});\r\n            // case CoordinateMode.absolute: return size;\r\n            case CoordinateMode.relativePercent:\r\n                // let s = this.getBasicSize(c);\r\n                // MATH:\r\n                // size.x = sp.x*x% + ep.x*(1-x%)\r\n                // size.x = sp.x*x% + ep.x - ep.x*x%\r\n                // size.x - ep.x= (sp.x - ep.x)*x%\r\n                // (size.x - ep.x) / (sp.x - ep.x) = x% // actually i inverted <sp, ep> in first equation, so reverse them in result too.\r\n\r\n                if (sp.x === ep.x) ret.x = 0.5; // because otherwise it is infinity. so i force him to return in line.\r\n                else if (size.x !== undefined) ret.x = (size.x - sp.x) / (ep.x - sp.x);\r\n                if (sp.y === ep.y) ret.y = 0.5;\r\n                else if (size.y !== undefined) ret.y = (size.y - sp.y) / (ep.y - sp.y);\r\n                break;\r\n            case CoordinateMode.relativeOffset:\r\n            case CoordinateMode.relativeOffsetStart:\r\n            case CoordinateMode.relativeOffsetEnd:\r\n                let useStart: boolean;\r\n                let useEnd: boolean;\r\n                switch (edgePointCoordMode) {\r\n                    default:\r\n                    case CoordinateMode.relativeOffset: useStart = true; useEnd = true; break;\r\n                    case CoordinateMode.relativeOffsetStart: useStart = true; useEnd = false; break;\r\n                    case CoordinateMode.relativeOffsetEnd: useStart = false; useEnd = true; break;\r\n                }\r\n                if (size.x) ret.x = [useStart ? size.x - sp.x : -1, useEnd ? size.x - ep.x : -1];\r\n                if (size.y) ret.y = [useStart ? size.y - sp.y : -1, useEnd ? size.y - ep.y : -1];\r\n                /*\r\n                if (size.x) ret.x = [sp.x - size.x, ep.x - size.x];\r\n                if (size.y) ret.y = [sp.y - size.y, ep.y - size.y];*/\r\n                break;\r\n        }\r\n        if (size.x === undefined) delete ret.x;\r\n        if (size.y === undefined) delete ret.y;\r\n        if ((size as any).w === undefined) delete ret.w; else ret.w = (size as any).w;\r\n        if ((size as any).h === undefined) delete ret.h; else ret.h = (size as any).h;\r\n        // console.log(\"encode coorde\", {size, sp, ep, ret});\r\n        ret.currentCoordType = edgePointCoordMode;\r\n        return ret;\r\n    }\r\n    public encodePosCoords(c: Context, size0: Partial<EPSize>, view: LViewElement, sp0?: GraphPoint, ep0?: GraphPoint, mode?: CoordinateMode): Partial<EPSize> {\r\n        if (!view) view = this.get_view(c);\r\n        let size: Partial<EPSize> = size0 as any;\r\n        let edgePointCoordMode = mode || (view.__raw || view).edgePointCoordMode;\r\n        let le: LVoidEdge = c&&c.proxyObject.father;\r\n        let sp: GraphPoint = sp0 || le.startPoint;\r\n        let ep: GraphPoint = ep0 || le.endPoint;\r\n        return LEdgePoint.encodeCoords(size, edgePointCoordMode, sp, ep);\r\n    }\r\n\r\n    /* 13/10/2023 Giordano comment (defined in LPointerTargetable\r\n    public get_delete(context: Context): () => void {\r\n        // careful: pointedBy might be broken due to comment x984 (search it)\r\n        return super.get_delete(context);\r\n    }\r\n    */\r\n}\r\nRuntimeAccessibleClass.set_extend(DVoidVertex, DEdgePoint);\r\nRuntimeAccessibleClass.set_extend(LVoidVertex, LEdgePoint);\r\n\r\n@RuntimeAccessible('DVertex')\r\nexport class DVertex extends DGraphElement { // DVoidVertex\r\n    // static _super = DVoidVertex;\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // static singleton: LVertex;\r\n    // static logic: typeof LVertex;\r\n    // static structure: typeof DVertex;\r\n\r\n    // inherit redefine\r\n    id!: Pointer<DVertex, 1, 1, LVertex>;\r\n    graph!: Pointer<DGraph, 1, 1, LGraph>;\r\n    model!: Pointer<DModelElement, 0, 1, LModelElement>;\r\n    isSelected!: Dictionary<DocString<Pointer<DUser>>, boolean>;\r\n    // containedIn!: Pointer<DGraphElement, 0, 1, LGraphElement>;\r\n    subElements!: Pointer<DGraphElement, 0, 'N', LGraphElement>;\r\n    zoom!: GraphPoint;\r\n    x!: number;\r\n    y!: number;\r\n    w!: number;\r\n    h!: number;\r\n    isResized!: boolean;\r\n    // size!: GraphSize; // virtual, gets extracted from this. x and y are stored directly here as it extends GraphSize\r\n    // personal attributes\r\n    __isDVertex!: true;\r\n\r\n    public static new(htmlindex: number, model: DGraphElement[\"model\"], parentNodeID: DGraphElement[\"father\"],\r\n                      graphID: DGraphElement[\"graph\"], nodeID?: DGraphElement[\"id\"], size?: GraphSize): DVertex {\r\n        return new Constructors(new DVertex('dwc'), parentNodeID, true, undefined, nodeID)\r\n            .DPointerTargetable()\r\n            .DGraphElement(model, graphID, htmlindex)\r\n            .DVoidVertex(size || defaultVertexSize).DVertex().end();\r\n    }\r\n}\r\n\r\n@RuntimeAccessible('LVertex')\r\nexport class LVertex<Context extends LogicContext<any> = any, D = DVertex> extends LVoidVertex {\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // static singleton: LVertex;\r\n    // static logic: typeof LVertex;\r\n    // static structure: typeof DVertex;\r\n\r\n    // inherit redefine\r\n    __raw!: DVertex;\r\n    id!: Pointer<DVertex, 1, 1, LVertex>;\r\n    graph!: LGraph;\r\n    model?: LModelElement;\r\n    // isSelected: Dictionary<DocString<Pointer<DUser>>, boolean> = {};\r\n    isSelected(forUser?: Pointer<DUser>): boolean { return this.wrongAccessMessage(\"node.isSelected()\"); }\r\n    // containedIn?: LGraphElement;\r\n    subElements!: LGraphElement[];\r\n    zoom!: GraphPoint;\r\n    x!: number;\r\n    y!: number;\r\n    w!: number;\r\n    h!: number;\r\n    size!: GraphSize; // virtual, gets extracted from this. x and y are stored directly here as it extends GraphSize\r\n    isResized!: boolean;\r\n    // personal attributes\r\n    __isLVertex!: true;\r\n}\r\n\r\nRuntimeAccessibleClass.set_extend(DGraphElement, DVertex);\r\nRuntimeAccessibleClass.set_extend(LGraphElement, LVertex);\r\n\r\n@Leaf\r\n@RuntimeAccessible('DGraphVertex')\r\nexport class DGraphVertex extends DGraphElement { // MixOnlyFuncs(DGraph, DVertex)\r\n    // static _super1 = DGraph;\r\n    // static _super2 = DVertex;\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // static singleton: LGraphVertex;\r\n    // static logic: typeof LGraphVertex;\r\n    // static structure: typeof DGraphVertex;\r\n\r\n    // inherit redefine\r\n    id!: Pointer<DGraphVertex, 1, 1>;\r\n    graph!: Pointer<DGraph, 1, 1, LGraph>;\r\n    model!: Pointer<DModelElement, 1, 1, LModelElement>;\r\n    isSelected!: Dictionary<DocString<Pointer<DUser>>, boolean>;\r\n    // containedIn!: Pointer<DGraphElement, 0, 1, LGraphElement>;\r\n    subElements!: Pointer<DGraphElement, 0, 'N', LGraphElement>;\r\n    // from graph\r\n    zoom!: GraphPoint;\r\n    offset!: GraphSize; // in-graph scrolling position\r\n\r\n    // from VoidVertex\r\n    x!: number;\r\n    y!: number;\r\n    w!: number;\r\n    h!: number;\r\n    isResized!: boolean;\r\n    // size!: GraphSize; // virtual\r\n    // from graph\r\n\r\n    // personal attributes\r\n    __isDVertex!: true;\r\n    __isDGraph!: true;\r\n    __isDGraphVertex!: true;\r\n\r\n    public static new(htmlindex: number, model: DGraph[\"model\"], parentNodeID: DGraphElement[\"father\"],\r\n                      graphID: DGraphElement[\"graph\"], nodeID?: DGraphElement[\"id\"], size?: GraphSize): DGraphVertex {\r\n        return new Constructors(new DGraphVertex('dwc'), parentNodeID, true, undefined, nodeID)\r\n            .DPointerTargetable().DGraphElement(model, graphID, htmlindex)\r\n            .DVoidVertex(size || defaultVertexSize).DVertex().DGraph().end();\r\n    }\r\n\r\n\r\n    /*\r\n        static init_constructor(thiss: DGraphVertex, isUser: boolean = false, nodeID: string | undefined, graphID: string | undefined, model: Pointer<DModel>): void {\r\n            DGraph.init_constructor(thiss, isUser, nodeID, graphID, model);\r\n    //isUser: boolean = false, nodeID: string | undefined, graphID: string, model?: Pointer<DModel>\r\n            DVertex.init_constructor(thiss, isUser, nodeID, graphID as string, model);\r\n            thiss.className = this.name;\r\n        }*/\r\n}\r\nclass LG extends LGraph{}\r\nclass LV extends LVertex{}\r\n\r\nconst Mixed = MixOnlyFuncs(LG, LV) as (typeof LG & typeof LV & typeof RuntimeAccessibleClass);\r\n@RuntimeAccessible('LGraphVertex')\r\n//@ts-ignore TS2510\r\nexport class LGraphVertex<Context extends LogicContext<any> = any, D extends DGraphVertex = any> extends Mixed { // MixOnlyFuncs(LGraph, LVertex)\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // static singleton: LGraphVertex;\r\n    // static logic: typeof LGraphVertex;\r\n    // static structure: typeof DGraphVertex;\r\n\r\n    // inherit redefine\r\n    __raw!: DGraphVertex;\r\n    id!: Pointer<DGraphVertex, 1, 1>;\r\n    graph!: LGraph;\r\n    model?: LModelElement;\r\n    // isSelected: Dictionary<DocString<Pointer<DUser>>, boolean> = {};\r\n    isSelected(forUser?: Pointer<DUser>): boolean { return this.wrongAccessMessage(\"node.isSelected()\"); }\r\n    // containedIn?: LGraphElement;\r\n    ///////////////////////////////////////// subElements!: LGraphElement[];\r\n    // from graph\r\n    zoom!: GraphPoint;\r\n    offset!: GraphSize; // in-graph scrolling position\r\n    graphSize!: GraphSize; // internal size of the graph. can be huge even if the sub-graph is in a small window (scroll)\r\n\r\n    // from VoidVertex\r\n    x!: number;\r\n    y!: number;\r\n    w!: number;\r\n    h!: number;\r\n    isResized!: boolean;\r\n    size!: GraphSize; // virtual\r\n\r\n\r\n    // personal attributes\r\n    __isLVertex!: true;\r\n    __isLGraph!: true;\r\n    __isLGraphVertex!: true;\r\n}\r\n\r\nRuntimeAccessibleClass.set_extend(DGraph, DGraphVertex);\r\nRuntimeAccessibleClass.set_extend(DVertex, DGraphVertex);\r\nRuntimeAccessibleClass.set_extend(LGraph, LGraphVertex);\r\nRuntimeAccessibleClass.set_extend(LVertex, LGraphVertex);\r\n\r\n\r\n@RuntimeAccessible('DVoidEdge')\r\nexport class DVoidEdge extends DGraphElement {\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // static singleton: LVoidEdge;\r\n    // static logic: typeof LVoidEdge;\r\n    // static structure: typeof DVoidEdge;\r\n    id!: Pointer<DVoidEdge, 1, 1, LVoidEdge>;\r\n    graph!: Pointer<DGraph, 1, 1, LGraph>;\r\n    model!: Pointer<DModelElement, 0, 1, LModelElement>;\r\n    // isSelected: Dictionary<DocString<Pointer<DUser>>, boolean> = {};\r\n    isSelected!: Dictionary<DocString<Pointer<DUser>>, boolean>;\r\n    // containedIn!: Pointer<DGraphElement, 0, 1, LGraphElement>;\r\n    subElements!: Pointer<DGraphElement, 0, 'N', LGraphElement>;\r\n\r\n    // personal attributes\r\n    start!: Pointer<DGraphElement, 1, 1, LGraphElement>;\r\n    end!: Pointer<DGraphElement, 1, 1, LGraphElement>;\r\n    __isDVoidEdge!: true;\r\n\r\n    midPoints!: InitialVertexSize[]; // the logic part which instructs to generate the midnodes\r\n    midnodes!: Pointer<DEdgePoint, 1, 1, LEdgePoint>[]; // using subelements instead most of times\r\n\r\n    longestLabel?: DocString<\"function\">;\r\n    labels?: DocString<\"function\">;\r\n    anchorStart?: string;\r\n    anchorEnd?: string;\r\n\r\n    isExtend!: boolean;\r\n    isReference!: boolean;\r\n    isValue!: boolean;\r\n    isDependency!: boolean;\r\n    // endFollow!: boolean; they became derived attributes from static properties\r\n    // startFollow!: boolean;\r\n\r\n    static isFollowingCoords: GraphPoint;\r\n\r\n    public static new(htmlindex: number, model: DGraph[\"model\"]|null|undefined, parentNodeID: DGraphElement[\"father\"], graphID: DGraphElement[\"graph\"],\r\n                      nodeID: DGraphElement[\"id\"]|undefined, start: DGraphElement[\"id\"], end: DGraphElement[\"id\"],\r\n                      longestLabel?: DEdge[\"longestLabel\"], labels?: DEdge[\"labels\"]): DEdge {\r\n        return new Constructors(new DEdge('dwc'), parentNodeID, true, undefined, nodeID)\r\n            .DPointerTargetable()\r\n            .DGraphElement(model, graphID, htmlindex)\r\n            .DVoidEdge(start, end, longestLabel, labels).end();\r\n    }\r\n    public static new2(model: DGraph[\"model\"]|null|undefined, parentNodeID: DGraphElement[\"father\"], graphID: DGraphElement[\"graph\"],\r\n                       nodeID: DGraphElement[\"id\"]|undefined, start: DGraphElement[\"id\"], end: DGraphElement[\"id\"], setter:((d: DEdge) => any)): DEdge {\r\n        return new Constructors(new DEdge('dwc'), parentNodeID, true, undefined, nodeID)\r\n            .DPointerTargetable()\r\n            .DGraphElement(model, graphID)\r\n            .DVoidEdge(start, end).end(setter);\r\n    }\r\n}\r\n/*\r\n@RuntimeAccessible\r\nexport class MidPoint{\r\n    readonly id: string; // not really a pointer, it's not on store.\r\n    x?: number; y?: number;\r\n    readonly w?: number; // if it's modified it's not ever here (initial size) but on DEdgePoint that is a Node.\r\n    readonly h?: number;/*\r\n    constructor2(x: number=5, y: number=5, w: number=5, h: number=5) {\r\n        this.x = x;\r\n        this.y = y;\r\n        this.w = w;\r\n        this.h = h;\r\n    }* /\r\nconstructor(id: string, w: number=5, h: number=5) {\r\n    this.id = id;\r\n    this.w = w;\r\n    this.h = h;\r\n}\r\n}*/\r\n@RuntimeAccessible('EdgeSegment')\r\nexport class EdgeSegment{\r\n    index: number;\r\n    prev: EdgeSegment | undefined;\r\n    start: segmentmaker;\r\n    bezier: segmentmaker[];\r\n    end: segmentmaker;\r\n    length!: number;\r\n    // if EdgeSegment is changed, shouldcomponentupdate needs update too: search in IDE for \"5khi2\"\r\n    d!: string;\r\n    dpart!: string; //  a segment of the whole path\r\n    m!: number; // m coefficient of the line between start and end.\r\n    rad!: number; // for head and tails: radian angle of the segment.\r\n    radLabels!: number; // for labels: it flips the angle when it's < PI/2 so the text is never upside down\r\n\r\n    isLongest!: boolean;\r\n    label!: PrimitiveType | JSX.Element | undefined;\r\n    svgLetter: EdgeBendingMode;\r\n    /*constructor(label: PrimitiveType|undefined, length: number, startp: GraphPoint, endp: GraphPoint, start: LGraphElement, end: LGraphElement,\r\n                bezierpts: GraphPoint[], mid: LGraphElement[],\r\n                svgLetter: EdgeBendingMode, index: number, fillMode: MidNodeHandling) {\r\n        this.label = label;\r\n        this.length = length;\r\n        this.length = length;\r\n        this.startp = startp;\r\n        this.bezierp = bezierpts;\r\n        this.endp = endp;\r\n        this.start = start;\r\n        this.end = end;\r\n        this.mid = mid;\r\n    }*/\r\n    constructor(start: segmentmaker, mid: segmentmaker[], end: segmentmaker,\r\n                svgLetter: EdgeBendingMode, gapMode: EdgeGapMode,\r\n                index: number, prevSegment: EdgeSegment | undefined){\r\n        // console.log(\"segmentmaker:\", arguments, ((start.ge?.model as any)?.name)+\" ---> \" + ((end.ge?.model as any)?.name));\r\n        this.start = start;\r\n        this.bezier = mid;\r\n        this.end = end;\r\n        this.index = index;\r\n        this.prev = prevSegment;\r\n        //this.segments = segments;\r\n        // the idea: forbid all T and S or transform them in C, Q by calculating and manually adding their mirrored bezier pts\r\n        // if (svgLetter[1]) svgLetter = (svgLetter[0]) as any;\r\n        if (svgLetter === EdgeBendingMode.Bezier_QT) {\r\n            this.svgLetter = EdgeBendingMode.Bezier_QT[0] as any as EdgeBendingMode;\r\n            // this.svgLetter = (index === 0 ? EdgeBendingMode.Bezier_QT[0] : EdgeBendingMode.Bezier_QT[1]) as any as EdgeBendingMode;\r\n            this.addBezierPoint();\r\n        } else\r\n        if (svgLetter === EdgeBendingMode.Bezier_CS) {\r\n            this.svgLetter = EdgeBendingMode.Bezier_CS[0] as any as EdgeBendingMode;\r\n            // this.svgLetter = (index === 0 ? EdgeBendingMode.Bezier_CS[0] : EdgeBendingMode.Bezier_CS[1]) as any as EdgeBendingMode;\r\n            this.addBezierPoint();\r\n        }\r\n        else this.svgLetter = svgLetter;\r\n\r\n        // fix if amount of bezier pts is invalid for current letter\r\n        switch (this.svgLetter) {\r\n            case EdgeBendingMode.Line:\r\n            case EdgeBendingMode.Bezier_quadratic:\r\n                if (this.bezier.length >= 1) break;\r\n                else this.svgLetter = EdgeBendingMode.Line;\r\n                break;\r\n            case EdgeBendingMode.Bezier_cubic:\r\n                if (this.bezier.length >= 2) break;\r\n                else if (this.bezier.length >= 1) this.svgLetter = EdgeBendingMode.Bezier_quadratic;\r\n                else this.svgLetter = EdgeBendingMode.Line;\r\n                break;\r\n            case EdgeBendingMode.Elliptical_arc:\r\n                if (this.bezier.length >= 3) break;\r\n                else this.svgLetter = EdgeBendingMode.Line; // straight to end ignoring midpoints that are NOT coordinates when using elliptical arc.\r\n                break;\r\n            default:\r\n            //case EdgeBendingMode.Bezier_quadratic_mirrored as string:\r\n            //case EdgeBendingMode.Bezier_cubic_mirrored as string: // translated to Q or C by adding mirrored bezier points explicitly\r\n            case EdgeBendingMode.Bezier_QT:\r\n            case EdgeBendingMode.Bezier_CS: // translated to Q or C by sending the right letter to each segment\r\n                Log.exDevv(\"this svg letter should not appear here\", this.svgLetter);\r\n                break;\r\n        }\r\n    }\r\n    addBezierPoint(): void {\r\n        let prev: EdgeSegment | undefined = this.prev;\r\n        if (!prev) return;\r\n        let prevedgemakerbezier: segmentmaker = (prev.bezier[prev.bezier.length-1] || prev.start);\r\n        let mirroredBezier: segmentmaker = {...prevedgemakerbezier,\r\n            pt: EdgeSegment.invertLastBezierPt(prevedgemakerbezier.pt, prev.end.pt),\r\n            uncutPt: EdgeSegment.invertLastBezierPt(prevedgemakerbezier.uncutPt, prev.end.uncutPt),\r\n        };\r\n        this.bezier = [mirroredBezier, ...this.bezier];\r\n        // always only 1 assumed pt both in cubic and quadratic.\r\n        // let next: this | undefined = this.segments[this.index+1];\r\n        // EdgeSegment.invertLastBezierPt((next.mid[1] || next.end).pt, next.start.pt);\r\n    }\r\n\r\n    makeD(index: number, gapMode: EdgeGapMode): string {\r\n        this.m = GraphPoint.getM(this.start.pt, this.end.pt);\r\n        this.rad = Geom.mToRad(this.m, this.start.pt, this.end.pt);\r\n        this.radLabels = Math.atan(this.m);\r\n\r\n        let svgLetter = this.svgLetter; // caller makes sure to pass right letter and resolve \"CS\" mixed letters. // this.bendingModeToLetter(bendingMode, index);\r\n        // caller sends inverted pts as normal coords\r\n        // let invertedBezPt = lastSegment && EdgeSegment.invertLastBezierPt(lastSegment.midp[lastSegment.mid.length-1] || lastSegment.startp, lastSegment.endp);\r\n        switch (this.svgLetter.length) {\r\n            case 2:\r\n                return Log.exDevv(\"mixed letters are not allowed and should have been resolved to single svg letters before here, found:\" + svgLetter);\r\n            /*return Log.exDevv(\"dev problem to fix:\\n\" +\r\n            \"the mirrored mode requires the first one to have explicit non-mirrored mode?? like M, C a1 a2 a3, S a1, S a1, S a1\\n\" +\r\n            \"So all segments with mixed modes needs to extract the last bezier point (penultimate coordinate) from previous segments, mirror it and insert in midp[0]\");*/\r\n            case 1:\r\n                let bezierpts = [...this.bezier.map( b => b.pt), this.end.pt];\r\n                let finalpart = svgLetter + \" \" + bezierpts.map((p)=> p.x + \" \" + p.y).join(\", \");\r\n                this.dpart = \"M \" + this.start.pt.x + \" \" + this.start.pt.y + \", \" + finalpart;\r\n                let bezierptsUncut = [...this.bezier.map( b => b.uncutPt), this.end.pt]; // uncutPt exist for start and end too, but i want to use the cut one for those. or edgehead is off\r\n                let finalpartUncut = svgLetter + \" \" + bezierptsUncut.map((p)=> p.x + \" \" + p.y).join(\", \");\r\n                this.d = (index === 0 ? \"M\" + this.start.pt.x + \" \" + this.start.pt.y + \", \" : \"\") + finalpartUncut;\r\n\r\n                //midp = [this.startp, ...this.midp];\r\n                // d = M sp X mp2 ep // X = custom letter\r\n                // dpart = T sp X mp2 ep // S = S if X = C,\r\n                // sp is the startingpoint from the prev node, which might be != from endpoint of last node if last node have w>0 && h>0\r\n                // so i'm \"filling\" the gap with a T, or L arc wich can use only 1 parameter (they are the only 1-parameter arcs)\r\n                // if (this.prev && this.prev.end.pt.equals(this.start.pt)) gapMode = EdgeGapMode.average; // if the 2 points coincide, i use any 1 of the gapmodes that are continuous\r\n                /*switch (gapMode){\r\n                    case EdgeGapMode.center:\r\n                    case EdgeGapMode.average:\r\n                        // continuous gap modes. they only differ in how the \"joining\" point is found, but not in how they behave after that.\r\n                        /*\r\n                        if (index === 0) {\r\n                             startletter = \"M \";\r\n                         }\r\n                         else {\r\n                             switch (svgLetter) {\r\n                                 case SvgLetter.A: case SvgLetter.C: case SvgLetter.S: case SvgLetter.Q: case SvgLetter.T: default:\r\n                                     startletter = SvgLetter.T + \" \"; break;\r\n                                 case SvgLetter.L: case SvgLetter.M:\r\n                                     startletter = SvgLetter.L + \" \"; break;\r\n                             }\r\n                         }* /\r\n                        if (index) {\r\n                            this.d = finalpart;\r\n                        }\r\n                        else { this.d = this.dpart; }\r\n                        break;\r\n                    case EdgeGapMode.gap:\r\n                    case EdgeGapMode.autoFill:\r\n                    case EdgeGapMode.lineFill:\r\n                    case EdgeGapMode.arcFill:\r\n                        // the filling itself is done by another segment (solving svg letter and simulating i=0), so i treat it as a gap.\r\n                        this.d = this.dpart;\r\n                        break;\r\n                    default:\r\n                        Log.exDevv(\"unexpected EdgeGapMode:\" + gapMode, {gapMode});\r\n                }*/\r\n                break;\r\n            default: return Log.exDevv(\"unexpected bending mode length:\" + this.svgLetter + \" or fillMode: \" + gapMode, {bendingMode: this.svgLetter, index, gapMode});\r\n        }\r\n\r\n        //using\r\n        /*\r\n        88\r\n\r\n        // d should not have M set (except for segments[0]\r\n        // dpart have M abd beed to add explicit points for \"mirroring\" and transforming bezier quadratic mirrored in bezier quadratic normal etc.\r\n        //88 problem: the mirrored mode requires the first one to have explicit nonmirrored mode?? like M, C a1 a2 a3, S a1, S a1, S a1 .... ?\r\n        in any case the % letter part is wrong because it needs to subtract first element used for M*/\r\n        return this.d;\r\n    }\r\n\r\n    static invertLastBezierPt(bezier: GraphPoint, end: GraphPoint): GraphPoint{\r\n        // vector = bezier - end\r\n        // end + vector = bezier\r\n        // end - vector = inverted bezier? = 2*end-bezier\r\n        let vector = bezier.subtract(end, true);\r\n        return end.subtract(vector, true);\r\n    }\r\n\r\n    calcLength(): void {\r\n        this.length = this.start.pt.distanceFromPoint(this.end.pt);\r\n    }\r\n}\r\n\r\nexport class EdgeFillSegment extends EdgeSegment{\r\n    public static cname: string = \"EdgeFillSegment\";\r\n    makeD(index: number, gapMode: EdgeGapMode): string {\r\n        // if (gapMode === EdgeGapMode.autoFill) { gapMode = this.svgLetter === EdgeBendingMode.Line ? EdgeGapMode.lineFill : EdgeGapMode.arcFill; }\r\n        switch (gapMode) {\r\n            case \"closest\" as any:// EdgeGapMode.closest:\r\n            case EdgeGapMode.center:\r\n            case EdgeGapMode.average:\r\n            case EdgeGapMode.gap:\r\n                return \"\"; // should not have filler arcs\r\n            default:\r\n                /*\r\n            case EdgeGapMode.autoFill as any:\r\n            case EdgeGapMode.lineFill:\r\n                this.bezier = [];\r\n                this.svgLetter = EdgeBendingMode.Line;\r\n                return super.makeD(index, gapMode);\r\n            case EdgeGapMode.arcFill:*/\r\n                this.svgLetter = this.svgLetter[0] as EdgeBendingMode;\r\n                if (this.svgLetter === \"Q\") this.bezier = this.bezier.length ? [this.bezier[0]] : [];\r\n                return super.makeD(index, gapMode);\r\n        }\r\n    }\r\n}\r\nexport type labelfunc = (e:LVoidEdge, segment: EdgeSegment, allNodes: LEdge[\"allNodes\"], allSegments: EdgeSegment[]) => PrimitiveType;\r\nexport type labeltype = orArr<labelfunc | PrimitiveType>;\r\n\r\ntype segmentmaker = {size: GraphSize, view: LViewElement, ge: LGraphElement, pt: GraphPoint, uncutPt: GraphPoint};\r\n@RuntimeAccessible('LVoidEdge')\r\nexport class LVoidEdge<Context extends LogicContext<DVoidEdge> = any, D extends DEdge = DEdge> extends LGraphElement {\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // static singleton: LVoidEdge;\r\n    // static logic: typeof LVoidEdge;\r\n    // static structure: typeof DVoidEdge;\r\n    __raw!: DVoidEdge;\r\n    id!: Pointer<DVoidEdge, 1, 1, LVoidEdge>;\r\n    graph!: LGraph;\r\n    model?: LModelElement;\r\n    // isSelected: Dictionary<DocString<Pointer<DUser>>, boolean> = {};\r\n    isSelected(forUser?: Pointer<DUser>): boolean { return this.wrongAccessMessage(\"node.isSelected()\"); }\r\n    // containedIn?: LGraphElemnt;\r\n    subElements!: LGraphElement[];\r\n    __isLVoidEdge!: true;\r\n    midPoints!: InitialVertexSize[]; // the logic part which instructs to generate the midnodes\r\n    midnodes!: LEdgePoint[];\r\n    edge!: LVoidEdge; // returns self. useful to get edge from edgePoints without triggering error if you are already on edge.\r\n    __info_of__edge: Info = {type:\"?LEdge\", txt:\"returns this if called on an edge, the containing edge if called on an EdgePoint, undefined otherwise.\"}\r\n\r\n    isExtend!: boolean;\r\n    isReference!: boolean;\r\n    isValue!: boolean;\r\n    isDependency!: boolean;\r\n\r\n/*\r\nreplaced by startPoint\r\n    edgeStart!: GraphPoint;\r\n    edgeStart_inner!: GraphPoint;\r\n    edgeStart_outer!: GraphPoint;\r\n    __info_of__edgeStart: Info = {type: \"GraphPoint\", txt: \"Same as edgeStart_outer.\"}\r\n    __info_of__edgeStart_outer: Info = {type: \"GraphPoint\",\r\n     txt: \"Where the edge should start his path, in coordinates relative at the root Graph.\r\n     <br>Computed by combining the anchor offset option in View and the size of the starting node.\"}\r\n    __info_of__edgeStart_inner: Info = {type: \"GraphPoint\",\r\n     txt: \"Where the edge should start his path, in coordinates relative at the most nested Graph.\r\n     <br>Computed by combining the anchor offset option in View and the size of the starting node.\"}\r\n    edgeEnd!: GraphPoint;\r\n    edgeEnd_inner!: GraphPoint;\r\n    edgeEnd_outer!: GraphPoint;\r\n    __info_of__edgeEnd: Info = {type: \"GraphPoint\", txt: \"Same as edgeEnd_outer.\"}\r\n    __info_of__edgeEnd_outer: Info = {type: \"GraphPoint\",\r\n     txt: \"Where the edge should end his path, in coordinates relative at the root Graph.\r\n     <br>Computed by combining the anchor offset option in View and the size of the starting node.\"}\r\n    __info_of__edgeEnd_inner: Info = {type: \"GraphPoint\",\r\n     txt: \"Where the edge should end his path, in coordinates relative at the most nested Graph.\r\n     <br>Computed by combining the anchor offset option in View and the size of the starting node.\"}\r\n*/\r\n\r\n    allNodes!: [LGraphElement, ...Array<LEdgePoint>, LGraphElement];\r\n    __info_of__allNodes: Info = {type: \"[LGraphElement, ...Array<LEdgePoint>, LGraphElement]\", txt: <span>first element is this.start. then all this.midnodes. this.end as last element</span>};\r\n\r\n\r\n    label!: this[\"longestLabel\"];  // should never be read change their documentation in write only. their values is \"read\" in this.segments\r\n    longestLabel!: labeltype;\r\n    labels!: labeltype;\r\n    __info_of__longestLabel: Info = {label:\"Longest label\", type:\"function(edge)=>string\",\r\n        readType: \"(edge:LEdge, segment: EdgeSegment, allNodes: DGraphElement[], allSegments: EdgeSegment[]) => PrimitiveType\",\r\n        writeType:\"string\",\r\n        txt: <span>Label assigned to the longest path segment.</span>}\r\n    __info_of__label: Info = {type: \"\", txt: <span>Alias for longestLabel</span>};\r\n    __info_of__labels: Info = {label:\"Multiple labels\", type: \"same type as longestLabel | longestLabel[]\",\r\n        writeType: \"string\",\r\n        txt: <span>Instructions to label to multiple or all path segments in an edge</span>\r\n    };\r\n\r\n\r\n    start!: LGraphElement;\r\n    __info_of__start: Info = {type: \"LVertex\", txt:\"the source point of the edge.\"}\r\n    get_start(c: Context): this['start'] { return LPointerTargetable.fromPointer(c.data.start); }\r\n    set_start(val: Pack1<LGraphElement>, c: Context): boolean {\r\n        let ptr = Pointers.from(val);\r\n        if (!ptr) { Log.exx(\"attempting to set an invalid LEdge.start: \" + ptr, {ptr, data: c.data}); return true; }\r\n        if (ptr === c.data.start) return true;\r\n        let name = this.get_name(c)||'';\r\n        TRANSACTION((name.toLowerCase().indexOf('edge')>=0 ? name : 'Edge: '+name)+'.start', ()=>{\r\n            SetFieldAction.new(c.data.id, 'start', ptr, '', true);\r\n        }, LPointerTargetable.from(c.data.start).name, LPointerTargetable.from(ptr).name)\r\n        return true;\r\n    }\r\n    end!: LGraphElement;\r\n    __info_of__end: Info = {type: \"LVertex\", txt:\"the terminal point of the edge.\"}\r\n    get_end(c: Context): this['end'] { return LPointerTargetable.fromPointer(c.data.end); }\r\n    set_end(val: Pack1<LGraphElement>, c: Context): boolean {\r\n        let ptr = Pointers.from(val);\r\n        if (!ptr) { Log.exx(\"attempting to set an invalid LEdge.end: \" + ptr, {ptr, data: c.data}); return true; }\r\n        if (ptr === c.data.end) return true;\r\n        let name = this.get_name(c)||'';\r\n        TRANSACTION((name.toLowerCase().indexOf('edge')>=0 ? name : 'Edge: '+name)+'.end', ()=>{\r\n            SetFieldAction.new(c.data.id, 'end', ptr, '', true);\r\n        }, LPointerTargetable.from(c.data.end).name, LPointerTargetable.from(ptr).name)\r\n        return true;\r\n    }\r\n\r\n\r\n    get_label(c: Context): this[\"longestLabel\"] { return this.get_longestLabel(c); }\r\n    set_label(val: DVoidEdge[\"longestLabel\"], c: Context): boolean { return this.set_longestLabel(val, c); }\r\n    get_longestLabel(c: Context): this[\"longestLabel\"] {\r\n        return transientProperties.node[c.data.id].longestLabel;\r\n        /*if (transientProperties.node[c.data.id].longestLabel !== undefined) return transientProperties.node[c.data.id].longestLabel;\r\n        else return transientProperties.view[c.data.view].longestLabel;*/\r\n    }\r\n    get_labels(c: Context): this[\"labels\"] {\r\n        return transientProperties.node[c.data.id].labels;\r\n        /*if (transientProperties.node[c.data.id].labels !== undefined) return transientProperties.node[c.data.id].labels;\r\n        else return transientProperties.view[c.data.view].labels;*/\r\n    }\r\n    set_longestLabel(val: DVoidEdge[\"longestLabel\"], c: Context): boolean {\r\n        Log.exDevv('Edge.labels are disabled, pass it through props instead');\r\n        if (val === c.data.longestLabel) return true;\r\n        let name = this.get_name(c)||'';\r\n        TRANSACTION((name.toLowerCase().indexOf('edge')>=0 ? name : 'Edge: '+name)+'.label', ()=>{\r\n            SetFieldAction.new(c.data, \"longestLabel\", val);\r\n            SetRootFieldAction.new(\"NODES_RECOMPILE_longestLabel+=\", c.data.id);\r\n        }, c.data.longestLabel, val);\r\n        return true;\r\n    }\r\n    set_labels(val: DVoidEdge[\"labels\"], c: Context): boolean {\r\n        Log.exDevv('Edge.labels are disabled, pass it through props instead');\r\n        if (val === c.data.labels) return true;\r\n        let name = this.get_name(c)||'';\r\n        TRANSACTION((name.toLowerCase().indexOf('edge')>=0 ? name : 'Edge: '+name)+'.labels', ()=>{\r\n            SetFieldAction.new(c.data, \"labels\", val);\r\n            SetRootFieldAction.new(\"NODES_RECOMPILE_labels+=\", c.data.id);\r\n        }, c.data.labels, val);\r\n        return true; }\r\n\r\n    public headPos_impl(c: Context, isHead: boolean, headSize0?: GraphPoint, segment0?: EdgeSegment, zoom0?: GraphPoint): GraphSize & {rad: number} {\r\n        let segment: EdgeSegment = segment0 || this.get_segments(c).segments[0];\r\n        // let v: LViewElement = this.get_view(c);\r\n        let tmp: any = headSize0 || (isHead ? this.get_view(c).edgeHeadSize : this.get_view(c).edgeTailSize);\r\n        if (!tmp || tmp.x === 0 || tmp.y === 0) {\r\n            // head or tail missing\r\n            tmp = new GraphSize(0, 0, 0, 0);\r\n            tmp.rad = 0;\r\n            return tmp;\r\n        }\r\n        let zoom: GraphPoint = zoom0 || this.get_graph(c).zoom;// ownZoom or cumulativeZoom?\r\n        let headPos: GraphSize & {rad: number} = (new GraphSize(0, 0, tmp.x, tmp.y) as any); //.multiply({w:zoom.x, h:zoom.y});\r\n        let useBezierPoints = true;\r\n        let start: GraphPoint, end: GraphPoint;\r\n        let m: number;\r\n        if (useBezierPoints) {\r\n            if (isHead) {\r\n                start = segment.end.pt;\r\n                end = (segment.bezier[segment.bezier.length - 1] || segment.start).pt;\r\n            } else {\r\n                start = segment.start.pt;\r\n                end = (segment.bezier[0] || segment.end).pt;\r\n            }\r\n            m = GraphPoint.getM(start, end);\r\n        } else {\r\n            if (isHead) { start = segment.end.pt; end = segment.start.pt; }\r\n            else { start = segment.start.pt; end = segment.end.pt; }\r\n            m = segment.m;\r\n        }\r\n        // first find the center of where it should be positioned\r\n        // let center: GraphPoint;\r\n        // let distance: number = Math.sqrt(headPos.w*headPos.w + headPos.h*headPos.h);\r\n        // let isVertical = m >=1 ;\r\n        let x4headsize = new GraphSize(start.x - headPos.w, start.y - headPos.h, headPos.w*2, headPos.h*2);\r\n        // first intersection is segment origin. second is found with the box containing all possible edgeHead positions that touch the startPoint\r\n        // (doing x4 his shape and placing 4 \"rectangles\" all around startPoint forming a 2x2 square) to cover all possible segment directions.\r\n        // or finding first direction (vertical if m >1, horizontal if m<0) and vector direction and intersecting with only the \"correct\" placed edgeHead rectangle.\r\n        // then the intersection will likely not fall on the extreme angle of EdgeHead and i can re-center edgeHead\r\n        // so that first and second intersections are equal spaced with the center segment\r\n        // later comment: i think original head is placed with .tl() equal to edge.endPoint (target anchor pos),\r\n        // then you build a 2x2 square around it (center of 2x2 square is edge.endPoint) to move it where the edge is coming, intersecting it.\r\n        let secondIntersection: GraphPoint | undefined;\r\n        let segmentDistance = start.distanceFromPoint(end);\r\n        if (segmentDistance <= Math.sqrt(headPos.w**2 + headPos.h**2)){ // todo: if pts are too close and m is infinite, this crashes?\r\n            let safeDistance = Math.max(headPos.w, headPos.h)*5;\r\n            end = new GraphPoint( end.y + safeDistance, end.y + m * safeDistance); // move the point away so it doesn't intersect anymore. i just need direction\r\n            // too small to fit edgeHead, i simply put it centered on the whole segment\r\n            // secondIntersection = end;\r\n        }\r\n        secondIntersection = GraphSize.closestIntersection(x4headsize, start, end, undefined, m, undefined);\r\n        if (!secondIntersection) {\r\n           return Log.exDevv(\"failed to intersect edge head\", {x4headsize, segment, headPos, c, start, end, useBezierPoints, m});\r\n        }\r\n        tmp = secondIntersection.add(start, false).divide(2); // center of edgehead\r\n        headPos.x = tmp.x - headPos.w / 2; // tl corner\r\n        headPos.y = tmp.y - headPos.h / 2; // tl corner\r\n        headPos.rad = Geom.mToRad(m, start, end);\r\n        /*\r\n        devo trovare la distanza tra il centro dell'egeHead e il punto di inizio in termini assoluti, così tramite M trovo distanza in x e y. o trovarla in altro modo\r\n        if (segment.m === Number.POSITIVE_INFINITY || segment.m === Number.NEGATIVE_INFINITY) {\r\n            center = segment.start.pt.add({x:0, y: distance}, true); }\r\n        else { center = segment.start.pt.add({x:segment.m*headPos.w/2, y:segment.m*headPos.h/2\r\n         this is wrong, cannot be the same for x and y, i should invert the line equation for x?}, true); }\r\n        headPos.x = center.x - headPos.w / 2;\r\n        headPos.y = center.y - headPos.h / 2;*/\r\n        // console.log(\"head intersected\", {headPos, secondIntersection, x4headsize, segment, c, start, end, useBezierPoints});\r\n\r\n        return headPos;\r\n    }\r\n\r\n    public headPos(headSize0?: GraphPoint, segment0?: EdgeSegment, zoom0?: GraphPoint): GraphSize & {rad: number} {\r\n        return this.wrongAccessMessage(\"This is not headPos() implementation. it is just for typings. use the getter\"); }\r\n    public tailPos(headSize0?: GraphPoint, segment0?: EdgeSegment, zoom0?: GraphPoint): GraphSize & {rad: number} {\r\n        return this.wrongAccessMessage(\"This is not tailPos() implementation. it is just for typings. use the getter\"); }\r\n    protected get_headPos(c: Context): this[\"headPos\"] {\r\n        return (headSize?: GraphPoint, segment?: EdgeSegment, zoom?: GraphPoint) => this.headPos_impl(c, true, headSize, segment, zoom); }\r\n    protected get_tailPos(c: Context): this[\"tailPos\"] {\r\n        return (headSize?: GraphPoint, segment?: EdgeSegment, zoom?: GraphPoint) => this.headPos_impl(c, false, headSize, segment, zoom); }\r\n    protected get_allNodes(c: Context): this[\"allNodes\"] { return [this.get_start(c), ...this.get_midnodes(c), this.get_end(c)]; }\r\n\r\n    protected get_edge(c: Context): this{ return c.proxyObject as this; }\r\n    protected set_edge(v: any, c: Context): false { return this.cannotSet(\"edge field, on an edge element\"); }\r\n    protected get_midPoints(c: Context):this[\"midPoints\"] { return c.data.midPoints; }\r\n    public addMidPoint(v: this[\"midPoints\"][0]): boolean { return this.wrongAccessMessage(\"addMidPoint\"); }\r\n    protected get_addMidPoint(c: Context): (v: this[\"midPoints\"][0]) => boolean { return (v:this[\"midPoints\"][0]) => this.impl_addMidPoints(v, c); }\r\n    protected set_midPoints(val: this[\"midPoints\"], c: Context): boolean {\r\n        let name = this.get_name(c)||'';\r\n        TRANSACTION((name.toLowerCase().indexOf('edge')>=0 ? name : 'Edge: '+name)+'.midpoints', ()=>{\r\n            SetFieldAction.new(c.data.id, \"midPoints\", val, undefined, false);\r\n        });\r\n        return true;\r\n    }\r\n    protected impl_addMidPoints(val: this[\"midPoints\"][0], c: Context): boolean {\r\n        let name = this.get_name(c)||'';\r\n        TRANSACTION((name.toLowerCase().indexOf('edge')>=0 ? name : 'Edge: '+name)+' add midpoints', ()=>{\r\n           SetFieldAction.new(c.data.id, \"midPoints\", val, '+=', false);\r\n        });\r\n        return true;\r\n    }\r\n    protected get_label_impl(c: Context, segment: EdgeSegment, nodes: this[\"allNodes\"], segments: EdgeSegment[]): PrimitiveType | undefined {\r\n        let key: \"longestLabel\" | \"labels\" = segment.isLongest ? \"longestLabel\" : \"labels\"; // : keyof this\r\n        // if (isLongestSegment) return this.get_longestLabel_impl(d, l, nodes, index):\r\n        const d = c.data;\r\n        const l = c.proxyObject;\r\n        let labelmaker: any = (this as any)['get_'+key](c);\r\n        let labelmakerfunc: labelfunc = labelmaker as any;\r\n        // let lastSeg = segments[i-1];\r\n        switch (typeof labelmaker) {//nb{}[]<>\r\n            case \"number\":\r\n            case \"undefined\":\r\n            case \"boolean\":\r\n            case \"string\": return labelmaker;\r\n            // case \"function\": return nodes.map( (o, i) => d.labels(l, nodes, i)).slice(0, nodes.length-1);\r\n            // (e:LVoidEdge, segment: EdgeSegment, allNodes: LEdge[\"allNodes\"], allSegments: EdgeSegment[]) => PrimitiveType\r\n            case \"function\": return labelmakerfunc(l, segment, nodes, segments);\r\n            default: break;\r\n            case \"object\":\r\n                if (labelmaker === null) return null;\r\n                if (!Array.isArray(labelmaker)) break;\r\n                let elem = (labelmaker as PrimitiveType[])[segment.index % labelmaker.length];\r\n                if (typeof elem === \"function\") return (elem as labelfunc)(l, segment, nodes, segments);\r\n                return elem;\r\n        }\r\n        Log.exx(\"edge labels invalid type, must be a primitive value, a function or an array of such.\", {labelmaker, key, d});\r\n        return undefined;\r\n    }/*\r\n    private get_label_impl_old(d: DVoidEdge, l: LVoidEdge, nodes:this[\"allNodes\"], index: number, longestlabelindex?: number): PrimitiveType {\r\n        if (d.longestLabel !== undefined && index === longestlabelindex) return this.get_longestLabel_impl(d, l, nodes, index);\r\n        switch (typeof d.labels) {//nb{}[]<>\r\n            case \"number\":\r\n            case \"undefined\":\r\n            case \"boolean\":\r\n            case \"string\": return d.labels;\r\n            // case \"function\": return nodes.map( (o, i) => d.labels(l, nodes, i)).slice(0, nodes.length-1);\r\n            case \"function\": return d.labels(l, nodes[index], nodes[index+1], index, nodes);\r\n            default: break;\r\n            case \"object\": if (!Array.isArray(d.labels)) break;\r\n            if (typeof d.labels[0] === \"function\") return (d.labels as any)[index % d.labels.length](l, nodes[index], nodes[index+1], index, nodes);\r\n            return (d.labels as PrimitiveType[])[index % d.labels.length];\r\n        }\r\n        Log.exx(\"edge labels invalid type, must be a primitive value, a function or an array of such.\", d.labels);\r\n    }*/\r\n\r\n    __info_of__startPoint: Info = {type: \"GraphPoint\", txt:<span>startPoint of this.start (element originating the edge). Defaults in outer coordinates.</span>};\r\n    __info_of__endPoint: Info = {type: \"GraphPoint\", txt:<span>endPoint of this.end (element originating the edge). Defaults in outer coordinates.</span>};\r\n    public get_startPoint(context: Context): GraphPoint{ return this.get_startPoint_Outer(context); }\r\n    public get_endPoint(context: Context): GraphPoint{ return this.get_endPoint_Outer(context); }\r\n    public get_startPoint_Outer(c: Context): GraphPoint{\r\n        // console.log(\"get_edgeStart_Outer\", {out:this.get_outerGraph(c), pos:this.get_startPoint_inner(c), inner:this.get_start(c).innerGraph});\r\n        return this.get_outerGraph(c).translateSize(this.get_startPoint_inner(c), this.get_start(c).innerGraph);\r\n    }\r\n    public get_endPoint_Outer(c: Context): GraphPoint{\r\n        // console.log(\"get_edgeEnd_Outer\", {out:this.get_outerGraph(c), pos:this.get_endPoint_inner(c), inner:this.get_end(c).innerGraph});\r\n        return this.get_outerGraph(c).translateSize(this.get_endPoint_inner(c), this.get_end(c).innerGraph);\r\n    }\r\n\r\n    public get_startPoint_inner(c: Context): GraphPoint{ return this.get_edgeStartEnd_inner(c, true); }\r\n    public get_endPoint_inner(c: Context): GraphPoint{ return this.get_edgeStartEnd_inner(c, false); }\r\n    private get_edgeStartEnd_inner(c: Context, isStart: boolean): GraphPoint{ return isStart ? this.get_start(c).startPoint : this.get_end(c).endPoint; }\r\n    segments!: {all: EdgeSegment[], segments: EdgeSegment[], fillers: EdgeSegment[], head: GraphSize&{rad:number}, tail: GraphSize&{rad:number}};\r\n    segments_inner!: {all: EdgeSegment[], segments: EdgeSegment[], fillers: EdgeSegment[], head: GraphSize&{rad:number}, tail: GraphSize&{rad:number}};\r\n    segments_outer!: {all: EdgeSegment[], segments: EdgeSegment[], fillers: EdgeSegment[], head: GraphSize&{rad:number}, tail: GraphSize&{rad:number}};\r\n    __info_of__segments: Info = {type: \"{all:T, segments:T, fillers:T, head: GraphSize&{rad:number}, tail: as head} where T is EdgeSegment\",\r\n        txt:<span>Collection of segments connecting in order vertex and EdgePoint without intersecting their area, aimed to be rendered in svg path.\r\n            <br/>fillers are arcs generated by view.edgeGapMode being autofill, arcfill or linefill.\r\n            <br/>length of this.segments array is Math.ceil(allNodes.length / svg_letter_size) specified on view.\r\n            <br/>\"head\" and \"tail\" are the position and angle of eventual edge decorators. Refer to this.headPos documentation.</span>}\r\n\r\n    private svgLetterSize(s: string, addM: boolean = true, doublingMidPoints: boolean = true): {first:number, others: number} {\r\n        let ret: {first:number, others: number};\r\n        switch (s) {\r\n            default: ret = Log.exDevv(\"unexpected svg path letter: \\\"\" + s + \"\\\"\", s); break;\r\n            case EdgeBendingMode.Line:\r\n            //case EdgeBendingMode.Bezier_quadratic_mirrored:\r\n                ret = {first:1, others:1}; break;\r\n            case EdgeBendingMode.Bezier_quadratic:\r\n            //case EdgeBendingMode.Bezier_cubic_mirrored:\r\n                ret = {first:2, others:2}; break;\r\n            case EdgeBendingMode.Bezier_cubic: ret = {first:3, others:3}; break;\r\n            case EdgeBendingMode.Elliptical_arc: ret = {first:4, others:4}; break;\r\n\r\n            case EdgeBendingMode.Bezier_QT: ret = {first:2, others:1}; break;\r\n            case EdgeBendingMode.Bezier_CS: ret = {first:3, others:2}; break;\r\n        }\r\n\r\n        // account for the fact that every midpoint is listed twice: at anchor start and anchor end.\r\n        if (doublingMidPoints) {\r\n            // removing last point (first is already excluded because addM didn't trigger yet)\r\n            // , the remaining are midpoints to double. then i add it back\r\n            ret.first = (ret.first - 1) * 2 + 1;\r\n            ret.others = (ret.others - 1) * 2 + 1;\r\n        }\r\n\r\n        // account for the first M letter\r\n        //    (if the segment is not mode.gap or first, M coord still exist in segment but are ignored)\r\n        if (addM) {\r\n            ret.first += 1;\r\n            ret.others += 1;\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    // outer should be a redundant param and always == true\r\n    private get_points_impl(allNodes: LGraphElement[], outer: boolean, c:Context): segmentmaker[] {\r\n        function getAnchorOffset(size: GraphSize, offset: GraphPoint, isPercentage: boolean, $factor: number = 100) {\r\n            if (!size) size = new GraphSize(0, 0, 0, 0);\r\n            // else if (!size.tl) size = new GraphSize(size.x, size.y, size.w, size.h);\r\n            if (isPercentage) offset = new GraphPoint(offset.x/$factor*(size.w), offset.y/$factor*(size.h));\r\n            return size.tl().add(offset, false);\r\n        }\r\n        let innermost: LGraph = this.get_graph(c);\r\n        let root: LGraph = this.get_root(c);\r\n        const all: segmentmaker[] = allNodes.flatMap((ge, i) => {\r\n            let dge = ge.__raw;\r\n            let size = outer ? ge.outerSize : ge.innerSize;\r\n\r\n            if (outer && root && innermost && innermost.id !== root.id) {\r\n                size = innermost.translateSize(size, root);\r\n            }\r\n            let base: segmentmaker = {view: ge.view, size, ge, pt: null as any, uncutPt: null as any};\r\n\r\n            Log.exDev(typeof base.size !== \"object\", \"could not get node size:\", {base, c, outer})\r\n            let rets: segmentmaker | undefined;// = base as any;\r\n            let rete: segmentmaker | undefined;// = {...base} as any;\r\n            let debug = true;\r\n            if (debug) {\r\n                (base as any).anchor_e = dge.anchors[c.data.anchorEnd || 0] || dge.anchors[Object.keys(dge.anchors)[0]];\r\n                (base as any).anchor_s = dge.anchors[c.data.anchorStart || 0] || dge.anchors[Object.keys(dge.anchors)[0]];\r\n            }\r\n\r\n            // get endpoint, then startpoint (land on midnode, then depart from it)\r\n            if (i !== 0){\r\n                rete = {rete:true, ...base} as any as segmentmaker;\r\n                if (i === allNodes.length - 1) {\r\n                    // get end anchor from node\r\n                    let anchor = dge.anchors[c.data.anchorEnd || 0];\r\n                    if (!anchor) anchor = dge.anchors[Object.keys(dge.anchors)[0]];\r\n                    if (anchor) rete.pt = getAnchorOffset(rete.size, anchor, true, 1);\r\n                }\r\n                // if no anchor, treat the node as a midpoint\r\n                if (!rete.pt) {\r\n                    // get ending point from midpoint\r\n                    //rete.pt = (LEdgePoint.singleton as LEdgePoint).get_endPoint(undefined as any, rete.size, rete.view);\r\n                    rete.pt = getAnchorOffset(rete.size, rete.view.edgeStartOffset, rete.view.edgeStartOffset_isPercentage);\r\n                }\r\n                rete.uncutPt = rete.pt;\r\n            }\r\n            if (i !== allNodes.length - 1){\r\n                rets = {rets: true, ...base} as any as segmentmaker;\r\n                if (i === 0) {\r\n                    // get start anchor from node\r\n                    let anchor = dge.anchors[c.data.anchorStart || 0];\r\n                    if (!anchor) anchor = dge.anchors[Object.keys(dge.anchors)[0]];\r\n                    if (anchor) rets.pt = getAnchorOffset(rets.size, anchor, true, 1);\r\n                }\r\n                if (!rets.pt) {\r\n                    // rets starting point from midpoint\r\n                    // rets.pt = (LEdgePoint.singleton as LEdgePoint).get_startPoint(undefined as any, rets.size, rets.view);\r\n                    rets.pt = getAnchorOffset(rets.size, rets.view.edgeStartOffset, rets.view.edgeStartOffset_isPercentage);\r\n                }\r\n                rets.uncutPt = rets.pt;\r\n            }\r\n\r\n            // ret.pt = ge.startPoint\r\n            return rets && rete ? [rete, rets] : (rets ? [rets] : [rete as segmentmaker]); }\r\n        );\r\n\r\n        if (DVoidEdge.isFollowingCoords){\r\n            if (c.data.id === LVoidEdge.endFollow) {\r\n                let seg = all[all.length - 1];\r\n                seg.pt = DVoidEdge.isFollowingCoords;\r\n                seg.size = new GraphSize(seg.pt.x, seg.pt.y, 0.01, 0.01);\r\n            }\r\n            if (c.data.id === LVoidEdge.startFollow) {\r\n                let seg = all[0];\r\n                seg.pt = DVoidEdge.isFollowingCoords;\r\n                seg.size = new GraphSize(seg.pt.x, seg.pt.y, 0.01, 0.01);\r\n            }\r\n        }\r\n        return all;\r\n    }\r\n    private get_pointsDebug(c: Context): segmentmaker[]{ return this.get_points_impl(this.get_allNodes(c), true, c); }\r\n    private get_points(allNodes: LGraphElement[], outer: boolean = false, c: Context): segmentmaker[]{\r\n        return this.get_points_impl(allNodes, outer, c);\r\n    }\r\n    private get_points_outer(allNodes: LGraphElement[], c: Context): segmentmaker[]{ return this.get_points_impl(allNodes, true, c); }\r\n    // private get_points_inner(allNodes: LGraphElement[], c: Context): segmentmaker[]{ return this.get_points_impl(allNodes, false, c); }\r\n    public d!: string;\r\n    public __info_of__d: Info = {type: ShortAttribETypes.EString, txt:\"the full suggested path of SVG path \\\"d\\\" attribute, merging all segments.\"}\r\n    public get_d(c: Context) {\r\n        return this.get_segments(c).all.map(s => s.d).join(\" \");\r\n    }/*\r\n    private get_fillingSegments(c: Context): Partial<this[\"segments\"]> {\r\n        return this.get_segments(c).fillers;\r\n    }*/\r\n\r\n\r\n    public get_segments(c:Context): this[\"segments\"] {\r\n        return this.get_segments_outer(c);\r\n    }\r\n    public get_segments_outer(c:Context): this[\"segments\"] { return this.get_segments_impl(c, true); }\r\n    // public get_segments_inner(c: Context): this[\"segments\"] { return this.get_segments_impl(c, false); }\r\n    private get_segments_impl(c: Context, outer: boolean): this[\"segments\"] {\r\n        let l = c.proxyObject;\r\n        let v = this.get_view(c);\r\n        let allNodes = l.allNodes;\r\n        windoww.edge = l;\r\n        let all: segmentmaker[] = this.get_points(allNodes, outer, c);\r\n        //const all: {size: GraphSize, view: LViewElement, ge: LGraphElement}[] = allNodes.map((ge) => { return { view: ge.view, size: ge.size, ge}});\r\n        let ret: EdgeSegment[] = [];\r\n        let bm: EdgeBendingMode = v.bendingMode;\r\n        let gapMode: EdgeGapMode = v.edgeGapMode;\r\n        let segmentSize = this.svgLetterSize(bm, false, true);\r\n        let increase: number = segmentSize.first;\r\n        let segment: EdgeSegment | undefined = undefined;\r\n        /// grouping points according to SvgLetter\r\n        for (let i = 0; i < all.length - 1; ) {\r\n            // let start = all[i], end = all[i+increase];\r\n            let start: segmentmaker = all[i];\r\n            let endindex = (i+increase < all.length - 1) ? i+increase : all.length - 1;\r\n            let mid: segmentmaker[] = all.slice(i+1, endindex).filter( (e, i)=> i % 2 === 0);\r\n            let end: segmentmaker = all[endindex];\r\n            // makes sure the edge actually reaches his target even if there is an invalid amount of midnodes fot the current EdgeBendingMode\r\n            if (i === endindex && segment) start = segment.end;\r\n            // segment = this.get_segmentv3(start, mid, end, getSvgLetter(i), i, segment, all);\r\n            segment = new EdgeSegment(start, mid, end, bm, gapMode, i, segment);\r\n            // segment = this.get_segment(start.ge, start.size, start.view, end.ge, end.size, end.view, cut, v.bendingMode, mid, ret[ret.length -1], fillMode, segment);\r\n            ret.push(segment);\r\n            i+= increase+1; // because increase index is already inserted at the end of prev segment\r\n            if (increase !== segmentSize.others) increase = segmentSize.others;\r\n            // if (longestLabel !== undefined && longest < s.length) { longest = s.length; longestindex = i; } todo: move to after snapping to borders\r\n        }\r\n        function printablesegment(s:GObject) {\r\n            let r: GObject = {};\r\n            for (let k in s) {\r\n                let v = s[k];\r\n                v = v?.__raw || v;\r\n                if (typeof v === \"object\") r[k] = JSON.parse(JSON.stringify(v));\r\n                else r[k] = v;\r\n            }\r\n            return r;\r\n        }\r\n\r\n        let fillSegments: EdgeSegment[] = [];\r\n        this.snapSegmentsToNodeBorders(c, v, ret, fillSegments);\r\n        let longestLabel = c.data.longestLabel;\r\n        this.setLabels(c, ret, allNodes);\r\n        // console.log(\"getSegments() labeled:\", {main:ret, fillSegments});\r\n        let rett: this[\"segments\"] = {all: [...ret, ...fillSegments], segments: ret, fillers: fillSegments} as any;\r\n        /*switch(bm){\r\n            default: break;\r\n            case EdgeBendingMode.Bezier_QT:\r\n            case EdgeBendingMode.Bezier_CS:\r\n                rett.\r\n        }*/\r\n        for (let i = 0; i < rett.all.length; i++) {\r\n            let s = rett.all[i];\r\n            s.makeD(i, gapMode);\r\n        }\r\n        let zoom = new GraphPoint(1, 1);\r\n        rett.head = this.headPos_impl(c, true, v.edgeHeadSize, rett.segments[rett.segments.length - 1], zoom);\r\n        rett.tail = this.headPos_impl(c, false, v.edgeTailSize, rett.segments[0], zoom);\r\n        return rett;\r\n    }\r\n    private setLabels(c: Context, segments: EdgeSegment[], allNodes: this[\"allNodes\"]): void {\r\n        // find longest segment\r\n        let longestindex = -1;\r\n        let longest = 0;\r\n        for (let i = 0; i < segments.length; i++) {\r\n            let s = segments[i];\r\n            s.calcLength();\r\n            if (longest < s.length) { longest = s.length; longestindex = i; }\r\n            s.isLongest = false;\r\n        }\r\n        if (longestindex >= 0) segments[longestindex].isLongest = true;\r\n        // apply labels\r\n        for (let s of segments) s.label = this.get_label_impl(c, s, allNodes, segments);\r\n    }\r\n\r\n    private snapSegmentsToNodeBorders(c: Context, v: LViewElement, ret: EdgeSegment[], fillSegments: EdgeSegment[]){\r\n        // snap segment start and end to a node border\r\n        let canCutStart: boolean = v.edgeStartStopAtBoundaries,\r\n            canCutEnd: boolean = v.edgeEndStopAtBoundaries;\r\n        let grid: GraphPoint | undefined = undefined;\r\n        // let fillSegments: EdgeSegment[] = [];\r\n        let gapMode: EdgeGapMode = v.edgeGapMode;\r\n        let bm: EdgeBendingMode = v.bendingMode;\r\n\r\n\r\n        let ci: GraphPoint | undefined;\r\n        // cut i === 0 is cut regardless of gapmode.\r\n        if (canCutStart) {\r\n            ci = GraphSize.closestIntersection(ret[0].start.size, ret[0].start.pt, (ret[0].bezier[0] || ret[0].end).pt, grid);\r\n            if (ci) ret[0].start.pt = ci;\r\n            /*\r\n            ret[0].start.pt =\r\n                GraphSize.closestIntersection(ret[0].start.size, ret[0].start.pt, (ret[0].bezier[0] || ret[0].end).pt, grid) as any\r\n                || Geom.closestPoint(ret[0].start.size, ret[0].start.pt);*/\r\n        }\r\n\r\n        // cut middle segments maybe\r\n        let prev: EdgeSegment;\r\n        let curr: EdgeSegment = ret[0];\r\n\r\n        // if (gapMode === EdgeGapMode.gap) return;\r\n        if (canCutStart || canCutEnd) // do the for below\r\n            for (let i = 1; i < ret.length; i++){\r\n                prev = ret[i-1];\r\n                curr = ret[i];\r\n                let doStartCut: boolean, doEndCut: boolean;\r\n                switch(gapMode){/*\r\n                    case EdgeGapMode.arcFill:\r\n                    case EdgeGapMode.lineFill:\r\n                    case EdgeGapMode.autoFill:\r\n                        // same as gap, but will insert 1 more segment to fill the hole\r\n                        doStartCut = true;\r\n                        doEndCut = true;\r\n                        if (prev.end.pt.equals(curr.start.pt)) break;\r\n                        fillSegments.push(new EdgeFillSegment(\r\n                            prev.end,\r\n                            [\r\n                                {...prev.end, pt: EdgeSegment.invertLastBezierPt(prev.end.pt, (prev.bezier[prev.bezier.length-1] || prev.start).pt)},\r\n                                {...curr.start, pt: EdgeSegment.invertLastBezierPt(curr.start.pt, (curr.bezier[0] || curr.end).pt)}\r\n                            ],\r\n                            curr.start,\r\n                            bm, gapMode, 0, undefined));\r\n                            / *\r\n                            fillSegments.push(new FillEdgeSegment( // M <start_gap> C <bez1> <bez2> <end_gap>\r\n                               // <start_gap> = end of last seg (start of gap) <end_gap> = first of curr seg (end of gap)\r\n                            prev.end.pt,\r\n                            EdgeSegment.invertLastBezierPt(prev.end.pt, prev.bezier[prev.bezier.length-1].pt || prev.start.pt),\r\n                            EdgeSegment.invertLastBezierPt(curr.start.pt, curr.bezier[0].pt || curr.end.pt),\r\n                            curr.start.pt)* /\r\n\r\n                        break;*/\r\n                    case EdgeGapMode.gap:\r\n                        // just snap to vertex edge         prevSegment.endp and ret.startp\r\n                        doEndCut = true; doStartCut = true;\r\n                        break;\r\n                    // average: todo: maybe rename in join (merges start-end at closest pt to both (avg), then snap on edge)\r\n                    case \"closest\" as any: //EdgeGapMode.closest:\r\n                        // does not work properly, i think i need to get next.end instead of curr.end, just disabled for now\r\n                        let nextpt: GraphPoint = (curr.bezier[0] || curr.end).pt;\r\n                        let prevpt: GraphPoint = (prev.bezier[prev.bezier.length-1] || prev.start).pt;\r\n                        let midexternalpt = prevpt.add(nextpt, true);\r\n                        let midedgepoint = curr.start.size.tl().add(curr.start.size.br(), false).divide(2, false);\r\n                        // od average between the 2 points before and after that are not part of this edgepoint, then raw a line from there to center of ep, find that intersection.\r\n                        ci = GraphSize.closestIntersection(curr.start.size, midedgepoint, midexternalpt, grid);\r\n                        doEndCut = doStartCut = false;\r\n                        if (canCutEnd && ci) prev.end.pt = ci;\r\n                        if (canCutStart && ci) curr.start.pt = ci;\r\n                        break;\r\n                    case EdgeGapMode.average:\r\n                        // first move to average of the 2 points in the gap, then snap to edge\r\n                        doEndCut = true; doStartCut = true;\r\n                        // indipendent from cutStart, cutEnd.\r\n                        // they merge if just 1 of cutting sides are true. (and if they are both false we don't even enter the for loop)\r\n                        curr.start.pt = curr.start.pt.add(prev.end.pt, false).divide(2, false);\r\n                        prev.end.pt = curr.start.pt.duplicate(); // intentionally not the same pt because during snap to edge they can diverge again.\r\n                        prev.start.uncutPt = prev.start.pt;\r\n                        prev.end.uncutPt = prev.end.pt;\r\n                        break;\r\n                    // center: first move it to center of edgePoint/node, then snap to edge.\r\n                    // this mode might be as well deleted, it can be specified with anchor points\r\n                    case EdgeGapMode.center:\r\n                        doEndCut = false; doStartCut = false;\r\n                        curr.start.pt = curr.start.size.tl().add(curr.start.size.br(), false).divide(2, false);\r\n                        prev.end.pt = curr.start.pt.duplicate(); // intentionally not the same pt because during snap to edge they can diverge again.\r\n                        prev.start.uncutPt = prev.start.pt; // only update them when point moves without being cut (average and center)\r\n                        prev.end.uncutPt = prev.end.pt;\r\n                        break;\r\n                    default:\r\n                        return Log.exDevv(\"unexpected EdgeGapMode:\" + gapMode);\r\n                }\r\n                if (canCutStart && doStartCut){\r\n                    let nextpt: GraphPoint = (curr.bezier[0] || curr.end).pt;\r\n                    ci = GraphSize.closestIntersection(curr.start.size, curr.start.pt, nextpt, grid);\r\n                    if (ci) curr.start.pt = ci;// || Geom.closestPoint(curr.start.size, curr.start.pt);\r\n                    //if (gapMode === EdgeGapMode.average && prev) { prev.end.pt = curr.start.pt.add(prev.end.pt, false).divide(2, false); }\r\n                }\r\n                if (canCutEnd && doEndCut && prev){\r\n                    let prevpt: GraphPoint = (prev.bezier[prev.bezier.length-1] || prev.start).pt;\r\n                    ci = GraphSize.closestIntersection(prev.end.size, prev.end.pt, prevpt, grid);\r\n                    if (ci) prev.end.pt = ci;// || Geom.closestPoint(prev.end.size, prev.end.pt);\r\n                    // if average: first do average between start anchor points non-snapped. then i snap both,\r\n                    // then i do average again, and since it might snap out, i get closestPoint to EdgePoint size\r\n                    if (gapMode === EdgeGapMode.average) prev.end.pt = curr.start.pt =\r\n                        Geom.closestPoint(curr.start.size, curr.start.pt.add(prev.end.pt, false).divide(2, false));\r\n                }\r\n            }\r\n        // cut end of last segment regardless of gapMode\r\n        if (canCutEnd) {\r\n            let prevendpt = curr.end.pt;\r\n            ci = GraphSize.closestIntersection(curr.end.size, curr.end.pt, (curr.bezier[curr.bezier.length-1] || curr.start).pt, grid);\r\n            if (ci) curr.end.pt = ci; //|| Geom.closestPoint(prev.end.size, prev.end.pt);\r\n        }\r\n\r\n    }\r\n\r\n\r\n\r\n    get_edgeEnd(context: Context){ return this.get_edgeEnd_outer(context); }\r\n    get_edgeEnd_outer(c: Context){\r\n        // return this.get_outerGraph(c).translateSize(this.get_edgeEnd_inner(c), this.get_innerGraph(c));\r\n        return this.get_outerGraph(c).translateSize(this.get_edgeEnd_inner(c), this.get_end(c).innerGraph);\r\n    }\r\n    get_edgeEnd_inner(c: Context){\r\n        return this.get_edgeStartEnd_inner(c, false);\r\n        // return context.proxyObject.end?.size || new GraphPoint(0, 0);\r\n    }\r\n\r\n\r\n    protected get_midnodes(context: Context): this[\"midnodes\"] {\r\n        // return LPointerTargetable.wrapAll(context.data.midnodes);\r\n        return LPointerTargetable.wrapAll(context.data.subElements);\r\n    }\r\n    protected set_midnodes(val: D[\"midnodes\"], context: Context): boolean {\r\n\r\n        let name = this.get_name(context)||'';\r\n        TRANSACTION((name.toLowerCase().indexOf('edge')>=0 ? name : 'Edge: '+name)+'.midpoints', ()=>{\r\n            SetFieldAction.new(context.data.id, \"midnodes\", val, '', true);\r\n        });\r\n        return true;\r\n    }\r\n\r\n\r\n    anchorStart?: string;\r\n    anchorEnd?: string;\r\n    __info_of__anchorStart: Info = {writeType:\"string | undefined\", type:\"string\", isEdge: true,\r\n        txt:\"The name of a node anchor where the edge should originate from.\"};\r\n    __info_of__anchorEnd: Info = {writeType:\"string | undefined\", type:\"string\", isEdge: true,\r\n        txt:\"The name of a node anchor where the edge should point to.\"};\r\n    endFollow!: boolean;\r\n    startFollow!: boolean;\r\n    __info_of__endFollow: Info = {writeType:\"boolean\", readType:\"boolean\", type:\"boolean\", isEdge: true,// type:\"read:(()=>void), write:boolean\", readType:\"(()=>void))\",\r\n        txt:\"makes the ending point of an edge follow the cursor, so it can be assigned to a new anchor or target.\"};\r\n    __info_of__startFollow: Info = {writeType:\"boolean\", readType:\"boolean\", type:\"boolean\", isEdge: true,// type:\"read:(()=>void), write:boolean\", readType:\"(()=>void))\",\r\n        txt:\"makes the starting point of an edge follow the cursor, so it can be assigned to a new anchor or source.\"};\r\n    get_endFollow(c: Context): boolean { return (c.data.id === LVoidEdge.endFollow); }\r\n    get_startFollow(c: Context): boolean { return (c.data.id === LVoidEdge.startFollow); }\r\n    // // what in multieditor? needs to be moved in transientstuff?\r\n    set_endFollow(val: boolean, c: Context): boolean { return this._set_start_endFollow(val, c, false); }\r\n    set_startFollow(val: boolean, c: Context): boolean { return this._set_start_endFollow(val, c, true); }\r\n    _set_start_endFollow(val: boolean, c: Context, isStart: boolean): boolean {\r\n        val = !!val;\r\n        console.log(\"_set_start_endFollow\", {val, c, isStart});\r\n        if (val) {\r\n            if (isStart) LVoidEdge.startFollow = c.data.id;\r\n            else LVoidEdge.endFollow = c.data.id;\r\n            if (!LVoidEdge.following) {\r\n                console.log(\"_set_start_endFollow event attached\");\r\n                document.body.addEventListener(\"mousemove\", LVoidEdge.mousemove_pendingEdge, false);\r\n                document.body.addEventListener(\"keydown\", LVoidEdge.onKeyDown_pendingEdge, false);\r\n                LVoidEdge.following = true;\r\n                LVoidEdge.followingContext = c;\r\n                LVoidEdge.showAnchors();\r\n                (windoww.Tooltip as (typeof Tooltip)).show(<div>Changing anchor, press <b>Esc</b> to undo.</div>);\r\n\r\n                //let selector = \".Edge[nodeid='\" + (LVoidEdge.endFollow || LVoidEdge.startFollow as any)+\"']\";\r\n                // [...document.querySelectorAll(selector)].map(e=>e.classList.add(\"no-transition-following\")); gets refreshed by react\r\n                document.body.classList.add(\"no-transition-following\");\r\n            }\r\n        }\r\n        else {\r\n            if (LVoidEdge.following && ((isStart ? LVoidEdge.startFollow : LVoidEdge.endFollow) === c.data.id)) {\r\n                document.body.removeEventListener(\"mousemove\", LVoidEdge.mousemove_pendingEdge, false);\r\n                document.body.removeEventListener(\"keydown\", LVoidEdge.onKeyDown_pendingEdge, false);\r\n                let selector = \".Edge[nodeid='\" + (LVoidEdge.endFollow || LVoidEdge.startFollow as any)+\"']\";\r\n                //[...document.querySelectorAll(selector)].map(e=>e.classList.remove(\"no-transition-following\"));\r\n                document.body.classList.remove(\"no-transition-following\");\r\n                if (isStart) LVoidEdge.startFollow = undefined;\r\n                else LVoidEdge.endFollow = undefined;\r\n                LVoidEdge.following = false;\r\n                const $base = $(document.getElementById(isStart ? c.data.start : c.data.end) || []);\r\n                if (!$base.length) return true;\r\n                //const $deepAnchors = $base.find(\"[nodeid] .anchor\");\r\n                const $anchors = $base.find(\".anchor\")//.not($deepAnchors);\r\n                $anchors.removeClass([\"valid-anchor\", \"active-anchor\"]);\r\n                $base[0].style.overflow = '';\r\n                (windoww.Tooltip as (typeof Tooltip)).hide();\r\n            }\r\n        }\r\n        //SetFieldAction.new(c.data, \"startFollow\", !!val, '', false);\r\n        return true; }\r\n    public static startFollow: Pointer<DVoidEdge> | undefined = undefined;\r\n    public static endFollow: Pointer<DVoidEdge> | undefined = undefined;\r\n    public static following: boolean = false;\r\n    public static followingContext: LogicContext<DVoidEdge, LVoidEdge>;\r\n    public static tmp: number = 1;\r\n    public static canForceUpdate: boolean = true;\r\n    public static getCursorPos(e0: Event): Point { return new Point((e0 as any as MouseEvent).pageX, (e0 as any as MouseEvent).pageY); }\r\n    /*public static getGCursorPos(e0: Event): GraphPoint {\r\n        return LVLoidEdge.getCursorPos(e0).subtract(svgsize.tl(), true).multiply(svgzoom) as any as GraphPoint;\r\n    }*/\r\n    public static onKeyDown_pendingEdge(e: KeyboardEvent): void{\r\n        if (e.key === Keystrokes.escape) {\r\n            const c = LVoidEdge.followingContext;\r\n            if (!c || (!LVoidEdge.startFollow && !LVoidEdge.endFollow)) return;\r\n            let isStart = LVoidEdge.startFollow ? true : false;\r\n            let l = (c.proxyObject as any as LVoidEdge);\r\n            if (isStart) l.startFollow = false;\r\n            else l.endFollow = false;\r\n            // l.component?.forceUpdate(); does not work?\r\n            l.clonedCounter = (l.clonedCounter || 0) + 2;\r\n        }\r\n    }\r\n    public static showAnchors(): void{\r\n        const c = LVoidEdge.followingContext;\r\n        if (!c || (!LVoidEdge.startFollow && !LVoidEdge.endFollow)) return;\r\n        let isStart = LVoidEdge.startFollow ? true : false;\r\n        let nodeid: Pointer<DGraphElement> = isStart ? c.data.start : c.data.end;\r\n        let activeAnchor: string | number = (isStart ? c.data.anchorStart : c.data.anchorEnd) || 0;\r\n\r\n        const $base = $(document.getElementById(nodeid) || []);\r\n        if (!$base.length) return;\r\n        const $deepAnchors = $base.find(\"[nodeid] .anchor\");\r\n        const $anchors = $base.find(\".anchor\").not($deepAnchors);\r\n        $anchors.addClass(\"valid-anchor\");\r\n        $anchors.filter('[data-anchorname=\"'+activeAnchor+'\"]').addClass(\"active-anchor\");\r\n        $base[0].style.overflow = \"visible\";\r\n\r\n    }\r\n    private static mousemovei: number = 0;\r\n    public static mousemove_pendingEdge(e0: Event): void {\r\n        let forcererendermode = true;\r\n        if (forcererendermode) {\r\n            if (!LVoidEdge.following) return;\r\n            if (!LVoidEdge.canForceUpdate) return;\r\n            if (LVoidEdge.mousemovei++%30 === 0) LVoidEdge.showAnchors();\r\n\r\n\r\n            let c = LVoidEdge.followingContext;\r\n            let g: LGraph = c.proxyObject.graph;\r\n            let cursorPos = LVoidEdge.getCursorPos(e0);\r\n            let gcursorpos = g.translateHtmlSize(cursorPos);\r\n            // console.log(\"gcursorpos\", {cursorPos:cursorPos.toString(), gcursorpos:gcursorpos.toString(), g});\r\n            DVoidEdge.isFollowingCoords = gcursorpos;\r\n\r\n            let component: GraphElementComponent = GraphElementComponent.map[(LVoidEdge.startFollow || LVoidEdge.endFollow) as string];\r\n            LVoidEdge.canForceUpdate = false;\r\n            let timer = setTimeout(()=>{LVoidEdge.canForceUpdate = true; }, 5000);\r\n            let tn = transientProperties.node[c.data.id];\r\n            for (let vid in tn.viewScores) { // required to truly force an update\r\n                let tnv = tn.viewScores[vid];\r\n                tnv.jsxOutput = undefined;\r\n                tnv.usageDeclarations = undefined as any;\r\n                tnv.shouldUpdate = true;\r\n            }\r\n            component.setState({forceupdate:new Date().getDate()} as any, ()=>{LVoidEdge.canForceUpdate = true; clearTimeout(timer)});\r\n            // component.forceUpdate(()=>{LVoidEdge.canForceUpdate = true; clearTimeout(timer)});\r\n            return;\r\n        }\r\n\r\n        LVoidEdge.tmp++;\r\n        let selector = \".Edge[nodeid='\" + (LVoidEdge.endFollow || LVoidEdge.startFollow as any)+\"']\";\r\n        let root = document.querySelector(selector);\r\n        if (!root) return;\r\n        let paths: SVGPathElementt[] = [...root.querySelectorAll(\"path.full\")] as SVGPathElementt[];\r\n        let pathSegments = root.querySelectorAll(\"path.segment.preview\") as any as SVGPathElementt[];\r\n        // if (!paths.length) paths = pathSegments;\r\n        let pathSegmentContainers: Element[] = [...new Set([...pathSegments].map(e=>e.parentElement))] as Element[];\r\n        for (let container of pathSegmentContainers){\r\n            let se: SVGPathElementt[] = [...container.querySelectorAll(\"path.segment.preview\")] as SVGPathElementt[];\r\n            paths.push(se[LVoidEdge.endFollow ? se.length-1 : 0]);\r\n        }\r\n        let headTail = [...root.querySelectorAll(LVoidEdge.endFollow ? '.edgeHead' : '.edgeTail')] as HTMLElement[];\r\n        let cursorPos = LVoidEdge.getCursorPos(e0)\r\n\r\n        let segList: SVGPathSegment[] | undefined;\r\n        for (let p of paths) {\r\n            let svg: SVGElement = U.parentUntil(\"svg\", p) as SVGElement;\r\n            let svgsize: Size = Size.of(svg);\r\n            let svgzoom: Point = new Point(1,1); // todo: check viewbox and css zoom\r\n            let gcursorPos = cursorPos.subtract(svgsize.tl(), true).multiply(svgzoom) as any as GraphPoint;\r\n            segList = [...p.getPathData()];\r\n            let lastSeg = {...segList[LVoidEdge.endFollow ? segList.length-1 : 0]};\r\n            switch (lastSeg.type){\r\n                case 'a': case 'A':\r\n                    segList.push('fake new segment to get replaced instead of actual last segment which is A' as any);\r\n                    lastSeg.type=\"L\"; lastSeg.values = [gcursorPos.x, gcursorPos.y];\r\n                    break;\r\n                case \"C\": case \"c\": // bezier curves, keep type just change last point\r\n                case \"Q\": case \"q\":\r\n                case \"S\": case \"s\":\r\n                case \"T\": case \"t\":\r\n                    lastSeg.values[lastSeg.values.length-2] = gcursorPos.x;\r\n                    lastSeg.values[lastSeg.values.length-1] = gcursorPos.y; break;\r\n                case \"M\": case \"m\":\r\n                    lastSeg.type = LVoidEdge.endFollow ? \"L\" : \"M\";\r\n                    lastSeg.values = [gcursorPos.x, gcursorPos.y]; break;\r\n                case \"V\": case \"v\": // stuff forced to become a line\r\n                case \"H\": case \"h\":\r\n                case \"L\": case \"l\":\r\n                case \"Z\": case \"z\":\r\n                    lastSeg.type=\"L\"; lastSeg.values = [gcursorPos.x, gcursorPos.y];\r\n                    break;\r\n            }\r\n            segList[LVoidEdge.endFollow ? segList.length-1 : 0] = lastSeg;\r\n            if (LVoidEdge.tmp%20===0) console.log(\"svg set path data,\", {segList, oldSeglist:p.getPathData(), p});\r\n            p.setPathData(segList);\r\n        }\r\n\r\n        for (let ht of headTail){\r\n            let svg: SVGElement = U.parentUntil(\"svg\", ht) as SVGElement;\r\n            let svgsize: Size = Size.of(svg);\r\n            let svgzoom: Point = new Point(1,1); // todo: check viewbox and css zoom\r\n            let gcursorPos = cursorPos.subtract(svgsize.tl(), true).multiply(svgzoom) as any as GraphPoint;\r\n            let rotation: number;\r\n            let lastPt = segList && segList[LVoidEdge.endFollow ? segList.length-2 : 1].values;\r\n\r\n            if (lastPt) {\r\n                let m = gcursorPos.getM(new Point(lastPt[LVoidEdge.endFollow ? lastPt.length-2 : 1], lastPt[LVoidEdge.endFollow ? lastPt.length-1 : 0]));\r\n                if (Number.POSITIVE_INFINITY === m) rotation = Geom.degToRad(90); else\r\n                if (Number.NEGATIVE_INFINITY === m) rotation = Geom.degToRad(270); else\r\n                    rotation = Math.atan(m);\r\n                if (lastPt[LVoidEdge.endFollow ? lastPt.length-2 : 1] > gcursorPos.x) rotation -= Geom.degToRad(180);\r\n            } else { rotation = 0;}\r\n            let headSize = Size.of(ht);\r\n\r\n            let headPos = gcursorPos.subtract({x:headSize.w/2, y:headSize.h/2}, true);//.subtract({x:Math.cos(rotation)*headSize.w/2, y: -Math.sin(rotation)*headSize.h/2}, true);\r\n\r\n            if (LVoidEdge.tmp%20===0) console.log(\"_set_start_endFollow move head\", {selector:LVoidEdge.endFollow ? '.edgeHead' : '.edgeTail', headTail, root});\r\n            ht.style.transform = 'translate('+headPos.x+\"px, \"+headPos.y+\"px) rotate(\"+rotation+\"rad)\";\r\n        }\r\n    }\r\n}\r\nRuntimeAccessibleClass.set_extend(DGraphElement, DVoidEdge);\r\nRuntimeAccessibleClass.set_extend(LGraphElement, LVoidEdge);\r\n\r\n@RuntimeAccessible('DEdge')\r\nexport class DEdge extends DVoidEdge { // DVoidEdge\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // static singleton: LGraphElement;\r\n    // static logic: typeof LGraphElement;\r\n    // static structure: typeof DGraphElement;\r\n    id!: Pointer<DEdge, 1, 1, LEdge>;\r\n    graph!: Pointer<DGraph, 1, 1, LGraph>;\r\n    model!: Pointer<DModelElement, 0, 1, LModelElement>;\r\n    // isSelected: Dictionary<DocString<Pointer<DUser>>, boolean> = {};\r\n    isSelected!: Dictionary<DocString<Pointer<DUser>>, boolean>;\r\n    // containedIn!: Pointer<DGraphElement, 0, 1, LGraphElement>;\r\n    subElements!: Pointer<DGraphElement, 0, 'N', LGraphElement>;\r\n    state!: GObject;\r\n    start!: Pointer<DGraphElement, 1, 1, LGraphElement>;\r\n    end!: Pointer<DGraphElement, 1, 1, LGraphElement>;\r\n    __isDEdge!: true;\r\n    __isDVoidEdge!: true;\r\n    midnodes!: Pointer<DEdgePoint, 1, 1, LEdgePoint>[];\r\n}\r\n\r\n@RuntimeAccessible('LEdge')\r\nexport class LEdge<Context extends LogicContext<DEdge> = any, D extends DEdge = DEdge> extends LVoidEdge {\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // static singleton: LGraphElement;\r\n    // static logic: typeof LGraphElement;\r\n    // static structure: typeof DGraphElement;\r\n    __raw!: DEdge;\r\n    id!: Pointer<DEdge, 1, 1, LEdge>;\r\n    graph!: LGraph;\r\n    model?: LModelElement;\r\n    // isSelected: Dictionary<DocString<Pointer<DUser>>, boolean> = {};\r\n    isSelected(forUser?: Pointer<DUser>): boolean { return this.wrongAccessMessage(\"node.isSelected()\"); }\r\n    // containedIn!: LGraphElement;\r\n    subElements!: LGraphElement[];\r\n    _state!: GObject<\"proxified\">; // LMap;\r\n    midnodes!: LEdgePoint[];\r\n    __isLEdge!: true;\r\n    __isLVoidEdge!: true;\r\n\r\n}\r\nRuntimeAccessibleClass.set_extend(DVoidEdge, DEdge);\r\nRuntimeAccessibleClass.set_extend(LVoidEdge, LEdge);\r\n@Leaf\r\n@RuntimeAccessible('DExtEdge')\r\nexport class DExtEdge extends DEdge { // etends DEdge\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // static singleton: LGraphElement;\r\n    // static logic: typeof LGraphElement;\r\n    // static structure: typeof DGraphElement;\r\n    id!: Pointer<DExtEdge, 1, 1, LExtEdge>;\r\n    graph!: Pointer<DGraph, 1, 1, LGraph>;\r\n    model!: Pointer<DModelElement, 0, 1, LModelElement>;\r\n    // isSelected: Dictionary<DocString<Pointer<DUser>>, boolean> = {};\r\n    isSelected!: Dictionary<DocString<Pointer<DUser>>, boolean>;\r\n    // containedIn!: Pointer<DGraphElement, 0, 1, LGraphElement>;\r\n    subElements!: Pointer<DGraphElement, 0, 'N', LGraphElement>;\r\n    state!: GObject;\r\n    start!: Pointer<DGraphElement, 1, 1, LGraphElement>;\r\n    end!: Pointer<DGraphElement, 1, 1, LGraphElement>;\r\n    __isDExtEdge!: true;\r\n    __isDEdge!: true;\r\n    __isDVoidEdge!: true;\r\n    /*\r\n        public static new(model: DGraph[\"model\"], parentNodeID: DGraphElement[\"father\"], graphID: DGraphElement[\"graph\"], nodeID?: DGraphElement[\"id\"], size?: GraphSize): DExtEdge {\r\n            return new Constructors(new DExtEdge('dwc')).DPointerTargetable().DGraphElement(model, parentNodeID, graphID, nodeID)\r\n                .DVoidEdge().DEdge().DExtEdge().end();\r\n        }*/\r\n}\r\n\r\n@RuntimeAccessible('LExtEdge')\r\nexport class LExtEdge extends LEdge{\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // static singleton: LGraphElement;\r\n    // static logic: typeof LGraphElement;\r\n    // static structure: typeof DGraphElement;\r\n    __raw!: DExtEdge;\r\n    id!: Pointer<DExtEdge, 1, 1, LExtEdge>;\r\n    graph!: LGraph;\r\n    model?: LModelElement;\r\n    // isSelected: Dictionary<DocString<Pointer<DUser>>, boolean> = {};\r\n    isSelected(forUser?: Pointer<DUser>): boolean { return this.wrongAccessMessage(\"node.isSelected()\"); }\r\n    // containedIn!: LGraphElement;\r\n    subElements!: LGraphElement[];\r\n    _state!: GObject<\"proxified\">; // LMap;\r\n    start!: LGraphElement;\r\n    end!: LGraphElement;\r\n    __isLExtEdge!: true;\r\n    __isLEdge!: true;\r\n    __isLVoidEdge!: true;\r\n}\r\nRuntimeAccessibleClass.set_extend(DEdge, DExtEdge);\r\nRuntimeAccessibleClass.set_extend(LEdge, LExtEdge);\r\n@Leaf\r\n@RuntimeAccessible('DRefEdge')\r\nexport class DRefEdge extends DEdge { // extends DEdge\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    start!: Pointer<DGraphElement, 1, 1, LGraphElement>;\r\n    end!: Pointer<DGraphElement, 1, 1, LGraphElement>;\r\n    isSelected!: Dictionary<DocString<Pointer<DUser>>, boolean>;\r\n    __isDRefEdge!: true;\r\n    /*\r\n        public static new(model: DGraph[\"model\"], parentNodeID: DGraphElement[\"father\"], graphID: DGraphElement[\"graph\"], nodeID?: DGraphElement[\"id\"]): DRefEdge {\r\n            return new Constructors(new DRefEdge('dwc')).DPointerTargetable().DGraphElement(model, parentNodeID, graphID, nodeID)\r\n                .DVoidEdge().DEdge().DRefEdge().end();\r\n        }*/\r\n\r\n}\r\n@RuntimeAccessible('LRefEdge')\r\nexport class LRefEdge extends LEdge {\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // __raw!: DRefEdge;\r\n    start!: LGraphElement;\r\n    end!: LGraphElement;\r\n    __isLRefEdge!: true;\r\n}\r\nRuntimeAccessibleClass.set_extend(DEdge, DRefEdge);\r\nRuntimeAccessibleClass.set_extend(LEdge, LRefEdge);\r\n// for edges without a modelling element\r\n\r\n\r\n/*\r\n\r\nlet a = `DExtEdge, DRefEdge, DVoidEdge, LGraphVertex, LRefEdge, LEdgePoint, DVoidVertex, DGraphVertex, DEdgePoint,\r\n DVertex, DEdge, LVertex, LGraph, DGraph, LVoidVertex, LVoidEdge, LEdge, LGraphElement, LExtEdge, DGraphElement`;\r\n  // // ... get from export in index.ts\r\na = a.replaceAll(',,', \",\")\r\nlet aa = a.split(\",\").map(a => a.trim().substring(1));\r\n\r\nfunction onlyUnique(value, index, self) { return self.indexOf(value) === index; }\r\n\r\naa = aa.filter(onlyUnique).filter( a=> !!a)\r\nlet r = aa.filter(onlyUnique).filter( a=> !!a).map( a=> `export type W${a} = getWParams<L${a}, D${a}>;`).join('\\n')\r\ndocument.body.innerText = r;\r\n*/\r\nexport type WExtEdge = getWParams<LExtEdge, DExtEdge>;\r\nexport type WRefEdge = getWParams<LRefEdge, DRefEdge>;\r\nexport type WVoidEdge = getWParams<LVoidEdge, DVoidEdge>;\r\nexport type WGraphVertex = any; // getWParams<LGraphVertex, DGraphVertex>;\r\nexport type WEdgePoint = getWParams<LEdgePoint, DEdgePoint>;\r\nexport type WVoidVertex = getWParams<LVoidVertex, DVoidVertex>;\r\nexport type WVertex = getWParams<LVertex, DVertex>;\r\nexport type WEdge = getWParams<LEdge, DEdge>;\r\nexport type WGraph = getWParams<LGraph, DGraph>;\r\nexport type WGraphElement = getWParams<LGraphElement, DGraphElement>;\r\n\r\n//console.warn('ts loading graphDataElement');\r\n\r\n","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\view\\viewElement\\view.tsx",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\graph\\graphElement\\sharedTypes\\sharedTypes.tsx",["900"],"import React, {CSSProperties, PureComponent, ReactNode} from \"react\";\r\nimport type {\r\n    DEdge,\r\n    DGraph,\r\n    DGraphElement,\r\n    DModelElement,\r\n    DViewElement,\r\n    Json,\r\n    LGraph,\r\n    LGraphElement,\r\n    LModelElement,\r\n    LViewElement,\r\n    Pointer, PrimitiveType\r\n} from \"../../../joiner\";\r\nimport {Dictionary, LClass, LEdge, LUser, LViewPoint, LVoidVertex, RuntimeAccessible} from \"../../../joiner\";\r\nimport {GObject, InitialVertexSize, orArr} from \"../../../joiner/types\";\r\n\r\nexport class GraphElementStatee {/*\r\n    constructor(preRenderFunc: string | undefined, evalContext: GObject, templatefunc: () => React.ReactNode) {\r\n        this.preRenderFunc = preRenderFunc;\r\n        this.evalContext = evalContext;\r\n        this.template = templatefunc;\r\n    }\r\n    preRenderFunc?: string;\r\n    evalContext: Json;\r\n    template: () => ReactNode;* /\r\n    nodeid: Pointer<DGraphElement, 1, 1, LGraphElement>;\r\n    constructor(nodeid: Pointer<DGraphElement, 1, 1, LGraphElement>) {\r\n        this.nodeid = nodeid;\r\n    }*/\r\n    // displayPosition?: GraphSize; // used while dragging to prevent flood of redux events\r\n    classes!: string[];\r\n}\r\n\r\n\r\nexport class GraphElementReduxStateProps {\r\n    // userexample?: UserState; // todo: make and repace with proxy wrapper \"User\", or make a \"cached\" global variable synchronized with redux state for easier access\r\n    view!: LViewElement;\r\n    views!: LViewElement[]; // all applicable views\r\n    // graphID!: string;\r\n    // dataid?: Pointer<DModelElement, 1, 1, LModelElement>;\r\n    // model?: LModel;\r\n    // [userMappedFromRedux: string]: any; // roba che l'utente ha dichiarato di voler prendere dallo stato e redux gli carica nelle props\r\n    //preRenderFunc?: string;\r\n    // evalContext!: Json; moved to transient properties\r\n    //template!: string;\r\n    node!: LGraphElement;\r\n    data?: LModelElement;\r\n    __skipRender?: boolean;\r\n    // usageDeclarations!: DefaultUsageDeclarations;\r\n    // invalidUsageDeclarations?: Error; // moved in stateProps.usageDeclarations.__invalidUsageDeclarations\r\n    // graph!: LGraph;\r\n\r\n    // lastSelected!: LModelElement | null;\r\n    isEdgePending!: { user: LUser, source: LClass };// vertex only\r\n    nodeid!: Pointer<DGraphElement>;\r\n    dataid?: Pointer<DModelElement>;\r\n    viewid!: Pointer<DViewElement>;\r\n    viewsid!: Pointer<DViewElement>[];\r\n    parentviewid?:Pointer<DViewElement>;\r\n\r\n    static new(): GObject<GraphElementReduxStateProps>{\r\n        let e: GObject<GraphElementReduxStateProps> = new GraphElementReduxStateProps();\r\n        for (let k in e) if (e[k] === undefined) delete e[k];\r\n        return {...e}; // NB: because react complains if it's not a POJO.\r\n    }\r\n    protected constructor(){  }\r\n}\r\n\r\nexport class GraphElementDispatchProps {\r\n}\r\n\r\n// generic props for every component that this component will need to extend joining user-specified values and component-specific built-in values\r\nexport class BasicReactOwnProps {\r\n    children?: ReactNode; // orArr<JSX.Element | PrimitiveType>;\r\n    style?: CSSProperties;\r\n    class?: string | string[]; // my add as a fault-tolerant fix for users not used to jsx\r\n    className?: string | string[];\r\n    key?: string;\r\n\r\n    static new(): GObject<BasicReactOwnProps>{\r\n        let e: GObject<BasicReactOwnProps> = new BasicReactOwnProps();\r\n        for (let k in e) if (e[k] === undefined) delete e[k];\r\n        return e;\r\n    }\r\n    protected constructor(){ }\r\n}\r\n\r\nexport class GraphElementOwnProps extends BasicReactOwnProps {\r\n    data?: Pointer<DModelElement, 0, 1, LModelElement> | LModelElement;\r\n    view?: Pointer<DViewElement, 1, 1, LViewElement> | LViewElement;\r\n    views?: LViewElement[] | Pointer<DViewElement>[];\r\n    isGraph?: boolean;\r\n    isGraphVertex?: boolean;\r\n    isVertex?: boolean;\r\n    isEdgePoint?: boolean;\r\n    isEdge?: boolean;\r\n    isVoid?: boolean;\r\n    isField?: boolean = true;\r\n    onDelete?: (node: LGraphElement)=>boolean; // return false to prevent deletion\r\n\r\n    initialSize?: InitialVertexSize;\r\n\r\n    parentnodeid?: Pointer<DGraphElement, 1, 1, LGraphElement>; // Injected\r\n    nodeid?: Pointer<DGraphElement, 1, 1, LGraphElement>; // Injected\r\n    graphid?: Pointer<DGraph, 1, 1, LGraph>; // injected\r\n    parentViewId?: Pointer<DViewElement, 1, 1, LViewElement>; // injected\r\n    htmlindex?: number; // injected\r\n    childStyle?: CSSProperties; // obsolete use css // injected, indicates some properties are styled from <Polygon or such, and must be transferred to the first child of root\r\n\r\n    static new(): GObject<GraphElementOwnProps>{\r\n        let e: GObject<GraphElementOwnProps> = new GraphElementOwnProps();\r\n        for (let k in e) if (e[k] === undefined) delete e[k];\r\n        return e;\r\n    }\r\n    protected constructor(){ super(); }\r\n}\r\n\r\nexport class EdgeOwnProps extends GraphElementOwnProps {\r\n    onclick?: (e: React.MouseEvent<HTMLDivElement>) => void;\r\n    onmousedown?: (e: React.MouseEvent<HTMLDivElement>) => void;\r\n    start!: LGraphElement[\"id\"];\r\n    end!: LGraphElement[\"id\"];\r\n    label?: DEdge[\"longestLabel\"];\r\n    labels?: DEdge[\"labels\"];\r\n    anchorStart?: string;\r\n    anchorEnd?: string;\r\n    isField?: boolean = false;\r\n    isEdge?: boolean = true;\r\n    isReference?: boolean;\r\n    isValue?: boolean; // if missing it is deduced from isReference.\r\n    isExtend?: boolean;\r\n    isDepencency?: boolean; // package dep\r\n\r\n    static new(): GObject<EdgeOwnProps>{\r\n        let e: GObject<EdgeOwnProps> = new EdgeOwnProps();\r\n        for (let k in e) if (e[k] === undefined) delete e[k];\r\n        return e;\r\n    }\r\n    protected constructor(){ super(); }\r\n}\r\n\r\nexport class EdgeStateProps extends GraphElementReduxStateProps {\r\n    node!: LEdge;\r\n    edge!: LEdge; // just alias for node\r\n    //lastSelected!: LModelElement | null;\r\n    isEdgePending!: { user: LUser, source: LClass };\r\n    viewpoint!: LViewPoint;\r\n    start!: LGraphElement;\r\n    end!: LGraphElement;\r\n    __skipRender?: boolean; // in case start or end are undefined -> do not render the edge\r\n    static new(): GObject<EdgeStateProps>{\r\n        let e: GObject<EdgeStateProps> = new EdgeStateProps();\r\n        for (let k in e) if (e[k] === undefined) delete e[k];\r\n        return {...e}; // NB: because react complains if it's not a POJO.\r\n    }\r\n    protected constructor(){ super(); }\r\n    // key: string;\r\n}\r\n\r\n// @RuntimeAccessible\r\nexport class DefaultUsageDeclarations{\r\n    // all can be deleted in usageDeclaration function except view.\r\n    view?: GraphElementReduxStateProps[\"view\"];\r\n    node?: GraphElementReduxStateProps[\"node\"];\r\n    data: GraphElementOwnProps[\"data\"];\r\n    [key:string]: any;\r\n    constructor(ret: GraphElementReduxStateProps, ownProps: GraphElementOwnProps) {\r\n        /*this.data = ret.data;\r\n        this.view = ret.view;\r\n        this.node = ret.node;/*/\r\n    }\r\n}\r\n\r\n// @RuntimeAccessible\r\nexport class EdgeDefaultUsageDeclarations extends DefaultUsageDeclarations{\r\n    start!: EdgeOwnProps[\"start\"];\r\n    end!: EdgeOwnProps[\"end\"];\r\n}\r\n\r\n\r\n\r\nexport class VertexOwnProps extends GraphElementOwnProps {\r\n    // onclick?: (e: React.MouseEvent<HTMLDivElement>) => void;\r\n    // onmousedown?: (e: React.MouseEvent<HTMLDivElement>) => void;\r\n    isField?: boolean = false;\r\n    isVertex?: boolean = true;\r\n\r\n    decorated?: boolean; // for <decoratedStar /> (defaults true)\r\n    sides?: number // for <Polygon />, <Star /> and <Cross />\r\n    innerRadius?: number // for <Star /> and <Cross />\r\n    ratio?: number // for <Trapezoid />\r\n    rotate?: number // initial vertex rotation\r\n\r\n    static new(): GObject<VertexOwnProps>{\r\n        let e: GObject<VertexOwnProps> = new VertexOwnProps();\r\n        for (let k in e) if (e[k] === undefined) delete e[k];\r\n        return e;\r\n    }\r\n    protected constructor(){ super(); }\r\n}\r\n\r\nexport class VertexStateProps extends GraphElementReduxStateProps {\r\n    node!: LVoidVertex;\r\n    // lastSelected!: LModelElement | null;\r\n    // selected!: Dictionary<Pointer<DUser>, LModelElement|null>;\r\n    //selected!: LGraphElement|null;\r\n    isEdgePending!: { user: LUser, source: LClass };\r\n    viewpoint!: LViewPoint;\r\n\r\n    static new(): GObject<VertexStateProps>{\r\n        let e: GObject<VertexStateProps> = new VertexStateProps();\r\n        for (let k in e) if (e[k] === undefined) delete e[k];\r\n        return {...e}; // NB: because react complains if it's not a POJO.\r\n    }\r\n    protected constructor(){ super(); }\r\n}\r\n\r\n\r\nexport let contextFixedKeys: Dictionary<string, boolean> = {};\r\nsetContextFixedKeys();\r\n\r\nfunction setContextFixedKeys(){\r\n    // @ts-ignore: here i must use the constructor instead of new to have the undefined properties included.\r\n    let propmakers: GObject[] = [new EdgeOwnProps(), new EdgeStateProps(), new VertexOwnProps(), new VertexStateProps(), {\r\n        // \"model\", \"graph\",\r\n        \"constants\": true, \"usageDeclarations\": true,\r\n        \"component\": true,\r\n        \"htmlindex\": true,\r\n        \"state\": true, \"props\": true, \"stateProps\": true, \"ownProps\": true,\r\n        \"otherViews\": true, 'decorators':true, // only on final jsx, decorators are injected\r\n        //\"data\":true, \"node\":true, \"parentViewId\":true, \"parentnodeid\":true,// from props:\r\n        //\"view\":true, \"views\":true, \"viewScores\":true,// from props:\r\n        //\"children\":true, \"isGraph\":true, \"isVertex\":true, isEdge:true, isEdgePoint:true, isVoid: true, \"graphid\":true, \"nodeid\":true,// from props:\r\n    }];\r\n    for (let props of propmakers) for (let k in props) contextFixedKeys[k] = true;\r\n    delete contextFixedKeys.class;\r\n    return contextFixedKeys;\r\n}\r\n","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\common\\Dummy.ts",["901"],"import {\r\n    DeleteElementAction,\r\n    DState,\r\n    GObject,\r\n    Log,\r\n    LPointerTargetable, Pointer,\r\n    SetFieldAction, U,\r\n    SetRootFieldAction, TRANSACTION, DPointerTargetable, LViewPoint, DClass, L, LClass, Uarr, Pointers, store\r\n} from '../joiner';\r\nimport {Dependency} from \"../joiner/types\";\r\n\r\nexport class Dummy {\r\n\r\n    static get_delete(thiss: LPointerTargetable, context: any): () => void {\r\n        const lDeleted: LPointerTargetable & GObject = context.proxyObject;\r\n        const dDeleted = context.data;\r\n        const dependencies = thiss.get__jjdependencies(context);\r\n        console.log('get_delete '+(dDeleted as any).name, {dData: dDeleted, dependencies});\r\n\r\n        const ret = () => {\r\n            //console.log('0 get_delete() '+(dDeleted as any)?.name, {dData: dDeleted, cn:dDeleted?.className, dependencies});\r\n            const deletedID = dDeleted.id as any;\r\n            if (dDeleted.__readonly) return;\r\n            if (deletedID.indexOf('Pointer_View') !== -1 ) return; // cannot delete default views/viewpoints\r\n            SetRootFieldAction.new('_lastSelected', undefined, '');\r\n\r\n            console.log('1 get_delete() '+(dDeleted as any)?.name, {carr: lDeleted.children, dData: dDeleted, cn:dDeleted?.className, dependencies});\r\n            for (let child of lDeleted.children) {\r\n                child?.delete();\r\n                // if a m1-dvalue which conforms to a m2-reference with \"containment\" is deleted, the target is also deleted because is a \"children\" of it.\r\n            }\r\n\r\n            console.log('2 get_delete() '+(dDeleted as any)?.name, {dData: dDeleted, cn:dDeleted?.className, dependencies});\r\n            // those 2 are exceptions because the pointer is a key in an object instead of a normal value as a field or array member.\r\n            switch (dDeleted.className) {\r\n                case 'DViewElement':\r\n                    SetFieldAction.new(dDeleted.father, 'subViews', deletedID, '-=', false);\r\n                    break;\r\n                case 'DViewPoint':\r\n                    let projectid = (lDeleted as LViewPoint)?.project?.id;\r\n                    Log.eDevv('cannot find project id while deleting a viewpoint', {dData: dDeleted, context, dependencies});\r\n                    if (projectid) SetFieldAction.new(projectid, 'viewpoints', deletedID, '-=', false);\r\n                    break;\r\n                case 'DClass':\r\n                    this.dclass(context, thiss);\r\n                    break;\r\n            }\r\n\r\n            for (let dependency of dependencies) {\r\n                console.log('loop get_delete() '+(dDeleted as any)?.name, {dependency, dData: dDeleted, cn:dDeleted?.className, dependencies});\r\n\r\n                const root: keyof DState = dependency.firstKey;\r\n                if (root !== 'idlookup') {\r\n                    Log.eDev(root[root.length - 1] !== 's', 'Unexpected root pointedBy found in delete: ', {field: root, context, dependency, dependencies});\r\n                    SetRootFieldAction.new(root, deletedID, '-=', false);\r\n                    continue;\r\n                }\r\n                const pointer: Pointer|undefined = dependency.obj; // the object pointing to the deleted element\r\n                Log.exDev(!pointer, 'unexpected pointedBy found in delete', {pointer, dependency, dependencies});\r\n                if (!pointer) continue;\r\n                const field = dependency.lastKey;\r\n                const lObj: any = LPointerTargetable.wrap(pointer); // the object pointing to the deleted element\r\n                if (!lObj) continue; // already deleted?\r\n                const dObj: any = lObj.__raw;\r\n                console.log('3 get_delete() '+(dObj as any)?.name + '.' + field, {field, dData: dDeleted, cn:dDeleted?.className});\r\n\r\n\r\n                switch (field as string) {\r\n                    /* on '-=' pointedby would be removed from the element we are deleting, so it is irrelevant */\r\n                    default:\r\n                        Log.eDevv('Unexpected case in delete: '+field, {dDeleted, '.':'.', field, '=':'=', dObj});\r\n                        break;\r\n                    case 'end': case 'start':\r\n                        // no-op\r\n                        break;\r\n                    case 'extends':\r\n                    case 'extendedBy':/* both handled in this.DClass()\r\n                        // just remove the entry\r\n                        lObj[field as any] = dObj[field as any].filter((id: Pointer)=> !!id && id !== deletedID);\r\n                        break;\r\n                    case 'extends':\r\n                        let superclasses = (dDeleted as DClass).extends;\r\n                        let newArr = dObj[field as any].filter((id: Pointer)=> !!id && id !== deletedID);\r\n                        if (!superclasses.length){\r\n                            newArr.push(...superclasses);\r\n                        }\r\n                        lObj[field as any] = newArr*/\r\n                        break;\r\n                    case 'type':\r\n                        switch (dObj.className) {\r\n                            default: Log.eDevv('unexpected pointer to type:' + dObj.className, {dObj, dDeleted, field}); break;\r\n                            case 'DParameter': case 'DAttribute': lObj.type = 'Pointer_ESTRING'; break;\r\n                            case 'DReference': case 'DOperation':\r\n                                // would be nice to set dObj.extends[0] instead but i cannot tell if it was deleted too.\r\n                                // lData.father instead is safe as even if it's deleted it does not matter as it will delete the feature together\r\n                                lObj.type = lDeleted.father;\r\n                                break;\r\n                        }\r\n                        break;\r\n\r\n                    case 'subElements':\r\n                        // could change parent to them, but if parent node is removed, childnodes won't exist anymore either.\r\n                        // low prio todo: delete subnodes to save memory\r\n                        break;\r\n                    case 'values':\r\n                    case 'packages':\r\n                    case 'subpackages':\r\n                    case 'classifiers':\r\n                    case 'enumerators':\r\n                    case 'literals':\r\n                    case 'classes':\r\n                    case 'attributes':\r\n                    case 'references':\r\n                    case 'operations':\r\n                    case 'parameters':\r\n                    case 'features':\r\n                    case 'instances':\r\n                    case 'objects':\r\n                    case 'annotations':\r\n                    case 'models': // from DProject\r\n                    case 'edgesIn': case 'edgesOut':\r\n                    case 'metamodels':\r\n                    case 'dependencies':\r\n                        /* obj.annotations -> removed element, just remove the entry from the list*/\r\n                        // NB: \"models\" etc are not from DState.models but from idlookup[someid].models or so, the root arrays are handled above.\r\n                        console.log('delete() update subcollection '+ field, {dObj:{...dObj}, dDeleted:{...dDeleted}, field});\r\n                        SetFieldAction.new(dObj.id, field, deletedID, '-=', true);\r\n                        /*let oldList = [...dObj[field]];\r\n                        let newList = dObj[field].filter((id: Pointer) => id && id !== deletedID);\r\n                        lObj[field] = newList;*/\r\n                        break;\r\n\r\n                    case 'instanceof': // all elements being instance of a removed element are also removed\r\n                        lObj.delete();\r\n                        break;\r\n                    case 'model':\r\n                        // pkg.model --> deleted element should delete but i ignore because is already removed through children\r\n                        /*if (dObj.className === 'DPackage') {\r\n                            //?? lObj.father.model = lObj.father.__raw.model.filter((id: any) => id && id !== deletedID);\r\n                            break;\r\n                        } else {\r\n                            /* Node is deleted in nodes.delete() * /\r\n                            break;\r\n                        }*/\r\n                    case 'father': // obj.father -> deleted element. should be deleted but is already removed through deleted.children\r\n                        break;\r\n                }\r\n                /*\r\n                if ((root === 'idlookup') && obj && field) {\r\n                    console.log('Delete', `SetFieldAction.new('${obj}', '${field}', '${val}', '${op}');`, {dependency});\r\n                    SetFieldAction.new(obj, field, val, op, false);\r\n                } else {\r\n                    console.log('Delete', `SetRootFieldAction.new('${root}', '${val}', '${op}');`);\r\n                    SetRootFieldAction.new(root, val, op, false);\r\n                }\r\n                */\r\n            }\r\n\r\n            console.log('4 get_delete() '+(dDeleted as any)?.name, {dData: dDeleted, cn:dDeleted?.className});\r\n            if (lDeleted.nodes) lDeleted.nodes.map((node: any) => node.delete());\r\n            console.log('5 get_delete() '+(dDeleted as any)?.name, {dData: dDeleted, cn:dDeleted?.className});\r\n            SetRootFieldAction.new('ELEMENT_DELETED', deletedID, '+=', false); // here no need to IsPointer because it only affects Transient stuff\r\n            //U.sleep(1).then(() => SetRootFieldAction.new(`idlookup.${deletedID}`, undefined, '', false));\r\n            //SetRootFieldAction.new(`idlookup.${deletedID}`, undefined, '', false);\r\n            console.log('6 get_delete() '+(dDeleted as any)?.name, {dData: dDeleted, cn:dDeleted?.className});\r\n            DeleteElementAction.new(dDeleted.id);\r\n        };\r\n        //console.log('00 get_delete '+(dDeleted as any)?.name, {dData: dDeleted, cn:dDeleted?.className});\r\n        return () => {\r\n            //console.log('00 get_delete() '+(dDeleted as any)?.name, {dData: dDeleted, cn:dDeleted?.className});\r\n            TRANSACTION('delete ' + (thiss as any).get_name(context), ()=>{\r\n                // console.log('0000 get_delete '+(dDeleted as any)?.name, {dData: dDeleted, cn:dDeleted?.className});\r\n                ret();\r\n            })\r\n        }\r\n    }\r\n\r\n    private static dclass(c: any, thiss: any) {\r\n        let dDeleted = c.data as DClass;\r\n        let lDeleted = c.proxyObject as LClass;\r\n        for (let p of dDeleted.extends){\r\n\r\n        }\r\n        let replacementClasses: Pointer<DClass>[] = dDeleted.extends;\r\n        for (let p of dDeleted.extendedBy){\r\n            let l = L.fromPointer(p) as LClass;\r\n            if (!l) continue;\r\n            let newValues = l.__raw.extends;\r\n            for (let r of replacementClasses) U.ArrayAdd(newValues, r);\r\n            l.extends = newValues.filter((e) => e && e !== dDeleted.id) as any;\r\n        }\r\n    }\r\n}\r\n","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\data\\storage.ts",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\common\\SimpleTree.ts",["902"],"import {Dictionary, GObject, Log, U} from \"../joiner\";\r\n\r\n\r\n/* problema: se creo una key per ordinare l'albero e trovare \"of\" in O(log n), allora perdo l'ordinamento arbitrario di sottoalberi = sottoclassi a prescindere dai nomi.\r\n   potrei fare un dizionario di alberi, 1 albero per ogni dclass e lclass, con sottoelementi\r\n    */\r\n\r\n// not binary, not rb tree, not balanced, just a tree\r\n// it is N-ary\r\n// ma probabilmente non dovrei usare affatto un albero, ma fare un dizionario per ogni classe con cosa estende direttamente\r\n// e uno con cosa estende direttamente e indirettamente popolato automaticamente in n*logn una volta e fine\r\n// navigando superclass\r\n\r\n// B.superclass = [a1, a2] --- > a1.pushdirectsubclass(b), a2 same.  poi se a1 estende c, c.pushindirectsubclass(b)... e si risale da b finchè ci sono superclassi (logn) volte, fatto per tutte le n classi\r\n// each node have a \"node<T>\" value and a subtree with all subelements.\r\n// iterable with for...of with width iterator (not depth)\r\nexport class SimpleTree<T extends GObject> {\r\n    subelements: SimpleTree<T>[];\r\n    node: T; // can be undef, if root was an array instead of a single element.\r\n    // the nodes containing the rooots will be the childrens instead, as if they are N trees\r\n    // with a fake node joining them in a single one\r\n    // up: SimpleTree<T>; maybe do this too\r\n\r\n    [Symbol.iterator] = function*(this:SimpleTree<T>) {\r\n    // [Symbol.iterator]: Generator<number, string, boolean> = function*() {\r\n    // [Symbol.iterator]: Generator<number, string, boolean>= () => {\r\n    // [Symbol.iterator] () {\r\n        yield this;\r\n        let fifo = this.subelements;\r\n        while (fifo.length) {\r\n            let nextLevel = [];\r\n            for (let subtree of fifo) {\r\n                yield subtree;\r\n                nextLevel.push(...subtree.subelements);\r\n            }\r\n            //@ts-ignore\r\n            // console.log(\"fifo -> next level\", fifo.map(f=>f?.node?.cname), nextLevel.map(f=>f?.node?.cname));\r\n            fifo = nextLevel;\r\n        }\r\n    }\r\n\r\n    getiIsSubElementMatrix(namekey: keyof T): Dictionary<string, Dictionary<string, boolean>>{\r\n        let ret: Dictionary<string, Dictionary<string, boolean>> = {}// matrix name x name telling if A extends B\r\n        for (let o of this) { // O(N^2), but optimal for this task, as the matrix size is O(N^2) as well\r\n            let name = o.node[namekey];\r\n            if (!name) Log.ee(\"missing key property  in tree node: \", {tree: this, node:o.node, namekey});\r\n            ret[name] = {};\r\n            // if (o === this) continue;\r\n            for (let subo of o) {\r\n                let subname = subo.node[namekey];\r\n                if (!subname) { console.log(\"skipped\"); continue; }\r\n                ret[name as string][subname as string] = true;\r\n            }\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    public add(e: T, childKey?: keyof T, loopdetector?: WeakMap<T, boolean>): SimpleTree<T> | undefined{\r\n        if (loopdetector) {\r\n            if (loopdetector.get(e)) {\r\n                Log.eDev(e.cname.indexOf(\"GraphVertex\") !== 1,\r\n                    \"A constructor is extending 2 different classes, or there is a loop in Tree constructor parameter.\",\r\n                    \"GraphVertex should be the only class doing that currently\",\r\n                    {e, cname:e.cname, childKey, loopdetector});\r\n                return;\r\n            }\r\n            loopdetector.set(e, true);\r\n        }\r\n        let subtree =  new SimpleTree<T>(e, childKey, loopdetector);\r\n        this.subelements.push(subtree);\r\n        return subtree; }\r\n\r\n    getSubtree(e: T): SimpleTree<T> | undefined {\r\n        for (let t of this) { if (t.node == e) return t; }\r\n        return undefined; }\r\n\r\n    // childkey: adds subobjects found in \"roots\" parameters as nodes<T> in the tree\r\n    // comparison: tells if a node comes first or after another, example: (a, b) => a.name.toUpperCase() < b.name.toUpperCase()\r\n    constructor(roots: GObject | GObject[], childKey?: keyof T, loopdetector?: WeakMap<T, boolean>) {\r\n        // if arr, add N roots as subelements, and delegate actual subelements of the root to subtree constructors\r\n        if (!loopdetector) loopdetector = new WeakMap();\r\n        /*(this as any)[Symbol.iterator] = function *(){\r\n            yield this;\r\n            let fifo = this.subelements;\r\n            while (fifo.length) {\r\n                let nextLevel = [];\r\n                for (let subtree of fifo) {\r\n                    yield subtree;\r\n                    nextLevel.push(subtree);\r\n                }\r\n                fifo = nextLevel;\r\n            }\r\n        }*/\r\n\r\n        //@ts-ignore\r\n        this.debug = roots.cname;\r\n        this.subelements = [];\r\n        if (Array.isArray(roots)) {\r\n            this.node = undefined as any;\r\n            for (let e of roots) {\r\n                if (!e) continue;\r\n                this.add(e as T, childKey, loopdetector);\r\n            }\r\n        }\r\n        // if not arr, add immediate subelements of root\r\n        else {\r\n            this.node = roots as T;\r\n            if (!childKey) return;\r\n            let child: T | T[] = this.node[childKey];\r\n            if (Array.isArray(child)) {\r\n                for (let c of child) this.add(c, childKey, loopdetector);\r\n            }\r\n            else this.add(child, childKey, loopdetector);\r\n        }\r\n    }\r\n\r\n\r\n}\r\n","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\collaborative\\Collaborative.ts",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\DSL\\DSL.ts",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\iot\\IoT.ts",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\redux\\defaults\\views.ts",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\graph\\graphElement\\graphElement.tsx",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\forEndUser\\Input.tsx",["903","904","905"],"import React, {Dispatch, KeyboardEvent, LegacyRef, ReactElement, ReactNode, useRef} from 'react';\r\nimport {connect} from 'react-redux';\r\nimport {DState} from '../../redux/store';\r\nimport {\r\n    Any,\r\n    Defaults,\r\n    DObject,\r\n    DPointerTargetable,\r\n    GObject,\r\n    Keystrokes, LAttribute,\r\n    LClass, LEnumerator, LEnumLiteral, LModel, LObject,\r\n    LPointerTargetable, LReference, LStructuralFeature, LValue, MultiSelect, MultiSelectOptGroup,\r\n    MultiSelectOption,\r\n    Overlap,\r\n    Pointer, PrimitiveType, Selectors,\r\n    store,\r\n    U,\r\n    UX\r\n} from '../../joiner';\r\nimport {useStateIfMounted} from 'use-state-if-mounted';\r\nimport './inputselect.scss';\r\nimport { Tooltip } from './Tooltip';\r\n\r\nexport function getSelectOptions_raw(data: LPointerTargetable, field: string): MultiSelectOptGroup[] {\r\n    if (!data) return [];\r\n    switch (field){\r\n        default:\r\n        case 'extends':\r\n        case 'type':\r\n        case 'values': return (data as LValue | LStructuralFeature | LClass).validTargetOptions;\r\n    }\r\n    return [];\r\n}\r\n\r\nexport function getSelectOptions(data: LPointerTargetable, field: string, options: ReactNode, children?: ReactNode): ReactNode {\r\n    if (options) return options;\r\n    // children is auto-filled to empty array even if it is not set explicitly in jsx\r\n    if (Array.isArray(children) && children.length > 0) return children;\r\n    let ret: ReactNode | undefined;\r\n    switch (field) {\r\n        default:\r\n        case 'extends':\r\n        case 'type':\r\n        case 'values': return (data as LValue | LStructuralFeature | LClass).validTargetsJSX; break;\r\n    }\r\n    return ret;\r\n}\r\n    /*\r\n    export function getSelectOptions_raw(data: LPointerTargetable, field: string): MultiSelectOptGroup[] {\r\n        if (!data) return [];\r\n        // console.log(\"select options\", {data, field, children, options});\r\n        let returns: LClass[] | undefined;\r\n        let primitives: LClass[] | undefined;\r\n        let classes: LClass[] | undefined;\r\n        let enumerators: LEnumerator[] | undefined;\r\n        let objects: (LObject | LEnumLiteral)[] | undefined;\r\n        let m2classname: string | undefined;\r\n        let hasPrimitives: boolean = false;\r\n        let hasReturnTypes: boolean = false;\r\n        let cname = data.className;\r\n        if (!field) switch(cname) {\r\n            case 'DAttribute':  case 'DReference': case 'DOperation': case 'DParameter': field = 'type'; break;\r\n            case 'DValue': field = 'values'; break;\r\n            case 'DClass': field = 'extends'; break;\r\n        }\r\n    /*\r\n        let newmode = true;\r\n        if (newmode){\r\n            switch(field){\r\n                case 'extends': case 'type': return data.validTargetOptions;\r\n            }\r\n            return [];\r\n        }* /\r\n        switch(field) {\r\n            case 'type':\r\n                let model = (data as LStructuralFeature).model;\r\n                switch (cname) {\r\n                    default: break;\r\n                    case 'DAttribute': enumerators = model.enums; hasPrimitives = true; break;\r\n                    case 'DReference': classes = model.classes; break;\r\n                    case 'DOperation': classes = model.classes; enumerators = model.enums; hasPrimitives = hasReturnTypes = true; break;\r\n                    case 'DParameter': classes = model.classes; enumerators = model.enums; hasPrimitives = true; break;\r\n                }\r\n                break;\r\n            case 'value': case 'values':\r\n                if (cname !== 'DValue') break;\r\n                objects = (data as LValue).validTargets;\r\n                /*\r\n                let m2: LReference | LAttribute | undefined = (data as LValue).instanceof;\r\n                if (!m2) {\r\n                    objects = (data as LValue).model.allSubObjects;\r\n                    break;\r\n                }\r\n                let dm2 = m2.__raw;\r\n                if (dm2.className === \"DAttribute\") break;\r\n                let type: LClass = m2.type as LClass;\r\n                if (!type) break;\r\n                m2classname = type.name;\r\n                let m1modelid = data.model.id;\r\n                objects = (type.allInstances || []).filter( o => o.model.id === m1modelid);* /\r\n        }\r\n        let state: DState | undefined;\r\n        // todo: all this stuff might be better moved in mapstatetoprops, or the select list won't update properly.\r\n        if (hasPrimitives) {\r\n            if (!state) state = store.getState();\r\n            primitives = LPointerTargetable.fromPointer(state.primitiveTypes);\r\n        }\r\n        if (hasReturnTypes) {\r\n            if (!state) state = store.getState();\r\n            returns = LPointerTargetable.fromPointer(state.returnTypes);\r\n        }\r\n\r\n        // console.log(\"select options\", {data, field, returns, primitives, classes, enumerators});\r\n\r\n        let ret:MultiSelectOptGroup[] = [];\r\n        if (returns && returns.length) ret.push({label: 'Defaults', options: returns.map((r, i)=>({value: r.id, label:r.name}))});\r\n        if (primitives && primitives.length) ret.push({label: 'Primitives', options: primitives.map((r, i)=>({value: r.id, label:r.name}))});\r\n        if (enumerators && enumerators.length) ret.push({label: 'Enumerators', options: enumerators.map((r, i)=>({value: r.id, label:r.name}))});\r\n        if (classes && classes.length) ret.push({label: 'Classes#', options: classes.map((r, i)=>({value: r.id, label:r.name}))});\r\n        if (objects && objects.length) ret.push({label: m2classname ? 'Instances of ' + m2classname : \"All objects\", options:\r\n                [{value: undefined as any, label: '_empty_'}, ...objects.map((r, i)=>({value: r.id, label:r.name}))]});\r\n        return ret;\r\n    }\r\n    export function getSelectOptions(data: LPointerTargetable, field: string, options: ReactNode, children?: ReactNode): ReactNode {\r\n        if (options) return options;\r\n        // children is auto-filled to empty array even if it is not set explicitly in jsx\r\n        if (Array.isArray(children) && children.length > 0) return children;\r\n        let ret: ReactNode | undefined;\r\n        let newmode = true;\r\n        if (newmode){\r\n            switch(field){\r\n                case 'extends': case 'type': ret = (data as any).validTargetJSX; break;\r\n            }\r\n            console.log('msel ret opt', {ret, data, vt: (data as any).validTargetJSX, field})\r\n        }\r\n        if (ret) return ret;\r\n        let opts = getSelectOptions_raw(data, field); // old to remove?\r\n        return UX.options(opts); // selectOptionsToJSX(opts);\r\n    }\r\n    function selectOptionsToJSX(ret: MultiSelectOptGroup[]): ReactNode{\r\n        return(\r\n            <>{\r\n                ret.map(optgrp => <optgroup label={optgrp.label}>{\r\n                    optgrp.options.map((e, i) => <option key={i} value={e.value}>{e.label}</option>)\r\n                }</optgroup>).filter(e=>!!e)\r\n            }</>);\r\n    }*/\r\n\r\nexport function InputComponent(props: AllProps) {\r\n    const data = props.data;\r\n    const getter = props.getter;\r\n    const setter = props.setter;\r\n    const field: string = props.field as string;\r\n    const oldValue: PrimitiveType | PrimitiveType[] | LPointerTargetable = (getter) ? getter(data, field) : (data ? data[field] : undefined); // !== undefined); ? data[field] : 'undefined'\r\n    let [value, setValue] = useStateIfMounted<PrimitiveType | PrimitiveType[] | LPointerTargetable>(oldValue);\r\n\r\n    const [isTouched, setIsTouched] = useStateIfMounted(false);\r\n    const inputRef = useRef<Element | null>(null);\r\n    if (props.tag === 'select') value = oldValue; // select does not use state.\r\n    let serializeValue = (val: LPointerTargetable | PrimitiveType | PrimitiveType[], maxDepth=1, currDepth = 0): string | PrimitiveType | PrimitiveType[] => {\r\n        if (Array.isArray(val)) {\r\n            if (props.isMultiSelect && currDepth < maxDepth) {\r\n                // return val.map(e => serializeValue(e, maxDepth, currDepth + 1)) as PrimitiveType[];\r\n                return val.map(e => (e as any)?.id||e) as PrimitiveType[];\r\n            }\r\n            if (currDepth < maxDepth) return serializeValue(val[0], maxDepth, currDepth + 1);\r\n            else return undefined;\r\n        }\r\n        return (val as LPointerTargetable)?.id || (val as any);\r\n    };\r\n\r\n    function valueDidChange(v1: any, v2: any): boolean {\r\n\r\n        return serializeValue(v1) !== serializeValue(v2);\r\n        /*\r\n        let rawv1 = v1?.__raw || v1;\r\n        let rawv2 = v2?.__raw || v2;\r\n        if (rawv1 !== v1 || rawv2 !== v2) { return v1?.clonedCounter !== v2?.clonedCounter; }\r\n        return v1 !== v2;*/\r\n    }\r\n\r\n    // I check if the value that I have in my local state is being edited by other <Input />\r\n    if (props.tag !== 'select' && !isTouched && valueDidChange(value, oldValue)){\r\n        setValue(serializeValue(oldValue));\r\n        setIsTouched(false);\r\n    }\r\n\r\n\r\n    if (!((data && field) || (getter && setter))) return(<>Either props.data & field or both getter & setter are required.</>);\r\n    let readOnly: boolean;\r\n    if (props.readOnly !== undefined) readOnly = props.readOnly;\r\n    // else if (props.disabled !== undefined) readOnly = props.disabled;\r\n    else readOnly = props.debugmodee !== 'true' && Defaults.check(data?.id)\r\n\r\n    let type = (props.type) ? props.type : 'text';\r\n    let subtype: string = type;\r\n    switch (type) {\r\n        case 'toggle': type = 'checkbox'; subtype = 'switch'; break;\r\n        case 'checkbox3': case 'switch': type = 'checkbox'; break;\r\n        case 'slider': type = 'range'; break;\r\n    }\r\n    let label: ReactNode | undefined = props.jsxLabel || props.label;\r\n    let postlabel: ReactNode | undefined = props.postlabel;\r\n    let tooltip: ReactNode|string|undefined = ((props.tooltip === true) ? data?.['__info_of__' + field]?.txt : props.tooltip) || '';\r\n\r\n    let css = '';//'my-auto input ';\r\n    //css += (jsxLabel) ? 'ms-1' : (label) ? 'ms-auto' : '';\r\n    css += (props.hidden) ? ' hidden-input' : '';\r\n    let autosize: boolean = props.autosize === undefined ? false : props.autosize; // props.type==='text'\r\n    css += autosize ? ' autosize-input' : '';\r\n    const isBoolean = (['checkbox', 'radio'].includes(type));\r\n\r\n\r\n    const onDoubleClick = (evt: React.MouseEvent<HTMLInputElement>) => { // fully select the text\r\n        evt.preventDefault();\r\n        evt.stopPropagation();\r\n        console.warn('input dblclick', {t:evt.target, evt}); //, ets:(evt.target as HTMLInputElement).select()};\r\n        (evt.target as HTMLInputElement).select();\r\n    }\r\n    const onChange = (evt: React.ChangeEvent<HTMLInputElement>) => {\r\n        (props as any).onChange?.(evt);\r\n        if (readOnly) return;\r\n\r\n        if (isBoolean) {\r\n            let target = evt.target.checked;\r\n            if (subtype === 'checkbox3' && !value) { target = undefined as any; }\r\n            if (setter) setter(target, data, field);\r\n            else data[field] = target;\r\n            setValue(target);\r\n            return;\r\n        }\r\n        if (props.tag === \"select\") {\r\n            confirmValue(evt as any);\r\n        } else {\r\n            //console.log(\"setValue\", {value, nv: getValueFromEvent(evt), evt, ev: evt.target.value});\r\n            setValue(getValueFromEvent(evt));\r\n            setIsTouched(true);     // I'm editing the element in my local state.\r\n            // the actual set is done in onBlur\r\n        }\r\n\r\n\r\n    }\r\n    const onKeyDown = (evt: React.KeyboardEvent<HTMLInputElement>) => {\r\n        (props as any).onKeyDown?.(evt);\r\n        if (props.tag === 'select') return;\r\n        if (evt.key === Keystrokes.enter) confirmValue(evt as any);\r\n        if (evt.key === Keystrokes.escape) {\r\n            const oldValue = getter ? getter(data, field) : data[field];\r\n            writeHtmlValueFromEvent(evt as any, oldValue);\r\n            setValue(serializeValue(oldValue));\r\n            setIsTouched(false);\r\n            (evt.target as HTMLInputElement).blur();\r\n            // to optimize: probably can remove a large part of this function because this should trigger blur event as well. or move \"change\" event contents here\r\n            // optimize 2: memoize the whole component, so it won't update unless the displayed value changed. this would also fix cursor going to input end when pressing enter.\r\n        }\r\n    }\r\n    const getValueFromEvent = (evt: { target: HTMLInputElement | HTMLSelectElement | HTMLTextAreaElement }) => {\r\n        switch (props.tag){\r\n            case \"textarea\": case \"input\": case \"select\": case \"\": case null: case undefined: return evt.target.value;\r\n            default: return evt.target.innerText;\r\n        }\r\n    }\r\n    const writeHtmlValueFromEvent = (evt: { target: HTMLInputElement | HTMLSelectElement | HTMLTextAreaElement }, value: any) => {\r\n        value = serializeValue(value);\r\n        switch (props.tag){\r\n            case \"textarea\": case \"input\": case \"select\": case \"\": case null: case undefined: return evt.target.value = value;\r\n            default: return evt.target.innerText = value;\r\n        }\r\n    }\r\n\r\n    const onBlur = (evt: { target: HTMLInputElement | HTMLSelectElement | HTMLTextAreaElement }) => {\r\n        (props as any).onBlur?.(evt);\r\n        if (props.tag === 'select') return;\r\n        confirmValue(evt);\r\n    }\r\n    const confirmValue = (evt: { target: HTMLInputElement | HTMLSelectElement | HTMLTextAreaElement }|undefined, val?: PrimitiveType|PrimitiveType[]) => {\r\n        if (readOnly || isBoolean) return;\r\n        const newValue = val || (evt && getValueFromEvent(evt));\r\n        const oldValue = getter ? getter(data, field) : data[field];\r\n        console.log(\"onChange confirm\", {evt, newValue, oldValue, data, field, changed: valueDidChange(newValue, oldValue), readOnly, isBoolean, setter, nnv:serializeValue(newValue)});\r\n        if (valueDidChange(newValue, oldValue)){\r\n            if (setter) setter(newValue as any, data, field);\r\n            else data[field] = serializeValue(newValue);\r\n        }\r\n        // I terminate my editing, so I communicate it to other <Input /> that render the same field.\r\n        setIsTouched(false);\r\n    }\r\n\r\n    const otherprops: GObject = {...props};\r\n    delete otherprops.data;\r\n    delete otherprops.field;\r\n    delete otherprops.getter;\r\n    delete otherprops.setter;\r\n    delete otherprops.label;\r\n    delete otherprops.postlabel;\r\n    delete otherprops.jsxLabel;\r\n    delete otherprops.tooltip;\r\n    delete otherprops.hidden;\r\n    delete otherprops.inputStyle;\r\n    delete otherprops.children;\r\n    delete otherprops.autosize; // because react complains is bool in dom attribute or unknown attrib name\r\n\r\n    let checked: boolean | undefined = undefined;\r\n    if (isBoolean) checked = typeof value === \"boolean\" ? value : (typeof value === \"string\" ? U.fromBoolString(value) : !!value);\r\n\r\n    let cursor: string;\r\n    if (tooltip) cursor = 'help';\r\n    else if (readOnly) cursor = 'not-allowed';\r\n    else if (isBoolean) cursor = 'pointer';\r\n    else cursor = 'auto';\r\n\r\n    let inputProps: GObject = {...otherprops,\r\n        className: [props.inputClassName||'', css].join(' '),\r\n        style: (props.inputStyle || {}),\r\n        spellCheck: (props as any).spellCkeck || false, readOnly, disabled: readOnly, type,\r\n        value: serializeValue(value),\r\n        checked,\r\n        onDoubleClick,\r\n        onChange, onBlur, onKeyDown} // key:`${field}.${data?.id}`\r\n    if (!inputProps.style.cursor) { inputProps.style.cursor = cursor; }\r\n    switch(subtype){\r\n        case 'checkbox3': case 'switch': case 'slider': inputProps.className += ' ' + subtype + (oldValue===undefined?'undetermined':''); break;\r\n        default: break;\r\n    }\r\n\r\n    let input: ReactNode;\r\n    let rootprops: GObject = {className: otherprops.className||'', style: otherprops.style||{}};\r\n    switch (typeof rootprops.ref) {\r\n        default: rootprops.ref = inputRef; break;\r\n        case \"object\":\r\n            let oldref = rootprops.ref;\r\n            rootprops.ref = (v: Element | null) => { oldref.current = inputRef.current = v; }\r\n            break;\r\n        case \"function\":\r\n            let oldreff = rootprops.ref;\r\n            rootprops.ref = (v: Element | null) => { oldreff(v); inputRef.current = v; }\r\n            break;\r\n    }\r\n    if (props.autosize) rootprops['data-value'] = inputProps.value;\r\n\r\n    if (tooltip) {\r\n        rootprops.onMouseEnter = () => Tooltip.show(tooltip, 'b', (rootprops.ref?.current) || rootprops.ref);\r\n        rootprops.onMouseLeave = () => Tooltip.hide();\r\n    }\r\n    /*let rootkeys = new Set(...Object.keys(rootprops));\r\n    //  merge events: might want to distinguish which events are merged between root and input and which not.\r\n    //  onChange surely needs merge. onMouseHover might not to let it trigger on label too.\r\n    for (let k of rootkeys) {\r\n        if (!(k[0] === 'o' && k[1] === 'n' && k[2] && k[2].toUpperCase() === k[2])) continue;\r\n        if (inputProps[k]) inputProps[k] = function(...a:any) { inputProps[k](arguments); rootprops[k](arguments); }\r\n        else inputProps[k] = rootprops[k];\r\n        delete rootprops[k];\r\n    }*/\r\n\r\n    let wrap = true;\r\n    if (autosize) rootprops.className = (rootprops.className || '') + ' autosize-input-container';\r\n    else if (!label && !postlabel && !props.isMultiSelect) {\r\n        if (rootprops.className) inputProps.className = rootprops.className + ' ' + inputProps.className;\r\n        if (rootprops.style) U.objectMergeInPlace(inputProps.style, rootprops.style);\r\n        inputProps = {...rootprops, ...inputProps};\r\n        wrap = false;\r\n    }\r\n\r\n    switch (props.tag){\r\n        case \"textarea\": input = <textarea {...inputProps}>{inputProps.value}</textarea>; break;\r\n        case \"select\":\r\n            if (props.isMultiSelect){\r\n                let options = props.options as any || getSelectOptions_raw(data, field);\r\n                let multiOptions = options as MultiSelectOptGroup[];\r\n                console.log('setting multiselect pre', {multiOptions, value, ivalue: inputProps.value, options, data, df:data[field], field});\r\n                let valuesMap = U.objectFromArrayValues((inputProps.value||[]));\r\n                delete valuesMap[undefined as any];\r\n                inputProps.value = [];\r\n                for (let optgrp of multiOptions) for (let opt of optgrp.options) if (valuesMap[opt.value]) inputProps.value.push(opt);\r\n                // rootprops.className = (rootprops.className || '') + ' clearfix';\r\n                let old = {...rootprops};\r\n                rootprops.onMouseMove = (e:any) => { UX.stopEvt(e); old.onMouseMove?.(); console.log('multiselect onmove'); };\r\n                /*rootprops.onMouseDown = (e:any) => { UX.stopEvt(e); old.onMouseDown?.(); console.log('multiselect onMouseDown'); };\r\n                rootprops.onMouseUp = (e:any) => { UX.stopEvt(e); old.onMouseUp?.(); console.log('multiselect onMouseUp'); };\r\n                rootprops.onClick = (e:any) => { UX.stopEvt(e); old.onClick?.(); console.log('multiselect onClick'); };\r\n                rootprops.onMouseLeave = (e:any) => { UX.stopEvt(e); old.onMouseLeave?.(); console.log('multiselect onMouseLeave'); };*/\r\n                // @ts-ignore\r\n                input = <MultiSelect {...inputProps} isMulti={true} options={options}\r\n                    onChange={((v0: MultiSelectOption[]) => {\r\n                        let v = v0.map(v => v.value);\r\n                        confirmValue(undefined, v);\r\n                        console.log('setting multiselect onchange', {v, v0, value, ivalue: inputProps.value, options});\r\n                    }) as any}\r\n                />;\r\n            }\r\n            else {\r\n                let options = getSelectOptions(data, field, props.options, props.children);\r\n                input = <select {...inputProps}>{options}</select>;\r\n            }\r\n            break;\r\n        case null: case undefined: case \"\": case \"input\": input = <input {...inputProps} />; break;\r\n        default:\r\n            inputProps.contentEditable = inputProps.contentEditable !== false;\r\n            input = React.createElement(props.tag, inputProps, props.children); break;\r\n    }\r\n    if (!wrap) return input;\r\n\r\n    if (typeof label === \"string\") label = <span>{label}</span>;\r\n    if (typeof postlabel === \"string\") postlabel = <span>{postlabel}</span>;\r\n\r\n    const openSelect = (e: any)=>{\r\n        /*\r\n        tried to make label click open the select but does not work easily in js, a solution was here but with css padding.\r\n        https://stackoverflow.com/questions/15249958/once-i-click-on-label-select-button-should-get-open\r\n        */\r\n        if (props.tag !== \"select\") return;\r\n        let t: HTMLElement = (e.target) as any;\r\n        let select = (t.tagName === 'select') ? t : t.querySelector('select');\r\n        console.log(\"click select root\", {t, select});\r\n        select?.click();\r\n    }\r\n    return <label className={'input-container'} {...rootprops} /*onClick={openSelect}*/>\r\n        {label || undefined}{input}{postlabel || undefined}</label>;\r\n    /*\r\n    return(<label className={'p-1'} {...otherprops}\r\n                  style={rootStyle}>\r\n\r\n        {label && <span className={'my-auto'} onMouseEnter={e => setShowTooltip(true)}\r\n                        onMouseLeave={e => setShowTooltip(false)}>{label}\r\n        </span>}\r\n\r\n        {jsxLabel && <span onMouseEnter={e => setShowTooltip(true)}\r\n                           onMouseLeave={e => setShowTooltip(false)} style={{width: '100%'}}>{jsxLabel}\r\n        </span>}\r\n\r\n        {(tooltip && showTooltip) && <div className={'my-tooltip'}>\r\n            <b className={'text-center text-capitalize'}>{field}</b>\r\n            <br />\r\n            <label>{tooltip}</label>\r\n        </div>}\r\n\r\n        {autosize ? <div className={(autosize ? 'autosize-input-container' : '') + (props.asLabel ? ' labelstyle' : '')}\r\n                         data-value={value}>{input}\r\n        </div> : input}\r\n    </label>);\r\n    */\r\n}\r\n\r\nexport interface InputOwnProps {\r\n    data?: LPointerTargetable | DPointerTargetable | Pointer<DPointerTargetable, 1, 1, LPointerTargetable>;\r\n    field?: string;\r\n    // DANGER: use the data provided in parameters instead of using js closure, as the proxy accessed from using closure won't be updated in rerenders.\r\n    getter?: (data: any/*LPointerTargetable*/, field: string) => string | boolean | undefined;\r\n    setter?: (value: string|boolean, data: any, field: string) => void;\r\n    label?: string | ReactNode;\r\n    postlabel?: string | ReactNode;\r\n    jsxLabel?: ReactNode; // @deprecated, use label\r\n    type?: 'checkbox'|'color'|'date'|'datetime-local'|'email'|'file'|'image'|'month'|'number'|'password'\r\n        |'radio'|'range'|'tel'|'text'|'time'|'url'|'week'\r\n        |'checkbox3'|'toggle'|'switch'|'slider';\r\n    className?: string;\r\n    style?: GObject;\r\n    readOnly?: boolean;\r\n    tooltip?: boolean | ReactNode;\r\n    hidden?: boolean;\r\n    autosize?: boolean;\r\n    inputClassName?: string;\r\n    inputStyle?: GObject;\r\n    key?: React.Key | null;\r\n    placeholder?: string;\r\n    tag?: string;\r\n    children?: ReactNode;\r\n}\r\n\r\nexport interface SelectOwnProps extends Omit<InputOwnProps, 'setter'> {\r\n    options?: JSX.Element;\r\n    setter?: (value: string/*|PrimitiveType[]*/, data: any, field: string) => void; // parent select has value: string | boolean\r\n    isMultiSelect?: boolean;\r\n}\r\ninterface RealOwnProps extends Omit<SelectOwnProps, 'setter'>{\r\n    setter: InputOwnProps['setter'];\r\n}\r\n\r\ninterface StateProps {\r\n    debugmodee: string;\r\n    data: LPointerTargetable & GObject;\r\n    // selected: Dictionary<Pointer<DUser>, LModelElement | null>;\r\n}\r\ninterface DispatchProps { }\r\ntype AllProps = Overlap<RealOwnProps, Overlap<StateProps, DispatchProps>>;\r\n\r\n\r\nexport function InputMapStateToProps(state: DState, ownProps: RealOwnProps): StateProps {\r\n    const ret: StateProps = {} as any;\r\n    const pointer: Pointer | undefined = typeof ownProps.data === 'string' ? ownProps.data : ownProps.data?.id;\r\n    ret.debugmodee = state.debug ? 'true' : 'false';\r\n    if (pointer) ret.data = LPointerTargetable.fromPointer(pointer);\r\n    return ret;\r\n}\r\n\r\nfunction mapDispatchToProps(dispatch: Dispatch<any>): DispatchProps {\r\n    const ret: DispatchProps = {};\r\n    return ret;\r\n}\r\n\r\nexport const InputConnected =\r\n    // @ts-ignore\r\n    connect<StateProps, DispatchProps, RealOwnProps, DState>(InputMapStateToProps, mapDispatchToProps)(InputComponent);\r\n\r\n\r\n// export function Input(props: InputOwnProps, children: (string | React.Component)[] = []): ReactElement { return 'input' as any; }\r\nexport function Input(props: InputOwnProps): ReactElement {\r\n    // @ts-ignore\r\n    return <InputConnected {...props as any}>{props.children}</InputConnected>;\r\n}\r\n\r\n// export function TextArea(props: InputOwnProps, children: (string | React.Component)[] = []): ReactElement { return 'textarea' as any; }\r\nexport function TextArea(props: InputOwnProps, c: any): ReactElement {\r\n    // @ts-ignore\r\n    return <InputConnected {...{...props, tag:\"textarea\"} as any}>{props.children||c}</InputConnected>;\r\n}\r\n//export function Select(props: SelectOwnProps, children: (string | React.Component)[] = []): ReactElement { return 'select' as any; }\r\nexport function Select(props: SelectOwnProps, c: any): ReactElement {\r\n    // @ts-ignore\r\n    return <InputConnected {...{...props, tag:\"select\"} as any}>{props.children||c}</InputConnected>;\r\n}\r\nexport const Edit = Input;\r\n\r\n// @ts-ignore\r\nInputComponent.cname = 'InputComponent';\r\n// @ts-ignore\r\nInputConnected.cname = 'InputConnected';\r\nInput.cname = 'Input';\r\nTextArea.cname = 'TextArea';\r\nSelect.cname = 'Select';\r\nEdit.cname = 'Edit';\r\n","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\forEndUser\\Selector.tsx",["906","907","908","909"],"import {DPointerTargetable, LClass, LModel, Defaults, U, Input} from '../../joiner';\r\nimport {DState, GObject, LEnumerator, LPointerTargetable, Overlap, Pointer} from '../../joiner';\r\nimport React, {Dispatch, LegacyRef, ReactElement, ReactNode} from 'react';\r\nimport {connect} from 'react-redux';\r\nimport {useStateIfMounted} from 'use-state-if-mounted';\r\nimport './inputselect.scss';\r\n\r\n\r\nfunction SelectorComponent(props: AllProps) {\r\n    const data = props.data;\r\n    const [showTooltip, setShowTooltip] = useStateIfMounted(false);\r\n    if (!data) return(<></>);\r\n    let d: DPointerTargetable = data.__raw || data;\r\n    let l: LPointerTargetable = LPointerTargetable.fromD(data);\r\n    let gdata: GObject<LPointerTargetable> = data;\r\n    const field: (keyof LPointerTargetable & keyof DPointerTargetable) = props.field as any;\r\n    const readOnly = props.readonly !== undefined ? props.readonly : !props.debugmode && Defaults.check(data.id);\r\n    const value: string | Pointer = d[field] as string;\r\n    const label: string|undefined = props.label;\r\n    const jsxLabel: ReactNode|undefined = props.jsxLabel;\r\n    let tooltip: string|undefined = (props.tooltip === true) ? ((gdata['__info_of__' + field]) ? gdata['__info_of__' + field].txt: '') : props.tooltip;\r\n    tooltip = tooltip || '';\r\n    let css = '';//'my-auto select ';\r\n   // css += (jsxLabel) ? 'ms-1' : 'ms-auto';\r\n    css += (props.hidden) ? ' hidden-input' : '';\r\n\r\n    \r\n    /* @ts-ignore */\r\n    const setter = (id) => {l[field].value=id} \r\n    \r\n    /* @ts-ignore */\r\n\r\n    const getter = () => l[field].value;//l.$type.__raw.values[0];\r\n    \r\n\r\n    function SelectorChange(evt: React.ChangeEvent<HTMLSelectElement>) {\r\n        if (readOnly) return;\r\n\r\n        \r\n        const newValue = evt.target.value; \r\n        const oldValue = getter(); \r\n        setter(newValue);\r\n    }\r\n\r\n    // \r\n\r\n    function getOptions(): any {\r\n\r\n\r\n        {/*@ts-ignore*/}\r\n        switch (l[field].type.className) {\r\n            case 'DClass':\r\n                return (<>\r\n\r\n                    {/*@ts-ignore*/}\r\n                    {l[field].type.allInstances.map(cl =><>\r\n                        {/*@ts-ignore*/}\r\n                        {typeof(l[field].value) === 'undefined' ? \r\n                            <option value={cl.id}>{cl.name}</option> \r\n                            :\r\n                            <>\r\n                                {/*@ts-ignore*/}\r\n                                {l[field].value.id === cl.id ?\r\n                                <option value={cl.id} selected>{cl.name}</option> \r\n                                :\r\n                                <option value={cl.id}>{cl.name}</option>  \r\n                            }\r\n                            </>\r\n                        }\r\n        \r\n                    </>)}\r\n                </>); \r\n            break;\r\n            case 'DEnumerator':\r\n                \r\n                return (<>\r\n                    <option value=\"\" disabled selected>Select your option</option>\r\n                    {/*@ts-ignore*/}\r\n                    {l[field].type.literals.map(lit =><>\r\n                        \r\n                        {/*@ts-ignore*/}\r\n                        {typeof(l[field].value) === 'undefined' ? \r\n                            \r\n                            <option value={lit.id}>{lit.name}</option>\r\n                            :\r\n                            <>\r\n                                {/*@ts-ignore*/}\r\n                                {l[field].value.name === lit.name ?\r\n                                    <option value={lit.id} selected>{lit.name}</option> \r\n                                    :\r\n                                    <option value={lit.id}>{lit.name}</option>  \r\n                                }\r\n                            </>\r\n                        }\r\n        \r\n                    </>)}\r\n                </>);\r\n            break;\r\n            default:\r\n                return (U.alert('e', 'Unsupported type','Selector Component'));\r\n            break;\r\n\r\n        }\r\n\r\n\r\n\r\n        \r\n    }\r\n\r\n    const otherprops: GObject = {...props};\r\n    delete otherprops.data;\r\n    delete otherprops.getter;\r\n    delete otherprops.setter;\r\n    delete otherprops.jsxLabel;\r\n    delete otherprops.primitives;\r\n    delete otherprops.returns;\r\n    delete otherprops.hidden;\r\n    let cursor: string;\r\n    if (tooltip) cursor = 'help';\r\n    else if (readOnly) cursor = 'not-allowed';\r\n    else cursor = 'pointer';\r\n    let inputStyle = props.inputStyle || {};\r\n    if (!inputStyle.cursor && cursor === 'not-allowed') { inputStyle.cursor = cursor; }\r\n    U.objectMergeInPlace(inputStyle, props.inputStyle || {}, props.style || {});\r\n    let className = [props.className, props.inputClassName, css].join(' ');\r\n\r\n    let get_options = getOptions();\r\n\r\n    let select = (<select {...otherprops} className={className + ' model-select'} disabled={readOnly} placeholder={'-----'}\r\n            style={props.inputStyle}\r\n            value={value}\r\n            onChange={SelectorChange}>\r\n                {get_options ? get_options : U.alert('e', 'Error in Selector component', 'Something went wrong ...')}\r\n    </select>);\r\n\r\n\r\n    return select;\r\n}\r\n\r\nSelectorComponent.cname = 'SelectorComponent';\r\nexport interface SelectorOwnProps {\r\n    data?: DPointerTargetable | Pointer<DPointerTargetable, 1, 1, LPointerTargetable>;\r\n    field: string;\r\n    label?: string;\r\n    jsxLabel?: ReactNode;\r\n    tooltip?: boolean|string;\r\n    hidden?: boolean;\r\n    options?: JSX.Element;\r\n    key?: React.Key | null;\r\n    className?: string;\r\n    style?: GObject;\r\n    ref?: React.RefObject<HTMLElement> | LegacyRef<HTMLElement>;\r\n    readonly?: boolean;\r\n    inputClassName?: string;\r\n    inputStyle?: GObject;\r\n    // DANGER: use the data provided in parameters instead of using js closure, as the proxy accessed from using closure won't be updated in rerenders.\r\n    my_getter?: <T extends DPointerTargetable = any>(data: any | T | Pointer<T>, field: (string | number | symbol) | keyof T) => string;\r\n    // setter?: <T extends DPointerTargetable = any>(data: T | Pointer<T>, field: keyof T, selectedValue: string) => void;\r\n    // setter?: <T extends DPointerTargetable = any>(data: any | T | Pointer<T>, field: (string | number | symbol) | keyof T, selectedValue: string) => void;\r\n    my_setter?: (data: any, field: string, selectedValue: string) => void;\r\n\r\n}\r\ninterface StateProps {\r\n    debugmode: boolean,\r\n    data: LPointerTargetable;\r\n    primitives: LClass[];\r\n    returns: LClass[]; }\r\ninterface DispatchProps { }\r\n\r\ntype AllProps = Overlap<SelectorOwnProps, Overlap<StateProps, DispatchProps>>;\r\n\r\n\r\nfunction mapStateToProps(state: DState, ownProps: SelectorOwnProps): StateProps {\r\n    const ret: StateProps = {} as any;\r\n    if (!ownProps.data) return ret;\r\n    const pointer: Pointer = typeof ownProps.data === 'string' ? ownProps.data : ownProps.data.id;\r\n    ret.debugmode = state.debug;\r\n    ret.data = LPointerTargetable.fromPointer(pointer);\r\n    ret.primitives = LPointerTargetable.fromPointer(state.primitiveTypes);\r\n    ret.returns = LPointerTargetable.fromPointer(state.returnTypes);\r\n    return ret;\r\n}\r\n\r\nfunction mapDispatchToProps(dispatch: Dispatch<any>): DispatchProps {\r\n    const ret: DispatchProps = {};\r\n    return ret;\r\n}\r\n\r\n\r\nexport const SelectorConnected = connect<StateProps, DispatchProps, SelectorOwnProps, DState>(\r\n    mapStateToProps,\r\n    mapDispatchToProps\r\n)(SelectorComponent);\r\n\r\nexport const Selector = (props: SelectorOwnProps, children: (string | React.Component)[] = []): ReactElement => {\r\n    return <SelectorConnected {...{...props, children}} />;\r\n}\r\n\r\n\r\nSelectorComponent.cname = 'SelectorComponent';\r\nSelectorConnected.cname = 'SelectorConnected';\r\nSelector.cname = 'Selector';\r\nexport default Selector;\r\n","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\pages\\Account.tsx",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\pages\\AllProjects.tsx",["910","911","912","913"],"/* DASHBOARD */\r\n/* ALLPROJECTS */\r\n\r\nimport React, {ChangeEvent, MouseEventHandler, Component, Dispatch, ReactElement, useState, useRef } from 'react';\r\nimport {connect} from 'react-redux';\r\nimport {DProject, DState, Log, LProject, SetRootFieldAction, Try, U} from '../joiner';\r\nimport {Dictionary, FakeStateProps} from '../joiner/types';\r\nimport {Dashboard, Project} from './components';\r\nimport Storage from \"../data/storage\";\r\n\r\nimport { Cards, Card } from './components/cards/Cards';\r\nimport { Catalog } from './components/catalog/Catalog';\r\n\r\nimport {ProjectsApi} from \"../api/persistance\";\r\nimport { LatestUpdates } from './components/LatestUpdates';\r\n\r\nfunction AllProjectsComponent(props: AllProps): JSX.Element {\r\n    const {projects} = props;\r\n    const [isDropping, setDropping] = useState(false);\r\n    const createProject = async(type: DProject['type']) => {\r\n        await ProjectsApi.create(type, undefined, undefined, undefined, projects);\r\n    }\r\n    function dropConfirm(e: React.DragEvent<HTMLElement>){\r\n        e.preventDefault();\r\n        e.stopPropagation();\r\n        console.log('dropevent', {e});\r\n\r\n        const droppedFiles = Array.from(e.dataTransfer.files);\r\n        if (droppedFiles.length > 0) {\r\n            for (let file of droppedFiles){\r\n            var reader = new FileReader();\r\n            reader.onload = function(e) {\r\n                if (!e.target) { Log.ee('invalid file', e); return; }\r\n                var contents = e.target.result;\r\n                console.log('read file', {contents, e, file});\r\n                let date: number = file.lastModified;\r\n                let name = file.name; // including extension\r\n                if (typeof contents === 'string') ProjectsApi.importFromText(contents, name, date);\r\n                else Log.ee('invalid file content', {e, contents});\r\n            };\r\n            reader.readAsText(file);\r\n            }\r\n        }\r\n        //let file = e.dataTransfer.getData('file');\r\n        setDropping(false);\r\n    }\r\n    function mouseleave(e: any){ // should use onDragLeave but it is flashing\r\n        setDropping(false);\r\n    }\r\n    function dropPreview(e: React.DragEvent<any>){\r\n        e.stopPropagation();\r\n        e.preventDefault();\r\n        setDropping(true);\r\n        e.dataTransfer.dropEffect = 'copy';\r\n    }\r\n    return(<Try>\r\n        <>\r\n        <Dashboard active={'All'} version={props.version}>\r\n            <div className={'droparea'} onDrop={dropConfirm} onDragOver={dropPreview} onMouseLeave={mouseleave}>\r\n                <div style={{opacity: isDropping ? 0.5 : 1}}>\r\n                <Cards>\r\n                    <Cards.Item\r\n                        title={'New Jjodel'}\r\n                        subtitle={'Create a new Jjodel project.'}\r\n                        icon={'add'}\r\n                        style={'green'}\r\n                        action={() => createProject('private')}\r\n                    />\r\n                    {!(U.isOffline()) && <Cards.Item\r\n                        title={'New Jjodel (Collaborative)'}\r\n                        subtitle={'Create a new Jjodel project.'}\r\n                        icon={'add'}\r\n                        style={'yellow'}\r\n                        action={() => createProject('collaborative')}\r\n                    />}\r\n                    <Cards.Item\r\n                        title={'Import Jjodel'}\r\n                        subtitle={'Import an existing Jjodel project.'}\r\n                        icon={'import'}\r\n                        style={'dark'}\r\n                        action={ProjectsApi.import}\r\n                    />\r\n                    {true && <Cards.Item icon={'gettingstarted'} url={'https://www.jjodel.io/getting-started/'} style={'red-orange'} title={'Getting Started'} subtitle={'New to Jjodel? No worries'}/>}\r\n                </Cards>\r\n                <Catalog projects={projects} />\r\n            </div>\r\n                {isDropping ? <div style={{\r\n                    position: 'absolute',\r\n                    left: '50%',\r\n                    marginLeft: '-50px',\r\n                    top: '50%',\r\n                    marginTop: '-50px',}}>Drop the file to import a .jJodel project</div> : null}\r\n            </div>\r\n        </Dashboard>\r\n        <LatestUpdates page={'AllProjects'}/>\r\n        </>\r\n\r\n    </Try>);\r\n}\r\n\r\ninterface OwnProps {}\r\ninterface StateProps {\r\n    projects: LProject[];\r\n    version: DState[\"version\"];\r\n}\r\ninterface DispatchProps {}\r\n\r\ntype AllProps = OwnProps & StateProps & DispatchProps;\r\n\r\n\r\nfunction mapStateToProps(state: DState, ownProps: OwnProps): StateProps {\r\n    const ret: StateProps = {} as FakeStateProps;\r\n    ret.projects = LProject.fromArr(state.projects);\r\n    ret.version = state.version;\r\n    return ret;\r\n}\r\n\r\nfunction mapDispatchToProps(dispatch: Dispatch<any>): DispatchProps {\r\n    const ret: DispatchProps = {};\r\n    return ret;\r\n}\r\n\r\nconst AllProjectsConnected = connect<StateProps, DispatchProps, OwnProps, DState>(\r\n    mapStateToProps,\r\n    mapDispatchToProps\r\n)(AllProjectsComponent);\r\n\r\nconst AllProjectsPage = (props: OwnProps, children: (string | Component)[] = []): ReactElement => {\r\n    return <AllProjectsConnected {...{...props, children}} />;\r\n}\r\n\r\nexport {AllProjectsPage};\r\n\r\n","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\pages\\Auth.tsx",["914"],"import {FormEvent} from 'react';\r\nimport {useStateIfMounted} from 'use-state-if-mounted';\r\nimport {DUser, R, SetRootFieldAction, U} from '../joiner';\r\nimport Storage from '../data/storage';\r\nimport {AuthApi} from \"../api/persistance\";\r\nimport logo from '../static/img/jjodel.jpg';\r\nimport {Tooltip} from '../components/forEndUser/Tooltip';\r\n\r\nfunction AuthPage(): JSX.Element {\r\n\r\n    const [action, setAction] = useStateIfMounted<'login'|'register'|'retrieve-password'>('login');\r\n\r\n    const [nickname, setNickname] = useStateIfMounted('');\r\n    const [name, setName] = useStateIfMounted('');\r\n    const [surname, setSurname] = useStateIfMounted('');\r\n    const [affiliation, setAffiliation] = useStateIfMounted('');\r\n    const [country, setCountry] = useStateIfMounted('Italy');\r\n    const [email, setEmail] = useStateIfMounted('');\r\n    const [password, setPassword] = useStateIfMounted('');\r\n    const [passwordCheck, setPasswordCheck] = useStateIfMounted('');\r\n    const [newsletter, setNewsletter] = useStateIfMounted(false);\r\n\r\n\r\n    const onSubmit = async(e: FormEvent<HTMLFormElement>) => {\r\n        e.preventDefault();\r\n        SetRootFieldAction.new('isLoading', true);\r\n\r\n        switch (action) {\r\n            case 'login':\r\n                await login();\r\n                break;\r\n            case 'register':\r\n                await register();\r\n                break;\r\n            case 'retrieve-password':\r\n                await retrieve_password();\r\n                break;\r\n        }\r\n\r\n        SetRootFieldAction.new('isLoading', false);\r\n    }\r\n\r\n    const retrieve_password = async() => {\r\n        /* something to be provided here */\r\n    }\r\n\r\n    const login = async() => {\r\n        const response = await AuthApi.login(email, password);\r\n        if (response.code !== 200) {\r\n            U.alert('e', 'Login failed.','');\r\n            return;\r\n        }\r\n\r\n        const data = U.wrapper<DUser>(response.data);\r\n\r\n        const user = DUser.new(data.name, data.surname, data.nickname, data.affiliation, data.country, data.newsletter || false, data.email, data.token, data.id);\r\n        Storage.write('user', user);\r\n        Storage.write('token', user.token);\r\n        Storage.write('offline', false);\r\n        //R.navigate('/dashboard');\r\n        R.navigate('/allProjects');\r\n        U.resetState();\r\n    }\r\n\r\n    const register = async() => {\r\n        if (password !== passwordCheck) {\r\n            U.alert('e', 'The two passwords are different','');\r\n            return;\r\n        }\r\n        const response = await AuthApi.register(name, surname, country, affiliation, newsletter, nickname, email, password);\r\n        if (response.code !== 200) {\r\n            U.alert('e', 'Registration failed.', '');\r\n            return;\r\n        }\r\n        const data = U.wrapper<DUser>(response.data);\r\n        Storage.write('token', data.token);\r\n        const user = DUser.new(data.name, data.surname, data.nickname, data.affiliation, data.country, data.newsletter || false, data.email, data.token, data.id);\r\n        Storage.write('user', user);\r\n        Storage.write('offline', false);\r\n        R.navigate('/allProjects');\r\n        U.resetState();\r\n    }\r\n\r\n    const offline = () => {\r\n        AuthApi.offline();\r\n        R.navigate('/allProjects');\r\n        U.resetState();\r\n    }\r\n\r\n    return(<section className={`w-100 h-100 login bg ${action === 'register' ? 'register' : action === 'retrieve-password' && 'retrieve' } `}>\r\n\r\n        <form className={'d-block bg-white rounded border mx-auto w-fit px-5 py-4 mt-5'} onSubmit={onSubmit}>\r\n            <label className={'fs-1 d-block text-center text-primary login-header'}>\r\n\r\n                {action === 'register' && 'Create an Account'}\r\n                {action === 'login' && 'Sign In'}\r\n                {action === 'retrieve-password' && 'Retrieve your Password'}\r\n\r\n\r\n            </label>\r\n\r\n            {action === 'register' && <>\r\n\r\n                {/* REGISTRATION */}\r\n\r\n                <Tooltip tooltip={<div style={{padding: '10px', maxWidth: '600px'}}><h6>First Name</h6>Your first name will be visible to others whenever you interact with them, such as during collaboration on shared projects.</div>} >\r\n                    <label>\r\n                        First Name\r\n                        <input className={'w-100 input w-fit d-block mx-auto mt-2'}\r\n                            placeholder={'john'}\r\n                            value={name}\r\n                            onChange={e => setName(e.target.value)}\r\n                            type={'text'} required={true}\r\n                        />\r\n                    </label>\r\n                </Tooltip>\r\n\r\n                <Tooltip tooltip={<div style={{padding: '10px', maxWidth: '600px'}}><h6>Last Name</h6>Your last name will be visible to others whenever you interact with them, such as during collaboration on shared projects.</div>} >\r\n                    <label>\r\n                        Last Name\r\n                        <input className={'w-100 input w-fit d-block mx-auto mt-2'}\r\n                               placeholder={'doe'}\r\n                               value={surname}\r\n                               onChange={e => setSurname(e.target.value)}\r\n                               type={'text'} required={true}\r\n                        />\r\n                    </label>\r\n                </Tooltip>\r\n\r\n                    <Tooltip tooltip={<div style={{padding: '10px', maxWidth: '600px'}}><h6>Nickname</h6>Your nickname will be visible to others whenever you interact with them, such as during collaboration on shared projects.</div>} >\r\n                        <label>\r\n                            Nickname\r\n                            <input className={'w-100 input w-fit d-block mx-auto mt-2'}\r\n                                   placeholder={''}\r\n                                   value={nickname}\r\n                                   onChange={e => setNickname(e.target.value)}\r\n                                   type={'text'} required={true}\r\n                            />\r\n                        </label>\r\n                    </Tooltip>\r\n\r\n                <Tooltip tooltip={<div style={{padding: '10px', maxWidth: '600px'}}><h6>Affiliation</h6>Your affiliation refers to the organization, institution, or company you’re associated with, will be displayed in relevant contexts like project collaborations or professional interactions, and will help us keep track of where jjodel is being used.</div>} ><label>\r\n                    Affiliation\r\n                    <input className={'w-100 input w-fit d-block mx-auto mt-2'}\r\n                        placeholder={'eg: univaq'}\r\n                        value={affiliation}\r\n                        onChange={e => setAffiliation(e.target.value)}\r\n                        type={'text'} required={false}\r\n                    />\r\n                    </label>\r\n                </Tooltip>\r\n                <label>\r\n                    <label>Country</label>\r\n                    <select className={\"form-control\"} defaultValue={country} onChange={e => setCountry(e.target.value)}>\r\n                        <option value=\"Afghanistan\">Afghanistan</option>\r\n                        <option value=\"Åland Islands\">Åland Islands</option>\r\n                        <option value=\"Albania\">Albania</option>\r\n                        <option value=\"Algeria\">Algeria</option>\r\n                        <option value=\"American Samoa\">American Samoa</option>\r\n                        <option value=\"Andorra\">Andorra</option>\r\n                        <option value=\"Angola\">Angola</option>\r\n                        <option value=\"Anguilla\">Anguilla</option>\r\n                        <option value=\"Antarctica\">Antarctica</option>\r\n                        <option value=\"Antigua and Barbuda\">Antigua and Barbuda</option>\r\n                        <option value=\"Argentina\">Argentina</option>\r\n                        <option value=\"Armenia\">Armenia</option>\r\n                        <option value=\"Aruba\">Aruba</option>\r\n                        <option value=\"Australia\">Australia</option>\r\n                        <option value=\"Austria\">Austria</option>\r\n                        <option value=\"Azerbaijan\">Azerbaijan</option>\r\n                        <option value=\"Bahamas\">Bahamas</option>\r\n                        <option value=\"Bahrain\">Bahrain</option>\r\n                        <option value=\"Bangladesh\">Bangladesh</option>\r\n                        <option value=\"Barbados\">Barbados</option>\r\n                        <option value=\"Belarus\">Belarus</option>\r\n                        <option value=\"Belgium\">Belgium</option>\r\n                        <option value=\"Belize\">Belize</option>\r\n                        <option value=\"Benin\">Benin</option>\r\n                        <option value=\"Bermuda\">Bermuda</option>\r\n                        <option value=\"Bhutan\">Bhutan</option>\r\n                        <option value=\"Bolivia\">Bolivia</option>\r\n                        <option value=\"Bosnia and Herzegovina\">Bosnia and Herzegovina</option>\r\n                        <option value=\"Botswana\">Botswana</option>\r\n                        <option value=\"Bouvet Island\">Bouvet Island</option>\r\n                        <option value=\"Brazil\">Brazil</option>\r\n                        <option value=\"British Indian Ocean Territory\">British Indian Ocean Territory</option>\r\n                        <option value=\"Brunei Darussalam\">Brunei Darussalam</option>\r\n                        <option value=\"Bulgaria\">Bulgaria</option>\r\n                        <option value=\"Burkina Faso\">Burkina Faso</option>\r\n                        <option value=\"Burundi\">Burundi</option>\r\n                        <option value=\"Cambodia\">Cambodia</option>\r\n                        <option value=\"Cameroon\">Cameroon</option>\r\n                        <option value=\"Canada\">Canada</option>\r\n                        <option value=\"Cape Verde\">Cape Verde</option>\r\n                        <option value=\"Cayman Islands\">Cayman Islands</option>\r\n                        <option value=\"Central African Republic\">Central African Republic</option>\r\n                        <option value=\"Chad\">Chad</option>\r\n                        <option value=\"Chile\">Chile</option>\r\n                        <option value=\"China\">China</option>\r\n                        <option value=\"Christmas Island\">Christmas Island</option>\r\n                        <option value=\"Cocos (Keeling) Islands\">Cocos (Keeling) Islands</option>\r\n                        <option value=\"Colombia\">Colombia</option>\r\n                        <option value=\"Comoros\">Comoros</option>\r\n                        <option value=\"Congo\">Congo</option>\r\n                        <option value=\"Congo, The Democratic Republic of The\">Congo, The Democratic Republic of The</option>\r\n                        <option value=\"Cook Islands\">Cook Islands</option>\r\n                        <option value=\"Costa Rica\">Costa Rica</option>\r\n                        <option value=\"Cote D'ivoire\">Cote D'ivoire</option>\r\n                        <option value=\"Croatia\">Croatia</option>\r\n                        <option value=\"Cuba\">Cuba</option>\r\n                        <option value=\"Cyprus\">Cyprus</option>\r\n                        <option value=\"Czech Republic\">Czech Republic</option>\r\n                        <option value=\"Denmark\">Denmark</option>\r\n                        <option value=\"Djibouti\">Djibouti</option>\r\n                        <option value=\"Dominica\">Dominica</option>\r\n                        <option value=\"Dominican Republic\">Dominican Republic</option>\r\n                        <option value=\"Ecuador\">Ecuador</option>\r\n                        <option value=\"Egypt\">Egypt</option>\r\n                        <option value=\"El Salvador\">El Salvador</option>\r\n                        <option value=\"Equatorial Guinea\">Equatorial Guinea</option>\r\n                        <option value=\"Eritrea\">Eritrea</option>\r\n                        <option value=\"Estonia\">Estonia</option>\r\n                        <option value=\"Ethiopia\">Ethiopia</option>\r\n                        <option value=\"Falkland Islands (Malvinas)\">Falkland Islands (Malvinas)</option>\r\n                        <option value=\"Faroe Islands\">Faroe Islands</option>\r\n                        <option value=\"Fiji\">Fiji</option>\r\n                        <option value=\"Finland\">Finland</option>\r\n                        <option value=\"France\">France</option>\r\n                        <option value=\"French Guiana\">French Guiana</option>\r\n                        <option value=\"French Polynesia\">French Polynesia</option>\r\n                        <option value=\"French Southern Territories\">French Southern Territories</option>\r\n                        <option value=\"Gabon\">Gabon</option>\r\n                        <option value=\"Gambia\">Gambia</option>\r\n                        <option value=\"Georgia\">Georgia</option>\r\n                        <option value=\"Germany\">Germany</option>\r\n                        <option value=\"Ghana\">Ghana</option>\r\n                        <option value=\"Gibraltar\">Gibraltar</option>\r\n                        <option value=\"Greece\">Greece</option>\r\n                        <option value=\"Greenland\">Greenland</option>\r\n                        <option value=\"Grenada\">Grenada</option>\r\n                        <option value=\"Guadeloupe\">Guadeloupe</option>\r\n                        <option value=\"Guam\">Guam</option>\r\n                        <option value=\"Guatemala\">Guatemala</option>\r\n                        <option value=\"Guernsey\">Guernsey</option>\r\n                        <option value=\"Guinea\">Guinea</option>\r\n                        <option value=\"Guinea-bissau\">Guinea-bissau</option>\r\n                        <option value=\"Guyana\">Guyana</option>\r\n                        <option value=\"Haiti\">Haiti</option>\r\n                        <option value=\"Heard Island and Mcdonald Islands\">Heard Island and Mcdonald Islands</option>\r\n                        <option value=\"Holy See (Vatican City State)\">Holy See (Vatican City State)</option>\r\n                        <option value=\"Honduras\">Honduras</option>\r\n                        <option value=\"Hong Kong\">Hong Kong</option>\r\n                        <option value=\"Hungary\">Hungary</option>\r\n                        <option value=\"Iceland\">Iceland</option>\r\n                        <option value=\"India\">India</option>\r\n                        <option value=\"Indonesia\">Indonesia</option>\r\n                        <option value=\"Iran, Islamic Republic of\">Iran, Islamic Republic of</option>\r\n                        <option value=\"Iraq\">Iraq</option>\r\n                        <option value=\"Ireland\">Ireland</option>\r\n                        <option value=\"Isle of Man\">Isle of Man</option>\r\n                        <option value=\"Israel\">Israel</option>\r\n                        <option value=\"Italy\">Italy</option>\r\n                        <option value=\"Jamaica\">Jamaica</option>\r\n                        <option value=\"Japan\">Japan</option>\r\n                        <option value=\"Jersey\">Jersey</option>\r\n                        <option value=\"Jordan\">Jordan</option>\r\n                        <option value=\"Kazakhstan\">Kazakhstan</option>\r\n                        <option value=\"Kenya\">Kenya</option>\r\n                        <option value=\"Kiribati\">Kiribati</option>\r\n                        <option value=\"Korea, Democratic People's Republic of\">Korea, Democratic People's Republic of</option>\r\n                        <option value=\"Korea, Republic of\">Korea, Republic of</option>\r\n                        <option value=\"Kuwait\">Kuwait</option>\r\n                        <option value=\"Kyrgyzstan\">Kyrgyzstan</option>\r\n                        <option value=\"Lao People's Democratic Republic\">Lao People's Democratic Republic</option>\r\n                        <option value=\"Latvia\">Latvia</option>\r\n                        <option value=\"Lebanon\">Lebanon</option>\r\n                        <option value=\"Lesotho\">Lesotho</option>\r\n                        <option value=\"Liberia\">Liberia</option>\r\n                        <option value=\"Libyan Arab Jamahiriya\">Libyan Arab Jamahiriya</option>\r\n                        <option value=\"Liechtenstein\">Liechtenstein</option>\r\n                        <option value=\"Lithuania\">Lithuania</option>\r\n                        <option value=\"Luxembourg\">Luxembourg</option>\r\n                        <option value=\"Macao\">Macao</option>\r\n                        <option value=\"Macedonia, The Former Yugoslav Republic of\">Macedonia, The Former Yugoslav Republic of</option>\r\n                        <option value=\"Madagascar\">Madagascar</option>\r\n                        <option value=\"Malawi\">Malawi</option>\r\n                        <option value=\"Malaysia\">Malaysia</option>\r\n                        <option value=\"Maldives\">Maldives</option>\r\n                        <option value=\"Mali\">Mali</option>\r\n                        <option value=\"Malta\">Malta</option>\r\n                        <option value=\"Marshall Islands\">Marshall Islands</option>\r\n                        <option value=\"Martinique\">Martinique</option>\r\n                        <option value=\"Mauritania\">Mauritania</option>\r\n                        <option value=\"Mauritius\">Mauritius</option>\r\n                        <option value=\"Mayotte\">Mayotte</option>\r\n                        <option value=\"Mexico\">Mexico</option>\r\n                        <option value=\"Micronesia, Federated States of\">Micronesia, Federated States of</option>\r\n                        <option value=\"Moldova, Republic of\">Moldova, Republic of</option>\r\n                        <option value=\"Monaco\">Monaco</option>\r\n                        <option value=\"Mongolia\">Mongolia</option>\r\n                        <option value=\"Montenegro\">Montenegro</option>\r\n                        <option value=\"Montserrat\">Montserrat</option>\r\n                        <option value=\"Morocco\">Morocco</option>\r\n                        <option value=\"Mozambique\">Mozambique</option>\r\n                        <option value=\"Myanmar\">Myanmar</option>\r\n                        <option value=\"Namibia\">Namibia</option>\r\n                        <option value=\"Nauru\">Nauru</option>\r\n                        <option value=\"Nepal\">Nepal</option>\r\n                        <option value=\"Netherlands\">Netherlands</option>\r\n                        <option value=\"Netherlands Antilles\">Netherlands Antilles</option>\r\n                        <option value=\"New Caledonia\">New Caledonia</option>\r\n                        <option value=\"New Zealand\">New Zealand</option>\r\n                        <option value=\"Nicaragua\">Nicaragua</option>\r\n                        <option value=\"Niger\">Niger</option>\r\n                        <option value=\"Nigeria\">Nigeria</option>\r\n                        <option value=\"Niue\">Niue</option>\r\n                        <option value=\"Norfolk Island\">Norfolk Island</option>\r\n                        <option value=\"Northern Mariana Islands\">Northern Mariana Islands</option>\r\n                        <option value=\"Norway\">Norway</option>\r\n                        <option value=\"Oman\">Oman</option>\r\n                        <option value=\"Pakistan\">Pakistan</option>\r\n                        <option value=\"Palau\">Palau</option>\r\n                        <option value=\"Palestinian Territory, Occupied\">Palestinian Territory, Occupied</option>\r\n                        <option value=\"Panama\">Panama</option>\r\n                        <option value=\"Papua New Guinea\">Papua New Guinea</option>\r\n                        <option value=\"Paraguay\">Paraguay</option>\r\n                        <option value=\"Peru\">Peru</option>\r\n                        <option value=\"Philippines\">Philippines</option>\r\n                        <option value=\"Pitcairn\">Pitcairn</option>\r\n                        <option value=\"Poland\">Poland</option>\r\n                        <option value=\"Portugal\">Portugal</option>\r\n                        <option value=\"Puerto Rico\">Puerto Rico</option>\r\n                        <option value=\"Qatar\">Qatar</option>\r\n                        <option value=\"Reunion\">Reunion</option>\r\n                        <option value=\"Romania\">Romania</option>\r\n                        <option value=\"Russian Federation\">Russian Federation</option>\r\n                        <option value=\"Rwanda\">Rwanda</option>\r\n                        <option value=\"Saint Helena\">Saint Helena</option>\r\n                        <option value=\"Saint Kitts and Nevis\">Saint Kitts and Nevis</option>\r\n                        <option value=\"Saint Lucia\">Saint Lucia</option>\r\n                        <option value=\"Saint Pierre and Miquelon\">Saint Pierre and Miquelon</option>\r\n                        <option value=\"Saint Vincent and The Grenadines\">Saint Vincent and The Grenadines</option>\r\n                        <option value=\"Samoa\">Samoa</option>\r\n                        <option value=\"San Marino\">San Marino</option>\r\n                        <option value=\"Sao Tome and Principe\">Sao Tome and Principe</option>\r\n                        <option value=\"Saudi Arabia\">Saudi Arabia</option>\r\n                        <option value=\"Senegal\">Senegal</option>\r\n                        <option value=\"Serbia\">Serbia</option>\r\n                        <option value=\"Seychelles\">Seychelles</option>\r\n                        <option value=\"Sierra Leone\">Sierra Leone</option>\r\n                        <option value=\"Singapore\">Singapore</option>\r\n                        <option value=\"Slovakia\">Slovakia</option>\r\n                        <option value=\"Slovenia\">Slovenia</option>\r\n                        <option value=\"Solomon Islands\">Solomon Islands</option>\r\n                        <option value=\"Somalia\">Somalia</option>\r\n                        <option value=\"South Africa\">South Africa</option>\r\n                        <option value=\"South Georgia and The South Sandwich Islands\">South Georgia and The South Sandwich Islands</option>\r\n                        <option value=\"Spain\">Spain</option>\r\n                        <option value=\"Sri Lanka\">Sri Lanka</option>\r\n                        <option value=\"Sudan\">Sudan</option>\r\n                        <option value=\"Suriname\">Suriname</option>\r\n                        <option value=\"Svalbard and Jan Mayen\">Svalbard and Jan Mayen</option>\r\n                        <option value=\"Swaziland\">Swaziland</option>\r\n                        <option value=\"Sweden\">Sweden</option>\r\n                        <option value=\"Switzerland\">Switzerland</option>\r\n                        <option value=\"Syrian Arab Republic\">Syrian Arab Republic</option>\r\n                        <option value=\"Taiwan\">Taiwan</option>\r\n                        <option value=\"Tajikistan\">Tajikistan</option>\r\n                        <option value=\"Tanzania, United Republic of\">Tanzania, United Republic of</option>\r\n                        <option value=\"Thailand\">Thailand</option>\r\n                        <option value=\"Timor-leste\">Timor-leste</option>\r\n                        <option value=\"Togo\">Togo</option>\r\n                        <option value=\"Tokelau\">Tokelau</option>\r\n                        <option value=\"Tonga\">Tonga</option>\r\n                        <option value=\"Trinidad and Tobago\">Trinidad and Tobago</option>\r\n                        <option value=\"Tunisia\">Tunisia</option>\r\n                        <option value=\"Turkey\">Turkey</option>\r\n                        <option value=\"Turkmenistan\">Turkmenistan</option>\r\n                        <option value=\"Turks and Caicos Islands\">Turks and Caicos Islands</option>\r\n                        <option value=\"Tuvalu\">Tuvalu</option>\r\n                        <option value=\"Uganda\">Uganda</option>\r\n                        <option value=\"Ukraine\">Ukraine</option>\r\n                        <option value=\"United Arab Emirates\">United Arab Emirates</option>\r\n                        <option value=\"United Kingdom\">United Kingdom</option>\r\n                        <option value=\"United States\">United States</option>\r\n                        <option value=\"United States Minor Outlying Islands\">United States Minor Outlying Islands</option>\r\n                        <option value=\"Uruguay\">Uruguay</option>\r\n                        <option value=\"Uzbekistan\">Uzbekistan</option>\r\n                        <option value=\"Vanuatu\">Vanuatu</option>\r\n                        <option value=\"Venezuela\">Venezuela</option>\r\n                        <option value=\"Viet Nam\">Viet Nam</option>\r\n                        <option value=\"Virgin Islands, British\">Virgin Islands, British</option>\r\n                        <option value=\"Virgin Islands, U.S.\">Virgin Islands, U.S.</option>\r\n                        <option value=\"Wallis and Futuna\">Wallis and Futuna</option>\r\n                        <option value=\"Western Sahara\">Western Sahara</option>\r\n                        <option value=\"Yemen\">Yemen</option>\r\n                        <option value=\"Zambia\">Zambia</option>\r\n                        <option value=\"Zimbabwe\">Zimbabwe</option>\r\n                    </select>\r\n                </label>\r\n                <Tooltip tooltip={<div style={{padding: '10px', maxWidth: '600px'}}><h6>Email</h6>Your email address will be used for communication, notifications, and to identify you in the system, but it won’t be shared publicly without your consent.</div>} >\r\n                    <label>\r\n                        Email\r\n                        <input className={'w-100 input w-fit d-block mx-auto mt-2'}\r\n                            placeholder={'johndoe@mail.com'}\r\n                            value={email}\r\n                            onChange={e => setEmail(e.target.value)}\r\n                            type={'email'} name='email' autoComplete={'on'} required={true}\r\n                        />\r\n                    </label>\r\n                </Tooltip>\r\n                <br /><br /><br />\r\n                <label>\r\n                    Password\r\n                    <input className={'w-100 input w-fit d-block mx-auto mt-2'}\r\n                        placeholder={'password'}\r\n                        value={password}\r\n                        onChange={e => setPassword(e.target.value)}\r\n                        type={'password'} required={true}\r\n                    />\r\n                </label>\r\n\r\n\r\n                <label>\r\n                    Confirm Password\r\n                    <input className={'w-100 input w-fit d-block mx-auto mt-2'}\r\n                        placeholder={'confirm password'}\r\n                        value={passwordCheck}\r\n                        onChange={e => setPasswordCheck(e.target.value)}\r\n                        type={'password'} required={true}\r\n                    />\r\n                </label>\r\n\r\n                <br /><br /><br />\r\n                <Tooltip tooltip={<div style={{padding: '10px', maxWidth: '600px'}}><h6>Newsletter</h6>Select this option for remaining updated about Jjodel new releases, updates, and initiatives.</div>} >\r\n                    <label>\r\n                        <input className={'checkbox'}\r\n                            placeholder={'newsletter'}\r\n                            checked={newsletter}\r\n                            onChange={e => setNewsletter(e.target.checked)}\r\n                            type={'checkbox'}\r\n                            style={{outline: 'none', marginTop: '10px', float: 'left'}}\r\n                        />\r\n                        <div style={{display: 'block', width: '90%', float: 'left', marginBottom: '10px', paddingLeft: '10px'}}>Newsletter. Subscribe to the newsletter to receive updates and news. You can manage your registration preferences at any time. </div>\r\n                    </label>\r\n\r\n                </Tooltip>\r\n                <br />\r\n                <div style={{width: '100%', textAlign: 'center'}}>\r\n                    By proceeding you accept the terms and conditions.\r\n                </div>\r\n                <button className={'d-block btn btn-primary p-1 mx-auto mt-3 login-button'} type={'submit'}>\r\n                    Create\r\n                </button>\r\n            </>}\r\n\r\n            {action === 'login' &&\r\n\r\n            <>\r\n                {/* LOGIN */}\r\n                <label>\r\n                    Email\r\n                    <input className={'w-100 input w-fit d-block mx-auto mt-3'}\r\n                        placeholder={'e-mail'}\r\n                        value={email}\r\n                        onChange={e => setEmail(e.target.value)} type={'email'}\r\n                        required={true}\r\n                    />\r\n                </label>\r\n                <label>\r\n                    Password\r\n                    <input className={'w-100 input w-fit d-block mx-auto  mt-2'}\r\n                        placeholder={'password'}\r\n                        value={password}\r\n                        onChange={e => setPassword(e.target.value)}\r\n                        type={'password'}\r\n                        required={true}\r\n                />\r\n                </label>\r\n                <button className={'d-block btn btn-primary p-1 mx-auto mt-3 login-button'} type={'submit'}>\r\n                    Login\r\n                </button>\r\n                {(true || window.location.host.includes('localhost')) &&\r\n                    <button className={'d-block btn btn-primary p-1 mx-auto mt-3 login-button'} onClick={(e) => offline()}>Offline mode</button>\r\n                }\r\n            </>}\r\n\r\n            {action === 'retrieve-password' &&\r\n\r\n            <>\r\n                {/* RETRIEVE PASSWORD */}\r\n                <label>\r\n                    Enter your email\r\n                    <input className={'w-100 input w-fit d-block mx-auto mt-3'}\r\n                        placeholder={'e-mail'}\r\n                        value={email}\r\n                        onChange={e => setEmail(e.target.value)} type={'email'}\r\n                        required={true}\r\n                    />\r\n                </label>\r\n\r\n                <button className={'d-block btn btn-primary p-1 mx-auto mt-3 login-button'} type={'submit'}>\r\n                    Retrieve\r\n                </button>\r\n            </>}\r\n\r\n\r\n            <label className={'mt-3 d-block text-center'}>\r\n                {action === 'register' && <>Already have an account? <span tabIndex={-1} onClick={e => {setAction('login')}} className={'ms-1 text-primary text-decoration-none cursor-pointer login-link'}>Sign In</span></>}\r\n                {action === 'login' &&\r\n                    <>\r\n                        Don't have an account? <span tabIndex={-1} onClick={e => {setAction('register')}} className={'ms-1 text-primary text-decoration-none cursor-pointer login-link'}>Register</span><br/>\r\n                        <span tabIndex={-1} onClick={e => {setAction('retrieve-password')}} className={'ms-1 text-primary text-decoration-none cursor-pointer login-link'}>Forgot your password?</span>\r\n                    </>\r\n                }\r\n                {action === 'retrieve-password' &&\r\n                    <>\r\n                        Go back to the <span tabIndex={-1} onClick={e => {setAction('login')}} className={'ms-1 text-primary text-decoration-none cursor-pointer login-link'}>Sign In</span> page<br/>\r\n                        Don't have an account? <span tabIndex={-1} onClick={e => {setAction('register')}} className={'ms-1 text-primary text-decoration-none cursor-pointer login-link'}>Register</span><br/>\r\n                    </>\r\n                }\r\n\r\n            </label>\r\n            <div className='login-logo'><img src={logo}></img></div>\r\n        </form>\r\n    </section>);\r\n}\r\n\r\nexport {AuthPage};\r\n","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\pages\\Project.tsx",["915","916","917","918","919"],"import React, {Dispatch, ReactElement, useEffect,  useState} from 'react';\r\nimport {connect} from 'react-redux';\r\nimport {\r\n    CreateElementAction,\r\n    Dictionary,\r\n    DState,\r\n    DUser,\r\n    DViewElement, GObject,\r\n    LProject,\r\n    LUser,\r\n    LViewElement,\r\n    LViewPoint,\r\n    Pointer,\r\n    R,\r\n    Try,\r\n    U\r\n} from '../joiner';\r\nimport {FakeStateProps} from '../joiner/types';\r\nimport useQuery from '../hooks/useQuery';\r\nimport {ProjectsApi} from '../api/persistance';\r\nimport {SaveManager} from '../components/topbar/SaveManager';\r\nimport {Dashboard} from \"./components\";\r\nimport CollaborativeAttacher from \"../components/collaborative/CollaborativeAttacher\";\r\nimport {Cards} from './components/cards/Cards';\r\nimport Storage from \"../data/storage\";\r\nimport Loader from '../components/loader/Loader';\r\nimport {Navbar} from \"./components\";\r\nimport {CSS_Units} from \"../view/viewElement/view\";\r\nimport {useEffectOnce} from \"usehooks-ts\";\r\n\r\nfunction ProjectComponent(props: AllProps): JSX.Element {\r\n    const {user} = props;\r\n    const query = useQuery();\r\n    const id = query.get('id') || '';\r\n\r\n    useEffect(() => {\r\n        (async function() {\r\n            const project = await ProjectsApi.getOne(id); \r\n            if(!project) {\r\n                U.resetState();\r\n                R.navigate('/allProject');\r\n                return;\r\n            }\r\n            if(project.state) {\r\n                const state = JSON.parse(await U.decompressState(project.state));\r\n                state['idlookup'][DUser.current] = user.__raw;\r\n                if(!state['users'].includes(DUser.current)) state['users'].push(DUser.current);\r\n                SaveManager.load(state);\r\n            }\r\n\r\n            user.project = LProject.fromPointer(project.id);\r\n        })();\r\n    }, [id]);\r\n\r\n    let vparr = user?.project?.viewpoints || [];\r\n    let allViews = vparr.flatMap((vp: LViewPoint) => vp && vp.allSubViews);\r\n    allViews.push(...vparr as LViewElement[]);\r\n    allViews = allViews.filter(v => v);\r\n    const viewsDeDuplicator: Dictionary<Pointer<DViewElement>, LViewElement> = {};\r\n    for (let v of allViews) viewsDeDuplicator[v.id] = v;\r\n    if (!user?.project) {\r\n        return (\r\n            <div className={'w-100 h-100 d-flex'}>\r\n                <div className={'m-auto d-flex p-5'} style={{flexFlow: 'column', cursor:'pointer'}}onClick={(e) => R.navigate('/allProjects')}>\r\n                    <h4 className={'mx-auto'}>Project loading...</h4>\r\n                    <div className={'mx-auto'}>if it takes too long try refreshing the page, or click to go back</div>\r\n                </div>\r\n            </div>\r\n        );\r\n    }\r\n\r\n    return (<>\r\n        <Try>\r\n        <Dashboard active={'Project'} version={props.version} project={user.project}>\r\n            <React.Fragment>\r\n                <style id={\"views-css-injector-p\"}>\r\n                    {Object.values(viewsDeDuplicator).map(v => v.compiled_css).join('\\n\\n')}\r\n                </style>\r\n                {CSS_Units.jsx}\r\n\r\n                <Cards>\r\n                    {user.project.metamodels.length === 0 ?\r\n                        <Cards.Item\r\n                            title={'Your first metamodel ?'}\r\n                            subtitle={'Create a new metamodel.'}\r\n                            icon={'add'}\r\n                            style={'red'}\r\n                            action={() => {\r\n                                alert('new metamodel')\r\n                            }}\r\n                        />\r\n                        :\r\n                        <React.Fragment>\r\n                            <Cards.Item\r\n                                title={'Create another metamodel ?'}\r\n                                subtitle={'Create a new metamodel.'}\r\n                                icon={'add'}\r\n                                style={'red'}\r\n                                action={() => {\r\n                                    alert('another metamodel')\r\n                                }}\r\n                            />\r\n                            <Cards.Item\r\n                                title={'Create a model ?'}\r\n                                subtitle={'Create a new model.'}\r\n                                icon={'add'}\r\n                                style={'red'}\r\n                                action={() => {\r\n                                    alert('new model')\r\n                                }}\r\n                            />\r\n                        </React.Fragment>\r\n                    }\r\n                    <Cards.Item icon={'question'} style={'clear'} title={'Ehy!'}\r\n                                subtitle={'What do you want to do today?'}/>\r\n                </Cards>\r\n\r\n            </React.Fragment>\r\n        </Dashboard>\r\n        </Try>\r\n\r\n        {/*<Try><Dock /></Try>*/}\r\n        {user.project.type === 'collaborative' && <CollaborativeAttacher project={user.project}/>}\r\n    </>);\r\n\r\n}\r\n\r\ninterface OwnProps {\r\n}\r\n\r\ninterface StateProps {\r\n    user: LUser,\r\n    version: DState[\"version\"],\r\n}\r\ninterface DispatchProps {}\r\ntype AllProps = OwnProps & StateProps & DispatchProps;\r\n\r\n\r\nfunction mapStateToProps(state: DState, ownProps: OwnProps): StateProps {\r\n    const ret: StateProps = {} as FakeStateProps;\r\n    ret.user = LUser.fromPointer(DUser.current);\r\n    return ret;\r\n}\r\n\r\nfunction mapDispatchToProps(dispatch: Dispatch<any>): DispatchProps {\r\n    const ret: DispatchProps = {};\r\n    return ret;\r\n}\r\n\r\nexport const ProjectConnected = connect<StateProps, DispatchProps, OwnProps, DState>(\r\n    mapStateToProps,\r\n    mapDispatchToProps\r\n)(ProjectComponent);\r\n\r\nconst ProjectPage = (props: OwnProps, children: (string | React.Component)[] = []): ReactElement => {\r\n    return <ProjectConnected {...{...props, children}} />;\r\n}\r\n\r\nexport {ProjectPage};\r\n\r\n","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\pages\\Updates.tsx",["920","921"],"import {Dictionary, R, Try, windoww} from '../joiner';\r\nimport {Dashboard} from './components';\r\n\r\nimport {Cards, Card} from './components/cards/Cards';\r\nimport {Catalog} from './components/catalog/Catalog';\r\nimport {ReactNode, useState} from \"react\";\r\nimport \"./DashStyles/updates.scss\"\r\n\r\ntype keys = 'fix' | 'newbug' | 'opt' | 'feat' | 'info';\r\n\r\nclass InfoEntry {\r\n    constructor(public title: ReactNode, public content: ReactNode, public key: keys) {\r\n    }\r\n}\r\n\r\nclass Version {\r\n    static all: Version[] = [];\r\n    entries: Dictionary<keys, InfoEntry[]>;\r\n    majorEntries: InfoEntry[];\r\n    minorEntries: InfoEntry[];\r\n    _minor: boolean;\r\n    number: string;\r\n    name: string;\r\n    date: string;\r\n\r\n    constructor(number: string, name: string, date: string) {\r\n        this.number = number;\r\n        this.name = name;\r\n        this.date = date;\r\n        this.entries = {fix: [], newbug: [], opt: [], feat: [], info: []};\r\n        this.majorEntries = [];\r\n        this.minorEntries = [];\r\n        this._minor = false;\r\n        Version.all.push(this);\r\n    }\r\n\r\n    add(key: keys, title: ReactNode, node: ReactNode = null): this {\r\n        let entry = new InfoEntry(title, node, key);\r\n        this.entries[key].push(entry);\r\n        // if (this._minor) this.minorEntries.push(entry) else\r\n        this.majorEntries.push(entry);\r\n        return this;\r\n    }\r\n\r\n    fix(title: ReactNode, node: ReactNode = null): this {\r\n        this.add('fix', title, node);\r\n        return this;\r\n    }\r\n\r\n    newbug(title: ReactNode, node: ReactNode = null): this {\r\n        this.add('newbug', title, node);\r\n        return this;\r\n    }\r\n\r\n    opt(title: ReactNode, node: ReactNode = null): this {\r\n        this.add('opt', title, node);\r\n        return this;\r\n    }\r\n\r\n    feat(title: ReactNode, node: ReactNode = null): this {\r\n        this.add('feat', title, node);\r\n        return this;\r\n    }\r\n\r\n    engine(title: ReactNode, node: ReactNode = null): this {\r\n        this.add('feat', title, node);\r\n        return this;\r\n    }\r\n\r\n    info(title: ReactNode, node: ReactNode = null): this {\r\n        this.add('info', title, node);\r\n        return this;\r\n    }\r\n\r\n    minor(): this {\r\n        this._minor = true;\r\n        return this;\r\n    }\r\n}\r\n\r\nlet warnicon = <i className=\"bi bi-exclamation-triangle-fill\"/>\r\n// <i className=\"bi bi-exclamation-diamond-fill\" />;\r\n// <i className=\"bi bi-exclamation-square-fill\" />;\r\n\r\nfunction versionsetup() {\r\n    localStorage.setItem('_jj_update_date', '' + Math.min(Date.now(), new Date('2024-11-19').getTime()));\r\n    new Version('2.2', 'manatee', '19/nov/2024')\r\n        .newbug(<>{warnicon} Edges</>, <>Some update were made on edge's internal behaviour, old saves might have side effects.\r\n            If edges are not behaving properly create a new project, copy the default model's JSX and paste it in the old project.\r\n            <br/>To enable edits on default views right-click on the jjodel logo at the top-center of the page.\r\n            <br/>On custom views try to make start and end point to vertexes (draggable items) instead of fields (inline items).</>)\r\n        .feat('console tips', 'When hovering a console output or suggested keys a tooltip will show documentation.')\r\n        .fix('delete viewpoints', 'But cannot delete the active viewpoint.') // what if i delete a non-exclusive vp?\r\n        .fix('delete models')\r\n        .fix('containment & parent', 'Containment references were inconsistently updating the .parent property of contained elements.')\r\n        .feat('model dependencies', <>Models can now \"depend\" on other models in a extend-like style. if A depends on B\r\n            (A→B), A can use concepts from B.\r\n            <br/>Dependency chains (A→B→C) and loops (A→B, B→A) are also supported\r\n            <br/>Cross-reference activation is required too.</>)\r\n        .feat('cross-Reference', <>Cross-reference can be activated for: classes (inheritance), features (type).<br/>\r\n            To reduce cluttering in the options, normally you can only reference concepts in the same model.<br/>\r\n            If Cross-Reference is enabled you can reference valid concepts from all model dependencies.\r\n        </>)\r\n        .feat('context-menu containment', <>The option to add containment objects has been expanded, it is now available\r\n            to individual features too.</>)\r\n        .engine('data.validTargets (JDL Engine)', <>Can be used to create custom DSL and filtered to restrict model transformations, it\r\n            provides a list of valid targets for:\r\n            <ul>\r\n                <li>class extension</li>\r\n                <li>parameter, operation and m2-feature type</li>\r\n                <li>m1-values</li>\r\n                <li>model-dependencies</li>\r\n            </ul>\r\n        </>)\r\n        .minor()\r\n        .feat('U.clickedOutside()',\r\n            <>Utility for interactive graphs: When a click is detected outside the first parameter (HTMLElement or Event), it triggers a callback function in the first parameter.\r\n                <br/>\r\n                Example: {\"<div onClick={(evt)=>{data.$active=true; U.clickedOutside(evt, ()=>data.$active=false)}} ></div>\"} where\r\n                data is a m1-object holding a boolean feature \"active\"\r\n                {warnicon} To ensure the node is properly updated, remember to add \"Listed dependencies\" accordingly to\r\n                the value edited in the view.\r\n                <br/>In this example you need the dependency \"active = data.$active\" or equivalent ones.\r\n                <br/>Without it the value would update immediately but the graphical representation would always be 1 state behind.\r\n            </>)\r\n        .fix('structure editor', 'The layout was occasionally breaking')\r\n        .feat('changelog', 'Yes, this one. It deserved a mention.')\r\n}\r\n\r\nfunction UpdatesPage(): JSX.Element {\r\n    // NB: this works only in production if you put subfolders with past builds in the new build root.\r\n    let [info, setInfo] = useState(true);\r\n    let [feat, setFeat] = useState(true);\r\n    let [fix, setFix] = useState(true);\r\n    let [newbug, setNewbug] = useState(true);\r\n    let [opt, setOpt] = useState(false);\r\n    let [versionCollapse, setVersionCollapse] = useState({} as Dictionary<string, boolean>);\r\n\r\n    if (!Version.all.length) versionsetup();\r\n    let allowedDict: Dictionary<keys, boolean> = {info, feat, fix, newbug, opt};\r\n    let cards: ReactNode =\r\n        <Cards>\r\n            <Cards.Item\r\n                title={'Getting started'}\r\n                subtitle={'Create your first notation.'}\r\n                icon={'gettingstarted'}\r\n                style={'rainbow'}\r\n            />\r\n            {true && <Cards.Item icon={'question'} style={'clear'} title={'Ehy!'}\r\n                                 subtitle={'What do you want to do today?'}/>}\r\n        </Cards>;\r\n    cards = null;\r\n\r\n    return (<Try>\r\n        <Dashboard active={'Updates'} version={{n: 0, date: 'fake-date'}}>\r\n            <div id={'updates-page'}>{cards}\r\n                <h2>Past versions\r\n                    <select className={'ms-2'}\r\n                            onChange={(e) => R.navigate(e.target.value)}>\r\n                        <option value='/jjodel/2.2' title={'13/nov/2024'}>2.2</option>\r\n                        <option value='/jjodel/2.1' disabled>2.1</option>\r\n                        <option value='/jjodel/2.0' disabled>2.0</option>\r\n                    </select>\r\n                </h2>\r\n                <div className={'filter-container'}>\r\n                    <button className={'feat btn btn-' + (feat ? '' : 'outline-') + 'info'}\r\n                            onClick={e => setFeat(!feat)}>Feature\r\n                    </button>\r\n                    <button className={'fix btn btn-' + (fix ? '' : 'outline-') + 'success'}\r\n                            onClick={e => setFix(!fix)}>Bugfix\r\n                    </button>\r\n                    <button className={'newbug btn btn-' + (newbug ? '' : 'outline-') + 'danger'}\r\n                            onClick={e => setNewbug(!newbug)}>New known bug\r\n                    </button>\r\n                    <button className={'info btn btn-' + (info ? '' : 'outline-') + 'secondary'}\r\n                            onClick={e => setInfo(!info)}>Information\r\n                    </button>\r\n                    <button className={'opt btn btn-' + (opt ? '' : 'outline-') + 'warning'}\r\n                            onClick={e => setOpt(!opt)}>Optimization\r\n                    </button>\r\n                </div>\r\n                <ul className={'version-list'}>\r\n                    {Version.all.map(v=>\r\n                    <li className={'version'}>\r\n                        <h2 className={'version-name'} onClick={()=>{setVersionCollapse({...versionCollapse, [v.number]: !versionCollapse[v.number]})}}>{\r\n                            <i className={\"bi bi-chevron-\" + (!versionCollapse[v.number] ? 'up' : 'down')}/>\r\n                        } {v.number} {v.name} {v.date}\r\n                        </h2>\r\n                        {!versionCollapse[v.number] && <ul className={'entry-list'}>\r\n                            {v.majorEntries.map(e => {\r\n                                if (!allowedDict[e.key]) return null;\r\n                                return <li className={'entry ' + e.key}>\r\n                                    <span className={'title'}>{e.title}</span>\r\n                                    <span className={'content'}>{e.content}</span>\r\n                                </li>\r\n                            })\r\n                            }\r\n                        </ul>}\r\n                    </li>)\r\n                    }\r\n                </ul>\r\n            </div>\r\n        </Dashboard>\r\n    </Try>)\r\n        ;\r\n}\r\n\r\nexport {UpdatesPage};\r\n","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\pages\\components\\Dashboard.tsx",["922"],"import {\r\n    Dictionary, DProject,\r\n    DState,\r\n    DUser,\r\n    DViewElement,\r\n    Input,\r\n    LPointerTargetable,\r\n    LProject,\r\n    LUser,\r\n    LViewElement,\r\n    LViewPoint,\r\n    Pointer,\r\n    SetFieldAction,\r\n    SetRootFieldAction,\r\n    U,\r\n    Try, TRANSACTION, L\r\n} from '../../joiner';\r\nimport {LeftBar, Navbar} from './';\r\n\r\nimport '../dashboard.scss'\r\nimport {ReactElement, useRef} from \"react\";\r\nimport {Btn, CommandBar, Sep} from '../../components/commandbar/CommandBar';\r\n\r\nimport colors from '../../static/img/colors.png';\r\nimport useQuery from '../../hooks/useQuery';\r\n\r\nimport {\r\n    TbSquareRoundedLetterM,\r\n    TbSquareRoundedLetterMFilled,\r\n    TbSquareRoundedLetterV,\r\n    TbSquareRoundedLetterVFilled,\r\n    TbSquareRoundedLetterE\r\n} from \"react-icons/tb\";\r\nimport DockManager from '../../components/abstract/DockManager';\r\nimport Dock from \"../../components/abstract/Dock\";\r\nimport {CSS_Units} from \"../../view/viewElement/view\";\r\nimport {useStateIfMounted} from 'use-state-if-mounted';\r\nimport { Tooltip } from '../../components/forEndUser/Tooltip';\r\nimport { ProjectsApi } from '../../api/persistance';\r\n\r\n\r\ntype UserProps = {\r\n    name: string;\r\n    initials: string;\r\n};\r\n\r\nconst User = (props: UserProps) => {\r\n    return (<>\r\n        <div className={'user'}>\r\n            <div className={'initials'}>{props.initials}</div>\r\n            <div className={'name'}><h2>{props.name}'s projects</h2></div>\r\n        </div>\r\n    </>);\r\n};\r\n\r\ntype TitleProps = {\r\n    projectID?: Pointer<DProject>;\r\n    active: string;\r\n    title: string;\r\n    icon: ReactElement;\r\n    description?: string;\r\n    type?: 'private'|'public'|'collaborative';\r\n}\r\n\r\n\r\nconst Title = (props: TitleProps) => {\r\n\r\n    let [title, setTitle] = useStateIfMounted(props.title);\r\n    let [description, setDescription] = useStateIfMounted(props.description);\r\n\r\n\r\n    const [editTitle, setEditTitle] = useStateIfMounted(false);\r\n    const [editDes, setEditDes] = useStateIfMounted(false);\r\n    //if (!editTitle && title !== props.title) setTitle(props.title);\r\n    //if (!editDes && description !== props.description) setDescription(props.description);\r\n\r\n    const titleRef = useRef();\r\n    const desRef = useRef();\r\n\r\n    const ProjectProperties = () => {\r\n\r\n        const server = 'http://app.jjodel.io';\r\n        const projectLink = '/#/project?id='+props.projectID;\r\n\r\n        function copyToClipboard(e: any) {\r\n            //const server = document.getElementById('server');\r\n            //const link = document.getElementById('link');\r\n            let full_link = server + projectLink;\r\n            console.log('copy to clipboard');\r\n            U.clipboardCopy(full_link, ()=>U.alert('i', \"Copied\", \"The project link has been copied to the Clipboard.\"));\r\n        }\r\n\r\n        let type = (props.type === \"public\");\r\n            return (<><label className='text-end nav-commands d-flex' \r\n                        style={{float: `${props.type === 'public' ? 'left': 'none'}`}}>\r\n                {props.type && <>\r\n                    <span className={\"my-auto me-1\"}>{props.type === \"public\" ? \"public\" : props.type === \"private\" ? \"private\" : \"collaborative\"}</span>\r\n                    \r\n                    {props.type !== \"collaborative\" && \r\n                        <Input type=\"toggle\"\r\n                            className={\"my-auto\"}\r\n                            style={{fontSize:'1.25em'}}\r\n                            setter={(v) => {\r\n                                if (!props.projectID) return;\r\n                                let project: LProject = L.fromPointer(props.projectID);\r\n                                project.type = v ? \"public\" : \"private\";\r\n                                if (v) U.alert('i', \"The project \"+title+\" is public\", \"It can be accessed only by those who have the public link.\");\r\n                            }}\r\n                            getter={() => type}\r\n                        />    \r\n                    }\r\n                </>\r\n                }\r\n            </label>\r\n            {props.type === \"public\" &&\r\n                <Tooltip tooltip={'Copy to Clipboard'} inline={true} position={'top'} offsetY={10}>\r\n                    <span onClick={(e) => copyToClipboard(e)}className={'project-link'}>\r\n                        <span id={'server'}>{server}</span><span id={'link'}>{projectLink}</span>\r\n                    </span>\r\n                </Tooltip>\r\n            }\r\n            </>\r\n            );\r\n        };\r\n\r\n        // <h2 onBlur={() => setEditTitle(!editTitle)} >\r\n\r\n        // function setTitle(e: any) {\r\n        //     if (title === '') {\r\n        //         U.alert('e', 'Title cannot be empty', 'Please enter a title for the project.');\r\n        //         e.target.focus();\r\n        //         return;\r\n        //     }\r\n        //     setProjectModified();\r\n        //     setEditTitle(!editTitle);\r\n        // }\r\n\r\n        // function setDescription(e: any) {\r\n\r\n        //     if (description === '') {\r\n        //         U.alert('e', 'Description cannot be empty', 'Please enter a description for the project.');\r\n        //         e.target.focus();\r\n        //         return;\r\n        //     }\r\n        //     setProjectModified();\r\n        //     setEditDes(!editDes);\r\n        // }\r\n\r\n        // function setPrivacy(e: any) {\r\n        //     setProjectModified();\r\n        // }\r\n\r\n\r\n\r\n    return (<>\r\n        <div className={'title'}>\r\n            {props.active === 'Project' ?\r\n                <div className={'project-list'}> {/* name */}\r\n                    {editTitle ?\r\n                        <h2>\r\n                            <div>\r\n                                {props.icon}\r\n                                <input\r\n                                    autoFocus\r\n                                    type={'text'}\r\n                                    value={title}\r\n                                    onChange={(e)=>setTitle(e.target.value)}\r\n                                    style={{padding: '0px', margin: '0'}}\r\n                                    onBlur={(e) => {\r\n                                        if (!props.projectID) return;\r\n                                        if (!e.target.value) {\r\n                                            U.alert('e', 'A Project Name is required.', 'Please provide a name to identify and organize your project effectively.');\r\n                                            e.target.focus();\r\n                                            return;\r\n                                        }\r\n                                        let project: LProject = L.fromPointer(props.projectID);\r\n                                        project.name = e.target.value;\r\n                                        setEditTitle(false);\r\n                                    }}\r\n                                />\r\n                            </div>\r\n                        </h2> :\r\n                        <>\r\n                        <Tooltip tooltip={'DoubleClick to edit'} inline={true} position={'left'} offsetX={10}>\r\n                            <h2 onDoubleClick={() => {setEditTitle(true)}}>\r\n                            {props.icon} {props.title}\r\n                        </h2></Tooltip>\r\n                         </>\r\n                    }\r\n                    <h6><ProjectProperties/></h6>\r\n                    \r\n                    {editDes ? \r\n                        <h3>\r\n                            <textarea\r\n                                autoFocus\r\n                                rows={4}\r\n                                cols={80}\r\n                                value={description}\r\n                                onChange={(e)=> {\r\n                                    console.log('onchange', {e, tv:e.target.value, pv:props.description, sv:description})\r\n                                    setDescription(e.target.value)\r\n                                }}\r\n                                onInput={(e)=> {\r\n                                    console.log('onInput', {e, tv:e.target, pv:props.description, sv:description})\r\n                                }}\r\n                                onBlur={e => {\r\n                                    if (!props.projectID) return;\r\n                                    if (!e.target.value) {\r\n                                        e.target.focus();\r\n                                        U.alert('e', 'A Project Description is required.', 'Adding a description helps provide clarity and context for your project.');\r\n                                        return;}\r\n                                    let project: LProject = L.fromPointer(props.projectID);\r\n                                    project.description = e.target.value;\r\n                                    setEditDes(false);\r\n                                }}\r\n                            />\r\n                        </h3>\r\n                        :\r\n                        <>\r\n                            {props.description && <Tooltip tooltip={'DoubleClick to edit'} inline={true} position={'left'} offsetX={10}>\r\n                                <h3 onDoubleClick={() => setEditDes(!editDes)}>{props.description}</h3>\r\n                            </Tooltip>}\r\n                        </>\r\n                    }\r\n                    \r\n                </div>\r\n                :\r\n                <div className={'header'}>\r\n                    <h2>{props.icon} {props.title}</h2>\r\n                    {props.description && <h3>{props.description}</h3>}\r\n                </div>\r\n            }\r\n        </div>\r\n    </>);\r\n};\r\n\r\n\r\nexport type DashProps = {\r\n    children?: JSX.Element,\r\n    className?: string;\r\n    // NB: account and profile are both used, i don't know which to keep\r\n    active: 'Account'|'Profile'|'Settings'|'Updates'|'Community'|'All'|'Archive'|'Templates'|'Recent' | 'Notes' | 'Project' | 'UsersInfo' | 'ProjectsInfo' | 'News';\r\n    version?: Partial<DState[\"version\"]>;\r\n    project?: LProject;\r\n    projects?:LProject[];\r\n    style?: any;\r\n};\r\n\r\n\r\ntype CatalogProps = {\r\n    children: any;\r\n}\r\n\r\nconst Catalog = (props: CatalogProps) => {\r\n\r\n    return props.children;\r\n};\r\n\r\ntype ProjectDashboardProps = {\r\n    children?: JSX.Element,\r\n    // NB: account and profile are both used, i don't know which to keep\r\n    active: 'Account'|'Profile'|'Settings'|'Updates'|'Community'|'All'|'Archive'|'Templates'|'Recent' | 'Notes' | 'Project';\r\n    version: Partial<DState[\"version\"]>;\r\n    project?: LProject;\r\n}\r\n\r\nfunction GenericDashboard(props: DashProps): any {\r\n    const {children, active} = props;\r\n    const user: LUser = LPointerTargetable.fromPointer(DUser.current);\r\n\r\n    return (<>\r\n        <Navbar />\r\n        <div className={\"dashboard-container\"} tabIndex={-1}>\r\n            <LeftBar active={active} projects={user?.projects}/>\r\n            <div className={`dash-content user ${props.style && props.style}`}>\r\n                <div>\r\n                    <>\r\n                        {active === \"All\" && <Title active={active} title={'Dashboard'} icon={<i className=\"bi bi-columns-gap\"></i>} />}\r\n                        {active === \"Recent\" && <Title  active={active} title={'Recent'} icon={<i className=\"bi bi-clock\"></i>} />}\r\n                        {active === \"Templates\" && <Title  active={active} title={'Templates'} icon={<i className=\"bi bi-lightbulb\"></i>} />}\r\n                        {active === \"Notes\" && <Title  active={active} title={'Project Notes'} icon={<i className=\"bi bi-pencil-square\"></i>} />}\r\n                        {active === \"Updates\" && <Title  active={active} title={'What\\'s new'} icon={<i className=\"bi bi-clock-history\"></i>} />}\r\n                        {active === \"Profile\" && <Title  active={active} title={'Profile'} icon={<i className=\"bi bi-clock-history\"></i>} />}\r\n                    </>\r\n                </div>\r\n                <Catalog children={children}/>\r\n            </div>\r\n        </div>\r\n    </>);\r\n}\r\n\r\ntype ProjectProps = {\r\n    project: LProject;\r\n}\r\n\r\nconst ProjectInfoCard = (props: ProjectProps) => {\r\n\r\n    const {project} = props;\r\n\r\n    /* to be refined */\r\n\r\n    return (\r\n        <div className={'details'}>\r\n            <>\r\n                <h5>{project.name ? project.name : 'Unnamed Project'}</h5>\r\n                {project.description && <p>{project.description}</p>}\r\n                <img src={colors} width={220} style={{paddingBottom: '10px'}}/>\r\n\r\n                {project.metamodels.length === 0 ?\r\n                    <p>This project does not contain any metamodel and consequently no models yet; it only contains the default viewpoints.</p>\r\n                    :\r\n                    <p>\r\n                    {project.metamodels.length === 1 && <>In this project, <b>one metamodel</b> is defined</>}\r\n                    {project.metamodels.length > 1 && <>In this project, <b>{project.metamodels.length} metamodels</b> are defined </>}\r\n                    {project.models.length === 0  ?\r\n                        <> and does not contain any model (it only includes the default viewpoints).</>\r\n                        :\r\n                        <>\r\n                        {project.models.length === 1  && <>, from which <b>one model</b> is instantiated. </>}\r\n                        {project.models.length > 1  && <>, from which <b>{project.models.length}</b> models are instantiated. </>}\r\n\r\n                        <>These models are explored and analyzed through <b>{project.viewpoints.length} viewpoints</b> (including the default ones), each offering a distinct perspective on different system concerns. </>\r\n                        </>\r\n                    }\r\n\r\n\r\n                    </p>\r\n                }\r\n            </>\r\n        </div>\r\n    );\r\n}\r\n\r\n/* Project Details / Project Summary */\r\n\r\nfunction ProjectCatalog(props: ProjectProps) {\r\n\r\n    const {project} = props;\r\n\r\n    return (<>\r\n        <ProjectInfoCard project={project} key={'info'} />\r\n        <div className={'row project-list'} key={'list'}>\r\n            <div className='row header' key={'header'}>\r\n                <div className={'col-4 '}>Name</div>\r\n                <div className={'col-2 artifact-type'}>Type</div>\r\n                <div className={'col-1'}>Operation</div>\r\n            </div>\r\n\r\n            {project.metamodels.map((mm) =>{\r\n                let name = mm.name\r\n                return (\r\n                <div className=\"row data\" key={mm.id}>\r\n                    <div className={'col-4 '} onClick={async () => await DockManager.open2(mm)}>\r\n                        <TbSquareRoundedLetterMFilled style={{fontSize: '1.5em'}}/> {name}</div>\r\n                    <div className={'col-2 artifact-type'}>Metamodel</div>\r\n                    <div className={'buttons'}>\r\n                        <CommandBar noBorder={true} style={{marginBottom: '0'}}>\r\n                            <Btn icon={'open'} action={async () => await DockManager.open2(mm)}\r\n                                 tip={'Open metamodel'}/>\r\n                            <Btn icon={'minispace'}/>\r\n                            <Btn icon={'copy'} action={e => {\r\n                            }} tip={'Duplicate metamodel'}/>\r\n                            <Sep/>\r\n                            <Btn icon={'delete'} action={e => mm.delete()} tip={`Delete model \"${name}\"`}/>\r\n                        </CommandBar>\r\n                    </div>\r\n                </div>)\r\n            })\r\n            }\r\n            {project.models.map(model => {\r\n                let name = model.name;\r\n                return (\r\n                <div className=\"row data\" key={model.id}>\r\n                    <div className={'col-4 '} onClick={async () => await DockManager.open2(model)}>\r\n                        <TbSquareRoundedLetterM style={{fontSize: '1.5em'}}/> {name}</div>\r\n                    <div className={'col-2 artifact-type'}>Model</div>\r\n                    <div className={'buttons'}>\r\n                        <CommandBar noBorder={true} style={{marginBottom: '0'}}>\r\n                            <Btn icon={'open'} action={async () => await DockManager.open2(model)}\r\n                                 tip={'Open model'}/>\r\n                            <Btn icon={'minispace'}/>\r\n                            <Btn icon={'copy'} action={e => {\r\n                            }} tip={'Duplicate model'}/>\r\n                            <Sep/>\r\n                            <Btn icon={'delete'} action={e => model.delete()} tip={`Delete model \"${name}\"`}/>\r\n                        </CommandBar>\r\n                    </div>\r\n                </div>)\r\n            })\r\n            }\r\n            {project.viewpoints.map(vp => {\r\n                let name = vp?.name;\r\n                return (!vp ? <div key={name||'error_'+vp}>errorvp: {vp + ''}</div> :\r\n                    <div className=\"row data viewpoint\" key={name}>\r\n                        <div className={'col-4'}>{vp.isOverlay ?\r\n                            <TbSquareRoundedLetterVFilled style={{fontSize: '1.5em'}}/> :\r\n                            <TbSquareRoundedLetterV style={{fontSize: '1.5em'}}/>} {name}</div>\r\n                        <div className={'col-2 artifact-type'}>Viewpoint</div>\r\n                        <div className={'buttons'}>\r\n                            <CommandBar noBorder={true} style={{marginBottom: '0'}}>\r\n                                <Btn icon={'open'} tip={'Open viewpoint'} disabled={true}/>\r\n                                <Btn icon={'minispace'}/>\r\n                                <Btn icon={'copy'} action={e => vp.duplicate()} tip={'Duplicate viewpoint'}/>\r\n                                <Sep/>\r\n                                <Btn icon={'delete'} action={e => vp.delete()} tip={'Delete viewpoint'}\r\n                                     disabled={name === 'Default' || name === 'Validation default'}/>\r\n                            </CommandBar>\r\n                        </div>\r\n                    </div>)\r\n            })\r\n            }\r\n            <div className={'legenda'} key={'legenda'}>\r\n                <h1>Legenda</h1>\r\n                <div className={'row'}>\r\n                    <div className={'col'}>\r\n                        <TbSquareRoundedLetterMFilled style={{fontSize: '1.3em'}}/> Metamodels\r\n                    </div>\r\n                    <div className={'col'}>\r\n                        <TbSquareRoundedLetterM style={{fontSize: '1.3em'}}/> Models\r\n                    </div>\r\n                    <div className={'col'}>\r\n                        <TbSquareRoundedLetterVFilled style={{fontSize: '1.3em'}}/> Viewpoints\r\n                    </div>\r\n                    <div className={'col'}>\r\n                        <TbSquareRoundedLetterV style={{fontSize: '1.3em'}}/> Overlay Viewpoints\r\n                    </div>\r\n                    <div className={'col disabled'}>\r\n                        <TbSquareRoundedLetterE className={'disabled'} style={{fontSize: '1.3em'}}/> Epsilon Transformations\r\n                    </div>\r\n                </div>\r\n            </div>\r\n        </div>\r\n    </>)}\r\n\r\n\r\nfunction ProjectDashboard(props: DashProps): any {\r\n\r\n    const {children, active} = props;\r\n    const user: LUser = LPointerTargetable.fromPointer(DUser.current);\r\n    const query = useQuery();\r\n    const id = query.get('id') || '';\r\n    const project: LProject = LProject.fromPointer(id);\r\n\r\n    let vparr = project?.viewpoints || [];\r\n    let allViews = vparr.flatMap((vp: LViewPoint) => vp && vp.allSubViews);\r\n    allViews.push(...vparr as LViewElement[]);\r\n    allViews = allViews.filter(v => v);\r\n    const viewsDeDuplicator: Dictionary<Pointer<DViewElement>, LViewElement> = {};\r\n    for (let v of allViews) viewsDeDuplicator[v.id] = v;\r\n\r\n    return (<>\r\n        <Try>\r\n            <>\r\n                <style id={\"views-css-injector-d\"}>\r\n                    {Object.values(viewsDeDuplicator).map(v => v.compiled_css).join('\\n\\n')}\r\n                </style>\r\n                {CSS_Units.jsx}\r\n            </>\r\n        </Try>\r\n        <Navbar />\r\n        <Try><Dock /></Try>\r\n    </>);\r\n}\r\n\r\nfunction Dashboard(props: DashProps): any {\r\n\r\n    return props.active === 'Project' ?\r\n            <ProjectDashboard {...props} className={(props.className||'') + ' bg'} /> :\r\n            <GenericDashboard {...props} />\r\n}\r\n\r\nexport {Dashboard, ProjectCatalog, Title};\r\n\r\n\r\n\r\n","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\pages\\components\\LeftBar.tsx",["923"],"import { meanBy } from 'lodash';\r\nimport { useState, MouseEventHandler } from 'react';\r\nimport { IconTheme } from 'react-hot-toast';\r\nimport {DProject, DUser, L, LProject, LUser, R, SetRootFieldAction, U, windoww} from '../../joiner';\r\n\r\nimport { icon } from './icons/Icons';\r\nimport {DashProps} from \"./Dashboard\";\r\nimport Collaborative from \"../../components/collaborative/Collaborative\";\r\nimport {ProjectsApi} from \"../../api/persistance\";\r\nimport storage from \"../../data/storage\";\r\nimport { isProjectModified } from '../../common/libraries/projectModified';\r\nimport { Tooltip } from '../../components/forEndUser/Tooltip';\r\nimport {SaveManager} from \"../../components/topbar/SaveManager\";\r\nimport {Link, useNavigate} from \"react-router-dom\";\r\n\r\ninterface StateProps {\r\n    projects: LProject[];\r\n}\r\n\r\n\r\nexport type LeftBarProps = {\r\n    user?: LUser;\r\n    active: DashProps['active']; // prende il tipo dal parent-component, così si evita di aggiornare entrambi o avere tipi discordanti.\r\n    projects?: LProject[];\r\n    project?: LProject;\r\n\r\n};\r\n\r\n\r\ntype ItemProps = {\r\n    children: string;\r\n    icon?: any;\r\n    action?: string | MouseEventHandler;\r\n    dot?: boolean;\r\n    onClick?: MouseEventHandler\r\n};\r\n\r\nconst Item = (props: ItemProps) => {\r\n    let action: (e:any)=>any = props.action as any;\r\n    let navigate = useNavigate();\r\n    if (typeof action === 'string') action = (e => R.navigate(`/${props.action}`, navigate));\r\n    let finalaction = (e:any) =>{ props.onClick?.(e); action(e); }\r\n/*\r\n    let url: string = '';\r\n    if (typeof props.action === 'string') url = props.action;*/\r\n    return (<>\r\n\r\n        {/*<Link to={url} className={'item ' + (props.dot ? 'red-dot' : '')}>{props.icon && props.icon}&nbsp;{props.children}</Link>*/}\r\n            <div onClick={finalaction} className={'item ' + (props.dot ? 'red-dot' : '')}>\r\n                {props.icon && props.icon}&nbsp;<span>{props.children}</span>\r\n            </div>\r\n    </>);\r\n}\r\n\r\nconst Upload = () => {\r\n    return(<></>);\r\n    return(\r\n        <div className={'upload'}>\r\n            <i className=\"bi bi-arrow-up-circle\"></i>\r\n            <p>Drop your jjodel project archive here to import it.</p>\r\n        </div>\r\n    );\r\n};\r\n\r\ntype MenuProps = {\r\n    children: any;\r\n    title?: string;\r\n    mode?: \"collapsable\";\r\n    project?: boolean;\r\n};\r\n\r\nconst Menu = (props: MenuProps) => {\r\n    const [open,setOpen] = useState(true);\r\n\r\n    return (<>\r\n\r\n        {props.title && props.mode && open && <i className={'bi bi-chevron-down'} onClick={(e) => setOpen(!open)}></i>}\r\n        {props.title && props.mode && !open && <i className={'bi bi-chevron-right'} onClick={(e) => setOpen(!open)}></i>}\r\n        \r\n\r\n        <div className='menu border-bottom'>\r\n            {isProjectModified() && props.title ? <h1>{props.title} <i className=\"bi bi-circle-fill modified\"></i> </h1> : <h1> {props.title} </h1>}\r\n            <div>\r\n                {open && props.children}\r\n            </div>\r\n        </div>\r\n    </>);\r\n}\r\n\r\nconst Divisor = () => {\r\n    return (<hr className='my-1' />);\r\n};\r\n\r\nMenu.Item = Item;\r\n\r\nfunction LeftBar(props: LeftBarProps): JSX.Element {\r\n\r\n    // export type LeftBarProps = {\r\n    //     active: DashProps['active']; // prende il tipo dal parent-component, così si evita di aggiornare entrambi o avere tipi discordanti.\r\n    //     projects: LProject[];\r\n    //     project?: LProject;\r\n\r\n    // };\r\n\r\n    const {active, project} = props;\r\n    let user: LUser = props.user || L.fromPointer(DUser.current);\r\n\r\n    const selectProject= (project: LProject) => {\r\n        R.navigate(`/project?id=${project.id}`, true);\r\n        U.resetState();\r\n    };\r\n\r\n    const closeProject = () => {\r\n        function doclose(){\r\n            R.navigate('/allProjects', true);\r\n            Collaborative.client.off('pullAction');\r\n            Collaborative.client.disconnect();\r\n            SetRootFieldAction.new('collaborativeSession', false);\r\n            U.resetState();\r\n        }\r\n        /*\r\n        if (isProjectModified()) {\r\n            U.dialog('Close the project without saving?', 'close project', ()=>{\r\n                doclose();\r\n            })\r\n        }\r\n        else doclose();*/\r\n        doclose();\r\n    }\r\n    const toggleFavorite = async() => {\r\n        await ProjectsApi.favorite(project?.__raw as DProject);\r\n    };\r\n    const exportProject = async() => {\r\n        if(project) {\r\n            await ProjectsApi.save(project);\r\n            U.download(`${project?.name}.jjodel`, JSON.stringify(project?.__raw));\r\n        }\r\n    }\r\n\r\n    \r\n\r\n    return(<>\r\n\r\n        {active === 'Project' ?\r\n            <div className={'leftbar border-end border-light-subtle '}>\r\n\r\n                <i className=\"bi bi-search\"></i>\r\n                <input placeholder={'Search for anything'} type={'text'} name='search-text' />\r\n                {/* @ts-ignore */}\r\n                <Menu title={props.project.name ? props.project.name : 'Unnamed Project'} project>\r\n                    {/*<Item icon={icon['edit']}>Edit </Item>*/}\r\n                    <Item action={exportProject} icon={icon['download']}>Download</Item>\r\n                    {/*<Item icon={icon['duplicate']}>Duplicate </Item>*/}\r\n                    <Item action={toggleFavorite} icon={!project?.isFavorite ? icon['favorite'] : icon['favoriteFill']}>{!project?.isFavorite ? 'Add to favorites ' : 'Remove from favorites '}</Item>\r\n                    {/*<Item icon={icon['share']}>Public link </Item>*/}\r\n                    {/*<Item icon={icon['delete']}>Delete </Item>*/}\r\n                    <Item action={closeProject} icon={icon['close']}>Close project </Item>\r\n                </Menu>\r\n\r\n                {/* {props.projects.filter(p => p.favorite).length > 0 &&\r\n                    <Menu title={\"Starred\"} mode={'collapsable'}>\r\n                        {props.projects.filter(p => p.favorite).map(p => <Item icon={icon['folder']} action={e => selectProject()}>{p.name}</Item>)}\r\n                    </Menu>\r\n                } *//*}\r\n\r\n                { <Menu>\r\n                    <Item action={'templates'} icon={icon['template2']}>Templates</Item>\r\n                    <Item action={'notes'} icon={icon['edit']}>Notes</Item>\r\n                </Menu>}\r\n\r\n                <Menu title={'Support'} mode={'collapsable'}>\r\n                    <Item icon={icon['whats-new']}>What's newwew</Item>\r\n                    <Item icon={icon['getting-started']}>Getting started</Item>\r\n                    <Item icon={icon['manual']}>User guide</Item>\r\n                </Menu>*/\r\n                }\r\n\r\n            </div>\r\n            :\r\n            <div className={'leftbar border-end border-light-subtle '}>\r\n\r\n                <i className=\"bi bi-search\"></i>\r\n                <input placeholder={'Search for anything'} type={'text'} name='search-text' />\r\n\r\n\r\n                {user && user.email === 'admin@gmail.it' && <Menu title={'Administration'} mode={'collapsable'}>\r\n                    <Item action={'usersInfo'} icon={icon['profile']}>Users</Item>\r\n                    <Item action={'projectsInfo'} icon={icon['folder']}>Projects</Item>\r\n                    <Item action={'news'} icon={icon['manual']}>News</Item>\r\n                </Menu>}\r\n\r\n                <Menu>\r\n                    <Item action={'allProjects'} icon={icon['dashboard']}>All projects </Item>\r\n                </Menu>\r\n                {props.projects && props.projects.filter(p => p.isFavorite).length > 0 &&\r\n                    <Menu title={\"Starred\"} mode={'collapsable'}>\r\n                        {props.projects\r\n                            .filter(p => p.isFavorite)\r\n                            .map(p => \r\n                                <Item icon={icon['folder']} action={e => selectProject(p)}>{p.name}</Item>\r\n                            )\r\n                        }\r\n                    </Menu>\r\n                }\r\n\r\n                {props.projects && props.projects.filter(p => p.isFavorite).length > 0 &&\r\n                    <Menu title={\"Recent\"} mode={'collapsable'}>\r\n                        {props.projects\r\n                            .sort((a,b) => (b.lastModified > a.lastModified) ?  1 : -1)\r\n                            .slice(0,5)\r\n                            .map(p => <Item icon={icon['folder']} action={e => selectProject(p)}>{p.name}</Item>)}\r\n                    </Menu>\r\n                }\r\n                \r\n                <Menu title={'Support'} mode={'collapsable'}>\r\n                    {/* <Item action={'updates'} icon={icon['whats-new']}\r\n                          dot={+(localStorage.getItem('_jj_update_seen')||0)<+(localStorage.getItem('_jj_update_date')||Number.POSITIVE_INFINITY)}\r\n                          onClick={()=>localStorage.setItem('_jj_update_seen', ''+Date.now())}\r\n                    >What's new</Item>*/}\r\n                    <Item \r\n                        action={() => {R.navigate(\"https://www.jjodel.io/whats-new/\")}}\r\n                        icon={icon['whats-new']}\r\n                    >What's new</Item>\r\n                    <Item \r\n                        action={() => {R.navigate(\"https://www.jjodel.io/getting-started/\")}}\r\n                        icon={icon['getting-started']}\r\n                    >Getting started</Item>\r\n                    <Item \r\n                        action={() => {R.navigate(\"https://www.jjodel.io/manual/\")}}\r\n                        icon={icon['manual']}\r\n                    >User guide</Item>\r\n                </Menu>\r\n\r\n                <Upload />\r\n\r\n            </div>\r\n        }\r\n\r\n    </>)\r\n}\r\n\r\nexport {LeftBar};\r\n","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\pages\\components\\Project.tsx",["924","925"],"import {DProject, LProject, R, U} from '../../joiner';\r\nimport React from \"react\";\r\n\r\nimport {ProjectsApi} from '../../api/persistance';\r\nimport {Divisor, Item, Menu} from './menu/Menu';\r\n\r\nimport card from '../../static/img/card.png';\r\nimport {icon} from './icons/Icons';\r\nimport {Btn, CommandBar, Sep} from '../../components/commandbar/CommandBar';\r\nimport { int } from '../../joiner/types';\r\n\r\nimport { \r\n    VscLock as Lock,\r\n    VscUnlock as UnLock,\r\n    VscBroadcast as Share\r\n} from \"react-icons/vsc\";\r\n\r\nimport { SlShare as Share2 } from \"react-icons/sl\";\r\nimport { Tooltip } from '../../components/forEndUser/Tooltip';\r\nimport { time } from 'console';\r\nimport { Logo } from '../../components/logo';\r\n\r\n\r\nfunction formatDate(lastModified: number){\r\n    \r\n    let timeago = Date.now() - lastModified;\r\n    let timeunit: string;\r\n    let sec = 1000;\r\n    let min = sec*60;\r\n    let hr = min*60;\r\n    let day = hr*24;\r\n    let week = day*7;\r\n    let month = day*24;\r\n    let year = day*365;\r\n\r\n    if (timeago < min) { timeago /= sec; timeunit = 'seconds'; }\r\n    else if (timeago >= min && timeago < hr) { timeago /= min; timeunit = 'minutes'; }\r\n    else if (timeago >= hr && timeago < day) { timeago /= hr; timeunit = 'hours'; }\r\n    else if (timeago >= day && timeago < week) { timeago /= day; timeunit = 'days'; }\r\n    else if (timeago >= week && timeago < month) { timeago /= week; timeunit = 'weeks'; }\r\n    else if (timeago >= month && timeago < year) { timeago /= month; timeunit = 'months'; }\r\n    else { timeago/= min; timeunit = 'years'; }\r\n\r\n    return Math.round(timeago) + ' ' + timeunit + ' ago';\r\n}\r\n\r\n\r\ntype Props = {\r\n    data: LProject;\r\n    mode?: string;\r\n    key: any;\r\n    index?: number; // a che serve? si può togliere?\r\n};\r\n\r\ntype ProjectTypeType = {\r\n    type: string;\r\n}\r\n\r\nfunction ProjectType(props: ProjectTypeType){\r\n    return (<>\r\n        {props.type === \"public\" && <i className=\"bi bi-unlock\"></i>}\r\n        {props.type === \"private\" && <i className=\"bi bi-lock\"></i>}\r\n        {props.type === \"collaborative\" && <i className=\"bi bi-diagram-3\"></i>}\r\n    </>);\r\n}\r\n\r\nfunction Project(props: Props): JSX.Element {\r\n    const {data} = props;\r\n\r\n    // const [favorite, setFavorite] = useState(false);\r\n\r\n    const toggleFavorite = async(project: LProject) => {\r\n        await ProjectsApi.favorite(project.__raw as DProject);\r\n    };\r\n    const selectProject = () => {\r\n        R.navigate(`/project?id=${data.id}`, true);\r\n        //U.resetState();\r\n    }\r\n    const exportProject = async() => {\r\n        // await ProjectsApi.save(data);\r\n        U.download(`${data.name}.jjodel`, JSON.stringify(data.__raw));\r\n    }\r\n    const deleteProject = async() => {\r\n        await ProjectsApi.delete(data);\r\n    }\r\n\r\n    const typeIcon = (type: string) => {\r\n    \r\n        var icon = <></>;\r\n\r\n        switch(type){\r\n            case 'public':\r\n                icon = <UnLock className={'type-icon'} style={{fontSize: '1.2em'}}/>;\r\n                break;\r\n            case 'private':\r\n                icon = <Lock className={'type-icon'} style={{fontSize: '1.2em'}}/>;\r\n                break;\r\n            case 'collaborative':\r\n                icon = <Share2 className={'type-icon'} style={{fontSize: '1.2em'}}/>;\r\n                break;\r\n        }\r\n\r\n        return(\r\n            icon\r\n        );\r\n    \r\n    \r\n    }\r\n\r\n    /* CARDS */\r\n\r\n    var sectionStyle = {\r\n        backgroundImage: `url(${card})`,\r\n        backgroundSize: 'contain'\r\n     }\r\n\r\n    type ProjectProps = {\r\n        project: LProject\r\n    }\r\n\r\n    const Empty = (props: ProjectProps) => {\r\n        return (<>\r\n            {props.project.metamodelsNumber == 0 && props.project.modelsNumber == 0 && <><i title=\"empty project\" className=\"bi bi-exclamation-circle\"></i> <span>Empty</span></>}\r\n            {/* {props.project.metamodels.length == 0 && props.project.models.length != 0 && <i style={{float: 'left'}} title=\"no models\" className=\"bi bi-circle-half\"></i>}\r\n            {props.project.metamodels.length != 0 && props.project.models.length != 0 && <i style={{float: 'left'}} title=\"artifacts present\" className=\"bi bi-circle-fill\"></i>}*/}\r\n        </>);\r\n    }\r\n\r\n    function ProjectCard(props: Props): JSX.Element {\r\n\r\n\r\n        function multiplicity(n: int, none: string, one: string, many: string){\r\n            if (n <= 0) return none;\r\n            if (n === 1) return n + ' ' + one;\r\n            if (n > 1) return n + ' ' + many;\r\n        }\r\n\r\n        function getClickedElement(e: any){\r\n\r\n            if(e.target.className === 'bi bi-star-fill' || e.target.className === 'bi bi-star' || e.target.className === 'bi bi-chevron-down' || e.target.className === 'item') {\r\n                return;\r\n            } else {\r\n                selectProject(); \r\n            }\r\n        }\r\n\r\n        return (\r\n            <Tooltip tooltip={`${props.data.type} project with ${multiplicity(props.data.metamodelsNumber,'no metamodels', 'metamodel', 'metamodels')}, \r\n                ${multiplicity(props.data.modelsNumber,'no models', 'model', 'models')}, \r\n                ${multiplicity(props.data.viewpointsNumber -2, 'no (custom) viewpoints', '(custom) viewpoint', '(custom) viewpoints')}` } position={'top'} offsetY={10} theme={'dark'} inline><div className={`project-card-v2 ${data.type}`} \r\n                onClick={e => getClickedElement(e)}>\r\n                <div className=\"project-actions d-flex\" style={{position: 'absolute', top: 10, right: 5}}>\r\n                    {data.isFavorite ? <i onClick={(e) => toggleFavorite(data)} className=\"bi bi-star-fill\" />\r\n                        :\r\n                        <i onClick={(e) => toggleFavorite(data)} className=\"bi bi-star\" />\r\n                    }\r\n                    \r\n                    <Menu>\r\n                            <Item icon={icon['new']} keystroke={'<i class=\"bi bi-command\"></i>'} action={e => {selectProject()}}>Open</Item>\r\n                            <Item icon={icon['duplicate']}>Duplicate</Item>\r\n                            <Item icon={icon['download']} action={e => exportProject()}>Download</Item>\r\n                            <Divisor />\r\n                            <Item icon={icon['favorite']} action={(e => toggleFavorite(data))}>{!data.isFavorite ? 'Add to favorites' : 'Remove from favorites'}</Item>\r\n                            <Divisor />\r\n                            <Item icon={icon['delete']} action={async e => await deleteProject()}>Delete</Item>\r\n                    </Menu>\r\n                </div>\r\n                <div className='header'>\r\n                    <Logo style={{fontSize: '2em', float: 'left', marginTop: '0px', marginBottom: '20px', marginRight: '10px'}}/>\r\n                    <h5 className={'d-block'} style={{cursor: 'pointer'}} onClick={e => selectProject()}>\r\n                        {data.name}\r\n                    </h5>\r\n                    <p className={'description'}>{data.description}</p>\r\n                    <div className={'last-updated'}>\r\n                        <div className='date'><i className=\"bi bi-clock-history\"></i> Last updated {formatDate(data.lastModified)}</div>\r\n                        \r\n                        <div className={'type'}>\r\n                            {data.type === 'public' && <UnLock className={'type-icon'} style={{fontSize: '1.2em', color: 'var(--bg-4)'}}/>}\r\n                            {data.type === 'private' && <Lock  className={'type-icon'} style={{fontSize: '1.2em', color: 'var(--bg-4)'}}/>} \r\n                            {data.type === 'collaborative' && <Share2 className={'type-icon'} style={{fontSize: '1.2em', color: 'var(--bg-4)'}}/>} \r\n                        </div>\r\n                    </div>                   \r\n                </div>\r\n            </div></Tooltip>);\r\n        }\r\n\r\n\r\n    /* LIST */\r\n\r\n    function ProjectList(props: Props): JSX.Element {\r\n\r\n        let timeago = Date.now() - data.lastModified;\r\n        let timeunit: string;\r\n        let sec = 1000;\r\n        let min = sec*60;\r\n        let hr = min*60;\r\n        let day = hr*24;\r\n        let week = day*7;\r\n        let month = day*24;\r\n        let year = day*365;\r\n\r\n        if (timeago < min) { timeago /= sec; timeunit = 'seconds'; }\r\n        else if (timeago >= min && timeago < hr) { timeago /= min; timeunit = 'minutes'; }\r\n        else if (timeago >= hr && timeago < day) { timeago /= hr; timeunit = 'hours'; }\r\n        else if (timeago >= day && timeago < week) { timeago /= day; timeunit = 'days'; }\r\n        else if (timeago >= week && timeago < month) { timeago /= week; timeunit = 'weeks'; }\r\n        else if (timeago >= month && timeago < year) { timeago /= month; timeunit = 'months'; }\r\n        else { timeago/= min; timeunit = 'years'; }\r\n\r\n\r\n        function timeConverter(UNIX_timestamp: int){\r\n            var a = new Date(UNIX_timestamp);\r\n            \r\n            const formattedDate2 = a.toISOString();\r\n\r\n            const formattedDate = new Intl.DateTimeFormat('en-US', {\r\n                day: '2-digit',\r\n                month: 'short', // \"long\" for full month name\r\n                year: 'numeric',\r\n                hour: '2-digit',\r\n                minute: '2-digit',\r\n                //second: '2-digit',\r\n                //fractionalSecondDigits: 3, // Includes milliseconds\r\n                //timeZone: 'UTC', // Optional, set the timezone\r\n              }).format(a);\r\n\r\n            return formattedDate;\r\n        }\r\n\r\n        return (<>\r\n            <div className=\"row data\">\r\n                \r\n                <div style={{paddingLeft: '15px'}} className={'col-4'} onClick={()=> {selectProject()}}>{data.name}</div>\r\n                <div className={'col-1'} onClick={()=> {selectProject()}}>{typeIcon(data.type)}</div>\r\n                <div className={'col-3'} onClick={()=> {selectProject()}}>{timeConverter(data.creation+0)}</div>\r\n                <div className={'col-2'} onClick={()=> {selectProject()}}>{Math.floor(timeago)} {timeunit} ago</div>\r\n                <div className={'col-2'}>\r\n                    <CommandBar noBorder={true} style={{marginBottom: '0'}}>\r\n                        <Btn icon={'favorite'} action={(e => toggleFavorite(data))} tip={!data.isFavorite ? 'Add to favorites' : 'Remove from favorites'} />\r\n                        <Btn icon={'minispace'} />\r\n                        <Btn icon={'copy'} action={e => props.data.duplicate()} tip={'Duplicate project'}/>\r\n                        <Btn icon={'minispace'} />\r\n                        <Btn icon={'download'} action={e => exportProject()} tip={'Download project'}/>\r\n                        <Sep />\r\n                        <Btn icon={'delete'} action={async e => await deleteProject()} tip={'Delete project'}/>\r\n                    </CommandBar>\r\n                </div>\r\n            </div>\r\n        </>);\r\n    }\r\n\r\n\r\n    return(<>\r\n        {props.mode === \"cards\" ?\r\n            <ProjectCard index={props.index} key={props.key} data={props.data} /> :\r\n            <ProjectList index={props.index}  key={props.key} data={props.data} />\r\n        }\r\n    </>);\r\n}\r\n\r\nexport {Project};\r\n","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\pages\\components\\Navbar.tsx",["926"],"import './style.scss';\r\nimport './navbar.scss';\r\nimport {\r\n    Dictionary,\r\n    DModel,\r\n    DProject,\r\n    DState,\r\n    DUser,\r\n    Input,\r\n    Keystrokes,\r\n    L,\r\n    LGraph,\r\n    LModel,\r\n    LPackage,\r\n    LProject,\r\n    LUser,\r\n    Selectors,\r\n    SetRootFieldAction,\r\n    TRANSACTION,\r\n    store,\r\n    U,\r\n    R\r\n} from '../../joiner';\r\n\r\nimport {icon} from '../components/icons/Icons';\r\n\r\nimport {useNavigate} from 'react-router-dom';\r\n\r\nimport React, {Component, Dispatch, ReactElement, useState} from 'react';\r\nimport {FakeStateProps} from '../../joiner/types';\r\nimport {connect} from 'react-redux';\r\nimport {MetamodelPopup, ModelPopup} from './popups';\r\nimport {AuthApi, ProjectsApi} from '../../api/persistance';\r\nimport TabDataMaker from \"../../../src/components/abstract/tabs/TabDataMaker\";\r\nimport DockManager from \"../../../src/components/abstract/DockManager\";\r\n\r\nimport {Divisor, Item, Menu} from '../components/menu/Menu';\r\n\r\nimport Collaborative from \"../../components/collaborative/Collaborative\";\r\nimport { isProjectModified } from '../../common/libraries/projectModified';\r\nimport { AboutModal } from './about/About';\r\nimport { MetricsPanelManager } from '../../components/metrics/Metrics';\r\nimport Api from '../../data/api';\r\nimport {Undoredocomponent} from \"../../components/topbar/undoredocomponent\";\r\n\r\n\r\nlet windoww = window as any;\r\n\r\nfunction createM2(project: LProject) {\r\n    let name = 'metamodel_' + 1;\r\n    let names: string[] = Selectors.getAllMetamodels().map(m => m.name);\r\n    name = U.increaseEndingNumber(name, false, false, newName => names.indexOf(newName) >= 0);\r\n    const dModel = DModel.new(name, undefined, true);\r\n    const lModel: LModel = LModel.fromD(dModel);\r\n    project.metamodels = [...project.metamodels, lModel];\r\n    project.graphs = [...project.graphs, lModel.node as LGraph];\r\n    const dPackage = lModel.addChild('package');\r\n    const lPackage: LPackage = LPackage.fromD(dPackage);\r\n    lPackage.name = 'default';\r\n    const tab = TabDataMaker.metamodel(dModel);\r\n    DockManager.open('models', tab);\r\n}\r\n\r\nconst createM1 = (project: LProject, metamodel: LModel) => {\r\n    let name = 'model_' + 1;\r\n    let modelNames: (string)[] = metamodel.models.map(m => m.name);\r\n    name = U.increaseEndingNumber(name, false, false, newName => modelNames.indexOf(newName) >= 0);\r\n    const dModel: DModel = DModel.new(name, metamodel.id, false, true);\r\n    const lModel: LModel = LModel.fromD(dModel);\r\n    project.models = [...project.models, lModel];\r\n    project.graphs = [...project.graphs, lModel.node as LGraph];\r\n    const tab = TabDataMaker.model(dModel);\r\n    DockManager.open('models', tab);\r\n}\r\nfunction getKeyStrokes(keys?: string[]){\r\n    if (!keys || !keys.length) return undefined;\r\n    return <div className={\"keystrokes\"}>\r\n        {keys.map(k => Keystrokes.getKeystrokeJsx(k))}\r\n    </div>\r\n}\r\n\r\nlet globalProject: LProject|undefined = undefined as any;\r\nfunction makeEntry(i: MenuEntry, index: number) {\r\n    if (!i) return;\r\n    let isUndo = (i.name === \"Undo\" || i.name === \"Redo\");\r\n    // if (true as any) return <li >{i.name}</li>;\r\n\r\n    if (i.name === \"Redo\") { return null; }\r\n    if (i.name === \"Undo\") {\r\n        if (!globalProject) return null;\r\n        return <Undoredocomponent key={'undo'} project={globalProject} />\r\n    }\r\n    if (i.name === \"divisor\") {\r\n        return (\r\n            <li key={index} className='divisor'>\r\n                <hr />\r\n            </li>\r\n        );\r\n    } else {\r\n        if (i.subItems && i.subItems.length === 0) return undefined;\r\n        let slength = i.subItems ? i.subItems.length : 0;\r\n\r\n        let hasSubItems = (!i.disabled && slength > 0) || isUndo;\r\n\r\n        return (\r\n            <li className={hasSubItems ? \"hoverable\" : \"\"} key={i.name} tabIndex={0} onClick={()=>i.function?.()}>\r\n                <label className={`highlight ${i.disabled ? 'disabled' : ''}`}>\r\n                    <span>{i.icon || <i className=\"bi bi-app hidden\"/>} <span>{i.name}</span></span>\r\n                    {!i.disabled && slength > 0 ?\r\n                        <i className='bi bi-chevron-right icon-expand-submenu'/> :\r\n                        getKeyStrokes(i.keystroke)\r\n                    }\r\n                </label>\r\n            {hasSubItems &&\r\n                <div className='content right'>\r\n                    <ul className='context-menu right'>\r\n                        {i.subItems && i.subItems.map((si, index) => makeEntry(si, index))}\r\n                    </ul>\r\n                </div>\r\n            }\r\n            </li>\r\n        );\r\n    }\r\n}\r\n\r\n\r\n\r\ntype UserProps = {}\r\nconst User = (props: UserProps) => {\r\n    const user: LUser = LUser.fromPointer(DUser.current);\r\n    const name = `${user?.name} ${user?.surname}`;\r\n    const initials = name.split(' ').map(n=>n[0]).join('');\r\n    return (<div className={'user text-end'}>\r\n        <div className={'initials'}>\r\n            {initials.toUpperCase()}\r\n        </div>\r\n        &nbsp;&nbsp;\r\n        <span>{name}</span>\r\n    </div>);\r\n};\r\n\r\ntype MenuEntry = {\r\n    name: string,\r\n    icon?: any,\r\n    function?: ()=>any,\r\n    keystroke?: string[],\r\n    subItems?:MenuEntry[],\r\n    disabled?: boolean;\r\n} | null;\r\n\r\nfunction NavbarComponent(props: AllProps) {\r\n    const {version, metamodels, advanced, debug, project} = props;\r\n    const [focussed, setFocussed] = useState('');\r\n    const [clicked, setClicked] = useState('');\r\n    const navigate = useNavigate();\r\n    globalProject = project;\r\n\r\n    const open = (url: string) => { window.open(url, '_blank'); }\r\n\r\n    const Key = Keystrokes;\r\n    let projectItems2: MenuEntry[] = [];\r\n\r\n    if (project){\r\n        projectItems2 = [\r\n\r\n            /* New Metamodel */\r\n\r\n            {name: 'New metamodel', icon: icon['new'], function: () => createM2(project), keystroke: [Key.alt, Key.cmd, 'M']},\r\n\r\n            /* New Model */\r\n            {\r\n                name: 'New model',\r\n                icon: icon['new'],\r\n                subItems: project.metamodels.filter(m2=>!!m2).map((m2, i)=>({\r\n                    name: m2.name, function: () => createM1(project, m2), keystroke: []\r\n                })),\r\n                disabled: project.metamodels.length == 0\r\n            },\r\n\r\n            /* ----- */\r\n\r\n            {name: 'divisor', function: () => {}, keystroke: []},\r\n\r\n            /* Close */\r\n\r\n            {name: 'Close', icon: icon['close'], function: () => {\r\n                if (isProjectModified()) {\r\n                    U.dialog('Close the project without saving?', 'close project', ()=>{\r\n                        R.navigate('/allProjects');\r\n                        Collaborative.client.off('pullAction');\r\n                        Collaborative.client.disconnect();\r\n                        SetRootFieldAction.new('collaborativeSession', false);\r\n                        U.resetState();\r\n                    });\r\n                } else {\r\n                    R.navigate('/allProjects');\r\n                    Collaborative.client.off('pullAction');\r\n                    Collaborative.client.disconnect();\r\n                    SetRootFieldAction.new('collaborativeSession', false);\r\n                    U.resetState();\r\n                }\r\n            }, keystroke: [Key.cmd, 'W']},\r\n\r\n            /* ----- */\r\n\r\n            {name: 'divisor', function: () => {}, keystroke: []},\r\n\r\n            /* Save & Close */\r\n\r\n            {name: 'Save & Close', icon: icon['close'], function: async () => {\r\n                if (isProjectModified()) {\r\n                    await ProjectsApi.save(project);\r\n                }\r\n\r\n                R.navigate('/allProjects');\r\n                Collaborative.client.off('pullAction');\r\n                Collaborative.client.disconnect();\r\n                SetRootFieldAction.new('collaborativeSession', false);\r\n                U.resetState();\r\n            }, keystroke: []},\r\n\r\n            /* Save */\r\n\r\n            {name: 'Save', icon: icon['save'], function: async() => {\r\n                await ProjectsApi.save(project);\r\n            }, keystroke: [Key.cmd, 'S']},\r\n\r\n\r\n\r\n            /* Download */\r\n\r\n            {name: 'Download', icon: icon['download'], function: async() => {\r\n                await ProjectsApi.save(project);\r\n                U.download(`${project.name}.jjodel`, JSON.stringify(project.__raw));\r\n            }, keystroke: []},\r\n\r\n\r\n\r\n            /* ----- */\r\n\r\n            {name: 'divisor', function: () => {}, keystroke: []},\r\n\r\n            /* Help */\r\n\r\n            {name: 'Help', icon: icon['help'], subItems: [\r\n                {name: 'What\\'s new', icon: icon['whats-new'], function: async() => {R.navigate(\"https://www.jjodel.io/whats-new/\")}, keystroke: []},\r\n                {name: 'divisor', function: async() => {}, keystroke: []},\r\n                {name: 'Homepage', icon: icon['home'], function: async() => {R.navigate(\"https://www.jjodel.io/\")}, keystroke: []},\r\n                {name: 'Getting started', icon: icon['getting-started'], function: async() => {R.navigate(\"https://www.jjodel.io/getting-started/\")}, keystroke: []},\r\n                {name: 'User guide', icon: icon['manual'], function: async() => {R.navigate(\"https://www.jjodel.io/manual/\")}, keystroke: []},\r\n                {name: 'divisor', function: async() => {}, keystroke: []},\r\n                {name: 'Legal terms', icon: icon['legal'], function: async() => {R.navigate(\"https://www.jjodel.io/terms-conditions-page/\")}, keystroke: []}\r\n            ],\r\n            keystroke: []}\r\n        ];\r\n    }\r\n\r\n    const dashboardItems2: MenuEntry[] = [\r\n\r\n        {name: 'New project', icon: <i className=\"bi bi-plus-square\"></i>, function:\r\n            async()=>{\r\n                R.navigate('/allProjects');\r\n                await ProjectsApi.create('public', undefined, undefined, undefined, props.user?.projects);\r\n                /*\r\n                SetRootFieldAction.new('isLoading', true);\r\n                await U.sleep(1);\r\n                await ProjectsApi.create('public', 'Unnamed Project');\r\n                SetRootFieldAction.new('isLoading', false);*/\r\n            },\r\n            keystroke: [Key.cmd, 'M']},\r\n            {name: 'divisor', function: () => {}, keystroke: []},\r\n\r\n        {name: 'Import...', icon: <i className=\"bi bi-arrow-bar-left\"></i>, function: ProjectsApi.import, keystroke: []},\r\n        {name: 'divisor', function: () => {}, keystroke: []},\r\n        {name: 'Help', icon: <i className=\"bi bi-question-square\"></i>, subItems: [\r\n            {name: 'What\\'s new', icon: <i className=\"bi bi-clock\"></i>, function: () => {R.navigate(\"https://www.jjodel.io/whats-new/\", navigate)}, keystroke: []},\r\n            {name: 'divisor', function: () => {}, keystroke: []},\r\n            {name: 'Homepage', icon: <i className=\"bi bi-house\"></i>, function: () => {R.navigate(\"https://www.jjodel.io/\", navigate)}, keystroke: []},\r\n            {name: 'Getting started', icon: <i className=\"bi bi-airplane\"></i>, function: () => {R.navigate(\"https://www.jjodel.io/getting-started/\", navigate)}, keystroke: []},\r\n            {name: 'User guide', icon: <i className=\"bi bi-journals\"></i>, function: () => {R.navigate(\"https://www.jjodel.io/manual/\", navigate)}, keystroke: []},\r\n            {name: 'divisor', function: () => {}, keystroke: []},\r\n            {name: 'Legal terms', icon: <i className=\"bi bi-mortarboard\"></i>, function: () => {R.navigate(\"https://www.jjodel.io/terms-conditions-page/\", navigate)}, keystroke: []}\r\n        ],\r\n        keystroke: []},\r\n\r\n        {name: 'About jjodel', icon: <i className=\"bi bi-info-square\"></i>, function: () => {}, keystroke: []},\r\n        {name: 'divisor', function: () => {}, keystroke: []},\r\n        {name: 'Logout', icon: <i className=\"bi bi-box-arrow-right\"></i>, function: async() => {\r\n                await AuthApi.logout();\r\n                R.navigate('/auth', true);\r\n            }, keystroke: [Key.cmd, 'Q']}\r\n    ];\r\n\r\n\r\n\r\n    /* -- */\r\n\r\n    const recentProjects: MenuEntry[] = [];\r\n    const recentProjectsDisabled: MenuEntry[] = [];\r\n    let user: LUser = L.fromPointer(DUser.current); // props.user || L.fromPointer(DUser.current);\r\n\r\n\r\n\r\n    /*\r\n\r\n        The following is used for toggling fullscreen mode from the View menu\r\n\r\n    */\r\n\r\n    const [fullscreen, setFullscreen] = useState(false);\r\n\r\n    function isFullscreen() {\r\n        return fullscreen;\r\n    }\r\n\r\n    function toggleFullScreen() {\r\n        const elem = document.body;\r\n        setFullscreen(U.toggleFullscreen(elem));\r\n    }\r\n\r\n    /*\r\n\r\n        An error occurs in 'Recent projects' when a project is selected, then is saved - at this points all projects in user.projects are lost\r\n\r\n    */\r\n\r\n    /* retrieve all projects */\r\n\r\n    // if (user.projects[0]) {\r\n    //     localStorage.setItem('projects', JSON.stringify(user.projects));\r\n    //     let projects = user.projects;\r\n    // } else {\r\n    //     let projects = JSON.parse(localStorage.getItem('projects') || '[]');\r\n    // }\r\n\r\n\r\n    /* -- */\r\n\r\n    if (user?.projects) {\r\n\r\n        user.projects\r\n            .sort((a,b) => (b.lastModified > a.lastModified) ?  1 : -1)\r\n            .slice(0,20)\r\n            .map(p =>\r\n                recentProjects.push({name: p.name, function: ()=>{alert(p.name)}, icon: icon['project']})\r\n            );\r\n\r\n        user.projects\r\n            .sort((a,b) => (b.lastModified > a.lastModified) ?  1 : -1)\r\n            .slice(0,20)\r\n            .map(p =>\r\n                recentProjectsDisabled.push({name: p.name, function: ()=>{alert(p.name)}, icon: icon['project'], disabled: true})\r\n            );\r\n    }\r\n\r\n    let newModel: MenuEntry[] = [];\r\n\r\n    if (project && project.metamodels.length > 0) {\r\n        newModel.push({\r\n            name: 'Model',\r\n            icon: icon['model'],\r\n            subItems: project.metamodels.filter(m2=>!!m2).map((m2, i)=>({\r\n                name: m2.name, function: () => createM1(project, m2), keystroke: []\r\n            }))\r\n        });\r\n    } else {\r\n        newModel.push({\r\n            name: 'Model',\r\n            icon: icon['model'],\r\n            disabled: true\r\n        });\r\n    }\r\n\r\n\r\n    const isDashboard = !project;\r\n    const isProject = !!project;\r\n\r\n    const items: MenuEntry[] = [\r\n\r\n        // Jjodel OK\r\n\r\n        {name: 'Jjodel',\r\n            subItems: [\r\n                {name: 'About Jjodel',function: () => {AboutModal.open();}, icon: icon['jjodel']},\r\n                {name: 'Roadmap',function: () => open('https://www.jjodel.io/roadmap/'), icon: icon['roadmap']},\r\n                {name: 'divisor'},\r\n\r\n                {name: 'Settings', function: ()=> alert(), icon: icon['settings'], disabled: true}, // TO-DO\r\n                {name: 'divisor'},\r\n                {name: 'Logout', function: async() => {\r\n                        if (isProjectModified()) {\r\n                            U.dialog('You are about to log out without saving your project. Do you want to proceed?', 'logout', async ()=>{\r\n                                await AuthApi.logout();\r\n                                R.navigate('/auth');\r\n                            });\r\n                        } else {\r\n                            await AuthApi.logout();\r\n                            R.navigate('/auth');\r\n                        }},\r\n                    icon: icon['logout']}\r\n            ]},\r\n\r\n        /* File */\r\n\r\n        {name: 'File',\r\n            subItems: [\r\n                {name: 'New',function: () => {}, icon: icon['new'],\r\n                    subItems: [\r\n                        {name: 'Project', function: () => {}, icon: icon['project'], disabled: true},\r\n                        isDashboard ? null : {name: 'Metamodel', icon: icon['metamodel'], function: ()=>{ project && createM2(project); }, keystroke: [Key.alt, Key.cmd, 'M']},\r\n                        isDashboard ? null : newModel[0]\r\n                    ]\r\n                },\r\n                /* Recent Projects OK - va sistemato il refersh dei progetti */\r\n                {name: 'Recent Projects',function: () => {}, icon: icon['recent'], subItems: recentProjects},\r\n\r\n                /* Import Project OK */\r\n                isProject ? null : {name: 'Import Project', function: ProjectsApi.import, icon: icon['import']},\r\n                {name: 'divisor'},\r\n\r\n                /* Save Project OK */\r\n\r\n                isDashboard ? null : {name: 'Save Project',\r\n                    function: async () => {\r\n                        if (project) {\r\n                            try {\r\n                                await ProjectsApi.save(project);\r\n                            } catch (error: any) {\r\n                                U.alert('e', 'Error while Saving Project', error.message);\r\n                            }\r\n                        }\r\n                    }\r\n                    , icon: icon['save'], keystroke: [Key.cmd, 'S']},\r\n\r\n                /* Close Project OK */\r\n\r\n                isDashboard ? null : {name: 'Close Project',function: async() => {\r\n                        if (isProjectModified()) {\r\n                            U.dialog('Close the project without saving?', 'close project', async()=>{\r\n                                Collaborative.client.off('pullAction');\r\n                                await Collaborative.client.disconnect();\r\n                                SetRootFieldAction.new('collaborativeSession', false);\r\n                                U.resetState();\r\n                                R.navigate('/allProjects', true);\r\n                            });\r\n                        } else {\r\n                            Collaborative.client.off('pullAction');\r\n                            await Collaborative.client.disconnect();\r\n                            SetRootFieldAction.new('collaborativeSession', false);\r\n                            U.resetState();\r\n                            R.navigate('/allProjects', true);\r\n                        }\r\n                    }, icon: icon['close'], keystroke: [Key.cmd, 'E']},\r\n\r\n                /* Delete Project - vedere come fare  TEMPORARLY DISABLED */\r\n                true as any ? null : {name: 'Delete Project', function: ()=>{}, icon: icon['delete'], disabled: true},\r\n\r\n                /* Download Project OK */\r\n\r\n                isDashboard ? null : {name: 'Download Project', function: async() => {\r\n                        if (project) {\r\n                            await ProjectsApi.save(project);\r\n                            U.download(`${project.name}.jjodel`, JSON.stringify(project.__raw));\r\n                        }\r\n                    }, icon: icon['download']}\r\n            ]},\r\n\r\n        /* Edit: Damiano aggiungere funzioni undo/redo */\r\n\r\n        isDashboard ? null : {name: 'Edit',\r\n            subItems: [\r\n                {name: 'Undo',function: () => {}, icon: icon['undo'], keystroke: [Key.cmd, 'Z']},\r\n                {name: 'Redo',function: () => {}, icon: icon['redo'], keystroke: [Key.cmd, 'Y'], subItems:[{name:\"i\"}]},\r\n                /*\r\n                {name: 'Undo',function:()=>{undo(1)}, disabled:disabledUndo, icon: icon['undo'],\r\n                    keystroke: [Key.cmd, 'Z'], subItems:hoverUndo},\r\n                {name: 'Redo',function:()=>{redo(1)}, disabled:disabledRedo, icon: icon['redo'],\r\n                    keystroke: [Key.shift, Key.cmd, 'Z'], subItems:hoverRedo},\r\n                */\r\n                {name: 'divisor'},\r\n                {name: 'Add to Favorites', function: () => {}, icon: icon['favorite']}, // vedere in leftbar // TODO\r\n                {name: 'Copy Public Link', function: () =>{}, icon: icon['link'], keystroke: [Key.cmd, Key.shift, 'S']} // vedere in scheda progetto // TODO\r\n            ]\r\n        },\r\n\r\n        /* View - da fare */\r\n        isDashboard ? null : {name: 'View',\r\n            subItems: [\r\n                {name: 'Zoom-in', function: ()=>{}, icon: icon['zoom-in'], disabled: true}, // TODO\r\n                {name: 'Zoom-out', function: ()=>{}, icon: icon['zoom-out'], disabled: true}, // TODO\r\n\r\n                {name: 'divisor'},\r\n                {name: 'Toggle Grid', function: ()=>{}, icon: icon['toggle-grid'], disabled: true}, // TODO\r\n                {name: 'Toggle Snap-to-Grid', function: ()=>{}, icon: icon['toggle-snap'], disabled: true}, // TODO\r\n\r\n                {name: 'divisor'},\r\n                {name: 'Show/Hide Sidebar', function: ()=>{}, icon: icon['sidebar'], disabled: true}, // TODO\r\n                {name: 'Show/Hide Toolbar', function: ()=>{}, icon: icon['toolbar2'], disabled: true}, // TODO\r\n\r\n                {name: `${isFullscreen() ? 'Exit Fullscreen Mode' : 'Fullscreen Mode'}`, function: ()=>{toggleFullScreen()}, icon: icon['fullscreen']},\r\n                {name: 'Reset Layout', function: ()=>{}, icon: icon['reset-layout'], disabled: true} // TODO\r\n            ]\r\n        },\r\n        /* ANALYZE - da fare */\r\n\r\n        isDashboard ? null : {name: 'Analyze',\r\n            subItems: [\r\n                {name: 'Live Validation',function: () => {},icon: icon['validation'], disabled: true}, // TODO\r\n                {name: 'Validate',function: () => {}, icon: icon['validate'], disabled: true}, // TODO\r\n                {name: 'divisor'},\r\n                {name: 'Analytics', function: () => {}, icon: icon['metrics'], disabled: true} // TODO\r\n\r\n            ]\r\n        },\r\n\r\n        /* HELP ok */\r\n\r\n        {name: 'Help',\r\n            subItems: [\r\n                {name: 'What\\'s New in Jjodel',function: () => open(\"https://www.jjodel.io/whats-new/\"),icon: <i className=\"bi bi-bell\" />},\r\n                {name: 'divisor'},\r\n                {name: 'Homepage',function: () => open(\"https://www.jjodel.io\"), icon: <i className=\"bi bi-house\" />},\r\n                {name: 'divisor'},\r\n                {name: 'Learn Jjodel', function: () => open(\"https://www.jjodel.io/learn-jjodel/\"), icon: icon['learn']},\r\n                {name: 'Getting Started', function: ()=> open(\"https://www.jjodel.io/getting-started/\"), icon: icon['getting-started']},\r\n                {name: 'Video Tutorials', function: ()=> open(\"https://www.jjodel.io/video-tutorials/\"), icon: icon['video']},\r\n                {name: 'User Guide', function: ()=> open('https://www.jjodel.io/getting-started/'), icon: <i className=\"bi bi-journal-text\" />},\r\n                {name: 'Glossary', function: ()=> open('https://www.jjodel.io/glossary/'), icon: <i className=\"bi bi-book\" />},\r\n                {name: 'FAQ',function: () => {}, icon: icon['faq'], disabled: true},\r\n                {name: 'divisor'},\r\n                {name: 'Support', function: ()=>{}, icon: icon['support'],\r\n                    subItems: [\r\n                        {name: 'Report a Bug', function: ()=>{}, icon: icon['report-bug'], disabled: true}, // TODO\r\n                        {name: 'Request a Feature', function: ()=>{}, icon: icon['feature-request'], disabled: true}, // TODO\r\n                        {name: 'Contact', function: ()=>{}, icon: icon['contact'], disabled: true} // TODO\r\n                    ]}\r\n            ]}\r\n\r\n    ];\r\n\r\n\r\n    let itemsToRegister: MenuEntry[] = items; // [...items]; // [...dashboardItems, ...projectItems];\r\n    let keybindings = U.flattenObjectByKey(itemsToRegister, 'subItems')\r\n        .filter(e=> e && (e.keystroke?.length));\r\n    Keystrokes.register('#root', keybindings);\r\n\r\n    type MenuProps = {\r\n        title?: string;\r\n        items: MenuEntry[];\r\n    }\r\n\r\n    const MainMenu = (props: MenuProps) => {\r\n        return(<>\r\n                { props.items.map(m => !m || !m.subItems?.length ? null : <Submenu key={m.name} title={m.name} items={m.subItems} />) }\r\n            </>\r\n        );\r\n    }\r\n\r\n    const Submenu = (props: MenuProps) => {\r\n        return (<div className='nav-hamburger hoverable inline' key={props.title} tabIndex={0}>\r\n            {props.title && <span className={'menu-title'} key={'title'}>{props.title}</span>}\r\n            <div className={'content context-menu'} key={'content'}>\r\n                <ul>\r\n                    {props.items && props.items.map((i, index) => makeEntry(i, index))}\r\n                </ul>\r\n            </div>\r\n        </div>\r\n    )}\r\n\r\n    const MainMenu2 = (props: MenuProps) => {\r\n\r\n        return(\r\n            <div className='nav-hamburger hoverable' tabIndex={0}>\r\n                <i className=\"bi bi-grid-3x3-gap-fill list\"></i>\r\n                <div className={'content context-menu'}>\r\n                    <ul>\r\n                        { props.items.map((i, index) => makeEntry(i, index)) }\r\n                    </ul>\r\n                </div>\r\n            </div>\r\n        );\r\n    };\r\n\r\n    const MainLogo = () => {\r\n        let toggleDebug = (e: any)=>{\r\n            e.preventDefault();\r\n            TRANSACTION('debug', ()=>SetRootFieldAction.new('debug', !props.debug), props.debug, !props.debug);\r\n            U.debug = !props.debug;\r\n        }\r\n        return (\r\n        <div className='nav-logo'>\r\n            <div className={\"aligner\"}>\r\n\r\n                {props.debug ?\r\n                    <div className='logo-on' onContextMenu={toggleDebug}></div>\r\n                    :\r\n                    <div className='logo' onContextMenu={toggleDebug}></div>\r\n                }\r\n                {props.debug && <i className=\"bi bi-bug-fill\"></i>}\r\n\r\n            </div>\r\n        </div>\r\n        );\r\n    }\r\n\r\n    const Commands = () => {\r\n        return (<label className='text-end nav-commands d-flex'>\r\n            {project && <>\r\n                <span className={\"my-auto me-1\"}>{props.advanced ? \"advanced\" : \"base\"}</span>\r\n                <Input type=\"toggle\"\r\n                       className={\"my-auto\"}\r\n                       style={{fontSize:'1.25em'}}\r\n                       setter={(v) => {\r\n                           SetRootFieldAction.new('advanced', v);\r\n                           windoww.advanced = v;\r\n                       }}\r\n                       getter={() => props.advanced}/>\r\n            </>\r\n            }\r\n        </label>);\r\n    };\r\n\r\n    const UserMenu = () => {\r\n        return (<>\r\n        <div className='text-end nav-side'>\r\n                <div style={{float: 'right', left: '300px!important', marginTop: '2px'}}>\r\n                    <Menu position={'left'}>\r\n                        <Item icon={icon['dashboard']} action={async() => {\r\n                            Collaborative.client.off('pullAction');\r\n                            await Collaborative.client.disconnect();\r\n                            SetRootFieldAction.new('collaborativeSession', false);\r\n                            U.resetState();\r\n                            R.navigate('/allProjects');\r\n                        }}>Dashboard</Item>\r\n                        <Divisor />\r\n                        <Item icon={icon['profile']} action={()=> {\r\n                            R.navigate('/account');\r\n                            U.resetState();\r\n                        }}>Profile</Item>\r\n                        <Item icon={icon['settings']} action={(e)=> {alert('')}}>Settings</Item>\r\n                        <Divisor />\r\n                        <Item icon={icon['logout']} action={async () => {\r\n                            if (isProjectModified()) {\r\n                                U.dialog('You are about to log out without saving your project. Do you want to proceed?', 'logout', async ()=>{\r\n                                    await AuthApi.logout();\r\n                                    R.navigate('/auth');\r\n                                });\r\n                            } else {\r\n                                await AuthApi.logout();\r\n                                R.navigate('/auth');\r\n                            }\r\n                        }}>Logout</Item>\r\n                    </Menu>\r\n                </div>\r\n            </div>\r\n        </>);\r\n    }\r\n\r\n    return(<>\r\n        <nav className={'w-100 nav-container d-flex'} style={{zIndex: 99}}>\r\n            <MainMenu items={items} />\r\n            <MainLogo />\r\n            <UserMenu />\r\n            <Commands />\r\n            <User />\r\n        </nav>\r\n\r\n        {project && clicked === 'new.metamodel' && <MetamodelPopup {...{project, setClicked}} />}\r\n        {project && clicked === 'new.model' && <ModelPopup {...{metamodels, project, setClicked}} />}\r\n    </>);\r\n}\r\n\r\ninterface OwnProps {}\r\ninterface StateProps {\r\n    user: LUser;\r\n    project?: LProject;\r\n    metamodels: LModel[];\r\n    version: DState['version'];\r\n    advanced: boolean;\r\n    debug: boolean;\r\n}\r\ninterface DispatchProps {}\r\ntype AllProps = OwnProps & StateProps & DispatchProps;\r\n\r\n\r\nfunction mapStateToProps(state: DState, ownProps: OwnProps): StateProps {\r\n    const ret: StateProps = {} as FakeStateProps;\r\n    ret.user = LUser.fromPointer(DUser.current);\r\n    ret.project = ret.user?.project || undefined;\r\n    ret.metamodels = LModel.fromArr(state.m2models);\r\n    ret.version = state.version;\r\n    ret.advanced = state.advanced;\r\n    ret.debug = state.debug;\r\n    return ret;\r\n}\r\n\r\nfunction mapDispatchToProps(dispatch: Dispatch<any>): DispatchProps {\r\n    const ret: DispatchProps = {};\r\n    return ret;\r\n}\r\n\r\nconst NavbarConnected = connect<StateProps, DispatchProps, OwnProps, DState>(\r\n    mapStateToProps,\r\n    mapDispatchToProps\r\n)(NavbarComponent);\r\n\r\nconst Navbar = (props: OwnProps, children: (string | Component)[] = []): ReactElement => {\r\n    return <NavbarConnected {...{...props, children}} />;\r\n}\r\n\r\nexport {Navbar};\r\n","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\pages\\components\\BottomBar.tsx",["927"],"import './style.scss';\r\nimport {DState, DUser, LGraphElement, LModelElement, LUser, U} from \"../../joiner\";\r\nimport {FakeStateProps} from \"../../joiner/types\";\r\nimport React, {Dispatch, ReactElement, useState} from \"react\";\r\nimport {connect} from \"react-redux\";\r\n\r\n\r\nimport swen from '../../static/img/swen-splash.png';\r\nimport { About } from './about/About';\r\n\r\nenum notificationType {\r\n    Clients = 0,\r\n    Terminal = 1,\r\n    Messages = 2\r\n  }\r\n\r\nenum alertType {\r\n    Normal = 0,\r\n    Success = 1,\r\n    RequireAttention = 2,\r\n    Alert = 3,\r\n    Error = 4\r\n}\r\n\r\ntype Props = {\r\n    type: notificationType;\r\n    alert: alertType;\r\n    message: string;\r\n\r\n};\r\n\r\n\r\nconst JjodelName = () => {\r\nconst [animal, setAnimal] = useState(false);\r\n\r\n\r\n    return (<>\r\n        <div className={'jjodel'}>\r\n            <span><About ver={'1.6'} name={'manatee'} /></span>\r\n        </div>\r\n        </>);\r\n}\r\n\r\nfunction BottomBarComponent(props: AllProps): JSX.Element {\r\n    const [swenOpen, setSwen] = useState(false);\r\n    const {node,data} = props;\r\n    let nodepos: string | undefined;\r\n    if (node) {\r\n        let size = {...node.size};\r\n        if (size && typeof size === 'object'){\r\n            let ret = [\r\n                '', U.cropNum(+(+size.x||0).toFixed(2)),\r\n                ', ', U.cropNum(+(+size.y||0).toFixed(2)),\r\n                ', ', U.cropNum(+(+node.zIndex||0).toFixed(2)),\r\n                ' w:', U.cropNum(+(+size.w||0).toFixed(2)),\r\n                ' h:', U.cropNum(+(+size.h||0).toFixed(2)),\r\n            ]\r\n            nodepos = ret.join('');\r\n        }\r\n    }\r\n\r\n    return(<footer className={'footer'}>\r\n        <label className={'me-3'}>\r\n            Made with <i className=\"bi bi-heart-fill\" /> in the swen group\r\n        </label>\r\n        <div style={{width: '100px'}}></div>\r\n        <div className={'coordinates'} hidden={!node}>\r\n            {data?.name}&nbsp;\r\n            {nodepos}\r\n        </div>\r\n        {swenOpen && \r\n                <>\r\n                    <div className='modal-container'></div>\r\n                    <div className='swen'>\r\n                        <img src={swen} onClick={(e) => setSwen(false)} />\r\n                    </div>\r\n                </>\r\n        }\r\n        <JjodelName />\r\n\r\n    </footer>)\r\n}\r\n\r\ninterface OwnProps {}\r\ninterface StateProps {\r\n    node?: LGraphElement;\r\n    data?: LModelElement\r\n}\r\ninterface DispatchProps {}\r\ntype AllProps = OwnProps & StateProps & DispatchProps;\r\n\r\n\r\nfunction mapStateToProps(state: DState, ownProps: OwnProps): StateProps {\r\n    const ret: StateProps = {} as FakeStateProps;\r\n    const selected = state._lastSelected;\r\n    if(selected?.node) ret.node = LGraphElement.fromPointer(selected.node);\r\n    if(selected?.modelElement) ret.data = LModelElement.fromPointer(selected.modelElement);\r\n\r\n    return ret;\r\n}\r\n\r\nfunction mapDispatchToProps(dispatch: Dispatch<any>): DispatchProps {\r\n    const ret: DispatchProps = {};\r\n    return ret;\r\n}\r\n\r\nexport const BottomBarConnected = connect<StateProps, DispatchProps, OwnProps, DState>(\r\n    mapStateToProps,\r\n    mapDispatchToProps\r\n)(BottomBarComponent);\r\n\r\nconst BottomBar = (props: OwnProps, children: (string | React.Component)[] = []): ReactElement => {\r\n    return <BottomBarConnected {...{...props, children}} />;\r\n}\r\n\r\nexport {BottomBar};\r\n","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\forEndUser\\Aliases.tsx",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\forEndUser\\GenericInput.tsx",["928","929"],"import React, {Dispatch, InputHTMLAttributes, PureComponent, ReactNode} from 'react';\r\nimport {connect} from 'react-redux';\r\nimport './GenericInput.scss';\r\nimport {\r\n    Dictionary,\r\n    DocString,\r\n    DPointerTargetable,\r\n    DState,\r\n    DViewElement,\r\n    GObject,\r\n    Info,\r\n    Input,\r\n    Log,\r\n    LPointerTargetable,\r\n    LViewElement,\r\n    RuntimeAccessibleClass,\r\n    Select,\r\n    ShortAttribETypes,\r\n    TextArea,\r\n    U\r\n} from '../../joiner';\r\nimport {SizeInput} from './SizeInput';\r\nimport {JavascriptEditor} from \"../editors/languages\";\r\n\r\n// private\r\ninterface ThisState {\r\n}\r\ntype Dic<K extends string|number, V> = Dictionary<K, V>;\r\ntype String<T> = DocString<T>;\r\nclass GenericInputComponent extends PureComponent<AllProps, ThisState/*undefined*/>{\r\n    constructor(props: AllProps, context: any) {\r\n        super(props, context);\r\n    }\r\n\r\n    render(): ReactNode {\r\n        let d: DViewElement = ((this.props.data as LPointerTargetable).__raw || this.props.data) as any;\r\n        let l: LViewElement = LPointerTargetable.wrap(this.props.data) as LViewElement;\r\n        let field: keyof LViewElement = this.props.field as any;\r\n        let info: GObject<Info>;\r\n        if (!this.props.info){\r\n            let DConstructor: typeof DPointerTargetable = RuntimeAccessibleClass.get(d.className);\r\n            let singleton: GObject<LPointerTargetable> = DConstructor.singleton;\r\n            info = singleton['__info_of__' + this.props.field] ;\r\n        } else info = this.props.info;\r\n        if (!info) {\r\n            Log.eDevv(\"<GenericInput/> could not find info of \" + this.props.field, {props:this.props});\r\n            return <></>;\r\n        }\r\n\r\n        let type: string;\r\n        let enumOptions: Dic<String<'optgroup'>, Dic<String<'options'>, String<'values'>>> = {}; // 'Options' entry is a fallback for items without an optgroup\r\n        let enumOptionsJSX: JSX.Element | undefined;\r\n        if (info.enum) {\r\n            type = 'EEnum';\r\n            let prevoptgroup: string = 'Options';\r\n            let group: string;\r\n            let option: string;\r\n            for (let key in info.enum) {\r\n                let val: string = info.enum[key];\r\n                if (key.indexOf('(') === 0) {\r\n                    let end = key.indexOf(')');\r\n                    group = key.substring(1, end).trim();\r\n                    option = key.substring(end + 1).trim();\r\n                    prevoptgroup = group;\r\n                } else {\r\n                    option = key;\r\n                    group = prevoptgroup;\r\n                }\r\n                if (!enumOptions[group]) enumOptions[group] = {};\r\n                enumOptions[group][option] = val;\r\n            }\r\n            let unsorted = enumOptions.Options;\r\n            delete enumOptions.Options;\r\n            enumOptionsJSX = <>\r\n                {\r\n                    //data-selected={l[field] === unsorted[optkey]}\r\n                    unsorted && Object.keys(unsorted).map((optKey: string) => <option value={unsorted[optKey]}>{optKey}</option>)\r\n                }\r\n                {Object.keys(enumOptions).map((grpKey: string) => <optgroup label={grpKey}>{\r\n                Object.keys(enumOptions[grpKey]).map( (optKey: string) => <option value={enumOptions[grpKey][optKey]}>{optKey}</option>)\r\n            }</optgroup>)}</>;\r\n        }\r\n        else {\r\n            if (typeof info.type === 'string') {\r\n                if (info.type.toLowerCase().indexOf('function') === 0) type = 'Function';\r\n                else type = info.type as any;\r\n            }\r\n            else {\r\n                if (!info.type) { Log.exDevv('missing __info_of__ type for ' + d.className + '.' + this.props.field, {d, info, props: this.props}); return <></>}\r\n                let infoType: GObject = info.type;\r\n                type = infoType.cname || infoType.className || infoType.name;\r\n                Log.exDev(!type, 'missing type:', {type, info});\r\n            }\r\n        }\r\n\r\n        /*if (type.indexOf('|') !== -1) {\r\n            type = 'EEnum';\r\n            let options = type.split('|');\r\n            if (!enumOptions.Option) enumOptions.Option = {};\r\n            for (let o in options){\r\n                o = o.trim();\r\n                enumOptions.Option[o] = o;\r\n            }\r\n        }*/\r\n\r\n        // const otherProps: {[inputattribute:HTMLInputTypeAttribute]: any} = {...this.props};\r\n        const otherProps: InputHTMLAttributes<Event> = {...this.props} as any;\r\n        function setMinMax(max: number): void {\r\n            if (info.min !== undefined) otherProps.min = info.min;\r\n            else otherProps.min = info.positive === true ? 0 : -max / 2; // assume false if non specified\r\n\r\n            if (info.max !== undefined) otherProps.max = info.max;\r\n            else otherProps.max = info.positive === false ? max/2 - 1 : max-1; // assume true if non specified\r\n        }\r\n\r\n        let label: ReactNode = info.label || this.props.field;\r\n        if (typeof label === \"string\") label = U.uppercaseFirstLetter(info.label || this.props.field);\r\n\r\n        if (type.toLowerCase().indexOf(\"function(\") >=0 || type.indexOf(\"()=>\") >=0) type = \"Function\";\r\n        switch (type.toLowerCase()) {\r\n            default:\r\n                Log.ee('invalid type in GenericInput', {type, props:this.props, info, d});\r\n                return <div {...otherProps as any} className={'danger'} style={{color: 'red', border: '1px solid red'}}>Invalid GInput type: '{type}'</div>;\r\n            case 'point': case 'graphpoint': case 'size': case 'graphSsize':\r\n                return <SizeInput {...otherProps} data={l} field={this.props.field} label={label} />;\r\n            case 'text':\r\n                return <TextArea inputClassName={'input my-auto ms-auto '} {...otherProps as any} className={(this.props.rootClassName||'')+' '+(this.props.className||'')}\r\n                                 data={this.props.data} field={this.props.field}\r\n                                 jsxLabel={label} tooltip={this.props.tooltip} />;\r\n            case 'function':\r\n                return <JavascriptEditor className={(this.props.rootClassName||'')+' '+(this.props.className||'')} placeHolder={this.props.placeholder}\r\n                                         jsxLabel={this.props.label}\r\n                                         data={this.props.data} field={this.props.field} tooltip={this.props.tooltip}\r\n                                         hide={this.props.hide} style={this.props.style} title={this.props.title}\r\n                                         getter={this.props.getter} setter={this.props.setter} key={this.props.key}\r\n                                         readOnly={this.props.readOnly}\r\n                                         height={this.props.height}\r\n                                         {...otherProps as any /*not working? i had to list them all*/}  />;\r\n            case 'eenum':\r\n                return <Select inputClassName={'my-auto ms-auto select'} {...otherProps as any} className={this.props.rootClassName}\r\n                               data={this.props.data} field={this.props.field} options={enumOptionsJSX}\r\n                               jsxLabel={label} tooltip={this.props.tooltip} />;\r\n                // <input> natives\r\n            case 'radio':\r\n                // problem: this would need to return a <form> and multiple inputs generated by a single element.\r\n                // it should be easy but unlikely it will be needed so i won't do it for now.\r\n                Log.eDevv('radio input type is unsupported'); break;\r\n            case 'datetime': type = 'datetime-local'; break;\r\n            case 'color': break;\r\n            case 'email': break;\r\n            case 'image': break; // ?\r\n            case 'password': break;\r\n            case 'range': break;\r\n            case 'month': break;\r\n            case 'week': break;\r\n            case 'datetime-local': break;\r\n            case 'time': break;\r\n            case 'url': break;\r\n            // ecore\r\n            case ShortAttribETypes.EChar.toLowerCase():\r\n                type = 'text';\r\n                if (undefined === otherProps.minLength) otherProps.minLength = 1;\r\n                otherProps.maxLength = 1;\r\n                // otherProps.pattern = '^.{1}$';\r\n                break;\r\n            case \"string\":\r\n            case ShortAttribETypes.EString.toLowerCase(): type = 'text'; break;\r\n            case ShortAttribETypes.EBoolean.toLowerCase(): type = 'checkbox'; break;\r\n            case ShortAttribETypes.EByte.toLowerCase():\r\n                type = 'number';\r\n                setMinMax(2**8);\r\n                break;\r\n            case ShortAttribETypes.EShort.toLowerCase():\r\n                type = 'number';\r\n                setMinMax(2**16);\r\n                break;\r\n            case ShortAttribETypes.EInt.toLowerCase():\r\n                type = 'number';\r\n                setMinMax(2**32);\r\n                break;\r\n            case ShortAttribETypes.ELong.toLowerCase():\r\n                type = 'number';\r\n                setMinMax(2**64);\r\n                break;\r\n            case ShortAttribETypes.EFloat.toLowerCase():\r\n            case ShortAttribETypes.EDouble.toLowerCase():\r\n                type = 'number';\r\n                if (!otherProps.step) otherProps.step = info.step || 0.1;\r\n                if (!otherProps.pattern) otherProps.pattern = info.pattern || '^[0-9]+\\.[0-9]{' + info.digits + '}$';\r\n                break;\r\n            case ShortAttribETypes.EDate.toLowerCase(): type = 'datetime-local'; break;\r\n        }\r\n        let className = (this.props.className || '') + ' ' + ( this.props.rootClassName||'');\r\n        // delete otherProps.field; delete otherProps.data; delete otherProps.infoof;\r\n        return <Input {...otherProps} className={className}\r\n                      data={this.props.data} field={this.props.field}\r\n                      jsxLabel={label} tooltip={this.props.tooltip} type={type as any}/>;\r\n    }\r\n}\r\n\r\n// private\r\ninterface _OwnProps {\r\n    // propsRequestedFromJSX_AsAttributes: string;\r\n    data: DPointerTargetable | LPointerTargetable;\r\n    field: string;\r\n    key?: string;\r\n    label?: ReactNode;\r\n    title?: ReactNode;\r\n    info?: Info | undefined;\r\n    tooltip?: boolean|string;\r\n\r\n    className?: string;\r\n    rootClassName?: string;\r\n    inputClassName?: string;\r\n    rootStyle?: GObject;// this goes to root\r\n    style?: GObject; // this goes at the root of <Input> or <Select> element(s)\r\n    inputStyle?: GObject; // this goes to the actual native <input> or <select> element(s)\r\n    hide?: undefined | boolean; // for autohiding Javascript editor\r\n    getter?: <T extends LPointerTargetable>(data: T, field: DocString<\"keyof T\">) => string;\r\n    setter?: <T extends LPointerTargetable>(value: string|boolean, data: T, field: DocString<\"keyof T\">) => void;\r\n\r\n    /*\r\n    they might be useful, but can just add them in without declaring all of them. i pass them like <input ...otherprops>\r\n    multiple?: boolean;  // multi value for select! works on file, email (just changes default validation pattern), and maybe others\r\n    size?: ??\r\n    accept?: string // only for type = 'file'\r\n    capture?: string // only for type = 'file'\r\n    autocomplete?: string; // only for <input> types\r\n    disabled?: boolean;\r\n    height?: string; // for 'image'\r\n    list?: string; // datalist\r\n    maxLength?: string; // chars\r\n    */\r\n    // many more skipped mostly for forms\r\n\r\n}\r\ntype OwnProps = _OwnProps & InputHTMLAttributes<Event>; // {[inputattribute:HTMLInputAttribute]: any};\r\n// private\r\ninterface StateProps {\r\n    // propsFromReduxStateOrOtherKindOfStateManagement: boolean; // flux or custom things too, unrelated to this.state of react.\r\n}\r\n\r\n// private\r\ninterface DispatchProps {\r\n    // propsFromReduxActions: typeof funzioneTriggeraAzioneDaImportare;\r\n}\r\n\r\n\r\n// private\r\ntype AllProps = OwnProps & StateProps & DispatchProps;\r\n\r\n////// mapper func\r\n\r\nfunction mapStateToProps(state: DState, ownProps: OwnProps): StateProps {\r\n    const ret: StateProps = {} as any;\r\n    /// to fill\r\n    return ret; }\r\n\r\nfunction mapDispatchToProps(dispatch: Dispatch<any>): DispatchProps {\r\n    const ret: DispatchProps = {} as any;\r\n    /// to fill\r\n    return ret; }\r\n\r\n\r\nexport const GenericInput = connect<StateProps, DispatchProps, OwnProps, DState>(\r\n    mapStateToProps,\r\n    mapDispatchToProps\r\n)(GenericInputComponent);\r\n\r\n\r\n/*\r\n\r\nSupported __info_of__.type values:\r\n\r\n\r\n- ShortAttribETypes     =   ecore type names\r\n- text                  =   for textarea\r\n- Function              =   for textarea\r\n- richtext              =   for monaco editor\r\n- native <input> types\r\n- DPointerTargetable    = will make a select out of available elements of that kind\r\n- GraphPoint            = will make a mini interactive square where you can select a point, output is in % [0, 1].\r\n                          NEED A SETTER AND GETTER to get from % to coords and the other way\r\n- GraphSize             = will make a mini interactive square where you can select a rectangle, output is in % [0, 1].\r\n                          NEED A SETTER AND GETTER to get from % to coords and the other way\r\n\r\n\r\n- typescript enumerators, with optgroups defined as following\r\n        (optgroup1) option1\r\n        option2 // assumed still in optgroup1\r\n        option3 // assumed still in optgroup1\r\n        (optgroup2) option4\r\n        if first option(s) are without optgroup, they are grouped in optgroup 'Options'\r\n\r\nNOT SUPPORT\r\n- 'EEnum' string, it is only used internally. pass it the whole enum.\r\nnative <input> not supported\r\n- radio\r\n- tel\r\n- search\r\n- reset\r\n- hidden\r\n- image\r\n- button\r\n- submit\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n* */\r\n","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\forEndUser\\Try.tsx",["930"],"import React, {Dispatch, ErrorInfo, KeyboardEvent, ReactElement, ReactNode} from 'react';\r\nimport {connect} from 'react-redux';\r\nimport {DState} from '../../redux/store';\r\nimport {compressToBase64, compressToUTF16, decompressFromBase64, decompressFromUTF16} from \"async-lz-string\";\r\nimport {\r\n    Defaults,\r\n    DPointerTargetable,\r\n    DV,\r\n    GObject,\r\n    Keystrokes,\r\n    Log,\r\n    LPointerTargetable,\r\n    Overlap,\r\n    Pointer, store,\r\n    U, LoggerCategoryState\r\n} from '../../joiner';\r\nimport { DefaultView } from '../../common/DV';\r\n/*\r\n*   What's uncatched:\r\n*   - reducer\r\n*   - mapstatetoprops, if reducer doesn't do his job\r\n*\r\n*\r\n*\r\n*\r\n*\r\n* */\r\n\r\n// todo: after we have a server, instead of this, make an automatic error report with POST requests to the server without having the uri char limit\r\nclass TryComponent extends React.Component<AllProps, State> {\r\n    static cname: string = \"TryComponent\";\r\n    static mailRecipients = [\"damiano.divincenzo@student.univaq.it\", \"giordano.tinella@student.univaq.it\"];\r\n\r\n    constructor(props: AllProps) {\r\n        super(props);\r\n        this.state = { error: undefined, info: undefined, stateUpdateTime: 0, canUseClipboard: true};\r\n    }\r\n\r\n    static getDerivedStateFromError(error: Error) {\r\n        // Update state so the next render will show the fallback UI.\r\n        return { error, info: undefined }; // this first set an error and stops error propagation\r\n    }\r\n\r\n    private postGitIssue(content: string){\r\n        let owner = 'MDEGroup';\r\n        let repo = 'jjodel';\r\n        let obj = {\r\n            owner,\r\n            repo,\r\n            title: 'Automatic bug report',\r\n            body: content,\r\n            labels: [\r\n                'bug', 'auto-bug'\r\n            ],\r\n            headers: {\r\n                'X-GitHub-Api-Version': '2022-11-28'\r\n            }\r\n        }\r\n        this.postBugReport(`https://api.github.com/repos/${owner}/${repo}/issues`, JSON.stringify(obj));\r\n\r\n    }\r\n    private postBugReport(url: string, content: string){\r\n        var xhr = new XMLHttpRequest();\r\n        xhr.open(\"POST\", url, true);\r\n        xhr.setRequestHeader('Content-Type', 'application/json');\r\n        xhr.send(content);\r\n    }\r\n\r\n    componentDidCatch(error: Error, info: React.ErrorInfo): void {\r\n        console.error(\"uncatched error didcatch:\", {info});\r\n        // this is called after error propagation and a full render cycle is complete, i use it to trigger a rerender with more accurate infos.\r\n        this.setState({error, info, stateUpdateTime: this.props.stateUpdateTime});\r\n    }\r\n\r\n    render() {\r\n        /*\r\n        if (this.props.stateUpdateTime !== this.state.stateUpdateTime) {\r\n            // after a redux state update try checking if error is gone\r\n            return this.props.children;\r\n        }*/\r\n        if (this.state.error) {\r\n            // You can render any custom fallback UI\r\n            return this.catch(this.state.error, this.state.info);\r\n        }\r\n        if (Array.isArray(this.props.children)) {\r\n            console.error(\"<Try /> can have only 1 subcomponent\", this.props.children, this);\r\n            return this.catch({message: \"<Try /> can have only 1 subcomponent. If you need more wrap them inside a <>React.fragment</>\"} as any, undefined);\r\n        }\r\n        if (!React.isValidElement(this.props.children)) {\r\n            // You can render any custom fallback UI\r\n            console.error(\"Children is not a valid React Element\", this.props.children, this);\r\n            return this.catch({message: \"Children is not a valid React Element\"} as any, undefined);\r\n        }\r\n        return this.props.children;\r\n    }\r\n    reset(){\r\n        this.setState({error:undefined, info: undefined, lz: undefined});\r\n    }\r\n\r\n    catch(error: Error, info?: React.ErrorInfo): ReactNode{\r\n        console.error(\"uncatched error:\", {state:{...this.state}});\r\n        let debug = false;\r\n        if (debug) return<div>error</div>;\r\n        if (this.props.catch) {\r\n            try {\r\n                if (typeof this.props.catch === \"function\") return this.props.catch(error, info);\r\n                if (React.isValidElement(this.props.catch)) return this.props.catch;\r\n            }\r\n            catch (e) {\r\n                console.error(\"uncatched error WITH INVALID CATCHING FUNC\", {catcherFuncError:e});\r\n            }\r\n        }\r\n\r\n\r\n        let state: DState = store.getState();\r\n        let title = \"Jodel assisted error report V\"+state?.version?.n;\r\n        (window as any).tryerror = error;\r\n        let reportstr = this.state.lz || this.stringreport(Log.getByError(error));\r\n        let mongoreport = {state: state, when: new Date()+'', e:{'stack':error.stack, 'msg':error.message}, compostack: info?.componentStack};\r\n        // todo giordano: salva report su mongodb\r\n\r\n        const msgbody_notencoded: string = \"This mail is auto-generated, it might contain data of your views or model.\\n\" +\r\n            \"If your project have sensitive personal information please do a manual report instead.\"+// check the report below to omit them.\\n\\n\" +\r\n            \"\" + error?.message + \"\\n\\n\" +\r\n            (reportstr ? 'logger report'+(this.state.lz ? ' (lz-base64)' : '')+':\\n' + encodeURIComponent(reportstr) +'\\n\\n' : '') +\r\n            \"_stack:\\n\" + U.cropStr(error.stack || '', 30, 0, 35, 15) + '\\n\\n'+\r\n            \"_component_stack:\\n\" + (info ? U.cropStr(info.componentStack, 10, 0, 35, 5) : '');\r\n\r\n        let {mailto, gitissue} = U.mailerror(TryComponent.mailRecipients, title, msgbody_notencoded, this.state.canUseClipboard,\r\n            undefined, ()=>{this.setState({canUseClipboard: false})});\r\n\r\n        let shortErrorBody = (error?.message || \"\\n\").split(\"\\n\")[0];\r\n        let visibleMessage: ReactNode = <div onClick={()=> this.reset()}>\r\n            <div>{info ? \"has info\": \"###########\"}</div>\r\n            <div>ut:{this.state.stateUpdateTime}, { shortErrorBody }</div>\r\n            <div>What you can try:</div>\r\n            <ul>\r\n                <li>- Undo the last change</li>\r\n                <li>- {mailto && [<a href={mailto}>Mail the developers</a>, \" or\"]} <a href={gitissue} target=\"_blank\">open an issue</a></li>\r\n            </ul>\r\n            {state.debug ? this.decompress() : undefined}\r\n        </div>\r\n        return DefaultView.error(visibleMessage, \"unhandled\");\r\n    }\r\n\r\n    decompress(){\r\n        function dec(e:any){\r\n            e.stopPropagation();\r\n            let s: any=undefined, s1: any=undefined, s2:Promise<string>=undefined as any, o: any=undefined;\r\n            try { s = e.target.value; } catch (e) {\r\n                console.error(\"crashed decompress\", e);\r\n            }\r\n            try { s1 = decodeURIComponent(s); } catch (e) {\r\n                console.error(\"crashed decompress uri\", e);\r\n            }\r\n            try { s2 = decompressFromBase64(s1); } catch (e) {\r\n                console.error(\"crashed decompress lz\", e);\r\n            }\r\n            if (s2) {s2.then(v=> {\r\n                try { o = JSON.parse(s2=v as any) } catch (e) { console.error(\"crashed decompress p\", e, v); }\r\n            }).finally(()=>{\r\n                let out = {s, uri:s1, lz:s2, o};\r\n                console.log('decompress final', out);\r\n                $('#decompress')[0].innerText = JSON.stringify(o ||  out, null, 4);\r\n\r\n            })} else {\r\n                let out = {s, uri:s1, lz:s2, o};\r\n                console.log('decompress else', out);\r\n                $('#decompress')[0].innerText = JSON.stringify(o ||  out, null, 4);\r\n            }\r\n        }\r\n        return (<><span>Debug mode: paste error report to decompress it.</span><textarea className={\"w-100\"} onChange={dec}></textarea><textarea id={\"decompress\"} className={\"w-100\"} /></>);\r\n    }\r\n\r\n\r\n    private stringreport(loggerReport0?: GObject): string | undefined{\r\n        if (!loggerReport0) return undefined;\r\n        let loggerReport = {...loggerReport0};\r\n        (window as any).loggerReport = loggerReport;\r\n        delete loggerReport.exception;\r\n        loggerReport = U.cropDeepObject(loggerReport);\r\n        loggerReport.time = loggerReport0.time; // do not \"crop\" timestamp\r\n        delete loggerReport.short_string\r\n        let s = JSON.stringify(U.cropDeepObject(loggerReport));\r\n        /*(window as any).compressToUTF16 = compressToUTF16;\r\n        (window as any).decompressFromUTF16 = decompressFromUTF16;\r\n        (window as any).compressToBase64 = compressToBase64;\r\n        (window as any).decompressFromBase64 = decompressFromBase64;\r\n        (window as any).ss = s;*/\r\n        // or: LZString.compressToBase64()\r\n        if (s.length > 100) compressToBase64(s).then((v)=> this.setState({lz:v}));\r\n        return s;\r\n    }\r\n}\r\ninterface State{\r\n    error?: Error;\r\n    info?: React.ErrorInfo;\r\n    stateUpdateTime: number;\r\n    canUseClipboard: boolean;\r\n    lz?: string;\r\n}\r\ninterface OwnProps {\r\n    key?: React.Key | null;\r\n    catch?: ReactNode | ((error: Error, info?: React.ErrorInfo) => ReactNode);\r\n    children: ReactNode;\r\n}\r\ninterface StateProps {\r\n    stateUpdateTime: number;\r\n}\r\ninterface DispatchProps { }\r\ntype AllProps = Overlap<OwnProps, Overlap<StateProps, DispatchProps>>;\r\n\r\nlet rendercount: number = 0;\r\nfunction mapStateToProps(state: DState, ownProps: OwnProps): StateProps {\r\n    const ret: StateProps = {} as any;\r\n    ret.stateUpdateTime = rendercount++; // new Date().getTime();\r\n    return ret;\r\n}\r\n\r\nfunction mapDispatchToProps(dispatch: Dispatch<any>): DispatchProps {\r\n    const ret: DispatchProps = {};\r\n    return ret;\r\n}\r\n\r\nconst TryConnected =\r\n    connect<StateProps, DispatchProps, OwnProps, DState>(mapStateToProps, mapDispatchToProps)(TryComponent);\r\n\r\n\r\nexport function Try(props: OwnProps): ReactElement {\r\n    return <TryConnected {...{...props}}>{props.children}</TryConnected>;\r\n}\r\n\r\nTryComponent.cname = 'TryComponent';\r\nTryConnected.cname = 'TryConnected';\r\nTry.cname = 'Try';\r\n","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\forEndUser\\ControlPanel.tsx",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\forEndUser\\Overlap.tsx",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\forEndUser\\Control.tsx",["931","932"],"import {ClickEvent, ControlPanel, LGraphElement, SetRootFieldAction, U} from \"../../joiner\";\r\nimport { ReactElement, ReactNode, useEffect, useRef, useState } from \"react\";\r\n\r\nimport \"./control.scss\";\r\nimport { useStateIfMounted } from \"use-state-if-mounted\";\r\nimport { Tooltip } from \"./Tooltip\";\r\nimport { VertexOwnProps } from \"../../graph/graphElement/sharedTypes/sharedTypes\";\r\nimport { useEffectOnce } from \"usehooks-ts\";\r\n\r\n\r\n/* Notification */\r\n\r\ntype Widget = 'control'|'slider'|null;\r\ntype Field = 'node'|'name'|'children'|null;\r\ntype ErrorType = 'missing'|null;\r\n\r\ntype NotificationProps = {\r\n    widget: Widget,\r\n    field: Field,\r\n    type: ErrorType,\r\n    suggestion?: string\r\n}\r\nconst Notification = (props: NotificationProps) => {\r\n\r\n    return (\r\n        <div className=\"control-widget control-notification\">\r\n            <div className=\"control-header\">\r\n                <h1>You forgot something...</h1>\r\n                {props.type && <h2>Missing '{props.field}'' in '{props.widget}' in template definition.</h2>}\r\n            </div>\r\n\r\n            {props.suggestion && <p>{props.suggestion}</p>}\r\n        </div>\r\n    );\r\n\r\n}\r\n\r\ntype CheckReturnTYpe = {\r\n    error: boolean;\r\n    notification: any;\r\n}\r\n\r\nconst CheckProps = (widget: Widget, props: any): any => {\r\n\r\n    let result:any = false;\r\n    let notification: any|null = null;\r\n    let field: Field = null;\r\n    let type: ErrorType = null;\r\n    let suggestion = '';\r\n\r\n    switch(widget) {\r\n        case 'control':\r\n            if (!props.children) {\r\n                alert('You did not specify any children in <Control ...> </Control>');\r\n                // field = 'children';\r\n                // type = 'missing';\r\n                // suggestion = 'You did not specify any children in <Control ...> </Control>';\r\n                // notification = <Notification widget={widget} field={field} type={type} suggestion={suggestion}/>;\r\n                result = true;\r\n            }\r\n        break;\r\n        case 'slider':\r\n            if (!props.node) {\r\n                alert('You did not specify node in <Slider .../>');\r\n                // field = 'node';\r\n                // type = 'missing';\r\n                // suggestion = '';\r\n                // notification = <Notification widget={widget} field={field} type={type} suggestion={suggestion}/>;\r\n                result = true;\r\n\r\n            }\r\n            if (!props.name) {\r\n                alert('You did not specify name in <Slider .../>');\r\n                field = 'name';\r\n                type = 'missing';\r\n                suggestion = 'You did not specify name in <Slider .../>';\r\n                notification = <Notification widget={widget} field={field} type={type} suggestion={suggestion}/>;\r\n                result = true;\r\n            }\r\n        break;\r\n    }\r\n\r\n    return result;\r\n}\r\n\r\n\r\ntype ControlProps = {\r\n    children: any;\r\n    title?: string;\r\n    payoff?: string;\r\n    icon?: boolean;\r\n}\r\n\r\nfunction useClickOutside(ref: any, onClickOutside: any) {\r\n    useEffect(() => {\r\n\r\n        function handleClickOutside(event: Event) {\r\n            if (ref.current && !ref.current.contains(event.target)) {\r\n                onClickOutside();\r\n            }\r\n        }\r\n\r\n      // Bind\r\n      document.addEventListener(\"mousedown\", handleClickOutside);\r\n      return () => {\r\n        // dispose\r\n        document.removeEventListener(\"mousedown\", handleClickOutside);\r\n      };\r\n    }, [ref, onClickOutside]);\r\n  }\r\n\r\n\r\n/*  Control */\r\n\r\nconst ControlComponent = (props: ControlProps, children?:ReactNode) => {\r\n    \r\n    const [controlOpen, setControlOpen] = useStateIfMounted(false);\r\n\r\n    const toggleValue = () => {\r\n        setControlOpen(!controlOpen);\r\n\r\n    }\r\n\r\n\r\n    function onClick(e: any){\r\n        console.log('setup hide control');\r\n        U.clickedOutside(e, ()=> {\r\n            console.log('hide control');\r\n            setControlOpen(false)\r\n        });\r\n    }\r\n    return (<div className={`jjodel-control-root`} onClick={onClick}>\r\n        <div className={`jjodel-control d-flex flex-row ${controlOpen ? 'opened' : 'closed'}`}>\r\n            <div className={'control-header'}>\r\n                <h1>{props.title}</h1>\r\n                <h2>{props.payoff}</h2>\r\n            </div>\r\n            {props.children || children}\r\n        </div>\r\n        <div className={'jjodel-control-icon'}>\r\n            <i onClick={(e) => {toggleValue()}} className=\"bi bi-toggles\"/>\r\n        </div>\r\n    </div>);\r\n}\r\n\r\nconst Control = (props: VertexOwnProps, children: ReactNode = []): ReactElement => {\r\n    return <ControlComponent {...props}>{children || props.children}</ControlComponent>;\r\n}\r\n\r\n\r\n/* Slider */\r\n\r\ntype SliderProps = {\r\n    node: LGraphElement;\r\n    name?: string;\r\n    defaultValue?:number;\r\n    title?:string;\r\n    min?: number;\r\n    max?: number;\r\n    step?: number;\r\n    label?: string;\r\n}\r\n\r\nconst SliderComponent = (props: SliderProps) => {\r\n\r\n    const min = props.min ? props.min : 0;\r\n    const max = props.max ? props.max : 10;\r\n    const step = props.step ? props.step : 1;\r\n    const defaultValue = props.defaultValue ? props.defaultValue : max;\r\n    const name = props.name;\r\n\r\n    useEffectOnce(\r\n        () => {\r\n            {/* @ts-ignore */}\r\n            props.node.state = {[name] : defaultValue};\r\n        }\r\n    );\r\n\r\n    function updateValue(value: number) {\r\n        // @ts-ignore\r\n        props.node.state = {[name]: value};\r\n    }\r\n\r\n\r\n    return (\r\n        <>\r\n            {CheckProps('slider', props) || <div className={'control-widget control-slider'}>\r\n\r\n                <div className={'track'}\r\n                    style={{transition: 'width 0.3s', position: 'relative', left: '10px',\r\n                        width: `calc(((100%/${max} - 8px) * ${props.node.state[name as string]}))`}}\r\n                >\r\n\r\n                </div>\r\n\r\n                <input\r\n                    type={'range'}\r\n                    min={min}\r\n                    max={max}\r\n                    step={step}\r\n                    onChange={(e)=>{updateValue(+e.target.value)}} />\r\n\r\n                {/* @ts-ignore */}\r\n                {props.title && <div className={'tip'}>{props.title} <label>{props.node.state[name]}</label></div>}\r\n                </div>\r\n            }\r\n        </>);\r\n}\r\n\r\nconst Slider = (props: SliderProps, children: ReactNode = []): ReactElement => {\r\n    return <SliderComponent {...props} />;\r\n}\r\n\r\n\r\n/* Toggle */\r\n\r\ntype ToggleValues = {\r\n    true: string;\r\n    false: string;\r\n}\r\n\r\ntype ToggleProps = {\r\n    name: string;\r\n    values?: ToggleValues;\r\n    labels?: ToggleValues;\r\n    size?: string;\r\n    style?: React.CSSProperties;\r\n    title?: string;\r\n};\r\n\r\nconst ToggleComponent = (props: ToggleProps) => {\r\n    const [value, setValue] = useState<boolean>(false);\r\n    const defaultValue = false;\r\n\r\n    const labels = props.labels ? props.labels : {true: 'On', false: 'Off'};\r\n\r\n    useEffectOnce(\r\n        () => {\r\n            {/* @ts-ignore */}\r\n            props.node.state = {[props.name] : defaultValue};\r\n        }\r\n    );\r\n\r\n    function updateValue(value: boolean) {\r\n        // @ts-ignore\r\n        props.node.state = {[props.name]: value};\r\n    }\r\n\r\n    function toggleValue() {\r\n        const newValue = !value;\r\n        setValue(newValue);\r\n\r\n        // @ts-ignore\r\n        props.node.state = {[props.name]: newValue};\r\n    }\r\n    // // updateValue(+e.target.value) \r\n\r\n    return (<>\r\n        \r\n        <div className={'toggle'} onClick={(e) => {toggleValue()}}>\r\n            <input type={'checkbox'} className={'toggle-input'} id={props.name} checked={value} onChange={(e)=>{alert(e.target.value)}}  onClick={(e) => alert('input, click')} /> \r\n\r\n            <label onClick={() => alert()} className={'toggle-label'}></label>\r\n\r\n            <div className={\"toggle-labels\"}>\r\n                {value ?\r\n                    <span className={\"toggle-on\"}>{labels['true']}</span>\r\n                    :\r\n                    <span className={\"toggle-off\"}>{labels['false']}</span>\r\n                }\r\n            </div>\r\n            <div className={\"tip\"}>{props.title}</div>\r\n\r\n        </div></>\r\n    );\r\n}\r\n\r\nconst Toggle = (props: ToggleProps, children: ReactNode = []): ReactElement => {\r\n    return <ToggleComponent {...props} />;\r\n}\r\n\r\nexport {Control, Slider, Toggle};\r\n\r\n","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\pages\\Archive.tsx",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\forEndUser\\Measurable.tsx",["933"],"import React, {Component, CSSProperties, PureComponent, ReactChild, ReactElement, ReactNode} from \"react\";\r\nimport {DGraphElement, Dictionary, GObject, GraphSize, LGraph, Log, RuntimeAccessible, Size, TRANSACTION, U} from \"../../joiner\";\r\nimport $ from \"jquery\";\r\n/// <reference path=\"../../common/libraries/jqui-types.ts\" />\r\nimport {JQueryUI} from \"../../common/libraries/jqui-types\"\r\nimport \"./Measurable.scss\";\r\n\r\ntype ResizableEvent = JQueryUI.ResizableEvent;\r\ntype DraggableEvent = JQueryUI.DraggableEvent;\r\ntype RotatableEvent = JQueryUI.RotatableEvent;\r\ntype DraggableOptions = JQueryUI.DraggableOptions;\r\ntype ResizableOptions = JQueryUI.ResizableOptions;\r\ntype RotatabeOptions = JQueryUI.RotatableOptions;\r\n// private\r\ninterface MeasurableState {\r\n}\r\ninterface ScrollState {\r\n}\r\n\r\ntype EventLetter = 's'|'ing'|'e';\r\ntype MeasurableUIEvent = ResizableEvent | DraggableEvent | RotatableEvent;\r\n\r\n@RuntimeAccessible('MeasurableComponent')\r\nexport class MeasurableComponent extends Component<MeasurableAllProps, MeasurableState>{\r\n    static cname: string = \"MeasurableComponent\";\r\n    static childmodekeys: (keyof CSSStyleDeclaration)[] = ['left', 'top', 'transform', 'position'];\r\n\r\n\r\n    private html: Element | null = null;\r\n    private $html!:  JQuery<Element>;\r\n    dragOptionsChanged: boolean = true;\r\n    resizeOptionsChanged: boolean = true;\r\n    rotateOptionsChanged: boolean = true;\r\n    defaultOptions: {\"draggable\": JQueryUI.DraggableOptions, resizable: JQueryUI.ResizableOptions, rotatable: GObject} = {\r\n        draggable: {\r\n            cancel: '.no-drag,[contenteditable=\"true\"],input,textarea,button,select,option',\r\n            cursor: 'grabbing',\r\n            // containment: 'parent',\r\n            distance: 5,\r\n            // helper: 'clone', // 'original' or 'csselector'? or func=>html\r\n            // disabled: !(view.draggable),}\r\n        },\r\n        resizable: {},\r\n        rotatable: {},\r\n    }\r\n    oldPos: Dictionary<string, number> = {left: undefined, top: undefined} as any;\r\n\r\n    componentDidMount() {\r\n        this.afterUpdate();\r\n    }\r\n    componentDidUpdate(prevProps: Readonly<MeasurableAllProps>, prevState: Readonly<MeasurableState>, snapshot?: any) {\r\n        this.afterUpdate();\r\n    }\r\n\r\n    afterUpdate(): void{\r\n        if (!this.html) return;\r\n        this.$html = $(this.html);\r\n        if (this.dragOptionsChanged) { this.afterUpdateSingle(\"draggable\"); }\r\n        if (this.resizeOptionsChanged) { this.afterUpdateSingle(\"resizable\"); }\r\n        if (this.rotateOptionsChanged) { this.afterUpdateSingle(\"rotatable\"); }\r\n    }\r\n    /*\r\n        afterUpdateSingle(type: \"draggable\" | \"resizable\" | \"rotatable\"): void{\r\n            if (this.props.draggable) this.afterUpdateDraggable\r\n        }/*\r\n        afterUpdateDraggable_old(): void{\r\n            nope, erase this and just make the previous _old genericversion with inner dynamic functions called 9 times like event('drag', 'while'); event('drag', 'end'); event('resize', 'while');...\r\n            make and extract new functions from code so that it dinamically build the jqui options object\r\n            if (!this.$html) return;\r\n            let $measurable = this.$html;\r\n            let jqui_options = this.props.draggable;\r\n            let jqui_start = jqui_options === 'object' ? jqui_options.start : undefined;\r\n            let jqui_end = jqui_options === 'object' ? jqui_options.stop : undefined;\r\n            let jqui_ing = jqui_options === 'object' ? jqui_options.drag : undefined;\r\n            let props_start = this.props.onDragStart;\r\n            let props_end = this.props.onDragEnd;\r\n            let props_ing = this.props.whileDragging;\r\n            let type = 'draggable';\r\n\r\n\r\n            //let positionMap = new WeakMap<HTMLElement, {left: number; top: number}>();\r\n            let childmode_drag = (e: HTMLElement, evt?: any, evtkind?: EventLetter, ui?:any): void => {\r\n                let oc = this.props.onChildren;\r\n                if (!oc) {\r\n                    Log.ee('not oc', {evt, oc, e, p: this.props}); return;\r\n                }\r\n                let child: HTMLElement;\r\n                if (typeof oc === 'function') child = oc(e);\r\n                else child = e.children[0] as HTMLElement;\r\n                if (!child) {\r\n                    Log.ee('child not found', {child, evt, oc, e}); return;\r\n                }\r\n                let oldpos = this.oldPos; // positionMap.get(e);\r\n                console.log('measurable default event child ' + evtkind, {ui, e, oc, oldpos});\r\n                //if (evtkind === 'e') { positionMap.set(e, ui.position); }\r\n\r\n                /*if (evtkind === 's') {\r\n                    ui.originalPosition.left = 300;\r\n                    ui.offset.left = 300;\r\n                    ui.position.left = 300;\r\n                    console.log('measurable sstart ', {type, e, oc, ui, el: e.style.left, cl: child.style.left});\r\n                }* /\r\n\r\n                let key: any;\r\n                for (key of childmodekeys) {\r\n                    let fixpos = () => {\r\n                        if (oldpos && (oldpos as any)[key] !== undefined) {\r\n                            if (key ==='left') console.log('measurable fixpos ' + evtkind, (oldpos as any)[key] + ui.position[key] + 'px', (oldpos as any)[key]);\r\n                            let newpos = (oldpos as any)[key] + ui.position[key];\r\n                            child.style[key] = (newpos) + 'px';\r\n                            if (evtkind === 'e') this.oldPos[key] = newpos;\r\n                        }\r\n                        else child.style[key] = e.style[key];\r\n                    }\r\n                    fixpos();\r\n                    if (evtkind === 'e')  setTimeout(fixpos, 1000);\r\n                    if (evtkind === 's' && !e.classList.contains('draggable-child-mode')) e.classList.add('draggable-child-mode');\r\n                    // delete e.style[key]\r\n                }\r\n            }\r\n\r\n            let translateeevents: Dictionary<string, Dictionary<string, DraggableEvent>> = {\r\n                'draggable': {\r\n                    's': (e, ui)=>{ this.absoluteToTransform(e.target as HTMLElement, e, 's'); },\r\n                    'ing': (e, ui)=>{ this.absoluteToTransform(e.target as HTMLElement, e, 'ing'); },\r\n                    'e': (e, ui)=>{ this.absoluteToTransform(e.target as HTMLElement, e, 'e'); }},\r\n            };\r\n            let defaulteevent = (evtkind: EventLetter): MeasurableUIEvent | null =>{\r\n                if (!this.props.transformMode && !this.props.onChildren) return null;\r\n                return (e: any, ui: any) => {\r\n                    //console.log('measurable default event', {type, evtkind, translateeevents, e, t: e.target});\r\n                    if (this.props.transformMode === true) translateeevents[type][evtkind](e, ui);\r\n                    childmode_drag(e.target, e, evtkind, ui);\r\n                }\r\n            };\r\n\r\n            if (props[optionkey] === false || !props[optionkey]) {\r\n                console.log(\"measurable off \" + type, {$measurable, type, datamap, optionkey, props});\r\n                if ($measurable.data(datamap[type])) ($measurable as GObject)[type]('disable');\r\n                return;\r\n            }\r\n            if (props[optionkey] === true) {\r\n                options = {};\r\n            } else options = {...props[optionkey]};\r\n\r\n            if (props_start && typeof props_start !== \"function\") { return Log.ee(\"<Measurable /> onDragStart props must be a function\"); }\r\n            if (props_end && typeof props_end !== \"function\") { return Log.ee(\"<Measurable /> onDragEnd props must be a function\"); }\r\n            if (props_ing && typeof props_ing !== \"function\") { return Log.ee(\"<Measurable /> whileDragging props must be a function\"); }\r\n            if (!jqui_start && !props_start && ! default_start) delete options.start,\r\n                else options.start = (evt, ui) => { default_start?.(evt, ui); jqui_start?.(evt, ui); props_start?.(thiss.getCoords(evt, ui), evt, ui); }\r\n\r\n            let propsOptions = {...options};\r\n            let defaultOptions = this.defaultOptions[type];\r\n            U.objectMergeInPlace(options, defaultOptions);\r\n            //console.log(\"measurable\", {type, $measurable, options, propsOptions, defaultOptions});\r\n            ($measurable as GObject)[type](options);\r\n        }*/\r\n\r\n    absoluteToTransform(e: HTMLElement, evt?: any, evtkind?: EventLetter): any {\r\n        let x = e.style.left;\r\n        let y = e.style.top;\r\n        /*\r\n            e.style.left = '0px';\r\n            e.style.top = '0px';*/\r\n        //e.style.position = 'unset';\r\n        e.style.transform = `translate(${x}, ${y})`;\r\n    }\r\n    childmode(e: HTMLElement, evt?: any, evtkind?: EventLetter, ui?:any): void{\r\n        let oc = this.props.onChildren;\r\n        if (!oc) {\r\n            Log.ee('not oc', {evt, oc, e, p: this.props}); return;\r\n        }\r\n        let child: HTMLElement;\r\n        console.log('cchild', {e, evt,  evtkind, ui});\r\n        if (typeof oc === 'function') child = oc(e);\r\n        else child = e.children[0] as HTMLElement;\r\n        if (!child) {\r\n            Log.ee('child not found', {child, evt, oc, e}); return;\r\n        }\r\n        console.log('measurable default event child ' + evtkind, {ui, e, oc, oldpos: this.oldPos});\r\n        //if (evtkind === 'e') { positionMap.set(e, ui.position); }\r\n\r\n        /*if (evtkind === 's') {\r\n            ui.originalPosition.left = 300;\r\n            ui.offset.left = 300;\r\n            ui.position.left = 300;\r\n            console.log('measurable sstart ', {type, e, oc, ui, el: e.style.left, cl: child.style.left});\r\n        }*/\r\n\r\n        let key: any;\r\n        for (key of MeasurableComponent.childmodekeys) {\r\n            let fixpos = () => {\r\n                let oldpos = this.oldPos; // positionMap.get(e); {x:-1000, y:-3000};//\r\n                if (oldpos && (oldpos as any)[key] !== undefined) {\r\n                    let newpos = (oldpos as any)[key] + ui.position[key];\r\n                    if (key ==='left') console.log('measurable fixpos ' + newpos + 'px', (oldpos as any)[key], {oldpos, uipos:ui.position, newpos});\r\n                    child.style[key] = (newpos) + 'px';\r\n                    if (evtkind === 'e') this.oldPos[key] = newpos;\r\n                }\r\n                else child.style[key] = e.style[key];\r\n            }\r\n            if (evtkind === 'e') setTimeout(fixpos, 1000);\r\n            if (evtkind === 's') {\r\n                let graph = this.props.isPanning;\r\n                if (this.oldPos.left === undefined && graph) {\r\n                    console.log('measurable fixposss ',{oldpos:{...this.oldPos}});\r\n                    this.oldPos.left = ui.position.left = graph.offset.x;\r\n                    this.oldPos.top = ui.position.top = graph.offset.y;\r\n                }\r\n                if (!e.classList.contains('draggable-child-mode')) e.classList.add('draggable-child-mode');\r\n            }\r\n            fixpos();\r\n            // delete e.style[key]\r\n        }\r\n    }\r\n    getDefaultEvent(type: \"draggable\" | \"resizable\" | \"rotatable\", evtkind: EventLetter): MeasurableUIEvent | null {\r\n        if (!this.props.transformMode && !(this.props.onChildren && type === 'draggable')) return null;\r\n        switch (type) {\r\n            case 'draggable': if (!this.props.transformMode && !this.props.onChildren) return null; break\r\n            case 'resizable': break\r\n            case 'rotatable': break\r\n        }\r\n\r\n        let translateeevents: Dictionary<string, Dictionary<string, DraggableEvent>> = {\r\n            'draggable': {\r\n                's': (e, ui)=>{ this.absoluteToTransform(e.target as HTMLElement, e, 's'); },\r\n                'ing': (e, ui)=>{ this.absoluteToTransform(e.target as HTMLElement, e, 'ing'); },\r\n                'e': (e, ui)=>{ this.absoluteToTransform(e.target as HTMLElement, e, 'e'); }},\r\n            /*'resizable': {\r\n                's': (e, ui)=>{ },\r\n                'ing': (e, ui)=>{ },\r\n                'e': (e, ui)=>{ }},\r\n            'rotatable': {\r\n                's': (e, ui)=>{ },\r\n                'ing': (e, ui)=>{ },\r\n                'e': (e, ui)=>{ }},*/\r\n        };\r\n        return (e: any, ui: any) => {\r\n            console.log('measurable default event', {type, evtkind, translateeevents, e, t: e.target});\r\n            if (this.props.transformMode === true) translateeevents[type]?.[evtkind]?.(e, ui);\r\n            this.childmode(e.target, e, evtkind, ui);\r\n        }\r\n    }\r\n    makeEvent(options: GObject<DraggableOptions>, type: string, evtkey: keyof typeof jquievent) {\r\n        let eventmap = {\r\n            's':    {'draggable': 'onDragStart',    'rotatable': 'onRotateStart',   'resizable': 'onResizeStart'},\r\n            'ing':  {'draggable': 'whileDragging',  'rotatable': 'whileRotating',   'resizable': 'whileResizing'},\r\n            'e':    {'draggable': 'onDragEnd',      'rotatable': 'onRotateEnd',     'resizable': 'onResizeEnd'  },\r\n        }\r\n        let jqui_ing: string;\r\n        switch (type){\r\n            default: jqui_ing = Log.eDevv(\"unexpected measurable event: \" + type); return;\r\n            case \"draggable\": jqui_ing = 'drag'; break;\r\n            case \"resizable\": jqui_ing = 'resize'; break;\r\n            case \"rotatable\": jqui_ing = 'rotate'; break;\r\n        }\r\n        //let jodelevent = {'s': eventmap.s[type], 'ing': eventmap.ing[type], 'e': eventmap.e[type]};\r\n        let jquievent = {'s': 'start', 'ing': jqui_ing, 'e':'stop'};\r\n\r\n        let jqkey = jquievent[evtkey] || '';\r\n        let props: GObject<MeasurableAllProps> = this.props;\r\n        let propsevent = props[eventmap[evtkey][type]];\r\n\r\n        if (propsevent && typeof propsevent !== \"function\") {\r\n            Log.ee(\"<Measurable /> \" + eventmap[evtkey][type] + \" props must be a function\");\r\n            return;\r\n        }\r\n        // call ondragend... jodel events\r\n        let jquievt = options[jqkey];\r\n        // let jodelevt = propsevent; // (...params: any) => propsevent(...params); // was made to preserve \"this\"?\r\n        let defaultevt: null | MeasurableUIEvent = this.getDefaultEvent(type, evtkey);\r\n        let allevents = [defaultevt, jquievt, propsevent].filter((e)=>!!e);\r\n        if (allevents.length) options[jqkey] = ((evt, ui)=>{\r\n            for (let e of allevents) {\r\n                propsevent = props[eventmap[evtkey][type]]; // if i don't redeclare it here, closure makes a mess taking always the last jodelevt for all iterations.\r\n                if (e === propsevent) { e(this.getCoords(evt, ui, this.props.isPanning), evt, ui); }\r\n                else e(evt, ui);\r\n            }\r\n        }) as DraggableEvent;\r\n    }\r\n    afterUpdateSingle(type: \"draggable\" | \"resizable\" | \"rotatable\"): void{\r\n        // was forced to move from general loop-style implementation to individual redundant stuff because of closure messes.\r\n        if (!this.$html) return;\r\n        let $measurable = this.$html;\r\n        let options: GObject;\r\n        const props: GObject = this.props;\r\n        const datamap = {draggable: \"uiDraggable\", resizable: \"uiResizable\", rotatable: \"uiRotatable\"};\r\n        const optionmap = {draggable: \"draggable\", resizable: \"resizable\", rotatable: \"rotatable\"};\r\n        const optionkey = optionmap[type];\r\n        if (props[optionkey] === false || !props[optionkey]) {\r\n            // console.log(\"measurable off \" + type, {$measurable, type, datamap, optionkey, props});\r\n            if ($measurable.data(datamap[type])) ($measurable as GObject)[type]('disable');\r\n            return;\r\n        }\r\n        if (props[optionkey] === true) {\r\n            options = {};\r\n        } else options = {...props[optionkey]};\r\n\r\n        // todo: changing options at runtime works, but changing children does not update\r\n\r\n        let jqui_ing: string;\r\n        switch (type){\r\n            default: jqui_ing = Log.eDevv(\"unexpected measurable event: \" + type); return;\r\n            case \"draggable\": jqui_ing = 'drag'; break;\r\n            case \"resizable\": jqui_ing = 'resize'; break;\r\n            case \"rotatable\": jqui_ing = 'rotate'; break;\r\n        }\r\n        let jquievent = {'s': 'start', 'ing': jqui_ing, 'e':'stop'};\r\n        let evtkey: keyof typeof jquievent;\r\n        for (evtkey in jquievent) { this.makeEvent(options, type, evtkey); }\r\n        let defaultOptions = this.defaultOptions[type];\r\n        U.objectMergeInPlace(options, defaultOptions);\r\n        ($measurable as GObject)[type](options);\r\n    }\r\n    shouldComponentUpdate(nextProps: Readonly<MeasurableAllProps>, nextState: Readonly<MeasurableState>, nextContext: any): boolean {\r\n        //console.log(\"measurable shouldup\", {nc:nextProps.children, tc:this.props.children, eq: nextProps.children == this.props.children});\r\n        // todo: would need to check if pros.children has changed, but that requires a deep search of subcomponents props and state.\r\n        // currently with just return true it works and rerenders every time the parent component rerenders. not when other elements are interacted.\r\n        // it works also with <Input> as direct child and it updates.\r\n        if (window) return true;\r\n        const oldProps = this.props || {};\r\n        this.dragOptionsChanged = false;\r\n        this.resizeOptionsChanged = false;\r\n        this.rotateOptionsChanged = false;\r\n        let ret: boolean = false;\r\n        const nestederr = \"Options cannot contain functions or nested objects\";\r\n        if (!U.isShallowEqualWithProxies(oldProps.draggable, nextProps.draggable)) {\r\n            const opt: GObject = oldProps.draggable as any;\r\n            if (opt && typeof opt === \"object\") for(let k in opt){ switch (typeof opt[k]){ case \"function\": case \"object\": Log.ee(\"drag\" + nestederr, k); } }\r\n            this.dragOptionsChanged = true;\r\n            ret = true;\r\n        }\r\n        if (!U.isShallowEqualWithProxies(oldProps.resizable, nextProps.resizable)) {\r\n            const opt: GObject = oldProps.resizable as any;\r\n            if (opt && typeof opt === \"object\") for(let k in opt){ switch (typeof opt[k]){ case \"function\": case \"object\": Log.ee(\"resize\" + nestederr, k); } }\r\n            this.resizeOptionsChanged = true;\r\n            ret = true;\r\n        }\r\n        if (!U.isShallowEqualWithProxies(oldProps.rotatable, nextProps.rotatable)) {\r\n            const opt: GObject = oldProps.rotatable as any;\r\n            if (opt && typeof opt === \"object\") for(let k in opt){ switch (typeof opt[k]){ case \"function\": case \"object\": Log.ee(\"rotate\" + nestederr, k); } }\r\n            this.rotateOptionsChanged = true;\r\n            return true;\r\n        }\r\n        if (ret) return true; // i don't need to set more this.variable stuff and i already determined something changed.\r\n        if (Object.keys(oldProps).length !== Object.keys(nextProps).length) return true;\r\n        let k: keyof typeof nextProps;\r\n        for (k in oldProps){\r\n            switch(k){\r\n                //case \"axis\": if (ok)\r\n                case \"draggable\": case \"resizable\": case \"rotatable\": continue;\r\n                case \"children\": continue;\r\n            }\r\n            if (!(k in nextProps)) return false;\r\n            let ok = oldProps[k];\r\n            let nk = nextProps[k];\r\n            if (ok === nk) continue;\r\n            let tk = typeof ok;\r\n            if (tk !== typeof nk) return false;\r\n            switch (tk) {\r\n                case \"object\": Log.ee(\"unexpected object in <Measurable/> props\", {k, nk, ok}); return true;\r\n                case \"function\": if (ok!.toString() !== nk!.toString()) return true; break;\r\n                default: return false; // already checked they are !==\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    updateDefaultOptions(){\r\n        /*let addClasses = this.props.children ? 'on-children' as any : undefined;\r\n                                          jqui.classes does not owrk? and addclass is only for draggable?\r\n        if (this.defaultOptions.draggable.addClasses !== addClasses) {\r\n            this.defaultOptions.resizable.classes = addClasses;\r\n            // this.defaultOptions.rotatable.classes = addClasses;\r\n        }*/\r\n    }\r\n    render(): ReactNode {\r\n        let child: ReactElement = this.props.children as any;\r\n\r\n        this.updateDefaultOptions();\r\n        if (!child) return child || null; // sometimes react passes {} as props.children?\r\n        if (!Object.keys(child).length) return Log.ee(\"Measurable can have only 1 subelement and it cannot be an array or a <>React.fragment</>\", child, this.props);\r\n        if (Array.isArray(child)) {\r\n            if (child.length !== 1) {\r\n                Log.ee(\"Measurable can have only 1 subelement and it cannot be an array or a <>React.fragment</>\", child, this.props);\r\n                return child;\r\n            }\r\n            else child = child[0];\r\n        }\r\n        if (child.type.toString() === React.Fragment.toString()) {\r\n            Log.ee(\"Measurable can have only 1 subelement and it cannot be an array or a <>React.fragment</>\", child, this.props);\r\n            return child; }\r\n\r\n        let oldProps = child.props;\r\n        let newProps = {\r\n            ref: (html: Element | null)=>{\r\n                if (html && !U.isHtmlNode(html)) {\r\n                    Log.ee('ref tring to set non-html element', html);\r\n                    return;\r\n                }\r\n                this.html = html;\r\n            }\r\n        };\r\n        U.objectMergeInPlace(newProps, oldProps);\r\n        let clonedChild = React.cloneElement(child, newProps);\r\n        return clonedChild;\r\n    }\r\n\r\n    private getCoords(evt: JQueryEventObject, ui: JQueryUI.DraggableEventUIParams, isPanning?: LGraph): GraphSize {\r\n        let size = Size.of(evt.target);\r\n        let graph: LGraph = DGraphElement.graphLFromHtml(evt.target) as LGraph;\r\n        let gsize: GraphSize = graph?.translateHtmlSize(size);\r\n        if (isPanning) {\r\n            let position = this.props.onChildren ? this.oldPos : ui.position;\r\n            gsize.x = position.left;\r\n            gsize.y = position.top;\r\n        }\r\n        return gsize;\r\n    }\r\n}\r\n\r\n@RuntimeAccessible('ScrollableComponent')\r\nexport class ScrollableComponent extends Component<ScrollOwnProps, ScrollState>{\r\n    static cname: string = \"ScrollableComponent\";\r\n    render(){\r\n        let graph = this.props.graph;\r\n        let create = (e: JQueryEventObject) => {/*\r\n            let target: HTMLElement = e.target.children[0] as HTMLElement;\r\n            target.style.left = graph.offset.x+'px';\r\n            target.style.top = graph.offset.y+'px';*/\r\n            // $(target).data({uiDraggable:{offset:{left: graph.offset.x, top: graph.offset.y}}});\r\n        }\r\n        return (\r\n            <div {...this.props} className={(this.props.className || '' ) + \" scrollable\"} >\r\n                <Measurable draggable={{create}}\r\n                            isPanning={graph}\r\n                            onDragEnd={graph ? (coords, ...args: any)=>{\r\n                                if (!graph) return; // just for ts-lint\r\n                                console.log(\"drag odee\", {coords, graph, args});\r\n                                let offset = graph.offset;\r\n                                if (!offset.equals(coords)) graph.offset = coords as any;\r\n                            } : undefined}\r\n                            onChildren={true}>\r\n                    <div className=\"panning-handle\">\r\n                        <div className=\"panning-content\">{ this.props.children }</div>\r\n                    </div>\r\n                </Measurable>\r\n            </div>);\r\n    }\r\n}\r\n\r\n// private\r\ninterface ScrollOwnProps {\r\n    children: ReactChild[] | ReactChild;\r\n    className?: string;\r\n    graph: LGraph;\r\n}\r\ninterface MeasurableOwnProps {\r\n    isPanning?: LGraph;\r\n    children: ReactChild[] | ReactChild;\r\n    //dragOptions?: Options;\r\n    //drag?: Options;\r\n    draggable?: JQueryUI.DraggableOptions | boolean;\r\n    onDragStart?: DraggableEvent;\r\n    whileDragging?: DraggableEvent;\r\n    onDragEnd?: (coords: GraphSize, ...args: Parameters<DraggableEvent>)=>void;\r\n    onChildren?: boolean | ((e: HTMLElement)=>HTMLElement);\r\n\r\n    //resizeOptions?: Options;\r\n    //resize?: Options;\r\n    resizable?: JQueryUI.ResizableOptions | boolean;\r\n    onResizeStart?: ResizableEvent;\r\n    whileResizing?: ResizableEvent;\r\n    onResizeEnd?: ResizableEvent;\r\n    transformMode?: boolean; // if true uses transform: translate() instead of pos:absolute; left; & top;\r\n\r\n    //rotateOptions?: Options;\r\n    //rotate?: Options;\r\n    rotatable?: GObject | boolean;\r\n    onRotationStart?: RotatableEvent;\r\n    whileRotating?: RotatableEvent;\r\n    onRotationEnd?: RotatableEvent;\r\n}\r\n// private\r\ninterface MeasurableStateProps {\r\n    // propsFromReduxStateOrOtherKindOfStateManagement: boolean; // flux or custom things too, unrelated to this.state of react.\r\n}\r\n\r\n// private\r\ninterface DispatchProps {\r\n    // propsFromReduxActions: typeof funzioneTriggeraAzioneDaImportare;\r\n}\r\n\r\n\r\n// private\r\ntype MeasurableAllProps = MeasurableOwnProps & MeasurableStateProps & DispatchProps;\r\n\r\n////// mapper func\r\n/*\r\nfunction mapStateToProps(state: DState, ownProps: MeasurableOwnProps): MeasurableStateProps {\r\n    const ret: MeasurableStateProps = {} as any;\r\n    /// to fill\r\n    return ret; }\r\n\r\nfunction mapDispatchToProps(dispatch: Dispatch<any>): DispatchProps {\r\n    const ret: DispatchProps = {} as any;\r\n    /// to fill\r\n    return ret; }\r\n*/\r\n\r\n(MeasurableComponent as any).defaultProps = {\r\n    autosizex: true,\r\n    autosizey: true,\r\n    style: undefined,\r\n    children: [],\r\n} as MeasurableOwnProps;\r\n\r\n\r\nexport function Measurable(props: MeasurableAllProps, children?: any): ReactElement {\r\n    return <MeasurableComponent {...{...props}}>{props.children||children}</MeasurableComponent>;\r\n}\r\n// shortcuts for Draggable Resizable Rotatable with whileDragging onDragStart props simplified to start, while, end\r\nexport function Draggable(props: GObject<MeasurableAllProps>, children?: any): ReactElement {\r\n    return <MeasurableComponent\r\n        {...{...props}}\r\n        draggable={props.options || props.draggable || true}\r\n        onDragStart={props.start || props.begin || props.onDragStart}\r\n        onDragEnd={props.end || props.stop || props.onDragEnd}\r\n        whileDragging={props.drag || props.while || props.ing || props.whileDragging}\r\n    >{props.children||children}</MeasurableComponent>;\r\n}\r\nexport function Resizable(props: GObject<MeasurableAllProps>, children?: any): ReactElement {\r\n    return <MeasurableComponent\r\n        {...{...props}}\r\n        resizable={props.options || props.resizable || true}\r\n        onResizeStart={props.start || props.begin || props.onResizeStart}\r\n        onResizeEnd={props.end || props.stop || props.onResizeEnd}\r\n        whileResizing={props.resize || props.while || props.ing || props.whileResizing}\r\n    >{props.children||children}</MeasurableComponent>;\r\n}\r\nexport function Rotatable(props: GObject<MeasurableAllProps>, children?: any): ReactElement {\r\n    return <MeasurableComponent\r\n        {...{...props}}\r\n        rotatable={props.options || props.rotatable || true}\r\n        onRotationStart={props.start || props.begin || props.onRotateStart|| props.onRotationStart}\r\n        onRotationEnd={props.end || props.stop || props.onRotateEnd|| props.onRotationEnd}\r\n        whileRotating={props.rotate || props.while || props.ing || props.whileRotate || props.whileRotating}\r\n    >{props.children||children}</MeasurableComponent>;\r\n}\r\n\r\n\r\nexport function Scrollable(props: MeasurableAllProps, children?: any): ReactElement {\r\n    // @ts-ignore\r\n    return <ScrollableComponent {...{...props}}>{props.children||children}</ScrollableComponent>;\r\n}/*\r\nexport function InfiniteScroll(props: MeasurableAllProps, children: ReactChild[] = []): ReactElement {\r\n    return <InfiniteScrollComponent {...{...props, children}}>{children}</InfiniteScrollComponent>;\r\n}*/\r\n\r\n/*connect<MeasurableStateProps, DispatchProps, MeasurableOwnProps, DState>(\r\n    mapStateToProps,\r\n    mapDispatchToProps\r\n)(MeasurableComponent);*/\r\n","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\pages\\Community.tsx",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\pages\\Profile.tsx",["934","935"],"import {Try} from '../joiner';\r\nimport {Dashboard} from './components';\r\n\r\nimport {Cards, Card} from './components/cards/Cards';\r\nimport { Catalog } from './components/catalog/Catalog';\r\n\r\nfunction ProfilePage(): JSX.Element {\r\n    // NB: this works only in production if you put subfolders with past builds in the new build root.\r\n    return(<Try>\r\n        <Dashboard active={'Profile'} version={{n: 0, date:'fake-date'}}>\r\n            <>                \r\n\r\n            <Cards>\r\n                <Cards.Item\r\n                    title={'Getting started'} \r\n                    subtitle={'Create your first notation.'}\r\n                    icon={'gettingstarted'} \r\n                    style={'rainbow'}   \r\n                />\r\n                {true && <Cards.Item icon={'question'} style={'clear'} title={'Ehy!'} subtitle={'What do you want to do today?'}/>}\r\n            </Cards>\r\n\r\n            <ul>\r\n                <li><a href={window.location.origin + '/jjodel'}>2.0</a></li>\r\n                <li><a href={window.location.origin + '/jjodel/2.1/'}>2.1</a></li>\r\n                <li><a href={window.location.origin + '/jjodel/2.2/'}>2.2 (to come)</a></li>\r\n            </ul>\r\n            </>\r\n            \r\n        </Dashboard>\r\n    </Try>);\r\n}\r\n\r\nexport {ProfilePage};\r\n","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\pages\\Settings.tsx",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\pages\\Notes.tsx",["936","937","938","939","940","941","942","943","944","945","946"],"import React, {ChangeEvent, MouseEventHandler, Component, Dispatch, ReactElement, useState, useRef } from 'react';\r\nimport {connect} from 'react-redux';\r\nimport {DProject, DState, LProject, Try, U} from '../joiner';\r\nimport {FakeStateProps} from '../joiner/types';\r\nimport {Dashboard, Project} from './components';\r\nimport Storage from \"../data/storage\";\r\n\r\nimport {Menu, Item, Divisor} from './components/menu/Menu';\r\n\r\nimport colors from '../static/img/colors.png';\r\nimport {CatalogInfoCard} from \"./components/catalog/Catalog\";\r\n\r\n\r\n\r\ntype CardsType = {\r\n    children: any;\r\n};\r\n\r\n\r\nconst Cards = (props: CardsType): any => {\r\n    return (\r\n        <React.Fragment>\r\n            <div className='row mb-5 commandbar'>\r\n                {props.children}\r\n            </div>\r\n        </React.Fragment>\r\n    );\r\n}\r\n\r\ntype CardType = {\r\n    icon: \"add\" | \"import\" | \"clone\" | \"question\";\r\n    style?: \"blue\" | \"red\" | \"dark\" | \"clear\" | \"rainbow\" | \"default\";\r\n    title: string;\r\n    subtitle: string;\r\n    action?: MouseEventHandler;\r\n    children?: JSX.Element[];\r\n};\r\n\r\nconst Card = (props: CardType) => {\r\n\r\n    const icons = {\r\n        add: \"bi-plus-circle\",\r\n        import: \"bi-box-arrow-in-up\",\r\n        question: \"bi-question-square\",\r\n        clone: \"bi-clipboard2-check\"\r\n    };\r\n\r\n    return (<>\r\n        <div className={`card ${props.style ? props.style : 'default' }`}>\r\n            <div className={'col icon'}>\r\n                {props.action ?\r\n                    <i onClick={props.action} className={`bi ${icons[props.icon]}`}></i> :\r\n                    <i className={`bi ${icons[props.icon]} disabled`}></i>\r\n                }\r\n            </div>\r\n            <div className={'col body'}>\r\n                <h5>{props.title}</h5>\r\n                {props.subtitle}\r\n            </div>\r\n        </div>\r\n        </>\r\n    );\r\n}\r\n\r\nCards.Item = Card;\r\n\r\ntype ChildrenType = {\r\n    projects?: any;\r\n    children?: JSX.Element[];\r\n};\r\n\r\n\r\n/* main component */\r\n\r\nconst Catalog = (props: ChildrenType) => {\r\n\r\n    const [filters, setFilters] = useState([false,false,false]);\r\n    const [mode, setMode] = useState<string>(\"cards\");\r\n\r\n    const Header = (props: ChildrenType) => {\r\n        return (\r\n            <div className='row catalog-header'>\r\n                {props.children}\r\n            </div>\r\n        );\r\n    }\r\n\r\n    const CatalogFilters = () => {\r\n\r\n        function toggleFilters(el: 0|1|2) {\r\n            switch(el) {\r\n                case 0:\r\n                    setFilters([!filters[0], filters[1], filters[2]]);\r\n                    break;\r\n                case 1:\r\n                    setFilters([filters[0], !filters[1], filters[2]]);\r\n                    break;\r\n                case 2:\r\n                    setFilters([filters[0], filters[1], !filters[2]]);\r\n                    break;\r\n            }\r\n        };\r\n\r\n        return (\r\n            <div className={'col left'}>\r\n                {filters[0] ? <button onClick={(e) => toggleFilters(0)} className='active'>public</button> : <button onClick={(e) => toggleFilters(0)}>public</button>}\r\n                {filters[1] ? <button onClick={(e) => toggleFilters(1)} className='active'>private</button> : <button onClick={(e) => toggleFilters(1)}>private</button>}\r\n                {filters[2] ? <button onClick={(e) => toggleFilters(2)} className='active'>collaborative</button> : <button onClick={(e) => toggleFilters(2)} >collaborative</button>}\r\n            </div>\r\n        );\r\n    }\r\n\r\n    const CatalogMode = () => { // unused component?\r\n        return (<>\r\n            <div className={'col left'}>\r\n                <div className=\"float-end\">sorted by\r\n                    <div className={'view-icons'}>\r\n                        <i onClick={(e) => setMode('cards')} className={`bi bi-grid ${mode === \"cards\" && 'selected'}`}></i>\r\n                        <i onClick={(e) => setMode('list')} className={`bi bi-list ${mode === \"list\" && 'selected'}`}></i>\r\n                    </div>\r\n                    <div style={{float: 'right'}}>\r\n                    <Menu position={'left'}>\r\n                        <Item action={(e)=> {alert('')}}>Alphabetical</Item>\r\n                        <Item>Date created</Item>\r\n                        <Item>Last modified</Item>\r\n                    </Menu>\r\n                    </div>\r\n                </div>\r\n            </div>\r\n        </>);\r\n    }\r\n\r\n    const CatalogSide = (props: ChildrenType) => {\r\n        return (\r\n            <div className={'catalog'}>\r\n                {props.children}\r\n            </div>\r\n        );\r\n    }\r\n\r\n\r\n    type CatalogType = {\r\n        projects: LProject[];\r\n    }\r\n\r\n    const CatalogReport = (props: CatalogType) =>{\r\n\r\n        let items_public: LProject[] = [];\r\n        let items_private: LProject[] = [];\r\n        let items_collaborative: LProject[] = [];\r\n\r\n\r\n        if (filters[0]) {\r\n            items_public = props.projects.filter(p => p.type === \"public\");\r\n        }\r\n        if (filters[1]) {\r\n            items_private = props.projects.filter(p => p.type === \"private\");\r\n        }\r\n        if (filters[2]) {\r\n            items_collaborative = props.projects.filter(p => p.type === \"collaborative\");\r\n        }\r\n\r\n        //var items  = items_public.concat(items_private,items_collaborative);\r\n\r\n        var items = props.projects.filter(p =>\r\n            (filters[0] && p.type ===\"public\" || filters[1] && p.type ===\"private\" || filters[2] && p.type ===\"collaborative\" || !filters[0] && !filters[1] && !filters[2]));\r\n\r\n        return (\r\n\r\n            mode == \"cards\" ?\r\n\r\n            <div style={{display: (items.length > 0) ? 'flex' : 'flex'}} className={'flex-wrap'} >\r\n\r\n                {items.length === 0 && <div>Sorry, there are no results matching your search criteria. Please try again with different filters.</div>}\r\n\r\n                {\r\n                    props.projects.map(p => <>\r\n                        {filters[0] && p.type === \"public\" && <Project key={p.id} data={p} mode={mode} />}\r\n                        {filters[1] && p.type === \"private\" && <Project key={p.id} data={p} mode={mode} />}\r\n                        {filters[2] && p.type === \"collaborative\" && <Project key={p.id} data={p} mode={mode} />}\r\n                        {!filters[0] && !filters[1] && !filters[2] && <Project key={p.id} data={p} mode={mode} />}\r\n                    </>)\r\n                }\r\n\r\n            </div>\r\n\r\n            :\r\n            <div className={'row project-list'}>\r\n                <div className='row header'>\r\n                    <div className={'col-6'}>Name</div><div className={'col-3'}>Last modified</div><div className={'col-3'}>Created</div>\r\n                </div>\r\n                {\r\n                    props.projects.map(p => <>\r\n                        {filters[0] && p.type === \"public\" && <Project key={p.id} data={p} mode={mode} />}\r\n                        {filters[1] && p.type === \"private\" && <Project key={p.id} data={p} mode={mode} />}\r\n                        {filters[2] && p.type === \"collaborative\" && <Project key={p.id} data={p} mode={mode} />}\r\n                        {!filters[0] && !filters[1] && !filters[2] && <Project key={p.id} data={p} mode={mode} />}\r\n                    </>)\r\n                }\r\n            </div>\r\n\r\n        );\r\n    };\r\n\r\n    return (\r\n        <div>\r\n            <Header>\r\n                <CatalogFilters/>\r\n                <CatalogMode/>\r\n            </Header>\r\n            <CatalogSide>\r\n                <CatalogInfoCard projects={props.projects}/>\r\n                <CatalogReport projects={props.projects}/>\r\n            </CatalogSide>\r\n        </div>\r\n    );\r\n}\r\n\r\nfunction AllProjectsComponent(props: AllProps): JSX.Element {\r\n    const {projects} = props;\r\n\r\n    const reader = new FileReader();\r\n    reader.onload = async e => {\r\n        /* Import Project File */\r\n        const content = String(e.target?.result);\r\n        if(!content) return;\r\n        try {\r\n            const project = JSON.parse(content) as DProject;\r\n            const projects = Storage.read<DProject[]>('projects') || [];\r\n            const filtered = projects.filter(p => p.id !== project.id);\r\n            filtered.push(project);\r\n            Storage.write('projects', filtered);\r\n            U.resetState();\r\n        } catch (e) {alert('Invalid File.')}\r\n    }\r\n\r\n    const importProject = async(e: ChangeEvent<HTMLInputElement>) => {\r\n        const files = e.target.files || [];\r\n        if(!files.length) return;\r\n        const file = files[0];\r\n        reader.readAsText(file);\r\n    }\r\n\r\n\r\n\r\n\r\n    return(<Try>\r\n        <Dashboard active={'Notes'} version={props.version}>\r\n\r\n            <React.Fragment>\r\n\r\n                <Cards>\r\n                    <Cards.Item\r\n                        title={'Clone a template'}\r\n                        subtitle={'Clone a template in your workspace.'}\r\n                        icon={'clone'}\r\n                        style={'rainbow'}\r\n                    />\r\n                    {true && <Cards.Item icon={'question'} style={'clear'} title={'Ehy!'} subtitle={'What do you want to do today?'}/>}\r\n                </Cards>\r\n\r\n                <Catalog projects={projects} />\r\n            </React.Fragment>\r\n\r\n        </Dashboard>\r\n    </Try>);\r\n}\r\n\r\ninterface OwnProps {}\r\ninterface StateProps {\r\n    projects: LProject[];\r\n    version: DState[\"version\"];\r\n}\r\ninterface DispatchProps {}\r\n\r\ntype AllProps = OwnProps & StateProps & DispatchProps;\r\n\r\n\r\nfunction mapStateToProps(state: DState, ownProps: OwnProps): StateProps {\r\n    const ret: StateProps = {} as FakeStateProps;\r\n    ret.projects = LProject.fromArr(state.projects);\r\n    ret.version = state.version;\r\n    return ret;\r\n}\r\n\r\nfunction mapDispatchToProps(dispatch: Dispatch<any>): DispatchProps {\r\n    const ret: DispatchProps = {};\r\n    return ret;\r\n}\r\n\r\nconst AllProjectsConnected = connect<StateProps, DispatchProps, OwnProps, DState>(\r\n    mapStateToProps,\r\n    mapDispatchToProps\r\n)(AllProjectsComponent);\r\n\r\nconst NotesPage = (props: OwnProps, children: (string | Component)[] = []): ReactElement => {\r\n    return <AllProjectsConnected {...{...props, children}} />;\r\n}\r\n\r\nexport {NotesPage};\r\n\r\n","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\pages\\Recent.tsx",["947","948"],"import React, {ChangeEvent, MouseEventHandler, Component, Dispatch, ReactElement, useState, useRef } from 'react';\r\nimport {connect} from 'react-redux';\r\nimport {DProject, DState, LProject, Try, U} from '../joiner';\r\nimport {FakeStateProps} from '../joiner/types';\r\nimport {Dashboard, Project} from './components';\r\nimport Storage from \"../data/storage\";\r\n\r\nimport {Menu, Item, Divisor} from './components/menu/Menu';\r\nimport { Cards, Card } from './components/cards/Cards';\r\nimport { Catalog } from './components/catalog/Catalog';\r\n\r\nimport colors from '../static/img/colors.png';\r\n\r\n\r\nfunction AllProjectsComponent(props: AllProps): JSX.Element {\r\n    const {projects} = props;\r\n\r\n    const reader = new FileReader();\r\n    reader.onload = async e => {\r\n        /* Import Project File */\r\n        const content = String(e.target?.result);\r\n        if(!content) return;\r\n        try {\r\n            const project = JSON.parse(content) as DProject;\r\n            const projects = Storage.read<DProject[]>('projects') || [];\r\n            const filtered = projects.filter(p => p.id !== project.id);\r\n            filtered.push(project);\r\n            Storage.write('projects', filtered);\r\n            U.resetState();\r\n        } catch (e) {alert('Invalid File.')}\r\n    }\r\n    \r\n    const importProject = async(e: ChangeEvent<HTMLInputElement>) => {\r\n        const files = e.target.files || [];\r\n        if(!files.length) return;\r\n        const file = files[0];\r\n        reader.readAsText(file);\r\n    }\r\n\r\n\r\n\r\n\r\n    return(<Try>\r\n        <Dashboard active={'Recent'} version={props.version}>\r\n            \r\n            <React.Fragment>                \r\n\r\n                <Cards>\r\n                    <Cards.Item\r\n                        title={'Need help?'} \r\n                        subtitle={'Don\\' ask Alexa, click here instead.'}\r\n                        icon={'alexa'} \r\n                        style={'red-orange'}   \r\n                    />\r\n                    {false && <Cards.Item icon={'question'} style={'clear'} title={'Ehy!'} subtitle={'What do you want to do today?'}/>}\r\n                </Cards>\r\n\r\n                <Catalog projects={projects} />\r\n            </React.Fragment>\r\n            \r\n        </Dashboard>\r\n    </Try>);\r\n}\r\n\r\ninterface OwnProps {}\r\ninterface StateProps {\r\n    projects: LProject[];\r\n    version: DState[\"version\"];\r\n}\r\ninterface DispatchProps {}\r\n\r\ntype AllProps = OwnProps & StateProps & DispatchProps;\r\n\r\n\r\nfunction mapStateToProps(state: DState, ownProps: OwnProps): StateProps {\r\n    const ret: StateProps = {} as FakeStateProps;\r\n    ret.projects = LProject.fromArr(state.projects);\r\n    ret.version = state.version;\r\n    return ret;\r\n}\r\n\r\nfunction mapDispatchToProps(dispatch: Dispatch<any>): DispatchProps {\r\n    const ret: DispatchProps = {};\r\n    return ret;\r\n}\r\n\r\nconst AllProjectsConnected = connect<StateProps, DispatchProps, OwnProps, DState>(\r\n    mapStateToProps,\r\n    mapDispatchToProps\r\n)(AllProjectsComponent);\r\n\r\nconst RecentPage = (props: OwnProps, children: (string | Component)[] = []): ReactElement => {\r\n    return <AllProjectsConnected {...{...props, children}} />;\r\n}\r\n\r\nexport {RecentPage};\r\n\r\n","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\pages\\Error.tsx",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\pages\\Templates.tsx",["949","950","951","952","953","954","955","956","957","958","959"],"import React, {ChangeEvent, MouseEventHandler, Component, Dispatch, ReactElement, useState, useRef } from 'react';\r\nimport {connect} from 'react-redux';\r\nimport {DProject, DState, LProject, Try, U} from '../joiner';\r\nimport {FakeStateProps} from '../joiner/types';\r\nimport {Dashboard, Project} from './components';\r\nimport Storage from \"../data/storage\";\r\n\r\nimport {Menu, Item, Divisor} from './components/menu/Menu';\r\n\r\nimport colors from '../static/img/colors.png';\r\nimport {CatalogInfoCard} from \"./components/catalog/Catalog\";\r\n\r\n\r\n\r\ntype CardsType = {\r\n    children: any;\r\n};\r\n\r\nconst Cards = (props: CardsType): any => {\r\n    return (\r\n        <React.Fragment>\r\n            <div className='row mb-5 commandbar'>\r\n                {props.children}\r\n            </div>\r\n        </React.Fragment>\r\n    );\r\n}\r\n\r\ntype CardType = {\r\n    icon: \"add\" | \"import\" | \"clone\" | \"question\";\r\n    style?: \"blue\" | \"red\" | \"dark\" | \"clear\" | \"rainbow\" | \"default\";\r\n    title: string;\r\n    subtitle: string;\r\n    action?: MouseEventHandler;\r\n    children?: JSX.Element[];\r\n};\r\n\r\nconst Card = (props: CardType) => {\r\n\r\n    const icons = {\r\n        add: \"bi-plus-circle\",\r\n        import: \"bi-box-arrow-in-up\",\r\n        question: \"bi-question-square\",\r\n        clone: \"bi-clipboard2-check\"\r\n    };\r\n\r\n    return (<>\r\n        <div className={`card ${props.style ? props.style : 'default' }`}>\r\n            <div className={'col icon'}>\r\n                {props.action ?\r\n                    <i onClick={props.action} className={`bi ${icons[props.icon]}`}></i> :\r\n                    <i className={`bi ${icons[props.icon]} disabled`}></i>\r\n                }\r\n            </div>\r\n            <div className={'col body'}>\r\n                <h5>{props.title}</h5>\r\n                {props.subtitle}\r\n            </div>\r\n        </div>\r\n        </>\r\n    );\r\n}\r\n\r\nCards.Item = Card;\r\n\r\ntype ChildrenType = {\r\n    projects?: any;\r\n    children?: JSX.Element[];\r\n};\r\n\r\n\r\n/* main component */\r\n\r\nconst Catalog = (props: ChildrenType) => {\r\n\r\n    const [filters, setFilters] = useState([false,false,false]);\r\n    const [mode, setMode] = useState<string>(\"cards\");\r\n\r\n    const Header = (props: ChildrenType) => {\r\n        return (\r\n            <div className='row catalog-header'>\r\n                {props.children}\r\n            </div>\r\n        );\r\n    }\r\n\r\n    const CatalogFilters = () => {\r\n\r\n        function toggleFilters(el: 0|1|2) {\r\n            switch(el) {\r\n                case 0:\r\n                    setFilters([!filters[0], filters[1], filters[2]]);\r\n                    break;\r\n                case 1:\r\n                    setFilters([filters[0], !filters[1], filters[2]]);\r\n                    break;\r\n                case 2:\r\n                    setFilters([filters[0], filters[1], !filters[2]]);\r\n                    break;\r\n            }\r\n        };\r\n\r\n        return (\r\n            <div className={'col left'}>\r\n                {filters[0] ? <button onClick={(e) => toggleFilters(0)} className='active'>public</button> : <button onClick={(e) => toggleFilters(0)}>public</button>}\r\n                {filters[1] ? <button onClick={(e) => toggleFilters(1)} className='active'>private</button> : <button onClick={(e) => toggleFilters(1)}>private</button>}\r\n                {filters[2] ? <button onClick={(e) => toggleFilters(2)} className='active'>collaborative</button> : <button onClick={(e) => toggleFilters(2)} >collaborative</button>}\r\n            </div>\r\n        );\r\n    }\r\n\r\n    const CatalogMode = () => { // unused component?\r\n        return (<>\r\n            <div className={'col left'}>\r\n                <div className=\"float-end\">sorted by\r\n                    <div className={'view-icons'}>\r\n                        <i onClick={(e) => setMode('cards')} className={`bi bi-grid ${mode === \"cards\" && 'selected'}`}></i>\r\n                        <i onClick={(e) => setMode('list')} className={`bi bi-list ${mode === \"list\" && 'selected'}`}></i>\r\n                    </div>\r\n                    <div style={{float: 'right'}}>\r\n                    <Menu position={'left'}>\r\n                        <Item action={(e)=> {alert('')}}>Alphabetical</Item>\r\n                        <Item>Date created</Item>\r\n                        <Item>Last modified</Item>\r\n                    </Menu>\r\n                    </div>\r\n                </div>\r\n            </div>\r\n        </>);\r\n    }\r\n\r\n    const CatalogSide = (props: ChildrenType) => {\r\n        return (\r\n            <div className={'catalog'}>\r\n                {props.children}\r\n            </div>\r\n        );\r\n    }\r\n\r\n\r\n    type CatalogType = {\r\n        projects: LProject[];\r\n    }\r\n\r\n    const CatalogReport = (props: CatalogType) =>{\r\n\r\n        let items_public: LProject[] = [];\r\n        let items_private: LProject[] = [];\r\n        let items_collaborative: LProject[] = [];\r\n\r\n\r\n        if (filters[0]) {\r\n            items_public = props.projects.filter(p => p.type === \"public\");\r\n        }\r\n        if (filters[1]) {\r\n            items_private = props.projects.filter(p => p.type === \"private\");\r\n        }\r\n        if (filters[2]) {\r\n            items_collaborative = props.projects.filter(p => p.type === \"collaborative\");\r\n        }\r\n\r\n        //var items  = items_public.concat(items_private,items_collaborative);\r\n\r\n        var items = props.projects.filter(p =>\r\n            (filters[0] && p.type ===\"public\" || filters[1] && p.type ===\"private\" || filters[2] && p.type ===\"collaborative\" || !filters[0] && !filters[1] && !filters[2]));\r\n\r\n        return (\r\n\r\n            mode == \"cards\" ?\r\n\r\n            <div style={{display: (items.length > 0) ? 'flex' : 'flex'}} className={'flex-wrap'} >\r\n\r\n                {items.length === 0 && <div>Sorry, there are no results matching your search criteria. Please try again with different filters.</div>}\r\n\r\n                {\r\n                    props.projects.map(p => <>\r\n                        {filters[0] && p.type === \"public\" && <Project key={p.id} data={p} mode={mode} />}\r\n                        {filters[1] && p.type === \"private\" && <Project key={p.id} data={p} mode={mode} />}\r\n                        {filters[2] && p.type === \"collaborative\" && <Project key={p.id} data={p} mode={mode} />}\r\n                        {!filters[0] && !filters[1] && !filters[2] && <Project key={p.id} data={p} mode={mode} />}\r\n                    </>)\r\n                }\r\n\r\n            </div>\r\n\r\n            :\r\n            <div className={'row project-list'}>\r\n                <div className='row header'>\r\n                    <div className={'col-6'}>Name</div><div className={'col-3'}>Last modified</div><div className={'col-3'}>Created</div>\r\n                </div>\r\n                {\r\n                    props.projects.map(p => <>\r\n                        {filters[0] && p.type === \"public\" && <Project key={p.id} data={p} mode={mode} />}\r\n                        {filters[1] && p.type === \"private\" && <Project key={p.id} data={p} mode={mode} />}\r\n                        {filters[2] && p.type === \"collaborative\" && <Project key={p.id} data={p} mode={mode} />}\r\n                        {!filters[0] && !filters[1] && !filters[2] && <Project key={p.id} data={p} mode={mode} />}\r\n                    </>)\r\n                }\r\n            </div>\r\n\r\n        );\r\n    };\r\n\r\n    return (\r\n        <div>\r\n            <Header>\r\n                <CatalogFilters/>\r\n                <CatalogMode/>\r\n            </Header>\r\n            <CatalogSide>\r\n                <CatalogInfoCard projects={props.projects}/>\r\n                <CatalogReport projects={props.projects}/>\r\n            </CatalogSide>\r\n        </div>\r\n    );\r\n}\r\n\r\nfunction AllProjectsComponent(props: AllProps): JSX.Element {\r\n    const {projects} = props;\r\n\r\n    const reader = new FileReader();\r\n    reader.onload = async e => {\r\n        /* Import Project File */\r\n        const content = String(e.target?.result);\r\n        if(!content) return;\r\n        try {\r\n            const project = JSON.parse(content) as DProject;\r\n            const projects = Storage.read<DProject[]>('projects') || [];\r\n            const filtered = projects.filter(p => p.id !== project.id);\r\n            filtered.push(project);\r\n            Storage.write('projects', filtered);\r\n            U.resetState();\r\n        } catch (e) {alert('Invalid File.')}\r\n    }\r\n\r\n    const importProject = async(e: ChangeEvent<HTMLInputElement>) => {\r\n        const files = e.target.files || [];\r\n        if(!files.length) return;\r\n        const file = files[0];\r\n        reader.readAsText(file);\r\n    }\r\n\r\n\r\n\r\n\r\n    return(<Try>\r\n        <Dashboard active={'Templates'} version={props.version}>\r\n\r\n            <React.Fragment>\r\n\r\n                <Cards>\r\n                    <Cards.Item\r\n                        title={'Clone a template'}\r\n                        subtitle={'Clone a template in your workspace.'}\r\n                        icon={'clone'}\r\n                        style={'rainbow'}\r\n                    />\r\n                    {true && <Cards.Item icon={'question'} style={'clear'} title={'Ehy!'} subtitle={'What do you want to do today?'}/>}\r\n                    \r\n                </Cards>\r\n\r\n                <Catalog projects={projects} />\r\n            </React.Fragment>\r\n\r\n        </Dashboard>\r\n    </Try>);\r\n}\r\n\r\ninterface OwnProps {}\r\ninterface StateProps {\r\n    projects: LProject[];\r\n    version: DState[\"version\"];\r\n}\r\ninterface DispatchProps {}\r\n\r\ntype AllProps = OwnProps & StateProps & DispatchProps;\r\n\r\n\r\nfunction mapStateToProps(state: DState, ownProps: OwnProps): StateProps {\r\n    const ret: StateProps = {} as FakeStateProps;\r\n    ret.projects = LProject.fromArr(state.projects);\r\n    ret.version = state.version;\r\n    return ret;\r\n}\r\n\r\nfunction mapDispatchToProps(dispatch: Dispatch<any>): DispatchProps {\r\n    const ret: DispatchProps = {};\r\n    return ret;\r\n}\r\n\r\nconst AllProjectsConnected = connect<StateProps, DispatchProps, OwnProps, DState>(\r\n    mapStateToProps,\r\n    mapDispatchToProps\r\n)(AllProjectsComponent);\r\n\r\nconst TemplatePage = (props: OwnProps, children: (string | Component)[] = []): ReactElement => {\r\n    return <AllProjectsConnected {...{...props, children}} />;\r\n}\r\n\r\nexport {TemplatePage};\r\n\r\n","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\pages\\News.tsx",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\pages\\UsersInfo.tsx",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\pages\\ProjectsInfo.tsx",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\graph\\vertex\\Vertex.tsx",["960","961"],"import React, {Dispatch, ReactElement, ReactNode} from 'react';\r\nimport {connect} from 'react-redux';\r\nimport {\r\n    Debug,\r\n    DEdgePoint,\r\n    DGraph,\r\n    DGraphElement,\r\n    DGraphVertex,\r\n    DState, DUser,\r\n    DVertex, DViewElement,\r\n    DVoidVertex,\r\n    EMeasurableEvents,\r\n    GObject,\r\n    GraphElementComponent,\r\n    GraphElementDispatchProps,\r\n    GraphElementOwnProps,\r\n    GraphElementReduxStateProps,\r\n    GraphElementStatee,\r\n    GraphPoint,\r\n    GraphSize,\r\n    LClass, LGraph, LGraphElement,\r\n    LModelElement, LNamedElement,\r\n    Log,\r\n    LPointerTargetable,\r\n    LUser, LViewElement,\r\n    LViewPoint,\r\n    LVoidVertex, Pointer,\r\n    RuntimeAccessibleClass,\r\n    SetRootFieldAction,\r\n    Size,\r\n    TRANSACTION,\r\n    U,\r\n} from '../../joiner';\r\nimport $ from 'jquery';\r\nimport 'jqueryui';\r\nimport 'jqueryui/jquery-ui.css';\r\nimport { lightModeAllowedElements } from '../graphElement/graphElement';\r\nimport ContextMenu from \"../../components/contextMenu/ContextMenu\";\r\nimport {VertexOwnProps, VertexStateProps} from '../graphElement/sharedTypes/sharedTypes';\r\n\r\nconst superclassGraphElementComponent: typeof GraphElementComponent = RuntimeAccessibleClass.classes.GraphElementComponent as any as typeof GraphElementComponent;\r\nclass ThisStatee extends GraphElementStatee { forceupdate?: number }\r\n\r\nconst dragHelper = document.createElement('div');\r\ndragHelper.style.backgroundColor = 'transparent';\r\ndragHelper.style.outline = '1px dashed black'; // '4px dashed #333';\r\ndragHelper.style.zIndex = '9999';\r\n\r\n\r\nexport class VertexComponent<AllProps extends AllPropss = AllPropss, ThisState extends ThisStatee = ThisStatee>\r\n    extends superclassGraphElementComponent<AllProps, ThisState> {\r\n    public static cname: string = 'VertexComponent';\r\n    static defaultProps: Partial<VertexOwnProps> = VertexOwnProps.new();\r\n    draggableOptions: GObject | undefined;\r\n    resizableOptions: GObject | undefined;\r\n    rotableOptions: GObject | undefined;\r\n\r\n    constructor(props: AllProps, context: any) {\r\n        super(props, context);\r\n        this.getSize = this.getSize.bind(this);\r\n        this.setSize = this.setSize.bind(this);\r\n        // this.state={forceupdate:1};\r\n        /*// remove this?\r\n        setTimeout(()=>{\r\n            this.getSize = this.getSize.bind(this);\r\n            this.setSize = this.setSize.bind(this);\r\n            // this.get_size = console.error as any;\r\n            // this.r = (<RootVertex props={this.props} render={super.render()} super={this} />);\r\n            this.forceUpdate();\r\n            this.setState({forceupdate:2});\r\n        },1)*/\r\n    }\r\n/*\r\n    onViewChangeOld(): void {\r\n        super.onViewChangeOld();\r\n        this.draggableOptions = undefined;\r\n        this.resizableOptions = undefined;\r\n        this.rotableOptions = undefined;\r\n    }*/\r\n\r\n    onHtmlNodeChange(){\r\n        this.draggableOptions = undefined;\r\n        this.resizableOptions = undefined;\r\n        this.rotableOptions = undefined;\r\n        this.oldHtml = this.html.current;\r\n    }\r\n\r\n    setVertexProperties(){\r\n        if (!this.props.node || !this.html.current) return;\r\n        switch (this.nodeType){\r\n            case 'GraphVertex':\r\n            case 'Vertex':\r\n            case 'VoidVertex':\r\n            case 'EdgePoint': break;\r\n            default: return;\r\n        }\r\n\r\n        let html = this.html.current;\r\n        const $measurable: GObject<'JQuery + ui plugin'> = $(html); // todo: install typings\r\n\r\n        let view: LViewElement = this.props.view;\r\n        let isDraggable: boolean = view.draggable;\r\n        let isResizable: boolean = view.resizable;\r\n        let allviews: Pointer<DViewElement>[] = [view, ...this.props.views].map(v=>v.id);\r\n        // $element = $(html).find('.measurable').addBack();\r\n        try {\r\n        if (!isDraggable) {\r\n            if ($measurable.data(\"uiDraggable\")) $measurable.draggable('disable');\r\n        }\r\n        else if (this.draggableOptions) {\r\n            if ($measurable.data(\"uiDraggable\")) $measurable.draggable('enable');\r\n            // NB: this check is to see if draggable has been setup. i think if 2 refreshes happens to fast it can\r\n            // happen that this.draggableOptions i set, but jqui didn't set up the draggable infos and throws warnings.\r\n        }\r\n        else {\r\n            // first setup only\r\n            this.draggableOptions = {\r\n                cursor: 'grabbing',\r\n                cancel: '.no-drag,[contenteditable=\"true\"],input,textarea,button,select,option',\r\n                // cancel: '.no-drag,input,textarea,button,select,option',\r\n                containment: 'parent',\r\n                opacity: 0.0,\r\n                disabled: !(isDraggable), // this does not work, i think because once set the first time the whole declaration is not re-applied. would need to undo draggable\r\n                distance: 5,\r\n                helper: () => { // or 'clone'\r\n                    // dragHelper.style.display='block';\r\n                    let size = this.getSize();\r\n                    // let actualSize = Size.of(html);\r\n                    // if (size.w !== actualSize.w || size.h !== actualSize.h) this.setSize({w:actualSize.w, h:actualSize.h});\r\n                    dragHelper.style.width = size.w + 'px';\r\n                    dragHelper.style.height = size.h + 'px';\r\n                    dragHelper.style.opacity = '1'; // this.props.view.constraints.length ? '1' : '0.5';\r\n                    if (this.props.view.lazySizeUpdate) dragHelper.classList.add('lazySizeUpdate');\r\n                    else dragHelper.classList.remove('lazySizeUpdate');\r\n                    return dragHelper;\r\n                },\r\n                // disabled: !(view.draggable),\r\n                start: (event: GObject, obj: GObject) => {\r\n                    TRANSACTION('Vertex dragStart ' + this.props.node.name, ()=> {\r\n                        for (let vid of allviews) this.doMeasurableEvent(EMeasurableEvents.onDragStart, vid);\r\n                    })\r\n                },\r\n                drag: (event: GObject, obj: GObject) => {\r\n                    TRANSACTION('Vertex dragging ' + this.props.node.name, ()=>{\r\n                        // console.log('Vertex.setsize', obj);\r\n                        if (!this.props.view.lazySizeUpdate) this.setSize({x:obj.position.left, y:obj.position.top});\r\n                        for (let vid of allviews) this.doMeasurableEvent(EMeasurableEvents.whileDragging, vid);\r\n                    })\r\n                },\r\n                stop: (event: GObject, obj: GObject) => {\r\n                    TRANSACTION('Vertex dragEnd ' + this.props.node.name, ()=>{\r\n                        this.setSize({x:obj.position.left, y:obj.position.top});\r\n                        for (let vid of allviews) this.doMeasurableEvent(EMeasurableEvents.onDragEnd, vid);\r\n                    })\r\n                }\r\n            };\r\n            $measurable.draggable(this.draggableOptions);\r\n        }\r\n        } catch(e) {\r\n            this.draggableOptions = undefined;\r\n            Log.ee(\"failed to setup / update draggable uptions\", e, this, this.props.node, this.props.data);\r\n            return;\r\n            // might throw error if element is not visible or in the dom or similar, but i won't care in that case.\r\n            // but i reset draggableOptions so it can retry later if element enters the DOM instead of thinking it is already finished setup\r\n        }\r\n\r\n        try{\r\n        if (!isResizable) {\r\n            if ($measurable.data(\"uiResizable\")) $measurable.resizable('disable');\r\n        }\r\n        else if (this.resizableOptions) {\r\n            if ($measurable.data(\"uiResizable\")) $measurable.resizable('enable');\r\n        }\r\n        if (!this.resizableOptions) {\r\n            this.resizableOptions = {\r\n                helper: 'selected-by-me',\r\n                start: (event: GObject, obj: GObject) => {\r\n                    TRANSACTION('onResizeStart events ' + this.props.node.name, ()=>{\r\n                        if (!this.props.node.isResized) this.props.node.isResized = true; // set only on manual resize, so here and not on setSize()\r\n                        for (let vid of allviews) this.doMeasurableEvent(EMeasurableEvents.onResizeStart, vid);\r\n                    })\r\n                },\r\n                resize: (event: GObject, obj: GObject) => {\r\n                    TRANSACTION('resizing events ' + this.props.node.name, ()=>{\r\n                        if (!this.props.view.lazySizeUpdate) this.setSize({w:obj.position.width, h:obj.position.height});\r\n                        for (let vid of allviews) this.doMeasurableEvent(EMeasurableEvents.whileResizing, vid);\r\n                    })\r\n                },\r\n                stop: (event: GObject, obj: GObject) => {\r\n                    if (!this.state.classes.includes('resized')) this.setState({classes:[...this.state.classes, 'resized']});\r\n                    // if (!withSetSize) { node.width = obj.size.width; node.height = obj.size.height; } else {\r\n                    let absolutemode = true; // this one is less tested and safe, but should work even if html container is sized 0. best if made to work\r\n                    let newSize: Partial<GraphSize>;\r\n                    if (absolutemode) {\r\n                        let nativeevt: MouseEvent = event.originalEvent.originalEvent;\r\n                        let htmlSize = Size.of(event.target, false);\r\n                        newSize = this.props.node.graph.translateHtmlSize(htmlSize);\r\n                        /*n\r\n                        this is some pixels off, i think because inner coords are post the border of the container element,\r\n                         and the innermost graph size have coords before his borders, so the translation is off by the amount\r\n                          of border width of the innermost graph (and package default view does have a border)\r\n                           so in graph coord translate function should add: outersize.add( x: innergraph.html.getFinalComputedCSS('border-width-left'), y: ...border-width-top\r\n\r\n                    let cursorSize = new GraphSize(0, 0, nativeevt.clientX, nativeevt.clientY);//\r\n                    newSize = htmlSize.duplicate() as any; // .subtract( {w:cursorSize.x, h:cursorSize.y}, true);\r\n                    let handleClasses: string[] = [...event.originalEvent.target.classList];\r\n                    let handleKeyLength = 14; // equal to 'ui-resizable-'.length + 1;\r\n                    let handleClassName = handleClasses.find( // i check both length and indexOf, because i must match 'ui-resizable-se' but not 'ui-resizable-handle'\r\n                        (e) => (e.length === handleKeyLength || e.length === handleKeyLength + 1) && e.indexOf('ui-resizable-')===0);\r\n\r\n                        let handleType = handleClassName ? handleClassName.substring(13) : '';\r\n                        switch (handleType) {\r\n                            default: case '': case 'se':\r\n                                delete newSize.x;\r\n                                delete newSize.y;\r\n                                newSize.w = cursorSize.w - htmlSize.x;\r\n                                newSize.h = cursorSize.h - htmlSize.y;\r\n                                break;\r\n                            case 'n': case 's':\r\n                                delete newSize.x;\r\n                                delete newSize.y;\r\n                                delete newSize.w;\r\n                                newSize.h = cursorSize.h - htmlSize.y;\r\n                                break;\r\n                            case 'e': case 'W':\r\n                                delete newSize.x;\r\n                                delete newSize.y;\r\n                                newSize.w = cursorSize.w - htmlSize.x;\r\n                                delete newSize.h;\r\n                                break;\r\n                            case 'nw':\r\n                                let br = htmlSize.br();\r\n                                newSize.x = cursorSize.x;\r\n                                newSize.y = cursorSize.y;\r\n                                newSize.w = br.x - cursorSize.w;\r\n                                newSize.h = br.y - cursorSize.h;\r\n                                break;\r\n                            case 'ne':\r\n                                delete newSize.x;\r\n                                newSize.y = cursorSize.y;\r\n                                delete newSize.w;\r\n                                delete newSize.h;\r\n                            case '?':\r\n                                delete newSize.x;\r\n                                delete newSize.y;\r\n                                delete newSize.w;\r\n                                delete newSize.h;\r\n                                break;\r\n                        }*/\r\n                        // n, e, s, w, ne, se, sw, nw\r\n                        console.log('resizing', {newSize, htmlSize, event, nativeevt, sizeof_with_transforms: Size.of(event.target, true)});\r\n                        // NB: size.x and size.y are going crazy if the element have an edge, no idea why, i just deleted x & y before setSize()\r\n                    }\r\n                    else newSize = {w:obj.size.width, h:obj.size.height};\r\n                    // evt coordinates: clientX, layerX, offsetX, pageX, screenX\r\n                    TRANSACTION('onResizeEnd events ' + this.props.node.name, ()=>{/*\r\n                        delete newSize.x;\r\n                        delete newSize.y;*/\r\n                        this.setSize(newSize);\r\n                        // console.log('resize setsize:', obj, {w:obj.size.width, h:obj.size.height});\r\n                        for (let vid of allviews) this.doMeasurableEvent(EMeasurableEvents.onResizeEnd, vid);\r\n                    })\r\n\r\n                }\r\n            }\r\n            $measurable.resizable(this.resizableOptions);\r\n        }\r\n        } catch(e){\r\n            // check draggable catch comment\r\n            this.resizableOptions = undefined;\r\n            Log.ee(\"failed to setup / update resizable uptions\", e, this, this.props.node, this.props.data);\r\n            return;\r\n        }\r\n\r\n        try{\r\n            // edit dynamic draggable options post-setup\r\n            if (this.draggableOptions) {\r\n                // none so far?\r\n            }\r\n            // edit dynamic resizable options post-setup\r\n            if (this.resizableOptions) {\r\n                let lazySizeUpdate = view.lazySizeUpdate;\r\n                let containment = lazySizeUpdate ? false : 'parent';\r\n                let helper = lazySizeUpdate ? 'resizable-helper-bad' : 'original';\r\n                // helper does not accept a func or htmlElem, but only a classname...\r\n                // and makes his own empty proxy element to resize in his place. inchoherent.\r\n                if (this.resizableOptions?.containment !== containment){\r\n                    this.resizableOptions.containment = containment;\r\n                    $measurable.draggable( 'option', 'containment', containment);\r\n                }\r\n                if (this.resizableOptions?.helper !== helper){\r\n                    this.resizableOptions.helper = helper;\r\n                    $measurable.resizable( 'option', 'helper', helper);\r\n                }\r\n            }\r\n        } catch(e) {\r\n            // check draggable catch comment\r\n            this.draggableOptions = undefined;\r\n            this.resizableOptions = undefined;\r\n            this.rotableOptions = undefined;\r\n            Log.ee(\"failed to update measurable uptions\", e, this, this.props.node, this.props.data);\r\n            return;\r\n        }\r\n    }\r\n\r\n\r\n\r\n    getSize(): Readonly<GraphSize> {\r\n        return this.props.node.getSize(false, !this.props.node.isResized && this.props.view.adaptWidth);\r\n        /*console.log('get_size('+(this.props?.data as any).name+')', {\r\n            view:this.props.view.getSize(this.props.dataid || this.props.nodeid as string),\r\n            node:this.props.node?.size,\r\n            default: this.props.view.defaultVSize});*/\r\n        let ret = this.props.view.getSize(this.props.data?.id || this.props.nodeid as string)\r\n            || this.props.node?.size\r\n            || this.props.view.defaultVSize;\r\n        if (this.props.node.isResized) return ret;\r\n        let actualSize: Partial<Size>&{w:number, h:number} = this.html.current ? Size.of(this.html.current as Element) : {w:0, h:0};\r\n        if (this.props.view.adaptWidth && ret.w !== actualSize.w) {\r\n            this.setSize({w:actualSize.w});\r\n            ret.w = actualSize.w;\r\n        }\r\n        if (this.props.view.adaptHeight && ret.h !== actualSize.h) {\r\n            this.setSize({h:actualSize.h});\r\n            ret.h = actualSize.h;\r\n        }\r\n        return ret;\r\n    }\r\n    // setSize(x_or_size_or_point: number, y?: number, w?:number, h?:number): void;\r\n    setSize(x_or_size_or_point: Partial<GraphPoint>): void;\r\n    setSize(x_or_size_or_point: Partial<GraphSize>): void;\r\n    // setSize(x_or_size_or_point: number | GraphSize | GraphPoint, y?: number, w?:number, h?:number): void;\r\n    setSize(size0: Partial<GraphSize> | Partial<GraphPoint>): void {\r\n        let size: {x?:number, y?: number, w?:number, h?:number} = size0;\r\n        if (size.w !== undefined && size.w < 0) size.w = 0;\r\n        if (size.h !== undefined && size.h < 0) size.h = 0;\r\n\r\n        console.log('L.setsize', size, size0);\r\n        return this.props.node.size = size as any;\r\n        // console.log('setSize('+(this.props?.data as any).name+') thisss', this);\r\n        if (this.props.view.storeSize) {\r\n            let id = (this.props.data?.id || this.props.nodeid) as string;\r\n            this.props.view.updateSize(id, size);\r\n            return;\r\n        }\r\n        let olds = this.props.node.size;\r\n        size.x = size.x === undefined ? olds?.x : size.x;\r\n        size.y = size.y === undefined ? olds?.y : size.y;\r\n        size.w = size.w === undefined ? olds?.w : size.w;\r\n        size.h = size.h === undefined ? olds?.h : size.h;\r\n        this.props.node.size = size as GraphSize;\r\n    }\r\n\r\n    oldHtml?: Element | null = null;\r\n    nodeType!: string;\r\n    render(): ReactNode {\r\n        if (Debug.lightMode && (!this.props.data || !(lightModeAllowedElements.includes(this.props.data.className)))){\r\n            return this.props.data ? <div>{\" \" + ((this.props.data as any).name)}:{this.props.data.className}</div> : undefined;\r\n        }\r\n        if (!this.props.node) return 'Loading Node...';\r\n\r\n        if (this.html.current !== this.oldHtml){ this.onHtmlNodeChange(); }\r\n\r\n        const cssOverride: string[] = [];\r\n        // const selected = this.props.selected;\r\n        // if (selected && selected.id === this.props.nodeid) cssOverride.push('selected-by-me');\r\n\r\n        // if(!windoww.cpts) windoww.cpts = {};\r\n        // windoww.cpts[this.props.nodeid]=this;\r\n        // console.log('updated');\r\n        //return this.r || <div>loading...</div>;\r\n\r\n        // set classes\r\n        this.nodeType = 'NODE_TYPE_ERROR';\r\n        if ( this.props.isEdgePoint) this.nodeType = 'EdgePoint'; else\r\n        if ( this.props.isGraph &&  this.props.isVertex) this.nodeType = 'GraphVertex'; else\r\n        if ( this.props.isGraph && !this.props.isVertex) this.nodeType = 'Graph'; else\r\n        if (!this.props.isGraph &&  this.props.isVertex && (this.props.isVoid || !this.props.data)) this.nodeType = 'VoidVertex'; else\r\n        if (!this.props.isGraph &&  this.props.isVertex) this.nodeType = 'Vertex'; else\r\n        if (!this.props.isGraph && !this.props.isVertex) this.nodeType = 'Field';\r\n\r\n        // const named: LNamedElement = this.props.data as LNamedElement; // LNamedElement.fromPointer(this.props.dataid);\r\n        const classesOverride = [this.nodeType, ...cssOverride]; // , (named?.name === 'default') ? 'default' : ''];\r\n        const styleOverride: React.CSSProperties = {};\r\n        // set classes end\r\n        const size: Readonly<GraphSize> = this.getSize();\r\n\r\n        let isVertex: boolean= false, isEdge: boolean= false, isGraph: boolean = false;\r\n        switch (this.nodeType) {\r\n            case 'Graph': isGraph = true; break;\r\n            case 'GraphVertex': isGraph = isVertex = true; break;\r\n            case 'Vertex':\r\n            case 'VoidVertex':\r\n            case 'EdgePoint':\r\n                isVertex = true;\r\n                break;\r\n            default: break;\r\n        }\r\n\r\n        if (isGraph){\r\n            let offset = (this.props.node as any as LGraph).offset;\r\n            let zoom = (this.props.node as any as LGraph).zoom;\r\n            // @ts-ignore\r\n            styleOverride['--offset-x'] = offset.x + 'px';\r\n            // @ts-ignore\r\n            styleOverride['--offset-y'] = offset.y + 'px';\r\n            // @ts-ignore\r\n            styleOverride['--zoom-x'] = zoom.x;\r\n            // @ts-ignore\r\n            styleOverride['--zoom-y'] = zoom.y;\r\n        }\r\n        if (isVertex){\r\n            // @ts-ignore\r\n            styleOverride['--top'] = size.y + 'px';\r\n            // @ts-ignore\r\n            styleOverride['--left'] = size.x + 'px';\r\n            let isResized = this.props.node.isResized;\r\n            if (isResized || !this.props.view.adaptWidth) styleOverride.width = size.w+'px';\r\n            else styleOverride.width = undefined;\r\n            if (isResized || !this.props.view.adaptHeight) styleOverride.height = size.h+'px';\r\n            else styleOverride.height = undefined; // todo: the goal is to reset jqui inline style, but not override user-defined inline style\r\n        }\r\n\r\n\r\n        return super.render(this.nodeType, styleOverride, classesOverride);\r\n        // return <RootVertex props={this.props} render={super.render()} super={this} key={this.props.nodeid+'.'+this.state?.forceupdate} />;\r\n    }\r\n\r\n    select(forUser?: Pointer<DUser>): void{\r\n        super.select(forUser);\r\n    }\r\n    componentDidMount(){\r\n        this.setVertexProperties();\r\n    }\r\n    componentDidUpdate(prevProps: Readonly<AllProps>, prevState: Readonly<ThisState>, snapshot?: any) {\r\n        this.setVertexProperties();\r\n    }\r\n}\r\n\r\n\r\nclass DispatchProps extends GraphElementDispatchProps {\r\n}\r\n\r\nexport type AllPropss = VertexOwnProps & VertexStateProps & DispatchProps;\r\n\r\nfunction mapStateToProps(state: DState, ownProps: VertexOwnProps): VertexStateProps {\r\n    let DGraphElementClass: typeof DGraphElement;\r\n    if (ownProps.isEdgePoint) DGraphElementClass = DEdgePoint; else\r\n    if (ownProps.isVertex && ownProps.isGraph) DGraphElementClass = DGraphVertex; else\r\n    if (ownProps.isVertex && !ownProps.isGraph) DGraphElementClass = DVertex; else\r\n    if (!ownProps.isVertex && ownProps.isGraph) DGraphElementClass = DGraph;\r\n    else DGraphElementClass = DGraphElement; // DField;\r\n\r\n    if (DGraphElementClass === DVertex && ownProps.isVoid) DGraphElementClass = DVoidVertex;\r\n    const superret: VertexStateProps = GraphElementComponent.mapStateToProps(state, ownProps, DGraphElementClass, VertexStateProps.new()) as VertexStateProps;\r\n    // superret.lastSelected = state._lastSelected?.modelElement;\r\n    // superret.lastSelected = state._lastSelected ? LPointerTargetable.from(state._lastSelected.modelElement) : null;\r\n\r\n    // change current to correct user ID when authentication is implemented.\r\n    // const selected = state.selected[DUser.current];\r\n    // uperret.selected = (selected) ? LGraphElement.fromPointer(selected) : null;\r\n    /*  Uncomment this when we have user authentication.\r\n    superret.selected = {};\r\n    for(let user of Object.keys(selected)) {\r\n        const pointer = selected[user];\r\n        if (pointer) superret.selected[user] = LModelElement.fromPointer(pointer);\r\n        else superret.selected[user] = null;\r\n    }\r\n    */\r\n\r\n    superret.isEdgePending = {\r\n        user: LPointerTargetable.from(state.isEdgePending.user),\r\n        source: LPointerTargetable.from(state.isEdgePending.source)\r\n    };\r\n    // superret.viewpoint = LViewPoint.fromPointer(state.viewpoint);\r\n    /*const ret: VertexStateProps = VertexStateProps.new();\r\n    U.objectMergeInPlace(superret, ret);*/\r\n    U.removeEmptyObjectKeys(superret);\r\n    return superret;\r\n}\r\n\r\nfunction mapDispatchToProps(dispatch: Dispatch<any>): DispatchProps {\r\n    const superret: GraphElementDispatchProps = GraphElementComponent.mapDispatchToProps(dispatch);\r\n    const ret: GraphElementDispatchProps = new GraphElementDispatchProps();\r\n    U.objectMergeInPlace(superret, ret);\r\n    U.removeEmptyObjectKeys(superret);\r\n    return superret;\r\n}\r\nexport const VertexConnected = connect<VertexStateProps, DispatchProps, VertexOwnProps, DState>(\r\n    mapStateToProps,\r\n    mapDispatchToProps\r\n)(VertexComponent as any);\r\n\r\nexport const Vertex = (props: VertexOwnProps, children: ReactNode | undefined = []): ReactElement => { //  children: (string | React.Component)[]\r\n    return <VertexConnected {...{...props, children}}\r\n        isGraph={false} isGraphVertex={false} isVertex={true} isEdgePoint={false} isField={false} isEdge={false} isVoid={false}/>;\r\n}\r\nexport const VoidVertex = (props: VertexOwnProps, children: ReactNode | undefined = []): ReactElement => {\r\n    return <VertexConnected {...{...props, children}}\r\n                            isGraph={false} isGraphVertex={false} isVertex={true} isEdgePoint={false} isField={false} isEdge={false} isVoid={true}/>;\r\n}\r\nexport const EdgePoint = function EdgePoint (props: VertexOwnProps, children: ReactNode | undefined = []): ReactElement {\r\n    return <VertexConnected {...{...props, children}}\r\n                            isGraph={false} isGraphVertex={false} isVertex={true} isEdgePoint={true} isField={false} isEdge={false} isVoid={false}/>;\r\n}\r\n// todo: name them all or verify the name is still usable.\r\n\r\nexport const Graph = (props: VertexOwnProps, children: ReactNode | undefined = []): ReactElement => {\r\n    return <VertexConnected {...{...props, children}}\r\n                            isGraph={true} isGraphVertex={false} isVertex={false} isEdgePoint={false} isField={false} isEdge={false} isVoid={false} />;\r\n}\r\n\r\nexport const GraphVertex = (props: VertexOwnProps, children: ReactNode | undefined = []): ReactElement => {\r\n    return <VertexConnected {...{...props, children}}\r\n                            isGraph={true} isGraphVertex={true} isVertex={true} isEdgePoint={false} isField={false} isEdge={false} isVoid={false}/>;\r\n}\r\n\r\nexport const Field = (props: VertexOwnProps, children: ReactNode | undefined = []): ReactElement => {\r\n    return <VertexConnected {...{...props, children}}\r\n                            isGraph={false} isGraphVertex={false} isVertex={false} isEdgePoint={false} isField={true} isEdge={false} isVoid={false} />;\r\n}\r\n(window as any).componentdebug = {Graph, GraphVertex, Field, Vertex, VoidVertex, EdgePoint, VertexConnected, VertexComponent};\r\n\r\n\r\nGraph.cname = 'Graph';\r\nGraphVertex.cname = 'GraphVertex';\r\nField.cname = 'Field';\r\nVertex.cname = 'Vertex';\r\nVoidVertex.cname = 'VoidVertex';\r\nEdgePoint.cname = 'EdgePoint';\r\n\r\n// GraphConnected.cname = 'GraphConnected';\r\n// GraphVertexConnected.cname = 'GraphVertexConnected';\r\n// FieldConnected.cname = 'FieldConnected';\r\nVertexConnected.cname = 'VertexConnected';\r\n// VoidVertexConnected.cname = 'VoidVertexConnected';\r\n// EdgePointConnected.cname = 'EdgePointConnected';\r\n\r\n// GraphComponent.cname = 'GraphComponent';\r\n// GraphVertexComponent.cname = 'GraphVertexComponent';\r\n// FieldComponent.cname = 'FieldComponent';\r\nVertexComponent.cname = 'VertexComponent';\r\n// VoidVertexComponent.cname = 'VoidVertexComponent';\r\n// EdgePointComponent.cname = 'EdgePointComponent';\r\n","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\graph\\damedges\\damedge.tsx",["962","963","964"],"import React, {Dispatch, ReactElement, ReactNode} from \"react\";\r\nimport {connect} from \"react-redux\";\r\nimport {\r\n    DEdge,\r\n    DGraph,\r\n    DGraphElement,\r\n    DGraphVertex, Dictionary,\r\n    DVoidVertex, EdgeBendingMode, GObject,\r\n    GraphElementComponent,\r\n    GraphElementDispatchProps,\r\n    GraphElementOwnProps,\r\n    GraphElementReduxStateProps,\r\n    GraphElementStatee, GraphPoint,\r\n    GraphSize,\r\n    DState,\r\n    LClass, LEdge, LGraphElement,\r\n    LModelElement,\r\n    LPointerTargetable,\r\n    LUser,\r\n    LVoidVertex, Overlap,\r\n    RuntimeAccessibleClass,\r\n    U,\r\n    EdgeOwnProps, EdgeStateProps,\r\n    LViewPoint, DModelElement, SetFieldAction, LVertex\r\n} from \"../../joiner\";\r\n\r\nlet groupingsize: Dictionary<EdgeBendingMode, number> = {} as any;\r\ngroupingsize[EdgeBendingMode.Line] = 1;\r\ngroupingsize[EdgeBendingMode.Bezier_quadratic] = 2;\r\ngroupingsize[EdgeBendingMode.Bezier_cubic] = 3;\r\n// groupingsize[EdgeBendingMode.Bezier_quadratic_mirrored] = 1;\r\n// groupingsize[EdgeBendingMode.Bezier_cubic_mirrored] = 2;\r\ngroupingsize[EdgeBendingMode.Elliptical_arc] = 2; // (1_coord), (rotation), (sweep    arc), (1_coord)\r\n\r\nconst superclassGraphElementComponent: typeof GraphElementComponent = RuntimeAccessibleClass.classes.GraphElementComponent as any as typeof GraphElementComponent;\r\nconst superclassGraphElementComponentuntyped: any = RuntimeAccessibleClass.classes.GraphElementComponent as any;\r\nclass ThisStatee extends GraphElementStatee {}\r\n\r\nexport class EdgeComponent<AllProps extends AllPropss = AllPropss, ThisState extends ThisStatee = ThisStatee>\r\n    extends superclassGraphElementComponent<AllProps, ThisState> {\r\n    public static cname: string = \"EdgeComponent\";\r\n    static defaultProps: Partial<EdgeOwnProps> = EdgeOwnProps.new();\r\n\r\n    constructor(props: AllProps, context: any) {\r\n        super(props, context);\r\n    }\r\n/*\r\n    path(): string {\r\n        let coords = this.pathCoords();\r\n        let svgletter: EdgeBendingMode = (this.props.view.bendingMode || \"L\");\r\n        let strings: string[] = coords.map(gp => gp.x+\" \" + gp.y);\r\n        return \"M\"+strings.join(\" \" + svgletter); }\r\n\r\n    pathCoords(): GraphPoint[] {\r\n        const ret = this.props;\r\n        let svgletter: EdgeBendingMode = (ret).view.bendingMode;\r\n        if (!ret.node) return []; // \"node missing\"\r\n        let coords: GraphPoint[] = (ret.node.midnodes as { x:number, y:number }[] as GraphPoint[]) || [];\r\n        let grouping = groupingsize[svgletter];\r\n        console.log(\"edgeee\", {coords, svgletter, groupingsize, midnodes:ret.node.midnodes, mnraw: ret.node.midnodes.map(mn=>mn.__raw), ret});\r\n        let scoord: GraphPoint = ret.node.startPoint || new GraphPoint(10, 10);\r\n        let ecoord: GraphPoint = ret.node.endPoint || new GraphPoint(100, 100);\r\n        return [scoord, ...coords, ecoord]; }\r\n\r\n    pathSegments(): GraphPoint[][]{\r\n        return U.pairArrayElements(this.pathCoords(), true); }\r\n*/\r\n    render(): ReactNode {\r\n        if (this.props.__skipRender) return null;\r\n        if (!this.props.node) return \"loading\";\r\n        // set classes\r\n        let nodeType = \"Edge\";\r\n        let classesoverride = [nodeType];\r\n        // set classes end\r\n        let styleoverride: React.CSSProperties = {}\r\n        return super.render(nodeType, styleoverride, classesoverride);\r\n    }\r\n\r\n}\r\n\r\n\r\n\r\nclass DispatchProps extends GraphElementDispatchProps {\r\n}\r\n\r\ntype AllPropss = Overlap<Overlap<EdgeOwnProps, EdgeStateProps>, DispatchProps>;\r\n\r\nfunction mapStateToProps(state: DState, ownProps: EdgeOwnProps): EdgeStateProps {\r\n    let ret: EdgeStateProps = EdgeStateProps.new();\r\n    if (!ownProps.data && !ownProps.start || !ownProps.end) return {__skipRender: true} as any;\r\n    if (!ownProps.data) {\r\n        let lstart = LPointerTargetable.from(ownProps.start);\r\n        if (RuntimeAccessibleClass.extends(lstart.className, DModelElement.cname)) ret.data = lstart as any;\r\n    }\r\n    ret = GraphElementComponent.mapStateToProps(state, ownProps, DEdge, ret) as EdgeStateProps;\r\n    // superret.lastSelected = state._lastSelected ? LPointerTargetable.from(state._lastSelected.modelElement) : null;\r\n    ret.isEdgePending = {\r\n        user: LPointerTargetable.from(state.isEdgePending.user),\r\n        source: LPointerTargetable.from(state.isEdgePending.source)\r\n    };\r\n    let l: GObject;\r\n\r\n    if (ownProps.start){ l = LPointerTargetable.from(ownProps.start); if (l) ret.start = l as LVertex; }\r\n    if (ownProps.end){ l = LPointerTargetable.from(ownProps.end); if (l) ret.end = l as LVertex; }\r\n\r\n    U.removeEmptyObjectKeys(ret);\r\n    if (!ret.start || !ret.end) return {__skipRender: true} as any;\r\n    return ret;\r\n}\r\n\r\nfunction mapDispatchToProps(dispatch: Dispatch<any>): DispatchProps {\r\n    const superret: GraphElementDispatchProps = GraphElementComponent.mapDispatchToProps(dispatch);\r\n    const ret: GraphElementDispatchProps = new GraphElementDispatchProps();\r\n    U.objectMergeInPlace(superret, ret);\r\n    U.removeEmptyObjectKeys(superret);\r\n    return superret;\r\n}\r\n\r\n\r\nexport const EdgeConnected = connect<EdgeStateProps, DispatchProps, EdgeOwnProps, DState>(\r\n    mapStateToProps,\r\n    mapDispatchToProps\r\n)(EdgeComponent as any);\r\n\r\nexport const Edge = (props: EdgeOwnProps, children: (string | React.Component)[] = []): ReactElement => {\r\n    return <EdgeConnected {...{...props, children}}\r\n                          isGraph={false} isGraphVertex={false} isVertex={false} isEdgePoint={false} isField={false} isEdge={true} isVoid={false} />;\r\n}\r\n\r\nEdgeComponent.cname = \"EdgeComponent\";\r\nEdgeConnected.cname = \"EdgeConnected\";\r\nEdge.cname = \"Edge\";\r\n","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\graph\\vertex\\Shapes.tsx",["965"],"import type { VertexOwnProps } from \"../graphElement/sharedTypes/sharedTypes\";\r\nimport React, {ReactElement, ReactNode} from \"react\";\r\nimport {GObject, Point, U} from \"../../joiner\";\r\nimport { Geom } from \"../../common/Geom\";\r\nimport {VertexConnected} from \"./Vertex\";\r\nimport {radian} from \"../../joiner/types\";\r\n\r\n\r\nfunction polygonSideLength(sides: number, radius: number = 1){\r\n    let rad = Math.PI/sides; // actual angle is twice, ut to do calculations i need half of it, to make it first a triangle slice out of a polygon, and then 2 right angle slices. this is the angle of 1 of the 2 right angle slices\r\n    return 2*(radius * Math.sin(rad)); }\r\n\r\nfunction makePolygon(sides: number, radius: number = 0.5, startingPoint?:Point, startingRad?: radian): Point[]{\r\n    let lastPt: Point = startingPoint || new Point(radius, 0);\r\n    let pts: Point[] = [lastPt];\r\n    let sideLength = polygonSideLength(sides, radius);\r\n    let rad0 = Math.PI/sides;\r\n    let currentRad: radian = startingRad !== undefined ? startingRad : rad0;\r\n    let sidesloop = sides;\r\n    while (sidesloop-- > 0) {\r\n        let nextPt = lastPt.move(currentRad, sideLength);\r\n        pts.push(nextPt);\r\n        lastPt = nextPt;\r\n        currentRad += rad0*2;\r\n    }\r\n    return pts;\r\n}\r\n\r\nfunction makeStar(sides: number, radius: number = 0.5, starRadius: number=0.25, niceBugVersion: boolean = true): Point[]{\r\n    console.log(\"make star\", {sides, starRadius});\r\n    let startRad;\r\n    let nextPtRad;\r\n    if (niceBugVersion && sides % 2 == 0) {\r\n        // nb: not fully correct, the correct \"bug\" version on even would be having an inner polygon identical to outer poly (not rotated)\r\n        // with points[0] = topmost point of the ex-circle for both odd polys. and then matching outer[i] with inner[i-1] points to make a line\r\n        startRad = Geom.degToRad(180/sides+90);\r\n        //nextPtRad = -startRad*2;\r\n        nextPtRad = -startRad*2*(sides-1);\r\n    } else {\r\n        startRad = -Geom.degToRad(-180/sides+90);\r\n        nextPtRad = (startRad - Geom.degToRad(90))*2;\r\n    }\r\n    let startPt: Point = new Point(0.5, 0.5).move(startRad, starRadius);\r\n    //startPt.y = 2*0.5 - startPt.y;\r\n    let poly = makePolygon(sides, radius);\r\n    let innerPoly = makePolygon(sides, starRadius, startPt, nextPtRad);\r\n    //innerPoly = [innerPoly[0], innerPoly[1]]\r\n    let ret: Point[] = []; // both go clockwise, but inner starts on opposide side\r\n    //return innerPoly;\r\n    for (let i = 0; i <= sides; i++) ret.push(poly[i], innerPoly[i]);\r\n    return ret.filter(r => !!r);\r\n}\r\n\r\nfunction makeAsterisk(sides: number, radius: number = 0.5, starRadius: number=0.25): Point[]{\r\n    console.log(\"make asterisk, todo\", {sides, starRadius});\r\n    return [];\r\n}\r\nfunction makeClipPath(pts:Point[]): string {\r\n    return 'polygon(' + pts.map(pt=> (pt.x*100 + '% ' + pt.y*100 + '%')).join(', ') + ')';\r\n}\r\n/*\r\nfunction makeSvg(pts: Point[]): string{\r\n    let val = 'M' + (pts.map(pt=> ('L' + pt.x*100 + ' ' + pt.y*100 + ' ')).join(', ')).substring(1) + '';\r\n    let html = document.querySelector('#p');\r\n    html.setAttribute('d', val);\r\n    html.style.display='block';\r\n    html = document.querySelector('#c'+0);\r\n    html.setAttribute(\"cx\", pts[0].x*100);\r\n    html.setAttribute(\"cy\", pts[0].y*100);\r\n\r\n    for (let i = 1; i < 20; i++) {\r\n        let v =  pts[i] ? \"M\" + pts[i-1].x*100 + ' ' + pts[i-1].y*100 + \" L\" + pts[i].x*100 + ' ' + pts[i].y*100 : \"\";\r\n        html = document.querySelector('#p'+i);\r\n        html.setAttribute('d', v);\r\n        html.style.display='block';\r\n        html.style.display='block';\r\n        html = document.querySelector('#c'+i);\r\n        if (!html) console.error(\"failed selector\", '#c'+i, {i, v, pts});\r\n        html.setAttribute(\"cx\", pts[i] ? pts[i].x*100 : -500);\r\n        html.setAttribute(\"cy\", pts[i] ? pts[i].y*100 : -500);\r\n    }\r\n    console.log(html);\r\n    return val;\r\n}*/\r\n\r\n\r\n\r\n\r\n\r\n// geom shortcuts\r\nfunction addStyle(props0: VertexOwnProps, children:any, childStyle: React.CSSProperties, style: React.CSSProperties = {}){\r\n    let props: GObject = {...props0, children, isGraph:false, isGraphVertex: false, isVertex:true, isEdgePoint: false, isField: false, isEdge: false, isVoid:true};\r\n    // props.style = !props0.style ? {} : {...props0.style};\r\n    props.childStyle = props.childStyle ? {...props.childStyle} : {};\r\n    props.style = props.style ? {...props.style} : {};\r\n    U.objectMergeInPlace(props.childStyle, childStyle, {\r\n        // custom fixed stuff\r\n    });\r\n    U.objectMergeInPlace(props.style, style, {\r\n        // custom fixed stuff\r\n        filter: 'drop-shadow(0px var(--border-width) 0px var(--border-color)) drop-shadow(var(--border-width) 0px 0px var(--border-color))' +\r\n            ' drop-shadow(calc( -1 * var(--border-width)) 0px 0px var(--border-color)) drop-shadow(0px calc( -1 * var(--border-width)) 0px var(--border-color))',\r\n    });\r\n    props.datastyle = JSON.stringify(props.style);\r\n    props.dataChildStyle = JSON.stringify(props.childStyle);\r\n    return props;}\r\n\r\nexport const Ellipse = (props: VertexOwnProps, children: ReactNode | undefined = []): ReactElement => {\r\n    return <VertexConnected {...addStyle(props, children, {borderRadius:'100%', // ellipse(50% 25% at 50% 50%)\r\n    })} />;}\r\nEllipse.cname = 'Ellipse';\r\n\r\nexport const Rectangle = (props: VertexOwnProps, children: ReactNode | undefined = []): ReactElement => { // default\r\n    return <VertexConnected {...addStyle(props, children, {})} />;}\r\nRectangle.cname = 'Rectangle (alias for default <Vertex />)';\r\n\r\nexport const Polygon = (props: VertexOwnProps, children: ReactNode | undefined = []): ReactElement => {\r\n    props = {...props};\r\n    if (!props.sides) props.sides = 6;\r\n    // if (!props.radius) props.radius = 0.5;\r\n    return <VertexConnected {...addStyle(props, children, {clipPath: makeClipPath(makePolygon(props.sides, 0.5))})} />;\r\n}\r\nPolygon.cname = 'N-Polygon';\r\n\r\nexport const Star = (props: VertexOwnProps, children: ReactNode | undefined = []): ReactElement => { // pointed lines, N endings (include 6-stars and more)\r\n    return props.decorated === false ? SimpleStar(props, children) : DecoratedStar(props, children);\r\n}\r\nStar.cname = 'N-Star';\r\nexport const DecoratedStar = (props: VertexOwnProps, children: ReactNode | undefined = []): ReactElement => {\r\n    props = {...props};\r\n    if (!props.sides) props.sides = 4;\r\n    // if (!props.radius) props.radius = 0.5;\r\n    if (!props.innerRadius) props.innerRadius = 0.25;\r\n    return <VertexConnected {...addStyle(props, children, {clipPath: makeClipPath(makeStar(props.sides, 0.5, props.innerRadius, true))})} />;\r\n}\r\nDecoratedStar.cname = 'N-DecoratedStar';\r\nexport const SimpleStar = (props: VertexOwnProps, children: ReactNode | undefined = []): ReactElement => {\r\n    props = {...props};\r\n    if (!props.sides) props.sides = 6;\r\n    // if (!props.radius) props.radius = 0.5;\r\n    if (!props.innerRadius) props.innerRadius = 0.25;\r\n    return <VertexConnected {...addStyle(props, children, {clipPath: makeClipPath(makeStar(props.sides, 0.5, props.innerRadius, false))})} />;\r\n}\r\nSimpleStar.cname = 'N-SimpleStar';\r\n\r\nexport const Cross = (props: VertexOwnProps, children: ReactNode | undefined = []): ReactElement => { // cut lines, N endings (includes asterisk)\r\n    return <div>N-Crosses (Asterisk-like) shapes yet to do</div>;\r\n}\r\nCross.cname = 'N-Cross';\r\n\r\nexport const Trapezoid = (props0: VertexOwnProps, children: ReactNode | undefined = []): ReactElement => { // cut lines, N endings (includes asterisk)\r\n    let props: VertexOwnProps & {ratio: number} = props0 as any;\r\n    if (!props0.ratio) props = {...props, ratio: 0.2 };\r\n    return <VertexConnected {...addStyle(props, children, {clipPath: 'polygon(' + props.ratio * 100 + '% 0%, ' + (1-props.ratio) * 100 + '% 0%, 100% 100%, 0% 100%)'})} />;}\r\nTrapezoid.cname = 'Trapezoid';\r\n\r\n\r\n//////////////// aliases (circle -> ellipse) ...\r\n\r\nexport const Circle = (props: VertexOwnProps, children: ReactNode | undefined = []): ReactElement => { // ellipse ellipse(50% 50% at 50% 50%)\r\n    return Ellipse(props, children); }\r\nCircle.cname = 'Ellipse/Circle';\r\n\r\n/*\r\nstep 1) put favoriteNode props on all GraphElememnt components except the most basic one like here,\r\nin a way that mirrirong components will have the mirror name instead of the implementation name (which is always GraphVertex)\r\n favoriteNode={props.favoriteNode || Square.cname}\r\nstep 2) when parsing jsx to build nodes, edges, check if props like edge.start or node.favoriteNode are different from the same prop in DVertex/DEdge/DView\r\nin that case, update such value\r\n*/\r\nexport const Square = (props: VertexOwnProps, children: ReactNode | undefined = []): ReactElement => { // rectangle\r\n    return <VertexConnected {...{...props, children}} isGraph={false} isVertex={true} isVoid={true} />; }\r\nSquare.cname = 'Rectangle/Square';\r\n/*\r\nexport const Rhombus = (props: VertexOwnProps, children: ReactNode | undefined = []): ReactElement => { // rectangle\r\n    return <VertexConnected {...{...props, children}} isGraph={false} isVertex={true} isVoid={true} rotate={props.rotate || 45} />; }\r\nRhombus.cname = 'Rectangle/Diamond';\r\n\r\nexport const Diamond = (props: VertexOwnProps, children: ReactNode | undefined = []): ReactElement => { return Rhombus(props, children); }\r\nDiamond.cname = 'Rectangle/Diamond';*/\r\n\r\n// polygon\r\nexport const Triangle = (props: VertexOwnProps, children: ReactNode | undefined = []): ReactElement => {\r\n    return <VertexConnected {...addStyle(props, children, {clipPath: 'polygon(50% 0%, 0% 100%, 100% 100%)'})} />;}\r\nTriangle.cname = 'Polygon/Triangle';\r\n\r\nexport const Pentagon = (props: VertexOwnProps, children: ReactNode | undefined = []): ReactElement => {\r\n    return <VertexConnected {...addStyle(props, children, {clipPath: 'polygon(50% 0%, 100% 38%, 82% 100%, 18% 100%, 0% 38%)'})} />;}\r\nPentagon.cname = 'Polygon/Pentagon';\r\n\r\nexport const Hexagon = (props: VertexOwnProps, children: ReactNode | undefined = []): ReactElement => {\r\n    return <VertexConnected {...addStyle(props, children, {clipPath: 'polygon(50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%)'})} />;}\r\nHexagon.cname = 'Polygon/Hexagon';\r\n\r\nexport const Heptagon = (props: VertexOwnProps, children: ReactNode | undefined = []): ReactElement => {\r\n    return <VertexConnected {...addStyle(props, children, {clipPath: 'polygon(50% 0%, 90% 20%, 100% 60%, 75% 100%, 25% 100%, 0% 60%, 10% 20%)'})} />;}\r\nHeptagon.cname = 'Polygon/Heptagon';\r\nexport const Septagon = (props: VertexOwnProps, children: ReactNode | undefined = []): ReactElement => {\r\n    return <VertexConnected {...addStyle(props, children, {clipPath: 'polygon(50% 0%, 90% 20%, 100% 60%, 75% 100%, 25% 100%, 0% 60%, 10% 20%)'})} />;}\r\nSeptagon.cname = 'Polygon/Heptagon';\r\n\r\nexport const Octagon = (props: VertexOwnProps, children: ReactNode | undefined = []): ReactElement => {\r\n    return <VertexConnected {...addStyle(props, children, {clipPath: 'polygon(30% 0%, 70% 0%, 100% 30%, 100% 70%, 70% 100%, 30% 100%, 0% 70%, 0% 30%)'})} />;}\r\nOctagon.cname = 'Polygon/Octagon';\r\n\r\nexport const Nonagon = (props: VertexOwnProps, children: ReactNode | undefined = []): ReactElement => {\r\n    return <VertexConnected {...addStyle(props, children, {clipPath: 'polygon(50% 0%, 83% 12%, 100% 43%, 94% 78%, 68% 100%, 32% 100%, 6% 78%, 0% 43%, 17% 12%)'})} />;}\r\nNonagon.cname = 'Polygon/Nonagon';\r\n\r\nexport const Enneagon = (props: VertexOwnProps, children: ReactNode | undefined = []): ReactElement => {\r\n    return <VertexConnected {...addStyle(props, children, {clipPath: 'polygon(50% 0%, 83% 12%, 100% 43%, 94% 78%, 68% 100%, 32% 100%, 6% 78%, 0% 43%, 17% 12%)'})} />;}\r\nEnneagon.cname = 'Polygon/Nonagon';\r\n\r\nexport const Decagon = (props: VertexOwnProps, children: ReactNode | undefined = []): ReactElement => {\r\n    return <VertexConnected {...addStyle(props, children, {clipPath: 'polygon(50% 0%, 80% 10%, 100% 35%, 100% 70%, 80% 90%, 50% 100%, 20% 90%, 0% 70%, 0% 35%, 20% 10%)'})} />;}\r\nDecagon.cname = 'Polygon/Decagon';\r\n\r\nexport const Asterisk = (props: VertexOwnProps, children: ReactNode | undefined = []): ReactElement => { // cut lines, N endings (includes asterisk)\r\n    return Star(props, children); }\r\nAsterisk.cname = 'Cross/Asterisk';\r\n","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\graph\\defaultNode\\DefaultNode.tsx",["966"],"import React, {ReactElement, ReactNode} from \"react\";\r\nimport {connect} from \"react-redux\";\r\nimport {\r\n    DClassifier,\r\n    DEnumerator,\r\n    Dictionary,\r\n    DModel,\r\n    DModelElement,\r\n    DPackage,\r\n    DV,\r\n    GObject,\r\n    GraphElementComponent,\r\n    GraphElementDispatchProps,\r\n    GraphElementOwnProps,\r\n    GraphElementReduxStateProps,\r\n    GraphElementStatee,\r\n    DState,\r\n    LModelElement,\r\n    Log,\r\n    LViewElement,\r\n    RuntimeAccessibleClass,\r\n    SetRootFieldAction,\r\n    windoww,\r\n    Field,\r\n    Graph,\r\n    GraphVertex,\r\n    Vertex,\r\n    VoidVertex,\r\n    RuntimeAccessible,\r\n    Polygon,\r\n    Circle,\r\n    Cross,\r\n    Decagon,\r\n    Asterisk,\r\n    Ellipse,\r\n    Enneagon,\r\n    Hexagon,\r\n    Nonagon,\r\n    Octagon,\r\n    Heptagon,\r\n    Pentagon,\r\n    Rectangle,\r\n    Septagon,\r\n    Square,\r\n    Star,\r\n    SimpleStar,\r\n    DecoratedStar,\r\n    Trapezoid,\r\n    Triangle,\r\n    Selectors,\r\n    LPointerTargetable,\r\n    Pointer,\r\n    DGraphElement,\r\n    DPointerTargetable, LGraphElement, transientProperties\r\n} from \"../../joiner\";\r\nimport { GraphElements } from \"../../joiner/components\";\r\n// import {Field, Graph, GraphVertex} from \"../vertex/Vertex\";\r\n\r\nconst superclass: typeof GraphElementComponent = RuntimeAccessibleClass.classes.GraphElementComponent as any as typeof GraphElementComponent;\r\n\r\n// private\r\nclass DefaultNodeStatee extends GraphElementStatee { }\r\n\r\n// from ownstateprops function getVertexID(props: AllPropss): Pointer<DVoidVertex, 0, 1, LVoidVertex> { return props.vertex?.id; }\r\n\r\n// Giordano: add ignore for webpack\r\n@RuntimeAccessible('DefaultNodeComponent')\r\n//@ts-ignore\r\nexport class DefaultNodeComponent<AllProps extends AllPropss = AllPropss, NodeState = DefaultNodeStatee> extends superclass<AllProps, NodeState>{\r\n    static defaultProps: Partial<DefaultNodeOwnProps> = {}; // cannot decide anything on this level, delegated to lower levels.\r\n\r\n    static mapStateToProps(state: DState, ownProps: GraphElementOwnProps): GraphElementReduxStateProps {\r\n        let ret: GraphElementReduxStateProps = {} as GraphElementReduxStateProps; // NB: cannot use a constructor, must be pojo\r\n        // GraphElementComponent.mapLModelStuff(state, ownProps, ret); // not necessary either?\r\n        // GraphElementComponent.mapLGraphElementStuff(state, ownProps, ret, dGraphDataClass); not necessary, it's demanded to sub-components\r\n/*        ret.data = LPointerTargetable.wrap(ownProps.data);\r\n        ret.node = undefined as any; // because DefaultNode is all about determining the correct node to create, so there is no node yet.\r\n        ret.nodeid = ownProps.nodeid as Pointer<DGraphElement>; // but nodeid exists, passed from the parent along graphid and parentview\r\n*/\r\n        // try{\r\n        ret.data = LPointerTargetable.wrap(ownProps.data);\r\n        ret.dataid = ownProps.data ? (typeof ownProps.data === \"string\" ? ownProps.data : ownProps.data.id) : undefined;\r\n        // if node does not exist yet it's fine, don't create it. let Vertex or Graph or Edge make it with appropriate constructor according fo first matching view on model.\r\n        // problem: what kind of node to make / initial view assign on shapeless objects? they have both data and node undefined at first render.\r\n        ret.node = LPointerTargetable.wrap(ownProps.nodeid) as LGraphElement;\r\n        if (ret.dataid) {\r\n            // set up transient model-> node map\r\n            if (!transientProperties.modelElement[ret.dataid]) transientProperties.modelElement[ret.dataid] = {nodes: {}} as any;\r\n            transientProperties.modelElement[ret.dataid].nodes[ownProps.nodeid as string] = ret.node;\r\n            transientProperties.modelElement[ret.dataid].node = ret.node;\r\n        }\r\n\r\n        GraphElementComponent.mapViewStuff(state, ret, ownProps);\r\n\r\n            // GraphElementComponent.mapViewStuff(state, ret, ownProps);\r\n            // (ret as any).skiparenderforloading = false;\r\n        //} catch(e) {\r\n            //(ret as any).skiparenderforloading = true; // model id is updated, but he's still trying to load old model which got replaced and is not in state.\r\n            /* crashes on loading because old model and new model have different timestamps? looks by id of old model with same number and diffferent timestamp*/\r\n            // Log.eDev(!ret.data, \"can't find model data:\", {state, ret, ownpropsdata:ownProps.data, ownProps});\r\n            // Log.eDevv(\"cannot map state to props:\", {e, state, ret, ownpropsdata:ownProps.data, ownProps});\r\n        //}\r\n        return ret; }\r\n\r\n    constructor(props: AllProps, context: any) { super(props, context); }\r\n\r\n    shouldComponentUpdate(nextProps: Readonly<AllProps>, nextState: Readonly<NodeState>, nextContext: any): boolean {\r\n        // i want to avoid double check on this and Vertex or graph.\r\n        // actually should not use this and avoid double mapstatetoprops execution too\r\n        return true;\r\n    }\r\n\r\n    render(): ReactNode {\r\n        if ((this.props as any).skiparenderforloading) {\r\n            windoww.bugged = this;\r\n            console.log(\"realoading render: \", {thiss:this, data:this.props.data});\r\n            SetRootFieldAction.new(\"rerenderforloading\", new Date().getTime()); return <div>loading...</div>;}\r\n        const view: LViewElement = this.props.view;\r\n        const modelElement: LModelElement | undefined = this.props.data;\r\n        if (!view) { Log.exx(\"cannot find view in DefaultNode\", {props: this.props, thiss:this}); }\r\n        // if (!view) { SetRootFieldAction.new(\"uselessrefresh_afterload\", new Date().getTime()); return <div>Loading...</div>; }\r\n\r\n        let componentMap: Dictionary<string, (props: GObject, children?: (string | React.Component)[]) => ReactElement> = windoww.components;\r\n        let dmodelMap: Dictionary<string, typeof DModelElement> = RuntimeAccessibleClass.classes as any;\r\n\r\n        let serializableProps = {...this.props};\r\n        // let serializableProps = {...this.props, data: this.props.data?.id, view: this.props.view?.id, views: this.props.views?.map( v => v.id )};\r\n\r\n        // console.log('dnode render', {props: {...this.props}, serializableProps});\r\n        let componentfunction: typeof Graph = null as any;\r\n        let forceNodeType = view.forceNodeType;\r\n        if (forceNodeType && forceNodeType !== \"Any\") {\r\n            componentfunction = GraphElements[forceNodeType] as any;\r\n            Log.exDev(!componentfunction, 'unrecognized View.forceNodeType:' + view.forceNodeType, {view, modelElement, nt: forceNodeType, GraphElements, });\r\n            // console.log(\"force node type\", {requested:view.forceNodeType, G:  windoww.GraphComponent.name, GE: windoww.GraphElementComponent.name, GV: windoww.GraphVertexComponent.name, V: windoww.VertexComponent.name, F:windoww.FieldComponent.name})\r\n            return componentfunction(serializableProps, this.props.children); }\r\n\r\n        if (modelElement?.className) switch(modelElement.className) {\r\n            case \"DModel\": componentfunction = Graph; break;\r\n            case \"DPackage\": componentfunction = GraphVertex; break;\r\n            case \"DClassifier\":\r\n            case \"DEnumerator\":\r\n            case \"DObject\":\r\n            case \"DClass\": componentfunction = Vertex; break;\r\n            case \"DAnnotation\":\r\n            case \"DAttribute\":\r\n            case \"DOperation\":\r\n            case \"DParameter\":\r\n            case \"DReference\":\r\n            case \"DEnumLiteral\":\r\n            case \"DValue\":\r\n            case \"DModelElement\": componentfunction = Field; break;\r\n            default:\r\n                Log.exDevv('invalid model class, add a case in the switch', {modelElement, view, dmodelMap, componentMap});\r\n                // const dmodel: typeof DModelElement = dmodelMap[modelElement.className];\r\n                // Log.exDev(!dmodel || !dmodel.defaultComponent, 'invalid model class:', {dmodel, modelElement, view, dmodelMap, componentMap});\r\n                // return dmodel.defaultComponent(serializableProps, this.props.children);\r\n        } else componentfunction = VoidVertex; // model-less, VoidVertex\r\n\r\n        if (componentfunction) return componentfunction(serializableProps, this.props.children);\r\n        // errore: questoon passa gli id correttamente al sottoelemento vertex o field\r\n        return DV.errorView(\"DefaultNode is missing both view and model, please state node type explicitly: Graph, GraphVertex, Vertex or Field\",\r\n            '', 'DefaultNode', modelElement?.__raw, this.props.node?.__raw, view);\r\n    }\r\n\r\n}\r\n\r\n// private\r\nclass DefaultNodeOwnProps extends GraphElementOwnProps {}\r\nclass DefaultNodeReduxStateProps  extends GraphElementReduxStateProps {}\r\nclass DefaultNodeDispatchProps extends GraphElementDispatchProps {}\r\ntype AllPropss = DefaultNodeOwnProps & DefaultNodeReduxStateProps & DefaultNodeDispatchProps;\r\n\r\n\r\nconst DefaultNodeConnected = connect<DefaultNodeReduxStateProps, DefaultNodeDispatchProps, DefaultNodeOwnProps, DState>(\r\n    DefaultNodeComponent.mapStateToProps,\r\n    DefaultNodeComponent.mapDispatchToProps\r\n)(DefaultNodeComponent as any);\r\n// export const Vertex = VertexConnected;\r\n\r\n\r\nexport const DefaultNode = (props: DefaultNodeOwnProps, children: (string | React.Component)[] = []): ReactElement => {\r\n    return <DefaultNodeConnected {...{...props, children}} />; }\r\n\r\n\r\nDefaultNodeComponent.cname = \"DefaultNodeComponent\";\r\nDefaultNodeConnected.cname = \"DefaultNodeConnected\";\r\nDefaultNode.cname = \"DefaultNode\";\r\n","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\graph\\graph\\graphContainer.tsx",["967"],"import React, {Dispatch, PureComponent, ReactElement, ReactNode} from \"react\";\r\nimport {connect} from \"react-redux\";\r\n// import './graph.scss';\r\nimport {DGraph, DModel, DPointerTargetable, DState, LGraph, LModel, LPointerTargetable} from \"../../joiner\";\r\n\r\n\r\n// private\r\ninterface ThisState { }\r\n\r\nexport class GraphsContainerComponent extends PureComponent<AllProps, ThisState>{\r\n    public static cname: string = \"GraphsContainerComponent\";\r\n    constructor(props: AllProps, context: any) {\r\n        super(props, context);\r\n    }\r\n\r\n    // todo: per ogni vista crea un set di opzioni {enableAutocorrect: \"boolean(true)\", displayEdges: \"boolean(true)\", maximumGraphWidth: \"number(2000)\"} specificate dall\\'utente che deve specificare sia il tipo (Come se osse una funzione) che il valore predefinito\r\n    // il grafo deve leggere l'oggetto di opzioni e creare un menù che consente di cambiarle (una checkbox al posto dell'enableAutocorrect (bool), uno spinner per maximumGraphWidth (number...)\r\n\r\n    render(): ReactNode {\r\n        // const editinput = \"<input onChange={(e) => this.data.name = e.target.value } value={this.data.name} />\";\r\n        // const editinput = \"\";\r\n        // todo: rendi opzionale obj = this.data.id se non è specificato.\r\n        // const editinput = \"<Input obj={this.data.id} field={'name'} getter={val => val.toUpperCase()} setter={(val) => val.toLowerCase()} />\";\r\n        // \"<Input obj={this.data} field={'name'} getter={val => val.toUpperCase()} setter={(val) => val.toLowerCase()} />\";\r\n        return (<>\r\n            {\r\n                this.props.graphs.map( (m: LGraph) => (\r\n                    <>\r\n                        {/*<svg style={{backgroundColor: 'red'}}>\r\n                        <Overlap style={{width: '100px'}}>\r\n                            success, now i can test resize handler overlayed to content and dragndrop dnd\r\n                            <foreignObject className={\"rectangle\"} />\r\n                            <foreignObject className={\"ellipse\"} />\r\n                            <foreignObject className={\"point\"} />\r\n                        </Overlap>\r\n                        </svg><svg style={{backgroundColor: 'red'}}>\r\n                            <Overlap>\r\n                                <foreignObject className={\"rectangle\"} style={{width: '100px'}}/>\r\n                                <foreignObject className={\"ellipse\"} style={{width: '300px'}}/>\r\n                                <foreignObject className={\"point\"} />\r\n                            </Overlap>\r\n                        </svg>* /}\r\n                        <GraphElement data={m} />*/}\r\n                        {/*\r\n                            Giordano comment this problem with model's children\r\n                            <Graph graphid={m.id} data={m.model} view={undefined}>\r\n                                <Vertex data={m.model}/>\r\n                            </Graph>\r\n\r\n                        */}\r\n                        {this.props.children/*<QA />*/}\r\n                    </>)\r\n                )\r\n            }\r\n        </>); }\r\n}\r\n\r\n// private\r\ninterface OwnProps {\r\n    // propsRequestedFromHtmlAsAttributes: string;\r\n}\r\n// private\r\ninterface StateProps {\r\n    models: LModel[];\r\n    graphs: LGraph[];\r\n    // propsFromReduxStateOrOtherKindOfStateManagement: boolean; // flux or custom things too, unrelated to this.state of react.\r\n}\r\n\r\n// private\r\ninterface DispatchProps {\r\n    // propsFromReduxActions: typeof funzioneTriggeraAzioneDaImportare;\r\n}\r\n\r\n\r\n// private\r\ntype AllProps = OwnProps & StateProps & DispatchProps;\r\n\r\n////// mapper func\r\n\r\nfunction mapStateToProps(state: DState, ownProps: OwnProps): StateProps {\r\n    const ret: StateProps = {} as any;\r\n    console.log('mapStateToProps', {ret, state, ownProps, models: state.models})\r\n    ret.models = state.models.length ? LPointerTargetable.fromArr(state.models, state) as LModel[] : [];\r\n    ret.graphs = state.graphs.length ? LGraph.fromArr(state.graphs, state) as LGraph[] : [];\r\n    /// to fill\r\n    return ret; }\r\n\r\nfunction mapDispatchToProps(dispatch: Dispatch<any>): DispatchProps {\r\n    const ret: DispatchProps = {} as any;\r\n    /// to fill\r\n    return ret; }\r\n\r\n\r\nconst GraphsContainerConnected = connect<StateProps, DispatchProps, OwnProps, DState>(\r\n    mapStateToProps,\r\n    mapDispatchToProps\r\n)(GraphsContainerComponent);\r\n\r\nexport const GraphsContainer = (props: OwnProps, children: (string | React.Component)[] = []): ReactElement => {\r\n    return <GraphsContainerConnected {...{...props, children}} />; }\r\n\r\n\r\nGraphsContainer.cname = \"GraphsContainer\";\r\nGraphsContainerConnected.cname = \"GraphsContainerConnected\";\r\nGraphsContainerComponent.cname = \"GraphsContainerComponent\";\r\n","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\logger\\DataOutput.tsx",["968"],"import React, {PureComponent, ReactNode} from \"react\";\r\nimport ReactJson from 'react-json-view' // npm i react-json-view\r\nimport './logger.scss'\r\nimport {GObject} from \"../../joiner\";\r\n\r\n// private\r\ninterface ThisState { }\r\n\r\nexport class DataOutputComponent extends PureComponent<AllProps, ThisState>{\r\n    static cname: string = \"DataOutputComponent\";\r\n\r\n    render(): ReactNode {\r\n        {/* themes:\r\n                                        export interface ThemeObject {\r\n                                            base00: string;\r\n                                            base01: string;\r\n                                            base02: string;\r\n                                            base03: string;\r\n                                            base04: string;\r\n                                            base05: string;\r\n                                            base06: string;\r\n                                            base07: string;\r\n                                            base08: string;\r\n                                            base09: string;\r\n                                            base0A: string;\r\n                                            base0B: string;\r\n                                            base0C: string;\r\n                                            base0D: string;\r\n                                            base0E: string;\r\n                                            base0F: string;\r\n                                        }\r\n\r\n                                            export type ThemeKeys =\r\n                                              | 'apathy'\r\n                                              | 'apathy:inverted'\r\n                                              | 'ashes'\r\n                                              | 'bespin'\r\n                                              | 'brewer'\r\n                                              | 'bright:inverted'\r\n                                              | 'bright'\r\n                                              | 'chalk'\r\n                                              | 'codeschool'\r\n                                              | 'colors'\r\n                                              | 'eighties'\r\n                                              | 'embers'\r\n                                              | 'flat'\r\n                                              | 'google'\r\n                                              | 'grayscale'\r\n                                              | 'grayscale:inverted'\r\n                                              | 'greenscreen'\r\n                                              | 'harmonic'\r\n                                              | 'hopscotch'\r\n                                              | 'isotope'\r\n                                              | 'marrakesh'\r\n                                              | 'mocha'\r\n                                              | 'monokai'\r\n                                              | 'ocean'\r\n                                              | 'paraiso'\r\n                                              | 'pop'\r\n                                              | 'railscasts'\r\n                                              | 'rjv-default'\r\n                                              | 'shapeshifter'\r\n                                              | 'shapeshifter:inverted'\r\n                                              | 'solarized'\r\n                                              | 'summerfruit'\r\n                                              | 'summerfruit:inverted'\r\n                                              | 'threezerotwofour'\r\n                                              | 'tomorrow'\r\n                                              | 'tube'\r\n                                              | 'twilight'; */}\r\n        return <ReactJson src={this.props.data}\r\n                          collapsed={1}\r\n                          collapseStringsAfterLength={20}\r\n                          displayDataTypes={true}\r\n                          displayObjectSize={true}\r\n                          enableClipboard={true}\r\n                          groupArraysAfterLength={100}\r\n                          indentWidth={4}\r\n                          iconStyle={\"triangle\"}\r\n                          name={this.props.rootName}\r\n                          quotesOnKeys={true} shouldCollapse={ false /*((field: CollapsedFieldProps) => { return Object.keys(field.src).length > 3;*/ }\r\n                          sortKeys={false}\r\n                          theme={\"rjv-default\"}\r\n        >{this.props.children}</ReactJson>;\r\n    };\r\n\r\n}\r\n\r\n// private\r\ninterface OwnProps {\r\n    data: GObject;\r\n    rootName?: string;\r\n}\r\n// private\r\ntype AllProps = OwnProps;\r\n/*\r\nif (!windoww.mycomponents) windoww.mycomponents = {};\r\nwindoww.mycomponents.DataOutput = DataOutputComponent;\r\nwindoww.mycomponents.DataOutputComponent = DataOutputComponent;*/\r\n////// mapper func\r\n\r\n","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\logger\\loggerComponent.tsx",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\api\\persistance\\index.ts",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\forEndUser\\SizeInput.tsx",["969"],"import React, {Dispatch, PureComponent, ReactNode} from \"react\";\r\nimport { connect } from \"react-redux\";\r\nimport toast from \"react-hot-toast\";\r\nimport type {GObject, Pointer, Info} from \"../../joiner\";\r\nimport {\r\n    DPointerTargetable,\r\n    DState,\r\n    GenericInput,\r\n    Log,\r\n    LPointerTargetable,\r\n    Input,\r\n    ISize,\r\n    SetFieldAction\r\n} from \"../../joiner\";\r\nexport let useless=1;\r\n\r\n// private\r\ninterface ThisState {\r\n}\r\n\r\nclass SizeInputComponent extends PureComponent<AllProps, ThisState>{\r\n    static cname: string;\r\n\r\n    constructor(props: AllProps, context: any) {\r\n        super(props, context);\r\n    }\r\n\r\n    render(): ReactNode {\r\n        let l: LPointerTargetable = this.props.data;\r\n        let ll: GObject = l;\r\n        let field: keyof LPointerTargetable = this.props.field as any;\r\n        let otherProps: GObject = {...this.props};\r\n        delete otherProps.xgetter;\r\n        delete otherProps.xsetter;\r\n        delete otherProps.ygetter;\r\n        delete otherProps.ysetter;\r\n        delete otherProps.wgetter;\r\n        delete otherProps.wsetter;\r\n        delete otherProps.hgetter;\r\n        delete otherProps.hsetter;\r\n        delete otherProps.data;\r\n        delete otherProps.field;\r\n        delete otherProps.label;\r\n        delete otherProps.tooltip;\r\n        delete otherProps.key;\r\n\r\n        let tooltip: JSX.Element;\r\n        if (this.props.tooltip === true) { tooltip = (ll[\"__info_of__\" + field])?.txt || ''; }\r\n        else { tooltip = (this.props.tooltip || '') as any; }\r\n\r\n        const notify = () => toast((t: GObject) => (\r\n            <div onClick={() => toast.dismiss(t.id)}>\r\n                <label className={'ms-1'}>{tooltip}</label>\r\n            </div>\r\n        ));\r\n\r\n\r\n        let size: Partial<ISize> = (l[field] || {}) as GObject;\r\n        console.log('sizeinput debug', {l, field, size})\r\n\r\n        const inputStyle = {justifyContent: \"right\", width: \"auto\", marginRight:\"5px\"};\r\n        let labelStyle = {height: '100%', display: 'inline-block', marginRight:\"5px\"}\r\n        return (<>\r\n            <label className={this.props.rootClassName} style={{fontFamily:'Inter Tight', ...(this.props.rootStyle||{})}}>\r\n                {(this.props.label) && <label className={'my-auto'} style={{fontFamily:'-webkit-body'}} onClick={() => { if (tooltip) notify() }}>\r\n                    {this.props.label}\r\n                </label>}\r\n                <label className={\"d-flex my-auto ms-auto\"} style={{flexWrap: \"wrap\"}}>\r\n                    {\"x\" in size && <Input {...otherProps} className={\"\"} data={l} label={<span style={labelStyle}>x</span>} field={field} type={\"number\"}\r\n                        getter={(ll)=>(l[field] as any as ISize).x+''}\r\n                        setter={(val)=>{\r\n                            // SetFieldAction.new(l.id, field as string, {x: +val}, '+=', false)\r\n                            (l[field] as any as Partial<ISize>) = {x: +val}; // {y:? x: +val, w:?, h:?}}\r\n                    }}\r\n                        inputStyle={inputStyle}\r\n                    />}\r\n                    {\"y\" in size && <Input {...otherProps} className={\"\"} data={l} label={<span style={labelStyle}>y</span>} field={field} type={\"number\"}\r\n                       getter={(ll)=>(l[field] as any as ISize).y+''}\r\n                       setter={(val)=>{(l[field] as any as Partial<ISize>) = {y: +val}}}\r\n                       inputStyle={inputStyle}\r\n                    />}\r\n                    {\"w\" in size && <Input {...otherProps} className={\"\"} data={l} label={<span style={labelStyle}>w</span>} field={field} type={\"number\"}\r\n                        getter={(ll)=>(l[field] as any as ISize).w+''}\r\n                        setter={(val)=>{(l[field] as any as Partial<ISize>) = {w: +val}}}\r\n                        inputStyle={inputStyle}\r\n                    />}\r\n                    {\"h\" in size && <Input {...otherProps} className={\"\"} data={l} label={<span style={labelStyle}>h</span>} field={field} type={\"number\"}\r\n                       getter={(ll)=>(l[field] as any as ISize).h+''}\r\n                       setter={(val)=>{(l[field] as any as Partial<ISize>) = {h: +val}}}\r\n                       inputStyle={inputStyle}\r\n                    />}\r\n                </label>\r\n            </label>\r\n        </>); }\r\n}\r\n\r\n// private\r\ninterface OwnProps {\r\n    data: LPointerTargetable;\r\n    field: string;\r\n    xgetter?: (data: LPointerTargetable) => string;\r\n    xsetter?: (value: string|boolean) => void;\r\n    ygetter?: (data: LPointerTargetable) => string;\r\n    ysetter?: (value: string|boolean) => void;\r\n    wgetter?: (data: LPointerTargetable) => string;\r\n    wsetter?: (value: string|boolean) => void;\r\n    hgetter?: (data: LPointerTargetable) => string;\r\n    hsetter?: (value: string|boolean) => void;\r\n    label?: ReactNode;\r\n    tooltip?: ReactNode | true; // if true picks it up from __info_of__\r\n    readonly?: boolean;\r\n    key?: React.Key | null;\r\n    className?: string;\r\n    rootClassName?: string;\r\n    inputClassName?: string;\r\n    rootStyle?: GObject;// this goes to root\r\n    style?: GObject; // this goes at the root of <Input> or <Select> element(s)\r\n    inputStyle?: GObject; // this goes to the actual native <input> or <select> element(s)\r\n}\r\n\r\n// private\r\ninterface StateProps {\r\n    // propsFromReduxStateOrOtherKindOfStateManagement: boolean; // flux or custom things too, unrelated to this.state of react.\r\n}\r\n\r\n// private\r\ninterface DispatchProps {\r\n    // propsFromReduxActions: typeof funzioneTriggeraAzioneDaImportare;\r\n}\r\n\r\n\r\n// private\r\ntype AllProps = OwnProps & StateProps & DispatchProps;\r\n\r\n////// mapper func\r\n\r\nfunction mapStateToProps(state: DState, ownProps: OwnProps): StateProps {\r\n    const ret: StateProps = {} as any;\r\n    /// to fill\r\n    return ret; }\r\n\r\nfunction mapDispatchToProps(dispatch: Dispatch<any>): DispatchProps {\r\n    const ret: DispatchProps = {} as any;\r\n    /// to fill\r\n    return ret; }\r\n\r\n\r\nexport const SizeInput = connect<StateProps, DispatchProps, OwnProps, DState>(\r\n    mapStateToProps,\r\n    mapDispatchToProps\r\n)(SizeInputComponent);\r\n\r\n\r\nSizeInputComponent.cname = \"SizeInputComponent\";\r\nSizeInput.cname = \"SizeInput\";\r\n","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\pages\\components\\cards\\Cards.tsx",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\pages\\components\\menu\\Menu.tsx",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\pages\\components\\catalog\\Catalog.tsx",["970","971","972","973","974","975","976","977","978","979","980"],"import React, {useState} from \"react\";\r\nimport { LProject } from \"../../../joiner\";\r\nimport { Menu, Item } from \"../menu/Menu\";\r\nimport { Project } from \"../Project\";\r\n\r\nimport colors from '../../../static/img/colors.png';\r\nimport { icon } from \"../icons/Icons\";\r\nimport \"./catalog.scss\"\r\nimport _ from \"lodash\";\r\n\r\nexport const CatalogInfoCard = (props: any) => {\r\n    return (\r\n        <div className={'details'}>\r\n            {props.projects ?\r\n                <>\r\n                    <h5>Your projects</h5>\r\n                    <p>You developed <strong>{props.projects.length}</strong> projects{false && ' with an overall number of 12 artifacts'}.</p>\r\n                    <img src={colors} width={220} />\r\n                </>\r\n                :\r\n                <>\r\n                    <h5>No projects so far. Are you new to Jjodel? why not exploring the Getting Started section?</h5>\r\n                    <img src={colors} width={220} />\r\n                </>\r\n            }\r\n        </div>\r\n    );\r\n}\r\ntype ChildrenType = {\r\n    projects?: any;\r\n    children?: any;\r\n};\r\n\r\nconst Catalog = (props: ChildrenType) => {\r\n\r\n    const [filters, setFilters] = useState([true,true,true]);\r\n    const [mode, setMode] = useState<string>(\"cards\");\r\n\r\n    const [sortingMode, setSortingMode] = useState<string>(\"alphabetical\");\r\n\r\n    const Header = (props: ChildrenType) => {\r\n        return (\r\n            <div className='row catalog-header' style={{maxWidth: '1250px'}}>\r\n                {props.children}\r\n            </div>\r\n        );\r\n    }\r\n\r\n    const CatalogFilters = () => {\r\n\r\n        function toggleFilters(el: 0|1|2) {\r\n            switch(el) {\r\n                case 0:\r\n                    setFilters([!filters[0], filters[1], filters[2]]);\r\n                    break;\r\n                case 1:\r\n                    setFilters([filters[0], !filters[1], filters[2]]);\r\n                    break;\r\n                case 2:\r\n                    setFilters([filters[0], filters[1], !filters[2]]);\r\n                    break;\r\n            }\r\n        };\r\n\r\n        return (\r\n            <div className={'left'}>\r\n                {filters[0] ? <button onClick={(e) => toggleFilters(0)} className='active'>public</button> : <button onClick={(e) => toggleFilters(0)}>public</button>}\r\n                {filters[1] ? <button onClick={(e) => toggleFilters(1)} className='active'>private</button> : <button onClick={(e) => toggleFilters(1)}>private</button>}\r\n                {filters[2] ? <button onClick={(e) => toggleFilters(2)} className='active'>collaborative</button> : <button onClick={(e) => toggleFilters(2)} >collaborative</button>}\r\n            </div>\r\n        );\r\n    }\r\n\r\n    const CatalogMode = () => {\r\n        return (<>\r\n            <div className={'right'}>\r\n                <span>sorted by <span style={{paddingLeft: '6px'}}>{icon[sortingMode]} </span></span>\r\n                <Menu position={'left'}>\r\n                    <Item icon={icon['alphabetical']} action={(e)=> {setSortingMode('alphabetical')}}>Alphabetical {sortingMode === 'alphabetical' && <i style={{float: 'right'}} className=\"bi bi-check-lg\"></i>}</Item>\r\n                    <Item icon={icon['created']} action={(e)=> {setSortingMode('created')}}>Date created {sortingMode === 'created' && <i style={{float: 'right'}} className=\"bi bi-check-lg\"></i>}</Item>\r\n                    <Item icon={icon['modified']} action={(e)=> {setSortingMode('modified')}}>Last modified {sortingMode === 'modified' && <i style={{float: 'right'}} className=\"bi bi-check-lg\"></i>}</Item>\r\n                </Menu>\r\n                <div className={'view-icons'}>\r\n                    <i onClick={(e) => setMode('cards')} className={`bi bi-grid ${mode === \"cards\" && 'selected'}`}></i>\r\n                    <i onClick={(e) => setMode('list')} className={`bi bi-list ${mode === \"list\" && 'selected'}`}></i>\r\n                </div>\r\n            </div>\r\n        </>);\r\n    }\r\n\r\n    const CatalogSide = (props: ChildrenType) => {\r\n        return (\r\n            <div className={'catalog'}>\r\n                {props.children}\r\n            </div>\r\n        );\r\n    }\r\n\r\n\r\n\r\n    type CatalogType = {\r\n        projects: LProject[];\r\n    }\r\n\r\n    const CatalogReport = (props: CatalogType) => {\r\n\r\n\r\n        var items = props.projects\r\n            .filter(p =>\r\n                (filters[0] && p.type ===\"public\" || filters[1] && p.type ===\"private\" || filters[2] && p.type ===\"collaborative\" || !filters[0] && !filters[1] && !filters[2]));\r\n        \r\n        var sorted = items;\r\n        var iteratees: ((obj: LProject) => any) | string = 'created';\r\n\r\n        switch(sortingMode) {\r\n            case \"alphabetical\":\r\n                sorted = _.sortBy(items, 'name');\r\n                break;\r\n            case \"created\":\r\n                iteratees = (obj: LProject) => -new Date(obj.creation).getTime();\r\n                sorted = _.sortBy(items, iteratees);\r\n                break;\r\n            case \"modified\":\r\n                iteratees = (obj: LProject) => -new Date(obj.lastModified).getTime();\r\n                sorted = _.sortBy(items, iteratees);\r\n                break;\r\n        }\r\n\r\n        return (\r\n\r\n            mode == \"cards\" ?\r\n\r\n                /* cards mode */\r\n\r\n                <div className={'card-holder'}>\r\n\r\n                    {items.length === 0 && <div className={\"fallback-message\"}><span>\r\n                        Sorry, there are no results matching your search criteria. Please try again with different filters.\r\n                    </span></div>}\r\n\r\n                    {\r\n                        sorted.map((p,i) => <Project key={i} data={p} mode={mode} />)\r\n                    }\r\n\r\n                </div>\r\n\r\n            :\r\n                /* list mode */\r\n\r\n                <div className={'row project-list'}>\r\n                    <div className='row header'>\r\n                        <div className={'col-4'}>Name</div>\r\n                        <div className={'col-1'}>Type</div>\r\n                        <div className={'col-3'}>Created</div>\r\n                        <div className={'col-2'}>Last modified</div>\r\n                        <div className={'col-2'}>Operation</div>\r\n                    </div>\r\n                    {\r\n                        sorted.map(p => <>\r\n                            {filters[0] && p.type === \"public\" && <Project key={p.id} data={p} mode={mode} />}\r\n                            {filters[1] && p.type === \"private\" && <Project key={p.id} data={p} mode={mode} />}\r\n                            {filters[2] && p.type === \"collaborative\" && <Project key={p.id} data={p} mode={mode} />}\r\n                            {!filters[0] && !filters[1] && !filters[2] && <Project key={p.id} data={p} mode={mode} />}\r\n                        </>)\r\n                    }\r\n                </div>\r\n\r\n        );\r\n    };\r\n\r\n    return (\r\n        <>\r\n            <Header>\r\n                <CatalogFilters />\r\n                <CatalogMode />\r\n            </Header>\r\n            <CatalogSide>\r\n                <CatalogInfoCard projects={props.projects}/>\r\n                <CatalogReport projects={props.projects}/>\r\n            </CatalogSide>\r\n        </>\r\n    );\r\n}\r\n\r\nexport {Catalog}\r\n","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\abstract\\DockManager.ts",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\pages\\components\\about\\About.tsx",["981","982"],"import { useState } from \"react\";\r\nimport logo from '../../../static/img/logo-on.png';\r\nimport manatee from '../../../static/img/manatee.png';\r\nimport React from \"react\";\r\nimport ReactDOM from \"react-dom\";\r\n\r\nlet windoww = window as any;\r\n\r\ntype Props = {\r\n    type?: 'inline'|'menu';\r\n    ver: string;\r\n    name: string;\r\n    value?: boolean;\r\n};\r\n\r\nconst message: string = \"Manatees are large, fully aquatic, mostly herbivorous marine mammals sometimes known as sea cows.The main causes of death for manatees are human-related issues. As usual, we are the most dangerous animal on earth.\";\r\n\r\n\r\nclass AboutModal {\r\n  \r\n    static open() {\r\n        if (!document) return;\r\n\r\n        const aboutElement = document.createElement('div');\r\n        ReactDOM.render(React.createElement(About, { ver: '1.0', name: 'Jjodel', type: 'menu', value: true }), aboutElement);\r\n        document.body.append(aboutElement);\r\n    }\r\n}\r\n\r\nconst About = (props: Props) => {\r\n\r\n    const [open, setOpen] = useState<boolean>(props.value ? props.value : false);\r\n\r\n    const {type, ver, name} = props;\r\n\r\n    const AboutRaw = (props: Props) => {\r\n        return(\r\n            <>\r\n                <div className='modal-container'></div>\r\n                <div className='modal'>\r\n                    <div><img src={logo} /></div>\r\n                    <div>v{props.ver} {props.name}</div>\r\n                    <div>\r\n                        {message}\r\n                    </div>\r\n                    <div><img src={manatee} /></div>\r\n                    \r\n                    <button className={'close'} onClick={() => setOpen(!open)}>close</button>\r\n                </div>\r\n            </>\r\n        );\r\n    }\r\n\r\n    return (\r\n        <>\r\n            {props.type !== 'menu' && <span className={'about'} onClick={(e) => setOpen(!open)}>Jjodel v{props.ver} <i className=\"bi bi-globe-americas\"></i> {props.name}</span>}\r\n            {open  && <AboutRaw ver={ver} name={name} />}\r\n        </>\r\n\r\n    );\r\n};\r\n\r\n\r\nexport {About, AboutModal};\r\n","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\topbar\\undoredocomponent.tsx",["983","984","985"],"import React, {Dispatch, PureComponent, ReactNode} from 'react';\r\nimport {\r\n    Dictionary, DUser,\r\n    GObject, DState,\r\n    Log, U, RedoAction,\r\n    statehistory,\r\n    UndoAction, store, DPointerTargetable, Pointer, LProject, UserHistory,\r\n} from '../../joiner';\r\nimport {connect} from \"react-redux\";\r\nimport \"./undoredo.scss\"\r\nimport {icon} from \"../../pages/components/icons/Icons\";\r\nimport {COMMIT} from \"../../redux/action/action\";\r\n\r\ninterface SaveManagerProps {}\r\n\r\nclass UndoRedoState{\r\n    hover: boolean = false;\r\n    jsx: any | null;\r\n    constructor(jsx: any) {  this.jsx = jsx; }\r\n}\r\n\r\n// private\r\ninterface ThisState {\r\n    undo: UndoRedoState;\r\n    redo: UndoRedoState;\r\n    user: Pointer<DUser>|'all';\r\n}\r\n\r\n// private\r\ninterface OwnProps {\r\n    // propsRequestedFromHtmlAsAttributes: string;\r\n    project: LProject;\r\n}\r\n// private\r\ninterface StateProps {\r\n    // propsFromReduxStateOrOtherKindOfStateManagement: boolean; // flux or custom things too, unrelated to this.state of react.\r\n    maxlistsize: number;\r\n    maxDetailSize: number;\r\n    //undo: GObject<\"delta\">[],\r\n    // redo: GObject<\"delta\">[],\r\n    debug: boolean\r\n}\r\n\r\n// private\r\ninterface DispatchProps {\r\n    // propsFromReduxActions: typeof funzioneTriggeraAzioneDaImportare;\r\n}\r\n\r\ntype R = {\r\n    str: string,\r\n    fullstr: string,\r\n    path:string[],\r\n    fullpath:string[],\r\n    fullpath_str?:string, // fullpath.join('.') only saved temporarly in render phase\r\n    val: string,\r\n    fullvalue: string,\r\n    pathlength?: number\r\n};\r\n\r\n// private\r\ntype AllProps = OwnProps & StateProps & DispatchProps;\r\nexport class SaveManagerComponent extends PureComponent<AllProps, ThisState>{\r\n    public static cname: string = \"SaveManagerComponent\";\r\n    private undoredolistoutdated: boolean;\r\n    do_undo = (index: number) => {\r\n        UndoAction.new(index+1, this.state.user, false).commit();\r\n        this.undoenter(); // updates list\r\n    }\r\n    do_redo = (index: number) => {\r\n        console.log(\"redo(\" + index + \")\");\r\n        RedoAction.new(index+1, this.state.user, false).commit();\r\n        this.redoenter();\r\n    }\r\n    printablePointer(pathsegment: string, state: DState){\r\n        let obj = DPointerTargetable.from(pathsegment, state) as GObject;\r\n        if (!obj) return pathsegment;\r\n        if (obj.name) return \"$\"+obj.name;\r\n        if (obj.className) return \"#\"+obj.className;\r\n        return pathsegment;\r\n    }\r\n\r\n    // redo list is updated only when the user mouse-enters it. for efficiency.\r\n    undoredoenter2 = (key: \"undo\"|\"redo\" = \"undo\") => {\r\n        let history = this.get_history(this.state.user);\r\n        let undoarr = history.undoable;\r\n        let redoarr = history.redoable;\r\n        // console.log(\"statemanager undo update\", {thiss:this, undoarr, redoarr, user: this.state.user, props: this.props, state:this.state});\r\n        if (!this.undoredolistoutdated) return;\r\n        let s: DState = store.getState();\r\n        let arr = [...(key === 'undo' ? undoarr : redoarr)].reverse().slice(0, this.props.maxlistsize);\r\n        let out: {best: R, obj: GObject}&R[] = [] as any;\r\n        let strings = arr.map( delta => U.ObjectToAssignementStrings(delta, 10, 6, 20, \"…\", out, true));\r\n        //todo: make it just for current index, then get the next val from index+1 or current state, using R.path and replacing just the value. on mouseover switch it val of the delta vs next val\r\n            let list = arr.map((delta, index) => {})\r\n\r\n    }\r\n\r\n    improveText(e: R, s: DState) {\r\n        if (e.fullstr.includes(\"Pointer\")) {\r\n            let editedfullpath = e.fullpath.map( (pathsegment) => {\r\n                //  console.log(\"undoredo replace attempt\", {pathsegment, idlookup:s.idlookup, dobj:s.idlookup[pathsegment], replacement: this.printablePointer(pathsegment, s)});\r\n                return this.printablePointer(pathsegment, s); });\r\n            e.str = editedfullpath.join(\".\") + \" = \" + e.val;\r\n            console.log(\"undoredo replace attempt\", {editedfullpath, beststr:e.str, best: e});\r\n        }\r\n        if (e.path[0] === \"idlookup\") e.str = \"\" + e.str.substring(\"idlookup.\".length);\r\n        if (e.fullvalue.includes(\"Pointer\")) {\r\n            e.val = this.printablePointer(e.fullvalue.substring(1, e.fullvalue.length-1), s); // 1, -1 because string values have quotes \"\"\r\n            e.str = e.str.substring(0, e.str.lastIndexOf(\"=\")) + \"= \" + e.val;\r\n        }\r\n    }\r\n    undoredoenter = (key: \"undo\"|\"redo\" = \"undo??\" as any) => {\r\n        let debug = this.props.debug;\r\n        let history = this.get_history(this.state.user);\r\n        let undoarr = history.undoable;\r\n        let redoarr = history.redoable;\r\n        // console.log(\"statemanager undo update\", {thiss:this, undoarr, redoarr, user: this.state.user, props: this.props, state:this.state});\r\n        if (!this.undoredolistoutdated) return;\r\n        let s: DState = store.getState();\r\n        // let arr = [...(this.props as GObject)[key]].reverse().slice(0, this.props.maxlistsize);\r\n        let fullarr = [...(key === 'undo' ? undoarr : redoarr)].reverse()\r\n        let arr = fullarr.slice(0, this.props.maxlistsize);\r\n\r\n        function getLatestDelta(i: number, searchPath: string[], direction: -1 | 1 = 1): GObject {\r\n            outer: for (; i < fullarr.length+1 && i >= -1; i+=direction) {\r\n                let rootdelta = fullarr[i] || s;\r\n                let currDelta = rootdelta;\r\n                for (let pathSeg of searchPath){\r\n                    if (!(pathSeg in currDelta)) continue outer;\r\n                    else currDelta = currDelta[pathSeg];\r\n                }\r\n                return rootdelta;\r\n            }\r\n            return s;\r\n        }\r\n        let list = arr.map((delta, index) => {\r\n            let out: {best: R, obj: GObject}&R[] = [] as GObject as any;\r\n            let out_otherdelta: {best: R, obj: GObject}&R[] = [] as any;\r\n            let titleindex = index + (key === 'undo' ? -1 : 0);\r\n            let titleDelta = arr[titleindex]\r\n            let otherDelta = arr[index + 1]; //[index + (key === 'undo' ? -1 : +1)]\r\n            // let actiodesc = key ==='undo' ? arr[index + 1] : ) || s;\r\n\r\n            let excludedPaths: Dictionary<string, boolean> = {'action.title': true, 'action.description': true};\r\n            let filterrow = (e:R)=> {\r\n                //console.log('filterrow', {debug, e});\r\n                return debug || !excludedPaths[key] && !e.fullpath.includes(\"clonedCounter\")\r\n                    && !e.fullpath.includes(\"timestamp\")\r\n                    && !e.fullpath.includes(\"timestampdiff\")\r\n                    && !e.fullpath.includes(\"pointedBy\")\r\n                    && !e.fullpath.includes(\"pointedBy\")\r\n                    && !e.fullpath.includes('__jjObjDiffIsArr');\r\n            }\r\n            U.ObjectToAssignementStrings(delta, 10, 6, 20, \"…\", out, true, filterrow);\r\n            if (otherDelta) U.ObjectToAssignementStrings(otherDelta, 10, 6, 20, \"…\", out_otherdelta, true, filterrow);\r\n            // if (!index) console.log('debug undoredo', {out, delta, arr});\r\n            // if out.best is undef, then get most recent titles until you find a delta with a title or the current(state)\r\n            let latestTitleDelta = getLatestDelta(titleindex, ['action_title'], (key === 'undo' ? -1 : +1));\r\n            let debugTitle = (titleDelta||s).action_title;\r\n            // console.log('getLatestDelta', {delta, latestTitleDelta, best:out.best?.str, titleDelta, dt:(titleDelta||s).action_title, titleindex, out})\r\n            if (!out.best?.str) {\r\n                console.error('generated wrong delta??', {out, best:out?.best});\r\n                return <><div>errored</div></>;\r\n            }\r\n            if (latestTitleDelta.action_title) out.best.str = latestTitleDelta.action_title;\r\n            if (latestTitleDelta.action_description) out.best.fullstr = latestTitleDelta.action_description;\r\n            else out.best.fullstr = out.length + ' subchanges';\r\n            if (latestTitleDelta.action_title !== debugTitle) out.best.str = '* ' + out.best.str;\r\n            if ((otherDelta)?.action_title) out_otherdelta.best.str = (otherDelta||s).action_title;\r\n            if ((otherDelta)?.action_description) out_otherdelta.best.fullstr = (otherDelta||s).action_description;\r\n            out.best.str = U.cropStr(out.best.str, 1, 0, 13, 12);\r\n            out.best.fullstr = U.cropStr(out.best.fullstr, 1, 0, 250, 250);\r\n            //out_otherdelta.best.str = U.cropStr(out_otherdelta.best.str, 1, 0, 13, 12);\r\n            //out_otherdelta.best.fullstr = U.cropStr(out_otherdelta.best.fullstr, 1, 0, 250, 250);\r\n            //this.improveText(out.best, s);\r\n            let other = out.slice(0, this.props.maxDetailSize); //.map(e=>this.improveText(e));\r\n            let other2 = out_otherdelta.slice(0, this.props.maxDetailSize); //.map(e=>this.improveText(e));\r\n\r\n            let newstyle: boolean = true as any;\r\n\r\n            let entry = (): JSX.Element => {\r\n                return (\r\n                    <li onClick={() => ((this as GObject)[\"do_\" + key](index))} className=\"hoverable\" key={index} tabIndex={0}>\r\n                        <label className=\"highlight undefined\">\r\n                            <span><i className=\"bi bi-app hidden\"/> i</span>\r\n                        </label>\r\n                    </li>)\r\n            }\r\n            // if (newstyle) return entry();\r\n\r\n\r\n            for (let e of other2){ e.fullpath_str = e.fullpath.join(\".\")}\r\n            for (let e of other){ e.fullpath_str = e.fullpath.join(\".\")}\r\n            return <li onClick={() => ((this as GObject)[\"do_\" + key](index))} className=\"\" key={index}\r\n                       tabIndex={0}\r\n                       style={{/*overflow: \"visible\", height: \"24px\"*/}}>\r\n                <label className=\"highlight undefined hoverable\">\r\n                    <div className={\"my-auto preview\"}>{out.best.str}</div>\r\n                    <div className={\"my-auto content inline\"}>{out.best.fullstr}</div>\r\n                    <div className={\"content right detail-list\"}>\r\n                        <ul className=\"context-menu right\">{\r\n                            other.map((row, ii) => {\r\n                                let row2 = other2.filter(e=>e.fullpath_str === row.fullpath_str)[0];//other2[ii];\r\n                                return <li className={'detail-entry hoverable'} onClick={(e=> {\r\n                                    e.stopPropagation()\r\n                                })}>\r\n                                    <label className={`highlight disabled hoverable`}>\r\n                                    <span\r\n                                        className='preview inline'>{row.fullpath_str + \" = \" + row.fullvalue}</span>\r\n                                        <span className='content inline'>{row2 && (row2.fullpath_str + \" = \" + row2.fullvalue)}</span>\r\n                                    </label>\r\n                                </li>\r\n                            })}\r\n                            {out.length !== other.length ? <div className={'detail-entry'}>...</div> : null}\r\n                        </ul>\r\n                    </div>\r\n                </label>\r\n            </li>\r\n        });\r\n        let jsx =\r\n            <>{list}</>;\r\n        let obj: GObject = {};\r\n        obj[key] = {...(this.state as GObject)[key], hover: true, jsx};\r\n        // {undo: {...this.state.undo, hover: true, jsx}}\r\n        this.undoredolistoutdated = false;\r\n        this.setState(obj as ThisState);\r\n    }\r\n\r\n    undoenter = ()=>{ return this.undoredoenter(\"undo\"); }\r\n    redoenter = ()=>{ return this.undoredoenter(\"redo\"); }\r\n    undoleave = ()=>{ this.setState({undo: {...this.state.undo, hover: false}}); }\r\n    redoleave = ()=>{ this.setState({redo: {...this.state.redo, hover: false}}); }\r\n\r\n    constructor(props: AllProps, context: any) {\r\n        super(props, context);\r\n        let undo = new UndoRedoState(<div>undo list example</div>);\r\n        let redo = new UndoRedoState(<div>redo list example</div>);\r\n        this.state = {undo, redo, user: DUser.current};\r\n        this.undoredolistoutdated = true;\r\n        // this.setState({undo, redo});\r\n    }\r\n    get_history(user: Pointer<DUser> | 'all'): {redoable: GObject[], undoable: GObject[]}{\r\n        // let ret = {redoable: [] as GObject[], undoable: [] as GObject[]};\r\n        return statehistory[user];\r\n    }\r\n    erase_history(user: Pointer<DUser> | 'all', project: LProject){\r\n        if (user === 'all'){/*\r\n            for (let user of project.collaborators){\r\n                this.erase_history(user.id, project);\r\n            }\r\n            this.erase_history(DUser.current, project);*/\r\n            for (let user in statehistory){\r\n                statehistory[user].undoable = [];\r\n                statehistory[user].redoable = [];\r\n            }\r\n        } else {\r\n            statehistory[user].undoable = [];\r\n            statehistory[user].redoable = [];\r\n        }\r\n    }\r\n    render(): ReactNode {\r\n        let user = this.state.user;\r\n        this.undoredolistoutdated = true; // if render is called it means redux state props he's watching (redux-state) changed, so the preview list in component-state is outdated.\r\n        // console.log(\"undoredomanager\", {thiss:this, undo:this.props.undo, props: this.props, state:this.state});\r\n        let history: UserHistory = this.get_history(user);\r\n        let undo: GObject<\"delta\">[] = history?.undoable || [];\r\n        let redo: GObject<\"delta\">[] = history?.redoable || [];\r\n\r\n        let contextmenustyle =(undoStr: 'Undo'|'Redo', undoarr: GObject<\"delta\">[]): JSX.Element => {\r\n            let undostr = undoStr.toLowerCase() as 'undo'|'redo';\r\n            let isUndo = undoarr === undo;\r\n            return (\r\n            <li className={\"undoredo hoverable \" +(!undoarr.length?'disabled':'')} tabIndex={0}\r\n                onMouseEnter={isUndo?this.undoenter:this.redoenter}\r\n                onMouseLeave={isUndo?this.undoleave:this.redoleave}>\r\n\r\n                <label className=\"highlight undefined\" onClick={(e) => {\r\n                    isUndo ? this.do_undo(0) : this.do_redo(0)\r\n                }}>\r\n                    <span>{icon[undoStr.toLowerCase()]} <span>{undoStr + ' ' + ((undoarr).length || '')}</span></span>\r\n                    {<div className=\"keystrokes\">\r\n                        <i className=\"text-icon ctrl\" title=\"Control\" data-val=\"ctrl\" data-content=\"Control\"/>\r\n                        <span>{isUndo ? 'Z' : 'Y'}</span>\r\n                    </div>}\r\n                    {undoarr.length ? <i className=\"bi bi-chevron-right icon-expand-submenu\"/> : null}\r\n                </label>\r\n                <div className=\"content right\">\r\n                    {undoarr.length ? <ul className=\"context-menu right\">{this.state[undoStr.toLowerCase() as 'undo'|'redo'].jsx}</ul> : null}\r\n                </div>\r\n            </li>)\r\n        }\r\n\r\n        let testnew: boolean = true as any;\r\n        if (testnew) return <>\r\n            {contextmenustyle('Undo', undo)}\r\n            {contextmenustyle('Redo', redo)}\r\n        </>\r\n\r\n        return (<>\r\n            <div className='undoredo' key={'undo'}>\r\n                <span className={\"hoverable\"} style={{position: \"relative\", background: \"white\"}}\r\n                      onMouseEnter={this.undoenter} onMouseLeave={this.undoleave}>\r\n                    <button className={'item border round ms-1'} onClick={(e) => {\r\n                        this.do_undo(0)\r\n                    }}>Undo ({undo.length})</button>\r\n                    {undo.length ?\r\n                        <ul style={{background: \"inherit\", width: \"max-content\", zIndex:10000}} className={\"content\"}>\r\n                            {this.state.undo.jsx}\r\n                        </ul>\r\n                        : null}\r\n                </span>\r\n                <span className={\"hoverable\"} style={{position: \"relative\", background: \"white\"}} onMouseEnter={this.redoenter} onMouseLeave={this.redoleave}>\r\n                    <button className={'item border round ms-1'} onClick={(e)=> { this.do_redo(0) }}>Redo ({redo.length})</button>\r\n                    { redo.length ? <ul style={{background: \"inherit\", width: \"max-content\", zIndex:10000}} className={\"content\"}>{this.state.redo.jsx}</ul> : null}\r\n                </span>\r\n                <button onClick={()=>{this.erase_history(user, this.props.project)}}>x</button>\r\n            </div>\r\n        </>);\r\n    }\r\n}\r\n\r\n\r\nfunction mapStateToProps(state: DState, ownProps: OwnProps): StateProps {\r\n    const ret: StateProps = {} as any;\r\n    //ret.undo = statehistory[DUser.current].undoable;\r\n    //ret.redo = statehistory[DUser.current].redoable;\r\n    ret.maxlistsize = 20;\r\n    ret.maxDetailSize = 30;\r\n    ret.debug = state.debug;\r\n    return ret; }\r\n\r\nfunction mapDispatchToProps(dispatch: Dispatch<any>): DispatchProps {\r\n    const ret: DispatchProps = {} as any;\r\n    /// to fill\r\n    return ret; }\r\n\r\nexport const SaveManagerConnected = connect<StateProps, DispatchProps, OwnProps, DState>(\r\n    mapStateToProps,\r\n    mapDispatchToProps\r\n)(SaveManagerComponent);\r\n\r\nexport default SaveManagerConnected;\r\nexport const Undoredocomponent = SaveManagerConnected;","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\api\\persistance\\admin.ts",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\abstract\\tabs\\TabDataMaker.tsx",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\editors\\languages\\index.ts",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\api\\persistance\\projects.ts",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\api\\persistance\\users.ts",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\api\\persistance\\auth.ts",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\topbar\\SaveManager.ts",["986"],"import {\r\n    Dictionary,\r\n    DUser,\r\n    EcoreParser,\r\n    GObject,\r\n    DState,\r\n    Json,\r\n    LModel,\r\n    LoadAction,\r\n    Log,\r\n    U,\r\n    LPointerTargetable,\r\n    prjson2xml,\r\n    prxml2json,\r\n    store,\r\n    RuntimeAccessible,\r\n    DModelElement,\r\n    SetRootFieldAction,\r\n    Selectors,\r\n    Debug,\r\n    DViewElement,\r\n    transientProperties,\r\n    LUser\r\n} from '../../joiner';\r\nimport {ProjectsApi} from \"../../api/persistance\";\r\nimport {VersionFixer} from \"../../redux/VersionFixer\";\r\n\r\n@RuntimeAccessible('SaveManager')\r\nexport class SaveManager {\r\n    private static tmpsave: DState;\r\n\r\n    static save(): void {\r\n        let project = LUser.fromPointer(DUser.current)?.project;\r\n        if (project) ProjectsApi.save(project);\r\n        U.isProjectModified = false;\r\n        /*SaveManager.tmpsave = store.getState();\r\n        localStorage.setItem(\"tmpsave\", JSON.stringify(SaveManager.tmpsave));\r\n        console.clear();\r\n        console.log(JSON.stringify(SaveManager.tmpsave))*/\r\n    }\r\n\r\n    static load(state0?: string | GObject<DState>): void {\r\n        if (!state0 && SaveManager.tmpsave) { LoadAction.new(SaveManager.tmpsave); return; }\r\n        state0 = state0 || localStorage.getItem('tmpsave') || 'null'; // priorities: 1) argument from file 2) state variable cached 3) localstorage 4) null prevent crash\r\n        let save: GObject<DState> = SaveManager.tmpsave = typeof state0 === 'string' ? JSON.parse(state0) : state0;\r\n        for (let vid of [...save.viewelements, ...save.viewpoints]) {\r\n            for (let key of DViewElement.RecompileKeys) {\r\n                if(!transientProperties.view[vid]) transientProperties.view[vid] = {name: (save.idlookup[vid] as any)?.name || 'Unnamed'} as any;\r\n                key = 'VIEWS_RECOMPILE_' + key;\r\n                if (!save[key]) save[key] = [];\r\n                save[key].push(vid);\r\n            }\r\n        }\r\n        VersionFixer.update(save);\r\n        LoadAction.new(save);\r\n    }\r\n\r\n    public static exportEcore_click(toXML: boolean = false, toFile: boolean = true): void { // e: React.MouseEvent,\r\n        let lmodel: null|LModel = Selectors.getActiveModel();\r\n        if (!lmodel) return;\r\n        let json = SaveManager.exportEcore(lmodel);\r\n        let str = JSON.stringify(json, null, \"\\t\");\r\n        if (toXML) {\r\n            str = prjson2xml.json2xml(json, '\\t');\r\n            str = U.formatXml(str);\r\n        }\r\n\r\n        if (!toFile) {\r\n            // (document.querySelector(\"#export-tmp\") as any).innerText = str;\r\n            localStorage.setItem(\"import\", str);\r\n            return;\r\n        }\r\n        let ism2 = (lmodel as LModel).isMetamodel;\r\n        let name = (lmodel.name || (ism2 ? 'M2' : 'M1') + '_unnamed')  + (toXML ? \".xml\" : '.json') + \".\"+ (ism2 ? \"ecore\" : lmodel.instanceof?.name || \"shapeless\");\r\n        console.log(\"download file:\", {name, ism2, toXML, lmodel, instanceof:lmodel.instanceof});\r\n        U.download(name, str);\r\n    }\r\n\r\n    public static importEcore_click(fromXML: boolean = false, fromfile: boolean = true): void {\r\n        try { this.importEcore_click0(fromXML, fromfile); } catch (e: any) {\r\n            let str = e?.message?.substring?.(0, 1000) || 'some error';\r\n            console.trace(str, e);\r\n            // throw new Error(str);\r\n        }\r\n    }\r\n    public static importEcore_click0(fromXML: boolean = false, fromfile: boolean = true): void {\r\n        const extensions: string[] = [(fromXML ? \"*.xml.*\" : \"*.json.*\")]; // [\".ecore\"]; // Selectors.getActiveModel().isM1() ? '.' + Selectors.getActiveModel().metamodel.fullname() : '.ecore';\r\n        let filestring: string, jsonstring: string, jsonobj: GObject = undefined as any;\r\n        console.log(\"importEcore: prefromfile\");\r\n        if (!fromfile) {\r\n            filestring = localStorage.getItem(\"import\") || 'null';\r\n            if (fromXML) {\r\n                const xmlDoc = new DOMParser().parseFromString(filestring,\"text/xml\");\r\n                jsonobj = prxml2json.xml2jsonobj(xmlDoc, ' ');\r\n            }\r\n            //if (filestring.includes(\"\\n\")) throw new Error(filestring.substring(0, 1000));\r\n            SaveManager.importEcore(jsonobj || filestring, true, undefined, true); // todo: trova il modo di determinare se è m1 o m2 senza filename\r\n            return; }\r\n\r\n        console.log(\"importEcore: pre file read\", {fromXML, fromfile});\r\n        let filename;\r\n        U.fileRead((e: Event, files?: FileList | null, fileContents?: string[]) => {\r\n            Log.ex(!fileContents || !files || fileContents.length !== files.length, 'Failed to get file contents:', files, fileContents);\r\n            Log.ex(!!fileContents && fileContents.length > 1, 'Should not be possible to input multiple files yet.');\r\n            if (!fileContents) return;\r\n            if (fileContents.length == 0) return;\r\n            // @ts-ignore\r\n            filename = e.target.files?.[0].name;\r\n            console.log(\"file read\", {e, fileContents, files, filename});\r\n            filestring = fileContents[0];\r\n\r\n            // if file is over 500kb, lightmode on\r\n            if (filestring.length >= 500*1024 && !Debug.lightMode) {\r\n                Debug.setLightMode(true);\r\n                // $(document).one(\"click\", (e) => { Debug.setLightMode(false); });\r\n            }\r\n\r\n            console.log('importEcore filestring input: ', filestring);\r\n            if (fromXML) {\r\n                let windoww = window as any;\r\n                windoww.file = filestring;\r\n                windoww.todoc = (str: any) => new DOMParser().parseFromString(str,\"text/xml\");\r\n                windoww.doctojson = (doc: any) => prxml2json.xml2jsonobj(doc, ' ');\r\n                // problemi doctojson or xmi parser: \\n replacemet causa crash per stringa in posizione invalida. \\\" anche per attributi inline che iniiano con \\\\\"\r\n                // filestring = U.multiReplaceAll(filestring, [\"\\t\", \"\\r\", \"\\n\", '&amp;', '&#38;', '&quot;', '&', '\\'', '\"'], [\"\\\\t\", \"\\\\r\", \"\\\\n\", '\\\\&', \"\\\\'\", '\\\\\"', '\\\\&', \"\\\\'\", '\\\\\"']);//,  \"\\\\t\"), \"\\r\", \"\\\\r\"), \"\\n\", \"\\\\n\");\r\n\r\n                const xmlDoc = new DOMParser().parseFromString(filestring,\"text/xml\");\r\n                console.log('importEcore xml:', xmlDoc);\r\n                let jsonstring0 = '';\r\n                jsonobj = prxml2json.xml2jsonobj(xmlDoc, ' ');//doto: non devo wrappare con \\\" i nomi di chiavi o valori ma solo i contenuti\r\n                /*jsonstring = jsonstring0;\r\n                //jsonstring = U.multiReplaceAll(jsonstring0, [\"\\t\", \"\\r\", \"\\n\", '&amp;', '&#38;', '&quot;', '&', '\\'', '\"'], [\"\\\\t\", \"\\\\r\", \"\\\\n\", '\\\\&', \"\\\\'\", '\\\\\"', '\\\\&', \"\\\\'\", '\\\\\"']);//,  \"\\\\t\"), \"\\r\", \"\\\\r\"), \"\\n\", \"\\\\n\");\r\n                *///jsonstring = jsonstring.replaceAll(/(\\{|\\,)\\\\n\\s*/gm, \"\")\r\n                /*if (jsonstring.includes(\"\\n\")) throw new Error(jsonstring0.substring(0, 1000)+\"\\n\\n\\n\\n\" + jsonstring.substring(0, 1000));\r\n                */\r\n                // jsonstring = JSON.stringify(jsonobj);\r\n                if (jsonobj.parsererror) { Log.ee(\"failed to parse XML->JSON\", {parseError:jsonobj.parseerror, jsonobj});  return; }\r\n                console.log('importEcore jsonstr input: ', jsonobj);\r\n            }\r\n            else jsonstring = filestring;\r\n            let isMetamodel = filename.indexOf(\".ecore\") === filename.length - \".ecore\".length;\r\n            console.log(\"ismetamodel\", {filename, isMetamodel});\r\n            let end = SaveManager.importEcore(jsonobj || jsonstring || 'null', isMetamodel, filename, true);\r\n        }, extensions, true);\r\n    }\r\n\r\n    public static exportEcore(model: LModel): Json {\r\n        let loopobj = {};\r\n        try { return model.generateEcoreJson(loopobj); }\r\n        catch(e) { Log.exx(\"possible loop in model:\\t\\n\" + (e as Error).message, {loopobj, e}); }\r\n        return {\"error\": true, loopobj};\r\n    }\r\n    public static importEcore(jsonstr: GObject | string | null, isMetamodel: boolean, filename: string | undefined, persist: boolean = true): DModelElement[] {\r\n        return EcoreParser.parse(jsonstr, isMetamodel, filename, persist);\r\n    }\r\n\r\n    static exportLayout_click(toFile: boolean) {\r\n        let lmodel: LModel = (LPointerTargetable.wrap(store.getState().models[0]) as LModel);\r\n        // lmodel.node?.allSubNodes\r\n\r\n    }\r\n    static importLayout_click(fromFile: boolean) {\r\n\r\n    }\r\n}\r\n\r\n","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\abstract\\Dock.tsx",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\hooks\\useQuery.ts",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\pages\\components\\popups\\index.ts",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\commandbar\\CommandBar.tsx",["987","988"],"import React, {MouseEventHandler, ClassAttributes, useState, useRef, useEffect, ReactElement, ReactNode} from \"react\";\r\nimport './commandbar.scss';\r\nimport { inherits } from \"util\";\r\nimport { Tooltip } from \"../forEndUser/Tooltip\";\r\nimport { U } from \"../../joiner\";\r\n\r\ntype BtnProps = {\r\n    disabled?: boolean;\r\n    active?: boolean;\r\n    icon: \"up\"\r\n        | \"down\"\r\n        | \"back\"\r\n        | \"fwd\"\r\n        | \"add\"\r\n        | \"add2\"\r\n        | \"delete\"\r\n        | \"delete2\"\r\n        | \"open\"\r\n        | \"edit\"\r\n        | \"favorite\"\r\n        | \"shrink\"\r\n        | \"expand\"\r\n        | \"space\"\r\n        | \"minispace\"\r\n        | \"sep\"\r\n        | \"check\"\r\n        | \"copy\"\r\n        | \"close\"\r\n        | \"info\"\r\n        | \"show\"\r\n        | \"open-down\"\r\n        | \"close-up\"\r\n        | \"settings\"\r\n        | \"download\";\r\n\r\n    tip?: string | ReactNode;\r\n    label?: string;\r\n    theme?: \"dark\" | \"light\",\r\n    action?: MouseEventHandler,\r\n    size?: \"x-small\" | \"small\" | \"medium\" | \"large\",\r\n    style?: React.CSSProperties,\r\n    mode?: 'normal' | 'negative'\r\n    className?: string;\r\n    needConfirm?:boolean;\r\n}\r\n\r\n\r\nexport const Btn = (props: BtnProps) => {\r\n\r\n    const [askingConfirm, setConfirm] = useState(false);\r\n    const mode = (props.mode ? props.mode : 'normal');\r\n    let needConfirm = props.needConfirm || props.icon === 'delete' && !props.disabled;\r\n    let i_classes = (props.className||'') + ` bi tab-btn commandbar-btn ${askingConfirm ? 'bi-question-square-fill question': props.icon} ${props.theme ? props.theme : 'light'} ${props.size||''} ${mode} ${props.disabled ? 'disabled ' : ''}`\r\n    let action = (e: React.MouseEvent<any,any>) => {\r\n        console.log('commandbar action', {disabled: props.disabled, action:props.action, askingConfirm, needConfirm});\r\n        if (props.disabled || !props.action) return;\r\n        if (!askingConfirm && needConfirm) {\r\n            setConfirm(true);\r\n            U.clickedOutside(e, ()=> {\r\n                console.log('clicked outside remove confirm');\r\n                setConfirm(false)\r\n            });\r\n            return;\r\n        }\r\n        props.action(e);\r\n        e.stopPropagation();\r\n    }\r\n    let icon: ReactNode = null;\r\n\r\n    switch (props.icon){\r\n        case 'delete2':\r\n            icon = <div className={`delete2 ${props.theme ? props.theme : 'light'}`}>Delete</div>; break;\r\n\r\n        case 'delete':\r\n            icon = <Tooltip tooltip={askingConfirm ? 'Are you sure?' : props.tip} inline={true} position={'top'} offsetY={10} >\r\n                <i onClick={action} style={props.style} className={i_classes} />\r\n            </Tooltip>; break;\r\n\r\n        default:\r\n            icon = <Tooltip tooltip={props.tip} inline={true} position={'top'} offsetY={10}>\r\n                <i className={i_classes} onClick={action} style={props.style}/>\r\n            </Tooltip>; break;\r\n    }\r\n\r\n    if (props.icon === \"space\" || props.icon === \"minispace\") return <span style={{display: 'block', width: `${props.icon === 'space' ? '24px' : '4px'}`}} />;\r\n    return <div className={'btn-component '+(props.active ? 'active' : '')}>{icon}</div>;\r\n}\r\n\r\n\r\n\r\nexport const Sep = (style?: any) => {\r\n\r\n    return (<>\r\n            {style ?\r\n                <div>\r\n                    <div className={'tab-btn sep'}></div>\r\n                </div>\r\n            :\r\n                <div>\r\n                    <div className={'tab-btn sep'} style={style}></div>\r\n                </div>\r\n            }\r\n\r\n    </>);\r\n}\r\n\r\n\r\ntype CommandProps = {\r\n    children: any,\r\n    style?: React.CSSProperties,\r\n    className?: string,\r\n    noBorder?: boolean;\r\n}\r\n\r\nexport const CommandBar = (props: CommandProps) => {\r\n\r\n    let style = props.style;\r\n\r\n    let noBorder = (props.noBorder ? props.noBorder: false);\r\n\r\n    return(<>\r\n        {props.style ?\r\n            <div className={`command-bar ${props.className && props.className} ${noBorder && 'no-border'}`} style={props.style}>\r\n                {props.children}\r\n            </div>\r\n            :\r\n            <div className={`command-bar ${props.className && props.className} ${noBorder && 'no-border'}`} >\r\n                {props.children}\r\n            </div>\r\n        }\r\n\r\n    </>);\r\n};\r\n","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\pages\\components\\icons\\Icons.tsx",["989","990"],"import './icons.scss';\r\n\r\nimport jj from '../../../static/img/jj-k.png';\r\nimport { Tooltip } from '../../../components/forEndUser/Tooltip';\r\nimport { Logo, MetamodelIcon, ModelIcon } from '../../../components/logo';\r\n\r\nimport { LuPackage2 } from \"react-icons/lu\";\r\nimport { CgToolbarTop as Toolbar } from \"react-icons/cg\";\r\n\r\nexport let icon: { [name: string]: any} = {\r\n    'new': <i className=\"bi bi-plus-circle-dotted menuitem\"></i>,\r\n    close: <i className=\"bi bi-x-lg menuitem\"></i>,\r\n    edit: <i className=\"bi bi-pencil-square menuitem\"></i>,\r\n    duplicate: <i className=\"bi bi-files menuitem\"></i>,\r\n    copy: <i className=\"bi bi-files menuitem\"></i>,\r\n    undo: <i className=\"bi bi-arrow-counterclockwise menuitem\"></i>,\r\n    redo: <i className=\"bi bi-arrow-clockwise menuitem\"></i>,\r\n    save: <i className=\"bi bi-floppy menuitem\"></i>,\r\n    select: <i className=\"bi bi-check menuitem\"></i>,\r\n    deselect: <i className=\"bi bi-check2 menuitem\"></i>,\r\n    add: <i className=\"bi bi-plus-circle-dotted menuitem\"></i>,\r\n    validation: <i className=\"bi bi-check2-circle menuitem\"></i>,\r\n    validate: <i className=\"bi bi-clipboard-check menuitem\"></i>,\r\n    faq: <i className=\"bi bi-chat-left-dots menuitem\"></i>,\r\n    'user-guide': <i className=\"bi bi-journal-text menuitem\"></i>,\r\n    glossary: <i className=\"bi bi-book menuitem\"></i>,\r\n\r\n    'import': <i className=\"bi bi-cloud-upload menuitem\"></i>,\r\n    'export': <i className=\"bi bi-arrow-bar-right menuitem\"></i>,\r\n    download: <i className=\"bi bi-cloud-download menuitem\"></i>,\r\n\r\n    favorite: <i className=\"bi bi-star menuitem\"></i>,\r\n    favoriteFill: <i className=\"bi bi-star-fill menuitem\"></i>,\r\n    share: <i className=\"bi bi-share menuitem\"></i>,\r\n    delete: <i className=\"bi bi-trash3 menuitem\"></i>,\r\n    'delete-confirm': <i className=\"bi bi-question-square-fill menuitem confirm\"></i>,\r\n    refresh: <i className=\"bi bi-arrow-clockwise menuitem\"></i>,\r\n    up: <i className=\"bi bi-arrow-up menuitem\"></i>,\r\n    down: <i className=\"bi bi-arrow-down menuitem\"></i>,\r\n    lock: <i className=\"bi bi-lock menuitem\" style={{marginRight: '10px'}}></i>,\r\n    unlock: <i className=\"bi bi-unlock menuitem\" style={{marginRight: '10px'}}></i>,\r\n    view: <i className=\"bi bi-window-plus menuitem\"></i>,\r\n    grid: <i className=\"bi bi-grid-3x3-gap menuitem\"></i>,\r\n    maximize: <i className=\"bi bi-arrows-fullscreen menuitem\"></i>,\r\n    fullscreen: <i className=\"bi bi-arrows-fullscreen menuitem\"></i>,\r\n    'fullscreen-exit': <i className=\"bi bi-fullscreen-exit\"></i>,\r\n    'zoom-in': <i className=\"bi bi-zoom-in menuitem\"></i>,\r\n    'zoom-out': <i className=\"bi bi-zoom-out menuitem\"></i>,\r\n    help: <i className=\"bi bi-question-square menuitem\"></i>,\r\n    'whats-, Metamodel': <i className=\"bi bi-bell menuitem\"></i>,\r\n    home: <i className=\"bi bi-house menuitem\"></i>,\r\n    'getting-started': <i className=\"bi bi-airplane menuitem\"></i>,\r\n    manual: <i className=\"bi bi-journals menuitem\"></i>,\r\n    legal: <i className=\"bi bi-mortarboard menuitem\"></i>,\r\n    about: <Logo style={{width: 15}} className={'menuitem'}/>,\r\n    'jjodel-dark': <img src={jj} width={15} className={'menuitem'}/>,\r\n    'jjodel-clear': <img\r\n        style={{border: '1px solid var(--color)', borderRadius: '2px', marginTop: '2px', marginRight: '-2px'}} src={jj}\r\n        width={16} className={'menuitem'}/>,\r\n\r\n    jjodel: <Logo style={{fontSize: '1.5em'}} className={'menuitem'}/>,\r\n    metamodel: <MetamodelIcon className={'menuitem'} style={{fontSize: '1.5em'}}/>,\r\n    model: <ModelIcon className={'menuitem'} style={{fontSize: '1.5em'}}/>,\r\n    project: <LuPackage2 style={{fontSize: '1.5em'}} className='menuitem'/>,\r\n\r\n    logout: <i className=\"bi bi-box-arrow-right menuitem\"></i>,\r\n    dashboard2: <i className=\"bi bi-grid menuitem\"></i>,\r\n    dashboard: <i className=\"bi bi-columns-gap menuitem\"></i>,\r\n    profile: <i className=\"bi bi-person-square menuitem\"></i>,\r\n    settings: <i className=\"bi bi-sliders menuitem\"></i>,\r\n    recent: <i className=\"bi bi-clock-history menuitem\"></i>,\r\n    folder: <i className=\"bi bi-folder menuitem\"></i>,\r\n    template: <i className=\"bi bi-code-square menuitem\"></i>,\r\n    template2: <i className=\"bi bi-lightbulb menuitem\"></i>,\r\n    extend: <i className=\"bi bi-caret-up menuitem\" style={{paddingBottom: '2px'}}></i>,\r\n    ai: <i className=\"bi bi-stars\"></i>,\r\n    metrics: <i className=\"bi bi-graph-up\" style={{marginRight: '10px'}}></i>,\r\n    analytics: <i className=\"bi bi-graph-up menuitem\"></i>,\r\n    submenu: <i className=\"bi bi-chevron-right menuitem float-end\"></i>,\r\n    contract: <i className=\"bi bi-arrows-angle-contract\"></i>,\r\n    expand: <i className=\"bi bi-arrows-angle-expand\"></i>,\r\n    alphabetical: <i className=\"bi bi-sort-alpha-down\"></i>,\r\n    created: <i className=\"bi bi-calendar2-plus\"></i>,\r\n    modified: <i className=\"bi bi-clock\"></i>,\r\n    lastModified: <i className=\"bi bi-clock\"></i>,\r\n    link: <i style={{scale: '1.2'}}\r\n             className=\"bi bi-link-45deg menuitem\"></i>,\r\n    learn: <i className=\"bi bi-infinity menuitem\"></i>,\r\n    video: <i className=\"bi bi-youtube menuitem\"></i>,\r\n    roadmap: <i className=\"bi bi-calendar3 menuitem\"></i>,\r\n    support: <i className=\"bi bi-life-preserver menuitem\"></i>,\r\n    'report-bug': <i className=\"bi bi-bug menuitem\"></i>,\r\n    'feature-request': <i className=\"bi bi-hand-index menuitem\"></i>,\r\n    contact: <i className=\"bi bi-card-text menuitem\"></i>,\r\n    'toggle-grid': <i className=\"bi bi-grid-1x2 menuitem\"></i>,\r\n    'toggle-snap': <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"22\" height=\"22\" fill=\"currentColor\"\r\n                        className=\"bi bi-layout-sidebar\" viewBox=\"0 0 16 16\">\r\n        <path\r\n            d=\"M6 1H1v14h5z m9 0h-5v5h5zm0 9v5M0 1a1 1 0 0 1 1-1h5a1 1 0 0 1 1 1v14a1 1 0 0 1-1 1H1a1 1 0 0 1-1-1zm9 0a1 1 0 0 1 1-1h5a1 1 0 0 1 1 1v5a1 1 0 0 1-1 1h-5a1 1 0 0 1-1-1zm1 8a1 1 0 0 0-1 1v5a1 1 0 0 0 1 1h5a1 1 0 0 0 1-1v-5a1 1 0 0 0-1-1z\"/>\r\n    </svg>,\r\n    'reset-layout': <i className=\"bi bi-columns menuitem\"></i>,\r\n    sidebar: <i className=\"bi bi-layout-sidebar menuitem\"></i>,\r\n    toolbar2: <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"22\" height=\"22\" fill=\"currentColor\"\r\n                   className=\"bi bi-layout-sidebar\" viewBox=\"0 0 16 16\">\r\n        <path\r\n            d=\"M0 3a2 2 0 0 1 2-2h12a2 2 0 0 1 2 2v10a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2z m2 -1 a1 1 0 0 0 -1 1v2h14v-2a1 1 0 0 0 -1 -1zm -1 4l 0 7a1 1 0 0 0 1 1h12a1 1 0 0 0 1 -1v-7z\"/>\r\n    </svg>\r\n}\r\n\r\n","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\collaborative\\CollaborativeAttacher.tsx",["991"],"import Collaborative from './Collaborative';\r\nimport type {CompositeAction, GObject, LProject, Pointer} from '../../joiner';\r\nimport {Action, SetRootFieldAction} from '../../joiner';\r\nimport {useEffect, useState} from \"react\";\r\n\r\ninterface Props {project: LProject}\r\nfunction CollaborativeAttacher(props: Props) {\r\n    const project = props.project;\r\n    const [actions, setActions] = useState<Pointer[]>([]);\r\n\r\n    useEffect(() => {\r\n        SetRootFieldAction.new('collaborativeSession', true);\r\n        Collaborative.client.io.opts.query = {'project': project.id};\r\n        Collaborative.client.connect();\r\n        /*\r\n        return () => {\r\n            Collaborative.client.off('pullAction');\r\n            Collaborative.client.disconnect();\r\n            SetRootFieldAction.new('collaborativeSession', false);\r\n        }\r\n        */\r\n        Collaborative.client.on('pullAction', (action: GObject<Action & CompositeAction>) => {\r\n            const receivedAction = Action.fromJson(action);\r\n            console.log('Received Action from server.', action);\r\n            receivedAction.hasFired = 0;\r\n            if(!actions.includes(receivedAction.id)) {\r\n                console.log('Received actions', actions)\r\n                setActions([...actions, action.id]);\r\n                receivedAction.fire();\r\n            }\r\n        });\r\n    }, []);\r\n\r\n    return(<></>);\r\n}\r\n\r\nexport default CollaborativeAttacher;\r\n","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\pages\\components\\LatestUpdates.tsx",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\pages\\components\\Edit\\Edit.tsx",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\data\\api.ts",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\abstract\\tabs\\MetamodelTab.tsx",["992","993"],"import React, {Dispatch, ReactElement} from \"react\";\r\nimport {connect} from \"react-redux\";\r\nimport {DModel, Pointer, Try, U} from \"../../../joiner\";\r\nimport {\r\n    DState,\r\n    CreateElementAction,\r\n    DGraph,\r\n    LGraph,\r\n    LModel,\r\n    Edge,\r\n    DUser,\r\n    DClass,\r\n    SetRootFieldAction\r\n} from \"../../../joiner\";\r\nimport {DefaultNode} from \"../../../joiner/components\";\r\nimport ToolBar from \"../../toolbar/ToolBar\";\r\nimport ContextMenu from \"../../contextMenu/ContextMenu\";\r\nimport { MetricsPanel } from \"../../metrics/Metrics\";\r\n\r\n\r\nfunction MetamodelTabComponent(props: AllProps) {\r\n    const model = props.model;\r\n    const graph = props.graph;\r\n    const isEdgePending = props.isEdgePending;\r\n\r\n    if (!model) return(<>closed tab</>);\r\n    if (!graph) {\r\n        DGraph.new(0, model.id);\r\n        return(<div style={{width: \"100%\", height: \"100%\", display: \"flex\"}}>\r\n            <span style={{margin: \"auto\"}}>Building the Graph...</span>\r\n        </div>);\r\n    }\r\n\r\n    return(<div className={'w-100 h-100'}>\r\n        <MetricsPanel data={model}/>\r\n        <ContextMenu />\r\n        {/*<PendingEdge />*/}\r\n        {/* Temporary Edge Pending Manager */}\r\n        {isEdgePending.source && <div style={{position: 'absolute', top: 15, right: 15, zIndex: 999}}\r\n             className={'w-fit bg-white rounded border p-2'}>\r\n            <label className={'d-block text-center'}>Pending Edge...</label>\r\n            <label tabIndex={-1} onClick={e => SetRootFieldAction.new('isEdgePending', {user: '', source: ''})}\r\n               className={'cursor-pointer text-decoration-none d-block text-danger text-center'}>close</label>\r\n        </div>}\r\n\r\n        <div className={'d-flex h-100'}>\r\n            <ToolBar model={model.id} isMetamodel={model.isMetamodel} />\r\n            <Try>\r\n                <div className={\"GraphContainer h-100 w-100\"} style={{position:\"relative\"}}\r\n                     onClick={ e => {\r\n                         if(!U.isProjectModified) U.isProjectModified = U.userHasInteracted = true\r\n                     }}>\r\n                    {graph && <DefaultNode data={model} nodeid={graph.id} graphid={graph.id}/> || <div>Error: missing DGraph prop</div> }\r\n                </div>\r\n            </Try>\r\n        </div>\r\n    </div>);\r\n\r\n}\r\ninterface OwnProps { modelid: Pointer<DModel, 1, 1, LModel> }\r\ninterface StateProps {\r\n    model: LModel,\r\n    graph: LGraph,\r\n    isEdgePending: {user: Pointer<DUser>, source: Pointer<DClass>}\r\n}\r\ninterface DispatchProps { }\r\ntype AllProps = OwnProps & StateProps & DispatchProps;\r\n\r\n\r\nfunction mapStateToProps(state: DState, ownProps: OwnProps): StateProps {\r\n    const ret: StateProps = {} as any;\r\n    ret.model = LModel.fromPointer(ownProps.modelid);\r\n    const graphs: DGraph[] = DGraph.fromPointer(state.graphs);\r\n    const pointers = graphs.filter((graph) => { return graph.model === ret.model?.id });\r\n    if (pointers.length > 0) ret.graph = LGraph.fromPointer(pointers[0].id);\r\n    ret.isEdgePending = state.isEdgePending\r\n    return ret;\r\n}\r\n\r\nfunction mapDispatchToProps(dispatch: Dispatch<any>): DispatchProps {\r\n    const ret: DispatchProps = {};\r\n    return ret;\r\n}\r\n\r\n\r\nexport const MetamodelTabConnected = connect<StateProps, DispatchProps, OwnProps, DState>(\r\n    mapStateToProps,\r\n    mapDispatchToProps\r\n)(MetamodelTabComponent);\r\n\r\nexport const MetamodelTab = (props: OwnProps, children: (string | React.Component)[] = []): ReactElement => {\r\n    return <MetamodelTabConnected {...{...props, children}} />;\r\n}\r\nexport default MetamodelTab;\r\n","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\abstract\\tabs\\ModelTab.tsx",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\editors\\languages\\Ocl.tsx",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\editors\\languages\\Jsx.tsx",["994"],"import React, {Dispatch, ReactElement, ReactNode, useEffect} from \"react\";\r\nimport {connect} from \"react-redux\";\r\nimport {useStateIfMounted} from \"use-state-if-mounted\";\r\nimport type {FakeStateProps} from \"../../../joiner/types\";\r\nimport {DState, DViewElement, LViewElement, Pointer, Defaults} from \"../../../joiner\";\r\nimport Editor, { useMonaco } from \"@monaco-editor/react\";\r\n\r\n// import monacoTypes2 from '!raw-loader!../../../static/monacotypes';\r\nimport monacoTypes from '../../../static/monacotypes';\r\nimport { CommandBar, Btn } from \"../../commandbar/CommandBar\";\r\nimport { uniqueId } from \"lodash\";\r\n\r\nfunction JsxEditorComponent(props: AllProps) {\r\n    const monaco = useMonaco();\r\n    const view = props.view;\r\n    const dview = view.__raw;\r\n    const readOnly = props.readOnly !== undefined ? props.readOnly : !props.debugmode && Defaults.check(dview.id);\r\n    const [jsx, setJsx] = useStateIfMounted(dview.jsxString || '');\r\n    const [show, setShow] = useStateIfMounted(true);\r\n\r\n    const [expand, setExpand] = useStateIfMounted(false);\r\n\r\n    const change = (value: string|undefined) => { // save in local state for frequent changes.\r\n        if (value !== undefined) setJsx(value);\r\n    }\r\n\r\n\r\n    const blur = (evt?: React.FocusEvent) => { // confirm in redux state for final state\r\n        view.jsxString = jsx;\r\n    }\r\n\r\n    useEffect(() => {\r\n        if (!monaco) return;\r\n        monaco.languages.typescript.typescriptDefaults.setCompilerOptions({\r\n            target: monaco.languages.typescript.ScriptTarget.Latest,\r\n            allowNonTsExtensions: true,\r\n            moduleResolution: monaco.languages.typescript.ModuleResolutionKind.NodeJs,\r\n            module: monaco.languages.typescript.ModuleKind.CommonJS,\r\n            noEmit: true,\r\n            esModuleInterop: true,\r\n            jsx: monaco.languages.typescript.JsxEmit.React,\r\n            reactNamespace: \"React\",\r\n            allowJs: true,\r\n            typeRoots: [\"node_modules/@types\"]//, 'src/static/'], // doubt those can be accesed at runtime but trying\r\n        });\r\n\r\n        monaco.languages.typescript.typescriptDefaults.setDiagnosticsOptions({ noSemanticValidation: false, noSyntaxValidation: false });\r\n        monaco.languages.typescript.javascriptDefaults.setEagerModelSync(true);\r\n\r\n        monaco.languages.typescript.typescriptDefaults.addExtraLib(\"declare var data: 'datatype';\");\r\n        /*\r\n        // doubt those files can be accesed at runtime but trying\r\n        monaco.languages.typescript.javascriptDefaults.addExtraLib('declare var data: LModelElement; declare var node: LGraphElement;', 'src/static/monacotypes.d.ts');\r\n\r\n        monaco.languages.typescript.typescriptDefaults.addExtraLib(\r\n            '<<react-definition-file>>',\r\n            `file:///node_modules/@react/types/index.d.ts`\r\n        );*/\r\n\r\n\r\n\r\n    }, [monaco]);\r\n\r\n    //const lines = (Math.round(dview.jsxString.split(/\\r|\\r\\n|\\n/).length*1.8) < 5 ? 5 : Math.round(dview.jsxString.split(/\\r|\\r\\n|\\n/).length*1.8));\r\n\r\n    let lines: number;\r\n    if (expand) {\r\n        lines = 1;\r\n        for (let i = 0; i < dview.jsxString.length; i++) if (dview.jsxString[i] === '\\n') lines++;\r\n        lines += 2; // \"margin\"\r\n    } else {\r\n        lines = 5;\r\n    }\r\n    if (lines < 5) lines = 5;\r\n    return(<>\r\n        <div className={'cursor-pointer d-flex'} onClick={e => setShow(!show)}>\r\n            <span className={'my-auto'} tabIndex={-1} >\r\n                <i className={'bi bi-chevron-' + (show ? 'down' : 'right')} />\r\n                {/*show ? <i className={'bi bi-eye-fill'} /> : <i className={'bi bi-eye-slash-fill'} /> */}\r\n            </span>\r\n            <label className={'editor-label'}>\r\n                JSX Editor\r\n            </label>\r\n\r\n            {/* show && <CommandBar style={{paddingTop: '10px'}}>\r\n                {expand ?\r\n                    <Btn icon={'shrink'} action={(e) => {setExpand(false); setShow(true)}} tip={'Minimize editor'}/>\r\n                    :\r\n                    <Btn icon={'expand'} action={(e) => {setExpand(true); setShow(true)}} tip={'Enlarge editor'}/>\r\n                }\r\n            </CommandBar>*/}\r\n        </div>\r\n        {show && <div className={'mt-1'}>\r\n            {jsx.match(/{\\s*\\(.+\\?.+\\:.+\\)\\s*}/gm) && <label>\r\n                <b className={'text-warning'}>Warning:</b>\r\n                Please remove the round parenthesis, concatenate it with an empty string as in &#123; (a ? b : c) + '' &#125;\r\n                or replace the ternary operator as in (a && b || c).\r\n            </label>}\r\n            {(jsx).indexOf('<>') >= 0 && <label>\r\n                <b className={'text-warning'}>Warning:</b>\r\n                JSX.Fragment {'<>'} is valid JSX but is not supported by our compiler.\r\n                Please replace it with an array [] instead.\r\n            </label>}\r\n            {(jsx).indexOf('?.') >= 0 && <label>\r\n                <b className={'text-warning'}>Warning:</b>\r\n                Optional chaining {'.?'} is valid JS but is not supported by our compiler.\r\n                Please replace it with && instead. Eg: from (a?.b) to (a && a.b).\r\n            </label>}\r\n            {(jsx).indexOf('??') >= 0 && <label>\r\n                <b className={'text-warning'}>Warning:</b>\r\n                Nullish coalescing {'??'} is valid JS but is not supported by our compiler.\r\n                Please replace it with explicit null and undefined checks, or a ||.\r\n            </label>}\r\n        </div>}\r\n        {show && <div className={'monaco-editor-wrapper'}\r\n                    style={{padding: '5px', minHeight: '20px', transition: 'height 0.3s', height:`${expand ? 'calc('+(lines-1)+' * 16px)' : (5*16)+'px'}`, resize: 'vertical', overflow:'hidden'}}\r\n                    onFocus={() => setExpand(true)}\r\n                    onBlur={(e) => {setExpand(false); blur(e);}}\r\n                    tabIndex={-1} >\r\n            <Editor className={'mx-1'} onChange={change} language={\"typescript\"}\r\n                    options={{fontSize: 12, scrollbar: {vertical: 'hidden', horizontalScrollbarSize: 5}, minimap: {enabled: false}, readOnly: readOnly}}\r\n                    defaultLanguage={'typescript'} value={dview.jsxString} />\r\n        </div>}\r\n    </>);\r\n}\r\ninterface OwnProps {\r\n    viewid: Pointer<DViewElement, 1, 1, LViewElement>;\r\n    readOnly?: boolean;\r\n}\r\n\r\ninterface StateProps {\r\n    view: LViewElement;\r\n    debugmode: boolean;\r\n}\r\ninterface DispatchProps {}\r\ntype AllProps = OwnProps & StateProps & DispatchProps;\r\n\r\n\r\nfunction mapStateToProps(state: DState, ownProps: OwnProps): StateProps {\r\n    const ret: StateProps = {} as FakeStateProps;\r\n    ret.debugmode = state.debug;\r\n    ret.view = LViewElement.fromPointer(ownProps.viewid);\r\n    return ret;\r\n}\r\n\r\nfunction mapDispatchToProps(dispatch: Dispatch<any>): DispatchProps {\r\n    const ret: DispatchProps = {};\r\n    return ret;\r\n}\r\n\r\n\r\nexport const JsxEditorConnected = connect<StateProps, DispatchProps, OwnProps, DState>(\r\n    mapStateToProps,\r\n    mapDispatchToProps\r\n)(JsxEditorComponent);\r\n\r\nexport const JsxEditor = (props: OwnProps, children: (string | React.Component)[] = []): ReactElement => {\r\n    return <JsxEditorConnected {...{...props, children}} />;\r\n}\r\n\r\nJsxEditorComponent.cname = \"JsxEditorComponent\";\r\nJsxEditorConnected.cname = \"JsxEditorConnected\";\r\nJsxEditor.cname = \"JsxEditor\";\r\nexport default JsxEditor;\r\n","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\editors\\languages\\Js.tsx",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\editors\\PermissionModelTab.tsx",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\pages\\components\\popups\\Model.tsx",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\pages\\components\\popups\\Metamodel.tsx",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\abstract\\tabs\\ModelsSummaryTab.tsx",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\editors\\Broker.tsx",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\editors\\NodeEditor.tsx",["995","996","997","998"],"import React, {Dispatch, ReactElement} from 'react';\r\nimport {connect} from 'react-redux';\r\nimport {DState} from '../../redux/store';\r\nimport type {\r\n    LModelElement,\r\n    LViewElement,\r\n    LGraphElement,\r\n    LVoidVertex,\r\n    LVoidEdge, LGraph,Pointer, DGraphElement,\r\n    DNamedElement, LNamedElement} from '../../joiner';\r\nimport {\r\n    LPointerTargetable,\r\n    L,\r\n    Input,\r\n    GenericInput,\r\n    TextArea,\r\n    RuntimeAccessibleClass,\r\n    SetRootFieldAction, DEdge,\r\n} from '../../joiner';\r\nimport './editors.scss';\r\nimport './node-editor.scss';\r\nimport {Empty} from \"./Empty\";\r\nimport { CommandBar, Btn } from '../commandbar/CommandBar';\r\n\r\nfunction NodeEditorComponent(props: AllProps) {\r\n    const selected = props.selected;\r\n    const editable = true;\r\n    if (!selected?.node) return <Empty msg={'Select a node.'} />;\r\n    const node = selected.node;\r\n    const dnode = (node.__raw || node) as DGraphElement\r\n    let cname = dnode.className;\r\n    let isGraph = ['DGraph', 'DGraphVertex'].includes(cname); // RuntimeAccessibleClass.extends(cname, 'DGraph');\r\n    let isVertex = ['DVoidVertex', 'DVertex', 'DEdgePoint'].includes(cname); // RuntimeAccessibleClass.extends(cname, 'DVoidVertex');\r\n    let isEdge = ['DVoidEdge', 'DEdge'].includes(cname); // RuntimeAccessibleClass.extends(cname, 'DVoidEdge');\r\n    let isField = (!isGraph && !isVertex && !isEdge);\r\n    let asGraph: LGraph | undefined = isGraph && node as any;\r\n    let asVertex: LVoidVertex | undefined  = isVertex && node as any;\r\n    let asEdge: LVoidEdge | undefined = isEdge && node as any;\r\n    let asField: LVoidEdge | undefined = isField && node as any;\r\n    function openNode(id: Pointer<DGraphElement>) {\r\n        SetRootFieldAction.new('_lastSelected.node', id, '', false);\r\n    }\r\n\r\n    function getNodeLabel(node: LGraphElement){\r\n        if (!node) return 'error';\r\n        let model: DNamedElement | undefined = node.model?.__raw as any;\r\n        if (!model) return node.className;\r\n        return node.className + ' - ' +(model.name || model.className)\r\n    }\r\n    function getEdgeLabel(edge: LVoidEdge){\r\n        let s: DNamedElement | undefined = edge?.start?.model?.__raw as any;\r\n        let e: DNamedElement | undefined = edge?.end?.model?.__raw as any;\r\n        return [\r\n            (s ? s.name || s.className : <i style={{color: 'orange'}}>empty</i>),\r\n            <i className={'bi bi-arrow-right ms-1 me-1'} />,\r\n            (e ? e.name || e.className : <i style={{color: 'orange'}}>empty</i>)\r\n        ];\r\n\r\n    }\r\n    const clickableStyle = {cursor:'pointer', color: 'gray'};\r\n    const headerStyle = {marginBottom:0, marginTop: '0.5em'};\r\n    const edgeStart: LGraphElement | undefined = asEdge && asEdge.start;\r\n    const edgeEnd: LGraphElement | undefined = asEdge && asEdge.end;\r\n    const notFoundStyle = {color: 'orange', cursor:'not-allowed'};\r\n    const subElements = node.subElements;\r\n    let edgesIn = !isEdge && node.edgesIn || [];\r\n    let edgesOut = !isEdge && node.edgesOut || [];\r\n\r\n\r\n\r\n\r\n\r\n    type InputRowProps = {\r\n        label: string,\r\n        as: any,\r\n        field: string,\r\n        type: string\r\n    }\r\n    const InputRow = (props: any) => {\r\n        return (\r\n            <div className='input-container'>\r\n                <b className={'me-2'}>{props.label}</b>\r\n                <Input data={props.as} field={props.field} type={props.type} readOnly={!editable} />\r\n            </div>\r\n        );\r\n    };\r\n\r\n    let stackingOrder = <InputRow label={'Stacking order'} as={node} field={'zIndex'} type={'number'} />\r\n\r\n    return(<div className={'p-3 node-editor'}>\r\n        {/*<Input obj={selected.node} field={'id'} label={'ID'} type={'text'} readonly={true}/>*/}\r\n\r\n        {asGraph && <><h3>Graph</h3>\r\n            <GenericInput data={asGraph} field={'zoom'} />\r\n            <GenericInput data={asGraph} field={'offset'} />\r\n\r\n            {/*graphSize readonly on LGraph but not on DGraph, = internal graph size. put it for info.*/ }\r\n        </>}\r\n\r\n        {asVertex && <><h3>Vertex</h3>\r\n            {stackingOrder}\r\n\r\n            <InputRow label={'isResized'} as={asVertex} field={'isResized'} type={'checkbox'} />\r\n            <InputRow label={'X Position'} as={asVertex} field={'x'} type={'number'} />\r\n            <InputRow label={'Y Position'} as={asVertex} field={'y'} type={'number'} />\r\n            <InputRow label={'Width'} as={asVertex} field={'width'} type={'number'} />\r\n            <InputRow label={'Height'} as={asVertex} field={'height'} type={'number'} />\r\n        </>}\r\n\r\n        {asEdge && <><h3>Edge</h3>\r\n            {stackingOrder}\r\n\r\n            {\r\n            //  <>\r\n            //     moved to props & transient properties\r\n            //     <GenericInput data={asEdge} field={'longestLabel'}\r\n            //         placeholder={'(edge/*LEdge*/, segment/*EdgeSegment*/, subNodes/*LGraphElement[]*/, allSegments/*EdgeSegment[]*/) => {' +\r\n            //         '\\n\\t// a complex example. The label can be either a function like this or a simple string.' +\r\n            //         '\\n\\t return (edge.start.model)?.name + \\' ~ \\' + (e.end.model)?.name + \\'(\\' + segment.length.toFixed(1) + \\')\\';' +\r\n            //         '\\n}'}/>\r\n            //     <GenericInput data={asEdge} field={'labels'}\r\n            //         placeholder={'(edge/*LEdge*/, segment/*EdgeSegment*/, subNodes/*LGraphElement[]*/, allSegments/*EdgeSegment[]*/) => {' +\r\n            //         '\\n\\t// a complex example. The label can be either a function like this or a simple string.' +\r\n            //         '\\n\\t return (edge.start.model)?.name + \\' ~ \\' + (e.end.model)?.name + \\'(\\' + segment.length.toFixed(1) + \\')\\';' +\r\n            //         '\\n}'}/>\r\n            // </>\r\n            }\r\n\r\n            <GenericInput className='input-container' data={asEdge} field={\"anchorStart\"}/>\r\n            <GenericInput className='input-container' data={asEdge} field={\"anchorEnd\"}/>\r\n        </>}\r\n\r\n        {asField && <><h3>Field</h3>\r\n            {stackingOrder}\r\n        </>}\r\n\r\n        <div style={{marginTop:'1em', marginBottom:'1em', borderBottom:'1px solid gray'}}/>\r\n\r\n        {/* <div>\r\n            <h6 className={'super'}>\r\n                Super element:\r\n                {node.father?.className ?\r\n                    <span onClick={(e)=> dnode.father && openNode(dnode.father)} style={clickableStyle}>\r\n                        {[node.father?.className, <i style={{paddingLeft: '8px'}} className=\"bi bi-chevron-up\"></i>]}\r\n                    </span>\r\n                :\r\n                    <span style={notFoundStyle}>Not contained</span>\r\n                }\r\n            </h6>\r\n            </div>*/}\r\n\r\n        {node.father?.className && <div>\r\n            <h6 style={{display: 'flex'}}>\r\n                Super element\r\n                    {/*<span onClick={(e)=> dnode.father && openNode(dnode.father)} style={clickableStyle}>\r\n                        {[node.father?.className, <i style={{paddingLeft: '8px'}} className=\"bi bi-chevron-up\"></i>]}\r\n                    </span>*/}\r\n                    <CommandBar style={{paddingLeft: 'var(--tab-sep)', bottom: '3px'}}>\r\n                        <Btn icon={'up'} action={(e)=> dnode.father && openNode(dnode.father)} tip={'Go up'}/>\r\n                    </CommandBar>\r\n            </h6>\r\n        </div>}\r\n\r\n        {asEdge && [\r\n            <div key={'es'}><h6 style={headerStyle}>Edge start:{\r\n                edgeStart ?\r\n                    <span className={'ms-2'} onClick={(e)=> openNode(edgeStart.id)} style={clickableStyle}>\r\n                        {getNodeLabel(edgeStart)}<i className={'ms-1 bi bi-arrow-right'}/>\r\n                    </span>\r\n                    : <span style={notFoundStyle}>Missing</span>\r\n            }</h6></div>,\r\n            <div key={'ee'}><h6 style={headerStyle}>Edge End:{\r\n                edgeEnd ?\r\n                    <span className={'ms-2'} onClick={(e)=> openNode(edgeEnd.id)} style={clickableStyle}>\r\n                        {getNodeLabel(edgeEnd)}<i className={'ms-1 bi bi-arrow-left'}/>\r\n                    </span>\r\n                    : <span style={notFoundStyle}>Missing</span>\r\n            }</h6></div>\r\n        ]}\r\n\r\n        {/* <div>\r\n            <h6 style={headerStyle} className='sub'>\r\n                Sub elements\r\n                {subElements.length ?\r\n                    <i style={{paddingLeft: '8px'}}className=\"bi bi-chevron-down\"></i>\r\n                :\r\n                    [': ', <span style={notFoundStyle}>None</span>]\r\n                }\r\n            </h6>\r\n            {subElements.map(\r\n                n => <div className={'w-100 ms-2'} onClick={(e)=> openNode(n.id)} style={clickableStyle}>{getNodeLabel(n)}</div>\r\n            )}\r\n            </div>*/}\r\n\r\n            {subElements.length > 0 && <div>\r\n            <h6 style={{display: 'flex'}}>\r\n                Sub elements\r\n                <CommandBar style={{paddingLeft: 'var(--tab-sep)', bottom: '3px'}}>\r\n                    <Btn icon={'down'} action={(e)=> {}} tip={'Go down'}/>\r\n                </CommandBar>\r\n            </h6>\r\n\r\n            {subElements.map(\r\n                n => <div key={n.id} className={'w-100 ms-2 sub-element'} onClick={(e)=> openNode(n.id)} style={clickableStyle}>{getNodeLabel(n)}</div>\r\n            )}\r\n            </div>}\r\n\r\n        {!asEdge && <>\r\n            {edgesOut.length > 0 && <div>\r\n                <h6 style={{display: 'flex'}}>\r\n                    Outgoing Edges\r\n                </h6>\r\n                {edgesOut.map(n => <div key={n.id} className={'w-100 ms-2 sub-element'} onClick={(e)=> openNode(n.id)} style={clickableStyle}>{getEdgeLabel(n)}</div>)}\r\n            </div>}\r\n\r\n            {edgesIn.length > 0 && <div>\r\n                <h6 style={{display: 'flex'}}>\r\n                    Incoming Edges\r\n                </h6>\r\n                {edgesIn.map(n => <div key={n.id} className={'w-100 ms-2 sub-element'} onClick={(e)=> openNode(n.id)} style={clickableStyle}>{getEdgeLabel(n)}</div>)}\r\n            </div>}\r\n\r\n            {/*<div>\r\n                <h6 style={headerStyle}>\r\n                    Outgoing Edges {edgesOut.length === 0 && <>: <span style={notFoundStyle}>None</span></>}\r\n                </h6>\r\n                {edgesOut.length && edgesOut.map(n => <div className={'w-100 ms-2'} onClick={(e)=> openNode(n.id)} style={clickableStyle}>{getEdgeLabel(n)}</div>)}\r\n            </div>\r\n\r\n            <div>\r\n                <h6 style={headerStyle}>Incoming Edges{edgesIn.length === 0 && <>:\r\n                    <span style={notFoundStyle}>None</span></>}\r\n                </h6>\r\n                {edgesIn.map(n => <div className={'w-100 ms-2'} onClick={(e)=> openNode(n.id)} style={clickableStyle}>{getEdgeLabel(n)}</div>)}\r\n            </div>*/}\r\n        </>}\r\n\r\n\r\n        <h6>Node state</h6>\r\n        <div className={'object-state'}>\r\n            {Object.keys(dnode._state).length === 0 && <pre> Empty</pre>}\r\n            <pre>{Object.keys(dnode._state).length ? JSON.stringify(dnode._state, null, '\\t') : undefined}</pre>\r\n        </div>\r\n\r\n    </div>);\r\n\r\n}\r\ninterface OwnProps {}\r\ninterface StateProps {\r\n    selected?: {\r\n        node: LGraphElement;\r\n        view: LViewElement;\r\n        modelElement?: LModelElement;\r\n    };\r\n}\r\ninterface DispatchProps {}\r\ntype AllProps = OwnProps & StateProps & DispatchProps;\r\n\r\n\r\nfunction mapStateToProps(state: DState, ownProps: OwnProps): StateProps {\r\n    let ret: StateProps = {};\r\n    const selected = state._lastSelected;\r\n    if(selected) {\r\n        const modelElement = state._lastSelected?.modelElement;\r\n        const node = state._lastSelected?.node;\r\n        const view = state._lastSelected?.view;\r\n        if(node && view) {\r\n            ret.selected = {\r\n                node: L.fromPointer(node),\r\n                view: L.fromPointer(node),\r\n                modelElement: (modelElement) ? L.fromPointer(modelElement) : undefined\r\n            }\r\n        }\r\n    }\r\n    return ret;\r\n}\r\n\r\nfunction mapDispatchToProps(dispatch: Dispatch<any>): DispatchProps {\r\n    const ret: DispatchProps = {};\r\n    return ret;\r\n}\r\n\r\n\r\nexport const NodeEditorConnected = connect<StateProps, DispatchProps, OwnProps, DState>(\r\n    mapStateToProps,\r\n    mapDispatchToProps\r\n)(NodeEditorComponent);\r\n\r\nexport const NodeEditor = (props: OwnProps, children: (string | React.Component)[] = []): ReactElement => {\r\n    return <NodeEditorConnected {...{...props, children}} />;\r\n}\r\nexport default NodeEditor;\r\n\r\n","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\dock\\MyRcDock.tsx",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\metrics\\Metrics.tsx",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\contextMenu\\ContextMenu.tsx",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\toolbar\\ToolBar.tsx",["999","1000","1001"],"import React, {Dispatch, ReactElement, ReactNode, useEffect, useRef, useState} from \"react\";\r\nimport {connect} from \"react-redux\";\r\nimport \"./toolbar.scss\";\r\nimport {\r\n    DState,\r\n    DGraphElement,\r\n    Dictionary,\r\n    DModel,\r\n    DModelElement,\r\n    DNamedElement,\r\n    DObject,\r\n    DocString,\r\n    DPointerTargetable,\r\n    DViewElement,\r\n    LGraphElement,\r\n    LModel,\r\n    LModelElement,\r\n    LObject,\r\n    LValue,\r\n    LViewElement,\r\n    MyProxyHandler,\r\n    Pointer,\r\n    SetFieldAction,\r\n    RuntimeAccessibleClass,\r\n    DVoidEdge,\r\n    DEdge,\r\n    DEdgePoint,\r\n    EdgeSegment,\r\n    LVoidEdge,\r\n    Constructors,\r\n    WVoidEdge,\r\n    Log,\r\n    LEdgePoint, DUser,\r\n    U, LPointerTargetable, SetRootFieldAction, GObject, EMeasurableEvents, TRANSACTION\r\n} from \"../../joiner\";\r\n\r\nimport {InitialVertexSizeObj} from \"../../joiner/types\";\r\nimport ModellingIcon from \"../forEndUser/ModellingIcon\";\r\n\r\ninterface ThisState {}\r\n\r\nlet ti = 0; // tabindex counter\r\n\r\nfunction toolbarClick(item_dname: string, data: LModelElement|undefined, myDictValidator: Dictionary<DocString<\"DClassName\">, DocString<\"hisChildren\">[]>, node?:LGraphElement) {\r\n    switch(item_dname){\r\n        case DVoidEdge.cname:\r\n        case DEdge.cname:\r\n            // no add edges through toolbar for now\r\n            break;\r\n        case DEdgePoint.cname:\r\n            let ledge: LVoidEdge = (node as LEdgePoint | LVoidEdge).edge;\r\n            let dedge: DVoidEdge = ledge.__raw;\r\n            let wedge: WVoidEdge = ledge as any;\r\n            // if (!myDictValidator[item_dname]) return;\r\n            let longestSeg: EdgeSegment = undefined as any; // just because compiler does not know it is always found through the for loop\r\n            let longestIndex: number = 0;\r\n            let segms = ledge.segments.segments;\r\n            // longestIndex = segms.length - 1;// i just put it at end because this edgepoint\r\n            for (; longestIndex < segms.length; longestIndex++) if (segms[longestIndex].isLongest) { longestSeg = segms[longestIndex]; break;}\r\n            // let index = edge.segments.all.findIndex((s: EdgeSegment) => s.isLongest);\r\n            let newmp: InitialVertexSizeObj = {...(longestSeg.start.pt.add(longestSeg.end.pt, true).divide(2)), w: 15, h: 15, index:longestIndex};\r\n            // @ts-ignore\r\n            newmp.x -= newmp.w/2; newmp.y -= newmp.h/2;\r\n\r\n            newmp.id = Constructors.makeID();\r\n            let subelements = [...dedge.subElements];\r\n            let prevNodeid = longestSeg.start.ge.id;\r\n            let prevnodeindex = subelements.indexOf(prevNodeid);\r\n            if (prevnodeindex === -1) {\r\n                if (prevNodeid === dedge.start) prevnodeindex = 0; // first and last are not subelements\r\n                else if (prevNodeid === dedge.end) prevnodeindex = subelements.length;\r\n                else Log.exDevv(\"edgepoint insert position not found\", {subelements, prevNodeid, longestSeg, dedge, ledge});\r\n            } else prevnodeindex += 1;\r\n            newmp.index = prevnodeindex;\r\n            // delete (newmp as any).id;\r\n            let mp = [...dedge.midPoints];\r\n            mp.splice(longestIndex, 0, newmp);\r\n            wedge.midPoints = mp;\r\n            let olddebug = [...subelements];\r\n            subelements.splice(prevnodeindex, 0, newmp.id as string);\r\n            console.log(\"injecting ep\", {prevnodeindex, newmp, prevNodeid, longestSeg, old: olddebug, new: subelements, ledge, dedge});\r\n            break;\r\n        default:\r\n            if (!data || !myDictValidator) return;\r\n            let item = item_dname.substring(1).toLowerCase();\r\n            let d = data.addChild(item);\r\n            try {\r\n                let d2 = (d as any)();\r\n                if (myDictValidator[item_dname]) select(d2);\r\n            } catch(e) {\r\n                if (myDictValidator[item_dname]) select(d);\r\n            }\r\n            break;\r\n    }\r\n}\r\nlet n_agonSides = 10; //this shuld be in react.setState(), but the function handling it is outside a component, so i don't wanna rewrite it.\r\n// it should be fine, except for the input value being shared on different sidebar components, which might even be better.\r\nfunction getItems(data: LModelElement|undefined, myDictValidator: Dictionary<DocString<\"DClassName\">, DocString<\"hisChildren\">[]>, items: DocString<\"D-ClassNames\">[], node?:LGraphElement): ReactNode[] {\r\n    const reactNodes: ReactNode[] = [];\r\n    // todo: does myDictValidator have any reason to exist? if something is invalid it should not make it on toolbar jsx generated list\r\n    for (let item_dname of items) {\r\n        if (item_dname[0]==\"_\") {\r\n            item_dname = item_dname.substring(2);\r\n            data = data?.father || data;\r\n        }\r\n        let item = item_dname.substring(1).toLowerCase();\r\n        reactNodes.push(<div className={'toolbar-item'} tabIndex={ti} style={{cursor:\"pointer\"}} key={item_dname} onClick={()=>toolbarClick(item_dname, data, myDictValidator, node)}>\r\n            <ModellingIcon name={item} />\r\n            <span className={'ms-1 my-auto text-capitalize'}>{item}</span>\r\n            {/*\r\n            <i className=\"bi bi-arrow-right-short hoverable\">\r\n                <ul className={\"content\"}>\r\n                    <li className={\"hoverable\"}>\r\n                        <span className={'ms-1 my-auto text-capitalize'}>Polygon</span>\r\n                        <i className=\"bi bi-arrow-right-short hoverable\">\r\n                            <ul className={\"content\"}>\r\n                                <span className={'ms-1 my-auto text-capitalize'}>Triangle</span>\r\n                                <span className={'ms-1 my-auto text-capitalize'}>Pentagon</span>\r\n                                <span className={'ms-1 my-auto text-capitalize'}>Hexagon</span>\r\n                                <span className={'ms-1 my-auto text-capitalize'}>Octagon</span>\r\n                                <span className={'ms-1 my-auto text-capitalize'}>\r\n                                    <input className={\"autosize-input\"} type={\"number\"} min={3} step={1}\r\n                                           value={n_agonSides} onClick{(evt) => { evt.stopPropagation()}}\r\n                                        onChange={(evt) => {\r\n                                            n_agonSides = +evt.target.value || 10;\r\n                                            if (n_agonSides<3) n_agonSides = 10;\r\n                                        }}\r\n                                    />-agon</span>\r\n                            </ul>\r\n                        </i>\r\n                    </li>\r\n                </ul>\r\n            </i>\r\n            <i className=\"bi bi-arrow-right-short hoverable\">\r\n                <ul className={\"content\"}>\r\n                    <li className={\"hoverable\"}>\r\n                        <span className={'ms-1 my-auto text-capitalize'}>Polygon</span>\r\n                    </li>\r\n                </ul>\r\n            </i>\r\n                */\r\n            }\r\n\r\n        </div>);\r\n    }\r\n    return reactNodes;\r\n}\r\nfunction select(dl: DModelElement | LModelElement): DModelElement {\r\n    let d: DModelElement = (dl as LModelElement)?.__raw || dl as DModelElement;\r\n    //console.log(\"selecting\", {d, dl, selector:\".Graph [data-dataid='\"+d?.id+\"']\", $ : $(\".Graph [data-dataid='\"+d?.id+\"']\")});\r\n    if (d && d.id) setTimeout(()=>$(\".Graph [data-dataid='\"+d?.id+\"']\").trigger(\"click\"), 10);\r\n    return d; }\r\n\r\nfunction selectNode(d: DGraphElement|{id: string}): any {\r\n    if (d && d.id) setTimeout(()=>$(\".Graph [data-nodeid='\"+d?.id+\"']\").trigger(\"click\"), 10);\r\n    return d; }\r\n\r\nfunction useClickOutside(ref: any, onClickOutside: any) {\r\n    useEffect(() => {\r\n        \r\n        function handleClickOutside(event: Event) {\r\n            if (ref.current && !ref.current.contains(event.target)) {\r\n                onClickOutside();\r\n            }\r\n        }\r\n\r\n        // Bind\r\n        document.addEventListener(\"mousedown\", handleClickOutside);\r\n        return () => {\r\n        // dispose\r\n        document.removeEventListener(\"mousedown\", handleClickOutside);\r\n        };\r\n    }, [ref, onClickOutside]);\r\n}\r\n\r\nfunction ToolBarComponent(props: AllProps, state: ThisState) {\r\n\r\n    const node = props.node;\r\n    let [pinned, setPinned] = useState(true);\r\n    let [collapsed, setCollapsed] = useState(false);\r\n    let [position, setPosition] = useState([20, 50]);\r\n\r\n    const menuRef = useRef();\r\n\r\n    /*useClickOutside(menuRef, () => {\r\n        setCollapsed(true);\r\n    });*/\r\n\r\n    const htmlref: React.MutableRefObject<null | HTMLDivElement> = useRef(null);\r\n    useEffect(() => {\r\n        if (!htmlref.current) return;\r\n        let draggableOptions = {\r\n            cursor: 'grabbing',\r\n            axis: \"y\",\r\n            opacity: 0.0,\r\n            distance: 5,\r\n            containment: 'parent',\r\n            // helper: 'clone'\r\n        };\r\n        ($(htmlref.current) as GObject<'JQuery + ui plugin'>).draggable(draggableOptions);\r\n    }, [htmlref.current]);\r\n\r\n    if (!node) return null;\r\n\r\n    const minimize = (ref: any) => {\r\n        //ref.current.style.opacity = 0;\r\n\r\n        // ref.current.style.visibility = 'hidden';\r\n        // ref.current.style.display = 'none';\r\n        setCollapsed(true);\r\n    }\r\n    const maximize = (ref: any) => {\r\n        //ref.current.style.opacity = 1;\r\n        setCollapsed(false);\r\n    }\r\n    let toolbarContent = null;\r\n    if (!collapsed) {\r\n\r\n        const data: LModelElement | LModel = (node.model) ? node.model : LModel.fromPointer(props.model);\r\n\r\n        const isMetamodel: boolean = props.isMetamodel;\r\n        const metamodel: LModel | undefined = props.metamodel;\r\n        const downward: Dictionary<DocString<\"DClassName\">, DocString<\"hisChildren\">[]> = {}\r\n        const addChildren = (items: string[]) => items ? getItems(data, downward, [...new Set(items)], node) : [];\r\n\r\n        // downward[\"DModel\"] = [\"DPackage\"];\r\n        // downward[\"DModel\"] = [\"DPackage\"];\r\n\r\n        downward[\"DPackage\"] = [\"DPackage\", \"DClass\", \"DEnumerator\"];\r\n        downward[\"DClass\"] = [\"DAttribute\", \"DReference\", \"DOperation\"];\r\n        downward[\"DEnumerator\"] = [\"DLiteral\"];\r\n        downward[\"DOperation\"] = [\"DParameter\", \"DException\"];\r\n\r\n\r\n        // nodes\r\n        downward[\"DEdge\"] = [\"DEdgePoint\"]\r\n        downward[\"DVoidEdge\"] = [\"DEdgePoint\"]\r\n\r\n        // for (let parentKey in downward) myDictValidator.set(parentKey, addChildren(\"package\"));\r\n\r\n        let upward: Dictionary<DocString<\"DClassName (model)\">, DocString<\"hisDParents\">[]> = {};\r\n        for (let parentKey in downward) {\r\n            let vals = downward[parentKey];\r\n            if (!vals) continue;\r\n            for (let child of vals) {\r\n                if (!upward[child]) upward[child] = [];\r\n                upward[child].push(parentKey)\r\n                upward[child].push(...(downward[parentKey] || []));\r\n            }\r\n        }\r\n        downward[\"DModel\"] = downward[\"DPackage\"];\r\n\r\n        // exceptions:\r\n        upward[\"DPackage\"] = [\"_pDPackage\"]; //, \"DModel\"]; because from a package, i don't want to prompt the user to create a model in toolbar.\r\n        upward[\"DEdgePoint\"] = [\"DEdgePoint\"]; //, \"DEdge\", \"DVoidEdge\"]; because from a edgeNode, i don't want to prompt the user to create a edge in toolbar.\r\n        // upward[\"DClass\"] = [\"_pDPackage\", \"DClass\", \"DEnumerator\"];\r\n\r\n        let content: ReactNode;\r\n        // if (RuntimeAccessibleClass.extends(props.selected?.node?.className, DVoidEdge)) { }\r\n        let contentarr: ReactNode[][] = [];\r\n        if (isMetamodel) {\r\n            let siblings = data ? addChildren(upward[data.className]) : [];\r\n            if (node) siblings.push(...addChildren(upward[node.className]));\r\n            let subelements = data ? addChildren(downward[data.className]) : [];\r\n\r\n\r\n            if (siblings.length > 0) {\r\n                contentarr.push([<span className={'toolbar-section-label'} key={'str'}>Structure</span>,\r\n                    <hr className={'my-1'} key={'h_str'}/>, siblings]);\r\n            }\r\n            if (subelements.length > 0) {\r\n                contentarr.push([<span className={'toolbar-section-label'} key={'ftr'}>Features</span>,\r\n                    <hr className={'my-1'} key={'h_ftr'}/>, subelements]);\r\n            }\r\n\r\n        } else {\r\n            const classes = metamodel?.classes;\r\n            const model: LModel = LModel.fromPointer(props.model);\r\n            const lobj: LObject | undefined = data.className === \"DObject\" ? data as LObject : undefined;\r\n            const lfeat: LValue | undefined = data.className === \"DValue\" ? data as LValue : undefined;\r\n\r\n            let subleveloptions = [];\r\n            if (lobj && (!lobj.instanceof || lobj.partial)) subleveloptions.push( //@ts-ignore\r\n                <div key={\"Feature\"} className={\"toolbar-item feature\"} tabIndex={ti} onClick={() => {\r\n                    lobj.addValue();\r\n                }}>+Feature</div>\r\n            );\r\n            if (lfeat && lfeat.values.length < lfeat.upperBound) subleveloptions.push( //@ts-ignore\r\n                <div key={\"Value\"} className={\"toolbar-item value\"} tabIndex={ti} onClick={() => {\r\n                    SetFieldAction.new(lfeat.id, 'value' as any, undefined, '+=', false);\r\n                    alert(280);\r\n                }}>\r\n                    <ModellingIcon name={'value'}/>\r\n                    <span className={'ms-1 my-auto text-capitalize'}>value</span>\r\n                    {/*@ts-ignore*/}\r\n                </div>\r\n            );\r\n            if (node) subleveloptions.push(...addChildren(downward[node.className]));\r\n            let rootobjs = classes?.filter((lClass) => lClass.rootable).map((lClass, index) => {\r\n                let dclass = lClass.__raw;\r\n                return ( //@ts-ignore\r\n                    <div key={\"LObject_\" + dclass.id}\r\n                          onMouseEnter={() => SetRootFieldAction.new('tooltip', lClass.annotations.map(a => a.source).join(' '))}\r\n                          onMouseLeave={() => SetRootFieldAction.new('tooltip', '')}\r\n                          className={\"toolbar-item LObject\"} tabIndex={ti}\r\n                          onClick={() => select(model.addObject({}, lClass))}>\r\n                        {dclass._state.icon ? <ModellingIcon src={dclass._state.icon}/> : <ModellingIcon name={'object'}/>}\r\n                        <span className={'ms-1 my-auto text-capitalize'}>{U.stringMiddleCut(dclass.name, 14)}</span>\r\n                        {/*@ts-ignore*/}\r\n                    </div>)\r\n            }) || [];\r\n\r\n            // @ts-ignore TS2339\r\n            //\r\n            rootobjs.push(<>\r\n                <hr className={'my-1 toolbar-hr'} key={'h_robj'}/>\r\n                {/*@ts-ignore*/}\r\n                <divd key={\"RawObject\"} className={'toolbar-item'} tabIndex={ti}\r\n                      onClick={() => select(model.addObject({}, null))}>\r\n                    <ModellingIcon name={'object'}/>\r\n                    <span className={'ms-1 my-auto text-capitalize'}>Object</span>\r\n                    {/*@ts-ignore*/}\r\n                </divd>\r\n            </>);\r\n\r\n\r\n            if (rootobjs.length > 0) {\r\n                contentarr.push([<b key={'rlvl'} className={'toolbar-section-label'}\r\n                                    style={{marginRight: \"1.5em\"/*to avoid overlap with pin*/}}>Root level</b>, rootobjs]);\r\n            }\r\n            if (subleveloptions.length > 0) {\r\n                contentarr.push([<b key='slo' className={'toolbar-section-label'}>Sublevel</b>, subleveloptions]);\r\n            }\r\n        }\r\n\r\n\r\n        let shapes = node ? addChildren(downward[node.className]) : [];\r\n        if (shapes.length > 0) {\r\n            contentarr.push([<b key={'shape'} className={'toolbar-section-label'}>Shape</b>, shapes]);\r\n        }\r\n\r\n        let separator = <hr className={'my-1'}/> as any;\r\n\r\n        // @ts-ignore\r\n        // console.error('toolbar', {ct:[...contentarr], ctm:contentarr.map(e=>e?.key), carr:contentarr.separator(separator).flat().flat()})\r\n        // @ts-ignore\r\n        content = contentarr.separator(separator).flat().flat() as any;\r\n\r\n        toolbarContent = (\r\n            <div className=\"toolbar-draggable\"\r\n                 ref={htmlref}\r\n                 style={{\r\n                     border: 'none',\r\n                     top: '35px',\r\n                     position: \"absolute\",\r\n                     backgroundColor: 'red !important'\r\n                 }} // refuses to focus without event...\r\n                 onClick={(e) => {\r\n                     console.log(\"click focus\", {htmlref});\r\n                     setTimeout(() => {\r\n                         if (htmlref.current) (htmlref.current as any).children[0].focus();\r\n                     }, 1)\r\n                 }}>\r\n                <div className={\"toolbar hoverable\" + (pinned ? \" pinned\" : '')} tabIndex={0}>\r\n                    <i style={{marginTop: '8px'}} className={\"content pin bi bi-x-lg\"} onClick={() => minimize(htmlref)}/>\r\n                    <section className={\"content inline w-100\"}>\r\n                        {content}\r\n                    </section>\r\n                </div>\r\n            </div>);\r\n    }\r\n    return (<>\r\n        {toolbarContent}\r\n        {collapsed ?\r\n            <div className=\"toolbar-collapsed\" onClick={() => maximize(htmlref)}></div>\r\n            :\r\n            <div className=\"toolbar-collapsed\" onClick={() => minimize(htmlref)}></div>\r\n        }\r\n    </>);\r\n}\r\n\r\ninterface OwnProps {\r\n    model: Pointer<DModel, 1, 1, LModel>;\r\n    isMetamodel: boolean;\r\n    metamodelId?: Pointer<DModelElement, 1, 1, LModelElement>;\r\n}\r\n\r\ninterface StateProps {\r\n    node: LGraphElement | null;\r\n    metamodel?: LModel;\r\n}\r\n\r\ninterface DispatchProps {\r\n}\r\n\r\ntype AllProps = OwnProps & StateProps & DispatchProps;\r\n\r\n//* 23/11 versione giordano\r\nfunction mapStateToProps(state: DState, ownProps: OwnProps): StateProps {\r\n    const ret: StateProps = {} as any;\r\n    const nodeid = state._lastSelected?.node;\r\n    if (nodeid) ret.node = LGraphElement.fromPointer(nodeid);\r\n    else ret.node = null;\r\n    if (ownProps.metamodelId) {\r\n        ret.metamodel = LModel.fromPointer(ownProps.metamodelId);\r\n    }\r\n    return ret;\r\n}\r\n\r\nfunction mapDispatchToProps(dispatch: Dispatch<any>): DispatchProps {\r\n    const ret: DispatchProps = {} as any;\r\n    return ret;\r\n}\r\n\r\n\r\nexport const ToolBarConnected = connect<StateProps, DispatchProps, OwnProps, DState>(\r\n    mapStateToProps,\r\n    mapDispatchToProps\r\n)(ToolBarComponent);\r\n\r\nexport const ToolBar = (props: OwnProps, children: (string | React.Component)[] = []): ReactElement => {\r\n    return <ToolBarConnected {...{...props, children}} />;\r\n}\r\nexport default ToolBar;\r\n\r\n\r\n\r\n\r\n","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\editors\\languages\\Javascript.tsx",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\editors\\index.ts",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\editors\\Empty.tsx",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\dock\\MyDock.tsx",["1002","1003","1004","1005","1006","1007"],"import JqxDockingLayout, {IDockingLayoutProps} from \"jqwidgets-scripts/jqwidgets-react-tsx/jqxdockinglayout\";\r\nimport React, {PureComponent, ReactElement, ReactNode} from \"react\";\r\nimport ReactDOM from \"react-dom\";\r\n/*import \"./jqx.base.css\"\r\nimport \"./jqx.darkblue.css\"*/\r\nimport \"./jqx.custom-styling.scss\"\r\nimport \"./smartdock.custom-styling.scss\"\r\nimport 'jqwidgets-scripts/jqwidgets/styles/jqx.base.css';\r\nimport 'jqwidgets-scripts/jqwidgets/styles/jqx.material-purple.css';\r\nimport $ from \"jquery\";\r\nimport {Dictionary, DocString, GObject, Log} from \"../../joiner\";\r\nimport { DockingLayout } from 'smart-webcomponents-react/dockinglayout';\r\n\r\nimport {DockLayout, LayoutData} from 'rc-dock';\r\nimport { Slider } from 'smart-webcomponents-react/slider';\r\nimport { MultilineTextBox } from 'smart-webcomponents-react/multilinetextbox';\r\nclass PortalOwnProps{\r\n    children!: ReactNode;\r\n    container!: string | Element;\r\n}\r\n\r\nexport class MyPortal extends React.Component<PortalOwnProps> {\r\n    container: Element | null = null;\r\n    maxRetries: number = 10;\r\n    retries: number = 0;\r\n\r\n    constructor(props: PortalOwnProps) {\r\n        super(props);\r\n    }\r\n\r\n    render() {\r\n        if (!this.container) {\r\n            if (!this.props.container) return <div>Error: Portal container is {this.props.container}</div>;\r\n            if (typeof this.props.container === 'object') this.container = this.props.container; else\r\n            if (typeof this.props.container === 'string') this.container = document.querySelector(this.props.container);\r\n        }\r\n        if (!this.container) {\r\n            if (this.retries++ < this.maxRetries) this.forceUpdate();\r\n            console.log('MyPortal retry getting container', {thiss: this, props: this.props});\r\n            return this.props.children;\r\n        }\r\n        this.retries = 0;\r\n        return ReactDOM.createPortal(this.props.children, this.container);\r\n    }\r\n}\r\nconst defaultLayout = [{\r\n    type: 'LayoutGroup',\r\n    orientation: 'horizontal',\r\n    items: [{\r\n        type: 'LayoutGroup',\r\n        items: [{\r\n            type: 'LayoutPanel',\r\n            id: 'tabPanel',\r\n            label: 'Input',\r\n            items: [{\r\n                id: 'tab1',\r\n                label: 'first TextBox Tab',\r\n                content: '<div class=\"tab-root\" idata-d=\"do not use those content at all. the whole content is lost when you save state\"><div>firstcontainer content</div></div>'\r\n            },\r\n                {\r\n                    id: 'tabslider',\r\n                    label: 'Slider Tab',\r\n                    content: '<div style=\"padding:10px;\" id=\"secondContainer\"></div>'\r\n                }\r\n            ]\r\n        },\r\n            {\r\n                type: 'LayoutPanel',\r\n                label: 'Output',\r\n                items: [{\r\n                    id: 'outputTab',\r\n                    label: 'Output',\r\n                    headerPosition: 'none',\r\n                    content: 'Write more text here ...'\r\n                }]\r\n            }\r\n        ],\r\n        orientation: 'vertical'\r\n    },\r\n        {\r\n            id: 'item0',\r\n            label: 'Tabs 0',\r\n            items: [{\r\n                id: 'tab A',\r\n                label: 'Tab A',\r\n                selected: true,\r\n                content: 'What is Lorem Ipsum?\\n' +\r\n                    'Lorem Ipsum is simply dummy text of the printing and typesetting industry. Lorem Ipsum has been the industry\\'s standard dummy text ever since the 1500s, when an unknown printer took a galley of' + 'type and scrambled it to make a type specimen book. It has survived not only five centuries, but also the leap into electronic typesetting, remaining essentially unchanged. It was popularised in ' + 'the 1960s with the release of Letraset sheets containing Lorem Ipsum passages, and more recently with desktop publishing software like Aldus PageMaker including versions of Lorem Ipsum.\\n' +\r\n                    'Why do we use it?\\n' +\r\n                    'It is a long established fact that a reader will be distracted by the readable content of a page when looking at its layout. The point of using Lorem Ipsum is that it has a more-or-less normal ' + 'distribution of letters, as opposed to using \\'Content here, content here\\', making it look like readable English. Many desktop publishing packages and web page editors now use Lorem Ipsum as their' + 'default model text, and a search for \\'lorem ipsum\\' will uncover many web sites still in their infancy. Various versions have evolved over the years, sometimes by accident, sometimes on ' + 'purpose (injected humour and the like).'\r\n            }]\r\n        }\r\n    ]\r\n}];\r\n\r\nexport class SmartDock extends React.Component {\r\n    public layout: GObject;\r\n    constructor(props: any) {\r\n        super(props);\r\n        let layoutstr = localStorage.getItem('smartDockingLayoutdocking-smart-1');\r\n        let layout: GObject | null = layoutstr ? JSON.parse(layoutstr) : null;\r\n        if (!layout) {\r\n            layout = defaultLayout;\r\n        }\r\n        this.layout = layout;\r\n    }\r\n\r\n    private html: HTMLElement | null = null;\r\n    private dock: DockingLayout | null = null;\r\n    // componentDidMount() { this.afterUpdate(); }\r\n    dockReady() { this.afterUpdate(); }\r\n    componentDidUpdate(prevProps: Readonly<{}>, prevState: Readonly<{}>, snapshot?: any) { this.afterUpdate(); }\r\n\r\n    saveHtmlMap: Dictionary<DocString<'id'>, NodeListOf<ChildNode>> = {}\r\n    beforeUpdate(){\r\n        if (!this.html) return;\r\n        let $tabs = $(this.html).find('smart-tab-item.smart-element.smart-tab-item');\r\n        let tab: HTMLElement;\r\n        for (tab of $tabs){\r\n            if (!tab.id) { Log.eDevv('tabs must have id\\'s', {tab}); }\r\n            this.saveHtmlMap[tab.id] = tab.childNodes;\r\n        }\r\n    }\r\n    afterUpdate(){\r\n        if ((this.dock as any).items.length === 0) {\r\n            this.layout = defaultLayout;\r\n            this.forceUpdate();\r\n            // dock failed to load from localStorage, i'm forcing rerender.\r\n        }\r\n        (window as any).debugAfterUpdate = () => {\r\n            this.forceUpdate();\r\n        }\r\n        if (window) return; // weirdly it works also without this?\r\n        // ReactDOM.render(<MultilineTextBox />, document.querySelector(\"#firstContainer\"));\r\n        //ReactDOM.render(<Slider />, document.querySelector(\"#secondContainer\"));\r\n        if (!this.html) return;\r\n        // let $html = $(this.html);\r\n        let id: string;\r\n        for (id in this.saveHtmlMap){\r\n            let elem = document.getElementById(id);\r\n            if (!elem) { continue; }\r\n            for (let c of this.saveHtmlMap[id]) {\r\n                elem.append(c);\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    render() {\r\n        const random = Math.random();\r\n        let layout: GObject = this.layout;\r\n        let r = (random * 255).toFixed(0);\r\n        this.beforeUpdate();\r\n        return (\r\n            <div onMouseEnter={() => this.forceUpdate()} ref={e => this.html = e}>\r\n                <h1>{r}</h1>\r\n                <DockingLayout id={'docking-smart-1'} autoSaveState={true} autoLoadState={true}\r\n                               ref={(e)=> {\r\n                                   this.dock = e;\r\n                                   if (!this.dock) return;\r\n                                   // this.dock.loadState(layout);\r\n                               }}\r\n                               style={{backgroundColor: `rgb(${r}, ${r}, ${r})`}}\r\n                    onReady={() => this.dockReady()} layout={layout} draggable={true}>\r\n                </DockingLayout>\r\n                <MyPortal container={'#tab1'}>\r\n                    <div id={'tab1content'}>tab1 content!</div>\r\n                </MyPortal>\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\n/*\r\nhow to do custom pinned tabs:\r\n\r\nto show preview after is pinned:\r\nkeep a fake tab in a sidebar outside rc-dock. keep the rc-dock tab hidden in floating mode but anchored to the side of the pin.\r\nwhen hover on a sidebar title, set display: block on the hovering tab.\r\n\r\nto unpin: set display: block on the hovering tab and remove the sidebar fake tab\r\nto pin: set tab on float mode, position it near the pin fake sidebar, make a fake sidebar entry, then hide the float tab\r\n\r\nbonus: add pin buttons at the 4 edges near the current position of the 4\r\n .jqx-docking-layout-overlay-square.jqx-docking-layout-overlay-square-edge\r\n\r\n*/\r\nexport class JQDock extends React.PureComponent<{}, IDockingLayoutProps> {\r\n    constructor(props: {}) {\r\n        super(props);\r\n        const layout: IDockingLayoutProps['layout'] = [\r\n            {\r\n                items: [{\r\n                    alignment: 'left',\r\n                    items: [{\r\n                        contentContainer: 'ToolboxPanel',\r\n                        title: 'toolbox', //<b color={\"red\"}>Toolbox red</b>,\r\n                        type: 'layoutPanel'\r\n                    }, {\r\n                        contentContainer: 'HelpPanel',\r\n                        title: 'Help',\r\n                        type: 'layoutPanel'\r\n                    }],\r\n                    type: 'autoHideGroup',\r\n                    unpinnedWidth: 200,\r\n                    width: 80\r\n                },\r\n                    {\r\n                        items: [{\r\n                            height: 400,\r\n                            items: [{\r\n                                contentContainer: 'Document1Panel',\r\n                                title: 'Document 1',\r\n                                type: 'documentPanel',\r\n                            },\r\n                                {\r\n                                    contentContainer: 'Document2Panel',\r\n                                    title: 'Document 2',\r\n                                    type: 'documentPanel'\r\n                                }],\r\n                            minHeight: 200,\r\n                            type: 'documentGroup'\r\n                        },\r\n                            {\r\n                                height: 200,\r\n                                items: [{\r\n                                    contentContainer: 'ErrorListPanel',\r\n                                    title: 'Error List',\r\n                                    type: 'layoutPanel'\r\n                                }],\r\n                                pinnedHeight: 30,\r\n                                type: 'tabbedGroup'\r\n                            }],\r\n                        orientation: 'vertical',\r\n                        type: 'layoutGroup',\r\n                        width: 500\r\n                    },\r\n                    {\r\n                        items: [\r\n                            {\r\n                                contentContainer: 'SolutionExplorerPanel',\r\n                                initContent: () => {\r\n                                    // initialize a jqxTree inside the Solution Explorer Panel\r\n                                    const source = [{\r\n                                        expanded: true,\r\n                                        icon: './../images/earth.png',\r\n                                        items: [\r\n                                            {\r\n                                                expanded: true,\r\n                                                icon: './../images/folder.png',\r\n                                                items: [{\r\n                                                    icon: './../images/nav1.png',\r\n                                                    label: 'jqx.base.css'\r\n                                                },\r\n                                                    {\r\n                                                        icon: './../images/nav1.png',\r\n                                                        label: 'jqx.energyblue.css'\r\n                                                    }, {\r\n                                                        icon: './../images/nav1.png',\r\n                                                        label: 'jqx.orange.css'\r\n                                                    }],\r\n                                                label: 'css'\r\n                                            },\r\n                                            {\r\n                                                icon: './../images/folder.png',\r\n                                                items: [{\r\n                                                    icon: './../images/nav1.png',\r\n                                                    label: 'jqxcore.js'\r\n                                                },\r\n                                                    {\r\n                                                        icon: './../images/nav1.png',\r\n                                                        label: 'jqxdata.js'\r\n                                                    }, {\r\n                                                        icon: './../images/nav1.png',\r\n                                                        label: 'jqxgrid.js'\r\n                                                    }],\r\n                                                label: 'scripts',\r\n                                            },\r\n                                            {\r\n                                                icon: './../images/nav1.png',\r\n                                                label: 'index.htm'\r\n                                            }],\r\n                                        label: 'Project',\r\n                                    }];\r\n                                    ReactDOM.render(<div>tree?</div>, document.querySelector('#treeContainer'));\r\n                                },\r\n                                title: 'Solution Explorer',\r\n                                type: 'layoutPanel'\r\n                            },\r\n                            {\r\n                                contentContainer: 'PropertiesPanel',\r\n                                title: 'Properties',\r\n                                type: 'layoutPanel'\r\n                            }],\r\n                        minWidth: 200,\r\n                        type: 'tabbedGroup',\r\n                        width: 220\r\n                    }],\r\n                orientation: 'horizontal',\r\n                type: 'layoutGroup'\r\n            },\r\n            {\r\n                height: 300,\r\n                items: [{\r\n                    contentContainer: 'OutputPanel',\r\n                    selected: true,\r\n                    title: 'Output',\r\n                    type: 'layoutPanel'\r\n                }],\r\n                position: {\r\n                    x: 350,\r\n                    y: 250\r\n                },\r\n                type: 'floatGroup',\r\n                width: 500\r\n            }\r\n        ];\r\n        this.state = {\r\n            layout\r\n        }\r\n    }\r\n    public html: Element | null = null;\r\n    callbackReference(e: HTMLElement | null) {\r\n        this.html = e;\r\n        if (!e) return;\r\n        $(e).on('float', function (event: JQuery.Event & GObject) {\r\n            var floatedItem = event.args.item;\r\n            const $allfloats = $('.jqx-docking-layout-group-floating');\r\n            console.log(\"something is afloat\", {event, args:event.args, floatedItem, e, $allfloats});\r\n            // @ts-ignore\r\n            e.prepend(...($allfloats as any));\r\n\r\n        });\r\n    }\r\n    public render() {\r\n        return (\r\n            <div id={\"dock-roottt\"}  ref={(e)=> this.callbackReference(e)}>\r\n            <JqxDockingLayout width={500} height={300} layout={this.state.layout}>\r\n                {/* The panel content divs can have a flat structure */}\r\n                {/* autoHideGroup */}\r\n                <div data-container={'ToolboxPanel'}>\r\n                    List of tools\r\n                </div>\r\n                <div data-container={'HelpPanel'}>\r\n                    Help topics\r\n                </div>\r\n                {/* documentGroup */}\r\n                <div data-container={'Document1Panel'}>\r\n                    Document 1 content\r\n                </div>\r\n                <div data-container={'Document2Panel'}>\r\n                    Document 2 content\r\n                </div>\r\n                {/* bottom tabbedGroup */}\r\n                <div data-container={'ErrorListPanel'}>\r\n                    List of errors\r\n                </div>\r\n                {/* right tabbedGroup */}\r\n                <div data-container={'SolutionExplorerPanel'}>\r\n                    <div id=\"treeContainer\" style={{ border: 'none', width: '99%', height: '100%' }} />\r\n                </div>\r\n                <div data-container={'PropertiesPanel'}>\r\n                    List of properties\r\n                </div>\r\n                {/* floatGroup */}\r\n                <div data-container={'OutputPanel'}>\r\n                    <div style={{ fontFamily: 'Inter Tight' }}>\r\n                        <p>\r\n                            Themes installation complete.\r\n                        </p>\r\n                        <p>\r\n                            List of installed stylesheet files. Include at least one stylesheet Theme file and\r\n                            the images folder:\r\n                        </p>\r\n                        <ul>\r\n                            <li>\r\n                                styles/jqx.base.css: Stylesheet for the base Theme. The jqx.base.css file should\r\n                                be always included in your project.\r\n                            </li>\r\n                            <li>styles/jqx.arctic.css: Stylesheet for the Arctic Theme</li>\r\n                            <li>styles/jqx.web.css: Stylesheet for the Web Theme</li>\r\n                            <li>styles/jqx.bootstrap.css: Stylesheet for the Bootstrap Theme</li>\r\n                            <li>styles/jqx.classic.css: Stylesheet for the Classic Theme</li>\r\n                            <li>styles/jqx.darkblue.css: Stylesheet for the DarkBlue Theme</li>\r\n                            <li>styles/jqx.energyblue.css: Stylesheet for the EnergyBlue Theme</li>\r\n                            <li>styles/jqx.shinyblack.css: Stylesheet for the ShinyBlack Theme</li>\r\n                            <li>styles/jqx.office.css: Stylesheet for the Office Theme</li>\r\n                            <li>styles/jqx.metro.css: Stylesheet for the Metro Theme</li>\r\n                            <li>styles/jqx.metrodark.css: Stylesheet for the Metro Dark Theme</li>\r\n                            <li>styles/jqx.orange.css: Stylesheet for the Orange Theme</li>\r\n                            <li>styles/jqx.summer.css: Stylesheet for the Summer Theme</li>\r\n                            <li>styles/jqx.black.css: Stylesheet for the Black Theme</li>\r\n                            <li>styles/jqx.fresh.css: Stylesheet for the Fresh Theme</li>\r\n                            <li>styles/jqx.highcontrast.css: Stylesheet for the HighContrast Theme</li>\r\n                            <li>styles/jqx.blackberry.css: Stylesheet for the Blackberry Theme</li>\r\n                            <li>styles/jqx.android.css: Stylesheet for the Android Theme</li>\r\n                            <li>styles/jqx.mobile.css: Stylesheet for the Mobile Theme</li>\r\n                            <li>styles/jqx.windowsphone.css: Stylesheet for the Windows Phone Theme</li>\r\n                            <li>styles/jqx.ui-darkness.css: Stylesheet for the UI Darkness Theme</li>\r\n                            <li>styles/jqx.ui-lightness.css: Stylesheet for the UI Lightness Theme</li>\r\n                            <li>styles/jqx.ui-le-frog.css: Stylesheet for the UI Le Frog Theme</li>\r\n                            <li>styles/jqx.ui-overcast.css: Stylesheet for the UI Overcast Theme</li>\r\n                            <li>styles/jqx.ui-redmond.css: Stylesheet for the UI Redmond Theme</li>\r\n                            <li>styles/jqx.ui-smoothness.css: Stylesheet for the UI Smoothness Theme</li>\r\n                            <li>styles/jqx.ui-start.css: Stylesheet for the UI Start Theme</li>\r\n                            <li>styles/jqx.ui-sunny.css: Stylesheet for the UI Sunny Theme</li>\r\n                            <li>styles/images: contains images referenced in the stylesheet files</li>\r\n                        </ul>\r\n                    </div>\r\n                </div>\r\n            </JqxDockingLayout>\r\n            </div>\r\n        );\r\n    }\r\n}\r\nexport const MyDock = JQDock;\r\n// export class MyDock extends JQDock{}\r\n\r\n\r\n/*\r\n// @ts-ignore\r\nexport function MyDock(...a:any) {\r\n// @ts-ignore\r\n    return <igc-dockmanager id=\"dockManager\" onClick={()=>new IgcDockManager()}>\r\n        <div slot=\"content1\" className=\"dockManagerContent\">Content 1</div>\r\n        <div slot=\"content2\" className=\"dockManagerContent\">Content 2</div>\r\n        <div slot=\"content3\" className=\"dockManagerContent\">Content 3</div>\r\n        <div slot=\"content4\" className=\"dockManagerContent\">Content 4</div>\r\n        <div slot=\"content5\" className=\"dockManagerContent\">Content 5</div>\r\n        <div slot=\"content6\" className=\"dockManagerContent\">Content 6</div>\r\n        <div slot=\"content7\" className=\"dockManagerContent\">Content 7</div>\r\n        <div slot=\"content8\" className=\"dockManagerContent\">Content 8</div>\r\n        <div slot=\"content9\" className=\"dockManagerContent\">Content 9</div>\r\n        <div slot=\"content10\" className=\"dockManagerContent\">Content 10</div>\r\n        <div slot=\"content11\" className=\"dockManagerContent\">Content 11</div>\r\n        <div slot=\"content12\" className=\"dockManagerContent\">Content 12</div>\r\n        {/* @ts-ignore * /}\r\n    </igc-dockmanager>\r\n\r\n\r\n//    return <IgcDockManager {...a}></IgcDockManager>;\r\n}\r\n*/\r\n","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\forEndUser\\ModellingIcon.tsx",["1008"],"import React from 'react';\r\nimport EPackage from '../../static/icon/modelling/package.png';\r\nimport EClass from '../../static/icon/modelling/class.png';\r\nimport EAttribute from '../../static/icon/modelling/attribute.png';\r\nimport EReference from '../../static/icon/modelling/reference.png';\r\nimport EOperation from '../../static/icon/modelling/operation.png';\r\nimport EEnumerator from '../../static/icon/modelling/enumerator.png';\r\nimport ELiteral from '../../static/icon/modelling/literal.png';\r\nimport Utility from '../../static/img/utility.png';\r\n\r\ninterface Props {name?: string, className?: string, src?:string}\r\n\r\n/* function ModellingIcon(props: Props) {\r\n    const name = props.name;\r\n    const className = props.className ? props.className : '';\r\n    const pprops = {width:20, height:20, className:`my-auto ${className||''} ` + (name || '')}\r\n    if (props.src) return <img {...pprops} src={props.src} />;\r\n    switch (name) {\r\n        case 'package': return(<img {...pprops} src={EPackage} />);\r\n        case 'object':\r\n        case 'class':\r\n            return(<img {...pprops} src={EClass} />);\r\n        case 'reference': return(<img {...pprops} src={EReference} />);\r\n        case 'operation': return(<img {...pprops} src={EOperation} />);\r\n        case 'enumerator': return(<img {...pprops} src={EEnumerator} />);\r\n        case 'literal': return(<img {...pprops} src={ELiteral} />);\r\n        case 'value':\r\n        case 'attribute':\r\n            return(<img {...pprops} src={EAttribute} />);\r\n        default:\r\n            return(<img {...pprops} src={Utility} />);\r\n\r\n    }\r\n}*/\r\n\r\ntype IconProps = {\r\n    letter: string\r\n}\r\nfunction Icon(props: IconProps) {\r\n\r\n    return (\r\n        <label className={'element-icon'}>{props.letter}</label>\r\n    );\r\n\r\n};\r\n\r\nfunction ModellingIcon(props: Props) {\r\n    const name = props.name;\r\n    const className = props.className ? props.className : '';\r\n    const pprops = {width:20, height:20, className:`my-auto ${className||''} ` + (name || '')}\r\n    if (props.src) return <img {...pprops} src={props.src} />;\r\n    switch (name) {\r\n        case 'package': return(<Icon letter={'P'} />);\r\n        case 'object':\r\n        case 'class':\r\n            return(<Icon letter={'C'} />);\r\n        case 'reference': return(<Icon letter={'R'} />)\r\n        case 'operation': return(<Icon letter={'O'} />)\r\n        case 'enumerator': return(<Icon letter={'E'} />)\r\n        case 'literal': return(<Icon letter={'L'} />)\r\n        case 'value':\r\n        case 'attribute':\r\n            return(<Icon letter={'A'} />)\r\n        default:\r\n            return(<Icon letter={'U'} />)\r\n    }\r\n}\r\n\r\nexport default ModellingIcon;\r\n","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\model\\logicWrapper\\index.ts",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\editors\\Collaborative.tsx",["1009"],"import {Dispatch, ReactElement, useEffect, useState} from 'react';\r\nimport {connect} from 'react-redux';\r\nimport type {DState, LProject} from '../../joiner';\r\nimport {DUser, GObject, LUser, U} from '../../joiner';\r\nimport {FakeStateProps} from '../../joiner/types';\r\nimport {UsersApi} from \"../../api/persistance\";\r\nimport {Btn, CommandBar} from '../commandbar/CommandBar';\r\nimport {useEffectOnce} from \"usehooks-ts\";\r\n\r\nfunction CollaborativeComponent(props: AllProps) {\r\n    const {project, users} = props;\r\n    const [emails, setEmails] = useState<string[]>([]);\r\n    const [filteredEmails, setFilteredEmails] = useState<string[]>([]);\r\n    const [email, setEmail] = useState<string>('');\r\n\r\n    useEffectOnce(() => {\r\n        (async function() {\r\n            setEmails(await UsersApi.getAllEmails());\r\n        })();\r\n    });\r\n\r\n    useEffect(() => {\r\n        if(!email) setFilteredEmails([]);\r\n        else setFilteredEmails(emails.filter(e => e.startsWith(email)));\r\n    }, [email])\r\n\r\n    const addCollaborator = async(e: string) => {\r\n        const user = await UsersApi.getUserByEmail(e);\r\n        if(!user) {\r\n            U.alert('e', 'Cannot retrieve user data.', 'Something went wrong ...');\r\n            return;\r\n        }\r\n        if(!users.map(u => u.id).includes(user.id))\r\n            DUser.new(user.name, user.surname, user.nickname, user.affiliation, user.country, user.newsletter, user.email, '', user.id);\r\n        if(project.collaborators.map(c => c.id).includes(user.id)) return;\r\n        project.collaborators = [...project.collaborators, user];\r\n    }\r\n\r\n    return(<section className={'page-root collaborative-tab'}>\r\n        <h1 className={'view'}>Collaborative Modeling</h1>\r\n        <div className={'p-1 w-100  d-flex'} style={{borderRadius: 'var(--radius)'}}>\r\n            <h5><i className=\"bi bi-person-video3\"></i> Editor</h5>\r\n            <label className={'ms-auto'}>{project.author.nickname}</label>\r\n        </div>\r\n        {project.collaborators.length > 0 && <div className={'mt-2 p-1 w-100 border'} style={{borderRadius: 'var(--radius'}}>\r\n            <h5><i className=\"bi bi-person-video3\"></i> Collaborators</h5>\r\n            <div className={'ms-auto'}>\r\n                {project.collaborators.map((c, index) => {\r\n                    return(<label className={'ms-1'} key={index}>{c.surname}</label>);\r\n                })}\r\n            </div>\r\n        </div>}\r\n        <input placeholder={'contributor email'} className={'input w-25 float-end'} defaultValue={email} onChange={e => setEmail(e.target.value)} />\r\n        <div>\r\n            {filteredEmails.map(e => <div key={e}>\r\n                <CommandBar className={'float-end'} style={{marginLeft: '5px'}}>\r\n                    {e}\r\n                    <Btn icon={'add'} action={() => addCollaborator(e)} tip={'Invite contributor'} />\r\n                </CommandBar>\r\n            </div>)}\r\n        </div>\r\n        <div className={'alert'}>\r\n            <i className=\"bi bi-exclamation-circle\"></i>\r\n            Important: After sending the invitation, save the project!\r\n        </div>\r\n    </section>);\r\n}\r\ninterface OwnProps {}\r\ninterface StateProps {project: LProject, users: LUser[]}\r\ninterface DispatchProps {}\r\ntype AllProps = OwnProps & StateProps & DispatchProps;\r\n\r\n\r\nfunction mapStateToProps(state: DState, ownProps: OwnProps): StateProps {\r\n    const ret: StateProps = {} as FakeStateProps;\r\n    const user = LUser.fromPointer(DUser.current);\r\n    ret.project = user.project as LProject;\r\n    ret.users = LUser.fromPointer(state.users);\r\n    return ret;\r\n}\r\n\r\nfunction mapDispatchToProps(dispatch: Dispatch<any>): DispatchProps {\r\n    const ret: DispatchProps = {};\r\n    return ret;\r\n}\r\n\r\nexport const CollaborativeConnected = connect<StateProps, DispatchProps, OwnProps, DState>(\r\n    mapStateToProps,\r\n    mapDispatchToProps\r\n)(CollaborativeComponent);\r\n\r\nexport const Collaborative = (props: OwnProps, children: (string | React.Component)[] = []): ReactElement => {\r\n    return <CollaborativeConnected {...{...props, children}} />;\r\n}\r\n","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\editors\\views\\NestedView.tsx",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\editors\\MetaData.tsx",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\editors\\Info.tsx",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\editors\\Logger.tsx",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\editors\\Settings.tsx",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\editors\\Console.tsx",["1010","1011","1012","1013","1014","1015"],"import {\r\n    DEdge,\r\n    DGraphElement,\r\n    Dictionary,\r\n    DState,\r\n    GObject, Info,\r\n    LGraphElement,\r\n    LModelElement,\r\n    Log,\r\n    LPointerTargetable,\r\n    LViewElement,\r\n    Pointer,\r\n    RuntimeAccessibleClass,\r\n    transientProperties,\r\n    U,\r\n    windoww\r\n} from '../../joiner';\r\nimport {FakeStateProps} from '../../joiner/types';\r\nimport React, {Component, Dispatch, PureComponent, ReactElement, ReactNode} from 'react';\r\nimport {connect} from 'react-redux';\r\n\r\nimport './style.scss'; // <-- tenuto per retro-compatibilità ma dovrebbe sparire\r\nimport './editors.scss'; // <-- stile comune a tutte le tab editor (idealmente da tenere leggero)\r\nimport './console.scss'; // <-- stile di questa tab\r\nimport ReactDOM from \"react-dom\";\r\nimport {Empty} from \"./Empty\";\r\nimport {Tooltip} from \"../forEndUser/Tooltip\";\r\n\r\nconst Convert = require('ansi-to-html');\r\n\r\nlet ansiConvert = (window as any).ansiConvert;\r\nif (!ansiConvert) (window as any).ansiconvert = ansiConvert = new Convert();\r\n\r\nclass ThisState{\r\n    expression: string = '';\r\n    output: any = null;\r\n    expressionIndex: number = 0;\r\n    expressionHistory: string[] = [''];\r\n    initialState: boolean = true;\r\n    time: number = 0;\r\n}\r\n\r\n// trasformato in class component così puoi usare il this nella console. e non usa accidentalmente window come contesto\r\n\r\nlet hiddenkeys = [\"jsxString\", \"pointedBy\", \"clonedCounter\", \"parent\", \"_subMaps\", \"inspect\", \"__random\", '__serialize'];\r\nfunction fixproxy(output: any/*but not array*/, addDKeys: boolean = true, addLKeys: boolean = true):\r\n    { output: any, shortcuts?: GObject<'L singleton'>, comments?: Dictionary<string, string | {type:string, txt:string}>, hiddenkeys?: GObject} {\r\n\r\n    let ret: ReturnType<typeof fixproxy> = {output};\r\n    if (!output) return ret;\r\n\r\n    let proxy: LPointerTargetable | undefined;\r\n    if (output?.__isProxy) {\r\n        proxy = output;\r\n        output = output.__raw; //Object.fromEntries(Object.getOwnPropertyNames(p).map(k => [k, p[k]]));\r\n    } else proxy = undefined;\r\n\r\n    console.log('console short in 1', {output, proxy, ret, addLKeys, iff:addLKeys && proxy});\r\n\r\n    switch (typeof output) {\r\n        case \"function\": {\r\n            let fdata =  U.buildFunctionDocumentation(output);\r\n            return {output: fdata};\r\n        }\r\n        default: return ret;\r\n        case \"object\":\r\n            // if (Array.isArray(output)) { ret.output = output; break; /* no need to go inside, it is already done at render phase */ }\r\n            ret.output = output = {...output};\r\n            // if (ret.output.anchors) ret.output.anchors = JSON.stringify(ret.output.anchors);\r\n            if (addLKeys && proxy) {\r\n                let Lsingleton: GObject<'L singleton'> = (RuntimeAccessibleClass.get(output?.className)?.logic?.singleton) || {};\r\n                let comments: Dictionary<string, string | {type:string, txt:string}> = {};\r\n                ret.shortcuts = {...Lsingleton};\r\n                console.log('console short in 2', {output, rett:{...ret, shortt:{...(ret.shortcuts||{})}}, Lsingleton, DClass:RuntimeAccessibleClass.get(output?.className), LClass:RuntimeAccessibleClass.get(output?.className)?.logic});\r\n                ret.comments = comments;\r\n                for (let key in output) {\r\n                    if (Lsingleton[\"__info_of__\" + key]) comments[key] = Lsingleton[\"__info_of__\" + key];\r\n                }\r\n                for (let key in Lsingleton) {\r\n                    if ((key in output) || (key.indexOf(\"__info_of__\") === 0)) {\r\n                        delete ret.shortcuts[key];\r\n                        continue;\r\n                    } else { if (ret.shortcuts[key] === undefined) ret.shortcuts[key] = ''; }\r\n                    if (key.indexOf(\"info\") >=0 && key.indexOf(\"of\") >=0){\r\n                        Log.eDevv('Possible error on __info_of__ misnamed as '+key+', if the name was intentional' +\r\n                            ' and not an Info object add an allowal rule here.');\r\n                        continue;\r\n                    }\r\n                    if (Lsingleton[\"__info_of__\" + key]) comments[key] = Lsingleton[\"__info_of__\" + key];\r\n                    if (comments[key]) continue; // if explicitly commented, i will not attempt to generate documentation.\r\n                    let entryvalue = Lsingleton[key];\r\n                    switch (typeof entryvalue) {\r\n                        default:\r\n                        case \"object\":\r\n                            ret.shortcuts[key] = entryvalue;\r\n                            break;\r\n                        case \"function\":\r\n                            ret.shortcuts[key] = U.buildFunctionDocumentation(entryvalue);\r\n                            break;\r\n                    }\r\n                }\r\n                console.log('console short in 3', {ret});\r\n\r\n            }\r\n            if (hiddenkeys) {\r\n                ret.hiddenkeys = {};\r\n                for (let key of hiddenkeys) {\r\n                    ret.hiddenkeys[key] = output[key];\r\n                    delete output[key];\r\n                    if (ret.shortcuts) delete ret.shortcuts[key];\r\n                }\r\n            }\r\n            break;\r\n    }\r\n\r\n    //@ts-ignore\r\n    //ret ={...ret, shortcuts: undefined, comments: undefined, hiddenkeys: undefined};\r\n\r\n    return ret;\r\n}\r\n\r\n\r\nclass ConsoleComponent extends PureComponent<AllProps, ThisState>{\r\n    public static cname: string = \"ConsoleComponent\";\r\n    lastNode?: Pointer<DGraphElement>;\r\n    constructor(props: AllProps) {\r\n        super(props);\r\n        this.state = new ThisState();\r\n        this.change = this.change.bind(this);\r\n        this.change(undefined);\r\n    }\r\n    private _context: GObject = {};\r\n    change(evt?: React.ChangeEvent<HTMLTextAreaElement>) {\r\n        if (!this) return; // component being destroyed and remade after code hot update\r\n        let expression0: string = (evt ? evt.target.value : this.state.expression) || '';\r\n        let expression: string = expression0.trim();\r\n        let output;\r\n        // let context = {...this.props, props: this.props}; // makeEvalContext(this.props as any, {} as any);\r\n\r\n        let nid = this.props.node?.id;\r\n        let tn = transientProperties.node[nid as string];\r\n        if (nid && tn) {\r\n            // let component = GraphElementComponent.map[this.props.node.id];\r\n            this._context = {...tn.viewScores[tn.mainView.id].evalContext};\r\n            this._context.fromcomponent = true;\r\n        }\r\n        else {\r\n            this._context = {...this.props, props: this.props};\r\n        }\r\n        try {\r\n            // if (expression === 'this') expression = 'data'; // it does a mess by taking a L-singleton with all his __info_of__ stuff\r\n            if (expression === 'this') output = this._context;\r\n            else output = U.evalInContextAndScope(expression || '<span class=\"console-msg\">undefined</span>', this._context, this._context);\r\n        }\r\n        catch (e: any) {\r\n            console.error(\"console error\", e);\r\n            // output = '<span class=\"console-error\">Invalid Syntax!</span> <span class=\"console-error-msg\">' + e.toString() + '<span>' ; }\r\n            output = '<span class=\"console-error-msg\"><i class=\"bi bi-exclamation-square-fill\"></i><span>' + e.toString() + '</span></span>' ; }\r\n        this.setState({expression:expression0, output });\r\n    }\r\n\r\n    // textarea: HTMLTextAreaElement | null = null;\r\n    getClickableEntry(jsxComments: Dictionary<string, ReactNode>, strcomments: Dictionary<string, Info>, expression: string, k: string, arr?: any): JSX.Element{\r\n        let isReactNode = !!jsxComments[k];\r\n        let infoof_tooltip: string | ReactNode;\r\n        if (isReactNode){\r\n            infoof_tooltip = <span id={'console_output_comment_key_' + k} className='my-tooltip output-comment tooltip-msg'/>;//jsxComments[k];\r\n        } else {\r\n            let str = (strcomments[k]?.txt as string)||'';\r\n            if (str) infoof_tooltip = <div className=\"my-tooltip output-comment\" dangerouslySetInnerHTML={{__html:str}}/>;\r\n            else infoof_tooltip = null;\r\n        }\r\n        if (k === 'father') console.log('jsx comment', {k, infoof_tooltip, jsxComments:{...jsxComments}});\r\n        if (k === 'isM1') console.log('jsx comment', {k, infoof_tooltip, jsxComments:{...jsxComments}});\r\n        return <li key={k} onClick={()=> {\r\n            let isnum = !isNaN(+k);\r\n            let isregular: boolean = isnum ? true : /\\w/.test(k);\r\n            let append: string;\r\n            if (isnum) append = '['+k+']';\r\n            else if (isregular) append = '.'+k;\r\n            else append = '['+JSON.stringify(k)+']';\r\n            this.setState({expression: (expression ? expression + append : k)}/*, ()=> { this.change(); }*/);\r\n        }}>{k}{arr && arr[k] || null}{infoof_tooltip}</li>;\r\n    }\r\n\r\n    outputhtml: HTMLElement | null = null;\r\n    setState(s: GObject<Partial<ThisState>> | null, callback?: (...a:any) => any): void{\r\n        if (s){\r\n            if (s.initialState) {\r\n                delete s.initialState;\r\n                return super.setState(s as any);\r\n            }\r\n            let s0: GObject<ThisState> = {...s} as any;\r\n            let olds = this.state;\r\n            if (s0.expressionIndex !== undefined && s0.expressionIndex !== olds.expressionIndex) s.expression = olds.expressionHistory[s0.expressionIndex];\r\n            if (s0.expression && s0.expression !== olds.expression) {\r\n                let time = new Date().getTime();\r\n                let oldtime = olds.time;\r\n                Log.exDev(s0.expressionIndex !== undefined, 'cannot set both index and expression together');\r\n                let i = s.expressionIndex ?? olds.expressionIndex;\r\n                let slice: string[];\r\n                if (time - oldtime < 1000) {\r\n                    slice = olds.expressionHistory.slice(0, i);\r\n                }\r\n                else {\r\n                    slice = olds.expressionHistory.slice(0, i+1);\r\n                    s.expressionIndex = i + 1;\r\n                }\r\n                s.time = time;\r\n                s.expressionHistory = [...slice, s0.expression];\r\n                console.log('setstate', {olds: {...olds}, s, slice, i, s0});\r\n            }\r\n            if (s.expression !== olds.expression && !('output' in s)) {\r\n                let call0 = callback;\r\n                callback = () => { call0?.(); this.change(); }\r\n            }\r\n        }\r\n        super.setState(s as any, callback);\r\n    }\r\n    render(){\r\n        /*const [expression, setExpression] = useStateIfMounted('data');\r\n        const [output, setOutput] = useStateIfMounted('');*/\r\n\r\n        if (!this.props.node) return <Empty msg={\"Select a node.\"} />;\r\n        let postprocess: boolean = true;\r\n        let expression = this.state.expression.trim();\r\n        if (expression === 'this') expression = 'data';\r\n        const data = this.props.data;\r\n        if (this.lastNode !== this.props.node.id) this.change(); // force reevaluation if selected node changed\r\n        this.lastNode = this.props.node.id;\r\n\r\n        /*display history*/\r\n        let history = this.state.expressionHistory||[];\r\n        let hlen = history.length;\r\n        let hindex = this.state.expressionIndex;\r\n        const entries = 10;\r\n        let max = Math.floor(Math.min(hindex+entries/2, hlen));\r\n        let min = Math.floor(hindex + entries - Math.max((hlen-max), entries/2));\r\n        history = history.slice(min, max);\r\n        console.log('chistory', {min, max, oldh: this.state.expressionHistory, h: history, selected: history[entries/2]});\r\n\r\n\r\n        let outstr;\r\n        // try { outstr = U.circularStringify(this.state.output, (key, value)=> { return value.__isProxy ? value.name : value; }, \"\\t\", 1) }\r\n        // (window as any).inspect = util.inspect;\r\n        // (window as any).tmpp = this.state.output;\r\n        let ashtml: boolean\r\n        let output: any = this.state.output;\r\n        let shortcuts: GObject<'L singleton'> | undefined = undefined;\r\n        let comments: Dictionary<string, string | {type:string, txt:string}> | undefined = undefined;\r\n        let hidden: Dictionary<string, string> | undefined = undefined;\r\n        let jsxComments: Dictionary<string, JSX.Element[]> = {};\r\n        let shortcutsjsx: ReactNode = undefined;\r\n        try {\r\n            if (Array.isArray(output)){\r\n                comments = {\"separator\": '<span>Similar to <a href={\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/join\"}>Array.join(separator)</a>' +\r\n                        ', but supports array of JSX nodes and JSX as separator argument.</span>'};\r\n                shortcuts = {\"separator\": \"\"};\r\n                output = output.map(o => fixproxy(o).output);\r\n            }\r\n            else {\r\n                console.log('console short pre', {output});\r\n                let ret = fixproxy(output);\r\n                output = ret.output;\r\n                comments = ret.comments;\r\n                shortcuts = ret.shortcuts;\r\n                console.log('console short', {shortcuts, ret, output});\r\n                hidden = ret.hiddenkeys;\r\n            }\r\n            // todo: as i fix the displaying of a LViewElement without replacing it with __raw,\r\n            //  i will fix window, component and props displaying too i think they crash for props.data, props.view...\r\n            if (output?._reactInternals) {\r\n                output = {\"React.Component\": {props:\"...navigate to expand...\", state:\"\", _isMounted:output._isMounted}}\r\n            }\r\n            outstr = '<h4>Result</h4><section class=\"group result-container\"><div class=\"output-row\" tabindex=\"984\">' + U.objectInspect(output)+\"<span>\";\r\n            let commentsPopup = \"\";\r\n            if (shortcuts || comments){\r\n                // if(!shortcuts) shortcuts = {};\r\n                if (!comments) comments = {};\r\n                for (let commentKey in comments){\r\n                    let commentVal: any = comments[commentKey];\r\n                    let txt = commentVal?.txt;\r\n                    if (txt && typeof txt !== \"string\") {// only for infoof that have txt = reactNode\r\n                        // try to inject jsx\r\n                        jsxComments[commentKey] = txt;\r\n                        txt = \"<span id='console_output_comment_\" + commentKey + \"'  class='tooltip-msg'/>\";\r\n                        // fallback read text, that should go deep iteration, but 1 level deep should be enough.\r\n                        // let arr: any[] = (Array.isArray(txt?.props?.children) ? txt.props.children : (txt.props.children ? [txt.props.children] : []));\r\n                        // txt = arr.map(e => typeof e === \"string\" ? e : e?.props?.children + '' || '').join(\"\");\r\n                    }\r\n                    if (commentVal?.type) commentVal = \"\\t\\t<span class='console-msg'>\" + (commentVal?.type?.cname || commentVal.type)+\"</span>\"; // + \" ~ \" + txt;\r\n                    // warning: unicode char but should not make a problem. 𐀹\r\n                    commentVal += '<div class=\"output-comment my-tooltip\">' + txt + '</div></div><div class=\"output-row\" tabindex=\"984\">'\r\n\r\n                    if (postprocess){\r\n                        let commentKeyEscaped = U.multiReplaceAll(commentKey, [\"$\", \"-\"], [\"\\\\$\", \"\\\\-\"]); // _ should be safe, .-,?^ not happening?\r\n\r\n                        let regexp = new RegExp(\"^({?\\\\s*\" +commentKeyEscaped+\":.*)$\", \"gm\");\r\n                        let regexpCloseTags = new RegExp(\"(\\\\<span style\\\\=\\\"color\\\\:\\\\#)\", \"gm\");\r\n                        outstr = U.replaceAll(outstr, \"$\", \"£\");\r\n                        outstr = outstr.replace(regexp, \"$1\" + commentVal);\r\n                        outstr = outstr.replace(regexpCloseTags,  \"</span>$1\");\r\n                        outstr = U.replaceAll(outstr, \"£\", \"$\");\r\n                    }\r\n                }\r\n\r\n\r\n                /*if (shortcuts) outstr += \"</div></section><br><br>\" +\r\n                    \"<h4>Shortcuts</h4><section class='group shortcuts-container'><div class=\\\"output-row\\\" tabindex=\\\"984\\\">\" + U.objectInspect(shortcuts)+\"</section>\";\r\n                */\r\n\r\n                // if (hidden) outstr +=\"</div><br><br><h4>Other less useful properties</h4><div class=\\\"output-row\\\" tabindex=\\\"984\\\">\" + format(hidden);\r\n                // warning: unicode char but should not make a problem.\r\n                // outstr = U.replaceAll( outstr, '𐀹,\\n', '],</span>\\n</div><div class=\"output-row\" tabindex=\"984\"><span style=\"color:#000\">');\r\n                windoww.outstr = outstr.substring(0, 500);\r\n                windoww.outstrr = outstr;\r\n                // [length]: <span style=\"color:#A50\">1<span style=\"color:#000\"> ]\r\n                if (postprocess){\r\n                    // let closetagsafely = '</span>';\r\n                    let closetagsafely = '</span></span></span></span></span></span></span></span></span></span>';\r\n\r\n                    outstr = U.replaceAll( outstr, '<span style=\"color:#000\">,\\n',\r\n                        closetagsafely+'\\n</div>' + '<div class=\"output-row\" tabindex=\"984\"><span class=\"console-msg\" style=\"color:#000\">');\r\n\r\n                    outstr = U.replaceAll( outstr, '<span style=\"color:#000\"> ],\\n',\r\n                        ']</span>\\n</div>' + '<div class=\"output-row\" tabindex=\"984\"><span class=\"console-msg\" style=\"color:#000\">');\r\n\r\n                    outstr = U.replaceAll( outstr, ': {},\\n',\r\n                        ': {}</span>\\n</div>' + '<div class=\"output-row\" tabindex=\"984\">');\r\n                    // let regexpFixArray = /,?\\s\\[length\\]:\\s<span style=\"color:#A50\">\\d<span style=\"color:#000\">\\s/gm;\r\n                    windoww.outp = outstr;\r\n                    // let regexpFixArray = /,?\\s\\[length\\]:\\s(<\\/span>)+<span style=\"color:#A50\">\\d(<\\/span>)+]/gm;\r\n                    let regexpFixArray = /,?\\s\\[length\\]:\\s(<\\/span>)+<span style=\"color:#A50\">\\d(<\\/span>)+(<span style=\"color:#000\">\\s){0,1}]/gm\r\n                    outstr = outstr.replaceAll(regexpFixArray, \"&nbsp;]</span>\");\r\n                    outstr = U.replaceAll( outstr, ': [&nbsp;]', ': []');\r\n\r\n                }\r\n                let postprocessold: boolean = false;\r\n                if (postprocessold){\r\n                    outstr = U.replaceAll( outstr, '<span style=\"color:#000\" class=\"console-msg\">,\\n',\r\n                        '</span><span style=\"color:#000\" class=\"console-msg\">,</span>\\n</div><div class=\"output-row\" tabindex=\"984\"><span class=\"console-msg\" style=\"color:#000\">');\r\n                    /*outstr = U.replaceAll( outstr, '<span style=\"color:#000\" class=\"console-msg\">,\\n',\r\n                        '</span><span style=\"color:#000\" class=\"console-msg\">,</span>\\n</div><div class=\"output-row\" tabindex=\"984\"><span class=\"console-msg\" style=\"color:#000\">');*/\r\n\r\n                    outstr = U.replaceAll( outstr, '],\\n', '],</span>\\n</div><div class=\"output-row\" tabindex=\"984\"><span class=\"console-msg\" style=\"color:#000\">');\r\n                    outstr = U.replaceAll( outstr, '},\\n', '},</span>\\n</div><div class=\"output-row\" tabindex=\"984\"><span class=\"console-msg\" style=\"color:#000\">');\r\n\r\n                }\r\n            }\r\n            ashtml = true; }\r\n        catch(e: any) {\r\n            console.error(e);\r\n            throw e;\r\n            outstr = \"[circular object]: \" + e.toString();\r\n            ashtml = false;\r\n        }\r\n        let contextkeysarr: (string)[];\r\n        let contextkeys: ReactNode = '';\r\n        if (this.state.expression.trim() === \"this\") contextkeys = \"Warning: \\\"this\\\" in the console is aliased to data instead of the whole context of a GraphElement component.\";\r\n\r\n        let objraw = this.state.output?.__raw || (typeof this.state.output === \"object\" ? this.state.output : \"[primitiveValue]\") || {};\r\n        if (this.state.expression.trim() === \"\") contextkeysarr = [\"data\", \"node\", \"view\", \"component\"];\r\n        else if (typeof objraw === \"string\") { contextkeysarr = Object.keys(String.prototype); }\r\n        else contextkeysarr = (Array.isArray(objraw) ?\r\n                [...(Object.keys(objraw) as any as number[]).filter(k => (k) <= 10).map(k=>k===10 ? '...' : ''+k), ...Object.keys(Array.prototype)]\r\n                : Object.getOwnPropertyNames(objraw)) || [];\r\n\r\n\r\n        let injectCommentJSX = () => {\r\n            try{ for (let key in jsxComments) {\r\n                if (hiddenkeys.includes(key)) continue;\r\n                let commentNode: HTMLElement | null = document.getElementById(\"console_output_comment_\"+key);\r\n                Log.eDev(!commentNode, \"failed to find comment placeholder\", {key, v:jsxComments[key], jsxComments});\r\n                if (commentNode) ReactDOM.render(jsxComments[key], commentNode);\r\n                // for shortcut or context keys, this can fail without warning as some shortcuts are missing\r\n                commentNode = document.getElementById(\"console_output_comment_key_\"+key);\r\n                if (commentNode) ReactDOM.render(jsxComments[key], commentNode);\r\n            } }\r\n            catch (e) { console.error(\"failed to inject console output comment:\", e)}\r\n        }\r\n        setTimeout(injectCommentJSX, 1)\r\n        this.setNativeConsoleVariables();\r\n        windoww.output = output;\r\n        const undo = ()=>{\r\n            let expressionIndex = Math.max(0, this.state.expressionIndex - 1);\r\n            if (expressionIndex === this.state.expressionIndex) return;\r\n            this.setState({ expressionIndex })\r\n        }\r\n        const redo = ()=>{\r\n            const expressionHistory = this.state.expressionHistory;\r\n            let expressionIndex = Math.min(expressionHistory.length-1, this.state.expressionIndex + 1);\r\n            if (expressionIndex === this.state.expressionIndex) return;\r\n            this.setState({ expressionIndex })\r\n        }\r\n        let canredo = this.state.expressionIndex < this.state.expressionHistory.length - 1;\r\n        let canundo = this.state.expressionIndex > 0;\r\n        let advanced = this.props.advanced;\r\n\r\n        contextkeys = <ul>{\r\n            contextkeysarr.sort().map(k=>this.getClickableEntry(jsxComments, comments||{} as any, expression, k))\r\n        }</ul>;\r\n\r\n        if (shortcuts) {\r\n            shortcutsjsx = <ul>{\r\n                Object.keys(shortcuts).sort().map(k=>this.getClickableEntry(jsxComments, comments||{} as any, expression, k, shortcuts))\r\n            }</ul>\r\n        }\r\n\r\n        return(<div className={'w-100 h-100 p-2 console'}>\r\n            <h1>\r\n                On {((data as GObject)?.name || \"model-less node (\" + this.props.node?.className + \")\") + \" - \" + this.props.node?.className}\r\n            </h1>\r\n            <div className='console-terminal p-0 mb-2 w-100'>\r\n                <div className='commands'>\r\n                    <i onClick={(e) => {\r\n                        this.setState({expression: '', expressionHistory:[''], expressionIndex:0})\r\n                    }} title={'Empty console'} className=\"bi bi-slash-circle\"/>\r\n                    <i onClick={(e) => {\r\n                        if (!this.state.expression.trim()) {\r\n                            return Tooltip.show('Nothing to copy', undefined, undefined, 2);\r\n                        }\r\n                        let s = this.outputhtml?.innerText || '';\r\n                        s = s.substring('Result'.length).trim();\r\n                        U.clipboardCopy(s, () => Tooltip.show('Content copied to clipboard', undefined, undefined, 2));\r\n                    }} title={'Copy in the clipboard'} className=\"bi bi-clipboard-plus\"/>\r\n                    {/* @ts-ignore */}\r\n                    <i onClick={redo} title={'redo'}\r\n                       className={\"redo bi bi-arrow-right-square\" + (canredo ? '' : \" disabled\")}/>\r\n                    {/* @ts-ignore */}\r\n                    <i onClick={undo} title={'undo'}\r\n                       className={\"undo bi bi-arrow-left-square\" + (canundo ? '' : \" disabled\")}/>\r\n                </div>\r\n                <textarea id={'console'} spellCheck={false} className={'p-0 input w-100'} onChange={this.change}\r\n                          value={this.state.expression}></textarea>\r\n            </div>\r\n            {advanced && history.length>1 && <div>Advanced query history (index = {this.state.expressionIndex})\r\n                {history.map((s, i) => i === 0 ? null : <>\r\n                    <div style={{\r\n                        border: '1px solid ' + (i === history.length/2) ? 'red' : 'gray',\r\n                        marginTop: '5px',\r\n                        height: '30px'\r\n                    }}>{(i) + ') ' + s}</div>\r\n                </>)}</div>}\r\n            {/*<label>Query {(this.state.expression)}</label>*/}\r\n            <hr className={'mt-1 mb-1'}/>\r\n            {this.state.expression && ashtml && <div className={\"console-output-container console-msg\"}\r\n                                                     ref={(e) => this.outputhtml = e}\r\n                                                     dangerouslySetInnerHTML={ashtml ? {__html: outstr as string} : undefined}/>}\r\n\r\n            {this.state.expression && !ashtml && <div className={\"console-output-container console-msg\"}\r\n                                                      ref={(e) => this.outputhtml = e}\r\n                                                      style={{whiteSpace: \"pre\"}}>{outstr}</div>}\r\n\r\n\r\n            {contextkeysarr.length && <section className={'group suggestion-keys context-keys-list'} style={{whiteSpace: \"pre\"}}>\r\n                    <label className={\"context-keys\"}>Context keys</label>\r\n                    {contextkeys}\r\n                </section>\r\n            }\r\n            {shortcutsjsx && <section className='group  suggestion-keys shortcuts-container'>\r\n                <label className={\"context-keys pt-0\"}>Shortcuts</label>\r\n                {shortcutsjsx}\r\n            </section>}\r\n        </div>)\r\n    }\r\n\r\n    private setNativeConsoleVariables(): void { // just fordebugging\r\n        let context = this._context;\r\n        windoww.context = context;\r\n        windoww.data = context.data;\r\n        windoww.node = context.node;\r\n        windoww.edge = context.edge;\r\n        windoww.output = this.state.output;\r\n        if (context.data?.model) windoww.model = context.data?.model;\r\n    }\r\n}\r\n\r\ninterface OwnProps {}\r\ninterface StateProps {\r\n    data: LModelElement|null;\r\n    node: LGraphElement|null;\r\n    view: LViewElement|null;\r\n    advanced: boolean;\r\n}\r\ninterface DispatchProps {}\r\n\r\ntype AllProps = OwnProps & StateProps & DispatchProps;\r\n\r\nfunction mapStateToProps(state: DState, ownProps: OwnProps): StateProps {\r\n    const ret: StateProps = {} as FakeStateProps;\r\n    const nodeid = state._lastSelected?.node;\r\n    const node: LGraphElement|null = (nodeid) ? LGraphElement.fromPointer(nodeid) : null;\r\n    ret.node = node;\r\n    ret.data = (node?.model) ? node.model : null;\r\n    ret.view = (node?.view) ? node.view : null;\r\n    ret.advanced = state.advanced;\r\n    return ret;\r\n}\r\n\r\nfunction mapDispatchToProps(dispatch: Dispatch<any>): DispatchProps {\r\n    const ret: DispatchProps = {} as any;\r\n    return ret;\r\n}\r\n\r\n\r\nexport const ConsoleConnected = connect<StateProps, DispatchProps, OwnProps, DState>(\r\n    mapStateToProps,\r\n    mapDispatchToProps\r\n)(ConsoleComponent);\r\n\r\nexport const Console = (props: OwnProps, children: (string | Component)[] = []): ReactElement => {\r\n    return <ConsoleConnected {...{...props, children}} />;\r\n}\r\nexport default Console;\r\n","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\editors\\Skeleton.tsx",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\api\\memorec\\index.ts",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\editors\\views\\ViewData.tsx",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\forEndUser\\Tree.tsx",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\editors\\views\\data\\ComponentsTab.tsx",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\editors\\views\\data\\PermissionViewpointTab.tsx",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\editors\\views\\data\\PermissionViewTab.tsx",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\editors\\views\\data\\PaletteData.tsx",["1016"],"/* Viewpoints > Style */\r\n\r\nimport React, {Dispatch, ReactElement, ReactNode, Ref, RefObject, SyntheticEvent, useState, useRef, useEffect} from 'react';\r\nimport {connect} from \"react-redux\";\r\nimport {useStateIfMounted} from \"use-state-if-mounted\";\r\nimport tinycolor, {Instance} from \"tinycolor2\";\r\nimport Editor from \"@monaco-editor/react\";\r\nimport DropDownButton from \"smart-webcomponents-react/dropdownbutton\";\r\nimport 'smart-webcomponents-react/source/styles/smart.default.css';\r\nimport type {Dictionary, GObject, Pointer,} from '../../../../joiner';\r\nimport {DState, DViewElement, EdgeHead, Input, Keystrokes, Log, LViewElement, U,} from '../../../../joiner';\r\nimport type {\r\n    NumberControl,\r\n    PaletteControl,\r\n    PaletteType,\r\n    PathControl,\r\n    StringControl\r\n} from '../../../../view/viewElement/view';\r\nimport {CSS_Units} from '../../../../view/viewElement/view';\r\nimport {Color} from '../../../forEndUser/Color';\r\n\r\nimport {Btn, CommandBar} from '../../../commandbar/CommandBar';\r\nimport {HRule} from '../../../widgets/Widgets';\r\n\r\n\r\nfunction makeNumericInput(prefix: string, number: NumberControl,\r\n                          setNumber: (e: React.FocusEvent<HTMLInputElement>, prefix: string) => void,\r\n                          setText: (e: React.FocusEvent<HTMLInputElement>, prefix: string) => void, readOnly: boolean) {\r\n    let min: number | undefined;\r\n    let max: number | undefined;\r\n    let step: number | undefined = undefined;\r\n    switch (number.unit) {\r\n        case '':\r\n        case 'px': min = 0; max = 300; break;\r\n        case 'pt': break; // 1pt = 1.33 px; 1px = 0.75pt\r\n        case 'cm':\r\n        case 'mm': min = 0; max = 200; break; // 1mm = 3.7px\r\n        case 'ch':\r\n        case 'ex':\r\n        case 'em':\r\n        case 'rem':\r\n        case 'in': // 1in = 96px\r\n        case 'pc': // 2px = 0.125 picas; 18.75pc = 300px\r\n        case 'fr': min=0; max=20; step = 0.5; break;\r\n        case \"%\": case \"vh\": case \"vw\": case \"vmax\": case \"vmin\":\r\n            min = 0;\r\n            max = 100;\r\n            break;\r\n    }\r\n    let roundedValue0 = Math.round(((number.value || 0) - (typeof step === \"number\" ? number.value % step : number.value % 0.1))*10000)/10000; // % works on decimals right.\r\n    let roundedValue = typeof step === \"number\" ? Math.round(((number.value || 0)  * (1/step))) * step : Math.round(number.value*100)/100; // % works on decimals right.\r\n    return <>\r\n        <input className={\"value\"} placeholder={\"value\"} type={\"range\"} disabled={readOnly}\r\n            key={\"s\"+number.value} defaultValue={number.value}\r\n            min={min}\r\n            max={max}\r\n            step={\"any\"}\r\n            onBlur={e => {setNumber(e as any, prefix)}}\r\n            onMouseUp={e => { setNumber(e as any, prefix); }} />\r\n        <input className={\"spinner\"} placeholder={\"value\"} type={\"number\"} disabled={readOnly}\r\n            key={roundedValue} defaultValue={roundedValue} data-dv={roundedValue} data-dv2={number.value}\r\n            step={step}\r\n            onBlur={e => {setNumber(e as any, prefix)}}\r\n            onKeyDown={e => {\r\n               if (e.key === Keystrokes.enter) setNumber(e as any, prefix);\r\n               if (e.key === Keystrokes.escape) (e.target as any).value = '' + number.value; }} />\r\n    </>\r\n}\r\n\r\n\r\n\r\n// delete button <button className=\"btn btn-danger ms-1\"><i className=\"p-1 bi bi-trash3-fill\"/></button>\r\nfunction PaletteDataComponent(props: AllProps) {\r\n    const view = props.view;\r\n    const readOnly = props.readonly;\r\n    let palette: Readonly<PaletteType> = {...view.palette};\r\n    let tmp: PaletteType = undefined as any;\r\n    const [css, setCss] = useStateIfMounted(view.css);\r\n\r\n    const [expand, setExpand] = useStateIfMounted(false);\r\n\r\n    const change = (value: string|undefined) => { if(value !== undefined) setCss(value); } // save in local state for frequent changes.\r\n    const blur = () => view.css = css; // confirm in redux state for final state\r\n\r\n    /* *** alfonso *** */\r\n\r\n\r\n    function useClickOutside(ref: any, onClickOutside: any) {\r\n        useEffect(() => {\r\n            function handleClickOutside(event: Event) {\r\n                if (ref.current && !ref.current.contains(event.target)) {\r\n                    onClickOutside();\r\n                }\r\n            }\r\n\r\n          // Bind\r\n\r\n          // @ts-ignore\r\n            document.addEventListener(\"mousedown\", handleClickOutside);\r\n          return () => {\r\n            // dispose\r\n            // @ts-ignore\r\n            document.removeEventListener(\"mousedown\", handleClickOutside);\r\n          };\r\n        }, [ref, onClickOutside]);\r\n    }\r\n\r\n    const AddPalette = () => {\r\n        const [open,setOpen] = useState(false);\r\n        const menuRef = useRef(null);\r\n\r\n        useClickOutside(menuRef, () => {\r\n            setOpen(false);\r\n        });\r\n\r\n\r\n        return (<>\r\n            {/* {open ?\r\n                <div className='palette-buttons'>\r\n                    <button onClick={()=>addControl('palette')} className='btn btn-success my-btn btn-color'>Add palette</button>\r\n                    <button onClick={()=> addControl('number')} className='btn btn-success my-btn btn-number'>Add number</button>\r\n                    <button onClick={()=>addControl('text')} className='btn btn-success my-btn btn-textual'>Add text</button>\r\n                    <button onClick={()=>addControl('path')}className='btn btn-success my-btn btn-path'>Add path</button>\r\n                </div>\r\n            :\r\n                <button onClick={() => setOpen(!open)} className='btn btn-success my-btn'>Add new</button>\r\n            }*/}\r\n\r\n            {!open ?\r\n                <div className={'add-palette-item'} onClick={() => {setOpen(true)}}>\r\n                    <i style={{color: 'white'}} className=\"bi bi-plus\"></i>\r\n                    <span>Add new</span>\r\n                </div>\r\n                :\r\n                <>\r\n                    <div className={'add-palette-item active'} onClick={() => {setOpen(false)}}>\r\n                        <i style={{color: 'white'}} className=\"bi bi-plus\"></i>\r\n                    </div>\r\n                    <button onClick={()=>addControl('palette')} className='btn btn-success my-btn btn-color'>Palette</button>\r\n                    <button onClick={()=> addControl('number')} className='btn btn-success my-btn btn-number'>Number</button>\r\n                    <button onClick={()=>addControl('text')} className='btn btn-success my-btn btn-textual'>Text</button>\r\n                    <button onClick={()=>addControl('path')}className='btn btn-success my-btn btn-path'>Path</button>\r\n\r\n                </>\r\n            }\r\n\r\n        </>);\r\n    };\r\n\r\n    /* *** */\r\n\r\n\r\n\r\n\r\n\r\n\r\n    const addControl = (type: 'palette' | 'number' | 'text' | 'path') => {\r\n        if (readOnly) return;\r\n        let i: number;\r\n        let prefix0: string;//= 'palette_' + i + '-';\r\n        switch (type){\r\n            default: Log.exDevv(\"unexpected case in addControl:\" + type); return;\r\n            case 'path':\r\n                i = Object.values(palette).filter( o => (o as PathControl).type === \"path\").length + 1;\r\n                prefix0 = 'path_';\r\n                break;\r\n            case 'text':\r\n                i = Object.values(palette).filter( o => (o as StringControl).type === \"text\").length + 1;\r\n                prefix0 = 'text_';\r\n                break;\r\n            case 'number':\r\n                i = Object.values(palette).filter( o => (o as NumberControl).type === \"number\").length + 1;\r\n                prefix0 = 'numeric_';\r\n                break;\r\n            case 'palette':\r\n                i = Object.values(palette).filter( o => Array.isArray(o as any)).length + 1;\r\n                prefix0 = 'palette_';\r\n                break;\r\n        }\r\n        let prefix: string;\r\n        while (true){\r\n            prefix = prefix0 + i++;\r\n            if (prefix in palette) continue;\r\n            break;\r\n        }\r\n        switch (type){\r\n            default: Log.exDevv(\"unexpected case in addControl:\" + type); return;\r\n            case 'path':\r\n                const agglabel = \"◇ Aggregation / Composition\";\r\n                const extendlabel = \"△ \"+EdgeHead.extend;\r\n                const asslabel = \"Λ \"+EdgeHead.reference;\r\n                let headdict: Dictionary<string, string> = {\r\n                    [asslabel]: 'M 0 0   L x y/2   L 0 y',\r\n                    [extendlabel]: 'M 0 0   L x y/2   L 0 y   Z',\r\n                    [agglabel]: 'M 0 y/2   L x/2 0   L x y/2   L x/2 y   Z',\r\n                };\r\n                let predefinedPaths: {k:string, v:string}[] = Object.entries(headdict).map((e)=>({k:e[0], v:e[1]}));\r\n\r\n                tmp = {...palette};\r\n                tmp[prefix] = {type: 'path', value: '', x:'edgeHeadSize.x', y:'edgeHeadSize.y', options: predefinedPaths};\r\n                break;\r\n            case 'text':\r\n                tmp = {...palette};\r\n                tmp[prefix] = {type: 'text', value: ''};\r\n                break;\r\n            case 'number':\r\n                tmp = {...palette};\r\n                tmp[prefix] = {type: 'number', value: 0, unit: 'px'};\r\n                break;\r\n            case 'palette':\r\n                tmp = {...palette};\r\n                tmp[prefix] = {type:'color', value:[]};\r\n                break;\r\n        }\r\n        view.palette = palette = tmp;\r\n    }\r\n\r\n\r\n\r\n\r\n    const setGeneric = (e: any, prefix: string, key: string) => {\r\n        const val: string = e.target.value;\r\n        if (readOnly || (palette[prefix] as any)[key] === val) return;\r\n        let tmp: Dictionary<string, StringControl> = {...palette} as any;\r\n        (tmp[prefix] as any)[key] = val;\r\n        view.palette = palette = tmp; }\r\n    const setText = (e: any, prefix: string) => {\r\n        const val: string = e.target.value;\r\n        if (readOnly || (palette[prefix] as StringControl).value === val) return;\r\n        let tmp: Dictionary<string, StringControl> = {...palette} as any;\r\n        tmp[prefix].value = val;\r\n        view.palette = palette = tmp; }\r\n    const setNumber = (e: any, prefix: string) => {\r\n        const val: number = +e.target.value || 0;\r\n        if (readOnly || (palette[prefix] as NumberControl).value === val) return;\r\n        let tmp: Dictionary<string, NumberControl> = {...palette} as any;\r\n        tmp[prefix].value = val;\r\n        view.palette = palette = tmp; }\r\n    const setUnit = (e: any, prefix: string) => {\r\n        const val: string = e.target.value === undefined ? 'px' : e.target.value;\r\n        if (readOnly || val === (palette[prefix] as NumberControl).unit) return;\r\n        let tmp: Dictionary<string, NumberControl> = {...palette} as any;\r\n        tmp[prefix].unit = val;\r\n        view.palette = palette = tmp; }\r\n    const changePrefix = (oldPrefix: string, newPrefix: string) => {\r\n        // @ts-ignore\r\n        newPrefix = newPrefix.replaceAll(/[^\\w\\-]/g,'-'); // /^[^a-zA-Z0-9_\\-]*$/, '-');\r\n        if (readOnly || palette[newPrefix]) return; // refuse to overwrite existing palette name (2 different palettes with same name)\r\n        tmp = {...palette};\r\n        tmp[newPrefix] = palette[oldPrefix];\r\n        delete tmp[oldPrefix];\r\n        view.palette = palette = tmp;\r\n    }\r\n    const removeControl = (prefix: string) => {\r\n        if (readOnly || !palette[prefix]) return;\r\n        tmp = {...palette};\r\n        delete tmp[prefix];\r\n        view.palette = palette = tmp;\r\n    }\r\n\r\n    const addColor = (prefix: string, colors: Instance[] | Instance, index: number = -1, skipFirst: boolean = true) => {\r\n        if (readOnly) return;\r\n        if (!Array.isArray(colors)) {\r\n            colors = [colors as Instance];\r\n            skipFirst = false;\r\n        }\r\n        let tmp: Dictionary<string, PaletteControl> = {...palette} as GObject;\r\n        let lastAdded: tinycolor.ColorFormats.RGBA = undefined as any;\r\n        for (let i = colors.length-1; i >= (skipFirst ? 1 : 0); i--) {\r\n            let color: Instance = colors[i];\r\n            let rgba = color.toRgb();\r\n            console.log(\"addingColor:\", {rgba, lastAdded, color});\r\n            if (rgba === lastAdded) continue;\r\n            lastAdded = rgba;\r\n            if (!tmp[prefix]) tmp[prefix] = {type:'color', value:[]};\r\n            else tmp[prefix] = {...tmp[prefix]};\r\n            tmp[prefix].value = [...tmp[prefix].value];\r\n            if (index >= 0) tmp[prefix].value.splice(index + 1, 0, rgba);\r\n            else tmp[prefix].value.push(rgba);\r\n        }\r\n        view.palette = palette = tmp;\r\n    }\r\n\r\n    const setColor = (prefix: string, index: number, hex?: string, alpha?: number) => {\r\n        let tmp: Dictionary<string, PaletteControl> = {...palette} as any;\r\n        if (readOnly || !tmp[prefix]) tmp[prefix] = {type:'color', value:[]};\r\n        else tmp[prefix] = {...tmp[prefix]};\r\n        let oldColor = tmp[prefix].value[index];\r\n        if (hex) {\r\n            let color = tinycolor(hex);\r\n            if (alpha !== undefined) color.setAlpha(alpha);\r\n            let rgba = color.toRgb();\r\n            if (oldColor && oldColor.a !== undefined) rgba.a = oldColor.a;\r\n            tmp[prefix].value[index] = oldColor = rgba;\r\n            view.palette = palette = tmp;\r\n        }\r\n        if (alpha !== undefined) tmp[prefix].value[index] = {...oldColor, a:alpha};\r\n    }\r\n    const transparencyColor = (prefix: string, index: number, color: tinycolor.Instance, alpha: number) => {\r\n        if (readOnly || !palette[prefix]) return;\r\n        let tmp: Dictionary<string, PaletteControl> = {...palette} as any;\r\n        if (!alpha && alpha !== 0) alpha = 1;\r\n        tmp[prefix] = {...tmp[prefix]};\r\n        tmp[prefix].value = [...tmp[prefix].value];\r\n        tmp[prefix].value[index] = {...tmp[prefix].value[index]};\r\n        tmp[prefix].value[index].a = alpha;\r\n        color.setAlpha(alpha);\r\n        console.log(\"set transparency\", {color, tinycolor, oldcolor: tmp[prefix].value[index]});\r\n        view.palette = palette = tmp;\r\n    }\r\n    const removeColor = (prefix: string, index: number) => {\r\n        if (readOnly || !palette[prefix]) return;\r\n\r\n        let tmp: Dictionary<string, PaletteControl> = {...palette} as any;\r\n        tmp[prefix].value = [...tmp[prefix].value];\r\n        tmp[prefix].value = tmp[prefix].value.filter((c, i) => i !== index);\r\n        view.palette = palette = tmp;\r\n    }\r\n\r\n    const cssIsGlobal = view.cssIsGlobal;\r\n    let a: DropDownButton;\r\n    let dropDownButton: RefObject<DropDownButton> = {current: null};\r\n    function addcss(color: Instance): GObject {\r\n        let ret: GObject = {};\r\n        ret.background = color.toRgbString();\r\n        // ret.opacity = color.getAlpha();\r\n        return ret;\r\n    }\r\n    function invert(color: Instance, transformGrays: number = 0.2): string {\r\n        transformGrays = transformGrays * 128;\r\n        let {r, g, b, a} = color.toRgb();\r\n        r = Math.abs(r-128) <= transformGrays ? (r >= 128 ? 0 : 255) : 255 - r;\r\n        g = Math.abs(g-128) <= transformGrays ? (g >= 128 ? 0 : 255) : 255 - g;\r\n        b = Math.abs(b-128) <= transformGrays ? (b >= 128 ? 0 : 255) : 255 - b;\r\n        if (a || a === 0) a = 255 - a;\r\n        return (tinycolor({r, g, b, a})).toRgbString();\r\n    }\r\n    function style(c: Instance): GObject{\r\n        return {backgroundColor: c.toRgbString(), color:invert(c)};\r\n    }\r\n\r\n    let palettes = U.paletteSplit(palette);\r\n    function palettewrap(prefix: string, node: ReactNode): ReactNode{\r\n        return (\r\n            <div className=\"palette-row-container\">\r\n                {/* <button className=\"btn btn-danger me-1\" onClick={()=>removeControl(prefix)} disabled={readOnly}><i className=\"p-1 bi bi-trash3-fill\"/></button>*/}\r\n\r\n                <input className={\"prefix\"}\r\n                    style={{maxHeight: 'var(--input-height)', borderRadius: 'var(--radius)'}}\r\n                    placeholder={\"variable name\"}\r\n                    defaultValue={prefix}\r\n                    onBlur={(e: any)=> changePrefix(prefix, e.target.value)}\r\n                    disabled={readOnly} />\r\n                {node}\r\n            </div>)\r\n    }\r\n    const vcss = view.css;\r\n\r\n    let colors = Object.keys(palettes.color).sort();\r\n    const lines = (Math.round(vcss.split(/\\r|\\r\\n|\\n/).length*1.8) < 5 ? 10 : Math.round(vcss.split(/\\r|\\r\\n|\\n/).length*1.8));\r\n\r\n    return(<section className={'p-3 style-tab'}>\r\n        <h1 className={'view'}>View: {props.view.name}</h1>\r\n        <div className={\"controls\"} style={{position:'relative', zIndex:2}}>\r\n\r\n            {colors.map((entry, index, entries)=>{\r\n                let prefix = entry;\r\n                let paletteobj: PaletteControl = palettes.color[prefix] as PaletteControl;\r\n                let colors: Instance[] = paletteobj.value.map(v=> tinycolor(v));\r\n                let suggestions = [tinycolor('#ffaaaa')]; // todo: compute according to current row \"colors\"\r\n                return palettewrap(prefix, <>\r\n                    <div className=\"palette-row\">\r\n\r\n                        <div className=\"color-container\" style={{maxHeight: 'var(--input-height)', borderRadius: 'var(--radius)'}}>{\r\n                            colors.map((color, i) => <Color key={prefix+i} readOnly={readOnly}\r\n                                                            data={view} field={'palette'} canDelete={!readOnly}\r\n                                                            getter={()=>colors[i].toHexString()} setter={(newVal) => { setColor(prefix, i, newVal) }}\r\n                                                            style ={{background: 'white'}}\r\n                                                            inputStyle ={{opacity: color.getAlpha()}}\r\n                                                            childrenn={\r\n                                                                <div className={\"content suggestions\"} tabIndex={-1} style={{backgroundColor: \"inherit\"}} onClick={(e) => {e.preventDefault(); e.stopPropagation();}}>\r\n                                                                    {(()=>{ return <>\r\n                                                                        <h6 title={\"Alter current color transparency\"}>Opacity</h6>\r\n\r\n                                                                        <input style={{width: \"auto\", marginLeft:\"1em\", marginRight:\"1em\"}}\r\n                                                                            type={\"range\"} min={0} max={1} step={\"any\"}\r\n                                                                            value={color.getAlpha()}\r\n                                                                            onChange={(e: any)=>{ transparencyColor(prefix, i, color, +e.target.value) }} />\r\n\r\n                                                                        {/* Add all colors */}\r\n                                                                        <h6 title={\"Add all the colors\"}>\r\n                                                                            <CommandBar style={{float: 'left', paddingRight: '8px'}}>\r\n                                                                                <Btn icon={'add'} size={'x-small'}  action={()=>addColor(prefix, color.analogous(7, 30/1.5), i)} theme={'dark'} tip={'Add all the colors'}/>\r\n                                                                            </CommandBar>\r\n                                                                            <span>Analogous</span>\r\n                                                                        </h6>\r\n\r\n                                                                        <div className={\"roww\"}>\r\n                                                                            {color.analogous(7, 30/1.5).map((c,ii) => ii===0?undefined:\r\n                                                                                <button style={style(c)}\r\n                                                                                    onClick={(e)=>{addColor(prefix, c, i)}}\r\n                                                                                    className=\"btn color-suggestion\">\r\n                                                                                        <i style={style(c)} className=\"bi bi-plus-lg\"></i>\r\n                                                                                </button>\r\n                                                                            )}\r\n                                                                        </div>{/*\r\n                                    <h6 onClick={()=>addColor(prefix, color.monochromatic(7), i)} title={\"Add all the colors\"}>Monochromatic</h6>\r\n                                    <div className={\"roww\"}>\r\n                                        {color.monochromatic(7).map((c,ii) => ii===0?undefined: <button style={style(c)}\r\n                                                                                                        onClick={(e)=>{addColor(prefix, c, i)}} className=\"btn color-suggestion\">+</button>)}\r\n                                    </div>{/*[6/12, 5/12, 4/12, 3/12, 2/12, 1/12]*/}\r\n\r\n                                                                        {/* Add all colors */}\r\n                                                                        <h6 title={\"Add all the colors\"}>\r\n                                                                            <CommandBar style={{\r\n                                                                                float: 'left',\r\n                                                                                paddingRight: '8px'\r\n                                                                            }}>\r\n                                                                                <Btn icon={'add'} size={'x-small'}\r\n                                                                                     tip={'Add all the colors'}\r\n                                                                                     theme={'dark'}\r\n                                                                                     action={() => addColor(prefix, [1 / 12, 2 / 12, 3 / 12, 4 / 12, 5 / 12, 6 / 12].map(n => color.clone().lighten(n * 100)), i, false)}/>\r\n                                                                            </CommandBar>\r\n                                                                            <span>Lighten</span>\r\n\r\n                                                                        </h6>\r\n\r\n                                                                        <div className={\"roww\"}>\r\n                                                                            {[1/12, 2/12, 3/12, 4/12, 5/12, 6/12].map(n=>color.clone().lighten(n*100))\r\n                                                                                .map((c,ii) => <button style={style(c)} className=\"btn color-suggestion\"\r\n                                                                                                       onClick={(e)=>{addColor(prefix, c, i)}}><i style={style(c)} className=\"bi bi-plus-lg\"></i></button>)}\r\n                                                                        </div>\r\n\r\n                                                                        {/* Add all colors */}\r\n                                                                        <h6 title={\"Add all the colors\"}>\r\n                                                                            <CommandBar style={{\r\n                                                                                float: 'left',\r\n                                                                                paddingRight: '8px'\r\n                                                                            }}>\r\n                                                                                <Btn icon={'add'} theme={'dark'}\r\n                                                                                     tip={'Add all the colors'}\r\n                                                                                     size={'x-small'}\r\n                                                                                     action={() => addColor(prefix, [6 / 12, 5 / 12, 4 / 12, 3 / 12, 2 / 12, 1 / 12].map(n => color.clone().darken(n * 100)), i, false)}/>\r\n                                                                            </CommandBar>\r\n                                                                            <span>Darken</span>\r\n                                                                        </h6>\r\n\r\n                                                                        <div className={\"roww\"}>\r\n                                                                            {[6/12, 5/12, 4/12, 3/12, 2/12, 1/12].reverse().map(n=>color.clone().darken(n*100))\r\n                                                                                .map((c,ii) => <button style={style(c)} className=\"btn color-suggestion\"\r\n                                                                                                       onClick={(e)=>{addColor(prefix, c, i)}}><i style={style(c)} className=\"bi bi-plus-lg\"></i></button>)}\r\n                                                                        </div>\r\n\r\n                                                                        {/* Add all colors */}\r\n                                                                        <h6 title={\"Add all the colors\"}>\r\n                                                                            <CommandBar style={{\r\n                                                                                float: 'left',\r\n                                                                                paddingRight: '8px'\r\n                                                                            }}>\r\n                                                                                <Btn icon={'add'}\r\n                                                                                     tip={'Add all the colors'}\r\n                                                                                     theme={'dark'} size={'x-small'}\r\n                                                                                     action={() => addColor(prefix, [color.complement(), tinycolor(invert(color))], i, false)}/>\r\n                                                                            </CommandBar>\r\n                                                                            <span>Complementary / Opposite</span>\r\n                                                                        </h6>\r\n\r\n                                                                        <div className={\"roww\"}>\r\n                                                                            <button style={style(color.complement())} className=\"btn color-suggestion\"\r\n                                                                                    onClick={(e)=>{addColor(prefix, color.complement(), i)}}><i style={style(color.complement())} className=\"bi bi-plus-lg\"></i></button>\r\n                                                                            <button style={style(color)} className=\"btn color-suggestion\"\r\n                                                                                    onClick={(e)=>{addColor(prefix, tinycolor(invert(color)), i)}}><i style={style(color)} className=\"bi bi-plus-lg\"></i></button>\r\n                                                                        </div>\r\n\r\n                                                                        {/* Add all colors */}\r\n                                                                        <h6 title={\"Add all the colors\"}>\r\n                                                                            <CommandBar style={{\r\n                                                                                float: 'left',\r\n                                                                                paddingRight: '8px'\r\n                                                                            }}>\r\n                                                                                <Btn icon={'add'}\r\n                                                                                     tip={'Add all the colors'}\r\n                                                                                     theme={'dark'} size={'x-small'}\r\n                                                                                     action={() => addColor(prefix, color.splitcomplement(), i)}/>\r\n                                                                            </CommandBar>\r\n                                                                            <span>Split Complementary</span>\r\n                                                                        </h6>\r\n\r\n                                                                        <div className={\"roww\"}>\r\n                                                                            {color.splitcomplement().map((c) => <button style={{...style(c)}} className=\"btn color-suggestion\"\r\n                                                                                                                        onClick={(e)=>{addColor(prefix, c, i)}}><i style={style(c)} className=\"bi bi-plus-lg\"></i></button>)}\r\n                                                                        </div>\r\n\r\n                                                                        <h6 title={\"Add all the colors\"}>\r\n                                                                            <CommandBar style={{\r\n                                                                                float: 'left',\r\n                                                                                paddingRight: '8px'\r\n                                                                            }}>\r\n                                                                                <Btn icon={'add'}\r\n                                                                                     tip={'Add all the colors'}\r\n                                                                                     theme={'dark'} size={'x-small'}\r\n                                                                                     action={() => addColor(prefix, color.triad(), i)}/>\r\n                                                                            </CommandBar>\r\n                                                                            <span>Triadic</span>\r\n                                                                        </h6>\r\n\r\n                                                                        <div className={\"roww\"}>\r\n                                                                            {color.triad().map ( (c) => <button style={{...style(c)}} className=\"btn color-suggestion\"\r\n                                                                                                                onClick={(e)=>{addColor(prefix, c, i)}}><i style={style(c)} className=\"bi bi-plus-lg\"></i></button>)}\r\n                                                                        </div>\r\n\r\n                                                                        {/* Add all colors */}\r\n                                                                        <h6 title={\"Add all the colors\"}>\r\n                                                                            <CommandBar style={{\r\n                                                                                float: 'left',\r\n                                                                                paddingRight: '8px'\r\n                                                                            }}>\r\n                                                                                <Btn icon={'add'}\r\n                                                                                     tip={'Add all the colors'}\r\n                                                                                     theme={'dark'} size={'x-small'}\r\n                                                                                     action={() => addColor(prefix, color.tetrad(), i)}/>\r\n                                                                            </CommandBar>\r\n                                                                            <span>Tetradic</span>\r\n                                                                        </h6>\r\n                                                                        <div className={\"roww\"}>\r\n                                                                            {color.tetrad().map ( (c) => <button style={{...style(c)}} className=\"btn color-suggestion\"\r\n                                                                                                                 onClick={(e)=>{addColor(prefix, c, i)}}><i style={style(c)} className=\"bi bi-plus-lg\"></i></button>)}\r\n                                                                        </div>\r\n                                                                    </>})()}\r\n\r\n\r\n                                                                    <button\r\n                                                                        className={'btn btn-danger content delete-color mt-2 jj-delete'}\r\n                                                                        onClick={()=>removeColor(prefix, i)}\r\n                                                                        disabled={readOnly}\r\n                                                                    >\r\n                                                                        <i className=\"bi p-1 bi-trash-fill\"/> Delete\r\n                                                                    </button>\r\n                                                                </div>\r\n                                                            }\r\n                            />)\r\n                        }\r\n                        </div>\r\n                        <div className=\"suggestion-container\">{\r\n                            suggestions.map((c, i) => <label className=\"p-1\">\r\n\r\n                                {/* Palette */}\r\n                                <CommandBar style={{float: 'right'}}>\r\n                                    <Btn icon={'add'} tip={'Add color to palette'} action={() => addColor(prefix, c)} />\r\n                                    <Btn icon={'delete'} tip={'Remove color from palette'} action={() => {\r\n                                        if (Array.isArray(palette[prefix].value) && (palette[prefix].value as any).length) {\r\n                                            removeColor(prefix, i)\r\n                                        } else {\r\n                                            removeControl(prefix);\r\n                                        }\r\n                                    }}\r\n                                    />\r\n                                </CommandBar>\r\n\r\n                                {/* <button className=\"btn color-suggestion\" style={style(c)} onClick={()=>{addColor(prefix, c)}} disabled={readOnly}>+</button>*/}\r\n                            </label>)\r\n                        }</div>\r\n                    </div>\r\n                </>); })\r\n            }\r\n            {Object.entries(palettes.path).map((entry, index, entries)=>{\r\n                    let prefix = entry[0];\r\n                    let path: PathControl = entry[1] as any;\r\n                    return palettewrap(prefix,\r\n                        <div className=\"palette-row path\" title={\"todo: proper tooltip.\\nedgeHeadSize is in the \\\"Options\\\" tab and determines the position of the head.\\nBasic math operators are allowed, but the minus and plus must have spaces around them or they will be traated as unary operators.\\nx and y are variables local to this path used to scale his shape.\"}>\r\n                            <div className={\"value hoverable\"} >\r\n                                <div className={\"d-flex w-100\"}>\r\n                                    <input className={\"value w-100 my-auto\"} placeholder={\"svg path [d]\"} defaultValue={path.value} key={path.value} onBlur={e => {setText(e as any, prefix)}} disabled={readOnly}\r\n                                           onKeyDown={e => {\r\n                                               if (e.key === Keystrokes.enter) setText(e as any, prefix);\r\n                                               if (e.key === Keystrokes.escape) (e.target as any).value = path.value; }}\r\n                                    />\r\n                                </div>\r\n                                <div className={\"content d-flex w-100\"} style={{position: 'relative', backgroundColor: 'whitesmoke'}}>\r\n                                    <input className={\"spacer w-100\"}/>\r\n                                    <label className={\"mx-auto\"}>x:&nbsp;<input className=\"x\" placeholder={\"x\"} defaultValue={path.x} disabled={readOnly} onChange={(e)=>setGeneric(e, prefix, \"x\")}/></label>\r\n                                    <label className={\"mx-auto\"}>y:&nbsp;<input className=\"y\" placeholder={\"y\"} defaultValue={path.y} disabled={readOnly} onChange={(e)=>setGeneric(e, prefix, \"y\")}/></label>\r\n                                </div>\r\n                            </div>\r\n                            <select className={'d-flex'} style={{width: '100px!important'}} value={path.value} disabled={readOnly} onChange={(e)=>setText(e as any, prefix)}>\r\n                                {[<option style={{fontStyle:'italic', color:'gray'}} value={\"\"}>Custom</option>, path.options.map((e)=>{\r\n                                let k = e.k;\r\n                                let v = e.v;\r\n                                return <option value={v}>{k}</option>\r\n                            })]}</select>\r\n\r\n                            {/* Path */}\r\n                            <CommandBar  style={{paddingRight: '4px', marginLeft: 'auto'}}>\r\n                                <Btn icon={'space'} />\r\n                                <Btn icon={\"delete\"} action={(e) => {removeControl(prefix)}} tip={'Remove path'}/>\r\n                            </CommandBar>\r\n\r\n                        </div>)\r\n                }\r\n            )}\r\n            {Object.entries(palettes.number).map((entry, index, entries)=>{\r\n                    let prefix = entry[0];\r\n                    let number: NumberControl = entry[1] as any;\r\n                    return palettewrap(prefix,\r\n                        <div className=\"palette-row numeric\">\r\n                            {makeNumericInput(prefix, number, setNumber, setText, readOnly)}\r\n                            <input className={\"unit\"} placeholder={\"unit\"} value={number.unit} pattern={CSS_Units.pattern} disabled={readOnly}\r\n                                   list={\"__jodel_CSS_units\"} onChange={e => {setUnit(e as any, prefix)}} />\r\n\r\n                            {/* Numeric */}\r\n                            <CommandBar  style={{paddingRight: '4px', marginLeft: 'auto'}}>\r\n                                <Btn icon={'space'} />\r\n                                <Btn icon={\"delete\"} action={(e) => {removeControl(prefix)}} tip={'Remove number'}/>\r\n                            </CommandBar>\r\n                        </div>)\r\n                }\r\n            )}\r\n            {Object.entries(palettes.text).map((entry, index, entries)=>{\r\n                    let prefix = entry[0];\r\n                    let string: StringControl = entry[1] as any;\r\n                    return palettewrap(prefix,\r\n                        <div className={\"palette-row textual\"}>\r\n                            <input className={\"value\"} placeholder={\"value\"} defaultValue={string.value} onBlur={e => {setText(e as any, prefix)}} disabled={readOnly}\r\n                                   onKeyDown={e => {\r\n                                       if (e.key === Keystrokes.enter) setText(e as any, prefix);\r\n                                       if (e.key === Keystrokes.escape) (e.target as any).value = string.value; }} />\r\n\r\n                            {/* Text */}\r\n                            <CommandBar  style={{paddingRight: '4px', marginLeft: 'auto'}}>\r\n                                <Btn icon={'space'} />\r\n                                <Btn icon={\"delete\"} action={(e) => {removeControl(prefix)}} tip={'Remove text'}/>\r\n                            </CommandBar>\r\n                        </div>)\r\n                }\r\n            )}\r\n        </div>\r\n\r\n\r\n        <AddPalette />\r\n\r\n\r\n        {/* <div className={\"w-100\"} style={{display: 'grid', gridTemplateColumns: 'repeat(10, 1fr)', position: 'relative', zIndex:1}}\r\n             onMouseEnter={(e)=>{ dropDownButton.current?.open()}}\r\n             onMouseLeave={(e)=>{ dropDownButton.current?.close()}}\r\n        >\r\n            <button className=\"btn btn-success\" style={{flexBasis:0, flexGrow:9, gridArea: '1 / 1 / 1 / 1', zIndex: 2, minWidth: 'calc(1000% - var(--smart-editor-addon-width))'}} onClick={()=>addControl('palette')}>+ Palette</button>\r\n            <DropDownButton ref={dropDownButton} style={{flexBasis:0, flexGrow:1, minWidth:0, gridArea: '1 / 1 / 1 / 11', zIndex:1, transform: 'scaleX(-1)'}}>\r\n                <div onClick={(e)=> dropDownButton.current?.close()} style={{transform: 'scaleX(-1)'}}>\r\n                    <button className={\"w-100 btn btn-outline-success\"} style={{height: 'var(--smart-editor-height)'}}\r\n                            onClick={()=>addControl('number')}>+ Number</button>\r\n                    <button className={\"w-100 btn btn-outline-success\"} style={{height: 'var(--smart-editor-height)'}}\r\n                            onClick={()=>addControl('text')}>+ Text</button>\r\n                    <button className={\"w-100 btn btn-outline-success\"} style={{height: 'var(--smart-editor-height)'}}\r\n                            onClick={()=>addControl('path')}>+ Path</button>\r\n                </div>\r\n            </DropDownButton>\r\n            </div>*/}\r\n\r\n        <HRule theme={'light'} style={{display: 'block', padding: '30px 0px!important'}}/>\r\n\r\n        <Input data={view} field={'cssIsGlobal'} type={\"checkbox\"}  jsxLabel={\r\n            <div style={{width:'100%', display:'block', float: 'left'}}>\r\n                {cssIsGlobal ? <b style={{color: 'inherit'}}>Global</b> : <b style={{color: 'inherit'}}>Local</b>}\r\n                {' CSS & LESS Editor '}\r\n                {cssIsGlobal ? '(Use with caution)' : ''}\r\n            </div>\r\n        } />\r\n\r\n        {/* <CommandBar style={{paddingTop: '10px', float: 'right'}}>\r\n            {expand ?\r\n                <Btn icon={'shrink'} action={(e) => {setExpand(false)}} tip={'Minimize editor'}/>\r\n                :\r\n                <Btn icon={'expand'} action={(e) => {setExpand(true)}} tip={'Enlarge editor'}/>\r\n            }\r\n        </CommandBar>*/}\r\n\r\n        {/* ****** */}\r\n\r\n        {/*<label className={'ms-1 mb-1'}>{view.cssIsGlobal ? 'Global' : 'Local'} CSS Editor</label>*/}\r\n        {vcss.indexOf('//') >= 0 && <b><span style={{color:'red'}}>Warning:</span> Inline comments // are not supported by our compiler.<br/>\r\n            Please replace them with /* block comments */</b>}\r\n\r\n            <div className={\"monaco-editor-wrapper\"} style={{\r\n                minHeight: '20px',\r\n                height:`${expand ? '30lvh' : '10lvh'}`,\r\n                transition: 'height 0.3s',\r\n                resize: 'vertical', overflow:'hidden',\r\n                display: 'flex',\r\n                flexDirection: 'column'\r\n            }}\r\n            onFocus={() => setExpand(true)}\r\n            onBlur={() => {setExpand(false);blur()}}>\r\n            <Editor className={'mx-1'}\r\n                    options={{fontSize: 12, scrollbar: {vertical: 'hidden', horizontalScrollbarSize: 5}, minimap: {enabled: false}, readOnly: readOnly}}\r\n                    defaultLanguage={'less'} value={vcss} onChange={change}/>\r\n        </div>\r\n        {false && <div className={\"debug\"}><div style={{whiteSpace:'pre'}}>{view.compiled_css}</div></div>}\r\n        {/*<textarea>\r\n            '[data-viewid=\"'+view.id+'\"]{\\n' +\r\n            Object.entries(palette).flatMap((entry, index, entries)=>{\r\n                let prefix = entry[0];\r\n                let colors = entry[1];\r\n                return colors.map((color, i)=> \"\\t--\" + prefix + i + \": \" + color + \";\\n\");\r\n            }).join('')+'\\n' + (cssISGlobal ? '}\\n' : '\\n') +\r\n            '/ *** custom css area *** /\\n' + view.css + (!cssISGlobal ? '}\\n' : '\\n')\r\n            view.css\r\n        </textarea>*/}\r\n        {\r\n            // todo: if row have only 1 color can be accessed both as palette prefix-1 or as palett prefix without number, so i can name colors.\r\n        }\r\n\r\n    </section>);\r\n}\r\n\r\ninterface OwnProps {viewID: Pointer<DViewElement, 1, 1, LViewElement>, readonly: boolean}\r\ninterface StateProps {view: LViewElement}\r\ninterface DispatchProps { }\r\ntype AllProps = OwnProps & StateProps & DispatchProps;\r\n\r\n\r\nfunction mapStateToProps(state: DState, ownProps: OwnProps): StateProps {\r\n    const view = LViewElement.fromPointer(ownProps.viewID);\r\n    return {view};\r\n}\r\n\r\nfunction mapDispatchToProps(dispatch: Dispatch<any>): DispatchProps {\r\n    const ret: DispatchProps = {};\r\n    return ret;\r\n}\r\n\r\n\r\nexport const PaletteDataConnected = connect<StateProps, DispatchProps, OwnProps, DState>(\r\n    mapStateToProps,\r\n    mapDispatchToProps\r\n)(PaletteDataComponent);\r\n\r\nexport const PaletteData = (props: OwnProps, children: (string | React.Component)[] = []): ReactElement => {\r\n    return <PaletteDataConnected {...{...props, children}} />;\r\n}\r\nexport default PaletteData;\r\n","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\editors\\views\\data\\GenericNodeData.tsx",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\editors\\views\\data\\CustomData.tsx",["1017"],"/* Viewpoints > Events */\r\n\r\nimport React, {Dispatch, EventHandler, MouseEventHandler, ReactElement} from 'react';\r\nimport {DState, DViewElement, GObject, LViewElement, Pointer, TextArea, U} from '../../../../joiner';\r\nimport {connect} from \"react-redux\";\r\nimport {JsEditor} from \"../../languages\";\r\nimport {Function} from \"../../../forEndUser/FunctionComponent\";\r\n// import JsEditor from \"../../jsEditor/JsEditor\";\r\n\r\nimport { CommandBar, Btn, Sep } from '../../../commandbar/CommandBar';\r\n\r\nfunction ViewEventsComponent(props: AllProps) {\r\n    const view = props.view;\r\n    const dview = props.view.__raw;\r\n    const readOnly = props.readonly;\r\n\r\n    function addEvent() {\r\n        let eventname = \"customEvent1\";\r\n        eventname = U.increaseEndingNumber(eventname, false, false, (s)=> s in dview.events);\r\n        let newevent: GObject = {};\r\n        newevent[eventname] = '(parameter1, parameter2) => {\\n\\t// example, replace with your function\\n\\treturn parameter1 + parameter2;\\n}';\r\n        view.events = newevent;\r\n    }\r\n\r\n    let initialExpand = (v: any, field: any)=>!!(v as any)[field as string];\r\n    return(<section className={'p-3 events-tab'}>\r\n        <h1 className={'view'}>View: {view.name}</h1>\r\n        <h2>Default Events</h2>\r\n        <JsEditor key='odu' data={view} field={'onDataUpdate'} title={'onDataUpdate'} initialExpand={initialExpand} readOnly={readOnly}/>\r\n        <JsEditor key='ods' data={view} field={'onDragStart'} title={'onDragStart'} initialExpand={initialExpand} readOnly={readOnly}/>\r\n        <JsEditor key='odw' data={view} field={'whileDragging'} title={'whileDragging'} initialExpand={initialExpand} readOnly={readOnly}/>\r\n        <JsEditor key='ode' data={view} field={'onDragEnd'} title={'onDragEnd'} initialExpand={initialExpand} readOnly={readOnly}/>\r\n        <JsEditor key='ors' data={view} field={'onResizeStart'} title={'onResizeStart'} initialExpand={initialExpand} readOnly={readOnly}/>\r\n        <JsEditor key='orw' data={view} field={'whileResizing'} title={'whileResizing'} initialExpand={initialExpand} readOnly={readOnly}/>\r\n        <JsEditor key='ore' data={view} field={'onResizeEnd'} title={'onResizeEnd'} initialExpand={initialExpand} readOnly={readOnly}/>\r\n        <div className={'d-flex mx-auto'} style={{marginTop: '14px'}}>\r\n            <h2>Custom Events</h2>\r\n            <CommandBar className={'ms-auto'} style={{paddingTop: '12px'}}>\r\n                <Btn icon={'add'} action={addEvent}  tip={'New event'}/>\r\n            </CommandBar>\r\n        </div>\r\n\r\n        {Object.keys(dview.events).map((k) => {\r\n            let val = dview.events[k];\r\n            if (!val) return;\r\n            return <>\r\n            <JsEditor\r\n            data={view} key={k/* if val does not update, concatenate it to the key (k+val)*/}\r\n            readOnly={readOnly}\r\n            initialExpand={()=>true}\r\n            title={<input defaultValue={k} disabled={readOnly} onBlur={(e)=>{\r\n                let newname = e.target.value;\r\n                if (k === newname) return;\r\n                let newEvent: GObject = {};\r\n                newEvent[newname] = dview.events[k];\r\n                newEvent[k] = undefined;\r\n                view.events = newEvent;\r\n            }}/>}\r\n            jsxLabel={<CommandBar className={'ms-auto'} style={{paddingTop: '9px'}}>\r\n                <Btn icon={'delete'} tip={'Remove event'} action={() => {\r\n                    let newEvent: GObject = {};\r\n                    newEvent[k] = undefined; // this is how you trigger deletion with object -= action\r\n                    view.events = newEvent;\r\n                }}/>\r\n            </CommandBar>}\r\n\r\n            /* jsxLabel={<button className={'btn btn-danger my-auto ms-auto'} onClick={() => {\r\n                let newEvent: GObject = {};\r\n                newEvent[k] = undefined; // this is how you trigger deletion with object -= action\r\n                view.events = newEvent;\r\n            }}>\r\n                <i className={'p-1 bi bi-trash3-fill'} />\r\n            </button>}*/\r\n\r\n\r\n            getter={() => val}\r\n            setter={(js) => {\r\n                let newEvent: GObject = {};\r\n                newEvent[k] = js;\r\n                view.events = newEvent;\r\n            }}\r\n        /></>})}\r\n        <div className={'p-4'}></div>\r\n    </section>);\r\n}\r\n\r\ninterface OwnProps {viewID: Pointer<DViewElement, 1, 1, LViewElement>, readonly: boolean}\r\ninterface StateProps {view: LViewElement}\r\ninterface DispatchProps { }\r\ntype AllProps = OwnProps & StateProps & DispatchProps;\r\n\r\n\r\nfunction mapStateToProps(state: DState, ownProps: OwnProps): StateProps {\r\n    const view = LViewElement.fromPointer(ownProps.viewID);\r\n    return {view};\r\n}\r\n\r\nfunction mapDispatchToProps(dispatch: Dispatch<any>): DispatchProps {\r\n    const ret: DispatchProps = {};\r\n    return ret;\r\n}\r\n\r\n\r\nexport const ViewEventsConnected = connect<StateProps, DispatchProps, OwnProps, DState>(\r\n    mapStateToProps,\r\n    mapDispatchToProps\r\n)(ViewEventsComponent);\r\n\r\nexport const ViewEvents = (props: OwnProps, children: (string | React.Component)[] = []): ReactElement => {\r\n    return <ViewEventsConnected {...{...props, children}} />;\r\n}\r\nexport default ViewEvents;\r\n","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\editors\\views\\data\\TemplateData.tsx",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\editors\\views\\data\\InfoData.tsx",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\tooltip\\MyTooltip.tsx",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\forEndUser\\Color.tsx",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\editors\\views\\data\\EdgePointData.tsx",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\editors\\views\\data\\EdgeData.tsx",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\editors\\views\\data\\FieldData.tsx",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\editors\\views\\data\\GraphData.tsx",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\forEndUser\\FunctionComponent.tsx",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\editors\\views\\data\\NodeData.tsx",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\widgets\\Widgets.tsx",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\alert\\Dialog.tsx",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\logo.tsx",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\common\\libraries\\projectModified.ts",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\editors\\MTM.tsx",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\redux\\VersionFixer.tsx",["1018","1019","1020","1021","1022","1023","1024","1025","1026","1027","1028"],"import {\r\n    CoordinateMode,\r\n    Defaults,\r\n    Dictionary, DocString, DPointerTargetable, DReference,\r\n    DState, DStructuralFeature,\r\n    DViewElement,\r\n    EdgeBendingMode,\r\n    EdgeGapMode,\r\n    GObject,\r\n    GraphPoint,\r\n    GraphSize, LClass,\r\n    Log, LPointerTargetable, LState, Pointer, Pointers, RuntimeAccessible, RuntimeAccessibleClass, store,\r\n    U\r\n} from \"../joiner\";\r\nimport {NumberControl, PaletteControl, PathControl, StringControl} from \"../view/viewElement/view\";\r\nimport {Tooltip} from \"../components/forEndUser/Tooltip\";\r\n\r\n/*\r\n                                    TODO for every update: check the VersionFixer.help() function\r\n*/\r\n\r\nconst deleteDState = false; // there is also one in Constructors, update them together\r\n@RuntimeAccessible('VersionFixer')\r\nexport class VersionFixer {\r\n    public static cname = 'VersionFixer';\r\n    private static versionAdapters: Dictionary<number/*version*/, {n: number, f:(s: DState)=>DState}> = VersionFixer.setup();\r\n    private static highestVersion: number = 0; // automatically updated from updater function names\r\n    private static prefix: string = '__jodel_versioning_';\r\n    public static help(){\r\n        console.clear();\r\n        let i: number  = 1;\r\n\r\n        console.log(`\r\nBefore deploying a new version you should:\r\n\r\n${i++}) Update changelog\r\n\r\n${i++}) make a separate build subfolder (so you can switch versions)\r\n\r\n${i++}) build a new empty versioning function with signature like: private ['2.1 -> 2.3'](s: DState): DState\r\n        fill this function in a way that translates from the state shape of the old version, to the state shape of the new one\r\n   \r\n        `);\r\n\r\n\r\n\r\n        // DEPRECATED stuff\r\n        false && console.log(`\r\nBefore deploying a new version you should:\r\n\r\n${i++}?) ONLY IF IT'S FIRST TIME;\r\n   run DState.registerFirstTimeOnly() in the deploy version and export the localStorage variables starting with ${VersionFixer.prefix} to the dev version.\r\n   or call it in dev version after having temporarly undone the pending updates if possible, otherwise next steps might fail.\r\n   \r\n${i++}?) ONLY IF there are entirely new kinds of D-objects or optional new sub-structures in D-objects (like View.palette), update buildVersionSignature() method\r\n \r\n\r\n${i++}) build a new empty versioning function with signature: private ['2.1 -> 2.3'](s: DState): DState\r\n\r\n${i++}) in DState update DState.version.n (leave date and conversionList unchanged)\r\n\r\n${i++}) open a new empty project (no models no metamodels)\r\n   to find out what changed in the state between version without risking human error, i made an automatic detection.\r\n   call VersionFixer.checkVersionChanges() in browser console to see what changed need conversion in the function (i would save the result as comment inside the func)\r\n\r\n${i++}) fill the empty function of step (1), in a way that translates from the state shape of the old version, to the state shape of the new one\r\n\r\n${i++}) only after the transition function is complete, call VersionFixer.registerNewVersion();\r\n   it will both validate the version update function and store the new version as baseline.\r\n   (needs to be done last because checkVersionChanges will stop working until a new version is ready)\r\n   \r\nBEWARE: this approach cannot detect changes of valid values where the type did not change. eg if view.appliableTo = 'string' change his valid string values but not his type;\r\neverytime you put hands into a D-Object shape or valid values, you should document them to be able to write a conversion function later on.\r\n        `);\r\n    }\r\n    public static get_highestversion(): number{\r\n        if (VersionFixer.highestVersion === 0) VersionFixer.setup();\r\n        return VersionFixer.highestVersion;\r\n    }\r\n\r\n    private static setup(): (typeof VersionFixer)[\"versionAdapters\"]{\r\n        VersionFixer.versionAdapters = {};\r\n        const errormsg = (k: string)=>\"Version auto-updater have a updater registered incorrectly: \\\"\" + k + \"\\\", please notify the developers.\"\r\n        let staticKeys = [] as string[];// no need for them Object.getOwnPropertyNames(VersionFixer);\r\n        let instanceKeys = Object.getOwnPropertyNames(VersionFixer.prototype); // object.keys does not list not-enumarable stuff (like class funcs)\r\n        let allKeys = [...staticKeys, ...instanceKeys];\r\n        for (let k of allKeys){\r\n            switch(k){\r\n                case 'constructor': case 'd': case 'className':\r\n                case 'prefix': case 'highestVersion': case 'versionAdapters':\r\n                case 'get_highestversion':\r\n                case 'staticClassName': case 'cname': case 'subclasses':\r\n                case 'help': case 'setup': case 'update': continue;\r\n            }\r\n            let [froms, tos] = k.split(' -> ');\r\n            Log.exDev(!froms?.length || !tos?.length, errormsg(k));\r\n            let from = +froms; let to = +tos;\r\n            Log.exDev(isNaN(from) || isNaN(to), errormsg(k));\r\n            Log.exDev(!!VersionFixer.versionAdapters[from], \"duplicate version adapter from \\\"\"+from+\"\\\", please notify the developers.\")\r\n            VersionFixer.highestVersion = Math.max(VersionFixer.highestVersion, to);\r\n            VersionFixer.versionAdapters[from] = {n:to, f: (VersionFixer.prototype as any)[k]}\r\n        }\r\n        return VersionFixer.versionAdapters;\r\n    }\r\n\r\n    public static update(s: DState): DState{\r\n        if (!VersionFixer.versionAdapters) VersionFixer.setup();\r\n        if (!s.version) s.version = {n: 2.1, date:\"_reconverted\", conversionList:[0]};\r\n        let prevVer = s.version.n || 0;\r\n        let currVer = prevVer;\r\n        let singleton = new VersionFixer();\r\n        let canAutocorrect = U.getHashParam('repair') === '1';\r\n        if (canAutocorrect) VersionFixer.autocorrect(s);\r\n        while (currVer !== VersionFixer.highestVersion) {\r\n            Log.exDev(!VersionFixer.versionAdapters[currVer], \"missing version adapter from \\\"\"+ currVer+\"\\\", please notify the developers.\",\r\n                {adapers: VersionFixer.versionAdapters, curr: VersionFixer.versionAdapters[currVer]});\r\n            console.log('versionfixer update pre', {prevVer, currVer, entry: VersionFixer.versionAdapters[currVer]});\r\n            let {n, f} = VersionFixer.versionAdapters[currVer];\r\n            s.version.conversionList = [...s.version.conversionList, currVer];\r\n            s = f.call(singleton, s);\r\n            currVer = s.version.n = n || 0;\r\n            console.log('versionfixer update post', {prevVer, currVer, n});\r\n            //Log.exDev(currVer !== n, \"version updater updated to incorrect target versionn \\\"\"+prevVer+\"\\\" -> \\\"\"+n+\"\\\" , please notify the developers.\");\r\n            Log.exDev(currVer <= prevVer, \"version updater found loop at version \\\"\"+currVer+\"\\\", please notify the developers.\");\r\n            prevVer = currVer;\r\n        }\r\n        if (canAutocorrect) VersionFixer.autocorrect(s);\r\n        return s;\r\n    }\r\n\r\n\r\n    private d<D extends DPointerTargetable, L extends LPointerTargetable>(ptr: Pointer<D>, s: DState): D{\r\n        return s.idlookup[ptr] as any;\r\n        // {n}\r\n    }\r\n    private ['0 -> 2.1'](s: DState): DState {\r\n        s.version = {n: 2.1, date:\"_reconverted\", conversionList:[0]};\r\n        return s;\r\n    }\r\n    private ['2.1 -> 2.2'](s: DState): void {\r\n\r\n    }\r\n    private ['2.2 -> 2.201'](s: DState): DState {\r\n        // let ls: LState = LPointerTargetable.from(s); nope, avoid L-objects. actions would fire in present state instead of in parameter state\r\n        for (let c of (s.classs).map(p=> this.d(p, s))) {\r\n            c.isSingleton = !!c.isSingleton; // booleanize the undefined\r\n            c.sealed = [];\r\n            c.final = false;\r\n            c.rootable = undefined;\r\n        }\r\n        for (let c of Object.values(s.idlookup) as any[]) { if (c?.className && c.id && c.isCrossReference === undefined) c.isCrossReference = false; }\r\n        for (let c of (s.viewelements).map(p=> this.d(p, s))) { c.father = c.viewpoint; }\r\n        for (let c of (s.viewpoints).map(p=> this.d(p, s))) { c.cssIsGlobal = true; }\r\n        for (let c of (s.projects).map(p=> this.d(p, s))) { c.favorite = {}; c.description = ''; }\r\n        for (let c of (s.references).map(p=> this.d(p, s))) { if (c.composition === undefined) c.aggregation = !(c.composition = !!(c as any).containment); }\r\n        for (let c of (s.models).map(p=> this.d(p, s))) { if (c.dependencies === undefined) c.dependencies = []; }\r\n        for (let c of (s.attributes).map(p => this.d(p, s))) {\r\n            c.derived = !!c.derived;\r\n            c.derived_write = undefined; // c.derived ? '' : undefined;\r\n            c.derived_read = undefined; // c.derived ? '' : undefined;\r\n        }\r\n\r\n        return s;\r\n    }\r\n\r\n    public static autocorrect(s0?: DState): void {\r\n        let s: DState;\r\n        if (s0) s = s0;\r\n        else s = store.getState();\r\n\r\n        let validPtrs: typeof s.idlookup = {};\r\n        let oldIDlookup = {...s.idlookup};\r\n        for (let ptr in s.idlookup) {\r\n            if (ptr === 'clonedCounter') continue;\r\n            if (!Pointers.isPointer(ptr)) {\r\n                Log.eDevv('invalid key in idlookup', {ptr, s});\r\n                continue;\r\n            }\r\n            let v = s.idlookup[ptr];\r\n            if (Object.keys(v).length < 5 || deleteDState && v.className === 'DState') { // totally euristic lowerbound to detect semi-deleted objects or ill-created\r\n                console.log('autocorrect: removed incomplete object ', {d:s.idlookup[ptr], cn:s.idlookup[ptr]?.className, ptr})\r\n                delete s.idlookup[ptr];\r\n            }\r\n        }\r\n\r\n        // remove invalid pointers (with values but pointing to nothing).\r\n        let removedPointers: Pointer[] = [];\r\n        let hasDeleted: boolean;\r\n        do {\r\n            hasDeleted = false;\r\n            U.deepReplace(s, (key:string|number|undefined, obj: any, fullpath:string[]) => {\r\n                if (!Pointers.isPointer(obj) || s.idlookup[obj]) return obj; // if is valid pointer, no-op\r\n                // pointer is invalid\r\n                // if: invalid pointer implicates full object removal\r\n                if (\r\n                    key === 'father' && fullpath.length === 3 // idlookup.someid.father = 3 keys\r\n                    || key === 'end' && fullpath.length === 3\r\n                    || key === 'start' && fullpath.length === 3\r\n                    //|| key === 'viewpoint' && fullpath.length === 3\r\n                ) {\r\n                    let id: Pointer<any> = fullpath[1];\r\n                    if (!Pointers.isPointer(id)) { Log.eDevv('found mandatory key in an unexpected position', {fullpath, obj, s}); return obj; }\r\n                    let d = s.idlookup[id];issues:\r\n                    if (key === 'father' && d?.className === 'DObject') return obj; // dobj can have missing father\r\n                    removedPointers.push(id);\r\n                    if (!(id in s.idlookup)) return undefined;\r\n                    console.log('autocorrect: removed for missing mandatory pointer ', {obj, id, fullpath})\r\n\r\n                    delete s.idlookup[id]; // NB: in theory this might be replaced during deepReplace causing a conflict, but in practice it shouldn't.\r\n                    hasDeleted = true;\r\n                    return undefined;\r\n                }\r\n                // if: invalid pointer implicates self-removal (just the pointer from a collection/variable)\r\n                return undefined;\r\n            })\r\n        } while (hasDeleted);\r\n\r\n\r\n        let lookup: Dictionary<DocString<'className', DPointerTargetable[]>> = {};\r\n        for (let k in s.idlookup) {\r\n            let v = s.idlookup[k];\r\n            if (typeof v !== 'object' || !v.className) continue;\r\n            if (!lookup[v.className]) lookup[v.className] = [];\r\n            lookup[v.className].push(v);\r\n        }\r\n        let common = ['father', 'instances', 'instanceof', 'node', 'model', 'annotations', 'graph'];\r\n        let out = {counter: 0};\r\n        VersionFixer.removeNulls(out, s, lookup, 'DModel', [...common, 'packages'])\r\n        VersionFixer.removeNulls(out, s, lookup, 'DPackage', [...common, 'classifiers', 'subpackages'])\r\n        VersionFixer.removeNulls(out, s, lookup, 'DClass', [...common, 'references', 'attributes', 'operations', 'extends', 'extendedBy'])\r\n        VersionFixer.removeNulls(out, s, lookup, 'DAttribute', [...common, 'type'])\r\n        VersionFixer.removeNulls(out, s, lookup, 'DReference', [...common, 'type'])\r\n        VersionFixer.removeNulls(out, s, lookup, 'DOperation', [...common, 'type'])\r\n        VersionFixer.removeNulls(out, s, lookup, 'DParameter', [...common, 'type', 'parameters', 'exceptions'])\r\n        VersionFixer.removeNulls(out, s, lookup, 'DEnumerator', [...common, 'literals'])\r\n        VersionFixer.removeNulls(out, s, lookup, 'DObject', [...common, 'features'])\r\n        VersionFixer.removeNulls(out, s, lookup, 'DValue', [...common, 'values'])\r\n        VersionFixer.removeNulls(out, s, lookup, 'DGraph', [...common, 'subElements'])\r\n        VersionFixer.removeNulls(out, s, lookup, 'DGraphVertex', [...common, 'subElements'])\r\n        VersionFixer.removeNulls(out, s, lookup, 'DGraphElement', [...common, 'subElements'])\r\n        VersionFixer.removeNulls(out, s, lookup, 'DEdgePoint', [...common, 'subElements'])\r\n        VersionFixer.removeNulls(out, s, lookup, 'DVertex', [...common, 'subElements'])\r\n        VersionFixer.removeNulls(out, s, lookup, 'DVoidVertex', [...common, 'subElements'])\r\n        VersionFixer.removeNulls(out, s, lookup, 'DVoidEdge', [...common, 'subElements', 'start', 'end', 'midnodes'])\r\n        VersionFixer.removeNulls(out, s, lookup, 'DEdge', [...common, 'subElements', 'start', 'end', 'midnodes'])\r\n        VersionFixer.removeNulls(out, s, lookup, 'DViewPoint', [...common, 'subViews', 'viewpoint'])\r\n        VersionFixer.removeNulls(out, s, lookup, 'DViewElement', [...common, 'subViews', 'viewpoint'])\r\n\r\n        let output: string[] = ['Project repair'];\r\n        let removedDObjects = Object.keys(oldIDlookup).length - Object.keys(s.idlookup).length;\r\n        let diff = U.arrayDifference(Object.keys(oldIDlookup), Object.keys(s.idlookup));\r\n        if (removedDObjects) {\r\n            output.push('removed ' + removedDObjects + ' invalid objects.',); // dobjects\r\n        }\r\n        if (removedPointers.length) output.push('removed ' + removedPointers.length+' invalid pointers.'); // ptr to non-existing elem\r\n        if (out.counter) {\r\n            output.push('removed ' + removedDObjects + ' invalid values.'); // undef in ptr collection\r\n        }\r\n        if (output.length > 1) {\r\n            Tooltip.show(<>{(output as any).separator(<br/>)}</>, undefined, undefined, 3);\r\n            Log.ii('project repair report', {removedPointers,\r\n                removedObjects_num: removedDObjects, removedObjects: diff.removed.map(e=>oldIDlookup[e]),\r\n                removedValues: out.counter, output})\r\n        }\r\n        else {\r\n            Log.ii('project repair report:\\tall good, nothing to repair!')\r\n        }\r\n\r\n    }\r\n\r\n    public static mandatoryKeys = ['father'];\r\n    public static removeNulls(out:{counter:number}, s: DState, lookup: Dictionary<DocString<'className'>, DPointerTargetable[]>,\r\n                    cn: DocString<'ClassName'>, keys: string[]): void {\r\n        for (let d of (lookup[cn]||[])) {\r\n            for (let k in keys) {\r\n                if (!(k in d)) continue;\r\n                let v = (d as GObject)[k];\r\n                if (Pointers.isPointer(v)) continue; // it's a valid single value\r\n                /* if (!Array.isArray(v)) {\r\n                       d[k] = undefined; // removal of single elements is already handled by deepReplace, this just ensures it is always undef and not null or so.\r\n                       continue;\r\n                   }\r\n                */\r\n                (d as GObject)[k] = (v as any[]).filter(e => !!(e && Pointers.isPointer(e)));\r\n                if (out) out.counter += v.length - (d as GObject)[k].length\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n//deprecated stuff\r\n\r\n\r\n\r\n/*\r\npublic static checkVersionChanges(): GObject{\r\n    let lastVerName = localStorage.getItem(VersionFixer.prefix+'last');\r\n    let lastVerState = localStorage.getItem(VersionFixer.prefix+lastVerName);\r\n    let lastVersionSignature = JSON.parse(lastVerState || '{not:\"found\"}');\r\n    let newVersionSignature = this.buildVersionSignature();\r\n    return VersionFixer.checkVersionChanges_inner(lastVersionSignature, newVersionSignature);\r\n}\r\npublic static checkVersionChanges_inner(s1: DState, s2:DState): GObject{ return U.objectDelta(s1, s2, true); }\r\npublic static registerFirstTimeOnly(): void {\r\n    let newVersionSignature = VersionFixer.buildVersionSignature();\r\n    localStorage.setItem(VersionFixer.prefix+'last', ''+newVersionSignature.version.n);\r\n    localStorage.setItem(VersionFixer.prefix+''+newVersionSignature.version.n, JSON.stringify(newVersionSignature));\r\n}\r\n\r\npublic static registerNewVersion(): boolean {\r\n    let lastVerName = localStorage.getItem(VersionFixer.prefix+'last');\r\n    let prevVersionSignature: DState = JSON.parse(localStorage.getItem(VersionFixer.prefix+lastVerName) || '{not:\"found\"}') as any;\r\n    let newVersionSignature = VersionFixer.buildVersionSignature();\r\n    let updatedVersionSignature = this.update(prevVersionSignature);\r\n    let versionDiff: GObject = VersionFixer.checkVersionChanges_inner(updatedVersionSignature, newVersionSignature);\r\n    if (Object.keys(versionDiff).length !== 0) {\r\n        console.log(\"failed to save new version, the conversion function is not updating state properly.\",\r\n            {versionDiff, prevVersionSignature, newVersionSignature, updatedVersionSignature});\r\n        return false;\r\n    }\r\n    localStorage.setItem(VersionFixer.prefix+'last', ''+newVersionSignature.version.n);\r\n    localStorage.setItem(VersionFixer.prefix+''+newVersionSignature.version.n, JSON.stringify(newVersionSignature));\r\n    return true;\r\n}\r\nprivate static buildVersionSignature(): DState {\r\n    // purpose: save in state 1 of each D-objects with all the possible sub-objects in every possible structure shape\r\n    // values can be dummy but syntactical valid\r\n    //DState.new(); nope, i'm using current state, just call it from an empty project with no models.\r\n    DViewElement.new2(\"View\", \"jsx\", undefined,(d)=>{\r\n        d.appliableTo = 'Any';\r\n        d.subViews = {[\"Sample-fake-subView\"]: 3.5};\r\n        d.oclUpdateCondition = '(view: LViewElement) => { return false; } <--- as a string'\r\n        d.defaultVSize = new GraphSize(5,5,5,5);\r\n        d.palette = {\r\n            \"color\": {type:'color', value: [{r:0, g:0, b:0, a:0}]} as PaletteControl,\r\n            \"number\": {type:'number', value: 4, unit: 'px'} as NumberControl,\r\n            \"text\": {type:'text', value: 'stringa'} as StringControl,\r\n            \"path\": {type:'path', value: 'M 00 L 1 1 Z', x: '5', y: '10', options: [{k: 'optionnale', v:'option path M 0 0 L 5 5 Z'}]} as PathControl,\r\n        };\r\n        d.events = {[\"function name\"]: \"function body\"};\r\n        d.bendingMode = EdgeBendingMode.Bezier_QT;\r\n        d.edgeGapMode = EdgeGapMode.gap;\r\n        d.size = {[\"node or model Pointer\"]: new GraphSize(5,5,5,5)};\r\n        d.edgeStartOffset = new GraphPoint(5,5);\r\n        d.edgeEndOffset = new GraphPoint(5,5);\r\n        d.edgePointCoordMode = CoordinateMode.relativePercent;\r\n        d.edgeHeadSize = new GraphPoint(5,5);\r\n        d.edgeTailSize = new GraphPoint(5,5);\r\n    }, true, 'DViewElement');\r\n\r\n\r\n\r\n    return store.getState();\r\n}\r\n*/","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\forEndUser\\MTM.tsx",[],{"ruleId":"1029","replacedBy":"1030"},{"ruleId":"1031","replacedBy":"1032"},{"ruleId":"1033","severity":1,"message":"1034","line":14,"column":8,"nodeType":"1035","endLine":14,"endColumn":18,"suggestions":"1036"},{"ruleId":"1037","severity":1,"message":"1038","line":19,"column":29,"nodeType":"1039","messageId":"1040","endLine":19,"endColumn":31},{"ruleId":"1041","severity":1,"message":"1042","line":26,"column":22,"nodeType":"1043","messageId":"1044","endLine":26,"endColumn":23},{"ruleId":"1037","severity":1,"message":"1038","line":27,"column":22,"nodeType":"1039","messageId":"1040","endLine":27,"endColumn":24},{"ruleId":"1037","severity":1,"message":"1038","line":29,"column":27,"nodeType":"1039","messageId":"1040","endLine":29,"endColumn":29},{"ruleId":"1037","severity":1,"message":"1045","line":31,"column":37,"nodeType":"1039","messageId":"1040","endLine":31,"endColumn":39},{"ruleId":"1037","severity":1,"message":"1038","line":34,"column":45,"nodeType":"1039","messageId":"1040","endLine":34,"endColumn":47},{"ruleId":"1029","replacedBy":"1030"},{"ruleId":"1031","replacedBy":"1032"},{"ruleId":"1037","severity":1,"message":"1038","line":11,"column":23,"nodeType":"1039","messageId":"1040","endLine":11,"endColumn":25},{"ruleId":"1037","severity":1,"message":"1038","line":18,"column":30,"nodeType":"1039","messageId":"1040","endLine":18,"endColumn":32},{"ruleId":"1037","severity":1,"message":"1038","line":19,"column":35,"nodeType":"1039","messageId":"1040","endLine":19,"endColumn":37},{"ruleId":"1037","severity":1,"message":"1038","line":20,"column":35,"nodeType":"1039","messageId":"1040","endLine":20,"endColumn":37},{"ruleId":"1041","severity":1,"message":"1046","line":25,"column":28,"nodeType":"1043","messageId":"1044","endLine":25,"endColumn":29},{"ruleId":"1037","severity":1,"message":"1038","line":26,"column":37,"nodeType":"1039","messageId":"1040","endLine":26,"endColumn":39},{"ruleId":"1037","severity":1,"message":"1038","line":28,"column":42,"nodeType":"1039","messageId":"1040","endLine":28,"endColumn":44},{"ruleId":"1041","severity":1,"message":"1046","line":57,"column":28,"nodeType":"1043","messageId":"1044","endLine":57,"endColumn":29},{"ruleId":"1037","severity":1,"message":"1038","line":63,"column":28,"nodeType":"1039","messageId":"1040","endLine":63,"endColumn":30},{"ruleId":"1037","severity":1,"message":"1038","line":97,"column":28,"nodeType":"1039","messageId":"1040","endLine":97,"endColumn":30},{"ruleId":"1037","severity":1,"message":"1038","line":110,"column":33,"nodeType":"1039","messageId":"1040","endLine":110,"endColumn":35},{"ruleId":"1037","severity":1,"message":"1038","line":112,"column":33,"nodeType":"1039","messageId":"1040","endLine":112,"endColumn":35},{"ruleId":"1047","severity":1,"message":"1048","line":123,"column":22,"nodeType":"1049","messageId":"1050","endLine":123,"endColumn":23,"suggestions":"1051"},{"ruleId":"1037","severity":1,"message":"1038","line":130,"column":25,"nodeType":"1039","messageId":"1040","endLine":130,"endColumn":27},{"ruleId":"1037","severity":1,"message":"1038","line":139,"column":30,"nodeType":"1039","messageId":"1040","endLine":139,"endColumn":32},{"ruleId":"1037","severity":1,"message":"1038","line":150,"column":21,"nodeType":"1039","messageId":"1040","endLine":150,"endColumn":23},{"ruleId":"1052","severity":1,"message":"1053","line":188,"column":9,"nodeType":"1054","messageId":"1040","endLine":188,"endColumn":62},{"ruleId":"1055","severity":1,"message":"1056","line":190,"column":9,"nodeType":"1057","messageId":"1040","endLine":190,"endColumn":13},{"ruleId":"1058","severity":1,"message":"1059","line":575,"column":20,"nodeType":"1060","messageId":"1061","endLine":575,"endColumn":22},{"ruleId":"1058","severity":1,"message":"1059","line":575,"column":44,"nodeType":"1060","messageId":"1061","endLine":575,"endColumn":46},{"ruleId":"1047","severity":1,"message":"1062","line":1643,"column":74,"nodeType":"1049","messageId":"1050","endLine":1643,"endColumn":75,"suggestions":"1063"},{"ruleId":"1047","severity":1,"message":"1062","line":1643,"column":97,"nodeType":"1049","messageId":"1050","endLine":1643,"endColumn":98,"suggestions":"1064"},{"ruleId":"1058","severity":1,"message":"1065","line":1688,"column":37,"nodeType":"1060","messageId":"1061","endLine":1688,"endColumn":39},{"ruleId":"1058","severity":1,"message":"1065","line":1688,"column":61,"nodeType":"1060","messageId":"1061","endLine":1688,"endColumn":63},{"ruleId":"1058","severity":1,"message":"1059","line":1688,"column":61,"nodeType":"1060","messageId":"1061","endLine":1688,"endColumn":63},{"ruleId":"1058","severity":1,"message":"1059","line":1689,"column":37,"nodeType":"1060","messageId":"1061","endLine":1689,"endColumn":39},{"ruleId":"1066","severity":1,"message":"1067","line":1813,"column":104,"nodeType":"1068","messageId":"1069","endLine":1813,"endColumn":106},{"ruleId":"1058","severity":1,"message":"1059","line":2007,"column":28,"nodeType":"1060","messageId":"1061","endLine":2007,"endColumn":30},{"ruleId":"1058","severity":1,"message":"1059","line":2007,"column":38,"nodeType":"1060","messageId":"1061","endLine":2007,"endColumn":40},{"ruleId":"1058","severity":1,"message":"1059","line":2018,"column":89,"nodeType":"1060","messageId":"1061","endLine":2018,"endColumn":91},{"ruleId":"1058","severity":1,"message":"1059","line":2018,"column":97,"nodeType":"1060","messageId":"1061","endLine":2018,"endColumn":99},{"ruleId":"1058","severity":1,"message":"1059","line":2019,"column":50,"nodeType":"1060","messageId":"1061","endLine":2019,"endColumn":52},{"ruleId":"1058","severity":1,"message":"1059","line":2019,"column":63,"nodeType":"1060","messageId":"1061","endLine":2019,"endColumn":65},{"ruleId":"1058","severity":1,"message":"1065","line":2524,"column":24,"nodeType":"1060","messageId":"1061","endLine":2524,"endColumn":26},{"ruleId":"1058","severity":1,"message":"1065","line":2524,"column":57,"nodeType":"1060","messageId":"1061","endLine":2524,"endColumn":59},{"ruleId":"1058","severity":1,"message":"1065","line":2731,"column":16,"nodeType":"1060","messageId":"1061","endLine":2731,"endColumn":18},{"ruleId":"1058","severity":1,"message":"1065","line":2731,"column":27,"nodeType":"1060","messageId":"1061","endLine":2731,"endColumn":29},{"ruleId":"1070","severity":1,"message":"1071","line":429,"column":13,"nodeType":"1072","messageId":"1073","endLine":429,"endColumn":61},{"ruleId":"1058","severity":1,"message":"1059","line":246,"column":44,"nodeType":"1060","messageId":"1061","endLine":246,"endColumn":46},{"ruleId":"1058","severity":1,"message":"1059","line":246,"column":53,"nodeType":"1060","messageId":"1061","endLine":246,"endColumn":55},{"ruleId":"1074","severity":1,"message":"1075","line":702,"column":79,"nodeType":"1076","messageId":"1077","endLine":702,"endColumn":135},{"ruleId":"1047","severity":1,"message":"1078","line":732,"column":109,"nodeType":"1049","messageId":"1050","endLine":732,"endColumn":110,"suggestions":"1079"},{"ruleId":"1074","severity":1,"message":"1075","line":748,"column":29,"nodeType":"1076","messageId":"1077","endLine":748,"endColumn":93},{"ruleId":"1074","severity":1,"message":"1075","line":757,"column":29,"nodeType":"1076","messageId":"1077","endLine":757,"endColumn":72},{"ruleId":"1074","severity":1,"message":"1075","line":798,"column":38,"nodeType":"1076","messageId":"1077","endLine":798,"endColumn":66},{"ruleId":"1074","severity":1,"message":"1075","line":837,"column":30,"nodeType":"1076","messageId":"1077","endLine":837,"endColumn":58},{"ruleId":"1074","severity":1,"message":"1075","line":859,"column":57,"nodeType":"1076","messageId":"1077","endLine":859,"endColumn":85},{"ruleId":"1074","severity":1,"message":"1075","line":904,"column":63,"nodeType":"1076","messageId":"1077","endLine":904,"endColumn":90},{"ruleId":"1070","severity":1,"message":"1071","line":1038,"column":21,"nodeType":"1080","messageId":"1073","endLine":1056,"endColumn":124},{"ruleId":"1081","severity":1,"message":"1082","line":216,"column":17,"nodeType":"1083","messageId":"1040","endLine":218,"endColumn":28},{"ruleId":"1070","severity":1,"message":"1071","line":209,"column":9,"nodeType":"1084","messageId":"1073","endLine":209,"endColumn":34},{"ruleId":"1058","severity":1,"message":"1065","line":286,"column":22,"nodeType":"1060","messageId":"1061","endLine":286,"endColumn":24},{"ruleId":"1058","severity":1,"message":"1065","line":286,"column":41,"nodeType":"1060","messageId":"1061","endLine":286,"endColumn":43},{"ruleId":"1058","severity":1,"message":"1065","line":287,"column":22,"nodeType":"1060","messageId":"1061","endLine":287,"endColumn":24},{"ruleId":"1058","severity":1,"message":"1065","line":287,"column":41,"nodeType":"1060","messageId":"1061","endLine":287,"endColumn":43},{"ruleId":"1058","severity":1,"message":"1065","line":288,"column":22,"nodeType":"1060","messageId":"1061","endLine":288,"endColumn":24},{"ruleId":"1058","severity":1,"message":"1065","line":288,"column":41,"nodeType":"1060","messageId":"1061","endLine":288,"endColumn":43},{"ruleId":"1058","severity":1,"message":"1065","line":289,"column":22,"nodeType":"1060","messageId":"1061","endLine":289,"endColumn":24},{"ruleId":"1058","severity":1,"message":"1065","line":289,"column":41,"nodeType":"1060","messageId":"1061","endLine":289,"endColumn":43},{"ruleId":"1058","severity":1,"message":"1065","line":290,"column":26,"nodeType":"1060","messageId":"1061","endLine":290,"endColumn":28},{"ruleId":"1058","severity":1,"message":"1065","line":290,"column":50,"nodeType":"1060","messageId":"1061","endLine":290,"endColumn":52},{"ruleId":"1058","severity":1,"message":"1065","line":291,"column":27,"nodeType":"1060","messageId":"1061","endLine":291,"endColumn":29},{"ruleId":"1058","severity":1,"message":"1065","line":291,"column":52,"nodeType":"1060","messageId":"1061","endLine":291,"endColumn":54},{"ruleId":"1070","severity":1,"message":"1071","line":623,"column":13,"nodeType":"1085","messageId":"1073","endLine":630,"endColumn":42},{"ruleId":"1070","severity":1,"message":"1071","line":812,"column":9,"nodeType":"1084","messageId":"1073","endLine":812,"endColumn":19},{"ruleId":"1037","severity":1,"message":"1038","line":928,"column":57,"nodeType":"1039","messageId":"1040","endLine":928,"endColumn":59},{"ruleId":"1058","severity":1,"message":"1065","line":982,"column":25,"nodeType":"1060","messageId":"1061","endLine":982,"endColumn":27},{"ruleId":"1058","severity":1,"message":"1065","line":982,"column":35,"nodeType":"1060","messageId":"1061","endLine":982,"endColumn":37},{"ruleId":"1058","severity":1,"message":"1059","line":982,"column":35,"nodeType":"1060","messageId":"1061","endLine":982,"endColumn":37},{"ruleId":"1058","severity":1,"message":"1059","line":982,"column":45,"nodeType":"1060","messageId":"1061","endLine":982,"endColumn":47},{"ruleId":"1058","severity":1,"message":"1059","line":1036,"column":24,"nodeType":"1060","messageId":"1061","endLine":1036,"endColumn":26},{"ruleId":"1058","severity":1,"message":"1059","line":1036,"column":43,"nodeType":"1060","messageId":"1061","endLine":1036,"endColumn":45},{"ruleId":"1058","severity":1,"message":"1059","line":1037,"column":28,"nodeType":"1060","messageId":"1061","endLine":1037,"endColumn":30},{"ruleId":"1058","severity":1,"message":"1059","line":1037,"column":47,"nodeType":"1060","messageId":"1061","endLine":1037,"endColumn":49},{"ruleId":"1070","severity":1,"message":"1071","line":502,"column":9,"nodeType":"1085","messageId":"1073","endLine":514,"endColumn":58},{"ruleId":"1070","severity":1,"message":"1071","line":520,"column":9,"nodeType":"1084","messageId":"1073","endLine":520,"endColumn":28},{"ruleId":"1070","severity":1,"message":"1071","line":585,"column":9,"nodeType":"1080","messageId":"1073","endLine":611,"endColumn":26},{"ruleId":"1086","severity":1,"message":"1087","line":857,"column":30,"nodeType":"1043","messageId":"1088","endLine":857,"endColumn":44},{"ruleId":"1055","severity":1,"message":"1056","line":351,"column":20,"nodeType":"1057","messageId":"1040","endLine":351,"endColumn":24},{"ruleId":"1058","severity":1,"message":"1059","line":509,"column":59,"nodeType":"1060","messageId":"1061","endLine":509,"endColumn":61},{"ruleId":"1058","severity":1,"message":"1059","line":509,"column":82,"nodeType":"1060","messageId":"1061","endLine":509,"endColumn":84},{"ruleId":"1070","severity":1,"message":"1071","line":600,"column":9,"nodeType":"1084","messageId":"1073","endLine":600,"endColumn":23},{"ruleId":"1070","severity":1,"message":"1071","line":639,"column":9,"nodeType":"1084","messageId":"1073","endLine":639,"endColumn":20},{"ruleId":"1058","severity":1,"message":"1059","line":733,"column":33,"nodeType":"1060","messageId":"1061","endLine":733,"endColumn":35},{"ruleId":"1058","severity":1,"message":"1059","line":733,"column":54,"nodeType":"1060","messageId":"1061","endLine":733,"endColumn":56},{"ruleId":"1047","severity":1,"message":"1089","line":746,"column":27,"nodeType":"1049","messageId":"1050","endLine":746,"endColumn":28,"suggestions":"1090"},{"ruleId":"1047","severity":1,"message":"1091","line":746,"column":29,"nodeType":"1049","messageId":"1050","endLine":746,"endColumn":30,"suggestions":"1092"},{"ruleId":"1055","severity":1,"message":"1056","line":817,"column":13,"nodeType":"1057","messageId":"1040","endLine":817,"endColumn":17},{"ruleId":"1074","severity":1,"message":"1075","line":819,"column":26,"nodeType":"1076","messageId":"1077","endLine":819,"endColumn":97},{"ruleId":"1055","severity":1,"message":"1056","line":922,"column":20,"nodeType":"1057","messageId":"1040","endLine":922,"endColumn":24},{"ruleId":"1074","severity":1,"message":"1075","line":949,"column":19,"nodeType":"1076","messageId":"1077","endLine":949,"endColumn":151},{"ruleId":"1055","severity":1,"message":"1056","line":955,"column":20,"nodeType":"1057","messageId":"1040","endLine":955,"endColumn":24},{"ruleId":"1074","severity":1,"message":"1075","line":964,"column":17,"nodeType":"1076","messageId":"1077","endLine":964,"endColumn":61},{"ruleId":"1055","severity":1,"message":"1056","line":970,"column":36,"nodeType":"1057","messageId":"1040","endLine":970,"endColumn":40},{"ruleId":"1058","severity":1,"message":"1059","line":1015,"column":29,"nodeType":"1060","messageId":"1061","endLine":1015,"endColumn":31},{"ruleId":"1058","severity":1,"message":"1059","line":1015,"column":38,"nodeType":"1060","messageId":"1061","endLine":1015,"endColumn":40},{"ruleId":"1058","severity":1,"message":"1065","line":1287,"column":24,"nodeType":"1060","messageId":"1061","endLine":1287,"endColumn":26},{"ruleId":"1058","severity":1,"message":"1065","line":1287,"column":38,"nodeType":"1060","messageId":"1061","endLine":1287,"endColumn":40},{"ruleId":"1070","severity":1,"message":"1071","line":1961,"column":9,"nodeType":"1084","messageId":"1073","endLine":1961,"endColumn":26},{"ruleId":"1037","severity":1,"message":"1045","line":2136,"column":53,"nodeType":"1039","messageId":"1040","endLine":2136,"endColumn":55},{"ruleId":"1037","severity":1,"message":"1045","line":2141,"column":63,"nodeType":"1039","messageId":"1040","endLine":2141,"endColumn":65},{"ruleId":"1037","severity":1,"message":"1045","line":2146,"column":58,"nodeType":"1039","messageId":"1040","endLine":2146,"endColumn":60},{"ruleId":"1037","severity":1,"message":"1045","line":2151,"column":52,"nodeType":"1039","messageId":"1040","endLine":2151,"endColumn":54},{"ruleId":"1037","severity":1,"message":"1045","line":2156,"column":54,"nodeType":"1039","messageId":"1040","endLine":2156,"endColumn":56},{"ruleId":"1037","severity":1,"message":"1045","line":2159,"column":55,"nodeType":"1039","messageId":"1040","endLine":2159,"endColumn":57},{"ruleId":"1037","severity":1,"message":"1045","line":2164,"column":53,"nodeType":"1039","messageId":"1040","endLine":2164,"endColumn":55},{"ruleId":"1037","severity":1,"message":"1045","line":2169,"column":52,"nodeType":"1039","messageId":"1040","endLine":2169,"endColumn":54},{"ruleId":"1037","severity":1,"message":"1045","line":2174,"column":53,"nodeType":"1039","messageId":"1040","endLine":2174,"endColumn":55},{"ruleId":"1037","severity":1,"message":"1045","line":2179,"column":55,"nodeType":"1039","messageId":"1040","endLine":2179,"endColumn":57},{"ruleId":"1037","severity":1,"message":"1045","line":2184,"column":55,"nodeType":"1039","messageId":"1040","endLine":2184,"endColumn":57},{"ruleId":"1037","severity":1,"message":"1045","line":2187,"column":55,"nodeType":"1039","messageId":"1040","endLine":2187,"endColumn":57},{"ruleId":"1037","severity":1,"message":"1045","line":2192,"column":56,"nodeType":"1039","messageId":"1040","endLine":2192,"endColumn":58},{"ruleId":"1037","severity":1,"message":"1045","line":2197,"column":43,"nodeType":"1039","messageId":"1040","endLine":2197,"endColumn":45},{"ruleId":"1037","severity":1,"message":"1038","line":2205,"column":39,"nodeType":"1039","messageId":"1040","endLine":2205,"endColumn":41},{"ruleId":"1037","severity":1,"message":"1045","line":2210,"column":41,"nodeType":"1039","messageId":"1040","endLine":2210,"endColumn":43},{"ruleId":"1037","severity":1,"message":"1045","line":2211,"column":41,"nodeType":"1039","messageId":"1040","endLine":2211,"endColumn":43},{"ruleId":"1037","severity":1,"message":"1045","line":2212,"column":41,"nodeType":"1039","messageId":"1040","endLine":2212,"endColumn":43},{"ruleId":"1047","severity":1,"message":"1078","line":2286,"column":98,"nodeType":"1049","messageId":"1050","endLine":2286,"endColumn":99,"suggestions":"1093"},{"ruleId":"1047","severity":1,"message":"1094","line":2286,"column":100,"nodeType":"1049","messageId":"1050","endLine":2286,"endColumn":101,"suggestions":"1095"},{"ruleId":"1096","severity":1,"message":"1097","line":2477,"column":38,"nodeType":"1068","messageId":"1098","endLine":2486,"endColumn":18},{"ruleId":"1086","severity":1,"message":"1099","line":2640,"column":12,"nodeType":"1043","messageId":"1088","endLine":2640,"endColumn":24},{"ruleId":"1086","severity":1,"message":"1100","line":2645,"column":81,"nodeType":"1043","messageId":"1088","endLine":2645,"endColumn":96},{"ruleId":"1101","severity":1,"message":"1102","line":380,"column":34,"nodeType":"1039","messageId":"1103","endLine":380,"endColumn":35},{"ruleId":"1104","severity":1,"message":"1105","line":380,"column":36,"nodeType":"1049","messageId":"1106","endLine":380,"endColumn":55},{"ruleId":"1101","severity":1,"message":"1102","line":380,"column":56,"nodeType":"1039","messageId":"1103","endLine":380,"endColumn":57},{"ruleId":"1070","severity":1,"message":"1071","line":662,"column":17,"nodeType":"1107","messageId":"1073","endLine":662,"endColumn":23},{"ruleId":"1070","severity":1,"message":"1071","line":668,"column":17,"nodeType":"1107","messageId":"1073","endLine":668,"endColumn":23},{"ruleId":"1108","severity":1,"message":"1109","line":126,"column":13,"nodeType":"1083","messageId":"1110","endLine":126,"endColumn":64},{"ruleId":"1108","severity":1,"message":"1109","line":129,"column":13,"nodeType":"1083","messageId":"1110","endLine":129,"endColumn":26},{"ruleId":"1108","severity":1,"message":"1109","line":133,"column":13,"nodeType":"1083","messageId":"1110","endLine":133,"endColumn":38},{"ruleId":"1047","severity":1,"message":"1111","line":228,"column":83,"nodeType":"1049","messageId":"1050","endLine":228,"endColumn":84,"suggestions":"1112"},{"ruleId":"1113","severity":1,"message":"1114","line":330,"column":53,"nodeType":"1054","messageId":"1115","endLine":330,"endColumn":93},{"ruleId":"1113","severity":1,"message":"1114","line":336,"column":52,"nodeType":"1054","messageId":"1115","endLine":336,"endColumn":91},{"ruleId":"1070","severity":1,"message":"1071","line":236,"column":17,"nodeType":"1084","messageId":"1073","endLine":236,"endColumn":30},{"ruleId":"1070","severity":1,"message":"1071","line":333,"column":9,"nodeType":"1084","messageId":"1073","endLine":333,"endColumn":19},{"ruleId":"1037","severity":1,"message":"1045","line":1188,"column":35,"nodeType":"1039","messageId":"1040","endLine":1188,"endColumn":37},{"ruleId":"1116","severity":1,"message":"1117","line":1270,"column":13,"nodeType":"1039","messageId":"1118","endLine":1270,"endColumn":48},{"ruleId":"1055","severity":1,"message":"1056","line":2021,"column":34,"nodeType":"1057","messageId":"1040","endLine":2021,"endColumn":38},{"ruleId":"1119","severity":1,"message":"1120","line":2727,"column":32,"nodeType":"1121","messageId":"1122","endLine":2727,"endColumn":39,"fix":"1123"},{"ruleId":"1124","severity":1,"message":"1125","line":4585,"column":69,"nodeType":"1043","messageId":"1040","endLine":4585,"endColumn":74,"fix":"1126"},{"ruleId":"1124","severity":1,"message":"1125","line":4588,"column":53,"nodeType":"1043","messageId":"1040","endLine":4588,"endColumn":58,"fix":"1127"},{"ruleId":"1124","severity":1,"message":"1125","line":4591,"column":75,"nodeType":"1043","messageId":"1040","endLine":4591,"endColumn":80,"fix":"1128"},{"ruleId":"1124","severity":1,"message":"1125","line":4593,"column":61,"nodeType":"1043","messageId":"1040","endLine":4593,"endColumn":66,"fix":"1129"},{"ruleId":"1058","severity":1,"message":"1059","line":4923,"column":46,"nodeType":"1060","messageId":"1061","endLine":4923,"endColumn":48},{"ruleId":"1058","severity":1,"message":"1059","line":4923,"column":62,"nodeType":"1060","messageId":"1061","endLine":4923,"endColumn":64},{"ruleId":"1130","severity":1,"message":"1131","line":5036,"column":5,"nodeType":"1132","messageId":"1133","endLine":5038,"endColumn":6},{"ruleId":"1066","severity":1,"message":"1067","line":5150,"column":92,"nodeType":"1068","messageId":"1069","endLine":5150,"endColumn":94},{"ruleId":"1074","severity":1,"message":"1075","line":5995,"column":39,"nodeType":"1076","messageId":"1077","endLine":5995,"endColumn":117},{"ruleId":"1074","severity":1,"message":"1075","line":6368,"column":40,"nodeType":"1076","messageId":"1077","endLine":6368,"endColumn":121},{"ruleId":"1070","severity":1,"message":"1071","line":6414,"column":9,"nodeType":"1085","messageId":"1073","endLine":6450,"endColumn":21},{"ruleId":"1058","severity":1,"message":"1059","line":6422,"column":27,"nodeType":"1060","messageId":"1061","endLine":6422,"endColumn":29},{"ruleId":"1058","severity":1,"message":"1059","line":6422,"column":36,"nodeType":"1060","messageId":"1061","endLine":6422,"endColumn":38},{"ruleId":"1058","severity":1,"message":"1059","line":6492,"column":41,"nodeType":"1060","messageId":"1061","endLine":6492,"endColumn":43},{"ruleId":"1058","severity":1,"message":"1059","line":6492,"column":56,"nodeType":"1060","messageId":"1061","endLine":6492,"endColumn":58},{"ruleId":"1058","severity":1,"message":"1065","line":204,"column":62,"nodeType":"1060","messageId":"1061","endLine":204,"endColumn":64},{"ruleId":"1058","severity":1,"message":"1065","line":204,"column":89,"nodeType":"1060","messageId":"1061","endLine":204,"endColumn":91},{"ruleId":"1058","severity":1,"message":"1065","line":825,"column":22,"nodeType":"1060","messageId":"1061","endLine":825,"endColumn":24},{"ruleId":"1058","severity":1,"message":"1065","line":825,"column":42,"nodeType":"1060","messageId":"1061","endLine":825,"endColumn":44},{"ruleId":"1037","severity":1,"message":"1038","line":931,"column":88,"nodeType":"1039","messageId":"1040","endLine":931,"endColumn":90},{"ruleId":"1096","severity":1,"message":"1134","line":1374,"column":54,"nodeType":"1068","messageId":"1098","endLine":1374,"endColumn":105},{"ruleId":"1037","severity":1,"message":"1045","line":1375,"column":27,"nodeType":"1039","messageId":"1040","endLine":1375,"endColumn":29},{"ruleId":"1037","severity":1,"message":"1045","line":1376,"column":30,"nodeType":"1039","messageId":"1040","endLine":1376,"endColumn":32},{"ruleId":"1058","severity":1,"message":"1059","line":1383,"column":58,"nodeType":"1060","messageId":"1061","endLine":1383,"endColumn":60},{"ruleId":"1058","severity":1,"message":"1059","line":1384,"column":36,"nodeType":"1060","messageId":"1061","endLine":1384,"endColumn":38},{"ruleId":"1108","severity":1,"message":"1109","line":1762,"column":13,"nodeType":"1083","messageId":"1110","endLine":1762,"endColumn":44},{"ruleId":"1130","severity":1,"message":"1131","line":168,"column":5,"nodeType":"1132","messageId":"1133","endLine":172,"endColumn":6},{"ruleId":"1108","severity":1,"message":"1109","line":145,"column":21,"nodeType":"1083","messageId":"1110","endLine":146,"endColumn":31},{"ruleId":"1037","severity":1,"message":"1038","line":74,"column":42,"nodeType":"1039","messageId":"1040","endLine":74,"endColumn":44},{"ruleId":"1070","severity":1,"message":"1071","line":32,"column":5,"nodeType":"1084","messageId":"1073","endLine":32,"endColumn":15},{"ruleId":"1070","severity":1,"message":"1071","line":44,"column":95,"nodeType":"1107","messageId":"1073","endLine":44,"endColumn":101},{"ruleId":"1070","severity":1,"message":"1071","line":46,"column":5,"nodeType":"1084","messageId":"1073","endLine":46,"endColumn":16},{"ruleId":"1135","severity":1,"message":"1136","line":50,"column":9,"nodeType":"1137","messageId":"1138","endLine":50,"endColumn":25},{"ruleId":"1070","severity":1,"message":"1071","line":73,"column":13,"nodeType":"1107","messageId":"1073","endLine":73,"endColumn":19},{"ruleId":"1070","severity":1,"message":"1071","line":98,"column":13,"nodeType":"1107","messageId":"1073","endLine":98,"endColumn":19},{"ruleId":"1070","severity":1,"message":"1071","line":101,"column":13,"nodeType":"1107","messageId":"1073","endLine":101,"endColumn":19},{"ruleId":"1139","severity":1,"message":"1140","line":66,"column":25,"nodeType":"1141","messageId":"1142","endLine":66,"endColumn":40},{"ruleId":"1139","severity":1,"message":"1140","line":73,"column":25,"nodeType":"1141","messageId":"1142","endLine":73,"endColumn":41},{"ruleId":"1139","severity":1,"message":"1140","line":80,"column":25,"nodeType":"1141","messageId":"1142","endLine":80,"endColumn":39},{"ruleId":"1139","severity":1,"message":"1140","line":83,"column":113,"nodeType":"1141","messageId":"1142","endLine":83,"endColumn":133},{"ruleId":"1143","severity":1,"message":"1144","line":524,"column":41,"nodeType":"1145","endLine":524,"endColumn":57},{"ruleId":"1033","severity":1,"message":"1146","line":53,"column":8,"nodeType":"1035","endLine":53,"endColumn":12,"suggestions":"1147"},{"ruleId":"1139","severity":1,"message":"1140","line":87,"column":29,"nodeType":"1141","messageId":"1142","endLine":87,"endColumn":42},{"ruleId":"1139","severity":1,"message":"1140","line":98,"column":33,"nodeType":"1141","messageId":"1142","endLine":98,"endColumn":46},{"ruleId":"1139","severity":1,"message":"1140","line":107,"column":33,"nodeType":"1141","messageId":"1142","endLine":107,"endColumn":46},{"ruleId":"1139","severity":1,"message":"1140","line":114,"column":51,"nodeType":"1141","messageId":"1142","endLine":114,"endColumn":66},{"ruleId":"1139","severity":1,"message":"1140","line":147,"column":17,"nodeType":"1141","messageId":"1142","endLine":147,"endColumn":34},{"ruleId":"1139","severity":1,"message":"1140","line":149,"column":52,"nodeType":"1141","messageId":"1142","endLine":149,"endColumn":67},{"ruleId":"1143","severity":1,"message":"1144","line":307,"column":17,"nodeType":"1145","endLine":307,"endColumn":80},{"ruleId":"1070","severity":1,"message":"1071","line":57,"column":5,"nodeType":"1084","messageId":"1073","endLine":62,"endColumn":7},{"ruleId":"1037","severity":1,"message":"1038","line":123,"column":45,"nodeType":"1039","messageId":"1040","endLine":123,"endColumn":47},{"ruleId":"1037","severity":1,"message":"1038","line":123,"column":80,"nodeType":"1039","messageId":"1040","endLine":123,"endColumn":82},{"ruleId":"1037","severity":1,"message":"1038","line":177,"column":53,"nodeType":"1039","messageId":"1040","endLine":177,"endColumn":55},{"ruleId":"1143","severity":1,"message":"1144","line":75,"column":25,"nodeType":"1145","endLine":75,"endColumn":75},{"ruleId":"1130","severity":1,"message":"1131","line":31,"column":5,"nodeType":"1132","messageId":"1133","endLine":33,"endColumn":6},{"ruleId":"1047","severity":1,"message":"1078","line":189,"column":87,"nodeType":"1049","messageId":"1050","endLine":189,"endColumn":88,"suggestions":"1148"},{"ruleId":"1149","severity":1,"message":"1150","line":139,"column":85,"nodeType":"1145","messageId":"1151","endLine":139,"endColumn":120,"fix":"1152"},{"ruleId":"1135","severity":1,"message":"1136","line":174,"column":13,"nodeType":"1137","messageId":"1138","endLine":174,"endColumn":31},{"ruleId":"1135","severity":1,"message":"1136","line":239,"column":13,"nodeType":"1137","messageId":"1138","endLine":239,"endColumn":31},{"ruleId":"1096","severity":1,"message":"1153","line":192,"column":26,"nodeType":"1068","messageId":"1098","endLine":201,"endColumn":14},{"ruleId":"1139","severity":1,"message":"1140","line":18,"column":21,"nodeType":"1141","messageId":"1142","endLine":18,"endColumn":38},{"ruleId":"1139","severity":1,"message":"1140","line":20,"column":56,"nodeType":"1141","messageId":"1142","endLine":20,"endColumn":71},{"ruleId":"1058","severity":1,"message":"1065","line":166,"column":25,"nodeType":"1060","messageId":"1061","endLine":166,"endColumn":27},{"ruleId":"1058","severity":1,"message":"1065","line":166,"column":47,"nodeType":"1060","messageId":"1061","endLine":166,"endColumn":49},{"ruleId":"1058","severity":1,"message":"1059","line":166,"column":47,"nodeType":"1060","messageId":"1061","endLine":166,"endColumn":49},{"ruleId":"1058","severity":1,"message":"1059","line":166,"column":61,"nodeType":"1060","messageId":"1061","endLine":166,"endColumn":63},{"ruleId":"1058","severity":1,"message":"1059","line":166,"column":84,"nodeType":"1060","messageId":"1061","endLine":166,"endColumn":86},{"ruleId":"1058","severity":1,"message":"1059","line":166,"column":98,"nodeType":"1060","messageId":"1061","endLine":166,"endColumn":100},{"ruleId":"1058","severity":1,"message":"1059","line":166,"column":127,"nodeType":"1060","messageId":"1061","endLine":166,"endColumn":129},{"ruleId":"1058","severity":1,"message":"1059","line":166,"column":157,"nodeType":"1060","messageId":"1061","endLine":166,"endColumn":159},{"ruleId":"1037","severity":1,"message":"1038","line":170,"column":18,"nodeType":"1039","messageId":"1040","endLine":170,"endColumn":20},{"ruleId":"1139","severity":1,"message":"1140","line":257,"column":25,"nodeType":"1141","messageId":"1142","endLine":257,"endColumn":42},{"ruleId":"1139","severity":1,"message":"1140","line":259,"column":60,"nodeType":"1141","messageId":"1142","endLine":259,"endColumn":75},{"ruleId":"1139","severity":1,"message":"1140","line":53,"column":25,"nodeType":"1141","messageId":"1142","endLine":53,"endColumn":45},{"ruleId":"1139","severity":1,"message":"1140","line":55,"column":61,"nodeType":"1141","messageId":"1142","endLine":55,"endColumn":76},{"ruleId":"1058","severity":1,"message":"1065","line":165,"column":25,"nodeType":"1060","messageId":"1061","endLine":165,"endColumn":27},{"ruleId":"1058","severity":1,"message":"1065","line":165,"column":47,"nodeType":"1060","messageId":"1061","endLine":165,"endColumn":49},{"ruleId":"1058","severity":1,"message":"1059","line":165,"column":47,"nodeType":"1060","messageId":"1061","endLine":165,"endColumn":49},{"ruleId":"1058","severity":1,"message":"1059","line":165,"column":61,"nodeType":"1060","messageId":"1061","endLine":165,"endColumn":63},{"ruleId":"1058","severity":1,"message":"1059","line":165,"column":84,"nodeType":"1060","messageId":"1061","endLine":165,"endColumn":86},{"ruleId":"1058","severity":1,"message":"1059","line":165,"column":98,"nodeType":"1060","messageId":"1061","endLine":165,"endColumn":100},{"ruleId":"1058","severity":1,"message":"1059","line":165,"column":127,"nodeType":"1060","messageId":"1061","endLine":165,"endColumn":129},{"ruleId":"1058","severity":1,"message":"1059","line":165,"column":157,"nodeType":"1060","messageId":"1061","endLine":165,"endColumn":159},{"ruleId":"1037","severity":1,"message":"1038","line":169,"column":18,"nodeType":"1039","messageId":"1040","endLine":169,"endColumn":20},{"ruleId":"1139","severity":1,"message":"1140","line":256,"column":25,"nodeType":"1141","messageId":"1142","endLine":256,"endColumn":42},{"ruleId":"1139","severity":1,"message":"1140","line":258,"column":60,"nodeType":"1141","messageId":"1142","endLine":258,"endColumn":75},{"ruleId":"1070","severity":1,"message":"1071","line":314,"column":9,"nodeType":"1085","messageId":"1073","endLine":327,"endColumn":20},{"ruleId":"1070","severity":1,"message":"1071","line":341,"column":9,"nodeType":"1080","messageId":"1073","endLine":351,"endColumn":50},{"ruleId":"1130","severity":1,"message":"1131","line":44,"column":5,"nodeType":"1132","messageId":"1133","endLine":46,"endColumn":6},{"ruleId":"1058","severity":1,"message":"1065","line":90,"column":24,"nodeType":"1060","messageId":"1061","endLine":90,"endColumn":26},{"ruleId":"1058","severity":1,"message":"1065","line":90,"column":43,"nodeType":"1060","messageId":"1061","endLine":90,"endColumn":45},{"ruleId":"1037","severity":1,"message":"1038","line":33,"column":37,"nodeType":"1039","messageId":"1040","endLine":33,"endColumn":39},{"ruleId":"1130","severity":1,"message":"1131","line":105,"column":5,"nodeType":"1132","messageId":"1133","endLine":105,"endColumn":74},{"ruleId":"1130","severity":1,"message":"1131","line":12,"column":5,"nodeType":"1132","messageId":"1133","endLine":14,"endColumn":6},{"ruleId":"1135","severity":1,"message":"1136","line":13,"column":9,"nodeType":"1137","messageId":"1138","endLine":70,"endColumn":64},{"ruleId":"1130","severity":1,"message":"1131","line":24,"column":5,"nodeType":"1132","messageId":"1133","endLine":26,"endColumn":6},{"ruleId":"1143","severity":1,"message":"1144","line":18,"column":21,"nodeType":"1145","endLine":18,"endColumn":53},{"ruleId":"1143","severity":1,"message":"1144","line":23,"column":21,"nodeType":"1145","endLine":23,"endColumn":53},{"ruleId":"1058","severity":1,"message":"1065","line":110,"column":29,"nodeType":"1060","messageId":"1061","endLine":110,"endColumn":31},{"ruleId":"1058","severity":1,"message":"1065","line":110,"column":51,"nodeType":"1060","messageId":"1061","endLine":110,"endColumn":53},{"ruleId":"1058","severity":1,"message":"1059","line":110,"column":51,"nodeType":"1060","messageId":"1061","endLine":110,"endColumn":53},{"ruleId":"1058","severity":1,"message":"1059","line":110,"column":65,"nodeType":"1060","messageId":"1061","endLine":110,"endColumn":67},{"ruleId":"1058","severity":1,"message":"1059","line":110,"column":88,"nodeType":"1060","messageId":"1061","endLine":110,"endColumn":90},{"ruleId":"1058","severity":1,"message":"1059","line":110,"column":102,"nodeType":"1060","messageId":"1061","endLine":110,"endColumn":104},{"ruleId":"1058","severity":1,"message":"1059","line":110,"column":131,"nodeType":"1060","messageId":"1061","endLine":110,"endColumn":133},{"ruleId":"1058","severity":1,"message":"1059","line":110,"column":161,"nodeType":"1060","messageId":"1061","endLine":110,"endColumn":163},{"ruleId":"1037","severity":1,"message":"1038","line":131,"column":18,"nodeType":"1039","messageId":"1040","endLine":131,"endColumn":20},{"ruleId":"1143","severity":1,"message":"1144","line":41,"column":26,"nodeType":"1145","endLine":41,"endColumn":44},{"ruleId":"1143","severity":1,"message":"1144","line":46,"column":26,"nodeType":"1145","endLine":46,"endColumn":47},{"ruleId":"1066","severity":1,"message":"1154","line":94,"column":47,"nodeType":"1068","messageId":"1155","endLine":94,"endColumn":49},{"ruleId":"1058","severity":1,"message":"1059","line":147,"column":30,"nodeType":"1060","messageId":"1061","endLine":147,"endColumn":32},{"ruleId":"1058","severity":1,"message":"1059","line":152,"column":21,"nodeType":"1060","messageId":"1061","endLine":152,"endColumn":23},{"ruleId":"1037","severity":1,"message":"1038","line":106,"column":37,"nodeType":"1039","messageId":"1040","endLine":106,"endColumn":39},{"ruleId":"1058","severity":1,"message":"1059","line":52,"column":41,"nodeType":"1060","messageId":"1061","endLine":52,"endColumn":43},{"ruleId":"1058","severity":1,"message":"1059","line":52,"column":68,"nodeType":"1060","messageId":"1061","endLine":52,"endColumn":70},{"ruleId":"1143","severity":1,"message":"1144","line":56,"column":20,"nodeType":"1145","endLine":56,"endColumn":69},{"ruleId":"1143","severity":1,"message":"1144","line":57,"column":21,"nodeType":"1145","endLine":59,"endColumn":44},{"ruleId":"1033","severity":1,"message":"1156","line":32,"column":8,"nodeType":"1035","endLine":32,"endColumn":10,"suggestions":"1157"},{"ruleId":"1058","severity":1,"message":"1065","line":53,"column":28,"nodeType":"1060","messageId":"1061","endLine":53,"endColumn":30},{"ruleId":"1058","severity":1,"message":"1065","line":53,"column":96,"nodeType":"1060","messageId":"1061","endLine":53,"endColumn":98},{"ruleId":"1047","severity":1,"message":"1158","line":94,"column":37,"nodeType":"1049","messageId":"1050","endLine":94,"endColumn":38,"suggestions":"1159"},{"ruleId":"1058","severity":1,"message":"1065","line":66,"column":27,"nodeType":"1060","messageId":"1061","endLine":66,"endColumn":29},{"ruleId":"1058","severity":1,"message":"1065","line":66,"column":43,"nodeType":"1060","messageId":"1061","endLine":66,"endColumn":45},{"ruleId":"1058","severity":1,"message":"1065","line":67,"column":28,"nodeType":"1060","messageId":"1061","endLine":67,"endColumn":30},{"ruleId":"1058","severity":1,"message":"1065","line":67,"column":45,"nodeType":"1060","messageId":"1061","endLine":67,"endColumn":47},{"ruleId":"1037","severity":1,"message":"1038","line":102,"column":26,"nodeType":"1039","messageId":"1040","endLine":102,"endColumn":28},{"ruleId":"1096","severity":1,"message":"1160","line":107,"column":124,"nodeType":"1068","messageId":"1098","endLine":107,"endColumn":181},{"ruleId":"1033","severity":1,"message":"1161","line":201,"column":8,"nodeType":"1035","endLine":201,"endColumn":25,"suggestions":"1162"},{"ruleId":"1130","severity":1,"message":"1131","line":27,"column":5,"nodeType":"1132","messageId":"1133","endLine":29,"endColumn":6},{"ruleId":"1101","severity":1,"message":"1102","line":88,"column":218,"nodeType":"1039","messageId":"1103","endLine":88,"endColumn":219},{"ruleId":"1101","severity":1,"message":"1102","line":88,"column":418,"nodeType":"1039","messageId":"1103","endLine":88,"endColumn":419},{"ruleId":"1101","severity":1,"message":"1102","line":90,"column":217,"nodeType":"1039","messageId":"1103","endLine":90,"endColumn":218},{"ruleId":"1101","severity":1,"message":"1102","line":90,"column":419,"nodeType":"1039","messageId":"1103","endLine":90,"endColumn":420},{"ruleId":"1101","severity":1,"message":"1102","line":90,"column":611,"nodeType":"1039","messageId":"1103","endLine":90,"endColumn":612},{"ruleId":"1143","severity":1,"message":"1144","line":51,"column":27,"nodeType":"1145","endLine":51,"endColumn":62},{"ruleId":"1033","severity":1,"message":"1163","line":25,"column":8,"nodeType":"1035","endLine":25,"endColumn":15,"suggestions":"1164"},{"ruleId":"1058","severity":1,"message":"1065","line":183,"column":20,"nodeType":"1060","messageId":"1061","endLine":183,"endColumn":22},{"ruleId":"1058","severity":1,"message":"1065","line":183,"column":30,"nodeType":"1060","messageId":"1061","endLine":183,"endColumn":32},{"ruleId":"1101","severity":1,"message":"1102","line":323,"column":51,"nodeType":"1039","messageId":"1103","endLine":323,"endColumn":52},{"ruleId":"1101","severity":1,"message":"1102","line":326,"column":44,"nodeType":"1039","messageId":"1103","endLine":326,"endColumn":45},{"ruleId":"1101","severity":1,"message":"1102","line":329,"column":47,"nodeType":"1039","messageId":"1103","endLine":329,"endColumn":48},{"ruleId":"1070","severity":1,"message":"1071","line":354,"column":13,"nodeType":"1072","messageId":"1073","endLine":355,"endColumn":28},{"ruleId":"1047","severity":1,"message":"1165","line":247,"column":47,"nodeType":"1049","messageId":"1050","endLine":247,"endColumn":48,"suggestions":"1166"},{"ruleId":"1066","severity":1,"message":"1154","line":45,"column":23,"nodeType":"1084","messageId":"1167","endLine":45,"endColumn":30},{"ruleId":"1058","severity":1,"message":"1059","line":180,"column":43,"nodeType":"1060","messageId":"1061","endLine":180,"endColumn":45},{"ruleId":"1058","severity":1,"message":"1059","line":180,"column":59,"nodeType":"1060","messageId":"1061","endLine":180,"endColumn":61},{"ruleId":"1096","severity":1,"message":"1168","line":191,"column":30,"nodeType":"1068","messageId":"1098","endLine":215,"endColumn":14},{"ruleId":"1058","severity":1,"message":"1065","line":196,"column":38,"nodeType":"1060","messageId":"1061","endLine":196,"endColumn":40},{"ruleId":"1058","severity":1,"message":"1065","line":197,"column":21,"nodeType":"1060","messageId":"1061","endLine":197,"endColumn":23},{"ruleId":"1058","severity":1,"message":"1059","line":197,"column":21,"nodeType":"1060","messageId":"1061","endLine":197,"endColumn":23},{"ruleId":"1058","severity":1,"message":"1059","line":197,"column":38,"nodeType":"1060","messageId":"1061","endLine":197,"endColumn":40},{"ruleId":"1058","severity":1,"message":"1059","line":198,"column":21,"nodeType":"1060","messageId":"1061","endLine":198,"endColumn":23},{"ruleId":"1058","severity":1,"message":"1059","line":198,"column":40,"nodeType":"1060","messageId":"1061","endLine":198,"endColumn":42},{"ruleId":"1169","severity":1,"message":"1170","line":203,"column":44,"nodeType":"1171","messageId":"1172","endLine":204,"endColumn":84},{"ruleId":"1173","severity":1,"message":"1174","line":203,"column":44,"nodeType":"1043","messageId":"1175","endLine":203,"endColumn":50,"fix":"1176"},"no-native-reassign",["1177"],"no-negated-in-lhs",["1178"],"react-hooks/exhaustive-deps","React Hook useEffect has a missing dependency: 'renders'. Either include it or remove the dependency array.","ArrayExpression",["1179"],"eqeqeq","Expected '===' and instead saw '=='.","BinaryExpression","unexpected","no-redeclare","'m' is already defined.","Identifier","redeclared","Expected '!==' and instead saw '!='.","'n' is already defined.","no-useless-escape","Unnecessary escape character: \\\".","Literal","unnecessaryEscape",["1180","1181"],"no-extend-native","Array prototype is read only, properties should not be added.","AssignmentExpression","no-eval","eval can be harmful.","CallExpression","no-mixed-operators","Unexpected mix of '||' and '&&'. Use parentheses to clarify the intended order of operations.","LogicalExpression","unexpectedMixedOperator","Unnecessary escape character: \\'.",["1182","1183"],["1184","1185"],"Unexpected mix of '&&' and '||'. Use parentheses to clarify the intended order of operations.","array-callback-return","Array.prototype.map() expects a value to be returned at the end of arrow function.","ArrowFunctionExpression","expectedAtEnd","no-unreachable","Unreachable code.","ExpressionStatement","unreachableCode","no-new-func","The Function constructor is eval.","NewExpression","noFunctionConstructor","Unnecessary escape character: \\..",["1186","1187"],"IfStatement","no-duplicate-case","Duplicate case label.","SwitchCase","ReturnStatement","VariableDeclaration","@typescript-eslint/no-use-before-define","'AccessModifier' was used before it was defined.","noUseBeforeDefine","Unnecessary escape character: \\/.",["1188","1189"],"Unnecessary escape character: \\,.",["1190","1191"],["1192","1193"],"Unnecessary escape character: \\_.",["1194","1195"],"no-loop-func","Function declared in a loop contains unsafe references to variable(s) 'fileLetti', 'fileLetti'.","unsafeRefs","'AttribETypes' was used before it was defined.","'DefaultEClasses' was used before it was defined.","no-useless-concat","Unexpected string concatenation of literals.","unexpectedConcat","no-template-curly-in-string","Unexpected template string expression.","unexpectedTemplateExpression","BreakStatement","no-fallthrough","Expected a 'break' statement before 'case'.","case","Unnecessary escape character: \\].",["1196","1197"],"no-cond-assign","Expected a conditional expression and instead saw an assignment.","missing","no-self-compare","Comparing to itself is potentially pointless.","comparingToSelf","no-whitespace-before-property","Unexpected whitespace before property data.","MemberExpression","unexpectedWhitespace",{"range":"1198","text":"1199"},"no-extra-label","This label 'inner' is unnecessary.",{"range":"1200","text":"1201"},{"range":"1202","text":"1201"},{"range":"1203","text":"1201"},{"range":"1204","text":"1201"},"@typescript-eslint/no-useless-constructor","Useless constructor.","MethodDefinition","noUselessConstructor","Function declared in a loop contains unsafe references to variable(s) 's0', 's00'.","no-lone-blocks","Nested block is redundant.","BlockStatement","redundantNestedBlock","react/style-prop-object","Style prop value must be an object","JSXAttribute","stylePropNotObject","jsx-a11y/alt-text","img elements must have an alt prop, either with meaningful text, or an empty string for decorative images.","JSXOpeningElement","React Hook useEffect has a missing dependency: 'user'. Either include it or remove the dependency array.",["1205"],["1206","1207"],"react/jsx-no-target-blank","Using target=\"_blank\" without rel=\"noreferrer\" (which implies rel=\"noopener\") is a security risk in older browsers: see https://mathiasbynens.github.io/rel-noopener/#recommendations","noTargetBlankWithoutNoreferrer",{"range":"1208","text":"1209"},"Function declared in a loop contains unsafe references to variable(s) 'key', 'key', 'key', 'key', 'key', 'key', 'key', 'key', 'key'.","Array.prototype.map() expects a return value from arrow function.","expectedInside","React Hook useEffect has missing dependencies: 'actions' and 'project.id'. Either include them or remove the dependency array. You can also do a functional update 'setActions(a => ...)' if you only need 'actions' in the 'setActions' call.",["1210"],"Unnecessary escape character: \\:.",["1211","1212"],"Function declared in a loop contains unsafe references to variable(s) 'data'.","React Hook useEffect has an unnecessary dependency: 'htmlref.current'. Either exclude it or remove the dependency array. Mutable values like 'htmlref.current' aren't valid dependencies because mutating them doesn't re-render the component.",["1213"],"React Hook useEffect has a missing dependency: 'emails'. Either include it or remove the dependency array. You can also replace multiple useState variables with useReducer if 'setFilteredEmails' needs the current value of 'emails'.",["1214"],"Unnecessary escape character: \\-.",["1215","1216"],"expectedReturnValue","Function declared in a loop contains unsafe references to variable(s) 'hasDeleted'.","no-labels","Unexpected labeled statement.","LabeledStatement","unexpectedLabel","no-unused-labels","'issues:' is defined but never used.","unused",{"range":"1217","text":"1201"},"no-global-assign","no-unsafe-negation",{"desc":"1218","fix":"1219"},{"messageId":"1220","fix":"1221","desc":"1222"},{"messageId":"1223","fix":"1224","desc":"1225"},{"messageId":"1220","fix":"1226","desc":"1222"},{"messageId":"1223","fix":"1227","desc":"1225"},{"messageId":"1220","fix":"1228","desc":"1222"},{"messageId":"1223","fix":"1229","desc":"1225"},{"messageId":"1220","fix":"1230","desc":"1222"},{"messageId":"1223","fix":"1231","desc":"1225"},{"messageId":"1220","fix":"1232","desc":"1222"},{"messageId":"1223","fix":"1233","desc":"1225"},{"messageId":"1220","fix":"1234","desc":"1222"},{"messageId":"1223","fix":"1235","desc":"1225"},{"messageId":"1220","fix":"1236","desc":"1222"},{"messageId":"1223","fix":"1237","desc":"1225"},{"messageId":"1220","fix":"1238","desc":"1222"},{"messageId":"1223","fix":"1239","desc":"1225"},{"messageId":"1220","fix":"1240","desc":"1222"},{"messageId":"1223","fix":"1241","desc":"1225"},[131149,131151],".",[229882,229888],"",[230061,230067],[230331,230337],[230453,230459],{"desc":"1242","fix":"1243"},{"messageId":"1220","fix":"1244","desc":"1222"},{"messageId":"1223","fix":"1245","desc":"1225"},[6141,6141]," rel=\"noreferrer\"",{"desc":"1246","fix":"1247"},{"messageId":"1220","fix":"1248","desc":"1222"},{"messageId":"1223","fix":"1249","desc":"1225"},{"desc":"1250","fix":"1251"},{"desc":"1252","fix":"1253"},{"messageId":"1220","fix":"1254","desc":"1222"},{"messageId":"1223","fix":"1255","desc":"1225"},[10711,10740],"Update the dependencies array to be: [pathname, renders]",{"range":"1256","text":"1257"},"removeEscape",{"range":"1258","text":"1201"},"Remove the `\\`. This maintains the current functionality.","escapeBackslash",{"range":"1259","text":"1260"},"Replace the `\\` with `\\\\` to include the actual backslash character.",{"range":"1261","text":"1201"},{"range":"1262","text":"1260"},{"range":"1263","text":"1201"},{"range":"1264","text":"1260"},{"range":"1265","text":"1201"},{"range":"1266","text":"1260"},{"range":"1267","text":"1201"},{"range":"1268","text":"1260"},{"range":"1269","text":"1201"},{"range":"1270","text":"1260"},{"range":"1271","text":"1201"},{"range":"1272","text":"1260"},{"range":"1273","text":"1201"},{"range":"1274","text":"1260"},{"range":"1275","text":"1201"},{"range":"1276","text":"1260"},"Update the dependencies array to be: [id, user]",{"range":"1277","text":"1278"},{"range":"1279","text":"1201"},{"range":"1280","text":"1260"},"Update the dependencies array to be: [actions, project.id]",{"range":"1281","text":"1282"},{"range":"1283","text":"1201"},{"range":"1284","text":"1260"},"Update the dependencies array to be: []",{"range":"1285","text":"1286"},"Update the dependencies array to be: [email, emails]",{"range":"1287","text":"1288"},{"range":"1289","text":"1201"},{"range":"1290","text":"1260"},[450,460],"[pathname, renders]",[5160,5161],[5160,5160],"\\",[96109,96110],[96109,96109],[96132,96133],[96132,96132],[39697,39698],[39697,39697],[34673,34674],[34673,34673],[34675,34676],[34675,34675],[118652,118653],[118652,118652],[118654,118655],[118654,118654],[14743,14744],[14743,14743],[1788,1792],"[id, user]",[9384,9385],[9384,9384],[1347,1349],"[actions, project.id]",[4229,4230],[4229,4229],[8962,8979],"[]",[979,986],"[email, emails]",[10858,10859],[10858,10858]]