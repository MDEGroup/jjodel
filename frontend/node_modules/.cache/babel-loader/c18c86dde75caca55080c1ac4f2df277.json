{"ast":null,"code":"var _jsxFileName = \"C:\\\\0Programmi\\\\Dev\\\\projects\\\\frontend\\\\jjodel\\\\src\\\\model\\\\dataStructure\\\\GraphDataElements.tsx\",\n  _dec,\n  _class,\n  _class2,\n  _dec2,\n  _class3,\n  _class4,\n  _dec3,\n  _class5,\n  _class6,\n  _dec4,\n  _class7,\n  _class8,\n  _dec5,\n  _class9,\n  _class10,\n  _dec6,\n  _class11,\n  _class12,\n  _dec7,\n  _class13,\n  _class14,\n  _dec8,\n  _class15,\n  _class16,\n  _dec9,\n  _class17,\n  _class18,\n  _dec10,\n  _class19,\n  _class20,\n  _dec11,\n  _class21,\n  _class22,\n  _dec12,\n  _class23,\n  _class24,\n  _dec13,\n  _class25,\n  _class26,\n  _dec14,\n  _class27,\n  _dec15,\n  _class29,\n  _class30,\n  _dec16,\n  _class31,\n  _class32,\n  _dec17,\n  _class33,\n  _class34,\n  _dec18,\n  _class35,\n  _class36,\n  _dec19,\n  _class37,\n  _class38,\n  _dec20,\n  _class39,\n  _class40,\n  _dec21,\n  _class41,\n  _class42;\n// import {Mixin} from \"ts-mixer\";\nimport { isDeepStrictEqual } from \"util\";\nimport { BEGIN, Constructors, CoordinateMode, Debug, DPointerTargetable, DUser, EdgeBendingMode, END, GraphElementComponent, GraphPoint, GraphSize, Leaf, Log, LPointerTargetable, MixOnlyFuncs, Node, Pointers, RuntimeAccessible, RuntimeAccessibleClass, SetFieldAction, ShortAttribETypes, Size, store, TargetableProxyHandler, U, Uarr, windoww } from \"../../joiner\";\nimport { EdgeGapMode } from \"../../joiner/types\";\nimport { Geom } from \"../../common/Geom\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconsole.warn('ts loading graphDataElement');\nexport const packageDefaultSize = new GraphSize(0, 0, 400, 500);\nexport let DGraphElement = (_dec = RuntimeAccessible('DGraphElement'), Node(_class = _dec(_class = (_class2 = class DGraphElement extends DPointerTargetable {\n  constructor() {\n    super(...arguments);\n    this.id = void 0;\n    this.graph = void 0;\n    this.model = void 0;\n    this.isSelected = void 0;\n    this.subElements = void 0;\n    this.state = {};\n    this.father = void 0;\n    this.x = void 0;\n    this.y = void 0;\n    this.zIndex = 100;\n    this.w = void 0;\n    this.h = void 0;\n    this.view = void 0;\n    this.favoriteNode = void 0;\n    this.edgesIn = void 0;\n    this.edgesOut = void 0;\n  } // static _super = DPointerTargetable;\n  // static singleton: LGraphElement;\n  // static logic: typeof LGraphElement;\n  // static structure: typeof DGraphElement;\n  // containedIn!: Pointer<DGraphElement, 0, 1, LGraphElement>;\n  // width: number = 300;\n  // height: number = 400;\n  static new(htmlindex, model, parentNodeID, graphID, nodeID, a, b) {\n    return new Constructors(new DGraphElement('dwc'), parentNodeID, true, undefined, nodeID).DPointerTargetable().DGraphElement(model, graphID, htmlindex).end();\n  }\n}, _class2.subclasses = [], _class2._extends = [], _class2)) || _class) || _class);\nexport let LGraphElement = (_dec2 = RuntimeAccessible('LGraphElement'), _dec2(_class3 = (_class4 = class LGraphElement extends LPointerTargetable {\n  constructor() {\n    super(...arguments);\n    this.__raw = void 0;\n    this.id = void 0;\n    this.father = void 0;\n    this.graph = void 0;\n    this.model = void 0;\n    this.subElements = void 0;\n    this.state = void 0;\n    this.allSubNodes = void 0;\n    this.x = void 0;\n    this.y = void 0;\n    this.width = void 0;\n    this.height = void 0;\n    this.z = void 0;\n    this.zIndex = void 0;\n    this.__info_of_z__ = {\n      type: ShortAttribETypes.EInt,\n      txt: \"alias for zIndex\"\n    };\n    this.__info_of_zIndex__ = {\n      type: ShortAttribETypes.EInt,\n      txt: \"Determine the z-axis priority of the element.<br/>Higher value tende to overlap other elements.<br/>Lower value tends to be on background.\"\n    };\n    this.zoom = void 0;\n    this.html = void 0;\n    this.w = void 0;\n    this.h = void 0;\n    this.size = void 0;\n    this.position = void 0;\n    this.htmlSize = void 0;\n    this.htmlPosition = void 0;\n    this.view = void 0;\n    this.component = void 0;\n    this.favoriteNode = void 0;\n    this.vertex = void 0;\n    this.__info__of__vertex = {\n      type: \"LVoidVertex\",\n      txt: \"the foremost vertex containing this graphElement, or undefiened.\"\n    };\n    this.__info__of__favoriteNode = {\n      type: ShortAttribETypes.EBoolean,\n      txt: \"<span>Indicates this is the primarly used (by default) node to refer to a modelling element that might have multiple representations.\" + \"<br> Can be used as favorite target for edges or other.\"\n    };\n    this.startPoint = void 0;\n    this.endPoint = void 0;\n    this.__info_of__startPoint = {\n      type: \"GraphPoint\",\n      txt: /*#__PURE__*/_jsxDEV(\"span\", {\n        children: [\"Where the outgoing edges should start their paths.\", /*#__PURE__*/_jsxDEV(\"br\", {}, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 157,\n          columnNumber: 13\n        }, this), \"Obtained by combining anchoring point offset specified in view, before snapping to a Vertex border.\", /*#__PURE__*/_jsxDEV(\"br\", {}, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 158,\n          columnNumber: 13\n        }, this), \"Defaults in outer coordinates.\"]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 156,\n        columnNumber: 60\n      }, this)\n    };\n    this.__info_of__endPoint = {\n      type: \"GraphPoint\",\n      txt: /*#__PURE__*/_jsxDEV(\"span\", {\n        children: [\"Where the incoming edges should end their paths.\", /*#__PURE__*/_jsxDEV(\"br\", {}, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 160,\n          columnNumber: 13\n        }, this), \"Obtained by combining anchoring point offset specified in view, before snapping to a Vertex border.\", /*#__PURE__*/_jsxDEV(\"br\", {}, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 161,\n          columnNumber: 13\n        }, this), \"Defaults in outer coordinates.\"]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 159,\n        columnNumber: 58\n      }, this)\n    };\n    this.__info_of__graph = {\n      type: \"\",\n      txt: \"\"\n    };\n    this.innerGraph = void 0;\n    this.__info_of__innnerGraph = {\n      type: \"\",\n      txt: \"\"\n    };\n    this.outerGraph = void 0;\n    this.__info_of__outerGraphGraph = {\n      type: \"\",\n      txt: \"\"\n    };\n    this.__info_of__graphAncestors = {\n      type: \"LGraph[]\",\n      txt: \"<span>collection of the stack of Graphs containing the current element where [0] is the most nested graph, and last is root graph.</span>\"\n    };\n    this.graphAncestors = void 0;\n    this.edgesIn = void 0;\n    this.edgesOut = void 0;\n    this.__info_of__edgesIn = {\n      type: \"LEdge[]\",\n      txt: /*#__PURE__*/_jsxDEV(\"div\", {\n        children: [\"Edges incoming into this element. \", /*#__PURE__*/_jsxDEV(\"code\", {\n          children: \"this.edgesOut[i].end\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 176,\n          columnNumber: 92\n        }, this), \" always equals to \", /*#__PURE__*/_jsxDEV(\"code\", {\n          children: \"this\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 176,\n          columnNumber: 143\n        }, this), \".\"]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 176,\n        columnNumber: 53\n      }, this)\n    };\n    this.__info_of__edgesOut = {\n      type: \"LEdge[]\",\n      txt: /*#__PURE__*/_jsxDEV(\"div\", {\n        children: [\"Edges outgoing from this element. \", /*#__PURE__*/_jsxDEV(\"code\", {\n          children: \"this.edgesIn[i].start\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 177,\n          columnNumber: 93\n        }, this), \" always equals to \", /*#__PURE__*/_jsxDEV(\"code\", {\n          children: \"this\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 177,\n          columnNumber: 145\n        }, this), \".\"]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 177,\n        columnNumber: 54\n      }, this)\n    };\n    this.__info_of__edgesStart = {\n      type: \"LEdge[]\",\n      txt: /*#__PURE__*/_jsxDEV(\"div\", {\n        children: \"Alias for this.edgesOut\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 178,\n        columnNumber: 56\n      }, this)\n    };\n    this.__info_of__edgesEnd = {\n      type: \"LEdge[]\",\n      txt: /*#__PURE__*/_jsxDEV(\"div\", {\n        children: \"Alias for this.edgesIn\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 179,\n        columnNumber: 54\n      }, this)\n    };\n    this.outerSize = void 0;\n    this.__info_of__outerSize = {\n      type: \"GraphSize\",\n      txt: \"the size of the current element relative to the first (root) graph level.\"\n    };\n    this.innerSize = void 0;\n    this.__info_of__innerSize = {\n      type: \"GraphSize\",\n      txt: \"the size of the current element relative to the last (most nested) graph level.\"\n    };\n    this.__info_of__size = {\n      type: \"GraphSize\",\n      txt: \"same as innerSize.\"\n    };\n    this.__info_of__isselected = {\n      type: \"Dictionary<Pointer<User>, true>\",\n      txt: /*#__PURE__*/_jsxDEV(\"div\", {\n        children: [\"A map that contains all the users selecting this element as keys, and always true as a value (if present).\", /*#__PURE__*/_jsxDEV(\"br\", {}, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 565,\n          columnNumber: 13\n        }, this), \"Edit it through node.select() and node.deselect()\"]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 564,\n        columnNumber: 13\n      }, this)\n    };\n    this.__info_of_select = {\n      type: \"function(forUser?:Pointer<User>):void\",\n      txt: \"Marks this node as selected by argument user.\"\n    };\n    this.__info_of_deselect = {\n      type: \"function(forUser?:Pointer<User>):void\",\n      txt: \"Un-marks this node as selected by argument user.\"\n    };\n    this.__info_of_toggleSelect = {\n      type: \"function(usr?:Pointer<User>):void\",\n      txt: \"Calls this.select(usr) if the node is selected by argument user, this.deselect(usr) otherwise. If omitted, argument \\\"usr\\\" is the current user id.<br>Returns the result of this.isSelected() after the toggle.\"\n    };\n    this.__info_of_isSelected = {\n      type: \"function(forUser?:Pointer<User>):void\",\n      txt: \"Tells if this node is selected by argument user.\"\n    };\n  }\n  static getNodeId(o) {\n    var _node;\n    if (!o) return undefined;\n    let node = o;\n    // from L to D\n    // let cname = (node.__raw || node).className;\n    // from DModelE to LGraphE\n    if (RuntimeAccessibleClass.extends(o.className, \"DModelElement\")) node = LPointerTargetable.from(o).node;\n    return typeof node === \"string\" ? node : (_node = node) === null || _node === void 0 ? void 0 : _node.id;\n  }\n  // static singleton: LGraphElement;\n  // static logic: typeof LGraphElement;\n  // static structure: typeof DGraphElement;\n\n  // todo: can be removed and accessed by navigating .father\n\n  // protected isSelected!: Dictionary<DocString<Pointer<DUser>>, boolean>; //  & ((forUser?: Pointer<DUser>) => boolean);\n\n  // containedIn?: LGraphElement;\n  // shallow, direct subelements\n\n  // deep, nested subelements\n\n  // fittizi\n\n  // size and position in global document coordinates.\n\n  get_graph(context) {\n    return this.get_innerGraph(context);\n  }\n  get_edgesIn(context) {\n    return LPointerTargetable.fromArr(context.data.edgesIn);\n  }\n  get_edgesOut(context) {\n    return LPointerTargetable.fromArr(context.data.edgesOut);\n  }\n  set_edgesIn(val, c) {\n    return SetFieldAction.new(c.data.id, \"edgesIn\", Pointers.fromArr(val), '', true);\n  }\n  set_edgesOut(val, c) {\n    return SetFieldAction.new(c.data.id, \"edgesOut\", Pointers.fromArr(val), '', true);\n  }\n  get_edgesStart(context) {\n    return this.get_edgesIn(context);\n  }\n  get_edgesEnd(context) {\n    return this.get_edgesOut(context);\n  }\n  set_edgesStart(val, context) {\n    return this.set_edgesIn(val, context);\n  }\n  set_edgesEnd(val, context) {\n    return this.set_edgesOut(val, context);\n  }\n  _defaultCollectionGetter(c, k) {\n    return LPointerTargetable.fromPointer(c.data[k]);\n  }\n  _defaultGetter(c, k) {\n    //console.log(\"default Getter\");\n    if (k in c.data) {\n      let v = c.data[k];\n      if (Array.isArray(v)) {\n        if (v.length === 0) return [];else if (Pointers.isPointer(v[0])) return this._defaultCollectionGetter(c, k);\n        return v;\n      } else return v;\n    }\n    let ret;\n    let view = this.get_view(c);\n    try {\n      ret = view[k];\n    } catch (e) {\n      Log.ee(\"Could not find get_ property \\\"\" + k + \"\\\" in node or view.\", {\n        c,\n        view,\n        k\n      });\n      return undefined;\n    }\n    return ret;\n  }\n  _defaultSetter(v, c, k) {\n    console.log(\"default Setter\");\n    if (k in c.data) {\n      let isPointer;\n      if (Array.isArray(v)) {\n        if (v.length === 0) isPointer = true; // assumed, should not cause harm if it is not.\n        // it will delete remove an entry in pointedBy from all oldValue entries in the array that should not be present anyway.\n        // like oldVal.map( id => U.arrayRemove(LData.wrap(id).pointedBy, c.data.this_id)\n        else isPointer = Pointers.isPointer(v[0]);\n      } else isPointer = false;\n      return SetFieldAction.new(c.data.id, k, v, '', isPointer);\n    }\n    let view = this.get_view(c);\n    try {\n      view[k] = v;\n    } catch (e) {\n      Log.ee(\"Could not find set_ property \\\"\" + k + \"\\\" in node or view.\", {\n        c,\n        v,\n        k,\n        view\n      });\n      return false;\n    }\n    return true;\n  }\n  get_graphAncestors(c) {\n    let current = c.proxyObject;\n    let next = current.father;\n    let ret = [];\n    while (next) {\n      if (RuntimeAccessibleClass.extends(next.className, DGraph.cname)) ret.push(next);\n      if (current.id === next.id) break;\n      current = next;\n      next = next.father;\n    }\n    return ret;\n  }\n  get_outerGraph(context) {\n    // todo: this relies on the fact that GraphVertex are not passing their own id to their childrens, but the parent graph id\n    return TargetableProxyHandler.wrap(context.data.graph);\n  }\n  get_vertex(context) {\n    let lcurrent = LPointerTargetable.fromPointer(context.data.id);\n    let dcurrent = lcurrent.__raw;\n    // iterate parents.\n    while (dcurrent) {\n      switch (dcurrent.className) {\n        case DVertex.cname:\n        case DVoidVertex.cname:\n        case DGraphVertex.cname:\n          return lcurrent || LPointerTargetable.fromD(dcurrent);\n        default:\n          if (!dcurrent.father || dcurrent.id === dcurrent.father) return undefined;\n          Log.exDev(!dcurrent.father || dcurrent.id === dcurrent.father, \"node failed to get containing vertex\", context.data, dcurrent, lcurrent);\n          lcurrent = LPointerTargetable.fromPointer(dcurrent.father);\n          dcurrent = lcurrent.__raw;\n      }\n    }\n    return undefined;\n  }\n  get_innerGraph(context) {\n    var _lcurrent;\n    let lcurrent = LPointerTargetable.fromPointer(context.data.father);\n    let dcurrent = (_lcurrent = lcurrent) === null || _lcurrent === void 0 ? void 0 : _lcurrent.__raw;\n\n    // if no parent, but it's a graph, return itself.\n    if (!dcurrent) {\n      dcurrent = context.data;\n      switch (dcurrent.className) {\n        case DGraph.cname:\n        case DGraphVertex.cname:\n          return lcurrent || LPointerTargetable.fromD(dcurrent);\n        default:\n          return Log.exDevv(\"node failed to get containing graph\", context.data, dcurrent, lcurrent);\n      }\n    }\n\n    // if it have a parent, iterate parents.\n    while (true) {\n      var _dcurrent;\n      switch ((_dcurrent = dcurrent) === null || _dcurrent === void 0 ? void 0 : _dcurrent.className) {\n        case DGraph.cname:\n        case DGraphVertex.cname:\n          return lcurrent || LPointerTargetable.fromD(dcurrent);\n        default:\n          if (!dcurrent.father || dcurrent.id === dcurrent.father) {\n            /*switch(dcurrent.className){\r\n                case DGraph.name:\r\n                case DGraphVertex.name: return (lcurrent || LPointerTargetable.fromD(dcurrent)) as LGraph;\r\n                default: */\n            return Log.exDevv(\"node failed to get containing graph\", context.data, dcurrent, lcurrent);\n            //}\n          }\n          lcurrent = LPointerTargetable.fromPointer(dcurrent.father);\n          dcurrent = lcurrent.__raw;\n      }\n    }\n  }\n\n  // set_x(val: this[\"x\"], context: Context): boolean { SetFieldAction.new(context.data.id, \"x\", val, undefined, false); return true; }\n  // get_x(context: Context): this[\"x\"] { return context.data.x; }\n  get_x(context) {\n    return this.get_size(context).x;\n  }\n  set_x(val, context) {\n    return this.set_size({\n      x: val\n    }, context);\n  }\n  get_y(context) {\n    return this.get_size(context).y;\n  }\n  set_y(val, context) {\n    return this.set_size({\n      y: val\n    }, context);\n  }\n  get_w(context) {\n    return this.get_size(context).w;\n  }\n  set_w(val, context) {\n    return this.set_size({\n      w: val\n    }, context);\n  }\n  get_h(context) {\n    return this.get_size(context).h;\n  }\n  set_h(val, context) {\n    return this.set_size({\n      h: val\n    }, context);\n  }\n  get_width(context) {\n    return this.get_w(context);\n  }\n  set_width(val, context) {\n    return this.set_w(val, context);\n  }\n  get_height(context) {\n    return this.get_h(context);\n  }\n  set_height(val, context) {\n    return this.set_h(val, context);\n  }\n  get_position(context) {\n    return new GraphPoint(context.data.x, context.data.y);\n  }\n  set_position(val, context) {\n    BEGIN();\n    SetFieldAction.new(context.data.id, \"x\", val.x, undefined, false);\n    SetFieldAction.new(context.data.id, \"y\", val.y, undefined, false);\n    END();\n    return true;\n  }\n  get_sizeold(context) {\n    return new GraphSize(context.data.x, context.data.y, context.data.w, context.data.h);\n  }\n  get_component(context) {\n    // switch(context.data.className) { case DEdgePoint.name: return GraphElementComponent.map[context.data.father]; }\n    return GraphElementComponent.map[context.data.id];\n  }\n  // get_view(context: Context): this[\"view\"] { return this.get_component(context).props.view; }\n  get_view(context) {\n    var _this$get_component;\n    return (_this$get_component = this.get_component(context)) === null || _this$get_component === void 0 ? void 0 : _this$get_component.props.view;\n    // return LPointerTargetable.fromPointer(context.data.view);\n  }\n  set_view(val, context) {\n    Log.eDevv(\"node.view is readonly, change it through props or the model\");\n    // let ptr: DGraphElement[\"view\"] = Pointers.from(val as this[\"view\"]);\n    // return SetFieldAction.new(context.data.id, \"view\", ptr, '', true);\n  }\n  getSize() {\n    let outer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    let canTriggerSet = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    return this.wrongAccessMessage(\"getSize()\");\n  }\n  get_getSize(c) {\n    var _this = this;\n    return function () {\n      let outer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n      let canTriggerSet = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      return _this.get_innerSize(c, canTriggerSet, outer);\n    };\n  }\n  get_outerSize(context) {\n    let canTriggerSet = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    return this.get_innerSize(context, canTriggerSet, true);\n  }\n  get_size(context) {\n    let canTriggerSet = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    return this.get_innerSize(context, canTriggerSet, false);\n  }\n  get_innerSize(context) {\n    let canTriggerSet = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    let outerSize = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    let r = this.get_innerSize_impl(context, canTriggerSet, outerSize);\n    return new GraphSize(r.x, r.y, r.w, r.h);\n  }\n  get_innerSize_impl(context) {\n    var _component$props;\n    let canTriggerSet = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    let outerSize = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    canTriggerSet = canTriggerSet && !Debug.lightMode;\n    switch (context.data.className) {\n      default:\n        return Log.exDevv(\"unexpected classname in get_size switch: \" + context.data.className);\n      case DEdge.cname:\n      case DVoidEdge.cname:\n      case DGraph.cname:\n        return nosize;\n      // case DField.cname:\n      case DGraphElement.cname:\n        let graph = outerSize ? this.get_outerGraph(context) : this.get_innerGraph(context);\n        return graph.coord(this.get_htmlSize(context));\n      case DVoidVertex.cname:\n      case DVertex.cname:\n      case DEdgePoint.cname:\n      case DGraphVertex.cname:\n        break;\n    }\n    // low prio todo: memoization in proxy, as long state does not change keep a collection Dictionary[object][key] = returnval. it gets emptied when state is updated.\n    /*console.log(\"get_size(\"+(this.props?.data as any).name+\")\", {\r\n        view:this.props.view.getSize(this.props.dataid || this.props.nodeid as string),\r\n        node:this.props.node?.size,\r\n        default: this.props.view.defaultVSize});*/\n    let component = this.get_component(context);\n    // windoww.debugg = context;\n    // console.log(\"edgee getsize\", {component, view:component?.props?.view, data:{...context.data}});\n    let view = (component === null || component === void 0 ? void 0 : (_component$props = component.props) === null || _component$props === void 0 ? void 0 : _component$props.view) || this.get_view(context);\n    // (window as any).retry = ()=>view.getSize(context.data.id);\n    let ret = view.getSize(context.data.id); // (this.props.dataid || this.props.nodeid as string)\n    // console.log(\"getSize() from view\", {ret: ret ? {...ret} : ret});\n    if (!ret) {\n      ret = new GraphSize();\n      ret.x = context.data.x;\n      ret.y = context.data.y;\n      ret.w = context.data.w;\n      ret.h = context.data.h;\n      let def;\n      if (undefined === ret.x) {\n        if (!def) def = view.defaultVSize;\n        ret.x = def.x;\n      }\n      if (undefined === ret.y) {\n        if (!def) def = view.defaultVSize;\n        ret.y = def.y;\n      }\n      if (undefined === ret.w) {\n        if (!def) def = view.defaultVSize;\n        ret.w = def.w;\n      }\n      if (undefined === ret.h) {\n        if (!def) def = view.defaultVSize;\n        ret.h = def.h;\n      }\n      // console.log(\"getSize() from node merged with defaultVSize\", {ret: ret ? {...ret} : ret});\n    }\n    if (context.data.className === DEdgePoint.cname) {\n      ret = this.decodePosCoords(context, ret, view);\n    }\n    /*\r\n            if ((context.data as DVoidVertex).isResized) {\r\n                return ret;\r\n            }*/\n    if (!canTriggerSet) {\n      if (outerSize) ret = this.get_outerGraph(context).translateSize(ret, this.get_innerGraph(context));\n      return ret;\n    }\n    let html = component === null || component === void 0 ? void 0 : component.html;\n    let actualSize = (html === null || html === void 0 ? void 0 : html.current) ? Size.of(html.current) : {\n      w: 0,\n      h: 0\n    };\n    let updateSize = false;\n    let isOldElement = context.data.clonedCounter > 3;\n    // if w = 0 i don't auto-set it as in first render it has w:0 because is not reredered and not resized.\n    // if (canTriggerSet) this.set_size({w:actualSize.w}, context);\n    if (view.adaptWidth && ret.w !== actualSize.w) {\n      if (canTriggerSet && (isOldElement || actualSize.w !== 0)) {\n        ret.w = actualSize.w;\n        updateSize = true;\n      }\n    }\n    if (view.adaptHeight && ret.h !== actualSize.h) {\n      if (canTriggerSet && (isOldElement || actualSize.h !== 0)) {\n        ret.h = actualSize.h;\n        updateSize = true;\n      }\n    }\n    // console.log(\"getSize() from node merged with actualSize\", {ret: {...ret}});\n\n    if (updateSize) this.set_size(ret, context);\n    if (outerSize) ret = this.get_outerGraph(context).translateSize(ret, this.get_innerGraph(context));\n    return ret;\n  }\n  // set_size(size: Partial<this[\"size\"]>, context: Context): boolean {\n  set_size(size, c) {\n    // console.log(\"setSize(\"+(this.props?.data as any).name+\") thisss\", this);\n    if (!size) return false;\n    let view = this.get_view(c);\n    if (c.data.className === DEdgePoint.cname) size = this.encodePosCoords(c, size, view);\n    if (view.updateSize(c.data.id, size)) return true;\n    BEGIN();\n    if (size.x !== c.data.x && size.x !== undefined) SetFieldAction.new(c.data.id, \"x\", size.x, undefined, false);\n    if (size.y !== c.data.y && size.y !== undefined) SetFieldAction.new(c.data.id, \"y\", size.y, undefined, false);\n    if (size.w !== c.data.w && size.w !== undefined) SetFieldAction.new(c.data.id, \"w\", size.w, undefined, false);\n    if (size.h !== c.data.h && size.h !== undefined) SetFieldAction.new(c.data.id, \"h\", size.h, undefined, false);\n    END();\n    return true;\n  }\n  get_html(context) {\n    return this.get_component(context).html.current || undefined;\n  }\n  // get_html(context: Context): this[\"html\"] { return $(\"[node-id='\" + context.data.id + \"']\")[0]; }\n  set_html(val, context) {\n    return this.cannotSet(\"set_html(). html is generated through jsx. edit the view instead.\");\n  }\n  get_htmlSize(context) {\n    let html = this.get_html(context);\n    return html ? Size.of(html) : new Size(0, 0, 0, 0);\n    /*\r\n    let graph = this.get_graph(context);\r\n    if (!html) return nosize as any;\r\n    let size = Size.of(html);\r\n    let zoom = graph.zoom;\r\n    size.x /= zoom.x;\r\n    size.y /= zoom.y;\r\n    return size;*/\n  }\n  set_htmlSize(val, context) {\n    // might be useful for fixed display size/location elements that stay in place even if you move tab or change zoom. debatable if needed\n    this.cannotSet(\"set_htmlSize(): todo extra low priority. set GraphSize through set_size instead.\");\n    return true;\n  }\n  get_htmlPosition(context) {\n    return this.get_htmlSize(context).tl();\n  }\n  set_htmlPosition(val, context) {\n    // might be useful for fixed display size/location elements that stay in place even if you move tab or change zoom. debatable if needed\n    this.cannotSet(\"set_htmlPosition(): todo extra low priority. set graph position through set_position instead.\");\n    return true;\n  }\n\n  /* how z-index work, it's really messy.\r\n  * cannot move html position. node id depends on it, and a node moving position would need to change id.\r\n  * so i use css order.\r\n  * first order is assigned through node constructor called by parent component injectProps, according to his last index in html.\r\n  * now z-index is set in node and updated properly.\r\n  * z-index is passed to a prop, rendered as html attribute.\r\n  * css takes the attribute value and uses it in \"order\" css rule.\r\n  * problem: updating node.z doesn't trigger the parent injectprops, so he inject html index and\r\n  * the outernmost html root cannot update his attribute without refreshing the parent and recalling injectprops\r\n  * fixed: by updating it directly in GraphElement.render()\r\n  * */\n  get_zIndex(context) {\n    return context.data.zIndex;\n  }\n  set_zIndex(val, context) {\n    SetFieldAction.new(context.data.id, \"zIndex\", val, undefined, false);\n    return true;\n  }\n  get_z(context) {\n    return context.data.zIndex;\n  }\n  set_z(val, context) {\n    return this.set_zIndex(val, context);\n  }\n  /*\r\n      get_containedIn(context: Context): this[\"containedIn\"] {\r\n          return context.data.containedIn ? LPointerTargetable.fromPointer(context.data.containedIn) : undefined; }\r\n      set_containedIn(val: Pack1<this[\"containedIn\"]>, context: LogicContext<DGraphElement>): boolean {\r\n          let ptr: DGraphElement[\"containedIn\"] = Pointers.from(val) as any;\r\n          SetFieldAction.new(context.data, 'containedIn', ptr, undefined, true);\r\n          if (ptr) SetFieldAction.new(ptr as any, 'subElements+=', context.data.id);\r\n          return true; }*/\n\n  get_subElements(context) {\n    return LPointerTargetable.fromArr([...new Set(context.data.subElements)]);\n  }\n  set_subElements(val, context) {\n    console.log(\"isDeepStrictEqual\", {\n      isDeepStrictEqual\n    });\n    Log.eDev([...new Set(val)].length !== val.length, \"subelemnts setter have duplicates\", {\n      val,\n      context\n    });\n    // if (isDeepStrictEqual(context.data.subElements, val)) return true;\n    let pointers = Pointers.from(val) || [];\n    if (Uarr.equals(pointers, context.data.subElements, false)) return true;\n    SetFieldAction.new(context.data, 'subElements', pointers, '', true);\n    const idlookup = store.getState().idlookup;\n    let arrdiff = U.arrayDifference(context.data.subElements, pointers);\n    // old subelements\n    for (let oldsubelementid of arrdiff.removed) {\n      let subelement = oldsubelementid && idlookup[oldsubelementid];\n      if (subelement.father !== context.data.id) continue;\n      LPointerTargetable.from(subelement).father = null; // todo: can this happen? è transitorio o causa vertici senza parent permanenti?\n    }\n    // new subelements\n    for (let newsubelementid of arrdiff.added) {\n      let subelement = newsubelementid && idlookup[newsubelementid];\n      if (subelement.father === context.data.id) continue;\n      LPointerTargetable.from(subelement).father = context.data.id; // trigger side-action\n    }\n    return true;\n  }\n  get_isResized(context) {\n    return context.data.isResized;\n  }\n  set_isResized(val, context) {\n    return SetFieldAction.new(context.data.id, \"isResized\", val);\n  }\n  get_model(context) {\n    const modelElementId = $('[id=\"' + context.data.id + '\"]')[0].dataset.dataid;\n    const lModelElement = LPointerTargetable.from(modelElementId);\n    return lModelElement;\n  }\n  get_allSubNodes(context, state) {\n    // return context.data.packages.map(p => LPointerTargetable.from(p));\n    state = state || store.getState();\n    let tocheck = context.data.subElements || [];\n    let checked = {};\n    let dblcheck = {}; // <child, parent>  // debug only\n    for (let e of tocheck) dblcheck[e] = context.data.id; // debug only\n    checked[context.data.id] = true; //nb6[]{}&\n    while (tocheck.length) {\n      let newtocheck = [];\n      for (let ptr of tocheck) {\n        Log.eDev(checked[ptr], \"loop in GraphElements containing themselves\", {\n          dblcheck,\n          context,\n          ptr,\n          checked,\n          fistContainer: dblcheck[ptr]\n        });\n        if (checked[ptr]) continue;\n        checked[ptr] = true;\n        let subnode = DPointerTargetable.from(ptr, state);\n        let se = subnode === null || subnode === void 0 ? void 0 : subnode.subElements;\n        for (let e of se) dblcheck[e] = ptr; // debug only\n        U.arrayMergeInPlace(newtocheck, se);\n      }\n      tocheck = newtocheck;\n    }\n    delete checked[context.data.id];\n    return LPointerTargetable.from(Object.keys(checked), state);\n  }\n  get_father(context) {\n    return LPointerTargetable.fromPointer(context.data.father);\n  }\n  set_father(val, context) {\n    let ptr = Pointers.from(val);\n    SetFieldAction.new(context.data, 'father', ptr, undefined, true);\n    if (ptr) SetFieldAction.new(ptr, 'subElements+=', context.data.id);\n    return true;\n  }\n  select(forUser) {\n    return this.wrongAccessMessage(\"node.select()\");\n  }\n  deselect(forUser) {\n    return this.wrongAccessMessage(\"node.deselect()\");\n  }\n  toggleSelected(forUser) {\n    return this.wrongAccessMessage(\"node.toggleSelected()\");\n  }\n  isSelected(forUser) {\n    return this.wrongAccessMessage(\"node.isSelected()\");\n  }\n  get_select(c) {\n    return forUser => {\n      if (!forUser) forUser = DUser.current;\n      if (c.data.isSelected[forUser]) return; // no-op\n      let map = {\n        ...c.data.isSelected\n      };\n      map[forUser] = true;\n      SetFieldAction.new(c.data.id, \"isSelected\", map, undefined, false);\n      // todo: actually they are pointer to users, but i'm assuming users are not erased at runtime. on deselect too\n    };\n  }\n  get_deselect(c) {\n    return forUser => {\n      if (!forUser) forUser = DUser.current;\n      if (!c.data.isSelected[forUser]) return; // no-op\n      let map = {\n        ...c.data.isSelected\n      };\n      delete map[forUser];\n      SetFieldAction.new(c.data.id, \"isSelected\", map, undefined, false);\n      // todo: actually they are pointer to users, but i'm assuming users are not erased at runtime. on deselect too\n    };\n  }\n  get_toggleSelected(context) {\n    return forUser => {\n      if (!forUser) forUser = DUser.current;\n      if (this.get_isSelected(context)(forUser)) {\n        this.get_deselect(context)(forUser);\n        return false;\n      } else {\n        this.get_select(context)(forUser);\n        return true;\n      }\n    };\n  }\n  get_isSelected(context) {\n    return forUser => {\n      if (!forUser) forUser = DUser.current;\n      return !!context.data.isSelected[forUser];\n    };\n  }\n  set_isSelected(val, context) {\n    return this.cannotSet(\"graphElement.isSelected(): use this.select() or this.deselect() instead.\");\n  }\n  /*\r\n  get_isSelected(context: LogicContext<DVoidVertex>): GObject {\r\n      return DPointerTargetable.mapWrap(context.data.isSelected, context.data, 'idlookup.' + context.data.id + '.isSelected', []);\r\n  }*/\n\n  get_state(context) {\n    let state = context.data.state;\n    for (let key in state) {\n      switch (key) {\n        case \"id\":\n          break;\n        default:\n          state[key] = LPointerTargetable.wrap(state[key]);\n          break;\n      }\n    }\n    return state;\n  }\n  set_state(val, context) {\n    return this.cannotSet(\"graphElement.setstate(): todo\");\n  }\n\n  // for edges\n  get_startPoint(c, size, view) {\n    return this.get_startEndPoint(c, size, view, true);\n  }\n  get_endPoint(c, size, view) {\n    return this.get_startEndPoint(c, size, view, false);\n  }\n  get_startEndPoint(c, size, view) {\n    let isStart = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n    if (!size) {\n      if (c) size = this.get_size(c);else size = Log.exDevv(\"invalid arguments in get_startEndPoint\", {\n        arguments\n      });\n    }\n    if (!view) {\n      // if (c) view = this.get_view(c); else view = Log.exDevv(\"invalid arguments in get_startPoint\", {arguments});\n      view = c && this.get_view(c) || Log.exDevv(\"invalid arguments in get_startEndPoint\", {\n        arguments\n      });\n    }\n    let offset = view[isStart ? \"edgeStartOffset\" : \"edgeEndOffset\"];\n    let isPercentage = view[isStart ? \"edgeStartOffset_isPercentage\" : \"edgeEndOffset_isPercentage\"];\n    if (!size) size = new GraphSize(0, 0, 0, 0);\n    if (isPercentage) offset = new GraphPoint(offset.x / 100 * size.w, offset.y / 100 * size.h);\n    return size.tl().add(offset, false);\n  }\n}, _class4.subclasses = [], _class4._extends = [], _class4)) || _class3);\nRuntimeAccessibleClass.set_extend(DPointerTargetable, DGraphElement);\nRuntimeAccessibleClass.set_extend(LPointerTargetable, LGraphElement);\nexport let DGraph = (_dec3 = RuntimeAccessible('DGraph'), _dec3(_class5 = (_class6 = class DGraph extends DGraphElement {\n  constructor() {\n    super(...arguments);\n    this.father = void 0;\n    this.id = void 0;\n    this.graph = void 0;\n    this.model = void 0;\n    this.isSelected = void 0;\n    this.subElements = void 0;\n    this.state = {};\n    this.zoom = void 0;\n    this.offset = void 0;\n  } // static _super = DGraphElement;\n  // static singleton: LGraph;\n  // static logic: typeof LGraph;\n  // static structure: typeof DGraph;\n  // inherit redefine\n  // containedIn!: Pointer<DGraphElement, 0, 1, LGraphElement>;\n  // personal attributes\n  // in-graph scrolling offset\n\n  static new(htmlindex, model, parentNodeID,\n  // immediate parent\n  parentgraphID,\n  // graph containing this subgraph (redudant? could get it from father chain)\n  nodeID) {\n    return new Constructors(new DGraph('dwc'), parentNodeID, true, undefined, nodeID || Constructors.DGraph_makeID(model)).DPointerTargetable().DGraphElement(model, parentgraphID, htmlindex).DGraph().end();\n  }\n  static getNodes(dmp, out) {\n    let $allnodes = $('[data-dataid]');\n    let matchedids = (dmp || []).map(d => d.id);\n    let matchedidmap = U.objectFromArrayValues(matchedids);\n    if (!out) out = {};\n    let allnodesarr = [...$allnodes];\n    let filternode = d => {\n      var _d$dataset, _d$dataset2;\n      if (!(d === null || d === void 0 ? void 0 : (_d$dataset = d.dataset) === null || _d$dataset === void 0 ? void 0 : _d$dataset.dataid)) return false;\n      let id = '' + (d === null || d === void 0 ? void 0 : (_d$dataset2 = d.dataset) === null || _d$dataset2 === void 0 ? void 0 : _d$dataset2.dataid);\n      return matchedidmap[id];\n    };\n    out.$matched = $(allnodesarr.filter(filternode));\n    out.$notMatched = $(allnodesarr.filter(n => !filternode(n)));\n    return out.$matched;\n    // throw new Error(\"Method not implemented.\");\n  }\n}, _class6.subclasses = [], _class6._extends = [], _class6)) || _class5);\nvar nosize = {\n  x: 0,\n  y: 0,\n  w: 0,\n  h: 0,\n  nosize: true\n};\nvar defaultEdgePointSize = {\n  x: 0,\n  y: 0,\n  w: 5,\n  h: 5\n};\nvar defaultVertexSize = {\n  x: 0,\n  y: 0,\n  w: 140.6818084716797,\n  h: 32.52840805053711\n};\nexport let LGraph = (_dec4 = RuntimeAccessible('LGraph'), _dec4(_class7 = (_class8 = class LGraph extends LGraphElement {\n  constructor() {\n    super(...arguments);\n    this.__raw = void 0;\n    this.id = void 0;\n    this.graph = void 0;\n    this.model = void 0;\n    this.subElements = void 0;\n    this.state = void 0;\n    this.zoom = void 0;\n    this.graphSize = void 0;\n    this.offset = void 0;\n    this.__info_of__zoom = {\n      type: GraphPoint.cname,\n      label: \"zoom\",\n      txt: \"Scales the graph and all subelements by a factor.\"\n    };\n    this.__info_of__offset = {\n      type: GraphPoint.cname,\n      label: \"offset\",\n      txt: \"In-graph scrolling position.\"\n    };\n    this.__info_of__graphSize = {\n      type: GraphSize.cname,\n      label: \"graphSize\",\n      txt: \"size internal to the graph, including internal scroll and panning.\"\n    };\n    this.__info_of__translateSize = {\n      type: \"(T, Graph)=>T where T is GraphSize | GraphPoint\",\n      txt: \"Translates a coordinate set from the local coordinates of a SubGraph to this Graph containing it.\"\n    };\n    this.__info_of__translateHtmlSize = {\n      type: \"(Size|Point) => GraphSize|GraphPoint\",\n      txt: \"Translate page\\'s viewport coordinate set to this graph coordinate set.\"\n    };\n  } // static singleton: LGraph;\n  // static logic: typeof LGraph;\n  // static structure: typeof DGraph;\n  // inherit redefine\n  // isSelected: Dictionary<DocString<Pointer<DUser>>, boolean> = {};\n  isSelected(forUser) {\n    return this.wrongAccessMessage(\"node.isSelected()\");\n  }\n  // containedIn?: LGraphElement;\n\n  // personal attributes\n\n  // derived attribute: bounding rect containing all subnodes, while \"size\" is instead external size of the vertex holding the graph in GraphVertexes\n\n  // Scrolling position inside the graph\n\n  // get_graphSize(context: LogicContext<DGraph>):  Readonly<GraphSize> { return todo: get bounding rect containing all subnodes.; }\n  get_offset(context) {\n    return new GraphSize(context.data.offset.x, context.data.offset.y);\n  }\n  set_offset(val, context) {\n    if (!val) val = {\n      x: 0,\n      y: 0\n    };\n    if (context.data.offset.x === val.x && context.data.offset.y === val.y) return true;\n    if (val.x === undefined && context.data.offset.x !== val.x) val.x = context.data.offset.x;\n    if (val.y === undefined && context.data.offset.y !== val.y) val.y = context.data.offset.y;\n    SetFieldAction.new(context.data, \"offset\", val);\n    return true;\n  }\n  get_zoom(context) {\n    const zoom = context.data.zoom;\n    // (zoom as any).debug = {rawgraph: context.data.__raw, zoomx: context.data.zoom.x, zoomy: context.data.zoom.y}\n    return context.data.zoom;\n  }\n  toGraphSize() {\n    return this.wrongAccessMessage(\"toGraphSize\");\n  }\n  coord(htmlSize) {\n    return this.wrongAccessMessage(\"toGraphSize\");\n  }\n  get_coord(context) {\n    return htmlSize => {\n      let size = this.get_htmlSize(context);\n      let zoom = this.get_zoom(context);\n      return new GraphSize((htmlSize.x - size.x) / zoom.x, (htmlSize.y - size.y) / zoom.y, htmlSize.w / zoom.x, htmlSize.h / zoom.y);\n    };\n  }\n  // get_htmlSize(context: Context): Size { }\n  translateSize(ret, innerGraph) {\n    return this.wrongAccessMessage(\"translateSize()\");\n  }\n  translateHtmlSize(size) {\n    return this.wrongAccessMessage(\"translateHtmlSize()\");\n  }\n  get_translateHtmlSize(c) {\n    return size => {\n      let graphHtmlSize = this.get_htmlSize(c);\n      let a = size.subtract(graphHtmlSize.tl(), true);\n      let b = a.add({\n        x: c.data.offset.x,\n        y: c.data.offset.y\n      }, false);\n      return b.multiply(c.data.zoom, false);\n    };\n  }\n  get_translateSize(c) {\n    return (size, innerGraph) => {\n      innerGraph = LPointerTargetable.wrap(innerGraph);\n      let ret = size.hasOwnProperty(\"w\") ? new GraphSize(size.x, size.y, size.w, size.h) : new GraphPoint(size.x, size.y);\n      Log.ex(!innerGraph, \"translateSize() graph parameter is invalid: \" + innerGraph, innerGraph, c);\n      let ancestors = [innerGraph, ...innerGraph.graphAncestors];\n      Log.ex(ancestors.indexOf(c.proxyObject) !== -1, \"translateSize() graph parameter is invalid: it must be a graph containing the current one.\", innerGraph, c);\n      for (let g of ancestors) ret.add(g.size.tl(), false);\n      // console.log(\"translateSize\", {c, thiss:c.proxyObject, ancestors, ancestorSizes: ancestors.map(a=> a.size.tl()), size, ret});\n      return ret;\n    };\n  }\n  contains(elem) {\n    return this.wrongAccessMessage(\"contains()\");\n  }\n  get_contains(c) {\n    return elem => {\n      let current = elem;\n      let next = elem.father;\n      let targetid = c.proxyObject.id;\n      if (current.id !== targetid) return true;\n      while (next && current.id !== next.id) {\n        current = next;\n        next = next.father;\n        if (current.id !== targetid) return true;\n      }\n      return false;\n    };\n  }\n}, _class8.subclasses = [], _class8._extends = [], _class8)) || _class7);\nRuntimeAccessibleClass.set_extend(DGraphElement, DGraph);\nRuntimeAccessibleClass.set_extend(LGraphElement, LGraph);\n// export const defaultVSize: GraphSize = new GraphSize(0, 0, 300, 160); // useless, now it's in view.DefaultVSize\n// export const defaultEPSize: GraphSize = new GraphSize(0, 0, 15, 15); // useless, now it's in view.DefaultVSize\n\nexport let DVoidVertex = (_dec5 = RuntimeAccessible('DVoidVertex'), _dec5(_class9 = (_class10 = class DVoidVertex extends DGraphElement {\n  constructor() {\n    super(...arguments);\n    this.id = void 0;\n    this.graph = void 0;\n    this.model = void 0;\n    this.isSelected = void 0;\n    this.subElements = void 0;\n    this.state = {};\n    this.zoom = void 0;\n    this.x = void 0;\n    this.y = void 0;\n    this.w = void 0;\n    this.h = void 0;\n    this.isResized = void 0;\n  } // static _super = DGraphElement;\n  // static singleton: LVoidVertex;\n  // static logic: typeof LVoidVertex;\n  // static structure: typeof DVoidVertex;\n  // inherit redefine\n  // containedIn!: Pointer<DGraphElement, 0, 1, LGraphElement>;\n  // personal attributes\n  // size?: GraphSize; // virtual, gets extracted from this. x and y are stored directly here as it extends GraphSize\n\n  static new(htmlindex, model, parentNodeID, graphID, nodeID, size) {\n    return new Constructors(new DVoidVertex('dwc'), parentNodeID, true, undefined, nodeID).DPointerTargetable().DGraphElement(model, graphID, htmlindex).DVoidVertex(size || defaultVertexSize).end();\n  }\n}, _class10.subclasses = [], _class10._extends = [], _class10)) || _class9);\nexport let LVoidVertex = (_dec6 = RuntimeAccessible('LVoidVertex'), _dec6(_class11 = (_class12 = class LVoidVertex extends LGraphElement {\n  constructor() {\n    super(...arguments);\n    this.__raw = void 0;\n    this.id = void 0;\n    this.graph = void 0;\n    this.model = void 0;\n    this.subElements = void 0;\n    this.state = void 0;\n    this.zoom = void 0;\n    this.isResized = void 0;\n    this.x = void 0;\n    this.y = void 0;\n    this.w = void 0;\n    this.h = void 0;\n    this.size = void 0;\n    this.__info_of__size = {\n      type: \"?GraphSize\",\n      txt: \"Size of the vertex, if null it means is utilizing the defaultSize from view. recommended to read component.getSize() instead of this.\"\n    };\n  } // <D extends DVoidVertex = any>\n  // static singleton: LVoidVertex;\n  // static logic: typeof LVoidVertex;\n  // static structure: typeof DVoidVertex;\n  // inherit redefine\n  // isSelected: Dictionary<DocString<Pointer<DUser>>, boolean> = {};\n  isSelected(forUser) {\n    return this.wrongAccessMessage(\"node.isSelected()\");\n  }\n  // containedIn?: LGraphElement;\n\n  // personal attributes\n\n  // virtual, gets extracted from this. x and y are stored directly here as it extends GraphSize\n\n  get_isResized(context) {\n    return context.data.isResized;\n  }\n  set_isResized(val, context) {\n    return SetFieldAction.new(context.data.id, \"isResized\", val);\n  }\n}, _class12.subclasses = [], _class12._extends = [], _class12)) || _class11);\nRuntimeAccessibleClass.set_extend(DGraphElement, DVoidVertex);\nRuntimeAccessibleClass.set_extend(LGraphElement, LVoidVertex);\nexport let DEdgePoint = (_dec7 = RuntimeAccessible('DEdgePoint'), _dec7(_class13 = (_class14 = class DEdgePoint extends DVoidVertex {\n  constructor() {\n    super(...arguments);\n    this.id = void 0;\n    this.father = void 0;\n    this.graph = void 0;\n    this.model = void 0;\n    this.isSelected = void 0;\n    this.subElements = void 0;\n    this.zoom = void 0;\n    this.x = void 0;\n    this.y = void 0;\n    this.w = void 0;\n    this.h = void 0;\n    this.size = void 0;\n    this.__isDEdgePoint = void 0;\n  } // DVoidVertex\n  // static singleton: LEdgePoint;\n  // static logic: typeof LEdgePoint;\n  // static structure: typeof DEdgePoint;\n  // inherit redefine\n  // todo: if null gets model from this.father (edge)?\n  // containedIn!: Pointer<DGraphElement, 0, 1, LGraphElement>;\n  //／／ virtual, gets extracted from this. x and y are stored directly here as it extends GraphSize\n  // personal attributes\n  static new(htmlindex, model, parentNodeID, graphID, nodeID, size) {\n    return new Constructors(new DEdgePoint('dwc'), parentNodeID, true, undefined, nodeID).DGraphElement(undefined, graphID, htmlindex).DVoidVertex(size || defaultEdgePointSize).DEdgePoint().end();\n  }\n}, _class14.subclasses = [], _class14._extends = [], _class14)) || _class13);\nexport let LEdgePoint = (_dec8 = RuntimeAccessible('LEdgePoint'), _dec8(_class15 = (_class16 = class LEdgePoint extends LVoidVertex {\n  constructor() {\n    super(...arguments);\n    this.father = void 0;\n    this.id = void 0;\n    this.graph = void 0;\n    this.model = void 0;\n    this.subElements = void 0;\n    this.zoom = void 0;\n    this.x = void 0;\n    this.y = void 0;\n    this.w = void 0;\n    this.h = void 0;\n    this.size = void 0;\n    this.__isLEdgePoint = void 0;\n    this.edge = void 0;\n    this.__info_of__edge = {\n      type: \"?LEdge\",\n      txt: \"returns the containing edge if called on an EdgePoint, \\\"this\\\" if called on an edge, undefined otherwise.\"\n    };\n  } // static singleton: LEdgePoint;\n  // static logic: typeof LEdgePoint;\n  // static structure: typeof DEdgePoint;\n  // inherit redefine\n  // __raw!: DEdgePoint;\n  // isSelected: Dictionary<DocString<Pointer<DUser>>, boolean> = {};\n  isSelected(forUser) {\n    return this.wrongAccessMessage(\"node.isSelected()\");\n  }\n  // containedIn?: LGraphElement;\n\n  // virtual, gets extracted from this. x and y are stored directly here as it extends GraphSize\n  // personal attributes\n\n  // returns container edge\n\n  get_edge(c) {\n    return c.proxyObject.father;\n  }\n  set_edge(v, c) {\n    return this.set_father(v, c);\n  }\n\n  // from x,y as coords, to x%,y% as % of ((1-val)%*startpt) + ((val)%*endpt)\n  decodePosCoords(c, size, view, sp0, ep0) {\n    if (!view) view = this.get_view(c);\n    let edgePointCoordMode = view.edgePointCoordMode;\n    if (edgePointCoordMode === CoordinateMode.absolute) return size;\n    let le = c && c.proxyObject.father;\n    // console.log(\"decodepos:\", {le, sp0, lesp:le?.startPoint});\n    let sp = sp0 || le.startPoint;\n    let ep = ep0 || le.endPoint;\n    let ret = \"w\" in size || \"h\" in size ? new GraphSize() : new GraphPoint(); // GObject<Partial<GraphSize>>;\n    switch (edgePointCoordMode) {\n      default:\n        return Log.exDevv(\"translatePosCoords() invalid coordinate mode\", {\n          mode: edgePointCoordMode,\n          view\n        });\n      // case CoordinateMode.absolute: return size;\n      case CoordinateMode.relativePercent:\n        //maybe do: dampening factor on relative % offset? is it possible?\n\n        // let s = this.getBasicSize(c);\n        // MATH:\n        // size.x = sp.x*x% + ep.x*(1-x%)\n        // size.x = sp.x*x% + ep.x - ep.x*x%\n        // size.x - ep.x= (sp.x - ep.x)*x%\n        // (size.x - ep.x) / (sp.x - ep.x) = x% // actually i inverted <sp, ep> in first equation, so reverse them in result too.\n        if (size.x !== undefined) ret.x = (1 - size.x) * sp.x + size.x * ep.x;\n        if (size.y !== undefined) ret.y = (1 - size.y) * sp.y + size.y * ep.y;\n        break;\n      case CoordinateMode.relativeOffset:\n      case CoordinateMode.relativeOffsetStart:\n      case CoordinateMode.relativeOffsetEnd:\n        let useStart;\n        let useEnd;\n        switch (edgePointCoordMode) {\n          default:\n          case CoordinateMode.relativeOffset:\n            useStart = true;\n            useEnd = true;\n            break;\n          case CoordinateMode.relativeOffsetStart:\n            useStart = true;\n            useEnd = false;\n            break;\n          case CoordinateMode.relativeOffsetEnd:\n            useStart = false;\n            useEnd = true;\n            break;\n        }\n        // offset = sp - size\n        // size = offset - sp\n        // in reverse: actualsize = offset, size=offset\n        Log.exDev(size.x && !Array.isArray(size.x) || size.y && !Array.isArray(size.y), \"decoding relative offset require an array size coordinate system. x=[x1, x2] --> x\", {\n          size\n        });\n        let offsetsp = useStart ? new GraphPoint(size.x[0] + sp.x, size.y[0] + sp.y) : new GraphPoint();\n        let offsetep = useEnd ? new GraphPoint(size.x[1] + ep.x, size.y[1] + ep.y) : new GraphPoint();\n        // if the start and endpoint of the edge didn't move, offsetsp = offsetep.\n        // if they moved, those 2 are discordant --> i pick middle\n        offsetsp.add(offsetep, false);\n        if (useStart && useEnd) offsetsp.divide(2, false);\n        if (size.x !== undefined) ret.x = offsetsp.x;\n        if (size.y !== undefined) ret.y = offsetsp.y;\n        break;\n    }\n    if (size.x === undefined) delete ret.x;\n    if (size.y === undefined) delete ret.y;\n    if (size.w === undefined) delete ret.w;else ret.w = size.w;\n    if (size.h === undefined) delete ret.h;else ret.h = size.h;\n    // console.log(\"decode coords\", {size, sp, ep, ret});\n\n    return ret;\n  }\n  encodePosCoords(c, size, view, sp0, ep0) {\n    if (!view) view = this.get_view(c);\n    let edgePointCoordMode = view.edgePointCoordMode;\n    if (edgePointCoordMode === CoordinateMode.absolute) return size;\n    let le = c && c.proxyObject.father;\n    let sp = sp0 || le.startPoint; //todo: delete sp0, ep0 parameters after testing\n    let ep = ep0 || le.endPoint;\n    let ret = \"w\" in size || \"h\" in size ? new GraphSize() : new GraphPoint(); // GObject<Partial<GraphSize>>;\n    switch (edgePointCoordMode) {\n      default:\n        return Log.exDevv(\"translatePosCoords() invalid coordinate mode\", {\n          mode: edgePointCoordMode,\n          view\n        });\n      // case CoordinateMode.absolute: return size;\n      case CoordinateMode.relativePercent:\n        // let s = this.getBasicSize(c);\n        // MATH:\n        // size.x = sp.x*x% + ep.x*(1-x%)\n        // size.x = sp.x*x% + ep.x - ep.x*x%\n        // size.x - ep.x= (sp.x - ep.x)*x%\n        // (size.x - ep.x) / (sp.x - ep.x) = x% // actually i inverted <sp, ep> in first equation, so reverse them in result too.\n        if (size.x !== undefined) ret.x = (size.x - sp.x) / (ep.x - sp.x);\n        if (size.y !== undefined) ret.y = (size.y - sp.y) / (ep.y - sp.y);\n        break;\n      case CoordinateMode.relativeOffset:\n      case CoordinateMode.relativeOffsetStart:\n      case CoordinateMode.relativeOffsetEnd:\n        let useStart;\n        let useEnd;\n        switch (edgePointCoordMode) {\n          default:\n          case CoordinateMode.relativeOffset:\n            useStart = true;\n            useEnd = true;\n            break;\n          case CoordinateMode.relativeOffsetStart:\n            useStart = true;\n            useEnd = false;\n            break;\n          case CoordinateMode.relativeOffsetEnd:\n            useStart = false;\n            useEnd = true;\n            break;\n        }\n        if (size.x) ret.x = [useStart ? size.x - sp.x : -1, useEnd ? size.x - ep.x : -1];\n        if (size.y) ret.y = [useStart ? size.y - sp.y : -1, useEnd ? size.y - ep.y : -1];\n        /*\r\n        if (size.x) ret.x = [sp.x - size.x, ep.x - size.x];\r\n        if (size.y) ret.y = [sp.y - size.y, ep.y - size.y];*/\n        break;\n    }\n    if (size.x === undefined) delete ret.x;\n    if (size.y === undefined) delete ret.y;\n    if (size.w === undefined) delete ret.w;else ret.w = size.w;\n    if (size.h === undefined) delete ret.h;else ret.h = size.h;\n    // console.log(\"encode coorde\", {size, sp, ep, ret});\n    return ret;\n  }\n\n  /* 13/10/2023 Giordano comment (defined in LPointerTargetable\r\n  public get_delete(context: Context): () => void {\r\n      // careful: pointedBy might be broken due to comment x984 (search it)\r\n      return super.get_delete(context);\r\n  }\r\n  */\n}, _class16.subclasses = [], _class16._extends = [], _class16)) || _class15);\nRuntimeAccessibleClass.set_extend(DVoidVertex, DEdgePoint);\nRuntimeAccessibleClass.set_extend(LVoidVertex, LEdgePoint);\nexport let DVertex = (_dec9 = RuntimeAccessible('DVertex'), _dec9(_class17 = (_class18 = class DVertex extends DGraphElement {\n  constructor() {\n    super(...arguments);\n    this.id = void 0;\n    this.graph = void 0;\n    this.model = void 0;\n    this.isSelected = void 0;\n    this.subElements = void 0;\n    this.zoom = void 0;\n    this.x = void 0;\n    this.y = void 0;\n    this.w = void 0;\n    this.h = void 0;\n    this.isResized = void 0;\n    this.__isDVertex = void 0;\n  } // DVoidVertex\n  // static _super = DVoidVertex;\n  // static singleton: LVertex;\n  // static logic: typeof LVertex;\n  // static structure: typeof DVertex;\n  // inherit redefine\n  // containedIn!: Pointer<DGraphElement, 0, 1, LGraphElement>;\n  // size!: GraphSize; // virtual, gets extracted from this. x and y are stored directly here as it extends GraphSize\n  // personal attributes\n  static new(htmlindex, model, parentNodeID, graphID, nodeID, size) {\n    return new Constructors(new DVertex('dwc'), parentNodeID, true, undefined, nodeID).DPointerTargetable().DGraphElement(model, graphID, htmlindex).DVoidVertex(size || defaultVertexSize).DVertex().end();\n  }\n}, _class18.subclasses = [], _class18._extends = [], _class18)) || _class17);\nexport let LVertex = (_dec10 = RuntimeAccessible('LVertex'), _dec10(_class19 = (_class20 = class LVertex extends LVoidVertex {\n  constructor() {\n    super(...arguments);\n    this.__raw = void 0;\n    this.id = void 0;\n    this.graph = void 0;\n    this.model = void 0;\n    this.subElements = void 0;\n    this.zoom = void 0;\n    this.x = void 0;\n    this.y = void 0;\n    this.w = void 0;\n    this.h = void 0;\n    this.size = void 0;\n    this.isResized = void 0;\n    this.__isLVertex = void 0;\n  } // static singleton: LVertex;\n  // static logic: typeof LVertex;\n  // static structure: typeof DVertex;\n  // inherit redefine\n  // isSelected: Dictionary<DocString<Pointer<DUser>>, boolean> = {};\n  isSelected(forUser) {\n    return this.wrongAccessMessage(\"node.isSelected()\");\n  }\n  // containedIn?: LGraphElement;\n\n  // virtual, gets extracted from this. x and y are stored directly here as it extends GraphSize\n\n  // personal attributes\n}, _class20.subclasses = [], _class20._extends = [], _class20)) || _class19);\nRuntimeAccessibleClass.set_extend(DGraphElement, DVertex);\nRuntimeAccessibleClass.set_extend(LGraphElement, LVertex);\nexport let DGraphVertex = (_dec11 = RuntimeAccessible('DGraphVertex'), Leaf(_class21 = _dec11(_class21 = (_class22 = class DGraphVertex extends DGraphElement {\n  constructor() {\n    super(...arguments);\n    this.id = void 0;\n    this.graph = void 0;\n    this.model = void 0;\n    this.isSelected = void 0;\n    this.subElements = void 0;\n    this.zoom = void 0;\n    this.offset = void 0;\n    this.x = void 0;\n    this.y = void 0;\n    this.w = void 0;\n    this.h = void 0;\n    this.isResized = void 0;\n    this.__isDVertex = void 0;\n    this.__isDGraph = void 0;\n    this.__isDGraphVertex = void 0;\n  } // MixOnlyFuncs(DGraph, DVertex)\n  // static _super1 = DGraph;\n  // static _super2 = DVertex;\n  // static singleton: LGraphVertex;\n  // static logic: typeof LGraphVertex;\n  // static structure: typeof DGraphVertex;\n  // inherit redefine\n  // containedIn!: Pointer<DGraphElement, 0, 1, LGraphElement>;\n  // from graph\n  // in-graph scrolling position\n  // from VoidVertex\n  // size!: GraphSize; // virtual\n  // from graph\n  // personal attributes\n  static new(htmlindex, model, parentNodeID, graphID, nodeID, size) {\n    return new Constructors(new DGraphVertex('dwc'), parentNodeID, true, undefined, nodeID).DPointerTargetable().DGraphElement(model, graphID, htmlindex).DVoidVertex(size || defaultVertexSize).DVertex().DGraph().end();\n  }\n\n  /*\r\n      static init_constructor(thiss: DGraphVertex, isUser: boolean = false, nodeID: string | undefined, graphID: string | undefined, model: Pointer<DModel>): void {\r\n          DGraph.init_constructor(thiss, isUser, nodeID, graphID, model);\r\n  //isUser: boolean = false, nodeID: string | undefined, graphID: string, model?: Pointer<DModel>\r\n          DVertex.init_constructor(thiss, isUser, nodeID, graphID as string, model);\r\n          thiss.className = this.name;\r\n      }*/\n}, _class22.subclasses = [], _class22._extends = [], _class22)) || _class21) || _class21);\nclass LG extends LGraph {}\nclass LV extends LVertex {}\nexport let LGraphVertex = (_dec12 = RuntimeAccessible('LGraphVertex'), _dec12(_class23 = (_class24 = class LGraphVertex extends MixOnlyFuncs(LG, LV) {\n  constructor() {\n    super(...arguments);\n    this.__raw = void 0;\n    this.id = void 0;\n    this.graph = void 0;\n    this.model = void 0;\n    this.zoom = void 0;\n    this.offset = void 0;\n    this.graphSize = void 0;\n    this.x = void 0;\n    this.y = void 0;\n    this.w = void 0;\n    this.h = void 0;\n    this.isResized = void 0;\n    this.size = void 0;\n    this.__isLVertex = void 0;\n    this.__isLGraph = void 0;\n    this.__isLGraphVertex = void 0;\n  } // MixOnlyFuncs(LGraph, LVertex)\n  // static singleton: LGraphVertex;\n  // static logic: typeof LGraphVertex;\n  // static structure: typeof DGraphVertex;\n  // inherit redefine\n  // isSelected: Dictionary<DocString<Pointer<DUser>>, boolean> = {};\n  isSelected(forUser) {\n    return this.wrongAccessMessage(\"node.isSelected()\");\n  }\n  // containedIn?: LGraphElement;\n  ///////////////////////////////////////// subElements!: LGraphElement[];\n  // from graph\n\n  // in-graph scrolling position\n  // internal size of the graph. can be huge even if the sub-graph is in a small window (scroll)\n\n  // from VoidVertex\n\n  // virtual\n\n  // personal attributes\n}, _class24.subclasses = [], _class24._extends = [], _class24)) || _class23);\nRuntimeAccessibleClass.set_extend(DGraph, DGraphVertex);\nRuntimeAccessibleClass.set_extend(DVertex, DGraphVertex);\nRuntimeAccessibleClass.set_extend(LGraph, LGraphVertex);\nRuntimeAccessibleClass.set_extend(LVertex, LGraphVertex);\nexport let DVoidEdge = (_dec13 = RuntimeAccessible('DVoidEdge'), _dec13(_class25 = (_class26 = class DVoidEdge extends DGraphElement {\n  constructor() {\n    super(...arguments);\n    this.id = void 0;\n    this.graph = void 0;\n    this.model = void 0;\n    this.isSelected = void 0;\n    this.subElements = void 0;\n    this.start = void 0;\n    this.end = void 0;\n    this.__isDVoidEdge = void 0;\n    this.midPoints = void 0;\n    this.midnodes = void 0;\n    this.longestLabel = void 0;\n    this.labels = void 0;\n  } // static singleton: LVoidEdge;\n  // static logic: typeof LVoidEdge;\n  // static structure: typeof DVoidEdge;\n  // isSelected: Dictionary<DocString<Pointer<DUser>>, boolean> = {};\n  // containedIn!: Pointer<DGraphElement, 0, 1, LGraphElement>;\n  // personal attributes\n  // the logic part which instructs to generate the midnodes\n  // using subelements instead most of times\n  static new(htmlindex, model, parentNodeID, graphID, nodeID, start, end, longestLabel, labels) {\n    return new Constructors(new DEdge('dwc'), parentNodeID, true, undefined, nodeID).DPointerTargetable().DGraphElement(model, graphID, htmlindex).DVoidEdge(start, end, longestLabel, labels).end();\n  }\n}, _class26.subclasses = [], _class26._extends = [], _class26)) || _class25);\n/*\r\n@RuntimeAccessible\r\nexport class MidPoint{\r\n    readonly id: string; // not really a pointer, it's not on store.\r\n    x?: number; y?: number;\r\n    readonly w?: number; // if it's modified it's not ever here (initial size) but on DEdgePoint that is a Node.\r\n    readonly h?: number;/*\r\n    constructor2(x: number=5, y: number=5, w: number=5, h: number=5) {\r\n        this.x = x;\r\n        this.y = y;\r\n        this.w = w;\r\n        this.h = h;\r\n    }* /\r\nconstructor(id: string, w: number=5, h: number=5) {\r\n    this.id = id;\r\n    this.w = w;\r\n    this.h = h;\r\n}\r\n}*/\nexport let EdgeSegment = (_dec14 = RuntimeAccessible('EdgeSegment'), _dec14(_class27 = class EdgeSegment {\n  //  a segment of the whole path\n  // m coefficient of the line between start and end.\n  // for head and tails: radian angle of the segment.\n  // for labels: it flips the angle when it's < PI/2 so the text is never upside down\n\n  /*constructor(label: PrimitiveType|undefined, length: number, startp: GraphPoint, endp: GraphPoint, start: LGraphElement, end: LGraphElement,\r\n              bezierpts: GraphPoint[], mid: LGraphElement[],\r\n              svgLetter: EdgeBendingMode, index: number, fillMode: MidNodeHandling) {\r\n      this.label = label;\r\n      this.length = length;\r\n      this.length = length;\r\n      this.startp = startp;\r\n      this.bezierp = bezierpts;\r\n      this.endp = endp;\r\n      this.start = start;\r\n      this.end = end;\r\n      this.mid = mid;\r\n  }*/\n  constructor(start, mid, end, svgLetter, gapMode, index, prevSegment) {\n    this.index = void 0;\n    this.prev = void 0;\n    this.start = void 0;\n    this.bezier = void 0;\n    this.end = void 0;\n    this.length = void 0;\n    this.d = void 0;\n    this.dpart = void 0;\n    this.m = void 0;\n    this.rad = void 0;\n    this.radLabels = void 0;\n    this.isLongest = void 0;\n    this.label = void 0;\n    this.svgLetter = void 0;\n    // console.log(\"segmentmaker:\", arguments, ((start.ge?.model as any)?.name)+\" ---> \" + ((end.ge?.model as any)?.name));\n    this.start = start;\n    this.bezier = mid;\n    this.end = end;\n    this.index = index;\n    this.prev = prevSegment;\n    //this.segments = segments;\n    // the idea: forbid all T and S or transform them in C, Q by calculating and manually adding their mirrored bezier pts\n    if (svgLetter[1]) svgLetter = svgLetter[0];\n    if (svgLetter === EdgeBendingMode.Bezier_quadratic_mirrored) {\n      this.addBezierPoint();\n      this.svgLetter = EdgeBendingMode.Bezier_quadratic;\n    } else if (svgLetter === EdgeBendingMode.Bezier_cubic_mirrored) {\n      this.addBezierPoint();\n      this.svgLetter = EdgeBendingMode.Bezier_cubic;\n    } else this.svgLetter = svgLetter;\n\n    // fix if amount of bezier pts is invalid for current letter\n    switch (this.svgLetter) {\n      case EdgeBendingMode.Line:\n      case EdgeBendingMode.Bezier_quadratic:\n        if (this.bezier.length >= 1) break;else this.svgLetter = EdgeBendingMode.Line;\n        break;\n      case EdgeBendingMode.Bezier_cubic:\n        if (this.bezier.length >= 2) break;else if (this.bezier.length >= 1) this.svgLetter = EdgeBendingMode.Bezier_quadratic;else this.svgLetter = EdgeBendingMode.Line;\n        break;\n      case EdgeBendingMode.Elliptical_arc:\n        if (this.bezier.length >= 3) break;else this.svgLetter = EdgeBendingMode.Line; // straight to end ignoring midpoints that are NOT coordinates when using elliptical arc.\n        break;\n      default:\n      case EdgeBendingMode.Bezier_quadratic_mirrored:\n      case EdgeBendingMode.Bezier_cubic_mirrored: // translated to Q or C by adding mirrored bezier points explicitly\n      case EdgeBendingMode.Bezier_QT:\n      case EdgeBendingMode.Bezier_CS:\n        // translated to Q or C by sending the right letter to each segment\n        Log.exDevv(\"this svg letter should not appear here\", this.svgLetter);\n        break;\n    }\n  }\n  addBezierPoint() {\n    let prev = this.prev;\n    if (!prev) return;\n    let prevedgemakerbezier = prev.bezier[prev.bezier.length - 1] || prev.start;\n    let mirroredBezier = {\n      ...prevedgemakerbezier,\n      pt: EdgeSegment.invertLastBezierPt(prevedgemakerbezier.pt, prev.end.pt),\n      uncutPt: EdgeSegment.invertLastBezierPt(prevedgemakerbezier.uncutPt, prev.end.uncutPt)\n    };\n    this.bezier = [mirroredBezier, ...this.bezier];\n    // always only 1 assumed pt both in cubic and quadratic.\n    // let next: this | undefined = this.segments[this.index+1];\n    // EdgeSegment.invertLastBezierPt((next.mid[1] || next.end).pt, next.start.pt);\n  }\n  makeD(index, gapMode) {\n    this.m = GraphPoint.getM(this.start.pt, this.end.pt);\n    this.rad = Geom.mToRad(this.m, this.start.pt, this.end.pt);\n    this.radLabels = Math.atan(this.m);\n    let svgLetter = this.svgLetter; // caller makes sure to pass right letter and resolve \"CS\" mixed letters. // this.bendingModeToLetter(bendingMode, index);\n    // caller sends inverted pts as normal coords\n    // let invertedBezPt = lastSegment && EdgeSegment.invertLastBezierPt(lastSegment.midp[lastSegment.mid.length-1] || lastSegment.startp, lastSegment.endp);\n    switch (this.svgLetter.length) {\n      case 2:\n        return Log.exDevv(\"mixed letters are not allowed and should have been resolved to single svg letters before here, found:\" + svgLetter);\n      /*return Log.exDevv(\"dev problem to fix:\\n\" +\r\n      \"the mirrored mode requires the first one to have explicit non-mirrored mode?? like M, C a1 a2 a3, S a1, S a1, S a1\\n\" +\r\n      \"So all segments with mixed modes needs to extract the last bezier point (penultimate coordinate) from previous segments, mirror it and insert in midp[0]\");*/\n      case 1:\n        let bezierpts = [...this.bezier.map(b => b.pt), this.end.pt];\n        let finalpart = svgLetter + \" \" + bezierpts.map(p => p.x + \" \" + p.y).join(\", \");\n        this.dpart = \"M \" + this.start.pt.x + \" \" + this.start.pt.y + \", \" + finalpart;\n        let bezierptsUncut = [...this.bezier.map(b => b.uncutPt), this.end.pt]; // uncutPt exist for start and end too, but i want to use the cut one for those. or edgehead is off\n        let finalpartUncut = svgLetter + \" \" + bezierptsUncut.map(p => p.x + \" \" + p.y).join(\", \");\n        this.d = (index === 0 ? \"M\" + this.start.pt.x + \" \" + this.start.pt.y + \", \" : \"\") + finalpartUncut;\n\n        //midp = [this.startp, ...this.midp];\n        // d = M sp X mp2 ep // X = custom letter\n        // dpart = T sp X mp2 ep // S = S if X = C,\n        // sp is the startingpoint from the prev node, which might be != from endpoint of last node if last node have w>0 && h>0\n        // so i'm \"filling\" the gap with a T, or L arc wich can use only 1 parameter (they are the only 1-parameter arcs)\n        if (this.prev && this.prev.end.pt.equals(this.start.pt)) gapMode = EdgeGapMode.average; // if the 2 points coincide, i use any 1 of the gapmodes that are continuous\n        /*switch (gapMode){\r\n            case EdgeGapMode.center:\r\n            case EdgeGapMode.average:\r\n                // continuous gap modes. they only differ in how the \"joining\" point is found, but not in how they behave after that.\r\n                /*\r\n                if (index === 0) {\r\n                     startletter = \"M \";\r\n                 }\r\n                 else {\r\n                     switch (svgLetter) {\r\n                         case SvgLetter.A: case SvgLetter.C: case SvgLetter.S: case SvgLetter.Q: case SvgLetter.T: default:\r\n                             startletter = SvgLetter.T + \" \"; break;\r\n                         case SvgLetter.L: case SvgLetter.M:\r\n                             startletter = SvgLetter.L + \" \"; break;\r\n                     }\r\n                 }* /\r\n                if (index) {\r\n                    this.d = finalpart;\r\n                }\r\n                else { this.d = this.dpart; }\r\n                break;\r\n            case EdgeGapMode.gap:\r\n            case EdgeGapMode.autoFill:\r\n            case EdgeGapMode.lineFill:\r\n            case EdgeGapMode.arcFill:\r\n                // the filling itself is done by another segment (solving svg letter and simulating i=0), so i treat it as a gap.\r\n                this.d = this.dpart;\r\n                break;\r\n            default:\r\n                Log.exDevv(\"unexpected EdgeGapMode:\" + gapMode, {gapMode});\r\n        }*/\n        break;\n      default:\n        return Log.exDevv(\"unexpected bending mode length:\" + this.svgLetter + \" or fillMode: \" + gapMode, {\n          bendingMode: this.svgLetter,\n          index,\n          gapMode\n        });\n    }\n\n    //using\n    /*\r\n    88\r\n      // d should not have M set (except for segments[0]\r\n    // dpart have M abd beed to add explicit points for \"mirroring\" and transforming bezier quadratic mirrored in bezier quadratic normal etc.\r\n    //88 problem: the mirrored mode requires the first one to have explicit nonmirrored mode?? like M, C a1 a2 a3, S a1, S a1, S a1 .... ?\r\n    in any case the % letter part is wrong because it needs to subtract first element used for M*/\n    return this.d;\n  }\n  static invertLastBezierPt(bezier, end) {\n    // vector = bezier - end\n    // end + vector = bezier\n    // end - vector = inverted bezier? = 2*end-bezier\n    let vector = bezier.subtract(end, true);\n    return end.subtract(vector, true);\n  }\n  calcLength() {\n    this.length = this.start.pt.distanceFromPoint(this.end.pt);\n  }\n}) || _class27);\nexport class EdgeFillSegment extends EdgeSegment {\n  makeD(index, gapMode) {\n    if (gapMode === EdgeGapMode.autoFill) {\n      gapMode = this.svgLetter === EdgeBendingMode.Line ? EdgeGapMode.lineFill : EdgeGapMode.arcFill;\n    }\n    switch (gapMode) {\n      case EdgeGapMode.center:\n      case EdgeGapMode.average:\n      case EdgeGapMode.gap:\n        return \"\";\n      // should not have filler arcs\n      default:\n      case EdgeGapMode.autoFill:\n      case EdgeGapMode.lineFill:\n        this.bezier = [];\n        this.svgLetter = EdgeBendingMode.Line;\n        return super.makeD(index, gapMode);\n      case EdgeGapMode.arcFill:\n        this.svgLetter = this.svgLetter[0];\n        if (this.svgLetter === \"Q\") this.bezier = this.bezier.length ? [this.bezier[0]] : [];\n        return super.makeD(index, gapMode);\n    }\n  }\n}\nEdgeFillSegment.cname = \"EdgeFillSegment\";\nexport let LVoidEdge = (_dec15 = RuntimeAccessible('LVoidEdge'), _dec15(_class29 = (_class30 = class LVoidEdge extends LGraphElement {\n  constructor() {\n    super(...arguments);\n    this.__raw = void 0;\n    this.id = void 0;\n    this.graph = void 0;\n    this.model = void 0;\n    this.subElements = void 0;\n    this.start = void 0;\n    this.end = void 0;\n    this.__isLVoidEdge = void 0;\n    this.midPoints = void 0;\n    this.midnodes = void 0;\n    this.edge = void 0;\n    this.__info_of__edge = {\n      type: \"?LEdge\",\n      txt: \"returns this if called on an edge, the containing edge if called on an EdgePoint, undefined otherwise.\"\n    };\n    this.label = void 0;\n    this.longestLabel = void 0;\n    this.labels = void 0;\n    this.allNodes = void 0;\n    this.__info_of__longestLabel = {\n      label: \"longest label\",\n      type: \"text\",\n      readType: \"PrimitiveType\",\n      writeType: \"PrimitiveType | (e:this, curr: LGraphElement, next: LGraphElement, curr_index: number, allNodes: LGraphElement[]) => PrimitiveType)\",\n      txt: /*#__PURE__*/_jsxDEV(\"span\", {\n        children: \"Label assigned to the longest path segment.\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 1544,\n        columnNumber: 14\n      }, this)\n    };\n    this.__info_of__label = {\n      type: \"\",\n      txt: /*#__PURE__*/_jsxDEV(\"span\", {\n        children: \"Alias for longestLabel\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 1545,\n        columnNumber: 46\n      }, this)\n    };\n    this.__info_of__labels = {\n      label: \"multple labels\",\n      type: \"text\",\n      writeType: \"type of label or Array<type of label>\",\n      txt: /*#__PURE__*/_jsxDEV(\"span\", {\n        children: \"Instructions to label to multiple or all path segments in an edge\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 1548,\n        columnNumber: 14\n      }, this)\n    };\n    this.__info_of__allNodes = {\n      type: \"[LGraphElement, ...Array<LEdgePoint>, LGraphElement]\",\n      txt: /*#__PURE__*/_jsxDEV(\"span\", {\n        children: \"first element is this.start. then all this.midnodes. this.end as last element\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 1549,\n        columnNumber: 101\n      }, this)\n    };\n    this.__info_of__startPoint = {\n      type: \"GraphPoint\",\n      txt: /*#__PURE__*/_jsxDEV(\"span\", {\n        children: \"startPoint of this.start (element originating the edge). Defaults in outer coordinates.\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 1686,\n        columnNumber: 60\n      }, this)\n    };\n    this.__info_of__endPoint = {\n      type: \"GraphPoint\",\n      txt: /*#__PURE__*/_jsxDEV(\"span\", {\n        children: \"endPoint of this.end (element originating the edge). Defaults in outer coordinates.\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 1687,\n        columnNumber: 58\n      }, this)\n    };\n    this.segments = void 0;\n    this.segments_inner = void 0;\n    this.segments_outer = void 0;\n    this.__info_of__segments = {\n      type: \"{all:T, segments:T, fillers:T, head: GraphSize&{rad:number}, tail: as head} where T is EdgeSegment\",\n      txt: /*#__PURE__*/_jsxDEV(\"span\", {\n        children: [\"Collection of segments connecting in order vertex and EdgePoint without intersecting their area, aimed to be rendered in svg path.\", /*#__PURE__*/_jsxDEV(\"br\", {}, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 1707,\n          columnNumber: 13\n        }, this), \"fillers are arcs generated by view.edgeGapMode being autofill, arcfill or linefill.\", /*#__PURE__*/_jsxDEV(\"br\", {}, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 1708,\n          columnNumber: 13\n        }, this), \"length of this.segments array is Math.ceil(allNodes.length / svg_letter_size) specified on view.\", /*#__PURE__*/_jsxDEV(\"br\", {}, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 1709,\n          columnNumber: 13\n        }, this), \"\\\"head\\\" and \\\"tail\\\" are the position and angle of eventual edge decorators. Refer to this.headPos documentation.\"]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 1706,\n        columnNumber: 13\n      }, this)\n    };\n    this.d = void 0;\n    this.__info_of__d = {\n      type: ShortAttribETypes.EString,\n      txt: \"the full suggested path of SVG path \\\"d\\\" attribute, merging all segments.\"\n    };\n  } // static singleton: LVoidEdge;\n  // static logic: typeof LVoidEdge;\n  // static structure: typeof DVoidEdge;\n  // isSelected: Dictionary<DocString<Pointer<DUser>>, boolean> = {};\n  isSelected(forUser) {\n    return this.wrongAccessMessage(\"node.isSelected()\");\n  }\n  // containedIn?: LGraphElement;\n\n  // the logic part which instructs to generate the midnodes\n\n  // returns self. useful to get edge from edgePoints without triggering error if you are already on edge.\n\n  /*\r\n  replaced by startPoint\r\n      edgeStart!: GraphPoint;\r\n      edgeStart_inner!: GraphPoint;\r\n      edgeStart_outer!: GraphPoint;\r\n      __info_of__edgeStart: Info = {type: \"GraphPoint\", txt: \"Same as edgeStart_outer.\"}\r\n      __info_of__edgeStart_outer: Info = {type: \"GraphPoint\",\r\n       txt: \"Where the edge should start his path, in coordinates relative at the root Graph.\r\n       <br>Computed by combining the anchor offset option in View and the size of the starting node.\"}\r\n      __info_of__edgeStart_inner: Info = {type: \"GraphPoint\",\r\n       txt: \"Where the edge should start his path, in coordinates relative at the most nested Graph.\r\n       <br>Computed by combining the anchor offset option in View and the size of the starting node.\"}\r\n      edgeEnd!: GraphPoint;\r\n      edgeEnd_inner!: GraphPoint;\r\n      edgeEnd_outer!: GraphPoint;\r\n      __info_of__edgeEnd: Info = {type: \"GraphPoint\", txt: \"Same as edgeEnd_outer.\"}\r\n      __info_of__edgeEnd_outer: Info = {type: \"GraphPoint\",\r\n       txt: \"Where the edge should end his path, in coordinates relative at the root Graph.\r\n       <br>Computed by combining the anchor offset option in View and the size of the starting node.\"}\r\n      __info_of__edgeEnd_inner: Info = {type: \"GraphPoint\",\r\n       txt: \"Where the edge should end his path, in coordinates relative at the most nested Graph.\r\n       <br>Computed by combining the anchor offset option in View and the size of the starting node.\"}\r\n  */\n\n  // should never be read change their documentation in write only. their values is \"read\" in this.segments\n\n  get_label(c) {\n    return this.get_longestLabel(c);\n  }\n  get_longestLabel(c) {\n    return c.data.longestLabel;\n  }\n  set_longestLabel(val, c) {\n    return SetFieldAction.new(c.data, \"longestLabel\", val);\n  }\n  get_labels(c) {\n    return c.data.labels;\n  }\n  set_labels(val, c) {\n    return SetFieldAction.new(c.data, \"labels\", val);\n  }\n  headPos_impl(c, isHead, headSize0, segment0, zoom0) {\n    let segment = segment0 || this.get_segments(c).segments[0];\n    // let v: LViewElement = this.get_view(c);\n    let tmp = headSize0 || (isHead ? this.get_view(c).edgeHeadSize : this.get_view(c).edgeTailSize);\n    if (!tmp || tmp.x === 0 || tmp.y === 0) {\n      // head or tail missing\n      tmp = new GraphSize(0, 0, 0, 0);\n      tmp.rad = 0;\n      return tmp;\n    }\n    let zoom = zoom0 || this.get_graph(c).zoom;\n    let headPos = new GraphSize(0, 0, tmp.x, tmp.y); //.multiply({w:zoom.x, h:zoom.y});\n    let useBezierPoints = true;\n    let start, end;\n    let m;\n    if (useBezierPoints) {\n      if (isHead) {\n        start = segment.end.pt;\n        end = (segment.bezier[segment.bezier.length - 1] || segment.start).pt;\n      } else {\n        start = segment.start.pt;\n        end = (segment.bezier[0] || segment.end).pt;\n      }\n      m = GraphPoint.getM(start, end);\n    } else {\n      if (isHead) {\n        start = segment.end.pt;\n        end = segment.start.pt;\n      } else {\n        start = segment.start.pt;\n        end = segment.end.pt;\n      }\n      m = segment.m;\n    }\n    // first find the center of where it should be positioned\n    // let center: GraphPoint;\n    // let distance: number = Math.sqrt(headPos.w*headPos.w + headPos.h*headPos.h);\n    // let isVertical = m >=1 ;\n    let x4headsize = new GraphSize(start.x - headPos.w, start.y - headPos.h, headPos.w * 2, headPos.h * 2);\n    // first intersection is segment origin. second is found with the box containing all possible edgeHead positions that touch the startPoint\n    // (doing x4 his shape and placing 4 \"rectangles\" all around startPoint) to cover all possible segment directions.\n    // or finding first direction (vertical if m >1, horizontal if m<0) and vector direction and intersecting with only the \"correct\" placed edgeHead rectangle.\n    // then the intersection will likely not fall on the extreme angle of EdgeHead and i can re-center edgeHead\n    // so that first and second intersections are equal spaced with the center segment\n    let secondIntersection;\n    let segmentDistance = start.distanceFromPoint(end);\n    if (segmentDistance <= Math.sqrt(headPos.w ** 2 + headPos.h ** 2)) {\n      let safeDistance = Math.max(headPos.w, headPos.h) * 5;\n      end = new GraphPoint(end.y + safeDistance, end.y + m * safeDistance); // move the point away so it doesn't intersect anymore. i just need direction\n      // too small to fit edgeHead, i simply put it centered on the whole segment\n      // secondIntersection = end;\n    }\n    secondIntersection = GraphSize.closestIntersection(x4headsize, start, end, undefined);\n    if (!secondIntersection) return Log.exx(\"failed to intersect edge head\", {\n      x4headsize,\n      segment,\n      headPos,\n      c,\n      start,\n      end,\n      useBezierPoints\n    });\n    tmp = secondIntersection.add(start, false).divide(2); // center of edgehead\n    headPos.x = tmp.x - headPos.w / 2; // tl corner\n    headPos.y = tmp.y - headPos.h / 2; // tl corner\n    headPos.rad = Geom.mToRad(m, start, end);\n    /*\r\n    devo trovare la distanza tra il centro dell'egeHead e il punto di inizio in termini assoluti, così tramite M trovo distanza in x e y. o trovarla in altro modo\r\n    if (segment.m === Number.POSITIVE_INFINITY || segment.m === Number.NEGATIVE_INFINITY) {\r\n        center = segment.start.pt.add({x:0, y: distance}, true); }\r\n    else { center = segment.start.pt.add({x:segment.m*headPos.w/2, y:segment.m*headPos.h/2\r\n     this is wrong, cannot be the same for x and y, i should invert the line equation for x?}, true); }\r\n    headPos.x = center.x - headPos.w / 2;\r\n    headPos.y = center.y - headPos.h / 2;*/\n    // console.log(\"head intersected\", {headPos, secondIntersection, x4headsize, segment, c, start, end, useBezierPoints});\n\n    return headPos;\n  }\n  headPos(headSize0, segment0, zoom0) {\n    return this.wrongAccessMessage(\"This is not headPos() implementation. it is just for typings. use the getter\");\n  }\n  tailPos(headSize0, segment0, zoom0) {\n    return this.wrongAccessMessage(\"This is not tailPos() implementation. it is just for typings. use the getter\");\n  }\n  get_headPos(c) {\n    return (headSize, segment, zoom) => this.headPos_impl(c, true, headSize, segment, zoom);\n  }\n  get_tailPos(c) {\n    return (headSize, segment, zoom) => this.headPos_impl(c, false, headSize, segment, zoom);\n  }\n  get_allNodes(c) {\n    return [this.get_start(c), ...this.get_midnodes(c), this.get_end(c)];\n  }\n  get_edge(c) {\n    return c.proxyObject;\n  }\n  set_edge(v, c) {\n    return this.cannotSet(\"edge field, on an edge element\");\n  }\n  get_midPoints(c) {\n    return c.data.midPoints;\n  }\n  addMidPoint(v) {\n    return this.wrongAccessMessage(\"addMidPoint\");\n  }\n  get_addMidPoint(c) {\n    return v => this.impl_addMidPoints(v, c);\n  }\n  set_midPoints(val, c) {\n    return SetFieldAction.new(c.data.id, \"midPoints\", val, undefined, false);\n  }\n  impl_addMidPoints(val, c) {\n    return SetFieldAction.new(c.data.id, \"midPoints\", val, '+=', false);\n  }\n  get_label_impl(c, segment, nodes, segments) {\n    let key = segment.isLongest ? \"longestLabel\" : \"labels\"; // : keyof this\n    // if (isLongestSegment) return this.get_longestLabel_impl(d, l, nodes, index):\n    const d = c.data;\n    const l = c.proxyObject;\n    let labelmaker = d[key]; // orArr<PrimitiveType | JSX | function>\n    let labelmakerfunc = labelmaker;\n    // let lastSeg = segments[i-1];\n    switch (typeof labelmaker) {\n      //nb{}[]<>\n      case \"number\":\n      case \"undefined\":\n      case \"boolean\":\n      case \"string\":\n        return labelmaker;\n      // case \"function\": return nodes.map( (o, i) => d.labels(l, nodes, i)).slice(0, nodes.length-1);\n      case \"function\":\n        return labelmakerfunc(l, segment, nodes, segments);\n      default:\n        break;\n      case \"object\":\n        if (labelmaker === null) return null;\n        if (!Array.isArray(labelmaker)) break;\n        if (typeof labelmaker[0] === \"function\") return labelmaker[segment.index % labelmaker.length](l, segment, nodes, segments);\n        return labelmaker[segment.index % labelmaker.length];\n    }\n    Log.exx(\"edge labels invalid type, must be a primitive value, a function or an array of such.\", {\n      labelmaker,\n      key,\n      d\n    });\n    return undefined;\n  } /*\r\n    private get_label_impl_old(d: DVoidEdge, l: LVoidEdge, nodes:this[\"allNodes\"], index: number, longestlabelindex?: number): PrimitiveType {\r\n       if (d.longestLabel !== undefined && index === longestlabelindex) return this.get_longestLabel_impl(d, l, nodes, index);\r\n       switch (typeof d.labels) {//nb{}[]<>\r\n           case \"number\":\r\n           case \"undefined\":\r\n           case \"boolean\":\r\n           case \"string\": return d.labels;\r\n           // case \"function\": return nodes.map( (o, i) => d.labels(l, nodes, i)).slice(0, nodes.length-1);\r\n           case \"function\": return d.labels(l, nodes[index], nodes[index+1], index, nodes);\r\n           default: break;\r\n           case \"object\": if (!Array.isArray(d.labels)) break;\r\n           if (typeof d.labels[0] === \"function\") return (d.labels as any)[index % d.labels.length](l, nodes[index], nodes[index+1], index, nodes);\r\n           return (d.labels as PrimitiveType[])[index % d.labels.length];\r\n       }\r\n       Log.exx(\"edge labels invalid type, must be a primitive value, a function or an array of such.\", d.labels);\r\n    }*/\n\n  get_startPoint(context) {\n    return this.get_startPoint_Outer(context);\n  }\n  get_endPoint(context) {\n    return this.get_endPoint_Outer(context);\n  }\n  get_startPoint_Outer(c) {\n    // console.log(\"get_edgeStart_Outer\", {out:this.get_outerGraph(c), pos:this.get_startPoint_inner(c), inner:this.get_start(c).innerGraph});\n    return this.get_outerGraph(c).translateSize(this.get_startPoint_inner(c), this.get_start(c).innerGraph);\n  }\n  get_endPoint_Outer(c) {\n    // console.log(\"get_edgeEnd_Outer\", {out:this.get_outerGraph(c), pos:this.get_endPoint_inner(c), inner:this.get_end(c).innerGraph});\n    return this.get_outerGraph(c).translateSize(this.get_endPoint_inner(c), this.get_end(c).innerGraph);\n  }\n  get_startPoint_inner(c) {\n    return this.get_edgeStartEnd_inner(c, true);\n  }\n  get_endPoint_inner(c) {\n    return this.get_edgeStartEnd_inner(c, false);\n  }\n  get_edgeStartEnd_inner(c, isStart) {\n    return isStart ? this.get_start(c).startPoint : this.get_end(c).endPoint;\n  }\n  svgLetterSize(s) {\n    let addM = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    let doublingMidPoints = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    let ret;\n    switch (s) {\n      default:\n        ret = Log.exDevv(\"unexpected svg path letter: \\\"\" + s + \"\\\"\", s);\n        break;\n      case EdgeBendingMode.Line:\n      case EdgeBendingMode.Bezier_quadratic_mirrored:\n        ret = {\n          first: 1,\n          others: 1\n        };\n        break;\n      case EdgeBendingMode.Bezier_quadratic:\n      case EdgeBendingMode.Bezier_cubic_mirrored:\n        ret = {\n          first: 2,\n          others: 2\n        };\n        break;\n      case EdgeBendingMode.Bezier_cubic:\n        ret = {\n          first: 3,\n          others: 3\n        };\n        break;\n      case EdgeBendingMode.Elliptical_arc:\n        ret = {\n          first: 4,\n          others: 4\n        };\n        break;\n      case EdgeBendingMode.Bezier_QT:\n        ret = {\n          first: 2,\n          others: 1\n        };\n        break;\n      case EdgeBendingMode.Bezier_CS:\n        ret = {\n          first: 3,\n          others: 2\n        };\n        break;\n    }\n\n    // account for the fact that every midpoint is listed twice: at anchor start and anchor end.\n    if (doublingMidPoints) {\n      // removing last point (first is already excluded because addM didn't trigger yet)\n      // , the remaining are midpoints to double. then i add it back\n      ret.first = (ret.first - 1) * 2 + 1;\n      ret.others = (ret.others - 1) * 2 + 1;\n    }\n\n    // account for the first M letter\n    //    (if the segment is not mode.gap or first, M coord still exist in segment but are ignored)\n    if (addM) {\n      ret.first += 1;\n      ret.others += 1;\n    }\n    return ret;\n  }\n  get_points_impl(allNodes, outer) {\n    function getAnchorOffset(size, offset, isPercentage) {\n      if (!size) size = new GraphSize(0, 0, 0, 0);\n      if (isPercentage) offset = new GraphPoint(offset.x / 100 * size.w, offset.y / 100 * size.h);\n      return size.tl().add(offset, false);\n    }\n    const all = allNodes.flatMap((ge, i) => {\n      let base = {\n        view: ge.view,\n        size: outer ? ge.outerSize : ge.innerSize,\n        ge,\n        pt: null,\n        uncutPt: null\n      };\n      let rets; // = base as any;\n      let rete; // = {...base} as any;\n      if (i !== 0) {\n        rete = {\n          ...base\n        };\n        rete.pt = LEdgePoint.singleton.get_endPoint(undefined, rete.size, rete.view);\n        rete.pt = getAnchorOffset(rete.size, rete.view.edgeStartOffset, rete.view.edgeStartOffset_isPercentage);\n        rete.uncutPt = rete.pt;\n      }\n      if (i !== allNodes.length - 1) {\n        rets = {\n          ...base\n        };\n        rets.pt = LEdgePoint.singleton.get_startPoint(undefined, rets.size, rets.view);\n        rets.pt = getAnchorOffset(rets.size, rets.view.edgeStartOffset, rets.view.edgeStartOffset_isPercentage);\n        rets.uncutPt = rets.pt;\n      }\n      // ret.pt = ge.startPoint\n      return rets && rete ? [rete, rets] : rets ? [rets] : [rete];\n    });\n    return all;\n  }\n  get_points(allNodes) {\n    let outer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    return this.get_points_impl(allNodes, outer);\n  }\n  get_points_outer(allNodes) {\n    return this.get_points_impl(allNodes, true);\n  }\n  get_points_inner(allNodes) {\n    return this.get_points_impl(allNodes, false);\n  }\n  get_d(c) {\n    return this.get_segments(c).all.map(s => s.d).join(\" \");\n  } /*\r\n    private get_fillingSegments(c: Context): Partial<this[\"segments\"]> {\r\n       return this.get_segments(c).fillers;\r\n    }*/\n\n  get_segments(c) {\n    return this.get_segments_outer(c);\n  }\n  get_segments_outer(c) {\n    return this.get_segments_impl(c, true);\n  }\n  get_segments_inner(c) {\n    return this.get_segments_impl(c, false);\n  }\n  get_segments_impl(c, outer) {\n    let l = c.proxyObject;\n    let v = this.get_view(c);\n    let allNodes = l.allNodes;\n    windoww.edge = l;\n    let all = this.get_points(allNodes, outer);\n    //const all: {size: GraphSize, view: LViewElement, ge: LGraphElement}[] = allNodes.map((ge) => { return { view: ge.view, size: ge.size, ge}});\n    let ret = [];\n    let bm = v.bendingMode;\n    let gapMode = v.edgeGapMode;\n    let segmentSize = this.svgLetterSize(bm, false, true);\n    let increase = segmentSize.first;\n    let segment;\n    /// grouping points according to SvgLetter\n    for (let i = 0; i < all.length - 1;) {\n      // let start = all[i], end = all[i+increase];\n      let start = all[i];\n      let endindex = i + increase < all.length - 1 ? i + increase : all.length - 1;\n      let mid = all.slice(i + 1, endindex).filter((e, i) => i % 2 === 0);\n      let end = all[endindex];\n      // makes sure the edge actually reaches his target even if there is an invalid amount of midnodes fot the current EdgeBendingMode\n      if (i === endindex && segment) start = segment.end;\n      // segment = this.get_segmentv3(start, mid, end, getSvgLetter(i), i, segment, all);\n      segment = new EdgeSegment(start, mid, end, bm, gapMode, i, segment);\n      // segment = this.get_segment(start.ge, start.size, start.view, end.ge, end.size, end.view, cut, v.bendingMode, mid, ret[ret.length -1], fillMode, segment);\n      ret.push(segment);\n      i += increase + 1; // because increase index is already inserted at the end of prev segment\n      if (increase !== segmentSize.others) increase = segmentSize.others;\n      // if (longestLabel !== undefined && longest < s.length) { longest = s.length; longestindex = i; } todo: move to after snapping to borders\n    }\n    let fillSegments = [];\n    this.snapSegmentsToNodeBorders(c, v, ret, fillSegments);\n    let longestLabel = c.data.longestLabel;\n    this.setLabels(c, ret, allNodes);\n    // console.log(\"getSegments() labeled:\", {main:ret, fillSegments});\n    let rett = {\n      all: [...ret, ...fillSegments],\n      segments: ret,\n      fillers: fillSegments\n    };\n    for (let i = 0; i < rett.all.length; i++) {\n      let s = rett.all[i];\n      s.makeD(i, gapMode);\n    }\n    let zoom = new GraphPoint(1, 1);\n    rett.head = this.headPos_impl(c, true, v.edgeHeadSize, rett.segments[rett.segments.length - 1], zoom);\n    rett.tail = this.headPos_impl(c, false, v.edgeTailSize, rett.segments[0], zoom);\n    return rett;\n  }\n  setLabels(c, segments, allNodes) {\n    // find longest segment\n    let longestindex = -1;\n    let longest = 0;\n    for (let i = 0; i < segments.length; i++) {\n      let s = segments[i];\n      s.calcLength();\n      if (longest < s.length) {\n        longest = s.length;\n        longestindex = i;\n      }\n      s.isLongest = false;\n    }\n    if (longestindex >= 0) segments[longestindex].isLongest = true;\n    // apply labels\n    for (let s of segments) s.label = this.get_label_impl(c, s, allNodes, segments);\n  }\n  snapSegmentsToNodeBorders(c, v, ret, fillSegments) {\n    // snap segment start and end to a node border\n    let canCutStart = v.edgeStartStopAtBoundaries,\n      canCutEnd = v.edgeEndStopAtBoundaries;\n    let grid = undefined;\n    // let fillSegments: EdgeSegment[] = [];\n    let gapMode = v.edgeGapMode;\n    let bm = v.bendingMode;\n    let ci;\n    // cut i === 0 is cut regardless of gapmode.\n    if (canCutStart) {\n      ci = GraphSize.closestIntersection(ret[0].start.size, ret[0].start.pt, (ret[0].bezier[0] || ret[0].end).pt, grid);\n      if (ci) ret[0].start.pt = ci;\n      /*\r\n      ret[0].start.pt =\r\n          GraphSize.closestIntersection(ret[0].start.size, ret[0].start.pt, (ret[0].bezier[0] || ret[0].end).pt, grid) as any\r\n          || Geom.closestPoint(ret[0].start.size, ret[0].start.pt);*/\n    }\n\n    // cut middle segments maybe\n    let prev;\n    let curr = ret[0];\n    if (canCutStart || canCutEnd)\n      // do the for below\n      for (let i = 1; i < ret.length; i++) {\n        prev = ret[i - 1];\n        curr = ret[i];\n        let doStartCut, doEndCut;\n        switch (gapMode) {\n          case EdgeGapMode.arcFill:\n          case EdgeGapMode.lineFill:\n          case EdgeGapMode.autoFill:\n            // same as gap, but will insert 1 more segment to fill the hole\n            doStartCut = true;\n            doEndCut = true;\n            if (prev.end.pt.equals(curr.start.pt)) break;\n            fillSegments.push(new EdgeFillSegment(prev.end, [{\n              ...prev.end,\n              pt: EdgeSegment.invertLastBezierPt(prev.end.pt, (prev.bezier[prev.bezier.length - 1] || prev.start).pt)\n            }, {\n              ...curr.start,\n              pt: EdgeSegment.invertLastBezierPt(curr.start.pt, (curr.bezier[0] || curr.end).pt)\n            }], curr.start, bm, gapMode, 0, undefined));\n            /*\r\n            fillSegments.push(new FillEdgeSegment( // M <start_gap> C <bez1> <bez2> <end_gap>\r\n               // <start_gap> = end of last seg (start of gap) <end_gap> = first of curr seg (end of gap)\r\n            prev.end.pt,\r\n            EdgeSegment.invertLastBezierPt(prev.end.pt, prev.bezier[prev.bezier.length-1].pt || prev.start.pt),\r\n            EdgeSegment.invertLastBezierPt(curr.start.pt, curr.bezier[0].pt || curr.end.pt),\r\n            curr.start.pt)\r\n            */\n            break;\n          case EdgeGapMode.gap:\n            // just snap to vertex edge         prevSegment.endp and ret.startp\n            doStartCut = true;\n            doEndCut = true;\n            break;\n          // average: todo: maybe rename in join (merges start-end at closest pt to both (avg), then snap on edge)\n          case EdgeGapMode.average:\n            // first move to average of the 2 points in the gap, then snap to edge\n            doEndCut = true;\n            doStartCut = true;\n            // indipendent from cutStart, cutEnd.\n            // they merge if just 1 of cutting sides are true. (and if they are both false we don't even enter the for loop)\n            curr.start.pt.add(prev.end.pt, false).divide(2, false);\n            prev.end.pt = curr.start.pt.duplicate(); // intentionally not the same pt because during snap to edge they can temporarly diverge.again,\n            prev.start.uncutPt = prev.start.pt;\n            prev.end.uncutPt = prev.end.pt;\n            break;\n          // center: first move it to center of edgePoint/node, then snap to edge.\n          // this mode might be as well deleted, it can be specified with anchor points\n          case EdgeGapMode.center:\n            doEndCut = false;\n            doStartCut = false;\n            curr.start.pt = curr.start.size.tl().add(curr.start.size.br(), false).divide(2, false);\n            prev.end.pt = curr.start.pt.duplicate(); // intentionally not the same pt because during snap to edge they can diverge.again,\n            prev.start.uncutPt = prev.start.pt; // only update them when point moves without being cut (average and center)\n            prev.end.uncutPt = prev.end.pt;\n            break;\n          default:\n            return Log.exDevv(\"unexpected EdgeGapMode:\" + gapMode);\n        }\n        if (canCutStart && doStartCut) {\n          let extpt = (curr.bezier[0] || curr.end).pt;\n          ci = GraphSize.closestIntersection(curr.start.size, curr.start.pt, extpt, grid);\n          if (ci) curr.start.pt = ci; // || Geom.closestPoint(curr.start.size, curr.start.pt);\n          //if (gapMode === EdgeGapMode.average && prev) { prev.end.pt = curr.start.pt.add(prev.end.pt, false).divide(2, false); }\n        }\n        if (canCutEnd && doEndCut && prev) {\n          let prevpt = (prev.bezier[prev.bezier.length - 1] || prev.start).pt;\n          ci = GraphSize.closestIntersection(prev.end.size, prev.end.pt, prevpt, grid);\n          if (ci) prev.end.pt = ci; // || Geom.closestPoint(prev.end.size, prev.end.pt);\n          // if average: first do average between start anchor points non-snapped. then i snap both,\n          // then i do average again, and since it might snap out, i get closestPoint to EdgePoint size\n          if (gapMode === EdgeGapMode.average) prev.end.pt = curr.start.pt = Geom.closestPoint(curr.start.size, curr.start.pt.add(prev.end.pt, false).divide(2, false));\n        }\n      }\n    // cut end of last segment regardless of gapMode\n    if (canCutEnd) {\n      let prevendpt = curr.end.pt;\n      ci = GraphSize.closestIntersection(curr.end.size, curr.end.pt, (curr.bezier[curr.bezier.length - 1] || curr.start).pt, grid);\n      if (ci) curr.end.pt = ci; //|| Geom.closestPoint(prev.end.size, prev.end.pt);\n    }\n  }\n  get_edgeEnd(context) {\n    return this.get_edgeEnd_outer(context);\n  }\n  get_edgeEnd_outer(c) {\n    // return this.get_outerGraph(c).translateSize(this.get_edgeEnd_inner(c), this.get_innerGraph(c));\n    return this.get_outerGraph(c).translateSize(this.get_edgeEnd_inner(c), this.get_end(c).innerGraph);\n  }\n  get_edgeEnd_inner(c) {\n    return this.get_edgeStartEnd_inner(c, false);\n    // return context.proxyObject.end?.size || new GraphPoint(0, 0);\n  }\n  get_midnodes(context) {\n    // return LPointerTargetable.wrapAll(context.data.midnodes);\n    return LPointerTargetable.wrapAll(context.data.subElements);\n  }\n  set_midnodes(val, context) {\n    return SetFieldAction.new(context.data.id, \"midnodes\", val, '', true);\n  }\n  get_start(context) {\n    return LPointerTargetable.from(context.data.start);\n  }\n  get_end(context) {\n    return LPointerTargetable.from(context.data.end);\n  }\n}, _class30.subclasses = [], _class30._extends = [], _class30)) || _class29);\nRuntimeAccessibleClass.set_extend(DGraphElement, DVoidEdge);\nRuntimeAccessibleClass.set_extend(LGraphElement, LVoidEdge);\nexport let DEdge = (_dec16 = RuntimeAccessible('DEdge'), _dec16(_class31 = (_class32 = class DEdge extends DVoidEdge {\n  constructor() {\n    super(...arguments);\n    this.id = void 0;\n    this.graph = void 0;\n    this.model = void 0;\n    this.isSelected = void 0;\n    this.subElements = void 0;\n    this.state = {};\n    this.start = void 0;\n    this.end = void 0;\n    this.__isDEdge = void 0;\n    this.__isDVoidEdge = void 0;\n    this.midnodes = void 0;\n  } // DVoidEdge\n  // static singleton: LGraphElement;\n  // static logic: typeof LGraphElement;\n  // static structure: typeof DGraphElement;\n  // isSelected: Dictionary<DocString<Pointer<DUser>>, boolean> = {};\n  // containedIn!: Pointer<DGraphElement, 0, 1, LGraphElement>;\n}, _class32.subclasses = [], _class32._extends = [], _class32)) || _class31);\nexport let LEdge = (_dec17 = RuntimeAccessible('LEdge'), _dec17(_class33 = (_class34 = class LEdge extends LVoidEdge {\n  constructor() {\n    super(...arguments);\n    this.__raw = void 0;\n    this.id = void 0;\n    this.graph = void 0;\n    this.model = void 0;\n    this.subElements = void 0;\n    this.state = void 0;\n    this.start = void 0;\n    this.end = void 0;\n    this.midnodes = void 0;\n    this.__isLEdge = void 0;\n    this.__isLVoidEdge = void 0;\n  } // static singleton: LGraphElement;\n  // static logic: typeof LGraphElement;\n  // static structure: typeof DGraphElement;\n  // isSelected: Dictionary<DocString<Pointer<DUser>>, boolean> = {};\n  isSelected(forUser) {\n    return this.wrongAccessMessage(\"node.isSelected()\");\n  }\n  // containedIn!: LGraphElement;\n}, _class34.subclasses = [], _class34._extends = [], _class34)) || _class33);\nRuntimeAccessibleClass.set_extend(DVoidEdge, DEdge);\nRuntimeAccessibleClass.set_extend(LVoidEdge, LEdge);\nexport let DExtEdge = (_dec18 = RuntimeAccessible('DExtEdge'), Leaf(_class35 = _dec18(_class35 = (_class36 = class DExtEdge extends DEdge {\n  constructor() {\n    super(...arguments);\n    this.id = void 0;\n    this.graph = void 0;\n    this.model = void 0;\n    this.isSelected = void 0;\n    this.subElements = void 0;\n    this.state = {};\n    this.start = void 0;\n    this.end = void 0;\n    this.__isDExtEdge = void 0;\n    this.__isDEdge = void 0;\n    this.__isDVoidEdge = void 0;\n  } // etends DEdge\n  // static singleton: LGraphElement;\n  // static logic: typeof LGraphElement;\n  // static structure: typeof DGraphElement;\n  // isSelected: Dictionary<DocString<Pointer<DUser>>, boolean> = {};\n  // containedIn!: Pointer<DGraphElement, 0, 1, LGraphElement>;\n  /*\r\n      public static new(model: DGraph[\"model\"], parentNodeID: DGraphElement[\"father\"], graphID: DGraphElement[\"graph\"], nodeID?: DGraphElement[\"id\"], size?: GraphSize): DExtEdge {\r\n          return new Constructors(new DExtEdge('dwc')).DPointerTargetable().DGraphElement(model, parentNodeID, graphID, nodeID)\r\n              .DVoidEdge().DEdge().DExtEdge().end();\r\n      }*/\n}, _class36.subclasses = [], _class36._extends = [], _class36)) || _class35) || _class35);\nexport let LExtEdge = (_dec19 = RuntimeAccessible('LExtEdge'), _dec19(_class37 = (_class38 = class LExtEdge extends LEdge {\n  constructor() {\n    super(...arguments);\n    this.__raw = void 0;\n    this.id = void 0;\n    this.graph = void 0;\n    this.model = void 0;\n    this.subElements = void 0;\n    this.state = void 0;\n    this.start = void 0;\n    this.end = void 0;\n    this.__isLExtEdge = void 0;\n    this.__isLEdge = void 0;\n    this.__isLVoidEdge = void 0;\n  } // static singleton: LGraphElement;\n  // static logic: typeof LGraphElement;\n  // static structure: typeof DGraphElement;\n  // isSelected: Dictionary<DocString<Pointer<DUser>>, boolean> = {};\n  isSelected(forUser) {\n    return this.wrongAccessMessage(\"node.isSelected()\");\n  }\n  // containedIn!: LGraphElement;\n}, _class38.subclasses = [], _class38._extends = [], _class38)) || _class37);\nRuntimeAccessibleClass.set_extend(DEdge, DExtEdge);\nRuntimeAccessibleClass.set_extend(LEdge, LExtEdge);\nexport let DRefEdge = (_dec20 = RuntimeAccessible('DRefEdge'), Leaf(_class39 = _dec20(_class39 = (_class40 = class DRefEdge extends DEdge {\n  constructor() {\n    super(...arguments);\n    this.start = void 0;\n    this.end = void 0;\n    this.isSelected = void 0;\n    this.__isDRefEdge = void 0;\n  } // extends DEdge\n  /*\r\n      public static new(model: DGraph[\"model\"], parentNodeID: DGraphElement[\"father\"], graphID: DGraphElement[\"graph\"], nodeID?: DGraphElement[\"id\"]): DRefEdge {\r\n          return new Constructors(new DRefEdge('dwc')).DPointerTargetable().DGraphElement(model, parentNodeID, graphID, nodeID)\r\n              .DVoidEdge().DEdge().DRefEdge().end();\r\n      }*/\n}, _class40.subclasses = [], _class40._extends = [], _class40)) || _class39) || _class39);\nexport let LRefEdge = (_dec21 = RuntimeAccessible('LRefEdge'), _dec21(_class41 = (_class42 = class LRefEdge extends LEdge {\n  constructor() {\n    super(...arguments);\n    this.start = void 0;\n    this.end = void 0;\n    this.__isLRefEdge = void 0;\n  } // __raw!: DRefEdge;\n}, _class42.subclasses = [], _class42._extends = [], _class42)) || _class41);\nRuntimeAccessibleClass.set_extend(DEdge, DRefEdge);\nRuntimeAccessibleClass.set_extend(LEdge, LRefEdge);\n// for edges without a modelling element\n\n/*\r\n\r\nlet a = `DExtEdge, DRefEdge, DVoidEdge, LGraphVertex, LRefEdge, LEdgePoint, DVoidVertex, DGraphVertex, DEdgePoint,\r\n DVertex, DEdge, LVertex, LGraph, DGraph, LVoidVertex, LVoidEdge, LEdge, LGraphElement, LExtEdge, DGraphElement`;\r\n  // // ... get from export in index.ts\r\na = a.replaceAll(',,', \",\")\r\nlet aa = a.split(\",\").map(a => a.trim().substring(1));\r\n\r\nfunction onlyUnique(value, index, self) { return self.indexOf(value) === index; }\r\n\r\naa = aa.filter(onlyUnique).filter( a=> !!a)\r\nlet r = aa.filter(onlyUnique).filter( a=> !!a).map( a=> `export type W${a} = getWParams<L${a}, D${a}>;`).join('\\n')\r\ndocument.body.innerText = r;\r\n*/\n\n// getWParams<LGraphVertex, DGraphVertex>;\n\nconsole.warn('ts loading graphDataElement');","map":{"version":3,"names":["isDeepStrictEqual","BEGIN","Constructors","CoordinateMode","Debug","DPointerTargetable","DUser","EdgeBendingMode","END","GraphElementComponent","GraphPoint","GraphSize","Leaf","Log","LPointerTargetable","MixOnlyFuncs","Node","Pointers","RuntimeAccessible","RuntimeAccessibleClass","SetFieldAction","ShortAttribETypes","Size","store","TargetableProxyHandler","U","Uarr","windoww","EdgeGapMode","Geom","jsxDEV","_jsxDEV","console","warn","packageDefaultSize","DGraphElement","_dec","_class","_class2","constructor","arguments","id","graph","model","isSelected","subElements","state","father","x","y","zIndex","w","h","view","favoriteNode","edgesIn","edgesOut","new","htmlindex","parentNodeID","graphID","nodeID","a","b","undefined","end","subclasses","_extends","LGraphElement","_dec2","_class3","_class4","__raw","allSubNodes","width","height","z","__info_of_z__","type","EInt","txt","__info_of_zIndex__","zoom","html","size","position","htmlSize","htmlPosition","component","vertex","__info__of__vertex","__info__of__favoriteNode","EBoolean","startPoint","endPoint","__info_of__startPoint","children","fileName","_jsxFileName","lineNumber","columnNumber","__info_of__endPoint","__info_of__graph","innerGraph","__info_of__innnerGraph","outerGraph","__info_of__outerGraphGraph","__info_of__graphAncestors","graphAncestors","__info_of__edgesIn","__info_of__edgesOut","__info_of__edgesStart","__info_of__edgesEnd","outerSize","__info_of__outerSize","innerSize","__info_of__innerSize","__info_of__size","__info_of__isselected","__info_of_select","__info_of_deselect","__info_of_toggleSelect","__info_of_isSelected","getNodeId","o","_node","node","extends","className","from","get_graph","context","get_innerGraph","get_edgesIn","fromArr","data","get_edgesOut","set_edgesIn","val","c","set_edgesOut","get_edgesStart","get_edgesEnd","set_edgesStart","set_edgesEnd","_defaultCollectionGetter","k","fromPointer","_defaultGetter","v","Array","isArray","length","isPointer","ret","get_view","e","ee","_defaultSetter","log","get_graphAncestors","current","proxyObject","next","DGraph","cname","push","get_outerGraph","wrap","get_vertex","lcurrent","dcurrent","DVertex","DVoidVertex","DGraphVertex","fromD","exDev","_lcurrent","exDevv","_dcurrent","get_x","get_size","set_x","set_size","get_y","set_y","get_w","set_w","get_h","set_h","get_width","set_width","get_height","set_height","get_position","set_position","get_sizeold","get_component","map","_this$get_component","props","set_view","eDevv","getSize","outer","canTriggerSet","wrongAccessMessage","get_getSize","_this","get_innerSize","get_outerSize","r","get_innerSize_impl","_component$props","lightMode","DEdge","DVoidEdge","nosize","coord","get_htmlSize","DEdgePoint","def","defaultVSize","decodePosCoords","translateSize","actualSize","of","updateSize","isOldElement","clonedCounter","adaptWidth","adaptHeight","encodePosCoords","get_html","set_html","cannotSet","set_htmlSize","get_htmlPosition","tl","set_htmlPosition","get_zIndex","set_zIndex","get_z","set_z","get_subElements","Set","set_subElements","eDev","pointers","equals","idlookup","getState","arrdiff","arrayDifference","oldsubelementid","removed","subelement","newsubelementid","added","get_isResized","isResized","set_isResized","get_model","modelElementId","$","dataset","dataid","lModelElement","get_allSubNodes","tocheck","checked","dblcheck","newtocheck","ptr","fistContainer","subnode","se","arrayMergeInPlace","Object","keys","get_father","set_father","select","forUser","deselect","toggleSelected","get_select","get_deselect","get_toggleSelected","get_isSelected","set_isSelected","get_state","key","set_state","get_startPoint","get_startEndPoint","get_endPoint","isStart","offset","isPercentage","add","set_extend","_dec3","_class5","_class6","parentgraphID","DGraph_makeID","getNodes","dmp","out","$allnodes","matchedids","d","matchedidmap","objectFromArrayValues","allnodesarr","filternode","_d$dataset","_d$dataset2","$matched","filter","$notMatched","n","defaultEdgePointSize","defaultVertexSize","LGraph","_dec4","_class7","_class8","graphSize","__info_of__zoom","label","__info_of__offset","__info_of__graphSize","__info_of__translateSize","__info_of__translateHtmlSize","get_offset","set_offset","get_zoom","toGraphSize","get_coord","translateHtmlSize","get_translateHtmlSize","graphHtmlSize","subtract","multiply","get_translateSize","hasOwnProperty","ex","ancestors","indexOf","g","contains","elem","get_contains","targetid","_dec5","_class9","_class10","LVoidVertex","_dec6","_class11","_class12","_dec7","_class13","_class14","__isDEdgePoint","LEdgePoint","_dec8","_class15","_class16","__isLEdgePoint","edge","__info_of__edge","get_edge","set_edge","sp0","ep0","edgePointCoordMode","absolute","le","sp","ep","mode","relativePercent","relativeOffset","relativeOffsetStart","relativeOffsetEnd","useStart","useEnd","offsetsp","offsetep","divide","_dec9","_class17","_class18","__isDVertex","LVertex","_dec10","_class19","_class20","__isLVertex","_dec11","_class21","_class22","__isDGraph","__isDGraphVertex","LG","LV","LGraphVertex","_dec12","_class23","_class24","__isLGraph","__isLGraphVertex","_dec13","_class25","_class26","start","__isDVoidEdge","midPoints","midnodes","longestLabel","labels","EdgeSegment","_dec14","_class27","mid","svgLetter","gapMode","index","prevSegment","prev","bezier","dpart","m","rad","radLabels","isLongest","Bezier_quadratic_mirrored","addBezierPoint","Bezier_quadratic","Bezier_cubic_mirrored","Bezier_cubic","Line","Elliptical_arc","Bezier_QT","Bezier_CS","prevedgemakerbezier","mirroredBezier","pt","invertLastBezierPt","uncutPt","makeD","getM","mToRad","Math","atan","bezierpts","finalpart","p","join","bezierptsUncut","finalpartUncut","average","bendingMode","vector","calcLength","distanceFromPoint","EdgeFillSegment","autoFill","lineFill","arcFill","center","gap","LVoidEdge","_dec15","_class29","_class30","__isLVoidEdge","allNodes","__info_of__longestLabel","readType","writeType","__info_of__label","__info_of__labels","__info_of__allNodes","segments","segments_inner","segments_outer","__info_of__segments","__info_of__d","EString","get_label","get_longestLabel","set_longestLabel","get_labels","set_labels","headPos_impl","isHead","headSize0","segment0","zoom0","segment","get_segments","tmp","edgeHeadSize","edgeTailSize","headPos","useBezierPoints","x4headsize","secondIntersection","segmentDistance","sqrt","safeDistance","max","closestIntersection","exx","tailPos","get_headPos","headSize","get_tailPos","get_allNodes","get_start","get_midnodes","get_end","get_midPoints","addMidPoint","get_addMidPoint","impl_addMidPoints","set_midPoints","get_label_impl","nodes","l","labelmaker","labelmakerfunc","get_startPoint_Outer","get_endPoint_Outer","get_startPoint_inner","get_endPoint_inner","get_edgeStartEnd_inner","svgLetterSize","s","addM","doublingMidPoints","first","others","get_points_impl","getAnchorOffset","all","flatMap","ge","i","base","rets","rete","singleton","edgeStartOffset","edgeStartOffset_isPercentage","get_points","get_points_outer","get_points_inner","get_d","get_segments_outer","get_segments_impl","get_segments_inner","bm","edgeGapMode","segmentSize","increase","endindex","slice","fillSegments","snapSegmentsToNodeBorders","setLabels","rett","fillers","head","tail","longestindex","longest","canCutStart","edgeStartStopAtBoundaries","canCutEnd","edgeEndStopAtBoundaries","grid","ci","curr","doStartCut","doEndCut","duplicate","br","extpt","prevpt","closestPoint","prevendpt","get_edgeEnd","get_edgeEnd_outer","get_edgeEnd_inner","wrapAll","set_midnodes","_dec16","_class31","_class32","__isDEdge","LEdge","_dec17","_class33","_class34","__isLEdge","DExtEdge","_dec18","_class35","_class36","__isDExtEdge","LExtEdge","_dec19","_class37","_class38","__isLExtEdge","DRefEdge","_dec20","_class39","_class40","__isDRefEdge","LRefEdge","_dec21","_class41","_class42","__isLRefEdge"],"sources":["C:/0Programmi/Dev/projects/frontend/jjodel/src/model/dataStructure/GraphDataElements.tsx"],"sourcesContent":["// import {Mixin} from \"ts-mixer\";\r\nimport {isDeepStrictEqual} from \"util\";\r\nimport {\r\n    BEGIN,\r\n    Constructors,\r\n    CoordinateMode,\r\n    Debug,\r\n    Dictionary,\r\n    DMap,\r\n    DModelElement,\r\n    DocString,\r\n    DPointerTargetable,\r\n    DState,\r\n    DUser,\r\n    DViewElement,\r\n    EdgeBendingMode,\r\n    END,\r\n    getWParams,\r\n    GObject,\r\n    GraphElementComponent,\r\n    GraphPoint,\r\n    GraphSize,\r\n    Info,\r\n    Leaf,\r\n    LMap,\r\n    LModelElement,\r\n    Log,\r\n    LogicContext,\r\n    LPointerTargetable,\r\n    LViewElement,\r\n    MixOnlyFuncs,\r\n    Node,\r\n    Pack1,\r\n    PackArr,\r\n    Point,\r\n    Pointer,\r\n    Pointers,\r\n    PrimitiveType,\r\n    RuntimeAccessible,\r\n    RuntimeAccessibleClass,\r\n    SetFieldAction,\r\n    ShortAttribETypes,\r\n    Size,\r\n    store,\r\n    TargetableProxyHandler,\r\n    U,\r\n    Uarr,\r\n    windoww\r\n} from \"../../joiner\";\r\nimport type {RefObject} from \"react\";\r\nimport {EdgeGapMode, InitialVertexSize} from \"../../joiner/types\";\r\nimport {labelfunc} from \"../../joiner/classes\";\r\nimport {Geom} from \"../../common/Geom\";\r\n\r\n\r\nconsole.warn('ts loading graphDataElement');\r\n\r\nexport const packageDefaultSize = new GraphSize(0, 0, 400, 500);\r\n\r\n@Node\r\n@RuntimeAccessible('DGraphElement')\r\nexport class DGraphElement extends DPointerTargetable {\r\n    // static _super = DPointerTargetable;\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // static singleton: LGraphElement;\r\n    // static logic: typeof LGraphElement;\r\n    // static structure: typeof DGraphElement;\r\n    id!: Pointer<DGraphElement, 1, 1, LGraphElement>;\r\n    graph!: Pointer<DGraph, 1, 1, LGraph>;\r\n    model?: Pointer<DModelElement, 0, 1, LModelElement>;\r\n    isSelected!: Dictionary<DocString<Pointer<DUser>>, boolean>;\r\n    // containedIn!: Pointer<DGraphElement, 0, 1, LGraphElement>;\r\n    subElements!: Pointer<DGraphElement, 0, 'N', LGraphElement>;\r\n    state: DMap = {} as any;\r\n    father!: Pointer<DGraphElement, 1, 1, LGraphElement>;\r\n    x!: number;\r\n    y!: number;\r\n    zIndex: number = 100;\r\n    w!: number;\r\n    h!: number;\r\n    // width: number = 300;\r\n    // height: number = 400;\r\n    view!: Pointer<DViewElement, 1, 1, LViewElement>;\r\n    favoriteNode!: boolean;\r\n    edgesIn!: Pointer<DEdge>[];\r\n    edgesOut!: Pointer<DEdge>[];\r\n\r\n\r\n    public static new(htmlindex: number, model: DGraphElement[\"model\"]|null|undefined, parentNodeID: DGraphElement[\"father\"],\r\n                      graphID: DGraphElement[\"graph\"], nodeID?: DGraphElement[\"id\"]|undefined, a?: any, b?:any, ...c:any): DGraphElement {\r\n        return new Constructors(new DGraphElement('dwc'), parentNodeID, true, undefined, nodeID)\r\n            .DPointerTargetable()\r\n            .DGraphElement(model, graphID, htmlindex).end();\r\n    }\r\n\r\n}\r\n@RuntimeAccessible('LGraphElement')\r\nexport class LGraphElement<Context extends LogicContext<DGraphElement> = any, C extends Context = Context> extends LPointerTargetable {\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static getNodeId<L extends LGraphElement, D extends DGraphElement>(o?:L | D | Pointer<D> | LModelElement | DModelElement | Pointer<DModelElement>): Pointer<D> {\r\n        if (!o) return undefined as any;\r\n        let node: any = o;\r\n        // from L to D\r\n        // let cname = (node.__raw || node).className;\r\n        // from DModelE to LGraphE\r\n        if (RuntimeAccessibleClass.extends((o as any).className, \"DModelElement\")) node = LPointerTargetable.from(o as DModelElement).node as LGraphElement;\r\n        return (typeof node === \"string\") ? node : node?.id;\r\n    }\r\n    // static singleton: LGraphElement;\r\n    // static logic: typeof LGraphElement;\r\n    // static structure: typeof DGraphElement;\r\n    __raw!: DGraphElement;\r\n    id!: Pointer<DGraphElement, 1, 1, LGraphElement>;\r\n    father!: LGraphElement;\r\n    graph!: LGraph; // todo: can be removed and accessed by navigating .father\r\n    model?: LModelElement;\r\n    // protected isSelected!: Dictionary<DocString<Pointer<DUser>>, boolean>; //  & ((forUser?: Pointer<DUser>) => boolean);\r\n\r\n    // containedIn?: LGraphElement;\r\n    subElements!: LGraphElement[]; // shallow, direct subelements\r\n    state!: LMap;\r\n    allSubNodes!: LGraphElement[]; // deep, nested subelements\r\n    x!: number;\r\n    y!: number;\r\n    width!: number;\r\n    height!: number\r\n\r\n    z!:number;\r\n    zIndex!: number;\r\n    __info_of_z__: Info = {type:ShortAttribETypes.EInt, txt: \"alias for zIndex\"};\r\n    __info_of_zIndex__: Info = {type:ShortAttribETypes.EInt,\r\n        txt: \"Determine the z-axis priority of the element.<br/>Higher value tende to overlap other elements.<br/>Lower value tends to be on background.\"};\r\n    zoom!: GraphPoint;\r\n    html?: Element;\r\n\r\n    // fittizi\r\n    w!:number;\r\n    h!:number;\r\n    size!: GraphSize;\r\n    position!: GraphPoint;\r\n    htmlSize!: Size; // size and position in global document coordinates.\r\n    htmlPosition!: Point;\r\n    view!: LViewElement;\r\n    component!: GraphElementComponent;\r\n    favoriteNode!: boolean;\r\n    vertex?: LVoidVertex;\r\n    __info__of__vertex: Info = {type: \"LVoidVertex\", txt: \"the foremost vertex containing this graphElement, or undefiened.\"}\r\n    __info__of__favoriteNode: Info = {type: ShortAttribETypes.EBoolean,\r\n        txt: \"<span>Indicates this is the primarly used (by default) node to refer to a modelling element that might have multiple representations.\" +\r\n            \"<br> Can be used as favorite target for edges or other.\"}\r\n\r\n    startPoint!: GraphPoint;\r\n    endPoint!: GraphPoint;\r\n    __info_of__startPoint: Info = {type: \"GraphPoint\", txt:<span>Where the outgoing edges should start their paths.\r\n            <br/>Obtained by combining anchoring point offset specified in view, before snapping to a Vertex border.\r\n            <br/>Defaults in outer coordinates.</span>};\r\n    __info_of__endPoint: Info = {type: \"GraphPoint\", txt:<span>Where the incoming edges should end their paths.\r\n            <br/>Obtained by combining anchoring point offset specified in view, before snapping to a Vertex border.\r\n            <br/>Defaults in outer coordinates.</span>};\r\n\r\n    __info_of__graph: Info = {type:\"\", txt:\"\"};\r\n    innerGraph!: LGraph;\r\n    __info_of__innnerGraph: Info = {type:\"\", txt:\"\"};\r\n    outerGraph!: LGraph;\r\n    __info_of__outerGraphGraph: Info = {type:\"\", txt:\"\"};\r\n    get_graph(context: Context): LGraph { return this.get_innerGraph(context); }\r\n\r\n    __info_of__graphAncestors: Info = {type:\"LGraph[]\",\r\n        txt:\"<span>collection of the stack of Graphs containing the current element where [0] is the most nested graph, and last is root graph.</span>\"};\r\n    graphAncestors!: LGraph[];\r\n\r\n    edgesIn!: LVoidEdge[];\r\n    edgesOut!: LVoidEdge[];\r\n    __info_of__edgesIn: Info = {type:\"LEdge[]\", txt:<div>Edges incoming into this element. <code>this.edgesOut[i].end</code> always equals to <code>this</code>.</div>}\r\n    __info_of__edgesOut: Info = {type:\"LEdge[]\", txt:<div>Edges outgoing from this element. <code>this.edgesIn[i].start</code> always equals to <code>this</code>.</div>}\r\n    __info_of__edgesStart: Info = {type:\"LEdge[]\", txt:<div>Alias for this.edgesOut</div>}\r\n    __info_of__edgesEnd: Info = {type:\"LEdge[]\", txt:<div>Alias for this.edgesIn</div>}\r\n    public get_edgesIn(context: Context): this[\"edgesIn\"] { return LPointerTargetable.fromArr(context.data.edgesIn); }\r\n    public get_edgesOut(context: Context): this[\"edgesOut\"]  { return LPointerTargetable.fromArr(context.data.edgesOut); }\r\n    public set_edgesIn(val: PackArr<LVoidEdge>, c: Context): boolean { return SetFieldAction.new(c.data.id, \"edgesIn\", Pointers.fromArr(val), '', true); }\r\n    public set_edgesOut(val: PackArr<LVoidEdge>, c: Context): boolean { return SetFieldAction.new(c.data.id, \"edgesOut\", Pointers.fromArr(val), '', true); }\r\n    public get_edgesStart(context: Context): this[\"edgesIn\"]  { return this.get_edgesIn(context); }\r\n    public get_edgesEnd(context: Context): this[\"edgesOut\"]  { return this.get_edgesOut(context); }\r\n    public set_edgesStart(val: PackArr<LVoidEdge>, context: Context): boolean { return this.set_edgesIn(val, context); }\r\n    public set_edgesEnd(val: PackArr<LVoidEdge>, context: Context): boolean { return this.set_edgesOut(val, context); }\r\n\r\n\r\n    protected _defaultCollectionGetter(c: Context, k: keyof Context[\"data\"]): LPointerTargetable[] { return LPointerTargetable.fromPointer((c.data as any)[k]); }\r\n    protected _defaultGetter(c: Context, k: keyof Context[\"data\"]): any {\r\n        //console.log(\"default Getter\");\r\n        if (k in c.data) {\r\n            let v = (c.data as any)[k];\r\n            if (Array.isArray(v)) {\r\n                if (v.length === 0) return [];\r\n                else if (Pointers.isPointer(v[0] as any)) return this._defaultCollectionGetter(c, k);\r\n                return v;\r\n            } else return v;\r\n        }\r\n        let ret: any;\r\n        let view = this.get_view(c);\r\n        try { ret = (view as any)[k] } catch (e) { Log.ee(\"Could not find get_ property \\\"\" + k + \"\\\" in node or view.\", {c, view, k}); return undefined; }\r\n        return ret;\r\n    }\r\n\r\n    protected _defaultSetter(v: any, c: Context, k: keyof Context[\"data\"]): any {\r\n        console.log(\"default Setter\");\r\n        if (k in c.data) {\r\n            let isPointer: boolean;\r\n            if (Array.isArray(v)) {\r\n                if (v.length === 0) isPointer = true; // assumed, should not cause harm if it is not.\r\n                // it will delete remove an entry in pointedBy from all oldValue entries in the array that should not be present anyway.\r\n                // like oldVal.map( id => U.arrayRemove(LData.wrap(id).pointedBy, c.data.this_id)\r\n                else isPointer = Pointers.isPointer(v[0] as any);\r\n            } else isPointer = false;\r\n            return SetFieldAction.new(c.data.id, k as any, v, '', isPointer);\r\n        }\r\n        let view = this.get_view(c);\r\n        try { (view as any)[k] = v; } catch (e) { Log.ee(\"Could not find set_ property \\\"\" + k + \"\\\" in node or view.\", {c, v, k, view}); return false; }\r\n        return true;\r\n    }\r\n\r\n    get_graphAncestors(c: Context): LGraph[] {\r\n        let current = c.proxyObject;\r\n        let next = current.father;\r\n        let ret: LGraph[] = [];\r\n        while(next) {\r\n            if (RuntimeAccessibleClass.extends(next.className, DGraph.cname)) ret.push(next as LGraph);\r\n            if (current.id === next.id) break;\r\n            current = next;\r\n            next = next.father;\r\n        }\r\n        return ret;\r\n    }\r\n    get_outerGraph(context: Context): LGraph {\r\n        // todo: this relies on the fact that GraphVertex are not passing their own id to their childrens, but the parent graph id\r\n        return TargetableProxyHandler.wrap(context.data.graph);\r\n    }\r\n    get_vertex(context: Context): this[\"vertex\"] {\r\n        let lcurrent: LGraphElement = LPointerTargetable.fromPointer(context.data.id);\r\n        let dcurrent = lcurrent.__raw;\r\n        // iterate parents.\r\n        while(dcurrent){\r\n            switch(dcurrent.className){\r\n                case DVertex.cname:\r\n                case DVoidVertex.cname:\r\n                case DGraphVertex.cname: return (lcurrent || LPointerTargetable.fromD(dcurrent)) as LVoidVertex;\r\n                default:\r\n                    if (!dcurrent.father || dcurrent.id === dcurrent.father) return undefined;\r\n                    Log.exDev(!dcurrent.father || dcurrent.id === dcurrent.father, \"node failed to get containing vertex\", context.data, dcurrent, lcurrent);\r\n                    lcurrent = LPointerTargetable.fromPointer(dcurrent.father);\r\n                    dcurrent = lcurrent.__raw;\r\n            }\r\n        }\r\n        return undefined;\r\n    }\r\n\r\n    get_innerGraph(context: Context): LGraph {\r\n        let lcurrent: LGraphElement = LPointerTargetable.fromPointer(context.data.father);\r\n        let dcurrent = lcurrent?.__raw;\r\n\r\n        // if no parent, but it's a graph, return itself.\r\n        if (!dcurrent) {\r\n            dcurrent = context.data;\r\n            switch(dcurrent.className){\r\n                case DGraph.cname:\r\n                case DGraphVertex.cname: return (lcurrent || LPointerTargetable.fromD(dcurrent)) as LGraph;\r\n                default: return Log.exDevv(\"node failed to get containing graph\", context.data, dcurrent, lcurrent);\r\n            }\r\n        }\r\n\r\n        // if it have a parent, iterate parents.\r\n        while(true){\r\n            switch(dcurrent?.className){\r\n                case DGraph.cname:\r\n                case DGraphVertex.cname: return (lcurrent || LPointerTargetable.fromD(dcurrent)) as LGraph;\r\n                default:\r\n                    if (!dcurrent.father || dcurrent.id === dcurrent.father) {\r\n                        /*switch(dcurrent.className){\r\n                            case DGraph.name:\r\n                            case DGraphVertex.name: return (lcurrent || LPointerTargetable.fromD(dcurrent)) as LGraph;\r\n                            default: */return Log.exDevv(\"node failed to get containing graph\", context.data, dcurrent, lcurrent);\r\n                        //}\r\n                    }\r\n                    lcurrent = LPointerTargetable.fromPointer(dcurrent.father);\r\n                    dcurrent = lcurrent.__raw;\r\n            }\r\n        }\r\n    }\r\n\r\n    // set_x(val: this[\"x\"], context: Context): boolean { SetFieldAction.new(context.data.id, \"x\", val, undefined, false); return true; }\r\n    // get_x(context: Context): this[\"x\"] { return context.data.x; }\r\n    get_x(context: Context): this[\"x\"] { return this.get_size(context).x; }\r\n    set_x(val: this[\"x\"], context: Context): boolean { return this.set_size({x:val}, context); }\r\n    get_y(context: Context): this[\"y\"] { return this.get_size(context).y; }\r\n    set_y(val: this[\"y\"], context: Context): boolean { return this.set_size({y:val}, context); }\r\n\r\n    get_w(context: Context): this[\"w\"] { return this.get_size(context).w; }\r\n    set_w(val: this[\"w\"], context: Context): boolean { return this.set_size({w:val}, context); }\r\n    get_h(context: Context): this[\"h\"] { return this.get_size(context).h; }\r\n    set_h(val: this[\"h\"], context: Context): boolean { return this.set_size({h:val}, context); }\r\n\r\n    get_width(context: Context): this[\"w\"] { return this.get_w(context); }\r\n    set_width(val: this[\"w\"], context: Context): boolean { return this.set_w(val, context); }\r\n    get_height(context: Context): this[\"h\"] { return this.get_h(context); }\r\n    set_height(val: this[\"h\"], context: Context): boolean { return this.set_h(val, context); }\r\n\r\n    get_position(context: Context): this[\"position\"] { return new GraphPoint(context.data.x, context.data.y); }\r\n    set_position(val: this[\"position\"], context: Context): boolean {\r\n        BEGIN()\r\n        SetFieldAction.new(context.data.id, \"x\", val.x, undefined, false);\r\n        SetFieldAction.new(context.data.id, \"y\", val.y, undefined, false);\r\n        END()\r\n        return true; }\r\n\r\n    get_sizeold(context: Context): this[\"size\"] { return new GraphSize(context.data.x, context.data.y, context.data.w, context.data.h); }\r\n    get_component(context: Context): this[\"component\"] {\r\n        // switch(context.data.className) { case DEdgePoint.name: return GraphElementComponent.map[context.data.father]; }\r\n        return GraphElementComponent.map[context.data.id]; }\r\n    // get_view(context: Context): this[\"view\"] { return this.get_component(context).props.view; }\r\n    get_view(context: Context): this[\"view\"] {\r\n        return (this.get_component(context)?.props.view as this[\"view\"]);\r\n        // return LPointerTargetable.fromPointer(context.data.view);\r\n    }\r\n    set_view(val: Pack1<this[\"view\"]>, context: Context){\r\n        Log.eDevv(\"node.view is readonly, change it through props or the model\");\r\n        // let ptr: DGraphElement[\"view\"] = Pointers.from(val as this[\"view\"]);\r\n        // return SetFieldAction.new(context.data.id, \"view\", ptr, '', true);\r\n    }\r\n\r\n    outerSize!: LGraphElement[\"size\"];\r\n    __info_of__outerSize: Info = {type:\"GraphSize\", txt:\"the size of the current element relative to the first (root) graph level.\"};\r\n    innerSize!: LGraphElement[\"size\"];\r\n    __info_of__innerSize: Info = {type:\"GraphSize\", txt:\"the size of the current element relative to the last (most nested) graph level.\"};\r\n    __info_of__size: Info = {type:\"GraphSize\", txt: \"same as innerSize.\"};\r\n\r\n\r\n    getSize(outer: boolean = false, canTriggerSet: boolean = true): Readonly<GraphSize> { return this.wrongAccessMessage(\"getSize()\"); }\r\n    get_getSize(c: Context): ((outer?: boolean, canTriggerSet?: boolean) => Readonly<GraphSize>) {\r\n        return (outer: boolean = true, canTriggerSet: boolean = true) => this.get_innerSize(c, canTriggerSet, outer); }\r\n\r\n    get_outerSize(context: Context, canTriggerSet: boolean = true): Readonly<GraphSize> {\r\n        return this.get_innerSize(context, canTriggerSet, true);\r\n    }\r\n    get_size(context: Context, canTriggerSet: boolean = true): Readonly<GraphSize> { return this.get_innerSize(context, canTriggerSet, false); }\r\n    get_innerSize(context: Context, canTriggerSet: boolean = true, outerSize: boolean = false): Readonly<GraphSize> {\r\n        let r = this.get_innerSize_impl(context, canTriggerSet, outerSize);\r\n        return new GraphSize(r.x, r.y, r.w, r.h);\r\n    }\r\n    protected get_innerSize_impl(context: Context, canTriggerSet: boolean = true, outerSize: boolean = false): Readonly<GraphSize> {\r\n        canTriggerSet = canTriggerSet && !Debug.lightMode;\r\n        switch (context.data.className){\r\n            default: return Log.exDevv(\"unexpected classname in get_size switch: \" + context.data.className);\r\n            case DEdge.cname:\r\n            case DVoidEdge.cname:\r\n            case DGraph.cname: return nosize as any;\r\n            // case DField.cname:\r\n            case DGraphElement.cname:\r\n                let graph = outerSize ? this.get_outerGraph(context) : this.get_innerGraph(context);\r\n                return graph.coord(this.get_htmlSize(context));\r\n            case DVoidVertex.cname:\r\n            case DVertex.cname:\r\n            case DEdgePoint.cname:\r\n            case DGraphVertex.cname: break;\r\n        }\r\n        // low prio todo: memoization in proxy, as long state does not change keep a collection Dictionary[object][key] = returnval. it gets emptied when state is updated.\r\n        /*console.log(\"get_size(\"+(this.props?.data as any).name+\")\", {\r\n            view:this.props.view.getSize(this.props.dataid || this.props.nodeid as string),\r\n            node:this.props.node?.size,\r\n            default: this.props.view.defaultVSize});*/\r\n        let component = this.get_component(context);\r\n        // windoww.debugg = context;\r\n        // console.log(\"edgee getsize\", {component, view:component?.props?.view, data:{...context.data}});\r\n        let view = component?.props?.view || this.get_view(context);\r\n        // (window as any).retry = ()=>view.getSize(context.data.id);\r\n        let ret: GraphSize = view.getSize(context.data.id) as any; // (this.props.dataid || this.props.nodeid as string)\r\n        // console.log(\"getSize() from view\", {ret: ret ? {...ret} : ret});\r\n        if (!ret) {\r\n            ret = new GraphSize();\r\n            ret.x = context.data.x;\r\n            ret.y = context.data.y;\r\n            ret.w = context.data.w;\r\n            ret.h = context.data.h;\r\n            let def: GraphSize | undefined;\r\n            if (undefined===(ret.x)) { if (!def) def = view.defaultVSize; ret.x = def.x;}\r\n            if (undefined===(ret.y)) { if (!def) def = view.defaultVSize; ret.y = def.y;}\r\n            if (undefined===(ret.w)) { if (!def) def = view.defaultVSize; ret.w = def.w;}\r\n            if (undefined===(ret.h)) { if (!def) def = view.defaultVSize; ret.h = def.h;}\r\n            // console.log(\"getSize() from node merged with defaultVSize\", {ret: ret ? {...ret} : ret});\r\n        }\r\n        if (context.data.className === DEdgePoint.cname) { ret = (this as any as LEdgePoint).decodePosCoords(context, ret, view); }\r\n/*\r\n        if ((context.data as DVoidVertex).isResized) {\r\n            return ret;\r\n        }*/\r\n        if (!canTriggerSet) {\r\n            if (outerSize) ret = this.get_outerGraph(context).translateSize(ret, this.get_innerGraph(context));\r\n            return ret;\r\n        }\r\n        let html: RefObject<HTMLElement | undefined> | undefined = component?.html;\r\n        let actualSize: Partial<Size> & {w:number, h:number} = html?.current ? Size.of(html.current) : {w:0, h:0};\r\n        let updateSize: boolean = false;\r\n        let isOldElement = (context.data.clonedCounter as number) > 3;\r\n        // if w = 0 i don't auto-set it as in first render it has w:0 because is not reredered and not resized.\r\n        // if (canTriggerSet) this.set_size({w:actualSize.w}, context);\r\n        if (view.adaptWidth && ret.w !== actualSize.w) {\r\n            if (canTriggerSet && (isOldElement || actualSize.w !== 0)) {\r\n                ret.w = actualSize.w;\r\n                updateSize = true;\r\n            }\r\n        }\r\n        if (view.adaptHeight && ret.h !== actualSize.h) {\r\n            if (canTriggerSet && (isOldElement || actualSize.h !== 0)) {\r\n                ret.h = actualSize.h;\r\n                updateSize = true;\r\n            }\r\n        }\r\n        // console.log(\"getSize() from node merged with actualSize\", {ret: {...ret}});\r\n\r\n        if (updateSize) this.set_size(ret, context);\r\n        if (outerSize) ret = this.get_outerGraph(context).translateSize(ret, this.get_innerGraph(context));\r\n        return ret;\r\n    }\r\n    // set_size(size: Partial<this[\"size\"]>, context: Context): boolean {\r\n    set_size(size: Partial<GraphSize>, c: Context): boolean {\r\n        // console.log(\"setSize(\"+(this.props?.data as any).name+\") thisss\", this);\r\n        if (!size) return false;\r\n        let view = this.get_view(c);\r\n        if (c.data.className === DEdgePoint.cname) size = (this as any as LEdgePoint).encodePosCoords(c as any, size, view);\r\n        if (view.updateSize(c.data.id, size)) return true;\r\n        BEGIN()\r\n        if (size.x !== c.data.x && size.x !== undefined) SetFieldAction.new(c.data.id, \"x\", size.x, undefined, false);\r\n        if (size.y !== c.data.y && size.y !== undefined) SetFieldAction.new(c.data.id, \"y\", size.y, undefined, false);\r\n        if (size.w !== c.data.w && size.w !== undefined) SetFieldAction.new(c.data.id, \"w\", size.w, undefined, false);\r\n        if (size.h !== c.data.h && size.h !== undefined) SetFieldAction.new(c.data.id, \"h\", size.h, undefined, false);\r\n        END()\r\n        return true; }\r\n\r\n    get_html(context: Context): this[\"html\"] { return this.get_component(context).html.current || undefined; }\r\n    // get_html(context: Context): this[\"html\"] { return $(\"[node-id='\" + context.data.id + \"']\")[0]; }\r\n    set_html(val: this[\"htmlSize\"], context: Context): boolean { return this.cannotSet(\"set_html(). html is generated through jsx. edit the view instead.\"); }\r\n\r\n    get_htmlSize(context: Context): this[\"htmlSize\"] {\r\n        let html = this.get_html(context);\r\n        return html ? Size.of(html) : new Size(0, 0, 0, 0);\r\n        /*\r\n        let graph = this.get_graph(context);\r\n        if (!html) return nosize as any;\r\n        let size = Size.of(html);\r\n        let zoom = graph.zoom;\r\n        size.x /= zoom.x;\r\n        size.y /= zoom.y;\r\n        return size;*/}\r\n    set_htmlSize(val: this[\"htmlSize\"], context: Context): boolean {\r\n        // might be useful for fixed display size/location elements that stay in place even if you move tab or change zoom. debatable if needed\r\n        this.cannotSet(\"set_htmlSize(): todo extra low priority. set GraphSize through set_size instead.\");\r\n        return true; }\r\n    get_htmlPosition(context: Context): this[\"htmlPosition\"] { return this.get_htmlSize(context).tl(); }\r\n    set_htmlPosition(val: this[\"htmlPosition\"], context: Context): boolean {\r\n        // might be useful for fixed display size/location elements that stay in place even if you move tab or change zoom. debatable if needed\r\n        this.cannotSet(\"set_htmlPosition(): todo extra low priority. set graph position through set_position instead.\");\r\n        return true; }\r\n\r\n\r\n    /* how z-index work, it's really messy.\r\n    * cannot move html position. node id depends on it, and a node moving position would need to change id.\r\n    * so i use css order.\r\n    * first order is assigned through node constructor called by parent component injectProps, according to his last index in html.\r\n    * now z-index is set in node and updated properly.\r\n    * z-index is passed to a prop, rendered as html attribute.\r\n    * css takes the attribute value and uses it in \"order\" css rule.\r\n    * problem: updating node.z doesn't trigger the parent injectprops, so he inject html index and\r\n    * the outernmost html root cannot update his attribute without refreshing the parent and recalling injectprops\r\n    * fixed: by updating it directly in GraphElement.render()\r\n    * */\r\n    get_zIndex(context: Context): this[\"zIndex\"] { return context.data.zIndex; }\r\n    set_zIndex(val: this[\"zIndex\"], context: Context): boolean {\r\n        SetFieldAction.new(context.data.id, \"zIndex\", val, undefined, false);\r\n        return true; }\r\n    get_z(context: Context): this[\"zIndex\"] { return context.data.zIndex; }\r\n    set_z(val: this[\"zIndex\"], context: Context): boolean { return this.set_zIndex(val, context); }\r\n    /*\r\n        get_containedIn(context: Context): this[\"containedIn\"] {\r\n            return context.data.containedIn ? LPointerTargetable.fromPointer(context.data.containedIn) : undefined; }\r\n        set_containedIn(val: Pack1<this[\"containedIn\"]>, context: LogicContext<DGraphElement>): boolean {\r\n            let ptr: DGraphElement[\"containedIn\"] = Pointers.from(val) as any;\r\n            SetFieldAction.new(context.data, 'containedIn', ptr, undefined, true);\r\n            if (ptr) SetFieldAction.new(ptr as any, 'subElements+=', context.data.id);\r\n            return true; }*/\r\n\r\n    get_subElements(context: Context): this[\"subElements\"] {\r\n        return LPointerTargetable.fromArr([...new Set(context.data.subElements)]);\r\n    }\r\n    set_subElements(val: PackArr<this[\"subElements\"]>, context: LogicContext<DGraphElement>): boolean {\r\n        console.log(\"isDeepStrictEqual\", {isDeepStrictEqual});\r\n        Log.eDev([...new Set(val)].length !== val.length, \"subelemnts setter have duplicates\", {val, context});\r\n        // if (isDeepStrictEqual(context.data.subElements, val)) return true;\r\n        let pointers: Pointer<DGraphElement, 0, 'N', LGraphElement> = Pointers.from(val) || [];\r\n        if (Uarr.equals(pointers, context.data.subElements, false)) return true;\r\n        SetFieldAction.new(context.data, 'subElements', pointers, '', true);\r\n        const idlookup = store.getState().idlookup;\r\n        let arrdiff = U.arrayDifference(context.data.subElements, pointers);\r\n        // old subelements\r\n        for (let oldsubelementid of arrdiff.removed) {\r\n            let subelement: DGraphElement = (oldsubelementid && idlookup[oldsubelementid]) as DGraphElement;\r\n            if (subelement.father !== context.data.id) continue;\r\n            LPointerTargetable.from(subelement).father = null as any; // todo: can this happen? è transitorio o causa vertici senza parent permanenti?\r\n        }\r\n        // new subelements\r\n        for (let newsubelementid of arrdiff.added) {\r\n            let subelement: DGraphElement = (newsubelementid && idlookup[newsubelementid]) as DGraphElement;\r\n            if (subelement.father === context.data.id) continue;\r\n            LPointerTargetable.from(subelement).father = context.data.id as any; // trigger side-action\r\n        }\r\n        return true;\r\n    }\r\n\r\n    get_isResized(context: LogicContext<DVoidVertex>): DVoidVertex[\"isResized\"] { return context.data.isResized; }\r\n    set_isResized(val: DVoidVertex[\"isResized\"], context: LogicContext<DVoidVertex>): DVoidVertex[\"isResized\"] {\r\n        return SetFieldAction.new(context.data.id, \"isResized\", val);\r\n    }\r\n\r\n    get_model(context: Context): this[\"model\"] {\r\n        const modelElementId = $('[id=\"' + context.data.id + '\"]')[0].dataset.dataid;\r\n        const lModelElement: LModelElement = LPointerTargetable.from(modelElementId as string);\r\n        return lModelElement;\r\n    }\r\n\r\n    private get_allSubNodes(context: Context, state?: DState): this[\"allSubNodes\"] {\r\n        // return context.data.packages.map(p => LPointerTargetable.from(p));\r\n        state = state || store.getState();\r\n        let tocheck: Pointer<DGraphElement>[] = context.data.subElements || [];\r\n        let checked: Dictionary<Pointer, true> = {};\r\n        let dblcheck: Dictionary<Pointer, Pointer> = {}; // <child, parent>  // debug only\r\n        for (let e of tocheck) dblcheck[e] = context.data.id; // debug only\r\n        checked[context.data.id] = true;//nb6[]{}&\r\n        while (tocheck.length) {\r\n            let newtocheck: Pointer<DGraphElement>[] = [];\r\n            for (let ptr of tocheck) {\r\n                Log.eDev(checked[ptr], \"loop in GraphElements containing themselves\", {dblcheck, context, ptr, checked, fistContainer:dblcheck[ptr]});\r\n                if (checked[ptr]) continue;\r\n                checked[ptr] = true;\r\n                let subnode: DGraphElement = DPointerTargetable.from(ptr, state);\r\n                let se = subnode?.subElements;\r\n                for (let e of se) dblcheck[e] = ptr; // debug only\r\n                U.arrayMergeInPlace(newtocheck, se);\r\n            }\r\n            tocheck = newtocheck;\r\n        }\r\n        delete checked[context.data.id];\r\n        return LPointerTargetable.from(Object.keys(checked), state);\r\n    }\r\n\r\n\r\n    get_father(context: Context): this[\"father\"] { return LPointerTargetable.fromPointer(context.data.father); }\r\n    set_father(val: Pack1<this[\"father\"]>, context: Context): boolean {\r\n        let ptr: DGraphElement[\"father\"] = Pointers.from(val) as any;\r\n        SetFieldAction.new(context.data, 'father', ptr, undefined, true);\r\n        if (ptr) SetFieldAction.new(ptr as any, 'subElements+=', context.data.id);\r\n        return true; }\r\n\r\n    __info_of__isselected: Info = {type: \"Dictionary<Pointer<User>, true>\",\r\n        txt:<div>A map that contains all the users selecting this element as keys, and always true as a value (if present).\r\n            <br/>Edit it through node.select() and node.deselect()</div>}\r\n    __info_of_select: Info = {type:\"function(forUser?:Pointer<User>):void\", txt:\"Marks this node as selected by argument user.\"};\r\n    __info_of_deselect: Info = {type:\"function(forUser?:Pointer<User>):void\", txt:\"Un-marks this node as selected by argument user.\"};\r\n    __info_of_toggleSelect: Info = {type:\"function(usr?:Pointer<User>):void\", txt:\"Calls this.select(usr) if the node is selected by argument user, this.deselect(usr) otherwise. If omitted, argument \\\"usr\\\" is the current user id.<br>Returns the result of this.isSelected() after the toggle.\"};\r\n    __info_of_isSelected: Info = {type:\"function(forUser?:Pointer<User>):void\", txt:\"Tells if this node is selected by argument user.\"};\r\n    select(forUser?: Pointer<DUser>): void { return this.wrongAccessMessage(\"node.select()\"); }\r\n    deselect(forUser?: Pointer<DUser>): void { return this.wrongAccessMessage(\"node.deselect()\"); }\r\n    toggleSelected(forUser?: Pointer<DUser>): void { return this.wrongAccessMessage(\"node.toggleSelected()\"); }\r\n    isSelected(forUser?: Pointer<DUser>): boolean { return this.wrongAccessMessage(\"node.isSelected()\"); }\r\n    get_select(c: Context): (forUser?: Pointer<DUser>)=>void {\r\n        return (forUser?: Pointer<DUser>)=> {\r\n            if (!forUser) forUser = DUser.current;\r\n            if (c.data.isSelected[forUser]) return; // no-op\r\n            let map = {...c.data.isSelected};\r\n            map[forUser] = true;\r\n            SetFieldAction.new(c.data.id, \"isSelected\", map, undefined, false);\r\n            // todo: actually they are pointer to users, but i'm assuming users are not erased at runtime. on deselect too\r\n        }\r\n    }\r\n    get_deselect(c: Context): (forUser?: Pointer<DUser>)=>void {\r\n        return (forUser?: Pointer<DUser>)=> {\r\n            if (!forUser) forUser = DUser.current;\r\n            if (!c.data.isSelected[forUser]) return; // no-op\r\n            let map = {...c.data.isSelected};\r\n            delete map[forUser];\r\n            SetFieldAction.new(c.data.id, \"isSelected\", map, undefined, false);\r\n            // todo: actually they are pointer to users, but i'm assuming users are not erased at runtime. on deselect too\r\n        }\r\n    }\r\n    get_toggleSelected(context: Context): ((forUser?: Pointer<DUser>) => boolean) {\r\n        return (forUser?: Pointer<DUser>): boolean => {\r\n            if (!forUser) forUser = DUser.current;\r\n            if (this.get_isSelected(context)(forUser)) {\r\n                this.get_deselect(context)(forUser);\r\n                return false;\r\n            } else {\r\n                this.get_select(context)(forUser);\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    get_isSelected(context: Context): ((forUser?: Pointer<DUser>) => boolean) {\r\n        return (forUser?: Pointer<DUser>): boolean => {\r\n            if (!forUser) forUser = DUser.current;\r\n            return !!context.data.isSelected[forUser]; }\r\n    }\r\n    set_isSelected(val: this[\"isSelected\"], context: Context): boolean {\r\n        return this.cannotSet(\"graphElement.isSelected(): use this.select() or this.deselect() instead.\");\r\n    }\r\n    /*\r\n    get_isSelected(context: LogicContext<DVoidVertex>): GObject {\r\n        return DPointerTargetable.mapWrap(context.data.isSelected, context.data, 'idlookup.' + context.data.id + '.isSelected', []);\r\n    }*/\r\n\r\n    get_state(context: LogicContext<DGraphElement>): this[\"state\"] {\r\n        let state: GObject = context.data.state;\r\n        for (let key in state) {\r\n            switch(key) {\r\n                case \"id\": break;\r\n                default: state[key] = LPointerTargetable.wrap(state[key]); break;\r\n            }\r\n        }\r\n        return state as any;\r\n    }\r\n    set_state(val: this[\"state\"], context: LogicContext<DGraphElement>): boolean {\r\n        return this.cannotSet(\"graphElement.setstate(): todo\"); }\r\n\r\n\r\n\r\n    // for edges\r\n    public get_startPoint(c: Context|undefined, size?: GraphSize, view?: LViewElement): GraphPoint { return this.get_startEndPoint(c, size, view, true); }\r\n    public get_endPoint(c: Context|undefined, size?: GraphSize, view?: LViewElement): GraphPoint { return this.get_startEndPoint(c, size, view, false); }\r\n    private get_startEndPoint(c: Context|undefined, size?: GraphSize, view?: LViewElement, isStart:boolean=true): GraphPoint {\r\n        if (!size) {\r\n            if (c) size = this.get_size(c) as any; else size = Log.exDevv(\"invalid arguments in get_startEndPoint\", {arguments});\r\n        }\r\n        if (!view) {\r\n            // if (c) view = this.get_view(c); else view = Log.exDevv(\"invalid arguments in get_startPoint\", {arguments});\r\n            view = c && this.get_view(c) || Log.exDevv(\"invalid arguments in get_startEndPoint\", {arguments});\r\n        }\r\n        let offset: GraphPoint = (view as LViewElement)[isStart ? \"edgeStartOffset\" : \"edgeEndOffset\"];\r\n        let isPercentage: boolean = (view as LViewElement)[isStart ? \"edgeStartOffset_isPercentage\" : \"edgeEndOffset_isPercentage\"];\r\n        if (!size) size = new GraphSize(0, 0, 0, 0);\r\n        if (isPercentage) offset = new GraphPoint(offset.x/100*(size.w), offset.y/100*(size.h));\r\n        return size.tl().add(offset, false);\r\n    }\r\n\r\n}\r\nRuntimeAccessibleClass.set_extend(DPointerTargetable, DGraphElement);\r\nRuntimeAccessibleClass.set_extend(LPointerTargetable, LGraphElement)\r\n\r\n\r\n@RuntimeAccessible('DGraph')\r\nexport class DGraph extends DGraphElement {\r\n    // static _super = DGraphElement;\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // static singleton: LGraph;\r\n    // static logic: typeof LGraph;\r\n    // static structure: typeof DGraph;\r\n\r\n    // inherit redefine\r\n    father!: Pointer<DGraphElement, 1, 1, LGraphElement>;\r\n    id!: Pointer<DGraph, 1, 1, LGraph>;\r\n    graph!: Pointer<DGraph, 1, 1, LGraph>;\r\n    model!: Pointer<DModelElement, 1, 1, LModelElement>;\r\n    isSelected!: Dictionary<DocString<Pointer<DUser>>, boolean>;\r\n    // containedIn!: Pointer<DGraphElement, 0, 1, LGraphElement>;\r\n    subElements!: Pointer<DGraphElement, 0, 'N', LGraphElement>;\r\n    state: DMap = {} as any;\r\n    // personal attributes\r\n    zoom!: GraphPoint;\r\n    offset!: GraphPoint; // in-graph scrolling offset\r\n\r\n    public static new(htmlindex: number, model: DGraph[\"model\"],\r\n                      parentNodeID?: DGraphElement[\"father\"], // immediate parent\r\n                      parentgraphID?: DGraphElement[\"graph\"], // graph containing this subgraph (redudant? could get it from father chain)\r\n                      nodeID?: DGraphElement[\"id\"] // this id\r\n    ): DGraph {\r\n        return new Constructors(new DGraph('dwc'), parentNodeID, true, undefined, nodeID || Constructors.DGraph_makeID(model))\r\n            .DPointerTargetable()\r\n            .DGraphElement(model, parentgraphID, htmlindex).DGraph().end();\r\n    }\r\n\r\n\r\n    static getNodes(dmp: import(\"../logicWrapper/LModelElement\").DModelElement[], out: {$matched: JQuery<HTMLElement>; $notMatched: JQuery<HTMLElement>; }): JQuery<HTMLElement> {\r\n        let $allnodes = $('[data-dataid]');\r\n        let matchedids: Pointer[] = (dmp || []).map(d => d.id);\r\n        let matchedidmap:Dictionary<string, boolean> = U.objectFromArrayValues(matchedids);\r\n        if (!out) out = {} as any;\r\n\r\n        let allnodesarr = [...$allnodes];\r\n        let filternode = (d: HTMLElement) => {\r\n            if (!d?.dataset?.dataid) return false;\r\n            let id: string = ''+d?.dataset?.dataid;\r\n            return matchedidmap[id]; };\r\n        out.$matched = $(allnodesarr.filter(filternode));\r\n        out.$notMatched = $(allnodesarr.filter((n) => !filternode(n)));\r\n        return out.$matched;\r\n        // throw new Error(\"Method not implemented.\");\r\n    }\r\n\r\n}\r\nvar nosize = {x:0, y:0, w:0, h:0, nosize:true};\r\nvar defaultEdgePointSize = {x:0, y:0, w:5, h:5};\r\nvar defaultVertexSize = {x:0, y:0, w:140.6818084716797, h:32.52840805053711};\r\n@RuntimeAccessible('LGraph')\r\nexport class LGraph<Context extends LogicContext<DGraph> = any, D extends DGraph = any> extends LGraphElement {\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // static singleton: LGraph;\r\n    // static logic: typeof LGraph;\r\n    // static structure: typeof DGraph;\r\n\r\n    // inherit redefine\r\n    __raw!: DGraph;\r\n    id!: Pointer<DGraph, 1, 1, LGraph>;\r\n    graph!: LGraph;\r\n    model?: LModelElement;\r\n    // isSelected: Dictionary<DocString<Pointer<DUser>>, boolean> = {};\r\n    isSelected(forUser?: Pointer<DUser>): boolean { return this.wrongAccessMessage(\"node.isSelected()\"); }\r\n    // containedIn?: LGraphElement;\r\n    subElements!: LGraphElement[];\r\n    state!: LMap;\r\n    // personal attributes\r\n    zoom!: GraphPoint;\r\n    graphSize!: GraphSize; // derived attribute: bounding rect containing all subnodes, while \"size\" is instead external size of the vertex holding the graph in GraphVertexes\r\n    offset!: GraphPoint; // Scrolling position inside the graph\r\n\r\n    // get_graphSize(context: LogicContext<DGraph>):  Readonly<GraphSize> { return todo: get bounding rect containing all subnodes.; }\r\n    get_offset(context: LogicContext<DGraph>):  Readonly<GraphSize> {\r\n        return new GraphSize(context.data.offset.x, context.data.offset.y);\r\n    }\r\n    set_offset(val: Partial<GraphPoint>, context: Context): boolean {\r\n        if (!val) val = {x:0, y:0};\r\n        if (context.data.offset.x === val.x && context.data.offset.y === val.y) return true;\r\n        if (val.x === undefined && context.data.offset.x !== val.x) val.x = context.data.offset.x;\r\n        if (val.y === undefined && context.data.offset.y !== val.y) val.y = context.data.offset.y;\r\n        SetFieldAction.new(context.data, \"offset\", val as GraphPoint);\r\n        return true;\r\n    }\r\n    get_zoom(context: Context): GraphPoint {\r\n        const zoom: GraphPoint = context.data.zoom;\r\n        // (zoom as any).debug = {rawgraph: context.data.__raw, zoomx: context.data.zoom.x, zoomy: context.data.zoom.y}\r\n        return context.data.zoom; }\r\n\r\n    toGraphSize(...a:Parameters<this[\"coord\"]>): ReturnType<this[\"coord\"]>{ return this.wrongAccessMessage(\"toGraphSize\"); }\r\n    coord(htmlSize: Size): GraphSize { return this.wrongAccessMessage(\"toGraphSize\"); }\r\n    get_coord(context: Context): (htmlSize: Size) => GraphSize {\r\n        return (htmlSize: Size)=> {\r\n            let size: Size = this.get_htmlSize(context);\r\n            let zoom: GraphPoint = this.get_zoom(context);\r\n            return new GraphSize((htmlSize.x - size.x) / zoom.x, (htmlSize.y - size.y) / zoom.y, htmlSize.w/zoom.x, htmlSize.h/zoom.y);\r\n        }\r\n    }\r\n    // get_htmlSize(context: Context): Size { }\r\n    translateSize<T extends GraphSize|GraphPoint>(ret: T, innerGraph: LGraph): T { return this.wrongAccessMessage(\"translateSize()\"); }\r\n    translateHtmlSize<T extends Size|Point, G = T extends Size ? GraphSize : GraphPoint>(size: T): G { return this.wrongAccessMessage(\"translateHtmlSize()\"); }\r\n\r\n    __info_of__zoom: Info = {type:GraphPoint.cname, label:\"zoom\", txt:\"Scales the graph and all subelements by a factor.\"};\r\n    __info_of__offset: Info = {type:GraphPoint.cname, label:\"offset\", txt:\"In-graph scrolling position.\"};\r\n    __info_of__graphSize: Info = {type:GraphSize.cname, label:\"graphSize\", txt:\"size internal to the graph, including internal scroll and panning.\"};\r\n    __info_of__translateSize: Info = {type:\"(T, Graph)=>T where T is GraphSize | GraphPoint\", txt:\"Translates a coordinate set from the local coordinates of a SubGraph to this Graph containing it.\"};\r\n    __info_of__translateHtmlSize: Info = {type:\"(Size|Point) => GraphSize|GraphPoint\", txt:\"Translate page\\'s viewport coordinate set to this graph coordinate set.\"};\r\n    get_translateHtmlSize<T extends Size|Point, G = T extends Size ? GraphSize : GraphPoint>(c: Context): ((size: T) => G) {\r\n        return (size: T): G => {\r\n            let graphHtmlSize = this.get_htmlSize(c);\r\n            let a = size.subtract(graphHtmlSize.tl(), true);\r\n            let b = a.add({x:c.data.offset.x, y:c.data.offset.y}, false);\r\n            return b.multiply(c.data.zoom, false) as any as G;\r\n        }\r\n    }\r\n\r\n    get_translateSize<T extends GraphSize|GraphPoint>(c: Context): ((size: T, innerGraph: LGraph) => T) {\r\n        return (size: T, innerGraph: LGraph): T => {\r\n            innerGraph = LPointerTargetable.wrap(innerGraph) as LGraph;\r\n            let ret: T = (size.hasOwnProperty(\"w\") ? new GraphSize(size.x, size.y, (size as GraphSize).w, (size as GraphSize).h) : new GraphPoint(size.x, size.y)) as T;\r\n            Log.ex(!innerGraph, \"translateSize() graph parameter is invalid: \"+innerGraph, innerGraph, c);\r\n            let ancestors: LGraph[] = [innerGraph, ...innerGraph.graphAncestors]\r\n            Log.ex(ancestors.indexOf(c.proxyObject) !== -1, \"translateSize() graph parameter is invalid: it must be a graph containing the current one.\", innerGraph, c);\r\n            for (let g of ancestors) ret.add(g.size.tl(), false);\r\n            // console.log(\"translateSize\", {c, thiss:c.proxyObject, ancestors, ancestorSizes: ancestors.map(a=> a.size.tl()), size, ret});\r\n            return ret; }\r\n    }\r\n    contains(elem: LGraphElement): boolean{ return this.wrongAccessMessage(\"contains()\"); }\r\n    get_contains(c: Context): ((elem: LGraphElement)=> boolean) {\r\n        return (elem: LGraphElement): boolean => {\r\n            let current = elem;\r\n            let next = elem.father;\r\n            let targetid = c.proxyObject.id;\r\n            if (current.id !== targetid) return true;\r\n            while(next && current.id !== next.id) {\r\n                current = next;\r\n                next = next.father;\r\n                if (current.id !== targetid) return true;\r\n            }\r\n            return false;\r\n        }}\r\n}\r\nRuntimeAccessibleClass.set_extend(DGraphElement, DGraph);\r\nRuntimeAccessibleClass.set_extend(LGraphElement, LGraph);\r\n// export const defaultVSize: GraphSize = new GraphSize(0, 0, 300, 160); // useless, now it's in view.DefaultVSize\r\n// export const defaultEPSize: GraphSize = new GraphSize(0, 0, 15, 15); // useless, now it's in view.DefaultVSize\r\n\r\n\r\n@RuntimeAccessible('DVoidVertex')\r\nexport class DVoidVertex extends DGraphElement {\r\n    // static _super = DGraphElement;\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // static singleton: LVoidVertex;\r\n    // static logic: typeof LVoidVertex;\r\n    // static structure: typeof DVoidVertex;\r\n\r\n    // inherit redefine\r\n    id!: Pointer<DVoidVertex, 1, 1, LVoidVertex>;\r\n    graph!: Pointer<DGraph, 1, 1, LGraph>;\r\n    model!: Pointer<DModelElement, 0, 1, LModelElement>;\r\n    isSelected!: Dictionary<DocString<Pointer<DUser>>, boolean>;\r\n    // containedIn!: Pointer<DGraphElement, 0, 1, LGraphElement>;\r\n    subElements!: Pointer<DGraphElement, 0, 'N', LGraphElement>;\r\n    state: DMap = {} as any;\r\n    zoom!: GraphPoint;\r\n    // personal attributes\r\n    x!: number;\r\n    y!: number;\r\n    w!: number;\r\n    h!: number;\r\n    isResized!: boolean;\r\n    // size?: GraphSize; // virtual, gets extracted from this. x and y are stored directly here as it extends GraphSize\r\n\r\n    public static new(htmlindex: number, model: DGraphElement[\"model\"], parentNodeID: DGraphElement[\"father\"], graphID: DGraphElement[\"graph\"], nodeID?: DGraphElement[\"id\"],\r\n                      size?: InitialVertexSize): DVoidVertex {\r\n        return new Constructors(new DVoidVertex('dwc'), parentNodeID, true, undefined, nodeID)\r\n            .DPointerTargetable()\r\n            .DGraphElement(model, graphID, htmlindex)\r\n            .DVoidVertex(size || defaultVertexSize).end();\r\n    }\r\n\r\n}\r\n\r\n@RuntimeAccessible('LVoidVertex')\r\nexport class LVoidVertex<Context extends LogicContext<DVoidVertex> = any, C extends Context = Context> extends LGraphElement {// <D extends DVoidVertex = any>\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // static singleton: LVoidVertex;\r\n    // static logic: typeof LVoidVertex;\r\n    // static structure: typeof DVoidVertex;\r\n\r\n    // inherit redefine\r\n    __raw!: DVoidVertex;\r\n    id!: Pointer<DVoidVertex, 1, 1, LVoidVertex>;\r\n    graph!: LGraph;\r\n    model?: LModelElement;\r\n    // isSelected: Dictionary<DocString<Pointer<DUser>>, boolean> = {};\r\n    isSelected(forUser?: Pointer<DUser>): boolean { return this.wrongAccessMessage(\"node.isSelected()\"); }\r\n    // containedIn?: LGraphElement;\r\n    subElements!: LGraphElement[];\r\n    state!: LMap;\r\n    zoom!: GraphPoint;\r\n    isResized!: boolean;\r\n\r\n    // personal attributes\r\n    x!: number;\r\n    y!: number;\r\n    w!: number;\r\n    h!: number;\r\n    size!: GraphSize; // virtual, gets extracted from this. x and y are stored directly here as it extends GraphSize\r\n    __info_of__size = {type: \"?GraphSize\", txt: \"Size of the vertex, if null it means is utilizing the defaultSize from view. recommended to read component.getSize() instead of this.\"};\r\n\r\n    get_isResized(context: LogicContext<DVoidVertex>): DVoidVertex[\"isResized\"] { return context.data.isResized; }\r\n    set_isResized(val: DVoidVertex[\"isResized\"], context: LogicContext<DVoidVertex>): DVoidVertex[\"isResized\"] {\r\n        return SetFieldAction.new(context.data.id, \"isResized\", val);\r\n    }\r\n\r\n\r\n\r\n}\r\n\r\nRuntimeAccessibleClass.set_extend(DGraphElement, DVoidVertex);\r\nRuntimeAccessibleClass.set_extend(LGraphElement, LVoidVertex);\r\n@RuntimeAccessible('DEdgePoint')\r\nexport class DEdgePoint extends DVoidVertex { // DVoidVertex\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // static singleton: LEdgePoint;\r\n    // static logic: typeof LEdgePoint;\r\n    // static structure: typeof DEdgePoint;\r\n\r\n    // inherit redefine\r\n    id!: Pointer<DEdgePoint, 1, 1, LEdgePoint>;\r\n    father!: Pointer<DVoidEdge, 1, 1, LVoidEdge>;\r\n    graph!: Pointer<DGraph, 1, 1, LGraph>;\r\n    model!: Pointer<DModelElement, 0, 1, LModelElement>; // todo: if null gets model from this.father (edge)?\r\n    isSelected!: Dictionary<DocString<Pointer<DUser>>, boolean>;\r\n    // containedIn!: Pointer<DGraphElement, 0, 1, LGraphElement>;\r\n    subElements!: Pointer<DGraphElement, 0, 'N', LGraphElement>;\r\n    zoom!: GraphPoint;\r\n    x!: number;\r\n    y!: number;\r\n    w!: number;\r\n    h!: number;\r\n    size?: GraphSize; //／／ virtual, gets extracted from this. x and y are stored directly here as it extends GraphSize\r\n    // personal attributes\r\n    __isDEdgePoint!: true;\r\n\r\n    public static new(htmlindex: number, model: DEdgePoint[\"model\"] | undefined, parentNodeID: DEdgePoint[\"father\"], graphID?: DEdgePoint[\"graph\"], nodeID?: DGraphElement[\"id\"],\r\n                      size?: InitialVertexSize): DEdgePoint {\r\n        return new Constructors(new DEdgePoint('dwc'), parentNodeID, true, undefined, nodeID)\r\n            .DGraphElement(undefined, graphID, htmlindex)\r\n            .DVoidVertex(size || defaultEdgePointSize).DEdgePoint().end();\r\n    }\r\n\r\n}\r\n\r\n@RuntimeAccessible('LEdgePoint')\r\nexport class LEdgePoint<Context extends LogicContext<DEdgePoint> = any, C extends Context = Context> extends LVoidVertex {\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // static singleton: LEdgePoint;\r\n    // static logic: typeof LEdgePoint;\r\n    // static structure: typeof DEdgePoint;\r\n\r\n    // inherit redefine\r\n    father!: LVoidEdge;\r\n    // __raw!: DEdgePoint;\r\n    id!: Pointer<DEdgePoint, 1, 1, LEdgePoint>;\r\n    graph!: LGraph;\r\n    model?: LModelElement;\r\n    // isSelected: Dictionary<DocString<Pointer<DUser>>, boolean> = {};\r\n    isSelected(forUser?: Pointer<DUser>): boolean { return this.wrongAccessMessage(\"node.isSelected()\"); }\r\n    // containedIn?: LGraphElement;\r\n    subElements!: LGraphElement[];\r\n    zoom!: GraphPoint;\r\n    x!: number;\r\n    y!: number;\r\n    w!: number;\r\n    h!: number;\r\n    size!: GraphSize; // virtual, gets extracted from this. x and y are stored directly here as it extends GraphSize\r\n    // personal attributes\r\n    __isLEdgePoint!: true;\r\n    edge!: LVoidEdge; // returns container edge\r\n    __info_of__edge: Info = {type:\"?LEdge\", txt:\"returns the containing edge if called on an EdgePoint, \\\"this\\\" if called on an edge, undefined otherwise.\"}\r\n\r\n    public get_edge(c: Context): LVoidEdge { return c.proxyObject.father; }\r\n    public set_edge(v: Pack1<LVoidEdge>, c: Context): boolean { return this.set_father(v as any, c); }\r\n\r\n    // from x,y as coords, to x%,y% as % of ((1-val)%*startpt) + ((val)%*endpt)\r\n    public decodePosCoords<T extends Partial<GraphSize> | Partial<GraphPoint>>(c: Context, size: T&any, view: LViewElement, sp0?: GraphPoint, ep0?: GraphPoint): T {\r\n        if (!view) view = this.get_view(c);\r\n        let edgePointCoordMode = view.edgePointCoordMode;\r\n        if (edgePointCoordMode === CoordinateMode.absolute) return size;\r\n        let le: LVoidEdge = c&&c.proxyObject.father;\r\n        // console.log(\"decodepos:\", {le, sp0, lesp:le?.startPoint});\r\n        let sp: GraphPoint = sp0||le.startPoint;\r\n        let ep: GraphPoint = ep0||le.endPoint;\r\n        let ret: any = ((\"w\" in size || \"h\" in size) ? new GraphSize() : new GraphPoint()); // GObject<Partial<GraphSize>>;\r\n        switch (edgePointCoordMode) {\r\n            default: return Log.exDevv(\"translatePosCoords() invalid coordinate mode\", {mode:edgePointCoordMode, view});\r\n            // case CoordinateMode.absolute: return size;\r\n            case CoordinateMode.relativePercent:\r\n                //maybe do: dampening factor on relative % offset? is it possible?\r\n\r\n                // let s = this.getBasicSize(c);\r\n                // MATH:\r\n                // size.x = sp.x*x% + ep.x*(1-x%)\r\n                // size.x = sp.x*x% + ep.x - ep.x*x%\r\n                // size.x - ep.x= (sp.x - ep.x)*x%\r\n                // (size.x - ep.x) / (sp.x - ep.x) = x% // actually i inverted <sp, ep> in first equation, so reverse them in result too.\r\n                if (size.x !== undefined) ret.x = (1 - size.x) * sp.x + (size.x) * ep.x;\r\n                if (size.y !== undefined) ret.y = (1 - size.y) * sp.y + (size.y) * ep.y;\r\n                break;\r\n            case CoordinateMode.relativeOffset:\r\n            case CoordinateMode.relativeOffsetStart:\r\n            case CoordinateMode.relativeOffsetEnd:\r\n                let useStart: boolean;\r\n                let useEnd: boolean;\r\n                switch (edgePointCoordMode) {\r\n                    default:\r\n                    case CoordinateMode.relativeOffset: useStart = true; useEnd = true; break;\r\n                    case CoordinateMode.relativeOffsetStart: useStart = true; useEnd = false; break;\r\n                    case CoordinateMode.relativeOffsetEnd: useStart = false; useEnd = true; break;\r\n                }\r\n                // offset = sp - size\r\n                // size = offset - sp\r\n                // in reverse: actualsize = offset, size=offset\r\n                Log.exDev(size.x&&!Array.isArray(size.x) || size.y&&!Array.isArray(size.y),\r\n                    \"decoding relative offset require an array size coordinate system. x=[x1, x2] --> x\", {size});\r\n                let offsetsp = useStart ? new GraphPoint(size.x[0] + sp.x, size.y[0] + sp.y) : new GraphPoint();\r\n                let offsetep = useEnd ? new GraphPoint(size.x[1] + ep.x, size.y[1] + ep.y) : new GraphPoint();\r\n                // if the start and endpoint of the edge didn't move, offsetsp = offsetep.\r\n                // if they moved, those 2 are discordant --> i pick middle\r\n                offsetsp.add(offsetep, false);\r\n                if (useStart && useEnd) offsetsp.divide(2, false);\r\n                if (size.x !== undefined) ret.x = offsetsp.x;\r\n                if (size.y !== undefined) ret.y = offsetsp.y;\r\n                break;\r\n        }\r\n        if (size.x === undefined) delete ret.x;\r\n        if (size.y === undefined) delete ret.y;\r\n        if ((size as any).w === undefined) delete ret.w; else ret.w = size.w;\r\n        if ((size as any).h === undefined) delete ret.h; else ret.h = size.h;\r\n        // console.log(\"decode coords\", {size, sp, ep, ret});\r\n\r\n        return ret;\r\n    }\r\n\r\n    public encodePosCoords<T extends Partial<GraphSize> | Partial<GraphPoint>>(c: Context, size: T, view: LViewElement, sp0?: GraphPoint, ep0?: GraphPoint): T {\r\n        if (!view) view = this.get_view(c);\r\n        let edgePointCoordMode = view.edgePointCoordMode;\r\n        if (edgePointCoordMode === CoordinateMode.absolute) return size;\r\n        let le: LVoidEdge = c&&c.proxyObject.father;\r\n        let sp: GraphPoint = sp0 || le.startPoint;//todo: delete sp0, ep0 parameters after testing\r\n        let ep: GraphPoint = ep0 || le.endPoint;\r\n        let ret: any = ((\"w\" in size || \"h\" in size) ? new GraphSize() : new GraphPoint()); // GObject<Partial<GraphSize>>;\r\n        switch (edgePointCoordMode) {\r\n            default: return Log.exDevv(\"translatePosCoords() invalid coordinate mode\", {mode:edgePointCoordMode, view});\r\n            // case CoordinateMode.absolute: return size;\r\n            case CoordinateMode.relativePercent:\r\n                // let s = this.getBasicSize(c);\r\n                // MATH:\r\n                // size.x = sp.x*x% + ep.x*(1-x%)\r\n                // size.x = sp.x*x% + ep.x - ep.x*x%\r\n                // size.x - ep.x= (sp.x - ep.x)*x%\r\n                // (size.x - ep.x) / (sp.x - ep.x) = x% // actually i inverted <sp, ep> in first equation, so reverse them in result too.\r\n                if (size.x !== undefined) ret.x = (size.x - sp.x) / (ep.x - sp.x);\r\n                if (size.y !== undefined) ret.y = (size.y - sp.y) / (ep.y - sp.y);\r\n                break;\r\n            case CoordinateMode.relativeOffset:\r\n            case CoordinateMode.relativeOffsetStart:\r\n            case CoordinateMode.relativeOffsetEnd:\r\n                let useStart: boolean;\r\n                let useEnd: boolean;\r\n                switch (edgePointCoordMode) {\r\n                    default:\r\n                    case CoordinateMode.relativeOffset: useStart = true; useEnd = true; break;\r\n                    case CoordinateMode.relativeOffsetStart: useStart = true; useEnd = false; break;\r\n                    case CoordinateMode.relativeOffsetEnd: useStart = false; useEnd = true; break;\r\n                }\r\n                if (size.x) ret.x = [useStart ? size.x - sp.x : -1, useEnd ? size.x - ep.x : -1];\r\n                if (size.y) ret.y = [useStart ? size.y - sp.y : -1, useEnd ? size.y - ep.y : -1];\r\n                /*\r\n                if (size.x) ret.x = [sp.x - size.x, ep.x - size.x];\r\n                if (size.y) ret.y = [sp.y - size.y, ep.y - size.y];*/\r\n                break;\r\n        }\r\n        if (size.x === undefined) delete ret.x;\r\n        if (size.y === undefined) delete ret.y;\r\n        if ((size as any).w === undefined) delete ret.w; else ret.w = (size as any).w;\r\n        if ((size as any).h === undefined) delete ret.h; else ret.h = (size as any).h;\r\n        // console.log(\"encode coorde\", {size, sp, ep, ret});\r\n        return ret;\r\n    }\r\n\r\n    /* 13/10/2023 Giordano comment (defined in LPointerTargetable\r\n    public get_delete(context: Context): () => void {\r\n        // careful: pointedBy might be broken due to comment x984 (search it)\r\n        return super.get_delete(context);\r\n    }\r\n    */\r\n}\r\nRuntimeAccessibleClass.set_extend(DVoidVertex, DEdgePoint);\r\nRuntimeAccessibleClass.set_extend(LVoidVertex, LEdgePoint);\r\n\r\n@RuntimeAccessible('DVertex')\r\nexport class DVertex extends DGraphElement { // DVoidVertex\r\n    // static _super = DVoidVertex;\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // static singleton: LVertex;\r\n    // static logic: typeof LVertex;\r\n    // static structure: typeof DVertex;\r\n\r\n    // inherit redefine\r\n    id!: Pointer<DVertex, 1, 1, LVertex>;\r\n    graph!: Pointer<DGraph, 1, 1, LGraph>;\r\n    model!: Pointer<DModelElement, 0, 1, LModelElement>;\r\n    isSelected!: Dictionary<DocString<Pointer<DUser>>, boolean>;\r\n    // containedIn!: Pointer<DGraphElement, 0, 1, LGraphElement>;\r\n    subElements!: Pointer<DGraphElement, 0, 'N', LGraphElement>;\r\n    zoom!: GraphPoint;\r\n    x!: number;\r\n    y!: number;\r\n    w!: number;\r\n    h!: number;\r\n    isResized!: boolean;\r\n    // size!: GraphSize; // virtual, gets extracted from this. x and y are stored directly here as it extends GraphSize\r\n    // personal attributes\r\n    __isDVertex!: true;\r\n\r\n    public static new(htmlindex: number, model: DGraphElement[\"model\"], parentNodeID: DGraphElement[\"father\"],\r\n                      graphID: DGraphElement[\"graph\"], nodeID?: DGraphElement[\"id\"], size?: GraphSize): DVertex {\r\n        return new Constructors(new DVertex('dwc'), parentNodeID, true, undefined, nodeID)\r\n            .DPointerTargetable()\r\n            .DGraphElement(model, graphID, htmlindex)\r\n            .DVoidVertex(size || defaultVertexSize).DVertex().end();\r\n    }\r\n}\r\n\r\n@RuntimeAccessible('LVertex')\r\nexport class LVertex<Context extends LogicContext<any> = any, D = DVertex> extends LVoidVertex {\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // static singleton: LVertex;\r\n    // static logic: typeof LVertex;\r\n    // static structure: typeof DVertex;\r\n\r\n    // inherit redefine\r\n    __raw!: DVertex;\r\n    id!: Pointer<DVertex, 1, 1, LVertex>;\r\n    graph!: LGraph;\r\n    model?: LModelElement;\r\n    // isSelected: Dictionary<DocString<Pointer<DUser>>, boolean> = {};\r\n    isSelected(forUser?: Pointer<DUser>): boolean { return this.wrongAccessMessage(\"node.isSelected()\"); }\r\n    // containedIn?: LGraphElement;\r\n    subElements!: LGraphElement[];\r\n    zoom!: GraphPoint;\r\n    x!: number;\r\n    y!: number;\r\n    w!: number;\r\n    h!: number;\r\n    size!: GraphSize; // virtual, gets extracted from this. x and y are stored directly here as it extends GraphSize\r\n    isResized!: boolean;\r\n    // personal attributes\r\n    __isLVertex!: true;\r\n}\r\n\r\nRuntimeAccessibleClass.set_extend(DGraphElement, DVertex);\r\nRuntimeAccessibleClass.set_extend(LGraphElement, LVertex);\r\n\r\n@Leaf\r\n@RuntimeAccessible('DGraphVertex')\r\nexport class DGraphVertex extends DGraphElement { // MixOnlyFuncs(DGraph, DVertex)\r\n    // static _super1 = DGraph;\r\n    // static _super2 = DVertex;\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // static singleton: LGraphVertex;\r\n    // static logic: typeof LGraphVertex;\r\n    // static structure: typeof DGraphVertex;\r\n\r\n    // inherit redefine\r\n    id!: Pointer<DGraphVertex, 1, 1>;\r\n    graph!: Pointer<DGraph, 1, 1, LGraph>;\r\n    model!: Pointer<DModelElement, 1, 1, LModelElement>;\r\n    isSelected!: Dictionary<DocString<Pointer<DUser>>, boolean>;\r\n    // containedIn!: Pointer<DGraphElement, 0, 1, LGraphElement>;\r\n    subElements!: Pointer<DGraphElement, 0, 'N', LGraphElement>;\r\n    // from graph\r\n    zoom!: GraphPoint;\r\n    offset!: GraphPoint; // in-graph scrolling position\r\n\r\n    // from VoidVertex\r\n    x!: number;\r\n    y!: number;\r\n    w!: number;\r\n    h!: number;\r\n    isResized!: boolean;\r\n    // size!: GraphSize; // virtual\r\n    // from graph\r\n\r\n    // personal attributes\r\n    __isDVertex!: true;\r\n    __isDGraph!: true;\r\n    __isDGraphVertex!: true;\r\n\r\n    public static new(htmlindex: number, model: DGraph[\"model\"], parentNodeID: DGraphElement[\"father\"],\r\n                      graphID: DGraphElement[\"graph\"], nodeID?: DGraphElement[\"id\"], size?: GraphSize): DGraphVertex {\r\n        return new Constructors(new DGraphVertex('dwc'), parentNodeID, true, undefined, nodeID)\r\n            .DPointerTargetable().DGraphElement(model, graphID, htmlindex)\r\n            .DVoidVertex(size || defaultVertexSize).DVertex().DGraph().end();\r\n    }\r\n\r\n\r\n    /*\r\n        static init_constructor(thiss: DGraphVertex, isUser: boolean = false, nodeID: string | undefined, graphID: string | undefined, model: Pointer<DModel>): void {\r\n            DGraph.init_constructor(thiss, isUser, nodeID, graphID, model);\r\n    //isUser: boolean = false, nodeID: string | undefined, graphID: string, model?: Pointer<DModel>\r\n            DVertex.init_constructor(thiss, isUser, nodeID, graphID as string, model);\r\n            thiss.className = this.name;\r\n        }*/\r\n}\r\nclass LG extends LGraph{}\r\nclass LV extends LVertex{}\r\n@RuntimeAccessible('LGraphVertex')\r\nexport class LGraphVertex<Context extends LogicContext<any> = any, D extends DGraphVertex = any> extends MixOnlyFuncs(LG, LV) { // MixOnlyFuncs(LGraph, LVertex)\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // static singleton: LGraphVertex;\r\n    // static logic: typeof LGraphVertex;\r\n    // static structure: typeof DGraphVertex;\r\n\r\n    // inherit redefine\r\n    __raw!: DGraphVertex;\r\n    id!: Pointer<DGraphVertex, 1, 1>;\r\n    graph!: LGraph;\r\n    model?: LModelElement;\r\n    // isSelected: Dictionary<DocString<Pointer<DUser>>, boolean> = {};\r\n    isSelected(forUser?: Pointer<DUser>): boolean { return this.wrongAccessMessage(\"node.isSelected()\"); }\r\n    // containedIn?: LGraphElement;\r\n    ///////////////////////////////////////// subElements!: LGraphElement[];\r\n    // from graph\r\n    zoom!: GraphPoint;\r\n    offset!: GraphPoint; // in-graph scrolling position\r\n    graphSize!: GraphSize; // internal size of the graph. can be huge even if the sub-graph is in a small window (scroll)\r\n\r\n    // from VoidVertex\r\n    x!: number;\r\n    y!: number;\r\n    w!: number;\r\n    h!: number;\r\n    isResized!: boolean;\r\n    size!: GraphSize; // virtual\r\n\r\n\r\n    // personal attributes\r\n    __isLVertex!: true;\r\n    __isLGraph!: true;\r\n    __isLGraphVertex!: true;\r\n}\r\n\r\nRuntimeAccessibleClass.set_extend(DGraph, DGraphVertex);\r\nRuntimeAccessibleClass.set_extend(DVertex, DGraphVertex);\r\nRuntimeAccessibleClass.set_extend(LGraph, LGraphVertex);\r\nRuntimeAccessibleClass.set_extend(LVertex, LGraphVertex);\r\n\r\n\r\n@RuntimeAccessible('DVoidEdge')\r\nexport class DVoidEdge extends DGraphElement {\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // static singleton: LVoidEdge;\r\n    // static logic: typeof LVoidEdge;\r\n    // static structure: typeof DVoidEdge;\r\n    id!: Pointer<DVoidEdge, 1, 1, LVoidEdge>;\r\n    graph!: Pointer<DGraph, 1, 1, LGraph>;\r\n    model!: Pointer<DModelElement, 0, 1, LModelElement>;\r\n    // isSelected: Dictionary<DocString<Pointer<DUser>>, boolean> = {};\r\n    isSelected!: Dictionary<DocString<Pointer<DUser>>, boolean>;\r\n    // containedIn!: Pointer<DGraphElement, 0, 1, LGraphElement>;\r\n    subElements!: Pointer<DGraphElement, 0, 'N', LGraphElement>;\r\n\r\n    // personal attributes\r\n    start!: Pointer<DGraphElement, 1, 1, LGraphElement>;\r\n    end!: Pointer<DGraphElement, 1, 1, LGraphElement>;\r\n    __isDVoidEdge!: true;\r\n\r\n    midPoints!: InitialVertexSize[]; // the logic part which instructs to generate the midnodes\r\n    midnodes!: Pointer<DEdgePoint, 1, 1, LEdgePoint>[]; // using subelements instead most of times\r\n\r\n    longestLabel!: PrimitiveType | labelfunc;\r\n    labels!: PrimitiveType[] | labelfunc[];\r\n\r\n    public static new(htmlindex: number, model: DGraph[\"model\"]|null|undefined, parentNodeID: DGraphElement[\"father\"], graphID: DGraphElement[\"graph\"],\r\n                      nodeID: DGraphElement[\"id\"]|undefined, start: DGraphElement[\"id\"], end: DGraphElement[\"id\"],\r\n                      longestLabel: DEdge[\"longestLabel\"], labels: DEdge[\"labels\"]): DEdge {\r\n        return new Constructors(new DEdge('dwc'), parentNodeID, true, undefined, nodeID)\r\n            .DPointerTargetable()\r\n            .DGraphElement(model, graphID, htmlindex)\r\n            .DVoidEdge(start, end, longestLabel, labels).end();\r\n    }\r\n}\r\n/*\r\n@RuntimeAccessible\r\nexport class MidPoint{\r\n    readonly id: string; // not really a pointer, it's not on store.\r\n    x?: number; y?: number;\r\n    readonly w?: number; // if it's modified it's not ever here (initial size) but on DEdgePoint that is a Node.\r\n    readonly h?: number;/*\r\n    constructor2(x: number=5, y: number=5, w: number=5, h: number=5) {\r\n        this.x = x;\r\n        this.y = y;\r\n        this.w = w;\r\n        this.h = h;\r\n    }* /\r\nconstructor(id: string, w: number=5, h: number=5) {\r\n    this.id = id;\r\n    this.w = w;\r\n    this.h = h;\r\n}\r\n}*/\r\n@RuntimeAccessible('EdgeSegment')\r\nexport class EdgeSegment{\r\n    index: number;\r\n    prev: EdgeSegment | undefined;\r\n    start: segmentmaker;\r\n    bezier: segmentmaker[];\r\n    end: segmentmaker;\r\n    length!: number;\r\n    d!: string;\r\n    dpart!: string; //  a segment of the whole path\r\n    m!: number; // m coefficient of the line between start and end.\r\n    rad!: number; // for head and tails: radian angle of the segment.\r\n    radLabels!: number; // for labels: it flips the angle when it's < PI/2 so the text is never upside down\r\n\r\n    isLongest!: boolean;\r\n    label!: PrimitiveType | JSX.Element | undefined;\r\n    svgLetter: EdgeBendingMode;\r\n    /*constructor(label: PrimitiveType|undefined, length: number, startp: GraphPoint, endp: GraphPoint, start: LGraphElement, end: LGraphElement,\r\n                bezierpts: GraphPoint[], mid: LGraphElement[],\r\n                svgLetter: EdgeBendingMode, index: number, fillMode: MidNodeHandling) {\r\n        this.label = label;\r\n        this.length = length;\r\n        this.length = length;\r\n        this.startp = startp;\r\n        this.bezierp = bezierpts;\r\n        this.endp = endp;\r\n        this.start = start;\r\n        this.end = end;\r\n        this.mid = mid;\r\n    }*/\r\n    constructor(start: segmentmaker, mid: segmentmaker[], end: segmentmaker,\r\n                svgLetter: EdgeBendingMode, gapMode: EdgeGapMode,\r\n                index: number, prevSegment: EdgeSegment | undefined){\r\n        // console.log(\"segmentmaker:\", arguments, ((start.ge?.model as any)?.name)+\" ---> \" + ((end.ge?.model as any)?.name));\r\n        this.start = start;\r\n        this.bezier = mid;\r\n        this.end = end;\r\n        this.index = index;\r\n        this.prev = prevSegment;\r\n        //this.segments = segments;\r\n        // the idea: forbid all T and S or transform them in C, Q by calculating and manually adding their mirrored bezier pts\r\n        if (svgLetter[1]) svgLetter = (svgLetter[0]) as any;\r\n        if (svgLetter === EdgeBendingMode.Bezier_quadratic_mirrored) {\r\n            this.addBezierPoint();\r\n            this.svgLetter = EdgeBendingMode.Bezier_quadratic;\r\n        } else\r\n        if (svgLetter === EdgeBendingMode.Bezier_cubic_mirrored) {\r\n            this.addBezierPoint();\r\n            this.svgLetter = EdgeBendingMode.Bezier_cubic;\r\n        }\r\n        else this.svgLetter = svgLetter;\r\n\r\n        // fix if amount of bezier pts is invalid for current letter\r\n        switch (this.svgLetter) {\r\n            case EdgeBendingMode.Line:\r\n            case EdgeBendingMode.Bezier_quadratic:\r\n                if (this.bezier.length >= 1) break;\r\n                else this.svgLetter = EdgeBendingMode.Line;\r\n                break;\r\n            case EdgeBendingMode.Bezier_cubic:\r\n                if (this.bezier.length >= 2) break;\r\n                else if (this.bezier.length >= 1) this.svgLetter = EdgeBendingMode.Bezier_quadratic;\r\n                else this.svgLetter = EdgeBendingMode.Line;\r\n                break;\r\n            case EdgeBendingMode.Elliptical_arc:\r\n                if (this.bezier.length >= 3) break;\r\n                else this.svgLetter = EdgeBendingMode.Line; // straight to end ignoring midpoints that are NOT coordinates when using elliptical arc.\r\n                break;\r\n            default:\r\n            case EdgeBendingMode.Bezier_quadratic_mirrored as string:\r\n            case EdgeBendingMode.Bezier_cubic_mirrored as string: // translated to Q or C by adding mirrored bezier points explicitly\r\n            case EdgeBendingMode.Bezier_QT:\r\n            case EdgeBendingMode.Bezier_CS: // translated to Q or C by sending the right letter to each segment\r\n                Log.exDevv(\"this svg letter should not appear here\", this.svgLetter);\r\n                break;\r\n        }\r\n    }\r\n    addBezierPoint(): void {\r\n        let prev: EdgeSegment | undefined = this.prev;\r\n        if (!prev) return;\r\n        let prevedgemakerbezier: segmentmaker = (prev.bezier[prev.bezier.length-1] || prev.start);\r\n        let mirroredBezier: segmentmaker = {...prevedgemakerbezier,\r\n            pt: EdgeSegment.invertLastBezierPt(prevedgemakerbezier.pt, prev.end.pt),\r\n            uncutPt: EdgeSegment.invertLastBezierPt(prevedgemakerbezier.uncutPt, prev.end.uncutPt),\r\n        };\r\n        this.bezier = [mirroredBezier, ...this.bezier];\r\n        // always only 1 assumed pt both in cubic and quadratic.\r\n        // let next: this | undefined = this.segments[this.index+1];\r\n        // EdgeSegment.invertLastBezierPt((next.mid[1] || next.end).pt, next.start.pt);\r\n    }\r\n\r\n    makeD(index: number, gapMode: EdgeGapMode): string {\r\n        this.m = GraphPoint.getM(this.start.pt, this.end.pt);\r\n        this.rad = Geom.mToRad(this.m, this.start.pt, this.end.pt);\r\n        this.radLabels = Math.atan(this.m);\r\n\r\n        let svgLetter = this.svgLetter; // caller makes sure to pass right letter and resolve \"CS\" mixed letters. // this.bendingModeToLetter(bendingMode, index);\r\n        // caller sends inverted pts as normal coords\r\n        // let invertedBezPt = lastSegment && EdgeSegment.invertLastBezierPt(lastSegment.midp[lastSegment.mid.length-1] || lastSegment.startp, lastSegment.endp);\r\n        switch (this.svgLetter.length) {\r\n            case 2:\r\n                return Log.exDevv(\"mixed letters are not allowed and should have been resolved to single svg letters before here, found:\" + svgLetter);\r\n            /*return Log.exDevv(\"dev problem to fix:\\n\" +\r\n            \"the mirrored mode requires the first one to have explicit non-mirrored mode?? like M, C a1 a2 a3, S a1, S a1, S a1\\n\" +\r\n            \"So all segments with mixed modes needs to extract the last bezier point (penultimate coordinate) from previous segments, mirror it and insert in midp[0]\");*/\r\n            case 1:\r\n                let bezierpts = [...this.bezier.map( b => b.pt), this.end.pt];\r\n                let finalpart = svgLetter + \" \" + bezierpts.map((p)=> p.x + \" \" + p.y).join(\", \");\r\n                this.dpart = \"M \" + this.start.pt.x + \" \" + this.start.pt.y + \", \" + finalpart;\r\n                let bezierptsUncut = [...this.bezier.map( b => b.uncutPt), this.end.pt]; // uncutPt exist for start and end too, but i want to use the cut one for those. or edgehead is off\r\n                let finalpartUncut = svgLetter + \" \" + bezierptsUncut.map((p)=> p.x + \" \" + p.y).join(\", \");\r\n                this.d = (index === 0 ? \"M\" + this.start.pt.x + \" \" + this.start.pt.y + \", \" : \"\") + finalpartUncut;\r\n\r\n                //midp = [this.startp, ...this.midp];\r\n                // d = M sp X mp2 ep // X = custom letter\r\n                // dpart = T sp X mp2 ep // S = S if X = C,\r\n                // sp is the startingpoint from the prev node, which might be != from endpoint of last node if last node have w>0 && h>0\r\n                // so i'm \"filling\" the gap with a T, or L arc wich can use only 1 parameter (they are the only 1-parameter arcs)\r\n                if (this.prev && this.prev.end.pt.equals(this.start.pt)) gapMode = EdgeGapMode.average; // if the 2 points coincide, i use any 1 of the gapmodes that are continuous\r\n                /*switch (gapMode){\r\n                    case EdgeGapMode.center:\r\n                    case EdgeGapMode.average:\r\n                        // continuous gap modes. they only differ in how the \"joining\" point is found, but not in how they behave after that.\r\n                        /*\r\n                        if (index === 0) {\r\n                             startletter = \"M \";\r\n                         }\r\n                         else {\r\n                             switch (svgLetter) {\r\n                                 case SvgLetter.A: case SvgLetter.C: case SvgLetter.S: case SvgLetter.Q: case SvgLetter.T: default:\r\n                                     startletter = SvgLetter.T + \" \"; break;\r\n                                 case SvgLetter.L: case SvgLetter.M:\r\n                                     startletter = SvgLetter.L + \" \"; break;\r\n                             }\r\n                         }* /\r\n                        if (index) {\r\n                            this.d = finalpart;\r\n                        }\r\n                        else { this.d = this.dpart; }\r\n                        break;\r\n                    case EdgeGapMode.gap:\r\n                    case EdgeGapMode.autoFill:\r\n                    case EdgeGapMode.lineFill:\r\n                    case EdgeGapMode.arcFill:\r\n                        // the filling itself is done by another segment (solving svg letter and simulating i=0), so i treat it as a gap.\r\n                        this.d = this.dpart;\r\n                        break;\r\n                    default:\r\n                        Log.exDevv(\"unexpected EdgeGapMode:\" + gapMode, {gapMode});\r\n                }*/\r\n                break;\r\n            default: return Log.exDevv(\"unexpected bending mode length:\" + this.svgLetter + \" or fillMode: \" + gapMode, {bendingMode: this.svgLetter, index, gapMode});\r\n        }\r\n\r\n        //using\r\n        /*\r\n        88\r\n\r\n        // d should not have M set (except for segments[0]\r\n        // dpart have M abd beed to add explicit points for \"mirroring\" and transforming bezier quadratic mirrored in bezier quadratic normal etc.\r\n        //88 problem: the mirrored mode requires the first one to have explicit nonmirrored mode?? like M, C a1 a2 a3, S a1, S a1, S a1 .... ?\r\n        in any case the % letter part is wrong because it needs to subtract first element used for M*/\r\n        return this.d;\r\n    }\r\n\r\n    static invertLastBezierPt(bezier: GraphPoint, end: GraphPoint): GraphPoint{\r\n        // vector = bezier - end\r\n        // end + vector = bezier\r\n        // end - vector = inverted bezier? = 2*end-bezier\r\n        let vector = bezier.subtract(end, true);\r\n        return end.subtract(vector, true);\r\n    }\r\n\r\n    calcLength(): void {\r\n        this.length = this.start.pt.distanceFromPoint(this.end.pt);\r\n    }\r\n}\r\n\r\nexport class EdgeFillSegment extends EdgeSegment{\r\n    public static cname: string = \"EdgeFillSegment\";\r\n    makeD(index: number, gapMode: EdgeGapMode): string {\r\n        if (gapMode === EdgeGapMode.autoFill) { gapMode = this.svgLetter === EdgeBendingMode.Line ? EdgeGapMode.lineFill : EdgeGapMode.arcFill; }\r\n        switch (gapMode) {\r\n            case EdgeGapMode.center:\r\n            case EdgeGapMode.average:\r\n            case EdgeGapMode.gap:\r\n                return \"\"; // should not have filler arcs\r\n            default:\r\n            case EdgeGapMode.autoFill as any:\r\n            case EdgeGapMode.lineFill:\r\n                this.bezier = [];\r\n                this.svgLetter = EdgeBendingMode.Line;\r\n                return super.makeD(index, gapMode);\r\n            case EdgeGapMode.arcFill:\r\n                this.svgLetter = this.svgLetter[0] as EdgeBendingMode;\r\n                if (this.svgLetter === \"Q\") this.bezier = this.bezier.length ? [this.bezier[0]] : [];\r\n                return super.makeD(index, gapMode);\r\n        }\r\n    }\r\n}\r\n\r\n\r\ntype segmentmaker = {size: GraphSize, view: LViewElement, ge: LGraphElement, pt: GraphPoint, uncutPt: GraphPoint};\r\n@RuntimeAccessible('LVoidEdge')\r\nexport class LVoidEdge<Context extends LogicContext<DVoidEdge> = any, D extends DEdge = DEdge> extends LGraphElement {\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // static singleton: LVoidEdge;\r\n    // static logic: typeof LVoidEdge;\r\n    // static structure: typeof DVoidEdge;\r\n    __raw!: DVoidEdge;\r\n    id!: Pointer<DVoidEdge, 1, 1, LVoidEdge>;\r\n    graph!: LGraph;\r\n    model?: LModelElement;\r\n    // isSelected: Dictionary<DocString<Pointer<DUser>>, boolean> = {};\r\n    isSelected(forUser?: Pointer<DUser>): boolean { return this.wrongAccessMessage(\"node.isSelected()\"); }\r\n    // containedIn?: LGraphElement;\r\n    subElements!: LGraphElement[];\r\n    start!: LGraphElement;\r\n    end!: LGraphElement;\r\n    __isLVoidEdge!: true;\r\n    midPoints!: InitialVertexSize[]; // the logic part which instructs to generate the midnodes\r\n    midnodes!: LEdgePoint[];\r\n    edge!: LVoidEdge; // returns self. useful to get edge from edgePoints without triggering error if you are already on edge.\r\n    __info_of__edge: Info = {type:\"?LEdge\", txt:\"returns this if called on an edge, the containing edge if called on an EdgePoint, undefined otherwise.\"}\r\n\r\n\r\n/*\r\nreplaced by startPoint\r\n    edgeStart!: GraphPoint;\r\n    edgeStart_inner!: GraphPoint;\r\n    edgeStart_outer!: GraphPoint;\r\n    __info_of__edgeStart: Info = {type: \"GraphPoint\", txt: \"Same as edgeStart_outer.\"}\r\n    __info_of__edgeStart_outer: Info = {type: \"GraphPoint\",\r\n     txt: \"Where the edge should start his path, in coordinates relative at the root Graph.\r\n     <br>Computed by combining the anchor offset option in View and the size of the starting node.\"}\r\n    __info_of__edgeStart_inner: Info = {type: \"GraphPoint\",\r\n     txt: \"Where the edge should start his path, in coordinates relative at the most nested Graph.\r\n     <br>Computed by combining the anchor offset option in View and the size of the starting node.\"}\r\n    edgeEnd!: GraphPoint;\r\n    edgeEnd_inner!: GraphPoint;\r\n    edgeEnd_outer!: GraphPoint;\r\n    __info_of__edgeEnd: Info = {type: \"GraphPoint\", txt: \"Same as edgeEnd_outer.\"}\r\n    __info_of__edgeEnd_outer: Info = {type: \"GraphPoint\",\r\n     txt: \"Where the edge should end his path, in coordinates relative at the root Graph.\r\n     <br>Computed by combining the anchor offset option in View and the size of the starting node.\"}\r\n    __info_of__edgeEnd_inner: Info = {type: \"GraphPoint\",\r\n     txt: \"Where the edge should end his path, in coordinates relative at the most nested Graph.\r\n     <br>Computed by combining the anchor offset option in View and the size of the starting node.\"}\r\n*/\r\n\r\n\r\n    label!: PrimitiveType;  // should never be read change their documentation in write only. their values is \"read\" in this.segments\r\n    longestLabel!: PrimitiveType;\r\n    labels!: PrimitiveType[];\r\n    allNodes!: [LGraphElement, ...Array<LEdgePoint>, LGraphElement];\r\n    __info_of__longestLabel: Info = {label:\"longest label\", type:\"text\", readType: \"PrimitiveType\",\r\n        writeType:\"PrimitiveType | (e:this, curr: LGraphElement, next: LGraphElement, curr_index: number, allNodes: LGraphElement[]) => PrimitiveType)\",\r\n        txt: <span>Label assigned to the longest path segment.</span>}\r\n    __info_of__label: Info = {type: \"\", txt: <span>Alias for longestLabel</span>};\r\n    __info_of__labels: Info = {label:\"multple labels\", type: \"text\",\r\n        writeType: \"type of label or Array<type of label>\",\r\n        txt: <span>Instructions to label to multiple or all path segments in an edge</span>};\r\n    __info_of__allNodes: Info = {type: \"[LGraphElement, ...Array<LEdgePoint>, LGraphElement]\", txt: <span>first element is this.start. then all this.midnodes. this.end as last element</span>};\r\n\r\n\r\n    get_label(c: Context): this[\"longestLabel\"] { return this.get_longestLabel(c); }\r\n    get_longestLabel(c: Context): this[\"longestLabel\"] { return c.data.longestLabel as any; }\r\n    set_longestLabel(val: this[\"longestLabel\"], c: Context): boolean { return SetFieldAction.new(c.data, \"longestLabel\", val); }\r\n    get_labels(c: Context): this[\"labels\"] { return c.data.labels as any; }\r\n    set_labels(val: this[\"labels\"], c: Context): boolean { return SetFieldAction.new(c.data, \"labels\", val); }\r\n    public headPos_impl(c: Context, isHead: boolean, headSize0?: GraphPoint, segment0?: EdgeSegment, zoom0?: GraphPoint): GraphSize & {rad: number} {\r\n        let segment: EdgeSegment = segment0 || this.get_segments(c).segments[0];\r\n        // let v: LViewElement = this.get_view(c);\r\n        let tmp: any = headSize0 || (isHead ? this.get_view(c).edgeHeadSize : this.get_view(c).edgeTailSize);\r\n        if (!tmp || tmp.x === 0 || tmp.y === 0) {\r\n            // head or tail missing\r\n            tmp = new GraphSize(0, 0, 0, 0);\r\n            tmp.rad = 0;\r\n            return tmp;\r\n        }\r\n        let zoom: GraphPoint = zoom0 || this.get_graph(c).zoom;\r\n        let headPos: GraphSize & {rad: number} = (new GraphSize(0, 0, tmp.x, tmp.y) as any); //.multiply({w:zoom.x, h:zoom.y});\r\n        let useBezierPoints = true;\r\n        let start: GraphPoint, end: GraphPoint;\r\n        let m: number;\r\n        if (useBezierPoints) {\r\n            if (isHead) {\r\n                start = segment.end.pt;\r\n                end = (segment.bezier[segment.bezier.length - 1] || segment.start).pt;\r\n            } else {\r\n                start = segment.start.pt;\r\n                end = (segment.bezier[0] || segment.end).pt;\r\n            }\r\n            m = GraphPoint.getM(start, end);\r\n        } else {\r\n            if (isHead) { start = segment.end.pt; end = segment.start.pt; }\r\n            else { start = segment.start.pt; end = segment.end.pt; }\r\n            m = segment.m;\r\n        }\r\n        // first find the center of where it should be positioned\r\n        // let center: GraphPoint;\r\n        // let distance: number = Math.sqrt(headPos.w*headPos.w + headPos.h*headPos.h);\r\n        // let isVertical = m >=1 ;\r\n        let x4headsize = new GraphSize(start.x - headPos.w, start.y - headPos.h, headPos.w*2, headPos.h*2);\r\n        // first intersection is segment origin. second is found with the box containing all possible edgeHead positions that touch the startPoint\r\n        // (doing x4 his shape and placing 4 \"rectangles\" all around startPoint) to cover all possible segment directions.\r\n        // or finding first direction (vertical if m >1, horizontal if m<0) and vector direction and intersecting with only the \"correct\" placed edgeHead rectangle.\r\n        // then the intersection will likely not fall on the extreme angle of EdgeHead and i can re-center edgeHead\r\n        // so that first and second intersections are equal spaced with the center segment\r\n        let secondIntersection: GraphPoint | undefined;\r\n        let segmentDistance = start.distanceFromPoint(end);\r\n        if (segmentDistance <= Math.sqrt(headPos.w**2 + headPos.h**2)){\r\n            let safeDistance = Math.max(headPos.w, headPos.h)*5;\r\n            end = new GraphPoint( end.y + safeDistance, end.y + m * safeDistance); // move the point away so it doesn't intersect anymore. i just need direction\r\n            // too small to fit edgeHead, i simply put it centered on the whole segment\r\n            // secondIntersection = end;\r\n        }\r\n        secondIntersection = GraphSize.closestIntersection(x4headsize, start, end, undefined);\r\n        if (!secondIntersection) return Log.exx(\"failed to intersect edge head\", {x4headsize, segment, headPos, c, start, end, useBezierPoints});\r\n        tmp = secondIntersection.add(start, false).divide(2); // center of edgehead\r\n        headPos.x = tmp.x - headPos.w / 2; // tl corner\r\n        headPos.y = tmp.y - headPos.h / 2; // tl corner\r\n        headPos.rad = Geom.mToRad(m, start, end);\r\n        /*\r\n        devo trovare la distanza tra il centro dell'egeHead e il punto di inizio in termini assoluti, così tramite M trovo distanza in x e y. o trovarla in altro modo\r\n        if (segment.m === Number.POSITIVE_INFINITY || segment.m === Number.NEGATIVE_INFINITY) {\r\n            center = segment.start.pt.add({x:0, y: distance}, true); }\r\n        else { center = segment.start.pt.add({x:segment.m*headPos.w/2, y:segment.m*headPos.h/2\r\n         this is wrong, cannot be the same for x and y, i should invert the line equation for x?}, true); }\r\n        headPos.x = center.x - headPos.w / 2;\r\n        headPos.y = center.y - headPos.h / 2;*/\r\n        // console.log(\"head intersected\", {headPos, secondIntersection, x4headsize, segment, c, start, end, useBezierPoints});\r\n\r\n        return headPos;\r\n    }\r\n\r\n    public headPos(headSize0?: GraphPoint, segment0?: EdgeSegment, zoom0?: GraphPoint): GraphSize & {rad: number} {\r\n        return this.wrongAccessMessage(\"This is not headPos() implementation. it is just for typings. use the getter\"); }\r\n    public tailPos(headSize0?: GraphPoint, segment0?: EdgeSegment, zoom0?: GraphPoint): GraphSize & {rad: number} {\r\n        return this.wrongAccessMessage(\"This is not tailPos() implementation. it is just for typings. use the getter\"); }\r\n    protected get_headPos(c: Context): this[\"headPos\"] {\r\n        return (headSize?: GraphPoint, segment?: EdgeSegment, zoom?: GraphPoint) => this.headPos_impl(c, true, headSize, segment, zoom); }\r\n    protected get_tailPos(c: Context): this[\"tailPos\"] {\r\n        return (headSize?: GraphPoint, segment?: EdgeSegment, zoom?: GraphPoint) => this.headPos_impl(c, false, headSize, segment, zoom); }\r\n    protected get_allNodes(c: Context): this[\"allNodes\"] { return [this.get_start(c), ...this.get_midnodes(c), this.get_end(c)]; }\r\n\r\n    protected get_edge(c: Context): this{ return c.proxyObject as this; }\r\n    protected set_edge(v: any, c: Context): false { return this.cannotSet(\"edge field, on an edge element\"); }\r\n    protected get_midPoints(c: Context):this[\"midPoints\"] { return c.data.midPoints; }\r\n    public addMidPoint(v: this[\"midPoints\"][0]): boolean { return this.wrongAccessMessage(\"addMidPoint\"); }\r\n    protected get_addMidPoint(c: Context): (v: this[\"midPoints\"][0]) => boolean { return (v:this[\"midPoints\"][0]) => this.impl_addMidPoints(v, c); }\r\n    protected set_midPoints(val: this[\"midPoints\"], c: Context): boolean {\r\n        return SetFieldAction.new(c.data.id, \"midPoints\", val, undefined, false);\r\n    }\r\n    protected impl_addMidPoints(val: this[\"midPoints\"][0], c: Context): boolean {\r\n        return SetFieldAction.new(c.data.id, \"midPoints\", val, '+=', false);\r\n    }\r\n    protected get_label_impl(c: Context, segment: EdgeSegment, nodes: this[\"allNodes\"], segments: EdgeSegment[]): PrimitiveType | undefined {\r\n        let key: \"longestLabel\" | \"labels\" = segment.isLongest ? \"longestLabel\" : \"labels\"; // : keyof this\r\n        // if (isLongestSegment) return this.get_longestLabel_impl(d, l, nodes, index):\r\n        const d = c.data;\r\n        const l = c.proxyObject;\r\n        let labelmaker: any = d[key]; // orArr<PrimitiveType | JSX | function>\r\n        let labelmakerfunc: labelfunc = labelmaker as any;\r\n        // let lastSeg = segments[i-1];\r\n        switch (typeof labelmaker) {//nb{}[]<>\r\n            case \"number\":\r\n            case \"undefined\":\r\n            case \"boolean\":\r\n            case \"string\": return labelmaker;\r\n            // case \"function\": return nodes.map( (o, i) => d.labels(l, nodes, i)).slice(0, nodes.length-1);\r\n            case \"function\": return labelmakerfunc(l, segment, nodes, segments);\r\n            default: break;\r\n            case \"object\":\r\n                if (labelmaker === null) return null;\r\n                if (!Array.isArray(labelmaker)) break;\r\n                if (typeof labelmaker[0] === \"function\") return (labelmaker[segment.index % labelmaker.length] as labelfunc)(l, segment, nodes, segments);\r\n                return (labelmaker as PrimitiveType[])[segment.index % labelmaker.length];\r\n        }\r\n        Log.exx(\"edge labels invalid type, must be a primitive value, a function or an array of such.\", {labelmaker, key, d});\r\n        return undefined;\r\n    }/*\r\n    private get_label_impl_old(d: DVoidEdge, l: LVoidEdge, nodes:this[\"allNodes\"], index: number, longestlabelindex?: number): PrimitiveType {\r\n        if (d.longestLabel !== undefined && index === longestlabelindex) return this.get_longestLabel_impl(d, l, nodes, index);\r\n        switch (typeof d.labels) {//nb{}[]<>\r\n            case \"number\":\r\n            case \"undefined\":\r\n            case \"boolean\":\r\n            case \"string\": return d.labels;\r\n            // case \"function\": return nodes.map( (o, i) => d.labels(l, nodes, i)).slice(0, nodes.length-1);\r\n            case \"function\": return d.labels(l, nodes[index], nodes[index+1], index, nodes);\r\n            default: break;\r\n            case \"object\": if (!Array.isArray(d.labels)) break;\r\n            if (typeof d.labels[0] === \"function\") return (d.labels as any)[index % d.labels.length](l, nodes[index], nodes[index+1], index, nodes);\r\n            return (d.labels as PrimitiveType[])[index % d.labels.length];\r\n        }\r\n        Log.exx(\"edge labels invalid type, must be a primitive value, a function or an array of such.\", d.labels);\r\n    }*/\r\n\r\n    __info_of__startPoint: Info = {type: \"GraphPoint\", txt:<span>startPoint of this.start (element originating the edge). Defaults in outer coordinates.</span>};\r\n    __info_of__endPoint: Info = {type: \"GraphPoint\", txt:<span>endPoint of this.end (element originating the edge). Defaults in outer coordinates.</span>};\r\n    public get_startPoint(context: Context): GraphPoint{ return this.get_startPoint_Outer(context); }\r\n    public get_endPoint(context: Context): GraphPoint{ return this.get_endPoint_Outer(context); }\r\n    public get_startPoint_Outer(c: Context): GraphPoint{\r\n        // console.log(\"get_edgeStart_Outer\", {out:this.get_outerGraph(c), pos:this.get_startPoint_inner(c), inner:this.get_start(c).innerGraph});\r\n        return this.get_outerGraph(c).translateSize(this.get_startPoint_inner(c), this.get_start(c).innerGraph);\r\n    }\r\n    public get_endPoint_Outer(c: Context): GraphPoint{\r\n        // console.log(\"get_edgeEnd_Outer\", {out:this.get_outerGraph(c), pos:this.get_endPoint_inner(c), inner:this.get_end(c).innerGraph});\r\n        return this.get_outerGraph(c).translateSize(this.get_endPoint_inner(c), this.get_end(c).innerGraph);\r\n    }\r\n\r\n    public get_startPoint_inner(c: Context): GraphPoint{ return this.get_edgeStartEnd_inner(c, true); }\r\n    public get_endPoint_inner(c: Context): GraphPoint{ return this.get_edgeStartEnd_inner(c, false); }\r\n    private get_edgeStartEnd_inner(c: Context, isStart: boolean): GraphPoint{ return isStart ? this.get_start(c).startPoint : this.get_end(c).endPoint; }\r\n    segments!: {all: EdgeSegment[], segments: EdgeSegment[], fillers: EdgeSegment[], head: GraphSize&{rad:number}, tail: GraphSize&{rad:number}};\r\n    segments_inner!: {all: EdgeSegment[], segments: EdgeSegment[], fillers: EdgeSegment[], head: GraphSize&{rad:number}, tail: GraphSize&{rad:number}};\r\n    segments_outer!: {all: EdgeSegment[], segments: EdgeSegment[], fillers: EdgeSegment[], head: GraphSize&{rad:number}, tail: GraphSize&{rad:number}};\r\n    __info_of__segments: Info = {type: \"{all:T, segments:T, fillers:T, head: GraphSize&{rad:number}, tail: as head} where T is EdgeSegment\",\r\n        txt:<span>Collection of segments connecting in order vertex and EdgePoint without intersecting their area, aimed to be rendered in svg path.\r\n            <br/>fillers are arcs generated by view.edgeGapMode being autofill, arcfill or linefill.\r\n            <br/>length of this.segments array is Math.ceil(allNodes.length / svg_letter_size) specified on view.\r\n            <br/>\"head\" and \"tail\" are the position and angle of eventual edge decorators. Refer to this.headPos documentation.</span>}\r\n\r\n    private svgLetterSize(s: string, addM: boolean = true, doublingMidPoints: boolean = true): {first:number, others: number} {\r\n        let ret: {first:number, others: number};\r\n        switch (s) {\r\n            default: ret = Log.exDevv(\"unexpected svg path letter: \\\"\" + s + \"\\\"\", s); break;\r\n            case EdgeBendingMode.Line:\r\n            case EdgeBendingMode.Bezier_quadratic_mirrored: ret = {first:1, others:1}; break;\r\n            case EdgeBendingMode.Bezier_quadratic:\r\n            case EdgeBendingMode.Bezier_cubic_mirrored: ret = {first:2, others:2}; break;\r\n            case EdgeBendingMode.Bezier_cubic: ret = {first:3, others:3}; break;\r\n            case EdgeBendingMode.Elliptical_arc: ret = {first:4, others:4}; break;\r\n\r\n            case EdgeBendingMode.Bezier_QT: ret = {first:2, others:1}; break;\r\n            case EdgeBendingMode.Bezier_CS: ret = {first:3, others:2}; break;\r\n        }\r\n\r\n        // account for the fact that every midpoint is listed twice: at anchor start and anchor end.\r\n        if (doublingMidPoints) {\r\n            // removing last point (first is already excluded because addM didn't trigger yet)\r\n            // , the remaining are midpoints to double. then i add it back\r\n            ret.first = (ret.first - 1) * 2 + 1;\r\n            ret.others = (ret.others - 1) * 2 + 1;\r\n        }\r\n\r\n        // account for the first M letter\r\n        //    (if the segment is not mode.gap or first, M coord still exist in segment but are ignored)\r\n        if (addM) {\r\n            ret.first += 1;\r\n            ret.others += 1;\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    private get_points_impl(allNodes: LGraphElement[], outer: boolean): segmentmaker[] {\r\n        function getAnchorOffset(size: GraphSize, offset: GraphPoint, isPercentage: boolean) {\r\n            if (!size) size = new GraphSize(0, 0, 0, 0);\r\n            if (isPercentage) offset = new GraphPoint(offset.x/100*(size.w), offset.y/100*(size.h));\r\n            return size.tl().add(offset, false);\r\n        }\r\n        const all: segmentmaker[] = allNodes.flatMap((ge, i) => {\r\n            let base: segmentmaker = {view: ge.view, size: outer ? ge.outerSize : ge.innerSize, ge, pt: null as any, uncutPt: null as any};\r\n            let rets: segmentmaker | undefined;// = base as any;\r\n            let rete: segmentmaker | undefined;// = {...base} as any;\r\n            if (i !== 0){\r\n                rete = {...base};\r\n                rete.pt = (LEdgePoint.singleton as LEdgePoint).get_endPoint(undefined as any, rete.size, rete.view);\r\n                rete.pt = getAnchorOffset(rete.size, rete.view.edgeStartOffset, rete.view.edgeStartOffset_isPercentage);\r\n                rete.uncutPt = rete.pt;\r\n            }\r\n            if (i !== allNodes.length - 1){\r\n                rets = {...base};\r\n                rets.pt = (LEdgePoint.singleton as LEdgePoint).get_startPoint(undefined as any, rets.size, rets.view);\r\n                rets.pt = getAnchorOffset(rets.size, rets.view.edgeStartOffset, rets.view.edgeStartOffset_isPercentage);\r\n                rets.uncutPt = rets.pt;\r\n            }\r\n            // ret.pt = ge.startPoint\r\n            return rets && rete ? [rete, rets] : (rets ? [rets] : [rete as segmentmaker]); }\r\n        );\r\n        return all;\r\n    }\r\n    private get_points(allNodes: LGraphElement[], outer: boolean = false): segmentmaker[]{ return this.get_points_impl(allNodes, outer); }\r\n    private get_points_outer(allNodes: LGraphElement[]): segmentmaker[]{ return this.get_points_impl(allNodes, true); }\r\n    private get_points_inner(allNodes: LGraphElement[]): segmentmaker[]{ return this.get_points_impl(allNodes, false); }\r\n    public d!: string;\r\n    public __info_of__d: Info = {type: ShortAttribETypes.EString, txt:\"the full suggested path of SVG path \\\"d\\\" attribute, merging all segments.\"}\r\n    public get_d(c: Context) {\r\n        return this.get_segments(c).all.map(s => s.d).join(\" \");\r\n    }/*\r\n    private get_fillingSegments(c: Context): Partial<this[\"segments\"]> {\r\n        return this.get_segments(c).fillers;\r\n    }*/\r\n\r\n\r\n    public get_segments(c:Context): this[\"segments\"] { return this.get_segments_outer(c); }\r\n    public get_segments_outer(c:Context): this[\"segments\"] { return this.get_segments_impl(c, true); }\r\n    public get_segments_inner(c: Context): this[\"segments\"] { return this.get_segments_impl(c, false); }\r\n    private get_segments_impl(c: Context, outer: boolean): this[\"segments\"] {\r\n        let l = c.proxyObject;\r\n        let v = this.get_view(c);\r\n        let allNodes = l.allNodes;\r\n        windoww.edge = l;\r\n        let all: segmentmaker[] = this.get_points(allNodes, outer);\r\n        //const all: {size: GraphSize, view: LViewElement, ge: LGraphElement}[] = allNodes.map((ge) => { return { view: ge.view, size: ge.size, ge}});\r\n        let ret: EdgeSegment[] = [];\r\n        let bm: EdgeBendingMode = v.bendingMode;\r\n        let gapMode: EdgeGapMode = v.edgeGapMode;\r\n        let segmentSize = this.svgLetterSize(bm, false, true);\r\n        let increase: number = segmentSize.first;\r\n        let segment: EdgeSegment | undefined;\r\n        /// grouping points according to SvgLetter\r\n        for (let i = 0; i < all.length - 1; ) {\r\n            // let start = all[i], end = all[i+increase];\r\n            let start: segmentmaker = all[i];\r\n            let endindex = (i+increase < all.length - 1) ? i+increase : all.length - 1;\r\n            let mid: segmentmaker[] = all.slice(i+1, endindex).filter( (e, i)=> i % 2 === 0);\r\n            let end: segmentmaker = all[endindex];\r\n            // makes sure the edge actually reaches his target even if there is an invalid amount of midnodes fot the current EdgeBendingMode\r\n            if (i === endindex && segment) start = segment.end;\r\n            // segment = this.get_segmentv3(start, mid, end, getSvgLetter(i), i, segment, all);\r\n            segment = new EdgeSegment(start, mid, end, bm, gapMode, i, segment);\r\n            // segment = this.get_segment(start.ge, start.size, start.view, end.ge, end.size, end.view, cut, v.bendingMode, mid, ret[ret.length -1], fillMode, segment);\r\n            ret.push(segment);\r\n            i+= increase+1; // because increase index is already inserted at the end of prev segment\r\n            if (increase !== segmentSize.others) increase = segmentSize.others;\r\n            // if (longestLabel !== undefined && longest < s.length) { longest = s.length; longestindex = i; } todo: move to after snapping to borders\r\n        }\r\n        let fillSegments: EdgeSegment[] = [];\r\n        this.snapSegmentsToNodeBorders(c, v, ret, fillSegments);\r\n        let longestLabel = c.data.longestLabel;\r\n        this.setLabels(c, ret, allNodes);\r\n        // console.log(\"getSegments() labeled:\", {main:ret, fillSegments});\r\n        let rett: this[\"segments\"] = {all: [...ret, ...fillSegments], segments: ret, fillers: fillSegments} as any;\r\n        for (let i = 0; i < rett.all.length; i++) {\r\n            let s = rett.all[i];\r\n            s.makeD(i, gapMode);\r\n        }\r\n        let zoom = new GraphPoint(1, 1);\r\n        rett.head = this.headPos_impl(c, true, v.edgeHeadSize, rett.segments[rett.segments.length - 1], zoom);\r\n        rett.tail = this.headPos_impl(c, false, v.edgeTailSize, rett.segments[0], zoom);\r\n        return rett;\r\n    }\r\n    private setLabels(c: Context, segments: EdgeSegment[], allNodes: this[\"allNodes\"]): void {\r\n        // find longest segment\r\n        let longestindex = -1;\r\n        let longest = 0;\r\n        for (let i = 0; i < segments.length; i++) {\r\n            let s = segments[i];\r\n            s.calcLength();\r\n            if (longest < s.length) { longest = s.length; longestindex = i; }\r\n            s.isLongest = false;\r\n        }\r\n        if (longestindex >= 0) segments[longestindex].isLongest = true;\r\n        // apply labels\r\n        for (let s of segments) s.label = this.get_label_impl(c, s, allNodes, segments);\r\n    }\r\n\r\n    private snapSegmentsToNodeBorders(c: Context, v: LViewElement, ret: EdgeSegment[], fillSegments: EdgeSegment[]){\r\n        // snap segment start and end to a node border\r\n        let canCutStart: boolean = v.edgeStartStopAtBoundaries,\r\n            canCutEnd: boolean = v.edgeEndStopAtBoundaries;\r\n        let grid: GraphPoint | undefined = undefined;\r\n        // let fillSegments: EdgeSegment[] = [];\r\n        let gapMode: EdgeGapMode = v.edgeGapMode;\r\n        let bm: EdgeBendingMode = v.bendingMode;\r\n\r\n\r\n        let ci: GraphPoint | undefined;\r\n        // cut i === 0 is cut regardless of gapmode.\r\n        if (canCutStart) {\r\n            ci = GraphSize.closestIntersection(ret[0].start.size, ret[0].start.pt, (ret[0].bezier[0] || ret[0].end).pt, grid);\r\n            if (ci) ret[0].start.pt = ci;\r\n            /*\r\n            ret[0].start.pt =\r\n                GraphSize.closestIntersection(ret[0].start.size, ret[0].start.pt, (ret[0].bezier[0] || ret[0].end).pt, grid) as any\r\n                || Geom.closestPoint(ret[0].start.size, ret[0].start.pt);*/\r\n        }\r\n\r\n        // cut middle segments maybe\r\n        let prev: EdgeSegment;\r\n        let curr: EdgeSegment = ret[0];\r\n        if (canCutStart || canCutEnd) // do the for below\r\n            for (let i = 1; i < ret.length; i++){\r\n                prev = ret[i-1];\r\n                curr = ret[i];\r\n                let doStartCut: boolean, doEndCut: boolean;\r\n                switch(gapMode){\r\n                    case EdgeGapMode.arcFill:\r\n                    case EdgeGapMode.lineFill:\r\n                    case EdgeGapMode.autoFill:\r\n                        // same as gap, but will insert 1 more segment to fill the hole\r\n                        doStartCut = true;\r\n                        doEndCut = true;\r\n                        if (prev.end.pt.equals(curr.start.pt)) break;\r\n                        fillSegments.push(new EdgeFillSegment(\r\n                            prev.end,\r\n                            [\r\n                                {...prev.end, pt: EdgeSegment.invertLastBezierPt(prev.end.pt, (prev.bezier[prev.bezier.length-1] || prev.start).pt)},\r\n                                {...curr.start, pt: EdgeSegment.invertLastBezierPt(curr.start.pt, (curr.bezier[0] || curr.end).pt)}\r\n                            ],\r\n                            curr.start,\r\n                            bm, gapMode, 0, undefined));\r\n                            /*\r\n                            fillSegments.push(new FillEdgeSegment( // M <start_gap> C <bez1> <bez2> <end_gap>\r\n                               // <start_gap> = end of last seg (start of gap) <end_gap> = first of curr seg (end of gap)\r\n                            prev.end.pt,\r\n                            EdgeSegment.invertLastBezierPt(prev.end.pt, prev.bezier[prev.bezier.length-1].pt || prev.start.pt),\r\n                            EdgeSegment.invertLastBezierPt(curr.start.pt, curr.bezier[0].pt || curr.end.pt),\r\n                            curr.start.pt)\r\n                            */\r\n                        break;\r\n                    case EdgeGapMode.gap:\r\n                        // just snap to vertex edge         prevSegment.endp and ret.startp\r\n                        doStartCut = true;\r\n                        doEndCut = true;\r\n                        break;\r\n                    // average: todo: maybe rename in join (merges start-end at closest pt to both (avg), then snap on edge)\r\n                    case EdgeGapMode.average:\r\n                        // first move to average of the 2 points in the gap, then snap to edge\r\n                        doEndCut = true; doStartCut = true;\r\n                        // indipendent from cutStart, cutEnd.\r\n                        // they merge if just 1 of cutting sides are true. (and if they are both false we don't even enter the for loop)\r\n                        curr.start.pt.add(prev.end.pt, false).divide(2, false);\r\n                        prev.end.pt = curr.start.pt.duplicate() // intentionally not the same pt because during snap to edge they can temporarly diverge.again,\r\n                        prev.start.uncutPt = prev.start.pt;\r\n                        prev.end.uncutPt = prev.end.pt;\r\n                        break;\r\n                    // center: first move it to center of edgePoint/node, then snap to edge.\r\n                    // this mode might be as well deleted, it can be specified with anchor points\r\n                    case EdgeGapMode.center:\r\n                        doEndCut = false; doStartCut = false;\r\n                        curr.start.pt = curr.start.size.tl().add(curr.start.size.br(), false).divide(2, false);\r\n                        prev.end.pt = curr.start.pt.duplicate(); // intentionally not the same pt because during snap to edge they can diverge.again,\r\n                        prev.start.uncutPt = prev.start.pt; // only update them when point moves without being cut (average and center)\r\n                        prev.end.uncutPt = prev.end.pt;\r\n                        break;\r\n                    default:\r\n                        return Log.exDevv(\"unexpected EdgeGapMode:\" + gapMode);\r\n                }\r\n                if (canCutStart && doStartCut){\r\n                    let extpt: GraphPoint = (curr.bezier[0] || curr.end).pt;\r\n                    ci = GraphSize.closestIntersection(curr.start.size, curr.start.pt, extpt, grid);\r\n                    if (ci) curr.start.pt = ci;// || Geom.closestPoint(curr.start.size, curr.start.pt);\r\n                    //if (gapMode === EdgeGapMode.average && prev) { prev.end.pt = curr.start.pt.add(prev.end.pt, false).divide(2, false); }\r\n                }\r\n                if (canCutEnd && doEndCut && prev){\r\n                    let prevpt: GraphPoint = (prev.bezier[prev.bezier.length-1] || prev.start).pt;\r\n                    ci = GraphSize.closestIntersection(prev.end.size, prev.end.pt, prevpt, grid);\r\n                    if (ci) prev.end.pt = ci;// || Geom.closestPoint(prev.end.size, prev.end.pt);\r\n                    // if average: first do average between start anchor points non-snapped. then i snap both,\r\n                    // then i do average again, and since it might snap out, i get closestPoint to EdgePoint size\r\n                    if (gapMode === EdgeGapMode.average) prev.end.pt = curr.start.pt =\r\n                        Geom.closestPoint(curr.start.size, curr.start.pt.add(prev.end.pt, false).divide(2, false));\r\n                }\r\n            }\r\n        // cut end of last segment regardless of gapMode\r\n        if (canCutEnd) {\r\n            let prevendpt = curr.end.pt;\r\n            ci = GraphSize.closestIntersection(curr.end.size, curr.end.pt, (curr.bezier[curr.bezier.length-1] || curr.start).pt, grid);\r\n            if (ci) curr.end.pt = ci; //|| Geom.closestPoint(prev.end.size, prev.end.pt);\r\n        }\r\n\r\n    }\r\n\r\n\r\n\r\n    get_edgeEnd(context: Context){ return this.get_edgeEnd_outer(context); }\r\n    get_edgeEnd_outer(c: Context){\r\n        // return this.get_outerGraph(c).translateSize(this.get_edgeEnd_inner(c), this.get_innerGraph(c));\r\n        return this.get_outerGraph(c).translateSize(this.get_edgeEnd_inner(c), this.get_end(c).innerGraph);\r\n    }\r\n    get_edgeEnd_inner(c: Context){\r\n        return this.get_edgeStartEnd_inner(c, false);\r\n        // return context.proxyObject.end?.size || new GraphPoint(0, 0);\r\n    }\r\n\r\n\r\n    protected get_midnodes(context: Context): this[\"midnodes\"] {\r\n        // return LPointerTargetable.wrapAll(context.data.midnodes);\r\n        return LPointerTargetable.wrapAll(context.data.subElements);\r\n    }\r\n    protected set_midnodes(val: D[\"midnodes\"], context: Context): boolean {\r\n        return SetFieldAction.new(context.data.id, \"midnodes\", val, '', true);\r\n    }\r\n    protected get_start(context: Context): this[\"start\"] { return LPointerTargetable.from(context.data.start); }\r\n    protected get_end(context: Context): this[\"end\"] { return LPointerTargetable.from(context.data.end); }\r\n\r\n}\r\nRuntimeAccessibleClass.set_extend(DGraphElement, DVoidEdge);\r\nRuntimeAccessibleClass.set_extend(LGraphElement, LVoidEdge);\r\n@RuntimeAccessible('DEdge')\r\nexport class DEdge extends DVoidEdge { // DVoidEdge\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // static singleton: LGraphElement;\r\n    // static logic: typeof LGraphElement;\r\n    // static structure: typeof DGraphElement;\r\n    id!: Pointer<DEdge, 1, 1, LEdge>;\r\n    graph!: Pointer<DGraph, 1, 1, LGraph>;\r\n    model!: Pointer<DModelElement, 0, 1, LModelElement>;\r\n    // isSelected: Dictionary<DocString<Pointer<DUser>>, boolean> = {};\r\n    isSelected!: Dictionary<DocString<Pointer<DUser>>, boolean>;\r\n    // containedIn!: Pointer<DGraphElement, 0, 1, LGraphElement>;\r\n    subElements!: Pointer<DGraphElement, 0, 'N', LGraphElement>;\r\n    state: DMap = {} as any;\r\n    start!: Pointer<DGraphElement, 1, 1, LGraphElement>;\r\n    end!: Pointer<DGraphElement, 1, 1, LGraphElement>;\r\n    __isDEdge!: true;\r\n    __isDVoidEdge!: true;\r\n    midnodes!: Pointer<DEdgePoint, 1, 1, LEdgePoint>[];\r\n\r\n}\r\n\r\n@RuntimeAccessible('LEdge')\r\nexport class LEdge<Context extends LogicContext<DEdge> = any, D extends DEdge = DEdge> extends LVoidEdge {\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // static singleton: LGraphElement;\r\n    // static logic: typeof LGraphElement;\r\n    // static structure: typeof DGraphElement;\r\n    __raw!: DEdge;\r\n    id!: Pointer<DEdge, 1, 1, LEdge>;\r\n    graph!: LGraph;\r\n    model?: LModelElement;\r\n    // isSelected: Dictionary<DocString<Pointer<DUser>>, boolean> = {};\r\n    isSelected(forUser?: Pointer<DUser>): boolean { return this.wrongAccessMessage(\"node.isSelected()\"); }\r\n    // containedIn!: LGraphElement;\r\n    subElements!: LGraphElement[];\r\n    state!: LMap;\r\n    start!: LGraphElement;\r\n    end!: LGraphElement;\r\n    midnodes!: LEdgePoint[];\r\n    __isLEdge!: true;\r\n    __isLVoidEdge!: true;\r\n\r\n}\r\nRuntimeAccessibleClass.set_extend(DVoidEdge, DEdge);\r\nRuntimeAccessibleClass.set_extend(LVoidEdge, LEdge);\r\n@Leaf\r\n@RuntimeAccessible('DExtEdge')\r\nexport class DExtEdge extends DEdge { // etends DEdge\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // static singleton: LGraphElement;\r\n    // static logic: typeof LGraphElement;\r\n    // static structure: typeof DGraphElement;\r\n    id!: Pointer<DExtEdge, 1, 1, LExtEdge>;\r\n    graph!: Pointer<DGraph, 1, 1, LGraph>;\r\n    model!: Pointer<DModelElement, 0, 1, LModelElement>;\r\n    // isSelected: Dictionary<DocString<Pointer<DUser>>, boolean> = {};\r\n    isSelected!: Dictionary<DocString<Pointer<DUser>>, boolean>;\r\n    // containedIn!: Pointer<DGraphElement, 0, 1, LGraphElement>;\r\n    subElements!: Pointer<DGraphElement, 0, 'N', LGraphElement>;\r\n    state: DMap = {} as any;\r\n    start!: Pointer<DGraphElement, 1, 1, LGraphElement>;\r\n    end!: Pointer<DGraphElement, 1, 1, LGraphElement>;\r\n    __isDExtEdge!: true;\r\n    __isDEdge!: true;\r\n    __isDVoidEdge!: true;\r\n    /*\r\n        public static new(model: DGraph[\"model\"], parentNodeID: DGraphElement[\"father\"], graphID: DGraphElement[\"graph\"], nodeID?: DGraphElement[\"id\"], size?: GraphSize): DExtEdge {\r\n            return new Constructors(new DExtEdge('dwc')).DPointerTargetable().DGraphElement(model, parentNodeID, graphID, nodeID)\r\n                .DVoidEdge().DEdge().DExtEdge().end();\r\n        }*/\r\n}\r\n\r\n@RuntimeAccessible('LExtEdge')\r\nexport class LExtEdge extends LEdge{\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // static singleton: LGraphElement;\r\n    // static logic: typeof LGraphElement;\r\n    // static structure: typeof DGraphElement;\r\n    __raw!: DExtEdge;\r\n    id!: Pointer<DExtEdge, 1, 1, LExtEdge>;\r\n    graph!: LGraph;\r\n    model?: LModelElement;\r\n    // isSelected: Dictionary<DocString<Pointer<DUser>>, boolean> = {};\r\n    isSelected(forUser?: Pointer<DUser>): boolean { return this.wrongAccessMessage(\"node.isSelected()\"); }\r\n    // containedIn!: LGraphElement;\r\n    subElements!: LGraphElement[];\r\n    state!: LMap;\r\n    start!: LGraphElement;\r\n    end!: LGraphElement;\r\n    __isLExtEdge!: true;\r\n    __isLEdge!: true;\r\n    __isLVoidEdge!: true;\r\n}\r\nRuntimeAccessibleClass.set_extend(DEdge, DExtEdge);\r\nRuntimeAccessibleClass.set_extend(LEdge, LExtEdge);\r\n@Leaf\r\n@RuntimeAccessible('DRefEdge')\r\nexport class DRefEdge extends DEdge { // extends DEdge\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    start!: Pointer<DGraphElement, 1, 1, LGraphElement>;\r\n    end!: Pointer<DGraphElement, 1, 1, LGraphElement>;\r\n    isSelected!: Dictionary<DocString<Pointer<DUser>>, boolean>;\r\n    __isDRefEdge!: true;\r\n    /*\r\n        public static new(model: DGraph[\"model\"], parentNodeID: DGraphElement[\"father\"], graphID: DGraphElement[\"graph\"], nodeID?: DGraphElement[\"id\"]): DRefEdge {\r\n            return new Constructors(new DRefEdge('dwc')).DPointerTargetable().DGraphElement(model, parentNodeID, graphID, nodeID)\r\n                .DVoidEdge().DEdge().DRefEdge().end();\r\n        }*/\r\n\r\n}\r\n@RuntimeAccessible('LRefEdge')\r\nexport class LRefEdge extends LEdge {\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // __raw!: DRefEdge;\r\n    start!: LGraphElement;\r\n    end!: LGraphElement;\r\n    __isLRefEdge!: true;\r\n}\r\nRuntimeAccessibleClass.set_extend(DEdge, DRefEdge);\r\nRuntimeAccessibleClass.set_extend(LEdge, LRefEdge);\r\n// for edges without a modelling element\r\n\r\n\r\n/*\r\n\r\nlet a = `DExtEdge, DRefEdge, DVoidEdge, LGraphVertex, LRefEdge, LEdgePoint, DVoidVertex, DGraphVertex, DEdgePoint,\r\n DVertex, DEdge, LVertex, LGraph, DGraph, LVoidVertex, LVoidEdge, LEdge, LGraphElement, LExtEdge, DGraphElement`;\r\n  // // ... get from export in index.ts\r\na = a.replaceAll(',,', \",\")\r\nlet aa = a.split(\",\").map(a => a.trim().substring(1));\r\n\r\nfunction onlyUnique(value, index, self) { return self.indexOf(value) === index; }\r\n\r\naa = aa.filter(onlyUnique).filter( a=> !!a)\r\nlet r = aa.filter(onlyUnique).filter( a=> !!a).map( a=> `export type W${a} = getWParams<L${a}, D${a}>;`).join('\\n')\r\ndocument.body.innerText = r;\r\n*/\r\nexport type WExtEdge = getWParams<LExtEdge, DExtEdge>;\r\nexport type WRefEdge = getWParams<LRefEdge, DRefEdge>;\r\nexport type WVoidEdge = getWParams<LVoidEdge, DVoidEdge>;\r\nexport type WGraphVertex = any; // getWParams<LGraphVertex, DGraphVertex>;\r\nexport type WEdgePoint = getWParams<LEdgePoint, DEdgePoint>;\r\nexport type WVoidVertex = getWParams<LVoidVertex, DVoidVertex>;\r\nexport type WVertex = getWParams<LVertex, DVertex>;\r\nexport type WEdge = getWParams<LEdge, DEdge>;\r\nexport type WGraph = getWParams<LGraph, DGraph>;\r\nexport type WGraphElement = getWParams<LGraphElement, DGraphElement>;\r\n\r\nconsole.warn('ts loading graphDataElement');\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}