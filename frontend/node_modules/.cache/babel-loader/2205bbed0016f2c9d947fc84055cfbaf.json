{"ast":null,"code":"import { DViewElement, UX, GraphElementComponent, ViewEClassMatch } from '../../joiner';\nimport { Action, CompositeAction, CreateElementAction, DeleteElementAction, DPointerTargetable, DState, DUser, getPath, Log, MyError, PendingPointedByPaths, PointedBy, Pointers, RuntimeAccessibleClass, SetFieldAction, SetRootFieldAction, statehistory } from \"../../joiner\";\nimport React from \"react\";\nimport { LoadAction, RedoAction, UndoAction } from \"../action/action\";\nimport Collaborative from \"../../components/collaborative/Collaborative\";\nimport { SimpleTree } from \"../../common/SimpleTree\";\nimport { transientProperties, Selectors } from \"../../joiner\";\nimport { contextFixedKeys } from '../../graph/graphElement/sharedTypes/sharedTypes';\nimport Storage from \"../../data/storage\";\nimport { ProjectsApi } from \"../../api/persistance\";\nimport DSL from \"../../DSL/DSL\";\nlet windoww = window;\nlet U = windoww.U;\nfunction deepCopyButOnlyFollowingPath(oldStateDoNotModify, action, prevAction, newVal) {\n  var _action$path;\n  let newRoot = {\n    ...oldStateDoNotModify\n  };\n  let current = newRoot;\n  if (!((_action$path = action.path) === null || _action$path === void 0 ? void 0 : _action$path.length)) throw new MyError(\"path length must be at least 1\", {\n    action\n  });\n  let gotChanged = false; // dovrebbe cambiare sempre, se non cambia non lancio neanche l'azione e non faccio la shallow copy, ma non si sa mai, così posso evitare un render se succede l' \"insuccedibile\"\n  let alreadyPastDivergencePoint = false; // true dal momento in cui il path dell'azione attuale e della azione precedente divergono, false fino al sotto-segmento in cui combaciano\n  // console.log('deepCopyButOnlyFollowingPath', arguments);\n  for (let i = 0; i < action.pathArray.length; i++) {\n    let key = action.pathArray[i].trim();\n    let prevActionPathKey = prevAction === null || prevAction === void 0 ? void 0 : prevAction.pathArray[i];\n    // middle execution: not on final loop\n    // console.log('deepCopyButOnlyFollowingPath', {current, i, imax:action.pathArray.length, key, gotChanged, alreadyPastDivergencePoint});\n    if (i !== action.pathArray.length - 1) {\n      if (alreadyPastDivergencePoint || key !== prevActionPathKey) {\n        // se l'oggetto è stato già duplicato in una azione composita, non lo duplico 2 volte.\n        alreadyPastDivergencePoint = true;\n        current[key] = Array.isArray(current[key]) ? [...current[key]] : {\n          ...current[key]\n        };\n        current[key].clonedCounter = 1 + (current[key].clonedCounter || 0);\n      }\n      current = current[key];\n      continue;\n    }\n    // Giordano: added this on 03/12/2023 to prevent \"Cannot read properties of undefined\".\n    // if(!current) continue; damiano: temp removed to check if there are invalid actions firing\n    // perform final assignment\n    if (i >= action.pathArray.length - 1) {\n      let isArrayAppend = false;\n      let isArrayRemove = false;\n      let isObjectMerge = false;\n      let isObjectDifference = false;\n      // console.log('isarrayappend?', {endswith: U.endsWith(key, ['+=', '[]', '-1']), key, action, i});\n      // console.log('isarraydelete?', {endswith: U.endsWith(key, ['-='])});\n\n      let oldValue;\n      if (U.endsWith(key, ['+=', '[]'])) {\n        key = key.substr(0, key.length - 2).trim();\n        oldValue = current[key];\n        switch (typeof oldValue) {\n          case 'object':\n            if (Array.isArray(oldValue)) isArrayAppend = true;else isObjectMerge = true;\n            break;\n          default:\n            newVal += oldValue;\n            break;\n        }\n      }\n      if (U.endsWith(key, ['-='])) {\n        key = key.substr(0, key.length - 2).trim();\n        oldValue = current[key];\n        switch (typeof oldValue) {\n          case 'object':\n            if (Array.isArray(oldValue)) isArrayRemove = true;else isObjectDifference = true;\n            break;\n          case \"string\":\n            newVal = U.replaceAll(oldValue, newVal, '');\n            break;\n          default:\n            newVal -= oldValue;\n            break;\n        }\n        isArrayRemove = true;\n      }\n\n      // let unpointedElement: DPointerTargetable | undefined;\n      // perform final assignment\n      if (action.type === CreateElementAction.type && current[key]) {\n        oldValue = current[key];\n        gotChanged = false;\n        Log.ee(\"rejected CreateElementAction, rollback occurring:\", {\n          action,\n          preexistingValue: current[key],\n          isShallowEqual: current[key] === action.value\n        });\n        return false; // warning: use return only when you want to abort and skip subsequent CompositeAction sub-actions like now.\n      }\n\n      if (isObjectMerge) {\n        if (typeof newVal === 'string') {\n          let tmp = {};\n          tmp[newVal] = true;\n          newVal = tmp;\n        }\n        oldValue = {\n          ...current[key]\n        };\n        current[key] = {\n          ...current[key]\n        };\n        for (let subkey in newVal) {\n          // console.warn(\"object merge\", {current, key, subkey, newVal, old:current[key][subkey], new:newVal[subkey]});\n          if (current[key][subkey] === newVal[subkey]) continue;\n          current[key][subkey] = newVal[subkey];\n          gotChanged = true;\n          if (action.isPointer) {\n            newRoot = PointedBy.add(key, action, newRoot, \"+=\");\n          }\n        }\n      } else if (isObjectDifference) {\n        if (typeof newVal === 'string') {\n          let tmp = {};\n          tmp[newVal] = true;\n          newVal = tmp;\n        }\n        oldValue = {\n          ...current[key]\n        };\n        current[key] = {\n          ...current[key]\n        };\n        for (let subkey in newVal) {\n          if (!(subkey in current[key])) continue;\n          delete current[key][subkey];\n          gotChanged = true;\n          if (action.isPointer) {\n            newRoot = PointedBy.add(key, action, newRoot, \"-=\");\n          }\n        }\n      } else if (isArrayAppend) {\n        gotChanged = true;\n        if (!Array.isArray(current[key])) {\n          current[key] = [];\n        }\n        oldValue = [...current[key]];\n        current[key] = [...current[key]];\n        current[key].push(newVal);\n        // unpointedElement = undefined;\n        if (action.isPointer) {\n          newRoot = PointedBy.add(newVal, action, newRoot, \"+=\");\n        }\n      } else if (isArrayRemove) {\n        if (!Array.isArray(current[key])) {\n          current[key] = [];\n        }\n        oldValue = [...current[key]];\n        let index;\n        if (U.isNumber(newVal)) {\n          // delete by index\n          index = newVal;\n          if (index < 0) index = oldValue.length + index; // if index is -2, i remove the penultimate element\n        } else if (newVal === undefined) {\n          index = oldValue.length - 1;\n        } else {\n          index = oldValue.indexOf(newVal);\n        }\n        // if it's negatively or positively out of boundary, i skip it\n        gotChanged = index >= 0 && index < current[key].length;\n        if (gotChanged) {\n          current[key] = [...current[key]];\n          let removedval = current[key].splice(index, 1); // in-place edit\n          if (action.isPointer) {\n            newRoot = PointedBy.remove(removedval, action, newRoot, '-=');\n          }\n          /*\r\n          fixed problem: se ho [dobj1, dobj2]... e li swappo, cambia un indice nel percorso \"pointedby\" e non me ne accorgo mai e un oggetto risulta \"pointedby\" da oggetti che non lo puntano o non esistono più a quell'indice\r\n          SOLVED! by not including index in pointedBy path, but making it like \"parentObject.arrayKey+=\" instead of \"parentObject.arrayKey.4\"\r\n          and knowing it's in the array it's enough info.\r\n            // a.pointsto = [x, y, z]; a.pointsto = [x, z]       --->    remove a from y.pointedby\r\n          const elementsThatChangedIndex: DPointerTargetable[] = current[key].slice(index);\r\n            for (let j = 0; j < elementsThatChangedIndex.length; j++) {\r\n              let newindex = index + j - 1;\r\n              let oldFullpathTrimmed = action.pathArray.join('.');\r\n              se realizzi \"pointedby\" qui è to do: remove old paths and re-add them with updated index\r\n          }\r\n          unpointedElement = newRoot.idlookup[oldValue];\r\n          */\n        }\n      } else if (action.type === DeleteElementAction.type && !(key in current) || current[key] === newVal) {\n        // value not changed\n        gotChanged = false;\n      } else {\n        // value changed\n        // todo: caso in cui setto manualmente classes.1 = pointer;\n        //  the latest element is array and not DPointerTargetable, so might need to buffer upper level in the tree? or instead of \"current\" keep an array of sub-objects encountered navigating the path in state.\n        oldValue = current[key];\n        gotChanged = true;\n        // unpointedElement = newRoot.idlookup[oldValue];\n        // NB: se elimino un oggetto che contiene array di puntatori, o resetto l'array di puntatori kinda like store.arr= [ptr1, ptr2, ...]; store.arr = [];\n        // i puntati dall'array hanno i loro pointedBY non aggiornati, non voglio fare un deep check di tutto l'oggetto a cercare puntatori per efficienza.\n        // if (newVal === undefined) delete current[key];\n        if (newVal === undefined || false && action.type === DeleteElementAction.type) delete current[key];else current[key] = newVal;\n\n        // update pointedBy's\n        // NB: even if the current action have isPointer=true, it doesn't mean the old value is a pointer as well for sure. so need to check old values.\n        // also what if old val is pointer, and new one isn't? will it be just removed without updating pointedBy's?\n        // already fixed: might need to evaluate this if block always regardless of action.isPointer,\n        // and do checks every time both on old and new value if they actually are ptrs.\n        if (true || action.isPointer) {\n          let oldpointerdestinations;\n          let newpointerdestinations;\n          if (Array.isArray(newVal)) {\n            newpointerdestinations = newVal;\n            if (Array.isArray(oldValue)) {\n              // case: path.array = array;\n              oldpointerdestinations = oldValue;\n            } else {\n              // case: path.object = array; + case: path.value = array;\n              oldpointerdestinations = [oldValue];\n            }\n          } else {\n            // case: path.array = object; + case: path.array = value;\n            newpointerdestinations = [newVal];\n            if (Array.isArray(oldValue)) {\n              oldpointerdestinations = oldValue;\n            } else {\n              // case: path.object = object; and all other cases without arrays involved\n              oldpointerdestinations = [oldValue];\n            }\n          }\n          // after i mapped all cases to path.array = array; i solve it for that case.\n          let difference = U.arrayDifference(oldpointerdestinations, newpointerdestinations); // : {added: Pointer[], removed: Pointer[], starting: Pointer[], final: Pointer[]}\n          for (let rem of difference.removed) {\n            if (Pointers.isPointer(rem)) newRoot = PointedBy.remove(rem, action, newRoot, undefined, oldStateDoNotModify);\n          }\n          for (let add of difference.added) {\n            if (Pointers.isPointer(add)) newRoot = PointedBy.add(add, action, newRoot, undefined, oldStateDoNotModify);\n          }\n          // a.pointsto = [a, b, c];  a.pointsto = [a, b, x];    ------>     c.pointedby.remove(a) & x.pointedby.add(a)\n          // idlookup.somelongid.pointsto = [...b];\n        }\n      }\n\n      break;\n    }\n    Log.exDevv('should not reach here: reducer');\n  }\n  return gotChanged ? newRoot : oldStateDoNotModify;\n}\n\n// const pendingPointedByPaths: {from: DocString<\"Path in store\">, field: DocString<\"keyof object found in from path\">, to: Pointer}[] = [];\nfunction CompositeActionReducer(oldState, actionBatch) {\n  // per via di thunk se arrivo qui lo stato cambia sicuro in mono-client non synchro (non ri-assegno valori equivalenti)\n  // todo: ma se arrivano in ordine sbagliato da altri client? posso permetterlo?\n  let actions;\n  if (actionBatch.actions) actions = Action.parse(actionBatch.actions);else actions = [Action.parse(actionBatch)]; // else-case is if it's a single action and not an actual compositeaction\n  if (PendingPointedByPaths.all.length) actions.push(...PendingPointedByPaths.getSolveableActions(oldState)); //.all.map( p=> p.resolve() ) );\n\n  Action.possibleInconsistencies = {};\n\n  // estraggo le azioni derivate\n  let derivedActions = [];\n  let newState = oldState;\n  for (let action of actions) {\n    switch (action.type) {\n      default:\n        break;\n      case CreateElementAction.type:\n        const elem = action.value;\n        delete DPointerTargetable.pendingCreation[elem.id];\n        /*\r\n        if (oldState.idlookup[elem.id]) {\r\n            Log.ee(\"rejected CreateElementAction, rollback occurring:\", {action, elem:{...elem},\r\n                preexistingValue: {...oldState.idlookup[elem.id]}, isEqual: elem === oldState.idlookup[elem.id] });\r\n            return oldState; // warning: use return only when you want to abort and skip subsequent CompositeAction sub-actions like now.\r\n              action.value = \"An element with that id already existed.\";\r\n            action.path = action.field = \"CreateActionRejected\";\r\n            action.className = SetRootFieldAction.name;\r\n            action.type = SetRootFieldAction.type;\r\n            action.pathArray = [action.path]; //a\r\n            action.isPointer = false;\r\n            // just to log it in undo-redo action list and have a feedback\r\n            return oldState;}*/\n\n        elem.className = elem.className || elem.constructor.cname || elem.constructor.name;\n        let statefoldername = elem.className.substring(1).toLowerCase() + 's';\n        derivedActions.push(Action.parse(SetRootFieldAction.create(statefoldername, elem.id, '[]', true)));\n        if (!Array.isArray(elem.pointedBy)) elem.pointedBy = [];\n        elem.pointedBy.push(PointedBy.new(statefoldername));\n        /*if (false && action.isPointer) {\r\n            if (Array.isArray(action.value)) {\r\n                const ptr: Pointer[] = action.value;\r\n                // todo but replaced by side actions in execution of the main action instead of triggering derived actions\r\n            }\r\n            else {\r\n                const ptr: Pointer = action.value;\r\n                const target: DPointerTargetable | null = oldState.idlookup[ptr];\r\n                let pendingPointedBy = PendingPointedByPaths.new(action, oldState);\r\n                if (!target) PendingPointedByPaths.new(action, oldState).saveForLater(); // {from: action.path, field: action.field, to: target});\r\n                // @ts-ignore\r\n                else derivedActions.push(pendingPointedBy.resolve());\r\n                // a -> x\r\n                // a -> y     unset x.pointedby(a)\r\n            }\r\n        }*/\n        break;\n    }\n  }\n  // console.error({U, Umip:U.arrayMergeInPlace, WU: windoww.U, WUmip: windoww.U.arrayMergeInPlace});\n  actions = U.arrayMergeInPlace(actions, derivedActions);\n\n  // ordino i path con segmenti comuni\n  actions = actions.sort((a1, a2) => U.stringCompare(a1.path, a2.path));\n\n  // destrutturo solo i nodi intermedi e solo la prima volta che li incontro (richiede le azioni ordinate in base al path)\n\n  for (let i = 0; i < actions.length; i++) {\n    const prevAction = actions[i - 1];\n    const action = actions[i];\n    const actiontype = action.type.indexOf('@@') === 0 ? 'redux' : action.type;\n    console.log('executing action:', {\n      a: action,\n      t: actiontype,\n      field: action.field,\n      v: action.value\n    }); //, count: ++action.executionCount});\n\n    switch (actiontype) {\n      /*\r\n      case '@@redux/INIT6.x.f.d.r.e':\r\n      case '@@redux/INITm.f.1.s.o.g':\r\n      case '@@redux/INIT5.t.4.v.d.o':\r\n      case '@@redux/INITy.a.d.r.l.a':\r\n      case '@@redux/INIT4.2.q.u.z.k':\r\n      case '@@redux/INITj.8.e.g.y.p':\r\n      case '@@redux/INITp.k.q.g.z.w':\r\n      case '@@redux/INITq.c.u.w.f.e': ... etc*/\n      default:\n        if (action.type.indexOf('@@redux/') === 0) break;\n        return Log.exDevv('unexpected action type:', action.type);\n      case LoadAction.type:\n        newState = action.value;\n        break;\n      case CreateElementAction.type:\n      case SetRootFieldAction.type:\n      case DeleteElementAction.type:\n      case SetFieldAction.type:\n        let tmp = deepCopyButOnlyFollowingPath(newState, action, prevAction, action.value);\n        if (!tmp) return oldState; // rollback due to invalid action in transaction\n        newState = tmp;\n        break;\n    }\n\n    // and that's all, the reducer is really simple as actions are really simple.\n  }\n\n  // effetti collaterali, aggiornamento di ridondanze\n  newState = updateRedundancies_OBSOLETE(newState, oldState, Action.possibleInconsistencies);\n  return newState;\n}\n_c = CompositeActionReducer;\nfunction updateRedundancies_OBSOLETE(state, oldState, possibleInconsistencies) {\n  for (let subType in possibleInconsistencies) switch (subType) {\n    default:\n      break;\n    case Action.SubType.vertexSubElements: /*\r\n                                           risolto triggrerando più azioni da LGraphElement setter\r\n                                           let dvertexid: Pointer, newdvertex: DGraphElement, olddvertex: DGraphElement;\r\n                                           for (newdvertex of possibleInconsistencies[subType] as DGraphElement[]){\r\n                                           const olddvertex: DGraphElement = oldState.idlookup[newdvertex.id] as DGraphElement;\r\n                                           const notContainedAnymoreOut: Pointer<DGraphElement> = [];\r\n                                           const newlyInsertedOut: Pointer<DGraphElement>[] = [];\r\n                                           U.arraySymmetricDifference(olddvertex.subElements, newdvertex.subElements, notContainedAnymoreOut, newlyInsertedOut);\r\n                                           for (let geid of notContainedAnymoreOut) {\r\n                                           const oldge = oldState.idlookup[geid] as DGraphElement;\r\n                                           const newge = state.idlookup[geid] as DGraphElement;\r\n                                           if (oldge.containedIn === newge.containedIn) continue;\r\n                                           }\r\n                                           for (let geid of notContainedAnymoreOut) {\r\n                                           const ge = idlookup[geid] as DGraphElement;\r\n                                           if (ge.containedIn === context.data.id) set container = context.data.id\r\n                                           meglio se sti 2 cicli li fai nel reducer perchè  potrebbe esserci una azione pending che setta il parent = someotherid e qui faccio partire una azione che setta il parent a null, \"annullando\" una azione pending non ancora eseguita\r\n                                           }\r\n                                           }\r\n                                           break;*/\n  }\n  // if state is updated shallow copy state before returning it\n  return state;\n}\nlet initialState = null;\nlet storeLoaded = false;\nconst UDRegexp = /(?:^|\\s|;|}|\\n|\\t|\\(|,)ret\\s*\\.\\s*[a-zA-Z_$][0-9a-zA-Z_$]*\\s*=/g;\n/* tested with:\r\nif (ret.key = stuff) ret.key2=morestuff;\r\n;ret.k=3;\r\n}ret. kk=3,ret. a = 3\r\n\r\nret .b = 3\r\n*/\n\n// then add to it: content of props, constants, usageDeclarations\n\nexport function reducer() {\n  let oldState = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : initialState;\n  let action = arguments.length > 1 ? arguments[1] : undefined;\n  try {\n    return unsafereducer(oldState, action);\n  } catch (e) {\n    console.error('unhandled error in reducer', {\n      oldState,\n      action\n    });\n    return oldState;\n  }\n}\nfunction unsafereducer() {\n  var _ret$VIEWS_RECOMPILE_, _ret$VIEWS_RECOMPILE_2, _ret$VIEWS_RECOMPILE_3, _ret$VIEWS_RECOMPILE_4, _ret$VIEWS_RECOMPILE_5;\n  let oldState = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : initialState;\n  let action = arguments.length > 1 ? arguments[1] : undefined;\n  const ret = _reducer(oldState, action);\n  if (ret === oldState) return oldState;\n  ret.idlookup.__proto__ = DPointerTargetable.pendingCreation;\n\n  // client synchronization stuff\n  if (oldState === null || oldState === void 0 ? void 0 : oldState.collaborativeSession) {\n    const ignoredFields = ['contextMenu', '_lastSelected', 'isLoading', 'collaborativeSession'];\n    /* Checking if CompositeAction has some actions that MUST be ignored */\n    let compositeAction = null;\n    if (action.type === CompositeAction.type) {\n      compositeAction = action;\n      const subActions = compositeAction.actions || [];\n      compositeAction.actions = subActions.filter(a => !ignoredFields.includes(a.field));\n    }\n    if (compositeAction && !compositeAction.actions.length) return ret;\n    action = compositeAction ? compositeAction : action;\n    if (action.sender === DUser.current && !ignoredFields.includes(action.field)) {\n      const parsedAction = JSON.parse(JSON.stringify(action));\n      Collaborative.client.emit('pushAction', parsedAction);\n    }\n  }\n  if (ret.VIEWS_RECOMPILE_all === true) ret.VIEWS_RECOMPILE_all = Object.keys(ret.idlookup);\n  if ((_ret$VIEWS_RECOMPILE_ = ret.VIEWS_RECOMPILE_all) === null || _ret$VIEWS_RECOMPILE_ === void 0 ? void 0 : _ret$VIEWS_RECOMPILE_.length) {\n    let resetAllNodes = false;\n    for (let id of new Set(ret.VIEWS_RECOMPILE_all)) {\n      let d = ret.idlookup[id];\n      if (RuntimeAccessibleClass.extends(d.className, \"DViewElement\")) {\n        d.css_MUST_RECOMPILE = true;\n        transientProperties.view[d.id] = {};\n        for (let k of DViewElement.MeasurableKeys) ret['VIEWS_RECOMPILE_' + k].push(d.id);\n        if (!resetAllNodes) resetAllNodes = true;\n      }\n      if (RuntimeAccessibleClass.extends(d.className, \"DModelElement\")) {\n        if (d.className === \"DClass\") {\n          var _oldState$idlookup$d$, _ret$idlookup$d$id;\n          let oldname = (_oldState$idlookup$d$ = oldState.idlookup[d.id]) === null || _oldState$idlookup$d$ === void 0 ? void 0 : _oldState$idlookup$d$.name;\n          let newname = (_ret$idlookup$d$id = ret.idlookup[d.id]) === null || _ret$idlookup$d$id === void 0 ? void 0 : _ret$idlookup$d$id.name;\n          if (oldname !== newname) ret.ClassNameChanged[d.id] = oldname;\n        }\n        // transientProperties.modelElement[d.id] = { } as any; stuff in here does not need replacement, can never be dangerous.\n      }\n\n      if (RuntimeAccessibleClass.extends(d.className, \"DGraphElement\")) {\n        transientProperties.node[d.id] = {};\n      }\n    }\n    if (resetAllNodes) for (let nid in transientProperties.node) transientProperties.node[nid] = {};\n  }\n\n  // local changes to out-of-redux stuff\n  if (ret.VIEWS_RECOMPILE_ocl.length) {\n    // for (let gid of ret.graphs) Selectors.updateViewMatchings(gid, ret.modelElements, Object.values(ret.idlookup).map( d => RuntimeAccessibleClass.extends(d, DModelElement.cname)));\n    // for (let vid of ret.VIEW_APPLIABLETO_NEEDS_RECALCULATION) { }\n    for (let vid of new Set(ret.VIEWS_RECOMPILE_ocl)) {\n      if (!transientProperties.view[vid]) transientProperties.view[vid] = {};\n      transientProperties.view[vid].oclEngine = undefined; // force re-parse\n      transientProperties.view[vid].oclChanged = true;\n      for (let nid in transientProperties.node) {\n        let tnv = transientProperties.node[nid].viewScores[vid];\n        if ((tnv === null || tnv === void 0 ? void 0 : tnv.OCLScore) !== ViewEClassMatch.NOT_EVALUATED_YET) tnv.OCLScore = ViewEClassMatch.NOT_EVALUATED_YET;\n      }\n    }\n    ret.VIEWS_RECOMPILE_ocl = [];\n  }\n  /*\r\n  if (ret.VIEWOCL_UPDATE_NEEDS_RECALCULATION.length) {\r\n      // not implemented for now\r\n      ret.VIEWOCL_UPDATE_NEEDS_RECALCULATION = [];\r\n  }*/\n\n  if (ret.VIEWS_RECOMPILE_preconditions.length) {\n    for (let vid of new Set(ret.VIEWS_RECOMPILE_preconditions)) {\n      for (let nid in transientProperties.node) {\n        let tnv = transientProperties.node[nid].viewScores[vid];\n        if ((tnv === null || tnv === void 0 ? void 0 : tnv.metaclassScore) !== ViewEClassMatch.NOT_EVALUATED_YET) tnv.metaclassScore = ViewEClassMatch.NOT_EVALUATED_YET;\n      }\n    }\n    ret.VIEWS_RECOMPILE_preconditions = [];\n  }\n  if ((_ret$VIEWS_RECOMPILE_2 = ret.VIEWS_RECOMPILE_constants) === null || _ret$VIEWS_RECOMPILE_2 === void 0 ? void 0 : _ret$VIEWS_RECOMPILE_2.length) for (const vid of new Set(ret.VIEWS_RECOMPILE_constants)) {\n    // compiled in func, and executed, result does not vary between nodes.\n    let dv = DPointerTargetable.fromPointer(vid, ret);\n    // transientProperties.view[vid].constantsList = dv.constants?.match(UDRegexp).map(s=>s.substring(4, s.length-1).trim()) || [];\n    // let allContextKeys = {...contextFixedKeys};\n    if (!dv.constants) {\n      if (!transientProperties.view[vid]) transientProperties.view[vid] = {};\n      transientProperties.view[vid].constants = {};\n      transientProperties.view[vid].constantsList = [];\n      // no need to recompile UD, jsx or measurables, they will have additional parameters in scope but they are undefined and cause no problems.\n      continue;\n    }\n    const constantsOutput = {};\n    const context = {\n      view: dv\n    }; // context at this point holds only static stuff, which are in gloval scope (window) plus view.\n    let paramStr = '{' + Object.keys(context).join(',') + '}, ret';\n    try {\n      // the scope of new Function() is \"window\" and not the function where is called, unlike eval();\n      let constantsFunction = new Function(paramStr, 'return (' + dv.constants + ')(ret)').bind(context);\n      constantsFunction(context, constantsOutput);\n    } catch (e) {\n      console.error('error constants parse', {\n        vid,\n        e,\n        paramStr,\n        body: 'return (' + dv.constants + ')(ret)'\n      });\n      // todo: how do i render an error from here? even if i set jsx or ud.__invalidDeclarations it will be recompiled. need a constants.__invalidDeclarations too?\n    }\n\n    transientProperties.view[vid].constants = constantsOutput;\n    transientProperties.view[vid].constantsList = Object.keys(transientProperties.view[vid].constants);\n    // implies recompilation of: jsCondition, ud, jsx and all measurable events\n    ret.VIEWS_RECOMPILE_jsCondition.push(vid);\n    ret.VIEWS_RECOMPILE_usageDeclarations.push(vid);\n    ret.VIEWS_RECOMPILE_jsxString.push(vid);\n    ret.VIEWS_RECOMPILE_events.push(vid);\n    for (let k of DViewElement.MeasurableKeys) ret['VIEWS_RECOMPILE_' + k].push(vid);\n  }\n  ret.VIEWS_RECOMPILE_constants = [];\n  if ((_ret$VIEWS_RECOMPILE_3 = ret.VIEWS_RECOMPILE_usageDeclarations) === null || _ret$VIEWS_RECOMPILE_3 === void 0 ? void 0 : _ret$VIEWS_RECOMPILE_3.length) for (const vid of new Set(ret.VIEWS_RECOMPILE_usageDeclarations)) {\n    var _dv$usageDeclarations;\n    // compiled in func, but NOT executed, result varies between nodes.\n    let dv = DPointerTargetable.fromPointer(vid, ret);\n    let tv = transientProperties.view[vid];\n    if (!tv) transientProperties.view[vid] = tv = {};\n    if (!dv.usageDeclarations) {\n      tv.UDList = [];\n      tv.UDFunction = undefined;\n      // no need to recompile jsx or measurables, they will have additional parameters in scope but they are undefined and cause no problems.\n      continue;\n    }\n    let matches = ((_dv$usageDeclarations = dv.usageDeclarations) === null || _dv$usageDeclarations === void 0 ? void 0 : _dv$usageDeclarations.match(UDRegexp)) || [];\n    transientProperties.view[vid].UDList = matches.map(s => {\n      s = s.trim();\n      return s.substring(s.indexOf('\\.') + 1, s.length - 2).trim();\n    });\n    console.log('matches', {\n      matches,\n      udlist: transientProperties.view[vid].UDList\n    });\n    // warning for user: do not redeclare ret in nested blocks.\n    // do not use ret[key] syntax.\n    // do not set nested values directly (ret.key.subkey syntax).\n    // do not use ret.key +=, -= or any other operator assignment different than \"=\"\n    // if that is ever required, do instead\n    // do not assign values to ret in block comments\n    // those restrictions only apply to the ret object, all those violations can be done on other objects.\n    // so the following is valid, and a way to overcome the previous limitations:\n    // let subobject = {}; subobject[key] += stuff; ret.somefixedname = subobject;\n\n    let allContextKeys = {\n      ...contextFixedKeys\n    };\n    for (let k of tv.constantsList) if (!allContextKeys[k]) allContextKeys[k] = true;\n    let paramStr = '{' + Object.keys(allContextKeys).join(',') + '}, ret';\n    if (vid.includes('Model')) console.log(\"modelparse, ud\", {\n      paramStr,\n      udstr: dv.usageDeclarations,\n      udlist: transientProperties.view[vid].UDList\n    });\n    try {\n      tv.UDFunction = new Function(paramStr, 'return (' + dv.usageDeclarations + ')(ret)');\n    } catch (e) {\n      let strerr = JSON.stringify(e); //(e.message || '').split('\\n')[0]);\n      let udErrors = windoww.udErrors;\n      if (!windoww.udErrors) windoww.udErrors = udErrors = {\n        maxi: 0\n      };\n      udErrors[\"e\" + ++udErrors.maxi] = e;\n      e.isSyntax = true;\n      let errbody = \"ret.__invalidUsageDeclarations = window.udErrors.e\" + udErrors.maxi + \"; return ret;\";\n      console.error('error udparse', {\n        vid,\n        e,\n        paramStr,\n        body: 'return (' + dv.usageDeclarations + ')(ret)',\n        strerr,\n        errbody\n      });\n      tv.UDFunction = new Function(\"ret\", errbody);\n    }\n\n    // implies recompilation of: jsx and all measurable events\n    ret.VIEWS_RECOMPILE_jsxString.push(vid);\n    ret.VIEWS_RECOMPILE_events.push(vid);\n    for (let k of DViewElement.MeasurableKeys) ret['VIEWS_RECOMPILE_' + k].push(vid);\n  }\n  ret.VIEWS_RECOMPILE_usageDeclarations = [];\n  if (ret.VIEWS_RECOMPILE_events.length) {\n    // for (let gid of ret.graphs) Selectors.updateViewMatchings(gid, ret.modelElements, Object.values(ret.idlookup).map( d => RuntimeAccessibleClass.extends(d, DModelElement.cname)));\n    // for (let vid of ret.VIEW_APPLIABLETO_NEEDS_RECALCULATION) { }\n    for (let entry of new Set(ret.VIEWS_RECOMPILE_events)) {\n      let vid;\n      let dv;\n      let keys;\n      if (typeof entry === \"object\") {\n        vid = entry.vid;\n        dv = DPointerTargetable.fromPointer(vid, ret);\n        keys = entry.keys || Object.keys(dv.events);\n      } else {\n        vid = entry;\n        dv = DPointerTargetable.fromPointer(vid, ret);\n        keys = Object.keys(dv.events);\n      }\n      let tv = transientProperties.view[vid];\n      if (!tv) transientProperties.view[vid] = tv = {};\n      if (!tv.events) tv.events = {};\n      // if (!tv.events_raw) tv.events_raw = {};\n      for (let key of keys) {\n        if (!key) {\n          delete tv.events[key];\n          continue;\n        }\n        let allContextKeys = {\n          ...contextFixedKeys\n        };\n        for (let k of transientProperties.view[vid].constantsList) if (!allContextKeys[k]) allContextKeys[k] = true;\n        for (let k of transientProperties.view[vid].UDList) if (!allContextKeys[k]) allContextKeys[k] = true;\n        let paramStr = '{' + Object.keys(allContextKeys).join(',') + '}, ..._params';\n        // dv.events[key] = (...params)=> code\n        const body = 'return (' + dv.events[key] + ')(..._params)';\n        // if (vid.includes('Model')) console.log(\"modelparse, jsx\", {paramStr, body});\n        try {\n          tv.events[key] = new Function(paramStr, body);\n          // tv.events_raw[key] = new Function(paramStr, body) as ((...a:any)=>any);\n          // attempt to auto obtain node context\n          // impossile with view.event.name\n          // could with node.event.name if node.get_event sets a current node thing__, no he must wrap the func!! in the getter\n          // tv.events[key] = (..._params2:any) => { return tv.events_raw[key](context, ..._params2) };\n        } catch (e) {\n          console.error('error jsxparse', {\n            vid,\n            e,\n            paramStr,\n            body\n          });\n          tv.events[key] = context => Log.ee(\"failed to parse function body: \" + e.message.split(\"\\n\")[0], e.message);\n        }\n      }\n    }\n    ret.VIEWS_RECOMPILE_events = [];\n    // triggers recompile of nothing\n  }\n\n  if ((_ret$VIEWS_RECOMPILE_4 = ret.VIEWS_RECOMPILE_jsCondition) === null || _ret$VIEWS_RECOMPILE_4 === void 0 ? void 0 : _ret$VIEWS_RECOMPILE_4.length) for (const vid of new Set(ret.VIEWS_RECOMPILE_jsCondition)) {\n    const dv = DPointerTargetable.fromPointer(vid, ret);\n    let tv = transientProperties.view[vid];\n    if (!tv) transientProperties.view[vid] = tv = {};\n    tv.jsConditionChanged = true;\n    if (!dv.jsCondition) {\n      tv.jsCondition = undefined;\n      continue;\n    }\n    const lines = dv.jsCondition.trim().split('\\n');\n    let lastLine = lines[lines.length - 1];\n    if (lastLine.indexOf('return') !== 0) lines[lines.length - 1] = `return (${lastLine})`;\n    if (!dv.jsxString) {\n      transientProperties.view[vid].JSXFunction = undefined;\n      continue;\n    }\n    let allContextKeys = {\n      ...contextFixedKeys\n    };\n    for (let k of transientProperties.view[vid].constantsList) if (!allContextKeys[k]) allContextKeys[k] = true;\n    let paramStr = '{' + Object.keys(allContextKeys).join(',') + '}';\n    const body = lines.join('\\n');\n    try {\n      tv.jsCondition = new Function(paramStr, body);\n    } catch (e) {\n      tv.jsCondition = undefined;\n      console.log('JS Condition parsed error', e);\n    }\n  }\n  ret.VIEWS_RECOMPILE_jsCondition = [];\n  if ((_ret$VIEWS_RECOMPILE_5 = ret.VIEWS_RECOMPILE_jsxString) === null || _ret$VIEWS_RECOMPILE_5 === void 0 ? void 0 : _ret$VIEWS_RECOMPILE_5.length) for (const vid of new Set(ret.VIEWS_RECOMPILE_jsxString)) {\n    // compiled in func, but NOT executed, result varies between nodes.\n    let dv = DPointerTargetable.fromPointer(vid, ret);\n    let tv = transientProperties.view[vid];\n    if (!tv) transientProperties.view[vid] = tv = {};\n    if (!dv.jsxString) {\n      transientProperties.view[vid].JSXFunction = undefined;\n      continue;\n    }\n    let allContextKeys = {\n      ...contextFixedKeys\n    };\n    for (let k of transientProperties.view[vid].constantsList) if (!allContextKeys[k]) allContextKeys[k] = true;\n    for (let k of transientProperties.view[vid].UDList) if (!allContextKeys[k]) allContextKeys[k] = true;\n    let paramStr = '{' + Object.keys(allContextKeys).join(',') + '}';\n    console.log('jsxparse', {\n      allContextKeys,\n      ud: transientProperties.view[vid].UDList,\n      c: transientProperties.view[vid].constantsList\n    });\n    const body = 'return (' + UX.parseAndInject(DSL.parser(dv.jsxString), dv) + ')';\n    // if (vid.includes('Model')) console.log(\"modelparse, jsx\", {paramStr, body});\n    console.log('jsxparse', {\n      vid,\n      paramStr,\n      body\n    });\n    try {\n      transientProperties.view[vid].JSXFunction = new Function(paramStr, body);\n    } catch (e) {\n      /*try{\r\n          let try_to_get_better_error = eval(\"let __f = function(\" + paramStr+\") {\\n\" + body + \"}\");\r\n      } catch(eeval){\r\n          console.error(\"eval error same as func error\", {e, eeval});\r\n          e = eeval;\r\n      }*/\n      console.error('error jsxparse', {\n        vid,\n        e,\n        paramStr,\n        body\n      });\n      transientProperties.view[vid].JSXFunction = context => GraphElementComponent.displayError(e, 'JSX Syntax', dv);\n    }\n    // implies recompilation of: ... nothing?\n  }\n\n  ret.VIEWS_RECOMPILE_jsxString = [];\n  for (const key of DViewElement.MeasurableKeys) {\n    var _ref;\n    if ((_ref = ret['VIEWS_RECOMPILE_' + key]) === null || _ref === void 0 ? void 0 : _ref.length) for (let vid of new Set(ret['VIEWS_RECOMPILE_' + key])) {\n      let dv = DPointerTargetable.fromPointer(vid, ret);\n      let tv = transientProperties.view[vid];\n      if (!tv) transientProperties.view[vid] = tv = {};\n      let str = dv[key];\n      if (!str) {\n        transientProperties.view[vid][key] = undefined;\n        continue;\n      }\n      let allContextKeys = {\n        ...contextFixedKeys\n      };\n      for (let k of transientProperties.view[vid].constantsList) if (!allContextKeys[k]) allContextKeys[k] = true;\n      for (let k of transientProperties.view[vid].UDList) if (!allContextKeys[k]) allContextKeys[k] = true;\n      let paramStr = '{' + Object.keys(allContextKeys).join(',') + '}';\n      console.log('measurable parse ' + key, {\n        allContextKeys,\n        ud: transientProperties.view[vid].UDList,\n        c: transientProperties.view[vid].constantsList\n      });\n      console.log('measurable parse ' + key, {\n        vid,\n        paramStr,\n        body: str\n      });\n      try {\n        transientProperties.view[vid][key] = new Function(paramStr, str);\n      } catch (e) {\n        console.error('error measurable parse ' + key, {\n          vid,\n          e,\n          paramStr,\n          body: str\n        });\n        transientProperties.view[vid][key] = undefined;\n        // display error in jsx\n        transientProperties.view[vid].JSXFunction = context => GraphElementComponent.displayError(e, 'Measurable ' + key + ' Syntax', dv);\n        break;\n      }\n    }\n    ret['VIEWS_RECOMPILE_' + key] = [];\n  }\n  for (let dataid in ret.ClassNameChanged) {\n    if (dataid === 'clonedCounter') continue;\n    // NB: if i ever want to access a constructor's other properties in ocl, like \"context Persona inv: self.$somecounter === Persona.instances.length\",\n    // i would need to update this every time a DClass property changes instead of only when name changes.\n\n    // if it's first creation of a modelpiece\n    if (!transientProperties.modelElement[dataid]) {\n      transientProperties.modelElement[dataid] = {\n        nodes: {}\n      };\n    }\n    // update ocl type names\n    let data = ret.idlookup[dataid];\n    RuntimeAccessibleClass.makeOCLConstructor(data, ret, oldState);\n    // here i should reset all tnv.oclEngine too and set all ocl scores to notevaluated, but it is too computationally heavy\n    // and it's useful to keep the old ocl condition valid with past names until manually edited.\n  }\n\n  ret.ClassNameChanged = {};\n  return ret;\n}\nexport function _reducer /*<S extends StateNoFunc, A extends Action>*/() {\n  let oldState = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : initialState;\n  let action = arguments.length > 1 ? arguments[1] : undefined;\n  let times;\n  let state;\n  let removedDeltas = [];\n  switch (action.type) {\n    case UndoAction.type:\n      times = action.value;\n      state = oldState;\n      Log.exDev(times <= 0, \"undo must be positive\", action);\n      while (times--) {\n        const delta = statehistory[DUser.current].undoable.pop();\n        removedDeltas.push(delta);\n        state = undo(state, delta);\n      }\n      state.VIEWS_RECOMPILE_all = removedDeltas.flatMap(d => Object.keys((d === null || d === void 0 ? void 0 : d.idlookup) || {}));\n      // state.VIEWS_RECOMPILE_all = true;\n      return state;\n    case RedoAction.type:\n      times = action.value;\n      state = oldState;\n      Log.exDev(times <= 0, \"redo must be positive\", action);\n      while (times--) {\n        const delta = statehistory[DUser.current].redoable.pop();\n        removedDeltas.push(delta);\n        state = undo(state, delta, false);\n      }\n      state.VIEWS_RECOMPILE_all = removedDeltas.flatMap(d => Object.keys((d === null || d === void 0 ? void 0 : d.idlookup) || {}));\n      // state.VIEWS_RECOMPILE_all = true;\n      return state;\n    // case CombineHistoryAction.type: return combineHistory(oldState); break;\n    // todo: se al posto di \"annullare l'undo\" memorizzo l'azione e la rieseguo, posso ripetere l'ultimo passo N volte e questa azione diventa utile per combinare passi e ripetere blocchi di azioni assieme\n    default:\n      let ret = doreducer(oldState, action);\n      if (ret === oldState) return ret;\n      // statehistory[DUser.current].redoable = [];   <-- Moved to stateInitializer()\n      let delta = U.objectDelta(ret, oldState);\n      if (!filterundoableactions(delta)) return ret;\n      // console.log(\"setting undoable action:\", {ret, oldState0:{...oldState}, oldState, delta});\n      if (oldState !== null) statehistory[DUser.current].undoable.push(delta);\n      return ret;\n  }\n}\nfunction filterundoableactions(delta) {\n  if (!statehistory.globalcanundostate) return false;\n  if (Object.keys(delta).length === 1) {\n    if (\"dragging\" in delta) return false;\n    if (\"_lastSelected\" in delta) return false;\n    if (\"contextMenu\" in delta) return false;\n  }\n  return true;\n}\nfunction undo(state, delta) {\n  let isundo = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n  if (!delta) return state;\n  let undonestate = {\n    ...state\n  };\n  //   controlla se vengono shallow-copied solo e tutti gli oggetti nested lungo la catena del percorso delle modifiche\n  //   es: root.a.b.c=3 + root.a.b.d=3 = 4+1 modifiche, 5 shallow copies including the root\n  undorecursive(delta, undonestate);\n  if (isundo) statehistory[DUser.current].redoable.push(U.objectDelta(undonestate, state)); // reverses from undo to redo and viceversa swapping arguments, so the target result after appliying the delta changes\n  else statehistory[DUser.current].undoable.push(U.objectDelta(undonestate, state)); // redo is \"undoing an undo\", reversing his changes just like an undo reverses an ordinary action changes.\n  return undonestate;\n}\nfunction undorecursive(deltalevel, statelevel) {\n  // statelevel = {...statelevel}; not working if i do it here, just a new var. first time copy id done in caller func undo(). recursive copies are done before recursive step\n  for (let key in deltalevel) {\n    let delta = deltalevel[key];\n    console.log(\"undoing\", {\n      delta,\n      key,\n      deltalevel,\n      statelevel\n    });\n    if (key.indexOf(\"_-\") === 0) {\n      delete statelevel[key.substring(2)];\n      continue;\n    }\n    if (typeof delta === \"object\") {\n      // if (U.isObject(delta, false, false, true)) {\n      statelevel[key] = {\n        ...statelevel[key]\n      };\n      undorecursive(deltalevel[key], statelevel[key]);\n    } else {\n      statelevel[key] = delta;\n    }\n  }\n}\nfunction doreducer /*<S extends StateNoFunc, A extends Action>*/() {\n  let oldState = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : initialState;\n  let action = arguments.length > 1 ? arguments[1] : undefined;\n  if (!oldState) {\n    oldState = initialState = DState.new();\n  }\n  let ca;\n  // console.log('external REDUCER', {action, CEtype:CreateElementAction.type});\n  if (!storeLoaded) {\n    // new SetRootFieldAction('forceinit', true);\n    storeLoaded = true;\n  }\n  if (!oldState.forceinit) {\n    // afterStoreLoad();\n    // new SetRootFieldAction('forceinit', true);\n  } //  setTimeout(afterStoreLoad, 1);\n  switch (action.type) {\n    case CompositeAction.type:\n      ca = action;\n      break;\n    case LoadAction.type:\n    default:\n      if (action.type.indexOf('@@redux/') === 0) {\n        //storeLoaded = true;\n        return oldState;\n      }\n      ca = new CompositeAction([action], false);\n      break;\n  }\n  let ret = CompositeActionReducer(oldState, ca);\n  /*if (state.current !== ret) {\r\n      state.current = ret;\r\n      state.past.push(ret);\r\n  }*/\n  return ret;\n}\nfunction setSubclasses(roots) {\n  RuntimeAccessibleClass.extendMatrix = new SimpleTree(roots, \"subclasses\").getiIsSubElementMatrix(\"cname\");\n  /*\r\n  let tree = new TreeModel({\r\n      childrenPropertyName: \"subclasses\"\r\n  });\r\n  for (let key in dict){\r\n      let constructor = dict[key];\r\n      if(!constructor.hasOwnProperty(\"subclasses\")) constructor.subclasses = [];\r\n  }\r\n  RuntimeAccessibleClass.extendTree = (tree as any).safe_parse(RuntimeAccessibleClass);*/\n}\n// windoww.TreeModel = TreeModel;\nfunction buildLSingletons(alld, alll) {\n  for (let dname in alld) {\n    switch (dname) {\n      case \"DeleteElementAction\":\n        continue;\n      case \"DV\":\n        continue;\n      case \"Debug\":\n        continue;\n      default:\n        break;\n    }\n    if ((dname[1] || \"\").toLowerCase() === dname[1]) continue; // if second letter is lowercase, it's not a \"D\" class\n    let tagless = dname.substring(1);\n    let d = alld[dname];\n    let l = alll['L' + tagless];\n    if (!d || !l) console.error(\"missing d constructor\", {\n      d,\n      l\n    });\n    d.logic = l;\n    if (!l) console.error('init() could not find L-class during mapping', l, d);\n    // @ts-ignore\n    d.singleton = new l('dwc');\n    d.structure = d;\n    l.logic = d.logic;\n    l.singleton = d.singleton;\n    l.structure = d.structure;\n\n    // if (!d.subclasses) d.subclasses = [];\n    // @ts-ignore\n    // for (let sc of d.subclasses) { if (!sc[\"_extends\"]) sc[\"_extends\"] = [];  sc[\"_extends\"].push(d); }\n  }\n}\n\nexport async function stateInitializer() {\n  statehistory[DUser.current] = {\n    redoable: [],\n    undoable: []\n  };\n  RuntimeAccessibleClass.fixStatics();\n  let dClassesMap = {};\n  let lClassesMap = {};\n  for (let name in RuntimeAccessibleClass.classes) {\n    switch (name[0]) {\n      default:\n        break;\n      case \"D\":\n        dClassesMap[name] = RuntimeAccessibleClass.classes[name];\n        break;\n      case \"L\":\n        lClassesMap[name] = RuntimeAccessibleClass.classes[name];\n        break;\n    }\n  }\n  /*\r\n  let dClasses: string[] = RuntimeAccessibleClass.getAllNames().filter(rc => rc[0] === 'D');\r\n  let lClasses: string[] = RuntimeAccessibleClass.getAllNames().filter(rc => rc[0] === 'L');\r\n  let dClassesMap: Dictionary<string, typeof DPointerTargetable> =\r\n      dClasses.reduce((acc: GObject, curr) => {acc[curr] = RuntimeAccessibleClass.get(curr); return acc}, {});\r\n  let lClassesMap: Dictionary<string, typeof LPointerTargetable> =\r\n      lClasses.reduce((acc: GObject, curr) => {acc[curr] = RuntimeAccessibleClass.get(curr); return acc}, {}); */\n\n  buildLSingletons(dClassesMap, lClassesMap);\n  setSubclasses(RuntimeAccessibleClass.get(\"DPointerTargetable\")); // setSubclasses(lClassesMap);\n  windoww.defaultContext = {\n    $: windoww.$,\n    getPath,\n    React: React,\n    Selectors,\n    ...RuntimeAccessibleClass.getAllClassesDictionary(),\n    ...windoww.Components\n  };\n  // global document events\n\n  // do not use typings or class constructors here or it will change import order\n  setTimeout(() => $(document).on(\"mouseup\", e => RuntimeAccessibleClass.get(\"GraphDragManager\").stopPanning(e)),\n  // ()=> $(document).on(\"mouseup\", (e: MouseUpEvent) => (window as any).GraphDragManager.stopPanning(e)), //a\n  1);\n  DState.init();\n  const user = Storage.read('user');\n  if (!user) return;\n  DUser.new(user.username, user.id);\n  DUser.current = user.id;\n  await ProjectsApi.getAll();\n}\nvar _c;\n$RefreshReg$(_c, \"CompositeActionReducer\");","map":{"version":3,"names":["DViewElement","UX","GraphElementComponent","ViewEClassMatch","Action","CompositeAction","CreateElementAction","DeleteElementAction","DPointerTargetable","DState","DUser","getPath","Log","MyError","PendingPointedByPaths","PointedBy","Pointers","RuntimeAccessibleClass","SetFieldAction","SetRootFieldAction","statehistory","React","LoadAction","RedoAction","UndoAction","Collaborative","SimpleTree","transientProperties","Selectors","contextFixedKeys","Storage","ProjectsApi","DSL","windoww","window","U","deepCopyButOnlyFollowingPath","oldStateDoNotModify","action","prevAction","newVal","_action$path","newRoot","current","path","length","gotChanged","alreadyPastDivergencePoint","i","pathArray","key","trim","prevActionPathKey","Array","isArray","clonedCounter","isArrayAppend","isArrayRemove","isObjectMerge","isObjectDifference","oldValue","endsWith","substr","replaceAll","type","ee","preexistingValue","isShallowEqual","value","tmp","subkey","isPointer","add","push","index","isNumber","undefined","indexOf","removedval","splice","remove","oldpointerdestinations","newpointerdestinations","difference","arrayDifference","rem","removed","added","exDevv","CompositeActionReducer","oldState","actionBatch","actions","parse","all","getSolveableActions","possibleInconsistencies","derivedActions","newState","elem","pendingCreation","id","className","constructor","cname","name","statefoldername","substring","toLowerCase","create","pointedBy","new","arrayMergeInPlace","sort","a1","a2","stringCompare","actiontype","console","log","a","t","field","v","updateRedundancies_OBSOLETE","_c","state","subType","SubType","vertexSubElements","initialState","storeLoaded","UDRegexp","reducer","arguments","unsafereducer","e","error","_ret$VIEWS_RECOMPILE_","_ret$VIEWS_RECOMPILE_2","_ret$VIEWS_RECOMPILE_3","_ret$VIEWS_RECOMPILE_4","_ret$VIEWS_RECOMPILE_5","ret","_reducer","idlookup","__proto__","collaborativeSession","ignoredFields","compositeAction","subActions","filter","includes","sender","parsedAction","JSON","stringify","client","emit","VIEWS_RECOMPILE_all","Object","keys","resetAllNodes","Set","d","extends","css_MUST_RECOMPILE","view","k","MeasurableKeys","_oldState$idlookup$d$","_ret$idlookup$d$id","oldname","newname","ClassNameChanged","node","nid","VIEWS_RECOMPILE_ocl","vid","oclEngine","oclChanged","tnv","viewScores","OCLScore","NOT_EVALUATED_YET","VIEWS_RECOMPILE_preconditions","metaclassScore","VIEWS_RECOMPILE_constants","dv","fromPointer","constants","constantsList","constantsOutput","context","paramStr","join","constantsFunction","Function","bind","body","VIEWS_RECOMPILE_jsCondition","VIEWS_RECOMPILE_usageDeclarations","VIEWS_RECOMPILE_jsxString","VIEWS_RECOMPILE_events","_dv$usageDeclarations","tv","usageDeclarations","UDList","UDFunction","matches","match","map","s","udlist","allContextKeys","udstr","strerr","udErrors","maxi","isSyntax","errbody","entry","events","message","split","jsConditionChanged","jsCondition","lines","lastLine","jsxString","JSXFunction","ud","c","parseAndInject","parser","displayError","_ref","str","dataid","modelElement","nodes","data","makeOCLConstructor","times","removedDeltas","exDev","delta","undoable","pop","undo","flatMap","redoable","doreducer","objectDelta","filterundoableactions","globalcanundostate","isundo","undonestate","undorecursive","deltalevel","statelevel","ca","forceinit","setSubclasses","roots","extendMatrix","getiIsSubElementMatrix","buildLSingletons","alld","alll","dname","tagless","l","logic","singleton","structure","stateInitializer","fixStatics","dClassesMap","lClassesMap","classes","get","defaultContext","$","getAllClassesDictionary","Components","setTimeout","document","on","stopPanning","init","user","read","username","getAll","$RefreshReg$"],"sources":["C:/d/Programming/web/jodel-mde/src/redux/reducer/reducer.ts"],"sourcesContent":["import {\r\n    U as UType,\r\n    GraphDragManager,\r\n    MouseUpEvent,\r\n    orArr,\r\n    DModelElement,\r\n    DViewElement,\r\n    DClass,\r\n    DModel,\r\n    UX, EdgeOwnProps, EdgeStateProps, GraphElementComponent, ViewEClassMatch, bool\r\n} from '../../joiner';\r\nimport {\r\n    Action,\r\n    CompositeAction,\r\n    CreateElementAction,\r\n    DeleteElementAction,\r\n    Dictionary,\r\n    DocString,\r\n    DPointerTargetable,\r\n    DState,\r\n    DUser,\r\n    getPath,\r\n    GObject,\r\n    Log,\r\n    LPointerTargetable,\r\n    MyError,\r\n    ParsedAction,\r\n    PendingPointedByPaths,\r\n    PointedBy,\r\n    Pointer,\r\n    Pointers,\r\n    RuntimeAccessibleClass,\r\n    SetFieldAction,\r\n    SetRootFieldAction,\r\n    statehistory\r\n} from \"../../joiner\";\r\nimport React from \"react\";\r\nimport {LoadAction, RedoAction, UndoAction} from \"../action/action\";\r\nimport Collaborative from \"../../components/collaborative/Collaborative\";\r\nimport {SimpleTree} from \"../../common/SimpleTree\";\r\nimport {transientProperties, Selectors} from \"../../joiner\";\r\nimport {OclEngine} from \"@stekoe/ocl.js\";\r\nimport { contextFixedKeys } from '../../graph/graphElement/sharedTypes/sharedTypes';\r\nimport Storage from \"../../data/storage\";\r\nimport {ProjectsApi} from \"../../api/persistance\";\r\nimport DSL from \"../../DSL/DSL\";\r\n\r\nlet windoww = window as any;\r\nlet U: typeof UType = windoww.U;\r\n\r\n\r\nfunction deepCopyButOnlyFollowingPath(oldStateDoNotModify: DState, action: ParsedAction, prevAction: ParsedAction, newVal: any): DState | false{\r\n    let newRoot: DState = {...oldStateDoNotModify} as DState;\r\n    let current: any = newRoot;\r\n    if (!action.path?.length) throw new MyError(\"path length must be at least 1\", {action});\r\n    let gotChanged: boolean = false; // dovrebbe cambiare sempre, se non cambia non lancio neanche l'azione e non faccio la shallow copy, ma non si sa mai, così posso evitare un render se succede l' \"insuccedibile\"\r\n    let alreadyPastDivergencePoint = false; // true dal momento in cui il path dell'azione attuale e della azione precedente divergono, false fino al sotto-segmento in cui combaciano\r\n    // console.log('deepCopyButOnlyFollowingPath', arguments);\r\n    for (let i = 0; i < action.pathArray.length; i++) {\r\n        let key = action.pathArray[i].trim();\r\n        let prevActionPathKey = prevAction?.pathArray[i];\r\n        // middle execution: not on final loop\r\n        // console.log('deepCopyButOnlyFollowingPath', {current, i, imax:action.pathArray.length, key, gotChanged, alreadyPastDivergencePoint});\r\n        if (i !== action.pathArray.length - 1) {\r\n            if (alreadyPastDivergencePoint || key !== prevActionPathKey) {\r\n                // se l'oggetto è stato già duplicato in una azione composita, non lo duplico 2 volte.\r\n                alreadyPastDivergencePoint = true;\r\n                current[key] = Array.isArray(current[key]) ? [...current[key]] : {...current[key]};\r\n                current[key].clonedCounter = 1 + (current[key].clonedCounter || 0);\r\n            }\r\n            current = current[key];\r\n            continue;\r\n        }\r\n        // Giordano: added this on 03/12/2023 to prevent \"Cannot read properties of undefined\".\r\n        // if(!current) continue; damiano: temp removed to check if there are invalid actions firing\r\n        // perform final assignment\r\n        if (i >= action.pathArray.length - 1) {\r\n            let isArrayAppend = false;\r\n            let isArrayRemove = false;\r\n            let isObjectMerge = false;\r\n            let isObjectDifference = false;\r\n            // console.log('isarrayappend?', {endswith: U.endsWith(key, ['+=', '[]', '-1']), key, action, i});\r\n            // console.log('isarraydelete?', {endswith: U.endsWith(key, ['-='])});\r\n\r\n            let oldValue: any;\r\n            if (U.endsWith(key, ['+=', '[]'])) {\r\n                key = key.substr(0, key.length - 2).trim();\r\n                oldValue = current[key];\r\n                switch (typeof oldValue){\r\n                    case 'object':\r\n                    if (Array.isArray(oldValue)) isArrayAppend = true;\r\n                    else isObjectMerge = true;\r\n                    break;\r\n                    default: newVal += oldValue; break;\r\n                }\r\n            }\r\n            if (U.endsWith(key, ['-='])) {\r\n                key = key.substr(0, key.length - 2).trim();\r\n                oldValue = current[key];\r\n                switch (typeof oldValue){\r\n                    case 'object':\r\n                        if (Array.isArray(oldValue)) isArrayRemove = true;\r\n                        else isObjectDifference = true;\r\n                        break;\r\n                    case \"string\":\r\n                        newVal = U.replaceAll(oldValue, newVal, '');\r\n                        break;\r\n                    default: newVal -= oldValue; break;\r\n                }\r\n                isArrayRemove = true; }\r\n\r\n            // let unpointedElement: DPointerTargetable | undefined;\r\n            // perform final assignment\r\n            if (action.type === CreateElementAction.type && current[key]) {\r\n                oldValue = current[key];\r\n                gotChanged = false;\r\n                Log.ee(\"rejected CreateElementAction, rollback occurring:\", {action,\r\n                    preexistingValue: current[key], isShallowEqual: current[key] === action.value });\r\n                return false; // warning: use return only when you want to abort and skip subsequent CompositeAction sub-actions like now.\r\n            }\r\n            if (isObjectMerge) {\r\n                if (typeof newVal === 'string') { let tmp: any = {}; tmp[newVal] = true; newVal = tmp; }\r\n                oldValue = {...current[key]};\r\n                current[key] = {...current[key]};\r\n                for (let subkey in newVal) {\r\n                    // console.warn(\"object merge\", {current, key, subkey, newVal, old:current[key][subkey], new:newVal[subkey]});\r\n                    if (current[key][subkey] === newVal[subkey]) continue;\r\n                    current[key][subkey] = newVal[subkey];\r\n                    gotChanged = true;\r\n                    if (action.isPointer) { newRoot = PointedBy.add(key as Pointer, action, newRoot, \"+=\"); }\r\n                }\r\n            } else\r\n            if (isObjectDifference) {\r\n                if (typeof newVal === 'string') { let tmp: any = {}; tmp[newVal] = true; newVal = tmp; }\r\n                oldValue = {...current[key]};\r\n                current[key] = {...current[key]};\r\n                for (let subkey in newVal) {\r\n                    if (!(subkey in current[key])) continue;\r\n                    delete current[key][subkey];\r\n                    gotChanged = true;\r\n                    if (action.isPointer) { newRoot = PointedBy.add(key as Pointer, action, newRoot, \"-=\"); }\r\n                }\r\n            } else\r\n            if (isArrayAppend) {\r\n                gotChanged = true;\r\n                if (!Array.isArray(current[key])) { current[key] = []; }\r\n                oldValue = [...current[key]];\r\n                current[key] = [...current[key]];\r\n                current[key].push(newVal);\r\n                // unpointedElement = undefined;\r\n                if (action.isPointer) { newRoot = PointedBy.add(newVal as Pointer, action, newRoot, \"+=\"); }\r\n            } else\r\n            if (isArrayRemove) {\r\n                if (!Array.isArray(current[key])) { current[key] = []; }\r\n                oldValue = [...current[key]];\r\n                let index: number;\r\n                if (U.isNumber(newVal)) { // delete by index\r\n                    index = newVal;\r\n                    if (index < 0) index = oldValue.length + index; // if index is -2, i remove the penultimate element\r\n                } else\r\n                if (newVal === undefined) {\r\n                    index = oldValue.length - 1;\r\n                }\r\n                else {\r\n                    index = oldValue.indexOf(newVal);\r\n                }\r\n                // if it's negatively or positively out of boundary, i skip it\r\n                gotChanged = index >= 0 && index < current[key].length;\r\n                if (gotChanged) {\r\n                    current[key] = [...current[key]];\r\n                    let removedval = current[key].splice(index, 1); // in-place edit\r\n                    if (action.isPointer) { newRoot = PointedBy.remove(removedval as Pointer, action, newRoot, '-='); }\r\n                    /*\r\n                    fixed problem: se ho [dobj1, dobj2]... e li swappo, cambia un indice nel percorso \"pointedby\" e non me ne accorgo mai e un oggetto risulta \"pointedby\" da oggetti che non lo puntano o non esistono più a quell'indice\r\n                    SOLVED! by not including index in pointedBy path, but making it like \"parentObject.arrayKey+=\" instead of \"parentObject.arrayKey.4\"\r\n                    and knowing it's in the array it's enough info.\r\n\r\n                    // a.pointsto = [x, y, z]; a.pointsto = [x, z]       --->    remove a from y.pointedby\r\n                    const elementsThatChangedIndex: DPointerTargetable[] = current[key].slice(index);\r\n\r\n                    for (let j = 0; j < elementsThatChangedIndex.length; j++) {\r\n                        let newindex = index + j - 1;\r\n                        let oldFullpathTrimmed = action.pathArray.join('.');\r\n                        se realizzi \"pointedby\" qui è to do: remove old paths and re-add them with updated index\r\n                    }\r\n                    unpointedElement = newRoot.idlookup[oldValue];\r\n                    */\r\n                }\r\n            } else\r\n            if ((action.type === DeleteElementAction.type && !(key in current)) || current[key] === newVal) {\r\n                // value not changed\r\n                gotChanged = false;\r\n            } else {\r\n                // value changed\r\n                // todo: caso in cui setto manualmente classes.1 = pointer;\r\n                //  the latest element is array and not DPointerTargetable, so might need to buffer upper level in the tree? or instead of \"current\" keep an array of sub-objects encountered navigating the path in state.\r\n                oldValue = current[key];\r\n                gotChanged = true;\r\n                // unpointedElement = newRoot.idlookup[oldValue];\r\n                // NB: se elimino un oggetto che contiene array di puntatori, o resetto l'array di puntatori kinda like store.arr= [ptr1, ptr2, ...]; store.arr = [];\r\n                // i puntati dall'array hanno i loro pointedBY non aggiornati, non voglio fare un deep check di tutto l'oggetto a cercare puntatori per efficienza.\r\n                // if (newVal === undefined) delete current[key];\r\n                if ((newVal === undefined) || false && action.type === DeleteElementAction.type) delete current[key];\r\n                else current[key] = newVal;\r\n\r\n                // update pointedBy's\r\n                // NB: even if the current action have isPointer=true, it doesn't mean the old value is a pointer as well for sure. so need to check old values.\r\n                // also what if old val is pointer, and new one isn't? will it be just removed without updating pointedBy's?\r\n                // already fixed: might need to evaluate this if block always regardless of action.isPointer,\r\n                // and do checks every time both on old and new value if they actually are ptrs.\r\n                if (true || action.isPointer) {\r\n                    let oldpointerdestinations: unknown[];\r\n                    let newpointerdestinations: unknown[];\r\n                    if (Array.isArray(newVal)) {\r\n                        newpointerdestinations = newVal;\r\n                        if (Array.isArray(oldValue)) { // case: path.array = array;\r\n                            oldpointerdestinations = oldValue;\r\n                        }\r\n                        else { // case: path.object = array; + case: path.value = array;\r\n                            oldpointerdestinations = [oldValue];\r\n                        }\r\n                    }\r\n                    else {\r\n                        // case: path.array = object; + case: path.array = value;\r\n                        newpointerdestinations = [newVal];\r\n                        if (Array.isArray(oldValue)) {\r\n                            oldpointerdestinations = oldValue;\r\n                        } else {\r\n                            // case: path.object = object; and all other cases without arrays involved\r\n                            oldpointerdestinations = [oldValue];\r\n                        }\r\n                    }\r\n                    // after i mapped all cases to path.array = array; i solve it for that case.\r\n                    let difference = U.arrayDifference(oldpointerdestinations, newpointerdestinations); // : {added: Pointer[], removed: Pointer[], starting: Pointer[], final: Pointer[]}\r\n                    for (let rem of difference.removed) {if (Pointers.isPointer(rem))\r\n                        newRoot = PointedBy.remove(rem, action, newRoot, undefined, oldStateDoNotModify); }\r\n                    for (let add of difference.added) { if (Pointers.isPointer(add))\r\n                        newRoot = PointedBy.add(add, action, newRoot, undefined, oldStateDoNotModify); }\r\n                    // a.pointsto = [a, b, c];  a.pointsto = [a, b, x];    ------>     c.pointedby.remove(a) & x.pointedby.add(a)\r\n                    // idlookup.somelongid.pointsto = [...b];\r\n                }\r\n            }\r\n            break;\r\n        }\r\n        Log.exDevv('should not reach here: reducer');\r\n    }\r\n    return gotChanged ? newRoot : oldStateDoNotModify;\r\n}\r\n\r\n\r\n// const pendingPointedByPaths: {from: DocString<\"Path in store\">, field: DocString<\"keyof object found in from path\">, to: Pointer}[] = [];\r\nfunction CompositeActionReducer(oldState: DState, actionBatch: CompositeAction): DState {\r\n    // per via di thunk se arrivo qui lo stato cambia sicuro in mono-client non synchro (non ri-assegno valori equivalenti)\r\n    // todo: ma se arrivano in ordine sbagliato da altri client? posso permetterlo?\r\n    let actions: ParsedAction[];\r\n    if (actionBatch.actions) actions = Action.parse(actionBatch.actions);\r\n    else actions = [Action.parse(actionBatch)]; // else-case is if it's a single action and not an actual compositeaction\r\n    if (PendingPointedByPaths.all.length) actions.push(...PendingPointedByPaths.getSolveableActions(oldState)); //.all.map( p=> p.resolve() ) );\r\n\r\n    Action.possibleInconsistencies = {};\r\n\r\n    // estraggo le azioni derivate\r\n    let derivedActions: ParsedAction[] = [];\r\n    let newState = oldState;\r\n    for (let action of actions) {\r\n        switch (action.type){\r\n            default: break;\r\n            case CreateElementAction.type:\r\n                const elem: DPointerTargetable = action.value;\r\n                delete DPointerTargetable.pendingCreation[elem.id];\r\n                /*\r\n                if (oldState.idlookup[elem.id]) {\r\n                    Log.ee(\"rejected CreateElementAction, rollback occurring:\", {action, elem:{...elem},\r\n                        preexistingValue: {...oldState.idlookup[elem.id]}, isEqual: elem === oldState.idlookup[elem.id] });\r\n                    return oldState; // warning: use return only when you want to abort and skip subsequent CompositeAction sub-actions like now.\r\n\r\n                    action.value = \"An element with that id already existed.\";\r\n                    action.path = action.field = \"CreateActionRejected\";\r\n                    action.className = SetRootFieldAction.name;\r\n                    action.type = SetRootFieldAction.type;\r\n                    action.pathArray = [action.path]; //a\r\n                    action.isPointer = false;\r\n                    // just to log it in undo-redo action list and have a feedback\r\n                    return oldState;}*/\r\n\r\n                elem.className = elem.className || (elem.constructor as typeof RuntimeAccessibleClass).cname || elem.constructor.name;\r\n                let statefoldername = elem.className.substring(1).toLowerCase() + 's';\r\n                derivedActions.push(\r\n                    Action.parse(SetRootFieldAction.create(statefoldername, elem.id,'[]', true)));\r\n                if (!Array.isArray(elem.pointedBy)) elem.pointedBy = [];\r\n                elem.pointedBy.push(PointedBy.new(statefoldername));\r\n                /*if (false && action.isPointer) {\r\n                    if (Array.isArray(action.value)) {\r\n                        const ptr: Pointer[] = action.value;\r\n                        // todo but replaced by side actions in execution of the main action instead of triggering derived actions\r\n                    }\r\n                    else {\r\n                        const ptr: Pointer = action.value;\r\n                        const target: DPointerTargetable | null = oldState.idlookup[ptr];\r\n                        let pendingPointedBy = PendingPointedByPaths.new(action, oldState);\r\n                        if (!target) PendingPointedByPaths.new(action, oldState).saveForLater(); // {from: action.path, field: action.field, to: target});\r\n                        // @ts-ignore\r\n                        else derivedActions.push(pendingPointedBy.resolve());\r\n                        // a -> x\r\n                        // a -> y     unset x.pointedby(a)\r\n                    }\r\n                }*/\r\n                break;\r\n        }\r\n    }\r\n    // console.error({U, Umip:U.arrayMergeInPlace, WU: windoww.U, WUmip: windoww.U.arrayMergeInPlace});\r\n    actions = U.arrayMergeInPlace<ParsedAction>(actions, derivedActions);\r\n\r\n    // ordino i path con segmenti comuni\r\n    actions = actions.sort( (a1, a2) => U.stringCompare(a1.path, a2.path));\r\n\r\n    // destrutturo solo i nodi intermedi e solo la prima volta che li incontro (richiede le azioni ordinate in base al path)\r\n\r\n    for (let i = 0; i < actions.length; i++) {\r\n        const prevAction: ParsedAction = actions[i-1];\r\n        const action: ParsedAction = actions[i];\r\n        const actiontype = action.type.indexOf('@@') === 0 ? 'redux' : action.type;\r\n        console.log('executing action:', {a:action, t:actiontype, field: action.field, v:action.value}); //, count: ++action.executionCount});\r\n\r\n        switch (actiontype) {\r\n            /*\r\n            case '@@redux/INIT6.x.f.d.r.e':\r\n            case '@@redux/INITm.f.1.s.o.g':\r\n            case '@@redux/INIT5.t.4.v.d.o':\r\n            case '@@redux/INITy.a.d.r.l.a':\r\n            case '@@redux/INIT4.2.q.u.z.k':\r\n            case '@@redux/INITj.8.e.g.y.p':\r\n            case '@@redux/INITp.k.q.g.z.w':\r\n            case '@@redux/INITq.c.u.w.f.e': ... etc*/\r\n            default:\r\n                if (action.type.indexOf('@@redux/') === 0) break;\r\n                return Log.exDevv('unexpected action type:', action.type);\r\n            case LoadAction.type: newState = action.value; break;\r\n            case CreateElementAction.type:\r\n            case SetRootFieldAction.type:\r\n            case DeleteElementAction.type:\r\n            case SetFieldAction.type:\r\n                let tmp: false | DState = deepCopyButOnlyFollowingPath(newState, action, prevAction, action.value);\r\n                if (!tmp) return oldState; // rollback due to invalid action in transaction\r\n                newState = tmp;\r\n                break;\r\n        }\r\n\r\n        // and that's all, the reducer is really simple as actions are really simple.\r\n    }\r\n\r\n    // effetti collaterali, aggiornamento di ridondanze\r\n    newState = updateRedundancies_OBSOLETE(newState, oldState, Action.possibleInconsistencies);\r\n    return newState;\r\n}\r\n\r\nfunction updateRedundancies_OBSOLETE(state: DState, oldState:DState, possibleInconsistencies: Dictionary<DocString<'subtype'>, (Pointer | DPointerTargetable)[]>): DState {\r\n    for (let subType in possibleInconsistencies)\r\n    switch (subType) {\r\n        default: break;\r\n        case Action.SubType.vertexSubElements:/*\r\n            risolto triggrerando più azioni da LGraphElement setter\r\n            let dvertexid: Pointer, newdvertex: DGraphElement, olddvertex: DGraphElement;\r\n            for (newdvertex of possibleInconsistencies[subType] as DGraphElement[]){\r\n                const olddvertex: DGraphElement = oldState.idlookup[newdvertex.id] as DGraphElement;\r\n                const notContainedAnymoreOut: Pointer<DGraphElement> = [];\r\n                const newlyInsertedOut: Pointer<DGraphElement>[] = [];\r\n                U.arraySymmetricDifference(olddvertex.subElements, newdvertex.subElements, notContainedAnymoreOut, newlyInsertedOut);\r\n                for (let geid of notContainedAnymoreOut) {\r\n                    const oldge = oldState.idlookup[geid] as DGraphElement;\r\n                    const newge = state.idlookup[geid] as DGraphElement;\r\n                    if (oldge.containedIn === newge.containedIn) continue;\r\n                }\r\n                for (let geid of notContainedAnymoreOut) {\r\n                    const ge = idlookup[geid] as DGraphElement;\r\n                    if (ge.containedIn === context.data.id) set container = context.data.id\r\n                    meglio se sti 2 cicli li fai nel reducer perchè  potrebbe esserci una azione pending che setta il parent = someotherid e qui faccio partire una azione che setta il parent a null, \"annullando\" una azione pending non ancora eseguita\r\n                }\r\n            }\r\n            break;*/\r\n    }\r\n    // if state is updated shallow copy state before returning it\r\n    return state;\r\n}\r\n\r\nlet initialState: DState = null as any;\r\nlet storeLoaded: boolean = false;\r\n\r\nconst UDRegexp = /(?:^|\\s|;|}|\\n|\\t|\\(|,)ret\\s*\\.\\s*[a-zA-Z_$][0-9a-zA-Z_$]*\\s*=/g;\r\n/* tested with:\r\nif (ret.key = stuff) ret.key2=morestuff;\r\n;ret.k=3;\r\n}ret. kk=3,ret. a = 3\r\n\r\nret .b = 3\r\n*/\r\n\r\n\r\n// then add to it: content of props, constants, usageDeclarations\r\n\r\nexport function reducer(oldState: DState = initialState, action: Action): DState {\r\n    try{ return unsafereducer(oldState, action); }\r\n    catch(e) {\r\n        console.error('unhandled error in reducer', {oldState, action});\r\n        return oldState;\r\n    }\r\n}\r\n\r\nfunction unsafereducer(oldState: DState = initialState, action: Action): DState {\r\n    const ret = _reducer(oldState, action);\r\n    if (ret === oldState) return oldState;\r\n    ret.idlookup.__proto__ = DPointerTargetable.pendingCreation as any;\r\n\r\n    // client synchronization stuff\r\n    if (oldState?.collaborativeSession) {\r\n        const ignoredFields: (keyof DState)[]  = ['contextMenu', '_lastSelected', 'isLoading', 'collaborativeSession'];\r\n        /* Checking if CompositeAction has some actions that MUST be ignored */\r\n        let compositeAction: CompositeAction|null = null;\r\n        if(action.type === CompositeAction.type) {\r\n            compositeAction = action as CompositeAction;\r\n            const subActions = compositeAction.actions || [];\r\n            compositeAction.actions = subActions.filter(a => !ignoredFields.includes(a.field as keyof DState));\r\n        }\r\n        if(compositeAction && !compositeAction.actions.length) return ret;\r\n        action = (compositeAction) ? compositeAction : action;\r\n        if(action.sender === DUser.current && !ignoredFields.includes(action.field as keyof DState)) {\r\n            const parsedAction: JSON & GObject = JSON.parse(JSON.stringify(action));\r\n            Collaborative.client.emit('pushAction', parsedAction);\r\n        }\r\n    }\r\n\r\n    if (ret.VIEWS_RECOMPILE_all === true) ret.VIEWS_RECOMPILE_all = Object.keys(ret.idlookup);\r\n    if ((ret.VIEWS_RECOMPILE_all as Pointer[])?.length) {\r\n        let resetAllNodes: boolean = false;\r\n        for (let id of new Set(ret.VIEWS_RECOMPILE_all as Pointer[])){\r\n            let d = ret.idlookup[id];\r\n            if (RuntimeAccessibleClass.extends(d.className, \"DViewElement\")) {\r\n                (d as DViewElement).css_MUST_RECOMPILE = true;\r\n                transientProperties.view[d.id as string] = { } as any;\r\n                for (let k of DViewElement.MeasurableKeys) (ret as any)['VIEWS_RECOMPILE_'+k].push(d.id);\r\n                if (!resetAllNodes) resetAllNodes = true;\r\n            }\r\n            if (RuntimeAccessibleClass.extends(d.className, \"DModelElement\")) {\r\n                if (d.className === \"DClass\") {\r\n                    let oldname = (oldState.idlookup[d.id] as DClass)?.name;\r\n                    let newname = (ret.idlookup[d.id] as DClass)?.name;\r\n                    if (oldname !== newname) ret.ClassNameChanged[d.id as Pointer<DClass>] = oldname;\r\n                }\r\n                // transientProperties.modelElement[d.id] = { } as any; stuff in here does not need replacement, can never be dangerous.\r\n            }\r\n            if (RuntimeAccessibleClass.extends(d.className, \"DGraphElement\")) {\r\n                transientProperties.node[d.id as string] = { } as any;\r\n            }\r\n        }\r\n        if (resetAllNodes) for (let nid in transientProperties.node) transientProperties.node[nid] = {} as any;\r\n    }\r\n\r\n    // local changes to out-of-redux stuff\r\n    if (ret.VIEWS_RECOMPILE_ocl.length) {\r\n        // for (let gid of ret.graphs) Selectors.updateViewMatchings(gid, ret.modelElements, Object.values(ret.idlookup).map( d => RuntimeAccessibleClass.extends(d, DModelElement.cname)));\r\n        // for (let vid of ret.VIEW_APPLIABLETO_NEEDS_RECALCULATION) { }\r\n        for (let vid of new Set(ret.VIEWS_RECOMPILE_ocl)) {\r\n            if (!transientProperties.view[vid]) transientProperties.view[vid] = {} as any;\r\n            transientProperties.view[vid].oclEngine = undefined as any; // force re-parse\r\n            transientProperties.view[vid].oclChanged = true;\r\n            for (let nid in transientProperties.node) {\r\n                let tnv = transientProperties.node[nid].viewScores[vid];\r\n                if (tnv?.OCLScore !== ViewEClassMatch.NOT_EVALUATED_YET) tnv.OCLScore = ViewEClassMatch.NOT_EVALUATED_YET as any as boolean;\r\n            }\r\n        }\r\n        ret.VIEWS_RECOMPILE_ocl = [];\r\n    }\r\n    /*\r\n    if (ret.VIEWOCL_UPDATE_NEEDS_RECALCULATION.length) {\r\n        // not implemented for now\r\n        ret.VIEWOCL_UPDATE_NEEDS_RECALCULATION = [];\r\n    }*/\r\n\r\n    if (ret.VIEWS_RECOMPILE_preconditions.length) {\r\n        for (let vid of new Set(ret.VIEWS_RECOMPILE_preconditions)) {\r\n            for (let nid in transientProperties.node) {\r\n                let tnv = transientProperties.node[nid].viewScores[vid];\r\n                if (tnv?.metaclassScore !== ViewEClassMatch.NOT_EVALUATED_YET) tnv.metaclassScore = ViewEClassMatch.NOT_EVALUATED_YET as any as number;\r\n            }\r\n        }\r\n        ret.VIEWS_RECOMPILE_preconditions = [];\r\n    }\r\n\r\n    if (ret.VIEWS_RECOMPILE_constants?.length)\r\n    for (const vid of new Set(ret.VIEWS_RECOMPILE_constants)) { // compiled in func, and executed, result does not vary between nodes.\r\n        let dv: DViewElement = DPointerTargetable.fromPointer(vid, ret);\r\n        // transientProperties.view[vid].constantsList = dv.constants?.match(UDRegexp).map(s=>s.substring(4, s.length-1).trim()) || [];\r\n        // let allContextKeys = {...contextFixedKeys};\r\n        if (!dv.constants) {\r\n            if (!transientProperties.view[vid]) transientProperties.view[vid] = {} as any;\r\n            transientProperties.view[vid].constants = {};\r\n            transientProperties.view[vid].constantsList = [];\r\n            // no need to recompile UD, jsx or measurables, they will have additional parameters in scope but they are undefined and cause no problems.\r\n            continue;\r\n        }\r\n        const constantsOutput: GObject = {};\r\n        const context = {view:dv}; // context at this point holds only static stuff, which are in gloval scope (window) plus view.\r\n        let paramStr = '{'+Object.keys(context).join(',')+'}, ret';\r\n        try {\r\n            // the scope of new Function() is \"window\" and not the function where is called, unlike eval();\r\n            let constantsFunction: (context: GObject, ret: GObject) => void = new Function(paramStr, 'return ('+dv.constants+')(ret)').bind(context);\r\n            constantsFunction(context, constantsOutput);\r\n        } catch(e:any){\r\n            console.error('error constants parse', {vid, e, paramStr, body:'return ('+dv.constants+')(ret)'});\r\n            // todo: how do i render an error from here? even if i set jsx or ud.__invalidDeclarations it will be recompiled. need a constants.__invalidDeclarations too?\r\n        }\r\n\r\n        transientProperties.view[vid].constants = constantsOutput;\r\n        transientProperties.view[vid].constantsList = Object.keys(transientProperties.view[vid].constants);\r\n        // implies recompilation of: jsCondition, ud, jsx and all measurable events\r\n        ret.VIEWS_RECOMPILE_jsCondition.push(vid);\r\n        ret.VIEWS_RECOMPILE_usageDeclarations.push(vid);\r\n        ret.VIEWS_RECOMPILE_jsxString.push(vid);\r\n        ret.VIEWS_RECOMPILE_events.push(vid);\r\n        for (let k of DViewElement.MeasurableKeys) (ret as any)['VIEWS_RECOMPILE_'+k].push(vid);\r\n    }\r\n    ret.VIEWS_RECOMPILE_constants = [];\r\n\r\n    if (ret.VIEWS_RECOMPILE_usageDeclarations?.length)\r\n    for (const vid of new Set(ret.VIEWS_RECOMPILE_usageDeclarations)) { // compiled in func, but NOT executed, result varies between nodes.\r\n        let dv: DViewElement = DPointerTargetable.fromPointer(vid, ret);\r\n        let tv = transientProperties.view[vid];\r\n        if (!tv) transientProperties.view[vid] = tv = {} as any;\r\n        if (!dv.usageDeclarations) {\r\n            tv.UDList = [];\r\n            tv.UDFunction = undefined as any;\r\n            // no need to recompile jsx or measurables, they will have additional parameters in scope but they are undefined and cause no problems.\r\n            continue;\r\n        }\r\n        let matches = dv.usageDeclarations?.match(UDRegexp) || [];\r\n        transientProperties.view[vid].UDList = matches.map(s=>{ s = s.trim(); return s.substring(s.indexOf('\\.')+1, s.length-2).trim()});\r\n        console.log('matches', {matches, udlist:transientProperties.view[vid].UDList});\r\n        // warning for user: do not redeclare ret in nested blocks.\r\n        // do not use ret[key] syntax.\r\n        // do not set nested values directly (ret.key.subkey syntax).\r\n        // do not use ret.key +=, -= or any other operator assignment different than \"=\"\r\n        // if that is ever required, do instead\r\n        // do not assign values to ret in block comments\r\n        // those restrictions only apply to the ret object, all those violations can be done on other objects.\r\n        // so the following is valid, and a way to overcome the previous limitations:\r\n        // let subobject = {}; subobject[key] += stuff; ret.somefixedname = subobject;\r\n\r\n        let allContextKeys: Dictionary = {...contextFixedKeys};\r\n        for (let k of tv.constantsList) if (!allContextKeys[k]) allContextKeys[k] = true;\r\n        let paramStr = '{'+Object.keys(allContextKeys).join(',')+'}, ret';\r\n        if (vid.includes('Model')) console.log(\"modelparse, ud\", {paramStr, udstr:dv.usageDeclarations, udlist:transientProperties.view[vid].UDList});\r\n        try {\r\n            tv.UDFunction = new Function(paramStr, 'return ('+dv.usageDeclarations+')(ret)') as (...a:any)=>any;\r\n        } catch (e:any) {\r\n            let strerr = JSON.stringify(e); //(e.message || '').split('\\n')[0]);\r\n            let udErrors: GObject =  windoww.udErrors;\r\n            if (!windoww.udErrors) windoww.udErrors = udErrors = {maxi: 0};\r\n            udErrors[\"e\"+(++udErrors.maxi)] = e;\r\n            e.isSyntax = true;\r\n            let errbody = \"ret.__invalidUsageDeclarations = window.udErrors.e\"+udErrors.maxi+\"; return ret;\"\r\n            console.error('error udparse', {vid, e, paramStr, body: 'return ('+dv.usageDeclarations+')(ret)', strerr, errbody});\r\n            tv.UDFunction = new Function(\"ret\", errbody) as (...a:any)=>any;\r\n        }\r\n\r\n\r\n        // implies recompilation of: jsx and all measurable events\r\n        ret.VIEWS_RECOMPILE_jsxString.push(vid);\r\n        ret.VIEWS_RECOMPILE_events.push(vid);\r\n        for (let k of DViewElement.MeasurableKeys) (ret as any)['VIEWS_RECOMPILE_'+k].push(vid);\r\n    }\r\n    ret.VIEWS_RECOMPILE_usageDeclarations = [];\r\n\r\n    if (ret.VIEWS_RECOMPILE_events.length) {\r\n        // for (let gid of ret.graphs) Selectors.updateViewMatchings(gid, ret.modelElements, Object.values(ret.idlookup).map( d => RuntimeAccessibleClass.extends(d, DModelElement.cname)));\r\n        // for (let vid of ret.VIEW_APPLIABLETO_NEEDS_RECALCULATION) { }\r\n        for (let entry of new Set(ret.VIEWS_RECOMPILE_events)) {\r\n            let vid: string;\r\n            let dv: DViewElement;\r\n            let keys: string[];\r\n            if (typeof entry === \"object\") {\r\n                vid = entry.vid;\r\n                dv = DPointerTargetable.fromPointer(vid, ret);\r\n                keys = entry.keys || Object.keys(dv.events);\r\n            }\r\n            else {\r\n                vid = entry;\r\n                dv = DPointerTargetable.fromPointer(vid, ret);\r\n                keys = Object.keys(dv.events);\r\n            }\r\n            let tv = transientProperties.view[vid];\r\n            if (!tv) transientProperties.view[vid] = tv = {} as any;\r\n            if (!tv.events) tv.events = {};\r\n            // if (!tv.events_raw) tv.events_raw = {};\r\n            for (let key of keys) {\r\n                if (!key) { delete tv.events[key]; continue; }\r\n                let allContextKeys = {...contextFixedKeys};\r\n                for (let k of transientProperties.view[vid].constantsList) if (!allContextKeys[k]) allContextKeys[k] = true;\r\n                for (let k of transientProperties.view[vid].UDList) if (!allContextKeys[k]) allContextKeys[k] = true;\r\n                let paramStr = '{'+Object.keys(allContextKeys).join(',')+'}, ..._params';\r\n                // dv.events[key] = (...params)=> code\r\n                const body: string = 'return (' +dv.events[key]+')(..._params)';\r\n                // if (vid.includes('Model')) console.log(\"modelparse, jsx\", {paramStr, body});\r\n                try {\r\n                    tv.events[key] = new Function(paramStr, body) as ((...a:any[])=>any);\r\n                    // tv.events_raw[key] = new Function(paramStr, body) as ((...a:any)=>any);\r\n                    // attempt to auto obtain node context\r\n                    // impossile with view.event.name\r\n                    // could with node.event.name if node.get_event sets a current node thing__, no he must wrap the func!! in the getter\r\n                    // tv.events[key] = (..._params2:any) => { return tv.events_raw[key](context, ..._params2) };\r\n                }\r\n                catch (e: any) {\r\n                    console.error('error jsxparse', {vid, e, paramStr, body});\r\n                    tv.events[key] = (context) => Log.ee(\"failed to parse function body: \" + e.message.split(\"\\n\")[0], e.message);\r\n                }\r\n            }\r\n        }\r\n        ret.VIEWS_RECOMPILE_events = [];\r\n        // triggers recompile of nothing\r\n    }\r\n\r\n    if (ret.VIEWS_RECOMPILE_jsCondition?.length)\r\n    for (const vid of new Set(ret.VIEWS_RECOMPILE_jsCondition)) {\r\n        const dv: DViewElement = DPointerTargetable.fromPointer(vid, ret);\r\n        let tv = transientProperties.view[vid];\r\n        if (!tv) transientProperties.view[vid] = tv = {} as any;\r\n        tv.jsConditionChanged = true;\r\n        if (!dv.jsCondition) {\r\n            tv.jsCondition = undefined;\r\n            continue;\r\n        }\r\n        const lines = dv.jsCondition.trim().split('\\n');\r\n        let lastLine = lines[lines.length - 1];\r\n        if (lastLine.indexOf('return') !== 0) lines[lines.length - 1] = `return (${lastLine})`;\r\n\r\n\r\n        if (!dv.jsxString) { transientProperties.view[vid].JSXFunction = undefined as any; continue; }\r\n        let allContextKeys = {...contextFixedKeys};\r\n        for (let k of transientProperties.view[vid].constantsList) if (!allContextKeys[k]) allContextKeys[k] = true;\r\n\r\n        let paramStr = '{'+Object.keys(allContextKeys).join(',')+'}';\r\n        const body = lines.join('\\n');\r\n        try {\r\n            tv.jsCondition = new Function(paramStr, body) as ((...a:any)=>any);\r\n        } catch (e) {\r\n            tv.jsCondition = undefined;\r\n            console.log('JS Condition parsed error', e);\r\n        }\r\n    }\r\n    ret.VIEWS_RECOMPILE_jsCondition = [];\r\n\r\n\r\n    if (ret.VIEWS_RECOMPILE_jsxString?.length)\r\n    for (const vid of new Set(ret.VIEWS_RECOMPILE_jsxString)) { // compiled in func, but NOT executed, result varies between nodes.\r\n        let dv: DViewElement = DPointerTargetable.fromPointer(vid, ret);\r\n        let tv = transientProperties.view[vid];\r\n        if (!tv) transientProperties.view[vid] = tv = {} as any;\r\n        if (!dv.jsxString) { transientProperties.view[vid].JSXFunction = undefined as any; continue; }\r\n        let allContextKeys = {...contextFixedKeys};\r\n        for (let k of transientProperties.view[vid].constantsList) if (!allContextKeys[k]) allContextKeys[k] = true;\r\n        for (let k of transientProperties.view[vid].UDList) if (!allContextKeys[k]) allContextKeys[k] = true;\r\n        let paramStr = '{'+Object.keys(allContextKeys).join(',')+'}';\r\n        console.log('jsxparse', { allContextKeys, ud:transientProperties.view[vid].UDList, c:transientProperties.view[vid].constantsList });\r\n        const body: string =  'return (' + UX.parseAndInject(DSL.parser(dv.jsxString), dv) + ')';\r\n        // if (vid.includes('Model')) console.log(\"modelparse, jsx\", {paramStr, body});\r\n        console.log('jsxparse', {vid, paramStr, body});\r\n        try {\r\n            transientProperties.view[vid].JSXFunction = new Function(paramStr, body) as ((...a: any) => any);\r\n        }\r\n        catch (e: any) {\r\n            /*try{\r\n                let try_to_get_better_error = eval(\"let __f = function(\" + paramStr+\") {\\n\" + body + \"}\");\r\n            } catch(eeval){\r\n                console.error(\"eval error same as func error\", {e, eeval});\r\n                e = eeval;\r\n            }*/\r\n            console.error('error jsxparse', {vid, e, paramStr, body});\r\n            transientProperties.view[vid].JSXFunction = (context) => GraphElementComponent.displayError(e, 'JSX Syntax', dv);\r\n        }\r\n        // implies recompilation of: ... nothing?\r\n    }\r\n    ret.VIEWS_RECOMPILE_jsxString = [];\r\n\r\n\r\n\r\n    for (const key of DViewElement.MeasurableKeys) {\r\n        if ((ret as any)['VIEWS_RECOMPILE_'+key]?.length)\r\n        for (let vid of new Set((ret as any)['VIEWS_RECOMPILE_'+key]) as any) {\r\n            let dv: DViewElement = DPointerTargetable.fromPointer(vid, ret);\r\n            let tv = transientProperties.view[vid];\r\n            if (!tv) transientProperties.view[vid] = tv = {} as any;\r\n            let str: string = (dv as any)[key];\r\n            if (!str) {\r\n                (transientProperties.view[vid] as any)[key] = undefined;\r\n                continue;\r\n            }\r\n            let allContextKeys = {...contextFixedKeys};\r\n            for (let k of transientProperties.view[vid].constantsList) if (!allContextKeys[k]) allContextKeys[k] = true;\r\n            for (let k of transientProperties.view[vid].UDList) if (!allContextKeys[k]) allContextKeys[k] = true;\r\n            let paramStr = '{'+Object.keys(allContextKeys).join(',')+'}';\r\n            console.log('measurable parse '+key, {allContextKeys, ud:transientProperties.view[vid].UDList, c:transientProperties.view[vid].constantsList });\r\n            console.log('measurable parse '+key, {vid, paramStr, body:str});\r\n            try {\r\n                (transientProperties.view[vid] as any)[key] = new Function(paramStr, str);\r\n            }\r\n            catch (e: any) {\r\n                console.error('error measurable parse '+key, {vid, e, paramStr, body:str});\r\n                (transientProperties.view[vid] as any)[key] = undefined;\r\n                // display error in jsx\r\n                transientProperties.view[vid].JSXFunction = (context) => GraphElementComponent.displayError(e, 'Measurable ' + key + ' Syntax', dv);\r\n                break;\r\n            }\r\n        }\r\n        (ret as any)['VIEWS_RECOMPILE_'+key] = [];\r\n    }\r\n\r\n    for (let dataid in ret.ClassNameChanged) {\r\n        if (dataid === 'clonedCounter') continue;\r\n        // NB: if i ever want to access a constructor's other properties in ocl, like \"context Persona inv: self.$somecounter === Persona.instances.length\",\r\n        // i would need to update this every time a DClass property changes instead of only when name changes.\r\n\r\n        // if it's first creation of a modelpiece\r\n        if (!transientProperties.modelElement[dataid]) {\r\n            transientProperties.modelElement[dataid] = {nodes: {}};\r\n        }\r\n        // update ocl type names\r\n        let data: DClass = ret.idlookup[dataid] as DClass;\r\n        RuntimeAccessibleClass.makeOCLConstructor(data, ret, oldState);\r\n        // here i should reset all tnv.oclEngine too and set all ocl scores to notevaluated, but it is too computationally heavy\r\n        // and it's useful to keep the old ocl condition valid with past names until manually edited.\r\n    }\r\n    ret.ClassNameChanged = {};\r\n\r\n    return ret;\r\n\r\n}\r\n\r\nexport function _reducer/*<S extends StateNoFunc, A extends Action>*/(oldState: DState = initialState, action: Action): DState{\r\n    let times: number;\r\n    let state: DState;\r\n    let removedDeltas: (GObject | undefined)[] = [];\r\n    switch (action.type) {\r\n        case UndoAction.type:\r\n            times = action.value;\r\n            state = oldState;\r\n            Log.exDev(times<=0, \"undo must be positive\", action);\r\n            while (times--) {\r\n                const delta = statehistory[DUser.current].undoable.pop();\r\n                removedDeltas.push(delta);\r\n                state = undo(state, delta);\r\n            }\r\n            state.VIEWS_RECOMPILE_all = removedDeltas.flatMap( d => Object.keys(d?.idlookup||{}));\r\n            // state.VIEWS_RECOMPILE_all = true;\r\n            return state;\r\n\r\n        case RedoAction.type:\r\n            times = action.value;\r\n            state = oldState;\r\n            Log.exDev(times<=0, \"redo must be positive\", action);\r\n            while (times--) {\r\n                const delta = statehistory[DUser.current].redoable.pop();\r\n                removedDeltas.push(delta);\r\n                state = undo(state, delta, false);\r\n            }\r\n            state.VIEWS_RECOMPILE_all = removedDeltas.flatMap( d => Object.keys(d?.idlookup||{}));\r\n            // state.VIEWS_RECOMPILE_all = true;\r\n            return state;\r\n        // case CombineHistoryAction.type: return combineHistory(oldState); break;\r\n        // todo: se al posto di \"annullare l'undo\" memorizzo l'azione e la rieseguo, posso ripetere l'ultimo passo N volte e questa azione diventa utile per combinare passi e ripetere blocchi di azioni assieme\r\n        default:\r\n            let ret = doreducer(oldState, action);\r\n            if (ret === oldState) return ret;\r\n            // statehistory[DUser.current].redoable = [];   <-- Moved to stateInitializer()\r\n            let delta =  U.objectDelta(ret, oldState);\r\n            if (!filterundoableactions(delta)) return ret;\r\n            // console.log(\"setting undoable action:\", {ret, oldState0:{...oldState}, oldState, delta});\r\n            if (oldState !== null) statehistory[DUser.current].undoable.push(delta);\r\n            return ret;\r\n    }\r\n}\r\n\r\nfunction filterundoableactions(delta: Partial<DState>): boolean {\r\n    if (!statehistory.globalcanundostate) return false;\r\n    if (Object.keys(delta).length === 1) {\r\n        if (\"dragging\" in delta) return false;\r\n        if (\"_lastSelected\" in delta) return false;\r\n        if (\"contextMenu\" in delta) return false;\r\n    }\r\n    return true;\r\n}\r\nfunction undo(state: DState, delta: GObject | undefined, isundo = true): DState {\r\n    if (!delta) return state;\r\n    let undonestate: DState = {...state} as DState;\r\n    //   controlla se vengono shallow-copied solo e tutti gli oggetti nested lungo la catena del percorso delle modifiche\r\n    //   es: root.a.b.c=3 + root.a.b.d=3 = 4+1 modifiche, 5 shallow copies including the root\r\n    undorecursive(delta, undonestate);\r\n    if (isundo) statehistory[DUser.current].redoable.push( U.objectDelta(undonestate, state) ); // reverses from undo to redo and viceversa swapping arguments, so the target result after appliying the delta changes\r\n    else statehistory[DUser.current].undoable.push( U.objectDelta(undonestate, state) ); // redo is \"undoing an undo\", reversing his changes just like an undo reverses an ordinary action changes.\r\n    return undonestate;\r\n}\r\n\r\nfunction undorecursive(deltalevel: GObject, statelevel: GObject): void {\r\n    // statelevel = {...statelevel}; not working if i do it here, just a new var. first time copy id done in caller func undo(). recursive copies are done before recursive step\r\n    for (let key in deltalevel) {\r\n        let delta = deltalevel[key];\r\n        console.log(\"undoing\", {delta, key, deltalevel, statelevel})\r\n        if (key.indexOf(\"_-\") === 0) { delete statelevel[key.substring(2)]; continue; }\r\n        if (typeof delta === \"object\") {\r\n        // if (U.isObject(delta, false, false, true)) {\r\n            statelevel[key] = {...statelevel[key]};\r\n            undorecursive(deltalevel[key], statelevel[key]); }\r\n        else { statelevel[key] = delta; }\r\n    }\r\n}\r\n\r\nfunction doreducer/*<S extends StateNoFunc, A extends Action>*/(oldState: DState = initialState, action: Action): DState{\r\n    if (!oldState) { oldState = initialState = DState.new(); }\r\n    let ca: CompositeAction;\r\n    // console.log('external REDUCER', {action, CEtype:CreateElementAction.type});\r\n    if (!storeLoaded) {\r\n        // new SetRootFieldAction('forceinit', true);\r\n        storeLoaded = true;\r\n    }\r\n    if (!(oldState as any).forceinit) {\r\n        // afterStoreLoad();\r\n        // new SetRootFieldAction('forceinit', true);\r\n    } //  setTimeout(afterStoreLoad, 1);\r\n    switch (action.type) {\r\n        case CompositeAction.type: ca = action as CompositeAction; break;\r\n        case LoadAction.type:\r\n        default:\r\n            if (action.type.indexOf('@@redux/') === 0) {\r\n                //storeLoaded = true;\r\n                return oldState;\r\n            }\r\n            ca = new CompositeAction([action], false);\r\n            break;\r\n    }\r\n    let ret = CompositeActionReducer(oldState, ca);\r\n    /*if (state.current !== ret) {\r\n        state.current = ret;\r\n        state.past.push(ret);\r\n    }*/\r\n    return ret;\r\n}\r\nfunction setSubclasses(roots: orArr<typeof RuntimeAccessibleClass>){\r\n    RuntimeAccessibleClass.extendMatrix =\r\n        new SimpleTree<(typeof RuntimeAccessibleClass)>(roots, \"subclasses\")\r\n            .getiIsSubElementMatrix(\"cname\");\r\n    /*\r\n    let tree = new TreeModel({\r\n        childrenPropertyName: \"subclasses\"\r\n    });\r\n    for (let key in dict){\r\n        let constructor = dict[key];\r\n        if(!constructor.hasOwnProperty(\"subclasses\")) constructor.subclasses = [];\r\n    }\r\n    RuntimeAccessibleClass.extendTree = (tree as any).safe_parse(RuntimeAccessibleClass);*/\r\n}\r\n// windoww.TreeModel = TreeModel;\r\nfunction buildLSingletons(alld: Dictionary<string, typeof DPointerTargetable>, alll: Dictionary<string, typeof LPointerTargetable>) {\r\n    for (let dname in alld) {\r\n        switch (dname) {\r\n            case \"DeleteElementAction\": continue;\r\n            case \"DV\": continue;\r\n            case \"Debug\": continue;\r\n            default: break;\r\n        }\r\n        if ((dname[1] || \"\").toLowerCase() === dname[1]) continue; // if second letter is lowercase, it's not a \"D\" class\r\n        let tagless = dname.substring(1);\r\n        let d = alld[dname];\r\n        let l = alll['L'+tagless];\r\n        if (!d||!l) console.error(\"missing d constructor\", {d, l});\r\n        d.logic = l;\r\n        if (!l) console.error('init() could not find L-class during mapping', l, d);\r\n        // @ts-ignore\r\n        d.singleton = new l('dwc');\r\n        d.structure = d;\r\n\r\n        l.logic = d.logic;\r\n        l.singleton = d.singleton;\r\n        l.structure = d.structure;\r\n\r\n        // if (!d.subclasses) d.subclasses = [];\r\n        // @ts-ignore\r\n        // for (let sc of d.subclasses) { if (!sc[\"_extends\"]) sc[\"_extends\"] = [];  sc[\"_extends\"].push(d); }\r\n    }\r\n}\r\n\r\nexport async function stateInitializer() {\r\n    statehistory[DUser.current] = {redoable: [], undoable: []};\r\n    RuntimeAccessibleClass.fixStatics();\r\n    let dClassesMap: Dictionary<string, typeof DPointerTargetable> = {};\r\n    let lClassesMap: Dictionary<string, typeof LPointerTargetable> = {};\r\n    for (let name in RuntimeAccessibleClass.classes) {\r\n        switch(name[0]) {\r\n            default: break;\r\n            case \"D\": dClassesMap[name] = RuntimeAccessibleClass.classes[name] as typeof DPointerTargetable; break;\r\n            case \"L\": lClassesMap[name] = RuntimeAccessibleClass.classes[name] as typeof LPointerTargetable; break;\r\n        }\r\n    }\r\n    /*\r\n    let dClasses: string[] = RuntimeAccessibleClass.getAllNames().filter(rc => rc[0] === 'D');\r\n    let lClasses: string[] = RuntimeAccessibleClass.getAllNames().filter(rc => rc[0] === 'L');\r\n    let dClassesMap: Dictionary<string, typeof DPointerTargetable> =\r\n        dClasses.reduce((acc: GObject, curr) => {acc[curr] = RuntimeAccessibleClass.get(curr); return acc}, {});\r\n    let lClassesMap: Dictionary<string, typeof LPointerTargetable> =\r\n        lClasses.reduce((acc: GObject, curr) => {acc[curr] = RuntimeAccessibleClass.get(curr); return acc}, {}); */\r\n\r\n    buildLSingletons(dClassesMap, lClassesMap);\r\n    setSubclasses(RuntimeAccessibleClass.get(\"DPointerTargetable\"));// setSubclasses(lClassesMap);\r\n    windoww.defaultContext = {$: windoww.$, getPath, React: React, Selectors, ...RuntimeAccessibleClass.getAllClassesDictionary(), ...windoww.Components};\r\n    // global document events\r\n\r\n    // do not use typings or class constructors here or it will change import order\r\n    setTimeout(\r\n        ()=> $(document).on(\"mouseup\",\r\n            (e: MouseUpEvent) => RuntimeAccessibleClass.get<typeof GraphDragManager>(\"GraphDragManager\").stopPanning(e)),\r\n        // ()=> $(document).on(\"mouseup\", (e: MouseUpEvent) => (window as any).GraphDragManager.stopPanning(e)), //a\r\n        1\r\n    );\r\n    DState.init();\r\n    const user = Storage.read<DUser>('user');\r\n    if(!user) return;\r\n    DUser.new(user.username, user.id);\r\n    DUser.current = user.id;\r\n    await ProjectsApi.getAll();\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}