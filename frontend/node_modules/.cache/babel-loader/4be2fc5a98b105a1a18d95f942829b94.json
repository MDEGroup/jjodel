{"ast":null,"code":"var _dec,_class;import{LUser,DUser,DViewElement,DPointerTargetable,DModel,DModelElement,OCL,Log,LPointerTargetable,RuntimeAccessible,RuntimeAccessibleClass,store,U,toShortEType,NodeTransientProperties,transientProperties,ViewEClassMatch}from\"../../joiner\";import{ShortDefaultEClasses,toShortEClass}from\"../../common/U\";export let Selectors=(_dec=RuntimeAccessible('Selectors'),_dec(_class=class Selectors{static getActiveModel(){var _state$_lastSelected;let metamodel;let state=store.getState();const selected=(_state$_lastSelected=state._lastSelected)===null||_state$_lastSelected===void 0?void 0:_state$_lastSelected.modelElement;if(selected){const me=LPointerTargetable.fromPointer(selected);metamodel=me?me.model:null;}else metamodel=null;return metamodel;}static getLastSelectedModel(state){var _state$_lastSelected2;state=state||store.getState();let me=(_state$_lastSelected2=state._lastSelected)===null||_state$_lastSelected2===void 0?void 0:_state$_lastSelected2.modelElement;if(!me)return{};let ret={element:LPointerTargetable.fromPointer(me,state)};ret.model=ret.element.model;if(ret.model.isMetamodel)ret.m2=ret.model;else{ret.m1=ret.model;ret.m2=ret.m1.instanceof;}return ret;}static getAllViewElements(state0){// return Object.values(store.getState().idlookup).filter(v => v.className === DViewElement.name) as DViewElement[];\nconst state=state0||store.getState();const ptrs=Object.values(state.viewelements);let views=ptrs.map(ptr=>DPointerTargetable.fromPointer(ptr,state));return views;}//Giordano: start\nstatic getViewpoints(){const state=store.getState();return LPointerTargetable.fromPointer(state.viewpoints);}static getViewpoint(){const state=store.getState();return LPointerTargetable.fromPointer(state.viewpoint);}static getObjects(){let state=store.getState();const ptrs=Object.values(state.objects);const dObjects=ptrs.map(ptr=>state.idlookup[ptr]);const lObjects=[];for(let dObject of dObjects){lObjects.push(LPointerTargetable.fromPointer(dObject.id));}return lObjects;}static getValues(){let state=store.getState();const ptrs=Object.values(state.values);const dValues=ptrs.map(ptr=>state.idlookup[ptr]);const lValues=[];for(let dValue of dValues){if(dValue===null||dValue===void 0?void 0:dValue.id){lValues.push(LPointerTargetable.fromPointer(dValue.id));}}return lValues;}static getDeleted(){const state=store.getState();return state.deleted;}static getState(){const state=store.getState();return state;}static getDefaultEcoreClass(type,state){let shorttype=(toShortEClass(type)||type).toUpperCase();if(!state)state=store.getState();// todo: make other m3 classes and make this generic like getPrimitiveType\nreturn state.idlookup[\"Pointer_\"+ShortDefaultEClasses.EObject.toUpperCase()];}static getPrimitiveType(type,state){let shorttype=(toShortEType(type)||type).toUpperCase();if(!state)state=store.getState();return state.idlookup[\"Pointer_\"+shorttype];}static getAllPrimitiveTypes(){let state=store.getState();const ptrs=Object.values(state.primitiveTypes);const classifiers=ptrs.map(ptr=>state.idlookup[ptr]);return classifiers;}static getFirstPrimitiveTypes(){return Selectors.getAllPrimitiveTypes()[0];}static getRefEdges(){const state=store.getState();const pointers=Object.values(state.refEdges);const dRefEdges=pointers.map(ptr=>state.idlookup[ptr]);return dRefEdges;}static getField(field){let state=store.getState();const pointers=Object.values(state[field]);return pointers;}static getAllAttributes(){const state=store.getState();return Object.values(state.attributes);}static getAllEnumLiterals(){const state=store.getState();return Object.values(state.enumliterals);}static getAllReferences(){const state=store.getState();return Object.values(state.references);}// static getAllReferenceEdges(): string[] { const state: DState = store.getState(); return Object.values((state).refEdges); }\nstatic getAllClasses(){const state=store.getState();return Object.values(state.classs);}static getReturnTypes(){const state=store.getState();return LPointerTargetable.from(Object.values(state.returnTypes));}static getAllClassesWithoutPrimitive(){// this solution does not look good. what if a primitive type is inserted at runtime in between?\n// coould reach the same goal by taking all Classes of a model (m2), excluding classes from other models (types are classes from m3 model)\nconst state=store.getState();const classList=Object.values(state.classs);classList.splice(0,Selectors.getAllPrimitiveTypes().length);/* todo: need to change it in something like this once cross-references between models and instances are implemented\r\n        const m2: LModel;\r\n        m2.isInstanceOf = m3 as LModel;\r\n        m2.isInstanceOf.classes;*/return classList;}static getAllEnumerators(){let flag=arguments.length>0&&arguments[0]!==undefined?arguments[0]:false;const state=store.getState();return Object.values(state.enumerators);}static getAllPackages(){const state=store.getState();return Object.values(state.packages);}static getAllParameters(){const state=store.getState();return Object.values(state.parameters);}static getAllOperations(){const state=store.getState();return Object.values(state.operations);}static getDElement(pointer){const state=store.getState();const dElement=state.idlookup[pointer];return dElement;}static getAllMetamodels(){const state=store.getState();const dModels=Object.values(state.m2models);return LPointerTargetable.fromPointer(dModels);}static getAllModels(){const state=store.getState();const dModels=Object.values(state.m1models);return LPointerTargetable.fromPointer(dModels);}//Giordano: end\nstatic getVertex(wrap,resolvePointers){const state=store.getState();let ptrs=[];U.ArrayMerge0(false,ptrs,// Object.values(state.graphs || {}),\nObject.values(state.voidvertexs||{}),Object.values(state.vertexs||{}),Object.values(state.graphvertexs||{}),Object.values(state.edgepoints||{}));console.log('selector getvertex: ',{ptrs,g:Object.values(state.graphs||{}),vv:Object.values(state.voidvertexs||{}),v:Object.values(state.vertexs||{}),gv:Object.values(state.graphvertexs||{}),ep:Object.values(state.edgepoints||{})});if(wrap===undefined||wrap===true)return ptrs.map(p=>DPointerTargetable.wrap(p));if(resolvePointers===undefined||resolvePointers===true)return ptrs.map(r=>state.idlookup[r]);return ptrs;}static getAll(Classe,condition,state,resolvePointers,wrap){if(!state)state=store.getState();let GClass=Classe||{name:\"idlookup\",cname:\"idlookup\"};const className=((GClass===null||GClass===void 0?void 0:GClass.staticClassName)||GClass.cname).toLowerCase();const allIdByClassName=state[className]||state[className.substr(1)]||state[className+'s']||state[className.substr(1)+'s'];Log.exDev(!allIdByClassName,'cannot find store key:',{state,className,Classe});let allDByClassName=null;let allLByClassName=null;if(resolvePointers||wrap){allDByClassName=allIdByClassName.map(e=>state.idlookup[e]);if(wrap){allLByClassName=allDByClassName.map(e=>DPointerTargetable.wrap(e));}}let ret=resolvePointers||wrap?wrap?allLByClassName:allDByClassName:allIdByClassName;if(!Array.isArray(ret))ret=Object.values(ret).filter(e=>e instanceof Object);if(condition)return ret.filter(e=>condition(e));return ret;}static getModels(condition){return Selectors.getAll(DModel,undefined,undefined,true,false);}static getModel(name){let caseSensitive=arguments.length>1&&arguments[1]!==undefined?arguments[1]:false;let wrap=arguments.length>2&&arguments[2]!==undefined?arguments[2]:false;if(!caseSensitive)name=name.toLowerCase();let ret=Selectors.getAll(DModel,d=>(caseSensitive?d.name:d.name.toLowerCase())===name,undefined,true,wrap)[0];return ret;}static getByName(classe,name){let caseSensitive=arguments.length>2&&arguments[2]!==undefined?arguments[2]:false;let wrap=arguments.length>3&&arguments[3]!==undefined?arguments[3]:false;return Selectors.getByField(classe,'name',name,caseSensitive,wrap);}static getByField(classe,field,value){let caseSensitive=arguments.length>3&&arguments[3]!==undefined?arguments[3]:false;let wrap=arguments.length>4&&arguments[4]!==undefined?arguments[4]:false;if(!caseSensitive)value=value.toLowerCase();let condition=d=>{var _d$field;let ret=(caseSensitive?d[field]:(_d$field=d[field])===null||_d$field===void 0?void 0:_d$field.toLowerCase())===value;console.log('filtering getall by field:',{d,dfield:d[field],value,ret});return ret;};let ret=Selectors.getAll(classe,condition,undefined,true,wrap)[0];return ret;}static getViewIDs(condition){return Selectors.getAll(DViewElement);}static queryJS(model,query){try{return eval(query);}catch(e){return[];}}/*static getCurrentView(data: LModelElement): DViewElement {\r\n        Log.exDevv('todo');\r\n        return undefined as any;\r\n    }*/static matchesMetaClassTarget(v,data){if(!v)return ViewEClassMatch.MISMATCH_PRECONDITIONS;if(!v.appliableToClasses||!v.appliableToClasses.length)return ViewEClassMatch.IMPLICIT_MATCH;if(!data)return ViewEClassMatch.MISMATCH_PRECONDITIONS;let ThisClass=RuntimeAccessibleClass.get(data.className);Log.exDev(!ThisClass,'unable to find class type:',{v,data});// todo: v = view appliable to DModel, data = proxy<LModel>\nlet gotSubclassMatch=false;for(let classtarget of v.appliableToClasses){const ClassTarget=RuntimeAccessibleClass.get(classtarget);if(ThisClass===ClassTarget)return ViewEClassMatch.EXACT_MATCH;// explicit exact match\nif(!gotSubclassMatch&&U.classIsExtending(ThisClass,ClassTarget))gotSubclassMatch=true;// explicit subclass match\nif(gotSubclassMatch)return ViewEClassMatch.INHERITANCE_MATCH;}return ViewEClassMatch.MISMATCH_PRECONDITIONS;}static isOfSubclass(data,classTarget){let acceptEquality=arguments.length>2&&arguments[2]!==undefined?arguments[2]:false;let ThisClass=RuntimeAccessibleClass.get(data.className);Log.exDev(!ThisClass,'isOfSubclass() unable to find class type:',{data});const ClassTarget=typeof classTarget===\"string\"?RuntimeAccessibleClass.get(classTarget):classTarget;if(ThisClass===ClassTarget)return acceptEquality;return U.classIsExtending(ThisClass,ClassTarget);}static getViewByIDOrNameD(name,state){var _state$idlookup$name,_state$idlookup$id;if(!state)state=store.getState();if(typeof name===\"object\"){return name.__raw||name;}if(((_state$idlookup$name=state.idlookup[name])===null||_state$idlookup$name===void 0?void 0:_state$idlookup$name.className)===DViewElement.cname)return state.idlookup[name];let id=Selectors.getViewIdFromName(name,state);if(id&&((_state$idlookup$id=state.idlookup[id])===null||_state$idlookup$id===void 0?void 0:_state$idlookup$id.className)===DViewElement.cname)return state.idlookup[id];return undefined;}// input: \"subview.subview2.targetview\"\n// output: returns pointer to targetview\n// path is not required to start with a root, it's also possible to start navigating from a subview (notviewpoint/model view)\n// in case multiple matches are given due to incomplete path not starting from a viewpoint, the oldest matching view is returned.\nstatic getViewIdFromName(namepath,state){if(!state)state=store.getState();let names=namepath.split(\".\");let eligibleContainers=state.viewelements;for(let i=0;i<names.length;i++){let name=names[i];eligibleContainers=eligibleContainers.filter(v=>state.idlookup[v].name===name);if(i===names.length-1||eligibleContainers.length===0)return eligibleContainers[0];eligibleContainers=eligibleContainers.flatMap(v=>Object.keys(state.idlookup[v].subViews));}return undefined;}static getAllGraphElementPointers(){// graphelements = fields;\nlet state=store.getState();return[...state.graphs,...state.graphvertexs,...state.graphelements,...state.vertexs,...state.edgepoints,...state.edges];}static getFinalScore(entry,vid,parentView,dview){if(entry.metaclassScore===ViewEClassMatch.MISMATCH_PRECONDITIONS)return ViewEClassMatch.MISMATCH;if(entry.viewPointMatch===ViewEClassMatch.VP_MISMATCH)return ViewEClassMatch.MISMATCH;if(entry.jsScore===ViewEClassMatch.MISMATCH_JS||entry.OCLScore===ViewEClassMatch.MISMATCH_JS)return ViewEClassMatch.MISMATCH;let pvMatch=parentView?vid in parentView.subViews:false;let pvScore=pvMatch?parentView.subViews[vid]:1;let explicitprio;if(typeof entry.jsScore==='number'){explicitprio=entry.jsScore;}else if(dview.explicitApplicationPriority===undefined){var _dview$jsCondition,_dview$oclCondition;// in editor put placeholder with computed expression\nexplicitprio=(((_dview$jsCondition=dview.jsCondition)===null||_dview$jsCondition===void 0?void 0:_dview$jsCondition.length)||1)+(((_dview$oclCondition=dview.oclCondition)===null||_dview$oclCondition===void 0?void 0:_dview$oclCondition.length)||1);}else explicitprio=dview.explicitApplicationPriority;//console.log(\"getFinalScore\", {entry, vid, dview, explicitprio, ep:dview.explicitApplicationPriority})\nlet defualtViewMalus=dview.id.indexOf('View')>=0?0:0.1;return entry.viewPointMatch*entry.metaclassScore*pvScore*explicitprio+defualtViewMalus;//score = precoditiom * paremtview(comfiguravle) * (explicitprio = jsValid*jslemgth + oclvalid*ocllemgth)\n// or if jscomditiom returmed mumver --> * jsscore\n}/*\r\n    //this function handles: what i do when view changes? do i recompute the score?\r\n    static updateViewMatchings(dview: DViewElement, updatePreconditions: boolean, updateOCLScore: boolean, store: DState, updateManualViews: boolean = false, forcedUpdateViews: boolean = false): void {\r\n\r\n        //  event           observed change         ignore change\r\n        //  ocl             data                    node, view (except view.ocl)\r\n        //  jsCondition     all                     none\r\n        //  appliableTo     view.appliableto\r\n        // if (!forcedUpdateViews && (dview.oclUpdateCondition === 'manual') !== updateManualViews) return;\r\n        // modularize getscoresnew split in setpreconditionscore, setoclscorem, setjscscore, and call those only if observed stuff changed\r\n\r\n        const allNodes: DGraphElement[] = DPointerTargetable.fromPointer(Selectors.getAllGraphElementPointers());\r\n        //let dview = view.__raw;\r\n        let vid = dview.id; // optimize searching multiple usages and replacing\r\n\r\n        // filter alldata to exclude modelpieces that didn't pass the view.appyto check\r\n        // let oclData: (LModelElement)[] = allData.filter(l => {\r\n        let oclnodes: (DGraphElement)[] = allNodes.filter((dg: DGraphElement) => {\r\n            if (!dg) return false;\r\n            if (true) {\r\n                let d: DModelElement | undefined = dg.model ? DPointerTargetable.fromPointer(dg.model) : undefined;\r\n                let firstEvaluationForNodeView: boolean = false;\r\n                if (!transientProperties.node[dg.id]) { transientProperties.node[dg.id] = {viewScores: {}} as any; firstEvaluationForNodeView = true; }\r\n                if (!transientProperties.node[dg.id].viewScores[vid]) { transientProperties.node[dg.id].viewScores[vid] = {score: undefined} as any; firstEvaluationForNodeView = true; }\r\n\r\n                if (firstEvaluationForNodeView || updatePreconditions) {\r\n                    const oldScore = transientProperties.node[dg.id].viewScores[vid].score;\r\n                    const newScore = transientProperties.node[dg.id].viewScores[vid].score = this.matchesMetaClassTarget(dview, d);\r\n                    if (oldScore !== newScore) transientProperties.node[dg.id].stackViews = undefined as any; // force re-sorting\r\n                    // 67{}[]'?^&&||nb>\r\n                } /* else {\r\n                    if (!transientProperties.view[dview.id].oclUpdateCondition_PARSED( transientProperties.node[dg.id].viewScores[vid].)) return;\r\n                }* /\r\n                // no need to check if parentview changed as well. i optimized by not having parentview affect the numeric scores, but only the view queue array sorting\r\n\r\n                // transient.node[dg.id].viewScores[vid].score = MISSING (hasOwnProperty);    if the view or model is new and they are not yet evaluated.\r\n                // transient.node[dg.id].viewScores[vid].score = Number.NEGATIVE_INFINITY;    if pre-ocl conditions failed (view.appliableTo)\r\n                // transient.node[dg.id].viewScores[vid].score = 0;                           if preconditions are met, but ocl failed\r\n                // transient.node[dg.id].viewScores[vid].score = number ocl score;            if preconditions are met and ocl matched\r\n                // transient.node[dg.id].viewScores[vid].score = number precondition score;   if preconditions are met, and there is no ocl condition\r\n                // changed: matching score and ocl score are summed.\r\n                return transientProperties.node[dg.id].viewScores[vid].score !== undefined;\r\n            }\r\n\r\n            // if (model_viewstack[vid]) { filledElementsInOclData++; return l; } return undefined;\r\n        });\r\n        function mergeViewScores(preconditionScore: number, oclScore: number): number{ return preconditionScore + oclScore; }\r\n    }*/static updateScores(data0,node,nid,pv,state){let needsorting=false;let firstEvaluationForNode=false;let firstEvaluationForNodeView=false;let tn=transientProperties.node[nid];if(!tn){transientProperties.node[nid]=tn=new NodeTransientProperties();firstEvaluationForNode=true;}let olddata=tn.viewSorted_modelused;//let oldnode = transientProperties.node[nid]?.viewSorted_nodeused as LGraphElement;\nconst data=data0;// console.error('changed', {data, olddata, node, oldnode, cdata:data?.clonedCounter, colddata:olddata?.clonedCounter})\nconst pvid=pv===null||pv===void 0?void 0:pv.id;const oldpv=tn.viewSorted_pvid_used;let datachanged=!!data!==!!olddata||!!(data&&olddata)&&data.clonedCounter!==olddata.clonedCounter;//let nodechanged: boolean = (!!node !== !!oldnode) || !!(node && oldnode) && (node.clonedCounter !== oldnode.clonedCounter);\nlet parentViewChanged=pvid!==(oldpv===null||oldpv===void 0?void 0:oldpv.id)||!!(pv&&oldpv)&&oldpv.subViews!==pv.subViews;// shallow comparison is fine.\nif(parentViewChanged)tn.viewSorted_pvid_used=pv;//if (nodechanged) transientProperties.node[nid].viewSorted_nodeused = node;\nif(datachanged)tn.viewSorted_modelused=data;// let nodechanged: boolean\n// important to remember: how i'm using parentView in score and storage.\n// i'm calculating and storing every score without parentView, then i apply it right before sorting the array,\n// the enhanced value is not sored anyway but affects array sorting.\n// so if parentView changes, or if his subviews changed, need to resort array without recomputing any score value.\n//console.log('2302, getviews 2', {datachanged, nodechanged, olddata, oldnode, data, node, allViews: Selectors.getAllViewElements()});\nif(!state)state=store.getState();const allViews=Selectors.getAllViewElements(state);const user=LUser.fromPointer(DUser.current);const project=user.project;let activevpid=project.activeViewpoint.id;// check if scores needs to be updated\nfor(const dview of allViews){let vid=dview.id;let tv=transientProperties.view[vid];if(!tv)transientProperties.view[vid]=tv={};let tnv=tn.viewScores[vid];//console.log('2302, getviews evaluating view ' + vid, {vid, dview});\n// check initialization\nif(!tnv){transientProperties.node[nid].viewScores[vid]=tnv={};/*{\r\n                    score: ViewEClassMatch.NOT_EVALUATED_YET,\r\n                    metaclassScore: ViewEClassMatch.NOT_EVALUATED_YET,\r\n                    //jsScore:ViewEClassMatch.NOT_EVALUATED_YET,\r\n                    //OCLScore: ViewEClassMatch.NOT_EVALUATED_YET\r\n                } as any;*/firstEvaluationForNodeView=true;}else firstEvaluationForNodeView=tnv.metaclassScore===ViewEClassMatch.NOT_EVALUATED_YET;// todo: when changing view.appliableTo, delete all tnv using that view.\n// don't match exclusive views from other vp\nlet dvp=DPointerTargetable.fromPointer(dview.viewpoint,state);let oldVpMatch=tnv.viewPointMatch;// console.log(\"vp matching \" +vid, {vid, dvp, activevpid });\nif(dvp.id===activevpid)tnv.viewPointMatch=ViewEClassMatch.VP_Explicit;else if(dvp.id==='Pointer_ViewPointDefault')tnv.viewPointMatch=ViewEClassMatch.VP_Default;else if(!dvp.isExclusiveView)tnv.viewPointMatch=ViewEClassMatch.VP_Decorative;else tnv.viewPointMatch=ViewEClassMatch.VP_MISMATCH;if(!needsorting&&oldVpMatch!==tnv.viewPointMatch)needsorting=true;if(tnv.viewPointMatch===ViewEClassMatch.VP_MISMATCH){tnv.finalScore=ViewEClassMatch.VP_MISMATCH;continue;}// check preconditions\nif(firstEvaluationForNodeView){const oldScore=tnv.metaclassScore;tnv.metaclassScore=this.matchesMetaClassTarget(dview,data===null||data===void 0?void 0:data.__raw);needsorting=true;// sorting is mandatory here because it's the first evaluation of node-vie\n// if mismatch i stop computing the score.\nif(tnv.metaclassScore===ViewEClassMatch.MISMATCH_PRECONDITIONS){tnv.finalScore=ViewEClassMatch.MISMATCH;continue;}}else if(tnv.metaclassScore===ViewEClassMatch.MISMATCH_PRECONDITIONS)continue;if(true){// this needs to be called not only if datachanged || nodechanged, but everytime in case it is a reference like data.$value.name.length\n// also his performances are so fast that it might be more costly to check if it's supposed to be reevaluated than just calling it.\nlet jsScoreChanged=Selectors.updateJSScore(node,data,dview,tv,tnv);if(!needsorting&&jsScoreChanged)needsorting=true;// if mismatch i stop computing the score.\nif(tnv.jsScore===ViewEClassMatch.MISMATCH_JS){tnv.finalScore=ViewEClassMatch.MISMATCH;continue;}}// check pre-ocl guard\n// if (!tv.oclUpdateCondition_PARSED(data, olddata)) continue;\nif(datachanged||tnv.OCLScore===ViewEClassMatch.NOT_EVALUATED_YET){// check ocl: this can lead to mis-updating if ocl queries a reference.\n// but OCL is computationally heavy, so i decided it is now a requirement to update the model to reevaluate ocl.\nlet oldScore=tnv.OCLScore;tnv.OCLScore=OCL.test(data,dview,node);//Selectors.calculateOCLScore({data, node, dview});\ntv.oclChanged=false;if(!needsorting&&tnv.OCLScore!==oldScore)needsorting=true;if(tnv.OCLScore===ViewEClassMatch.MISMATCH_OCL){tnv.finalScore=ViewEClassMatch.MISMATCH;continue;}}}if(parentViewChanged)needsorting=true;// scores saved in dictionaries are the same, but score in final sorted array changed.\nreturn needsorting;}// get final viewstack for a node, also updates OCL scores if needed because of a change in model or parentView (NOT from a change in view)\nstatic getAppliedViewsNew(_ref){let{data:data0,node,pv,nid}=_ref;// console.trace('2302, getviews', {tnode: transientProperties.node[nid], nid, pv})\nlet state=store.getState();let needsorting=Selectors.updateScores(data0,node,nid,pv,state);let tn=transientProperties.node[nid];// needs to be placed after updateScores() which will initialize it.\nif(!needsorting&&tn.needSorting)needsorting=tn.needSorting;if(needsorting||!tn.stackViews){var _mainViews$;let mainViews=[];let decorativeViews=[];for(let vid of Object.keys(tn.viewScores)){let tnv=tn.viewScores[vid];const dview=DPointerTargetable.fromPointer(vid,state);if(!dview)console.error('missing view, is it an old save with less default views?',{dview,vid,state});if(!dview)continue;const score=tnv.finalScore=Selectors.getFinalScore(tnv,vid,pv,dview);if(!(score>0))continue;// do not flip to <=, because undefined and NEGATIVE_INFINITY always compute to false.\n(dview.isExclusiveView?mainViews:decorativeViews).push({element:vid,score,view:LPointerTargetable.fromD(dview)});}decorativeViews.sort((s1,s2)=>s2.score-s1.score);// sorted from biggest to smallest\nmainViews.sort((s1,s2)=>s2.score-s1.score);// sorted from biggest to smallest\n// Log.exDev(!mainViews[0], 'cannot find a matching main view', {mainViews, decorativeViews, data0, scores: tn.viewScores})\ntn.mainView=(_mainViews$=mainViews[0])===null||_mainViews$===void 0?void 0:_mainViews$.view;tn.validMainViews=mainViews.map(s=>s.view);// this have duplicates of newly created elements\ntn.stackViews=decorativeViews.map(s=>s.view);}// chamges to view or ocl comditiom are mot hamdled here, ut om multple mp/modes a omce\n//nb{}[]\n// if data or view changed update the score dict, them re-sort the view arr first, fimally update Sorted_modelused, Sorted_modelused\n// console.log('2302 getviews ret', {dn: data?.name, data, stack: transientProperties.node[nid].stackViews, stackn: transientProperties.node[nid].stackViews.map(v => v.name), scores: transientProperties.node[nid]});\n// throw new Error(\"stop debug\");\nreturn tn;}static getAllMP(state){if(!state)state=store.getState();let allD=Object.values(state.idlookup);return allD.filter(d=>U.isObject(d)&&Selectors.isOfSubclass(d,DModelElement));}static toObject(ptrs,state){if(!state)state=store.getState();return ptrs.map(p=>state.idlookup[p]);}static wrap(arr,state){if(!arr.length)return[];if(!state)state=store.getState();let objarr;if(typeof arr[0]===\"string\"){objarr=Selectors.toObject(arr,state);}else objarr=arr;return objarr.map(p=>RuntimeAccessibleClass.wrap(p));}static unwrap(arr){return arr.map(a=>a.__raw);}static getSubNodeElements(forGraph){let asPointers=arguments.length>1&&arguments[1]!==undefined?arguments[1]:false;let wrap=arguments.length>2&&arguments[2]!==undefined?arguments[2]:false;const state=store.getState();const g=state.idlookup[forGraph];if(asPointers)return g.subElements;const subelements=g.subElements.map(geid=>state.idlookup[geid]);if(wrap)return subelements.map(ge=>LPointerTargetable.from(ge));return subelements;}//// giordano part\nstatic getAllPackageClasses(id){const data=LPointerTargetable.from(id);let lPackage;const classes=[];if(data.className===\"DReference\"){const lClass=LPointerTargetable.from(data.father);lPackage=LPointerTargetable.from(lClass.father);}if(data.className===\"DParameter\"){const lOperation=LPointerTargetable.from(data.father);const lClass=LPointerTargetable.from(lOperation.father);lPackage=LPointerTargetable.wrap(lClass.father);}if(data.className===\"DOperation\"){const lClass=LPointerTargetable.from(data.father);lPackage=LPointerTargetable.wrap(lClass.father);}if(lPackage){for(let classifier of lPackage.classifiers){const lClassifier=LPointerTargetable.from(classifier);if(lClassifier.className===\"DClass\")classes.push(lClassifier);}}return classes;}static getAllPackageEnumerators(id){const data=LPointerTargetable.from(id);let lPackage;const enumerators=[];if(data.className===\"DAttribute\"){const lClass=LPointerTargetable.from(data.father);lPackage=LPointerTargetable.from(lClass.father);}if(data.className===\"DParameter\"){const lOperation=LPointerTargetable.from(data.father);const lClass=LPointerTargetable.from(lOperation.father);lPackage=LPointerTargetable.from(lClass.father);}if(data.className===\"DOperation\"){const lClass=LPointerTargetable.from(data.father);lPackage=LPointerTargetable.from(lClass.father);}if(lPackage){for(let classifier of lPackage.classifiers){const lClassifier=LPointerTargetable.from(classifier);if(lClassifier.className===\"DEnumerator\")enumerators.push(lClassifier);}}return enumerators;}static updateJSScore(node,data,dview,tv,tnv){let oldjsScore=tnv.jsScore;let jsConditionChanged=tv.jsConditionChanged;tv.jsConditionChanged=false;// tnv.jsScore = ViewEClassMatch.NOT_EVALUATED_YET as any as number;\nlet printstuff={name:data===null||data===void 0?void 0:data.name,jsc:tv.jsCondition,tv:{...tv},data:data&&data.__raw,node:node&&{...node.__raw},nerr:node===null||node===void 0?void 0:node.errors};if(tv.jsCondition){try{tnv.jsScore=tv.jsCondition({data,node,view:LPointerTargetable.fromD(dview),constants:tv.constants});// if (tnv.jsScore === true) tnv.jsScore = dview.jsCondition.length;\nswitch(typeof tnv.jsScore){case\"boolean\":// bool is fine if true\nif(!tnv.jsScore)tnv.jsScore=ViewEClassMatch.MISMATCH_JS;break;case\"number\":// number is fine if not NaN and > 0\nif(isNaN(tnv.jsScore)||tnv.jsScore<0)tnv.jsScore=ViewEClassMatch.MISMATCH_JS;break;default:tnv.jsScore=ViewEClassMatch.MISMATCH_JS;break;}}catch(e){var _e$message;// crash = mismatch\nLog.ee(\"failed to evaluate jsCondition: \"+((_e$message=e.message)===null||_e$message===void 0?void 0:_e$message.split(\"\\n\")[0]),{e,data,node,tnv,jsc:tv.jsCondition+''});tnv.jsScore=ViewEClassMatch.MISMATCH_JS;}}else tnv.jsScore=true;// missing condition = match\n// jsConditionChanged: because even if score didn't change, if jsc.length changed the final computed score is affected\nreturn jsConditionChanged||tnv.jsScore!==oldjsScore;}})||_class);window.Selectors=Selectors;class Scored{constructor(score,element){this.score=score;this.element=element;}}","map":{"version":3,"names":["LUser","DUser","DViewElement","DPointerTargetable","DModel","DModelElement","OCL","Log","LPointerTargetable","RuntimeAccessible","RuntimeAccessibleClass","store","U","toShortEType","NodeTransientProperties","transientProperties","ViewEClassMatch","ShortDefaultEClasses","toShortEClass","Selectors","_dec","_class","getActiveModel","_state$_lastSelected","metamodel","state","getState","selected","_lastSelected","modelElement","me","fromPointer","model","getLastSelectedModel","_state$_lastSelected2","ret","element","isMetamodel","m2","m1","instanceof","getAllViewElements","state0","ptrs","Object","values","viewelements","views","map","ptr","getViewpoints","viewpoints","getViewpoint","viewpoint","getObjects","objects","dObjects","idlookup","lObjects","dObject","push","id","getValues","dValues","lValues","dValue","getDeleted","deleted","getDefaultEcoreClass","type","shorttype","toUpperCase","EObject","getPrimitiveType","getAllPrimitiveTypes","primitiveTypes","classifiers","getFirstPrimitiveTypes","getRefEdges","pointers","refEdges","dRefEdges","getField","field","getAllAttributes","attributes","getAllEnumLiterals","enumliterals","getAllReferences","references","getAllClasses","classs","getReturnTypes","from","returnTypes","getAllClassesWithoutPrimitive","classList","splice","length","getAllEnumerators","flag","arguments","undefined","enumerators","getAllPackages","packages","getAllParameters","parameters","getAllOperations","operations","getDElement","pointer","dElement","getAllMetamodels","dModels","m2models","getAllModels","m1models","getVertex","wrap","resolvePointers","ArrayMerge0","voidvertexs","vertexs","graphvertexs","edgepoints","console","log","g","graphs","vv","v","gv","ep","p","r","getAll","Classe","condition","GClass","name","cname","className","staticClassName","toLowerCase","allIdByClassName","substr","exDev","allDByClassName","allLByClassName","e","Array","isArray","filter","getModels","getModel","caseSensitive","d","getByName","classe","getByField","value","_d$field","dfield","getViewIDs","queryJS","query","eval","matchesMetaClassTarget","data","MISMATCH_PRECONDITIONS","appliableToClasses","IMPLICIT_MATCH","ThisClass","get","gotSubclassMatch","classtarget","ClassTarget","EXACT_MATCH","classIsExtending","INHERITANCE_MATCH","isOfSubclass","classTarget","acceptEquality","getViewByIDOrNameD","_state$idlookup$name","_state$idlookup$id","__raw","getViewIdFromName","namepath","names","split","eligibleContainers","i","flatMap","keys","subViews","getAllGraphElementPointers","graphelements","edges","getFinalScore","entry","vid","parentView","dview","metaclassScore","MISMATCH","viewPointMatch","VP_MISMATCH","jsScore","MISMATCH_JS","OCLScore","pvMatch","pvScore","explicitprio","explicitApplicationPriority","_dview$jsCondition","_dview$oclCondition","jsCondition","oclCondition","defualtViewMalus","indexOf","updateScores","data0","node","nid","pv","needsorting","firstEvaluationForNode","firstEvaluationForNodeView","tn","olddata","viewSorted_modelused","pvid","oldpv","viewSorted_pvid_used","datachanged","clonedCounter","parentViewChanged","allViews","user","current","project","activevpid","activeViewpoint","tv","view","tnv","viewScores","NOT_EVALUATED_YET","dvp","oldVpMatch","VP_Explicit","VP_Default","isExclusiveView","VP_Decorative","finalScore","oldScore","jsScoreChanged","updateJSScore","test","oclChanged","MISMATCH_OCL","getAppliedViewsNew","_ref","needSorting","stackViews","_mainViews$","mainViews","decorativeViews","error","score","fromD","sort","s1","s2","mainView","validMainViews","s","getAllMP","allD","isObject","toObject","arr","objarr","unwrap","a","getSubNodeElements","forGraph","asPointers","subElements","subelements","geid","ge","getAllPackageClasses","lPackage","classes","lClass","father","lOperation","classifier","lClassifier","getAllPackageEnumerators","oldjsScore","jsConditionChanged","printstuff","jsc","nerr","errors","constants","isNaN","_e$message","ee","message","window","Scored","constructor"],"sources":["C:/0Programmi/Dev/projects/frontend/jjodel/frontend/src/redux/selectors/selectors.ts"],"sourcesContent":["import {\r\n    AbstractConstructor,\r\n    AttribETypes,\r\n    Constructor,\r\n    DAttribute,\r\n    DClass,\r\n    DClassifier,\r\n    DEnumerator,\r\n    DGraph,\r\n    DGraphElement,\r\n    DObject,\r\n    DRefEdge,\r\n    DState,\r\n    DValue,\r\n    DVoidVertex,\r\n    GObject,\r\n    LClass,\r\n    LEnumerator,\r\n    LGraphElement,\r\n    LModel,\r\n    LModelElement,\r\n    LObject,\r\n    LOperation,\r\n    LPackage,\r\n    LRefEdge,\r\n    LValue,\r\n    LViewElement,\r\n    LViewPoint,\r\n    LVoidVertex,\r\n    Pointer,\r\n    ShortAttribETypes,\r\n    Dictionary,\r\n    LUser,\r\n    DUser,\r\n    Defaults, LProject, ViewScore,\r\n    DViewElement,\r\n    DPointerTargetable,\r\n    DModel,\r\n    DModelElement,\r\n    OCL,\r\n    Log,\r\n    LPointerTargetable,\r\n    RuntimeAccessible,\r\n    RuntimeAccessibleClass,\r\n    store,\r\n    U,\r\n    toShortEType,\r\n    NodeTransientProperties, transientProperties, ViewEClassMatch, ViewTransientProperties, DProject, DViewPoint\r\n} from \"../../joiner\";\r\nimport {DefaultEClasses, ShortDefaultEClasses, toShortEClass} from \"../../common/U\";\r\n\r\n\r\n@RuntimeAccessible('Selectors')\r\nexport class Selectors{\r\n\r\n    static getActiveModel(): null|LModel {\r\n        let metamodel: null|LModel;\r\n        let state: DState & GObject = store.getState();\r\n        const selected = state._lastSelected?.modelElement;\r\n        if(selected) {\r\n            const me = LPointerTargetable.fromPointer(selected)\r\n            metamodel = (me) ? me.model : null;\r\n        } else metamodel = null;\r\n        return metamodel;\r\n    }\r\n\r\n    public static getLastSelectedModel<RET extends {m1?:LModel, m2?:LModel, model?:LModel, element?:LModelElement}>(state?: DState): RET {\r\n        state = state || store.getState();\r\n        let me = state._lastSelected?.modelElement;\r\n        if (!me) return {} as RET;\r\n        let ret: RET = {element: LPointerTargetable.fromPointer(me, state)} as RET;\r\n        ret.model = ret.element!.model\r\n        if (ret.model.isMetamodel) ret.m2 = ret.model;\r\n        else {\r\n            ret.m1 = ret.model;\r\n            ret.m2 = ret.m1.instanceof;\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    static getAllViewElements(state0?: DState): DViewElement[] {\r\n        // return Object.values(store.getState().idlookup).filter(v => v.className === DViewElement.name) as DViewElement[];\r\n        const state: GObject<DState> = state0 || store.getState();\r\n        const ptrs: Pointer<DViewElement>[] = Object.values((state).viewelements);\r\n        let views: DViewElement[] = ptrs.map<DViewElement>( (ptr) => DPointerTargetable.fromPointer(ptr, state) as DViewElement);\r\n        return views;\r\n    }\r\n    //Giordano: start\r\n\r\n    public static getViewpoints() : LViewPoint[] {\r\n        const state: DState & GObject = store.getState();\r\n        return LPointerTargetable.fromPointer(state.viewpoints);\r\n    }\r\n    public static getViewpoint() : LViewPoint {\r\n        const state: DState & GObject = store.getState();\r\n        return LPointerTargetable.fromPointer(state.viewpoint);\r\n    }\r\n\r\n    public static getObjects(): LObject[] {\r\n        let state: DState & GObject = store.getState();\r\n        const ptrs: Pointer<DObject, 0, 'N'> = Object.values((state).objects);\r\n        const dObjects: DObject[] = ptrs.map<DObject>( (ptr) => state.idlookup[ptr] as DObject);\r\n        const lObjects: LObject[] = [];\r\n        for(let dObject of dObjects) {\r\n            lObjects.push(LPointerTargetable.fromPointer(dObject.id));\r\n        }\r\n        return lObjects;\r\n    }\r\n    public static getValues(): LValue[] {\r\n        let state: DState & GObject = store.getState();\r\n        const ptrs: Pointer<DValue, 0, 'N'> = Object.values((state).values);\r\n        const dValues: DValue[] = ptrs.map<DValue>( (ptr) => state.idlookup[ptr] as DValue);\r\n        const lValues: LValue[] = [];\r\n        for(let dValue of dValues) {\r\n            if(dValue?.id) {\r\n                lValues.push(LPointerTargetable.fromPointer(dValue.id));\r\n            }\r\n        }\r\n        return lValues;\r\n    }\r\n\r\n    public static getDeleted(): string [] {\r\n        const state: DState & GObject = store.getState();\r\n        return state.deleted;\r\n    }\r\n\r\n    public static getState(): any {\r\n        const state: DState & GObject = store.getState();\r\n        return state;\r\n    }\r\n\r\n    static getDefaultEcoreClass(type: DefaultEClasses | ShortDefaultEClasses, state?: DState): DClassifier {\r\n        let shorttype: string = (toShortEClass(type as any) || type).toUpperCase();\r\n        if (!state) state = store.getState();\r\n        // todo: make other m3 classes and make this generic like getPrimitiveType\r\n        return state.idlookup[\"Pointer_\"+ShortDefaultEClasses.EObject.toUpperCase()] as DClassifier;\r\n    }\r\n    static getPrimitiveType(type: AttribETypes | ShortAttribETypes, state?: DState): DClassifier {\r\n        let shorttype: string = (toShortEType(type as any) || type).toUpperCase();\r\n        if (!state) state = store.getState();\r\n        return state.idlookup[\"Pointer_\"+shorttype] as DClassifier;\r\n    }\r\n    static getAllPrimitiveTypes(): DClassifier[] {\r\n        let state: DState & GObject = store.getState();\r\n        const ptrs: Pointer<DClassifier, 0, 'N'> = Object.values((state).primitiveTypes);\r\n        const classifiers: DClassifier[] = ptrs.map<DClassifier>( (ptr) => state.idlookup[ptr] as DClassifier);\r\n        return classifiers;\r\n    }\r\n    static getFirstPrimitiveTypes(): DClassifier {\r\n        return Selectors.getAllPrimitiveTypes()[0];\r\n    }\r\n    static getRefEdges(): DRefEdge[] {\r\n        const state: DState & GObject = store.getState();\r\n        const pointers: Pointer<DRefEdge, 0, 'N', LRefEdge> = Object.values((state).refEdges);\r\n        const dRefEdges: DRefEdge[] = pointers.map<DRefEdge>( (ptr) => state.idlookup[ptr] as DRefEdge);\r\n        return dRefEdges;\r\n    }\r\n    static getField(field: string): string[] {\r\n        let state: DState & GObject = store.getState();\r\n        const pointers: Pointer<DModelElement, 0, 'N'> = Object.values((state)[field]);\r\n        return pointers;\r\n    }\r\n\r\n    static getAllAttributes(): string[] {\r\n        const state: DState = store.getState();\r\n        return Object.values((state).attributes);\r\n    }\r\n    static getAllEnumLiterals(): string[] {\r\n        const state: DState = store.getState();\r\n        return Object.values((state).enumliterals);\r\n    }\r\n    static getAllReferences(): string[] {\r\n        const state: DState = store.getState();\r\n        return Object.values((state).references);\r\n    }\r\n    // static getAllReferenceEdges(): string[] { const state: DState = store.getState(); return Object.values((state).refEdges); }\r\n    static getAllClasses(): string[] {\r\n        const state: DState = store.getState();\r\n        return Object.values((state).classs);\r\n    }\r\n    static getReturnTypes(): LClass[] {\r\n        const state: DState = store.getState();\r\n        return LPointerTargetable.from(Object.values((state).returnTypes));\r\n    }\r\n\r\n    static getAllClassesWithoutPrimitive(): string[] {\r\n        // this solution does not look good. what if a primitive type is inserted at runtime in between?\r\n        // coould reach the same goal by taking all Classes of a model (m2), excluding classes from other models (types are classes from m3 model)\r\n        const state: DState = store.getState();\r\n        const classList: string[] = Object.values((state).classs);\r\n        classList.splice(0, Selectors.getAllPrimitiveTypes().length);\r\n        /* todo: need to change it in something like this once cross-references between models and instances are implemented\r\n        const m2: LModel;\r\n        m2.isInstanceOf = m3 as LModel;\r\n        m2.isInstanceOf.classes;*/\r\n\r\n        return classList;\r\n    }\r\n\r\n    static getAllEnumerators(flag = false): string[] {\r\n        const state: DState = store.getState();\r\n        return Object.values((state).enumerators);\r\n    }\r\n    static getAllPackages(): string[] {\r\n        const state: DState = store.getState();\r\n        return Object.values((state).packages);\r\n    }\r\n\r\n    static getAllParameters(): string[] {\r\n        const state: DState = store.getState();\r\n        return Object.values((state).parameters);\r\n    }\r\n    static getAllOperations(): string[] {\r\n        const state: DState = store.getState();\r\n        return Object.values((state).operations);\r\n    }\r\n\r\n    static getDElement<T extends DModelElement>(pointer: string): T {\r\n        const state: DState & GObject = store.getState();\r\n        const dElement: T = state.idlookup[pointer] as T;\r\n        return dElement;\r\n    }\r\n\r\n    static getAllMetamodels(): LModel[] {\r\n        const state: DState = store.getState();\r\n        const dModels = Object.values((state).m2models);\r\n        return LPointerTargetable.fromPointer(dModels);\r\n    }\r\n\r\n    static getAllModels(): LModel[] {\r\n        const state: DState = store.getState();\r\n        const dModels = Object.values((state).m1models);\r\n        return LPointerTargetable.fromPointer(dModels);\r\n    }\r\n\r\n    //Giordano: end\r\n\r\n    static getVertex<W extends boolean = true, RP extends boolean = true>(wrap?: W /* = true */, resolvePointers?: RP /**/):\r\n        W extends false ? (RP extends false ? Pointer<DVoidVertex, 1, 1, LVoidVertex>[] : DVoidVertex[]) : LVoidVertex[] {\r\n        const state: DState = store.getState();\r\n        let ptrs: Pointer<DVoidVertex>[] = [];\r\n\r\n        U.ArrayMerge0(false, ptrs,\r\n            // Object.values(state.graphs || {}),\r\n            Object.values(state.voidvertexs || {}),\r\n            Object.values(state.vertexs || {}),\r\n            Object.values(state.graphvertexs || {}),\r\n            Object.values(state.edgepoints || {}));\r\n\r\n        console.log('selector getvertex: ', {ptrs, g: Object.values(state.graphs || {}), vv:Object.values(state.voidvertexs || {}), v:Object.values(state.vertexs || {}), gv:Object.values(state.graphvertexs || {}), ep:Object.values(state.edgepoints || {})});\r\n        if (wrap === undefined || wrap === true) return ptrs.map( p => DPointerTargetable.wrap(p)) as any[];\r\n        if (resolvePointers === undefined || resolvePointers === true) return ptrs.map( r => state.idlookup[r]) as any[];\r\n        return ptrs as any[];\r\n    }\r\n\r\n    static getAll<D extends DPointerTargetable, L extends LPointerTargetable, DT extends typeof DPointerTargetable = typeof DPointerTargetable,\r\n        W extends undefined | true | false = false, RP extends undefined | true | false = true, RET = W extends false ? (RP extends false ? Pointer<D, 1, 1, L> : D) : L>\r\n        (Classe?: DT, condition?: (e:RET) => boolean, state?: DState, resolvePointers?: RP /**/, wrap?: W /* = true */): RET[] {\r\n        if (!state) state = store.getState();\r\n        let GClass = (Classe as GObject) || {name:\"idlookup\", cname:\"idlookup\"};\r\n        const className: string = (GClass?.staticClassName || GClass.cname).toLowerCase();\r\n        const allIdByClassName: Pointer<D, 1, 1, L>[]\r\n            = (state as GObject)[className]\r\n            || (state as GObject)[className.substr(1)]\r\n            || (state as GObject)[className + 's']\r\n            || (state as GObject)[className.substr(1) + 's'];\r\n        Log.exDev(!allIdByClassName, 'cannot find store key:', {state, className, Classe});\r\n        let allDByClassName: D[] | null = null;\r\n        let allLByClassName: L[] | null = null;\r\n        if (resolvePointers || wrap) {\r\n            allDByClassName = allIdByClassName.map( (e) => (state as DState).idlookup[e] ) as D[];\r\n            if (wrap) {\r\n                allLByClassName = allDByClassName.map( e => DPointerTargetable.wrap(e)) as any as L[];\r\n            }\r\n        }\r\n        let ret: RET[] = (resolvePointers || wrap ? (wrap ? allLByClassName : allDByClassName) : allIdByClassName) as any[] as RET[];\r\n        if (!Array.isArray(ret)) ret = Object.values(ret).filter(e => e instanceof Object) as RET[];\r\n        if (condition) return ret.filter( e => condition(e));\r\n        return ret;\r\n    }\r\n\r\n    static getModels(condition?: (m: DModel) => boolean): DModel[] { return Selectors.getAll(DModel, undefined, undefined, true, false); }\r\n\r\n    static getModel(name: string, caseSensitive: boolean = false, wrap: boolean = false): DModel | LModel | null {\r\n        if (!caseSensitive) name = name.toLowerCase();\r\n        let ret = Selectors.getAll<DModel, LModel>(DModel, (d) => (caseSensitive ? d.name : d.name.toLowerCase()) === name, undefined, true, wrap as any)[0];\r\n        return ret;\r\n    }\r\n\r\n    static getByName(classe: typeof DPointerTargetable, name: string, caseSensitive: boolean = false, wrap: boolean = false): DPointerTargetable | LPointerTargetable | null {\r\n        return Selectors.getByField(classe, 'name', name, caseSensitive, wrap); }\r\n\r\n    static getByField(classe: typeof DPointerTargetable, field: string, value: string, caseSensitive: boolean = false, wrap: boolean = false): DPointerTargetable | LPointerTargetable | null {\r\n        if (!caseSensitive) value = value.toLowerCase();\r\n        let condition = (d: any) => {\r\n            let ret = (caseSensitive ? d[field] : d[field]?.toLowerCase()) === value;\r\n            console.log('filtering getall by field:', {d, dfield:d[field], value, ret});\r\n            return ret;\r\n        }\r\n        let ret = Selectors.getAll(classe, condition, undefined, true, wrap as any)[0];\r\n        return ret; }\r\n\r\n    static getViewIDs(condition?: (m: DModel) => boolean): Pointer<DViewElement>[] { return Selectors.getAll(DViewElement); }\r\n\r\n\r\n\r\n    private static queryJS(model: LModel, query: string): LPointerTargetable[] {\r\n        try {\r\n            return eval(query);\r\n        } catch (e) { return []; }\r\n    }\r\n    /*static getCurrentView(data: LModelElement): DViewElement {\r\n        Log.exDevv('todo');\r\n        return undefined as any;\r\n    }*/\r\n\r\n    private static matchesMetaClassTarget(v: DViewElement, data?: DModelElement | DGraphElement | undefined): number {\r\n        if (!v) return ViewEClassMatch.MISMATCH_PRECONDITIONS;\r\n        if (!v.appliableToClasses || !v.appliableToClasses.length) return ViewEClassMatch.IMPLICIT_MATCH;\r\n        if (!data) return ViewEClassMatch.MISMATCH_PRECONDITIONS;\r\n        let ThisClass: typeof DPointerTargetable = RuntimeAccessibleClass.get(data.className);\r\n        Log.exDev(!ThisClass, 'unable to find class type:', {v, data}); // todo: v = view appliable to DModel, data = proxy<LModel>\r\n        let gotSubclassMatch: boolean = false;\r\n        for (let classtarget of v.appliableToClasses) {\r\n            const ClassTarget: typeof DPointerTargetable = RuntimeAccessibleClass.get(classtarget);\r\n            if (ThisClass === ClassTarget) return ViewEClassMatch.EXACT_MATCH; // explicit exact match\r\n            if (!gotSubclassMatch && U.classIsExtending(ThisClass, ClassTarget)) gotSubclassMatch = true; // explicit subclass match\r\n            if (gotSubclassMatch) return ViewEClassMatch.INHERITANCE_MATCH;\r\n        }\r\n        return ViewEClassMatch.MISMATCH_PRECONDITIONS;\r\n }\r\n\r\n    private static isOfSubclass(data: DPointerTargetable, classTarget: string | typeof DPointerTargetable, acceptEquality: boolean = false): boolean {\r\n        let ThisClass: typeof DPointerTargetable = RuntimeAccessibleClass.get(data.className);\r\n        Log.exDev(!ThisClass, 'isOfSubclass() unable to find class type:', {data});\r\n        const ClassTarget: typeof DPointerTargetable = typeof classTarget === \"string\"? RuntimeAccessibleClass.get(classTarget) : classTarget;\r\n        if (ThisClass === ClassTarget) return acceptEquality;\r\n        return U.classIsExtending(ThisClass, ClassTarget);\r\n    }\r\n\r\n\r\n    static getViewByIDOrNameD(name: string | DViewElement | LViewElement, state?: DState): undefined | DViewElement {\r\n        if (!state) state = store.getState();\r\n        if (typeof name === \"object\") { return (name as any).__raw || name as any; }\r\n        if (state.idlookup[name]?.className === DViewElement.cname) return state.idlookup[name] as DViewElement;\r\n        let id = Selectors.getViewIdFromName(name, state);\r\n        if (id && state.idlookup[id]?.className === DViewElement.cname) return state.idlookup[id] as DViewElement;\r\n        return undefined;\r\n    }\r\n\r\n\r\n    // input: \"subview.subview2.targetview\"\r\n    // output: returns pointer to targetview\r\n    // path is not required to start with a root, it's also possible to start navigating from a subview (notviewpoint/model view)\r\n    // in case multiple matches are given due to incomplete path not starting from a viewpoint, the oldest matching view is returned.\r\n    static getViewIdFromName(namepath: string, state?: DState): undefined | Pointer<DViewElement> {\r\n        if (!state) state = store.getState();\r\n        let names: string[] = namepath.split(\".\");\r\n        let eligibleContainers: Pointer<DViewElement>[] = state.viewelements;\r\n        for (let i = 0; i < names.length; i++) {\r\n            let name = names[i];\r\n            eligibleContainers = eligibleContainers.filter(v => ((state as DState).idlookup[v] as DViewElement).name === name);\r\n            if (i === names.length-1 || eligibleContainers.length === 0) return eligibleContainers[0];\r\n            eligibleContainers = eligibleContainers.flatMap(v => Object.keys(((state as DState).idlookup[v] as DViewElement).subViews));\r\n        }\r\n        return undefined;\r\n    }\r\n\r\n    static getAllGraphElementPointers(): Pointer<DGraphElement>[] {\r\n        // graphelements = fields;\r\n        let state: DState = store.getState();\r\n        return [...state.graphs, ...state.graphvertexs, ...state.graphelements, ...state.vertexs, ...state.edgepoints, ...state.edges];\r\n    }\r\n\r\n    private static getFinalScore(entry: ViewScore, vid: Pointer<DViewElement>, parentView: DViewElement | undefined, dview: DViewElement): number {\r\n        if (entry.metaclassScore === ViewEClassMatch.MISMATCH_PRECONDITIONS) return ViewEClassMatch.MISMATCH;\r\n        if (entry.viewPointMatch === ViewEClassMatch.VP_MISMATCH) return ViewEClassMatch.MISMATCH;\r\n        if (entry.jsScore === ViewEClassMatch.MISMATCH_JS || entry.OCLScore === ViewEClassMatch.MISMATCH_JS) return ViewEClassMatch.MISMATCH;\r\n        let pvMatch: boolean = parentView ? vid in parentView.subViews : false;\r\n        let pvScore: number = pvMatch ? (parentView as DViewElement).subViews[vid] : 1;\r\n        let explicitprio: number;\r\n        if (typeof entry.jsScore === 'number') {\r\n            explicitprio = entry.jsScore;\r\n        } else if (dview.explicitApplicationPriority === undefined) {\r\n            // in editor put placeholder with computed expression\r\n            explicitprio = (dview.jsCondition?.length || 1) + (dview.oclCondition?.length || 1);\r\n        } else explicitprio = dview.explicitApplicationPriority;\r\n\r\n        //console.log(\"getFinalScore\", {entry, vid, dview, explicitprio, ep:dview.explicitApplicationPriority})\r\n\r\n        let defualtViewMalus = dview.id.indexOf('View') >= 0 ? 0 : 0.1;\r\n        return entry.viewPointMatch * entry.metaclassScore * pvScore * explicitprio + defualtViewMalus;\r\n        //score = precoditiom * paremtview(comfiguravle) * (explicitprio = jsValid*jslemgth + oclvalid*ocllemgth)\r\n        // or if jscomditiom returmed mumver --> * jsscore\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n/*\r\n    //this function handles: what i do when view changes? do i recompute the score?\r\n    static updateViewMatchings(dview: DViewElement, updatePreconditions: boolean, updateOCLScore: boolean, store: DState, updateManualViews: boolean = false, forcedUpdateViews: boolean = false): void {\r\n\r\n        //  event           observed change         ignore change\r\n        //  ocl             data                    node, view (except view.ocl)\r\n        //  jsCondition     all                     none\r\n        //  appliableTo     view.appliableto\r\n        // if (!forcedUpdateViews && (dview.oclUpdateCondition === 'manual') !== updateManualViews) return;\r\n        // modularize getscoresnew split in setpreconditionscore, setoclscorem, setjscscore, and call those only if observed stuff changed\r\n\r\n        const allNodes: DGraphElement[] = DPointerTargetable.fromPointer(Selectors.getAllGraphElementPointers());\r\n        //let dview = view.__raw;\r\n        let vid = dview.id; // optimize searching multiple usages and replacing\r\n\r\n        // filter alldata to exclude modelpieces that didn't pass the view.appyto check\r\n        // let oclData: (LModelElement)[] = allData.filter(l => {\r\n        let oclnodes: (DGraphElement)[] = allNodes.filter((dg: DGraphElement) => {\r\n            if (!dg) return false;\r\n            if (true) {\r\n                let d: DModelElement | undefined = dg.model ? DPointerTargetable.fromPointer(dg.model) : undefined;\r\n                let firstEvaluationForNodeView: boolean = false;\r\n                if (!transientProperties.node[dg.id]) { transientProperties.node[dg.id] = {viewScores: {}} as any; firstEvaluationForNodeView = true; }\r\n                if (!transientProperties.node[dg.id].viewScores[vid]) { transientProperties.node[dg.id].viewScores[vid] = {score: undefined} as any; firstEvaluationForNodeView = true; }\r\n\r\n                if (firstEvaluationForNodeView || updatePreconditions) {\r\n                    const oldScore = transientProperties.node[dg.id].viewScores[vid].score;\r\n                    const newScore = transientProperties.node[dg.id].viewScores[vid].score = this.matchesMetaClassTarget(dview, d);\r\n                    if (oldScore !== newScore) transientProperties.node[dg.id].stackViews = undefined as any; // force re-sorting\r\n                    // 67{}[]'?^&&||nb>\r\n                } /* else {\r\n                    if (!transientProperties.view[dview.id].oclUpdateCondition_PARSED( transientProperties.node[dg.id].viewScores[vid].)) return;\r\n                }* /\r\n                // no need to check if parentview changed as well. i optimized by not having parentview affect the numeric scores, but only the view queue array sorting\r\n\r\n                // transient.node[dg.id].viewScores[vid].score = MISSING (hasOwnProperty);    if the view or model is new and they are not yet evaluated.\r\n                // transient.node[dg.id].viewScores[vid].score = Number.NEGATIVE_INFINITY;    if pre-ocl conditions failed (view.appliableTo)\r\n                // transient.node[dg.id].viewScores[vid].score = 0;                           if preconditions are met, but ocl failed\r\n                // transient.node[dg.id].viewScores[vid].score = number ocl score;            if preconditions are met and ocl matched\r\n                // transient.node[dg.id].viewScores[vid].score = number precondition score;   if preconditions are met, and there is no ocl condition\r\n                // changed: matching score and ocl score are summed.\r\n                return transientProperties.node[dg.id].viewScores[vid].score !== undefined;\r\n            }\r\n\r\n            // if (model_viewstack[vid]) { filledElementsInOclData++; return l; } return undefined;\r\n        });\r\n        function mergeViewScores(preconditionScore: number, oclScore: number): number{ return preconditionScore + oclScore; }\r\n    }*/\r\n\r\n\r\n\r\n\r\n    static updateScores(data0: LModelElement | undefined, node: LGraphElement | undefined, nid: Pointer<DGraphElement>, pv: DViewElement | undefined, state: DState){\r\n        let needsorting: boolean = false;\r\n        let firstEvaluationForNode: boolean = false;\r\n        let firstEvaluationForNodeView: boolean = false;\r\n        let tn = transientProperties.node[nid];\r\n        if (!tn) { transientProperties.node[nid] = tn = new NodeTransientProperties(); firstEvaluationForNode = true; }\r\n        let olddata = tn.viewSorted_modelused as LModelElement;\r\n        //let oldnode = transientProperties.node[nid]?.viewSorted_nodeused as LGraphElement;\r\n        const data: LModelElement = data0 as LModelElement;\r\n        // console.error('changed', {data, olddata, node, oldnode, cdata:data?.clonedCounter, colddata:olddata?.clonedCounter})\r\n        const pvid: Pointer<DViewElement> | undefined = pv?.id;\r\n        const oldpv: DViewElement | undefined = tn.viewSorted_pvid_used;\r\n        let datachanged: boolean = (!!data !== !!olddata) || !!(data && olddata) && (data.clonedCounter !== olddata.clonedCounter);\r\n        //let nodechanged: boolean = (!!node !== !!oldnode) || !!(node && oldnode) && (node.clonedCounter !== oldnode.clonedCounter);\r\n        let parentViewChanged: boolean = (pvid !== oldpv?.id || (!!(pv && oldpv) && oldpv.subViews !== pv.subViews)); // shallow comparison is fine.\r\n        if (parentViewChanged) tn.viewSorted_pvid_used = pv;\r\n        //if (nodechanged) transientProperties.node[nid].viewSorted_nodeused = node;\r\n        if (datachanged) tn.viewSorted_modelused = data;\r\n\r\n        // let nodechanged: boolean\r\n        // important to remember: how i'm using parentView in score and storage.\r\n        // i'm calculating and storing every score without parentView, then i apply it right before sorting the array,\r\n        // the enhanced value is not sored anyway but affects array sorting.\r\n        // so if parentView changes, or if his subviews changed, need to resort array without recomputing any score value.\r\n\r\n        //console.log('2302, getviews 2', {datachanged, nodechanged, olddata, oldnode, data, node, allViews: Selectors.getAllViewElements()});\r\n\r\n        if (!state) state = store.getState();\r\n        const allViews: DViewElement[] = Selectors.getAllViewElements(state);\r\n\r\n        const user = LUser.fromPointer(DUser.current);\r\n        const project = user.project as LProject;\r\n        let activevpid: Pointer<DViewElement> = project.activeViewpoint.id;\r\n        // check if scores needs to be updated\r\n        for (const dview of allViews) {\r\n            let vid = dview.id;\r\n            let tv = transientProperties.view[vid];\r\n            if (!tv) transientProperties.view[vid] = tv = {} as any;\r\n            let tnv = tn.viewScores[vid];\r\n            //console.log('2302, getviews evaluating view ' + vid, {vid, dview});\r\n            // check initialization\r\n\r\n            if (!tnv) {\r\n                transientProperties.node[nid].viewScores[vid] = tnv = {} as any;\r\n                /*{\r\n                    score: ViewEClassMatch.NOT_EVALUATED_YET,\r\n                    metaclassScore: ViewEClassMatch.NOT_EVALUATED_YET,\r\n                    //jsScore:ViewEClassMatch.NOT_EVALUATED_YET,\r\n                    //OCLScore: ViewEClassMatch.NOT_EVALUATED_YET\r\n                } as any;*/\r\n                firstEvaluationForNodeView = true;\r\n            } else firstEvaluationForNodeView = tnv.metaclassScore === ViewEClassMatch.NOT_EVALUATED_YET; // todo: when changing view.appliableTo, delete all tnv using that view.\r\n\r\n            // don't match exclusive views from other vp\r\n            let dvp: DViewPoint = DPointerTargetable.fromPointer(dview.viewpoint, state);\r\n            let oldVpMatch: number = tnv.viewPointMatch;\r\n            // console.log(\"vp matching \" +vid, {vid, dvp, activevpid });\r\n            if (dvp.id === activevpid) tnv.viewPointMatch = ViewEClassMatch.VP_Explicit;\r\n            else if (dvp.id === 'Pointer_ViewPointDefault') tnv.viewPointMatch = ViewEClassMatch.VP_Default;\r\n            else if (!dvp.isExclusiveView) tnv.viewPointMatch = ViewEClassMatch.VP_Decorative;\r\n            else tnv.viewPointMatch = ViewEClassMatch.VP_MISMATCH;\r\n\r\n            if (!needsorting && (oldVpMatch !== tnv.viewPointMatch)) needsorting = true;\r\n            if (tnv.viewPointMatch === ViewEClassMatch.VP_MISMATCH) {\r\n                tnv.finalScore = ViewEClassMatch.VP_MISMATCH;\r\n                continue;\r\n            }\r\n\r\n\r\n            // check preconditions\r\n            if (firstEvaluationForNodeView) {\r\n                const oldScore = tnv.metaclassScore;\r\n                tnv.metaclassScore = this.matchesMetaClassTarget(dview, data?.__raw);\r\n                needsorting = true; // sorting is mandatory here because it's the first evaluation of node-vie\r\n                // if mismatch i stop computing the score.\r\n                if (tnv.metaclassScore === ViewEClassMatch.MISMATCH_PRECONDITIONS) {\r\n                    tnv.finalScore = ViewEClassMatch.MISMATCH;\r\n                    continue;\r\n                }\r\n            } else if (tnv.metaclassScore === ViewEClassMatch.MISMATCH_PRECONDITIONS) continue;\r\n\r\n            if (true) {\r\n                // this needs to be called not only if datachanged || nodechanged, but everytime in case it is a reference like data.$value.name.length\r\n                // also his performances are so fast that it might be more costly to check if it's supposed to be reevaluated than just calling it.\r\n                let jsScoreChanged: boolean = Selectors.updateJSScore(node, data, dview, tv, tnv);\r\n                if (!needsorting && jsScoreChanged) needsorting = true;\r\n                // if mismatch i stop computing the score.\r\n                if (tnv.jsScore === ViewEClassMatch.MISMATCH_JS) { tnv.finalScore = ViewEClassMatch.MISMATCH; continue; }\r\n            }\r\n\r\n            // check pre-ocl guard\r\n            // if (!tv.oclUpdateCondition_PARSED(data, olddata)) continue;\r\n\r\n            if (datachanged || tnv.OCLScore === ViewEClassMatch.NOT_EVALUATED_YET) {\r\n                // check ocl: this can lead to mis-updating if ocl queries a reference.\r\n                // but OCL is computationally heavy, so i decided it is now a requirement to update the model to reevaluate ocl.\r\n                let oldScore = tnv.OCLScore;\r\n                tnv.OCLScore = OCL.test(data, dview, node)//Selectors.calculateOCLScore({data, node, dview});\r\n                tv.oclChanged = false;\r\n                if (!needsorting && tnv.OCLScore !== oldScore) needsorting = true;\r\n                if (tnv.OCLScore === ViewEClassMatch.MISMATCH_OCL) { tnv.finalScore = ViewEClassMatch.MISMATCH; continue; }\r\n            }\r\n        }\r\n\r\n        if (parentViewChanged) needsorting = true; // scores saved in dictionaries are the same, but score in final sorted array changed.\r\n        return needsorting;\r\n    }\r\n\r\n    // get final viewstack for a node, also updates OCL scores if needed because of a change in model or parentView (NOT from a change in view)\r\n    static getAppliedViewsNew({data:data0, node, pv, nid}:{ node: LGraphElement | undefined; data: LModelElement | undefined; pv: DViewElement | undefined; nid: Pointer<DGraphElement>}): NodeTransientProperties {\r\n        // console.trace('2302, getviews', {tnode: transientProperties.node[nid], nid, pv})\r\n        let state = store.getState();\r\n        let needsorting: boolean = Selectors.updateScores(data0, node, nid, pv, state);\r\n\r\n        let tn: NodeTransientProperties = transientProperties.node[nid]; // needs to be placed after updateScores() which will initialize it.\r\n        if (!needsorting && tn.needSorting) needsorting = tn.needSorting;\r\n\r\n        type ViewScoreEntry = {element: Pointer<DViewElement>, score: number, view: LViewElement};\r\n        if (needsorting || !tn.stackViews) {\r\n            let mainViews: ViewScoreEntry[] = [];\r\n            let decorativeViews: ViewScoreEntry[] = [];\r\n            for (let vid of Object.keys(tn.viewScores)) {\r\n                let tnv = tn.viewScores[vid];\r\n                const dview: DViewElement = DPointerTargetable.fromPointer(vid, state);\r\n                if (!dview) console.error('missing view, is it an old save with less default views?', {dview, vid, state});\r\n                if (!dview) continue;\r\n\r\n                const score = tnv.finalScore = Selectors.getFinalScore(tnv, vid, pv, dview);\r\n                if (!(score > 0)) continue; // do not flip to <=, because undefined and NEGATIVE_INFINITY always compute to false.\r\n                (dview.isExclusiveView ? mainViews : decorativeViews).push( {element:vid, score, view: LPointerTargetable.fromD(dview)} );\r\n            }\r\n            decorativeViews.sort((s1, s2)=> s2.score - s1.score); // sorted from biggest to smallest\r\n            mainViews.sort((s1, s2)=> s2.score - s1.score); // sorted from biggest to smallest\r\n\r\n            // Log.exDev(!mainViews[0], 'cannot find a matching main view', {mainViews, decorativeViews, data0, scores: tn.viewScores})\r\n            tn.mainView = mainViews[0]?.view;\r\n            tn.validMainViews = mainViews.map((s)=> s.view); // this have duplicates of newly created elements\r\n            tn.stackViews = decorativeViews.map((s)=> s.view);\r\n        }\r\n        // chamges to view or ocl comditiom are mot hamdled here, ut om multple mp/modes a omce\r\n        //nb{}[]\r\n\r\n        // if data or view changed update the score dict, them re-sort the view arr first, fimally update Sorted_modelused, Sorted_modelused\r\n        // console.log('2302 getviews ret', {dn: data?.name, data, stack: transientProperties.node[nid].stackViews, stackn: transientProperties.node[nid].stackViews.map(v => v.name), scores: transientProperties.node[nid]});\r\n\r\n        // throw new Error(\"stop debug\");\r\n        return tn;\r\n\r\n    }\r\n\r\n    static getAllMP(state?: DState): DModelElement[] {\r\n        if (!state) state = store.getState();\r\n        let allD: DPointerTargetable[] = Object.values(state.idlookup);\r\n        return allD.filter( (d: DPointerTargetable) => U.isObject(d) && Selectors.isOfSubclass(d, DModelElement)) as DModelElement[]; }\r\n\r\n    static toObject<D extends DPointerTargetable>(ptrs: Pointer<D>[], state?: DState):D[] {\r\n        if (!state) state = store.getState();\r\n        return ptrs.map(p => (state as DState).idlookup[p]) as D[]; }\r\n\r\n    static wrap<D extends DPointerTargetable, L extends LPointerTargetable>(arr: (Pointer<D, 1, 1, L> | D)[], state?: DState): L[] {\r\n        if (!arr.length) return [];\r\n        if (!state) state = store.getState();\r\n        let objarr: D[];\r\n        if (typeof arr[0] === \"string\") { objarr = Selectors.toObject(arr as string[], state); }\r\n        else objarr = arr as D[];\r\n        return objarr.map(p => RuntimeAccessibleClass.wrap(p)) as L[]; }\r\n\r\n    static unwrap<D extends DPointerTargetable, L extends LPointerTargetable>(arr:L[]): D[] { return arr.map( (a)=> a.__raw) as any[]; }\r\n    static getSubNodeElements(forGraph: Pointer<DGraph, 1, 1>, asPointers: boolean = false, wrap: boolean = false): Pointer<DGraphElement>[] | DGraphElement[] | LGraphElement[] {\r\n        const state : DState = store.getState();\r\n        const g: DGraph = state.idlookup[forGraph] as DGraph;\r\n        if (asPointers) return g.subElements;\r\n        const subelements: DGraphElement[] = g.subElements.map( geid => state.idlookup[geid]) as DGraphElement[];\r\n        if (wrap) return subelements.map<LGraphElement>( (ge) => LPointerTargetable.from(ge));\r\n        return subelements; }\r\n\r\n\r\n\r\n\r\n    //// giordano part\r\n\r\n\r\n\r\n    public static getAllPackageClasses(id: string): LClass[] {\r\n        const data = LPointerTargetable.from(id) as GObject;\r\n        let lPackage : LPackage | undefined;\r\n        const classes: LClass[] = [];\r\n        if (data.className === \"DReference\") {\r\n            const lClass: LClass = LPointerTargetable.from(data.father);\r\n            lPackage = LPointerTargetable.from(lClass.father);\r\n        }\r\n        if (data.className === \"DParameter\") {\r\n            const lOperation: LOperation = LPointerTargetable.from(data.father);\r\n            const lClass: LClass = LPointerTargetable.from(lOperation.father);\r\n            lPackage = LPointerTargetable.wrap(lClass.father);\r\n        }\r\n        if (data.className === \"DOperation\") {\r\n            const lClass: LClass = LPointerTargetable.from(data.father);\r\n            lPackage = LPointerTargetable.wrap(lClass.father);\r\n        }\r\n        if (lPackage) {\r\n            for(let classifier of lPackage.classifiers) {\r\n                const lClassifier: LClass | LEnumerator = LPointerTargetable.from(classifier);\r\n                if(lClassifier.className === \"DClass\") classes.push(lClassifier as LClass);\r\n            }\r\n        }\r\n        return classes;\r\n    }\r\n    public static getAllPackageEnumerators(id: string): LEnumerator[] {\r\n        const data = LPointerTargetable.from(id) as GObject;\r\n        let lPackage : LPackage | undefined;\r\n        const enumerators: LEnumerator[] = [];\r\n        if(data.className === \"DAttribute\") {\r\n            const lClass: LClass = LPointerTargetable.from(data.father);\r\n            lPackage = LPointerTargetable.from(lClass.father);\r\n        }\r\n        if(data.className === \"DParameter\") {\r\n            const lOperation: LOperation = LPointerTargetable.from(data.father);\r\n            const lClass: LClass = LPointerTargetable.from(lOperation.father);\r\n            lPackage = LPointerTargetable.from(lClass.father);\r\n        }\r\n        if(data.className === \"DOperation\") {\r\n            const lClass: LClass = LPointerTargetable.from(data.father);\r\n            lPackage = LPointerTargetable.from(lClass.father);\r\n        }\r\n        if(lPackage) {\r\n            for(let classifier of lPackage.classifiers) {\r\n                const lClassifier: LClass | LEnumerator = LPointerTargetable.from(classifier);\r\n                if(lClassifier.className === \"DEnumerator\") enumerators.push(lClassifier as LEnumerator);\r\n            }\r\n        }\r\n        return enumerators;\r\n    }\r\n\r\n    private static updateJSScore(node: LGraphElement | undefined, data: LModelElement | undefined, dview: DViewElement, tv: ViewTransientProperties, tnv: ViewScore) {\r\n        let oldjsScore = tnv.jsScore;\r\n        let jsConditionChanged: boolean = tv.jsConditionChanged;\r\n        tv.jsConditionChanged = false;\r\n\r\n        // tnv.jsScore = ViewEClassMatch.NOT_EVALUATED_YET as any as number;\r\n        let printstuff = {name: data?.name, jsc:tv.jsCondition, tv:{...tv}, data:data&&data.__raw, node:node&&{...node.__raw}, nerr: (node as any)?.errors}\r\n        if (tv.jsCondition) {\r\n            try {\r\n                tnv.jsScore = tv.jsCondition({data, node, view: LPointerTargetable.fromD(dview), constants: tv.constants});\r\n                // if (tnv.jsScore === true) tnv.jsScore = dview.jsCondition.length;\r\n                switch (typeof tnv.jsScore) {\r\n                    case \"boolean\": // bool is fine if true\r\n                        if (!tnv.jsScore) tnv.jsScore = ViewEClassMatch.MISMATCH_JS;\r\n                        break;\r\n                    case \"number\": // number is fine if not NaN and > 0\r\n                        if (isNaN(tnv.jsScore) || tnv.jsScore < 0) tnv.jsScore = ViewEClassMatch.MISMATCH_JS;\r\n                        break;\r\n                    default:\r\n                        tnv.jsScore = ViewEClassMatch.MISMATCH_JS;\r\n                        break;\r\n                }\r\n            }\r\n            catch (e:any) { // crash = mismatch\r\n                Log.ee(\"failed to evaluate jsCondition: \" + e.message?.split(\"\\n\")[0], {e, data, node, tnv, jsc:tv.jsCondition+''});\r\n                tnv.jsScore = ViewEClassMatch.MISMATCH_JS;\r\n            }\r\n        } else tnv.jsScore = true; // missing condition = match\r\n\r\n        // jsConditionChanged: because even if score didn't change, if jsc.length changed the final computed score is affected\r\n        return jsConditionChanged || tnv.jsScore !== oldjsScore;\r\n    }\r\n}\r\n\r\n(window as any).Selectors = Selectors;\r\n\r\nclass Scored<T extends GObject> {\r\n    constructor(public score: number, public element: T) {}\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}