{"ast":null,"code":"/**\n * Copyright 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/*jslint node: true*/\nvar Syntax = require('esprima-fb').Syntax;\nvar leadingIndentRegexp = /(^|\\n)( {2}|\\t)/g;\nvar nonWhiteRegexp = /(\\S)/g;\n\n/**\n * A `state` object represents the state of the parser. It has \"local\" and\n * \"global\" parts. Global contains parser position, source, etc. Local contains\n * scope based properties like current class name. State should contain all the\n * info required for transformation. It's the only mandatory object that is\n * being passed to every function in transform chain.\n *\n * @param  {string} source\n * @param  {object} transformOptions\n * @return {object}\n */\nfunction createState(source, rootNode, transformOptions) {\n  return {\n    /**\n     * A tree representing the current local scope (and its lexical scope chain)\n     * Useful for tracking identifiers from parent scopes, etc.\n     * @type {Object}\n     */\n    localScope: {\n      parentNode: rootNode,\n      parentScope: null,\n      identifiers: {},\n      tempVarIndex: 0,\n      tempVars: []\n    },\n    /**\n     * The name (and, if applicable, expression) of the super class\n     * @type {Object}\n     */\n    superClass: null,\n    /**\n     * The namespace to use when munging identifiers\n     * @type {String}\n     */\n    mungeNamespace: '',\n    /**\n     * Ref to the node for the current MethodDefinition\n     * @type {Object}\n     */\n    methodNode: null,\n    /**\n     * Ref to the node for the FunctionExpression of the enclosing\n     * MethodDefinition\n     * @type {Object}\n     */\n    methodFuncNode: null,\n    /**\n     * Name of the enclosing class\n     * @type {String}\n     */\n    className: null,\n    /**\n     * Whether we're currently within a `strict` scope\n     * @type {Bool}\n     */\n    scopeIsStrict: null,\n    /**\n     * Indentation offset\n     * @type {Number}\n     */\n    indentBy: 0,\n    /**\n     * Global state (not affected by updateState)\n     * @type {Object}\n     */\n    g: {\n      /**\n       * A set of general options that transformations can consider while doing\n       * a transformation:\n       *\n       * - minify\n       *   Specifies that transformation steps should do their best to minify\n       *   the output source when possible. This is useful for places where\n       *   minification optimizations are possible with higher-level context\n       *   info than what jsxmin can provide.\n       *\n       *   For example, the ES6 class transform will minify munged private\n       *   variables if this flag is set.\n       */\n      opts: transformOptions,\n      /**\n       * Current position in the source code\n       * @type {Number}\n       */\n      position: 0,\n      /**\n       * Auxiliary data to be returned by transforms\n       * @type {Object}\n       */\n      extra: {},\n      /**\n       * Buffer containing the result\n       * @type {String}\n       */\n      buffer: '',\n      /**\n       * Source that is being transformed\n       * @type {String}\n       */\n      source: source,\n      /**\n       * Cached parsed docblock (see getDocblock)\n       * @type {object}\n       */\n      docblock: null,\n      /**\n       * Whether the thing was used\n       * @type {Boolean}\n       */\n      tagNamespaceUsed: false,\n      /**\n       * If using bolt xjs transformation\n       * @type {Boolean}\n       */\n      isBolt: undefined,\n      /**\n       * Whether to record source map (expensive) or not\n       * @type {SourceMapGenerator|null}\n       */\n      sourceMap: null,\n      /**\n       * Filename of the file being processed. Will be returned as a source\n       * attribute in the source map\n       */\n      sourceMapFilename: 'source.js',\n      /**\n       * Only when source map is used: last line in the source for which\n       * source map was generated\n       * @type {Number}\n       */\n      sourceLine: 1,\n      /**\n       * Only when source map is used: last line in the buffer for which\n       * source map was generated\n       * @type {Number}\n       */\n      bufferLine: 1,\n      /**\n       * The top-level Program AST for the original file.\n       */\n      originalProgramAST: null,\n      sourceColumn: 0,\n      bufferColumn: 0\n    }\n  };\n}\n\n/**\n * Updates a copy of a given state with \"update\" and returns an updated state.\n *\n * @param  {object} state\n * @param  {object} update\n * @return {object}\n */\nfunction updateState(state, update) {\n  var ret = Object.create(state);\n  Object.keys(update).forEach(function (updatedKey) {\n    ret[updatedKey] = update[updatedKey];\n  });\n  return ret;\n}\n\n/**\n * Given a state fill the resulting buffer from the original source up to\n * the end\n *\n * @param {number} end\n * @param {object} state\n * @param {?function} contentTransformer Optional callback to transform newly\n *                                       added content.\n */\nfunction catchup(end, state, contentTransformer) {\n  if (end < state.g.position) {\n    // cannot move backwards\n    return;\n  }\n  var source = state.g.source.substring(state.g.position, end);\n  var transformed = updateIndent(source, state);\n  if (state.g.sourceMap && transformed) {\n    // record where we are\n    state.g.sourceMap.addMapping({\n      generated: {\n        line: state.g.bufferLine,\n        column: state.g.bufferColumn\n      },\n      original: {\n        line: state.g.sourceLine,\n        column: state.g.sourceColumn\n      },\n      source: state.g.sourceMapFilename\n    });\n\n    // record line breaks in transformed source\n    var sourceLines = source.split('\\n');\n    var transformedLines = transformed.split('\\n');\n    // Add line break mappings between last known mapping and the end of the\n    // added piece. So for the code piece\n    //  (foo, bar);\n    // > var x = 2;\n    // > var b = 3;\n    //   var c =\n    // only add lines marked with \">\": 2, 3.\n    for (var i = 1; i < sourceLines.length - 1; i++) {\n      state.g.sourceMap.addMapping({\n        generated: {\n          line: state.g.bufferLine,\n          column: 0\n        },\n        original: {\n          line: state.g.sourceLine,\n          column: 0\n        },\n        source: state.g.sourceMapFilename\n      });\n      state.g.sourceLine++;\n      state.g.bufferLine++;\n    }\n    // offset for the last piece\n    if (sourceLines.length > 1) {\n      state.g.sourceLine++;\n      state.g.bufferLine++;\n      state.g.sourceColumn = 0;\n      state.g.bufferColumn = 0;\n    }\n    state.g.sourceColumn += sourceLines[sourceLines.length - 1].length;\n    state.g.bufferColumn += transformedLines[transformedLines.length - 1].length;\n  }\n  state.g.buffer += contentTransformer ? contentTransformer(transformed) : transformed;\n  state.g.position = end;\n}\n\n/**\n * Returns original source for an AST node.\n * @param {object} node\n * @param {object} state\n * @return {string}\n */\nfunction getNodeSourceText(node, state) {\n  return state.g.source.substring(node.range[0], node.range[1]);\n}\nfunction _replaceNonWhite(value) {\n  return value.replace(nonWhiteRegexp, ' ');\n}\n\n/**\n * Removes all non-whitespace characters\n */\nfunction _stripNonWhite(value) {\n  return value.replace(nonWhiteRegexp, '');\n}\n\n/**\n * Finds the position of the next instance of the specified syntactic char in\n * the pending source.\n *\n * NOTE: This will skip instances of the specified char if they sit inside a\n *       comment body.\n *\n * NOTE: This function also assumes that the buffer's current position is not\n *       already within a comment or a string. This is rarely the case since all\n *       of the buffer-advancement utility methods tend to be used on syntactic\n *       nodes' range values -- but it's a small gotcha that's worth mentioning.\n */\nfunction getNextSyntacticCharOffset(char, state) {\n  var pendingSource = state.g.source.substring(state.g.position);\n  var pendingSourceLines = pendingSource.split('\\n');\n  var charOffset = 0;\n  var line;\n  var withinBlockComment = false;\n  var withinString = false;\n  lineLoop: while ((line = pendingSourceLines.shift()) !== undefined) {\n    var lineEndPos = charOffset + line.length;\n    charLoop: for (; charOffset < lineEndPos; charOffset++) {\n      var currChar = pendingSource[charOffset];\n      if (currChar === '\"' || currChar === '\\'') {\n        withinString = !withinString;\n        continue charLoop;\n      } else if (withinString) {\n        continue charLoop;\n      } else if (charOffset + 1 < lineEndPos) {\n        var nextTwoChars = currChar + line[charOffset + 1];\n        if (nextTwoChars === '//') {\n          charOffset = lineEndPos + 1;\n          continue lineLoop;\n        } else if (nextTwoChars === '/*') {\n          withinBlockComment = true;\n          charOffset += 1;\n          continue charLoop;\n        } else if (nextTwoChars === '*/') {\n          withinBlockComment = false;\n          charOffset += 1;\n          continue charLoop;\n        }\n      }\n      if (!withinBlockComment && currChar === char) {\n        return charOffset + state.g.position;\n      }\n    }\n\n    // Account for '\\n'\n    charOffset++;\n    withinString = false;\n  }\n  throw new Error('`' + char + '` not found!');\n}\n\n/**\n * Catches up as `catchup` but replaces non-whitespace chars with spaces.\n */\nfunction catchupWhiteOut(end, state) {\n  catchup(end, state, _replaceNonWhite);\n}\n\n/**\n * Catches up as `catchup` but removes all non-whitespace characters.\n */\nfunction catchupWhiteSpace(end, state) {\n  catchup(end, state, _stripNonWhite);\n}\n\n/**\n * Removes all non-newline characters\n */\nvar reNonNewline = /[^\\n]/g;\nfunction stripNonNewline(value) {\n  return value.replace(reNonNewline, function () {\n    return '';\n  });\n}\n\n/**\n * Catches up as `catchup` but removes all non-newline characters.\n *\n * Equivalent to appending as many newlines as there are in the original source\n * between the current position and `end`.\n */\nfunction catchupNewlines(end, state) {\n  catchup(end, state, stripNonNewline);\n}\n\n/**\n * Same as catchup but does not touch the buffer\n *\n * @param  {number} end\n * @param  {object} state\n */\nfunction move(end, state) {\n  // move the internal cursors\n  if (state.g.sourceMap) {\n    if (end < state.g.position) {\n      state.g.position = 0;\n      state.g.sourceLine = 1;\n      state.g.sourceColumn = 0;\n    }\n    var source = state.g.source.substring(state.g.position, end);\n    var sourceLines = source.split('\\n');\n    if (sourceLines.length > 1) {\n      state.g.sourceLine += sourceLines.length - 1;\n      state.g.sourceColumn = 0;\n    }\n    state.g.sourceColumn += sourceLines[sourceLines.length - 1].length;\n  }\n  state.g.position = end;\n}\n\n/**\n * Appends a string of text to the buffer\n *\n * @param {string} str\n * @param {object} state\n */\nfunction append(str, state) {\n  if (state.g.sourceMap && str) {\n    state.g.sourceMap.addMapping({\n      generated: {\n        line: state.g.bufferLine,\n        column: state.g.bufferColumn\n      },\n      original: {\n        line: state.g.sourceLine,\n        column: state.g.sourceColumn\n      },\n      source: state.g.sourceMapFilename\n    });\n    var transformedLines = str.split('\\n');\n    if (transformedLines.length > 1) {\n      state.g.bufferLine += transformedLines.length - 1;\n      state.g.bufferColumn = 0;\n    }\n    state.g.bufferColumn += transformedLines[transformedLines.length - 1].length;\n  }\n  state.g.buffer += str;\n}\n\n/**\n * Update indent using state.indentBy property. Indent is measured in\n * double spaces. Updates a single line only.\n *\n * @param {string} str\n * @param {object} state\n * @return {string}\n */\nfunction updateIndent(str, state) {\n  /*jshint -W004*/\n  var indentBy = state.indentBy;\n  if (indentBy < 0) {\n    for (var i = 0; i < -indentBy; i++) {\n      str = str.replace(leadingIndentRegexp, '$1');\n    }\n  } else {\n    for (var i = 0; i < indentBy; i++) {\n      str = str.replace(leadingIndentRegexp, '$1$2$2');\n    }\n  }\n  return str;\n}\n\n/**\n * Calculates indent from the beginning of the line until \"start\" or the first\n * character before start.\n * @example\n *   \"  foo.bar()\"\n *         ^\n *       start\n *   indent will be \"  \"\n *\n * @param  {number} start\n * @param  {object} state\n * @return {string}\n */\nfunction indentBefore(start, state) {\n  var end = start;\n  start = start - 1;\n  while (start > 0 && state.g.source[start] != '\\n') {\n    if (!state.g.source[start].match(/[ \\t]/)) {\n      end = start;\n    }\n    start--;\n  }\n  return state.g.source.substring(start + 1, end);\n}\nfunction getDocblock(state) {\n  if (!state.g.docblock) {\n    var docblock = require('./docblock');\n    state.g.docblock = docblock.parseAsObject(docblock.extract(state.g.source));\n  }\n  return state.g.docblock;\n}\nfunction identWithinLexicalScope(identName, state, stopBeforeNode) {\n  var currScope = state.localScope;\n  while (currScope) {\n    if (currScope.identifiers[identName] !== undefined) {\n      return true;\n    }\n    if (stopBeforeNode && currScope.parentNode === stopBeforeNode) {\n      break;\n    }\n    currScope = currScope.parentScope;\n  }\n  return false;\n}\nfunction identInLocalScope(identName, state) {\n  return state.localScope.identifiers[identName] !== undefined;\n}\n\n/**\n * @param {object} boundaryNode\n * @param {?array} path\n * @return {?object} node\n */\nfunction initScopeMetadata(boundaryNode, path, node) {\n  return {\n    boundaryNode: boundaryNode,\n    bindingPath: path,\n    bindingNode: node\n  };\n}\nfunction declareIdentInLocalScope(identName, metaData, state) {\n  state.localScope.identifiers[identName] = {\n    boundaryNode: metaData.boundaryNode,\n    path: metaData.bindingPath,\n    node: metaData.bindingNode,\n    state: Object.create(state)\n  };\n}\nfunction getLexicalBindingMetadata(identName, state) {\n  var currScope = state.localScope;\n  while (currScope) {\n    if (currScope.identifiers[identName] !== undefined) {\n      return currScope.identifiers[identName];\n    }\n    currScope = currScope.parentScope;\n  }\n}\nfunction getLocalBindingMetadata(identName, state) {\n  return state.localScope.identifiers[identName];\n}\n\n/**\n * Apply the given analyzer function to the current node. If the analyzer\n * doesn't return false, traverse each child of the current node using the given\n * traverser function.\n *\n * @param {function} analyzer\n * @param {function} traverser\n * @param {object} node\n * @param {array} path\n * @param {object} state\n */\nfunction analyzeAndTraverse(analyzer, traverser, node, path, state) {\n  if (node.type) {\n    if (analyzer(node, path, state) === false) {\n      return;\n    }\n    path.unshift(node);\n  }\n  getOrderedChildren(node).forEach(function (child) {\n    traverser(child, path, state);\n  });\n  node.type && path.shift();\n}\n\n/**\n * It is crucial that we traverse in order, or else catchup() on a later\n * node that is processed out of order can move the buffer past a node\n * that we haven't handled yet, preventing us from modifying that node.\n *\n * This can happen when a node has multiple properties containing children.\n * For example, XJSElement nodes have `openingElement`, `closingElement` and\n * `children`. If we traverse `openingElement`, then `closingElement`, then\n * when we get to `children`, the buffer has already caught up to the end of\n * the closing element, after the children.\n *\n * This is basically a Schwartzian transform. Collects an array of children,\n * each one represented as [child, startIndex]; sorts the array by start\n * index; then traverses the children in that order.\n */\nfunction getOrderedChildren(node) {\n  var queue = [];\n  for (var key in node) {\n    if (node.hasOwnProperty(key)) {\n      enqueueNodeWithStartIndex(queue, node[key]);\n    }\n  }\n  queue.sort(function (a, b) {\n    return a[1] - b[1];\n  });\n  return queue.map(function (pair) {\n    return pair[0];\n  });\n}\n\n/**\n * Helper function for analyzeAndTraverse which queues up all of the children\n * of the given node.\n *\n * Children can also be found in arrays, so we basically want to merge all of\n * those arrays together so we can sort them and then traverse the children\n * in order.\n *\n * One example is the Program node. It contains `body` and `comments`, both\n * arrays. Lexographically, comments are interspersed throughout the body\n * nodes, but esprima's AST groups them together.\n */\nfunction enqueueNodeWithStartIndex(queue, node) {\n  if (typeof node !== 'object' || node === null) {\n    return;\n  }\n  if (node.range) {\n    queue.push([node, node.range[0]]);\n  } else if (Array.isArray(node)) {\n    for (var ii = 0; ii < node.length; ii++) {\n      enqueueNodeWithStartIndex(queue, node[ii]);\n    }\n  }\n}\n\n/**\n * Checks whether a node or any of its sub-nodes contains\n * a syntactic construct of the passed type.\n * @param {object} node - AST node to test.\n * @param {string} type - node type to lookup.\n */\nfunction containsChildOfType(node, type) {\n  return containsChildMatching(node, function (node) {\n    return node.type === type;\n  });\n}\nfunction containsChildMatching(node, matcher) {\n  var foundMatchingChild = false;\n  function nodeTypeAnalyzer(node) {\n    if (matcher(node) === true) {\n      foundMatchingChild = true;\n      return false;\n    }\n  }\n  function nodeTypeTraverser(child, path, state) {\n    if (!foundMatchingChild) {\n      foundMatchingChild = containsChildMatching(child, matcher);\n    }\n  }\n  analyzeAndTraverse(nodeTypeAnalyzer, nodeTypeTraverser, node, []);\n  return foundMatchingChild;\n}\nvar scopeTypes = {};\nscopeTypes[Syntax.ArrowFunctionExpression] = true;\nscopeTypes[Syntax.FunctionExpression] = true;\nscopeTypes[Syntax.FunctionDeclaration] = true;\nscopeTypes[Syntax.Program] = true;\nfunction getBoundaryNode(path) {\n  for (var ii = 0; ii < path.length; ++ii) {\n    if (scopeTypes[path[ii].type]) {\n      return path[ii];\n    }\n  }\n  throw new Error('Expected to find a node with one of the following types in path:\\n' + JSON.stringify(Object.keys(scopeTypes)));\n}\nfunction getTempVar(tempVarIndex) {\n  return '$__' + tempVarIndex;\n}\nfunction injectTempVar(state) {\n  var tempVar = '$__' + state.localScope.tempVarIndex++;\n  state.localScope.tempVars.push(tempVar);\n  return tempVar;\n}\nfunction injectTempVarDeclarations(state, index) {\n  if (state.localScope.tempVars.length) {\n    state.g.buffer = state.g.buffer.slice(0, index) + 'var ' + state.localScope.tempVars.join(', ') + ';' + state.g.buffer.slice(index);\n    state.localScope.tempVars = [];\n  }\n}\nexports.analyzeAndTraverse = analyzeAndTraverse;\nexports.append = append;\nexports.catchup = catchup;\nexports.catchupNewlines = catchupNewlines;\nexports.catchupWhiteOut = catchupWhiteOut;\nexports.catchupWhiteSpace = catchupWhiteSpace;\nexports.containsChildMatching = containsChildMatching;\nexports.containsChildOfType = containsChildOfType;\nexports.createState = createState;\nexports.declareIdentInLocalScope = declareIdentInLocalScope;\nexports.getBoundaryNode = getBoundaryNode;\nexports.getDocblock = getDocblock;\nexports.getLexicalBindingMetadata = getLexicalBindingMetadata;\nexports.getLocalBindingMetadata = getLocalBindingMetadata;\nexports.getNextSyntacticCharOffset = getNextSyntacticCharOffset;\nexports.getNodeSourceText = getNodeSourceText;\nexports.getOrderedChildren = getOrderedChildren;\nexports.getTempVar = getTempVar;\nexports.identInLocalScope = identInLocalScope;\nexports.identWithinLexicalScope = identWithinLexicalScope;\nexports.indentBefore = indentBefore;\nexports.initScopeMetadata = initScopeMetadata;\nexports.injectTempVar = injectTempVar;\nexports.injectTempVarDeclarations = injectTempVarDeclarations;\nexports.move = move;\nexports.scopeTypes = scopeTypes;\nexports.updateIndent = updateIndent;\nexports.updateState = updateState;","map":{"version":3,"names":["Syntax","require","leadingIndentRegexp","nonWhiteRegexp","createState","source","rootNode","transformOptions","localScope","parentNode","parentScope","identifiers","tempVarIndex","tempVars","superClass","mungeNamespace","methodNode","methodFuncNode","className","scopeIsStrict","indentBy","g","opts","position","extra","buffer","docblock","tagNamespaceUsed","isBolt","undefined","sourceMap","sourceMapFilename","sourceLine","bufferLine","originalProgramAST","sourceColumn","bufferColumn","updateState","state","update","ret","Object","create","keys","forEach","updatedKey","catchup","end","contentTransformer","substring","transformed","updateIndent","addMapping","generated","line","column","original","sourceLines","split","transformedLines","i","length","getNodeSourceText","node","range","_replaceNonWhite","value","replace","_stripNonWhite","getNextSyntacticCharOffset","char","pendingSource","pendingSourceLines","charOffset","withinBlockComment","withinString","lineLoop","shift","lineEndPos","charLoop","currChar","nextTwoChars","Error","catchupWhiteOut","catchupWhiteSpace","reNonNewline","stripNonNewline","catchupNewlines","move","append","str","indentBefore","start","match","getDocblock","parseAsObject","extract","identWithinLexicalScope","identName","stopBeforeNode","currScope","identInLocalScope","initScopeMetadata","boundaryNode","path","bindingPath","bindingNode","declareIdentInLocalScope","metaData","getLexicalBindingMetadata","getLocalBindingMetadata","analyzeAndTraverse","analyzer","traverser","type","unshift","getOrderedChildren","child","queue","key","hasOwnProperty","enqueueNodeWithStartIndex","sort","a","b","map","pair","push","Array","isArray","ii","containsChildOfType","containsChildMatching","matcher","foundMatchingChild","nodeTypeAnalyzer","nodeTypeTraverser","scopeTypes","ArrowFunctionExpression","FunctionExpression","FunctionDeclaration","Program","getBoundaryNode","JSON","stringify","getTempVar","injectTempVar","tempVar","injectTempVarDeclarations","index","slice","join","exports"],"sources":["C:/0Programmi/Dev/projects/frontend/jjodel/frontend/node_modules/jstransform/src/utils.js"],"sourcesContent":["/**\n * Copyright 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n\n/*jslint node: true*/\nvar Syntax = require('esprima-fb').Syntax;\nvar leadingIndentRegexp = /(^|\\n)( {2}|\\t)/g;\nvar nonWhiteRegexp = /(\\S)/g;\n\n/**\n * A `state` object represents the state of the parser. It has \"local\" and\n * \"global\" parts. Global contains parser position, source, etc. Local contains\n * scope based properties like current class name. State should contain all the\n * info required for transformation. It's the only mandatory object that is\n * being passed to every function in transform chain.\n *\n * @param  {string} source\n * @param  {object} transformOptions\n * @return {object}\n */\nfunction createState(source, rootNode, transformOptions) {\n  return {\n    /**\n     * A tree representing the current local scope (and its lexical scope chain)\n     * Useful for tracking identifiers from parent scopes, etc.\n     * @type {Object}\n     */\n    localScope: {\n      parentNode: rootNode,\n      parentScope: null,\n      identifiers: {},\n      tempVarIndex: 0,\n      tempVars: []\n    },\n    /**\n     * The name (and, if applicable, expression) of the super class\n     * @type {Object}\n     */\n    superClass: null,\n    /**\n     * The namespace to use when munging identifiers\n     * @type {String}\n     */\n    mungeNamespace: '',\n    /**\n     * Ref to the node for the current MethodDefinition\n     * @type {Object}\n     */\n    methodNode: null,\n    /**\n     * Ref to the node for the FunctionExpression of the enclosing\n     * MethodDefinition\n     * @type {Object}\n     */\n    methodFuncNode: null,\n    /**\n     * Name of the enclosing class\n     * @type {String}\n     */\n    className: null,\n    /**\n     * Whether we're currently within a `strict` scope\n     * @type {Bool}\n     */\n    scopeIsStrict: null,\n    /**\n     * Indentation offset\n     * @type {Number}\n     */\n    indentBy: 0,\n    /**\n     * Global state (not affected by updateState)\n     * @type {Object}\n     */\n    g: {\n      /**\n       * A set of general options that transformations can consider while doing\n       * a transformation:\n       *\n       * - minify\n       *   Specifies that transformation steps should do their best to minify\n       *   the output source when possible. This is useful for places where\n       *   minification optimizations are possible with higher-level context\n       *   info than what jsxmin can provide.\n       *\n       *   For example, the ES6 class transform will minify munged private\n       *   variables if this flag is set.\n       */\n      opts: transformOptions,\n      /**\n       * Current position in the source code\n       * @type {Number}\n       */\n      position: 0,\n      /**\n       * Auxiliary data to be returned by transforms\n       * @type {Object}\n       */\n      extra: {},\n      /**\n       * Buffer containing the result\n       * @type {String}\n       */\n      buffer: '',\n      /**\n       * Source that is being transformed\n       * @type {String}\n       */\n      source: source,\n\n      /**\n       * Cached parsed docblock (see getDocblock)\n       * @type {object}\n       */\n      docblock: null,\n\n      /**\n       * Whether the thing was used\n       * @type {Boolean}\n       */\n      tagNamespaceUsed: false,\n\n      /**\n       * If using bolt xjs transformation\n       * @type {Boolean}\n       */\n      isBolt: undefined,\n\n      /**\n       * Whether to record source map (expensive) or not\n       * @type {SourceMapGenerator|null}\n       */\n      sourceMap: null,\n\n      /**\n       * Filename of the file being processed. Will be returned as a source\n       * attribute in the source map\n       */\n      sourceMapFilename: 'source.js',\n\n      /**\n       * Only when source map is used: last line in the source for which\n       * source map was generated\n       * @type {Number}\n       */\n      sourceLine: 1,\n\n      /**\n       * Only when source map is used: last line in the buffer for which\n       * source map was generated\n       * @type {Number}\n       */\n      bufferLine: 1,\n\n      /**\n       * The top-level Program AST for the original file.\n       */\n      originalProgramAST: null,\n\n      sourceColumn: 0,\n      bufferColumn: 0\n    }\n  };\n}\n\n/**\n * Updates a copy of a given state with \"update\" and returns an updated state.\n *\n * @param  {object} state\n * @param  {object} update\n * @return {object}\n */\nfunction updateState(state, update) {\n  var ret = Object.create(state);\n  Object.keys(update).forEach(function(updatedKey) {\n    ret[updatedKey] = update[updatedKey];\n  });\n  return ret;\n}\n\n/**\n * Given a state fill the resulting buffer from the original source up to\n * the end\n *\n * @param {number} end\n * @param {object} state\n * @param {?function} contentTransformer Optional callback to transform newly\n *                                       added content.\n */\nfunction catchup(end, state, contentTransformer) {\n  if (end < state.g.position) {\n    // cannot move backwards\n    return;\n  }\n  var source = state.g.source.substring(state.g.position, end);\n  var transformed = updateIndent(source, state);\n  if (state.g.sourceMap && transformed) {\n    // record where we are\n    state.g.sourceMap.addMapping({\n      generated: { line: state.g.bufferLine, column: state.g.bufferColumn },\n      original: { line: state.g.sourceLine, column: state.g.sourceColumn },\n      source: state.g.sourceMapFilename\n    });\n\n    // record line breaks in transformed source\n    var sourceLines = source.split('\\n');\n    var transformedLines = transformed.split('\\n');\n    // Add line break mappings between last known mapping and the end of the\n    // added piece. So for the code piece\n    //  (foo, bar);\n    // > var x = 2;\n    // > var b = 3;\n    //   var c =\n    // only add lines marked with \">\": 2, 3.\n    for (var i = 1; i < sourceLines.length - 1; i++) {\n      state.g.sourceMap.addMapping({\n        generated: { line: state.g.bufferLine, column: 0 },\n        original: { line: state.g.sourceLine, column: 0 },\n        source: state.g.sourceMapFilename\n      });\n      state.g.sourceLine++;\n      state.g.bufferLine++;\n    }\n    // offset for the last piece\n    if (sourceLines.length > 1) {\n      state.g.sourceLine++;\n      state.g.bufferLine++;\n      state.g.sourceColumn = 0;\n      state.g.bufferColumn = 0;\n    }\n    state.g.sourceColumn += sourceLines[sourceLines.length - 1].length;\n    state.g.bufferColumn +=\n      transformedLines[transformedLines.length - 1].length;\n  }\n  state.g.buffer +=\n    contentTransformer ? contentTransformer(transformed) : transformed;\n  state.g.position = end;\n}\n\n/**\n * Returns original source for an AST node.\n * @param {object} node\n * @param {object} state\n * @return {string}\n */\nfunction getNodeSourceText(node, state) {\n  return state.g.source.substring(node.range[0], node.range[1]);\n}\n\nfunction _replaceNonWhite(value) {\n  return value.replace(nonWhiteRegexp, ' ');\n}\n\n/**\n * Removes all non-whitespace characters\n */\nfunction _stripNonWhite(value) {\n  return value.replace(nonWhiteRegexp, '');\n}\n\n/**\n * Finds the position of the next instance of the specified syntactic char in\n * the pending source.\n *\n * NOTE: This will skip instances of the specified char if they sit inside a\n *       comment body.\n *\n * NOTE: This function also assumes that the buffer's current position is not\n *       already within a comment or a string. This is rarely the case since all\n *       of the buffer-advancement utility methods tend to be used on syntactic\n *       nodes' range values -- but it's a small gotcha that's worth mentioning.\n */\nfunction getNextSyntacticCharOffset(char, state) {\n  var pendingSource = state.g.source.substring(state.g.position);\n  var pendingSourceLines = pendingSource.split('\\n');\n\n  var charOffset = 0;\n  var line;\n  var withinBlockComment = false;\n  var withinString = false;\n  lineLoop: while ((line = pendingSourceLines.shift()) !== undefined) {\n    var lineEndPos = charOffset + line.length;\n    charLoop: for (; charOffset < lineEndPos; charOffset++) {\n      var currChar = pendingSource[charOffset];\n      if (currChar === '\"' || currChar === '\\'') {\n        withinString = !withinString;\n        continue charLoop;\n      } else if (withinString) {\n        continue charLoop;\n      } else if (charOffset + 1 < lineEndPos) {\n        var nextTwoChars = currChar + line[charOffset + 1];\n        if (nextTwoChars === '//') {\n          charOffset = lineEndPos + 1;\n          continue lineLoop;\n        } else if (nextTwoChars === '/*') {\n          withinBlockComment = true;\n          charOffset += 1;\n          continue charLoop;\n        } else if (nextTwoChars === '*/') {\n          withinBlockComment = false;\n          charOffset += 1;\n          continue charLoop;\n        }\n      }\n\n      if (!withinBlockComment && currChar === char) {\n        return charOffset + state.g.position;\n      }\n    }\n\n    // Account for '\\n'\n    charOffset++;\n    withinString = false;\n  }\n\n  throw new Error('`' + char + '` not found!');\n}\n\n/**\n * Catches up as `catchup` but replaces non-whitespace chars with spaces.\n */\nfunction catchupWhiteOut(end, state) {\n  catchup(end, state, _replaceNonWhite);\n}\n\n/**\n * Catches up as `catchup` but removes all non-whitespace characters.\n */\nfunction catchupWhiteSpace(end, state) {\n  catchup(end, state, _stripNonWhite);\n}\n\n/**\n * Removes all non-newline characters\n */\nvar reNonNewline = /[^\\n]/g;\nfunction stripNonNewline(value) {\n  return value.replace(reNonNewline, function() {\n    return '';\n  });\n}\n\n/**\n * Catches up as `catchup` but removes all non-newline characters.\n *\n * Equivalent to appending as many newlines as there are in the original source\n * between the current position and `end`.\n */\nfunction catchupNewlines(end, state) {\n  catchup(end, state, stripNonNewline);\n}\n\n\n/**\n * Same as catchup but does not touch the buffer\n *\n * @param  {number} end\n * @param  {object} state\n */\nfunction move(end, state) {\n  // move the internal cursors\n  if (state.g.sourceMap) {\n    if (end < state.g.position) {\n      state.g.position = 0;\n      state.g.sourceLine = 1;\n      state.g.sourceColumn = 0;\n    }\n\n    var source = state.g.source.substring(state.g.position, end);\n    var sourceLines = source.split('\\n');\n    if (sourceLines.length > 1) {\n      state.g.sourceLine += sourceLines.length - 1;\n      state.g.sourceColumn = 0;\n    }\n    state.g.sourceColumn += sourceLines[sourceLines.length - 1].length;\n  }\n  state.g.position = end;\n}\n\n/**\n * Appends a string of text to the buffer\n *\n * @param {string} str\n * @param {object} state\n */\nfunction append(str, state) {\n  if (state.g.sourceMap && str) {\n    state.g.sourceMap.addMapping({\n      generated: { line: state.g.bufferLine, column: state.g.bufferColumn },\n      original: { line: state.g.sourceLine, column: state.g.sourceColumn },\n      source: state.g.sourceMapFilename\n    });\n    var transformedLines = str.split('\\n');\n    if (transformedLines.length > 1) {\n      state.g.bufferLine += transformedLines.length - 1;\n      state.g.bufferColumn = 0;\n    }\n    state.g.bufferColumn +=\n      transformedLines[transformedLines.length - 1].length;\n  }\n  state.g.buffer += str;\n}\n\n/**\n * Update indent using state.indentBy property. Indent is measured in\n * double spaces. Updates a single line only.\n *\n * @param {string} str\n * @param {object} state\n * @return {string}\n */\nfunction updateIndent(str, state) {\n  /*jshint -W004*/\n  var indentBy = state.indentBy;\n  if (indentBy < 0) {\n    for (var i = 0; i < -indentBy; i++) {\n      str = str.replace(leadingIndentRegexp, '$1');\n    }\n  } else {\n    for (var i = 0; i < indentBy; i++) {\n      str = str.replace(leadingIndentRegexp, '$1$2$2');\n    }\n  }\n  return str;\n}\n\n/**\n * Calculates indent from the beginning of the line until \"start\" or the first\n * character before start.\n * @example\n *   \"  foo.bar()\"\n *         ^\n *       start\n *   indent will be \"  \"\n *\n * @param  {number} start\n * @param  {object} state\n * @return {string}\n */\nfunction indentBefore(start, state) {\n  var end = start;\n  start = start - 1;\n\n  while (start > 0 && state.g.source[start] != '\\n') {\n    if (!state.g.source[start].match(/[ \\t]/)) {\n      end = start;\n    }\n    start--;\n  }\n  return state.g.source.substring(start + 1, end);\n}\n\nfunction getDocblock(state) {\n  if (!state.g.docblock) {\n    var docblock = require('./docblock');\n    state.g.docblock =\n      docblock.parseAsObject(docblock.extract(state.g.source));\n  }\n  return state.g.docblock;\n}\n\nfunction identWithinLexicalScope(identName, state, stopBeforeNode) {\n  var currScope = state.localScope;\n  while (currScope) {\n    if (currScope.identifiers[identName] !== undefined) {\n      return true;\n    }\n\n    if (stopBeforeNode && currScope.parentNode === stopBeforeNode) {\n      break;\n    }\n\n    currScope = currScope.parentScope;\n  }\n  return false;\n}\n\nfunction identInLocalScope(identName, state) {\n  return state.localScope.identifiers[identName] !== undefined;\n}\n\n/**\n * @param {object} boundaryNode\n * @param {?array} path\n * @return {?object} node\n */\nfunction initScopeMetadata(boundaryNode, path, node) {\n  return {\n    boundaryNode: boundaryNode,\n    bindingPath: path,\n    bindingNode: node\n  };\n}\n\nfunction declareIdentInLocalScope(identName, metaData, state) {\n  state.localScope.identifiers[identName] = {\n    boundaryNode: metaData.boundaryNode,\n    path: metaData.bindingPath,\n    node: metaData.bindingNode,\n    state: Object.create(state)\n  };\n}\n\nfunction getLexicalBindingMetadata(identName, state) {\n  var currScope = state.localScope;\n  while (currScope) {\n    if (currScope.identifiers[identName] !== undefined) {\n      return currScope.identifiers[identName];\n    }\n\n    currScope = currScope.parentScope;\n  }\n}\n\nfunction getLocalBindingMetadata(identName, state) {\n  return state.localScope.identifiers[identName];\n}\n\n/**\n * Apply the given analyzer function to the current node. If the analyzer\n * doesn't return false, traverse each child of the current node using the given\n * traverser function.\n *\n * @param {function} analyzer\n * @param {function} traverser\n * @param {object} node\n * @param {array} path\n * @param {object} state\n */\nfunction analyzeAndTraverse(analyzer, traverser, node, path, state) {\n  if (node.type) {\n    if (analyzer(node, path, state) === false) {\n      return;\n    }\n    path.unshift(node);\n  }\n\n  getOrderedChildren(node).forEach(function(child) {\n    traverser(child, path, state);\n  });\n\n  node.type && path.shift();\n}\n\n/**\n * It is crucial that we traverse in order, or else catchup() on a later\n * node that is processed out of order can move the buffer past a node\n * that we haven't handled yet, preventing us from modifying that node.\n *\n * This can happen when a node has multiple properties containing children.\n * For example, XJSElement nodes have `openingElement`, `closingElement` and\n * `children`. If we traverse `openingElement`, then `closingElement`, then\n * when we get to `children`, the buffer has already caught up to the end of\n * the closing element, after the children.\n *\n * This is basically a Schwartzian transform. Collects an array of children,\n * each one represented as [child, startIndex]; sorts the array by start\n * index; then traverses the children in that order.\n */\nfunction getOrderedChildren(node) {\n  var queue = [];\n  for (var key in node) {\n    if (node.hasOwnProperty(key)) {\n      enqueueNodeWithStartIndex(queue, node[key]);\n    }\n  }\n  queue.sort(function(a, b) { return a[1] - b[1]; });\n  return queue.map(function(pair) { return pair[0]; });\n}\n\n/**\n * Helper function for analyzeAndTraverse which queues up all of the children\n * of the given node.\n *\n * Children can also be found in arrays, so we basically want to merge all of\n * those arrays together so we can sort them and then traverse the children\n * in order.\n *\n * One example is the Program node. It contains `body` and `comments`, both\n * arrays. Lexographically, comments are interspersed throughout the body\n * nodes, but esprima's AST groups them together.\n */\nfunction enqueueNodeWithStartIndex(queue, node) {\n  if (typeof node !== 'object' || node === null) {\n    return;\n  }\n  if (node.range) {\n    queue.push([node, node.range[0]]);\n  } else if (Array.isArray(node)) {\n    for (var ii = 0; ii < node.length; ii++) {\n      enqueueNodeWithStartIndex(queue, node[ii]);\n    }\n  }\n}\n\n/**\n * Checks whether a node or any of its sub-nodes contains\n * a syntactic construct of the passed type.\n * @param {object} node - AST node to test.\n * @param {string} type - node type to lookup.\n */\nfunction containsChildOfType(node, type) {\n  return containsChildMatching(node, function(node) {\n    return node.type === type;\n  });\n}\n\nfunction containsChildMatching(node, matcher) {\n  var foundMatchingChild = false;\n  function nodeTypeAnalyzer(node) {\n    if (matcher(node) === true) {\n      foundMatchingChild = true;\n      return false;\n    }\n  }\n  function nodeTypeTraverser(child, path, state) {\n    if (!foundMatchingChild) {\n      foundMatchingChild = containsChildMatching(child, matcher);\n    }\n  }\n  analyzeAndTraverse(\n    nodeTypeAnalyzer,\n    nodeTypeTraverser,\n    node,\n    []\n  );\n  return foundMatchingChild;\n}\n\nvar scopeTypes = {};\nscopeTypes[Syntax.ArrowFunctionExpression] = true;\nscopeTypes[Syntax.FunctionExpression] = true;\nscopeTypes[Syntax.FunctionDeclaration] = true;\nscopeTypes[Syntax.Program] = true;\n\nfunction getBoundaryNode(path) {\n  for (var ii = 0; ii < path.length; ++ii) {\n    if (scopeTypes[path[ii].type]) {\n      return path[ii];\n    }\n  }\n  throw new Error(\n    'Expected to find a node with one of the following types in path:\\n' +\n    JSON.stringify(Object.keys(scopeTypes))\n  );\n}\n\nfunction getTempVar(tempVarIndex) {\n  return '$__' + tempVarIndex;\n}\n\nfunction injectTempVar(state) {\n  var tempVar = '$__' + (state.localScope.tempVarIndex++);\n  state.localScope.tempVars.push(tempVar);\n  return tempVar;\n}\n\nfunction injectTempVarDeclarations(state, index) {\n  if (state.localScope.tempVars.length) {\n    state.g.buffer =\n      state.g.buffer.slice(0, index) +\n      'var ' + state.localScope.tempVars.join(', ') + ';' +\n      state.g.buffer.slice(index);\n    state.localScope.tempVars = [];\n  }\n}\n\nexports.analyzeAndTraverse = analyzeAndTraverse;\nexports.append = append;\nexports.catchup = catchup;\nexports.catchupNewlines = catchupNewlines;\nexports.catchupWhiteOut = catchupWhiteOut;\nexports.catchupWhiteSpace = catchupWhiteSpace;\nexports.containsChildMatching = containsChildMatching;\nexports.containsChildOfType = containsChildOfType;\nexports.createState = createState;\nexports.declareIdentInLocalScope = declareIdentInLocalScope;\nexports.getBoundaryNode = getBoundaryNode;\nexports.getDocblock = getDocblock;\nexports.getLexicalBindingMetadata = getLexicalBindingMetadata;\nexports.getLocalBindingMetadata = getLocalBindingMetadata;\nexports.getNextSyntacticCharOffset = getNextSyntacticCharOffset;\nexports.getNodeSourceText = getNodeSourceText;\nexports.getOrderedChildren = getOrderedChildren;\nexports.getTempVar = getTempVar;\nexports.identInLocalScope = identInLocalScope;\nexports.identWithinLexicalScope = identWithinLexicalScope;\nexports.indentBefore = indentBefore;\nexports.initScopeMetadata = initScopeMetadata;\nexports.injectTempVar = injectTempVar;\nexports.injectTempVarDeclarations = injectTempVarDeclarations;\nexports.move = move;\nexports.scopeTypes = scopeTypes;\nexports.updateIndent = updateIndent;\nexports.updateState = updateState;\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA;AACA,IAAIA,MAAM,GAAGC,OAAO,CAAC,YAAY,CAAC,CAACD,MAAM;AACzC,IAAIE,mBAAmB,GAAG,kBAAkB;AAC5C,IAAIC,cAAc,GAAG,OAAO;;AAE5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,WAAWA,CAACC,MAAM,EAAEC,QAAQ,EAAEC,gBAAgB,EAAE;EACvD,OAAO;IACL;AACJ;AACA;AACA;AACA;IACIC,UAAU,EAAE;MACVC,UAAU,EAAEH,QAAQ;MACpBI,WAAW,EAAE,IAAI;MACjBC,WAAW,EAAE,CAAC,CAAC;MACfC,YAAY,EAAE,CAAC;MACfC,QAAQ,EAAE;IACZ,CAAC;IACD;AACJ;AACA;AACA;IACIC,UAAU,EAAE,IAAI;IAChB;AACJ;AACA;AACA;IACIC,cAAc,EAAE,EAAE;IAClB;AACJ;AACA;AACA;IACIC,UAAU,EAAE,IAAI;IAChB;AACJ;AACA;AACA;AACA;IACIC,cAAc,EAAE,IAAI;IACpB;AACJ;AACA;AACA;IACIC,SAAS,EAAE,IAAI;IACf;AACJ;AACA;AACA;IACIC,aAAa,EAAE,IAAI;IACnB;AACJ;AACA;AACA;IACIC,QAAQ,EAAE,CAAC;IACX;AACJ;AACA;AACA;IACIC,CAAC,EAAE;MACD;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;MACMC,IAAI,EAAEf,gBAAgB;MACtB;AACN;AACA;AACA;MACMgB,QAAQ,EAAE,CAAC;MACX;AACN;AACA;AACA;MACMC,KAAK,EAAE,CAAC,CAAC;MACT;AACN;AACA;AACA;MACMC,MAAM,EAAE,EAAE;MACV;AACN;AACA;AACA;MACMpB,MAAM,EAAEA,MAAM;MAEd;AACN;AACA;AACA;MACMqB,QAAQ,EAAE,IAAI;MAEd;AACN;AACA;AACA;MACMC,gBAAgB,EAAE,KAAK;MAEvB;AACN;AACA;AACA;MACMC,MAAM,EAAEC,SAAS;MAEjB;AACN;AACA;AACA;MACMC,SAAS,EAAE,IAAI;MAEf;AACN;AACA;AACA;MACMC,iBAAiB,EAAE,WAAW;MAE9B;AACN;AACA;AACA;AACA;MACMC,UAAU,EAAE,CAAC;MAEb;AACN;AACA;AACA;AACA;MACMC,UAAU,EAAE,CAAC;MAEb;AACN;AACA;MACMC,kBAAkB,EAAE,IAAI;MAExBC,YAAY,EAAE,CAAC;MACfC,YAAY,EAAE;IAChB;EACF,CAAC;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,WAAWA,CAACC,KAAK,EAAEC,MAAM,EAAE;EAClC,IAAIC,GAAG,GAAGC,MAAM,CAACC,MAAM,CAACJ,KAAK,CAAC;EAC9BG,MAAM,CAACE,IAAI,CAACJ,MAAM,CAAC,CAACK,OAAO,CAAC,UAASC,UAAU,EAAE;IAC/CL,GAAG,CAACK,UAAU,CAAC,GAAGN,MAAM,CAACM,UAAU,CAAC;EACtC,CAAC,CAAC;EACF,OAAOL,GAAG;AACZ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASM,OAAOA,CAACC,GAAG,EAAET,KAAK,EAAEU,kBAAkB,EAAE;EAC/C,IAAID,GAAG,GAAGT,KAAK,CAACjB,CAAC,CAACE,QAAQ,EAAE;IAC1B;IACA;EACF;EACA,IAAIlB,MAAM,GAAGiC,KAAK,CAACjB,CAAC,CAAChB,MAAM,CAAC4C,SAAS,CAACX,KAAK,CAACjB,CAAC,CAACE,QAAQ,EAAEwB,GAAG,CAAC;EAC5D,IAAIG,WAAW,GAAGC,YAAY,CAAC9C,MAAM,EAAEiC,KAAK,CAAC;EAC7C,IAAIA,KAAK,CAACjB,CAAC,CAACS,SAAS,IAAIoB,WAAW,EAAE;IACpC;IACAZ,KAAK,CAACjB,CAAC,CAACS,SAAS,CAACsB,UAAU,CAAC;MAC3BC,SAAS,EAAE;QAAEC,IAAI,EAAEhB,KAAK,CAACjB,CAAC,CAACY,UAAU;QAAEsB,MAAM,EAAEjB,KAAK,CAACjB,CAAC,CAACe;MAAa,CAAC;MACrEoB,QAAQ,EAAE;QAAEF,IAAI,EAAEhB,KAAK,CAACjB,CAAC,CAACW,UAAU;QAAEuB,MAAM,EAAEjB,KAAK,CAACjB,CAAC,CAACc;MAAa,CAAC;MACpE9B,MAAM,EAAEiC,KAAK,CAACjB,CAAC,CAACU;IAClB,CAAC,CAAC;;IAEF;IACA,IAAI0B,WAAW,GAAGpD,MAAM,CAACqD,KAAK,CAAC,IAAI,CAAC;IACpC,IAAIC,gBAAgB,GAAGT,WAAW,CAACQ,KAAK,CAAC,IAAI,CAAC;IAC9C;IACA;IACA;IACA;IACA;IACA;IACA;IACA,KAAK,IAAIE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGH,WAAW,CAACI,MAAM,GAAG,CAAC,EAAED,CAAC,EAAE,EAAE;MAC/CtB,KAAK,CAACjB,CAAC,CAACS,SAAS,CAACsB,UAAU,CAAC;QAC3BC,SAAS,EAAE;UAAEC,IAAI,EAAEhB,KAAK,CAACjB,CAAC,CAACY,UAAU;UAAEsB,MAAM,EAAE;QAAE,CAAC;QAClDC,QAAQ,EAAE;UAAEF,IAAI,EAAEhB,KAAK,CAACjB,CAAC,CAACW,UAAU;UAAEuB,MAAM,EAAE;QAAE,CAAC;QACjDlD,MAAM,EAAEiC,KAAK,CAACjB,CAAC,CAACU;MAClB,CAAC,CAAC;MACFO,KAAK,CAACjB,CAAC,CAACW,UAAU,EAAE;MACpBM,KAAK,CAACjB,CAAC,CAACY,UAAU,EAAE;IACtB;IACA;IACA,IAAIwB,WAAW,CAACI,MAAM,GAAG,CAAC,EAAE;MAC1BvB,KAAK,CAACjB,CAAC,CAACW,UAAU,EAAE;MACpBM,KAAK,CAACjB,CAAC,CAACY,UAAU,EAAE;MACpBK,KAAK,CAACjB,CAAC,CAACc,YAAY,GAAG,CAAC;MACxBG,KAAK,CAACjB,CAAC,CAACe,YAAY,GAAG,CAAC;IAC1B;IACAE,KAAK,CAACjB,CAAC,CAACc,YAAY,IAAIsB,WAAW,CAACA,WAAW,CAACI,MAAM,GAAG,CAAC,CAAC,CAACA,MAAM;IAClEvB,KAAK,CAACjB,CAAC,CAACe,YAAY,IAClBuB,gBAAgB,CAACA,gBAAgB,CAACE,MAAM,GAAG,CAAC,CAAC,CAACA,MAAM;EACxD;EACAvB,KAAK,CAACjB,CAAC,CAACI,MAAM,IACZuB,kBAAkB,GAAGA,kBAAkB,CAACE,WAAW,CAAC,GAAGA,WAAW;EACpEZ,KAAK,CAACjB,CAAC,CAACE,QAAQ,GAAGwB,GAAG;AACxB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAASe,iBAAiBA,CAACC,IAAI,EAAEzB,KAAK,EAAE;EACtC,OAAOA,KAAK,CAACjB,CAAC,CAAChB,MAAM,CAAC4C,SAAS,CAACc,IAAI,CAACC,KAAK,CAAC,CAAC,CAAC,EAAED,IAAI,CAACC,KAAK,CAAC,CAAC,CAAC,CAAC;AAC/D;AAEA,SAASC,gBAAgBA,CAACC,KAAK,EAAE;EAC/B,OAAOA,KAAK,CAACC,OAAO,CAAChE,cAAc,EAAE,GAAG,CAAC;AAC3C;;AAEA;AACA;AACA;AACA,SAASiE,cAAcA,CAACF,KAAK,EAAE;EAC7B,OAAOA,KAAK,CAACC,OAAO,CAAChE,cAAc,EAAE,EAAE,CAAC;AAC1C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASkE,0BAA0BA,CAACC,IAAI,EAAEhC,KAAK,EAAE;EAC/C,IAAIiC,aAAa,GAAGjC,KAAK,CAACjB,CAAC,CAAChB,MAAM,CAAC4C,SAAS,CAACX,KAAK,CAACjB,CAAC,CAACE,QAAQ,CAAC;EAC9D,IAAIiD,kBAAkB,GAAGD,aAAa,CAACb,KAAK,CAAC,IAAI,CAAC;EAElD,IAAIe,UAAU,GAAG,CAAC;EAClB,IAAInB,IAAI;EACR,IAAIoB,kBAAkB,GAAG,KAAK;EAC9B,IAAIC,YAAY,GAAG,KAAK;EACxBC,QAAQ,EAAE,OAAO,CAACtB,IAAI,GAAGkB,kBAAkB,CAACK,KAAK,CAAC,CAAC,MAAMhD,SAAS,EAAE;IAClE,IAAIiD,UAAU,GAAGL,UAAU,GAAGnB,IAAI,CAACO,MAAM;IACzCkB,QAAQ,EAAE,OAAON,UAAU,GAAGK,UAAU,EAAEL,UAAU,EAAE,EAAE;MACtD,IAAIO,QAAQ,GAAGT,aAAa,CAACE,UAAU,CAAC;MACxC,IAAIO,QAAQ,KAAK,GAAG,IAAIA,QAAQ,KAAK,IAAI,EAAE;QACzCL,YAAY,GAAG,CAACA,YAAY;QAC5B,SAASI,QAAQ;MACnB,CAAC,MAAM,IAAIJ,YAAY,EAAE;QACvB,SAASI,QAAQ;MACnB,CAAC,MAAM,IAAIN,UAAU,GAAG,CAAC,GAAGK,UAAU,EAAE;QACtC,IAAIG,YAAY,GAAGD,QAAQ,GAAG1B,IAAI,CAACmB,UAAU,GAAG,CAAC,CAAC;QAClD,IAAIQ,YAAY,KAAK,IAAI,EAAE;UACzBR,UAAU,GAAGK,UAAU,GAAG,CAAC;UAC3B,SAASF,QAAQ;QACnB,CAAC,MAAM,IAAIK,YAAY,KAAK,IAAI,EAAE;UAChCP,kBAAkB,GAAG,IAAI;UACzBD,UAAU,IAAI,CAAC;UACf,SAASM,QAAQ;QACnB,CAAC,MAAM,IAAIE,YAAY,KAAK,IAAI,EAAE;UAChCP,kBAAkB,GAAG,KAAK;UAC1BD,UAAU,IAAI,CAAC;UACf,SAASM,QAAQ;QACnB;MACF;MAEA,IAAI,CAACL,kBAAkB,IAAIM,QAAQ,KAAKV,IAAI,EAAE;QAC5C,OAAOG,UAAU,GAAGnC,KAAK,CAACjB,CAAC,CAACE,QAAQ;MACtC;IACF;;IAEA;IACAkD,UAAU,EAAE;IACZE,YAAY,GAAG,KAAK;EACtB;EAEA,MAAM,IAAIO,KAAK,CAAC,GAAG,GAAGZ,IAAI,GAAG,cAAc,CAAC;AAC9C;;AAEA;AACA;AACA;AACA,SAASa,eAAeA,CAACpC,GAAG,EAAET,KAAK,EAAE;EACnCQ,OAAO,CAACC,GAAG,EAAET,KAAK,EAAE2B,gBAAgB,CAAC;AACvC;;AAEA;AACA;AACA;AACA,SAASmB,iBAAiBA,CAACrC,GAAG,EAAET,KAAK,EAAE;EACrCQ,OAAO,CAACC,GAAG,EAAET,KAAK,EAAE8B,cAAc,CAAC;AACrC;;AAEA;AACA;AACA;AACA,IAAIiB,YAAY,GAAG,QAAQ;AAC3B,SAASC,eAAeA,CAACpB,KAAK,EAAE;EAC9B,OAAOA,KAAK,CAACC,OAAO,CAACkB,YAAY,EAAE,YAAW;IAC5C,OAAO,EAAE;EACX,CAAC,CAAC;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAASE,eAAeA,CAACxC,GAAG,EAAET,KAAK,EAAE;EACnCQ,OAAO,CAACC,GAAG,EAAET,KAAK,EAAEgD,eAAe,CAAC;AACtC;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,SAASE,IAAIA,CAACzC,GAAG,EAAET,KAAK,EAAE;EACxB;EACA,IAAIA,KAAK,CAACjB,CAAC,CAACS,SAAS,EAAE;IACrB,IAAIiB,GAAG,GAAGT,KAAK,CAACjB,CAAC,CAACE,QAAQ,EAAE;MAC1Be,KAAK,CAACjB,CAAC,CAACE,QAAQ,GAAG,CAAC;MACpBe,KAAK,CAACjB,CAAC,CAACW,UAAU,GAAG,CAAC;MACtBM,KAAK,CAACjB,CAAC,CAACc,YAAY,GAAG,CAAC;IAC1B;IAEA,IAAI9B,MAAM,GAAGiC,KAAK,CAACjB,CAAC,CAAChB,MAAM,CAAC4C,SAAS,CAACX,KAAK,CAACjB,CAAC,CAACE,QAAQ,EAAEwB,GAAG,CAAC;IAC5D,IAAIU,WAAW,GAAGpD,MAAM,CAACqD,KAAK,CAAC,IAAI,CAAC;IACpC,IAAID,WAAW,CAACI,MAAM,GAAG,CAAC,EAAE;MAC1BvB,KAAK,CAACjB,CAAC,CAACW,UAAU,IAAIyB,WAAW,CAACI,MAAM,GAAG,CAAC;MAC5CvB,KAAK,CAACjB,CAAC,CAACc,YAAY,GAAG,CAAC;IAC1B;IACAG,KAAK,CAACjB,CAAC,CAACc,YAAY,IAAIsB,WAAW,CAACA,WAAW,CAACI,MAAM,GAAG,CAAC,CAAC,CAACA,MAAM;EACpE;EACAvB,KAAK,CAACjB,CAAC,CAACE,QAAQ,GAAGwB,GAAG;AACxB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS0C,MAAMA,CAACC,GAAG,EAAEpD,KAAK,EAAE;EAC1B,IAAIA,KAAK,CAACjB,CAAC,CAACS,SAAS,IAAI4D,GAAG,EAAE;IAC5BpD,KAAK,CAACjB,CAAC,CAACS,SAAS,CAACsB,UAAU,CAAC;MAC3BC,SAAS,EAAE;QAAEC,IAAI,EAAEhB,KAAK,CAACjB,CAAC,CAACY,UAAU;QAAEsB,MAAM,EAAEjB,KAAK,CAACjB,CAAC,CAACe;MAAa,CAAC;MACrEoB,QAAQ,EAAE;QAAEF,IAAI,EAAEhB,KAAK,CAACjB,CAAC,CAACW,UAAU;QAAEuB,MAAM,EAAEjB,KAAK,CAACjB,CAAC,CAACc;MAAa,CAAC;MACpE9B,MAAM,EAAEiC,KAAK,CAACjB,CAAC,CAACU;IAClB,CAAC,CAAC;IACF,IAAI4B,gBAAgB,GAAG+B,GAAG,CAAChC,KAAK,CAAC,IAAI,CAAC;IACtC,IAAIC,gBAAgB,CAACE,MAAM,GAAG,CAAC,EAAE;MAC/BvB,KAAK,CAACjB,CAAC,CAACY,UAAU,IAAI0B,gBAAgB,CAACE,MAAM,GAAG,CAAC;MACjDvB,KAAK,CAACjB,CAAC,CAACe,YAAY,GAAG,CAAC;IAC1B;IACAE,KAAK,CAACjB,CAAC,CAACe,YAAY,IAClBuB,gBAAgB,CAACA,gBAAgB,CAACE,MAAM,GAAG,CAAC,CAAC,CAACA,MAAM;EACxD;EACAvB,KAAK,CAACjB,CAAC,CAACI,MAAM,IAAIiE,GAAG;AACvB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASvC,YAAYA,CAACuC,GAAG,EAAEpD,KAAK,EAAE;EAChC;EACA,IAAIlB,QAAQ,GAAGkB,KAAK,CAAClB,QAAQ;EAC7B,IAAIA,QAAQ,GAAG,CAAC,EAAE;IAChB,KAAK,IAAIwC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,CAACxC,QAAQ,EAAEwC,CAAC,EAAE,EAAE;MAClC8B,GAAG,GAAGA,GAAG,CAACvB,OAAO,CAACjE,mBAAmB,EAAE,IAAI,CAAC;IAC9C;EACF,CAAC,MAAM;IACL,KAAK,IAAI0D,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGxC,QAAQ,EAAEwC,CAAC,EAAE,EAAE;MACjC8B,GAAG,GAAGA,GAAG,CAACvB,OAAO,CAACjE,mBAAmB,EAAE,QAAQ,CAAC;IAClD;EACF;EACA,OAAOwF,GAAG;AACZ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,YAAYA,CAACC,KAAK,EAAEtD,KAAK,EAAE;EAClC,IAAIS,GAAG,GAAG6C,KAAK;EACfA,KAAK,GAAGA,KAAK,GAAG,CAAC;EAEjB,OAAOA,KAAK,GAAG,CAAC,IAAItD,KAAK,CAACjB,CAAC,CAAChB,MAAM,CAACuF,KAAK,CAAC,IAAI,IAAI,EAAE;IACjD,IAAI,CAACtD,KAAK,CAACjB,CAAC,CAAChB,MAAM,CAACuF,KAAK,CAAC,CAACC,KAAK,CAAC,OAAO,CAAC,EAAE;MACzC9C,GAAG,GAAG6C,KAAK;IACb;IACAA,KAAK,EAAE;EACT;EACA,OAAOtD,KAAK,CAACjB,CAAC,CAAChB,MAAM,CAAC4C,SAAS,CAAC2C,KAAK,GAAG,CAAC,EAAE7C,GAAG,CAAC;AACjD;AAEA,SAAS+C,WAAWA,CAACxD,KAAK,EAAE;EAC1B,IAAI,CAACA,KAAK,CAACjB,CAAC,CAACK,QAAQ,EAAE;IACrB,IAAIA,QAAQ,GAAGzB,OAAO,CAAC,YAAY,CAAC;IACpCqC,KAAK,CAACjB,CAAC,CAACK,QAAQ,GACdA,QAAQ,CAACqE,aAAa,CAACrE,QAAQ,CAACsE,OAAO,CAAC1D,KAAK,CAACjB,CAAC,CAAChB,MAAM,CAAC,CAAC;EAC5D;EACA,OAAOiC,KAAK,CAACjB,CAAC,CAACK,QAAQ;AACzB;AAEA,SAASuE,uBAAuBA,CAACC,SAAS,EAAE5D,KAAK,EAAE6D,cAAc,EAAE;EACjE,IAAIC,SAAS,GAAG9D,KAAK,CAAC9B,UAAU;EAChC,OAAO4F,SAAS,EAAE;IAChB,IAAIA,SAAS,CAACzF,WAAW,CAACuF,SAAS,CAAC,KAAKrE,SAAS,EAAE;MAClD,OAAO,IAAI;IACb;IAEA,IAAIsE,cAAc,IAAIC,SAAS,CAAC3F,UAAU,KAAK0F,cAAc,EAAE;MAC7D;IACF;IAEAC,SAAS,GAAGA,SAAS,CAAC1F,WAAW;EACnC;EACA,OAAO,KAAK;AACd;AAEA,SAAS2F,iBAAiBA,CAACH,SAAS,EAAE5D,KAAK,EAAE;EAC3C,OAAOA,KAAK,CAAC9B,UAAU,CAACG,WAAW,CAACuF,SAAS,CAAC,KAAKrE,SAAS;AAC9D;;AAEA;AACA;AACA;AACA;AACA;AACA,SAASyE,iBAAiBA,CAACC,YAAY,EAAEC,IAAI,EAAEzC,IAAI,EAAE;EACnD,OAAO;IACLwC,YAAY,EAAEA,YAAY;IAC1BE,WAAW,EAAED,IAAI;IACjBE,WAAW,EAAE3C;EACf,CAAC;AACH;AAEA,SAAS4C,wBAAwBA,CAACT,SAAS,EAAEU,QAAQ,EAAEtE,KAAK,EAAE;EAC5DA,KAAK,CAAC9B,UAAU,CAACG,WAAW,CAACuF,SAAS,CAAC,GAAG;IACxCK,YAAY,EAAEK,QAAQ,CAACL,YAAY;IACnCC,IAAI,EAAEI,QAAQ,CAACH,WAAW;IAC1B1C,IAAI,EAAE6C,QAAQ,CAACF,WAAW;IAC1BpE,KAAK,EAAEG,MAAM,CAACC,MAAM,CAACJ,KAAK;EAC5B,CAAC;AACH;AAEA,SAASuE,yBAAyBA,CAACX,SAAS,EAAE5D,KAAK,EAAE;EACnD,IAAI8D,SAAS,GAAG9D,KAAK,CAAC9B,UAAU;EAChC,OAAO4F,SAAS,EAAE;IAChB,IAAIA,SAAS,CAACzF,WAAW,CAACuF,SAAS,CAAC,KAAKrE,SAAS,EAAE;MAClD,OAAOuE,SAAS,CAACzF,WAAW,CAACuF,SAAS,CAAC;IACzC;IAEAE,SAAS,GAAGA,SAAS,CAAC1F,WAAW;EACnC;AACF;AAEA,SAASoG,uBAAuBA,CAACZ,SAAS,EAAE5D,KAAK,EAAE;EACjD,OAAOA,KAAK,CAAC9B,UAAU,CAACG,WAAW,CAACuF,SAAS,CAAC;AAChD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASa,kBAAkBA,CAACC,QAAQ,EAAEC,SAAS,EAAElD,IAAI,EAAEyC,IAAI,EAAElE,KAAK,EAAE;EAClE,IAAIyB,IAAI,CAACmD,IAAI,EAAE;IACb,IAAIF,QAAQ,CAACjD,IAAI,EAAEyC,IAAI,EAAElE,KAAK,CAAC,KAAK,KAAK,EAAE;MACzC;IACF;IACAkE,IAAI,CAACW,OAAO,CAACpD,IAAI,CAAC;EACpB;EAEAqD,kBAAkB,CAACrD,IAAI,CAAC,CAACnB,OAAO,CAAC,UAASyE,KAAK,EAAE;IAC/CJ,SAAS,CAACI,KAAK,EAAEb,IAAI,EAAElE,KAAK,CAAC;EAC/B,CAAC,CAAC;EAEFyB,IAAI,CAACmD,IAAI,IAAIV,IAAI,CAAC3B,KAAK,CAAC,CAAC;AAC3B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASuC,kBAAkBA,CAACrD,IAAI,EAAE;EAChC,IAAIuD,KAAK,GAAG,EAAE;EACd,KAAK,IAAIC,GAAG,IAAIxD,IAAI,EAAE;IACpB,IAAIA,IAAI,CAACyD,cAAc,CAACD,GAAG,CAAC,EAAE;MAC5BE,yBAAyB,CAACH,KAAK,EAAEvD,IAAI,CAACwD,GAAG,CAAC,CAAC;IAC7C;EACF;EACAD,KAAK,CAACI,IAAI,CAAC,UAASC,CAAC,EAAEC,CAAC,EAAE;IAAE,OAAOD,CAAC,CAAC,CAAC,CAAC,GAAGC,CAAC,CAAC,CAAC,CAAC;EAAE,CAAC,CAAC;EAClD,OAAON,KAAK,CAACO,GAAG,CAAC,UAASC,IAAI,EAAE;IAAE,OAAOA,IAAI,CAAC,CAAC,CAAC;EAAE,CAAC,CAAC;AACtD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASL,yBAAyBA,CAACH,KAAK,EAAEvD,IAAI,EAAE;EAC9C,IAAI,OAAOA,IAAI,KAAK,QAAQ,IAAIA,IAAI,KAAK,IAAI,EAAE;IAC7C;EACF;EACA,IAAIA,IAAI,CAACC,KAAK,EAAE;IACdsD,KAAK,CAACS,IAAI,CAAC,CAAChE,IAAI,EAAEA,IAAI,CAACC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;EACnC,CAAC,MAAM,IAAIgE,KAAK,CAACC,OAAO,CAAClE,IAAI,CAAC,EAAE;IAC9B,KAAK,IAAImE,EAAE,GAAG,CAAC,EAAEA,EAAE,GAAGnE,IAAI,CAACF,MAAM,EAAEqE,EAAE,EAAE,EAAE;MACvCT,yBAAyB,CAACH,KAAK,EAAEvD,IAAI,CAACmE,EAAE,CAAC,CAAC;IAC5C;EACF;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,mBAAmBA,CAACpE,IAAI,EAAEmD,IAAI,EAAE;EACvC,OAAOkB,qBAAqB,CAACrE,IAAI,EAAE,UAASA,IAAI,EAAE;IAChD,OAAOA,IAAI,CAACmD,IAAI,KAAKA,IAAI;EAC3B,CAAC,CAAC;AACJ;AAEA,SAASkB,qBAAqBA,CAACrE,IAAI,EAAEsE,OAAO,EAAE;EAC5C,IAAIC,kBAAkB,GAAG,KAAK;EAC9B,SAASC,gBAAgBA,CAACxE,IAAI,EAAE;IAC9B,IAAIsE,OAAO,CAACtE,IAAI,CAAC,KAAK,IAAI,EAAE;MAC1BuE,kBAAkB,GAAG,IAAI;MACzB,OAAO,KAAK;IACd;EACF;EACA,SAASE,iBAAiBA,CAACnB,KAAK,EAAEb,IAAI,EAAElE,KAAK,EAAE;IAC7C,IAAI,CAACgG,kBAAkB,EAAE;MACvBA,kBAAkB,GAAGF,qBAAqB,CAACf,KAAK,EAAEgB,OAAO,CAAC;IAC5D;EACF;EACAtB,kBAAkB,CAChBwB,gBAAgB,EAChBC,iBAAiB,EACjBzE,IAAI,EACJ,EACF,CAAC;EACD,OAAOuE,kBAAkB;AAC3B;AAEA,IAAIG,UAAU,GAAG,CAAC,CAAC;AACnBA,UAAU,CAACzI,MAAM,CAAC0I,uBAAuB,CAAC,GAAG,IAAI;AACjDD,UAAU,CAACzI,MAAM,CAAC2I,kBAAkB,CAAC,GAAG,IAAI;AAC5CF,UAAU,CAACzI,MAAM,CAAC4I,mBAAmB,CAAC,GAAG,IAAI;AAC7CH,UAAU,CAACzI,MAAM,CAAC6I,OAAO,CAAC,GAAG,IAAI;AAEjC,SAASC,eAAeA,CAACtC,IAAI,EAAE;EAC7B,KAAK,IAAI0B,EAAE,GAAG,CAAC,EAAEA,EAAE,GAAG1B,IAAI,CAAC3C,MAAM,EAAE,EAAEqE,EAAE,EAAE;IACvC,IAAIO,UAAU,CAACjC,IAAI,CAAC0B,EAAE,CAAC,CAAChB,IAAI,CAAC,EAAE;MAC7B,OAAOV,IAAI,CAAC0B,EAAE,CAAC;IACjB;EACF;EACA,MAAM,IAAIhD,KAAK,CACb,oEAAoE,GACpE6D,IAAI,CAACC,SAAS,CAACvG,MAAM,CAACE,IAAI,CAAC8F,UAAU,CAAC,CACxC,CAAC;AACH;AAEA,SAASQ,UAAUA,CAACrI,YAAY,EAAE;EAChC,OAAO,KAAK,GAAGA,YAAY;AAC7B;AAEA,SAASsI,aAAaA,CAAC5G,KAAK,EAAE;EAC5B,IAAI6G,OAAO,GAAG,KAAK,GAAI7G,KAAK,CAAC9B,UAAU,CAACI,YAAY,EAAG;EACvD0B,KAAK,CAAC9B,UAAU,CAACK,QAAQ,CAACkH,IAAI,CAACoB,OAAO,CAAC;EACvC,OAAOA,OAAO;AAChB;AAEA,SAASC,yBAAyBA,CAAC9G,KAAK,EAAE+G,KAAK,EAAE;EAC/C,IAAI/G,KAAK,CAAC9B,UAAU,CAACK,QAAQ,CAACgD,MAAM,EAAE;IACpCvB,KAAK,CAACjB,CAAC,CAACI,MAAM,GACZa,KAAK,CAACjB,CAAC,CAACI,MAAM,CAAC6H,KAAK,CAAC,CAAC,EAAED,KAAK,CAAC,GAC9B,MAAM,GAAG/G,KAAK,CAAC9B,UAAU,CAACK,QAAQ,CAAC0I,IAAI,CAAC,IAAI,CAAC,GAAG,GAAG,GACnDjH,KAAK,CAACjB,CAAC,CAACI,MAAM,CAAC6H,KAAK,CAACD,KAAK,CAAC;IAC7B/G,KAAK,CAAC9B,UAAU,CAACK,QAAQ,GAAG,EAAE;EAChC;AACF;AAEA2I,OAAO,CAACzC,kBAAkB,GAAGA,kBAAkB;AAC/CyC,OAAO,CAAC/D,MAAM,GAAGA,MAAM;AACvB+D,OAAO,CAAC1G,OAAO,GAAGA,OAAO;AACzB0G,OAAO,CAACjE,eAAe,GAAGA,eAAe;AACzCiE,OAAO,CAACrE,eAAe,GAAGA,eAAe;AACzCqE,OAAO,CAACpE,iBAAiB,GAAGA,iBAAiB;AAC7CoE,OAAO,CAACpB,qBAAqB,GAAGA,qBAAqB;AACrDoB,OAAO,CAACrB,mBAAmB,GAAGA,mBAAmB;AACjDqB,OAAO,CAACpJ,WAAW,GAAGA,WAAW;AACjCoJ,OAAO,CAAC7C,wBAAwB,GAAGA,wBAAwB;AAC3D6C,OAAO,CAACV,eAAe,GAAGA,eAAe;AACzCU,OAAO,CAAC1D,WAAW,GAAGA,WAAW;AACjC0D,OAAO,CAAC3C,yBAAyB,GAAGA,yBAAyB;AAC7D2C,OAAO,CAAC1C,uBAAuB,GAAGA,uBAAuB;AACzD0C,OAAO,CAACnF,0BAA0B,GAAGA,0BAA0B;AAC/DmF,OAAO,CAAC1F,iBAAiB,GAAGA,iBAAiB;AAC7C0F,OAAO,CAACpC,kBAAkB,GAAGA,kBAAkB;AAC/CoC,OAAO,CAACP,UAAU,GAAGA,UAAU;AAC/BO,OAAO,CAACnD,iBAAiB,GAAGA,iBAAiB;AAC7CmD,OAAO,CAACvD,uBAAuB,GAAGA,uBAAuB;AACzDuD,OAAO,CAAC7D,YAAY,GAAGA,YAAY;AACnC6D,OAAO,CAAClD,iBAAiB,GAAGA,iBAAiB;AAC7CkD,OAAO,CAACN,aAAa,GAAGA,aAAa;AACrCM,OAAO,CAACJ,yBAAyB,GAAGA,yBAAyB;AAC7DI,OAAO,CAAChE,IAAI,GAAGA,IAAI;AACnBgE,OAAO,CAACf,UAAU,GAAGA,UAAU;AAC/Be,OAAO,CAACrG,YAAY,GAAGA,YAAY;AACnCqG,OAAO,CAACnH,WAAW,GAAGA,WAAW","ignoreList":[]},"metadata":{},"sourceType":"script"}