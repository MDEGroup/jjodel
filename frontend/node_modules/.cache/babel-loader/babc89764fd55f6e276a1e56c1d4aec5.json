{"ast":null,"code":"var _dec, _class, _class2;\nimport { Log, RuntimeAccessible } from \"../joiner\";\n/*\r\n                                    TODO for every update: check the VersionFixer.help() function\r\n*/\n\nexport let VersionFixer = (_dec = RuntimeAccessible('VersionFixer'), _dec(_class = (_class2 = class VersionFixer {\n  // automatically updated from updater function names\n\n  static help() {\n    console.clear();\n    let i = 1;\n    console.log(`\nBefore deploying a new version you should:\n\n${i++}) Update changelog\n\n${i++}) make a separate build subfolder (so you can switch versions)\n\n${i++}) build a new empty versioning function with signature like: private ['2.1 -> 2.3'](s: DState): DState\n        fill this function in a way that translates from the state shape of the old version, to the state shape of the new one\n   \n        `);\n\n    // DEPRECATED stuff\n    false && console.log(`\nBefore deploying a new version you should:\n\n${i++}?) ONLY IF IT'S FIRST TIME;\n   run DState.registerFirstTimeOnly() in the deploy version and export the localStorage variables starting with ${VersionFixer.prefix} to the dev version.\n   or call it in dev version after having temporarly undone the pending updates if possible, otherwise next steps might fail.\n   \n${i++}?) ONLY IF there are entirely new kinds of D-objects or optional new sub-structures in D-objects (like View.palette), update buildVersionSignature() method\n \n\n${i++}) build a new empty versioning function with signature: private ['2.1 -> 2.3'](s: DState): DState\n\n${i++}) in DState update DState.version.n (leave date and conversionList unchanged)\n\n${i++}) open a new empty project (no models no metamodels)\n   to find out what changed in the state between version without risking human error, i made an automatic detection.\n   call VersionFixer.checkVersionChanges() in browser console to see what changed need conversion in the function (i would save the result as comment inside the func)\n\n${i++}) fill the empty function of step (1), in a way that translates from the state shape of the old version, to the state shape of the new one\n\n${i++}) only after the transition function is complete, call VersionFixer.registerNewVersion();\n   it will both validate the version update function and store the new version as baseline.\n   (needs to be done last because checkVersionChanges will stop working until a new version is ready)\n   \nBEWARE: this approach cannot detect changes of valid values where the type did not change. eg if view.appliableTo = 'string' change his valid string values but not his type;\neverytime you put hands into a D-Object shape or valid values, you should document them to be able to write a conversion function later on.\n        `);\n  }\n  static get_highestversion() {\n    if (VersionFixer.highestVersion === 0) VersionFixer.setup();\n    return VersionFixer.highestVersion;\n  }\n  static setup() {\n    VersionFixer.versionAdapters = {};\n    const errormsg = k => \"Version auto-updater have a updater registered incorrectly: \\\"\" + k + \"\\\", please notify the developers.\";\n    for (let k in VersionFixer) {\n      switch (k) {\n        case 'highestVersion':\n        case 'versionAdapters':\n        case 'get_highestversion':\n        case 'cname':\n        case 'prefix':\n        case 'help':\n        case 'setup':\n        case 'update':\n          continue;\n      }\n      let [froms, tos] = k.split(' -> ');\n      Log.exDev(!(froms === null || froms === void 0 ? void 0 : froms.length) || !(tos === null || tos === void 0 ? void 0 : tos.length), errormsg(k));\n      let from = +froms;\n      let to = +tos;\n      Log.exDev(isNaN(from) || isNaN(to), errormsg(k));\n      Log.exDev(!!VersionFixer.versionAdapters[from], \"duplicate version adapter from \\\"\" + from + \"\\\", please notify the developers.\");\n      VersionFixer.highestVersion = Math.max(VersionFixer.highestVersion, to);\n      VersionFixer.versionAdapters[from] = {\n        n: to,\n        f: VersionFixer[k]\n      };\n    }\n    return VersionFixer.versionAdapters;\n  }\n  static update(s) {\n    if (!VersionFixer.versionAdapters) VersionFixer.setup();\n    if (!s.version) s.version = {\n      n: 2.1,\n      date: \"_reconverted\",\n      conversionList: [0]\n    };\n    let prevVer = s.version.n || 0;\n    let currVer = prevVer;\n    while (currVer !== VersionFixer.highestVersion) {\n      Log.exDev(!VersionFixer.versionAdapters[currVer], \"missing version adapter from \\\"\" + currVer + \"\\\", please notify the developers.\");\n      console.log('versionfixer update', {\n        prevVer,\n        currVer\n      });\n      let {\n        n,\n        f\n      } = VersionFixer.versionAdapters[currVer];\n      console.log('versionfixer update', {\n        prevVer,\n        currVer,\n        n\n      });\n      s.version.conversionList = [...s.version.conversionList, s.version.n];\n      s = f(s);\n      currVer = s.version.n = n || 0;\n      Log.exDev(currVer !== n, \"version updater updated to incorrect target versionn \\\"\" + prevVer + \"\\\" -> \\\"\" + n + \"\\\" , please notify the developers.\");\n      Log.exDev(currVer <= prevVer, \"version updater found loop at version \\\"\" + currVer + \"\\\", please notify the developers.\");\n      prevVer = currVer;\n    }\n    return s;\n  }\n  d(ptr, s) {\n    return s.idlookup[ptr];\n    // {n}\n  }\n  ['0 -> 2.1'](s) {\n    s.version = {\n      n: 2.1,\n      date: \"_reconverted\",\n      conversionList: [0]\n    };\n    return s;\n  }\n  ['2.1 -> 2.2'](s) {\n    // let ls: LState = LPointerTargetable.from(s); nope, avoid L-ojects. actions would fire in present state instead of in parameter state\n    for (let c of s.classs.map(p => this.d(p, s))) {\n      c.isSingleton = !!c.isSingleton; // booleanize the undefined\n      c.sealed = [];\n      c.final = false;\n      c.rootable = undefined;\n    }\n    for (let c of Object.values(s.idlookup)) {\n      if ((c === null || c === void 0 ? void 0 : c.className) && c.id && c.isCrossReference === undefined) c.isCrossReference = false;\n    }\n    for (let c of s.viewelements.map(p => this.d(p, s))) {\n      c.father = c.viewpoint;\n    }\n    for (let c of s.viewpoints.map(p => this.d(p, s))) {\n      c.cssIsGlobal = true;\n    }\n    for (let c of s.projects.map(p => this.d(p, s))) {\n      c.favorite = {};\n      c.description = '';\n    }\n    for (let c of s.references.map(p => this.d(p, s))) {\n      if (c.composition === undefined) c.aggregation = !(c.composition = !!c.containment);\n    }\n    for (let c of s.models.map(p => this.d(p, s))) {\n      if (c.dependencies === undefined) c.dependencies = [];\n    }\n    for (let c of s.attributes.map(p => this.d(p, s))) {\n      c.derived = !!c.derived;\n      c.derived_write = undefined; // c.derived ? '' : undefined;\n      c.derived_read = undefined; // c.derived ? '' : undefined;\n    }\n    return s;\n  }\n}, _class2.cname = 'VersionFixer', _class2.versionAdapters = _class2.setup(), _class2.highestVersion = 0, _class2.prefix = '__jodel_versioning_', _class2)) || _class);\n\n//deprecated stuff\n\n/*\r\npublic static checkVersionChanges(): GObject{\r\n    let lastVerName = localStorage.getItem(VersionFixer.prefix+'last');\r\n    let lastVerState = localStorage.getItem(VersionFixer.prefix+lastVerName);\r\n    let lastVersionSignature = JSON.parse(lastVerState || '{not:\"found\"}');\r\n    let newVersionSignature = this.buildVersionSignature();\r\n    return VersionFixer.checkVersionChanges_inner(lastVersionSignature, newVersionSignature);\r\n}\r\npublic static checkVersionChanges_inner(s1: DState, s2:DState): GObject{ return U.objectDelta(s1, s2, true); }\r\npublic static registerFirstTimeOnly(): void {\r\n    let newVersionSignature = VersionFixer.buildVersionSignature();\r\n    localStorage.setItem(VersionFixer.prefix+'last', ''+newVersionSignature.version.n);\r\n    localStorage.setItem(VersionFixer.prefix+''+newVersionSignature.version.n, JSON.stringify(newVersionSignature));\r\n}\r\n\r\npublic static registerNewVersion(): boolean {\r\n    let lastVerName = localStorage.getItem(VersionFixer.prefix+'last');\r\n    let prevVersionSignature: DState = JSON.parse(localStorage.getItem(VersionFixer.prefix+lastVerName) || '{not:\"found\"}') as any;\r\n    let newVersionSignature = VersionFixer.buildVersionSignature();\r\n    let updatedVersionSignature = this.update(prevVersionSignature);\r\n    let versionDiff: GObject = VersionFixer.checkVersionChanges_inner(updatedVersionSignature, newVersionSignature);\r\n    if (Object.keys(versionDiff).length !== 0) {\r\n        console.log(\"failed to save new version, the conversion function is not updating state properly.\",\r\n            {versionDiff, prevVersionSignature, newVersionSignature, updatedVersionSignature});\r\n        return false;\r\n    }\r\n    localStorage.setItem(VersionFixer.prefix+'last', ''+newVersionSignature.version.n);\r\n    localStorage.setItem(VersionFixer.prefix+''+newVersionSignature.version.n, JSON.stringify(newVersionSignature));\r\n    return true;\r\n}\r\nprivate static buildVersionSignature(): DState {\r\n    // purpose: save in state 1 of each D-objects with all the possible sub-objects in every possible structure shape\r\n    // values can be dummy but syntactical valid\r\n    //DState.new(); nope, i'm using current state, just call it from an empty project with no models.\r\n    DViewElement.new2(\"View\", \"jsx\", undefined,(d)=>{\r\n        d.appliableTo = 'Any';\r\n        d.subViews = {[\"Sample-fake-subView\"]: 3.5};\r\n        d.oclUpdateCondition = '(view: LViewElement) => { return false; } <--- as a string'\r\n        d.defaultVSize = new GraphSize(5,5,5,5);\r\n        d.palette = {\r\n            \"color\": {type:'color', value: [{r:0, g:0, b:0, a:0}]} as PaletteControl,\r\n            \"number\": {type:'number', value: 4, unit: 'px'} as NumberControl,\r\n            \"text\": {type:'text', value: 'stringa'} as StringControl,\r\n            \"path\": {type:'path', value: 'M 00 L 1 1 Z', x: '5', y: '10', options: [{k: 'optionnale', v:'option path M 0 0 L 5 5 Z'}]} as PathControl,\r\n        };\r\n        d.events = {[\"function name\"]: \"function body\"};\r\n        d.bendingMode = EdgeBendingMode.Bezier_QT;\r\n        d.edgeGapMode = EdgeGapMode.gap;\r\n        d.size = {[\"node or model Pointer\"]: new GraphSize(5,5,5,5)};\r\n        d.edgeStartOffset = new GraphPoint(5,5);\r\n        d.edgeEndOffset = new GraphPoint(5,5);\r\n        d.edgePointCoordMode = CoordinateMode.relativePercent;\r\n        d.edgeHeadSize = new GraphPoint(5,5);\r\n        d.edgeTailSize = new GraphPoint(5,5);\r\n    }, true, 'DViewElement');\r\n\r\n\r\n\r\n    return store.getState();\r\n}\r\n*/","map":{"version":3,"names":["Log","RuntimeAccessible","VersionFixer","_dec","_class","_class2","help","console","clear","i","log","prefix","get_highestversion","highestVersion","setup","versionAdapters","errormsg","k","froms","tos","split","exDev","length","from","to","isNaN","Math","max","n","f","update","s","version","date","conversionList","prevVer","currVer","d","ptr","idlookup","0 -> 2.1","2.1 -> 2.2","c","classs","map","p","isSingleton","sealed","final","rootable","undefined","Object","values","className","id","isCrossReference","viewelements","father","viewpoint","viewpoints","cssIsGlobal","projects","favorite","description","references","composition","aggregation","containment","models","dependencies","attributes","derived","derived_write","derived_read","cname"],"sources":["C:/0Programmi/Dev/projects/frontend/jjodel/src/redux/VersionFixer.ts"],"sourcesContent":["import {\r\n    CoordinateMode,\r\n    Defaults,\r\n    Dictionary, DocString, DPointerTargetable, DReference,\r\n    DState, DStructuralFeature,\r\n    DViewElement,\r\n    EdgeBendingMode,\r\n    EdgeGapMode,\r\n    GObject,\r\n    GraphPoint,\r\n    GraphSize, LClass,\r\n    Log, LPointerTargetable, LState, Pointer, RuntimeAccessible, RuntimeAccessibleClass, store,\r\n    U\r\n} from \"../joiner\";\r\nimport {NumberControl, PaletteControl, PathControl, StringControl} from \"../view/viewElement/view\";\r\n\r\n/*\r\n                                    TODO for every update: check the VersionFixer.help() function\r\n*/\r\n\r\n@RuntimeAccessible('VersionFixer')\r\nexport class VersionFixer {\r\n    public static cname = 'VersionFixer';\r\n    private static versionAdapters: Dictionary<number/*version*/, {n: number, f:(s: DState)=>DState}> = VersionFixer.setup();\r\n    private static highestVersion: number = 0; // automatically updated from updater function names\r\n    private static prefix: string = '__jodel_versioning_';\r\n    public static help(){\r\n        console.clear();\r\n        let i: number  = 1;\r\n\r\n        console.log(`\r\nBefore deploying a new version you should:\r\n\r\n${i++}) Update changelog\r\n\r\n${i++}) make a separate build subfolder (so you can switch versions)\r\n\r\n${i++}) build a new empty versioning function with signature like: private ['2.1 -> 2.3'](s: DState): DState\r\n        fill this function in a way that translates from the state shape of the old version, to the state shape of the new one\r\n   \r\n        `);\r\n\r\n\r\n\r\n        // DEPRECATED stuff\r\n        false && console.log(`\r\nBefore deploying a new version you should:\r\n\r\n${i++}?) ONLY IF IT'S FIRST TIME;\r\n   run DState.registerFirstTimeOnly() in the deploy version and export the localStorage variables starting with ${VersionFixer.prefix} to the dev version.\r\n   or call it in dev version after having temporarly undone the pending updates if possible, otherwise next steps might fail.\r\n   \r\n${i++}?) ONLY IF there are entirely new kinds of D-objects or optional new sub-structures in D-objects (like View.palette), update buildVersionSignature() method\r\n \r\n\r\n${i++}) build a new empty versioning function with signature: private ['2.1 -> 2.3'](s: DState): DState\r\n\r\n${i++}) in DState update DState.version.n (leave date and conversionList unchanged)\r\n\r\n${i++}) open a new empty project (no models no metamodels)\r\n   to find out what changed in the state between version without risking human error, i made an automatic detection.\r\n   call VersionFixer.checkVersionChanges() in browser console to see what changed need conversion in the function (i would save the result as comment inside the func)\r\n\r\n${i++}) fill the empty function of step (1), in a way that translates from the state shape of the old version, to the state shape of the new one\r\n\r\n${i++}) only after the transition function is complete, call VersionFixer.registerNewVersion();\r\n   it will both validate the version update function and store the new version as baseline.\r\n   (needs to be done last because checkVersionChanges will stop working until a new version is ready)\r\n   \r\nBEWARE: this approach cannot detect changes of valid values where the type did not change. eg if view.appliableTo = 'string' change his valid string values but not his type;\r\neverytime you put hands into a D-Object shape or valid values, you should document them to be able to write a conversion function later on.\r\n        `);\r\n    }\r\n    public static get_highestversion(): number{\r\n        if (VersionFixer.highestVersion === 0) VersionFixer.setup();\r\n        return VersionFixer.highestVersion;\r\n    }\r\n\r\n    private static setup(): (typeof VersionFixer)[\"versionAdapters\"]{\r\n        VersionFixer.versionAdapters = {};\r\n        const errormsg = (k: string)=>\"Version auto-updater have a updater registered incorrectly: \\\"\" + k + \"\\\", please notify the developers.\"\r\n        for (let k in VersionFixer){\r\n            switch(k){\r\n                case 'highestVersion': case 'versionAdapters':\r\n                case 'get_highestversion':\r\n                case 'cname': case 'prefix': case 'help':\r\n                case 'setup': case 'update': continue;\r\n            }\r\n            let [froms, tos] = k.split(' -> ');\r\n            Log.exDev(!froms?.length || !tos?.length, errormsg(k));\r\n            let from = +froms; let to = +tos;\r\n            Log.exDev(isNaN(from) || isNaN(to), errormsg(k));\r\n            Log.exDev(!!VersionFixer.versionAdapters[from], \"duplicate version adapter from \\\"\"+from+\"\\\", please notify the developers.\")\r\n            VersionFixer.highestVersion = Math.max(VersionFixer.highestVersion, to);\r\n            VersionFixer.versionAdapters[from] = {n:to, f: (VersionFixer as any)[k]}\r\n        }\r\n        return VersionFixer.versionAdapters;\r\n    }\r\n\r\n    public static update(s: DState): DState{\r\n        if (!VersionFixer.versionAdapters) VersionFixer.setup();\r\n        if (!s.version) s.version = {n: 2.1, date:\"_reconverted\", conversionList:[0]};\r\n        let prevVer = s.version.n || 0;\r\n        let currVer = prevVer;\r\n        while (currVer !== VersionFixer.highestVersion) {\r\n            Log.exDev(!VersionFixer.versionAdapters[currVer], \"missing version adapter from \\\"\"+ currVer+\"\\\", please notify the developers.\");\r\n            console.log('versionfixer update', {prevVer, currVer});\r\n            let {n, f} = VersionFixer.versionAdapters[currVer];\r\n            console.log('versionfixer update', {prevVer, currVer, n});\r\n\r\n            s.version.conversionList = [...s.version.conversionList, s.version.n];\r\n            s = f(s);\r\n            currVer = s.version.n = n || 0;\r\n            Log.exDev(currVer !== n, \"version updater updated to incorrect target versionn \\\"\"+prevVer+\"\\\" -> \\\"\"+n+\"\\\" , please notify the developers.\");\r\n            Log.exDev(currVer <= prevVer, \"version updater found loop at version \\\"\"+currVer+\"\\\", please notify the developers.\");\r\n            prevVer = currVer;\r\n        }\r\n        return s;\r\n    }\r\n\r\n\r\n    private d<D extends DPointerTargetable, L extends LPointerTargetable>(ptr: Pointer<D>, s: DState): D{\r\n        return s.idlookup[ptr] as any;\r\n        // {n}\r\n    }\r\n    private ['0 -> 2.1'](s: DState): DState {\r\n        s.version = {n: 2.1, date:\"_reconverted\", conversionList:[0]};\r\n        return s;\r\n    }\r\n    private ['2.1 -> 2.2'](s: DState): DState {\r\n        // let ls: LState = LPointerTargetable.from(s); nope, avoid L-ojects. actions would fire in present state instead of in parameter state\r\n        for (let c of (s.classs).map(p=> this.d(p, s))) {\r\n            c.isSingleton = !!c.isSingleton; // booleanize the undefined\r\n            c.sealed = [];\r\n            c.final = false;\r\n            c.rootable = undefined;\r\n        }\r\n        for (let c of Object.values(s.idlookup) as any[]) { if (c?.className && c.id && c.isCrossReference === undefined) c.isCrossReference = false; }\r\n        for (let c of (s.viewelements).map(p=> this.d(p, s))) { c.father = c.viewpoint; }\r\n        for (let c of (s.viewpoints).map(p=> this.d(p, s))) { c.cssIsGlobal = true; }\r\n        for (let c of (s.projects).map(p=> this.d(p, s))) { c.favorite = {}; c.description = ''; }\r\n        for (let c of (s.references).map(p=> this.d(p, s))) { if (c.composition === undefined) c.aggregation = !(c.composition = !!(c as any).containment); }\r\n        for (let c of (s.models).map(p=> this.d(p, s))) { if (c.dependencies === undefined) c.dependencies = []; }\r\n        for (let c of (s.attributes).map(p=> this.d(p, s))) {\r\n            c.derived = !!c.derived;\r\n            c.derived_write = undefined; // c.derived ? '' : undefined;\r\n            c.derived_read = undefined; // c.derived ? '' : undefined;\r\n        }\r\n\r\n        return s;\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n//deprecated stuff\r\n\r\n\r\n\r\n/*\r\npublic static checkVersionChanges(): GObject{\r\n    let lastVerName = localStorage.getItem(VersionFixer.prefix+'last');\r\n    let lastVerState = localStorage.getItem(VersionFixer.prefix+lastVerName);\r\n    let lastVersionSignature = JSON.parse(lastVerState || '{not:\"found\"}');\r\n    let newVersionSignature = this.buildVersionSignature();\r\n    return VersionFixer.checkVersionChanges_inner(lastVersionSignature, newVersionSignature);\r\n}\r\npublic static checkVersionChanges_inner(s1: DState, s2:DState): GObject{ return U.objectDelta(s1, s2, true); }\r\npublic static registerFirstTimeOnly(): void {\r\n    let newVersionSignature = VersionFixer.buildVersionSignature();\r\n    localStorage.setItem(VersionFixer.prefix+'last', ''+newVersionSignature.version.n);\r\n    localStorage.setItem(VersionFixer.prefix+''+newVersionSignature.version.n, JSON.stringify(newVersionSignature));\r\n}\r\n\r\npublic static registerNewVersion(): boolean {\r\n    let lastVerName = localStorage.getItem(VersionFixer.prefix+'last');\r\n    let prevVersionSignature: DState = JSON.parse(localStorage.getItem(VersionFixer.prefix+lastVerName) || '{not:\"found\"}') as any;\r\n    let newVersionSignature = VersionFixer.buildVersionSignature();\r\n    let updatedVersionSignature = this.update(prevVersionSignature);\r\n    let versionDiff: GObject = VersionFixer.checkVersionChanges_inner(updatedVersionSignature, newVersionSignature);\r\n    if (Object.keys(versionDiff).length !== 0) {\r\n        console.log(\"failed to save new version, the conversion function is not updating state properly.\",\r\n            {versionDiff, prevVersionSignature, newVersionSignature, updatedVersionSignature});\r\n        return false;\r\n    }\r\n    localStorage.setItem(VersionFixer.prefix+'last', ''+newVersionSignature.version.n);\r\n    localStorage.setItem(VersionFixer.prefix+''+newVersionSignature.version.n, JSON.stringify(newVersionSignature));\r\n    return true;\r\n}\r\nprivate static buildVersionSignature(): DState {\r\n    // purpose: save in state 1 of each D-objects with all the possible sub-objects in every possible structure shape\r\n    // values can be dummy but syntactical valid\r\n    //DState.new(); nope, i'm using current state, just call it from an empty project with no models.\r\n    DViewElement.new2(\"View\", \"jsx\", undefined,(d)=>{\r\n        d.appliableTo = 'Any';\r\n        d.subViews = {[\"Sample-fake-subView\"]: 3.5};\r\n        d.oclUpdateCondition = '(view: LViewElement) => { return false; } <--- as a string'\r\n        d.defaultVSize = new GraphSize(5,5,5,5);\r\n        d.palette = {\r\n            \"color\": {type:'color', value: [{r:0, g:0, b:0, a:0}]} as PaletteControl,\r\n            \"number\": {type:'number', value: 4, unit: 'px'} as NumberControl,\r\n            \"text\": {type:'text', value: 'stringa'} as StringControl,\r\n            \"path\": {type:'path', value: 'M 00 L 1 1 Z', x: '5', y: '10', options: [{k: 'optionnale', v:'option path M 0 0 L 5 5 Z'}]} as PathControl,\r\n        };\r\n        d.events = {[\"function name\"]: \"function body\"};\r\n        d.bendingMode = EdgeBendingMode.Bezier_QT;\r\n        d.edgeGapMode = EdgeGapMode.gap;\r\n        d.size = {[\"node or model Pointer\"]: new GraphSize(5,5,5,5)};\r\n        d.edgeStartOffset = new GraphPoint(5,5);\r\n        d.edgeEndOffset = new GraphPoint(5,5);\r\n        d.edgePointCoordMode = CoordinateMode.relativePercent;\r\n        d.edgeHeadSize = new GraphPoint(5,5);\r\n        d.edgeTailSize = new GraphPoint(5,5);\r\n    }, true, 'DViewElement');\r\n\r\n\r\n\r\n    return store.getState();\r\n}\r\n*/"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}