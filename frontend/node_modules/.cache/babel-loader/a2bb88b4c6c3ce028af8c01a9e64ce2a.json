{"ast":null,"code":"var _jsxFileName = \"C:\\\\0Programmi\\\\Dev\\\\projects\\\\frontend\\\\jjodel\\\\frontend\\\\src\\\\model\\\\dataStructure\\\\GraphDataElements.tsx\",\n  _dec,\n  _class,\n  _class2,\n  _dec2,\n  _class3,\n  _class4,\n  _dec3,\n  _class5,\n  _class6,\n  _dec4,\n  _class7,\n  _class8,\n  _dec5,\n  _class9,\n  _class10,\n  _dec6,\n  _class11,\n  _class12,\n  _dec7,\n  _class13,\n  _class14,\n  _dec8,\n  _class15,\n  _class16,\n  _dec9,\n  _class17,\n  _class18,\n  _dec10,\n  _class19,\n  _class20,\n  _dec11,\n  _class21,\n  _class22,\n  _dec12,\n  _class23,\n  _class24,\n  _dec13,\n  _class25,\n  _class26,\n  _dec14,\n  _class27,\n  _dec15,\n  _class29,\n  _class30,\n  _dec16,\n  _class31,\n  _class32,\n  _dec17,\n  _class33,\n  _class34,\n  _dec18,\n  _class35,\n  _class36,\n  _dec19,\n  _class37,\n  _class38,\n  _dec20,\n  _class39,\n  _class40,\n  _dec21,\n  _class41,\n  _class42;\n// import {Mixin} from \"ts-mixer\";\nimport { isDeepStrictEqual } from \"util\";\nimport { Constructors, CoordinateMode, Debug, DPointerTargetable, DUser, EdgeBendingMode, GraphElementComponent, GraphPoint, GraphSize, IPoint, Keystrokes, L, Leaf, Log, LPointerTargetable, MixOnlyFuncs, Node, Point, Pointers, RuntimeAccessible, RuntimeAccessibleClass, SetFieldAction, SetRootFieldAction, ShortAttribETypes, Size, store, TargetableProxyHandler, TRANSACTION, transientProperties, U, Uarr, UX, windoww } from \"../../joiner\";\nimport { EdgeGapMode } from \"../../joiner/types\";\nimport { Geom, ISize } from \"../../common/Geom\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconsole.warn('ts loading graphDataElement');\nexport let DGraphElement = (_dec = RuntimeAccessible('DGraphElement'), Node(_class = _dec(_class = (_class2 = class DGraphElement extends DPointerTargetable {\n  constructor() {\n    super(...arguments);\n    this.id = void 0;\n    this.graph = void 0;\n    this.model = void 0;\n    this.isSelected = void 0;\n    this.subElements = void 0;\n    this.state = void 0;\n    this.father = void 0;\n    this.x = void 0;\n    this.y = void 0;\n    this.zIndex = 100;\n    this.w = void 0;\n    this.h = void 0;\n    this.view = void 0;\n    this.favoriteNode = void 0;\n    this.edgesIn = void 0;\n    this.edgesOut = void 0;\n    this.anchors = void 0;\n  } // static _super = DPointerTargetable;\n  // static singleton: LGraphElement;\n  // static logic: typeof LGraphElement;\n  // static structure: typeof DGraphElement;\n  // containedIn!: Pointer<DGraphElement, 0, 1, LGraphElement>;\n  // DMap\n  // width: number = 300;\n  // height: number = 400;\n  static new(htmlindex, model, parentNodeID, graphID, nodeID, a, b) {\n    return new Constructors(new DGraphElement('dwc'), parentNodeID, true, undefined, nodeID).DPointerTargetable().DGraphElement(model, graphID, htmlindex).end();\n  }\n  static nodeLFromHtml(target) {\n    return LPointerTargetable.fromPointer(DGraphElement.nodePtrFromHtml(target));\n  }\n  static nodeDFromHtml(target) {\n    return DPointerTargetable.fromPointer(DGraphElement.nodePtrFromHtml(target));\n  }\n  static nodePtrFromHtml(target) {\n    while (target) {\n      if (target.attributes.nodeid) return target.attributes.nodeid.value;\n      target = target.parentElement;\n    }\n    return undefined;\n  }\n  static graphLFromHtml(target) {\n    return LPointerTargetable.fromPointer(DGraphElement.graphPtrFromHtml(target));\n  }\n  static graphDFromHtml(target) {\n    return DPointerTargetable.fromPointer(DGraphElement.graphPtrFromHtml(target));\n  }\n  static graphPtrFromHtml(target) {\n    while (target) {\n      if (target.attributes.graphid) return target.attributes.graphid.value;\n      target = target.parentElement;\n    }\n    return undefined;\n  }\n}, _class2.subclasses = [], _class2._extends = [], _class2)) || _class) || _class);\nexport let LGraphElement = (_dec2 = RuntimeAccessible('LGraphElement'), _dec2(_class3 = (_class4 = class LGraphElement extends LPointerTargetable {\n  constructor() {\n    super(...arguments);\n    this.__raw = void 0;\n    this.id = void 0;\n    this.father = void 0;\n    this.model = void 0;\n    this._state = void 0;\n    this.x = void 0;\n    this.y = void 0;\n    this.width = void 0;\n    this.height = void 0;\n    this.z = void 0;\n    this.zIndex = void 0;\n    this.__info_of__z__ = {\n      type: ShortAttribETypes.EInt,\n      txt: \"alias for zIndex\"\n    };\n    this.__info_of__zIndex__ = {\n      type: ShortAttribETypes.EInt,\n      txt: \"Determine the z-axis priority of the element.<br/>Higher value tende to overlap other elements.<br/>Lower value tends to be on background.\"\n    };\n    this.zoom = void 0;\n    this.html = void 0;\n    this.__info_of__html = {\n      type: 'HTMLElement',\n      txt: 'The DOM element generated by this node.'\n    };\n    this.w = void 0;\n    this.h = void 0;\n    this.size = void 0;\n    this.position = void 0;\n    this.htmlSize = void 0;\n    this.htmlPosition = void 0;\n    this.view = void 0;\n    this.component = void 0;\n    this.favoriteNode = void 0;\n    this.vertex = void 0;\n    this.__info_of__vertex = {\n      type: \"LVoidVertex\",\n      txt: \"the foremost vertex containing this graphElement, or undefiened.\"\n    };\n    this.__info_of__favoriteNode = {\n      type: ShortAttribETypes.EBoolean,\n      txt: \"<span>Indicates this is the primarly used (by default) node to refer to a modelling element that might have multiple representations.\" + \"<br> Can be used as favorite target for edges or other.\"\n    };\n    this.startPoint = void 0;\n    this.endPoint = void 0;\n    this.__info_of__startPoint = {\n      type: \"GraphPoint\",\n      txt: /*#__PURE__*/_jsxDEV(\"span\", {\n        children: [\"Where the outgoing edges should start their paths.\", /*#__PURE__*/_jsxDEV(\"br\", {}, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 171,\n          columnNumber: 13\n        }, this), \"Obtained by combining anchoring point offset specified in view, before snapping to a Vertex border.\", /*#__PURE__*/_jsxDEV(\"br\", {}, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 172,\n          columnNumber: 13\n        }, this), \"Defaults in outer coordinates.\"]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 170,\n        columnNumber: 60\n      }, this)\n    };\n    this.__info_of__endPoint = {\n      type: \"GraphPoint\",\n      txt: /*#__PURE__*/_jsxDEV(\"span\", {\n        children: [\"Where the incoming edges should end their paths.\", /*#__PURE__*/_jsxDEV(\"br\", {}, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 174,\n          columnNumber: 13\n        }, this), \"Obtained by combining anchoring point offset specified in view, before snapping to a Vertex border.\", /*#__PURE__*/_jsxDEV(\"br\", {}, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 175,\n          columnNumber: 13\n        }, this), \"Defaults in outer coordinates.\"]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 173,\n        columnNumber: 58\n      }, this)\n    };\n    this.graph = void 0;\n    this.__info_of__graph = {\n      type: \"LGraph | LGraphVertex\",\n      txt: \"Alias for innerGraph\"\n    };\n    this.innerGraph = void 0;\n    this.__info_of__innnerGraph = {\n      type: \"LGraph | LGraphVertex\",\n      txt: \"Gets the nearest-level graph (it might be a Sub-graph like a package usually is)\"\n    };\n    this.outerGraph = void 0;\n    this.__info_of__outerGraphGraph = {\n      type: \"LGraph\",\n      txt: \"Gets the root-level graph\"\n    };\n    this.root = void 0;\n    this.__info_of__root = {\n      type: \"LGraph\",\n      txt: \"Alias for outerGraph\"\n    };\n    this.rendered = void 0;\n    this.__info_of__rendered = {\n      type: 'boolean',\n      txt: 'If the node is currently displayed somewhere in the graph.'\n    };\n    this.visible = void 0;\n    this.__info_of__visible = {\n      type: 'boolean',\n      txt: 'If the node is currently visible on the user screen.'\n    };\n    this.firstRenderedNode = void 0;\n    this.__info_of__firstRenderedNode = {\n      type: 'LGraphElement',\n      txt: \"The first currently rendered node in the collection: [this.node, this.father.node, this.father.father.node , ...]\"\n    };\n    this.name = void 0;\n    this.__info_of__graphAncestors = {\n      type: \"LGraph[]\",\n      txt: \"<span>collection of the stack of Graphs containing the current element where [0] is the most nested graph, and last is root graph.</span>\"\n    };\n    this.graphAncestors = void 0;\n    this.anchors = void 0;\n    this.__info_of__anchors = {\n      type: \"Dictionary<string, point>\",\n      txt: /*#__PURE__*/_jsxDEV(\"div\", {\n        children: [\"A named list of all anchor points where edges are allowed to land or depart from.\", /*#__PURE__*/_jsxDEV(\"br\", {}, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 217,\n          columnNumber: 158\n        }, this), \"When writing it must be done in percentages, with the same rules as node.state.\"]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 217,\n        columnNumber: 72\n      }, this)\n    };\n    this.edgesIn = void 0;\n    this.edgesOut = void 0;\n    this.__info_of__edgesIn = {\n      type: \"LEdge[]\",\n      txt: /*#__PURE__*/_jsxDEV(\"div\", {\n        children: [\"Edges incoming into this element. \", /*#__PURE__*/_jsxDEV(\"code\", {\n          children: \"this.edgesOut[i].end\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 249,\n          columnNumber: 92\n        }, this), \" always equals to \", /*#__PURE__*/_jsxDEV(\"code\", {\n          children: \"this\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 249,\n          columnNumber: 143\n        }, this), \".\"]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 249,\n        columnNumber: 53\n      }, this)\n    };\n    this.__info_of__edgesOut = {\n      type: \"LEdge[]\",\n      txt: /*#__PURE__*/_jsxDEV(\"div\", {\n        children: [\"Edges outgoing from this element. \", /*#__PURE__*/_jsxDEV(\"code\", {\n          children: \"this.edgesIn[i].start\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 250,\n          columnNumber: 93\n        }, this), \" always equals to \", /*#__PURE__*/_jsxDEV(\"code\", {\n          children: \"this\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 250,\n          columnNumber: 145\n        }, this), \".\"]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 250,\n        columnNumber: 54\n      }, this)\n    };\n    this.__info_of__edgesStart = {\n      type: \"LEdge[]\",\n      txt: /*#__PURE__*/_jsxDEV(\"div\", {\n        children: \"Alias for this.edgesOut\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 251,\n        columnNumber: 56\n      }, this)\n    };\n    this.__info_of__edgesEnd = {\n      type: \"LEdge[]\",\n      txt: /*#__PURE__*/_jsxDEV(\"div\", {\n        children: \"Alias for this.edgesIn\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 252,\n        columnNumber: 54\n      }, this)\n    };\n    this.outerSize = void 0;\n    this.__info_of__outerSize = {\n      type: \"GraphSize\",\n      txt: \"the size of the current element relative to the first (root) graph level.\"\n    };\n    this.innerSize = void 0;\n    this.__info_of__innerSize = {\n      type: \"GraphSize\",\n      txt: \"the size of the current element relative to the last (most nested) graph level.\"\n    };\n    this.__info_of__size = {\n      type: \"GraphSize\",\n      txt: \"same as innerSize.\"\n    };\n    this.nodes = void 0;\n    this.__info_of__nodes = {\n      type: 'LVertex[]',\n      txt: \"all direct sub-nodes. not including deep subelements (subelements of subelements)\"\n    };\n    this.edges = void 0;\n    this.__info_of__edges = {\n      type: 'LEdge[]',\n      txt: \"all direct sub-edges. not including deep subelements (subelements of subelements)\"\n    };\n    this.graphs = void 0;\n    this.__info_of__graphs = {\n      type: 'LGraph[]',\n      txt: \"all direct sub-graphs. not including deep subelements (subelements of subelements)\"\n    };\n    this.allSubNodes = void 0;\n    this.__info_of__allSubNodes = {\n      type: 'LVertex[]',\n      txt: \"all deep sub-nodes. including subelements of subelements.\"\n    };\n    this.allSubEdges = void 0;\n    this.__info_of__allSubEdges = {\n      type: 'LEdge[]',\n      txt: \"all deep sub-edges. including subelements of subelements.\"\n    };\n    this.allSubGraphs = void 0;\n    this.__info_of__allSubGraphs = {\n      type: 'LGraph[]',\n      txt: \"all deep sub-graphs. including subelements of subelements.\"\n    };\n    this.subElements = void 0;\n    this.__info_of__subElements = {\n      type: 'LGraphElement[]',\n      txt: \"all direct subelements (nodes, edges, edgepoints, subgraphs...). not including deep subelements (subelements of subelements)\"\n    };\n    this.allSubElements = void 0;\n    this.__info_of__allSubElements = {\n      type: 'LGraphElement[]',\n      txt: \"all deep subelements (nodes, edges, edgepoints, subgraphs...). including subelements of subelements.\"\n    };\n    this.assignEdgeAnchor = void 0;\n    this.__info_of__assignEdgeAnchor = void 0;\n    this.__info_of__isselected = {\n      type: \"Dictionary<Pointer<User>, true>\",\n      txt: /*#__PURE__*/_jsxDEV(\"div\", {\n        children: [\"A map that contains all the users selecting this element as keys, and always true as a value (if present).\", /*#__PURE__*/_jsxDEV(\"br\", {}, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 736,\n          columnNumber: 13\n        }, this), \"Edit it through node.select() and node.deselect()\"]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 735,\n        columnNumber: 13\n      }, this)\n    };\n    this.__info_of__select = {\n      type: \"function(forUser?:Pointer<User>):void\",\n      txt: \"Marks this node as selected by argument user.\"\n    };\n    this.__info_of__deselect = {\n      type: \"function(forUser?:Pointer<User>):void\",\n      txt: \"Un-marks this node as selected by argument user.\"\n    };\n    this.__info_of__toggleSelect = {\n      type: \"function(usr?:Pointer<User>):void\",\n      txt: \"Calls this.select(usr) if the node is selected by argument user, this.deselect(usr) otherwise. If omitted, argument \\\"usr\\\" is the current user id.<br>Returns the result of this.isSelected() after the toggle.\"\n    };\n    this.__info_of__isSelected = {\n      type: \"function(forUser?:Pointer<User>):void\",\n      txt: \"Tells if this node is selected by argument user.\"\n    };\n  }\n  static getNodeId(o) {\n    var _node;\n    if (!o) return undefined;\n    let node = o;\n    // from L to D\n    // let cname = (node.__raw || node).className;\n    // from DModelE to LGraphE\n    if (RuntimeAccessibleClass.extends(o.className, \"DModelElement\")) node = LPointerTargetable.from(o).node;\n    return typeof node === \"string\" ? node : (_node = node) === null || _node === void 0 ? void 0 : _node.id;\n  }\n  // static singleton: LGraphElement;\n  // static logic: typeof LGraphElement;\n  // static structure: typeof DGraphElement;\n\n  // protected isSelected!: Dictionary<DocString<Pointer<DUser>>, boolean>; //  & ((forUser?: Pointer<DUser>) => boolean);\n\n  // containedIn?: LGraphElement;\n  // LMap;\n\n  // fittizi\n\n  // size and position in global document coordinates.\n\n  get_graph(context) {\n    return this.get_innerGraph(context);\n  }\n  get_root(context) {\n    return this.get_outerGraph(context);\n  }\n  get_rendered(c) {\n    return !!this.get_html(c);\n  }\n  get_visible(c) {\n    return UX.isElementInViewport(this.get_html(c));\n  }\n  get_firstRenderedNode(c) {\n    let arr = [c.proxyObject];\n    return U.findInChildProperties(arr, e => [e.father], undefined, e => e.rendered);\n  }\n  get_name(c) {\n    var _this$get_model;\n    return c.data.model && ((_this$get_model = this.get_model(c)) === null || _this$get_model === void 0 ? void 0 : _this$get_model.name) || c.data.name || c.data.className;\n  }\n  /*firstRenderedNodes!: LGraphElement;\r\n  __info_of__firstRenderedNodes:Info={type: 'LGraphElement', txt: \"The first currently rendered node in the collection: [this.nodes, this.father.nodes, this.father.father.nodes , ...]\"};\r\n  protected get_firstRenderedNodes(c: Context): this[\"firstRenderedNodes\"] {\r\n      let arr = this.get_nodes(c);\r\n      // return U.findInChildProperties(arr, (e)=>e.model.father.nodes, undefined, (e)=>e.rendered);\r\n      return U.findInChildProperties(arr, (e)=>[e.father], undefined, (e)=>e.rendered);\r\n  }*/\n\n  get_anchors(c) {\n    return c.data.anchors;\n  }\n  set_anchors(v, c) {\n    if (v !== undefined && (typeof v !== \"object\" || Array.isArray(v))) {\n      Log.ee('cannot set anchors: invalid value provided');\n      return true;\n    }\n    if (v) {\n      // if !v it means clear all anchors?\n      for (let ka in v) {\n        //for each anchor\n        if (!v[ka]) continue;\n        if (c.data.anchors[ka]) {\n          for (let kk in v[ka]) {\n            //for each key within an anchor (x, y, w, h)\n            // if i was attempting to set a partial size, complete it with the old size values.\n            if (v[ka][kk] === undefined && c.data.anchors[ka][kk] !== undefined) v[ka][kk] = c.data.anchors[ka][kk];\n          }\n        }\n        if (v[ka].x === undefined || isNaN(v[ka].x)) v[ka].x = 0.5;\n        if (v[ka].y === undefined || isNaN(v[ka].y)) v[ka].y = 0.5;\n        // if (v[ka].w === undefined || isNaN(v[ka].w)) v[ka].w = 5;\n        // if (v[ka].h === undefined || isNaN(v[ka].h)) v[ka].h = 5;\n      }\n    }\n    TRANSACTION(this.get_name(c) + '.anchors', () => {\n      SetFieldAction.new(c.data, \"anchors\", v, '', false);\n    });\n    return true;\n  }\n  get_edgesIn(context) {\n    return LPointerTargetable.fromArr(context.data.edgesIn);\n  }\n  get_edgesOut(context) {\n    return LPointerTargetable.fromArr(context.data.edgesOut);\n  }\n  set_edgesIn(val, c) {\n    TRANSACTION(this.get_name(c) + 'edgesIn', () => {\n      SetFieldAction.new(c.data.id, \"edgesIn\", Pointers.fromArr(val), '', true);\n    });\n    return true;\n  }\n  set_edgesOut(val, c) {\n    TRANSACTION(this.get_name(c) + '.edgesOut', () => {\n      SetFieldAction.new(c.data.id, \"edgesOut\", Pointers.fromArr(val), '', true);\n    });\n    return true;\n  }\n  get_edgesStart(context) {\n    return this.get_edgesIn(context);\n  }\n  get_edgesEnd(context) {\n    return this.get_edgesOut(context);\n  }\n  set_edgesStart(val, context) {\n    return this.set_edgesIn(val, context);\n  }\n  set_edgesEnd(val, context) {\n    return this.set_edgesOut(val, context);\n  }\n  _defaultGetter(c, k) {\n    if (k in c.data) return this.__defaultGetter(c, k);\n    // if value not found in node, check in view.\n    return this.get_view(c)[k];\n    /*let ret: any;\r\n    let view = this.get_view(c);\r\n    try { ret = (view as any)[k] } catch (e) { Log.ee(\"Could not find get_ property \\\"\" + k + \"\\\" in node or view.\", {c, view, k}); return undefined; }\r\n    return ret;*/\n  }\n  _defaultSetter(v, c, k) {\n    this.__defaultSetter(v, c, k);\n    return true;\n  }\n  get_graphAncestors(c) {\n    let current = c.proxyObject;\n    let next = current.father;\n    let ret = [];\n    while (next) {\n      if (RuntimeAccessibleClass.extends(next.className, DGraph.cname)) ret.push(next);\n      if (current.id === next.id) break;\n      current = next;\n      next = next.father;\n    }\n    return ret;\n  }\n  get_outerGraph(context) {\n    // todo: this relies on the fact that GraphVertex are not passing their own id to their childrens, but the parent graph id\n    return TargetableProxyHandler.wrap(context.data.graph);\n  }\n  get_vertex(context) {\n    let lcurrent = LPointerTargetable.fromPointer(context.data.id);\n    let dcurrent = lcurrent.__raw;\n    // iterate parents.\n    while (dcurrent) {\n      switch (dcurrent.className) {\n        case DVertex.cname:\n        case DVoidVertex.cname:\n        case DGraphVertex.cname:\n          return lcurrent || LPointerTargetable.fromD(dcurrent);\n        default:\n          if (!dcurrent.father || dcurrent.id === dcurrent.father) return undefined;\n          Log.exDev(!dcurrent.father || dcurrent.id === dcurrent.father, \"node failed to get containing vertex\", context.data, dcurrent, lcurrent);\n          lcurrent = LPointerTargetable.fromPointer(dcurrent.father);\n          dcurrent = lcurrent.__raw;\n      }\n    }\n    return undefined;\n  }\n  get_innerGraph(context) {\n    var _LPointerTargetable$f;\n    let dcurrent = DPointerTargetable.fromPointer(context.data.father);\n\n    // if no parent, but it's a graph, return itself.\n    if (!dcurrent) {\n      dcurrent = context.data;\n      switch (dcurrent.className) {\n        case DGraph.cname:\n        case DGraphVertex.cname:\n          return LPointerTargetable.fromD(dcurrent);\n        default:\n          return Log.exDevv(\"root node failed to get containing graph\", {\n            cdata: context.data,\n            dcurrent\n          });\n      }\n    }\n\n    // if it have a parent, iterate parents.\n    while (true) {\n      var _dcurrent;\n      switch ((_dcurrent = dcurrent) === null || _dcurrent === void 0 ? void 0 : _dcurrent.className) {\n        case DGraph.cname:\n        case DGraphVertex.cname:\n          return LPointerTargetable.fromD(dcurrent);\n        default:\n          Log.exDev(!dcurrent.father, \"node failed to get containing graph\", {\n            cdata: context.data,\n            dcurrent\n          });\n          Log.exDev(dcurrent.id === dcurrent.father, \"node failed to get containing graph, found loop\", {\n            cdata: context.data,\n            dcurrent,\n            father: (_LPointerTargetable$f = LPointerTargetable.from(dcurrent)) === null || _LPointerTargetable$f === void 0 ? void 0 : _LPointerTargetable$f.father\n          });\n          dcurrent = DPointerTargetable.fromPointer(dcurrent.father);\n      }\n    }\n  }\n\n  // set_x(val: this[\"x\"], context: Context): boolean { SetFieldAction.new(context.data.id, \"x\", val, undefined, false); return true; }\n  // get_x(context: Context): this[\"x\"] { return context.data.x; }\n  get_x(context) {\n    return this.get_size(context).x;\n  }\n  set_x(val, context) {\n    return this.set_size({\n      x: val\n    }, context);\n  }\n  get_y(context) {\n    return this.get_size(context).y;\n  }\n  set_y(val, context) {\n    return this.set_size({\n      y: val\n    }, context);\n  }\n  get_w(context) {\n    return this.get_size(context).w;\n  }\n  set_w(val, context) {\n    return this.set_size({\n      w: val\n    }, context);\n  }\n  get_h(context) {\n    return this.get_size(context).h;\n  }\n  set_h(val, context) {\n    return this.set_size({\n      h: val\n    }, context);\n  }\n  get_width(context) {\n    return this.get_w(context);\n  }\n  set_width(val, context) {\n    return this.set_w(val, context);\n  }\n  get_height(context) {\n    return this.get_h(context);\n  }\n  set_height(val, context) {\n    return this.set_h(val, context);\n  }\n  get_position(context) {\n    return new GraphPoint(context.data.x, context.data.y);\n  }\n  set_position(val, c) {\n    TRANSACTION('drag' + this.get_name(c), () => {\n      SetFieldAction.new(c.data.id, \"x\", val.x, undefined, false);\n      SetFieldAction.new(c.data.id, \"y\", val.y, undefined, false);\n    }, IPoint.printDiff(c.data, val));\n    return true;\n  }\n  get_sizeold(context) {\n    return new GraphSize(context.data.x, context.data.y, context.data.w, context.data.h);\n  }\n  get_component(context) {\n    // switch(context.data.className) { case DEdgePoint.name: return GraphElementComponent.map[context.data.father]; }\n    return GraphElementComponent.map[context.data.id];\n  }\n  // get_view(context: Context): this[\"view\"] { return this.get_component(context).props.view; }\n  get_view(context) {\n    var _transientProperties$, _transientProperties$2, _this$get_component, _this$get_component$p;\n    return ((_transientProperties$ = transientProperties.node[context.data.id]) === null || _transientProperties$ === void 0 ? void 0 : (_transientProperties$2 = _transientProperties$.mainView) === null || _transientProperties$2 === void 0 ? void 0 : _transientProperties$2.r) || LPointerTargetable.fromPointer(context.data.view) || ((_this$get_component = this.get_component(context)) === null || _this$get_component === void 0 ? void 0 : (_this$get_component$p = _this$get_component.props.view) === null || _this$get_component$p === void 0 ? void 0 : _this$get_component$p.r);\n  }\n  set_view(val, context) {\n    Log.eDevv(\"node.view is readonly, change it through props or the model\");\n    // let ptr: DGraphElement[\"view\"] = Pointers.from(val as this[\"view\"]);\n    // return SetFieldAction.new(context.data.id, \"view\", ptr, '', true);\n  }\n  getSize() {\n    let outer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    let canTriggerSet = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    return this.wrongAccessMessage(\"getSize()\");\n  }\n  get_getSize(c) {\n    var _this = this;\n    return function () {\n      let outer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n      let canTriggerSet = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      return _this.get_innerSize(c, canTriggerSet, outer);\n    };\n  }\n  get_outerSize(context) {\n    let canTriggerSet = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    return this.get_innerSize(context, canTriggerSet, true);\n  }\n  get_size(context) {\n    let canTriggerSet = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    return this.get_innerSize(context, canTriggerSet, false);\n  }\n  get_innerSize(context) {\n    let canTriggerSet = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    let outerSize = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    let r = this.get_innerSize_impl(context, canTriggerSet, outerSize);\n    return new GraphSize(r.x, r.y, r.w, r.h);\n  }\n  get_innerSize_impl(context) {\n    var _this$get_component2, _this$get_component2$;\n    let canTriggerSet = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    let outerSize = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    canTriggerSet = canTriggerSet && !Debug.lightMode;\n    let cname = context.data.className;\n    // cname = DGraphElement.cname;\n    switch (cname) {\n      default:\n        return Log.exDevv(\"unexpected classname in get_size switch: \" + context.data.className);\n      case DEdge.cname:\n      case DVoidEdge.cname:\n      case DGraph.cname:\n        return nosize;\n      // case DField.cname:\n      case DGraphElement.cname:\n        let graph = outerSize ? this.get_outerGraph(context) : this.get_innerGraph(context);\n        return graph.coord(this.get_htmlSize(context));\n      case DVoidVertex.cname:\n      case DVertex.cname:\n      case DEdgePoint.cname:\n      case DGraphVertex.cname:\n        break;\n    }\n\n    // low prio todo: memoization in proxy, as long state does not change keep a collection Dictionary[object][key] = returnval. it gets emptied when state is updated.\n\n    // when loading a save, edge segements and edgepoints/nodes are computed before creating the edgepoint component\n    let view = this.get_view(context);\n    // (window as any).retry = ()=>view.getSize(context.data.id);\n    let ret = view.getSize(context.data.id); // (this.props.dataid || this.props.nodeid as string)\n\n    if (!ret) {\n      ret = new GraphSize();\n      ret.x = context.data.x;\n      ret.y = context.data.y;\n      ret.w = context.data.w;\n      ret.h = context.data.h;\n      let def;\n      if (undefined === ret.x) {\n        if (!def) def = view.defaultVSize;\n        ret.x = def.x || 0;\n      }\n      if (undefined === ret.y) {\n        if (!def) def = view.defaultVSize;\n        ret.y = def.y || 0;\n      }\n      if (undefined === ret.w) {\n        if (!def) def = view.defaultVSize;\n        ret.w = def.w || 10;\n      }\n      if (undefined === ret.h) {\n        if (!def) def = view.defaultVSize;\n        ret.h = def.h | 10;\n      }\n      ret.currentCoordType = context.data.currentCoordType;\n    }\n    if (context.data.className === DEdgePoint.cname) {\n      ret = this.decodePosCoords(context, ret, view);\n    }\n\n    /*\r\n            if ((context.data as DVoidVertex).isResized) {\r\n                return ret;\r\n            }*/\n    if (!canTriggerSet) {\n      if (outerSize) ret = this.get_outerGraph(context).translateSize(ret, this.get_innerGraph(context));\n      return ret;\n    }\n    let html = (_this$get_component2 = this.get_component(context)) === null || _this$get_component2 === void 0 ? void 0 : (_this$get_component2$ = _this$get_component2.html) === null || _this$get_component2$ === void 0 ? void 0 : _this$get_component2$.current;\n    let actualSize = html ? Size.of(html) : {\n      w: 0,\n      h: 0\n    };\n    let isOldElement = context.data.clonedCounter > 3;\n    // if w = 0 i don't auto-set it as in first render it has w:0 because is not reredered and not resized.\n    // console.log(\"getSize() cantriggerset html size\", {ret: ret ? {...ret} : ret, html, actualSize, hcc:html?.dataset?.clonedcounter, ncc: context.data.clonedCounter});\n    if (!html || +html.dataset.clonedcounter !== context.data.clonedCounter) canTriggerSet = false;\n    let updateSize = false;\n    if (view.adaptWidth && ret.w !== actualSize.w) {\n      if (canTriggerSet && (isOldElement || actualSize.w !== 0)) {\n        ret.w = actualSize.w;\n        updateSize = true;\n      }\n    }\n    if (view.adaptHeight && ret.h !== actualSize.h) {\n      if (canTriggerSet && (isOldElement || actualSize.h !== 0)) {\n        ret.h = actualSize.h;\n        updateSize = true;\n      }\n    }\n    // console.log(\"getSize() from node merged with actualSize\", {ret: {...ret}});\n\n    if (updateSize) this.set_size(ret, context);\n    if (outerSize) ret = this.get_outerGraph(context).translateSize(ret, this.get_innerGraph(context));\n    return ret;\n  }\n  // set_size(size: Partial<this[\"size\"]>, context: Context): boolean {\n  set_size(size0, c) {\n    // console.log(\"setSize(\"+(this.props?.data as any).name+\") thisss\", this);\n    if (!size0) return false;\n    let size = size0;\n    let view = this.get_view(c);\n    let testmode = false;\n    if (c.data.className === DEdgePoint.cname && size.currentCoordType !== CoordinateMode.absolute) size = this.encodePosCoords(c, size, view);\n    if (view.updateSize(c.data.id, size)) return true;\n    TRANSACTION('resize ' + this.get_name(c), () => {\n      if (size.x !== c.data.x && size.x !== undefined) SetFieldAction.new(c.data.id, \"x\", size.x, undefined, false);\n      if (size.y !== c.data.y && size.y !== undefined) SetFieldAction.new(c.data.id, \"y\", size.y, undefined, false);\n      if (size.w !== c.data.w && size.w !== undefined) SetFieldAction.new(c.data.id, \"w\", size.w, undefined, false);\n      if (size.h !== c.data.h && size.h !== undefined) SetFieldAction.new(c.data.id, \"h\", size.h, undefined, false);\n      let epdata = c.data;\n      if (size.currentCoordType !== epdata.currentCoordType && size.currentCoordType !== undefined) SetFieldAction.new(epdata.id, \"currentCoordType\", size.currentCoordType, undefined, false);\n    }, ISize.printDiff(c.data, size));\n    return true;\n  }\n  get_html(c) {\n    let component = this.get_component(c);\n    let html = component === null || component === void 0 ? void 0 : component.html.current;\n    if (html) return html;\n    html = document.getElementById(c.data.id); //$('[nodeid=\"' + c.data.id + '\"]')[0];\n    if (!html) return undefined;\n    if (component) component.html.current = html;\n    return html;\n  }\n  // get_html(context: Context): this[\"html\"] { return $(\"[node-id='\" + context.data.id + \"']\")[0]; }\n  set_html(val, context) {\n    return this.cannotSet(\"set_html(). html is generated through jsx. edit the view instead.\");\n  }\n  get_htmlSize(context) {\n    let html = this.get_html(context);\n    return html ? Size.of(html) : new Size(0, 0, 0, 0);\n    /*\r\n    let graph = this.get_graph(context);\r\n    if (!html) return nosize as any;\r\n    let size = Size.of(html);\r\n    let zoom = graph.zoom;\r\n    size.x /= zoom.x;\r\n    size.y /= zoom.y;\r\n    return size;*/\n  }\n  set_htmlSize(val, context) {\n    // might be useful for fixed display size/location elements that stay in place even if you move tab or change zoom. debatable if needed\n    this.cannotSet(\"set_htmlSize(): todo extra low priority. set GraphSize through set_size instead.\");\n    return true;\n  }\n  get_htmlPosition(context) {\n    return this.get_htmlSize(context).tl();\n  }\n  set_htmlPosition(val, context) {\n    // might be useful for fixed display size/location elements that stay in place even if you move tab or change zoom. debatable if needed\n    this.cannotSet(\"set_htmlPosition(): todo extra low priority. set graph position through set_position instead.\");\n    return true;\n  }\n\n  /* how z-index work, it's really messy.\r\n  * cannot move html position. node id depends on it, and a node moving position would need to change id.\r\n  * so i use css order.\r\n  * first order is assigned through node constructor called by parent component injectProps, according to his last index in html.\r\n  * now z-index is set in node and updated properly.\r\n  * z-index is passed to a prop, rendered as html attribute.\r\n  * css takes the attribute value and uses it in \"order\" css rule.\r\n  * problem: updating node.z doesn't trigger the parent injectprops, so he inject html index and\r\n  * the outernmost html root cannot update his attribute without refreshing the parent and recalling injectprops\r\n  * fixed: by updating it directly in GraphElement.render()\r\n  * */\n  get_zIndex(context) {\n    return +context.data.zIndex || 0;\n  }\n  set_zIndex(val, c) {\n    var _val;\n    val = (_val = +val) !== null && _val !== void 0 ? _val : 0;\n    if (val === c.data.zIndex) return true;\n    TRANSACTION(this.get_name(c) + '.zIndex', () => {\n      SetFieldAction.new(c.data.id, \"zIndex\", val, undefined, false);\n    }, c.data.zIndex, val);\n    return true;\n  }\n  get_z(context) {\n    return context.data.zIndex;\n  }\n  set_z(val, context) {\n    return this.set_zIndex(val, context);\n  }\n  /*\r\n      get_containedIn(context: Context): this[\"containedIn\"] {\r\n          return context.data.containedIn ? LPointerTargetable.fromPointer(context.data.containedIn) : undefined; }\r\n      set_containedIn(val: Pack1<this[\"containedIn\"]>, context: LogicContext<DGraphElement>): boolean {\r\n          let ptr: DGraphElement[\"containedIn\"] = Pointers.from(val) as any;\r\n          SetFieldAction.new(context.data, 'containedIn', ptr, undefined, true);\r\n          if (ptr) SetFieldAction.new(ptr as any, 'subElements+=', context.data.id);\r\n          return true; }*/\n\n  get_nodes(c) {\n    return this.get_subElements(c).filter(c => c && c.className.indexOf('Vertex') >= 0);\n  }\n  set_nodes(val, c) {\n    return this.cannotSet('nodes');\n  }\n  get_edges(c) {\n    return this.get_subElements(c).filter(c => c && c.className.indexOf('Edge') >= 0);\n  }\n  set_edges(val, c) {\n    return this.cannotSet('edges');\n  }\n  get_graphs(c) {\n    return this.get_subElements(c).filter(c => c && c.className.indexOf('Graph') >= 0);\n  }\n  set_graphs(val, c) {\n    return this.cannotSet('graphs');\n  }\n  get_allSubNodes(c) {\n    return this.get_allSubElements(c).filter(c => c && c.className.indexOf('Vertex') >= 0);\n  }\n  set_allSubNodes(val, c) {\n    return this.cannotSet('allSubNodes');\n  }\n  get_allSubEdges(c) {\n    return this.get_allSubElements(c).filter(c => c && c.className.indexOf('Edge') >= 0);\n  }\n  set_allSubEdges(val, c) {\n    return this.cannotSet('allSubEdges');\n  }\n  get_allSubGraphs(c) {\n    return this.get_allSubElements(c).filter(c => c && c.className.indexOf('Graph') >= 0);\n  }\n  set_allSubGraphs(val, c) {\n    return this.cannotSet('allSubGraphs');\n  }\n\n  // shallow, direct subelements\n\n  get_subElements(context) {\n    return LPointerTargetable.fromArr([...new Set(context.data.subElements)]).filter(e => !!e);\n  }\n  set_subElements(val, context) {\n    console.log(\"isDeepStrictEqual\", {\n      isDeepStrictEqual\n    });\n    Log.eDev([...new Set(val)].length !== val.length, \"subelemnts setter have duplicates\", {\n      val,\n      context\n    });\n    // if (isDeepStrictEqual(context.data.subElements, val)) return true;\n    let pointers = Pointers.from(val) || [];\n    if (Uarr.equals(pointers, context.data.subElements, false)) return true;\n    TRANSACTION(this.get_name(context) + '.subElements', () => {\n      SetFieldAction.new(context.data, 'subElements', pointers, '', true);\n      const idlookup = store.getState().idlookup;\n      let arrdiff = U.arrayDifference(context.data.subElements, pointers);\n      // old subelements\n      for (let oldsubelementid of arrdiff.removed) {\n        let subelement = oldsubelementid && idlookup[oldsubelementid];\n        if (subelement.father !== context.data.id) continue;\n        LPointerTargetable.from(subelement).father = null; // todo: can this happen? è transitorio o causa vertici senza parent permanenti?\n      }\n      // new subelements\n      for (let newsubelementid of arrdiff.added) {\n        let subelement = newsubelementid && idlookup[newsubelementid];\n        if (subelement.father === context.data.id) continue;\n        LPointerTargetable.from(subelement).father = context.data.id; // trigger side-action\n      }\n    });\n    return true;\n  }\n\n  // deep, nested subelements\n\n  get_allSubElements(context, state) {\n    // return context.data.packages.map(p => LPointerTargetable.from(p));\n    state = state || store.getState();\n    let tocheck = context.data.subElements || [];\n    let checked = {};\n    let dblcheck = {}; // <child, parent>  // debug only\n    for (let e of tocheck) dblcheck[e] = context.data.id; // debug only\n    checked[context.data.id] = true; //nb6[]{}&\n    while (tocheck.length) {\n      let newtocheck = [];\n      for (let ptr of tocheck) {\n        Log.eDev(checked[ptr], \"loop in GraphElements containing themselves\", {\n          dblcheck,\n          context,\n          ptr,\n          checked,\n          fistContainer: dblcheck[ptr]\n        });\n        if (checked[ptr]) continue;\n        checked[ptr] = true;\n        let subnode = DPointerTargetable.from(ptr, state);\n        let se = subnode === null || subnode === void 0 ? void 0 : subnode.subElements;\n        //for (let e of se) dblcheck[e] = ptr; // debug only\n        U.arrayMergeInPlace(newtocheck, se);\n      }\n      tocheck = newtocheck;\n    }\n    delete checked[context.data.id];\n    return LPointerTargetable.from(Object.keys(checked), state);\n  }\n  set_allSubElements(val, c) {\n    return this.cannotSet('allSubElements');\n  }\n  get_isResized(context) {\n    return context.data.isResized;\n  }\n  set_isResized(val, c) {\n    val = !!val;\n    if (!!c.data.isResized === val) return true;\n    TRANSACTION(this.get_name(c) + '.isResized', () => {\n      SetFieldAction.new(c.data.id, \"isResized\", val);\n    }, c.data.isResized, val);\n    return true;\n  }\n  get_model(context) {\n    const modelElementId = context.data.model; //$('[id=\"' + context.data.id + '\"]')[0].dataset.dataid;\n    const lModelElement = LPointerTargetable.from(modelElementId);\n    return lModelElement;\n  }\n  get_assignEdgeAnchor(c) {\n    return anchorName => {\n      if (anchorName && !c.data.anchors[anchorName]) anchorName = undefined;\n      if (LVoidEdge.startFollow) {\n        let de = DPointerTargetable.fromPointer(LVoidEdge.startFollow);\n        if (de.start !== c.data.id) return; // cannot change edge targets, only an anchor within the current targets\n        let le = LPointerTargetable.fromD(de);\n        le.anchorStart = anchorName;\n        le.startFollow = false;\n      }\n      if (LVoidEdge.endFollow) {\n        let de = DPointerTargetable.fromPointer(LVoidEdge.endFollow);\n        if (de.end !== c.data.id) return; // cannot change edge targets, only an anchor within the current targets\n        let le = LPointerTargetable.fromD(de);\n        le.anchorEnd = anchorName;\n        le.endFollow = false;\n      }\n    };\n  }\n  get_events(c) {\n    const tn = transientProperties.node[c.data.id];\n    let mainview = tn.mainView.__raw;\n    let otherViews = tn.stackViews.map(v => v.__raw);\n    let allviews = [mainview, ...otherViews].reverse();\n    const keep_for_closure_original_funcs = {};\n    const ret = {};\n    for (let dv of allviews) U.objectMergeInPlace(keep_for_closure_original_funcs, transientProperties.view[dv.id].events);\n    const lastContext = tn.viewScores[mainview.id].evalContext;\n    const keys = Object.keys(keep_for_closure_original_funcs);\n    // for (let k of keys) ret['_raw_'+k] = keep_for_closure_original_funcs[k];\n    for (let k of keys) {\n      if (!keep_for_closure_original_funcs[k]) continue;\n      ret[k] = function () {\n        for (var _len = arguments.length, _params = new Array(_len), _key = 0; _key < _len; _key++) {\n          _params[_key] = arguments[_key];\n        }\n        return keep_for_closure_original_funcs[k](lastContext, ..._params);\n      };\n    }\n    return ret;\n  }\n  get_father(context) {\n    return LPointerTargetable.fromPointer(context.data.father);\n  }\n  set_father(val, c) {\n    let ptr = Pointers.from(val);\n    TRANSACTION(this.get_name(c) + '.father', () => {\n      SetFieldAction.new(c.data, 'father', ptr, undefined, true);\n      if (ptr) SetFieldAction.new(ptr, 'subElements+=', c.data.id);\n    }, this.get_father(c).name, L.fromPointer(ptr).name);\n    return true;\n  }\n  select(forUser) {\n    return this.wrongAccessMessage(\"node.select()\");\n  }\n  deselect(forUser) {\n    return this.wrongAccessMessage(\"node.deselect()\");\n  }\n  toggleSelected(forUser) {\n    return this.wrongAccessMessage(\"node.toggleSelected()\");\n  }\n  isSelected(forUser) {\n    return this.wrongAccessMessage(\"node.isSelected()\");\n  }\n  get_select(c) {\n    return forUser => {\n      if (!forUser) forUser = DUser.current;\n      Log.exDev(typeof forUser !== 'string', 'unexpected parameter in select()', {\n        forUser\n      });\n      if (c.data.isSelected[forUser]) return; // no-op\n      let map = {\n        ...c.data.isSelected\n      };\n      map[forUser] = true;\n      let duser = DPointerTargetable.fromPointer(forUser);\n      TRANSACTION(this.get_name(c) + '.select(' + duser.name + ')', () => {\n        SetFieldAction.new(c.data.id, \"isSelected\", map, undefined, false);\n      }, false, true);\n      // todo: actually they are pointer to users, but i'm assuming users are not erased at runtime. on deselect too\n    };\n  }\n  get_deselect(c) {\n    return forUser => {\n      if (!forUser) forUser = DUser.current;\n      Log.exDev(typeof forUser !== 'string', 'unexpected parameter in deselect()', {\n        forUser\n      });\n      if (!c.data.isSelected[forUser]) return; // no-op\n      let map = {\n        ...c.data.isSelected\n      };\n      delete map[forUser];\n      let duser = DPointerTargetable.fromPointer(forUser);\n      TRANSACTION(this.get_name(c) + '.select(' + duser.name + ')', () => {\n        // todo: actually they are pointer to users, but i'm assuming users are not erased at runtime. on deselect too\n        SetFieldAction.new(c.data.id, \"isSelected\", map, undefined, false);\n      });\n    };\n  }\n  get_toggleSelected(context) {\n    return forUser => {\n      if (!forUser) forUser = DUser.current;\n      if (this.get_isSelected(context)(forUser)) {\n        this.get_deselect(context)(forUser);\n        return false;\n      } else {\n        this.get_select(context)(forUser);\n        return true;\n      }\n    };\n  }\n  get_isSelected(context) {\n    return forUser => {\n      if (!forUser) forUser = DUser.current;\n      return !!context.data.isSelected[forUser];\n    };\n  }\n  set_isSelected(val, context) {\n    return this.cannotSet(\"graphElement.isSelected(): use this.select() or this.deselect() instead.\");\n  }\n  /*\r\n  get_isSelected(context: LogicContext<DVoidVertex>): GObject {\r\n      return DPointerTargetable.mapWrap(context.data.isSelected, context.data, 'idlookup.' + context.data.id + '.isSelected', []);\r\n  }*/\n\n  // for edges\n  get_startPoint(c, size, view) {\n    return this.get_startEndPoint(c, size, view, true);\n  }\n  get_endPoint(c, size, view) {\n    return this.get_startEndPoint(c, size, view, false);\n  }\n  get_startEndPoint(c, size, view) {\n    let isStart = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n    if (!size) {\n      if (c) size = this.get_size(c);else size = Log.exDevv(\"invalid arguments in get_startEndPoint\", {\n        arguments\n      });\n    }\n    if (!view) {\n      // if (c) view = this.get_view(c); else view = Log.exDevv(\"invalid arguments in get_startPoint\", {arguments});\n      view = c && this.get_view(c) || Log.exDevv(\"invalid arguments in get_startEndPoint\", {\n        arguments\n      });\n    }\n    let offset = view[isStart ? \"edgeStartOffset\" : \"edgeEndOffset\"];\n    let isPercentage = view[isStart ? \"edgeStartOffset_isPercentage\" : \"edgeEndOffset_isPercentage\"];\n    if (!size) size = new GraphSize(0, 0, 0, 0);\n    if (isPercentage) offset = new GraphPoint(offset.x / 100 * size.w, offset.y / 100 * size.h);\n    return size.tl().add(offset, false);\n  }\n}, _class4.subclasses = [], _class4._extends = [], _class4)) || _class3);\nRuntimeAccessibleClass.set_extend(DPointerTargetable, DGraphElement);\nRuntimeAccessibleClass.set_extend(LPointerTargetable, LGraphElement);\nexport let DGraph = (_dec3 = RuntimeAccessible('DGraph'), _dec3(_class5 = (_class6 = class DGraph extends DGraphElement {\n  constructor() {\n    super(...arguments);\n    this.father = void 0;\n    this.id = void 0;\n    this.graph = void 0;\n    this.model = void 0;\n    this.isSelected = void 0;\n    this.state = void 0;\n    this.zoom = void 0;\n    this.offset = void 0;\n  } // static _super = DGraphElement;\n  // static singleton: LGraph;\n  // static logic: typeof LGraph;\n  // static structure: typeof DGraph;\n  // inherit redefine\n  // containedIn!: Pointer<DGraphElement, 0, 1, LGraphElement>;\n  // personal attributes\n  // in-graph scrolling offset\n\n  static new(htmlindex, model, parentNodeID,\n  // immediate parent\n  parentgraphID,\n  // graph containing this subgraph (redudant? could get it from father chain)\n  nodeID) {\n    return new Constructors(new DGraph('dwc'), parentNodeID, true, undefined, nodeID || Constructors.DGraph_makeID(model)).DPointerTargetable().DGraphElement(model, parentgraphID, htmlindex).DGraph().end();\n  }\n  static getNodes(dmp, out) {\n    let $allnodes = $('[data-dataid]');\n    let matchedids = (dmp || []).map(d => d.id);\n    let matchedidmap = U.objectFromArrayValues(matchedids);\n    if (!out) out = {};\n    let allnodesarr = [...$allnodes];\n    let filternode = d => {\n      var _d$dataset, _d$dataset2;\n      if (!(d === null || d === void 0 ? void 0 : (_d$dataset = d.dataset) === null || _d$dataset === void 0 ? void 0 : _d$dataset.dataid)) return false;\n      let id = '' + (d === null || d === void 0 ? void 0 : (_d$dataset2 = d.dataset) === null || _d$dataset2 === void 0 ? void 0 : _d$dataset2.dataid);\n      return matchedidmap[id];\n    };\n    out.$matched = $(allnodesarr.filter(filternode));\n    out.$notMatched = $(allnodesarr.filter(n => !filternode(n)));\n    return out.$matched;\n    // throw new Error(\"Method not implemented.\");\n  }\n}, _class6.subclasses = [], _class6._extends = [], _class6)) || _class5);\nvar nosize = {\n  x: 0,\n  y: 0,\n  w: 0,\n  h: 0,\n  nosize: true\n};\nvar defaultEdgePointSize = undefined; // = {x:0, y:0, w:5, h:5};\nvar defaultVertexSize = undefined; // {x:0, y:0, w:140.6818084716797, h:32.52840805053711};\n\nexport let LGraph = (_dec4 = RuntimeAccessible('LGraph'), _dec4(_class7 = (_class8 = class LGraph extends LGraphElement {\n  constructor() {\n    super(...arguments);\n    this.__raw = void 0;\n    this.id = void 0;\n    this.graph = void 0;\n    this.model = void 0;\n    this.subElements = void 0;\n    this._state = void 0;\n    this.zoom = void 0;\n    this.graphSize = void 0;\n    this.offset = void 0;\n    this.cumulativeZoom = void 0;\n    this.__info_of__cumulativeZoom = {\n      type: GraphPoint.cname,\n      txt: \"the product of all the ownZoom of containing ancestor graphs.\"\n    };\n    this.ownZoom = void 0;\n    this.__info_of__ownZoom = {\n      type: GraphPoint.cname,\n      label: \"zoom\",\n      txt: \"The individual zoom applied to this graph.\"\n    };\n    this.__info_of__zoom = {\n      type: GraphPoint.cname,\n      label: \"zoom\",\n      txt: \"Scales the graph and all subelements by a factor.\"\n    };\n    this.__info_of__offset = {\n      type: GraphPoint.cname,\n      label: \"offset\",\n      txt: \"In-graph scrolling position.\"\n    };\n    this.__info_of__graphSize = {\n      type: GraphSize.cname,\n      label: \"graphSize\",\n      txt: \"size internal to the graph, including internal scroll and panning.\"\n    };\n    this.__info_of__translateSize = {\n      type: \"(T, Graph)=>T where T is GraphSize | GraphPoint\",\n      txt: \"Translates a coordinate set from the local coordinates of a SubGraph to this Graph containing it.\"\n    };\n    this.__info_of__translateHtmlSize = {\n      type: \"(Size|Point) => GraphSize|GraphPoint\",\n      txt: 'Translate page\\'s viewport coordinate set to this graph coordinate set.'\n    };\n    this.screenOffset = void 0;\n    this.__info_of__screenOffset = {\n      type: GraphPoint.cname,\n      txt: \"Distance of the subgraph origin in rendered pixels. to the top-left of graph container.\"\n    };\n  } // static singleton: LGraph;\n  // static logic: typeof LGraph;\n  // static structure: typeof DGraph;\n  // inherit redefine\n  // isSelected: Dictionary<DocString<Pointer<DUser>>, boolean> = {};\n  isSelected(forUser) {\n    return this.wrongAccessMessage(\"node.isSelected()\");\n  }\n  // containedIn?: LGraphElement;\n\n  // LMap;\n  // personal attributes\n\n  // derived attribute: bounding rect containing all subnodes, while \"size\" is instead external size of the vertex holding the graph in GraphVertexes\n\n  // Scrolling position inside the graph\n\n  // get_graphSize(context: LogicContext<DGraph>):  Readonly<GraphSize> { return todo: get bounding rect containing all subnodes.; }\n  get_offset(context) {\n    let offset = context.data.offset || new GraphSize();\n    return new GraphSize(offset.x, offset.y, offset.w, offset.h);\n  }\n  set_offset(val, context) {\n    if (!val) val = {\n      x: 0,\n      y: 0,\n      w: 0,\n      h: 0\n    };\n    //if (val.x === undefined && val.y === undefined && val.w === undefined && val.h === undefined) return true;\n    let offset = context.data.offset || new GraphSize();\n    if (val.x === undefined && offset.x !== val.x) val.x = offset.x;\n    if (val.y === undefined && offset.y !== val.y) val.y = offset.y;\n    if (val.w === undefined && offset.w !== val.w) val.w = offset.w;\n    if (val.h === undefined && offset.h !== val.h) val.h = offset.h;\n    if (offset.x === val.x && offset.y === val.y && offset.w === val.w && offset.h == val.h) return true;\n    TRANSACTION(this.get_name(context) + '.offset', () => {\n      SetFieldAction.new(context.data, \"offset\", val);\n    }, IPoint.stringify(offset), IPoint.stringify(val));\n    return true;\n  }\n  get_cumulativeZoom(c) {\n    let ancestors = [c.proxyObject, ...this.get_graphAncestors(c)];\n    let zoom = new GraphPoint(1, 1);\n    for (let g of ancestors) zoom.multiply(g.ownZoom, false);\n    return zoom;\n  }\n  get_zoom(c) {\n    return this.get_cumulativeZoom(c);\n  }\n  get_ownZoom(context) {\n    const zoom = context.data.zoom;\n    let ret = new GraphPoint(zoom.x || 1, zoom.y || 1); // NB: do not use (??1), zero is not a valid value for zoom.\n    // (zoom as any).debug = {rawgraph: context.data.__raw, zoomx: context.data.zoom.x, zoomy: context.data.zoom.y}\n    return ret;\n  }\n  set_zoom(val, c) {\n    if (!val) val = {\n      x: 1,\n      y: 1\n    };\n    //if (val.x === undefined && val.y === undefined) return true;\n    let zoom = c.data.zoom || new GraphSize();\n    if (!val.x) val.x = zoom.x; // remember zero is not allowed value\n    if (!val.y) val.y = zoom.y;\n    if (zoom.x === val.x && zoom.y === val.y) return true;\n    TRANSACTION(this.get_name(c) + '.zoom', () => {\n      SetFieldAction.new(c.data, 'zoom', val, '+=', false);\n    }, IPoint.stringify(zoom), IPoint.stringify(val));\n    return true;\n  }\n  toGraphSize() {\n    return this.wrongAccessMessage(\"toGraphSize\");\n  }\n  coord(htmlSize) {\n    return this.wrongAccessMessage(\"toGraphSize\");\n  }\n  get_coord(context) {\n    return htmlSize => {\n      let graphHtmlSize = this.get_htmlSize(context);\n      let zoom = this.get_zoom(context);\n      return new GraphSize((htmlSize.x - graphHtmlSize.x) / zoom.x, (htmlSize.y - graphHtmlSize.y) / zoom.y, htmlSize.w / zoom.x, htmlSize.h / zoom.y);\n    };\n  }\n  // get_htmlSize(context: Context): Size { }\n  translateSize(ret, innerGraph) {\n    return this.wrongAccessMessage(\"translateSize()\");\n  }\n  translateHtmlSize(size) {\n    return this.wrongAccessMessage(\"translateHtmlSize()\");\n  }\n  get_translateHtmlSize(c) {\n    return size => {\n      let rootGraph = this.get_root(c);\n      if (rootGraph.id === c.data.id) return this.get_translateHtmlSize_fromRoot(c)(size);\n      let fakeRootSize = rootGraph.translateHtmlSize_fromRoot(size);\n      let screenOffset = this.get_screenOffset(c); //cumulative (g.size.tl()-offset.tl()*cumulativezoom)\n\n      // distance from the origin of the subgraph in rendered pixels\n      let ret = new GraphSize(fakeRootSize.x - screenOffset.x, fakeRootSize.y - screenOffset.y, fakeRootSize.w, fakeRootSize.h);\n      return ret.divide(this.get_cumulativeZoom(c), false);\n\n      /*\r\n      // fake because it assumes all subgraphs have the same zoom level of current graph.\r\n      let ancestors = this.get_graphAncestors(c).reverse().slice(1);\r\n      let cumulativeZoom: GraphPoint = new GraphPoint(1, 1); // = this.get_ownZoom(c);\r\n      for (let g of ancestors){\r\n          let offset = g.offset;\r\n          let ownZoom = g.ownZoom;\r\n          cumulativeZoom.multiply(ownZoom);\r\n          // let a, b, c be graphs\r\n          // size is =  a.zoom + a.offset\r\n        }\r\n      */\n    };\n  }\n  get_screenOffset(c) {\n    let ancestors = [c.proxyObject, ...this.get_graphAncestors(c)].reverse();\n    let ret = new GraphPoint(0, 0);\n    let cumulativeZoom = new GraphPoint(1, 1); // = this.get_ownZoom(c);\n    for (let g of ancestors) {\n      let offset = g.offset;\n      let ownZoom = g.ownZoom;\n      let size = g.size;\n      ret.add(size.tl().multiply(cumulativeZoom, false), false).subtract(offset, false);\n      cumulativeZoom.multiply(ownZoom);\n      ret.multiply(cumulativeZoom, false);\n    }\n    return ret;\n  }\n  translateHtmlSize_fromRoot(size) {\n    return this.wrongAccessMessage('translateHtmlSize_fromRoot');\n  }\n\n  /**\r\n   *  IMPORTANT!\r\n   *  this is a wrong partial result, do not call this function directly outside translateHtmlSize.\r\n   *  this is outercoord without zoom, needs ti be translated to container graph coords & de-apply zoom\r\n   */\n  get_translateHtmlSize_fromRoot(c) {\n    return size => {\n      let graphHtmlSize = this.get_htmlSize(c);\n      let a = size.subtract(graphHtmlSize.tl(), true);\n      let offset = {\n        x: c.data.offset.x,\n        y: c.data.offset.y\n      };\n      let b = a.subtract(offset, true);\n      let r = b.divide(c.data.zoom, false);\n      return r;\n    };\n  }\n\n  // graph_of_size, the size parameter have coordinates based on this graph.\n  get_translateSize(c) {\n    return (size, graph_of_size) => {\n      let targetGraph = c.proxyObject;\n      let currGraph = graph_of_size;\n      if (currGraph.id === c.data.id) return size;\n      let currAncestors = [currGraph, ...currGraph.graphAncestors];\n      let targetAncestors = [targetGraph, ...targetGraph.graphAncestors];\n      let currAncestorsPtr = currAncestors.map(l => l.id).reverse();\n      let targetAncestorsPtr = targetAncestors.map(l => l.id).reverse();\n      Log.ex(targetAncestorsPtr[0] !== currAncestorsPtr[0], 'translateSize() The root graph of 2 elements should always be the same, are you comparing nodes from different graphs?', {\n        currGraph,\n        targetGraph\n      });\n      let i = 1;\n      while (currAncestorsPtr[i] === targetAncestorsPtr[i]) {\n        i++;\n      }\n      let commonAncestor = targetAncestorsPtr[i - 1];\n      currAncestors = currAncestors.slice(0, currAncestors.length - i).filter(e => !!e);\n      targetAncestors = targetAncestors.slice(0, currAncestors.length - i).filter(e => !!e);\n      // d, c, b, a           currAncestors\n      // d, c, x, y           targetAncestors\n      // undo a,b, redo x,y        i = [2]\n\n      Log.exDev(!currAncestors.length && !targetAncestors.length, \"translateSize() found invalid intersection in container graphs\", {\n        currGraph,\n        targetGraph,\n        currAncestors,\n        targetAncestors\n      });\n      // @ts-ignore\n      let ret = 'w' in size ? new GraphSize(size.x, size.y, size.w, size.h) : new GraphPoint(size.x, size.y, size.w, size.h);\n      console.log(\"translateSizee pre\", this.get_model(c).name, size.x, size.y, {\n        size,\n        ret,\n        currAncestors,\n        targetAncestors\n      });\n      for (let g of currAncestors) {\n        ret.subtract(g.offset, false);\n        ret.divide(g.cumulativeZoom, false);\n        ret.add(g.size.tl(), false);\n      }\n      for (let g of targetAncestors) {\n        ret.subtract(g.size.tl(), false);\n        ret.multiply(g.cumulativeZoom, false);\n        ret.add(g.offset, false);\n      }\n      console.log(\"translateSizee ret\", this.get_model(c).name, size.x, size.y, {\n        size,\n        ret,\n        currAncestors,\n        targetAncestors\n      });\n      return ret;\n    };\n    //todo: check how many passes you need to go down or up, and make the up version too\n  }\n  get_translateSize_down_old(c) {\n    return (size, graph_of_size) => {\n      graph_of_size = LPointerTargetable.wrap(graph_of_size);\n      let ret = size.hasOwnProperty(\"w\") ? new GraphSize(size.x, size.y, size.w, size.h) : new GraphPoint(size.x, size.y);\n      Log.ex(!graph_of_size, \"translateSize() graph parameter is invalid: \" + graph_of_size, graph_of_size, c);\n      let ancestors = [graph_of_size, ...graph_of_size.graphAncestors];\n      console.log(\"translateSize\", {\n        innerGraph: graph_of_size,\n        ret,\n        ancestors,\n        c\n      });\n      Log.ex(ancestors.indexOf(c.proxyObject) !== -1, \"translateSize() graph parameter is invalid: it must be a graph containing the current one.\", graph_of_size, c);\n      for (let g of ancestors) ret.add(g.size.tl(), false);\n      // for (let g of ancestors) ret.subtract(g.offset, false);\n      // console.log(\"translateSize\", {c, thiss:c.proxyObject, ancestors, ancestorSizes: ancestors.map(a=> a.size.tl()), size, ret});\n      return ret;\n    };\n  }\n  contains(elem) {\n    return this.wrongAccessMessage(\"contains()\");\n  }\n  get_contains(c) {\n    return elem => {\n      let current = elem;\n      let next = elem.father;\n      let targetid = c.proxyObject.id;\n      if (current.id !== targetid) return true;\n      while (next && current.id !== next.id) {\n        current = next;\n        next = next.father;\n        if (current.id !== targetid) return true;\n      }\n      return false;\n    };\n  }\n}, _class8.subclasses = [], _class8._extends = [], _class8)) || _class7);\nRuntimeAccessibleClass.set_extend(DGraphElement, DGraph);\nRuntimeAccessibleClass.set_extend(LGraphElement, LGraph);\n// export const defaultVSize: GraphSize = new GraphSize(0, 0, 300, 160); // useless, now it's in view.DefaultVSize\n// export const defaultEPSize: GraphSize = new GraphSize(0, 0, 15, 15); // useless, now it's in view.DefaultVSize\n\nexport let DVoidVertex = (_dec5 = RuntimeAccessible('DVoidVertex'), _dec5(_class9 = (_class10 = class DVoidVertex extends DGraphElement {\n  constructor() {\n    super(...arguments);\n    this.id = void 0;\n    this.graph = void 0;\n    this.model = void 0;\n    this.isSelected = void 0;\n    this.subElements = void 0;\n    this.state = void 0;\n    this.zoom = void 0;\n    this.x = void 0;\n    this.y = void 0;\n    this.w = void 0;\n    this.h = void 0;\n    this.isResized = void 0;\n  } // static _super = DGraphElement;\n  // static singleton: LVoidVertex;\n  // static logic: typeof LVoidVertex;\n  // static structure: typeof DVoidVertex;\n  // inherit redefine\n  // containedIn!: Pointer<DGraphElement, 0, 1, LGraphElement>;\n  // personal attributes\n  // size?: GraphSize; // virtual, gets extracted from this. x and y are stored directly here as it extends GraphSize\n\n  static new(htmlindex, model, parentNodeID, graphID, nodeID, size) {\n    return new Constructors(new DVoidVertex('dwc'), parentNodeID, true, undefined, nodeID).DPointerTargetable().DGraphElement(model, graphID, htmlindex).DVoidVertex(size || defaultVertexSize).end();\n  }\n}, _class10.subclasses = [], _class10._extends = [], _class10)) || _class9);\nexport let LVoidVertex = (_dec6 = RuntimeAccessible('LVoidVertex'), _dec6(_class11 = (_class12 = class LVoidVertex extends LGraphElement {\n  constructor() {\n    super(...arguments);\n    this.__raw = void 0;\n    this.id = void 0;\n    this.graph = void 0;\n    this.model = void 0;\n    this.subElements = void 0;\n    this._state = void 0;\n    this.zoom = void 0;\n    this.isResized = void 0;\n    this.x = void 0;\n    this.y = void 0;\n    this.w = void 0;\n    this.h = void 0;\n    this.size = void 0;\n    this.__info_of__size = {\n      type: \"?GraphSize\",\n      txt: \"Size of the vertex, if null it means is utilizing the defaultSize from view. recommended to read component.getSize() instead of this.\"\n    };\n  } // <D extends DVoidVertex = any>\n  // static singleton: LVoidVertex;\n  // static logic: typeof LVoidVertex;\n  // static structure: typeof DVoidVertex;\n  // inherit redefine\n  // isSelected: Dictionary<DocString<Pointer<DUser>>, boolean> = {};\n  isSelected(forUser) {\n    return this.wrongAccessMessage(\"node.isSelected()\");\n  }\n  // containedIn?: LGraphElement;\n\n  // LMap;\n\n  // personal attributes\n\n  // virtual, gets extracted from this. x and y are stored directly here as it extends GraphSize\n\n  get_isResized(context) {\n    return context.data.isResized;\n  }\n  set_isResized(val, context) {\n    val = !!val;\n    if (!!context.data.isResized === val) return true;\n    TRANSACTION(this.get_name(context) + '.isResized', () => {\n      SetFieldAction.new(context.data.id, \"isResized\", val);\n    }, context.data.isResized, val);\n    return true;\n  }\n}, _class12.subclasses = [], _class12._extends = [], _class12)) || _class11);\nRuntimeAccessibleClass.set_extend(DGraphElement, DVoidVertex);\nRuntimeAccessibleClass.set_extend(LGraphElement, LVoidVertex);\nexport let DEdgePoint = (_dec7 = RuntimeAccessible('DEdgePoint'), _dec7(_class13 = (_class14 = class DEdgePoint extends DVoidVertex {\n  constructor() {\n    super(...arguments);\n    this.id = void 0;\n    this.father = void 0;\n    this.graph = void 0;\n    this.model = void 0;\n    this.isSelected = void 0;\n    this.subElements = void 0;\n    this.zoom = void 0;\n    this.x = void 0;\n    this.y = void 0;\n    this.w = void 0;\n    this.h = void 0;\n    this.size = void 0;\n    this.__isDEdgePoint = void 0;\n    this.currentCoordType = void 0;\n  } // DVoidVertex\n  // static singleton: LEdgePoint;\n  // static logic: typeof LEdgePoint;\n  // static structure: typeof DEdgePoint;\n  // inherit redefine\n  // todo: if null gets model from this.father (edge)?\n  // containedIn!: Pointer<DGraphElement, 0, 1, LGraphElement>;\n  //／／ virtual, gets extracted from this. x and y are stored directly here as it extends GraphSize\n  // personal attributes\n  static new(htmlindex, model, parentNodeID, graphID, nodeID, size) {\n    return new Constructors(new DEdgePoint('dwc'), parentNodeID, true, undefined, nodeID).DGraphElement(undefined, graphID, htmlindex).DVoidVertex(size || defaultEdgePointSize).DEdgePoint().end();\n  }\n}, _class14.subclasses = [], _class14._extends = [], _class14)) || _class13);\nexport let LEdgePoint = (_dec8 = RuntimeAccessible('LEdgePoint'), _dec8(_class15 = (_class16 = class LEdgePoint extends LVoidVertex {\n  constructor() {\n    super(...arguments);\n    this.father = void 0;\n    this.id = void 0;\n    this.graph = void 0;\n    this.model = void 0;\n    this.subElements = void 0;\n    this.zoom = void 0;\n    this.x = void 0;\n    this.y = void 0;\n    this.w = void 0;\n    this.h = void 0;\n    this.size = void 0;\n    this.__isLEdgePoint = void 0;\n    this.edge = void 0;\n    this.__info_of__edge = {\n      type: \"?LEdge\",\n      txt: \"returns the containing edge if called on an EdgePoint, \\\"this\\\" if called on an edge, undefined otherwise.\"\n    };\n  } // static singleton: LEdgePoint;\n  // static logic: typeof LEdgePoint;\n  // static structure: typeof DEdgePoint;\n  // inherit redefine\n  // __raw!: DEdgePoint;\n  // isSelected: Dictionary<DocString<Pointer<DUser>>, boolean> = {};\n  isSelected(forUser) {\n    return this.wrongAccessMessage(\"node.isSelected()\");\n  }\n  // containedIn?: LGraphElement;\n\n  // virtual, gets extracted from this. x and y are stored directly here as it extends GraphSize\n  // personal attributes\n\n  // returns container edge\n\n  get_edge(c) {\n    return c.proxyObject.father;\n  }\n  set_edge(v, c) {\n    return this.set_father(v, c);\n  }\n  static decodeCoords(size0, sp, ep) /*absolute*/{\n    let size = size0;\n    let ret = \"w\" in size || \"h\" in size ? new GraphSize() : new GraphPoint(); // GObject<Partial<GraphSize>>;\n    switch (size.currentCoordType) {\n      default:\n        return Log.exDevv(\"translatePosCoords() invalid coordinate mode\", {\n          mode: size.currentCoordType\n        });\n      // case CoordinateMode.absolute: return size;\n      case CoordinateMode.absolute:\n      case undefined:\n      case null:\n        if (size.x !== undefined) ret.x = size.x;\n        if (size.y !== undefined) ret.y = size.y;\n        break;\n      case CoordinateMode.relativePercent:\n        //maybe do: dampening factor on relative % offset? is it possible?\n        // let s = this.getBasicSize(c);\n        // MATH:\n        // size.x = sp.x*x% + ep.x*(1-x%)\n        // size.x = sp.x*x% + ep.x - ep.x*x%\n        // size.x - ep.x= (sp.x - ep.x)*x%\n        // (size.x - ep.x) / (sp.x - ep.x) = x% // actually i inverted <sp, ep> in first equation, so reverse them in result too.\n        if (size.x !== undefined) ret.x = (1 - size.x) * sp.x + size.x * ep.x;\n        if (size.y !== undefined) ret.y = (1 - size.y) * sp.y + size.y * ep.y;\n        break;\n      case CoordinateMode.relativeOffset:\n      case CoordinateMode.relativeOffsetStart:\n      case CoordinateMode.relativeOffsetEnd:\n        let useStart;\n        let useEnd;\n        switch (size.currentCoordType) {\n          default:\n          case CoordinateMode.relativeOffset:\n            useStart = true;\n            useEnd = true;\n            break;\n          case CoordinateMode.relativeOffsetStart:\n            useStart = true;\n            useEnd = false;\n            break;\n          case CoordinateMode.relativeOffsetEnd:\n            useStart = false;\n            useEnd = true;\n            break;\n        }\n        // offset = sp - size\n        // size = offset - sp\n        // in reverse: actualsize = offset, size=offset\n\n        // if coords are already in absolute mode.\n        let xIsAbsolute = size.x && !Array.isArray(size.x) ? size.x : undefined;\n        let yIsAbsolute = size.x && !Array.isArray(size.x) ? size.x : undefined;\n        Log.w(!!(xIsAbsolute || yIsAbsolute), \"decoding relative offset require an array size coordinate system. x=[x1, x2] --> x\", {\n          size\n        });\n        let offsetsp = useStart ? new GraphPoint(xIsAbsolute || size.x[0] + sp.x, yIsAbsolute || size.y[0] + sp.y) : new GraphPoint();\n        let offsetep = useEnd ? new GraphPoint(xIsAbsolute || size.x[1] + ep.x, yIsAbsolute || size.y[1] + ep.y) : new GraphPoint();\n        // if the start and endpoint of the edge didn't move, offsetsp = offsetep.\n        // if they moved, those 2 are discordant --> i pick middle\n        offsetsp.add(offsetep, false);\n        if (useStart && useEnd) offsetsp.divide(2, false);\n        if (!xIsAbsolute && size.x !== undefined) ret.x = offsetsp.x;\n        if (!yIsAbsolute && size.y !== undefined) ret.y = offsetsp.y;\n        if (xIsAbsolute) {\n          ret.x = size.x;\n        }\n        if (yIsAbsolute) {\n          ret.y = size.y;\n        }\n        break;\n    }\n    if (size.x === undefined) delete ret.x;\n    if (size.y === undefined) delete ret.y;\n    if (size.w === undefined) delete ret.w;else ret.w = size.w;\n    if (size.h === undefined) delete ret.h;else ret.h = size.h;\n    ret.currentCoordType = CoordinateMode.absolute;\n    // console.log(\"decode coords\", {size, sp, ep, ret});\n    return ret;\n  }\n  // from x,y as coords, to x%,y% as % of ((1-val)%*startpt) + ((val)%*endpt)\n  decodePosCoords(c, size, view, sp0, ep0) {\n    let le = c && c.proxyObject.father;\n    // console.log(\"decodepos:\", {le, sp0, lesp:le?.startPoint});\n    let sp = sp0 || le.startPoint;\n    let ep = ep0 || le.endPoint;\n    return LEdgePoint.decodeCoords(size, sp, ep);\n  }\n  static testCoords() {\n    let range = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 30;\n    outer: for (let mode of [\"absolute\", \"relative%\", \"relativeOffset\", \"relativeOffsetStart\", \"relativeOffsetEnd\"]) for (let i = -range; i < range; i++) for (let j = -range; j < range; j++) {\n      var s0 = {\n        x: i,\n        y: j\n      };\n      var sp = {\n        x: 10,\n        y: 10\n      };\n      var ep = {\n        x: 10,\n        y: -10\n      };\n      // @ts-ignore\n      var s1 = LEdgePoint.encodeCoords(s0, mode, sp, ep);\n      // @ts-ignore\n      var s00 = LEdgePoint.decodeCoords(s1, sp, ep);\n      // @ts-ignore\n      var error = Object.keys(s0).map(k => s0[k].toFixed(3) === s00[k].toFixed(3) ? '' : k).join('');\n      (mode != \"relative%\" && error ? console.error : console.log)({\n        diff: [s00.x - s0.x, s00.y - s0.y].join(),\n        i,\n        j,\n        mode,\n        s1: [s1.x, s1.y].join(),\n        s0,\n        s00,\n        error\n      });\n      if (mode != \"relative%\" && error) break outer;\n    }\n  }\n  // @ts-ignore a\n\n  static encodeCoords(size0, edgePointCoordMode, sp, ep) /*absolute*/{\n    let size = size0;\n    if (edgePointCoordMode === size.currentCoordType || !size.currentCoordType && edgePointCoordMode === CoordinateMode.absolute) return size;\n    if (size.currentCoordType && size.currentCoordType !== CoordinateMode.absolute) size = LEdgePoint.decodeCoords(size, sp, ep);\n    let ret = \"w\" in size || \"h\" in size ? new GraphSize() : new GraphPoint(); // GObject<Partial<GraphSize>>;\n    switch (edgePointCoordMode) {\n      default:\n        return Log.exDevv(\"translatePosCoords() invalid coordinate mode\", {\n          mode: edgePointCoordMode\n        });\n      // case CoordinateMode.absolute: return size;\n      case CoordinateMode.relativePercent:\n        // let s = this.getBasicSize(c);\n        // MATH:\n        // size.x = sp.x*x% + ep.x*(1-x%)\n        // size.x = sp.x*x% + ep.x - ep.x*x%\n        // size.x - ep.x= (sp.x - ep.x)*x%\n        // (size.x - ep.x) / (sp.x - ep.x) = x% // actually i inverted <sp, ep> in first equation, so reverse them in result too.\n\n        if (sp.x === ep.x) ret.x = 0.5; // because otherwise it is infinity. so i force him to return in line.\n        else if (size.x !== undefined) ret.x = (size.x - sp.x) / (ep.x - sp.x);\n        if (sp.y === ep.y) ret.y = 0.5;else if (size.y !== undefined) ret.y = (size.y - sp.y) / (ep.y - sp.y);\n        break;\n      case CoordinateMode.relativeOffset:\n      case CoordinateMode.relativeOffsetStart:\n      case CoordinateMode.relativeOffsetEnd:\n        let useStart;\n        let useEnd;\n        switch (edgePointCoordMode) {\n          default:\n          case CoordinateMode.relativeOffset:\n            useStart = true;\n            useEnd = true;\n            break;\n          case CoordinateMode.relativeOffsetStart:\n            useStart = true;\n            useEnd = false;\n            break;\n          case CoordinateMode.relativeOffsetEnd:\n            useStart = false;\n            useEnd = true;\n            break;\n        }\n        if (size.x) ret.x = [useStart ? size.x - sp.x : -1, useEnd ? size.x - ep.x : -1];\n        if (size.y) ret.y = [useStart ? size.y - sp.y : -1, useEnd ? size.y - ep.y : -1];\n        /*\r\n        if (size.x) ret.x = [sp.x - size.x, ep.x - size.x];\r\n        if (size.y) ret.y = [sp.y - size.y, ep.y - size.y];*/\n        break;\n    }\n    if (size.x === undefined) delete ret.x;\n    if (size.y === undefined) delete ret.y;\n    if (size.w === undefined) delete ret.w;else ret.w = size.w;\n    if (size.h === undefined) delete ret.h;else ret.h = size.h;\n    // console.log(\"encode coorde\", {size, sp, ep, ret});\n    ret.currentCoordType = edgePointCoordMode;\n    return ret;\n  }\n  encodePosCoords(c, size0, view, sp0, ep0, mode) {\n    if (!view) view = this.get_view(c);\n    let size = size0;\n    let edgePointCoordMode = mode || (view.__raw || view).edgePointCoordMode;\n    let le = c && c.proxyObject.father;\n    let sp = sp0 || le.startPoint;\n    let ep = ep0 || le.endPoint;\n    return LEdgePoint.encodeCoords(size, edgePointCoordMode, sp, ep);\n  }\n\n  /* 13/10/2023 Giordano comment (defined in LPointerTargetable\r\n  public get_delete(context: Context): () => void {\r\n      // careful: pointedBy might be broken due to comment x984 (search it)\r\n      return super.get_delete(context);\r\n  }\r\n  */\n}, _class16.subclasses = [], _class16._extends = [], _class16)) || _class15);\nRuntimeAccessibleClass.set_extend(DVoidVertex, DEdgePoint);\nRuntimeAccessibleClass.set_extend(LVoidVertex, LEdgePoint);\nexport let DVertex = (_dec9 = RuntimeAccessible('DVertex'), _dec9(_class17 = (_class18 = class DVertex extends DGraphElement {\n  constructor() {\n    super(...arguments);\n    this.id = void 0;\n    this.graph = void 0;\n    this.model = void 0;\n    this.isSelected = void 0;\n    this.subElements = void 0;\n    this.zoom = void 0;\n    this.x = void 0;\n    this.y = void 0;\n    this.w = void 0;\n    this.h = void 0;\n    this.isResized = void 0;\n    this.__isDVertex = void 0;\n  } // DVoidVertex\n  // static _super = DVoidVertex;\n  // static singleton: LVertex;\n  // static logic: typeof LVertex;\n  // static structure: typeof DVertex;\n  // inherit redefine\n  // containedIn!: Pointer<DGraphElement, 0, 1, LGraphElement>;\n  // size!: GraphSize; // virtual, gets extracted from this. x and y are stored directly here as it extends GraphSize\n  // personal attributes\n  static new(htmlindex, model, parentNodeID, graphID, nodeID, size) {\n    return new Constructors(new DVertex('dwc'), parentNodeID, true, undefined, nodeID).DPointerTargetable().DGraphElement(model, graphID, htmlindex).DVoidVertex(size || defaultVertexSize).DVertex().end();\n  }\n}, _class18.subclasses = [], _class18._extends = [], _class18)) || _class17);\nexport let LVertex = (_dec10 = RuntimeAccessible('LVertex'), _dec10(_class19 = (_class20 = class LVertex extends LVoidVertex {\n  constructor() {\n    super(...arguments);\n    this.__raw = void 0;\n    this.id = void 0;\n    this.graph = void 0;\n    this.model = void 0;\n    this.subElements = void 0;\n    this.zoom = void 0;\n    this.x = void 0;\n    this.y = void 0;\n    this.w = void 0;\n    this.h = void 0;\n    this.size = void 0;\n    this.isResized = void 0;\n    this.__isLVertex = void 0;\n  } // static singleton: LVertex;\n  // static logic: typeof LVertex;\n  // static structure: typeof DVertex;\n  // inherit redefine\n  // isSelected: Dictionary<DocString<Pointer<DUser>>, boolean> = {};\n  isSelected(forUser) {\n    return this.wrongAccessMessage(\"node.isSelected()\");\n  }\n  // containedIn?: LGraphElement;\n\n  // virtual, gets extracted from this. x and y are stored directly here as it extends GraphSize\n\n  // personal attributes\n}, _class20.subclasses = [], _class20._extends = [], _class20)) || _class19);\nRuntimeAccessibleClass.set_extend(DGraphElement, DVertex);\nRuntimeAccessibleClass.set_extend(LGraphElement, LVertex);\nexport let DGraphVertex = (_dec11 = RuntimeAccessible('DGraphVertex'), Leaf(_class21 = _dec11(_class21 = (_class22 = class DGraphVertex extends DGraphElement {\n  constructor() {\n    super(...arguments);\n    this.id = void 0;\n    this.graph = void 0;\n    this.model = void 0;\n    this.isSelected = void 0;\n    this.subElements = void 0;\n    this.zoom = void 0;\n    this.offset = void 0;\n    this.x = void 0;\n    this.y = void 0;\n    this.w = void 0;\n    this.h = void 0;\n    this.isResized = void 0;\n    this.__isDVertex = void 0;\n    this.__isDGraph = void 0;\n    this.__isDGraphVertex = void 0;\n  } // MixOnlyFuncs(DGraph, DVertex)\n  // static _super1 = DGraph;\n  // static _super2 = DVertex;\n  // static singleton: LGraphVertex;\n  // static logic: typeof LGraphVertex;\n  // static structure: typeof DGraphVertex;\n  // inherit redefine\n  // containedIn!: Pointer<DGraphElement, 0, 1, LGraphElement>;\n  // from graph\n  // in-graph scrolling position\n  // from VoidVertex\n  // size!: GraphSize; // virtual\n  // from graph\n  // personal attributes\n  static new(htmlindex, model, parentNodeID, graphID, nodeID, size) {\n    return new Constructors(new DGraphVertex('dwc'), parentNodeID, true, undefined, nodeID).DPointerTargetable().DGraphElement(model, graphID, htmlindex).DVoidVertex(size || defaultVertexSize).DVertex().DGraph().end();\n  }\n\n  /*\r\n      static init_constructor(thiss: DGraphVertex, isUser: boolean = false, nodeID: string | undefined, graphID: string | undefined, model: Pointer<DModel>): void {\r\n          DGraph.init_constructor(thiss, isUser, nodeID, graphID, model);\r\n  //isUser: boolean = false, nodeID: string | undefined, graphID: string, model?: Pointer<DModel>\r\n          DVertex.init_constructor(thiss, isUser, nodeID, graphID as string, model);\r\n          thiss.className = this.name;\r\n      }*/\n}, _class22.subclasses = [], _class22._extends = [], _class22)) || _class21) || _class21);\nclass LG extends LGraph {}\nclass LV extends LVertex {}\nconst Mixed = MixOnlyFuncs(LG, LV);\nexport let LGraphVertex = (_dec12 = RuntimeAccessible('LGraphVertex'), _dec12(_class23 = (_class24 = class LGraphVertex extends Mixed {\n  constructor() {\n    super(...arguments);\n    this.__raw = void 0;\n    this.id = void 0;\n    this.graph = void 0;\n    this.model = void 0;\n    this.zoom = void 0;\n    this.offset = void 0;\n    this.graphSize = void 0;\n    this.x = void 0;\n    this.y = void 0;\n    this.w = void 0;\n    this.h = void 0;\n    this.isResized = void 0;\n    this.size = void 0;\n    this.__isLVertex = void 0;\n    this.__isLGraph = void 0;\n    this.__isLGraphVertex = void 0;\n  } // MixOnlyFuncs(LGraph, LVertex)\n  // static singleton: LGraphVertex;\n  // static logic: typeof LGraphVertex;\n  // static structure: typeof DGraphVertex;\n  // inherit redefine\n  // isSelected: Dictionary<DocString<Pointer<DUser>>, boolean> = {};\n  isSelected(forUser) {\n    return this.wrongAccessMessage(\"node.isSelected()\");\n  }\n  // containedIn?: LGraphElement;\n  ///////////////////////////////////////// subElements!: LGraphElement[];\n  // from graph\n\n  // in-graph scrolling position\n  // internal size of the graph. can be huge even if the sub-graph is in a small window (scroll)\n\n  // from VoidVertex\n\n  // virtual\n\n  // personal attributes\n}, _class24.subclasses = [], _class24._extends = [], _class24)) || _class23);\nRuntimeAccessibleClass.set_extend(DGraph, DGraphVertex);\nRuntimeAccessibleClass.set_extend(DVertex, DGraphVertex);\nRuntimeAccessibleClass.set_extend(LGraph, LGraphVertex);\nRuntimeAccessibleClass.set_extend(LVertex, LGraphVertex);\nexport let DVoidEdge = (_dec13 = RuntimeAccessible('DVoidEdge'), _dec13(_class25 = (_class26 = class DVoidEdge extends DGraphElement {\n  constructor() {\n    super(...arguments);\n    this.id = void 0;\n    this.graph = void 0;\n    this.model = void 0;\n    this.isSelected = void 0;\n    this.subElements = void 0;\n    this.start = void 0;\n    this.end = void 0;\n    this.__isDVoidEdge = void 0;\n    this.midPoints = void 0;\n    this.midnodes = void 0;\n    this.longestLabel = void 0;\n    this.labels = void 0;\n    this.anchorStart = void 0;\n    this.anchorEnd = void 0;\n    this.isExtend = void 0;\n    this.isReference = void 0;\n    this.isValue = void 0;\n    this.isDependency = void 0;\n  } // static singleton: LVoidEdge;\n  // static logic: typeof LVoidEdge;\n  // static structure: typeof DVoidEdge;\n  // isSelected: Dictionary<DocString<Pointer<DUser>>, boolean> = {};\n  // containedIn!: Pointer<DGraphElement, 0, 1, LGraphElement>;\n  // personal attributes\n  // the logic part which instructs to generate the midnodes\n  // using subelements instead most of times\n  // endFollow!: boolean; they became derived attributes from static properties\n  // startFollow!: boolean;\n  static new(htmlindex, model, parentNodeID, graphID, nodeID, start, end, longestLabel, labels) {\n    return new Constructors(new DEdge('dwc'), parentNodeID, true, undefined, nodeID).DPointerTargetable().DGraphElement(model, graphID, htmlindex).DVoidEdge(start, end, longestLabel, labels).end();\n  }\n  static new2(model, parentNodeID, graphID, nodeID, start, end, setter) {\n    return new Constructors(new DEdge('dwc'), parentNodeID, true, undefined, nodeID).DPointerTargetable().DGraphElement(model, graphID).DVoidEdge(start, end).end(setter);\n  }\n}, _class26.subclasses = [], _class26._extends = [], _class26.isFollowingCoords = void 0, _class26)) || _class25);\n/*\r\n@RuntimeAccessible\r\nexport class MidPoint{\r\n    readonly id: string; // not really a pointer, it's not on store.\r\n    x?: number; y?: number;\r\n    readonly w?: number; // if it's modified it's not ever here (initial size) but on DEdgePoint that is a Node.\r\n    readonly h?: number;/*\r\n    constructor2(x: number=5, y: number=5, w: number=5, h: number=5) {\r\n        this.x = x;\r\n        this.y = y;\r\n        this.w = w;\r\n        this.h = h;\r\n    }* /\r\nconstructor(id: string, w: number=5, h: number=5) {\r\n    this.id = id;\r\n    this.w = w;\r\n    this.h = h;\r\n}\r\n}*/\nexport let EdgeSegment = (_dec14 = RuntimeAccessible('EdgeSegment'), _dec14(_class27 = class EdgeSegment {\n  // if EdgeSegment is changed, shouldcomponentupdate needs update too: search in IDE for \"5khi2\"\n\n  //  a segment of the whole path\n  // m coefficient of the line between start and end.\n  // for head and tails: radian angle of the segment.\n  // for labels: it flips the angle when it's < PI/2 so the text is never upside down\n\n  /*constructor(label: PrimitiveType|undefined, length: number, startp: GraphPoint, endp: GraphPoint, start: LGraphElement, end: LGraphElement,\r\n              bezierpts: GraphPoint[], mid: LGraphElement[],\r\n              svgLetter: EdgeBendingMode, index: number, fillMode: MidNodeHandling) {\r\n      this.label = label;\r\n      this.length = length;\r\n      this.length = length;\r\n      this.startp = startp;\r\n      this.bezierp = bezierpts;\r\n      this.endp = endp;\r\n      this.start = start;\r\n      this.end = end;\r\n      this.mid = mid;\r\n  }*/\n  constructor(start, mid, end, svgLetter, gapMode, index, prevSegment) {\n    this.index = void 0;\n    this.prev = void 0;\n    this.start = void 0;\n    this.bezier = void 0;\n    this.end = void 0;\n    this.length = void 0;\n    this.d = void 0;\n    this.dpart = void 0;\n    this.m = void 0;\n    this.rad = void 0;\n    this.radLabels = void 0;\n    this.isLongest = void 0;\n    this.label = void 0;\n    this.svgLetter = void 0;\n    // console.log(\"segmentmaker:\", arguments, ((start.ge?.model as any)?.name)+\" ---> \" + ((end.ge?.model as any)?.name));\n    this.start = start;\n    this.bezier = mid;\n    this.end = end;\n    this.index = index;\n    this.prev = prevSegment;\n    //this.segments = segments;\n    // the idea: forbid all T and S or transform them in C, Q by calculating and manually adding their mirrored bezier pts\n    // if (svgLetter[1]) svgLetter = (svgLetter[0]) as any;\n    if (svgLetter === EdgeBendingMode.Bezier_QT) {\n      this.svgLetter = EdgeBendingMode.Bezier_QT[0];\n      // this.svgLetter = (index === 0 ? EdgeBendingMode.Bezier_QT[0] : EdgeBendingMode.Bezier_QT[1]) as any as EdgeBendingMode;\n      this.addBezierPoint();\n    } else if (svgLetter === EdgeBendingMode.Bezier_CS) {\n      this.svgLetter = EdgeBendingMode.Bezier_CS[0];\n      // this.svgLetter = (index === 0 ? EdgeBendingMode.Bezier_CS[0] : EdgeBendingMode.Bezier_CS[1]) as any as EdgeBendingMode;\n      this.addBezierPoint();\n    } else this.svgLetter = svgLetter;\n\n    // fix if amount of bezier pts is invalid for current letter\n    switch (this.svgLetter) {\n      case EdgeBendingMode.Line:\n      case EdgeBendingMode.Bezier_quadratic:\n        if (this.bezier.length >= 1) break;else this.svgLetter = EdgeBendingMode.Line;\n        break;\n      case EdgeBendingMode.Bezier_cubic:\n        if (this.bezier.length >= 2) break;else if (this.bezier.length >= 1) this.svgLetter = EdgeBendingMode.Bezier_quadratic;else this.svgLetter = EdgeBendingMode.Line;\n        break;\n      case EdgeBendingMode.Elliptical_arc:\n        if (this.bezier.length >= 3) break;else this.svgLetter = EdgeBendingMode.Line; // straight to end ignoring midpoints that are NOT coordinates when using elliptical arc.\n        break;\n      default:\n      //case EdgeBendingMode.Bezier_quadratic_mirrored as string:\n      //case EdgeBendingMode.Bezier_cubic_mirrored as string: // translated to Q or C by adding mirrored bezier points explicitly\n      case EdgeBendingMode.Bezier_QT:\n      case EdgeBendingMode.Bezier_CS:\n        // translated to Q or C by sending the right letter to each segment\n        Log.exDevv(\"this svg letter should not appear here\", this.svgLetter);\n        break;\n    }\n  }\n  addBezierPoint() {\n    let prev = this.prev;\n    if (!prev) return;\n    let prevedgemakerbezier = prev.bezier[prev.bezier.length - 1] || prev.start;\n    let mirroredBezier = {\n      ...prevedgemakerbezier,\n      pt: EdgeSegment.invertLastBezierPt(prevedgemakerbezier.pt, prev.end.pt),\n      uncutPt: EdgeSegment.invertLastBezierPt(prevedgemakerbezier.uncutPt, prev.end.uncutPt)\n    };\n    this.bezier = [mirroredBezier, ...this.bezier];\n    // always only 1 assumed pt both in cubic and quadratic.\n    // let next: this | undefined = this.segments[this.index+1];\n    // EdgeSegment.invertLastBezierPt((next.mid[1] || next.end).pt, next.start.pt);\n  }\n  makeD(index, gapMode) {\n    this.m = GraphPoint.getM(this.start.pt, this.end.pt);\n    this.rad = Geom.mToRad(this.m, this.start.pt, this.end.pt);\n    this.radLabels = Math.atan(this.m);\n    let svgLetter = this.svgLetter; // caller makes sure to pass right letter and resolve \"CS\" mixed letters. // this.bendingModeToLetter(bendingMode, index);\n    // caller sends inverted pts as normal coords\n    // let invertedBezPt = lastSegment && EdgeSegment.invertLastBezierPt(lastSegment.midp[lastSegment.mid.length-1] || lastSegment.startp, lastSegment.endp);\n    switch (this.svgLetter.length) {\n      case 2:\n        return Log.exDevv(\"mixed letters are not allowed and should have been resolved to single svg letters before here, found:\" + svgLetter);\n      /*return Log.exDevv(\"dev problem to fix:\\n\" +\r\n      \"the mirrored mode requires the first one to have explicit non-mirrored mode?? like M, C a1 a2 a3, S a1, S a1, S a1\\n\" +\r\n      \"So all segments with mixed modes needs to extract the last bezier point (penultimate coordinate) from previous segments, mirror it and insert in midp[0]\");*/\n      case 1:\n        let bezierpts = [...this.bezier.map(b => b.pt), this.end.pt];\n        let finalpart = svgLetter + \" \" + bezierpts.map(p => p.x + \" \" + p.y).join(\", \");\n        this.dpart = \"M \" + this.start.pt.x + \" \" + this.start.pt.y + \", \" + finalpart;\n        let bezierptsUncut = [...this.bezier.map(b => b.uncutPt), this.end.pt]; // uncutPt exist for start and end too, but i want to use the cut one for those. or edgehead is off\n        let finalpartUncut = svgLetter + \" \" + bezierptsUncut.map(p => p.x + \" \" + p.y).join(\", \");\n        this.d = (index === 0 ? \"M\" + this.start.pt.x + \" \" + this.start.pt.y + \", \" : \"\") + finalpartUncut;\n\n        //midp = [this.startp, ...this.midp];\n        // d = M sp X mp2 ep // X = custom letter\n        // dpart = T sp X mp2 ep // S = S if X = C,\n        // sp is the startingpoint from the prev node, which might be != from endpoint of last node if last node have w>0 && h>0\n        // so i'm \"filling\" the gap with a T, or L arc wich can use only 1 parameter (they are the only 1-parameter arcs)\n        // if (this.prev && this.prev.end.pt.equals(this.start.pt)) gapMode = EdgeGapMode.average; // if the 2 points coincide, i use any 1 of the gapmodes that are continuous\n        /*switch (gapMode){\r\n            case EdgeGapMode.center:\r\n            case EdgeGapMode.average:\r\n                // continuous gap modes. they only differ in how the \"joining\" point is found, but not in how they behave after that.\r\n                /*\r\n                if (index === 0) {\r\n                     startletter = \"M \";\r\n                 }\r\n                 else {\r\n                     switch (svgLetter) {\r\n                         case SvgLetter.A: case SvgLetter.C: case SvgLetter.S: case SvgLetter.Q: case SvgLetter.T: default:\r\n                             startletter = SvgLetter.T + \" \"; break;\r\n                         case SvgLetter.L: case SvgLetter.M:\r\n                             startletter = SvgLetter.L + \" \"; break;\r\n                     }\r\n                 }* /\r\n                if (index) {\r\n                    this.d = finalpart;\r\n                }\r\n                else { this.d = this.dpart; }\r\n                break;\r\n            case EdgeGapMode.gap:\r\n            case EdgeGapMode.autoFill:\r\n            case EdgeGapMode.lineFill:\r\n            case EdgeGapMode.arcFill:\r\n                // the filling itself is done by another segment (solving svg letter and simulating i=0), so i treat it as a gap.\r\n                this.d = this.dpart;\r\n                break;\r\n            default:\r\n                Log.exDevv(\"unexpected EdgeGapMode:\" + gapMode, {gapMode});\r\n        }*/\n        break;\n      default:\n        return Log.exDevv(\"unexpected bending mode length:\" + this.svgLetter + \" or fillMode: \" + gapMode, {\n          bendingMode: this.svgLetter,\n          index,\n          gapMode\n        });\n    }\n\n    //using\n    /*\r\n    88\r\n      // d should not have M set (except for segments[0]\r\n    // dpart have M abd beed to add explicit points for \"mirroring\" and transforming bezier quadratic mirrored in bezier quadratic normal etc.\r\n    //88 problem: the mirrored mode requires the first one to have explicit nonmirrored mode?? like M, C a1 a2 a3, S a1, S a1, S a1 .... ?\r\n    in any case the % letter part is wrong because it needs to subtract first element used for M*/\n    return this.d;\n  }\n  static invertLastBezierPt(bezier, end) {\n    // vector = bezier - end\n    // end + vector = bezier\n    // end - vector = inverted bezier? = 2*end-bezier\n    let vector = bezier.subtract(end, true);\n    return end.subtract(vector, true);\n  }\n  calcLength() {\n    this.length = this.start.pt.distanceFromPoint(this.end.pt);\n  }\n}) || _class27);\nexport class EdgeFillSegment extends EdgeSegment {\n  makeD(index, gapMode) {\n    // if (gapMode === EdgeGapMode.autoFill) { gapMode = this.svgLetter === EdgeBendingMode.Line ? EdgeGapMode.lineFill : EdgeGapMode.arcFill; }\n    switch (gapMode) {\n      case \"closest\": // EdgeGapMode.closest:\n      case EdgeGapMode.center:\n      case EdgeGapMode.average:\n      case EdgeGapMode.gap:\n        return \"\";\n      // should not have filler arcs\n      default:\n        /*\r\n        case EdgeGapMode.autoFill as any:\r\n        case EdgeGapMode.lineFill:\r\n        this.bezier = [];\r\n        this.svgLetter = EdgeBendingMode.Line;\r\n        return super.makeD(index, gapMode);\r\n        case EdgeGapMode.arcFill:*/\n        this.svgLetter = this.svgLetter[0];\n        if (this.svgLetter === \"Q\") this.bezier = this.bezier.length ? [this.bezier[0]] : [];\n        return super.makeD(index, gapMode);\n    }\n  }\n}\nEdgeFillSegment.cname = \"EdgeFillSegment\";\nexport let LVoidEdge = (_dec15 = RuntimeAccessible('LVoidEdge'), _dec15(_class29 = (_class30 = class LVoidEdge extends LGraphElement {\n  constructor() {\n    super(...arguments);\n    this.__raw = void 0;\n    this.id = void 0;\n    this.graph = void 0;\n    this.model = void 0;\n    this.subElements = void 0;\n    this.__isLVoidEdge = void 0;\n    this.midPoints = void 0;\n    this.midnodes = void 0;\n    this.edge = void 0;\n    this.__info_of__edge = {\n      type: \"?LEdge\",\n      txt: \"returns this if called on an edge, the containing edge if called on an EdgePoint, undefined otherwise.\"\n    };\n    this.isExtend = void 0;\n    this.isReference = void 0;\n    this.isValue = void 0;\n    this.isDependency = void 0;\n    this.allNodes = void 0;\n    this.__info_of__allNodes = {\n      type: \"[LGraphElement, ...Array<LEdgePoint>, LGraphElement]\",\n      txt: /*#__PURE__*/_jsxDEV(\"span\", {\n        children: \"first element is this.start. then all this.midnodes. this.end as last element\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 1933,\n        columnNumber: 101\n      }, this)\n    };\n    this.label = void 0;\n    this.longestLabel = void 0;\n    this.labels = void 0;\n    this.__info_of__longestLabel = {\n      label: \"Longest label\",\n      type: \"function(edge)=>string\",\n      readType: \"(edge:LEdge, segment: EdgeSegment, allNodes: DGraphElement[], allSegments: EdgeSegment[]) => PrimitiveType\",\n      writeType: \"string\",\n      txt: /*#__PURE__*/_jsxDEV(\"span\", {\n        children: \"Label assigned to the longest path segment.\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 1942,\n        columnNumber: 14\n      }, this)\n    };\n    this.__info_of__label = {\n      type: \"\",\n      txt: /*#__PURE__*/_jsxDEV(\"span\", {\n        children: \"Alias for longestLabel\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 1943,\n        columnNumber: 46\n      }, this)\n    };\n    this.__info_of__labels = {\n      label: \"Multiple labels\",\n      type: \"same type as longestLabel | longestLabel[]\",\n      writeType: \"string\",\n      txt: /*#__PURE__*/_jsxDEV(\"span\", {\n        children: \"Instructions to label to multiple or all path segments in an edge\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 1946,\n        columnNumber: 14\n      }, this)\n    };\n    this.start = void 0;\n    this.__info_of__start = {\n      type: \"LVertex\",\n      txt: \"the source point of the edge.\"\n    };\n    this.end = void 0;\n    this.__info_of__end = {\n      type: \"LVertex\",\n      txt: \"the terminal point of the edge.\"\n    };\n    this.__info_of__startPoint = {\n      type: \"GraphPoint\",\n      txt: /*#__PURE__*/_jsxDEV(\"span\", {\n        children: \"startPoint of this.start (element originating the edge). Defaults in outer coordinates.\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 2151,\n        columnNumber: 60\n      }, this)\n    };\n    this.__info_of__endPoint = {\n      type: \"GraphPoint\",\n      txt: /*#__PURE__*/_jsxDEV(\"span\", {\n        children: \"endPoint of this.end (element originating the edge). Defaults in outer coordinates.\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 2152,\n        columnNumber: 58\n      }, this)\n    };\n    this.segments = void 0;\n    this.segments_inner = void 0;\n    this.segments_outer = void 0;\n    this.__info_of__segments = {\n      type: \"{all:T, segments:T, fillers:T, head: GraphSize&{rad:number}, tail: as head} where T is EdgeSegment\",\n      txt: /*#__PURE__*/_jsxDEV(\"span\", {\n        children: [\"Collection of segments connecting in order vertex and EdgePoint without intersecting their area, aimed to be rendered in svg path.\", /*#__PURE__*/_jsxDEV(\"br\", {}, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 2172,\n          columnNumber: 13\n        }, this), \"fillers are arcs generated by view.edgeGapMode being autofill, arcfill or linefill.\", /*#__PURE__*/_jsxDEV(\"br\", {}, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 2173,\n          columnNumber: 13\n        }, this), \"length of this.segments array is Math.ceil(allNodes.length / svg_letter_size) specified on view.\", /*#__PURE__*/_jsxDEV(\"br\", {}, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 2174,\n          columnNumber: 13\n        }, this), \"\\\"head\\\" and \\\"tail\\\" are the position and angle of eventual edge decorators. Refer to this.headPos documentation.\"]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 2171,\n        columnNumber: 13\n      }, this)\n    };\n    this.d = void 0;\n    this.__info_of__d = {\n      type: ShortAttribETypes.EString,\n      txt: \"the full suggested path of SVG path \\\"d\\\" attribute, merging all segments.\"\n    };\n    this.anchorStart = void 0;\n    this.anchorEnd = void 0;\n    this.__info_of__anchorStart = {\n      writeType: \"string | undefined\",\n      type: \"string\",\n      isEdge: true,\n      txt: \"The name of a node anchor where the edge should originate from.\"\n    };\n    this.__info_of__anchorEnd = {\n      writeType: \"string | undefined\",\n      type: \"string\",\n      isEdge: true,\n      txt: \"The name of a node anchor where the edge should point to.\"\n    };\n    this.endFollow = void 0;\n    this.startFollow = void 0;\n    this.__info_of__endFollow = {\n      writeType: \"boolean\",\n      readType: \"boolean\",\n      type: \"boolean\",\n      isEdge: true,\n      // type:\"read:(()=>void), write:boolean\", readType:\"(()=>void))\",\n      txt: \"makes the ending point of an edge follow the cursor, so it can be assigned to a new anchor or target.\"\n    };\n    this.__info_of__startFollow = {\n      writeType: \"boolean\",\n      readType: \"boolean\",\n      type: \"boolean\",\n      isEdge: true,\n      // type:\"read:(()=>void), write:boolean\", readType:\"(()=>void))\",\n      txt: \"makes the starting point of an edge follow the cursor, so it can be assigned to a new anchor or source.\"\n    };\n  } // static singleton: LVoidEdge;\n  // static logic: typeof LVoidEdge;\n  // static structure: typeof DVoidEdge;\n  // isSelected: Dictionary<DocString<Pointer<DUser>>, boolean> = {};\n  isSelected(forUser) {\n    return this.wrongAccessMessage(\"node.isSelected()\");\n  }\n  // containedIn?: LGraphElemnt;\n\n  // the logic part which instructs to generate the midnodes\n\n  // returns self. useful to get edge from edgePoints without triggering error if you are already on edge.\n\n  /*\r\n  replaced by startPoint\r\n      edgeStart!: GraphPoint;\r\n      edgeStart_inner!: GraphPoint;\r\n      edgeStart_outer!: GraphPoint;\r\n      __info_of__edgeStart: Info = {type: \"GraphPoint\", txt: \"Same as edgeStart_outer.\"}\r\n      __info_of__edgeStart_outer: Info = {type: \"GraphPoint\",\r\n       txt: \"Where the edge should start his path, in coordinates relative at the root Graph.\r\n       <br>Computed by combining the anchor offset option in View and the size of the starting node.\"}\r\n      __info_of__edgeStart_inner: Info = {type: \"GraphPoint\",\r\n       txt: \"Where the edge should start his path, in coordinates relative at the most nested Graph.\r\n       <br>Computed by combining the anchor offset option in View and the size of the starting node.\"}\r\n      edgeEnd!: GraphPoint;\r\n      edgeEnd_inner!: GraphPoint;\r\n      edgeEnd_outer!: GraphPoint;\r\n      __info_of__edgeEnd: Info = {type: \"GraphPoint\", txt: \"Same as edgeEnd_outer.\"}\r\n      __info_of__edgeEnd_outer: Info = {type: \"GraphPoint\",\r\n       txt: \"Where the edge should end his path, in coordinates relative at the root Graph.\r\n       <br>Computed by combining the anchor offset option in View and the size of the starting node.\"}\r\n      __info_of__edgeEnd_inner: Info = {type: \"GraphPoint\",\r\n       txt: \"Where the edge should end his path, in coordinates relative at the most nested Graph.\r\n       <br>Computed by combining the anchor offset option in View and the size of the starting node.\"}\r\n  */\n\n  // should never be read change their documentation in write only. their values is \"read\" in this.segments\n\n  get_start(c) {\n    return LPointerTargetable.fromPointer(c.data.start);\n  }\n  set_start(val, c) {\n    let ptr = Pointers.from(val);\n    if (!ptr) {\n      Log.exx(\"attempting to set an invalid LEdge.start: \" + ptr, {\n        ptr,\n        data: c.data\n      });\n      return true;\n    }\n    if (ptr === c.data.start) return true;\n    let name = this.get_name(c) || '';\n    TRANSACTION((name.toLowerCase().indexOf('edge') >= 0 ? name : 'Edge: ' + name) + '.start', () => {\n      SetFieldAction.new(c.data.id, 'start', ptr, '', true);\n    }, LPointerTargetable.from(c.data.start).name, LPointerTargetable.from(ptr).name);\n    return true;\n  }\n  get_end(c) {\n    return LPointerTargetable.fromPointer(c.data.end);\n  }\n  set_end(val, c) {\n    let ptr = Pointers.from(val);\n    if (!ptr) {\n      Log.exx(\"attempting to set an invalid LEdge.end: \" + ptr, {\n        ptr,\n        data: c.data\n      });\n      return true;\n    }\n    if (ptr === c.data.end) return true;\n    let name = this.get_name(c) || '';\n    TRANSACTION((name.toLowerCase().indexOf('edge') >= 0 ? name : 'Edge: ' + name) + '.end', () => {\n      SetFieldAction.new(c.data.id, 'end', ptr, '', true);\n    }, LPointerTargetable.from(c.data.end).name, LPointerTargetable.from(ptr).name);\n    return true;\n  }\n  get_label(c) {\n    return this.get_longestLabel(c);\n  }\n  set_label(val, c) {\n    return this.set_longestLabel(val, c);\n  }\n  get_longestLabel(c) {\n    return transientProperties.node[c.data.id].longestLabel;\n    /*if (transientProperties.node[c.data.id].longestLabel !== undefined) return transientProperties.node[c.data.id].longestLabel;\r\n    else return transientProperties.view[c.data.view].longestLabel;*/\n  }\n  get_labels(c) {\n    return transientProperties.node[c.data.id].labels;\n    /*if (transientProperties.node[c.data.id].labels !== undefined) return transientProperties.node[c.data.id].labels;\r\n    else return transientProperties.view[c.data.view].labels;*/\n  }\n  set_longestLabel(val, c) {\n    Log.exDevv('Edge.labels are disabled, pass it through props instead');\n    if (val === c.data.longestLabel) return true;\n    let name = this.get_name(c) || '';\n    TRANSACTION((name.toLowerCase().indexOf('edge') >= 0 ? name : 'Edge: ' + name) + '.label', () => {\n      SetFieldAction.new(c.data, \"longestLabel\", val);\n      SetRootFieldAction.new(\"NODES_RECOMPILE_longestLabel+=\", c.data.id);\n    }, c.data.longestLabel, val);\n    return true;\n  }\n  set_labels(val, c) {\n    Log.exDevv('Edge.labels are disabled, pass it through props instead');\n    if (val === c.data.labels) return true;\n    let name = this.get_name(c) || '';\n    TRANSACTION((name.toLowerCase().indexOf('edge') >= 0 ? name : 'Edge: ' + name) + '.labels', () => {\n      SetFieldAction.new(c.data, \"labels\", val);\n      SetRootFieldAction.new(\"NODES_RECOMPILE_labels+=\", c.data.id);\n    }, c.data.labels, val);\n    return true;\n  }\n  headPos_impl(c, isHead, headSize0, segment0, zoom0) {\n    let segment = segment0 || this.get_segments(c).segments[0];\n    // let v: LViewElement = this.get_view(c);\n    let tmp = headSize0 || (isHead ? this.get_view(c).edgeHeadSize : this.get_view(c).edgeTailSize);\n    if (!tmp || tmp.x === 0 || tmp.y === 0) {\n      // head or tail missing\n      tmp = new GraphSize(0, 0, 0, 0);\n      tmp.rad = 0;\n      return tmp;\n    }\n    let zoom = zoom0 || this.get_graph(c).zoom; // ownZoom or cumulativeZoom?\n    let headPos = new GraphSize(0, 0, tmp.x, tmp.y); //.multiply({w:zoom.x, h:zoom.y});\n    let useBezierPoints = true;\n    let start, end;\n    let m;\n    if (useBezierPoints) {\n      if (isHead) {\n        start = segment.end.pt;\n        end = (segment.bezier[segment.bezier.length - 1] || segment.start).pt;\n      } else {\n        start = segment.start.pt;\n        end = (segment.bezier[0] || segment.end).pt;\n      }\n      m = GraphPoint.getM(start, end);\n    } else {\n      if (isHead) {\n        start = segment.end.pt;\n        end = segment.start.pt;\n      } else {\n        start = segment.start.pt;\n        end = segment.end.pt;\n      }\n      m = segment.m;\n    }\n    // first find the center of where it should be positioned\n    // let center: GraphPoint;\n    // let distance: number = Math.sqrt(headPos.w*headPos.w + headPos.h*headPos.h);\n    // let isVertical = m >=1 ;\n    let x4headsize = new GraphSize(start.x - headPos.w, start.y - headPos.h, headPos.w * 2, headPos.h * 2);\n    // first intersection is segment origin. second is found with the box containing all possible edgeHead positions that touch the startPoint\n    // (doing x4 his shape and placing 4 \"rectangles\" all around startPoint) to cover all possible segment directions.\n    // or finding first direction (vertical if m >1, horizontal if m<0) and vector direction and intersecting with only the \"correct\" placed edgeHead rectangle.\n    // then the intersection will likely not fall on the extreme angle of EdgeHead and i can re-center edgeHead\n    // so that first and second intersections are equal spaced with the center segment\n    let secondIntersection;\n    let segmentDistance = start.distanceFromPoint(end);\n    if (segmentDistance <= Math.sqrt(headPos.w ** 2 + headPos.h ** 2)) {\n      let safeDistance = Math.max(headPos.w, headPos.h) * 5;\n      end = new GraphPoint(end.y + safeDistance, end.y + m * safeDistance); // move the point away so it doesn't intersect anymore. i just need direction\n      // too small to fit edgeHead, i simply put it centered on the whole segment\n      // secondIntersection = end;\n    }\n    secondIntersection = GraphSize.closestIntersection(x4headsize, start, end, undefined);\n    if (!secondIntersection) {\n      return Log.exDevv(\"failed to intersect edge head\", {\n        x4headsize,\n        segment,\n        headPos,\n        c,\n        start,\n        end,\n        useBezierPoints\n      });\n    }\n    tmp = secondIntersection.add(start, false).divide(2); // center of edgehead\n    headPos.x = tmp.x - headPos.w / 2; // tl corner\n    headPos.y = tmp.y - headPos.h / 2; // tl corner\n    headPos.rad = Geom.mToRad(m, start, end);\n    /*\r\n    devo trovare la distanza tra il centro dell'egeHead e il punto di inizio in termini assoluti, così tramite M trovo distanza in x e y. o trovarla in altro modo\r\n    if (segment.m === Number.POSITIVE_INFINITY || segment.m === Number.NEGATIVE_INFINITY) {\r\n        center = segment.start.pt.add({x:0, y: distance}, true); }\r\n    else { center = segment.start.pt.add({x:segment.m*headPos.w/2, y:segment.m*headPos.h/2\r\n     this is wrong, cannot be the same for x and y, i should invert the line equation for x?}, true); }\r\n    headPos.x = center.x - headPos.w / 2;\r\n    headPos.y = center.y - headPos.h / 2;*/\n    // console.log(\"head intersected\", {headPos, secondIntersection, x4headsize, segment, c, start, end, useBezierPoints});\n\n    return headPos;\n  }\n  headPos(headSize0, segment0, zoom0) {\n    return this.wrongAccessMessage(\"This is not headPos() implementation. it is just for typings. use the getter\");\n  }\n  tailPos(headSize0, segment0, zoom0) {\n    return this.wrongAccessMessage(\"This is not tailPos() implementation. it is just for typings. use the getter\");\n  }\n  get_headPos(c) {\n    return (headSize, segment, zoom) => this.headPos_impl(c, true, headSize, segment, zoom);\n  }\n  get_tailPos(c) {\n    return (headSize, segment, zoom) => this.headPos_impl(c, false, headSize, segment, zoom);\n  }\n  get_allNodes(c) {\n    return [this.get_start(c), ...this.get_midnodes(c), this.get_end(c)];\n  }\n  get_edge(c) {\n    return c.proxyObject;\n  }\n  set_edge(v, c) {\n    return this.cannotSet(\"edge field, on an edge element\");\n  }\n  get_midPoints(c) {\n    return c.data.midPoints;\n  }\n  addMidPoint(v) {\n    return this.wrongAccessMessage(\"addMidPoint\");\n  }\n  get_addMidPoint(c) {\n    return v => this.impl_addMidPoints(v, c);\n  }\n  set_midPoints(val, c) {\n    let name = this.get_name(c) || '';\n    TRANSACTION((name.toLowerCase().indexOf('edge') >= 0 ? name : 'Edge: ' + name) + '.midpoints', () => {\n      SetFieldAction.new(c.data.id, \"midPoints\", val, undefined, false);\n    });\n    return true;\n  }\n  impl_addMidPoints(val, c) {\n    let name = this.get_name(c) || '';\n    TRANSACTION((name.toLowerCase().indexOf('edge') >= 0 ? name : 'Edge: ' + name) + ' add midpoints', () => {\n      SetFieldAction.new(c.data.id, \"midPoints\", val, '+=', false);\n    });\n    return true;\n  }\n  get_label_impl(c, segment, nodes, segments) {\n    let key = segment.isLongest ? \"longestLabel\" : \"labels\"; // : keyof this\n    // if (isLongestSegment) return this.get_longestLabel_impl(d, l, nodes, index):\n    const d = c.data;\n    const l = c.proxyObject;\n    let labelmaker = this['get_' + key](c);\n    let labelmakerfunc = labelmaker;\n    // let lastSeg = segments[i-1];\n    switch (typeof labelmaker) {\n      //nb{}[]<>\n      case \"number\":\n      case \"undefined\":\n      case \"boolean\":\n      case \"string\":\n        return labelmaker;\n      // case \"function\": return nodes.map( (o, i) => d.labels(l, nodes, i)).slice(0, nodes.length-1);\n      // (e:LVoidEdge, segment: EdgeSegment, allNodes: LEdge[\"allNodes\"], allSegments: EdgeSegment[]) => PrimitiveType\n      case \"function\":\n        return labelmakerfunc(l, segment, nodes, segments);\n      default:\n        break;\n      case \"object\":\n        if (labelmaker === null) return null;\n        if (!Array.isArray(labelmaker)) break;\n        let elem = labelmaker[segment.index % labelmaker.length];\n        if (typeof elem === \"function\") return elem(l, segment, nodes, segments);\n        return elem;\n    }\n    Log.exx(\"edge labels invalid type, must be a primitive value, a function or an array of such.\", {\n      labelmaker,\n      key,\n      d\n    });\n    return undefined;\n  } /*\r\n    private get_label_impl_old(d: DVoidEdge, l: LVoidEdge, nodes:this[\"allNodes\"], index: number, longestlabelindex?: number): PrimitiveType {\r\n       if (d.longestLabel !== undefined && index === longestlabelindex) return this.get_longestLabel_impl(d, l, nodes, index);\r\n       switch (typeof d.labels) {//nb{}[]<>\r\n           case \"number\":\r\n           case \"undefined\":\r\n           case \"boolean\":\r\n           case \"string\": return d.labels;\r\n           // case \"function\": return nodes.map( (o, i) => d.labels(l, nodes, i)).slice(0, nodes.length-1);\r\n           case \"function\": return d.labels(l, nodes[index], nodes[index+1], index, nodes);\r\n           default: break;\r\n           case \"object\": if (!Array.isArray(d.labels)) break;\r\n           if (typeof d.labels[0] === \"function\") return (d.labels as any)[index % d.labels.length](l, nodes[index], nodes[index+1], index, nodes);\r\n           return (d.labels as PrimitiveType[])[index % d.labels.length];\r\n       }\r\n       Log.exx(\"edge labels invalid type, must be a primitive value, a function or an array of such.\", d.labels);\r\n    }*/\n\n  get_startPoint(context) {\n    return this.get_startPoint_Outer(context);\n  }\n  get_endPoint(context) {\n    return this.get_endPoint_Outer(context);\n  }\n  get_startPoint_Outer(c) {\n    // console.log(\"get_edgeStart_Outer\", {out:this.get_outerGraph(c), pos:this.get_startPoint_inner(c), inner:this.get_start(c).innerGraph});\n    return this.get_outerGraph(c).translateSize(this.get_startPoint_inner(c), this.get_start(c).innerGraph);\n  }\n  get_endPoint_Outer(c) {\n    // console.log(\"get_edgeEnd_Outer\", {out:this.get_outerGraph(c), pos:this.get_endPoint_inner(c), inner:this.get_end(c).innerGraph});\n    return this.get_outerGraph(c).translateSize(this.get_endPoint_inner(c), this.get_end(c).innerGraph);\n  }\n  get_startPoint_inner(c) {\n    return this.get_edgeStartEnd_inner(c, true);\n  }\n  get_endPoint_inner(c) {\n    return this.get_edgeStartEnd_inner(c, false);\n  }\n  get_edgeStartEnd_inner(c, isStart) {\n    return isStart ? this.get_start(c).startPoint : this.get_end(c).endPoint;\n  }\n  svgLetterSize(s) {\n    let addM = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    let doublingMidPoints = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    let ret;\n    switch (s) {\n      default:\n        ret = Log.exDevv(\"unexpected svg path letter: \\\"\" + s + \"\\\"\", s);\n        break;\n      case EdgeBendingMode.Line:\n        //case EdgeBendingMode.Bezier_quadratic_mirrored:\n        ret = {\n          first: 1,\n          others: 1\n        };\n        break;\n      case EdgeBendingMode.Bezier_quadratic:\n        //case EdgeBendingMode.Bezier_cubic_mirrored:\n        ret = {\n          first: 2,\n          others: 2\n        };\n        break;\n      case EdgeBendingMode.Bezier_cubic:\n        ret = {\n          first: 3,\n          others: 3\n        };\n        break;\n      case EdgeBendingMode.Elliptical_arc:\n        ret = {\n          first: 4,\n          others: 4\n        };\n        break;\n      case EdgeBendingMode.Bezier_QT:\n        ret = {\n          first: 2,\n          others: 1\n        };\n        break;\n      case EdgeBendingMode.Bezier_CS:\n        ret = {\n          first: 3,\n          others: 2\n        };\n        break;\n    }\n\n    // account for the fact that every midpoint is listed twice: at anchor start and anchor end.\n    if (doublingMidPoints) {\n      // removing last point (first is already excluded because addM didn't trigger yet)\n      // , the remaining are midpoints to double. then i add it back\n      ret.first = (ret.first - 1) * 2 + 1;\n      ret.others = (ret.others - 1) * 2 + 1;\n    }\n\n    // account for the first M letter\n    //    (if the segment is not mode.gap or first, M coord still exist in segment but are ignored)\n    if (addM) {\n      ret.first += 1;\n      ret.others += 1;\n    }\n    return ret;\n  }\n\n  // outer should be a redundant param and always == true\n  get_points_impl(allNodes, outer, c) {\n    function getAnchorOffset(size, offset, isPercentage) {\n      let $factor = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 100;\n      if (!size) size = new GraphSize(0, 0, 0, 0);\n      // else if (!size.tl) size = new GraphSize(size.x, size.y, size.w, size.h);\n      if (isPercentage) offset = new GraphPoint(offset.x / $factor * size.w, offset.y / $factor * size.h);\n      return size.tl().add(offset, false);\n    }\n    let innermost = this.get_graph(c);\n    let root = this.get_root(c);\n    const all = allNodes.flatMap((ge, i) => {\n      let dge = ge.__raw;\n      let size = outer ? ge.outerSize : ge.innerSize;\n      if (outer && root && innermost && innermost.id !== root.id) {\n        size = innermost.translateSize(size, root);\n      }\n      let base = {\n        view: ge.view,\n        size,\n        ge,\n        pt: null,\n        uncutPt: null\n      };\n      Log.exDev(typeof base.size !== \"object\", \"could not get node size:\", {\n        base,\n        c,\n        outer\n      });\n      let rets; // = base as any;\n      let rete; // = {...base} as any;\n      let debug = true;\n      if (debug) {\n        base.anchor_e = dge.anchors[c.data.anchorEnd || 0] || dge.anchors[Object.keys(dge.anchors)[0]];\n        base.anchor_s = dge.anchors[c.data.anchorStart || 0] || dge.anchors[Object.keys(dge.anchors)[0]];\n      }\n\n      // get endpoint, then startpoint (land on midnode, then depart from it)\n      if (i !== 0) {\n        rete = {\n          rete: true,\n          ...base\n        };\n        if (i === allNodes.length - 1) {\n          // get end anchor from node\n          let anchor = dge.anchors[c.data.anchorEnd || 0];\n          if (!anchor) anchor = dge.anchors[Object.keys(dge.anchors)[0]];\n          if (anchor) rete.pt = getAnchorOffset(rete.size, anchor, true, 1);\n        }\n        // if no anchor, treat the node as a midpoint\n        if (!rete.pt) {\n          // get ending point from midpoint\n          //rete.pt = (LEdgePoint.singleton as LEdgePoint).get_endPoint(undefined as any, rete.size, rete.view);\n          rete.pt = getAnchorOffset(rete.size, rete.view.edgeStartOffset, rete.view.edgeStartOffset_isPercentage);\n        }\n        rete.uncutPt = rete.pt;\n      }\n      if (i !== allNodes.length - 1) {\n        rets = {\n          rets: true,\n          ...base\n        };\n        if (i === 0) {\n          // get start anchor from node\n          let anchor = dge.anchors[c.data.anchorStart || 0];\n          if (!anchor) anchor = dge.anchors[Object.keys(dge.anchors)[0]];\n          if (anchor) rets.pt = getAnchorOffset(rets.size, anchor, true, 1);\n        }\n        if (!rets.pt) {\n          // rets starting point from midpoint\n          // rets.pt = (LEdgePoint.singleton as LEdgePoint).get_startPoint(undefined as any, rets.size, rets.view);\n          rets.pt = getAnchorOffset(rets.size, rets.view.edgeStartOffset, rets.view.edgeStartOffset_isPercentage);\n        }\n        rets.uncutPt = rets.pt;\n      }\n\n      // ret.pt = ge.startPoint\n      return rets && rete ? [rete, rets] : rets ? [rets] : [rete];\n    });\n    if (DVoidEdge.isFollowingCoords) {\n      if (c.data.id === LVoidEdge.endFollow) {\n        let seg = all[all.length - 1];\n        seg.pt = DVoidEdge.isFollowingCoords;\n        seg.size = new GraphSize(seg.pt.x, seg.pt.y, 0.01, 0.01);\n      }\n      if (c.data.id === LVoidEdge.startFollow) {\n        let seg = all[0];\n        seg.pt = DVoidEdge.isFollowingCoords;\n        seg.size = new GraphSize(seg.pt.x, seg.pt.y, 0.01, 0.01);\n      }\n    }\n    return all;\n  }\n  get_pointsDebug(c) {\n    return this.get_points_impl(this.get_allNodes(c), true, c);\n  }\n  get_points(allNodes) {\n    let outer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    let c = arguments.length > 2 ? arguments[2] : undefined;\n    return this.get_points_impl(allNodes, outer, c);\n  }\n  get_points_outer(allNodes, c) {\n    return this.get_points_impl(allNodes, true, c);\n  }\n  // private get_points_inner(allNodes: LGraphElement[], c: Context): segmentmaker[]{ return this.get_points_impl(allNodes, false, c); }\n\n  get_d(c) {\n    return this.get_segments(c).all.map(s => s.d).join(\" \");\n  } /*\r\n    private get_fillingSegments(c: Context): Partial<this[\"segments\"]> {\r\n       return this.get_segments(c).fillers;\r\n    }*/\n\n  get_segments(c) {\n    return this.get_segments_outer(c);\n  }\n  get_segments_outer(c) {\n    return this.get_segments_impl(c, true);\n  }\n  // public get_segments_inner(c: Context): this[\"segments\"] { return this.get_segments_impl(c, false); }\n  get_segments_impl(c, outer) {\n    let l = c.proxyObject;\n    let v = this.get_view(c);\n    let allNodes = l.allNodes;\n    windoww.edge = l;\n    let all = this.get_points(allNodes, outer, c);\n    //const all: {size: GraphSize, view: LViewElement, ge: LGraphElement}[] = allNodes.map((ge) => { return { view: ge.view, size: ge.size, ge}});\n    let ret = [];\n    let bm = v.bendingMode;\n    let gapMode = v.edgeGapMode;\n    let segmentSize = this.svgLetterSize(bm, false, true);\n    let increase = segmentSize.first;\n    let segment = undefined;\n    /// grouping points according to SvgLetter\n    for (let i = 0; i < all.length - 1;) {\n      // let start = all[i], end = all[i+increase];\n      let start = all[i];\n      let endindex = i + increase < all.length - 1 ? i + increase : all.length - 1;\n      let mid = all.slice(i + 1, endindex).filter((e, i) => i % 2 === 0);\n      let end = all[endindex];\n      // makes sure the edge actually reaches his target even if there is an invalid amount of midnodes fot the current EdgeBendingMode\n      if (i === endindex && segment) start = segment.end;\n      // segment = this.get_segmentv3(start, mid, end, getSvgLetter(i), i, segment, all);\n      segment = new EdgeSegment(start, mid, end, bm, gapMode, i, segment);\n      // segment = this.get_segment(start.ge, start.size, start.view, end.ge, end.size, end.view, cut, v.bendingMode, mid, ret[ret.length -1], fillMode, segment);\n      ret.push(segment);\n      i += increase + 1; // because increase index is already inserted at the end of prev segment\n      if (increase !== segmentSize.others) increase = segmentSize.others;\n      // if (longestLabel !== undefined && longest < s.length) { longest = s.length; longestindex = i; } todo: move to after snapping to borders\n    }\n    function printablesegment(s) {\n      let r = {};\n      for (let k in s) {\n        var _v;\n        let v = s[k];\n        v = ((_v = v) === null || _v === void 0 ? void 0 : _v.__raw) || v;\n        if (typeof v === \"object\") r[k] = JSON.parse(JSON.stringify(v));else r[k] = v;\n      }\n      return r;\n    }\n    let fillSegments = [];\n    this.snapSegmentsToNodeBorders(c, v, ret, fillSegments);\n    let longestLabel = c.data.longestLabel;\n    this.setLabels(c, ret, allNodes);\n    // console.log(\"getSegments() labeled:\", {main:ret, fillSegments});\n    let rett = {\n      all: [...ret, ...fillSegments],\n      segments: ret,\n      fillers: fillSegments\n    };\n    /*switch(bm){\r\n        default: break;\r\n        case EdgeBendingMode.Bezier_QT:\r\n        case EdgeBendingMode.Bezier_CS:\r\n            rett.\r\n    }*/\n    for (let i = 0; i < rett.all.length; i++) {\n      let s = rett.all[i];\n      s.makeD(i, gapMode);\n    }\n    let zoom = new GraphPoint(1, 1);\n    rett.head = this.headPos_impl(c, true, v.edgeHeadSize, rett.segments[rett.segments.length - 1], zoom);\n    rett.tail = this.headPos_impl(c, false, v.edgeTailSize, rett.segments[0], zoom);\n    return rett;\n  }\n  setLabels(c, segments, allNodes) {\n    // find longest segment\n    let longestindex = -1;\n    let longest = 0;\n    for (let i = 0; i < segments.length; i++) {\n      let s = segments[i];\n      s.calcLength();\n      if (longest < s.length) {\n        longest = s.length;\n        longestindex = i;\n      }\n      s.isLongest = false;\n    }\n    if (longestindex >= 0) segments[longestindex].isLongest = true;\n    // apply labels\n    for (let s of segments) s.label = this.get_label_impl(c, s, allNodes, segments);\n  }\n  snapSegmentsToNodeBorders(c, v, ret, fillSegments) {\n    // snap segment start and end to a node border\n    let canCutStart = v.edgeStartStopAtBoundaries,\n      canCutEnd = v.edgeEndStopAtBoundaries;\n    let grid = undefined;\n    // let fillSegments: EdgeSegment[] = [];\n    let gapMode = v.edgeGapMode;\n    let bm = v.bendingMode;\n    let ci;\n    // cut i === 0 is cut regardless of gapmode.\n    if (canCutStart) {\n      ci = GraphSize.closestIntersection(ret[0].start.size, ret[0].start.pt, (ret[0].bezier[0] || ret[0].end).pt, grid);\n      if (ci) ret[0].start.pt = ci;\n      /*\r\n      ret[0].start.pt =\r\n          GraphSize.closestIntersection(ret[0].start.size, ret[0].start.pt, (ret[0].bezier[0] || ret[0].end).pt, grid) as any\r\n          || Geom.closestPoint(ret[0].start.size, ret[0].start.pt);*/\n    }\n\n    // cut middle segments maybe\n    let prev;\n    let curr = ret[0];\n\n    // if (gapMode === EdgeGapMode.gap) return;\n    if (canCutStart || canCutEnd)\n      // do the for below\n      for (let i = 1; i < ret.length; i++) {\n        prev = ret[i - 1];\n        curr = ret[i];\n        let doStartCut, doEndCut;\n        switch (gapMode) {\n          /*\r\n          case EdgeGapMode.arcFill:\r\n          case EdgeGapMode.lineFill:\r\n          case EdgeGapMode.autoFill:\r\n          // same as gap, but will insert 1 more segment to fill the hole\r\n          doStartCut = true;\r\n          doEndCut = true;\r\n          if (prev.end.pt.equals(curr.start.pt)) break;\r\n          fillSegments.push(new EdgeFillSegment(\r\n          prev.end,\r\n          [\r\n          {...prev.end, pt: EdgeSegment.invertLastBezierPt(prev.end.pt, (prev.bezier[prev.bezier.length-1] || prev.start).pt)},\r\n          {...curr.start, pt: EdgeSegment.invertLastBezierPt(curr.start.pt, (curr.bezier[0] || curr.end).pt)}\r\n          ],\r\n          curr.start,\r\n          bm, gapMode, 0, undefined));\r\n          / *\r\n          fillSegments.push(new FillEdgeSegment( // M <start_gap> C <bez1> <bez2> <end_gap>\r\n          // <start_gap> = end of last seg (start of gap) <end_gap> = first of curr seg (end of gap)\r\n          prev.end.pt,\r\n          EdgeSegment.invertLastBezierPt(prev.end.pt, prev.bezier[prev.bezier.length-1].pt || prev.start.pt),\r\n          EdgeSegment.invertLastBezierPt(curr.start.pt, curr.bezier[0].pt || curr.end.pt),\r\n          curr.start.pt)* /\r\n          break;*/\n          case EdgeGapMode.gap:\n            // just snap to vertex edge         prevSegment.endp and ret.startp\n            doEndCut = true;\n            doStartCut = true;\n            break;\n          // average: todo: maybe rename in join (merges start-end at closest pt to both (avg), then snap on edge)\n          case \"closest\":\n            //EdgeGapMode.closest:\n            // does not work properly, i think i need to get next.end instead of curr.end, just disabled for now\n            let nextpt = (curr.bezier[0] || curr.end).pt;\n            let prevpt = (prev.bezier[prev.bezier.length - 1] || prev.start).pt;\n            let midexternalpt = prevpt.add(nextpt, true);\n            let midedgepoint = curr.start.size.tl().add(curr.start.size.br(), false).divide(2, false);\n            // od average between the 2 points before and after that are not part of this edgepoint, then raw a line from there to center of ep, find that intersection.\n            ci = GraphSize.closestIntersection(curr.start.size, midedgepoint, midexternalpt, grid);\n            doEndCut = doStartCut = false;\n            if (canCutEnd && ci) prev.end.pt = ci;\n            if (canCutStart && ci) curr.start.pt = ci;\n            break;\n          case EdgeGapMode.average:\n            // first move to average of the 2 points in the gap, then snap to edge\n            doEndCut = true;\n            doStartCut = true;\n            // indipendent from cutStart, cutEnd.\n            // they merge if just 1 of cutting sides are true. (and if they are both false we don't even enter the for loop)\n            curr.start.pt = curr.start.pt.add(prev.end.pt, false).divide(2, false);\n            prev.end.pt = curr.start.pt.duplicate(); // intentionally not the same pt because during snap to edge they can diverge again.\n            prev.start.uncutPt = prev.start.pt;\n            prev.end.uncutPt = prev.end.pt;\n            break;\n          // center: first move it to center of edgePoint/node, then snap to edge.\n          // this mode might be as well deleted, it can be specified with anchor points\n          case EdgeGapMode.center:\n            doEndCut = false;\n            doStartCut = false;\n            curr.start.pt = curr.start.size.tl().add(curr.start.size.br(), false).divide(2, false);\n            prev.end.pt = curr.start.pt.duplicate(); // intentionally not the same pt because during snap to edge they can diverge again.\n            prev.start.uncutPt = prev.start.pt; // only update them when point moves without being cut (average and center)\n            prev.end.uncutPt = prev.end.pt;\n            break;\n          default:\n            return Log.exDevv(\"unexpected EdgeGapMode:\" + gapMode);\n        }\n        if (canCutStart && doStartCut) {\n          let nextpt = (curr.bezier[0] || curr.end).pt;\n          ci = GraphSize.closestIntersection(curr.start.size, curr.start.pt, nextpt, grid);\n          if (ci) curr.start.pt = ci; // || Geom.closestPoint(curr.start.size, curr.start.pt);\n          //if (gapMode === EdgeGapMode.average && prev) { prev.end.pt = curr.start.pt.add(prev.end.pt, false).divide(2, false); }\n        }\n        if (canCutEnd && doEndCut && prev) {\n          let prevpt = (prev.bezier[prev.bezier.length - 1] || prev.start).pt;\n          ci = GraphSize.closestIntersection(prev.end.size, prev.end.pt, prevpt, grid);\n          if (ci) prev.end.pt = ci; // || Geom.closestPoint(prev.end.size, prev.end.pt);\n          // if average: first do average between start anchor points non-snapped. then i snap both,\n          // then i do average again, and since it might snap out, i get closestPoint to EdgePoint size\n          if (gapMode === EdgeGapMode.average) prev.end.pt = curr.start.pt = Geom.closestPoint(curr.start.size, curr.start.pt.add(prev.end.pt, false).divide(2, false));\n        }\n      }\n    // cut end of last segment regardless of gapMode\n    if (canCutEnd) {\n      let prevendpt = curr.end.pt;\n      ci = GraphSize.closestIntersection(curr.end.size, curr.end.pt, (curr.bezier[curr.bezier.length - 1] || curr.start).pt, grid);\n      if (ci) curr.end.pt = ci; //|| Geom.closestPoint(prev.end.size, prev.end.pt);\n    }\n  }\n  get_edgeEnd(context) {\n    return this.get_edgeEnd_outer(context);\n  }\n  get_edgeEnd_outer(c) {\n    // return this.get_outerGraph(c).translateSize(this.get_edgeEnd_inner(c), this.get_innerGraph(c));\n    return this.get_outerGraph(c).translateSize(this.get_edgeEnd_inner(c), this.get_end(c).innerGraph);\n  }\n  get_edgeEnd_inner(c) {\n    return this.get_edgeStartEnd_inner(c, false);\n    // return context.proxyObject.end?.size || new GraphPoint(0, 0);\n  }\n  get_midnodes(context) {\n    // return LPointerTargetable.wrapAll(context.data.midnodes);\n    return LPointerTargetable.wrapAll(context.data.subElements);\n  }\n  set_midnodes(val, context) {\n    let name = this.get_name(context) || '';\n    TRANSACTION((name.toLowerCase().indexOf('edge') >= 0 ? name : 'Edge: ' + name) + '.midpoints', () => {\n      SetFieldAction.new(context.data.id, \"midnodes\", val, '', true);\n    });\n    return true;\n  }\n  get_endFollow(c) {\n    return c.data.id === LVoidEdge.endFollow;\n  }\n  get_startFollow(c) {\n    return c.data.id === LVoidEdge.startFollow;\n  }\n  // // what in multieditor? needs to be moved in transientstuff?\n  set_endFollow(val, c) {\n    return this._set_start_endFollow(val, c, false);\n  }\n  set_startFollow(val, c) {\n    return this._set_start_endFollow(val, c, true);\n  }\n  _set_start_endFollow(val, c, isStart) {\n    val = !!val;\n    console.log(\"_set_start_endFollow\", {\n      val,\n      c,\n      isStart\n    });\n    if (val) {\n      if (isStart) LVoidEdge.startFollow = c.data.id;else LVoidEdge.endFollow = c.data.id;\n      if (!LVoidEdge.following) {\n        console.log(\"_set_start_endFollow event attached\");\n        document.body.addEventListener(\"mousemove\", LVoidEdge.mousemove_pendingEdge, false);\n        document.body.addEventListener(\"keydown\", LVoidEdge.onKeyDown_pendingEdge, false);\n        LVoidEdge.following = true;\n        LVoidEdge.followingContext = c;\n        LVoidEdge.showAnchors();\n        windoww.Tooltip.show( /*#__PURE__*/_jsxDEV(\"div\", {\n          children: [\"Changing anchor, press \", /*#__PURE__*/_jsxDEV(\"b\", {\n            children: \"Esc\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 2564,\n            columnNumber: 88\n          }, this), \" to undo.\"]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 2564,\n          columnNumber: 60\n        }, this));\n\n        //let selector = \".Edge[nodeid='\" + (LVoidEdge.endFollow || LVoidEdge.startFollow as any)+\"']\";\n        // [...document.querySelectorAll(selector)].map(e=>e.classList.add(\"no-transition-following\")); gets refreshed by react\n        document.body.classList.add(\"no-transition-following\");\n      }\n    } else {\n      if (LVoidEdge.following && (isStart ? LVoidEdge.startFollow : LVoidEdge.endFollow) === c.data.id) {\n        document.body.removeEventListener(\"mousemove\", LVoidEdge.mousemove_pendingEdge, false);\n        document.body.removeEventListener(\"keydown\", LVoidEdge.onKeyDown_pendingEdge, false);\n        let selector = \".Edge[nodeid='\" + (LVoidEdge.endFollow || LVoidEdge.startFollow) + \"']\";\n        //[...document.querySelectorAll(selector)].map(e=>e.classList.remove(\"no-transition-following\"));\n        document.body.classList.remove(\"no-transition-following\");\n        if (isStart) LVoidEdge.startFollow = undefined;else LVoidEdge.endFollow = undefined;\n        LVoidEdge.following = false;\n        const $base = $(document.getElementById(isStart ? c.data.start : c.data.end) || []);\n        if (!$base.length) return true;\n        //const $deepAnchors = $base.find(\"[nodeid] .anchor\");\n        const $anchors = $base.find(\".anchor\"); //.not($deepAnchors);\n        $anchors.removeClass([\"valid-anchor\", \"active-anchor\"]);\n        $base[0].style.overflow = '';\n        windoww.Tooltip.hide();\n      }\n    }\n    //SetFieldAction.new(c.data, \"startFollow\", !!val, '', false);\n    return true;\n  }\n  static getCursorPos(e0) {\n    return new Point(e0.pageX, e0.pageY);\n  }\n  /*public static getGCursorPos(e0: Event): GraphPoint {\r\n      return LVLoidEdge.getCursorPos(e0).subtract(svgsize.tl(), true).multiply(svgzoom) as any as GraphPoint;\r\n  }*/\n  static onKeyDown_pendingEdge(e) {\n    if (e.key === Keystrokes.escape) {\n      const c = LVoidEdge.followingContext;\n      if (!c || !LVoidEdge.startFollow && !LVoidEdge.endFollow) return;\n      let isStart = LVoidEdge.startFollow ? true : false;\n      let l = c.proxyObject;\n      if (isStart) l.startFollow = false;else l.endFollow = false;\n      // l.component?.forceUpdate(); does not work?\n      l.clonedCounter = (l.clonedCounter || 0) + 2;\n    }\n  }\n  static showAnchors() {\n    const c = LVoidEdge.followingContext;\n    if (!c || !LVoidEdge.startFollow && !LVoidEdge.endFollow) return;\n    let isStart = LVoidEdge.startFollow ? true : false;\n    let nodeid = isStart ? c.data.start : c.data.end;\n    let activeAnchor = (isStart ? c.data.anchorStart : c.data.anchorEnd) || 0;\n    const $base = $(document.getElementById(nodeid) || []);\n    if (!$base.length) return;\n    const $deepAnchors = $base.find(\"[nodeid] .anchor\");\n    const $anchors = $base.find(\".anchor\").not($deepAnchors);\n    $anchors.addClass(\"valid-anchor\");\n    $anchors.filter('[data-anchorname=\"' + activeAnchor + '\"]').addClass(\"active-anchor\");\n    $base[0].style.overflow = \"visible\";\n  }\n  static mousemove_pendingEdge(e0) {\n    let forcererendermode = true;\n    if (forcererendermode) {\n      if (!LVoidEdge.following) return;\n      if (!LVoidEdge.canForceUpdate) return;\n      if (LVoidEdge.mousemovei++ % 30 === 0) LVoidEdge.showAnchors();\n      let c = LVoidEdge.followingContext;\n      let g = c.proxyObject.graph;\n      let cursorPos = LVoidEdge.getCursorPos(e0);\n      let gcursorpos = g.translateHtmlSize(cursorPos);\n      // console.log(\"gcursorpos\", {cursorPos:cursorPos.toString(), gcursorpos:gcursorpos.toString(), g});\n      DVoidEdge.isFollowingCoords = gcursorpos;\n      let component = GraphElementComponent.map[LVoidEdge.startFollow || LVoidEdge.endFollow];\n      LVoidEdge.canForceUpdate = false;\n      let timer = setTimeout(() => {\n        LVoidEdge.canForceUpdate = true;\n      }, 5000);\n      let tn = transientProperties.node[c.data.id];\n      for (let vid in tn.viewScores) {\n        // required to truly force an update\n        let tnv = tn.viewScores[vid];\n        tnv.jsxOutput = undefined;\n        tnv.usageDeclarations = undefined;\n        tnv.shouldUpdate = true;\n      }\n      component.setState({\n        forceupdate: new Date().getDate()\n      }, () => {\n        LVoidEdge.canForceUpdate = true;\n        clearTimeout(timer);\n      });\n      // component.forceUpdate(()=>{LVoidEdge.canForceUpdate = true; clearTimeout(timer)});\n      return;\n    }\n    LVoidEdge.tmp++;\n    let selector = \".Edge[nodeid='\" + (LVoidEdge.endFollow || LVoidEdge.startFollow) + \"']\";\n    let root = document.querySelector(selector);\n    if (!root) return;\n    let paths = [...root.querySelectorAll(\"path.full\")];\n    let pathSegments = root.querySelectorAll(\"path.segment.preview\");\n    // if (!paths.length) paths = pathSegments;\n    let pathSegmentContainers = [...new Set([...pathSegments].map(e => e.parentElement))];\n    for (let container of pathSegmentContainers) {\n      let se = [...container.querySelectorAll(\"path.segment.preview\")];\n      paths.push(se[LVoidEdge.endFollow ? se.length - 1 : 0]);\n    }\n    let headTail = [...root.querySelectorAll(LVoidEdge.endFollow ? '.edgeHead' : '.edgeTail')];\n    let cursorPos = LVoidEdge.getCursorPos(e0);\n    let segList;\n    for (let p of paths) {\n      let svg = U.parentUntil(\"svg\", p);\n      let svgsize = Size.of(svg);\n      let svgzoom = new Point(1, 1); // todo: check viewbox and css zoom\n      let gcursorPos = cursorPos.subtract(svgsize.tl(), true).multiply(svgzoom);\n      segList = [...p.getPathData()];\n      let lastSeg = {\n        ...segList[LVoidEdge.endFollow ? segList.length - 1 : 0]\n      };\n      switch (lastSeg.type) {\n        case 'a':\n        case 'A':\n          segList.push('fake new segment to get replaced instead of actual last segment which is A');\n          lastSeg.type = \"L\";\n          lastSeg.values = [gcursorPos.x, gcursorPos.y];\n          break;\n        case \"C\":\n        case \"c\": // bezier curves, keep type just change last point\n        case \"Q\":\n        case \"q\":\n        case \"S\":\n        case \"s\":\n        case \"T\":\n        case \"t\":\n          lastSeg.values[lastSeg.values.length - 2] = gcursorPos.x;\n          lastSeg.values[lastSeg.values.length - 1] = gcursorPos.y;\n          break;\n        case \"M\":\n        case \"m\":\n          lastSeg.type = LVoidEdge.endFollow ? \"L\" : \"M\";\n          lastSeg.values = [gcursorPos.x, gcursorPos.y];\n          break;\n        case \"V\":\n        case \"v\": // stuff forced to become a line\n        case \"H\":\n        case \"h\":\n        case \"L\":\n        case \"l\":\n        case \"Z\":\n        case \"z\":\n          lastSeg.type = \"L\";\n          lastSeg.values = [gcursorPos.x, gcursorPos.y];\n          break;\n      }\n      segList[LVoidEdge.endFollow ? segList.length - 1 : 0] = lastSeg;\n      if (LVoidEdge.tmp % 20 === 0) console.log(\"svg set path data,\", {\n        segList,\n        oldSeglist: p.getPathData(),\n        p\n      });\n      p.setPathData(segList);\n    }\n    for (let ht of headTail) {\n      let svg = U.parentUntil(\"svg\", ht);\n      let svgsize = Size.of(svg);\n      let svgzoom = new Point(1, 1); // todo: check viewbox and css zoom\n      let gcursorPos = cursorPos.subtract(svgsize.tl(), true).multiply(svgzoom);\n      let rotation;\n      let lastPt = segList && segList[LVoidEdge.endFollow ? segList.length - 2 : 1].values;\n      if (lastPt) {\n        let m = gcursorPos.getM(new Point(lastPt[LVoidEdge.endFollow ? lastPt.length - 2 : 1], lastPt[LVoidEdge.endFollow ? lastPt.length - 1 : 0]));\n        if (Number.POSITIVE_INFINITY === m) rotation = Geom.degToRad(90);else if (Number.NEGATIVE_INFINITY === m) rotation = Geom.degToRad(270);else rotation = Math.atan(m);\n        if (lastPt[LVoidEdge.endFollow ? lastPt.length - 2 : 1] > gcursorPos.x) rotation -= Geom.degToRad(180);\n      } else {\n        rotation = 0;\n      }\n      let headSize = Size.of(ht);\n      let headPos = gcursorPos.subtract({\n        x: headSize.w / 2,\n        y: headSize.h / 2\n      }, true); //.subtract({x:Math.cos(rotation)*headSize.w/2, y: -Math.sin(rotation)*headSize.h/2}, true);\n\n      if (LVoidEdge.tmp % 20 === 0) console.log(\"_set_start_endFollow move head\", {\n        selector: LVoidEdge.endFollow ? '.edgeHead' : '.edgeTail',\n        headTail,\n        root\n      });\n      ht.style.transform = 'translate(' + headPos.x + \"px, \" + headPos.y + \"px) rotate(\" + rotation + \"rad)\";\n    }\n  }\n}, _class30.subclasses = [], _class30._extends = [], _class30.startFollow = undefined, _class30.endFollow = undefined, _class30.following = false, _class30.followingContext = void 0, _class30.tmp = 1, _class30.canForceUpdate = true, _class30.mousemovei = 0, _class30)) || _class29);\nRuntimeAccessibleClass.set_extend(DGraphElement, DVoidEdge);\nRuntimeAccessibleClass.set_extend(LGraphElement, LVoidEdge);\nexport let DEdge = (_dec16 = RuntimeAccessible('DEdge'), _dec16(_class31 = (_class32 = class DEdge extends DVoidEdge {\n  constructor() {\n    super(...arguments);\n    this.id = void 0;\n    this.graph = void 0;\n    this.model = void 0;\n    this.isSelected = void 0;\n    this.subElements = void 0;\n    this.state = void 0;\n    this.start = void 0;\n    this.end = void 0;\n    this.__isDEdge = void 0;\n    this.__isDVoidEdge = void 0;\n    this.midnodes = void 0;\n  } // DVoidEdge\n  // static singleton: LGraphElement;\n  // static logic: typeof LGraphElement;\n  // static structure: typeof DGraphElement;\n  // isSelected: Dictionary<DocString<Pointer<DUser>>, boolean> = {};\n  // containedIn!: Pointer<DGraphElement, 0, 1, LGraphElement>;\n}, _class32.subclasses = [], _class32._extends = [], _class32)) || _class31);\nexport let LEdge = (_dec17 = RuntimeAccessible('LEdge'), _dec17(_class33 = (_class34 = class LEdge extends LVoidEdge {\n  constructor() {\n    super(...arguments);\n    this.__raw = void 0;\n    this.id = void 0;\n    this.graph = void 0;\n    this.model = void 0;\n    this.subElements = void 0;\n    this._state = void 0;\n    this.midnodes = void 0;\n    this.__isLEdge = void 0;\n    this.__isLVoidEdge = void 0;\n  } // static singleton: LGraphElement;\n  // static logic: typeof LGraphElement;\n  // static structure: typeof DGraphElement;\n  // isSelected: Dictionary<DocString<Pointer<DUser>>, boolean> = {};\n  isSelected(forUser) {\n    return this.wrongAccessMessage(\"node.isSelected()\");\n  }\n  // containedIn!: LGraphElement;\n\n  // LMap;\n}, _class34.subclasses = [], _class34._extends = [], _class34)) || _class33);\nRuntimeAccessibleClass.set_extend(DVoidEdge, DEdge);\nRuntimeAccessibleClass.set_extend(LVoidEdge, LEdge);\nexport let DExtEdge = (_dec18 = RuntimeAccessible('DExtEdge'), Leaf(_class35 = _dec18(_class35 = (_class36 = class DExtEdge extends DEdge {\n  constructor() {\n    super(...arguments);\n    this.id = void 0;\n    this.graph = void 0;\n    this.model = void 0;\n    this.isSelected = void 0;\n    this.subElements = void 0;\n    this.state = void 0;\n    this.start = void 0;\n    this.end = void 0;\n    this.__isDExtEdge = void 0;\n    this.__isDEdge = void 0;\n    this.__isDVoidEdge = void 0;\n  } // etends DEdge\n  // static singleton: LGraphElement;\n  // static logic: typeof LGraphElement;\n  // static structure: typeof DGraphElement;\n  // isSelected: Dictionary<DocString<Pointer<DUser>>, boolean> = {};\n  // containedIn!: Pointer<DGraphElement, 0, 1, LGraphElement>;\n  /*\r\n      public static new(model: DGraph[\"model\"], parentNodeID: DGraphElement[\"father\"], graphID: DGraphElement[\"graph\"], nodeID?: DGraphElement[\"id\"], size?: GraphSize): DExtEdge {\r\n          return new Constructors(new DExtEdge('dwc')).DPointerTargetable().DGraphElement(model, parentNodeID, graphID, nodeID)\r\n              .DVoidEdge().DEdge().DExtEdge().end();\r\n      }*/\n}, _class36.subclasses = [], _class36._extends = [], _class36)) || _class35) || _class35);\nexport let LExtEdge = (_dec19 = RuntimeAccessible('LExtEdge'), _dec19(_class37 = (_class38 = class LExtEdge extends LEdge {\n  constructor() {\n    super(...arguments);\n    this.__raw = void 0;\n    this.id = void 0;\n    this.graph = void 0;\n    this.model = void 0;\n    this.subElements = void 0;\n    this._state = void 0;\n    this.start = void 0;\n    this.end = void 0;\n    this.__isLExtEdge = void 0;\n    this.__isLEdge = void 0;\n    this.__isLVoidEdge = void 0;\n  } // static singleton: LGraphElement;\n  // static logic: typeof LGraphElement;\n  // static structure: typeof DGraphElement;\n  // isSelected: Dictionary<DocString<Pointer<DUser>>, boolean> = {};\n  isSelected(forUser) {\n    return this.wrongAccessMessage(\"node.isSelected()\");\n  }\n  // containedIn!: LGraphElement;\n\n  // LMap;\n}, _class38.subclasses = [], _class38._extends = [], _class38)) || _class37);\nRuntimeAccessibleClass.set_extend(DEdge, DExtEdge);\nRuntimeAccessibleClass.set_extend(LEdge, LExtEdge);\nexport let DRefEdge = (_dec20 = RuntimeAccessible('DRefEdge'), Leaf(_class39 = _dec20(_class39 = (_class40 = class DRefEdge extends DEdge {\n  constructor() {\n    super(...arguments);\n    this.start = void 0;\n    this.end = void 0;\n    this.isSelected = void 0;\n    this.__isDRefEdge = void 0;\n  } // extends DEdge\n  /*\r\n      public static new(model: DGraph[\"model\"], parentNodeID: DGraphElement[\"father\"], graphID: DGraphElement[\"graph\"], nodeID?: DGraphElement[\"id\"]): DRefEdge {\r\n          return new Constructors(new DRefEdge('dwc')).DPointerTargetable().DGraphElement(model, parentNodeID, graphID, nodeID)\r\n              .DVoidEdge().DEdge().DRefEdge().end();\r\n      }*/\n}, _class40.subclasses = [], _class40._extends = [], _class40)) || _class39) || _class39);\nexport let LRefEdge = (_dec21 = RuntimeAccessible('LRefEdge'), _dec21(_class41 = (_class42 = class LRefEdge extends LEdge {\n  constructor() {\n    super(...arguments);\n    this.start = void 0;\n    this.end = void 0;\n    this.__isLRefEdge = void 0;\n  } // __raw!: DRefEdge;\n}, _class42.subclasses = [], _class42._extends = [], _class42)) || _class41);\nRuntimeAccessibleClass.set_extend(DEdge, DRefEdge);\nRuntimeAccessibleClass.set_extend(LEdge, LRefEdge);\n// for edges without a modelling element\n\n/*\r\n\r\nlet a = `DExtEdge, DRefEdge, DVoidEdge, LGraphVertex, LRefEdge, LEdgePoint, DVoidVertex, DGraphVertex, DEdgePoint,\r\n DVertex, DEdge, LVertex, LGraph, DGraph, LVoidVertex, LVoidEdge, LEdge, LGraphElement, LExtEdge, DGraphElement`;\r\n  // // ... get from export in index.ts\r\na = a.replaceAll(',,', \",\")\r\nlet aa = a.split(\",\").map(a => a.trim().substring(1));\r\n\r\nfunction onlyUnique(value, index, self) { return self.indexOf(value) === index; }\r\n\r\naa = aa.filter(onlyUnique).filter( a=> !!a)\r\nlet r = aa.filter(onlyUnique).filter( a=> !!a).map( a=> `export type W${a} = getWParams<L${a}, D${a}>;`).join('\\n')\r\ndocument.body.innerText = r;\r\n*/\n\n// getWParams<LGraphVertex, DGraphVertex>;\n\nconsole.warn('ts loading graphDataElement');","map":{"version":3,"names":["isDeepStrictEqual","Constructors","CoordinateMode","Debug","DPointerTargetable","DUser","EdgeBendingMode","GraphElementComponent","GraphPoint","GraphSize","IPoint","Keystrokes","L","Leaf","Log","LPointerTargetable","MixOnlyFuncs","Node","Point","Pointers","RuntimeAccessible","RuntimeAccessibleClass","SetFieldAction","SetRootFieldAction","ShortAttribETypes","Size","store","TargetableProxyHandler","TRANSACTION","transientProperties","U","Uarr","UX","windoww","EdgeGapMode","Geom","ISize","jsxDEV","_jsxDEV","console","warn","DGraphElement","_dec","_class","_class2","constructor","arguments","id","graph","model","isSelected","subElements","state","father","x","y","zIndex","w","h","view","favoriteNode","edgesIn","edgesOut","anchors","new","htmlindex","parentNodeID","graphID","nodeID","a","b","undefined","end","nodeLFromHtml","target","fromPointer","nodePtrFromHtml","nodeDFromHtml","attributes","nodeid","value","parentElement","graphLFromHtml","graphPtrFromHtml","graphDFromHtml","graphid","subclasses","_extends","LGraphElement","_dec2","_class3","_class4","__raw","_state","width","height","z","__info_of__z__","type","EInt","txt","__info_of__zIndex__","zoom","html","__info_of__html","size","position","htmlSize","htmlPosition","component","vertex","__info_of__vertex","__info_of__favoriteNode","EBoolean","startPoint","endPoint","__info_of__startPoint","children","fileName","_jsxFileName","lineNumber","columnNumber","__info_of__endPoint","__info_of__graph","innerGraph","__info_of__innnerGraph","outerGraph","__info_of__outerGraphGraph","root","__info_of__root","rendered","__info_of__rendered","visible","__info_of__visible","firstRenderedNode","__info_of__firstRenderedNode","name","__info_of__graphAncestors","graphAncestors","__info_of__anchors","__info_of__edgesIn","__info_of__edgesOut","__info_of__edgesStart","__info_of__edgesEnd","outerSize","__info_of__outerSize","innerSize","__info_of__innerSize","__info_of__size","nodes","__info_of__nodes","edges","__info_of__edges","graphs","__info_of__graphs","allSubNodes","__info_of__allSubNodes","allSubEdges","__info_of__allSubEdges","allSubGraphs","__info_of__allSubGraphs","__info_of__subElements","allSubElements","__info_of__allSubElements","assignEdgeAnchor","__info_of__assignEdgeAnchor","__info_of__isselected","__info_of__select","__info_of__deselect","__info_of__toggleSelect","__info_of__isSelected","getNodeId","o","_node","node","extends","className","from","get_graph","context","get_innerGraph","get_root","get_outerGraph","get_rendered","c","get_html","get_visible","isElementInViewport","get_firstRenderedNode","arr","proxyObject","findInChildProperties","e","get_name","_this$get_model","data","get_model","get_anchors","set_anchors","v","Array","isArray","ee","ka","kk","isNaN","get_edgesIn","fromArr","get_edgesOut","set_edgesIn","val","set_edgesOut","get_edgesStart","get_edgesEnd","set_edgesStart","set_edgesEnd","_defaultGetter","k","__defaultGetter","get_view","_defaultSetter","__defaultSetter","get_graphAncestors","current","next","ret","DGraph","cname","push","wrap","get_vertex","lcurrent","dcurrent","DVertex","DVoidVertex","DGraphVertex","fromD","exDev","_LPointerTargetable$f","exDevv","cdata","_dcurrent","get_x","get_size","set_x","set_size","get_y","set_y","get_w","set_w","get_h","set_h","get_width","set_width","get_height","set_height","get_position","set_position","printDiff","get_sizeold","get_component","map","_transientProperties$","_transientProperties$2","_this$get_component","_this$get_component$p","mainView","r","props","set_view","eDevv","getSize","outer","length","canTriggerSet","wrongAccessMessage","get_getSize","_this","get_innerSize","get_outerSize","get_innerSize_impl","_this$get_component2","_this$get_component2$","lightMode","DEdge","DVoidEdge","nosize","coord","get_htmlSize","DEdgePoint","def","defaultVSize","currentCoordType","decodePosCoords","translateSize","actualSize","of","isOldElement","clonedCounter","dataset","clonedcounter","updateSize","adaptWidth","adaptHeight","size0","testmode","absolute","encodePosCoords","epdata","document","getElementById","set_html","cannotSet","set_htmlSize","get_htmlPosition","tl","set_htmlPosition","get_zIndex","set_zIndex","_val","get_z","set_z","get_nodes","get_subElements","filter","indexOf","set_nodes","get_edges","set_edges","get_graphs","set_graphs","get_allSubNodes","get_allSubElements","set_allSubNodes","get_allSubEdges","set_allSubEdges","get_allSubGraphs","set_allSubGraphs","Set","set_subElements","log","eDev","pointers","equals","idlookup","getState","arrdiff","arrayDifference","oldsubelementid","removed","subelement","newsubelementid","added","tocheck","checked","dblcheck","newtocheck","ptr","fistContainer","subnode","se","arrayMergeInPlace","Object","keys","set_allSubElements","get_isResized","isResized","set_isResized","modelElementId","lModelElement","get_assignEdgeAnchor","anchorName","LVoidEdge","startFollow","de","start","le","anchorStart","endFollow","anchorEnd","get_events","tn","mainview","otherViews","stackViews","allviews","reverse","keep_for_closure_original_funcs","dv","objectMergeInPlace","events","lastContext","viewScores","evalContext","_len","_params","_key","get_father","set_father","select","forUser","deselect","toggleSelected","get_select","duser","get_deselect","get_toggleSelected","get_isSelected","set_isSelected","get_startPoint","get_startEndPoint","get_endPoint","isStart","offset","isPercentage","add","set_extend","_dec3","_class5","_class6","parentgraphID","DGraph_makeID","getNodes","dmp","out","$allnodes","$","matchedids","d","matchedidmap","objectFromArrayValues","allnodesarr","filternode","_d$dataset","_d$dataset2","dataid","$matched","$notMatched","n","defaultEdgePointSize","defaultVertexSize","LGraph","_dec4","_class7","_class8","graphSize","cumulativeZoom","__info_of__cumulativeZoom","ownZoom","__info_of__ownZoom","label","__info_of__zoom","__info_of__offset","__info_of__graphSize","__info_of__translateSize","__info_of__translateHtmlSize","screenOffset","__info_of__screenOffset","get_offset","set_offset","stringify","get_cumulativeZoom","ancestors","g","multiply","get_zoom","get_ownZoom","set_zoom","toGraphSize","get_coord","graphHtmlSize","translateHtmlSize","get_translateHtmlSize","rootGraph","get_translateHtmlSize_fromRoot","fakeRootSize","translateHtmlSize_fromRoot","get_screenOffset","divide","subtract","get_translateSize","graph_of_size","targetGraph","currGraph","currAncestors","targetAncestors","currAncestorsPtr","l","targetAncestorsPtr","ex","i","commonAncestor","slice","get_translateSize_down_old","hasOwnProperty","contains","elem","get_contains","targetid","_dec5","_class9","_class10","LVoidVertex","_dec6","_class11","_class12","_dec7","_class13","_class14","__isDEdgePoint","LEdgePoint","_dec8","_class15","_class16","__isLEdgePoint","edge","__info_of__edge","get_edge","set_edge","decodeCoords","sp","ep","mode","relativePercent","relativeOffset","relativeOffsetStart","relativeOffsetEnd","useStart","useEnd","xIsAbsolute","yIsAbsolute","offsetsp","offsetep","sp0","ep0","testCoords","range","j","s0","s1","encodeCoords","s00","error","toFixed","join","diff","edgePointCoordMode","_dec9","_class17","_class18","__isDVertex","LVertex","_dec10","_class19","_class20","__isLVertex","_dec11","_class21","_class22","__isDGraph","__isDGraphVertex","LG","LV","Mixed","LGraphVertex","_dec12","_class23","_class24","__isLGraph","__isLGraphVertex","_dec13","_class25","_class26","__isDVoidEdge","midPoints","midnodes","longestLabel","labels","isExtend","isReference","isValue","isDependency","new2","setter","isFollowingCoords","EdgeSegment","_dec14","_class27","mid","svgLetter","gapMode","index","prevSegment","prev","bezier","dpart","m","rad","radLabels","isLongest","Bezier_QT","addBezierPoint","Bezier_CS","Line","Bezier_quadratic","Bezier_cubic","Elliptical_arc","prevedgemakerbezier","mirroredBezier","pt","invertLastBezierPt","uncutPt","makeD","getM","mToRad","Math","atan","bezierpts","finalpart","p","bezierptsUncut","finalpartUncut","bendingMode","vector","calcLength","distanceFromPoint","EdgeFillSegment","center","average","gap","_dec15","_class29","_class30","__isLVoidEdge","allNodes","__info_of__allNodes","__info_of__longestLabel","readType","writeType","__info_of__label","__info_of__labels","__info_of__start","__info_of__end","segments","segments_inner","segments_outer","__info_of__segments","__info_of__d","EString","__info_of__anchorStart","isEdge","__info_of__anchorEnd","__info_of__endFollow","__info_of__startFollow","get_start","set_start","exx","toLowerCase","get_end","set_end","get_label","get_longestLabel","set_label","set_longestLabel","get_labels","set_labels","headPos_impl","isHead","headSize0","segment0","zoom0","segment","get_segments","tmp","edgeHeadSize","edgeTailSize","headPos","useBezierPoints","x4headsize","secondIntersection","segmentDistance","sqrt","safeDistance","max","closestIntersection","tailPos","get_headPos","headSize","get_tailPos","get_allNodes","get_midnodes","get_midPoints","addMidPoint","get_addMidPoint","impl_addMidPoints","set_midPoints","get_label_impl","key","labelmaker","labelmakerfunc","get_startPoint_Outer","get_endPoint_Outer","get_startPoint_inner","get_endPoint_inner","get_edgeStartEnd_inner","svgLetterSize","s","addM","doublingMidPoints","first","others","get_points_impl","getAnchorOffset","$factor","innermost","all","flatMap","ge","dge","base","rets","rete","debug","anchor_e","anchor_s","anchor","edgeStartOffset","edgeStartOffset_isPercentage","seg","get_pointsDebug","get_points","get_points_outer","get_d","get_segments_outer","get_segments_impl","bm","edgeGapMode","segmentSize","increase","endindex","printablesegment","_v","JSON","parse","fillSegments","snapSegmentsToNodeBorders","setLabels","rett","fillers","head","tail","longestindex","longest","canCutStart","edgeStartStopAtBoundaries","canCutEnd","edgeEndStopAtBoundaries","grid","ci","curr","doStartCut","doEndCut","nextpt","prevpt","midexternalpt","midedgepoint","br","duplicate","closestPoint","prevendpt","get_edgeEnd","get_edgeEnd_outer","get_edgeEnd_inner","wrapAll","set_midnodes","get_endFollow","get_startFollow","set_endFollow","_set_start_endFollow","set_startFollow","following","body","addEventListener","mousemove_pendingEdge","onKeyDown_pendingEdge","followingContext","showAnchors","Tooltip","show","classList","removeEventListener","selector","remove","$base","$anchors","find","removeClass","style","overflow","hide","getCursorPos","e0","pageX","pageY","escape","activeAnchor","$deepAnchors","not","addClass","forcererendermode","canForceUpdate","mousemovei","cursorPos","gcursorpos","timer","setTimeout","vid","tnv","jsxOutput","usageDeclarations","shouldUpdate","setState","forceupdate","Date","getDate","clearTimeout","querySelector","paths","querySelectorAll","pathSegments","pathSegmentContainers","container","headTail","segList","svg","parentUntil","svgsize","svgzoom","gcursorPos","getPathData","lastSeg","values","oldSeglist","setPathData","ht","rotation","lastPt","Number","POSITIVE_INFINITY","degToRad","NEGATIVE_INFINITY","transform","_dec16","_class31","_class32","__isDEdge","LEdge","_dec17","_class33","_class34","__isLEdge","DExtEdge","_dec18","_class35","_class36","__isDExtEdge","LExtEdge","_dec19","_class37","_class38","__isLExtEdge","DRefEdge","_dec20","_class39","_class40","__isDRefEdge","LRefEdge","_dec21","_class41","_class42","__isLRefEdge"],"sources":["C:/0Programmi/Dev/projects/frontend/jjodel/frontend/src/model/dataStructure/GraphDataElements.tsx"],"sourcesContent":["// import {Mixin} from \"ts-mixer\";\r\nimport {isDeepStrictEqual} from \"util\";\r\nimport {\r\n    Constructors,\r\n    CoordinateMode,\r\n    Debug,\r\n    Dictionary,\r\n    DModelElement,\r\n    DocString,\r\n    DPointerTargetable,\r\n    DState,\r\n    DUser,\r\n    DViewElement,\r\n    EdgeBendingMode,\r\n    EPSize,\r\n    getWParams,\r\n    GObject,\r\n    GraphElementComponent,\r\n    GraphPoint,\r\n    GraphSize,\r\n    Info, IPoint, Keystrokes, L,\r\n    Leaf,\r\n    LModelElement,\r\n    Log,\r\n    LogicContext,\r\n    LPointerTargetable,\r\n    LViewElement,\r\n    MixOnlyFuncs,\r\n    Node, orArr,\r\n    Pack1,\r\n    PackArr,\r\n    Point,\r\n    Pointer,\r\n    Pointers,\r\n    PrimitiveType,\r\n    RuntimeAccessible,\r\n    RuntimeAccessibleClass,\r\n    SetFieldAction, SetRootFieldAction,\r\n    ShortAttribETypes,\r\n    Size,\r\n    store,\r\n    TargetableProxyHandler, TRANSACTION,\r\n    transientProperties,\r\n    U,\r\n    Uarr, UX,\r\n    windoww\r\n} from \"../../joiner\";\r\nimport type {Tooltip} from \"../../components/forEndUser/Tooltip\";\r\nimport type {RefObject} from \"react\";\r\nimport type {SVGPathElementt, SVGPathSegment} from '../../common/libraries/pathdata';\r\nimport {EdgeGapMode, InitialVertexSize} from \"../../joiner/types\";\r\nimport {Geom, ISize} from \"../../common/Geom\";\r\n\r\n\r\nconsole.warn('ts loading graphDataElement');\r\n\r\n@Node\r\n@RuntimeAccessible('DGraphElement')\r\nexport class DGraphElement extends DPointerTargetable {\r\n    // static _super = DPointerTargetable;\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // static singleton: LGraphElement;\r\n    // static logic: typeof LGraphElement;\r\n    // static structure: typeof DGraphElement;\r\n    id!: Pointer<DGraphElement, 1, 1, LGraphElement>;\r\n    graph!: Pointer<DGraph, 1, 1, LGraph>;\r\n    model?: Pointer<DModelElement, 0, 1, LModelElement>;\r\n    isSelected!: Dictionary<DocString<Pointer<DUser>>, boolean>;\r\n    // containedIn!: Pointer<DGraphElement, 0, 1, LGraphElement>;\r\n    subElements!: Pointer<DGraphElement, 0, 'N', LGraphElement>;\r\n    state!: GObject; // DMap\r\n    father!: Pointer<DGraphElement, 1, 1, LGraphElement>;\r\n    x!: number;\r\n    y!: number;\r\n    zIndex: number = 100;\r\n    w!: number;\r\n    h!: number;\r\n    // width: number = 300;\r\n    // height: number = 400;\r\n    view!: Pointer<DViewElement, 1, 1, LViewElement>;\r\n    favoriteNode!: boolean;\r\n    edgesIn!: Pointer<DEdge>[];\r\n    edgesOut!: Pointer<DEdge>[];\r\n    anchors!: Dictionary<string, GraphPoint/* as % of node size.*/>;\r\n\r\n\r\n    public static new(htmlindex: number, model: DGraphElement[\"model\"]|null|undefined, parentNodeID: DGraphElement[\"father\"],\r\n                      graphID: DGraphElement[\"graph\"], nodeID?: DGraphElement[\"id\"]|undefined, a?: any, b?:any, ...c:any): DGraphElement {\r\n        return new Constructors(new DGraphElement('dwc'), parentNodeID, true, undefined, nodeID)\r\n            .DPointerTargetable()\r\n            .DGraphElement(model, graphID, htmlindex).end();\r\n    }\r\n\r\n    static nodeLFromHtml(target?: Element | null): LGraphElement | undefined { return LPointerTargetable.fromPointer(DGraphElement.nodePtrFromHtml(target) as Pointer); }\r\n    static nodeDFromHtml(target?: Element | null): DGraphElement | undefined { return DPointerTargetable.fromPointer(DGraphElement.nodePtrFromHtml(target) as Pointer); }\r\n    static nodePtrFromHtml(target?: Element | null): Pointer<DGraphElement> | undefined {\r\n        while (target) {\r\n            if ((target.attributes as any).nodeid) return (target.attributes as any).nodeid.value;\r\n            target = target.parentElement;\r\n        }\r\n        return undefined;\r\n    }\r\n    static graphLFromHtml(target?: Element | null): LGraph | undefined { return LPointerTargetable.fromPointer(DGraphElement.graphPtrFromHtml(target) as Pointer); }\r\n    static graphDFromHtml(target?: Element | null): DGraph | undefined { return DPointerTargetable.fromPointer(DGraphElement.graphPtrFromHtml(target) as Pointer); }\r\n    static graphPtrFromHtml(target?: Element | null): Pointer<DGraph> | undefined {\r\n        while (target) {\r\n            if ((target.attributes as any).graphid) return (target.attributes as any).graphid.value;\r\n            target = target.parentElement;\r\n        }\r\n        return undefined;\r\n    }\r\n}\r\n@RuntimeAccessible('LGraphElement')\r\nexport class LGraphElement<Context extends LogicContext<DGraphElement> = any, C extends Context = Context> extends LPointerTargetable {\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static getNodeId<L extends LGraphElement, D extends DGraphElement>(o?:L | D | Pointer<D> | LModelElement | DModelElement | Pointer<DModelElement>): Pointer<D> {\r\n        if (!o) return undefined as any;\r\n        let node: any = o;\r\n        // from L to D\r\n        // let cname = (node.__raw || node).className;\r\n        // from DModelE to LGraphE\r\n        if (RuntimeAccessibleClass.extends((o as any).className, \"DModelElement\")) node = LPointerTargetable.from(o as DModelElement).node as LGraphElement;\r\n        return (typeof node === \"string\") ? node : node?.id;\r\n    }\r\n    // static singleton: LGraphElement;\r\n    // static logic: typeof LGraphElement;\r\n    // static structure: typeof DGraphElement;\r\n    __raw!: DGraphElement;\r\n    id!: Pointer<DGraphElement, 1, 1, LGraphElement>;\r\n    father!: LGraphElement;\r\n    model?: LModelElement;\r\n    // protected isSelected!: Dictionary<DocString<Pointer<DUser>>, boolean>; //  & ((forUser?: Pointer<DUser>) => boolean);\r\n\r\n    // containedIn?: LGraphElement;\r\n    _state!: GObject<\"proxified\">; // LMap;\r\n    x!: number;\r\n    y!: number;\r\n    width!: number;\r\n    height!: number\r\n\r\n    z!:number;\r\n    zIndex!: number;\r\n    __info_of__z__: Info = {type:ShortAttribETypes.EInt, txt: \"alias for zIndex\"};\r\n    __info_of__zIndex__: Info = {type:ShortAttribETypes.EInt,\r\n        txt: \"Determine the z-axis priority of the element.<br/>Higher value tende to overlap other elements.<br/>Lower value tends to be on background.\"};\r\n    zoom!: GraphPoint;\r\n    html?: Element;\r\n    __info_of__html: Info = {type: 'HTMLElement', txt:'The DOM element generated by this node.'}\r\n\r\n    // fittizi\r\n    w!:number;\r\n    h!:number;\r\n    size!: GraphSize;\r\n    position!: GraphPoint;\r\n    htmlSize!: Size; // size and position in global document coordinates.\r\n    htmlPosition!: Point;\r\n    view!: LViewElement;\r\n    component!: GraphElementComponent;\r\n    favoriteNode!: boolean;\r\n    vertex?: LVoidVertex;\r\n    __info_of__vertex: Info = {type: \"LVoidVertex\", txt: \"the foremost vertex containing this graphElement, or undefiened.\"}\r\n    __info_of__favoriteNode: Info = {type: ShortAttribETypes.EBoolean,\r\n        txt: \"<span>Indicates this is the primarly used (by default) node to refer to a modelling element that might have multiple representations.\" +\r\n            \"<br> Can be used as favorite target for edges or other.\"}\r\n\r\n    startPoint!: GraphPoint;\r\n    endPoint!: GraphPoint;\r\n    __info_of__startPoint: Info = {type: \"GraphPoint\", txt:<span>Where the outgoing edges should start their paths.\r\n            <br/>Obtained by combining anchoring point offset specified in view, before snapping to a Vertex border.\r\n            <br/>Defaults in outer coordinates.</span>};\r\n    __info_of__endPoint: Info = {type: \"GraphPoint\", txt:<span>Where the incoming edges should end their paths.\r\n            <br/>Obtained by combining anchoring point offset specified in view, before snapping to a Vertex border.\r\n            <br/>Defaults in outer coordinates.</span>};\r\n\r\n    graph!: LGraph | LGraphVertex;\r\n    __info_of__graph: Info = {type:\"LGraph | LGraphVertex\", txt:\"Alias for innerGraph\"};\r\n    get_graph(context: Context): LGraph | LGraphVertex { return this.get_innerGraph(context); }\r\n    innerGraph!: LGraph|LGraphVertex;\r\n    __info_of__innnerGraph: Info = {type:\"LGraph | LGraphVertex\", txt:\"Gets the nearest-level graph (it might be a Sub-graph like a package usually is)\"};\r\n    outerGraph!: LGraph;\r\n    __info_of__outerGraphGraph: Info = {type:\"LGraph\", txt:\"Gets the root-level graph\"};\r\n    root!: LGraph;\r\n\r\n    __info_of__root: Info = {type:\"LGraph\", txt:\"Alias for outerGraph\"};\r\n    get_root(context: Context): LGraph { return this.get_outerGraph(context); }\r\n\r\n    rendered!: boolean;\r\n    __info_of__rendered: Info = {type: 'boolean', txt:'If the node is currently displayed somewhere in the graph.'}\r\n    get_rendered(c: Context): this[\"rendered\"] { return !!this.get_html(c);}\r\n    visible!: boolean;\r\n    __info_of__visible: Info = {type: 'boolean', txt:'If the node is currently visible on the user screen.'}\r\n    get_visible(c: Context): this[\"visible\"] { return UX.isElementInViewport(this.get_html(c)); }\r\n    firstRenderedNode!: LGraphElement;\r\n    __info_of__firstRenderedNode:Info={type: 'LGraphElement', txt: \"The first currently rendered node in the collection: [this.node, this.father.node, this.father.father.node , ...]\"};\r\n    protected get_firstRenderedNode(c: Context): this[\"firstRenderedNode\"] {\r\n        let arr = [c.proxyObject];\r\n        return U.findInChildProperties(arr, (e)=>[e.father], undefined, (e)=>e.rendered);\r\n    }\r\n    name!:string;\r\n    public get_name(c: Context): string{ return c.data.model && this.get_model(c)?.name || (c.data as any).name || c.data.className; }\r\n    /*firstRenderedNodes!: LGraphElement;\r\n    __info_of__firstRenderedNodes:Info={type: 'LGraphElement', txt: \"The first currently rendered node in the collection: [this.nodes, this.father.nodes, this.father.father.nodes , ...]\"};\r\n    protected get_firstRenderedNodes(c: Context): this[\"firstRenderedNodes\"] {\r\n        let arr = this.get_nodes(c);\r\n        // return U.findInChildProperties(arr, (e)=>e.model.father.nodes, undefined, (e)=>e.rendered);\r\n        return U.findInChildProperties(arr, (e)=>[e.father], undefined, (e)=>e.rendered);\r\n    }*/\r\n\r\n\r\n    __info_of__graphAncestors: Info = {type:\"LGraph[]\",\r\n        txt:\"<span>collection of the stack of Graphs containing the current element where [0] is the most nested graph, and last is root graph.</span>\"};\r\n    graphAncestors!: LGraph[];\r\n\r\n    anchors!: Dictionary<string, GraphPoint/* as % of node size.*/>;\r\n    __info_of__anchors: Info = {type:\"Dictionary<string, point>\", txt: <div>A named list of all anchor points where edges are allowed to land or depart from.<br/>\r\n            {/*When reading it is in absolute sizes.<br/>*/}\r\n            When writing it must be done in percentages, with the same rules as node.state.</div>}\r\n    get_anchors(c: Context): this[\"anchors\"]{ return c.data.anchors; }\r\n    set_anchors(v: this[\"anchors\"], c: Context):boolean{\r\n        if (v !== undefined && (typeof v !== \"object\" || Array.isArray(v))){\r\n            Log.ee('cannot set anchors: invalid value provided');\r\n            return true;\r\n        }\r\n        if (v){ // if !v it means clear all anchors?\r\n            for (let ka in v){//for each anchor\r\n                if (!v[ka]) continue;\r\n\r\n                if (c.data.anchors[ka]) {\r\n                    for (let kk in v[ka]) { //for each key within an anchor (x, y, w, h)\r\n                        // if i was attempting to set a partial size, complete it with the old size values.\r\n                        if ((v[ka][kk] === undefined) && (c.data.anchors[ka][kk] !== undefined)) v[ka][kk] = c.data.anchors[ka][kk];\r\n                    }\r\n                }\r\n                if (v[ka].x === undefined || isNaN(v[ka].x)) v[ka].x = 0.5;\r\n                if (v[ka].y === undefined || isNaN(v[ka].y)) v[ka].y = 0.5;\r\n                // if (v[ka].w === undefined || isNaN(v[ka].w)) v[ka].w = 5;\r\n                // if (v[ka].h === undefined || isNaN(v[ka].h)) v[ka].h = 5;\r\n            }\r\n        }\r\n        TRANSACTION(this.get_name(c)+'.anchors', ()=> {\r\n            SetFieldAction.new(c.data, \"anchors\", v, '', false)\r\n        });\r\n        return true; }\r\n\r\n    edgesIn!: LVoidEdge[];\r\n    edgesOut!: LVoidEdge[];\r\n    __info_of__edgesIn: Info = {type:\"LEdge[]\", txt:<div>Edges incoming into this element. <code>this.edgesOut[i].end</code> always equals to <code>this</code>.</div>}\r\n    __info_of__edgesOut: Info = {type:\"LEdge[]\", txt:<div>Edges outgoing from this element. <code>this.edgesIn[i].start</code> always equals to <code>this</code>.</div>}\r\n    __info_of__edgesStart: Info = {type:\"LEdge[]\", txt:<div>Alias for this.edgesOut</div>}\r\n    __info_of__edgesEnd: Info = {type:\"LEdge[]\", txt:<div>Alias for this.edgesIn</div>}\r\n    public get_edgesIn(context: Context): this[\"edgesIn\"] { return LPointerTargetable.fromArr(context.data.edgesIn); }\r\n    public get_edgesOut(context: Context): this[\"edgesOut\"]  { return LPointerTargetable.fromArr(context.data.edgesOut); }\r\n    public set_edgesIn(val: PackArr<LVoidEdge>, c: Context): boolean {\r\n        TRANSACTION(this.get_name(c)+'edgesIn', ()=> {\r\n            SetFieldAction.new(c.data.id, \"edgesIn\", Pointers.fromArr(val), '', true);\r\n        })\r\n        return true;\r\n\r\n    }\r\n    public set_edgesOut(val: PackArr<LVoidEdge>, c: Context): boolean {\r\n        TRANSACTION(this.get_name(c)+'.edgesOut', ()=> {\r\n            SetFieldAction.new(c.data.id, \"edgesOut\", Pointers.fromArr(val), '', true);\r\n        })\r\n        return true;\r\n    }\r\n    public get_edgesStart(context: Context): this[\"edgesIn\"]  { return this.get_edgesIn(context); }\r\n    public get_edgesEnd(context: Context): this[\"edgesOut\"]  { return this.get_edgesOut(context); }\r\n    public set_edgesStart(val: PackArr<LVoidEdge>, context: Context): boolean { return this.set_edgesIn(val, context); }\r\n    public set_edgesEnd(val: PackArr<LVoidEdge>, context: Context): boolean { return this.set_edgesOut(val, context); }\r\n\r\n\r\n    protected _defaultGetter(c: Context, k: keyof Context[\"data\"]): any {\r\n        if (k in c.data) return this.__defaultGetter(c, k);\r\n        // if value not found in node, check in view.\r\n        return (this.get_view(c) as any)[k];\r\n        /*let ret: any;\r\n        let view = this.get_view(c);\r\n        try { ret = (view as any)[k] } catch (e) { Log.ee(\"Could not find get_ property \\\"\" + k + \"\\\" in node or view.\", {c, view, k}); return undefined; }\r\n        return ret;*/\r\n    }\r\n\r\n    protected _defaultSetter(v: any, c: Context, k: keyof Context[\"data\"]): true {\r\n        this.__defaultSetter(v, c, k);\r\n        return true;\r\n    }\r\n\r\n    get_graphAncestors(c: Context): LGraph[] {\r\n        let current = c.proxyObject;\r\n        let next = current.father;\r\n        let ret: LGraph[] = [];\r\n        while(next) {\r\n            if (RuntimeAccessibleClass.extends(next.className, DGraph.cname)) ret.push(next as LGraph);\r\n            if (current.id === next.id) break;\r\n            current = next;\r\n            next = next.father;\r\n        }\r\n        return ret;\r\n    }\r\n    get_outerGraph(context: Context): LGraph {\r\n        // todo: this relies on the fact that GraphVertex are not passing their own id to their childrens, but the parent graph id\r\n        return TargetableProxyHandler.wrap(context.data.graph);\r\n    }\r\n    get_vertex(context: Context): this[\"vertex\"] {\r\n        let lcurrent: LGraphElement = LPointerTargetable.fromPointer(context.data.id);\r\n        let dcurrent = lcurrent.__raw;\r\n        // iterate parents.\r\n        while(dcurrent){\r\n            switch(dcurrent.className){\r\n                case DVertex.cname:\r\n                case DVoidVertex.cname:\r\n                case DGraphVertex.cname: return (lcurrent || LPointerTargetable.fromD(dcurrent)) as LVoidVertex;\r\n                default:\r\n                    if (!dcurrent.father || dcurrent.id === dcurrent.father) return undefined;\r\n                    Log.exDev(!dcurrent.father || dcurrent.id === dcurrent.father, \"node failed to get containing vertex\", context.data, dcurrent, lcurrent);\r\n                    lcurrent = LPointerTargetable.fromPointer(dcurrent.father);\r\n                    dcurrent = lcurrent.__raw;\r\n            }\r\n        }\r\n        return undefined;\r\n    }\r\n\r\n    get_innerGraph(context: Context): LGraph {\r\n        let dcurrent = DPointerTargetable.fromPointer(context.data.father);\r\n\r\n        // if no parent, but it's a graph, return itself.\r\n        if (!dcurrent) {\r\n            dcurrent = context.data;\r\n            switch(dcurrent.className){\r\n                case DGraph.cname:\r\n                case DGraphVertex.cname: return (LPointerTargetable.fromD(dcurrent)) as LGraph;\r\n                default: return Log.exDevv(\"root node failed to get containing graph\", {cdata:context.data, dcurrent});\r\n            }\r\n        }\r\n\r\n        // if it have a parent, iterate parents.\r\n        while(true){\r\n            switch(dcurrent?.className){\r\n                case DGraph.cname:\r\n                case DGraphVertex.cname: return (LPointerTargetable.fromD(dcurrent)) as LGraph;\r\n                default:\r\n                    Log.exDev(!dcurrent.father, \"node failed to get containing graph\", {cdata:context.data, dcurrent});\r\n                    Log.exDev(dcurrent.id === dcurrent.father, \"node failed to get containing graph, found loop\",\r\n                        {cdata:context.data, dcurrent, father: LPointerTargetable.from(dcurrent)?.father});\r\n                    dcurrent = DPointerTargetable.fromPointer(dcurrent.father);\r\n            }\r\n        }\r\n    }\r\n\r\n    // set_x(val: this[\"x\"], context: Context): boolean { SetFieldAction.new(context.data.id, \"x\", val, undefined, false); return true; }\r\n    // get_x(context: Context): this[\"x\"] { return context.data.x; }\r\n    get_x(context: Context): this[\"x\"] { return this.get_size(context).x; }\r\n    set_x(val: this[\"x\"], context: Context): boolean { return this.set_size({x:val}, context); }\r\n    get_y(context: Context): this[\"y\"] { return this.get_size(context).y; }\r\n    set_y(val: this[\"y\"], context: Context): boolean { return this.set_size({y:val}, context); }\r\n\r\n    get_w(context: Context): this[\"w\"] { return this.get_size(context).w; }\r\n    set_w(val: this[\"w\"], context: Context): boolean { return this.set_size({w:val}, context); }\r\n    get_h(context: Context): this[\"h\"] { return this.get_size(context).h; }\r\n    set_h(val: this[\"h\"], context: Context): boolean { return this.set_size({h:val}, context); }\r\n\r\n    get_width(context: Context): this[\"w\"] { return this.get_w(context); }\r\n    set_width(val: this[\"w\"], context: Context): boolean { return this.set_w(val, context); }\r\n    get_height(context: Context): this[\"h\"] { return this.get_h(context); }\r\n    set_height(val: this[\"h\"], context: Context): boolean { return this.set_h(val, context); }\r\n\r\n    get_position(context: Context): this[\"position\"] { return new GraphPoint(context.data.x, context.data.y); }\r\n    set_position(val: this[\"position\"], c: Context): boolean {\r\n        TRANSACTION('drag' + this.get_name(c), ()=>{\r\n            SetFieldAction.new(c.data.id, \"x\", val.x, undefined, false);\r\n            SetFieldAction.new(c.data.id, \"y\", val.y, undefined, false);\r\n        }, IPoint.printDiff(c.data, val))\r\n        return true; }\r\n\r\n    get_sizeold(context: Context): this[\"size\"] { return new GraphSize(context.data.x, context.data.y, context.data.w, context.data.h); }\r\n    get_component(context: Context): this[\"component\"] {\r\n        // switch(context.data.className) { case DEdgePoint.name: return GraphElementComponent.map[context.data.father]; }\r\n        return GraphElementComponent.map[context.data.id]; }\r\n    // get_view(context: Context): this[\"view\"] { return this.get_component(context).props.view; }\r\n    get_view(context: Context): this[\"view\"] {\r\n        return transientProperties.node[context.data.id]?.mainView?.r || LPointerTargetable.fromPointer(context.data.view) || this.get_component(context)?.props.view?.r;\r\n    }\r\n    set_view(val: Pack1<this[\"view\"]>, context: Context){\r\n        Log.eDevv(\"node.view is readonly, change it through props or the model\");\r\n        // let ptr: DGraphElement[\"view\"] = Pointers.from(val as this[\"view\"]);\r\n        // return SetFieldAction.new(context.data.id, \"view\", ptr, '', true);\r\n    }\r\n\r\n    outerSize!: LGraphElement[\"size\"];\r\n    __info_of__outerSize: Info = {type:\"GraphSize\", txt:\"the size of the current element relative to the first (root) graph level.\"};\r\n    innerSize!: LGraphElement[\"size\"];\r\n    __info_of__innerSize: Info = {type:\"GraphSize\", txt:\"the size of the current element relative to the last (most nested) graph level.\"};\r\n    __info_of__size: Info = {type:\"GraphSize\", txt: \"same as innerSize.\"};\r\n\r\n\r\n    getSize(outer: boolean = false, canTriggerSet: boolean = true): Readonly<GraphSize> { return this.wrongAccessMessage(\"getSize()\"); }\r\n    get_getSize(c: Context): ((outer?: boolean, canTriggerSet?: boolean) => Readonly<GraphSize>) {\r\n        return (outer: boolean = true, canTriggerSet: boolean = true) => this.get_innerSize(c, canTriggerSet, outer); }\r\n\r\n    get_outerSize(context: Context, canTriggerSet: boolean = true): Readonly<GraphSize> {\r\n        return this.get_innerSize(context, canTriggerSet, true);\r\n    }\r\n    get_size(context: Context, canTriggerSet: boolean = true): Readonly<GraphSize> { return this.get_innerSize(context, canTriggerSet, false); }\r\n    get_innerSize(context: Context, canTriggerSet: boolean = true, outerSize: boolean = false): Readonly<GraphSize> {\r\n        let r = this.get_innerSize_impl(context, canTriggerSet, outerSize);\r\n        return new GraphSize(r.x, r.y, r.w, r.h);\r\n    }\r\n    protected get_innerSize_impl(context: Context, canTriggerSet: boolean = true, outerSize: boolean = false): Readonly<GraphSize> {\r\n        canTriggerSet = canTriggerSet && !Debug.lightMode;\r\n        let cname = context.data.className;\r\n        // cname = DGraphElement.cname;\r\n        switch (cname){\r\n            default: return Log.exDevv(\"unexpected classname in get_size switch: \" + context.data.className);\r\n            case DEdge.cname:\r\n            case DVoidEdge.cname:\r\n            case DGraph.cname: return nosize as any;\r\n            // case DField.cname:\r\n            case DGraphElement.cname:\r\n                let graph = outerSize ? this.get_outerGraph(context) : this.get_innerGraph(context);\r\n                return graph.coord(this.get_htmlSize(context));\r\n            case DVoidVertex.cname:\r\n            case DVertex.cname:\r\n            case DEdgePoint.cname:\r\n            case DGraphVertex.cname: break;\r\n        }\r\n\r\n        // low prio todo: memoization in proxy, as long state does not change keep a collection Dictionary[object][key] = returnval. it gets emptied when state is updated.\r\n\r\n        // when loading a save, edge segements and edgepoints/nodes are computed before creating the edgepoint component\r\n        let view: LViewElement = this.get_view(context);\r\n        // (window as any).retry = ()=>view.getSize(context.data.id);\r\n        let ret: EPSize = view.getSize(context.data.id) as any; // (this.props.dataid || this.props.nodeid as string)\r\n\r\n        if (!ret) {\r\n            ret = new GraphSize() as EPSize;\r\n            ret.x = context.data.x;\r\n            ret.y = context.data.y;\r\n            ret.w = context.data.w;\r\n            ret.h = context.data.h;\r\n            let def: GraphSize | undefined;\r\n            if (undefined===(ret.x)) { if (!def) def = view.defaultVSize; ret.x = def.x || 0;}\r\n            if (undefined===(ret.y)) { if (!def) def = view.defaultVSize; ret.y = def.y || 0;}\r\n            if (undefined===(ret.w)) { if (!def) def = view.defaultVSize; ret.w = def.w || 10;}\r\n            if (undefined===(ret.h)) { if (!def) def = view.defaultVSize; ret.h = def.h | 10;}\r\n            ret.currentCoordType = (context.data as DEdgePoint).currentCoordType as any;\r\n        }\r\n        if (context.data.className === DEdgePoint.cname) {\r\n            ret = (this as any as LEdgePoint).decodePosCoords(context, ret, view);\r\n        }\r\n\r\n        /*\r\n                if ((context.data as DVoidVertex).isResized) {\r\n                    return ret;\r\n                }*/\r\n        if (!canTriggerSet) {\r\n            if (outerSize) ret = this.get_outerGraph(context).translateSize(ret, this.get_innerGraph(context));\r\n            return ret;\r\n        }\r\n        let html: HTMLElement | undefined | null = this.get_component(context)?.html?.current;\r\n        let actualSize: Partial<Size> & {w:number, h:number} = html ? Size.of(html) : {w:0, h:0};\r\n        let isOldElement = (context.data.clonedCounter as number) > 3;\r\n        // if w = 0 i don't auto-set it as in first render it has w:0 because is not reredered and not resized.\r\n        // console.log(\"getSize() cantriggerset html size\", {ret: ret ? {...ret} : ret, html, actualSize, hcc:html?.dataset?.clonedcounter, ncc: context.data.clonedCounter});\r\n        if (!html || +(html.dataset.clonedcounter as string) !== context.data.clonedCounter) canTriggerSet = false;\r\n        let updateSize: boolean = false;\r\n        if (view.adaptWidth && ret.w !== actualSize.w) {\r\n            if (canTriggerSet && (isOldElement || actualSize.w !== 0)) {\r\n                ret.w = actualSize.w;\r\n                updateSize = true;\r\n            }\r\n        }\r\n        if (view.adaptHeight && ret.h !== actualSize.h) {\r\n            if (canTriggerSet && (isOldElement || actualSize.h !== 0)) {\r\n                ret.h = actualSize.h;\r\n                updateSize = true;\r\n            }\r\n        }\r\n        // console.log(\"getSize() from node merged with actualSize\", {ret: {...ret}});\r\n\r\n        if (updateSize) this.set_size(ret, context);\r\n        if (outerSize) ret = this.get_outerGraph(context).translateSize(ret, this.get_innerGraph(context));\r\n        return ret;\r\n    }\r\n    // set_size(size: Partial<this[\"size\"]>, context: Context): boolean {\r\n    set_size(size0: Partial<GraphSize>, c: Context): boolean {\r\n        // console.log(\"setSize(\"+(this.props?.data as any).name+\") thisss\", this);\r\n        if (!size0) return false;\r\n        let size = size0 as Partial<EPSize>;\r\n        let view = this.get_view(c);\r\n        let testmode: boolean = false;\r\n        if (c.data.className === DEdgePoint.cname && size.currentCoordType !== CoordinateMode.absolute) size = (this as any as LEdgePoint).encodePosCoords(c as any, size, view);\r\n\r\n        if (view.updateSize(c.data.id, size)) return true;\r\n\r\n        TRANSACTION('resize '+this.get_name(c), ()=>{\r\n            if (size.x !== c.data.x && size.x !== undefined) SetFieldAction.new(c.data.id, \"x\", size.x, undefined, false);\r\n            if (size.y !== c.data.y && size.y !== undefined) SetFieldAction.new(c.data.id, \"y\", size.y, undefined, false);\r\n            if (size.w !== c.data.w && size.w !== undefined) SetFieldAction.new(c.data.id, \"w\", size.w, undefined, false);\r\n            if (size.h !== c.data.h && size.h !== undefined) SetFieldAction.new(c.data.id, \"h\", size.h, undefined, false);\r\n            let epdata: DEdgePoint = c.data as DEdgePoint;\r\n            if (size.currentCoordType !== epdata.currentCoordType && size.currentCoordType !== undefined) SetFieldAction.new(epdata.id, \"currentCoordType\", size.currentCoordType, undefined, false);\r\n        }, ISize.printDiff(c.data, size))\r\n        return true; }\r\n\r\n    get_html(c: Context): this[\"html\"] {\r\n        let component = this.get_component(c);\r\n        let html = component?.html.current;\r\n        if (html) return html;\r\n        html = document.getElementById(c.data.id);//$('[nodeid=\"' + c.data.id + '\"]')[0];\r\n        if (!html) return undefined;\r\n        if (component) (component.html as any).current = html;\r\n        return html;\r\n    }\r\n    // get_html(context: Context): this[\"html\"] { return $(\"[node-id='\" + context.data.id + \"']\")[0]; }\r\n    set_html(val: this[\"htmlSize\"], context: Context): boolean { return this.cannotSet(\"set_html(). html is generated through jsx. edit the view instead.\"); }\r\n\r\n    get_htmlSize(context: Context): this[\"htmlSize\"] {\r\n        let html = this.get_html(context);\r\n        return html ? Size.of(html) : new Size(0, 0, 0, 0);\r\n        /*\r\n        let graph = this.get_graph(context);\r\n        if (!html) return nosize as any;\r\n        let size = Size.of(html);\r\n        let zoom = graph.zoom;\r\n        size.x /= zoom.x;\r\n        size.y /= zoom.y;\r\n        return size;*/}\r\n    set_htmlSize(val: this[\"htmlSize\"], context: Context): boolean {\r\n        // might be useful for fixed display size/location elements that stay in place even if you move tab or change zoom. debatable if needed\r\n        this.cannotSet(\"set_htmlSize(): todo extra low priority. set GraphSize through set_size instead.\");\r\n        return true; }\r\n    get_htmlPosition(context: Context): this[\"htmlPosition\"] { return this.get_htmlSize(context).tl(); }\r\n    set_htmlPosition(val: this[\"htmlPosition\"], context: Context): boolean {\r\n        // might be useful for fixed display size/location elements that stay in place even if you move tab or change zoom. debatable if needed\r\n        this.cannotSet(\"set_htmlPosition(): todo extra low priority. set graph position through set_position instead.\");\r\n        return true; }\r\n\r\n\r\n    /* how z-index work, it's really messy.\r\n    * cannot move html position. node id depends on it, and a node moving position would need to change id.\r\n    * so i use css order.\r\n    * first order is assigned through node constructor called by parent component injectProps, according to his last index in html.\r\n    * now z-index is set in node and updated properly.\r\n    * z-index is passed to a prop, rendered as html attribute.\r\n    * css takes the attribute value and uses it in \"order\" css rule.\r\n    * problem: updating node.z doesn't trigger the parent injectprops, so he inject html index and\r\n    * the outernmost html root cannot update his attribute without refreshing the parent and recalling injectprops\r\n    * fixed: by updating it directly in GraphElement.render()\r\n    * */\r\n    get_zIndex(context: Context): this[\"zIndex\"] { return (+context.data.zIndex || 0); }\r\n    set_zIndex(val: this[\"zIndex\"], c: Context): boolean {\r\n        val = +val ?? 0;\r\n        if (val === c.data.zIndex) return true;\r\n        TRANSACTION(this.get_name(c)+'.zIndex', ()=> {\r\n            SetFieldAction.new(c.data.id, \"zIndex\", val, undefined, false);\r\n        }, c.data.zIndex, val)\r\n        return true; }\r\n    get_z(context: Context): this[\"zIndex\"] { return context.data.zIndex; }\r\n    set_z(val: this[\"zIndex\"], context: Context): boolean { return this.set_zIndex(val, context); }\r\n    /*\r\n        get_containedIn(context: Context): this[\"containedIn\"] {\r\n            return context.data.containedIn ? LPointerTargetable.fromPointer(context.data.containedIn) : undefined; }\r\n        set_containedIn(val: Pack1<this[\"containedIn\"]>, context: LogicContext<DGraphElement>): boolean {\r\n            let ptr: DGraphElement[\"containedIn\"] = Pointers.from(val) as any;\r\n            SetFieldAction.new(context.data, 'containedIn', ptr, undefined, true);\r\n            if (ptr) SetFieldAction.new(ptr as any, 'subElements+=', context.data.id);\r\n            return true; }*/\r\n\r\n    nodes!:LVoidVertex[];\r\n    __info_of__nodes:Info = {type:'LVertex[]', txt: \"all direct sub-nodes. not including deep subelements (subelements of subelements)\"};\r\n    get_nodes(c: Context): this['nodes'] { return this.get_subElements(c).filter(c => c && c.className.indexOf('Vertex') >= 0) as any; }\r\n    set_nodes(val: never, c: Context): boolean { return this.cannotSet('nodes'); }\r\n    edges!:LVoidVertex[];\r\n    __info_of__edges:Info = {type:'LEdge[]', txt: \"all direct sub-edges. not including deep subelements (subelements of subelements)\"};\r\n    get_edges(c: Context): this['edges'] { return this.get_subElements(c).filter(c => c && c.className.indexOf('Edge') >= 0) as any; }\r\n    set_edges(val: never, c: Context): boolean { return this.cannotSet('edges'); }\r\n    graphs!:LVoidVertex[];\r\n    __info_of__graphs:Info = {type:'LGraph[]', txt: \"all direct sub-graphs. not including deep subelements (subelements of subelements)\"};\r\n    get_graphs(c: Context): this['graphs'] { return this.get_subElements(c).filter(c => c && c.className.indexOf('Graph') >= 0) as any; }\r\n    set_graphs(val: never, c: Context): boolean { return this.cannotSet('graphs'); }\r\n\r\n    allSubNodes!: LVoidVertex[];\r\n    __info_of__allSubNodes:Info = {type:'LVertex[]', txt: \"all deep sub-nodes. including subelements of subelements.\"};\r\n    get_allSubNodes(c: Context): this['allSubNodes'] { return this.get_allSubElements(c).filter(c => c && c.className.indexOf('Vertex') >= 0) as any; }\r\n    set_allSubNodes(val: never, c: Context): boolean { return this.cannotSet('allSubNodes'); }\r\n    allSubEdges!: LVoidEdge[];\r\n    __info_of__allSubEdges:Info = {type:'LEdge[]', txt: \"all deep sub-edges. including subelements of subelements.\"};\r\n    get_allSubEdges(c: Context): this['allSubEdges'] { return this.get_allSubElements(c).filter(c => c && c.className.indexOf('Edge') >= 0) as any; }\r\n    set_allSubEdges(val: never, c: Context): boolean { return this.cannotSet('allSubEdges'); }\r\n    allSubGraphs!: (LGraph | LGraphVertex)[];\r\n    __info_of__allSubGraphs:Info = {type:'LGraph[]', txt: \"all deep sub-graphs. including subelements of subelements.\"};\r\n    get_allSubGraphs(c: Context): this['allSubGraphs'] { return this.get_allSubElements(c).filter(c => c && c.className.indexOf('Graph') >= 0) as any; }\r\n    set_allSubGraphs(val: never, c: Context): boolean { return this.cannotSet('allSubGraphs'); }\r\n\r\n    subElements!: LGraphElement[]; // shallow, direct subelements\r\n    __info_of__subElements: Info = {type: 'LGraphElement[]',\r\n        txt: \"all direct subelements (nodes, edges, edgepoints, subgraphs...). not including deep subelements (subelements of subelements)\"}\r\n    get_subElements(context: Context): this[\"subElements\"] {\r\n        return LPointerTargetable.fromArr([...new Set(context.data.subElements)]).filter((e:L)=>!!e);\r\n    }\r\n    set_subElements(val: PackArr<this[\"subElements\"]>, context: LogicContext<DGraphElement>): boolean {\r\n        console.log(\"isDeepStrictEqual\", {isDeepStrictEqual});\r\n        Log.eDev([...new Set(val)].length !== val.length, \"subelemnts setter have duplicates\", {val, context});\r\n        // if (isDeepStrictEqual(context.data.subElements, val)) return true;\r\n        let pointers: Pointer<DGraphElement, 0, 'N', LGraphElement> = Pointers.from(val) || [];\r\n        if (Uarr.equals(pointers, context.data.subElements, false)) return true;\r\n\r\n        TRANSACTION(this.get_name(context as any)+'.subElements', ()=> {\r\n            SetFieldAction.new(context.data, 'subElements', pointers, '', true);\r\n            const idlookup = store.getState().idlookup;\r\n            let arrdiff = U.arrayDifference(context.data.subElements, pointers);\r\n            // old subelements\r\n            for (let oldsubelementid of arrdiff.removed) {\r\n                let subelement: DGraphElement = (oldsubelementid && idlookup[oldsubelementid]) as DGraphElement;\r\n                if (subelement.father !== context.data.id) continue;\r\n                LPointerTargetable.from(subelement).father = null as any; // todo: can this happen? è transitorio o causa vertici senza parent permanenti?\r\n            }\r\n            // new subelements\r\n            for (let newsubelementid of arrdiff.added) {\r\n                let subelement: DGraphElement = (newsubelementid && idlookup[newsubelementid]) as DGraphElement;\r\n                if (subelement.father === context.data.id) continue;\r\n                LPointerTargetable.from(subelement).father = context.data.id as any; // trigger side-action\r\n            }\r\n        })\r\n        return true;\r\n    }\r\n\r\n    allSubElements!: LGraphElement[]; // deep, nested subelements\r\n    __info_of__allSubElements: Info = {type: 'LGraphElement[]',\r\n        txt: \"all deep subelements (nodes, edges, edgepoints, subgraphs...). including subelements of subelements.\"}\r\n    private get_allSubElements(context: Context, state?: DState): this[\"allSubElements\"] {\r\n        // return context.data.packages.map(p => LPointerTargetable.from(p));\r\n        state = state || store.getState();\r\n        let tocheck: Pointer<DGraphElement>[] = context.data.subElements || [];\r\n        let checked: Dictionary<Pointer, true> = {};\r\n        let dblcheck: Dictionary<Pointer, Pointer> = {}; // <child, parent>  // debug only\r\n        for (let e of tocheck) dblcheck[e] = context.data.id; // debug only\r\n        checked[context.data.id] = true;//nb6[]{}&\r\n        while (tocheck.length) {\r\n            let newtocheck: Pointer<DGraphElement>[] = [];\r\n            for (let ptr of tocheck) {\r\n                Log.eDev(checked[ptr], \"loop in GraphElements containing themselves\", {\r\n                    dblcheck,\r\n                    context,\r\n                    ptr,\r\n                    checked,\r\n                    fistContainer: dblcheck[ptr]\r\n                });\r\n                if (checked[ptr]) continue;\r\n                checked[ptr] = true;\r\n                let subnode: DGraphElement = DPointerTargetable.from(ptr, state);\r\n                let se = subnode?.subElements;\r\n                //for (let e of se) dblcheck[e] = ptr; // debug only\r\n                U.arrayMergeInPlace(newtocheck, se);\r\n            }\r\n            tocheck = newtocheck;\r\n        }\r\n        delete checked[context.data.id];\r\n        return LPointerTargetable.from(Object.keys(checked), state);\r\n    }\r\n\r\n    set_allSubElements(val: never, c: Context): boolean {\r\n        return this.cannotSet('allSubElements');\r\n    }\r\n\r\n    get_isResized(context: LogicContext<DVoidVertex>): DVoidVertex[\"isResized\"] { return (context.data as DVertex).isResized; }\r\n    set_isResized(val: DVoidVertex[\"isResized\"], c: LogicContext<DVoidVertex>): DVoidVertex[\"isResized\"] {\r\n        val = !!val;\r\n        if (!!c.data.isResized === val) return true;\r\n        TRANSACTION(this.get_name(c as any as Context)+'.isResized', ()=> {\r\n            SetFieldAction.new(c.data.id, \"isResized\", val);\r\n        }, c.data.isResized, val)\r\n        return true;\r\n    }\r\n\r\n    get_model(context: Context): this[\"model\"] {\r\n        const modelElementId = context.data.model; //$('[id=\"' + context.data.id + '\"]')[0].dataset.dataid;\r\n        const lModelElement: LModelElement = LPointerTargetable.from(modelElementId as string);\r\n        return lModelElement;\r\n    }\r\n\r\n    assignEdgeAnchor!: ((anchorName?: string)=>void);\r\n    __info_of__assignEdgeAnchor!: {hidden:true, type:\"(anchorName?: string)=>void\", txt: \"Assign a specific anchor of this node to the edge currently following the cursor, if any.\"};\r\n    get_assignEdgeAnchor(c: Context): ((anchorName?: string)=>void) {\r\n        return (anchorName?: string)=>{\r\n            if (anchorName && !c.data.anchors[anchorName]) anchorName = undefined;\r\n            if (LVoidEdge.startFollow) {\r\n                let de: DEdge = DPointerTargetable.fromPointer(LVoidEdge.startFollow);\r\n                if (de.start !== c.data.id) return; // cannot change edge targets, only an anchor within the current targets\r\n                let le: LVoidEdge = LPointerTargetable.fromD(de);\r\n                le.anchorStart = anchorName;\r\n                le.startFollow = false;\r\n\r\n            }\r\n            if (LVoidEdge.endFollow) {\r\n                let de = DPointerTargetable.fromPointer(LVoidEdge.endFollow);\r\n                if (de.end !== c.data.id) return; // cannot change edge targets, only an anchor within the current targets\r\n                let le = LPointerTargetable.fromD(de);\r\n                le.anchorEnd = anchorName;\r\n                le.endFollow = false;\r\n            }\r\n        }\r\n    }\r\n    get_events(c: Context): LViewElement[\"events\"] {\r\n        const tn = transientProperties.node[c.data.id];\r\n        let mainview: DViewElement = tn.mainView.__raw;\r\n        let otherViews: DViewElement[] = tn.stackViews.map(v=>v.__raw);\r\n        let allviews: DViewElement[] = [mainview, ...otherViews].reverse();\r\n        const keep_for_closure_original_funcs: LViewElement[\"events\"] = {};\r\n        const ret: LViewElement[\"events\"] = {};\r\n        for (let dv of allviews) U.objectMergeInPlace(keep_for_closure_original_funcs, transientProperties.view[dv.id].events);\r\n\r\n        const lastContext: GObject = tn.viewScores[mainview.id].evalContext;\r\n        const keys = Object.keys(keep_for_closure_original_funcs);\r\n        // for (let k of keys) ret['_raw_'+k] = keep_for_closure_original_funcs[k];\r\n        for (let k of keys) {\r\n            if (!keep_for_closure_original_funcs[k]) continue;\r\n            ret[k] = (..._params: any) => keep_for_closure_original_funcs[k](lastContext, ..._params);\r\n        }\r\n\r\n        return ret; }\r\n\r\n\r\n    get_father(context: Context): this[\"father\"] { return LPointerTargetable.fromPointer(context.data.father); }\r\n    set_father(val: Pack1<this[\"father\"]>, c: Context): boolean {\r\n        let ptr: DGraphElement[\"father\"] = Pointers.from(val) as any;\r\n        TRANSACTION(this.get_name(c)+'.father', ()=> {\r\n            SetFieldAction.new(c.data, 'father', ptr, undefined, true);\r\n            if (ptr) SetFieldAction.new(ptr as any, 'subElements+=', c.data.id);\r\n        }, this.get_father(c).name, L.fromPointer(ptr).name)\r\n        return true; }\r\n\r\n    __info_of__isselected: Info = {type: \"Dictionary<Pointer<User>, true>\",\r\n        txt:<div>A map that contains all the users selecting this element as keys, and always true as a value (if present).\r\n            <br/>Edit it through node.select() and node.deselect()</div>}\r\n    __info_of__select: Info = {type:\"function(forUser?:Pointer<User>):void\", txt:\"Marks this node as selected by argument user.\"};\r\n    __info_of__deselect: Info = {type:\"function(forUser?:Pointer<User>):void\", txt:\"Un-marks this node as selected by argument user.\"};\r\n    __info_of__toggleSelect: Info = {type:\"function(usr?:Pointer<User>):void\", txt:\"Calls this.select(usr) if the node is selected by argument user, this.deselect(usr) otherwise. If omitted, argument \\\"usr\\\" is the current user id.<br>Returns the result of this.isSelected() after the toggle.\"};\r\n    __info_of__isSelected: Info = {type:\"function(forUser?:Pointer<User>):void\", txt:\"Tells if this node is selected by argument user.\"};\r\n    select(forUser?: Pointer<DUser>): void { return this.wrongAccessMessage(\"node.select()\"); }\r\n    deselect(forUser?: Pointer<DUser>): void { return this.wrongAccessMessage(\"node.deselect()\"); }\r\n    toggleSelected(forUser?: Pointer<DUser>): void { return this.wrongAccessMessage(\"node.toggleSelected()\"); }\r\n    isSelected(forUser?: Pointer<DUser>): boolean { return this.wrongAccessMessage(\"node.isSelected()\"); }\r\n    get_select(c: Context): (forUser?: Pointer<DUser>)=>void {\r\n        return (forUser?: Pointer<DUser>)=>{\r\n            if (!forUser) forUser = DUser.current;\r\n            Log.exDev(typeof forUser !== 'string', 'unexpected parameter in select()', {forUser});\r\n            if (c.data.isSelected[forUser]) return; // no-op\r\n            let map = {...c.data.isSelected};\r\n            map[forUser] = true;\r\n            let duser = DPointerTargetable.fromPointer(forUser);\r\n            TRANSACTION(this.get_name(c)+'.select('+ duser.name+')', ()=>{\r\n                SetFieldAction.new(c.data.id, \"isSelected\", map, undefined, false);\r\n            }, false, true)\r\n            // todo: actually they are pointer to users, but i'm assuming users are not erased at runtime. on deselect too\r\n        }\r\n    }\r\n    get_deselect(c: Context): (forUser?: Pointer<DUser>)=>void {\r\n        return (forUser?: Pointer<DUser>)=>{\r\n            if (!forUser) forUser = DUser.current;\r\n            Log.exDev(typeof forUser !== 'string', 'unexpected parameter in deselect()', {forUser});\r\n            if (!c.data.isSelected[forUser]) return; // no-op\r\n            let map = {...c.data.isSelected};\r\n            delete map[forUser];\r\n            let duser = DPointerTargetable.fromPointer(forUser);\r\n\r\n            TRANSACTION(this.get_name(c)+'.select('+ duser.name+')', ()=>{\r\n                // todo: actually they are pointer to users, but i'm assuming users are not erased at runtime. on deselect too\r\n                SetFieldAction.new(c.data.id, \"isSelected\", map, undefined, false);\r\n            })\r\n        }\r\n    }\r\n    get_toggleSelected(context: Context): ((forUser?: Pointer<DUser>) => boolean) {\r\n        return (forUser?: Pointer<DUser>): boolean => {\r\n            if (!forUser) forUser = DUser.current;\r\n            if (this.get_isSelected(context)(forUser)) {\r\n                this.get_deselect(context)(forUser);\r\n                return false;\r\n            } else {\r\n                this.get_select(context)(forUser);\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    get_isSelected(context: Context): ((forUser?: Pointer<DUser>) => boolean) {\r\n        return (forUser?: Pointer<DUser>): boolean => {\r\n            if (!forUser) forUser = DUser.current;\r\n            return !!context.data.isSelected[forUser]; }\r\n    }\r\n    set_isSelected(val: this[\"isSelected\"], context: Context): boolean {\r\n        return this.cannotSet(\"graphElement.isSelected(): use this.select() or this.deselect() instead.\");\r\n    }\r\n    /*\r\n    get_isSelected(context: LogicContext<DVoidVertex>): GObject {\r\n        return DPointerTargetable.mapWrap(context.data.isSelected, context.data, 'idlookup.' + context.data.id + '.isSelected', []);\r\n    }*/\r\n\r\n\r\n\r\n    // for edges\r\n    public get_startPoint(c: Context|undefined, size?: GraphSize, view?: LViewElement): GraphPoint { return this.get_startEndPoint(c, size, view, true); }\r\n    public get_endPoint(c: Context|undefined, size?: GraphSize, view?: LViewElement): GraphPoint { return this.get_startEndPoint(c, size, view, false); }\r\n    private get_startEndPoint(c: Context|undefined, size?: GraphSize, view?: LViewElement, isStart:boolean=true): GraphPoint {\r\n        if (!size) {\r\n            if (c) size = this.get_size(c) as any; else size = Log.exDevv(\"invalid arguments in get_startEndPoint\", {arguments});\r\n        }\r\n        if (!view) {\r\n            // if (c) view = this.get_view(c); else view = Log.exDevv(\"invalid arguments in get_startPoint\", {arguments});\r\n            view = c && this.get_view(c) || Log.exDevv(\"invalid arguments in get_startEndPoint\", {arguments});\r\n        }\r\n        let offset: GraphPoint = (view as LViewElement)[isStart ? \"edgeStartOffset\" : \"edgeEndOffset\"];\r\n        let isPercentage: boolean = (view as LViewElement)[isStart ? \"edgeStartOffset_isPercentage\" : \"edgeEndOffset_isPercentage\"];\r\n        if (!size) size = new GraphSize(0, 0, 0, 0);\r\n        if (isPercentage) offset = new GraphPoint(offset.x/100*(size.w), offset.y/100*(size.h));\r\n        return size.tl().add(offset, false);\r\n    }\r\n\r\n}\r\nRuntimeAccessibleClass.set_extend(DPointerTargetable, DGraphElement);\r\nRuntimeAccessibleClass.set_extend(LPointerTargetable, LGraphElement)\r\n\r\n\r\n@RuntimeAccessible('DGraph')\r\nexport class DGraph extends DGraphElement {\r\n    // static _super = DGraphElement;\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // static singleton: LGraph;\r\n    // static logic: typeof LGraph;\r\n    // static structure: typeof DGraph;\r\n\r\n    // inherit redefine\r\n    father!: Pointer<DGraphElement, 1, 1, LGraphElement>;\r\n    id!: Pointer<DGraph, 1, 1, LGraph>;\r\n    graph!: Pointer<DGraph, 1, 1, LGraph>;\r\n    model!: Pointer<DModelElement, 1, 1, LModelElement>;\r\n    isSelected!: Dictionary<DocString<Pointer<DUser>>, boolean>;\r\n    // containedIn!: Pointer<DGraphElement, 0, 1, LGraphElement>;\r\n\r\n    state!: GObject;\r\n    // personal attributes\r\n    zoom!: GraphPoint;\r\n    offset!: GraphPoint; // in-graph scrolling offset\r\n\r\n    public static new(htmlindex: number, model: DGraph[\"model\"],\r\n                      parentNodeID?: DGraphElement[\"father\"], // immediate parent\r\n                      parentgraphID?: DGraphElement[\"graph\"], // graph containing this subgraph (redudant? could get it from father chain)\r\n                      nodeID?: DGraphElement[\"id\"] // this id\r\n    ): DGraph {\r\n        return new Constructors(new DGraph('dwc'), parentNodeID, true, undefined, nodeID || Constructors.DGraph_makeID(model))\r\n            .DPointerTargetable()\r\n            .DGraphElement(model, parentgraphID, htmlindex).DGraph().end();\r\n    }\r\n\r\n\r\n    static getNodes(dmp: import(\"../logicWrapper/LModelElement\").DModelElement[], out: {$matched: JQuery<HTMLElement>; $notMatched: JQuery<HTMLElement>; }): JQuery<HTMLElement> {\r\n        let $allnodes = $('[data-dataid]');\r\n        let matchedids: Pointer[] = (dmp || []).map(d => d.id);\r\n        let matchedidmap:Dictionary<string, boolean> = U.objectFromArrayValues(matchedids);\r\n        if (!out) out = {} as any;\r\n\r\n        let allnodesarr = [...$allnodes];\r\n        let filternode = (d: HTMLElement) => {\r\n            if (!d?.dataset?.dataid) return false;\r\n            let id: string = ''+d?.dataset?.dataid;\r\n            return matchedidmap[id]; };\r\n        out.$matched = $(allnodesarr.filter(filternode));\r\n        out.$notMatched = $(allnodesarr.filter((n) => !filternode(n)));\r\n        return out.$matched;\r\n        // throw new Error(\"Method not implemented.\");\r\n    }\r\n\r\n}\r\nvar nosize: GraphSize = {x:0, y:0, w:0, h:0, nosize:true} as any;\r\nvar defaultEdgePointSize: GraphSize = undefined as any; // = {x:0, y:0, w:5, h:5};\r\nvar defaultVertexSize: GraphSize = undefined as any; // {x:0, y:0, w:140.6818084716797, h:32.52840805053711};\r\n\r\n\r\n@RuntimeAccessible('LGraph')\r\nexport class LGraph<Context extends LogicContext<DGraph> = any, D extends DGraph = any> extends LGraphElement {\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // static singleton: LGraph;\r\n    // static logic: typeof LGraph;\r\n    // static structure: typeof DGraph;\r\n\r\n    // inherit redefine\r\n    __raw!: DGraph;\r\n    id!: Pointer<DGraph, 1, 1, LGraph>;\r\n    graph!: LGraph;\r\n    model?: LModelElement;\r\n    // isSelected: Dictionary<DocString<Pointer<DUser>>, boolean> = {};\r\n    isSelected(forUser?: Pointer<DUser>): boolean { return this.wrongAccessMessage(\"node.isSelected()\"); }\r\n    // containedIn?: LGraphElement;\r\n    subElements!: LGraphElement[];\r\n    _state!: GObject<\"proxified\">; // LMap;\r\n    // personal attributes\r\n    zoom!: GraphPoint;\r\n    graphSize!: GraphSize; // derived attribute: bounding rect containing all subnodes, while \"size\" is instead external size of the vertex holding the graph in GraphVertexes\r\n    offset!: GraphPoint; // Scrolling position inside the graph\r\n\r\n    // get_graphSize(context: LogicContext<DGraph>):  Readonly<GraphSize> { return todo: get bounding rect containing all subnodes.; }\r\n    get_offset(context: LogicContext<DGraph>):  Readonly<GraphSize> {\r\n        let offset: Partial<GraphSize> = (context.data.offset || new GraphSize()) as any;\r\n        return new GraphSize(offset.x, offset.y, offset.w, offset.h);\r\n    }\r\n    set_offset(val: Partial<GraphSize>, context: Context): boolean {\r\n        if (!val) val = {x:0, y:0, w:0, h:0};\r\n        //if (val.x === undefined && val.y === undefined && val.w === undefined && val.h === undefined) return true;\r\n        let offset: Partial<GraphSize> = (context.data.offset || new GraphSize()) as any\r\n        if (val.x === undefined && offset.x !== val.x) val.x = offset.x;\r\n        if (val.y === undefined && offset.y !== val.y) val.y = offset.y;\r\n        if (val.w === undefined && offset.w !== val.w) val.w = offset.w;\r\n        if (val.h === undefined && offset.h !== val.h) val.h = offset.h;\r\n        if (offset.x === val.x && offset.y === val.y && offset.w === val.w && offset.h == val.h) return true;\r\n\r\n        TRANSACTION(this.get_name(context)+'.offset', ()=>{\r\n            SetFieldAction.new(context.data, \"offset\", val as any);\r\n        }, IPoint.stringify(offset), IPoint.stringify(val))\r\n        return true;\r\n    }\r\n\r\n    public cumulativeZoom!: GraphPoint;\r\n    public __info_of__cumulativeZoom: Info = {type: GraphPoint.cname, txt: \"the product of all the ownZoom of containing ancestor graphs.\"};\r\n    private get_cumulativeZoom(c:Context): this['cumulativeZoom']{\r\n        let ancestors = [c.proxyObject, ...this.get_graphAncestors(c)];\r\n        let zoom: GraphPoint = new GraphPoint(1,1);\r\n        for (let g of ancestors) zoom.multiply(g.ownZoom, false);\r\n        return zoom;\r\n    }\r\n\r\n    get_zoom(c: Context): GraphPoint {\r\n        return this.get_cumulativeZoom(c);\r\n    }\r\n    public ownZoom!: GraphPoint;\r\n    __info_of__ownZoom: Info = {type:GraphPoint.cname, label:\"zoom\", txt:\"The individual zoom applied to this graph.\"};\r\n    __info_of__zoom: Info = {type:GraphPoint.cname, label:\"zoom\", txt:\"Scales the graph and all subelements by a factor.\"};\r\n    get_ownZoom(context: Context): GraphPoint {\r\n        const zoom: GraphPoint = context.data.zoom;\r\n        let ret = new GraphPoint(zoom.x||1, zoom.y||1); // NB: do not use (??1), zero is not a valid value for zoom.\r\n        // (zoom as any).debug = {rawgraph: context.data.__raw, zoomx: context.data.zoom.x, zoomy: context.data.zoom.y}\r\n        return ret; }\r\n    set_zoom(val: Partial<GraphPoint>, c: Context): boolean{\r\n        if (!val) val = {x:1, y:1};\r\n        //if (val.x === undefined && val.y === undefined) return true;\r\n        let zoom: Partial<GraphSize> = (c.data.zoom || new GraphSize()) as any;\r\n        if (!val.x) val.x = zoom.x; // remember zero is not allowed value\r\n        if (!val.y) val.y = zoom.y;\r\n        if (zoom.x === val.x && zoom.y === val.y) return true;\r\n\r\n        TRANSACTION(this.get_name(c)+'.zoom', ()=>{\r\n            SetFieldAction.new(c.data, 'zoom', val as any, '+=', false);\r\n        }, IPoint.stringify(zoom), IPoint.stringify(val))\r\n        return true;\r\n    }\r\n\r\n    toGraphSize(...a:Parameters<this[\"coord\"]>): ReturnType<this[\"coord\"]>{ return this.wrongAccessMessage(\"toGraphSize\"); }\r\n    coord(htmlSize: Size): GraphSize { return this.wrongAccessMessage(\"toGraphSize\"); }\r\n    get_coord(context: Context): (htmlSize: Size) => GraphSize {\r\n        return (htmlSize: Size)=> {\r\n            let graphHtmlSize: Size = this.get_htmlSize(context);\r\n            let zoom: GraphPoint = this.get_zoom(context);\r\n            return new GraphSize(\r\n                (htmlSize.x - graphHtmlSize.x) / zoom.x,\r\n                (htmlSize.y - graphHtmlSize.y) / zoom.y,\r\n                htmlSize.w/zoom.x,\r\n                htmlSize.h/zoom.y);\r\n        }\r\n    }\r\n    // get_htmlSize(context: Context): Size { }\r\n    translateSize<T extends GraphSize|GraphPoint>(ret: T, innerGraph: LGraph): T { return this.wrongAccessMessage(\"translateSize()\"); }\r\n    translateHtmlSize<T extends Size|Point, G = T extends Size ? GraphSize : GraphPoint>(size: T): G { return this.wrongAccessMessage(\"translateHtmlSize()\"); }\r\n\r\n    __info_of__offset: Info = {type:GraphPoint.cname, label:\"offset\", txt:\"In-graph scrolling position.\"};\r\n    __info_of__graphSize: Info = {type:GraphSize.cname, label:\"graphSize\", txt:\"size internal to the graph, including internal scroll and panning.\"};\r\n    __info_of__translateSize: Info = {type:\"(T, Graph)=>T where T is GraphSize | GraphPoint\", txt:\"Translates a coordinate set from the local coordinates of a SubGraph to this Graph containing it.\"};\r\n    __info_of__translateHtmlSize: Info = {type:\"(Size|Point) => GraphSize|GraphPoint\", txt:'Translate page\\'s viewport coordinate set to this graph coordinate set.'};\r\n    get_translateHtmlSize<T extends Size|Point, G = T extends Size ? GraphSize : GraphPoint>(c: Context): ((size: T) => G) {\r\n        return (size: T): G => {\r\n            let rootGraph: LGraph = this.get_root(c);\r\n            if (rootGraph.id === c.data.id) return this.get_translateHtmlSize_fromRoot<T, G>(c)(size);\r\n            let fakeRootSize = rootGraph.translateHtmlSize_fromRoot<T, G>(size) as any as ISize;\r\n            let screenOffset = this.get_screenOffset(c);//cumulative (g.size.tl()-offset.tl()*cumulativezoom)\r\n\r\n            // distance from the origin of the subgraph in rendered pixels\r\n            let ret = new GraphSize(fakeRootSize.x - screenOffset.x, fakeRootSize.y - screenOffset.y, fakeRootSize.w, fakeRootSize.h);\r\n            return ret.divide(this.get_cumulativeZoom(c) as any, false) as any;\r\n\r\n            /*\r\n            // fake because it assumes all subgraphs have the same zoom level of current graph.\r\n            let ancestors = this.get_graphAncestors(c).reverse().slice(1);\r\n            let cumulativeZoom: GraphPoint = new GraphPoint(1, 1); // = this.get_ownZoom(c);\r\n            for (let g of ancestors){\r\n                let offset = g.offset;\r\n                let ownZoom = g.ownZoom;\r\n                cumulativeZoom.multiply(ownZoom);\r\n                // let a, b, c be graphs\r\n                // size is =  a.zoom + a.offset\r\n\r\n            }\r\n            */\r\n        }\r\n    }\r\n    screenOffset!: GraphPoint;\r\n    __info_of__screenOffset: Info = {type: GraphPoint.cname, txt:\"Distance of the subgraph origin in rendered pixels. to the top-left of graph container.\"}\r\n    private get_screenOffset(c: Context): GraphPoint{\r\n        let ancestors = [c.proxyObject, ...this.get_graphAncestors(c)].reverse();\r\n        let ret = new GraphPoint(0, 0);\r\n        let cumulativeZoom: GraphPoint = new GraphPoint(1, 1); // = this.get_ownZoom(c);\r\n        for (let g of ancestors){\r\n            let offset = g.offset;\r\n            let ownZoom = g.ownZoom;\r\n            let size = g.size;\r\n            ret\r\n                .add(size.tl().multiply(cumulativeZoom, false), false)\r\n                .subtract(offset, false);\r\n            cumulativeZoom.multiply(ownZoom);\r\n            ret\r\n                .multiply(cumulativeZoom, false);\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    private translateHtmlSize_fromRoot<T extends Size|Point, G = T extends Size ? GraphSize : GraphPoint>(size: T):G {\r\n        return this.wrongAccessMessage('translateHtmlSize_fromRoot');\r\n    }\r\n\r\n    /**\r\n     *  IMPORTANT!\r\n     *  this is a wrong partial result, do not call this function directly outside translateHtmlSize.\r\n     *  this is outercoord without zoom, needs ti be translated to container graph coords & de-apply zoom\r\n     */\r\n    private get_translateHtmlSize_fromRoot<T extends Size|Point, G = T extends Size ? GraphSize : GraphPoint>(c: Context): ((size: T) => G) {\r\n        return (size: T): G => {\r\n            let graphHtmlSize = this.get_htmlSize(c);\r\n            let a = size.subtract(graphHtmlSize.tl(), true);\r\n            let offset = {x:c.data.offset.x, y:c.data.offset.y};\r\n            let b = a.subtract(offset, true);\r\n            let r = b.divide(c.data.zoom as any, false) as any as G;\r\n            return r;\r\n        }\r\n    }\r\n\r\n    // graph_of_size, the size parameter have coordinates based on this graph.\r\n    get_translateSize<T extends GraphSize|GraphPoint>(c: Context): ((size: T, graph_of_size: LGraph) => T) {\r\n        return (size: T, graph_of_size: LGraph): T => {\r\n            let targetGraph: LGraph = c.proxyObject;\r\n            let currGraph: LGraph = graph_of_size;\r\n            if (currGraph.id === c.data.id) return size;\r\n            let currAncestors: LGraph[] = [currGraph, ...currGraph.graphAncestors];\r\n            let targetAncestors: LGraph[] = [targetGraph, ...targetGraph.graphAncestors];\r\n            let currAncestorsPtr: Pointer<DGraph>[] = currAncestors.map(l=>l.id).reverse();\r\n            let targetAncestorsPtr: Pointer<DGraph>[] = targetAncestors.map(l=>l.id).reverse();\r\n            Log.ex(targetAncestorsPtr[0] !== currAncestorsPtr[0],\r\n                'translateSize() The root graph of 2 elements should always be the same, are you comparing nodes from different graphs?',\r\n                {currGraph, targetGraph});\r\n            let i: number = 1;\r\n            while (currAncestorsPtr[i] === targetAncestorsPtr[i]) { i++; }\r\n            let commonAncestor: Pointer<DGraph> = targetAncestorsPtr[i-1];\r\n            currAncestors = currAncestors.slice(0, currAncestors.length - i).filter(e=>!!e);\r\n            targetAncestors = targetAncestors.slice(0, currAncestors.length - i).filter(e=>!!e);\r\n            // d, c, b, a           currAncestors\r\n            // d, c, x, y           targetAncestors\r\n            // undo a,b, redo x,y        i = [2]\r\n\r\n            Log.exDev(!currAncestors.length && !targetAncestors.length, \"translateSize() found invalid intersection in container graphs\",\r\n                {currGraph, targetGraph, currAncestors, targetAncestors});\r\n            // @ts-ignore\r\n            let ret: T = 'w' in size ? new GraphSize(size.x, size.y, size.w, size.h) : new GraphPoint(size.x, size.y, size.w, size.h);\r\n            console.log(\"translateSizee pre\", (this.get_model(c) as any).name, size.x, size.y, {size, ret, currAncestors, targetAncestors} )\r\n            for (let g of currAncestors){\r\n                ret.subtract(g.offset, false);\r\n                ret.divide(g.cumulativeZoom, false);\r\n                ret.add(g.size.tl(), false);\r\n            }\r\n            for (let g of targetAncestors){\r\n                ret.subtract(g.size.tl(), false);\r\n                ret.multiply(g.cumulativeZoom, false);\r\n                ret.add(g.offset, false);\r\n            }\r\n            console.log(\"translateSizee ret\", (this.get_model(c) as any).name, size.x, size.y, {size, ret, currAncestors, targetAncestors} )\r\n\r\n            return ret; }\r\n        //todo: check how many passes you need to go down or up, and make the up version too\r\n\r\n    }\r\n    get_translateSize_down_old<T extends GraphSize|GraphPoint>(c: Context): ((size: T, innerGraph: LGraph) => T) {\r\n        return (size: T, graph_of_size: LGraph): T => {\r\n            graph_of_size = LPointerTargetable.wrap(graph_of_size) as LGraph;\r\n            let ret: T = (size.hasOwnProperty(\"w\") ? new GraphSize(size.x, size.y, (size as GraphSize).w, (size as GraphSize).h) : new GraphPoint(size.x, size.y)) as T;\r\n            Log.ex(!graph_of_size, \"translateSize() graph parameter is invalid: \"+graph_of_size, graph_of_size, c);\r\n            let ancestors: LGraph[] = [graph_of_size, ...graph_of_size.graphAncestors];\r\n            console.log(\"translateSize\", {innerGraph: graph_of_size, ret, ancestors, c});\r\n            Log.ex(ancestors.indexOf(c.proxyObject) !== -1, \"translateSize() graph parameter is invalid: it must be a graph containing the current one.\", graph_of_size, c);\r\n            for (let g of ancestors) ret.add(g.size.tl(), false);\r\n            // for (let g of ancestors) ret.subtract(g.offset, false);\r\n            // console.log(\"translateSize\", {c, thiss:c.proxyObject, ancestors, ancestorSizes: ancestors.map(a=> a.size.tl()), size, ret});\r\n            return ret; }\r\n    }\r\n    contains(elem: LGraphElement): boolean{ return this.wrongAccessMessage(\"contains()\"); }\r\n    get_contains(c: Context): ((elem: LGraphElement)=> boolean) {\r\n        return (elem: LGraphElement): boolean => {\r\n            let current = elem;\r\n            let next = elem.father;\r\n            let targetid = c.proxyObject.id;\r\n            if (current.id !== targetid) return true;\r\n            while(next && current.id !== next.id) {\r\n                current = next;\r\n                next = next.father;\r\n                if (current.id !== targetid) return true;\r\n            }\r\n            return false;\r\n        }}\r\n}\r\nRuntimeAccessibleClass.set_extend(DGraphElement, DGraph);\r\nRuntimeAccessibleClass.set_extend(LGraphElement, LGraph);\r\n// export const defaultVSize: GraphSize = new GraphSize(0, 0, 300, 160); // useless, now it's in view.DefaultVSize\r\n// export const defaultEPSize: GraphSize = new GraphSize(0, 0, 15, 15); // useless, now it's in view.DefaultVSize\r\n\r\n\r\n@RuntimeAccessible('DVoidVertex')\r\nexport class DVoidVertex extends DGraphElement {\r\n    // static _super = DGraphElement;\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // static singleton: LVoidVertex;\r\n    // static logic: typeof LVoidVertex;\r\n    // static structure: typeof DVoidVertex;\r\n\r\n    // inherit redefine\r\n    id!: Pointer<DVoidVertex, 1, 1, LVoidVertex>;\r\n    graph!: Pointer<DGraph, 1, 1, LGraph>;\r\n    model!: Pointer<DModelElement, 0, 1, LModelElement>;\r\n    isSelected!: Dictionary<DocString<Pointer<DUser>>, boolean>;\r\n    // containedIn!: Pointer<DGraphElement, 0, 1, LGraphElement>;\r\n    subElements!: Pointer<DGraphElement, 0, 'N', LGraphElement>;\r\n    state!: GObject;\r\n    zoom!: GraphPoint;\r\n    // personal attributes\r\n    x!: number;\r\n    y!: number;\r\n    w!: number;\r\n    h!: number;\r\n    isResized!: boolean;\r\n    // size?: GraphSize; // virtual, gets extracted from this. x and y are stored directly here as it extends GraphSize\r\n\r\n    public static new(htmlindex: number, model: DGraphElement[\"model\"], parentNodeID: DGraphElement[\"father\"], graphID: DGraphElement[\"graph\"], nodeID?: DGraphElement[\"id\"],\r\n                      size?: InitialVertexSize): DVoidVertex {\r\n        return new Constructors(new DVoidVertex('dwc'), parentNodeID, true, undefined, nodeID)\r\n            .DPointerTargetable()\r\n            .DGraphElement(model, graphID, htmlindex)\r\n            .DVoidVertex(size || defaultVertexSize).end();\r\n    }\r\n\r\n}\r\n\r\n@RuntimeAccessible('LVoidVertex')\r\nexport class LVoidVertex<Context extends LogicContext<DVoidVertex> = any, C extends Context = Context> extends LGraphElement {// <D extends DVoidVertex = any>\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // static singleton: LVoidVertex;\r\n    // static logic: typeof LVoidVertex;\r\n    // static structure: typeof DVoidVertex;\r\n\r\n    // inherit redefine\r\n    __raw!: DVoidVertex;\r\n    id!: Pointer<DVoidVertex, 1, 1, LVoidVertex>;\r\n    graph!: LGraph;\r\n    model?: LModelElement;\r\n    // isSelected: Dictionary<DocString<Pointer<DUser>>, boolean> = {};\r\n    isSelected(forUser?: Pointer<DUser>): boolean { return this.wrongAccessMessage(\"node.isSelected()\"); }\r\n    // containedIn?: LGraphElement;\r\n    subElements!: LGraphElement[];\r\n    _state!: GObject<\"proxified\">; // LMap;\r\n    zoom!: GraphPoint;\r\n    isResized!: boolean;\r\n\r\n    // personal attributes\r\n    x!: number;\r\n    y!: number;\r\n    w!: number;\r\n    h!: number;\r\n    size!: GraphSize; // virtual, gets extracted from this. x and y are stored directly here as it extends GraphSize\r\n    __info_of__size = {type: \"?GraphSize\", txt: \"Size of the vertex, if null it means is utilizing the defaultSize from view. recommended to read component.getSize() instead of this.\"};\r\n\r\n    get_isResized(context: LogicContext<DVoidVertex>): DVoidVertex[\"isResized\"] { return context.data.isResized; }\r\n    set_isResized(val: DVoidVertex[\"isResized\"], context: LogicContext<DVoidVertex>): DVoidVertex[\"isResized\"] {\r\n        val = !!val;\r\n        if (!!context.data.isResized === val) return true;\r\n        TRANSACTION(this.get_name(context)+'.isResized', ()=>{\r\n            SetFieldAction.new(context.data.id, \"isResized\", val);\r\n        }, context.data.isResized, val)\r\n        return true;\r\n    }\r\n\r\n\r\n\r\n}\r\n\r\nRuntimeAccessibleClass.set_extend(DGraphElement, DVoidVertex);\r\nRuntimeAccessibleClass.set_extend(LGraphElement, LVoidVertex);\r\n@RuntimeAccessible('DEdgePoint')\r\nexport class DEdgePoint extends DVoidVertex { // DVoidVertex\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // static singleton: LEdgePoint;\r\n    // static logic: typeof LEdgePoint;\r\n    // static structure: typeof DEdgePoint;\r\n\r\n    // inherit redefine\r\n    id!: Pointer<DEdgePoint, 1, 1, LEdgePoint>;\r\n    father!: Pointer<DVoidEdge, 1, 1, LVoidEdge>;\r\n    graph!: Pointer<DGraph, 1, 1, LGraph>;\r\n    model!: Pointer<DModelElement, 0, 1, LModelElement>; // todo: if null gets model from this.father (edge)?\r\n    isSelected!: Dictionary<DocString<Pointer<DUser>>, boolean>;\r\n    // containedIn!: Pointer<DGraphElement, 0, 1, LGraphElement>;\r\n    subElements!: Pointer<DGraphElement, 0, 'N', LGraphElement>;\r\n    zoom!: GraphPoint;\r\n    x!: number;\r\n    y!: number;\r\n    w!: number;\r\n    h!: number;\r\n    size?: GraphSize; //／／ virtual, gets extracted from this. x and y are stored directly here as it extends GraphSize\r\n    // personal attributes\r\n    __isDEdgePoint!: true;\r\n    currentCoordType?: CoordinateMode;\r\n\r\n    public static new(htmlindex: number, model: DEdgePoint[\"model\"] | undefined, parentNodeID: DEdgePoint[\"father\"], graphID?: DEdgePoint[\"graph\"], nodeID?: DGraphElement[\"id\"],\r\n                      size?: InitialVertexSize): DEdgePoint {\r\n        return new Constructors(new DEdgePoint('dwc'), parentNodeID, true, undefined, nodeID)\r\n            .DGraphElement(undefined, graphID, htmlindex)\r\n            .DVoidVertex(size || defaultEdgePointSize).DEdgePoint().end();\r\n    }\r\n\r\n}\r\n\r\n@RuntimeAccessible('LEdgePoint')\r\nexport class LEdgePoint<Context extends LogicContext<DEdgePoint> = any, C extends Context = Context> extends LVoidVertex {\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // static singleton: LEdgePoint;\r\n    // static logic: typeof LEdgePoint;\r\n    // static structure: typeof DEdgePoint;\r\n\r\n    // inherit redefine\r\n    father!: LVoidEdge;\r\n    // __raw!: DEdgePoint;\r\n    id!: Pointer<DEdgePoint, 1, 1, LEdgePoint>;\r\n    graph!: LGraph;\r\n    model?: LModelElement;\r\n    // isSelected: Dictionary<DocString<Pointer<DUser>>, boolean> = {};\r\n    isSelected(forUser?: Pointer<DUser>): boolean { return this.wrongAccessMessage(\"node.isSelected()\"); }\r\n    // containedIn?: LGraphElement;\r\n    subElements!: LGraphElement[];\r\n    zoom!: GraphPoint;\r\n    x!: number;\r\n    y!: number;\r\n    w!: number;\r\n    h!: number;\r\n    size!: GraphSize; // virtual, gets extracted from this. x and y are stored directly here as it extends GraphSize\r\n    // personal attributes\r\n    __isLEdgePoint!: true;\r\n    edge!: LVoidEdge; // returns container edge\r\n    __info_of__edge: Info = {type:\"?LEdge\", txt:\"returns the containing edge if called on an EdgePoint, \\\"this\\\" if called on an edge, undefined otherwise.\"}\r\n\r\n    public get_edge(c: Context): LVoidEdge { return c.proxyObject.father; }\r\n    public set_edge(v: Pack1<LVoidEdge>, c: Context): boolean { return this.set_father(v as any, c); }\r\n\r\n\r\n\r\n\r\n    static decodeCoords<T extends Partial<EPSize>>(size0: T, sp:GraphPoint, ep: GraphPoint): T/*absolute*/{\r\n        let size: any = size0;\r\n        let ret: any = ((\"w\" in size || \"h\" in size) ? new GraphSize() : new GraphPoint()); // GObject<Partial<GraphSize>>;\r\n        switch (size.currentCoordType) {\r\n            default: return Log.exDevv(\"translatePosCoords() invalid coordinate mode\", {mode:size.currentCoordType});\r\n            // case CoordinateMode.absolute: return size;\r\n            case CoordinateMode.absolute: case undefined: case null:\r\n                if (size.x !== undefined) ret.x = size.x;\r\n                if (size.y !== undefined) ret.y = size.y;\r\n                break;\r\n            case CoordinateMode.relativePercent:\r\n                //maybe do: dampening factor on relative % offset? is it possible?\r\n                // let s = this.getBasicSize(c);\r\n                // MATH:\r\n                // size.x = sp.x*x% + ep.x*(1-x%)\r\n                // size.x = sp.x*x% + ep.x - ep.x*x%\r\n                // size.x - ep.x= (sp.x - ep.x)*x%\r\n                // (size.x - ep.x) / (sp.x - ep.x) = x% // actually i inverted <sp, ep> in first equation, so reverse them in result too.\r\n                if (size.x !== undefined) ret.x = (1 - size.x) * sp.x + (size.x) * ep.x;\r\n                if (size.y !== undefined) ret.y = (1 - size.y) * sp.y + (size.y) * ep.y;\r\n                break;\r\n            case CoordinateMode.relativeOffset:\r\n            case CoordinateMode.relativeOffsetStart:\r\n            case CoordinateMode.relativeOffsetEnd:\r\n                let useStart: boolean;\r\n                let useEnd: boolean;\r\n                switch (size.currentCoordType) {\r\n                    default:\r\n                    case CoordinateMode.relativeOffset: useStart = true; useEnd = true; break;\r\n                    case CoordinateMode.relativeOffsetStart: useStart = true; useEnd = false; break;\r\n                    case CoordinateMode.relativeOffsetEnd: useStart = false; useEnd = true; break;\r\n                }\r\n                // offset = sp - size\r\n                // size = offset - sp\r\n                // in reverse: actualsize = offset, size=offset\r\n\r\n                // if coords are already in absolute mode.\r\n                let xIsAbsolute: number | undefined = (size.x&&!Array.isArray(size.x)) ? size.x : undefined;\r\n                let yIsAbsolute: number | undefined = (size.x&&!Array.isArray(size.x)) ? size.x : undefined;\r\n                Log.w(!!(xIsAbsolute || yIsAbsolute), \"decoding relative offset require an array size coordinate system. x=[x1, x2] --> x\", {size});\r\n\r\n                let offsetsp = useStart ? new GraphPoint(xIsAbsolute || size.x[0] + sp.x, yIsAbsolute || size.y[0] + sp.y) : new GraphPoint();\r\n                let offsetep = useEnd ? new GraphPoint(xIsAbsolute || size.x[1] + ep.x, yIsAbsolute || size.y[1] + ep.y) : new GraphPoint();\r\n                // if the start and endpoint of the edge didn't move, offsetsp = offsetep.\r\n                // if they moved, those 2 are discordant --> i pick middle\r\n                offsetsp.add(offsetep, false);\r\n                if (useStart && useEnd) offsetsp.divide(2, false);\r\n                if (!xIsAbsolute && size.x !== undefined) ret.x = offsetsp.x;\r\n                if (!yIsAbsolute && size.y !== undefined) ret.y = offsetsp.y;\r\n                if (xIsAbsolute) {\r\n                    ret.x = size.x;\r\n                }\r\n                if (yIsAbsolute) {\r\n                    ret.y = size.y;\r\n                }\r\n                break;\r\n        }\r\n        if (size.x === undefined) delete ret.x;\r\n        if (size.y === undefined) delete ret.y;\r\n        if ((size as any).w === undefined) delete ret.w; else ret.w = size.w;\r\n        if ((size as any).h === undefined) delete ret.h; else ret.h = size.h;\r\n        ret.currentCoordType = CoordinateMode.absolute;\r\n        // console.log(\"decode coords\", {size, sp, ep, ret});\r\n        return ret;\r\n    }\r\n    // from x,y as coords, to x%,y% as % of ((1-val)%*startpt) + ((val)%*endpt)\r\n    public decodePosCoords<T extends Partial<GraphSize> | Partial<GraphPoint>>(c: Context, size: T&any, view: LViewElement, sp0?: GraphPoint, ep0?: GraphPoint): T {\r\n        let le: LVoidEdge = c&&c.proxyObject.father;\r\n        // console.log(\"decodepos:\", {le, sp0, lesp:le?.startPoint});\r\n        let sp: GraphPoint = sp0||le.startPoint;\r\n        let ep: GraphPoint = ep0||le.endPoint;\r\n        return LEdgePoint.decodeCoords(size, sp, ep);\r\n    }\r\n\r\n    static testCoords(range: number = 30){\r\n        outer: for (let mode of [\"absolute\", \"relative%\", \"relativeOffset\", \"relativeOffsetStart\", \"relativeOffsetEnd\"])\r\n            for (let i = -range; i < range; i++)\r\n                for (let j = -range; j < range; j++){\r\n                    var s0 = {x:i, y:j};\r\n                    var sp = {x:10, y:10};\r\n                    var ep = {x:10, y:-10};\r\n                    // @ts-ignore\r\n                    var s1 = LEdgePoint.encodeCoords(s0, mode, sp, ep)\r\n                    // @ts-ignore\r\n                    var s00 = LEdgePoint.decodeCoords(s1, sp, ep);\r\n                    // @ts-ignore\r\n                    var error = Object.keys(s0).map( k=> s0[k].toFixed(3) === s00[k].toFixed(3) ? '' : k).join('');\r\n                    (mode != \"relative%\" && error ? console.error : console.log)({diff:[s00.x-s0.x, s00.y-s0.y].join(), i, j, mode, s1:[s1.x, s1.y].join(), s0, s00, error});\r\n                    if (mode != \"relative%\" && error ) break outer;\r\n                }\r\n    }\r\n    // @ts-ignore a\r\n\r\n    static encodeCoords<T extends Partial<EPSize>>(size0: T, edgePointCoordMode: CoordinateMode, sp:GraphPoint, ep: GraphPoint): T/*absolute*/{\r\n        let size: T = size0 as any;\r\n        if (edgePointCoordMode === size.currentCoordType ||\r\n            !size.currentCoordType && edgePointCoordMode === CoordinateMode.absolute) return size;\r\n        if (size.currentCoordType && size.currentCoordType !== CoordinateMode.absolute) size = LEdgePoint.decodeCoords(size, sp, ep);\r\n\r\n        let ret: any = ((\"w\" in size || \"h\" in size) ? new GraphSize() : new GraphPoint()); // GObject<Partial<GraphSize>>;\r\n        switch (edgePointCoordMode) {\r\n            default: return Log.exDevv(\"translatePosCoords() invalid coordinate mode\", {mode:edgePointCoordMode});\r\n            // case CoordinateMode.absolute: return size;\r\n            case CoordinateMode.relativePercent:\r\n                // let s = this.getBasicSize(c);\r\n                // MATH:\r\n                // size.x = sp.x*x% + ep.x*(1-x%)\r\n                // size.x = sp.x*x% + ep.x - ep.x*x%\r\n                // size.x - ep.x= (sp.x - ep.x)*x%\r\n                // (size.x - ep.x) / (sp.x - ep.x) = x% // actually i inverted <sp, ep> in first equation, so reverse them in result too.\r\n\r\n                if (sp.x === ep.x) ret.x = 0.5; // because otherwise it is infinity. so i force him to return in line.\r\n                else if (size.x !== undefined) ret.x = (size.x - sp.x) / (ep.x - sp.x);\r\n                if (sp.y === ep.y) ret.y = 0.5;\r\n                else if (size.y !== undefined) ret.y = (size.y - sp.y) / (ep.y - sp.y);\r\n                break;\r\n            case CoordinateMode.relativeOffset:\r\n            case CoordinateMode.relativeOffsetStart:\r\n            case CoordinateMode.relativeOffsetEnd:\r\n                let useStart: boolean;\r\n                let useEnd: boolean;\r\n                switch (edgePointCoordMode) {\r\n                    default:\r\n                    case CoordinateMode.relativeOffset: useStart = true; useEnd = true; break;\r\n                    case CoordinateMode.relativeOffsetStart: useStart = true; useEnd = false; break;\r\n                    case CoordinateMode.relativeOffsetEnd: useStart = false; useEnd = true; break;\r\n                }\r\n                if (size.x) ret.x = [useStart ? size.x - sp.x : -1, useEnd ? size.x - ep.x : -1];\r\n                if (size.y) ret.y = [useStart ? size.y - sp.y : -1, useEnd ? size.y - ep.y : -1];\r\n                /*\r\n                if (size.x) ret.x = [sp.x - size.x, ep.x - size.x];\r\n                if (size.y) ret.y = [sp.y - size.y, ep.y - size.y];*/\r\n                break;\r\n        }\r\n        if (size.x === undefined) delete ret.x;\r\n        if (size.y === undefined) delete ret.y;\r\n        if ((size as any).w === undefined) delete ret.w; else ret.w = (size as any).w;\r\n        if ((size as any).h === undefined) delete ret.h; else ret.h = (size as any).h;\r\n        // console.log(\"encode coorde\", {size, sp, ep, ret});\r\n        ret.currentCoordType = edgePointCoordMode;\r\n        return ret;\r\n    }\r\n    public encodePosCoords(c: Context, size0: Partial<EPSize>, view: LViewElement, sp0?: GraphPoint, ep0?: GraphPoint, mode?: CoordinateMode): Partial<EPSize> {\r\n        if (!view) view = this.get_view(c);\r\n        let size: Partial<EPSize> = size0 as any;\r\n        let edgePointCoordMode = mode || (view.__raw || view).edgePointCoordMode;\r\n        let le: LVoidEdge = c&&c.proxyObject.father;\r\n        let sp: GraphPoint = sp0 || le.startPoint;\r\n        let ep: GraphPoint = ep0 || le.endPoint;\r\n        return LEdgePoint.encodeCoords(size, edgePointCoordMode, sp, ep);\r\n    }\r\n\r\n    /* 13/10/2023 Giordano comment (defined in LPointerTargetable\r\n    public get_delete(context: Context): () => void {\r\n        // careful: pointedBy might be broken due to comment x984 (search it)\r\n        return super.get_delete(context);\r\n    }\r\n    */\r\n}\r\nRuntimeAccessibleClass.set_extend(DVoidVertex, DEdgePoint);\r\nRuntimeAccessibleClass.set_extend(LVoidVertex, LEdgePoint);\r\n\r\n@RuntimeAccessible('DVertex')\r\nexport class DVertex extends DGraphElement { // DVoidVertex\r\n    // static _super = DVoidVertex;\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // static singleton: LVertex;\r\n    // static logic: typeof LVertex;\r\n    // static structure: typeof DVertex;\r\n\r\n    // inherit redefine\r\n    id!: Pointer<DVertex, 1, 1, LVertex>;\r\n    graph!: Pointer<DGraph, 1, 1, LGraph>;\r\n    model!: Pointer<DModelElement, 0, 1, LModelElement>;\r\n    isSelected!: Dictionary<DocString<Pointer<DUser>>, boolean>;\r\n    // containedIn!: Pointer<DGraphElement, 0, 1, LGraphElement>;\r\n    subElements!: Pointer<DGraphElement, 0, 'N', LGraphElement>;\r\n    zoom!: GraphPoint;\r\n    x!: number;\r\n    y!: number;\r\n    w!: number;\r\n    h!: number;\r\n    isResized!: boolean;\r\n    // size!: GraphSize; // virtual, gets extracted from this. x and y are stored directly here as it extends GraphSize\r\n    // personal attributes\r\n    __isDVertex!: true;\r\n\r\n    public static new(htmlindex: number, model: DGraphElement[\"model\"], parentNodeID: DGraphElement[\"father\"],\r\n                      graphID: DGraphElement[\"graph\"], nodeID?: DGraphElement[\"id\"], size?: GraphSize): DVertex {\r\n        return new Constructors(new DVertex('dwc'), parentNodeID, true, undefined, nodeID)\r\n            .DPointerTargetable()\r\n            .DGraphElement(model, graphID, htmlindex)\r\n            .DVoidVertex(size || defaultVertexSize).DVertex().end();\r\n    }\r\n}\r\n\r\n@RuntimeAccessible('LVertex')\r\nexport class LVertex<Context extends LogicContext<any> = any, D = DVertex> extends LVoidVertex {\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // static singleton: LVertex;\r\n    // static logic: typeof LVertex;\r\n    // static structure: typeof DVertex;\r\n\r\n    // inherit redefine\r\n    __raw!: DVertex;\r\n    id!: Pointer<DVertex, 1, 1, LVertex>;\r\n    graph!: LGraph;\r\n    model?: LModelElement;\r\n    // isSelected: Dictionary<DocString<Pointer<DUser>>, boolean> = {};\r\n    isSelected(forUser?: Pointer<DUser>): boolean { return this.wrongAccessMessage(\"node.isSelected()\"); }\r\n    // containedIn?: LGraphElement;\r\n    subElements!: LGraphElement[];\r\n    zoom!: GraphPoint;\r\n    x!: number;\r\n    y!: number;\r\n    w!: number;\r\n    h!: number;\r\n    size!: GraphSize; // virtual, gets extracted from this. x and y are stored directly here as it extends GraphSize\r\n    isResized!: boolean;\r\n    // personal attributes\r\n    __isLVertex!: true;\r\n}\r\n\r\nRuntimeAccessibleClass.set_extend(DGraphElement, DVertex);\r\nRuntimeAccessibleClass.set_extend(LGraphElement, LVertex);\r\n\r\n@Leaf\r\n@RuntimeAccessible('DGraphVertex')\r\nexport class DGraphVertex extends DGraphElement { // MixOnlyFuncs(DGraph, DVertex)\r\n    // static _super1 = DGraph;\r\n    // static _super2 = DVertex;\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // static singleton: LGraphVertex;\r\n    // static logic: typeof LGraphVertex;\r\n    // static structure: typeof DGraphVertex;\r\n\r\n    // inherit redefine\r\n    id!: Pointer<DGraphVertex, 1, 1>;\r\n    graph!: Pointer<DGraph, 1, 1, LGraph>;\r\n    model!: Pointer<DModelElement, 1, 1, LModelElement>;\r\n    isSelected!: Dictionary<DocString<Pointer<DUser>>, boolean>;\r\n    // containedIn!: Pointer<DGraphElement, 0, 1, LGraphElement>;\r\n    subElements!: Pointer<DGraphElement, 0, 'N', LGraphElement>;\r\n    // from graph\r\n    zoom!: GraphPoint;\r\n    offset!: GraphPoint; // in-graph scrolling position\r\n\r\n    // from VoidVertex\r\n    x!: number;\r\n    y!: number;\r\n    w!: number;\r\n    h!: number;\r\n    isResized!: boolean;\r\n    // size!: GraphSize; // virtual\r\n    // from graph\r\n\r\n    // personal attributes\r\n    __isDVertex!: true;\r\n    __isDGraph!: true;\r\n    __isDGraphVertex!: true;\r\n\r\n    public static new(htmlindex: number, model: DGraph[\"model\"], parentNodeID: DGraphElement[\"father\"],\r\n                      graphID: DGraphElement[\"graph\"], nodeID?: DGraphElement[\"id\"], size?: GraphSize): DGraphVertex {\r\n        return new Constructors(new DGraphVertex('dwc'), parentNodeID, true, undefined, nodeID)\r\n            .DPointerTargetable().DGraphElement(model, graphID, htmlindex)\r\n            .DVoidVertex(size || defaultVertexSize).DVertex().DGraph().end();\r\n    }\r\n\r\n\r\n    /*\r\n        static init_constructor(thiss: DGraphVertex, isUser: boolean = false, nodeID: string | undefined, graphID: string | undefined, model: Pointer<DModel>): void {\r\n            DGraph.init_constructor(thiss, isUser, nodeID, graphID, model);\r\n    //isUser: boolean = false, nodeID: string | undefined, graphID: string, model?: Pointer<DModel>\r\n            DVertex.init_constructor(thiss, isUser, nodeID, graphID as string, model);\r\n            thiss.className = this.name;\r\n        }*/\r\n}\r\nclass LG extends LGraph{}\r\nclass LV extends LVertex{}\r\n\r\nconst Mixed = MixOnlyFuncs(LG, LV) as (typeof LG & typeof LV & typeof RuntimeAccessibleClass);\r\n@RuntimeAccessible('LGraphVertex')\r\n//@ts-ignore TS2510\r\nexport class LGraphVertex<Context extends LogicContext<any> = any, D extends DGraphVertex = any> extends Mixed { // MixOnlyFuncs(LGraph, LVertex)\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // static singleton: LGraphVertex;\r\n    // static logic: typeof LGraphVertex;\r\n    // static structure: typeof DGraphVertex;\r\n\r\n    // inherit redefine\r\n    __raw!: DGraphVertex;\r\n    id!: Pointer<DGraphVertex, 1, 1>;\r\n    graph!: LGraph;\r\n    model?: LModelElement;\r\n    // isSelected: Dictionary<DocString<Pointer<DUser>>, boolean> = {};\r\n    isSelected(forUser?: Pointer<DUser>): boolean { return this.wrongAccessMessage(\"node.isSelected()\"); }\r\n    // containedIn?: LGraphElement;\r\n    ///////////////////////////////////////// subElements!: LGraphElement[];\r\n    // from graph\r\n    zoom!: GraphPoint;\r\n    offset!: GraphPoint; // in-graph scrolling position\r\n    graphSize!: GraphSize; // internal size of the graph. can be huge even if the sub-graph is in a small window (scroll)\r\n\r\n    // from VoidVertex\r\n    x!: number;\r\n    y!: number;\r\n    w!: number;\r\n    h!: number;\r\n    isResized!: boolean;\r\n    size!: GraphSize; // virtual\r\n\r\n\r\n    // personal attributes\r\n    __isLVertex!: true;\r\n    __isLGraph!: true;\r\n    __isLGraphVertex!: true;\r\n}\r\n\r\nRuntimeAccessibleClass.set_extend(DGraph, DGraphVertex);\r\nRuntimeAccessibleClass.set_extend(DVertex, DGraphVertex);\r\nRuntimeAccessibleClass.set_extend(LGraph, LGraphVertex);\r\nRuntimeAccessibleClass.set_extend(LVertex, LGraphVertex);\r\n\r\n\r\n@RuntimeAccessible('DVoidEdge')\r\nexport class DVoidEdge extends DGraphElement {\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // static singleton: LVoidEdge;\r\n    // static logic: typeof LVoidEdge;\r\n    // static structure: typeof DVoidEdge;\r\n    id!: Pointer<DVoidEdge, 1, 1, LVoidEdge>;\r\n    graph!: Pointer<DGraph, 1, 1, LGraph>;\r\n    model!: Pointer<DModelElement, 0, 1, LModelElement>;\r\n    // isSelected: Dictionary<DocString<Pointer<DUser>>, boolean> = {};\r\n    isSelected!: Dictionary<DocString<Pointer<DUser>>, boolean>;\r\n    // containedIn!: Pointer<DGraphElement, 0, 1, LGraphElement>;\r\n    subElements!: Pointer<DGraphElement, 0, 'N', LGraphElement>;\r\n\r\n    // personal attributes\r\n    start!: Pointer<DGraphElement, 1, 1, LGraphElement>;\r\n    end!: Pointer<DGraphElement, 1, 1, LGraphElement>;\r\n    __isDVoidEdge!: true;\r\n\r\n    midPoints!: InitialVertexSize[]; // the logic part which instructs to generate the midnodes\r\n    midnodes!: Pointer<DEdgePoint, 1, 1, LEdgePoint>[]; // using subelements instead most of times\r\n\r\n    longestLabel?: DocString<\"function\">;\r\n    labels?: DocString<\"function\">;\r\n    anchorStart?: string;\r\n    anchorEnd?: string;\r\n\r\n    isExtend!: boolean;\r\n    isReference!: boolean;\r\n    isValue!: boolean;\r\n    isDependency!: boolean;\r\n    // endFollow!: boolean; they became derived attributes from static properties\r\n    // startFollow!: boolean;\r\n\r\n    static isFollowingCoords: GraphPoint;\r\n\r\n    public static new(htmlindex: number, model: DGraph[\"model\"]|null|undefined, parentNodeID: DGraphElement[\"father\"], graphID: DGraphElement[\"graph\"],\r\n                      nodeID: DGraphElement[\"id\"]|undefined, start: DGraphElement[\"id\"], end: DGraphElement[\"id\"],\r\n                      longestLabel?: DEdge[\"longestLabel\"], labels?: DEdge[\"labels\"]): DEdge {\r\n        return new Constructors(new DEdge('dwc'), parentNodeID, true, undefined, nodeID)\r\n            .DPointerTargetable()\r\n            .DGraphElement(model, graphID, htmlindex)\r\n            .DVoidEdge(start, end, longestLabel, labels).end();\r\n    }\r\n    public static new2(model: DGraph[\"model\"]|null|undefined, parentNodeID: DGraphElement[\"father\"], graphID: DGraphElement[\"graph\"],\r\n                       nodeID: DGraphElement[\"id\"]|undefined, start: DGraphElement[\"id\"], end: DGraphElement[\"id\"], setter:((d: DEdge) => any)): DEdge {\r\n        return new Constructors(new DEdge('dwc'), parentNodeID, true, undefined, nodeID)\r\n            .DPointerTargetable()\r\n            .DGraphElement(model, graphID)\r\n            .DVoidEdge(start, end).end(setter);\r\n    }\r\n}\r\n/*\r\n@RuntimeAccessible\r\nexport class MidPoint{\r\n    readonly id: string; // not really a pointer, it's not on store.\r\n    x?: number; y?: number;\r\n    readonly w?: number; // if it's modified it's not ever here (initial size) but on DEdgePoint that is a Node.\r\n    readonly h?: number;/*\r\n    constructor2(x: number=5, y: number=5, w: number=5, h: number=5) {\r\n        this.x = x;\r\n        this.y = y;\r\n        this.w = w;\r\n        this.h = h;\r\n    }* /\r\nconstructor(id: string, w: number=5, h: number=5) {\r\n    this.id = id;\r\n    this.w = w;\r\n    this.h = h;\r\n}\r\n}*/\r\n@RuntimeAccessible('EdgeSegment')\r\nexport class EdgeSegment{\r\n    index: number;\r\n    prev: EdgeSegment | undefined;\r\n    start: segmentmaker;\r\n    bezier: segmentmaker[];\r\n    end: segmentmaker;\r\n    length!: number;\r\n    // if EdgeSegment is changed, shouldcomponentupdate needs update too: search in IDE for \"5khi2\"\r\n    d!: string;\r\n    dpart!: string; //  a segment of the whole path\r\n    m!: number; // m coefficient of the line between start and end.\r\n    rad!: number; // for head and tails: radian angle of the segment.\r\n    radLabels!: number; // for labels: it flips the angle when it's < PI/2 so the text is never upside down\r\n\r\n    isLongest!: boolean;\r\n    label!: PrimitiveType | JSX.Element | undefined;\r\n    svgLetter: EdgeBendingMode;\r\n    /*constructor(label: PrimitiveType|undefined, length: number, startp: GraphPoint, endp: GraphPoint, start: LGraphElement, end: LGraphElement,\r\n                bezierpts: GraphPoint[], mid: LGraphElement[],\r\n                svgLetter: EdgeBendingMode, index: number, fillMode: MidNodeHandling) {\r\n        this.label = label;\r\n        this.length = length;\r\n        this.length = length;\r\n        this.startp = startp;\r\n        this.bezierp = bezierpts;\r\n        this.endp = endp;\r\n        this.start = start;\r\n        this.end = end;\r\n        this.mid = mid;\r\n    }*/\r\n    constructor(start: segmentmaker, mid: segmentmaker[], end: segmentmaker,\r\n                svgLetter: EdgeBendingMode, gapMode: EdgeGapMode,\r\n                index: number, prevSegment: EdgeSegment | undefined){\r\n        // console.log(\"segmentmaker:\", arguments, ((start.ge?.model as any)?.name)+\" ---> \" + ((end.ge?.model as any)?.name));\r\n        this.start = start;\r\n        this.bezier = mid;\r\n        this.end = end;\r\n        this.index = index;\r\n        this.prev = prevSegment;\r\n        //this.segments = segments;\r\n        // the idea: forbid all T and S or transform them in C, Q by calculating and manually adding their mirrored bezier pts\r\n        // if (svgLetter[1]) svgLetter = (svgLetter[0]) as any;\r\n        if (svgLetter === EdgeBendingMode.Bezier_QT) {\r\n            this.svgLetter = EdgeBendingMode.Bezier_QT[0] as any as EdgeBendingMode;\r\n            // this.svgLetter = (index === 0 ? EdgeBendingMode.Bezier_QT[0] : EdgeBendingMode.Bezier_QT[1]) as any as EdgeBendingMode;\r\n            this.addBezierPoint();\r\n        } else\r\n        if (svgLetter === EdgeBendingMode.Bezier_CS) {\r\n            this.svgLetter = EdgeBendingMode.Bezier_CS[0] as any as EdgeBendingMode;\r\n            // this.svgLetter = (index === 0 ? EdgeBendingMode.Bezier_CS[0] : EdgeBendingMode.Bezier_CS[1]) as any as EdgeBendingMode;\r\n            this.addBezierPoint();\r\n        }\r\n        else this.svgLetter = svgLetter;\r\n\r\n        // fix if amount of bezier pts is invalid for current letter\r\n        switch (this.svgLetter) {\r\n            case EdgeBendingMode.Line:\r\n            case EdgeBendingMode.Bezier_quadratic:\r\n                if (this.bezier.length >= 1) break;\r\n                else this.svgLetter = EdgeBendingMode.Line;\r\n                break;\r\n            case EdgeBendingMode.Bezier_cubic:\r\n                if (this.bezier.length >= 2) break;\r\n                else if (this.bezier.length >= 1) this.svgLetter = EdgeBendingMode.Bezier_quadratic;\r\n                else this.svgLetter = EdgeBendingMode.Line;\r\n                break;\r\n            case EdgeBendingMode.Elliptical_arc:\r\n                if (this.bezier.length >= 3) break;\r\n                else this.svgLetter = EdgeBendingMode.Line; // straight to end ignoring midpoints that are NOT coordinates when using elliptical arc.\r\n                break;\r\n            default:\r\n            //case EdgeBendingMode.Bezier_quadratic_mirrored as string:\r\n            //case EdgeBendingMode.Bezier_cubic_mirrored as string: // translated to Q or C by adding mirrored bezier points explicitly\r\n            case EdgeBendingMode.Bezier_QT:\r\n            case EdgeBendingMode.Bezier_CS: // translated to Q or C by sending the right letter to each segment\r\n                Log.exDevv(\"this svg letter should not appear here\", this.svgLetter);\r\n                break;\r\n        }\r\n    }\r\n    addBezierPoint(): void {\r\n        let prev: EdgeSegment | undefined = this.prev;\r\n        if (!prev) return;\r\n        let prevedgemakerbezier: segmentmaker = (prev.bezier[prev.bezier.length-1] || prev.start);\r\n        let mirroredBezier: segmentmaker = {...prevedgemakerbezier,\r\n            pt: EdgeSegment.invertLastBezierPt(prevedgemakerbezier.pt, prev.end.pt),\r\n            uncutPt: EdgeSegment.invertLastBezierPt(prevedgemakerbezier.uncutPt, prev.end.uncutPt),\r\n        };\r\n        this.bezier = [mirroredBezier, ...this.bezier];\r\n        // always only 1 assumed pt both in cubic and quadratic.\r\n        // let next: this | undefined = this.segments[this.index+1];\r\n        // EdgeSegment.invertLastBezierPt((next.mid[1] || next.end).pt, next.start.pt);\r\n    }\r\n\r\n    makeD(index: number, gapMode: EdgeGapMode): string {\r\n        this.m = GraphPoint.getM(this.start.pt, this.end.pt);\r\n        this.rad = Geom.mToRad(this.m, this.start.pt, this.end.pt);\r\n        this.radLabels = Math.atan(this.m);\r\n\r\n        let svgLetter = this.svgLetter; // caller makes sure to pass right letter and resolve \"CS\" mixed letters. // this.bendingModeToLetter(bendingMode, index);\r\n        // caller sends inverted pts as normal coords\r\n        // let invertedBezPt = lastSegment && EdgeSegment.invertLastBezierPt(lastSegment.midp[lastSegment.mid.length-1] || lastSegment.startp, lastSegment.endp);\r\n        switch (this.svgLetter.length) {\r\n            case 2:\r\n                return Log.exDevv(\"mixed letters are not allowed and should have been resolved to single svg letters before here, found:\" + svgLetter);\r\n            /*return Log.exDevv(\"dev problem to fix:\\n\" +\r\n            \"the mirrored mode requires the first one to have explicit non-mirrored mode?? like M, C a1 a2 a3, S a1, S a1, S a1\\n\" +\r\n            \"So all segments with mixed modes needs to extract the last bezier point (penultimate coordinate) from previous segments, mirror it and insert in midp[0]\");*/\r\n            case 1:\r\n                let bezierpts = [...this.bezier.map( b => b.pt), this.end.pt];\r\n                let finalpart = svgLetter + \" \" + bezierpts.map((p)=> p.x + \" \" + p.y).join(\", \");\r\n                this.dpart = \"M \" + this.start.pt.x + \" \" + this.start.pt.y + \", \" + finalpart;\r\n                let bezierptsUncut = [...this.bezier.map( b => b.uncutPt), this.end.pt]; // uncutPt exist for start and end too, but i want to use the cut one for those. or edgehead is off\r\n                let finalpartUncut = svgLetter + \" \" + bezierptsUncut.map((p)=> p.x + \" \" + p.y).join(\", \");\r\n                this.d = (index === 0 ? \"M\" + this.start.pt.x + \" \" + this.start.pt.y + \", \" : \"\") + finalpartUncut;\r\n\r\n                //midp = [this.startp, ...this.midp];\r\n                // d = M sp X mp2 ep // X = custom letter\r\n                // dpart = T sp X mp2 ep // S = S if X = C,\r\n                // sp is the startingpoint from the prev node, which might be != from endpoint of last node if last node have w>0 && h>0\r\n                // so i'm \"filling\" the gap with a T, or L arc wich can use only 1 parameter (they are the only 1-parameter arcs)\r\n                // if (this.prev && this.prev.end.pt.equals(this.start.pt)) gapMode = EdgeGapMode.average; // if the 2 points coincide, i use any 1 of the gapmodes that are continuous\r\n                /*switch (gapMode){\r\n                    case EdgeGapMode.center:\r\n                    case EdgeGapMode.average:\r\n                        // continuous gap modes. they only differ in how the \"joining\" point is found, but not in how they behave after that.\r\n                        /*\r\n                        if (index === 0) {\r\n                             startletter = \"M \";\r\n                         }\r\n                         else {\r\n                             switch (svgLetter) {\r\n                                 case SvgLetter.A: case SvgLetter.C: case SvgLetter.S: case SvgLetter.Q: case SvgLetter.T: default:\r\n                                     startletter = SvgLetter.T + \" \"; break;\r\n                                 case SvgLetter.L: case SvgLetter.M:\r\n                                     startletter = SvgLetter.L + \" \"; break;\r\n                             }\r\n                         }* /\r\n                        if (index) {\r\n                            this.d = finalpart;\r\n                        }\r\n                        else { this.d = this.dpart; }\r\n                        break;\r\n                    case EdgeGapMode.gap:\r\n                    case EdgeGapMode.autoFill:\r\n                    case EdgeGapMode.lineFill:\r\n                    case EdgeGapMode.arcFill:\r\n                        // the filling itself is done by another segment (solving svg letter and simulating i=0), so i treat it as a gap.\r\n                        this.d = this.dpart;\r\n                        break;\r\n                    default:\r\n                        Log.exDevv(\"unexpected EdgeGapMode:\" + gapMode, {gapMode});\r\n                }*/\r\n                break;\r\n            default: return Log.exDevv(\"unexpected bending mode length:\" + this.svgLetter + \" or fillMode: \" + gapMode, {bendingMode: this.svgLetter, index, gapMode});\r\n        }\r\n\r\n        //using\r\n        /*\r\n        88\r\n\r\n        // d should not have M set (except for segments[0]\r\n        // dpart have M abd beed to add explicit points for \"mirroring\" and transforming bezier quadratic mirrored in bezier quadratic normal etc.\r\n        //88 problem: the mirrored mode requires the first one to have explicit nonmirrored mode?? like M, C a1 a2 a3, S a1, S a1, S a1 .... ?\r\n        in any case the % letter part is wrong because it needs to subtract first element used for M*/\r\n        return this.d;\r\n    }\r\n\r\n    static invertLastBezierPt(bezier: GraphPoint, end: GraphPoint): GraphPoint{\r\n        // vector = bezier - end\r\n        // end + vector = bezier\r\n        // end - vector = inverted bezier? = 2*end-bezier\r\n        let vector = bezier.subtract(end, true);\r\n        return end.subtract(vector, true);\r\n    }\r\n\r\n    calcLength(): void {\r\n        this.length = this.start.pt.distanceFromPoint(this.end.pt);\r\n    }\r\n}\r\n\r\nexport class EdgeFillSegment extends EdgeSegment{\r\n    public static cname: string = \"EdgeFillSegment\";\r\n    makeD(index: number, gapMode: EdgeGapMode): string {\r\n        // if (gapMode === EdgeGapMode.autoFill) { gapMode = this.svgLetter === EdgeBendingMode.Line ? EdgeGapMode.lineFill : EdgeGapMode.arcFill; }\r\n        switch (gapMode) {\r\n            case \"closest\" as any:// EdgeGapMode.closest:\r\n            case EdgeGapMode.center:\r\n            case EdgeGapMode.average:\r\n            case EdgeGapMode.gap:\r\n                return \"\"; // should not have filler arcs\r\n            default:\r\n                /*\r\n            case EdgeGapMode.autoFill as any:\r\n            case EdgeGapMode.lineFill:\r\n                this.bezier = [];\r\n                this.svgLetter = EdgeBendingMode.Line;\r\n                return super.makeD(index, gapMode);\r\n            case EdgeGapMode.arcFill:*/\r\n                this.svgLetter = this.svgLetter[0] as EdgeBendingMode;\r\n                if (this.svgLetter === \"Q\") this.bezier = this.bezier.length ? [this.bezier[0]] : [];\r\n                return super.makeD(index, gapMode);\r\n        }\r\n    }\r\n}\r\nexport type labelfunc = (e:LVoidEdge, segment: EdgeSegment, allNodes: LEdge[\"allNodes\"], allSegments: EdgeSegment[]) => PrimitiveType;\r\nexport type labeltype = orArr<labelfunc | PrimitiveType>;\r\n\r\ntype segmentmaker = {size: GraphSize, view: LViewElement, ge: LGraphElement, pt: GraphPoint, uncutPt: GraphPoint};\r\n@RuntimeAccessible('LVoidEdge')\r\nexport class LVoidEdge<Context extends LogicContext<DVoidEdge> = any, D extends DEdge = DEdge> extends LGraphElement {\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // static singleton: LVoidEdge;\r\n    // static logic: typeof LVoidEdge;\r\n    // static structure: typeof DVoidEdge;\r\n    __raw!: DVoidEdge;\r\n    id!: Pointer<DVoidEdge, 1, 1, LVoidEdge>;\r\n    graph!: LGraph;\r\n    model?: LModelElement;\r\n    // isSelected: Dictionary<DocString<Pointer<DUser>>, boolean> = {};\r\n    isSelected(forUser?: Pointer<DUser>): boolean { return this.wrongAccessMessage(\"node.isSelected()\"); }\r\n    // containedIn?: LGraphElemnt;\r\n    subElements!: LGraphElement[];\r\n    __isLVoidEdge!: true;\r\n    midPoints!: InitialVertexSize[]; // the logic part which instructs to generate the midnodes\r\n    midnodes!: LEdgePoint[];\r\n    edge!: LVoidEdge; // returns self. useful to get edge from edgePoints without triggering error if you are already on edge.\r\n    __info_of__edge: Info = {type:\"?LEdge\", txt:\"returns this if called on an edge, the containing edge if called on an EdgePoint, undefined otherwise.\"}\r\n\r\n    isExtend!: boolean;\r\n    isReference!: boolean;\r\n    isValue!: boolean;\r\n    isDependency!: boolean;\r\n\r\n/*\r\nreplaced by startPoint\r\n    edgeStart!: GraphPoint;\r\n    edgeStart_inner!: GraphPoint;\r\n    edgeStart_outer!: GraphPoint;\r\n    __info_of__edgeStart: Info = {type: \"GraphPoint\", txt: \"Same as edgeStart_outer.\"}\r\n    __info_of__edgeStart_outer: Info = {type: \"GraphPoint\",\r\n     txt: \"Where the edge should start his path, in coordinates relative at the root Graph.\r\n     <br>Computed by combining the anchor offset option in View and the size of the starting node.\"}\r\n    __info_of__edgeStart_inner: Info = {type: \"GraphPoint\",\r\n     txt: \"Where the edge should start his path, in coordinates relative at the most nested Graph.\r\n     <br>Computed by combining the anchor offset option in View and the size of the starting node.\"}\r\n    edgeEnd!: GraphPoint;\r\n    edgeEnd_inner!: GraphPoint;\r\n    edgeEnd_outer!: GraphPoint;\r\n    __info_of__edgeEnd: Info = {type: \"GraphPoint\", txt: \"Same as edgeEnd_outer.\"}\r\n    __info_of__edgeEnd_outer: Info = {type: \"GraphPoint\",\r\n     txt: \"Where the edge should end his path, in coordinates relative at the root Graph.\r\n     <br>Computed by combining the anchor offset option in View and the size of the starting node.\"}\r\n    __info_of__edgeEnd_inner: Info = {type: \"GraphPoint\",\r\n     txt: \"Where the edge should end his path, in coordinates relative at the most nested Graph.\r\n     <br>Computed by combining the anchor offset option in View and the size of the starting node.\"}\r\n*/\r\n\r\n    allNodes!: [LGraphElement, ...Array<LEdgePoint>, LGraphElement];\r\n    __info_of__allNodes: Info = {type: \"[LGraphElement, ...Array<LEdgePoint>, LGraphElement]\", txt: <span>first element is this.start. then all this.midnodes. this.end as last element</span>};\r\n\r\n\r\n    label!: this[\"longestLabel\"];  // should never be read change their documentation in write only. their values is \"read\" in this.segments\r\n    longestLabel!: labeltype;\r\n    labels!: labeltype;\r\n    __info_of__longestLabel: Info = {label:\"Longest label\", type:\"function(edge)=>string\",\r\n        readType: \"(edge:LEdge, segment: EdgeSegment, allNodes: DGraphElement[], allSegments: EdgeSegment[]) => PrimitiveType\",\r\n        writeType:\"string\",\r\n        txt: <span>Label assigned to the longest path segment.</span>}\r\n    __info_of__label: Info = {type: \"\", txt: <span>Alias for longestLabel</span>};\r\n    __info_of__labels: Info = {label:\"Multiple labels\", type: \"same type as longestLabel | longestLabel[]\",\r\n        writeType: \"string\",\r\n        txt: <span>Instructions to label to multiple or all path segments in an edge</span>\r\n    };\r\n\r\n\r\n    start!: LGraphElement;\r\n    __info_of__start: Info = {type: \"LVertex\", txt:\"the source point of the edge.\"}\r\n    get_start(c: Context): this['start'] { return LPointerTargetable.fromPointer(c.data.start); }\r\n    set_start(val: Pack1<LGraphElement>, c: Context): boolean {\r\n        let ptr = Pointers.from(val);\r\n        if (!ptr) { Log.exx(\"attempting to set an invalid LEdge.start: \" + ptr, {ptr, data: c.data}); return true; }\r\n        if (ptr === c.data.start) return true;\r\n        let name = this.get_name(c)||'';\r\n        TRANSACTION((name.toLowerCase().indexOf('edge')>=0 ? name : 'Edge: '+name)+'.start', ()=>{\r\n            SetFieldAction.new(c.data.id, 'start', ptr, '', true);\r\n        }, LPointerTargetable.from(c.data.start).name, LPointerTargetable.from(ptr).name)\r\n        return true;\r\n    }\r\n    end!: LGraphElement;\r\n    __info_of__end: Info = {type: \"LVertex\", txt:\"the terminal point of the edge.\"}\r\n    get_end(c: Context): this['end'] { return LPointerTargetable.fromPointer(c.data.end); }\r\n    set_end(val: Pack1<LGraphElement>, c: Context): boolean {\r\n        let ptr = Pointers.from(val);\r\n        if (!ptr) { Log.exx(\"attempting to set an invalid LEdge.end: \" + ptr, {ptr, data: c.data}); return true; }\r\n        if (ptr === c.data.end) return true;\r\n        let name = this.get_name(c)||'';\r\n        TRANSACTION((name.toLowerCase().indexOf('edge')>=0 ? name : 'Edge: '+name)+'.end', ()=>{\r\n            SetFieldAction.new(c.data.id, 'end', ptr, '', true);\r\n        }, LPointerTargetable.from(c.data.end).name, LPointerTargetable.from(ptr).name)\r\n        return true;\r\n    }\r\n\r\n\r\n    get_label(c: Context): this[\"longestLabel\"] { return this.get_longestLabel(c); }\r\n    set_label(val: DVoidEdge[\"longestLabel\"], c: Context): boolean { return this.set_longestLabel(val, c); }\r\n    get_longestLabel(c: Context): this[\"longestLabel\"] {\r\n        return transientProperties.node[c.data.id].longestLabel;\r\n        /*if (transientProperties.node[c.data.id].longestLabel !== undefined) return transientProperties.node[c.data.id].longestLabel;\r\n        else return transientProperties.view[c.data.view].longestLabel;*/\r\n    }\r\n    get_labels(c: Context): this[\"labels\"] {\r\n        return transientProperties.node[c.data.id].labels;\r\n        /*if (transientProperties.node[c.data.id].labels !== undefined) return transientProperties.node[c.data.id].labels;\r\n        else return transientProperties.view[c.data.view].labels;*/\r\n    }\r\n    set_longestLabel(val: DVoidEdge[\"longestLabel\"], c: Context): boolean {\r\n        Log.exDevv('Edge.labels are disabled, pass it through props instead');\r\n        if (val === c.data.longestLabel) return true;\r\n        let name = this.get_name(c)||'';\r\n        TRANSACTION((name.toLowerCase().indexOf('edge')>=0 ? name : 'Edge: '+name)+'.label', ()=>{\r\n            SetFieldAction.new(c.data, \"longestLabel\", val);\r\n            SetRootFieldAction.new(\"NODES_RECOMPILE_longestLabel+=\", c.data.id);\r\n        }, c.data.longestLabel, val);\r\n        return true;\r\n    }\r\n    set_labels(val: DVoidEdge[\"labels\"], c: Context): boolean {\r\n        Log.exDevv('Edge.labels are disabled, pass it through props instead');\r\n        if (val === c.data.labels) return true;\r\n        let name = this.get_name(c)||'';\r\n        TRANSACTION((name.toLowerCase().indexOf('edge')>=0 ? name : 'Edge: '+name)+'.labels', ()=>{\r\n            SetFieldAction.new(c.data, \"labels\", val);\r\n            SetRootFieldAction.new(\"NODES_RECOMPILE_labels+=\", c.data.id);\r\n        }, c.data.labels, val);\r\n        return true; }\r\n\r\n    public headPos_impl(c: Context, isHead: boolean, headSize0?: GraphPoint, segment0?: EdgeSegment, zoom0?: GraphPoint): GraphSize & {rad: number} {\r\n        let segment: EdgeSegment = segment0 || this.get_segments(c).segments[0];\r\n        // let v: LViewElement = this.get_view(c);\r\n        let tmp: any = headSize0 || (isHead ? this.get_view(c).edgeHeadSize : this.get_view(c).edgeTailSize);\r\n        if (!tmp || tmp.x === 0 || tmp.y === 0) {\r\n            // head or tail missing\r\n            tmp = new GraphSize(0, 0, 0, 0);\r\n            tmp.rad = 0;\r\n            return tmp;\r\n        }\r\n        let zoom: GraphPoint = zoom0 || this.get_graph(c).zoom;// ownZoom or cumulativeZoom?\r\n        let headPos: GraphSize & {rad: number} = (new GraphSize(0, 0, tmp.x, tmp.y) as any); //.multiply({w:zoom.x, h:zoom.y});\r\n        let useBezierPoints = true;\r\n        let start: GraphPoint, end: GraphPoint;\r\n        let m: number;\r\n        if (useBezierPoints) {\r\n            if (isHead) {\r\n                start = segment.end.pt;\r\n                end = (segment.bezier[segment.bezier.length - 1] || segment.start).pt;\r\n            } else {\r\n                start = segment.start.pt;\r\n                end = (segment.bezier[0] || segment.end).pt;\r\n            }\r\n            m = GraphPoint.getM(start, end);\r\n        } else {\r\n            if (isHead) { start = segment.end.pt; end = segment.start.pt; }\r\n            else { start = segment.start.pt; end = segment.end.pt; }\r\n            m = segment.m;\r\n        }\r\n        // first find the center of where it should be positioned\r\n        // let center: GraphPoint;\r\n        // let distance: number = Math.sqrt(headPos.w*headPos.w + headPos.h*headPos.h);\r\n        // let isVertical = m >=1 ;\r\n        let x4headsize = new GraphSize(start.x - headPos.w, start.y - headPos.h, headPos.w*2, headPos.h*2);\r\n        // first intersection is segment origin. second is found with the box containing all possible edgeHead positions that touch the startPoint\r\n        // (doing x4 his shape and placing 4 \"rectangles\" all around startPoint) to cover all possible segment directions.\r\n        // or finding first direction (vertical if m >1, horizontal if m<0) and vector direction and intersecting with only the \"correct\" placed edgeHead rectangle.\r\n        // then the intersection will likely not fall on the extreme angle of EdgeHead and i can re-center edgeHead\r\n        // so that first and second intersections are equal spaced with the center segment\r\n        let secondIntersection: GraphPoint | undefined;\r\n        let segmentDistance = start.distanceFromPoint(end);\r\n        if (segmentDistance <= Math.sqrt(headPos.w**2 + headPos.h**2)){\r\n            let safeDistance = Math.max(headPos.w, headPos.h)*5;\r\n            end = new GraphPoint( end.y + safeDistance, end.y + m * safeDistance); // move the point away so it doesn't intersect anymore. i just need direction\r\n            // too small to fit edgeHead, i simply put it centered on the whole segment\r\n            // secondIntersection = end;\r\n        }\r\n        secondIntersection = GraphSize.closestIntersection(x4headsize, start, end, undefined);\r\n        if (!secondIntersection) {\r\n           return Log.exDevv(\"failed to intersect edge head\", {x4headsize, segment, headPos, c, start, end, useBezierPoints});\r\n        }\r\n        tmp = secondIntersection.add(start, false).divide(2); // center of edgehead\r\n        headPos.x = tmp.x - headPos.w / 2; // tl corner\r\n        headPos.y = tmp.y - headPos.h / 2; // tl corner\r\n        headPos.rad = Geom.mToRad(m, start, end);\r\n        /*\r\n        devo trovare la distanza tra il centro dell'egeHead e il punto di inizio in termini assoluti, così tramite M trovo distanza in x e y. o trovarla in altro modo\r\n        if (segment.m === Number.POSITIVE_INFINITY || segment.m === Number.NEGATIVE_INFINITY) {\r\n            center = segment.start.pt.add({x:0, y: distance}, true); }\r\n        else { center = segment.start.pt.add({x:segment.m*headPos.w/2, y:segment.m*headPos.h/2\r\n         this is wrong, cannot be the same for x and y, i should invert the line equation for x?}, true); }\r\n        headPos.x = center.x - headPos.w / 2;\r\n        headPos.y = center.y - headPos.h / 2;*/\r\n        // console.log(\"head intersected\", {headPos, secondIntersection, x4headsize, segment, c, start, end, useBezierPoints});\r\n\r\n        return headPos;\r\n    }\r\n\r\n    public headPos(headSize0?: GraphPoint, segment0?: EdgeSegment, zoom0?: GraphPoint): GraphSize & {rad: number} {\r\n        return this.wrongAccessMessage(\"This is not headPos() implementation. it is just for typings. use the getter\"); }\r\n    public tailPos(headSize0?: GraphPoint, segment0?: EdgeSegment, zoom0?: GraphPoint): GraphSize & {rad: number} {\r\n        return this.wrongAccessMessage(\"This is not tailPos() implementation. it is just for typings. use the getter\"); }\r\n    protected get_headPos(c: Context): this[\"headPos\"] {\r\n        return (headSize?: GraphPoint, segment?: EdgeSegment, zoom?: GraphPoint) => this.headPos_impl(c, true, headSize, segment, zoom); }\r\n    protected get_tailPos(c: Context): this[\"tailPos\"] {\r\n        return (headSize?: GraphPoint, segment?: EdgeSegment, zoom?: GraphPoint) => this.headPos_impl(c, false, headSize, segment, zoom); }\r\n    protected get_allNodes(c: Context): this[\"allNodes\"] { return [this.get_start(c), ...this.get_midnodes(c), this.get_end(c)]; }\r\n\r\n    protected get_edge(c: Context): this{ return c.proxyObject as this; }\r\n    protected set_edge(v: any, c: Context): false { return this.cannotSet(\"edge field, on an edge element\"); }\r\n    protected get_midPoints(c: Context):this[\"midPoints\"] { return c.data.midPoints; }\r\n    public addMidPoint(v: this[\"midPoints\"][0]): boolean { return this.wrongAccessMessage(\"addMidPoint\"); }\r\n    protected get_addMidPoint(c: Context): (v: this[\"midPoints\"][0]) => boolean { return (v:this[\"midPoints\"][0]) => this.impl_addMidPoints(v, c); }\r\n    protected set_midPoints(val: this[\"midPoints\"], c: Context): boolean {\r\n        let name = this.get_name(c)||'';\r\n        TRANSACTION((name.toLowerCase().indexOf('edge')>=0 ? name : 'Edge: '+name)+'.midpoints', ()=>{\r\n            SetFieldAction.new(c.data.id, \"midPoints\", val, undefined, false);\r\n        });\r\n        return true;\r\n    }\r\n    protected impl_addMidPoints(val: this[\"midPoints\"][0], c: Context): boolean {\r\n        let name = this.get_name(c)||'';\r\n        TRANSACTION((name.toLowerCase().indexOf('edge')>=0 ? name : 'Edge: '+name)+' add midpoints', ()=>{\r\n           SetFieldAction.new(c.data.id, \"midPoints\", val, '+=', false);\r\n        });\r\n        return true;\r\n    }\r\n    protected get_label_impl(c: Context, segment: EdgeSegment, nodes: this[\"allNodes\"], segments: EdgeSegment[]): PrimitiveType | undefined {\r\n        let key: \"longestLabel\" | \"labels\" = segment.isLongest ? \"longestLabel\" : \"labels\"; // : keyof this\r\n        // if (isLongestSegment) return this.get_longestLabel_impl(d, l, nodes, index):\r\n        const d = c.data;\r\n        const l = c.proxyObject;\r\n        let labelmaker: any = (this as any)['get_'+key](c);\r\n        let labelmakerfunc: labelfunc = labelmaker as any;\r\n        // let lastSeg = segments[i-1];\r\n        switch (typeof labelmaker) {//nb{}[]<>\r\n            case \"number\":\r\n            case \"undefined\":\r\n            case \"boolean\":\r\n            case \"string\": return labelmaker;\r\n            // case \"function\": return nodes.map( (o, i) => d.labels(l, nodes, i)).slice(0, nodes.length-1);\r\n            // (e:LVoidEdge, segment: EdgeSegment, allNodes: LEdge[\"allNodes\"], allSegments: EdgeSegment[]) => PrimitiveType\r\n            case \"function\": return labelmakerfunc(l, segment, nodes, segments);\r\n            default: break;\r\n            case \"object\":\r\n                if (labelmaker === null) return null;\r\n                if (!Array.isArray(labelmaker)) break;\r\n                let elem = (labelmaker as PrimitiveType[])[segment.index % labelmaker.length];\r\n                if (typeof elem === \"function\") return (elem as labelfunc)(l, segment, nodes, segments);\r\n                return elem;\r\n        }\r\n        Log.exx(\"edge labels invalid type, must be a primitive value, a function or an array of such.\", {labelmaker, key, d});\r\n        return undefined;\r\n    }/*\r\n    private get_label_impl_old(d: DVoidEdge, l: LVoidEdge, nodes:this[\"allNodes\"], index: number, longestlabelindex?: number): PrimitiveType {\r\n        if (d.longestLabel !== undefined && index === longestlabelindex) return this.get_longestLabel_impl(d, l, nodes, index);\r\n        switch (typeof d.labels) {//nb{}[]<>\r\n            case \"number\":\r\n            case \"undefined\":\r\n            case \"boolean\":\r\n            case \"string\": return d.labels;\r\n            // case \"function\": return nodes.map( (o, i) => d.labels(l, nodes, i)).slice(0, nodes.length-1);\r\n            case \"function\": return d.labels(l, nodes[index], nodes[index+1], index, nodes);\r\n            default: break;\r\n            case \"object\": if (!Array.isArray(d.labels)) break;\r\n            if (typeof d.labels[0] === \"function\") return (d.labels as any)[index % d.labels.length](l, nodes[index], nodes[index+1], index, nodes);\r\n            return (d.labels as PrimitiveType[])[index % d.labels.length];\r\n        }\r\n        Log.exx(\"edge labels invalid type, must be a primitive value, a function or an array of such.\", d.labels);\r\n    }*/\r\n\r\n    __info_of__startPoint: Info = {type: \"GraphPoint\", txt:<span>startPoint of this.start (element originating the edge). Defaults in outer coordinates.</span>};\r\n    __info_of__endPoint: Info = {type: \"GraphPoint\", txt:<span>endPoint of this.end (element originating the edge). Defaults in outer coordinates.</span>};\r\n    public get_startPoint(context: Context): GraphPoint{ return this.get_startPoint_Outer(context); }\r\n    public get_endPoint(context: Context): GraphPoint{ return this.get_endPoint_Outer(context); }\r\n    public get_startPoint_Outer(c: Context): GraphPoint{\r\n        // console.log(\"get_edgeStart_Outer\", {out:this.get_outerGraph(c), pos:this.get_startPoint_inner(c), inner:this.get_start(c).innerGraph});\r\n        return this.get_outerGraph(c).translateSize(this.get_startPoint_inner(c), this.get_start(c).innerGraph);\r\n    }\r\n    public get_endPoint_Outer(c: Context): GraphPoint{\r\n        // console.log(\"get_edgeEnd_Outer\", {out:this.get_outerGraph(c), pos:this.get_endPoint_inner(c), inner:this.get_end(c).innerGraph});\r\n        return this.get_outerGraph(c).translateSize(this.get_endPoint_inner(c), this.get_end(c).innerGraph);\r\n    }\r\n\r\n    public get_startPoint_inner(c: Context): GraphPoint{ return this.get_edgeStartEnd_inner(c, true); }\r\n    public get_endPoint_inner(c: Context): GraphPoint{ return this.get_edgeStartEnd_inner(c, false); }\r\n    private get_edgeStartEnd_inner(c: Context, isStart: boolean): GraphPoint{ return isStart ? this.get_start(c).startPoint : this.get_end(c).endPoint; }\r\n    segments!: {all: EdgeSegment[], segments: EdgeSegment[], fillers: EdgeSegment[], head: GraphSize&{rad:number}, tail: GraphSize&{rad:number}};\r\n    segments_inner!: {all: EdgeSegment[], segments: EdgeSegment[], fillers: EdgeSegment[], head: GraphSize&{rad:number}, tail: GraphSize&{rad:number}};\r\n    segments_outer!: {all: EdgeSegment[], segments: EdgeSegment[], fillers: EdgeSegment[], head: GraphSize&{rad:number}, tail: GraphSize&{rad:number}};\r\n    __info_of__segments: Info = {type: \"{all:T, segments:T, fillers:T, head: GraphSize&{rad:number}, tail: as head} where T is EdgeSegment\",\r\n        txt:<span>Collection of segments connecting in order vertex and EdgePoint without intersecting their area, aimed to be rendered in svg path.\r\n            <br/>fillers are arcs generated by view.edgeGapMode being autofill, arcfill or linefill.\r\n            <br/>length of this.segments array is Math.ceil(allNodes.length / svg_letter_size) specified on view.\r\n            <br/>\"head\" and \"tail\" are the position and angle of eventual edge decorators. Refer to this.headPos documentation.</span>}\r\n\r\n    private svgLetterSize(s: string, addM: boolean = true, doublingMidPoints: boolean = true): {first:number, others: number} {\r\n        let ret: {first:number, others: number};\r\n        switch (s) {\r\n            default: ret = Log.exDevv(\"unexpected svg path letter: \\\"\" + s + \"\\\"\", s); break;\r\n            case EdgeBendingMode.Line:\r\n            //case EdgeBendingMode.Bezier_quadratic_mirrored:\r\n                ret = {first:1, others:1}; break;\r\n            case EdgeBendingMode.Bezier_quadratic:\r\n            //case EdgeBendingMode.Bezier_cubic_mirrored:\r\n                ret = {first:2, others:2}; break;\r\n            case EdgeBendingMode.Bezier_cubic: ret = {first:3, others:3}; break;\r\n            case EdgeBendingMode.Elliptical_arc: ret = {first:4, others:4}; break;\r\n\r\n            case EdgeBendingMode.Bezier_QT: ret = {first:2, others:1}; break;\r\n            case EdgeBendingMode.Bezier_CS: ret = {first:3, others:2}; break;\r\n        }\r\n\r\n        // account for the fact that every midpoint is listed twice: at anchor start and anchor end.\r\n        if (doublingMidPoints) {\r\n            // removing last point (first is already excluded because addM didn't trigger yet)\r\n            // , the remaining are midpoints to double. then i add it back\r\n            ret.first = (ret.first - 1) * 2 + 1;\r\n            ret.others = (ret.others - 1) * 2 + 1;\r\n        }\r\n\r\n        // account for the first M letter\r\n        //    (if the segment is not mode.gap or first, M coord still exist in segment but are ignored)\r\n        if (addM) {\r\n            ret.first += 1;\r\n            ret.others += 1;\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    // outer should be a redundant param and always == true\r\n    private get_points_impl(allNodes: LGraphElement[], outer: boolean, c:Context): segmentmaker[] {\r\n        function getAnchorOffset(size: GraphSize, offset: GraphPoint, isPercentage: boolean, $factor: number = 100) {\r\n            if (!size) size = new GraphSize(0, 0, 0, 0);\r\n            // else if (!size.tl) size = new GraphSize(size.x, size.y, size.w, size.h);\r\n            if (isPercentage) offset = new GraphPoint(offset.x/$factor*(size.w), offset.y/$factor*(size.h));\r\n            return size.tl().add(offset, false);\r\n        }\r\n        let innermost: LGraph = this.get_graph(c);\r\n        let root: LGraph = this.get_root(c);\r\n        const all: segmentmaker[] = allNodes.flatMap((ge, i) => {\r\n            let dge = ge.__raw;\r\n            let size = outer ? ge.outerSize : ge.innerSize;\r\n\r\n            if (outer && root && innermost && innermost.id !== root.id) {\r\n                size = innermost.translateSize(size, root);\r\n            }\r\n            let base: segmentmaker = {view: ge.view, size, ge, pt: null as any, uncutPt: null as any};\r\n\r\n            Log.exDev(typeof base.size !== \"object\", \"could not get node size:\", {base, c, outer})\r\n            let rets: segmentmaker | undefined;// = base as any;\r\n            let rete: segmentmaker | undefined;// = {...base} as any;\r\n            let debug = true;\r\n            if (debug) {\r\n                (base as any).anchor_e = dge.anchors[c.data.anchorEnd || 0] || dge.anchors[Object.keys(dge.anchors)[0]];\r\n                (base as any).anchor_s = dge.anchors[c.data.anchorStart || 0] || dge.anchors[Object.keys(dge.anchors)[0]];\r\n            }\r\n\r\n            // get endpoint, then startpoint (land on midnode, then depart from it)\r\n            if (i !== 0){\r\n                rete = {rete:true, ...base} as any as segmentmaker;\r\n                if (i === allNodes.length - 1) {\r\n                    // get end anchor from node\r\n                    let anchor = dge.anchors[c.data.anchorEnd || 0];\r\n                    if (!anchor) anchor = dge.anchors[Object.keys(dge.anchors)[0]];\r\n                    if (anchor) rete.pt = getAnchorOffset(rete.size, anchor, true, 1);\r\n                }\r\n                // if no anchor, treat the node as a midpoint\r\n                if (!rete.pt) {\r\n                    // get ending point from midpoint\r\n                    //rete.pt = (LEdgePoint.singleton as LEdgePoint).get_endPoint(undefined as any, rete.size, rete.view);\r\n                    rete.pt = getAnchorOffset(rete.size, rete.view.edgeStartOffset, rete.view.edgeStartOffset_isPercentage);\r\n                }\r\n                rete.uncutPt = rete.pt;\r\n            }\r\n            if (i !== allNodes.length - 1){\r\n                rets = {rets: true, ...base} as any as segmentmaker;\r\n                if (i === 0) {\r\n                    // get start anchor from node\r\n                    let anchor = dge.anchors[c.data.anchorStart || 0];\r\n                    if (!anchor) anchor = dge.anchors[Object.keys(dge.anchors)[0]];\r\n                    if (anchor) rets.pt = getAnchorOffset(rets.size, anchor, true, 1);\r\n                }\r\n                if (!rets.pt) {\r\n                    // rets starting point from midpoint\r\n                    // rets.pt = (LEdgePoint.singleton as LEdgePoint).get_startPoint(undefined as any, rets.size, rets.view);\r\n                    rets.pt = getAnchorOffset(rets.size, rets.view.edgeStartOffset, rets.view.edgeStartOffset_isPercentage);\r\n                }\r\n                rets.uncutPt = rets.pt;\r\n            }\r\n\r\n            // ret.pt = ge.startPoint\r\n            return rets && rete ? [rete, rets] : (rets ? [rets] : [rete as segmentmaker]); }\r\n        );\r\n\r\n        if (DVoidEdge.isFollowingCoords){\r\n            if (c.data.id === LVoidEdge.endFollow) {\r\n                let seg = all[all.length - 1];\r\n                seg.pt = DVoidEdge.isFollowingCoords;\r\n                seg.size = new GraphSize(seg.pt.x, seg.pt.y, 0.01, 0.01);\r\n            }\r\n            if (c.data.id === LVoidEdge.startFollow) {\r\n                let seg = all[0];\r\n                seg.pt = DVoidEdge.isFollowingCoords;\r\n                seg.size = new GraphSize(seg.pt.x, seg.pt.y, 0.01, 0.01);\r\n            }\r\n        }\r\n        return all;\r\n    }\r\n    private get_pointsDebug(c: Context): segmentmaker[]{ return this.get_points_impl(this.get_allNodes(c), true, c); }\r\n    private get_points(allNodes: LGraphElement[], outer: boolean = false, c: Context): segmentmaker[]{\r\n        return this.get_points_impl(allNodes, outer, c);\r\n    }\r\n    private get_points_outer(allNodes: LGraphElement[], c: Context): segmentmaker[]{ return this.get_points_impl(allNodes, true, c); }\r\n    // private get_points_inner(allNodes: LGraphElement[], c: Context): segmentmaker[]{ return this.get_points_impl(allNodes, false, c); }\r\n    public d!: string;\r\n    public __info_of__d: Info = {type: ShortAttribETypes.EString, txt:\"the full suggested path of SVG path \\\"d\\\" attribute, merging all segments.\"}\r\n    public get_d(c: Context) {\r\n        return this.get_segments(c).all.map(s => s.d).join(\" \");\r\n    }/*\r\n    private get_fillingSegments(c: Context): Partial<this[\"segments\"]> {\r\n        return this.get_segments(c).fillers;\r\n    }*/\r\n\r\n\r\n    public get_segments(c:Context): this[\"segments\"] {\r\n        return this.get_segments_outer(c);\r\n    }\r\n    public get_segments_outer(c:Context): this[\"segments\"] { return this.get_segments_impl(c, true); }\r\n    // public get_segments_inner(c: Context): this[\"segments\"] { return this.get_segments_impl(c, false); }\r\n    private get_segments_impl(c: Context, outer: boolean): this[\"segments\"] {\r\n        let l = c.proxyObject;\r\n        let v = this.get_view(c);\r\n        let allNodes = l.allNodes;\r\n        windoww.edge = l;\r\n        let all: segmentmaker[] = this.get_points(allNodes, outer, c);\r\n        //const all: {size: GraphSize, view: LViewElement, ge: LGraphElement}[] = allNodes.map((ge) => { return { view: ge.view, size: ge.size, ge}});\r\n        let ret: EdgeSegment[] = [];\r\n        let bm: EdgeBendingMode = v.bendingMode;\r\n        let gapMode: EdgeGapMode = v.edgeGapMode;\r\n        let segmentSize = this.svgLetterSize(bm, false, true);\r\n        let increase: number = segmentSize.first;\r\n        let segment: EdgeSegment | undefined = undefined;\r\n        /// grouping points according to SvgLetter\r\n        for (let i = 0; i < all.length - 1; ) {\r\n            // let start = all[i], end = all[i+increase];\r\n            let start: segmentmaker = all[i];\r\n            let endindex = (i+increase < all.length - 1) ? i+increase : all.length - 1;\r\n            let mid: segmentmaker[] = all.slice(i+1, endindex).filter( (e, i)=> i % 2 === 0);\r\n            let end: segmentmaker = all[endindex];\r\n            // makes sure the edge actually reaches his target even if there is an invalid amount of midnodes fot the current EdgeBendingMode\r\n            if (i === endindex && segment) start = segment.end;\r\n            // segment = this.get_segmentv3(start, mid, end, getSvgLetter(i), i, segment, all);\r\n            segment = new EdgeSegment(start, mid, end, bm, gapMode, i, segment);\r\n            // segment = this.get_segment(start.ge, start.size, start.view, end.ge, end.size, end.view, cut, v.bendingMode, mid, ret[ret.length -1], fillMode, segment);\r\n            ret.push(segment);\r\n            i+= increase+1; // because increase index is already inserted at the end of prev segment\r\n            if (increase !== segmentSize.others) increase = segmentSize.others;\r\n            // if (longestLabel !== undefined && longest < s.length) { longest = s.length; longestindex = i; } todo: move to after snapping to borders\r\n        }\r\n        function printablesegment(s:GObject) {\r\n            let r: GObject = {};\r\n            for (let k in s) {\r\n                let v = s[k];\r\n                v = v?.__raw || v;\r\n                if (typeof v === \"object\") r[k] = JSON.parse(JSON.stringify(v));\r\n                else r[k] = v;\r\n            }\r\n            return r;\r\n        }\r\n\r\n        let fillSegments: EdgeSegment[] = [];\r\n        this.snapSegmentsToNodeBorders(c, v, ret, fillSegments);\r\n        let longestLabel = c.data.longestLabel;\r\n        this.setLabels(c, ret, allNodes);\r\n        // console.log(\"getSegments() labeled:\", {main:ret, fillSegments});\r\n        let rett: this[\"segments\"] = {all: [...ret, ...fillSegments], segments: ret, fillers: fillSegments} as any;\r\n        /*switch(bm){\r\n            default: break;\r\n            case EdgeBendingMode.Bezier_QT:\r\n            case EdgeBendingMode.Bezier_CS:\r\n                rett.\r\n        }*/\r\n        for (let i = 0; i < rett.all.length; i++) {\r\n            let s = rett.all[i];\r\n            s.makeD(i, gapMode);\r\n        }\r\n        let zoom = new GraphPoint(1, 1);\r\n        rett.head = this.headPos_impl(c, true, v.edgeHeadSize, rett.segments[rett.segments.length - 1], zoom);\r\n        rett.tail = this.headPos_impl(c, false, v.edgeTailSize, rett.segments[0], zoom);\r\n        return rett;\r\n    }\r\n    private setLabels(c: Context, segments: EdgeSegment[], allNodes: this[\"allNodes\"]): void {\r\n        // find longest segment\r\n        let longestindex = -1;\r\n        let longest = 0;\r\n        for (let i = 0; i < segments.length; i++) {\r\n            let s = segments[i];\r\n            s.calcLength();\r\n            if (longest < s.length) { longest = s.length; longestindex = i; }\r\n            s.isLongest = false;\r\n        }\r\n        if (longestindex >= 0) segments[longestindex].isLongest = true;\r\n        // apply labels\r\n        for (let s of segments) s.label = this.get_label_impl(c, s, allNodes, segments);\r\n    }\r\n\r\n    private snapSegmentsToNodeBorders(c: Context, v: LViewElement, ret: EdgeSegment[], fillSegments: EdgeSegment[]){\r\n        // snap segment start and end to a node border\r\n        let canCutStart: boolean = v.edgeStartStopAtBoundaries,\r\n            canCutEnd: boolean = v.edgeEndStopAtBoundaries;\r\n        let grid: GraphPoint | undefined = undefined;\r\n        // let fillSegments: EdgeSegment[] = [];\r\n        let gapMode: EdgeGapMode = v.edgeGapMode;\r\n        let bm: EdgeBendingMode = v.bendingMode;\r\n\r\n\r\n        let ci: GraphPoint | undefined;\r\n        // cut i === 0 is cut regardless of gapmode.\r\n        if (canCutStart) {\r\n            ci = GraphSize.closestIntersection(ret[0].start.size, ret[0].start.pt, (ret[0].bezier[0] || ret[0].end).pt, grid);\r\n            if (ci) ret[0].start.pt = ci;\r\n            /*\r\n            ret[0].start.pt =\r\n                GraphSize.closestIntersection(ret[0].start.size, ret[0].start.pt, (ret[0].bezier[0] || ret[0].end).pt, grid) as any\r\n                || Geom.closestPoint(ret[0].start.size, ret[0].start.pt);*/\r\n        }\r\n\r\n        // cut middle segments maybe\r\n        let prev: EdgeSegment;\r\n        let curr: EdgeSegment = ret[0];\r\n\r\n        // if (gapMode === EdgeGapMode.gap) return;\r\n        if (canCutStart || canCutEnd) // do the for below\r\n            for (let i = 1; i < ret.length; i++){\r\n                prev = ret[i-1];\r\n                curr = ret[i];\r\n                let doStartCut: boolean, doEndCut: boolean;\r\n                switch(gapMode){/*\r\n                    case EdgeGapMode.arcFill:\r\n                    case EdgeGapMode.lineFill:\r\n                    case EdgeGapMode.autoFill:\r\n                        // same as gap, but will insert 1 more segment to fill the hole\r\n                        doStartCut = true;\r\n                        doEndCut = true;\r\n                        if (prev.end.pt.equals(curr.start.pt)) break;\r\n                        fillSegments.push(new EdgeFillSegment(\r\n                            prev.end,\r\n                            [\r\n                                {...prev.end, pt: EdgeSegment.invertLastBezierPt(prev.end.pt, (prev.bezier[prev.bezier.length-1] || prev.start).pt)},\r\n                                {...curr.start, pt: EdgeSegment.invertLastBezierPt(curr.start.pt, (curr.bezier[0] || curr.end).pt)}\r\n                            ],\r\n                            curr.start,\r\n                            bm, gapMode, 0, undefined));\r\n                            / *\r\n                            fillSegments.push(new FillEdgeSegment( // M <start_gap> C <bez1> <bez2> <end_gap>\r\n                               // <start_gap> = end of last seg (start of gap) <end_gap> = first of curr seg (end of gap)\r\n                            prev.end.pt,\r\n                            EdgeSegment.invertLastBezierPt(prev.end.pt, prev.bezier[prev.bezier.length-1].pt || prev.start.pt),\r\n                            EdgeSegment.invertLastBezierPt(curr.start.pt, curr.bezier[0].pt || curr.end.pt),\r\n                            curr.start.pt)* /\r\n\r\n                        break;*/\r\n                    case EdgeGapMode.gap:\r\n                        // just snap to vertex edge         prevSegment.endp and ret.startp\r\n                        doEndCut = true; doStartCut = true;\r\n                        break;\r\n                    // average: todo: maybe rename in join (merges start-end at closest pt to both (avg), then snap on edge)\r\n                    case \"closest\" as any: //EdgeGapMode.closest:\r\n                        // does not work properly, i think i need to get next.end instead of curr.end, just disabled for now\r\n                        let nextpt: GraphPoint = (curr.bezier[0] || curr.end).pt;\r\n                        let prevpt: GraphPoint = (prev.bezier[prev.bezier.length-1] || prev.start).pt;\r\n                        let midexternalpt = prevpt.add(nextpt, true);\r\n                        let midedgepoint = curr.start.size.tl().add(curr.start.size.br(), false).divide(2, false);\r\n                        // od average between the 2 points before and after that are not part of this edgepoint, then raw a line from there to center of ep, find that intersection.\r\n                        ci = GraphSize.closestIntersection(curr.start.size, midedgepoint, midexternalpt, grid);\r\n                        doEndCut = doStartCut = false;\r\n                        if (canCutEnd && ci) prev.end.pt = ci;\r\n                        if (canCutStart && ci) curr.start.pt = ci;\r\n                        break;\r\n                    case EdgeGapMode.average:\r\n                        // first move to average of the 2 points in the gap, then snap to edge\r\n                        doEndCut = true; doStartCut = true;\r\n                        // indipendent from cutStart, cutEnd.\r\n                        // they merge if just 1 of cutting sides are true. (and if they are both false we don't even enter the for loop)\r\n                        curr.start.pt = curr.start.pt.add(prev.end.pt, false).divide(2, false);\r\n                        prev.end.pt = curr.start.pt.duplicate(); // intentionally not the same pt because during snap to edge they can diverge again.\r\n                        prev.start.uncutPt = prev.start.pt;\r\n                        prev.end.uncutPt = prev.end.pt;\r\n                        break;\r\n                    // center: first move it to center of edgePoint/node, then snap to edge.\r\n                    // this mode might be as well deleted, it can be specified with anchor points\r\n                    case EdgeGapMode.center:\r\n                        doEndCut = false; doStartCut = false;\r\n                        curr.start.pt = curr.start.size.tl().add(curr.start.size.br(), false).divide(2, false);\r\n                        prev.end.pt = curr.start.pt.duplicate(); // intentionally not the same pt because during snap to edge they can diverge again.\r\n                        prev.start.uncutPt = prev.start.pt; // only update them when point moves without being cut (average and center)\r\n                        prev.end.uncutPt = prev.end.pt;\r\n                        break;\r\n                    default:\r\n                        return Log.exDevv(\"unexpected EdgeGapMode:\" + gapMode);\r\n                }\r\n                if (canCutStart && doStartCut){\r\n                    let nextpt: GraphPoint = (curr.bezier[0] || curr.end).pt;\r\n                    ci = GraphSize.closestIntersection(curr.start.size, curr.start.pt, nextpt, grid);\r\n                    if (ci) curr.start.pt = ci;// || Geom.closestPoint(curr.start.size, curr.start.pt);\r\n                    //if (gapMode === EdgeGapMode.average && prev) { prev.end.pt = curr.start.pt.add(prev.end.pt, false).divide(2, false); }\r\n                }\r\n                if (canCutEnd && doEndCut && prev){\r\n                    let prevpt: GraphPoint = (prev.bezier[prev.bezier.length-1] || prev.start).pt;\r\n                    ci = GraphSize.closestIntersection(prev.end.size, prev.end.pt, prevpt, grid);\r\n                    if (ci) prev.end.pt = ci;// || Geom.closestPoint(prev.end.size, prev.end.pt);\r\n                    // if average: first do average between start anchor points non-snapped. then i snap both,\r\n                    // then i do average again, and since it might snap out, i get closestPoint to EdgePoint size\r\n                    if (gapMode === EdgeGapMode.average) prev.end.pt = curr.start.pt =\r\n                        Geom.closestPoint(curr.start.size, curr.start.pt.add(prev.end.pt, false).divide(2, false));\r\n                }\r\n            }\r\n        // cut end of last segment regardless of gapMode\r\n        if (canCutEnd) {\r\n            let prevendpt = curr.end.pt;\r\n            ci = GraphSize.closestIntersection(curr.end.size, curr.end.pt, (curr.bezier[curr.bezier.length-1] || curr.start).pt, grid);\r\n            if (ci) curr.end.pt = ci; //|| Geom.closestPoint(prev.end.size, prev.end.pt);\r\n        }\r\n\r\n    }\r\n\r\n\r\n\r\n    get_edgeEnd(context: Context){ return this.get_edgeEnd_outer(context); }\r\n    get_edgeEnd_outer(c: Context){\r\n        // return this.get_outerGraph(c).translateSize(this.get_edgeEnd_inner(c), this.get_innerGraph(c));\r\n        return this.get_outerGraph(c).translateSize(this.get_edgeEnd_inner(c), this.get_end(c).innerGraph);\r\n    }\r\n    get_edgeEnd_inner(c: Context){\r\n        return this.get_edgeStartEnd_inner(c, false);\r\n        // return context.proxyObject.end?.size || new GraphPoint(0, 0);\r\n    }\r\n\r\n\r\n    protected get_midnodes(context: Context): this[\"midnodes\"] {\r\n        // return LPointerTargetable.wrapAll(context.data.midnodes);\r\n        return LPointerTargetable.wrapAll(context.data.subElements);\r\n    }\r\n    protected set_midnodes(val: D[\"midnodes\"], context: Context): boolean {\r\n\r\n        let name = this.get_name(context)||'';\r\n        TRANSACTION((name.toLowerCase().indexOf('edge')>=0 ? name : 'Edge: '+name)+'.midpoints', ()=>{\r\n            SetFieldAction.new(context.data.id, \"midnodes\", val, '', true);\r\n        });\r\n        return true;\r\n    }\r\n\r\n\r\n    anchorStart?: string;\r\n    anchorEnd?: string;\r\n    __info_of__anchorStart: Info = {writeType:\"string | undefined\", type:\"string\", isEdge: true,\r\n        txt:\"The name of a node anchor where the edge should originate from.\"};\r\n    __info_of__anchorEnd: Info = {writeType:\"string | undefined\", type:\"string\", isEdge: true,\r\n        txt:\"The name of a node anchor where the edge should point to.\"};\r\n    endFollow!: boolean;\r\n    startFollow!: boolean;\r\n    __info_of__endFollow: Info = {writeType:\"boolean\", readType:\"boolean\", type:\"boolean\", isEdge: true,// type:\"read:(()=>void), write:boolean\", readType:\"(()=>void))\",\r\n        txt:\"makes the ending point of an edge follow the cursor, so it can be assigned to a new anchor or target.\"};\r\n    __info_of__startFollow: Info = {writeType:\"boolean\", readType:\"boolean\", type:\"boolean\", isEdge: true,// type:\"read:(()=>void), write:boolean\", readType:\"(()=>void))\",\r\n        txt:\"makes the starting point of an edge follow the cursor, so it can be assigned to a new anchor or source.\"};\r\n    get_endFollow(c: Context): boolean { return (c.data.id === LVoidEdge.endFollow); }\r\n    get_startFollow(c: Context): boolean { return (c.data.id === LVoidEdge.startFollow); }\r\n    // // what in multieditor? needs to be moved in transientstuff?\r\n    set_endFollow(val: boolean, c: Context): boolean { return this._set_start_endFollow(val, c, false); }\r\n    set_startFollow(val: boolean, c: Context): boolean { return this._set_start_endFollow(val, c, true); }\r\n    _set_start_endFollow(val: boolean, c: Context, isStart: boolean): boolean {\r\n        val = !!val;\r\n        console.log(\"_set_start_endFollow\", {val, c, isStart});\r\n        if (val) {\r\n            if (isStart) LVoidEdge.startFollow = c.data.id;\r\n            else LVoidEdge.endFollow = c.data.id;\r\n            if (!LVoidEdge.following) {\r\n                console.log(\"_set_start_endFollow event attached\");\r\n                document.body.addEventListener(\"mousemove\", LVoidEdge.mousemove_pendingEdge, false);\r\n                document.body.addEventListener(\"keydown\", LVoidEdge.onKeyDown_pendingEdge, false);\r\n                LVoidEdge.following = true;\r\n                LVoidEdge.followingContext = c;\r\n                LVoidEdge.showAnchors();\r\n                (windoww.Tooltip as (typeof Tooltip)).show(<div>Changing anchor, press <b>Esc</b> to undo.</div>);\r\n\r\n                //let selector = \".Edge[nodeid='\" + (LVoidEdge.endFollow || LVoidEdge.startFollow as any)+\"']\";\r\n                // [...document.querySelectorAll(selector)].map(e=>e.classList.add(\"no-transition-following\")); gets refreshed by react\r\n                document.body.classList.add(\"no-transition-following\");\r\n            }\r\n        }\r\n        else {\r\n            if (LVoidEdge.following && ((isStart ? LVoidEdge.startFollow : LVoidEdge.endFollow) === c.data.id)) {\r\n                document.body.removeEventListener(\"mousemove\", LVoidEdge.mousemove_pendingEdge, false);\r\n                document.body.removeEventListener(\"keydown\", LVoidEdge.onKeyDown_pendingEdge, false);\r\n                let selector = \".Edge[nodeid='\" + (LVoidEdge.endFollow || LVoidEdge.startFollow as any)+\"']\";\r\n                //[...document.querySelectorAll(selector)].map(e=>e.classList.remove(\"no-transition-following\"));\r\n                document.body.classList.remove(\"no-transition-following\");\r\n                if (isStart) LVoidEdge.startFollow = undefined;\r\n                else LVoidEdge.endFollow = undefined;\r\n                LVoidEdge.following = false;\r\n                const $base = $(document.getElementById(isStart ? c.data.start : c.data.end) || []);\r\n                if (!$base.length) return true;\r\n                //const $deepAnchors = $base.find(\"[nodeid] .anchor\");\r\n                const $anchors = $base.find(\".anchor\")//.not($deepAnchors);\r\n                $anchors.removeClass([\"valid-anchor\", \"active-anchor\"]);\r\n                $base[0].style.overflow = '';\r\n                (windoww.Tooltip as (typeof Tooltip)).hide();\r\n            }\r\n        }\r\n        //SetFieldAction.new(c.data, \"startFollow\", !!val, '', false);\r\n        return true; }\r\n    public static startFollow: Pointer<DVoidEdge> | undefined = undefined;\r\n    public static endFollow: Pointer<DVoidEdge> | undefined = undefined;\r\n    public static following: boolean = false;\r\n    public static followingContext: LogicContext<DVoidEdge, LVoidEdge>;\r\n    public static tmp: number = 1;\r\n    public static canForceUpdate: boolean = true;\r\n    public static getCursorPos(e0: Event): Point { return new Point((e0 as any as MouseEvent).pageX, (e0 as any as MouseEvent).pageY); }\r\n    /*public static getGCursorPos(e0: Event): GraphPoint {\r\n        return LVLoidEdge.getCursorPos(e0).subtract(svgsize.tl(), true).multiply(svgzoom) as any as GraphPoint;\r\n    }*/\r\n    public static onKeyDown_pendingEdge(e: KeyboardEvent): void{\r\n        if (e.key === Keystrokes.escape) {\r\n            const c = LVoidEdge.followingContext;\r\n            if (!c || (!LVoidEdge.startFollow && !LVoidEdge.endFollow)) return;\r\n            let isStart = LVoidEdge.startFollow ? true : false;\r\n            let l = (c.proxyObject as any as LVoidEdge);\r\n            if (isStart) l.startFollow = false;\r\n            else l.endFollow = false;\r\n            // l.component?.forceUpdate(); does not work?\r\n            l.clonedCounter = (l.clonedCounter || 0) + 2;\r\n        }\r\n    }\r\n    public static showAnchors(): void{\r\n        const c = LVoidEdge.followingContext;\r\n        if (!c || (!LVoidEdge.startFollow && !LVoidEdge.endFollow)) return;\r\n        let isStart = LVoidEdge.startFollow ? true : false;\r\n        let nodeid: Pointer<DGraphElement> = isStart ? c.data.start : c.data.end;\r\n        let activeAnchor: string | number = (isStart ? c.data.anchorStart : c.data.anchorEnd) || 0;\r\n\r\n        const $base = $(document.getElementById(nodeid) || []);\r\n        if (!$base.length) return;\r\n        const $deepAnchors = $base.find(\"[nodeid] .anchor\");\r\n        const $anchors = $base.find(\".anchor\").not($deepAnchors);\r\n        $anchors.addClass(\"valid-anchor\");\r\n        $anchors.filter('[data-anchorname=\"'+activeAnchor+'\"]').addClass(\"active-anchor\");\r\n        $base[0].style.overflow = \"visible\";\r\n\r\n    }\r\n    private static mousemovei: number = 0;\r\n    public static mousemove_pendingEdge(e0: Event): void {\r\n        let forcererendermode = true;\r\n        if (forcererendermode) {\r\n            if (!LVoidEdge.following) return;\r\n            if (!LVoidEdge.canForceUpdate) return;\r\n            if (LVoidEdge.mousemovei++%30 === 0) LVoidEdge.showAnchors();\r\n\r\n\r\n            let c = LVoidEdge.followingContext;\r\n            let g: LGraph = c.proxyObject.graph;\r\n            let cursorPos = LVoidEdge.getCursorPos(e0);\r\n            let gcursorpos = g.translateHtmlSize(cursorPos);\r\n            // console.log(\"gcursorpos\", {cursorPos:cursorPos.toString(), gcursorpos:gcursorpos.toString(), g});\r\n            DVoidEdge.isFollowingCoords = gcursorpos;\r\n\r\n            let component: GraphElementComponent = GraphElementComponent.map[(LVoidEdge.startFollow || LVoidEdge.endFollow) as string];\r\n            LVoidEdge.canForceUpdate = false;\r\n            let timer = setTimeout(()=>{LVoidEdge.canForceUpdate = true; }, 5000);\r\n            let tn = transientProperties.node[c.data.id];\r\n            for (let vid in tn.viewScores) { // required to truly force an update\r\n                let tnv = tn.viewScores[vid];\r\n                tnv.jsxOutput = undefined;\r\n                tnv.usageDeclarations = undefined as any;\r\n                tnv.shouldUpdate = true;\r\n            }\r\n            component.setState({forceupdate:new Date().getDate()} as any, ()=>{LVoidEdge.canForceUpdate = true; clearTimeout(timer)});\r\n            // component.forceUpdate(()=>{LVoidEdge.canForceUpdate = true; clearTimeout(timer)});\r\n            return;\r\n        }\r\n\r\n        LVoidEdge.tmp++;\r\n        let selector = \".Edge[nodeid='\" + (LVoidEdge.endFollow || LVoidEdge.startFollow as any)+\"']\";\r\n        let root = document.querySelector(selector);\r\n        if (!root) return;\r\n        let paths: SVGPathElementt[] = [...root.querySelectorAll(\"path.full\")] as SVGPathElementt[];\r\n        let pathSegments = root.querySelectorAll(\"path.segment.preview\") as any as SVGPathElementt[];\r\n        // if (!paths.length) paths = pathSegments;\r\n        let pathSegmentContainers: Element[] = [...new Set([...pathSegments].map(e=>e.parentElement))] as Element[];\r\n        for (let container of pathSegmentContainers){\r\n            let se: SVGPathElementt[] = [...container.querySelectorAll(\"path.segment.preview\")] as SVGPathElementt[];\r\n            paths.push(se[LVoidEdge.endFollow ? se.length-1 : 0]);\r\n        }\r\n        let headTail = [...root.querySelectorAll(LVoidEdge.endFollow ? '.edgeHead' : '.edgeTail')] as HTMLElement[];\r\n        let cursorPos = LVoidEdge.getCursorPos(e0)\r\n\r\n        let segList: SVGPathSegment[] | undefined;\r\n        for (let p of paths) {\r\n            let svg: SVGElement = U.parentUntil(\"svg\", p) as SVGElement;\r\n            let svgsize: Size = Size.of(svg);\r\n            let svgzoom: Point = new Point(1,1); // todo: check viewbox and css zoom\r\n            let gcursorPos = cursorPos.subtract(svgsize.tl(), true).multiply(svgzoom) as any as GraphPoint;\r\n            segList = [...p.getPathData()];\r\n            let lastSeg = {...segList[LVoidEdge.endFollow ? segList.length-1 : 0]};\r\n            switch (lastSeg.type){\r\n                case 'a': case 'A':\r\n                    segList.push('fake new segment to get replaced instead of actual last segment which is A' as any);\r\n                    lastSeg.type=\"L\"; lastSeg.values = [gcursorPos.x, gcursorPos.y];\r\n                    break;\r\n                case \"C\": case \"c\": // bezier curves, keep type just change last point\r\n                case \"Q\": case \"q\":\r\n                case \"S\": case \"s\":\r\n                case \"T\": case \"t\":\r\n                    lastSeg.values[lastSeg.values.length-2] = gcursorPos.x;\r\n                    lastSeg.values[lastSeg.values.length-1] = gcursorPos.y; break;\r\n                case \"M\": case \"m\":\r\n                    lastSeg.type = LVoidEdge.endFollow ? \"L\" : \"M\";\r\n                    lastSeg.values = [gcursorPos.x, gcursorPos.y]; break;\r\n                case \"V\": case \"v\": // stuff forced to become a line\r\n                case \"H\": case \"h\":\r\n                case \"L\": case \"l\":\r\n                case \"Z\": case \"z\":\r\n                    lastSeg.type=\"L\"; lastSeg.values = [gcursorPos.x, gcursorPos.y];\r\n                    break;\r\n            }\r\n            segList[LVoidEdge.endFollow ? segList.length-1 : 0] = lastSeg;\r\n            if (LVoidEdge.tmp%20===0) console.log(\"svg set path data,\", {segList, oldSeglist:p.getPathData(), p});\r\n            p.setPathData(segList);\r\n        }\r\n\r\n        for (let ht of headTail){\r\n            let svg: SVGElement = U.parentUntil(\"svg\", ht) as SVGElement;\r\n            let svgsize: Size = Size.of(svg);\r\n            let svgzoom: Point = new Point(1,1); // todo: check viewbox and css zoom\r\n            let gcursorPos = cursorPos.subtract(svgsize.tl(), true).multiply(svgzoom) as any as GraphPoint;\r\n            let rotation: number;\r\n            let lastPt = segList && segList[LVoidEdge.endFollow ? segList.length-2 : 1].values;\r\n\r\n            if (lastPt) {\r\n                let m = gcursorPos.getM(new Point(lastPt[LVoidEdge.endFollow ? lastPt.length-2 : 1], lastPt[LVoidEdge.endFollow ? lastPt.length-1 : 0]));\r\n                if (Number.POSITIVE_INFINITY === m) rotation = Geom.degToRad(90); else\r\n                if (Number.NEGATIVE_INFINITY === m) rotation = Geom.degToRad(270); else\r\n                    rotation = Math.atan(m);\r\n                if (lastPt[LVoidEdge.endFollow ? lastPt.length-2 : 1] > gcursorPos.x) rotation -= Geom.degToRad(180);\r\n            } else { rotation = 0;}\r\n            let headSize = Size.of(ht);\r\n\r\n            let headPos = gcursorPos.subtract({x:headSize.w/2, y:headSize.h/2}, true);//.subtract({x:Math.cos(rotation)*headSize.w/2, y: -Math.sin(rotation)*headSize.h/2}, true);\r\n\r\n            if (LVoidEdge.tmp%20===0) console.log(\"_set_start_endFollow move head\", {selector:LVoidEdge.endFollow ? '.edgeHead' : '.edgeTail', headTail, root});\r\n            ht.style.transform = 'translate('+headPos.x+\"px, \"+headPos.y+\"px) rotate(\"+rotation+\"rad)\";\r\n        }\r\n    }\r\n}\r\nRuntimeAccessibleClass.set_extend(DGraphElement, DVoidEdge);\r\nRuntimeAccessibleClass.set_extend(LGraphElement, LVoidEdge);\r\n\r\n@RuntimeAccessible('DEdge')\r\nexport class DEdge extends DVoidEdge { // DVoidEdge\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // static singleton: LGraphElement;\r\n    // static logic: typeof LGraphElement;\r\n    // static structure: typeof DGraphElement;\r\n    id!: Pointer<DEdge, 1, 1, LEdge>;\r\n    graph!: Pointer<DGraph, 1, 1, LGraph>;\r\n    model!: Pointer<DModelElement, 0, 1, LModelElement>;\r\n    // isSelected: Dictionary<DocString<Pointer<DUser>>, boolean> = {};\r\n    isSelected!: Dictionary<DocString<Pointer<DUser>>, boolean>;\r\n    // containedIn!: Pointer<DGraphElement, 0, 1, LGraphElement>;\r\n    subElements!: Pointer<DGraphElement, 0, 'N', LGraphElement>;\r\n    state!: GObject;\r\n    start!: Pointer<DGraphElement, 1, 1, LGraphElement>;\r\n    end!: Pointer<DGraphElement, 1, 1, LGraphElement>;\r\n    __isDEdge!: true;\r\n    __isDVoidEdge!: true;\r\n    midnodes!: Pointer<DEdgePoint, 1, 1, LEdgePoint>[];\r\n}\r\n\r\n@RuntimeAccessible('LEdge')\r\nexport class LEdge<Context extends LogicContext<DEdge> = any, D extends DEdge = DEdge> extends LVoidEdge {\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // static singleton: LGraphElement;\r\n    // static logic: typeof LGraphElement;\r\n    // static structure: typeof DGraphElement;\r\n    __raw!: DEdge;\r\n    id!: Pointer<DEdge, 1, 1, LEdge>;\r\n    graph!: LGraph;\r\n    model?: LModelElement;\r\n    // isSelected: Dictionary<DocString<Pointer<DUser>>, boolean> = {};\r\n    isSelected(forUser?: Pointer<DUser>): boolean { return this.wrongAccessMessage(\"node.isSelected()\"); }\r\n    // containedIn!: LGraphElement;\r\n    subElements!: LGraphElement[];\r\n    _state!: GObject<\"proxified\">; // LMap;\r\n    midnodes!: LEdgePoint[];\r\n    __isLEdge!: true;\r\n    __isLVoidEdge!: true;\r\n\r\n}\r\nRuntimeAccessibleClass.set_extend(DVoidEdge, DEdge);\r\nRuntimeAccessibleClass.set_extend(LVoidEdge, LEdge);\r\n@Leaf\r\n@RuntimeAccessible('DExtEdge')\r\nexport class DExtEdge extends DEdge { // etends DEdge\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // static singleton: LGraphElement;\r\n    // static logic: typeof LGraphElement;\r\n    // static structure: typeof DGraphElement;\r\n    id!: Pointer<DExtEdge, 1, 1, LExtEdge>;\r\n    graph!: Pointer<DGraph, 1, 1, LGraph>;\r\n    model!: Pointer<DModelElement, 0, 1, LModelElement>;\r\n    // isSelected: Dictionary<DocString<Pointer<DUser>>, boolean> = {};\r\n    isSelected!: Dictionary<DocString<Pointer<DUser>>, boolean>;\r\n    // containedIn!: Pointer<DGraphElement, 0, 1, LGraphElement>;\r\n    subElements!: Pointer<DGraphElement, 0, 'N', LGraphElement>;\r\n    state!: GObject;\r\n    start!: Pointer<DGraphElement, 1, 1, LGraphElement>;\r\n    end!: Pointer<DGraphElement, 1, 1, LGraphElement>;\r\n    __isDExtEdge!: true;\r\n    __isDEdge!: true;\r\n    __isDVoidEdge!: true;\r\n    /*\r\n        public static new(model: DGraph[\"model\"], parentNodeID: DGraphElement[\"father\"], graphID: DGraphElement[\"graph\"], nodeID?: DGraphElement[\"id\"], size?: GraphSize): DExtEdge {\r\n            return new Constructors(new DExtEdge('dwc')).DPointerTargetable().DGraphElement(model, parentNodeID, graphID, nodeID)\r\n                .DVoidEdge().DEdge().DExtEdge().end();\r\n        }*/\r\n}\r\n\r\n@RuntimeAccessible('LExtEdge')\r\nexport class LExtEdge extends LEdge{\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // static singleton: LGraphElement;\r\n    // static logic: typeof LGraphElement;\r\n    // static structure: typeof DGraphElement;\r\n    __raw!: DExtEdge;\r\n    id!: Pointer<DExtEdge, 1, 1, LExtEdge>;\r\n    graph!: LGraph;\r\n    model?: LModelElement;\r\n    // isSelected: Dictionary<DocString<Pointer<DUser>>, boolean> = {};\r\n    isSelected(forUser?: Pointer<DUser>): boolean { return this.wrongAccessMessage(\"node.isSelected()\"); }\r\n    // containedIn!: LGraphElement;\r\n    subElements!: LGraphElement[];\r\n    _state!: GObject<\"proxified\">; // LMap;\r\n    start!: LGraphElement;\r\n    end!: LGraphElement;\r\n    __isLExtEdge!: true;\r\n    __isLEdge!: true;\r\n    __isLVoidEdge!: true;\r\n}\r\nRuntimeAccessibleClass.set_extend(DEdge, DExtEdge);\r\nRuntimeAccessibleClass.set_extend(LEdge, LExtEdge);\r\n@Leaf\r\n@RuntimeAccessible('DRefEdge')\r\nexport class DRefEdge extends DEdge { // extends DEdge\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    start!: Pointer<DGraphElement, 1, 1, LGraphElement>;\r\n    end!: Pointer<DGraphElement, 1, 1, LGraphElement>;\r\n    isSelected!: Dictionary<DocString<Pointer<DUser>>, boolean>;\r\n    __isDRefEdge!: true;\r\n    /*\r\n        public static new(model: DGraph[\"model\"], parentNodeID: DGraphElement[\"father\"], graphID: DGraphElement[\"graph\"], nodeID?: DGraphElement[\"id\"]): DRefEdge {\r\n            return new Constructors(new DRefEdge('dwc')).DPointerTargetable().DGraphElement(model, parentNodeID, graphID, nodeID)\r\n                .DVoidEdge().DEdge().DRefEdge().end();\r\n        }*/\r\n\r\n}\r\n@RuntimeAccessible('LRefEdge')\r\nexport class LRefEdge extends LEdge {\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // __raw!: DRefEdge;\r\n    start!: LGraphElement;\r\n    end!: LGraphElement;\r\n    __isLRefEdge!: true;\r\n}\r\nRuntimeAccessibleClass.set_extend(DEdge, DRefEdge);\r\nRuntimeAccessibleClass.set_extend(LEdge, LRefEdge);\r\n// for edges without a modelling element\r\n\r\n\r\n/*\r\n\r\nlet a = `DExtEdge, DRefEdge, DVoidEdge, LGraphVertex, LRefEdge, LEdgePoint, DVoidVertex, DGraphVertex, DEdgePoint,\r\n DVertex, DEdge, LVertex, LGraph, DGraph, LVoidVertex, LVoidEdge, LEdge, LGraphElement, LExtEdge, DGraphElement`;\r\n  // // ... get from export in index.ts\r\na = a.replaceAll(',,', \",\")\r\nlet aa = a.split(\",\").map(a => a.trim().substring(1));\r\n\r\nfunction onlyUnique(value, index, self) { return self.indexOf(value) === index; }\r\n\r\naa = aa.filter(onlyUnique).filter( a=> !!a)\r\nlet r = aa.filter(onlyUnique).filter( a=> !!a).map( a=> `export type W${a} = getWParams<L${a}, D${a}>;`).join('\\n')\r\ndocument.body.innerText = r;\r\n*/\r\nexport type WExtEdge = getWParams<LExtEdge, DExtEdge>;\r\nexport type WRefEdge = getWParams<LRefEdge, DRefEdge>;\r\nexport type WVoidEdge = getWParams<LVoidEdge, DVoidEdge>;\r\nexport type WGraphVertex = any; // getWParams<LGraphVertex, DGraphVertex>;\r\nexport type WEdgePoint = getWParams<LEdgePoint, DEdgePoint>;\r\nexport type WVoidVertex = getWParams<LVoidVertex, DVoidVertex>;\r\nexport type WVertex = getWParams<LVertex, DVertex>;\r\nexport type WEdge = getWParams<LEdge, DEdge>;\r\nexport type WGraph = getWParams<LGraph, DGraph>;\r\nexport type WGraphElement = getWParams<LGraphElement, DGraphElement>;\r\n\r\nconsole.warn('ts loading graphDataElement');\r\n\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}