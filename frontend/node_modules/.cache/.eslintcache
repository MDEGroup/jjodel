[{"C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\index.tsx":"1","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\App.tsx":"2","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\joiner\\index.ts":"3","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\components\\loader\\Loader.tsx":"4","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\components\\pathChecker\\PathChecker.tsx":"5","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\components\\alert\\Alert.tsx":"6","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\components\\alert\\Dialog.tsx":"7","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\components\\forEndUser\\ExternalLibraries.tsx":"8","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\components\\forEndUser\\Tooltip.tsx":"9","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\common\\libraries\\prj_json2xml.js":"10","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\common\\libraries\\prj_xml2json.js":"11","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\joiner\\types.ts":"12","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\joiner\\ExecuteOnRead.ts":"13","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\common\\Log.ts":"14","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\common\\UObj.ts":"15","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\joiner\\proxy.ts":"16","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\common\\Defaults.ts":"17","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\joiner\\classes.ts":"18","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\common\\Uhtml.ts":"19","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\common\\Geom.ts":"20","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\redux\\createStore.ts":"21","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\api\\data.ts":"22","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\redux\\action\\action.ts":"23","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\redux\\selectors\\selectors.ts":"24","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\redux\\reducer\\reducer.ts":"25","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\model\\classes\\D.ts":"26","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\model\\classes\\L.ts":"27","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\view\\viewPoint\\viewpoint.ts":"28","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\graph\\graphElement\\GraphDragHandler.ts":"29","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\joiner\\components.tsx":"30","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\common\\U.tsx":"31","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\common\\UX.tsx":"32","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\common\\DV.tsx":"33","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\redux\\store.tsx":"34","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\ocl\\ocl.tsx":"35","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\debugtools\\debug.tsx":"36","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\model\\dataStructure\\GraphDataElements.tsx":"37","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\pages\\components\\index.ts":"38","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\graph\\graphElement\\sharedTypes\\sharedTypes.tsx":"39","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\view\\viewElement\\view.tsx":"40","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\model\\logicWrapper\\LModelElement.tsx":"41","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\pages\\index.ts":"42","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\common\\Dummy.ts":"43","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\data\\storage.ts":"44","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\common\\SimpleTree.ts":"45","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\DSL\\DSL.ts":"46","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\components\\collaborative\\Collaborative.ts":"47","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\redux\\VersionFixer.ts":"48","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\iot\\IoT.ts":"49","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\redux\\defaults\\views.ts":"50","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\graph\\graphElement\\graphElement.tsx":"51","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\components\\forEndUser\\GenericInput.tsx":"52","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\components\\forEndUser\\Aliases.tsx":"53","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\components\\forEndUser\\Selector.tsx":"54","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\components\\forEndUser\\ControlPanel.tsx":"55","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\components\\forEndUser\\Overlap.tsx":"56","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\components\\forEndUser\\Input.tsx":"57","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\components\\forEndUser\\Try.tsx":"58","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\components\\forEndUser\\Control.tsx":"59","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\components\\forEndUser\\Measurable.tsx":"60","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\graph\\damedges\\damedge.tsx":"61","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\graph\\graph\\graphContainer.tsx":"62","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\graph\\vertex\\Shapes.tsx":"63","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\components\\logger\\DataOutput.tsx":"64","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\graph\\defaultNode\\DefaultNode.tsx":"65","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\graph\\vertex\\Vertex.tsx":"66","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\components\\logger\\loggerComponent.tsx":"67","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\pages\\components\\BottomBar.tsx":"68","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\pages\\components\\LeftBar.tsx":"69","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\pages\\components\\Project.tsx":"70","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\pages\\components\\Dashboard.tsx":"71","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\pages\\components\\Navbar.tsx":"72","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\pages\\Archive.tsx":"73","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\pages\\Community.tsx":"74","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\pages\\Project.tsx":"75","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\pages\\Profile.tsx":"76","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\pages\\Notes.tsx":"77","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\pages\\Settings.tsx":"78","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\pages\\ProjectsInfo.tsx":"79","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\pages\\Error.tsx":"80","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\pages\\Updates.tsx":"81","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\pages\\News.tsx":"82","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\pages\\Recent.tsx":"83","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\pages\\UsersInfo.tsx":"84","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\pages\\Templates.tsx":"85","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\pages\\Auth.tsx":"86","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\pages\\ConfirmAccount.tsx":"87","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\pages\\AllProjects.tsx":"88","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\pages\\Account.tsx":"89","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\api\\persistance\\index.ts":"90","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\components\\forEndUser\\SizeInput.tsx":"91","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\common\\libraries\\projectModified.ts":"92","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\components\\topbar\\SaveManager.ts":"93","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\components\\abstract\\DockManager.ts":"94","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\api\\DTO\\RegisterRequest.ts":"95","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\api\\DTO\\LoginRequest.ts":"96","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\api\\DTO\\ResetPasswordRequest.ts":"97","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\components\\collaborative\\CollaborativeAttacher.tsx":"98","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\api\\DTO\\ConfirmAccountRequest.ts":"99","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\pages\\components\\about\\About.tsx":"100","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\pages\\components\\menu\\Menu.tsx":"101","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\pages\\components\\cards\\Cards.tsx":"102","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\components\\topbar\\undoredocomponent.tsx":"103","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\components\\abstract\\tabs\\TabDataMaker.tsx":"104","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\pages\\components\\catalog\\Catalog.tsx":"105","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\pages\\components\\LatestUpdates.tsx":"106","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\hooks\\useQuery.ts":"107","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\pages\\components\\Edit\\Edit.tsx":"108","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\components\\logo.tsx":"109","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\components\\abstract\\Dock.tsx":"110","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\pages\\components\\icons\\Icons.tsx":"111","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\api\\persistance\\admin.ts":"112","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\components\\commandbar\\CommandBar.tsx":"113","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\api\\persistance\\auth.ts":"114","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\api\\persistance\\users.ts":"115","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\api\\persistance\\projects.ts":"116","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\components\\editors\\languages\\index.ts":"117","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\components\\abstract\\tabs\\MetamodelTab.tsx":"118","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\components\\abstract\\tabs\\ModelTab.tsx":"119","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\pages\\components\\popups\\index.ts":"120","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\components\\editors\\PermissionModelTab.tsx":"121","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\components\\editors\\MTM.tsx":"122","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\components\\editors\\Broker.tsx":"123","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\components\\abstract\\tabs\\ModelsSummaryTab.tsx":"124","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\api\\DTO\\Project.ts":"125","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\components\\editors\\NodeEditor.tsx":"126","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\api\\api.ts":"127","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\api\\memorec\\types.ts":"128","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\api\\DTO\\JwtClaims.ts":"129","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\components\\dock\\MyRcDock.tsx":"130","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\components\\editors\\languages\\Ocl.tsx":"131","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\components\\editors\\languages\\Jsx.tsx":"132","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\components\\editors\\languages\\Js.tsx":"133","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\components\\editors\\languages\\Javascript.tsx":"134","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\components\\editors\\index.ts":"135","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\pages\\components\\popups\\Model.tsx":"136","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\components\\metrics\\Metrics.tsx":"137","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\components\\contextMenu\\ContextMenu.tsx":"138","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\components\\editors\\Empty.tsx":"139","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\pages\\components\\popups\\Metamodel.tsx":"140","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\components\\dock\\MyDock.tsx":"141","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\components\\toolbar\\ToolBar.tsx":"142","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\components\\editors\\Skeleton.tsx":"143","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\model\\logicWrapper\\index.ts":"144","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\components\\editors\\views\\NestedView.tsx":"145","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\components\\editors\\Console.tsx":"146","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\components\\editors\\MetaData.tsx":"147","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\components\\editors\\Info.tsx":"148","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\components\\forEndUser\\ModellingIcon.tsx":"149","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\api\\memorec\\index.ts":"150","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\components\\forEndUser\\Tree.tsx":"151","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\components\\editors\\views\\ViewData.tsx":"152","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\components\\editors\\Collaborative.tsx":"153","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\components\\editors\\Logger.tsx":"154","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\components\\editors\\Settings.tsx":"155","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\components\\editors\\views\\data\\CustomData.tsx":"156","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\components\\editors\\views\\data\\InfoData.tsx":"157","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\components\\editors\\views\\data\\GenericNodeData.tsx":"158","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\components\\editors\\views\\data\\ComponentsTab.tsx":"159","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\components\\editors\\views\\data\\PermissionViewpointTab.tsx":"160","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\components\\editors\\views\\data\\PermissionViewTab.tsx":"161","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\components\\editors\\views\\data\\PaletteData.tsx":"162","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\components\\editors\\views\\data\\TemplateData.tsx":"163","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\components\\tooltip\\MyTooltip.tsx":"164","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\components\\editors\\views\\data\\NodeData.tsx":"165","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\components\\editors\\views\\data\\EdgePointData.tsx":"166","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\components\\editors\\views\\data\\FieldData.tsx":"167","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\components\\forEndUser\\Color.tsx":"168","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\components\\editors\\views\\data\\GraphData.tsx":"169","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\components\\editors\\views\\data\\EdgeData.tsx":"170","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\components\\forEndUser\\FunctionComponent.tsx":"171","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\components\\widgets\\Widgets.tsx":"172","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\api\\DTO\\ChangePasswordRequest.ts":"173","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\api\\DTO\\UpdateUserRequest.ts":"174"},{"size":725,"mtime":1742914483000,"results":"175","hashOfConfig":"176"},{"size":6894,"mtime":1744199359000,"results":"177","hashOfConfig":"176"},{"size":12017,"mtime":1742914488000,"results":"178","hashOfConfig":"176"},{"size":629,"mtime":1744185815000,"results":"179","hashOfConfig":"176"},{"size":520,"mtime":1742914487000,"results":"180","hashOfConfig":"176"},{"size":2667,"mtime":1742914484000,"results":"181","hashOfConfig":"176"},{"size":2795,"mtime":1742914484000,"results":"182","hashOfConfig":"176"},{"size":793,"mtime":1742914486000,"results":"183","hashOfConfig":"176"},{"size":11232,"mtime":1742914486000,"results":"184","hashOfConfig":"176"},{"size":1524,"mtime":1742914483000,"results":"185","hashOfConfig":"176"},{"size":6369,"mtime":1742914483000,"results":"186","hashOfConfig":"176"},{"size":10123,"mtime":1742914488000,"results":"187","hashOfConfig":"176"},{"size":4961,"mtime":1742914488000,"results":"188","hashOfConfig":"176"},{"size":8378,"mtime":1742914483000,"results":"189","hashOfConfig":"176"},{"size":9529,"mtime":1742914483000,"results":"190","hashOfConfig":"176"},{"size":23838,"mtime":1742914488000,"results":"191","hashOfConfig":"176"},{"size":1670,"mtime":1742914483000,"results":"192","hashOfConfig":"176"},{"size":183397,"mtime":1742914488000,"results":"193","hashOfConfig":"176"},{"size":1234,"mtime":1742914483000,"results":"194","hashOfConfig":"176"},{"size":54535,"mtime":1742914483000,"results":"195","hashOfConfig":"176"},{"size":357,"mtime":1742914490000,"results":"196","hashOfConfig":"176"},{"size":62293,"mtime":1742914483000,"results":"197","hashOfConfig":"176"},{"size":31753,"mtime":1742914490000,"results":"198","hashOfConfig":"176"},{"size":41257,"mtime":1742914490000,"results":"199","hashOfConfig":"176"},{"size":65899,"mtime":1743518444000,"results":"200","hashOfConfig":"176"},{"size":514,"mtime":1742914488000,"results":"201","hashOfConfig":"176"},{"size":341,"mtime":1742914488000,"results":"202","hashOfConfig":"176"},{"size":2365,"mtime":1742914491000,"results":"203","hashOfConfig":"176"},{"size":1505,"mtime":1742914488000,"results":"204","hashOfConfig":"176"},{"size":4575,"mtime":1742914488000,"results":"205","hashOfConfig":"176"},{"size":145458,"mtime":1743169089000,"results":"206","hashOfConfig":"176"},{"size":25622,"mtime":1742914483000,"results":"207","hashOfConfig":"176"},{"size":31847,"mtime":1742914483000,"results":"208","hashOfConfig":"176"},{"size":20899,"mtime":1742914490000,"results":"209","hashOfConfig":"176"},{"size":10394,"mtime":1742914488000,"results":"210","hashOfConfig":"176"},{"size":8477,"mtime":1742914487000,"results":"211","hashOfConfig":"176"},{"size":160900,"mtime":1742914488000,"results":"212","hashOfConfig":"176"},{"size":186,"mtime":1742914489000,"results":"213","hashOfConfig":"176"},{"size":9401,"mtime":1742914488000,"results":"214","hashOfConfig":"176"},{"size":86495,"mtime":1742914491000,"results":"215","hashOfConfig":"176"},{"size":362853,"mtime":1742914488000,"results":"216","hashOfConfig":"176"},{"size":703,"mtime":1743773058000,"results":"217","hashOfConfig":"176"},{"size":8811,"mtime":1742914483000,"results":"218","hashOfConfig":"176"},{"size":850,"mtime":1743158894000,"results":"219","hashOfConfig":"176"},{"size":5395,"mtime":1742914483000,"results":"220","hashOfConfig":"176"},{"size":2011,"mtime":1742914487000,"results":"221","hashOfConfig":"176"},{"size":292,"mtime":1742914484000,"results":"222","hashOfConfig":"176"},{"size":11920,"mtime":1742914490000,"results":"223","hashOfConfig":"176"},{"size":173,"mtime":1742914488000,"results":"224","hashOfConfig":"176"},{"size":25355,"mtime":1742914490000,"results":"225","hashOfConfig":"176"},{"size":71912,"mtime":1742914488000,"results":"226","hashOfConfig":"176"},{"size":13671,"mtime":1742914486000,"results":"227","hashOfConfig":"176"},{"size":578,"mtime":1742914485000,"results":"228","hashOfConfig":"176"},{"size":7815,"mtime":1742914486000,"results":"229","hashOfConfig":"176"},{"size":810,"mtime":1742914486000,"results":"230","hashOfConfig":"176"},{"size":2707,"mtime":1742914486000,"results":"231","hashOfConfig":"176"},{"size":25274,"mtime":1742914486000,"results":"232","hashOfConfig":"176"},{"size":9890,"mtime":1742914487000,"results":"233","hashOfConfig":"176"},{"size":8290,"mtime":1742914486000,"results":"234","hashOfConfig":"176"},{"size":27944,"mtime":1742914486000,"results":"235","hashOfConfig":"176"},{"size":5597,"mtime":1742914488000,"results":"236","hashOfConfig":"176"},{"size":4713,"mtime":1742914488000,"results":"237","hashOfConfig":"176"},{"size":12251,"mtime":1742914488000,"results":"238","hashOfConfig":"176"},{"size":4963,"mtime":1742914487000,"results":"239","hashOfConfig":"176"},{"size":9511,"mtime":1742914488000,"results":"240","hashOfConfig":"176"},{"size":27571,"mtime":1742914488000,"results":"241","hashOfConfig":"176"},{"size":13580,"mtime":1742914487000,"results":"242","hashOfConfig":"176"},{"size":3290,"mtime":1742914489000,"results":"243","hashOfConfig":"176"},{"size":9554,"mtime":1742914489000,"results":"244","hashOfConfig":"176"},{"size":11061,"mtime":1744283465850,"results":"245","hashOfConfig":"176"},{"size":19849,"mtime":1742914489000,"results":"246","hashOfConfig":"176"},{"size":29183,"mtime":1743177202000,"results":"247","hashOfConfig":"176"},{"size":326,"mtime":1742914488000,"results":"248","hashOfConfig":"176"},{"size":332,"mtime":1742914488000,"results":"249","hashOfConfig":"176"},{"size":5812,"mtime":1742914489000,"results":"250","hashOfConfig":"176"},{"size":1295,"mtime":1744199562000,"results":"251","hashOfConfig":"176"},{"size":10129,"mtime":1742914489000,"results":"252","hashOfConfig":"176"},{"size":329,"mtime":1742914489000,"results":"253","hashOfConfig":"176"},{"size":1110,"mtime":1742914489000,"results":"254","hashOfConfig":"176"},{"size":125,"mtime":1742914489000,"results":"255","hashOfConfig":"176"},{"size":9772,"mtime":1742914489000,"results":"256","hashOfConfig":"176"},{"size":328,"mtime":1742914489000,"results":"257","hashOfConfig":"176"},{"size":3153,"mtime":1742914489000,"results":"258","hashOfConfig":"176"},{"size":945,"mtime":1742914489000,"results":"259","hashOfConfig":"176"},{"size":10159,"mtime":1742914489000,"results":"260","hashOfConfig":"176"},{"size":33277,"mtime":1744101960000,"results":"261","hashOfConfig":"176"},{"size":3660,"mtime":1743782006000,"results":"262","hashOfConfig":"176"},{"size":5213,"mtime":1744199890000,"results":"263","hashOfConfig":"176"},{"size":12522,"mtime":1744042792000,"results":"264","hashOfConfig":"176"},{"size":144,"mtime":1742914483000,"results":"265","hashOfConfig":"176"},{"size":6162,"mtime":1742914486000,"results":"266","hashOfConfig":"176"},{"size":559,"mtime":1742914483000,"results":"267","hashOfConfig":"176"},{"size":8318,"mtime":1742914487000,"results":"268","hashOfConfig":"176"},{"size":864,"mtime":1742914484000,"results":"269","hashOfConfig":"176"},{"size":243,"mtime":1744101960000,"results":"270","hashOfConfig":"176"},{"size":79,"mtime":1742990227000,"results":"271","hashOfConfig":"176"},{"size":63,"mtime":1743410298000,"results":"272","hashOfConfig":"176"},{"size":1419,"mtime":1742914484000,"results":"273","hashOfConfig":"176"},{"size":84,"mtime":1743669157000,"results":"274","hashOfConfig":"176"},{"size":2012,"mtime":1742914489000,"results":"275","hashOfConfig":"176"},{"size":3137,"mtime":1742914489000,"results":"276","hashOfConfig":"176"},{"size":2165,"mtime":1742914489000,"results":"277","hashOfConfig":"176"},{"size":17105,"mtime":1742914487000,"results":"278","hashOfConfig":"176"},{"size":923,"mtime":1742914484000,"results":"279","hashOfConfig":"176"},{"size":7181,"mtime":1742914489000,"results":"280","hashOfConfig":"176"},{"size":910,"mtime":1742914489000,"results":"281","hashOfConfig":"176"},{"size":276,"mtime":1742914488000,"results":"282","hashOfConfig":"176"},{"size":23162,"mtime":1742914489000,"results":"283","hashOfConfig":"176"},{"size":975,"mtime":1742914483000,"results":"284","hashOfConfig":"176"},{"size":6582,"mtime":1742914484000,"results":"285","hashOfConfig":"176"},{"size":6488,"mtime":1742914489000,"results":"286","hashOfConfig":"176"},{"size":846,"mtime":1744283465858,"results":"287","hashOfConfig":"176"},{"size":4193,"mtime":1742914484000,"results":"288","hashOfConfig":"176"},{"size":2839,"mtime":1744102306000,"results":"289","hashOfConfig":"176"},{"size":3917,"mtime":1744042731000,"results":"290","hashOfConfig":"176"},{"size":11427,"mtime":1744283465819,"results":"291","hashOfConfig":"176"},{"size":148,"mtime":1742914485000,"results":"292","hashOfConfig":"176"},{"size":3532,"mtime":1742914484000,"results":"293","hashOfConfig":"176"},{"size":2725,"mtime":1742914484000,"results":"294","hashOfConfig":"176"},{"size":82,"mtime":1742914489000,"results":"295","hashOfConfig":"176"},{"size":2209,"mtime":1742914485000,"results":"296","hashOfConfig":"176"},{"size":9048,"mtime":1742914485000,"results":"297","hashOfConfig":"176"},{"size":4379,"mtime":1742914484000,"results":"298","hashOfConfig":"176"},{"size":4037,"mtime":1742914484000,"results":"299","hashOfConfig":"176"},{"size":310,"mtime":1743417039000,"results":"300","hashOfConfig":"176"},{"size":12397,"mtime":1742914485000,"results":"301","hashOfConfig":"176"},{"size":3659,"mtime":1744015589000,"results":"302","hashOfConfig":"176"},{"size":710,"mtime":1744028636000,"results":"303","hashOfConfig":"176"},{"size":209,"mtime":1744021510000,"results":"304","hashOfConfig":"176"},{"size":25377,"mtime":1742914484000,"results":"305","hashOfConfig":"176"},{"size":4091,"mtime":1742914485000,"results":"306","hashOfConfig":"176"},{"size":7351,"mtime":1742914485000,"results":"307","hashOfConfig":"176"},{"size":6214,"mtime":1742914485000,"results":"308","hashOfConfig":"176"},{"size":6865,"mtime":1742914485000,"results":"309","hashOfConfig":"176"},{"size":309,"mtime":1742914484000,"results":"310","hashOfConfig":"176"},{"size":2310,"mtime":1742914489000,"results":"311","hashOfConfig":"176"},{"size":11650,"mtime":1742914487000,"results":"312","hashOfConfig":"176"},{"size":13863,"mtime":1742914484000,"results":"313","hashOfConfig":"176"},{"size":304,"mtime":1742914484000,"results":"314","hashOfConfig":"176"},{"size":1891,"mtime":1742914489000,"results":"315","hashOfConfig":"176"},{"size":21692,"mtime":1742914484000,"results":"316","hashOfConfig":"176"},{"size":17129,"mtime":1742914487000,"results":"317","hashOfConfig":"176"},{"size":1484,"mtime":1742914485000,"results":"318","hashOfConfig":"176"},{"size":928,"mtime":1742914488000,"results":"319","hashOfConfig":"176"},{"size":13182,"mtime":1742914485000,"results":"320","hashOfConfig":"176"},{"size":27435,"mtime":1742914484000,"results":"321","hashOfConfig":"176"},{"size":2349,"mtime":1742914485000,"results":"322","hashOfConfig":"176"},{"size":25790,"mtime":1742914485000,"results":"323","hashOfConfig":"176"},{"size":2658,"mtime":1742914486000,"results":"324","hashOfConfig":"176"},{"size":2383,"mtime":1742914483000,"results":"325","hashOfConfig":"176"},{"size":11145,"mtime":1742914487000,"results":"326","hashOfConfig":"176"},{"size":5512,"mtime":1742914485000,"results":"327","hashOfConfig":"176"},{"size":4041,"mtime":1742914484000,"results":"328","hashOfConfig":"176"},{"size":13420,"mtime":1742914485000,"results":"329","hashOfConfig":"176"},{"size":1797,"mtime":1742914485000,"results":"330","hashOfConfig":"176"},{"size":5188,"mtime":1742914485000,"results":"331","hashOfConfig":"176"},{"size":6014,"mtime":1742914485000,"results":"332","hashOfConfig":"176"},{"size":2608,"mtime":1742914485000,"results":"333","hashOfConfig":"176"},{"size":1216,"mtime":1742914485000,"results":"334","hashOfConfig":"176"},{"size":2425,"mtime":1742914485000,"results":"335","hashOfConfig":"176"},{"size":2707,"mtime":1742914485000,"results":"336","hashOfConfig":"176"},{"size":45736,"mtime":1742914485000,"results":"337","hashOfConfig":"176"},{"size":2589,"mtime":1742914485000,"results":"338","hashOfConfig":"176"},{"size":1427,"mtime":1742914487000,"results":"339","hashOfConfig":"176"},{"size":5226,"mtime":1742914485000,"results":"340","hashOfConfig":"176"},{"size":2210,"mtime":1742914485000,"results":"341","hashOfConfig":"176"},{"size":2654,"mtime":1742914485000,"results":"342","hashOfConfig":"176"},{"size":6403,"mtime":1742914486000,"results":"343","hashOfConfig":"176"},{"size":1437,"mtime":1742914485000,"results":"344","hashOfConfig":"176"},{"size":2166,"mtime":1742914485000,"results":"345","hashOfConfig":"176"},{"size":17630,"mtime":1742914486000,"results":"346","hashOfConfig":"176"},{"size":2285,"mtime":1742914487000,"results":"347","hashOfConfig":"176"},{"size":147,"mtime":1744042758000,"results":"348","hashOfConfig":"176"},{"size":214,"mtime":1743693001000,"results":"349","hashOfConfig":"176"},{"filePath":"350","messages":"351","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"9afb92",{"filePath":"352","messages":"353","errorCount":0,"fatalErrorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"354"},{"filePath":"355","messages":"356","errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"357"},{"filePath":"358","messages":"359","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"360","messages":"361","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"362"},{"filePath":"363","messages":"364","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"365","messages":"366","errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"367"},{"filePath":"368","messages":"369","errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"370"},{"filePath":"371","messages":"372","errorCount":0,"fatalErrorCount":0,"warningCount":17,"fixableErrorCount":0,"fixableWarningCount":0,"source":"373"},{"filePath":"374","messages":"375","errorCount":0,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"376"},{"filePath":"377","messages":"378","errorCount":0,"fatalErrorCount":0,"warningCount":16,"fixableErrorCount":0,"fixableWarningCount":0,"source":"379"},{"filePath":"380","messages":"381","errorCount":0,"fatalErrorCount":0,"warningCount":12,"fixableErrorCount":0,"fixableWarningCount":0,"source":"382"},{"filePath":"383","messages":"384","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"385"},{"filePath":"386","messages":"387","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"388"},{"filePath":"389","messages":"390","errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"391"},{"filePath":"392","messages":"393","errorCount":0,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"394"},{"filePath":"395","messages":"396","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"397"},{"filePath":"398","messages":"399","errorCount":0,"fatalErrorCount":0,"warningCount":60,"fixableErrorCount":0,"fixableWarningCount":0,"source":"400"},{"filePath":"401","messages":"402","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"403","messages":"404","errorCount":0,"fatalErrorCount":0,"warningCount":21,"fixableErrorCount":0,"fixableWarningCount":0,"source":"405"},{"filePath":"406","messages":"407","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"408","messages":"409","errorCount":0,"fatalErrorCount":0,"warningCount":14,"fixableErrorCount":0,"fixableWarningCount":0,"source":"410"},{"filePath":"411","messages":"412","errorCount":0,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"413"},{"filePath":"414","messages":"415","errorCount":0,"fatalErrorCount":0,"warningCount":15,"fixableErrorCount":0,"fixableWarningCount":0,"source":"416"},{"filePath":"417","messages":"418","errorCount":0,"fatalErrorCount":0,"warningCount":31,"fixableErrorCount":0,"fixableWarningCount":0,"source":"419"},{"filePath":"420","messages":"421","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"422","messages":"423","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"424","messages":"425","errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"426"},{"filePath":"427","messages":"428","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"429","messages":"430","errorCount":0,"fatalErrorCount":0,"warningCount":14,"fixableErrorCount":0,"fixableWarningCount":0,"source":"431"},{"filePath":"432","messages":"433","errorCount":0,"fatalErrorCount":0,"warningCount":56,"fixableErrorCount":0,"fixableWarningCount":0,"source":"434"},{"filePath":"435","messages":"436","errorCount":0,"fatalErrorCount":0,"warningCount":11,"fixableErrorCount":0,"fixableWarningCount":0,"source":"437"},{"filePath":"438","messages":"439","errorCount":0,"fatalErrorCount":0,"warningCount":12,"fixableErrorCount":0,"fixableWarningCount":0,"source":"440"},{"filePath":"441","messages":"442","errorCount":0,"fatalErrorCount":0,"warningCount":52,"fixableErrorCount":0,"fixableWarningCount":0,"source":"443"},{"filePath":"444","messages":"445","errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"446"},{"filePath":"447","messages":"448","errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"449"},{"filePath":"450","messages":"451","errorCount":0,"fatalErrorCount":0,"warningCount":30,"fixableErrorCount":0,"fixableWarningCount":0,"source":"452"},{"filePath":"453","messages":"454","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"455","messages":"456","errorCount":0,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"457"},{"filePath":"458","messages":"459","errorCount":0,"fatalErrorCount":0,"warningCount":11,"fixableErrorCount":0,"fixableWarningCount":0,"source":"460"},{"filePath":"461","messages":"462","errorCount":0,"fatalErrorCount":0,"warningCount":70,"fixableErrorCount":0,"fixableWarningCount":5,"source":"463"},{"filePath":"464","messages":"465","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"466","messages":"467","errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"468"},{"filePath":"469","messages":"470","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"471","messages":"472","errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"473"},{"filePath":"474","messages":"475","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"476","messages":"477","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"478","messages":"479","errorCount":0,"fatalErrorCount":0,"warningCount":21,"fixableErrorCount":0,"fixableWarningCount":0,"source":"480"},{"filePath":"481","messages":"482","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"483","messages":"484","errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"485"},{"filePath":"486","messages":"487","errorCount":0,"fatalErrorCount":0,"warningCount":20,"fixableErrorCount":0,"fixableWarningCount":0,"source":"488"},{"filePath":"489","messages":"490","errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"491"},{"filePath":"492","messages":"493","errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"494"},{"filePath":"495","messages":"496","errorCount":0,"fatalErrorCount":0,"warningCount":12,"fixableErrorCount":0,"fixableWarningCount":0,"source":"497"},{"filePath":"498","messages":"499","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"500","messages":"501","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"502","messages":"503","errorCount":0,"fatalErrorCount":0,"warningCount":16,"fixableErrorCount":0,"fixableWarningCount":0,"source":"504"},{"filePath":"505","messages":"506","errorCount":0,"fatalErrorCount":0,"warningCount":12,"fixableErrorCount":0,"fixableWarningCount":1,"source":"507"},{"filePath":"508","messages":"509","errorCount":0,"fatalErrorCount":0,"warningCount":11,"fixableErrorCount":0,"fixableWarningCount":0,"source":"510"},{"filePath":"511","messages":"512","errorCount":0,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"513"},{"filePath":"514","messages":"515","errorCount":0,"fatalErrorCount":0,"warningCount":20,"fixableErrorCount":0,"fixableWarningCount":0,"source":"516"},{"filePath":"517","messages":"518","errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"519"},{"filePath":"520","messages":"521","errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"522"},{"filePath":"523","messages":"524","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"525"},{"filePath":"526","messages":"527","errorCount":0,"fatalErrorCount":0,"warningCount":29,"fixableErrorCount":0,"fixableWarningCount":0,"source":"528"},{"filePath":"529","messages":"530","errorCount":0,"fatalErrorCount":0,"warningCount":14,"fixableErrorCount":0,"fixableWarningCount":0,"source":"531"},{"filePath":"532","messages":"533","errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"534"},{"filePath":"535","messages":"536","errorCount":0,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"537"},{"filePath":"538","messages":"539","errorCount":0,"fatalErrorCount":0,"warningCount":10,"fixableErrorCount":0,"fixableWarningCount":0,"source":"540"},{"filePath":"541","messages":"542","errorCount":0,"fatalErrorCount":0,"warningCount":8,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"543","messages":"544","errorCount":0,"fatalErrorCount":0,"warningCount":12,"fixableErrorCount":0,"fixableWarningCount":0,"source":"545"},{"filePath":"546","messages":"547","errorCount":0,"fatalErrorCount":0,"warningCount":13,"fixableErrorCount":0,"fixableWarningCount":0,"source":"548"},{"filePath":"549","messages":"550","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"551","messages":"552","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"553","messages":"554","errorCount":0,"fatalErrorCount":0,"warningCount":12,"fixableErrorCount":0,"fixableWarningCount":0,"source":"555"},{"filePath":"556","messages":"557","errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"558"},{"filePath":"559","messages":"560","errorCount":0,"fatalErrorCount":0,"warningCount":18,"fixableErrorCount":0,"fixableWarningCount":0,"source":"561"},{"filePath":"562","messages":"563","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"564","messages":"565","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"566"},{"filePath":"567","messages":"568","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"569","messages":"570","errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"571"},{"filePath":"572","messages":"573","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"574","messages":"575","errorCount":0,"fatalErrorCount":0,"warningCount":12,"fixableErrorCount":0,"fixableWarningCount":0,"source":"576"},{"filePath":"577","messages":"578","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"579","messages":"580","errorCount":0,"fatalErrorCount":0,"warningCount":18,"fixableErrorCount":0,"fixableWarningCount":0,"source":"581"},{"filePath":"582","messages":"583","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"584"},{"filePath":"585","messages":"586","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"587"},{"filePath":"588","messages":"589","errorCount":0,"fatalErrorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"590"},{"filePath":"591","messages":"592","errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"593"},{"filePath":"594","messages":"595","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"596","messages":"597","errorCount":0,"fatalErrorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"598"},{"filePath":"599","messages":"600","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"601","messages":"602","errorCount":0,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"603"},{"filePath":"604","messages":"605","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"606"},{"filePath":"607","messages":"608","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"609","messages":"610","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"611","messages":"612","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"613","messages":"614","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"615"},{"filePath":"616","messages":"617","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"618","messages":"619","errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"620"},{"filePath":"621","messages":"622","errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"623"},{"filePath":"624","messages":"625","errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"626"},{"filePath":"627","messages":"628","errorCount":0,"fatalErrorCount":0,"warningCount":11,"fixableErrorCount":0,"fixableWarningCount":0,"source":"629"},{"filePath":"630","messages":"631","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"632","messages":"633","errorCount":0,"fatalErrorCount":0,"warningCount":11,"fixableErrorCount":0,"fixableWarningCount":0,"source":"634"},{"filePath":"635","messages":"636","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"637","messages":"638","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"639","messages":"640","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"641"},{"filePath":"642","messages":"643","errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"644"},{"filePath":"645","messages":"646","errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"647"},{"filePath":"648","messages":"649","errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"650"},{"filePath":"651","messages":"652","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"653","messages":"654","errorCount":0,"fatalErrorCount":0,"warningCount":8,"fixableErrorCount":0,"fixableWarningCount":0,"source":"655"},{"filePath":"656","messages":"657","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"658"},{"filePath":"659","messages":"660","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"661"},{"filePath":"662","messages":"663","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"664","messages":"665","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"666","messages":"667","errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"668"},{"filePath":"669","messages":"670","errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"671"},{"filePath":"672","messages":"673","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"674","messages":"675","errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"676"},{"filePath":"677","messages":"678","errorCount":0,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"679"},{"filePath":"680","messages":"681","errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"682"},{"filePath":"683","messages":"684","errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"685"},{"filePath":"686","messages":"687","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"688","messages":"689","errorCount":0,"fatalErrorCount":0,"warningCount":10,"fixableErrorCount":0,"fixableWarningCount":0,"source":"690"},{"filePath":"691","messages":"692","errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"693"},{"filePath":"694","messages":"695","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"696","messages":"697","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"698","messages":"699","errorCount":0,"fatalErrorCount":0,"warningCount":9,"fixableErrorCount":0,"fixableWarningCount":0,"source":"700"},{"filePath":"701","messages":"702","errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"703"},{"filePath":"704","messages":"705","errorCount":0,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"706"},{"filePath":"707","messages":"708","errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"709"},{"filePath":"710","messages":"711","errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"712"},{"filePath":"713","messages":"714","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"715","messages":"716","errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"717"},{"filePath":"718","messages":"719","errorCount":0,"fatalErrorCount":0,"warningCount":19,"fixableErrorCount":0,"fixableWarningCount":0,"source":"720"},{"filePath":"721","messages":"722","errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"723"},{"filePath":"724","messages":"725","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"726","messages":"727","errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"728"},{"filePath":"729","messages":"730","errorCount":0,"fatalErrorCount":0,"warningCount":13,"fixableErrorCount":0,"fixableWarningCount":0,"source":"731"},{"filePath":"732","messages":"733","errorCount":0,"fatalErrorCount":0,"warningCount":19,"fixableErrorCount":0,"fixableWarningCount":0,"source":"734"},{"filePath":"735","messages":"736","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"737"},{"filePath":"738","messages":"739","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"740","messages":"741","errorCount":0,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"742"},{"filePath":"743","messages":"744","errorCount":0,"fatalErrorCount":0,"warningCount":9,"fixableErrorCount":0,"fixableWarningCount":0,"source":"745"},{"filePath":"746","messages":"747","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"748","messages":"749","errorCount":0,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"750"},{"filePath":"751","messages":"752","errorCount":0,"fatalErrorCount":0,"warningCount":9,"fixableErrorCount":0,"fixableWarningCount":0,"source":"753"},{"filePath":"754","messages":"755","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"756","messages":"757","errorCount":0,"fatalErrorCount":0,"warningCount":8,"fixableErrorCount":0,"fixableWarningCount":0,"source":"758"},{"filePath":"759","messages":"760","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"761","messages":"762","errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"763"},{"filePath":"764","messages":"765","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"766","messages":"767","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"768"},{"filePath":"769","messages":"770","errorCount":0,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"771"},{"filePath":"772","messages":"773","errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"774"},{"filePath":"775","messages":"776","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"777","messages":"778","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"779","messages":"780","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"781","messages":"782","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"783","messages":"784","errorCount":0,"fatalErrorCount":0,"warningCount":8,"fixableErrorCount":0,"fixableWarningCount":0,"source":"785"},{"filePath":"786","messages":"787","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"788","messages":"789","errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"790"},{"filePath":"791","messages":"792","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"793","messages":"794","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"795","messages":"796","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"797"},{"filePath":"798","messages":"799","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"800"},{"filePath":"801","messages":"802","errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"803"},{"filePath":"804","messages":"805","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"806","messages":"807","errorCount":0,"fatalErrorCount":0,"warningCount":15,"fixableErrorCount":0,"fixableWarningCount":0,"source":"808"},{"filePath":"809","messages":"810","errorCount":0,"fatalErrorCount":0,"warningCount":8,"fixableErrorCount":0,"fixableWarningCount":0,"source":"811"},{"filePath":"812","messages":"813","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"814","messages":"815","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\index.tsx",[],"C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\App.tsx",["816","817","818","819","820","821","822"],"import React, {Dispatch, useState} from 'react';\r\nimport './App.scss';\r\nimport './styles/view.scss';\r\nimport './styles/style.scss';\r\nimport {DState, DUser, LUser, Pointer, R, SetRootFieldAction, statehistory, stateInitializer, Try, U} from \"./joiner\";\r\nimport {connect} from \"react-redux\";\r\nimport Loader from \"./components/loader/Loader\";\r\nimport {FakeStateProps} from \"./joiner/types\";\r\nimport {useEffectOnce} from \"usehooks-ts\";\r\nimport {HashRouter, BrowserRouter, Route, Routes} from 'react-router-dom';\r\nimport PathChecker from \"./components/pathChecker/PathChecker\";\r\n\r\nimport {\r\n    AccountPage,\r\n    AllProjectsPage,\r\n    ArchivePage,\r\n    AuthPage,\r\n    CommunityPage, NewsPage,\r\n    NotesPage,\r\n    ProfilePage,\r\n    ProjectPage, ProjectsInfoPage,\r\n    RecentPage,\r\n    SettingsPage,\r\n    TemplatePage,\r\n    UpdatesPage, UsersInfoPage,\r\n    ConfirmAccount\r\n} from \"./pages\";\r\n\r\nimport {ExternalLibraries} from \"./components/forEndUser/ExternalLibraries\";\r\nimport {TooltipVisualizer} from \"./components/forEndUser/Tooltip\";\r\nimport {BottomBar} from \"./pages/components\";\r\nimport AlertVisualizer from \"./components/alert/Alert\";\r\nimport DialogVisualizer from './components/alert/Dialog';\r\n\r\n\r\n\r\nlet firstLoading = true;\r\nlet browserData = U.getOSBrowserData();\r\n\r\n\r\nfunction App(props: AllProps): JSX.Element {\r\n    //const debug = props.debug;\r\n    const isLoading = props.isLoading;\r\n    let [user, updateUser] = useState(DUser.current);\r\n    let [useless, forceUpdate] = useState(0);\r\n    console.log('forceupdate app', {pu: props.user, u:DUser.current})\r\n\r\n    /*\r\n    const tooltip = props.tooltip;\r\n    let user: LUser = LPointerTargetable.wrap(user);\r\n    useEffectOnce(() => {\r\n        console.log(\"ALFI: App useEffectOnce\");\r\n        // SetRootFieldAction.new('isLoading', true);\r\n        // stateInitializer().then(() => SetRootFieldAction.new('isLoading', false));\r\n    });*/\r\n\r\n    //let user = LUser.fromPointer(DUser.current);\r\n    if (firstLoading) {\r\n        firstLoading = false;\r\n        console.log(\"entro in app.tsx nel costrutto per verificare se è il firstLoading\");\r\n        stateInitializer().then(()=> {console.log('forceupdate trigger', {'#':window.location.hash, o:{pu:props.user, u:DUser.current}});\r\n            updateUser(DUser.current);\r\n            forceUpdate(1);\r\n\r\n        });\r\n        return <Loader/>;\r\n    }\r\n    if (U.navigating) return <Loader/>;\r\n    console.log('forceupdate done', {pu:props.user, u:DUser.current});\r\n\r\n    if (DUser.current !== user) updateUser(DUser.current);\r\n    if (browserData.browser === 'Firefox') U.alert('e', 'Unsupported browser',\r\n        'Firefox is not supported yet and have known issues.\\nplease open this website on another browser.');\r\n    return (<>\r\n        <div className={\"router-wrapper\"}>\r\n            {isLoading && <Loader/>}\r\n            <ExternalLibraries/>\r\n            <Try><TooltipVisualizer/></Try>\r\n\r\n            {/*<MessageVisualizer />*/}\r\n            <Try><AlertVisualizer/></Try>\r\n            <Try><DialogVisualizer/></Try>\r\n            <HashRouter>\r\n                <Try><PathChecker/></Try>\r\n                <Try><Routes>\r\n\r\n                    {user ? <>\r\n                        <Route path={'allProjects'} element={<AllProjectsPage/>}/>\r\n                        {/*<Route path={'dock'} element={<MyDock />} />*/}\r\n                        <Route path={'account'} element={<AccountPage/>}/>\r\n                        <Route path={'settings'} element={<SettingsPage/>}/>\r\n                        <Route path={'updates'} element={<UpdatesPage/>}/>\r\n                        <Route path={'community'} element={<CommunityPage/>}/>\r\n                        <Route path={'templates'} element={<TemplatePage/>}/>\r\n                        <Route path={'notes'} element={<NotesPage/>}/>\r\n                        <Route path={'archive'} element={<ArchivePage/>}/>\r\n                        <Route path={'project'} element={<><ProjectPage/></>}/>\r\n                        <Route path={'recent'} element={<RecentPage/>}/>\r\n                        <Route path={'profile'} element={<ProfilePage/>}/>\r\n                        <Route path={'usersInfo'} element={<UsersInfoPage/>}/>\r\n                        <Route path={'projectsInfo'} element={<ProjectsInfoPage/>}/>\r\n                        <Route path={'news'} element={<NewsPage/>}/>\r\n                        <Route path={'auth'} element={<AuthPage/>}/>\r\n\r\n                        <Route path={'*'} element={<AllProjectsPage/>}/>\r\n                        {window.location.hostname !== 'localhost' && false &&\r\n                            <Route path={'*'} element={<AllProjectsPage/>}/>}\r\n                    </> :\r\n                        <>\r\n                            <Route path={'confirm/:id/:token'} element={<ConfirmAccount />}/>\r\n                            <Route path={'*'} element={<AuthPage/>}/>\r\n                            </>\r\n\r\n                    }\r\n                </Routes></Try>\r\n            </HashRouter>\r\n            {user && <Try><BottomBar/></Try>}\r\n        </div>\r\n    </>);\r\n\r\n    /*\r\n    if (user) {\r\n        return(<div className={'d-flex flex-column h-100 p-1 REACT-ROOT' + (props.debug ? ' debug' : '')}\r\n                    onClick={e => statehistory.globalcanundostate = true}>\r\n            {isLoading && <Loader />}\r\n            {tooltip && <ToolTip />}\r\n            <Navbar />\r\n            <Helper />\r\n            {(project) ? (project.type === 'collaborative' && !DUser.offlineMode) ? <CollaborativeAttacher project={project} /> : <Editor /> : <Dashboard />}\r\n        </div>);\r\n    } else {\r\n        return(<>\r\n            {isLoading && <Loader />}\r\n            <Auth />\r\n        </>);\r\n    }\r\n    */\r\n}\r\n\r\ninterface OwnProps {\r\n    room?: string\r\n}\r\n\r\ninterface StateProps {\r\n    //offlineMode: boolean,\r\n    debug: boolean,\r\n    isLoading: boolean\r\n    tooltip: string\r\n    user: Pointer<DUser>; // do not use, just for triggering rerender. use state.user instead\r\n}\r\ninterface DispatchProps {}\r\ntype AllProps = OwnProps & StateProps & DispatchProps;\r\n\r\n\r\nfunction mapStateToProps(state: DState, ownProps: OwnProps): StateProps {\r\n    const ret: StateProps = {} as FakeStateProps;\r\n    //ret.debug = state.debug;\r\n    ret.isLoading = state.isLoading;\r\n    ret.user = DUser.current;\r\n    // ret.user = LUser.fromPointer(DUser.current);\r\n    // needed here as props, because apparently functional components are memoized by default.\r\n    //ret.offlineMode = DUser.offlineMode;\r\n    // ret.tooltip = state.tooltip;\r\n    // console.log(\"app re mapstate\", {u:DUser.current, o:DUser.offlineMode});\r\n    return ret;\r\n}\r\n\r\nfunction mapDispatchToProps(dispatch: Dispatch<any>): DispatchProps {\r\n    const ret: DispatchProps = {};\r\n    return ret;\r\n}\r\n\r\nexport const AppConnected = connect<StateProps, DispatchProps, OwnProps, DState>(\r\n    mapStateToProps,\r\n    mapDispatchToProps\r\n)(App);\r\n\r\nexport default AppConnected;\r\n","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\joiner\\index.ts",["823","824","825","826","827"],"import * as jsxtt from 'jsx-transform/lib/jsx.js';\r\nimport $$ from 'jquery';\r\nimport {ReactNode} from \"react\";\r\nimport Select from 'react-select'\r\nimport * as _pr_json2xml from '../common/libraries/prj_json2xml.js';\r\nimport * as _pr_xml2json from '../common/libraries/prj_xml2json.js';\r\n\r\n// true imports for this file (should all be import type\r\nimport type {DocString} from './types';\r\nimport type {U as UType} from \"../common/U\";\r\nimport type {Log as LogType} from \"../common/Log\";\r\n\r\nvar pathDataPolyfill = require(\"path-data-polyfill\") // needs to be required (and automatically executed) before the creation of any svg element\r\nvar windoww = (window as any);\r\nwindoww.windoww = windoww;\r\nexport const MultiSelect = Select;\r\n\r\nwindoww.$ = $$;\r\nexport const $: JQueryStatic = $$;\r\nexport const prjson2xml = _pr_json2xml;\r\nexport const prxml2json = _pr_xml2json;\r\nwindoww.prjson2xml = prjson2xml;\r\nwindoww.prxml2json = prxml2json;\r\n\r\n// import types\r\n//import {$s, GraphPoint, GraphSize, IPoint, ISize, Log, Point, Size, U} from \"../common/U\";\r\n\r\n// nb: export type è un export \"finto\" che esiste solo in compilazione per fare capire a typescript i tipi. permette export di alias con nomi diversi (l'export normale no)\r\nexport type {GetPath} from './proxy';\r\n\r\nexport type {Subtract, Class, Empty, Json, GObject, bool, Dictionary, Proxyfied, Temporary, RawObject, NotFoundv,\r\n    NotFound, DocString, nbool, nnumber, nstring, Nullable, TODO, UnixTimestamp, UObject, IsActually,\r\n    Function, Function2, InOutParam,\r\n    unArr, orArr, PrimitiveType, CClass, NonEmptyString, Overlap, Info,\r\n    Constructor, AbstractConstructor, ApiResponse, Any, MultiSelectOptGroup, MultiSelectOption\r\n} from \"./types\";\r\n\r\nexport type {Pointer, PtrString, getWParams, WUser, WProject, WtoD, WtoL, DtoW, LtoW, LtoD, DtoL, PackArr, Pack, Pack1, ViewScore, EPSize,\r\n} from \"./classes\";\r\nexport type { WAnnotation, WNamedElement, WFactory_useless_, WClass, WAttribute, WClassifier, WDataType, WMap, WModel,\r\n    WModelElement, WEnumerator, WObject, WPackage, WOperation, WValue, WParameter, WReference, WTypedElement, WEnumLiteral, WStructuralFeature,\r\n    ValueDetail, SetValueAtPositionInfoType\r\n} from \"../model/logicWrapper/LModelElement\";\r\nexport type {WEdge, WEdgePoint, WExtEdge, WGraph, WRefEdge, WGraphElement, WVoidEdge, WGraphVertex, WVertex, WVoidVertex, EdgeSegment, EdgeFillSegment} from \"../model/dataStructure/GraphDataElements\";\r\nexport type {PackagePointers, EdgePointers, AnnotationPointers, AttributePointers, EnumPointers, ClassPointers,\r\n    LiteralPointers, OperationPointers, ObjectPointers, GraphPointers, ParameterPointers, ReferencePointers, VertexPointers,\r\n    ModelPointers,\r\n} from \"../model/logicWrapper/PointerDefinitions\";\r\nexport type {LoggerCategoryState, LoggerType} from \"../common/Log\";\r\n\r\n\r\nexport {windoww, EdgeBendingMode, EdgeGapMode, EMeasurableEvents} from './types';\r\nexport {GraphElementStatee, GraphElementDispatchProps, GraphElementReduxStateProps, GraphElementOwnProps,\r\n    EdgeStateProps, EdgeOwnProps, VertexOwnProps, BasicReactOwnProps} from \"../graph/graphElement/sharedTypes/sharedTypes\";\r\n\r\nexport {Constructors, JsType, RuntimeAccessibleClass, DPointerTargetable,\r\n    LPointerTargetable, WPointerTargetable, MyError, RuntimeAccessible,\r\n    L, D, P,\r\n    Obsolete, Leaf, Node, Abstract, Instantiable, MixOnlyFuncs,\r\n    NodeTransientProperties, ViewTransientProperties, DataTransientProperties,\r\n    UserHistory,\r\n    LUser, DUser, DProject, LProject, Pointers, PointedBy, PendingPointedByPaths, CoordinateMode, EdgeHead, EGraphElements, EModelElements, transientProperties, ViewEClassMatch} from \"./classes\";\r\n\r\n// export type {Pointer} from './typeconverter';\r\nexport {getPath, TargetableProxyHandler, MyProxyHandler, MapProxyHandler, LogicContext, MapLogicContext} from './proxy';\r\n// import independent generic modules (only dependent from types and RuntimeAccessible\r\n\r\nexport {Uarr, DDate, ParseNumberOrBooleanOptions, myFileReader,\r\n    Keystrokes, ShortAttribETypes, AttribETypes, FileReadTypeEnum, FocusHistoryEntry, SelectorOutput,\r\n    toShortEType, toLongEType, ShortAttribSuperTypes, R\r\n    } from \"../common/U\";\r\nexport {Uobj} from \"../common/UObj\";\r\nexport {Log} from \"../common/Log\";\r\nexport {DV} from '../common/DV';\r\nexport {Defaults} from '../common/Defaults';\r\nexport {Size, GraphSize, GraphPoint, IPoint, ISize, Point} from \"../common/Geom\";\r\nexport { CSSRuleSorted, CSSParser, TagNames } from \"../common/Uhtml\";\r\n// export {Log as Logg, Size, GraphSize, GraphPoint, IPoint, ISize, Point} from \"../common/Log\";\r\n// export const Log = (windoww.Log) as typeof LogType;\r\nexport {UX} from \"../common/UX\";\r\nexport var U = windoww.U as typeof UType;\r\nexport {DLog} from \"../model/classes/D\";\r\nexport {LLog} from \"../model/classes/L\";\r\n\r\nexport {\r\n    EcoreParser,\r\n    AccessModifier,\r\n    IStorage,\r\n    LocalStorage,\r\n    XMIModel,\r\n    ECoreRoot,\r\n    ECoreAnnotation,\r\n    ECoreNamed,\r\n    ECoreDetail,\r\n    ECorePackage,\r\n    ECoreSubPackage,\r\n    ECoreClass,\r\n    ECoreEnum,\r\n    ECoreAttribute,\r\n    ECoreReference,\r\n    EcoreLiteral,\r\n    ECoreOperation,\r\n    ECoreParameter,\r\n    ECoreObject,\r\n} from \"../api/data\";\r\n// import domain-specific classes\r\n\r\n\r\nexport {\r\n    DModelElement,\r\n    LModelElement,\r\n    DModel, LModel,\r\n    DValue, LValue,\r\n    DNamedElement, LNamedElement,\r\n    DObject, LObject,\r\n    DEnumerator, LEnumerator,\r\n    DEnumLiteral, LEnumLiteral,\r\n    DAttribute, LAttribute,\r\n    DReference, LReference,\r\n    DStructuralFeature, LStructuralFeature,\r\n    DClassifier, LClassifier,\r\n    DDataType, LDataType,\r\n    DClass, LClass,\r\n    DParameter, LParameter,\r\n    DOperation, LOperation,\r\n    DPackage, LPackage,\r\n    DTypedElement, LTypedElement,\r\n    DAnnotation, LAnnotation,\r\n    EJavaObject,\r\n    DFactory_useless_, LFactory_useless_, DMap, LMap\r\n} from \"../model/logicWrapper/LModelElement\";\r\n\r\n/*\r\nexport {\r\n    LModelElement,\r\n    LAnnotation,\r\n    LAttribute,\r\n    LClass,\r\n    LClassifier,\r\n    LEnumerator,\r\n    LEnumLiteral, LModel,\r\n    LObject, LOperation,\r\n    LPackage, LParameter, LReference,\r\n    LStructuralFeature, LDataType, LTypedElement, LNamedElement, // DMap, LMap,\r\n    LValue,\r\n} from \"../model/logicWrapper/LModelElement\";*/\r\nexport {\r\n    DExtEdge, DRefEdge, DVoidEdge, LGraphVertex, LRefEdge, LEdgePoint, DVoidVertex, DGraphVertex, DEdgePoint, DVertex,\r\n    DEdge, LVertex, LGraph, DGraph, LVoidVertex, LVoidEdge, LEdge, LGraphElement, LExtEdge, DGraphElement} from \"../model/dataStructure/GraphDataElements\";\r\n\r\n\r\n\r\n// export {GraphDragHandler} from \"../graph/vertex/GraphDragHandler\";\r\n\r\nexport type {WViewElement, WViewTransientProperties} from \"../view/viewElement/view\";\r\nexport {DViewTransientProperties, LViewTransientProperties, LViewElement, DViewElement} from \"../view/viewElement/view\";\r\nexport {DViewPoint, LViewPoint} from \"../view/viewPoint/viewpoint\";\r\n\r\nexport {Action, CreateElementAction, DeleteElementAction, SetFieldAction, SetRootFieldAction, CompositeAction, ParsedAction, LoadAction, CombineHistoryAction, RedoAction, UndoAction,\r\n    TRANSACTION, ABORT, /*BEGIN, END*/} from \"../redux/action/action\";\r\n\r\nexport {DState, LState, ModelStore, ViewPointState, statehistory} from \"../redux/store\";\r\nexport {GraphDragManager} from \"../graph/graphElement/GraphDragHandler\";\r\nexport {Selectors} from \"../redux/selectors/selectors\";\r\n// export var Selectors = windoww.Selectors as (GObjectt & typeof SelType);\r\nexport {reducer, stateInitializer} from \"../redux/reducer/reducer\";\r\nexport {store} from \"../redux/createStore\";\r\nexport {Debug} from \"../debugtools/debug\";\r\n\r\nexport {OCL} from \"../ocl/ocl\";\r\n\r\n\r\n\r\n\r\nclass JSXT_TYPE{\r\n    fromString(str: string, options?:\r\n        {   factory: string,\r\n            spreadFn?:Function,\r\n            unknownTagPattern?:string,\r\n            passUnknownTagsToFactory?:boolean,\r\n            unknownTagsAsString?:boolean,\r\n            arrayChildren?:boolean\r\n        }): DocString<ReactNode, 'compiled code as string, like React.CreateElement(...)'> { return ''; }\r\n    fromFile(path: string, options?:\r\n        {   factory: string,\r\n            spreadFn?:Function,\r\n            unknownTagPattern?:string,\r\n            passUnknownTagsToFactory?:boolean,\r\n            unknownTagsAsString?:boolean,\r\n            arrayChildren?:boolean\r\n        }): DocString<ReactNode, 'compiled code as string, like React.CreateElement(...)'> { return ''; }\r\n    browserifyTransform(...params: any): any {}\r\n    visitor: unknown = null;\r\n}\r\n\r\nexport const JSXT = jsxtt as any as JSXT_TYPE/*as {\r\n    fromString: (str: string, options?:\r\n        {   factory: string,\r\n            spreadFn?:Function,\r\n            unknownTagPattern?:string,\r\n            passUnknownTagsToFactory?:boolean,\r\n            unknownTagsAsString?:boolean,\r\n            arrayChildren?:boolean\r\n        }) =>string,\r\n    fromFile: (path: string, options?:\r\n        {   factory: string,\r\n            spreadFn?:Function,\r\n            unknownTagPattern?:string,\r\n            passUnknownTagsToFactory?:boolean,\r\n            unknownTagsAsString?:boolean,\r\n            arrayChildren?:boolean\r\n        }) =>string,\r\n    browserifyTransform: unknown | Function,\r\n    visitor: unknown\r\n}*/\r\nwindoww.jsxt = jsxtt;\r\nwindoww.JSXT = jsxtt;\r\n\r\n\r\nexport type Event = JQuery.Event;\r\nexport type EventBase = JQuery.EventBase;\r\nexport type EventHandlerBase<T1, T2> = JQuery.EventHandlerBase<T1, T2>;\r\nexport type MouseEventBase = JQuery.MouseEventBase;\r\nexport type MouseUpEvent = JQuery.MouseUpEvent;\r\nexport type ChangeEvent = JQuery.ChangeEvent;\r\nexport type ContextMenuEvent = JQuery.ContextMenuEvent;\r\nexport type ClickEvent = JQuery.ClickEvent;\r\nexport type MouseDownEvent = JQuery.MouseDownEvent;\r\nexport type BlurEvent = JQuery.BlurEvent;\r\nexport type KeyDownEvent = JQuery.KeyDownEvent;\r\nexport type KeyUpEvent = JQuery.KeyUpEvent;\r\nexport type KeyPressEvent = JQuery.KeyPressEvent;\r\nexport type DoubleClickEvent = JQuery.DoubleClickEvent;\r\nexport type DragEndEvent = JQuery.DragEndEvent;\r\nexport type DragEnterEvent = JQuery.DragEnterEvent;\r\nexport type DragEvent = JQuery.DragEvent;\r\nexport type DragExitEvent = JQuery.DragExitEvent;\r\nexport type DragLeaveEvent = JQuery.DragLeaveEvent;\r\nexport type DragOverEvent = JQuery.DragOverEvent;\r\nexport type DragStartEvent = JQuery.DragStartEvent;\r\nexport type DropEvent = JQuery.DropEvent;\r\nexport type FocusEvent = JQuery.FocusEvent;\r\nexport type FocusInEvent = JQuery.FocusInEvent;\r\nexport type FocusOutEvent = JQuery.FocusOutEvent;\r\nexport type FocusEventBase = JQuery.FocusEventBase;\r\n\r\n\r\n\r\n// window (NB: most of them should be replaced by RuntimeAccessibleClass)\r\nlet w: any = window;/*\r\nw.$ = $;\r\nw.Log = Log;\r\nw.U = U;\r\nw.Size = Size;\r\nw.ISize = ISize;\r\nw.GraphSize = GraphSize;\r\nw.Point = Point;\r\nw.IPoint = IPoint;\r\nw.GraphPoint = GraphPoint;\r\nw.$s = $s;\r\n*/\r\nexport {} from './components';\r\nexport {\r\n    TextArea, Select, Input, Edit, Edge, // Image,\r\n    GraphsContainerComponent,\r\n    Overlap as OverlapComponent,\r\n    GraphsContainer,\r\n    GraphElement,\r\n    Vertex, VoidVertex, EdgePoint,\r\n    Graph, GraphVertex,\r\n    Field,\r\n    DefaultNode,\r\n    GraphElementComponent,\r\n    VertexComponent,\r\n    DefaultNodeComponent,\r\n    // DockLayoutComponent,\r\n    //ColorScheme,\r\n    EdgeComponent,\r\n    DataOutputComponent, LoggerComponent, GenericInput,\r\n    Polygon, Circle, Cross, Decagon,\r\n    Asterisk, Ellipse, Enneagon, Hexagon, Nonagon,\r\n    Octagon, Heptagon, Pentagon, Rectangle, Septagon,\r\n    Square, Star, SimpleStar, DecoratedStar, Trapezoid, Triangle,\r\n    View, Try, ControlPanel,\r\n    GraphElements, Graphs, Vertexes, Edges, Fields,\r\n    MeasurableComponent, Measurable, Draggable, Rotatable, Resizable\r\n} from './components'\r\n//export {createOrOpenModelTab} from \"../components/abstract/DockLayoutComponent\"; // needs to be after docklayoutcomponent or to split the file\r\nexport {fakeExport} from './ExecuteOnRead';\r\n// console.info('joiner loaded');\r\n\r\nclass joiner{}\r\nclass Joiner{\r\n    // just to help the file search\r\n}\r\n\r\n","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\components\\loader\\Loader.tsx",[],"C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\components\\pathChecker\\PathChecker.tsx",["828"],"import {useLocation} from \"react-router-dom\";\r\nimport {useEffect, useState} from \"react\";\r\nimport {U} from \"../../joiner\";\r\n\r\ntype Props = {};\r\nfunction PathChecker(props: Props) {\r\n    const {pathname} = useLocation();\r\n    const [renders, setRenders] = useState(0);\r\n\r\n    useEffect(() => {\r\n        const newRenders = renders + 1;\r\n        if(/*pathname === '/project' && */newRenders > 1) U.resetState();\r\n        setRenders(newRenders);\r\n    }, [pathname]);\r\n\r\n    return(<></>);\r\n}\r\n\r\nexport default PathChecker;\r\n","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\components\\alert\\Alert.tsx",[],"C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\components\\alert\\Dialog.tsx",["829","830","831"],"import {DState, SetRootFieldAction} from '../../joiner';\r\nimport {FakeStateProps, windoww} from '../../joiner/types';\r\nimport React, {Component, Dispatch, ReactElement} from 'react';\r\nimport {connect} from 'react-redux';\r\nimport './style.scss';\r\n\r\nfunction DialogComponent(props: AllProps) {\r\n    let {message,label} = props;console.log('dialog',props);\r\n\r\n    let paused = false;\r\n    \r\n\r\n    const cancel_button = document.getElementById('cancel-button');\r\n    const confirm_button = document.getElementById('confirm-button');\r\n    \r\n    function cancel(e: any) {\r\n        SetRootFieldAction.new('dialog', '', '');\r\n    };\r\n\r\n    function confirm(e: any) {\r\n        \r\n        if (windoww.dialog_action) {\r\n            windoww.dialog_action(); \r\n            windoww.dialog_action = null;\r\n        }\r\n        SetRootFieldAction.new('dialog', '', '');\r\n    };\r\n\r\n\r\n\r\n    if (!message || !label) return(<></>);\r\n\r\n    return(<div className={'dialog-container'}>\r\n        <div className={'dialog-card'}>\r\n            <div className={'dialog-header'}>\r\n                <div className={'dialog-sign-outer'}>\r\n                    <div className={'dialog-sign-inner'}>\r\n                    </div>\r\n                </div>\r\n            </div>\r\n            <h1>{message}</h1>\r\n            <div className={'dialog-message'}></div>\r\n            <div className={'dialog-button-bar'}>\r\n                <button className={'btn dialog-cancel-btn my-2  px-4'} id={'cancel-button'} onClick={(e) => cancel(e)}>\r\n                    cancel\r\n                </button>\r\n                <button className={'btn dialog-btn my-2  px-4'} id={'confirm-button'} onClick={(e) => confirm(e)}>\r\n                    {label}\r\n                </button> \r\n            </div>\r\n        </div>\r\n\r\n    </div>);\r\n}\r\n\r\ninterface OwnProps {}\r\ninterface StateProps {\r\n    message: string;\r\n    label:string;\r\n    \r\n}\r\ninterface DispatchProps {}\r\n\r\ntype AllProps = OwnProps & StateProps & DispatchProps;\r\n\r\nfunction mapStateToProps(state: DState, ownProps: OwnProps): StateProps {\r\n    const ret: StateProps = {} as FakeStateProps;\r\n    let dialog = state.dialog;\r\n    if(!dialog) return ret;\r\n    dialog = dialog + ' ';\r\n    let pieces = dialog.split(':');\r\n    ret.message = pieces[0];\r\n    ret.label = pieces[1];\r\n\r\n    return ret;\r\n}\r\n\r\nfunction mapDispatchToProps(dispatch: Dispatch<any>): DispatchProps {\r\n    const ret: DispatchProps = {} as any;\r\n    return ret;\r\n}\r\n\r\n\r\nexport const DialogConnected = connect<StateProps, DispatchProps, OwnProps, DState>(\r\n    mapStateToProps,\r\n    mapDispatchToProps\r\n)(DialogComponent);\r\n\r\nexport const DialogVisualizer = (props: OwnProps, children: (string | Component)[] = []): ReactElement => {\r\n    return <DialogConnected {...{...props, children}} />;\r\n}\r\nexport default DialogVisualizer;\r\n","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\components\\forEndUser\\ExternalLibraries.tsx",["832","833"],"import {ReactElement, ReactNode} from \"react\";\r\n\r\n// paste the sources in src/common/libraries or /public/libname/\r\n// avoid npm install when possible. because some libraries might get excluded from build\r\n// if they are not used in source code.\r\n// but even if they are not used in source code could be used by users in their views.\r\n\r\n\r\n// used in App.tsx\r\n\r\nexport function ExternalLibraries(): any {\r\n    return [\r\n        // @ts-ignore  // .js is not included in source files?\r\n        <link href='https://unpkg.com/boxicons@2.1.4/css/boxicons.min.css' rel='stylesheet' />,\r\n        <script src=\"https://unpkg.com/boxicons@2.1.4/dist/boxicons.js\"></script>,\r\n        // <link href='https://unpkg.com/boxicons@2.1.4/dist/boxicons.js' rel='stylesheet' > in docs was like this??\r\n    ];\r\n}\r\n","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\components\\forEndUser\\Tooltip.tsx",["834","835","836","837","838","839","840","841","842","843","844","845","846","847","848","849","850"],"import React, {\r\n    Dispatch,\r\n    isValidElement,\r\n    KeyboardEvent,\r\n    LegacyRef,\r\n    ReactElement,\r\n    ReactNode,\r\n    Ref,\r\n    RefObject\r\n} from 'react';\r\nimport {connect} from 'react-redux';\r\nimport {DState} from '../../redux/store';\r\nimport {\r\n    Defaults,\r\n    DPointerTargetable,\r\n    DV,\r\n    GObject,\r\n    Keystrokes,\r\n    Log,\r\n    LPointerTargetable,\r\n    Overlap,\r\n    Pointer, store,\r\n    U, LoggerCategoryState, RuntimeAccessible, Size, Point\r\n} from '../../joiner';\r\nimport './tooltip.scss';\r\nimport {IPoint, PositionStr, PositionStrTypes} from \"../../common/Geom\";\r\n\r\nclass TooltipVisualizerState{\r\n    tooltip?: ReactNode;\r\n    baseElement?: Element;\r\n    position?: PositionStrTypes;\r\n    offsetX?: number;\r\n    offsetY?: number\r\n    theme?: ThemeType;\r\n    constructor() {\r\n        this.position = 'b';\r\n    }\r\n}\r\nexport class TooltipVisualizer extends React.Component<{}, TooltipVisualizerState> {\r\n    public static component: TooltipVisualizer;\r\n    constructor(){\r\n        super({});\r\n        this.state = new TooltipVisualizerState();\r\n        TooltipVisualizer.component = this;\r\n    }\r\n    onMouseEnter(){\r\n        let position = PositionStr.invertPosStr(TooltipVisualizer.component.state.position ?? \"b\");\r\n        TooltipVisualizer.component.setState({position});\r\n    }\r\n\r\n    private tooltip: HTMLElement | null = null;\r\n    private root: HTMLElement | null = null;\r\n    private innerText?: string;\r\n    private tsize?: Size;\r\n    private theme?: ThemeType;\r\n\r\n    setRef(e: HTMLElement | null) { this.root = e; this.componentDidUpdate(); }\r\n    componentDidMount(){\r\n        return this.componentDidUpdate();\r\n    }\r\n    componentDidUpdate(){\r\n        let e = this.root;\r\n        if (!e) return;\r\n        let innerText = e.innerText;\r\n        if (innerText === this.innerText) return;\r\n        this.innerText = innerText;\r\n        this.tooltip = e.children[0] as any;\r\n        this.tsize = this.tooltip ? Size.of(this.tooltip) : undefined;\r\n        \r\n        this.forceUpdate();\r\n    }\r\n\r\n    render(){\r\n        let tooltip = this.state.tooltip;\r\n        if (!tooltip) return null;\r\n        const style: GObject = {};\r\n        let position = this.state.position;\r\n        let offsetX = this.state.offsetX || 0;\r\n        let offsetY = this.state.offsetY || 0;\r\n        let theme = this.state.theme;\r\n\r\n        /* debug stuff override\r\n        let positions = ['t', 'b', 'l', 'r', 'tl', 'tr', 'bl', 'br', ''] as any;\r\n        let windoww = window as any\r\n        position = positions[windoww.ii || 0];//Math.floor(Math.random()*positions.length)];\r\n        offsetX = windoww.xx || 0;\r\n        offsetY = windoww.yy || 0;*/\r\n        if (this.state.baseElement){\r\n            //style.position = 'absolute';\r\n            let size = Size.of(this.state.baseElement);\r\n            let tsize = this.tsize;\r\n            let x = size.x;\r\n            let y = size.y;\r\n            let pos = PositionStr.fromPosString(position);\r\n            x += (pos.x+1)/2 * size.w + pos.x * offsetX;\r\n            y += (pos.y+1)/2 * size.h + pos.y * offsetY;\r\n            // -1 -> 0\r\n            // 0 -> 0.5\r\n            // 1 -> 1\r\n\r\n            let xmin = 'calc(' + size.w + 'px / 2 - 50vw)';\r\n            let ymin = 'calc(' +  size.h + 'px / 2 - 50vh)';\r\n\r\n            let xmax = 'calc(50vw - ' + size.w + 'px / 2)';\r\n            let ymax = 'calc(50vh - ' +  size.h + 'px / 2)';\r\n\r\n            let l = 'max(' + xmin + ', min(' + xmax +', calc( '+ x +'px - 50vw)))';\r\n            let t = 'max(' + ymin + ', min(' + ymax + ', calc( '+ y +'px - 50vh)))';\r\n            // style.left = l; style.top = t;\r\n            style['--mid-x'] = 'calc(' + x + 'px - 50vw)';\r\n            style['--mid-y'] = 'calc(' + y + 'px - 50vh)';\r\n            style['--source-size-w'] = size.w + 'px';\r\n            style['--source-size-h'] = size.h + 'px';\r\n            if (tsize) {\r\n                style['--size-w'] = tsize.w + 'px';\r\n                style['--size-h'] = tsize.h + 'px';\r\n            }\r\n            // style.right = 'calc( 100vw - '+size.w+'px)';\r\n            // currently center of tooltip is topleft of baseelem\r\n        }\r\n\r\n        // wrapper cannot contain only rawtext without subelements to be rendered\r\n        if (typeof tooltip !== 'object') tooltip = <div>{tooltip}</div>;\r\n        if (Array.isArray(tooltip)) tooltip = tooltip.map(e => typeof e !== 'object' ? <div>{e}</div> : e)\r\n        // NB: arrays are allowed but currently show elements in an horizontal line\r\n        // debugg stuff\r\n        let tooltip2 = <div style={{...style, padding:0, width:0, height:0,  borderRadius: '100%'}} />; // border:'2px solid red',\r\n        style.padding = 0;\r\n        // debug stuff end\r\n\r\n        return <>\r\n            <div className={\"tooltip-wrapper \" +\r\n                (PositionStr.toSeparateFullLabels(position ?? 't'))+\r\n                (this.state.baseElement ? \" inline\" : \" fixed\")+ \" \"+\r\n                (theme)\r\n            } onMouseEnter={this.onMouseEnter}\r\n                 style={style} ref={(e)=> this.setRef(e)}>\r\n                {tooltip}</div>\r\n            <div className={\"tooltip-wrapper \" +\r\n                (PositionStr.toSeparateFullLabels(position ?? 't'))+\r\n                (this.state.baseElement ? \" inline\" : \" fixed\")+ \" \"+\r\n                (theme)\r\n            } onMouseEnter={this.onMouseEnter}\r\n                 style={style}>\r\n        {tooltip2}</div>\r\n        </>;\r\n    }\r\n}\r\n\r\n@RuntimeAccessible('Tooltip')\r\nexport class Tooltip extends React.Component<AllProps, State> {\r\n    static cname: string = \"Tooltip\";\r\n    tooltip!: ReactNode;\r\n\r\n    constructor(props: AllProps) {\r\n        super(props);\r\n        this.state = {};\r\n        this.onMouseEnter = this.onMouseEnter.bind(this);\r\n        this.onMouseLeave = this.onMouseLeave.bind(this);\r\n    }\r\n\r\n    public static show(tooltip: ReactNode, pos?: PositionStrTypes, baseElement?: Element, seconds: number = -1, offset?: IPoint, theme?: ThemeType): void{\r\n        tooltip = Tooltip.fixTooltip(tooltip);\r\n        const statepatch: Partial<TooltipVisualizerState> = {tooltip, baseElement, offsetX: offset?.x ?? 0, offsetY: offset?.y ?? 0, theme};\r\n         statepatch.position = pos ?? 'b';\r\n        TooltipVisualizer.component.setState(statepatch);\r\n        if (seconds>0) setTimeout( () => {\r\n            if (TooltipVisualizer.component.state.tooltip !== tooltip) return;\r\n            if (TooltipVisualizer.component.state.baseElement !== baseElement) return;\r\n            TooltipVisualizer.component.setState({tooltip: undefined, baseElement: undefined, offsetX: 0, offsetY: 0});\r\n            }, seconds * 1000);\r\n    }\r\n\r\n    public static hide(): void {\r\n        TooltipVisualizer.component.setState({tooltip: undefined});\r\n    }\r\n\r\n    onMouseEnter(e?: MouseEvent): void{\r\n        let inline = this.props.inline;\r\n        let x = this.props.offsetX;\r\n        let y = this.props.offsetY;\r\n        let offset: Point | undefined = (x || x === 0) || (y || y === 0) ? new Point(this.props.offsetX || 0, this.props.offsetY || 0) : undefined;\r\n        Tooltip.show(this.tooltip, this.props.position, inline ? (this.childhtml || undefined) : undefined, -1, offset);\r\n\r\n        if (this.props.seconds) {\r\n            setTimeout(()=>this.onMouseLeave(e), this.props.seconds);\r\n        }\r\n    }\r\n    onMouseLeave(e?: MouseEvent): void{\r\n        if (this.props.seconds) return;\r\n        Tooltip.hide();\r\n    }\r\n\r\n    componentWillUnmount() {\r\n        this.onMouseLeave();\r\n    }\r\n    private static fixTooltip(t: ReactNode): ReactNode{\r\n        return t;\r\n        // const onMouseEnter = Tooltip.mergeEvents(t, \"onMouseEnter\", ()=> TooltipVisualizer.component.setState({position: !TooltipVisualizer.component.position}));\r\n        //return React.cloneElement(t, {onMouseEnter});\r\n    }\r\n    private static mergeEvents(c: React.ReactElement<any, string | React.JSXElementConstructor<any>> | React.ReactPortal, key: string, func: (...a:any)=>any): ((...a:any)=>any) {\r\n        if (!c.props[key]) return func;\r\n\r\n        let evt = (...a:any[])=>{\r\n            let ret: any = undefined;\r\n            if (typeof c.props[key] !== \"function\") Log.ww(\"<Tooltip /> component requires his child to have \"+key+\" props either missing or a valid function\");\r\n            else { ret = c.props[key](...a); }\r\n            func(...a);\r\n            return ret;\r\n        }\r\n        return evt;\r\n\r\n    }\r\n    childhtml: Element | null = null;\r\n\r\n    render() {\r\n        if (!this.props.tooltip) return this.props.children;\r\n        if (Array.isArray(this.props.children)) return <span>\r\n            &lt;Tooltip /&gt; component requires exactly 1 element as children. Wrap the subelements in a container element.\r\n        </span>\r\n        if (!this.props.children || !isValidElement(this.props.children)) return <span>\r\n            &lt;Tooltip /&gt; component requires a html or react node as children.\r\n        </span>\r\n        for (let k of Object.keys(this.props)) switch (k){\r\n            //default: Log.ww('<Tooltip /> component cannot accept props other than \"key\", \"position\", and \"tooltip\".'); break;\r\n            case 'children': case 'key': case 'tooltip': case 'position': break;\r\n            // case \"inline\": break;\r\n        }\r\n        this.tooltip = Tooltip.fixTooltip(this.props.tooltip);\r\n\r\n        let c = this.props.children;\r\n        const onMouseEnter = Tooltip.mergeEvents(c, 'onMouseEnter', this.onMouseEnter);\r\n        const onMouseLeave = Tooltip.mergeEvents(c, 'onMouseLeave', this.onMouseLeave);\r\n        let ref: Ref<Element> | undefined = undefined;\r\n        if (c.props.ref) {\r\n            const pref = c.props.ref;\r\n            switch(typeof pref){\r\n                case \"object\": this.childhtml = (pref as RefObject<Element>).current; break;\r\n                case \"function\": ref = (e: Element, ...a:any)=> { pref(e, a); this.childhtml = e;}; break;\r\n                case \"string\": Log.ee(\"Found React-ref of type string in Tooltip children which is unsupported. Use object or funcional refs.\"); break;\r\n            }\r\n        } else ref = ((ref: Element | null) => { this.childhtml = ref; } );\r\n\r\n        const injectProps: GObject = {onMouseEnter, onMouseLeave};\r\n        if (ref) injectProps.ref = ref;\r\n        let ret = React.cloneElement(c, injectProps);\r\n        return ret;\r\n    }\r\n\r\n}\r\ninterface State{\r\n}\r\n\r\ntype ThemeType = 'default' | 'dark';\r\n\r\ninterface OwnProps {\r\n    key?: React.Key | null;\r\n    catch?: ReactNode | ((error: Error, info?: React.ErrorInfo) => ReactNode);\r\n    children: ReactNode;\r\n    tooltip: ReactNode;\r\n    inline?: boolean;\r\n    offsetX?: number;\r\n    offsetY?: number;\r\n    position?: PositionStrTypes;\r\n    seconds?: number;\r\n    theme?: ThemeType;\r\n}\r\ninterface StateProps {\r\n}\r\ninterface DispatchProps { }\r\ntype AllProps = Overlap<OwnProps, Overlap<StateProps, DispatchProps>>;\r\n\r\n\r\n// const TooltipConnected = connect<StateProps, DispatchProps, OwnProps, DState>(mapStateToProps, mapDispatchToProps)(TooltipComponent);\r\n\r\n\r\n// export function Tooltip(props: OwnProps): ReactElement { return <TooltipConnected {...{...props}}>{props.children}</TooltipConnected>; }\r\n\r\n//TooltipComponent.cname = 'TooltipComponent';\r\n//TooltipConnected.cname = 'TooltipConnected';\r\nTooltip.cname = 'Tooltip';\r\n","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\common\\libraries\\prj_json2xml.js",["851","852","853","854","855","856"],"/*\tThis work is licensed under Creative Commons GNU LGPL License.\r\n\r\n\tLicense: http://creativecommons.org/licenses/LGPL/2.1/\r\n   Version: 0.9\r\n\tAuthor:  Stefan Goessner/2006\r\n\tWeb:     http://goessner.net/ \r\n*/\r\nexport function json2xml(o, tab/*string, string*/) {\r\n   var toXml = function(v, name, ind) {\r\n      var xml = \"\";\r\n      if (v instanceof Array) {\r\n         for (var i=0, n=v.length; i<n; i++)\r\n            xml += ind + toXml(v[i], name, ind+\"\\t\") + \"\\n\";\r\n      }\r\n      else if (typeof(v) == \"object\") {\r\n         var hasChild = false;\r\n         xml += ind + \"<\" + name;\r\n         for (var m in v) {\r\n            if (m.charAt(0) == \"@\")\r\n               xml += \" \" + m.substr(1) + \"=\\\"\" + v[m].toString() + \"\\\"\";\r\n            else\r\n               hasChild = true;\r\n         }\r\n         xml += hasChild ? \">\" : \"/>\";\r\n         if (hasChild) {\r\n            for (var m in v) {\r\n               if (m == \"#text\")\r\n                  xml += v[m];\r\n               else if (m == \"#cdata\")\r\n                  xml += \"<![CDATA[\" + v[m] + \"]]>\";\r\n               else if (m.charAt(0) != \"@\")\r\n                  xml += toXml(v[m], m, ind+\"\\t\");\r\n            }\r\n            xml += (xml.charAt(xml.length-1)==\"\\n\"?ind:\"\") + \"</\" + name + \">\";\r\n         }\r\n      }\r\n      else {\r\n         xml += ind + \"<\" + name + \">\" + v.toString() +  \"</\" + name + \">\";\r\n      }\r\n      return xml;\r\n   }, xml=\"\";\r\n   for (var m in o)\r\n      xml += toXml(o[m], m, \"\");\r\n   return tab ? xml.replace(/\\t/g, tab) : xml.replace(/\\t|\\n/g, \"\");\r\n}\r\n","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\common\\libraries\\prj_xml2json.js",["857","858","859","860","861","862","863","864","865","866","867","868","869","870","871","872"],"/*\tThis work is licensed under Creative Commons GNU LGPL License.\r\n\r\n\tLicense: http://creativecommons.org/licenses/LGPL/2.1/\r\n   Version: 0.9\r\n\tAuthor:  Stefan Goessner/2006\r\n\tWeb:     http://goessner.net/\r\n*/\r\nvar X = {\r\n   toObj: function(xml) {\r\n      var o = {};\r\n      if (xml.nodeType==1) {   // element node ..\r\n         if (xml.attributes.length)   // element with attributes  ..\r\n            for (var i=0; i<xml.attributes.length; i++)\r\n               o[\"@\"+xml.attributes[i].nodeName] = (xml.attributes[i].nodeValue||\"\").toString(); // dam: qua parsa attribs\r\n         if (xml.firstChild) { // element has child nodes ..\r\n            var textChild=0, cdataChild=0, hasElementChild=false;\r\n            for (var n=xml.firstChild; n; n=n.nextSibling) {\r\n               if (n.nodeType==1) hasElementChild = true;\r\n               else if (n.nodeType==3 && n.nodeValue.match(/[^ \\f\\n\\r\\t\\v]/)) textChild++; // non-whitespace text\r\n               else if (n.nodeType==4) cdataChild++; // cdata section node\r\n            }\r\n            if (hasElementChild) {\r\n               if (textChild < 2 && cdataChild < 2) { // structured element with evtl. a single text or/and cdata node ..\r\n                  X.removeWhite(xml);\r\n                  for (var n=xml.firstChild; n; n=n.nextSibling) {\r\n                     if (n.nodeType == 3)  // text node\r\n                        o[\"#text\"] = X.escape(n.nodeValue);\r\n                     else if (n.nodeType == 4)  // cdata node\r\n                        o[\"#cdata\"] = X.escape(n.nodeValue);\r\n                     else if (o[n.nodeName]) {  // multiple occurence of element ..\r\n                        if (o[n.nodeName] instanceof Array)\r\n                           o[n.nodeName][o[n.nodeName].length] = X.toObj(n);\r\n                        else\r\n                           o[n.nodeName] = [o[n.nodeName], X.toObj(n)];\r\n                     }\r\n                     else  // first occurence of element..\r\n                        o[n.nodeName] = X.toObj(n); // damiano: qua parsa sottonodi\r\n                  }\r\n               }\r\n               else { // mixed content\r\n                  if (!xml.attributes.length)\r\n                     o = X.escape(X.innerXml(xml));\r\n                  else\r\n                     o[\"#text\"] = X.escape(X.innerXml(xml));\r\n               }\r\n            }\r\n            else if (textChild) { // pure text\r\n               if (!xml.attributes.length)\r\n                  o = X.escape(X.innerXml(xml));\r\n               else\r\n                  o[\"#text\"] = X.escape(X.innerXml(xml));\r\n            }\r\n            else if (cdataChild) { // cdata\r\n               if (cdataChild > 1)\r\n                  o = X.escape(X.innerXml(xml));\r\n               else\r\n                  for (var n=xml.firstChild; n; n=n.nextSibling)\r\n                     o[\"#cdata\"] = X.escape(n.nodeValue);\r\n            }\r\n         }\r\n         if (!xml.attributes.length && !xml.firstChild) o = null;\r\n      }\r\n      else if (xml.nodeType==9) { // document.node\r\n         o = X.toObj(xml.documentElement);\r\n      }\r\n      else alert(\"unhandled node type: \" + xml.nodeType);\r\n      return o;\r\n   },\r\n   toJson: function(o, name, ind) {\r\n      var json = name ? (\"\\\"\"+name+\"\\\"\") : \"\";\r\n      if (o instanceof Array) {\r\n         for (var i=0,n=o.length; i<n; i++)\r\n            o[i] = X.toJson(o[i], \"\", ind+\"\\t\");\r\n         json += (name?\":[\":\"[\") + (o.length > 1 ? (\"\\n\"+ind+\"\\t\"+o.join(\",\\n\"+ind+\"\\t\")+\"\\n\"+ind) : o.join(\"\")) + \"]\";\r\n      }\r\n      else if (o == null)\r\n         json += (name&&\":\") + \"null\";\r\n      else if (typeof(o) == \"object\") {\r\n         var arr = [];\r\n         for (var m in o)\r\n            arr[arr.length] = X.toJson(o[m], m, ind+\"\\t\");\r\n         json += (name?\":{\":\"{\") + (arr.length > 1 ? (\"\\n\"+ind+\"\\t\"+arr.join(\",\\n\"+ind+\"\\t\")+\"\\n\"+ind) : arr.join(\"\")) + \"}\";\r\n      }\r\n      else if (typeof(o) == \"string\")\r\n         json += (name&&\":\") + \"\\\"\" + o.toString() + \"\\\"\";\r\n      else\r\n         json += (name&&\":\") + o.toString();\r\n      return json;\r\n   },\r\n   innerXml: function(node) {\r\n      var s = \"\"\r\n      if (\"innerHTML\" in node)\r\n         s = node.innerHTML;\r\n      else {\r\n         var asXml = function(n) {\r\n            var s = \"\";\r\n            if (n.nodeType == 1) {\r\n               s += \"<\" + n.nodeName;\r\n               for (var i=0; i<n.attributes.length;i++)\r\n                  s += \" \" + n.attributes[i].nodeName + \"=\\\"\" + (n.attributes[i].nodeValue||\"\").toString() + \"\\\"\";\r\n               if (n.firstChild) {\r\n                  s += \">\";\r\n                  for (var c=n.firstChild; c; c=c.nextSibling)\r\n                     s += asXml(c);\r\n                  s += \"</\"+n.nodeName+\">\";\r\n               }\r\n               else\r\n                  s += \"/>\";\r\n            }\r\n            else if (n.nodeType == 3)\r\n               s += n.nodeValue;\r\n            else if (n.nodeType == 4)\r\n               s += \"<![CDATA[\" + n.nodeValue + \"]]>\";\r\n            return s;\r\n         };\r\n         for (var c=node.firstChild; c; c=c.nextSibling)\r\n            s += asXml(c);\r\n      }\r\n      return s;\r\n   },\r\n   escape: function(txt) {\r\n      return txt.replace(/[\\\\]/g, \"\\\\\\\\\")\r\n          .replace(/[\\\"]/g, '\\\\\"')\r\n          .replace(/[\\n]/g, '\\\\n')\r\n          .replace(/[\\r]/g, '\\\\r');\r\n   },\r\n   removeWhite: function(e) {\r\n      e.normalize();\r\n      for (var n = e.firstChild; n; ) {\r\n         if (n.nodeType == 3) {  // text node\r\n            if (!n.nodeValue.match(/[^ \\f\\n\\r\\t\\v]/)) { // pure whitespace text node\r\n               var nxt = n.nextSibling;\r\n               e.removeChild(n);\r\n               n = nxt;\r\n            }\r\n            else\r\n               n = n.nextSibling;\r\n         }\r\n         else if (n.nodeType == 1) {  // element node\r\n            X.removeWhite(n);\r\n            n = n.nextSibling;\r\n         }\r\n         else                      // any other node\r\n            n = n.nextSibling;\r\n      }\r\n      return e;\r\n   }\r\n};\r\nexport function xml2json(xml, tab = '    '/*XML_DOM, string*/) {\r\n   if (xml.nodeType == 9) // document node\r\n      xml = xml.documentElement;\r\n   var json = X.toJson(X.toObj(X.removeWhite(xml)), xml.nodeName, \"\\t\");\r\n   return \"{\\n\" + tab + (tab ? json.replace(/\\t/g, tab) : json.replace(/\\t|\\n/g, \"\")) + \"\\n}\";\r\n}\r\nexport function xml2jsonobj(xml, tab= '    '){\r\n   return X.toObj(X.removeWhite(xml));\r\n}\r\n// damiano: i needX.toObj(X.removeWhite(xml))\r\n","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\joiner\\types.ts",["873","874","875","876","877","878","879","880","881","882","883","884"],"// export type Class = { new(...args: any[]): any; };\r\nimport type {Pointer, RuntimeAccessibleClass, ShortAttribETypes} from \"../joiner\";\r\nimport {\r\n    DGraphElement,\r\n    DPointerTargetable,\r\n    DState,\r\n    DUser,\r\n    LAttribute,\r\n    LClass,\r\n    LEdge,\r\n    LEdgePoint,\r\n    LEnumerator,\r\n    LEnumLiteral,\r\n    LGraph,\r\n    LGraphElement,\r\n    LGraphVertex,\r\n    LModel,\r\n    LObject,\r\n    LOperation,\r\n    LPackage,\r\n    LParameter,\r\n    LReference,\r\n    LValue,\r\n    LVertex,\r\n    LVoidEdge,\r\n    LVoidVertex\r\n} from \"../joiner\";\r\nimport type React from \"react\";\r\nimport {ReactNode} from 'react';\r\n\r\nexport type double = number;\r\nexport type float = number;\r\nexport type int = number;\r\nexport type byte = number;\r\nexport type uint = number;\r\nexport type ubyte = number;\r\nexport type ratio = number; // [0, 1]\r\nexport type percent = number; // [0, 1]\r\nexport type degree = number;\r\nexport type radian = number;\r\n\r\nexport declare type Class<CtorArgs extends any[] = any[], InstanceType = {}, StaticType = {}, IsAbstract = false> = (abstract new (...args: any[]) => InstanceType) & StaticType;\r\nexport declare type CClass<CtorArgs extends any[] = any[], InstanceType = {}, StaticType = {}, IsAbstract = false> = (new (...args: any[]) => InstanceType) & StaticType;\r\ninterface Caller { caller: any; }\r\ninterface Bind { bind: any; }\r\ninterface Apply { apply: any; }\r\ninterface Call { call: any; }\r\nexport type Function =  Caller | Bind | Apply | Call;\r\nexport type Function2 =  (...a: any) => any;\r\nexport type Constructor<InstanceType = any> = (new (...a: any) => InstanceType) & {__proto__?: Constructor<InstanceType> & GObject};\r\nexport type AbstractConstructor<InstanceType = any> = (GObject | (new (...a: any) => InstanceType)) & {__proto__?: Constructor<InstanceType> & GObject};\r\nexport type Temporary = any;\r\nexport type Nullable<T> = T | null\r\nexport type UnixTimestamp = number;\r\ninterface NoCaller { caller?: never; }\r\ninterface NoBind { bind?: never; }\r\ninterface NoApply { apply?: never; }\r\ninterface NoCall { call?: never; }\r\n\r\n\r\nexport type MultiSelectOption = {value: string, label: string, title?:string};\r\nexport type MultiSelectOptGroup = {label: string, options: MultiSelectOption[]};\r\n\r\n\r\nexport type orArr<T> = T | T[];\r\nexport type unArr<T extends any[] | any> = T extends any[] ? T[0] : T;\r\n\r\n// type primitiveType = string | number | boolean | symbol | null | undefined;\r\nexport type PrimitiveType = string | number | boolean | null | undefined;\r\ntype NotAFunction = NoCaller | NoBind | NoApply | NoCall;\r\ntype NotFunction = GObject & NotAFunction | PrimitiveType;\r\nexport type Info = {\r\n    txt: ReactNode,\r\n    label?: ReactNode,\r\n    type?: ShortAttribETypes | string; //| GObject<\"Enum\">,\r\n    readType?: ShortAttribETypes | string | typeof RuntimeAccessibleClass,\r\n    writeType?: ShortAttribETypes | string | typeof RuntimeAccessibleClass,\r\n    obsolete?: boolean, // hidden because is about to be removed\r\n    hidden?: boolean, // hidden for other reason (like autogeneration is faulty and is manually generated)\r\n    todo?: boolean, // features that should not be listed yet in the view editor\r\n    isGlobal?: boolean, // for things that are common to all graph elements like jsx\r\n    isNode?: boolean,\r\n    isEdge?: boolean,\r\n    isEdgePoint?: boolean,\r\n    enum?: GObject, // todo: remove or use it\r\n    pattern?: string // regexp validation\r\n    min?: number; // for numeric types\r\n    max?: number; // for numeric types\r\n    positive?: boolean; // for numeric types\r\n    digits?: number; // for decimal types validation\r\n    step?: number// for decimal types numeric spinner increase\r\n\r\n};\r\n\r\n\r\nexport type Empty = any;\r\nexport type UObject = { [key: string]: unknown; }\r\nexport type GObject<DocSubType = ''> = DocSubType extends object ? { [key: string]: any; } & DocSubType : { [key: string]: any; };\r\nexport type RawObject = { [key: string]: NotFunction; };\r\n// Json<T> = oggetto con le chiavi di T senza le funzioni (post deserializzazione)\r\nexport type Json<T extends GObject = RawObject> =\r\n        {[key in keyof T]: T[key] extends Function ? never : (T[key] extends symbol ? \"symbol\" :\r\n            Exclude<T[key], symbol>); }\r\n        ;\r\n\r\n// export type Dictionary<K extends keyof any, T> = { [P in K]: T; };\r\nexport type Dictionary<K extends keyof GObject = any, V = any> = { [P in K]: V; } & { _subMaps?: V};\r\n// _subMaps type *actually just Dict<str, boolean> but if i set it as bool and access a random element of the map it will be typed as boolean | V*/\r\nexport type DocString<T, COMMENT = ''> = string;\r\nexport type NotFound = null;\r\nexport const NotFoundv = null as NotFound;\r\nexport type nstring = null | string;\r\nexport type nnumber = null | number;\r\nexport type nbool = null | boolean;\r\nexport type bool = boolean;\r\nexport type NotBool<T> = Exclude<T, boolean>;\r\nexport type TODO<T = any> = any;\r\nexport type NonEmptyString = Exclude<string, ''>;\r\nexport enum EdgeBendingMode {\r\n    \"Line\"=\"L\", // end\r\n    \"Bezier_quadratic\"=\"Q\", // bending1, end\r\n    \"Bezier_cubic\"=\"C\", // bending1, bending2, end\r\n    // \"Bezier_cubic_mirrored\"=\"S\", // bending1, end // when there are multiple bezier curves on a row, this takes a bendingpoint1 from the last bezier curves mirrored https://css-tricks.com/svg-path-syntax-illustrated-guide/\r\n    // \"Bezier_quadratic_mirrored\"=\"T\", // end // when there are multiple bezier curves on a row, this takes a bendingpoint1 from the last bezier curves mirrored https://css-tricks.com/svg-path-syntax-illustrated-guide/\r\n    \"Elliptical_arc\" = \"A\",// x y, rot, arc sweep, x y.  x,y are coords. rot is angle [0, 360), arc & sweep are {0,1}\r\n    // can do elliptical arc with a single EP. rotation i take it from rotating the actual EP. arc & sweep i take it from node state (maybe rotation too)\r\n    \"Bezier_QT\"=\"QT\", // first a Quadratic, then N quadratic mirrored\r\n    \"Bezier_CS\"=\"CS\", // first a Quadratic, then N quadratic mirrored\r\n}\r\nexport enum EdgeGapMode {\r\n    \"gap\" = \"gap\",\r\n    //\"autoFill\" = \"autoFill\",\r\n    //\"lineFill\" = \"lineFill\",\r\n    //\"arcFill\" = \"arcFill\",\r\n    \"center\" = \"center\",\r\n    \"average\" = \"average\",\r\n    // \"closest\" = \"closest\", does not work properly, just disabled. average is doing similar and better.\r\n}\r\nexport enum EMeasurableEvents {\r\n    // data\r\n    onDataUpdate = \"onDataUpdate\",\r\n    // drag\r\n    onDragStart = \"onDragStart\",\r\n    onDragEnd = \"onDragEnd\",\r\n    whileDragging = \"whileDragging\",\r\n    // resize\r\n    onResizeStart = \"onResizeStart\",\r\n    onResizeEnd = \"onResizeEnd\",\r\n    whileResizing = \"whileResizing\",\r\n    // rotate\r\n    onRotationStart = \"onRotationStart\",\r\n    onRotationEnd = \"onRotationEnd\",\r\n    whileRotating = \"whileRotating\",\r\n}\r\n\r\n// export type Subtract<T, K> = {  [L in Exclude<keyof T, K>]: T[L] };\r\n// Or alternatively, and more concisely, as:\r\n\r\n// export type Subtract<T, K> = Pick<T, Exclude<keyof T, K>>;\r\nexport type Subtract<T, K> = Omit<T, keyof K>;\r\nexport type Overlap<T1, T2> =  Omit<T1, keyof T2> & T2;\r\n\r\n\r\n\r\n\r\n\r\n// tipo puramente documentazionale, è solo una stringa o array di stringhe\r\n/*export type Pointer<T extends DPointerTargetable = DPointerTargetable, lowerbound = number, upperbound = number | string, RET = LPointerTargetable> =\r\n    upperbound extends 'N' ? string[] : (\r\n    upperbound extends 0 ? never : (\r\n    lowerbound extends 0 ? (string | undefined | null) : string)); // & {[Symbol.iterator]: () => IterableIterator<string>};\r\n*/\r\ndeclare global  {\r\n    interface ProxyConstructor {\r\n        new <TS extends object, TT extends object = TS>(target: TS, handler: ProxyHandler<TS>): TT;\r\n        // official flawed definition: new <T extends object>(target: T, handler: ProxyHandler<T>): T;\r\n    }\r\n\r\n}\r\n\r\n\r\n// export type Proxyfied<T extends object> = T | GObject;// | T;\r\n\r\nexport type Proxyfied<T extends object> = UObject & T;\r\nexport const windoww: typeof window & GObject= window;\r\nexport type InOutParam<T> = T;\r\n\r\nexport type IsActually<T> = any; // for some reason typescript complains about circular type references? this is a workaround\r\nexport type Any<T> = any;\r\n\r\ntype KeysnotOfType<T, TT> = { [P in keyof T as (T[P] extends TT ? never : P)]: T[P] };\r\ntype ObjectWithoutStrings<T> = {\r\n    [P in keyof T as (T[P] extends string ? never : (T[P] extends string[] ? never : P))]: T[P] // working on arr, keeps single ptrs\r\n};\r\ntype pureStringsNoPointers<T> = {\r\n    [P in keyof T as ( T[P] extends Pointer ? (Pointer extends T[P] ? P : (never)): never)]: T[P]\r\n};\r\nexport type ObjectWithoutPointers<T> = Omit<ObjectWithoutStrings<T> & pureStringsNoPointers<T>, 'pointedBy' | '_storePath'>\r\n\r\ntype refkeys = \"parent\" | \"father\" | \"classifiers\" | \"children\" | \"classes\" | \"packages\" | \"subpackages\" | \"annotations\" | \"\"\r\n    | \"type\" | \"attributes\" | \"references\" | \"operations\" | \"parameters\" | \"..... much more\"\r\n\r\nexport type InitialSizeField = number ;// | ((segment: EdgeSegment) => number);\r\nexport type InitialVertexSizeObj = Partial<{\r\n    id?: DocString<\"Just something to be used as a react key. doesn't need to be a proper Pointer id\">,\r\n    index?: number, // where the EdgePoint should be inserted\r\n    w: InitialSizeField, h: InitialSizeField, x: InitialSizeField, y: InitialSizeField}>;\r\nexport type InitialVertexSizeFunc = ((parent: LVoidEdge|LGraphElement, thiss: LVoidVertex|LEdgePoint)=>InitialVertexSizeObj);\r\nexport type InitialVertexSize =  undefined | InitialVertexSizeObj | InitialVertexSizeFunc; // | ((segment: EdgeSegment) => privateTempIVS);\r\nexport type Dependency = {\r\n    root: keyof DState,\r\n    obj: Pointer<DPointerTargetable, 0, 1>,\r\n    field: keyof DPointerTargetable|'',\r\n    op: ''|'-='\r\n};\r\nexport type Selected = Dictionary<Pointer<DUser>, Pointer<DGraphElement, 0, 1>>;\r\nexport type FakeStateProps = any;\r\nexport type ApiResponse = {code: number, body: Json|string}\r\nexport type DataTypes = LModel|LPackage|LClass|LEnumerator|LAttribute|LReference|LOperation|LParameter|LEnumLiteral|LObject|LValue\r\nexport type NodeTypes = LGraph|LGraphVertex|LVoidVertex|LVertex|LGraphElement|LEdge|LEdgePoint;\r\nexport interface DefaultProps {key?: string|number, children?: ReactNode}\r\n","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\joiner\\ExecuteOnRead.ts",["885"],"import {\r\n    AttribETypes,\r\n    CoordinateMode,\r\n    EdgeBendingMode,\r\n    EdgeHead,\r\n    EGraphElements,\r\n    EModelElements,\r\n    stateInitializer,\r\n    ShortAttribETypes,\r\n    windoww,\r\n    AccessModifier,\r\n    EdgeGapMode, GObject\r\n} from \"../joiner\";\r\nimport * as Componentss from '../joiner/components';\r\nimport React from \"react\";\r\n\r\n\r\n/*\r\nlet pairs = [\r\n    [DAnnotation, LAnnotation],\r\n    [DModelElement, LModelElement],\r\n    [DAttribute, LAttribute],\r\n    [DClass, LClass],\r\n    [DClassifier, LClassifier],\r\n    [DEnumerator, LEnumerator],\r\n    [DEnumLiteral, LEnumLiteral],\r\n    [DModel, LModel],\r\n    [DObject, LObject],\r\n    [DOperation, LOperation],\r\n    [DPackage, LPackage],\r\n    [DParameter, LParameter],\r\n    [DReference, LReference],\r\n    [DStructuralFeature, LStructuralFeature],\r\n    [DValue, LValue],\r\n    [DModelElementTransientProperties, LModelElementTransientProperties],\r\n    [DViewTransientProperties, LViewTransientProperties],\r\n    [DViewPrivateTransientProperties, LViewPrivateTransientProperties],\r\n    [DViewElement, LViewElement],\r\n    [DVoidVertex, LVoidVertex]\r\n    // [DMap, LMap],\r\n];\r\n*/\r\n\r\n/*for (let pair of pairs as any[]) {\r\n    pair[0].logic = pair[1];\r\n    pair[1].singleton = new pair[1]();\r\n    pair[1].structure = pair[0];\r\n    windoww[pair[0].name] = pair[0];\r\n    windoww[pair[1].name] = pair[1];\r\n}*/\r\n\r\n/*\r\nDAnnotation.logic = LAnnotation;\r\nLAnnotation.singleton = new LAnnotation();\r\n\r\nDModelElement.logic = LModelElement;\r\nLModelElement.singleton = new LModelElement();\r\nDAttribute.logic = LAttribute;\r\nLAttribute.singleton = new LAttribute();\r\nDClass.logic = LClass;\r\nDClassifier.logic = LClassifier;\r\nDEnumerator.logic = LEnumerator;\r\nDEnumLiteral.logic = LEnumLiteral;\r\nDModel.logic = LModel;\r\nDOBject.logic = LObject;\r\nDOperation.logic = LOperation;\r\nDPackage.logic = LPackage;\r\nDParameter.logic = LParameter;\r\nDReference.logic = LReference;\r\nDStructuralFeature.logic = LStructuralFeature;\r\nDValue.logic = LValue;\r\nDModelElementTransientProperties.logic = LModelElementTransientProperties;\r\n\r\nLClass.singleton = new LClass();\r\nLClassifier.singleton = new LClassifier();\r\nLEnumerator.singleton = new LEnumerator();\r\nLEnumLiteral.singleton = new LEnumLiteral();\r\nLOperation.singleton = new LOperation();\r\nLPackage.singleton = new LPackage();\r\nLParameter.singleton = new LParameter();\r\nLReference.singleton = new LReference();\r\nLStructuralFeature.singleton = new LStructuralFeature();\r\nLValue.singleton = new LValue();\r\nLModel.singleton = new LModel();\r\nLObject.singleton = new LObject();\r\nLModelElementTransientProperties.singleton = new LModelElementTransientProperties();\r\n*/\r\nexport const fakeExport = {}; // just to import-execute this file\r\n// DState.fakeinit();\r\n// Symbol.prototype.toString = function(): string { alert('symbol to string'); return String(this); }\r\n\r\nlet Components = Componentss;\r\n/*\r\nComponents.map(C=> {\r\n    if (typeof C === 'object') return\r\n})\r\nfor (let Comp of Components) {\r\n\r\n}*/\r\nlet wComponents: GObject = {...Components}\r\n// set fallback keys without \"Component\" string, only if this does not make a naming conflict.\r\nfor (let key in wComponents) {\r\n    let index = key.indexOf(\"Component\")\r\n    if (index === -1) continue;\r\n    let newkey = key.substring(0, index);\r\n    if ((Components as any)[newkey]) continue;\r\n    (wComponents as any)[newkey] = (Components as any)[key];\r\n}\r\nwindoww.React = React;\r\n// (Components as any)[\"input\"] = Components[\"InputComponent\"];\r\nwindoww.Components = wComponents;\r\nfor (let k in wComponents) {\r\n    if (windoww[k] && windoww[k] !== wComponents[k]) {\r\n        let str = \"Component naming conflict with a preexisting variable \\\"\" + k + \"\\\"\";\r\n        console.error(str, {inWindow:windoww[k], inComponents:wComponents[k]});\r\n        throw new Error(str);\r\n    }\r\n    windoww[k] = wComponents[k];\r\n}\r\n\r\nwindoww.enumerators = {};\r\n\r\n\r\n(window as any).ShortAttribETypes = ShortAttribETypes;\r\n(window as any).enumerators.ShortAttribETypes = ShortAttribETypes;\r\n(window as any).AccessModifier = AccessModifier;\r\n(window as any).enumerators.AccessModifier = AccessModifier;\r\n(window as any).AttribETypes = AttribETypes;\r\n(window as any).enumerators.AttribETypes = AttribETypes;\r\n(window as any).CoordinateMode = CoordinateMode;\r\n(window as any).enumerators.CoordinateMode = CoordinateMode;\r\n(window as any).EdgeHead = EdgeHead;\r\n(window as any).enumerators.EdgeHead = EdgeHead;\r\n(window as any).EGraphElements = EGraphElements;\r\n(window as any).enumerators.EGraphElements = EGraphElements;\r\n(window as any).EModelElements = EModelElements;\r\n(window as any).enumerators.EModelElements = EModelElements;\r\n(window as any).EdgeGapMode = EdgeGapMode;\r\n(window as any).enumerators.EdgeGapMode = EdgeGapMode;\r\n(window as any).EdgeBendingMode = EdgeBendingMode;\r\n(window as any).enumerators.EdgeBendingMode = EdgeBendingMode;\r\n\r\nfunction afterStoreLoad() {\r\n    stateInitializer();\r\n}\r\n\r\n// afterStoreLoad();\r\n//setTimeout( afterStoreLoad, 0);\r\n","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\common\\Log.ts",["886"],"import {Dictionary, MyError, RuntimeAccessible, windoww} from \"../joiner\";\r\nimport {U} from \"./U\";\r\nimport {NotBool} from \"../joiner/types\";\r\n\r\nexport type LoggerType = \"l\" | \"i\" | \"w\" | \"e\" | \"ex\" | \"eDev\" | \"exDev\";\r\nexport class LoggerCategoryState{\r\n    static counter: number = 0;\r\n    category: LoggerType;\r\n    time: number;\r\n    expireTime?: number; // set dynamically during display phase, it is just a cache.\r\n    raw_args: any[];\r\n    short_string: string;\r\n    long_string: string;\r\n    exception?: Error\r\n    key: string | number;\r\n    toastHidden?: undefined | true;\r\n\r\n\r\n    constructor(args: any[], short_string: string, cat: LoggerType, exception?: Error) {\r\n        this.raw_args = args;\r\n        this.time = new Date().getTime();\r\n        this.category = cat;\r\n        this.short_string = short_string;\r\n        this.long_string = '';\r\n        this.exception = exception;\r\n        this.key = (LoggerCategoryState.counter++); // + '_' + this.time + '_' + this.short_string;\r\n\r\n        // this.long_string = JSON.stringify(U.cropDeepObject(args, 10, 20, 45, 35, 5), null, '\\t');\r\n        /*\r\n        const maxChars: Dictionary<string, [number, number]> = {\r\n            function: [50, 0],\r\n            object: [100, 0],\r\n            string: [80, 20],\r\n        }\r\n        let ansiConvert = (window as any).ansiConvert;\r\n        if (!ansiConvert) {\r\n            (window as any).ansiconvert = ansiConvert = new Convert();\r\n        }\r\n        for (let a of args){\r\n            let s: string;\r\n            let ta: string = typeof a;\r\n            switch(ta){\r\n                case \"function\": s = a.toString(); break;\r\n                case \"object\":\r\n                    let outstr = U.inspect(a, true, 2, true);\r\n                    outstr = U.replaceAll(ansiConvert.toHtml(outstr), \"style=\\\"color:#FFF\\\"\", \"style=\\\"color:#000\\\"\");\r\n                    let regexpCloseTags = new RegExp(\"(\\\\<span style\\\\=\\\"color\\\\:\\\\#)\", \"gm\");\r\n                    outstr = U.replaceAll( outstr, \"$\", \"£\");\r\n                    outstr = outstr.replace(regexpCloseTags,  \"</span>$1\");\r\n                    outstr = U.replaceAll(outstr, \"£\", \"$\");\r\n                    s = outstr;\r\n                    break;\r\n                default: s = ''+a;\r\n            }\r\n            if (maxChars[ta]) s = U.cropStr(s, maxChars[ta][0], maxChars[ta][1]);\r\n            this.long_string += s;\r\n        }*/\r\n    }\r\n}\r\n\r\n@RuntimeAccessible('Log')\r\nexport class Log{\r\n    // public static history: Dictionary<string, Dictionary<string, any[]>> = {}; // history['pe']['key'] = ...parameters\r\n    public static lastError: any[];/*\r\n    public static last_e: LoggerCategoryState[] = [];\r\n    public static last_eDev: LoggerCategoryState[] = [];\r\n    public static last_ex: LoggerCategoryState[] = [];\r\n    public static last_exDev: LoggerCategoryState[] = [];\r\n    public static last_w: LoggerCategoryState[] = [];\r\n    public static last_i: LoggerCategoryState[] = [];*/\r\n    // private static loggerMapping: Dictionary<string, LoggerInterface[]> = {} // takes function name returns logger list\r\n    public static allMessages: LoggerCategoryState[] = []\r\n    public static messageMapping: Dictionary<LoggerType, LoggerCategoryState[]> = {\r\n        l: [],\r\n        i: [],\r\n        w: [],\r\n        e: [],\r\n        ex: [],\r\n        eDev: [],\r\n        exDev: [],\r\n    } // takes function name returns log messages list\r\n\r\n\r\n    static disableConsole(){\r\n        // @ts-ignore\r\n        console['logg'] = console.log;\r\n        console.log = () => {}; }\r\n\r\n    static enableConsole() {\r\n        // @ts-ignore\r\n        if (console['logg']) console.log = console['logg']; }\r\n\r\n    private static log(prefix: string, category: LoggerType, originalFunc: typeof console.log, b: boolean, canthrow: boolean, ...restArgs: any[]): string {\r\n        if (!b) { return ''; }\r\n        const key: string = windoww.U.getCaller(1); // todo: remove replace heavy fumc\r\n        if (restArgs === null || restArgs === undefined) { restArgs = []; }\r\n        let str = key + ': ';\r\n        for (let i = 0; i < restArgs.length; i++) {\r\n            // console.log(prefix, {i, restArgs, curr:restArgs[i]});\r\n            str += '' +\r\n                (typeof restArgs[i] === 'symbol' ?\r\n                    '' + String(restArgs[i]) :\r\n                    restArgs[i])\r\n                + '\\t\\r\\n'; }\r\n        let prefixedstr = '[' + prefix + ']' + str;\r\n\r\n        let exception: Error | undefined = (canthrow ? new MyError(prefixedstr, ...restArgs) : undefined);\r\n\r\n        Log.updateLoggerComponent(category, restArgs, str, category, exception);\r\n        // merged loggers if (Log.loggerMapping[category]) for (const logger of Log.loggerMapping[category]) { logger.log(category, key, restArgs, str); }\r\n        originalFunc(key, ...restArgs);\r\n        if (exception) throw exception;\r\n        return prefixedstr;\r\n    }\r\n\r\n    public static e(b: boolean, ...restArgs: any[]): string {\r\n        if (!b) return '';\r\n        const str = Log.log('Error', 'e', console.error, b, false, ...restArgs);\r\n        Log.lastError = restArgs;\r\n        return str;\r\n        // throw new Error(str);\r\n    }\r\n\r\n    public static eDev(b: boolean, ...restArgs: any[]): string {\r\n        if (!b) return '';\r\n        Log.lastError = restArgs;\r\n        windoww.ee = restArgs;\r\n        windoww.e1 = restArgs[1];\r\n        return Log.log('Dev Error','eDev', console.error, b, false, ...restArgs);\r\n    }\r\n\r\n    public static ex(b: boolean, ...restArgs: any[]): null | never | any {\r\n        if (!b) return null;\r\n        Log.lastError = restArgs;\r\n        windoww.ee = restArgs;\r\n        windoww.e1 = restArgs[1];\r\n        Log.log('Error', 'e', console.error, b, true, ...restArgs);}\r\n\r\n    public static exDev(b: boolean, ...restArgs: any[]): null | never | any {\r\n        if (!b) return null;\r\n        Log.lastError = restArgs;\r\n        windoww.ee = restArgs;\r\n        windoww.e1 = restArgs[1];\r\n        Log.log('Dev Error','eDev', console.error, b, true, ...restArgs);\r\n    }\r\n\r\n    public static i(b: boolean, ...restArgs: any[]): string | null {\r\n        if (!b) return null;\r\n        return Log.log('Info', 'i', console.log, b, false, ...restArgs);\r\n    }\r\n    public static _loggerComponent: any = undefined as any;\r\n    private static get_loggercomponent(): any { return Log._loggerComponent; }\r\n    private static updateLoggerComponent(type: LoggerType, args: any[], short_str: string, cat: LoggerType, exception?: Error): void {\r\n        let c = Log.get_loggercomponent();\r\n        let update: LoggerCategoryState = new LoggerCategoryState(args, short_str, cat, exception);\r\n        Log.messageMapping[type].push(update);\r\n        Log.allMessages.push(update);\r\n        if (!c) return;\r\n        c.setState({[type+\"_counter\"]: c.state[type+\"_counter\"]+1}); // so it doesn't pass through redux\r\n    }\r\n    public static l(b: boolean, ...restArgs: any[]): string | null {\r\n        if (!b) return null;\r\n        return Log.log('Log', 'l', console.log, b, false, ...restArgs);\r\n    }\r\n    public static w(b: boolean, ...restArgs: any[]): string | null {\r\n        if (!b) return null;\r\n        return Log.log('Warn', 'w', console.warn, b, false, ...restArgs); }\r\n\r\n\r\n    public static eDevv<T extends any = any>(firstParam?: NotBool<T>, ...restAgs: any): string { return Log.eDev(true, ...[firstParam, ...restAgs]); }\r\n    public static ee(...restAgs: any): string { return Log.e(true, ...restAgs); }\r\n    public static exDevv<T extends any = any>(firstParam?: NotBool<T>, ...restAgs: any): never | any { return Log.exDev(true, ...[firstParam, ...restAgs]); }\r\n    public static exx(...restAgs: any): never | any { return Log.ex(true, ...restAgs); }\r\n    public static ii(...restAgs: any): string { return Log.i(true, ...restAgs) as string; }\r\n    public static ll(...restAgs: any): string { return Log.l(true, ...restAgs) as string; }\r\n    public static ww(...restAgs: any): string { return Log.w(true, ...restAgs) as string; }\r\n\r\n\r\n    static getByError(error: Error) {\r\n        for (let m of Log.allMessages){\r\n            if (m.exception === error) return m;\r\n            /*\r\n            switch (m.category){\r\n                case 'l': case 'i': case 'w': continue;\r\n                default: break;\r\n            }\r\n            if (U.deepFindInObject(m.raw_args, error, undefined, 3)) return m;*/\r\n        }\r\n\r\n    }\r\n}\r\n// (window as any).Log = Log;\r\n","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\common\\UObj.ts",["887","888"],"import {GObject, Log, PointedBy, RuntimeAccessible} from \"../joiner\";\r\nimport {U, Uarr} from \"../joiner\";\r\nconst stringify = require('json-stable-stringify');\r\n\r\n@RuntimeAccessible('Uobj')\r\nexport class Uobj {\r\n    static cname: string = 'Uobj';\r\n\r\n    // difference react-style. lazy check by === equality field by field. parameters are readonly\r\n    public static objdiff<T extends GObject>(old:T, neww: T, includeProto: boolean = true): {removed: Partial<T>, added: Partial<T>, changed: Partial<T>, unchanged: Partial<T>} {\r\n        // let ret: GObject = {removed:{}, added:{}, changed:{}};\r\n        let ret: {removed: Partial<T>, added: Partial<T>, changed: Partial<T>, unchanged: Partial<T>}  = {removed:{}, added:{}, changed:{}, unchanged: {}};\r\n        if (!neww && !old) { return ret; }\r\n        if (!neww) {\r\n            ret.removed = old;\r\n            if (!includeProto){\r\n                ret.removed = {...ret.removed, __proto__:{}};\r\n            }\r\n            return ret;\r\n        }\r\n        if (!old) {\r\n            ret.added = neww;\r\n            if (!includeProto) {\r\n                ret.added = {...ret.added, __proto__:{}};\r\n            }\r\n            return ret;\r\n        }\r\n        // let oldkeys: string[] = Object.keys(old); let newkeys: string[] = Object.keys(neww);\r\n\r\n        let key: any;\r\n        for (key in old) {\r\n            if (!includeProto && !old.hasOwnProperty(key)) continue;\r\n            // if (neww[key] === undefined){\r\n            // if neww have a key with undefined value, it counts (and should) as having that property key defined\r\n            if (!(key in neww)){ (ret.removed as GObject)[key] = old[key]; }\r\n            else if (neww[key] === old[key]) { (ret.unchanged as GObject)[key] = old[key] }\r\n            else (ret.changed as GObject)[key] = old[key];\r\n        }\r\n        for (let key in neww) {\r\n            if (!includeProto && !neww.hasOwnProperty(key)) continue;\r\n            if (!(key in old)){ (ret.added as GObject)[key] = neww[key]; }\r\n        }\r\n        if (Array.isArray(neww)) {\r\n            if (neww.length === old.length) { (ret.unchanged as GObject).length = neww.length; }\r\n            else {\r\n                let newb = 'length' in neww;\r\n                let oldb = 'length' in old;\r\n                if (newb && !oldb) (ret.added as GObject).length = neww.length;\r\n                else if (!newb && oldb) (ret.removed as GObject).length = neww.length;\r\n                else (ret.changed as GObject).length = neww.length;\r\n            }\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    // returns <\"what changed from old to neww\"> and in nested objects recursively\r\n    // todo: how can i tell at what point it's the fina lvalue (might be a nestedobj) and up to when it's a delta to follow and unroll?   using __isAdelta:true ?\r\n    // NB: this returns the delta that generates the future. if you want the delta that generate the past one, invert parameter order.\r\n    public static objectDelta<T extends object>(old: T, neww: T, deep: boolean = true, includeProto: boolean = false): Partial<T>{\r\n        let newwobj: GObject = neww;\r\n        let oldobj: GObject = old;\r\n        if (old === neww) return {};\r\n        if (!neww) {\r\n            if (includeProto) return old;\r\n            return {...old}; // destructure because i need to remove prototype\r\n        }\r\n        let diff = Uobj.objdiff(old, neww, includeProto); // todo: optimize this, remove the 3 loops below and add those directly in Uobj.objdiff(old, neww, ret); writing inside the obj in third parameter\r\n        let isArr = false;\r\n        let to = typeof old;\r\n        let tn = typeof old;\r\n        if (to !== 'object'/* && tn === 'object'*/) {\r\n            if (includeProto) return neww;\r\n            return {...neww} as any;\r\n        }\r\n        if (tn === 'object' && Array.isArray(neww)) { isArr = true; }\r\n        let ret: GObject = {}; // {__isAdelta:true};\r\n        for (let key in diff.added) {\r\n            //if (!includeProto && diff.added.hasOwnProperty(key)) continue;\r\n            ret[key] = newwobj[key];\r\n        }\r\n        for (let key in diff.changed) {\r\n            let subold = oldobj[key];\r\n            let subnew = newwobj[key];\r\n            if (typeof subold === typeof subnew && typeof subold === \"object\") {\r\n                if (deep) {\r\n                    ret[key] = Uobj.objectDelta(subold, subnew, true, includeProto)\r\n                }\r\n                else {\r\n                    ret[key] = subnew;\r\n                    /*if (typeof neww === 'object' && Array.isArray(subnew)) {\r\n                        ret[key].length = subnew.length;\r\n                        ret[key].__jjObjDiffIsArr = true;\r\n                    }*/\r\n                }\r\n            }\r\n            else ret[key] = subnew;\r\n        }\r\n        // todo: add to variable naming rules: can't start with \"_-\", like in \"_-keyname\", it means \"keyname\" removed in undo delta\r\n        let removedprefix = \"\"; // \"_-\";\r\n        for (let key in diff.removed) {\r\n            ///if (!includeProto && !diff.removed.hasOwnProperty(key)) continue;\r\n            if (ret[removedprefix + key] === undefined) {\r\n                //console.log('undef empty probl<em', {r:diff.removed, val:ret[removedprefix + key], pkey:removedprefix + key, key, ret, old, neww})\r\n            }\r\n            if (key in neww) ret[removedprefix + key] = undefined;\r\n            else ret[removedprefix + key] = '__jjObjDiffEmptyElem';\r\n        } //newwobj[key]; }\r\n        // console.log(\"objdiff\", {old, neww, diff, ret});\r\n        if (isArr) {\r\n            ret.length = (neww as GObject).length;\r\n            ret.__jjObjDiffIsArr = true;\r\n        }\r\n        return ret as Partial<T>;\r\n    }\r\n\r\n\r\n    public static applyObjectDelta(statelevel: GObject, deltalevel: GObject, inplace: boolean = false, asserteq?: GObject): GObject {\r\n        if (!statelevel) statelevel = {};\r\n        // todo: if delta = ObjectDelta('str', {0:'s', 1:'t', 2:'X'}); applydelta('str', delta); what happes?\r\n        if (typeof statelevel !== 'object') statelevel = {}; // return statelevel;\r\n        if (typeof deltalevel !== 'object') return deltalevel as any;\r\n        let oldState = {...statelevel}; // just for debug\r\n        let targetIsArr = deltalevel.__jjObjDiffIsArr || Array.isArray(deltalevel);\r\n        if (!inplace) statelevel = Array.isArray(statelevel) ? Uarr.arrayShallowCopy(statelevel) : {...statelevel}; // NB: [ ...{obj} ] is invalid, but {...[]} is valid, careful\r\n        else if (targetIsArr && !Array.isArray(statelevel)) statelevel = Uarr.arrayShallowCopy(statelevel); // forced to ignore inplace requirement due to change of type (obj -> arr)\r\n\r\n        // statelevel = {...statelevel}; not working if i do it here, just a new var. first time copy id done in caller func undo(). recursive copies are done before recursive step\r\n        let includeProto = false;\r\n        for (let key in deltalevel) {\r\n            let delta = deltalevel[key];\r\n            if (!includeProto && !deltalevel.hasOwnProperty(key)) { continue; }\r\n            // console.log(\"undoing\", {delta, key, deltalevel, statelevel})\r\n            // if (key.indexOf(\"_-\") === 0) { delete statelevel[key.substring(2)]; continue; } // ????????????????????????????????????? todo: check\r\n            if (key === '__jjObjDiffIsArr') continue; // the key is the string, the val is true\r\n            if (delta === '__jjObjDiffEmptyElem') { // the key is the index,the  val is the string\r\n                delete statelevel[key];\r\n                continue;\r\n            }\r\n            if (typeof delta === \"object\") {\r\n                // if (Uobj.isObject(delta, false, false, true)) {\r\n                // if (!inplace) statelevel[key] = Array.isArray(delta) ? Uarr.arrayShallowCopy(statelevel[key]) : {...statelevel[key]};\r\n                // console.log('handling ', {key});\r\n                statelevel[key] = Uobj.applyObjectDelta(statelevel[key], delta, inplace, asserteq?.[key]); }\r\n            else { statelevel[key] = delta; }\r\n        }\r\n        let old = statelevel;\r\n\r\n        if (targetIsArr) {\r\n            statelevel = [];\r\n            for (let k in old) {\r\n                if (!old.hasOwnProperty(k)) continue;\r\n                statelevel[k] = old[k]; // it takes array custom keys\r\n            }\r\n\r\n            //delete statelevel.__jjObjDiffIsArr;\r\n            let len: number = null as any;\r\n            if (Array.isArray(deltalevel) || 'length' in deltalevel) len = deltalevel.length;\r\n            else if ('length' in old) len = old.length;\r\n            else Log.exDevv('cannot find array length', {old, statelevel, deltalevel, asserteq});\r\n            if (!(len>=0)) {\r\n                console.error('invalid array length set', {old, statelevel, deltalevel, asserteq});\r\n            }\r\n            else {\r\n                try { statelevel.length = len; } catch(e){\r\n                    console.error('invalid array length set err', {e, old,\r\n                        len, linold:'length' in old, 'lindelta': 'length' in deltalevel,\r\n                        statelevel, deltalevel, asserteq});\r\n                    throw e;\r\n                }\r\n\r\n            }\r\n        }\r\n\r\n        if (asserteq) {\r\n            let as = stringify(asserteq);\r\n            let rs = stringify(statelevel);\r\n            Log.eDev(as !== rs, 'deltas: error in Uobj.diff, UObj.delta or UObj.patch, assertion failed',\r\n                {oldState, deltalevel, ret:statelevel, asserteq, rs, as, old, targetIsArr});\r\n        }\r\n        return statelevel;\r\n    }\r\n}\r\n\r\nUobj.cname = 'Uobj';","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\joiner\\proxy.ts",["889","890","891","892","893","894"],"import type {DocString, DtoL, DtoW, GObject, Proxyfied, WPointerTargetable,} from \"../joiner\";\r\nimport {\r\n    ABORT,\r\n    Dictionary,\r\n    DModelElement,\r\n    DPointerTargetable,\r\n    JsType,\r\n    LModelElement,\r\n    Log,\r\n    LPointerTargetable,\r\n    Pointer,\r\n    RuntimeAccessible,\r\n    RuntimeAccessibleClass,\r\n    SetFieldAction,\r\n    SetRootFieldAction,\r\n    U\r\n} from \"../joiner\";\r\n\r\ntype NotAConcatenation = null;\r\ntype ERROR = \"_Type_Error_\";\r\n\r\n// (DX extends DUser ? LUser : (DX extends DPointerTargetable ? LPointerTargetable : (ERROR))\r\n// (DX extends DUser ? LUser : (DX extends DPointerTargetable ? LPointerTargetable : (           WViewElement\r\n//\r\n// (IN extends WViewElement ? LViewElement : (IN extends WViewTransientProperties ? LWiewTransientProperties : (ERROR)))\r\n// ))\r\n// type WtoL<WX extends WPointerTargetable> ='';\r\n\r\n@RuntimeAccessible('LogicContext')\r\nexport class LogicContext<\r\n    DX extends GObject = DModelElement,\r\n    LX = DtoL<DX>,\r\n    // PF extends MyProxyHandler<DX> = MyProxyHandler<DX>,\r\n    WX = DtoW<DX>\r\n    > extends RuntimeAccessibleClass{\r\n    public proxyObject: LX;\r\n    public data: DX;// & GObject;\r\n    public write: WX;\r\n    constructor(proxyObject: LX, data: DX) {\r\n        super();\r\n        this.className = (this.constructor as typeof RuntimeAccessibleClass).cname || this.constructor.name;\r\n        this.data = data;\r\n        this.proxyObject = proxyObject;\r\n        this.write = proxyObject as any;\r\n    }\r\n    /*\r\n        saveToRedux(propkey: \"keyof data\" | string, val: \"typeof data[path]\" | any): void { // todo: ask non stackoverflow\r\n            // todo, put data in redux store, path is \"obj1.obj2.obj3...\" might replace it with a path funciton that return the foremost nested object container\r\n            if (!propkey) {\r\n                // todo: set whole object instead of a property\r\n            }\r\n        }*/\r\n}\r\n\r\nRuntimeAccessibleClass.set_extend(RuntimeAccessibleClass, LogicContext);\r\n@RuntimeAccessible('MapLogicContext')\r\nexport class MapLogicContext extends LogicContext<GObject, LPointerTargetable, WPointerTargetable> {\r\n    data: GObject;\r\n    path: string;\r\n    subMaps: string[];\r\n    constructor(proxy: LPointerTargetable, data: GObject, path: string, subMaps: string[] = []) {\r\n        super(proxy, data);\r\n        // this.proxyfyFunction = proxyfyFunction;\r\n        this.proxyObject = proxy;\r\n        this.data = data;\r\n        this.path = path;\r\n        this.subMaps = subMaps;\r\n        this.className = (this.constructor as typeof RuntimeAccessibleClass).cname || this.constructor.name;\r\n    }\r\n}\r\nRuntimeAccessibleClass.set_extend(LogicContext, MapLogicContext);\r\n\r\n@RuntimeAccessible('MyProxyHandler')\r\nexport abstract class MyProxyHandler<T extends GObject> extends RuntimeAccessibleClass implements ProxyHandler<T>{\r\n    s: string = 'set_';\r\n    g: string = 'get_';\r\n    /*get(target: T, p: string | number | symbol, proxyitself: Proxyfied<T>): boolean {\r\n        switch (p) {\r\n            case '_isProxy': return true;\r\n            case 'init': return (this as any).init;\r\n            case 'init0': return (this as any).init0;\r\n            default: throw new Error('proxy get must be overridden, called for key: ' + (p as string));\r\n        }}*/\r\n    set(target: T, p: string | number | symbol, value: any, proxyitself: Proxyfied<T>): boolean { throw new Error('proxy set must be overridden'); }\r\n    deleteProperty(target: T, p: string | symbol): boolean { throw new Error('proxy delete must be overridden'); }\r\n\r\n    ownKeys(target: T): ArrayLike<string | symbol>{\r\n        // return Object.getOwnPropertyNames(target);\r\n        console.log(\"ownkeys trap 1\", {thiss:this, target})\r\n        console.log(\"ownkeys trap 2\", {thiss:this, target, ret:Reflect.ownKeys(target)});\r\n        return Reflect.ownKeys(target);\r\n    }\r\n    /// proxy methods not used\r\n    /* setPrototypeOf(target: T, v: object | null): boolean { ?? }\r\n    apply(target: T, thisArg: any, argArray: any[]): any { }\r\n    defineProperty(target: T, p: string | symbol, attributes: PropertyDescriptor): boolean { }\r\n    construct(target: T, argArray: any[], newTarget: Function): object { }\r\n    getOwnPropertyDescriptor(target: T, p: string | symbol): PropertyDescriptor | undefined { }\r\n    has(target: T, p: string | symbol): boolean { return p in target; }\r\n    getPrototypeOf(target: T): object | null { }\r\n    isExtensible(target: T): boolean { }\r\n    preventExtensions(target: T): boolean { }*/\r\n\r\n    static wrap<D extends RuntimeAccessibleClass, L extends LPointerTargetable = LPointerTargetable, CAN_THROW extends boolean = false,\r\n        RET extends CAN_THROW extends true ? L : L | undefined  = CAN_THROW extends true ? L : L>\r\n    (data: D | Pointer | undefined | null, baseObjInLookup?: DPointerTargetable, path: string = '', canThrow: CAN_THROW = false as CAN_THROW): RET{\r\n\r\n//    static wrap<D extends RuntimeAccessibleClass, L extends LPointerTargetable, RET extends boolean = false>\r\n//        (data: D | Pointer<DViewElement>, baseObjInLookup?: DPointerTargetable, path: string = '', canthrow: RET = false as RET): RET {\r\n        return DPointerTargetable.wrap(data, baseObjInLookup, path) as RET; }\r\n\r\n    static isProxy(data: GObject): boolean { return data?.__isProxy || false; }\r\n}\r\nRuntimeAccessibleClass.set_extend(RuntimeAccessibleClass, MyProxyHandler);\r\nexport type GetPath<T = GObject> = T;\r\n/*\r\n* handling proxy += and proxy -=\r\n*\r\n* will become var = var + add; which will call Symbol.getPrimitive\r\nconsole.log(+obj2);     // 10        — hint is \"number\"         NaN with +array with multiple vals, +array[0] with array of size 1, NaN with functions & objects\r\nconsole.log(`${obj2}`); // \"hello\"   — hint is \"string\"         array => array.join(','), object => \"[object Object]\", function => function.toString() whole func definition with body code\r\nconsole.log(obj2 + \"\"); // \"true\"    — hint is \"default\"        array, object, function => same as with hint \"string\"\r\n*\r\n* */\r\n\r\n// NB: lclass.extends += somepointer will become: lclass.extends = lclass.extends + somepointer;\r\n// array + string will cause getPrimitive(\"default\") to array, then .join(',') on it, and finally and toString() to be called on all array members.\r\n// so pointers cannot include \",\" char and toString() must return a pointer to keep lclass.extends += somepointer as a valid expression;\r\n// -= will call getPrimitive(\"number\") which will result in array -> NaN, so NaN = NaN - pointer and cannot be done.\r\n// or maybe it can because if getPrimitive fails it calls toString as fallback, and viceversa\r\n\r\n@RuntimeAccessible('GetPathHandler')\r\nclass GetPathHandler<T extends GObject> extends MyProxyHandler<T>{\r\n    public static __asCalls: boolean = false;\r\n    public static __asArray: boolean = false;\r\n    public static __nested: boolean = true;\r\n    private strbuilder: string = '';\r\n    private array: (string | number | symbol)[] = [];\r\n    private calls: (GObject<'parameters of get calls'>)[] = [];\r\n\r\n    public constructor() { super(); }\r\n\r\n    get(targetObj: T, propKey: keyof T | string, proxyitself: Proxyfied<T>): any {\r\n        // console.log('GetPathHandler', {targetObj, propKey, proxyitself});\r\n        if (propKey === \"start\") { this.strbuilder = ''; this.array = []; }\r\n        if (propKey === '$') {\r\n            const ret = GetPathHandler.__asCalls ? this.calls : (GetPathHandler.__asArray ? this.array : this.strbuilder);\r\n            this.array = [];\r\n            this.strbuilder = '';\r\n            return ret; }\r\n        this.array.push(propKey);\r\n        this.calls.push(arguments);\r\n        if (propKey === Symbol.toPrimitive) {\r\n            console.log(\"toprimitive\");\r\n            return (...a: any)=> {console.log(\"toprimitive called with parameters\", a); }\r\n        }\r\n        if (!GetPathHandler.__asArray && !GetPathHandler.__asCalls) {\r\n            if (typeof propKey === \"symbol\") { this.strbuilder += propKey.toString(); }\r\n            else {\r\n                // Giordano: add ignore for webpack\r\n                //@ts-ignore\r\n                this.strbuilder += (this.strbuilder ? '.' : '') + propKey;\r\n            }\r\n        }\r\n        return GetPathHandler.__nested ? proxyitself : {};\r\n    }\r\n\r\n    set(target: T, p: string | number | symbol, value: any, proxyitself: Proxyfied<T>): boolean {\r\n        switch(p){\r\n            case '__asArray':\r\n            case '__asCalls':\r\n            case '__nested':\r\n                (GetPathHandler as any)[p] = value;\r\n                return true;\r\n            default:\r\n                throw new Error('getPath proxy cannot be written');\r\n        }\r\n    }\r\n}\r\nRuntimeAccessibleClass.set_extend(MyProxyHandler, GetPathHandler);\r\n@RuntimeAccessible('TargetableProxyHandler')\r\nexport class TargetableProxyHandler<ME extends GObject = DModelElement, LE extends LPointerTargetable = LModelElement> extends MyProxyHandler<ME> {\r\n// permette di fare cose tipo: user.name_surname che ritorna la concatenazione di nome e cognome anche se il campo name_surname non esiste.\r\n    lg: LE & GObject; // to disable type check easily and access 'set_' + varname dynamically\r\n    l: LE;\r\n    d: ME;\r\n    additionalPath: string;\r\n\r\n    public baseObjInLookup: DPointerTargetable;\r\n    static childKeys: Dictionary<string, true> = {'$': true, '@': true};\r\n\r\n    constructor(d: ME, baseObjInLookup?: DPointerTargetable, additionalPath: string = '', l?: LE) {\r\n        super();\r\n        this.d = d;\r\n        if (!l) {\r\n            l = RuntimeAccessibleClass.get(d.className)?.logic?.singleton as LE;\r\n            Log.exDev(!l, 'Trying to wrap class without singleton or logic mapped: ' + d.className, { object: d, className: d.className })\r\n        }\r\n        this.baseObjInLookup = baseObjInLookup || d as any;\r\n        this.additionalPath = additionalPath;\r\n        this.l = l as LE;\r\n        this.lg = this.l;\r\n        this.className = (this.constructor as typeof RuntimeAccessibleClass).cname || this.constructor.name;\r\n    }\r\n\r\n    // damiano todo: this does not work\r\n    private concatenableHandler(targetObj: ME, propKey: number | string | symbol, proxyitself: Proxyfied<ME>): NotAConcatenation | any[] | string {\r\n        //console.log(\"concatenableHandler 1\", {targetObj, propKey, proxyitself});\r\n        if (propKey in targetObj)  return null as NotAConcatenation;\r\n        const propKeyStr: null | string = U.asString(propKey, null);\r\n        let _index: number = propKeyStr ? propKeyStr.indexOf('_') : -1;\r\n        //console.log(\"concatenableHandler 2\", {targetObj, propKey, propKeyStr, proxyitself, _index});\r\n        if (_index < 0) return null as NotAConcatenation;\r\n\r\n        let isConcatenable = true;\r\n        let ret: any[] = (propKey as string).split('_').map( (subKey: string) => {\r\n            //console.log(\"concatenableHandler 3.0\", {targetObj, subKey, propKeyStr, proxyitself});\r\n            // se trovo multipli ___ li tratto come spazi aggiuntivi invece che come proprietà '' che ritornano undefined, così posso fare name___surname --> \"damiano   di vincenzo\"\r\n            let val: any = subKey === '' ? ' ' : this.get(targetObj, subKey, proxyitself);\r\n            isConcatenable = isConcatenable && JsType.isPrimitive(val);\r\n            return val;\r\n        });\r\n        //console.log(\"concatenableHandler 4\", {targetObj, propKey, propKeyStr, proxyitself, ret, isConcatenable});\r\n        return isConcatenable ? ret.join(' ') : ret; }\r\n\r\n    public get(targetObj: ME, propKey: string | symbol, proxyitself: Proxyfied<ME>): any {\r\n        let ret;\r\n        let isError = false;\r\n        // console.error('_proxy get PRE:', {targetObj, propKey, proxyitself, arguments});\r\n        try { ret = this.get0(targetObj, propKey, proxyitself); } catch(e) { ret = e; isError = true;}\r\n\r\n        // if (isError) throw ret;\r\n        // console.error('_proxy get POST:', {targetObj, propKey, ret, isError});\r\n        return ret;\r\n    }\r\n\r\n    public get0(targetObj: ME, propKey: string | symbol, proxyitself: Proxyfied<ME>): any {\r\n        // console.log('proxy keysearch', {propKey, targetObj, l: this.l, proxyitself, d: this.d});\r\n        let canThrowErrors = true;\r\n\r\n        switch(typeof propKey) {\r\n            case \"symbol\":\r\n                propKey = String(propKey);\r\n                // console.log('get symbol', {propKey});\r\n                switch (propKey) {\r\n                    default: Log.exDevv('unexpected symbol in proxy getter:', propKey); break;\r\n                    case 'Symbol(Symbol.toStringTag)': propKey = 'toString'; break; //return (()=>\"[Proxy]\");\r\n                    case \"Symbol(Symbol.toPrimitive)\": propKey = 'toPrimitive'; break;\r\n                }\r\n                break;\r\n            // case \"number\": return null;\r\n        }\r\n\r\n        switch (propKey) {\r\n            case '__l': return this.l;\r\n            case '__d': return this.d;\r\n            case 'inspect': // node.js util\r\n            case \"r\":\r\n            case \"_refresh\":\r\n            case \"_reload\": return LPointerTargetable.wrap(targetObj.id);\r\n            case '__Raw':\r\n            case '__raw': return targetObj;\r\n            case '__serialize': return JSON.stringify(targetObj);\r\n            case '__isproxy':\r\n            case '__isProxy': return true;\r\n            case '__random': return Math.random();\r\n            case 'editCount':\r\n            case 'clonedcounter':\r\n            case 'clonedCounter':\r\n                return targetObj.clonedCounter || 0;\r\n            case '$$typeof':\r\n            case \"typeName\":\r\n                return this.d.className;\r\n            case 'parent': propKey = 'father'; break;\r\n        }\r\n        if (propKey[0] === \"_\" && propKey.indexOf(\"__info_of__\")===0) {\r\n            return (this.l as GObject)[propKey];\r\n        }\r\n\r\n\r\n        // check if exist directly in D.key, L.key or through a get_key\r\n        if (propKey in this.l || propKey in this.d || (this.l as GObject)[this.g + (propKey as string)]) {\r\n            // todo: il LogicContext passato come parametro risulta nell'autocompletion editor automaticamente generato, come passo un parametro senza passargli il parametro? uso arguments senza dichiararlo?\r\n            if (typeof propKey !== 'symbol' && this.g + propKey in this.lg) return this.lg[this.g + propKey](new LogicContext(proxyitself as any, targetObj));\r\n\r\n\r\n\r\n            // if specific custom getter exist\r\n            if (typeof propKey !== 'symbol' && this.g + propKey in this.lg) {\r\n                let getterMethod: Function = this.lg[this.g + propKey]; // || this.defaultGetter;\r\n                // console.log(\"gets method\", {getterMethod, lg:this.lg, thiss: this});\r\n                if (getterMethod) return getterMethod(new LogicContext(proxyitself as any, targetObj));\r\n            }\r\n\r\n        }\r\n        // @ts-ignore\r\n        //console.trace(\"proxy $getter 2\", {targetObj, n:targetObj.name, propKey, l:this.lg, dg:this.lg._defaultGetter});\r\n\r\n\r\n        // if custom generic getter exist\r\n        // @ts-ignore\r\n        if (this.lg._defaultGetter) return this.lg._defaultGetter(new LogicContext(proxyitself as any, targetObj), propKey);\r\n\r\n        // if property do not exist, try a concatenation\r\n        /*let concatenationTentative = null;\r\n        try {concatenationTentative = this.concatenableHandler(targetObj, propKey, proxyitself); } catch(e) {}\r\n        if (concatenationTentative !== null) return concatenationTentative;\r\n        */\r\n        Log.e(canThrowErrors, 'GET property \"'+ (propKey as any)+ '\" do not exist in object of type \"' + U.getType(this.l) + \" DType:\" +  U.getType(this.d), {data: targetObj});\r\n        return undefined;\r\n        // todo: credo che con espressioni sui tipi siano tipizzabili tutti i return di proprietà note eccetto quelle ottenute per concatenazione.\r\n    }\r\n\r\n    public defaultGetter(targetObj: ME, key: string, proxyitself: Proxyfied<ME>): any {\r\n        if (!targetObj) return targetObj;\r\n        if (!targetObj._subMaps || !targetObj._subMaps[key]) return (targetObj as Dictionary)[key];\r\n        // if is a nexted subobject\r\n        let context: MapLogicContext = new MapLogicContext(proxyitself as any, targetObj, key, []);\r\n        let retRaw: Dictionary = this.lg[this.s + key]\r\n        return MapProxyHandler.mapWrap((targetObj as Dictionary)[key], targetObj as any, this.additionalPath + '.' + key)\r\n    }\r\n\r\n    public defaultSetter(targetObj: DPointerTargetable, propKey: string, value: any, proxyitself?: Proxyfied<ME>): boolean {\r\n        SetFieldAction.new(targetObj, propKey as any, value);\r\n        return true;\r\n    }\r\n\r\n    public set(targetObj: ME, propKey: string | symbol, value: any, proxyitself?: Proxyfied<ME>): boolean {\r\n        // console.error('_proxy set PRE:', {targetObj, propKey, value, proxyitself, arguments});\r\n        // if (propKey in this.l || propKey in this.d || (this.l as GObject)[this.s + (propKey as string)] || (this.l as GObject)[(propKey as string)]) {\r\n\r\n        if ((this.d as GObject).__readonly && propKey !== '__readonly') {\r\n            //todo if there is a transaction open i should throw exception?\r\n            if(ABORT()){\r\n                Log.ee('Transaction aborted because an object is readonly:', this.d);\r\n            }\r\n            return true;\r\n        }\r\n        switch (typeof propKey) {\r\n            case \"symbol\":\r\n                propKey = String(propKey);\r\n                Log.exDevv('unexpected symbol in proxy setter:', propKey);\r\n                break;\r\n            default: break;\r\n        }\r\n\r\n        switch (propKey) {\r\n            case 'parent': propKey = 'father'; break;\r\n        }\r\n\r\n        if (propKey in this.l || propKey in this.d || (this.l as GObject)[this.s + (propKey as string)]) {\r\n            // todo: il LogicContext passato come parametro risulta nell'autocompletion editor automaticamente generato, come passo un parametro senza passargli il parametro? uso arguments senza dichiararlo?\r\n            if (typeof propKey !== 'symbol' && this.s + propKey in this.lg) {\r\n                this.lg[this.s + propKey](value, new LogicContext(proxyitself as any, targetObj));\r\n                return true;\r\n            }\r\n\r\n\r\n            // se esiste la proprietà ma non esiste il setter?\r\n            // Log.eDevv(\"dev error: property exist but setter does not: \", propKey, this);\r\n            // return false;\r\n        }\r\n        // if property do not exist\r\n\r\n        // if custom generic setter exist\r\n        // @ts-ignore private property\r\n        if (this.lg._defaultSetter) { // @ts-ignore private property\r\n            this.lg._defaultSetter(value, new LogicContext(proxyitself as any, targetObj), propKey);\r\n            return true;\r\n        }\r\n        /*if (enableFallbackSetter && typeof (propKey === \"string\") && ((propKey as string)[0] === '_' || (propKey as string).indexOf('tmp') > 0)) {\r\n            return this.defaultSetter(targetObj as any as DPointerTargetable, propKey as string, value, proxyitself);\r\n            // new SetFieldAction(new LogicContext(proxyitself as any, targetObj).data as any, propKey as string, value); return true;\r\n        }*/\r\n        let canThrowErrors = true;\r\n        Log.ex(canThrowErrors,'SET property \"set_' + (propKey as any) + '\" do not exist in object of type \"' + U.getType(this.l) + \" DType:\" +  U.getType(this.l), {'this': this, targetObj});\r\n        return false; }\r\n    /*      problema: ogni oggetto deve avere multipli puntatori, quando ne modifico uno devo modificarli tutti, come tengo traccia?\r\n            ipotesi 1: lo memorizzo in un solo posto (store.idlookup) e uso Pointer<type, lb, ub> che è una stringa che simula un puntatore\r\n            problema 1: se fornisco l'intero store ai componenti si aggiornano ad ogni singola modifica, se estraggo i campi interesasti le stringhe puntatore sono invariate ma il contenuto puntato è cambiato e il componente non lo sa...\r\n            problemone 2: non so a quali proprietà dello store devo abbonarmi, devo leggere sempre tutto lo store?\r\n            !!!!! soluzione 2?: dovrei dichiarare le variabili a cui mi abbono, salvarle nello stato e precaricarle tramite mapStateToProps*/\r\n\r\n    public deleteProperty(target: ME, key: string | symbol, proxyItself?: Proxyfied<any>): boolean {\r\n        if (typeof key === \"symbol\") return false;\r\n        this.set(target, key, undefined, proxyItself);\r\n        delete target[key];\r\n        return true; }\r\n\r\n    private mergedObject(target: ME): GObject{\r\n        let ret: GObject = {...target}; // U.arrayMergeInPlace(Object.keys(target), Object.keys(this.l).filter(k => k.indexOf('set_') !== 0 && k.indexOf('get_') !== 0));\r\n        for (let k in this.l) {\r\n            if (!(k in ret) && k.lastIndexOf('get_', 4) !== 0 && k.lastIndexOf('set_', 4) !== 0) ret[k] = true;\r\n        }\r\n        return ret;\r\n    }\r\n    ownKeys(target: ME): ArrayLike<string | symbol>{\r\n        const ret: GObject = this.mergedObject(target);\r\n        // ret = Reflect.ownKeys(ret);\r\n        return Reflect.ownKeys(ret);\r\n    }\r\n\r\n    // has(target: ME, p: string | symbol): boolean { return p in this.mergedObject(target); }\r\n    has(target: ME, p: string | symbol): boolean { return (p in target) || (p in this.l); }\r\n\r\n    /*\r\n    apply(target: DModelElement, thisArg: any, argArray: any[]): any {\r\n        // will i ever use it? dovrei pasare una funzione invece di una classe, quindi in questo caso credo wrappi solo il costruttore\r\n    }*/\r\n}\r\nRuntimeAccessibleClass.set_extend(MyProxyHandler, TargetableProxyHandler);\r\n@RuntimeAccessible('MapProxyHandler')\r\nexport class MapProxyHandler extends TargetableProxyHandler<Dictionary, LPointerTargetable> {\r\n    // todo: sposta alcune funzioni da TargetableProxy a MyProxy e fai estendere direttamente MyProxy a questa classe\r\n    public subMapKeys: Dictionary<string, any | Dictionary<DocString<'nested map keys'>>>;\r\n\r\n    constructor(d: Dictionary, baseObjInLookup: DPointerTargetable, additionalPath: string = '', subMapKeys: Dictionary<string, any | Dictionary<DocString<'nested map keys'>>> = {}) {\r\n        super(d, baseObjInLookup, additionalPath, LPointerTargetable.singleton);\r\n        this.subMapKeys = subMapKeys;\r\n    }\r\n\r\n    get(target: Dictionary, key: string | number | symbol, proxyitself: Proxyfied<Dictionary>): any {\r\n        if (typeof key === \"symbol\") return this.d[key as any];\r\n        let val: any = this.d[key];\r\n        if (key in this.subMapKeys && !(key in target)) { Log.exx('property not found in dictionary', {target, key, thiss:this, proxyitself, submapkeys: this.subMapKeys}); return undefined; }\r\n        if (key in this.subMapKeys) {\r\n            this.additionalPath += '.';\r\n            return MapProxyHandler.mapWrap( this.d, this.baseObjInLookup, this.additionalPath, this.subMapKeys[key]);\r\n            Log.exDevv('todo: wrap sub-map', {thiss: this});\r\n        }\r\n        return target[key as string]; }\r\n\r\n    set(target: Dictionary, key: string | number | symbol, value: any, proxyitself: Proxyfied<Dictionary>): boolean {\r\n        if (typeof key === \"symbol\") { Log.exx('cannot set a symbol in dictionary', {target, key, value, proxyitself}); return false; }\r\n        SetRootFieldAction.new(this.additionalPath + '.' + key, value, '',false)\r\n        return true;\r\n    }\r\n\r\n    public deleteProperty(target: Dictionary, key: string | symbol, proxyItself?: Proxyfied<any>): boolean {\r\n        if (typeof key === \"symbol\") return false;\r\n        this.set(target, key, undefined, proxyItself);\r\n        delete target[key];\r\n        return true; }\r\n}\r\nRuntimeAccessibleClass.set_extend(MyProxyHandler, MapProxyHandler);\r\n// 15-20 min + 5 di domande entro il 1° ottobre, discussione 10-12 ottobre\r\nexport const getPath: GetPath = new Proxy( {}, new GetPathHandler());\r\n(window as any).getPath = getPath;\r\n// usage: pathstring = ((getPath as DType).some.path.to.follow as any).$; // = \"some.path.to.follow\" with compilation-time validation\r\n","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\common\\Defaults.ts",["895"],"import {Pointer, DViewElement, DViewPoint, Dictionary, U, RuntimeAccessible} from '../joiner';\r\n@RuntimeAccessible('Defaults')\r\nexport class Defaults { /// TODO: this really needs to become dynamically generated, after view creations.\r\n    static cname: string = 'Defaults';\r\n    static views: Pointer<DViewElement>[] = [\r\n        'Pointer_ViewModel',\r\n        'Pointer_ViewPackage',\r\n        'Pointer_ViewClass',\r\n        'Pointer_ViewEnum',\r\n        'Pointer_ViewAttribute',\r\n        'Pointer_ViewReference',\r\n        'Pointer_ViewOperation',\r\n        'Pointer_ViewParameter',\r\n        'Pointer_ViewLiteral',\r\n        'Pointer_ViewObject',\r\n        'Pointer_ViewValue',\r\n        // 'Pointer_ViewDefaultPackage',\r\n        'Pointer_ViewVoid',\r\n        'Pointer_ViewEdgeAssociation',\r\n        'Pointer_ViewEdgeDependency',\r\n        'Pointer_ViewEdgeInheritance',\r\n        'Pointer_ViewEdgeAggregation',\r\n        'Pointer_ViewEdgeComposition',\r\n        'Pointer_ViewEdgePoint',\r\n        // 'Pointer_ViewAnchors',\r\n    ];\r\n    static viewpoints: Pointer<DViewPoint>[] = ['Pointer_ViewPointDefault', 'Pointer_ViewPointValidation'];\r\n\r\n    // @ts-ignore\r\n    static defaultViewsMap: Dictionary<Pointer, boolean> = Defaults.views.reduce((acc, val) => { acc[val] = true; return acc; }, {}); // U.objectFromArrayValues(Defaults.views);\r\n    // @ts-ignore\r\n    static defaultViewPointsMap: Dictionary<Pointer, boolean> = Defaults.viewpoints.reduce((acc, val) => { acc[val] = true; return acc; }, {});\r\n\r\n    static check(id: string): boolean {\r\n        return !!Defaults.defaultViewsMap[id] || !!Defaults.defaultViewPointsMap[id]; // id.indexOf('Pointer_View') !== -1\r\n    }\r\n}\r\n","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\joiner\\classes.ts",["896","897","898","899","900","901","902","903","904","905","906","907","908","909","910","911","912","913","914","915","916","917","918","919","920","921","922","923","924","925","926","927","928","929","930","931","932","933","934","935","936","937","938","939","940","941","942","943","944","945","946","947","948","949","950","951","952","953","954","955"],"import {Mixin} from \"ts-mixer\";\r\nimport type {\r\n    DEdge,\r\n    DEdgePoint,\r\n    DExtEdge,\r\n    DGraph,\r\n    DGraphElement,\r\n    DGraphVertex,\r\n    DRefEdge,\r\n    DVertex,\r\n    DVoidEdge,\r\n    DVoidVertex,\r\n    LEdge,\r\n    LEdgePoint,\r\n    LExtEdge,\r\n    LGraphElement,\r\n    LGraphVertex,\r\n    LRefEdge,\r\n    LVertex,\r\n    LVoidEdge,\r\n    LVoidVertex,\r\n    WEdge,\r\n    WEdgePoint,\r\n    WExtEdge,\r\n    WGraph,\r\n    WGraphElement,\r\n    WGraphVertex,\r\n    WRefEdge,\r\n    WVertex,\r\n    WVoidEdge,\r\n    WVoidVertex\r\n} from \"../model/dataStructure\";\r\nimport type {Class, Longest} from \"ts-mixer/dist/types/types\";\r\nimport type {\r\n    DAnnotation,\r\n    DAttribute,\r\n    DClass,\r\n    DClassifier,\r\n    DDataType,\r\n    DEnumerator,\r\n    DEnumLiteral,\r\n    DMap,\r\n    DModel,\r\n    DModelElement,\r\n    DNamedElement,\r\n    DObject,\r\n    DOperation,\r\n    DPackage,\r\n    DParameter,\r\n    DReference,\r\n    DStructuralFeature,\r\n    DTypedElement,\r\n    DValue,\r\n    LAnnotation,\r\n    LAttribute,\r\n    LClass,\r\n    LClassifier,\r\n    LDataType,\r\n    LEnumerator,\r\n    LEnumLiteral,\r\n    LMap,\r\n    LModelElement,\r\n    LNamedElement,\r\n    LObject,\r\n    LOperation,\r\n    LPackage,\r\n    LParameter,\r\n    LReference,\r\n    LStructuralFeature,\r\n    LTypedElement,\r\n    LValue,\r\n    WAnnotation,\r\n    WAttribute,\r\n    WClass,\r\n    WClassifier,\r\n    WDataType,\r\n    WEnumerator,\r\n    WEnumLiteral,\r\n    WMap,\r\n    WModel,\r\n    WModelElement,\r\n    WNamedElement,\r\n    WObject,\r\n    WOperation,\r\n    WPackage,\r\n    WParameter,\r\n    WReference,\r\n    WStructuralFeature,\r\n    WTypedElement,\r\n    WValue\r\n} from \"../model/logicWrapper\";\r\nimport type {\r\n    CClass,\r\n    Constructor,\r\n    Dictionary,\r\n    DocString,\r\n    GObject,\r\n    InitialVertexSize,\r\n    InitialVertexSizeFunc,\r\n    InitialVertexSizeObj,\r\n    orArr,\r\n    Proxyfied,\r\n    unArr\r\n} from \"./types\";\r\nimport {EdgeBendingMode, EdgeGapMode, NodeTypes, PrimitiveType} from \"./types\";\r\nimport type {\r\n    DViewElement,\r\n    DViewTransientProperties,\r\n    LViewTransientProperties,\r\n    WViewElement,\r\n    WViewTransientProperties\r\n} from \"../view/viewElement/view\";\r\nimport type {LogicContext} from \"./proxy\";\r\nimport {\r\n    Action,\r\n    CreateElementAction,\r\n    Defaults,\r\n    DeleteElementAction,\r\n    DLog,\r\n    DState,\r\n    DViewPoint,\r\n    EdgeSegment,\r\n    GraphPoint,\r\n    GraphSize, IPoint, ISize,\r\n    LGraph,\r\n    LLog,\r\n    LModel,\r\n    Log,\r\n    LViewElement,\r\n    LViewPoint,\r\n    ParsedAction, Selectors,\r\n    SetFieldAction,\r\n    SetRootFieldAction,\r\n    ShortAttribETypes,\r\n    statehistory,\r\n    store,\r\n    TRANSACTION,\r\n    U\r\n} from \"./index\";\r\nimport {OclEngine} from \"@stekoe/ocl.js\";\r\nimport {ReactNode} from \"react\";\r\nimport {ProjectsApi} from \"../api/persistance\";\r\nimport {labelfunc} from \"../model/dataStructure/GraphDataElements\";\r\nimport {Dummy} from \"../common/Dummy\";\r\nimport Storage from \"../data/storage\";\r\n\r\nvar windoww = window as any;\r\n// qui dichiarazioni di tipi che non sono importabili con \"import type\", ma che devono essere davvero importate a run-time (eg. per fare un \"extend\", chiamare un costruttore o usare un metodo statico)\r\n\r\n\r\nconsole.warn('ts loading classes');\r\n\r\n\r\n// annotation @RuntimeAccessible\r\n// import {store} from \"../redux/createStore\";\r\n\r\nabstract class AbstractMixedClass {\r\n    // superclass!: Dictionary<DocString<'parent class name', Class>>;\r\n    static logic: typeof LPointerTargetable;\r\n    static structure: typeof DPointerTargetable;\r\n    static singleton: LPointerTargetable;\r\n    // static [key: string]: any;\r\n    static init_constructor(...constructorArguments: any): void{}\r\n}\r\n\r\nexport abstract class RuntimeAccessibleClass extends AbstractMixedClass {\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    //static extendTree: TreeModel.Node<typeof RuntimeAccessibleClass>// Tree<string, typeof RuntimeAccessibleClass>;\r\n    static extendMatrix: Dictionary<string, Dictionary<string, boolean>>;\r\n    // static name: never; // it breaks with minification, don't use it\r\n    static cname: string;\r\n    private static OCL_Constructors: Dictionary<Pointer<DModel>, Dictionary<DocString<\"DClass name\">, GObject<\"Fake constructors for ocl \\\"Context\\\"\">>> = {};\r\n\r\n    static set_extend(superclass: typeof RuntimeAccessibleClass, subclass: typeof RuntimeAccessibleClass): void{\r\n        if (!superclass.hasOwnProperty(\"subclasses\")) superclass.subclasses = [subclass];\r\n        else if (superclass.subclasses.indexOf(subclass) === -1) superclass.subclasses.push(subclass);\r\n        if (!subclass.hasOwnProperty(\"_extends\")) subclass._extends = [superclass];\r\n        else if (subclass._extends.indexOf(superclass) === -1) subclass._extends.push(superclass);\r\n    }\r\n\r\n    static extendPrototypes(){\r\n        (Array.prototype as any).contains = function (o:any): boolean{\r\n            return this.indexOf(o) !== -1;\r\n        };\r\n        // (Array.prototype as any).joinOriginal = Array.prototype.join;\r\n        // @ts-ignore\r\n        Array.prototype.first = function(){ return this[0]; }\r\n        // @ts-ignore\r\n        eval(\"Array.prototype.last = function(){ return this[this.length-1]; }\");// without eval it still gives typescript error even with tsignore\r\n        // @ts-ignore\r\n        (Array.prototype as any).separator = function(...separators: any[]/*: orArr<(PrimitiveType | null | undefined | JSX.Element)[]>*/): (string|JSX.Element)[]{\r\n            if (Array.isArray(separators[0])) separators = separators[0]; // case .join([1,2,3])  --> .join(1, 2, 3)\r\n            // console.log(\"separators debug\", this, separators, this[0], typeof this[0]);\r\n            // if (typeof this[0] !== \"object\") return (this as any).joinOriginal(separators);\r\n            // if JSX\r\n            // it handles empty cells like it handles '', but this is how native .join() handles them too: [emptyx5, \"a\", emptyx1, \"b\"].join(\",\") ->  ,,,,,a,,b\r\n            let ret/*:JSX.Element[]*/ = [];\r\n            for (let i = 0; i < this.length; i++){\r\n                if (i === 0) {ret.push(this[i]); continue;}\r\n                ret.push(...separators);\r\n                ret.push(this[i]);\r\n            }\r\n            return ret;\r\n        }\r\n    }\r\n    static fixStatics() {\r\n        this.extendPrototypes();\r\n        for (let classs of Object.values(RuntimeAccessibleClass.annotatedClasses)) {\r\n            let gclass = classs as GObject;\r\n            for (let statickey in gclass.s) { gclass[statickey] = gclass.s[statickey]; }\r\n        }\r\n\r\n    }\r\n    // static allRuntimeClasses: string[] = [];\r\n    static classes: Dictionary<string, typeof RuntimeAccessibleClass> = {};\r\n    static annotatedClasses: Dictionary<string, typeof RuntimeAccessibleClass> = {};\r\n\r\n    static getAllNames(annotated = false): string[] {\r\n        return Object.keys(annotated ? RuntimeAccessibleClass.annotatedClasses : RuntimeAccessibleClass.classes); }\r\n    static getAllClasses(annotated = false): typeof RuntimeAccessibleClass[] {\r\n        return Object.values(annotated ? RuntimeAccessibleClass.annotatedClasses : RuntimeAccessibleClass.classes); }\r\n    static getAllClassesDictionary(annotated = false): Dictionary<string, typeof RuntimeAccessibleClass> {\r\n        return annotated ? RuntimeAccessibleClass.annotatedClasses : RuntimeAccessibleClass.classes; }\r\n\r\n    static wrapAll<D extends RuntimeAccessibleClass, L extends LPointerTargetable = LPointerTargetable, CAN_THROW extends boolean = false,\r\n        RET extends CAN_THROW extends true ? L[] : L[] = CAN_THROW extends true ? L[] : L[] >\r\n    (data: D[] | Pointer<DPointerTargetable, 0, 'N'>, baseObjInLookup?: DPointerTargetable, path: string = '', canThrow: CAN_THROW = false as CAN_THROW, state?: DState, filter:boolean=true): CAN_THROW extends true ? L[] : L[] {\r\n        if (!Array.isArray(data)) return [];\r\n        if (!data.length) return [];\r\n        if (!state) state = windoww.store.getState() as DState;\r\n        if (!filter) return data.map( d => DPointerTargetable.wrap(d, baseObjInLookup, path, canThrow, state)) as L[];\r\n        let ret = [];\r\n        for (let o of data) { if (o) ret.push( DPointerTargetable.wrap(o, baseObjInLookup, path, canThrow, state))}\r\n        return ret;\r\n    }\r\n\r\n    static wrap<D extends RuntimeAccessibleClass, L extends LPointerTargetable = LPointerTargetable, CAN_THROW extends boolean = false,\r\n        RET extends CAN_THROW extends true ? L : L | undefined = CAN_THROW extends true ? L : L | undefined>\r\n    (data: D | Pointer | undefined | null, baseObjInLookup?: DPointerTargetable, path: string = '', canThrow: CAN_THROW = false as CAN_THROW, state?: DState): CAN_THROW extends true ? L : L | undefined{\r\n        if (!data || (data as any).__isProxy) return data as any;\r\n        if (typeof data === 'string') {\r\n            data = DPointerTargetable.from(data, state) as D;\r\n            if (!data) {\r\n                windoww.Log.e(canThrow, 'Cannot wrap:', {data, baseObjInLookup, path});\r\n                return undefined as RET;\r\n            }\r\n        }\r\n        if (Array.isArray(data)) {\r\n            console.error('use WrapAll instead for arrays', {data, baseObjInLookup, path, canThrow});\r\n            if (canThrow) throw new Error(\"use WrapAll instead for arrays\");\r\n            else return undefined as any;\r\n        }\r\n        if (!data) return data;\r\n        // @ts-ignore\r\n        if (!data.className) return undefined;\r\n        // console.log('ProxyWrapping:', {data, baseObjInLookup, path});\r\n        return new Proxy(data, new windoww.TargetableProxyHandler(data, baseObjInLookup, path)) as L;\r\n    }\r\n\r\n    // if v can be wrapped, wrap it. otherwise return the parameter v.\r\n    public static attemptWrap(v: any, s?: DState): any{\r\n        let ret: any = undefined;\r\n        switch (typeof v){\r\n            case \"string\": s = store.getState(); ret = LPointerTargetable.fromPointer(v, s); break\r\n            case \"object\":\r\n                if(v.__isProxy) return v;\r\n                if (v.className) {\r\n                    if (!RuntimeAccessibleClass.get(v?.className)?.logic?.singleton) break;\r\n                    ret = LPointerTargetable.fromD(v);\r\n                }\r\n                break;\r\n            default: break;\r\n        }\r\n        return ret || v;\r\n    }\r\n    /*\r\n        static mapWrap2<D extends DPointerTargetable, L extends LPointerTargetable>(map: RuntimeAccessibleClass, container: D, baseObjInLookup?: DPointerTargetable, path: string = ''): L{\r\n            if (!map || (map as any).__isProxy) return map as any;\r\n            if (typeof container === 'string') {\r\n                container = store.getState().idlookup[container] as unknown as D;\r\n                if (!container) { return Log.exx('Cannot wrap map:', {map, container, baseObjInLookup, path}); }\r\n            }\r\n            // console.log('ProxyWrapping:', {data, baseObjInLookup, path});\r\n            return new Proxy(map, new MapProxyHandler(map, baseObjInLookup, path));\r\n        }\r\n\r\n    */\r\n\r\n    static mapWrap(data: Dictionary, baseObjInLookup: DPointerTargetable, path: string, subMapKeys: string[] = []): Proxyfied<Dictionary> {\r\n        if (!data || (data as any).__isProxy) return data as any;\r\n        // console.error('GETMAP', {data, logicContext, path});\r\n        return new Proxy(data, new windoww.MapProxyHandler(data, baseObjInLookup, path));\r\n    }\r\n\r\n    className!: string;\r\n    protected constructor(...a:any) {\r\n        super();\r\n        // RuntimeAccessibleClass.init_constructor(this, ...a);\r\n        // this.className = this.constructor.name;\r\n        // nb: per i mixin questo settaggio viene sovrascritto. perchè il mixin crea le 2 classi ereditate separatamente con i loro costruttori e le incrocia. quindi devo settarlo dall'annotazione @ tramite prototype\r\n        // RuntimeAccessibleClass.allRuntimeClasses.push(this.className);\r\n    }\r\n\r\n    static init_constructor(thiss: any, ...args: any): void {\r\n\r\n        // this.className = this.constructor.name;\r\n        // let finalObject = this;\r\n        // if (finalObject.constructor.name === \"DVoidVertex\" || finalObject.constructor.name === \"DGraphElement\") { let breakp = true; }\r\n        // this.init0(...arguments);\r\n        // thiss.className = this.name;\r\n    }\r\n\r\n    public static get<T extends typeof RuntimeAccessibleClass = typeof RuntimeAccessibleClass>(dclassname: string, mode?: string )\r\n        : T & {logic?: typeof LPointerTargetable} {\r\n\r\n        // believe it or not there are actually 3 different versions generated, with different static method contexts, it's a mess.\r\n        return this.classes[dclassname] as any;\r\n        /*\r\n        switch(mode) {\r\n            case \"annotated version\":\r\n                /* it is like this in console\r\n                () {\r\n                    var _obj$initBase;\r\n                    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\r\n                ...* /\r\n                return RuntimeAccessibleClass.annotatedClasses[dclassname] as any;\r\n            case \"local definition version\":\r\n            default: // same as window.classname\r\n            case \"module export version\":\r\n                /* it was like this in console, it is not anymore after reworking cname\r\n                // don't know how to get it now, but default version should be always the correct one,\r\n                    class DClassifier extends _joiner__WEBPACK_IMPORTED_MODULE_0__[\"DPointerTargetable\"]\r\n                which is even wrong as i asked for DPointerTargetable and not DClassifier. * /\r\n            return null as any;\r\n        }*/\r\n    }\r\n\r\n    public static extends(className?: string | typeof RuntimeAccessibleClass, superClassName?: string| typeof RuntimeAccessibleClass, returnIfEqual: boolean = true): boolean {\r\n        if (!className || !superClassName) return false;\r\n        const superclass = typeof superClassName === \"string\" ? RuntimeAccessibleClass.get(superClassName) : superClassName;\r\n        const thisclass = typeof className === \"string\" ? RuntimeAccessibleClass.get(className) : className;\r\n        if (!superclass || !thisclass) return false;\r\n        //console.trace(\"extends.1:\", {thisclass, superclass});\r\n        // console.log(\"extends.2:\", {iof:(thisclass instanceof superclass),\r\n        //     tree: !!(RuntimeAccessibleClass.extendTree.first((node) => node.model === superclass)?.first((node) => node.model === thisclass))});\r\n        if (superclass === thisclass) return returnIfEqual;\r\n        // for (let aaa in RuntimeAccessibleClass.extendTree.find(superClassName)) { }\r\n\r\n        return (thisclass instanceof superclass)\r\n            || RuntimeAccessibleClass.extendMatrix[superclass.cname]?.[thisclass.cname]\r\n        // !!(RuntimeAccessibleClass.extendTree.first((node) => node.model === superclass)?.first((node) => node.model === thisclass))\r\n        // || true;\r\n    }\r\n\r\n    getAllPrototypeSuperClasses(): GObject[] {\r\n        let currentlevel = this;\r\n        let ret: GObject[] = [];\r\n        while (true) {\r\n            if (!currentlevel) break;\r\n            ret.push(currentlevel);\r\n            // @ts-ignore\r\n            currentlevel = currentlevel.__proto__;\r\n        }\r\n        console.log('constructor chain:', ret);\r\n        return ret;\r\n    }\r\n    /*initBase(){\r\n        let superclasses = this.getAllPrototypeSuperClasses();\r\n        for (let sc of superclasses) {\r\n            if (!sc.hasOwnProperty('init0')) continue;\r\n            console.log('initbase calling ', {thiss: this, sc, init0: sc.init0, args:sc.constructorArguments});\r\n            sc.init0.apply(this, ...(sc.constructorArguments || []));\r\n        }\r\n    }*/\r\n    // protected abstract init(...constructorParameters: any): void;\r\n    // NB: per colpa della limitazione #3 di ts-mixer,\r\n    // DEVO chiamare init su ogni oggetto per settargli il corretto this.className, altrimenti prende quello dell'ultima superclasse\r\n    /*protected init0(...constructorParameters: any): void {\r\n        let a = this;\r\n        let finalObject = this;\r\n        console.log('creation of___ ', {thiss: this, finalObject});\r\n        if (finalObject.constructor.name === \"DVoidVertex\" || finalObject.constructor.name === \"DGraphElement\") {\r\n            let breakp = true; }\r\n\r\n        (window as any)[finalObject.constructor.name] =\r\n            RuntimeAccessibleClass.classes[finalObject.constructor.name] = finalObject.constructor as any;\r\n        // @ts-ignore\r\n        // delete this.className;\r\n        this.className = (finalObject as any).__proto__.className;\r\n    }*/\r\n\r\n    static makeOCLConstructor(data: DClass, state: DState, oldState: DState): GObject<\"fake constructor of m2-class for ocl's Context\"> {\r\n        let rootModel: DModel = data as any;\r\n        while (rootModel && rootModel.className !== \"DModel\") rootModel = DPointerTargetable.fromPointer(rootModel.father, state);\r\n        let mid: Pointer<DModel> = rootModel?.id; // NB: for EBoolean etc, primitive type meteclasses don't have a model;\r\n        if (!RuntimeAccessibleClass.OCL_Constructors[mid]) {\r\n            RuntimeAccessibleClass.OCL_Constructors[mid] = {...RuntimeAccessibleClass.classes};\r\n        }\r\n        const OclConstructor: GObject = data;\r\n        let namefixed: string;\r\n\r\n        if (oldState && oldState.idlookup[data.id]) {\r\n            let oldname = (oldState.idlookup[data.id] as DClass).name;\r\n            namefixed = U.replaceAll(U.replaceAll(oldname, '-', '_'), ' ', '_');\r\n            delete RuntimeAccessibleClass.OCL_Constructors[mid][oldname];\r\n            delete RuntimeAccessibleClass.OCL_Constructors[mid][namefixed];\r\n\r\n        }\r\n        namefixed = U.replaceAll(U.replaceAll(data.name, '-', '_'), ' ', '_');\r\n        RuntimeAccessibleClass.OCL_Constructors[mid][data.name] = OclConstructor;\r\n        RuntimeAccessibleClass.OCL_Constructors[mid][namefixed] = OclConstructor;\r\n\r\n        return data;\r\n    }\r\n\r\n    static getOCLClasses(model_id: Pointer<DModel>): GObject {\r\n        // return { ...(RuntimeAccessibleClass.OCL_Constructors[model_id] || {}), ...RuntimeAccessibleClass.classes}\r\n        return RuntimeAccessibleClass.OCL_Constructors[model_id] || RuntimeAccessibleClass.classes;\r\n    }\r\n}\r\nexport function Obsolete<T extends any>( constructor: T & GObject): T { return constructor; }\r\nexport function Leaf<T extends any>( constructor: T & GObject): T { return constructor; }\r\nexport function Node<T extends any>( constructor: T & GObject): T { return constructor; }\r\nexport function Abstract<T extends any>( constructor: T & GObject): T { return constructor; }\r\nexport function Instantiable<T extends any>(constructor: T & GObject, instanceConstructor?: Constructor): T { return constructor; } // for m2 cklasses that have m1 instances\r\n// export function RuntimeAccessible<T extends any>(cname: string): ((constructor: T & GObject) => T) {\r\nexport function RuntimeAccessible(cname: string) {\r\n    return (ctor: any) => RuntimeAccessible_inner(ctor, cname);\r\n}\r\n\r\nfunction RuntimeAccessible_inner<T extends any>(constructor: T & GObject, cname: string): T {\r\n    // console.log('DecoratorTest', {constructor, arguments});\r\n    (constructor as GObject).cname = cname;\r\n    if (!constructor.hasOwnProperty(\"subclasses\")) (constructor as GObject).subclasses = [];\r\n    // @ts-ignore\r\n    RuntimeAccessibleClass.classes[constructor.cname] = constructor as any as typeof RuntimeAccessibleClass;\r\n    // console.log(\"setting runtime accessible\", {key: constructor.cname, constructor, pre: predebug, post: {...RuntimeAccessibleClass.classes}});\r\n    if (!windoww[constructor.cname]) (windoww[constructor.cname] as any) = constructor;\r\n    constructor.prototype.className = constructor.cname;\r\n    //constructor.prototype.$$typeof = constructor.cname;\r\n    //constructor.prototype.typeName = constructor.cname;\r\n    (constructor as any).staticClassName = constructor.cname;\r\n    // @ts-ignore\r\n    // console.log('runtimeaccessible annotation:', {thiss:this, constructor});\r\n    //    const classnameFixedConstructor = constructor; //  function (...args) { let obj = new constructor(...args); obj.init?.(); obj.init0?.(); return obj; }\r\n\r\n    // @ts-ignore\r\n    let outerthis = this;\r\n    // @ts-ignore\r\n    const classnameFixedConstructorDoNotRenameWithoutSearchStrings = function (...args) {\r\n        // @ts-ignore\r\n        // console.log('runtimeaccessible annotation inner:', {thiss:this, outerthis, constructor});\r\n        // @ts-ignore\r\n        let obj = new constructor(...args);\r\n        obj.classNameFromAnnotation = constructor.cname;\r\n        obj.className = constructor.cname;\r\n        //obj.prototype.$$typeof = constructor.name;\r\n        // obj.prototype.typeName = constructor.name;\r\n        // obj.init?.();\r\n        // obj.init0?.();\r\n        obj.initBase?.();\r\n        // @ts-ignore\r\n        // console.log('runtimeaccessible annotation inner end:', {thiss:this, outerthis, constructor, obj});\r\n        return obj; }\r\n    RuntimeAccessibleClass.annotatedClasses[constructor.cname] = classnameFixedConstructorDoNotRenameWithoutSearchStrings as any as typeof RuntimeAccessibleClass;\r\n\r\n    for (let key in constructor) (classnameFixedConstructorDoNotRenameWithoutSearchStrings as GObject)[key] = constructor[key];\r\n    // constructor.constructor = classnameFixedConstructorDoNotRenameWithoutSearchStrings; return constructor;\r\n\r\n    // @ts-ignore\r\n    // for (let staticKey of constructor as GObject) { classnameFixedConstructorDoNotRenameWithoutSearchStrings[staticKey] = constructor[staticKey]; }\r\n    classnameFixedConstructorDoNotRenameWithoutSearchStrings.prototype = constructor.prototype;\r\n    classnameFixedConstructorDoNotRenameWithoutSearchStrings.prototype.constructor = constructor.prototype.constructor;\r\n\r\n    // required for inheriting static methods\r\n    classnameFixedConstructorDoNotRenameWithoutSearchStrings.__proto__ = constructor.__proto__;\r\n    classnameFixedConstructorDoNotRenameWithoutSearchStrings.s = constructor;\r\n    // return classnameFixedConstructorDoNotRenameWithoutSearchStrings as any;\r\n    return constructor;\r\n}\r\n\r\n\r\n(window as any).RuntimeAccessibleClass = RuntimeAccessibleClass;\r\n// todo: problema: per creare un PointerTargetable ho bisogno dell'userid, e devo generarlo prima che venga generato l'initialState... dovrebbe venir servito con la pagina dal server. o passato come navigation props dalla pagina di login\r\n\r\n\r\n\r\nexport type DtoL<DX extends GObject, LX =\r\n    DX extends DEnumerator ? LEnumerator : (DX extends DAttribute ? LAttribute : (DX extends DReference ? LReference : (DX extends DRefEdge ? LRefEdge : (DX extends DExtEdge ? LExtEdge : (DX extends DDataType ? LDataType : (DX extends DClass ? LClass : (DX extends DStructuralFeature ? LStructuralFeature : (DX extends DParameter ? LParameter : (DX extends DOperation ? LOperation : (DX extends DEdge ? LEdge : (DX extends DEdgePoint ? LEdgePoint : (DX extends DGraphVertex ? LGraphVertex : (DX extends DModel ? LModel : (DX extends DValue ? LValue : (DX extends DObject ? LObject : (DX extends DEnumLiteral ? LEnumLiteral : (DX extends DPackage ? LPackage : (DX extends DClassifier ? LClassifier : (DX extends DTypedElement ? LTypedElement : (DX extends DVertex ? LVertex : (DX extends DVoidEdge ? LVoidEdge : (DX extends DVoidVertex ? LVoidVertex : (DX extends DGraph ? LGraph : (DX extends DNamedElement ? LNamedElement : (DX extends DAnnotation ? LAnnotation : (DX extends DGraphElement ? LGraphElement : (DX extends DMap ? LMap : (DX extends DModelElement ? LModelElement : (DX extends DUser ? LUser : (DX extends DPointerTargetable ? LPointerTargetable :\r\n        (DX extends DUser ? LUser : (DX extends DLog ? LLog : (ERROR)))\r\n        ))))))))))))))))))))))))))))))> = LX;\r\nexport type DtoW<DX extends GObject, WX = DX extends DEnumerator ? WEnumerator : (DX extends DAttribute ? WAttribute : (DX extends DReference ? WReference : (DX extends DRefEdge ? WRefEdge : (DX extends DExtEdge ? WExtEdge : (DX extends DDataType ? WDataType : (DX extends DClass ? WClass : (DX extends DStructuralFeature ? WStructuralFeature : (DX extends DParameter ? WParameter : (DX extends DOperation ? WOperation : (DX extends DEdge ? WEdge : (DX extends DEdgePoint ? WEdgePoint : (DX extends DGraphVertex ? WGraphVertex : (DX extends DModel ? WModel : (DX extends DValue ? WValue : (DX extends DObject ? WObject : (DX extends DEnumLiteral ? WEnumLiteral : (DX extends DPackage ? WPackage : (DX extends DClassifier ? WClassifier : (DX extends DTypedElement ? WTypedElement : (DX extends DVertex ? WVertex : (DX extends DVoidEdge ? WVoidEdge : (DX extends DVoidVertex ? WVoidVertex : (DX extends DGraph ? WGraph : (DX extends DNamedElement ? WNamedElement : (DX extends DAnnotation ? WAnnotation : (DX extends DGraphElement ? WGraphElement : (DX extends DMap ? WMap : (DX extends DModelElement ? WModelElement : (DX extends DUser ? WUser : (DX extends DPointerTargetable ? WPointerTargetable : (ERROR)))))))))))))))))))))))))))))))> = WX;\r\n// export type DtoW<DX extends GObject, WX = Omit<DtoW0<DX>, 'id'>> = WX;\r\nexport type LtoD<LX extends LPointerTargetable, DX = LX extends LEnumerator ? DEnumerator : (LX extends LAttribute ? DAttribute : (LX extends LReference ? DReference : (LX extends LRefEdge ? DRefEdge : (LX extends LExtEdge ? DExtEdge : (LX extends LDataType ? DDataType : (LX extends LClass ? DClass : (LX extends LStructuralFeature ? DStructuralFeature : (LX extends LParameter ? DParameter : (LX extends LOperation ? DOperation : (LX extends LEdge ? DEdge : (LX extends LEdgePoint ? DEdgePoint : (LX extends LGraphVertex ? DGraphVertex : (LX extends LModel ? DModel : (LX extends LValue ? DValue : (LX extends LObject ? DObject : (LX extends LEnumLiteral ? DEnumLiteral : (LX extends LPackage ? DPackage : (LX extends LClassifier ? DClassifier : (LX extends LTypedElement ? DTypedElement : (LX extends LVertex ? DVertex : (LX extends LVoidEdge ? DVoidEdge : (LX extends LVoidVertex ? DVoidVertex : (LX extends LGraph ? DGraph : (LX extends LNamedElement ? DNamedElement : (LX extends LAnnotation ? DAnnotation : (LX extends LGraphElement ? DGraphElement : (LX extends LMap ? DMap : (LX extends LModelElement ? DModelElement : (LX extends LUser ? DUser : (LX extends LPointerTargetable ? DPointerTargetable : (ERROR)))))))))))))))))))))))))))))))> = DX;\r\nexport type LtoW<LX extends LPointerTargetable, WX = LX extends LEnumerator ? WEnumerator : (LX extends LAttribute ? WAttribute : (LX extends LReference ? WReference : (LX extends LRefEdge ? WRefEdge : (LX extends LExtEdge ? WExtEdge : (LX extends LDataType ? WDataType : (LX extends LClass ? WClass : (LX extends LStructuralFeature ? WStructuralFeature : (LX extends LParameter ? WParameter : (LX extends LOperation ? WOperation : (LX extends LEdge ? WEdge : (LX extends LEdgePoint ? WEdgePoint : (LX extends LGraphVertex ? WGraphVertex : (LX extends LModel ? WModel : (LX extends LValue ? WValue : (LX extends LObject ? WObject : (LX extends LEnumLiteral ? WEnumLiteral : (LX extends LPackage ? WPackage : (LX extends LClassifier ? WClassifier : (LX extends LTypedElement ? WTypedElement : (LX extends LVertex ? WVertex : (LX extends LVoidEdge ? WVoidEdge : (LX extends LVoidVertex ? WVoidVertex : (LX extends LGraph ? WGraph : (LX extends LNamedElement ? WNamedElement : (LX extends LAnnotation ? WAnnotation : (LX extends LGraphElement ? WGraphElement : (LX extends LMap ? WMap : (LX extends LModelElement ? WModelElement : (LX extends LUser ? WUser : (LX extends LPointerTargetable ? WPointerTargetable : (ERROR)))))))))))))))))))))))))))))))> = WX;\r\nexport type WtoD<IN extends WPointerTargetable, OUT = IN extends WEnumerator ? DEnumerator : (IN extends WAttribute ? DAttribute : (IN extends WReference ? DReference : (IN extends WRefEdge ? DRefEdge : (IN extends WExtEdge ? DExtEdge : (IN extends WDataType ? DDataType : (IN extends WClass ? DClass : (IN extends WStructuralFeature ? DStructuralFeature : (IN extends WParameter ? DParameter : (IN extends WOperation ? DOperation : (IN extends WEdge ? DEdge : (IN extends WEdgePoint ? DEdgePoint : (IN extends WGraphVertex ? DGraphVertex : (IN extends WModel ? DModel : (IN extends WValue ? DValue : (IN extends WObject ? DObject : (IN extends WEnumLiteral ? DEnumLiteral : (IN extends WPackage ? DPackage : (IN extends WClassifier ? DClassifier : (IN extends WTypedElement ? DTypedElement : (IN extends WVertex ? DVertex : (IN extends WVoidEdge ? DVoidEdge : (IN extends WVoidVertex ? DVoidVertex : (IN extends WGraph ? DGraph : (IN extends WNamedElement ? DNamedElement : (IN extends WAnnotation ? DAnnotation : (IN extends WGraphElement ? DGraphElement : (IN extends WMap ? DMap : (IN extends WModelElement ? DModelElement : (IN extends WUser ? DUser : (IN extends WPointerTargetable ? DPointerTargetable : (IN extends WViewElement ? DViewElement : (IN extends WViewTransientProperties ? DViewTransientProperties : (ERROR)))))))))))))))))))))))))))))))))> = OUT;\r\nexport type WtoL<IN extends WPointerTargetable, OUT = IN extends WEnumerator ? LEnumerator : (IN extends WAttribute ? LAttribute : (IN extends WReference ? LReference : (IN extends WRefEdge ? LRefEdge : (IN extends WExtEdge ? LExtEdge : (IN extends WDataType ? LDataType : (IN extends WClass ? LClass : (IN extends WStructuralFeature ? LStructuralFeature : (IN extends WParameter ? LParameter : (IN extends WOperation ? LOperation : (IN extends WEdge ? LEdge : (IN extends WEdgePoint ? LEdgePoint : (IN extends WGraphVertex ? LGraphVertex : (IN extends WModel ? LModel : (IN extends WValue ? LValue : (IN extends WObject ? LObject : (IN extends WEnumLiteral ? LEnumLiteral : (IN extends WPackage ? LPackage : (IN extends WClassifier ? LClassifier : (IN extends WTypedElement ? LTypedElement : (IN extends WVertex ? LVertex : (IN extends WVoidEdge ? LVoidEdge : (IN extends WVoidVertex ? LVoidVertex : (IN extends WGraph ? LGraph : (IN extends WNamedElement ? LNamedElement : (IN extends WAnnotation ? LAnnotation : (IN extends WGraphElement ? LGraphElement : (IN extends WMap ? LMap : (IN extends WModelElement ? LModelElement : (IN extends WUser ? LUser : (IN extends WPointerTargetable ? LPointerTargetable : (IN extends WViewElement ? LViewElement : (IN extends WViewTransientProperties ? LViewTransientProperties : (ERROR)))))))))))))))))))))))))))))))))> = OUT;\r\nexport enum CoordinateMode {\r\n    \"absolute\"              = \"absolute\",\r\n    \"relativePercent\"       = \"relative%\",\r\n    \"relativeOffset\"        = \"relativeOffset\",\r\n    \"relativeOffsetStart\"   = \"relativeOffsetStart\",\r\n    \"relativeOffsetEnd\"     = \"relativeOffsetEnd\",\r\n}\r\n\r\nexport type EPSize = GraphSize & {currentCoordType: CoordinateMode};\r\nexport enum EdgeHead {\r\n    composition = \"Composition\",\r\n    aggregation = \"Aggregation\",\r\n    reference   = \"Association\",\r\n    extend      = \"Extension\"\r\n}\r\n\r\n\r\n@RuntimeAccessible('UserHistory')\r\nexport class UserHistory{\r\n    static cnamne: string = 'UserHistory';\r\n    constructor(public undoable:GObject<\"delta\">[] = [], public redoable: GObject<\"delta\">[] = []){\r\n\r\n    }\r\n}\r\n\r\nlet canFireActions: boolean = true;\r\n@RuntimeAccessible('Constructors')\r\nexport class Constructors<T extends DPointerTargetable = DPointerTargetable>{\r\n    public static paused: boolean = false;\r\n    private thiss: T;\r\n    private persist: boolean;\r\n    // private callbacks: Function[];\r\n    private nonPersistentCallbacks: Function[];\r\n    fatherType?: typeof RuntimeAccessibleClass;\r\n    private fatherPtr?: Pointer // T['father'];\r\n    private state?: DState; // set only if requested by setWithSideEffect\r\n    /*\r\n    problem: if isPersistent is set to false, but the object is later made persistent with an action, you lose all the callback effects afecting other elements (as setting opposite relations like instances-typeof or losing pointedBy's)\r\n    solution 1: store in the D-object a function executing the callbacks called by CreateNewElement action, then delete that field before persisting.\r\n    continued: instead of setting the pointedBy's this way (and increasing clonedcounter for nothing) erase all PointedBy mentionings here, and make all pointer values assigned separately with a SetAction,' +\r\n    '         if new2 is used that set manually a d-field, set it to undefined in the in the .end() part, then trigger the setaction with correct value.\r\n    continued: sort actions by path, but always make sure CreateElement are first in the sort regardless of path. make also sure 2 actions with the same path keep the order they are launched/created (oldest first)\r\n    */\r\n    constructor(t:T, father?: Pointer, persist: boolean = true, fatherType?: Constructor, id?: string, isUser:boolean = false) {\r\n        persist = persist && canFireActions;\r\n        this.thiss = t;\r\n        this.setID(id, isUser);\r\n        // the same thing is done in reducer/createelementaction, but if the object is destructured before then, it will lose the constructor and reducer will fail to assign classname\r\n        t.className = t.className || (t.constructor as typeof RuntimeAccessibleClass).cname || t.constructor.name;\r\n        DPointerTargetable.pendingCreation[t.id] = t;\r\n        this.persist = persist;\r\n        t._persistCallbacks = [];\r\n        t._derivedSubElements = [];\r\n        this.nonPersistentCallbacks = [];\r\n        this.fatherPtr = father;\r\n\r\n        if (this.thiss.hasOwnProperty(\"father\")) {\r\n            this.fatherType = fatherType as any;\r\n            // console.log('x6 addchild() set ptr father', {father, thiss:this.thiss});\r\n            this.setPtr(\"father\", father);\r\n        }\r\n    }\r\n\r\n    static makeID(isUser:boolean=false): Pointer { return \"Pointer\" + new Date().getTime() + \"_\" + (isUser ? DUser.current : 'USER') + \"_\" + (DPointerTargetable.maxID++) }\r\n    private setID(id?: string, isUser:boolean = false){\r\n        this.thiss.id = id || Constructors.makeID(isUser);\r\n    }\r\n\r\n    // cannot use Lobjects as they will set PointedBy in persistent state, also might access an incomplete version of the object crashing\r\n    private setPtr(property: string, value: any, checkPointerValidity?: DState) {\r\n        (this.thiss as GObject)[property] = value;\r\n        if (!value) return;\r\n        if (Array.isArray(value)) for (let v of value) {\r\n            if (!value) continue;\r\n            if (typeof v === \"object\") v = v.id;\r\n            if (!v || checkPointerValidity && !Pointers.isPointer(v, checkPointerValidity)) continue;\r\n            this.thiss._persistCallbacks.push(SetFieldAction.create(v, \"pointedBy\", PointedBy.fromID(this.thiss.id, property as any), '+='));\r\n        }\r\n        else {\r\n            if (typeof value === \"object\") value = value.id;\r\n            value && this.thiss._persistCallbacks.push(SetFieldAction.create(value, \"pointedBy\", PointedBy.fromID(this.thiss.id, property as any), '+='));\r\n        }\r\n        // todo: in delete if the element was not persistent, just do nothing.\r\n    }\r\n\r\n    private setExternalRootProperty<D extends DPointerTargetable>(path: string, val: any, accessModifier: \"[]\" | \"+=\" | \"\", isPointer: boolean): this {\r\n        this.thiss._persistCallbacks.push(SetRootFieldAction.create(path, val, accessModifier, isPointer));\r\n        return this;\r\n    }\r\n\r\n    private setExternalPtr<D extends DPointerTargetable>(target: D | Pointer<any>, property: string, accessModifier: \"[]\" | \"+=\" | \"\" = \"\", val?: any): this {\r\n        if (!target) return this;\r\n        if (typeof target === \"object\") target = target.id;\r\n        if (!val) val = this.thiss.id;\r\n        this.thiss._persistCallbacks.push(SetFieldAction.create(target, property, val, accessModifier, true));\r\n        return this;\r\n        // PointedBy is set by reducer directly in this case.\r\n        // this.thiss._persistCallbacks.push(SetFieldAction.create(this.thiss.id, \"pointedBy\", PointedBy.fromID(target, property as any), '+='));\r\n    }\r\n\r\n    private setWithSideEffect<D extends DPointerTargetable>(property: string, val: any): this {\r\n        if (!val) return this;\r\n        if (!this.state) this.state = store.getState();\r\n        if (typeof val === \"object\") val = val.id;\r\n        this.thiss._persistCallbacks.push( () => {\r\n            (LPointerTargetable.from(this.thiss, this.state) as GObject<\"L\">)[property] = val;\r\n        });\r\n        return this;\r\n    }\r\n\r\n    //static pause(): void { canFireActions = false; }\r\n    //static resume(): void { canFireActions = true; }\r\n    static persist(d: DPointerTargetable, fromCreateAction?: boolean): void;\r\n    static persist(d: DPointerTargetable[]): void;\r\n    static persist(d: orArr<DPointerTargetable>, fromCreateAction?: boolean): void {\r\n        if (Constructors.paused) return;\r\n        TRANSACTION('Create element', ()=> {\r\n            if (!Array.isArray(d)) d = [d];\r\n            // first create \"this\"\r\n            for (let e of d) {\r\n                let subElements = e._derivedSubElements;\r\n                let callbacks = e._persistCallbacks;\r\n                delete (e as Partial<DPointerTargetable>)._derivedSubElements;\r\n                delete (e as Partial<DPointerTargetable>)._persistCallbacks;\r\n                // then create subelements (object -> values) and fire their actions.\r\n                if (!fromCreateAction) CreateElementAction.new(e, false);\r\n                for (let c of subElements) Constructors.persist([c]);\r\n                // finally fire the actions for \"this\"\r\n\r\n                // console.log('x6 addchild pre firing act()', {callbacks, d:e});\r\n                for (let c of callbacks) (c as Action).fire ? (c as Action).fire() : (c as () => void)();\r\n                SetRootFieldAction.new('ELEMENT_CREATED', e.id, '+=', false); // here no need to IsPointer because it only affects Transient stuff\r\n            }\r\n        })\r\n    }\r\n    // start(thiss: any): this { this.thiss = thiss; return this; }\r\n    end(simpledatacallback?: (d:T, c: this) => void): T {\r\n        if (simpledatacallback) simpledatacallback(this.thiss, this); // callback for setting primitive types, not pointers not context-dependant values (name being potentially invalid / chosen according to parent)\r\n        if (this.nonPersistentCallbacks.length) {\r\n            for (let cb of this.nonPersistentCallbacks) cb();\r\n        }\r\n        if (!this.persist) return this.thiss;\r\n        Constructors.persist(this.thiss);\r\n        /// todo: warning: there is a transaction at .persist method, do not use BEGIN+END/TRANSACTION inside\r\n\r\n        return this.thiss; }\r\n\r\n\r\n    DState(): this {\r\n        let thiss: DState = this.thiss as any;\r\n        thiss.debug = !!localStorage.getItem('debug');\r\n        return this;\r\n    }\r\n\r\n    DModelElement(): this {\r\n        let thiss: GObject<DModelElement> = this.thiss as any;\r\n        if ('instances' in thiss) thiss.instances = [];\r\n        return this; }\r\n    DClassifier(): this { return this; }\r\n    DParameter(defaultValue?: any): this {\r\n        let thiss: DParameter = this.thiss as any;\r\n        thiss.defaultValue = defaultValue;\r\n        this.setExternalPtr(thiss.father, \"parameters\", \"+=\");\r\n        return this; }\r\n    DStructuralFeature(): this {\r\n        if (this.thiss.className === 'DOperation') return this;\r\n        // if (!this.persist) return this;\r\n        let thiss: DAttribute|DReference = this.thiss as any;\r\n        thiss.allowCrossReference = false;\r\n        const _DClass: typeof DClass = windoww.DClass;\r\n        const _DValue: typeof DValue = windoww.DValue;\r\n\r\n\r\n        let targets: DClass[] = [(_DClass as typeof DPointerTargetable).from(thiss.father, this.state)];\r\n        let alreadyParsed: Dictionary<Pointer, DClass> = {};\r\n        /*\r\n        todo: build a Tree<DClass> of all superclasses tree nested by level.\r\n            only then instantiate DValues by depth level, if same level from right to left (last extend on right takes priority) and erase this stuff below.*/\r\n        // let superClassesByLevel: Dictionary<Pointer, DClass> = ;\r\n        while(targets.length) { // gather superclasses in map \"alreadyParsed\"\r\n            let nextTargets = [];\r\n            for (let target of targets) {\r\n                if (!target) { Log.ww(\"Invalid father pointer in DStructuralFeature\", {feature: thiss, father:target, superclasses: alreadyParsed}); continue; }\r\n                if (alreadyParsed[target.id]) continue;\r\n                alreadyParsed[target.id] = target;\r\n                for(let ext of target.extendedBy) nextTargets.push((_DClass as typeof DPointerTargetable).from(ext));\r\n            }\r\n            targets = nextTargets;\r\n        }\r\n        //(thiss as DPointerTargetable)._persistCallbacks.push(()=>{\r\n        // When a feature is added in m2, i loop instanced m1 objects to add that feature as a DValue.\r\n        for (let pointer in alreadyParsed) {\r\n            for (let instanceObjPtr of alreadyParsed[pointer].instances) {\r\n                // this._derivedSubElements.push(_DValue.new(thiss.name, thiss.id, undefined, instanceObjPtr));\r\n                thiss._derivedSubElements.push(_DValue.new3({name: undefined, instanceof: thiss.id, father: instanceObjPtr}, undefined, false));\r\n            }\r\n            //}\r\n        }\r\n\r\n\r\n        return this;\r\n    }\r\n    DReference(): this {\r\n        let thiss: DReference = this.thiss as any;\r\n        thiss.aggregation = false;\r\n        thiss.composition = false;\r\n        thiss.rootable = undefined;\r\n        this.setExternalPtr(thiss.father, \"references\", \"+=\");\r\n        return this; }\r\n\r\n    DAttribute(): this {\r\n        let thiss: DAttribute = this.thiss as any;\r\n        this.setExternalPtr(thiss.father, \"attributes\", \"+=\");\r\n        this.setPtr(\"type\", \"Pointer_EBOOLEAN\");\r\n        return this; }\r\n\r\n    DDataType(): this { return this; }\r\n\r\n    DObject(instanceoff?: DObject[\"instanceof\"]): this {\r\n        let thiss: DObject = this.thiss as any;\r\n        if (thiss.father) {\r\n            if (this.fatherType!.cname === \"DModel\") {\r\n                this.setExternalPtr(thiss.father, \"objects\", \"+=\");\r\n            }\r\n            else {\r\n                // object containing object is not in any direct child collection. access through values\r\n                this.setExternalPtr(thiss.father, \"values\", \"+=\");\r\n            }\r\n        }\r\n        instanceoff && this.setWithSideEffect( \"instanceof\", instanceoff);\r\n        return this; }\r\n\r\n    DValue(instanceoff?: DValue[\"instanceof\"], val?: DValue[\"values\"], isMirage?: DValue[\"isMirage\"]): this {\r\n        let thiss: DValue = this.thiss as any; thiss.edges = [];\r\n        // thiss.values = val || [];\r\n        thiss.instanceof = instanceoff;\r\n        thiss.isMirage = isMirage || false;\r\n        if (val === undefined) val = [];\r\n        else if(!Array.isArray(val)) val = [val];\r\n        thiss.values = [];// because reducer calculating newly added pointedby must find something to start comparison\r\n        thiss.allowCrossReference = false;\r\n        this.setPtr(\"values\", val, this.state);\r\n\r\n        // update father's collections (pointedby's here are set automatically)\r\n        if (instanceoff) {\r\n            this.setPtr(\"instanceof\", instanceoff);\r\n            this.setExternalPtr(instanceoff, \"instances\", \"+=\");\r\n        }\r\n        this.setExternalPtr(thiss.father, \"features\", \"+=\");\r\n        return this; }\r\n\r\n    DAnnotation(source?: DAnnotation[\"source\"], details?: DAnnotation[\"details\"]): this {\r\n        const thiss: DAnnotation = this.thiss as any;\r\n        thiss.source = source || '';\r\n        thiss.details = details || [];\r\n        this.setExternalPtr(thiss.father, \"annotations\", \"+=\");\r\n\r\n        if (details) for (let det of details)\r\n            thiss._persistCallbacks.push(SetFieldAction.create(det, \"pointedBy\", PointedBy.fromID(thiss.id, \"details\"), '+='));\r\n\r\n        return this; }\r\n\r\n    DPointerTargetable(): this {\r\n        const thiss: DPointerTargetable = this.thiss as any;\r\n        thiss.className = (thiss.constructor as typeof RuntimeAccessibleClass).cname;\r\n        // this.className = thiss.className;\r\n        return this; }\r\n\r\n    DUser(name: string, surname: string, nickname: string, affiliation: string, country: string, newsletter: boolean, email: string, token: string): this {\r\n        const _this: DUser = this.thiss as unknown as DUser;\r\n        _this.name = name;\r\n        _this.surname = surname;\r\n        _this.nickname = nickname;\r\n        _this.affiliation = affiliation;\r\n        _this.country = country;\r\n        _this.newsletter = newsletter;\r\n        _this.email = email;\r\n        _this.token = token;\r\n        // statehistory[_this.id] = new UserHistory();\r\n        // todo: make it able to combine last 2 changes with a keystroke.\r\n        //  reapeat N times to combine N actions.\r\n        //  let it \"redo\" multiple times, it's like recording a macro.\r\n\r\n        if (this.persist) {\r\n            // no pointedBy\r\n        }\r\n        return this;\r\n    }\r\n\r\n    DNamedElement(name?: DNamedElement[\"name\"]): this {\r\n        const thiss: DNamedElement = this.thiss as any;\r\n        thiss.name = (name !== undefined) ? name || '' : thiss.constructor.name.substring(1) + \" 1\";\r\n        return this; }\r\n\r\n    DTypedElement(type?: DTypedElement[\"type\"]): this {\r\n        const thiss: DTypedElement = this.thiss as any;\r\n        let dtype = Selectors.getByName2(type) as DClassifier | null;\r\n        switch (dtype?.className){\r\n            default: type = undefined; break;\r\n            case 'DClass':\r\n                switch (thiss.className) {\r\n                    case 'DReference':\r\n                    case 'DOperation':\r\n                    case 'DParameter':\r\n                        type = dtype.id;\r\n                        break;\r\n                    case 'DAttribute':\r\n                    default: type = dtype.id; break;\r\n                }\r\n                break;\r\n            case 'DEnumerator':\r\n                switch (thiss.className) {\r\n                    case 'DAttribute':\r\n                    case 'DOperation':\r\n                    case 'DParameter':\r\n                        type = dtype.id;\r\n                        break;\r\n                    case 'DReference':\r\n                    default: type = undefined; break;\r\n                }\r\n                break;\r\n        }\r\n        this.setPtr(\"type\", type);\r\n        return this; }\r\n\r\n    DPackage(uri?: DPackage[\"uri\"], prefix?: DPackage[\"prefix\"]): this {\r\n        const thiss: DPackage = this.thiss as any;\r\n        thiss.uri = uri || '';// || 'org.jodel-react.username';\r\n        thiss.prefix = prefix || '';\r\n        if (thiss.father) {\r\n            if (this.fatherType!.cname === \"DModel\") {\r\n                this.setExternalPtr(thiss.father, \"packages\", \"+=\");\r\n            }\r\n            else {\r\n                this.setExternalPtr(thiss.father, \"subpackages\", \"+=\");\r\n            }\r\n        }\r\n        return this; }\r\n\r\n    DModel(instanceoff?: DModel[\"instanceof\"], isMetamodel?: DModel[\"isMetamodel\"]): this {\r\n        const thiss: DModel = this.thiss as any;\r\n        thiss.packages = []; // packages;\r\n        thiss.isMetamodel = isMetamodel || false;\r\n        thiss.dependencies = [];\r\n        this.setPtr(\"instanceof\", instanceoff || null);\r\n        let lmodel: LModel | undefined = instanceoff ? LPointerTargetable.fromPointer(instanceoff) : undefined;\r\n        this.thiss._persistCallbacks.push(()=>{\r\n            if (lmodel){\r\n                let lthis: LModel = LPointerTargetable.fromD(this.thiss);\r\n                for (let c of lmodel.classes) {\r\n                    let d: DClass = c.__raw;\r\n                    if (d.isSingleton) lthis.addObject({name: d.name}, c, true);\r\n                }\r\n            }\r\n        });\r\n        instanceoff && this.setExternalPtr(instanceoff, \"instances\", \"+=\");\r\n        // todo: check all D.new calls to make sure there are not actions in callbacks in new2() versions that will go outside the Transaction of persist(),, better move ptrs as .new() parameters\r\n        // or make it so new2 splits pointer and non-pointer declarations (or just allow non-ptrs and ptrs must be DSomething.new() explicit parameters)\r\n        thiss._persistCallbacks.push(SetRootFieldAction.create(isMetamodel ? \"m2models\" : \"m1models\", thiss.id, \"+=\", true));\r\n        return this;\r\n    }\r\n\r\n    DOperation(exceptions: DOperation[\"exceptions\"] = [], implementation?: string/*, parameters: DOperation[\"parameters\"] = []*/): this {\r\n        const thiss: DOperation = this.thiss as any;\r\n        // thiss.parameters = parameters;\r\n        thiss.implementation = implementation || 'return \"default placeholder function called\";'\r\n        this.setPtr(\"exceptions\", exceptions);\r\n        this.setExternalPtr(thiss.father, \"operations\", \"+=\");\r\n        return this; }\r\n\r\n    DClass(isInterface: DClass[\"interface\"] = false, isAbstract: DClass[\"abstract\"] = false, isPrimitive: LClassifier[\"isPrimitive\"] = false,\r\n           partial: DClass[\"partial\"] = false, partialdefaultname: DClass[\"partialdefaultname\"] = ''): this {\r\n        const thiss: DClass = this.thiss as any;\r\n        thiss.interface = isInterface;\r\n        thiss.abstract = isAbstract;\r\n        thiss.isPrimitive = isPrimitive;\r\n        thiss.partial = partial;\r\n        thiss.partialdefaultname = partialdefaultname;\r\n        thiss.isSingleton = false;\r\n        thiss.rootable = undefined;\r\n        thiss.sealed = [];\r\n        thiss.final = false;\r\n        thiss.allowCrossReference = false;\r\n        this.setExternalPtr(thiss.father, \"classifiers\", \"+=\");\r\n        this.setExternalRootProperty('ClassNameChanged.'+thiss.id, thiss.name, '', false);\r\n\r\n        // thiss.isClass = !isPrimitive;\r\n        // thiss.isEnum = false;\r\n        return this; }\r\n\r\n    DEnumLiteral(value?: DEnumLiteral[\"value\"]): this { // vv4\r\n        const thiss: DEnumLiteral = this.thiss as any;\r\n        thiss.value = value as any; // undef is ok, handled in getter as automatic ordinal index\r\n        thiss.literal = thiss.name;\r\n        this.setExternalPtr(thiss.father, \"literals\", \"+=\");\r\n        return this; }\r\n\r\n    DEnumerator(literals: DEnumerator[\"literals\"] = []): this {\r\n        const thiss: DEnumerator = this.thiss as any;\r\n        this.setExternalPtr(thiss.father, \"classifiers\", \"+=\");\r\n        this.setPtr(\"literals\", literals);\r\n        // thiss.literals = literals;\r\n        // thiss.isClass = false;\r\n        // thiss.isEnum = true;\r\n        return this; }\r\n    DEdgePoint(): this { return this; }\r\n    DEdge(): this {\r\n        let thiss: DVoidEdge = this.thiss as any;\r\n        return this; }\r\n    DVertex(): this { return this; }\r\n    DVoidEdge(start: DGraphElement[\"id\"] | DGraphElement | LGraphElement | DModelElement[\"id\"] | DModelElement | LModelElement,\r\n              end: DGraphElement[\"id\"] | DGraphElement | LGraphElement | DModelElement[\"id\"] | DModelElement | LModelElement,\r\n              longestLabel?: DEdge[\"longestLabel\"], labels?: DEdge[\"labels\"]): this {\r\n        const thiss: DVoidEdge = this.thiss as any;\r\n        let startid: DGraphElement[\"id\"] = (windoww.LGraphElement as typeof LGraphElement).getNodeId(start);\r\n        let endid: DGraphElement[\"id\"] = (windoww.LGraphElement as typeof LGraphElement).getNodeId(end);\r\n        Log.ex(!startid || !endid, \"cannot create an edge without start or ending nodes\", {start, end, startid, endid});\r\n        thiss.anchorStart = '0';\r\n        thiss.anchorEnd = '0';\r\n        // thiss.startFollow = false;\r\n        // thiss.endFollow = false;\r\n        thiss.midnodes = [];\r\n        thiss.midPoints = []; // the logic part which instructs to generate the midnodes\r\n        // if (!thiss.model && isDModelElementPointer(startid)) thiss.model = startid;\r\n        // thiss.labels = undefined;\r\n        let ll: labelfunc = (e: LVoidEdge, s: EdgeSegment, allNodes: LGraphElement[], allSegments: EdgeSegment[]\r\n        ) => /*defining the edge label (e.start.model as any)?.name + \" ~ \" + (e.end.model as any)?.name */\" (\" + s.length.toFixed(1) + \")\";\r\n        // complex edge label func example: (thiss.longestLabel = ll) but assign to transientnodeproperties or in jsx props instead on this.longestLabel\r\n        thiss.longestLabel = longestLabel;\r\n        this.setPtr(\"start\", startid);\r\n        this.setPtr(\"end\", endid);\r\n        this.setExternalPtr(startid, \"edgesOut\", \"+=\");\r\n        this.setExternalPtr(endid, \"edgesIn\", \"+=\");\r\n\r\n        let gthis: Partial<DVoidEdge> = thiss;\r\n        delete gthis.x;\r\n        delete gthis.y;\r\n        delete gthis.w;\r\n        delete gthis.h;\r\n        delete gthis.edgesIn;\r\n        delete gthis.edgesOut;\r\n        delete gthis.anchors;\r\n        delete gthis.__isDVoidEdge;\r\n        delete (gthis as Partial<DEdge>).__isDEdge;\r\n        return this; }\r\n\r\n    DExtEdge(): this { return this; }\r\n    DRefEdge(): this { return this; }\r\n\r\n    DGraphElement(model: DGraphElement[\"model\"]|null|undefined, parentgraphID: DGraphElement[\"graph\"]|undefined,\r\n                  htmlindex: number = 1): this {\r\n        const thiss: DGraphElement = this.thiss as any;\r\n        thiss.subElements = [];\r\n        thiss.favoriteNode = false;\r\n        thiss.zIndex = htmlindex;\r\n        thiss.isSelected = {};\r\n        thiss.edgesIn = [];\r\n        thiss.edgesOut = [];\r\n        thiss.subElements = [];\r\n        // thiss.state = {id: thiss.id+\".state\", className: thiss.className};\r\n        // 5-way anchors thiss.anchors = {'0':{x:0.5, y:0.5}, '1':{x:0.5, y:0}, '2':{x:1, y:0.5}, '3':{x:0.5, y:1}, '4':{x:0, y:0.5}} as any;\r\n        thiss.anchors = {'0':{x:0.5, y:0.5}, 't':{x:0.5, y:0},\r\n            'tr':{x:1, y:0}, 'r':{x:1, y:0.5}, 'br':{x:1, y:1},\r\n            'b':{x:0.5, y:1},\r\n            'bl':{x:0, y:1}, 'l':{x:0, y:0.5}, 'tl':{x:0, y:0},\r\n        } as any;\r\n        for (let k in (thiss.anchors as GObject)) {\r\n            let a: GObject = thiss.anchors[k];\r\n            if (!a.name) a.name = k;\r\n            if (!a.w) a.w = 15;\r\n            if (!a.h) a.h = 15;\r\n        }\r\n\r\n        this.setPtr(\"model\", model);\r\n        this.setPtr(\"graph\", parentgraphID);\r\n        this.setExternalPtr(thiss.father, \"subElements\", \"+=\");\r\n\r\n        Log.eDev(thiss.father&&DPointerTargetable.fromPointer(thiss.father).subElements.indexOf(thiss.id)!==-1, \"subelemnts+= addition have duplicates\",\r\n            {adding:thiss, d:thiss.father&&DPointerTargetable.fromPointer(thiss.father).subElements.indexOf(thiss.id)});\r\n\r\n        return this;\r\n    }\r\n\r\n    DViewElement(name: string, jsxString: string, vp?: Pointer<DViewPoint>,\r\n                 defaultVSize?: GraphSize, usageDeclarations: string = '', constants: string = '',\r\n                 preRenderFunc: string = '', appliableToClasses: string[] = [], oclCondition: string = '', priority?: number): this {\r\n        const thiss: DViewElement = this.thiss as any;\r\n        const vid = thiss.id;\r\n        let tv = transientProperties.view[vid];\r\n        if (!tv) transientProperties.view[vid] = tv = {} as any;\r\n\r\n        thiss.name = name;\r\n        thiss.appliableToClasses = appliableToClasses;\r\n        thiss.appliableTo = 'Any';\r\n        thiss.jsxString = jsxString;\r\n        thiss.usageDeclarations = usageDeclarations;\r\n        thiss.constants = undefined; // '{}';\r\n        thiss.preRenderFunc = ''; // '() => {return{}}';\r\n        thiss.onDragEnd = thiss.onDragStart = thiss.whileDragging =\r\n        thiss.onResizeEnd = thiss.onResizeStart = thiss.whileResizing = '';\r\n        thiss.onRotationEnd = thiss.onRotationStart = thiss.whileRotating = '';\r\n        thiss.onDataUpdate = '';\r\n        thiss.events = {};\r\n        // thiss.__transient = new DViewTransientProperties();\r\n        thiss.subViews = {};\r\n        thiss.oclCondition = oclCondition || '';\r\n        thiss.jsCondition = '';\r\n        thiss.oclUpdateCondition = '';\r\n        thiss.OCL_NEEDS_RECALCULATION = true;\r\n        thiss.explicitApplicationPriority = undefined as any; //priority as any as number;\r\n        thiss.isExclusiveView = true;\r\n        thiss.size = {};\r\n        thiss.storeSize = false;\r\n        thiss.lazySizeUpdate = true;\r\n        thiss.isValidation = false;\r\n        //thiss.constraints = [];\r\n        thiss.palette = {\r\n            'color-': U.hexToPalette(), //['#ffffff', '#ff0000', '#00ff00', '#0000ff','#aaaaaa', '#ffaaaa', '#aaffaa', '#aaaaff'],\r\n            'background-': U.hexToPalette() // ['#000000', '#33333', '#777777']};\r\n        };\r\n        thiss.css = '';\r\n        thiss.compiled_css = '';\r\n        thiss.css_MUST_RECOMPILE = true;\r\n        thiss.cssIsGlobal = false;\r\n        // thiss.palette = {};\r\n\r\n        // thiss.useSizeFrom = EuseSizeFrom.node;\r\n        // thiss.adaptHeight = false;\r\n        // thiss.adaptWidth = false;\r\n\r\n\r\n        thiss.draggable = true;\r\n        thiss.resizable = true;\r\n        //thiss.display = 'flex' as any;\r\n        thiss.defaultVSize = defaultVSize || new GraphSize(0, 0, 140.6818084716797, 32.52840805053711);\r\n        thiss.adaptWidth = false;\r\n        thiss.adaptHeight = true; //'fit-content';\r\n\r\n        thiss.edgeStartOffset = new GraphPoint(50, 50);\r\n        thiss.edgeEndOffset = new GraphPoint(50, 50);\r\n        thiss.edgeStartOffset_isPercentage = true;\r\n        thiss.edgeEndOffset_isPercentage = true;\r\n        thiss.edgeStartStopAtBoundaries = true;\r\n        thiss.edgeEndStopAtBoundaries = true;\r\n        thiss.bendingMode = EdgeBendingMode.Bezier_quadratic;\r\n        thiss.edgeGapMode = EdgeGapMode.center;\r\n        thiss.edgePointCoordMode = CoordinateMode.relativeOffset;\r\n        thiss.usageDeclarations = undefined;\r\n\r\n        /// edge only\r\n\r\n        thiss.edgeHeadSize = new GraphPoint(20, 20);\r\n        thiss.edgeTailSize = new GraphPoint(20, 20);\r\n        if (thiss.className !== 'DViewElement') return this;\r\n        const user = LUser.fromPointer(DUser.current);\r\n        // const project = user?.project; if(!project) return this;\r\n        if (!vp) vp = user?.project?.activeViewpoint.id || Defaults.viewpoints[0];\r\n        if (vp !== 'skip') {\r\n            // let dvp = DPointerTargetable.fromPointer(vp);\r\n            // let subviews = {...dvp.subViews}; subviews[thiss.id] = 1.5;\r\n            // this.setExternalPtr(vp, 'subViews', '', subviews);\r\n            this.setPtr('viewpoint', vp);\r\n        }\r\n\r\n        this.setExternalPtr(this.fatherPtr as Pointer<DViewElement>, 'subViews', '+=', {[thiss.id]: 1.5});\r\n        transientProperties.view[thiss.id] = {} as any;\r\n\r\n        // let trview = transientProperties.view[thiss.id];\r\n        // trview.?? = ???\r\n\r\n        TRANSACTION('recompile jsx & more', () => {\r\n            // add relation to vp\r\n            for(let key of (windoww.DViewElement as typeof DViewElement).RecompileKeys)\r\n                this.setExternalRootProperty('VIEWS_RECOMPILE_'+key, thiss.id, '+=', false) // is pointer, but no need to set pointedby\r\n        })\r\n\r\n        // this.setExternalPtr(project.id, 'views', '+=');\r\n        // this.setExternalPtr(project.id, 'stackViews', '+=');\r\n        return this;\r\n    }\r\n\r\n    DViewPoint(): this {\r\n        const thiss: DViewPoint = (this.thiss) as any;\r\n        const user = LUser.fromPointer(DUser.current);\r\n        const project = user?.project;\r\n        if (!project) return this;\r\n        this.setExternalPtr(project.id, 'viewpoints', '+=');\r\n        // thiss.cssIsGlobal = true;\r\n        // thiss._persistCallbacks.push( SetFieldAction.create(project.id, 'stackViews', [], '', false) );\r\n        return this;\r\n    }\r\n\r\n    DProject(type: DProject['type'], name: string, state: DProject['state'], m2: DProject['metamodels'], m1: DProject['models'], id?: DProject['id']): this {\r\n        const _this: DProject = U.wrapper<DProject>(this.thiss);\r\n        _this.metamodels = m2;\r\n        _this.models = m1;\r\n        _this.type = type;\r\n        _this.name = name;\r\n        _this.state = state || '';\r\n        if(id) _this.id = id;\r\n        _this.favorite = {};\r\n        _this.description = 'A new Project. Created by ' + (DPointerTargetable.from(DUser.current) as DUser).nickname + ' @' + new Date().toLocaleString();\r\n        this.setExternalPtr(DUser.current, 'projects', '+=');\r\n        return this;\r\n    }\r\n\r\n    static DGraph_maxID: number = 0;\r\n    public static DGraph_makeID(modelid: DGraph[\"model\"]): Pointer<DGraph, 1, 1, LGraph> {\r\n        if (!modelid) modelid = \"shapeless\";\r\n        return modelid + '_graph' + Constructors.DGraph_maxID++;\r\n    }\r\n    DGraph(): this {\r\n        const thiss: DGraph = this.thiss as any;\r\n        thiss.graph = thiss.id; // no setPtr because i want to avoid circular pointedby reference\r\n        thiss.zoom = new GraphPoint(1, 1);\r\n        thiss.offset = new GraphPoint(0, 0);  // GraphSize.apply(this, [0, 0, 0 ,0]);\r\n        thiss._subMaps = {zoom: true, graphSize: true}\r\n\r\n        const user: LUser = LUser.fromPointer(DUser.current);\r\n        if (thiss.className === 'DGraph') { // to exclude GraphVertex\r\n            user.project && this.setExternalPtr(user.project.id, 'graphs', \"+=\");\r\n            thiss.x = 0;\r\n            thiss.y = 0;\r\n            thiss.w = 0;\r\n            thiss.h = 0;\r\n        }\r\n        else {\r\n            // todo: set to default graphvertex size, so it can skip a rerender\r\n            thiss.x = 0;\r\n            thiss.y = 0;\r\n            //thiss.w = packageDefaultSize.w;\r\n            //thiss.h = packageDefaultSize.h;\r\n        }\r\n        return this; }\r\n\r\n    DVoidVertex(defaultVSize?: InitialVertexSize): this {\r\n        const thiss: DVoidVertex = this.thiss as any;\r\n        /*[]{}<>\r\n?'^~\r\n&&||\\+\r\n6nb*/\r\n        let defaultVSizeObj: InitialVertexSizeObj | undefined;\r\n        let defaultVSizeFunc: InitialVertexSizeFunc;\r\n        thiss.isResized = false;\r\n\r\n        let lvertex: LVoidVertex = LPointerTargetable.fromD(thiss);\r\n        if (typeof defaultVSize !== \"function\") { defaultVSizeObj = defaultVSize; }\r\n        else {\r\n            defaultVSizeFunc = defaultVSize;\r\n            try { defaultVSizeObj = defaultVSizeFunc(lvertex.father, lvertex); }\r\n            catch (e) { Log.exx(\"Error in user DefaultVSize function:\", {e, defaultVSizeFunc, txt:defaultVSizeFunc.toString()}); }\r\n        }\r\n        if (defaultVSizeObj) {\r\n            if (defaultVSizeObj.x !== undefined) thiss.x = defaultVSizeObj.x;\r\n            if (defaultVSizeObj.y !== undefined) thiss.y = defaultVSizeObj.y;\r\n            if (defaultVSizeObj.w !== undefined) thiss.w = defaultVSizeObj.w;\r\n            if (defaultVSizeObj.h !== undefined) thiss.h = defaultVSizeObj.h;\r\n\r\n            if ((defaultVSizeObj as any).index >= 0 && thiss.className === \"DEdgePoint\") {\r\n                let updateEPindex = () => {\r\n                    let lep = lvertex as LEdgePoint;\r\n                    let le: LVoidEdge = lep.father;\r\n                    let de: DVoidEdge = le.__raw;\r\n                    let subelements = [...de.subElements];\r\n                    U.arrayRemoveAll(subelements, thiss.id);\r\n                    subelements.splice(defaultVSizeObj?.index as number, 0, thiss.id);\r\n                    // console.log(\"setting subelements\", {oldsubelements, subelements, de, le, thiss});\r\n                    le.subElements = subelements as any;\r\n                    // todo: this might break \"pointedBy\" x984\r\n                }\r\n                // updateEPindex();\r\n                // it's already wrapped in a callback\r\n                // but needs a second one because after node is created, id is auto-appended to this collection\r\n                // and i need to rewrite that append by inserting my own customized index position\r\n                console.log(\"setting subelements 0\", {updateEPindex});\r\n                setTimeout(updateEPindex, 0);\r\n                // NB: do not use this.callbacks.push because the body of this func is executed after Constructors.end() so end() can never find and execute it.\r\n            }\r\n        }\r\n\r\n        return this; }\r\n\r\n\r\n}\r\n// export const Constructors = new _Constructors();\r\n\r\n@RuntimeAccessible(\"DPointerTargetable\")\r\nexport class DPointerTargetable extends RuntimeAccessibleClass {\r\n    static defaultComponent: (ownProps: GObject, children?: (string | React.Component)[]) => React.ReactElement; //\r\n    public static maxID: number = 0;\r\n    public static logic: typeof LPointerTargetable;\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static pendingCreation: Record<Pointer<DPointerTargetable, 1, 1>, DPointerTargetable> = {};\r\n    clonedCounter?: number;\r\n    _storePath?: string[];\r\n    _subMaps?: Dictionary<string, boolean>;\r\n    id!: Pointer<DPointerTargetable, 1, 1, LPointerTargetable>;\r\n    // pointedBy: DocString<'path in store'>[] = []; // NB: potrebbe contenere puntatori invalidi.\r\n    // se viene cancellato un intero oggetto A che contiene una lista di puntatori, gli oggetti che puntano ad A rimuovono A dai loro \"poitnedBy\",\r\n    // ma gli oggetti puntati da A tramite sotto-oggetti o attributi (subviews...) non vengono aggiornati in \"pointedby\"\r\n    pointedBy: PointedBy[] = [];\r\n    public className!: string;\r\n    public __readonly!: boolean;\r\n    _state: GObject = {};\r\n    name?:string;\r\n\r\n    static defaultname<L extends LModelElement = LModelElement>(startingPrefix: string | ((meta:L)=>string), father?: Pointer | DPointerTargetable | ((a:string)=>boolean), metaptr?: Pointer | null): string {\r\n        let lfather: LModelElement;\r\n        // startingPrefix = \"model_\", father = ((name: string) => !dmodelnames.includes(name))\r\n        if (father) {\r\n            if (typeof father === \"string\" || (father as any).className) { // Pointer or D\r\n                lfather = LPointerTargetable.wrap(father as DModelElement) as LModelElement;\r\n                if (!lfather) return (typeof startingPrefix === \"string\" ? startingPrefix : \"unnamed_elem\"); // can happen during parse when father ptr exist but it's not in store yet. not a prob\r\n                if (typeof startingPrefix !== \"string\") {\r\n                    let meta = LPointerTargetable.from(metaptr as Pointer);\r\n                    startingPrefix = startingPrefix(meta as L);\r\n                }\r\n                const childrenNames: (string)[] = lfather.children.map(c => (c as LNamedElement)?.name);\r\n                return U.increaseEndingNumber(startingPrefix + '0', false, false, (newname) => childrenNames.indexOf(newname) >= 0);\r\n            }\r\n            else {\r\n                let condition: (a:string)=>boolean = father as any;\r\n                return U.increaseEndingNumber(startingPrefix + '0', false, false, condition);\r\n            }\r\n        }\r\n        return startingPrefix + \"1\"; }\r\n\r\n    public static new(...a:any): DPointerTargetable { //father?: Pointer, persist: boolean = false, fatherType?: Constructor, ...a:any): DPointerTargetable {\r\n        Log.exx(\"cannot instantiate abstract class DPointerTargetable\");\r\n        return null as any;\r\n        // return new Constructors(new DPointerTargetable('dwc'), father, persist, fatherType).DPointerTargetable().end();\r\n    }\r\n    constructor(fakearg_detectwrongcalls:'dwc') {\r\n        super();\r\n        if (!fakearg_detectwrongcalls) throw new Error( \"cannot build D-objects using new keyword, use the static D-Class.new method instead\");\r\n    }\r\n\r\n    static fromL<LX extends LPointerTargetable,\r\n        DX = LX extends LEnumerator ? LEnumerator : (LX extends LAttribute ? LAttribute : (LX extends LReference ? LReference : (LX extends LRefEdge ? LRefEdge : (LX extends LExtEdge ? LExtEdge : (LX extends LDataType ? LDataType : (LX extends LClass ? LClass : (LX extends LStructuralFeature ? LStructuralFeature : (LX extends LParameter ? LParameter : (LX extends LOperation ? LOperation : (LX extends LEdge ? LEdge : (LX extends LEdgePoint ? LEdgePoint : (LX extends LGraphVertex ? LGraphVertex : (LX extends LModel ? LModel : (LX extends LValue ? LValue : (LX extends LObject ? LObject : (LX extends LEnumLiteral ? LEnumLiteral : (LX extends LPackage ? LPackage : (LX extends LClassifier ? LClassifier : (LX extends LTypedElement ? LTypedElement : (LX extends LVertex ? LVertex : (LX extends LVoidEdge ? LVoidEdge : (LX extends LVoidVertex ? LVoidVertex : (LX extends LGraph ? LGraph : (LX extends LNamedElement ? LNamedElement : (LX extends LAnnotation ? LAnnotation : (LX extends LGraphElement ? LGraphElement : (LX extends LMap ? LMap : (LX extends LModelElement ? LModelElement : (LX extends LUser ? LUser : (LX extends LPointerTargetable ? LPointerTargetable : (ERROR)))))))))))))))))))))))))))))))\r\n        >(data: LX): DX {\r\n        return data.__raw as any;\r\n    }\r\n\r\n\r\n    static fromPointer<// LOW extends number, UPP extends number | 'N',\r\n        T extends Pointer | Pointer[], // <DPointerTargetable, 1, 'N', LPointerTargetable>,\r\n        DDD extends (T extends Pointer<infer D> ? D : 'undefined D'),\r\n        LOW extends (T extends Pointer<any, infer LO> ? LO : 'undefined_upp'),\r\n        UPP extends (T extends Pointer<any, number, infer UP> ? UP : 'undefined_low'),\r\n\r\n        DDDARR extends (T extends Pointer<infer D>[] ? D : 'undefined_DARR'),\r\n        LOWARR extends (T extends Pointer<any, infer LO>[] ? LO : 'undefined_uppARR'),\r\n        UPPARR extends (T extends Pointer<any, number, infer UP>[] ? 'UP_is_N' : 'undefined_lowARR'),\r\n\r\n        RET = UPPARR extends 'UP_is_N' ?\r\n            (DDDARR[]) : // 0...N\r\n            (UPP extends 1 ? (LOW extends 0 ? DDD | null : DDD) : // 0...1 && 1...1\r\n                (LOW extends 1 ? DDD : undefined)  //1...1\r\n                ),\r\n        INFERRED = {ret: RET, upp: UPP, low:LOW, ddd: DDD, dddARR: DDDARR, lowARR: LOWARR, uppARR: UPPARR},>(ptr: T, s?: DState)\r\n        : RET {\r\n        s = s || store.getState();\r\n        if (!ptr) { return ptr as any; }\r\n        if (Array.isArray(ptr)) {\r\n            return ptr.map( (p: Pointer) => DPointerTargetable.fromPointer(p, s)) as any;\r\n        }\r\n        if (typeof ptr !== \"string\") {\r\n            console.error(\"wrong parameter in DPointerTargetable.fromPointers()\", ptr);\r\n            throw new Error(\"wrong parameter in DPointerTargetable.fromPointers()\");\r\n        }\r\n        if (s && s.idlookup[ptr as string]) return s.idlookup[ptr as string] as any;\r\n        return (DPointerTargetable.pendingCreation[ptr as string] || s.idlookup[ptr as string]) as any;\r\n        // return ((s || store.getState()).idlookup[ptr as string] || DPointerTargetable.pendingCreation[ptr as string]) as any;\r\n    }\r\n\r\n    static from<// LOW extends number, UPP extends number | 'N',\r\n        PTR extends Pointer | Pointer[], // <DPointerTargetable, 1, 'N', LPointerTargetable>,\r\n        DDD extends (PTR extends Pointer<infer D> ? D : 'undefined D'),\r\n        LOW extends (PTR extends Pointer<any, infer LO> ? LO : 'undefined_upp'),\r\n        UPP extends (PTR extends Pointer<any, number, infer UP> ? UP : 'undefined_low'),\r\n\r\n        DDDARR extends (PTR extends Pointer<infer D>[] ? D : 'undefined_DARR'),\r\n        LOWARR extends (PTR extends Pointer<any, infer LO>[] ? LO : 'undefined_uppARR'),\r\n        UPPARR extends (PTR extends Pointer<any, number, infer UP>[] ? 'UP_is_N' : 'undefined_lowARR'),\r\n\r\n        LX extends LPointerTargetable,\r\n\r\n        RETPTR = UPPARR extends 'UP_is_N' ?\r\n            (DDDARR[]) : // 0...N\r\n            (UPP extends 1 ? (LOW extends 0 ? DDD | null : DDD) : // 0...1 && 1...1\r\n                (LOW extends 1 ? DDD : undefined)  //1...1\r\n                ),\r\n        // DX = LX extends LEnumerator ? DEnumerator : (LX extends LAttribute ? DAttribute : (LX extends LReference ? DReference : (LX extends LDataType ? DDataType : (LX extends LClass ? DClass : (LX extends LStructuralFeature ? DStructuralFeature : (LX extends LParameter ? DParameter : (LX extends LOperation ? DOperation : (LX extends LModel ? DModel : (LX extends LValue ? DValue : (LX extends LObject ? DObject : (LX extends LEnumLiteral ? DEnumLiteral : (LX extends LPackage ? DPackage : (LX extends LClassifier ? DClassifier : (LX extends LTypedElement ? DTypedElement : (LX extends LNamedElement ? DNamedElement : (LX extends LAnnotation ? DAnnotation : ('ERROR'))))))))))))))))),\r\n        DX = LX extends LEnumerator ? DEnumerator : (LX extends LAttribute ? DAttribute : (LX extends LReference ? DReference : (LX extends LRefEdge ? DRefEdge : (LX extends LExtEdge ? DExtEdge : (LX extends LDataType ? DDataType : (LX extends LClass ? DClass : (LX extends LStructuralFeature ? DStructuralFeature : (LX extends LParameter ? DParameter : (LX extends LOperation ? DOperation : (LX extends LEdge ? DEdge : (LX extends LEdgePoint ? DEdgePoint : (LX extends LGraphVertex ? DGraphVertex : (LX extends LModel ? DModel : (LX extends LValue ? DValue : (LX extends LObject ? DObject : (LX extends LEnumLiteral ? DEnumLiteral : (LX extends LPackage ? DPackage : (LX extends LClassifier ? DClassifier : (LX extends LTypedElement ? DTypedElement : (LX extends LVertex ? DVertex : (LX extends LVoidEdge ? DVoidEdge : (LX extends LVoidVertex ? DVoidVertex : (LX extends LGraph ? DGraph : (LX extends LNamedElement ? DNamedElement : (LX extends LAnnotation ? DAnnotation : (LX extends LGraphElement ? DGraphElement : (LX extends LMap ? DMap : (LX extends LModelElement ? DModelElement : (LX extends LUser ? DUser : (LX extends LPointerTargetable ? DPointerTargetable : (ERROR))))))))))))))))))))))))))))))),\r\n        RET = DX extends 'ERROR' ? RETPTR : (RETPTR extends DX ? RETPTR : DX),\r\n        INFERRED = {ret: RET, RETPTR:RETPTR, upp: UPP, low:LOW, ddd: DDD, dddARR: DDDARR, lowARR: LOWARR, uppARR: UPPARR, LX:LX, DX:DX}>(ptr: PTR | LX, s?: DState)\r\n        : RET {\r\n        if (!ptr) return ptr as any;\r\n        if (Array.isArray(ptr)) return DPointerTargetable.fromArr(ptr, true, s) as any;\r\n        if ((ptr as LX).__isProxy) return (ptr as LX).__raw as any;\r\n        if (typeof ptr === \"string\") {\r\n            if (s && s.idlookup[ptr as string]) return s.idlookup[ptr as string] as any;\r\n            return (DPointerTargetable.pendingCreation[ptr as string] || store.getState().idlookup[ptr as string]) as any;\r\n        }\r\n        else if ((ptr as any as GObject<DX>).className) return ptr as any;\r\n        else return undefined as any;\r\n    }\r\n    public static fromArr(arr:any[], filter: boolean = true, s?: DState): DPointerTargetable[]{\r\n        let ret: (DPointerTargetable)[] = [];\r\n        s = s || store.getState();\r\n        for (let a of arr) {\r\n            let d = DPointerTargetable.from(a, s);\r\n            if (!filter || d) ret.push(d as DPointerTargetable);\r\n        }\r\n        return ret;\r\n    }\r\n    //static from0(a: any, ...aa: any): any { return null; }\r\n    static writeable<LX extends LPointerTargetable, WX = LtoW<LX>>(l: LX): WX { return l as any; }\r\n\r\n    _persistCallbacks!: ((() => void) | Action)[]; // deleted when it becomes persistent\r\n    _derivedSubElements!: DModelElement[]; // deleted when it becomes persistent\r\n    // persist(): void { Constructors.persist(this); }// deleted when it becomes persistent\r\n}\r\n\r\nRuntimeAccessibleClass.set_extend(RuntimeAccessibleClass, DPointerTargetable);\r\n/*\r\nlet d0: LClassifier = null as any;\r\nlet ptrr: Pointer<DPackage, 1, 'N', LPackage> = null as any;\r\nlet ptr1: Pointer<DPackage, 1, 1, LPackage> = null as any;\r\nlet dd = DPointerTargetable.from(d0.id);\r\n*/\r\n\r\n\r\n/*\r\ntype Pack1<D extends DPointerTargetable, L extends LPointerTargetable = DtoL<D>, P extends Pointer<D, 0, 1, L> = Pointer<D, 0, 1, L>, R = {D:D, L:L, P:P} > = P|D|L\r\ntype PackArr<D extends DPointerTargetable, L extends LPointerTargetable = DtoL<D>, P extends Pointer<D, 0, 1, L> = Pointer<D, 0, 1, L> , ARR = Pack1<D>> = (ARR)[];\r\ntype Pack<D extends DPointerTargetable, L extends LPointerTargetable = DtoL<D>, P extends Pointer<D, 0, 1, L> = Pointer<D, 0, 1, L> , ARR = Pack1<D>> = ARR | (ARR)[];*/\r\n\r\n\r\n\r\n@RuntimeAccessible('Pointers')\r\nexport class Pointers{\r\n    static filterValid<P extends (Pointer | Pointer[]) = any, RET = P extends Pointer[] ? P : P | null>\r\n    (p: P): P | null {\r\n        const pointerval: DPointerTargetable | DPointerTargetable[] = DPointerTargetable.from(p);\r\n        if (Array.isArray(pointerval)) return pointerval.filter( p => !!p).map( p => p.id) as P;\r\n        if (!pointerval) return null;\r\n        return pointerval.id as P; }\r\n\r\n    static fromArr<D extends DPointerTargetable, L extends LPointerTargetable, P extends Pointer> (val: (P | D | L | null | undefined)[] |  (P | D | L | null | undefined)): P[] {\r\n        if (!val) val = [];\r\n        if (!Array.isArray(val)) { val = [val]; }\r\n        if (!val.length) { return []; }\r\n        if ((val[0] as any).id) { val = (val as any as (LModelElement | DModelElement)[]).filter(v => !!v).map( (v) => v.id) as any[]; }\r\n        return val.filter( v => !!v) as any[]; }\r\n\r\n    fromm<D extends DPointerTargetable, L extends LPointerTargetable, P extends Pointer> (val: (P | D | L)): P | null { return !val ? null : (val as any).id; }\r\n\r\n    from0<// LOW extends number, UPP extends number | 'N',\r\n        PTR extends Pointer | Pointer[], // <DPointerTargetable, 1, 'N', LPointerTargetable>,\r\n        // DDD extends (PTR extends Pointer<infer D> ? D : 'undefined_D'),\r\n        LOW extends (PTR extends Pointer<any, infer LO> ? LO : 'undefined_upp'),\r\n        UPP extends (PTR extends Pointer<any, number, infer UP> ? UP : 'undefined_low'),\r\n        DDD extends (PTR extends Pointer<any, number, any, infer LL> ? LL : 'undefined_L'),\r\n\r\n        LOWARR extends (PTR extends Pointer<any, infer LO>[] ? LO : 'undefined_uppARR'),\r\n        UPPARR extends (PTR extends Pointer<any, number, infer UP>[] ? 'UP_is_N' : 'undefined_lowARR'),\r\n        DDDARR extends (PTR extends Pointer<any, any, any, infer LL>[] ? LL : 'undefined_LARR'),\r\n\r\n        DX extends DPointerTargetable,\r\n        LX extends LPointerTargetable,\r\n        WX extends WPointerTargetable,\r\n        RETPTR = UPPARR extends 'UP_is_N' ?\r\n            (DDDARR[]) : // 0...N\r\n            (UPP extends 1 ? (LOW extends 0 ? DDD | null : DDD) : // 0...1 && 1...1\r\n                (LOW extends 1 ? DDD : undefined)  //1...1\r\n                ),\r\n\r\n\r\n        // DX = LX extends LEnumerator ? DEnumerator : (LX extends LAttribute ? DAttribute : (LX extends LReference ? DReference : (LX extends LDataType ? DDataType : (LX extends LClass ? DClass : (LX extends LStructuralFeature ? DStructuralFeature : (LX extends LParameter ? DParameter : (LX extends LOperation ? DOperation : (LX extends LModel ? DModel : (LX extends LValue ? DValue : (LX extends LObject ? DObject : (LX extends LEnumLiteral ? DEnumLiteral : (LX extends LPackage ? DPackage : (LX extends LClassifier ? DClassifier : (LX extends LTypedElement ? DTypedElement : (LX extends LNamedElement ? DNamedElement : (LX extends LAnnotation ? DAnnotation : ('ERROR'))))))))))))))))),\r\n        LXX = DtoL<DX>,\r\n        DXX = LtoD<LX>,\r\n        LXFinal = LXX extends 'ERROR' ? LX : LXX,\r\n        DXFinal = DXX extends 'ERROR' ? DX : DXX,\r\n        RET = {d: DXFinal, l:LXFinal}, // Pointer<DX, 0 | 1, 1 | 'N', LX>\r\n        INFERRED = {ret: RET, RETPTR: RETPTR, LXX: LXX, DXX: DXX, upp: UPP, low:LOW, ddd: DDD, dddARR: DDDARR, lowARR: LOWARR, uppARR: UPPARR, LX:LX, DX:DX}>(data: LX | DX | WX)\r\n        : INFERRED {\r\n        return null as any;\r\n    }\r\n\r\n\r\n    static from00<\r\n        // LOW extends number, UPP extends number | 'N',\r\n        // DDD extends (PTR extends Pointer<infer D> ? D : 'undefined_D'),\r\n        DWL extends {id: any},\r\n        // PCK extends (T extends Pack<infer PPP> ? PPP : never),\r\n        //ISARR extends (T extends any[] ? true : false),\r\n        // PCK1 extends (T extends any[] ? null : T extends Pack1<infer PPP> ? PPP : never), //         PCK1 extends (T extends any[] ? true : false),\r\n        // PCKA extends (T extends PackArr<infer PPP> ? PPP : 'undefined_arrpack'),\r\n        // PTR extends DWL[\"id\"], // <DPointerTargetable, 1, 'N', LPointerTargetable>,\r\n        // T extends DWL | DWL[] | null | undefined,\r\n        /*DX extends (PTR extends Pointer<infer D0> ? D0 : 'undefined_D'),\r\n        LOW extends (PTR extends Pointer<any, infer LO> ? LO : 'undefined_upp'),\r\n        UPP extends (PTR extends Pointer<any, number, infer UP> ? UP : 'undefined_low'),\r\n        LX extends (PTR extends Pointer<any, number, any, infer LL> ? LL : 'undefined_L'),\r\n\r\n        LOWARR extends (PTR extends Pointer<any, infer LO>[] ? LO : 'undefined_uppARR'),\r\n        UPPARR extends (PTR extends Pointer<any, number, infer UP>[] ? 'UP_is_N' : 'undefined_lowARR'),\r\n        DDDARR extends (PTR extends Pointer<any, any, any, infer LL>[] ? LL : 'undefined_LARR'),\r\n        RET = DX extends DPointerTargetable ? ( LOW extends number ? ( UPP extends number ? ( LX extends LPointerTargetable ? Pointer<DX, LOW, UPP, LX> : '_notret_L_') : '_notret_UPP_') : '_notret_LOW_') : '_notret_D_'\r\n        */\r\n        PTRPARAM = Pointer | Pointer[],\r\n        T = Exclude<DWL | DWL[] | PTRPARAM, unknown[]>,\r\n        // @ts-ignore\r\n        PTR = T extends null ? null : T extends undefined ? null : (T extends PTRPARAM ? T : (T extends any[] ? T[number]['id'][] : T['id'])),\r\n        // RET extends Pointer<DPointerTargetable, any, any, LPointerTargetable> = T extends DWL ? DWL[\"id\"] : (T extends DWL[] ? DWL[\"id\"] : null),\r\n        // INF = { PCK:PCK, ISARR: ISARR,  PTR: PTR, DWL: DWL, RET: RET}, // {DD:DD, LL: LL}//\r\n        >(data: T | T[] ): PTR { // RET | RET[] {\r\n        if (Array.isArray(data)) return data.filter(d => !!d).map(d => (typeof d === \"string\" ? d : (d as any as DWL).id)) as any;\r\n        else return (data ? (data as any).id : null);\r\n    } // stavolta fai infer so D|l.id\r\n\r\n\r\n    public static from<DX extends DPointerTargetable>(data:DX): DX[\"id\"]; // | {D:any};\r\n    public static from<DX extends DPointerTargetable>(data:DX[]): DX[\"id\"][]; // | {DD:any};\r\n    public static from<LX extends LPointerTargetable>(data:LX): LX[\"id\"]; // | {L:any};\r\n    public static from<LX extends LPointerTargetable>(data:LX[]): LX[\"id\"][]; // | {LL:any};\r\n    public static from<WX extends WPointerTargetable>(data:WX): WX[\"id\"]; // | {W:any};\r\n    public static from<WX extends WPointerTargetable>(data:WX[]): WX[\"id\"][]; // | {WW:any};\r\n    public static from<PTR extends Pointer<DPointerTargetable, 1, 1, LPointerTargetable>>(data:PTR): PTR; // | {P:any};\r\n    public static from<PTR extends Pointer<DPointerTargetable, 1, 1, LPointerTargetable>>(data:PTR[]): PTR[]; // | {PP:any};\r\n    public static from<T extends LPointerTargetable>(data:Pack1<T>): Pointer<LtoD<T>, 1, 1, T>; //{TEST1:any};\r\n    public static from<T extends LPointerTargetable>(data:Pack1<T>[]): Pointer<LtoD<T>, 1, 1, T>[]; //{TEST111:any};\r\n    public static from<T extends LPointerTargetable>(data:Pack<T>): Pointer<LtoD<T>, 1, 1, T>[]; //{TEST0:any};\r\n    public static from<P extends Pack<T> | undefined, T extends LPointerTargetable>(data: P): Pointer<LtoD<T>, 1, 1, T>[]; //{TEST0:any};\r\n    public static from<T extends LPointerTargetable>(data:PackArr<T>): Pointer<LtoD<T>, 1, 1, T>[]; //{TESTARR:any};\r\n    public static from<T extends LPointerTargetable>(data:Pack1<T[]>): Pointer<LtoD<T>, 1, 1, T>; //{TEST1:any};\r\n    public static from<T extends LPointerTargetable>(data:Pack1<T[]>[]): Pointer<LtoD<T>, 1, 1, T>[]; //{TEST111:any};\r\n    public static from<T extends LPointerTargetable>(data:Pack<T[]>): Pointer<LtoD<T>, 1, 1, T>[]; //{TEST0:any};\r\n    public static from<T extends LPointerTargetable>(data:PackArr<T[]>): Pointer<LtoD<T>, 1, 1, T>[]; //{TESTARR:any};\r\n\r\n    /*\r\n        public static from(data:undefined): undefined; // | {D:any};\r\n        public static from<DX extends DPointerTargetable | undefined | null>(data:DX): DX extends DPointerTargetable ? DX[\"id\"] : DX; // | {D:any};\r\n        public static from<DX extends DPointerTargetable | undefined | null>(data:DX[]): DX extends DPointerTargetable ? DX[\"id\"][] : DX; // | {DD:any};\r\n        public static from<LX extends LPointerTargetable | undefined | null>(data:LX): LX extends LPointerTargetable ? LX[\"id\"] : LX; // | {L:any};\r\n        public static from<LX extends LPointerTargetable | undefined | null>(data:LX[]): LX extends LPointerTargetable ? LX[\"id\"][] : LX; // | {LL:any};\r\n        public static from<WX extends WPointerTargetable | undefined | null>(data:WX): WX extends WPointerTargetable ? WX[\"id\"] : WX; // | {W:any};\r\n        public static from<WX extends WPointerTargetable | undefined | null>(data:WX[]): WX extends WPointerTargetable ? WX[\"id\"][] : WX; // | {WW:any};\r\n        public static from<PTR extends Pointer<DPointerTargetable, 1, 1, LPointerTargetable> | undefined | null>(data:PTR): PTR extends Pointer<DPointerTargetable, 1, 1, LPointerTargetable> ? PTR : PTR; // | {P:any};\r\n        public static from<PTR extends Pointer<DPointerTargetable, 1, 1, LPointerTargetable> | undefined | null>(data:PTR[]): PTR extends Pointer<DPointerTargetable, 1, 1, LPointerTargetable> ? PTR[] : PTR; // | {PP:any};\r\n        public static from<T extends LPointerTargetable | undefined | null>(data:Pack1<T>): T extends LPointerTargetable ? Pointer<LtoD<T>, 1, 1, T> : T; //{TEST1:any};\r\n        public static from<T extends LPointerTargetable | undefined | null>(data:Pack1<T>[]): T extends LPointerTargetable ? Pointer<LtoD<T>, 1, 1, T>[] : T; //{TEST111:any};\r\n        public static from<T extends LPointerTargetable | undefined | null>(data:Pack<T>): T extends LPointerTargetable ? Pointer<LtoD<T>, 1, 1, T>[] : T; //{TEST0:any};\r\n        public static from<T extends LPointerTargetable | undefined | null>(data:PackArr<T>): T extends LPointerTargetable ? Pointer<LtoD<T>, 1, 1, T>[] : T; //{TESTARR:any};\r\n        // public static from<T extends LPointerTargetable | undefined | null>(data:Pack1<T[]>): T extends LPointerTargetable ? Pointer<LtoD<T>, 1, 1, T> : T; //{TEST1:any};\r\n        // public static from<T extends LPointerTargetable | undefined | null>(data:Pack1<T[]>[]): T extends LPointerTargetable ? Pointer<LtoD<T>, 1, 1, T>[] : T; //{TEST111:any};\r\n        // DDD extends (T extends Pointer<infer D> ? D : 'undefined D'),*/\r\n    // returns:\r\n    // if ptr is unvalid = undefined;\r\n    // if [ptr] is unvalid = []\r\n    public static from<TT extends Pack<LPointerTargetable[]> | undefined | null,\r\n        // @ts-ignore\r\n        T extends (TT extends Pack<infer PTYPE> ? PTYPE : undefined)>(data:T): T extends null | undefined ? T : Pointer<LtoD<T>, 1, 1, T>[]; //{TEST0:any};\r\n    // @ts-ignore\r\n    public static from<T extends LPointerTargetable | undefined | null>(data: PackArr<T[]>): T extends null | undefined ? T : Pointer<LtoD<T>, 1, 1, T>[]; //{TESTARR:any};\r\n    public static from(data:null | undefined): null; // | {Dn:any};\r\n    public static from(data:(null | undefined)[]): []; // | {Dnn:any};\r\n    public static from(data:(null | undefined) | (null | undefined)[]): []; // | {Dn0:any};\r\n\r\n    // function from<PTR extends Pointer<DPointerTargetable, 1, 1, LPointerTargetable>>(data:unknown | unknown[]): PTR | PTR[] | GObject {\r\n    public static from<T extends LClass, PTR extends Pointer<DPointerTargetable, 1, 1, LPointerTargetable>>(data:unknown | unknown[]): null | PTR | PTR[]{\r\n        if (!data) return null;\r\n        if (Array.isArray(data)) return data.filter(d => !!d).map(d => (typeof d === \"string\" ? d : (d as any)?.id)) as any;\r\n        return typeof data === \"string\" ? data : (data as any)?.id;\r\n    }\r\n\r\n    static isPointer(val: any, state?: DState, doArrayCheck: boolean = false): val is Pointer {\r\n        // might cause endless loop if there are subarrays in a containment loop.\r\n        if (doArrayCheck && Array.isArray(val)) return (val as any[]).some((v) => Pointers.isPointer(val, state, true));\r\n        if (state) return DPointerTargetable.from(val, state);\r\n        return typeof val === \"string\" ? val.includes(\"Pointer\") : false;\r\n    }\r\n}\r\n\r\n/*\r\nexport type Pack1<L extends LPointerTargetable | undefined | null,\r\n    // L extends LPointerTargetable | undefined | null = LL extends LPointerTargetable[] ? LPointerTargetable : null | undefined,\r\n    D extends (L extends LPointerTargetable ? LtoD<L> : undefined | null) = (L extends LPointerTargetable ? LtoD<L> : undefined | null)> =\r\n    L extends LPointerTargetable ? ( D extends DPointerTargetable ? D | L /*| LtoW<L>* / | Pointer<D, 1, 1, L> : L) : undefined;\r\nexport type PackArr<LL extends orArr<LPointerTargetable> | undefined | null,\r\n    L extends LPointerTargetable | undefined | null = LL extends undefined | null ? undefined : unArr<LL>> = Pack1<L>[];\r\nexport type Pack<\r\n    LL extends orArr<LPointerTargetable> | undefined | null,\r\n    L extends unArr<LL> = unArr<LL>,\r\n    // L extends (LL extends orArr<LPointerTargetable> ? LPointerTargetable : undefined | null) = (LL extends orArr<LPointerTargetable> ? unArr<LL> : undefined)\r\n    >\r\n    = LL extends undefined ? undefined : Pack1<L> | PackArr<L>;\r\n*/\r\nexport type Pack1<LL extends orArr<LPointerTargetable> | undefined, L extends LPointerTargetable | undefined = unArr<LL>,\r\n    D extends (L extends LPointerTargetable ? LtoD<L> : undefined) = (L extends LPointerTargetable ? LtoD<L> : undefined)> =\r\n    L extends LPointerTargetable ? ( D extends DPointerTargetable ? D | L | Pointer<D, 1, 1, L> : undefined) : undefined;\r\nexport type PackArr<LL extends orArr<LPointerTargetable> | undefined, L extends LPointerTargetable | undefined = unArr<LL>> = Pack1<L>[];\r\nexport type Pack<LL extends orArr<LPointerTargetable> | undefined, L extends LPointerTargetable | undefined = unArr<LL>> = L extends undefined ? undefined : Pack1<L> | PackArr<L>;\r\n/*\r\nlet n: any = null;\r\nlet aa: DClass = n;\r\nlet ptrr = Pointers.from(aa.parent);\r\naa.parent = ptrr;*/\r\n\r\n@RuntimeAccessible('PendingPointedByPaths')\r\nexport class PendingPointedByPaths{\r\n    static all: PendingPointedByPaths[] = [];\r\n    // static pendingMoreThanTwice: ParsedAction[] = [];\r\n    static maxSolveAttempts: number = 2099999;\r\n    public solveAttempts: number = 1;\r\n    private stackTrace: string[];\r\n\r\n    // tmp fields, not sure what i need\r\n    public action!: ParsedAction; // todo: remove\r\n    static new(action: ParsedAction, oldState: DState): PendingPointedByPaths {\r\n        const ptr: Pointer = action.value;\r\n        const target: DPointerTargetable | null = oldState.idlookup[ptr as string];\r\n        let pendingPointedBy = new PendingPointedByPaths(action.path, ptr);\r\n        pendingPointedBy.action = action;\r\n        return pendingPointedBy;\r\n    }\r\n\r\n    private constructor(\r\n        public from: DocString<\"full Path in store including field key\">,\r\n        // todo 6: how about actions that do not include index but just += -= [] ?\r\n        public to: Pointer){\r\n        this.stackTrace = U.getStackTrace();\r\n    }\r\n    static attemptimplementationdelete(pb: PointedBy) {\r\n        let state: DState = store.getState();\r\n        let objectChain = U.followPath(state, pb.source);\r\n    }\r\n\r\n    public attemptResolve(state: DState): ParsedAction | null {\r\n        if (this.canBeResolved(state)) return this.resolve();\r\n        return null;\r\n    }\r\n\r\n    private resolve(): ParsedAction{\r\n        U.arrayRemoveAll(PendingPointedByPaths.all, this);\r\n        return Action.parse(SetRootFieldAction.create(\"idlookup.\" + this.to + '.pointedBy', PointedBy.new(this.action.path), '+=', false));\r\n    }\r\n\r\n    public saveForLater(): void { PendingPointedByPaths.all.push(this); }\r\n    private canBeResolved(state: DState): boolean {\r\n        this.solveAttempts++;\r\n        Log.exDev(this.solveAttempts >= PendingPointedByPaths.maxSolveAttempts, \"pending PointedBy action is not revolved for too long, some pointer was wrongly set up.\", this.stackTrace, this, state);\r\n        return !!state.idlookup[this.to]; }\r\n\r\n    static getSolveableActions(oldState: DState): ParsedAction[] {\r\n        let allClone = [...this.all]; // necessary because the array will remove some elements during iteration as they are solved.\r\n        return allClone.map( p => p.attemptResolve(oldState)).filter(p => (!!p)) as ParsedAction[];\r\n    }\r\n}\r\n\r\n@RuntimeAccessible('PointedBy')\r\nexport class PointedBy {\r\n    static list: string[] = [\"father\", \"parent\", \"annotations\", \"packages\", \"type\", \"subpackages\", \"classifiers\", \"exceptions\", \"parameters\", \"defaultValue\", \"instances\", \"operations\", \"features\", \"attributes\", \"references\", \"extends\", \"extendedBy\", \"implements\", \"implementedBy\", \"instanceof\", \"edges\", \"target\", \"opposite\", \"parameters\", \"exceptions\", \"literals\", \"values\"];\r\n    source: string; // elemento da cui parte il puntatore\r\n    // field: keyof DPointerTargetable;\r\n    // il bersaglio non c'è qui, perchè è l'oggetto che contiene questo dentro l'array pointedBy\r\n\r\n    /*private constructor(source: DPointerTargetable, field: any) {\r\n        this.source = source;\r\n        this.field = field;\r\n    }*/\r\n\r\n    static getPath(p: PointedBy) : string { return p.source.substring(0, p.source.lastIndexOf(\".\")); }\r\n    static getLastKey(p: PointedBy) : string { return p.source.substring(p.source.lastIndexOf(\".\")); }\r\n    static getPathArr(p: PointedBy) : string[] { return p.source.split('.'); }\r\n    private constructor(source: string) {\r\n        this.source = source;\r\n    }\r\n    // don't use modifiers here,\r\n    static fromID<D extends DPointerTargetable>(ptr: Pointer<D>, field: keyof D, NoAccessModifiersHere?: never & (\"-=\" | \"+=\")) {\r\n        return PointedBy.new(\"idlookup.\" + ptr + \".\" + field);\r\n    }\r\n    static new(source: DocString<\"full path in store including key. like \\'idlookup.id.extends+=\\'\">, modifier: \"-=\" | \"+=\" | undefined = undefined, action?: ParsedAction): PointedBy {\r\n        // let source: DocString<\"full path in store including key\"> = action.path;\r\n        // if (source.includes(\"true\")) { console.error(this, action); throw new Error(\"mixed a bool\"); }\r\n        if (modifier) source = source.substring(0, source.length - (modifier?.length || 0));\r\n        return new PointedBy(source);\r\n    }\r\n    // static new0<D extends DPointerTargetable> (source: D, field: keyof D): PointedBy { return new PointedBy(source, field); }\r\n\r\n\r\n\r\n    public static remove(oldValue: Pointer | undefined, action: ParsedAction, state: DState, casee: \"+=\" | \"-=\" | undefined = undefined, oldState?:DState): DState {\r\n        if (!oldValue) return state;\r\n        let oldtarget: DPointerTargetable = state.idlookup[oldValue];\r\n        if (!oldtarget) return state;\r\n        let index = -1;\r\n        let actionpath: string = action.path.substring(0, action.path.length -(casee?.length || 0))\r\n        for (let i = 0; i < oldtarget.pointedBy.length; i++) { if (oldtarget.pointedBy[i].source === actionpath) { index = i; break; } }\r\n        if (index < 0) return state;\r\n\r\n        if (oldState === state) state = {...state} as DState;\r\n        if (oldState?.idlookup === state.idlookup) state.idlookup = {...state.idlookup};\r\n        if (oldState?.idlookup[oldValue] === state.idlookup[oldValue]) {\r\n            state.idlookup[oldValue] = {...oldtarget} as any;\r\n        }\r\n        else {\r\n            // no need\r\n        }\r\n        state.idlookup[oldValue].pointedBy.splice(index, 1) // in-place edit\r\n\r\n        // console.warn('pointedby remove:', {from: oldtarget.pointedBy, to: state.idlookup[oldValue].pointedBy, obj: state.idlookup[oldValue], index, oldValue, actionpath});\r\n        return state;\r\n    }\r\n\r\n    // important! must be called only in reducer\r\n    public static add(newtargetptr: Pointer | undefined, action: ParsedAction, state: DState, casee: \"+=\" | \"-=\" | undefined = undefined, oldState?:DState): DState {\r\n        if (!newtargetptr) return state;\r\n        // todo: if can't be done because newtarget doesn't exist, build an action from this and set it pending.\r\n        let newtarget: DPointerTargetable = state.idlookup[newtargetptr];\r\n        if (!newtarget) {\r\n            PendingPointedByPaths.new(action, state).saveForLater(); // {from: action.path, field: action.field, to: target});\r\n            return state;\r\n        }\r\n        /* simpler version but does unnecessary shallow copies\r\n        state = {...state} as DState;\r\n        state.idlookup = {...state.idlookup};\r\n        state.idlookup[newtargetptr] = {...newtarget, pointedBy:  [...newtarget.pointedBy, PointedBy.new(action.path, casee)]} as any;*/\r\n        if (oldState === state) state = {...state} as DState;\r\n        if (oldState?.idlookup === state.idlookup) state.idlookup = {...state.idlookup};\r\n        if (oldState?.idlookup[newtargetptr] === state.idlookup[newtargetptr]) {\r\n            state.idlookup[newtargetptr] = {...newtarget, pointedBy:  [...newtarget.pointedBy, PointedBy.new(action.path, casee)]} as any;\r\n        }\r\n        else {\r\n            state.idlookup[newtargetptr].pointedBy = [...newtarget.pointedBy, PointedBy.new(action.path, casee)];\r\n        }\r\n        // console.warn('pointedby add:', {from: oldtarget.pointedBy, to: state.idlookup[newtargetptr].pointedBy, obj: state.idlookup[newtargetptr]});\r\n        return state;\r\n    }\r\n}\r\n\r\ntype AnyPointer = Pointer<DPointerTargetable, number, number|'N', LPointerTargetable>;\r\n\r\n@RuntimeAccessible('LPointerTargetable')\r\nexport class LPointerTargetable<Context extends LogicContext<DPointerTargetable> = any, D extends DPointerTargetable = DPointerTargetable> extends DPointerTargetable {\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    public static structure: typeof DPointerTargetable;\r\n    public static singleton: LPointerTargetable;\r\n    public __raw!: D;\r\n    public clonedCounter?: number;\r\n\r\n    public __isProxy!: boolean;\r\n    public __serialize!: DocString<\"json\">;\r\n    private inspect!: D;\r\n    private __random!: number;\r\n    public __readonly!: boolean;\r\n    public state!: any;\r\n    public r!:any;\r\n\r\n    private test(){\r\n        let a: LPointerTargetable = null as any as LEnumLiteral;\r\n        let c: LPointerTargetable = null as any as LParameter;\r\n        let b: LPointerTargetable = null as any as LVertex;\r\n    }\r\n    // public r!: this;\r\n\r\n    private __info_of__id = {type:\"Pointer&lt;this&gt;\",\r\n        txt:\"<a href=\\\"https://github.com/DamianoNaraku/jodel-react/wiki/identifiers\\\">\" +\r\n            \"<span>Unique identifier, and value used to point this object.</span></a>\"};\r\n\r\n    private __info_of____readonly = {type:\"boolean\", txt:\"prevent any change to the current object.\"};\r\n    project!: LProject|null;\r\n    protected get_project(c: GObject<Context>): LProject | null {\r\n        return LPointerTargetable.fromPointer(DUser.current as Pointer<DUser>)?.project || null;\r\n    }\r\n    protected set___readonly(val: any, c: Context): boolean {\r\n        val = !!val;\r\n        let thiss: GObject = this;\r\n        let childrens = (thiss.get_children && thiss.get_children(c)) || [];\r\n        let annotations = (thiss.get_annotations && thiss.get_annotations(c)) || [];\r\n        if (val === c.data.__readonly) return true;\r\n        TRANSACTION('readonly ' + + this.get_name(c), ()=>{\r\n            for (let c of childrens) { c.__readonly = val; }\r\n            for (let c of annotations) { c.__readonly = val; }\r\n            SetFieldAction.new(c.data, '__readonly', val);\r\n        }, val, !val);\r\n        return true;\r\n    }\r\n\r\n\r\n    public pointedBy!: PointedBy[];\r\n    // pointedBy!: LPointerTargetable[];\r\n    get_pointedBy(context: Context): LPointerTargetable[\"pointedBy\"] {\r\n        let state: DState = store.getState();\r\n        let targeting: LPointerTargetable[] = LPointerTargetable.fromArr(context.data.pointedBy.map( p => {\r\n            let s: GObject = state;\r\n            for (let key of PointedBy.getPathArr(p)) {\r\n                s = s[key];\r\n                if (!s) return null;\r\n                if (s.className) return s.id;\r\n            }\r\n        }));\r\n        return targeting as any;\r\n    }\r\n\r\n\r\n    name!:string;\r\n    protected get_name(c: Context): this[\"name\"] {\r\n        let nameattribute = (c.proxyObject as any).$name;\r\n        let ret: string = undefined as any;\r\n        if (nameattribute && nameattribute.className === 'LValue') {\r\n            ret = nameattribute.value;\r\n        }\r\n        if (ret === undefined) ret = c.data.name || c.data.className;\r\n        return ret;\r\n    }\r\n\r\n    protected set_name(val: this[\"name\"], c: Context): boolean {\r\n        let name = val;\r\n        const father: LPointerTargetable = (c.proxyObject as LModelElement).father;\r\n        if (father) {\r\n            const check = (father as LModelElement).children?.filter((child) => {\r\n                return (D.fromPointer(child.id) as DNamedElement).name === name;\r\n            });\r\n            if (check.length > 0) {\r\n                U.alert('e', 'Cannot rename the selected element since this name is already taken.');\r\n                return true;\r\n            }\r\n        }\r\n\r\n        TRANSACTION(this.get_name(c)+'.name', ()=>{\r\n            let nameattribute = (c.proxyObject as any).$name;\r\n            if (nameattribute && nameattribute.className === 'LValue') {\r\n                nameattribute.value = val;\r\n            }\r\n            SetFieldAction.new(c.data, 'name', name, '', false);\r\n        }, undefined, val)\r\n        return true;\r\n    }\r\n\r\n\r\n    fullname!:string;\r\n    protected get_fullname(c: Context): this[\"name\"] { return this.get_name(c); } // fallback\r\n\r\n    protected wrongAccessMessage(str: string): any {\r\n        let msg = \"Method \"+str+\" should not be called directly, attempting to do so should trigger get_\"+str+\"(). This is only a signature for type checking.\";\r\n        Log.ex(true, msg);\r\n        throw new Error(msg); }\r\n\r\n    public toString(): string { throw this.wrongAccessMessage(\"toString\"); }\r\n    protected get_toString(context: Context): () => string {\r\n        const data = context.data as DNamedElement;\r\n        return () => ( data.name || data.className.substring(0));\r\n        // return () => data.id;\r\n    }\r\n    public toPrimitive(): string { throw this.wrongAccessMessage(\"toPrimitive\"); }\r\n    protected get_toPrimitive(c: Context): ((hint?: \"number\" | \"string\" | \"default\" ) => (number | string)) {\r\n        return (hint?: \"number\" | \"string\" | \"default\") => {\r\n            switch (hint){\r\n                default:\r\n                case \"number\":\r\n                    return c.data.clonedCounter || -1;\r\n                case \"string\":\r\n                case \"default\":\r\n                    return this.get_toString(c)();\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    protected cannotSet(field: string, msg?:string): any { return Log.exx('\"' + field + '\" field is read-only' + (msg ? '.\\n'+msg : '')); }\r\n    protected get_id(context: Context): this[\"id\"] { return context.data.id; }\r\n    protected set_id(): boolean { return this.cannotSet('id'); }\r\n\r\n    protected _get_default< DD extends DPointerTargetable, T extends string & keyof (DD) & keyof (L), L extends LModelElement = LModelElement>(data: DD, key: T): L[T]{\r\n        // @ts-ignore\r\n        return LPointerTargetable.from(data[key]);\r\n    }\r\n\r\n    _state!: GObject;\r\n    __info_of___state = {type:\"GObject\", txt: `<div>A space where the user can store informations for their operations/views.<br/>\r\nExample: The Validation viewpoint uses it to store validation messages.<br/>\r\nWARNING! do not set proxies in the state, set pointers instead.<br/>\r\n<a href='https://github.com/MDEGroup/jjodel/wiki/L%E2%80%90Object-state'>Learn more on the wiki</a></div>`};\r\n\r\n    // get__state(c: Context): any { return this.wrongAccessMessage('_state',', use obj.state instead.'); }\r\n    // set__state(val: this[\"_state\"], c: Context): boolean { return this.cannotSet('_state', 'use obj.state instead.'); }\r\n    get_state(context: any): any /*this['_state']*/ {\r\n        if (!context.data._state) return {};\r\n        return this.__shallowSolver(context.data._state, true, true); // to solve pointers in state\r\n        // return LPointerTargetable.wrap(context.data._state); // this should work, because data._state have id = this.id+\"._state\"\r\n    }\r\n    set_state(val: any, c: Context): boolean {\r\n        // todo: put those lobjects -> pointer checks into defaultsetter to improve it\r\n\r\n        // 3 options:\r\n        // 1) if state === node, then setting whole state is invalid\r\n        // 2) if state is a proxified obj with id = node.id+\".state\" so actions and proxy getters/setters will act on the subobject properties still invalid setting whole obj.\r\n        // 3) forbid to set the whole state, merge old state with new one, if val === undefined, state is reset.\r\n\r\n        // i choose 3)\r\n        let newState: GObject;\r\n        let oldState = c.data._state ? {...c.data._state} : {};\r\n        let changed: boolean = false;\r\n        if (val === undefined) {\r\n            if (!oldState || !Object.keys(oldState).length) return true;\r\n            newState = {};\r\n            changed = true;\r\n        }\r\n        else if (typeof val !== \"object\") { Log.ee(\"state can only be assigned with an object or undefined\"); return true; }\r\n        else {\r\n            val = this.__sanitizeValue(val);\r\n            newState = {...oldState};\r\n            for (let k in val) {\r\n                if (val[k] === undefined) {\r\n                    if (oldState[k] === undefined) continue;\r\n                    delete newState[k];\r\n                    changed = true;\r\n                    continue;\r\n                }\r\n\r\n                if (oldState[k] === val[k]) continue;\r\n                newState[k] = val[k];\r\n                changed = true;\r\n            }\r\n        }\r\n\r\n        if (!changed) return true;\r\n\r\n        TRANSACTION(this.get_name(c)+'.state', ()=>{\r\n            SetFieldAction.new(c.data, \"_state\", newState, undefined, false);\r\n        })\r\n        return true;\r\n    }\r\n    protected __sanitizeValue(val: any, canEditVal: boolean = true, canEditValDeep:boolean = false): any{\r\n        if (!val) { return val; }\r\n        let className = val.className;\r\n        if ((val.__isProxy || val.id && className)\r\n            && !RuntimeAccessibleClass.extends(className, IPoint.cname)\r\n            && !RuntimeAccessibleClass.extends(className, ISize.cname)) {\r\n            return val.id;\r\n        }\r\n        // if (typeof val === \"string\") { return val; } else\r\n        if (typeof val !== \"object\") { return val; }\r\n        else if (Array.isArray(val)) { return val.map(v => this.__sanitizeValue(v, canEditValDeep, canEditValDeep)); }\r\n        // case val is object not array, not proxy, not D. just a POJO\r\n        let ret = canEditVal ? val : {...val};\r\n        for (let k in val) {\r\n            if (Array.isArray(val[k])) ret[k] = val[k].map((v: any)=> v && (v.__isProxy || v.id && v.className) ? v.id : v);\r\n            else if (val[k] && (val[k].__isProxy || val[k].id && val[k].className)) ret[k] = val[k].id;\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    // protected _defaultCollectionGetter(c: Context, k: keyof Context[\"data\"]): LPointerTargetable[] { return LPointerTargetable.fromPointer((c.data as any)[k]); }\r\n    protected _defaultGetter(c: Context, k: keyof Context[\"data\"]): any {\r\n        return this.__defaultGetter(c, k);\r\n    }\r\n    protected _defaultSetter(v0: any, c: Context, k: keyof Context[\"data\"]): boolean {\r\n        this.__defaultSetter(v0, c, k);\r\n        return true;\r\n    }\r\n    protected __defaultGetter(c: Context, k: keyof Context[\"data\"]): any {\r\n        // console.log(\"default Getter\");\r\n        let v = (c.data as any)[k];\r\n        return this.__shallowSolver(v, true, false);\r\n    }\r\n    protected __shallowSolver<T>(val: any, solveArrayValues: boolean, solveObjectKeys: boolean): any {\r\n        if (!val) return val;\r\n        let state: DState = store.getState();\r\n        if (solveArrayValues && Array.isArray(val)) {\r\n            if (val.length === 0) return [];\r\n            return val.map(v => LPointerTargetable.attemptWrap(v));\r\n            // else if (Pointers.isPointer(val[0] as any)) return LPointerTargetable.fromArr(val, state);\r\n            // return val;\r\n        }\r\n        if (solveObjectKeys && typeof val === \"object\"){\r\n            let ret = {...val};\r\n            for (let key in val){\r\n                ret[key] = LPointerTargetable.attemptWrap(val[key]);\r\n            }\r\n            return ret;\r\n        }\r\n        return val && Pointers.isPointer(val as any, undefined) ? LPointerTargetable.fromPointer(val, state) : val;\r\n    }\r\n\r\n    protected __defaultSetter(v0: any, c: Context, k: keyof Context[\"data\"]): boolean {\r\n        // todo: get the those lobjects -> pointer checks from set_state\r\n        let v: any = this.__sanitizeValue(v0, false, false);\r\n        if (!k) return Log.exx('a key is mandatory for default setter', {v0, k, c});\r\n        if (true || k in c.data) {\r\n            // check if is pointer\r\n            let isPointer: boolean;\r\n            if (Array.isArray(v)) {\r\n                if (v.length === 0) isPointer = true; // assumed, should not cause harm if it is not.\r\n                    // it will delete remove an entry in pointedBy from all oldValue entries in the array that should not be present anyway.\r\n                // like oldVal.map( id => U.arrayRemove(LData.wrap(id).pointedBy, c.data.this_id)\r\n                else isPointer = v.some(p=>Pointers.isPointer(p)); //Pointers.isPointer(v[0] as any);\r\n            } else isPointer = Pointers.isPointer(v);\r\n\r\n            // autofix value\r\n            let bytes = 0;\r\n            let type: string = (this as any)[\"__info_of__\"+k]?.type;\r\n            if (type) type = U.multiReplaceAll(type, [\"array\", \"Array\", \"<\", \">\", \"[]\"], []);\r\n            switch(type){\r\n                case ShortAttribETypes.EDate: break;\r\n                default: break;\r\n                case ShortAttribETypes.EBoolean: v = !!v; break;\r\n                case ShortAttribETypes.EByte: bytes = 8; break;\r\n                case ShortAttribETypes.EShort: bytes = 16; break;\r\n                case ShortAttribETypes.EInt: bytes = 32; break;\r\n                case ShortAttribETypes.ELong: bytes = 64; break;\r\n                case ShortAttribETypes.EString: v = \"\"+v; break;\r\n                case ShortAttribETypes.EChar: v = (\"\"+v)[0]; break;\r\n                case ShortAttribETypes.EVoid: Log.exx(\"cannot set a void-typed value\", {c, d:c.data, k, v}); return true;\r\n                case ShortAttribETypes.EDouble:\r\n                case ShortAttribETypes.EFloat: v = +v; break;\r\n            }\r\n            if (bytes) {\r\n                v = Math.round(+v);\r\n                let max = v << bytes; // left shift is the same as multiplying by a power of 2, but binary and more efficient.\r\n                let min = -max + 1\r\n                if (v > max) v = max;\r\n                else if (v < min) v = min;\r\n            }\r\n            console.log(\"default Setter[\"+k+\"] = \" + v , {type, v, v0, oldv:(c.data as any)[k], isPointer});\r\n\r\n            let oldv = c.data[k as keyof DPointerTargetable];\r\n            let newv = v;\r\n            if (!U.isPrimitive(oldv)) oldv = undefined;\r\n            if (!U.isPrimitive(newv)) newv = undefined;\r\n            TRANSACTION(this.get_name(c)+'.'+k, ()=>{\r\n                SetFieldAction.new(c.data, k as any, v, '', isPointer);\r\n            }, oldv, newv)\r\n            return true;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    public get__extends(superClassName: string, context: LogicContext<DPointerTargetable>): boolean {\r\n        return RuntimeAccessibleClass.extends(context.data.className, superClassName);\r\n    }\r\n\r\n    /*\r\n    public get_pointedBy(superClassName: string, context: LogicContext<DPointerTargetable>): LPointerTargetable[] {\r\n        let state: GObject = windoww.store.getState();\r\n        function getForemostObjectInPath(path: DocString<'storePath'>): undefined | LPointerTargetable {\r\n            let lastPointableObject: undefined | DPointerTargetable;\r\n            let pathArray = path.split('.');\r\n            for (let key of pathArray) {\r\n                let currentObj: GObject = state[key];\r\n                if (!currentObj) break;\r\n                if (currentObj && currentObj.id && state.idlookup[currentObj.id]) lastPointableObject = state.idlookup[currentObj.id];\r\n            }\r\n            return lastPointableObject && DPointerTargetable.wrap(lastPointableObject);\r\n        }\r\n        return (context.data.pointedBy || []).map(getForemostObjectInPath).filter( lobj => !!lobj) as LPointerTargetable[];\r\n    }*/\r\n\r\n    public set_pointedBy(val: never, context: LogicContext<DPointerTargetable>): boolean {\r\n        windoww.Log.exx('pointedBy field should never be directly edited.', {context, val});\r\n        return false;\r\n    }\r\n\r\n\r\n\r\n\r\n    static fromD<DX extends DPointerTargetable,\r\n        LX = DX extends DEnumerator ? LEnumerator : (DX extends DAttribute ? LAttribute : (DX extends DReference ? LReference : (DX extends DRefEdge ? LRefEdge : (DX extends DExtEdge ? LExtEdge : (DX extends DDataType ? LDataType : (DX extends DClass ? LClass : (DX extends DStructuralFeature ? LStructuralFeature : (DX extends DParameter ? LParameter : (DX extends DOperation ? LOperation : (DX extends DEdge ? LEdge : (DX extends DEdgePoint ? LEdgePoint : (DX extends DGraphVertex ? LGraphVertex : (DX extends DModel ? LModel : (DX extends DValue ? LValue : (DX extends DObject ? LObject : (DX extends DEnumLiteral ? LEnumLiteral : (DX extends DPackage ? LPackage : (DX extends DClassifier ? LClassifier : (DX extends DTypedElement ? LTypedElement : (DX extends DVertex ? LVertex : (DX extends DVoidEdge ? LVoidEdge : (DX extends DVoidVertex ? LVoidVertex : (DX extends DGraph ? LGraph : (DX extends DNamedElement ? LNamedElement : (DX extends DAnnotation ? LAnnotation : (DX extends DGraphElement ? LGraphElement : (DX extends DMap ? LMap : (DX extends DModelElement ? LModelElement : (DX extends DUser ? LUser : (DX extends DPointerTargetable ? LPointerTargetable : (ERROR))))))))))))))))))))))))))))))),\r\n        >(data: DX): LX;\r\n    static fromD<DX extends DPointerTargetable,\r\n        LX = DX extends DEnumerator ? LEnumerator : (DX extends DAttribute ? LAttribute : (DX extends DReference ? LReference : (DX extends DRefEdge ? LRefEdge : (DX extends DExtEdge ? LExtEdge : (DX extends DDataType ? LDataType : (DX extends DClass ? LClass : (DX extends DStructuralFeature ? LStructuralFeature : (DX extends DParameter ? LParameter : (DX extends DOperation ? LOperation : (DX extends DEdge ? LEdge : (DX extends DEdgePoint ? LEdgePoint : (DX extends DGraphVertex ? LGraphVertex : (DX extends DModel ? LModel : (DX extends DValue ? LValue : (DX extends DObject ? LObject : (DX extends DEnumLiteral ? LEnumLiteral : (DX extends DPackage ? LPackage : (DX extends DClassifier ? LClassifier : (DX extends DTypedElement ? LTypedElement : (DX extends DVertex ? LVertex : (DX extends DVoidEdge ? LVoidEdge : (DX extends DVoidVertex ? LVoidVertex : (DX extends DGraph ? LGraph : (DX extends DNamedElement ? LNamedElement : (DX extends DAnnotation ? LAnnotation : (DX extends DGraphElement ? LGraphElement : (DX extends DMap ? LMap : (DX extends DModelElement ? LModelElement : (DX extends DUser ? LUser : (DX extends DPointerTargetable ? LPointerTargetable : (ERROR))))))))))))))))))))))))))))))),\r\n        >(data: DX[]): LX[];\r\n    static fromD(data: any): any {\r\n        // return null as any;\r\n        if (Array.isArray(data)) return LPointerTargetable.wrapAll(data) as any;\r\n        return LPointerTargetable.wrap(data) as any;\r\n    }\r\n\r\n\r\n    static fromPointer<\r\n        T extends AnyPointer | AnyPointer[], // <DPointerTargetable, 1, 'N', LPointerTargetable>,\r\n        DDD extends (T extends Pointer<any, any, any, infer D> ? D : 'undefined L'),\r\n        LOW extends (T extends Pointer<any, infer LO> ? LO : 'undefined_upp'),\r\n        UPP extends (T extends Pointer<any, number, infer UP> ? UP : 'undefined_low'),\r\n\r\n        DDDARR extends (T extends Pointer<any, any, any, infer D>[] ? D : 'undefined_DARR'),\r\n        LOWARR extends (T extends Pointer<any, infer LO>[] ? LO : 'undefined_uppARR'),\r\n        UPPARR extends (T extends Pointer<any, number, infer UP>[] ? 'UP_is_N' : 'undefined_lowARR'),\r\n\r\n        RET = UPPARR extends 'UP_is_N' ?\r\n            (DDDARR[]) : // 0...N\r\n            (UPP extends 1 ? (LOW extends 0 ? DDD | null : DDD) : // 0...1 && 1...1\r\n                (LOW extends 1 ? DDD : undefined)  //1...1\r\n                ),\r\n        INFERRED = {ret: RET, upp: UPP, low:LOW, ddd: DDD, dddARR: DDDARR, lowARR: LOWARR, uppARR: UPPARR},>(ptr: T | undefined, state?: DState)\r\n        : RET {\r\n        // return null as any;\r\n        if (Array.isArray(ptr)) return LPointerTargetable.wrapAll(ptr as any, undefined, '', false, state) as any;\r\n        return LPointerTargetable.wrap(ptr) as any;\r\n    }\r\n    static fromArr(...a:any): any; // because otherwise it complains about inheriting from DPointerTargetable.fromArr\r\n    static fromArr<\r\n        PTR extends Pointer | Pointer[], // <DPointerTargetable, 1, 'N', LPointerTargetable>,\r\n        // DDD extends (PTR extends Pointer<infer D> ? D : 'undefined_D'),\r\n        LOW extends (PTR extends Pointer<any, infer LO> ? LO : 'undefined_upp'),\r\n        UPP extends (PTR extends Pointer<any, number, infer UP> ? UP : 'undefined_low'),\r\n        DDD extends (PTR extends Pointer<any, number, any, infer LL> ? LL : 'undefined_L'),\r\n\r\n        LOWARR extends (PTR extends Pointer<any, infer LO>[] ? LO : 'undefined_uppARR'),\r\n        UPPARR extends (PTR extends Pointer<any, number, infer UP>[] ? 'UP_is_N' : 'undefined_lowARR'),\r\n        DDDARR extends (PTR extends Pointer<any, any, any, infer LL>[] ? LL : 'undefined_LARR'),\r\n\r\n        DX extends DPointerTargetable,\r\n\r\n        RETPTR = UPPARR extends 'UP_is_N' ?\r\n            (DDDARR[]) : // 0...N\r\n            (UPP extends 1 ? (LOW extends 0 ? DDD | null : DDD) : // 0...1 && 1...1\r\n                (LOW extends 1 ? DDD : undefined)  //1...1\r\n                ),\r\n\r\n        // DX = LX extends LEnumerator ? DEnumerator : (LX extends LAttribute ? DAttribute : (LX extends LReference ? DReference : (LX extends LDataType ? DDataType : (LX extends LClass ? DClass : (LX extends LStructuralFeature ? DStructuralFeature : (LX extends LParameter ? DParameter : (LX extends LOperation ? DOperation : (LX extends LModel ? DModel : (LX extends LValue ? DValue : (LX extends LObject ? DObject : (LX extends LEnumLiteral ? DEnumLiteral : (LX extends LPackage ? DPackage : (LX extends LClassifier ? DClassifier : (LX extends LTypedElement ? DTypedElement : (LX extends LNamedElement ? DNamedElement : (LX extends LAnnotation ? DAnnotation : ('ERROR'))))))))))))))))),\r\n        LX = DX extends DEnumerator ? LEnumerator : (DX extends DAttribute ? LAttribute : (DX extends DReference ? LReference : (DX extends DRefEdge ? LRefEdge : (DX extends DExtEdge ? LExtEdge : (DX extends DDataType ? LDataType : (DX extends DClass ? LClass : (DX extends DStructuralFeature ? LStructuralFeature : (DX extends DParameter ? LParameter : (DX extends DOperation ? LOperation : (DX extends DEdge ? LEdge : (DX extends DEdgePoint ? LEdgePoint : (DX extends DGraphVertex ? LGraphVertex : (DX extends DModel ? LModel : (DX extends DValue ? LValue : (DX extends DObject ? LObject : (DX extends DEnumLiteral ? LEnumLiteral : (DX extends DPackage ? LPackage : (DX extends DClassifier ? LClassifier : (DX extends DTypedElement ? LTypedElement : (DX extends DVertex ? LVertex : (DX extends DVoidEdge ? LVoidEdge : (DX extends DVoidVertex ? LVoidVertex : (DX extends DGraph ? LGraph : (DX extends DNamedElement ? LNamedElement : (DX extends DAnnotation ? LAnnotation : (DX extends DGraphElement ? LGraphElement : (DX extends DMap ? LMap : (DX extends DModelElement ? LModelElement : (DX extends DUser ? LUser : (DX extends DPointerTargetable ? LPointerTargetable : (ERROR))))))))))))))))))))))))))))))),\r\n        RET = LX extends 'ERROR' ? RETPTR : (RETPTR extends LX ? RETPTR : LX),\r\n        INFERRED = {ret: RET, RETPTR: RETPTR, upp: UPP, low:LOW, ddd: DDD, dddARR: DDDARR, lowARR: LOWARR, uppARR: UPPARR, LX:LX, DX:DX}>(ptr: PTR[] | DX[], state?: DState)\r\n        : RET[] {\r\n        return LPointerTargetable.from(ptr as any, state); }\r\n\r\n    static from<// LOW extends number, UPP extends number | 'N',\r\n        PTR extends Pointer<DPointerTargetable, 0|1, 1|'N', LPointerTargetable> | Pointer[], // <DPointerTargetable, 1, 'N', LPointerTargetable>,\r\n        // DDD extends (PTR extends Pointer<infer D> ? D : 'undefined_D'),\r\n        LOW extends (PTR extends Pointer<any, infer LO> ? LO : 'undefined_upp'),\r\n        UPP extends (PTR extends Pointer<any, number, infer UP> ? UP : 'undefined_low'),\r\n        DDD extends (PTR extends Pointer<any, number, any, infer LL> ? LL : 'undefined_L'),\r\n\r\n        LOWARR extends (PTR extends Pointer<any, infer LO>[] ? LO : 'undefined_uppARR'),\r\n        UPPARR extends (PTR extends Pointer<any, number, infer UP>[] ? 'UP_is_N' : 'undefined_lowARR'),\r\n        DDDARR extends (PTR extends Pointer<any, any, any, infer LL>[] ? LL : 'undefined_LARR'),\r\n\r\n        DX extends DPointerTargetable,\r\n\r\n        RETPTR = UPPARR extends 'UP_is_N' ?\r\n            (DDDARR[]) : // 0...N\r\n            (UPP extends 1 ? (LOW extends 0 ? DDD | null : DDD) : // 0...1 && 1...1\r\n                (LOW extends 1 ? DDD : undefined)  //1...1\r\n                ),\r\n\r\n\r\n        // DX = LX extends LEnumerator ? DEnumerator : (LX extends LAttribute ? DAttribute : (LX extends LReference ? DReference : (LX extends LDataType ? DDataType : (LX extends LClass ? DClass : (LX extends LStructuralFeature ? DStructuralFeature : (LX extends LParameter ? DParameter : (LX extends LOperation ? DOperation : (LX extends LModel ? DModel : (LX extends LValue ? DValue : (LX extends LObject ? DObject : (LX extends LEnumLiteral ? DEnumLiteral : (LX extends LPackage ? DPackage : (LX extends LClassifier ? DClassifier : (LX extends LTypedElement ? DTypedElement : (LX extends LNamedElement ? DNamedElement : (LX extends LAnnotation ? DAnnotation : ('ERROR'))))))))))))))))),\r\n        LX = DX extends DEnumerator ? LEnumerator : (DX extends DAttribute ? LAttribute : (DX extends DReference ? LReference : (DX extends DRefEdge ? LRefEdge : (DX extends DExtEdge ? LExtEdge : (DX extends DDataType ? LDataType : (DX extends DClass ? LClass : (DX extends DStructuralFeature ? LStructuralFeature : (DX extends DParameter ? LParameter : (DX extends DOperation ? LOperation : (DX extends DEdge ? LEdge : (DX extends DEdgePoint ? LEdgePoint : (DX extends DGraphVertex ? LGraphVertex : (DX extends DModel ? LModel : (DX extends DValue ? LValue : (DX extends DObject ? LObject : (DX extends DEnumLiteral ? LEnumLiteral : (DX extends DPackage ? LPackage : (DX extends DClassifier ? LClassifier : (DX extends DTypedElement ? LTypedElement : (DX extends DVertex ? LVertex : (DX extends DVoidEdge ? LVoidEdge : (DX extends DVoidVertex ? LVoidVertex : (DX extends DGraph ? LGraph : (DX extends DNamedElement ? LNamedElement : (DX extends DAnnotation ? LAnnotation : (DX extends DGraphElement ? LGraphElement : (DX extends DMap ? LMap : (DX extends DModelElement ? LModelElement : (DX extends DUser ? LUser : (DX extends DPointerTargetable ? LPointerTargetable : (ERROR))))))))))))))))))))))))))))))),\r\n        RET = LX extends 'ERROR' ? RETPTR : (RETPTR extends LX ? RETPTR : LX),\r\n        INFERRED = {ret: RET, RETPTR: RETPTR, upp: UPP, low:LOW, ddd: DDD, dddARR: DDDARR, lowARR: LOWARR, uppARR: UPPARR, LX:LX, DX:DX}>(ptr: PTR | DX, s?: DState)\r\n        : RET {\r\n        // return null as any;\r\n        if (Array.isArray(ptr)) return LPointerTargetable.wrapAll(ptr) as any;\r\n        return LPointerTargetable.wrap(ptr as any) as any;\r\n    }\r\n\r\n    // static from0(a: any, ...aa: any): any { return null; }\r\n\r\n    /* OLD DELETE\r\n    public delete(): void { throw this.wrongAccessMessage(\"delete\"); }\r\n    public _delete(context: Context): void { new DeleteElementAction(context.data); }\r\n    protected get_delete(context: Context): () => void {\r\n        return () => {\r\n            alert(\"Delete in LPOINTER\")\r\n            this._delete(context);\r\n        }\r\n    }\r\n    */\r\n    /*\r\n*/\r\n    public delete(): void {}\r\n    protected get_delete(c: Context): () => void {\r\n        return ()=>TRANSACTION('delete '+this.get_name(c), Dummy.get_delete(this, c));\r\n    }\r\n}\r\nRuntimeAccessibleClass.set_extend(RuntimeAccessibleClass, LPointerTargetable);\r\n\r\n@RuntimeAccessible('D') export class D extends DPointerTargetable{}\r\n@RuntimeAccessible('L') export class L extends LPointerTargetable{}\r\n@RuntimeAccessible('P') export class P extends Pointers{}\r\n\r\n/*\r\nlet pttr: Pointer<DClassifier, 0, 1, LClassifier> = null as any;\r\nlet ptrany: Pointer<DClassifier, 0|1, 1|'N'>[] = null as any;\r\nlet ptrarr: Pointer<DClassifier>[] = null as any;\r\nlet ptrarr2: Pointer<DClassifier, 1, 'N'> = null as any;\r\nlet d: DClassifier = null as any;\r\nlet darr: DClassifier[] = null as any;\r\n\r\ntype VoidPtr = null | undefined | '';\r\nfunction dfrom<\r\n    PARAM extends orArr<AnyPointer | VoidPtr>,//orArr<WPointerTargetable | LPointerTargetable | DPointerTargetable | AnyPointer>,\r\n\r\n\r\n    DDD extends (PARAM extends Pointer<infer DD> ? DD : 'undefined_D'),\r\n    LOW extends (PARAM extends Pointer<any, infer LO> ? LO : 'undefined_low'),\r\n    LOW0 extends (PARAM extends Pointer<any, 0, any, any> ? 0 : never),\r\n    LOW1 extends (PARAM extends Pointer<any, 1, any, any> ? 1 : never),\r\n    LOW2 extends (VoidPtr extends PARAM ? 0 | 'first' : (PARAM extends VoidPtr ? 0 | 1 | 'second': 1|'third')),\r\n    UPP extends (PARAM extends Pointer<any, number, infer UP> ? UP : 'undefined_upp'),\r\n    LLL extends (PARAM extends Pointer<any, number, any, infer LL> ? LL : 'undefined_L'),\r\n\r\n\r\n\r\n    ISVOID extends PARAM extends VoidPtr  ? 'isvoid' : never,\r\n    ISARR extends PARAM extends [] ? true : false,\r\n    ISPTR extends (PARAM extends AnyPointer | VoidPtr ? 'ptr' : never),\r\n    ISPTRARR extends (PARAM extends (AnyPointer | VoidPtr)[] | Pointer<DPointerTargetable, 1|0, 'N', LPointerTargetable> ? 'ptr_arr' : never),\r\n    ISD extends (PARAM extends DPointerTargetable ? 'd' : never),\r\n    ISDARR extends (PARAM extends DPointerTargetable[] ? 'd_arr' : never),\r\n    ISL extends (PARAM extends LPointerTargetable ? 'l' : never),\r\n    ISLARR extends (PARAM extends LPointerTargetable[] ? 'l_arr' : never),\r\n    ISW extends (PARAM extends WPointerTargetable ? 'w' : never),\r\n    ISWARR extends (PARAM extends WPointerTargetable[] ? 'w_arr' : never),\r\n    // INFER = {LOW:LOW, UPP:UPP, DDD:DDD, LLL:LLL, LOW2:LOW2},\r\n    INFER = { LOW2:LOW2},\r\n    RET = ISVOID | ISPTR | ISPTRARR | ISD | ISDARR | ISL | ISLARR | ISW | ISWARR | INFER\r\n    >\r\n(ptr: PARAM): RET { return null as any; }\r\nlet Lptr = dfrom(pttr as Pointer<DClassifier, 0, 1, LClassifier> );\r\nlet Lptrany = dfrom(ptrany);\r\nlet Lptrarr = dfrom(ptrarr);\r\nlet Lptrarr2 = dfrom(ptrarr2);\r\nlet Ld = dfrom(d);\r\nlet Ldarr = dfrom(darr);*/\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n@RuntimeAccessible('WPointerTargetable')\r\nexport class WPointerTargetable extends DPointerTargetable{\r\n    id!: never;\r\n    _storePath!: never;\r\n    _subMaps!: never;\r\n    pointedBy!: never;\r\n    // todo: WfromD, WfromL, WfromPointer, Wfrom\r\n\r\n    static fromD<DX extends DPointerTargetable, WX extends DtoW<DX>>(data: DX): WX { return LPointerTargetable.fromD(data) as any; }\r\n}\r\nRuntimeAccessibleClass.set_extend(DPointerTargetable, LPointerTargetable);\r\nRuntimeAccessibleClass.set_extend(DPointerTargetable, WPointerTargetable);\r\nfunction fffff<DX, LX = DX extends DRefEdge ? LRefEdge : 'not'>( t: DX): LX { return null as any; }\r\nlet a: DGraphElement = null as any;\r\nlet bbb = LPointerTargetable.from(a);\r\nlet bb2 = fffff(a);\r\n\r\n@Leaf\r\n@RuntimeAccessible('DUser')\r\nexport class DUser extends DPointerTargetable {\r\n    //public static offlineMode: boolean = !!localStorage.getItem(\"offlineMode\");\r\n    public static isStateMachine = false;\r\n    // static current: Pointer<DUser> = 'Pointer_AnonymousUser';\r\n    static current: Pointer<DUser> = undefined as any;\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    id!: Pointer<DUser>;\r\n    name!: string;\r\n    surname!: string;\r\n    nickname!: string;\r\n    country!: string;\r\n    affiliation!: string;\r\n    newsletter!: boolean;\r\n    email!: string;\r\n    token!: string;\r\n    projects: Pointer<DProject, 0, 'N', LProject> = [];\r\n    project: Pointer<DProject, 0, 1, LProject> = '';\r\n    __isUser: true = true; // necessary to trick duck typing to think this is NOT the superclass of anything that extends PointerTargetable.\r\n    /*public static new(id?: DUser[\"id\"], triggerActions: boolean = true): DUser {\r\n        return new Constructors(new DUser('dwc'), undefined, false, undefined, id, true).DPointerTargetable().DUser().end(); }*/\r\n    public static new(name: string, surname: string, nickname: string, affiliation: string, country: string, newsletter: boolean, email: string, token: string, id?: DUser['id'], persist: boolean = true): DUser {\r\n        return new Constructors(new DUser('dwc'), undefined, persist, undefined, id).DPointerTargetable().DUser(name, surname, nickname, affiliation, country, newsletter, email, token).end();\r\n    }\r\n\r\n    /*\r\n    static async loadOffline(): Promise<void> {\r\n        if (DUser.current) return;\r\n        const user = Storage.read<DUser>('user');\r\n        if (user) {\r\n            DUser.new(user.name, user.surname, user.nickname, user.affiliation, user.country, user.newsletter, user.email, user.token, user.id);\r\n            DUser.current = user.id;\r\n            statehistory[user.id] = new UserHistory();\r\n        } else DUser.current = '';\r\n    }*/\r\n\r\n    static offline(allowOffline:boolean=true, allowOnline: boolean = false): DUser | null {\r\n        let ptr: Pointer<DUser> = 'Pointer_OfflineUser';\r\n        let isOffline = U.isOffline();\r\n        if (!isOffline) allowOffline = false;\r\n        let isValid = (d: DUser)=>{\r\n            if (!d) return false;\r\n            let savedUserIsOffline = d.id === ptr;\r\n            if (savedUserIsOffline){\r\n                if (!allowOffline) return false;\r\n            } else if (!allowOnline) return false;\r\n            return true;\r\n        }\r\n\r\n        let d: DUser = D.from(DUser.current);\r\n        console.log('User.load 0 D.from', {d, cu:DUser.current, isOffline, '+':{allowOffline, allowOnline}})\r\n        if (d && isValid(d)) return d;\r\n        let state = store.getState();\r\n        let timer: any = -1;\r\n        let saveToState = ()=>{\r\n            state = store.getState();\r\n            console.log('User.load interval', {state, d, cu:DUser.current, isOffline, '+':{allowOffline, allowOnline}})\r\n            if (!state) return;\r\n            state.idlookup[d.id] = d;\r\n            clearInterval(timer);\r\n        }\r\n        console.log('User.load 1 check state', {d, cu:DUser.current, isOffline, '+':{allowOffline, allowOnline}})\r\n\r\n        if (state){\r\n            d = state.idlookup[ptr] as DUser;\r\n            if (d && isValid(d)) return d;\r\n        }\r\n        console.log('User.load 2 check store', {d, cu:DUser.current, isOffline, '+':{allowOffline, allowOnline}})\r\n\r\n        d = Storage.read<DUser>('user') as DUser;\r\n        if (d && isValid(d)) {\r\n            if (state?.idlookup) saveToState(); //state.idlookup[d.id] = d;\r\n            else {\r\n                timer = setInterval(saveToState, 1);\r\n            }\r\n            return d;\r\n        }\r\n        console.log('User.load 4 exit notoff', {d, cu:DUser.current, isOffline, '+':{allowOffline, allowOnline}})\r\n\r\n        if (!allowOffline) return null; // load offline user only if in offline mode\r\n        d = DUser.new('Offline', 'User', 'Unknown', 'Unknown', 'Unknown', false, 'Unknown', 'Unknown', ptr);//`Pointer${Date.now()}_OfflineUser`);\r\n        console.log('User.load 5 off init', {d, cu:DUser.current, isOffline, '+':{allowOffline, allowOnline}})\r\n\r\n        if (d && isValid(d)){\r\n            Storage.write('user', d);\r\n            return d as DUser;\r\n        }\r\n        console.log('User.load failend', {d, cu:DUser.current, isOffline, '+':{allowOffline, allowOnline}})\r\n\r\n        return null;\r\n    }\r\n\r\n    static load(): DUser | null {\r\n        return DUser.offline(true, true);\r\n    }\r\n}\r\n\r\n@RuntimeAccessible('LUser')\r\nexport class LUser<Context extends LogicContext<DUser> = any, D extends DUser = DUser> extends LPointerTargetable {\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    public __raw!: DUser;\r\n    id!: Pointer<DUser>;\r\n    name!: string;\r\n    surname!: string;\r\n    nickname!: string;\r\n    country!: string;\r\n    affiliation!: string;\r\n    newsletter!: boolean;\r\n    email!: string;\r\n    token!: string;\r\n    projects!: LProject[];\r\n    project!: LProject|null;\r\n    __isUser!: true;\r\n\r\n    protected get_name(context: Context): this['name'] {\r\n        return context.data.name;\r\n    }\r\n    protected set_name(val: this['name'], c: Context): boolean {\r\n        TRANSACTION(this.get_name(c)+'.name', ()=>{\r\n            SetFieldAction.new(c.data.id, 'name', val, '', false);\r\n        }, undefined, val)\r\n        return true;\r\n    }\r\n\r\n    protected get_surname(context: Context): this['surname'] {\r\n        return context.data.surname;\r\n    }\r\n    protected set_surname(val: this['surname'], c: Context): boolean {\r\n        TRANSACTION(this.get_name(c)+'.surname', ()=>{\r\n            SetFieldAction.new(c.data.id, 'surname', val, '', false);\r\n        }, c.data.surname, val)\r\n        return true;\r\n    }\r\n\r\n    protected get_nickname(context: Context): this['nickname'] {\r\n        return context.data.nickname;\r\n    }\r\n    protected set_nickname(val: this['nickname'], c: Context): boolean {\r\n        TRANSACTION(this.get_name(c)+'.nickname', ()=>{\r\n            SetFieldAction.new(c.data.id, 'nickname', val, '', false);\r\n        }, c.data.nickname, val)\r\n        return true;\r\n    }\r\n\r\n    protected get_affiliation(context: Context): this['affiliation'] {\r\n        return context.data.affiliation;\r\n    }\r\n    protected set_affiliation(val: this['affiliation'], c: Context): boolean {\r\n        TRANSACTION(this.get_name(c)+'.affiliation', ()=>{\r\n            SetFieldAction.new(c.data.id, 'affiliation', val, '', false);\r\n        }, c.data.affiliation, val)\r\n        return true;\r\n    }\r\n\r\n    protected get_country(context: Context): this['country'] {\r\n        return context.data.country;\r\n    }\r\n    protected set_country(val: this['country'], c: Context): boolean {\r\n        TRANSACTION(this.get_name(c)+'.country', ()=>{\r\n            SetFieldAction.new(c.data.id, 'country', val, '', false);\r\n        }, c.data.country, val)\r\n        return true;\r\n    }\r\n\r\n    protected get_newsletter(context: Context): this['newsletter'] {\r\n        return context.data.newsletter;\r\n    }\r\n    protected set_newsletter(val: this['newsletter'], c: Context): boolean {\r\n        TRANSACTION(this.get_name(c)+'.newsletter', ()=>{\r\n            SetFieldAction.new(c.data.id, 'newsletter', val, '', false);\r\n        }, c.data.newsletter, val)\r\n        return true;\r\n    }\r\n\r\n    protected get_email(context: Context): this['email'] {\r\n        return context.data.email;\r\n    }\r\n    protected set_email(val: this['email'], c: Context): boolean {\r\n        TRANSACTION(this.get_name(c)+'.email', ()=>{\r\n            SetFieldAction.new(c.data.id, 'email', val, '', false);\r\n        }, c.data.email, val)\r\n        return true;\r\n    }\r\n\r\n    protected get_token(context: Context): this['token'] {\r\n        return context.data.token;\r\n    }\r\n    protected set_token(val: this['token'], c: Context): boolean {\r\n        TRANSACTION(this.get_name(c)+'.token', ()=>{\r\n            SetFieldAction.new(c.data.id, 'token', val, '', false);\r\n        }, c.data.token, val)\r\n        return true;\r\n    }\r\n\r\n    protected get_projects(context: Context): this['projects'] {\r\n        return (LProject.fromPointer(context.data.projects) as this['projects']).filter(p=>!!p);\r\n    }\r\n    protected set_projects(val: PackArr<this['projects']>, c: Context): boolean {\r\n        let ptrs = Pointers.from(val)||[];\r\n        TRANSACTION(this.get_name(c)+'.projects', ()=>{\r\n            SetFieldAction.new(c.data.id, 'projects', ptrs, '', true);\r\n        })\r\n        return true;\r\n    }\r\n\r\n    protected get_project(context: Context): this['project'] {\r\n        const project = context.data.project;\r\n        return project && LProject.fromPointer(project) || null;\r\n    }\r\n    protected set_project(val: Pack<Exclude<this['project'], null>>|null, c: Context): boolean {\r\n        let ptr: Pointer<LProject> = Pointers.from(val as any);\r\n        if (!ptr) ptr = '';\r\n        if (ptr === c.data.project) return true;\r\n\r\n        TRANSACTION(this.get_name(c)+'.project', ()=>{\r\n            SetFieldAction.new(c.data.id, 'project', ptr, '', true);\r\n        })\r\n        return true;\r\n    }\r\n}\r\n\r\nRuntimeAccessibleClass.set_extend(DPointerTargetable, DUser);\r\nRuntimeAccessibleClass.set_extend(LPointerTargetable, LUser);\r\nexport type WUser = getWParams<LUser, DUser>;\r\n\r\n@Leaf\r\n@RuntimeAccessible('DProject')\r\nexport class DProject extends DPointerTargetable {\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n\r\n    id!: Pointer<DProject, 1, 1, LProject>;\r\n    type: 'public'|'private'|'collaborative' = 'public';\r\n    name!: string;\r\n    author: Pointer<DUser> = DUser.current;\r\n    collaborators: Pointer<DUser, 0, 'N'> = [];\r\n    onlineUsers : number = 0;\r\n    metamodels: Pointer<DModel, 0, 'N'> = [];\r\n    models: Pointer<DModel, 0, 'N'> = [];\r\n    graphs: Pointer<DGraph, 0, 'N'> = [];\r\n    // views: Pointer<DViewElement, 0, 'N'> = []; // can be retrieved from viewpoints.subviews\r\n    // stackViews: Pointer<DViewPoint, 0, 'N'> = []; // ??\r\n    viewpoints: Pointer<DViewPoint, 0, 'N'> = [];\r\n    activeViewpoint: Pointer<DViewPoint, 1, 1> = Defaults.viewpoints[0];\r\n    favorite!: Dictionary<Pointer<DUser>, true | undefined>;\r\n\r\n    description!: string;\r\n    creation: number = Date.now();\r\n    lastModified: number = Date.now();\r\n    viewpointsNumber: number = 0;\r\n    metamodelsNumber: number = 0;\r\n    modelsNumber: number = 0;\r\n    isFavorite: boolean = false;\r\n\r\n    // collaborators dict user: priority\r\n\r\n    state!: string;\r\n\r\n    public static new(type: DProject['type'], name?: string, state?: DProject['state'],\r\n                      m2?: DProject['metamodels'], m1?: DProject['models'], id?: DProject['id'], otherProjects?:LProject[]): DProject {\r\n\r\n        // fix name\r\n        if (!otherProjects) otherProjects = LPointerTargetable.fromPointer(DUser.current).projects;\r\n        if (!name) {\r\n            // autofix default name\r\n            let regexp = /Project (\\d+)/;\r\n            const matches = otherProjects.map(p=>(+(regexp.exec(p.name)?.[1] as any) || 0));\r\n            let maxnum = Math.max(...matches, 0);\r\n            name = 'Project ' + (1 + maxnum);\r\n        }\r\n        else {\r\n            // autofix manually inputted name\r\n            let allProjectNames: Dictionary<string, LProject> = U.objectFromArray(otherProjects, (p)=>p.name);\r\n            name = U.increaseEndingNumber(name, false, false, (s)=>!!allProjectNames[s]);\r\n        }\r\n\r\n        return new Constructors(new DProject('dwc'), undefined, true, undefined)\r\n            .DPointerTargetable().DProject(type, name, state || '', m2 || [], m1 || [], id).end(); }\r\n}\r\n\r\n@RuntimeAccessible('LProject')\r\nexport class LProject<Context extends LogicContext<DProject> = any, D extends DProject = DProject> extends LPointerTargetable {\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n\r\n    readonly id!: Pointer<DProject>;\r\n    type!: 'public'|'private'|'collaborative';\r\n    author!: LUser;\r\n    collaborators!: LUser[];\r\n    onlineUsers!: number;\r\n    name!: string;\r\n    metamodels!: LModel[];\r\n    models!: LModel[];\r\n    graphs!: LGraph[];\r\n    // stackViews!: LViewElement[];\r\n    viewpoints!: LViewPoint[];\r\n    activeViewpoint!: LViewPoint;\r\n    favorite!: boolean;\r\n\r\n    description!: string;\r\n    creation!: number;\r\n    lastModified!: number;\r\n    viewpointsNumber!: number;\r\n    metamodelsNumber!: number;\r\n    modelsNumber!: number;\r\n    isFavorite!: boolean;\r\n\r\n    // stringify state\r\n    state!: string;\r\n\r\n    /* DATA */\r\n    readonly packages!: LPackage[];\r\n    readonly classes!: LClass[];\r\n    readonly attributes!: LAttribute[];\r\n    readonly references!: LReference[];\r\n    readonly operations!: LOperation[];\r\n    readonly parameters!: LParameter[];\r\n    readonly enumerators!: LEnumerator[];\r\n    readonly literals!: LEnumLiteral[];\r\n    readonly objects!: LObject[];\r\n    readonly values!: LValue[];\r\n\r\n    /* NODES */\r\n    readonly allNodes!: NodeTypes[];\r\n    readonly graphVertexes!: LGraphVertex[];\r\n    readonly voidVertexes!: LVoidVertex[];\r\n    readonly vertexes!: LVertex[];\r\n    readonly fields!: LGraphElement[];\r\n    readonly edges!: LEdge[];\r\n    readonly edgePoints!: LEdgePoint[];\r\n\r\n    /* UTILS */\r\n    readonly children!: LPointerTargetable[];\r\n    readonly views!: LViewElement[]; // derived from viewpoints.subView\r\n\r\n    /* Functions */\r\n\r\n    protected get_description(context: Context): this['description'] {\r\n        return context.data.description;\r\n    }\r\n    protected set_description(val: this['description'], c: Context): boolean {\r\n        TRANSACTION(this.get_name(c)+'.description', ()=>{\r\n            SetFieldAction.new(c.data.id, 'description', val, '', false);\r\n        }, c.data.description, val)\r\n        return true;\r\n    }\r\n\r\n    protected get_creation(context: Context): this['creation'] {\r\n        return context.data.creation;\r\n    }\r\n    protected set_creation(val: this['creation'], c: Context): boolean {\r\n        TRANSACTION(this.get_name(c)+'.creation', ()=>{\r\n            SetFieldAction.new(c.data.id, 'creation', val, '', false);\r\n        }, c.data.creation, val)\r\n        return true;\r\n    }\r\n\r\n    protected get_lastModified(context: Context): this['lastModified'] {\r\n        return context.data.lastModified;\r\n    }\r\n    protected set_lastModified(val: this['lastModified'], c: Context): boolean {\r\n        TRANSACTION(this.get_name(c)+'.lastModified', ()=>{\r\n            SetFieldAction.new(c.data.id, 'lastModified', val, '', false);\r\n        }, c.data.lastModified, val)\r\n        return true;\r\n    }\r\n\r\n    protected get_viewpointsNumber(c: Context): this['viewpointsNumber'] {\r\n        return c.data.viewpointsNumber;\r\n    }\r\n    protected set_viewpointsNumber(val: this['viewpointsNumber'], c: Context): boolean {\r\n        TRANSACTION(this.get_name(c)+'.viewpointsNumber', ()=>{\r\n            SetFieldAction.new(c.data.id, 'viewpointsNumber', val, '', false);\r\n        }, c.data.viewpointsNumber, val)\r\n        return true;\r\n    }\r\n\r\n    protected get_metamodelsNumber(c: Context): this['metamodelsNumber'] {\r\n        return c.data.metamodelsNumber;\r\n    }\r\n    protected set_metamodelsNumber(val: this['metamodelsNumber'], c: Context): boolean {\r\n        TRANSACTION(this.get_name(c)+'.metamodelsNumber', ()=>{\r\n            SetFieldAction.new(c.data.id, 'metamodelsNumber', val, '', false);\r\n        }, c.data.metamodelsNumber, val)\r\n        return true;\r\n    }\r\n\r\n    protected get_modelsNumber(context: Context): this['modelsNumber'] {\r\n        return context.data.modelsNumber;\r\n    }\r\n    protected set_modelsNumber(val: this['modelsNumber'], c: Context): boolean {\r\n        TRANSACTION(this.get_name(c)+'.modelsNumber', ()=>{\r\n            SetFieldAction.new(c.data.id, 'modelsNumber', val, '', false);\r\n        }, c.data.modelsNumber, val)\r\n        return true;\r\n    }\r\n\r\n    protected get_isFavorite(context: Context): this['isFavorite'] {\r\n        return context.data.isFavorite;\r\n    }\r\n    protected set_isFavorite(val: this['isFavorite'], context: Context): boolean {\r\n        const data = context.data;\r\n        return SetFieldAction.new(data.id, 'isFavorite', val, '', false);\r\n    }\r\n\r\n    protected get_favorite(c: Context): this['favorite'] {\r\n        const uid = DUser.current;\r\n        if (!c.data.favorite) return false;\r\n        return !!c.data.favorite[uid];\r\n    }\r\n    protected set_favorite(v: boolean, c: Context): true {\r\n        let favMap = c.data.favorite;\r\n        const uid = DUser.current;\r\n        v = !!v;\r\n        if (!v && !favMap || v === favMap[uid]) return true;\r\n        TRANSACTION(this.get_name(c)+'.favorite', ()=>{\r\n            SetFieldAction.new(c.data.id, 'favorite', {[uid]: v ? true : undefined}, v ? '+=' : '-='); //!favMap ? '' : (v ? '+=' : '-=');\r\n        }, !!favMap?.[uid], v)\r\n        return true;\r\n    }\r\n    protected get_name(context: Context): this['name'] {\r\n        return context.data.name;\r\n    }\r\n    protected set_name(val: this['name'], c: Context): boolean {\r\n        if (c.data.name === val) return true;\r\n        TRANSACTION(this.get_name(c)+'.name', ()=>{\r\n            SetFieldAction.new(c.data.id, 'name', val, '', false);\r\n        }, undefined, val)\r\n        return true;\r\n    }\r\n\r\n    protected get_author(context: Context): this['author'] {\r\n        return LUser.fromPointer(context.data.author);\r\n    }\r\n    protected set_author(val0: Pack<this['author']>, c: Context): boolean {\r\n        let val: Pointer<LUser> = Pointers.from(val0) as any;\r\n        TRANSACTION(this.get_name(c)+'.author', ()=> {\r\n            SetFieldAction.new(c.data.id, 'author', val, '', true);\r\n        })\r\n        return true;\r\n    }\r\n\r\n    public get_state(context: Context): this['state'] {\r\n        return context.data.state;\r\n    }\r\n    public set_state(val: this['state'], c: Context): boolean {\r\n        TRANSACTION(this.get_name(c)+'.state', ()=>{\r\n            SetFieldAction.new(c.data.id, 'state', val, '', false);\r\n        })\r\n        return true;\r\n    }\r\n\r\n    protected get_collaborators(context: Context): this['collaborators'] {\r\n        return LUser.fromPointer(context.data.collaborators) || [];\r\n    }\r\n    protected set_collaborators(val0: PackArr<this['collaborators']>, c: Context): boolean {\r\n        let val: Pointer<LUser> = Pointers.from(val0) as any;\r\n        TRANSACTION(this.get_name(c)+'.collaborators', ()=>{\r\n            SetFieldAction.new(c.data.id, 'collaborators', val, '', true);\r\n        })\r\n        return true;\r\n    }\r\n\r\n    protected get_onlineUsers(context: Context): this['onlineUsers'] {\r\n        return context.data.onlineUsers;\r\n    }\r\n    protected set_onlineUsers(val: this['onlineUsers'], c: Context): boolean {\r\n        TRANSACTION(this.get_name(c)+'.onlineUsers', ()=>{\r\n            SetFieldAction.new(c.data.id, 'onlineUsers', val, '', false);\r\n        }, c.data.onlineUsers, val)\r\n        return true;\r\n    }\r\n\r\n    protected get_metamodels(context: Context): this['metamodels'] {\r\n        return LModel.fromPointer(context.data.metamodels) || [];\r\n    }\r\n    protected set_metamodels(val0: PackArr<this['metamodels']>, c: Context): boolean {\r\n        let val = Pointers.from(val0);\r\n        TRANSACTION(this.get_name(c)+'.metamodels', ()=>{\r\n            SetFieldAction.new(c.data.id, 'metamodels', val, '', true);\r\n        })\r\n        return true;\r\n    }\r\n\r\n    protected get_models(context: Context): this['models'] {\r\n        return LModel.fromPointer(context.data.models) || [];\r\n    }\r\n    protected set_models(val0: PackArr<this['models']>, c: Context): boolean {\r\n        let val = Pointers.from(val0);\r\n        TRANSACTION(this.get_name(c)+'.models', ()=>{\r\n            SetFieldAction.new(c.data.id, 'models', val, '', true);\r\n        })\r\n        return true;\r\n    }\r\n\r\n    protected get_graphs(context: Context): this['graphs'] {\r\n        return LGraph.fromPointer(context.data.graphs) || [];\r\n    }\r\n    protected set_graphs(val0: PackArr<this['graphs']>, c: Context): boolean {\r\n        let val = Pointers.from(val0);\r\n        TRANSACTION(this.get_name(c)+'.graphs', ()=>{\r\n            SetFieldAction.new(c.data.id, 'graphs', val, '', true);\r\n        })\r\n        return true;\r\n    }\r\n\r\n    protected get_views(c: Context): this['views'] {\r\n        // return LViewElement.fromPointer([...c.data.views, ...Defaults.views]);\r\n        let duplicateRemover: Dictionary<Pointer, LViewElement> = {};\r\n        let varr = this.get_viewpoints(c).flatMap(vp => vp.allSubViews);\r\n        for (let v of varr) duplicateRemover[v.id] = v;\r\n        return Object.values(duplicateRemover);\r\n    }\r\n\r\n    protected set_views(val: PackArr<this['views']>, context: Context): boolean {\r\n        return Log.exx(\"cannot set project.views, set them as subviews of a project viewpoint.\");\r\n        /*\r\n        const data = context.data;\r\n        let ptrs = Pointers.from(val);\r\n        let defaultViewsMap: Dictionary<Pointer, boolean> = U.objectFromArrayValues(Defaults.views);\r\n        ptrs = ptrs.filter(ptr => !defaultViewsMap[ptr]);\r\n        SetFieldAction.new(data.id, 'views', ptrs, '', true);\r\n        return true;*/\r\n    }\r\n    /*\r\n        protected get_stackViews(context: Context): this['stackViews'] {\r\n            return LViewElement.fromPointer(context.data.stackViews || []);\r\n        }\r\n        protected set_stackViews(val: PackArr<this['stackViews']>, context: Context): boolean {\r\n            const data = context.data;\r\n            SetFieldAction.new(data.id, 'stackViews', Pointers.from(val), '', true);\r\n            return true;\r\n        }*/\r\n\r\n    protected get_viewpoints(context: Context): this['viewpoints'] {\r\n        return LViewPoint.fromPointer([...Defaults.viewpoints, ...(context.data.viewpoints || [])]);\r\n    }\r\n    protected set_viewpoints(val0: PackArr<this['viewpoints']>, c: Context): boolean {\r\n        let val = Pointers.from(val0);\r\n        TRANSACTION(this.get_name(c)+'.viewpoints', ()=>{\r\n            SetFieldAction.new(c.data.id, 'viewpoints', val, '', true);\r\n        })\r\n        return true;\r\n    }\r\n\r\n    protected get_activeViewpoint(context: Context): this['activeViewpoint'] {\r\n        return LViewPoint.fromPointer(context.data.activeViewpoint || Defaults.viewpoints[0]);\r\n    }\r\n    protected set_activeViewpoint(val0: Pack1<this['activeViewpoint']>, c: Context): boolean {\r\n        let val = Pointers.from(val0);\r\n        TRANSACTION(this.get_name(c)+'.activeViewpoint', ()=>{\r\n            SetFieldAction.new(c.data.id, 'activeViewpoint', val, '', true);\r\n        })\r\n        return true;\r\n    }\r\n\r\n    /* DATA Getter */\r\n    protected get_packages(c: Context): this['packages'] {\r\n        const data = c.proxyObject as LProject;\r\n        return data.metamodels.flatMap(m => m.allSubPackages);\r\n    }\r\n    protected get_classes(context: Context): this['classes'] {\r\n        const data = context.proxyObject as LProject;\r\n        return data.packages.flatMap(p => p.classes);\r\n    }\r\n    protected get_attributes(context: Context): this['attributes'] {\r\n        const data = context.proxyObject as LProject;\r\n        return data.classes.flatMap(c => c.attributes);\r\n    }\r\n    protected get_references(context: Context): this['references'] {\r\n        const data = context.proxyObject as LProject;\r\n        return data.classes.flatMap(c => c.references);\r\n    }\r\n    protected get_operations(context: Context): this['operations'] {\r\n        const data = context.proxyObject as LProject;\r\n        return data.classes.flatMap(c => c.operations);\r\n    }\r\n    protected get_parameters(context: Context): this['parameters'] {\r\n        const data = context.proxyObject as LProject;\r\n        return data.operations.flatMap(o => o.parameters);\r\n    }\r\n    protected get_enumerators(context: Context): this['enumerators'] {\r\n        const data = context.proxyObject as LProject;\r\n        return data.packages.flatMap(p => p.enumerators);\r\n    }\r\n    protected get_literals(context: Context): this['literals'] {\r\n        const data = context.proxyObject as LProject;\r\n        return data.enumerators.flatMap(e => e.literals);\r\n    }\r\n    protected get_objects(context: Context): this['objects'] {\r\n        const data = context.proxyObject as LProject;\r\n        return data.models.flatMap(m => m.allSubObjects);\r\n    }\r\n    protected get_values(context: Context): this['values'] {\r\n        const data = context.proxyObject as LProject;\r\n        return data.models.flatMap(m => m.allSubValues);\r\n    }\r\n\r\n    /* NODES Getter */\r\n    protected get_allNodes(context: Context): this['allNodes'] {\r\n        const data = context.proxyObject as LProject;\r\n        const nodes: NodeTypes[] = [];\r\n        // nodes.push(...(data.metamodels.flatMap(m => m.node).filter(n => n !== undefined) as NodeTypes[]));\r\n        nodes.push(...(data.packages.flatMap(m => m.node).filter(n => n !== undefined) as NodeTypes[]));\r\n        nodes.push(...(data.classes.flatMap(m => m.node).filter(n => n !== undefined) as NodeTypes[]));\r\n        nodes.push(...(data.attributes.flatMap(m => m.node).filter(n => n !== undefined) as NodeTypes[]));\r\n        nodes.push(...(data.references.flatMap(m => m.node).filter(n => n !== undefined) as NodeTypes[]));\r\n        nodes.push(...(data.operations.flatMap(m => m.node).filter(n => n !== undefined) as NodeTypes[]));\r\n        nodes.push(...(data.parameters.flatMap(m => m.node).filter(n => n !== undefined) as NodeTypes[]));\r\n        nodes.push(...(data.enumerators.flatMap(m => m.node).filter(n => n !== undefined) as NodeTypes[]));\r\n        nodes.push(...(data.literals.flatMap(m => m.node).filter(n => n !== undefined) as NodeTypes[]));\r\n        // nodes.push(...(data.models.flatMap(m => m.node).filter(n => n !== undefined) as NodeTypes[]));\r\n        nodes.push(...(data.objects.flatMap(m => m.node).filter(n => n !== undefined) as NodeTypes[]));\r\n        nodes.push(...(data.values.flatMap(m => m.node).filter(n => n !== undefined) as NodeTypes[]));\r\n        return nodes;\r\n    }\r\n    protected get_graphVertexes(context: Context): this['graphVertexes'] {\r\n        const data = context.proxyObject as LProject;\r\n        return data.allNodes.filter(n => n.className === 'DGraphVertex') as LGraphVertex[];\r\n    }\r\n    protected get_voidVertexes(context: Context): this['voidVertexes'] {\r\n        const data = context.proxyObject as LProject;\r\n        return data.allNodes.filter(n => n.className === 'DVoidVertex') as LVoidVertex[];\r\n    }\r\n    protected get_vertexes(context: Context): this['vertexes'] {\r\n        const data = context.proxyObject as LProject;\r\n        return data.allNodes.filter(n => n.className === 'DVertex') as LVertex[];\r\n    }\r\n    protected get_fields(context: Context): this['fields'] {\r\n        const data = context.proxyObject as LProject;\r\n        return data.allNodes.filter(n => n.className === 'DGraphElement') as LGraphElement[];\r\n    }\r\n    protected get_edges(context: Context): this['edges'] {\r\n        const data = context.proxyObject as LProject;\r\n        return data.graphs.flatMap(g => g.subElements.filter(e => e.className === 'DEdge')) as LEdge[];\r\n    }\r\n    protected get_edgePoints(context: Context): this['edgePoints'] {\r\n        const data = context.proxyObject as LProject;\r\n        return data.edges.flatMap(e => e.subElements) as LEdgePoint[];\r\n    }\r\n\r\n    /* CUSTOM Functions */\r\n    protected get_children(context: Context): this['children'] {\r\n        const data = context.proxyObject as LProject;\r\n        return [\r\n            /* Data */\r\n            ...data.metamodels,\r\n            ...data.packages,\r\n            ...data.classes,\r\n            ...data.attributes,\r\n            ...data.references,\r\n            ...data.operations,\r\n            ...data.parameters,\r\n            ...data.enumerators,\r\n            ...data.literals,\r\n            ...data.models,\r\n            ...data.objects,\r\n            ...data.values,\r\n            /* Views & Viewpoints */\r\n            ...data.views.filter(v => v && !Defaults.views.includes(v.id)),\r\n            ...data.viewpoints.filter(vp => vp && !Defaults.viewpoints.includes(vp.id)),\r\n            /* Nodes */\r\n            ...data.allNodes\r\n        ];\r\n    }\r\n\r\n    /*\r\n        public pushToStackViews(view: Pack<LViewElement>): void {\r\n            throw new Error('cannot be called directly, should trigger getter. this is only for correct signature');\r\n        }\r\n        protected get_pushToStackViews(context: Context): (view: Pack<LViewElement>) => void {\r\n            return (view) => {\r\n                const data = context.data;\r\n                SetFieldAction.new(data.id, 'stackViews', Pointers.from(view), ', true);\r\n            }\r\n        }\r\n    /*\r\n        public popFromStackViews(): void {\r\n            throw new Error('cannot be called directly, should trigger getter. this is only for correct signature');\r\n        }\r\n        protected get_popFromStackViews(context: Context): () => void {\r\n            return () => {\r\n                const data = context.data;\r\n                const view = data.stackViews?.at(-1);\r\n                if(!view) return;\r\n                SetFieldAction.new(data.id, 'stackViews', view as any, '-=', true);\r\n            }\r\n        }\r\n    */\r\n    public delete(): void {\r\n        throw new Error('cannot be called directly, should trigger getter. this is only for correct signature');\r\n    }\r\n    protected get_delete(c: Context): () => void {\r\n        const data = c.proxyObject as LProject;\r\n        return () => {\r\n            TRANSACTION('delete ' + this.get_name(c), ()=> {\r\n                SetFieldAction.new(DUser.current, 'projects', c.data.id as any, '-=', true);\r\n                DeleteElementAction.new(data.id);\r\n                SetRootFieldAction.new('projects', c.data.id, '-=', true);\r\n\r\n                // project can only be deleted in homepage, project list is not even present in editor state.\r\n                // if (windoww.location.hasg.includes('project') windoww.location.href = windoww.location.origin; use R.navigate\r\n            });\r\n        }\r\n    }\r\n\r\n    duplicate(): LProject{ return this.wrongAccessMessage('LProject.duplicate()')};\r\n    get_duplicate(c: Context): ()=>LProject{\r\n        return () => {\r\n            let clone: DProject = DProject.new(c.data.type, c.data.name + ' Copy');\r\n            for (let key in c.data){\r\n                switch (key){\r\n                    case 'id':\r\n                    case 'pointedBy':\r\n                    case 'name':\r\n                        continue;\r\n                    default:\r\n                        // @ts-ignore\r\n                        clone[key] = c.data[key];\r\n                        break;\r\n            }\r\n        }\r\n        clone.author = DUser.current;\r\n        clone.onlineUsers = 0;// i think this should not be a presistent data, but a fake attribute available only on LProject\r\n        // todo per giordano: assign project to user & set persistent stuff with ProjectsAPI ?\r\n        return LPointerTargetable.fromD(clone); }\r\n    }\r\n}\r\n\r\nRuntimeAccessibleClass.set_extend(DPointerTargetable, DProject);\r\nRuntimeAccessibleClass.set_extend(LPointerTargetable, LProject);\r\nexport type WProject = getWParams<LProject, DProject>;\r\n\r\n\r\n@RuntimeAccessible('MyError')\r\nexport class MyError extends Error {\r\n    constructor(message?: string, ...otherMsg: any[]) {\r\n        // 'Error' breaks prototype chain here\r\n        super(message);\r\n        const proto = (this as any).__proto__;\r\n\r\n        console.error(proto.constructor.cname || proto.constructor.name, message, ...otherMsg);\r\n        // restore prototype chain\r\n        const actualProto = new.target.prototype;\r\n\r\n        if (Object.setPrototypeOf) { Object.setPrototypeOf(this, actualProto); }\r\n        else { (this as any).__proto__ = actualProto; }\r\n        (this as any).className = (this.constructor as typeof RuntimeAccessibleClass).cname;\r\n    }\r\n}\r\n\r\n// @RuntimeAccessible\r\nexport class JsType{\r\n    public static all: JsType[] = [];\r\n    public static object: JsType = new JsType(\"object\", JsType.isObject, false);\r\n    public static function: JsType = new JsType(\"function\", JsType.isFunction, false);\r\n    public static array: JsType = new JsType(\"array\", JsType.isArray, false);\r\n    public static date: JsType = new JsType(\"Date\", JsType.isDate, false);\r\n\r\n    public static lambdaFunction: JsType = new JsType(\"lambda-function\", JsType.isLambdaFunction, true);\r\n    public static nonLambdaFunction: JsType = new JsType(\"non-lambda-function\", JsType.isNonLambdaFunction, true);\r\n    public static symbol: JsType = new JsType(\"symbol\", JsType.isSymbol, true);\r\n    public static undefined: JsType = new JsType(\"undefined\", JsType.isUndefined, true);\r\n    public static null: JsType = new JsType(\"null\", JsType.isNull, true);\r\n    public static boolean: JsType = new JsType(\"boolean\", JsType.isBoolean, true);\r\n    public static number: JsType = new JsType(\"number\", JsType.isNumber, true);\r\n    public static bigint: JsType = new JsType(\"bigint\", JsType.isBigint, true);\r\n    public static string: JsType = new JsType(\"string\", JsType.isString, true);\r\n\r\n    private constructor(public printableTypeName: string, public check: (data: any) => boolean, public isExclusiveType: boolean){\r\n        JsType.all.push(this);\r\n    }\r\n    public toString(): string { return this.printableTypeName; }\r\n    /*\r\n    * example: isObject but not Date, not function...\r\n    * */\r\n    public static isOnlyType(data: any, type: JsType): boolean { return !JsType.getTypes(data, type).length; }\r\n    public static isAnyOfTypes(data: any, ...acceptables: JsType[]): boolean { return !!windoww.Uarr.arrayIntersection(JsType.getTypes(data), acceptables).length; }\r\n    public static getTypes(data: any, stopIfTypeIsNot?: JsType): JsType[]{\r\n        const ret: JsType[] = [];\r\n        for (const type of JsType.all) {\r\n            if (type.check(data)) {\r\n                ret.push(data);\r\n                if (stopIfTypeIsNot !== type) { return []; }\r\n                if (type.isExclusiveType) return ret;\r\n            }\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    /// is...\r\n    public static isObject(data: GObject | any, returnIfNull: boolean = false): boolean { return data === null ? returnIfNull : typeof data === \"object\"; }\r\n    public static isFunction(data: Function | any): boolean { return typeof data === \"function\"; }\r\n    public static isLambdaFunction(data: Function | any): boolean {\r\n        if (!JsType.isFunction(data)) return false;\r\n        return windoww.U.getFunctionSignatureFromComments(data).isLambda; }\r\n    public static isNonLambdaFunction(data: Function | any): boolean { return JsType.isFunction(data) && !JsType.isNonLambdaFunction(data); }\r\n    public static isArray(data: Array<any> | any): boolean { return Array.isArray(data); }\r\n    public static isSymbol(data: symbol | any): boolean { return typeof data === \"symbol\"; }\r\n    public static isBoolean(data: symbol | any): boolean { return !!data === data; }\r\n    public static isNumber(data: number | any): boolean { return typeof data === \"number\"; }\r\n    public static isBigint(data: bigint | any): boolean { return typeof data === \"bigint\"; }\r\n    public static isString(data: string | any): boolean { return typeof data === \"string\"; }\r\n    public static isNull(data: null | any): boolean { return data === null; }\r\n    public static isUndefined(data: undefined | any): boolean { return data === undefined; }\r\n    public static isDate(data: Date | any): boolean { return data instanceof Date; }\r\n\r\n    /// as...\r\n    public static asObject<T>(data: GObject | any, fallbackReturn: T): T | GObject { return JsType.isObject(data) ? data : fallbackReturn; }\r\n    public static asFunction<T>(data: Function | any, fallbackReturn: T): T | Function { return JsType.isFunction(data) ? data : fallbackReturn; }\r\n    public static asLambdaFunction<T>(data: Function | any, fallbackReturn: T): T | Function { return JsType.isLambdaFunction(data) ? data : fallbackReturn; }\r\n    public static asNonLambdaFunction<T>(data: Function | any, fallbackReturn: T): T | Function { return JsType.isNonLambdaFunction(data) ? data : fallbackReturn; }\r\n    public static asArray<T, A>(data: Array<A> | any, fallbackReturn: T): T | Array<A> { return JsType.isArray(data) ? data : fallbackReturn; }\r\n    public static asSymbol<T>(data: symbol | any, fallbackReturn: T): T | symbol { return JsType.isSymbol(data) ? data : fallbackReturn; }\r\n    public static asBoolean<T>(data: boolean | any, fallbackReturn: T): T | boolean { return JsType.isBoolean(data) ? data : fallbackReturn; }\r\n    public static asNumber<T>(data: number | any, fallbackReturn: T): T | number { return JsType.isNumber(data) ? data : fallbackReturn; }\r\n    public static asBigint<T>(data: bigint | any, fallbackReturn: T): T | bigint { return JsType.isBigint(data) ? data : fallbackReturn; }\r\n    public static asString<T>(data: string | any, fallbackReturn: T): T | string { return JsType.isString(data) ? data : fallbackReturn; }\r\n    public static asNull<T>(data: null | any, fallbackReturn: T): T | null { return JsType.isNull(data) ? data : fallbackReturn; }\r\n    public static asUndefined<T>(data: undefined | any, fallbackReturn: T): T | undefined { return JsType.isUndefined(data) ? data : fallbackReturn; }\r\n    public static asDate<T>(data: Date | any, fallbackReturn: T): T | Date { return JsType.isDate(data) ? data : fallbackReturn; }\r\n    public static isPrimitive(data: any) { return !JsType.isAnyOfTypes(data, JsType.object, JsType.function, JsType.array); }\r\n}\r\n\r\n\r\nfunction invalidSuperClassError(/*callee: Class,*/ scname: string, superclass: Class): (() => never) {\r\n    return () => { windoww.Log.exDevv('parent super class \"' + scname + '\" is not implementing init_constructor', {scname, superclass, }); throw new Error(); }\r\n}\r\n// @ts-ignore\r\nfunction MixinFakeConstructor() { this.isMixinFakeConstructor = true; }\r\nexport function MixOnlyFuncs2<A1 extends any[], I1, S1, A2 extends any[], I2, S2>(c1: Class<A1, I1, S1> & typeof RuntimeAccessibleClass, c2: Class<A2, I2, S2> & typeof RuntimeAccessibleClass):\r\n    Class<A1, I1, S1> & Class<A2, I2, S2>{\r\n    return MixOnlyFuncs(c1, c2) as any;\r\n}\r\nexport function MixOnlyFuncs3<A1 extends any[], I1, S1, A2 extends any[], I2, S2>(c1: Class<A1, I1, S1> & typeof RuntimeAccessibleClass, c2: Class<A2, I2, S2> & typeof RuntimeAccessibleClass):\r\n    Class<A1&A2, I1&I2, S1&S2>{\r\n    return MixOnlyFuncs(c1, c2) as any;\r\n}\r\nexport function MixOnlyFuncs<A1 extends any[], I1, S1, A2 extends any[], I2, S2>(c1: Class<A1, I1, S1> & typeof RuntimeAccessibleClass, c2: Class<A2, I2, S2> & typeof RuntimeAccessibleClass):\r\n    CClass<Longest<A1, A2>, I1 & I2\r\n        & {\r\n        // superclass: Dictionary<string, (/*thiss: I1 & I2,* / ...superConstructorParams:ConstructorParameters<Class<A1, I1, S1>> | ConstructorParameters<Class<A2, I2, S2>>) => void>,\r\n        superclass1: Dictionary<DocString<'constructor name to make sure the user knows what superclass constructor is calling'>,  (...superConstructor1Params:ConstructorParameters<Class<A1, I1, S1>>) => void>,\r\n        superclass2: Dictionary<DocString<'constructor name to make sure the user knows what superclass constructor is calling'>,  (...superConstructor2Params:ConstructorParameters<Class<A2, I2, S2>>) => void>,\r\n        // initt: Class<A1, I1, S1>\r\n    } & AbstractMixedClass\r\n        // , Omit<Omit<Omit<S1 & S2, 'init_constructor'>, 'logic'>, 'maxID'> & typeof AbstractMixedClass> {\r\n        , S1 & S2 & GObject & typeof AbstractMixedClass> {\r\n    // strategia: passo dei finti valori che copiano i prototipi delle classi sovrascrivendo i costruttori per evitare che chiami i costruttori delle superclassi\r\n    // ma che comunque erediti campi e funzioni\r\n    // @ts-ignore\r\n    let c1noconstructor: any = MixinFakeConstructor;\r\n    let c2noconstructor: any = MixinFakeConstructor;\r\n    c1noconstructor.prototype = c1.prototype;\r\n    c2noconstructor.prototype = c2.prototype;\r\n\r\n    let disableconstructor = false;\r\n    if (!disableconstructor) {\r\n        c1noconstructor = c1;\r\n        c2noconstructor = c2; }\r\n\r\n\r\n    let ret = Mixin(c1noconstructor, c2noconstructor);\r\n    let c1name = (c1.cname || c1.name) === 'classnameFixedConstructorDoNotRenameWithoutSearchStrings' ? c1.prototype.className : c1.cname || c1.name;\r\n    let c2name = (c2.cname || c2.name) === 'classnameFixedConstructorDoNotRenameWithoutSearchStrings' ? c2.prototype.className : c2.cname || c2.name;\r\n    //ret.prototype['superclass'] = {};\r\n    // ret.prototype['superclass'][c1name] = c1.prototype.init_constructor || invalidSuperClassError(c1name, c1);\r\n    // ret.prototype['superclass'][c2name] = c2.init_constructor || invalidSuperClassError(c2name, c2);\r\n    ret.prototype['superclass1'] = {};\r\n    ret.prototype['superclass2'] = {};\r\n    ret.prototype['superclass1'][c1name] = c1.init_constructor || invalidSuperClassError(c1name, c1);\r\n    ret.prototype['superclass2'][c2name] = c2.init_constructor || invalidSuperClassError(c2name, c2);\r\n    return ret;\r\n}\r\n// console.info('ts loaded classes');\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n//*********************************************************************************************\r\n//*********************************************************************************************\r\n///////                              type juggling starts here                          ///////\r\n//*********************************************************************************************\r\n//*********************************************************************************************\r\n\r\n// export type NotAString<T extends any = 'uselessval'> = Omit<string, 'bold'> & {big: T};\r\n// export type NotAString<T extends any = 'uselessval'> = Omit<string, 'bold'>;\r\n// export type NotAString<T extends any = 'uselessval', T2 extends any = any, T3 extends any = any, T4 extends any = any> = string & Omit<string, 'bold'> & {bold: ()=>string};\r\nexport type NotAString<T extends any = 'uselessval', T2 extends any = any, T3 extends any = any, T4 extends any = any> = string & Omit<string, 'bold'> & {bolda?: T};\r\n// export type NotAString<T> = string;\r\n// type Pointer<T> = NotAString<T>;\r\nexport type Pointer<T extends DPointerTargetable = DPointerTargetable, lowerbound extends number = 1, upperbound extends number|'N' = 1,\r\n    RET extends LPointerTargetable = DtoL<T>> =\r\n    upperbound extends 'N' ? NotAString<T, lowerbound, upperbound, RET>[] : (\r\n        upperbound extends 0 ? never : (\r\n            lowerbound extends 0 ? (NotAString<T, lowerbound, upperbound, RET> | null) : NotAString<T, upperbound, lowerbound, RET>));\r\n\r\n\r\nexport type PtrString = any; // to convert Pointers to strings more explicitly then using as any\r\n// let ptr: Pointer<Object> = null as any;\r\n/*\r\nclass D extends DPointerTargetable{\r\n    parent!: Pointer<D>;\r\n    dattrib!: boolean;\r\n    juststring!: string;\r\n    nattrib!: number;\r\n    ddattrib!: Date\r\n}\r\n\r\nclass D2 extends D{\r\n    d2!: string;\r\n}\r\nclass D3 extends D{\r\n    d3!: string;\r\n}\r\n\r\n\r\n\r\ntype OverrideTypes<M, N> = { [P in keyof M]: P extends keyof N ? N[P] : M[P] }; // usage:  OverrideTypes<A, { x: number }>;\r\n\r\ninterface LFix {\r\n    parent: L;\r\n}\r\ninterface L { // no instances ever\r\n    parent: L;\r\n    lattrib: boolean;\r\n}\r\ninterface L2 extends L { // no instances ever\r\n    l2: string;\r\n}\r\ninterface L3 extends L{ // no instances ever\r\n    l3: string;\r\n}\r\n\r\nclass P { // singleton\r\n    get_parent(){}\r\n    set_parent(){}\r\n}\r\nclass P2 extends P { // singleton\r\n    get_d2() {}\r\n}\r\nclass P3 extends P { // singleton\r\n    get_d3() {}\r\n}*/\r\n\r\ntype ERROR = \"_TYPE_ERROR_\";\r\n// RegExp extends Animal ? number : string\r\n\r\n\r\nfunction buildWrapSignature(maxdepth = 100) {\r\n    let arr = windoww[\"DPointerTargetable\"].subclasses;\r\n    /*\r\n    let dict0 = arr.reduce((a, v) => ({ ...a, [v.name]: v}), {});\r\n    let dict = {}\r\n    for (let name in dict0) { let n = name.substring(1); dict[n] = {\"D\":dict0[\"D\"+n], \"L\":dict0[\"L\"+n]}; dict[\"D\"+n] = dict0[\"L\"+n]; dict[\"L\"+n] = dict0[\"D\"+n]; }\r\n    console.log(\"dict\", dict);\r\n    console.table(dict);\r\n    */\r\n    function onlyUnique(value: any, index: number, self: any) { return self.indexOf(value) === index; }\r\n\r\n    let dep = arr; // .map( (me) => { return {\"name\": me.name, \"me\": me, \"Derror\": (dict[me.name] || me).name, \"Lerror\": (dict[me.name] || me).name, \"subclasses\": [...me.subclasses]}});\r\n    let depsorted = [];\r\n\r\n    let byLevels = [];\r\n    let loopdetecter: any[] = [arr];\r\n    while (dep.length && maxdepth--) {\r\n        let namelist = dep.map((e: any) => e.name).filter(onlyUnique);\r\n        depsorted.push(...namelist);\r\n        byLevels.push([...namelist]);\r\n        let olddep = dep;\r\n        dep = dep.flatMap((d: any) => d.subclasses).filter(onlyUnique);\r\n        for (let d of dep) {\r\n            windoww.loopdetecter = loopdetecter;\r\n            windoww.dep = dep;\r\n            windoww.olddep = olddep;\r\n            windoww.byLevels = byLevels;\r\n            windoww.d = d;\r\n            if ( loopdetecter.includes(d.subclasses) ) throw new Error(\"class is not redefining subclasses static array: \" + d.name);\r\n            loopdetecter.push(d.subclasses);\r\n        }\r\n    }\r\n    console.log(\"byLevels\");\r\n    console.table(byLevels);\r\n\r\n    console.log(\"depsorted\", depsorted);\r\n\r\n    // console.log(\"map\");\r\n    // console.table(depsorted.map(dn => {let d = window[dn]; return !d ? \"\" :{name:d.name, scount: d.subclasses.length, subclasses:d.subclasses}}));\r\n\r\n\r\n    let goalSignature = \"function wrap<DX extends D, LX = DX extends D2 ? L2: (DX extends D3 ? L3: (DX extends D ? L : ERROR))>(data: DX): LX {\";\r\n    let lparam = \"ERROR\";\r\n    let epsorted = depsorted.map( e => e.substring(1)).filter(onlyUnique);\r\n    console.table(epsorted)\r\n    for (let e of epsorted) {\r\n        let D = \"D\" + e;\r\n        let L = \"L\" + e;\r\n        lparam = \"DX extends \" + D + \" ? \"  + L + \" : (\" + (lparam) + \")\";\r\n    }\r\n    let signature = \"function wrap<DX extends DPointerTargetable, LX = \" + lparam + \">(data: DX): LX {\";\r\n    return signature;\r\n}\r\nwindoww.buildWrapSignature = buildWrapSignature;\r\n// function wrap<DX extends D, LX = DX extends D2 ? L2: (DX extends D3 ? L3: (DX extends D ? L : ERROR))>(data: DX): LX {\r\n\r\n/*\r\n* NO    L -> D    /// l.__raw\r\n* NO    L -> Ptr  /// l.id\r\n*\r\n* NO    D -> Ptr   // d.id\r\n* YES   D -> L     // wrap\r\n*\r\n* NO    Ptr -> D\r\n* NO    Ptr -> L\r\n*\r\n*\r\n*\r\n*\r\n* DpointerTargetable.from( L or pointer )\r\n* LpointerTargetable.from( D or pointer )\r\n*\r\n* MyProxyHandler.wrap = LpointerTargetable.from;\r\n*\r\n* DpointerTargetable.toPointer( d );\r\n*\r\n\r\ntype subtractDL = subtract<D, L>;\r\n* */\r\n\r\n\r\n\r\ntype subtract<P, C> = { [F in keyof P]: keyof C extends undefined ? undefined : P[F] };\r\ntype Exclude3<T, U> = T & {[T in keyof U]: never};\r\ntype Override<A, B> = Omit<A, keyof B> & B; //////////////////////////////////////////// best solution so far\r\n\r\ntype Exclude2<Type, field> = {\r\n    [Property in keyof Type as Exclude<Property, keyof field>]: Type[Property]      /////////////////////////equally best solution\r\n};\r\n\r\n\r\ntype OnlyKeysOfTypeTmp<T, IncludeType> = ({[P in keyof T]: T[P] extends IncludeType ? P : never })[keyof T];\r\ntype OnlyKeysOfType<T, IncludeType> = Pick<T, OnlyKeysOfTypeTmp<T, IncludeType>>;\r\ntype RemoveKeysOfType<T, ExcludeType> = Exclude2<T, OnlyKeysOfType<T, ExcludeType>>;\r\n\r\n// todo: can't automatically convert D to L (generating the type instead of manual defining L) rules are: LClass <--- Pointer<LClass>, LClass[] <-- Pointer<LClass, 0, 'N'>, subobject = ? should not be there\r\n\r\n/**\r\n i have a documentation type that is actually a string, but it\\'s have a different purpose from the others, and i made a type to keep documentally separated.\r\n let's say it's\r\n type StringOf<P> = string; // regardless of P\r\n\r\n and i use it to define objects\r\n\r\n class C {\r\n           str: StringOf<Date>;\r\n           str2: StringOf<number>;\r\n           purestring: string;\r\n           num: number\r\n         }\r\n now i want to crete a derivate type that excludes all properties of type StringOf from C\r\n\r\n\r\n\r\n type OnlyKeysOfTypeTmp<T, IncludeType> = ({[P in keyof T]: T[P] extends IncludeType ? P : never })[keyof T];\r\n type OnlyKeysOfType<T, IncludeType> = Pick<T, OnlyKeysOfTypeTmp<T, IncludeType>>;\r\n type RemoveKeysOfType<T, ExcludeType> = Exclude2<T, OnlyKeysOfType<T, string>>;\r\n\r\n type D = RemoveKeysOfType<C, StringOf<any>>\r\n due to duck typing, this removes all StringOf attributes, but also \"purestring\" attribute.\r\n how can i remove only StringOf attributes?\r\n\r\n\r\n */\r\n\r\n\r\n\r\nexport type getWParams<L extends LPointerTargetable, D extends Object> ={\r\n    // [Property in keyof ValidObj<L>]: L[Property] extends never ? never : L[Property]\r\n    [Property in keyof L]:/*\r\n            Property extends \"opposite\" ? LReference | DReference | Pointer<DReference> :\r\n            Property extends \"parent\" ? LModelElement | DModelElement | Pointer<DModelElement> :\r\n            Property extends \"annotations\" ? LAnnotation | DAnnotation | Pointer<DAnnotation> :*/\r\n    (Property extends string ? (\r\n        Property extends \"id\" ? 'id is read-only' :\r\n            //@ts-ignore\r\n            (L[`set_${Property}`] extends (a:any, b: any, ...b:any)=> any ? // at least 2 params: 1 for val and 1 for Context\r\n                // if a set_ first parameter is Context it means the set_ is ill-defined, need to change actual method signature.\r\n                //@ts-ignore\r\n                Parameters<L[`set_${Property}`]>[0] // if set_X function is defined, get first param\r\n                //@ts-ignore\r\n                : never ///D[Property] | `todo: should define set_${Property}` // default type if it's not assigned = type in the D version\r\n                )): never)\r\n} // & L\r\n\r\n\r\nexport enum EGraphElements {\r\n    \"GraphElement\"=  \"GraphElement\",\r\n    \"Field\" =\"GraphElement\", // just an alias for now.\r\n    \"Vertex\"= \"Vertex\",\r\n    \"todo\" = \"todo\"\r\n}\r\nexport enum EModelElements{\r\n    // concrete m2\r\n    \"(m2) Model\" = \"DModel\",\r\n    \"(m2) Package\" = \"DPackage\",\r\n    \"(m2) Class\" = \"DClass\",\r\n    \"(m2) Enum\" = \"DEnumerator\",\r\n    \"(m2) Literal\" = \"DEnumLiteral\",\r\n    \"(m2) Operation\" = \"DOperation\",\r\n    \"(m2) Parameter\" = \"DParameter\",\r\n    \"(m2) Attribute\" = \"DAttribute\",\r\n    \"(m2) Reference\" = \"DReference\",\r\n    \"(m2) Annotation\" = \"DAnnotation\",\r\n    // abstract m2\r\n    \"(abstract m2) Feature\" = \"DStructuralFeature\",\r\n    \"(abstract m2) Classifier\" = \"DClassifier\",\r\n    // concrete m1\r\n    \"(m1) Object\" = \"DObject\",\r\n    \"(m1) Value\" = \"DValue\",\r\n}\r\nexport class ViewEClassMatch {\r\n    static NOT_EVALUATED_YET = undefined;\r\n    static MISMATCH = Number.NEGATIVE_INFINITY;\r\n    static MISMATCH_PRECONDITIONS = Number.NEGATIVE_INFINITY;\r\n    static MISMATCH_JS = false;\r\n    static MISMATCH_OCL = false;\r\n    static IMPLICIT_MATCH = 1;\r\n    static INHERITANCE_MATCH = 1.5;\r\n    static EXACT_MATCH = 2;\r\n    static VP_MISMATCH: number = Number.NEGATIVE_INFINITY;\r\n    static VP_Default = 1;\r\n    static VP_Decorative = 1;\r\n    static VP_Explicit = 2;\r\n}\r\n\r\nexport type ViewScore = {\r\n    viewPointMatch: number;\r\n    jsxOutput: React.ReactNode | React.ReactElement | undefined;\r\n    metaclassScore: number;\r\n    jsScore: number | boolean;\r\n    OCLScore: boolean;\r\n    finalScore: number;\r\n    usageDeclarations: GObject;\r\n    evalContext: GObject; // with added usageDeclarations for the current view\r\n    shouldUpdate: boolean; // computed along usageDeclarations in shouldComponentUpdate\r\n    shouldUpdate_reason: GObject;\r\n    nodeidcounter: Dictionary<number/*jsx char index*/, number/*counter:how many nodes generated by that jsx string line until now*/>\r\n\r\n    // usageDeclarations!: DefaultUsageDeclarations;\r\n    // oldNode: DGraphElement; moved to viewSorted_nodeused // ref to the actual node, not pointer. so even if it's modified through redux,\r\n    // it is still possible to compare old version and new version to check if view.oclUpdateCondition should trigger\r\n}\r\nexport class NodeTransientProperties{\r\n    viewSorted_modelused?: LModelElement; // L-version because it is used in oclUpdate function\r\n    viewSorted_pvid_used?: DViewElement;\r\n    viewSorted_nodeused?: LGraphElement;\r\n    stackViews!: LViewElement[]; // for each parentview, an array of Decorative Views[] sorted by score (including parent view influence).\r\n    validMainViews!: LViewElement[]; // an array of Main Views[] sorted by score (including parent view influence).\r\n    mainView!: LViewElement;\r\n    viewScores: Dictionary<Pointer<DViewElement>, ViewScore> = {} as any;\r\n    evalContext!: GObject; // global for this node (without view-specific usageDeclaration)\r\n    needSorting!: boolean;\r\n    longestLabel!: LVoidEdge['longestLabel'];\r\n    labels!: LVoidEdge['labels'];\r\n    src: any;\r\n    //force1Update!: boolean;\r\n    onDelete?: (node: LGraphElement)=>boolean; // return false to prevent deletion\r\n    constructor(){\r\n        // this.stackViews = []; this.validMainViews = [];\r\n        this.viewScores = {};\r\n        this.src = U.getStackTrace();\r\n    }\r\n}\r\nexport class ViewTransientProperties {\r\n    // css_MUST_RECOMPILE: boolean;\r\n    // compiled_css: string; maye those are better shared in sessions\r\n    events!: Dictionary<DocString<\"functionName\">, ((...a:any)=>any)>;\r\n    oclChanged!: boolean;\r\n    jsConditionChanged!: boolean;\r\n    oclUpdateCondition_PARSED!: (oldData: LModelElement, newData:LModelElement) => boolean;// not used anymore? was like UD+shouldcompoupdate for jsx, a pre-ocl check\r\n    oclEngine!: OclEngine;\r\n    jsCondition!: undefined | ((context:GObject) => boolean);\r\n    JSXFunction!: (scope: GObject)=>ReactNode;\r\n    UDFunction!: (scope: GObject, ret: GObject)=>void;\r\n    constantsList!: string[];\r\n    UDList!: string[];\r\n    constants!: GObject;\r\n    onDataUpdate!: undefined | ((context:GObject)=>void);\r\n    onDragStart!: undefined | ((context:GObject)=>void);\r\n    onDragEnd!: undefined | ((context:GObject)=>void);\r\n    whileDragging!: undefined | ((context:GObject)=>void);\r\n    onResizeStart!: undefined | ((context:GObject)=>void);\r\n    onResizeEnd!: undefined | ((context:GObject)=>void);\r\n    whileResizing!: undefined | ((context:GObject)=>void);\r\n    onRotationStart!: undefined | ((context:GObject)=>void);\r\n    onRotationEnd!: undefined | ((context:GObject)=>void);\r\n    whileRotating!: undefined | ((context:GObject)=>void);\r\n\r\n    longestLabel!: LVoidEdge['longestLabel'];\r\n    labels!: LVoidEdge['labels'];\r\n\r\n    constructor(){\r\n        this.events = {};\r\n    }\r\n\r\n\r\n}\r\nexport class DataTransientProperties {\r\n    nodes!: Dictionary<Pointer<DGraphElement>, LGraphElement>;\r\n    node?: LGraphElement;\r\n    derived_read?: (data: LModelElement, originalValues: any[]) => any; // derived attributes and references\r\n    derived_write?: (value:any, data:LModelElement, oldValue:any[]) => any; // derived attributes and references\r\n    constructor(){\r\n        this.nodes = {};\r\n    }\r\n}\r\n\r\n// score for all view ocl + sorted views by best match\r\ntype TransientPropertiesByGraphTab = Dictionary<Pointer<DViewElement, number>> & {\r\n    /*\r\n    need_sorting: boolean;\r\n    sorted: Pointer<DViewElement>[];\r\n    // viewMatchings: Scored<DViewElement>[];\r\n    when to update?\r\n    1) data.parent.view.id: when \"suviews\" in place are changed by a view on a container element has changed (if pkg view changed, class view might change as well)\r\n    2) data.any --> when a direct value of the doject changed, amd that value was declared in ocl\r\n    3) view.appliableto --> when d-type changes (never, a class cannot become a enum or reference\r\n    4) node stuff never? or maybe entire nodes?\r\n    other data or view properties?*/\r\n};\r\nexport const transientProperties = {\r\n    node: {} as Dictionary<Pointer<DGraphElement>, NodeTransientProperties>,\r\n    view: {} as Dictionary<Pointer<DViewElement>, ViewTransientProperties>,\r\n    modelElement: {} as Dictionary<Pointer<DModelElement>, DataTransientProperties>,\r\n};\r\n(window as any).transient = (window as any).transientProperties = transientProperties;\r\n// transientProperties.nodes[nid].viewScores[vid]?.[pvid as string];\r\n/*\r\nexport const transientPropertiesByGraphTab: {viewMatchings: Dictionary<Pointer<DGraph>, Dictionary<Pointer<DModelElement>, TransientPropertiesByGraphTab>>} = {\r\n viewMatchings: {}\r\n};*/\r\n","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\common\\Uhtml.ts",[],"C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\common\\Geom.ts",["956","957","958","959","960","961","962","963","964","965","966","967","968","969","970","971","972","973","974","975","976"],"import {GObject, Temporary, TODO, U} from \"../joiner\";\r\nimport {DPointerTargetable, RuntimeAccessible, windoww, Log, RuntimeAccessibleClass, Dictionary} from \"../joiner\";\r\nimport React from \"react\";\r\nimport {radian} from \"../joiner/types\";\r\n\r\n@RuntimeAccessible('IPoint')\r\nexport abstract class IPoint extends RuntimeAccessibleClass {\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    public x!: number;\r\n    public y!: number;\r\n\r\n    // @ts-ignore static getM is not null but must be declared nullable to achieve subclass mixing\r\n    // public static getM? = function(firstPt: IPoint, secondPt: IPoint): number { return (firstPt.y - secondPt.y) / (firstPt.x - secondPt.x); }\r\n    public static getM(firstPt: IPoint, secondPt: IPoint): number { return (firstPt.y - secondPt.y) / (firstPt.x - secondPt.x); }\r\n    public static getQ(firstPt: IPoint, secondPt: IPoint, m?: number): number {\r\n        if (m === undefined) m = IPoint.getM(firstPt, secondPt);\r\n        return firstPt.y - (m * firstPt.x);\r\n    }\r\n\r\n    public constructor(x: number = 0, y: number = 0) {\r\n        super(); // super('dwc');\r\n        IPoint.init_constructor(this, x, y);\r\n    }\r\n\r\n    static init_constructor(thiss: GObject, x: any = 0, y: any = 0, ...a: any): void {\r\n        thiss.id = \"POINT_\" + (DPointerTargetable.maxID++) + \"_\" + new Date().getTime();\r\n        thiss.className = thiss.constructor.name;\r\n        if (x === null || x === undefined) thiss.x = undefined as Temporary;\r\n        else if (isNaN(+x)) { thiss.x = 0; }\r\n        else thiss.x = +x;\r\n        if (y === null || y === undefined) thiss.y = undefined as Temporary;\r\n        else if (isNaN(+y)) { thiss.y = 0; }\r\n        else thiss.y = +y;\r\n        thiss.className = this.cname;\r\n    }\r\n\r\n\r\n    static printDiff(s1: SizeLike, s2: SizeLike) {\r\n        return ISize.printDiff(s1, s2, true);\r\n    }\r\n    public raw(): {x: number, y: number} { return {x: this.x, y: this.y}; }\r\n\r\n    public toString(letters: boolean=true, separator: string = \" \"): string {\r\n        if (letters) return  JSON.stringify({x:this.x, y: this.y});\r\n        else return this.x + separator + this.y + separator;\r\n    }\r\n    public clone(other: { x: number, y: number }): this { this.x = other.x; this.y = other.y; return this; }\r\n\r\n    protected abstract new(): this;\r\n    abstract toSize(w: number, h?: number): ISize;\r\n    public duplicate(): this { const ret = this.new(); ret.clone(this); return ret; }\r\n\r\n    public distanceFromPoint(tentativeEnd: IPoint, skipSqrt: boolean = false): number {\r\n        let d_pow2 = (this.x - tentativeEnd.x)**2 + (this.y - tentativeEnd.y)**2;\r\n        return skipSqrt ? d_pow2 : Math.sqrt(d_pow2);\r\n        // return this.subtract(tentativeEnd, true).absolute();\r\n    }\r\n\r\n    public subtract(p2: { x?: number, y?: number }, newInstance: boolean): this {\r\n        Log.e(!p2, 'subtract argument must be a valid point: ', p2);\r\n        let p1: this;\r\n        if (!newInstance) { p1 = this; } else { p1 = this.duplicate(); }\r\n        if (p2.x !== undefined) p1.x -= p2.x;\r\n        if (p2.y !== undefined) p1.y -= p2.y;\r\n        return p1; }\r\n\r\n    public add(p2: { x?: number, y?: number }, newInstance: boolean): this {\r\n        Log.e(!p2, 'add argument must be a valid point: ', p2);\r\n        let p1: this;\r\n        if (!newInstance) { p1 = this; } else { p1 = this.duplicate(); }\r\n        if (p2.x !== undefined) p1.x += p2.x;\r\n        if (p2.y !== undefined) p1.y += p2.y;\r\n        return p1; }\r\n\r\n    public addAll(p: IPoint[], newInstance: boolean): this {\r\n        let i;\r\n        let p0: this;\r\n        if (!newInstance) { p0 = this; } else { p0 = this.duplicate(); }\r\n        for (i = 0; i < p.length; i++) { p0.add(p[i], true); }\r\n        return p0; }\r\n\r\n    public subtractAll(p: this[], newInstance: boolean): this {\r\n        let i;\r\n        let p0: this;\r\n        if (!newInstance) { p0 = this; } else { p0 = this.duplicate(); }\r\n        for (i = 0; i < p.length; i++) { p0.subtract(p[i], true); }\r\n        return p0; }\r\n\r\n    public multiply(pt: {x?: number, y?: number} | number, newInstance: boolean = false): this {\r\n        let ret: this = (newInstance ? this.duplicate() : this);\r\n        if (typeof pt === \"number\") {\r\n            ret.x *= pt;\r\n            ret.y *= pt;\r\n        }\r\n        else {\r\n            if (pt.x !== undefined) ret.x *= pt.x;\r\n            if (pt.y !== undefined) ret.y *= pt.y;\r\n        }\r\n        return ret; }\r\n\r\n    public divide(pt: Partial<this> | number, newInstance: boolean = false): this {\r\n        let ret = (newInstance ? this.duplicate() : this);\r\n        if (typeof pt === \"number\") {\r\n            ret.x /= pt;\r\n            ret.y /= pt;\r\n        }\r\n        else {\r\n            ret.x /= pt.x as number;\r\n            ret.y /= pt.y as number;\r\n        }\r\n        return ret; }\r\n\r\n    public multiplyScalar(scalar: number, newInstance: boolean): this {\r\n        Log.e(isNaN(+scalar), 'IPoint.multiply()', 'scalar argument must be a valid number: ', scalar);\r\n        let p1: this;\r\n        if (!newInstance) { p1 = this; } else { p1 = this.duplicate(); }\r\n        p1.x *= scalar;\r\n        p1.y *= scalar;\r\n        return p1; }\r\n\r\n    public divideScalar(scalar: number, newInstance: boolean): this {\r\n        Log.e(isNaN(+scalar), 'IPoint.divide()', 'scalar argument must be a valid number: ', scalar);\r\n        let p1: this;\r\n        if (!newInstance) { p1 = this; } else { p1 = this.duplicate(); }\r\n        p1.x /= scalar;\r\n        p1.y /= scalar;\r\n        return p1; }\r\n\r\n    public isInTheMiddleOf(firstPt: this, secondPt: this, tolleranza: number): boolean {\r\n        const rectangle: Size = Size.fromPoints(firstPt, secondPt);\r\n        const tolleranzaX = tolleranza; // actually should be cos * arctan(m);\r\n        const tolleranzaY = tolleranza; // actually should be sin * arctan(m);\r\n        if (this.x < rectangle.x - tolleranzaX || this.x > rectangle.x + rectangle.w + tolleranzaX) { return false; }\r\n        if (this.y < rectangle.y - tolleranzaX || this.y > rectangle.y + rectangle.h + tolleranzaY) { return false; }\r\n        // const m = IPoint.getM(firstPt, secondPt);\r\n        // const q = IPoint.getQ(firstPt, secondPt);\r\n        const lineDistance = this.distanceFromLine(firstPt, secondPt);\r\n        // console.log('distance:', lineDistance, ', this:', this, ', p1:', firstPt, ', p2:', secondPt);\r\n        return lineDistance <= tolleranza; }\r\n\r\n    public distanceFromLine(p1: IPoint, p2: IPoint): number {\r\n        const top: number =\r\n            + (p2.y - p1.y) * this.x\r\n            - (p2.x - p1.x) * this.y\r\n            + p2.x * p1.y\r\n            - p1.x * p2.y;\r\n        const bot =\r\n            (p2.y - p1.y) * (p2.y - p1.y) +\r\n            (p2.x - p1.x) * (p2.x - p1.x);\r\n        return Math.abs(top) / Math.sqrt(bot);  }\r\n\r\n    public equals(pt: {x:number, y:number}, tolleranzaX: number = 0, tolleranzaY: number = 0): boolean {\r\n        if (pt === null) { return false; }\r\n        return Math.abs(this.x - pt.x) <= tolleranzaX && Math.abs(this.y - pt.y) <= tolleranzaY; }\r\n\r\n    public moveOnNearestBorder(startVertexSize: ISize, clone: boolean, graph: TODO/*IGraph*/, debug: boolean = true): IPoint {\r\n        const pt: IPoint = clone ? this.duplicate() : this;\r\n        const tl: IPoint = startVertexSize.tl();\r\n        const tr: IPoint = startVertexSize.tr();\r\n        const bl: IPoint = startVertexSize.bl();\r\n        const br: IPoint = startVertexSize.br();\r\n        const L: number = pt.distanceFromLine(tl, bl);\r\n        const R: number = pt.distanceFromLine(tr, br);\r\n        const T: number = pt.distanceFromLine(tl, tr);\r\n        const B: number = pt.distanceFromLine(bl, br);\r\n        const min: number = Math.min(L, R, T, B);\r\n        if (min === L) { pt.x = tl.x; }\r\n        if (min === R) { pt.x = tr.x; }\r\n        if (min === T) { pt.y = tr.y; }\r\n        if (min === B) { pt.y = br.y; }\r\n        if (debug && graph && pt instanceof GraphPoint) { graph.markg(pt, false, 'purple'); }\r\n        return pt; }\r\n\r\n    public getM(pt2: IPoint): number { return IPoint.getM?.(this, pt2) as unknown as number; }\r\n\r\n    public degreeWith(pt2: IPoint, toRadians: boolean): number {\r\n        const directionVector: IPoint = this.subtract(pt2, true);\r\n        const ret: number = Math.atan2(directionVector.y, directionVector.x);\r\n        return toRadians ? ret : windoww.U.RadToDegree(ret); }\r\n\r\n    public absolute(): number { return Math.sqrt(this.x * this.x + this.y * this.y); }\r\n    public set(x: number, y: number) { this.x = x; this.y = y; }\r\n\r\n    // move the point by a vector with direction and distance (module)\r\n    move(rad: radian /*in radians!*/, distance: number, clone:boolean = true): this{\r\n        let pt = clone ? this.duplicate() : this;\r\n        pt.x += distance * Math.cos(rad);\r\n        pt.y += distance * Math.sin(rad);\r\n        return pt;\r\n    }\r\n\r\n    static stringify(ptlike: {x?:number, y?:number}): string {\r\n        if (!ptlike) return ptlike;\r\n        let str: string[];\r\n        return '('+U.cropNum(ptlike.x||0)+', '+U.cropNum(ptlike.y||0)+')';\r\n    }\r\n}\r\n\r\n@RuntimeAccessible('GraphPoint')\r\nexport class GraphPoint extends IPoint{\r\n    private dontmixwithPoint: any;\r\n    public static fromEvent(e: JQuery.ClickEvent | JQuery.MouseMoveEvent | JQuery.MouseUpEvent | JQuery.MouseDownEvent | JQuery.MouseEnterEvent | JQuery.MouseLeaveEvent | JQuery.MouseEventBase)\r\n        : GraphPoint | null {\r\n        if (!e) { return null; }\r\n        const p: Point = new Point(e.pageX, e.pageY);\r\n        const g: any = null;\r\n        throw new Error(\"todo: const g: IGraph = Status.status.getActiveModel().graph;\");\r\n        return g.toGraphCoord(p); }\r\n\r\n    protected new(): this { return new GraphPoint() as this;}\r\n    public toSize(w: number, h?: number): GraphSize {\r\n        return new GraphSize(this.x, this.y, w, (h === undefined) ? w : h);\r\n    }\r\n\r\n}\r\n\r\n\r\n@RuntimeAccessible('Point')\r\nexport class Point extends IPoint{\r\n    private dontmixwithGPoint: any;\r\n    /// https://stackoverflow.com/questions/6073505/what-is-the-difference-between-screenx-y-clientx-y-and-pagex-y\r\n    public static fromEvent(e: JQuery.ClickEvent | JQuery.MouseMoveEvent | JQuery.MouseUpEvent | JQuery.MouseDownEvent\r\n        | JQuery.MouseEnterEvent | JQuery.MouseLeaveEvent | JQuery.MouseEventBase | React.MouseEvent)\r\n        : Point {\r\n        const p: Point = new Point(e.pageX, e.pageY);\r\n        return p; }\r\n\r\n    protected new(): this { return new Point() as this;}\r\n    public toSize(w: number, h?: number): Size {\r\n        return new Size(this.x, this.y, w, (h === undefined) ? w : h);\r\n    }\r\n}\r\n\r\nRuntimeAccessibleClass.set_extend(RuntimeAccessibleClass, IPoint);\r\nRuntimeAccessibleClass.set_extend(IPoint, GraphPoint);\r\nRuntimeAccessibleClass.set_extend(IPoint, Point);\r\n\r\n@RuntimeAccessible('ISize')\r\nexport abstract class ISize<PT extends IPoint = IPoint> extends RuntimeAccessibleClass {\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    public x!: number;\r\n    public y!: number;\r\n    public w!: number;\r\n    public h!: number;\r\n    public constructor(x: number = 0, y: number = 0, w: number = 0, h: number = 0) {\r\n        super(); // super('dwc');\r\n        // do not override any fields from the DPointerTargetable, otherwise the ! in the override will reinizialize the attribute\r\n        // erasing the value set in super or in the functions called by the constructor as side effect (static_init called from constructor will be overridden too)\r\n        // if need to override types, build the \"new\" static function like in DModelElement\r\n        ISize.init_constructor(this, x, y, w, h);\r\n    }\r\n\r\n\r\n    static printDiff(s1: SizeLike, s2: SizeLike, asPoints:boolean = false, maxDigits:number = 5) {\r\n        s1 = {...s1, w: s1.w ?? s1.width, h: s1.h ?? s1.height};\r\n        s1.x = s1.x ?? s2.x;\r\n        s1.y = s1.y ?? s2.y;\r\n        s2 = {...s2, w: s2.w ?? s2.width, h: s2.h ?? s2.height};\r\n        if (!asPoints) {\r\n            s1.w = s1.w ?? s2.w;\r\n            s1.h = s1.h ?? s2.h;\r\n        }\r\n        let s1coords: (number | string)[] = [];\r\n        s1coords.push(!U.isNumber(s1.x) ? '' : U.cropNum(s1.x, maxDigits));\r\n        s1coords.push(!U.isNumber(s1.y) ? ',' : ', '+U.cropNum(s1.y, maxDigits));\r\n        if (!asPoints) {\r\n            s1coords.push(!U.isNumber(s1.w) ? ',' : ', '+U.cropNum(s1.w, maxDigits));\r\n            s1coords.push(!U.isNumber(s1.h) ? ',' : ', '+U.cropNum(s1.h, maxDigits));\r\n        }\r\n        let s2coords: (number | string)[] = [];\r\n        s2coords.push(s2.x === s1.x || !U.isNumber(s2.x) ? '' : U.cropNum(s2.x, maxDigits));\r\n        s2coords.push(s2.y === s1.y || !U.isNumber(s2.y) ? ',' : ', '+U.cropNum(s2.y, maxDigits));\r\n        if (!asPoints) {\r\n            s2coords.push(s2.w === s1.w || !U.isNumber(s2.w) ? ',' : ', '+U.cropNum(s2.w, maxDigits));\r\n            s2coords.push(s2.h === s1.h || !U.isNumber(s2.h) ? ',' : ', '+U.cropNum(s2.h, maxDigits));\r\n        }\r\n\r\n        // → 🡲\r\n        return `(`+s1coords.join('')+`)🡲(`+s2coords.join('')+`)`;\r\n    }\r\n    static stringify(ptlike: {x?:number, y?:number, w?:number, h?:number, width?:number, height?:number}): string {\r\n        if (!ptlike) return ptlike as any;\r\n        let str: string[] = [];\r\n        if (ptlike.x && !isNaN(ptlike.x)|| ptlike.x === 0) str.push('x:'+U.cropNum(ptlike.x));\r\n        if (ptlike.y && !isNaN(ptlike.y)|| ptlike.y === 0) str.push('y:'+U.cropNum(ptlike.y));\r\n        if (ptlike.w && !isNaN(ptlike.w)|| ptlike.w === 0) str.push('w:'+U.cropNum(ptlike.w));\r\n        if (ptlike.h && !isNaN(ptlike.h)|| ptlike.h === 0) str.push('h:'+U.cropNum(ptlike.h));\r\n        if (ptlike.width && !isNaN(ptlike.width) || ptlike.width === 0) str.push('W:'+U.cropNum(ptlike.width));\r\n        if (ptlike.height && !isNaN(ptlike.height) || ptlike.height === 0) str.push('H:'+U.cropNum(ptlike.height));\r\n        // if (str.length === 0) return '{}';\r\n        return '{'+str.join(', ')+'}';\r\n    }\r\n\r\n    static init_constructor(thiss: GObject, x: any = 0, y: any = 0, w: any = 0, h: any = 0, ...a: any): void {\r\n        thiss.id = \"SIZE_\" + (DPointerTargetable.maxID++) + \"_\" + new Date().getTime();\r\n        thiss.className = (thiss.constructor as typeof RuntimeAccessibleClass).cname;\r\n        if (x === null || x === undefined) thiss.x = undefined as Temporary;\r\n        else if (isNaN(+x)) { thiss.x = 0; }\r\n        else thiss.x = +x;\r\n        if (y === null || y === undefined) thiss.y = undefined as Temporary;\r\n        else if (isNaN(+y)) { thiss.y = 0; }\r\n        else thiss.y = +y;\r\n        if (w === null || w === undefined) thiss.w = undefined as Temporary;\r\n        else if (isNaN(+w)) { thiss.w = 0; }\r\n        else thiss.w = +w;\r\n        if (h === null || h === undefined) thiss.h = undefined as Temporary;\r\n        else if (isNaN(+h)) { thiss.h = 0; }\r\n        else thiss.h = +h;\r\n        thiss.className = this.cname; }\r\n\r\n    public toString(letters: boolean=true, separator: string = \" \"): string {\r\n        if (letters) return JSON.stringify({x: this.x, y: this.y, w: this.w, h: this.h});\r\n        else return this.x + separator + this.y + separator + this.w + separator + this.h;\r\n    }\r\n\r\n    public set(x?: number, y?: number, w?: number, h?: number): void {\r\n        if (x !== undefined) (this.x = +x);\r\n        if (y !== undefined) (this.y = +y);\r\n        if (w !== undefined) (this.w = +w);\r\n        if (h !== undefined) (this.h = +h);\r\n    }\r\n\r\n    protected abstract makePoint(x: number, y: number): PT;\r\n    protected abstract new(...args:any): this;\r\n    public clone(json: this): this { this.x = json.x; this.y = json.y; this.w = json.w; this.h = json.h; return this; }\r\n    public duplicate(): this { return this.new().clone(this); }\r\n\r\n    public add(pt2: number | {x?:number, y?:number, w?:number, h?:number}, newInstance?: boolean): this {\r\n        let thiss = newInstance ? this.duplicate() : this;\r\n        if (typeof pt2 === \"number\") { thiss.x += pt2; thiss.y += pt2; thiss.w += pt2; thiss.h += pt2; return thiss; }\r\n        if (pt2.x !== undefined) thiss.x += pt2.x;\r\n        if (pt2.y !== undefined) thiss.y += pt2.y;\r\n        if (pt2.w !== undefined) thiss.w += pt2.w;\r\n        if (pt2.h !== undefined) thiss.h += pt2.h;\r\n        return thiss; }\r\n\r\n    public subtract(pt2: number | {x?:number, y?:number, w?:number, h?:number}, newInstance?: boolean): this {\r\n        let thiss = newInstance ? this.duplicate() : this;\r\n        if (typeof pt2 === \"number\") { thiss.x -= pt2; thiss.y -= pt2; thiss.w -= pt2; thiss.h -= pt2; return thiss; }\r\n        if (pt2.x !== undefined) thiss.x -= pt2.x;\r\n        if (pt2.y !== undefined) thiss.y -= pt2.y;\r\n        if (pt2.w !== undefined) thiss.w -= pt2.w;\r\n        if (pt2.h !== undefined) thiss.h -= pt2.h;\r\n        return thiss; }\r\n\r\n    public multiply(pt2: number | {x?:number, y?:number, w?:number, h?:number}, newInstance?: boolean): this {\r\n        let thiss = newInstance ? this.duplicate() : this;\r\n        if (typeof pt2 === \"number\") { thiss.x *= pt2; thiss.y *= pt2; thiss.w *= pt2; thiss.h *= pt2; return thiss; }\r\n        if (pt2.x !== undefined) thiss.x *= pt2.x;\r\n        if (pt2.y !== undefined) thiss.y *= pt2.y;\r\n        if (pt2.w !== undefined) thiss.w *= pt2.w;\r\n        if (pt2.h !== undefined) thiss.h *= pt2.h;\r\n        return thiss; }\r\n\r\n    public divide(pt2: number | {x?:number, y?:number, w?:number, h?:number}, newInstance?: boolean): this {\r\n        let thiss = newInstance ? this.duplicate() : this;\r\n        if (typeof pt2 === \"number\") { thiss.x /= pt2; thiss.y /= pt2; thiss.w /= pt2; thiss.h /= pt2; return thiss; }\r\n        if (pt2.x !== undefined) thiss.x /= pt2.x;\r\n        if (pt2.y !== undefined) thiss.y /= pt2.y;\r\n        if (pt2.w !== undefined) thiss.w /= pt2.w;\r\n        if (pt2.h !== undefined) thiss.h /= pt2.h;\r\n        return thiss; }\r\n\r\n\r\n    public tl(): PT {     return this.makePoint(   this.x,                 this.y             ); }\r\n    public tr(): PT {     return this.makePoint(this.x + this.w,        this.y             ); }\r\n    public bl(): PT {     return this.makePoint(   this.x,              this.y + this.h    ); }\r\n    public br(): PT {     return this.makePoint(this.x + this.w,     this.y + this.h    ); }\r\n    public center(): PT { return this.makePoint(this.x + this.w / 2, this.y + this.h / 2); }\r\n    public relativePoint(xPercent: number, yPercent: number): PT { return this.makePoint(this.x + this.w * xPercent, this.y + this.h * yPercent); }\r\n    public equals(size: this): boolean { return this.x === size.x && this.y === size.y && this.w === size.w && this.h === size.h; }\r\n\r\n    /// field-wise Math.min()\r\n    public min(minSize: this, clone: boolean): this {\r\n        const ret: this = clone ? this.new() : this;\r\n        if (!isNaN(minSize.x) && ret.x < minSize.x) { ret.x = minSize.x; }\r\n        if (!isNaN(minSize.y) && ret.y < minSize.y) { ret.y = minSize.y; }\r\n        if (!isNaN(minSize.w) && ret.w < minSize.w) { ret.w = minSize.w; }\r\n        if (!isNaN(minSize.h) && ret.h < minSize.h) { ret.h = minSize.h; }\r\n        return ret; }\r\n    public max(maxSize: this, clone: boolean): this {\r\n        const ret: this = clone ? this.new() : this;\r\n        if (!isNaN(maxSize.x) && ret.x > maxSize.x) { ret.x = maxSize.x; }\r\n        if (!isNaN(maxSize.y) && ret.y > maxSize.y) { ret.y = maxSize.y; }\r\n        if (!isNaN(maxSize.w) && ret.w > maxSize.w) { ret.w = maxSize.w; }\r\n        if (!isNaN(maxSize.h) && ret.h > maxSize.h) { ret.h = maxSize.h; }\r\n        return ret; }\r\n\r\n    public intersection(size: this): this | null {\r\n        if (!size) return null;\r\n        // anche \"isinside\"\r\n        let startx, starty, endx, endy;\r\n        startx = Math.max(this.x, size.x);\r\n        starty = Math.max(this.y, size.y);\r\n        endx = Math.min(this.x + this.w, size.x + size.w);\r\n        endy = Math.min(this.y + this.h, size.y + size.h);\r\n        const intersection: this = this.new();\r\n        // intersection.set(0, 0, 0, 0);\r\n        intersection.x = startx;\r\n        intersection.y = starty;\r\n        intersection.w = endx - startx;\r\n        intersection.h = endy - starty;\r\n        const doesintersect: boolean = intersection.w > 0 && intersection.h > 0;\r\n        return (doesintersect) ? intersection: null; }\r\n\r\n    public contains(pt: PT): boolean {\r\n        return  pt.x >= this.x && pt.x <= this.x + this.w && pt.y >= this.y && pt.y <= this.y + this.h; }\r\n\r\n    public isOverlapping(size2: this): boolean { return !!this.intersection(size2); }\r\n    public isOverlappingAnyOf(sizes: this[]): boolean {\r\n        if (!sizes) return false;\r\n        for (let size of sizes) { if (this.isOverlapping(size)) return true; }\r\n        return false;\r\n    }\r\n\r\n    public multiplyPoint(other: PT, newInstance: boolean): this {\r\n        const ret: this = newInstance ? this.new() : this;\r\n        ret.x *= other.x;\r\n        ret.w *= other.x;\r\n        ret.y *= other.y;\r\n        ret.h *= other.y;\r\n        return ret; }\r\n\r\n    public dividePoint(other: PT, newInstance: boolean): this {\r\n        const ret: this = newInstance ? this.new() : this;\r\n        ret.x /= other.x;\r\n        ret.w /= other.x;\r\n        ret.y /= other.y;\r\n        ret.h /= other.y;\r\n        return ret; }\r\n\r\n    public boundary(size2: this): void {\r\n        /*let minx, maxx, miny, maxy;\r\n        if (size2.y < this.y) { miny = size2.y; /*maxy = this.y;* / } else { miny = this.y; /*maxy = size2.y;* / }\r\n        if (size2.x < this.x) { minx = size2.y; /*maxx = this.x;* / } else { minx = this.x; /*maxy = size2.x;* / }\r\n        if (size2.y + size2.h < this.y + this.h) maxy = this.y + this.h; else maxy = size2.y + size2.h;\r\n        if (size2.x + size2.w < this.x + this.w) maxx = this.x + this.w; else maxx = size2.x + size2.w;\r\n        */\r\n        this.h = (size2.y + size2.h > this.y + this.h ? size2.y + size2.h : this.y + this.h); // -miny\r\n        this.w = (size2.x + size2.w > this.x + this.w ? size2.x + size2.w : this.x + this.w); // -minx\r\n        if (this.y < size2.y) this.y = size2.y;\r\n        if (this.x < size2.x) this.x = size2.x;\r\n        this.h -= this.y;\r\n        this.w -= this.x;\r\n    }\r\n}\r\ntype SizeLike = {x?: number, y?: number, w?: number, h?:number, width?: number, height?: number}\r\ntype PointLike = {x?: number, y?: number}\r\n\r\n@RuntimeAccessible('Size')\r\nexport class Size extends ISize<Point> {\r\n    static subclasses: any[] = [];\r\n    private static sizeofvar: HTMLElement;\r\n    private static $sizeofvar: JQuery<HTMLElement>;\r\n    private dontMixWithGraphSize: any;\r\n\r\n    /**\r\n     * measure a node size\r\n     * @param {Element} element0 - the emelemnt to measure;\r\n     * @param {boolean} sizePostTransform - includes css transform instructions for computing his size. like transform: scale(1.5)\r\n     * */\r\n    public static of(element0: Element, sizePostTransform: boolean = true): Size {\r\n        let element: HTMLElement = element0 as HTMLElement;\r\n        if (element as unknown === document) {\r\n            Log.ww('trying to measure document, rerouted to measuring body.');\r\n            element = document.body as any;\r\n        }\r\n        const $element = $(element);\r\n        Log.ex(!element || element.tagName === 'foreignObject', 'sizeof()', 'SvgForeignElementObject have a bug with size, measure a child instead.', element);\r\n        let tmp;\r\n        let size: Size;\r\n        if (!Size.sizeofvar) {\r\n            Size.sizeofvar = document.createElement('div');\r\n            document.body.append(Size.sizeofvar); }\r\n\r\n        const isOrphan = element.parentNode === null;\r\n        // var visible = element.style.display !== 'none';\r\n        // var visible = $element.is(\":visible\"); crea bug quando un elemento è teoricamente visibile ma orfano\r\n        const ancestors =  windoww.U.ancestorArray(element);\r\n        const displayStyles: string[] = ancestors.map( (e: HTMLElement) => e?.style?.display);\r\n        if (isOrphan) { Size.sizeofvar.append(element); }\r\n        // show all and saveToDB visibility to restore it later\r\n        for (let i = 0; i < ancestors.length; i++) { // document has undefined style\r\n            displayStyles[i] = ancestors[i]?.style?.display;\r\n            if (displayStyles[i] === 'none' || (displayStyles[i] === '' && getComputedStyle(ancestors[i]).display === 'none')) { ancestors[i].style.display = 'block' }\r\n        }\r\n        // size = new Size(tmp.left, tmp.top, 0, 0);\r\n        let rect = element.getBoundingClientRect();\r\n        size = new Size(0, 0, 0, 0);\r\n\r\n        let win = (element.ownerDocument?.defaultView || window);\r\n        size.x = rect.left + win.scrollX;\r\n        size.y = rect.top + win.scrollY;\r\n        if (sizePostTransform) {\r\n            size.w = rect.width;\r\n            size.h = rect.height;\r\n        }\r\n        else {\r\n            size.w = element.offsetWidth; // element.scrollWidth;\r\n            size.h = element.offsetHeight;\r\n        }\r\n        // restore visibility\r\n        for (let i = 0; i < ancestors.length; i++) {\r\n            if (displayStyles[i] === ancestors[i].style?.display) continue;\r\n            if (displayStyles[i]) ancestors[i].style.display = displayStyles[i];\r\n            else ancestors[i].style.removeProperty('display');\r\n        }\r\n        if (isOrphan) {  windoww.U.clear(Size.sizeofvar); }\r\n        // Status.status.getActiveModel().graph.markS(size, false);\r\n        return size;\r\n    }\r\n\r\n    public static fromPoints(firstPt: IPoint, secondPt: IPoint): Size {\r\n        const minX = Math.min(firstPt.x, secondPt.x);\r\n        const maxX = Math.max(firstPt.x, secondPt.x);\r\n        const minY = Math.min(firstPt.y, secondPt.y);\r\n        const maxY = Math.max(firstPt.y, secondPt.y);\r\n        return new Size(minX, minY, maxX - minX, maxY - minY); }\r\n\r\n    protected makePoint(x: number, y: number): Point { return new Point(x, y); }\r\n    protected new(...args:any): this { return new Size(...args) as this; }\r\n}\r\n@RuntimeAccessible('GraphSize')\r\nexport class GraphSize extends ISize<GraphPoint> {\r\n    private dontMixWithSize: any;\r\n\r\n    public static fromPoints(firstPt: GraphPoint, secondPt: GraphPoint): GraphSize {\r\n        const minX = Math.min(firstPt.x, secondPt.x);\r\n        const maxX = Math.max(firstPt.x, secondPt.x);\r\n        const minY = Math.min(firstPt.y, secondPt.y);\r\n        const maxY = Math.max(firstPt.y, secondPt.y);\r\n        return new GraphSize(minX, minY, maxX - minX, maxY - minY); }\r\n\r\n    // both pt and targetPt are readonly-safe parameters\r\n    public static closestIntersection(size: GraphSize, pt: GraphPoint, targetPt: GraphPoint, gridAlign?: GraphPoint, m0?:number, q0?:number): GraphPoint | undefined {\r\n        // let pt: GraphPoint = pt0.duplicate();\r\n        const m = m0 || GraphPoint.getM(targetPt, pt);\r\n        const q = q0 || GraphPoint.getQ(targetPt, pt);\r\n        // console.log(\"closestIntersection()\", {size, pt0, targetPt, m, q});\r\n        // if perfectly vertical line\r\n        if (m === Number.POSITIVE_INFINITY/* && q === Number.NEGATIVE_INFINITY*/) {\r\n            // top center\r\n            if (Math.abs(targetPt.y - size.y) <= Math.abs(targetPt.y - size.y - size.h)) return pt;\r\n            // bottom center\r\n            else return new GraphPoint(pt.x, size.y + size.h);\r\n        }\r\n        let tl = size.tl(), tr = size.tr(),\r\n            bl = size.bl(), br = size.br();\r\n        let allowT: boolean, allowB: boolean,\r\n            allowL: boolean, allowR: boolean;\r\n        /*let distanceT: number = Number.POSITIVE_INFINITY, distanceB: number = Number.POSITIVE_INFINITY,\r\n            distanceL: number = Number.POSITIVE_INFINITY, distanceR: number = Number.POSITIVE_INFINITY;*/\r\n        let intersectionT: GraphPoint | undefined, intersectionB: GraphPoint | undefined,\r\n            intersectionL: GraphPoint | undefined, intersectionR: GraphPoint | undefined;\r\n\r\n\r\n        allowT = Geom.isNumberBetween(tl.y, bl.y, targetPt.y);\r\n        allowB = Geom.isNumberBetween(bl.y, tl.y, targetPt.y);\r\n        allowL = Geom.isNumberBetween(tl.x, tr.x, targetPt.x);\r\n        allowR = Geom.isNumberBetween(tr.x, tl.x, targetPt.x);\r\n        // console.log(\"closestIntersection pt0\", {size, targetPt, pt0:pt0.raw(), gridAlign,\r\n        //     corners:{tl:tl.raw(), tr:tr.raw(), bl:bl.raw(), br:br.raw()}, allows:{allowT, allowB, allowL, allowR}});\r\n        if (!(allowT || allowB || allowL || allowR)) return undefined; // point is internal to size\r\n        if (allowT) intersectionT = Geom.lineToSegmentIntersection(tl, tr, q, m); else\r\n        if (allowB) intersectionB = Geom.lineToSegmentIntersection(bl, br, q, m); // NOT else, (T|B) AND (L|R) can happen, or just 1 or 0 of those.\r\n        if (allowL) intersectionL = Geom.lineToSegmentIntersection(tl, bl, q, m); else\r\n        if (allowR) intersectionR = Geom.lineToSegmentIntersection(tr, br, q, m);\r\n\r\n        // console.log(\"closestIntersection pt2\", {intersectionT, intersectionB, intersectionL, intersectionR});\r\n        // only 1 intersection can happen\r\n        return intersectionT || intersectionB || intersectionL || intersectionR;\r\n    }\r\n    public static closestIntersection_old(size: GraphSize, prevPt: GraphPoint, pt0: GraphPoint, gridAlign?: GraphPoint): GraphPoint | null {\r\n        let ret = GraphSize.closestIntersection0(size, prevPt, pt0, gridAlign) as any;\r\n        // Log.exDev(!Geom.isOnEdge(ret, size), 'ClosestIntersection failed. not on Vertex edge.', {ret, size, prevPt, pt0, gridAlign});\r\n        return ret;\r\n    }\r\n    private static closestIntersection0(vertexGSize: GraphSize, prevPt: GraphPoint, pt0: GraphPoint, gridAlign?: GraphPoint): GraphPoint | null {\r\n        let pt: GraphPoint | null = pt0.duplicate();\r\n        const m = GraphPoint.getM(prevPt, pt) as number;\r\n        const q = GraphPoint.getQ(prevPt, pt) as number;\r\n        // U.pe( Math.abs((pt.y - m * pt.x) - (prevPt.y - m * prevPt.x)) > .001, 'wrong math in Q:', (pt.y - m * pt.x), ' vs ', (prevPt.y - m * prevPt.x));\r\n        /*const isL = prevPt.x < pt.x;\r\n    const isT = prevPt.y < pt.y;\r\n    const isR = !isL;\r\n    const isB = !isT; */\r\n        if (m === Number.POSITIVE_INFINITY && q === Number.NEGATIVE_INFINITY) { // bottom middle\r\n            return new GraphPoint(vertexGSize.x + vertexGSize.w / 2, vertexGSize.y + vertexGSize.h); }\r\n        // console.log('pt:', pt, 'm:', m, 'q:', q);\r\n        let L: GraphPoint | null = new GraphPoint(0, 0);\r\n        let T: GraphPoint | null = new GraphPoint(0, 0);\r\n        let R: GraphPoint | null = new GraphPoint(0, 0);\r\n        let B: GraphPoint | null = new GraphPoint(0, 0);\r\n        L.x = vertexGSize.x;\r\n        L.y = m * L.x + q;\r\n        R.x = vertexGSize.x + vertexGSize.w;\r\n        R.y = m * R.x + q;\r\n        T.y = vertexGSize.y;\r\n        T.x = (T.y - q) / m;\r\n        B.y = vertexGSize.y + vertexGSize.h;\r\n        B.x = (B.y - q) / m;\r\n        // prendo solo il compreso pt ~ prevPt (escludo così il \"pierce\" sulla faccia opposta), prendo il più vicino al centro.\r\n        // console.log('4 possibili punti di intersezione (LTBR):', L, T, B, R);\r\n        /* this.owner.mark(this.owner.toHtmlCoord(T), true, 'blue');\r\n    this.owner.mark(this.owner.toHtmlCoord(B), false, 'violet');\r\n    this.owner.mark(this.owner.toHtmlCoord(L), false, 'red');\r\n    this.owner.mark(this.owner.toHtmlCoord(R), false, 'orange');*/\r\n        console.log(\"intersect pt1:\", {T, B, L, R});\r\n        if ( (B.x >= pt.x && B.x <= prevPt.x) || (B.x >= prevPt.x && B.x <= pt.x) ) { } else { B = null; }\r\n        if ( (T.x >= pt.x && T.x <= prevPt.x) || (T.x >= prevPt.x && T.x <= pt.x) ) { } else { T = null; }\r\n        if ( (L.y >= pt.y && L.y <= prevPt.y) || (L.y >= prevPt.y && L.y <= pt.y) ) { } else { L = null; }\r\n        if ( (R.y >= pt.y && R.y <= prevPt.y) || (R.y >= prevPt.y && R.y <= pt.y) ) { } else { R = null; }\r\n        console.log(\"intersect pt2:\", {T, B, L, R});\r\n        function closestmix(pt: GraphPoint, closest: GraphPoint, segStart: GraphPoint, segEnd: GraphPoint, mode: \"TB\" | \"LR\"): void {\r\n            // changes pt\r\n            pt.x = closest.x; pt.y = closest.y; return;\r\n            let main: \"x\" | \"y\", sub: \"x\" | \"y\";\r\n            if (mode === \"TB\") { main = \"y\"; sub = \"x\"; } else { main = \"x\"; sub = \"y\"; }\r\n            pt[main] = closest[main];\r\n            // if T[sub] is inside the top segment, take T[sub], otherwise closest between size.tl[sub] and size.tr[sub]\r\n            // pt[sub] = Math.max(segStart[sub], Math.min(segStart[sub], closest[sub]));\r\n            if (closest[sub] <= segEnd[sub] && closest[sub] >= segStart[sub]) pt[sub] = closest[sub];\r\n            else if (Math.abs(closest[sub]-segEnd[sub]) < Math.abs(closest[sub]-segStart[sub])) pt[sub] = segEnd[sub];\r\n            else pt[sub] = segStart[sub];\r\n        }\r\n        function closestmix2(pt: GraphPoint, closest: GraphPoint, segStart: GraphPoint, segEnd: GraphPoint, mode: \"TB\" | \"LR\"): void {\r\n            // changes closest\r\n            let main: \"x\" | \"y\", sub: \"x\" | \"y\";\r\n            if (mode === \"TB\") { main = \"y\"; sub = \"x\"; } else { main = \"x\"; sub = \"y\"; }\r\n            // closest[main] = pt[main];\r\n            // if T[sub] is inside the top segment, take T[sub], otherwise closest between size.tl[sub] and size.tr[sub]\r\n            // pt[sub] = Math.max(segStart[sub], Math.min(segStart[sub], closest[sub]));\r\n            if (closest[sub] <= segEnd[sub] && closest[sub] >= segStart[sub]) {/*no-op*/}\r\n            else if (Math.abs(closest[sub]-segEnd[sub]) < Math.abs(closest[sub]-segStart[sub])) closest[sub] = segEnd[sub];\r\n            else closest[sub] = segStart[sub];\r\n        }\r\n        console.log(\"intersect pt2.5:\");\r\n        try{\r\n            if(T) closestmix2(pt, T, vertexGSize.tl(), vertexGSize.tr(), \"TB\");\r\n            if(B) closestmix2(pt, B, vertexGSize.bl(), vertexGSize.br(), \"TB\");\r\n            if(R) closestmix2(pt, R, vertexGSize.tr(), vertexGSize.br(), \"LR\");\r\n            if(L) closestmix2(pt, L, vertexGSize.tl(), vertexGSize.bl(), \"LR\");\r\n        } catch(e){ console.error(\"intersect error\",e)}\r\n        // console.log('superstiti step1: (LTBR):', L, T, B, R);\r\n        console.log(\"intersect pt2.9:\");\r\n        const vicinanzaT = !T ? Number.POSITIVE_INFINITY : ((T.x - pt.x) * (T.x - pt.x)) + ((T.y - pt.y) * (T.y - pt.y));\r\n        const vicinanzaB = !B ? Number.POSITIVE_INFINITY : ((B.x - pt.x) * (B.x - pt.x)) + ((B.y - pt.y) * (B.y - pt.y));\r\n        const vicinanzaL = !L ? Number.POSITIVE_INFINITY : ((L.x - pt.x) * (L.x - pt.x)) + ((L.y - pt.y) * (L.y - pt.y));\r\n        const vicinanzaR = !R ? Number.POSITIVE_INFINITY : ((R.x - pt.x) * (R.x - pt.x)) + ((R.y - pt.y) * (R.y - pt.y));\r\n        const closest = Math.min(vicinanzaT, vicinanzaB, vicinanzaL, vicinanzaR);\r\n        console.log(\"intersect pt3:\", {vicinanzaT, vicinanzaB, vicinanzaL, vicinanzaR, closest});\r\n\r\n        // console.log( 'closest:', closest);\r\n        // succede quando pt e prevPt sono entrambi all'interno del rettangolo del vertice.\r\n        // L'edge non è visibile e il valore ritornato è irrilevante.\r\n\r\n        if (closest === Number.POSITIVE_INFINITY) {\r\n            /* top center */\r\n            pt = vertexGSize.tl();\r\n            pt.x += vertexGSize.w / 2; } else\r\n        if (closest === Number.POSITIVE_INFINITY) {\r\n            /* bottom center */\r\n            pt = vertexGSize.br();\r\n            pt.x -= vertexGSize.w / 2; } else\r\n        if (closest === vicinanzaT && T) {\r\n            closestmix(pt, T as any, vertexGSize.tl(), vertexGSize.tr(), \"TB\");\r\n            /*pt.y = T.y;\r\n            // if T.x is inside the top segment, take T.x, otherwise closest between size.tl.x and size.tr.x\r\n            if ((T.x <= tr.x && T.x >= tl.x)) pt.x = T.x;\r\n            else if (Math.abs(T.x-tr.x) < Math.abs(T.x-tl.x)) pt.x = tr.x;\r\n            else pt.x = tl.x;*/\r\n        }\r\n        if (closest === vicinanzaB) { closestmix(pt, B as any, vertexGSize.bl(), vertexGSize.br(), \"TB\"); } else\r\n        if (closest === vicinanzaR) { closestmix(pt, R as any, vertexGSize.tr(), vertexGSize.br(), \"LR\"); } else\r\n        if (closest === vicinanzaL) { closestmix(pt, L as any, vertexGSize.tl(), vertexGSize.bl(), \"LR\"); }\r\n\r\n        if (!gridAlign) { return pt; }\r\n        if (!pt) return null;\r\n        if (gridAlign.x && (pt === T || pt === B || isNaN(closest))) {\r\n            const floorX: number = Math.floor(pt.x / gridAlign.x) * gridAlign.x;\r\n            const ceilX: number = Math.ceil(pt.x / gridAlign.x) * gridAlign.x;\r\n            let closestX;\r\n            let farthestX;\r\n            if (Math.abs(floorX - pt.x) < Math.abs(ceilX - pt.x)) {\r\n                closestX = floorX; farthestX = ceilX;\r\n            } else { closestX = ceilX; farthestX = floorX; }\r\n\r\n            // todo: possibile causa del bug che non allinea punti fake a punti reali. nel calcolo realPT questo non viene fatto.\r\n            // if closest grid intersection is inside the vertex.\r\n            if (closestX >= vertexGSize.x && closestX <= vertexGSize.x + vertexGSize.w) { pt.x = closestX; } else\r\n                // if 2° closer grid intersection is inside the vertex.\r\n            if (closestX >= vertexGSize.x && closestX <= vertexGSize.x + vertexGSize.w) { pt.x = farthestX;\r\n                // if no intersection are inside the vertex (ignore grid)\r\n            } else { /* do nothing */ }\r\n        } else if (gridAlign.y && (pt === L || pt === R)) {\r\n            const floorY: number = Math.floor(pt.y / gridAlign.y) * gridAlign.y;\r\n            const ceilY: number = Math.ceil(pt.y / gridAlign.y) * gridAlign.y;\r\n            let closestY;\r\n            let farthestY;\r\n            if (Math.abs(floorY - pt.y) < Math.abs(ceilY - pt.y)) {\r\n                closestY = floorY; farthestY = ceilY;\r\n            } else { closestY = ceilY; farthestY = floorY; }\r\n\r\n            // if closest grid intersection is inside the vertex.\r\n            if (closestY >= vertexGSize.y && closestY <= vertexGSize.y + vertexGSize.h) { pt.y = closestY; } else\r\n                // if 2° closer grid intersection is inside the vertex.\r\n            if (closestY >= vertexGSize.y && closestY <= vertexGSize.y + vertexGSize.h) { pt.y = farthestY;\r\n                // if no intersection are inside the vertex (ignore grid)\r\n            } else { /* do nothing */ }\r\n        }\r\n        return pt; }\r\n\r\n\r\n    protected new(...args: any): this { return new GraphSize(...args) as this; }\r\n    protected makePoint(x: number, y: number): GraphPoint { return new GraphPoint(x, y) as GraphPoint; }\r\n\r\n    closestPoint(pt: GraphPoint): GraphPoint { return Geom.closestPoint(this, pt); }\r\n}\r\n\r\nRuntimeAccessibleClass.set_extend(RuntimeAccessibleClass, ISize);\r\nRuntimeAccessibleClass.set_extend(ISize, Size);\r\nRuntimeAccessibleClass.set_extend(ISize, GraphSize);\r\n\r\n\r\n\r\nexport type PositionStrTypes =\r\n    \"top\" | \"bottom\" | \"left\" | \"right\" | \"\" | // '' = x&y center, undefined = top\r\n    \"top right\" | \"top left\" | \"bottom left\" | \"bottom right\" |\r\n    \"right top\" | \"left top\" | \"left bottom\" | \"right bottom\" |\r\n    \"t\" | \"b\" | \"l\" | \"r\" |\r\n    \"tl\" | \"tr\" | \"bl\" | \"br\" |\r\n    \"lt\" | \"rt\" | \"lb\" | \"rb\";\r\n\r\n@RuntimeAccessible('PositionStr')\r\nexport class PositionStr{\r\n    public static cname = 'PositionStr';\r\n\r\n    x: -1 | 0 | 1; // left, centered, right\r\n    y: -1 | 0 | 1;\r\n    constructor(x?: PositionStr['x'], y? :PositionStr['y']){\r\n        this.x = x ?? 0;\r\n        this.y = y ?? -1;\r\n    }\r\n    toString(): PositionStrTypes{\r\n        return PositionStr.toPosString(this);\r\n    }\r\n    invert(x = true, y = true): this {\r\n        if (x) this.x = -this.x as 1|0|-1;\r\n        if (y) this.y = -this.y as 1|0|-1;\r\n        return this;\r\n    }\r\n    public static toPosString(o: PositionStr): PositionStrTypes{\r\n        let s: string;\r\n        if (o.y === -1) s = 't';\r\n        else if (o.y === 1) s = 'b';\r\n        else s = '';\r\n\r\n        if (o.x === -1) s += 'l';\r\n        else if (o.x === 1) s += 'r';\r\n        // else s = +'';\r\n        // if (!s) return \"c\";\r\n        return s as PositionStrTypes;\r\n    }\r\n    public static fromPosString(position?: PositionStrTypes): PositionStr{\r\n        let ret = new PositionStr(0, 0);\r\n        let posarr = (position ?? 't').split(' '); // .map(s=>s[0]);\r\n        for (let p of posarr)\r\n            switch (p) {\r\n                default:\r\n                case \"t\": case \"top\":                       ret.y = -1; break;\r\n                case \"b\": case \"bottom\":                    ret.y =  1; break;\r\n                case \"l\": case \"left\":                      ret.x = -1; break;\r\n                case \"r\": case \"right\":                     ret.x =  1; break;\r\n                case \"tl\": case \"lt\": case \"top left\":      ret.y = -1; ret.x = -1; break;\r\n                case \"tr\": case \"rt\": case \"top right\":     ret.y = -1; ret.x =  1; break;\r\n                case '': case 'c':                          ret.x =  0; ret.y =  0; break;\r\n                case \"bl\": case \"lb\": case \"bottom left\":   ret.y =  1; ret.x = -1; break;\r\n                case \"br\": case \"rb\": case \"bottom right\":  ret.y =  1; ret.x =  1; break;\r\n            }\r\n        return ret;\r\n    }\r\n    public static invertPosStr(pos?: PositionStrTypes): PositionStrTypes{\r\n        return PositionStr.fromPosString(pos).invert().toString() as any;\r\n    }\r\n\r\n    private static toFullLabelSingle(position: string | \"\" | \"c\" | \"t\" | \"b\" | \"l\" | \"r\"): \"top\" | \"bottom\" | \"left\" | \"right\" | \"center\" {\r\n        switch (position?.trim()[0]){\r\n            case 'c': case '': return 'center';\r\n            case 't': return 'top';\r\n            default: if (position.trim() === '') return 'center'; return 'bottom';\r\n            case 'b': return 'bottom';\r\n            case 'l': return 'left';\r\n            case 'r': return 'right';\r\n        }\r\n    }\r\n    // tl -> top left\r\n    static toSeparateFullLabels(position?: PositionStrTypes): string {\r\n        let pos = (position ?? 'b').trim();\r\n\r\n        if (pos.length === 2) {\r\n            return PositionStr.toFullLabelSingle(pos[0]) + ' ' + PositionStr.toFullLabelSingle(pos[1]);\r\n        } else if (pos.indexOf(' ')) { return pos.split(' ').map(s => PositionStr.toFullLabelSingle(s as any)).join(' '); }\r\n        else return PositionStr.toFullLabelSingle(pos[0]);\r\n        return \"\";\r\n    }\r\n}\r\n\r\n@RuntimeAccessible('Geom')\r\nexport class Geom extends RuntimeAccessibleClass {\r\n\r\n    static markings: Dictionary<string, HTMLElement> = {};\r\n    static unmark(key: string): boolean{\r\n        if (!Geom.markings[key]) return false;\r\n        let e = Geom.markings[key];\r\n        U.removeFromDom(e);\r\n        delete Geom.markings[key];\r\n        return true;\r\n    }\r\n    static markPt(key: string, pt: Point, color?: string, label?: string): HTMLElement{ return Geom.mark(key, pt.x, pt.y, 1, 1, color, label); }\r\n    static markSize(key: string, pt: Size, color?: string, label?: string): HTMLElement{ return Geom.mark(key, pt.x, pt.y, pt.w??1, pt.h??1, color, label); }\r\n    static mark(key: string, x: number, y: number, w: number=1, h: number=1, color: string='red', label: string=''): HTMLElement{\r\n        if (Geom.markings[key]) Geom.unmark(key);\r\n        let e: HTMLElement;\r\n        let pre = '<div class=\"debug-mark\" data-key=\"'+key+'\" data-label=\"'+label+'\" style=\"position: absolute; z-index:99999; left:'+x+'px; top:'+y+'px; width: '+w+'px; height: '+h+'px;';\r\n        let post = '\"/>';\r\n        if (w + h > 2) {\r\n            e = U.toHtml(pre+'border-radius:0; background: transparent;'+post) as HTMLElement;\r\n        }\r\n        else {\r\n            e = U.toHtml(pre+'border-radius:100%; background: '+color+'; outline: 1px solid '+color+'; outline-offset: 5px;'+post) as HTMLElement;\r\n        }\r\n        document.body.append(e);\r\n        Geom.markings[key] = e;\r\n        return e;\r\n    }\r\n    // warning: nodes from other iframes will say are not instance from Element of the current frame, in that case need duck typing.\r\n    public static isHtmlNode(element: any): element is Element {\r\n        return element instanceof Element || element instanceof HTMLDocument || element instanceof SVGElement;\r\n    }\r\n\r\n\r\n    static isPositiveZero(m: number): boolean {\r\n        if (!!Object.is) { return Object.is(m, +0); }\r\n        return (1 / m === Number.POSITIVE_INFINITY); }\r\n\r\n    static isNegativeZero(m: number): boolean {\r\n        if (!!Object.is) { return Object.is(m, -0); }\r\n        return (1 / m === Number.NEGATIVE_INFINITY); }\r\n\r\n    static TanToRadian(n: number): number { return Geom.DegreeToRad(Geom.TanToDegree(n)); }\r\n    static TanToDegree(n: number): number {\r\n        if (Geom.isPositiveZero(n)) { return 0; }\r\n        if (n === Number.POSITIVE_INFINITY) { return 90; }\r\n        if (Geom.isNegativeZero(n)) { return 180; }\r\n        if (n === Number.POSITIVE_INFINITY) { return 270; }\r\n        return Geom.RadToDegree((window as any).Math.atan(n)); }\r\n\r\n    static RadToDegree(radians: number): number { return Geom.radToDeg(radians); }\r\n    static DegreeToRad(degree: number): number { return Geom.degToRad(degree); }\r\n    static radToDeg(radians: number): number { return radians * (180 / Math.PI); }\r\n    static degToRad(degree: number): number { return degree * (Math.PI / 180); }\r\n\r\n\r\n\r\n    private static GeomTolerance = 0; // 0.001;\r\n    static isOnEdge(pt: GraphPoint, shape: GraphSize, tolerance: number = Geom.GeomTolerance): boolean {\r\n        return Geom.isOnHorizontalEdges(pt, shape, tolerance) || Geom.isOnVerticalEdges(pt, shape, tolerance); }\r\n\r\n    static isOnVerticalEdges(pt: GraphPoint, shape: GraphSize, tolerance: number = Geom.GeomTolerance): boolean {\r\n        return Geom.isOnLeftEdge(pt, shape, tolerance) || Geom.isOnRightEdge(pt, shape, tolerance); }\r\n\r\n    static isOnHorizontalEdges(pt: GraphPoint, shape: GraphSize, tolerance: number = Geom.GeomTolerance): boolean {\r\n        return Geom.isOnTopEdge(pt, shape, tolerance) || Geom.isOnBottomEdge(pt, shape, tolerance); }\r\n\r\n    static isOnRightEdge(pt: GraphPoint, shape: GraphSize, tolerance: number = Geom.GeomTolerance): boolean {\r\n        if (!pt || !shape) { return false; }\r\n        if (tolerance) return Math.abs(pt.x - (shape.x + shape.w)) < tolerance\r\n            && ( pt.y - shape.y > tolerance && pt.y - (shape.y + shape.h) < tolerance);\r\n        return (pt.x === shape.x + shape.w) && (pt.y >= shape.y && pt.y <= shape.y + shape.h);\r\n    }\r\n\r\n    static isOnLeftEdge(pt: GraphPoint, shape: GraphSize, tolerance: number = Geom.GeomTolerance): boolean {\r\n        if (!pt || !shape) { return false; }\r\n        if (tolerance) return Math.abs(pt.x - shape.x) < tolerance\r\n            && (pt.y - shape.y > tolerance && pt.y - (shape.y + shape.h) < tolerance);\r\n        return (pt.x === shape.x) && (pt.y >= shape.y && pt.y <= shape.y + shape.h);\r\n    }\r\n\r\n    static isOnTopEdge(pt: GraphPoint, shape: GraphSize, tolerance: number = Geom.GeomTolerance): boolean {\r\n        if (!pt || !shape) { return false; }\r\n        if (tolerance) return Math.abs(pt.y - shape.y) < tolerance\r\n            && (pt.x - shape.x > tolerance && pt.x - (shape.x + shape.w) < tolerance);\r\n        return (pt.y === shape.y) && (pt.x >= shape.x && pt.x <= shape.x + shape.w);\r\n    }\r\n\r\n    static isOnBottomEdge(pt: GraphPoint, shape: GraphSize, tolerance?: number): boolean {\r\n        if (!pt || !shape) { return false; }\r\n        if (tolerance) return Math.abs(pt.y - shape.y + shape.h) < tolerance\r\n            && (pt.x - shape.x > tolerance && pt.x - (shape.x + shape.w) < tolerance);\r\n        return (pt.y === shape.y + shape.h) && (pt.x >= shape.x && pt.x <= shape.x + shape.w);\r\n    }\r\n\r\n    static closestPoint(size: GraphSize, pt: GraphPoint): GraphPoint {\r\n        let top_closest = Geom.closestPointToSegment(size.tl(), size.tr(), pt);\r\n        let bot_closest = Geom.closestPointToSegment(size.bl(), size.br(), pt);\r\n        let left_closest = Geom.closestPointToSegment(size.tl(), size.bl(), pt);\r\n        let right_closest = Geom.closestPointToSegment(size.tr(), size.br(), pt);\r\n\r\n        let top_distance = top_closest.distanceFromPoint(pt, false);\r\n        let bot_distance = bot_closest.distanceFromPoint(pt, false);\r\n        let left_distance = left_closest.distanceFromPoint(pt, false);\r\n        let right_distance = right_closest.distanceFromPoint(pt, false);\r\n\r\n        let min_distance = Math.min(top_distance, bot_distance, left_distance, right_distance);\r\n        if (min_distance === top_distance) return top_closest;\r\n        if (min_distance === bot_distance) return bot_closest;\r\n        if (min_distance === left_distance) return left_closest;\r\n        return right_closest;\r\n    }\r\n    static isMinusZero(number: number) {return 1/number == -Infinity;}\r\n    static closestPointToSegment(segStart: GraphPoint, segEnd:GraphPoint, pt: GraphPoint): GraphPoint{\r\n        // 1) find equation of line passing for start, end.\r\n        // 2) then find all perpendicular lines, then the perpendicular line that pass through pt\r\n        // 3) find intersection between Line(s,e) and line of point 2.\r\n        // 4A) IF intersection is part of segment(s,e) that is closest.\r\n        // 4B) ELSE, one of the 2 extremes of the segment is closest.\r\n\r\n        let x_intersect: number, y_intersect: number;\r\n        let s = segStart;\r\n        let e = segEnd;\r\n        let mse = (e.y - s.y) / (e.x - s.x);\r\n        if (mse === Number.POSITIVE_INFINITY || mse === Number.NEGATIVE_INFINITY) {\r\n            // s and e are both on the same y vertical line (same x)      // new GraphPoint(segStart.x, pt.y);\r\n            x_intersect = segStart.x;\r\n            y_intersect = pt.y;\r\n            // 1), 2), 3) all done shortcut\r\n        } else if (mse === 0 || Geom.isNegativeZero(mse)) {\r\n            // s and e are both on the same x horizontal line (same y)    // new GraphPoint(pt.x, segStart.y);\r\n            x_intersect = pt.x;\r\n            y_intersect = segStart.y\r\n            // 1), 2), 3) all done shortcut\r\n        }\r\n        else {\r\n            let q = s.y - mse*s.x; // y = mx + q           q = y-mx\r\n            // 1) done\r\n            let pmse = -1/mse; // perpendicular to mse\r\n            let pq = pt.y - pmse*pt.x;\r\n            // 2) done\r\n            //  m1 * x + q1 = y    -->   m1 * x + q1 = m2 * x + q2    -->    (m1-m2)x = q2-q1      -->     x=(q2-q1)/(m1-m2)\r\n            x_intersect = (pq-q)/(mse-pmse);\r\n            y_intersect = mse*(x_intersect) + q; //  y = mx +q\r\n            // 3) done\r\n        }\r\n\r\n        let maxX: number, minX: number;\r\n        let maxY: number, minY: number;\r\n        if (s.x > e.x) { maxX = s.x; minX = e.x; } else {  maxX = e.x; minX = s.x; }\r\n        if (s.y > e.y) { maxY = s.y; minY = e.y; } else {  maxY = e.y; minY = s.y; }\r\n        if (x_intersect >= minX && x_intersect <= maxX && y_intersect >= minY && y_intersect <= maxY) return new GraphPoint(x_intersect, y_intersect);\r\n        // 4A) IF done\r\n\r\n        let sdist = (s.x - x_intersect)**2 + (s.y - y_intersect)**2;  // actual distance is sqrt() of this, but i just need to find closest, not correct distance.\r\n        let edist = (e.x - x_intersect)**2 + (e.y - y_intersect)**2;\r\n        return (sdist < edist) ? new GraphPoint(s.x, s.y) : new GraphPoint(e.x, e.y);\r\n        // 4B) ELSE done\r\n    }\r\n\r\n    static lineToSegmentIntersection(segStart: GraphPoint, segEnd: GraphPoint, q: number, m: number): GraphPoint | undefined {\r\n        if (segStart.x === segEnd.x){\r\n            let y = m*segStart.x + q;\r\n            if (Geom.isNumberBetween(y, segStart.y, segEnd.y)) return new GraphPoint(segStart.x, y);\r\n            else return undefined;\r\n        }\r\n        else if (segStart.y === segEnd.y) {\r\n            let x = (segStart.y-q)/m;\r\n            if (Geom.isNumberBetween(x, segStart.x, segEnd.x)) return new GraphPoint(x, segStart.y);\r\n            else return undefined;\r\n            //\r\n        }\r\n\r\n        let m2 = segStart.getM(segEnd);\r\n        let q2 = IPoint.getQ(segStart, segEnd);\r\n        if (m === m2) {\r\n            if (q2 === q) return segStart; // line and segment coincident\r\n            return undefined; // parallel\r\n        }\r\n        let intersect = Geom.lineToLineIntersection(m, q, m2, q2);\r\n        if (intersect && Geom.isNumberBetween(intersect.x, segStart.x, segEnd.x) && Geom.isNumberBetween(intersect.y, segStart.y, segEnd.y)) return intersect;\r\n        else return undefined;\r\n    }\r\n\r\n    static isNumberBetween(target: number, s: number, e: number): boolean {\r\n        let max = Math.max(s, e);\r\n        let min = Math.min(s, e);\r\n        return target >= min && target <= max; }\r\n\r\n    private static lineToLineIntersection(m: number, q: number, m2: number, q2: number, retIfParallel: any = undefined, retIfCoincident: any = undefined): undefined | GraphPoint {\r\n        if (m === m2) {\r\n            if (q === q2) return retIfCoincident;\r\n            return retIfParallel;\r\n        }\r\n        if (m === Number.POSITIVE_INFINITY || m === Number.NEGATIVE_INFINITY || m2 === Number.POSITIVE_INFINITY || m2 === Number.NEGATIVE_INFINITY) {\r\n            // m or m2 are a vertical line, Q must be invalid too and i don't have a single point of the line.\r\n            // it's actually infinite possible vertical parallel lines.\r\n            return undefined;\r\n        }\r\n        /*\r\n            y = mx + q\r\n            y = nx + w\r\n            -->\r\n            mx + q = nx + w\r\n            -->\r\n            mx - nx = w - q\r\n            -->\r\n            x (m - n) = w - q\r\n            -->\r\n            x = (w - q)/(m - n)\r\n        */\r\n        let x = (q2-q)/(m-m2);\r\n        return new GraphPoint(x, m*x+q); }\r\n    // @param start, end: are for determining direction. every m is a line that can be seen in 2 direction\r\n    static mToRad(m: number, start: GraphPoint, end: GraphPoint): number {\r\n        let rad: number;\r\n        if (start.x === end.x) {\r\n            rad = (start.y < end.y) ? Math.PI * 3/2 :  Math.PI / 2;\r\n        } else {\r\n            // console.log(\"rad diagonal\", {base:  Math.atan(m), add: start.x > end.x, sx: start.x, ex: end.x});\r\n            rad = Math.atan(m) + (start.x > end.x ? 0 : Math.PI);\r\n        }\r\n        return rad; }\r\n\r\n    // intersect a rectangle with a line or segment (if end parameter is specified)\r\n    // @return: [0, 2] intersections\r\n    static lineToSizeIntersection_TODO(size: GraphSize, m: number, startLine: GraphPoint, endIfSegment?: GraphPoint): [] | [GraphPoint] | [GraphPoint, GraphPoint] {\r\n         // todo: use GraphSize.closestIntersection which is close. it is size-segment returning only the closest intersection\r\n        return [];\r\n    }\r\n}\r\n\r\nRuntimeAccessibleClass.set_extend(RuntimeAccessibleClass, Geom);\r\n","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\redux\\createStore.ts",[],"C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\api\\data.ts",["977","978","979","980","981","982","983","984","985","986","987","988","989","990"],"import type {\r\n    Json,\r\n    Pointer,\r\n    GObject,\r\n    Dictionary,\r\n    DocString} from \"../joiner\";\r\nimport {\r\n    Log,\r\n    DModelElement,\r\n    DModel,\r\n    LModel,\r\n    DValue,\r\n    LValue,\r\n    DObject,\r\n    LObject,\r\n    DEnumerator,\r\n    DEnumLiteral,\r\n    DAttribute,\r\n    LAttribute,\r\n    DReference,\r\n    LReference,\r\n    DClassifier,\r\n    DClass,\r\n    LClass,\r\n    DParameter,\r\n    DOperation,\r\n    DPackage,\r\n    LPackage,\r\n    DTypedElement,\r\n    LTypedElement,\r\n    DAnnotation,\r\n    AttribETypes,\r\n    U,\r\n    CreateElementAction,\r\n    Selectors,\r\n    PointedBy,\r\n    LPointerTargetable,\r\n    windoww,\r\n    SetRootFieldAction,\r\n    Constructors,\r\n    store,\r\n    SetFieldAction,\r\n    DPointerTargetable, ShortAttribETypes, toLongEType, DState, Debug\r\n} from \"../joiner\";\r\nimport {DefaultEClasses, ShortDefaultEClasses, toLongEClass} from \"../common/U\";\r\n\r\ntype RET<T = boolean> = T | Promise<T>;\r\ntype Ret = RET;\r\n\r\nclass SavePack{\r\n    model: string;\r\n    vertexpos: string;\r\n    view: string;\r\n    constructor(model: string='', vertexpos: string='', view:string='') {\r\n        this.model = model;\r\n        this.vertexpos = vertexpos;\r\n        this.view = view;\r\n    }\r\n}\r\n\r\ntype JsonSavePack = {[key in keyof SavePack]: Json | null }\r\n\r\n\r\nexport abstract class IStorage{\r\n    static get():IStorage { return Log.exx(\"IStorage.get (static) should be overridden\"); }\r\n    public prefix: string;\r\n    public autosave: boolean;\r\n    constructor(prefix: string, autosave: boolean) {\r\n        this.prefix = prefix;\r\n        this.autosave = autosave;\r\n    }\r\n\r\n\r\n    public del(key: string | number): boolean{\r\n        let isOverwrite = this.get(key) !== null;\r\n        this.set(key, '');\r\n        return isOverwrite; }\r\n    public abstract set(key: string | number, val: string | any): RET;\r\n    get<T extends boolean>(key: string | number, parse: T = false as any): T extends false ? null | string : null | any{ return Log.exx(\"IStorage.get should be overridden\"); }\r\n\r\n    protected serialize(val: any): string { // serialize\r\n        try { return JSON.stringify(val); } catch(e){ return \"\"+val; }\r\n    }\r\n    protected deserialize(val: string): any{ // de-serialize\r\n        try { return JSON.parse(val); } catch(e){ return val; }\r\n    }\r\n    protected set0(val: any): string { return this.serialize(val); }\r\n    protected get0(val: any): string { return this.deserialize(val); }\r\n    protected parse(val: any): string { return this.deserialize(val); }\r\n}\r\n\r\nexport class LocalStorage extends IStorage{\r\n    public static get():LocalStorage {return new LocalStorage(\"_j\", true); }\r\n    private constructor (prefix: string, autosave: boolean) { super(prefix, autosave); }\r\n\r\n    private static KeyList= {lastOpenedModel: \"lastOpenedModel\",lastOpenedView: \"lastOpenedView\",lastOpenedPosition: \"lastOpenedPosition\",}\r\n\r\n\r\n    get<T extends boolean>(key: string | number, parse: T = false as any): T extends false ? null | string : null | any{\r\n        let val = localStorage.getItem(this.prefix+key);\r\n        return parse ? this.parse(val) : val;\r\n    }\r\n\r\n    set(key?: string | number, val?: string | any): boolean {\r\n        val = this.serialize(val);\r\n        // let isOverwrite = localStorage.getItem(this.prefix+key);\r\n        localStorage.set(this.prefix+key, val);\r\n        return true;\r\n    }\r\n\r\n\r\n    public getLastOpened(modelNumber: 1 | 2): SavePack {\r\n        let modelname = \"m\" + modelNumber + \"_\";\r\n        const ret: SavePack = new SavePack();\r\n        ret.model = this.get(modelname + LocalStorage.KeyList.lastOpenedModel, false) || '';\r\n        ret.view = this.get(modelNumber + LocalStorage.KeyList.lastOpenedView, false) || '';\r\n        ret.vertexpos = this.get(modelNumber + LocalStorage.KeyList.lastOpenedPosition, false) || '';\r\n        return ret; }\r\n\r\n    public deleteLastOpened(modelNumber: 1 | 2): void { this.setLastOpened(modelNumber, '', '', ''); }\r\n\r\n    public setLastOpened(modelNumber: 1 | 2, model: string = '', view: string = '', vertex: string = ''): void {\r\n        let modelname = \"m\" + modelNumber + \"_\";\r\n        if (model) this.set(modelname + LocalStorage.KeyList.lastOpenedModel, model);\r\n        else this.del(modelname +  LocalStorage.KeyList.lastOpenedModel);\r\n        if (view) this.set(modelname + LocalStorage.KeyList.lastOpenedView, view);\r\n        else this.del(modelname +  LocalStorage.KeyList.lastOpenedView);\r\n        if (vertex) this.set(modelname + LocalStorage.KeyList.lastOpenedPosition, vertex);\r\n        else this.del(modelname +  LocalStorage.KeyList.lastOpenedPosition); }\r\n\r\n\r\n}\r\n\r\nexport class EcoreParser{\r\n    static supportedEcoreVersions = [\"http://www.eclipse.org/emf/2002/Ecore\"];\r\n    static prefix:string = '@';\r\n\r\n    static parse(ecorejson: GObject | string | null, isMetamodel: boolean, filename: string | undefined, persist: boolean = true): DModelElement[]{\r\n        if (!ecorejson) return [];\r\n        let parsedjson: GObject;\r\n        if (typeof ecorejson === \"string\") try { parsedjson = JSON.parse(ecorejson); } catch(e) { windoww.temp = ecorejson; Log.exx(\"error while parsing json:\", e, ecorejson.substring(0, 1000)); throw e; }\r\n        else parsedjson = ecorejson;\r\n        console.log(\"root parse\", {ecorejson, parsedjson});\r\n        // isMetamodel = !!parsedjson[ECoreRoot.ecoreEPackage];\r\n\r\n        Constructors.paused = true;\r\n        let parsedElements: DModelElement[] = isMetamodel ? EcoreParser.parseM2Model(parsedjson, filename) : EcoreParser.parseM1Model(parsedjson, undefined, filename);\r\n        console.warn(\"parse.result D\", parsedElements);\r\n        this.LinkAllNamesToIDs(parsedElements);\r\n        this.fixNamingConflicts(parsedElements);\r\n        Constructors.paused = false;\r\n        // if (persist) CreateElementAction.newBatch(parsedElements);\r\n        // update m1 object pointers (need them to be persistent to navigate .fathers and get ecore pointer strings using LObject)\r\n        this.fixObjectPointers(parsedElements); // updates dvalue.values from ecore reference to pointers.\r\n        Constructors.persist(parsedElements);\r\n\r\n        windoww.tmpparse = () => LPointerTargetable.wrapAll(parsedElements);\r\n\r\n        this.tempfix_untilopennewtabisdone(parsedElements, isMetamodel);\r\n\r\n        console.log('parsedElem', parsedElements)\r\n        return parsedElements;\r\n    }\r\n\r\n    private static fixObjectPointers(parsedElements: DModelElement[]): void {\r\n        let dobjects: DObject[] = parsedElements.filter(e=>e.className === DObject.cname) as any[];\r\n        let values: DValue[] = parsedElements.filter(e=>e.className === DValue.cname) as any[];\r\n        let lobjects: LObject[] = LPointerTargetable.fromArr(dobjects);\r\n        let m1pointermap: Dictionary<string, LObject> = { }; //    \"//@rootrefname.index@/refname.index/@....etc\"\r\n        for (let o of lobjects){ m1pointermap[o.ecorePointer()] = o; }\r\n        for (let v of values) {\r\n            if (v.isMirage) continue;\r\n            let modified = false;\r\n            let newvalues = v.values.map((e) => {\r\n                if (!m1pointermap[e as any]) return e;\r\n                modified = true;\r\n                console.log(\"m1 pointer resolved:\", {from:e, to:m1pointermap[e as any].id});\r\n                return m1pointermap[e as any].id;\r\n            });\r\n            if (!modified) continue;\r\n            //let lv: LValue = LPointerTargetable.from(v);\r\n            v.values = newvalues;\r\n        }\r\n\r\n    }\r\n    private static tempfix_untilopennewtabisdone(parsedElements: DModelElement[], isMetamodel: boolean) {\r\n        // replaces current model with parsed model. this needs to be removed to open a new tab later on.\r\n        let model: DModel = null as any;\r\n        for (let elem of parsedElements) { if (elem.className === DModel.cname) { model = elem as any; break; } }\r\n        SetRootFieldAction.new(isMetamodel ? \"m2models\" : \"m1models\", model.id, '+=', false); // it is pointer but no need to update pointedby's this time\r\n    }\r\n\r\n    // resolve eCore pointers to Jodel pointers and set the PointedBy\r\n    private static LinkAllNamesToIDs(parsedElements: DModelElement[]): void {\r\n        // todo: è post-parse che legga i nomi e assegni gli id aggiustando le references e extends settati by name. trova i campi temporanei cercando i @ts-ignore\r\n        // update mref, attribute, parameter type\r\n        // update operation exception\r\n        // replace those names with id's\r\n\r\n        let idMap: Dictionary<Pointer, DModelElement> = {};\r\n        let nameMap: Dictionary<string, DModelElement> = {};\r\n        let replacePrimitiveMap: Dictionary<string, DClassifier> = {};\r\n        let d_Estring: DClassifier = Selectors.getAllPrimitiveTypes()[1];\r\n        replacePrimitiveMap[AttribETypes.EString] = d_Estring;\r\n        // todo: do the same for all other primitives\r\n        let state: DState = store.getState();\r\n\r\n        // let longprefixlength = 'ecore:EDataType http://www.eclipse.org/emf/2002/Ecore'.length;\r\n        const typeprefix = \"#//\";\r\n        for (let shortkey in ShortAttribETypes) {\r\n            if (shortkey === ShortAttribETypes.EVoid) continue;\r\n            let shortetype: ShortAttribETypes = (ShortAttribETypes as GObject)[shortkey];\r\n            let longetype: AttribETypes = toLongEType(shortetype);\r\n            let dClassType: DClassifier = Selectors.getPrimitiveType(shortetype, state);\r\n            Log.exDev(!dClassType, \"missing primitive type: \" + shortkey, {shortkey, shortetype, longetype, dClassType, state});\r\n            // the correct one\r\n            replacePrimitiveMap[typeprefix + shortkey] = dClassType; // like \"#//EChar\"\r\n            // fallbacks for missing type instead of crash\r\n            if (!replacePrimitiveMap[shortkey]) replacePrimitiveMap[shortkey] = dClassType;\r\n            if (!replacePrimitiveMap[shortetype]) replacePrimitiveMap[shortetype] = dClassType;\r\n            if (!replacePrimitiveMap[longetype]) replacePrimitiveMap[longetype] = dClassType;\r\n        }\r\n        for (let shortkey in ShortDefaultEClasses) {\r\n            let shortetype: ShortDefaultEClasses = (ShortDefaultEClasses as GObject)[shortkey];\r\n            let longetype: DefaultEClasses = toLongEClass(shortetype);\r\n            let dClassType: DClassifier = Selectors.getDefaultEcoreClass(shortetype, state);\r\n            Log.exDev(!dClassType, \"missing ecore native class: \" + shortkey, {shortkey, shortetype, longetype, dClassType, state});\r\n\r\n            // the correct one\r\n            replacePrimitiveMap[longetype] = dClassType;\r\n            // fallbacks for missing type instead of crash\r\n            if (!replacePrimitiveMap[shortkey]) replacePrimitiveMap[shortkey] = dClassType;\r\n            if (!replacePrimitiveMap[shortetype]) replacePrimitiveMap[shortetype] = dClassType;\r\n            if (!replacePrimitiveMap[longetype]) replacePrimitiveMap[typeprefix + shortkey] = dClassType; // like \"#//EObject\"\r\n        }\r\n\r\n\r\n        for (let ecorename in replacePrimitiveMap) {\r\n            // duplicates are very likely becuase of fallback alias like \"EChar\", but they shouldn't override user-defined class EChar if it exist, so don't throw error.\r\n            if (idMap[replacePrimitiveMap[ecorename].id]) continue;\r\n            idMap[replacePrimitiveMap[ecorename].id] = replacePrimitiveMap[ecorename];\r\n        }\r\n\r\n        // let prereplace = (name: string) => name.replaceAll(\"#//\", \"\");\r\n        let replaceRules = [\"extends\", /*\"extendedBy\",*/ \"exceptions\", \"type\", \"values\"];\r\n        let dobj: GObject & DModelElement;\r\n\r\n        for (dobj of parsedElements) {\r\n            idMap[dobj.id] = dobj;\r\n            if (!dobj.name || dobj.className === DModel.cname) continue; // Model name can be reused internally\r\n            let name = (dobj as GObject).__fullname;\r\n            delete (dobj as GObject).__fullname;\r\n            if (dobj.className === DOperation.cname || dobj.className === DParameter.cname) {\r\n                // operation overload, in this case i create N separate operations, but all references will point to the last operation.\r\n                // empty on purpose, just avoid naming check\r\n            }\r\n                // todo: problem, uml.ecore have \"isComposite\" operation and attribute on sme class \"property\", so who is referenced by \"#//property/isComposite\" ??\r\n            // else Log.exDev(nameMap[typeprefix + name], \"found 2 elements with same name\", {nameMap, dobj, name, shortname: dobj.name, typeprefix});\r\n            else Log.w(!!nameMap[typeprefix + name], \"found 2 elements with same name\", {nameMap, new:dobj, old:nameMap[typeprefix + name], name, shortname: dobj.name, typeprefix});\r\n            nameMap[typeprefix + name] = dobj;\r\n            // nameMap[typeprefix + dobj.name] = dobj; // <eAnnotations source=\"subsets\" references=\"#//Activity/group\"/>\r\n        }\r\n\r\n        for (let replacekey of replaceRules){\r\n            for (dobj of parsedElements) {\r\n                let valtmp: string | string[] = dobj[replacekey] as string | string[];\r\n                if (valtmp === undefined) continue; // for missing properties in a d-object like looking for extends on a dmodel.\r\n                let values: string[]\r\n                let isArray = Array.isArray(valtmp);\r\n                if (isArray) {\r\n                    values = valtmp as string[];\r\n                    dobj[replacekey] = [];\r\n                }\r\n                else {\r\n                    values = [valtmp as string];\r\n                }\r\n                for (let value of values) {\r\n                    if (!value) continue;\r\n                    // console.log(\"fixalltypes\", {replacekey, dobj, value, values});\r\n                    let target: DModelElement = replacePrimitiveMap[value];\r\n                    if (!target) target = nameMap[value];\r\n                    if (!target && value.indexOf(\"ecore:EDataType\") === 0) {\r\n                        Log.ww('found unknown EDataType \"' + value + '\", remapping it to string');\r\n                        target = replacePrimitiveMap[AttribETypes.EString];\r\n                    }\r\n                    /*\r\n                    if (!target && value === \"ecore:EClass platform:/plugin/org.eclipse.emf.ecore/model/Ecore.ecore#//EObject\"){\r\n                        Log.ww('found type Object is not supported yet in metamodel, remapped to EString');\r\n                        target = replacePrimitiveMap[AttribETypes.EString];\r\n                    }*/\r\n                    // if (Pointers.isPointer(value)) { target = value;  if it happen to be a pointer it's a mistake in parser }\r\n                    // (value.indexOf(\"#//\") == 0) && console.log(\"attempt to replace primitive type to his id\", {target, dobj, replacekey, value, replacePrimitiveMap, nameMap, idMap, parsedElements});\r\n\r\n                    if (replacekey === \"extends\") {\r\n                        if (!target) continue;\r\n                        Log.ex(target.className !== DClass.cname, \"found a class attempting to extend an object that is not a class\", {target, dobj, replacePrimitiveMap, nameMap, idMap});\r\n                        (target as DClass).extendedBy.push((dobj as DClass).id);\r\n                    }\r\n                    Log.ex(!target, \"LinkAllNames() can't find type target:\", {value, nameMap, replacePrimitiveMap, dobj, replacekey});\r\n                    if (isArray) dobj[replacekey].push(target.id);\r\n                    else dobj[replacekey] = target.id;\r\n                }\r\n            }\r\n        }\r\n\r\n        // fix from ordinals to Pointer<DEnumLiteral>\r\n        function DfromPtr<T extends DPointerTargetable>(id: Pointer<T>|null|undefined): T{ return !id ? undefined as any : (DPointerTargetable.fromPointer(id, state)); }\r\n        function getLiteral(id: Pointer<DEnumerator>, ordinal: number): DEnumLiteral { return LPointerTargetable.fromD(DfromPtr(id))?.ordinals[ordinal]?.__raw; }\r\n        for (let elem of parsedElements) {\r\n            if (elem.className !== DValue.cname) continue;\r\n            let dval: DValue = elem as DValue;\r\n            let meta: DAttribute | DReference = DfromPtr(dval.instanceof as Pointer<DAttribute|DReference>);\r\n            if (!meta) continue;\r\n            let type: DEnumerator = DfromPtr(meta.type) as DEnumerator;\r\n            if (!type || type.className !== DEnumLiteral.cname) continue;\r\n            let mapper = (v: unknown): Pointer<DEnumLiteral> => {\r\n                if (typeof v !== \"number\") { Log.ee(\"found non-numeric value in a literal value.\", v, dval); return v as any; }\r\n                let l = getLiteral(type.id, v);\r\n                return l ? l.id : v as any;\r\n            }\r\n            dval.values = dval.values.map( mapper );\r\n        }\r\n\r\n        // finally: set all pointedby\r\n        for (let ptrkey of PointedBy.list) for(dobj of parsedElements) {\r\n            let valtmp: string | string[] = dobj[ptrkey] as string | string[];\r\n            let values: string[];\r\n            if (Array.isArray(valtmp)) {\r\n                values = valtmp as string[];\r\n            }\r\n            else {\r\n                if (valtmp === undefined) values = [];\r\n                // if (valtmp === \"modeltmp\") { dobj[ptrkey] = null; values = []; } // because model.father is null, but i want to error check others and let them crash if missing father\r\n                else values = [valtmp as string];\r\n            }\r\n            for (let value of values) {\r\n                if (!value) continue;\r\n                // errore: per operazione.type l'import mi restituisce puntatore a oggetto stringa, ma non è tra gli oggetti parsed\r\n                let target: DModelElement = idMap[value];\r\n                if (target) {\r\n                    target.pointedBy.push(PointedBy.new(\"idlookup.\" + dobj.id + \".\" + ptrkey));\r\n                } else {\r\n                    target = DfromPtr(value);\r\n                    console.log(\"fixalltypes\", {ptrkey, valtmp, dobj, value, values, target, idMap});\r\n                    if (!target) throw new Error(\"target undefined\");\r\n                    SetFieldAction.new(target, \"pointedBy\", PointedBy.new(\"idlookup.\" + dobj.id + \".\" + ptrkey),'+=', false);\r\n                }\r\n            }\r\n        }\r\n        // update superclasses\r\n        this.updateSuperClasses(parsedElements);\r\n    }\r\n\r\n    private static todoGetPrimitiveTypenope(type: AttribETypes.EString | string): Pointer<DClass, 1, 1, LClass> {\r\n        // akready fixed in LinkAllNamesToID\r\n        return 'todoGetPrimitiveType from parser';\r\n    }\r\n\r\n    private static updateSuperClasses(parsedElements: DModelElement[]): void {\r\n        // todo:3\r\n\r\n    }\r\n    private static fixNamingConflicts(parsedElements: DModelElement[]): void {\r\n        // todo:4 final\r\n    }\r\n\r\n    static parseM2Model(json: Json, filename: string | undefined): DModelElement[] {\r\n        let generated: DModelElement[] = [];\r\n        if (!json) { json = {}; }\r\n        let modelname = json[ECoreNamed.namee] as string;\r\n        if (!modelname && filename) {\r\n            let pos = filename.indexOf(\".\");\r\n            modelname = pos === -1 ? filename : filename.substring(0, pos); }\r\n        let dObject: DModel = DModel.new( modelname || \"imported_metamodel_1\", undefined, true, true);\r\n        console.log(\"made model\", json);\r\n        generated.push(dObject); // dObject.father = 'modeltmp' as any;\r\n        // const annotations: Json[] = this.getAnnotations(json); i set them on root package\r\n        // for (let child of annotations) EcoreParser.parseDAnnotation(dObject, child, generated, (dObject as GObject).__fullname + \"/\");\r\n        /// *** specific  *** ///\r\n        // let defPackage: DPackage = DPackage.new(json)\r\n        EcoreParser.parseRootPackage(dObject, json, generated);\r\n        return generated;\r\n    }\r\n\r\n    static parseM2Model_old(json: Json, filename: string | undefined): DModelElement[] {\r\n        let generated: DModelElement[] = [];\r\n        if (!json) { json = {}; }\r\n        let modelname = json[ECoreNamed.namee] as string;\r\n        if (!modelname && filename) {\r\n            let pos = filename.indexOf(\".\");\r\n            modelname = pos === -1 ? filename : filename.substring(0, pos); }\r\n        let dObject: DModel = DModel.new( modelname || \"imported_metamodel_1\", undefined, true, true);\r\n        console.log(\"made model\", json);\r\n        generated.push(dObject); // dObject.father = 'modeltmp' as any;\r\n        /// *** specific  *** ///\r\n        const children = EcoreParser.getChildren(json);\r\n        const annotations = EcoreParser.getAnnotations(json);\r\n        // dObject.name = json[ECoreNamed.namee] as string || \"imported_metamodel_1\";\r\n        console.log(\"made model 2\", children, annotations);\r\n        for (let child of annotations) {\r\n            EcoreParser.parseDAnnotation(dObject, child, generated, 'aaaaaaaaaaaaaaaaaaaaaaaaaaaa');\r\n        }\r\n        console.log(\"made annotations\");\r\n        for (let child of children) {\r\n            EcoreParser.parseRootPackage(dObject, child, generated);\r\n        }\r\n        console.log(\"made packages\");\r\n        return generated;\r\n    }\r\n\r\n    static parseM1Model(json: Json, meta?: LModel, filename?: string): DModelElement[] {\r\n        let generated: DModelElement[] = [];\r\n        if (!json) { json = {}; }\r\n        /// *** specific  *** ///\r\n        // this.parseDObject(json, dObject, DModel,undefined, generated);\r\n        let allmodels: DModel[];\r\n        if (!meta && filename) {\r\n            allmodels = Selectors.getAll(DModel);\r\n            allmodels = allmodels.filter( (m) => m.name === filename);\r\n            meta = LPointerTargetable.fromD(allmodels[0]);\r\n        } else allmodels = [];\r\n\r\n        let xmlns =  EcoreParser.XMLinlineMarker + \"xmlns:\";\r\n        let ns: string | undefined = undefined as any;\r\n        function findns(key: string): false | string {\r\n            let pos = key.indexOf(\":\");\r\n            if (pos <= 0) return false;\r\n            return ns = key.substring(0, pos); // through namespace before the name of the root objects;\r\n            // additional method: through xmlns key\r\n            // if (key.indexOf(xmlns)) continue; // \"-xmlns:org.eclipse.example.modelname\": \"https://org/eclipse/example/modelname\",\r\n            // ns = key.substring(xmlns.length); break;\r\n        }\r\n        outerloop: for (let key0 in json) { // ns can be at most in sublevel 3, this is annoying but i need it at beginning of parsing\r\n            if (findns(key0)) break;\r\n            let val0 = json[key0];\r\n            if (typeof val0 === \"object\") for (let key1 in val0) {\r\n                if (findns(key0)) break outerloop;\r\n            }\r\n        }\r\n        if (ns && !meta) {\r\n            let allpkgs: LPackage[] = Selectors.getAll(DPackage, undefined, undefined, true, true);\r\n            let matchpkg: LPackage[] = allpkgs.filter( (d) => d.uri === ns);\r\n            meta = matchpkg[0]?.model;\r\n            // Log.exDev(!meta, \"metamodel not found: \", {ns, json, filename, allmodels, allpkgs, matchpkg}) // todo: after tests remove this check and allow shapeless models.\r\n        }\r\n\r\n        let modelname = '';\r\n        if (!modelname && filename) {\r\n            let pos = filename.indexOf(\".\");\r\n            modelname = (pos === -1 ? filename : filename.substring(0, pos)); }\r\n        let dObject: DModel = DModel.new( modelname || \"imported_model_1\", meta?.id, false, true);\r\n        console.log(\"made model\", json);\r\n        generated.push(dObject);\r\n\r\n        for (let key in json) {\r\n            switch(key) {\r\n                case ECoreObject.xmi_version: // this is only on roots\r\n                    Log.ex(json[key] !== \"2.0\",\"The only supported ecore version is \\\"2.0\\\", found instead: \\\"\"+json[key] +\"\\\"\");\r\n                    break;\r\n                // case ECoreObject.xmlnsecore:\r\n                case ECoreObject.xmlns_xmi:\r\n                    let expected = \"http://www.omg.org/XMI\";\r\n                    Log.ex(json[key] !== expected,\"Unexpected XMI schema. Should be \\\"\"+expected+\"\\\", found instead: \\\"\"+json[key] +\"\\\"\");\r\n                    break;\r\n                default: // a feature name\r\n                    let val = json[key];\r\n                    if (!val) continue;\r\n                    if (key.indexOf(xmlns) === 0) continue; // \"-xmlns:org.eclipse.example.modelname\": \"https://org/eclipse/example/modelname\",\r\n                    if (key[0] === EcoreParser.XMLinlineMarker) key = key.substring(EcoreParser.XMLinlineMarker.length);\r\n\r\n                    const namespacedclass: string = key;\r\n                    const mmclass: LClass | undefined = meta && meta.getClassByNameSpace(namespacedclass);\r\n                    if (!mmclass) console.log(\"failed to get mmclass\", {meta, key, mmclass})\r\n                    const roots_for_this_metaclass: Json[] = Array.isArray(val) ? val : [val]; // there might be N roots of class A, M of type B...\r\n                    for(let rootjson of roots_for_this_metaclass) {\r\n                        // DObject.new(mmclass.id, dObject.id, DModel, undefined, true)\r\n                        EcoreParser.parseDObject(rootjson, dObject, DModel, mmclass, generated);\r\n                    }\r\n            }\r\n        }\r\n        return generated;\r\n    }\r\n    /*\r\n    {\r\n      \"org.eclipse.example.bowling:League\": { <-- :classroot\r\n        \"-xmlns:xmi\": \"http://www.omg.org/XMI\",\r\n        \"-xmlns:org.eclipse.example.bowling\": \"https://org/eclipse/example/bowling\",\r\n        \"-xmi:version\": \"2.0\",\r\n        \"Players\": [\r\n          { \"-name\": \"tizio\" },\r\n          { \"-name\": \"asd\" }\r\n        ]\r\n      }\r\n    }\r\n    */\r\n\r\n\r\n    /// In Ecore parsing when you find a value list, it is possible to recover only the type for the meta-feature,<br>\r\n    /// but an array of Mammals might have some Whales, Pigs, etc mixed in. and you have to get the correct subclass for each\r\n    static getobjectmetaclass(json: Json, metaSuperClass: LClass): LClass {\r\n        return metaSuperClass; // todo: comment this and execute below\r\n        let subclasses: LClass[] | [] = !metaSuperClass ? [] : [metaSuperClass];\r\n        let subclasseshapes: Dictionary<Pointer<DClass>, {l: LClass } & Dictionary<DocString<\"feature name\">,  LTypedElement[\"type\"]/*feature type*/>> = {}\r\n        for (let sc of subclasses) {\r\n            subclasseshapes[sc.id] = {l: sc};\r\n            let row = subclasseshapes[sc.id];\r\n            for (let feat of sc.children) {\r\n                let lfeat: LTypedElement = feat as any;\r\n                let dfeat: DTypedElement = lfeat.__raw as any;\r\n                if (!dfeat.name || !dfeat.type) continue;\r\n                row[dfeat.name] = lfeat.type;\r\n            }\r\n        }\r\n        return this.findBestMatch(subclasseshapes, json);\r\n    }\r\n    static findBestMatch(\r\n        m2classes: Dictionary<Pointer<DClass>,  {l: LClass } & Dictionary<DocString<\"feature name\">, LTypedElement[\"type\"]>>,\r\n        json: Dictionary<DocString<\"feature name\">, any/*actual val instead of type*/>): LClass{\r\n        throw new Error(\"todo\");\r\n        return null as any;\r\n    }\r\n    static parseDObject(json: Json, parent: DModel | DValue, parentType: typeof DModel | typeof DValue, meta: LClass | undefined, generated: DModelElement[]): DModelElement[]{\r\n        if (!json) { json = {}; }\r\n        meta = meta && this.getobjectmetaclass(json, meta);\r\n        // let dObject: DObject = DObject.new(meta?.id, parent.id, parentType, json[\"name\"] as string || \"obj_1\");\r\n        // let data: Partial<DObject> = {};\r\n        let dObject: DObject = DObject.new(meta?.id, parent.id, parentType, json[\"name\"] as string || \"obj_1\");\r\n        generated.push(dObject); dObject.father = parent.id;\r\n        if (parent) {\r\n            if (parentType === DModel) (parent as DModel).objects.push(dObject.id);\r\n            else (parent as DValue).values.push(dObject.id);\r\n        }\r\n        console.log(\"made dobject\", {json, dObject, meta, metaname: meta?.name});\r\n        /// *** specific  *** ///\r\n        for (let key in json) {\r\n            switch(key) {\r\n                case ECoreObject.xmi_version: // this is only on roots\r\n                    Log.ex(json[key] !== \"2.0\",\"The only supported ecore version is \\\"2.0\\\", found instead: \\\"\"+json[key] +\"\\\"\");\r\n                    break;\r\n                // case ECoreObject.xmlnsecore:\r\n                case ECoreObject.xmlns_xmi:\r\n                    let expected = \"http://www.omg.org/XMI\";\r\n                    Log.ex(json[key] !== expected,\"Unexpected XMI schema. Should be \\\"\"+expected+\"\\\", found instead: \\\"\"+json[key] +\"\\\"\");\r\n                    break;\r\n                default: // a feature name\r\n                    let val = json[key];\r\n                    if (!val) continue;\r\n                    if (key[0] === EcoreParser.XMLinlineMarker) key = key.substring(1);\r\n                    if (key.indexOf(\"xmlns:\") === 0) continue; // \"-xmlns:org.eclipse.example.modelname\": \"https://org/eclipse/example/modelname\",\r\n                    let metafeature: LAttribute | LReference | undefined = meta && (meta as any)[\"@\"+key];\r\n                    console.log(\"feature meta\", {json, dObject, key, val, metafeature, classmeta: meta});\r\n                    let values: any[];\r\n                    if (Array.isArray(val)) values = val;\r\n                    else if (val as unknown === undefined) values = [];\r\n                    else values = [val];\r\n                    EcoreParser.parseDValue(key, values, dObject/*father*/, metafeature/*meta*/, generated);\r\n                // DValue.new(key, metafeature?.id, values, dObject, true, false);\r\n            }\r\n        }\r\n        return generated;\r\n    }\r\n\r\n    private static parseDValue(name:string | undefined, jsonvalues: any[], parent: DObject, meta: LAttribute | LReference | undefined, generated: DModelElement[]): DModelElement[] {\r\n        if (!jsonvalues) { jsonvalues = []; }\r\n        // let dObject: DObject = DObject.new(meta?.id, parent.id, parentType, json[\"name\"] as string || \"obj_1\");\r\n        console.log(\"DValue.new(meta ? undefined : name, meta?.id, jsonvalues, parent.id, true, false)\")\r\n        console.log(\"DValue.new(\", meta ? undefined : name, \",\",meta?.id, \",\",jsonvalues, \",\",parent.id);\r\n        let dValue: DValue = DValue.new(meta ? undefined : name, meta?.id, [], parent.id, true, false);\r\n        generated.push(dValue); dValue.father = parent.id;\r\n        parent.features.push(dValue.id);\r\n        console.log(\"made dValue\", {jsonvalues, dValue, meta, metaname: meta?.name});\r\n        if (meta && meta.className === DAttribute.cname) { dValue.values = jsonvalues; return generated; }\r\n\r\n        for (let v of jsonvalues) {\r\n            if (typeof v !== \"object\") { dValue.values.push(v); continue; }\r\n            // let subdObject: DObject = DObject.new((meta as LReference)?.type.id, parent.id, DValue, undefined);\r\n            // generated.push(subdObject);\r\n            EcoreParser.parseDObject(v, dValue, DValue, (meta as LReference)?.type, generated);\r\n        }\r\n        return generated;\r\n    }\r\n\r\n    static parseDAnnotation(parent: DModelElement, json: Json, generated: DModelElement[], fullnamePrefix: string): DModelElement[] {\r\n        return []; // todo\r\n        if (!generated) generated = [];\r\n        if (!json) { json = {}; }\r\n        let dObject: DAnnotation = DAnnotation.new();\r\n        generated.push(dObject); dObject.father = parent.id;\r\n        (dObject as any).name = this.read(json, ECoreNamed.namee, undefined);\r\n        dObject.father = parent.id;\r\n        if (parent) parent.annotations.push(dObject.id);\r\n        const annotations: Json[] = this.getAnnotations(json);\r\n        for (let child of annotations) EcoreParser.parseDAnnotation(dObject, child, generated, (dObject as GObject).__fullname + \"/\");\r\n        (dObject as GObject).__fullname = undefined; // fullnamePrefix + \"/\" + (dObject as any).name; // if annotation is not named (and it shouldn't) i don't wanna override container name\r\n        /// *** specific  *** ///\r\n        let key: string;\r\n        for (key in json){\r\n            const value = json[key];\r\n            switch (key) { //todo\r\n                default: Log.exx('unexpected field in EAnnotation:  ' + key + ' => |' + value + '|', {key, value, json}); break;\r\n                // case ECoreAnnotation.annotations: break; // todo: enable, yes annotations can have annotations\r\n                case ECoreAnnotation.details: break;\r\n                case ECoreAnnotation.references: break;\r\n                case ECoreAnnotation.source: break;\r\n            }\r\n        }\r\n        // annotation.referencesStr = this.read(json, ECoreAnnotation.source, '#/');\r\n        // annotation.name = this.read(json, ECoreAnnotation.name, 'EAnnotation_1');\r\n        // const details: Json[] = this.getDetails(json);\r\n        // for (let i = 0; i < details.length; i++) { new EAnnotationDetail(this, details[i]); }\r\n        return generated; }\r\n\r\n    static parseRootPackage(parent: DModel, json: Json, generated: DModelElement[]): DModelElement[] {\r\n        if (!generated) generated = [];\r\n        if (!json) { json = {}; }\r\n        const childs = this.getChildren(json);\r\n\r\n        let dObject: DPackage = DPackage.new();\r\n        generated.push(dObject); dObject.father = parent.id;\r\n        if (parent) parent.packages.push(dObject.id);\r\n\r\n        let version = (json[EcoreParser.prefix+\"xmlns:ecore\"] || '') as string;\r\n        // model.xmi = json[EcoreParser.prefix+\"xmlns:xmi\"]; // http://www.omg.org/XMI\r\n        // model.xsi = json[EcoreParser.prefix+\"xmlns:xsi\"]; // http://www.w3.org/2001/XMLSchema-instance\r\n        Log.ex(!EcoreParser.supportedEcoreVersions.includes(version), \"unsupported ecore version, must be one of:\" + EcoreParser.supportedEcoreVersions + \" found instead: \"+version);\r\n        dObject.name = this.read(json, ECoreNamed.namee, 'default');\r\n        // root package name is \"transparent\" and not applied in \"#//reference/paths/...\", if referenced i guess his name is \"#//\"\r\n        (dObject as GObject).__fullname = ''; // fullnamePrefix + \"/\" + dObject.name;\r\n        const annotations: Json[] = this.getAnnotations(json);\r\n        for (let child of annotations) EcoreParser.parseDAnnotation(dObject, child, generated, (dObject as GObject).__fullname + \"/\");\r\n        /// *** specific start *** ///\r\n        const subPackages: Json[] = this.getSubPackages(json);\r\n        dObject.uri = this.read(json, ECorePackage.nsURI, null);\r\n        dObject.prefix = this.read(json, ECorePackage.nsPrefix, null);\r\n        console.warn(\"parseRootPackage.children\", {childs, annotations, subPackages, dObject, generated});\r\n        // if (!parent.uri) parent.uri = dObject.uri;\r\n        // if (!parent.prefix) parent.prefix = dObject.prefix; // namespace\r\n        for (let child of childs) {\r\n            switch (child[ECoreClass.xsitype]) {\r\n                default: Log.exx('unexpected xsitype:', child[ECoreClass.xsitype], ' found in jsonfragment:', child, ', in json:', json, ' package:', dObject); break;\r\n                case 'ecore:EClass': this.parseDClass(dObject, child, generated, ''); break;\r\n                case 'ecore:EEnum': this.parseDEnum(dObject, child, generated, ''); break;\r\n            }\r\n        }\r\n        for (let child of subPackages) EcoreParser.parseSubPackage(dObject, child, generated, '');\r\n        /// *** specific end *** ///\r\n        return generated; }\r\n\r\n    static parseSubPackage(parent: DPackage, json: Json, generated: DModelElement[], fullnamePrefix: string): DModelElement[] {\r\n        if (!generated) generated = [];\r\n        if (!json) { json = {}; }\r\n        const childs = this.getChildren(json);\r\n        let dObject: DPackage = DPackage.new();\r\n        generated.push(dObject); dObject.father = parent.id;\r\n        if (parent) parent.subpackages.push(dObject.id);\r\n        dObject.name = this.read(json, ECoreNamed.namee, 'subPackage_1');\r\n        (dObject as GObject).__fullname = fullnamePrefix + dObject.name;\r\n        const annotations: Json[] = this.getAnnotations(json);\r\n        for (let child of annotations) EcoreParser.parseDAnnotation(dObject, child, generated, (dObject as GObject).__fullname + \"/\");\r\n        /// *** specific start *** ///\r\n        dObject.uri = this.read(json, ECoreSubPackage.nsURI, null);\r\n        dObject.prefix = this.read(json, ECoreSubPackage.nsPrefix, null);\r\n        const subPackages: Json[] = this.getSubPackages(json);\r\n        console.warn(\"parseSubPackage.children\", {childs, annotations, subPackages, dObject, generated});\r\n        // if (!dObject.uri) dObject.uri = dObject.name + \".\" + parent.uri;\r\n        // if (!dObject.prefix) dObject.prefix = dObject.name + \".\" + parent.prefix; // namespace\r\n        for (let child of childs) {\r\n            switch (child[ECoreClass.xsitype]) {\r\n                default: Log.exx('unexpected xsitype:', child[ECoreClass.xsitype], ' found in jsonfragment:', child, ', in json:', json, ' package:', dObject); break;\r\n                case 'ecore:EClass': this.parseDClass(dObject, child, generated, (dObject as GObject).__fullname + \"/\"); break;\r\n                case 'ecore:EEnum': this.parseDEnum(dObject, child, generated, (dObject as GObject).__fullname + \"/\"); break;\r\n            }\r\n        }\r\n        for (let child of subPackages) EcoreParser.parseSubPackage(dObject, child, generated, (dObject as GObject).__fullname + \"/\");\r\n        /// *** specific end *** ///\r\n        return generated; }\r\n\r\n    static parseDClass(parent: DPackage, json: Json, generated: DModelElement[], fullnamePrefix: string): DModelElement[] {\r\n        if (!generated) generated = [];\r\n        if (!json) { json = {}; }\r\n        let dObject: DClass = DClass.new(\r\n            this.read(json, ECoreNamed.namee, 'Concept 1'),\r\n            undefined as any, undefined as any, undefined as any, undefined as any, undefined, parent.id,\r\n        );\r\n        generated.push(dObject);// dObject.father = parent.id;\r\n        //if (parent) parent.classifiers.push(dObject.id);\r\n        //dObject.name = this.read(json, ECoreNamed.namee, 'Class_1');\r\n        (dObject as GObject).__fullname = fullnamePrefix + dObject.name;\r\n        const annotations: Json[] = this.getAnnotations(json);\r\n        for (let child of annotations) EcoreParser.parseDAnnotation(dObject, child, generated, (dObject as GObject).__fullname + \"/\");\r\n        /// *** specific start *** ///\r\n        for (let key in json) {\r\n            switch (key) {\r\n                default: Log.exx('unexpected field in parseDClass() |' + key + '|', json); break;\r\n                case ECoreClass.eAnnotations:\r\n                case ECoreClass.instanceTypeName:\r\n                case ECoreClass.eSuperTypes:\r\n                case ECoreClass.xsitype:\r\n                case ECoreClass.eOperations:\r\n                case ECoreClass.eStructuralFeatures:\r\n                case ECoreClass.abstract:\r\n                case ECoreClass.interface:\r\n                case ECoreClass.namee: break; } }\r\n        dObject.instanceClassName = this.read(json, ECoreClass.instanceTypeName, '');\r\n        dObject.interface = this.read(json, ECoreClass.interface, 'false') === 'true';\r\n        dObject.abstract = this.read(json, ECoreClass.abstract, 'false') === 'true';\r\n        let tmps: string = this.read(json, ECoreClass.eSuperTypes, '');\r\n        dObject.extends = tmps.split(' ');\r\n        const features: Json[] = this.getChildren(json);\r\n        const functions: Json[] = this.getChildren(json, false, true);\r\n\r\n        for (let child of functions) this.parseDOperation(dObject, child, generated, (dObject as GObject).__fullname + \"/\");\r\n        for (let child of features) {\r\n            const xsiType = this.read(child, ECoreAttribute.xsitype);\r\n            switch (xsiType) {\r\n                default: Log.exx( 'unexpected xsi:type: ', xsiType, ' in feature:', child); break;\r\n                case 'ecore:EAttribute':\r\n                    this.parseDAttribute(dObject, child, generated, (dObject as GObject).__fullname + \"/\"); break;\r\n                case 'ecore:EReference':\r\n                    this.parseDReference(dObject, child, generated, (dObject as GObject).__fullname + \"/\"); break;\r\n            }\r\n        }\r\n        /// *** specific end *** ///\r\n        return generated; }\r\n\r\n    static parseDEnum(parent: DPackage, json: Json, generated: DModelElement[], fullnamePrefix: string): DModelElement[] {\r\n        if (!generated) generated = [];\r\n        if (!json) { json = {}; }\r\n        const childs = this.getChildren(json);\r\n        let dObject: DEnumerator = DEnumerator.new();\r\n        generated.push(dObject); dObject.father = parent.id;\r\n        if (parent) parent.classifiers.push(dObject.id);\r\n        dObject.name = this.read(json, ECoreNamed.namee, 'Enum_1');\r\n        (dObject as GObject).__fullname = fullnamePrefix + dObject.name;\r\n        const annotations: Json[] = this.getAnnotations(json);\r\n        for (let child of annotations) EcoreParser.parseDAnnotation(dObject, child, generated, (dObject as GObject).__fullname + \"/\");\r\n        /// *** specific start *** ///\r\n        for (let key in json) {\r\n            const value = json[key];\r\n            switch (key) {\r\n                default: Log.exx('Enum.parse() unexpected key:', key, 'in json:', json); break;\r\n                case ECoreEnum.eAnnotations:\r\n                case ECoreEnum.xsitype: case ECoreNamed.namee: break;\r\n                case ECoreEnum.eLiterals: break;\r\n                case ECoreEnum.serializable: dObject.serializable = value === 'true'; break;\r\n                case ECoreEnum.instanceTypeName: dObject.instanceClassName = value + ''; break;\r\n            }\r\n        }\r\n        for (let child of childs) {\r\n            this.parseDEnumLiteral(dObject, child, generated, (dObject as GObject).__fullname + \"/\");\r\n        }\r\n\r\n        /// *** specific end *** ///\r\n        return generated; }\r\n\r\n\r\n\r\n    static parseDEnumLiteral(parent: DEnumerator, json: Json, generated: DModelElement[], fullnamePrefix: string): DModelElement[] {\r\n        if (!generated) generated = [];\r\n        if (!json) { json = {}; }\r\n        const childs = this.getChildren(json);\r\n        let dObject: DEnumLiteral = DEnumLiteral.new();\r\n        generated.push(dObject); dObject.father = parent.id;\r\n        if (parent) parent.literals.push(dObject.id);\r\n        const annotations: Json[] = this.getAnnotations(json);\r\n        for (let child of annotations) EcoreParser.parseDAnnotation(dObject, child, generated, (dObject as GObject).__fullname + \"/\");\r\n        /// *** specific start *** ///\r\n        dObject.value = +this.read(json, EcoreLiteral.value, Number.NEGATIVE_INFINITY);//vv4\r\n        dObject.literal = this.read(json, EcoreLiteral.literal, '');\r\n        dObject.name = this.read(json, ECoreNamed.namee,  dObject.literal || 'literal_1');\r\n        (dObject as GObject).__fullname = fullnamePrefix + dObject.name;\r\n        /// *** specific end *** ///\r\n        return generated; }\r\n\r\n    static parseDAttribute(parent: DClass, json: Json, generated: DModelElement[], fullnamePrefix: string): DModelElement[] {\r\n        if (!generated) generated = [];\r\n        if (!json) { json = {}; }\r\n        const childs = this.getChildren(json);\r\n        // done: old approach does not set pointedBy, i should set father and all pointers in .new() parameters\r\n        let dObject: DAttribute = DAttribute.new(\r\n            this.read(json, ECoreNamed.namee, 'attr_1'),\r\n            this.read(json, ECoreAttribute.eType, AttribETypes.EString),\r\n            parent.id,\r\n        );\r\n        generated.push(dObject);// dObject.father = parent.id;\r\n        // if (parent) parent.attributes.push(dObject.id);\r\n        //dObject.name = this.read(json, ECoreNamed.namee, 'attr_1');\r\n        (dObject as GObject).__fullname = fullnamePrefix + dObject.name;\r\n        const annotations: Json[] = this.getAnnotations(json);\r\n        for (let child of annotations) EcoreParser.parseDAnnotation(dObject, child, generated, (dObject as GObject).__fullname + \"/\");\r\n        /// *** specific start *** ///\r\n        dObject.lowerBound = +this.read(json, ECoreAttribute.lowerbound, 0);\r\n        dObject.upperBound = +this.read(json, ECoreAttribute.upperbound, 1);\r\n        //dObject.type = this.read(json, ECoreAttribute.eType, AttribETypes.EString);\r\n        /// *** specific end *** ///\r\n        return generated; }\r\n\r\n    static parseDReference(parent: DClass, json: Json, generated: DModelElement[], fullnamePrefix: string): DModelElement[] {\r\n        if (!generated) generated = [];\r\n        if (!json) { json = {}; }\r\n        const childs = this.getChildren(json);\r\n        let dObject: DReference = DReference.new();\r\n        generated.push(dObject); dObject.father = parent.id;\r\n        if (parent) parent.references.push(dObject.id);\r\n        dObject.name = this.read(json, ECorePackage.namee, 'Ref_1');\r\n        (dObject as GObject).__fullname = fullnamePrefix + dObject.name;\r\n        const annotations: Json[] = this.getAnnotations(json);\r\n        for (let child of annotations) EcoreParser.parseDAnnotation(dObject, child, generated, (dObject as GObject).__fullname + \"/\");\r\n        /// *** specific start *** ///\r\n        dObject.composition = U.fromBoolString(this.read(json, ECoreReference.containment, false), false);\r\n        dObject.container = U.fromBoolString(this.read(json, ECoreReference.container, false), false);\r\n        dObject.lowerBound = +this.read(json, ECoreAttribute.lowerbound, 0);\r\n        dObject.upperBound = +this.read(json, ECoreAttribute.upperbound, 1);\r\n        dObject.type = this.read(json, ECoreReference.eType, this.getEcoreTypeName(parent));\r\n        /// *** specific end *** ///\r\n        return generated; }\r\n\r\n    static parseDParameter(parent: DOperation, json: Json, generated: DModelElement[], fullnamePrefix: string): DModelElement[] {\r\n        if (!generated) generated = [];\r\n        if (!json) { json = {}; }\r\n        const childs = this.getChildren(json);\r\n        let dObject: DParameter = DParameter.new();\r\n        generated.push(dObject); dObject.father = parent.id;\r\n        if (parent) parent.parameters.push(dObject.id);\r\n        dObject.name = this.read(json, ECoreNamed.namee, 'arg1');\r\n        (dObject as GObject).__fullname = fullnamePrefix + dObject.name;\r\n        const annotations: Json[] = this.getAnnotations(json);\r\n        for (let child of annotations) EcoreParser.parseDAnnotation(dObject, child, generated, (dObject as GObject).__fullname + \"/\");\r\n        /// *** specific start *** ///\r\n        dObject.lowerBound = +this.read(json, ECoreAttribute.lowerbound, 0);\r\n        dObject.upperBound = +this.read(json, ECoreAttribute.upperbound, 1);\r\n        dObject.type = this.read(json, ECoreAttribute.eType, AttribETypes.EString);\r\n        dObject.ordered = U.fromBoolString(this.read(json, ECoreOperation.ordered, 'false'), false);\r\n        dObject.unique = U.fromBoolString(this.read(json, ECoreOperation.unique, 'false'), false);\r\n        /// *** specific end *** ///\r\n        return generated; }\r\n\r\n    static parseDOperation(parent: DClass, json: Json, generated: DModelElement[], fullnamePrefix: string): DModelElement[] {\r\n        if (!generated) generated = [];\r\n        if (!json) { json = {}; }\r\n        const childs = this.getChildren(json);\r\n        let dObject: DOperation = DOperation.new();\r\n        generated.push(dObject); dObject.father = parent.id;\r\n        if (parent) parent.operations.push(dObject.id);\r\n        dObject.name = this.read(json, ECoreNamed.namee, 'operation_1');\r\n        (dObject as GObject).__fullname = fullnamePrefix + dObject.name;\r\n\r\n        const annotations: Json[] = this.getAnnotations(json);\r\n        for (let child of annotations) EcoreParser.parseDAnnotation(dObject, child, generated, (dObject as GObject).__fullname + \"/\");\r\n        /// *** specific start *** ///\r\n        dObject.lowerBound = +this.read(json, ECoreAttribute.lowerbound, 1);\r\n        dObject.upperBound = +this.read(json, ECoreAttribute.upperbound, 1);\r\n        dObject.type = this.read(json, ECoreAttribute.eType, AttribETypes.EString);\r\n        dObject.exceptions = [this.read(json, ECoreOperation.eexceptions, '')];\r\n        dObject.ordered = U.fromBoolString(this.read(json, ECoreOperation.ordered, 'false'));\r\n        dObject.unique = U.fromBoolString(this.read(json, ECoreOperation.unique, 'false'));\r\n        dObject.visibility = AccessModifier.package;\r\n        for (let child of childs) {\r\n            this.parseDParameter(dObject, child, generated, (dObject as GObject).__fullname + \"/\");\r\n        }\r\n        /// *** specific end *** ///\r\n        return generated; }\r\n\r\n\r\n    /*\r\n    static parseTEMPLATE(parent: DSomething, json: Json, generated: DModelElement[], fullnamePrefix: string): DModelElement[] {\r\n        if (!generated) generated = [];\r\n        if (!json) { json = {}; }\r\n        const childs = this.getChildren(json);\r\n        let dObject: DSomething = DSomething.new();\r\n        generated.push(dObject); dObject.father = parent.id;\r\n        if (parent) parent.CHILDCOLLECTION.push(dObject.id);\r\n        dObject.name = this.read(json, ECoreNamed.namee, defaultNameTODO);\r\n        (dObject as GObject).__fullname = fullnamePrefix + dObject.name;\r\n        const annotations: Json[] = this.getAnnotations(json);\r\n        for (let child of annotations) EcoreParser.parseDAnnotation(dObject, child, generated, (dObject as GObject).__fullname + \"/\");\r\n        /// *** specific start *** ///\r\n        for (let child of childs) {\r\n            this.parseDSOMETHING(dObject, child, generated, (dObject as GObject).__fullname + \"/\");\r\n        }\r\n        /// *** specific end *** ///\r\n        return generated; }*/\r\n\r\n\r\n\r\n\r\n\r\n    /////////////////////////////////// generic\r\n    static XMLinlineMarker: string = '@';\r\n    static classTypePrefix: string = '#//'\r\n    private static getSubPackages(thiss: Json): Json[] {\r\n        const ret: any = thiss[ECoreSubPackage.eSubpackages];\r\n        if (!ret || U.isEmptyObject(ret)) { return []; }\r\n        if (Array.isArray(ret)) { return ret; } else { return [ret]; } }\r\n\r\n    private static getAnnotations(thiss: Json): Json[] {\r\n        const ret: any = thiss[ECorePackage.eAnnotations];\r\n        if (!ret || U.isEmptyObject(ret)) { return []; }\r\n        if (Array.isArray(ret)) { return ret; } else { return [ret]; } }\r\n\r\n    private static getDetails(thiss: Json): Json[] {\r\n        const ret: any = thiss[ECoreAnnotation.details];\r\n        if (!ret || U.isEmptyObject(ret)) { return []; }\r\n        if (Array.isArray(ret)) { return ret; } else { return [ret]; } }\r\n\r\n    private static getChildren(thiss: Json, throwError: boolean = false, functions: boolean = false): Json[] {\r\n        if (!thiss && !throwError) { return []; }\r\n        const mod = thiss[ECoreRoot.ecoreEPackage];\r\n        const pkg = thiss[ECorePackage.eClassifiers];\r\n        const cla = thiss[functions ? ECoreClass.eOperations : ECoreClass.eStructuralFeatures];\r\n        const fun = thiss[ECoreOperation.eParameters];\r\n        const lit = thiss[ECoreEnum.eLiterals];\r\n\r\n        const ret: any = mod || pkg || cla || fun || lit;\r\n        /*if ( ret === undefined || ret === null ) {\r\n          if (thiss['@name'] !== undefined) { ret = thiss; } // if it's the root with only 1 child arrayless\r\n        }*/\r\n        Log.ex( throwError && !ret, 'getChildren() Failed: ', thiss, ret);\r\n        // console.log('ret = ', ret, ' === ', {}, ' ? ', (U.isEmptyObject(ret) ? [] : [ret]));\r\n        if (!ret || U.isEmptyObject(ret)) { return []; }\r\n        if (Array.isArray(ret)) { return ret; } else { return [ret]; }\r\n    }\r\n\r\n    private static read(json: Json, field: string, valueIfNotFound: any = 'read<T>()CanThrowError'): string {\r\n        let ret: any = json ? json[field] : null;\r\n        if (ret !== null && ret !== undefined && field.indexOf(this.XMLinlineMarker) !== -1) {\r\n            Log.ex(U.isObject(ret, false, false, true), 'inline value |' + field + '| must be primitive.', ret);\r\n            ret = U.multiReplaceAll('' + ret, ['&amp;', '&#38;', '&quot;'], ['&', '\\'', '\"']);\r\n        }\r\n        if ((ret === null || ret === undefined)) {\r\n            Log.ex(valueIfNotFound === 'read<T>()CanThrowError', 'this.read<',  '> failed: field[' + field + '], json: ', json);\r\n            return valueIfNotFound; }\r\n        return ret; }\r\n\r\n    static write(json: Json, field: string, val: string | any[]): string | any[] {\r\n        if (val !== null && field.indexOf(EcoreParser.XMLinlineMarker) !== -1) {\r\n            Log.ex(val !== '' + val, 'inline value |' + field + '| must be a string.', val);\r\n            val = U.multiReplaceAll(val as string, ['&', '\\'', '\"'], ['&amp;', '&#38;', '&quot;']);\r\n        }\r\n        else Log.ex(val !== '' + val || !U.isObject(val, true), 'primitive values should be inserted only inline in the xml:', field, val);\r\n        json[field] = val;\r\n        return val; }\r\n\r\n    private static getEcoreTypeName(parent: DClassifier): string {\r\n        if (parent.className === DEnumerator.cname || parent.className === DClass.cname) return this.classTypePrefix + this.name;\r\n        // return Type.classTypePrefix + parent.parent.name; problem: need L-object to navigate\r\n        return Log.exx(\"getEcoreTypeName failed\", parent);\r\n    }\r\n\r\n}\r\n\r\nexport enum AccessModifier {\r\n    public = 'public',\r\n    private = 'private',\r\n    protected = 'protected',\r\n    internal = 'internal',\r\n    package = 'package',\r\n    protectedinternal = 'protected internal',\r\n    protectedprivate = 'protected private', }\r\n\r\nexport class ECoreRoot {\r\n    static ecoreEPackage: string;\r\n}\r\n\r\nexport class ECoreAnnotation {\r\n    static source: string;\r\n    static references: string;\r\n    static details: string;}\r\n\r\nexport class ECoreNamed {\r\n    static namee: string; }\r\n\r\nexport class ECoreDetail {\r\n    static key: string;\r\n    static value: string; }\r\n\r\nexport class ECoreSubPackage { // <eSubpackages\r\n    static eSubpackages: string;\r\n    static eAnnotations: string;\r\n    static eClassifiers: string;\r\n    static nsURI: string;\r\n    static nsPrefix: string;\r\n    static namee: string;\r\n}\r\n\r\nexport class ECorePackage extends ECoreSubPackage {\r\n    static eAnnotations: string;\r\n    static eSubpackages: string;\r\n    static eClassifiers: string;\r\n    static xmlnsxmi: string;\r\n    static xmlnsxsi: string;\r\n    static xmiversion: string;\r\n    static xmlnsecore: string;\r\n    static nsURI: string;\r\n    static nsPrefix: string;\r\n    static namee: string;\r\n}\r\n\r\nexport class ECoreClass {\r\n    static eAnnotations: string;\r\n    static eStructuralFeatures: string;\r\n    static xsitype: string;\r\n    static namee: string;\r\n    static eOperations: string;\r\n    static instanceTypeName: string;\r\n    static eSuperTypes: string;\r\n    static abstract: string;\r\n    static interface: string;\r\n\r\n    // static defaultValue = EcoreParser.XMLinlineMarker + 'defaultValue';  // visualizzato in ecore ma mai salvato dentro il file. inutilizzato\r\n    // nelle classi, assume il valore di \"[name] = [NumericValue]\" senza le [] negli enum.\r\n}\r\n\r\nexport class ECoreEnum {\r\n    static eAnnotations: string;\r\n    static xsitype: string;\r\n    static namee: string;\r\n    static instanceTypeName: string;\r\n    static serializable: string;\r\n    static eLiterals: string;\r\n}\r\n\r\nexport class EcoreLiteral {\r\n    static eAnnotations: string;\r\n    static namee: string;\r\n    static value: string;\r\n    static literal: string;\r\n}\r\n\r\n\r\nexport class ECoreReference {\r\n    static eAnnotations: string;\r\n    static xsitype: string;\r\n    static eType: string;\r\n    static containment: string;\r\n    static container: string;\r\n    static upperbound: string;\r\n    static lowerbound: string;\r\n    static namee: string; }\r\n\r\nexport class ECoreAttribute {\r\n    static eAnnotations: string;\r\n    static xsitype: string;\r\n    static eType: string;\r\n    static namee: string;\r\n    static lowerbound: string;\r\n    static upperbound: string;\r\n}\r\n\r\nexport class ECoreOperation {\r\n    static eAnnotations: string;\r\n    static eType: string;\r\n    static eexceptions: string;\r\n    static upperBound: string;\r\n    static lowerBound: string;\r\n    static unique: string;\r\n    static ordered: string;\r\n    static namee: string;\r\n    static eParameters: string; }\r\n\r\nexport class ECoreParameter {\r\n    static eAnnotations: string;\r\n    static namee: string;\r\n    static ordered: string;\r\n    static unique: string;\r\n    static lowerBound: string;\r\n    static upperBound: string;\r\n    static eType: string;\r\n}\r\n\r\nexport class ECoreObject{\r\n    static xmlns_xmi: string;\r\n    static xmlns_uri: never; // \"-xmlns:org.eclipse.example.modelname\": \"https://org/eclipse/example/modelname\", <b>key is dynamic</b>\r\n    static xmi_version: string;\r\n}\r\nexport class XMIModel {\r\n    static type: string;\r\n    static namee: string; }\r\n\r\n\r\n///////////////\r\n\r\nECoreRoot.ecoreEPackage = 'ecore:EPackage'; // this is root tag but not in xml->json, just his attributes/childrens\r\nECoreNamed.namee = EcoreParser.XMLinlineMarker + 'name';\r\n\r\nECorePackage.eAnnotations = ECoreSubPackage.eAnnotations = ECoreClass.eAnnotations =\r\n    ECoreEnum.eAnnotations = EcoreLiteral.eAnnotations =  ECoreReference.eAnnotations =\r\n        ECoreAttribute.eAnnotations = ECoreOperation.eAnnotations = ECoreParameter.eAnnotations = 'eAnnotations';\r\n\r\nECoreAnnotation.source = EcoreParser.XMLinlineMarker + 'source';\r\nECoreAnnotation.references = EcoreParser.XMLinlineMarker + 'references'; // \"#/\" for target = package.\r\nECoreAnnotation.details = 'details'; // arr\r\nECoreDetail.key = EcoreParser.XMLinlineMarker + 'key'; // can have spaces\r\nECoreDetail.value = EcoreParser.XMLinlineMarker + 'value';\r\n\r\nECorePackage.eSubpackages = 'eSubpackages';\r\nECorePackage.eClassifiers = 'eClassifiers';\r\nECorePackage.xmlnsxmi = EcoreParser.XMLinlineMarker + 'xmlns:xmi'; // typical value: http://www.omg.org/XMI\r\nECorePackage.xmlnsxsi = EcoreParser.XMLinlineMarker + 'xmlns:xsi'; // typical value: http://www.w3.org/2001/XMLSchema-instance\r\nECorePackage.xmiversion = EcoreParser.XMLinlineMarker + 'xmi:version'; // typical value: \"2.0\"\r\nECorePackage.xmlnsecore = EcoreParser.XMLinlineMarker + 'xmlns:ecore';\r\nECorePackage.nsURI = EcoreParser.XMLinlineMarker + 'nsURI'; // typical value: \"http://org/eclipse/example/modelname\"\r\nECorePackage.nsPrefix = EcoreParser.XMLinlineMarker + 'nsPrefix'; // typical value: org.eclipse.example.modelname\r\nECorePackage.namee = EcoreParser.XMLinlineMarker + 'name';\r\n\r\nECoreSubPackage.eSubpackages = 'eSubpackages';\r\nECoreSubPackage.eClassifiers = 'eClassifiers';\r\nECoreSubPackage.nsURI = EcoreParser.XMLinlineMarker + 'nsURI'; // typical value: \"http://org/eclipse/example/modelname\"\r\nECoreSubPackage.nsPrefix = EcoreParser.XMLinlineMarker + 'nsPrefix'; // typical value: org.eclipse.example.modelname\r\nECoreSubPackage.namee = EcoreParser.XMLinlineMarker + 'name';\r\n\r\n\r\nECoreClass.eStructuralFeatures = 'eStructuralFeatures';\r\nECoreClass.eOperations = 'eOperations';\r\nECoreClass.xsitype = EcoreParser.XMLinlineMarker + 'xsi:type'; // \"ecore:EClass\"\r\nECoreClass.namee = ECorePackage.namee;\r\nECoreClass.eSuperTypes = EcoreParser.XMLinlineMarker + 'eSuperTypes'; // space separated: \"#name1 #name2\"...\r\nECoreClass.instanceTypeName = EcoreParser.XMLinlineMarker + 'instanceTypeName';  // raw str\r\nECoreClass.instanceTypeName = EcoreParser.XMLinlineMarker + 'instanceTypeName';\r\nECoreClass.abstract = EcoreParser.XMLinlineMarker + 'abstract'; // bool\r\nECoreClass.interface = EcoreParser.XMLinlineMarker + 'interface'; // bool\r\n\r\nECoreEnum.instanceTypeName = ECoreClass.instanceTypeName;\r\nECoreEnum.serializable = 'serializable'; // \"false\", \"true\"\r\nECoreEnum.xsitype = ECoreClass.xsitype; // \"ecore:EEnum\"\r\nECoreEnum.eLiterals = 'eLiterals';\r\nECoreEnum.namee = ECorePackage.namee;\r\n\r\nEcoreLiteral.literal = 'literal';\r\nEcoreLiteral.namee = ECorePackage.namee;\r\nEcoreLiteral.value = 'value'; // any integer (-inf, +inf), not null. limiti = a type int 32 bit? vv4\r\n\r\nECoreReference.xsitype = EcoreParser.XMLinlineMarker + 'xsi:type'; // \"ecore:EReference\"\r\nECoreReference.eType = EcoreParser.XMLinlineMarker + 'eType'; // \"#//Player\"\r\nECoreReference.containment = EcoreParser.XMLinlineMarker + 'containment'; // \"true\"\r\nECoreReference.upperbound = EcoreParser.XMLinlineMarker + 'upperBound'; // \"@1\"\r\nECoreReference.lowerbound = EcoreParser.XMLinlineMarker + 'lowerBound'; // does even exists?\r\nECoreReference.namee = EcoreParser.XMLinlineMarker + 'name';\r\n\r\nECoreAttribute.xsitype = EcoreParser.XMLinlineMarker + 'xsi:type'; // \"ecore:EAttribute\",\r\nECoreAttribute.eType = EcoreParser.XMLinlineMarker + 'eType'; // \"ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EString\"\r\nECoreAttribute.namee = EcoreParser.XMLinlineMarker + 'name';\r\nECoreAttribute.lowerbound = EcoreParser.XMLinlineMarker + 'lowerBound';\r\nECoreAttribute.upperbound = EcoreParser.XMLinlineMarker + 'upperBound';\r\n\r\n\r\nECoreOperation.eParameters = 'eParameters';\r\nECoreOperation.namee = EcoreParser.XMLinlineMarker + 'name'; // \"EExceptionNameCustom\",\r\nECoreOperation.ordered = EcoreParser.XMLinlineMarker + 'ordered'; // \"false\",\r\nECoreOperation.unique = EcoreParser.XMLinlineMarker + 'unique'; // \"false\",\r\nECoreOperation.lowerBound = EcoreParser.XMLinlineMarker + 'lowerBound'; // \"5\", ma che senso ha su una funzione?? è il return?\r\nECoreOperation.upperBound = EcoreParser.XMLinlineMarker + 'upperBound';\r\nECoreOperation.eType = EcoreParser.XMLinlineMarker + 'eType'; // \"#//Classname\",\r\nECoreOperation.eexceptions = EcoreParser.XMLinlineMarker + 'eExceptions';\r\n// \"#//ClassnameException1 #//ClassNameException2 (also custom classes) ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EInt\r\n\r\nECoreParameter.namee = EcoreParser.XMLinlineMarker + 'name';\r\nECoreParameter.ordered = EcoreParser.XMLinlineMarker + 'ordered'; // \"false\";\r\nECoreParameter.unique = EcoreParser.XMLinlineMarker + 'unique'; // \"false\"\r\nECoreParameter.lowerBound = EcoreParser.XMLinlineMarker + 'lowerBound'; // \"1\"\r\nECoreParameter.upperBound = EcoreParser.XMLinlineMarker + 'upperBound'; // \"2\"\r\nECoreParameter.eType = EcoreParser.XMLinlineMarker + 'eType'; // \"ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EDoubl\r\n\r\nECoreObject.xmlns_xmi = EcoreParser.XMLinlineMarker + 'xmlns:xmi'; // \"http://www.omg.org/XMI\"\r\n// ECoreObject.xmlns_uri = EcoreParser.XMLinlineMarker + 'xmlns:org.eclipse.example.modelname'; // \"https://org/eclipse/example/modelname\"\r\nECoreObject.xmi_version = EcoreParser.XMLinlineMarker + 'xmi:version'; // \"2.0\"\r\n\r\nXMIModel.type = EcoreParser.XMLinlineMarker + 'type';\r\nXMIModel.namee = EcoreParser.XMLinlineMarker + 'name';\r\n\r\n","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\redux\\action\\action.ts",["991","992","993","994","995","996"],"import {\r\n    Constructors,\r\n    Dictionary,\r\n    DocString,\r\n    DPointerTargetable,\r\n    DState,\r\n    DUser,\r\n    GObject,\r\n    Json,\r\n    Log,\r\n    LPointerTargetable,\r\n    orArr,\r\n    Pack1,\r\n    Pointer,\r\n    Pointers,\r\n    RuntimeAccessible,\r\n    RuntimeAccessibleClass,\r\n    store,\r\n    U,\r\n    unArr,\r\n    windoww\r\n} from \"../../joiner\";\r\n\r\n// transactional-like start of storage modification\r\n// todo: nested transaction che conti quanti begin hai effettuato e crei una matrice di pendingActions una per ogni livello nested?\r\n\r\n/*\r\n// let nestedlevel: number = 0;\r\nclass NestedLevel{\r\n    level: number;\r\n    actions: Action[] = [];\r\n    up:NestedLevel[] = [];\r\n    down?:NestedLevel;\r\n\r\n    constructor(prevLevel?: NestedLevel, actions: Action[] = []) {\r\n        // this.prev = prev;\r\n        this.down = prevLevel;\r\n        this.actions = actions;\r\n        this.level = prevLevel ? prevLevel.level + 1 : 0;\r\n    }\r\n\r\n    add1(a:Action){ this.actions.push(a); }\r\n    add(a:Action[]){ this.actions.push(...a); }\r\n    push(actions:Action[]=[]){\r\n        this.up.push(new NestedLevel(this, actions));\r\n    }\r\n}\r\n// @Singleton\r\nclass NestedTransactionManager{\r\n    // private levels: NestedLevel[] = [];\r\n    public currentLevel?: NestedLevel;\r\n    // simple array is not good i can have spikes as russian mountains going up and down in deepness it's kinda a matrix or a pile of dishes like below'\r\n\r\n\r\n    /*\r\n    todo: to debug missing END paired with a begin, seve stack trace of begins and ends\r\n    * every level must have his own array?\r\n    * Begin0, Begin1, Begin2, End2, End1, Begin1.1 Begin 1.2....\r\n    it's a tree!\r\n    *\r\n    *\r\n    * ______begin lv2                              _______Begin1.2\r\n    * _________________________begin lv1           ___________________Begin1.1\r\n    * ____________________________________________________________________________________________________ a begin lv0\r\n    * * /\r\n    constructor() {}\r\n    begin(actions: Action[]=[]): void { this.pushLevel(actions); }\r\n    pushLevel(actions: Action[]=[]): void {\r\n        if (!this.currentLevel) { this.currentLevel = new NestedLevel(undefined, actions); return; }\r\n        this.currentLevel.push(actions); }\r\n    end(){\r\n        if (!this.currentLevel) return this.finalEnd();\r\n        this.currentLevel = this.currentLevel?.down; }\r\n    finalEnd(){\r\n\r\n    }\r\n    // current(): NestedLevel { return this.currentLevel; }\r\n    addActions(a:Action[]): void { this.currentLevel!.add(a); }\r\n    addAction(a:Action): void { this.currentLevel!.add1(a); }\r\n}\r\nlet transactionmanager = new NestedTransactionManager();\r\nfunction BEGIN2(){\r\n    transactionmanager.pushLevel();\r\n}\r\nfunction ABORT2(){\r\n    transactionmanager.end();\r\n}\r\nfunction END2(){\r\n\r\n}*/\r\n\r\nclass TransactionStatus{\r\n    pendingActions: Action[] = [];\r\n    hasBegun: boolean = false;\r\n    hasAborted: boolean = false;\r\n    transactionDepthLevel: number = 0;\r\n}\r\nlet t = new TransactionStatus();\r\nwindoww.transactionStatus = t;\r\n\r\nexport function BEGIN() {\r\n    if (t.transactionDepthLevel === 0) t.hasAborted = false;\r\n    t.hasBegun = true; // redundant but actions are reading this, minimize changes\r\n    t.transactionDepthLevel++;\r\n}\r\nexport function ABORT(): boolean {\r\n    let ret: boolean = t.transactionDepthLevel > 0;\r\n    t.hasAborted = true; // at any depth level since i have only a flat TRANSACTION array\r\n    END();\r\n    return ret;\r\n}\r\n// if without parameter: commits the current pending stuff, with parameter: fires the action ignoring transaction block while keeping te transaction active\r\nexport function COMMIT(action?:Action): boolean {\r\n    let olddepth = t.transactionDepthLevel;\r\n    if (olddepth<=0) {\r\n        END(); //just safety to restore has begun state, should be necessary.\r\n        action?.fire();\r\n        return false;\r\n    }\r\n    t.transactionDepthLevel = 1;\r\n    END();\r\n    action?.fire();\r\n    t.transactionDepthLevel = olddepth-1;\r\n    BEGIN();\r\n    return true;\r\n}\r\n\r\nexport function END(actionstoPrepend: Action[] = [], path?: string, oldval?: any, newval?: any, desc?:string): boolean {\r\n    t.transactionDepthLevel--;\r\n    if (actionstoPrepend.length) t.pendingActions = [...actionstoPrepend, ...t.pendingActions];\r\n\r\n    if (t.transactionDepthLevel < 0) { console.error(\"mismatching END()\"); t.transactionDepthLevel = 0; }\r\n    if (t.transactionDepthLevel === 0) return FINAL_END(path, oldval, newval, desc);\r\n    return false;\r\n}\r\nfunction FINAL_END(path?: string, oldval?: any, newval?: any, desc?:string): boolean{\r\n    t.hasBegun = false;\r\n    // pendingActions.sort( (a, b) => a.timestamp - b.timestamp)\r\n    if (t.hasAborted) {\r\n        t.pendingActions = [];\r\n        t.hasAborted = false;\r\n        return false;\r\n    }\r\n    const ca: CompositeAction = new CompositeAction(t.pendingActions, false);\r\n    if (lastDescription) {\r\n        path = lastDescription.name;\r\n        oldval = lastDescription.oldval;\r\n        newval = lastDescription.newval;\r\n        desc = lastDescription.desc;\r\n        lastDescription = undefined;\r\n    }\r\n    if (path) ca.descriptor = new ActionDescriptor(path, oldval, newval, desc);\r\n    t.pendingActions = [];\r\n    return ca.fire();\r\n}\r\nexport class ActionDescriptor{\r\n    path?: string;\r\n    desc?: string;\r\n    oldval: any;\r\n    newval: any;\r\n    public constructor (path?: string, oldval?: any, newval?: any, desc?:string){\r\n        this.path = path;\r\n        this.oldval = oldval;\r\n        this.newval = newval;\r\n        this.desc = desc;\r\n    }\r\n}\r\ntype NotPromise<T> = T extends Promise<any> ? never : T;\r\n\r\ntype NoAsyncFn<\r\n    T extends (...args: any)=>any,\r\n    ReturnsPromise extends (...args: any)=>any = ReturnType<T> extends Promise<any> ? never:T\r\n    >=ReturnsPromise;\r\n\r\nlet lastDescription: {name: string, oldval: any, newval: any, desc?: string} | undefined = undefined;\r\n(window as any).getLastDesc = () => lastDescription;\r\n// make class isinstorage e mettici il path studia annotazioni per annotare gli oggett in modo che vengano rwappati prima di farli ritornare se sono annotati\r\n// minor todo: type as (...args: infer P) => any) ?\r\n// NB: cannot be async, it changes execution order and break many codes where return value is determined in a transaction.\r\n// also because BEGIN() becomes stuck and actions cannot fire until the server replies or times out.\r\n// export function TRANSACTION<F extends (...args: any)=>any>(func: NoAsyncFn<F>, ...params: Parameters<F>): boolean | DState {\r\nexport function TRANSACTION(name:string, func: ()=> void, oldval?: any, newval?: any, desc?:string): boolean {\r\n//export function TRANSACTION<F extends NoAsyncFn)>(func: F, ...params: Parameters<F>): boolean | DState {\r\n    BEGIN();\r\n    if (!lastDescription) lastDescription = {name, oldval, newval, desc};\r\n    let e: Error = null as any;\r\n    try { func(); } catch(err: any) { e = err; ABORT(); }\r\n    if (t.hasAborted) {\r\n        if (e) Log.ee('Transaction failed:', e);\r\n        else Log.ee('Transaction aborted.');\r\n        return false;\r\n    }\r\n    return END([]);\r\n}\r\n(window as any).TRANSACTION = TRANSACTION;\r\n(window as any).BEGIN = BEGIN;\r\n(window as any).ABORT = ABORT;\r\n(window as any).END = END;\r\n(window as any).FINAL_END = FINAL_END;\r\n(window as any).maxActionFiring = 0;\r\n\r\n// todo: ma non so come, fare in modo che [], +=, -=, siano disponibili solo se la chiave è il nome di un attributo di tipo array\r\ntype arrayFieldNameTypes<D> = keyof D | `${string & keyof D}[]` | `${string & keyof D}+=` | `${string & keyof D}-=` | `${string & keyof D}.${number}` | `${string & keyof D}[${number}]`;\r\ntype AccessModifier = '' | '[]' | '+=' | '-=' | `.${number}` | `[${number}]` | undefined;\r\ntype StrictExclude<T, U> = T extends U ? U extends T ? never : T : T;\r\n\r\n@RuntimeAccessible('Action')\r\nexport class Action extends RuntimeAccessibleClass {\r\n    public static cname: string = \"Action\";\r\n    public static maxCounter: number = 1;\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static type = 'ACTION';\r\n    static SubType: {\r\n        vertexSubElements: 'vertexSubElements',\r\n        vertexSize: 'vertexSize'\r\n    };\r\n    field: string;\r\n    value: any;\r\n    id: Pointer;\r\n    timestamp: number;\r\n    sender: Pointer<DUser>;\r\n    hasFired: number = 0;\r\n    // targetID: string | undefined;\r\n    // target: IClass = null as any;\r\n    consoleTargetSelector: string = '';\r\n    // field: string = ''; // es: ID_58\r\n    // value: any; // es: lowerbound, name, namespace, values (for attrib-ref)...\r\n    type: string;\r\n    // private src?: string[];\r\n    subType?: string; //?\r\n    private stack?: string[];\r\n    protected constructor(field: string, value: any, subType?: string) {\r\n        super();\r\n        this.id = 'Action_' + Date.now() + \"_\" + Action.maxCounter++; // NB: the prefix must be the same for all actions because it must not affect order\r\n        this.timestamp = Date.now();\r\n        this.sender = DUser.current;\r\n        this.field = field;\r\n        this.value = value;\r\n        this.type = (this.constructor as any).type;\r\n        this.stack = new Error().stack?.split('\\n').splice( 4);\r\n        this.subType = subType;\r\n        this.className = (this.constructor as typeof RuntimeAccessibleClass).cname || this.constructor.name;\r\n    }\r\n\r\n    // forces the action to fire alone ignoring a TRANSACTION or BEGIN/END blocks\r\n    commit(): boolean{\r\n        return COMMIT(this);\r\n    }\r\n    fire(forceRelaunch: boolean = false): boolean {\r\n        if (this.hasFired && !forceRelaunch) return false;\r\n        if (this.value && this.value.__isProxy) {\r\n            Log.ee(\"Attempted to set a proxy object inside the store.\", {action:this, value: this.value});\r\n            return false;\r\n        }\r\n        this.hasFired++;\r\n        if (t.hasBegun) {\r\n            t.pendingActions.push(this);\r\n        } else {\r\n            // if ((window as any).maxActionFiring++ >= 400) return false;\r\n            let storee = store || windoww.store;\r\n            let printobj: GObject = {};\r\n            if (this.className === CompositeAction.cname) {\r\n                let ca: CompositeAction = this as any;\r\n                printobj.title = ca.descriptor?.path;\r\n                printobj.desc = ca.descriptor;\r\n                printobj.n = ca.actions?.length || 1;\r\n            }\r\n            else {\r\n                printobj.field = this.field;\r\n                printobj.val = this.value\r\n            }\r\n            printobj['this'] = this;\r\n            printobj['stack'] = this.stack;\r\n            console.log('firing action:', printobj);\r\n            storee.dispatch({...this});\r\n        }\r\n        return true;\r\n    }\r\n\r\n    public static possibleInconsistencies: Dictionary<DocString<'subtype'>, Pointer[]> = {};\r\n    private static parse1(action: Action): ParsedAction {\r\n        const ret: ParsedAction = action as any;\r\n        ret.path = action.field; // normalize the path\r\n        ret.pathArray = ret.path.split('.');\r\n        ret.executionCount = 0;\r\n        if (!action.subType) return ret;\r\n        if (!Action.possibleInconsistencies[action.subType]) Action.possibleInconsistencies[action.subType] = [ action.value ];\r\n        else Action.possibleInconsistencies[action.subType].push(action.value);\r\n        return ret;\r\n    }\r\n\r\n    static parse<T extends Action | Action[], RET extends T extends any[] ? ParsedAction[] : ParsedAction>(actions: T): RET {\r\n        if ((actions as Action).className === CompositeAction.cname) throw new Error(\"Composite action cannot be parsed directly, parse composite.actions instead\");\r\n        if (!Array.isArray(actions)) return Action.parse1(actions) as RET;\r\n        return actions.map( Action.parse1 ) as RET;\r\n    }\r\n\r\n    static fromJson(json: Json): Action{\r\n        let action = new Action('dummy', 'dummy');\r\n        for(let key in action) delete (action as GObject)[key]; // resetting the action\r\n        for(let key in json) (action as any)[key] = json[key];\r\n        return action;\r\n    }\r\n}\r\n\r\n@RuntimeAccessible('LoadAction')\r\nexport class LoadAction extends Action {\r\n    public static cname: string = \"LoadAction\";\r\n    static type = 'LOAD';\r\n    static new(state: DState | GObject): boolean { return state && new LoadAction(state).fire(); }\r\n    static create(state: DState | GObject): LoadAction { return state && new LoadAction(state); }\r\n\r\n    constructor(state: DState | GObject, fire: boolean = true) {\r\n        super('', state, '');\r\n        this.className = (this.constructor as typeof RuntimeAccessibleClass).cname || this.constructor.name;\r\n        if (fire) this.fire();\r\n    }\r\n}\r\n\r\n@RuntimeAccessible('SetRootFieldAction')\r\nexport class SetRootFieldAction extends Action {\r\n    public static cname: string = \"SetRootFieldAction\";\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static type = 'SET_ROOT_FIELD';\r\n    isPointer: boolean;\r\n\r\n    static create(fullpath: string, val: string | string[], accessModifier: AccessModifier | undefined, isPointer: boolean): SetRootFieldAction;\r\n    static create<\r\n        VAL extends any,\r\n        PATH extends VAL extends string | string[] ? 'must specify \"isPointer\" parameter' : string,\r\n        // VAL extends (AM extends undefined | '' ? D[T] : (AM extends '-=' ? number[] : (AM extends '+=' | '[]' | `[${number}]` | `.${number}` ? unArr<D[T]> | D[T] | D[T][] : '_error_'))),\r\n        /*VAL extends (AM extends undefined | '' ? (D[T] extends any[] ? StrictExclude<D[T], string[]> : StrictExclude<D[T], string>) :\r\n            (AM extends '-=' ?\r\n                number[] :\r\n                (AM extends '+=' | '[]' | `[${number}]` | `.${number}` ? unArr<StrictExclude<D[T], string>> | StrictExclude<D[T], string> | (StrictExclude<D[T], string>)[] : '_error_'))),\r\n        */\r\n        ISPOINTER extends boolean,\r\n        AM extends AccessModifier | undefined = undefined,\r\n        // T extends arrayFieldNameTypes<D> = any\r\n        >(fullpath: PATH, val: VAL, accessModifier?: AM | undefined, isPointer?: ISPOINTER): SetRootFieldAction;\r\n    static create<\r\n        T extends string,\r\n        VAL extends any,\r\n        ISPOINTER extends boolean,\r\n        AM extends AccessModifier | undefined = undefined,\r\n        // T extends arrayFieldNameTypes<D> = any\r\n        >(fullpath: T, val: VAL, accessModifier: AM | undefined = undefined, isPointer?: ISPOINTER): SetRootFieldAction {\r\n        if (accessModifier) (fullpath as any) += accessModifier;\r\n        return new SetRootFieldAction(fullpath, val, false, isPointer);\r\n    }\r\n    static new(...a:Parameters<(typeof SetRootFieldAction)[\"create\"]>): boolean{ return SetRootFieldAction.create(...a).fire();}\r\n\r\n    protected constructor(fullpath: string, value: any = undefined, fire: boolean = true, isPointer: boolean = false) {\r\n        super(fullpath, value, undefined);\r\n        this.className = (this.constructor as typeof RuntimeAccessibleClass).cname || this.constructor.name;\r\n        this.isPointer = isPointer;\r\n        if (fire) this.fire();\r\n    }\r\n\r\n    static create_old<\r\n        T extends string,\r\n        VAL extends any,\r\n        ISPOINTER extends boolean,\r\n        AM extends AccessModifier | undefined = undefined,\r\n        // T extends arrayFieldNameTypes<D> = any\r\n        >(tocheck:never, fullpath: T, val: VAL, accessModifier: AM | undefined = undefined, isPointer?: ISPOINTER): SetRootFieldAction {\r\n        return new SetRootFieldAction(fullpath + (accessModifier || ''), val, false, isPointer);\r\n    }\r\n    fire(forceRelaunch: boolean = false, doChecks: boolean = true): boolean {\r\n        /* no need, the reducer should return old state in this case. verify it!\r\n        if (doChecks) {\r\n            // if action would not change the value, i don't fire it at all\r\n            let s: GObject<DState> = store.getState();\r\n            let field = (this.field||'');\r\n            let accessOperator: string = field.substring(field.length-2);\r\n            let fieldpath: string[] = field.split(\".\");\r\n            switch(accessOperator){\r\n                default:\r\n                case \"-=\":\r\n                case \"+=\":\r\n            }\r\n            // path can end with -=, +=, [] etc, but it's fine if i check it as if it was part of the name like object[\"fieldname+=\"]\r\n            // because in all those cases\r\n            if (s[this.field] === this.value) return false;\r\n        }*/\r\n        return super.fire(forceRelaunch);\r\n    }\r\n}\r\n\r\n@RuntimeAccessible('SetFieldAction')\r\nexport class SetFieldAction extends SetRootFieldAction {\r\n    static type = 'SET_ME_FIELD';\r\n\r\n    static create<\r\n        D extends DPointerTargetable,\r\n        T extends (keyof D),\r\n        VAL extends\r\n            D[T] extends string | string[] ? 'must specify \"isPointer\" parameter' :\r\n                (AM extends undefined | '' ? D[T] : (AM extends '-=' ? number[] : (AM extends '+=' | '[]' | `[${number}]` | `.${number}` ? unArr<D[T]> | D[T] | D[T][] : '_error_'))),\r\n        // VAL extends (AM extends undefined | '' ? D[T] : (AM extends '-=' ? number[] : (AM extends '+=' | '[]' | `[${number}]` | `.${number}` ? unArr<D[T]> | D[T] | D[T][] : '_error_'))),\r\n        /*VAL extends (AM extends undefined | '' ? (D[T] extends any[] ? StrictExclude<D[T], string[]> : StrictExclude<D[T], string>) :\r\n            (AM extends '-=' ?\r\n                number[] :\r\n                (AM extends '+=' | '[]' | `[${number}]` | `.${number}` ? unArr<StrictExclude<D[T], string>> | StrictExclude<D[T], string> | (StrictExclude<D[T], string>)[] : '_error_'))),\r\n        */\r\n        ISPOINTER extends boolean | \"todo: ISPOINTER type = boolean but required only if val is UnArr< string > = string | string[], maybe do with override\",\r\n        AM extends AccessModifier | undefined = undefined,\r\n        // T extends arrayFieldNameTypes<D> = any\r\n        >(me: D | Pointer<D>,\r\n          field: T,\r\n          val: VAL,\r\n          accessModifier?: AM | undefined,\r\n          isPointer?: ISPOINTER): SetFieldAction;\r\n    static create<\r\n        D extends DPointerTargetable,\r\n        T extends (keyof D),\r\n        VAL extends AM extends '' | undefined ? orArr<string | null | undefined> :\r\n            (AM extends '-=' ? orArr<number> :\r\n                (AM extends '+=' ? orArr<string | null | undefined> : '_am_typeerror_')),\r\n        AM extends AccessModifier | undefined = undefined,\r\n        >(me: D | Pointer<D>, field: T,\r\n          val: VAL,\r\n          accessModifier: AM,\r\n          isPointer: boolean): SetFieldAction;\r\n    static create<\r\n        D extends DPointerTargetable,\r\n        T extends string & (keyof D),\r\n        VAL extends (AM extends undefined | '' ? D[T] : (AM extends '-=' ? number[] : (AM extends '+=' | '[]' | `[${number}]` | `.${number}` ? unArr<D[T]> | D[T] | D[T][] : '_error_'))),\r\n        ISPOINTER extends boolean | \"todo: ISPOINTER type = boolean but required only if val is UnArr< string > = string | string[], maybe do with override\",\r\n        AM extends AccessModifier | undefined = undefined,\r\n        // T extends arrayFieldNameTypes<D> = any\r\n        >(me: D | Pointer<D>, field: T, val: VAL, accessModifier: AM | undefined = undefined, isPointer?: ISPOINTER): SetFieldAction {\r\n        if (accessModifier) (field as any) += accessModifier;\r\n        return new SetFieldAction(me, field, val, false, isPointer as boolean);\r\n    }\r\n\r\n\r\n    static new<\r\n        D extends DPointerTargetable,\r\n        T extends (keyof D),\r\n        VAL extends\r\n            D[T] extends string | string[] ? 'must specify \"isPointer\" parameter' :\r\n                (AM extends undefined | '' ? D[T] : (AM extends '-=' ? number[] : (AM extends '+=' | '[]' | `[${number}]` | `.${number}` ? unArr<D[T]> | D[T] | D[T][] : '_error_'))),\r\n        // VAL extends (AM extends undefined | '' ? D[T] : (AM extends '-=' ? number[] : (AM extends '+=' | '[]' | `[${number}]` | `.${number}` ? unArr<D[T]> | D[T] | D[T][] : '_error_'))),\r\n        /*VAL extends (AM extends undefined | '' ? (D[T] extends any[] ? StrictExclude<D[T], string[]> : StrictExclude<D[T], string>) :\r\n            (AM extends '-=' ?\r\n                number[] :\r\n                (AM extends '+=' | '[]' | `[${number}]` | `.${number}` ? unArr<StrictExclude<D[T], string>> | StrictExclude<D[T], string> | (StrictExclude<D[T], string>)[] : '_error_'))),\r\n        */\r\n        ISPOINTER extends boolean | \"todo: ISPOINTER type = boolean but required only if val is UnArr< string > = string | string[], maybe do with override\",\r\n        AM extends AccessModifier | undefined = undefined,\r\n        // T extends arrayFieldNameTypes<D> = any\r\n        >(me: D | Pointer<D>,\r\n          field: T,\r\n          val: VAL,\r\n          accessModifier?: AM | undefined,\r\n          isPointer?: ISPOINTER): boolean;\r\n    static new<\r\n        D extends DPointerTargetable,\r\n        T extends (keyof D),\r\n        VAL extends AM extends '' | undefined ? orArr<string | null | undefined> :\r\n            (AM extends '-=' ? orArr<number> :\r\n                (AM extends '+=' ? orArr<string | null | undefined> : '_am_typeerror_')),\r\n        AM extends AccessModifier | undefined = undefined,\r\n        >(me: D | Pointer<D>, field: T,\r\n          val: VAL,\r\n          accessModifier: AM,\r\n          isPointer: boolean): boolean;\r\n    static new<\r\n        D extends DPointerTargetable,\r\n        T extends string & (keyof D),\r\n        VAL extends (AM extends undefined | '' ? D[T] : (AM extends '-=' ? number[] : (AM extends '+=' | '[]' | `[${number}]` | `.${number}` ? unArr<D[T]> | D[T] | D[T][] : '_error_'))),\r\n        ISPOINTER extends boolean | \"todo: ISPOINTER type = boolean but required only if val is UnArr< string > = string | string[], maybe do with override\",\r\n        AM extends AccessModifier | undefined = undefined,\r\n        // T extends arrayFieldNameTypes<D> = any\r\n        >(me: D | Pointer<D>, field: T, val: VAL, accessModifier: AM | undefined = undefined, isPointer?: ISPOINTER): boolean {\r\n        if (accessModifier) (field as any) += accessModifier;\r\n        return new SetFieldAction(me, field, val, false, isPointer as boolean).fire();\r\n    }\r\n\r\n\r\n\r\n    me: Pointer | DPointerTargetable;\r\n    me_field: string;\r\n    // field can end with \"+=\", \"[]\", or \"-1\" if it's array\r\n    protected constructor(me: DPointerTargetable | Pointer, field: string, val: any, fire: boolean = true, isPointer: boolean = false) {\r\n        Log.exDev(!me, 'BaseObject missing in SetFieldAction', {me, field, val});\r\n        super('idlookup.' + ((me as DPointerTargetable).id || me) + ( field ? '.' + field : ''), val, false, isPointer);\r\n        this.me = me;\r\n        this.me_field = field;\r\n        this.className = (this.constructor as typeof RuntimeAccessibleClass).cname || this.constructor.name;\r\n        if (fire) this.fire();\r\n    }\r\n\r\n    fire(forceRelaunch: boolean = false): boolean {\r\n        let fire = this.fire0(forceRelaunch);\r\n        return fire;\r\n\r\n    }\r\n    fire0(forceRelaunch: boolean = false): boolean {\r\n        return super.fire(forceRelaunch, false);\r\n        // IMPORTANT system discarded!\r\n        // if in a composite action there are 2 editos on the same value, like like a.v = 1; a.v = 0; if v initial value was 0 this would accept a.v=1 and refuse a.v=0;\r\n        // this is making an issue in containment lvalue.values = lvalue.values\r\n        // because the values are first disconnected to model, then reconnected to .father=lvalue. but the second command is not firing.\r\n\r\n\r\n    /*\r\n        // if action would not change the value, i don't fire it at all\r\n        // by id because if item was updated, this.me as DElement might be an old version, different from the one in store.\r\n        let d: GObject<any> = DPointerTargetable.from((this.me as DPointerTargetable)?.id || this.me as any);\r\n        // console.warn(\"me fire\", {thiss:this, d, typeofd:typeof d, field:this.me_field, dfield:d[this.me_field], val:this.value});\r\n        if (d && typeof d === \"object\") {\r\n            let oldv = U.followPath(d, this.me_field);\r\n            console.log('set value index firing 0', {ov:d[this.me_field], me_field:this.me_field, oldv, d, newv:this.value});\r\n            if (oldv === this.value) return false;\r\n        }\r\n        return super.fire(forceRelaunch, false);*/\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n/*\r\ncould put in documentation\r\nlet dclass: DClass = null as any;\r\nSetFieldAction.new(dclass, 'namek', '') // non è un attributo di \"DCLass\"\r\nSetFieldAction.new(dclass, 'parent', '') // val (stringa) non è assegnabile a parent (array di puntatori)\r\nSetFieldAction.new(dclass, 'name.5k', '') // non è un indice array valido\r\nSetFieldAction.new(dclass, 'name[4k]', '') // non è un indice array valido\r\nSetFieldAction.new(dclass, 'name[4]', '') // ok, anche se non dovrebbe accettare la dicitura array per name che è un primitivo (check non implementato, troppo difficile)\r\nSetFieldAction.new(dclass, 'name.5', '') // ok, equivale a dicitura array\r\n*/\r\n\r\n@RuntimeAccessible('RedoAction')\r\nexport class RedoAction extends Action {\r\n    public static cname: string = \"RedoAction\";\r\n    static type = 'RedoAction';\r\n    forUser: Pointer<DUser>\r\n\r\n    public static new<F extends boolean = true>(amount: number = 1, forUser:Pointer<DUser>, fire: F = true as F):\r\n        (F extends true ? boolean : (F extends undefined ? UndoAction : UndoAction)) {\r\n        let act = new RedoAction(amount, forUser);\r\n        if (fire) return act.fire() as any;\r\n        return act as any;\r\n\r\n    }\r\n    private constructor(amount: number = 1, forUser:Pointer<DUser>) {\r\n        super('', amount);\r\n        this.forUser = forUser;\r\n        this.className = (this.constructor as typeof RuntimeAccessibleClass).cname || this.constructor.name;\r\n    }\r\n}\r\n\r\n@RuntimeAccessible('UndoAction')\r\nexport class UndoAction extends Action {\r\n    public static cname: string = \"UndoAction\";\r\n    static type = 'UndoAction';\r\n    forUser: Pointer<DUser>;\r\n    public static new<F extends boolean = false>(amount: number = 1, forUser:Pointer<DUser>, fire: F = true as F):\r\n        (F extends true ? boolean : (F extends undefined ? UndoAction : UndoAction)) {\r\n        let act = new UndoAction(amount, forUser);\r\n        if (fire) return act.fire() as any;\r\n        return act as any;\r\n    }\r\n    private constructor(amount: number = 1, forUser:Pointer<DUser>) {\r\n        super('', amount);\r\n        this.forUser = forUser;\r\n        this.className = (this.constructor as typeof RuntimeAccessibleClass).cname || this.constructor.name;\r\n    }\r\n}\r\n\r\n// todo: delete or find original idea back\r\n@RuntimeAccessible('CombineHistoryAction')\r\nexport class CombineHistoryAction extends Action {\r\n    public static cname: string = \"CombineHistoryAction\";\r\n    static type = 'CombineHistoryAcCombineHistoryActiontion';\r\n    public static new<F extends boolean = true>(notfire?: F): (F extends false ? boolean : CombineHistoryAction) {\r\n        let act = new CombineHistoryAction();\r\n        if (!notfire) return act.fire() as any;\r\n        return act as any;\r\n    }\r\n    private constructor() {\r\n        super('', '');\r\n        this.className = (this.constructor as typeof RuntimeAccessibleClass).cname || this.constructor.name;\r\n    }\r\n}\r\n\r\n@RuntimeAccessible('CreateElementAction')\r\nexport class CreateElementAction extends Action {\r\n    public static cname: string = \"CreateElementAction\";\r\n    static type = 'CREATE_ELEMENT';\r\n    value!: DPointerTargetable;\r\n    public static newBatch<F extends boolean = true>(me: DPointerTargetable[], notfire?: F): (F extends false ? boolean : CreateElementAction)[]{\r\n        let ret: any[] = [];\r\n        if (!me.length) return [] as any;\r\n        let types = [...new Set(me.map(e=>e?.className))];\r\n        let typedesc = types.length > 1 ? ' objects of mixed types.' : me[0].className + 'objects.';\r\n        TRANSACTION('Created '+me.length+' '+typedesc, ()=>(ret = me.map( (e) => CreateElementAction.new(e, notfire))));\r\n        return ret;\r\n    }\r\n\r\n    public static create<F extends boolean = true>(me: DPointerTargetable): CreateElementAction {\r\n        if ((me as LPointerTargetable).__raw) me = (me as LPointerTargetable).__raw;\r\n        return new CreateElementAction(me, true);\r\n    }\r\n    public static new<F extends boolean = true>(me: DPointerTargetable, notfire?: F): (F extends false ? boolean : CreateElementAction) {\r\n        let act = CreateElementAction.create(me);\r\n        if (!notfire) return act.fire() as any;\r\n        return act as any;\r\n    }\r\n    private constructor(me: DPointerTargetable, fire: boolean = true) {\r\n        super('idlookup.' + me.id, me);\r\n        this.className = (this.constructor as typeof RuntimeAccessibleClass).cname || this.constructor.name;\r\n        this.value = me;\r\n        if (fire) this.fire();\r\n    }\r\n    public fire(forceRelaunch: boolean = false): boolean {\r\n        let ret = false;\r\n        TRANSACTION('Create ' + this.value?.className, () => {\r\n            ret = super.fire(forceRelaunch);\r\n            if (this.value._derivedSubElements || this.value._persistCallbacks) { Constructors.persist(this.value, true); }\r\n        });\r\n        return ret;\r\n    }\r\n}\r\n\r\n@RuntimeAccessible('DeleteElementAction')\r\nexport class DeleteElementAction extends SetFieldAction {\r\n    static type = 'DELETE_ELEMENT';\r\n    public static create(me: Pack1<LPointerTargetable>): DeleteElementAction { return new DeleteElementAction(me as any); }\r\n    public static new(me: Pack1<LPointerTargetable>): boolean { return new DeleteElementAction(me as any).fire(); }\r\n\r\n    constructor(me: Pack1<LPointerTargetable>) {\r\n        super(Pointers.from(me), '', undefined);\r\n        this.className = (this.constructor as typeof RuntimeAccessibleClass).cname || this.constructor.name;\r\n    }\r\n}\r\n\r\n\r\n/*\r\n\r\n@RuntimeAccessible\r\nexport class IDLinkAction extends Action{\r\n    constructor() {\r\n        super(IDLinkAction.name,\r\n    }\r\n    nope, uso un proxy\r\n}*/\r\n\r\n@RuntimeAccessible('CompositeAction')\r\nexport class CompositeAction extends Action {\r\n    static type: string = 'COMPOSITE_ACTION';\r\n    actions: Action[] = [];\r\n    descriptor?: ActionDescriptor;\r\n\r\n    public static new(actions: Action[], launch: boolean = true): CompositeAction { return new CompositeAction(actions, launch); }\r\n    constructor(actions: Action[], launch: boolean = false) {\r\n        super('', '');\r\n        this.actions = actions;\r\n        this.className = (this.constructor as typeof RuntimeAccessibleClass).cname || this.constructor.name;\r\n        if (launch) this.fire();\r\n    }\r\n    fire(forceRelanch?: boolean): boolean{\r\n        if (!this.actions.length) return false;\r\n        return super.fire(forceRelanch);\r\n    }\r\n}\r\n\r\n@RuntimeAccessible('ParsedAction')\r\nexport class ParsedAction extends SetRootFieldAction {\r\n    // NB: actually this is never created but \"converted\" from other actions by adding fields\r\n    path!: string; // path to a property in the store \"something.like.this\"\r\n    pathArray!: string[]; // path splitted \"like.1.this\"\r\n    executionCount!: number;\r\n}\r\n\r\n\r\nRuntimeAccessibleClass.set_extend(RuntimeAccessibleClass, Action);\r\nRuntimeAccessibleClass.set_extend(Action, LoadAction);\r\nRuntimeAccessibleClass.set_extend(Action, SetRootFieldAction);\r\nRuntimeAccessibleClass.set_extend(SetRootFieldAction, SetFieldAction);\r\nRuntimeAccessibleClass.set_extend(SetFieldAction, DeleteElementAction);\r\nRuntimeAccessibleClass.set_extend(Action, RedoAction as any);\r\nRuntimeAccessibleClass.set_extend(Action, UndoAction as any);\r\nRuntimeAccessibleClass.set_extend(Action, CreateElementAction as any);\r\nRuntimeAccessibleClass.set_extend(Action, CombineHistoryAction as any);\r\nRuntimeAccessibleClass.set_extend(Action, CompositeAction as any);\r\nRuntimeAccessibleClass.set_extend(SetRootFieldAction, ParsedAction as any);\r\n","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\redux\\selectors\\selectors.ts",["997","998","999","1000","1001","1002","1003","1004","1005","1006","1007","1008","1009","1010","1011"],"import {\r\n    AbstractConstructor,\r\n    AttribETypes,\r\n    Constructor,\r\n    DAttribute,\r\n    DClass,\r\n    DClassifier,\r\n    DEnumerator,\r\n    DGraph,\r\n    DGraphElement,\r\n    DObject,\r\n    DRefEdge,\r\n    DState,\r\n    DValue,\r\n    DVoidVertex,\r\n    GObject,\r\n    LClass,\r\n    LEnumerator,\r\n    LGraphElement,\r\n    LModel,\r\n    LModelElement,\r\n    LObject,\r\n    LOperation,\r\n    LPackage,\r\n    LRefEdge,\r\n    LValue,\r\n    LViewElement,\r\n    LViewPoint,\r\n    LVoidVertex,\r\n    Pointer,\r\n    ShortAttribETypes,\r\n    Dictionary,\r\n    LUser,\r\n    DUser,\r\n    Defaults,\r\n    LProject,\r\n    ViewScore,\r\n    DViewElement,\r\n    DPointerTargetable,\r\n    DModel,\r\n    DModelElement,\r\n    OCL,\r\n    Log,\r\n    LPointerTargetable,\r\n    RuntimeAccessible,\r\n    RuntimeAccessibleClass,\r\n    store,\r\n    U,\r\n    toShortEType,\r\n    NodeTransientProperties,\r\n    transientProperties,\r\n    ViewEClassMatch,\r\n    ViewTransientProperties,\r\n    DProject,\r\n    DViewPoint,\r\n    DNamedElement\r\n} from \"../../joiner\";\r\nimport {DefaultEClasses, ShortDefaultEClasses, toShortEClass} from \"../../common/U\";\r\n\r\n\r\n@RuntimeAccessible('Selectors')\r\nexport class Selectors{\r\n\r\n    static getActiveModel(): null|LModel {\r\n        let metamodel: null|LModel;\r\n        let state: DState & GObject = store.getState();\r\n        const selected = state._lastSelected?.modelElement;\r\n        if(selected) {\r\n            const me = LPointerTargetable.fromPointer(selected)\r\n            metamodel = (me) ? me.model : null;\r\n        } else metamodel = null;\r\n        return metamodel;\r\n    }\r\n\r\n    public static getLastSelectedModel<RET extends {m1?:LModel, m2?:LModel, model?:LModel, element?:LModelElement}>(state?: DState): RET {\r\n        state = state || store.getState();\r\n        let me = state._lastSelected?.modelElement;\r\n        if (!me) return {} as RET;\r\n        let ret: RET = {element: LPointerTargetable.fromPointer(me, state)} as RET;\r\n        ret.model = ret.element!.model\r\n        if (ret.model.isMetamodel) ret.m2 = ret.model;\r\n        else {\r\n            ret.m1 = ret.model;\r\n            ret.m2 = ret.m1.instanceof;\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    static getAllViewElements(state0?: DState): DViewElement[] {\r\n        // return Object.values(store.getState().idlookup).filter(v => v.className === DViewElement.name) as DViewElement[];\r\n        const state: GObject<DState> = state0 || store.getState();\r\n        const ptrs: Pointer<DViewElement>[] = Object.values((state).viewelements);\r\n        let views: DViewElement[] = ptrs.map<DViewElement>( (ptr) => DPointerTargetable.fromPointer(ptr, state) as DViewElement);\r\n        return views;\r\n    }\r\n    //Giordano: start\r\n\r\n    public static getViewpoints() : LViewPoint[] {\r\n        const state: DState & GObject = store.getState();\r\n        return LPointerTargetable.fromPointer(state.viewpoints);\r\n    }\r\n    public static getViewpoint() : LViewPoint {\r\n        const state: DState & GObject = store.getState();\r\n        return LPointerTargetable.fromPointer(state.viewpoint);\r\n    }\r\n\r\n    public static getObjects(): LObject[] {\r\n        let state: DState & GObject = store.getState();\r\n        const ptrs: Pointer<DObject, 0, 'N'> = Object.values((state).objects);\r\n        const dObjects: DObject[] = ptrs.map<DObject>( (ptr) => state.idlookup[ptr] as DObject);\r\n        const lObjects: LObject[] = [];\r\n        for(let dObject of dObjects) {\r\n            lObjects.push(LPointerTargetable.fromPointer(dObject.id));\r\n        }\r\n        return lObjects;\r\n    }\r\n    public static getValues(): LValue[] {\r\n        let state: DState & GObject = store.getState();\r\n        const ptrs: Pointer<DValue, 0, 'N'> = Object.values((state).values);\r\n        const dValues: DValue[] = ptrs.map<DValue>( (ptr) => state.idlookup[ptr] as DValue);\r\n        const lValues: LValue[] = [];\r\n        for(let dValue of dValues) {\r\n            if(dValue?.id) {\r\n                lValues.push(LPointerTargetable.fromPointer(dValue.id));\r\n            }\r\n        }\r\n        return lValues;\r\n    }\r\n\r\n    public static getDeleted(): string [] {\r\n        const state: DState & GObject = store.getState();\r\n        return state.deleted;\r\n    }\r\n\r\n    public static getState(): any {\r\n        const state: DState & GObject = store.getState();\r\n        return state;\r\n    }\r\n\r\n    static getDefaultEcoreClass(type: DefaultEClasses | ShortDefaultEClasses, state?: DState): DClassifier {\r\n        let shorttype: string = (toShortEClass(type as any) || type).toUpperCase();\r\n        if (!state) state = store.getState();\r\n        // todo: make other m3 classes and make this generic like getPrimitiveType\r\n        return state.idlookup[\"Pointer_\"+ShortDefaultEClasses.EObject.toUpperCase()] as DClassifier;\r\n    }\r\n    static getPrimitiveType(type: AttribETypes | ShortAttribETypes, state?: DState): DClassifier {\r\n        let shorttype: string = (toShortEType(type as any) || type).toUpperCase();\r\n        if (!state) state = store.getState();\r\n        return state.idlookup[\"Pointer_\"+shorttype] as DClassifier;\r\n    }\r\n    static getAllPrimitiveTypes(): DClassifier[] {\r\n        let state: DState & GObject = store.getState();\r\n        const ptrs: Pointer<DClassifier, 0, 'N'> = Object.values((state).primitiveTypes);\r\n        const classifiers: DClassifier[] = ptrs.map<DClassifier>( (ptr) => state.idlookup[ptr] as DClassifier);\r\n        return classifiers;\r\n    }\r\n    static getFirstPrimitiveTypes(): DClassifier {\r\n        return Selectors.getAllPrimitiveTypes()[0];\r\n    }\r\n    static getRefEdges(): DRefEdge[] {\r\n        const state: DState & GObject = store.getState();\r\n        const pointers: Pointer<DRefEdge, 0, 'N', LRefEdge> = Object.values((state).refEdges);\r\n        const dRefEdges: DRefEdge[] = pointers.map<DRefEdge>( (ptr) => state.idlookup[ptr] as DRefEdge);\r\n        return dRefEdges;\r\n    }\r\n    static getField(field: string): string[] {\r\n        let state: DState & GObject = store.getState();\r\n        const pointers: Pointer<DModelElement, 0, 'N'> = Object.values((state)[field]);\r\n        return pointers;\r\n    }\r\n\r\n    static getAllAttributes(): string[] {\r\n        const state: DState = store.getState();\r\n        return Object.values((state).attributes);\r\n    }\r\n    static getAllEnumLiterals(): string[] {\r\n        const state: DState = store.getState();\r\n        return Object.values((state).enumliterals);\r\n    }\r\n    static getAllReferences(): string[] {\r\n        const state: DState = store.getState();\r\n        return Object.values((state).references);\r\n    }\r\n    // static getAllReferenceEdges(): string[] { const state: DState = store.getState(); return Object.values((state).refEdges); }\r\n    static getAllClasses(): string[] {\r\n        const state: DState = store.getState();\r\n        return Object.values((state).classs);\r\n    }\r\n    static getReturnTypes(): LClass[] {\r\n        const state: DState = store.getState();\r\n        return LPointerTargetable.from(Object.values((state).returnTypes));\r\n    }\r\n\r\n    static getAllClassesWithoutPrimitive(): string[] {\r\n        // this solution does not look good. what if a primitive type is inserted at runtime in between?\r\n        // coould reach the same goal by taking all Classes of a model (m2), excluding classes from other models (types are classes from m3 model)\r\n        const state: DState = store.getState();\r\n        const classList: string[] = Object.values((state).classs);\r\n        classList.splice(0, Selectors.getAllPrimitiveTypes().length);\r\n        /* todo: need to change it in something like this once cross-references between models and instances are implemented\r\n        const m2: LModel;\r\n        m2.isInstanceOf = m3 as LModel;\r\n        m2.isInstanceOf.classes;*/\r\n\r\n        return classList;\r\n    }\r\n\r\n    static getAllEnumerators(flag = false): string[] {\r\n        const state: DState = store.getState();\r\n        return Object.values((state).enumerators);\r\n    }\r\n    static getAllPackages(): string[] {\r\n        const state: DState = store.getState();\r\n        return Object.values((state).packages);\r\n    }\r\n\r\n    static getAllParameters(): string[] {\r\n        const state: DState = store.getState();\r\n        return Object.values((state).parameters);\r\n    }\r\n    static getAllOperations(): string[] {\r\n        const state: DState = store.getState();\r\n        return Object.values((state).operations);\r\n    }\r\n\r\n    static getDElement<T extends DModelElement>(pointer: string): T {\r\n        const state: DState & GObject = store.getState();\r\n        const dElement: T = state.idlookup[pointer] as T;\r\n        return dElement;\r\n    }\r\n\r\n    static getAllMetamodels(): LModel[] {\r\n        const state: DState = store.getState();\r\n        const dModels = Object.values((state).m2models);\r\n        return LPointerTargetable.fromPointer(dModels);\r\n    }\r\n\r\n    static getAllModels(): LModel[] {\r\n        const state: DState = store.getState();\r\n        const dModels = Object.values((state).m1models);\r\n        return LPointerTargetable.fromPointer(dModels);\r\n    }\r\n\r\n    //Giordano: end\r\n\r\n    static getVertex<W extends boolean = true, RP extends boolean = true>(wrap?: W /* = true */, resolvePointers?: RP /**/):\r\n        W extends false ? (RP extends false ? Pointer<DVoidVertex, 1, 1, LVoidVertex>[] : DVoidVertex[]) : LVoidVertex[] {\r\n        const state: DState = store.getState();\r\n        let ptrs: Pointer<DVoidVertex>[] = [];\r\n\r\n        U.ArrayMerge0(false, ptrs,\r\n            // Object.values(state.graphs || {}),\r\n            Object.values(state.voidvertexs || {}),\r\n            Object.values(state.vertexs || {}),\r\n            Object.values(state.graphvertexs || {}),\r\n            Object.values(state.edgepoints || {}));\r\n\r\n        console.log('selector getvertex: ', {ptrs, g: Object.values(state.graphs || {}), vv:Object.values(state.voidvertexs || {}), v:Object.values(state.vertexs || {}), gv:Object.values(state.graphvertexs || {}), ep:Object.values(state.edgepoints || {})});\r\n        if (wrap === undefined || wrap === true) return ptrs.map( p => DPointerTargetable.wrap(p)) as any[];\r\n        if (resolvePointers === undefined || resolvePointers === true) return ptrs.map( r => state.idlookup[r]) as any[];\r\n        return ptrs as any[];\r\n    }\r\n\r\n    static getAll<D extends DPointerTargetable, L extends LPointerTargetable, DT extends typeof DPointerTargetable = typeof DPointerTargetable,\r\n        W extends undefined | true | false = false, RP extends undefined | true | false = true, RET = W extends false ? (RP extends false ? Pointer<D, 1, 1, L> : D) : L>\r\n        (Classe?: DT, condition?: (e:RET) => boolean, state?: DState, resolvePointers?: RP /**/, wrap?: W /* = true */): RET[] {\r\n        if (!state) state = store.getState();\r\n        let GClass = (Classe as GObject) || {name:\"idlookup\", cname:\"idlookup\"};\r\n        const className: string = (GClass?.staticClassName || GClass.cname).toLowerCase();\r\n        const allIdByClassName: Pointer<D, 1, 1, L>[]\r\n            = (state as GObject)[className]\r\n            || (state as GObject)[className.substr(1)]\r\n            || (state as GObject)[className + 's']\r\n            || (state as GObject)[className.substr(1) + 's'];\r\n        Log.exDev(!allIdByClassName, 'cannot find store key:', {state, className, Classe});\r\n        let allDByClassName: D[] | null = null;\r\n        let allLByClassName: L[] | null = null;\r\n        if (resolvePointers || wrap) {\r\n            allDByClassName = allIdByClassName.map( (e) => (state as DState).idlookup[e] ) as D[];\r\n            if (wrap) {\r\n                allLByClassName = allDByClassName.map( e => DPointerTargetable.wrap(e)) as any as L[];\r\n            }\r\n        }\r\n        let ret: RET[] = (resolvePointers || wrap ? (wrap ? allLByClassName : allDByClassName) : allIdByClassName) as any[] as RET[];\r\n        if (!Array.isArray(ret)) ret = Object.values(ret).filter(e => e instanceof Object) as RET[];\r\n        if (condition) return ret.filter( e => condition(e));\r\n        return ret;\r\n    }\r\n\r\n    static getModels(condition?: (m: DModel) => boolean): DModel[] { return Selectors.getAll(DModel, undefined, undefined, true, false); }\r\n\r\n    static getModel(name: string, caseSensitive: boolean = false, wrap: boolean = false): DModel | LModel | null {\r\n        if (!caseSensitive) name = name.toLowerCase();\r\n        let ret = Selectors.getAll<DModel, LModel>(DModel, (d) => (caseSensitive ? d.name : d.name.toLowerCase()) === name, undefined, true, wrap as any)[0];\r\n        return ret;\r\n    }\r\n\r\n    static getName(d: DPointerTargetable | LPointerTargetable | string, s: DState): string {\r\n        if (!d) return d;\r\n        if (typeof d === 'string') return d;\r\n        d = (d as LPointerTargetable).__raw || d;\r\n        if (d.className !== DObject.cname) return (d as DNamedElement).name;\r\n        let dobject: DObject = d as DObject;\r\n        for (let feat_id of dobject.features) {\r\n            let feat: DNamedElement | undefined = s.idlookup[feat_id] as any;\r\n            if (feat && feat.name.toLowerCase() === 'name') return feat.name;\r\n        }\r\n        return dobject.name;\r\n    }\r\n    static getByName2(name?: string | DPointerTargetable | LPointerTargetable, dtype?: typeof DPointerTargetable | undefined | string, caseSensitive: boolean = false, s?:DState): DPointerTargetable | null {\r\n        if (!name) { return null; }\r\n        if (typeof name === 'object') { return name as DPointerTargetable; }\r\n        if (!s) s = store.getState();\r\n        //let ret: DPointerTargetable[];\r\n        let classname: string | undefined = (dtype as typeof DClass)?.cname || dtype as string; // Selectors.getName(dtype, s); this was if dtype was allowed to be a class (filter Humans instead of filter DObjects)\r\n        if (!caseSensitive) {\r\n            name = name.toLowerCase();\r\n            classname = classname?.toLowerCase();\r\n        }\r\n        for (let id in s.idlookup) {\r\n            let d = s.idlookup[id];\r\n            if (!d || typeof d !== 'object') continue;\r\n            if (classname !== (caseSensitive ? d.className : d.className.toLowerCase())) continue;\r\n            let dname = Selectors.getName(d, s);\r\n            if (!caseSensitive) dname = dname?.toLowerCase();\r\n            if (dname === name) return d;\r\n        }\r\n        return null;\r\n    }\r\n    static getByName(classe: typeof DPointerTargetable, name: string, caseSensitive: boolean = false, wrap: boolean = false): DPointerTargetable | LPointerTargetable | null {\r\n        return Selectors.getByField(classe, 'name', name, caseSensitive, wrap); }\r\n\r\n    static getByField(classe: typeof DPointerTargetable | undefined, field: string, value: string, caseSensitive: boolean = false, wrap: boolean = false): DPointerTargetable | LPointerTargetable | null {\r\n        if (!caseSensitive) value = value.toLowerCase();\r\n        let condition = (d: any) => {\r\n            let ret = (caseSensitive ? d[field] : d[field]?.toLowerCase()) === value;\r\n            console.log('filtering getall by field:', {d, dfield:d[field], value, ret});\r\n            return ret;\r\n        }\r\n        let ret = Selectors.getAll(classe, condition, undefined, true, wrap as any)[0];\r\n        return ret; }\r\n\r\n    static getViewIDs(condition?: (m: DModel) => boolean): Pointer<DViewElement>[] { return Selectors.getAll(DViewElement); }\r\n\r\n\r\n\r\n    private static queryJS(model: LModel, query: string): LPointerTargetable[] {\r\n        try {\r\n            return eval(query);\r\n        } catch (e) { return []; }\r\n    }\r\n    /*static getCurrentView(data: LModelElement): DViewElement {\r\n        Log.exDevv('todo');\r\n        return undefined as any;\r\n    }*/\r\n\r\n    private static matchesMetaClassTarget(v: DViewElement, data?: DModelElement | DGraphElement | undefined): number {\r\n        if (!v) return ViewEClassMatch.MISMATCH_PRECONDITIONS;\r\n        if (!v.appliableToClasses || !v.appliableToClasses.length) return ViewEClassMatch.IMPLICIT_MATCH;\r\n        if (!data) return ViewEClassMatch.MISMATCH_PRECONDITIONS;\r\n        let ThisClass: typeof DPointerTargetable = RuntimeAccessibleClass.get(data.className);\r\n        Log.exDev(!ThisClass, 'unable to find class type:', {v, data}); // todo: v = view appliable to DModel, data = proxy<LModel>\r\n        let gotSubclassMatch: boolean = false;\r\n        for (let classtarget of v.appliableToClasses) {\r\n            const ClassTarget: typeof DPointerTargetable = RuntimeAccessibleClass.get(classtarget);\r\n            if (ThisClass === ClassTarget) return ViewEClassMatch.EXACT_MATCH; // explicit exact match\r\n            if (!gotSubclassMatch && U.classIsExtending(ThisClass, ClassTarget)) gotSubclassMatch = true; // explicit subclass match\r\n            if (gotSubclassMatch) return ViewEClassMatch.INHERITANCE_MATCH;\r\n        }\r\n        return ViewEClassMatch.MISMATCH_PRECONDITIONS;\r\n }\r\n\r\n    private static isOfSubclass(data: DPointerTargetable, classTarget: string | typeof DPointerTargetable, acceptEquality: boolean = false): boolean {\r\n        let ThisClass: typeof DPointerTargetable = RuntimeAccessibleClass.get(data.className);\r\n        Log.exDev(!ThisClass, 'isOfSubclass() unable to find class type:', {data});\r\n        const ClassTarget: typeof DPointerTargetable = typeof classTarget === \"string\"? RuntimeAccessibleClass.get(classTarget) : classTarget;\r\n        if (ThisClass === ClassTarget) return acceptEquality;\r\n        return U.classIsExtending(ThisClass, ClassTarget);\r\n    }\r\n\r\n\r\n    static getViewByIDOrNameD(name: string | DViewElement | LViewElement, state?: DState): undefined | DViewElement {\r\n        if (!state) state = store.getState();\r\n        if (typeof name === \"object\") { return (name as any).__raw || name as any; }\r\n        if (state.idlookup[name]?.className === DViewElement.cname) return state.idlookup[name] as DViewElement;\r\n        let id = Selectors.getViewIdFromName(name, state);\r\n        if (id && state.idlookup[id]?.className === DViewElement.cname) return state.idlookup[id] as DViewElement;\r\n        return undefined;\r\n    }\r\n\r\n\r\n    // input: \"subview.subview2.targetview\"\r\n    // output: returns pointer to targetview\r\n    // path is not required to start with a root, it's also possible to start navigating from a subview (notviewpoint/model view)\r\n    // in case multiple matches are given due to incomplete path not starting from a viewpoint, the oldest matching view is returned.\r\n    static getViewIdFromName(namepath: string, state?: DState): undefined | Pointer<DViewElement> {\r\n        if (!state) state = store.getState();\r\n        let names: string[] = namepath.split(\".\");\r\n        let eligibleContainers: Pointer<DViewElement>[] = state.viewelements;\r\n        for (let i = 0; i < names.length; i++) {\r\n            let name = names[i];\r\n            eligibleContainers = eligibleContainers.filter(v => ((state as DState).idlookup[v] as DViewElement).name === name);\r\n            if (i === names.length-1 || eligibleContainers.length === 0) return eligibleContainers[0];\r\n            eligibleContainers = eligibleContainers.flatMap(v => Object.keys(((state as DState).idlookup[v] as DViewElement).subViews));\r\n        }\r\n        return undefined;\r\n    }\r\n\r\n    static getAllGraphElementPointers(): Pointer<DGraphElement>[] {\r\n        // graphelements = fields;\r\n        let state: DState = store.getState();\r\n        return [...state.graphs, ...state.graphvertexs, ...state.graphelements, ...state.vertexs, ...state.edgepoints, ...state.edges];\r\n    }\r\n\r\n    private static getFinalScore(entry: ViewScore, vid: Pointer<DViewElement>, parentView: DViewElement | undefined, dview: DViewElement): number {\r\n        if (entry.metaclassScore === ViewEClassMatch.MISMATCH_PRECONDITIONS) return ViewEClassMatch.MISMATCH;\r\n        if (entry.viewPointMatch === ViewEClassMatch.VP_MISMATCH) return ViewEClassMatch.MISMATCH;\r\n        if (entry.jsScore === ViewEClassMatch.MISMATCH_JS || entry.OCLScore === ViewEClassMatch.MISMATCH_JS) return ViewEClassMatch.MISMATCH;\r\n        let pvMatch: boolean = parentView ? vid in parentView.subViews : false;\r\n        let pvScore: number = pvMatch ? (parentView as DViewElement).subViews[vid] : 1;\r\n        let explicitprio: number;\r\n        if (typeof entry.jsScore === 'number') {\r\n            explicitprio = entry.jsScore;\r\n        } else if (dview.explicitApplicationPriority === undefined) {\r\n            // in editor put placeholder with computed expression\r\n            explicitprio = (dview.jsCondition?.length || 1) + (dview.oclCondition?.length || 1);\r\n        } else explicitprio = dview.explicitApplicationPriority;\r\n\r\n        //console.log(\"getFinalScore\", {entry, vid, dview, explicitprio, ep:dview.explicitApplicationPriority})\r\n\r\n        let defualtViewMalus = dview.id.indexOf('View') >= 0 ? 0 : 0.1;\r\n        return entry.viewPointMatch * entry.metaclassScore * pvScore * explicitprio + defualtViewMalus;\r\n        //score = precoditiom * paremtview(comfiguravle) * (explicitprio = jsValid*jslemgth + oclvalid*ocllemgth)\r\n        // or if jscomditiom returmed mumver --> * jsscore\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n/*\r\n    //this function handles: what i do when view changes? do i recompute the score?\r\n    static updateViewMatchings(dview: DViewElement, updatePreconditions: boolean, updateOCLScore: boolean, store: DState, updateManualViews: boolean = false, forcedUpdateViews: boolean = false): void {\r\n\r\n        //  event           observed change         ignore change\r\n        //  ocl             data                    node, view (except view.ocl)\r\n        //  jsCondition     all                     none\r\n        //  appliableTo     view.appliableto\r\n        // if (!forcedUpdateViews && (dview.oclUpdateCondition === 'manual') !== updateManualViews) return;\r\n        // modularize getscoresnew split in setpreconditionscore, setoclscorem, setjscscore, and call those only if observed stuff changed\r\n\r\n        const allNodes: DGraphElement[] = DPointerTargetable.fromPointer(Selectors.getAllGraphElementPointers());\r\n        //let dview = view.__raw;\r\n        let vid = dview.id; // optimize searching multiple usages and replacing\r\n\r\n        // filter alldata to exclude modelpieces that didn't pass the view.appyto check\r\n        // let oclData: (LModelElement)[] = allData.filter(l => {\r\n        let oclnodes: (DGraphElement)[] = allNodes.filter((dg: DGraphElement) => {\r\n            if (!dg) return false;\r\n            if (true) {\r\n                let d: DModelElement | undefined = dg.model ? DPointerTargetable.fromPointer(dg.model) : undefined;\r\n                let firstEvaluationForNodeView: boolean = false;\r\n                if (!transientProperties.node[dg.id]) { transientProperties.node[dg.id] = {viewScores: {}} as any; firstEvaluationForNodeView = true; }\r\n                if (!transientProperties.node[dg.id].viewScores[vid]) { transientProperties.node[dg.id].viewScores[vid] = {score: undefined} as any; firstEvaluationForNodeView = true; }\r\n\r\n                if (firstEvaluationForNodeView || updatePreconditions) {\r\n                    const oldScore = transientProperties.node[dg.id].viewScores[vid].score;\r\n                    const newScore = transientProperties.node[dg.id].viewScores[vid].score = this.matchesMetaClassTarget(dview, d);\r\n                    if (oldScore !== newScore) transientProperties.node[dg.id].stackViews = undefined as any; // force re-sorting\r\n                    // 67{}[]'?^&&||nb>\r\n                } /* else {\r\n                    if (!transientProperties.view[dview.id].oclUpdateCondition_PARSED( transientProperties.node[dg.id].viewScores[vid].)) return;\r\n                }* /\r\n                // no need to check if parentview changed as well. i optimized by not having parentview affect the numeric scores, but only the view queue array sorting\r\n\r\n                // transient.node[dg.id].viewScores[vid].score = MISSING (hasOwnProperty);    if the view or model is new and they are not yet evaluated.\r\n                // transient.node[dg.id].viewScores[vid].score = Number.NEGATIVE_INFINITY;    if pre-ocl conditions failed (view.appliableTo)\r\n                // transient.node[dg.id].viewScores[vid].score = 0;                           if preconditions are met, but ocl failed\r\n                // transient.node[dg.id].viewScores[vid].score = number ocl score;            if preconditions are met and ocl matched\r\n                // transient.node[dg.id].viewScores[vid].score = number precondition score;   if preconditions are met, and there is no ocl condition\r\n                // changed: matching score and ocl score are summed.\r\n                return transientProperties.node[dg.id].viewScores[vid].score !== undefined;\r\n            }\r\n\r\n            // if (model_viewstack[vid]) { filledElementsInOclData++; return l; } return undefined;\r\n        });\r\n        function mergeViewScores(preconditionScore: number, oclScore: number): number{ return preconditionScore + oclScore; }\r\n    }*/\r\n\r\n\r\n\r\n\r\n    static updateScores(data0: LModelElement | undefined, node: LGraphElement | undefined, nid: Pointer<DGraphElement>, pv: DViewElement | undefined, state: DState){\r\n        let needsorting: boolean = false;\r\n        let firstEvaluationForNode: boolean = false;\r\n        let firstEvaluationForNodeView: boolean = false;\r\n        let tn = transientProperties.node[nid];\r\n        //console.log('2302 0, getviews evaluating view ', {tn:(tn ? {...tn} : tn), nid});\r\n        if (!tn) { transientProperties.node[nid] = tn = new NodeTransientProperties(); firstEvaluationForNode = true; }\r\n        //console.log('2302 1, getviews evaluating view ' , {tn:(tn ? {...tn} : tn), nid});\r\n        let olddata = tn.viewSorted_modelused as LModelElement;\r\n        //let oldnode = transientProperties.node[nid]?.viewSorted_nodeused as LGraphElement;\r\n        const data: LModelElement = data0 as LModelElement;\r\n        // console.error('changed', {data, olddata, node, oldnode, cdata:data?.clonedCounter, colddata:olddata?.clonedCounter})\r\n        const pvid: Pointer<DViewElement> | undefined = pv?.id;\r\n        const oldpv: DViewElement | undefined = tn.viewSorted_pvid_used;\r\n        let datachanged: boolean = (!!data !== !!olddata) || !!(data && olddata) && (data.clonedCounter !== olddata.clonedCounter);\r\n        //let nodechanged: boolean = (!!node !== !!oldnode) || !!(node && oldnode) && (node.clonedCounter !== oldnode.clonedCounter);\r\n        let parentViewChanged: boolean = (pvid !== oldpv?.id || (!!(pv && oldpv) && oldpv.subViews !== pv.subViews)); // shallow comparison is fine.\r\n        if (parentViewChanged) tn.viewSorted_pvid_used = pv;\r\n        //if (nodechanged) transientProperties.node[nid].viewSorted_nodeused = node;\r\n        if (datachanged) tn.viewSorted_modelused = data;\r\n\r\n        // let nodechanged: boolean\r\n        // important to remember: how i'm using parentView in score and storage.\r\n        // i'm calculating and storing every score without parentView, then i apply it right before sorting the array,\r\n        // the enhanced value is not sored anyway but affects array sorting.\r\n        // so if parentView changes, or if his subviews changed, need to resort array without recomputing any score value.\r\n\r\n        //console.log('2302, getviews 2', {datachanged, nodechanged, olddata, oldnode, data, node, allViews: Selectors.getAllViewElements()});\r\n\r\n        if (!state) state = store.getState();\r\n        const allViews: DViewElement[] = Selectors.getAllViewElements(state);\r\n\r\n        const user = LUser.fromPointer(DUser.current);\r\n        const project = user.project as LProject;\r\n        let activevpid: Pointer<DViewElement> = project.activeViewpoint.id;\r\n        // check if scores needs to be updated\r\n        for (const dview of allViews) {\r\n            let vid = dview.id;\r\n            let tv = transientProperties.view[vid];\r\n            if (!tv) transientProperties.view[vid] = tv = {} as any;\r\n            //console.log('2302 2, getviews evaluating view ' + vid, {vid, dview, tn});\r\n            if (!tn?.viewScores) console.error('2302 3, getviews evaluating view ' + vid, {vid, dview, tn});\r\n            let tnv = tn.viewScores[vid];\r\n\r\n            // check initialization\r\n\r\n            if (!tnv) {\r\n                tn.viewScores[vid] = tnv = {} as any;\r\n                /*{\r\n                    score: ViewEClassMatch.NOT_EVALUATED_YET,\r\n                    metaclassScore: ViewEClassMatch.NOT_EVALUATED_YET,\r\n                    //jsScore:ViewEClassMatch.NOT_EVALUATED_YET,\r\n                    //OCLScore: ViewEClassMatch.NOT_EVALUATED_YET\r\n                } as any;*/\r\n                firstEvaluationForNodeView = true;\r\n            } else firstEvaluationForNodeView = tnv.metaclassScore === ViewEClassMatch.NOT_EVALUATED_YET; // todo: when changing view.appliableTo, delete all tnv using that view.\r\n\r\n            // don't match exclusive views from other vp\r\n            let dvp: DViewPoint = DPointerTargetable.fromPointer(dview.viewpoint, state);\r\n            let oldVpMatch: number = tnv.viewPointMatch;\r\n            // console.log(\"vp matching \" +vid, {vid, dvp, activevpid });\r\n            if (dvp.id === activevpid) tnv.viewPointMatch = ViewEClassMatch.VP_Explicit;\r\n            else if (dvp.id === 'Pointer_ViewPointDefault') tnv.viewPointMatch = ViewEClassMatch.VP_Default;\r\n            else if (!dvp.isExclusiveView) tnv.viewPointMatch = ViewEClassMatch.VP_Decorative;\r\n            else tnv.viewPointMatch = ViewEClassMatch.VP_MISMATCH;\r\n\r\n            if (!needsorting && (oldVpMatch !== tnv.viewPointMatch)) needsorting = true;\r\n            if (tnv.viewPointMatch === ViewEClassMatch.VP_MISMATCH) {\r\n                tnv.finalScore = ViewEClassMatch.VP_MISMATCH;\r\n                continue;\r\n            }\r\n\r\n\r\n            // check preconditions\r\n            if (firstEvaluationForNodeView) {\r\n                const oldScore = tnv.metaclassScore;\r\n                tnv.metaclassScore = this.matchesMetaClassTarget(dview, data?.__raw);\r\n                needsorting = true; // sorting is mandatory here because it's the first evaluation of node-vie\r\n                // if mismatch i stop computing the score.\r\n                if (tnv.metaclassScore === ViewEClassMatch.MISMATCH_PRECONDITIONS) {\r\n                    tnv.finalScore = ViewEClassMatch.MISMATCH;\r\n                    continue;\r\n                }\r\n            } else if (tnv.metaclassScore === ViewEClassMatch.MISMATCH_PRECONDITIONS) continue;\r\n\r\n            if (true) {\r\n                // this needs to be called not only if datachanged || nodechanged, but everytime in case it is a reference like data.$value.name.length\r\n                // also his performances are so fast that it might be more costly to check if it's supposed to be reevaluated than just calling it.\r\n                let jsScoreChanged: boolean = Selectors.updateJSScore(node, data, dview, tv, tnv);\r\n                if (!needsorting && jsScoreChanged) needsorting = true;\r\n                // if mismatch i stop computing the score.\r\n                if (tnv.jsScore === ViewEClassMatch.MISMATCH_JS) { tnv.finalScore = ViewEClassMatch.MISMATCH; continue; }\r\n            }\r\n\r\n            // check pre-ocl guard\r\n            // if (!tv.oclUpdateCondition_PARSED(data, olddata)) continue;\r\n\r\n            if (datachanged || tnv.OCLScore === ViewEClassMatch.NOT_EVALUATED_YET) {\r\n                // check ocl: this can lead to mis-updating if ocl queries a reference.\r\n                // but OCL is computationally heavy, so i decided it is now a requirement to update the model to reevaluate ocl.\r\n                let oldScore = tnv.OCLScore;\r\n                tnv.OCLScore = OCL.test(data, dview, node)//Selectors.calculateOCLScore({data, node, dview});\r\n                tv.oclChanged = false;\r\n                if (!needsorting && tnv.OCLScore !== oldScore) needsorting = true;\r\n                if (tnv.OCLScore === ViewEClassMatch.MISMATCH_OCL) { tnv.finalScore = ViewEClassMatch.MISMATCH; continue; }\r\n            }\r\n        }\r\n\r\n        if (parentViewChanged) needsorting = true; // scores saved in dictionaries are the same, but score in final sorted array changed.\r\n        return needsorting;\r\n    }\r\n\r\n    // get final viewstack for a node, also updates OCL scores if needed because of a change in model or parentView (NOT from a change in view)\r\n    static getAppliedViewsNew({data:data0, node, pv, nid}:{ node: LGraphElement | undefined; data: LModelElement | undefined; pv: DViewElement | undefined; nid: Pointer<DGraphElement>}): NodeTransientProperties {\r\n        // console.trace('2302, getviews', {tnode: transientProperties.node[nid], nid, pv})\r\n        let state = store.getState();\r\n        let needsorting: boolean = Selectors.updateScores(data0, node, nid, pv, state);\r\n\r\n        let tn: NodeTransientProperties = transientProperties.node[nid]; // needs to be placed after updateScores() which will initialize it.\r\n        if (!needsorting && tn.needSorting) needsorting = tn.needSorting;\r\n\r\n\r\n\r\n        type ViewScoreEntry = {element: Pointer<DViewElement>, score: number, view: LViewElement};\r\n        if (needsorting || !tn.stackViews) {\r\n            let mainViews: ViewScoreEntry[] = [];\r\n            let decorativeViews: ViewScoreEntry[] = [];\r\n            for (let vid of Object.keys(tn.viewScores)) {\r\n                let tnv = tn.viewScores[vid];\r\n                const dview: DViewElement = DPointerTargetable.fromPointer(vid, state);\r\n                if (!dview) console.error('missing view, is it an old save with less default views?', {dview, vid, state});\r\n                if (!dview) continue;\r\n\r\n                const score = tnv.finalScore = Selectors.getFinalScore(tnv, vid, pv, dview);\r\n                if (!(score > 0)) continue; // do not flip to <=, because undefined and NEGATIVE_INFINITY always compute to false.\r\n                (dview.isExclusiveView ? mainViews : decorativeViews).push( {element:vid, score, view: LPointerTargetable.fromD(dview)} );\r\n            }\r\n            decorativeViews.sort((s1, s2)=> s2.score - s1.score); // sorted from biggest to smallest\r\n            mainViews.sort((s1, s2)=> s2.score - s1.score); // sorted from biggest to smallest\r\n\r\n            // Log.exDev(!mainViews[0], 'cannot find a matching main view', {mainViews, decorativeViews, data0, scores: tn.viewScores})\r\n            tn.mainView = mainViews[0]?.view;\r\n            tn.validMainViews = mainViews.map((s)=> s.view); // this have duplicates of newly created elements\r\n            tn.stackViews = decorativeViews.map((s)=> s.view);\r\n        }\r\n        // chamges to view or ocl comditiom are mot hamdled here, ut om multple mp/modes a omce\r\n        //nb{}[]\r\n\r\n        // if data or view changed update the score dict, them re-sort the view arr first, fimally update Sorted_modelused, Sorted_modelused\r\n        // console.log('2302 getviews ret', {dn: data?.name, data, stack: transientProperties.node[nid].stackViews, stackn: transientProperties.node[nid].stackViews.map(v => v.name), scores: transientProperties.node[nid]});\r\n\r\n        // throw new Error(\"stop debug\");\r\n        return tn;\r\n\r\n    }\r\n\r\n    static getAllMP(state?: DState): DModelElement[] {\r\n        if (!state) state = store.getState();\r\n        let allD: DPointerTargetable[] = Object.values(state.idlookup);\r\n        return allD.filter( (d: DPointerTargetable) => U.isObject(d) && Selectors.isOfSubclass(d, DModelElement)) as DModelElement[]; }\r\n\r\n    static toObject<D extends DPointerTargetable>(ptrs: Pointer<D>[], state?: DState):D[] {\r\n        if (!state) state = store.getState();\r\n        return ptrs.map(p => (state as DState).idlookup[p]) as D[]; }\r\n\r\n    static wrap<D extends DPointerTargetable, L extends LPointerTargetable>(arr: (Pointer<D, 1, 1, L> | D)[], state?: DState): L[] {\r\n        if (!arr.length) return [];\r\n        if (!state) state = store.getState();\r\n        let objarr: D[];\r\n        if (typeof arr[0] === \"string\") { objarr = Selectors.toObject(arr as string[], state); }\r\n        else objarr = arr as D[];\r\n        return objarr.map(p => RuntimeAccessibleClass.wrap(p)) as L[]; }\r\n\r\n    static unwrap<D extends DPointerTargetable, L extends LPointerTargetable>(arr:L[]): D[] { return arr.map( (a)=> a.__raw) as any[]; }\r\n    static getSubNodeElements(forGraph: Pointer<DGraph, 1, 1>, asPointers: boolean = false, wrap: boolean = false): Pointer<DGraphElement>[] | DGraphElement[] | LGraphElement[] {\r\n        const state : DState = store.getState();\r\n        const g: DGraph = state.idlookup[forGraph] as DGraph;\r\n        if (asPointers) return g.subElements;\r\n        const subelements: DGraphElement[] = g.subElements.map( geid => state.idlookup[geid]) as DGraphElement[];\r\n        if (wrap) return subelements.map<LGraphElement>( (ge) => LPointerTargetable.from(ge));\r\n        return subelements; }\r\n\r\n\r\n\r\n\r\n    //// giordano part\r\n\r\n\r\n\r\n    public static getAllPackageClasses(id: string): LClass[] {\r\n        const data = LPointerTargetable.from(id) as GObject;\r\n        let lPackage : LPackage | undefined;\r\n        const classes: LClass[] = [];\r\n        if (data.className === \"DReference\") {\r\n            const lClass: LClass = LPointerTargetable.from(data.father);\r\n            lPackage = LPointerTargetable.from(lClass.father);\r\n        }\r\n        if (data.className === \"DParameter\") {\r\n            const lOperation: LOperation = LPointerTargetable.from(data.father);\r\n            const lClass: LClass = LPointerTargetable.from(lOperation.father);\r\n            lPackage = LPointerTargetable.wrap(lClass.father);\r\n        }\r\n        if (data.className === \"DOperation\") {\r\n            const lClass: LClass = LPointerTargetable.from(data.father);\r\n            lPackage = LPointerTargetable.wrap(lClass.father);\r\n        }\r\n        if (lPackage) {\r\n            for(let classifier of lPackage.classifiers) {\r\n                const lClassifier: LClass | LEnumerator = LPointerTargetable.from(classifier);\r\n                if(lClassifier.className === \"DClass\") classes.push(lClassifier as LClass);\r\n            }\r\n        }\r\n        return classes;\r\n    }\r\n    public static getAllPackageEnumerators(id: string): LEnumerator[] {\r\n        const data = LPointerTargetable.from(id) as GObject;\r\n        let lPackage : LPackage | undefined;\r\n        const enumerators: LEnumerator[] = [];\r\n        if(data.className === \"DAttribute\") {\r\n            const lClass: LClass = LPointerTargetable.from(data.father);\r\n            lPackage = LPointerTargetable.from(lClass.father);\r\n        }\r\n        if(data.className === \"DParameter\") {\r\n            const lOperation: LOperation = LPointerTargetable.from(data.father);\r\n            const lClass: LClass = LPointerTargetable.from(lOperation.father);\r\n            lPackage = LPointerTargetable.from(lClass.father);\r\n        }\r\n        if(data.className === \"DOperation\") {\r\n            const lClass: LClass = LPointerTargetable.from(data.father);\r\n            lPackage = LPointerTargetable.from(lClass.father);\r\n        }\r\n        if(lPackage) {\r\n            for(let classifier of lPackage.classifiers) {\r\n                const lClassifier: LClass | LEnumerator = LPointerTargetable.from(classifier);\r\n                if(lClassifier.className === \"DEnumerator\") enumerators.push(lClassifier as LEnumerator);\r\n            }\r\n        }\r\n        return enumerators;\r\n    }\r\n\r\n    private static updateJSScore(node: LGraphElement | undefined, data: LModelElement | undefined, dview: DViewElement, tv: ViewTransientProperties, tnv: ViewScore) {\r\n        let oldjsScore = tnv.jsScore;\r\n        let jsConditionChanged: boolean = tv.jsConditionChanged;\r\n        tv.jsConditionChanged = false;\r\n\r\n        // tnv.jsScore = ViewEClassMatch.NOT_EVALUATED_YET as any as number;\r\n        let printstuff = {name: data?.name, jsc:tv.jsCondition, tv:{...tv}, data:data&&data.__raw, node:node&&{...node.__raw}, nerr: (node as any)?.errors}\r\n        if (tv.jsCondition) {\r\n            try {\r\n                tnv.jsScore = tv.jsCondition({data, node, view: LPointerTargetable.fromD(dview), constants: tv.constants});\r\n                // if (tnv.jsScore === true) tnv.jsScore = dview.jsCondition.length;\r\n                switch (typeof tnv.jsScore) {\r\n                    case \"boolean\": // bool is fine if true\r\n                        if (!tnv.jsScore) tnv.jsScore = ViewEClassMatch.MISMATCH_JS;\r\n                        break;\r\n                    case \"number\": // number is fine if not NaN and > 0\r\n                        if (isNaN(tnv.jsScore) || tnv.jsScore < 0) tnv.jsScore = ViewEClassMatch.MISMATCH_JS;\r\n                        break;\r\n                    default:\r\n                        tnv.jsScore = ViewEClassMatch.MISMATCH_JS;\r\n                        break;\r\n                }\r\n            }\r\n            catch (e:any) { // crash = mismatch\r\n                Log.ee(\"failed to evaluate jsCondition: \" + e.message?.split(\"\\n\")[0], {e, data, node, tnv, jsc:tv.jsCondition+''});\r\n                tnv.jsScore = ViewEClassMatch.MISMATCH_JS;\r\n            }\r\n        } else tnv.jsScore = true; // missing condition = match\r\n\r\n        // jsConditionChanged: because even if score didn't change, if jsc.length changed the final computed score is affected\r\n        return jsConditionChanged || tnv.jsScore !== oldjsScore;\r\n    }\r\n}\r\n\r\n(window as any).Selectors = Selectors;\r\n\r\nclass Scored<T extends GObject> {\r\n    constructor(public score: number, public element: T) {}\r\n}\r\n","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\redux\\reducer\\reducer.ts",["1012","1013","1014","1015","1016","1017","1018","1019","1020","1021","1022","1023","1024","1025","1026","1027","1028","1029","1030","1031","1032","1033","1034","1035","1036","1037","1038","1039","1040","1041","1042"],"import {\r\n    U as UType,\r\n    GraphDragManager,\r\n    MouseUpEvent,\r\n    orArr,\r\n    DModelElement,\r\n    DViewElement,\r\n    DClass,\r\n    DModel,\r\n    UX,\r\n    EdgeOwnProps,\r\n    EdgeStateProps,\r\n    GraphElementComponent,\r\n    ViewEClassMatch,\r\n    bool,\r\n    NodeTransientProperties,\r\n    ViewTransientProperties,\r\n    DGraphElement, Uarr,\r\n    Uobj, LocalStorage,\r\n    LProject,\r\n    DProject,\r\n    LUser, UserHistory, R,\r\n} from '../../joiner';\r\nimport {\r\n    Action,\r\n    CompositeAction,\r\n    CreateElementAction,\r\n    DeleteElementAction,\r\n    Dictionary,\r\n    DocString,\r\n    DPointerTargetable,\r\n    DState,\r\n    DUser,\r\n    getPath,\r\n    GObject,\r\n    Log,\r\n    LPointerTargetable,\r\n    MyError,\r\n    ParsedAction,\r\n    PendingPointedByPaths,\r\n    PointedBy,\r\n    Pointer,\r\n    Pointers,\r\n    RuntimeAccessibleClass,\r\n    SetFieldAction,\r\n    SetRootFieldAction,\r\n    statehistory\r\n} from \"../../joiner\";\r\nimport React from \"react\";\r\nimport {BEGIN, COMMIT, END, LoadAction, RedoAction, UndoAction} from \"../action/action\";\r\nimport Collaborative from \"../../components/collaborative/Collaborative\";\r\nimport {SimpleTree} from \"../../common/SimpleTree\";\r\nimport {transientProperties, Selectors} from \"../../joiner\";\r\nimport {OclEngine} from \"@stekoe/ocl.js\";\r\nimport { contextFixedKeys } from '../../graph/graphElement/sharedTypes/sharedTypes';\r\nimport Storage from \"../../data/storage\";\r\nimport {AuthApi, ProjectsApi} from \"../../api/persistance\";\r\nimport DSL from \"../../DSL/DSL\";\r\n\r\nlet windoww = window as any;\r\nlet U: typeof UType = windoww.U;\r\n\r\n\r\nfunction deepCopyButOnlyFollowingPath(oldStateDoNotModify: DState, action: ParsedAction, prevAction: ParsedAction, newVal: any): DState | false{\r\n    let newRoot: DState = {...oldStateDoNotModify} as DState;\r\n    let current: any = newRoot;\r\n    if (!action.path?.length) throw new MyError(\"path length must be at least 1\", {action});\r\n    let gotChanged: boolean = false; // dovrebbe cambiare sempre, se non cambia non lancio neanche l'azione e non faccio la shallow copy, ma non si sa mai, così posso evitare un render se succede l' \"insuccedibile\"\r\n    let alreadyPastDivergencePoint = false; // true dal momento in cui il path dell'azione attuale e della azione precedente divergono, false fino al sotto-segmento in cui combaciano\r\n    // console.log('deepCopyButOnlyFollowingPath', arguments);\r\n    for (let i = 0; i < action.pathArray.length; i++) {\r\n        let key = action.pathArray[i].trim();\r\n        let prevActionPathKey = prevAction?.pathArray[i];\r\n        // middle execution: not on final loop\r\n        // console.log('deepCopyButOnlyFollowingPath', {current, i, imax:action.pathArray.length, key, gotChanged, alreadyPastDivergencePoint});\r\n        if (i !== action.pathArray.length - 1) {\r\n            if (alreadyPastDivergencePoint || key !== prevActionPathKey) {\r\n                // se l'oggetto è stato già duplicato in una azione composita, non lo duplico 2 volte.\r\n                alreadyPastDivergencePoint = true;\r\n                current[key] = Array.isArray(current[key]) ? [...current[key]] : {...current[key]};\r\n                current[key].clonedCounter = 1 + (current[key].clonedCounter || 0);\r\n            }\r\n            current = current[key];\r\n            continue;\r\n        }\r\n        // Giordano: added this on 03/12/2023 to prevent \"Cannot read properties of undefined\".\r\n        // if(!current) continue; damiano: temp removed to check if there are invalid actions firing\r\n        // perform final assignment\r\n        if (i >= action.pathArray.length - 1) {\r\n            let isArrayAppend = false;\r\n            let isArrayRemove = false;\r\n            let isObjectMerge = false;\r\n            let isObjectDifference = false;\r\n            // console.log('isarrayappend?', {endswith: U.endsWith(key, ['+=', '[]', '-1']), key, action, i});\r\n            // console.log('isarraydelete?', {endswith: U.endsWith(key, ['-='])});\r\n\r\n            let oldValue: any;\r\n            if (U.endsWith(key, ['+=', '[]'])) {\r\n                key = key.substr(0, key.length - 2).trim();\r\n                oldValue = current[key];\r\n                switch (typeof oldValue){\r\n                    case 'object':\r\n                    if (Array.isArray(oldValue)) isArrayAppend = true;\r\n                    else isObjectMerge = true;\r\n                    break;\r\n                    default: newVal += oldValue; break;\r\n                }\r\n            }\r\n            if (U.endsWith(key, ['-='])) {\r\n                key = key.substr(0, key.length - 2).trim();\r\n                oldValue = current[key];\r\n                switch (typeof oldValue){\r\n                    case 'object':\r\n                        if (Array.isArray(oldValue)) isArrayRemove = true;\r\n                        else isObjectDifference = true;\r\n                        break;\r\n                    case \"string\":\r\n                        newVal = U.replaceAll(oldValue, newVal, '');\r\n                        break;\r\n                    case 'number': newVal = oldValue - newVal; break;\r\n                    default: isArrayRemove = true; break;\r\n                }\r\n                // isArrayRemove = true;\r\n            }\r\n\r\n            // let unpointedElement: DPointerTargetable | undefined;\r\n            // perform final assignment\r\n            if (action.type === CreateElementAction.type && current[key]) {\r\n                oldValue = current[key];\r\n                gotChanged = false;\r\n                Log.ee(\"rejected CreateElementAction, rollback occurring:\", {action,\r\n                    preexistingValue: current[key], isShallowEqual: current[key] === action.value });\r\n                return false; // warning: use return only when you want to abort and skip subsequent CompositeAction sub-actions like now.\r\n            }\r\n            if (isObjectMerge) {\r\n                if (typeof newVal === 'string') { let tmp: any = {}; tmp[newVal] = true; newVal = tmp; }\r\n                oldValue = {...current[key]};\r\n                current[key] = {...current[key]};\r\n                for (let subkey in newVal) {\r\n                    // console.warn(\"object merge\", {current, key, subkey, newVal, old:current[key][subkey], new:newVal[subkey]});\r\n                    if (current[key][subkey] === newVal[subkey]) continue;\r\n                    current[key][subkey] = newVal[subkey];\r\n                    gotChanged = true;\r\n                    if (action.isPointer) { newRoot = PointedBy.add(key as Pointer, action, newRoot, \"+=\"); }\r\n                }\r\n            } else\r\n            if (isObjectDifference) {\r\n                if (typeof newVal === 'string') { let tmp: any = {}; tmp[newVal] = true; newVal = tmp; }\r\n                oldValue = {...current[key]};\r\n                current[key] = {...current[key]};\r\n                for (let subkey in newVal) {\r\n                    if (!(subkey in current[key])) continue;\r\n                    delete current[key][subkey];\r\n                    gotChanged = true;\r\n                    if (action.isPointer) { newRoot = PointedBy.add(key as Pointer, action, newRoot, \"-=\"); }\r\n                }\r\n            } else\r\n            if (isArrayAppend) {\r\n                gotChanged = true;\r\n                if (!Array.isArray(current[key])) { current[key] = []; }\r\n                oldValue = [...current[key]];\r\n                current[key] = [...current[key]];\r\n                current[key].push(newVal);\r\n                // unpointedElement = undefined;\r\n                if (action.isPointer) { newRoot = PointedBy.add(newVal as Pointer, action, newRoot, \"+=\"); }\r\n            } else\r\n            if (isArrayRemove) {\r\n                if (!Array.isArray(current[key])) { current[key] = []; }\r\n                oldValue = [...current[key]];\r\n                let index: number;\r\n                if (U.isNumber(newVal)) { // delete by index\r\n                    index = newVal;\r\n                    if (index < 0) index = oldValue.length + index; // if index is -2, i remove the penultimate element\r\n                } else\r\n                if (newVal === undefined) {\r\n                    index = oldValue.length - 1;\r\n                }\r\n                else {\r\n                    index = oldValue.indexOf(newVal);\r\n                }\r\n                // if it's negatively or positively out of boundary, i skip it\r\n                gotChanged = index >= 0 && index < current[key].length;\r\n                if (gotChanged) {\r\n                    current[key] = [...current[key]];\r\n                    let removedval = current[key].splice(index, 1); // in-place edit\r\n                    if (action.isPointer) { newRoot = PointedBy.remove(removedval as Pointer, action, newRoot, '-='); }\r\n                    /*\r\n                    fixed problem: se ho [dobj1, dobj2]... e li swappo, cambia un indice nel percorso \"pointedby\" e non me ne accorgo mai e un oggetto risulta \"pointedby\" da oggetti che non lo puntano o non esistono più a quell'indice\r\n                    SOLVED! by not including index in pointedBy path, but making it like \"parentObject.arrayKey+=\" instead of \"parentObject.arrayKey.4\"\r\n                    and knowing it's in the array it's enough info.\r\n\r\n                    // a.pointsto = [x, y, z]; a.pointsto = [x, z]       --->    remove a from y.pointedby\r\n                    const elementsThatChangedIndex: DPointerTargetable[] = current[key].slice(index);\r\n\r\n                    for (let j = 0; j < elementsThatChangedIndex.length; j++) {\r\n                        let newindex = index + j - 1;\r\n                        let oldFullpathTrimmed = action.pathArray.join('.');\r\n                        se realizzi \"pointedby\" qui è to do: remove old paths and re-add them with updated index\r\n                    }\r\n                    unpointedElement = newRoot.idlookup[oldValue];\r\n                    */\r\n                }\r\n            } else\r\n            if ((action.type === DeleteElementAction.type && !(key in current)) || current[key] === newVal) {\r\n                // value not changed\r\n                gotChanged = false;\r\n            } else {\r\n                // value changed\r\n                // todo: caso in cui setto manualmente classes.1 = pointer;\r\n                //  the latest element is array and not DPointerTargetable, so might need to buffer upper level in the tree? or instead of \"current\" keep an array of sub-objects encountered navigating the path in state.\r\n                oldValue = current[key];\r\n                gotChanged = true;\r\n                // unpointedElement = newRoot.idlookup[oldValue];\r\n                // NB: se elimino un oggetto che contiene array di puntatori, o resetto l'array di puntatori kinda like store.arr= [ptr1, ptr2, ...]; store.arr = [];\r\n                // i puntati dall'array hanno i loro pointedBY non aggiornati, non voglio fare un deep check di tutto l'oggetto a cercare puntatori per efficienza.\r\n                // if (newVal === undefined) delete current[key];\r\n                if ((newVal === undefined) || false && action.type === DeleteElementAction.type) delete current[key];\r\n                else current[key] = newVal;\r\n\r\n                // update pointedBy's\r\n                // NB: even if the current action have isPointer=true, it doesn't mean the old value is a pointer as well for sure. so need to check old values.\r\n                // also what if old val is pointer, and new one isn't? will it be just removed without updating pointedBy's?\r\n                // already fixed: might need to evaluate this if block always regardless of action.isPointer,\r\n                // and do checks every time both on old and new value if they actually are ptrs.\r\n                if (true || action.isPointer) {\r\n                    let oldpointerdestinations: unknown[];\r\n                    let newpointerdestinations: unknown[];\r\n                    if (Array.isArray(newVal)) {\r\n                        newpointerdestinations = newVal;\r\n                        if (Array.isArray(oldValue)) { // case: path.array = array;\r\n                            oldpointerdestinations = oldValue;\r\n                        }\r\n                        else { // case: path.object = array; + case: path.value = array;\r\n                            oldpointerdestinations = [oldValue];\r\n                        }\r\n                    }\r\n                    else {\r\n                        // case: path.array = object; + case: path.array = value;\r\n                        newpointerdestinations = [newVal];\r\n                        if (Array.isArray(oldValue)) {\r\n                            oldpointerdestinations = oldValue;\r\n                        } else {\r\n                            // case: path.object = object; and all other cases without arrays involved\r\n                            oldpointerdestinations = [oldValue];\r\n                        }\r\n                    }\r\n                    // after i mapped all cases to path.array = array; i solve it for that case.\r\n                    let difference = U.arrayDifference(oldpointerdestinations, newpointerdestinations); // : {added: Pointer[], removed: Pointer[], starting: Pointer[], final: Pointer[]}\r\n                    for (let rem of difference.removed) {if (Pointers.isPointer(rem))\r\n                        newRoot = PointedBy.remove(rem, action, newRoot, undefined, oldStateDoNotModify); }\r\n                    for (let add of difference.added) { if (Pointers.isPointer(add))\r\n                        newRoot = PointedBy.add(add, action, newRoot, undefined, oldStateDoNotModify); }\r\n                    // a.pointsto = [a, b, c];  a.pointsto = [a, b, x];    ------>     c.pointedby.remove(a) & x.pointedby.add(a)\r\n                    // idlookup.somelongid.pointsto = [...b];\r\n                }\r\n            }\r\n            break;\r\n        }\r\n        Log.exDevv('should not reach here: reducer');\r\n    }\r\n    return gotChanged ? newRoot : oldStateDoNotModify;\r\n}\r\n\r\n\r\n// const pendingPointedByPaths: {from: DocString<\"Path in store\">, field: DocString<\"keyof object found in from path\">, to: Pointer}[] = [];\r\nfunction CompositeActionReducer(oldState: DState, actionBatch: CompositeAction): DState {\r\n    // per via di thunk se arrivo qui lo stato cambia sicuro in mono-client non synchro (non ri-assegno valori equivalenti)\r\n    // todo: ma se arrivano in ordine sbagliato da altri client? posso permetterlo?\r\n    let actions: ParsedAction[];\r\n    if (actionBatch.actions) actions = Action.parse(actionBatch.actions);\r\n    else actions = [Action.parse(actionBatch)]; // else-case is if it's a single action and not an actual compositeaction\r\n    if (PendingPointedByPaths.all.length) actions.push(...PendingPointedByPaths.getSolveableActions(oldState)); //.all.map( p=> p.resolve() ) );\r\n\r\n    Action.possibleInconsistencies = {};\r\n\r\n    // estraggo le azioni derivate\r\n    let derivedActions: ParsedAction[] = [];\r\n    let newState = oldState;\r\n    for (let action of actions) {\r\n        switch (action.type){\r\n            default: break;\r\n            case CreateElementAction.type:\r\n                const elem: DPointerTargetable = action.value;\r\n                delete DPointerTargetable.pendingCreation[elem.id];\r\n                /*\r\n                if (oldState.idlookup[elem.id]) {\r\n                    Log.ee(\"rejected CreateElementAction, rollback occurring:\", {action, elem:{...elem},\r\n                        preexistingValue: {...oldState.idlookup[elem.id]}, isEqual: elem === oldState.idlookup[elem.id] });\r\n                    return oldState; // warning: use return only when you want to abort and skip subsequent CompositeAction sub-actions like now.\r\n\r\n                    action.value = \"An element with that id already existed.\";\r\n                    action.path = action.field = \"CreateActionRejected\";\r\n                    action.className = SetRootFieldAction.name;\r\n                    action.type = SetRootFieldAction.type;\r\n                    action.pathArray = [action.path]; //a\r\n                    action.isPointer = false;\r\n                    // just to log it in undo-redo action list and have a feedback\r\n                    return oldState;}*/\r\n\r\n                elem.className = elem.className || (elem.constructor as typeof RuntimeAccessibleClass).cname || elem.constructor.name;\r\n                let statefoldername = elem.className.substring(1).toLowerCase() + 's';\r\n                derivedActions.push(\r\n                    Action.parse(SetRootFieldAction.create(statefoldername, elem.id,'[]', true)));\r\n                if (!Array.isArray(elem.pointedBy)) elem.pointedBy = [];\r\n                elem.pointedBy.push(PointedBy.new(statefoldername));\r\n                /*if (false && action.isPointer) {\r\n                    if (Array.isArray(action.value)) {\r\n                        const ptr: Pointer[] = action.value;\r\n                        // todo but replaced by side actions in execution of the main action instead of triggering derived actions\r\n                    }\r\n                    else {\r\n                        const ptr: Pointer = action.value;\r\n                        const target: DPointerTargetable | null = oldState.idlookup[ptr];\r\n                        let pendingPointedBy = PendingPointedByPaths.new(action, oldState);\r\n                        if (!target) PendingPointedByPaths.new(action, oldState).saveForLater(); // {from: action.path, field: action.field, to: target});\r\n                        // @ts-ignore\r\n                        else derivedActions.push(pendingPointedBy.resolve());\r\n                        // a -> x\r\n                        // a -> y     unset x.pointedby(a)\r\n                    }\r\n                }*/\r\n                break;\r\n        }\r\n    }\r\n    // console.error({U, Umip:U.arrayMergeInPlace, WU: windoww.U, WUmip: windoww.U.arrayMergeInPlace});\r\n    actions = U.arrayMergeInPlace<ParsedAction>(actions, derivedActions);\r\n\r\n    // ordino i path con segmenti comuni todo: da rimuovere\r\n    actions = actions.sort( (a1, a2) => {\r\n        if (a1.className !== a2.className) {\r\n            if (a1.className === DeleteElementAction.cname) return 1;\r\n            if (a2.className === DeleteElementAction.cname) return -1;\r\n        }\r\n        return U.stringCompare(a1.path, a2.path);\r\n    });\r\n\r\n    // destrutturo solo i nodi intermedi e solo la prima volta che li incontro (richiede le azioni ordinate in base al path)\r\n\r\n    for (let i = 0; i < actions.length; i++) {\r\n        const prevAction: ParsedAction = actions[i-1];\r\n        const action: ParsedAction = actions[i];\r\n        const actiontype = action.type.indexOf('@@') === 0 ? 'redux' : action.type;\r\n        console.log('executing action:', {a:action, t:actiontype, field: action.field, v:action.value}); //, count: ++action.executionCount});\r\n\r\n        switch (actiontype) {\r\n            /*\r\n            case '@@redux/INIT' + randomstr:... etc*/\r\n            default:\r\n                if (action.type.indexOf('@@redux/') === 0) break;\r\n                return Log.exDevv('unexpected action type:', action.type);\r\n            case LoadAction.type: newState = action.value; break;\r\n            case CreateElementAction.type:\r\n            case SetRootFieldAction.type:\r\n            case DeleteElementAction.type:\r\n            case SetFieldAction.type:\r\n                let tmp: false | DState = deepCopyButOnlyFollowingPath(newState, action, prevAction, action.value);\r\n                if (!tmp) return oldState; // rollback due to invalid action in transaction\r\n                newState = tmp;\r\n                break;\r\n        }\r\n\r\n        // and that's all, the reducer is really simple as actions are really simple.\r\n    }\r\n\r\n    // effetti collaterali, aggiornamento di ridondanze\r\n    newState = updateRedundancies_OBSOLETE(newState, oldState, Action.possibleInconsistencies);\r\n    return newState;\r\n}\r\n\r\nfunction updateRedundancies_OBSOLETE(state: DState, oldState:DState, possibleInconsistencies: Dictionary<DocString<'subtype'>, (Pointer | DPointerTargetable)[]>): DState {\r\n    for (let subType in possibleInconsistencies)\r\n    switch (subType) {\r\n        default: break;\r\n        case Action.SubType.vertexSubElements:/*\r\n            risolto triggrerando più azioni da LGraphElement setter\r\n            let dvertexid: Pointer, newdvertex: DGraphElement, olddvertex: DGraphElement;\r\n            for (newdvertex of possibleInconsistencies[subType] as DGraphElement[]){\r\n                const olddvertex: DGraphElement = oldState.idlookup[newdvertex.id] as DGraphElement;\r\n                const notContainedAnymoreOut: Pointer<DGraphElement> = [];\r\n                const newlyInsertedOut: Pointer<DGraphElement>[] = [];\r\n                U.arraySymmetricDifference(olddvertex.subElements, newdvertex.subElements, notContainedAnymoreOut, newlyInsertedOut);\r\n                for (let geid of notContainedAnymoreOut) {\r\n                    const oldge = oldState.idlookup[geid] as DGraphElement;\r\n                    const newge = state.idlookup[geid] as DGraphElement;\r\n                    if (oldge.containedIn === newge.containedIn) continue;\r\n                }\r\n                for (let geid of notContainedAnymoreOut) {\r\n                    const ge = idlookup[geid] as DGraphElement;\r\n                    if (ge.containedIn === context.data.id) set container = context.data.id\r\n                    meglio se sti 2 cicli li fai nel reducer perchè  potrebbe esserci una azione pending che setta il parent = someotherid e qui faccio partire una azione che setta il parent a null, \"annullando\" una azione pending non ancora eseguita\r\n                }\r\n            }\r\n            break;*/\r\n    }\r\n    // if state is updated shallow copy state before returning it\r\n    return state;\r\n}\r\n\r\nlet initialState: DState = null as any;\r\nlet storeLoaded: boolean = false;\r\n\r\nconst UDRegexp = /(?:^|\\s|;|}|\\n|\\t|\\(|,)ret\\s*\\.\\s*[a-zA-Z_$][0-9a-zA-Z_$]*\\s*=/g;\r\n/* tested with:\r\nif (ret.key = stuff) ret.key2=morestuff;\r\n;ret.k=3;\r\n}ret. kk=3,ret. a = 3\r\n\r\nret .b = 3\r\n*/\r\n\r\n\r\n// then add to it: content of props, constants, usageDeclarations\r\n\r\nexport function reducer(oldState: DState = initialState, action: Action): DState {\r\n    if (U.navigating) return oldState;\r\n    if (!windoww.jjactions) windoww.jjactions = [];\r\n    windoww.jjactions.push(action);\r\n    try{ return unsafereducer(oldState, action); }\r\n    catch(e) {\r\n        console.error('unhandled error in reducer', {e, oldState, action});\r\n        return oldState;\r\n    }\r\n}\r\n\r\nfunction unsafereducer(oldState: DState = initialState, action: Action): DState {\r\n    if (!oldState) { oldState = initialState = DState.new(); }\r\n    // console.log('external REDUCER', {action, CEtype:CreateElementAction.type});\r\n\r\n    const ret = _reducer(oldState, action);\r\n    if (ret === oldState) return oldState;\r\n    ret.idlookup.__proto__ = DPointerTargetable.pendingCreation as any;\r\n    // client synchronization stuff\r\n    if (oldState?.collaborativeSession) {\r\n        const ignoredFields: (keyof DState)[]  = [\r\n            'version',\r\n            'env',\r\n            'debug',\r\n            'isEdgePending',\r\n            'contextMenu',\r\n            '_lastSelected',\r\n            'isLoading',\r\n            'collaborativeSession',\r\n            'VIEWS_RECOMPILE_onDataUpdate',\r\n            'VIEWS_RECOMPILE_onDragStart',\r\n            'VIEWS_RECOMPILE_onDragEnd',\r\n            'VIEWS_RECOMPILE_whileDragging',\r\n            'VIEWS_RECOMPILE_onResizeStart',\r\n            'VIEWS_RECOMPILE_onResizeEnd',\r\n            'VIEWS_RECOMPILE_whileResizing',\r\n            'VIEWS_RECOMPILE_onRotationStart',\r\n            'VIEWS_RECOMPILE_onRotationEnd',\r\n            'VIEWS_RECOMPILE_whileRotating',\r\n            'VIEWS_RECOMPILE_constants',\r\n            'VIEWS_RECOMPILE_usageDeclarations',\r\n            'VIEWS_RECOMPILE_jsxString',\r\n            'VIEWS_RECOMPILE_preconditions',\r\n            'VIEWS_RECOMPILE_jsCondition',\r\n            'VIEWS_RECOMPILE_ocl',\r\n            'VIEWS_RECOMPILE_events',\r\n            'VIEWS_RECOMPILE_all',\r\n            'ClassNameChanged',\r\n            'tooltip',\r\n            'advanced',\r\n            'alert'\r\n        ];\r\n        /* Checking if CompositeAction has some actions that MUST be ignored */\r\n        let compositeAction: CompositeAction|null = null;\r\n        if(action.type === CompositeAction.type) {\r\n            compositeAction = action as CompositeAction;\r\n            const subActions = compositeAction.actions || [];\r\n            compositeAction.actions = subActions.filter(a => !ignoredFields.includes(a.field as keyof DState));\r\n        }\r\n        if(compositeAction && !compositeAction.actions.length) return ret;\r\n        action = (compositeAction) ? compositeAction : action;\r\n        if(action.sender === DUser.current && !ignoredFields.includes(action.field as keyof DState)) {\r\n            const parsedAction: JSON & GObject = JSON.parse(JSON.stringify(action));\r\n            Collaborative.client.emit('pushAction', parsedAction);\r\n        }\r\n    }\r\n\r\n    function filterSet<T extends any>(r: T[]): Set<T>{\r\n        if (!Array.isArray(r)) r = [];\r\n        r = r.filter(e=>!!e);\r\n        return new Set(r);\r\n    }\r\n    // recompile stuff\r\n    for (let ptr of filterSet(ret.ELEMENT_CREATED)){\r\n        let d = ret.idlookup[ptr];\r\n        if (!d) continue; // creation rejected, no-op\r\n        switch(d.className){\r\n            default: break;\r\n            case \"DViewElement\":\r\n                for(let nid in transientProperties.node){\r\n                    let tn = transientProperties.node[nid];\r\n                    delete tn.viewScores[d.id as any]; //= {} as any;\r\n                }\r\n        }\r\n    }\r\n    ret.ELEMENT_CREATED = [];\r\n    for (let ptr of filterSet(ret.ELEMENT_DELETED)){\r\n        let d = oldState.idlookup[ptr];\r\n        if (!d) continue; // already deleted, no-op\r\n        switch(d.className){\r\n            default: break;\r\n            case \"DViewElement\":\r\n                for (let nid in transientProperties.node) {\r\n                    let tn = transientProperties.node[nid];\r\n                    // delete tn.stackViews; // trigger recalc of all scores.\r\n                    delete tn.viewScores[d.id as any];\r\n                    tn.needSorting = true;\r\n                }\r\n        }\r\n    }\r\n    ret.ELEMENT_DELETED = [];\r\n\r\n    if (ret.VIEWS_RECOMPILE_all === true) ret.VIEWS_RECOMPILE_all = Object.keys(ret.idlookup);\r\n    if ((ret.VIEWS_RECOMPILE_all as Pointer[])?.length) {\r\n        let resetAllNodes: boolean = false;\r\n        let sk: keyof DState;\r\n        for (let id of filterSet(ret.VIEWS_RECOMPILE_all as Pointer[])){\r\n            let d = ret.idlookup[id];\r\n            if (!d) continue;\r\n            if (RuntimeAccessibleClass.extends(d.className, \"DViewElement\")) {\r\n                (d as DViewElement).css_MUST_RECOMPILE = true;\r\n                transientProperties.view[d.id as string] = { } as any;\r\n                // for (let k of DViewElement.MeasurableKeys) (ret as any)['VIEWS_RECOMPILE_'+k].push(d.id);\r\n                // for (let k of DViewElement.RecompileKeys) (ret as any)['VIEWS_RECOMPILE_'+k].push(d.id);\r\n                for (sk in ret) if (sk.indexOf('VIEWS_RECOMPILE') === 0) (ret[sk] as Pointer[]).push(id);\r\n                // ret.NODES_RECOMPILE_labels.push(id); ret.NODES_RECOMPILE_longestLabel.push(id);\r\n                if (!resetAllNodes) resetAllNodes = true;\r\n            }\r\n            if (RuntimeAccessibleClass.extends(d.className, \"DModelElement\")) {\r\n                if (d.className === \"DClass\") {\r\n                    let oldname = (oldState.idlookup[d.id] as DClass)?.name;\r\n                    let newname = (ret.idlookup[d.id] as DClass)?.name;\r\n                    if (oldname !== newname) ret.ClassNameChanged[d.id as Pointer<DClass>] = oldname;\r\n                }\r\n                for (sk in ret) if (sk.indexOf('MODELS_RECOMPILE') === 0) (ret[sk] as Pointer[]).push(id);\r\n                // transientProperties.modelElement[d.id] = { } as any; stuff in here does not need replacement, can never be dangerous (currently).\r\n            }\r\n            if (RuntimeAccessibleClass.extends(d.className, \"DGraphElement\")) {\r\n                delete transientProperties.node[d.id as string]; // = { } as any;\r\n                // transientProperties.node[d.id as string] = undefined as any;\r\n                console.warn('tn deleted', {tn:transientProperties.node[d.id as string], id:d.id});\r\n                for (sk in ret) if (sk.indexOf('NODES_RECOMPILE') === 0) (ret[sk] as Pointer[]).push(id);\r\n                //ret.NODES_RECOMPILE_labels.push(id); ret.NODES_RECOMPILE_longestLabel.push(id);\r\n            }\r\n        }\r\n\r\n        if (resetAllNodes) for (let nid in transientProperties.node) {\r\n            delete transientProperties.node[nid];// = {} as any;\r\n            // transientProperties.node[nid] = undefined as any;\r\n            console.warn('tn deleted 2', {tn:transientProperties.node[nid], nid});\r\n            for (sk in ret) if (sk.indexOf('NODES_RECOMPILE') === 0) (ret[sk] as Pointer[]).push(nid);\r\n            //ret.NODES_RECOMPILE_labels.push(id); ret.NODES_RECOMPILE_longestLabel.push(id);\r\n        }\r\n    }\r\n    ret.VIEWS_RECOMPILE_all = [];\r\n\r\n\r\n    function parseLabel(ptr: Pointer, key: \"labels\" | \"longestLabel\", isNode: boolean): boolean{\r\n        let dv: GObject<DViewElement | DGraphElement> = DPointerTargetable.fromPointer(ptr, ret);\r\n        let tp: NodeTransientProperties | ViewTransientProperties = ((isNode ? transientProperties.node : transientProperties.view) as GObject)[ptr];\r\n        if (!tp) {\r\n            if (isNode) transientProperties.node[ptr as any] = tp = new NodeTransientProperties();\r\n            else transientProperties.view[ptr as any] = tp = new ViewTransientProperties();\r\n        }\r\n        let val: string = dv[key];\r\n        if (!val) { tp[key] = undefined as any; return true; }\r\n        if (typeof val === \"function\") { tp[key] = val; return true; }\r\n        let allContextKeys = {...contextFixedKeys};\r\n        let vid: Pointer<DViewElement> = isNode ? (tp as NodeTransientProperties).mainView?.id : ptr as any;\r\n        if (!vid) return false; // leave pending & recompute them on next reducer action\r\n        let tv = transientProperties.view[vid];\r\n        for (let k of tv.constantsList) if (!allContextKeys[k]) allContextKeys[k] = true;\r\n        for (let k of tv.UDList) if (!allContextKeys[k]) allContextKeys[k] = true;\r\n        let paramStr = '{'+Object.keys(allContextKeys).join(',')+'}';\r\n        console.log('labels parse', { allContextKeys, ud:tv.UDList, c:tv.constantsList });\r\n        const body: string =  'return (' + val + ')';\r\n        console.log('labels parse', {vid: ptr, paramStr, body});\r\n        try {\r\n            if (isNode) {\r\n                // need to store the function in tnv instead of tn since if v changes, ud changes as well? in all of them?what if i make a new view?\r\n            }\r\n            else {\r\n                // tp[key] = new Function(paramStr, body) as ((...a: any) => any);\r\n            }\r\n            tp[key] = function(){ return 'label as an option is disabled, pass it through props instead.'; }\r\n        }\r\n        catch (e: any) {\r\n            /*try{\r\n                let try_to_get_better_error = eval(\"let __f = function(\" + paramStr+\") {\\n\" + body + \"}\");\r\n            } catch(eeval){\r\n                console.error(\"eval error same as func error\", {e, eeval});\r\n                e = eeval;\r\n            }*/\r\n            console.error('error labels parse', {vid: ptr, e, paramStr, body});\r\n            tp[key] = val;// (context: GObject) => 'Error during label evaluation';\r\n        }\r\n        return true;\r\n        // implies recompilation of: ... nothing?\r\n    }\r\n    let arr: Pointer<any>[]\r\n    arr = ret.NODES_RECOMPILE_labels;\r\n    if (arr.length) {\r\n        let successfullyParsed: Dictionary<string, boolean> = {};\r\n        for (const id of filterSet(arr)) successfullyParsed[id] = parseLabel(id, 'labels', true);\r\n        ret.NODES_RECOMPILE_labels = arr.filter(e => !successfullyParsed[e]);\r\n    }\r\n    arr = ret.NODES_RECOMPILE_longestLabel;\r\n    if (arr.length) {\r\n        let successfullyParsed: Dictionary<string, boolean> = {};\r\n        for (const id of filterSet(arr)) successfullyParsed[id] = parseLabel(id, 'longestLabel', true);\r\n        ret.NODES_RECOMPILE_longestLabel = arr.filter(e => !successfullyParsed[e]);\r\n    }\r\n    arr = ret.VIEWS_RECOMPILE_labels;\r\n    if (arr.length) {\r\n        let successfullyParsed: Dictionary<string, boolean> = {};\r\n        for (const id of filterSet(arr)) successfullyParsed[id] = parseLabel(id, 'labels', false);\r\n        ret.VIEWS_RECOMPILE_labels = arr.filter(e => !successfullyParsed[e]);\r\n    }\r\n    arr = ret.VIEWS_RECOMPILE_longestLabel;\r\n    if (arr.length) {\r\n        let successfullyParsed: Dictionary<string, boolean> = {};\r\n        for (const id of filterSet(arr)) successfullyParsed[id] = parseLabel(id, 'longestLabel', false);\r\n        ret.VIEWS_RECOMPILE_longestLabel = arr.filter(e => !successfullyParsed[e]);\r\n    }\r\n\r\n    // local changes to out-of-redux stuff\r\n    if (ret.VIEWS_RECOMPILE_ocl.length) {\r\n        // for (let gid of filterSet(ret.graphs)) Selectors.updateViewMatchings(gid, ret.modelElements, Object.values(ret.idlookup).map( d => RuntimeAccessibleClass.extends(d, DModelElement.cname)));\r\n        // for (let vid of filterSet(ret.VIEW_APPLIABLETO_NEEDS_RECALCULATION)) { }\r\n        for (let vid of filterSet(ret.VIEWS_RECOMPILE_ocl)) {\r\n            if (!transientProperties.view[vid]) transientProperties.view[vid] = {} as any;\r\n            transientProperties.view[vid].oclEngine = undefined as any; // force re-parse\r\n            transientProperties.view[vid].oclChanged = true;\r\n            for (let nid in transientProperties.node) {\r\n                let tnv = transientProperties.node[nid].viewScores[vid];\r\n                if (tnv?.OCLScore !== ViewEClassMatch.NOT_EVALUATED_YET) tnv.OCLScore = ViewEClassMatch.NOT_EVALUATED_YET as any as boolean;\r\n            }\r\n        }\r\n        ret.VIEWS_RECOMPILE_ocl = [];\r\n    }\r\n    /*\r\n    if (ret.VIEWOCL_UPDATE_NEEDS_RECALCULATION.length) {\r\n        // not implemented for now\r\n        ret.VIEWOCL_UPDATE_NEEDS_RECALCULATION = [];\r\n    }*/\r\n\r\n    if (ret.VIEWS_RECOMPILE_preconditions.length) {\r\n        for (let vid of filterSet(ret.VIEWS_RECOMPILE_preconditions)) {\r\n            for (let nid in transientProperties.node) {\r\n                let tnv = transientProperties.node[nid].viewScores[vid];\r\n                if (tnv?.metaclassScore !== ViewEClassMatch.NOT_EVALUATED_YET) tnv.metaclassScore = ViewEClassMatch.NOT_EVALUATED_YET as any as number;\r\n            }\r\n        }\r\n        ret.VIEWS_RECOMPILE_preconditions = [];\r\n    }\r\n\r\n    if (ret.VIEWS_RECOMPILE_constants?.length)\r\n    for (const vid of filterSet(ret.VIEWS_RECOMPILE_constants)) { // compiled in func, and executed, result does not vary between nodes.\r\n        let dv: DViewElement = DPointerTargetable.fromPointer(vid, ret);\r\n        // transientProperties.view[vid].constantsList = dv.constants?.match(UDRegexp).map(s=>s.substring(4, s.length-1).trim()) || [];\r\n        // let allContextKeys = {...contextFixedKeys};\r\n        if (!dv.constants) {\r\n            if (!transientProperties.view[vid]) transientProperties.view[vid] = {} as any;\r\n            transientProperties.view[vid].constants = {};\r\n            transientProperties.view[vid].constantsList = [];\r\n            // no need to recompile UD, jsx or measurables, they will have additional parameters in scope but they are undefined and cause no problems.\r\n            continue;\r\n        }\r\n        const constantsOutput: GObject = {};\r\n        const context = {view:dv}; // context at this point holds only static stuff, which are in gloval scope (window) plus view.\r\n        let paramStr = '{'+Object.keys(context).join(',')+'}, ret';\r\n        try {\r\n            // the scope of new Function() is \"window\" and not the function where is called, unlike eval();\r\n            let constantsFunction: (context: GObject, ret: GObject) => void = new Function(paramStr, 'return ('+dv.constants+')(ret)').bind(context);\r\n            constantsFunction(context, constantsOutput);\r\n        } catch(e:any){\r\n            console.error('error constants parse', {vid, e, paramStr, body:'return ('+dv.constants+')(ret)'});\r\n            // todo: how do i render an error from here? even if i set jsx or ud.__invalidDeclarations it will be recompiled. need a constants.__invalidDeclarations too?\r\n        }\r\n\r\n        transientProperties.view[vid].constants = constantsOutput;\r\n        transientProperties.view[vid].constantsList = Object.keys(transientProperties.view[vid].constants);\r\n        // implies recompilation of: jsCondition, ud, jsx and all measurable events\r\n        ret.VIEWS_RECOMPILE_jsCondition.push(vid);\r\n        ret.VIEWS_RECOMPILE_usageDeclarations.push(vid);\r\n        ret.VIEWS_RECOMPILE_jsxString.push(vid);\r\n        ret.VIEWS_RECOMPILE_events.push(vid);\r\n        for (let k of DViewElement.MeasurableKeys) (ret as any)['VIEWS_RECOMPILE_'+k].push(vid);\r\n    }\r\n    ret.VIEWS_RECOMPILE_constants = [];\r\n\r\n    if (ret.VIEWS_RECOMPILE_usageDeclarations?.length)\r\n    for (const vid of filterSet(ret.VIEWS_RECOMPILE_usageDeclarations)) { // compiled in func, but NOT executed, result varies between nodes.\r\n        let dv: DViewElement = DPointerTargetable.fromPointer(vid, ret);\r\n        let tv = transientProperties.view[vid];\r\n        if (!tv) transientProperties.view[vid] = tv = {} as any;\r\n        if (!dv.usageDeclarations) {\r\n            tv.UDList = [];\r\n            tv.UDFunction = undefined as any;\r\n            // no need to recompile jsx or measurables, they will have additional parameters in scope but they are undefined and cause no problems.\r\n            continue;\r\n        }\r\n        let matches = dv.usageDeclarations?.match(UDRegexp) || [];\r\n        transientProperties.view[vid].UDList = matches.map(s=>{ s = s.trim(); return s.substring(s.indexOf('\\.')+1, s.length-2).trim()});\r\n        // warning for user: do not redeclare ret in nested blocks.\r\n        // do not use ret[key] syntax.\r\n        // do not set nested values directly (ret.key.subkey syntax).\r\n        // do not use ret.key +=, -= or any other operator assignment different than \"=\"\r\n        // if that is ever required, do instead\r\n        // do not assign values to ret in block comments\r\n        // those restrictions only apply to the ret object, all those violations can be done on other objects.\r\n        // so the following is valid, and a way to overcome the previous limitations:\r\n        // let subobject = {}; subobject[key] += stuff; ret.somefixedname = subobject;\r\n\r\n        let allContextKeys: Dictionary = {...contextFixedKeys};\r\n        for (let k of tv.constantsList) if (!allContextKeys[k]) allContextKeys[k] = true;\r\n        let paramStr = '{'+Object.keys(allContextKeys).join(',')+'}, ret';\r\n\r\n        try {\r\n            tv.UDFunction = new Function(paramStr, 'return ('+dv.usageDeclarations+')(ret)') as (...a:any)=>any;\r\n        } catch (e:any) {\r\n            // problem: errors cannot be serialized in any way? they have no keys. let strerr = JSON.stringify(e); //(e.message || '').split('\\n')[0]);\r\n            let udErrors: GObject =  windoww.udErrors;\r\n            if (!windoww.udErrors) windoww.udErrors = udErrors = {maxi: 0};\r\n            udErrors[\"e\"+(++udErrors.maxi)] = e;\r\n            e.isSyntax = true;\r\n            let errbody = \"ret.__invalidUsageDeclarations = window.udErrors.e\"+udErrors.maxi+\"; return ret;\";\r\n            console.error('error udparse', {vid, e, paramStr, body: 'return ('+dv.usageDeclarations+')(ret)', errbody});\r\n            tv.UDFunction = new Function(\"unusedContext, ret\", errbody) as (...a:any)=>any;\r\n        }\r\n\r\n\r\n        // implies recompilation of: jsx and all measurable events\r\n        ret.VIEWS_RECOMPILE_jsxString.push(vid);\r\n        ret.VIEWS_RECOMPILE_events.push(vid);\r\n        for (let k of DViewElement.MeasurableKeys) (ret as any)['VIEWS_RECOMPILE_'+k].push(vid);\r\n    }\r\n    ret.VIEWS_RECOMPILE_usageDeclarations = [];\r\n\r\n    if (ret.VIEWS_RECOMPILE_events.length) {\r\n        // for (let gid of filterSet(ret.graphs)) Selectors.updateViewMatchings(gid, ret.modelElements, Object.values(ret.idlookup).map( d => RuntimeAccessibleClass.extends(d, DModelElement.cname)));\r\n        // for (let vid of filterSet(ret.VIEW_APPLIABLETO_NEEDS_RECALCULATION)) { }\r\n        for (let entry of filterSet(ret.VIEWS_RECOMPILE_events)) {\r\n            let vid: string;\r\n            let dv: DViewElement;\r\n            let keys: string[];\r\n            if (typeof entry === \"object\") {\r\n                vid = entry.vid;\r\n                dv = DPointerTargetable.fromPointer(vid, ret);\r\n                keys = entry.keys || Object.keys(dv.events);\r\n            }\r\n            else {\r\n                vid = entry;\r\n                dv = DPointerTargetable.fromPointer(vid, ret);\r\n                keys = Object.keys(dv.events);\r\n            }\r\n            let tv = transientProperties.view[vid];\r\n            if (!tv) transientProperties.view[vid] = tv = {} as any;\r\n            if (!tv.events) tv.events = {};\r\n            // if (!tv.events_raw) tv.events_raw = {};\r\n            for (let key of keys) {\r\n                if (!key) { delete tv.events[key]; continue; }\r\n                let allContextKeys = {...contextFixedKeys};\r\n                for (let k of transientProperties.view[vid].constantsList) if (!allContextKeys[k]) allContextKeys[k] = true;\r\n                for (let k of transientProperties.view[vid].UDList) if (!allContextKeys[k]) allContextKeys[k] = true;\r\n                let paramStr = '{'+Object.keys(allContextKeys).join(',')+'}, ..._params';\r\n                // dv.events[key] = (...params)=> code\r\n                const body: string = 'return (' +dv.events[key]+')(..._params)';\r\n                try {\r\n                    tv.events[key] = new Function(paramStr, body) as ((...a:any[])=>any);\r\n                    // tv.events_raw[key] = new Function(paramStr, body) as ((...a:any)=>any);\r\n                    // attempt to auto obtain node context\r\n                    // impossile with view.event.name\r\n                    // could with node.event.name if node.get_event sets a current node thing__, no he must wrap the func!! in the getter\r\n                    // tv.events[key] = (..._params2:any) => { return tv.events_raw[key](context, ..._params2) };\r\n                }\r\n                catch (e: any) {\r\n                    console.error('error jsxparse', {vid, e, paramStr, body});\r\n                    tv.events[key] = (context) => Log.ee(\"failed to parse function body: \" + e.message.split(\"\\n\")[0], e.message);\r\n                }\r\n            }\r\n        }\r\n        ret.VIEWS_RECOMPILE_events = [];\r\n        // triggers recompile of nothing\r\n    }\r\n\r\n    if (ret.VIEWS_RECOMPILE_jsCondition?.length)\r\n    for (const vid of filterSet(ret.VIEWS_RECOMPILE_jsCondition)) {\r\n        const dv: DViewElement = DPointerTargetable.fromPointer(vid, ret);\r\n        let tv = transientProperties.view[vid];\r\n        if (!tv) transientProperties.view[vid] = tv = {} as any;\r\n        tv.jsConditionChanged = true;\r\n        if (!dv.jsCondition) {\r\n            tv.jsCondition = undefined;\r\n            continue;\r\n        }\r\n        const lines = dv.jsCondition.trim().split('\\n');\r\n        let lastLine = lines[lines.length - 1];\r\n        if (lastLine.indexOf('return') !== 0) lines[lines.length - 1] = `return (${lastLine})`;\r\n\r\n\r\n        if (!dv.jsxString) { transientProperties.view[vid].JSXFunction = undefined as any; continue; }\r\n        let allContextKeys = {...contextFixedKeys};\r\n        for (let k of transientProperties.view[vid].constantsList) if (!allContextKeys[k]) allContextKeys[k] = true;\r\n\r\n        let paramStr = '{'+Object.keys(allContextKeys).join(',')+'}';\r\n        const body = lines.join('\\n');\r\n        try {\r\n            tv.jsCondition = new Function(paramStr, body) as ((...a:any)=>any);\r\n        } catch (e) {\r\n            tv.jsCondition = undefined;\r\n            console.log('JS Condition parsed error', e);\r\n        }\r\n    }\r\n    ret.VIEWS_RECOMPILE_jsCondition = [];\r\n\r\n\r\n    if (ret.VIEWS_RECOMPILE_jsxString?.length)\r\n    for (const vid of filterSet(ret.VIEWS_RECOMPILE_jsxString)) { // compiled in func, but NOT executed, result varies between nodes.\r\n        let dv: DViewElement = DPointerTargetable.fromPointer(vid, ret);\r\n        let tv = transientProperties.view[vid];\r\n        if (!tv) transientProperties.view[vid] = tv = {} as any;\r\n        if (!dv.jsxString) { transientProperties.view[vid].JSXFunction = undefined as any; continue; }\r\n        let allContextKeys = {...contextFixedKeys};\r\n        for (let k of transientProperties.view[vid].constantsList) if (!allContextKeys[k]) allContextKeys[k] = true;\r\n        for (let k of transientProperties.view[vid].UDList) if (!allContextKeys[k]) allContextKeys[k] = true;\r\n        let paramStr = '{'+Object.keys(allContextKeys).join(',')+'}';\r\n\r\n        const body: string =  'return (' + UX.parseAndInject(DSL.parser(dv.jsxString), dv) + ')';\r\n        try {\r\n            transientProperties.view[vid].JSXFunction = new Function(paramStr, body) as ((...a: any) => any);\r\n        }\r\n        catch (e: any) {\r\n            /*try{\r\n                let try_to_get_better_error = eval(\"let __f = function(\" + paramStr+\") {\\n\" + body + \"}\");\r\n            } catch(eeval){\r\n                console.error(\"eval error same as func error\", {e, eeval});\r\n                e = eeval;\r\n            }*/\r\n            console.error('error jsxparse', {vid, e, paramStr, body});\r\n            transientProperties.view[vid].JSXFunction = (context) => GraphElementComponent.displayError(e, 'JSX Syntax', dv);\r\n        }\r\n        // implies recompilation of: ... nothing?\r\n    }\r\n    ret.VIEWS_RECOMPILE_jsxString = [];\r\n\r\n\r\n\r\n    for (const key of DViewElement.MeasurableKeys) {\r\n        if ((ret as any)['VIEWS_RECOMPILE_'+key]?.length)\r\n        for (let vid of filterSet((ret as any)['VIEWS_RECOMPILE_'+key]) as any) {\r\n            let dv: DViewElement = DPointerTargetable.fromPointer(vid, ret);\r\n            let tv = transientProperties.view[vid];\r\n            if (!tv) transientProperties.view[vid] = tv = {} as any;\r\n            let str: string = (dv as any)[key];\r\n            if (!str) {\r\n                (transientProperties.view[vid] as any)[key] = undefined;\r\n                continue;\r\n            }\r\n            let allContextKeys = {...contextFixedKeys};\r\n            for (let k of transientProperties.view[vid].constantsList) if (!allContextKeys[k]) allContextKeys[k] = true;\r\n            for (let k of transientProperties.view[vid].UDList) if (!allContextKeys[k]) allContextKeys[k] = true;\r\n            let paramStr = '{'+Object.keys(allContextKeys).join(',')+'}';\r\n            // console.log('measurable parse '+key, {allContextKeys, ud:transientProperties.view[vid].UDList, c:transientProperties.view[vid].constantsList });\r\n            try {\r\n                (transientProperties.view[vid] as any)[key] = new Function(paramStr, str);\r\n            }\r\n            catch (e: any) {\r\n                console.error('error measurable parse '+key, {vid, e, paramStr, body:str});\r\n                (transientProperties.view[vid] as any)[key] = undefined;\r\n                // display error in jsx\r\n                transientProperties.view[vid].JSXFunction = (context) => GraphElementComponent.displayError(e, 'Measurable ' + key + ' Syntax', dv);\r\n                break;\r\n            }\r\n        }\r\n        (ret as any)['VIEWS_RECOMPILE_'+key] = [];\r\n    }\r\n\r\n    for (let dataid in ret.ClassNameChanged) {\r\n        if (dataid === 'clonedCounter') continue;\r\n        // NB: if i ever want to access a constructor's other properties in ocl, like \"context Persona inv: self.$somecounter === Persona.instances.length\",\r\n        // i would need to update this every time a DClass property changes instead of only when name changes.\r\n\r\n        // if it's first creation of a modelpiece\r\n        if (!transientProperties.modelElement[dataid]) {\r\n            // transientProperties.modelElement[dataid] = {nodes: {}};\r\n        }\r\n        // update ocl type names\r\n        let data: DClass = ret.idlookup[dataid] as DClass;\r\n        RuntimeAccessibleClass.makeOCLConstructor(data, ret, oldState);\r\n        // here i should reset all tnv.oclEngine too and set all ocl scores to notevaluated, but it is too computationally heavy\r\n        // and it's useful to keep the old ocl condition valid with past names until manually edited.\r\n    }\r\n    ret.ClassNameChanged = {};\r\n\r\n    return ret;\r\n\r\n}\r\nconst mergeTolerance = 500;\r\nfunction doUndoRedo(oldState: DState, action: Action, isUndo:'undo'|'redo'): DState {\r\n    let state: DState = oldState;\r\n    let times: number = action.value;\r\n    let removedDeltas: (GObject | undefined)[] = [];\r\n    let steps = times;\r\n    Log.exDev(times<=0, isUndo+\" must be positive\", action);\r\n    console.log('redo debug 0', {oldState, action, isUndo, times, steps});\r\n    let isUndoCheck = isUndo === 'undo';\r\n    while (times--) {\r\n        let forUser = (action as UndoAction | RedoAction).forUser;\r\n        const delta = statehistory[forUser][isUndo+'able' as 'undoable'|'redoable'].pop();\r\n        for (let user in statehistory){\r\n            U.arrayRemoveAll(statehistory[user]?.[isUndo+'able' as 'undoable'|'redoable'], delta);\r\n        }\r\n        if (!delta) continue;\r\n        removedDeltas.push(delta);\r\n        console.log('redo debug 1', {delta, times: times});\r\n        state = undo(state, action as UndoAction | RedoAction, delta, isUndoCheck);\r\n    }\r\n\r\n    if (steps > 1) {\r\n        /*let title = state.action_title || '.'\r\n        let cleanedTitle = title.indexOf('done') === 2 ? title.substring(title.indexOf(':')).trim() : title;\r\n        let desc = state.action_description || '.';\r\n        let cleanedDesc = desc.indexOf('done') === 2 ? desc.substring(desc.indexOf(':')).trim() : desc;\r\n        state.action_title = isUndo+'ne '+steps+' steps' +cleanedTitle;\r\n        state.action_description = isUndo+'ne '+steps+' steps'+cleanedDesc;\r\n        */\r\n    }\r\n    // state.VIEWS_RECOMPILE_all = true;\r\n    state.VIEWS_RECOMPILE_all = [...new Set(removedDeltas.flatMap( d => Object.keys(d?.idlookup||{})))];\r\n    return state;\r\n}\r\n\r\nexport function _reducer/*<S extends StateNoFunc, A extends Action>*/(oldState: DState = initialState, action: Action): DState{\r\n\r\n    switch (action.type) {\r\n        case UndoAction.type: return doUndoRedo(oldState, action, 'undo');\r\n        case RedoAction.type: return doUndoRedo(oldState, action, 'redo');\r\n        // case CombineHistoryAction.type: return combineHistory(oldState); break;\r\n        // todo: se al posto di \"annullare l'undo\" memorizzo l'azione e la rieseguo, posso ripetere l'ultimo passo N volte e questa azione diventa utile per combinare passi e ripetere blocchi di azioni assieme\r\n        default:\r\n            if (action.type?.indexOf('@@redux/') === 0) {\r\n                console.error('redux init', {action, oldState, initialState});\r\n                return oldState;\r\n            }\r\n            if (!(action?.className)) { Log.exDevv('unexpected action type:', action.type); return oldState; }\r\n            let ret = doreducer(oldState, action);\r\n            if (ret === oldState) return ret;\r\n            ret.timestamp = Date.now();\r\n            ret.action_title = '';\r\n            ret.action_description = '';\r\n            // undo-redo description\r\n            if (action.className === 'CompositeAction') {\r\n                let desc = (action as CompositeAction).descriptor;\r\n                if (desc) {\r\n                    ret.action_title = desc.path||'';\r\n                    let valchange: string;\r\n                    if (desc.oldval !== undefined && desc.newval!== undefined) valchange = ': ' + desc.oldval + ' -> ' + desc.newval;\r\n                    else if (desc.oldval === undefined && desc.newval!== undefined) valchange = ': ' + desc.newval;\r\n                    else valchange = '';\r\n                    ret.action_description = (desc.desc || '') + valchange;\r\n                }\r\n                else {\r\n                    ret.action_title = '';\r\n                    ret.action_description = '';\r\n                }\r\n            }\r\n            if (!oldState/* || !Object.keys(delta).length*/) return ret;\r\n\r\n            // update state history\r\n            let delta = Uobj.objectDelta(ret, oldState, true, false);\r\n            let debug = Uobj.applyObjectDelta(ret, delta, false, oldState);\r\n            delta.timestamp = ret.timestamp;\r\n            delta.timestampdiff = ret.timestampdiff = ret.timestamp - (oldState?.timestamp || 0);\r\n            if (!statehistory[action.sender]) statehistory[action.sender] = new UserHistory();\r\n            let pastDelta = statehistory[action.sender].undoable[statehistory.all.undoable.length-1];\r\n            const allowMerge = true; // switch for debugging\r\n            let isRelevantChange = isRelevantChangeCheck(delta as GObject<DState>, pastDelta as GObject<DState>);\r\n            // merge if: there is a past delta, and the delta doesn't pass the filter to exist individually\r\n            let shouldMerge = !isRelevantChange;\r\n            let debugMerge = true;\r\n            if (!shouldMerge && (delta.vertexs || delta.graphvertexs || delta.graphelements || delta.edgepoints || delta.edges || delta.graphs)) shouldMerge = true;\r\n            if (!pastDelta) shouldMerge = false;\r\n\r\n            if(pastDelta)console.log(\"merge deltas\", {forVertex:delta.vertexs || delta.graphvertexs || delta.graphelements || delta.edgepoints || delta.edges || delta.graphs,\r\n                isRelevantChange,\r\n                shouldMerge, irl: pastDelta && delta.timestamp - pastDelta.timestamp < mergeTolerance,\r\n                 dt: delta.timestamp, pdt: pastDelta.timestamp, diff: delta.timestamp - pastDelta.timestamp,\r\n                oldState, delta});\r\n            //todo: for cooperative prevent merge from different authors, store user in delta from action.sender when you set timestamp.\r\n            if (shouldMerge && allowMerge) {\r\n                // pastDelta = Uobj.applyObjectDelta(pastDelta, delta); no because special handling\r\n                //   of __jjisEmpty etc must not be done at this stage.\r\n                let gdelta: Dictionary<string, string[] | GObject> = {};\r\n                let allkeys: Set<string> = new Set([...Object.keys(delta), ...Object.keys(pastDelta)]);\r\n                let mergeRecompileArr = (k: string) => {\r\n                    // todo: reenable fix last line but remember they can be either true arrays or delta object fake arrays __jjObjDiffIsArr = true\r\n                    return;\r\n                    if (!(k.indexOf('RECOMPILE') >= 0 || k.indexOf('ELEMENT_') >= 0 || k === 'ClassNameChanged')) return;\r\n                    if (k === 'ClassNameChanged') {\r\n                        let merged: Dictionary<string> = {};\r\n                        for (let p of allkeys) {\r\n                            let vnow = (delta as GObject)[k][p];\r\n                            let vpast = pastDelta[k][p];\r\n                            if (vnow === vpast) { merged[p] = vnow; continue; }\r\n                            if (vnow.indexOf('__jjObjDiff') !== -1) { merged[p] = vpast; continue; }\r\n                            merged[p] = vnow;\r\n                        }\r\n                        gdelta.ClassNameChanged = merged;\r\n                        return;\r\n                    }\r\n                    // todo: this is troublesome because ['id1', 'empty'] + ['id2'] =  ['id1', 'empty', 'id2'] but should not have side effects? can the empty sparse arr make problems?\r\n                    if (!Array.isArray((delta as GObject)[k] || [])) console.error('mergerecompilearr err',\r\n                        {sm:shouldMerge, pd:!!pastDelta, delta, pastDelta, k, dk: (delta as any)?.[k], pdk: pastDelta?.[k]});\r\n                    if (!Array.isArray((delta as GObject)[k]||[])) console.log('err in delta merge', {arr:(delta as GObject)[k]||[], delta, k});\r\n                    if (!Array.isArray((pastDelta as GObject)[k]||[])) console.log('err in past delta merge', {arr:(pastDelta as GObject)[k]||[], pastDelta, k});\r\n                    gdelta[k] = [...new Set(U.arrayMergeInPlace((delta as GObject)[k]||[], pastDelta[k]||[]))] as string[];\r\n                }\r\n\r\n                for (let k of allkeys) mergeRecompileArr(k);\r\n                U.objectMergeInPlace(pastDelta, delta);\r\n                delta = pastDelta; // must be inaccessible now as it merged with pastdelta, use that instead\r\n                for (let k in gdelta) {\r\n                    if (Array.isArray(gdelta[k])) pastDelta[k] = gdelta[k].filter((e:string) => e && e.indexOf('__jjObjDiff') === -1);\r\n                    else pastDelta[k] = gdelta[k];\r\n                }\r\n                if (debugMerge) (ret as any).mergeCounter = (pastDelta as any).mergeCounter = 1+((ret as any).mergeCounter||0)\r\n            }\r\n            else if (isRelevantChange) {\r\n                let user = (action as Action).sender;\r\n                statehistory[user].undoable.push(delta);\r\n                statehistory.all.undoable.push(delta);\r\n                if (debugMerge) {\r\n                    if (shouldMerge) (ret as any).notMergeCounter = (delta as any).notMergeCounter = 1+((ret as any).notMergeCounter || 0)\r\n                    else (ret as any).notMergeCounter = 0;\r\n                }\r\n            }\r\n\r\n            return ret;\r\n    }\r\n}\r\n\r\nfunction isRelevantChangeCheck(delta: GObject<DState>, pastDelta?: GObject<DState>): boolean {\r\n    if (!U.userHasInteracted) return false;\r\n    if (pastDelta && delta.timestamp - pastDelta.timestamp < mergeTolerance) return false;\r\n    if (!statehistory.globalcanundostate) return false;\r\n    if (Object.keys(delta).length === 1) {\r\n        if (\"dragging\" in delta) return false;\r\n        if (\"_lastSelected\" in delta) return false;\r\n        if (\"contextMenu\" in delta) return false;\r\n    }\r\n    return true;\r\n}\r\nfunction undo(state: DState, action: UndoAction | RedoAction, delta: GObject | undefined, isundo = true): DState {\r\n    if (!delta) return state;\r\n    //let undonestate: DState = {...state} as DState;\r\n    //   controlla se vengono shallow-copied solo e tutti gli oggetti nested lungo la catena del percorso delle modifiche\r\n    //   es: root.a.b.c=3 + root.a.b.d=3 = 4+1 modifiche, 5 shallow copies including the root\r\n    //undorecursive(delta, undonestate);\r\n\r\n    let undonestate = Uobj.applyObjectDelta(state, delta, false);\r\n    // todo: check if delta2 === delta or is his opposite in values but same shape\r\n    let delta2 = Uobj.objectDelta(undonestate, state);\r\n    let debug = Uobj.applyObjectDelta(undonestate, delta2, false, state);\r\n    let forUser = action.forUser;\r\n    let user = action.sender;\r\n    // reverses from undo to redo and viceversa swapping arguments, so the target result after appliying the delta changes\r\n    // redo is \"undoing an undo\", reversing his changes just like an undo reverses an ordinary action changes.\r\n    let key: 'redoable'|'undoable' = isundo ? 'redoable' : 'undoable';\r\n    statehistory[user][key].push(delta2);\r\n    statehistory.all[key].push(delta2);\r\n    return undonestate as GObject<DState>;\r\n}\r\n/*\r\nfunction undorecursive(deltalevel: GObject, statelevel: GObject): void {\r\n    // statelevel = {...statelevel}; not working if i do it here, just a new var. first time copy id done in caller func undo(). recursive copies are done before recursive step\r\n    for (let key in deltalevel) {\r\n        let delta = deltalevel[key];\r\n        console.log(\"undoing\", {delta, key, deltalevel, statelevel})\r\n        //if (key.indexOf(\"_-\") === 0) { delete statelevel[key.substring(2)]; continue; }\r\n        if (typeof delta === \"object\") {\r\n        // if (U.isObject(delta, false, false, true)) {\r\n            if (Array.isArray(delta)) statelevel[key] = [...statelevel[key]];\r\n            else statelevel[key] = {...statelevel[key]};\r\n            undorecursive(deltalevel[key], statelevel[key]); }\r\n        else { statelevel[key] = delta; }\r\n    }\r\n}*/\r\n\r\nfunction doreducer/*<S extends StateNoFunc, A extends Action>*/(oldState: DState = initialState, action: Action): DState{\r\n    let ca: CompositeAction;\r\n    switch (action.type) {\r\n        case CompositeAction.type: ca = action as CompositeAction; break;\r\n        case LoadAction.type:\r\n        default:/*\r\n            if (action.type.indexOf('@@redux/') === 0) { handled on upper levels\r\n                //storeLoaded = true;\r\n                return oldState;\r\n            }*/\r\n            ca = new CompositeAction([action], false);\r\n            break;\r\n    }\r\n    let ret = CompositeActionReducer(oldState, ca);\r\n    /*if (state.current !== ret) {\r\n        state.current = ret;\r\n        state.past.push(ret);\r\n    }*/\r\n    return ret;\r\n}\r\nfunction setSubclasses(roots: orArr<typeof RuntimeAccessibleClass>){\r\n    RuntimeAccessibleClass.extendMatrix =\r\n        new SimpleTree<(typeof RuntimeAccessibleClass)>(roots, \"subclasses\")\r\n            .getiIsSubElementMatrix(\"cname\");\r\n    /*\r\n    let tree = new TreeModel({\r\n        childrenPropertyName: \"subclasses\"\r\n    });\r\n    for (let key in dict){\r\n        let constructor = dict[key];\r\n        if(!constructor.hasOwnProperty(\"subclasses\")) constructor.subclasses = [];\r\n    }\r\n    RuntimeAccessibleClass.extendTree = (tree as any).safe_parse(RuntimeAccessibleClass);*/\r\n}\r\n// windoww.TreeModel = TreeModel;\r\nfunction buildLSingletons(alld: Dictionary<string, typeof DPointerTargetable>, alll: Dictionary<string, typeof LPointerTargetable>) {\r\n    for (let dname in alld) {\r\n        switch (dname) {\r\n            case \"DeleteElementAction\": continue;\r\n            case \"DV\": continue;\r\n            case \"Debug\": continue;\r\n            default: break;\r\n        }\r\n        if ((dname[1] || \"\").toLowerCase() === dname[1]) continue; // if second letter is lowercase, it's not a \"D\" class\r\n        let tagless = dname.substring(1);\r\n        let d = alld[dname];\r\n        let l = alll['L'+tagless];\r\n        if (!d||!l) console.error(\"missing d constructor\", {d, l});\r\n        d.logic = l;\r\n        if (!l) console.error('init() could not find L-class during mapping', l, d);\r\n        // @ts-ignore\r\n        d.singleton = new l('dwc');\r\n        d.structure = d;\r\n\r\n        l.logic = d.logic;\r\n        l.singleton = d.singleton;\r\n        l.structure = d.structure;\r\n\r\n        // if (!d.subclasses) d.subclasses = [];\r\n        // @ts-ignore\r\n        // for (let sc of d.subclasses) { if (!sc[\"_extends\"]) sc[\"_extends\"] = [];  sc[\"_extends\"].push(d); }\r\n    }\r\n}\r\nfunction setDocumentEvents(){\r\n    // do not use typings or class constructors here or it will change import order\r\n    setTimeout(\r\n        ()=> $(document).on(\"mouseup\",\r\n            (e: MouseUpEvent) => {\r\n                statehistory.globalcanundostate = true;\r\n                RuntimeAccessibleClass.get<typeof GraphDragManager>(\"GraphDragManager\").stopPanning(e);\r\n            })\r\n        , 1);\r\n    // document.body.addEventListener(\"mousedown\", fixResizables, false);\r\n    setInterval(()=>{ END(); BEGIN(); }, 300);\r\n}\r\nfunction fixResizables(e: MouseEvent){\r\n    /*let parents = U.ancestorArray(e.target as HTMLElement);\r\n    for (let e of parents){\r\n        if (e.classList.contains(\"draggable\")) U.makeDraggable(e, e.dataset.draggableOptions, e.attributes.disabled);\r\n        if (e.classList.contains(\"resizable\")) U.makeResizable(e, e.dataset.draggableOptions);\r\n        if (e.classList.contains(\"resizable\")) U.makeRotatable(e, e.dataset.draggableOptions);\r\n    }*/\r\n}\r\n\r\nexport async function stateInitializer() {\r\n    console.trace('stateinitializer');\r\n    RuntimeAccessibleClass.fixStatics();\r\n    let dClassesMap: Dictionary<string, typeof DPointerTargetable> = {};\r\n    let lClassesMap: Dictionary<string, typeof LPointerTargetable> = {};\r\n    for (let name in RuntimeAccessibleClass.classes) {\r\n        switch(name[0]) {\r\n            case 'D': dClassesMap[name] = RuntimeAccessibleClass.classes[name] as typeof DPointerTargetable; break;\r\n            case 'L': lClassesMap[name] = RuntimeAccessibleClass.classes[name] as typeof LPointerTargetable; break;\r\n            default: break;\r\n        }\r\n    }\r\n\r\n    buildLSingletons(dClassesMap, lClassesMap);\r\n    setSubclasses(RuntimeAccessibleClass.get('DPointerTargetable'));\r\n    windoww.defaultContext = {$: windoww.$, getPath, React: React, Selectors, ...RuntimeAccessibleClass.getAllClassesDictionary(), ...windoww.Components};\r\n\r\n    DState.init();\r\n    // let duser = DUser.offline(); // if it's online mode this is a no-op and user should be already loaded\r\n    let duser = DUser.load();\r\n    if (!duser?.id) {\r\n        DUser.current = '';\r\n        console.warn('user not logged, redirecting to #/auth');\r\n        return;\r\n    }\r\n    DUser.current = duser.id;\r\n    try {\r\n        let c = await ProjectsApi.getAll();\r\n\r\n    } catch (error) {\r\n        // U.alert('e','Failed to fetch projects','');\r\n        AuthApi.logout();\r\n        console.error('Failed to fetch projects', {error});\r\n        DUser.current = '';\r\n        // R.navigate('/auth');\r\n    }\r\n    setDocumentEvents();\r\n    /*type RecentEntry = {id: Pointer<DProject>[], name: string};\r\n    let recent: RecentEntry[] = JSON.parse(localStorage.getItem('_jjRecent') || '[]') as any[];\r\n    if (window.location.hash.indexOf('#/project') === 0) { use R.navigate\r\n        let user: LUser = LPointerTargetable.from(DUser.current);\r\n        let project = user?.projects.filter(p=>!!p)[0]?.__raw as any;\r\n        //console.log('test recents', {project, user, recent});\r\n        let current: RecentEntry = {name: project.name, id:project.id};\r\n        // the filter looks if the current project was already in recent list, and prevents duplicates\r\n        recent = recent.filter(p=> p.id !== current.id);\r\n        recent.push(current);\r\n        localStorage.setItem('_jjRecent', JSON.stringify(recent));\r\n    }*/\r\n\r\n}\r\n","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\model\\classes\\D.ts",[],"C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\model\\classes\\L.ts",[],"C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\view\\viewPoint\\viewpoint.ts",["1043","1044","1045"],"import {\r\n    Constructors,\r\n    DPointerTargetable,\r\n    DViewElement,\r\n    GraphSize, LogicContext,\r\n    LPointerTargetable,\r\n    LViewElement,\r\n    Pointer,\r\n    RuntimeAccessible,\r\n    RuntimeAccessibleClass\r\n} from \"../../joiner\";\r\n\r\n\r\n@RuntimeAccessible('DViewPoint')\r\nexport class DViewPoint extends DViewElement {\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n\r\n    id!: Pointer<DViewPoint, 1, 1, LViewPoint>;\r\n    name!: string;\r\n\r\n/*\r\n    public static new(name: string, jsxString: string, defaultVSize?: GraphSize, usageDeclarations: string = '', constants: string = '',\r\n                      preRenderFunc: string = '', appliableToClasses: string[] = [], oclApplyCondition: string = '', priority: number = 1 , persist: boolean = true): DViewPoint {\r\n        return new Constructors(new DViewPoint('dwc'), undefined, persist, undefined).DPointerTargetable()\r\n            .DViewElement(name, jsxString, undefined, defaultVSize, usageDeclarations, constants,\r\n                preRenderFunc, appliableToClasses, oclApplyCondition, priority).DViewPoint().end();\r\n    }*/\r\n    public static newVP(name: string, callback?: (d:DViewElement)=>void, persist: boolean = true, id?: string): DViewPoint {\r\n        let c = new Constructors(\r\n            new DViewPoint('dwc'), undefined, persist, undefined, id)\r\n            .DPointerTargetable();\r\n        // @ts-ignore\r\n        c.thiss.viewpoint = c.thiss.id;\r\n    return c.DViewElement(name, '').DViewPoint().end(callback)\r\n    }\r\n}\r\n\r\n@RuntimeAccessible('LViewPoint')\r\nexport class LViewPoint<Context extends LogicContext<DViewPoint, LViewPoint> = any, D extends DViewPoint = any> extends LViewElement {\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    //public __raw!: DViewPoint;\r\n    id!: Pointer<DViewPoint, 1, 1, LViewPoint>;\r\n    name!: string;\r\n    /*protected* / get_duplicate(c: Context): ((deep?: boolean, new_vp?: DuplicateVPChange) => LViewElement){\r\n        return (deep?: boolean, new_vp?: DuplicateVPChange)=>super.get_duplicate(c)(deep, new_vp);\r\n    }*/\r\n}\r\n\r\nRuntimeAccessibleClass.set_extend(DPointerTargetable, DViewPoint);\r\nRuntimeAccessibleClass.set_extend(LPointerTargetable, LViewPoint);\r\n","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\graph\\graphElement\\GraphDragHandler.ts",[],"C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\joiner\\components.tsx",["1046","1047","1048","1049","1050","1051","1052","1053","1054","1055","1056","1057","1058","1059"],"import type { Dictionary } from \"./types\";\r\n\r\n// export {Graph, GraphComponent} from \"../graph/graph/graph\"; // require graphelement\r\n// export {Graph} from \"../graph/vertex/Vertex\"; // require graphelement\r\n// imports graphelements\r\nimport {GraphElement, GraphElementComponent} from \"../graph/graphElement/graphElement\";\r\nimport {Graph, Vertex, VoidVertex, GraphVertex, Field, EdgePoint, VertexComponent} from \"../graph/vertex/Vertex\"; // require overlap, graphelement\r\nimport { Polygon, Circle, Cross, Decagon,\r\n    Asterisk, Ellipse, Enneagon, Hexagon, Nonagon,\r\n    Octagon, Heptagon, Pentagon, Rectangle, Septagon,\r\n    Square, Star, SimpleStar, DecoratedStar, Trapezoid, Triangle\r\n} from  \"../graph/vertex/Shapes\";\r\nimport {DefaultNode, DefaultNodeComponent} from \"../graph/defaultNode/DefaultNode\"; // require graphelement\r\nimport {GraphsContainer, GraphsContainerComponent} from \"../graph/graph/graphContainer\"; // require vertex, graph\r\nimport {Edge, EdgeComponent} from \"../graph/damedges/damedge\";\r\nimport {GenericInput} from \"../components/forEndUser/GenericInput\"\r\nimport {U} from \"./index\";\r\nimport { Control } from \"../components/forEndUser/Control\";\r\n// exports graphelements\r\nexport {GraphElement, GraphElementComponent} from \"../graph/graphElement/graphElement\";\r\nexport {Graph, Vertex, VoidVertex, GraphVertex, Field, EdgePoint, VertexComponent} from \"../graph/vertex/Vertex\"; // require overlap, graphelement\r\nexport { Polygon, Circle, Cross, Decagon,\r\n    Asterisk, Ellipse, Enneagon, Hexagon, Nonagon,\r\n    Octagon, Heptagon, Pentagon, Rectangle, Septagon,\r\n    Square, Star, SimpleStar, DecoratedStar, Trapezoid, Triangle\r\n} from  \"../graph/vertex/Shapes\";\r\nexport {DefaultNode, DefaultNodeComponent} from \"../graph/defaultNode/DefaultNode\"; // require graphelement\r\nexport {GraphsContainer, GraphsContainerComponent} from \"../graph/graph/graphContainer\"; // require vertex, graph\r\nexport {Edge, EdgeComponent,} from \"../graph/damedges/damedge\";\r\nexport {GenericInput} from \"../components/forEndUser/GenericInput\"\r\n// other exports\r\n//export {DockLayoutComponent} from \"../components/abstract/DockLayoutComponent\";\r\n\r\nexport {Input, Edit, TextArea, Select} from \"../components/forEndUser/Input\";\r\n// export {TextArea} from \"../components/forEndUser/TextArea\";\r\nexport {Selector} from \"../components/forEndUser/Selector\";\r\nexport {View} from \"../components/forEndUser/Aliases\";\r\nexport {Try} from \"../components/forEndUser/Try\";\r\n\r\n// export {Image} from \"../components/forEndUser/Image\";\r\n\r\n\r\nexport {DataOutputComponent} from \"../components/logger/DataOutput\";\r\nexport {LoggerComponent} from \"../components/logger/loggerComponent\";\r\n\r\n/// import components that must save themselves to global variable to be accessible for user\r\n\r\nexport {Overlap} from \"../components/forEndUser/Overlap\";\r\n\r\nexport {ControlPanel} from '../components/forEndUser/ControlPanel';\r\n\r\nexport {Control, Slider, Toggle} from '../components/forEndUser/Control';\r\n\r\ntype dict = Dictionary<string, typeof GraphElement | typeof Edge>;\r\n\r\n\r\nexport const Graphs = {\r\n    Graph: Graph, GraphVertex: GraphVertex,\r\n}\r\nexport const Edges = {\r\n    Edge: Edge,\r\n    EdgePoint: EdgePoint,\r\n}\r\nexport const Fields = {\r\n    Field: Field,\r\n    // GraphElement: GraphElement,\r\n}\r\nexport const Vertexes = {\r\n    Vertex: Vertex,\r\n    // VoidVertex: VoidVertex,\r\n    Circle: Circle,\r\n    Polygon: Polygon,\r\n    Cross: Cross,\r\n    Asterisk: Asterisk,\r\n    //Star: Star,\r\n    SimpleStar: SimpleStar, DecoratedStar: DecoratedStar,\r\n    Triangle: Triangle, Square: Square, Pentagon: Pentagon,\r\n    Hexagon: Hexagon, Heptagon: Heptagon, Octagon: Octagon,\r\n    Enneagon: Enneagon, Decagon: Decagon,\r\n    // Nonagon: Nonagon, Septagon: Septagon,\r\n    // Diamond: Diamond, Rhombus: Rhombus,\r\n    Ellipse: Ellipse,\r\n    Rectangle: Rectangle,\r\n    Trapezoid: Trapezoid\r\n}\r\nexport const GraphElements: dict = {...Graphs, ...Vertexes, ...Fields, ...Edges}; // T & {vertexes: T, edges: T, graphs: T, fields: T} = {} as any;\r\nfor (let key in GraphElements) if (!(GraphElements as any)[key]) { console.log({GraphElements, v:(GraphElements as any)[key]}); throw new Error(\"wrong initialization fo components\"); }\r\n// U.objectMergeInPlace(GraphElements, Graphs, Edges as any, Vertexes, Fields, {Graphs, Edges, Vertexes, Fields});\r\n// console.info('components loaded');\r\nexport {Measurable, MeasurableComponent, ScrollableComponent, Scrollable, Draggable, Resizable, Rotatable} from \"../components/forEndUser/Measurable\";\r\n\r\n// icons\r\nexport * as Tb from 'react-icons/tb';\r\nexport * as Fa from 'react-icons/fa';\r\n","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\common\\U.tsx",["1060","1061","1062","1063","1064","1065","1066","1067","1068","1069","1070","1071","1072","1073","1074","1075","1076","1077","1078","1079","1080","1081","1082","1083","1084","1085","1086","1087","1088","1089","1090","1091","1092","1093","1094","1095","1096","1097","1098","1099","1100","1101","1102","1103","1104","1105","1106","1107","1108","1109","1110","1111","1112","1113","1114","1115"],"// import * as detectzoooom from 'detect-zoom'; alternative: https://www.npmjs.com/package/zoom-level\r\n// import {Mixin} from \"ts-mixer\";\r\nimport {Any, DGraphElement, LGraphElement} from \"../joiner\";\r\nimport {\r\n    AbstractConstructor,\r\n    Constructor,\r\n    Dictionary,\r\n    DocString,\r\n    GObject,\r\n    Pointer,\r\n    PrimitiveType,\r\n    Temporary,\r\n    LPointerTargetable,\r\n    DPointerTargetable,\r\n    Log,\r\n    EMeasurableEvents,\r\n    TRANSACTION,\r\n    SetRootFieldAction,\r\n    LoadAction,\r\n    KeyDownEvent, KeyUpEvent,\r\n    stateInitializer,\r\n    DUser,\r\n    DProject, D, L, ClickEvent,\r\n} from \"../joiner\";\r\nimport {\r\n    DClassifier,\r\n    DModelElement, DState,\r\n    Json,\r\n    JsType,\r\n    LClassifier,\r\n    LModelElement,\r\n    LNamedElement,\r\n    LogicContext,\r\n    MyError,\r\n    RuntimeAccessible,\r\n    RuntimeAccessibleClass, store,\r\n    windoww\r\n} from \"../joiner\";\r\nimport Swal from \"sweetalert2\";\r\nimport Storage from '../data/storage';\r\nimport {compressToUTF16, decompressFromUTF16} from \"async-lz-string\";\r\nimport {NumberControl, PaletteControl, PaletteType, PathControl, StringControl} from \"../view/viewElement/view\";\r\nimport tinycolor from \"tinycolor2\";\r\nimport util from \"util\";\r\nimport Convert from \"ansi-to-html\";\r\nimport React, {isValidElement} from \"react\";\r\nimport IoT from \"../iot/IoT\";\r\nimport Collaborative from \"../components/collaborative/Collaborative\";\r\nimport {Await, NavigateFunction} from \"react-router-dom\";\r\n// var Convert = require('ansi-to-html');\r\n// import KeyDownEvent = JQuery.KeyDownEvent; // https://github.com/tombigel/detect-zoom broken 2013? but works\r\n\r\nconsole.warn('loading ts U log');\r\n\r\n@RuntimeAccessible('Color')\r\nexport class Color {\r\n    r: number;\r\n    g: number;\r\n    b: number;\r\n\r\n    constructor(r: number, g: number, b: number) {\r\n        this.r = r;\r\n        this.g = g;\r\n        this.b = b;\r\n    }\r\n\r\n    static fromHex(hex:string): Color {\r\n        return undefined as any;\r\n    }\r\n    static fromHLS({h, l, s}:{h: number, l:number, s: number}): Color {\r\n        return undefined as any;\r\n    }\r\n    getHex(): string {\r\n        return undefined as any;\r\n    }\r\n    mixWith(c: Color): void {\r\n\r\n    }\r\n    getHLS(): {h: number, l:number, s: number} {\r\n        return undefined as any;\r\n    }\r\n    duplicate(): Color {\r\n        return undefined as any;\r\n    }\r\n}\r\n\r\n@RuntimeAccessible('R')\r\nexport class R{\r\n    public static cname: string = 'R';\r\n\r\n    // from: 1.com/2/3\r\n    // /5       --> 1.com/5/\r\n    // ./5      --> 1.com/1/2/3/5\r\n    // 5        --> 1.com/1/2/3/5\r\n    //\r\n    public static open_new_page(url: string): void {\r\n        window.open(url, '_blank');\r\n    }\r\n    public static replace(path: string): void {\r\n        window.location.replace(path);\r\n    }\r\n\r\n    public static navigate(path: string, refresh: (true|NavigateFunction) = true): void {\r\n        // window.location.assign = window.location = window.location.href = window.open(url, '_self')\r\n        console.warn('R.navigate()', {path, refresh});\r\n        //if (path.indexOf('allProject') >= 0) return;\r\n        let debug: false = true as any;\r\n        if (debug || refresh === true ) {\r\n            if (path[0] !== '/') path = '/'+path;\r\n            path = '/#' + path;\r\n            console.log('navigating: ', {path, url:window.location.origin + path, currHash:window.location.hash});\r\n            if ('/'+window.location.hash === path) return;\r\n            U.navigating = true;\r\n            window.location.href = window.location.origin + path;\r\n\r\n           // window.location.reload(); // i think this is causing a firefox bug, it refreshes old url\r\n        }\r\n        else refresh(path); // useNavigator()(path);\r\n    }\r\n}\r\n\r\n@RuntimeAccessible('U')\r\nexport class U {\r\n    private static clickedOutsideMap: WeakMap<Element, (e: Element, evt: JQuery.ClickEvent)=>void> = null as any;\r\n    private static clickedOutsideMapEntries: Element[] = null as any; // because weak maps are not iterable and cannot get a list of keys\r\n\r\n\r\n    // to register call with both parameters. to remove a listener call with callback=undefined\r\n    public static navigating: boolean = false; // if i'm changing page, i stop rendering to prevent meaningless errors.\r\n    static clickedOutside(currentTarget0: Element|Any<Event>, callback: undefined | ((e: Element, evt: JQuery.ClickEvent) => void)) {\r\n        if (!currentTarget0) return;\r\n        let currentTarget: Element = (currentTarget0 as any)?.currentTarget || currentTarget0 as any;\r\n        if (!currentTarget) return;\r\n        let map = U.clickedOutsideMap;\r\n        let arr = U.clickedOutsideMapEntries;\r\n        if (!map) {\r\n           U.clickedOutsideMap = map = new WeakMap();\r\n           U.clickedOutsideMapEntries = arr = [];\r\n           document.addEventListener('click', U.clickedOutsideCallback, true); // bubbling event! called before normal events.\r\n           // $(document).on('click', U.clickedOutsideCallback);\r\n        }\r\n        console.log('clickedOutside registering', {currentTarget, callback, map, arr});\r\n        if (callback) {\r\n            map.set(currentTarget, callback);\r\n            if (!arr.includes(currentTarget)) arr.push(currentTarget);\r\n        }\r\n        else {\r\n            map.delete(currentTarget);\r\n            U.arrayRemoveAll(arr, currentTarget);\r\n        }\r\n    }\r\n\r\n    //private static lastClicked?: Element;\r\n    private static lastClickedAncestors: Element[] = [];\r\n    private static lastClickedTime: number = 0;\r\n    public static userHasInteracted: boolean = false;\r\n    public static isProjectModified: boolean = false;\r\n    private static clickedOutsideCallback(e: any & ClickEvent){\r\n        let target = e.target as Element;\r\n        let clickedAncestors = U.ancestorArray(target, undefined, true);\r\n\r\n        // when i click on something containined in a label+input, the event fires twice:\r\n        // once for actually clicked element and 1 emulating a click on input/select\r\n        if ((Date.now() - U.lastClickedTime < 300)){\r\n            let labelAncestors = clickedAncestors.filter((e, i) => i>0 && e.tagName === 'LABEL');\r\n            if (U.lastClickedAncestors.filter(e=>labelAncestors.includes(e))) return;\r\n            //if (labelAncestors.includes(U.lastClicked)) return;\r\n        }\r\n        //U.lastClicked = target;\r\n        U.lastClickedAncestors = clickedAncestors;\r\n        U.lastClickedTime = Date.now();\r\n        let map = U.clickedOutsideMap;\r\n        let arr = U.clickedOutsideMapEntries;\r\n\r\n        // console.log('clickedOutside callback exec', {e, target, clickedAncestors, arr, map, callbacks: arr.map(e=>map.get(e))});\r\n        for (let elem of arr) {\r\n            let callback = map.get(elem);\r\n            if (!callback) continue;\r\n            // if (target === elem) continue;\r\n            if (clickedAncestors.includes(elem)) continue;\r\n            callback(target, e);\r\n        }\r\n    }\r\n\r\n    static publish(topic: string, value: unknown) {\r\n        if(!IoT.client.connected) {\r\n            SetRootFieldAction.new('alert', '3:Cannot connect to broker!:','');\r\n            return;\r\n        }\r\n        IoT.client.emit('push-action', {\r\n            topic: topic,\r\n            value: JSON.stringify(value)\r\n        });\r\n        SetRootFieldAction.new('alert', '1:Publish done!:','');\r\n    }\r\n\r\n    static extractValueFromTopic(obj: Dictionary, path: string) {\r\n        const keys = path.split('.');\r\n        let result = obj;\r\n        for (let key of keys) {\r\n            result = result[key];\r\n            if (result === undefined) return undefined;\r\n        }\r\n        return result;\r\n    }\r\n\r\n    static extractTopics(obj: Dictionary, parentKey = ''): string[] {\r\n        let keys: string[] = [];\r\n        for (let key in obj) {\r\n            if (typeof obj[key] === 'object' && !Array.isArray(obj[key]))\r\n                keys = keys.concat(this.extractTopics(obj[key], `${parentKey}${key}.`));\r\n            else keys.push(parentKey + key);\r\n        }\r\n        return keys.filter(k => k !== 'clonedCounter');\r\n    }\r\n\r\n    static keepKeys(dict: GObject, keys: string[]): Dictionary {\r\n        return Object.fromEntries(\r\n            Object.entries(dict).filter(([key]) => keys.includes(key))\r\n        );\r\n    }\r\n\r\n    static alert(type: 'i'|'w'|'e', title: string, message: string = ''): void {\r\n        SetRootFieldAction.new('alert', `${type}:${title}:${message}`, '');\r\n    }\r\n\r\n    static dialog(message: string, label: string, action: () => any): void {\r\n        windoww.dialog_action = action;\r\n        SetRootFieldAction.new('dialog', `${message}:${label}`, '');\r\n    }\r\n\r\n    static async decompressState(state: string): Promise<string> {\r\n        return await decompressFromUTF16(state);\r\n    }\r\n    static async compressedState(id: Pointer<DProject>): Promise<string> {\r\n        const state = store.getState();\r\n        const idlookup: Record<Pointer<DPointerTargetable>, DPointerTargetable> = {};\r\n        for(const [pointer, object] of Object.entries(state.idlookup)) {\r\n            if(object.className === DProject.name && pointer !== id) continue;\r\n            idlookup[pointer] = object;\r\n        }\r\n        (state.idlookup[id] as DProject).state = '';\r\n        state.projects = [id];\r\n        state.idlookup = idlookup;\r\n        return await compressToUTF16(JSON.stringify(state));\r\n    }\r\n    static isOffline(): boolean {\r\n        return Storage.read('offline') === true;\r\n    }\r\n    static resetState(): void {\r\n        LoadAction.new({...DState.new(), 'isLoading':true});\r\n        stateInitializer().then(() => SetRootFieldAction.new('isLoading', false));\r\n    }\r\n\r\n    public static inspect(object: any, showHidden?: boolean, depth?: number | null, color?: boolean): string {\r\n        let o0 = object;\r\n        object = object?.__raw || object;\r\n        if (Array.isArray(object)) object = object.map(o => o?.__raw || o);\r\n        // todo: use lodash \"clonedeepwith\" to clean proxies\r\n        console.error(\"inspect\", {o0, object});\r\n        return util.inspect(object, showHidden, depth, color);\r\n    }\r\n\r\n    public static objectInspect(val: GObject, depth: number = 2, color: boolean = true, showHidden = true): string{\r\n        if (typeof val === 'string') return val;\r\n        let ansiConvert = (window as any).ansiConvert;\r\n        if (!ansiConvert) (window as any).ansiconvert = ansiConvert = new Convert();\r\n        return U.replaceAll(ansiConvert.toHtml(U.inspect(val, showHidden, depth, color)),\r\n            \"style=\\\"color:#FFF\\\"\", \"style=\\\"color:#000\\\"\");\r\n    }\r\n\r\n    // exponential: undefined = only if it's over digits. false = never, true = always.\r\n    public static cropNum(num: number|undefined|null, digits: number=5, exponential?: boolean, atLeast1Decimal:boolean=true): number | string{\r\n        if (!digits || num === null || num === undefined || isNaN(num)) return num as any;\r\n        let sign = (num < 0 ? '-' : '');\r\n        if (sign.length) digits--;\r\n        if (exponential) return num.toExponential(digits-1);\r\n        else if (exponential === undefined) {\r\n            if (digits <= 4) digits = 4; // 4 extra chars for .e+x\r\n            // NB: i'm not checking if exponent is over 1 char (tens of billions)\r\n            let limit = 10**(digits);\r\n            if (num >= limit || -num >= limit) return num.toExponential(Math.max(0, digits-5));\r\n        }\r\n        let intpart: number = Math.trunc(num);\r\n        if (intpart === num) { return num; }\r\n        /*let s = ''+num;\r\n        let excess = (s.length - digits);\r\n        if (excess <= 0) return num;*/\r\n        // must cut decimals\r\n        let intpart_s = intpart + '';\r\n        let allowedDecimals = digits - intpart_s.length - 1;\r\n\r\n        // console.log('cropnum', {digits,num, intpart, is:intpart_s.length, allowedDecimals});\r\n        if (allowedDecimals <= 0) {\r\n            if (!atLeast1Decimal) return intpart;\r\n            else allowedDecimals = 1;\r\n        }\r\n        let decimalPart = num%1;\r\n        //console.log('cropnum', {allowedDecimals, decimalPart});\r\n\r\n        // nb: here in concatenation ((-0)+'') --> '0'. it will lose sign on cropNum(x) with x € (-1, 0)\r\n        // so need to check if it was negative\r\n        // let exp = (10**allowedDecimals);\r\n        // return sign + (intpart_s)+'.'+ (Math.round(decimalPart * exp)/exp).substring(2, allowedDecimals+2);\r\n        let decimal_s = decimalPart+'';\r\n        let firsti = sign.length + 2; // 0. in decimal string\r\n        let lasti = allowedDecimals + firsti;\r\n        while (--lasti > firsti && decimal_s[lasti] === '0') {   }\r\n        if (++lasti <= firsti) return intpart;\r\n        let ret = +((num < 0 && intpart === -0 ? '-' : '') + (intpart_s)+'.'+ (decimal_s.substring(firsti, lasti)));\r\n        // console.log('cropNum', {num, ret, oth:{sign, firsti, lasti, decimal_s, intpart_s}});\r\n        return ret;\r\n    }\r\n    public static cropStr(msg: string, linesStart: number = 5, linesEnd: number = 5, stringRowStart: number = 25, stringRowEnd: number = 25): string{\r\n        let arr = msg.split('\\n');\r\n        if (linesEnd + linesStart + 1 < arr.length) {\r\n            //arr = arr.slice(0, 10) + arr.slice(10, 0);\r\n            arr.splice(linesStart, arr.length - linesStart - linesEnd, '...')\r\n        }\r\n        let ret: string = '';\r\n        let i = 0;\r\n        for (let line of arr){\r\n            if (stringRowEnd + stringRowStart + 1 < line.length) {\r\n                ret += line.substring(0, stringRowStart) + '...' + line.substring(line.length - stringRowEnd) + (i === arr.length-1 ?'':'\\n');\r\n            }\r\n            else ret += line + (i === arr.length-1 ?'':'\\n');\r\n            i++;\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    // eseguire una funzione costa in performance, anche se è brutto fare questi cast\r\n    static wrapper<T>(obj: any): T {\r\n        return obj as unknown as T;\r\n    }\r\n    // mi sa che c'era un metodo l.__serialize or something\r\n    static json(dElement: GObject): Json {\r\n        return JSON.parse(JSON.stringify(dElement.__raw));\r\n    }\r\n\r\n    static hexToPalette(...hexs: string[]): PaletteControl{\r\n        return {type: \"color\", value: hexs.map( hex => {\r\n                if (hex[0] === '#') hex = hex.substring(1);\r\n                let r: number, g: number, b: number, a: number = 1;\r\n                if (hex.length === 4) {\r\n                    a = Number.parseInt('0x' + hex[3] + hex[3])/255;\r\n                    hex = hex.substring(0, 3);\r\n                }\r\n                if (hex.length === 7) {\r\n                    a = Number.parseInt('0x' + hex[5] + hex[6])/255;\r\n                    hex = hex.substring(0, 6);\r\n                }\r\n                Log.exDev(hex.length !== 3 && hex.length !== 6, \"invalid hex length\", {hex, a});\r\n                let i: number = 0;\r\n                if (hex.length === 3) {\r\n                    r =  Number.parseInt('0x' + hex[i] + hex[i++]);\r\n                    g =  Number.parseInt('0x' + hex[i] + hex[i++]);\r\n                    b =  Number.parseInt('0x' + hex[i] + hex[i]);\r\n                }\r\n                else {\r\n                    r =  Number.parseInt('0x' + hex[i++] + hex[i++]);\r\n                    g =  Number.parseInt('0x' + hex[i++] + hex[i++]);\r\n                    b =  Number.parseInt('0x' + hex[i++] + hex[i]);\r\n                }\r\n                return {r,g,b,a} as tinycolor.ColorFormats.RGBA;\r\n            })};\r\n    }\r\n    public static fatherChain(me: LModelElement): Pointer<DModelElement, 0, 'N', LModelElement> {\r\n        if(!me) return [];  // without this line go through delete error\r\n        const fathers: Pointer<DModelElement, 0, 'N', LModelElement>= [me.id];\r\n        const toCheck: LModelElement[] = [me];\r\n        while(toCheck.length > 0) {\r\n            const element = toCheck.pop();\r\n            if(element && element.father) {\r\n                fathers.push(element.father.id);\r\n                toCheck.push(element.father);\r\n            }\r\n        }\r\n        return fathers;\r\n    }\r\n\r\n    /// maxDepth = 2 is the minimum to check the content of objects inside usageDeclarations or node state. like node.errors.naming\r\n    static isShallowEqualWithProxies(obj1?: any, obj2?: any, skipKeys: Dictionary<string>={}, out?: {reason?: string},\r\n                                     depth: number = 0, maxDepth: number = 2, returnIfMaxDepth:boolean = false): boolean {\r\n        if (obj1 === obj2) {\r\n            // if (out) { out.reason = \"identical objects\"; }\r\n            return true; }\r\n        let tobj1 = obj1 === null ? 'null' : typeof obj1;\r\n        let tobj2 = obj2 === null ? 'null' : typeof obj2;\r\n        if (tobj1 !== tobj2) { if (out) { out.reason = \"type changed: \" + tobj1 + \" --> \" + tobj2; } return false; }\r\n\r\n        //\r\n        // at this point: same type, but different values\r\n        //\r\n\r\n        if (!obj1 || !obj2) return false; // cannot happen but compiler wants it to narrow types\r\n        switch (tobj1) {\r\n            default: // primitive with different values\r\n                console.error(\"unexpected case in isshallowequal:\", {tobj1, obj1, obj2});\r\n                if (out) {\r\n                    if (undefined === tobj1) out.reason = 'primitive value newly introduced';\r\n                    else if (undefined === tobj2) out.reason = 'primitive value got deleted';\r\n                    else out.reason = 'primitive value changedd';\r\n                }\r\n                return false;\r\n            case 'string': case 'boolean': // primitive with different values\r\n                if (out) {\r\n                    if (undefined === tobj1) out.reason = 'primitive value newly introduced';\r\n                    else if (undefined === tobj2) out.reason = 'primitive value got deleted';\r\n                    else out.reason = 'primitive value changedd';\r\n                }\r\n                return false;\r\n            case \"number\": // if both re nan it fails\r\n                // NB: infinities are not nan, and they compare with === like normal numbers. weird js...\r\n                if (isNaN(obj1 as any) && isNaN(obj2 as any)) return true;\r\n                if (out) out.reason = 'number changed';\r\n                return false;\r\n\r\n            case \"function\":\r\n                if (obj1.toString() === obj2.toString()) break;\r\n                if (out) out.reason = 'function body changed';\r\n                return false;\r\n\r\n            case \"object\":\r\n                let o1Raw = obj1.__raw;\r\n                let o2Raw = obj2.__raw;\r\n                if (o1Raw) {\r\n                    if (!o2Raw) {\r\n                        if (out) out.reason = o1Raw.className + 'replaced by another object type:' + o2Raw?.className;\r\n                        return false;\r\n                    }\r\n                    obj1 = o1Raw as GObject;\r\n                    obj2 = o2Raw as GObject;\r\n                }\r\n                // for proxies and DObjects\r\n                if (obj1.clonedCounter !== undefined && obj2.clonedCounter !== obj1.clonedCounter) {\r\n                    if (out) out.reason = 'clonedCounter difference ' + obj1.clonedCounter+ ' != ' + obj2.clonedCounter;\r\n                    return false;\r\n                }/*\r\n                if (obj1.className !== obj2.className) {\r\n                 removed: too unlikely to happen that a DObject is raplaced in the same path with another type of DObject with same clonedCounter\r\n                 nd it's checked anyway in for(let key in obj1)\r\n                    if (out) out.reason = o1Raw.className + 'replaced by another object type:' + o2Raw?.className;\r\n                    return false;\r\n                }*/\r\n                if (Array.isArray(obj1)) {\r\n                    if (obj1.length !== obj2.length) {\r\n                        if (out) out.reason = 'array length different: ' + obj1.length + \" !== \" + obj2.length;\r\n                        return false;\r\n                    }\r\n                    if (!Array.isArray(obj2)){\r\n                        if (out) out.reason = 'array became an object';\r\n                        return false;\r\n                    }\r\n                }\r\n\r\n                if (obj1.className !== obj2.className) {\r\n                    if (out) out.reason = o1Raw.className + 'replaced by another object type:' + o2Raw?.className;\r\n                    return false;\r\n                }\r\n                switch(obj1.className) {\r\n                    default: break;\r\n                    case \"ISize\": case \"IPoint\": case \"GraphPoint\": case \"Point\": case \"Size\":\r\n                        skipKeys.id = true;\r\n                        skipKeys.dontMixWithGraphSize = true;\r\n                        skipKeys.dontMixWithSize = true;\r\n                        skipKeys.dontmixwithGPoint = true;\r\n                        skipKeys.dontmixwithPoint = true;\r\n                        skipKeys.rad = true;\r\n                        break;\r\n                }\r\n                // if EdgeSegment is changed, this needs update too: search in IDE for \"5khi2\"\r\n                if (U.objectIncludeKeys(obj1, 'd', 'dpart', 'svgLetter')){\r\n                    let ret = obj1.d === obj2.d && obj1.dpart === obj2.dpart;\r\n                    if (out && !ret) out.reason = 'EdgeSegment changed:' + obj1.d +' --> ' + obj2.d;\r\n                    return ret;\r\n                }\r\n\r\n                // if it is any kind of unknown object type, do deep check on every subkey\r\n                if (depth > maxDepth) {\r\n                    // to debug and see where is too deep, make returnIfMaxDepth = false, so the path is displayed in out.reason\r\n                    if (out) out.reason = 'max depth reached, assumed ' + returnIfMaxDepth;\r\n                    return returnIfMaxDepth;\r\n                }\r\n                for (let key in obj1) {\r\n                    if (key in skipKeys) continue;\r\n                    let oldp: any = obj2[key];\r\n                    let newp: any = obj1[key];\r\n                    if (oldp === newp) continue;\r\n                    if (!U.isShallowEqualWithProxies(newp, oldp, skipKeys, out, depth +1, maxDepth, returnIfMaxDepth)) {\r\n                        if (out) out.reason = '['+key+']'+out.reason;\r\n                        return false;\r\n                    }\r\n                }\r\n                // just check for keys that were in props and are not in nextProps\r\n                for (let key in obj2) {\r\n                    if ((key in skipKeys) || (key in obj1)) continue;\r\n                    if (out) out.reason = \"deleted subobject property: \" + key;\r\n                    return false;\r\n                }\r\n            // else retIfMaxDepthReached; split the above if\r\n        }\r\n\r\n\r\n\r\n        return true;\r\n    }\r\n\r\n    public static deepEqual (x: GObject, y: GObject): boolean {\r\n        const tx = typeof x, ty = typeof y;\r\n        return x && y && tx === 'object' && tx === ty ? (\r\n            Object.keys(x).length === Object.keys(y).length && Object.keys(x).every(key => U.deepEqual(x[key], y[key]))\r\n        ) : (x === y);\r\n    }\r\n\r\n    public static sleep(s: number): Promise<void> {\r\n        return new Promise((resolve) => setTimeout(resolve, s * 1000));\r\n    }\r\n\r\n    public static getRandomString(length: number): string {\r\n        const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';\r\n        let randomString = '';\r\n        let index = 0;\r\n        while(index < length) {\r\n            const randomNumber = Math.floor(Math.random() * characters.length);\r\n            randomString += characters.charAt(randomNumber);\r\n            index += 1;\r\n        }\r\n        return randomString;\r\n    }\r\n\r\n    public static popup(element: any) {\r\n        let html = '<style>body.swal2-no-backdrop .swal2-container {background-color: rgb(0 0 0 / 60%) !important}</style>'+ element;\r\n        const result = Swal.fire({\r\n            html: html,\r\n            backdrop: false,\r\n            showCloseButton: true,\r\n            showConfirmButton: false\r\n            //confirmButtonText: 'GOT IT'\r\n        })\r\n    }\r\n    public static filteredPointedBy(data: LModelElement, label: string): LModelElement[] {\r\n        const models: LModelElement[] = [];\r\n        for(let dict of data.pointedBy) {\r\n            const pointedBy = dict.source.split('.');\r\n            if(pointedBy.length === 3 && pointedBy[2] === label) {\r\n                models.push(LModelElement.fromPointer(pointedBy[1]));\r\n            }\r\n        }\r\n        return models;\r\n    }\r\n\r\n    public static getFatherFieldToDelete(data: LModelElement): keyof DModelElement|null {\r\n        const father = data.father;\r\n        let field = '';\r\n        switch(father.className + '|' + data.className) {\r\n            // DPackage\r\n            case 'DModel|DPackage': field = 'packages'; break;\r\n            case 'DPackage|DPackage': field = 'subpackages'; break;\r\n            // DEnumerator and DClass\r\n            case 'DPackage|DEnumerator':\r\n            case 'DPackage|DClass': field = 'classifiers'; break;\r\n            // DAttribute\r\n            case 'DClass|DAttribute': field = 'attributes'; break;\r\n            // DReference\r\n            case 'DClass|DReference': field = 'references'; break;\r\n            // DOperation\r\n            case 'DClass|DOperation': field = 'operations'; break;\r\n            // DEnumLiteral\r\n            case 'DEnumerator|DEnumLiteral': field = 'literals'; break;\r\n            // DObject\r\n            case 'DModel|DObject': field = 'objects'; break;\r\n            // DParameter\r\n            case 'DOperation|DParameter': field = 'parameters'; break;\r\n            // DValue\r\n            case 'DObject|DValue': field = 'features'; break;\r\n            // Error\r\n            default: return null;\r\n        }\r\n        return field as keyof DModelElement;\r\n    }\r\n\r\n    public static initializeValue(typeclassifier: undefined|DClassifier|LClassifier|Pointer<DClassifier, 1, 1, LClassifier>): string {\r\n        // if(!classifier) return 'null';\r\n        const pointer: Pointer = typeof typeclassifier === 'string' ? typeclassifier : (typeclassifier as DClassifier)?.id;\r\n        const me: LNamedElement = LNamedElement.fromPointer(pointer);\r\n        switch(me?.name) {\r\n            default:\r\n            case 'EString': return '';\r\n            case 'EChar':  return 'a';\r\n            case 'EInt': return '0';\r\n            case 'ELong': return '0';\r\n            case 'EShort': return '0';\r\n            case 'Byte': return '0';\r\n            case 'EFloat': return '0';\r\n            case 'EDouble': return '0';\r\n            case 'EBoolean': return 'false';\r\n            case 'EDate': return new Date().toJSON().slice(0,10);\r\n        }\r\n        return 'null';\r\n    }\r\n\r\n    public static orderChildrenByTimestamp(context: LogicContext): LModelElement[] {\r\n        const children = context.proxyObject.children;\r\n        if(children && children.length > 0) {\r\n            let orderedChildren = new Map<number, LModelElement>();\r\n            for(let child of children) {\r\n                let timestamp = child.id.slice(-13);\r\n                orderedChildren.set(+timestamp, child);\r\n            }\r\n            orderedChildren = new Map([...orderedChildren.entries()].sort());\r\n            return [...orderedChildren.values()];\r\n        } else return [];\r\n    }\r\n\r\n\r\n    public static followPath(base: GObject, path: string): {chain: GObject[], lastObject: GObject, keys:string[], lastkey: string, lastval: any, failedRemainingPath: string[]} {\r\n        let patharr = path.split('.');\r\n        let base0 = base;\r\n        let ret: {chain: GObject[], lastObject: GObject, keys: string[], lastkey: string, lastval: any, failedRemainingPath: string[]}  = {} as any;\r\n        ret.keys = patharr;\r\n        ret.chain = [base];\r\n        let lastObject = base;\r\n\r\n        for (let i = 0; i < patharr.length; i++) {\r\n            let path = ret.lastkey = patharr[i];\r\n            lastObject = base;\r\n            base = base[path];\r\n            ret.chain.push(base);\r\n            if (typeof base !== \"object\" || i + 1 === patharr.length) {\r\n                ret.failedRemainingPath = patharr.slice(i);\r\n                ret.lastval = base;\r\n                ret.lastObject = lastObject;\r\n                return ret;\r\n            }\r\n        }\r\n        throw new Error(\"followPath should never reach here\");\r\n        return ret;\r\n    }\r\n\r\n    static multiReplaceAllKV(a: string, kv: string[][] = []): string {\r\n        const keys: string[] = [];\r\n        const vals: string[] = [];\r\n        let i: number;\r\n        for (i = 0; i < kv.length; i++) { keys.push(kv[i][0]); vals.push(kv[i][0]); }\r\n        return U.multiReplaceAll(a, keys, vals); }\r\n\r\n    // if replacement is empty, it will be filled with '';\r\n    // if replacement length < searchText, replacement will be filled with copies of his elements cycling from 0 to his length until his length matches searchText.length\r\n    static multiReplaceAll(a: string, searchText: string[] = [], replacement: string[] = []): string {\r\n        // Log.ex(searchText.length !== replacement.length, 'search and replacement must be have same length: ' + searchText.length + \"vs\" + replacement.length + \" \" +JSON.stringify(searchText) + \"   \" + JSON.stringify(replacement));\r\n        let i = -1;\r\n        while (replacement.length !== 0 && replacement.length < searchText.length) replacement.push(replacement[++i]);\r\n        i = -1;\r\n        while (++i < searchText.length) { a = U.replaceAll(a, searchText[i], replacement[i]); }\r\n        return a; }\r\n\r\n    static replaceAll(str: string, searchText: string, replacement: string | undefined, debug: boolean = false, warn: boolean = true): string {\r\n        if (!str) { return str; }\r\n        return str.split(searchText).join(replacement||''); }\r\n\r\n    static toFileName(a: string = 'nameless.txt'): string {\r\n        if (!a) { a = 'nameless.txt'; }\r\n        a = U.multiReplaceAll(a.trim(), ['\\\\', '//', ':', '*', '?', '<', '>', '\"', '|'],\r\n            ['[lslash]', '[rslash]', ';', '°', '_', '{', '}', '\\'', '!']);\r\n        return a;\r\n    }\r\n\r\n\r\n    // warn: this check if the scope containing the function is strict, to check if a specific external scope-file is strict\r\n    // you have to write inline the code:        var isStrict = true; eval(\"var isStrict = false\"); if (isStrict)...\r\n    // @ts-ignore\r\n    public static isStrict: boolean = ( function() { return !this; })();\r\n\r\n    // merge properties with first found first kept (first parameters have priority on override). only override null|undefined values, not (false|0|'') values\r\n    static objectMergeInPlace<A extends object, B extends object>(output: A, ...objarr: B[]): void {\r\n        const out: GObject = output;\r\n        if (objarr)\r\n            for (let o of objarr) {\r\n                if (o && typeof o === \"object\")\r\n                    for (let key in o) {\r\n                        // noinspection BadExpressionStatementJS,JSUnfilteredForInLoop\r\n                        out[key] ?? (out[key] = o[key]);\r\n                    }\r\n            }\r\n    }\r\n/*\r\n    public static log(obj: unknown, label: string = '###') {\r\n        console.clear();\r\n        console.log(label, obj);\r\n    }*/\r\n\r\n    static removeEmptyObjectKeys(obj: GObject): void{\r\n        for (let key of Object.keys(obj)) {\r\n            if (obj[key] === null || obj[key] === undefined) delete obj[key];\r\n        }\r\n    }\r\n\r\n    // usage example: objectMergeInPlace_conditional(baseobj, (out, key, current) => !out[key] && current[key];\r\n    // culprit of \"couldn't find intersection\" problem: condition type: (out:A&B, key: string | number, current:B, objarr?: B[], indexOfCurrent?: number) => boolean\r\n    static objectMergeInPlace_conditional<A extends GObject, B extends GObject>(output: A, condition: (...a:any)=>any, ...objarr: B[]): A & B {\r\n        const out: GObject<\"A & B\"> = output;\r\n        let i: number = 0;\r\n        for (let o of objarr) for (let key in o) { if (condition(out, key, o, objarr, i++)) out[key] = o[key]; }\r\n        return out as  A & B; }\r\n\r\n    static buildFunctionDocumentation(f: Function): {fullSignature: string, parameters: {name: string, defaultVal: string | undefined, typedesc: string | null}[], returns: string | undefined, f: Function, fname: string | undefined, isLambda: boolean, signature: string} {\r\n        Log.e(!JsType.isFunction(f), 'getFunctionSignature() parameter must be a function', f);\r\n        // let parameters: {name: string, defaultVal: string, typedesc: string}[] = []; //{name: '', defaultVal: undefined, typedesc: ''};\r\n        let ret: {fullSignature: string, parameters: {name: string, defaultVal: string | undefined, typedesc: string | null}[], returns: string | undefined, f: Function, fname: string | undefined, isLambda: boolean, signature: string}\r\n            = {fullSignature: '', fname: undefined, signature: '', parameters: [], returns: undefined, f: f, isLambda: null as Temporary};\r\n        let str: string = f.toString();\r\n        let starti: number = str.indexOf('(');\r\n        let endi: number;\r\n        let parcounter: number = 1;\r\n        for (endi = starti + 1; endi < str.length; endi++) {\r\n            if (str[endi] === ')' && --parcounter === 0) break;\r\n            if (str[endi] === '(') parcounter++; }\r\n\r\n        let parameterStr = str.substring(starti + 1, endi);\r\n        // console.log('getfuncsignature starti:', starti, 'endi', endi, 'fname:', str.substr(0, starti), 'parameterStr:', parameterStr);\r\n        ret.fname = str.substr(0, starti).trim();\r\n        ret.fname = ret.fname.substr(0, ret.fname.indexOf(' ')).trim();\r\n        // 2 casi: anonimo \"function (par1...){}\" e \"() => {}\", oppure nominato: \"function a1(){}\"\r\n        if (ret.fname === '' || ret.fname === 'function') ret.fname = undefined; // 'anonymous function';\r\n\r\n\r\n\r\n        let returnstarti: number = str.indexOf('/*', endi + 1);\r\n        let returnendi: number = -1;\r\n        let bodystarti: number = str.indexOf('{', endi + 1);\r\n        if (returnstarti === -1 || bodystarti !== -1 && bodystarti < returnstarti) {\r\n            // no return type or comment is past body\r\n            ret.returns = undefined;\r\n        } else {\r\n            returnendi = str.indexOf('*/', returnstarti + 2);\r\n            ret.returns = str.substring(returnstarti + 2, returnendi).trim();\r\n            bodystarti = str.indexOf('{', returnendi); }\r\n        if (ret.returns === '') ret.returns = undefined;\r\n\r\n        // is lambda if do not have curly body or contains => between return comment and body\r\n        // console.log('isLambda:', bodystarti, str.substring(Math.max(endi, returnendi)+1, bodystarti));\r\n        ret.isLambda =  bodystarti === -1 || str.substring((window as any).Math.max(endi, returnendi)+1, bodystarti).trim() === '=>';\r\n\r\n        let regexp = /([^=\\/\\,]+)(=?)([^,]*?)(\\/\\*[^,]*?\\*\\/)?,/g; // only problem: the last parameter won't match because it does not end with \",\", so i will append it everytime.\r\n        let match;\r\n        while ((match = regexp.exec(parameterStr + ','))) {\r\n            // match[0] is always the full match (not a capture group)\r\n            // match[2] can only be \"=\" or empty string\r\n            // nb: match[4] can be \"/*something*/\" or \",\" a single , without spaces.\r\n            let par: {name: string, defaultVal: string | undefined, typedesc: string | null} = {name: match[1], defaultVal: match[3], typedesc: match[4] && match[4].length > 1 ? match[4] : null};\r\n            par.name = par.name.trim();\r\n            par.defaultVal = par.defaultVal ? par.defaultVal.trim() : undefined;\r\n            par.typedesc = par.typedesc && par.typedesc && par.typedesc.length > 1 ? par.typedesc.substring(2, par.typedesc.length - 2).trim() || null : null;\r\n            ret.parameters.push(par); }\r\n        // set signature\r\n\r\n        ret.signature = '' + (ret.fname ? '/*' + ret.fname + '*/' : '') + '(';\r\n        let i: number;\r\n        for (i = 0; i < ret.parameters.length; i++) {\r\n            let par = ret.parameters[i];\r\n            ret.signature += (i === 0 ? '' : ', ') + par.name + (par.typedesc ? '/*' + par.typedesc + '*/' : '') + (par.defaultVal ? ' = ' + par.defaultVal : '');\r\n        }\r\n        ret.signature += ')' + (ret.returns ? '/*' + ret.returns + '*/' : '');\r\n\r\n        ret.fullSignature = ret.isLambda? ret.signature + '=>' + ret.returns : (ret.fname ||'function') + ret.signature+': '+ret.returns;\r\n        return ret; }\r\n\r\n\r\n\r\n    // NB: need to use result.apply(context) to have a usable \"this\"\r\n    // if you want to pass a parameter to the function, pass it through scope insteand !! AND UNDECLARE the parameter in function string signature !!\r\n    //if inner funcstr have parameters, need to declare them as codestrParamNames arr, and pass them in that order, after the scope which is fixed as first argument.\r\n    // rest values are declared with ellipsis in codestrParamNames\r\n    // !!! scope passed here, is only used for keys. values are not bound. scope is set as first parameter when you call the function.\r\n    // context is bound, but can be re-assigned by calling .bind(), .call() or .apply(), so neither context nor scope assigned in parsing phase are final.\r\n    // innerfunc params do not have to match the name on the string function, but only the correct amount. they can have any name i think, but i list them correctly to documentate.\r\n    public static parseFunctionWithContextAndScope<ParamNames extends string[], T extends Function = Function, TT extends GObject | undefined = GObject>(\r\n        codeStr0: string | Function, context0: GObject | undefined, scope0: TT, codestrParamNames?: ParamNames, protectShallowValues: boolean = false, doIdentifierValidation: boolean = false):\r\n        (TT extends undefined ? (...params: any)=>any : (scopee:TT, ...paramss: { [K in keyof ParamNames]: any;})=>any){\r\n        if (!codestrParamNames) codestrParamNames = [] as any;\r\n\r\n        let codeStr: string = typeof codeStr0 === \"function\" ? codeStr0.toString() : codeStr0;\r\n        let scopeParams: string = '';\r\n        let scope: GObject | undefined;\r\n        let context: GObject | undefined;\r\n        if (protectShallowValues) {\r\n            if (scope0) { //scope = {...scope0}; scope.__proto__ = scope0.__proto__; // for...in gets values in __proto__ too, {...o} instead gets only hasOwnProperty copied\r\n                scope = {};\r\n                for (let k in scope0) scope[k] = scope0[k];\r\n            } else scope = undefined;\r\n            if (context0) { // context = {...context0}; context.__proto__ = context0.__proto__;\r\n                context = {};\r\n                for (let k in context0) context[k] = context0[k];\r\n            } else context = undefined;\r\n        } else { scope = scope0; context = context0; }\r\n\r\n\r\n        if (scope) {\r\n            let scopekeys: string[] = Object.keys(scope);\r\n            if (doIdentifierValidation) scopekeys.map((key)=>{\r\n                key = key?.trim() || '';\r\n                if (!key || !U.validIdentfierRegexp.test(key)) return undefined;\r\n                return key;\r\n            }).filter(k=>!!k);\r\n            scopeParams = '{'+scopekeys.join(',')+'}';\r\n        }\r\n\r\n        let innerFuncParams = (codestrParamNames as string[]).join(',');\r\n        let _jevalfunc = undefined as any; // is set by eval\r\n        const evalmode = false;\r\n        console.log('parseFunctionWithContextAndScope', {codeStr, scope, context, params:{scopeParams, innerFuncParams}});\r\n        scopeParams = scopeParams && innerFuncParams ? scopeParams + ',' + innerFuncParams : scopeParams + innerFuncParams;\r\n        if (evalmode) {\r\n            codeStr = \"_jevalfunc = function (\"+scopeParams+\") { return (\"+codeStr+\")(\"+innerFuncParams+\") }\";\r\n            eval(codeStr);\r\n        } else {\r\n            _jevalfunc = new Function(scopeParams, \" return (\"+codeStr+\")(\"+innerFuncParams+\")\");\r\n        }\r\n\r\n        console.log('parseFunctionWithContextAndScope', {_jevalfunc, params:{scopeParams}});\r\n\r\n        if (context) return _jevalfunc.bind(context);\r\n        else return _jevalfunc;\r\n    }/*\r\n    public static evalInContextAndScope<T = any>(...a:any):any {return undefined}\r\n    public static evalInContextAndScopeNew<T = any>(...a:any):any {return undefined}*/\r\n    public static evalInContextAndScopeNew<T = any>(codeStr: string | ((...a:any)=>any), context0: GObject, injectScopeToo: boolean,\r\n                                                    protectShallowValues?: boolean, doIdentifierValidation?: boolean): T {\r\n        return U.evalInContextAndScope(codeStr, context0, injectScopeToo ? context0 : undefined, protectShallowValues, doIdentifierValidation);\r\n    }\r\n\r\n    // important! this is a simplified version. the correct one allows unicode chars and is 11kb long of regex expression\r\n    public static validIdentfierRegexp = /^[a-zA-Z_$][0-9a-zA-Z_$]*$/;\r\n\r\n    // warn: if return is not explicitly inserted (if that's the case set imlicitReturn = false) with a scope and the code have multiple statemepts it will fail.\r\n    // can modify scope AND context\r\n    // warn: can access global scope (window)\r\n    // if the context (this) is missing it will take the scope as context.\r\n    // warn: cannot set different scope and context, \"this\" della funzione sovrascrive anche il \"this\" interno allo scope come chiave dell'oggetto\r\n    // warn: !context && scope is impossible, so it gets autofixed by assigning context = scope; check Log messages inside function for details.\r\n    // warn: context && scope is impossible if context !== scope and cannot be hotfixed, that will cause a crash.\r\n    public static evalInContextAndScope<T = any>(codeStr: string | ((...a:any)=>any), scope0: GObject | undefined, context0?: GObject,\r\n                                                 protectShallowValues?: boolean, doIdentifierValidation?:boolean): T {\r\n        // console.log('evalInContextAndScope', {codeStr, scope, context});\r\n        // scope per accedere a variabili direttamente \"x + y\"\r\n        // context per accedervi tramite this, possono essere impostati come diversi.\r\n        if (!scope0 && !context0) { Log.ex(true, 'evalInContextAndScope: must specify at least one of scope || context', {codeStr, scope0, context0}); }\r\n\r\n        // scope.this = scope.this || context || scope; non funziona\r\n        // console.log('\"with(this){ return eval( \\'\" + codeStr + \"\\' ); }\"', \"with(this){ return eval( '\" + codeStr + \"' ); }\");\r\n        // eslint-disable-next-line no-restricted-syntax,no-with\r\n        // if (allowScope && allowContext) { return function(){ with(this){ return eval( '\" + codeStr + \"' ); }}.call(scopeAndContext); }\r\n        // if (allowScope && allowContext) { return new Function( \"with(this){ return eval( '\" + codeStr + \"' ); }\").call(scopeAndContext); }\r\n        let _ret: T = null as any;\r\n        let scope: GObject | undefined;\r\n        let context: GObject | undefined;\r\n        if (protectShallowValues) {\r\n            if (scope0) { scope = {...scope0, __proto__: scope0.__proto__}; scope.__proto__ = scope0.__proto__; } else scope = undefined;\r\n            if (context0) { context = {...context0, __proto__: context0.__proto__}; context.__proto__ = context0.__proto__; } else context = undefined;\r\n        } else { scope = scope0; context = context0; }\r\n\r\n        Log.w(!!(!context && scope),\r\n            \"evalInContextAndScope() Context is mandatory, as scope && !context case is not working properly \\n\" +\r\n            \"because scope is simulated by declaring variables pointing to \\\"this\\\" objects instead of doing a full deep copy.\\n\" +\r\n            \"Autofixed by assigning context = scope;\");\r\n        Log.eDev(!!((context && scope) && (context !== scope)),\r\n            \"evalInContextAndScope() Context and scope cannot be different if both present.\\n\" +\r\n            \"Because scope is simulated by declaring variables pointing to \\\"this\\\" objects instead of doing a full deep copy.\");\r\n        if (!context) context = scope; // se creo un nuovo contesto pulisco anche lo scope dalle variabili locali di questa funzione.\r\n\r\n\r\n        /*\r\n        if (allowScope && allowContext) { return new Function( \"with(this){ return eval( '\" + codeStr.replace(/'/g, \"\\\\'\") + \"' ); }\").call(scopeAndContext); }\r\n        if (!allowScope && allowContext) { return new Function( \"return eval( '\" + codeStr + \"' );\").call(scopeAndContext); }\r\n        if (allowScope && !allowContext) { return eval(\"with(scopeAndContext){ \" + codeStr + \" }\"); }*/\r\n//      U.pe(!!scope && U.isStrict(), 'cannot change scope while in strict mode (\"use strict\")');\r\n        let prefixDeclarations: string = \"\", postfixDeclarations: string = '';\r\n        if (scope) {\r\n            if (U.isStrict) {\r\n                for (let key in scope) {\r\n                    if (doIdentifierValidation) {\r\n                        key = key.trim();\r\n                        if (!key || !U.validIdentfierRegexp.test(key)) continue;\r\n                    }\r\n                    // anche se li assegno non cambiano i loro valori nel contesto fuori dall'eval, quindi lancio eccezioni con const.\r\n                    prefixDeclarations += \"const \" + key + \"=this.\" + key + \";\";\r\n                    postfixDeclarations = \"\";\r\n                }\r\n            } else {\r\n                prefixDeclarations = \"with(\" + (context ? \"this._eval.\" : \"\") + \"scope){ \";\r\n                postfixDeclarations = \" }\";\r\n            }\r\n        }\r\n\r\n        if (scope && context) {\r\n            if (typeof codeStr === \"function\") { codeStr = codeStr.toString(); } // functions cannot change scope (with statement is deprecated)\r\n            (context as any)._eval = {__codeStr: codeStr}; // necessary to reach this._eval.codeStr inside the eval()\r\n            // console.log(\"evalincontextandscope: \", {fullCodeStr: prefixDeclarations + \"return eval( this._eval._codeStr );\" + postfixDeclarations, codeStr});\r\n            _ret = new (Function as any)(prefixDeclarations + \"; return eval( this._eval.__codeStr );\" + postfixDeclarations).call(context);\r\n            delete (context as any)._eval;\r\n        } else\r\n        if (!scope && context) {\r\n            if (typeof codeStr === \"function\") {\r\n                _ret = (function(...a: any){ return (codeStr as Function).call(context, ...a)}) as any;\r\n                // _ret = (...a: any)=>codeStr.call(context, ...a);\r\n            } else {\r\n                // cannot just eval(codeStr).call(context) because the result might not be a function but only a piece of code or an expression\r\n                (context as any)._eval = {__codeStr: codeStr}; // necessary to reach this._eval.codeStr inside the eval()\r\n                _ret = new (Function as any)(\"return eval( this._eval.__codeStr );\").call(context);\r\n                delete (context as any)._eval;\r\n                // this below  is not good, as i need to quote the expanded result of codeStr,\r\n                // but since it might contain quotes as well i would need to escape them too.\r\n                // _ret = new (Function as any)(\"return eval( \" + codeStr + \" );\").call(context);\r\n            }\r\n        } else\r\n        if (scope && !context) {\r\n            // NB: potrei creare lo scope con \"let key = value;\" per ogni chiave, ma dovrei fare json stringify e non è una serializzazione perfetta e può dare eccezioni(circolarità)\r\n            // console.log({isStrict: U.isStrict, eval: \"eval(\" + prefixDeclarations + codeStr + postfixDeclarations + \")\"});\r\n            if (typeof codeStr === \"function\") { codeStr = codeStr.toString(); } // functions cannot change scope (with statement is deprecated)\r\n            _ret = eval(prefixDeclarations + codeStr + postfixDeclarations); }\r\n\r\n        return _ret; }\r\n\r\n    //T extends ( ((...args: any[]) => any) | (() => any)\r\n    public static execInContextAndScope<T extends (...args: any) => any>(func: T, parameters: Parameters<T>, scope?: GObject, context?: GObject): ReturnType<T>{\r\n        Log.l(false, 'execInCtxScope', {func, parameters, scope, context});\r\n        let ret: any;\r\n        const _eval = {context, scope, func, parameters: parameters || []};\r\n        let prefixDeclarations: string = \"\", postfixDeclarations: string = '';\r\n        if (scope) {\r\n            if (U.isStrict) {\r\n                for (let key in scope) {\r\n                    // anche se li assegno non cambiano i loro valori nel contesto fuori dall'eval, quindi lancio eccezioni con const.\r\n                    prefixDeclarations += \"const \" + key + \" = this.\" + key + \"; \";\r\n                    postfixDeclarations = \"\";\r\n                }\r\n            } else {\r\n                prefixDeclarations = \"with(\" + (context ? \"this._eval.\" : \"\") + \"scope){ \";\r\n                postfixDeclarations = \" }\";\r\n            }\r\n        }\r\n        if (!scope && !context) { Log.ex(true, 'execInContextAndScope: must specify at least one of scope || context', {func, scope, context}); }\r\n        if (!context) context = scope; // se creo un nuovo contesto pulisco anche lo scope dalle variabili locali di questa funzione.\r\n        if (scope && context) {\r\n            context._eval = _eval;\r\n            // will the scope work with \"with\" outside the function body?\r\n            ret = new Function( prefixDeclarations + \"return this._eval.func.apply(this._eval.context, this._eval.parameters);\" + postfixDeclarations).call(context);\r\n            delete context._eval;\r\n        }\r\n        if (!scope && context) { return _eval.func.apply(_eval.context, _eval.parameters); }\r\n        if (scope && !context) {\r\n            // todo: non credo funzioni, _eval non dovrebbe essere accessibile dopo la \"with\" forse devo fare scope._eval = _eval;\r\n            return eval(prefixDeclarations + \"return _eval.func(..._eval.parameters);\" + postfixDeclarations); }\r\n        return ret; }\r\n\r\n    // warn: aggiunge un layer di scope ma ha accesso anche agli scope precedenti (del chiamante della funzione e superiori)\r\n    // warn2: può modificare lo scope internamente all'eval ma ogni cambiamento è perso all'uscita dell'esecuzione (modifica copie)\r\n    // warn3: gli oggetti nested variabili dentro oggetti dello scope) sono modificabili con modifiche persistenti perchè vengono pasate per puntatore.\r\n    // warn4: richiede un return per leggere il valore\r\n    // insomma: sta funzione fa schifo ma non c'è di meglio e non puoi nè permettere nè vietare completamente le modifiche allo scope.\r\n    private static execInScope_DO_NOT_USE(codeStr: string, scope: GObject) {\r\n        return (new Function(...Object.keys(scope), codeStr))(...Object.values(scope));\r\n    }\r\n\r\n    // can modify context in-place, requires \"this\" before variable\r\n    private static evalInContext(js: string, context: GObject): unknown {\r\n        //# Return the results of the in-line anonymous function we .call with the passed context\r\n        return function() { return eval(js); }.call(context);\r\n    }/*\r\n    / *\r\n    // NO: ha 2 problemi: il contesto non è persistente e puoi accedere al contesto solo con \"this\" ma non direttamente usando i nomi delle variabili\r\n    public static evalInContext(contextObj: GObject, code: string): any{\r\n        return U.evalContextFunction.call(contextObj || {}, code);\r\n    }\r\n\r\n    // only create a context for \"this\", wich is bound by .call(), should never be called without .call()\r\n    private static evalContextFunction(code: string): any { eval(code); }\r\n*/\r\n    public static highOrderFunctionExampleTyped<T extends (...args: any[]) => ReturnType<T>>(func: T): (...funcArgs: Parameters<T>) => ReturnType<T> {\r\n        const funcName = (func as any).cname || func.name;\r\n\r\n        // Return a new function that tracks how long the original took\r\n        return (...args: Parameters<T>): ReturnType<T> => {\r\n            console.time(funcName);\r\n            const results = func(...args);\r\n            console.timeEnd(funcName);\r\n            return results; };\r\n    }\r\n\r\n    static asClass<T extends Function>(obj: any, classe: T, elseReturn: T | null = null): null | T { return obj instanceof classe ? obj as any as T: elseReturn; }\r\n    static asString<T>(propKey: unknown, elseReturn: T | null = null): string | null | T { return typeof propKey === 'string' ? propKey : elseReturn; }\r\n    static isString(propKey: unknown): boolean { return typeof propKey === 'string'; }\r\n\r\n    static loadScript(path: string, useEval: boolean = false): void {\r\n        const script = document.createElement('script');\r\n        script.src = path;\r\n        script.type = 'text/javascript';\r\n        Log.eDev(useEval, 'loadScript', 'useEval','useEval todo. potrebbe essere utile per avviare codice fuori dalle funzioni in futuro.');\r\n        document.body.append(script); }\r\n\r\n    static ancestorArray<T extends Element>(domelem: T | null | undefined, stopNode?: Node, includeSelf: boolean = true): Array<T> {\r\n        // [0]=element, [1]=father, [2]=grandfather... [n]=document\r\n        if (!domelem) { return []; }\r\n        const arr = includeSelf ? [domelem] : [];\r\n        let tmp: T = domelem.parentNode as T;\r\n        while (tmp !== null && tmp !== stopNode) {\r\n            arr.push(tmp);\r\n            tmp = tmp.parentNode as T; }\r\n        return arr; }\r\n\r\n    public static monitorObjectProperty(o: GObject, key: string, callback:((k:string, v:any, isWrite: boolean, oldVal: any)=>void),\r\n                                        read: boolean=true, write: boolean=true): void{\r\n        if (!o || !callback || !read && !write) return;\r\n        let propDescriptor: GObject = {};\r\n        let prefixed = '_monitorObject_' + key;\r\n        o[prefixed] = o[key];\r\n        if (read) propDescriptor.get = () => { callback(key, o[prefixed], false, undefined); return o[prefixed]; };\r\n        if (write) propDescriptor.set = (newVal: any) => { callback(key, newVal, true, o[prefixed]); o[prefixed] = newVal; };\r\n        Object.defineProperty(o, key, propDescriptor);\r\n    }\r\n\r\n    static toHtml<T extends Element>(html: string, container?: Element, containerTag: string = 'div'): T {\r\n        if (!container) { container = document.createElement(containerTag); }\r\n        Log.e(!html || html === '', 'toHtml', 'require a non-empty string', html);\r\n        container.innerHTML = html;\r\n        const ret: T = container.firstChild as any;\r\n        if (ret) container.removeChild(ret);\r\n        return ret; }\r\n\r\n    public static levenshtein(a: string, b: string): number {\r\n        if (!a.length) return b.length;\r\n        if (!b.length) return a.length;\r\n        let cost = (a.charAt(a.length - 1) === b.charAt(b.length - 1)) ? 0 : 1;\r\n        return (window as any).Math.min(\r\n            U.levenshtein(a.substring(0, a.length - 1), b) + 1,\r\n            U.levenshtein(a, b.substring(0, b.length - 1)) + 1,\r\n            U.levenshtein(a.substring(0, a.length - 1), b.substring(0, b.length - 1)) + cost,\r\n        );\r\n    }\r\n\r\n    public static getClosestPropertyName(names: string[], name: string): string {\r\n        let lowest = Infinity;\r\n        return names.reduce(function(previous, current) {\r\n            let distance = U.levenshtein(current, name);\r\n            if (distance < lowest) {\r\n                lowest = distance;\r\n                return current;\r\n            }\r\n            return previous;\r\n        }, '');\r\n    }\r\n\r\n    public static getClosestPropertyNames(names: string[], name: string): string[] {\r\n        let distances: {distance: number, value: string}[] = names.map( value => { return {distance: U.levenshtein(value, name), value}; });\r\n        return distances.sort( (a, b) => a.distance - b.distance).map( e => e.value);\r\n    }\r\n\r\n    //todo for console\r\n    public static autoCorrectProxy<T extends GObject>(target: T, recursive: boolean, logger: Console): ProxyHandler<T> {\r\n        return new Proxy(target, {\r\n            get: function(target, name) {\r\n                let namestr = U.asString(name, null);\r\n                if (!namestr) return undefined;\r\n                if (name in target) return target[namestr];\r\n                const suggestions: string[] = U.getClosestPropertyNames(Object.getOwnPropertyNames(target), namestr);\r\n                logger.warn(`${namestr} is not defined, did you meant ${suggestions[0]}?\\t\\nother suggestions:`, suggestions);\r\n                return namestr && target[suggestions[0]];\r\n            },\r\n        });\r\n    }\r\n\r\n    static arrayRemoveAll<T>(arr: Array<T>, elem: T, debug: boolean = false): void {\r\n        let index;\r\n        if (!arr) return;\r\n        while (true) {\r\n            index = arr.indexOf(elem);\r\n            Log.l(debug, 'ArrayRemoveAll: index: ', index, '; arr:', arr, '; elem:', elem);\r\n            if (index === -1) { return; }\r\n            arr.splice(index, 1);\r\n            Log.l(debug, 'ArrayRemoveAll RemovedOne:', arr);\r\n        }\r\n    }\r\n\r\n    static arrayUnique<T>(arr: T[]): Array<T> { return [ ...new Set<T>(arr)]; }\r\n\r\n    static fileReadContent(file: File, callback: (content :string) => void): void {\r\n        const textType = /text.*/;\r\n        try { if (!file.type || file.type.match(textType)) {\r\n            let reader = new FileReader();\r\n            reader.onload = function(e) { callback( '' + reader.result ); };\r\n            reader.readAsText(file);\r\n            return;\r\n        } } catch(e) { Log.e(true, \"Exception while trying to read file as text. Error: |\", e, \"|\", file); }\r\n        Log.e(true, \"Wrong file type found: |\", file ? file.type : null, \"|\", file); }\r\n\r\n    static fileRead(onChange: (e: Event, files: FileList | null, contents?: string[]) => void, extensions: string[] | FileReadTypeEnum[], readContent: boolean): void {\r\n        // $(document).on('change', (e) => console.log(e));\r\n        console.log(\"importEcore: pre file reader\");\r\n        myFileReader.show(onChange, extensions, readContent);\r\n    }\r\n\r\n    public static clear(htmlNode: Element): void {\r\n        if (htmlNode) while (htmlNode.firstChild) { htmlNode.removeChild(htmlNode.firstChild); }\r\n    }\r\n\r\n    static clearAllTimeouts(): void {\r\n        const highestTimeoutId: number = setTimeout(() => {}, 1) as any;\r\n        for (let i = 0 ; i < highestTimeoutId ; i++) { clearTimeout(i); }\r\n    }\r\n\r\n    static getStackTrace(sliceCalls: number = 2): string[] {\r\n        const ret: string | undefined = Error().stack;\r\n        // try { var a = {}; a.debug(); } catch(ex) { ret = ex.stack; }\r\n        // if (Array.isArray(ret)) return ret;\r\n        if (!ret) return ['UnknownStackTrace'];\r\n        const arr: string[] = ret.split('\\n');\r\n        // first 2 entries are \"Erorr\" and \"getStackTrace()\"\r\n        return sliceCalls > 0 ? arr.slice( sliceCalls ) : arr; }\r\n\r\n    // 0 for caller, 1 for caller of caller, -1 for current function, up to -4 to see internal layers (useless)\r\n    public static getCaller(stacksToSkip: number = 0): string {\r\n        const stack: string[] = this.getStackTrace(4);\r\n        // erase getStackTrace() and isFirstTimeCalled() + Error() first stack + n° of layer the caller wants.\r\n        return stack[stacksToSkip]; }\r\n\r\n    private static gotcalledby: Dictionary<string, boolean> = {};\r\n\r\n    // todo: use in Log.once\r\n    // returns true only the first time this line is reached, false in loops >1 loop, false in recursion >1 recursion, false even days after the first execution unless the page is reloaded\r\n    public static isFirstTimeCalledByThisLine(stacksToSkip: number = 0): boolean {\r\n        const caller: string = this.getCaller(stacksToSkip);\r\n        if (U.gotcalledby[caller]) return false;\r\n        return U.gotcalledby[caller] = true; }\r\n\r\n    public static lineKey(): string { return this.getCaller(0); }\r\n\r\n    // Prevent the backspace key from navigating back.\r\n    static preventBackSlashHistoryNavigation(event: JQuery.KeyDownEvent): boolean {\r\n        if (!event || !event.key || event.key.toLowerCase() !== 'backspace') { return true; }\r\n        const types: string[] = ['text', 'password', 'file', 'search', 'email', 'number', 'date',\r\n            'color', 'datetime', 'datetime-local', 'month', 'range', 'search', 'tel', 'time', 'url', 'week'];\r\n        const srcElement: JQuery<any> = $((event as any)['srcElement'] || event.target);\r\n        const disabled = srcElement.prop('readonly') || srcElement.prop('disabled');\r\n        if (!disabled) {\r\n            if (srcElement[0].isContentEditable || srcElement.is('textarea')) { return true; }\r\n            if (srcElement.is('input')) {\r\n                const type = srcElement.attr('type');\r\n                if (!type || types.indexOf(type.toLowerCase()) > -1) { return true; }\r\n            }\r\n        }\r\n        event.preventDefault();\r\n        return false; }\r\n\r\n    static SetMerge<T>(modifyFirst: boolean = true, ...iterables: Iterable<T>[]): Set<T> {\r\n        const set: Set<T> = modifyFirst ? iterables[0] as Set<T>: new Set<T>();\r\n        Log.e(!(set instanceof Set), 'U.SetMerge() used with modifyFirst = true requires the first argument to be a set');\r\n        for (let iterable of iterables) { for (let item of iterable) { set.add(item); } }\r\n        return set; }\r\n\r\n    // merge with unique elements\r\n    static ArrayMergeU(arr1: any[], ...arr2: any[]): void { U.ArrayMerge0(true, arr1, arr2); }\r\n    // merge without unique check\r\n    static ArrayMerge(arr1: any[], ...arr2: any[]): void { U.ArrayMerge0(false, arr1, arr2); }\r\n    // implementation\r\n    static ArrayMerge0(unique: boolean, arrtarget: any[], ...arrays: any[]): void {\r\n        if (!arrtarget || !arrays) return;\r\n\r\n        if (unique) { for (let arri of arrays) for (let e of arri) U.ArrayAdd(arrtarget, e); }\r\n        else { for (let arri of arrays) Array.prototype.push.apply(arrtarget, arri); }\r\n    }\r\n\r\n    static ArrayAdd<T>(arr: Array<T>, elem: T, unique: boolean = true, throwIfContained: boolean = false): boolean {\r\n        Log.ex(!arr || !Array.isArray(arr), 'ArrayAdd arr null or not array:', arr);\r\n        if (!unique) { arr.push(elem); return true; }\r\n        if (arr.indexOf(elem) === -1) { arr.push(elem); return true; }\r\n        Log.ex(throwIfContained, 'ArrayAdd element already contained:', arr, elem);\r\n        return false; }\r\n\r\n\r\n    private static maxID: number = 0;\r\n    public static idPrefix: string = '';\r\n    // static getID(): string { return U.idPrefix + U.maxID++; }\r\n    static getID: Generator<number> = function* idgenerator(): Generator<number> { let i: number = 0; while(true) yield i++; }();\r\n\r\n\r\n    static getType(param: any): string {\r\n        switch (typeof param) {\r\n            default: return typeof param;\r\n            case 'object':\r\n                return (param?.constructor as typeof RuntimeAccessibleClass)?.cname || param?.className || \"{_rawobject_}\";\r\n            case 'function': // and others\r\n                return \"geType for function todo: distinguish betweeen arrow and classic\";\r\n        }\r\n    }\r\n\r\n    static stringCompare(s1: string, s2: string): -1 | 0 | 1 { return (s1 < s2) ? -1 : (s1 > s2) ? 1 : 0; }\r\n\r\n    static endsWith(str: string, suffix: string | string[]): boolean {\r\n        if (Array.isArray(suffix)) {\r\n            for (let suf of suffix) {\r\n                if (U.endsWith(str, suf)) return true;\r\n            }\r\n            return false;\r\n        }\r\n        return str.length >= suffix.length && str.lastIndexOf(suffix) === str.length - suffix.length;\r\n    }\r\n\r\n\r\n    static arrayMergeInPlace<T>(arr1: T[], ...otherArrs: T[][]): T[] {\r\n        for (const arr of otherArrs) arr1.push.apply(arr1, arr || []);\r\n        return arr1; }\r\n\r\n    static getEndingNumber(s: string, ignoreNonNumbers: boolean = false, allowDecimal: boolean = false): number {\r\n        let i = s.length;\r\n        let numberEnd = -1;\r\n        while (--i > 0) {\r\n            if (!isNaN(+s[i])) { if (numberEnd === -1) { numberEnd = i; } continue; }\r\n            if (s[i] === '.' && !allowDecimal) { break; }\r\n            if (s[i] === '.') { allowDecimal = false; continue; }\r\n            if (!ignoreNonNumbers) { break; }\r\n            if (numberEnd !== -1) { ignoreNonNumbers = false; }\r\n        }\r\n        s = numberEnd === -1 ? '1' : s.substring(i, numberEnd);\r\n        return +parseFloat(s); }\r\n\r\n    static increaseEndingNumber(s: string, allowLastNonNumberChars: boolean = false, allowDecimal: boolean = false, increaseWhile?: ((x: string) => boolean)): string {\r\n        if (increaseWhile && !increaseWhile(s)) return s;\r\n        let regexpstr = '([0-9]+' + (allowDecimal ? '|[0-9]+\\\\.[0-9]+' : '') + ')' + (allowLastNonNumberChars ? '[^0-9]*' : '') + '$';\r\n        const matches: RegExpExecArray | null = new RegExp(regexpstr, 'g').exec(s); // Global (return multi-match) Single line (. matches \\n).\r\n        // S flag removed for browser support (firefox), should work anyway.\r\n        let prefix: string;\r\n        let num: number;\r\n        if (!matches) {\r\n            prefix = s;\r\n            num = 2;\r\n        } else {\r\n            Log.ex(matches.length > 2, 'parsing error: /' + regexpstr + '/gs.match(' + s + ')');\r\n            let i = s.length - matches[0].length;\r\n            prefix = s.substring(0, i);\r\n            num = 1 + (+matches[1]);\r\n        }\r\n        if (increaseWhile) while (increaseWhile(prefix + num)) { num++; }\r\n        return prefix + num; }\r\n\r\n\r\n    public static shallowEqual(objA: GObject, objB: GObject): boolean {\r\n        if (objA === objB) { return true; }\r\n\r\n        if (!objA || !objB || typeof objA !== 'object' || typeof objB !== 'object') { return false; }\r\n\r\n        var keysA = Object.keys(objA);\r\n        var keysB = Object.keys(objB);\r\n        if (keysA.length !== keysB.length) return false;\r\n\r\n        // if (keysA.length !== keysB.length) { return false; }\r\n        // Test for A's keys different from B.\r\n        // var bHasOwnProperty = hasOwnProperty.bind(objB);\r\n        for (let keya in objA) if (!Object.is(objA[keya], objB[keya])) return false;\r\n\r\n        // for (var i = 0; i < keysA.length; i++) if (!bHasOwnProperty(keysA[i]) || objA[keysA[i]] !== objB[keysA[i]]) { return false; }\r\n        return true;\r\n    }\r\n\r\n    // returns true only if parameter is already a number by type. UU.isNumber('3') will return false\r\n    static isNumber(o: any): o is number { return typeof o === \"number\" && !isNaN(o); }\r\n    static isPrimitive(o: any, returnIfNull=true, returnIfUndefined=true, returnIfSymbol = false): o is PrimitiveType {\r\n        switch (typeof o) {\r\n            case 'symbol': return returnIfSymbol; // it is primitive by definition, but behaves too much differently\r\n            case 'undefined': return returnIfUndefined;\r\n            case 'function':\r\n            case 'object':\r\n                if (o === null) return returnIfNull;\r\n                return false;\r\n            default: return true;\r\n            // case 'bigint':\r\n        }\r\n    }\r\n\r\n    public static getAllPrototypes(constructor: Constructor, chainoutoutrecursive: GObject[] = [], currentRecursion = 0, maxRecursion = 20, cache: boolean = true): GObject[] {\r\n        // console.log('getAllPrototypes:', {name: constructor.name, currentRecursion, constructor, chainoutoutrecursive});\r\n        if (cache && (constructor as any).__allprototypes) return (constructor as any).__allprototypes;\r\n        let prototype = (constructor.prototype?.name) && constructor.prototype;\r\n        let __proto__ = (constructor.__proto__?.name) && constructor.__proto__;\r\n        if (!prototype && !__proto__ || currentRecursion >= maxRecursion) return chainoutoutrecursive;\r\n        if (prototype) chainoutoutrecursive.push(prototype);\r\n        if (__proto__) chainoutoutrecursive.push(__proto__);\r\n        if (prototype) U.getAllPrototypes(prototype, chainoutoutrecursive, currentRecursion + 1, maxRecursion);\r\n        if (__proto__) U.getAllPrototypes(__proto__, chainoutoutrecursive, currentRecursion + 1, maxRecursion);\r\n        if (cache) (constructor as any).__allprototypes = chainoutoutrecursive;\r\n        return chainoutoutrecursive;\r\n    }\r\n\r\n    public static classIsExtending(subconstructor: Constructor | AbstractConstructor, superconstructor: Constructor | AbstractConstructor): boolean {\r\n        return (superconstructor as typeof DPointerTargetable)?._extends?.includes(subconstructor as any) || false;\r\n        // return U.getAllPrototypes(subconstructor).includes(superconstructor);\r\n    }\r\n\r\n    static isObject(v: GObject|any, returnIfNull: boolean = true, returnIfUndefined: boolean = false, retIfArray: boolean = false): boolean {\r\n        if (v === null) { return returnIfNull; }\r\n        if (v === undefined) { return returnIfUndefined; }\r\n        if (Array.isArray(v)) { return retIfArray; }\r\n        // nb: mind that typeof [] === 'object'\r\n        return typeof v === 'object'; }\r\n\r\n    static objectFromArray<V extends any>(arr: V[], getKey: (entry:V) => string): Dictionary<string, V>{\r\n        // @ts-ignore\r\n        return arr.reduce((acc, val) => { acc[getKey(val)] = val; return acc; }, {});\r\n    }\r\n\r\n    static objectFromArrayValues<T extends any>(arr: (string | number)[], val: T = true as T): Dictionary<string | number, T> {\r\n        // @ts-ignore\r\n        return arr.reduce((acc, v) => { acc[v] = val; return acc; }, {});\r\n        /*let ret: Dictionary = {};\r\n        for (let val of arr) { ret[val] = true; }\r\n        return ret;*/\r\n    }\r\n\r\n    static toBoolString(bool: boolean, ifNotBoolean: boolean = false): string { return bool === true ? 'true' : (bool === false ? 'false' : '' + ifNotBoolean); }\r\n    static fromBoolString<T extends any>(str: string | boolean): boolean;\r\n    static fromBoolString<T extends any>(str: string | boolean, defaultVal?: T): boolean | T;\r\n    static fromBoolString<T extends any>(str: string | boolean, defaultVal?: T, allowNull?: boolean): boolean | null | T;\r\n    static fromBoolString<T extends any>(str: string | boolean, defaultVal: T = false as any, allowNull: boolean = false, allowUndefined: boolean = false): boolean | null | undefined | T {\r\n        str = ('' + str).toLowerCase();\r\n        if (allowNull && (str === 'null')) return null;\r\n        if (allowUndefined && (str === 'undefined')) return undefined;\r\n\r\n        if (str === \"true\" || str === 't' || str === '1') return true;\r\n        // if (defaultVal === true) return str === \"false\" || str === 'f' || str === '0'; // false solo se è esplicitamente false, true se ambiguo.\r\n        if (str === \"false\" || str === 'f' || str === '0') return false;\r\n        return defaultVal;\r\n    }\r\n\r\n    static arrayDifference<T>(starting: T[], final: T[]): {added: T[], removed: T[], starting: T[], final: T[]} { return Uarr.arrayDifference(starting, final); }\r\n\r\n    /*  {a: { b: { c1: 1, c2:2, c3:3 } }, d: 1 }     ---->  {\"a.b.c1\":1, \"a.b.c2\":2, \"a.b.c3\":3. \"d\":1}*/\r\n    public static flattenObjectToRoot(obj: GObject, prefix: string = '', pathseparator: string = '.'): GObject{\r\n        if (!obj) { Log.ee('invalid flattenobject call', {obj, prefix}); return obj; }\r\n        return Object.keys(obj).reduce((acc: GObject, k: string) => {\r\n            const pre = prefix.length ? prefix + pathseparator : '';\r\n            if (typeof obj[k] === 'object') Object.assign(acc, U.flattenObjectToRoot(obj[k], pre + k, pathseparator));\r\n            else acc[pre + k] = obj[k];\r\n            return acc;\r\n        }, {});\r\n    }\r\n\r\n    // from {a:{aa:true, ab:\"ab\"}, b:4} to [\"a.aa = true\", \"a.ab = \\\"ab\\\"\", \"a.b = 4\"]\r\n    // maxkeylength is max length of any individual key, after it it will become: superlongpath --> supe...path\r\n    // maxsubpaths is how many subpaths are displayed at most. after it it will be: super.rea.lly.long.pa.th --> super.rea.pa.th\r\n    /*public static ObjectToAssignementStrings2<R extends {str: string, fullstr: string, path:string[], fullpath:string[], val: string, fullvalue: string, pathlength?: number}>\r\n    (obj: GObject, maxkeylength: number = 10, maxsubpaths: number = 6, maxvallength: number = 20, toolongreplacer: string = \"…\", out?:{best: R}&R[], quotestrings: boolean = true): {best: string}&string[] {\r\n        out.__jjsplitstrings = true;\r\n        let ret = U.ObjectToAssignementStrings(obj, maxkeylength, maxsubpaths, maxvallength, toolongreplacer, out, quotestrings)\r\n        delete out.__jjsplitstrings;\r\n        return ret;\r\n    }*/\r\n         public static ObjectToAssignementStrings<R extends {str: string, fullstr: string, path:string[], fullpath:string[],\r\n             val: string, fullvalue: string, pathlength?: number}>\r\n    (obj: GObject, maxkeylength: number = 10, maxsubpaths: number = 6, maxvallength: number = 20, toolongreplacer: string = \"…\",\r\n     out?:{best: R, obj: GObject}&R[], quotestrings: boolean = true, filterFunction?: (e:R)=>boolean): {best: string}&string[] {\r\n        const pathseparator = \".\";\r\n        const valueseparator = \" = \";\r\n        //const filterrow = (rowpaths: string[]) => { return (!rowpaths.includes(\"clonedCounter\") && !rowpaths.includes(\"pointedBy\")); };\r\n        let flatten = U.flattenObjectToRoot(obj, '', pathseparator);\r\n        let i = -1;\r\n        let tmp;\r\n        const ret: {best: string, obj: GObject} & string[] = [] as any;\r\n        ret.obj = obj;\r\n        tmp = (maxkeylength - toolongreplacer.length)/2;\r\n        let halfpath = { start: (window as any).Math.floor(tmp), end: (window as any).Math.ceil(tmp) };\r\n        tmp = (maxvallength - toolongreplacer.length)/2;\r\n        let halfval = { start: (window as any).Math.floor(tmp), end: (window as any).Math.ceil(tmp) };\r\n        tmp = (maxsubpaths - toolongreplacer.length)/2;\r\n        let halfsubpaths = { start: (window as any).Math.floor(tmp), end: (window as any).Math.ceil(tmp) };\r\n\r\n\r\n        let bestpathsize = 0;\r\n        let best: R | null = null;\r\n        let countsize = (total: number, arrelem: string): number => total + arrelem.length;\r\n        const filterbest = (row: R) => {\r\n            row.pathlength = row.fullstr.length; // row.fullpath.reduce<number>(countsize, 0);\r\n            if (!best || bestpathsize < row.pathlength) { // && filterrow(row.fullpath)) {\r\n                best = row;\r\n                bestpathsize = row.pathlength;\r\n                if (out) out.best = best;\r\n                ret.best = best.str;\r\n            }\r\n        }\r\n        console.log(\"u get assignements\", {flatten, obj});\r\n\r\n\r\n        for (let key in flatten) {\r\n            let row: R = {fullpath: key.split(pathseparator), fullstr: key} as R;\r\n            if (filterFunction && !filterFunction(row)) continue;\r\n            // stringify(undefined) = undefined, so i add + \"\"\r\n            try {\r\n                if (!quotestrings && typeof flatten[key] === \"string\") row.fullvalue = flatten[key];\r\n                else row.fullvalue = JSON.stringify(flatten[key]) + \"\";\r\n            } catch(e) { row.fullvalue = \"⁜not serializable⁜\"; }\r\n            // console.log(\"U get assignements loop\", {row, key, flatten, obj});\r\n            row.val = row.fullvalue.length <= maxvallength ? row.fullvalue : row.fullvalue.substring(0, halfval.start) + toolongreplacer + row.fullvalue.substring(halfval.start);\r\n            if (row.fullpath.length > maxsubpaths) {\r\n                row.path = [...row.fullpath];\r\n                row.path.splice( halfsubpaths.start, row.fullpath.length - halfsubpaths.start - halfsubpaths.end, toolongreplacer);\r\n            } else row.path = row.fullpath;\r\n\r\n            // row.path = row.fullpath.length <= maxsubpaths ? row.fullpath : [...row.fullpath.slice(0, halfsubpaths.start), ...row.fullpath.toomanyarraycopies];\r\n            row.path = row.path.map((p: string) => (p.length <= maxkeylength ? p : p.substring(0, halfpath.start) + toolongreplacer + p.substring(p.length - halfpath.end)));\r\n            if (out) { out.push(row); }\r\n\r\n            if (row.val === '__jjObjDiffEmptyElem') row.str = 'DELETE '+row.path.join(pathseparator)+';';\r\n            else row.str = row.path.join(pathseparator) + valueseparator + row.val;\r\n            ret.push( row.str );\r\n            filterbest(row);\r\n        }\r\n        return ret;\r\n    }\r\n\r\n\r\n    static download(filename: string = 'nameless.txt', text: string = '', debug: boolean = true): void {\r\n        if (!text) return;\r\n        filename = U.toFileName(filename);\r\n        const htmlA: HTMLAnchorElement = document.createElement('a');\r\n        const blob: Blob = new Blob([text], {type: 'text/plain', endings: 'native'});\r\n        const blobUrl: string = URL.createObjectURL(blob);\r\n        htmlA.style.display = 'none';\r\n        htmlA.href = blobUrl;\r\n        htmlA.download = filename;\r\n        document.body.appendChild(htmlA);\r\n        htmlA.click();\r\n        window.URL.revokeObjectURL(blobUrl);\r\n        document.body.removeChild(htmlA);\r\n    }\r\n\r\n    static formatXml(xml: string): string {\r\n        const reg = /(>)\\s*(<)(\\/*)/g;\r\n        const wsexp = / *(.*) +\\n/g;\r\n        const contexp = /(<.+>)(.+\\n)/g;\r\n        xml = xml.replace(reg, '$1\\n$2$3').replace(wsexp, '$1\\n').replace(contexp, '$1\\n$2');\r\n        const pad: string = '' || '\\t';\r\n        let formatted = '';\r\n        const lines = xml.split('\\n');\r\n        let indent = 0;\r\n        let lastType = 'other';\r\n        // 4 types of tags - single, closing, opening, other (text, doctype, comment) - 4*4 = 16 transitions\r\n        const transitions: GObject = {\r\n            'single->single': 0,\r\n            'single->closing': -1,\r\n            'single->opening': 0,\r\n            'single->other': 0,\r\n            'closing->single': 0,\r\n            'closing->closing': -1,\r\n            'closing->opening': 0,\r\n            'closing->other': 0,\r\n            'opening->single': 1,\r\n            'opening->closing': 0,\r\n            'opening->opening': 1,\r\n            'opening->other': 1,\r\n            'other->single': 0,\r\n            'other->closing': -1,\r\n            'other->opening': 0,\r\n            'other->other': 0\r\n        };\r\n        let i = 0;\r\n        for (i = 0; i < lines.length; i++) {\r\n            const ln = lines[i];\r\n\r\n            // Luca Viggiani 2017-07-03: handle optional <?xml ... ?> declaration\r\n            if (ln.match(/\\s*<\\?xml/)) {\r\n                formatted += ln + '\\n';\r\n                continue;\r\n            }\r\n            // ---\r\n\r\n            const single = Boolean(ln.match(/<.+\\/>/)); // is this line a single tag? ex. <br />\r\n            const closing = Boolean(ln.match(/<\\/.+>/)); // is this a closing tag? ex. </a>\r\n            const opening = Boolean(ln.match(/<[^!].*>/)); // is this even a tag (that's not <!something>)\r\n            const type = single ? 'single' : closing ? 'closing' : opening ? 'opening' : 'other';\r\n            const fromTo = lastType + '->' + type;\r\n            lastType = type;\r\n            let padding = '';\r\n\r\n            indent += transitions[fromTo];\r\n            let j: number;\r\n            for (j = 0; j < indent; j++) {\r\n                padding += pad;\r\n            }\r\n            if (fromTo === 'opening->closing') {\r\n                formatted = formatted.substr(0, formatted.length - 1) + ln + '\\n'; // substr removes line break (\\n) from prev loop\r\n            } else {\r\n                formatted += padding + ln + '\\n';\r\n            }\r\n        }\r\n\r\n        return formatted.trim(); }\r\n\r\n\r\n    // https://stackoverflow.com/questions/13861254/json-stringify-deep-objects  implementation with depth\r\n    static circularStringify(obj: GObject, replacer?: null | ((key: string, value: any) => any), space?: string | number, maxDepth_unsupported: number = 100): string {\r\n        const cache: any[] = [];\r\n        return JSON.stringify(obj, (key, value: any) => {\r\n            if (typeof value === 'object' && value !== null) {\r\n                // Duplicate reference found, discard key\r\n                if (cache.includes(value)) return \"[Circular Reference]\"; // might happen both before and after the replacer func\r\n                if (replacer){\r\n                    value = replacer(key, value);\r\n                    if (cache.includes(value)) return \"[Circular Reference]\"; // might happen both before and after the replacer func\r\n                }\r\n                // Store value in our collection\r\n                cache.push(value);\r\n            }\r\n            return value;\r\n        }, space);\r\n    }\r\n\r\n    static getFirstNumber(s: string, allowDecimalDot: boolean = true, allowDecimalComma: boolean = true, valueifmismatch: any = null): number {\r\n        let commamode = (allowDecimalComma ? (allowDecimalDot ?\"(\\\\.|\\\\,)\" : \"\\\\,\") : (allowDecimalDot ? \"\\\\.\" : \"will not use this regex\"));\r\n        let floatregex = new RegExp(\"-?\" + commamode  + \"?\\\\d+(\" + commamode + \"\\\\d{1,2})?\");\r\n        let intregex = /-?\\d+/;\r\n        let ret: any;\r\n        if (allowDecimalDot || allowDecimalComma) ret = floatregex.exec(s);\r\n        else ret = intregex.exec(s);\r\n        ret = ret && ret[0]; // first match\r\n        if (ret === null) return valueifmismatch;\r\n\r\n        let tmpindex:number;\r\n        if (allowDecimalComma) ret = U.replaceAll(ret, \",\", \".\");\r\n        // while (allowDecimalComma && (tmpindex = ret.indexOf(\",\")) !== ret.lastIndexOf(\",\")) ret.substring(tmp+1) // ret.indexOf(.)\r\n        while ((allowDecimalDot || allowDecimalComma) && (tmpindex = ret.indexOf(\".\")) !== ret.lastIndexOf(\".\")) ret = ret.substring(tmpindex+1) // ret.indexOf(.)\r\n        // if (ret[0]===\"-\" && (ret[1]===\",\" || ret[1]===\".\")) ret = \"-0.\"+ret.substring(2); automatically done bu js.    +\"-.5\" = -0.5\r\n        return +ret;\r\n    }\r\n\r\n    // faster than jquery, underscore and many native methods checked https://stackoverflow.com/a/59787784\r\n    public static isEmptyObject(obj: GObject | undefined): boolean {\r\n        if (typeof obj !== \"object\") return false;\r\n        for (var i in obj) return false;\r\n        return true;\r\n    }\r\n\r\n    private static pairArrayElementsRepeatFunc<T>(val: T, index: number, arr:T[]): T[]{ return [arr[index], arr[index+1]] }\r\n    private static pairArrayElementsReducerFunc<T>(accumulator: T[][], value: T, index: number, array: T[]):T[][] {\r\n        if (index % 2 === 0) accumulator.push(array.slice(index, index + 2));\r\n        return accumulator; }\r\n\r\n    // from arr[] to arr[][]. if is with repetitions is: [1,2], [2,3], [3,4]... (ret.length = source.length-1)\r\n    // if without repetitions is: [1,2], [3,4].... (ret.length = Math.ceil(source.length/2);\r\n    public static pairArrayElements<T>(arr:T[], withRepetitions:boolean = false):T[][] {\r\n        if (withRepetitions) { return arr.map(U.pairArrayElementsRepeatFunc).slice(0, arr.length-1); }\r\n        return arr.reduce( U.pairArrayElementsReducerFunc as ((accumulator: T[][], value: T, index: number, array: T[]) => T[][]), []); }\r\n\r\n    // removes line // and block /**/ comments  todo: can likely be improved by a regular expression\r\n    public static decomment_all(str: string): string { return this.decomment_line(this.decomment_block(str)); }\r\n    // removes line comments //\r\n    public static decomment_line(str: string, trimLines: boolean = true): string {\r\n        return str\r\n            .split(\"\\n\")\r\n            .map(s=> { let i = s.indexOf(\"//\"); s = (i === -1 ? s : s.substring(i)); return trimLines ? s.trim() : s; } )\r\n            .join(\"\\n\");\r\n    }\r\n    // removes block comments /**/\r\n    public static decomment_block(str: string): string {\r\n        // let maxcomments = 100;\r\n        while(true){\r\n            // if (--maxcomments===0) break;\r\n            let s: number = str.indexOf(\"/*\");\r\n            if (s === -1) break;\r\n            let e: number = str.indexOf(\"*/\", s+1);\r\n            if (e === -1) e = str.length;\r\n            str = str.substring(0, s) + str.substring(e+2);\r\n        }\r\n        return str; }\r\n\r\n    static uppercaseFirstLetter<T extends (string | GObject<\"jsx\">)>(str: T): T {\r\n        if (typeof str !== \"string\") return str;\r\n        return str.charAt(0).toUpperCase() + str.slice(1) as T;\r\n    }\r\n\r\n    // CAREFUL! it's imperfect.\r\n    // Does not handle strings starting with ( that are not ()=> arrow functions\r\n    // or codes whose last chars are () but not in (function)() form\r\n    static wrapUserFunction(str: string): string {\r\n        str = str.trim();\r\n        if (str[0]!=='(' || str.indexOf(\"function\") !== 0) {\r\n            str = \"()=>{\" + str + \"\\n}\"; // last \\n important for line comments //\r\n        }\r\n        if (str[str.length - 2] !== \"(\" || str[str.length - 1] !== \")\") str = \"(\" + str + \")()\";\r\n        return str;\r\n    }\r\n\r\n    // adds ellipsis in the middle of a string to truncate it when it's too long.\r\n    public static stringMiddleCut<T extends boolean | undefined, RET extends string | string[] = T extends true ? string[] : string>\r\n    (str: string, maxLength: number, ellipsisChar: string = '…', asArray?: T): RET{\r\n        if (!str as unknown || maxLength < 0 || str.length <= maxLength) return (asArray ? [str] : str) as RET;\r\n        var midpoint = Math.ceil(str.length / 2);\r\n        var toremove = str.length - maxLength + ellipsisChar.length; // makes room for the additional ellipsis too\r\n        var lstrip = Math.ceil(toremove/2); // left strip is the bigger one if odd chars\r\n        var rstrip = toremove - lstrip;\r\n        if (asArray) return [str.substring(0, midpoint-lstrip), ellipsisChar, str.substring(midpoint+rstrip)] as RET;\r\n        else return str.substring(0, midpoint-lstrip) + ellipsisChar + str.substring(midpoint+rstrip) as RET;\r\n    }\r\n\r\n    // transform grays: if the color is <20% different from gray, transform it instead in black or white, 0 = don't, 1 = always black or white\r\n    public static invertHex(s: string, prefix: string='#', transformGrays: number = 0.2): string {\r\n        if (s.indexOf(prefix) === 0) s = s.substring(prefix.length);\r\n        let r: number, g: number, b: number, h: number | undefined; // might be NaN if parseInt fails\r\n        if (s.length === 3 || s.length === 4) {\r\n            r = parseInt('0x'+s[0]);// works with hex numbers\r\n            g = parseInt('0x'+s[1]);\r\n            b = parseInt('0x'+s[2]);\r\n            h = s.length === 4 ? parseInt('0x'+s[4]) : undefined;\r\n        } else if (s.length === 6 || s.length === 8){\r\n            r = parseInt('0x'+s.substring(0, 2));\r\n            g = parseInt('0x'+s.substring(2, 4));\r\n            b = parseInt('0x'+s.substring(4, 6));\r\n            h = s.length === 8 ? parseInt('0x'+s.substring(6, 8)) : undefined;\r\n        } else return Log.ee(\"cannot invert hex color \" + s + \", invalid length\", {s});\r\n        if (isNaN(r)) return Log.ee(\"cannot invert hex color \" + s +\", invalid red\", {s});\r\n        if (isNaN(g)) return Log.ee(\"cannot invert hex color \" + s +\", invalid green\", {g});\r\n        if (isNaN(b)) return Log.ee(\"cannot invert hex color \" + s +\", invalid blue\", {b});\r\n\r\n        transformGrays = transformGrays * 128;\r\n        r = Math.abs(r-128) <= transformGrays ? (r >= 128 ? 0 : 255) : 255 - r;\r\n        g = Math.abs(g-128) <= transformGrays ? (g >= 128 ? 0 : 255) : 255 - g;\r\n        b = Math.abs(b-128) <= transformGrays ? (b >= 128 ? 0 : 255) : 255 - b;\r\n        if (h || h === 0) h = 255 - h;\r\n\r\n        let rs = r.toString(16);\r\n        if (rs.length === 1) rs = '0'+rs;\r\n        let gs = g.toString(16);\r\n        if (gs.length === 1) gs = '0'+gs;\r\n        let bs = b.toString(16);\r\n        if (bs.length === 1) bs = '0'+bs;\r\n        let hs = h ? h.toString(16) : '';\r\n        if (hs.length === 1) hs = '0'+hs;\r\n\r\n        return (prefix) + rs+gs+bs+hs;\r\n    }\r\n\r\n    public static parentUntil(tagName: string, p: Element | null): Element | null {\r\n        while (p && p.tagName !== tagName) p = p.parentElement;\r\n        return p;\r\n    }\r\n\r\n    static paletteSplit(palette: Readonly<PaletteType>): {\r\n        color: Dictionary<string, PaletteControl>,\r\n        number: Dictionary<string, NumberControl>,\r\n        text: Dictionary<string, StringControl>,\r\n        path: Dictionary<string, PathControl>,\r\n    } {\r\n        type clist = PaletteControl | NumberControl | StringControl | PathControl;\r\n        let ret = {\r\n            color: {} as Dictionary<string, PaletteControl>,\r\n            number: {} as Dictionary<string, NumberControl>,\r\n            text: {} as Dictionary<string, StringControl>,\r\n            path: {} as Dictionary<string, PathControl>,\r\n        } as Dictionary<(clist)[\"type\"], Dictionary<string, any>>;\r\n        for (let entry of Object.entries(palette)) {\r\n            let k = entry[0];\r\n            let v = entry[1];\r\n            ret[(v as clist).type][k] = v;\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    static mergeNamedArray<T extends GObject>(ret: T[] & Dictionary<DocString<\"$name\">, T>, classes: T[] & Dictionary<DocString<\"$name\">, T>) {\r\n        for (let key of Object.getOwnPropertyNames(classes)) { // ownPropertyNames skips \"first, last, separator\" created by extending array prototype\r\n            if (key === \"length\") continue;\r\n            if (!isNaN(+key)) ret.push(classes[key]);\r\n            // not else, if a class is named like a number it can be accessed by name until is overwrite by index being reached.\r\n            if (!ret[key]) ret[key] = classes[key];\r\n        }\r\n    }\r\n\r\n    private static prefix = 'ULibrary_';\r\n    private static clipboardinput: HTMLInputElement;\r\n    static async clipboardCopy<T>(text: string, onSuccess?:()=>T, onFailure?:()=>T): Promise<T | undefined> {\r\n        let ret: boolean = false;\r\n        return navigator.clipboard.writeText(text).then(() => {\r\n            ret = true;\r\n            if (onSuccess) return onSuccess();\r\n        },() => {\r\n            ret = U.clipboardCopy_old(text);\r\n            return ret ? onSuccess && onSuccess() : onFailure && onFailure();\r\n        });\r\n    }\r\n    static clipboardCopy_old(text: string): boolean {\r\n        try{\r\n        if (!U.clipboardinput) {\r\n            U.clipboardinput = document.createElement('input');\r\n            U.clipboardinput.id = U.prefix + 'CopyDataToClipboard';\r\n            U.clipboardinput.type = 'text';\r\n            U.clipboardinput.style.display = 'block';\r\n            U.clipboardinput.style.position = 'absolute';\r\n            U.clipboardinput.style.top = '-100vh'; }\r\n        document.body.appendChild(U.clipboardinput);\r\n        U.clipboardinput.value = text;\r\n        U.clipboardinput.select();\r\n        if (!document.execCommand) return false;\r\n        let ret = document.execCommand('copy');\r\n        document.body.removeChild(U.clipboardinput);\r\n        U.clearSelection();\r\n        return ret;\r\n        }\r\n        catch(e){ return false; }\r\n    }\r\n\r\n    static clearSelection() {}\r\n\r\n    static isError(obj: unknown): obj is Error{\r\n        // obj istanceof Error // this is not iframe-safe, Errors from different iframes are considered different instances\r\n        // this is iframe-safe and catches all error types\r\n        return Object.prototype.toString.call(obj) === \"[object Error]\";\r\n        // or err.toString --> \"Error: message\" dunno if stack is printed too i tested with a fake error.\r\n    }\r\n\r\n    static toNamedArray<D extends DPointerTargetable, L extends LPointerTargetable>(larr:L[], darr?:D[]): L[] & Dictionary<DocString<\"$name\">, L>{\r\n        if (!darr || darr.length !== larr.length) darr = larr.map(l=>l.__raw as D);\r\n\r\n        for (let i = 0; i < larr.length; i++) if (darr[i] && larr[i]) (larr as GObject)[\"$\"+(darr[i] as GObject).name] = larr[i];\r\n        /*for (let index of Object.getOwnPropertyNames(larr)) { // ownPropertyNames skips \"first, last, separator\" created by extending array prototype\r\n            if (index === \"length\") continue;\r\n            let d = darr[index as any as number];\r\n            let l = larr[index as any as number];\r\n            if (!d || !l) continue;\r\n            (larr as any)[\"$\" + (d as any).name] = l;\r\n        }*/\r\n        return larr as any;\r\n    }\r\n    public static isDPointerTargetable(e: any): e is (DPointerTargetable | LPointerTargetable){\r\n        return e && (e.__isProxy || (e.className && e.id && e.pointedBy && e._state));\r\n    }\r\n    public static arrayCount<T extends any>(arr: T[], find: T | ((e:T)=>boolean)): number{\r\n        if (typeof find === \"function\") return arr.reduce((total,x) => total+( (find as any as ((a:any)=>boolean) )(x) ? 1:0), 0);\r\n        return arr.reduce((total,x) => total+(x===find?1:0), 0);\r\n    }\r\n    /*public static cropDObject(o: any): GObject{\r\n        if (!o) return o as any;\r\n        let d: any & Partial<DPointerTargetable> = {...(o.__raw || o)};\r\n        // delete d.pointedBy;\r\n        // defaultValue, instanceClassName, isPrimitive, partialdefault_ame, _storePath, _su_maps, OCL__EEDS_RECALCULATIO_, compiled_css, css, cssISGlo_al, isValidatio_, oclUpdateCo_ditio_, everythimg empty str or 0 or empty arr or empty ovj, palette,\r\n\r\n        // remove all falsy properties, just knowing they are not there i know they are falsy, save space.\r\n        for (let k in o){\r\n            let v = o[k];\r\n            //  v === \"\" || v === null || v === undefined\r\n            if (!v || U.isEmptyObject(v) || Array.isArray(v) || v.lemgth === 0) delete o[k];\r\n        }\r\n        return d;\r\n    }*/\r\n\r\n    public static cropDeepObject(o: any, lines_start_crop: number=20, lines_end_crop: number=10, string_start_crop: number=45, string_end_crop: number=35, num_digit_crop: number=5): any{\r\n        if (!o) return o;\r\n        let replacer = (key: string | number | undefined, o: GObject, depth: number) => {\r\n            switch(key) {\r\n                case \"props\": return \"[_props_]\";\r\n            }\r\n            switch (typeof o) {\r\n                default: return o;\r\n                case \"string\":\r\n                    return U.cropStr(o, lines_start_crop, lines_end_crop, string_start_crop, string_end_crop);\r\n                case \"function\":\r\n                    return U.cropStr(o.toString(), lines_start_crop, lines_end_crop, string_start_crop, string_end_crop);\r\n                case \"number\":\r\n                    return U.cropNum(o, num_digit_crop);\r\n                case \"object\":\r\n                    if (o === null) return null;\r\n                    if (U.isHtmlNode(o)) return '[HTMLElement]';\r\n                    if (isValidElement(o)) return '[ReactElement]';\r\n                    // because native Error properties are not iterable. need to take them out manually.\r\n                    if (U.isError(o)) return {...o, message:o.message, stack:o.stack};\r\n                    /*if (Array.isArray(o)) {\r\n                        let delements = U.arrayCount(o, U.isDPointerTargetable);\r\n                        if (delements > 0){\r\n                            o = o.map(e=>(U.isDPointerTargetable(e) ? U.cropDObject(o) : e));\r\n                        }\r\n                    }*/\r\n                    if (U.isDPointerTargetable(o)) {\r\n                        if (depth >= 5) return o.id;\r\n                        // if (depth >= 2) return U.cropDObject(o);\r\n                        else o = (o as LPointerTargetable).__raw || o;\r\n                    }\r\n                    if (o.className === 'IPoint') return {x:o.x, y:o.y};\r\n                    if (o.className === 'ISize') return {x:o.x, y:o.y, w:o.w, h:o.h};\r\n\r\n                    // remove all falsy properties, just knowing they are not there i know they are falsy, save space.\r\n                    let isArr = Array.isArray(o);\r\n                    o = isArr ? [...(o as any[])] : {...o};\r\n                    for (let k in o) {\r\n                        let v = o[k];\r\n                        /*if (isArr) switch(k){ default: break;\r\n                            case 'contains': case 'joinOriginal': case 'first': case 'last': case 'separator': delete o[k]; continue;\r\n                        }*/\r\n                        //  v === \"\" || v === null || v === undefined\r\n                        if (!v || U.isEmptyObject(v) || (Array.isArray(v) && v.length === 0)) delete o[k];\r\n                    }\r\n                    // if (U.isDate(o)) return \"[Date \"+o.getTime()+\"]\";\r\n                    return o;\r\n            }\r\n        }\r\n        return U.deepReplace(o, replacer);\r\n    }\r\n\r\n    static deepCopy(obj: any, circularReferenceValue?: any | ((obj_alreadymet: GObject)=>any)): any {\r\n        return U.deepReplace(obj, undefined, circularReferenceValue);\r\n    }\r\n\r\n    // does make a deep copy too.\r\n    static deepReplace(obj: any, replacer?: ((key: undefined | string | number, o: any, depth: number) => any),\r\n                       circularReferenceValue: any | ((obj_alreadymet: GObject)=>any) = (o: GObject)=>((o.__raw || o).id || '_circular_ref_')): any {\r\n\r\n        const avoidloop: WeakMap<any, true> = new WeakMap();\r\n        return U.deepReplace_rec(obj, avoidloop, replacer, circularReferenceValue);\r\n    }\r\n\r\n    /**\r\n     replacing always preserves same reference statuses. eg, when  {a:\"x\", b:\"x\"} -> {a:\"y\", b:\"y\"}\r\n     if the original x,y values are the same reference (not just value),\r\n     in the output object a,b will also be the same reference (replacer will not be called twice on the same string)\r\n\r\n     note that let arr = [\"a\", \"a\"] is an array with 2 equal values but different references.\r\n     while let a = \"a\"; let arr = [a, a] have equal references.\r\n\r\n     circularReferenceValue === \"__preserve\" causes any duplicate reference causing a loop to be replaced\r\n     with the target of the first reference instead of the \"__preserve\" string.\r\n\r\n     todo: add parameter eagerLoopReturn (current behaviour is eagerLoopReturn = true)\r\n     eagerLoopReturn = true returns as soon a duplicate objects is found, the returned structure is guaranteed to not have duplicates. [a,a] => [a,'loop','loop']\r\n     eagerLoopReturn = false returns 'loop' only if an object is already found AND have subobjects.\r\n     let a = {id:\"a1\", l:{b:1}};    [a,a] --> [{id:\"a1\", l:{b:1}, {id:\"a1\", l:'_loop_']\r\n     finaly eagerLoopReturn = 'inline' replaces with '_loop_' only when there is really a circular ref\r\n     (found an object already found in the current \"path\" from root to current obj)\r\n     so i need to copy the current map and pass a new copy every time i go deep on a new subobject, branching a tree.\r\n     let a = {id:\"a1\", l:{b:1}};    [a,a] will still return [a,a] with no '_loop_' tags\r\n     instead let a = {l:{b:1}, a:a};    [a,a] will return [{l:{b:1}, a:'_loop_'}, {l:{b:1}, a:'_loop_'}] with no '_loop_' tags\r\n     while\r\n     */\r\n    static deepReplace_rec(obj: any, avoidloop: GObject & WeakMap<any, true>, replacer?: ((key: undefined | string | number, o: any, depth: number) => any),\r\n                           circularReferenceValue?: any | ((obj_alreadymet: GObject)=>any), key?: number | string, curdept:number=0, eagerLoopReturn: boolean = false): any {\r\n        if (typeof obj === \"symbol\") return replacer ? replacer(key, obj, curdept) : obj;\r\n\r\n        let old_obj = obj;\r\n        switch (typeof old_obj) {\r\n            case \"symbol\": // don't know what really do with symbols and funcs\r\n            case \"function\":\r\n                break;\r\n            default: // because primitive types cannot be used as WeakMap.set(key), but can as Object keys\r\n                if (obj in avoidloop) return avoidloop[obj];\r\n                else avoidloop[old_obj] = obj;\r\n                break;\r\n            case \"object\":\r\n                if (old_obj === null) {\r\n                    if (avoidloop[old_obj]) return avoidloop[old_obj];\r\n                    else avoidloop[old_obj] = obj;\r\n                    break;\r\n                }\r\n                if (avoidloop.has(obj)) { // for objects\r\n                    if (Array.isArray(obj) && obj.length === 0 || Object.keys(obj).length === 0) return obj;\r\n\r\n                    if (circularReferenceValue === \"__preserve\" || typeof obj !== \"object\") return avoidloop.get(obj);\r\n                    else return typeof circularReferenceValue === \"function\" ? circularReferenceValue(obj) : circularReferenceValue;\r\n                } else avoidloop.set(old_obj, obj);\r\n                break;\r\n        }\r\n\r\n\r\n        if (replacer) obj = replacer(key, obj, curdept);\r\n        switch (typeof obj){\r\n            default: break; // obj = obj; return obj; // for any leaf type\r\n            case \"object\":\r\n                if (U.isHtmlNode(obj)) return obj;\r\n                if (isValidElement(obj)) return obj;\r\n                if (U.isError(obj)) return obj;\r\n                if (Array.isArray(obj)) {\r\n                    obj = obj.map((o, i) => U.deepReplace_rec(o, avoidloop, replacer, circularReferenceValue, i,curdept+1));\r\n                    break;\r\n                }\r\n                let o: GObject = {};\r\n                for (let k in obj) {\r\n                    o[k] = U.deepReplace_rec(obj[k], avoidloop, replacer, circularReferenceValue, k, curdept+1);\r\n                }\r\n                obj = o;\r\n                break;\r\n        }\r\n\r\n        return obj;\r\n    }\r\n\r\n\r\n\r\n    // returns path to that object to find\r\n    public static deepFindInObject(obj: any, subobject: any, compareFunc?:(a:any,b:any)=>boolean, maxDepth: number = Number.POSITIVE_INFINITY): string | undefined {\r\n        const avoidloop: WeakMap<any, true> = new WeakMap();\r\n        let ret = U.deepFindInObject_rec(obj, subobject, avoidloop, maxDepth, compareFunc);\r\n        if (ret === '') return 'this';\r\n        else return ret;\r\n    }\r\n    private static deepFindInObject_rec(obj: any, subobject: any, avoidloop: GObject & WeakMap<any, true>, maxDepth: number, compareFunc?:((a:any,b:any)=>boolean), curdepth:number=0): string | undefined {\r\n        if (compareFunc ? compareFunc(obj, subobject) : obj === subobject) return ''\r\n        if (curdepth >= maxDepth) return undefined;\r\n\r\n        let old_obj = obj;\r\n        switch (typeof old_obj) {\r\n            default: return undefined;\r\n            case \"object\":\r\n                if (old_obj === null) return undefined;\r\n                if (avoidloop.has(obj)) { // for objects\r\n                    return undefined;\r\n                } else avoidloop.set(old_obj, obj);\r\n                break;\r\n        }\r\n\r\n        switch (typeof obj){\r\n            default: return undefined;\r\n            case \"object\":\r\n                if (U.isHtmlNode(obj)) return undefined;\r\n                if (isValidElement(obj)) return undefined; // ReactElement\r\n                if (U.isError(obj)) return undefined;\r\n\r\n                if (Array.isArray(obj)) {\r\n                    for (let i = 0; i < obj.length; i++) {\r\n                        let found = U.deepFindInObject_rec(obj[i], subobject, avoidloop, maxDepth, compareFunc, curdepth+1);\r\n                        if (found === '') return i+'';\r\n                        else if (found !== undefined) return i+'.'+found;\r\n                    }\r\n                    return undefined;\r\n                }\r\n                for (let k in obj) {\r\n                    let found = U.deepFindInObject_rec(obj[k], subobject, avoidloop, maxDepth, compareFunc, curdepth+1);\r\n                    if (found === '') return k+'';\r\n                    if (found !== undefined) return k+'.'+found;\r\n                }\r\n                return undefined;\r\n        }\r\n        return undefined;\r\n    }\r\n\r\n\r\n    public static mailerror(recipients: string[], title: string, msgbody_notencoded: string, canUseClipboard: boolean, clipboardSuccess?: ()=>any, clipboardFailure?: ()=>any) {\r\n\r\n        const msgbody: string = encodeURIComponent(msgbody_notencoded);\r\n        const mailtitle: string =  encodeURIComponent(title);\r\n        // \"mailto:no-one@snai1mai1.com?subject=look at this website&body=Hi,I found this website and thought you might like it http://www.geocities.com/wowhtml\"\r\n        const gitissue = \"https://github.com/MDEGroup/jjodel/issues/new?title=\"+mailtitle+\"&body=\"+msgbody;\r\n        let mailto: string | undefined = \"mailto:\"+recipients.join(';')+\"?subject=\"+mailtitle+\"&body=\"+msgbody;\r\n        const mailtolimit = 2042 - 23/*for safety*/;\r\n        /*\r\n            git uri limit: the requests start failing at exactly 8202 characters.\r\n\r\n            mailto: limits\r\n            2042 characters on Chrome 64.0.3282.186\r\n            2046 characters on Edge 16.16299\r\n            approximately 32700 characters on Firefox 58.0\r\n\r\n            max URI lengths:\r\n            chrome: 15613 chars\r\n            firefox: 15708\r\n        */\r\n        if (mailto.length > mailtolimit){\r\n            if (canUseClipboard) {\r\n                const mailfallback = encodeURIComponent(\"mail body exceeded maximum mailto: link length.\\n\" +\r\n                    \"It has been copied to your clipboard, please past it here or use github issue report.\");\r\n                U.clipboardCopy(msgbody_notencoded, clipboardSuccess, clipboardFailure);\r\n                mailto =  \"mailto:\"+recipients.join(';')+\"?subject=\"+mailtitle+\"&body=\" + mailfallback;\r\n            }\r\n            else mailto = undefined;\r\n        }\r\n        return {gitissue, mailto};\r\n    }\r\n\r\n\r\n\r\n    // NB: does not owrk if there is an overflow of pos:absolute elements needs to be updated before use.\r\n    public static findOverflowingNodes_broken(element : Element) : {element: Element, overflowingFrom: string }[] {\r\n        if (!element) return [];\r\n        // type Direction = {v: number, e: Element};\r\n        // const biggestChilds: Partial<{[k: keyof DOMRect]: {v: number, e: Element}}> = {};\r\n        //const biggestChilds: Partial<{[k: keyof DOMRectReadOnly]: {v: number, e: Element}}> = {};\r\n        const biggestChilds: Record<keyof DOMRectReadOnly, {v: number, e: Element}> = {} as any;\r\n        let childarr: {element: Element, size: DOMRect}[] = [];\r\n        let ret: {element: Element, overflowingFrom: string }[] = [];\r\n        while (element) {\r\n            const size = element.getBoundingClientRect();\r\n            childarr.push({element, size});\r\n            let k: keyof DOMRectReadOnly;\r\n            for (k in size) {\r\n                let v = size[k] as number;\r\n                if (!biggestChilds[k] || v > biggestChilds[k].v) biggestChilds[k] = {e: element, v};\r\n            }\r\n            if (childarr.length <= 1) continue;\r\n            let {element: child, size: childSize} = childarr[childarr.length -1];\r\n\r\n            for (k in size) {\r\n                let v = size[k];\r\n                if (childSize[k] > v) ret.push({element, overflowingFrom:k});\r\n            }\r\n            element = element.parentElement as Element;\r\n        }\r\n        return ret;\r\n    }\r\n/*\r\n    public static makeDraggable(e: HTMLElement, v: LViewElement, n: LGraphElement, type: \"draggable\" | \"resizable\" | \"rotatable\" = \"draggable\"): boolean {\r\n        let draggableOptions: string = e.dataset[type];\r\n        let disabled = !!e.attributes.disabled;\r\n\r\n        let options: GObject;\r\n        switch (typeof draggableOptions){\r\n            case \"string\":\r\n                try{ options = JSON.parse(draggableOptions); }\r\n                catch(e) { Log.ee(\"JSX error in \" + type + \", cannot parse options. Make sure they are a valid JSON object in string format.\"); return false; }\r\n                break;\r\n            case \"object\": options = draggableOptions; break;\r\n            default: Log.ee(\"JSX error in \" + type + \", unexpected type of options, only strings and objects are allowed, found instead: \" + typeof draggableOptions); return false;\r\n        }\r\n\r\n        let $measurable: GObject<'JQuery + ui plugin'> = $(e);\r\n        if (disabled && $measurable.data(\"uiDraggable\")) { $measurable.draggable('disable'); return false; }\r\n        if ($measurable.data(\"uiDraggable\")) $measurable.draggable('enable');\r\n        // todo: change options, put disable then remove disable attr and check if changing options at runtime works\r\n\r\n        let defaultoptions = {\r\n            cursor: 'grabbing',\r\n            // containment: 'parent',\r\n            opacity: 0.0,\r\n            distance: 5,\r\n            helper: 'clone', // 'original' or 'csselector'? or func=>html\r\n            // disabled: !(view.draggable),\r\n            drag: (event: GObject, obj: GObject) => {\r\n                TRANSACTION(()=>{\r\n                    if (!this.props.view.lazySizeUpdate) this.setSize({x:obj.position.left, y:obj.position.top});\r\n                    for (let vid of allviews) this.doMeasurableEvent(EMeasurableEvents.whileDragging, vid);\r\n                })\r\n            },\r\n            stop: (event: GObject, obj: GObject) => {\r\n                TRANSACTION(()=>{\r\n                    this.setSize({x:obj.position.left, y:obj.position.top});\r\n                    for (let vid of allviews) this.doMeasurableEvent(EMeasurableEvents.onDragEnd, vid);\r\n                })\r\n            }\r\n        };\r\n\r\n        let aval: string;\r\n        let eventmap = {\r\n            's':    {'draggable': 'onDragStart',    'rotatable': 'onRotateStart',   'resizable': 'onResizeStart'},\r\n            'ing':  {'draggable': 'whileDragging',  'rotatable': 'whileRotating',   'resizable': 'whileResizing'},\r\n            'e':    {'draggable': 'onDragEnd',      'rotatable': 'onRotateEnd',     'resizable': 'onResizeEnd'  },\r\n        }\r\n        let event = {'s': eventmap.s[type], 'ing': eventmap.ing[type], 'e': eventmap.e[type]};\r\n        let jqui_ing: string;\r\n        switch (type){\r\n            default: jqui_ing = Log.eDevv(\"unexpected measurable event: \" + type); return false;\r\n            case \"draggable\": jqui_ing = 'drag'; break;\r\n            case \"resizable\": jqui_ing = 'resize'; break;\r\n            case \"rotatable\": jqui_ing = 'rotate'; break;\r\n        }\r\n        let jquievent = {'s': 'start', 'ing': jqui_ing, 'e':'end'};\r\n        for (let evtkey in jquievent) {\r\n            // @ts-ignore\r\n            aval = e.attributes[event[evtkey]]?.value || '';\r\n            if (aval) defaultoptions[jquievent[evtkey]] = (event: GObject, obj: GObject) => {\r\n                // jqui event callback\r\n                // 1) call html-defined events (onDragStart=\"my_custom_event_name\")\r\n                // todo: currently only support jqui default parameters, not custom ones. make an eval and allow using stuff like whileDragging=\"(coords)=>myevent(coords, 1,2,3)\"\r\n                v.events[aval](event, obj);\r\n                let evt = options[evtkey];\r\n                delete options[evtkey];\r\n                switch(evt){\r\n                    case \"string\": v.events[evt]?.(event, obj);break;\r\n                    case \"function\": evt(); break;\r\n                    default: break;\r\n                }\r\n            }\r\n            U.objectMergeInPlace(options, defaultoptions);\r\n            $measurable[type](options);\r\n        }\r\n\r\n        return true;\r\n    }\r\n*/\r\n\r\n    static getOSBrowserData(){\r\n        /**\r\n         * JavaScript Client Detection\r\n         * (C) viazenetti GmbH (Christian Ludwig)\r\n         */\r\n        /** source: https://stackoverflow.com/a/18706818/24978590\r\n         author comment:\r\n         I started to write a Script to read OS and browser version that can be tested on Fiddle.\r\n         Feel free to use and extend.\r\n        */\r\n        var unknown = '-';\r\n\r\n        // screen\r\n        var screenSize = '';\r\n        let screen = window.screen;\r\n        if (screen?.width) {\r\n            let width = (screen.width) ? screen.width : '';\r\n            let height = (screen.height) ? screen.height : '';\r\n            screenSize += '' + width + \" x \" + height;\r\n        }\r\n\r\n        // browser\r\n        var nVer = navigator?.appVersion || '';\r\n        var nAgt = navigator?.userAgent || '';\r\n        var browser = navigator?.appName || '';\r\n        var version = '' + parseFloat(nVer);\r\n        var nameOffset, verOffset, ix;\r\n\r\n        // Yandex Browser\r\n        if ((verOffset = nAgt.indexOf('YaBrowser')) != -1) {\r\n            browser = 'Yandex';\r\n            version = nAgt.substring(verOffset + 10);\r\n        }\r\n        // Samsung Browser\r\n        else if ((verOffset = nAgt.indexOf('SamsungBrowser')) != -1) {\r\n            browser = 'Samsung';\r\n            version = nAgt.substring(verOffset + 15);\r\n        }\r\n        // UC Browser\r\n        else if ((verOffset = nAgt.indexOf('UCBrowser')) != -1) {\r\n            browser = 'UC Browser';\r\n            version = nAgt.substring(verOffset + 10);\r\n        }\r\n        // Opera Next\r\n        else if ((verOffset = nAgt.indexOf('OPR')) != -1) {\r\n            browser = 'Opera';\r\n            version = nAgt.substring(verOffset + 4);\r\n        }\r\n        // Opera\r\n        else if ((verOffset = nAgt.indexOf('Opera')) != -1) {\r\n            browser = 'Opera';\r\n            version = nAgt.substring(verOffset + 6);\r\n            if ((verOffset = nAgt.indexOf('Version')) != -1) {\r\n                version = nAgt.substring(verOffset + 8);\r\n            }\r\n        }\r\n        // Legacy Edge\r\n        else if ((verOffset = nAgt.indexOf('Edge')) != -1) {\r\n            browser = 'Microsoft Legacy Edge';\r\n            version = nAgt.substring(verOffset + 5);\r\n        }\r\n        // Edge (Chromium)\r\n        else if ((verOffset = nAgt.indexOf('Edg')) != -1) {\r\n            browser = 'Microsoft Edge';\r\n            version = nAgt.substring(verOffset + 4);\r\n        }\r\n        // MSIE\r\n        else if ((verOffset = nAgt.indexOf('MSIE')) != -1) {\r\n            browser = 'Microsoft Internet Explorer';\r\n            version = nAgt.substring(verOffset + 5);\r\n        }\r\n        // Chrome\r\n        else if ((verOffset = nAgt.indexOf('Chrome')) != -1) {\r\n            browser = 'Chrome';\r\n            version = nAgt.substring(verOffset + 7);\r\n        }\r\n        // Safari\r\n        else if ((verOffset = nAgt.indexOf('Safari')) != -1) {\r\n            browser = 'Safari';\r\n            version = nAgt.substring(verOffset + 7);\r\n            if ((verOffset = nAgt.indexOf('Version')) != -1) {\r\n                version = nAgt.substring(verOffset + 8);\r\n            }\r\n        }\r\n        // Firefox\r\n        else if ((verOffset = nAgt.indexOf('Firefox')) != -1) {\r\n            browser = 'Firefox';\r\n            version = nAgt.substring(verOffset + 8);\r\n        }\r\n        // MSIE 11+\r\n        else if (nAgt.indexOf('Trident/') != -1) {\r\n            browser = 'Microsoft Internet Explorer';\r\n            version = nAgt.substring(nAgt.indexOf('rv:') + 3);\r\n        }\r\n        // Other browsers\r\n        else if ((nameOffset = nAgt.lastIndexOf(' ') + 1) < (verOffset = nAgt.lastIndexOf('/'))) {\r\n            browser = nAgt.substring(nameOffset, verOffset);\r\n            version = nAgt.substring(verOffset + 1);\r\n            if (browser.toLowerCase() == browser.toUpperCase()) {\r\n                browser = navigator?.appName;\r\n            }\r\n        }\r\n        // trim the version string\r\n        if ((ix = version.indexOf(';')) != -1) version = version.substring(0, ix);\r\n        if ((ix = version.indexOf(' ')) != -1) version = version.substring(0, ix);\r\n        if ((ix = version.indexOf(')')) != -1) version = version.substring(0, ix);\r\n\r\n        let majorVersion = parseInt('' + version, 10);\r\n        if (isNaN(majorVersion)) {\r\n            version = '' + parseFloat(nVer);\r\n            majorVersion = parseInt(nVer, 10);\r\n        }\r\n\r\n        // mobile version\r\n        var mobile = /Mobile|mini|Fennec|Android|iP(ad|od|hone)/.test(nVer);\r\n\r\n        // cookie\r\n        var cookieEnabled = (navigator?.cookieEnabled) ? true : false;\r\n\r\n        if (typeof navigator?.cookieEnabled === 'undefined' && !cookieEnabled) {\r\n            document.cookie = 'testcookie';\r\n            cookieEnabled = document.cookie.indexOf('testcookie') !== -1;\r\n        }\r\n\r\n        // system\r\n        var clientStrings = [\r\n            {s:'Windows 10', r:/(Windows 10.0|Windows NT 10.0)/},\r\n            {s:'Windows 8.1', r:/(Windows 8.1|Windows NT 6.3)/},\r\n            {s:'Windows 8', r:/(Windows 8|Windows NT 6.2)/},\r\n            {s:'Windows 7', r:/(Windows 7|Windows NT 6.1)/},\r\n            {s:'Windows Vista', r:/Windows NT 6.0/},\r\n            {s:'Windows Server 2003', r:/Windows NT 5.2/},\r\n            {s:'Windows XP', r:/(Windows NT 5.1|Windows XP)/},\r\n            {s:'Windows 2000', r:/(Windows NT 5.0|Windows 2000)/},\r\n            {s:'Windows ME', r:/(Win 9x 4.90|Windows ME)/},\r\n            {s:'Windows 98', r:/(Windows 98|Win98)/},\r\n            {s:'Windows 95', r:/(Windows 95|Win95|Windows_95)/},\r\n            {s:'Windows NT 4.0', r:/(Windows NT 4.0|WinNT4.0|WinNT|Windows NT)/},\r\n            {s:'Windows CE', r:/Windows CE/},\r\n            {s:'Windows 3.11', r:/Win16/},\r\n            {s:'Android', r:/Android/},\r\n            {s:'Open BSD', r:/OpenBSD/},\r\n            {s:'Sun OS', r:/SunOS/},\r\n            {s:'Chrome OS', r:/CrOS/},\r\n            {s:'Linux', r:/(Linux|X11(?!.*CrOS))/},\r\n            {s:'iOS', r:/(iPhone|iPad|iPod)/},\r\n            {s:'Mac OS X', r:/Mac OS X/},\r\n            {s:'Mac OS', r:/(Mac OS|MacPPC|MacIntel|Mac_PowerPC|Macintosh)/},\r\n            {s:'QNX', r:/QNX/},\r\n            {s:'UNIX', r:/UNIX/},\r\n            {s:'BeOS', r:/BeOS/},\r\n            {s:'OS/2', r:/OS\\/2/},\r\n            {s:'Search Bot', r:/(nuhk|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask Jeeves\\/Teoma|ia_archiver)/}\r\n        ];\r\n        var os = unknown;\r\n        for (var id in clientStrings) {\r\n            var cs = clientStrings[id];\r\n            if (cs.r.test(nAgt)) {\r\n                os = cs.s;\r\n                break;\r\n            }\r\n        }\r\n        if (os === unknown){\r\n            let s = nAgt.toLowerCase();\r\n            if (s.indexOf('windows')) os = 'Windows';\r\n            if (s.indexOf('mac')) os = 'Mac OS';\r\n        }\r\n\r\n        var osVersion = unknown;\r\n\r\n        if (/Windows/.test(os)) {\r\n            osVersion = /Windows (.*)/.exec(os)?.[1] || 'unknown';\r\n            os = 'Windows';\r\n        }\r\n\r\n        switch (os) {\r\n            case 'Mac OS':\r\n            case 'Mac OS X':\r\n            case 'Android':\r\n                osVersion = /(?:Android|Mac OS|Mac OS X|MacPPC|MacIntel|Mac_PowerPC|Macintosh) ([\\.\\_\\d]+)/.exec(nAgt)?.[1] || 'unknown';\r\n                break;\r\n\r\n            case 'iOS':\r\n                let match = /OS (\\d+)_(\\d+)_?(\\d+)?/.exec(nVer);\r\n                if (match) osVersion = match[1] + '.' + match[2] + '.' + (match[3] || 0);\r\n                else osVersion = 'unknown';\r\n                break;\r\n        }\r\n\r\n        return {\r\n            screen: screenSize,\r\n            browser: browser,\r\n            browserVersion: version,\r\n            browserMajorVersion: majorVersion,\r\n            mobile: mobile,\r\n            os: os,\r\n            osVersion: osVersion,\r\n            cookies: cookieEnabled,\r\n            userAgent: navigator.userAgent,\r\n        };\r\n    }\r\n\r\n    // warning: nodes from other iframes will say are not instance from Element of the current frame, in that case need duck typing.\r\n    public static isHtmlNode(element: any): element is Element {\r\n        return element instanceof Element || element instanceof HTMLDocument || element instanceof SVGElement;\r\n    }\r\n\r\n    private static objectIncludeKeys(obj1: GObject, ...keys: string[]): boolean {\r\n        for (let k of keys) if (!(k in obj1)) return false;\r\n        return true;\r\n    }\r\n\r\n    static removeFromDom(e: Node): boolean {\r\n        let p = e.parentNode;\r\n        if (!p) return false;\r\n        p.removeChild(e);\r\n        return true;\r\n    }\r\n\r\n    static findInChildProperties<T extends D|L>(initialArr: (T)[], getChildrens: ((e:T) => (T)[]),\r\n                                                getID:((e:T)=>PrimitiveType)|undefined, returnWhenFound:((e:T)=>boolean), filter?:((e:T)=>boolean)): (T) {\r\n        return U.iterateChildProperties(initialArr, getChildrens, getID, returnWhenFound, filter)[0];\r\n    }\r\n    static iterateChildProperties<T extends D|L>(initialArr: (T)[], getChildrens: ((e:T) => (T)[]),\r\n                                                 getID?:((e:T)=>PrimitiveType), returnWhenFound?:((e:T)=>boolean), filter?:((e:T)=>boolean)): (T)[] {\r\n        let targets = initialArr;\r\n        let alreadyParsed: Dictionary<string|number, (T)> = {};\r\n        /*if (includeSelf) {\r\n            for (let t of targets) {\r\n                includeSelf\r\n            }\r\n        }*/\r\n        while (targets.length) {\r\n            let nextTargets: (T)[] = [];\r\n            for (let target of targets) {\r\n                if (!target) continue;\r\n                let tid = (getID ? getID(target) : (target?.id)) as any as (string | number);\r\n                if (alreadyParsed[tid]) continue;\r\n                if (filter && !filter(target)) continue;\r\n                alreadyParsed[tid] = target;\r\n                if (returnWhenFound && returnWhenFound(target)) return [target];\r\n                U.arrayMergeInPlace(nextTargets, getChildrens(target));\r\n            }\r\n            targets = nextTargets;\r\n        }\r\n        return Object.values(alreadyParsed);\r\n\r\n    }\r\n\r\n    static categorizeNode(c: LGraphElement|DGraphElement): {vertex: boolean, purevertex:boolean, field: boolean, graphvertex:boolean, puregraph: boolean, graph: boolean, edge:boolean, edgepoint: boolean}{\r\n        let ret = {} as any;\r\n        if (!c) return ret;\r\n        switch (c.className) {\r\n            case 'DEdge':\r\n            case 'DVoidEdge': ret.edge = true; break;\r\n            case 'DEdgePoint': ret.vertex = ret.edgepoint = true; ret.purevertex = false; break;\r\n            case 'DVertex':\r\n            case 'DVoidVertex': ret.vertex = ret.purevertex = true; break;\r\n            case 'DGraphVertex': ret.graph = true; ret.puregraph = ret.purevertex = false; break;\r\n            case 'DGraph': ret.graph = ret.puregraph = true; break;\r\n            case 'DGraphElement': ret.field = true; break;\r\n            default: Log.ee('unexpected node type:'+c.className); break;\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    // returns: isFullscreen\r\n    static toggleFullscreen(elem: HTMLElement): boolean {\r\n        if (U.fullscreenElement() === elem) { U.exitFullscreen(); return false; }\r\n        else { U.fullscreen(elem); return true; }\r\n    }\r\n\r\n    static fullscreen(elem: HTMLElement): Promise<void> {\r\n        // Find the right method, call on correct element\r\n        let e: any = elem;\r\n        if (e.requestFullscreen) return e.requestFullscreen();\r\n        if (e.mozRequestFullScreen) return e.mozRequestFullScreen();\r\n        if (e.webkitRequestFullscreen) return e.webkitRequestFullscreen();\r\n        if (e.msRequestFullscreen) return e.msRequestFullscreen();\r\n        return Promise.reject('unsupported');\r\n\r\n    }\r\n    static isFullscreen(): boolean {\r\n        let d: any = window.document;\r\n        return d.fullscreenEnabled || d.mozFullScreenEnabled || d.webkitFullscreenEnabled;\r\n    }\r\n    static fullscreenElement(): Element {\r\n        let d: any = window.document;\r\n        return d.fullscreenElement || d.mozFullScreenElement || d.webkitFullscreenElement;\r\n    }\r\n\r\n    static exitFullscreen(): Promise<void> {\r\n        let d: any = window.document;\r\n        if (d.exitFullscreen) return d.exitFullscreen();\r\n        if (d.mozCancelFullScreen) return d.mozCancelFullScreen();\r\n        if (d.webkitExitFullscreen) return d.webkitExitFullscreen();\r\n        return Promise.reject('unsupported');\r\n    }\r\n\r\n    static flattenObjectByKey<T extends GObject>(arr: (T|null|undefined)[], childKey: string):T[] {\r\n        let isArray = Array.isArray(arr);\r\n        if (!isArray) arr = [arr] as any;\r\n        let ret: T[] = [...arr as any];\r\n        for (let e of ret) {\r\n            let children = (e as any)?.[childKey];\r\n            if (!children || children.length === 0) continue;\r\n            U.arrayMergeInPlace(ret, U.flattenObjectByKey(children, childKey));\r\n        }\r\n        return ret;\r\n    }\r\n}\r\nexport class DDate{\r\n    static cname: string = \"DDate\";\r\n\r\n    public static addDay(date: Date, offset: number, inplace: boolean): Date {\r\n        const ret: Date = inplace ? date : new Date(date);\r\n        ret.setDate(date.getDate() + offset);\r\n        return ret;\r\n    }\r\n    public static addMonth(date: Date, offset: number, inplace: boolean): Date {\r\n        const ret: Date = inplace ? date : new Date(date);\r\n        ret.setMonth(date.getMonth() + offset);\r\n        return ret;\r\n    }\r\n    public static addYear(date: Date, offset: number, inplace: boolean): Date {\r\n        const ret: Date = inplace ? date : new Date(date);\r\n        ret.setFullYear(date.getFullYear() + offset);\r\n        return ret;\r\n    }\r\n}\r\n\r\nexport class myFileReader {\r\n    private static input: HTMLInputElement = null as any;\r\n    private static fileTypes: string[] = null as any;\r\n    private static onchange: (e: Event) => void = null as any;\r\n    // constructor(onchange: (e: ChangeEvent) => void = null, fileTypes: FileReadTypeEnum[] | string[] = null) { myFileReader.setinfos(fileTypes, onchange); }\r\n    private static setinfos(fileTypes: undefined | FileReadTypeEnum[] | string[], onchange: (e: Event, files: FileList | null, contents: string[] | undefined ) => void, readcontent: boolean) {\r\n        myFileReader.fileTypes = (fileTypes || myFileReader.fileTypes) as string[];\r\n        const debug: boolean = false;\r\n        debug&&console.log('fileTypes:', myFileReader.fileTypes, fileTypes);\r\n        myFileReader.input = document.createElement('input');\r\n        const input: HTMLInputElement = myFileReader.input;\r\n        myFileReader.onchange = function (e: Event): void {\r\n            if (!readcontent) { onchange(e, input.files, undefined); return; }\r\n            let contentObj: Dictionary<number, string> = {};\r\n            let fileLetti: number = 0;\r\n            for (let i: number = 0; input.files && i <input.files.length; i++) {\r\n                const f: File = input.files[i];\r\n                debug&&console.log('filereadContent['+i+']( file:', f, ')');\r\n                U.fileReadContent(f, (content: string) => {\r\n                    debug&&console.log('file['+i+'] read complete. done: ' + ( 1 + fileLetti) + ' / ' + input.files?.length, 'contentObj:', contentObj);\r\n                    contentObj[i] = content; // cannot use array, i'm not sure the callbacks will be called in order. using push is safer but could alter order.\r\n                    // this is last file to read.\r\n                    if (input.files && ++fileLetti === input.files.length) {\r\n                        const contentArr: string[] = [];\r\n                        for (let j: number = 0; j < input.files.length; j++) { contentArr.push(contentObj[j]); }\r\n                        onchange(e, input.files, contentArr);\r\n                    }\r\n                });\r\n            }\r\n        } || myFileReader.onchange;\r\n    }\r\n    private static reset(): void {\r\n        myFileReader.fileTypes = undefined as any;\r\n        myFileReader.onchange = undefined as any;\r\n        myFileReader.input = undefined as any;\r\n    }\r\n    public static show(onChange: (e: Event, files: FileList | null, contents?: string[]) => void, extensions: undefined | string[] | FileReadTypeEnum[] = undefined, readContent: boolean): void {\r\n        console.log(\"importEcore: pre file reader\", myFileReader.input);\r\n        myFileReader.setinfos(extensions, onChange, readContent);\r\n        //if (!myFileReader.input) return;\r\n        myFileReader.input.setAttribute('type', 'file');\r\n        if (myFileReader.fileTypes) {\r\n            myFileReader.input.setAttribute('accept', myFileReader.fileTypes.join(','));\r\n        }\r\n        //console.log('fileTypes:', myFileReader.fileTypes, 'input:', myFileReader.input);\r\n        $(myFileReader.input).on('change.custom' as any, myFileReader.onchange).trigger('click');\r\n        myFileReader.reset();\r\n    }\r\n\r\n}\r\n@RuntimeAccessible('Uarr')\r\nexport class Uarr{\r\n\r\n    static arrayShallowCopy<T extends any | undefined | null>(arr: T, includeCustomKeys: boolean = true): T{\r\n        if (!arr) return arr;\r\n        if (!Array.isArray(arr)) return arr;\r\n        let ret: T&any[] = [] as any;\r\n        if (!includeCustomKeys) ret = arr.map(e=>e) as any; // because [...arr] is transforming empty positions in undefined\r\n        else {\r\n            for (let k in arr) {\r\n                if (!(arr as any[]).hasOwnProperty(k)) continue;\r\n                ret[k] = arr[k]; // it takes array custom keys\r\n            }\r\n        }\r\n        ret.length = (arr as any[]).length;\r\n        return ret;\r\n    }\r\n\r\n    public static isSubArray(array: any[], subarray: any[]): boolean {\r\n        return subarray.every((el) => array.includes(el));\r\n    }\r\n\r\n    static arrayDifference<T>(starting: T[], final: T[]): {added: T[], removed: T[], starting: T[], final: T[]} {\r\n        let ret: {added: T[], removed: T[], starting: T[], final: T[]} = {} as any;\r\n        ret.starting = starting;\r\n        ret.final = final;\r\n        if (!starting) starting = [];\r\n        if (!final) final = [];\r\n        ret.removed = Uarr.arraySubtract(starting, final, false); // start & !end\r\n        ret.added = Uarr.arraySubtract(final, starting, false); // end & !start\r\n        return ret;\r\n    }\r\n\r\n    public static arrayIntersection<T>(arr1: T[], arr2: T[]): T[]{\r\n        if (!arr1 || ! arr2) return null as any;\r\n        return arr1.filter( e => arr2.indexOf(e) >= 0);\r\n    }\r\n\r\n    static arraySubtract(arr1: any[], arr2: any[], inPlace: boolean): any[]{\r\n        let i: number;\r\n        const ret: any[] = inPlace ? arr1 : [...arr1];\r\n        for (i = 0; i < arr2.length; i++) { U.arrayRemoveAll(ret, arr2[i]); }\r\n        return ret; }\r\n\r\n    static equals<T extends any>(a1: T[], a2: T[], deep: boolean): boolean {\r\n        Log.ex(deep, \"deep array comparison is not supported yet\");\r\n        if (!a1 || !a2) return false;\r\n        if (a1.length !== a2.length) return false;\r\n        for (let i = 0; i < a1.length; i++) if (a1[i] !== a2[i]) return false;\r\n        return true;\r\n    }\r\n\r\n    static equalsUnsorted(a1: any[], a2: any[]): boolean {\r\n        let diff = Uarr.arrayDifference(a1, a2);\r\n        return (diff.removed.length === 0 && diff.added.length === 0);\r\n    }\r\n}\r\n\r\nexport class FocusHistoryEntry {\r\n    static cname: string = \"FocusHistoryEntry\";\r\n    time: Date;\r\n    evt: JQuery.FocusInEvent;\r\n    element: Element;\r\n    constructor(e: JQuery.FocusInEvent, element?: Element, time?: Date) {\r\n        this.evt = e;\r\n        this.element = element || e.target;\r\n        this.time = time || new Date();\r\n    }\r\n}\r\nexport enum ShortDefaultEClasses{\r\n    EObject = \"EObject\",\r\n    EAnnotation = \"EAnnotation\",\r\n    EClass = \"EClass\",\r\n    EPackage = \"EPackage\",\r\n    ENamedElement = \"ENamedElement\",\r\n}\r\nexport enum ShortAttribETypes {\r\n    EVoid = 'EVoid',\r\n    EChar  = 'EChar',\r\n    EString  = 'EString',\r\n    EDate  = 'EDate',\r\n    EBoolean = 'EBoolean',\r\n    EByte  = 'EByte',\r\n    EShort  = 'EShort',\r\n    EInt  = 'EInt',\r\n    ELong  = 'ELong',\r\n    EFloat  = 'EFloat',\r\n    EDouble  = 'EDouble',\r\n    // EDiagnosticChain = \"EDiagnosticChain\", // present in uml.ecore, without definition. i guess it's a custom installed package which is commonly used\r\n    /*\r\n  ECharObj  = 'ECharObj',\r\n  EStringObj  = 'EStringObj',\r\n  EDateObj  = 'EDateObj',\r\n  EFloatObj  = 'EFloatObj',\r\n  EDoubleObj  = 'EDoubleObj',\r\n  EBooleanObj = 'EBooleanObj',\r\n  EByteObj  = 'EByteObj',\r\n  EShortObj  = 'EShortObj',\r\n  EIntObj  = 'EIntObj',\r\n  ELongObj  = 'ELongObj',\r\n  EELIST  = 'EELIST',*/\r\n\r\n}\r\nwindoww.ShortAttribETypes = ShortAttribETypes;\r\n\r\nexport const ShortAttribSuperTypes: Dictionary<ShortAttribETypes, ShortAttribETypes[]> = {\r\n    \"EVoid\"    : [],\r\n    \"EChar\"    : [ShortAttribETypes.EString],\r\n    \"EString\"  : [],\r\n    \"EDate\"    : [],\r\n    \"EBoolean\" : [ShortAttribETypes.EByte, ShortAttribETypes.EShort, ShortAttribETypes.EInt, ShortAttribETypes.ELong, ShortAttribETypes.EFloat, ShortAttribETypes.EDouble],\r\n    \"EByte\"    : [ShortAttribETypes.EShort, ShortAttribETypes.EInt, ShortAttribETypes.ELong, ShortAttribETypes.EFloat, ShortAttribETypes.EDouble],\r\n    \"EShort\"   : [ShortAttribETypes.EInt, ShortAttribETypes.ELong, ShortAttribETypes.EFloat, ShortAttribETypes.EDouble],\r\n    \"EInt\"     : [ShortAttribETypes.ELong, ShortAttribETypes.EFloat, ShortAttribETypes.EDouble],\r\n    \"ELong\"    : [ShortAttribETypes.EFloat, ShortAttribETypes.EDouble],\r\n    \"EFloat\"   : [ShortAttribETypes.EDouble],\r\n    \"EDouble\"  : []\r\n};\r\nlet ecoreprefix = \"ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//\";\r\nlet ecoreclasprefix = \"ecore:EClass platform:/plugin/org.eclipse.emf.ecore/model/Ecore.ecore#//\";\r\nexport function toShortEType(a: AttribETypes): ShortAttribETypes{ return a.substring(ecoreprefix.length) as any; }\r\nexport function toLongEType(a: ShortAttribETypes): AttribETypes {\r\n    return AttribETypes[a];\r\n    // return ecoreprefix + a as any;\r\n}\r\n\r\nexport function toShortEClass(a: DefaultEClasses): ShortDefaultEClasses{ return a.substring(ecoreclasprefix.length) as any; }\r\nexport function toLongEClass(a: ShortDefaultEClasses): DefaultEClasses { return DefaultEClasses[a]; }\r\n\r\nexport class SelectorOutput {\r\n    jqselector!: string;\r\n    attrselector!: string;\r\n    attrRegex!: RegExp;\r\n    exception!: any;\r\n    resultSetAttr!: Attr[];\r\n    resultSetElem!: JQuery<Element>;\r\n}\r\n// compare it with event.key\r\nexport type Key = string;\r\n@RuntimeAccessible('Keystrokes')\r\nexport class Keystrokes {\r\n    static cname: string = 'Keystrokes'\r\n    public static clickLeft = 0;\r\n    public static clickWheel = 1;\r\n    public static clickRight = 2;\r\n    public static clickBackMouseButton = 3;\r\n    public static clickForwardMouseButton = 4;\r\n\r\n    // keyboard\r\n    public static escape = 'Escape';\r\n    public static capsLock = 'CapsLock';\r\n    public static shift = 'Shift';\r\n    public static tab = 'Tab';\r\n    public static alt = 'Alt';\r\n    public static cmd = 'Control';\r\n    public static control = 'Control';\r\n    public static end = 'End';\r\n    public static home = 'Home';\r\n    public static pageUp = 'PageUp';\r\n    public static pageDown = 'PageDown';\r\n    public static enter = 'Enter'; // event.code = 'NumpadEnter' se fatto da numpad, oppure \"numpad3\", \"NumpadMultiply\", ShiftLeft, etc...\r\n    public static numpadEnter = 'NumpadEnter';\r\n    public static audioVolumeMute = 'AudioVolumeMute';\r\n    public static audioVolumeUp = 'AudioVolumeUp';\r\n    public static audioVolumeDown = 'AudioVolumeDown';\r\n    public static mediaTrackPrevious = 'MediaTrackPrevious';\r\n    public static delete = 'Delete'; // canc\r\n    public static backspace = 'Backspace';\r\n    public static space = ' ';\r\n    public static altGraph = 'AltGraph';\r\n    public static arrowLeft = 'ArrowLeft';\r\n    public static arrowRight = 'ArrowRight';\r\n    public static arrowUp = 'ArrowUp';\r\n    public static arrowDown = 'ArrowDown';\r\n    public static insert = 'Insert';\r\n    public static f1 = 'F1';\r\n    // weird ones:\r\n    public static meta = 'Meta'; // f1, or other f's with custom binding and windows key\r\n    public static unidentified = 'Unidentified'; // brightness\r\n    public static __NotReacting__ = 'fn, print, maybe others'; // not even triggering event?\r\n    private static RegisteredKeyStrokes: Dictionary<DocString<'selector'>, {keyup: (e:any)=>any, keydown: (e:any)=>any}> = {};\r\n    public static register(selector: string, arr: {function?: ()=>any, keystroke?: Key[]}[]): void{\r\n        if (Keystrokes.RegisteredKeyStrokes[selector]) return;\r\n        let $elems = $(selector);// sort from most \"uncommon\" to most common key\r\n        let metakeysmap = {\r\n            [Keystrokes.alt]: 'altKey',\r\n            [Keystrokes.shift]: 'shiftKey',\r\n            [Keystrokes.control]: 'ctrlKey',/*\r\n            'altKey': Keystrokes.alt,\r\n            'shiftKey': Keystrokes.shift,\r\n            'ctrlKey': Keystrokes.control,*/\r\n        }; //  '??': 'metaKey'];*/\r\n        // let metakeys = ['altKey', 'shiftKey', 'ctrlKey'];\r\n\r\n\r\n        Log.exDev(!($elems.on as any), 'jQuery is required for Keystrokes.register');\r\n        let optimizedKeyPaths: GObject = {\r\n            [Keystrokes.alt]: {},\r\n            [Keystrokes.shift]: {},\r\n            [Keystrokes.control]: {},\r\n        }\r\n        for (let entry of arr) {\r\n            if (!entry || !entry.function || !entry.keystroke || !entry.keystroke.length) continue;\r\n            let keymap = U.objectFromArrayValues(entry.keystroke);\r\n            let root = optimizedKeyPaths\r\n            if (keymap[Keystrokes.alt]) {\r\n                if (!root[Keystrokes.alt]) root = root[Keystrokes.alt] = {};\r\n                else root = root[Keystrokes.alt];\r\n            }\r\n            if (keymap[Keystrokes.shift]) {\r\n                if (!root[Keystrokes.shift]) root = root[Keystrokes.shift] = {};\r\n                else root = root[Keystrokes.shift];\r\n            }\r\n            if (keymap[Keystrokes.control]) {\r\n                if (!root[Keystrokes.control]) root = root[Keystrokes.control] = {};\r\n                else root = root[Keystrokes.control];\r\n            }\r\n            let terminalKeys = entry.keystroke.filter(k => !(k in metakeysmap));\r\n            Log.eDev(terminalKeys.length !== 1, \"found a keystroke combination with multiple terminal keys\", {entry, selector});\r\n            let terminal = terminalKeys[0].toLowerCase();\r\n            root[terminal] = entry.function;\r\n        }\r\n        let keyup = (e: KeyUpEvent) => {\r\n            // skip events happened in graph\r\n            let curr = e.target;\r\n            while (curr) {\r\n                if (curr.classList.contains('Graph')) return;\r\n                curr = curr.parentElement;\r\n            }\r\n            // handle event\r\n            if (e.altKey) { $elems.removeClass('key-alt'); }\r\n            if (e.shiftKey) { $elems.removeClass('key-shift'); }\r\n            if (e.ctrlKey) { $elems.removeClass('key-ctrl'); }\r\n        }\r\n        let keydown = (e: KeyDownEvent) => {\r\n            // skip events happened in graph\r\n            let curr = e.target;\r\n            console.log('keydown', {selector, e, curr, ct:e.currentTarget});\r\n            while (curr) {\r\n                if (curr.classList.contains('Graph')) return;\r\n                curr = curr.parentElement;\r\n            }\r\n            // handle event\r\n            let root = optimizedKeyPaths;\r\n            if (e.altKey) { root = root[Keystrokes.alt] || {}; $elems.addClass('key-alt'); }\r\n            if (e.shiftKey) { root = root[Keystrokes.shift] || {}; $elems.addClass('key-shift'); }\r\n            if (e.ctrlKey) { root = root[Keystrokes.control] || {}; $elems.addClass('key-ctrl'); }\r\n            let f = root[e.key];\r\n            console.log(\"execute keystrokes\", {e, root, optimizedKeyPaths, up:{$elems, keydown, optimizedKeyPaths, arr}});\r\n            Log.exDev(f && typeof f !== 'function','found keystroke with invalid func', {f, root, e})\r\n            f?.();\r\n        };\r\n        /// todo: for graph can attack evt to graph root and use selector in on() lieke $graphcontainer.on('keydown', '.Class', classkeystrokehandler...)\r\n        Keystrokes.RegisteredKeyStrokes[selector] = {keydown, keyup, arr, optimizedKeyPaths} as any;\r\n        // $elems.off('keydown').on('keydown', null, keydown);\r\n        // $elems.off('keydown').on('keyup', null, keyup);\r\n        let $doc = $(document.body);\r\n        $doc.off('keydown', selector, keydown).on('keydown', selector, keydown);\r\n        $doc.off('keyup', selector, keyup).on('keyup', selector, keyup);\r\n        console.log(\"register keystrokes\", {$elems, keydown, optimizedKeyPaths, arr});\r\n\r\n    }\r\n    public static unregister(selector: string): void{\r\n        if (!Keystrokes.RegisteredKeyStrokes[selector]) return;\r\n        //$(selector).off('keydown', null as any, Keystrokes.RegisteredKeyStrokes[selector].keydown);\r\n        //$(selector).off('keyup', null as any, Keystrokes.RegisteredKeyStrokes[selector].keyup);\r\n\r\n        let $doc = $(document.body);\r\n        $doc.off('keydown', selector, Keystrokes.RegisteredKeyStrokes[selector].keydown);\r\n        $doc.off('keyup', selector, Keystrokes.RegisteredKeyStrokes[selector].keyup);\r\n\r\n        delete Keystrokes.RegisteredKeyStrokes[selector];\r\n    }\r\n\r\n\r\n    public static getKeystrokeJsx(key: string, allowBootIcons: boolean = true, allowBoxIcons: boolean=true, allowTextIcons: boolean = true){\r\n        let os = U.getOSBrowserData().os.substring(0, 3).toLowerCase();\r\n        let obj = iconKeys['bi_' + os];\r\n        if (!obj) return Log.eDevv('Found unexpected OS: ' + os, {data:U.getOSBrowserData()}) && '';\r\n        if (allowBootIcons && key in obj) { let val = obj[key]; return <i className={\"bi \" + val} title={key}/>; }\r\n        //obj = iconKeys['box_' + os];\r\n        // if (!obj) return Log.eDevv('Found unexpected OS: ' + os, {data:U.getOSBrowserData()}) && '';\r\n        //if (allowBoxIcons && key in obj) { let val = obj[key]; return <span><i className={\"box-icons?? \" + val todo} title={key}/></span>; }\r\n        obj = iconKeys['text_' + os];\r\n        if (!obj) return Log.eDevv('Found unexpected OS: ' + os, {data:U.getOSBrowserData()}) && '';\r\n        if (allowTextIcons && key in obj) { let val = obj[key]; return <i className={\"text-icon \" + val} title={key} data-val={val} data-content={key}/>; }\r\n        return <span>{key.toUpperCase()}</span>;\r\n    }\r\n    public static NamedKeys: Dictionary<string, boolean>;\r\n}\r\n\r\nconst iconKeys: Dictionary<string, Dictionary<string, string>> = {\r\n        bi_win: {\r\n            [Keystrokes.shift] : \"bi-shift\"\r\n        },\r\n        bi_mac: {\r\n            [Keystrokes.cmd]   : \"bi-command\",\r\n            [Keystrokes.control]   : \"bi-command\",\r\n            [Keystrokes.alt]   : \"bi-alt\",\r\n            [Keystrokes.shift] : \"bi-shift\"\r\n        },\r\n    box_win: {},\r\n    box_mac: {},\r\n    text_win: {\r\n        [Keystrokes.cmd]   : \"ctrl\",\r\n        [Keystrokes.control]   : \"ctrl\",\r\n        [Keystrokes.alt]   : \"alt\",\r\n        [Keystrokes.shift] : \"shift\"\r\n    },\r\n    text_mac: {},\r\n};\r\n\r\n// Keystrokes.NamedKeys: Dictionary<string, boolean> = Object.values(Keystrokes).reduce((acc, v) => { acc[v] = true; return acc; }, Keystrokes.NamedKeys as GObject);\r\n/*const windowsKeys: Dictionary<string, string> = {\r\n    [Key.cmd]: \"ctrl\", //'windows'; // <i className=\"bi bi-windows\"></i>\r\n    [Key.shift]: \"shift\",\r\n    [Key.alt]: \"alt\",\r\n}*/\r\n\r\n\r\nexport enum DefaultEClasses{\r\n    EObject = \"ecore:EClass platform:/plugin/org.eclipse.emf.ecore/model/Ecore.ecore#//EObject\",\r\n    EAnnotation = \"ecore:EClass platform:/plugin/org.eclipse.emf.ecore/model/Ecore.ecore#//EAnnotation\",\r\n    EClass = \"ecore:EClass platform:/plugin/org.eclipse.emf.ecore/model/Ecore.ecore#//EClass\",\r\n    EPackage = \"ecore:EClass platform:/plugin/org.eclipse.emf.ecore/model/Ecore.ecore#//EPackage\",\r\n    ENamedElement = \"ecore:EClass platform:/plugin/org.eclipse.emf.ecore/model/Ecore.ecore#//ENamedElement\",\r\n}\r\nexport enum AttribETypes {\r\n    EVoid = 'ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EVoid', // ??? i invented this.\r\n    EChar = 'ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EChar',\r\n    EString = 'ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EString',\r\n    EDate = 'ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EDate',\r\n    EFloat = 'ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EFloat',\r\n    EDouble = 'ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EDouble',\r\n    EBoolean = 'ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EBoolean',\r\n    EByte = 'ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EByte',\r\n    EShort = 'ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EShort',\r\n    EInt = 'ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EInt',\r\n    ELong = 'ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//ELong',\r\n    // present in uml.ecore, without definition. i guess it's a custom installed package which is commonly used\r\n    // EDiagnosticChain = 'ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EDiagnosticChain',\r\n    /*\r\n  ECharObj = 'ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//ECharObject',\r\n  EStringObj = 'ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EStringObject',\r\n  EDateObj = 'ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EDateObject',\r\n  EFloatObj = 'ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EFloatObject',\r\n  EDoubleObj = 'ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EDoubleObject',\r\n  EBooleanObj = 'ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EBooleanObj',\r\n  EByteObj = 'ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EByteObject',\r\n  EShortObj = 'ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EShortObject',\r\n  EIntObj = 'ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EIntegerObject',\r\n  ELongObj = 'ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//ELongObject', */\r\n    // EELIST = 'ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EEList', // List<E> = List<?>\r\n}\r\n\r\n// export type Json = object;\r\n\r\nexport class ParseNumberOrBooleanOptions{\r\n    defaultValue?: any;\r\n    allowNull?: boolean; nullValue?: any;\r\n    allowUndefined?: boolean; undefinedValue?: any;\r\n    allowedNan?: boolean; nanValue?: any;\r\n    allowBooleans?: boolean; trueValue?: any; falseValue?: any;\r\n    constructor(\r\n        defaultValue: any = null, allowNull: boolean = false, nullValue: any = null,\r\n        allowUndefined: boolean = false, undefinedValue: any = undefined,\r\n        allowedNan: boolean = false, nanValue: any = NaN,\r\n        allowBooleans: boolean = true, trueValue : any = 1, falseValue: any = 0) {\r\n        this.defaultValue = defaultValue; this.allowNull = allowNull; this.nullValue = nullValue;\r\n        this.allowUndefined = allowUndefined; this.undefinedValue = undefinedValue;\r\n        this.allowedNan = allowedNan; this.nanValue = nanValue;\r\n        this.allowBooleans = allowBooleans; this.trueValue = trueValue; this.falseValue = falseValue;\r\n    }\r\n}\r\n/*\r\ninterface LoggerInterface{\r\n    log: (category: string, key: string, data: any[], fullconcat?: string, stringified?: string) => any;\r\n}*/\r\n\r\n\r\n\r\nexport class FileReadTypeEnum {\r\n    public static image: FileReadTypeEnum = \"image/*\" as any;\r\n    public static audio: FileReadTypeEnum = \"audio/*\" as any;\r\n    public static video: FileReadTypeEnum = \"video/*\" as any;\r\n    /// a too much huge list https://www.iana.org/assignments/media-types/media-types.xhtml\r\n    public static AndManyOthersButThereAreTooMuch: string = \"And many others... https://www.iana.org/assignments/media-types/media-types.xhtml\";\r\n    public static OrJustPutFileExtension: string = \"OrJustPutFileExtension\";\r\n}\r\n\r\n// console.info('loaded ts U');\r\n","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\common\\UX.tsx",["1116","1117","1118","1119","1120","1121","1122","1123","1124","1125","1126"],"import ReactJson from 'react-json-view' // npm i react-json-view\r\nimport React, {ReactElement, ReactNode} from \"react\";\r\nimport withReactContent from \"sweetalert2-react-content\";\r\nimport Swal from \"sweetalert2\";\r\nimport {GraphElementOwnProps, GObject, Dictionary, DocString, Pointer, LGraph, MultiSelectOptGroup} from \"../joiner\";\r\nimport type { InputOwnProps, SelectOwnProps } from '../components/forEndUser/Input';\r\nimport type {  } from '../components/forEndUser/Select';\r\nimport {\r\n    LPointerTargetable,\r\n    U,\r\n    Log,\r\n    GraphElementComponent,\r\n    windoww,\r\n    RuntimeAccessible,\r\n    EdgeComponent,\r\n    RuntimeAccessibleClass,\r\n    EdgeOwnProps,\r\n    DGraphElement,\r\n    DModelElement,\r\n    transientProperties, JSXT, DViewElement\r\n} from \"../joiner\";\r\nimport {AllPropss} from \"../graph/vertex/Vertex\";\r\n\r\nvar Convert = require('ansi-to-html');\r\n\r\n// U-functions that require jsx\r\n@RuntimeAccessible('UX')\r\nexport class UX{\r\n\r\n    static recursiveMap<T extends ReactNode | ReactNode[] | null | undefined>(children: T, fn: (rn: T, i: number, depthIndices: number[])=>T, depthIndices: number[] = []): T {\r\n        // NB: depthIndices is correct but if there is an expression children evaluated to false like {false && <jsx>},\r\n        // it counts as children iterated regardless. so html indices might be apparently off, but like this is even safer as indices won't change when conditions are changed.\r\n        const innermap = (child: ReactNode, i1: number, depthIndices: number[]): T => {\r\n            if (!React.isValidElement(child)) {\r\n                if (Array.isArray(child)) return React.Children.map(child as T, (c: T, i3: number)=>innermap(c, i3, [...depthIndices,i3])) as T;\r\n                if (child && typeof child === \"object\") {\r\n                    if (!windoww.invalidObjsReact) windoww.invalidObjsReact = [];\r\n                    windoww.invalidObjsReact.push(child);\r\n                    return \"<! Objects cannot be rendered in jsx : \" + (child as any)?.name + \">\" as T;\r\n                }\r\n                return child as T; }\r\n            if (child.props.children) {\r\n                // let deeperDepthIndices = [...depthIndices, i1];  // depthIndices; //\r\n                // should probably change deeperDepthIndices in [...deeperDepthIndices, i] in next uncommented line.\r\n                // Giordano: add ignore for webpack\r\n                //@ts-ignore\r\n                child = React.cloneElement(child, { children: UX.recursiveMap(child.props.children,\r\n                        (e: T, i2: number, ii) => fn(e, i2, ii), depthIndices) });\r\n                // this can be optimized, and i think i can avoid cloning here, as the nodes are already cloned in \"fn\" = ux.injectprops\r\n            }\r\n            return fn(child as T, i1, depthIndices);\r\n        };\r\n        if (!Array.isArray(children)) return innermap(children as ReactNode, 0, [...depthIndices, 0]) as T;\r\n        // if (typeof children[0] === \"object\") return (children).map( (c: T, i3: number)=>innermap(c, i3, [...depthIndices,i3])) as any as T;\r\n        return React.Children.map(children, (c: T, i3: number)=>innermap(c, i3, [...depthIndices,i3])) as T;\r\n    }\r\n    /*\r\n    public static draggable_eventmap = {\r\n        's':    {'draggable': 'onDragStart',    'rotatable': 'onRotateStart',   'resizable': 'onResizeStart'},\r\n        'ing':  {'draggable': 'whileDragging',  'rotatable': 'whileRotating',   'resizable': 'whileResizing'},\r\n        'e':    {'draggable': 'onDragEnd',      'rotatable': 'onRotateEnd',     'resizable': 'onResizeEnd'  },\r\n    };\r\n    public static draggable_eventprops= UX.initMeasurable();\r\n    static initMeasurable(): Dictionary<string, boolean>{\r\n        return U.objectFromArrayValues(Object.values(UX.draggable_eventmap).flatMap(v=>Object.values(v)), true);\r\n    }*/\r\n\r\n    static injectProp(parentComponent: GraphElementComponent, e: ReactNode, gvidmap_useless: Dictionary<DocString<'VertexID'>, boolean>,\r\n                      parentnodeid: string, index: number, indices: number[], injectOffset?: LGraph): ReactNode {\r\n        let re: ReactElement | null = UX.ReactNodeAsElement(e);\r\n\r\n        // injectOffset&&console.log(\"inject offset props 1:\", {e, re, injectOffset});\r\n        if (!re) return e;\r\n        // @ts-ignore this\r\n        // const parentComponent = this;\r\n        const type = (re.type as any).WrappedComponent?.name || re.type;\r\n        let injectProps: GraphElementOwnProps = {} as any;\r\n        /* if (false && injectOffset) {\r\n            const style = {...(re.props?.style || {})};\r\n            let offset = injectOffset.offset;\r\n            let scale = injectOffset.zoom;\r\n            style.position = \"absolute\";\r\n            style.left = offset.x;\r\n            style.top = offset.y;\r\n            style.transform = \"scale(\" + scale.x + \",\" + scale.y + \")\"\r\n            injectProps.style = style;\r\n            console.log(\"inject offset props:\", {re, injectProps});\r\n        }*/\r\n        //  fix the injection somehow. override Edge() Vertex() Asterisk() ...\r\n        // const windoww = window as any;\r\n        // console.log('ux.injectingProp pre ', {type: (re.type as any).WrappedComponent?.name || re.type}, {mycomponents: windoww.mycomponents, re, props:re.props});\r\n        // add \"view\" (view id) prop as default to sub-elements of any depth to inherit the view of the parent unless the user forced another view to apply\r\n        switch (type) {\r\n            default:\r\n                // console.count('ux.injectingProp case default: ' + type);\r\n                if (indices.length <= 2 && (parentComponent?.props?.childStyle)) {\r\n                    // if first non-component child of a GraphElement with a clipPath shape, i assign clip path to it.\r\n                    console.log('injecting to first child (A):', {re, indices, il: indices.length, pc: parentComponent, injectProps, cs:parentComponent.props.childStyle});\r\n                    let istyle: GObject = injectProps.style = {...(injectProps.style || {})};\r\n                    injectProps.style = injectProps.style ? {...injectProps.style} : {};\r\n                    U.objectMergeInPlace(injectProps.style, parentComponent.props.childStyle);\r\n                } else return re;\r\n                break;\r\n            /*\r\n            case windoww.Components.Input.name:\r\n            case windoww.Components.Textarea.name:\r\n                const objid =  re.props.obj?.id || re.props.obj || parentComponent.props.data.id;\r\n                const ret = React.cloneElement(re, {key: UX.getKey(re) || parentComponent.props.view.id + '_' + parentComponent.props.data.id + '_' + re.props.field, obj: objid, obj2: objid});\r\n                //console.log('relement Input set props',\r\n                //    {'re.props.obj.id': re.props.obj?.id, 're.props.obj': re.props.obj, 'thiss.props.data.id': thiss.props.data.id, thiss, re, objid, ret, 'ret.props': ret.props});\r\n                return ret;*/\r\n            // case windoww.Components.GraphElement.name:\r\n            case windoww.Components.Input.cname+\"Component\":\r\n            case windoww.Components.Select.cname+\"Component\":\r\n            case windoww.Components.TextArea.cname+\"Component\":\r\n                // todo: can i do a injector that if the user provides a ModelElement list raw <div>{this.children}</div> it wraps them in DefaultNode?\r\n                const injectProps2: InputOwnProps | SelectOwnProps = {} as any;\r\n                const parentnodeid = parentComponent.props.node?.id;\r\n                injectProps2.data = re.props.data || (typeof parentComponent.props.data === \"string\" ? parentComponent.props.data : parentComponent.props.data?.id);\r\n                // !IMPORTANT! this key does not remove the responsability of adding keys to <GraphElement>s. this is assigning the key to the first returned element by component A,\r\n                // but react needs to distinguish component A from other components, and he still doesn't have a key. in fact this is useless as this component can only have 1 child\r\n                injectProps2.key = UX.getKey(re) || (parentnodeid + \"_input_\"+index);\r\n                return React.cloneElement(re, injectProps2);\r\n            case windoww.Components.GraphElementComponent.cname:\r\n            // case windoww.Components.DefaultNode.name:\r\n            case windoww.Components.DefaultNodeComponent.cname:\r\n            // case windoww.Components.Graph.name:\r\n            // case windoww.Components.GraphComponent.cname:\r\n            case \"Graph\": case \"GraphComponent\":\r\n            // case windoww.Components.Field.name:\r\n            // case windoww.Components.FieldComponent.cname:\r\n            // case windoww.Components.Vertex.name:\r\n            case EdgeComponent.cname:\r\n            case windoww.Components.VertexComponent.cname:\r\n                injectProps.parentViewId = parentComponent.props.view.id || (parentComponent.props.view as any); // re.props.view ||  thiss.props.view\r\n                injectProps.parentnodeid = parentComponent.props.node?.id;\r\n                injectProps.graphid = parentComponent.props.graphid;\r\n                // const vidmap = GraphElementRaw.graphVertexID_counter;\r\n                // if (!vidmap[injectProps.graphid]) vidmap[injectProps.graphid] = {};\r\n                // const gvidmap = vidmap[injectProps.graphid];\r\n                // const validVertexIdCondition = (id: string): boolean => gvidmap_useless[id];\r\n                // todo: come butto dei sotto-vertici dentro un vertice contenitore? o dentro un sotto-grafo? senza modificare il jsx ma solo draggando? React-portals?\r\n                const dataid = (typeof re.props.data === \"string\" ? re.props.data : re.props.data?.id) || \"shapeless\";\r\n                let idbasename: string;\r\n\r\n                //console.log('injecting props ' + type, {re, pc: parentComponent, injectProps, ownProps: re.props});\r\n                if (re.props.initialSize?.id) { idbasename = re.props.initialSize?.id; } else\r\n                if (re.props.nodeid) { idbasename = re.props.nodeid; } else\r\n                if (re.props.id) { idbasename = re.props.id; } else\r\n                if (UX.getKey(re)) {\r\n                    idbasename = injectProps.parentnodeid + \"_\" +UX.getKey(re);\r\n                    // console.log(\"keyid: \", {idbasename});\r\n                }\r\n                else switch (type) {\r\n                    default:\r\n                        idbasename = injectProps.parentnodeid + \"_\" + dataid + \"N\";\r\n                        break;\r\n                    case windoww.Components.EdgePoint.cname:\r\n                        idbasename = injectProps.parentnodeid + \"_\" + (dataid || re.props.startingSize?.id || indices.join(\"_\")) + \"EP\";\r\n                        break;\r\n                    case EdgeComponent.cname: case \"Edge\":\r\n                        //console.log('injecting props ' + type + \" without key\", {re, pc: parentComponent, injectProps, ownProps: re.props});\r\n                        let edgeProps:EdgeOwnProps = re.props;\r\n                        let edgestart_id: Pointer<DGraphElement> | Pointer<DModelElement> = (edgeProps.start as any).id || edgeProps.start;\r\n                        let edgeend_id: Pointer<DGraphElement> | Pointer<DModelElement> = (edgeProps.end as any).id || edgeProps.end;\r\n                        idbasename = injectProps.parentnodeid + \"_\" + edgestart_id + \"-\" + edgeend_id;\r\n                }\r\n                // (injectProps.parentnodeid)+\"_\"+(dataid)+indices.join(\"_\");//injectProps.graphid + '_' + dataid;\r\n                // console.log(\"setting nodeid\", {injectProps, props:re.props, re});\r\n                // Log.exDev(!injectProps.graphid || !dataid, 'vertex is missing mandatory props.', {graphid: injectProps.graphid, dataid, props: re.props});\r\n                Log.exDev(!injectProps.graphid, 'vertex is missing mandatory props (graphid).', {graphid: injectProps.graphid, dataid, props: re.props});\r\n                if (false && indices.length === 2) {\r\n                    // if first component child, of a component? like (DefaultNode -> Vertex)?\r\n                    console.log('injecting to first child (B):', {re, pc: parentComponent, injectProps});\r\n                    if (parentComponent?.props.style?.clipPath) injectProps.style = {...(injectProps.style || {}), clipPath: parentComponent?.props.style?.clipPath||''}\r\n                }\r\n                injectProps.nodeid = idbasename; // U.increaseEndingNumber(idbasename, false, false, validVertexIdCondition);\r\n                injectProps.htmlindex = indices[indices.length - 1]; // re.props.node ? re.props.node.htmlindex : indices[indices.length - 1];\r\n                injectProps.key = UX.getKey(re) || injectProps.nodeid;\r\n                // console.log(\"cloning jsx:\", re, injectProps);\r\n                Log.ex((injectProps.nodeid === injectProps.graphid||injectProps.nodeid === injectProps.parentnodeid) && type !== \"GraphComponent\", \"User manually assigned a invalid node id. please remove or change prop \\\"nodeid\\\"\", {type: (re.type as any).WrappedComponent?.cname || re.type}, {mycomponents: windoww.mycomponents, re, props:re.props});\r\n        }\r\n        //console.log('injecting props ' + type, {id: injectProps.nodeid, re, pc: parentComponent, injectProps});\r\n        return React.cloneElement(re, injectProps);\r\n    }\r\n\r\n    static ReactNodeAsElement(e: React.ReactNode): React.ReactElement | null {\r\n        return e && (e as ReactElement).type ? e as ReactElement : null;\r\n    }\r\n    static getKey(e: ReactNode): string | undefined {\r\n        return (e as any)?.key; // NOT e.props.key, key is not a part of props in ReactNode.\r\n    }\r\n\r\n    public static async deleteWithAlarm(lItem: LPointerTargetable) {\r\n        const MySwal = withReactContent(Swal);\r\n        const confirm = await MySwal.fire({\r\n            title: \"Delete \" + lItem.toString() + \"?\",\r\n            showCancelButton: true,\r\n            confirmButtonText: \"Yes\",\r\n            cancelButtonText: \"No\",\r\n            showLoaderOnConfirm: true\r\n        });\r\n        if (confirm.value === true) {\r\n            lItem.delete();\r\n        }\r\n    }\r\n    public static async info(text: string) {\r\n        const MySwal = withReactContent(Swal);\r\n        const confirm = await MySwal.fire({\r\n            title: text,\r\n            showCancelButton: false,\r\n            confirmButtonText: \"Got It\"\r\n        });\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    private static initPropInjectionStuff(): string[]{\r\n        UX.graphComponents = ['GraphElement', '...more'];\r\n        UX.inputComponents = ['Input', 'Select', 'TextArea','...more'];\r\n        UX.graphComponentsRegexp = new RegExp(UX.graphComponents.map(s=>'(?:;\\\\}\\\\)\\\\]\\\\,\\\\;\\\\s)'+s+'\\\\(').join('|'));\r\n        UX.inputComponentRegexp = new RegExp(UX.graphComponents.map(s=>'(?:;\\\\}\\\\)\\]\\\\,\\\\;\\\\s)'+s+'\\\\(').join('|'));\r\n        UX.viewRootProps = '\"data-viewid\": props.viewid,' +\r\n            ' addStyle: (offset ? {position:\"absolute\", left:offset.x, top:offset.y/*,transform:\"scale(\"+zoom.x+\",\"+zoom.y+\")\"*/} : undefined)';\r\n        UX.mainViewRootProps = 'ref: component.html, id: props.nodeid, \"data-nodeid\": props.nodeid, \"data-dataid\": props.dataid,\\n' +\r\n            '\"data-modelname\": data?.className || \"model-less\",' +\r\n            '\"data-userselecting\": JSON.stringify(node.isSelected || {}),' +\r\n            '\"data-nodetype\": node.className, ' +\r\n            '\"data-parentview\": props.parentviewid, ' +\r\n            //'\"data-order\": node.zIndex,' +\r\n            'onClick: component.onClick,' +\r\n            'onContextMenu: component.onContextMenu,' +\r\n            'onMouseDown: component.onMouseDown,' +\r\n            'onMouseUp: component.onMouseUp,' +\r\n            'onwheel: component.onScroll,' +\r\n            'onMouseEnter: component.onEnter,' +\r\n            'onMouseLeave: component.onLeave,' +\r\n            'tabIndex: (props as any).tabIndex || node.zIndex || -1,' +\r\n            '\"data-countrenders\": component.countRenders++,' +\r\n            'decorators: otherViews,'+// used in user jsx to inject decorator views\r\n            'classNameAdd: [(component.countRenders%2 ? \"animate-on-update-even\" : \"animate-on-update-odd\"),\"mainView\", props.viewid, ...props.viewsid].join(\",\"),' +\r\n            '...this.props';\r\n        UX.decorativeViewRootProps +='classNameAdd: \"decorativeView \" + props.viewid, \"data-mainview\": mainviewid';\r\n        return UX.graphComponents\r\n    }\r\n    private static graphComponents: string[] = UX.initPropInjectionStuff();\r\n    private static inputComponents: string[] = undefined as any;\r\n    private static graphComponentsRegexp: RegExp = undefined as any;\r\n    private static inputComponentRegexp: RegExp = undefined as any;\r\n    private static GC_propsAdder(index: number): string { return \"nodeid: window._assignnodeid(props, \"+index+\"), key:\"+index; }\r\n    private static Input_propsAdder(index: number):string { return \"key:\"+index; }\r\n    private static injectPropsToString_addstuff(s: string, index: number, props: string, type: string, propsAdder?:((index: number)=>string) | undefined): string { // move out in global scope\r\n        switch (s[index]) {\r\n            case '{': // props object\r\n                // let propstr = JSON.stringify(propsToInjectAtRoot);\r\n                // propstr = propstr.substring(1, propstr.length-2);\r\n                s = s.substring(0, index+1) + props + (propsAdder ? ','+propsAdder(index) : '') + ',' + s.substring(index+1);\r\n                break;\r\n            case 'n': // null:\r\n                // let propstr = JSON.stringify(propsToInjectAtRoot)\r\n                s = s.substring(0, index) + '{'+props+(propsAdder ? ','+propsAdder(index) : '') + '}' + s.substring(index+4);\r\n                break;\r\n            default: Log.exDevv('unexpected string in '+type+' props injection parser',\r\n                {s_pre:s.substring(index-10, 10), s_post:s.substring(index, index+10), index, c:s[index], fullstr:s});\r\n                break;\r\n        }\r\n        return s;\r\n    }\r\n    private static viewRootProps: string;\r\n    private static decorativeViewRootProps: string;\r\n    private static mainViewRootProps: string;\r\n// propsToInject cannot be an object because i need variable names as prop values, NOT strings, not their immediate values. so i pass a string with a list of props\r\n    static injectPropsToString(s: string, asMainView:boolean, graphComponentsProps: string, inputComponentProps: string){\r\n        // non-root props are injected through Component constructors instead\r\n        // plan B instead: make it  \"DefaultNde({pa: \"pa\"}, [\"a\", [b,c]])\" ---> \"Root(DefaultNde, {pa: \"pa\"}, [\"a\", [b,c]]) and handle injection in Root func\r\n        const propsToInjectAtRoot = UX.viewRootProps + ','+(asMainView ? UX.mainViewRootProps : UX.decorativeViewRootProps);\r\n        //add in context: component = (this as GraphElementComponent), otherViews\r\n        // 'style: {...viewStyle, ...styleoverride},' + need to fix this\r\n        // 'className: classes.join(\\' \\'),' + and this\r\n        // and otherViews as ReactNode[]\r\n        // context.mainviewid (different from context.view in decorative views)\r\n        s = s.trim();\r\n        if (propsToInjectAtRoot.length) {\r\n            let argStartIndex = s.indexOf('(', 1) + 1;//.match(/[A-Za-z_$0-9]+\\(/)\r\n            // todo: hamdle props.addstyle\r\n            // add im props: offset: this.props.isGraph ££ this.props.ode.offset, zoom: this.props.isGraph ££ this.props.ode.zoom\r\n\r\n            if (s[argStartIndex] === \"'\") argStartIndex = s.indexOf(\"'\", argStartIndex+1);// it is a lowercase component with name as string in first param\r\n            s = UX.injectPropsToString_addstuff(s, argStartIndex, propsToInjectAtRoot, 'root');\r\n\r\n            // used in GC_propsAdder as a string to be eval-ed\r\n            (window as any)._assignnodeid = function _assignnodeid(props: AllPropss, index:number): string {\r\n                const tnv = transientProperties.node[props.nodeid].viewScores[props.viewid];\r\n                if (!tnv.nodeidcounter) tnv.nodeidcounter = {};\r\n                if (tnv.nodeidcounter[index] === undefined) tnv.nodeidcounter[index] = 0;\r\n                else tnv.nodeidcounter[index]++;\r\n\r\n                return props.nodeid+'_'+index+'_'+tnv.nodeidcounter[index];\r\n                // every time before jsx render, \" let nc = transientProperties.node[props.nodeid].viewScores[props.viewid].nodeidcounter; for (let k of nc) nc[k]=0; or just nodeidcounter={}\r\n            }\r\n        }\r\n\r\n        // lowercase, no props          React.createElement('defaultNde', null, [\"a\", [a,b,c]])\r\n        // uppercase, ++ props          DefaultNde({pa: \"pa\", pb: b, pc: \"c\"}, [\"a\", [a,b,c]])\r\n        // lowercase, ++ props          React.createElement('defaultNde', {a: \"1\"}, [\"a\", [a,b,c]])\r\n        // uppercase, no props          DefaultNde(null, [\"a\", [a,b,c]])\r\n        // might have () wrapping all\r\n        // or array wrapping all\r\n        // or comments (both inline and line)\r\n        // or even a string at beginning\r\n        // nightmare case is:          `([\"a()\", /*comment()*/ React.createElement('defaultNde', {a: \"1\"}, [\"a\", [a,b,c]]),2])`\r\n        // !! fix: force users to have < as first char?? and editor tells it's wrong if this is not the case?\r\n        // that forces mono-root, but arrays would be hard to inject root-level props and prone to break anyway\r\n        let match: RegExpExecArray | null;\r\n        //here i give up, because i cannot compute nodeid without htmlindex[] from root to component\r\n        // cannot even get nodeid according to jsxstr position because of loops / map generate multiple nodes from same string index\r\n        // NO! i can do srtindex+counters[strindex]++?\r\n        //\r\n\r\n        graphComponentsProps = 'parentnodeid: props.nodeid, graphid:this.props.node.className.indexOf(\"Graph\")>=0 ? props.nodeid : props.graphid,' +\r\n            ' parentViewId:props.viewid';// + dynamically: 'nodeid, key' // - removed: htmlindex\r\n        inputComponentProps = 'data: props.data, field:\"name\"'; // + dynamically: 'key'\r\n\r\n        if (graphComponentsProps.length > 0) while (match = UX.graphComponentsRegexp.exec(s)) {\r\n            let matchstr: string = match[0];\r\n            //let pre = s.substring(0, match.index) + matchstr;\r\n            let argStartIndex = match.index + matchstr.length;\r\n            s = UX.injectPropsToString_addstuff(s, argStartIndex, graphComponentsProps, 'graphElement', UX.GC_propsAdder);\r\n        }\r\n        if (inputComponentProps.length > 0) while (match = UX.inputComponentRegexp.exec(s)) {\r\n            let matchstr: string = match[0];\r\n            //let pre = s.substring(0, match.index) + matchstr;\r\n            let argStartIndex = match.index + matchstr.length;\r\n            s = UX.injectPropsToString_addstuff(s, argStartIndex, inputComponentProps, 'inputComponent', UX.Input_propsAdder);\r\n        }\r\n        return s;\r\n    }\r\n\r\n    static parseAndInject(jsxString: string, v: DViewElement): string {\r\n        let jsxCompiled: DocString<ReactNode>;\r\n        let e: any;\r\n        try { jsxCompiled = JSXT.fromString(jsxString, {factory: 'React.createElement'}); }\r\n        catch (ee: any) { e = ee; jsxCompiled = GraphElementComponent.displayError(e, \"JSX Syntax\", v, undefined, undefined, true) as any; }\r\n        return jsxCompiled;\r\n    }\r\n    static stopEvt(e: GObject<React.SyntheticEvent>): void{\r\n        if (!e) return;\r\n        e.persist?.();\r\n        (e as any).stopImmediatePropagation?.();\r\n        e.stopPropagation?.();\r\n        let ne: any = e.nativeEvent;\r\n        e._jjIsStopped = true;\r\n        if (!ne) return;\r\n        ne.stopImmediatePropagation?.();\r\n        ne.stopPropagation?.();\r\n        if (!ne.isPropagationStopped) ne.isPropagationStopped = ()=>true;\r\n        ne._jjIsStopped = true;\r\n    }\r\n    static isStoppedEvt(e: GObject<React.SyntheticEvent>): boolean{\r\n        if (!e) return true;\r\n        if (e._jjIsStopped || e.isPropagationStopped?.()) return true;\r\n        let ne: any = e.nativeEvent;\r\n        if (!ne) return false;\r\n        return !!(ne._jjIsStopped || ne.isPropagationStopped?.());\r\n    }\r\n\r\n    static options(validTargets: MultiSelectOptGroup[]): JSX.Element[] {\r\n        return validTargets\r\n            .filter(e=>!!e)\r\n            .map(e => <optgroup label={e.label}>\r\n                { e.options.filter(o=>!!o).map(o=><option value={o.value} key={o.value} title={o.title}>{o.label}</option>) }\r\n            </optgroup>);\r\n    }\r\n    /*\r\n    does not catch: visibility: hidden, opacity:0, invisible stuff inside a overflow:scroll element, overlapping z-index (returns true)\r\n    does catch display:none, top:-999999px, width:0 (returns false)\r\n    possibly zoom can mess it up\r\n    */\r\n    static isElementInViewport(el?: Element, includePartiallyVisible: boolean = true): boolean {\r\n        if (!el) return false;\r\n        var rect = el.getBoundingClientRect(); // safely returns a 0-filled struct for non-in-dom elements\r\n        return (\r\n            rect.top + (includePartiallyVisible ? rect.height : 0) >= 0 &&\r\n            rect.left + (includePartiallyVisible ? rect.width : 0)  >= 0 &&\r\n            rect.bottom <= (window.innerHeight || document.documentElement.clientHeight) &&\r\n            rect.right <= (window.innerWidth || document.documentElement.clientWidth)\r\n        );\r\n    }\r\n    static onVisibilityChange(el: Element, callback: ()=>any):(()=>void) {\r\n        var old_visible: boolean;\r\n        return function () {\r\n            var visible = UX.isElementInViewport(el);\r\n            if (visible === old_visible) return;\r\n            old_visible = visible;\r\n            if (typeof callback == 'function') { callback(); }\r\n        }\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\common\\DV.tsx",["1127","1128","1129","1130","1131","1132","1133","1134","1135","1136","1137","1138"],"import {\r\n    DGraphElement, Dictionary,\r\n    DModelElement,\r\n    DViewElement,\r\n    DViewPoint,\r\n    DVoidEdge,\r\n    EdgeBendingMode,\r\n    EdgeHead,\r\n    GObject,\r\n    GraphPoint, LPointerTargetable, LViewElement,\r\n    Pointer,\r\n    RuntimeAccessible,\r\n    ShortAttribETypes as SAType,\r\n    U, Draggable, Measurable\r\n} from '../joiner';\r\nimport React, {ReactNode, useState} from \"react\";\r\nimport {PaletteType} from \"../view/viewElement/view\";\r\nimport \"./error.scss\";\r\n\r\nconst notificationType: 'classic'|'alert'|'notification' = 'notification';\r\n\r\n// const beautify = require('js-beautify').html; // BEWARE: this adds some newline that might be breaking and introduce syntax errors in our JSX parser\r\nconst beautify = (s: string) => s;\r\nlet ShortAttribETypes: typeof SAType = (window as any).ShortAttribETypes;\r\n\r\n@RuntimeAccessible('DV')\r\nexport class DV {\r\n    public static invisibleJsx(): string { return ''; }\r\n    public static modelView(): string { return beautify(DefaultView.model()); }\r\n    public static packageView(): string { return beautify(DefaultView.package()); }\r\n    public static classView(): string { return beautify(DefaultView.class()); }\r\n    public static attributeView(): string { return beautify(DefaultView.feature()); }\r\n    public static referenceView(): string { return beautify(DefaultView.feature()); }\r\n    public static enumeratorView(): string { return beautify(DefaultView.enum()); }\r\n    public static literalView(): string { return beautify(DefaultView.literal()); }\r\n    public static fallbackView(): string { return beautify(DefaultView.void()); }\r\n    public static operationView(): string { return beautify(DefaultView.operation()); }\r\n    public static parameterView(): string { return beautify(DefaultView.parameter()); }\r\n\r\n    // i want to keep it because it will be useful for a candidate next feature in m1 & layoutable elements\r\n    // it is still work in progress.\r\n    public static operationViewm1(): string { return beautify(DefaultView.operationm1()); }\r\n    public static objectView(): string { return beautify(DefaultView.object()); }\r\n    public static valueView(): string { return beautify(DefaultView.value()); }\r\n    public static singletonView(): string { return beautify(DefaultView.singleton()); }\r\n    public static defaultPackage(): string { return beautify(DefaultView.defaultPackage()); }\r\n\r\n    public static errorView(publicmsg: ReactNode, debughiddenmsg:any, errortype: string, data?: DModelElement | undefined, node?: DGraphElement | undefined, v?: LViewElement|DViewElement): React.ReactNode {\r\n        let visibleMessage = publicmsg && typeof publicmsg === \"string\" ? U.replaceAll(publicmsg, \"Parse Error:\", \"\").trim() : publicmsg;\r\n        console.error(\"error in view:\", {publicmsg, debuginfo:debughiddenmsg});\r\n        return DefaultView.error(visibleMessage, errortype, data, node, v); }\r\n    public static errorView_string(publicmsg: string, debughiddenmsg:any, errortype: string, data?: DModelElement | undefined, node?: DGraphElement | undefined, v?: LViewElement|DViewElement): React.ReactNode {\r\n        let visibleMessage = publicmsg && typeof publicmsg === \"string\" ? U.replaceAll(publicmsg, \"Parse Error:\", \"\").trim() : publicmsg;\r\n        console.error(\"error in view:\", {publicmsg, debuginfo:debughiddenmsg});\r\n        return DefaultView.error_string(visibleMessage, errortype, data, node, v); }\r\n\r\n    // {ancors.map( a => <EdgePoint view={\"aaaaa\"} initialSize={{x: node.w * a.x, y: node.h * a.y}}/>)}\r\n    public static anchorJSX(): string { return (`\r\n<div className={\"overlap\"}>\r\n{Object.keys(anchors).map( (k) => { let a = anchors[k]; return(\r\n<div className={\"anchor draggable resizable\"} data-anchorName={a.name} data-anchorKey={k}\r\n    onDragEnd={(coords/*Point*/)=>node.events.dragAnchor(coords, k)} onMouseUp={()=>{node.events.assignAnchor(k)}}\r\n    style={{left: 100*a.x+'%', top:100*a.y+'%', width:a.w+'px', height:a.h+'px'}} />)})\r\n}</div>\r\n`);}\r\n    static edgePointView(): string { return beautify((\r\n`<div className={\"edgePoint\"} tabIndex=\"-1\">\r\n    {decorators}\r\n</div>`\r\n))}\r\n    static edgePointViewSVG(): string { return beautify(\r\n        `<ellipse stroke={\"black\"} fill={\"red\"} cx={\"50\"} cy={\"50\"} rx={\"20\"} ry={\"20\"} />`\r\n        //`<ellipse stroke={\"black\"} fill={\"red\"} cx={props.node.x} cy={props.node.y} rx={props.node.w} ry={props.node.h} />`\r\n    )}\r\n\r\n    static svgHeadTail(head: \"head\" | \"tail\", type: EdgeHead): string | undefined {\r\n        let ret: string;\r\n        let headstr = head===\"head\" ? \"segments.head\" : \"segments.tail\";\r\n        let styleTranslateRotate = 'transform:\"translate(\" + ' + headstr + '.x + \"px, \" + ' + headstr + '.y + \"px) rotate(\" + (' + headstr + '.rad) + \"rad)\",' +\r\n            ' \"transformOrigin\":'+headstr+'.w/2+\"px \"+ '+headstr+'.h/2+\"px\"';\r\n        let attrs = `\\n\\t\\t\\t\\tstyle={{`+styleTranslateRotate +`}}\\n\\t\\t\\t\\tclassName={\"` + head + ` ` + type +` preview\"} />\\n`;\r\n        let path: string;\r\n        let hoverAttrs = `\\n\\t\\t\\t\\tstyle={{`+styleTranslateRotate +`}}\\n\\t\\t\\t\\tclassName={\"` + head + ` ` + type +` clickable content\"} tabIndex=\"-1\" />\\n`;\r\n        let d: string;\r\n        switch (type) {\r\n            default:\r\n                ret = \"edge '\" + head + \"' with type: '\" +type + \"' not found\";\r\n                break;\r\n            case EdgeHead.extend:\r\n                //if (head === \"tail\") return undefined;\r\n                d = `M 0 0   L x y/2   L 0 y   Z`;\r\n                path = `<path  `;\r\n                ret = path + attrs + \"\\n\\t\\t\\t\\t\" + path + hoverAttrs;\r\n                break;\r\n            case EdgeHead.reference:\r\n                //if (head === \"tail\") return undefined;\r\n                d = `M 0 0   L x y/2   L 0 y`;\r\n                path = `<path  `;\r\n                ret = path + attrs + \"\\n\\t\\t\\t\\t\" + path + hoverAttrs;\r\n                break;\r\n            case EdgeHead.aggregation:\r\n                //if (head === \"head\") return undefined;\r\n                d = `M 0 y/2   L x/2 0   L x y/2   L x/2 y   Z`;\r\n                path = `<path  `;\r\n                ret = path + attrs + \"\\n\\t\\t\\t\\t\" + path + hoverAttrs;\r\n                break;\r\n            case EdgeHead.composition:\r\n                //if (head === \"head\") return undefined;\r\n                d = `M 0 y/2   L x/2 0   L x y/2   L x/2 y   Z`;\r\n                path = `<path  `;\r\n                ret = path + attrs + \"\\n\\t\\t\\t\\t\" + path + hoverAttrs;\r\n                break;\r\n                /* `<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" style={overflow: \"visible\"}>\r\n                                            <path d={\"M 10 0 L 0 20 L 20 20 Z\"} fill=\"#ffffff\" stroke=\"#808080\" strokeWidth=\"1\"></path>\r\n                                         </svg>`;*/\r\n                //  style={transform: \"rotate3d(xcenter, ycenter, zcenter??, 90deg)\"}\r\n        }\r\n        //  transform={\"rotate(\"+`+headstr+`.rad+\"rad \"+ segments.all[0].start.pt.toString(false, \" \")}\r\n        return ret; // no wrap because of .hoverable > .preview  on root & subelements must be consecutive\r\n        // return `<g className=\"edge`+head + ` ` + type +`\" style={` + styleTranslate + `}>\\n`+ ret +`</g>`\r\n    }\r\n\r\n    // about label rotation in .edge > foreignObect > div (label)\r\n    // first transform is h-center. second is rotate, third adds [0, 50%] of 50% vertical offset AFTER rotation to take label out of edge. fourth is to add a margin.\r\n    static edgeView(modename: EdgeHead, headSize: GraphPoint, tailSize: GraphPoint, dashing: string | undefined, vp: DViewElement, name: string): DViewElement {\r\n        let fill: string;\r\n        switch (modename){\r\n            case EdgeHead.reference:\r\n            default: fill = '#fff0'; break;\r\n            case EdgeHead.composition: fill = '#000'; break;\r\n            case EdgeHead.aggregation:\r\n            case EdgeHead.extend: fill = '#fff'; break;\r\n        }\r\n\r\n        const agglabel = \"◇ Aggregation / Composition\";\r\n        const extendlabel = \"△ \"+EdgeHead.extend;\r\n        const asslabel = \"Λ \"+EdgeHead.reference;\r\n        let headdict: Dictionary<string, string> = {\r\n            [asslabel]: 'M 0 0   L x y/2   L 0 y',\r\n            [extendlabel]: 'M 0 0   L x y/2   L 0 y   Z',\r\n            [agglabel]: 'M 0 y/2   L x/2 0   L x y/2   L x/2 y   Z',\r\n        };\r\n        let predefinedPaths: {k:string, v:string}[] = Object.entries(headdict).map((e)=>({k:e[0], v:e[1]}));\r\n\r\n        let headPath: string = '', tailPath: string = '';\r\n        switch (modename) {\r\n            default: break;\r\n            case EdgeHead.extend: headPath = extendlabel; break;\r\n            case EdgeHead.reference: headPath = asslabel; break;\r\n            case EdgeHead.aggregation: tailPath = agglabel; break;\r\n            case EdgeHead.composition: tailPath = agglabel; break;\r\n        }\r\n        headPath = headdict[headPath] || '';\r\n        tailPath = headdict[tailPath] || '';\r\n\r\n        let palette: PaletteType = {\r\n            'anchorSize': {type: 'number', value:20, unit:'px'},\r\n            'dashing': {value:dashing || '', type: \"text\"},\r\n            'stroke-color': U.hexToPalette('#777'),\r\n            'stroke-width': {value:1, type: 'number', unit: 'px'},\r\n            'stroke-color-hover': U.hexToPalette('#000'),\r\n            'stroke-width-hover': {value:3, type: 'number', unit: 'px'},\r\n            'head': {type:'path', value:headPath, options: predefinedPaths, x:'edgeHeadSize.x', y:'edgeHeadSize.y'},\r\n            'tail': {type:'path', value:tailPath, options: predefinedPaths, x:'edgeTailSize.x', y:'edgeTailSize.y'},\r\n            'fill': U.hexToPalette(fill),\r\n        };\r\n\r\n        let css = \".edge-anchor{\" +\r\n        \"\\n\\tcursor: crosshair;\" +\r\n        \"\\n\\tstroke: transparent;\" +\r\n        \"\\n\\tfill: none;\" +\r\n        \"\\n\\tr:var(--anchorSize);\" +\r\n        \"\\n\\toutline: var(--stroke-width) solid var(--stroke-color);\"+\r\n        \"\\n\\toutline-offset: calc(var(--stroke-width) * -1);\" +\r\n        \"\\n\\tborder-radius: 100%;\" +\r\n        \"\\n}\" +\r\n        \"\\n.clickthrough, .unclickable{\" +\r\n        \"\\n\\tpointer-events: none;\" +\r\n        \"\\n}\" +\r\n        \"\\n.clickable{\" +\r\n        \"\\n\\tpointer-events: all;\" +\r\n        \"\\n}\" +\r\n        \"\\n.fullscreen{\" +\r\n        \"\\n\\toverflow: visible;\" +\r\n        \"\\n\\twidth: 100vw;\" +\r\n        \"\\n\\theight: 100vh;\" +\r\n        \"\\n}\" +\r\n        \"\\npath{\" +\r\n        \"\\n\\tfill: none;\" +\r\n        \"\\n\\tstroke-dasharray: var(--dashing);\" +\r\n        \"\\n\\t&.head{\" +\r\n        \"\\n\\t\\td: path(var(--head));\" +\r\n        \"\\n\\t}\" +\r\n        \"\\n\\t&.tail{\" +\r\n        \"\\n\\t\\td: path(var(--tail));\" +\r\n        \"\\n\\t}\" +\r\n        \"\\n}\" +\r\n        \"\\npath.edge.full, path.tail, path.head{\" +\r\n        \"\\n\\tstroke: var(--stroke-color);\" +\r\n        \"\\n\\tstroke-width: var(--stroke-width);\" +\r\n        \"\\n}\" +\r\n        \"\\npath.tail, path.head{\" +\r\n        \"\\n\\tfill:var(--fill);\" +\r\n        \"\\n}\" +\r\n        \"\\npath.edge.full.hover-activator{\" +\r\n        \"\\n\\tstroke-width: var(--stroke-width-hover);\" +\r\n        \"\\n\\tstroke: none;\" +\r\n        \"\\n}\" +\r\n        \"\\npath.content{\" +\r\n        \"\\n\\tstroke: var(--stroke-color-hover);\" +\r\n        \"\\n\\tstroke-width: var(--stroke-width-hover);\" +\r\n        \"\\n}\" +\r\n        \"\\n.label-text{\" +\r\n        \"\\n\\tcolor: var(--stroke-color);\" +\r\n        \"\\n}\" +\r\n        \"\\nforeignObject.label{\" +\r\n        \"\\n\\toverflow: visible;\" +\r\n        \"\\n\\tcolor: var(--stroke-color);\" +\r\n        \"\\n\\twidth: 0;\" +\r\n        \"\\n\\theight: 0;\" +\r\n        \"\\n\\twhite-space: pre;\" +\r\n        \"\\n\\t> div{\" +\r\n        \"\\n\\t\\twidth: fit-content;\" +\r\n        \"\\n\\t}\" +\r\n        \"\\n}\" +\r\n        \"\\n\\t\" +\r\n        \"\\n\\t\" +\r\n        \"\";\r\n        let head = DV.svgHeadTail(\"head\", modename) || '';\r\n        let tail = DV.svgHeadTail(\"tail\", modename) || '';\r\n        let jsx = beautify(\r\n        `<div className={\"edge hoverable hide-ep clickthrough fullscreen ` + modename + `\"}>\r\n            <svg className={\"clickthrough fullscreen\"}>\r\n                { /* edge full paths\r\n               \r\n                 first is preview path, normally seen\r\n                 third (segmented) is path onHover\r\n                 second is to enlarge the hover area of path.preview to the same as path.content, so i avoid hover loop enter-leave and graphical flashing\r\n                \r\n                */ }\r\n                <path className={\"preview edge full` + (dashing ? ' dashed' : '') + `\"} d={this.edge.d} />\r\n                <path className={\"preview edge full hover-activator\"} d={this.edge.d} />\r\n                { /* edge separate segments */ }\r\n                {segments && segments.all && segments.all.flatMap(s => [\r\n                    <path tabIndex=\"-1\" className={\"clickable content segment\"} d={s.dpart}></path>,\r\n                    s.label && <foreignObject className=\"label\" x={(s.start.pt.x + s.end.pt.x)/2+\"px\"} y={(s.start.pt.y + s.end.pt.y)/2+\"px\"}>\r\n                    <div className={\"label-text\"}\r\n                     style={{transform: \"translate(-50%, 0%) rotate(\"+s.radLabels+\"rad) translate(0%, -\"+(1-0.5*Math.abs(Math.abs(s.radLabels)%Math.PI)/(Math.PI/2))*100+\"%)\"+\r\n                     \" translate(0%, -5px\"}}>{s.label}</div>\r\n                    </foreignObject>\r\n                ])}\r\n                { /* edge head */ }\r\n                ` + head + `\r\n                { /* edge tail */ }\r\n                ` + tail + `\r\n                { /* edge anchor start */ }\r\n                {edge.start && <circle className=\"edge-anchor content clickable no-drag\"\r\n                 style={{transform: \"translate(\" + segments.all[0].start.pt.x +\"px, \" + segments.all[0].start.pt.y +\"px)\"}}\r\n                 onMouseDown={()=> edge.startFollow=true}\r\n                 onMouseUp={()=> edge.startfollow=false} />}\r\n                { /* edge anchor end */ }\r\n                {edge.end && <circle className=\"edge-anchor content clickable no-drag\" `+ // cx={0*segments.all.last().end.pt.x} cy={0*segments.all.last().end.pt.y}\r\n                `style={{transform: \"translate(\" + segments.all.last().end.pt.x +\"px, \" + segments.all.last().end.pt.y +\"px)\"}}\r\n                 onMouseDown={()=> edge.endFollow=true}\r\n                 onMouseUp={()=> edge.endfollow=false} />}\r\n\r\n            </svg>\r\n            { /* interactively added edgepoints */ }\r\n            {\r\n                edge.midPoints.map( m => <EdgePoint data={edge.father.model.id} initialSize={m} key={m.id} view={\"EdgePoint\"} /> )\r\n            }\r\n            {decorators}\r\n        </div>`\r\n    );\r\n        let edgePrerenderFunc: string = \"(ret)=>{\\n\" +\r\n            \"// ** preparations and default behaviour here ** //\\n\" +\r\n            \"// add preparation code here (like for loops to count something), then list the dependencies below.\\n\" +\r\n            \"// ** declarations here ** //\\n\" +\r\n            \"\\n\"+\r\n            \"}\";\r\n\r\n        let edgeUsageDeclarations = \"(ret)=>{\\n\" +\r\n            \"// ** preparations and default behaviour here ** //\\n\" +\r\n            \"// ret.data = data\\n\" +\r\n            \"ret.edgeview = edge.view.id\\n\" +\r\n            \"ret.view = view\\n\" +\r\n            \"// data, edge, view are dependencies by default. delete them above if you want to remove them.\\n\" +\r\n            \"// add preparation code here (like for loops to count something), then list the dependencies below.\\n\" +\r\n            \"// ** declarations here ** //\\n\" +\r\n            \"ret.start = edge.start\\n\"+\r\n            \"ret.end = edge.end\\n\"+\r\n            \"ret.segments = edge.segments\\n\"+\r\n            \"}\";\r\n        let ev = DViewElement.new2(\"Edge\"+name, jsx, vp,\r\n            (v: DViewElement) => {\r\n                // v.appliableToClasses = [DVoidEdge.cname];\r\n                v.appliableTo = 'Edge';\r\n                v.bendingMode = EdgeBendingMode.Line;\r\n                v.edgeHeadSize = headSize;\r\n                v.edgeTailSize = tailSize;\r\n                //v.constants = edgeConstants;\r\n                v.palette = palette;\r\n                v.css = css\r\n                v.usageDeclarations = edgeUsageDeclarations;\r\n                v.preRenderFunc = edgePrerenderFunc;\r\n            }, false, 'Pointer_ViewEdge' + name);\r\n        return ev;\r\n    }\r\n    /*\r\n    {\r\n        false && edge.end.model.attributes.map( (m, index, arr) => <EdgePoint data={m.id} initialSize={(parent) => {\r\n            let segs = parent.segments.segments;\r\n            let pos = segs[0].start.pt.multiply(1-(index+1)/(arr.length+1), true).add(segs[segs.length-1].end.pt.multiply((index+1)/(arr.length+1), true));\r\n            // console.trace(\"initial ep\", {segs, pos, ratio:(index+1)/(arr.length+1), s:segs[0].start.pt, e:segs[segs.length-1].end.pt});\r\n            return {...pos, w:55, h:55}}} key={m.id} view={\"Pointer_ViewEdgePoint\"} /> )\r\n    }{\r\n        false && <EdgePoint key={\"midnode1\"} view={\"Pointer_ViewEdgePoint\"} />\r\n    }{\r\n        false && <EdgePoint key={\"midnode2\"} view={\"Pointer_ViewEdgePoint\"} />\r\n    }{\r\n        false && props.children && \"this would cause loop no idea why, needs to be fixed to allow passing EdgeNodes here\" || []\r\n    }\r\n    */\r\n    static semanticErrorOverlay_old() { return (\r\n`<section className=\"overlap\">\r\n    <div className=\"error-message\">Lowerbound violation</div>\r\n</section>`\r\n)}    static semanticErrorOverlay() { return (\r\n`<section className=\"overlap\">\r\n    <div className=\"error-message\">{errors.join(<br/>)}</div>\r\n</section>`\r\n)}\r\n\r\n\r\n} // DV class end\r\n\r\nlet valuecolormap: GObject = {};\r\nvaluecolormap[ShortAttribETypes.EBoolean] = \"orange\";\r\nvaluecolormap[ShortAttribETypes.EByte] = \"orange\";\r\nvaluecolormap[ShortAttribETypes.EShort] = \"orange\";\r\nvaluecolormap[ShortAttribETypes.EInt] = \"orange\";\r\nvaluecolormap[ShortAttribETypes.ELong] = \"orange\";\r\nvaluecolormap[ShortAttribETypes.EFloat] = \"orange\";\r\nvaluecolormap[ShortAttribETypes.EDouble] = \"orange\";\r\nvaluecolormap[ShortAttribETypes.EDate] = \"green\";\r\nvaluecolormap[ShortAttribETypes.EString] = \"green\";\r\nvaluecolormap[ShortAttribETypes.EChar] = \"green\";\r\nvaluecolormap[ShortAttribETypes.EVoid] = \"gray\";\r\n\r\nlet valuecolormap_str = JSON.stringify(valuecolormap); // can this be declared inside view.constants ?\r\n\r\n\r\ntype ErrorProps = {\r\n    dname: any,\r\n    nodename: any,\r\n    errortype: any,\r\n    on: any,\r\n    v: any,\r\n    msg: any\r\n};\r\n\r\n\r\n\r\n\r\n\r\nexport class DefaultView {\r\n\r\n    /* MODEL */\r\n\r\n    public static model(): string { return (\r\n`<View className={\\`root model ` + \"${grid && 'grid'}\" + `\\`}>\r\n<Scrollable graph={node}>\r\n    {!data && \"Model data missing.\"}\r\n    <div className={'edges'}>\r\n        {[\r\n            refEdges.map(se => <Edge data={se.start} start={se.startVertex} end={se.endVertex} anchorStart={0} anchorEnd={0} key={se.id} isReference={true} \r\n            view={'Edge' + (se.start.composition ? 'Composition' : (se.start.aggregation ? 'Aggregation' : 'Association'))} />),\r\n            extendEdges.map(se => <Edge data={se.start} start={se.startVertex} end={se.endVertex} view={'EdgeInheritance'} isExtend={true} key={se.id} />)\r\n        ]}\r\n    </div>\r\n    {/* metamodel only */}\r\n    {[\r\n        otherPackages.filter(p => p).map(pkg => <DefaultNode key={pkg.id} data={pkg} />),\r\n        level >= 1 && firstPackage && firstPackage.children.filter(c => c).map(classifier => <DefaultNode key={classifier.id} data={classifier} />)\r\n    ]}\r\n\r\n    {/* model only */}\r\n    {level >= 1 && m1Objects.filter(o => o).map(m1object => <DefaultNode key={m1object.id} data={m1object} />)}\r\n    {decorators}\r\n</Scrollable>\r\n\r\n{/* language designer defined controls */}\r\n<Control title={'Workbench'} payoff={'Options'}>\r\n    <Slider name={'level'} title={'Detail level '} node={node} max={3} />\r\n    <Toggle name={'grid'} title={'Grid'} node={node} />\r\n</Control>\r\n</View>`\r\n);}\r\n\r\n\r\n    public static void(): string { return (\r\n`<div className={'root void model-less round bg-white p-1'}>\r\n    <div>voidvertex element test</div>\r\n    <div>data: {props.data ? props.data.name : \"empty\"}</div>\r\n    {decorators}\r\n</div>`\r\n);}\r\n\r\n    /* PACKAGE */\r\n\r\n    public static package(): string { return (\r\n`<View className={'root package'}>\r\n    <Measurable draggable={true} resizable={true}><div>draggable resizable</div></Measurable>\r\n    <Measurable draggable={true}><div>draggable</div></Measurable>\r\n    <div className={'package-children'}>\r\n        {upperLevel >= 1 ? [\r\n            <label className={\"detail-level\"}>\r\n                <input onChange={(e)=>{node.state = {level:+e.target.value}}} min=\"0\" max=\"3\" type=\"range\" step=\"1\" value={level}/>\r\n                <div>Detail level:{level}</div>\r\n            </label>,\r\n            data.children.map(c => <DefaultNode key={c.id} data={c} />)\r\n        ] :\r\n        [\r\n            <div className={\"summary\"}><b>URI:</b><span className={\"ms-1\"}>{data.uri}</span></div>,\r\n            <div className={\"summary\"}>{[\r\n                data.classes.length ? data.classes.length + \" classes\" : '',\r\n                data.enumerators.length ? data.enumerators.length + \" enumerators\" : ''\r\n               ].filter(v=>!!v).join(',')}</div>\r\n        ]}\r\n    </div>\r\n    {decorators}\r\n</View>`\r\n);}\r\n\r\n    public static defaultPackage(): string { return (\r\n`<div className={'root package'}>\r\n    <div className={'package-children'}>\r\n        {data.children.map(c => <DefaultNode key={c.id} data={c} />)}\r\n    </div>\r\n    {decorators}\r\n</div>`\r\n);}\r\n\r\n    /* CLASS */\r\n\r\n// <View className={\"root class \" + (level === 1 && abstract ? \"abstract\")} + onClick={()=>{/*node.events.e1(Math.random().toFixed(3))*/}}>\r\n\r\npublic static class(): string { return (`<View className={\"root class\"} onClick={()=>{/*node.events.e1(Math.random().toFixed(3))*/}}>\r\n<div className={'header'}>\r\n    {data.isSingleton && <i className='bi bi-1-square'>&nbsp;</i>}\r\n    {level > 1 && <b className={'class-name'}>{interface ? 'Interface' : abstract ? 'Abstract Class' : 'Class'}: </b>}    \r\n    {level === 1 && <i className=\"bi bi-c-square-fill\"></i>}<Input data={data} field={'name'} hidden={true} autosize={true} />\r\n</div>\r\n\r\n{level > 2 && data.children.length > 0 && <hr/>}\r\n\r\n{level > 2 && \r\n    <div className={'class-children'}>\r\n        {level >= 2 && [\r\n            attributes.map(c => <DefaultNode key={c.id} data={c} />),\r\n            references.map(c => <DefaultNode key={c.id} data={c} />),\r\n            operations.map(c => <DefaultNode key={c.id} data={c} />)\r\n        ]\r\n        || [\r\n        <div className={\"summary\"}>{[\r\n            attributes.length ? attributes.length + \" attributes\" : '',\r\n            references.length ? references.length + \" references\" : '',\r\n            operations.length ? operations.length + \" operations\" : '',\r\n            !(attributes.length + references.length + operations.length) ? '- empty -' : ''\r\n            ].filter(v=>!!v).join(',')}</div>\r\n        ]\r\n        }\r\n    </div>\r\n}\r\n\r\n{decorators}\r\n</View>`);}\r\n\r\n\r\n    /* ENUM */\r\n\r\npublic static enum(): string { return (\r\n`<View className={'root enumerator'}>\r\n    <div className={'header'}>\r\n        {level > 1 && <b className={'enumerator-name'}>Enum:</b>}\r\n        {level == 1 && <i className=\"bi bi-explicit-fill\"></i>}<Input data={data} field={'name'} hidden={true} autosize={true} />\r\n    </div>\r\n    {level > 1 && <hr />}\r\n    <div className={'enumerator-children'}>\r\n        {level >= 2 && literals.map(c => <DefaultNode key={c.id} data={c}/>)}\r\n    </div>\r\n    {decorators}\r\n</View>`\r\n);}\r\n\r\n    /* FEATURE */\r\n\r\n    public static feature(): string { return (\r\n`<View className={'root feature w-100'}>\r\n    <span className={'feature-name'}>{data.name}:</span>\r\n    <Select data={data} field={'type'} />\r\n    {decorators}\r\n</View>`\r\n);}\r\n\r\n    /* LITERAL */\r\n\r\n    public static literal(): string { return (\r\n`<label className={'root literal d-block text-center'}>\r\n    {data.name}\r\n    {decorators}\r\n</label>`\r\n);}\r\n\r\n    /* OPERATION */\r\n\r\n    public static operation(): string { return (\r\n`<View className={'root operation w-100 hoverable'}>\r\n        <span className={'feature-name'}>{data.name + ' =>'}</span>\r\n        <Select data={data} field={'type'} />\r\n    <div className={\"parameters content\"}>\r\n    {data.exceptions.length ? \" throws \" + data.exceptions.join(\", \") : ''}\r\n    {\r\n        level >= 3 && data.parameters.map(p => <DefaultNode data={p} key={p.id} />)\r\n    }</div>\r\n    {decorators}\r\n</View>`\r\n);}\r\n\r\n    /* PARAMETER */\r\n\r\npublic static parameter(): string { return (\r\n`<View className={'root parameter w-100'}>\r\n    <span className={'feature-name'}>\r\n        {data.name + '' + (data.lowerBound === 0 ? '?:' : ':' )}\r\n    </span>\r\n    <Select data={data} field={'type'} />\r\n    <span className={\"modifier\"}>{data.upperBound > 1 || data.upperBound === -1 ? '[]' : ''}</span>\r\n    {decorators}\r\n</View>`\r\n);}\r\n\r\n    // i want to keep it because it will be useful for a candidate next feature in m1 & layoutable elements\r\n    // it is still work in progress.\r\n    public static operationm1(): string { return (\r\n`<div className={'d-flex root operationm1'} style={{paddingRight: \"6px\"}}>\r\n    <label className={'d-block ms-1'}>{this.props.data.instanceof.name}</label>\r\n    <label className={'d-block ms-auto hover-root'} style={{color:` + valuecolormap_str + `[this.props.data.values.type] || \"gray\"}}>\r\n        →→→\r\n        <div className=\"hover-content\">\r\n            <ParameterForm operation={this.props.data.id} vertical={true} />\r\n        </div>\r\n    </label>\r\n    {decorators}\r\n</div>`\r\n);}\r\n\r\n    public static objectOld(): string { return (\r\n`<div className={'round bg-white root class'}>\r\n    <label className={'ms-1'}>\r\n        <Input jsxLabel={<b className={'object-name'}>{data.instanceof ? data.instanceof.name : \"Object\"}:</b>} \r\n           data={data} field={'name'} hidden={true} autosize={true}/>\r\n    </label>\r\n    <hr />\r\n    <div className={'object-children'}>\r\n        { features.map(c => <DefaultNode key={c.id} data={c} />) }\r\n    </div>\r\n    {decorators}\r\n</div>`);\r\n}\r\n\r\n//     public static object(): string { return (\r\n// `<View className={'root object'}>\r\n//     <b className={'object-name'}>{data.instanceof ? data.instanceof.name : 'Object'}:</b>\r\n//     <Input data={data} field={'name'} hidden={true} autosize={true} />\r\n//     <hr/>\r\n//     <div className={'object-children'}>\r\n//         {level >= 2 && data.features.map(f => <DefaultNode key={f.id} data={f} />)}\r\n//     </div>\r\n//     {decorators}\r\n// </View>`\r\n// );}\r\n\r\n/* OBJECT */\r\n\r\npublic static object(): string { return (\r\n`<View className={'root object'}>\r\n    <b className={'object-name'}>{data.instanceof ? data.instanceof.name : 'Object'}:</b>\r\n    <Input data={data} field={'name'} hidden={true} autosize={true} />\r\n    <hr/>\r\n    <div className={'object-children'}>\r\n        {level >= 2 && data.features.map(f => <DefaultNode key={f.id} data={f} />)}\r\n    </div>\r\n    {decorators}\r\n</View>`\r\n);}\r\n\r\n    /* VALUE */\r\n\r\n    public static value() { return (\r\n`<View className={'root value d-flex'}>\r\n    {instanceofname && <label className={'d-block ms-1 name'}>{instanceofname}</label>}\r\n    {!instanceofname && <Input className='name' data={data} field={'name'} hidden={true} autosize={true} />}\r\n    <label className={'d-block m-auto values_str'} style={{color: constants[typeString] || 'gray'}}>\r\n        : {valuesString}\r\n    </label>\r\n    {decorators}\r\n</View>`\r\n);}\r\n\r\n    /* SINGLETON OBJECT */\r\n\r\n    public static singleton(): string { return (\r\n    `<div className={'singleton'}>\r\n        <div className={'header'}>\r\n            {data.name}        \r\n        </div>\r\n    </div>`);}\r\n\r\n    /* ERROR */\r\n\r\n    \r\n\r\n    public static error(msg: undefined | ReactNode, errortype: string | \"SYNTAX\" | \"RUNTIME\",\r\n                        data?: DModelElement | undefined, node?: DGraphElement | undefined, v?: LViewElement|DViewElement): React.ReactNode {\r\n\r\n        let dname: string | undefined = data && ((data as any).name || data.className.substring(1));\r\n        if (dname && dname.length >= 10) dname = dname.substring(0, 7) + '…';\r\n        let nodename: string = (node?.className || '').replace(/[^A-Z]+/g, \"\").substring(1);\r\n        let on = dname && nodename ? \" on \" + dname + \" / \" + nodename : (dname || nodename ? \" on \" + (dname || nodename) : '');\r\n\r\n        let lv: LViewElement | undefined = v ? ((v as any).__isProxy ? v as LViewElement : LPointerTargetable.wrap(v)) : undefined;\r\n        let viewpointname = lv?.viewpoint?.name ||'';\r\n\r\n        function openNotification(e: any) {\r\n            U.alert('e', 'Error in ' + v?.name + (viewpointname ? ' > '+viewpointname : ''), dname);\r\n            e.target.classList.add('opened');\r\n        }\r\n\r\n        switch (notificationType) {\r\n            case 'classic':\r\n                return (<Measurable draggable={true} resizable={true}><div className={'error-notification'}>\r\n                        <h1>Something Went Wrong...</h1>\r\n                        {v && <h2>Error in \"{v?.name}\" syntax view definition{viewpointname? ' in viewpoint ' + viewpointname : ''}.</h2>}\r\n                        <div className={'error-type'}>\r\n                            <b data-dname={dname} data-nodename={nodename} data-str={false}>\r\n                                {errortype} Error {on}\r\n                                {false && v && <div>While applying view \"{v?.name}\"</div>}\r\n                            </b>\r\n                        </div>\r\n                        <div className={'error-details'}>{msg}</div>\r\n                    </div></Measurable>);\r\n                break;\r\n            case 'alert':\r\n                U.alert('e', 'Error in ' + v?.name + (viewpointname ? 'of '+viewpointname : ''), dname);\r\n                break;\r\n            case 'notification':\r\n                return (<div className='notification-icon' onClick={(e) => openNotification(e)}/>);\r\n                break;\r\n        }\r\n    }\r\n\r\n    public static error_string(msg: undefined | ReactNode, errortype: string | \"SYNTAX\" | \"RUNTIME\", data?: DModelElement | undefined,\r\n                               node?: DGraphElement | undefined, v?: LViewElement|DViewElement) {\r\n        let dname: string | undefined = data && ((data as any).name || data.className.substring(1));\r\n        if (dname && dname.length >= 10) dname = dname.substring(0, 7) + '…';\r\n        let nodename: string = (node?.className || '').replace(/[^A-Z]+/g, \"\").substring(1);\r\n        let on = dname && nodename ? \" on \" + dname + \" / \" + nodename : (dname || nodename ? \" on \" + (dname || nodename) : '');\r\n\r\n        let lv: LViewElement | undefined = v ? ((v as any).__isProxy ? v as LViewElement : LPointerTargetable.wrap(v)) : undefined;\r\n        let viewpointname = lv?.viewpoint?.name ||'';\r\n        // <div className={'w-100 h-100 round bg-white border border-danger'} style={{minHeight:\"50px\", overflow:\"scroll\"}}>\r\n        //     <div className={'text-center text-danger'} tabIndex={-1} style={{background:\"#fff\", overflow: 'visible', zIndex:100, minWidth:\"min-content\"}}>\r\n        //         <b>{errortype}_ERROR` + on + `</b>\r\n        //         <hr/>\r\n        //         <label className={'text-center mx-1 d-block'}>\r\n        //             While applying view \"${v?.name}\"\r\n        //         </label>\r\n        //         {${msg} && <label className={'text-center mx-1 d-block'} style={{color:\"black\"}}>${msg}</label>}\r\n        //     </div>\r\n        // </div>\r\n        return `<Measurable draggable={true} resizable={true}><div className={'error-notification'}>\r\n            <h1>Something Went Wrong...</h1>\r\n            `+ (v && `<h2>Error in \"${v?.name}\" syntax view definition${viewpointname ? ' in viewpoint ' + viewpointname : ''}.</h2>`)+`\r\n            <div className={'error-type'}>\r\n                <b data-dname=${dname} data-nodename=${nodename} data-str={true}>\r\n                    ${errortype} Error ${on}\r\n                    {false && v && <div>While applying view \"${v?.name}\"</div>}\r\n                </b>\r\n            </div>\r\n            <div className={'error-details'}>${msg}</div>\r\n        </div></Measurable>)`;\r\n    }\r\n\r\n\r\n}\r\n","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\redux\\store.tsx",["1139","1140","1141","1142","1143","1144","1145","1146","1147","1148","1149","1150","1151","1152","1153","1154","1155","1156","1157","1158","1159","1160","1161","1162","1163","1164","1165","1166","1167","1168","1169","1170","1171","1172","1173","1174","1175","1176","1177","1178","1179","1180","1181","1182","1183","1184","1185","1186","1187","1188","1189","1190"],"import {\r\n    Asterisk,\r\n    Circle,\r\n    Constructors,\r\n    CoordinateMode,\r\n    CreateElementAction, Cross,\r\n    DAttribute,\r\n    DClass,\r\n    DClassifier, Decagon, DecoratedStar, DEdge,\r\n    DEdgePoint,\r\n    Defaults,\r\n    DEnumerator,\r\n    DEnumLiteral,\r\n    DExtEdge,\r\n    DGraph,\r\n    DGraphElement,\r\n    DGraphVertex,\r\n    Dictionary,\r\n    DLog,\r\n    DModel,\r\n    DModelElement,\r\n    DObject, DocString,\r\n    DOperation,\r\n    DPackage,\r\n    DParameter,\r\n    DPointerTargetable,\r\n    DProject,\r\n    DRefEdge,\r\n    DReference,\r\n    DUser,\r\n    DValue,\r\n    DVertex,\r\n    DViewElement,\r\n    DViewPoint,\r\n    DVoidEdge, Edge,\r\n    EdgeBendingMode,\r\n    EdgeHead, EdgePoint, Ellipse,\r\n    Enneagon, Field,\r\n    GObject, Graph, GraphElement,\r\n    GraphPoint,\r\n    GraphSize, GraphVertex, Heptagon, Hexagon,\r\n    LGraphElement,\r\n    LModelElement,\r\n    LObject, Log,\r\n    LogicContext,\r\n    LOperation,\r\n    LPackage,\r\n    LParameter,\r\n    LPointerTargetable, LProject,\r\n    LRefEdge,\r\n    LReference,\r\n    LUser,\r\n    LValue,\r\n    LViewElement,\r\n    LViewPoint, Nonagon, Octagon,\r\n    Pentagon,\r\n    Pointer,\r\n    Pointers, Polygon, Rectangle,\r\n    RuntimeAccessible,\r\n    RuntimeAccessibleClass, Septagon, SetFieldAction,\r\n    SetRootFieldAction,\r\n    ShortAttribETypes, SimpleStar, Square, Star,\r\n    store, TRANSACTION, Trapezoid, Triangle, U, UserHistory, Vertex, VoidVertex,\r\n} from '../joiner';\r\nimport {DV} from \"../common/DV\";\r\n//import {Selected} from \"../joiner/types\";\r\nimport {DefaultEClasses, ShortDefaultEClasses} from \"../common/U\";\r\nimport { GraphElements, Graphs, Vertexes, Edges, Fields } from '../joiner';\r\nimport DefaultViews from \"./defaults/views\";\r\nimport tinycolor, {Instance} from \"tinycolor2\";\r\nimport {ReactNode} from \"react\";\r\nimport {VersionFixer} from \"./VersionFixer\";\r\nlet windoww: GObject<typeof window> = window;\r\nconsole.warn('ts loading store');\r\n\r\n// @RuntimeAccessible\r\n// NB: le voci che iniziano con '_' sono personali e non condivise\r\n\r\n\r\n// export const statehistory_obsoleteidea: {past: IStore[], current: IStore, future: IStore[]} = { past:[], current: null, future:[] } as any;\r\nexport const statehistory: {\r\n    [userpointer:Pointer<DUser>]: UserHistory,\r\n    all: UserHistory\r\n} & {\r\n    all: UserHistory,\r\n    globalcanundostate: boolean // set to true at first user click }\r\n} = {globalcanundostate: false, all: new UserHistory()} as any;\r\n(window as any).statehistory = statehistory;\r\n\r\n@RuntimeAccessible('DState')\r\nexport class DState extends DPointerTargetable{\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static new(): DState {\r\n        let ds = new DState('dwc');\r\n        new Constructors(ds, undefined, false, undefined)\r\n            .DPointerTargetable().DState();\r\n        // .end();\r\n        return ds; // do not trigger persist and CreateElement for state, or it will be stored in idlookup making a loop\r\n    }\r\n\r\n    // no need to manually update for each update\r\n    version:{n:number, date:string, conversionList: number[]} = {n:VersionFixer.get_highestversion(), date: new Date().toString(), conversionList: []};\r\n    timestamp!: number;\r\n    timestampdiff!: number;\r\n\r\n    env: Dictionary = process.env;  //damiano: this might make problems on load\r\n    debug: boolean = false;\r\n    logs: Pointer<DLog>[] = [];\r\n    models: Pointer<DModel, 0, 'N'> = []; // Pointer<DModel, 0, 'N'>[] = [];\r\n    m2models: Pointer<DModel, 0, 'N'> = [];\r\n    m1models: Pointer<DModel, 0, 'N'> = [];\r\n\r\n\r\n    viewelements: Pointer<DViewElement, 0, 'N'> = [];\r\n    stackViews: Pointer<DViewElement, 0, 'N'> = [];\r\n\r\n    // users: Dictionary<DocString<Pointer<DUser>>, UserState> = {};\r\n    // collaborators: UserState[];\r\n    idlookup: Record<Pointer<DPointerTargetable>, DPointerTargetable> = {};\r\n\r\n    //// DClass section to fill\r\n    graphs: Pointer<DGraph, 0, 'N'> = [];\r\n    voidvertexs: Pointer<DGraphVertex, 0, 'N'> = [];\r\n    vertexs: Pointer<DVertex, 0, 'N'> = [];\r\n    graphvertexs: Pointer<DGraphVertex, 0, 'N'> = [];\r\n    graphelements: Pointer<DGraphVertex, 0, 'N'> = []; // actually fields\r\n    edgepoints: Pointer<DEdgePoint, 0, 'N'> = [];\r\n    edges: Pointer<DEdge, 0, \"N\"> = [];\r\n\r\n    classifiers: Pointer<DClassifier, 0, 'N'> = [];\r\n    enumerators: Pointer<DEnumerator, 0, 'N'> = [];\r\n    packages: Pointer<DPackage, 0, 'N'> = [];\r\n    primitiveTypes: Pointer<DClass, 0, \"N\"> = [];\r\n    attributes: Pointer<DAttribute, 0, \"N\"> = [];\r\n    enumliterals: Pointer<DEnumLiteral, 0, \"N\"> = [];\r\n    references: Pointer<DReference, 0, \"N\"> = [];\r\n    classs: Pointer<DClass, 0, \"N\"> = [];\r\n    operations: Pointer<DOperation, 0, \"N\"> = [];\r\n    parameters: Pointer<DParameter, 0, \"N\"> = [];\r\n    ecoreClasses: Pointer<DClass, 0, \"N\"> = [];\r\n    returnTypes: Pointer<DClass, 0, \"N\"> = [];\r\n    /// DClass section end\r\n\r\n    isEdgePending: {user: Pointer<DUser>, source: Pointer<DClass>} = {user: '', source: ''};\r\n\r\n    contextMenu: { display: boolean, x: number, y: number, nodeid: Pointer} = {display: false, x: 0, y: 0, nodeid:''};\r\n\r\n    objects: Pointer<DObject, 0, 'N', LObject> = [];\r\n    values: Pointer<DValue, 0, 'N', LValue> = [];\r\n\r\n    // private, non-shared fields\r\n    _lastSelected?: {\r\n        node: Pointer<DGraphElement, 1, 1>,\r\n        view: Pointer<DViewElement, 1, 1>,\r\n        modelElement: Pointer<DModelElement, 0, 1> // if a node is clicked: a node and a view are present, a modelElement might be. a node can exist without a modelElement counterpart.\r\n    };\r\n\r\n    users: Pointer<DUser, 0, 'N', LUser> = [];\r\n\r\n    viewpoint: Pointer<DViewPoint> = '';\r\n    viewpoints: Pointer<DViewPoint, 0, 'N'> = [];\r\n\r\n\r\n    isLoading: boolean = false;\r\n\r\n    projects: Pointer<DProject, 0, 'N'> = [];\r\n    collaborativeSession: boolean = false;\r\n    ////////////////     flags shared, but handled locally      /////////////////////////////\r\n\r\n    /* RECOMPILES MODULE */\r\n    NODES_RECOMPILE_labels: Pointer<DGraphElement>[] = [];\r\n    NODES_RECOMPILE_longestLabel: Pointer<DGraphElement>[] = [];\r\n\r\n    VIEWS_RECOMPILE_labels: Pointer<DViewElement>[] = [];\r\n    VIEWS_RECOMPILE_longestLabel: Pointer<DViewElement>[] = [];\r\n\r\n    VIEWS_RECOMPILE_onDataUpdate: Pointer<DViewElement>[] = [];\r\n\r\n    VIEWS_RECOMPILE_onDragStart: Pointer<DViewElement>[] = [];\r\n    VIEWS_RECOMPILE_onDragEnd: Pointer<DViewElement>[] = [];\r\n    VIEWS_RECOMPILE_whileDragging: Pointer<DViewElement>[] = [];\r\n\r\n    VIEWS_RECOMPILE_onResizeStart: Pointer<DViewElement>[] = [];\r\n    VIEWS_RECOMPILE_onResizeEnd: Pointer<DViewElement>[] = [];\r\n    VIEWS_RECOMPILE_whileResizing: Pointer<DViewElement>[] = [];\r\n\r\n    VIEWS_RECOMPILE_onRotationStart: Pointer<DViewElement>[] = [];\r\n    VIEWS_RECOMPILE_onRotationEnd: Pointer<DViewElement>[] = [];\r\n    VIEWS_RECOMPILE_whileRotating: Pointer<DViewElement>[] = [];\r\n\r\n    VIEWS_RECOMPILE_constants: Pointer<DViewElement>[] = [];\r\n    VIEWS_RECOMPILE_usageDeclarations: Pointer<DViewElement>[] = [];\r\n    VIEWS_RECOMPILE_jsxString: Pointer<DViewElement>[] = [];\r\n\r\n    VIEWS_RECOMPILE_preconditions: Pointer<DViewElement>[] = [];\r\n    VIEWS_RECOMPILE_jsCondition: Pointer<DViewElement>[] = [];\r\n    VIEWS_RECOMPILE_ocl: Pointer<DViewElement>[] = [];\r\n    VIEWS_RECOMPILE_events: (Pointer<DViewElement> | {vid: Pointer<DViewElement>, keys: string[] | undefined})[] = [];\r\n    VIEWS_RECOMPILE_all?: boolean | Pointer<any>[];\r\n    ELEMENT_CREATED: Pointer[] = [];\r\n    ELEMENT_DELETED: Pointer[] = [];\r\n\r\n    ClassNameChanged: Dictionary<Pointer<DModelElement>, DocString<\"name\">> = {}; // for ocl matchings by m2 class name: \"context inv Human: ...\"\r\n\r\n    tooltip: string = '';\r\n\r\n    /* IoT: Topic Table */\r\n    topics: Dictionary<string, unknown> = {};\r\n\r\n    advanced: boolean = false;\r\n    alert: string = '';\r\n    dialog: string = '';\r\n    dialog_response: string = '';\r\n    action_description: string = '';\r\n    action_title: string = '';\r\n\r\n\r\n    static fixcolors(){\r\n        (window as any).tinycolor = tinycolor;\r\n        let tofix = [\"tetrad\", \"triad\", \"splitcomplement\"];\r\n        for (let f of tofix) {\r\n            let f0 = f + '0';\r\n            if (tinycolor.prototype[f0]) return;\r\n            tinycolor.prototype[f0] = tinycolor.prototype[f];\r\n            tinycolor.prototype[f] = function (){ let a = this.getAlpha(); return this[f0]().map((t: Instance) => t.setAlpha(a)); }\r\n        }\r\n    }\r\n    static init(store?: DState): void {\r\n        if (windoww.location.hash.indexOf('#/project') === 0) this.init_editor(store);\r\n        else this.init_dashboard(store);\r\n    }\r\n    static init_dashboard(store?: DState): void {\r\n        console.error('init_dash');\r\n    }\r\n    static init_editor(store?: DState): void {\r\n        this.fixcolors();\r\n        TRANSACTION('init jodel state', ()=>{\r\n            const viewpoint = DViewPoint.newVP('Default', undefined, true, 'Pointer_ViewPointDefault');\r\n            const validationViewpoint = DViewPoint.newVP('Validation default',\r\n                (vp)=>{ vp.isExclusiveView = false; vp.isValidation = true;}, true, 'Pointer_ViewPointValidation');\r\n\r\n            Log.exDev(viewpoint.id !== Defaults.viewpoints[0], \"wrong vp id initialization\", {viewpoint, def:Defaults.viewpoints});\r\n            const views: DViewElement[] = makeDefaultGraphViews(viewpoint, validationViewpoint);\r\n\r\n            for (let view of views) { CreateElementAction.new(view); }\r\n\r\n            for (let primitiveType of Object.values(ShortAttribETypes)) {\r\n                let dPrimitiveType;\r\n                if (primitiveType === ShortAttribETypes.EVoid) continue; // or make void too without primitiveType = true, but with returnType = true?\r\n                dPrimitiveType = DClass.new(primitiveType, false, false, true, false, '', undefined, true, 'Pointer_' + primitiveType.toUpperCase());\r\n                SetRootFieldAction.new('primitiveTypes', dPrimitiveType.id, '+=', true);\r\n            }\r\n\r\n            /// creating m3 \"Object\" metaclass\r\n            let dObject = DClass.new(ShortDefaultEClasses.EObject, false, false, false, false,\r\n                '', undefined, true, 'Pointer_' + ShortDefaultEClasses.EObject.toUpperCase());\r\n\r\n            SetRootFieldAction.new('ecoreClasses', dObject.id, '+=', true);\r\n            for (let defaultEcoreClass of Object.values(DefaultEClasses)) {\r\n                // todo: creat everyone and not just object, make the whole m3 populated.\r\n            }\r\n\r\n            /*\r\n            let tmp = Object.values(GraphElements);\r\n            for (let k in tmp) {\r\n                let v: any = tmp[k];\r\n                Log.exDev(!v, 'wrong import order', {k, v, GraphElements, tmp});\r\n                if (!v.cname) continue; // it is a subdictionary\r\n                GraphElements[(v.cname as string)] = GraphElements[k] = v;\r\n            }*/\r\n        })\r\n    }\r\n}\r\n\r\n\r\nfunction makeDefaultGraphViews(vp: DViewPoint, validationVP: DViewPoint): DViewElement[] {\r\n\r\n    let errorOverlayView: DViewElement = DViewElement.new2('Generic error view', DV.semanticErrorOverlay(), validationVP, (v) => {\r\n        v.jsCondition = 'let nstate = node?.state || {};\\nObject.keys(nstate).filter(k => k.indexOf(\"error_\")===0).map(k=>nstate[k]).join(\\'\\\\n\\').length>0';\r\n        v.usageDeclarations = \"(ret)=>{\\n\" +\r\n        \"// ** preparations and default behaviour here ** //\\n\" +\r\n        \"// add preparation code here (like for loops to count something), then list the dependencies below.\\n\" +\r\n        \"// ** declarations here ** //\\n\" +\r\n        \"// console.log('overlayView ud inner ' + data.name, {errs:node.state, node, noder:node.r, data});\\n\" +\r\n        \"ret.nstate = node.state\\n\" +\r\n        \"ret.errors = Object.keys(ret.nstate).filter(k => k.indexOf(\\\"error_\\\")===0).map(k=>ret.nstate[k])\\n\" +\r\n        \"\\n}\"\r\n        v.isExclusiveView = false;\r\n        v.css =\r\n`/* -- v2.0 - */\r\n&.mainView { text-decoration-line: spelling-error; }\r\n&.decorativeView {\r\n    text-decoration-line: spelling-error;\r\n    \r\n    .overlap{\r\n      outline: 1px dotted var(--failure);\r\n      display: flex;\r\n    }\r\n\r\n    .error-message{\r\n        color: var(--accent);\r\n        background: var(--bg-2-5);\r\n        border-radius: var(--radius);\r\n        margin: auto;\r\n        padding: 8px 14px 16px 10px;\r\n        position:absolute;\r\n        top:50%; right:0;\r\n        transform: translate(calc(100% + 20px), calc(-50%));\r\n\r\n    }\r\n    .error-message::before {\r\n      position: relative;\r\n      top: 4px;\r\n      font-family: bootstrap-icons;\r\n      font-size: 1.2rem;\r\n      content: '\\\\F333';\r\n      margin-right: 10px;\r\n      padding-top: 10px!important;\r\n    }\r\n}\r\n`\r\n    }, false, 'Pointer_ViewOverlay' );\r\n\r\n    let errorCheckName: DViewElement = DViewElement.new2('Naming error view', DV.invisibleJsx(), validationVP, (v) => {\r\n        v.isExclusiveView = false;\r\n        v.usageDeclarations = \"(ret)=>{ // scope: data, node, view, state, \\n\" +\r\n            \"// ** preparations and default behaviour here ** //\\n\" +\r\n            \"// add preparation code here (like for loops to count something), then list the dependencies below.\\n\" +\r\n            \"// ** declarations here ** //\\n\" +\r\n            \"ret.name = data && data.name || '';\\n\"+\r\n            \"ret.type = data && data.className.substring(1) || 'shapeless';\\n\"+\r\n            \"}\";\r\n        v.onDataUpdate = `\r\nlet err = \"\";\r\n//if (name.indexOf(\" \") >= 0) err = type + \" names cannot contain white spaces.\"; else\r\nif (name.length === 0 && type !== \"shapeless\") err = type + \" must be named.\";\r\nelse if (!name[0].match(/[A-Za-z_$]/)) err = type + \" names must begin with an alphabet letter or $_ symbols.\";\r\nelse if (!name.match(/^[A-Za-z_$]+[A-Za-z0-9$_\\\\s]*$/)) err = type + \" names can only contain an alphanumeric chars or or $_ symbols\";\r\nnode.state = {error_naming: err};\r\n`;}, false, 'Pointer_ViewCheckName' );\r\n\r\nlet errorCheckLowerbound: DViewElement = DViewElement.new2('Lowerbound error view', DV.invisibleJsx(), validationVP, (v) => {\r\n            // v.jsCondition = '(data, node)=> {\\nnode.state.errors?.length>0';\r\n            v.appliableToClasses = ['DValue'];\r\n            v.isExclusiveView = false;\r\n            v.usageDeclarations = \"(ret)=>{ // scope: data, node, view, state, \\n\" +\r\n                \"// ** preparations and default behaviour here ** //\\n\" +\r\n                \"// add preparation code here (like for loops to count something), then list the dependencies below.\\n\" +\r\n                \"// ** declarations here ** //\\n\" +\r\n                \"ret.valuesLength = data.values.filter(v=>(v!==undefined && v!=='')).length;\\n\"+\r\n                \"ret.missingLowerbound = Math.max(0, data.lowerBound - ret.valuesLength);\\n\" +\r\n                \"}\";\r\n            v.onDataUpdate = `\r\nlet err = undefined;\\n\r\nif (missingLowerbound > 0) err = (data.className.substring(1))\\n\r\n \\t\\t+ ' Lowerbound violation, missing ' + missingLowerbound + ' values.';\\n\r\nnode.state = {error_lowerbound: err};\\n\r\n`;\r\n    }, false, 'Pointer_ViewLowerbound' );\r\n    // errorOverlayView.oclCondition = 'context DValue inv: self.value < 0';\r\n\r\n    let valuecolormap: GObject = {};\r\n    valuecolormap[ShortAttribETypes.EBoolean] = \"orange\";\r\n    valuecolormap[ShortAttribETypes.EByte] = \"orange\";\r\n    valuecolormap[ShortAttribETypes.EShort] = \"orange\";\r\n    valuecolormap[ShortAttribETypes.EInt] = \"orange\";\r\n    valuecolormap[ShortAttribETypes.ELong] = \"orange\";\r\n    valuecolormap[ShortAttribETypes.EFloat] = \"orange\";\r\n    valuecolormap[ShortAttribETypes.EDouble] = \"orange\";\r\n    valuecolormap[ShortAttribETypes.EDate] = \"green\";\r\n    valuecolormap[ShortAttribETypes.EString] = \"green\";\r\n    valuecolormap[ShortAttribETypes.EChar] = \"green\";\r\n    valuecolormap[ShortAttribETypes.EVoid] = \"gray\";\r\n\r\n\r\n    let voidView: DViewElement = DViewElement.new2('Fallback', DV.fallbackView(), vp, undefined, false, 'fallback');\r\n\r\n\r\n    let edgeViews: DViewElement[] = [];\r\n    let size0: GraphPoint = new GraphPoint(0, 0), size1: GraphPoint = new GraphPoint(12, 12), size2: GraphPoint = new GraphPoint(18, 12);\r\n\r\n\r\n    let model = DefaultViews.model(vp);\r\n    let packagee = DefaultViews.package(model);\r\n    let classs = DefaultViews.class(packagee);\r\n    let enumm = DefaultViews.enum(packagee);\r\n    let attr = DefaultViews.attribute(classs);\r\n    let ref = DefaultViews.reference(classs);\r\n    let op = DefaultViews.operation(classs);\r\n    let par = DefaultViews.parameter(op);\r\n    let lit = DefaultViews.literal(enumm);\r\n    let obj = DefaultViews.object(model);\r\n    /* ALFONSO */\r\n    let single = DefaultViews.singleton(model);\r\n    let val = DefaultViews.value(obj);\r\n    let anchorView = DefaultViews.anchor(model);\r\n\r\n    function makeEdgeView(name: string, type: EdgeHead, headSize: GraphPoint | undefined, tailSize: GraphPoint | undefined, dashing: boolean): DViewElement{\r\n        let ev = DV.edgeView(type, headSize || size0, tailSize || size0, dashing ? \"10.5,9,0,0\" : undefined, model, name);\r\n        edgeViews.push(ev);\r\n        return ev;\r\n    }\r\n\r\n    makeEdgeView(\"Association\", EdgeHead.reference,             size1,   undefined,  false);\r\n    makeEdgeView(\"Dependency\",  EdgeHead.reference,             size1,   undefined,  true);\r\n    makeEdgeView(\"Inheritance\", EdgeHead.extend,                size1,   undefined,  false);\r\n    makeEdgeView(\"Aggregation\", EdgeHead.aggregation,   undefined,      size2,      false);\r\n    makeEdgeView(\"Composition\", EdgeHead.composition,   undefined,      size2,      false);\r\n\r\n    // edgeView.forceNodeType=\"Edge\"\r\n\r\n    /*\r\n    for (let ev of edgeViews){\r\n        ev.bendingMode = EdgeBendingMode.Line;\r\n        ev.subViews = [edgePointView.id];\r\n    }*/\r\n    // nb: Error is not a view, just jsx. transform it in a view so users can edit it\r\n\r\n\r\n\r\n    let dv_subviews = [model, packagee, classs, enumm, attr, ref, op, par,\r\n        lit, obj, val, single, voidView,\r\n        ...edgeViews,\r\n        DefaultViews.edgepoint(model),\r\n        anchorView];\r\n\r\n    let validation_subviews = [errorOverlayView, errorCheckLowerbound, errorCheckName];\r\n    // SetFieldAction.new(vp, 'subViews', U.objectFromArrayValues(dv_subviews.map(dv=>dv.id), 1.5));\r\n    // SetFieldAction.new(validationVP, 'subViews', U.objectFromArrayValues(validation_subviews.map(dv=>dv.id), 1.5));\r\n    const ret = [...dv_subviews, ...validation_subviews];\r\n    for (let v of ret) Log.e(!v.events, \"missing events on view \" + v.name, {v, ret});\r\n    for (let v of ret) Log.w(!!!v.events, \"found events on view \" + v.name, {v, ret});\r\n    return ret;\r\n}\r\n\r\n@RuntimeAccessible('ViewPointState')\r\nexport class ViewPointState extends DPointerTargetable{\r\n    name: string = '';\r\n}\r\n\r\n// to delete?\r\n@RuntimeAccessible('ModelStore')\r\nexport class ModelStore {\r\n    private _meta!: ModelStore | string;\r\n    instances!: (ModelStore | string)[];\r\n\r\n    // getter e setter senza proxy\r\n    get meta(): ModelStore | string {\r\n        return this._meta;\r\n    }\r\n\r\n    set meta(value: ModelStore | string) {\r\n        this._meta = value;\r\n    }\r\n}\r\n\r\n\r\n\r\n@RuntimeAccessible('LState')\r\nexport class LState<Context extends LogicContext<DState> = any, C extends Context = Context, D extends DState = DState> extends LPointerTargetable {\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    public __raw!: DPointerTargetable & DState;\r\n    public static structure: typeof DPointerTargetable;\r\n    public static singleton: LPointerTargetable;\r\n    // return type is wrong, but have to extend the static method of RuntimeAccessibleClass which is completely different and returns a class constructor.\r\n    static get<T2 extends typeof RuntimeAccessibleClass & { logic?: typeof LPointerTargetable | undefined; }>(): T2 & LState { return LState.wrap(store.getState() as any) as any; }\r\n    contextMenu!: {display: boolean, x: number, y: number};\r\n    user!: LUser;\r\n    debug!: boolean;\r\n    room!: string;\r\n    _lastSelected?: {modelElement?: LModelElement, node?: LGraphElement, view?: LViewElement};\r\n    idlookup!:Dictionary<Pointer, DPointerTargetable>;\r\n\r\n    get__lastSelected(c: Context): this[\"_lastSelected\"] {\r\n        let ls = c.data._lastSelected;\r\n        return ls && {modelElement: LState.wrap(ls.modelElement), node: LState.wrap(ls.node), view: LState.wrap(ls.view)}; }\r\n\r\n    _defaultCollectionGetter(c: Context, k: keyof DState): LPointerTargetable[] {\r\n        return LPointerTargetable.fromPointer(c.data[k] as any);\r\n    }\r\n    _defaultGetter(c: Context, k: keyof DState) {\r\n        let v = c.data[k];\r\n        if (Array.isArray(v)) {\r\n            if (v.length === 0) return [];\r\n            else if (Pointers.isPointer(v[0] as any)) return this._defaultCollectionGetter(c, k);\r\n            return v;\r\n        }\r\n        return v;\r\n    }\r\n}\r\n\r\nRuntimeAccessibleClass.set_extend(DPointerTargetable, DState);\r\nRuntimeAccessibleClass.set_extend(LPointerTargetable, LState);\r\n\r\n","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\ocl\\ocl.tsx",["1191","1192","1193"],"import {OclEngine} from \"@stekoe/ocl.js\"\r\nimport {\r\n    Constructor, DGraphElement,\r\n    DModel,\r\n    DModelElement, DPointerTargetable, DState, DViewElement,\r\n    GObject, LGraphElement,\r\n    LModelElement,\r\n    Log,\r\n    LPointerTargetable,\r\n    LViewElement,\r\n    RuntimeAccessible,\r\n    RuntimeAccessibleClass, store, transientProperties, ViewEClassMatch\r\n} from \"../joiner\";\r\nimport {OclResult} from \"@stekoe/ocl.js/dist/components/OclResult\";\r\n\r\nlet windoww = window as any;\r\n\r\nexport class Company {\r\n    static all: Company[] = [];\r\n    constructor(public name: string ='cname', public employee: Persona[]=[], public manager: Persona|null = null) { Company.all.push(this); }\r\n}\r\nexport class Persona {\r\n    static all: Persona[] = [];\r\n    constructor(public name: string='pname', public age: number=18, public isUnemployed: boolean=true){ Persona.all.push(this) }\r\n}\r\n\r\nexport class OCL{\r\n    public static evaluate<T extends GObject>(obj0: T, constructor: Constructor<T>, oclexp: string, typeused: Constructor[]=[], oclEngine?: OclEngine): OclResult {\r\n        windoww.OclEngine = OclEngine;\r\n        if (!oclEngine) {\r\n            oclEngine = OclEngine.create();\r\n            var oclResult = null;\r\n            // let objexp = //\"context Object inv: self.age > 0\" +\r\n            if (!oclexp) oclexp = \"context Persona inv: self.age>0\";\r\n\r\n\r\n            const typeregister: GObject = {};\r\n            typeregister[(constructor as any as typeof RuntimeAccessibleClass).cname || constructor.name] = constructor;\r\n            for (let type of typeused) { typeregister[(type as any as typeof RuntimeAccessibleClass).cname || type.name] = type; }\r\n            oclEngine.registerTypes(typeregister);\r\n            oclEngine.addOclExpression(oclexp);\r\n        }\r\n\r\n        let obj: GObject = obj0;\r\n        if (!obj) {\r\n            obj = new Persona();\r\n            obj.age = -55;\r\n            obj.name = {notEmpty: () => { console.log('innerfunc'); return true} };\r\n            obj.f = (a:any) => { console.error('called a', a); return a>0};\r\n            obj.name0= '';\r\n//obj.$$typeof = Persona;\r\n\r\n            obj.__asArray = true;\r\n        }\r\n        // as you set classname in runtimeaccessible you must set this typeName\r\n        // obj.typeName = constructor.name || constructor;\r\n// obj = getPath;\r\n// obj.constructor = Persona;\r\n        oclResult = oclEngine.evaluate(obj);\r\n        return oclResult;\r\n    }\r\n\r\n    public static test_bugged_new(mp0: DModelElement | LModelElement | undefined, view0: LViewElement | DViewElement | undefined, node0?: LGraphElement | DGraphElement): boolean | (typeof ViewEClassMatch)[\"MISMATCH_OCL\"] {\r\n        if (!mp0 || !view0) return ViewEClassMatch.MISMATCH_OCL;\r\n        let mp: DModelElement, lmp: LModelElement;\r\n        let node: DGraphElement, lnode: LGraphElement;\r\n        let view: DViewElement;\r\n        // @ts-ignore\r\n        if ((mp = mp0.__raw)) lmp = mp0; else { lmp = mp0; mp = (lmp as LModelElement)?.__raw; }\r\n        // @ts-ignore\r\n        if ((node = node0?.__raw)) lnode = node0; else { lnode = node0; node = lnode?.__raw; }\r\n        // @ts-ignore\r\n        view = view0?.__raw || view0;\r\n        let oclCondition = view.oclCondition;\r\n        let tv = transientProperties.view[view.id];\r\n        console.log(\"Evaluating ocl: \"+view.oclCondition, {view, ocl:view.oclCondition});\r\n        if (!view.oclCondition) { return true; }\r\n        let oclEngine: OclEngine;\r\n        if (!tv) transientProperties.view[view.id] = tv = {} as any;\r\n        if (tv.oclEngine) oclEngine = tv.oclEngine;\r\n        else {\r\n            windoww.OclEngine = OclEngine;\r\n            tv.oclEngine = oclEngine = OclEngine.create();\r\n            let state: DState = store.getState();\r\n            let rootModel: DModel = mp as any;\r\n            windoww.rootModel = rootModel;\r\n            while (rootModel && rootModel.className !== \"DModel\") rootModel = DPointerTargetable.fromPointer(rootModel.father, state);\r\n            oclEngine.registerTypes(RuntimeAccessibleClass.getOCLClasses(rootModel.id));\r\n            oclEngine.addOclExpression(oclCondition);\r\n            console.log(\"4 Evaluating ocl: \"+view.oclCondition, {view, ocl:view.oclCondition, mp, lmp, oclEngine});\r\n        }\r\n        try {\r\n            let oclResult: OclResult;\r\n            if (!lmp) lmp = LPointerTargetable.fromD(mp);\r\n            if (node) {\r\n                // dangerous cheat, to make ocl be able to access current \"node\" if model have multiple nodes.\r\n                const oldNode = transientProperties.modelElement[mp.id].node;\r\n                transientProperties.modelElement[mp.id].node = lnode || LPointerTargetable.fromD(node);\r\n                oclResult = oclEngine.evaluate(lmp)\r\n                transientProperties.modelElement[mp.id].node = oldNode;\r\n            }\r\n            else oclResult = oclEngine.evaluate(lmp);\r\n            windoww.oclDebug={oclResult, oclEngine, lmp, oclCondition};\r\n            console.log(\"5 Evaluating ocl: \"+view.oclCondition, {view, ocl:view.oclCondition, mp, lmp, oclResult, oclEngine});\r\n            // return oclResult ? OCL.getOCLScore(oclCondition) : ViewEClassMatch.MISMATCH_OCL;\r\n            let matches: boolean = oclResult && oclResult.getEvaluatedContexts().length > 0 && oclResult.getResult();\r\n            return matches || ViewEClassMatch.MISMATCH_OCL;\r\n        } catch(e) {\r\n            Log.ee('failed to evalute OCL expression:', {e, obj: mp, view: view.name, oclexp: view.oclCondition, node});\r\n            return ViewEClassMatch.MISMATCH_OCL;\r\n        }\r\n        // oclEngine.setTypeDeterminer()\r\n    }\r\n    public static test(me: DModelElement | LModelElement | undefined, view: LViewElement | DViewElement | undefined, node?: LGraphElement | DGraphElement): boolean | (typeof ViewEClassMatch)[\"MISMATCH_OCL\"] {\r\n        if (!me || !view) return false;\r\n        const condition = view.oclCondition;\r\n        if (!condition) return true;\r\n        try {\r\n            const types = RuntimeAccessibleClass.getAllClasses();\r\n            return !!OCL.filter(true, 'src', [me], condition, types as any)[0];\r\n        } catch (e) {\r\n            return false\r\n        }\r\n\r\n    }\r\n\r\n\r\n    // warning: do not read ret.result with returntype='ocl'\r\n    // it neeeds to be evaluated both with  ret.getEvaluatedContexts().length > 0 && ret.getResult();\r\n    public static filter<T extends GObject>(keepIndex: boolean, returnType: 'ocl' | 'bool' | 'src', obj0: T[], oclexp: string, typeused: Constructor[]=[]) {\r\n        windoww.OclEngine = OclEngine;\r\n        var oclEngine = OclEngine.create();\r\n        var oclResult = null;\r\n        windoww.oclEngine = oclEngine;\r\n        const typeregister: GObject = {};\r\n        for (let type of typeused) { typeregister[(type as any as typeof RuntimeAccessibleClass).cname || type.name] = type; }\r\n        oclEngine.registerTypes(typeregister);\r\n        if (!oclexp) oclexp = \"context Persona inv: self.age>0\";\r\n        oclEngine.addOclExpression(oclexp);\r\n\r\n        let obj: GObject[] = obj0;\r\n        let ret: ((OclResult | boolean) | (GObject | null))[] = [];\r\n\r\n        for (let i = 0; i < obj.length; i++) {\r\n            let res: OclResult | null;\r\n            try { res = oclEngine.evaluate(obj[i]); }\r\n            catch(e) { console.error('failed to evalute object:', {e}); res = null; }\r\n            if (returnType === 'ocl') {\r\n                ret[i] = res;\r\n                continue; }\r\n            let bool = res && res.getEvaluatedContexts().length > 0 && res.getResult();\r\n            if (returnType === 'bool') ret[i] = bool;\r\n            else ret[i] = bool ? obj[i] : null;\r\n        }\r\n\r\n        if (!keepIndex) {\r\n            ret = (ret).filter((r:any) => !!r) as any;\r\n        }\r\n\r\n        return ret;\r\n    }\r\n}\r\nwindoww.OCL = OCL;\r\nconst oclEngine = OclEngine.create();\r\n\r\n\r\n/*\r\n\r\nlet p = new Persona();\r\np.age = 0;\r\nlet p2 = new Persona();\r\np2.age = 1;\r\nlet p3 = new Persona();\r\np3.age = -5;\r\nlet pp = [p, p2, p3];\r\nOCL.filter(true, 'ocl', pp, undefined, \"context Persona inv: self.age>0\")\r\n\r\n\r\n///\r\n\r\nOCL.filter(true, 'src', Selectors.getAll(DClass, undefined, undefined, true), \"context DClass inv: self.abstract\")\r\n/// works\r\nlet pp = Selectors.getAll(DClass, undefined, undefined, true);\r\nOCL.filter(true, 'src', Selectors.getAll(DClass, undefined, undefined, true), \"context DClass inv: self.name = \\\"class_2\\\"\")\r\n\r\n* */\r\n\r\noclEngine.addOclExpression(`\r\n    -- No one should work that long...\r\n    context Company inv:\r\n        self.employee->forAll(p : Person | p.age <= 65 )\r\n\r\n    -- If a company has a manager, \r\n    -- the company has at least one employee.\r\n    context Company\r\n        inv: self.manager.isUnemployed = false\r\n        inv: self.employee->notEmpty()\r\n`);\r\n\r\nlet company = new Company();\r\ncompany.employee.push(new Persona());\r\n\r\nconst oclResult = oclEngine.evaluate(company);\r\n\r\n\r\n\r\nwindoww.Person = Persona;\r\nwindoww.Company = Company;\r\nwindoww.oclEngine = oclEngine;\r\n\r\nif (false as any) console.log('tests:', '\\n' +\r\n    'oclEngine.addOclExpression(`\\n' +\r\n    '    -- No one should work that long...\\n' +\r\n    '    context Company inv:\\n' +\r\n    '        self.employee->forAll(p : Person | p.age <= 65 )\\n' +\r\n    '\\n' +\r\n    '    -- If a company has a manager, \\n' +\r\n    '    -- the company has at least one employee.\\n' +\r\n    '    context Company\\n' +\r\n    '        inv: self.manager.isUnemployed = false\\n' +\r\n    '        inv: self.employee->notEmpty()\\n' +\r\n    '`);\\n' +\r\n    '\\n' +\r\n    'const customTypes = {\\n' +\r\n    '  \"Person\": Person, \"Company\": Company \\n' +\r\n    '}\\n' +\r\n    '\\n' +\r\n    'oclEngine.registerTypes(customTypes);' +\r\n    'let company = new Company();\\n' +\r\n    'let employee = new Person();\\n' +\r\n    'let parent = new Person();\\n' +\r\n    'let child = new Person();\\n' +\r\n    'child.parents = [parent];\\n' +\r\n    'parent.parents = [parent];\\n' +\r\n    'employee.age = 70;\\n' +\r\n    'company.employee.push(employee);\\n' +\r\n    '\\n' +\r\n    'console.log(\\'evaluate company\\', oclEngine.evaluate(company));\\n' +\r\n    '\\n' +\r\n    '\\n' +\r\n    '// parentchild test\\n' +\r\n    'let oclEnginep = OclEngine.create();\\n' +\r\n    'oclEnginep.addOclExpression(`\\n' +\r\n    '    context Person\\n' +\r\n    '        inv: self.parents->forAll(p | p <> self)\\n' +\r\n    '`)\\n' +\r\n    'console.log(\\'evaluate parent\\', oclEnginep.evaluate(parent));\\n' +\r\n    'console.log(\\'evaluate child\\', oclEnginep.evaluate(child));\\n');\r\n","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\debugtools\\debug.tsx",["1194","1195"],"import type {DClass, DModel, GObject, LClass, LModel} from \"../joiner\";\r\nimport {LPointerTargetable, RuntimeAccessible, SetRootFieldAction} from \"../joiner\";\r\nlet windoww = window as any;\r\n\r\n@RuntimeAccessible('Debug')\r\nexport class Debug {\r\n    public static lightMode: boolean = false; // performance ligher mode for potato pc, huge models or complex simulations / measurables\r\n    private static lightModeInput: HTMLInputElement;\r\n\r\n    // manually activated: counts how many times each node is rendered in a component.\r\n    static getComponentMap(){\r\n        let nodes = Object.values(windoww.GraphElementComponent.all).map((a:any)=>a.props.node).filter(a=>!!a);\r\n        let nodeids = [...new Set(nodes.map(a=>a.id).filter(a=>!!a))];\r\n        let allids: GObject = {};\r\n        for (let o of nodeids) allids[o] = 0;\r\n        for (let n of nodes) allids[n?.id]++;\r\n        allids.nodes = nodeids;\r\n        allids.components = Object.values(windoww.GraphElementComponent.all);\r\n        return allids; }\r\n\r\n    static timeoutTasks(){}\r\n    static largeTimeoutTasks(){\r\n        windoww.model = windoww.LPointerTargetable.wrap(windoww.s().model?.[0]);\r\n    }\r\n\r\n    static remakeEdges(): void{\r\n        // warning: might break undo/redo for direct state editing\r\n        let eids = windoww.LPointerTargetable.wrapAll(windoww.LState.get().edges).map((e: any)=>e.id)\r\n        let epids = windoww.LPointerTargetable.wrapAll(windoww.LState.get().edgepoints).map((e: any)=>e.id)\r\n        let ss = windoww.store.getState();\r\n        ss.edges = [];\r\n        ss.edgepoints = [];\r\n        for (let e of eids) delete ss.idlookup[e];\r\n        for (let e of epids) delete ss.idlookup[e];\r\n        windoww.SetRootFieldAction.new(\"clonedCounter\" , ss.clonedCounter + 1, '', false);\r\n    }\r\n\r\n    static setLightMode(b: boolean): void {\r\n        // i don't want to use react or actions here because they cause a re-render and are heavy. this is a performance emergency mode.\r\n        if (this.lightMode === b) return;\r\n        this.lightMode = b;\r\n        if (!Debug.lightModeInput) {\r\n            Debug.lightModeInput = ($(\"#lightmode\") as any as HTMLInputElement[])[0];\r\n            if (!Debug.lightModeInput) return;\r\n        }\r\n        Debug.lightModeInput.checked = b;\r\n    }\r\n    public static refresh(): void {\r\n        for (let key in windoww.GraphElementComponent.all) {\r\n            windoww.GraphElementComponent.all[key].forceUpdate();\r\n        }\r\n        console.log(windoww.GraphElementComponent.all);\r\n    }\r\n\r\n    // 16s 50 classi vuote\r\n    static benchmarkCreateElement(times: number = 100, disableConsole: boolean = true): BenchmarkOptions{\r\n        let state = windoww.s();\r\n\r\n        let checkDelayMax = 300;\r\n        let checkDelayMin = 50;\r\n        let diff = checkDelayMax - checkDelayMin;\r\n        let callbacks: any = {checkCompletionFunction, checkDelayMin, additionalDelayMax: diff, times, disableConsole};\r\n        callbacks.startTime = new Date();\r\n        if(disableConsole) windoww.Log.disableConsole();\r\n        let lmodel = (LPointerTargetable.wrap(state.idlookup[ state.models[0] ]) as LModel);\r\n        for (let i = 0; i < times; i++){\r\n            lmodel.addChild(\"Class\");\r\n        }\r\n        function checkCompletionFunction() { return $(\".DClass\").length; }\r\n\r\n        Debug.timeMeasurer(callbacks);\r\n        return callbacks;\r\n    }\r\n    // 4s 10 istanze con 5 attributi\r\n    static benchmarkCreateInstance(metaclassName: string=\"Concept 1\", times: number = 100, disableConsole: boolean = true): BenchmarkOptions{\r\n        let checkDelayMax = 300;\r\n        let checkDelayMin = 50;\r\n        let diff = checkDelayMax - checkDelayMin;\r\n        let callbacks: any = {checkCompletionFunction, checkDelayMin, additionalDelayMax: diff, times, disableConsole};\r\n        callbacks.startTime = new Date();\r\n        if(disableConsole) windoww.Log.disableConsole();\r\n\r\n        let state = windoww.s();\r\n        let lmodel = (LPointerTargetable.wrap(state.idlookup[ state.models[1] ]) as LModel);\r\n        let lclass = LPointerTargetable.wrap(state.classs.map((cid: string)=>state.idlookup[cid]).filter((c:DClass) => c.name === metaclassName)[0]) as LClass;\r\n        for (let i = 0; i < times; i++) {\r\n            lmodel.addObject(lclass?.id);\r\n        }\r\n        function checkCompletionFunction() { return $(\"[data-modelname=\\\"DObject\\\"]\").length; }\r\n\r\n        Debug.timeMeasurer(callbacks);\r\n        return callbacks;\r\n    }\r\n\r\n\r\n    static timeMeasurer(callbacks0:Partial<BenchmarkOptions> | undefined): BenchmarkOptions {\r\n        let callbacks: BenchmarkOptions = callbacks0 as any;\r\n        if (!callbacks) callbacks = {} as any;\r\n        // if (!callbacks.startTime) callbacks.startTime = new Date();\r\n        if (!callbacks.maxStuckTime) callbacks.maxStuckTime = 10000;\r\n        if (!callbacks.checkDelayMin) callbacks.checkDelayMin = 300;\r\n        if (!callbacks.additionalDelayMax) callbacks.additionalDelayMax = 2000;\r\n        if (!callbacks.onStuck) callbacks.onStuck = (time:number, start: Date, end:Date, $complete: number) => {\r\n            console.log(\"Benchmarked operation stuck at same completion% for: \" + callbacks.maxStuckTime/1000+\" s. \\n\" +\r\n                \"After \" + time/100 + \"s total time passed and \" + $complete*100 + \"% of the task was completed. \\nBenchmark aborted.\"); }\r\n        if (!callbacks.onFinish) callbacks.onFinish = (time:number, start: Date, end:Date) => {\r\n            console.log(\"Benchmarked operation completed after: \" + time/1000 + \" s.\"); }\r\n\r\n        windoww.Log.exDev(!callbacks.times, \".times is a mandatory option\");\r\n        windoww.Log.exDev(!callbacks.checkCompletionFunction, \".checkCompletionFunction is a mandatory option\");\r\n        windoww.Log.exDev(!callbacks.checkCompletionFunction, \".startTime is a mandatory option. set it **before** doing the main task, then call the benchmark.\");\r\n        (callbacks as any).completionHistory = [];\r\n\r\n        if(callbacks.disableConsole) windoww.Log.disableConsole();\r\n        Debug.timeMeasurer_inner(callbacks);\r\n        return callbacks;\r\n    }\r\n\r\n    private static timeMeasurer_inner(callbacks:BenchmarkOptions): void {\r\n        let completedTimes = callbacks.checkCompletionFunction();\r\n        (callbacks as any).completionHistory.push(completedTimes);\r\n        if (completedTimes === callbacks.times) {\r\n            callbacks.endTime = new Date();\r\n            callbacks.totTime = callbacks.endTime.getTime() - callbacks.startTime.getTime();\r\n            if(callbacks.disableConsole) windoww.Log.enableConsole();\r\n            callbacks.onFinish(callbacks.totTime, callbacks.startTime, callbacks.endTime);\r\n            callbacks.endStatus = \"FINISH\";\r\n            return;\r\n        }\r\n        let $complete = completedTimes / callbacks.times;\r\n        if (callbacks.completedTimes !== completedTimes) {\r\n            callbacks.stuckSince = new Date().getTime();\r\n            callbacks.completedTimes = completedTimes;\r\n        } else\r\n        if (callbacks.stuckSince > callbacks.maxStuckTime) {\r\n            callbacks.endTime = new Date();\r\n            let $complete = completedTimes / callbacks.times;\r\n            callbacks.totTime = callbacks.endTime.getTime() - callbacks.startTime.getTime();\r\n            if(callbacks.disableConsole) windoww.Log.enableConsole();\r\n            callbacks.onStuck(callbacks.totTime, callbacks.startTime, callbacks.endTime, $complete);\r\n            callbacks.endStatus = \"STUCK\";\r\n            return;\r\n        }\r\n        let delay = callbacks.checkDelayMin;\r\n        if ($complete !== 0) delay += callbacks.additionalDelayMax * (1-$complete);\r\n        setTimeout(()=>Debug.timeMeasurer_inner(callbacks), delay );\r\n\r\n    }\r\n}\r\ntype BenchmarkOptions = {\r\n    onFinish:(time:number, start: Date, end:Date)=>void,\r\n    onStuck:(time:number, start: Date, end:Date, $complete: number)=>void,\r\n    disableConsole: boolean, endStatus: string,\r\n    // completionFunction returns how many steps are completed.\r\n    // times how many steps need to be completed to mark the test as finished.\r\n    checkCompletionFunction: () => number, times: number, completedTimes: number,\r\n    // those are automatically set\r\n    startTime:Date, endTime:Date, stuckSince: number, totTime: number,\r\n    // check how often completion or abortion is checked\r\n    checkDelayMin: number, additionalDelayMax: number, maxStuckTime:number\r\n};\r\n\r\nsetTimeout(Debug.timeoutTasks, 500);\r\nsetTimeout(Debug.largeTimeoutTasks, 5000);\r\nwindoww.Debug = Debug;\r\n","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\model\\dataStructure\\GraphDataElements.tsx",["1196","1197","1198","1199","1200","1201","1202","1203","1204","1205","1206","1207","1208","1209","1210","1211","1212","1213","1214","1215","1216","1217","1218","1219","1220","1221","1222","1223","1224","1225"],"// import {Mixin} from \"ts-mixer\";\r\nimport {isDeepStrictEqual} from \"util\";\r\nimport {\r\n    Constructors,\r\n    CoordinateMode,\r\n    Debug,\r\n    Dictionary,\r\n    DModelElement,\r\n    DocString,\r\n    DPointerTargetable,\r\n    DState,\r\n    DUser,\r\n    DViewElement,\r\n    EdgeBendingMode,\r\n    EPSize,\r\n    getWParams,\r\n    GObject,\r\n    GraphElementComponent,\r\n    GraphPoint,\r\n    GraphSize,\r\n    Info, IPoint, Keystrokes, L,\r\n    Leaf,\r\n    LModelElement,\r\n    Log,\r\n    LogicContext,\r\n    LPointerTargetable,\r\n    LViewElement,\r\n    MixOnlyFuncs,\r\n    Node, orArr,\r\n    Pack1,\r\n    PackArr,\r\n    Point,\r\n    Pointer,\r\n    Pointers,\r\n    PrimitiveType,\r\n    RuntimeAccessible,\r\n    RuntimeAccessibleClass,\r\n    SetFieldAction, SetRootFieldAction,\r\n    ShortAttribETypes,\r\n    Size,\r\n    store,\r\n    TargetableProxyHandler, TRANSACTION,\r\n    transientProperties,\r\n    U,\r\n    Uarr, UX,\r\n    windoww\r\n} from \"../../joiner\";\r\nimport type {Tooltip} from \"../../components/forEndUser/Tooltip\";\r\nimport type {RefObject} from \"react\";\r\nimport type {SVGPathElementt, SVGPathSegment} from '../../common/libraries/pathdata';\r\nimport {EdgeGapMode, InitialVertexSize} from \"../../joiner/types\";\r\nimport {Geom, ISize} from \"../../common/Geom\";\r\n\r\n\r\nconsole.warn('ts loading graphDataElement');\r\n\r\n@Node\r\n@RuntimeAccessible('DGraphElement')\r\nexport class DGraphElement extends DPointerTargetable {\r\n    // static _super = DPointerTargetable;\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // static singleton: LGraphElement;\r\n    // static logic: typeof LGraphElement;\r\n    // static structure: typeof DGraphElement;\r\n    id!: Pointer<DGraphElement, 1, 1, LGraphElement>;\r\n    graph!: Pointer<DGraph, 1, 1, LGraph>;\r\n    model?: Pointer<DModelElement, 0, 1, LModelElement>;\r\n    isSelected!: Dictionary<DocString<Pointer<DUser>>, boolean>;\r\n    // containedIn!: Pointer<DGraphElement, 0, 1, LGraphElement>;\r\n    subElements!: Pointer<DGraphElement, 0, 'N', LGraphElement>;\r\n    state!: GObject; // DMap\r\n    father!: Pointer<DGraphElement, 1, 1, LGraphElement>;\r\n    x!: number;\r\n    y!: number;\r\n    zIndex: number = 100;\r\n    w!: number;\r\n    h!: number;\r\n    // width: number = 300;\r\n    // height: number = 400;\r\n    view!: Pointer<DViewElement, 1, 1, LViewElement>;\r\n    favoriteNode!: boolean;\r\n    edgesIn!: Pointer<DEdge>[];\r\n    edgesOut!: Pointer<DEdge>[];\r\n    anchors!: Dictionary<string, GraphPoint/* as % of node size.*/>;\r\n\r\n\r\n    public static new(htmlindex: number, model: DGraphElement[\"model\"]|null|undefined, parentNodeID: DGraphElement[\"father\"],\r\n                      graphID: DGraphElement[\"graph\"], nodeID?: DGraphElement[\"id\"]|undefined, a?: any, b?:any, ...c:any): DGraphElement {\r\n        return new Constructors(new DGraphElement('dwc'), parentNodeID, true, undefined, nodeID)\r\n            .DPointerTargetable()\r\n            .DGraphElement(model, graphID, htmlindex).end();\r\n    }\r\n\r\n    static nodeLFromHtml(target?: Element | null): LGraphElement | undefined { return LPointerTargetable.fromPointer(DGraphElement.nodePtrFromHtml(target) as Pointer); }\r\n    static nodeDFromHtml(target?: Element | null): DGraphElement | undefined { return DPointerTargetable.fromPointer(DGraphElement.nodePtrFromHtml(target) as Pointer); }\r\n    static nodePtrFromHtml(target?: Element | null): Pointer<DGraphElement> | undefined {\r\n        while (target) {\r\n            if ((target.attributes as any).nodeid) return (target.attributes as any).nodeid.value;\r\n            target = target.parentElement;\r\n        }\r\n        return undefined;\r\n    }\r\n    static graphLFromHtml(target?: Element | null): LGraph | undefined { return LPointerTargetable.fromPointer(DGraphElement.graphPtrFromHtml(target) as Pointer); }\r\n    static graphDFromHtml(target?: Element | null): DGraph | undefined { return DPointerTargetable.fromPointer(DGraphElement.graphPtrFromHtml(target) as Pointer); }\r\n    static graphPtrFromHtml(target?: Element | null): Pointer<DGraph> | undefined {\r\n        while (target) {\r\n            if ((target.attributes as any).graphid) return (target.attributes as any).graphid.value;\r\n            target = target.parentElement;\r\n        }\r\n        return undefined;\r\n    }\r\n}\r\n@RuntimeAccessible('LGraphElement')\r\nexport class LGraphElement<Context extends LogicContext<DGraphElement> = any, C extends Context = Context> extends LPointerTargetable {\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static getNodeId<L extends LGraphElement, D extends DGraphElement>(o?:L | D | Pointer<D> | LModelElement | DModelElement | Pointer<DModelElement>): Pointer<D> {\r\n        if (!o) return undefined as any;\r\n        let node: any = o;\r\n        // from L to D\r\n        // let cname = (node.__raw || node).className;\r\n        // from DModelE to LGraphE\r\n        if (RuntimeAccessibleClass.extends((o as any).className, \"DModelElement\")) node = LPointerTargetable.from(o as DModelElement).node as LGraphElement;\r\n        return (typeof node === \"string\") ? node : node?.id;\r\n    }\r\n    // static singleton: LGraphElement;\r\n    // static logic: typeof LGraphElement;\r\n    // static structure: typeof DGraphElement;\r\n    __raw!: DGraphElement;\r\n    id!: Pointer<DGraphElement, 1, 1, LGraphElement>;\r\n    father!: LGraphElement;\r\n    model?: LModelElement;\r\n    // protected isSelected!: Dictionary<DocString<Pointer<DUser>>, boolean>; //  & ((forUser?: Pointer<DUser>) => boolean);\r\n\r\n    // containedIn?: LGraphElement;\r\n    _state!: GObject<\"proxified\">; // LMap;\r\n    x!: number;\r\n    y!: number;\r\n    width!: number;\r\n    height!: number\r\n\r\n    z!:number;\r\n    zIndex!: number;\r\n    __info_of__z__: Info = {type:ShortAttribETypes.EInt, txt: \"alias for zIndex\"};\r\n    __info_of__zIndex__: Info = {type:ShortAttribETypes.EInt,\r\n        txt: \"Determine the z-axis priority of the element.<br/>Higher value tende to overlap other elements.<br/>Lower value tends to be on background.\"};\r\n    zoom!: GraphPoint;\r\n    html?: Element;\r\n    __info_of__html: Info = {type: 'HTMLElement', txt:'The DOM element generated by this node.'}\r\n\r\n    // fittizi\r\n    w!:number;\r\n    h!:number;\r\n    size!: GraphSize;\r\n    position!: GraphPoint;\r\n    htmlSize!: Size; // size and position in global document coordinates.\r\n    htmlPosition!: Point;\r\n    view!: LViewElement;\r\n    component!: GraphElementComponent;\r\n    favoriteNode!: boolean;\r\n    vertex?: LVoidVertex;\r\n    __info_of__vertex: Info = {type: \"LVoidVertex\", txt: \"the foremost vertex containing this graphElement, or undefiened.\"}\r\n    __info_of__favoriteNode: Info = {type: ShortAttribETypes.EBoolean,\r\n        txt: \"<span>Indicates this is the primarly used (by default) node to refer to a modelling element that might have multiple representations.\" +\r\n            \"<br> Can be used as favorite target for edges or other.\"}\r\n\r\n    startPoint!: GraphPoint;\r\n    endPoint!: GraphPoint;\r\n    __info_of__startPoint: Info = {type: \"GraphPoint\", txt:<span>Where the outgoing edges should start their paths.\r\n            <br/>Obtained by combining anchoring point offset specified in view, before snapping to a Vertex border.\r\n            <br/>Defaults in outer coordinates.</span>};\r\n    __info_of__endPoint: Info = {type: \"GraphPoint\", txt:<span>Where the incoming edges should end their paths.\r\n            <br/>Obtained by combining anchoring point offset specified in view, before snapping to a Vertex border.\r\n            <br/>Defaults in outer coordinates.</span>};\r\n\r\n    graph!: LGraph | LGraphVertex;\r\n    __info_of__graph: Info = {type:\"LGraph | LGraphVertex\", txt:\"Alias for innerGraph\"};\r\n    get_graph(context: Context): LGraph | LGraphVertex { return this.get_innerGraph(context); }\r\n    innerGraph!: LGraph|LGraphVertex;\r\n    __info_of__innnerGraph: Info = {type:\"LGraph | LGraphVertex\", txt:\"Gets the nearest-level graph (it might be a Sub-graph like a package usually is)\"};\r\n    outerGraph!: LGraph;\r\n    __info_of__outerGraphGraph: Info = {type:\"LGraph\", txt:\"Gets the root-level graph\"};\r\n    root!: LGraph;\r\n\r\n    __info_of__root: Info = {type:\"LGraph\", txt:\"Alias for outerGraph\"};\r\n    get_root(context: Context): LGraph { return this.get_outerGraph(context); }\r\n\r\n    rendered!: boolean;\r\n    __info_of__rendered: Info = {type: 'boolean', txt:'If the node is currently displayed somewhere in the graph.'}\r\n    get_rendered(c: Context): this[\"rendered\"] { return !!this.get_html(c);}\r\n    visible!: boolean;\r\n    __info_of__visible: Info = {type: 'boolean', txt:'If the node is currently visible on the user screen.'}\r\n    get_visible(c: Context): this[\"visible\"] { return UX.isElementInViewport(this.get_html(c)); }\r\n    firstRenderedNode!: LGraphElement;\r\n    __info_of__firstRenderedNode:Info={type: 'LGraphElement', txt: \"The first currently rendered node in the collection: [this.node, this.father.node, this.father.father.node , ...]\"};\r\n    protected get_firstRenderedNode(c: Context): this[\"firstRenderedNode\"] {\r\n        let arr = [c.proxyObject];\r\n        return U.findInChildProperties(arr, (e)=>[e.father], undefined, (e)=>e.rendered);\r\n    }\r\n    name!:string;\r\n    public get_name(c: Context): string{ return c.data.model && this.get_model(c)?.name || (c.data as any).name || c.data.className; }\r\n    /*firstRenderedNodes!: LGraphElement;\r\n    __info_of__firstRenderedNodes:Info={type: 'LGraphElement', txt: \"The first currently rendered node in the collection: [this.nodes, this.father.nodes, this.father.father.nodes , ...]\"};\r\n    protected get_firstRenderedNodes(c: Context): this[\"firstRenderedNodes\"] {\r\n        let arr = this.get_nodes(c);\r\n        // return U.findInChildProperties(arr, (e)=>e.model.father.nodes, undefined, (e)=>e.rendered);\r\n        return U.findInChildProperties(arr, (e)=>[e.father], undefined, (e)=>e.rendered);\r\n    }*/\r\n\r\n\r\n    __info_of__graphAncestors: Info = {type:\"LGraph[]\",\r\n        txt:\"<span>collection of the stack of Graphs containing the current element where [0] is the most nested graph, and last is root graph.</span>\"};\r\n    graphAncestors!: LGraph[];\r\n\r\n    anchors!: Dictionary<string, GraphPoint/* as % of node size.*/>;\r\n    __info_of__anchors: Info = {type:\"Dictionary<string, point>\", txt: <div>A named list of all anchor points where edges are allowed to land or depart from.<br/>\r\n            {/*When reading it is in absolute sizes.<br/>*/}\r\n            When writing it must be done in percentages, with the same rules as node.state.</div>}\r\n    get_anchors(c: Context): this[\"anchors\"]{ return c.data.anchors; }\r\n    set_anchors(v: this[\"anchors\"], c: Context):boolean{\r\n        if (v !== undefined && (typeof v !== \"object\" || Array.isArray(v))){\r\n            Log.ee('cannot set anchors: invalid value provided');\r\n            return true;\r\n        }\r\n        if (v){ // if !v it means clear all anchors?\r\n            for (let ka in v){//for each anchor\r\n                if (!v[ka]) continue;\r\n\r\n                if (c.data.anchors[ka]) {\r\n                    for (let kk in v[ka]) { //for each key within an anchor (x, y, w, h)\r\n                        // if i was attempting to set a partial size, complete it with the old size values.\r\n                        if ((v[ka][kk] === undefined) && (c.data.anchors[ka][kk] !== undefined)) v[ka][kk] = c.data.anchors[ka][kk];\r\n                    }\r\n                }\r\n                if (v[ka].x === undefined || isNaN(v[ka].x)) v[ka].x = 0.5;\r\n                if (v[ka].y === undefined || isNaN(v[ka].y)) v[ka].y = 0.5;\r\n                // if (v[ka].w === undefined || isNaN(v[ka].w)) v[ka].w = 5;\r\n                // if (v[ka].h === undefined || isNaN(v[ka].h)) v[ka].h = 5;\r\n            }\r\n        }\r\n        TRANSACTION(this.get_name(c)+'.anchors', ()=> {\r\n            SetFieldAction.new(c.data, \"anchors\", v, '', false)\r\n        });\r\n        return true; }\r\n\r\n    edgesIn!: LVoidEdge[];\r\n    edgesOut!: LVoidEdge[];\r\n    __info_of__edgesIn: Info = {type:\"LEdge[]\", txt:<div>Edges incoming into this element. <code>this.edgesOut[i].end</code> always equals to <code>this</code>.</div>}\r\n    __info_of__edgesOut: Info = {type:\"LEdge[]\", txt:<div>Edges outgoing from this element. <code>this.edgesIn[i].start</code> always equals to <code>this</code>.</div>}\r\n    __info_of__edgesStart: Info = {type:\"LEdge[]\", txt:<div>Alias for this.edgesOut</div>}\r\n    __info_of__edgesEnd: Info = {type:\"LEdge[]\", txt:<div>Alias for this.edgesIn</div>}\r\n    public get_edgesIn(context: Context): this[\"edgesIn\"] { return LPointerTargetable.fromArr(context.data.edgesIn); }\r\n    public get_edgesOut(context: Context): this[\"edgesOut\"]  { return LPointerTargetable.fromArr(context.data.edgesOut); }\r\n    public set_edgesIn(val: PackArr<LVoidEdge>, c: Context): boolean {\r\n        TRANSACTION(this.get_name(c)+'edgesIn', ()=> {\r\n            SetFieldAction.new(c.data.id, \"edgesIn\", Pointers.fromArr(val), '', true);\r\n        })\r\n        return true;\r\n\r\n    }\r\n    public set_edgesOut(val: PackArr<LVoidEdge>, c: Context): boolean {\r\n        TRANSACTION(this.get_name(c)+'.edgesOut', ()=> {\r\n            SetFieldAction.new(c.data.id, \"edgesOut\", Pointers.fromArr(val), '', true);\r\n        })\r\n        return true;\r\n    }\r\n    public get_edgesStart(context: Context): this[\"edgesIn\"]  { return this.get_edgesIn(context); }\r\n    public get_edgesEnd(context: Context): this[\"edgesOut\"]  { return this.get_edgesOut(context); }\r\n    public set_edgesStart(val: PackArr<LVoidEdge>, context: Context): boolean { return this.set_edgesIn(val, context); }\r\n    public set_edgesEnd(val: PackArr<LVoidEdge>, context: Context): boolean { return this.set_edgesOut(val, context); }\r\n\r\n\r\n    protected _defaultGetter(c: Context, k: keyof Context[\"data\"]): any {\r\n        if (k in c.data) return this.__defaultGetter(c, k);\r\n        // if value not found in node, check in view.\r\n        return (this.get_view(c) as any)[k];\r\n        /*let ret: any;\r\n        let view = this.get_view(c);\r\n        try { ret = (view as any)[k] } catch (e) { Log.ee(\"Could not find get_ property \\\"\" + k + \"\\\" in node or view.\", {c, view, k}); return undefined; }\r\n        return ret;*/\r\n    }\r\n\r\n    protected _defaultSetter(v: any, c: Context, k: keyof Context[\"data\"]): true {\r\n        this.__defaultSetter(v, c, k);\r\n        return true;\r\n    }\r\n\r\n    get_graphAncestors(c: Context): LGraph[] {\r\n        let current = c.proxyObject;\r\n        let next = current.father;\r\n        let ret: LGraph[] = [];\r\n        while(next) {\r\n            if (RuntimeAccessibleClass.extends(next.className, DGraph.cname)) ret.push(next as LGraph);\r\n            if (current.id === next.id) break;\r\n            current = next;\r\n            next = next.father;\r\n        }\r\n        return ret;\r\n    }\r\n    get_outerGraph(context: Context): LGraph {\r\n        // todo: this relies on the fact that GraphVertex are not passing their own id to their childrens, but the parent graph id\r\n        return TargetableProxyHandler.wrap(context.data.graph);\r\n    }\r\n    get_vertex(context: Context): this[\"vertex\"] {\r\n        let lcurrent: LGraphElement = LPointerTargetable.fromPointer(context.data.id);\r\n        let dcurrent = lcurrent.__raw;\r\n        // iterate parents.\r\n        while(dcurrent){\r\n            switch(dcurrent.className){\r\n                case DVertex.cname:\r\n                case DVoidVertex.cname:\r\n                case DGraphVertex.cname: return (lcurrent || LPointerTargetable.fromD(dcurrent)) as LVoidVertex;\r\n                default:\r\n                    if (!dcurrent.father || dcurrent.id === dcurrent.father) return undefined;\r\n                    Log.exDev(!dcurrent.father || dcurrent.id === dcurrent.father, \"node failed to get containing vertex\", context.data, dcurrent, lcurrent);\r\n                    lcurrent = LPointerTargetable.fromPointer(dcurrent.father);\r\n                    dcurrent = lcurrent.__raw;\r\n            }\r\n        }\r\n        return undefined;\r\n    }\r\n\r\n    get_innerGraph(context: Context): LGraph {\r\n        let dcurrent = DPointerTargetable.fromPointer(context.data.father);\r\n\r\n        // if no parent, but it's a graph, return itself.\r\n        if (!dcurrent) {\r\n            dcurrent = context.data;\r\n            switch(dcurrent.className){\r\n                case DGraph.cname:\r\n                case DGraphVertex.cname: return (LPointerTargetable.fromD(dcurrent)) as LGraph;\r\n                default: return Log.exDevv(\"root node failed to get containing graph\", {cdata:context.data, dcurrent});\r\n            }\r\n        }\r\n\r\n        // if it have a parent, iterate parents.\r\n        while(true){\r\n            switch(dcurrent?.className){\r\n                case DGraph.cname:\r\n                case DGraphVertex.cname: return (LPointerTargetable.fromD(dcurrent)) as LGraph;\r\n                default:\r\n                    Log.exDev(!dcurrent.father, \"node failed to get containing graph\", {cdata:context.data, dcurrent});\r\n                    Log.exDev(dcurrent.id === dcurrent.father, \"node failed to get containing graph, found loop\",\r\n                        {cdata:context.data, dcurrent, father: LPointerTargetable.from(dcurrent)?.father});\r\n                    dcurrent = DPointerTargetable.fromPointer(dcurrent.father);\r\n            }\r\n        }\r\n    }\r\n\r\n    // set_x(val: this[\"x\"], context: Context): boolean { SetFieldAction.new(context.data.id, \"x\", val, undefined, false); return true; }\r\n    // get_x(context: Context): this[\"x\"] { return context.data.x; }\r\n    get_x(context: Context): this[\"x\"] { return this.get_size(context).x; }\r\n    set_x(val: this[\"x\"], context: Context): boolean { return this.set_size({x:val}, context); }\r\n    get_y(context: Context): this[\"y\"] { return this.get_size(context).y; }\r\n    set_y(val: this[\"y\"], context: Context): boolean { return this.set_size({y:val}, context); }\r\n\r\n    get_w(context: Context): this[\"w\"] { return this.get_size(context).w; }\r\n    set_w(val: this[\"w\"], context: Context): boolean { return this.set_size({w:val}, context); }\r\n    get_h(context: Context): this[\"h\"] { return this.get_size(context).h; }\r\n    set_h(val: this[\"h\"], context: Context): boolean { return this.set_size({h:val}, context); }\r\n\r\n    get_width(context: Context): this[\"w\"] { return this.get_w(context); }\r\n    set_width(val: this[\"w\"], context: Context): boolean { return this.set_w(val, context); }\r\n    get_height(context: Context): this[\"h\"] { return this.get_h(context); }\r\n    set_height(val: this[\"h\"], context: Context): boolean { return this.set_h(val, context); }\r\n\r\n    get_position(context: Context): this[\"position\"] { return new GraphPoint(context.data.x, context.data.y); }\r\n    set_position(val: this[\"position\"], c: Context): boolean {\r\n        TRANSACTION('drag' + this.get_name(c), ()=>{\r\n            SetFieldAction.new(c.data.id, \"x\", val.x, undefined, false);\r\n            SetFieldAction.new(c.data.id, \"y\", val.y, undefined, false);\r\n        }, IPoint.printDiff(c.data, val))\r\n        return true; }\r\n\r\n    get_sizeold(context: Context): this[\"size\"] { return new GraphSize(context.data.x, context.data.y, context.data.w, context.data.h); }\r\n    get_component(context: Context): this[\"component\"] {\r\n        // switch(context.data.className) { case DEdgePoint.name: return GraphElementComponent.map[context.data.father]; }\r\n        return GraphElementComponent.map[context.data.id]; }\r\n    // get_view(context: Context): this[\"view\"] { return this.get_component(context).props.view; }\r\n    get_view(context: Context): this[\"view\"] {\r\n        return transientProperties.node[context.data.id]?.mainView?.r || LPointerTargetable.fromPointer(context.data.view) || this.get_component(context)?.props.view?.r;\r\n    }\r\n    set_view(val: Pack1<this[\"view\"]>, context: Context){\r\n        Log.eDevv(\"node.view is readonly, change it through props or the model\");\r\n        // let ptr: DGraphElement[\"view\"] = Pointers.from(val as this[\"view\"]);\r\n        // return SetFieldAction.new(context.data.id, \"view\", ptr, '', true);\r\n    }\r\n\r\n    outerSize!: LGraphElement[\"size\"];\r\n    __info_of__outerSize: Info = {type:\"GraphSize\", txt:\"the size of the current element relative to the first (root) graph level.\"};\r\n    innerSize!: LGraphElement[\"size\"];\r\n    __info_of__innerSize: Info = {type:\"GraphSize\", txt:\"the size of the current element relative to the last (most nested) graph level.\"};\r\n    __info_of__size: Info = {type:\"GraphSize\", txt: \"same as innerSize.\"};\r\n\r\n\r\n    getSize(outer: boolean = false, canTriggerSet: boolean = true): Readonly<GraphSize> { return this.wrongAccessMessage(\"getSize()\"); }\r\n    get_getSize(c: Context): ((outer?: boolean, canTriggerSet?: boolean) => Readonly<GraphSize>) {\r\n        return (outer: boolean = true, canTriggerSet: boolean = true) => this.get_innerSize(c, canTriggerSet, outer); }\r\n\r\n    get_outerSize(context: Context, canTriggerSet: boolean = true): Readonly<GraphSize> {\r\n        return this.get_innerSize(context, canTriggerSet, true);\r\n    }\r\n    get_size(context: Context, canTriggerSet: boolean = true): Readonly<GraphSize> { return this.get_innerSize(context, canTriggerSet, false); }\r\n    get_innerSize(context: Context, canTriggerSet: boolean = true, outerSize: boolean = false): Readonly<GraphSize> {\r\n        let r = this.get_innerSize_impl(context, canTriggerSet, outerSize);\r\n        return new GraphSize(r.x, r.y, r.w, r.h);\r\n    }\r\n    protected get_innerSize_impl(context: Context, canTriggerSet: boolean = true, outerSize: boolean = false): Readonly<GraphSize> {\r\n        canTriggerSet = canTriggerSet && !Debug.lightMode;\r\n        let cname = context.data.className;\r\n        // cname = DGraphElement.cname;\r\n        switch (cname){\r\n            default: return Log.exDevv(\"unexpected classname in get_size switch: \" + context.data.className);\r\n            case DEdge.cname:\r\n            case DVoidEdge.cname:\r\n            case DGraph.cname: return nosize as any;\r\n            // case DField.cname:\r\n            case DGraphElement.cname:\r\n                let graph = outerSize ? this.get_outerGraph(context) : this.get_innerGraph(context);\r\n                return graph.coord(this.get_htmlSize(context));\r\n            case DVoidVertex.cname:\r\n            case DVertex.cname:\r\n            case DEdgePoint.cname:\r\n            case DGraphVertex.cname: break;\r\n        }\r\n\r\n        // low prio todo: memoization in proxy, as long state does not change keep a collection Dictionary[object][key] = returnval. it gets emptied when state is updated.\r\n\r\n        // when loading a save, edge segements and edgepoints/nodes are computed before creating the edgepoint component\r\n        let view: LViewElement = this.get_view(context);\r\n        // (window as any).retry = ()=>view.getSize(context.data.id);\r\n        let ret: EPSize = view.getSize(context.data.id) as any; // (this.props.dataid || this.props.nodeid as string)\r\n\r\n        if (!ret) {\r\n            ret = new GraphSize() as EPSize;\r\n            ret.x = context.data.x;\r\n            ret.y = context.data.y;\r\n            ret.w = context.data.w;\r\n            ret.h = context.data.h;\r\n            let def: GraphSize | undefined;\r\n            if (undefined===(ret.x)) { if (!def) def = view.defaultVSize; ret.x = def.x || 0;}\r\n            if (undefined===(ret.y)) { if (!def) def = view.defaultVSize; ret.y = def.y || 0;}\r\n            if (undefined===(ret.w)) { if (!def) def = view.defaultVSize; ret.w = def.w || 10;}\r\n            if (undefined===(ret.h)) { if (!def) def = view.defaultVSize; ret.h = def.h | 10;}\r\n            ret.currentCoordType = (context.data as DEdgePoint).currentCoordType as any;\r\n        }\r\n        if (context.data.className === DEdgePoint.cname) {\r\n            ret = (this as any as LEdgePoint).decodePosCoords(context, ret, view);\r\n        }\r\n\r\n        /*\r\n                if ((context.data as DVoidVertex).isResized) {\r\n                    return ret;\r\n                }*/\r\n        if (!canTriggerSet) {\r\n            if (outerSize) ret = this.get_outerGraph(context).translateSize(ret, this.get_innerGraph(context));\r\n            return ret;\r\n        }\r\n        let html: HTMLElement | undefined | null = this.get_component(context)?.html?.current;\r\n        let actualSize: Partial<Size> & {w:number, h:number} = html ? Size.of(html) : {w:0, h:0};\r\n        let isOldElement = (context.data.clonedCounter as number) > 3;\r\n        // if w = 0 i don't auto-set it as in first render it has w:0 because is not reredered and not resized.\r\n        // console.log(\"getSize() cantriggerset html size\", {ret: ret ? {...ret} : ret, html, actualSize, hcc:html?.dataset?.clonedcounter, ncc: context.data.clonedCounter});\r\n        if (!html || +(html.dataset.clonedcounter as string) !== context.data.clonedCounter) canTriggerSet = false;\r\n        let updateSize: boolean = false;\r\n        if (view.adaptWidth && ret.w !== actualSize.w) {\r\n            if (canTriggerSet && (isOldElement || actualSize.w !== 0)) {\r\n                ret.w = actualSize.w;\r\n                updateSize = true;\r\n            }\r\n        }\r\n        if (view.adaptHeight && ret.h !== actualSize.h) {\r\n            if (canTriggerSet && (isOldElement || actualSize.h !== 0)) {\r\n                ret.h = actualSize.h;\r\n                updateSize = true;\r\n            }\r\n        }\r\n        // console.log(\"getSize() from node merged with actualSize\", {ret: {...ret}});\r\n\r\n        if (updateSize) this.set_size(ret, context);\r\n        if (outerSize) ret = this.get_outerGraph(context).translateSize(ret, this.get_innerGraph(context));\r\n        return ret;\r\n    }\r\n    // set_size(size: Partial<this[\"size\"]>, context: Context): boolean {\r\n    set_size(size0: Partial<GraphSize>, c: Context): boolean {\r\n        // console.log(\"setSize(\"+(this.props?.data as any).name+\") thisss\", this);\r\n        if (!size0) return false;\r\n        let size = size0 as Partial<EPSize>;\r\n        let view = this.get_view(c);\r\n        let testmode: boolean = false;\r\n        if (c.data.className === DEdgePoint.cname && size.currentCoordType !== CoordinateMode.absolute) size = (this as any as LEdgePoint).encodePosCoords(c as any, size, view);\r\n\r\n        if (view.updateSize(c.data.id, size)) return true;\r\n\r\n        TRANSACTION('resize '+this.get_name(c), ()=>{\r\n            if (size.x !== c.data.x && size.x !== undefined) SetFieldAction.new(c.data.id, \"x\", size.x, undefined, false);\r\n            if (size.y !== c.data.y && size.y !== undefined) SetFieldAction.new(c.data.id, \"y\", size.y, undefined, false);\r\n            if (size.w !== c.data.w && size.w !== undefined) SetFieldAction.new(c.data.id, \"w\", size.w, undefined, false);\r\n            if (size.h !== c.data.h && size.h !== undefined) SetFieldAction.new(c.data.id, \"h\", size.h, undefined, false);\r\n            let epdata: DEdgePoint = c.data as DEdgePoint;\r\n            if (size.currentCoordType !== epdata.currentCoordType && size.currentCoordType !== undefined) SetFieldAction.new(epdata.id, \"currentCoordType\", size.currentCoordType, undefined, false);\r\n        }, undefined, ISize.printDiff(c.data, size))\r\n        return true; }\r\n\r\n    get_html(c: Context): this[\"html\"] {\r\n        let component = this.get_component(c);\r\n        let html = component?.html.current;\r\n        if (html) return html;\r\n        html = document.getElementById(c.data.id);//$('[nodeid=\"' + c.data.id + '\"]')[0];\r\n        if (!html) return undefined;\r\n        if (component) (component.html as any).current = html;\r\n        return html;\r\n    }\r\n    // get_html(context: Context): this[\"html\"] { return $(\"[node-id='\" + context.data.id + \"']\")[0]; }\r\n    set_html(val: this[\"htmlSize\"], context: Context): boolean { return this.cannotSet(\"set_html(). html is generated through jsx. edit the view instead.\"); }\r\n\r\n    get_htmlSize(context: Context): this[\"htmlSize\"] {\r\n        let html = this.get_html(context);\r\n        return html ? Size.of(html) : new Size(0, 0, 0, 0);\r\n        /*\r\n        let graph = this.get_graph(context);\r\n        if (!html) return nosize as any;\r\n        let size = Size.of(html);\r\n        let zoom = graph.zoom;\r\n        size.x /= zoom.x;\r\n        size.y /= zoom.y;\r\n        return size;*/}\r\n    set_htmlSize(val: this[\"htmlSize\"], context: Context): boolean {\r\n        // might be useful for fixed display size/location elements that stay in place even if you move tab or change zoom. debatable if needed\r\n        this.cannotSet(\"set_htmlSize(): todo extra low priority. set GraphSize through set_size instead.\");\r\n        return true; }\r\n    get_htmlPosition(context: Context): this[\"htmlPosition\"] { return this.get_htmlSize(context).tl(); }\r\n    set_htmlPosition(val: this[\"htmlPosition\"], context: Context): boolean {\r\n        // might be useful for fixed display size/location elements that stay in place even if you move tab or change zoom. debatable if needed\r\n        this.cannotSet(\"set_htmlPosition(): todo extra low priority. set graph position through set_position instead.\");\r\n        return true; }\r\n\r\n\r\n    /* how z-index work, it's really messy.\r\n    * cannot move html position. node id depends on it, and a node moving position would need to change id.\r\n    * so i use css order.\r\n    * first order is assigned through node constructor called by parent component injectProps, according to his last index in html.\r\n    * now z-index is set in node and updated properly.\r\n    * z-index is passed to a prop, rendered as html attribute.\r\n    * css takes the attribute value and uses it in \"order\" css rule.\r\n    * problem: updating node.z doesn't trigger the parent injectprops, so he inject html index and\r\n    * the outernmost html root cannot update his attribute without refreshing the parent and recalling injectprops\r\n    * fixed: by updating it directly in GraphElement.render()\r\n    * */\r\n    get_zIndex(context: Context): this[\"zIndex\"] { return (+context.data.zIndex || 0); }\r\n    set_zIndex(val: this[\"zIndex\"], c: Context): boolean {\r\n        val = +val ?? 0;\r\n        if (val === c.data.zIndex) return true;\r\n        TRANSACTION(this.get_name(c)+'.zIndex', ()=> {\r\n            SetFieldAction.new(c.data.id, \"zIndex\", val, undefined, false);\r\n        }, c.data.zIndex, val)\r\n        return true; }\r\n    get_z(context: Context): this[\"zIndex\"] { return context.data.zIndex; }\r\n    set_z(val: this[\"zIndex\"], context: Context): boolean { return this.set_zIndex(val, context); }\r\n    /*\r\n        get_containedIn(context: Context): this[\"containedIn\"] {\r\n            return context.data.containedIn ? LPointerTargetable.fromPointer(context.data.containedIn) : undefined; }\r\n        set_containedIn(val: Pack1<this[\"containedIn\"]>, context: LogicContext<DGraphElement>): boolean {\r\n            let ptr: DGraphElement[\"containedIn\"] = Pointers.from(val) as any;\r\n            SetFieldAction.new(context.data, 'containedIn', ptr, undefined, true);\r\n            if (ptr) SetFieldAction.new(ptr as any, 'subElements+=', context.data.id);\r\n            return true; }*/\r\n\r\n    nodes!:LVoidVertex[];\r\n    __info_of__nodes:Info = {type:'LVertex[]', txt: \"all direct sub-nodes. not including deep subelements (subelements of subelements)\"};\r\n    get_nodes(c: Context): this['nodes'] { return this.get_subElements(c).filter(c => c && c.className.indexOf('Vertex') >= 0) as any; }\r\n    set_nodes(val: never, c: Context): boolean { return this.cannotSet('nodes'); }\r\n    edges!:LVoidVertex[];\r\n    __info_of__edges:Info = {type:'LEdge[]', txt: \"all direct sub-edges. not including deep subelements (subelements of subelements)\"};\r\n    get_edges(c: Context): this['edges'] { return this.get_subElements(c).filter(c => c && c.className.indexOf('Edge') >= 0) as any; }\r\n    set_edges(val: never, c: Context): boolean { return this.cannotSet('edges'); }\r\n    graphs!:LVoidVertex[];\r\n    __info_of__graphs:Info = {type:'LGraph[]', txt: \"all direct sub-graphs. not including deep subelements (subelements of subelements)\"};\r\n    get_graphs(c: Context): this['graphs'] { return this.get_subElements(c).filter(c => c && c.className.indexOf('Graph') >= 0) as any; }\r\n    set_graphs(val: never, c: Context): boolean { return this.cannotSet('graphs'); }\r\n\r\n    allSubNodes!: LVoidVertex[];\r\n    __info_of__allSubNodes:Info = {type:'LVertex[]', txt: \"all deep sub-nodes. including subelements of subelements.\"};\r\n    get_allSubNodes(c: Context): this['allSubNodes'] { return this.get_allSubElements(c).filter(c => c && c.className.indexOf('Vertex') >= 0) as any; }\r\n    set_allSubNodes(val: never, c: Context): boolean { return this.cannotSet('allSubNodes'); }\r\n    allSubEdges!: LVoidEdge[];\r\n    __info_of__allSubEdges:Info = {type:'LEdge[]', txt: \"all deep sub-edges. including subelements of subelements.\"};\r\n    get_allSubEdges(c: Context): this['allSubEdges'] { return this.get_allSubElements(c).filter(c => c && c.className.indexOf('Edge') >= 0) as any; }\r\n    set_allSubEdges(val: never, c: Context): boolean { return this.cannotSet('allSubEdges'); }\r\n    allSubGraphs!: (LGraph | LGraphVertex)[];\r\n    __info_of__allSubGraphs:Info = {type:'LGraph[]', txt: \"all deep sub-graphs. including subelements of subelements.\"};\r\n    get_allSubGraphs(c: Context): this['allSubGraphs'] { return this.get_allSubElements(c).filter(c => c && c.className.indexOf('Graph') >= 0) as any; }\r\n    set_allSubGraphs(val: never, c: Context): boolean { return this.cannotSet('allSubGraphs'); }\r\n\r\n    subElements!: LGraphElement[]; // shallow, direct subelements\r\n    __info_of__subElements: Info = {type: 'LGraphElement[]',\r\n        txt: \"all direct subelements (nodes, edges, edgepoints, subgraphs...). not including deep subelements (subelements of subelements)\"}\r\n    get_subElements(context: Context): this[\"subElements\"] {\r\n        return LPointerTargetable.fromArr([...new Set(context.data.subElements)]).filter((e:L)=>!!e);\r\n    }\r\n    set_subElements(val: PackArr<this[\"subElements\"]>, context: LogicContext<DGraphElement>): boolean {\r\n        console.log(\"isDeepStrictEqual\", {isDeepStrictEqual});\r\n        Log.eDev([...new Set(val)].length !== val.length, \"subelemnts setter have duplicates\", {val, context});\r\n        // if (isDeepStrictEqual(context.data.subElements, val)) return true;\r\n        let pointers: Pointer<DGraphElement, 0, 'N', LGraphElement> = Pointers.from(val) || [];\r\n        if (Uarr.equals(pointers, context.data.subElements, false)) return true;\r\n\r\n        TRANSACTION(this.get_name(context as any)+'.subElements', ()=> {\r\n            SetFieldAction.new(context.data, 'subElements', pointers, '', true);\r\n            const idlookup = store.getState().idlookup;\r\n            let arrdiff = U.arrayDifference(context.data.subElements, pointers);\r\n            // old subelements\r\n            for (let oldsubelementid of arrdiff.removed) {\r\n                let subelement: DGraphElement = (oldsubelementid && idlookup[oldsubelementid]) as DGraphElement;\r\n                if (subelement.father !== context.data.id) continue;\r\n                LPointerTargetable.from(subelement).father = null as any; // todo: can this happen? è transitorio o causa vertici senza parent permanenti?\r\n            }\r\n            // new subelements\r\n            for (let newsubelementid of arrdiff.added) {\r\n                let subelement: DGraphElement = (newsubelementid && idlookup[newsubelementid]) as DGraphElement;\r\n                if (subelement.father === context.data.id) continue;\r\n                LPointerTargetable.from(subelement).father = context.data.id as any; // trigger side-action\r\n            }\r\n        })\r\n        return true;\r\n    }\r\n\r\n    allSubElements!: LGraphElement[]; // deep, nested subelements\r\n    __info_of__allSubElements: Info = {type: 'LGraphElement[]',\r\n        txt: \"all deep subelements (nodes, edges, edgepoints, subgraphs...). including subelements of subelements.\"}\r\n    private get_allSubElements(context: Context, state?: DState): this[\"allSubElements\"] {\r\n        // return context.data.packages.map(p => LPointerTargetable.from(p));\r\n        state = state || store.getState();\r\n        let tocheck: Pointer<DGraphElement>[] = context.data.subElements || [];\r\n        let checked: Dictionary<Pointer, true> = {};\r\n        let dblcheck: Dictionary<Pointer, Pointer> = {}; // <child, parent>  // debug only\r\n        for (let e of tocheck) dblcheck[e] = context.data.id; // debug only\r\n        checked[context.data.id] = true;//nb6[]{}&\r\n        while (tocheck.length) {\r\n            let newtocheck: Pointer<DGraphElement>[] = [];\r\n            for (let ptr of tocheck) {\r\n                Log.eDev(checked[ptr], \"loop in GraphElements containing themselves\", {\r\n                    dblcheck,\r\n                    context,\r\n                    ptr,\r\n                    checked,\r\n                    fistContainer: dblcheck[ptr]\r\n                });\r\n                if (checked[ptr]) continue;\r\n                checked[ptr] = true;\r\n                let subnode: DGraphElement = DPointerTargetable.from(ptr, state);\r\n                let se = subnode?.subElements;\r\n                //for (let e of se) dblcheck[e] = ptr; // debug only\r\n                U.arrayMergeInPlace(newtocheck, se);\r\n            }\r\n            tocheck = newtocheck;\r\n        }\r\n        delete checked[context.data.id];\r\n        return LPointerTargetable.from(Object.keys(checked), state);\r\n    }\r\n\r\n    set_allSubElements(val: never, c: Context): boolean {\r\n        return this.cannotSet('allSubElements');\r\n    }\r\n\r\n    get_isResized(context: LogicContext<DVoidVertex>): DVoidVertex[\"isResized\"] { return (context.data as DVertex).isResized; }\r\n    set_isResized(val: DVoidVertex[\"isResized\"], c: LogicContext<DVoidVertex>): DVoidVertex[\"isResized\"] {\r\n        val = !!val;\r\n        if (!!c.data.isResized === val) return true;\r\n        TRANSACTION(this.get_name(c as any as Context)+'.isResized', ()=> {\r\n            SetFieldAction.new(c.data.id, \"isResized\", val);\r\n        }, c.data.isResized, val)\r\n        return true;\r\n    }\r\n\r\n    get_model(context: Context): this[\"model\"] {\r\n        const modelElementId = context.data.model; //$('[id=\"' + context.data.id + '\"]')[0].dataset.dataid;\r\n        const lModelElement: LModelElement = LPointerTargetable.from(modelElementId as string);\r\n        return lModelElement;\r\n    }\r\n\r\n    assignEdgeAnchor!: ((anchorName?: string)=>void);\r\n    __info_of__assignEdgeAnchor!: {hidden:true, type:\"(anchorName?: string)=>void\", txt: \"Assign a specific anchor of this node to the edge currently following the cursor, if any.\"};\r\n    get_assignEdgeAnchor(c: Context): ((anchorName?: string)=>void) {\r\n        return (anchorName?: string)=>{\r\n            if (anchorName && !c.data.anchors[anchorName]) anchorName = undefined;\r\n            if (LVoidEdge.startFollow) {\r\n                let de: DEdge = DPointerTargetable.fromPointer(LVoidEdge.startFollow);\r\n                if (de.start !== c.data.id) return; // cannot change edge targets, only an anchor within the current targets\r\n                let le: LVoidEdge = LPointerTargetable.fromD(de);\r\n                le.anchorStart = anchorName;\r\n                le.startFollow = false;\r\n\r\n            }\r\n            if (LVoidEdge.endFollow) {\r\n                let de = DPointerTargetable.fromPointer(LVoidEdge.endFollow);\r\n                if (de.end !== c.data.id) return; // cannot change edge targets, only an anchor within the current targets\r\n                let le = LPointerTargetable.fromD(de);\r\n                le.anchorEnd = anchorName;\r\n                le.endFollow = false;\r\n            }\r\n        }\r\n    }\r\n    get_events(c: Context): LViewElement[\"events\"] {\r\n        const tn = transientProperties.node[c.data.id];\r\n        let mainview: DViewElement = tn.mainView.__raw;\r\n        let otherViews: DViewElement[] = tn.stackViews.map(v=>v.__raw);\r\n        let allviews: DViewElement[] = [mainview, ...otherViews].reverse();\r\n        const keep_for_closure_original_funcs: LViewElement[\"events\"] = {};\r\n        const ret: LViewElement[\"events\"] = {};\r\n        for (let dv of allviews) U.objectMergeInPlace(keep_for_closure_original_funcs, transientProperties.view[dv.id].events);\r\n\r\n        const lastContext: GObject = tn.viewScores[mainview.id].evalContext;\r\n        const keys = Object.keys(keep_for_closure_original_funcs);\r\n        // for (let k of keys) ret['_raw_'+k] = keep_for_closure_original_funcs[k];\r\n        for (let k of keys) {\r\n            if (!keep_for_closure_original_funcs[k]) continue;\r\n            ret[k] = (..._params: any) => keep_for_closure_original_funcs[k](lastContext, ..._params);\r\n        }\r\n\r\n        return ret; }\r\n\r\n\r\n    get_father(context: Context): this[\"father\"] { return LPointerTargetable.fromPointer(context.data.father); }\r\n    set_father(val: Pack1<this[\"father\"]>, c: Context): boolean {\r\n        let ptr: DGraphElement[\"father\"] = Pointers.from(val) as any;\r\n        TRANSACTION(this.get_name(c)+'.father', ()=> {\r\n            SetFieldAction.new(c.data, 'father', ptr, undefined, true);\r\n            if (ptr) SetFieldAction.new(ptr as any, 'subElements+=', c.data.id);\r\n        }, this.get_father(c).name, L.fromPointer(ptr).name)\r\n        return true; }\r\n\r\n    __info_of__isselected: Info = {type: \"Dictionary<Pointer<User>, true>\",\r\n        txt:<div>A map that contains all the users selecting this element as keys, and always true as a value (if present).\r\n            <br/>Edit it through node.select() and node.deselect()</div>}\r\n    __info_of__select: Info = {type:\"function(forUser?:Pointer<User>):void\", txt:\"Marks this node as selected by argument user.\"};\r\n    __info_of__deselect: Info = {type:\"function(forUser?:Pointer<User>):void\", txt:\"Un-marks this node as selected by argument user.\"};\r\n    __info_of__toggleSelect: Info = {type:\"function(usr?:Pointer<User>):void\", txt:\"Calls this.select(usr) if the node is selected by argument user, this.deselect(usr) otherwise. If omitted, argument \\\"usr\\\" is the current user id.<br>Returns the result of this.isSelected() after the toggle.\"};\r\n    __info_of__isSelected: Info = {type:\"function(forUser?:Pointer<User>):void\", txt:\"Tells if this node is selected by argument user.\"};\r\n    select(forUser?: Pointer<DUser>): void { return this.wrongAccessMessage(\"node.select()\"); }\r\n    deselect(forUser?: Pointer<DUser>): void { return this.wrongAccessMessage(\"node.deselect()\"); }\r\n    toggleSelected(forUser?: Pointer<DUser>): void { return this.wrongAccessMessage(\"node.toggleSelected()\"); }\r\n    isSelected(forUser?: Pointer<DUser>): boolean { return this.wrongAccessMessage(\"node.isSelected()\"); }\r\n    get_select(c: Context): (forUser?: Pointer<DUser>)=>void {\r\n        return (forUser?: Pointer<DUser>)=>{\r\n            if (!forUser) forUser = DUser.current;\r\n            Log.exDev(typeof forUser !== 'string', 'unexpected parameter in select()', {forUser});\r\n            if (c.data.isSelected[forUser]) return; // no-op\r\n            let map = {...c.data.isSelected};\r\n            map[forUser] = true;\r\n            let duser = DPointerTargetable.fromPointer(forUser);\r\n            TRANSACTION(this.get_name(c)+'.select('+ duser.name+')', ()=>{\r\n                SetFieldAction.new(c.data.id, \"isSelected\", map, undefined, false);\r\n            }, false, true)\r\n            // todo: actually they are pointer to users, but i'm assuming users are not erased at runtime. on deselect too\r\n        }\r\n    }\r\n    get_deselect(c: Context): (forUser?: Pointer<DUser>)=>void {\r\n        return (forUser?: Pointer<DUser>)=>{\r\n            if (!forUser) forUser = DUser.current;\r\n            Log.exDev(typeof forUser !== 'string', 'unexpected parameter in deselect()', {forUser});\r\n            if (!c.data.isSelected[forUser]) return; // no-op\r\n            let map = {...c.data.isSelected};\r\n            delete map[forUser];\r\n            let duser = DPointerTargetable.fromPointer(forUser);\r\n\r\n            TRANSACTION(this.get_name(c)+'.select('+ duser.name+')', ()=>{\r\n                // todo: actually they are pointer to users, but i'm assuming users are not erased at runtime. on deselect too\r\n                SetFieldAction.new(c.data.id, \"isSelected\", map, undefined, false);\r\n            })\r\n        }\r\n    }\r\n    get_toggleSelected(context: Context): ((forUser?: Pointer<DUser>) => boolean) {\r\n        return (forUser?: Pointer<DUser>): boolean => {\r\n            if (!forUser) forUser = DUser.current;\r\n            if (this.get_isSelected(context)(forUser)) {\r\n                this.get_deselect(context)(forUser);\r\n                return false;\r\n            } else {\r\n                this.get_select(context)(forUser);\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    get_isSelected(context: Context): ((forUser?: Pointer<DUser>) => boolean) {\r\n        return (forUser?: Pointer<DUser>): boolean => {\r\n            if (!forUser) forUser = DUser.current;\r\n            return !!context.data.isSelected[forUser]; }\r\n    }\r\n    set_isSelected(val: this[\"isSelected\"], context: Context): boolean {\r\n        return this.cannotSet(\"graphElement.isSelected(): use this.select() or this.deselect() instead.\");\r\n    }\r\n    /*\r\n    get_isSelected(context: LogicContext<DVoidVertex>): GObject {\r\n        return DPointerTargetable.mapWrap(context.data.isSelected, context.data, 'idlookup.' + context.data.id + '.isSelected', []);\r\n    }*/\r\n\r\n\r\n\r\n    // for edges\r\n    public get_startPoint(c: Context|undefined, size?: GraphSize, view?: LViewElement): GraphPoint { return this.get_startEndPoint(c, size, view, true); }\r\n    public get_endPoint(c: Context|undefined, size?: GraphSize, view?: LViewElement): GraphPoint { return this.get_startEndPoint(c, size, view, false); }\r\n    private get_startEndPoint(c: Context|undefined, size?: GraphSize, view?: LViewElement, isStart:boolean=true): GraphPoint {\r\n        if (!size) {\r\n            if (c) size = this.get_size(c) as any; else size = Log.exDevv(\"invalid arguments in get_startEndPoint\", {arguments});\r\n        }\r\n        if (!view) {\r\n            // if (c) view = this.get_view(c); else view = Log.exDevv(\"invalid arguments in get_startPoint\", {arguments});\r\n            view = c && this.get_view(c) || Log.exDevv(\"invalid arguments in get_startEndPoint\", {arguments});\r\n        }\r\n        let offset: GraphPoint = (view as LViewElement)[isStart ? \"edgeStartOffset\" : \"edgeEndOffset\"];\r\n        let isPercentage: boolean = (view as LViewElement)[isStart ? \"edgeStartOffset_isPercentage\" : \"edgeEndOffset_isPercentage\"];\r\n        if (!size) size = new GraphSize(0, 0, 0, 0);\r\n        if (isPercentage) offset = new GraphPoint(offset.x/100*(size.w), offset.y/100*(size.h));\r\n        return size.tl().add(offset, false);\r\n    }\r\n\r\n}\r\nRuntimeAccessibleClass.set_extend(DPointerTargetable, DGraphElement);\r\nRuntimeAccessibleClass.set_extend(LPointerTargetable, LGraphElement)\r\n\r\n\r\n@RuntimeAccessible('DGraph')\r\nexport class DGraph extends DGraphElement {\r\n    // static _super = DGraphElement;\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // static singleton: LGraph;\r\n    // static logic: typeof LGraph;\r\n    // static structure: typeof DGraph;\r\n\r\n    // inherit redefine\r\n    father!: Pointer<DGraphElement, 1, 1, LGraphElement>;\r\n    id!: Pointer<DGraph, 1, 1, LGraph>;\r\n    graph!: Pointer<DGraph, 1, 1, LGraph>;\r\n    model!: Pointer<DModelElement, 1, 1, LModelElement>;\r\n    isSelected!: Dictionary<DocString<Pointer<DUser>>, boolean>;\r\n    // containedIn!: Pointer<DGraphElement, 0, 1, LGraphElement>;\r\n\r\n    state!: GObject;\r\n    // personal attributes\r\n    zoom!: GraphPoint;\r\n    offset!: GraphPoint; // in-graph scrolling offset\r\n\r\n    public static new(htmlindex: number, model: DGraph[\"model\"],\r\n                      parentNodeID?: DGraphElement[\"father\"], // immediate parent\r\n                      parentgraphID?: DGraphElement[\"graph\"], // graph containing this subgraph (redudant? could get it from father chain)\r\n                      nodeID?: DGraphElement[\"id\"] // this id\r\n    ): DGraph {\r\n        return new Constructors(new DGraph('dwc'), parentNodeID, true, undefined, nodeID || Constructors.DGraph_makeID(model))\r\n            .DPointerTargetable()\r\n            .DGraphElement(model, parentgraphID, htmlindex).DGraph().end();\r\n    }\r\n\r\n\r\n    static getNodes(dmp: import(\"../logicWrapper/LModelElement\").DModelElement[], out: {$matched: JQuery<HTMLElement>; $notMatched: JQuery<HTMLElement>; }): JQuery<HTMLElement> {\r\n        let $allnodes = $('[data-dataid]');\r\n        let matchedids: Pointer[] = (dmp || []).map(d => d.id);\r\n        let matchedidmap:Dictionary<string, boolean> = U.objectFromArrayValues(matchedids);\r\n        if (!out) out = {} as any;\r\n\r\n        let allnodesarr = [...$allnodes];\r\n        let filternode = (d: HTMLElement) => {\r\n            if (!d?.dataset?.dataid) return false;\r\n            let id: string = ''+d?.dataset?.dataid;\r\n            return matchedidmap[id]; };\r\n        out.$matched = $(allnodesarr.filter(filternode));\r\n        out.$notMatched = $(allnodesarr.filter((n) => !filternode(n)));\r\n        return out.$matched;\r\n        // throw new Error(\"Method not implemented.\");\r\n    }\r\n\r\n}\r\nvar nosize: GraphSize = {x:0, y:0, w:0, h:0, nosize:true} as any;\r\nvar defaultEdgePointSize: GraphSize = undefined as any; // = {x:0, y:0, w:5, h:5};\r\nvar defaultVertexSize: GraphSize = undefined as any; // {x:0, y:0, w:140.6818084716797, h:32.52840805053711};\r\n\r\n\r\n@RuntimeAccessible('LGraph')\r\nexport class LGraph<Context extends LogicContext<DGraph> = any, D extends DGraph = any> extends LGraphElement {\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // static singleton: LGraph;\r\n    // static logic: typeof LGraph;\r\n    // static structure: typeof DGraph;\r\n\r\n    // inherit redefine\r\n    __raw!: DGraph;\r\n    id!: Pointer<DGraph, 1, 1, LGraph>;\r\n    graph!: LGraph;\r\n    model?: LModelElement;\r\n    // isSelected: Dictionary<DocString<Pointer<DUser>>, boolean> = {};\r\n    isSelected(forUser?: Pointer<DUser>): boolean { return this.wrongAccessMessage(\"node.isSelected()\"); }\r\n    // containedIn?: LGraphElement;\r\n    subElements!: LGraphElement[];\r\n    _state!: GObject<\"proxified\">; // LMap;\r\n    // personal attributes\r\n    zoom!: GraphPoint;\r\n    graphSize!: GraphSize; // derived attribute: bounding rect containing all subnodes, while \"size\" is instead external size of the vertex holding the graph in GraphVertexes\r\n    offset!: GraphPoint; // Scrolling position inside the graph\r\n\r\n    // get_graphSize(context: LogicContext<DGraph>):  Readonly<GraphSize> { return todo: get bounding rect containing all subnodes.; }\r\n    get_offset(context: LogicContext<DGraph>):  Readonly<GraphSize> {\r\n        let offset: Partial<GraphSize> = (context.data.offset || new GraphSize()) as any;\r\n        return new GraphSize(offset.x, offset.y, offset.w, offset.h);\r\n    }\r\n    set_offset(val: Partial<GraphSize>, context: Context): boolean {\r\n        if (!val) val = {x:0, y:0, w:0, h:0};\r\n        //if (val.x === undefined && val.y === undefined && val.w === undefined && val.h === undefined) return true;\r\n        let offset: Partial<GraphSize> = (context.data.offset || new GraphSize()) as any\r\n        if (val.x === undefined && offset.x !== val.x) val.x = offset.x;\r\n        if (val.y === undefined && offset.y !== val.y) val.y = offset.y;\r\n        if (val.w === undefined && offset.w !== val.w) val.w = offset.w;\r\n        if (val.h === undefined && offset.h !== val.h) val.h = offset.h;\r\n        if (offset.x === val.x && offset.y === val.y && offset.w === val.w && offset.h == val.h) return true;\r\n\r\n        TRANSACTION(this.get_name(context)+'.offset', ()=>{\r\n            SetFieldAction.new(context.data, \"offset\", val as any);\r\n        }, IPoint.stringify(offset), IPoint.stringify(val))\r\n        return true;\r\n    }\r\n\r\n    public cumulativeZoom!: GraphPoint;\r\n    public __info_of__cumulativeZoom: Info = {type: GraphPoint.cname, txt: \"the product of all the ownZoom of containing ancestor graphs.\"};\r\n    private get_cumulativeZoom(c:Context): this['cumulativeZoom']{\r\n        let ancestors = [c.proxyObject, ...this.get_graphAncestors(c)];\r\n        let zoom: GraphPoint = new GraphPoint(1,1);\r\n        for (let g of ancestors) zoom.multiply(g.ownZoom, false);\r\n        return zoom;\r\n    }\r\n\r\n    get_zoom(c: Context): GraphPoint {\r\n        return this.get_cumulativeZoom(c);\r\n    }\r\n    public ownZoom!: GraphPoint;\r\n    __info_of__ownZoom: Info = {type:GraphPoint.cname, label:\"zoom\", txt:\"The individual zoom applied to this graph.\"};\r\n    __info_of__zoom: Info = {type:GraphPoint.cname, label:\"zoom\", txt:\"Scales the graph and all subelements by a factor.\"};\r\n    get_ownZoom(context: Context): GraphPoint {\r\n        const zoom: GraphPoint = context.data.zoom;\r\n        let ret = new GraphPoint(zoom.x||1, zoom.y||1); // NB: do not use (??1), zero is not a valid value for zoom.\r\n        // (zoom as any).debug = {rawgraph: context.data.__raw, zoomx: context.data.zoom.x, zoomy: context.data.zoom.y}\r\n        return ret; }\r\n    set_zoom(val: Partial<GraphPoint>, c: Context): boolean{\r\n        if (!val) val = {x:1, y:1};\r\n        //if (val.x === undefined && val.y === undefined) return true;\r\n        let zoom: Partial<GraphSize> = (c.data.zoom || new GraphSize()) as any;\r\n        if (!val.x) val.x = zoom.x; // remember zero is not allowed value\r\n        if (!val.y) val.y = zoom.y;\r\n        if (zoom.x === val.x && zoom.y === val.y) return true;\r\n\r\n        TRANSACTION(this.get_name(c)+'.zoom', ()=>{\r\n            SetFieldAction.new(c.data, 'zoom', val as any, '+=', false);\r\n        }, IPoint.stringify(zoom), IPoint.stringify(val))\r\n        return true;\r\n    }\r\n\r\n    toGraphSize(...a:Parameters<this[\"coord\"]>): ReturnType<this[\"coord\"]>{ return this.wrongAccessMessage(\"toGraphSize\"); }\r\n    coord(htmlSize: Size): GraphSize { return this.wrongAccessMessage(\"toGraphSize\"); }\r\n    get_coord(context: Context): (htmlSize: Size) => GraphSize {\r\n        return (htmlSize: Size)=> {\r\n            let graphHtmlSize: Size = this.get_htmlSize(context);\r\n            let zoom: GraphPoint = this.get_zoom(context);\r\n            return new GraphSize(\r\n                (htmlSize.x - graphHtmlSize.x) / zoom.x,\r\n                (htmlSize.y - graphHtmlSize.y) / zoom.y,\r\n                htmlSize.w/zoom.x,\r\n                htmlSize.h/zoom.y);\r\n        }\r\n    }\r\n    // get_htmlSize(context: Context): Size { }\r\n    translateSize<T extends GraphSize|GraphPoint>(ret: T, innerGraph: LGraph): T { return this.wrongAccessMessage(\"translateSize()\"); }\r\n    translateHtmlSize<T extends Size|Point, G = T extends Size ? GraphSize : GraphPoint>(size: T): G { return this.wrongAccessMessage(\"translateHtmlSize()\"); }\r\n\r\n    __info_of__offset: Info = {type:GraphPoint.cname, label:\"offset\", txt:\"In-graph scrolling position.\"};\r\n    __info_of__graphSize: Info = {type:GraphSize.cname, label:\"graphSize\", txt:\"size internal to the graph, including internal scroll and panning.\"};\r\n    __info_of__translateSize: Info = {type:\"(T, Graph)=>T where T is GraphSize | GraphPoint\", txt:\"Translates a coordinate set from the local coordinates of a SubGraph to this Graph containing it.\"};\r\n    __info_of__translateHtmlSize: Info = {type:\"(Size|Point) => GraphSize|GraphPoint\", txt:'Translate page\\'s viewport coordinate set to this graph coordinate set.'};\r\n    get_translateHtmlSize<T extends Size|Point, G = T extends Size ? GraphSize : GraphPoint>(c: Context): ((size: T) => G) {\r\n        return (size: T): G => {\r\n            let rootGraph: LGraph = this.get_root(c);\r\n            if (rootGraph.id === c.data.id) return this.get_translateHtmlSize_fromRoot<T, G>(c)(size);\r\n            let fakeRootSize = rootGraph.translateHtmlSize_fromRoot<T, G>(size) as any as ISize;\r\n            let screenOffset = this.get_screenOffset(c);//cumulative (g.size.tl()-offset.tl()*cumulativezoom)\r\n\r\n            // distance from the origin of the subgraph in rendered pixels\r\n            let ret = new GraphSize(fakeRootSize.x - screenOffset.x, fakeRootSize.y - screenOffset.y, fakeRootSize.w, fakeRootSize.h);\r\n            return ret.divide(this.get_cumulativeZoom(c) as any, false) as any;\r\n\r\n            /*\r\n            // fake because it assumes all subgraphs have the same zoom level of current graph.\r\n            let ancestors = this.get_graphAncestors(c).reverse().slice(1);\r\n            let cumulativeZoom: GraphPoint = new GraphPoint(1, 1); // = this.get_ownZoom(c);\r\n            for (let g of ancestors){\r\n                let offset = g.offset;\r\n                let ownZoom = g.ownZoom;\r\n                cumulativeZoom.multiply(ownZoom);\r\n                // let a, b, c be graphs\r\n                // size is =  a.zoom + a.offset\r\n\r\n            }\r\n            */\r\n        }\r\n    }\r\n    screenOffset!: GraphPoint;\r\n    __info_of__screenOffset: Info = {type: GraphPoint.cname, txt:\"Distance of the subgraph origin in rendered pixels. to the top-left of graph container.\"}\r\n    private get_screenOffset(c: Context): GraphPoint{\r\n        let ancestors = [c.proxyObject, ...this.get_graphAncestors(c)].reverse();\r\n        let ret = new GraphPoint(0, 0);\r\n        let cumulativeZoom: GraphPoint = new GraphPoint(1, 1); // = this.get_ownZoom(c);\r\n        for (let g of ancestors){\r\n            let offset = g.offset;\r\n            let ownZoom = g.ownZoom;\r\n            let size = g.size;\r\n            ret\r\n                .add(size.tl().multiply(cumulativeZoom, false), false)\r\n                .subtract(offset, false);\r\n            cumulativeZoom.multiply(ownZoom);\r\n            ret\r\n                .multiply(cumulativeZoom, false);\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    private translateHtmlSize_fromRoot<T extends Size|Point, G = T extends Size ? GraphSize : GraphPoint>(size: T):G {\r\n        return this.wrongAccessMessage('translateHtmlSize_fromRoot');\r\n    }\r\n\r\n    /**\r\n     *  IMPORTANT!\r\n     *  this is a wrong partial result, do not call this function directly outside translateHtmlSize.\r\n     *  this is outercoord without zoom, needs ti be translated to container graph coords & de-apply zoom\r\n     */\r\n    private get_translateHtmlSize_fromRoot<T extends Size|Point, G = T extends Size ? GraphSize : GraphPoint>(c: Context): ((size: T) => G) {\r\n        return (size: T): G => {\r\n            let graphHtmlSize = this.get_htmlSize(c);\r\n            let a = size.subtract(graphHtmlSize.tl(), true);\r\n            let offset = {x:c.data.offset.x, y:c.data.offset.y};\r\n            let b = a.subtract(offset, true);\r\n            let r = b.divide(c.data.zoom as any, false) as any as G;\r\n            return r;\r\n        }\r\n    }\r\n\r\n    // graph_of_size, the size parameter have coordinates based on this graph.\r\n    get_translateSize<T extends GraphSize|GraphPoint>(c: Context): ((size: T, graph_of_size: LGraph) => T) {\r\n        return (size: T, graph_of_size: LGraph): T => {\r\n            let targetGraph: LGraph = c.proxyObject;\r\n            let currGraph: LGraph = graph_of_size;\r\n            if (currGraph.id === c.data.id) return size;\r\n            let currAncestors: LGraph[] = [currGraph, ...currGraph.graphAncestors];\r\n            let targetAncestors: LGraph[] = [targetGraph, ...targetGraph.graphAncestors];\r\n            let currAncestorsPtr: Pointer<DGraph>[] = currAncestors.map(l=>l.id).reverse();\r\n            let targetAncestorsPtr: Pointer<DGraph>[] = targetAncestors.map(l=>l.id).reverse();\r\n            Log.ex(targetAncestorsPtr[0] !== currAncestorsPtr[0],\r\n                'translateSize() The root graph of 2 elements should always be the same, are you comparing nodes from different graphs?',\r\n                {currGraph, targetGraph});\r\n            let i: number = 1;\r\n            while (currAncestorsPtr[i] === targetAncestorsPtr[i]) { i++; }\r\n            let commonAncestor: Pointer<DGraph> = targetAncestorsPtr[i-1];\r\n            currAncestors = currAncestors.slice(0, currAncestors.length - i).filter(e=>!!e);\r\n            targetAncestors = targetAncestors.slice(0, currAncestors.length - i).filter(e=>!!e);\r\n            // d, c, b, a           currAncestors\r\n            // d, c, x, y           targetAncestors\r\n            // undo a,b, redo x,y        i = [2]\r\n\r\n            Log.exDev(!currAncestors.length && !targetAncestors.length, \"translateSize() found invalid intersection in container graphs\",\r\n                {currGraph, targetGraph, currAncestors, targetAncestors});\r\n            // @ts-ignore\r\n            let ret: T = 'w' in size ? new GraphSize(size.x, size.y, size.w, size.h) : new GraphPoint(size.x, size.y, size.w, size.h);\r\n            console.log(\"translateSizee pre\", (this.get_model(c) as any).name, size.x, size.y, {size, ret, currAncestors, targetAncestors} )\r\n            for (let g of currAncestors){\r\n                ret.subtract(g.offset, false);\r\n                ret.divide(g.cumulativeZoom, false);\r\n                ret.add(g.size.tl(), false);\r\n            }\r\n            for (let g of targetAncestors){\r\n                ret.subtract(g.size.tl(), false);\r\n                ret.multiply(g.cumulativeZoom, false);\r\n                ret.add(g.offset, false);\r\n            }\r\n            console.log(\"translateSizee ret\", (this.get_model(c) as any).name, size.x, size.y, {size, ret, currAncestors, targetAncestors} )\r\n\r\n            return ret; }\r\n        //todo: check how many passes you need to go down or up, and make the up version too\r\n\r\n    }\r\n    get_translateSize_down_old<T extends GraphSize|GraphPoint>(c: Context): ((size: T, innerGraph: LGraph) => T) {\r\n        return (size: T, graph_of_size: LGraph): T => {\r\n            graph_of_size = LPointerTargetable.wrap(graph_of_size) as LGraph;\r\n            let ret: T = (size.hasOwnProperty(\"w\") ? new GraphSize(size.x, size.y, (size as GraphSize).w, (size as GraphSize).h) : new GraphPoint(size.x, size.y)) as T;\r\n            Log.ex(!graph_of_size, \"translateSize() graph parameter is invalid: \"+graph_of_size, graph_of_size, c);\r\n            let ancestors: LGraph[] = [graph_of_size, ...graph_of_size.graphAncestors];\r\n            console.log(\"translateSize\", {innerGraph: graph_of_size, ret, ancestors, c});\r\n            Log.ex(ancestors.indexOf(c.proxyObject) !== -1, \"translateSize() graph parameter is invalid: it must be a graph containing the current one.\", graph_of_size, c);\r\n            for (let g of ancestors) ret.add(g.size.tl(), false);\r\n            // for (let g of ancestors) ret.subtract(g.offset, false);\r\n            // console.log(\"translateSize\", {c, thiss:c.proxyObject, ancestors, ancestorSizes: ancestors.map(a=> a.size.tl()), size, ret});\r\n            return ret; }\r\n    }\r\n    contains(elem: LGraphElement): boolean{ return this.wrongAccessMessage(\"contains()\"); }\r\n    get_contains(c: Context): ((elem: LGraphElement)=> boolean) {\r\n        return (elem: LGraphElement): boolean => {\r\n            let current = elem;\r\n            let next = elem.father;\r\n            let targetid = c.proxyObject.id;\r\n            if (current.id !== targetid) return true;\r\n            while(next && current.id !== next.id) {\r\n                current = next;\r\n                next = next.father;\r\n                if (current.id !== targetid) return true;\r\n            }\r\n            return false;\r\n        }}\r\n}\r\nRuntimeAccessibleClass.set_extend(DGraphElement, DGraph);\r\nRuntimeAccessibleClass.set_extend(LGraphElement, LGraph);\r\n// export const defaultVSize: GraphSize = new GraphSize(0, 0, 300, 160); // useless, now it's in view.DefaultVSize\r\n// export const defaultEPSize: GraphSize = new GraphSize(0, 0, 15, 15); // useless, now it's in view.DefaultVSize\r\n\r\n\r\n@RuntimeAccessible('DVoidVertex')\r\nexport class DVoidVertex extends DGraphElement {\r\n    // static _super = DGraphElement;\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // static singleton: LVoidVertex;\r\n    // static logic: typeof LVoidVertex;\r\n    // static structure: typeof DVoidVertex;\r\n\r\n    // inherit redefine\r\n    id!: Pointer<DVoidVertex, 1, 1, LVoidVertex>;\r\n    graph!: Pointer<DGraph, 1, 1, LGraph>;\r\n    model!: Pointer<DModelElement, 0, 1, LModelElement>;\r\n    isSelected!: Dictionary<DocString<Pointer<DUser>>, boolean>;\r\n    // containedIn!: Pointer<DGraphElement, 0, 1, LGraphElement>;\r\n    subElements!: Pointer<DGraphElement, 0, 'N', LGraphElement>;\r\n    state!: GObject;\r\n    zoom!: GraphPoint;\r\n    // personal attributes\r\n    x!: number;\r\n    y!: number;\r\n    w!: number;\r\n    h!: number;\r\n    isResized!: boolean;\r\n    // size?: GraphSize; // virtual, gets extracted from this. x and y are stored directly here as it extends GraphSize\r\n\r\n    public static new(htmlindex: number, model: DGraphElement[\"model\"], parentNodeID: DGraphElement[\"father\"], graphID: DGraphElement[\"graph\"], nodeID?: DGraphElement[\"id\"],\r\n                      size?: InitialVertexSize): DVoidVertex {\r\n        return new Constructors(new DVoidVertex('dwc'), parentNodeID, true, undefined, nodeID)\r\n            .DPointerTargetable()\r\n            .DGraphElement(model, graphID, htmlindex)\r\n            .DVoidVertex(size || defaultVertexSize).end();\r\n    }\r\n\r\n}\r\n\r\n@RuntimeAccessible('LVoidVertex')\r\nexport class LVoidVertex<Context extends LogicContext<DVoidVertex> = any, C extends Context = Context> extends LGraphElement {// <D extends DVoidVertex = any>\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // static singleton: LVoidVertex;\r\n    // static logic: typeof LVoidVertex;\r\n    // static structure: typeof DVoidVertex;\r\n\r\n    // inherit redefine\r\n    __raw!: DVoidVertex;\r\n    id!: Pointer<DVoidVertex, 1, 1, LVoidVertex>;\r\n    graph!: LGraph;\r\n    model?: LModelElement;\r\n    // isSelected: Dictionary<DocString<Pointer<DUser>>, boolean> = {};\r\n    isSelected(forUser?: Pointer<DUser>): boolean { return this.wrongAccessMessage(\"node.isSelected()\"); }\r\n    // containedIn?: LGraphElement;\r\n    subElements!: LGraphElement[];\r\n    _state!: GObject<\"proxified\">; // LMap;\r\n    zoom!: GraphPoint;\r\n    isResized!: boolean;\r\n\r\n    // personal attributes\r\n    x!: number;\r\n    y!: number;\r\n    w!: number;\r\n    h!: number;\r\n    size!: GraphSize; // virtual, gets extracted from this. x and y are stored directly here as it extends GraphSize\r\n    __info_of__size = {type: \"?GraphSize\", txt: \"Size of the vertex, if null it means is utilizing the defaultSize from view. recommended to read component.getSize() instead of this.\"};\r\n\r\n    get_isResized(context: LogicContext<DVoidVertex>): DVoidVertex[\"isResized\"] { return context.data.isResized; }\r\n    set_isResized(val: DVoidVertex[\"isResized\"], context: LogicContext<DVoidVertex>): DVoidVertex[\"isResized\"] {\r\n        val = !!val;\r\n        if (!!context.data.isResized === val) return true;\r\n        TRANSACTION(this.get_name(context)+'.isResized', ()=>{\r\n            SetFieldAction.new(context.data.id, \"isResized\", val);\r\n        }, context.data.isResized, val)\r\n        return true;\r\n    }\r\n\r\n\r\n\r\n}\r\n\r\nRuntimeAccessibleClass.set_extend(DGraphElement, DVoidVertex);\r\nRuntimeAccessibleClass.set_extend(LGraphElement, LVoidVertex);\r\n@RuntimeAccessible('DEdgePoint')\r\nexport class DEdgePoint extends DVoidVertex { // DVoidVertex\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // static singleton: LEdgePoint;\r\n    // static logic: typeof LEdgePoint;\r\n    // static structure: typeof DEdgePoint;\r\n\r\n    // inherit redefine\r\n    id!: Pointer<DEdgePoint, 1, 1, LEdgePoint>;\r\n    father!: Pointer<DVoidEdge, 1, 1, LVoidEdge>;\r\n    graph!: Pointer<DGraph, 1, 1, LGraph>;\r\n    model!: Pointer<DModelElement, 0, 1, LModelElement>; // todo: if null gets model from this.father (edge)?\r\n    isSelected!: Dictionary<DocString<Pointer<DUser>>, boolean>;\r\n    // containedIn!: Pointer<DGraphElement, 0, 1, LGraphElement>;\r\n    subElements!: Pointer<DGraphElement, 0, 'N', LGraphElement>;\r\n    zoom!: GraphPoint;\r\n    x!: number;\r\n    y!: number;\r\n    w!: number;\r\n    h!: number;\r\n    size?: GraphSize; //／／ virtual, gets extracted from this. x and y are stored directly here as it extends GraphSize\r\n    // personal attributes\r\n    __isDEdgePoint!: true;\r\n    currentCoordType?: CoordinateMode;\r\n\r\n    public static new(htmlindex: number, model: DEdgePoint[\"model\"] | undefined, parentNodeID: DEdgePoint[\"father\"], graphID?: DEdgePoint[\"graph\"], nodeID?: DGraphElement[\"id\"],\r\n                      size?: InitialVertexSize): DEdgePoint {\r\n        return new Constructors(new DEdgePoint('dwc'), parentNodeID, true, undefined, nodeID)\r\n            .DGraphElement(undefined, graphID, htmlindex)\r\n            .DVoidVertex(size || defaultEdgePointSize).DEdgePoint().end();\r\n    }\r\n\r\n}\r\n\r\n@RuntimeAccessible('LEdgePoint')\r\nexport class LEdgePoint<Context extends LogicContext<DEdgePoint> = any, C extends Context = Context> extends LVoidVertex {\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // static singleton: LEdgePoint;\r\n    // static logic: typeof LEdgePoint;\r\n    // static structure: typeof DEdgePoint;\r\n\r\n    // inherit redefine\r\n    father!: LVoidEdge;\r\n    // __raw!: DEdgePoint;\r\n    id!: Pointer<DEdgePoint, 1, 1, LEdgePoint>;\r\n    graph!: LGraph;\r\n    model?: LModelElement;\r\n    // isSelected: Dictionary<DocString<Pointer<DUser>>, boolean> = {};\r\n    isSelected(forUser?: Pointer<DUser>): boolean { return this.wrongAccessMessage(\"node.isSelected()\"); }\r\n    // containedIn?: LGraphElement;\r\n    subElements!: LGraphElement[];\r\n    zoom!: GraphPoint;\r\n    x!: number;\r\n    y!: number;\r\n    w!: number;\r\n    h!: number;\r\n    size!: GraphSize; // virtual, gets extracted from this. x and y are stored directly here as it extends GraphSize\r\n    // personal attributes\r\n    __isLEdgePoint!: true;\r\n    edge!: LVoidEdge; // returns container edge\r\n    __info_of__edge: Info = {type:\"?LEdge\", txt:\"returns the containing edge if called on an EdgePoint, \\\"this\\\" if called on an edge, undefined otherwise.\"}\r\n\r\n    public get_edge(c: Context): LVoidEdge { return c.proxyObject.father; }\r\n    public set_edge(v: Pack1<LVoidEdge>, c: Context): boolean { return this.set_father(v as any, c); }\r\n\r\n\r\n\r\n\r\n    static decodeCoords<T extends Partial<EPSize>>(size0: T, sp:GraphPoint, ep: GraphPoint): T/*absolute*/{\r\n        let size: any = size0;\r\n        let ret: any = ((\"w\" in size || \"h\" in size) ? new GraphSize() : new GraphPoint()); // GObject<Partial<GraphSize>>;\r\n        switch (size.currentCoordType) {\r\n            default: return Log.exDevv(\"translatePosCoords() invalid coordinate mode\", {mode:size.currentCoordType});\r\n            // case CoordinateMode.absolute: return size;\r\n            case CoordinateMode.absolute: case undefined: case null:\r\n                if (size.x !== undefined) ret.x = size.x;\r\n                if (size.y !== undefined) ret.y = size.y;\r\n                break;\r\n            case CoordinateMode.relativePercent:\r\n                //maybe do: dampening factor on relative % offset? is it possible?\r\n                // let s = this.getBasicSize(c);\r\n                // MATH:\r\n                // size.x = sp.x*x% + ep.x*(1-x%)\r\n                // size.x = sp.x*x% + ep.x - ep.x*x%\r\n                // size.x - ep.x= (sp.x - ep.x)*x%\r\n                // (size.x - ep.x) / (sp.x - ep.x) = x% // actually i inverted <sp, ep> in first equation, so reverse them in result too.\r\n                if (size.x !== undefined) ret.x = (1 - size.x) * sp.x + (size.x) * ep.x;\r\n                if (size.y !== undefined) ret.y = (1 - size.y) * sp.y + (size.y) * ep.y;\r\n                break;\r\n            case CoordinateMode.relativeOffset:\r\n            case CoordinateMode.relativeOffsetStart:\r\n            case CoordinateMode.relativeOffsetEnd:\r\n                let useStart: boolean;\r\n                let useEnd: boolean;\r\n                switch (size.currentCoordType) {\r\n                    default:\r\n                    case CoordinateMode.relativeOffset: useStart = true; useEnd = true; break;\r\n                    case CoordinateMode.relativeOffsetStart: useStart = true; useEnd = false; break;\r\n                    case CoordinateMode.relativeOffsetEnd: useStart = false; useEnd = true; break;\r\n                }\r\n                // offset = sp - size\r\n                // size = offset - sp\r\n                // in reverse: actualsize = offset, size=offset\r\n\r\n                // if coords are already in absolute mode.\r\n                let xIsAbsolute: number | undefined = (size.x&&!Array.isArray(size.x)) ? size.x : undefined;\r\n                let yIsAbsolute: number | undefined = (size.x&&!Array.isArray(size.x)) ? size.x : undefined;\r\n                Log.w(!!(xIsAbsolute || yIsAbsolute), \"decoding relative offset require an array size coordinate system. x=[x1, x2] --> x\", {size});\r\n\r\n                let offsetsp = useStart ? new GraphPoint(xIsAbsolute || size.x[0] + sp.x, yIsAbsolute || size.y[0] + sp.y) : new GraphPoint();\r\n                let offsetep = useEnd ? new GraphPoint(xIsAbsolute || size.x[1] + ep.x, yIsAbsolute || size.y[1] + ep.y) : new GraphPoint();\r\n                // if the start and endpoint of the edge didn't move, offsetsp = offsetep.\r\n                // if they moved, those 2 are discordant --> i pick middle\r\n                offsetsp.add(offsetep, false);\r\n                if (useStart && useEnd) offsetsp.divide(2, false);\r\n                if (!xIsAbsolute && size.x !== undefined) ret.x = offsetsp.x;\r\n                if (!yIsAbsolute && size.y !== undefined) ret.y = offsetsp.y;\r\n                if (xIsAbsolute) {\r\n                    ret.x = size.x;\r\n                }\r\n                if (yIsAbsolute) {\r\n                    ret.y = size.y;\r\n                }\r\n                break;\r\n        }\r\n        if (size.x === undefined) delete ret.x;\r\n        if (size.y === undefined) delete ret.y;\r\n        if ((size as any).w === undefined) delete ret.w; else ret.w = size.w;\r\n        if ((size as any).h === undefined) delete ret.h; else ret.h = size.h;\r\n        ret.currentCoordType = CoordinateMode.absolute;\r\n        // console.log(\"decode coords\", {size, sp, ep, ret});\r\n        return ret;\r\n    }\r\n    // from x,y as coords, to x%,y% as % of ((1-val)%*startpt) + ((val)%*endpt)\r\n    public decodePosCoords<T extends Partial<GraphSize> | Partial<GraphPoint>>(c: Context, size: T&any, view: LViewElement, sp0?: GraphPoint, ep0?: GraphPoint): T {\r\n        let le: LVoidEdge = c&&c.proxyObject.father;\r\n        // console.log(\"decodepos:\", {le, sp0, lesp:le?.startPoint});\r\n        let sp: GraphPoint = sp0||le.startPoint;\r\n        let ep: GraphPoint = ep0||le.endPoint;\r\n        return LEdgePoint.decodeCoords(size, sp, ep);\r\n    }\r\n\r\n    static testCoords(range: number = 30){\r\n        outer: for (let mode of [\"absolute\", \"relative%\", \"relativeOffset\", \"relativeOffsetStart\", \"relativeOffsetEnd\"])\r\n            for (let i = -range; i < range; i++)\r\n                for (let j = -range; j < range; j++){\r\n                    var s0 = {x:i, y:j};\r\n                    var sp = {x:10, y:10};\r\n                    var ep = {x:10, y:-10};\r\n                    // @ts-ignore\r\n                    var s1 = LEdgePoint.encodeCoords(s0, mode, sp, ep)\r\n                    // @ts-ignore\r\n                    var s00 = LEdgePoint.decodeCoords(s1, sp, ep);\r\n                    // @ts-ignore\r\n                    var error = Object.keys(s0).map( k=> s0[k].toFixed(3) === s00[k].toFixed(3) ? '' : k).join('');\r\n                    (mode != \"relative%\" && error ? console.error : console.log)({diff:[s00.x-s0.x, s00.y-s0.y].join(), i, j, mode, s1:[s1.x, s1.y].join(), s0, s00, error});\r\n                    if (mode != \"relative%\" && error ) break outer;\r\n                }\r\n    }\r\n    // @ts-ignore a\r\n\r\n    static encodeCoords<T extends Partial<EPSize>>(size0: T, edgePointCoordMode: CoordinateMode, sp:GraphPoint, ep: GraphPoint): T/*absolute*/{\r\n        let size: T = size0 as any;\r\n        if (edgePointCoordMode === size.currentCoordType ||\r\n            !size.currentCoordType && edgePointCoordMode === CoordinateMode.absolute) return size;\r\n        if (size.currentCoordType && size.currentCoordType !== CoordinateMode.absolute) size = LEdgePoint.decodeCoords(size, sp, ep);\r\n\r\n        let ret: any = ((\"w\" in size || \"h\" in size) ? new GraphSize() : new GraphPoint()); // GObject<Partial<GraphSize>>;\r\n        switch (edgePointCoordMode) {\r\n            default: return Log.exDevv(\"translatePosCoords() invalid coordinate mode\", {mode:edgePointCoordMode});\r\n            // case CoordinateMode.absolute: return size;\r\n            case CoordinateMode.relativePercent:\r\n                // let s = this.getBasicSize(c);\r\n                // MATH:\r\n                // size.x = sp.x*x% + ep.x*(1-x%)\r\n                // size.x = sp.x*x% + ep.x - ep.x*x%\r\n                // size.x - ep.x= (sp.x - ep.x)*x%\r\n                // (size.x - ep.x) / (sp.x - ep.x) = x% // actually i inverted <sp, ep> in first equation, so reverse them in result too.\r\n\r\n                if (sp.x === ep.x) ret.x = 0.5; // because otherwise it is infinity. so i force him to return in line.\r\n                else if (size.x !== undefined) ret.x = (size.x - sp.x) / (ep.x - sp.x);\r\n                if (sp.y === ep.y) ret.y = 0.5;\r\n                else if (size.y !== undefined) ret.y = (size.y - sp.y) / (ep.y - sp.y);\r\n                break;\r\n            case CoordinateMode.relativeOffset:\r\n            case CoordinateMode.relativeOffsetStart:\r\n            case CoordinateMode.relativeOffsetEnd:\r\n                let useStart: boolean;\r\n                let useEnd: boolean;\r\n                switch (edgePointCoordMode) {\r\n                    default:\r\n                    case CoordinateMode.relativeOffset: useStart = true; useEnd = true; break;\r\n                    case CoordinateMode.relativeOffsetStart: useStart = true; useEnd = false; break;\r\n                    case CoordinateMode.relativeOffsetEnd: useStart = false; useEnd = true; break;\r\n                }\r\n                if (size.x) ret.x = [useStart ? size.x - sp.x : -1, useEnd ? size.x - ep.x : -1];\r\n                if (size.y) ret.y = [useStart ? size.y - sp.y : -1, useEnd ? size.y - ep.y : -1];\r\n                /*\r\n                if (size.x) ret.x = [sp.x - size.x, ep.x - size.x];\r\n                if (size.y) ret.y = [sp.y - size.y, ep.y - size.y];*/\r\n                break;\r\n        }\r\n        if (size.x === undefined) delete ret.x;\r\n        if (size.y === undefined) delete ret.y;\r\n        if ((size as any).w === undefined) delete ret.w; else ret.w = (size as any).w;\r\n        if ((size as any).h === undefined) delete ret.h; else ret.h = (size as any).h;\r\n        // console.log(\"encode coorde\", {size, sp, ep, ret});\r\n        ret.currentCoordType = edgePointCoordMode;\r\n        return ret;\r\n    }\r\n    public encodePosCoords(c: Context, size0: Partial<EPSize>, view: LViewElement, sp0?: GraphPoint, ep0?: GraphPoint, mode?: CoordinateMode): Partial<EPSize> {\r\n        if (!view) view = this.get_view(c);\r\n        let size: Partial<EPSize> = size0 as any;\r\n        let edgePointCoordMode = mode || (view.__raw || view).edgePointCoordMode;\r\n        let le: LVoidEdge = c&&c.proxyObject.father;\r\n        let sp: GraphPoint = sp0 || le.startPoint;\r\n        let ep: GraphPoint = ep0 || le.endPoint;\r\n        return LEdgePoint.encodeCoords(size, edgePointCoordMode, sp, ep);\r\n    }\r\n\r\n    /* 13/10/2023 Giordano comment (defined in LPointerTargetable\r\n    public get_delete(context: Context): () => void {\r\n        // careful: pointedBy might be broken due to comment x984 (search it)\r\n        return super.get_delete(context);\r\n    }\r\n    */\r\n}\r\nRuntimeAccessibleClass.set_extend(DVoidVertex, DEdgePoint);\r\nRuntimeAccessibleClass.set_extend(LVoidVertex, LEdgePoint);\r\n\r\n@RuntimeAccessible('DVertex')\r\nexport class DVertex extends DGraphElement { // DVoidVertex\r\n    // static _super = DVoidVertex;\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // static singleton: LVertex;\r\n    // static logic: typeof LVertex;\r\n    // static structure: typeof DVertex;\r\n\r\n    // inherit redefine\r\n    id!: Pointer<DVertex, 1, 1, LVertex>;\r\n    graph!: Pointer<DGraph, 1, 1, LGraph>;\r\n    model!: Pointer<DModelElement, 0, 1, LModelElement>;\r\n    isSelected!: Dictionary<DocString<Pointer<DUser>>, boolean>;\r\n    // containedIn!: Pointer<DGraphElement, 0, 1, LGraphElement>;\r\n    subElements!: Pointer<DGraphElement, 0, 'N', LGraphElement>;\r\n    zoom!: GraphPoint;\r\n    x!: number;\r\n    y!: number;\r\n    w!: number;\r\n    h!: number;\r\n    isResized!: boolean;\r\n    // size!: GraphSize; // virtual, gets extracted from this. x and y are stored directly here as it extends GraphSize\r\n    // personal attributes\r\n    __isDVertex!: true;\r\n\r\n    public static new(htmlindex: number, model: DGraphElement[\"model\"], parentNodeID: DGraphElement[\"father\"],\r\n                      graphID: DGraphElement[\"graph\"], nodeID?: DGraphElement[\"id\"], size?: GraphSize): DVertex {\r\n        return new Constructors(new DVertex('dwc'), parentNodeID, true, undefined, nodeID)\r\n            .DPointerTargetable()\r\n            .DGraphElement(model, graphID, htmlindex)\r\n            .DVoidVertex(size || defaultVertexSize).DVertex().end();\r\n    }\r\n}\r\n\r\n@RuntimeAccessible('LVertex')\r\nexport class LVertex<Context extends LogicContext<any> = any, D = DVertex> extends LVoidVertex {\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // static singleton: LVertex;\r\n    // static logic: typeof LVertex;\r\n    // static structure: typeof DVertex;\r\n\r\n    // inherit redefine\r\n    __raw!: DVertex;\r\n    id!: Pointer<DVertex, 1, 1, LVertex>;\r\n    graph!: LGraph;\r\n    model?: LModelElement;\r\n    // isSelected: Dictionary<DocString<Pointer<DUser>>, boolean> = {};\r\n    isSelected(forUser?: Pointer<DUser>): boolean { return this.wrongAccessMessage(\"node.isSelected()\"); }\r\n    // containedIn?: LGraphElement;\r\n    subElements!: LGraphElement[];\r\n    zoom!: GraphPoint;\r\n    x!: number;\r\n    y!: number;\r\n    w!: number;\r\n    h!: number;\r\n    size!: GraphSize; // virtual, gets extracted from this. x and y are stored directly here as it extends GraphSize\r\n    isResized!: boolean;\r\n    // personal attributes\r\n    __isLVertex!: true;\r\n}\r\n\r\nRuntimeAccessibleClass.set_extend(DGraphElement, DVertex);\r\nRuntimeAccessibleClass.set_extend(LGraphElement, LVertex);\r\n\r\n@Leaf\r\n@RuntimeAccessible('DGraphVertex')\r\nexport class DGraphVertex extends DGraphElement { // MixOnlyFuncs(DGraph, DVertex)\r\n    // static _super1 = DGraph;\r\n    // static _super2 = DVertex;\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // static singleton: LGraphVertex;\r\n    // static logic: typeof LGraphVertex;\r\n    // static structure: typeof DGraphVertex;\r\n\r\n    // inherit redefine\r\n    id!: Pointer<DGraphVertex, 1, 1>;\r\n    graph!: Pointer<DGraph, 1, 1, LGraph>;\r\n    model!: Pointer<DModelElement, 1, 1, LModelElement>;\r\n    isSelected!: Dictionary<DocString<Pointer<DUser>>, boolean>;\r\n    // containedIn!: Pointer<DGraphElement, 0, 1, LGraphElement>;\r\n    subElements!: Pointer<DGraphElement, 0, 'N', LGraphElement>;\r\n    // from graph\r\n    zoom!: GraphPoint;\r\n    offset!: GraphPoint; // in-graph scrolling position\r\n\r\n    // from VoidVertex\r\n    x!: number;\r\n    y!: number;\r\n    w!: number;\r\n    h!: number;\r\n    isResized!: boolean;\r\n    // size!: GraphSize; // virtual\r\n    // from graph\r\n\r\n    // personal attributes\r\n    __isDVertex!: true;\r\n    __isDGraph!: true;\r\n    __isDGraphVertex!: true;\r\n\r\n    public static new(htmlindex: number, model: DGraph[\"model\"], parentNodeID: DGraphElement[\"father\"],\r\n                      graphID: DGraphElement[\"graph\"], nodeID?: DGraphElement[\"id\"], size?: GraphSize): DGraphVertex {\r\n        return new Constructors(new DGraphVertex('dwc'), parentNodeID, true, undefined, nodeID)\r\n            .DPointerTargetable().DGraphElement(model, graphID, htmlindex)\r\n            .DVoidVertex(size || defaultVertexSize).DVertex().DGraph().end();\r\n    }\r\n\r\n\r\n    /*\r\n        static init_constructor(thiss: DGraphVertex, isUser: boolean = false, nodeID: string | undefined, graphID: string | undefined, model: Pointer<DModel>): void {\r\n            DGraph.init_constructor(thiss, isUser, nodeID, graphID, model);\r\n    //isUser: boolean = false, nodeID: string | undefined, graphID: string, model?: Pointer<DModel>\r\n            DVertex.init_constructor(thiss, isUser, nodeID, graphID as string, model);\r\n            thiss.className = this.name;\r\n        }*/\r\n}\r\nclass LG extends LGraph{}\r\nclass LV extends LVertex{}\r\n\r\nconst Mixed = MixOnlyFuncs(LG, LV) as (typeof LG & typeof LV & typeof RuntimeAccessibleClass);\r\n@RuntimeAccessible('LGraphVertex')\r\n//@ts-ignore TS2510\r\nexport class LGraphVertex<Context extends LogicContext<any> = any, D extends DGraphVertex = any> extends Mixed { // MixOnlyFuncs(LGraph, LVertex)\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // static singleton: LGraphVertex;\r\n    // static logic: typeof LGraphVertex;\r\n    // static structure: typeof DGraphVertex;\r\n\r\n    // inherit redefine\r\n    __raw!: DGraphVertex;\r\n    id!: Pointer<DGraphVertex, 1, 1>;\r\n    graph!: LGraph;\r\n    model?: LModelElement;\r\n    // isSelected: Dictionary<DocString<Pointer<DUser>>, boolean> = {};\r\n    isSelected(forUser?: Pointer<DUser>): boolean { return this.wrongAccessMessage(\"node.isSelected()\"); }\r\n    // containedIn?: LGraphElement;\r\n    ///////////////////////////////////////// subElements!: LGraphElement[];\r\n    // from graph\r\n    zoom!: GraphPoint;\r\n    offset!: GraphPoint; // in-graph scrolling position\r\n    graphSize!: GraphSize; // internal size of the graph. can be huge even if the sub-graph is in a small window (scroll)\r\n\r\n    // from VoidVertex\r\n    x!: number;\r\n    y!: number;\r\n    w!: number;\r\n    h!: number;\r\n    isResized!: boolean;\r\n    size!: GraphSize; // virtual\r\n\r\n\r\n    // personal attributes\r\n    __isLVertex!: true;\r\n    __isLGraph!: true;\r\n    __isLGraphVertex!: true;\r\n}\r\n\r\nRuntimeAccessibleClass.set_extend(DGraph, DGraphVertex);\r\nRuntimeAccessibleClass.set_extend(DVertex, DGraphVertex);\r\nRuntimeAccessibleClass.set_extend(LGraph, LGraphVertex);\r\nRuntimeAccessibleClass.set_extend(LVertex, LGraphVertex);\r\n\r\n\r\n@RuntimeAccessible('DVoidEdge')\r\nexport class DVoidEdge extends DGraphElement {\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // static singleton: LVoidEdge;\r\n    // static logic: typeof LVoidEdge;\r\n    // static structure: typeof DVoidEdge;\r\n    id!: Pointer<DVoidEdge, 1, 1, LVoidEdge>;\r\n    graph!: Pointer<DGraph, 1, 1, LGraph>;\r\n    model!: Pointer<DModelElement, 0, 1, LModelElement>;\r\n    // isSelected: Dictionary<DocString<Pointer<DUser>>, boolean> = {};\r\n    isSelected!: Dictionary<DocString<Pointer<DUser>>, boolean>;\r\n    // containedIn!: Pointer<DGraphElement, 0, 1, LGraphElement>;\r\n    subElements!: Pointer<DGraphElement, 0, 'N', LGraphElement>;\r\n\r\n    // personal attributes\r\n    start!: Pointer<DGraphElement, 1, 1, LGraphElement>;\r\n    end!: Pointer<DGraphElement, 1, 1, LGraphElement>;\r\n    __isDVoidEdge!: true;\r\n\r\n    midPoints!: InitialVertexSize[]; // the logic part which instructs to generate the midnodes\r\n    midnodes!: Pointer<DEdgePoint, 1, 1, LEdgePoint>[]; // using subelements instead most of times\r\n\r\n    longestLabel?: DocString<\"function\">;\r\n    labels?: DocString<\"function\">;\r\n    anchorStart?: string;\r\n    anchorEnd?: string;\r\n\r\n    isExtend!: boolean;\r\n    isReference!: boolean;\r\n    isValue!: boolean;\r\n    isDependency!: boolean;\r\n    // endFollow!: boolean; they became derived attributes from static properties\r\n    // startFollow!: boolean;\r\n\r\n    static isFollowingCoords: GraphPoint;\r\n\r\n    public static new(htmlindex: number, model: DGraph[\"model\"]|null|undefined, parentNodeID: DGraphElement[\"father\"], graphID: DGraphElement[\"graph\"],\r\n                      nodeID: DGraphElement[\"id\"]|undefined, start: DGraphElement[\"id\"], end: DGraphElement[\"id\"],\r\n                      longestLabel?: DEdge[\"longestLabel\"], labels?: DEdge[\"labels\"]): DEdge {\r\n        return new Constructors(new DEdge('dwc'), parentNodeID, true, undefined, nodeID)\r\n            .DPointerTargetable()\r\n            .DGraphElement(model, graphID, htmlindex)\r\n            .DVoidEdge(start, end, longestLabel, labels).end();\r\n    }\r\n    public static new2(model: DGraph[\"model\"]|null|undefined, parentNodeID: DGraphElement[\"father\"], graphID: DGraphElement[\"graph\"],\r\n                       nodeID: DGraphElement[\"id\"]|undefined, start: DGraphElement[\"id\"], end: DGraphElement[\"id\"], setter:((d: DEdge) => any)): DEdge {\r\n        return new Constructors(new DEdge('dwc'), parentNodeID, true, undefined, nodeID)\r\n            .DPointerTargetable()\r\n            .DGraphElement(model, graphID)\r\n            .DVoidEdge(start, end).end(setter);\r\n    }\r\n}\r\n/*\r\n@RuntimeAccessible\r\nexport class MidPoint{\r\n    readonly id: string; // not really a pointer, it's not on store.\r\n    x?: number; y?: number;\r\n    readonly w?: number; // if it's modified it's not ever here (initial size) but on DEdgePoint that is a Node.\r\n    readonly h?: number;/*\r\n    constructor2(x: number=5, y: number=5, w: number=5, h: number=5) {\r\n        this.x = x;\r\n        this.y = y;\r\n        this.w = w;\r\n        this.h = h;\r\n    }* /\r\nconstructor(id: string, w: number=5, h: number=5) {\r\n    this.id = id;\r\n    this.w = w;\r\n    this.h = h;\r\n}\r\n}*/\r\n@RuntimeAccessible('EdgeSegment')\r\nexport class EdgeSegment{\r\n    index: number;\r\n    prev: EdgeSegment | undefined;\r\n    start: segmentmaker;\r\n    bezier: segmentmaker[];\r\n    end: segmentmaker;\r\n    length!: number;\r\n    // if EdgeSegment is changed, shouldcomponentupdate needs update too: search in IDE for \"5khi2\"\r\n    d!: string;\r\n    dpart!: string; //  a segment of the whole path\r\n    m!: number; // m coefficient of the line between start and end.\r\n    rad!: number; // for head and tails: radian angle of the segment.\r\n    radLabels!: number; // for labels: it flips the angle when it's < PI/2 so the text is never upside down\r\n\r\n    isLongest!: boolean;\r\n    label!: PrimitiveType | JSX.Element | undefined;\r\n    svgLetter: EdgeBendingMode;\r\n    /*constructor(label: PrimitiveType|undefined, length: number, startp: GraphPoint, endp: GraphPoint, start: LGraphElement, end: LGraphElement,\r\n                bezierpts: GraphPoint[], mid: LGraphElement[],\r\n                svgLetter: EdgeBendingMode, index: number, fillMode: MidNodeHandling) {\r\n        this.label = label;\r\n        this.length = length;\r\n        this.length = length;\r\n        this.startp = startp;\r\n        this.bezierp = bezierpts;\r\n        this.endp = endp;\r\n        this.start = start;\r\n        this.end = end;\r\n        this.mid = mid;\r\n    }*/\r\n    constructor(start: segmentmaker, mid: segmentmaker[], end: segmentmaker,\r\n                svgLetter: EdgeBendingMode, gapMode: EdgeGapMode,\r\n                index: number, prevSegment: EdgeSegment | undefined){\r\n        // console.log(\"segmentmaker:\", arguments, ((start.ge?.model as any)?.name)+\" ---> \" + ((end.ge?.model as any)?.name));\r\n        this.start = start;\r\n        this.bezier = mid;\r\n        this.end = end;\r\n        this.index = index;\r\n        this.prev = prevSegment;\r\n        //this.segments = segments;\r\n        // the idea: forbid all T and S or transform them in C, Q by calculating and manually adding their mirrored bezier pts\r\n        // if (svgLetter[1]) svgLetter = (svgLetter[0]) as any;\r\n        if (svgLetter === EdgeBendingMode.Bezier_QT) {\r\n            this.svgLetter = EdgeBendingMode.Bezier_QT[0] as any as EdgeBendingMode;\r\n            // this.svgLetter = (index === 0 ? EdgeBendingMode.Bezier_QT[0] : EdgeBendingMode.Bezier_QT[1]) as any as EdgeBendingMode;\r\n            this.addBezierPoint();\r\n        } else\r\n        if (svgLetter === EdgeBendingMode.Bezier_CS) {\r\n            this.svgLetter = EdgeBendingMode.Bezier_CS[0] as any as EdgeBendingMode;\r\n            // this.svgLetter = (index === 0 ? EdgeBendingMode.Bezier_CS[0] : EdgeBendingMode.Bezier_CS[1]) as any as EdgeBendingMode;\r\n            this.addBezierPoint();\r\n        }\r\n        else this.svgLetter = svgLetter;\r\n\r\n        // fix if amount of bezier pts is invalid for current letter\r\n        switch (this.svgLetter) {\r\n            case EdgeBendingMode.Line:\r\n            case EdgeBendingMode.Bezier_quadratic:\r\n                if (this.bezier.length >= 1) break;\r\n                else this.svgLetter = EdgeBendingMode.Line;\r\n                break;\r\n            case EdgeBendingMode.Bezier_cubic:\r\n                if (this.bezier.length >= 2) break;\r\n                else if (this.bezier.length >= 1) this.svgLetter = EdgeBendingMode.Bezier_quadratic;\r\n                else this.svgLetter = EdgeBendingMode.Line;\r\n                break;\r\n            case EdgeBendingMode.Elliptical_arc:\r\n                if (this.bezier.length >= 3) break;\r\n                else this.svgLetter = EdgeBendingMode.Line; // straight to end ignoring midpoints that are NOT coordinates when using elliptical arc.\r\n                break;\r\n            default:\r\n            //case EdgeBendingMode.Bezier_quadratic_mirrored as string:\r\n            //case EdgeBendingMode.Bezier_cubic_mirrored as string: // translated to Q or C by adding mirrored bezier points explicitly\r\n            case EdgeBendingMode.Bezier_QT:\r\n            case EdgeBendingMode.Bezier_CS: // translated to Q or C by sending the right letter to each segment\r\n                Log.exDevv(\"this svg letter should not appear here\", this.svgLetter);\r\n                break;\r\n        }\r\n    }\r\n    addBezierPoint(): void {\r\n        let prev: EdgeSegment | undefined = this.prev;\r\n        if (!prev) return;\r\n        let prevedgemakerbezier: segmentmaker = (prev.bezier[prev.bezier.length-1] || prev.start);\r\n        let mirroredBezier: segmentmaker = {...prevedgemakerbezier,\r\n            pt: EdgeSegment.invertLastBezierPt(prevedgemakerbezier.pt, prev.end.pt),\r\n            uncutPt: EdgeSegment.invertLastBezierPt(prevedgemakerbezier.uncutPt, prev.end.uncutPt),\r\n        };\r\n        this.bezier = [mirroredBezier, ...this.bezier];\r\n        // always only 1 assumed pt both in cubic and quadratic.\r\n        // let next: this | undefined = this.segments[this.index+1];\r\n        // EdgeSegment.invertLastBezierPt((next.mid[1] || next.end).pt, next.start.pt);\r\n    }\r\n\r\n    makeD(index: number, gapMode: EdgeGapMode): string {\r\n        this.m = GraphPoint.getM(this.start.pt, this.end.pt);\r\n        this.rad = Geom.mToRad(this.m, this.start.pt, this.end.pt);\r\n        this.radLabels = Math.atan(this.m);\r\n\r\n        let svgLetter = this.svgLetter; // caller makes sure to pass right letter and resolve \"CS\" mixed letters. // this.bendingModeToLetter(bendingMode, index);\r\n        // caller sends inverted pts as normal coords\r\n        // let invertedBezPt = lastSegment && EdgeSegment.invertLastBezierPt(lastSegment.midp[lastSegment.mid.length-1] || lastSegment.startp, lastSegment.endp);\r\n        switch (this.svgLetter.length) {\r\n            case 2:\r\n                return Log.exDevv(\"mixed letters are not allowed and should have been resolved to single svg letters before here, found:\" + svgLetter);\r\n            /*return Log.exDevv(\"dev problem to fix:\\n\" +\r\n            \"the mirrored mode requires the first one to have explicit non-mirrored mode?? like M, C a1 a2 a3, S a1, S a1, S a1\\n\" +\r\n            \"So all segments with mixed modes needs to extract the last bezier point (penultimate coordinate) from previous segments, mirror it and insert in midp[0]\");*/\r\n            case 1:\r\n                let bezierpts = [...this.bezier.map( b => b.pt), this.end.pt];\r\n                let finalpart = svgLetter + \" \" + bezierpts.map((p)=> p.x + \" \" + p.y).join(\", \");\r\n                this.dpart = \"M \" + this.start.pt.x + \" \" + this.start.pt.y + \", \" + finalpart;\r\n                let bezierptsUncut = [...this.bezier.map( b => b.uncutPt), this.end.pt]; // uncutPt exist for start and end too, but i want to use the cut one for those. or edgehead is off\r\n                let finalpartUncut = svgLetter + \" \" + bezierptsUncut.map((p)=> p.x + \" \" + p.y).join(\", \");\r\n                this.d = (index === 0 ? \"M\" + this.start.pt.x + \" \" + this.start.pt.y + \", \" : \"\") + finalpartUncut;\r\n\r\n                //midp = [this.startp, ...this.midp];\r\n                // d = M sp X mp2 ep // X = custom letter\r\n                // dpart = T sp X mp2 ep // S = S if X = C,\r\n                // sp is the startingpoint from the prev node, which might be != from endpoint of last node if last node have w>0 && h>0\r\n                // so i'm \"filling\" the gap with a T, or L arc wich can use only 1 parameter (they are the only 1-parameter arcs)\r\n                // if (this.prev && this.prev.end.pt.equals(this.start.pt)) gapMode = EdgeGapMode.average; // if the 2 points coincide, i use any 1 of the gapmodes that are continuous\r\n                /*switch (gapMode){\r\n                    case EdgeGapMode.center:\r\n                    case EdgeGapMode.average:\r\n                        // continuous gap modes. they only differ in how the \"joining\" point is found, but not in how they behave after that.\r\n                        /*\r\n                        if (index === 0) {\r\n                             startletter = \"M \";\r\n                         }\r\n                         else {\r\n                             switch (svgLetter) {\r\n                                 case SvgLetter.A: case SvgLetter.C: case SvgLetter.S: case SvgLetter.Q: case SvgLetter.T: default:\r\n                                     startletter = SvgLetter.T + \" \"; break;\r\n                                 case SvgLetter.L: case SvgLetter.M:\r\n                                     startletter = SvgLetter.L + \" \"; break;\r\n                             }\r\n                         }* /\r\n                        if (index) {\r\n                            this.d = finalpart;\r\n                        }\r\n                        else { this.d = this.dpart; }\r\n                        break;\r\n                    case EdgeGapMode.gap:\r\n                    case EdgeGapMode.autoFill:\r\n                    case EdgeGapMode.lineFill:\r\n                    case EdgeGapMode.arcFill:\r\n                        // the filling itself is done by another segment (solving svg letter and simulating i=0), so i treat it as a gap.\r\n                        this.d = this.dpart;\r\n                        break;\r\n                    default:\r\n                        Log.exDevv(\"unexpected EdgeGapMode:\" + gapMode, {gapMode});\r\n                }*/\r\n                break;\r\n            default: return Log.exDevv(\"unexpected bending mode length:\" + this.svgLetter + \" or fillMode: \" + gapMode, {bendingMode: this.svgLetter, index, gapMode});\r\n        }\r\n\r\n        //using\r\n        /*\r\n        88\r\n\r\n        // d should not have M set (except for segments[0]\r\n        // dpart have M abd beed to add explicit points for \"mirroring\" and transforming bezier quadratic mirrored in bezier quadratic normal etc.\r\n        //88 problem: the mirrored mode requires the first one to have explicit nonmirrored mode?? like M, C a1 a2 a3, S a1, S a1, S a1 .... ?\r\n        in any case the % letter part is wrong because it needs to subtract first element used for M*/\r\n        return this.d;\r\n    }\r\n\r\n    static invertLastBezierPt(bezier: GraphPoint, end: GraphPoint): GraphPoint{\r\n        // vector = bezier - end\r\n        // end + vector = bezier\r\n        // end - vector = inverted bezier? = 2*end-bezier\r\n        let vector = bezier.subtract(end, true);\r\n        return end.subtract(vector, true);\r\n    }\r\n\r\n    calcLength(): void {\r\n        this.length = this.start.pt.distanceFromPoint(this.end.pt);\r\n    }\r\n}\r\n\r\nexport class EdgeFillSegment extends EdgeSegment{\r\n    public static cname: string = \"EdgeFillSegment\";\r\n    makeD(index: number, gapMode: EdgeGapMode): string {\r\n        // if (gapMode === EdgeGapMode.autoFill) { gapMode = this.svgLetter === EdgeBendingMode.Line ? EdgeGapMode.lineFill : EdgeGapMode.arcFill; }\r\n        switch (gapMode) {\r\n            case \"closest\" as any:// EdgeGapMode.closest:\r\n            case EdgeGapMode.center:\r\n            case EdgeGapMode.average:\r\n            case EdgeGapMode.gap:\r\n                return \"\"; // should not have filler arcs\r\n            default:\r\n                /*\r\n            case EdgeGapMode.autoFill as any:\r\n            case EdgeGapMode.lineFill:\r\n                this.bezier = [];\r\n                this.svgLetter = EdgeBendingMode.Line;\r\n                return super.makeD(index, gapMode);\r\n            case EdgeGapMode.arcFill:*/\r\n                this.svgLetter = this.svgLetter[0] as EdgeBendingMode;\r\n                if (this.svgLetter === \"Q\") this.bezier = this.bezier.length ? [this.bezier[0]] : [];\r\n                return super.makeD(index, gapMode);\r\n        }\r\n    }\r\n}\r\nexport type labelfunc = (e:LVoidEdge, segment: EdgeSegment, allNodes: LEdge[\"allNodes\"], allSegments: EdgeSegment[]) => PrimitiveType;\r\nexport type labeltype = orArr<labelfunc | PrimitiveType>;\r\n\r\ntype segmentmaker = {size: GraphSize, view: LViewElement, ge: LGraphElement, pt: GraphPoint, uncutPt: GraphPoint};\r\n@RuntimeAccessible('LVoidEdge')\r\nexport class LVoidEdge<Context extends LogicContext<DVoidEdge> = any, D extends DEdge = DEdge> extends LGraphElement {\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // static singleton: LVoidEdge;\r\n    // static logic: typeof LVoidEdge;\r\n    // static structure: typeof DVoidEdge;\r\n    __raw!: DVoidEdge;\r\n    id!: Pointer<DVoidEdge, 1, 1, LVoidEdge>;\r\n    graph!: LGraph;\r\n    model?: LModelElement;\r\n    // isSelected: Dictionary<DocString<Pointer<DUser>>, boolean> = {};\r\n    isSelected(forUser?: Pointer<DUser>): boolean { return this.wrongAccessMessage(\"node.isSelected()\"); }\r\n    // containedIn?: LGraphElemnt;\r\n    subElements!: LGraphElement[];\r\n    __isLVoidEdge!: true;\r\n    midPoints!: InitialVertexSize[]; // the logic part which instructs to generate the midnodes\r\n    midnodes!: LEdgePoint[];\r\n    edge!: LVoidEdge; // returns self. useful to get edge from edgePoints without triggering error if you are already on edge.\r\n    __info_of__edge: Info = {type:\"?LEdge\", txt:\"returns this if called on an edge, the containing edge if called on an EdgePoint, undefined otherwise.\"}\r\n\r\n    isExtend!: boolean;\r\n    isReference!: boolean;\r\n    isValue!: boolean;\r\n    isDependency!: boolean;\r\n\r\n/*\r\nreplaced by startPoint\r\n    edgeStart!: GraphPoint;\r\n    edgeStart_inner!: GraphPoint;\r\n    edgeStart_outer!: GraphPoint;\r\n    __info_of__edgeStart: Info = {type: \"GraphPoint\", txt: \"Same as edgeStart_outer.\"}\r\n    __info_of__edgeStart_outer: Info = {type: \"GraphPoint\",\r\n     txt: \"Where the edge should start his path, in coordinates relative at the root Graph.\r\n     <br>Computed by combining the anchor offset option in View and the size of the starting node.\"}\r\n    __info_of__edgeStart_inner: Info = {type: \"GraphPoint\",\r\n     txt: \"Where the edge should start his path, in coordinates relative at the most nested Graph.\r\n     <br>Computed by combining the anchor offset option in View and the size of the starting node.\"}\r\n    edgeEnd!: GraphPoint;\r\n    edgeEnd_inner!: GraphPoint;\r\n    edgeEnd_outer!: GraphPoint;\r\n    __info_of__edgeEnd: Info = {type: \"GraphPoint\", txt: \"Same as edgeEnd_outer.\"}\r\n    __info_of__edgeEnd_outer: Info = {type: \"GraphPoint\",\r\n     txt: \"Where the edge should end his path, in coordinates relative at the root Graph.\r\n     <br>Computed by combining the anchor offset option in View and the size of the starting node.\"}\r\n    __info_of__edgeEnd_inner: Info = {type: \"GraphPoint\",\r\n     txt: \"Where the edge should end his path, in coordinates relative at the most nested Graph.\r\n     <br>Computed by combining the anchor offset option in View and the size of the starting node.\"}\r\n*/\r\n\r\n    allNodes!: [LGraphElement, ...Array<LEdgePoint>, LGraphElement];\r\n    __info_of__allNodes: Info = {type: \"[LGraphElement, ...Array<LEdgePoint>, LGraphElement]\", txt: <span>first element is this.start. then all this.midnodes. this.end as last element</span>};\r\n\r\n\r\n    label!: this[\"longestLabel\"];  // should never be read change their documentation in write only. their values is \"read\" in this.segments\r\n    longestLabel!: labeltype;\r\n    labels!: labeltype;\r\n    __info_of__longestLabel: Info = {label:\"Longest label\", type:\"function(edge)=>string\",\r\n        readType: \"(edge:LEdge, segment: EdgeSegment, allNodes: DGraphElement[], allSegments: EdgeSegment[]) => PrimitiveType\",\r\n        writeType:\"string\",\r\n        txt: <span>Label assigned to the longest path segment.</span>}\r\n    __info_of__label: Info = {type: \"\", txt: <span>Alias for longestLabel</span>};\r\n    __info_of__labels: Info = {label:\"Multiple labels\", type: \"same type as longestLabel | longestLabel[]\",\r\n        writeType: \"string\",\r\n        txt: <span>Instructions to label to multiple or all path segments in an edge</span>\r\n    };\r\n\r\n\r\n    start!: LGraphElement;\r\n    __info_of__start: Info = {type: \"LVertex\", txt:\"the source point of the edge.\"}\r\n    get_start(c: Context): this['start'] { return LPointerTargetable.fromPointer(c.data.start); }\r\n    set_start(val: Pack1<LGraphElement>, c: Context): boolean {\r\n        let ptr = Pointers.from(val);\r\n        if (!ptr) { Log.exx(\"attempting to set an invalid LEdge.start: \" + ptr, {ptr, data: c.data}); return true; }\r\n        if (ptr === c.data.start) return true;\r\n        let name = this.get_name(c)||'';\r\n        TRANSACTION((name.toLowerCase().indexOf('edge')>=0 ? name : 'Edge: '+name)+'.start', ()=>{\r\n            SetFieldAction.new(c.data.id, 'start', ptr, '', true);\r\n        }, LPointerTargetable.from(c.data.start).name, LPointerTargetable.from(ptr).name)\r\n        return true;\r\n    }\r\n    end!: LGraphElement;\r\n    __info_of__end: Info = {type: \"LVertex\", txt:\"the terminal point of the edge.\"}\r\n    get_end(c: Context): this['end'] { return LPointerTargetable.fromPointer(c.data.end); }\r\n    set_end(val: Pack1<LGraphElement>, c: Context): boolean {\r\n        let ptr = Pointers.from(val);\r\n        if (!ptr) { Log.exx(\"attempting to set an invalid LEdge.end: \" + ptr, {ptr, data: c.data}); return true; }\r\n        if (ptr === c.data.end) return true;\r\n        let name = this.get_name(c)||'';\r\n        TRANSACTION((name.toLowerCase().indexOf('edge')>=0 ? name : 'Edge: '+name)+'.end', ()=>{\r\n            SetFieldAction.new(c.data.id, 'end', ptr, '', true);\r\n        }, LPointerTargetable.from(c.data.end).name, LPointerTargetable.from(ptr).name)\r\n        return true;\r\n    }\r\n\r\n\r\n    get_label(c: Context): this[\"longestLabel\"] { return this.get_longestLabel(c); }\r\n    set_label(val: DVoidEdge[\"longestLabel\"], c: Context): boolean { return this.set_longestLabel(val, c); }\r\n    get_longestLabel(c: Context): this[\"longestLabel\"] {\r\n        return transientProperties.node[c.data.id].longestLabel;\r\n        /*if (transientProperties.node[c.data.id].longestLabel !== undefined) return transientProperties.node[c.data.id].longestLabel;\r\n        else return transientProperties.view[c.data.view].longestLabel;*/\r\n    }\r\n    get_labels(c: Context): this[\"labels\"] {\r\n        return transientProperties.node[c.data.id].labels;\r\n        /*if (transientProperties.node[c.data.id].labels !== undefined) return transientProperties.node[c.data.id].labels;\r\n        else return transientProperties.view[c.data.view].labels;*/\r\n    }\r\n    set_longestLabel(val: DVoidEdge[\"longestLabel\"], c: Context): boolean {\r\n        Log.exDevv('Edge.labels are disabled, pass it through props instead');\r\n        if (val === c.data.longestLabel) return true;\r\n        let name = this.get_name(c)||'';\r\n        TRANSACTION((name.toLowerCase().indexOf('edge')>=0 ? name : 'Edge: '+name)+'.label', ()=>{\r\n            SetFieldAction.new(c.data, \"longestLabel\", val);\r\n            SetRootFieldAction.new(\"NODES_RECOMPILE_longestLabel+=\", c.data.id);\r\n        }, c.data.longestLabel, val);\r\n        return true;\r\n    }\r\n    set_labels(val: DVoidEdge[\"labels\"], c: Context): boolean {\r\n        Log.exDevv('Edge.labels are disabled, pass it through props instead');\r\n        if (val === c.data.labels) return true;\r\n        let name = this.get_name(c)||'';\r\n        TRANSACTION((name.toLowerCase().indexOf('edge')>=0 ? name : 'Edge: '+name)+'.labels', ()=>{\r\n            SetFieldAction.new(c.data, \"labels\", val);\r\n            SetRootFieldAction.new(\"NODES_RECOMPILE_labels+=\", c.data.id);\r\n        }, c.data.labels, val);\r\n        return true; }\r\n\r\n    public headPos_impl(c: Context, isHead: boolean, headSize0?: GraphPoint, segment0?: EdgeSegment, zoom0?: GraphPoint): GraphSize & {rad: number} {\r\n        let segment: EdgeSegment = segment0 || this.get_segments(c).segments[0];\r\n        // let v: LViewElement = this.get_view(c);\r\n        let tmp: any = headSize0 || (isHead ? this.get_view(c).edgeHeadSize : this.get_view(c).edgeTailSize);\r\n        if (!tmp || tmp.x === 0 || tmp.y === 0) {\r\n            // head or tail missing\r\n            tmp = new GraphSize(0, 0, 0, 0);\r\n            tmp.rad = 0;\r\n            return tmp;\r\n        }\r\n        let zoom: GraphPoint = zoom0 || this.get_graph(c).zoom;// ownZoom or cumulativeZoom?\r\n        let headPos: GraphSize & {rad: number} = (new GraphSize(0, 0, tmp.x, tmp.y) as any); //.multiply({w:zoom.x, h:zoom.y});\r\n        let useBezierPoints = true;\r\n        let start: GraphPoint, end: GraphPoint;\r\n        let m: number;\r\n        if (useBezierPoints) {\r\n            if (isHead) {\r\n                start = segment.end.pt;\r\n                end = (segment.bezier[segment.bezier.length - 1] || segment.start).pt;\r\n            } else {\r\n                start = segment.start.pt;\r\n                end = (segment.bezier[0] || segment.end).pt;\r\n            }\r\n            m = GraphPoint.getM(start, end);\r\n        } else {\r\n            if (isHead) { start = segment.end.pt; end = segment.start.pt; }\r\n            else { start = segment.start.pt; end = segment.end.pt; }\r\n            m = segment.m;\r\n        }\r\n        // first find the center of where it should be positioned\r\n        // let center: GraphPoint;\r\n        // let distance: number = Math.sqrt(headPos.w*headPos.w + headPos.h*headPos.h);\r\n        // let isVertical = m >=1 ;\r\n        let x4headsize = new GraphSize(start.x - headPos.w, start.y - headPos.h, headPos.w*2, headPos.h*2);\r\n        // first intersection is segment origin. second is found with the box containing all possible edgeHead positions that touch the startPoint\r\n        // (doing x4 his shape and placing 4 \"rectangles\" all around startPoint) to cover all possible segment directions.\r\n        // or finding first direction (vertical if m >1, horizontal if m<0) and vector direction and intersecting with only the \"correct\" placed edgeHead rectangle.\r\n        // then the intersection will likely not fall on the extreme angle of EdgeHead and i can re-center edgeHead\r\n        // so that first and second intersections are equal spaced with the center segment\r\n        let secondIntersection: GraphPoint | undefined;\r\n        let segmentDistance = start.distanceFromPoint(end);\r\n        if (segmentDistance <= Math.sqrt(headPos.w**2 + headPos.h**2)){\r\n            let safeDistance = Math.max(headPos.w, headPos.h)*5;\r\n            end = new GraphPoint( end.y + safeDistance, end.y + m * safeDistance); // move the point away so it doesn't intersect anymore. i just need direction\r\n            // too small to fit edgeHead, i simply put it centered on the whole segment\r\n            // secondIntersection = end;\r\n        }\r\n        secondIntersection = GraphSize.closestIntersection(x4headsize, start, end, undefined);\r\n        if (!secondIntersection) {\r\n           return Log.exDevv(\"failed to intersect edge head\", {x4headsize, segment, headPos, c, start, end, useBezierPoints});\r\n        }\r\n        tmp = secondIntersection.add(start, false).divide(2); // center of edgehead\r\n        headPos.x = tmp.x - headPos.w / 2; // tl corner\r\n        headPos.y = tmp.y - headPos.h / 2; // tl corner\r\n        headPos.rad = Geom.mToRad(m, start, end);\r\n        /*\r\n        devo trovare la distanza tra il centro dell'egeHead e il punto di inizio in termini assoluti, così tramite M trovo distanza in x e y. o trovarla in altro modo\r\n        if (segment.m === Number.POSITIVE_INFINITY || segment.m === Number.NEGATIVE_INFINITY) {\r\n            center = segment.start.pt.add({x:0, y: distance}, true); }\r\n        else { center = segment.start.pt.add({x:segment.m*headPos.w/2, y:segment.m*headPos.h/2\r\n         this is wrong, cannot be the same for x and y, i should invert the line equation for x?}, true); }\r\n        headPos.x = center.x - headPos.w / 2;\r\n        headPos.y = center.y - headPos.h / 2;*/\r\n        // console.log(\"head intersected\", {headPos, secondIntersection, x4headsize, segment, c, start, end, useBezierPoints});\r\n\r\n        return headPos;\r\n    }\r\n\r\n    public headPos(headSize0?: GraphPoint, segment0?: EdgeSegment, zoom0?: GraphPoint): GraphSize & {rad: number} {\r\n        return this.wrongAccessMessage(\"This is not headPos() implementation. it is just for typings. use the getter\"); }\r\n    public tailPos(headSize0?: GraphPoint, segment0?: EdgeSegment, zoom0?: GraphPoint): GraphSize & {rad: number} {\r\n        return this.wrongAccessMessage(\"This is not tailPos() implementation. it is just for typings. use the getter\"); }\r\n    protected get_headPos(c: Context): this[\"headPos\"] {\r\n        return (headSize?: GraphPoint, segment?: EdgeSegment, zoom?: GraphPoint) => this.headPos_impl(c, true, headSize, segment, zoom); }\r\n    protected get_tailPos(c: Context): this[\"tailPos\"] {\r\n        return (headSize?: GraphPoint, segment?: EdgeSegment, zoom?: GraphPoint) => this.headPos_impl(c, false, headSize, segment, zoom); }\r\n    protected get_allNodes(c: Context): this[\"allNodes\"] { return [this.get_start(c), ...this.get_midnodes(c), this.get_end(c)]; }\r\n\r\n    protected get_edge(c: Context): this{ return c.proxyObject as this; }\r\n    protected set_edge(v: any, c: Context): false { return this.cannotSet(\"edge field, on an edge element\"); }\r\n    protected get_midPoints(c: Context):this[\"midPoints\"] { return c.data.midPoints; }\r\n    public addMidPoint(v: this[\"midPoints\"][0]): boolean { return this.wrongAccessMessage(\"addMidPoint\"); }\r\n    protected get_addMidPoint(c: Context): (v: this[\"midPoints\"][0]) => boolean { return (v:this[\"midPoints\"][0]) => this.impl_addMidPoints(v, c); }\r\n    protected set_midPoints(val: this[\"midPoints\"], c: Context): boolean {\r\n        let name = this.get_name(c)||'';\r\n        TRANSACTION((name.toLowerCase().indexOf('edge')>=0 ? name : 'Edge: '+name)+'.midpoints', ()=>{\r\n            SetFieldAction.new(c.data.id, \"midPoints\", val, undefined, false);\r\n        });\r\n        return true;\r\n    }\r\n    protected impl_addMidPoints(val: this[\"midPoints\"][0], c: Context): boolean {\r\n        let name = this.get_name(c)||'';\r\n        TRANSACTION((name.toLowerCase().indexOf('edge')>=0 ? name : 'Edge: '+name)+' add midpoints', ()=>{\r\n           SetFieldAction.new(c.data.id, \"midPoints\", val, '+=', false);\r\n        });\r\n        return true;\r\n    }\r\n    protected get_label_impl(c: Context, segment: EdgeSegment, nodes: this[\"allNodes\"], segments: EdgeSegment[]): PrimitiveType | undefined {\r\n        let key: \"longestLabel\" | \"labels\" = segment.isLongest ? \"longestLabel\" : \"labels\"; // : keyof this\r\n        // if (isLongestSegment) return this.get_longestLabel_impl(d, l, nodes, index):\r\n        const d = c.data;\r\n        const l = c.proxyObject;\r\n        let labelmaker: any = (this as any)['get_'+key](c);\r\n        let labelmakerfunc: labelfunc = labelmaker as any;\r\n        // let lastSeg = segments[i-1];\r\n        switch (typeof labelmaker) {//nb{}[]<>\r\n            case \"number\":\r\n            case \"undefined\":\r\n            case \"boolean\":\r\n            case \"string\": return labelmaker;\r\n            // case \"function\": return nodes.map( (o, i) => d.labels(l, nodes, i)).slice(0, nodes.length-1);\r\n            // (e:LVoidEdge, segment: EdgeSegment, allNodes: LEdge[\"allNodes\"], allSegments: EdgeSegment[]) => PrimitiveType\r\n            case \"function\": return labelmakerfunc(l, segment, nodes, segments);\r\n            default: break;\r\n            case \"object\":\r\n                if (labelmaker === null) return null;\r\n                if (!Array.isArray(labelmaker)) break;\r\n                let elem = (labelmaker as PrimitiveType[])[segment.index % labelmaker.length];\r\n                if (typeof elem === \"function\") return (elem as labelfunc)(l, segment, nodes, segments);\r\n                return elem;\r\n        }\r\n        Log.exx(\"edge labels invalid type, must be a primitive value, a function or an array of such.\", {labelmaker, key, d});\r\n        return undefined;\r\n    }/*\r\n    private get_label_impl_old(d: DVoidEdge, l: LVoidEdge, nodes:this[\"allNodes\"], index: number, longestlabelindex?: number): PrimitiveType {\r\n        if (d.longestLabel !== undefined && index === longestlabelindex) return this.get_longestLabel_impl(d, l, nodes, index);\r\n        switch (typeof d.labels) {//nb{}[]<>\r\n            case \"number\":\r\n            case \"undefined\":\r\n            case \"boolean\":\r\n            case \"string\": return d.labels;\r\n            // case \"function\": return nodes.map( (o, i) => d.labels(l, nodes, i)).slice(0, nodes.length-1);\r\n            case \"function\": return d.labels(l, nodes[index], nodes[index+1], index, nodes);\r\n            default: break;\r\n            case \"object\": if (!Array.isArray(d.labels)) break;\r\n            if (typeof d.labels[0] === \"function\") return (d.labels as any)[index % d.labels.length](l, nodes[index], nodes[index+1], index, nodes);\r\n            return (d.labels as PrimitiveType[])[index % d.labels.length];\r\n        }\r\n        Log.exx(\"edge labels invalid type, must be a primitive value, a function or an array of such.\", d.labels);\r\n    }*/\r\n\r\n    __info_of__startPoint: Info = {type: \"GraphPoint\", txt:<span>startPoint of this.start (element originating the edge). Defaults in outer coordinates.</span>};\r\n    __info_of__endPoint: Info = {type: \"GraphPoint\", txt:<span>endPoint of this.end (element originating the edge). Defaults in outer coordinates.</span>};\r\n    public get_startPoint(context: Context): GraphPoint{ return this.get_startPoint_Outer(context); }\r\n    public get_endPoint(context: Context): GraphPoint{ return this.get_endPoint_Outer(context); }\r\n    public get_startPoint_Outer(c: Context): GraphPoint{\r\n        // console.log(\"get_edgeStart_Outer\", {out:this.get_outerGraph(c), pos:this.get_startPoint_inner(c), inner:this.get_start(c).innerGraph});\r\n        return this.get_outerGraph(c).translateSize(this.get_startPoint_inner(c), this.get_start(c).innerGraph);\r\n    }\r\n    public get_endPoint_Outer(c: Context): GraphPoint{\r\n        // console.log(\"get_edgeEnd_Outer\", {out:this.get_outerGraph(c), pos:this.get_endPoint_inner(c), inner:this.get_end(c).innerGraph});\r\n        return this.get_outerGraph(c).translateSize(this.get_endPoint_inner(c), this.get_end(c).innerGraph);\r\n    }\r\n\r\n    public get_startPoint_inner(c: Context): GraphPoint{ return this.get_edgeStartEnd_inner(c, true); }\r\n    public get_endPoint_inner(c: Context): GraphPoint{ return this.get_edgeStartEnd_inner(c, false); }\r\n    private get_edgeStartEnd_inner(c: Context, isStart: boolean): GraphPoint{ return isStart ? this.get_start(c).startPoint : this.get_end(c).endPoint; }\r\n    segments!: {all: EdgeSegment[], segments: EdgeSegment[], fillers: EdgeSegment[], head: GraphSize&{rad:number}, tail: GraphSize&{rad:number}};\r\n    segments_inner!: {all: EdgeSegment[], segments: EdgeSegment[], fillers: EdgeSegment[], head: GraphSize&{rad:number}, tail: GraphSize&{rad:number}};\r\n    segments_outer!: {all: EdgeSegment[], segments: EdgeSegment[], fillers: EdgeSegment[], head: GraphSize&{rad:number}, tail: GraphSize&{rad:number}};\r\n    __info_of__segments: Info = {type: \"{all:T, segments:T, fillers:T, head: GraphSize&{rad:number}, tail: as head} where T is EdgeSegment\",\r\n        txt:<span>Collection of segments connecting in order vertex and EdgePoint without intersecting their area, aimed to be rendered in svg path.\r\n            <br/>fillers are arcs generated by view.edgeGapMode being autofill, arcfill or linefill.\r\n            <br/>length of this.segments array is Math.ceil(allNodes.length / svg_letter_size) specified on view.\r\n            <br/>\"head\" and \"tail\" are the position and angle of eventual edge decorators. Refer to this.headPos documentation.</span>}\r\n\r\n    private svgLetterSize(s: string, addM: boolean = true, doublingMidPoints: boolean = true): {first:number, others: number} {\r\n        let ret: {first:number, others: number};\r\n        switch (s) {\r\n            default: ret = Log.exDevv(\"unexpected svg path letter: \\\"\" + s + \"\\\"\", s); break;\r\n            case EdgeBendingMode.Line:\r\n            //case EdgeBendingMode.Bezier_quadratic_mirrored:\r\n                ret = {first:1, others:1}; break;\r\n            case EdgeBendingMode.Bezier_quadratic:\r\n            //case EdgeBendingMode.Bezier_cubic_mirrored:\r\n                ret = {first:2, others:2}; break;\r\n            case EdgeBendingMode.Bezier_cubic: ret = {first:3, others:3}; break;\r\n            case EdgeBendingMode.Elliptical_arc: ret = {first:4, others:4}; break;\r\n\r\n            case EdgeBendingMode.Bezier_QT: ret = {first:2, others:1}; break;\r\n            case EdgeBendingMode.Bezier_CS: ret = {first:3, others:2}; break;\r\n        }\r\n\r\n        // account for the fact that every midpoint is listed twice: at anchor start and anchor end.\r\n        if (doublingMidPoints) {\r\n            // removing last point (first is already excluded because addM didn't trigger yet)\r\n            // , the remaining are midpoints to double. then i add it back\r\n            ret.first = (ret.first - 1) * 2 + 1;\r\n            ret.others = (ret.others - 1) * 2 + 1;\r\n        }\r\n\r\n        // account for the first M letter\r\n        //    (if the segment is not mode.gap or first, M coord still exist in segment but are ignored)\r\n        if (addM) {\r\n            ret.first += 1;\r\n            ret.others += 1;\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    // outer should be a redundant param and always == true\r\n    private get_points_impl(allNodes: LGraphElement[], outer: boolean, c:Context): segmentmaker[] {\r\n        function getAnchorOffset(size: GraphSize, offset: GraphPoint, isPercentage: boolean, $factor: number = 100) {\r\n            if (!size) size = new GraphSize(0, 0, 0, 0);\r\n            // else if (!size.tl) size = new GraphSize(size.x, size.y, size.w, size.h);\r\n            if (isPercentage) offset = new GraphPoint(offset.x/$factor*(size.w), offset.y/$factor*(size.h));\r\n            return size.tl().add(offset, false);\r\n        }\r\n        let innermost: LGraph = this.get_graph(c);\r\n        let root: LGraph = this.get_root(c);\r\n        const all: segmentmaker[] = allNodes.flatMap((ge, i) => {\r\n            let dge = ge.__raw;\r\n            let size = outer ? ge.outerSize : ge.innerSize;\r\n\r\n            if (outer && root && innermost && innermost.id !== root.id) {\r\n                size = innermost.translateSize(size, root);\r\n            }\r\n            let base: segmentmaker = {view: ge.view, size, ge, pt: null as any, uncutPt: null as any};\r\n\r\n            Log.exDev(typeof base.size !== \"object\", \"could not get node size:\", {base, c, outer})\r\n            let rets: segmentmaker | undefined;// = base as any;\r\n            let rete: segmentmaker | undefined;// = {...base} as any;\r\n            let debug = true;\r\n            if (debug) {\r\n                (base as any).anchor_e = dge.anchors[c.data.anchorEnd || 0] || dge.anchors[Object.keys(dge.anchors)[0]];\r\n                (base as any).anchor_s = dge.anchors[c.data.anchorStart || 0] || dge.anchors[Object.keys(dge.anchors)[0]];\r\n            }\r\n\r\n            // get endpoint, then startpoint (land on midnode, then depart from it)\r\n            if (i !== 0){\r\n                rete = {rete:true, ...base} as any as segmentmaker;\r\n                if (i === allNodes.length - 1) {\r\n                    // get end anchor from node\r\n                    let anchor = dge.anchors[c.data.anchorEnd || 0];\r\n                    if (!anchor) anchor = dge.anchors[Object.keys(dge.anchors)[0]];\r\n                    if (anchor) rete.pt = getAnchorOffset(rete.size, anchor, true, 1);\r\n                }\r\n                // if no anchor, treat the node as a midpoint\r\n                if (!rete.pt) {\r\n                    // get ending point from midpoint\r\n                    //rete.pt = (LEdgePoint.singleton as LEdgePoint).get_endPoint(undefined as any, rete.size, rete.view);\r\n                    rete.pt = getAnchorOffset(rete.size, rete.view.edgeStartOffset, rete.view.edgeStartOffset_isPercentage);\r\n                }\r\n                rete.uncutPt = rete.pt;\r\n            }\r\n            if (i !== allNodes.length - 1){\r\n                rets = {rets: true, ...base} as any as segmentmaker;\r\n                if (i === 0) {\r\n                    // get start anchor from node\r\n                    let anchor = dge.anchors[c.data.anchorStart || 0];\r\n                    if (!anchor) anchor = dge.anchors[Object.keys(dge.anchors)[0]];\r\n                    if (anchor) rets.pt = getAnchorOffset(rets.size, anchor, true, 1);\r\n                }\r\n                if (!rets.pt) {\r\n                    // rets starting point from midpoint\r\n                    // rets.pt = (LEdgePoint.singleton as LEdgePoint).get_startPoint(undefined as any, rets.size, rets.view);\r\n                    rets.pt = getAnchorOffset(rets.size, rets.view.edgeStartOffset, rets.view.edgeStartOffset_isPercentage);\r\n                }\r\n                rets.uncutPt = rets.pt;\r\n            }\r\n\r\n            // ret.pt = ge.startPoint\r\n            return rets && rete ? [rete, rets] : (rets ? [rets] : [rete as segmentmaker]); }\r\n        );\r\n\r\n        if (DVoidEdge.isFollowingCoords){\r\n            if (c.data.id === LVoidEdge.endFollow) {\r\n                let seg = all[all.length - 1];\r\n                seg.pt = DVoidEdge.isFollowingCoords;\r\n                seg.size = new GraphSize(seg.pt.x, seg.pt.y, 0.01, 0.01);\r\n            }\r\n            if (c.data.id === LVoidEdge.startFollow) {\r\n                let seg = all[0];\r\n                seg.pt = DVoidEdge.isFollowingCoords;\r\n                seg.size = new GraphSize(seg.pt.x, seg.pt.y, 0.01, 0.01);\r\n            }\r\n        }\r\n        return all;\r\n    }\r\n    private get_pointsDebug(c: Context): segmentmaker[]{ return this.get_points_impl(this.get_allNodes(c), true, c); }\r\n    private get_points(allNodes: LGraphElement[], outer: boolean = false, c: Context): segmentmaker[]{\r\n        return this.get_points_impl(allNodes, outer, c);\r\n    }\r\n    private get_points_outer(allNodes: LGraphElement[], c: Context): segmentmaker[]{ return this.get_points_impl(allNodes, true, c); }\r\n    // private get_points_inner(allNodes: LGraphElement[], c: Context): segmentmaker[]{ return this.get_points_impl(allNodes, false, c); }\r\n    public d!: string;\r\n    public __info_of__d: Info = {type: ShortAttribETypes.EString, txt:\"the full suggested path of SVG path \\\"d\\\" attribute, merging all segments.\"}\r\n    public get_d(c: Context) {\r\n        return this.get_segments(c).all.map(s => s.d).join(\" \");\r\n    }/*\r\n    private get_fillingSegments(c: Context): Partial<this[\"segments\"]> {\r\n        return this.get_segments(c).fillers;\r\n    }*/\r\n\r\n\r\n    public get_segments(c:Context): this[\"segments\"] {\r\n        return this.get_segments_outer(c);\r\n    }\r\n    public get_segments_outer(c:Context): this[\"segments\"] { return this.get_segments_impl(c, true); }\r\n    // public get_segments_inner(c: Context): this[\"segments\"] { return this.get_segments_impl(c, false); }\r\n    private get_segments_impl(c: Context, outer: boolean): this[\"segments\"] {\r\n        let l = c.proxyObject;\r\n        let v = this.get_view(c);\r\n        let allNodes = l.allNodes;\r\n        windoww.edge = l;\r\n        let all: segmentmaker[] = this.get_points(allNodes, outer, c);\r\n        //const all: {size: GraphSize, view: LViewElement, ge: LGraphElement}[] = allNodes.map((ge) => { return { view: ge.view, size: ge.size, ge}});\r\n        let ret: EdgeSegment[] = [];\r\n        let bm: EdgeBendingMode = v.bendingMode;\r\n        let gapMode: EdgeGapMode = v.edgeGapMode;\r\n        let segmentSize = this.svgLetterSize(bm, false, true);\r\n        let increase: number = segmentSize.first;\r\n        let segment: EdgeSegment | undefined = undefined;\r\n        /// grouping points according to SvgLetter\r\n        for (let i = 0; i < all.length - 1; ) {\r\n            // let start = all[i], end = all[i+increase];\r\n            let start: segmentmaker = all[i];\r\n            let endindex = (i+increase < all.length - 1) ? i+increase : all.length - 1;\r\n            let mid: segmentmaker[] = all.slice(i+1, endindex).filter( (e, i)=> i % 2 === 0);\r\n            let end: segmentmaker = all[endindex];\r\n            // makes sure the edge actually reaches his target even if there is an invalid amount of midnodes fot the current EdgeBendingMode\r\n            if (i === endindex && segment) start = segment.end;\r\n            // segment = this.get_segmentv3(start, mid, end, getSvgLetter(i), i, segment, all);\r\n            segment = new EdgeSegment(start, mid, end, bm, gapMode, i, segment);\r\n            // segment = this.get_segment(start.ge, start.size, start.view, end.ge, end.size, end.view, cut, v.bendingMode, mid, ret[ret.length -1], fillMode, segment);\r\n            ret.push(segment);\r\n            i+= increase+1; // because increase index is already inserted at the end of prev segment\r\n            if (increase !== segmentSize.others) increase = segmentSize.others;\r\n            // if (longestLabel !== undefined && longest < s.length) { longest = s.length; longestindex = i; } todo: move to after snapping to borders\r\n        }\r\n        function printablesegment(s:GObject) {\r\n            let r: GObject = {};\r\n            for (let k in s) {\r\n                let v = s[k];\r\n                v = v?.__raw || v;\r\n                if (typeof v === \"object\") r[k] = JSON.parse(JSON.stringify(v));\r\n                else r[k] = v;\r\n            }\r\n            return r;\r\n        }\r\n\r\n        let fillSegments: EdgeSegment[] = [];\r\n        this.snapSegmentsToNodeBorders(c, v, ret, fillSegments);\r\n        let longestLabel = c.data.longestLabel;\r\n        this.setLabels(c, ret, allNodes);\r\n        // console.log(\"getSegments() labeled:\", {main:ret, fillSegments});\r\n        let rett: this[\"segments\"] = {all: [...ret, ...fillSegments], segments: ret, fillers: fillSegments} as any;\r\n        /*switch(bm){\r\n            default: break;\r\n            case EdgeBendingMode.Bezier_QT:\r\n            case EdgeBendingMode.Bezier_CS:\r\n                rett.\r\n        }*/\r\n        for (let i = 0; i < rett.all.length; i++) {\r\n            let s = rett.all[i];\r\n            s.makeD(i, gapMode);\r\n        }\r\n        let zoom = new GraphPoint(1, 1);\r\n        rett.head = this.headPos_impl(c, true, v.edgeHeadSize, rett.segments[rett.segments.length - 1], zoom);\r\n        rett.tail = this.headPos_impl(c, false, v.edgeTailSize, rett.segments[0], zoom);\r\n        return rett;\r\n    }\r\n    private setLabels(c: Context, segments: EdgeSegment[], allNodes: this[\"allNodes\"]): void {\r\n        // find longest segment\r\n        let longestindex = -1;\r\n        let longest = 0;\r\n        for (let i = 0; i < segments.length; i++) {\r\n            let s = segments[i];\r\n            s.calcLength();\r\n            if (longest < s.length) { longest = s.length; longestindex = i; }\r\n            s.isLongest = false;\r\n        }\r\n        if (longestindex >= 0) segments[longestindex].isLongest = true;\r\n        // apply labels\r\n        for (let s of segments) s.label = this.get_label_impl(c, s, allNodes, segments);\r\n    }\r\n\r\n    private snapSegmentsToNodeBorders(c: Context, v: LViewElement, ret: EdgeSegment[], fillSegments: EdgeSegment[]){\r\n        // snap segment start and end to a node border\r\n        let canCutStart: boolean = v.edgeStartStopAtBoundaries,\r\n            canCutEnd: boolean = v.edgeEndStopAtBoundaries;\r\n        let grid: GraphPoint | undefined = undefined;\r\n        // let fillSegments: EdgeSegment[] = [];\r\n        let gapMode: EdgeGapMode = v.edgeGapMode;\r\n        let bm: EdgeBendingMode = v.bendingMode;\r\n\r\n\r\n        let ci: GraphPoint | undefined;\r\n        // cut i === 0 is cut regardless of gapmode.\r\n        if (canCutStart) {\r\n            ci = GraphSize.closestIntersection(ret[0].start.size, ret[0].start.pt, (ret[0].bezier[0] || ret[0].end).pt, grid);\r\n            if (ci) ret[0].start.pt = ci;\r\n            /*\r\n            ret[0].start.pt =\r\n                GraphSize.closestIntersection(ret[0].start.size, ret[0].start.pt, (ret[0].bezier[0] || ret[0].end).pt, grid) as any\r\n                || Geom.closestPoint(ret[0].start.size, ret[0].start.pt);*/\r\n        }\r\n\r\n        // cut middle segments maybe\r\n        let prev: EdgeSegment;\r\n        let curr: EdgeSegment = ret[0];\r\n\r\n        // if (gapMode === EdgeGapMode.gap) return;\r\n        if (canCutStart || canCutEnd) // do the for below\r\n            for (let i = 1; i < ret.length; i++){\r\n                prev = ret[i-1];\r\n                curr = ret[i];\r\n                let doStartCut: boolean, doEndCut: boolean;\r\n                switch(gapMode){/*\r\n                    case EdgeGapMode.arcFill:\r\n                    case EdgeGapMode.lineFill:\r\n                    case EdgeGapMode.autoFill:\r\n                        // same as gap, but will insert 1 more segment to fill the hole\r\n                        doStartCut = true;\r\n                        doEndCut = true;\r\n                        if (prev.end.pt.equals(curr.start.pt)) break;\r\n                        fillSegments.push(new EdgeFillSegment(\r\n                            prev.end,\r\n                            [\r\n                                {...prev.end, pt: EdgeSegment.invertLastBezierPt(prev.end.pt, (prev.bezier[prev.bezier.length-1] || prev.start).pt)},\r\n                                {...curr.start, pt: EdgeSegment.invertLastBezierPt(curr.start.pt, (curr.bezier[0] || curr.end).pt)}\r\n                            ],\r\n                            curr.start,\r\n                            bm, gapMode, 0, undefined));\r\n                            / *\r\n                            fillSegments.push(new FillEdgeSegment( // M <start_gap> C <bez1> <bez2> <end_gap>\r\n                               // <start_gap> = end of last seg (start of gap) <end_gap> = first of curr seg (end of gap)\r\n                            prev.end.pt,\r\n                            EdgeSegment.invertLastBezierPt(prev.end.pt, prev.bezier[prev.bezier.length-1].pt || prev.start.pt),\r\n                            EdgeSegment.invertLastBezierPt(curr.start.pt, curr.bezier[0].pt || curr.end.pt),\r\n                            curr.start.pt)* /\r\n\r\n                        break;*/\r\n                    case EdgeGapMode.gap:\r\n                        // just snap to vertex edge         prevSegment.endp and ret.startp\r\n                        doEndCut = true; doStartCut = true;\r\n                        break;\r\n                    // average: todo: maybe rename in join (merges start-end at closest pt to both (avg), then snap on edge)\r\n                    case \"closest\" as any: //EdgeGapMode.closest:\r\n                        // does not work properly, i think i need to get next.end instead of curr.end, just disabled for now\r\n                        let nextpt: GraphPoint = (curr.bezier[0] || curr.end).pt;\r\n                        let prevpt: GraphPoint = (prev.bezier[prev.bezier.length-1] || prev.start).pt;\r\n                        let midexternalpt = prevpt.add(nextpt, true);\r\n                        let midedgepoint = curr.start.size.tl().add(curr.start.size.br(), false).divide(2, false);\r\n                        // od average between the 2 points before and after that are not part of this edgepoint, then raw a line from there to center of ep, find that intersection.\r\n                        ci = GraphSize.closestIntersection(curr.start.size, midedgepoint, midexternalpt, grid);\r\n                        doEndCut = doStartCut = false;\r\n                        if (canCutEnd && ci) prev.end.pt = ci;\r\n                        if (canCutStart && ci) curr.start.pt = ci;\r\n                        break;\r\n                    case EdgeGapMode.average:\r\n                        // first move to average of the 2 points in the gap, then snap to edge\r\n                        doEndCut = true; doStartCut = true;\r\n                        // indipendent from cutStart, cutEnd.\r\n                        // they merge if just 1 of cutting sides are true. (and if they are both false we don't even enter the for loop)\r\n                        curr.start.pt = curr.start.pt.add(prev.end.pt, false).divide(2, false);\r\n                        prev.end.pt = curr.start.pt.duplicate(); // intentionally not the same pt because during snap to edge they can diverge again.\r\n                        prev.start.uncutPt = prev.start.pt;\r\n                        prev.end.uncutPt = prev.end.pt;\r\n                        break;\r\n                    // center: first move it to center of edgePoint/node, then snap to edge.\r\n                    // this mode might be as well deleted, it can be specified with anchor points\r\n                    case EdgeGapMode.center:\r\n                        doEndCut = false; doStartCut = false;\r\n                        curr.start.pt = curr.start.size.tl().add(curr.start.size.br(), false).divide(2, false);\r\n                        prev.end.pt = curr.start.pt.duplicate(); // intentionally not the same pt because during snap to edge they can diverge again.\r\n                        prev.start.uncutPt = prev.start.pt; // only update them when point moves without being cut (average and center)\r\n                        prev.end.uncutPt = prev.end.pt;\r\n                        break;\r\n                    default:\r\n                        return Log.exDevv(\"unexpected EdgeGapMode:\" + gapMode);\r\n                }\r\n                if (canCutStart && doStartCut){\r\n                    let nextpt: GraphPoint = (curr.bezier[0] || curr.end).pt;\r\n                    ci = GraphSize.closestIntersection(curr.start.size, curr.start.pt, nextpt, grid);\r\n                    if (ci) curr.start.pt = ci;// || Geom.closestPoint(curr.start.size, curr.start.pt);\r\n                    //if (gapMode === EdgeGapMode.average && prev) { prev.end.pt = curr.start.pt.add(prev.end.pt, false).divide(2, false); }\r\n                }\r\n                if (canCutEnd && doEndCut && prev){\r\n                    let prevpt: GraphPoint = (prev.bezier[prev.bezier.length-1] || prev.start).pt;\r\n                    ci = GraphSize.closestIntersection(prev.end.size, prev.end.pt, prevpt, grid);\r\n                    if (ci) prev.end.pt = ci;// || Geom.closestPoint(prev.end.size, prev.end.pt);\r\n                    // if average: first do average between start anchor points non-snapped. then i snap both,\r\n                    // then i do average again, and since it might snap out, i get closestPoint to EdgePoint size\r\n                    if (gapMode === EdgeGapMode.average) prev.end.pt = curr.start.pt =\r\n                        Geom.closestPoint(curr.start.size, curr.start.pt.add(prev.end.pt, false).divide(2, false));\r\n                }\r\n            }\r\n        // cut end of last segment regardless of gapMode\r\n        if (canCutEnd) {\r\n            let prevendpt = curr.end.pt;\r\n            ci = GraphSize.closestIntersection(curr.end.size, curr.end.pt, (curr.bezier[curr.bezier.length-1] || curr.start).pt, grid);\r\n            if (ci) curr.end.pt = ci; //|| Geom.closestPoint(prev.end.size, prev.end.pt);\r\n        }\r\n\r\n    }\r\n\r\n\r\n\r\n    get_edgeEnd(context: Context){ return this.get_edgeEnd_outer(context); }\r\n    get_edgeEnd_outer(c: Context){\r\n        // return this.get_outerGraph(c).translateSize(this.get_edgeEnd_inner(c), this.get_innerGraph(c));\r\n        return this.get_outerGraph(c).translateSize(this.get_edgeEnd_inner(c), this.get_end(c).innerGraph);\r\n    }\r\n    get_edgeEnd_inner(c: Context){\r\n        return this.get_edgeStartEnd_inner(c, false);\r\n        // return context.proxyObject.end?.size || new GraphPoint(0, 0);\r\n    }\r\n\r\n\r\n    protected get_midnodes(context: Context): this[\"midnodes\"] {\r\n        // return LPointerTargetable.wrapAll(context.data.midnodes);\r\n        return LPointerTargetable.wrapAll(context.data.subElements);\r\n    }\r\n    protected set_midnodes(val: D[\"midnodes\"], context: Context): boolean {\r\n\r\n        let name = this.get_name(context)||'';\r\n        TRANSACTION((name.toLowerCase().indexOf('edge')>=0 ? name : 'Edge: '+name)+'.midpoints', ()=>{\r\n            SetFieldAction.new(context.data.id, \"midnodes\", val, '', true);\r\n        });\r\n        return true;\r\n    }\r\n\r\n\r\n    anchorStart?: string;\r\n    anchorEnd?: string;\r\n    __info_of__anchorStart: Info = {writeType:\"string | undefined\", type:\"string\", isEdge: true,\r\n        txt:\"The name of a node anchor where the edge should originate from.\"};\r\n    __info_of__anchorEnd: Info = {writeType:\"string | undefined\", type:\"string\", isEdge: true,\r\n        txt:\"The name of a node anchor where the edge should point to.\"};\r\n    endFollow!: boolean;\r\n    startFollow!: boolean;\r\n    __info_of__endFollow: Info = {writeType:\"boolean\", readType:\"boolean\", type:\"boolean\", isEdge: true,// type:\"read:(()=>void), write:boolean\", readType:\"(()=>void))\",\r\n        txt:\"makes the ending point of an edge follow the cursor, so it can be assigned to a new anchor or target.\"};\r\n    __info_of__startFollow: Info = {writeType:\"boolean\", readType:\"boolean\", type:\"boolean\", isEdge: true,// type:\"read:(()=>void), write:boolean\", readType:\"(()=>void))\",\r\n        txt:\"makes the starting point of an edge follow the cursor, so it can be assigned to a new anchor or source.\"};\r\n    get_endFollow(c: Context): boolean { return (c.data.id === LVoidEdge.endFollow); }\r\n    get_startFollow(c: Context): boolean { return (c.data.id === LVoidEdge.startFollow); }\r\n    // // what in multieditor? needs to be moved in transientstuff?\r\n    set_endFollow(val: boolean, c: Context): boolean { return this._set_start_endFollow(val, c, false); }\r\n    set_startFollow(val: boolean, c: Context): boolean { return this._set_start_endFollow(val, c, true); }\r\n    _set_start_endFollow(val: boolean, c: Context, isStart: boolean): boolean {\r\n        val = !!val;\r\n        console.log(\"_set_start_endFollow\", {val, c, isStart});\r\n        if (val) {\r\n            if (isStart) LVoidEdge.startFollow = c.data.id;\r\n            else LVoidEdge.endFollow = c.data.id;\r\n            if (!LVoidEdge.following) {\r\n                console.log(\"_set_start_endFollow event attached\");\r\n                document.body.addEventListener(\"mousemove\", LVoidEdge.mousemove_pendingEdge, false);\r\n                document.body.addEventListener(\"keydown\", LVoidEdge.onKeyDown_pendingEdge, false);\r\n                LVoidEdge.following = true;\r\n                LVoidEdge.followingContext = c;\r\n                LVoidEdge.showAnchors();\r\n                (windoww.Tooltip as (typeof Tooltip)).show(<div>Changing anchor, press <b>Esc</b> to undo.</div>);\r\n\r\n                //let selector = \".Edge[nodeid='\" + (LVoidEdge.endFollow || LVoidEdge.startFollow as any)+\"']\";\r\n                // [...document.querySelectorAll(selector)].map(e=>e.classList.add(\"no-transition-following\")); gets refreshed by react\r\n                document.body.classList.add(\"no-transition-following\");\r\n            }\r\n        }\r\n        else {\r\n            if (LVoidEdge.following && ((isStart ? LVoidEdge.startFollow : LVoidEdge.endFollow) === c.data.id)) {\r\n                document.body.removeEventListener(\"mousemove\", LVoidEdge.mousemove_pendingEdge, false);\r\n                document.body.removeEventListener(\"keydown\", LVoidEdge.onKeyDown_pendingEdge, false);\r\n                let selector = \".Edge[nodeid='\" + (LVoidEdge.endFollow || LVoidEdge.startFollow as any)+\"']\";\r\n                //[...document.querySelectorAll(selector)].map(e=>e.classList.remove(\"no-transition-following\"));\r\n                document.body.classList.remove(\"no-transition-following\");\r\n                if (isStart) LVoidEdge.startFollow = undefined;\r\n                else LVoidEdge.endFollow = undefined;\r\n                LVoidEdge.following = false;\r\n                const $base = $(document.getElementById(isStart ? c.data.start : c.data.end) || []);\r\n                if (!$base.length) return true;\r\n                //const $deepAnchors = $base.find(\"[nodeid] .anchor\");\r\n                const $anchors = $base.find(\".anchor\")//.not($deepAnchors);\r\n                $anchors.removeClass([\"valid-anchor\", \"active-anchor\"]);\r\n                $base[0].style.overflow = '';\r\n                (windoww.Tooltip as (typeof Tooltip)).hide();\r\n            }\r\n        }\r\n        //SetFieldAction.new(c.data, \"startFollow\", !!val, '', false);\r\n        return true; }\r\n    public static startFollow: Pointer<DVoidEdge> | undefined = undefined;\r\n    public static endFollow: Pointer<DVoidEdge> | undefined = undefined;\r\n    public static following: boolean = false;\r\n    public static followingContext: LogicContext<DVoidEdge, LVoidEdge>;\r\n    public static tmp: number = 1;\r\n    public static canForceUpdate: boolean = true;\r\n    public static getCursorPos(e0: Event): Point { return new Point((e0 as any as MouseEvent).pageX, (e0 as any as MouseEvent).pageY); }\r\n    /*public static getGCursorPos(e0: Event): GraphPoint {\r\n        return LVLoidEdge.getCursorPos(e0).subtract(svgsize.tl(), true).multiply(svgzoom) as any as GraphPoint;\r\n    }*/\r\n    public static onKeyDown_pendingEdge(e: KeyboardEvent): void{\r\n        if (e.key === Keystrokes.escape) {\r\n            const c = LVoidEdge.followingContext;\r\n            if (!c || (!LVoidEdge.startFollow && !LVoidEdge.endFollow)) return;\r\n            let isStart = LVoidEdge.startFollow ? true : false;\r\n            let l = (c.proxyObject as any as LVoidEdge);\r\n            if (isStart) l.startFollow = false;\r\n            else l.endFollow = false;\r\n            // l.component?.forceUpdate(); does not work?\r\n            l.clonedCounter = (l.clonedCounter || 0) + 2;\r\n        }\r\n    }\r\n    public static showAnchors(): void{\r\n        const c = LVoidEdge.followingContext;\r\n        if (!c || (!LVoidEdge.startFollow && !LVoidEdge.endFollow)) return;\r\n        let isStart = LVoidEdge.startFollow ? true : false;\r\n        let nodeid: Pointer<DGraphElement> = isStart ? c.data.start : c.data.end;\r\n        let activeAnchor: string | number = (isStart ? c.data.anchorStart : c.data.anchorEnd) || 0;\r\n\r\n        const $base = $(document.getElementById(nodeid) || []);\r\n        if (!$base.length) return;\r\n        const $deepAnchors = $base.find(\"[nodeid] .anchor\");\r\n        const $anchors = $base.find(\".anchor\").not($deepAnchors);\r\n        $anchors.addClass(\"valid-anchor\");\r\n        $anchors.filter('[data-anchorname=\"'+activeAnchor+'\"]').addClass(\"active-anchor\");\r\n        $base[0].style.overflow = \"visible\";\r\n\r\n    }\r\n    private static mousemovei: number = 0;\r\n    public static mousemove_pendingEdge(e0: Event): void {\r\n        let forcererendermode = true;\r\n        if (forcererendermode) {\r\n            if (!LVoidEdge.following) return;\r\n            if (!LVoidEdge.canForceUpdate) return;\r\n            if (LVoidEdge.mousemovei++%30 === 0) LVoidEdge.showAnchors();\r\n\r\n\r\n            let c = LVoidEdge.followingContext;\r\n            let g: LGraph = c.proxyObject.graph;\r\n            let cursorPos = LVoidEdge.getCursorPos(e0);\r\n            let gcursorpos = g.translateHtmlSize(cursorPos);\r\n            // console.log(\"gcursorpos\", {cursorPos:cursorPos.toString(), gcursorpos:gcursorpos.toString(), g});\r\n            DVoidEdge.isFollowingCoords = gcursorpos;\r\n\r\n            let component: GraphElementComponent = GraphElementComponent.map[(LVoidEdge.startFollow || LVoidEdge.endFollow) as string];\r\n            LVoidEdge.canForceUpdate = false;\r\n            let timer = setTimeout(()=>{LVoidEdge.canForceUpdate = true; }, 5000);\r\n            let tn = transientProperties.node[c.data.id];\r\n            for (let vid in tn.viewScores) { // required to truly force an update\r\n                let tnv = tn.viewScores[vid];\r\n                tnv.jsxOutput = undefined;\r\n                tnv.usageDeclarations = undefined as any;\r\n                tnv.shouldUpdate = true;\r\n            }\r\n            component.setState({forceupdate:new Date().getDate()} as any, ()=>{LVoidEdge.canForceUpdate = true; clearTimeout(timer)});\r\n            // component.forceUpdate(()=>{LVoidEdge.canForceUpdate = true; clearTimeout(timer)});\r\n            return;\r\n        }\r\n\r\n        LVoidEdge.tmp++;\r\n        let selector = \".Edge[nodeid='\" + (LVoidEdge.endFollow || LVoidEdge.startFollow as any)+\"']\";\r\n        let root = document.querySelector(selector);\r\n        if (!root) return;\r\n        let paths: SVGPathElementt[] = [...root.querySelectorAll(\"path.full\")] as SVGPathElementt[];\r\n        let pathSegments = root.querySelectorAll(\"path.segment.preview\") as any as SVGPathElementt[];\r\n        // if (!paths.length) paths = pathSegments;\r\n        let pathSegmentContainers: Element[] = [...new Set([...pathSegments].map(e=>e.parentElement))] as Element[];\r\n        for (let container of pathSegmentContainers){\r\n            let se: SVGPathElementt[] = [...container.querySelectorAll(\"path.segment.preview\")] as SVGPathElementt[];\r\n            paths.push(se[LVoidEdge.endFollow ? se.length-1 : 0]);\r\n        }\r\n        let headTail = [...root.querySelectorAll(LVoidEdge.endFollow ? '.edgeHead' : '.edgeTail')] as HTMLElement[];\r\n        let cursorPos = LVoidEdge.getCursorPos(e0)\r\n\r\n        let segList: SVGPathSegment[] | undefined;\r\n        for (let p of paths) {\r\n            let svg: SVGElement = U.parentUntil(\"svg\", p) as SVGElement;\r\n            let svgsize: Size = Size.of(svg);\r\n            let svgzoom: Point = new Point(1,1); // todo: check viewbox and css zoom\r\n            let gcursorPos = cursorPos.subtract(svgsize.tl(), true).multiply(svgzoom) as any as GraphPoint;\r\n            segList = [...p.getPathData()];\r\n            let lastSeg = {...segList[LVoidEdge.endFollow ? segList.length-1 : 0]};\r\n            switch (lastSeg.type){\r\n                case 'a': case 'A':\r\n                    segList.push('fake new segment to get replaced instead of actual last segment which is A' as any);\r\n                    lastSeg.type=\"L\"; lastSeg.values = [gcursorPos.x, gcursorPos.y];\r\n                    break;\r\n                case \"C\": case \"c\": // bezier curves, keep type just change last point\r\n                case \"Q\": case \"q\":\r\n                case \"S\": case \"s\":\r\n                case \"T\": case \"t\":\r\n                    lastSeg.values[lastSeg.values.length-2] = gcursorPos.x;\r\n                    lastSeg.values[lastSeg.values.length-1] = gcursorPos.y; break;\r\n                case \"M\": case \"m\":\r\n                    lastSeg.type = LVoidEdge.endFollow ? \"L\" : \"M\";\r\n                    lastSeg.values = [gcursorPos.x, gcursorPos.y]; break;\r\n                case \"V\": case \"v\": // stuff forced to become a line\r\n                case \"H\": case \"h\":\r\n                case \"L\": case \"l\":\r\n                case \"Z\": case \"z\":\r\n                    lastSeg.type=\"L\"; lastSeg.values = [gcursorPos.x, gcursorPos.y];\r\n                    break;\r\n            }\r\n            segList[LVoidEdge.endFollow ? segList.length-1 : 0] = lastSeg;\r\n            if (LVoidEdge.tmp%20===0) console.log(\"svg set path data,\", {segList, oldSeglist:p.getPathData(), p});\r\n            p.setPathData(segList);\r\n        }\r\n\r\n        for (let ht of headTail){\r\n            let svg: SVGElement = U.parentUntil(\"svg\", ht) as SVGElement;\r\n            let svgsize: Size = Size.of(svg);\r\n            let svgzoom: Point = new Point(1,1); // todo: check viewbox and css zoom\r\n            let gcursorPos = cursorPos.subtract(svgsize.tl(), true).multiply(svgzoom) as any as GraphPoint;\r\n            let rotation: number;\r\n            let lastPt = segList && segList[LVoidEdge.endFollow ? segList.length-2 : 1].values;\r\n\r\n            if (lastPt) {\r\n                let m = gcursorPos.getM(new Point(lastPt[LVoidEdge.endFollow ? lastPt.length-2 : 1], lastPt[LVoidEdge.endFollow ? lastPt.length-1 : 0]));\r\n                if (Number.POSITIVE_INFINITY === m) rotation = Geom.degToRad(90); else\r\n                if (Number.NEGATIVE_INFINITY === m) rotation = Geom.degToRad(270); else\r\n                    rotation = Math.atan(m);\r\n                if (lastPt[LVoidEdge.endFollow ? lastPt.length-2 : 1] > gcursorPos.x) rotation -= Geom.degToRad(180);\r\n            } else { rotation = 0;}\r\n            let headSize = Size.of(ht);\r\n\r\n            let headPos = gcursorPos.subtract({x:headSize.w/2, y:headSize.h/2}, true);//.subtract({x:Math.cos(rotation)*headSize.w/2, y: -Math.sin(rotation)*headSize.h/2}, true);\r\n\r\n            if (LVoidEdge.tmp%20===0) console.log(\"_set_start_endFollow move head\", {selector:LVoidEdge.endFollow ? '.edgeHead' : '.edgeTail', headTail, root});\r\n            ht.style.transform = 'translate('+headPos.x+\"px, \"+headPos.y+\"px) rotate(\"+rotation+\"rad)\";\r\n        }\r\n    }\r\n}\r\nRuntimeAccessibleClass.set_extend(DGraphElement, DVoidEdge);\r\nRuntimeAccessibleClass.set_extend(LGraphElement, LVoidEdge);\r\n\r\n@RuntimeAccessible('DEdge')\r\nexport class DEdge extends DVoidEdge { // DVoidEdge\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // static singleton: LGraphElement;\r\n    // static logic: typeof LGraphElement;\r\n    // static structure: typeof DGraphElement;\r\n    id!: Pointer<DEdge, 1, 1, LEdge>;\r\n    graph!: Pointer<DGraph, 1, 1, LGraph>;\r\n    model!: Pointer<DModelElement, 0, 1, LModelElement>;\r\n    // isSelected: Dictionary<DocString<Pointer<DUser>>, boolean> = {};\r\n    isSelected!: Dictionary<DocString<Pointer<DUser>>, boolean>;\r\n    // containedIn!: Pointer<DGraphElement, 0, 1, LGraphElement>;\r\n    subElements!: Pointer<DGraphElement, 0, 'N', LGraphElement>;\r\n    state!: GObject;\r\n    start!: Pointer<DGraphElement, 1, 1, LGraphElement>;\r\n    end!: Pointer<DGraphElement, 1, 1, LGraphElement>;\r\n    __isDEdge!: true;\r\n    __isDVoidEdge!: true;\r\n    midnodes!: Pointer<DEdgePoint, 1, 1, LEdgePoint>[];\r\n}\r\n\r\n@RuntimeAccessible('LEdge')\r\nexport class LEdge<Context extends LogicContext<DEdge> = any, D extends DEdge = DEdge> extends LVoidEdge {\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // static singleton: LGraphElement;\r\n    // static logic: typeof LGraphElement;\r\n    // static structure: typeof DGraphElement;\r\n    __raw!: DEdge;\r\n    id!: Pointer<DEdge, 1, 1, LEdge>;\r\n    graph!: LGraph;\r\n    model?: LModelElement;\r\n    // isSelected: Dictionary<DocString<Pointer<DUser>>, boolean> = {};\r\n    isSelected(forUser?: Pointer<DUser>): boolean { return this.wrongAccessMessage(\"node.isSelected()\"); }\r\n    // containedIn!: LGraphElement;\r\n    subElements!: LGraphElement[];\r\n    _state!: GObject<\"proxified\">; // LMap;\r\n    midnodes!: LEdgePoint[];\r\n    __isLEdge!: true;\r\n    __isLVoidEdge!: true;\r\n\r\n}\r\nRuntimeAccessibleClass.set_extend(DVoidEdge, DEdge);\r\nRuntimeAccessibleClass.set_extend(LVoidEdge, LEdge);\r\n@Leaf\r\n@RuntimeAccessible('DExtEdge')\r\nexport class DExtEdge extends DEdge { // etends DEdge\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // static singleton: LGraphElement;\r\n    // static logic: typeof LGraphElement;\r\n    // static structure: typeof DGraphElement;\r\n    id!: Pointer<DExtEdge, 1, 1, LExtEdge>;\r\n    graph!: Pointer<DGraph, 1, 1, LGraph>;\r\n    model!: Pointer<DModelElement, 0, 1, LModelElement>;\r\n    // isSelected: Dictionary<DocString<Pointer<DUser>>, boolean> = {};\r\n    isSelected!: Dictionary<DocString<Pointer<DUser>>, boolean>;\r\n    // containedIn!: Pointer<DGraphElement, 0, 1, LGraphElement>;\r\n    subElements!: Pointer<DGraphElement, 0, 'N', LGraphElement>;\r\n    state!: GObject;\r\n    start!: Pointer<DGraphElement, 1, 1, LGraphElement>;\r\n    end!: Pointer<DGraphElement, 1, 1, LGraphElement>;\r\n    __isDExtEdge!: true;\r\n    __isDEdge!: true;\r\n    __isDVoidEdge!: true;\r\n    /*\r\n        public static new(model: DGraph[\"model\"], parentNodeID: DGraphElement[\"father\"], graphID: DGraphElement[\"graph\"], nodeID?: DGraphElement[\"id\"], size?: GraphSize): DExtEdge {\r\n            return new Constructors(new DExtEdge('dwc')).DPointerTargetable().DGraphElement(model, parentNodeID, graphID, nodeID)\r\n                .DVoidEdge().DEdge().DExtEdge().end();\r\n        }*/\r\n}\r\n\r\n@RuntimeAccessible('LExtEdge')\r\nexport class LExtEdge extends LEdge{\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // static singleton: LGraphElement;\r\n    // static logic: typeof LGraphElement;\r\n    // static structure: typeof DGraphElement;\r\n    __raw!: DExtEdge;\r\n    id!: Pointer<DExtEdge, 1, 1, LExtEdge>;\r\n    graph!: LGraph;\r\n    model?: LModelElement;\r\n    // isSelected: Dictionary<DocString<Pointer<DUser>>, boolean> = {};\r\n    isSelected(forUser?: Pointer<DUser>): boolean { return this.wrongAccessMessage(\"node.isSelected()\"); }\r\n    // containedIn!: LGraphElement;\r\n    subElements!: LGraphElement[];\r\n    _state!: GObject<\"proxified\">; // LMap;\r\n    start!: LGraphElement;\r\n    end!: LGraphElement;\r\n    __isLExtEdge!: true;\r\n    __isLEdge!: true;\r\n    __isLVoidEdge!: true;\r\n}\r\nRuntimeAccessibleClass.set_extend(DEdge, DExtEdge);\r\nRuntimeAccessibleClass.set_extend(LEdge, LExtEdge);\r\n@Leaf\r\n@RuntimeAccessible('DRefEdge')\r\nexport class DRefEdge extends DEdge { // extends DEdge\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    start!: Pointer<DGraphElement, 1, 1, LGraphElement>;\r\n    end!: Pointer<DGraphElement, 1, 1, LGraphElement>;\r\n    isSelected!: Dictionary<DocString<Pointer<DUser>>, boolean>;\r\n    __isDRefEdge!: true;\r\n    /*\r\n        public static new(model: DGraph[\"model\"], parentNodeID: DGraphElement[\"father\"], graphID: DGraphElement[\"graph\"], nodeID?: DGraphElement[\"id\"]): DRefEdge {\r\n            return new Constructors(new DRefEdge('dwc')).DPointerTargetable().DGraphElement(model, parentNodeID, graphID, nodeID)\r\n                .DVoidEdge().DEdge().DRefEdge().end();\r\n        }*/\r\n\r\n}\r\n@RuntimeAccessible('LRefEdge')\r\nexport class LRefEdge extends LEdge {\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // __raw!: DRefEdge;\r\n    start!: LGraphElement;\r\n    end!: LGraphElement;\r\n    __isLRefEdge!: true;\r\n}\r\nRuntimeAccessibleClass.set_extend(DEdge, DRefEdge);\r\nRuntimeAccessibleClass.set_extend(LEdge, LRefEdge);\r\n// for edges without a modelling element\r\n\r\n\r\n/*\r\n\r\nlet a = `DExtEdge, DRefEdge, DVoidEdge, LGraphVertex, LRefEdge, LEdgePoint, DVoidVertex, DGraphVertex, DEdgePoint,\r\n DVertex, DEdge, LVertex, LGraph, DGraph, LVoidVertex, LVoidEdge, LEdge, LGraphElement, LExtEdge, DGraphElement`;\r\n  // // ... get from export in index.ts\r\na = a.replaceAll(',,', \",\")\r\nlet aa = a.split(\",\").map(a => a.trim().substring(1));\r\n\r\nfunction onlyUnique(value, index, self) { return self.indexOf(value) === index; }\r\n\r\naa = aa.filter(onlyUnique).filter( a=> !!a)\r\nlet r = aa.filter(onlyUnique).filter( a=> !!a).map( a=> `export type W${a} = getWParams<L${a}, D${a}>;`).join('\\n')\r\ndocument.body.innerText = r;\r\n*/\r\nexport type WExtEdge = getWParams<LExtEdge, DExtEdge>;\r\nexport type WRefEdge = getWParams<LRefEdge, DRefEdge>;\r\nexport type WVoidEdge = getWParams<LVoidEdge, DVoidEdge>;\r\nexport type WGraphVertex = any; // getWParams<LGraphVertex, DGraphVertex>;\r\nexport type WEdgePoint = getWParams<LEdgePoint, DEdgePoint>;\r\nexport type WVoidVertex = getWParams<LVoidVertex, DVoidVertex>;\r\nexport type WVertex = getWParams<LVertex, DVertex>;\r\nexport type WEdge = getWParams<LEdge, DEdge>;\r\nexport type WGraph = getWParams<LGraph, DGraph>;\r\nexport type WGraphElement = getWParams<LGraphElement, DGraphElement>;\r\n\r\nconsole.warn('ts loading graphDataElement');\r\n\r\n","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\pages\\components\\index.ts",[],"C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\graph\\graphElement\\sharedTypes\\sharedTypes.tsx",["1226","1227","1228","1229","1230","1231"],"import React, {CSSProperties, PureComponent, ReactNode} from \"react\";\r\nimport type {\r\n    DEdge,\r\n    DGraph,\r\n    DGraphElement,\r\n    DModelElement,\r\n    DViewElement,\r\n    Json,\r\n    LGraph,\r\n    LGraphElement,\r\n    LModelElement,\r\n    LViewElement,\r\n    Pointer, PrimitiveType\r\n} from \"../../../joiner\";\r\nimport {Dictionary, LClass, LEdge, LUser, LViewPoint, LVoidVertex, RuntimeAccessible} from \"../../../joiner\";\r\nimport {GObject, InitialVertexSize, orArr} from \"../../../joiner/types\";\r\n\r\nexport class GraphElementStatee {/*\r\n    constructor(preRenderFunc: string | undefined, evalContext: GObject, templatefunc: () => React.ReactNode) {\r\n        this.preRenderFunc = preRenderFunc;\r\n        this.evalContext = evalContext;\r\n        this.template = templatefunc;\r\n    }\r\n    preRenderFunc?: string;\r\n    evalContext: Json;\r\n    template: () => ReactNode;* /\r\n    nodeid: Pointer<DGraphElement, 1, 1, LGraphElement>;\r\n    constructor(nodeid: Pointer<DGraphElement, 1, 1, LGraphElement>) {\r\n        this.nodeid = nodeid;\r\n    }*/\r\n    // displayPosition?: GraphSize; // used while dragging to prevent flood of redux events\r\n    classes!: string[];\r\n}\r\n\r\n\r\nexport class GraphElementReduxStateProps {\r\n    // userexample?: UserState; // todo: make and repace with proxy wrapper \"User\", or make a \"cached\" global variable synchronized with redux state for easier access\r\n    view!: LViewElement;\r\n    views!: LViewElement[]; // all applicable views\r\n    // graphID!: string;\r\n    // dataid?: Pointer<DModelElement, 1, 1, LModelElement>;\r\n    // model?: LModel;\r\n    // [userMappedFromRedux: string]: any; // roba che l'utente ha dichiarato di voler prendere dallo stato e redux gli carica nelle props\r\n    //preRenderFunc?: string;\r\n    // evalContext!: Json; moved to transient properties\r\n    //template!: string;\r\n    node!: LGraphElement;\r\n    data?: LModelElement;\r\n    __skipRender?: boolean;\r\n    // usageDeclarations!: DefaultUsageDeclarations;\r\n    // invalidUsageDeclarations?: Error; // moved in stateProps.usageDeclarations.__invalidUsageDeclarations\r\n    // graph!: LGraph;\r\n\r\n    // lastSelected!: LModelElement | null;\r\n    isEdgePending!: { user: LUser, source: LClass };// vertex only\r\n    nodeid!: Pointer<DGraphElement>;\r\n    dataid?: Pointer<DModelElement>;\r\n    viewid!: Pointer<DViewElement>;\r\n    viewsid!: Pointer<DViewElement>[];\r\n    parentviewid?:Pointer<DViewElement>;\r\n\r\n    static new(): GObject<GraphElementReduxStateProps>{\r\n        let e: GObject<GraphElementReduxStateProps> = new GraphElementReduxStateProps();\r\n        for (let k in e) if (e[k] === undefined) delete e[k];\r\n        return e;\r\n    }\r\n    protected constructor(){  }\r\n}\r\n\r\nexport class GraphElementDispatchProps {\r\n}\r\n\r\n// generic props for every component that this component will need to extend joining user-specified values and component-specific built-in values\r\nexport class BasicReactOwnProps {\r\n    children?: ReactNode; // orArr<JSX.Element | PrimitiveType>;\r\n    style?: CSSProperties;\r\n    class?: string | string[]; // my add as a fault-tolerant fix for users not used to jsx\r\n    className?: string | string[];\r\n    key?: string;\r\n\r\n    static new(): GObject<BasicReactOwnProps>{\r\n        let e: GObject<BasicReactOwnProps> = new BasicReactOwnProps();\r\n        for (let k in e) if (e[k] === undefined) delete e[k];\r\n        return e;\r\n    }\r\n    protected constructor(){ }\r\n}\r\n\r\nexport class GraphElementOwnProps extends BasicReactOwnProps {\r\n    data?: Pointer<DModelElement, 0, 1, LModelElement> | LModelElement;\r\n    view?: Pointer<DViewElement, 1, 1, LViewElement> | LViewElement;\r\n    views?: LViewElement[] | Pointer<DViewElement>[];\r\n    isGraph?: boolean;\r\n    isGraphVertex?: boolean;\r\n    isVertex?: boolean;\r\n    isEdgePoint?: boolean;\r\n    isEdge?: boolean;\r\n    isVoid?: boolean;\r\n    isField?: boolean = true;\r\n    onDelete?: (node: LGraphElement)=>boolean; // return false to prevent deletion\r\n\r\n    initialSize?: InitialVertexSize;\r\n\r\n    parentnodeid?: Pointer<DGraphElement, 1, 1, LGraphElement>; // Injected\r\n    nodeid?: Pointer<DGraphElement, 1, 1, LGraphElement>; // Injected\r\n    graphid?: Pointer<DGraph, 1, 1, LGraph>; // injected\r\n    parentViewId?: Pointer<DViewElement, 1, 1, LViewElement>; // injected\r\n    htmlindex?: number; // injected\r\n    childStyle?: CSSProperties; // obsolete use css // injected, indicates some properties are styled from <Polygon or such, and must be transferred to the first child of root\r\n\r\n    static new(): GObject<GraphElementOwnProps>{\r\n        let e: GObject<GraphElementOwnProps> = new GraphElementOwnProps();\r\n        for (let k in e) if (e[k] === undefined) delete e[k];\r\n        return e;\r\n    }\r\n    protected constructor(){ super(); }\r\n}\r\n\r\nexport class EdgeOwnProps extends GraphElementOwnProps {\r\n    onclick?: (e: React.MouseEvent<HTMLDivElement>) => void;\r\n    onmousedown?: (e: React.MouseEvent<HTMLDivElement>) => void;\r\n    start!: LGraphElement[\"id\"];\r\n    end!: LGraphElement[\"id\"];\r\n    label?: DEdge[\"longestLabel\"];\r\n    labels?: DEdge[\"labels\"];\r\n    anchorStart?: string;\r\n    anchorEnd?: string;\r\n    isField?: boolean = false;\r\n    isEdge?: boolean = true;\r\n    isReference?: boolean;\r\n    isValue?: boolean; // if missing it is deduced from isReference.\r\n    isExtend?: boolean;\r\n    isDepencency?: boolean; // package dep\r\n\r\n    static new(): GObject<EdgeOwnProps>{\r\n        let e: GObject<EdgeOwnProps> = new EdgeOwnProps();\r\n        for (let k in e) if (e[k] === undefined) delete e[k];\r\n        return e;\r\n    }\r\n    protected constructor(){ super(); }\r\n}\r\n\r\nexport class EdgeStateProps extends GraphElementReduxStateProps {\r\n    node!: LEdge;\r\n    edge!: LEdge; // just alias for node\r\n    //lastSelected!: LModelElement | null;\r\n    isEdgePending!: { user: LUser, source: LClass };\r\n    viewpoint!: LViewPoint;\r\n    start!: LGraphElement;\r\n    end!: LGraphElement;\r\n    __skipRender?: boolean; // in case start or end are undefined -> do not render the edge\r\n    static new(): GObject<EdgeStateProps>{\r\n        let e: GObject<EdgeStateProps> = new EdgeStateProps();\r\n        for (let k in e) if (e[k] === undefined) delete e[k];\r\n        return e;\r\n    }\r\n    protected constructor(){ super(); }\r\n    // key: string;\r\n}\r\n\r\n// @RuntimeAccessible\r\nexport class DefaultUsageDeclarations{\r\n    // all can be deleted in usageDeclaration function except view.\r\n    view?: GraphElementReduxStateProps[\"view\"];\r\n    node?: GraphElementReduxStateProps[\"node\"];\r\n    data: GraphElementOwnProps[\"data\"];\r\n    [key:string]: any;\r\n    constructor(ret: GraphElementReduxStateProps, ownProps: GraphElementOwnProps) {\r\n        /*this.data = ret.data;\r\n        this.view = ret.view;\r\n        this.node = ret.node;/*/\r\n    }\r\n}\r\n\r\n// @RuntimeAccessible\r\nexport class EdgeDefaultUsageDeclarations extends DefaultUsageDeclarations{\r\n    start!: EdgeOwnProps[\"start\"];\r\n    end!: EdgeOwnProps[\"end\"];\r\n}\r\n\r\n\r\n\r\nexport class VertexOwnProps extends GraphElementOwnProps {\r\n    // onclick?: (e: React.MouseEvent<HTMLDivElement>) => void;\r\n    // onmousedown?: (e: React.MouseEvent<HTMLDivElement>) => void;\r\n    isField?: boolean = false;\r\n    isVertex?: boolean = true;\r\n\r\n    decorated?: boolean; // for <decoratedStar /> (defaults true)\r\n    sides?: number // for <Polygon />, <Star /> and <Cross />\r\n    innerRadius?: number // for <Star /> and <Cross />\r\n    ratio?: number // for <Trapezoid />\r\n    rotate?: number // initial vertex rotation\r\n\r\n    static new(): GObject<VertexOwnProps>{\r\n        let e: GObject<VertexOwnProps> = new VertexOwnProps();\r\n        for (let k in e) if (e[k] === undefined) delete e[k];\r\n        return e;\r\n    }\r\n    protected constructor(){ super(); }\r\n}\r\n\r\nexport class VertexStateProps extends GraphElementReduxStateProps {\r\n    node!: LVoidVertex;\r\n    // lastSelected!: LModelElement | null;\r\n    // selected!: Dictionary<Pointer<DUser>, LModelElement|null>;\r\n    //selected!: LGraphElement|null;\r\n    isEdgePending!: { user: LUser, source: LClass };\r\n    viewpoint!: LViewPoint;\r\n\r\n    static new(): GObject<VertexStateProps>{\r\n        let e: GObject<VertexStateProps> = new VertexStateProps();\r\n        for (let k in e) if (e[k] === undefined) delete e[k];\r\n        return e;\r\n    }\r\n    protected constructor(){ super(); }\r\n}\r\n\r\n\r\nexport let contextFixedKeys: Dictionary<string, boolean> = {};\r\nsetContextFixedKeys();\r\n\r\nfunction setContextFixedKeys(){\r\n    // @ts-ignore: here i must use the constructor instead of new to have the undefined properties included.\r\n    let propmakers: GObject[] = [new EdgeOwnProps(), new EdgeStateProps(), new VertexOwnProps(), new VertexStateProps(), {\r\n        // \"model\", \"graph\",\r\n        \"constants\": true, \"usageDeclarations\": true,\r\n        \"component\": true,\r\n        \"htmlindex\": true,\r\n        \"state\": true, \"props\": true, \"stateProps\": true, \"ownProps\": true,\r\n        \"otherViews\": true, 'decorators':true, // only on final jsx, decorators are injected\r\n        //\"data\":true, \"node\":true, \"parentViewId\":true, \"parentnodeid\":true,// from props:\r\n        //\"view\":true, \"views\":true, \"viewScores\":true,// from props:\r\n        //\"children\":true, \"isGraph\":true, \"isVertex\":true, isEdge:true, isEdgePoint:true, isVoid: true, \"graphid\":true, \"nodeid\":true,// from props:\r\n    }];\r\n    for (let props of propmakers) for (let k in props) contextFixedKeys[k] = true;\r\n    delete contextFixedKeys.class;\r\n    return contextFixedKeys;\r\n}\r\n","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\view\\viewElement\\view.tsx",["1232","1233","1234","1235","1236","1237","1238","1239","1240","1241","1242"],"import {\r\n    Constructors,\r\n    CoordinateMode,\r\n    Debug, DEdgePoint,\r\n    Defaults,\r\n    DGraphElement,\r\n    Dictionary,\r\n    DModelElement,\r\n    DNamedElement,\r\n    DocString,\r\n    DPointerTargetable, DProject,\r\n    DState,\r\n    DViewPoint, DVoidEdge,\r\n    EdgeBendingMode,\r\n    EdgeGapMode, EdgeSegment,\r\n    EGraphElements,\r\n    EModelElements,\r\n    getWParams,\r\n    GObject,\r\n    GraphPoint,\r\n    GraphSize,\r\n    Info, LEdge, LEdgePoint, LGraphElement, LModelElement,\r\n    Log,\r\n    LogicContext,\r\n    LPointerTargetable, LProject, LUser,\r\n    LViewPoint,\r\n    LVoidEdge,\r\n    MyProxyHandler,\r\n    Pointer,\r\n    Pointers, PrimitiveType,\r\n    RuntimeAccessible,\r\n    RuntimeAccessibleClass,\r\n    Selectors,\r\n    SetFieldAction, SetRootFieldAction,\r\n    ShortAttribETypes,\r\n    store,\r\n    TRANSACTION,\r\n    U, Uobj, ViewEClassMatch,\r\n    windoww\r\n} from \"../../joiner\";\r\nimport {DUser, EPSize, Pack1, transientProperties } from \"../../joiner/classes\";\r\nimport DSL from \"../../DSL/DSL\";\r\nimport {ReactNode} from \"react\";\r\nimport {labeltype} from \"../../model/dataStructure/GraphDataElements\";\r\n\r\nlet CSS_Units0 = {'Local-font relative':{\r\n        'cap':     'cap - (Cap height) the nominal height of capital letters of the element\\'s font.',\r\n        'ch':      'ch - Average character advance of a narrow glyph in the element\\'s font, as represented by the \"0\" (ZERO, U+0030) glyph.',\r\n        'em':      'em - Font size of the element\\'s font.',\r\n        'ex':      'ex - x-height of the element\\'s font.',\r\n        'ic':      'ic - Average character advance of a full-width glyph in the element\\'s font, as represented by the \"水\" (CJK water ideograph, U+6C34) glyph.',\r\n        'lh':      'lh - Line height of the element.',\r\n    },\r\n\r\n    'Root-font relative':{\r\n        'rcap':    'rcap - Cap height (the nominal height of capital letters) of the root element\\'s font.',\r\n        'rch':     'rch - Average character advance of a narrow glyph in the root element\\'s font, as represented by the \"0\" (ZERO, U+0030) glyph.',\r\n        'rem':     'rem - Font size of the root element\\'s font.',\r\n        'rex':     'rex - x-height of the root element\\'s font.',\r\n        'ric':     'ric - Average character advance of a full-width glyph in the root element\\'s font, as represented by the \"水\" (CJK water ideograph, U+6C34) glyph.',\r\n        'rlh':     'rlh - Line height of the root element.',\r\n    },\r\n\r\n    'Relative':{\r\n        'dvh':      'dvh - 1% of the dynamic viewport\\'s height.',\r\n        'dvw':      'dvw - 1% of the dynamic viewport\\'s width.',\r\n        'lvh':      'lvh - 1% of the large viewport\\'s height.',\r\n        'lvw':      'lvw - 1% of the large viewport\\'s width.',\r\n        'svh':      'svh - 1% of the small viewport\\'s height.',\r\n        'svw':      'svw - 1% of the small viewport\\'s width.',\r\n        'vb':       'vb - 1% of viewport\\'s size in the root element\\'s block axis.',\r\n        'vh':       'vh - 1% of viewport\\'s height.',\r\n        'vi':       'vi - 1% of viewport\\'s size in the root element\\'s inline axis.',\r\n        'vmax':     'vmax - 1% of viewport\\'s larger dimension.',\r\n        'vmin':     'vmin - 1% of viewport\\'s smaller dimension.',\r\n        'vw':       'vw - 1% of viewport\\'s width.',\r\n        'fr':       'fr - (Flex) Represents a flexible length within a grid container',\r\n        '%':        '% - Percentage',\r\n    },\r\n\r\n    'Container @Query relative':{\r\n        'cqb':      'cqb - 1% of a query container\\'s block size',\r\n        'cqh':      'cqh - 1% of a query container\\'s height',\r\n        'cqi':      'cqi - 1% of a query container\\'s inline size',\r\n        'cqmax':    'cqmax - The larger value of cqi or cqb',\r\n        'cqmin':    'cqmin - The smaller value of cqi or cqb',\r\n        'cqw':      'cqw - 1% of a query container\\'s width',\r\n    },\r\n\r\n    'Absolute lengths':{\r\n        'cm':      'cm - (Centimeters) 1cm = 96px/2.54',\r\n        'in':      'in - (Inches) 1in = 2.54cm = 96px',\r\n        'mm':      'mm - (Millimeters) 1mm = 1/10th of 1cm',\r\n        'pc':      'pc - (Picas) 1pc = 1/6th of 1in',\r\n        'pt':      'pt - (Points) 1pt = 1/72th of 1in',\r\n        'px':      'px - (Pixels) 1px = 1/96th of 1in',\r\n        'Q':       'Q - (Quarter-millimeters) 1Q = 1/40th of 1cm',\r\n    },\r\n\r\n    'Angles':{\r\n        'deg':      'deg - (Degrees) There are 360 degrees in a full circle.',\r\n        'grad':     'grad - (Gradians) There are 400 gradians in a full circle.',\r\n        'rad':      'rad - (Radians) There are 2π radians in a full circle.',\r\n        'turn':     'turn - (Turns) There is 1 turn in a full circle.',\r\n    },\r\n\r\n    'Time':{\r\n        'ms':     'ms - Milliseconds',\r\n        's':      's - (Seconds) There are 1,000 milliseconds in a second.',\r\n    },\r\n\r\n    'Frequency':{\r\n        'Hz':      'Hz - (Hertz) Represents the number of occurrences per second.',\r\n        'kHz':     'kHz - (KiloHertz) A kiloHertz is 1000 Hertz.',\r\n    },\r\n\r\n    'Resolution':{\r\n        'dpcm':     'dpcm - Dots per centimeter.',\r\n        'dpi':      'dpi - Dots per inch.',\r\n        'dppx':     'dppx - Dots per px unit.',\r\n    },\r\n};\r\nexport let CSS_Units: typeof CSS_Units0 & { jsx: ReactNode, pattern: string } = CSS_Units0 as any;\r\n\r\nlet pattern: string[] = [];\r\n\r\nCSS_Units.jsx = <datalist id={\"__jodel_CSS_units\"}>{\r\n   (Object.keys(CSS_Units) as (keyof typeof CSS_Units0)[]).map(k1 => {\r\n        let v1: GObject = CSS_Units[k1];\r\n\r\n       return <optgroup label={k1}>\r\n            {Object.keys(v1).map(k => {\r\n                let v = v1[k];\r\n                pattern.push(k);\r\n                return <option value={k} title={v}></option>\r\n            })}\r\n        </optgroup>\r\n    })\r\n}</datalist>;\r\n//throw new Error(\"Stop\");\r\nCSS_Units.pattern = \"^(\" + pattern.join('|') + \")$\";\r\nwindoww.CSS_Units = CSS_Units;\r\n\r\n\r\n/*\r\nexport type CSS_AbsoluteUnit = 'px' | 'cm' | 'mm' | 'pt' | 'pc' | 'in' | '';\r\nexport type CSS_RelativeDomUnit = '%' | 'fr' | 'vw' | 'vh' | 'vmin' | 'vmax';\r\nexport type CSS_RelativeFontUnit =  'em' | 'rem' | 'ex' | 'ch';\r\nexport type CSSUnit = CSS_AbsoluteUnit | CSS_RelativeFontUnit | CSS_RelativeDomUnit;*/\r\n\r\nexport type StringControl = {type:'text', value: string};\r\nexport type NumberControl = {type:'number', value: number, unit: DocString<\"css unit\">};\r\nexport type PaletteControl = {type:'color', value: tinycolor.ColorFormats.RGBA[]}; // array of rgba: red, green, blue, alpha\r\nexport type PathControl = {type:'path', value: string, x: string, y: string, options: {k: string, v:string}[]};\r\nexport type PaletteType = Dictionary<string, PaletteControl | NumberControl | StringControl | PathControl>;\r\n\r\n\r\n@RuntimeAccessible('DViewElement')\r\nexport class DViewElement extends DPointerTargetable {\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // static singleton: LViewElement;\r\n    // static logic: typeof LViewDViewElementElement;\r\n    // static structure: typeof DViewElement;\r\n    public static MeasurableKeys: string[] = ['onDataUpdate', 'onDragStart', 'onDragEnd', 'whileDragging', 'onResizeStart',\r\n        'onResizeEnd', 'whileResizing', 'onRotationStart', 'onRotationEnd', 'whileRotating'];\r\n    public static RecompileKeys: string[] = ['onDataUpdate', 'onDragStart', 'onDragEnd', 'whileDragging', 'onResizeStart',\r\n        'onResizeEnd', 'whileResizing', 'onRotationStart', 'onRotationEnd', 'whileRotating',\r\n        'constants', 'usageDeclarations', 'jsxString', 'preconditions', 'jsCondition', 'ocl', 'events', 'labels', 'longestLabel'];\r\n\r\n    static LFromHtml(target?: Element | null): LViewElement | undefined { return LPointerTargetable.fromPointer(DViewElement.PtrFromHtml(target) as Pointer); }\r\n    static DFromHtml(target?: Element | null): DViewElement | undefined { return DPointerTargetable.fromPointer(DViewElement.PtrFromHtml(target) as Pointer); }\r\n    static PtrFromHtml(target?: Element | null): Pointer<DViewElement> | undefined {\r\n        while (target) {\r\n            if ((target.attributes as any).viewid) return (target.attributes as any).viewid.value;\r\n            target = target.parentElement;\r\n        }\r\n        return undefined;\r\n    }\r\n    // inherited redefine\r\n    // public __raw!: DViewElement;\r\n    id!: Pointer<DViewElement, 1, 1, LViewElement>;\r\n\r\n\r\n    // own properties\r\n    isValidation!: boolean; // only for root views (ex viewpoints) to group views semantically.\r\n    name!: string;\r\n    isExclusiveView!: boolean;\r\n\r\n    // processate 1 sola volta all'applicazione della vista o all'editing del campo\r\n    constants?: string;\r\n    // _parsedConstants?: GObject; // should be protected but LView is not subclass\r\n\r\n    // evaluate tutte le volte che l'elemento viene aggiornato (il model o la view cambia).\r\n    preRenderFunc!: string;\r\n\r\n    jsxString!: string; // l'html template\r\n    usageDeclarations?: string;\r\n\r\n    longestLabel?: DocString<\"function\">;\r\n    labels?: DocString<\"function\">;\r\n\r\n    forceNodeType?: DocString<'component name (Vertex, Field, GraphVertex, Graph)'>; // used in DefaultNode\r\n    // scalezoomx: boolean = false; // whether to resize the element normally using width-height or resize it using zoom-scale css\r\n    // scalezoomy: boolean = false;\r\n    // not persistent, some not shared. deve essere diverso da utente ad utente perchè dipende dal pan e zoom nel grafo dell'utente attuale.\r\n    // facendo pan su grafo html sposti gli elementi, per simulare uno spostamento del grafo e farlo sembrare illimitato.\r\n    // __transient: DViewTransientProperties;\r\n    appliableToClasses!: string[]; // class names: DModel, DPackage, DAttribute...\r\n    appliableTo!: 'Any'|'Graph'|'GraphVertex'|'Vertex'|'Edge'|'EdgePoint'|'Field';\r\n    subViews!: Dictionary<Pointer<DViewElement>, number/* priority boost */>;\r\n    oclCondition!: string; // ocl selector\r\n    jsCondition!: string; // js selector\r\n    oclUpdateCondition!: DocString<(view: LViewElement)=>boolean>;\r\n    //oclUpdateCondition_PARSED!: undefined | ((view: LViewElement)=>boolean); moved in transient\r\n    OCL_NEEDS_RECALCULATION!: boolean; // if only the oclCondition needs to be reapplied to all model elements\r\n    OCL_UPDATE_NEEDS_RECALCULATION!: boolean; // if both ocl needsto be reapplied and the oclUpdateCondition -> transient.view[v.id].oclUpdateCondition_PARSED needs to be remade\r\n    explicitApplicationPriority!: number; // priority of the view, if a node have multiple applicable views, the view with highest priority is applied.\r\n    defaultVSize!: GraphSize;\r\n    adaptHeight!: boolean;// | 'fit-content' | '-webkit-fill-available';\r\n    adaptWidth!: boolean;\r\n    /*width!: number;\r\n    height!: number;*/\r\n    draggable!: boolean;\r\n    resizable!: boolean;\r\n    viewpoint!: Pointer<DViewPoint>;\r\n    //display!: 'block'|'contents'|'flex'|string;\r\n    //constraints!: GObject<\"obsolete, used in Vertex. they are triggered by events (view.onDragStart....) and can bound the size of the vertex\">[];\r\n    onDataUpdate!: string;\r\n    onDragStart!: string;\r\n    onDragEnd!: string;\r\n    whileDragging!: string;\r\n    onResizeStart!: string;\r\n    onResizeEnd!: string;\r\n    whileResizing!: string;\r\n    onRotationStart!: string;\r\n    onRotationEnd!: string;\r\n    whileRotating!: string;\r\n    events!: Dictionary<DocString<\"functionName\">, DocString<\"functionBody\">>;\r\n    bendingMode!: EdgeBendingMode;\r\n    edgeGapMode!: EdgeGapMode;\r\n    //useSizeFrom!: EuseSizeFrom;\r\n    storeSize!: boolean;\r\n    size!: Dictionary<Pointer<DModelElement> | Pointer<DGraphElement>, GraphSize>;\r\n    lazySizeUpdate!: boolean; // if true updates it once when the vertex is released. if false updates vertex position every X millisecond while dragging.\r\n    edgeStartOffset!: GraphPoint;\r\n    edgeEndOffset!: GraphPoint;\r\n    edgeStartOffset_isPercentage!: boolean;\r\n    edgeEndOffset_isPercentage!: boolean;\r\n    edgeStartStopAtBoundaries!: boolean;\r\n    edgeEndStopAtBoundaries!: boolean;\r\n    edgePointCoordMode!: CoordinateMode;\r\n    edgeHeadSize!: GraphPoint;\r\n    edgeTailSize!: GraphPoint;\r\n    palette!: Readonly<PaletteType>;\r\n    css!: string;\r\n    cssIsGlobal!: boolean;\r\n    /* private */ compiled_css!: string;\r\n    /* private */ css_MUST_RECOMPILE!: boolean;\r\n    father?: Pointer<DViewElement>;\r\n/*\r\n    public static new(name: string, jsxString: string, father?: DViewElement, defaultVSize?: GraphSize, usageDeclarations: string = '', constants: string = '',\r\n                      preRenderFunc: string = '', appliableToClasses: string[] = [], oclCondition: string = '',\r\n                      priority?: number, persist: boolean = true, isDefaultView: boolean = false): DViewElement {\r\n        let id = isDefaultView ? 'Pointer_View' + name : undefined;\r\n        let vp = father.viewpoint;\r\n        return new Constructors(new DViewElement('dwc'), father.id, persist, undefined, id).DPointerTargetable()\r\n            .DViewElement(name, jsxString, vp, defaultVSize, usageDeclarations, constants,\r\n            preRenderFunc, appliableToClasses, oclCondition, priority).end();\r\n    }*/\r\n    public static new(...a:never): any{}\r\n    public static new2(name: string, jsxString: string, father0?: DViewElement, callback?: (d:DViewElement)=>void, persist: boolean = true,\r\n                       id?: string): DViewElement {\r\n        // let id = isDefaultView ? 'Pointer_View' + name : undefined;\r\n        let father: DViewElement = father0 || DPointerTargetable.from(Defaults.viewpoints[0]);\r\n        let vp = father.viewpoint || Defaults.viewpoints[0];\r\n        return new Constructors(new DViewElement('dwc'), father.id, persist, undefined, id)\r\n            .DPointerTargetable().DViewElement(name, jsxString, vp).end(callback);\r\n    }\r\n\r\n    static newDefault(forData?: DNamedElement): DViewElement{\r\n        const jsx = `<div className={'root'}>\r\n    <div className={'header'}>\r\n        <div className={'input-container mx-2'}>\r\n            <b className={'object-name'}>Name:</b>\r\n            <Input data={data} field={'name'} hidden={true} autosize={true} />\r\n        </div>\r\n    </div>\r\n    <div className={'body'}>To add information here,<br/> edit the view<br/><i>\"{view.name}\"</i></div>\r\n    {decorators}\r\n</div>`;\r\n        const palettes: PaletteType = {\r\n            \"border-color-\": {type:\"color\", value: [{r:187, g:187, b:187, a:1}]},\r\n            \"background-\": {type:\"color\", value: [{r:238, g:242, b:243, a:1}]},\r\n            \"color-\": {type:\"color\", value: [{r:3, g:54, b:86, a:1}]},\r\n        }\r\n            const css = `.root {\r\n    border: 1px solid var(--border-color-1);\r\n    border-radius: 4px;\r\n    background-color: var(--background-1);\r\n    color: var(--color-1);\r\n}\r\n \r\n.root div.header {\r\n    text-align: center;\r\n    border-bottom: 1px solid var(--border-color-1);\r\n    padding: 0px;\r\n    margin: 0px;\r\n}\r\n \r\n.root div.body {\r\n    text-align: center;\r\n    font-weight: normal;  \r\n    height: auto;\r\n    padding: 5px;\r\n}\r\n `;\r\n        let query = '';\r\n        if (forData) switch(forData.className) {\r\n            case 'DClass':\r\n                query = `context DObject inv: self.instanceof.id = '${forData.id}'`;\r\n                break;\r\n            case 'DAttribute':\r\n            case 'DReference':\r\n                query = `context DValue inv: self.instanceof.id = '${forData.id}'`;\r\n                break;\r\n            default:\r\n                query = `context ${forData.className} inv: self.id = '${forData.id}'`;\r\n                break;\r\n        }\r\n        const user = LUser.fromPointer(DUser.current);\r\n        // const project = user?.project; if(!project) return this;\r\n        let name: string;\r\n        const vp: LViewPoint = user?.project?.activeViewpoint || LPointerTargetable.fromPointer(Defaults.viewpoints[0]);\r\n        if (forData?.name) {\r\n            name = forData.name + 'View';\r\n        } else {\r\n            let names: string[] = vp.subViews.map(v => v && v.name);\r\n            name = U.increaseEndingNumber( 'view_' + 0, false, false, newName => names.indexOf(newName) >= 0);\r\n        }\r\n        return DViewElement.new2(name, jsx, vp.__raw,(d)=>{\r\n            d.css = css;\r\n            d.palette = palettes;\r\n            d.css_MUST_RECOMPILE = true;\r\n            d.oclCondition = query;\r\n        }, true);\r\n    }\r\n}\r\n\r\n@RuntimeAccessible('LViewElement')\r\nexport class LViewElement<Context extends LogicContext<DViewElement, LViewElement> = any, D extends DViewElement = any>\r\n    extends LPointerTargetable { // MixOnlyFuncs(DViewElement, LPointerTargetable)\r\n\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // static singleton: LViewElement;\r\n    // static logic: typeof LViewElement;\r\n    // static structure: typeof DViewElement;\r\n\r\n    // inherited redefine\r\n    public __raw!: DViewElement;\r\n    id!: Pointer<DViewElement, 1, 1, LViewElement>;\r\n\r\n\r\n\r\n    // own properties\r\n    isValidation!: boolean; // only for root views (ex viewpoints) to group views semantically.\r\n    name!: string;\r\n    __info_of__name: Info = {isGlobal: true, type: ShortAttribETypes.EString, txt:<div>Name of the view</div>}\r\n    isOverlay!:boolean;\r\n    __info_of__isOverlay: Info = {isGlobal:true, type: ShortAttribETypes.EBoolean, txt:<div>If not exclusive, the view is meant to add a functional outline of tools to a primary View, or css.\r\n            <br/>A non-exclusive view cannot be applied alone and needs an exclusive view to render the main graphical content.</div>};\r\n    get_isOverlay(c: Context): this[\"isOverlay\"] { return this.get_isExclusiveView(c); }\r\n    set_isOverlay(val: this[\"isOverlay\"], c: Context): boolean { return this.set_isExclusiveView(val, c); }\r\n\r\n    label!: this[\"longestLabel\"];  // should never be read change their documentation in write only. their values is \"read\" in this.segments\r\n    longestLabel!: labeltype; // (e:LVoidEdge, segment: EdgeSegment, allNodes: LEdge[\"allNodes\"], allSegments: EdgeSegment[]) => PrimitiveType;\r\n    labels!: labeltype; // (e:LVoidEdge, segment: EdgeSegment, allNodes: LEdge[\"allNodes\"], allSegments: EdgeSegment[]) => PrimitiveType;\r\n    __info_of__longestLabel: Info = {label:\"Longest label\", type:\"function(edge)=>string\",\r\n        readType: \"(edge:LEdge, segment: EdgeSegment, allNodes: DGraphElement[], allSegments: EdgeSegment[]) => PrimitiveType\",\r\n        writeType: \"string\",\r\n        txt: <span>Label assigned to the longest path segment.</span>}\r\n    __info_of__label: Info = {type: \"\", txt: <span>Alias for longestLabel</span>};\r\n    __info_of__labels: Info = {label:\"Multiple labels\",\r\n        readType: \"type of longestLabel | longestLabel[]\",\r\n        writeType: \"string\",\r\n        txt: <span>Instructions to label to multiple or all path segments in an edge</span>\r\n    };\r\n    get_label(c: Context): this[\"longestLabel\"] { return this.get_longestLabel(c); }\r\n    set_label(val: DVoidEdge[\"longestLabel\"], c: Context): boolean { return this.set_longestLabel(val, c); }\r\n    get_longestLabel(c: Context): this[\"longestLabel\"] { return transientProperties.view[c.data.id].longestLabel; }\r\n    get_labels(c: Context): this[\"labels\"] { return transientProperties.view[c.data.id].labels; }\r\n    set_longestLabel(val: DVoidEdge[\"longestLabel\"], c: Context): boolean {\r\n        Log.exDevv('Edge.labels are disabled, pass it through props instead');\r\n        if (val === c.data.longestLabel) return true;\r\n        TRANSACTION('change '+this.get_name(c)+' label', ()=>{\r\n            SetFieldAction.new(c.data, \"longestLabel\", val);\r\n            SetRootFieldAction.new(\"VIEWS_RECOMPILE_longestLabel+=\", c.data.id);\r\n        });\r\n        return true;\r\n    }\r\n    set_labels(val: DVoidEdge[\"labels\"], c: Context): boolean {\r\n        Log.exDevv('Edge.labels are disabled, pass it through props instead');\r\n        if (val === c.data.labels) return true;\r\n        TRANSACTION('change '+this.get_name(c)+' labels', ()=>{\r\n            SetFieldAction.new(c.data, \"labels\", val);\r\n            SetRootFieldAction.new(\"VIEWS_RECOMPILE_labels+=\", c.data.id);\r\n        });\r\n        return true; }\r\n\r\n    allPossibleParentViews!: LViewElement[];\r\n    __info_of__allPossibleParentViews: Info = {isGlobal: true, type: 'LViewElement[]', txt: 'All views except subviews and this view.' }\r\n    get_allPossibleParentViews(c: Context): this['allPossibleParentViews']{\r\n        let subviewsarr = this.get_allSubViews(c);\r\n        let subviews = U.objectFromArray(subviewsarr, (sv)=>sv.id);\r\n        let allviewsarr: LViewElement[] = Selectors.getAll(DViewElement, undefined, undefined, true, true);\r\n        let allviews = U.objectFromArray(allviewsarr, (sv)=>sv.id);\r\n        console.log('allPossibleParentViews', {subviews, subviewsarr, allviews:{...allviews}, allviewsarr});\r\n        for (let k in subviews) {\r\n            delete allviews[k];\r\n        }\r\n        delete allviews[c.data.id];\r\n        console.log('allPossibleParentViews ret', {allviews});\r\n        return Object.values(allviews);\r\n    }\r\n\r\n\r\n\r\n    explicitApplicationPriority!: number; // priority of the view, if a node have multiple applicable views, the view with highest priority is applied.\r\n    __info_of__explicitApplicationPriority: Info = {isGlobal: true, type: ShortAttribETypes.EByte, label:\"explicit priority\",\r\n        txt: 'Application priority of view. If multiple views match an element, the highest priority will render the main jsx.' }\r\n    get_explicitApplicationPriority(c: Context): this[\"explicitApplicationPriority\"] {\r\n        if (c.data.explicitApplicationPriority !== undefined) return c.data.explicitApplicationPriority;\r\n        else return (c.data.jsCondition?.length || 1) + (c.data.oclCondition?.length || 1); }\r\n    set_explicitApplicationPriority(val: this[\"explicitApplicationPriority\"] | undefined, c: Context): boolean {\r\n        if (c.data.explicitApplicationPriority === val) return true;\r\n        for (let nid in transientProperties.node){\r\n            let tn = transientProperties.node[nid];\r\n            for (let vid in tn.viewScores){\r\n                let tnv = tn.viewScores[vid];\r\n                if (!tnv.metaclassScore || !tnv.OCLScore) continue;\r\n                if (tnv.jsScore === true) tn.needSorting = true; // recompute final score.\r\n            }\r\n        }\r\n        SetFieldAction.new(c.data, \"explicitApplicationPriority\", val as number, '', false);\r\n        return true;\r\n    }\r\n\r\n    isExclusiveView!: boolean;\r\n    __info_of__isExclusiveView: Info = {isGlobal:true, type: ShortAttribETypes.EBoolean, txt:<div>If not exclusive, the view is meant to add a functional outline of tools to a primary View, or css.\r\n    <br/>A non-exclusive view cannot be applied alone and needs an exclusive view to render the main graphical content.</div>};\r\n    get_isExclusiveView(c: Context): this[\"isExclusiveView\"] { return c.data.isExclusiveView; }\r\n    set_isExclusiveView(val: this[\"isExclusiveView\"], c: Context): boolean {\r\n        if (Defaults.check(c.data.id)) return true; // cannot delete or \"demote\" to decorations the main views, to make sure there is always at least 1 appliable view.\r\n        return SetFieldAction.new(c.data, \"isExclusiveView\", !!val, '', false);\r\n    }\r\n\r\n    constants?: string;\r\n    __info_of__constants: Info = {todo:true, isGlobal: true, type: \"Function():Object\", label:\"constants declaration\",\r\n        txt:<div>Data used in the visual representation, meant to be static values evaluated only once when the view is first applied.<br/>\r\n        Check default value view for an example.<br/>\r\n    </div>};\r\n    // Example 1: <code>{'{color:\"red\", background: \"gray\"}'}</code><br/>\r\n    // Example 2: <code>{'function(){\\n    let fib = [1,1]; for (let i = 2; i < 100) { fib[i] = fib[i-2]+fib[i-1]; }\\n    return fib; }'}</code><br/>\r\n\r\n    preRenderFunc?: string; // evalutate tutte le volte che l'elemento viene aggiornato (il model o la view cambia)\r\n    __info_of__preRenderFunc: Info = {isGlobal: true, obsolete: true, type: \"Function():Object\", label:\"pre-render function\",\r\n        txt:<div>Data used in the visual representation, meant to be dynamic values evaluated every time the visual representation is updated.<br/>Replaced by usageDeclarations.</div>}\r\n\r\n    protected _defaultGetter(c: Context, k: keyof Context[\"data\"]): any { return this.__defaultGetter(c, k); }\r\n\r\n    protected _defaultSetter(v: any, c: Context, k: keyof Context[\"data\"]): any { return this.__defaultSetter(v, c, k); }\r\n\r\n    jsxString!: string;\r\n    __info_of__jsxString: Info = {isGlobal: true, type: \"text\", label:\"JSX template\",\r\n        txt:<div>The main ingredient, a <a href={\"https://react.dev/learn/writing-markup-with-jsx\"}>JSX template</a> that will be visualized in the graph.</div>}\r\n    protected get_jsxString(c: Context): this['jsxString'] {\r\n        return c.data.jsxString;\r\n    }\r\n    protected set_jsxString(val: this['jsxString'], c: Context): boolean {\r\n        TRANSACTION('change '+this.get_name(c)+' JSX', () => {\r\n            // const jsx = DSL.parser(val);\r\n            SetFieldAction.new(c.data, 'jsxString', val, '', false);\r\n            SetRootFieldAction.new('VIEWS_RECOMPILE_jsxString', c.data.id, '+=', false);\r\n        });\r\n        return true;\r\n    }\r\n\r\n    usageDeclarations?: string;\r\n    __info_of__usageDeclarations: Info = {todo: false, isGlobal: true, type: \"Function():Object\", label:\"usage declarations\",\r\n        txt: <div>Subset of the global or elements's data state that is graphically used.\r\n            <br/>If specified the element will only update when one of those has changed.\r\n            <br/>Can optimize performance and ensure the node is updated even when navigating remote properties that\r\n            <br/>    don\\'t belong to this element, like visualizing the name of an object pointed by a reference.\r\n            <br/>Context: it has the usual variables present in a JSX template (data, view, node...)\r\n            <br/>    plus a special variable \"ret\" where dependencies are registered.{/*and a \"state\" variable containing the entire application state.*/}\r\n            <br/>Usage Example: see the default view for value.\r\n    </div>}\r\n    protected get_usageDeclarations(c: Context): this[\"usageDeclarations\"]{\r\n        return c.data.usageDeclarations || \"(ret)=>{ // scope contains: data, node, view, constants, state\\n\" +\r\n            \"// ** preparations and default behaviour here ** //\\n\" +\r\n            \"ret.data = data\\n\" +\r\n            \"ret.node = node\\n\" +\r\n            \"ret.view = view\\n\" +\r\n            \"// data, node, view are dependencies by default. delete them above if you want to remove them.\\n\" +\r\n            // if you want your node re-rendered every time, add a dependency to ret.state = state; or ret.update = Math.random();\r\n            \"// add preparation code here (like for loops to count something), then list the dependencies below.\\n\" +\r\n            \"// ** declarations here ** //\\n\" +\r\n            \"}\";\r\n    }\r\n    protected set_usageDeclarations(val: this['usageDeclarations'], c: Context): boolean {\r\n        TRANSACTION('change '+this.get_name(c)+'.usageDeclarations', ()=>{\r\n            SetFieldAction.new(c.data, 'usageDeclarations', val, '', false);\r\n            SetRootFieldAction.new('VIEWS_RECOMPILE_usageDeclarations', c.data.id, '+=', false);\r\n        })\r\n        return true;\r\n    }\r\n\r\n    // format should be array of (usedPaths: string[]) starting with \"data.\" AUTOMATICALLY inefered from the ocl editor.\r\n    oclUpdateCondition!: (oldData: LModelElement, newData:LModelElement) => boolean;\r\n    __info_of__oclUpdateCondition: Info = {readType: '(view: LViewElement)=>boolean', writeType: 'function string',\r\n        txt: \"[Optionally] Declare variables that are used in OCL condition, so that OCL will be re-checked only when those values have changed.\"}\r\n    get_oclUpdateCondition(c: Context): this[\"oclUpdateCondition\"] { return transientProperties.view[c.data.id].oclUpdateCondition_PARSED; }\r\n    set_oclUpdateCondition(val: DocString<\"function\">, c: Context): boolean {\r\n        TRANSACTION('change '+this.get_name(c)+'.updateCondition', ()=>{\r\n            SetFieldAction.new(c.data, \"oclUpdateCondition\", val || '', '', false);\r\n            // not recalculated right now because the change needs to be sent to collaborative editor users\r\n            // it is pointer, but i don't want to set pointedby's, it is very short lived.\r\n            SetRootFieldAction.new(\"OCL_UPDATE_NEEDS_RECALCULATION\", c.data.id, '+=', false);\r\n        });\r\n        return true;\r\n    }\r\n/* moved it as setrootfield action and as array. check it after every reducer. update im same style the color palette too?\r\n    OCL_NEEDS_RECALCULATION!: boolean;\r\n    __info_of__OCL_NEEDS_RECALCULATION: Info = {hidden: true, type: ShortAttribETypes.EBoolean,\r\n        txt: \"if only the oclCondition needs to be reapplied to all model elements\"}\r\n    get_OCL_NEEDS_RECALCULATION(c: Context): this[\"OCL_NEEDS_RECALCULATION\"] { return c.data.OCL_NEEDS_RECALCULATION; }\r\n    set_OCL_NEEDS_RECALCULATION(val: this[\"OCL_NEEDS_RECALCULATION\"], c: Context): boolean { return this.cannotSet('OCL_NEEDS_RECALCULATION'); }\r\n\r\n    OCL_UPDATE_NEEDS_RECALCULATION!: boolean;\r\n    __info_of__OCL_UPDATE_NEEDS_RECALCULATION: Info = {hidden: true, type: ShortAttribETypes.EBoolean,\r\n        txt: \"if both ocl needsto be reapplied and the oclUpdateCondition -> transient.view[v.id].oclUpdateCondition_PARSED needs to be remade\"}\r\n    get_OCL_UPDATE_NEEDS_RECALCULATION(c: Context): this[\"OCL_UPDATE_NEEDS_RECALCULATION\"] { return c.data.OCL_UPDATE_NEEDS_RECALCULATION; }\r\n    set_OCL_UPDATE_NEEDS_RECALCULATION(val: this[\"OCL_UPDATE_NEEDS_RECALCULATION\"], c: Context): boolean { return this.cannotSet('OCL_UPDATE_NEEDS_RECALCULATION'); }*/\r\n\r\n    private css_MUST_RECOMPILE!: boolean;\r\n    public cssIsGlobal!: boolean;\r\n    __info_of__cssIsGlobal: Info = {type: ShortAttribETypes.EBoolean, txt: \"Use with caution!\\nIf true, custom css can affect even elements not matched with this view, or outside the graph.\"}\r\n    get_cssIsGlobal(c: Context): this[\"cssIsGlobal\"] {\r\n        return c.data.cssIsGlobal;\r\n    }\r\n    set_cssIsGlobal(val: this[\"cssIsGlobal\"], c: Context): boolean {\r\n        val = !!val;\r\n        if (val === c.data.cssIsGlobal) return true;\r\n        TRANSACTION('change '+this.get_name(c)+'.cssIsGlobal', ()=>{\r\n            SetFieldAction.new(c.data, \"cssIsGlobal\", val, '', false);\r\n            // compile only when accessed, to prevent color inputs to do a mess of compilations\r\n            SetFieldAction.new(c.data, \"css_MUST_RECOMPILE\", true, '', false);\r\n        }, c.data.cssIsGlobal, val);\r\n        return true;\r\n    }\r\n    public css!: string;\r\n    __info_of__css: Info = {type: \"css string\", txt: \"Inject custom css that cannot be inserted inline like :hover or css variables.\\nSupport LESS syntax.\"}\r\n    get_css(c: Context): this[\"css\"] { return c.data.css; }\r\n    set_css(val:this[\"css\"], c: Context): boolean {\r\n        TRANSACTION('change '+this.get_name(c)+'.css', ()=>{\r\n            SetFieldAction.new(c.data, \"css\", val, '', false);\r\n            // compile only when accessed, to prevent color inputs to do a mess of compilations\r\n            SetFieldAction.new(c.data, \"css_MUST_RECOMPILE\", true, '', false);\r\n        });\r\n        return true;\r\n    }\r\n\r\n    compiled_css!: string;\r\n    __info_of__compiled_css: Info = { hidden: true, txt:'css + palettes compiled from less in css'};\r\n    get_compiled_css(c: Context): this[\"compiled_css\"] {\r\n        if (c.data.isExclusiveView && c.data.className === DViewPoint.cname && !Defaults.check(c.data.id) ) {\r\n            let project = this.get_project(c);\r\n            let dproject = project?.__raw as DProject | undefined;\r\n            if (!(dproject && dproject.activeViewpoint === c.data.id)) return '';\r\n        }\r\n        if (!c.data.css_MUST_RECOMPILE) return c.data.compiled_css; // return c.proxyObject.r.__raw.compiled_css;\r\n        let s = '';\r\n        const allowLESS = false;\r\n        let shortPaletteName: string;\r\n        let cc = c;\r\n        function rgbastring(c: tinycolor.ColorFormats.RGBA): string{\r\n            Log.exDev(!c, \"invalid color:\", {id: cc.data.id, c, shortPaletteName, p:cc.data.palette});\r\n            return \"rgba(\"+c.r+\",\"+c.g+\",\"+c.b+\",\"+c.a+\")\";\r\n        }\r\n        //let palettes = U.paletteSplit(c.data.palette);\r\n        for (let paletteName in c.data.palette) {\r\n            let palette0 = c.data.palette[paletteName] as any;\r\n            if (palette0.type === \"color\") {\r\n                let palette = palette0 as PaletteControl;\r\n                let colors = palette.value;\r\n                if (!colors.length) continue;\r\n                if (['-', '_'].includes(paletteName[paletteName.length-1])) shortPaletteName = paletteName.substring(0, paletteName.length - 1);\r\n                else shortPaletteName = paletteName;\r\n                let rgba = rgbastring(colors[0]);\r\n                // set prefixed name without number\r\n                if (allowLESS) s += \"\\t@\" + shortPaletteName + \": \" + rgba + ';\\n';\r\n                s += \"\\t--\" + shortPaletteName + \": \" + rgba + ';\\n';\r\n                // set prefixed-0 name\r\n                if (allowLESS) s += \"\\t@\" + paletteName + '0: ' + rgba + ';\\n';\r\n                s += \"\\t--\" + paletteName + '0: ' + rgba + ';\\n';\r\n                // set prefixed-1 to prefixed-...n names\r\n                for (let i = 0 ; i < colors.length; i++) {\r\n                    rgba = rgbastring(colors[i]);\r\n                    if (allowLESS) s += \"\\t@\" + paletteName + (i+1) + \": \" + rgba + ';\\n';\r\n                    s += \"\\t--\" + paletteName + (i+1) + \": \" + rgba + ';\\n';\r\n                }\r\n            } else if (palette0.type === 'path'){\r\n                let palette: PathControl = palette0;\r\n                let val = U.replaceAll(palette.value, 'view.', '');\r\n                val = U.replaceAll(val, 'this.', '');\r\n                val = U.replaceAll(val, 'x', palette.x);\r\n                val = U.replaceAll(val, 'y', palette.y);\r\n                val = U.replaceAll(val, '+', ' +');\r\n                val = U.replaceAll(val, '-', ' -'); // important: cannot add space post-dash or it's harder to distinguish unary and binary -\r\n                val = U.replaceAll(val, '/', ' / ');\r\n                val = U.replaceAll(val, '*', ' * ');\r\n                let valarr: (string | number)[] = val.split(/[,\\s]/);\r\n                // [] not allowed\r\n                valarr = (valarr as string[]).map(val => {\r\n                    if (!isNaN(+val)) return val;\r\n                    let patharr: string[] = val.split('.');\r\n                    let curr: GObject = c.data;\r\n                    for (let pathseg of patharr) {\r\n                        curr = curr[pathseg];\r\n                        Log.e(!curr && (val.length > 1 || patharr.length > 1), \"invalid variable path in css path control\", {token:val, view:c.data.name});\r\n                        if (!curr) break;\r\n                    }\r\n                    if (typeof curr === \"object\" || (typeof curr === \"undefined\" && (val.length > 1 || patharr.length > 1)))\r\n                        Log.ee( \"invalid variable path in css path control\", {token:val, view:c.data.name});\r\n                    else val = curr || val;\r\n                    return val;\r\n                }).filter(p=>!!p);\r\n\r\n                for (let i = 0 ; i < valarr.length; i++) {\r\n                    let val = valarr[i];\r\n                    switch (val) { // i avoid subtracting L 1 -1 with spaces. it's unary if doesn't have a postfix space.\r\n                        default: continue;\r\n                        case '*': valarr[i] = +valarr[i-1] * +valarr[i+1]; valarr[i-1] = valarr[i+1] = ''; break;\r\n                        case '/': valarr[i] = +valarr[i-1] / +valarr[i+1]; valarr[i-1] = valarr[i+1] = ''; break;\r\n                        case '+': valarr[i] = +valarr[i-1] + +valarr[i+1]; valarr[i-1] = valarr[i+1] = ''; break;\r\n                        case '-': valarr[i] = +valarr[i-1] - +valarr[i+1]; valarr[i-1] = valarr[i+1] = ''; break;\r\n                    }\r\n                }\r\n                val = valarr.filter(p=>!!p).join(' ');\r\n                val = \"'\"+val+\"'\";\r\n                if (allowLESS) s += \"\\t@\" + paletteName + \": \" + val + ';\\n';\r\n                s += \"\\t--\" + paletteName + ': ' + val + ';\\n';\r\n            }\r\n            else {\r\n                // number or text\r\n                let palette: NumberControl | StringControl = palette0;\r\n                let val = palette.value + ((palette as NumberControl).unit || '');\r\n                if (!val) val = \"''\";\r\n                if (allowLESS) s += \"\\t@\" + paletteName + \": \" + val + ';\\n';\r\n                s += \"\\t--\" + paletteName + ': ' + val + ';\\n';\r\n            }\r\n        }\r\n        s += '\\n\\t' + U.replaceAll(c.data.css, '\\n', '\\n\\t');\r\n        const localViewSelector: string = (c.data.className === 'DViewPoint') ? '.GraphContainer' : '.'+c.data.id; // '[data-viewid=\"'+c.data.id+'\"]';\r\n        s = (!c.data.cssIsGlobal ? localViewSelector : 'body') +' {\\n' + s + '\\n}';\r\n        // not an error, i'm updating directly d-view that is usually wrong, this is to prevent multiple nodes with same view to trigger compile and redux actions\r\n        // count as if it's a derived attribute not really part of the store.\r\n        c.data.css_MUST_RECOMPILE = false;\r\n        return c.data.compiled_css = s;\r\n    }\r\n    set_compiled_css(val: this[\"compiled_css\"], c: Context): boolean {\r\n        Log.exx(\"Do not use setter for this, set it directly in d-object or use view.css.\");\r\n        return false;\r\n    }\r\n\r\n    public palette!: PaletteType;\r\n    __info_of__palette: Info = {type: \"Dictionary<prefix, colors[]>\", txt:\"Specify a set of colors, numbers or text variables to be used in the graphical syntax through css variables.\"}\r\n    get_palette(c: Context): this[\"palette\"] { return c.data.palette; }\r\n    set_palette(val:this[\"palette\"], c: Context): boolean {\r\n        TRANSACTION('update '+this.get_name(c)+'.palette', ()=>{\r\n            SetFieldAction.new(c.data, \"palette\", val, '', false);\r\n            SetFieldAction.new(c.data, \"css_MUST_RECOMPILE\", true, '', false);\r\n        });\r\n    return true; }\r\n\r\n    forceNodeType?: DocString<'component name'>;\r\n    __info_of__forceNodeType: Info = {isGlobal:true, type: \"EGraphElements\", enum: EGraphElements, label:\"force node type\",\r\n        txt:<div>Forces this element to be rendered with your component of choice instead of automatic selection when generated by a &lt;DefaultNode&gt; tag.</div>}\r\n\r\n    zoom!: GraphPoint;\r\n    __info_of__zoom: Info = {todo: true, isNode: true, type: GraphPoint.cname, txt:<div>Zooms in or out the element using css scale.</div>}\r\n    /*\r\n    scalezoomx!: boolean; // whether to resize the element normally using width-height or resize it using zoom-scale css\r\n    __info_of__scalezoomx: Info = {isNode: true, isEdge: false, isEdgePoint: false, txt:<div></div>}\r\n\r\n    scalezoomy!: boolean;\r\n    __info_of__scalezoomy: Info = {isNode: true, isEdge: false, isEdgePoint: false, txt:<div></div>}*/\r\n\r\n    // not persistent, some not shared. deve essere diverso da utente ad utente perchè dipende dal pan e zoom nel grafo dell'utente attuale.\r\n    // facendo pan su grafo html sposti gli elementi, per simulare uno spostamento del grafo e farlo sembrare illimitato.\r\n    // __transient: DViewTransientProperties;\r\n\r\n    appliableToClasses!: string[]; // class names: DModel, DPackage, DAttribute...\r\n    __info_of__appliableToClasses: Info = {isGlobal: true, type: \"EModelElements | EGraphElements\",\r\n        enum: {...EModelElements, ...EGraphElements, cname:\"EModelElements | EGraphElements\"}, label:\"applicable to\",\r\n        txt: <div>Do a low priority match with elements of this type.\r\n            <br/>This is just a shortcut with a lower priority than a OCL match.\r\n            <br/>The same result can be obtained through OCL.</div>}\r\n\r\n    appliableTo!: 'Any'|'Graph'|'GraphVertex'|'Vertex'|'Edge'|'EdgePoint'|'Field';\r\n\r\n    subViews!: LViewElement[];\r\n    __info_of__subViews: Info = {isGlobal: true, hidden: true, type: \"DViewElement[]\", label:\"sub-views\",\r\n        txt:<div>Views that are suggested to render elements contained in the current one with a higher match priority.\r\n            <br/>Like a package view giving priority to a specific Class or Enum view to render his contained Classifiers in a common theme.\r\n            <br/>If you wish to see the subview weight attached to the collection, access view.__raw.subViews instead.</div>}\r\n    get_SubViews(c: Context): this[\"subViews\"] {\r\n        delete c.data.subViews.clonedCounter;\r\n        return Object.keys(c.data.subViews).map( vid => LPointerTargetable.fromPointer(vid) as LViewElement);\r\n    }\r\n    set_SubViews(val: this[\"subViews\"] | GObject, c: Context): boolean {\r\n        let subviewsmap: GObject;\r\n        if (Array.isArray(val)) {\r\n            let ptrsArr = Pointers.fromArr(val);\r\n            subviewsmap = U.objectFromArrayValues(ptrsArr, 1.5);\r\n        } else subviewsmap = val || {};\r\n        SetFieldAction.new(c.data, \"subViews\", subviewsmap, '', true);\r\n        return true; }\r\n\r\n\r\n    setSubViewScore!: (subview: Pack1<LViewElement>, boost?: number | null) => void;\r\n    __info_of__setSubViewScore: Info = {isGlobal: true, hidden: true, type: \"function(ViewElement, numeric_score): void\", txt:<div>Adds, updates or unsets (if boost = null) a subview with his score.</div>}\r\n\r\n    // adds, updates or unsets (if boost = null) a subview with his score.\r\n    get_setSubViewScore(c: Context): ((subview: Pack1<LViewElement>, boost?: number | null) => void) {\r\n        return (subview: Pack1<LViewElement>, boost: number| null = 1.5 ) => {\r\n            let subviews = {...c.data.subViews};\r\n            let ptr = Pointers.from(subview) as Pointer<DViewElement>;\r\n            if (boost !== null) { // set mode\r\n                if (subviews[ptr] === boost) return;\r\n                subviews[ptr] = boost;\r\n            } else {// set mode\r\n                if (subviews[ptr] === undefined) return;\r\n                delete subviews[ptr];\r\n            }\r\n            SetFieldAction.new(c.data, 'subViews',  subviews, '', true);\r\n        };\r\n    }\r\n\r\n\r\n    allSubViews!: LViewElement[];\r\n    __info_of__allSubViews: Info = {type: \"ViewElement[]\", txt: \"recursively get this.subViews.\"}\r\n    get_allSubViews(c: Context): this[\"allSubViews\"] {\r\n        delete c.data.subViews.clonedCounter;\r\n        let arr: Pointer<DViewElement>[] = Object.keys(c.data.subViews);\r\n        let nextarr: Pointer<DViewElement>[] = [];\r\n        let idmap: Dictionary<Pointer, DViewElement> = {};\r\n        let s: DState = store.getState();\r\n        let dview: DViewElement;\r\n        while (arr.length) {\r\n            for (let vid of arr) {\r\n                if (idmap[vid]) continue;\r\n                dview = DPointerTargetable.fromPointer(vid, s);\r\n                if (!dview) continue;\r\n                idmap[vid] = dview;\r\n                U.arrayMergeInPlace(nextarr, Object.keys(dview.subViews));\r\n            }\r\n            arr = nextarr;\r\n            nextarr = [];\r\n        }\r\n        return LPointerTargetable.fromD(Object.values(idmap));\r\n    }\r\n    set_allSubViews(val: this[\"allSubViews\"], c: Context): boolean { return this.wrongAccessMessage(\"cannot call set_allSubViews, it is a derived attribute\"); }\r\n\r\n\r\n    defaultVSize!: GraphSize;\r\n    __info_of__defaultVSize: Info = {isNode:true, type: \"GraphSize\", label:\"default size\", txt: 'starting size of the node'}\r\n\r\n\r\n    adaptWidth!: boolean;\r\n    __info_of__adaptWidth: Info = {isNode:true, type: ShortAttribETypes.EBoolean, label:\"adapt width\",\r\n        txt: 'Whether the element should expand his width to accomodate his own contents.'}\r\n\r\n    adaptHeight!: boolean;\r\n    __info_of__adaptHeight: Info = {isNode:true, type: ShortAttribETypes.EBoolean, label:\"adapt height\",\r\n        txt: 'Whether the element should expand his height to accomodate his own contents.'}\r\n\r\n    draggable!: boolean;\r\n    __info_of__draggable: Info = {isNode: true, type: ShortAttribETypes.EBoolean, txt: 'if the element can be dragged'}\r\n\r\n    resizable!: boolean;\r\n    __info_of__resizable: Info = {isNode: true, type: ShortAttribETypes.EBoolean, txt: 'if the element can be resized'}\r\n\r\n    oclCondition!: string; // ocl selector\r\n    __info_of__oclCondition: Info = {isGlobal: true, hidden:true, label:\"OCL apply condition\", type: \"text\", // TODO: what's the difference with this.query?\r\n        txt: 'OCL Query selector to determine which nodes or model elements should apply this view'}\r\n    protected get_oclCondition(c: Context): this['oclCondition'] {\r\n        return c.data.oclCondition;\r\n    }\r\n    set_oclCondition(val: string, c: Context): boolean {\r\n        val = (val || '').trim();\r\n        if (val === c.data.oclCondition) return true;\r\n        TRANSACTION('change '+this.get_name(c)+'.oclCondition', ()=>{\r\n            SetFieldAction.new(c.data, 'oclCondition', val, '', false);\r\n            SetRootFieldAction.new('VIEWS_RECOMPILE_ocl', c.data.id, '+=', false); // it is pointer, but for transient stuff there is no need to set pointedby's\r\n        })\r\n        return true;\r\n    }\r\n\r\n    jsCondition!: string; // js selector\r\n    __info_of__jsCondition: Info = {isGlobal: true, hidden:true, label:\"js apply condition\", type: \"text\",\r\n        txt: 'js Query selector to determine which nodes or model elements should apply this view'}\r\n    protected get_jsCondition(c: Context): this['jsCondition'] {\r\n        return c.data.jsCondition;\r\n    }\r\n    set_jsCondition(val: string, c: Context): boolean {\r\n        val = (val || '').trim();\r\n        if (val === c.data.jsCondition) return true;\r\n        TRANSACTION('change '+this.get_name(c)+'.jsCondition', ()=>{\r\n            SetFieldAction.new(c.data, 'jsCondition', val, '', false);\r\n            SetRootFieldAction.new('VIEWS_RECOMPILE_jsCondition', c.data.id, '+=', false);\r\n        })\r\n        return true;\r\n    }\r\n\r\n    // todo: how about allowing a view to be part in multiple vp's? so this reference would be an array or removed, and you navigate only from vp to v.\r\n    viewpoint!: LViewPoint;\r\n    __info_of__viewpoint: Info = {hidden: true, type: LViewPoint.cname, txt: <div>The collection of views containing this one, useful to activate multiple views at once.</div>}\r\n\r\n    display!: 'block'|'contents';\r\n    __info_of__display: Info = {obsolete: true, isNode: true, type: ShortAttribETypes.EString,\r\n        txt: 'complete css injection instead'}\r\n\r\n    onDragStart!: string;\r\n    __info_of__onDragStart: Info = {isNode: true, type: \"Function():void\",\r\n        txt: 'Custom event activated when a node begins being dragged.'}\r\n    protected get_onDragStart(c: Context): this['onDragStart'] {\r\n        return c.data.onDragStart;\r\n    }\r\n    protected set_onDragStart(val: this['onDragStart'], c: Context): boolean {\r\n        TRANSACTION('change '+this.get_name(c)+'.onDragStart', ()=>{\r\n            SetFieldAction.new(c.data, 'onDragStart', val, '', false);\r\n            SetRootFieldAction.new('VIEWS_RECOMPILE_onDragStart', c.data.id, '+=', false);\r\n        })\r\n        return true;\r\n    }\r\n\r\n    onDragEnd!: string;\r\n    __info_of__onDragEnd: Info = {isNode: true, type: \"Function():void\",\r\n        txt: 'Custom event activated when a node finishes being dragged.'}\r\n    protected get_onDragEnd(c: Context): this['onDragEnd'] {\r\n        return c.data.onDragEnd;\r\n    }\r\n    protected set_onDragEnd(val: this['onDragEnd'], c: Context): boolean {\r\n        TRANSACTION('change '+this.get_name(c)+'.onDragEnd', ()=>{\r\n            SetFieldAction.new(c.data, 'onDragEnd', val, '', false);\r\n            SetRootFieldAction.new('VIEWS_RECOMPILE_onDragEnd', c.data.id, '+=', false);\r\n        })\r\n        return true;\r\n    }\r\n\r\n    whileDragging!: string;\r\n    __info_of__whileDragging: Info = {isNode: true, type: \"Function():void\",\r\n        txt: 'Custom event activated multiple times when mouse is moved while a node is being dragged.'}\r\n    protected get_whileDragging(c: Context): this['whileDragging'] {\r\n        return c.data.whileDragging;\r\n    }\r\n    protected set_whileDragging(val: this['whileDragging'], c: Context): boolean {\r\n        TRANSACTION('change '+this.get_name(c)+'.whileDragging', ()=>{\r\n            SetFieldAction.new(c.data, 'whileDragging', val, '', false);\r\n            SetRootFieldAction.new('VIEWS_RECOMPILE_whileDragging', c.data.id, '+=', false);\r\n        })\r\n        return true;\r\n    }\r\n\r\n    onResizeStart!: string;\r\n    __info_of__onResizeStart: Info = {isNode: true, type: \"Function():void\",\r\n    txt: 'Custom event activated when a node begins being resized.'}\r\n    protected get_onResizeStart(c: Context): this['onResizeStart'] {\r\n        return c.data.onResizeStart;\r\n    }\r\n    protected set_onResizeStart(val: this['onResizeStart'], c: Context): boolean {\r\n        TRANSACTION('change '+this.get_name(c)+'.onResizeStart', ()=>{\r\n            SetFieldAction.new(c.data, 'onResizeStart', val, '', false);\r\n            SetRootFieldAction.new('VIEWS_RECOMPILE_onResizeStart', c.data.id, '+=', false);\r\n        })\r\n        return true;\r\n    }\r\n\r\n    onResizeEnd!: string;\r\n    __info_of__onResizeEnd: Info = {isNode: true, type: \"Function():void\",\r\n        txt: 'Custom event activated when a node finishes being resized.'}\r\n    protected get_onResizeEnd(c: Context): this['onResizeEnd'] {\r\n        return c.data.onResizeEnd;\r\n    }\r\n    protected set_onResizeEnd(val: this['onResizeEnd'], c: Context): boolean {\r\n        TRANSACTION('change '+this.get_name(c)+'.onResizeEnd', ()=>{\r\n            SetFieldAction.new(c.data, 'onResizeEnd', val, '', false);\r\n            SetRootFieldAction.new('VIEWS_RECOMPILE_onResizeEnd', c.data.id, '+=', false);\r\n        })\r\n        return true;\r\n    }\r\n\r\n    whileResizing!: string;\r\n    __info_of__whileResizing: Info = {isNode: true, type: \"Function():void\",\r\n        txt: 'Custom event activated multiple times when mouse is moved while a node is being resized.'}\r\n    protected get_whileResizing(c: Context): this['whileResizing'] {\r\n        return c.data.whileResizing;\r\n    }\r\n    protected set_whileResizing(val: this['whileResizing'], c: Context): boolean {\r\n        TRANSACTION('change '+this.get_name(c)+'.whileResizing', ()=>{\r\n            SetFieldAction.new(c.data, 'whileResizing', val, '', false);\r\n            SetRootFieldAction.new('VIEWS_RECOMPILE_whileResizing', c.data.id, '+=', false);\r\n        })\r\n        return true;\r\n    }\r\n\r\n    onRotationStart!: string;\r\n    __info_of__onRotationStart: Info = {isNode: true, type: \"Function():void\",\r\n    txt: 'Custom event activated when a node begins being rotated.'}\r\n    protected get_onRotationStart(c: Context): this['onRotationStart'] {\r\n        return c.data.onRotationStart;\r\n    }\r\n    protected set_onRotationStart(val: this['onRotationStart'], c: Context): boolean {\r\n        TRANSACTION('change '+this.get_name(c)+'.onRotationStart', ()=>{\r\n            SetFieldAction.new(c.data, 'onRotationStart', val, '', false);\r\n            SetRootFieldAction.new('VIEWS_RECOMPILE_onRotationStart', c.data.id, '+=', false);\r\n        })\r\n        return true;\r\n    }\r\n\r\n    onRotationEnd!: string;\r\n    __info_of__onRotationEnd: Info = {isNode: true, type: \"Function():void\",\r\n        txt: 'Custom event activated when a node finishes being rotated.'}\r\n    protected get_onRotationEnd(c: Context): this['onRotationEnd'] {\r\n        return c.data.onRotationEnd;\r\n    }\r\n    protected set_onRotationEnd(val: this['onRotationEnd'], c: Context): boolean {\r\n        TRANSACTION('change '+this.get_name(c)+'.onRotationEnd', ()=>{\r\n        SetFieldAction.new(c.data, 'onRotationEnd', val, '', false);\r\n        SetRootFieldAction.new('VIEWS_RECOMPILE_onRotationEnd', c.data.id, '+=', false);\r\n        })\r\n        return true;\r\n    }\r\n\r\n    whileRotating!: string;\r\n    __info_of__whileRotating: Info = {isNode: true, type: \"Function():void\",\r\n        txt: 'Custom event activated multiple times when mouse is moved while a node is being rotated.'}\r\n    protected get_whileRotating(c: Context): this['whileRotating'] {\r\n        return c.data.whileRotating;\r\n    }\r\n    protected set_whileRotating(val: this['whileRotating'], c: Context): boolean {\r\n        TRANSACTION('change '+this.get_name(c)+'.whileRotating', ()=>{\r\n            SetFieldAction.new(c.data, 'whileRotating', val, '', false);\r\n            SetRootFieldAction.new('VIEWS_RECOMPILE_whileRotating', c.data.id, '+=', false);\r\n        })\r\n        return true;\r\n    }\r\n\r\n    onDataUpdate!: string;\r\n    __info_of__onDataUpdate: Info = {isNode: true, type: \"Function():void\",\r\n        txt: 'Custom event activated every time a property of his model, node or view is changed while the element is visibly rendered in a graph.\\n<br>Caution! this might cause loops.'}\r\n    protected get_onDataUpdate(c: Context): this['onDataUpdate'] {\r\n        return c.data.onDataUpdate;\r\n    }\r\n    protected set_onDataUpdate(val: this['onDataUpdate'], c: Context): boolean {\r\n        TRANSACTION('change '+this.get_name(c)+'.onDataUpdate', ()=>{\r\n            SetFieldAction.new(c.data, 'onDataUpdate', val, '', false);\r\n            SetRootFieldAction.new('VIEWS_RECOMPILE_onDataUpdate', c.data.id, '+=', false);\r\n        })\r\n        return true;\r\n    }\r\n\r\n    events!: Dictionary<DocString<\"functionName\">, ((...a:any)=>any)>;\r\n    event!:  Dictionary<DocString<\"functionName\">, ((...a:any)=>any)>;\r\n    __info_of__events: Info = {todo: true, isGlobal: true, type: \"Dictionary<name, function>\",\r\n        txt: <div>Custom events callable through JSX user interaction<br/>eg: &lt;div onClick=&#123;()=&gt;view.eventname()&#125; /&gt;</div>}\r\n    __info_of__event: Info = {todo: true, isGlobal: true, type: \"Dictionary<name, function>\", txt: 'Alias for this.events'}\r\n    protected get_event(c: Context): this['events'] { return this.get_events(c); }\r\n    protected get_events(c: Context): this['events'] {\r\n        Log.exx(\"use node.events instead\", U.getStackTrace());\r\n        return {};\r\n        // return transientProperties.view[c.data.id]?.events || {};\r\n    }\r\n    protected set_events(val: DViewElement[\"events\"], c: Context): boolean {\r\n        const addUD = true;\r\n        TRANSACTION('change '+this.get_name(c)+'.events', ()=> {\r\n            SetFieldAction.new(c.data, 'events', val, '+=', false);\r\n            SetRootFieldAction.new('VIEWS_RECOMPILE_events', {\r\n                vid: c.data.id,\r\n                keys: Object.keys(val)\r\n            }, '+=', false);\r\n            let udstr = c.data.usageDeclarations;\r\n            if (!addUD || !udstr) return;\r\n            let delta = Uobj.objectDelta(c.data.events, val, false);\r\n            for (let key in delta) {\r\n                let v = val[key];\r\n                let autogenstr = 'ret.' + key + ' = node.events.'+key+'; // @autogenerated, do not edit\\n';\r\n                if (!v) udstr = udstr.split(autogenstr).join('');\r\n                else {\r\n                    if (!c.data.events[key]) { // insert\r\n                        let findstr = '// ** declarations here ** //\\n';\r\n                        let insertat = udstr.indexOf(findstr);\r\n                        if (insertat === -1) continue; // malformed ud, will skip\r\n                        insertat += findstr.length;\r\n                        udstr = udstr.substring(0, insertat) + autogenstr + udstr.substring(insertat);\r\n                    } else {\r\n                        // just updated func body, no name changed, no need to update UD.\r\n                    }\r\n                }\r\n            }\r\n            if (udstr === c.data.usageDeclarations) return;\r\n            SetFieldAction.new(c.data, 'usageDeclarations', udstr, '', false);\r\n            SetRootFieldAction.new('VIEWS_RECOMPILE_usageDeclarations', c.data.id, '+=', false);\r\n        })\r\n        return true;\r\n    }\r\n\r\n    constraints!: GObject<\"todo, used in Vertex. they are triggered by events (view.onDragStart....) and can bound the size of the vertex\">[];\r\n    __info_of__constraints: Info = {todo: true, isNode: true, type: \"Function():void\",\r\n        txt: 'not supported yet'}\r\n\r\n\r\n    bendingMode!: EdgeBendingMode;\r\n    __info_of__bendingMode: Info = {isEdge: true, enum: EdgeBendingMode, type: '\"L\" | \"Q\" | \"C\" | \"T\" | \"S\" | \"A\" | \"QT\" | \"CS\"',\r\n        label:\"path mode\",\r\n        txt: <><div>How Svg path should use the EdgePoints to bend his shape{/*<a href={\"https://css-tricks.com/svg-path-syntax-illustrated-guide/\"}>to bend his shape</a>*/}</div></>}\r\n\r\n    edgeGapMode!: EdgeGapMode;\r\n    __info_of__edgeGapMode: Info = {isEdge: true, enum: EdgeGapMode, type: '\"gap\" | \"average\" | \"autoFill\" | \"lineFill\" | \"arcFill\"',\r\n        label:\"gap mode\",\r\n        txt: <><div>How the segment should treat the EdgePoint interruptions.<br/>\"gap\" leaves an empty space to not overlap the EdgePoint,\r\n            <br/>\"linefill\" makes the edge stop at the EdgePoint borders, but then connects the gap with a line.</div></>}\r\n\r\n    /*\r\n    bindVertexSizeToView!: boolean;\r\n    __info_of__bindVertexSizeToView: Info = {isNode:true, type:ShortAttribETypes.EBoolean, label:\"bind sizes to view\",\r\n        txt: <div>Store the vertex size inside the view instead of inside the vertex.\r\n            <br/>This causes the vertex to have different positions according to the view currently appied to it.</div>}*/\r\n    storeSize!: boolean;\r\n    __info_of__storeSize: Info = {isNode: true, type: ShortAttribETypes.EBoolean, label:\"bind sizes to view\",\r\n        txt: \"Active: the node position depends from the view currently displayed.Inactive: it depends from the graph.\"}\r\n\r\n    lazySizeUpdate!: boolean;\r\n    __info_of__lazySizeUpdate: Info = {isNode: true, type: ShortAttribETypes.EBoolean, txt: <div>If true updates the node position only when the drag action is finished. (best performance)</div>}\r\n\r\n    edgeStartOffset!: GraphPoint;\r\n    __info_of__edgeStartOffset: Info = {isEdge: true, type: GraphPoint.cname, label:\"start offset\",\r\n        txt: \"Location where outgoing edges should start their path, relative to top-upper corner of the element.\"}\r\n\r\n    edgeEndOffset!: GraphPoint;\r\n    __info_of__edgeEndOffset: Info = {isEdge: true,  type: GraphPoint.cname, label:\"end offset\",\r\n        txt: 'Same as this.edgeStartOffset'}\r\n\r\n\r\n    edgeStartOffset_isPercentage!: boolean;\r\n    __info_of__edgeStartOffset_isPercentage: Info = {isEdge: true, type:ShortAttribETypes.EBoolean, label:\"start offset is a %\",\r\n        txt: <div>Whether edgeStartOffset is an absolute value or a percentage.<br/>(eg: 50% of element width, vs 50 pixels flat).</div>}\r\n\r\n    edgeEndOffset_isPercentage!: boolean;\r\n    __info_of__edgeEndOffset_isPercentage: Info = {isEdge: true, type:ShortAttribETypes.EBoolean, label:\"end offset is a %\",\r\n        txt: <div>Whether edgeStartOffset is an absolute value or a percentage.<br/>(eg: 50% of element width, vs 50 pixels flat).</div>}\r\n\r\n\r\n    edgeStartStopAtBoundaries!: boolean;\r\n    __info_of__edgeStartStopAtBoundaries: Info = {isEdge: true, type:ShortAttribETypes.EBoolean, label:\"start cannot cross boundaries\",\r\n        txt: <div>Whether outgoing edges should cross the node boundaries overlapping the node\\'s html or stop at them.<br/>Edge arrows might enter the node if this is on.</div>}\r\n\r\n    edgeEndStopAtBoundaries!: boolean;\r\n    __info_of__edgeEndStopAtBoundaries: Info = {isEdge: true, type: ShortAttribETypes.EBoolean, label:\"end cannot cross boundaries\",\r\n        txt: <div>Whether incoming edges should cross the node boundaries overlapping the node\\'s html or stop at them.<br/>Edge arrows might enter the node if this is on.</div>}\r\n\r\n\r\n    edgePointCoordMode!: CoordinateMode;\r\n    __info_of__edgePointCoordMode: Info = {isEdgePoint: true, type: \"CoordinateMode\", enum: CoordinateMode, label:\"coordinate mode\",\r\n        txt:<div>Store coordinates as absolute coordinates or relative to start/end nodes.</div>}\r\n    set_edgePointCoordMode(val: CoordinateMode, c: Context): boolean {\r\n        TRANSACTION('change '+this.get_name(c)+'.edgePointCoordMode', ()=>{\r\n            setTimeout(()=>{ // needs to be done after coordinatemode change is applied\r\n                let s: DState = store.getState();\r\n                for (let nid in transientProperties.node) {\r\n                    let tn = transientProperties.node[nid];\r\n                    if (!tn || tn.mainView?.id !== c.data.id) continue;\r\n                    let lnode: LEdgePoint = LPointerTargetable.fromPointer(nid, s);\r\n                    let triggerCoordinateModeChange = lnode as any;\r\n                    triggerCoordinateModeChange.size = lnode.size;\r\n                }\r\n            }, 100);\r\n            SetFieldAction.new(c.data, 'edgePointCoordMode', val, '', false);\r\n        })\r\n        return true;\r\n    }\r\n\r\n    edgeHeadSize!: GraphPoint;\r\n    __info_of__edgeHeadSize: Info = {isEdge: true, type:GraphPoint.cname, label:\"head decorator size\", txt:<div>Size of the edge head decorator if present.</div>}\r\n\r\n    edgeTailSize!: GraphPoint;\r\n    __info_of__edgeTailSize: Info = {isEdge: true, type:GraphPoint.cname, label:\"tail decorator size\", txt:<div>Size of the tail head decorator if present.</div>}\r\n\r\n    protected size!: Dictionary<Pointer<DModelElement> | Pointer<DGraphElement>, GraphSize>; // use getSize, updateSize;\r\n    __info_of__size: Info = {isNode: true, hidden:true, type: ShortAttribETypes.EInt,\r\n        txt:<div>Do not use directly, contains all the sizes stored in this view. use getSize, updateSize instead.</div>}\r\n\r\n\r\n    __info_of__updateSize: Info = {isNode:true, hidden:true, type:\"Function(Pointer<GraphElement | ModelElement>, GraphSize) => GraphSize\",\r\n        txt:<div>Updates the size stored in this view for target element.<br/>@returns: the delta of the change between old value and new value.</div>}\r\n    __info_of__getSize: Info = {isNode:true, hidden:true, type:\"Function(Pointer<GraphElement | ModelElement>) => GraphSize\",\r\n        txt:<div>Gets the size stored in this view for target element.</div>}\r\n\r\n    // public _parsedConstants!: GObject;\r\n    // public get__parsedConstants(c: Context): this['_parsedConstants'] { return c.data._parsedConstants || {}; }\r\n\r\n    public get_constants(c: Context): this['constants'] {\r\n        return c.data.constants;\r\n    }\r\n\r\n\r\n    public static parseConstants(funcCode?: string): GObject | undefined {\r\n        if (!funcCode) return {};\r\n        let parsedConstants: GObject = {};\r\n        let context: GObject = {__param: parsedConstants};\r\n        context.__proto__ = windoww.defaultContext;\r\n        try{\r\n            let parsedFunc = U.parseFunctionWithContextAndScope(funcCode, context, context, ['ret']);\r\n            parsedFunc(context, parsedConstants);\r\n            // U.evalInContextAndScopeNew( \"(\"+funcCode+\")(this.__param)\", context, true, false, false);\r\n        } catch (e: any) {\r\n            Log.ee(\"Attempted to save an invalid view.constant setup. Cause:\\n\" + e.message.split(\"\\n\")[0], e)\r\n            return undefined;\r\n        }\r\n        return parsedConstants;\r\n    }\r\n\r\n    public set_constants(value: this['constants'], c: Context): boolean {\r\n        if (value === c.data.constants) return true;\r\n        TRANSACTION('change '+this.get_name(c)+'.constants', ()=> {\r\n            SetFieldAction.new(c.data.id, 'constants', value, '', false);\r\n            SetRootFieldAction.new('VIEWS_RECOMPILE_constants', c.data.id, '+=', false);\r\n            SetFieldAction.new(c.data.id, \"css_MUST_RECOMPILE\", true, '', false);\r\n        })\r\n        return true;\r\n    }\r\n\r\n    public get_preRenderFunc(c: Context): this['preRenderFunc'] {\r\n        return c.data.preRenderFunc;\r\n    }\r\n    public set_preRenderFunc(value: this['preRenderFunc'], c: Context): boolean {\r\n        const _value = value ? value : '() => {}';\r\n        return SetFieldAction.new(c.data.id, 'preRenderFunc', _value, '', false);\r\n    }\r\n\r\n    public get_edgeHeadSize(c: Context): this[\"edgeHeadSize\"] { return new GraphPoint(c.data.edgeHeadSize.x, c.data.edgeHeadSize.y); }\r\n    public get_edgeTailSize(c: Context): this[\"edgeTailSize\"] { return new GraphPoint(c.data.edgeTailSize.x, c.data.edgeTailSize.y); }\r\n    public set_edgeHeadSize(v: Partial<this[\"edgeHeadSize\"]>, c: Context): boolean {\r\n        let s = c.data.edgeHeadSize || new GraphPoint(0, 0);\r\n        if (!(\"x\" in v)) v.x = s.x;\r\n        if (!(\"y\" in v)) v.y = s.y;\r\n        if (v.x === s.x && v.y === s.y) return true;\r\n        TRANSACTION('change '+this.get_name(c)+'.edgeHeadSize', ()=>{\r\n            SetFieldAction.new(c.data.id, \"css_MUST_RECOMPILE\", true, '', false);\r\n            SetFieldAction.new(c.data.id, \"edgeHeadSize\", v as GraphPoint, '', false);\r\n        }, `(${s.x}, ${s.y})`, `(${v.x}, ${v.y})`);\r\n        return true; }\r\n    public set_edgeTailSize(v: Partial<this[\"edgeTailSize\"]>, c: Context): boolean {\r\n        let s = c.data.edgeTailSize || new GraphPoint(0, 0);\r\n        if (!(\"x\" in v)) v.x = s.x;\r\n        if (!(\"y\" in v)) v.y = s.y;\r\n        TRANSACTION('change '+this.get_name(c)+'.edgeTailSize', ()=>{\r\n            SetFieldAction.new(c.data.id, \"css_MUST_RECOMPILE\", true, '', false);\r\n            SetFieldAction.new(c.data.id, \"edgeTailSize\", v as GraphPoint, '', false);\r\n        }, `(${s.x}, ${s.y})`, `(${v.x}, ${v.y})`);\r\n        return true;\r\n    }\r\n\r\n    fatherChain!: LViewElement[];\r\n    __info_of__fatherChain: Info = {type: 'LViewElement[]', txt: 'a list of all father elements sorted from the closest to farthest'};\r\n    public get_fatherChain(c: Context): this[\"fatherChain\"] {\r\n        let current = this.get_father(c);\r\n        if (!current) return [] as any;\r\n        let ret: LViewElement[] = [];\r\n        while (current) {\r\n            ret.push(current);\r\n            current = current.father;\r\n        }\r\n        return ret;\r\n    }\r\n    father?: LViewElement;\r\n    public get_father(c: Context): this[\"father\"] {\r\n        return (LViewPoint.fromPointer(c.data.father as Pointer<DViewPoint>));\r\n    }\r\n    public get_viewpoint(c: Context): this[\"viewpoint\"] {\r\n        let p = c.data.father;\r\n        if (!p) return LPointerTargetable.fromD(c.data);\r\n        let curr: LViewElement = LPointerTargetable.fromPointer(p);\r\n        while (curr) {\r\n            let prev = curr.father;\r\n            if (!prev) return curr as LViewPoint;\r\n            curr = prev;\r\n        }\r\n        return undefined as any;\r\n    }\r\n    // public set_subViews(v: Pointer<DViewPoint>[], c: Context): boolean { return this.cannotSet('subViews, call set_viewpoint on the sub-elements instead.'); }\r\n\r\n    // WARNING!! if there are mass vp assignments, preserveOrder=true will cause a vp to \"lose\" subviews and keep only the last assigned.\r\n    public set_viewpoint(v: Pointer<DViewPoint>, c: Context, manualDview?: DViewElement, preserveOrder: boolean = false): boolean {\r\n        Log.exDevv('setViewpoint() should not be called, call view.setFather(viewpoint) instead');\r\n        return true;\r\n    }\r\n    public set_father(v: Pointer<DViewPoint>, c: Context, manualDview?: DViewElement, preserveOrder: boolean = false): boolean {\r\n        let ret = false;\r\n        let pvid: Pointer<DViewPoint> = v && Pointers.from(v);\r\n        const data =  (manualDview || c.data);\r\n        let id = data.id;\r\n        let oldpvid = data.father;\r\n        if (pvid === oldpvid) return true;\r\n        let dfather: DViewElement = (v && typeof v === \"object\") ? ((v as any).__raw || v) as any : DPointerTargetable.fromPointer(pvid);\r\n\r\n        TRANSACTION('change '+this.get_name(c)+'.parent', ()=>{\r\n            ret = SetFieldAction.new(id, \"father\", pvid, '', true);\r\n            if (data.viewpoint !== dfather.viewpoint) SetFieldAction.new(id, \"viewpoint\", dfather.viewpoint, '', true);\r\n            if (oldpvid) {\r\n                let subViews = (DPointerTargetable.fromPointer(oldpvid) as DViewElement).subViews;\r\n                if (id in subViews) {\r\n                    /*subViews = {...subViews};\r\n                    delete subViews[id];*/\r\n                    SetFieldAction.new(oldpvid, \"subViews\", {[id]:'valueispointless'} as any, '-=', true);\r\n                }\r\n            }\r\n            if (pvid) {\r\n                let name = data.name;\r\n                let copyPos = name.indexOf(\"Copy\");\r\n                let oldSubViews = DPointerTargetable.fromPointer(pvid).subViews;\r\n                let insertBefore: string = '';\r\n                let subViews: GObject = {};\r\n                if (copyPos) {\r\n                    let copiedFromName: string = copyPos ? name.substring(0, copyPos).trim() : '';\r\n                    if (copiedFromName in oldSubViews) insertBefore = copiedFromName;\r\n                    else {\r\n                        for (let key in oldSubViews) if (key.indexOf(copiedFromName) === 0) { insertBefore = key; break; }\r\n                    }\r\n                }\r\n\r\n\r\n                // WARNING!! if there are mass vp assignments, this will cause a vp to \"lose\" subviews and keep only the last assigned.\r\n                if (preserveOrder && insertBefore) {\r\n                    subViews = {};\r\n                    for (let key in oldSubViews) {\r\n                        subViews[key] = oldSubViews[key];\r\n                        // just to reinsert subviews **in order** so Object.keys() fits the new subview near the cloned one.\r\n                        if (key === insertBefore) subViews[id] = subViews[insertBefore];\r\n                    }\r\n                } else { subViews = {...oldSubViews}; subViews[id] = 1.5; }\r\n                subViews[id] = insertBefore ? subViews[insertBefore] : 1.5;\r\n                SetFieldAction.new(pvid, \"subViews\", subViews, '+=', true);\r\n            }\r\n        }, c.proxyObject.father?.name, dfather.name || dfather.className)\r\n        return ret;\r\n    }\r\n\r\n\r\n    public get_subViews(c: Context): LViewElement[]{\r\n        let subViewsPointers = c.data.subViews;\r\n        let subViews: LViewElement[] = [];\r\n        for (let pointer in subViewsPointers) {\r\n            let item: LViewElement = MyProxyHandler.wrap(pointer);\r\n            if (item !== undefined) subViews.push(item);\r\n        }\r\n        return subViews;\r\n    }\r\n\r\n    // returns the delta of change\r\n    public updateSize(id: Pointer<DModelElement> | Pointer<DGraphElement>, size: Partial<GraphSize>): boolean { return this.wrongAccessMessage(\"updateSize\"); }\r\n    public get_updateSize(c: Context): this[\"updateSize\"] {\r\n        return (id: Pointer<DModelElement> | Pointer<DGraphElement>, size0: Partial<GraphSize>) => {\r\n            let size: EPSize = size0 as any;\r\n            let vp = c.proxyObject.viewpoint;\r\n            if (!c.data.storeSize) {\r\n                if (vp?.storeSize) return vp.updateSize(id, size);\r\n                return false;\r\n            }\r\n            let vsize: EPSize = (c.data.size[id] || vp?.__raw.size[id]) as EPSize || {} as any;\r\n            let newSize: EPSize = new GraphSize() as EPSize;\r\n            console.log({vsize, newSize, size, vp, d:c.data})\r\n            if (size.currentCoordType === vsize?.currentCoordType) { // if samecoord system mix them.\r\n                newSize.x = size?.x !== undefined ? size.x : vsize.x;\r\n                newSize.y = size?.y !== undefined ? size.y : vsize.y;\r\n            } else if (size.x !== undefined && size.y !== undefined) { // if different coord system pick all of size\r\n                newSize.x = size.x;\r\n                newSize.y = size.y;\r\n                newSize.currentCoordType = size.currentCoordType || CoordinateMode.absolute;\r\n            } else if (vsize.x !== undefined && vsize.y !== undefined) { // or all of vsize if size was invalid\r\n                newSize.x = vsize.x;\r\n                newSize.y = vsize.y;\r\n                newSize.currentCoordType = vsize.currentCoordType || CoordinateMode.absolute;\r\n            }\r\n            let defaultsize = c.data.defaultVSize || vp?.__raw.defaultVSize;\r\n            if (newSize.x === undefined || newSize.y === undefined) { // only if pos is invalid, i take defaultvsize and force to use coord absolute.\r\n                newSize = new GraphSize().clone(defaultsize) as EPSize;\r\n                newSize.currentCoordType = CoordinateMode.absolute;\r\n            }\r\n            // w and h are always absolute so they can be mixed to whathever coordinate mode indipendently from the rest.\r\n            newSize.w = size?.w !== undefined ? size.w : vsize.w;\r\n            newSize.h = size?.h !== undefined ? size.h : vsize.h;\r\n            if (newSize.h === undefined) newSize.h = defaultsize.h || 10;\r\n            if (newSize.w === undefined) newSize.w = defaultsize.w || 10;\r\n\r\n            if (!newSize.equals(vsize)) SetFieldAction.new(c.data.id, \"size.\" + id as any, newSize);\r\n            return true;\r\n        }\r\n    }\r\n\r\n    public get_defaultVSize(c: Context): this[\"defaultVSize\"]{ return c.data.defaultVSize; }\r\n    public getSize(id: Pointer<DModelElement> | Pointer<DGraphElement>): GraphSize | undefined{ return this.wrongAccessMessage(\"getSize\"); }\r\n    public get_getSize(c: Context): ((...a:Parameters<this[\"getSize\"]>)=>ReturnType<LViewElement[\"getSize\"]>) {\r\n        function impl_getSize(id: Pointer<DModelElement> | Pointer<DGraphElement>): ReturnType<LViewElement[\"getSize\"]> {\r\n            if (typeof id === \"object\") id = (id as any).id;\r\n            let view = c.data;\r\n            let ret: GraphSize;\r\n            if (view.storeSize){\r\n                ret = view.size[id];\r\n                if (ret) return ret;\r\n            }\r\n            let vp = c.proxyObject.viewpoint;\r\n            if (vp && view.id !== vp.id && vp.storeSize){\r\n                ret = vp.size[id];\r\n                if (ret) return ret; }\r\n            return undefined;\r\n        }\r\n\r\n        return impl_getSize; }\r\n\r\n    set_generic_entry(c: Context, key: keyof DViewElement, val: any): boolean {\r\n        console.log('set_generic_entry', {c, key, val});\r\n        SetFieldAction.new(c.data, key, val);\r\n        return true;\r\n    }\r\n\r\n    children!: LViewElement[];\r\n    get_children(c: Context): this['children'] { return this.get_subViews(c); }\r\n\r\n\r\n    get_lazySizeUpdate(c: Context): D[\"lazySizeUpdate\"] { return Debug.lightMode || c.data.lazySizeUpdate; }\r\n    set_lazySizeUpdate(val: D[\"lazySizeUpdate\"], c: Context): boolean {\r\n        return Debug.lightMode || this.set_generic_entry(c, 'lazySizeUpdate', val);\r\n    }\r\n\r\n    get_bendingMode(c: Context): D[\"bendingMode\"] { return c.data.bendingMode; }\r\n    set_bendingMode(val: D[\"bendingMode\"], c: Context): boolean {\r\n        return this.set_generic_entry(c, 'bendingMode', val);\r\n    }\r\n\r\n    set_appliableTo(val: this[\"appliableTo\"], c: Context): boolean { // appliableTo >= forcenodetype\r\n        if (!val) val = 'Any';\r\n        let forceNodeType: string = c.data.forceNodeType as string;\r\n        if (forceNodeType !== val) switch(val) {\r\n            // case \"Any\": break;\r\n            default: forceNodeType = val;\r\n        }\r\n\r\n        console.log(\"set_appliableTo\", {forceNodeType, val});\r\n        TRANSACTION('change '+this.get_name(c)+'.appliableTo', ()=>{\r\n            if (forceNodeType !== c.data.forceNodeType) SetFieldAction.new(c.data, \"forceNodeType\", forceNodeType, '', false);\r\n            SetFieldAction.new(c.data, \"appliableTo\", val, '', false);\r\n        })\r\n        return true;\r\n    }\r\n    set_forceNodeType(val: this[\"forceNodeType\"], c: Context): boolean {\r\n        if (!val) val = 'Any';\r\n        /*let appliableTo: string = c.data.appliableTo as string;\r\n        if (appliableTo !== val) switch (appliableTo){\r\n            case undefined: case 'Any': break;\r\n            //case 'GraphVertex': if ((appliableTo as any) !== 'Graph' && (appliableTo as any) !== 'Vertex') appliableTo = val; break;\r\n            default: appliableTo = val; break;\r\n        }*/\r\n\r\n        TRANSACTION('change '+this.get_name(c)+'.forceNodeType', ()=>{\r\n            // if (appliableTo !== c.data.appliableTo) SetFieldAction.new(c.data, \"appliableTo\", appliableTo, '', false);\r\n            SetFieldAction.new(c.data, \"forceNodeType\", val, '', false);\r\n        }, c.data.forceNodeType, val)\r\n        return true;\r\n    }\r\n    get_appliableToClasses(c: Context): this[\"appliableToClasses\"] { return c.data.appliableToClasses || []; }\r\n    set_appliableToClasses(val: this[\"appliableToClasses\"], c: Context): boolean {\r\n        if (!val) val = [];\r\n        else if (!Array.isArray(val)) val = [val];\r\n        val.sort();\r\n        let hasChanged: boolean;\r\n        if (val.length === c.data.appliableToClasses?.length) {\r\n            hasChanged = false;\r\n            for (let i = 0; i < val.length; i++) if (val[i] !== c.data.appliableToClasses[i]) { hasChanged = true; break; }\r\n        } else hasChanged = true;\r\n\r\n        if (!hasChanged) return true;\r\n        TRANSACTION('change '+this.get_name(c)+'.appliableToClasses', ()=>{\r\n            this.set_generic_entry(c, \"appliableToClasses\", val);\r\n            SetRootFieldAction.new('VIEWS_RECOMPILE_preconditions', c.data.id, '+=', false);\r\n        })\r\n        return true;\r\n    }\r\n\r\n    set_defaultVSize(val: GraphSize, c: Context): boolean{\r\n        if (!val || typeof val !== \"object\") return true;\r\n        let x = val.x ?? +val.x;\r\n        let y = val.y ?? +val.y;\r\n        let w = val.w ?? +val.w;\r\n        let h = val.h ?? +val.h;\r\n        if (isNaN(x)) x = c.data.defaultVSize.x;\r\n        if (isNaN(y)) y = c.data.defaultVSize.y;\r\n        if (isNaN(w)) w = c.data.defaultVSize.w;\r\n        if (isNaN(h)) h = c.data.defaultVSize.h;\r\n        if (x === c.data.defaultVSize.x && y === c.data.defaultVSize.y && w === c.data.defaultVSize.w && h === c.data.defaultVSize.h) return true;\r\n        SetFieldAction.new(c.data, 'defaultVSize', {x, y, w, h} as any, '', false);\r\n        return true\r\n    }\r\n\r\n\r\n    public duplicate(deep: boolean = true, new_vp?: DuplicateVPChange): this {\r\n        return this.wrongAccessMessage( (this.constructor as typeof RuntimeAccessibleClass).cname + \"duplicate()\"); }\r\n    /*protected*/ get_duplicate(c: Context): ((deep?: boolean, new_vp?: DuplicateVPChange) => LViewElement) {\r\n        return (deep: boolean = false, new_vp0?: DuplicateVPChange) => {\r\n            let lview: LViewElement = undefined as any;\r\n            let state: DState = store.getState();\r\n            TRANSACTION('duplicate ' + this.get_name(c), () => {\r\n                // let pvid: Pointer<DViewPoint> = c.data.viewpoint as Pointer<DViewPoint>;\r\n                let pvid: Pointer<DViewPoint> = c.data.father as Pointer<DViewPoint>;\r\n                const new_vp: DuplicateVPChange = new_vp0 || {pvid};\r\n                const dfather = DPointerTargetable.fromPointer(new_vp.pvid);\r\n                console.log(\"DViewelement.duplicate\", {cn: c.data.className, n:c.data.name, deep, new_vp0, dfather});\r\n                const dclone: DViewElement = c.data.className === 'DViewPoint' ?\r\n                    DViewPoint.newVP(`${c.data.name} Copy`) :\r\n                    DViewElement.new2(`${c.data.name} Copy`, '', dfather,\r\n                        undefined, true);\r\n                // todo: test if this have correct parent, vp and pointedby\r\n                lview = LPointerTargetable.fromD(dclone);\r\n                // || {pvid,  score: (DPointerTargetable.from(pvid, state) as DViewElement).subViews[c.data.id]}\r\n\r\n                for (let key in c.data) {\r\n                    switch (key) {\r\n                        case 'subViews':\r\n                            // duplicate childrens only if deep\r\n                            if (!deep) break;\r\n                            // let subviews: Dictionary<Pointer, number> = {}\r\n                            for (const oldvid in c.data.subViews) {\r\n                                const oldScore = c.data.subViews[oldvid];\r\n                                (LPointerTargetable.fromPointer(oldvid, state) as LViewElement).duplicate(deep, {pvid:dclone.id/*, score:oldScore*/});\r\n                                // then everything is set inside case 'viewpoint' of subviews cloning\r\n                            }\r\n                            //lview.subViews = subviews as any;\r\n                            break;\r\n                        case 'compiled_css':\r\n                        case 'longestLabel': case 'labels': break;\r\n                        case 'father':\r\n                            // already set in DViewElement.new2()\r\n                            //console.log('set_father', {thiss:dclone.id, cdata:c.data.id, father:new_vp.pvid});\r\n                            //this.set_father(new_vp.pvid, undefined as any, dclone, !deep);\r\n                            break;\r\n                        case 'viewpoint':\r\n                            // update parent view\r\n                            /*\r\n                            let subviews: Dictionary<Pointer, number> = {};\r\n                            subviews[dclone.id] = new_vp.score;\r\n                            SetFieldAction.new(new_vp.pvid, 'subViews', subviews, '+=', true);\r\n                            SetFieldAction.new(dclone.id, 'viewpoint', new_vp.pvid, '+=', true);*/\r\n                            // insert in-place right after the cloned view, with old score.\r\n                            //this.set_viewpoint(new_vp.pvid, undefined as any, dclone, !deep);\r\n                            // SetFieldAction.new(dclone.id, 'father', new_vp.vpid, '+=', true);\r\n                            break;\r\n                        case '':\r\n                        case 'id':\r\n                        case 'name':\r\n                        case 'className':\r\n                        case 'pointedBy':\r\n                        case '_storePath':\r\n                        case '_subMaps':\r\n                        case 'clonedCounter': break;\r\n                        case 'css_MUST_RECOMPILE': break;\r\n                        case 'isValidation':\r\n                            console.log(\"duplicate \" + c.data.name + \" set isvalidation\", {data:c.data, iv:c.data.isValidation});\r\n                            (lview as any)[key] = (c.data as any)[key];\r\n                            break;\r\n                        default:\r\n                            if (key.includes('RECOMPILE')) break;\r\n                            try {\r\n                                let v: any = (c.data as any)[key];\r\n                                if (typeof v === 'object') v = (Array.isArray(v) ? [...v] : {...v});\r\n                                (lview as any)[key] = v;\r\n                            } catch(e) {\r\n                            //    Log.ee('Error on duplicate view:', e);\r\n                            }\r\n                    }\r\n                }\r\n\r\n                // insert in viewpoint.subview\r\n                //let defaultViews: Dictionary<Pointer, boolean> = Defaults.defaultViewsMap;\r\n                let vp: LViewPoint = c.proxyObject.viewpoint;\r\n                // let oldViews: Pointer<DViewElement>[] = Object.keys(vp.__raw.subViews);\r\n                // if (Defaults.viewpoints.indexOf(vpid)) oldViews = oldViews.filter( vid => !defaultViews[vid]);\r\n                // let i: number = oldViews.indexOf(c.data.id);\r\n                /*\r\n                if (i === -1) oldViews.push(dclone.id);\r\n                else oldViews.splice(i+1, 0, dclone.id); // insert in-place right after the cloned view\r\n                vp.subViews = oldViews as any;*/\r\n                // SetRootFieldAction.new('stackViews', dview.id, '+=', true);\r\n\r\n\r\n                const isVP = c.data.className === 'DViewPoint';\r\n                if (isVP) SetRootFieldAction.new(`viewpoints`, c.data.id, '+=', true);\r\n                else SetRootFieldAction.new(`viewelements`, c.data.id, '+=', true);\r\n                for (let key of DViewElement.RecompileKeys) SetRootFieldAction.new(`VIEWS_RECOMPILE_${key}`, c.data.id, '+=', false);\r\n            })\r\n            return lview;\r\n        }\r\n    }\r\n}\r\nRuntimeAccessibleClass.set_extend(DPointerTargetable, DViewElement);\r\nRuntimeAccessibleClass.set_extend(LPointerTargetable, LViewElement);\r\n\r\ntype DuplicateVPChange = {\r\n    pvid: Pointer<DViewElement>,\r\n    // score: number //unused\r\n}\r\nexport type WViewElement = getWParams<LViewElement, DPointerTargetable>;\r\n\r\n@RuntimeAccessible('DViewTransientProperties')\r\nexport class DViewTransientProperties extends RuntimeAccessibleClass{\r\n    static logic: typeof LPointerTargetable;\r\n    _isDViewTransientProperties!: true;\r\n    // isSelected: Dictionary<DocString<Pointer<DUser>>, boolean> = {};\r\n    // private: DViewPrivateTransientProperties;\r\n}\r\n\r\nRuntimeAccessibleClass.set_extend(RuntimeAccessibleClass, DViewTransientProperties);\r\n@RuntimeAccessible('LViewTransientProperties')\r\nexport class LViewTransientProperties extends LPointerTargetable{\r\n    static structure: typeof DPointerTargetable;\r\n    static singleton: LViewTransientProperties;\r\n    _isLViewTransientProperties!: true;\r\n\r\n    // isSelected: Dictionary<DocString<Pointer<DUser>>, boolean> = {};\r\n    // private!: LViewPrivateTransientProperties;\r\n    /*\r\n        get_private(c: LogicContext<DViewTransientProperties>): LViewPrivateTransientProperties {\r\n            return LViewTransientProperties.wrap(c.data.private, c.proxy.baseObjInLookup, c.proxy.additionalPath + '.private'); }*/\r\n    /*\r\n        get_isSelected(logicContext: LogicContext<TargetableProxyHandler<DViewTransientProperties>, DViewTransientProperties>): Proxyfied<Dictionary> {\r\n            // @ts-ignore for $ at end of getpath\r\n            console.log('GET_ISSELECTED handler func');\r\n            return TargetableProxyHandler.getMap(logicContext.data.isSelected, logicContext, logicContext.proxy.additionalPath + '.' + (getPath as this).isSelected.$);\r\n        }*/\r\n}\r\n\r\nRuntimeAccessibleClass.set_extend(DPointerTargetable, DViewTransientProperties);\r\nRuntimeAccessibleClass.set_extend(LPointerTargetable, LViewTransientProperties);\r\nexport type WViewTransientProperties = getWParams<LViewTransientProperties, DViewTransientProperties>;\r\n\r\n/*\r\n\r\n@RuntimeAccessible\r\nexport class DViewPrivateTransientProperties extends DPointerTargetable{\r\n    static logic: typeof LViewPrivateTransientProperties;\r\n\r\n    public size: GraphSize\r\n    constructor(size?: GraphSize) {\r\n        super();\r\n        this.size = size || defaultVSize;\r\n    }\r\n}\r\n\r\n@RuntimeAccessible\r\nexport class LViewPrivateTransientProperties extends DViewPrivateTransientProperties{\r\n    static structure: typeof DViewPrivateTransientProperties;\r\n    static singleton: LViewPrivateTransientProperties;\r\n\r\n}*/\r\n// shapeless component, receive jsx from redux\r\n// can access any of the redux state, but will usually access 1-2 var among many,\r\n// how can i dynamically mapStateToProps to map only the required ones?\r\n\r\n","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\model\\logicWrapper\\LModelElement.tsx",["1243","1244","1245","1246","1247","1248","1249","1250","1251","1252","1253","1254","1255","1256","1257","1258","1259","1260","1261","1262","1263","1264","1265","1266","1267","1268","1269","1270","1271","1272","1273","1274","1275","1276","1277","1278","1279","1280","1281","1282","1283","1284","1285","1286","1287","1288","1289","1290","1291","1292","1293","1294","1295","1296","1297","1298","1299","1300","1301","1302","1303","1304","1305","1306","1307","1308","1309","1310","1311","1312"],"import {\r\n    LVoidVertex,\r\n    PackagePointers,\r\n    EdgePointers,\r\n    AnnotationPointers,\r\n    AttributePointers,\r\n    EnumPointers,\r\n    LiteralPointers,\r\n    OperationPointers,\r\n    ObjectPointers,\r\n    GraphPointers,\r\n    ParameterPointers,\r\n    ReferencePointers,\r\n    VertexPointers,\r\n    ModelPointers,\r\n    LtoD,\r\n    LVertex, LEdgePoint, LGraph, MultiSelectOptGroup, UX, Function2, Any, MultiSelectOption, windoww, Uobj,\r\n} from \"../../joiner\";\r\nimport {\r\n    Abstract,\r\n    ClassPointers,\r\n    Constructor,\r\n    Constructors,\r\n    Debug,\r\n    DEdge, DefaultNode,\r\n    Dictionary,\r\n    DocString,\r\n    DPointerTargetable,\r\n    DState,\r\n    DtoL,\r\n    getWParams,\r\n    GObject,\r\n    GraphSize,\r\n    Instantiable,\r\n    Leaf,\r\n    LEdge,\r\n    LGraphElement,\r\n    Log,\r\n    LogicContext,\r\n    LPointerTargetable,\r\n    Node,\r\n    Pack,\r\n    Pack1,\r\n    PackArr,\r\n    PointedBy,\r\n    Pointer,\r\n    Pointers,\r\n    RuntimeAccessible,\r\n    RuntimeAccessibleClass,\r\n    Selectors,\r\n    SetFieldAction, SetRootFieldAction,\r\n    ShortAttribETypes,\r\n    ShortAttribSuperTypes,\r\n    store,\r\n    TargetableProxyHandler,\r\n    L,\r\n    TRANSACTION,\r\n    U, Uarr\r\n} from \"../../joiner\";\r\nimport type {Info, Json, ObjectWithoutPointers, orArr, PrimitiveType, unArr} from \"../../joiner/types\";\r\n\r\nimport {\r\n    AccessModifier,\r\n    ECoreAnnotation,\r\n    ECoreAttribute,\r\n    ECoreClass,\r\n    ECoreEnum,\r\n    EcoreLiteral,\r\n    ECoreOperation,\r\n    ECorePackage,\r\n    EcoreParser,\r\n    ECoreReference,\r\n    ECoreRoot\r\n} from \"../../api/data\";\r\nimport {ValuePointers} from \"./PointerDefinitions\";\r\nimport {ShortDefaultEClasses} from \"../../common/U\";\r\nimport {transientProperties} from \"../../joiner/classes\";\r\nimport React, {ReactNode} from \"react\";\r\n\r\ntype outactions = {clear:(()=>void)[], set:(()=>void)[], immediatefire?: boolean};\r\n\r\n\r\n@Node\r\n@RuntimeAccessible('DModelElement')\r\nexport class DModelElement extends DPointerTargetable {\r\n    // static _super = DPointerTargetable;\r\n    // static logic: typeof LModelElement;\r\n    // static structure: typeof DModelElement;\r\n    // static singleton: LModelElement;\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n\r\n    id!: Pointer<DModelElement, 1, 1, LModelElement>;\r\n    parent: Pointer<DModelElement, 0, 'N', LModelElement> = [];\r\n    father!: Pointer<DModelElement, 1, 1, LModelElement>;\r\n    annotations: Pointer<DAnnotation, 0, 'N', LAnnotation> = [];\r\n    // instances: Pointer<DModelElement, 0, 'N', LModelElement> = [];\r\n\r\n    public static new(): DModelElement {\r\n        Log.exx(\"DModelElement is abstract, cannot instantiate\");\r\n        return null as any;\r\n        //return new Constructors(new DModelElement('dwc')).DPointerTargetable().DModelElement().end();\r\n    }\r\n    public static new3(...a:any): DModelElement {\r\n        Log.exx(\"DModelElement is abstract, cannot instantiate\");\r\n        return null as any; }\r\n\r\n    static LFromHtml(target?: Element | null): LModelElement | undefined { return LPointerTargetable.fromPointer(DModelElement.PtrFromHtml(target) as Pointer); }\r\n    static DFromHtml(target?: Element | null): DModelElement | undefined { return DPointerTargetable.fromPointer(DModelElement.PtrFromHtml(target) as Pointer); }\r\n    static PtrFromHtml(target?: Element | null): Pointer<DModelElement> | undefined {\r\n        while (target) {\r\n            if ((target.attributes as any).dataid) return (target.attributes as any).dataid.value;\r\n            target = target.parentElement;\r\n        }\r\n        return undefined;\r\n    }\r\n}\r\n\r\n@Leaf\r\n@RuntimeAccessible('DAnnotationDetail')\r\nexport class DAnnotationDetail extends DPointerTargetable {\r\n    // todo\r\n}\r\n\r\n\r\n\r\n@Abstract\r\n@RuntimeAccessible('LModelElement')\r\nexport class LModelElement<Context extends LogicContext<DModelElement> = any, D extends DModelElement = DModelElement> extends LPointerTargetable {\r\n    // extends Mixin(DModelElement0, LPointerTargetable)\r\n    // static logic: typeof LModelElement;\r\n    // static structure: typeof DModelElement;\r\n\r\n    /* Alfonso */\r\n    static singleton: LModelElement;\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    /*static ResolvePointer = resolvePointerFunction;\r\n    private static ResolvePointers? = resolvePointersFunction;\r\n    private resolvePointer<T extends DPointerTargetable = DPointerTargetable, LB extends number = 0, UB extends number = 0, RET extends LPointerTargetable = LPointerTargetable>(ptr: Pointer<T, LB, UB, RET>): RET | null {\r\n        return LModelElement.ResolvePointer(ptr); }\r\n    private resolvePointers<T extends DPointerTargetable = DPointerTargetable, LB extends number = 0, RET extends LPointerTargetable = LPointerTargetable>(ptr: Pointer<T, LB, 'N', RET>)\r\n        : (RET | null)[] { return resolvePointersFunction(ptr); }\r\n    */\r\n    public __raw!: DModelElement;\r\n    id!: Pointer<DModelElement, 1, 1, LModelElement>;\r\n    parent!: LModelElement[];\r\n    father!: LModelElement; // annotations can be children of everything. except them fathers are: Model, Package, Classifier(class+enum), Operation\r\n\r\n    private __info_of__father = {type: \"LModelElement\", txt:\"<a href=\\\"https://github.com/DamianoNaraku/jodel-react/wiki/LModelElement\\\"><span>The element containing this object.</span></a>\"};\r\n    public fatherList!: LModelElement[]; // chain of fathers going up recursively\r\n    annotations!: LAnnotation[];\r\n    children!: (LPackage | LClassifier | LTypedElement | LAnnotation | LObject | LValue)[];\r\n    __info_of__children__: Info = {type: \"LModelElement[]\", txt: <div>Merging of all the subelement collections (attributes, references, parameters...) except annotations</div>}\r\n    nodes!: LGraphElement[];\r\n    node!: LGraphElement | undefined;\r\n\r\n    // utilities to go up in the tree (singular names)\r\n    model!: LModel; // utility, follow father chain until get a Model parent or null\r\n    package!: LPackage | null;\r\n    class!: LClass | null;\r\n    enum!: LEnumerator | null;\r\n    operation!: LOperation | null;\r\n    subNodes!: LGraphElement[] | null;\r\n\r\n\r\n    property!: keyof DModelElement;\r\n    containers!: LNamedElement[]; // list of fathers until the model is reached.\r\n    //name?:string;\r\n\r\n\r\n    [key: `@${string}`]: LModelElement;\r\n    [key: `$${string}`]: LModelElement;\r\n\r\n    // protected _defaultGetter(c: Context, k: keyof Context[\"data\"]): any {}\r\n\r\n    protected _defaultGetter(c: Context, k: keyof any): any {\r\n        let targetObj = c.data;\r\n        let proxyitself = c.proxyObject;\r\n        // if not exist check for children names\r\n        if (typeof k === \"string\" && k !== \"children\" && (!(k in c.data) && !(k in this))) { // __info_of_children__\r\n            let lchildren: LPointerTargetable[];\r\n            try { lchildren = this.get_children(c); }\r\n            catch (e) { lchildren = []; }\r\n            // let dchildren: DPointerTargetable[] = lchildren.map<DPointerTargetable>(l => l.__raw as any);\r\n            let lc: GObject;\r\n            let pk: string;\r\n            if (TargetableProxyHandler.childKeys[k[0]]) { pk = k.substring(1); }\r\n            else pk = k;\r\n            if (Array.isArray(lchildren)) for (lc of lchildren) {\r\n                let n = lc?.name;\r\n                if (n && n.toLowerCase() === pk.toLowerCase()) return lc;\r\n            }\r\n        }\r\n        return super.__defaultGetter(c, k);\r\n    }\r\n\r\n    // this one must return true or the js engine throws an exception\r\n    protected _defaultSetter(val: any, c: GObject<Context>, k: string): true {\r\n        if (this._setterFor$stuff_canReturnFalse(val, c as any, k as any)) return true;\r\n        super._defaultSetter(val, c as any, k);\r\n        return true;\r\n    }\r\n    // this one must be able to return false because is called by DObject and DValue default setters and return type is checked\r\n    protected _setterFor$stuff_canReturnFalse(val: any, c: Context, k: keyof Context[\"data\"] & string): boolean {\r\n        // if (![\"@\", \"$\"].includes(k[0])) return false;\r\n        if (!TargetableProxyHandler.childKeys[k[0]]) return false;\r\n        let target: LPointerTargetable = (c.proxyObject as GObject)[k];\r\n        if (!target) return false;\r\n        let l;\r\n        let tClassName: string = target.className;\r\n\r\n        // messanger classNames (pass it to next sublevel)\r\n        navigationloop: while(true) {\r\n            switch (tClassName) {\r\n                default: break navigationloop;\r\n                case DPackage.cname:\r\n                case DClass.cname:\r\n                case DEnumerator.cname:\r\n                case DObject.cname:\r\n                    target = (target as LModelElement).children[0]; continue navigationloop;\r\n            }\r\n        }\r\n\r\n        // actiong classNames\r\n        switch (tClassName) {\r\n            default: Log.exx(\"default setter not supported for model element: \" + c.data.className, {c, k, val, target}); return false;\r\n            case DEnumLiteral.cname:\r\n                l = target as LEnumLiteral;\r\n                switch (typeof val){\r\n                    default: return false;\r\n                    case \"string\": l.literal = val; return true;\r\n                    case \"number\": l.ordinal = val; return true;\r\n                }\r\n                return false;\r\n            case DValue.cname:\r\n                // makes object.$x = 1      be equivalent to object.$x.value = 1 (or values if is arr)\r\n                l = target as LValue;\r\n                l.values = val;\r\n                return true;\r\n        }\r\n    }\r\n\r\n    fullname!:string;\r\n    protected get_fullName(context: Context): this[\"fullname\"] { return this.get_fullname(context); }\r\n    protected get_fullname(context: Context): this[\"fullname\"] {\r\n        const containers = this.get_containers(context).reverse();\r\n        // let sliceindex = (containers[0] as LModel).dependencies.length ? 1 : 0;\r\n        let fullname: string = containers.slice(0, containers.length).map(c => c.name).join('.');\r\n        return fullname;\r\n    }\r\n\r\n\r\n    protected _autofix_name(val: string, context: Context): string {\r\n        // NB: NON fare autofix di univocità nome tra i children o qualsiasi cosa dipendente dal contesto, questo potrebbe essere valido in alcuni modelli e invalido in altri e modificare un oggetto condiviso.\r\n        return val.replaceAll(/\\s/g, '_');\r\n    }\r\n\r\n    protected get_autofix_name(val: string, context: Context): (val: string) => string {\r\n        return (val: string) => this._autofix_name(val, context);\r\n    }\r\n\r\n    public autofix_name(val: string): string {\r\n        return this.wrongAccessMessage(\"autofix_name\");\r\n    }\r\n\r\n    public static M1Classes = ['DModel', 'DObject', 'DValue']; // Dstrudturalfeature in shapeless obj??\r\n    public static AbstractClasses = ['DModelElement', 'DNamedElement', '...'];\r\n    public static M2InstantiableClasses = ['DModel', 'DOperation', 'DClass', 'DReference', 'DAttribute'];\r\n    isM1!: (()=>boolean);\r\n    __info_of__isM1: Info = {type:'()=>boolean', txt:<div>Whether the element belong to the metamodel or the model.</div>}\r\n    get_isM1(c: Context): ()=>boolean {\r\n        // NB: if called with \"abstract classes\" like DModelElement, DTypedElement... responds they are in m2\r\n        return (() => (!(c.data as DModel).isMetamodel && LModelElement.M1Classes.includes(c.data.className)));\r\n    }\r\n    isM2!: (()=>boolean);\r\n    __info_of__isM2: Info = {type:'()=>boolean', txt:<div>Whether the element belong to the metamodel or the model.</div>}\r\n    get_isM2(c: Context): ()=>boolean { return (() => !(this.get_isM1(c))); }\r\n\r\n    isInstantiable!: boolean;\r\n    instantiable!: boolean;\r\n    __info_of__isInstantiable: Info = {type:'boolean', txt:<div>Whether the element type (DClass, DAttribute...) can produce an instance in the model.</div>}\r\n    get_isInstantiable(c: Context): boolean { return this.get_instantiable(c); }\r\n     get_instantiable(c: Context): boolean { return LModelElement.M2InstantiableClasses.includes(c.data.className); }\r\n\r\n    childNames!: string[];\r\n    __info_of__childNames: Info = {type: \"(json: object, instanceof?: LClass) => LObject\", txt: \"Array containing the names of all children subelements.\"};\r\n    get_childNames(c: Context): string[] { return this.get_children(c).map( (c: GObject<LModelElement>) => c.name).filter(c=>!!c) as string[]; }\r\n\r\n    public generateEcoreJson(loopDetectionloopDetectionObj: Dictionary<Pointer, DModelElement> = {}): Json {\r\n        throw new Error(\"cannot be called directly, should trigger getter. this is only for correct signature\");\r\n    }\r\n\r\n    private get_generateEcoreJson(context: Context): (loopdetectionobj: Dictionary<Pointer, DModelElement>) => Json {\r\n        return (loopdetectionobj) => this.generateEcoreJson_impl(context, loopdetectionobj);\r\n    }\r\n\r\n    protected generateEcoreJson_impl(context: Context, loopDetectionObj?: Dictionary<Pointer, DModelElement>): Json {\r\n        return Log.exDevv(\"generateEcoreJson() should be overridden\", context);\r\n    }\r\n\r\n    public duplicate(deep: boolean = true): this {\r\n        return this.cannotCall(((this.constructor as typeof RuntimeAccessibleClass).cname || this.constructor.name) + \"duplicate() class is abstract\");\r\n    }\r\n\r\n    public addAnnotation(source?: DAnnotation[\"source\"], details?: DAnnotation[\"details\"]): DAnnotation {\r\n        return this.cannotCall(\"addAnnotation\");\r\n    }\r\n\r\n    protected get_addAnnotation(context: Context): this[\"addAnnotation\"] {\r\n        return (source?: DAnnotation[\"source\"], details?: DAnnotation[\"details\"]) => DAnnotation.new(source, details, context.data.id, true);\r\n    }\r\n\r\n    protected set_containers(): boolean {\r\n        return this.cannotSet('containers');\r\n    }\r\n\r\n    protected get_containers(context: Context): LModelElement[\"containers\"] {\r\n        let thiss: LModelElement = context.proxyObject;\r\n        const ret: LModelElement[] = [thiss];\r\n        while (true) {\r\n            thiss = thiss.father;\r\n            if (!thiss) break;\r\n            ret.push(thiss);\r\n        }\r\n        return ret as LNamedElement[];\r\n    }\r\n\r\n\r\n    protected get_namespace(context: Context): string {\r\n        throw new Error(\"?? get namespace ?? todo\");\r\n        return \"\";\r\n    }\r\n\r\n    protected get_subNodes(context: LogicContext<LClass>, includingthis: boolean = false): LGraphElement[] {\r\n        const lclass: LClass = context.proxyObject as any;\r\n        let $class = $('[data-dataid=\"' + context.data.id + '\"]');\r\n        let $subnodes = $class.find('[data-nodeid]');\r\n\r\n        function mapfunc(this: HTMLElement) {\r\n            return this.dataset.nodeid;\r\n        }\r\n\r\n        let nodehtmlarr: HTMLElement[] = $subnodes.toArray();\r\n        if (includingthis) nodehtmlarr.push($class[0]);\r\n        let nodeidarr: string[] = nodehtmlarr.map((html: HTMLElement) => html.dataset.nodeid) as string[];\r\n        let state = store.getState();\r\n        let dnodes = nodeidarr.map(id => state.idlookup[id]).filter((d) => !!d);\r\n        return dnodes.map(d => LPointerTargetable.wrap(d)) as any;\r\n    }\r\n\r\n\r\n    // name -> redux (es. DClass -> classs)\r\n    protected get_property(context: Context): this[\"property\"] {\r\n        return (context.data.className.substring(1) + \"s\").toLowerCase() as any;\r\n    }\r\n\r\n    protected targetRemoved(context: Context, field: keyof DPointerTargetable): void {\r\n        context.proxyObject.delete();\r\n    }\r\n\r\n\r\n    protected get_fatherList(context: Context): LModelElement[] {\r\n        let ret: LModelElement[] = [context.proxyObject];\r\n        let loopdetection: Dictionary<Pointer, boolean> = {};\r\n        loopdetection[context.data.id] = true;\r\n        let current = this.get_father(context);\r\n        while (current) {\r\n            if (loopdetection[current.id]) { console.error(\"found loop\", {loopdetection, ret, current}); return ret; }\r\n            loopdetection[current.id] = true;\r\n            ret.push(current);\r\n            current = current.father;\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    // @ts-ignore\r\n    private get_until_parent<D extends Constructor, L extends DtoL<InstanceType<D>>>(l: LModelElement, d: DModelElement, father: typeof D): L | null {\r\n        while (true) {\r\n            // console.log('get_until_parent', {l, d, father}, {dname: d.className, fname: father.name});\r\n            if (d.className === (father.cname || father.name)) return l as L;\r\n            l = l.father;\r\n            let oldd = d;\r\n            d = l?.__raw;\r\n            if (oldd === d || !l) return null; // reached end of father chain (a model) without finding the desired parent.\r\n        }\r\n    }\r\n\r\n    __info_of__nodes:Info={type: 'LGraphElement[]', txt: \"Return all kind of graphic elements representing this modelElement currently displayed in the graph, including edges\"};\r\n    protected get_nodes(context: Context): this[\"nodes\"] {\r\n        return Object.values(transientProperties.modelElement[context.data.id]?.nodes || {}).filter(n=>n&&n.html);/*\r\n        const nodes: LGraphElement[] = [];\r\n        const nodeElements = $('[data-dataid=\"' + context.data.id + '\"]'); nope, this must become more efficient. when node is created set action to update data.nodes array? or to update a transient property (better)\r\n        for (let nodeElement of nodeElements) {\r\n            const nodeId = nodeElement.id;\r\n            if (nodeId) {\r\n                const lNode: LGraphElement | undefined = LPointerTargetable.wrap(nodeId);\r\n                if (lNode) nodes.push(lNode);\r\n            }\r\n        }\r\n        return nodes;*/\r\n    }\r\n\r\n    __info_of__node:Info={type: 'LGraphElement[]', txt: \"Return the latest updated node representing this ModelElement, including those not currently displayed in the graph.\"};\r\n    protected get_node(context: Context): this[\"node\"] {\r\n        return transientProperties.modelElement[context.data.id]?.node;\r\n        // const nodes = context.proxyObject.nodes;\r\n        // return nodes.filter( n => n.favoriteNode)[0] || nodes[0];\r\n    }\r\n    edges!: LEdge[];\r\n    edge!: LEdge;\r\n    __info_of__edges:Info={type: 'LEdge[]', txt: \"The subset of \\\"nodes\\\" containing only edges.\"};\r\n    __info_of__edge:Info={type: 'LEdge[]', txt: \"The first element of the collection edges\"};\r\n    protected get_edges(context: Context): this[\"edges\"] {\r\n        return this.get_nodes(context).filter( l => l.className?.includes('Edge')) as any;\r\n    }\r\n    protected get_edge(context: Context): this[\"edge\"] {\r\n        return this.get_nodes(context).find( l => l.className?.includes('Edge')) as any;\r\n    }\r\n    notEdges!: LGraphElement[];\r\n    notEdge!: LGraphElement;\r\n    __info_of__notEdges:Info={type: 'LGraphElement[]', txt: \"The subset of \\\"nodes\\\" excluding only edges.\"};\r\n    protected get_notEdges(context: Context): this[\"notEdges\"] {\r\n        return this.get_nodes(context).filter( l => !(l.className?.includes('Edge'))) as any;\r\n    }\r\n    __info_of__notEdge:Info={type: 'LGraphElement', txt: \"The first element of the collection notEdges\"};\r\n    protected get_notEdge(context: Context): this[\"notEdge\"] {\r\n        return this.get_nodes(context).find( l => !(l.className?.includes('Edge'))) as any;\r\n    }\r\n    vertexes!: LVertex[];\r\n    vertex!: LVertex;\r\n    __info_of__vertexes:Info={type: 'LVertex[]', txt: \"The subset of \\\"nodes\\\" containing only vertexes.\"};\r\n    __info_of__vertex:Info={type: 'LVertex', txt: \"The first element of the collection vertexes\"};\r\n    protected get_vertexes(context: Context): this[\"vertexes\"] {\r\n        return this.get_nodes(context).filter( l => l.className?.includes('Vertex')) as any;\r\n    }\r\n    protected get_vertex(context: Context): this[\"vertex\"] {\r\n        return this.get_nodes(context).find( l => l.className?.includes('Vertex')) as any;\r\n    }\r\n    edgePoints!: LEdgePoint[];\r\n    edgePoint!: LEdgePoint;\r\n    __info_of__edgePoints:Info={type: 'LVertex[]', txt: \"The subset of \\\"nodes\\\" containing only edgePoints.\"};\r\n    __info_of__edgePoint:Info={type: 'LVertex', txt: \"The first element of the collection edgePoints\"};\r\n    protected get_edgePoints(context: Context): this[\"edgePoints\"] {\r\n        return this.get_nodes(context).filter( l => l.className?.includes('EdgePoint')) as any;\r\n    }\r\n    protected get_edgePoint(context: Context): this[\"edgePoint\"] {\r\n        return this.get_nodes(context).find( l => l.className?.includes('EdgePoint')) as any;\r\n    }\r\n    graphs!: LGraph[];\r\n    graph!: LGraph;\r\n    __info_of__graphs:Info={type: 'LGraph[]', txt: \"The subset of \\\"nodes\\\" containing only graphs.\"};\r\n    __info_of__graph:Info={type: 'LGraph', txt: \"The first element of the collection graphs\"};\r\n    protected get_graphs(context: Context): this[\"graphs\"] {\r\n        return this.get_nodes(context).filter( l => {\r\n            let d = l.__raw;\r\n            return d.className === 'DGraph' || d.className === 'DGraphVertex'\r\n        }) as any;\r\n    }\r\n    protected get_graph(context: Context): this[\"graph\"] {\r\n        return this.get_nodes(context).find( l => {\r\n            let d = l.__raw;\r\n            return d.className === 'DGraph' || d.className === 'DGraphVertex'\r\n        }) as any;\r\n    }\r\n    fields!: LGraphElement[];\r\n    field!: LGraphElement;\r\n    __info_of__fields:Info={type: 'LGraphElement[]', txt: \"The subset of \\\"nodes\\\" containing only fields.\"};\r\n    __info_of__field:Info={type: 'LGraphElement', txt: \"The first element of the collection fields\"};\r\n    protected get_fields(context: Context): this[\"fields\"] {\r\n        return this.get_nodes(context).filter( l => l.className === 'DGraphElement') as any;\r\n    }\r\n    protected get_field(context: Context): this[\"field\"] {\r\n        return this.get_nodes(context).find( l => l.className === 'DGraphElement') as any;\r\n    }\r\n\r\n    /*\r\n    protected get_nodes(context: Context): this[\"nodes\"] {\r\n        return context.data.nodes.map((pointer) => {\r\n            return LPointerTargetable.from(pointer)\r\n        });\r\n    }\r\n    protected set_nodes(val: PackArr<this[\"nodes\"]>, context: Context): boolean {\r\n        const list = val.map((lItem) => { return Pointers.from(lItem) });\r\n        SetFieldAction.new(context.data, 'nodes', list);\r\n        return true;\r\n    }\r\n    */\r\n\r\n    protected get_model(context: Context): LModel {\r\n        return this.get_until_parent(context.proxyObject, context.data, DModel) as LModel;\r\n    }\r\n\r\n    protected get_package(context: Context): LPackage {\r\n        return this.get_until_parent(context.proxyObject, context.data, DPackage) as LPackage;\r\n    }\r\n\r\n    protected get_class(context: Context): LClass | null {\r\n        return this.get_until_parent(context.proxyObject, context.data, DClass);\r\n    } // todo: might be better for pergormance to erase this universal method and add implementations to every single L-class counting the correct amount of \"father\" navigations for each ( attrib to package? use attrib.father.father)\r\n    protected get_operation(context: Context): LOperation | null {\r\n        return this.get_until_parent(context.proxyObject, context.data, DOperation);\r\n    }\r\n\r\n    protected get_enum(context: Context): LEnumerator | null {\r\n        return this.get_until_parent(context.proxyObject, context.data, DEnumerator);\r\n    }\r\n\r\n    protected get_father(context: Context): LModelElement {\r\n        return LPointerTargetable.from(context.data.father);\r\n    }\r\n\r\n    protected get_children_idlist(context: Context): Pointer<DAnnotation | DPackage | DClassifier | DEnumerator | DEnumLiteral | DParameter | DStructuralFeature | DOperation | DObject | DValue, 1, 'N'> { // LPackage | LClassifier | LTypedElement | LAnnotation | LEnumLiteral | LParameter | LStructuralFeature | LOperation\r\n        return context.data.annotations ? [...context.data.annotations] : [];\r\n    }\r\n\r\n    protected get_children(context: Context): this[\"children\"] {\r\n        // return this.get_children_idlist(context).map(e => LPointerTargetable.from(e));\r\n        return LPointerTargetable.from(this.get_children_idlist(context));\r\n    }\r\n\r\n    protected set_children(a: never, context: Context): boolean {\r\n        return Log.exx('children is a derived read-only collection', context.data);\r\n    }\r\n\r\n/*\r\n    add_parent(val: Pack<this[\"parent\"]>, c: Context): boolean { // will be used?\r\n        const ptr = Pointers.from(val);\r\n        TRANSACTION(this.get_name(c)+'.parent+=', ()=>{\r\n            SetFieldAction.new(c.data, 'parent', ptr, '+=', true); // need to update children of the old and new parents\r\n        })\r\n        return true;\r\n    }\r\n    protected remove_parent(c: Context): boolean {\r\n        return SetFieldAction.new(c.data, 'parent', [], '', true);\r\n    }\r\n\r\n    protected get_parent(c: Context): this[\"parent\"] {\r\n        return LPointerTargetable.from(c.data.id);\r\n    }*/\r\n\r\n    protected set_parent(val: Pack<LAnnotation>, c: Context): boolean { // val: Pack<DModelElement>\r\n        const ptrs = Pointers.from(val);\r\n        let ptr: Pointer;\r\n        if (Array.isArray(ptrs)) ptr = ptrs[0];\r\n        else ptr = ptrs;\r\n        if (c.data.father === ptr) return true;\r\n        TRANSACTION(this.get_name(c)+'.parent', ()=>{\r\n            SetFieldAction.new(c.data, 'father', ptr, '', true);\r\n            //SetFieldAction.new(c.data, 'parent', ptrs, '', true);\r\n        }, this.get_father(c)?.name, LPointerTargetable.wrap(ptr)?.name)\r\n        return true;\r\n    }\r\n\r\n    add_annotation(val: Pack<this[\"annotations\"]>, c: Context): boolean {\r\n        const ptrs = Pointers.from(val);\r\n        TRANSACTION(this.get_name(c)+'.annotations+=', ()=>{\r\n            SetFieldAction.new(c.data, 'annotations', ptrs, '+=', true);\r\n        }, undefined, ptrs.length)\r\n        return true;\r\n    }\r\n\r\n    remove_annotation(val: Pack<this[\"annotations\"]>, c: Context): boolean { // todo: when this will be ever used? this should be triggered by LObject but only get_ / set_ and delete of whole elements should be triggerable.\r\n        let ptrs: Pointer<DAnnotation, 1, 'N', LAnnotation> = Pointers.from(val) as any;\r\n        if (!Array.isArray(ptrs)) ptrs = [ptrs] as any;\r\n        let indexes = ptrs.map(ptr => c.data.annotations.indexOf(ptr)).filter(p => p >= 0);\r\n        if (indexes.length === 0) return true;\r\n        TRANSACTION(this.get_name(c)+'.annotations-=', ()=>{\r\n            SetFieldAction.new(c.data, 'annotations', indexes, '-=', true);\r\n        }, undefined, ptrs.length)\r\n        return true;\r\n    }\r\n\r\n    protected get_annotations(context: Context): this[\"annotations\"] {\r\n        return LPointerTargetable.fromPointer(context.data.annotations);\r\n    }\r\n\r\n    protected set_annotations(val: Pack<LAnnotation>, c: Context): boolean {\r\n        //  if (!Array.isArray(val)) val = [val];\r\n        //         val = val.map( v => (v instanceof LAnnotation ? v.id : ( Pointers.filterValid(v) ? v : null ))) as Pointer<DAnnotation>[];\r\n        let ptrs = Pointers.from(val);\r\n        if (!Array.isArray(ptrs)) ptrs = [ptrs] as any;\r\n        if (!ptrs.length) return true;\r\n        TRANSACTION(this.get_name(c)+'.annotations', ()=>{\r\n            SetFieldAction.new(c.data, 'annotations', ptrs, '', true);\r\n        }, undefined, ptrs.length)\r\n        return true;\r\n    }\r\n\r\n    protected get_addChild(c: Context): (type?: string, ...params: any[]) => LModelElement { // just for add new, not for add pre-existing.\r\n        return (type?: string, ...args: any) => {\r\n            let ret: undefined | ((...params: any[]) => LModelElement) = undefined;\r\n            TRANSACTION(this.get_name(c)+'.addChild()', ()=>{\r\n                let type0 = type;\r\n                if (!type || type === \"auto\") {\r\n                    switch(c.data.className){\r\n                        case DModel.cname: if ((c.data as DModel).isMetamodel) type = \"package\"; else type = \"object\"; break;\r\n                        case DObject.cname: type = \"value\"; break;\r\n                        case DPackage.cname: type = \"package\"; break;\r\n                        case DClass.cname: type = \"attribute\"; break;\r\n                        case DEnumerator.cname: type = \"literal\"; break;\r\n                        case DOperation.cname: type = \"parameter\"; break;\r\n                        default: type = \"annotation\"; break;\r\n                    }\r\n                }\r\n                let fatherElement;\r\n                switch (type.toLowerCase()) {\r\n                    default:\r\n                        Log.ee('cannot find children type requested to add:', {type: (type || '').toLowerCase(), c});\r\n                        ret = () => undefined as any;\r\n                        break;\r\n                    case \"package\":\r\n                        ret = (this.get_package(c) || this.get_model(c))?.addPackage;\r\n                        break;\r\n                    case \"class\":\r\n                        // let current = c.proxyObject;\r\n                        fatherElement = this.get_package(c);\r\n                        if (!fatherElement) {\r\n                            let model = this.get_model(c);\r\n                            //if (model && !model.isMetamodel) model = model.instanceof;\r\n                            fatherElement = model.packages[0];\r\n                            if (!fatherElement) fatherElement = model.addPackage();\r\n                        }\r\n                        ret = fatherElement.addClass;\r\n                        //ret = (this as any).get_addClass(context as any);\r\n                        break;\r\n                    case \"enum\":\r\n                    case \"enumerator\":\r\n                        fatherElement = this.get_package(c);\r\n                        if (!fatherElement) {\r\n                            let model = this.get_model(c);\r\n                            //if (model && !model.isMetamodel) model = model.instanceof;\r\n                            fatherElement = model.packages[0];\r\n                            if (!fatherElement) fatherElement = model.addPackage();\r\n                        }\r\n                        ret = fatherElement.addEnumerator;\r\n                        break;\r\n                    case \"attribute\":\r\n                        ret = this.get_class(c)?.addAttribute;\r\n                        break;\r\n                    case \"reference\":\r\n                        ret = this.get_class(c)?.addReference;\r\n                        break;\r\n                    case \"literal\":\r\n                        ret = this.get_enum(c)?.addLiteral;\r\n                        break;\r\n                    case \"operation\":\r\n                        ret = this.get_class(c)?.addOperation;\r\n                        break;\r\n                    case \"parameter\":\r\n                        ret = this.get_operation(c)?.addParameter;\r\n                        break;\r\n                    case \"object\":\r\n                        if (c.data.className === \"DValue\") {\r\n                            ret = (this as any as LValue).get_addObject(c as any as LogicContext<DValue>);\r\n                        }\r\n                        else {\r\n                            ret = this.get_model(c).addObject;\r\n                        }\r\n\r\n                    //case \"exception\": ret = ((exception: Pack1<LClassifier>) => { let rett = this.get_addException(context as any); rett(exception); }) as any; break;\r\n                    /*case \"exception\": exceptions should not be \"added\" here, this is for creating objects. exceptions are not created but just linked. they are classes.\r\n                        ret = (this as any).get_addException(c as any);\r\n                        break; */\r\n                }\r\n                // console.log('x6 addchild()', {type0, type, args, fatherElement, ret, rts:ret?.toString()});\r\n                ret = ret ? ret(...args) : null as any;\r\n            })\r\n            return ret as any;\r\n        }\r\n    }\r\n\r\n    protected get_addException(c: Context): () => void {\r\n        let ret = () => {};\r\n        const dOperation: DOperation | null = (c.data?.className === \"DOperation\") ? c.data as DOperation : null;\r\n        if (!dOperation) return ret;\r\n        const dClass = DPointerTargetable.from(dOperation.father);\r\n        if (!dClass) return ret;\r\n        ret = () => {\r\n            TRANSACTION(this.get_name(c)+'.exceptions+=', ()=>{\r\n                SetFieldAction.new(dOperation, \"exceptions\", dClass.id, '+=', true);\r\n            }, undefined, LPointerTargetable.fromD(dClass).name)\r\n        }\r\n        ret();\r\n        // todo: test & fix this double call, i suspect if you call it\r\n        //  from get_addChildren it triggers once (return is ignored) but twice if directly\r\n        return ret;\r\n    }\r\n\r\n    // activated by user in JSX\r\n    // todo: this.wrongAccessMessage(\"addClass\");\r\n    protected cannotCall(name: string, ...params: string[]): any {\r\n        Log.exDevv(name + ' should never be called directly, but should trigger get_' + name + '(' + params.join(', ') + '), this is only a signature for type checking.');\r\n    }\r\n\r\n    public addClass(): void {\r\n        this.cannotCall('addClass');\r\n    }\r\n\r\n    public addAttribute(): void {\r\n        this.cannotCall('addAttribute');\r\n    }\r\n\r\n    public addReference(): void {\r\n        this.cannotCall('addReference');\r\n    }\r\n\r\n    public addEnumerator(): void {\r\n        this.cannotCall('addEnumerator');\r\n    }\r\n\r\n    public addParameter(): void {\r\n        this.cannotCall('addParameter');\r\n    }\r\n\r\n    // chiedere al prof: cosa può lanciato come eccezione: se tutte le classi o se solo quelle che estendono Exception\r\n    public addException(exception?: DClassifier): () => void {\r\n        throw this.wrongAccessMessage(\"AddException\");\r\n    }\r\n\r\n    public addChild(type: string): DModelElement {\r\n        return this.cannotCall('addChild', type);\r\n    }\r\n\r\n}\r\n\r\n/*function isValidPointer<T extends DPointerTargetable = DModelElement, LB extends number = 0, UB extends number = 1, RET extends LPointerTargetable = LModelElement>\r\n(p: Pointer<T, LB, UB, RET>, constraintType?: typeof DPointerTargetable): boolean {\r\n    const pointerval: RET | null = LModelElement.ResolvePointer(p);\r\n    if (!pointerval) return false;\r\n    if (!constraintType) return true;\r\n    return (pointerval instanceof constraintType); }*/\r\n\r\n/* todo:\r\nnel proxy aggiungi regola di default, se prendi qualcosa che inizia con \"set_X\" esplicitamente (dovrebbe farlo solo il dev)\r\nrichiama _set_X(context, ...params)     <---- nuova funzione set di default, anche this.x = x richiama _set_x\r\n\r\nil dev specifica set_x come public di sola firma senza implementazione (throw exception) e senza context\r\nil dev specifica _set_x come implementazione private\r\n\r\nper la get esiste solo _get_x, non \"get_x\"\r\n\r\n todo2: aggiungi readonly a tutti i campi L per non sbagliarsi e fare in modo che il dev usi sempre i \"set_\" che sono correttamente tipizzati\r\n*\r\n* */\r\n\r\n/*todo:\r\n* for every feature X: typed L, in CLASS_L0 with a side effects when they are edited (like need to update other data for consistency)\r\n*\r\n* dev will use this\r\n* protected set_X(val: D | L | Pointer<D> ) { throw new Error(\"set_X should never be executed, the proxy should redirect to get_set_X.\"); }\r\n* protected get_set_X( val: D | L | Pointer<D>, otherparams, ContextD>) { throw new Error(\"set_X should never be executed, the proxy should redirect to get_set_X.\"); }\r\n*\r\n*\r\n* */\r\n// export type WModelElement = DModelElement | LModelElement | _WModelElement;\r\nRuntimeAccessibleClass.set_extend(DPointerTargetable, DModelElement);\r\nRuntimeAccessibleClass.set_extend(DPointerTargetable, LModelElement);\r\n\r\n@Leaf\r\n@RuntimeAccessible('DAnnotation')\r\nexport class DAnnotation extends DModelElement { // extends Mixin(DAnnotation0, DModelElement)\r\n    // static singleton: LAnnotation;\r\n    // static logic: typeof LAnnotation;\r\n    // static structure: typeof DAnnotation;\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // inherit redefine\r\n    id!: Pointer<DAnnotation, 1, 1, LAnnotation>;\r\n    parent: Pointer<DModelElement, 0, 'N', LModelElement> = [];\r\n    father!: Pointer<DModelElement, 1, 1, LModelElement>;\r\n    annotations: Pointer<DAnnotation, 0, 'N', LAnnotation> = [];\r\n    // personal\r\n    source!: string;\r\n    details!: DAnnotationDetail[];//Dictionary<string, string>;\r\n\r\n    public static new(source?: DAnnotation[\"source\"], details?: DAnnotation[\"details\"], father?: Pointer, persist: boolean = true): DAnnotation {\r\n        // if (!name) name = this.defaultname(\"annotation \", father);\r\n        return new Constructors(new DAnnotation('dwc'), father, persist, undefined).DPointerTargetable().DModelElement().DAnnotation(source, details).end();\r\n    }\r\n}\r\n\r\n@Node\r\n@RuntimeAccessible('LAnnotation')\r\nexport class LAnnotation<Context extends LogicContext<DAnnotation> = any, D extends DAnnotation = DAnnotation> extends LModelElement {\r\n    // Mixin(DAnnotation0, LModelElement)\r\n    // @ts-ignore\r\n    __namee!: \"LAnnotation\" = \"LAnnotation\";\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    public __raw!: DAnnotation;\r\n    id!: Pointer<DAnnotation, 1, 1, LAnnotation>;\r\n    // static singleton: LAnnotation;\r\n    // static logic: typeof LAnnotation;\r\n    // static structure: typeof DAnnotation;\r\n\r\n    // inherit redefine\r\n    parent!: LModelElement[];\r\n    father!: LModelElement;\r\n    annotations!: LAnnotation[];\r\n    // personal\r\n    source!: string;\r\n    details!: LAnnotationDetail[];// Dictionary<string, string> = {};\r\n\r\n    protected generateEcoreJson_impl(context: Context, loopDetectionObj: Dictionary<Pointer, DModelElement> = {}): Json {\r\n        loopDetectionObj[context.data.id] = context.data;\r\n        const json: Json = {};\r\n        EcoreParser.write(json, ECoreAnnotation.source, context.data.source);\r\n        // EcoreParser.write(json, ECoreAnnotation.references, context.proxyObject.referencesStr);\r\n        EcoreParser.write(json, ECoreAnnotation.details, context.proxyObject.details.map(d => d.generateEcoreJson(loopDetectionObj)));\r\n        return json;\r\n    }\r\n\r\n    public duplicate(deep: boolean = true): this {\r\n        return this.cannotCall(((this.constructor as typeof RuntimeAccessibleClass).cname || this.constructor.name) + \"duplicate()\");\r\n    }\r\n\r\n    protected get_duplicate(c: Context): ((deep?: boolean) => LAnnotation) {\r\n        return (deep: boolean = false) => {\r\n            let ret: LAnnotation = null as any;\r\n            TRANSACTION('duplicate ' + this.get_name(c), ()=>{\r\n                let de = c.proxyObject.father.addAnnotation(c.data.source, (deep ? c.proxyObject.details.map(ldet => ldet.duplicate().__raw) : c.data.details));\r\n                let le: LAnnotation = LPointerTargetable.fromD(de);\r\n                let we: WAnnotation = le as any;\r\n                we.annotations = deep ? c.proxyObject.annotations.map(lchild => lchild.duplicate(deep).id) : c.data.annotations;\r\n                ret = le; // set ret = le only if the transaction is complete.\r\n            })\r\n            return ret;\r\n        }\r\n    }\r\n\r\n    protected get_source(context: Context): this[\"source\"] {\r\n        return context.data.source;\r\n    }\r\n\r\n    protected set_source(val: this[\"source\"], c: Context): boolean {\r\n        if (val === c.data.source) return true;\r\n        TRANSACTION(this.get_name(c)+'.source', ()=>{\r\n            SetFieldAction.new(c.data, 'source', val, '', false);\r\n        }, c.data.source, val);\r\n        return true;\r\n    }\r\n\r\n    protected get_details(context: Context): this[\"details\"] {\r\n        return TargetableProxyHandler.wrapAll(context.data.details);\r\n    }\r\n\r\n    protected set_details(val: this[\"details\"], c: Context): boolean {\r\n        if (val === c.data.details) return true;\r\n        TRANSACTION(this.get_name(c)+'.details', ()=>{\r\n            SetFieldAction.new(c.data, 'details', val);\r\n        }, c.data.details, val)\r\n        return true;\r\n    }\r\n}\r\n\r\nRuntimeAccessibleClass.set_extend(DModelElement, DAnnotation);\r\nRuntimeAccessibleClass.set_extend(LModelElement, LAnnotation);\r\n@Leaf\r\n@RuntimeAccessible('LAnnotationDetail')\r\nexport class LAnnotationDetail<Context extends LogicContext<DAnnotationDetail> = any> extends LModelElement { // todo\r\n    father!: LAnnotation;\r\n\r\n    protected generateEcoreJson_impl(context: Context, loopDetectionObj: Dictionary<Pointer, DModelElement> = {}): Json {\r\n        // loopDetectionObj[context.data.id] = context.data;\r\n        const json: Json = {};\r\n        // if (context.data.name !== null) EcoreParser.write(json, ECoreDetail.key, context.data.name);\r\n        // if (context.data.value !== null) EcoreParser.write(json, ECoreDetail.value, context.data.value);\r\n        return json;\r\n    }\r\n\r\n    public duplicate(deep: boolean = true): this {\r\n        return this.cannotCall(((this.constructor as typeof RuntimeAccessibleClass).cname || this.constructor.name) + \"duplicate()\");\r\n    }\r\n\r\n    protected get_duplicate(context: Context): ((deep?: boolean) => this) {\r\n        Log.exDevv(\"LAnnotationDetail.getDuplicate(): todo\");\r\n        return () => this;\r\n        // return (deep: boolean = false) => (context.proxyObject as LAnnotationDetail).father.addAnnotationDetail( {...context.data._subMaps})\r\n    }\r\n}\r\n\r\nRuntimeAccessibleClass.set_extend(DModelElement, DAnnotationDetail);\r\nRuntimeAccessibleClass.set_extend(LModelElement, LAnnotationDetail);\r\n@Node\r\n@RuntimeAccessible('DNamedElement')\r\nexport class DNamedElement extends DPointerTargetable { // Mixin(DNamedElement0, DAnnotation)\r\n    // static _super = DAnnotation;\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // static singleton: LNamedElement;\r\n    // static logic: typeof LNamedElement;\r\n    // static structure: typeof DNamedElement;\r\n\r\n    // inherit redefine\r\n    id!: Pointer<DNamedElement, 1, 1, LNamedElement>;\r\n    parent: Pointer<DModelElement, 0, 'N', LModelElement> = [];\r\n    father!: Pointer<DModelElement, 1, 1, LModelElement>;\r\n    annotations: Pointer<DAnnotation, 0, 'N', LAnnotation> = [];\r\n    // personal\r\n    name!: string;\r\n\r\n    public static new(name?: DNamedElement[\"name\"]): DNamedElement {\r\n        Log.exx(\"DNamedElement is abstract, cannot instantiate\");\r\n        return null as any;\r\n        // return new Constructors(new DNamedElement('dwc')).DPointerTargetable().DModelElement().DNamedElement(name).end();\r\n    }\r\n\r\n}\r\n\r\n@Abstract\r\n@RuntimeAccessible('LNamedElement')\r\nexport class LNamedElement<Context extends LogicContext<DNamedElement> = any> extends LModelElement { // Mixin(DNamedElement0, DAnnotation)\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // public __raw!: DNamedElement;\r\n    id!: Pointer<DNamedElement, 1, 1, LNamedElement>;\r\n    // static singleton: LNamedElement;\r\n    // static logic: typeof LNamedElement;\r\n    // static structure: typeof DNamedElement;\r\n\r\n    // inherit redefine\r\n    parent!: LModelElement[];\r\n    father!: LModelElement;\r\n    annotations!: LAnnotation[];\r\n    // personal\r\n    name!: string;\r\n    namespace!: string;\r\n\r\n    protected set_containers(): boolean {\r\n        return this.cannotSet('containers');\r\n    }\r\n\r\n    protected get_containers(context: Context): LNamedElement[\"containers\"] {\r\n        let thiss: LNamedElement = context.proxyObject;\r\n        const ret: LNamedElement[] = [thiss];\r\n        while (true) {\r\n            thiss = thiss.father as LNamedElement;\r\n            if (!thiss) break;\r\n            ret.push(thiss);\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    // protected get_namespace(context: Context): string { throw new Error(\"?? get namespace ?? todo\"); return \"\"; }\r\n\r\n}\r\n\r\n\r\n// export type WNamedElement = DNamedElement | LNamedElement | _WNamedElement;\r\nRuntimeAccessibleClass.set_extend(DModelElement, DNamedElement);\r\nRuntimeAccessibleClass.set_extend(LModelElement, LNamedElement);\r\n@RuntimeAccessible('DTypedElement')\r\nexport class DTypedElement extends DPointerTargetable { // Mixin(DTypedElement0, DNamedElement)\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // static singleton: LTypedElement;\r\n    // static logic: typeof LTypedElement;\r\n    // static structure: typeof DTypedElement;\r\n\r\n    // inherit redefine\r\n    id!: Pointer<DTypedElement, 1, 1, LTypedElement>;\r\n    annotations: Pointer<DAnnotation, 0, 'N', LAnnotation> = [];\r\n    parent: Pointer<DModelElement, 0, 'N', LModelElement> = [];\r\n    father!: Pointer<DModelElement, 1, 1, LModelElement>;\r\n    name!: string;\r\n    instances!: Pointer<DValue, 0, 'N', LValue>;\r\n    // personal\r\n    type!: Pointer<DClassifier, 1, 1, LClassifier>;\r\n    ordered: boolean = true;\r\n    unique: boolean = true;\r\n    lowerBound: number = 0;\r\n    upperBound: number = 1;\r\n    many!: boolean; // ?\r\n    required!: boolean; // ?\r\n\r\n\r\n    public static new(name?: DNamedElement[\"name\"], type?: DTypedElement[\"type\"], father?: Pointer, persist: boolean = true): DTypedElement {\r\n        Log.exx(\"DTypedElement is abstract, cannot instantiate\");\r\n        return null as any;\r\n        //return new Constructors(new DTypedElement('dwc'), father, persist, undefined).DPointerTargetable().DModelElement().DNamedElement(name).DTypedElement(type).end();\r\n    }\r\n}\r\n\r\n@Abstract\r\n@RuntimeAccessible('LTypedElement')\r\nexport class LTypedElement<Context extends LogicContext<DTypedElement> = any> extends LNamedElement { // extends Mixin(DTypedElement0, LNamedElement)\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    public __raw!: DTypedElement;\r\n    id!: Pointer<DTypedElement, 1, 1, LTypedElement>;\r\n    // static singleton: LTypedElement;\r\n    // static logic: typeof LTypedElement;\r\n    // static structure: typeof DTypedElement;\r\n\r\n    // inherit redefine\r\n    parent!: LModelElement[];\r\n    father!: LModelElement;\r\n    annotations!: LAnnotation[];\r\n    name!: string;\r\n    namespace!: string;\r\n    instances!: LValue[];\r\n    // personal\r\n    type!: LClassifier;\r\n\r\n    primitiveType?: LClass;\r\n    classType?: LClass;\r\n    enumType?: LEnumerator;\r\n\r\n    ordered!: boolean;\r\n    unique!: boolean;\r\n    lowerBound!: number;\r\n    upperBound!: number;\r\n    many!: boolean;\r\n    required!: boolean;\r\n\r\n\r\n    protected get_classType(context: Context): this[\"classType\"] {\r\n        let type = this.get_type(context);\r\n        return type.isClass ? type as LClass : undefined;\r\n    }\r\n\r\n    protected get_enumType(context: Context): this[\"enumType\"] {\r\n        let type = this.get_type(context);\r\n        return type.isEnum ? type as LEnumerator : undefined;\r\n    }\r\n\r\n    protected get_primitiveType(context: Context): this[\"primitiveType\"] {\r\n        let type = this.get_type(context);\r\n        return type.isPrimitive ? type as LClass : undefined;\r\n    }\r\n\r\n    protected get_type(c: Context): this[\"type\"] {\r\n        let type = LPointerTargetable.from(c.data.type);\r\n        if (type) return type;\r\n        if (c.className === 'DReference') return LPointerTargetable.from(c.data.father);\r\n        else return LPointerTargetable.fromPointer('Pointer_ESTRING');\r\n    }\r\n\r\n    protected set_type(val: Pack1<this[\"type\"]>, c: Context): boolean {\r\n        // let instances: LValue[] = this.get_instances(c);\r\n        let ptr = Pointers.from(val);\r\n        if (c.data.type === ptr) return true;\r\n        TRANSACTION(this.get_name(c)+'.type', ()=>{\r\n            SetFieldAction.new(c.data, 'type', ptr, \"\", true);\r\n        }, this.get_type(c)?.fullname, LPointerTargetable.wrap(val)?.fullname);\r\n        return true;\r\n    }\r\n\r\n    protected get_ordered(context: Context): this[\"ordered\"] {\r\n        return context.data.ordered;\r\n    }\r\n\r\n    protected set_ordered(val: this[\"ordered\"], c: Context): boolean {\r\n        val = !!val;\r\n        if (c.data.ordered === val) return true;\r\n        TRANSACTION(this.get_name(c)+'.ordered', ()=>{\r\n            SetFieldAction.new(c.data, 'ordered', val);\r\n        }, c.data.ordered, val)\r\n        return true;\r\n    }\r\n\r\n    protected get_unique(context: Context): this[\"unique\"] {\r\n        return context.data.unique;\r\n    }\r\n\r\n    protected set_unique(val: this[\"unique\"], c: Context): boolean {\r\n        val = !!val;\r\n        if (c.data.ordered === val) return true;\r\n        TRANSACTION(this.get_name(c)+'.unique', ()=>{\r\n            SetFieldAction.new(c.data, 'unique', val);\r\n        }, c.data.unique, val)\r\n        return true;\r\n    }\r\n\r\n    protected get_lowerBound(context: Context): this[\"lowerBound\"] {\r\n        return context.data.lowerBound;\r\n    }\r\n\r\n    protected set_lowerBound(val: this[\"lowerBound\"], c: Context): boolean {\r\n        val = +val;\r\n        if (isNaN(val)) val = 0;\r\n        else val = Math.max(0, val);\r\n        if (val === c.data.lowerBound) return true;\r\n        TRANSACTION(this.get_name(c)+'.lowerBound', ()=>{\r\n            SetFieldAction.new(c.data, 'lowerBound', val);\r\n            if (c.data.upperBound !=-1 && val > c.data.upperBound) SetFieldAction.new(c.data, 'upperBound', val);\r\n        }, c.data.lowerBound, val)\r\n        return true;\r\n    }\r\n\r\n    protected get_upperBound(context: Context): this[\"upperBound\"] {\r\n        return context.data.upperBound;\r\n    }\r\n\r\n    protected set_upperBound(val: this[\"upperBound\"], c: Context): boolean {\r\n        val = +val;\r\n        if (isNaN(val)) val = -1;\r\n        else val = Math.max(-1, val);\r\n\r\n        TRANSACTION(this.get_name(c)+'.upperBound', ()=>{\r\n            SetFieldAction.new(c.data, 'upperBound', val);\r\n            if (val !== -1 && val < c.data.lowerBound) SetFieldAction.new(c.data, 'lowerBound', val);\r\n        }, c.data.upperBound, val)\r\n        return true;\r\n    }\r\n\r\n    protected get_many(context: Context): this[\"many\"] {\r\n        return context.data.many;\r\n    }\r\n\r\n    protected set_many(val: this[\"many\"], c: Context): boolean {\r\n        val = !!val;\r\n        if (val === c.data.many) return true;\r\n        TRANSACTION(this.get_name(c)+'.many', ()=>{\r\n            SetFieldAction.new(c.data, 'many', val);\r\n        }, c.data.many, val)\r\n        return true;\r\n    }\r\n\r\n    protected get_required(context: Context): this[\"required\"] {\r\n        return context.data.required;\r\n    }\r\n\r\n    protected set_required(val: this[\"required\"], c: Context): boolean {\r\n        val = !!val;\r\n        if (val === c.data.many) return true;\r\n        TRANSACTION(this.get_name(c)+'.required', ()=>{\r\n            SetFieldAction.new(c.data, 'required', val);\r\n        }, c.data.many, val)\r\n        return true;\r\n    }\r\n\r\n    public typeToEcoreString(): string {\r\n        return this.cannotCall(\"typeToEcoreString\");\r\n    }\r\n\r\n    protected get_typeToEcoreString(context: Context): () => string {\r\n        // if (context.data.classType) return EcoreParser.classTypePrefix + context.proxyObject.classType.name;\r\n        // if (context.data.enumType) return EcoreParser.classTypePrefix + context.proxyObject.enumType.name;\r\n        // if (context.data.primitiveType) return context.proxyObject.primitiveType.long;\r\n        return () => context.proxyObject.type.typeEcoreString;\r\n    }\r\n\r\n    public typeToShortString(): string {\r\n        return this.cannotCall(\"typeToShortString\");\r\n    }\r\n\r\n    protected get_typeToShortString(context: Context): () => string {\r\n        // if (context.data.classType) return '' + context.data.classType.name;\r\n        // if (context.data.enumType) return '' + context.data.enumType.name;\r\n        // if (context.data.primitiveType) return '' + context.data.primitiveType.getName();\r\n        return () => {\r\n            console.log('get_typeToShortString', {context, type: context.proxyObject.type});\r\n            return context.proxyObject.type.typeString;\r\n        }\r\n    }\r\n\r\n    canOverride(context: Context, other: LTypedElement): boolean {\r\n        // i primitivi identici sono compatibili\r\n        if (context.data.type === other.type.id) return true;\r\n        let t1 = context.proxyObject.type;\r\n        let t2 = other.type;\r\n        // se entrambi primitivi\r\n        if (context.proxyObject.primitiveType && other.primitiveType) {\r\n            ShortAttribSuperTypes[t1.name as ShortAttribETypes].includes(other.name as ShortAttribETypes);\r\n        }\r\n        if (context.proxyObject.enumType) return t1 === t2; // only if they are same enumerator\r\n        // now assumed to be class type\r\n        if (other.classType === other.classType) return true;\r\n        return (context.proxyObject.classType as LClass).isExtending(other.classType as LClass);\r\n    }\r\n\r\n}\r\n\r\n// @RuntimeAccessible('') export class _WTypedElement extends _WNamedElement { }\r\n// export type WTypedElement = DTypedElement | LTypedElement | _WTypedElement;\r\nRuntimeAccessibleClass.set_extend(DNamedElement, DTypedElement);\r\nRuntimeAccessibleClass.set_extend(LNamedElement, LTypedElement);\r\n@RuntimeAccessible('DClassifier')\r\nexport class DClassifier extends DPointerTargetable { // extends DNamedElement\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // static singleton: LClassifier;\r\n    // static logic: typeof LClassifier;\r\n    // static structure: typeof DClassifier;\r\n\r\n    // inherit redefine\r\n    id!: Pointer<DClassifier, 1, 1, LClassifier>;\r\n    parent: Pointer<DPackage, 0, 'N', LPackage> = [];\r\n    father!: Pointer<DPackage, 1, 1, LPackage>;\r\n    annotations: Pointer<DAnnotation, 0, 'N', LAnnotation> = [];\r\n    name!: string;\r\n    // personal\r\n    instanceClassName!: string;\r\n    // instanceClass: EJavaClass // ?\r\n    defaultValue!: Pointer<DObject, 1, 1, LObject>[] | string[];\r\n    // isInstance(object: EJavaObject): boolean; ?\r\n    // getClassifierID(): number;\r\n\r\n    public static new(name?: DNamedElement[\"name\"], father?: Pointer, persist: boolean = true): DClassifier {\r\n        Log.exx(\"DClassifier is abstract, cannot instantiate\");\r\n        return null as any;\r\n        // return new Constructors(new DClassifier('dwc'), father, persist, undefined).DPointerTargetable().DModelElement().DNamedElement(name).DClassifier().end();\r\n    }\r\n}\r\n\r\n@Abstract\r\n@RuntimeAccessible('LClassifier')\r\nexport class LClassifier<Context extends LogicContext<DClassifier> = any> extends LNamedElement { // extends DNamedElement\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    public __raw!: DClassifier;\r\n    id!: Pointer<DClassifier, 1, 1, LClassifier>;\r\n    // static singleton: LClassifier;\r\n    // static logic: typeof LClassifier;\r\n    // static structure: typeof DClassifier;\r\n\r\n    // inherit redefine\r\n    parent!: LPackage[];\r\n    father!: LPackage;\r\n    annotations!: LAnnotation[];\r\n    name!: string;\r\n    namespace!: string;\r\n    // personal\r\n    instanceClassName!: string;\r\n    // instanceClass: EJavaClass // ?\r\n    defaultValue!: LObject[] | string[];\r\n    isPrimitive!: boolean;\r\n    isClass!: boolean;\r\n    isEnum!: boolean;\r\n    // isInstance(object: EJavaObject): boolean; ?\r\n    // getClassifierID(): number;\r\n\r\n    protected get_instanceClassName(context: Context): this[\"instanceClassName\"] {\r\n        return context.data.instanceClassName;\r\n    }\r\n\r\n    protected set_instanceClassName(val: this[\"instanceClassName\"], c: Context): boolean {\r\n        TRANSACTION(this.get_name(c)+'.instanceClassName', ()=>{\r\n            SetFieldAction.new(c.data, 'instanceClassName', val, \"\", false);\r\n        }, c.data.instanceClassName, val)\r\n        return true;\r\n    }\r\n\r\n    protected set_isPrimitive(val: this[\"isPrimitive\"], context: Context): boolean {\r\n        return this.cannotSet(\"isPrimitive\");\r\n    }\r\n\r\n    protected set_isClass(val: this[\"isClass\"], context: Context): boolean {\r\n        return this.cannotSet(\"isClass\");\r\n    }\r\n\r\n    protected set_isEnum(val: this[\"isEnum\"], context: Context): boolean {\r\n        return this.cannotSet(\"isEnum\");\r\n    }\r\n\r\n    protected get_isPrimitive(context: Context): this[\"isPrimitive\"] {\r\n        return !!((context.data as DClass).isPrimitive as unknown);\r\n    }\r\n\r\n    protected get_isClass(context: Context): this[\"isClass\"] {\r\n        return (context.data as DClass).isPrimitive ? false : context.data.className === DClass.cname;\r\n    }\r\n\r\n    protected get_isEnum(context: Context): this[\"isEnum\"] {\r\n        return context.data.className === DEnumerator.cname;\r\n    }\r\n\r\n    protected set_defaultValue(val: this[\"defaultValue\"] | DClassifier[\"defaultValue\"], c: Context): boolean {\r\n        TRANSACTION(this.get_name(c)+'.defaultValue', ()=>{\r\n            if (typeof val !== \"object\" && !Pointers.isPointer(val)) {\r\n                // primitive default value for enums\r\n                SetFieldAction.new(c.data, 'defaultValue', val, \"\", false);\r\n            } else {\r\n                SetFieldAction.new(c.data, 'defaultValue', Pointers.from(val as Pointer[]) || [], \"\", true);\r\n            }\r\n        })\r\n        return true;\r\n    }\r\n\r\n    typeEcoreString!: string;\r\n    typeString!: string;\r\n\r\n    private get_typeEcoreString(c: Context) {\r\n        return EcoreParser.classTypePrefix + c.data.name;\r\n    }\r\n\r\n    get_typeString(context: Context) {\r\n        return context.data.name;\r\n    }\r\n}\r\n\r\n// @RuntimeAccessible('') export class _WClassifier extends _WNamedElement { }\r\n// export type WClassifier = DClassifier | LClassifier | _WClassifier;\r\nRuntimeAccessibleClass.set_extend(DNamedElement, DClassifier);\r\nRuntimeAccessibleClass.set_extend(LNamedElement, LClassifier);\r\n\r\n@Leaf\r\n@RuntimeAccessible('DPackage')\r\nexport class DPackage extends DPointerTargetable { // extends DNamedElement\r\n    // static _super = DNamedElement;\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // static singleton: LPackage;\r\n    // static logic: typeof LPackage;\r\n    // static structure: typeof DPackage;\r\n\r\n    // inherit redefine\r\n    id!: Pointer<DPackage, 1, 1, LPackage>;\r\n    parent: Pointer<DPackage | DModel, 0, 'N', LPackage | LModel> = [];\r\n    father!: Pointer<DPackage | DModel, 1, 1, LPackage | LModel>;\r\n    annotations: Pointer<DAnnotation, 0, 'N', LAnnotation> = [];\r\n    name!: string;\r\n    // personal\r\n    classifiers: Pointer<DClassifier, 0, 'N', LClassifier> = [];\r\n    subpackages: Pointer<DPackage, 0, 'N', LPackage> = [];\r\n    uri!: string;\r\n    prefix!: string;\r\n\r\n    public static new(name?: DNamedElement[\"name\"], uri?: DPackage[\"uri\"], prefix?: DPackage[\"prefix\"], father?: Pointer, persist: boolean = true, fatherType?: Constructor): DPackage {\r\n        let dmodel: DModel | undefined;\r\n        if (!name) {\r\n            dmodel = father && DPointerTargetable.from(father);\r\n            name = this.defaultname(\"pkg_\", dmodel);\r\n        }\r\n        /*if (!uri) {\r\n            dmodel = dmodel || father && DPointerTargetable.from(father);\r\n            uri = ('org.jodel-react.') + (dmodel?.name || \"username\"); // (DPointerTargetable.from(DUser.current)).name) todo: when DUser is done\r\n        }*/\r\n        return new Constructors(new DPackage('dwc'), father, persist, fatherType).DPointerTargetable().DModelElement()\r\n            .DNamedElement(name).DPackage(uri, prefix).end();\r\n    }/*\r\n    static new15(setter: (d: DPackage) => void, father: DPackage[\"father\"], fatherType: Constructor, name?: string): DPackage {\r\n        if (!name) name = this.defaultname(\"pkg_\", father);\r\n        return new Constructors(new DPackage('dwc'), father, true, fatherType).DPointerTargetable().DModelElement()\r\n            .DNamedElement(name).DPackage().end(setter);\r\n    }\r\n    static new2(setter: Partial<ObjectWithoutPointers<DPackage>>, fatherType: Constructor, persist: boolean = true): DPackage {\r\n        if (!name) name = this.defaultname(\"pkg_\", father);\r\n        return new Constructors(new DPackage('dwc'), father, true, fatherType).DPointerTargetable().DModelElement()\r\n            .DNamedElement(name).DPackage().end((d)=> { Object.assign(d, setter); });\r\n    }*/\r\n    static new3(a: Partial<PackagePointers>, callback: undefined | ((d: DPackage, c: Constructors) => void), fatherType: Constructor, persist: boolean = true): DPackage {\r\n        if (!a.name) a.name = this.defaultname(\"pkg_\", a.father);\r\n        return new Constructors(new DPackage('dwc'), a.father, persist, fatherType, a.id).DPointerTargetable().DModelElement()\r\n            .DNamedElement(a.name).DPackage().end(callback);\r\n    }\r\n}\r\n\r\n@Leaf\r\n@RuntimeAccessible('LPackage')\r\nexport class LPackage<Context extends LogicContext<DPackage> = any, C extends Context = Context, D extends DPackage = DPackage> extends LNamedElement { // extends DNamedElement\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    public __raw!: DPackage;\r\n    id!: Pointer<DPackage, 1, 1, LPackage>;\r\n    // static singleton: LPackage;\r\n    // static logic: typeof LPackage;\r\n    // static structure: typeof DPackage;\r\n    // inherit redefine\r\n    parent!: (LPackage| LModel)[];  // ype 'LPackage' is missing the following properties from type 'LModelElement': get_set_parent, set_parent\r\n    father!: LPackage | LModel;\r\n    annotations!: LAnnotation[];\r\n    name!: string;\r\n    namespace!: string;\r\n    // personal\r\n    classifiers!: LClassifier[];\r\n    subpackages!: LPackage[];\r\n    uri!: string;\r\n    prefix: string = '';\r\n    // derived\r\n    classes!: LClass[] & Dictionary<DocString<\"$name\">, LClass>;\r\n    enums!: LEnumerator[] & Dictionary<DocString<\"$name\">, LEnumerator>;\r\n    enumerators!: LEnumerator[];\r\n\r\n    // utilities to go down in the tree (plural names)\r\n    allSubPackages!: LPackage[];\r\n    allSubEnums!: LEnumerator[];\r\n    allSubClasses!: LClass[];\r\n    operations!: LOperation[];\r\n    parameters!: LParameter[];\r\n    exceptions!: LClassifier[];\r\n    attributes!: LAttribute[];\r\n    references!: LReference[];\r\n    literals!: LEnumLiteral[];\r\n\r\n    protected get_name(c: Context): this['name'] {\r\n        let l = c.proxyObject;\r\n        let ret: string = (l as GObject)['$name']?.value || c.data.name;\r\n        if (ret === 'default') {\r\n            let model = this.get_model(c);\r\n            if (model.__raw.packages[0] === c.data.id) return model.name;\r\n        }\r\n        return ret;\r\n    }\r\n    protected generateEcoreJson_impltemplate(context: Context, loopDetectionObj: Dictionary<Pointer, DModelElement> = {}): Json {\r\n        loopDetectionObj[context.data.id] = context.data;\r\n        const json: GObject = {};\r\n        return json; }\r\n\r\n    protected generateEcoreJson_impl(context: Context, loopDetectionObj: Dictionary<Pointer, DModelElement> = {}): Json {\r\n        loopDetectionObj[context.data.id] = context.data;\r\n        const model: GObject = {};\r\n        const d = context.data;\r\n        let classarr = context.proxyObject.classes.map( c => c.generateEcoreJson(loopDetectionObj));\r\n        let enumarr = context.proxyObject.enums.map(e => e.generateEcoreJson(loopDetectionObj));\r\n        const classifiers: Json[] = Array.prototype.concat.call(classarr, enumarr);\r\n        model[ECorePackage.xmiversion] = '2.0';\r\n        model[ECorePackage.xmlnsxmi] = 'http://www.omg.org/XMI';\r\n        model[ECorePackage.xmlnsxsi] = 'http://www.w3.org/2001/XMLSchema-instance';\r\n        model[ECorePackage.xmlnsecore] = 'http://www.eclipse.org/emf/2002/Ecore';\r\n        model[ECorePackage.namee] = d.name;\r\n        model[ECorePackage.nsURI] = d.uri;\r\n        model[ECorePackage.nsPrefix] = d.prefix;//getModelRoot().namespace();\r\n        model[ECorePackage.eClassifiers] = classifiers;\r\n        return model; }\r\n\r\n    public duplicate(deep: boolean = true): this {\r\n        return this.cannotCall( ((this.constructor as typeof RuntimeAccessibleClass).cname || this.constructor.name) + \"duplicate()\"); }\r\n    protected get_duplicate(c: Context): ((deep?: boolean) => LPackage) {\r\n        return (deep: boolean = false) => {\r\n            let ret: LPackage = null as any;\r\n            TRANSACTION('duplicate ' + this.get_name(c), ()=>{\r\n                let le: LPackage = c.proxyObject.father.addPackage(c.data.name, c.data.uri, c.data.prefix);\r\n                let de: D = le.__raw as D;\r\n                let we: WPackage = le as any;\r\n                we.subpackages = deep ? c.proxyObject.subpackages.map( lchild => lchild.duplicate(deep).id) : c.data.subpackages;\r\n                we.classifiers = deep ? c.proxyObject.classifiers.map( lchild => lchild.duplicate(deep).id) : c.data.classifiers;\r\n                we.annotations = deep ? c.proxyObject.annotations.map( lchild => lchild.duplicate(deep).id) : c.data.annotations;\r\n                ret = le;\r\n            })\r\n            return ret;\r\n        }\r\n    }\r\n\r\n    public addPackage(name?: D[\"name\"], uri?: D[\"uri\"], prefix?: D[\"prefix\"]): LPackage { return this.cannotCall(\"addPackage\"); }\r\n\r\n    protected get_addPackage(context: Context): this[\"addPackage\"] {\r\n        console.log(\"Package.get_addPackage()\", {context, thiss:this});\r\n        return (name?: D[\"name\"], uri?: D[\"uri\"], prefix?: D[\"prefix\"]) => {\r\n            return LPointerTargetable.fromD(DPackage.new(name, uri, prefix, context.data.id, true, DPackage));\r\n        }\r\n    }\r\n\r\n    public addClass(name?: DClass[\"name\"], isInterface?: DClass[\"interface\"], isAbstract?: DClass[\"abstract\"], isPrimitive?: DClass[\"isPrimitive\"],\r\n                    isPartial?: DClass[\"partial\"], partialDefaultName?: DClass[\"partialdefaultname\"]): LClass {\r\n        return this.cannotCall(\"addClass\"); }\r\n    protected get_addClass(context: Context): this[\"addClass\"] {\r\n        return (name?: DClass[\"name\"], isInterface?: DClass[\"interface\"], isAbstract?: DClass[\"abstract\"], isPrimitive?: DClass[\"isPrimitive\"],\r\n                isPartial?: DClass[\"partial\"], partialDefaultName?: DClass[\"partialdefaultname\"]\r\n        ) => LPointerTargetable.fromD(DClass.new(name, isInterface, isAbstract, isPrimitive, isPartial, partialDefaultName, context.data.id, true));\r\n    }\r\n\r\n    public addEnum(...p:Parameters<this[\"addEnumerator\"]>): LEnumerator { return this.addEnumerator(...p); }\r\n    protected get_addEnum(context: Context): this[\"addEnumerator\"] {\r\n        return this.get_addEnumerator(context); }\r\n    public addEnumerator(name?: DEnumerator[\"name\"]): LEnumerator { return this.cannotCall(\"addEnumerator\"); }\r\n    protected get_addEnumerator(context: Context): this[\"addEnumerator\"] {\r\n        return (name?: DEnumerator[\"name\"]) => LPointerTargetable.fromD(DEnumerator.new(name, context.data.id, true));\r\n    }\r\n\r\n    protected get_classes(context: Context, state?: DState, setNameKeys: boolean = true): LClass[] & Dictionary<DocString<\"$name\">, LClass> {\r\n        if (!context.data.classifiers.length) return [] as any;\r\n        if (!state) state = store.getState();\r\n        let classifiers = DPointerTargetable.fromPointer(context.data.classifiers as Pointer<DClassifier, 1, 1, LClassifier>[], state);\r\n        let dclasses = classifiers.filter(dc => dc?.className === DClass.cname) as DClass[];\r\n        let lclasses: LClass[] & Dictionary<DocString<\"$name\">, LClass> = LPointerTargetable.fromD(dclasses) as any;\r\n        if (setNameKeys) for (let i = 0; i < dclasses.length; i++) lclasses[\"$\"+dclasses[i].name] = lclasses[i];\r\n        return lclasses;\r\n    }\r\n    protected get_enums(context: Context): (LEnumerator[] & Dictionary<DocString<\"$name\">, LEnumerator>) { return this.get_enumerators(context); }\r\n    protected get_enumerators(context: Context, state?: DState, setNameKeys: boolean = true): (LEnumerator[] & Dictionary<DocString<\"$name\">, LEnumerator>) {\r\n        if (!context.data.classifiers.length) return [] as any;\r\n        if (!state) state = store.getState();\r\n        let classifiers = DPointerTargetable.fromPointer(context.data.classifiers as Pointer<DClassifier, 1, 1, LClassifier>[], state);\r\n        let denums = classifiers.filter(dc => dc?.className === DEnumerator.cname) as DEnumerator[];\r\n        let lenums: LEnumerator[] & Dictionary<DocString<\"$name\">, LEnumerator> = LPointerTargetable.fromD(denums) as any;\r\n        if (setNameKeys) for (let i = 0; i < denums.length; i++) (lenums as GObject)[\"$\"+denums[i].name] = lenums[i];\r\n        return lenums;\r\n    }\r\n    //private get_allClasses(context: Context): LClass[] & Dictionary<DocString<\"$name\">, LClass> { return this.get_allSubClasses(c); }\r\n    private get_allSubClasses(context: Context): LClass[] & Dictionary<DocString<\"$name\">, LClass> {\r\n        // if (!context.data.isMetamodel) return (context.data.instanceof?.allSubClasses(context) || [] as any);\r\n        const s: DState = store.getState();\r\n        let arr = this.get_allSubPackages(context, s);\r\n        let ret: (LClass[] & Dictionary<DocString<\"$name\">, LClass>) = [] as any;\r\n        // this.get_allSubPackages(context, s).flatMap(p => (p.classes || [])); this was losing the naming $keys!\r\n        for (let a of arr) {\r\n            let classarr: LClass[] & Dictionary<DocString<\"$name\">, LClass> = (a.classes || []) as any;\r\n            U.mergeNamedArray(ret, classarr);\r\n        }\r\n        return ret; }\r\n\r\n    private get_allSubEnums(context: Context): (LEnumerator[] & Dictionary<DocString<\"$name\">, LEnumerator>) { return this.get_allSubEnumerators(context); }\r\n    private get_allSubEnumerators(context: Context): (LEnumerator[] & Dictionary<DocString<\"$name\">, LEnumerator>) {\r\n        const s: DState = store.getState();\r\n        let arr = this.get_allSubPackages(context, s);\r\n        let ret: (LEnumerator[] & Dictionary<DocString<\"$name\">, LEnumerator>) = [] as any;\r\n        // this.get_allSubPackages(context, s).flatMap(p => (p.enums || [])); this was losing the naming $keys!\r\n        for (let a of arr) {\r\n            let enumarr: (LEnumerator[] & Dictionary<DocString<\"$name\">, LEnumerator>) = (a.enumerators || []) as any;\r\n            U.mergeNamedArray(ret, enumarr);\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    protected get_allSubPackages(c: Context, state?: DState): this[\"allSubPackages\"] {\r\n        // return context.data.packages.map(p => LPointerTargetable.from(p));\r\n        state = state || store.getState();\r\n        let tocheck: Pointer<DPackage>[] = c.data.subpackages || [];\r\n        let checked: Dictionary<Pointer, DPackage> = {};\r\n        checked[c.data.id] = c.data;\r\n        while (tocheck.length) {\r\n            let newtocheck: Pointer<DPackage>[] = [];\r\n            for (let ptr of tocheck) {\r\n                if (checked[ptr]) throw new Error(\"loop in packages containing themselves\");\r\n                let dpackage: DPackage = DPointerTargetable.from(ptr, state);\r\n                checked[ptr] = dpackage;\r\n                U.arrayMergeInPlace(newtocheck, dpackage?.subpackages);\r\n            }\r\n            tocheck = newtocheck;\r\n        }\r\n        let darr: DPackage[] = Object.values(checked);\r\n        let larr: LPackage[] & Dictionary<DocString<\"$name\">, LPackage> = LPointerTargetable.fromArr(darr, state);\r\n        U.toNamedArray(larr, darr);\r\n        return larr;\r\n    }\r\n\r\n    protected get_children_idlist(context: Context): Pointer<DAnnotation | DPackage | DClassifier, 1, 'N'> {\r\n        return [...super.get_children_idlist(context) as Pointer<DAnnotation | DPackage | DClassifier, 1, 'N'>, ...context.data.subpackages, ...context.data.classifiers]; }\r\n\r\n    protected get_classifiers(context: Context): this[\"classifiers\"] {\r\n        return context.data.classifiers.map((pointer) => {\r\n            return LPointerTargetable.from(pointer)\r\n        });\r\n    }\r\n    protected set_classifiers(val: PackArr<this[\"classifiers\"]>, c: Context): boolean {\r\n        const list: Pointer<DClassifier>[] = val.map((lItem) => { return Pointers.from(lItem) });\r\n        const oldList = c.data.classifiers;\r\n        const diff = U.arrayDifference(oldList, list);\r\n        TRANSACTION(''+this.get_name(c)+'.classifiers', ()=>{\r\n            SetFieldAction.new(c.data, 'classifiers', list, \"\", true);\r\n            for (let id of diff.added) {\r\n                SetFieldAction.new(id, 'father', c.data.id, '', true);\r\n                SetFieldAction.new(id, 'parent', c.data.id, '+=', true);\r\n            }\r\n            for (let id of diff.removed as Pointer<DModelElement>[]) {\r\n                SetFieldAction.new(id, 'father', undefined, '', true);\r\n                const parent = DPointerTargetable.from(id).parent;\r\n                U.arrayRemoveAll(parent, c.data.id);\r\n                SetFieldAction.new(id, 'parent', parent, '', true);\r\n            }\r\n        })\r\n        return true;\r\n    }\r\n\r\n    protected get_subpackages(context: Context): this[\"subpackages\"] {\r\n        return context.data.subpackages.map((pointer) => {\r\n            return LPointerTargetable.from(pointer)\r\n        });\r\n    }\r\n    protected set_subpackages(val: PackArr<this[\"subpackages\"]>, c: Context): boolean {\r\n        const list = val.map((lItem) => { return Pointers.from(lItem) });\r\n        const oldList = c.data.subpackages;\r\n        const diff = U.arrayDifference(oldList, list);\r\n        TRANSACTION(this.get_name(c)+'.packages', ()=>{\r\n            SetFieldAction.new(c.data, 'subpackages', list, \"\", true);\r\n            for (let id of diff.added) {\r\n                SetFieldAction.new(id, 'father', c.data.id, '', true);\r\n                SetFieldAction.new(id, 'parent', c.data.id, '+=', true);\r\n            }\r\n            for (let id of diff.removed as Pointer<DModelElement>[]) {\r\n                SetFieldAction.new(id, 'father', undefined, '', true);\r\n                const parent = DPointerTargetable.from(id).parent;\r\n                U.arrayRemoveAll(parent, c.data.id);\r\n                SetFieldAction.new(id, 'parent', parent, '', true);\r\n            }\r\n        })\r\n        return true;\r\n    }\r\n\r\n    protected get_uri(context: Context): this[\"uri\"] {\r\n        if (context.data.uri) return context.data.uri + \".\" + context.data.name;\r\n        return ('org.jodel-react.') + (context.proxyObject.model?.name || \"username\") + \".\" + context.data.name;\r\n    }\r\n    protected set_uri(val: this[\"uri\"], c: Context): boolean {\r\n        val = val || '';\r\n        let pos = val.lastIndexOf(c.data.name);\r\n        if (pos) val = val.substring(0, pos - 1); // removes final name and dot, to keep the name part dinamically added in the getter.\r\n        if (val === c.data.uri) return true;\r\n        TRANSACTION(this.get_name(c)+'.uri', ()=>{\r\n            SetFieldAction.new(c.data, 'uri', val, \"\", false);\r\n        }, c.data.uri, val);\r\n        return true;\r\n    }\r\n    protected get_prefix(context: Context): this[\"uri\"] { return context.data.prefix; }\r\n    protected set_prefix(val: this[\"prefix\"], c: Context): boolean {\r\n        if (c.data.prefix === val) return true;\r\n        TRANSACTION(this.get_name(c)+'.prefix', ()=>{\r\n            SetFieldAction.new(c.data, 'prefix', val, \"\", false);\r\n        }, c.data.prefix, val)\r\n        return true;\r\n    }\r\n\r\n}\r\n// @RuntimeAccessible('') export class _WPackage extends _WNamedElement { }\r\n// export type WPackage = DPackage | LPackage | _WPackage;\r\nRuntimeAccessibleClass.set_extend(DNamedElement, DPackage);\r\nRuntimeAccessibleClass.set_extend(LNamedElement, LPackage);\r\n\r\n@Leaf\r\n@RuntimeAccessible('DOperation')\r\nexport class DOperation extends DPointerTargetable { // extends DTypedElement\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // static singleton: LOperation;\r\n    // static logic: typeof LOperation;\r\n    // static structure: typeof DOperation;\r\n\r\n    // inherit redefine\r\n    instances!: never[];\r\n    id!: Pointer<DOperation, 1, 1, LObject>;\r\n    annotations: Pointer<DAnnotation, 0, 'N', LAnnotation> = [];\r\n    parent: Pointer<DClass, 0, 'N', LClass> = [];\r\n    father!: Pointer<DClass, 1, 1, LClass>;\r\n    name!: string;\r\n    type!: Pointer<DClassifier, 1, 1, LClassifier>;\r\n    ordered: boolean = true;\r\n    unique: boolean = true;\r\n    lowerBound: number = 0;\r\n    upperBound: number = 1;\r\n    many!: boolean;\r\n    required!: boolean;\r\n    // personal\r\n    exceptions: Pointer<DClassifier, 0, 'N', LClassifier> = [];\r\n    parameters: Pointer<DParameter, 0, 'N', LParameter> = [];\r\n    visibility: AccessModifier = AccessModifier.private;\r\n    implementation!: string;\r\n    allowCrossReference!: boolean;\r\n\r\n    public static new(name?: DNamedElement[\"name\"], type?: DOperation[\"type\"], exceptions: DOperation[\"exceptions\"] = [], father?: DOperation[\"father\"], persist: boolean = true): DOperation {\r\n        if (!name) name = this.defaultname(\"fx_\", father);\r\n        if (!type) type = father;\r\n        return new Constructors(new DOperation('dwc'), father, persist, undefined).DPointerTargetable().DModelElement()\r\n            .DNamedElement(name).DTypedElement(type).DOperation(exceptions).end();\r\n    }\r\n\r\n    static new2(setter: Partial<ObjectWithoutPointers<DOperation>>, father: DOperation[\"father\"], type?: DOperation[\"type\"], name?: string): DOperation {\r\n        if (!name) name = this.defaultname(\"fx_\", father);\r\n        if (!type) type = father;\r\n        return new Constructors(new DOperation('dwc'), father, true).DPointerTargetable().DModelElement()\r\n            .DNamedElement(name).DTypedElement(type).DOperation().end((d)=> { Object.assign(d, setter); });\r\n    }\r\n\r\n    static new3(a: Partial<OperationPointers>, callback: undefined | ((d: DOperation, c: Constructors) => void), persist: boolean = true): DOperation {\r\n        if (!a.name) a.name = this.defaultname(\"fx_\", a.father);\r\n        if (!a.type) a.type = a.father;\r\n        return new Constructors(new DOperation('dwc'), a.father, persist, undefined, a.id).DPointerTargetable().DModelElement()\r\n            .DNamedElement(a.name).DTypedElement(a.type).DOperation().end(callback);\r\n    }\r\n\r\n\r\n}\r\n\r\n@Node\r\n@RuntimeAccessible('LOperation')\r\nexport class LOperation<Context extends LogicContext<DOperation> = any, C extends Context = Context, D extends DOperation = DOperation>  extends LTypedElement { // extends DTypedElement\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    public __raw!: DOperation;\r\n    id!: Pointer<DOperation, 1, 1, LOperation>;\r\n    // static singleton: LOperation;\r\n    // static logic: typeof LOperation;\r\n    // static structure: typeof DOperation;\r\n\r\n    // inherit redefine\r\n    instances!: never[];\r\n    annotations!: LAnnotation[];\r\n    parent!: LClass[];\r\n    father!: LClass;\r\n    name!: string;\r\n    namespace!: string;\r\n    type!: LClassifier;\r\n    ordered: boolean = true;\r\n    unique: boolean = true;\r\n    lowerBound: number = 0;\r\n    upperBound: number = 1;\r\n    many!: boolean;\r\n    required!: boolean;\r\n    // personal\r\n    implementation!: string;\r\n    signatureImplementation!: string; // (param1 /*type*/, param2 = value, ...) => /*return type*/\r\n    exceptions!: LClassifier[];\r\n    parameters!: LParameter[];\r\n    visibility!: AccessModifier;\r\n    allowCrossReference!: boolean;\r\n\r\n\r\n    protected generateEcoreJson_impl(context: Context, loopDetectionObj: Dictionary<Pointer, DModelElement> = {}): Json {\r\n        loopDetectionObj[context.data.id] = context.data;\r\n        const json: Json = {};\r\n        json[ECoreOperation.eParameters] = context.proxyObject.parameters.map( par => par.generateEcoreJson(loopDetectionObj));\r\n        EcoreParser.write(json, ECoreOperation.namee, context.data.name);\r\n        EcoreParser.write(json, ECoreOperation.eType, context.proxyObject.type.typeEcoreString);\r\n        EcoreParser.write(json, ECoreOperation.lowerBound, '' + context.data.lowerBound);\r\n        EcoreParser.write(json, ECoreOperation.upperBound, '' + context.data.upperBound);\r\n        EcoreParser.write(json, ECoreOperation.eexceptions, context.proxyObject.exceptions.map( (l: LClassifier) => l.typeEcoreString).join(' ')); // todo: not really sure it's this format\r\n        EcoreParser.write(json, ECoreOperation.ordered, '' + context.data.ordered);\r\n        EcoreParser.write(json, ECoreOperation.unique, '' + context.data.unique);\r\n        return json; }\r\n\r\n    public duplicate(deep: boolean = true): this {\r\n        return this.cannotCall( ((this.constructor as typeof RuntimeAccessibleClass).cname || this.constructor.name) + \"duplicate()\"); }\r\n    protected get_duplicate(context: Context): ((deep?: boolean) => LOperation) {\r\n        return (deep: boolean = false) => {\r\n            let ret: LOperation = null as any;\r\n            TRANSACTION('duplicate ' + this.get_name(context), ()=>{\r\n                let le: LOperation = context.proxyObject.father.addOperation(context.data.name, context.data.type);\r\n                let de: D = le.__raw as D;\r\n                de.many = context.data.many;\r\n                de.lowerBound = context.data.lowerBound;\r\n                de.upperBound = context.data.upperBound;\r\n                de.ordered = context.data.ordered;\r\n                de.required = context.data.required;\r\n                de.unique = context.data.unique;\r\n                de.visibility = context.data.visibility;\r\n                de.exceptions = context.data.exceptions;\r\n                let we: WOperation = le as any;\r\n                we.annotations = deep ? context.proxyObject.annotations.map(lchild => lchild.duplicate(deep).id) : context.data.annotations;\r\n                we.parameters = deep ? context.proxyObject.parameters.map(lchild => lchild.duplicate(deep).id) : context.data.parameters;\r\n                we.exceptions = context.data.exceptions;\r\n                ret = le;\r\n            })\r\n            return ret; }\r\n    }\r\n\r\n    public addParameter(name?: DParameter[\"name\"], type?: DParameter[\"type\"]): LParameter { return this.cannotCall(\"addParameter\"); }\r\n    protected get_addParameter(context: Context): this[\"addParameter\"] {\r\n        return (name?: DParameter[\"name\"], type?: DParameter[\"type\"]) => LPointerTargetable.fromD(DParameter.new(name, type, context.data.id, true)); }\r\n\r\n    public execute(thiss: LObject, ...params: any): any { return this.cannotCall(\"execute\"); }\r\n    protected get_execute(context: Context): ((thiss: LObject, ...params: any[])=>any) {\r\n        return (thiss: LObject, ...params: any) => {\r\n            let func: Function = eval(this.get_signatureImplementation(context, true) + \" {\\n\"+ context.data.implementation + \"\\n}\");\r\n            func.apply(thiss, params);\r\n        };\r\n    }\r\n    public set_implementation(val: this[\"implementation\"], c: Context): boolean {\r\n        TRANSACTION(this.get_fullname(c)+'.implementation', ()=>{\r\n            SetFieldAction.new(c.data.id, \"implementation\", val, undefined, false);\r\n        })\r\n        return true;\r\n    }\r\n    public get_implementation(context: Context): this[\"implementation\"] { return context.data.implementation; }\r\n    public set_signatureImplementation(val: this[\"signatureImplementation\"], context: Context): boolean { return this.cannotSet(\"signatureImplementation\"); }\r\n    public get_signatureImplementation(context: Context, typedComments: boolean = true): this[\"signatureImplementation\"] {\r\n        let operation = context.proxyObject;\r\n        let typedcommentpre = typedComments ? \"/* :\" : ': ' ;\r\n        let typedcommentpost = typedComments ? \" */\" : '';\r\n        return \"(\" +\r\n            operation.parameters.map(\r\n                (p) => p.name + (p.defaultValue !== undefined ? \"=\" + p.defaultValue : typedcommentpre + p.typeToShortString() + typedcommentpost)\r\n            ).join(\", \")\r\n            + \") => \" +typedcommentpre.replace(\":\", \"\") + operation.type + typedcommentpost;\r\n    }\r\n    public get_signature(context: Context): this[\"signatureImplementation\"] { return this.get_signatureImplementation(context, false); }\r\n\r\n    protected get_children_idlist(context: Context): Pointer<DAnnotation | DClassifier | DParameter, 1, 'N'> {\r\n        return [...super.get_children_idlist(context) as Pointer<DAnnotation | DParameter | DClassifier, 1, 'N'>, ...context.data.exceptions, ...context.data.parameters]; }\r\n\r\n    protected get_exceptions(context: Context): this[\"exceptions\"] {\r\n        return context.data.exceptions.map((pointer) => {\r\n            return LPointerTargetable.from(pointer)\r\n        });\r\n    }\r\n    protected set_exceptions(val: PackArr<this[\"exceptions\"]>, c: Context): boolean {\r\n        const list = val.map((lItem) => { return Pointers.from(lItem) });\r\n        TRANSACTION(this.get_name(c)+'.exceptions', ()=>{\r\n            SetFieldAction.new(c.data, 'exceptions', list, \"\", true);\r\n        })\r\n        return true;\r\n    }\r\n\r\n    protected get_parameters(context: Context): this[\"parameters\"] {\r\n        return context.data.parameters.map((pointer) => {\r\n            return LPointerTargetable.from(pointer)\r\n        });\r\n    }\r\n    protected set_parameters(val: PackArr<this[\"parameters\"]>, c: Context): boolean {\r\n        const list = val.map((lItem) => { return Pointers.from(lItem) });\r\n        const oldList = c.data.parameters;\r\n        const diff = U.arrayDifference(oldList, list);\r\n        TRANSACTION(this.get_name(c)+'.parameters', ()=>{\r\n            SetFieldAction.new(c.data, 'parameters', list, \"\", true);\r\n            for (let id of diff.added) {\r\n                SetFieldAction.new(id, 'father', c.data.id, '', true);\r\n                SetFieldAction.new(id, 'parent', c.data.id, '+=', true);\r\n            }\r\n            for (let id of diff.removed as Pointer<DModelElement>[]) {\r\n                SetFieldAction.new(id, 'father', undefined, '', true);\r\n                const parent = DPointerTargetable.from(id).parent;\r\n                U.arrayRemoveAll(parent, c.data.id);\r\n                SetFieldAction.new(id, 'parent', parent, '', true);\r\n            }\r\n        })\r\n        return true;\r\n    }\r\n\r\n    // protected get_type(context: Context): this[\"type\"] { return context.proxyObject.parameters[0].type; }\r\n    // protected set_type(val: Pack1<this[\"type\"]>, context: Context): this[\"type\"] { return super.set_type(val, context); }\r\n\r\n    _mark(b: boolean, superchildren: LOperation, override: string) {\r\n\r\n    }\r\n\r\n    _canOverride(superchildren: LOperation) {\r\n        return undefined;\r\n    }\r\n\r\n    _canPolymorph(superchildren: LOperation) {\r\n        return undefined;\r\n    }\r\n}\r\nRuntimeAccessibleClass.set_extend(DTypedElement, DOperation);\r\nRuntimeAccessibleClass.set_extend(LTypedElement, LOperation);\r\n\r\n@Leaf\r\n@RuntimeAccessible('DParameter')\r\nexport class DParameter extends DPointerTargetable { // extends DTypedElement\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // static singleton: LParameter;\r\n    // static logic: typeof LParameter;\r\n    // static structure: typeof DParameter;\r\n\r\n    // inherit redefine\r\n    instances!: never[];\r\n    id!: Pointer<DParameter, 1, 1, LParameter>;\r\n    annotations: Pointer<DAnnotation, 0, 'N', LAnnotation> = [];\r\n    parent: Pointer<DOperation, 0, 'N', LOperation> = [];\r\n    father!: Pointer<DOperation, 1, 1, LOperation>;\r\n    name!: string;\r\n    type!: Pointer<DClassifier, 1, 1, LClassifier>;\r\n    ordered: boolean = true;\r\n    unique: boolean = true;\r\n    lowerBound: number = 0;\r\n    upperBound: number = 1;\r\n    many!: boolean;\r\n    required!: boolean;\r\n    defaultValue!: any;\r\n    // personal\r\n    allowCrossReference!: boolean;\r\n\r\n    public static new(name?: DNamedElement[\"name\"], type?: DTypedElement[\"type\"], father?: Pointer, persist: boolean = true): DParameter {\r\n        if (!type) type = LPointerTargetable.from(Selectors.getFirstPrimitiveTypes()).id; // default type as string\r\n        if (!name) name = this.defaultname(\"arg\", father);\r\n        return new Constructors(new DParameter('dwc'), father, persist, undefined).DPointerTargetable().DModelElement()\r\n            .DNamedElement(name).DTypedElement(type).DParameter().end();\r\n    }\r\n\r\n    static new2(setter: Partial<ObjectWithoutPointers<DParameter>>, father: DParameter[\"father\"], type?: DParameter[\"type\"], name?: DParameter[\"name\"]): DParameter {\r\n        if (!name) name = this.defaultname((name || \"arg\"), father);\r\n        return new Constructors(new DParameter('dwc'), father, true).DPointerTargetable().DModelElement()\r\n            .DNamedElement(name).DTypedElement(type).end((d) => { Object.assign(d, setter); });\r\n    }\r\n\r\n    static new3(a: Partial<ParameterPointers>, callback: undefined | ((d: DParameter, c: Constructors) => void), persist: boolean = true): DParameter {\r\n        if (!a.name) a.name = this.defaultname(\"arg\", a.father);\r\n        return new Constructors(new DParameter('dwc'), a.father, persist, undefined, a.id).DPointerTargetable().DModelElement()\r\n            .DNamedElement(a.name).DTypedElement(a.type).DOperation().end(callback);\r\n    }\r\n}\r\n\r\n@Leaf\r\n@RuntimeAccessible('LParameter')\r\nexport class LParameter<Context extends LogicContext<DParameter> = any, C extends Context = Context, D extends DParameter = DParameter>  extends LTypedElement { // extends DTypedElement\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    public __raw!: DParameter;\r\n    id!: Pointer<DParameter, 1, 1, LParameter>;\r\n    // static singleton: LParameter;\r\n    // static logic: typeof LParameter;\r\n    // static structure: typeof DParameter;\r\n\r\n    // inherit redefine\r\n    instances!: never[];\r\n    annotations!: LAnnotation[];\r\n    parent!: LOperation[];\r\n    father!: LOperation;\r\n    name!: string;\r\n    namespace!: string;\r\n    type!: LClassifier;\r\n    ordered: boolean = true;\r\n    unique: boolean = true;\r\n    lowerBound: number = 0;\r\n    upperBound: number = 1;\r\n    many!: boolean;\r\n    required!: boolean;\r\n    // personal\r\n    defaultValue!: any;\r\n    allowCrossReference!: boolean;\r\n\r\n    protected generateEcoreJson_impl(context: Context, loopDetectionObj: Dictionary<Pointer, DModelElement> = {}): Json {\r\n        loopDetectionObj[context.data.id] = context.data;\r\n        const json: Json = {};\r\n        const l = context.proxyObject;\r\n        const d = context.data;\r\n        EcoreParser.write(json, ECoreOperation.lowerBound, '' + d.lowerBound);\r\n        EcoreParser.write(json, ECoreOperation.upperBound, '' + d.upperBound);\r\n        EcoreParser.write(json, ECoreOperation.ordered, '' + d.ordered);\r\n        EcoreParser.write(json, ECoreOperation.unique, '' + d.unique);\r\n        EcoreParser.write(json, ECoreOperation.eType, '' + l.type.typeEcoreString);\r\n        return json; }\r\n\r\n    public duplicate(deep: boolean = true): this {\r\n        return this.cannotCall( ((this.constructor as typeof RuntimeAccessibleClass).cname || this.constructor.name) + \"duplicate()\"); }\r\n    protected get_duplicate(context: Context): ((deep?: boolean) => LParameter) {\r\n        return (deep: boolean = false) => {\r\n            let ret: LParameter = null as any;\r\n            TRANSACTION('duplicate ' + this.get_name(context), ()=>{\r\n                let le: LParameter = context.proxyObject.father.addParameter(context.data.name, context.data.type);\r\n                let de: D = le.__raw as D;\r\n                de.many = context.data.many;\r\n                de.lowerBound = context.data.lowerBound;\r\n                de.upperBound = context.data.upperBound;\r\n                de.ordered = context.data.ordered;\r\n                de.required = context.data.required;\r\n                de.unique = context.data.unique;\r\n                let we: WParameter = le as any;\r\n                we.annotations = deep ? context.proxyObject.annotations.map(lchild => lchild.duplicate(deep).id) : context.data.annotations;\r\n                ret = le;\r\n            })\r\n            return ret; }\r\n    }\r\n}\r\nRuntimeAccessibleClass.set_extend(DTypedElement, DParameter);\r\nRuntimeAccessibleClass.set_extend(LTypedElement, LParameter);\r\nexport class ClassReferences{\r\n    id?: Pack1<LClass>\r\n    parent?: this[\"father\"][];\r\n    father?: Pack1<LPackage>;\r\n    instances?: Pointer<DObject, 0, 'N', LObject> = [];\r\n    operations?: Pointer<DOperation, 0, 'N', LOperation> = [];\r\n    features?: Pointer<DStructuralFeature, 0, 'N', LStructuralFeature> = [];\r\n    references?: Pointer<DReference, 0, 'N', LReference> = [];\r\n    attributes?: Pointer<DAttribute, 0, 'N', LAttribute> = [];\r\n    referencedBy?: Pointer<DReference, 0, 'N', LReference> = [];\r\n    extends?: Pointer<DClass, 0, 'N', LClass> = [];\r\n    extendedBy?: Pointer<DClass, 0, 'N', LClass> = [];\r\n    implements?: Pointer<DClass, 0, 'N', LClass> = [];\r\n    implementedBy?: Pointer<DClass, 0, 'N', LClass> = [];\r\n}\r\n\r\n@RuntimeAccessible('DClass')\r\nexport class DClass extends DPointerTargetable { // extends DClassifier\r\n    // static _super = DClassifier;\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // static singleton: LClass;\r\n    // static logic: typeof LClass;\r\n    // static structure: typeof DClass;\r\n\r\n    // inherit redefine\r\n    // instanceClass: EJavaClass // ?\r\n    // isInstance(object: EJavaObject): boolean; ?\r\n    // getClassifierID(): number;\r\n    id!: Pointer<DClass, 1, 1, LClass>;\r\n    instanceClassName!: string;\r\n    parent: Pointer<DPackage, 0, 'N', LPackage> = [];\r\n    father!: Pointer<DPackage, 1, 1, LPackage>;\r\n    annotations: Pointer<DAnnotation, 0, 'N', LAnnotation> = [];\r\n    name!: string;\r\n    defaultValue!: Pointer<DObject, 1, 1, LObject>[];\r\n    // personal\r\n    // isSuperTypeOf(someClass: DClassifier): boolean { return todoret; }\r\n    // getEstructuralFeatureByID(featureID: number): DStructuralFeature { return todoret; }\r\n    // getEstructuralFeature(featureName: string): DStructuralFeature { return todoret; }\r\n    abstract: boolean = false;\r\n    interface: boolean = false;\r\n    instances: Pointer<DObject, 0, 'N', LObject> = [];\r\n    operations: Pointer<DOperation, 0, 'N', LOperation> = [];\r\n    features: Pointer<DStructuralFeature, 0, 'N', LStructuralFeature> = [];\r\n    references: Pointer<DReference, 0, 'N', LReference> = [];\r\n    attributes: Pointer<DAttribute, 0, 'N', LAttribute> = [];\r\n    referencedBy: Pointer<DReference, 0, 'N', LReference> = [];\r\n    extends: Pointer<DClass, 0, 'N', LClass> = [];\r\n    extendedBy: Pointer<DClass, 0, 'N', LClass> = [];\r\n\r\n    // mia aggiunta:\r\n    isPrimitive!: boolean;\r\n    implements: Pointer<DClass, 0, 'N', LClass> = [];\r\n    implementedBy: Pointer<DClass, 0, 'N', LClass> = [];\r\n    partial!: boolean;\r\n    partialdefaultname!: string;\r\n\r\n    isSingleton!: boolean;\r\n    rootable?: boolean;\r\n    sealed!: Pointer<DClass>[];\r\n    final!: boolean;\r\n    allowCrossReference!: boolean;//for extend\r\n\r\n    // for m1:\r\n    // hideExcessFeatures: boolean = true; // isn't it like partial?? // old comment: se attivo questo e creo una DClass di sistema senza nessuna feature e di nome Object, ho creato lo schema di un oggetto schema-less a cui tutti sono conformi\r\n\r\n    public static new(name?: DNamedElement[\"name\"], isInterface: DClass[\"interface\"] = false, isAbstract: DClass[\"abstract\"] = false, isPrimitive: DClass[\"isPrimitive\"] = false, partial?: DClass[\"partial\"],\r\n                      partialDefaultName?: DClass[\"partialdefaultname\"], father?: Pointer, persist: boolean = true, id?: string): DClass {\r\n        if (!name) name = this.defaultname(\"Concept \", father);\r\n\r\n        // console.log('x6 addchild() new class', {father, arguments, name});\r\n        return new Constructors(new DClass('dwc'), father, persist, undefined, id).DPointerTargetable().DModelElement()\r\n            .DNamedElement(name).DClassifier().DClass(isInterface, isAbstract, isPrimitive, partial, partialDefaultName).end();\r\n    }\r\n\r\n    static new2(setter: Partial<ObjectWithoutPointers<DClass>>, father: DClass[\"father\"], name?: DClass[\"name\"]): DClass {\r\n        if (!name) name = this.defaultname((name || \"Concept \"), father);\r\n        return new Constructors(new DClass('dwc'), father, true, undefined).DPointerTargetable().DModelElement()\r\n            .DNamedElement(name).DClassifier().DClass().end((d) => { Object.assign(d, setter); });\r\n    }\r\n\r\n    static new3(a: Partial<ClassPointers>, callback: undefined | ((d: DClass, c: Constructors) => void), persist: boolean = true): DClass {\r\n        if (!a.name) a.name = this.defaultname(\"Concept \", a.father);\r\n        return new Constructors(new DClass('dwc'), a.father, persist, undefined, a.id).DPointerTargetable().DModelElement()\r\n            .DNamedElement(a.name).DClassifier().DClass().end(callback);\r\n    }\r\n\r\n}\r\n\r\n(window as any).dc = DClassifier;\r\n(window as any).c = DClass;\r\n@Instantiable // (LObject)\r\n@Node\r\n@RuntimeAccessible('LClass')\r\nexport class LClass<D extends DClass = DClass, Context extends LogicContext<DClass> = any, C extends Context = Context>  extends LClassifier{ // extends DClassifier\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    public __raw!: DClass;\r\n    id!: Pointer<DClass, 1, 1, LClass>;\r\n    // static singleton: LClass;\r\n    // static logic: typeof LClass;\r\n    // static structure: typeof DClass;\r\n\r\n    // inherit redefine\r\n    // instanceClass: EJavaClass // ?\r\n    // isInstance(object: EJavaObject): boolean; ?\r\n    // getClassifierID(): number;\r\n    instanceClassName!: string;\r\n    parent!: LPackage[];\r\n    father!: LPackage;\r\n    annotations!: LAnnotation[];\r\n    name!: string;\r\n    namespace!: string;\r\n    defaultValue!: LObject[];\r\n    // personal\r\n    // isSuperTypeOf(someClass: DClassifier): boolean { return todoret; }\r\n    // getEstructuralFeatureByID(featureID: number): DStructuralFeature { return todoret; }\r\n    // getEstructuralFeature(featureName: string): DStructuralFeature { return todoret; }\r\n    abstract!: boolean;\r\n    interface!: boolean;\r\n    instances!: LObject[];\r\n    operations!: LOperation[];\r\n    features!: LStructuralFeature[];\r\n    references!: LReference[];\r\n    attributes!: LAttribute[];\r\n    referencedBy!: LReference[];\r\n    extends!: LClass[];\r\n    __info_of__extends: Info = {type:\"LClass[]\", txt: \"classes directly extended by this. check also: \\\"superclasses\\\".\"}\r\n    extendsChain!: LClass[];  // list of all super classes (father, father of father, ...)  todo: isn't this the same as \"superclasses\" ? check implementation differeces, eventually remove one.\r\n    extendedBy!: LClass[];\r\n    nodes!: LGraphElement[]; // ipotesi, non so se tenerlo\r\n    allowCrossReference!: boolean;\r\n    sealed!: LClass[];\r\n    __info_of__sealed: Info = {type: 'LClass[]', txt:'A sealed class can specify a list of other classes that are allowed to extend it.' +\r\n            '\\n A sealed class that does not allow any class to extend it is a \"final\" class.'}\r\n\r\n    final!: boolean;\r\n    __info_of__final: Info = {type: 'boolean', txt:'A final class cannot be extended.'}\r\n\r\n    rootable!: boolean;\r\n    __info_of__roootable: Info = {type: 'boolean', txt:'Specifies if the class can become a m1 model root, overriding the usual restriction of not being target of a containment reference.'}\r\n\r\n    isSingleton!: boolean;\r\n    __info_of__singleton: Info = {type: 'boolean', txt:'A singleton element is always present exactly 1 time in every model.' +\r\n            '\\n A single instance is created dynamically and cannot be created by the user.'}\r\n\r\n    // fittizi:\r\n\r\n    instantiable!: boolean;\r\n    __info_of__intantiable: Info = {type: 'boolean', txt:'Whether the class can be instantiated.'}\r\n\r\n    aggregated!: boolean;\r\n    __info_of__aggregated: Info = {type: 'boolean', txt:'Whether the class is targeted by an aggregation relationship.'}\r\n\r\n    composed!: boolean;\r\n    __info_of__composed: Info = {type: 'boolean', txt:'Whether the class is targeted by a composition relationship.'}\r\n\r\n    contained!: boolean;\r\n    __info_of__contained: Info = {type: 'boolean', txt:'Whether the class is targeted by a composition or aggregation relationship.'}\r\n\r\n    public superclasses!: LClass[];\r\n    __info_of__superclasses: Info = {type:\"LClass[]\", txt: \"all classes directly and indirectly extended by this. same as check also: \\\"extends\\\".\"}\r\n    public allSubClasses!: LClass[];\r\n\r\n    partialdefaultname!: string;\r\n    isPrimitive!: boolean;\r\n    isClass!: boolean; // false if it's primitive type\r\n    isEnum!: false;\r\n    implements: Pointer<DClass, 0, 'N', LClass> = [];  //todo: interface\r\n    implementedBy: Pointer<DClass, 0, 'N', LClass> = [];\r\n\r\n    ownAttributes!: LAttribute[];\r\n    ownReferences!: LReference[];\r\n    ownOperations!: LOperation[];\r\n    ownChildren!: (LStructuralFeature|LOperation)[];\r\n\r\n    inheritedAttributes!: LAttribute[];\r\n    inheritedReferences!: LReference[];\r\n    inheritedOperations!: LOperation[];\r\n    inheritedChildren!: (LStructuralFeature|LOperation)[];\r\n\r\n    allAttributes!: LAttribute[];\r\n    allReferences!: LReference[];\r\n    allOperations!: LOperation[]; // includes inherited and shadowed features\r\n    allChildren!: (LStructuralFeature|LOperation)[];\r\n\r\n\r\n\r\n    // utilities to go down in the tree (plural names)\r\n    exceptions!: LClassifier[] | null;\r\n    parameters!: LParameter[] | null;\r\n    // [`@${string}`]: LModelElement; todo: try to put it\r\n\r\n\r\n    validTargetsJSX!: JSX.Element[];\r\n    get_validTargetsJSX(c: Context): this['validTargetsJSX'] {\r\n        let opts: MultiSelectOptGroup[] = [];\r\n        this.get_validTargets(c, opts);\r\n        return UX.options(opts);\r\n    }\r\n    validTargetOptions!: MultiSelectOptGroup[];\r\n    get_validTargetOptions(c: Context): this['validTargetOptions'] {\r\n        let opts: MultiSelectOptGroup[] = [];\r\n        this.get_validTargets(c, opts);\r\n        return opts;\r\n    }\r\n    validTargets!: LClass[];\r\n    get_validTargets(c: Context, out?: MultiSelectOptGroup[]): this['validTargets'] {\r\n        let lclass: LClass = c.proxyObject as any;\r\n        // let extendOptions: {value: string, label: string}[] lclass.extends.map(lsubclass=> ({value: lsubclass.id, label: lsubclass.name}));\r\n        let m2: LModel = lclass.model;\r\n        let dclass = c.data;\r\n        let extendsarr = lclass.extendsChain.map(l=>l.id); //dclass.extends;\r\n        let pkgs = dclass.allowCrossReference ? m2.allCrossSubPackages : m2.allSubPackages;\r\n        let extendValue: {value: string, label: string}[] = [];\r\n        if (!out) out = [];\r\n        let ret: LClass[] = [];\r\n        out.push(...pkgs.map(p => (\r\n            {label: p.fullname, options: p.classes.map(c => {\r\n                    let opt = {value:c.id, label: c.name};\r\n                    if (opt.value === dclass.id) return undefined;\r\n                    if (!extendsarr.includes(opt.value)) return opt;\r\n                    extendValue.push(opt);\r\n                    ret.push(c);\r\n                    return undefined;\r\n                }).filter(e=>!!e) as {value: string, label: string}[]})));\r\n        return ret;\r\n    }\r\n\r\n    get_childNames(c: Context): string[] { return this.get_allChildren(c).map( c => c.name).filter(c=>!!c) as string[]; }\r\n    //get_isSealed(c: Context): LClass['sealed'] { return this.get_sealed(c); }\r\n    get_sealed(c: Context): LClass['sealed'] { return LPointerTargetable.wrapAll(c.data.sealed); }\r\n    set_sealed(val: PackArr<LClass>, c: Context): boolean{\r\n        if (!val) val = [];\r\n        else if (!Array.isArray(val)) val = [val];\r\n        const ptrs = [...new Set(val.map((val) => { return val && Pointers.from(val) }).filter(e=>!!e))];\r\n        if (Uarr.equalsUnsorted(c.data.sealed, ptrs)) return true;\r\n        TRANSACTION(this.get_name(c)+'.sealed ', ()=>{\r\n            SetFieldAction.new(c.data, 'sealed', ptrs, '', true);\r\n            if (ptrs.length) {\r\n                SetFieldAction.new(c.data, 'isSingleton', false);\r\n                SetFieldAction.new(c.data, 'final', false);\r\n            } else {\r\n                SetFieldAction.new(c.data, 'final', true);\r\n            }\r\n        });\r\n        return true;\r\n    }\r\n    get_isFinal(c: Context): LClass['final'] { return this.get_final(c); }\r\n    get_final(c: Context): LClass['final']{ return c.data.final; }\r\n    set_final(val: boolean, c: Context): boolean{\r\n        val = !!val;\r\n        if (val === c.data.final) return true;\r\n        if (c.data.extendedBy.length > 0) { U.alert('e', 'Class cannot become final as it is currently extended.', 'Remove the subclasses before.'); return true; }\r\n        TRANSACTION(this.get_name(c)+'.final', ()=>{\r\n            SetFieldAction.new(c.data, 'final', val);\r\n            SetFieldAction.new(c.data, 'sealed', [], '', true);\r\n            if (!val) SetFieldAction.new(c.data, 'isSingleton', false);\r\n        }, c.data.final, val);\r\n        return true;\r\n    }\r\n    get_isSingleton(c: Context): LClass['isSingleton'] { return this.get_singleton(c); }\r\n    get_singleton(c: Context): LClass['isSingleton']{ return c.data.isSingleton; }\r\n    set_isSingleton(val: boolean, c: Context): boolean{ return this.set_singleton(val, c); }\r\n    set_singleton(val: boolean, c: Context): boolean{\r\n        val = !!val;\r\n        if (c.data.instances.length > 1) { U.alert('e', 'Class cannot become a singleton since there are multiple instances already.','Delete some and retry.'); return true; }\r\n        if (c.data.extendedBy.length > 0) { U.alert('e', 'Class cannot become a singleton unless is also final, and is currently extended.', 'Remove the subclasses before.'); return true; }\r\n        TRANSACTION(this.get_name(c)+'.singleton', ()=>{\r\n            SetFieldAction.new(c.data, 'isSingleton', val);\r\n            if (val) {\r\n                SetFieldAction.new(c.data, 'final', true);\r\n                let m2 = this.get_model(c);\r\n                let instances: LObject[] = this.get_instances(c);\r\n                let modelsWithInstance: Pointer<DModel>[] = instances.map( o => o.model?.id );\r\n                for (let m1 of m2.instances) {\r\n                    if (modelsWithInstance.includes(m1.id)) continue;\r\n                    m1.addObject({name: c.data.name}, c.data, true);\r\n                }\r\n            }\r\n        }, c.data.isSingleton, val);\r\n        return c.data.final;\r\n    }\r\n    get_instantiable(c: Context): LClass['instantiable']{ return !(c.data.abstract || c.data.interface || c.data.isSingleton); }\r\n    get_isInstantiable(c: Context): LClass['instantiable'] { return this.get_instantiable(c); }\r\n    get_isComposed(c: Context): LClass['composed'] { return this.get_composed(c); }\r\n    get_isAggregated(c: Context): LClass['aggregated'] { return this.get_aggregated(c); }\r\n    get_isContained(c: Context): LClass['contained'] { return this.get_contained(c); }\r\n    get_contained(c: Context): LClass['contained']{\r\n        let refs = this.get_referencedBy(c);\r\n        for (let r of refs) { if (r && (r.aggregation || r.composition)) return true; }\r\n        return false;\r\n    }\r\n    get_aggregated(c: Context): LClass['aggregated']{\r\n        let refs = this.get_referencedBy(c);\r\n        for (let r of refs) if (r&&r.aggregation) return true;\r\n        return false;\r\n    }\r\n    get_composed(c: Context): LClass['composed']{\r\n        let refs = this.get_referencedBy(c);\r\n        for (let r of refs) if (r&&r.composition) return true;\r\n        return false;\r\n    }\r\n    get_isRootable(c: Context): LClass['rootable'] { return this.get_rootable(c); }\r\n    protected get_rootable(c: Context): this[\"rootable\"] {\r\n        if (c.data.rootable !== undefined) return c.data.rootable;\r\n        else return this.get_instantiable(c) && !this.get_isComposed(c);\r\n    }\r\n    protected set_rootable(val: this[\"rootable\"], c: Context): boolean {\r\n        if (c.data.rootable === val) return true;\r\n\r\n        TRANSACTION(this.get_name(c)+'.rootable', ()=>{\r\n            SetFieldAction.new(c.data, 'rootable', val);\r\n        }, c.data.rootable, val);\r\n        return true;\r\n    }\r\n\r\n    protected get_ownAttributes(context: Context): this['ownAttributes'] {\r\n        return LAttribute.fromPointer(context.data.attributes);\r\n    }\r\n    protected get_ownReferences(context: Context): this['ownReferences'] {\r\n        return LReference.fromPointer(context.data.references);\r\n    }\r\n    protected get_ownOperations(context: Context): this['ownOperations'] {\r\n        return LOperation.fromPointer(context.data.operations);\r\n    }\r\n    protected get_ownChildren(context: Context): this['ownChildren'] {\r\n        return U.arrayMergeInPlace<any>(this.get_ownAttributes(context), this.get_ownReferences(context),\r\n            this.get_ownOperations(context));\r\n    }\r\n\r\n    allExtends!: this['extendsChain'];\r\n    get_allExtends(c:Context): this['extendsChain']{ return this.get_extendsChain(c); }\r\n    private get_extendsChain(context: Context): this['extendsChain'] {\r\n        let targets: LClass[] = LClass.fromArr(context.data.extends);\r\n        let alreadyParsed: Dictionary<Pointer, LClass> = {};\r\n        while (targets.length) {\r\n            let nextTargets = [];\r\n            for (let target of targets){\r\n                if (alreadyParsed[target.id]) continue;\r\n                alreadyParsed[target.id] = target;\r\n                for (let next of target.extends) nextTargets.push(next);\r\n            }\r\n            targets = nextTargets;\r\n        }\r\n        return Object.values(alreadyParsed);\r\n    }\r\n\r\n    public isSubClassOf(superClass: LClass, returnIfSameClass: boolean = true): boolean { return this.cannotCall(\"isSubClassOf\"); }\r\n    public isSuperClassOf(subClass: LClass, returnIfSameClass: boolean = true): boolean { return this.cannotCall(\"isSuperClassOf\"); }\r\n    protected get_isSubClassOf(c: Context): ((superClass: LClass, returnIfSameClass?: boolean) => boolean) {\r\n        return (superClass?: LClass, returnIfSameClass: boolean = true) => {\r\n            superClass = LPointerTargetable.wrap(superClass);\r\n            if (!superClass) return false;\r\n            if (superClass.id === c.data.id) return returnIfSameClass;\r\n            for (let subclass of this.get_extendsChain(c)) {\r\n                if (subclass.id === superClass.id) return true;\r\n            }\r\n            return false;\r\n        }\r\n    }\r\n    protected get_isSuperClassOf(c: Context): ((subClass: LClass, returnIfSameClass?: boolean) => boolean) {\r\n        return (subClass: LClass, returnIfSameClass: boolean = true) => {\r\n            if (!subClass) return false;\r\n            if (subClass.id === c.data.id) return returnIfSameClass;\r\n            return subClass.isSubClassOf(c.proxyObject, returnIfSameClass);\r\n        }\r\n    }\r\n\r\n    protected get_inheritedAttributes(context: Context): this['inheritedAttributes'] {\r\n        return this.get_extendsChain(context).flatMap((superClass) => superClass.ownAttributes);\r\n    }\r\n    protected get_inheritedReferences(context: Context): this['inheritedReferences'] {\r\n        return this.get_extendsChain(context).flatMap((superClass) => superClass.ownReferences);\r\n    }\r\n    protected get_inheritedOperations(context: Context): this['inheritedOperations'] {\r\n        return this.get_extendsChain(context).flatMap((superClass) => superClass.ownOperations);\r\n    }\r\n    protected get_inheritedChildren(context: Context): this['inheritedChildren'] {\r\n        return U.arrayMergeInPlace<any>(this.get_inheritedAttributes(context), this.get_inheritedReferences(context),\r\n            this.get_inheritedOperations(context));\r\n    }\r\n\r\n    protected get_allAttributes(context: Context): this['allAttributes'] {\r\n        return U.arrayMergeInPlace<any>(this.get_ownAttributes(context), this.get_inheritedAttributes(context));\r\n    }\r\n    protected get_allReferences(context: Context): this['allReferences'] {\r\n        return U.arrayMergeInPlace<any>(this.get_ownReferences(context), this.get_inheritedReferences(context));\r\n    }\r\n    protected get_allOperations(context: Context): this['allOperations'] {\r\n        return U.arrayMergeInPlace<any>(this.get_ownOperations(context), this.get_inheritedOperations(context));\r\n    }\r\n    protected get_allChildren(context: Context): this['allChildren'] {\r\n        return U.arrayMergeInPlace<any>(this.get_ownChildren(context), this.get_inheritedChildren(context));\r\n    }\r\n\r\n    protected generateEcoreJson_impl(context: Context, loopDetectionObj: Dictionary<Pointer, DModelElement> = {}): Json {\r\n        loopDetectionObj[context.data.id] = context.data;\r\n        const json: GObject = {};\r\n        const featurearr: Json[] = [];\r\n        const operationsarr: Json[] = [];\r\n        let supertypesstr = [];\r\n        const d = context.data;\r\n        const l = context.proxyObject;\r\n        for (let att of l.attributes) { featurearr.push(att.generateEcoreJson(loopDetectionObj)); }\r\n        for (let ref of l.references) { featurearr.push(ref.generateEcoreJson(loopDetectionObj)); }\r\n        for (let op of l.operations) { operationsarr.push(op.generateEcoreJson(loopDetectionObj)); }\r\n\r\n        json[ECoreClass.xsitype] = 'ecore:EClass';\r\n        json[ECoreClass.namee] = d.name;\r\n        json[ECoreClass.interface] = U.toBoolString(d.interface, false);\r\n        json[ECoreClass.abstract] = U.toBoolString(d.abstract, false);\r\n        if (d.instanceClassName) json[ECoreClass.instanceTypeName] = d.instanceClassName;\r\n        json[ECoreClass.eSuperTypes] = l.extends.map( superclass => superclass.typeEcoreString).join(\" \");\r\n        if (featurearr) json[ECoreClass.eStructuralFeatures] = featurearr;\r\n        if (operationsarr) json[ECoreClass.eOperations] = operationsarr;\r\n        return json; }\r\n\r\n\r\n    public duplicate(deep: boolean = true): this {\r\n        return this.cannotCall( ((this.constructor as typeof RuntimeAccessibleClass).cname || this.constructor.name) + \"duplicate()\"); }\r\n    protected get_duplicate(context: Context): ((deep?: boolean) => LClass) {\r\n        return (deep: boolean = false) => {\r\n            let ret: LClass = null as any;\r\n            TRANSACTION('duplicate '+this.get_name(context), () => {\r\n                let le: LClass = context.proxyObject.father.addClass(context.data.name, context.data.interface, context.data.abstract, context.data.isPrimitive);\r\n                let de: D = le.__raw as D;\r\n                // de.hideExcessFeatures = context.data.hideExcessFeatures;\r\n                let we: WClass = le as any;\r\n                we.defaultValue = context.data.defaultValue;\r\n                we.extends = context.data.extends;\r\n                we.attributes = deep ? context.proxyObject.attributes.map(lchild => lchild.duplicate(deep).id) : context.data.attributes;\r\n                we.references = deep ? context.proxyObject.references.map(lchild => lchild.duplicate(deep).id) : context.data.references;\r\n                we.operations = deep ? context.proxyObject.operations.map(lchild => lchild.duplicate(deep).id) : context.data.operations;\r\n                ret = le; // set ret = le only if the transaction is complete.\r\n            });\r\n            return ret; }\r\n    }\r\n\r\n    protected get_children_idlist(context: Context): Pointer<DAnnotation | DStructuralFeature | DOperation, 1, 'N'> {\r\n        return [...super.get_children_idlist(context) as Pointer<DAnnotation | DStructuralFeature, 1, 'N'>,\r\n            ...context.data.attributes,\r\n            ...context.data.references,\r\n            ...context.data.operations];\r\n    }\r\n\r\n\r\n    protected set_name(val: this[\"name\"], context: Context): boolean {\r\n        if (context.data.name === val) return true;\r\n        super.set_name(val, context);\r\n        SetRootFieldAction.new('ClassNameChanged.'+context.data.id, val, '', false); // it is pointer, but related to transient stuff, so don't need pointedBy's\r\n        return true;\r\n    }\r\n\r\n    partial!: boolean;\r\n    __info_of__partial: Info = {type: 'boolean', txt:'A partial object have can add unlisted features as a shapeless (schemaless) object does,' +\r\n            ' on top of a set of fixed listed features.'}\r\n    protected set_partial(val: D[\"partial\"], c: Context): boolean {\r\n        val = !!val;\r\n        if (val === c.data.partial) return true;\r\n        TRANSACTION(this.get_name(c)+'.partial', ()=>{\r\n            SetFieldAction.new(c.data.id, \"partial\", val);\r\n        }, c.data.partial, val)\r\n        return true;\r\n    }\r\n    protected get_partial(context: Context): D[\"partial\"] { return context.data.partial; }\r\n\r\n    protected set_partialdefaultname(val: D[\"partialdefaultname\"], c: Context): boolean {\r\n        if (val === c.data.partialdefaultname) return true;\r\n        TRANSACTION(this.get_name(c)+'.partialdefaultname', ()=>{\r\n            SetFieldAction.new(c.data.id, \"partialdefaultname\", val, undefined, false);\r\n        })\r\n        return true;\r\n    }\r\n    protected get_partialdefaultname(context: Context): D[\"partialdefaultname\"] { return context.data.partialdefaultname; }\r\n\r\n    public addAttribute(name?: DAttribute[\"name\"], type?: DAttribute[\"type\"]): LAttribute { return this.cannotCall(\"addAttribute\"); }\r\n    protected get_addAttribute(context: Context): this[\"addAttribute\"] {\r\n        return (name?: DAttribute[\"name\"], type?: DAttribute[\"type\"]) => LPointerTargetable.fromD(DAttribute.new(name, type, context.data.id, true));\r\n    }\r\n\r\n    public addReference(name?: DReference[\"name\"], type?: DReference[\"type\"]): LReference { return this.cannotCall(\"addReference\"); }\r\n    protected get_addReference(context: Context): this[\"addReference\"] {\r\n        return (name?: DReference[\"name\"], type?: DReference[\"type\"]) => LPointerTargetable.fromD(DReference.new(name, type, context.data.id, true));\r\n    }\r\n\r\n    public addOperation(name?: DOperation[\"name\"], type?: DOperation[\"type\"]): LOperation { return this.cannotCall(\"addOperation\"); }\r\n    protected get_addOperation(context: Context): this[\"addOperation\"] {\r\n        return (name?: DOperation[\"name\"], type?: DOperation[\"type\"]) => LPointerTargetable.fromD(DOperation.new(name, type, [], context.data.id, true));\r\n    }\r\n\r\n\r\n    protected get_abstract(context: Context): this[\"abstract\"] { return context.data.abstract; }\r\n    protected set_abstract(val: this[\"abstract\"], c: Context): boolean {\r\n        const data = c.data;\r\n        val = !!val;\r\n        if (val === c.data.abstract) return true;\r\n        if(val && data.instances.length > 0) {\r\n            U.alert('e', 'Cannot change the abstraction level since there are instances.','');\r\n        } else {\r\n            TRANSACTION(this.get_name(c)+'.abstract', ()=>{\r\n                SetFieldAction.new(data, 'abstract', val);\r\n            }, c.data.abstract, val)\r\n        }\r\n        return true;\r\n    }\r\n\r\n    protected set_isPrimitive(val: this[\"isPrimitive\"], c: Context): boolean {\r\n        val = !!val;\r\n        if (val === c.data.isPrimitive) return true;\r\n        TRANSACTION(this.get_name(c)+'.isPrimitive', ()=>{\r\n            SetFieldAction.new(c. data, 'isPrimitive', val);\r\n        })\r\n        return true;\r\n    }\r\n    // get is in classifier with all other \"type\"s getter and setter\r\n\r\n    protected get_interface(context: Context): this[\"interface\"] { return context.data.interface; }\r\n    protected set_interface(val: this[\"interface\"], c: Context): boolean {\r\n        val = !!val;\r\n        if (c.data.interface === val) return true;\r\n        if (val && c.data.instances.length > 0) {\r\n            U.alert('e', 'Class cannot become an interface since there are instances.', '');\r\n        } else {\r\n            TRANSACTION(this.get_name(c)+'.interface', ()=>{\r\n                SetFieldAction.new(c.data, 'interface', val);\r\n            }, c.data.interface, val)\r\n        }\r\n        return true;\r\n    }\r\n\r\n    allInstances!: LObject[];\r\n    __info_of__allInstances: Info = {type: 'LObject[]', txt: \"Instances in m1 of this class and of all subclasses.\"};\r\n    protected get_allInstances(context: Context): this[\"instances\"] {\r\n        let sc = this.get_allSubClasses(context, true);\r\n        return sc.flatMap( (c) => c.instances);\r\n    }\r\n\r\n    protected get_instances(context: Context): this[\"instances\"] {\r\n        return context.data.instances.map((pointer) => {\r\n            return LPointerTargetable.from(pointer)\r\n        });\r\n    }\r\n    protected set_instances(val: PackArr<this[\"instances\"]>, c: Context): boolean {\r\n        const list = val.map((lItem) => { return Pointers.from(lItem) });\r\n        TRANSACTION(this.get_name(c)+'.instances', ()=>{\r\n            SetFieldAction.new(c.data, 'instances', list, \"\", true);\r\n        })\r\n        return true;\r\n    }\r\n\r\n    protected get_operations(context: Context): this[\"operations\"] {\r\n        return context.data.operations.map((pointer) => {\r\n            return LPointerTargetable.from(pointer)\r\n        });\r\n    }\r\n    protected set_operations(val: PackArr<this[\"operations\"]>, context: Context): boolean {\r\n        const list = val.map((lItem) => { return Pointers.from(lItem) });\r\n        const oldList = context.data.operations;\r\n        const diff = U.arrayDifference(oldList, list);\r\n        TRANSACTION(this.get_name(context)+'.operations', ()=>{\r\n            SetFieldAction.new(context.data, 'operations', list, \"\", true);\r\n            for (let id of diff.added) {\r\n                SetFieldAction.new(id, 'father', context.data.id, '', true);\r\n                SetFieldAction.new(id, 'parent', context.data.id, '+=', true);\r\n            }\r\n            for (let id of diff.removed as Pointer<DModelElement>[]) {\r\n                SetFieldAction.new(id, 'father', undefined, '', true);\r\n                const parent = DPointerTargetable.from(id).parent;\r\n                U.arrayRemoveAll(parent, context.data.id);\r\n                SetFieldAction.new(id, 'parent', parent, '', true);\r\n            }\r\n        })\r\n        return true;\r\n    }\r\n\r\n    protected get_features(context: Context): this[\"features\"] {\r\n        return context.data.features.map((pointer) => { return LPointerTargetable.from(pointer) });\r\n    }\r\n    protected set_features(val: PackArr<this[\"features\"]>, context: Context): boolean {\r\n        const list = val.map((lItem) => { return Pointers.from(lItem) });\r\n        const oldList = context.data.features;\r\n        const diff = U.arrayDifference(oldList, list);\r\n        let le: this = null as any;\r\n        TRANSACTION(this.get_name(context)+'.features', ()=>{\r\n            SetFieldAction.new(context.data, 'features', list, \"\", true);\r\n            for (let id of diff.added) {\r\n                SetFieldAction.new(id, 'father', context.data.id, '', true);\r\n                SetFieldAction.new(id, 'parent', context.data.id, '+=', true);\r\n            }\r\n            for (let id of diff.removed as Pointer<DModelElement>[]) {\r\n                SetFieldAction.new(id, 'father', undefined, '', true);\r\n                const parent = DPointerTargetable.from(id).parent;\r\n                U.arrayRemoveAll(parent, context.data.id);\r\n                SetFieldAction.new(id, 'parent', parent, '', true);\r\n            }\r\n        })\r\n        return true;\r\n    }\r\n\r\n    protected get_references(context: Context): this[\"references\"] {\r\n        return context.data.references.map((pointer) => {\r\n            return LPointerTargetable.from(pointer)\r\n        });\r\n    }\r\n    protected set_references(val: PackArr<this[\"references\"]>, context: Context): boolean {\r\n        const list = val.map((lItem) => { return Pointers.from(lItem) });\r\n        const oldList = context.data.references;\r\n        const diff = U.arrayDifference(oldList, list);\r\n        TRANSACTION(this.get_name(context)+'.references', ()=>{\r\n            SetFieldAction.new(context.data, 'references', list, \"\", true);\r\n            for (let id of diff.added) {\r\n                SetFieldAction.new(id, 'father', context.data.id, '', true);\r\n                SetFieldAction.new(id, 'parent', context.data.id, '+=', true);\r\n            }\r\n            for (let id of diff.removed as Pointer<DModelElement>[]) {\r\n                SetFieldAction.new(id, 'father', undefined, '', true);\r\n                const parent = DPointerTargetable.from(id).parent;\r\n                U.arrayRemoveAll(parent, context.data.id);\r\n                SetFieldAction.new(id, 'parent', parent, '', true);\r\n            }\r\n        })\r\n        return true;\r\n    }\r\n\r\n    protected get_attributes(context: Context): this[\"attributes\"] {\r\n        return context.data.attributes.map((pointer) => {\r\n            return LPointerTargetable.from(pointer)\r\n        });\r\n    }\r\n    protected set_attributes(val: PackArr<this[\"attributes\"]>, context: Context): boolean {\r\n        const list = val.map((lItem) => { return Pointers.from(lItem) });\r\n        const oldList = context.data.attributes;\r\n        const diff = U.arrayDifference(oldList, list);\r\n        TRANSACTION(this.get_name(context)+'.attributes', ()=>{\r\n            SetFieldAction.new(context.data, 'attributes', list, \"\", true);\r\n            for (let id of diff.added) {\r\n                SetFieldAction.new(id, 'father', context.data.id, '', true);\r\n                SetFieldAction.new(id, 'parent', context.data.id, '+=', true);\r\n            }\r\n            for (let id of diff.removed as Pointer<DModelElement>[]) {\r\n                SetFieldAction.new(id, 'father', undefined, '', true);\r\n                const parent = DPointerTargetable.from(id).parent;\r\n                U.arrayRemoveAll(parent, context.data.id);\r\n                SetFieldAction.new(id, 'parent', parent, '', true);\r\n            }\r\n        })\r\n        return true;\r\n    }\r\n\r\n    public get_referencedBy(c: Context): this[\"referencedBy\"] {\r\n        let keystr: string;\r\n        if (c.data.className === 'DClass'){ keystr = '.type'; }\r\n        // @ts-ignore\r\n        else if (c.data.className === 'DObject'){ return LObject.singleton.get_referencedBy(c); }\r\n        // else if (c.data.className === 'DObject'){ keystr = '.values'; } nope, model also have .values+=\r\n        // and lvalues might be under either \".values\" | \".values+=\" | \".values.0\" (in rightbar)\r\n        else return [];\r\n\r\n        let ptrs = c.data.pointedBy.map(e=> {\r\n            /*\r\n            if (c.data.className === 'DObject'){\r\n                let parent = this.get_father(c);\r\n                return parent.className === 'DValue' ? [parent] : [];\r\n            }*/\r\n            let index = e.source.lastIndexOf(keystr);\r\n            if (index !== (e.source.length - keystr.length)) return null;\r\n            return e.source.substring('idlookup.'.length, index);\r\n\r\n        }).filter(e=>!!e);\r\n\r\n        return LPointerTargetable.fromArr(ptrs);\r\n        // return context.data.referencedBy.map((pointer) => LPointerTargetable.from(pointer) );\r\n    }\r\n    protected set_referencedBy(val: PackArr<this[\"referencedBy\"]>, context: Context): boolean {\r\n        return this.cannotSet('referencedBy', 'is automatically updated through pointedBy');\r\n        /*if (!val) val = [];\r\n        else if (!Array.isArray(val)) val = [val];\r\n        const ptrs = [...new Set(val.map((val) => { return val && Pointers.from(val) })).filter(e=>!!e)];\r\n        SetFieldAction.new(context.data, 'referencedBy', ptrs, \"\", true);\r\n        return true;*/\r\n    }\r\n\r\n    protected get_extends(context: Context): this[\"extends\"] {\r\n        return context.data.extends.map((pointer) => {\r\n            return LPointerTargetable.from(pointer)\r\n        });\r\n    }\r\n    protected set_extends(val: PackArr<this[\"extends\"]>, c: Context): boolean {\r\n        if (!val) val = [];\r\n        else if (!Array.isArray(val)) val = [val];\r\n        let ptrs: Pointer[] = [...new Set(val.map((val) => { return val && Pointers.from(val) }).filter(e=>!!e))];\r\n        let diff = Uarr.arrayDifference(c.data.extends, ptrs);\r\n        let invalid: GObject[] = [];\r\n        let invalidPtrs: Pointer[] = [];\r\n        for (let ptr of diff.added){\r\n            let reason: GObject = {ptr};\r\n            if (this.get_canExtend(c)(ptr as any, reason as any)) continue;\r\n            invalid.push(reason);\r\n            invalidPtrs.push(ptr);\r\n        }\r\n        if (invalid.length) {\r\n            Log.ww('tried to add invalid extends, they were ignored:', invalid);\r\n            ptrs = ptrs.filter(e=>!invalid.includes(e));\r\n        }\r\n        if (diff.removed.length === 0 && diff.added.length === invalid.length) return true;\r\n\r\n        TRANSACTION(this.get_name(c)+'.extends', ()=>{\r\n            SetFieldAction.new(c.data, 'extends', ptrs, \"\", true);\r\n        }, undefined, ('+'+diff.added.length+', -'+diff.removed.length))\r\n        return true;\r\n    }\r\n\r\n    add_extends(val: PackArr<this[\"extends\"]>): void { this.cannotCall('add_extends'); }\r\n    get_add_extends(val: PackArr<this[\"extends\"]>, context: Context): this['add_extends'] {\r\n        return ((val: string[])=>this.impl_add_extends(val as any, context)) as any;\r\n    }\r\n    impl_add_extends(val: PackArr<this[\"extends\"]>, c: Context): void {\r\n        if (!val) val = [];\r\n        else if (!Array.isArray(val)) val = [val];\r\n        if (!val.length) return;\r\n        let ptrs = [...new Set(val.map((val) => { return val && Pointers.from(val) }).filter(e=>!!e && !c.data.extends.includes(e)))];\r\n\r\n        ptrs = ptrs.filter(ptr => this.get_canExtend(c)(ptr as any, {} as any));\r\n        if (!ptrs.length) return;\r\n        // todo: extendedby? or make it derived from pointedby\r\n\r\n        TRANSACTION(this.get_name(c)+'.extends+=', ()=>{\r\n            SetFieldAction.new(c.data, 'extends', [...c.data.extends, ...ptrs], '', true);\r\n        }, undefined, ptrs.length)\r\n    }\r\n\r\n    protected remove_extends(val: PackArr<this[\"extends\"]> | number | number[], c: Context): void {\r\n        if (!val) val = [];\r\n        else if (!Array.isArray(val)) val = [val];\r\n        if (!val.length) return;\r\n        let finalVal: D[\"extends\"];\r\n        if (typeof val[0] === \"number\") { finalVal = c.data.extends.filter((elem,index,arr)=> { return (val as any[]).includes(index); }); }\r\n        else {\r\n            finalVal = [...c.data.extends];\r\n            let ptrs: Pointer<DClass> = Pointers.from(val as PackArr<this[\"extends\"]>) as any;\r\n            for (let v of ptrs) { U.arrayRemoveAll(finalVal, v); }\r\n        }\r\n\r\n        TRANSACTION(this.get_name(c)+'.extends-=', ()=>{\r\n            SetFieldAction.new(c.data, 'extends', finalVal, '', true);\r\n        }, undefined, c.data.extends.length - finalVal.length)\r\n    }\r\n\r\n    protected get_extendedBy(c: Context): this[\"extendedBy\"] {\r\n        return c.data.extendedBy.map((pointer) => {\r\n            return LPointerTargetable.from(pointer)\r\n        });\r\n    }\r\n    protected set_extendedBy(val: PackArr<this[\"extendedBy\"]>, c: Context): boolean {\r\n        if (!val) val = [];\r\n        else if (!Array.isArray(val)) val = [val];\r\n        const ptrs = [...new Set(val.map((val) => { return val && Pointers.from(val) }).filter(e=>!!e))];\r\n        TRANSACTION(this.get_name(c)+'.extendedBy', ()=>{\r\n            SetFieldAction.new(c.data, 'extendedBy', ptrs, \"\", true);\r\n        })\r\n        return true;\r\n    }\r\n\r\n    protected get_implements(context: Context): this[\"implements\"] { return context.data.implements; }\r\n    protected set_implements(val: this[\"implements\"], c: Context): boolean {\r\n        TRANSACTION(this.get_name(c)+'.implements', ()=>{\r\n            SetFieldAction.new(c.data, 'implements', val, \"\", true);\r\n        })\r\n        return true;\r\n    }\r\n\r\n    protected get_implementedBy(context: Context): this[\"implementedBy\"] { return context.data.implementedBy; }\r\n    protected set_implementedBy(val: this[\"implementedBy\"], c: Context): boolean {\r\n        TRANSACTION(this.get_name(c)+'.implementedBy', ()=>{\r\n            SetFieldAction.new(c.data, 'implementedBy', val, \"\", true);\r\n        })\r\n        return true;\r\n    }\r\n\r\n\r\n    public canExtend(superclass: LClass, output: {reason: string, allTargetSuperClasses: LClass[]} = {reason: '', allTargetSuperClasses: []}): boolean {\r\n        this.cannotCall(\"canExtend\"); return false;\r\n    }\r\n\r\n    private get_canExtend(context: Context): (superclass: LClass, output: {reason: string, allTargetSuperClasses: LClass[]}) => boolean {\r\n        return (superclass: LClass, output: {reason: string, allTargetSuperClasses: LClass[]} =\r\n            {reason: '', allTargetSuperClasses: []}) => this._canExtend(context, superclass, output);\r\n    }\r\n\r\n    public isExtending(superclass: Pack1<LClass>, directly: boolean = false): boolean { return this.cannotCall(\"isExtending\"); }\r\n    public isSubclassOf(superclass: Pack1<LClass>, directly: boolean = false): boolean { return this.cannotCall(\"isSubclassOf\"); }\r\n    __info_of__isSubclassOf: Info = {type: \"(superclass: Pointer | LClass, directly: boolean = false) => boolean\", txt: \"Alias for isExtending\"};\r\n    __info_of__isExtending: Info = {type: \"(superclass: Pointer | LClass, directly: boolean = false) => boolean\",\r\n        txt:<div>Tells if \"this\" is a subclass of the \"superclass\" parameter.\r\n            <br/>- If \"directly\" is set to true, it will only include direct subclassing as in \"class A extends C\" not considering chains.\r\n            <br/>    If \"directly\" is set to true: \"class A extends B\" & \"Class B extends C\". In that case A.isExtending(C, true) will return false.</div>};\r\n\r\n    private get_isSubclassOf(c: Context, plusThis: boolean = true): this[\"isExtending\"] { return this.get_isExtending(c, plusThis); }\r\n    private get_isExtending(c: Context, plusThis: boolean = true): this[\"isExtending\"] {\r\n        return (superclass: Pack1<LClass>, directly: boolean = false): boolean => {\r\n            let ptr = Pointers.from(superclass);\r\n            if (directly) return c.data.extends.includes(ptr);\r\n            return this.get_superclasses(c, plusThis).map(classe=>classe.id).includes(ptr);\r\n        }\r\n    }\r\n\r\n    private get_superclasses(context: Context, plusThis: boolean = false): LClass[] {\r\n        let i: number;\r\n        const thiss: LClass = context.proxyObject;\r\n        const visited: Dictionary<Pointer, LClass> = {};\r\n        let queue: LClass[] = thiss.extends;\r\n        if (plusThis) queue = [thiss, ...queue];\r\n        const ret: LClass[] = [];\r\n        for (i = 0; i < queue.length; i++) {\r\n            let elem: LClass = queue[i];\r\n            if (visited[elem.id]) continue;\r\n            visited[elem.id] = elem;\r\n            ret.push(elem);\r\n            queue.push(...elem.extends);\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    private get_allSubClasses(context: Context, plusThis: boolean = false, state?: DState): LClass[] {\r\n        const thiss: LClass = context.proxyObject;\r\n        let extendedBy = thiss.extendedBy;\r\n        let ebyIDS = extendedBy.map(e => e.id);\r\n        /* old version, remade longer but more efficient\r\n        const set: Set<LClass> = plusThis ? new Set<LClass>([thiss.id, ...ebyIDS]) : new Set(ebyIDS);\r\n        for (let i = 0; i < extendedBy.length; i++) { U.SetMerge(true, set, extendedBy[i].allSubClasses.map(e=>e.id)); }*/\r\n        let parsedSubclasses: Dictionary<Pointer, DClass> = {}\r\n        parsedSubclasses[context.data.id] = context.data;\r\n        let stack: DClass[] = [context.data];\r\n        if (!state && !context.data.extendedBy?.length) state = store.getState();\r\n        while (stack.length) {\r\n            let newstack: DClass[] = [];\r\n            for (let d of stack) {\r\n                for (let sid of d.extendedBy) {\r\n                    if (!sid || parsedSubclasses[sid]) continue;\r\n                    let d: DClass = DClass.from(sid, state);\r\n                    if (!d) continue;\r\n                    parsedSubclasses[sid] = d;\r\n                    newstack.push(d);\r\n                }\r\n            }\r\n            stack = newstack;\r\n        }\r\n        if (!plusThis) delete parsedSubclasses[context.data.id];\r\n        return Object.values(parsedSubclasses).map(d=>LPointerTargetable.fromD(d)); }\r\n\r\n\r\n    private _canExtend(c: Context, superclass: LClass, output: {reason: string, allTargetSuperClasses: LClass[]} = {reason: '', allTargetSuperClasses: []}): boolean {\r\n        if (!output) output = {allTargetSuperClasses:[]} as any;\r\n        superclass = superclass && LPointerTargetable.wrap(superclass) as any;\r\n        if (!superclass) { output.reason = 'Invalid extend target: ' + superclass; return false; }\r\n        let sealed = superclass.sealed || [];\r\n        if (sealed.length) {\r\n            let inSealed = false;\r\n            for (let allowed of sealed) if (allowed && allowed.isSubClassOf(c.proxyObject)) { inSealed = true; break; }\r\n            if (!inSealed) {\r\n                output.reason = 'sealed on attempted superclass';\r\n                return false;\r\n            }\r\n        }\r\n        if (superclass.final) {\r\n            output.reason = 'final on attempted superclass';\r\n            return false;\r\n        }\r\n        const thiss: LClass = c.proxyObject;\r\n        if (superclass.id === thiss.id) { output.reason = 'Classes cannot extend themselves.'; return false; }\r\n        // todo: se diversi proxy dello stesso oggetto sono considerati diversi questo fallisce, in tal caso fai thiss.extends.map( l => l.id).indexof(superclass.id)\r\n        if (thiss.extends.map(sc=>sc.id).indexOf(superclass.id) >= 0) { output.reason = 'Target class is already directly extended.'; return false; }\r\n        output.allTargetSuperClasses = superclass.superclasses;\r\n        if (thiss.superclasses.map(sc=> sc.id).indexOf(superclass.id) >= 0) { output.reason = 'Target class is already indirectly extended.'; return false; }\r\n        if (output.allTargetSuperClasses.map(sc=>sc.id).indexOf(thiss.id) >= 0) { output.reason = 'Cannot set this extend, it would cause a inheritance loop.'; return false; }\r\n        if (thiss.interface && !superclass.interface) { output.reason = 'An interface cannot extend a class.'; return false; }\r\n        // ora verifico se causa delle violazioni di override (attibuti omonimi string e boolean non possono overridarsi)\r\n        let i: number;\r\n        let j: number;\r\n        let children: LOperation[] =  thiss.operations; //[...thiss.getBasicOperations()];\r\n        let superchildren: LOperation[] = superclass.operations; //[...superclass.getBasicOperations()];\r\n        for (i = 0; i < children.length; i++) {\r\n            let op: LOperation = children[i];\r\n            for (j = 0; j < superchildren.length; j++){\r\n                let superchild: LOperation = superchildren[j];\r\n                if (op.name !== superchild.name) continue;\r\n                if (op._canOverride(superchild) || op._canPolymorph(superchild)) continue;\r\n                output.reason = 'Marked homonymous operations cannot override nor polymorph each others.';\r\n                setTimeout( () => {\r\n                    op._mark(true, superchild, 'override'); //  mark op && superchildren\r\n                    setTimeout( () => { op._mark(false, superchild, 'override'); }, 3000); // unmark\r\n                }, 1);\r\n                return false;\r\n            }\r\n        }\r\n        return true; }\r\n\r\n    private _isExtending(context: Context, superclass: LClass, orEqual: boolean = true): boolean {\r\n        if (!superclass) return false;\r\n        return this.get_superclasses(context, orEqual).includes(superclass); }\r\n\r\n    private add_Extends(c: Context, superclass: LClass, force: boolean = false): boolean {\r\n        let out: {reason: string, allTargetSuperClasses: LClass[]} = {reason: '', allTargetSuperClasses: []};\r\n        const thiss: LClass = c.proxyObject;\r\n        superclass = LPointerTargetable.wrap(superclass) as any;\r\n        if (!superclass) return true;\r\n        if (!force && !this._canExtend(c, superclass, out)) {  return false; }\r\n\r\n        TRANSACTION(this.get_name(c)+'.extends+=', ()=>{\r\n            SetFieldAction.new(thiss.__raw, 'extends', [superclass.id], '+=', true);\r\n            SetFieldAction.new(superclass.__raw, 'extendedBy', [thiss.id], '+=', true);\r\n        }, undefined, superclass.fullname)\r\n        // const extendChildren: LClass[] =  [thiss, ...thiss.superclasses];\r\n        // console.log('calculateViolationsExtend children:'  + extendChildren, this);\r\n        // for (let extChild of extendChildren) { extChild._checkViolations(false); } // after instances have their meta-class changed, they might need to change shape or values.\r\n        return true; }\r\n\r\n    unsetExtends(superclass: LClass): void { return this.cannotCall('unsetExtends'); }\r\n    get_unsetExtends(c: Context, superclass: LClass): (superclass: LClass)=>void {\r\n        return (superclass: LClass)=>{\r\n            superclass = LPointerTargetable.wrap(superclass) as any;\r\n            if (!superclass) return;\r\n            console.log('UnsetExtend:', c, superclass);\r\n            // todo: when Object is loaded in m3, set him there for easy access.\r\n            //  if (superclass.id === LClass.genericObjectid) { Log.w(true, 'Cannot un-extend \"Object\"'); return; }\r\n            const thiss: LClass = c.proxyObject;\r\n            let superclassid = superclass.id;\r\n            let extendsarr = c.data.extends;\r\n            let index: number = extendsarr.indexOf(superclassid);\r\n            if (index < 0) return;\r\n            // let extendedby = superclass.__raw.extendedBy;\r\n\r\n            TRANSACTION(this.get_name(c)+'.extends-=', ()=>{\r\n                // @ts-ignore\r\n                SetFieldAction.new(thiss, 'extends', superclass.id, '-=', true);\r\n                // @ts-ignore\r\n                SetFieldAction.new(superclass, 'extendedBy', thiss.id, '-=', true);\r\n            }, undefined, superclass.fullname)\r\n            // todo: update instances for (i = 0; i < thiss.instances.length; i++) { thiss.instances[i].unsetExtends(superclass); }\r\n            // todo: check violations\r\n            // const extendedby: LClass[] = [thiss, ...thiss.allSubClasses];\r\n            // for (i = 0; i < extendedby.length; i++) { extendedby[i].checkViolations(true); }\r\n        }\r\n    }\r\n\r\n    public instance(): DObject { return this.cannotCall('instance'); }\r\n    /*private get_instance_old(context: Context): () => DObject {\r\n        return () => {\r\n            const dClass: DClass = context.data;\r\n            const lClass: LClass = LClass.from(dClass);\r\n            const dObject = DObject.new(lClass.name.toLowerCase());\r\n            CreateElementAction.new(dObject);\r\n            BEGIN()\r\n            SetFieldAction.new(dObject, 'instanceof', dClass.id, '', true);\r\n            SetFieldAction.new(dClass, 'instances', dObject.id, '+=', true);\r\n\r\n            let father: LClass|undefined = lClass;\r\n            while(father) {\r\n                for(let dFeature of [...father.attributes, ...father.references]) {\r\n                    const dValue = DValue.new(dFeature.name); dValue.value = [U.initializeValue(dFeature.type)];\r\n                    CreateElementAction.new(dValue);\r\n\r\n                    SetFieldAction.new(dValue, 'father', dObject.id, '', true);\r\n                    SetFieldAction.new(dValue, 'instanceof', dFeature.id, '', true);\r\n                    SetFieldAction.new(dFeature, 'instances', dValue.id, '+=', true);\r\n                    SetFieldAction.new(dObject, 'features', dValue.id, '+=', true);\r\n\r\n                }\r\n                father = (father.extends.length > 0) ? father.extends[0] : undefined;\r\n            }\r\n            END()\r\n            return dObject;\r\n        };\r\n    }*/\r\n\r\n}\r\nRuntimeAccessibleClass.set_extend(DClassifier, DClass);\r\nRuntimeAccessibleClass.set_extend(LClassifier, LClass);\r\n@RuntimeAccessible('DDataType')\r\nexport class DDataType extends DPointerTargetable { // extends DClassifier\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // static singleton: LDataType;\r\n    // static logic: typeof LDataType;\r\n    // static structure: typeof DDataType;\r\n\r\n    // inherit redefine\r\n    // instanceClass: EJavaClass // ?\r\n    // isInstance(object: EJavaObject): boolean; ?\r\n    // getClassifierID(): number;\r\n    id!: Pointer<DDataType, 1, 1, LDataType>;\r\n    instanceClassName!: string;\r\n    parent: Pointer<DPackage, 0, 'N', LPackage> = [];\r\n    father!: Pointer<DPackage, 1, 1, LPackage>;\r\n    annotations: Pointer<DAnnotation, 0, 'N', LAnnotation> = [];\r\n    name!: string;\r\n    defaultValue!: Pointer<DObject, 1, 1, LObject>[] | string[];\r\n    // personal\r\n    serializable: boolean = true;\r\n    // usedBy: Pointer<DAttribute, 0, 'N', LAttribute> = [];\r\n\r\n\r\n    public static new(name?: DNamedElement[\"name\"], father?: Pointer, persist: boolean = true): DDataType {\r\n        Log.exx(\"DDataType is abstract, cannot instantiate\");\r\n        return null as any;\r\n        // if (!name) name = this.defaultname(\"datatype_\", father);\r\n        // return new Constructors(new DDataType('dwc'), father, persist, undefined).DPointerTargetable().DModelElement().DNamedElement(name).DClassifier().DDataType().end();\r\n    }\r\n}\r\n\r\n@Abstract\r\n@RuntimeAccessible('LDataType')\r\nexport class LDataType<Context extends LogicContext<DDataType> = any, C extends Context = Context> extends LClassifier { // extends DClassifier\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    public __raw!: DDataType;\r\n    id!: Pointer<DDataType, 1, 1, LDataType>;\r\n    // static singleton: LDataType;\r\n    // static logic: typeof LDataType;\r\n    // static structure: typeof DDataType;\r\n\r\n    // inherit redefine\r\n    // instanceClass: EJavaClass // ?\r\n    // isInstance(object: EJavaObject): boolean; ?\r\n    // getClassifierID(): number;\r\n    instanceClassName!: string;\r\n    parent!: LPackage[];\r\n    father!: LPackage;\r\n    annotations!: LAnnotation[];\r\n    name!: string;\r\n    namespace!: string;\r\n    defaultValue!: LObject[] | string[];\r\n    isPrimitive!: false;\r\n    isClass!: false;\r\n    isEnum!: true;\r\n    // personal\r\n    serializable!: boolean;\r\n\r\n\r\n    protected get_serializable(context: Context): this[\"serializable\"] { return context.data.serializable; }\r\n    protected set_serializable(val: this[\"serializable\"], c: Context): boolean {\r\n        val = !!val;\r\n        if (val === c.data.serializable) return true;\r\n        TRANSACTION(this.get_name(c)+'.serializable', ()=>{\r\n            SetFieldAction.new(c.data, 'serializable', val);\r\n        }, c.data.serializable, val)\r\n        return true;\r\n    }\r\n\r\n}\r\n\r\nRuntimeAccessibleClass.set_extend(DClassifier, DDataType);\r\nRuntimeAccessibleClass.set_extend(LClassifier, LDataType);\r\n@RuntimeAccessible('DStructuralFeature')\r\nexport class DStructuralFeature extends DPointerTargetable { // DTypedElement\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // static singleton: LStructuralFeature;\r\n    // static logic: typeof LStructuralFeature;\r\n    // static structure: typeof DStructuralFeature;\r\n\r\n    // inherit redefine\r\n    id!: Pointer<DStructuralFeature, 1, 1, LStructuralFeature>;\r\n    annotations: Pointer<DAnnotation, 0, 'N', LAnnotation> = [];\r\n    parent: Pointer<DClass, 0, 'N', LClass> = [];\r\n    father!: Pointer<DClass, 1, 1, LClass>;\r\n    name!: string;\r\n    type!: Pointer<DClassifier, 1, 1, LClassifier>;\r\n    ordered: boolean = true;\r\n    unique: boolean = true;\r\n    lowerBound: number = 0;\r\n    upperBound: number = 1;\r\n    many!: boolean;\r\n    required!: boolean;\r\n    // personal\r\n    instances: Pointer<DValue, 0, 'N', LValue> = [];\r\n    changeable: boolean = true;\r\n    volatile: boolean = true;\r\n    transient: boolean = false;\r\n    unsettable: boolean = false;// if the feature can be \"unsetted\" aka undefined/deleted ?\r\n    allowCrossReference!:boolean;\r\n    public derived!: boolean;\r\n    /*protected */derived_read?: string;\r\n    /*protected */derived_write?: string;\r\n    /*protected*/ __info_of__derived: Info = {type: 'string', txt:'A ECore flag to signal the values of this feature depend on other features.\\n' +\r\n            'To make it usable at runtime in jjodel check derived_read and derived_write.'}\r\n    /*protected*/ __info_of__derived_read: Info = {type: 'string', txt:'A function in string format with 2 or less attributes: (data, oldValue).\\n' +\r\n            '- data is the LValue hosting this derived feature\\n' +\r\n            '- originalValues are the current **non-derived** values actually memorized in the data.values\\n'+\r\n            'The mandatory return value of this function will be returned when attempted to read data.values.'}\r\n    /*protected*/ __info_of__derived_write: Info = {type: 'string', txt:'A function in string format with 3 or less attributes: (value, data, oldValue).\\n' +\r\n            '- value is the value currently attempted to be set, which triggered the function call.\\n' +\r\n            '- data is the LValue hosting this derived feature\\n' +\r\n            '- originalValues are the current **non-derived** values actually memorized in the data.values\\n'+\r\n            'The optional return value of this function will be stored inside data, allowing for hybrid dependency-persistant features' +\r\n            '\\n or for a feature \"depending on itself\". like uppercasing his values before setting them.'}\r\n    defaultValue!: (Pointer<DObject, 1, 1, LObject> | PrimitiveType)[];\r\n\r\n    public static new(name?: DNamedElement[\"name\"], type?: DTypedElement[\"type\"], father?: Pointer, persist: boolean = true): DStructuralFeature {\r\n        Log.exx(\"DStructuralFeature is abstract, cannot instantiate\");\r\n        return null as any;\r\n        // if (!name) name = this.defaultname(\"feature \", father);\r\n        // return new Constructors(new DStructuralFeature('dwc'), father, persist, undefined).DPointerTargetable().DModelElement().DNamedElement(name).DTypedElement(type).DStructuralFeature().end();\r\n    }\r\n    // getFeatureID(): number;\r\n    // getContainerClass(): EJavaClass\r\n}\r\n\r\n@Abstract\r\n@RuntimeAccessible('LStructuralFeature')\r\nexport class LStructuralFeature<Context extends LogicContext<DStructuralFeature> = any,\r\n    C extends Context = Context, D extends DStructuralFeature = DStructuralFeature>  extends LTypedElement { // DTypedElement\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    public __raw!: DStructuralFeature;\r\n    id!: Pointer<DStructuralFeature, 1, 1, LStructuralFeature>;\r\n    // static singleton: LStructuralFeature;\r\n    // static logic: typeof LStructuralFeature;\r\n    // static structure: typeof DStructuralFeature;\r\n\r\n    // inherit redefine\r\n    annotations!: LAnnotation[];\r\n    parent!: LClass[];\r\n    father!: LClass;\r\n    name!: string;\r\n    namespace!: string;\r\n    type!: LClassifier;\r\n    ordered: boolean = true;\r\n    unique: boolean = true;\r\n    lowerBound: number = 0;\r\n    upperBound: number = 1;\r\n    many!: boolean;\r\n    required!: boolean;\r\n    public derived!: boolean;\r\n    /*protected */derived_read?: string;\r\n    /*protected */derived_write?: string;\r\n    /*protected*/ __info_of__derived: Info = {type: 'string', txt:'A ECore flag to signal the values of this feature depend on other features.\\n' +\r\n            'To make it usable at runtime in jjodel check derived_read and derived_write.'}\r\n    /*protected*/ __info_of__derived_read: Info = {type: 'string', txt:'A function in string format with 2 or less attributes: (data, oldValue).\\n' +\r\n            '- data is the LValue hosting this derived feature\\n' +\r\n            '- originalValues are the current **non-derived** values actually memorized in the data.values\\n'+\r\n            'The mandatory return value of this function will be returned when attempted to read data.values.'}\r\n    /*protected*/ __info_of__derived_write: Info = {type: 'string', txt:'A function in string format with 3 or less attributes: (value, data, oldValue).\\n' +\r\n            '- value is the value currently attempted to be set, which triggered the function call.\\n' +\r\n            '- data is the LValue hosting this derived feature\\n' +\r\n            '- originalValues are the current **non-derived** values actually memorized in the data.values\\n'+\r\n            'The optional return value of this function will be stored inside data, allowing for hybrid dependency-persistant features' +\r\n            '\\n or for a feature \"depending on itself\". like uppercasing his values before setting them.'}\r\n    // personal\r\n    instances!: LValue[];\r\n    changeable!: boolean;\r\n    volatile!: boolean;\r\n    transient!: boolean;\r\n    unsettable!: boolean;\r\n    // defaultValueLiteral!: string;\r\n    defaultValue!: (LObject[] | PrimitiveType[]);\r\n    // getFeatureID(): number;\r\n    // getContainerClass(): EJavaClass\r\n    allowCrossReference!:boolean;\r\n\r\n    get_crossReference(c: Context): this['allowCrossReference'] { return this.get_allowCrossReference(c); }\r\n    get_isCrossReference(c: Context): this['allowCrossReference'] { return this.get_allowCrossReference(c); }\r\n    set_crossReference(v: this['allowCrossReference'], c: Context): boolean { return this.set_allowCrossReference(v, c); }\r\n    set_isCrossReference(v: this['allowCrossReference'], c: Context): boolean { return this.set_allowCrossReference(v, c); }\r\n    get_allowCrossReference(c: Context): boolean { return c.data.allowCrossReference; }\r\n    set_allowCrossReference(v: this['allowCrossReference'], c: Context): boolean {\r\n        v = !!v;\r\n        if (v === c.data.allowCrossReference) return true;\r\n        TRANSACTION(this.get_name(c)+'.allowCrossReference', ()=>{\r\n            SetFieldAction.new(c.data, 'allowCrossReference', v);\r\n        }, c.data.allowCrossReference, v)\r\n        return true;\r\n    }\r\n\r\n    validTargetsJSX!: JSX.Element[];\r\n    get_validTargetsJSX(c: Context): this['validTargetsJSX'] {\r\n        let opts: MultiSelectOptGroup[] = [];\r\n        this.get_validTargets(c, opts);\r\n        return UX.options(opts);\r\n    }\r\n    validTargetOptions!: MultiSelectOptGroup[];\r\n    get_validTargetOptions(c: Context): this['validTargetOptions'] {\r\n        let opts: MultiSelectOptGroup[] = [];\r\n        this.get_validTargets(c, opts);\r\n        return opts;\r\n    }\r\n    validTargets!: (LObject | LEnumLiteral)[];\r\n    get_validTargets(c: Context, out?: MultiSelectOptGroup[]): this['validTargets'] {\r\n        let addClasses: boolean = false;\r\n        let addModels: boolean = false;\r\n        let addEnums: boolean = false;\r\n        let addPrimitives: boolean = false;\r\n        let addReturnTypes: boolean = false;\r\n        let isCrossRef = this.get_isCrossReference(c);\r\n        let d = c.data;\r\n        switch (d.className){\r\n            case DModel.cname:     addModels = true; break;\r\n            case DReference.cname: addClasses = true; break;\r\n            case DAttribute.cname:              addPrimitives = addEnums = true; break;\r\n            case DParameter.cname: addClasses = addPrimitives = addEnums = true; break;\r\n            case DOperation.cname: addClasses = addPrimitives = addEnums = addReturnTypes = true; break;\r\n        }\r\n        let m2: LModel = this.get_model(c);\r\n        let map = (object: LNamedElement): MultiSelectOption => {\r\n            let fname = object.fullname;\r\n            return {value:object.id, label: isCrossRef ? fname : object.name, title: object.fullname}\r\n        };\r\n        let map2 = (object: LNamedElement): MultiSelectOption => {\r\n            let name = object.name;\r\n            return {value:object.id, label: name, title: name}\r\n        };\r\n        let sort = (a:MultiSelectOption, b: MultiSelectOption) => (a.label > b.label ? +1 : -1);\r\n        let validClasses: LClass[] = [];\r\n        let validEnums: LEnumerator[] = [];\r\n        let validPrimitives: LClass[] = [];\r\n        let validModels: LModel[] = [];\r\n        let state: DState | null = null;\r\n        if (addModels) {\r\n            if (!state) state = store.getState();\r\n            validModels = LPointerTargetable.fromPointer(state.m2models);\r\n            if (out) out.push({label: 'Models', options: validModels.map(map2).sort(sort)});\r\n        }\r\n        if (addPrimitives) {\r\n            if (!state) state = store.getState();\r\n            validPrimitives = LPointerTargetable.fromPointer(state.primitiveTypes);\r\n        }\r\n        if (addReturnTypes) {\r\n            if (!state) state = store.getState();\r\n            U.arrayMergeInPlace(validPrimitives, LPointerTargetable.fromPointer(state.returnTypes));\r\n        }\r\n        if (out && validPrimitives.length) out.push({label: 'Primitives', options: validPrimitives.map(map2).sort(sort)});\r\n\r\n        if (addClasses) {\r\n            let m = this.get_model(c);\r\n            let pkgs = isCrossRef ? m.allCrossSubPackages : m.allSubPackages;\r\n            if (out) for (let pkg of pkgs){\r\n                let classes = pkg.classes;\r\n                if (classes.length === 0) continue;\r\n                out.push({label: 'Classes ('+pkg.fullname+')', options: classes.map(map2).sort(sort)});\r\n                U.arrayMergeInPlace(validClasses, classes);\r\n            } else validClasses = (isCrossRef ? m2.crossClasses : m2.classes);\r\n        }\r\n        if (addEnums) {\r\n            let m = this.get_model(c);\r\n            let pkgs = isCrossRef ? m.allCrossSubPackages : m.allSubPackages;\r\n            if (out) for (let pkg of pkgs){\r\n                let enums = pkg.enumerators;\r\n                if (enums.length === 0) continue;\r\n                out.push({label: 'Enumerators ('+pkg.fullname+')', options: enums.map(map2).sort(sort)});\r\n                U.arrayMergeInPlace(validEnums, enums);\r\n            } else validEnums = (isCrossRef ? m2.crossEnumerators : m2.enumerators);\r\n            //if (out) out.push({label: 'Enumerators', options: validEnums.map(map).sort(sort)});\r\n        }\r\n        return U.arrayMergeInPlace(validClasses as any[], validPrimitives, validEnums, validModels);\r\n    }\r\n    protected get_instances(context: Context): this[\"instances\"] {\r\n        return context.data.instances.map((pointer) => {\r\n            return LPointerTargetable.from(pointer)\r\n        });\r\n    }\r\n\r\n    protected set_instances(val: PackArr<this[\"instances\"]>, c: Context): boolean {\r\n        const list = val.map((lItem) => { return Pointers.from(lItem) });\r\n        TRANSACTION(this.get_name(c)+'.instances', ()=>{\r\n            SetFieldAction.new(c.data, 'instances', list, \"\", true);\r\n        })\r\n        return true;\r\n    }\r\n\r\n    protected get_changeable(context: Context): this[\"changeable\"] { return context.data.changeable; }\r\n    protected set_changeable(val: this[\"changeable\"], c: Context): boolean {\r\n        val = !!val;\r\n        if (c.data.changeable === val) return true;\r\n        TRANSACTION(this.get_name(c)+'.changeable', ()=>{\r\n            SetFieldAction.new(c.data, 'changeable', val);\r\n        }, c.data.changeable, val)\r\n        return true;\r\n    }\r\n\r\n    protected get_volatile(context: Context): this[\"volatile\"] { return context.data.volatile; }\r\n    protected set_volatile(val: this[\"volatile\"], c: Context): boolean {\r\n        val = !!val;\r\n        if (c.data.volatile === val) return true;\r\n        TRANSACTION(this.get_name(c)+'.volatile', ()=>{\r\n            SetFieldAction.new(c.data, 'volatile', val);\r\n        }, c.data.volatile, val)\r\n        return true;\r\n    }\r\n\r\n    protected get_transient(context: Context): this[\"transient\"] { return context.data.transient; }\r\n    protected set_transient(val: this[\"transient\"], c: Context): boolean {\r\n        val = !!val;\r\n        if (c.data.transient === val) return true;\r\n        TRANSACTION(this.get_name(c)+'.transient', ()=>{\r\n            SetFieldAction.new(c.data, 'transient', val);\r\n        }, c.data.transient, val)\r\n        return true;\r\n    }\r\n\r\n    protected get_unsettable(context: Context): this[\"unsettable\"] { return context.data.unsettable; }\r\n    protected set_unsettable(val: this[\"unsettable\"], c: Context): boolean {\r\n        val = !!val;\r\n        if (c.data.unsettable === val) return true;\r\n        TRANSACTION(this.get_name(c)+'.unsettable', ()=>{\r\n            SetFieldAction.new(c.data, 'unsettable', val);\r\n        }, c.data.unsettable, val)\r\n        return true;\r\n    }\r\n\r\n    protected get_derived(context: Context): D[\"derived\"] { return context.data.derived; }\r\n    protected set_derived(val: D[\"derived\"], c: Context): boolean {\r\n        val = !!val;\r\n        if (c.data.derived === val) return true;\r\n        TRANSACTION(this.get_name(c)+'.derived', ()=>{\r\n            SetFieldAction.new(c.data, 'derived', val);\r\n        }, c.data.derived, val)\r\n        return true;\r\n    }\r\n    /*\r\n        protected get_defaultValueLiteral(context: Context): this[\"defaultValueLiteral\"] { return context.data.defaultValueLiteral; }\r\n        protected set_defaultValueLiteral(val: this[\"defaultValueLiteral\"], context: Context): boolean {\r\n            SetFieldAction.new(context.data, 'defaultValueLiteral', val, \"\", false);\r\n            return true;\r\n        }*/\r\n}\r\nRuntimeAccessibleClass.set_extend(DTypedElement, DStructuralFeature);\r\nRuntimeAccessibleClass.set_extend(LTypedElement, LStructuralFeature);\r\n\r\n@Instantiable // DValue\r\n@Leaf\r\n@RuntimeAccessible('DReference')\r\nexport class DReference extends DPointerTargetable { // DStructuralFeature\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // static singleton: LReference;\r\n    // static logic: typeof LReference;\r\n    // static structure: typeof DReference;\r\n\r\n\r\n    // inherit redefine\r\n    id!: Pointer<DReference, 1, 1, LReference>;\r\n    annotations: Pointer<DAnnotation, 0, 'N', LAnnotation> = [];\r\n    name!: string;\r\n    type!: Pointer<DClass, 1, 1, LClass>;\r\n    ordered: boolean = true;\r\n    unique: boolean = true;\r\n    lowerBound: number = 0;\r\n    upperBound: number = 1;\r\n    many!: boolean;\r\n    required!: boolean;\r\n    changeable: boolean = true;\r\n    volatile: boolean = true;\r\n    transient: boolean = false;\r\n    unsettable: boolean = false;\r\n    defaultValueLiteral: string = '';\r\n    parent: Pointer<DClass, 0, 'N', LClass> = [];\r\n    father!: Pointer<DClass, 1, 1, LClass>;\r\n    instances: Pointer<DValue, 0, 'N', LValue> = [];\r\n    defaultValue!: Pointer<DObject, 1, 1, LObject>[];\r\n    allowCrossReference!:boolean;\r\n    public derived!: boolean;\r\n    /*protected */derived_read?: string;\r\n    /*protected */derived_write?: string;\r\n    /*protected*/ __info_of__derived: Info = {type: 'string', txt:'A ECore flag to signal the values of this feature depend on other features.\\n' +\r\n            'To make it usable at runtime in jjodel check derived_read and derived_write.'}\r\n    /*protected*/ __info_of__derived_read: Info = {type: 'string', txt:'A function in string format with 2 or less attributes: (data, oldValue).\\n' +\r\n            '- data is the LValue hosting this derived feature\\n' +\r\n            '- originalValues are the current **non-derived** values actually memorized in the data.values\\n'+\r\n            'The mandatory return value of this function will be returned when attempted to read data.values.'}\r\n    /*protected*/__info_of__derived_write: Info = {type: 'string', txt:'A function in string format with 3 or less attributes: (value, data, oldValue).\\n' +\r\n            '- value is the value currently attempted to be set, which triggered the function call.\\n' +\r\n            '- data is the LValue hosting this derived feature\\n' +\r\n            '- originalValues are the current **non-derived** values actually memorized in the data.values\\n'+\r\n            'The optional return value of this function will be stored inside data, allowing for hybrid dependency-persistant features' +\r\n            '\\n or for a feature \"depending on itself\". like uppercasing his values before setting them.'}\r\n\r\n    // personal\r\n    rootable?:boolean;\r\n    composition: boolean = false;\r\n    aggregation: boolean = false; // exist in uml but not in ecore\r\n    container: boolean = false;\r\n    __info_of__container: Info = {type: 'boolean', txt: \"A reference is a container if it has an opposite that is a containment.\"};\r\n    opposite?: Pointer<DReference>;\r\n    target: Pointer<DClass, 0, 'N', LClass> = [];\r\n    edges: Pointer<DEdge, 0, 'N', LEdge> = [];\r\n\r\n    public static new(name?: DReference[\"name\"], type?: DReference[\"type\"], father?: DReference[\"father\"], persist: boolean = true): DReference {\r\n        if (!type) type = father // default type is self-reference\r\n        if (!name) name = this.defaultname(\"ref_\", father);\r\n        return new Constructors(new DReference('dwc'), father, persist, undefined).DPointerTargetable().DModelElement()\r\n            .DNamedElement(name).DTypedElement(type).DStructuralFeature().DReference().end();\r\n    }\r\n\r\n    static new2(setter: Partial<ObjectWithoutPointers<DReference>>, father: DReference[\"father\"], type?: DReference[\"type\"], name?: DReference[\"name\"]): DReference {\r\n        if (!name) name = this.defaultname((name || \"ref_\"), father);\r\n        return new Constructors(new DReference('dwc'), father, true, undefined).DPointerTargetable().DModelElement()\r\n            .DNamedElement(name).DTypedElement(type).DStructuralFeature().DReference()\r\n            .end((d) => { Object.assign(d, setter); });\r\n    }\r\n\r\n    static new3(a: Partial<ReferencePointers>, callback: undefined | ((d: DReference, c: Constructors) => void), persist: boolean = true): DReference {\r\n        if (!a.name) a.name = this.defaultname(\"ref_\", a.father);\r\n        return new Constructors(new DReference('dwc'), a.father, persist, undefined, a.id).DPointerTargetable().DModelElement()\r\n            .DPointerTargetable().DModelElement().DNamedElement(a.name)\r\n            .DTypedElement(a.type).DStructuralFeature().DReference()\r\n            .end(callback);\r\n    }\r\n\r\n}\r\n\r\n@Instantiable // LValue\r\n@Leaf\r\n@RuntimeAccessible('LReference')\r\nexport class LReference<Context extends LogicContext<DReference> = any, C extends Context = Context, D extends DReference = DReference>  extends LStructuralFeature {\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    public __raw!: DReference;\r\n    id!: Pointer<DReference, 1, 1, LReference>;\r\n    // static singleton: LReference;\r\n    // static logic: typeof LReference;\r\n    // static structure: typeof DReference;\r\n\r\n    // inherit redefine\r\n    annotations!: LAnnotation[];\r\n    name!: string;\r\n    namespace!: string;\r\n    type!: LClass;\r\n    ordered!: boolean;\r\n    unique!: boolean;\r\n    lowerBound!: number;\r\n    upperBound!: number;\r\n    many!: boolean;\r\n    required!: boolean;\r\n    changeable!: boolean;\r\n    volatile!: boolean;\r\n    transient!: boolean;\r\n    unsettable!: boolean;\r\n    allowCrossReference!:boolean;\r\n    public derived!: boolean;\r\n    /*protected */derived_read?: string;\r\n    /*protected */derived_write?: string;\r\n    /*protected */__info_of__derived: Info = {type: 'string', txt:'A ECore flag to signal the values of this feature depend on other features.\\n' +\r\n            'To make it usable at runtime in jjodel check derived_read and derived_write.'}\r\n    /*protected */__info_of__derived_read: Info = {type: 'string', txt:'A function in string format with 2 or less attributes: (data, oldValue).\\n' +\r\n            '- data is the LValue hosting this derived feature\\n' +\r\n            '- originalValues are the current **non-derived** values actually memorized in the data.values\\n'+\r\n            'The mandatory return value of this function will be returned when attempted to read data.values.'}\r\n    /*protected */__info_of__derived_write: Info = {type: 'string', txt:'A function in string format with 3 or less attributes: (value, data, oldValue).\\n' +\r\n            '- value is the value currently attempted to be set, which triggered the function call.\\n' +\r\n            '- data is the LValue hosting this derived feature\\n' +\r\n            '- originalValues are the current **non-derived** values actually memorized in the data.values\\n'+\r\n            'The optional return value of this function will be stored inside data, allowing for hybrid dependency-persistant features' +\r\n            '\\n or for a feature \"depending on itself\". like uppercasing his values before setting them.'}\r\n    defaultValueLiteral!: string;\r\n    parent!: LClass[];\r\n    father!: LClass;\r\n    instances!: LValue[];\r\n    defaultValue!: LObject[];\r\n\r\n    // personal\r\n    composition!: boolean; // aggregation || containment\r\n    aggregation!: boolean;\r\n    containment!: boolean;\r\n    container!: boolean;\r\n\r\n    rootable?:boolean;\r\n    __info_of__rootable: Info = {type:\"boolean | undefined\",\r\n        txt: \"if missing, only classes not contained, not abstract and not interface can be a model root. if present this dictates it.\"};\r\n    __info_of__composition: Info = {type:\"boolean\",\r\n        txt: \"Defines a \\\"part of\\\" relationship where the target cannot exist without the source. Building -> Room \\\"A Room cannot exist without a Building\\\"\"};\r\n    __info_of__aggregation: Info = {type:\"boolean\",\r\n        txt: \"Defines a \\\"part of\\\" relationship where the target can exist without the source. Building -> Student \\\"A Student can exist outside a Building\\\"\"};\r\n    opposite?: LReference;\r\n    // target!: LClass[]; replaced by type\r\n    edges!: LEdge[];\r\n\r\n\r\n\r\n    protected generateEcoreJson_impl(context: Context, loopDetectionObj: Dictionary<Pointer, DModelElement> = {}): Json {\r\n        loopDetectionObj[context.data.id] = context.data;\r\n        const model: GObject = {};\r\n        const d = context.data;\r\n        const l = context.proxyObject;\r\n        model[ECoreReference.xsitype] = 'ecore:EReference';\r\n        model[ECoreReference.eType] = l.type.typeEcoreString;\r\n        model[ECoreReference.namee] = d.name;\r\n        if (d.lowerBound != null && !isNaN(+d.lowerBound)) { model[ECoreReference.lowerbound] = +d.lowerBound; }\r\n        if (d.upperBound != null && !isNaN(+d.upperBound)) { model[ECoreReference.upperbound] = +d.upperBound; }\r\n        let cont = d.aggregation || d.composition;\r\n        if (cont != null) { model[ECoreReference.containment] = cont; }\r\n        if (d.container != null) { model[ECoreReference.container] = d.container; }\r\n        return model; }\r\n\r\n    public duplicate(deep: boolean = true): this {\r\n        return this.cannotCall( ((this.constructor as typeof RuntimeAccessibleClass).cname || this.constructor.name) + \"duplicate()\"); }\r\n    protected get_duplicate(context: Context): ((deep?: boolean) => LReference) {\r\n        return (deep: boolean = false) => {\r\n            let ret: LReference = undefined as any;\r\n            TRANSACTION('duplicate ' + this.get_name(context), ()=>{\r\n                let le: LReference = context.proxyObject.father.addReference(context.data.name, context.data.type);\r\n                let de: D = le.__raw as D;\r\n                de.many = context.data.many;\r\n                de.lowerBound = context.data.lowerBound;\r\n                de.upperBound = context.data.upperBound;\r\n                de.ordered = context.data.ordered;\r\n                de.required = context.data.required;\r\n                de.unique = context.data.unique;\r\n                de.changeable = context.data.changeable;\r\n                de.container = context.data.container;\r\n                de.composition = context.data.composition;\r\n                de.aggregation = context.data.aggregation;\r\n                de.defaultValueLiteral = context.data.defaultValueLiteral;\r\n                de.derived = context.data.derived;\r\n                de.transient = context.data.transient;\r\n                de.unsettable = context.data.unsettable;\r\n                de.volatile = context.data.unsettable;\r\n                let we: WReference = le as any;\r\n                we.opposite = context.data.opposite || undefined;\r\n                we.defaultValue = context.data.defaultValue;\r\n                we.type = context.data.type;\r\n                we.annotations = deep ? context.proxyObject.annotations.map(lchild => lchild.duplicate(deep).id) : context.data.annotations;\r\n                // we.target = deep ? context.proxyObject.target.map(lchild => lchild.duplicate(deep).id) : context.data.target;\r\n                ret = le;\r\n            })\r\n            return ret; }\r\n    }\r\n\r\n    protected set_type(val: Pack1<this[\"type\"]>, context: Context): boolean {\r\n        super.set_type(val, context);\r\n        return true;\r\n    }\r\n\r\n    public addClass(name?: DClass[\"name\"], isInterface?: DClass[\"interface\"], isAbstract?: DClass[\"abstract\"], isPrimitive?: DClass[\"isPrimitive\"],\r\n                    isPartial?: DClass[\"partial\"], partialDefaultName?: DClass[\"partialdefaultname\"]): LClass {\r\n        return this.cannotCall(\"LReference.addClass\"); }\r\n    protected get_addClass(c: Context): this[\"addClass\"] {\r\n        return (name?: DClass[\"name\"], isInterface?: DClass[\"interface\"], isAbstract?: DClass[\"abstract\"], isPrimitive?: DClass[\"isPrimitive\"],\r\n                isPartial?: DClass[\"partial\"], partialDefaultName?: DClass[\"partialdefaultname\"]) => {\r\n            let dclass: DClass = null as any\r\n            TRANSACTION(this.get_name(c)+'.addClass()', ()=>{\r\n                dclass = DClass.new(name, isInterface, isAbstract, isPrimitive, isPartial, partialDefaultName, c.proxyObject.package!.id, true);\r\n                // SetFieldAction.new(context.data.id, \"type\", dclass.id);\r\n                this.set_type(dclass.id as any, c);\r\n            }, undefined, name)\r\n            return LPointerTargetable.fromD(dclass);\r\n        } }\r\n\r\n\r\n    get_containment(context: Context): this[\"containment\"] { return context.data.composition || context.data.aggregation; }\r\n    set_containment(val: this[\"containment\"], c: Context, mainkey:'composition'|'aggregation' = 'composition', altkey:'composition'|'aggregation' = 'aggregation'): boolean {\r\n        // return this.cannotSet('containment', 'set aggregation or composition instead');\r\n        val = !!val;\r\n        if (!!c.data[mainkey] === val) return true;\r\n        TRANSACTION(this.get_name(c)+'.'+mainkey, ()=>{\r\n            // set composition and unset aggregation or viceversa\r\n            SetFieldAction.new(c.data, mainkey, val);\r\n            if (val && c.data[altkey]) SetFieldAction.new(c.data, altkey, !val);\r\n            let containedObjects: Dictionary<Pointer, LObject> = {};\r\n            let removedValues: Pointer[] = [];\r\n            let parentChanges: LObject[] = [];\r\n            for (let lval of this.get_instances(c) as LValue[]) {\r\n                // todo: in set_values crop the arr to max upperbound\r\n                let dval = lval.__raw\r\n                let values = dval.values;\r\n                let lmodel = lval.model;\r\n                let dmodel = lmodel.__raw;\r\n                for (let ptr of values) {\r\n                    if (!Pointers.isPointer(ptr)) continue;\r\n                    if (containedObjects[ptr]) {\r\n                        // Log.ee('Cannot activate ' + mainkey+ ' on this reference because some objects are referenced twice in the model')\r\n                        // todo: ask for confirmation if want to abort or delete those values.\r\n                        if (val) {\r\n                            SetFieldAction.new(dval, 'values', ptr as any, '-=', true); // if is containment=true prevent the targets from being contained twice}\r\n                            removedValues.push(ptr);\r\n                            continue;\r\n                        }\r\n                    }\r\n                    // update parent\r\n                    let pointedobj = containedObjects[ptr] = LPointerTargetable.fromPointer(ptr);\r\n                    let newid = (val ? dval.id : dmodel.id) as any;\r\n                    let oldparent = pointedobj.father;\r\n                    if (oldparent?.id === newid) continue;\r\n                    pointedobj.father = newid;\r\n                    parentChanges.push(pointedobj);\r\n                }\r\n            }\r\n            if (removedValues.length || parentChanges.length){\r\n                Log.ww([\r\n                    removedValues.length ? removedValues.length+' values were removed':undefined,\r\n                    parentChanges.length ? parentChanges.length+' parents were changed':undefined\r\n                ].filter(e=>!!e).join(' and ') + ' as result.',//\\n If you want to check chem, write \"containmentSideEffects[\\''+c.data.id+'\\']\" in console.',\r\n                {removedValues, parentChanges}\r\n                );\r\n            }\r\n            //if (!windoww.containmentSideEffects) windoww.containmentSideEffects = {};\r\n            //windoww.containmentSideEffects[c.data.id] = {removedValues, parentChanges};\r\n        }, c.data[mainkey], val);\r\n        return true;\r\n    }\r\n\r\n    protected get_aggregation(context: Context): this[\"aggregation\"] { return context.data.aggregation; }\r\n    protected get_composition(context: Context): this[\"composition\"] { return context.data.composition; }\r\n    /*\r\n    protected get_container(context: Context): this[\"container\"] { return context.data.container; }\r\n    protected set_container(val: this[\"container\"], context: Context): boolean { return SetFieldAction.new(context.data, 'container', val); }*/\r\n\r\n    protected set_aggregation(val: this[\"aggregation\"], c: Context): boolean { return this.set_containment(val, c, 'aggregation', 'composition'); }\r\n    protected set_composition(val: this[\"composition\"], c: Context): boolean { return this.set_containment(val, c, 'composition', 'aggregation'); }\r\n\r\n    protected get_opposite(context: Context): this[\"opposite\"] { return context.data.opposite && LPointerTargetable.from(context.data.opposite); }\r\n    protected set_opposite(val: Pack<LReference | undefined>, c: Context): boolean {\r\n        let ptr = Pointers.from(val) as any as LAnnotation[\"id\"];\r\n        if (ptr === c.data.opposite) return true;\r\n        TRANSACTION(this.get_name(c)+'.opposite', ()=>{\r\n            SetFieldAction.new(c.data, 'opposite', ptr, \"\", true);\r\n        }, LPointerTargetable.wrap(c.data.opposite)?.fullname, LPointerTargetable.wrap(ptr)?.fullname)\r\n        return true;\r\n    }\r\n    /*\r\n        /// todo: why this exist?  why not type?\r\n        protected get_target(context: Context): this[\"target\"] { return context.data.target.map(pointer => LPointerTargetable.from(pointer)); }\r\n        protected set_target(val: PackArr<this[\"target\"]>, context: Context): boolean {\r\n            const list = val.map((lItem) => { return Pointers.from(lItem) });\r\n            SetFieldAction.new(context.data, 'target', list, \"\", true);\r\n            return true;\r\n        }*/\r\n\r\n    protected get_defaultValue(context: Context): this[\"defaultValue\"] { return LPointerTargetable.fromPointer(context.data.defaultValue); }\r\n    protected set_defaultValue(val: PackArr<this[\"defaultValue\"]>, c: Context): boolean {\r\n        // @ts-ignore\r\n        if (!val) (val) = []; else if (!Array.isArray(val)) val = [val];\r\n        let ptrs = Pointers.from(val);\r\n        TRANSACTION(this.get_name(c)+'.defaultValue', ()=>{\r\n            SetFieldAction.new(c.data, 'defaultValue', ptrs, '', false);\r\n        })\r\n        return true; }\r\n\r\n    protected get_edges(context: Context): this[\"edges\"] {\r\n        return context.data.edges.map((pointer) => {\r\n            return LPointerTargetable.from(pointer)\r\n        });\r\n    }\r\n    protected set_edges(val: PackArr<this[\"edges\"]>, c: Context): boolean {\r\n        const list = val.map((lItem) => { return Pointers.from(lItem) });\r\n        TRANSACTION(this.get_name(c)+'.edges', ()=>{\r\n            SetFieldAction.new(c.data, 'edges', list, \"\", true);\r\n        })\r\n        return true;\r\n    }\r\n}\r\nRuntimeAccessibleClass.set_extend(DStructuralFeature, DReference);\r\nRuntimeAccessibleClass.set_extend(LStructuralFeature, LReference);\r\nfunction has_opposite(oppositename: string, ...comments: string[]): any {\r\n    // return (c:Constructor, key:string, ):any =>{}\r\n}\r\nfunction obsolete_attribute(...comments: string[]) {\r\n    return undefined as any; // function(c:Constructor, key:string,): any {}\r\n}\r\n\r\n@Leaf\r\n@RuntimeAccessible('DAttribute')\r\nexport class DAttribute extends DPointerTargetable { // DStructuralFeature\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // static singleton: LAttribute;\r\n    // static logic: typeof LAttribute;\r\n    // static structure: typeof DAttribute;\r\n\r\n    // inherit redefine\r\n    id!: Pointer<DAttribute, 1, 1, LAttribute>;\r\n    // @has_opposite(\"father\")\r\n    annotations: Pointer<DAnnotation, 0, 'N', LAnnotation> = [];\r\n    name!: string;\r\n    type!: Pointer<DClassifier, 1, 1, LClassifier>;\r\n    ordered: boolean = true;\r\n    unique: boolean = true;\r\n    lowerBound: number = 0;\r\n    upperBound: number = 1;\r\n    many!: boolean;\r\n    required!: boolean;\r\n    changeable: boolean = true;\r\n    volatile: boolean = true;\r\n    transient: boolean = false;\r\n    unsettable: boolean = false;\r\n    defaultValueLiteral: string = '';\r\n    allowCrossReference!:boolean;\r\n    public derived!: boolean;\r\n    /*protected */derived_read?: string;\r\n    /*protected */derived_write?: string;\r\n    /*protected*/ __info_of__derived: Info = {type: 'string', txt:'A ECore flag to signal the values of this feature depend on other features.\\n' +\r\n            'To make it usable at runtime in jjodel check derived_read and derived_write.'}\r\n    /*protected*/ __info_of__derived_read: Info = {type: 'string', txt:'A function in string format with 2 or less attributes: (data, oldValue).\\n' +\r\n            '- data is the LValue hosting this derived feature\\n' +\r\n            '- originalValues are the current **non-derived** values actually memorized in the data.values\\n'+\r\n            'The mandatory return value of this function will be returned when attempted to read data.values.'}\r\n    /*protected*/ __info_of__derived_write: Info = {type: 'string', txt:'A function in string format with 3 or less attributes: (value, data, oldValue).\\n' +\r\n            '- value is the value currently attempted to be set, which triggered the function call.\\n' +\r\n            '- data is the LValue hosting this derived feature\\n' +\r\n            '- originalValues are the current **non-derived** values actually memorized in the data.values\\n'+\r\n            'The optional return value of this function will be stored inside data, allowing for hybrid dependency-persistant features' +\r\n            '\\n or for a feature \"depending on itself\". like uppercasing his values before setting them.'}\r\n    //@obsolete_attribute()\r\n    parent: Pointer<DClass, 0, 'N', LClass> = [];\r\n\r\n    //@has_opposite(\"attributes\")\r\n    father!: Pointer<DClass, 1, 1, LClass>;\r\n\r\n    //@has_opposite(\"instanceof\")\r\n    instances: Pointer<DValue, 0, 'N', LValue> = [];\r\n    defaultValue!: PrimitiveType[];\r\n\r\n    // personal\r\n    isID: boolean = false; // ? exist in ecore as \"iD\" ?\r\n    isIoT: boolean = false;\r\n\r\n    public static new(name?: DAttribute[\"name\"], type?: DAttribute[\"type\"], father?: DAttribute[\"father\"], persist: boolean = true): DAttribute {\r\n        if (!name) name = this.defaultname(\"attr_\", father);\r\n        if (!type) type = LPointerTargetable.from(Selectors.getFirstPrimitiveTypes()).id; // default type as string\r\n        return new Constructors(new DAttribute('dwc'), father, persist, undefined).DPointerTargetable().DModelElement()\r\n            .DNamedElement(name).DTypedElement(type).DStructuralFeature().DAttribute().end();\r\n    }\r\n    static new2(setter: Partial<ObjectWithoutPointers<DReference>>, father: DAttribute[\"father\"], type?: DAttribute[\"type\"], name?: DAttribute[\"name\"]): DAttribute {\r\n        if (!name) name = this.defaultname((name || \"ref_\"), father);\r\n        return new Constructors(new DAttribute('dwc'), father, true, undefined).DPointerTargetable().DModelElement()\r\n            .DNamedElement(name).DTypedElement(type).DStructuralFeature().DAttribute()\r\n            .end((d) => { Object.assign(d, setter); });\r\n    }\r\n    static new3(a: Partial<AttributePointers>, callback: undefined | ((d: DAttribute, c: Constructors) => void), persist: boolean = true): DAttribute {\r\n        if (!a.name) a.name = this.defaultname(\"attr_\", a.father);\r\n        return new Constructors(new DAttribute('dwc'), a.father, persist, undefined, a.id)\r\n            .DPointerTargetable().DModelElement().DNamedElement(a.name)\r\n            .DTypedElement(a.type).DStructuralFeature().DAttribute()\r\n            .end(callback);\r\n    }\r\n}\r\n\r\n\r\n@Leaf\r\n@Instantiable // (LValue)\r\n@RuntimeAccessible('LAttribute')\r\nexport class LAttribute <Context extends LogicContext<DAttribute> = any, C extends Context = Context, D extends DAttribute = DAttribute> extends LStructuralFeature { // DStructuralFeature\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    public __raw!: DAttribute;\r\n    id!: Pointer<DAttribute, 1, 1, LAttribute>;\r\n    // static singleton: LAttribute;\r\n    // static logic: typeof LAttribute;\r\n    // static structure: typeof DAttribute;\r\n\r\n    // inherit redefine\r\n    annotations!: LAnnotation[];\r\n    name!: string;\r\n    namespace!: string;\r\n    type!: LClassifier;\r\n    ordered!: boolean;\r\n    unique!: boolean;\r\n    lowerBound!: number;\r\n    upperBound!: number;\r\n    many!: boolean;\r\n    required!: boolean;\r\n    changeable!: boolean;\r\n    volatile!: boolean;\r\n    transient!: boolean;\r\n    unsettable!: boolean;\r\n    // defaultValueLiteral!: string;\r\n    defaultValue!: PrimitiveType[];\r\n    parent!: LClass[];\r\n    father!: LClass;\r\n    instances!: LValue[];\r\n\r\n    // personal\r\n    isID: boolean = false; // ? exist in ecore as \"iD\" ?\r\n    isIoT: boolean = false;\r\n    allowCrossReference!:boolean;\r\n\r\n    protected generateEcoreJson_impl(context: Context, loopDetectionObj: Dictionary<Pointer, DModelElement> = {}): Json {\r\n        loopDetectionObj[context.data.id] = context.data;\r\n        const model = {};\r\n        const d = context.data;\r\n        const l = context.proxyObject;\r\n        EcoreParser.write(model, ECoreAttribute.xsitype, 'ecore:EAttribute');\r\n        EcoreParser.write(model, ECoreAttribute.eType, l.type.typeEcoreString);\r\n        EcoreParser.write(model, ECoreAttribute.namee, d.name);\r\n        EcoreParser.write(model, ECoreAttribute.lowerbound, '' + d.lowerBound);\r\n        EcoreParser.write(model, ECoreAttribute.upperbound, '' + d.upperBound);\r\n        return model; }\r\n\r\n\r\n    public duplicate(deep: boolean = true): this {\r\n        return this.cannotCall( ((this.constructor as typeof RuntimeAccessibleClass).cname || this.constructor.name) + \"duplicate()\"); }\r\n    protected get_duplicate(context: Context): ((deep?: boolean) => LAttribute) {\r\n        return (deep: boolean = false) => {\r\n            let ret: LAttribute = null as any;\r\n            TRANSACTION('duplicate ' + this.get_name(context), ()=>{\r\n                let le: LAttribute = context.proxyObject.father.addAttribute(context.data.name, context.data.type);\r\n                let de: D = le.__raw as D;\r\n                de.many = context.data.many;\r\n                de.lowerBound = context.data.lowerBound;\r\n                de.upperBound = context.data.upperBound;\r\n                de.ordered = context.data.ordered;\r\n                de.required = context.data.required;\r\n                de.unique = context.data.unique;\r\n                de.changeable = context.data.changeable;\r\n                de.defaultValue = context.data.defaultValue;\r\n                de.defaultValueLiteral = context.data.defaultValueLiteral;\r\n                de.derived = context.data.derived;\r\n                de.transient = context.data.transient;\r\n                de.unsettable = context.data.unsettable;\r\n                de.volatile = context.data.volatile;\r\n                de.isID = context.data.isID;\r\n                de.isIoT = context.data.isIoT;\r\n                let we: WAttribute = le as any;\r\n                we.type = context.data.type;\r\n                we.annotations = deep ? context.proxyObject.annotations.map(lchild => lchild.duplicate(deep).id) : context.data.annotations;\r\n                ret = le;\r\n            })\r\n            return ret; }\r\n    }\r\n\r\n    public addEnum(...p:Parameters<this[\"addEnumerator\"]>): LEnumerator { return this.addEnumerator(...p); }\r\n    protected get_addEnum(context: Context): this[\"addEnumerator\"] { return this.get_addEnumerator(context); }\r\n    public addEnumerator(name?: DEnumerator[\"name\"], father?: DEnumerator[\"father\"]): LEnumerator { return this.cannotCall(\"Attribute.addEnumerator\"); }\r\n    protected get_addEnumerator(context: Context): this[\"addEnumerator\"] {\r\n        return (name?: DEnumerator[\"name\"], father?: DEnumerator[\"father\"]) => LPointerTargetable.fromD(DEnumerator.new(name, context.proxyObject.package?.id, true)); }\r\n\r\n    protected get_isID(context: Context): this[\"isID\"] { return context.data.isID; }\r\n    protected set_isID(val: this[\"isID\"], c: Context): boolean {\r\n        val = !!val;\r\n        if (!!c.data.isID === val) return true;\r\n        TRANSACTION(this.get_name(c)+'.isID', ()=>{\r\n            SetFieldAction.new(c.data, 'isID', val);\r\n        }, c.data.isID, val)\r\n        return true;\r\n    }\r\n    protected get_isIoT(context: Context): this[\"isIoT\"] { return context.data.isIoT; }\r\n    protected set_isIoT(val: this[\"isIoT\"], c: Context): boolean {\r\n        val = !!val;\r\n        if (!!c.data.isIoT === val) return true;\r\n        TRANSACTION(this.get_name(c)+'.isIoT', () => {\r\n            for (const value of c.proxyObject.instances) {\r\n                SetFieldAction.new(value, 'topic', '', '', false);\r\n            }\r\n            SetFieldAction.new(c.data, 'isIoT', val);\r\n        }, c.data.isIoT, val)\r\n        return true;\r\n    }\r\n    protected get_defaultValue(context: Context): this[\"defaultValue\"] { return context.data.defaultValue; }\r\n    protected set_defaultValue(val: unArr<this[\"defaultValue\"]>, c: Context): boolean {\r\n        // @ts-ignore\r\n        if (!val) (val) = []; else if (!Array.isArray(val)) val = [val];\r\n        TRANSACTION(this.get_name(c)+'.defaultValue', ()=>{\r\n            SetFieldAction.new(c.data, 'defaultValue', val, '', false);\r\n        })\r\n        return true; }\r\n\r\n}\r\nRuntimeAccessibleClass.set_extend(DStructuralFeature, DAttribute);\r\nRuntimeAccessibleClass.set_extend(LStructuralFeature, LAttribute);\r\n\r\n@Leaf\r\n@RuntimeAccessible('DEnumLiteral')\r\nexport class DEnumLiteral extends DPointerTargetable { // DNamedElement\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // static singleton: LAttribute;\r\n    // static logic: typeof LAttribute;\r\n    // static structure: typeof DAttribute;\r\n\r\n    // inherit redefine\r\n    id!: Pointer<DEnumLiteral, 1, 1, LEnumLiteral>;\r\n    parent: Pointer<DEnumerator, 0, 'N', LEnumerator> = [];\r\n    father!: Pointer<DEnumerator, 1, 1, LEnumerator>;\r\n    annotations: Pointer<DAnnotation, 0, 'N', LAnnotation> = [];\r\n    name!: string;\r\n    // personal\r\n    value!: number;\r\n    // ordinal: number=1; replaced by value\r\n    literal!: string;\r\n\r\n    public static new(name?: DNamedElement[\"name\"], value?: DEnumLiteral[\"value\"], father?: Pointer, persist: boolean = true): DEnumLiteral { //vv4\r\n        if (!name) name = this.defaultname(\"literal \", father);\r\n        return new Constructors(new DEnumLiteral('dwc'), father, persist, undefined).DPointerTargetable().DModelElement()\r\n            .DNamedElement(name).DEnumLiteral(value).end();\r\n    }\r\n    static new2(setter: Partial<ObjectWithoutPointers<DEnumLiteral>>, father: DEnumLiteral[\"father\"], name?: DEnumLiteral[\"name\"]): DEnumLiteral {\r\n        if (!name) name = this.defaultname(\"literal \", father);\r\n        return new Constructors(new DEnumLiteral('dwc'), father, true, undefined).DPointerTargetable().DModelElement()\r\n            .DNamedElement(name).DEnumLiteral()\r\n            .end((d) => { Object.assign(d, setter); });\r\n    }\r\n    static new3(a: Partial<LiteralPointers>, callback: undefined | ((d: DEnumLiteral, c: Constructors) => void), persist: boolean = true): DEnumLiteral {\r\n        if (!a.name) a.name = this.defaultname(\"literal_\", a.father);\r\n        return new Constructors(new DEnumLiteral('dwc'), a.father, persist, undefined, a.id)\r\n            .DPointerTargetable().DModelElement().DNamedElement(a.name)\r\n            .DEnumLiteral()\r\n            .end(callback);\r\n    }\r\n}\r\n\r\n@Leaf\r\n@RuntimeAccessible('LEnumLiteral')\r\nexport class LEnumLiteral<Context extends LogicContext<DEnumLiteral> = any, C extends Context = Context, D extends DEnumLiteral = DEnumLiteral>  extends LNamedElement { // DNamedElement\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    public __raw!: DEnumLiteral;\r\n    id!: Pointer<DEnumLiteral, 1, 1, LEnumLiteral>;\r\n    // static singleton: LAttribute;\r\n    // static logic: typeof LAttribute;\r\n    // static structure: typeof DAttribute;\r\n\r\n    // inherit redefine\r\n    parent!: LEnumerator[];\r\n    father!: LEnumerator;\r\n    annotations!: LAnnotation[];\r\n    name!: string;\r\n    namespace!: string;\r\n    // personal\r\n    value!: this[\"ordinal\"];\r\n    ordinal!: number;\r\n    literal!: string;\r\n\r\n    protected generateEcoreJson_impl(context: Context, loopDetectionObj: Dictionary<Pointer, DModelElement> = {}): Json {\r\n        loopDetectionObj[context.data.id] = context.data;\r\n        const json: Json = {};\r\n        const d = context.data;\r\n        json[EcoreLiteral.value] = d.value;\r\n        json[EcoreLiteral.literal] = d.literal;\r\n        json[EcoreLiteral.namee] = d.name;\r\n        return json; }\r\n\r\n    public generateEcoreJsonM1(): this[\"ordinal\"] { return this.cannotCall(\"GenerateEcoreJsonM1\"); }\r\n    protected get_generateEcoreJsonM1(context: Context): () => this[\"ordinal\"] { return this.impl_generateEcoreJsonM1(context); }\r\n    protected impl_generateEcoreJsonM1(context: Context): () => this[\"ordinal\"] {\r\n        // loopDetectionObj[context.data.id] = context.data; no loop detection here, the same literal can be exported multiple times in m1\r\n        // return context.data.literal;\r\n        // return context.data.name;\r\n        return () => context.data.value; }\r\n\r\n\r\n    public duplicate(deep: boolean = true): this {\r\n        return this.cannotCall( ((this.constructor as typeof RuntimeAccessibleClass).cname || this.constructor.name) + \"duplicate()\"); }\r\n    protected get_duplicate(c: Context): ((deep?: boolean) => LEnumLiteral) {\r\n        return (deep: boolean = false) => {\r\n            let ret: LEnumLiteral = null as any;\r\n            TRANSACTION(this.get_name(c)+'.duplicate()', ()=>{\r\n                let le: LEnumLiteral = c.proxyObject.father.addLiteral(c.data.name, c.data.value);\r\n                let de: D = le.__raw as D;\r\n                de.literal = c.data.literal;\r\n                de.value = c.data.value;\r\n                let we: WEnumLiteral = le as any;\r\n                we.annotations = deep ? c.proxyObject.annotations.map(lchild => lchild.duplicate(deep).id) : c.data.annotations;\r\n                ret = le;\r\n            })\r\n            return ret; }\r\n    }\r\n\r\n\r\n    protected get_ordinal(context: Context): this[\"ordinal\"] { return this.get_value(context); }\r\n    protected set_ordinal(val: this[\"ordinal\"], context: Context): boolean { return this.set_value(val, context); }\r\n\r\n    protected get_value(context: Context): this[\"value\"] {\r\n        let ordinalAssumedByPosition = true; // per ottimizzazione forse è disattivabile\r\n        if (!ordinalAssumedByPosition) return context.data.value || 0;\r\n        return context.proxyObject.father.ordinals.map( o => o?.id).indexOf(context.data.id);\r\n    }\r\n    protected set_value(val: this[\"value\"], c: Context): boolean {\r\n        if (val === c.data.value) return true;\r\n        let ordinals = (this.get_father(c) as LEnumerator).ordinals;\r\n        if (ordinals[val]) {\r\n            Log.e(true, \"that ordinal place is already taken by \" + ordinals[val].name, {sameOrdinalLit:ordinals[val], ordinals, thiss:c.data});\r\n            return true; }\r\n\r\n        TRANSACTION(this.get_name(c)+'.value', ()=>{\r\n            SetFieldAction.new(c.data, 'value', val);\r\n        }, c.data.value, val)\r\n        return true;\r\n    }\r\n    /*\r\n        protected get_literal(context: Context): this[\"literal\"] { return context.data.literal; }\r\n        protected set_literal(val: this[\"literal\"], context: Context): boolean {\r\n            return SetFieldAction.new(context.data, 'literal', val, '', false); }*/\r\n    protected get_literal(context: Context): this[\"literal\"] { return context.data.name; }\r\n    protected set_literal(val: this[\"literal\"], c: Context): boolean {\r\n        if (val === c.data.name) return true;\r\n        TRANSACTION(this.get_name(c)+'.name', ()=>{\r\n            return SetFieldAction.new(c.data, 'name', val, '', false);\r\n        }, c.data.name, val)\r\n        return true;\r\n    }\r\n\r\n\r\n}\r\nRuntimeAccessibleClass.set_extend(DNamedElement, DEnumLiteral);\r\nRuntimeAccessibleClass.set_extend(LNamedElement, LEnumLiteral);\r\n\r\n@Leaf\r\n@RuntimeAccessible('DEnumerator')\r\nexport class DEnumerator extends DPointerTargetable { // DDataType\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // static singleton: LEnumerator;\r\n    // static logic: typeof LEnumerator;\r\n    // static structure: typeof DEnumerator;\r\n\r\n    // inherit redefine\r\n    // instanceClass: EJavaClass // ?\r\n    // isInstance(object: EJavaObject): boolean; ?\r\n    // getClassifierID(): number;\r\n    id!: Pointer<DEnumerator, 1, 1, LEnumerator>;\r\n    instanceClassName!: string;\r\n    parent: Pointer<DPackage, 0, 'N', LPackage> = [];\r\n    father!: Pointer<DPackage, 1, 1, LPackage>;\r\n    annotations: Pointer<DAnnotation, 0, 'N', LAnnotation> = [];\r\n    name!: string;\r\n    defaultValue!: string[];\r\n    serializable: boolean = true;\r\n    // usedBy: Pointer<DAttribute, 0, 'N', LAttribute> = []; obsolete?\r\n    // personal\r\n    literals: Pointer<DEnumLiteral, 0, 'N', LEnumLiteral> = [];\r\n\r\n    public static new(name?: DNamedElement[\"name\"], father?: DEnumerator[\"father\"], persist: boolean = true): DEnumerator {\r\n        if (!name) name = this.defaultname(\"enum \", father);\r\n        return new Constructors(new DEnumerator('dwc'), father, persist, undefined).DPointerTargetable().DModelElement()\r\n            .DNamedElement(name).DEnumerator().end();\r\n    }\r\n    static new2(setter: Partial<ObjectWithoutPointers<DEnumerator>>, father: DEnumerator[\"father\"], name?: DEnumerator[\"name\"]): DEnumerator {\r\n        if (!name) name = this.defaultname(\"enum \", father);\r\n        return new Constructors(new DEnumerator('dwc'), father, true, undefined).DPointerTargetable().DModelElement()\r\n            .DNamedElement(name).DEnumerator().end((d) => { Object.assign(d, setter); });\r\n    }\r\n\r\n    static new3(a: Partial<EnumPointers>, callback: undefined | ((d: DEnumerator, c: Constructors) => void), persist: boolean = true): DEnumerator {\r\n        if (!a.name) a.name = this.defaultname(\"enum \", a.father);\r\n        return new Constructors(new DEnumerator('dwc'), a.father, persist, undefined, a.id)\r\n            .DPointerTargetable().DModelElement().DNamedElement(a.name)\r\n            .DEnumerator()\r\n            .end(callback);\r\n    }\r\n}\r\n\r\n@Node\r\n@RuntimeAccessible('LEnumerator')\r\nexport class LEnumerator<Context extends LogicContext<DEnumerator> = any, C extends Context = Context, D extends DEnumerator = DEnumerator> extends LDataType { // DDataType\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    public __raw!: DEnumerator;\r\n    id!: Pointer<DEnumerator, 1, 1, LEnumerator>;\r\n    // static singleton: LEnumerator;\r\n    // static logic: typeof LEnumerator;\r\n    // static structure: typeof DEnumerator;\r\n\r\n    // inherit redefine\r\n    // instanceClass: EJavaClass // ?\r\n    // isInstance(object: EJavaObject): boolean; ?\r\n    // getClassifierID(): number;\r\n    instanceClassName!: string;\r\n    parent!: LPackage [];\r\n    father!: LPackage;\r\n    annotations!: LAnnotation[];\r\n    name!: string;\r\n    namespace!: string;\r\n    defaultValue!:string[];\r\n    serializable!: boolean;\r\n    // usedBy!: LAttribute[];\r\n    isPrimitive!: false;\r\n    isClass!: false;\r\n    isEnum!: true;\r\n    // personal\r\n    literals!: LEnumLiteral[];\r\n    ordinals!: LEnumLiteral[]; // literal array ordered by ordinal number\r\n\r\n    protected generateEcoreJson_impl(context: Context, loopDetectionObj: Dictionary<Pointer, DModelElement> = {}): Json {\r\n        loopDetectionObj[context.data.id] = context.data;\r\n        const json: Json = {};\r\n        let d = context.data;\r\n        if (d.instanceClassName) json[ECoreEnum.instanceTypeName] = d.instanceClassName;\r\n        json[ECoreEnum.xsitype] = 'ecore:EEnum';\r\n        json[ECoreEnum.namee] = d.name;\r\n        json[ECoreEnum.serializable] = d.serializable ? \"true\" : \"false\";\r\n        json[ECoreEnum.eLiterals] = context.proxyObject.literals.map(l => l.generateEcoreJson(loopDetectionObj));\r\n        return json; }\r\n\r\n    public duplicate(deep: boolean = true): this {\r\n        return this.cannotCall( ((this.constructor as typeof RuntimeAccessibleClass).cname || this.constructor.name) + \"duplicate()\"); }\r\n    protected get_duplicate(c: Context): ((deep?: boolean) => LEnumerator) {\r\n        return (deep: boolean = false) => {\r\n            let ret: LEnumerator = null as any;\r\n            TRANSACTION(this.get_name(c)+'.duplicate()', ()=>{\r\n                let le: LEnumerator = c.proxyObject.father.addEnumerator(c.data.name);\r\n                let de: D = le.__raw as D;\r\n                de.defaultValue = c.data.defaultValue;\r\n                de.serializable = c.data.serializable;\r\n                let we: WEnumerator = le as any;\r\n                we.annotations = deep ? c.proxyObject.annotations.map(lchild => lchild.duplicate(deep).id) : c.data.annotations;\r\n                we.literals = deep ? c.proxyObject.literals.map(lchild => lchild.duplicate(deep).id) : c.data.literals;\r\n                ret = le;\r\n            })\r\n            return ret; }\r\n    }\r\n\r\n\r\n    protected get_children_idlist(c: Context): Pointer<DAnnotation | DEnumLiteral, 1, 'N'> {\r\n        return [...super.get_children_idlist(c) as Pointer<DAnnotation | DEnumLiteral, 1, 'N'>, ...c.data.literals]; }\r\n\r\n    public addLiteral(name?: DEnumLiteral[\"name\"], value?: DEnumLiteral[\"value\"]): LEnumLiteral { return this.cannotCall(\"addLiteral\"); }\r\n    protected get_addLiteral(c: Context): this[\"addLiteral\"] {\r\n        return (name?: DEnumLiteral[\"name\"], value?: DEnumLiteral[\"value\"]) => LPointerTargetable.fromD(DEnumLiteral.new(name, value, c.data.id, true)); }\r\n\r\n    protected get_literals(context: Context): this[\"literals\"] {\r\n        return context.data.literals.map((pointer) => {\r\n            return LPointerTargetable.from(pointer)\r\n        }); }\r\n\r\n    protected set_literals(val: PackArr<this[\"literals\"]>, context: Context): boolean {\r\n        const list = val.map((lItem) => { return Pointers.from(lItem) });\r\n        const oldList = context.data.literals;\r\n        const diff = U.arrayDifference(oldList, list);\r\n        TRANSACTION(this.get_name(context)+'.literals', ()=>{\r\n            SetFieldAction.new(context.data, 'literals', list, \"\", true);\r\n            for (let id of diff.added) {\r\n                SetFieldAction.new(id, 'father', context.data.id, '', true);\r\n                SetFieldAction.new(id, 'parent', context.data.id, '+=', true);\r\n            }\r\n            for (let id of diff.removed as Pointer<DModelElement>[]) {\r\n                SetFieldAction.new(id, 'father', undefined, '', true);\r\n                const parent = DPointerTargetable.from(id).parent;\r\n                U.arrayRemoveAll(parent, context.data.id);\r\n                SetFieldAction.new(id, 'parent', parent, '', true);\r\n            }\r\n        })\r\n        return true; }\r\n\r\n    protected get_ordinals(context: Context): this[\"ordinals\"]{\r\n        let ret: LEnumLiteral[] = [];\r\n        let literals: LEnumLiteral[] = context.proxyObject.literals;\r\n        let dliterals: DEnumLiteral[] = literals.map(d => d.__raw);\r\n        /*\r\n        if it happens like:   second=2, third, fourth=4, fifth=3, sixth.(six would be 4 but 4 already exist)\r\n        there are 2 problems:\r\n        1) [3] is already occupied by third, but fith is correctly being the only one explicitly declaring his ordinal 3.\r\n           fixed by first assigning all known ordinals, then starting with the assumed ordinals.\r\n        2) sixth would get in position fourth, but that is already occupied\r\n         */\r\n\r\n        // adressing 1)\r\n        for (let i = 0; i < dliterals.length; i++) {\r\n            let v = dliterals[i].value;\r\n            if (v) { ret[v] = literals[i]; }\r\n        }\r\n\r\n        // setting assumed literals\r\n        let currentOrdinal = 0;\r\n        for (let i = 0; i < dliterals.length; i++) {\r\n            let v = dliterals[i].value;\r\n            if (v) { currentOrdinal = v; continue; }\r\n            while (ret[currentOrdinal]) currentOrdinal++; // adressing 2)\r\n            ret[currentOrdinal] = literals[i];\r\n        }\r\n        return ret;\r\n    }\r\n}\r\nRuntimeAccessibleClass.set_extend(DDataType, DEnumerator);\r\nRuntimeAccessibleClass.set_extend(LDataType, LEnumerator);\r\n@RuntimeAccessible('DModelM1')\r\nexport class DModelM1 extends DNamedElement{\r\n    name!: string;\r\n    roots!: Pointer<DObject, 1, 'N', LObject> // no package ma LObjects[] (solo quelli isRoot)\r\n    children!: DModelM1[\"roots\"];\r\n}\r\n\r\n@RuntimeAccessible('LModelM1')\r\nexport class LModelM1 extends LNamedElement{\r\n    name!: string;\r\n    roots!: LObject[];\r\n    children!: LModelM1[\"roots\"];\r\n\r\n}\r\nRuntimeAccessibleClass.set_extend(DModelM1, DNamedElement);\r\nRuntimeAccessibleClass.set_extend(LModelM1, LNamedElement);\r\ntype DPrimitiveType = DClass;\r\ntype LPrimitiveType = LClass;\r\n\r\n\r\n// problema: o costringo l'utente a fare sempre .value per ricevere il valore invece dei metadati\r\n// oppure ritorno il valore da subito ma dal valore non posso accedere ai metadati (upperbound...) a meno che non trovi un altor sistema.\r\n\r\n// possibile fix: LValue.toString() che ritorna il .value\r\n\r\n\r\n\r\n\r\n\r\n@RuntimeAccessible('DModel')\r\nexport class DModel extends DNamedElement { // DNamedElement\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // static singleton: LModel;\r\n    // static logic: typeof LModel;\r\n    // static structure: typeof DModel;\r\n\r\n    // inherit redefine\r\n    id!: Pointer<DModel, 1, 1, LModel>;\r\n    parent: Pointer<DModelElement, 0, 'N', LModelElement> = [];\r\n    father!: Pointer<DModelElement, 1, 1, LModelElement>;\r\n    annotations: Pointer<DAnnotation, 0, 'N', LAnnotation> = [];\r\n    name!: string;\r\n    // personal\r\n    packages: Pointer<DPackage, 0, 'N', LPackage> = [];\r\n    isMetamodel: boolean = true;\r\n    objects: Pointer<DObject, 0, 'N', LObject> = [];\r\n    models: Pointer<DModel, 0, 'N', LModel> = [];\r\n    instanceof?: Pointer<DModel>;\r\n    instances!: Pointer<DModelElement>[];\r\n    dependencies!: Pointer<DModel>[];\r\n\r\n    public static new(name?: DNamedElement[\"name\"], instanceoff?: DModel[\"instanceof\"], isMetamodel?: DModel[\"isMetamodel\"], persist: boolean = true): DModel {\r\n        let dmodels: DModel[] = Selectors.getAll(DModel, undefined, undefined, true, false);\r\n        let dmodelnames: string[] = dmodels.map((d: DModel) => d.name);\r\n        if (!name) name = this.defaultname(\"model_\", ((name: string) => dmodelnames.includes(name)));\r\n        return new Constructors(new DModel('dwc'), undefined, persist, undefined).DPointerTargetable().DModelElement()\r\n            .DNamedElement(name).DModel(instanceoff, isMetamodel).end();\r\n    }\r\n    static new2(setter: Partial<ObjectWithoutPointers<DModel>>, name?: DModel[\"name\"], instanceoff?: DModel[\"instanceof\"]): DModel {\r\n        let dmodels: DModel[] = Selectors.getAll(DModel, undefined, undefined, true, false);\r\n        let dmodelnames: string[] = dmodels.map((d: DModel) => d.name);\r\n        if (!name) name = this.defaultname(\"model_\", ((name: string) => dmodelnames.includes(name)));\r\n        return new Constructors(new DModel('dwc'), undefined, true, undefined).DPointerTargetable().DModelElement()\r\n            .DNamedElement(name).DModel(instanceoff).end((d) => { Object.assign(d, setter); });\r\n    }\r\n\r\n    static new3(a: Partial<ModelPointers>, callback: undefined | ((d: DModel, c: Constructors) => void), persist: boolean = true): DModel {\r\n        let dmodels: DModel[] = Selectors.getAll(DModel, undefined, undefined, true, false);\r\n        let dmodelnames: string[] = dmodels.map((d: DModel) => d.name);\r\n        if (!a.name) a.name = this.defaultname(\"model_\", ((name: string) => dmodelnames.includes(name)));\r\n        return new Constructors(new DModel('dwc'), a.father, persist, undefined, a.id)\r\n            .DPointerTargetable().DModelElement().DNamedElement(a.name)\r\n            .DModel(a.instanceof, !a.instanceof)\r\n            .end(callback);\r\n    }\r\n}\r\n\r\n@RuntimeAccessible('EdgeStarter')\r\nexport class EdgeStarter<T1=any, T2=any>{ // <T1 extends LPointerTargetable = LPointerTargetable, T2 extends LPointerTargetable = LPointerTargetable>{\r\n    id: string; // suggested id & key for the element.\r\n    start: LModelElement;\r\n    end: LModelElement;\r\n    startNode: LGraphElement;\r\n    endNode: LGraphElement;\r\n    startVertex: LVoidVertex;\r\n    endVertex: LVoidVertex;\r\n    startGraph: LGraph;\r\n    endGraph: LGraph;\r\n    startSize: GraphSize;\r\n    endSize: GraphSize;\r\n    startVertexSize: GraphSize;\r\n    endVertexSize: GraphSize;\r\n    otherEnds: LGraphElement[];\r\n    extendTargets: LGraphElement[];\r\n    sameGraph: boolean;\r\n    isSameGraph: boolean;\r\n    overlaps: boolean;\r\n    vertexOverlaps: boolean;/*\r\n    firstRenderedStartNode: LGraphElement;\r\n    firstRenderedEndNode: LGraphElement;*/\r\n    // todo: if you want to get the first visible parent node (like for pkg dependencies), use edgestarter.startNode.firstRenderedNode\r\n    constructor(start: LModelElement, end: LModelElement, sn: LGraphElement, en: LGraphElement,\r\n                otherPossibleEnds: LGraphElement[], m1refindex: number, type:string) {\r\n        this.start = start;\r\n        this.end = end;\r\n        this.startNode = sn;\r\n        this.endNode = en;\r\n        this.otherEnds = this.extendTargets = otherPossibleEnds;// || end.nodes;\r\n        //console.log('edgestarter ss', {end, start, sn, en});\r\n\r\n        this.startSize = sn.outerSize;\r\n        this.endSize = en.outerSize;\r\n        this.startVertex = sn.vertex as any;\r\n        this.endVertex = en.vertex as any;\r\n        this.startGraph = this.startVertex?.root;\r\n        this.endGraph = this.endVertex?.root;\r\n        this.sameGraph = this.isSameGraph = this.endGraph?.id === this.startGraph?.id;\r\n        //this.firstRenderedStartNode = this.startNode.firstRenderedNode;\r\n        //this.firstRenderedEndNode = this.startNode.firstRenderedNode;\r\n        // this.firstVisibleStart = this.startNode.firstRenderedNode;\r\n        //console.log('edgestarter evs', {end, start, sn, en});\r\n        this.startVertexSize = this.startVertex === sn ? this.startSize : this.startVertex.outerSize;\r\n        this.endVertexSize = this.endVertex === en ? this.endSize : this.endVertex.outerSize;\r\n        this.overlaps = this.startSize?.isOverlapping(this.endSize);\r\n        this.vertexOverlaps = this.startVertexSize?.isOverlapping(this.endVertexSize);\r\n        //console.log('edgestarter end', {end, start, sn, en});\r\n        // how to pick edgeid:\r\n        // using nodeid is useless, as a ref might be hidden and take the node of a class or upper, it must be resolved at conceptual model-level\r\n        // mid = model id\r\n        // NB: mid -> mid is safe for extends, why:\r\n        // if a->b1->c && a->b2->c and both b1,b2 are hidden, extend edges might become both a->c, but in that case is fine to have it only once (filter it in suggestions)\r\n        // mid -> mid                   is safe for package-dependencies for the same reason as class inheritance.\r\n        // mid -> mid                   is not safe for dvalues which might have duplicate references. (DValue.a -> [Object.b, Object.b])\r\n        // mid + (valueindex) -> mid    is safe for everything i think.\r\n        // !!!! REMEMBER, DOTS AND ~ ARE NOT ALLOWED IN ID (css selector char) !!!\r\n        this.id = start.id + ('_' + m1refindex) + '-' + end.id + type;\r\n    }\r\n    /*\r\n    static oneToMany<T1 extends LModelElement = LModelElement, T2 extends LModelElement = LModelElement>(start: T1, ends:T2[]): EdgeStarter<T1, T2>[] {\r\n        let sn = start.node;\r\n        if (!sn) return [];\r\n        let rett: (EdgeStarter | undefined)[] = ends.map( (e) => {\r\n            if(!e) return undefined;\r\n            let en = e.node;\r\n            return en ? new EdgeStarter(start, e, sn as LGraphElement, en) : undefined;\r\n        });\r\n        let ret: (EdgeStarter)[] = rett.filter<EdgeStarter>(function(e: EdgeStarter|undefined): e is EdgeStarter { return !!e });\r\n        // let ret: (EdgeStarter)[] = rett.filter<EdgeStarter>((e): (e is EdgeStarter) => { return !!e });\r\n        return ret;\r\n    }*/\r\n}\r\n\r\n@RuntimeAccessible('LModel')\r\nexport class LModel<Context extends LogicContext<DModel> = any, C extends Context = Context, D extends DModel = DModel> extends LNamedElement {\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    public __raw!: DModel;\r\n    id!: Pointer<DModel, 1, 1, LModel>;\r\n    // static singleton: LModel;\r\n    // static logic: typeof LModel;\r\n    // static structure: typeof DModel;\r\n\r\n    // inherit redefine\r\n    parent!: LModel[];\r\n    father!: LModel;\r\n    annotations!: LAnnotation[];\r\n    name!: string;\r\n    namespace!: string;\r\n    // personal\r\n    isMetamodel!: boolean;\r\n\r\n    // Metamodel\r\n    packages!: LPackage[];\r\n    models!: LModel[];\r\n    instances!: LModel[];\r\n    dependencies!: LModel[]; // points to other models of the same level\r\n    allDependencies!: LModel[];\r\n    __info_of__dependencies: Info = {type: 'LModel[]',\r\n        txt:'Include other models as prerequisite for this model, it is as if this model is \"extending\" other models.'};\r\n    __info_of__allDependencies: Info = {type: 'LModel[]', txt:'Same as dependencies, but it solves recursively the dependencies of his dependencies.'};\r\n\r\n    // Model\r\n    instanceof?: LModel;\r\n    objects!: LObject[];\r\n    crossObjects!: LObject[];\r\n    roots!: LObject[];\r\n\r\n    // utilities to go down in the tree (plural names)\r\n    enums!: LEnumerator[] & Dictionary<DocString<\"$name\">, LEnumerator>; // alias for enumerators\r\n    enumerators!: LEnumerator[] & Dictionary<DocString<\"$name\">, LEnumerator>;\r\n    crossEnumerators!: LEnumerator[] & Dictionary<DocString<\"$name\">, LEnumerator>;\r\n    classes!: LClass[] & Dictionary<DocString<\"$name\">, LClass>;\r\n    crossClasses!: LClass[] & Dictionary<DocString<\"$name\">, LClass>;\r\n    operations!: LOperation[];\r\n    parameters!: LParameter[];\r\n    exceptions!: LClassifier[];\r\n    attributes!: LAttribute[];\r\n    references!: LReference[];\r\n    literals!: LEnumLiteral[];\r\n    values!: LValue[];\r\n    allSubAnnotations!: LAnnotation[];\r\n    allCrossSubAnnotations!: LAnnotation[];\r\n    allSubPackages!: LPackage[];\r\n    allCrossSubPackages!: LPackage[];\r\n    allSubObjects!: LObject[];\r\n    allCrossSubObjects!: LObject[];\r\n    allSubValues!: LValue[];\r\n    allCrossSubValues!: LValue[];\r\n    suggestedEdges!: {extend: EdgeStarter[], reference:EdgeStarter[], packageDependencies: EdgeStarter[]}; //, model: EdgeStarter[], package:EdgeStarter[], class:EdgeStarter[]};\r\n    __info_of__suggestedEdges: Info = {type: 'Dictionary<\"extend\" | \"reference\" | \"packageDependencies\" | DmodelName, EdgeStarter[]>', txt: \"A map to access all possible kind of edges based on model data.\" +\r\n            \"<br/>extend and reference are the most commonly used for horizontal references (outside the containment tree schema).\" +\r\n            \"<br/>packageDependencies links packages using classes from other packages.\" +\r\n            // \"<br/>other keys are the names of container data types (mode, package, class, object...) from them to their childrens rendered as Nodes (vertical tree schema).\" +\r\n            // todo: implement the commented part as LGrahElement.vertexs.map(v=>{start:v.parentnode.isVertex ? v.parentnode.id : undefined, end:v.id}).filter(e=>e.start) instead. it's a thing of graph more than model.\r\n            \"<br/> EdgeStarter is a collection of data useful to start a &lt;Edge /&gt; in JSX.\"}\r\n\r\n    protected generateEcoreJson_impl(context: Context, loopDetectionObj: Dictionary<Pointer, DModelElement> = {}): Json {\r\n        loopDetectionObj[context.data.id] = context.data;\r\n        const json: GObject = {};\r\n\r\n        // if it's M2 metamodel\r\n        if (context.data.isMetamodel) {\r\n            const packageArr: Json[] = [];\r\n            for (let pkg of context.proxyObject.packages) { packageArr.push(pkg.generateEcoreJson(loopDetectionObj)); }\r\n            // return (context.proxyObject.packages[0])?.generateEcoreJson(loopDetectionObj);\r\n            json[ECoreRoot.ecoreEPackage] = packageArr;\r\n            return json;\r\n        }\r\n\r\n        // if it's M1 model\r\n        // let serializeasroot = context.proxyObject.isRoot && loopDetectionObj.length; // if rootobj is nested because you started the serialization from another node, i prevent it generating root content\r\n        for (let obj of context.proxyObject.roots) { json[obj.ecoreRootName] = obj.generateEcoreJson(loopDetectionObj); }\r\n\r\n        return json; }\r\n\r\n    public addPackage(name?: DPackage[\"name\"], uri?: DPackage[\"uri\"], prefix?: DPackage[\"prefix\"]): LPackage { return this.cannotCall(\"addPackage\"); }\r\n    public get_addPackage(context: Context): ((name?: DPackage[\"name\"], uri?: DPackage[\"uri\"], prefix?: DPackage[\"prefix\"]) => LPackage) {\r\n        console.log(\"Model.addPackage()\", {context, thiss: this});\r\n        return (name?: DPackage[\"name\"], uri?: DPackage[\"uri\"], prefix?: DPackage[\"prefix\"]) => {\r\n            return LPointerTargetable.fromD(DPackage.new(name, uri, prefix, context.data.id, true, DModel));\r\n        }\r\n    }\r\n\r\n    public get_dependencies(c: Context): this['dependencies']{\r\n        return LPointerTargetable.fromPointer(c.data.dependencies);\r\n    }\r\n    public get_allDependencies(c: Context): this['allDependencies']{\r\n        let targets: LModel[] = L.fromArr(c.data.dependencies);\r\n        return U.iterateChildProperties(targets, (e)=>e.dependencies);\r\n        /*let alreadyParsed: Dictionary<Pointer, LModel> = {};\r\n        while (targets.length) {\r\n            let nextTargets = [];\r\n            for (let target of targets){\r\n                if (alreadyParsed[target.id]) continue;\r\n                alreadyParsed[target.id] = target;\r\n                U.arrayMergeInPlace(nextTargets, target.dependencies);\r\n            }\r\n            targets = nextTargets;\r\n        }\r\n        return Object.values(alreadyParsed);*/\r\n    }\r\n    /*public set_dependencies(c: Context): this['dependencies']{\r\n        default setter is fine, should automatically do the difference of pointers and trigger -= or +=\r\n    }*/\r\n\r\n    public static namesORDObjectsToID<T extends DPointerTargetable = DPointerTargetable>(a: T): Pointer<T>[];\r\n    public static namesORDObjectsToID<T extends DPointerTargetable = DPointerTargetable>(a: T[]): Pointer<T>[];\r\n    public static namesORDObjectsToID<L extends LPointerTargetable = LPointerTargetable>(a: L): Pointer<LtoD<L>>[];\r\n    public static namesORDObjectsToID<L extends LPointerTargetable = LPointerTargetable>(a: L[]): Pointer<LtoD<L>>[];\r\n    public static namesORDObjectsToID<T extends DPointerTargetable = DPointerTargetable>(a: Pointer<T>): Pointer<T>[];\r\n    public static namesORDObjectsToID<T extends DPointerTargetable = DPointerTargetable>(a: Pointer<T>[]): Pointer<T>[];\r\n    public static namesORDObjectsToID(a: string, namedCandidates: LModelElement[]): Pointer[];\r\n    public static namesORDObjectsToID(a: string[], namedCandidates: LModelElement[]): Pointer[];\r\n    public static namesORDObjectsToID(a: string | LClass | DClass | Pointer, namedCandidates: LModelElement[]): Pointer[];\r\n    public static namesORDObjectsToID(a: (string | LClass | DClass | Pointer)[], namedCandidates: LModelElement[]): Pointer[];\r\n    public static namesORDObjectsToID<T extends DPointerTargetable = DPointerTargetable>(a: orArr<(string | T | Pointer<T>)>): Pointer<T>[];\r\n    // return the first array parameter converted in an array of pointers. The second parameter is the scope where names are allowed to match. if empty all class.names will fail mapping to id's.\r\n    // second parameter is mandatory when the array contain names, to prevent looking into class names of different models.\r\n    public static namesORDObjectsToID<T extends DPointerTargetable = DPointerTargetable>(targets: orArr<(string | T | Pointer<T>)>, namedCandidates?: LModelElement[]): Pointer<T>[] {\r\n        // let targets = any[] = (!Array.isArray(targets0)) ? targets0 : [targets0];\r\n        if (!targets) return [];\r\n        let ret: Pointer<T>[] = [];\r\n        let state: DState = store.getState();\r\n        if (targets && !Array.isArray(targets)) targets = [targets];\r\n        let dnamedcandidates: DNamedElement[] = namedCandidates ? DPointerTargetable.fromArr(namedCandidates as any) as DNamedElement[] : [];\r\n        let dAllowedNamesMap: Dictionary<DocString<\"name\">, Pointer<T>> = (dnamedcandidates as any[]).reduce( (acc, val) => { acc[val.name] = val.id; return acc; }, {});\r\n        //let dtargets: DNamedElement[] = targets ? DPointerTargetable.fromArr(targets) as DNamedElement[] : [];\r\n        let tmp: Pointer<T> | undefined;\r\n        for (let target of targets) {\r\n            // try as name\r\n            tmp = dAllowedNamesMap[target as string];\r\n            if (tmp) { ret.push(tmp); continue; }\r\n            // try as $name\r\n            tmp = dAllowedNamesMap[\"$\" + target as string];\r\n            if (tmp) { ret.push(tmp); continue; }\r\n            // try as id\r\n            let d: DNamedElement = DPointerTargetable.from(target as Pointer, state);\r\n            if (d && dAllowedNamesMap[d.name]) { ret.push(target as Pointer<T>); continue; }\r\n            Log.ww(\"namesORDObjectsToID() could not resolve name:\", {name: target, namedCandidates, targets});\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    _defaultGetter(c: Context, key: string): any {\r\n        //console.log(\"$getter 000\", {key, ism1:!c.data.isMetamodel, ism:c.data.isMetamodel, data:c.data});\r\n        if (!c.data.isMetamodel) return this._defaultGetterM1(c, key);\r\n        return this._defaultGetterM2(c, key);\r\n    }\r\n    _defaultGetterM2(c: Context, key: string): any{\r\n        if ((TargetableProxyHandler.childKeys[key[0]])){\r\n            // look for m1 matches\r\n            let k = key.substring(1).toLowerCase();\r\n            let s = store.getState();\r\n\r\n            for (let subelement of this.get_allSubPackages(c, s)){\r\n                let n = subelement.__raw.name;\r\n                if (n && n.toLowerCase() === k) return subelement;\r\n            }\r\n            for (let subelement of this.get_classes(c, s)){\r\n                let n = subelement.__raw.name;\r\n                if (n && n.toLowerCase() === k) return subelement;\r\n            }\r\n        }\r\n        return this.__defaultGetter(c, key);\r\n        // Log.ee(\"Could not find property \" + key + \" on MetaModel\", {c, key});\r\n    }\r\n    _defaultGetterM1(c: Context, key: string): any{\r\n        // if m1.$m1RootObjectName then --> return that root object\r\n        // if m1.$m1ObjectName then --> return that sub object nested somewhere in the model.\r\n        // if m1.$m2classname\"s\" then --> this.instancesOf(\"m2classname\")\r\n        // if m1.$m2classname then ---> m2.$m2classname (lower priority, if there are 2 metaclasses differing only by final s,\r\n        // the one with 1 more final \"s\" if shadowed by the instances of the one with 1 less final \"s\",\r\n        // in that case you can access the shadowed one through m1.instanceof.$classnames\r\n        // priorities: 1) m1 name natch --> m1object. 2) m2 exact name match --> m2item, 3) m2 name+\"s\" match --> instances\r\n        // to access m2 classes within a package, need to navigate it like model.$packagename.Ssubcpackagename.$classname,\r\n        // path + \"s\" won't work in that case, and need to use this.getInstancesOf instead\r\n        if (TargetableProxyHandler.childKeys[key[0]]){\r\n            // look for m1 matches\r\n            let deepmatch: LObject | undefined;\r\n            let k = key.substring(1).toLowerCase();\r\n\r\n            const directSubObjects: Dictionary<Pointer, boolean> = U.objectFromArrayValues(c.data.objects);\r\n            for (let subobject of this.get_allSubObjects(c)){\r\n                let n = subobject.name;\r\n                if (!n || n.toLowerCase() !== k) continue;\r\n                // A0) perfect match with direct child object\r\n                if (directSubObjects[subobject.id]) return subobject; // actually cannot do direct match, because proxy get function will solve it directly before calling _defaultGetter\r\n                else if (!deepmatch) deepmatch = subobject;\r\n            }\r\n            // A1) match with deep sub-object\r\n            if (deepmatch) return deepmatch;\r\n\r\n            // look for m2 matches\r\n            let m2: LModel | undefined = this.get_instanceof(c);\r\n            if (!m2) return Log.ee(\"Could not find m1 match for data.$name. And the metamodel is missing, so cannot get instances by type.\", {c, key, m2});\r\n            let m2item: LClass | LPackage;\r\n            // check for a perfect m2 name match and return it\r\n            m2item = (m2 as GObject)[key];\r\n            if (m2item) return m2item; //this.instancesOf(key);\r\n            if (!m2) Log.ee(\"Could not find property \" + key + \" on M1 Model\", {c, key, m2});\r\n            // if not a perfect name match, i try name+s match for instances\r\n            if (key[key.length - 1] === \"s\") {\r\n                let key1 = key.substring(0, key.length - 1);\r\n                m2item = (m2 as GObject)[key1];\r\n                if (m2item) {\r\n                    if (m2item.className === \"DClass\") return this.get_instancesOf(c)(m2item as LClass);\r\n                    else return Log.ee(\"Could not get instances of \" + key1 + \".\", {c, key, m2});\r\n                }\r\n            }\r\n            if (!m2) return Log.ee(\"Could not find any subelement with name \" + key + \" on M1 or M2 Models\", {c, key, m1: c.data, m2});\r\n        }\r\n\r\n        return this.__defaultGetter(c, key);\r\n    }\r\n    private static otherObjectsTemp: Dictionary<DocString<\"className\">, LObject[]> = undefined as any;\r\n    private static otherObectsAccessedKeys: DocString<\"className\">[] = [];\r\n    // public otherObjectsSetup(){ LModel.otherObjectsTemp = undefined; LModel.otherObectsAccessedKeys = []; }\r\n    otherObjects!: (excludeInstances: orArr<(string | LClass | Pointer)>, excludeSubclasses?: boolean)=>LObject[];\r\n    otherInstances!: (excludeInstances: orArr<(string | LClass | Pointer)>, excludeSubclasses?: boolean)=>LObject[];\r\n    __info_of__otherObjects: Info = {type:\"(...excludeInstances: (string|LClass|Pointer)[], excludeSubclasses: boolean = false)=>LObject[]\", txt:<div>Alias for this.otherInstances.</div>};\r\n    __info_of__otherInstances: Info = {type:\"(...excludeInstances: (string|LClass|Pointer)[], excludeSubclasses: boolean = false)=>LObject[]\", txt:<div>Read this.instancesOf documentation first.\r\n            <br/>Retrieves all the objects not obtained between previous calls of this.instancesOf and the last call of this method.\r\n            <br/>Meaning calling it twice without any instancesOf in between, it will return all objects.</div>};\r\n\r\n    public get_otherObjects(c: Context): (excludeInstances: orArr<(string | LClass | Pointer)>, excludeSubclasses?: boolean)=>LObject[]{\r\n        return this.get_otherInstances(c); }\r\n    public get_otherInstances(c: Context): (excludeInstances: orArr<(string | LClass | Pointer)>, excludeSubclasses?: boolean)=>LObject[]{\r\n        // todo:\r\n        return (excludeInstances: orArr<(string | LClass | Pointer)>, includeSubclasses: boolean = false)=>{\r\n            let ret: LObject[];\r\n            this.get_instancesOf(c)(excludeInstances, includeSubclasses) // and drop the result\r\n            if (!LModel.otherObjectsTemp) { ret = this.get_allSubObjects(c); }\r\n            else {\r\n                let dict = {...LModel.otherObjectsTemp};\r\n                for (let key of LModel.otherObectsAccessedKeys) delete dict[key];\r\n                delete (LModel as any).otherObjectsTemp;\r\n                delete (LModel as any).otherObectsAccessedKeys;\r\n                ret = Object.values(dict).flat();\r\n            }\r\n            return ret;\r\n        }\r\n    }\r\n    // not meant to be called directly.\r\n    private _populateOtherObjects(c:Context, classes?: LClass[]): void {\r\n        // from names, DClass and ptrs, make them only ptrs. all classes of this model are valid name targets.\r\n        // nb: cannot optimize getting only instantiated classes from this.get_allSubObjects because if a class have 0 instances should have an empty array instead of undefined (risk jsx crash)\r\n        let state: DState = store.getState();\r\n        let dinstancetypes: DClass[] = (classes || this.get_classes(c, state)).map(c => c.__raw);\r\n        let namemap: Dictionary<DocString<\"className\">, DClass> = {};\r\n        namemap = dinstancetypes.reduce( (acc, current) => { namemap[current.name] = current; return namemap; }, namemap);\r\n        let idtoname: Dictionary<Pointer, string> = {};\r\n        for (let n in namemap) {idtoname[namemap[n].id] = n; }\r\n        // make it more general, first make a dictionary holding all selected types as keys, including \"_other\"\r\n        // then a SEPARATE (split this) function to return only the selected keys, merging the subarrays in the global naming instance map.\r\n        LModel.otherObjectsTemp = {};\r\n        LModel.otherObectsAccessedKeys = [];\r\n        // part 1: i add empty arrays for all instances, but not include shapeless objects.\r\n        for (let name in namemap) { LModel.otherObjectsTemp[name] = []; } //LPointerTargetable.fromPointer(namemap[name].instances); }\r\n        // part 2: for shapeless objs too\r\n        LModel.otherObjectsTemp[undefined as any] = [];\r\n        let allObjects: LObject[] = this.get_allSubObjects(c, state);\r\n        // part 3: now i populate the Model.otherObjectsTemp dictionary arrays\r\n        for (let o of allObjects) {\r\n            // if (o.__instanceof) continue;\r\n            let name: string | undefined = idtoname[o.__raw.instanceof];\r\n            if (!LModel.otherObjectsTemp[name]) {\r\n                LModel.otherObjectsTemp[name] = [o];\r\n                Log.eDevv(\"model._populateOtherObjects() this case should never happen\", {name, o, allObjects, namemap, idtoname});\r\n            }\r\n            else LModel.otherObjectsTemp[name].push(o);\r\n        }\r\n    }\r\n\r\n    public instancesOf(instancetypes0: orArr<(string | LClass | Pointer)>, includeSubclasses: boolean = false): LObject[]{ return this.cannotCall(\"instancesOf\"); }\r\n    public __info_of__instancesOf: Info = {type: \"(instancetypes: orArr<(string | LClass | Pointer)>, includeSubclasses: boolean = false) => LObject[]\",\r\n        txt:<div>Retrieves all objects instancing a target class.\r\n            <br/>The first parameter is the targeted class, which can be his name, pointer or object.\r\n            <br/>The second parameter tells if instances of his subclasses needs to be retreieved as well.</div>\r\n    }\r\n    // M1\r\n    public get_instancesOf(c:Context): (this[\"instancesOf\"]){\r\n        if (c.data.isMetamodel) { return (...a:any) => { Log.ww(\"cannot call instancesOf() on a metamodel\"); return []; } }\r\n        return (instancetypes0: orArr<(string | LClass | Pointer)>, includeSubclasses: boolean = false): LObject[] => {\r\n            let state: DState = store.getState();\r\n            let classes = this.get_classes(c, state);\r\n            if (!LModel.otherObjectsTemp) this._populateOtherObjects(c, classes);\r\n            if (!Array.isArray(instancetypes0)) instancetypes0 = [instancetypes0];\r\n            // from names, DClass and ptrs, make them only ptrs. all classes of this model are valid name targets.\r\n            let instancetypes: Pointer<DClass>[] = LModel.namesORDObjectsToID(instancetypes0, classes) as any;\r\n            let dinstancetypes: DClass[] = DClass.fromPointer(instancetypes, state);\r\n            if (includeSubclasses) {\r\n                let arr: LClass[] = dinstancetypes.map(d => LPointerTargetable.fromD(d));\r\n                for (let c of arr) dinstancetypes.push(...(c.allSubClasses.map(l => l.__raw) || []));\r\n                dinstancetypes = [...new Set(dinstancetypes)];\r\n            }\r\n            let ret: LObject[] = []\r\n            for (let c of dinstancetypes) {\r\n                let arr: LObject[] = LModel.otherObjectsTemp[c.name]\r\n                if (!arr || !arr.length) continue;\r\n                ret.push(...arr);\r\n                LModel.otherObectsAccessedKeys.push(c.name);\r\n            }\r\n            return ret;\r\n        }\r\n    }\r\n/*\r\n* instanceof === some class -> instantiate object and forces to conform to that class\r\ninstanceof === null  --> shapeless object\r\ninstanceof === undefined or missing  --> auto-detect and assign the type\r\n */\r\n    addObject(json: GObject, instanceoff: Pack1<LClass> | DocString<\"ClassName\"> | undefined | null = undefined, forceCreation: boolean = false): ReturnType<LValue[\"addObject\"]>{ return this.cannotCall(\"LValue.addObject\"); }\r\n    __info_of__addObject: Info = {type: \"(json: object, instanceof?: LClass) => LObject\",\r\n        txt: \"Appends an object instancing \\\"instanceof\\\" to the model.\\n<br>Setting his own properties, and DValues according to the content of the parameter object.\"}\r\n    get_addObject(c: Context): ReturnType<LValue[\"get_addObject\"]> { return (LValue.singleton as LValue).get_addObject.call(this, c); }\r\n\r\n    instantiableClasses(o?: GObject, loose: boolean = false):LClass[] { return this.cannotCall(\"instantiableClasses\"); }\r\n    __info_of__instantiableClasses: Info = {type: \"(o?: object, loose?: boolean) => LClass[]\",\r\n        txt: \"List of all classes which can be used to instantiate an object.\" +\r\n            \"\\n<br>Abstract and Interface classes are excluded.\" +\r\n            \"\\n<br>If the parameter \\\"o\\\" is specified, it will filter only the instances conforming to the object schema.\" +\r\n            \"\\n<br>Results are sorted from tightest fit to loosest fit.\" +\r\n            \"\\n<br>loose parameter set to true makes return instead a list of matching scores of all subclasses.\", hidden: true}\r\n    // M1\r\n    get_instantiableClasses(c: Context): LValue[\"instantiableClasses\"] {\r\n        if (c.data.isMetamodel) { return (...a:any)=> { Log.ww(\"cannot call instantiableClasses() on a metamodel\"); return []; } }\r\n        return (LValue.singleton as LValue).get_instantiableClasses.call(this, c)\r\n    }\r\n\r\n    public get_suggestedEdges(context: Context): this[\"suggestedEdges\"]{\r\n        let ret: this[\"suggestedEdges\"];\r\n        if (context.data.isMetamodel) ret = this.impl_get_suggestedEdgesM2(context);\r\n        else ret = this.impl_get_suggestedEdgesM1(context);\r\n\r\n        return ret;\r\n    }\r\n\r\n    private impl_get_suggestedEdgesM1(context: Context, state?: DState): this[\"suggestedEdges\"]{\r\n        let ret: this[\"suggestedEdges\"] = {extend: [], reference: [], packageDependencies: []};\r\n        if (context.data.isMetamodel) { Log.ww(\"cannot call suggestedEdgesM1() on a metamodel\"); return ret; }\r\n        if (Debug.lightMode) { return ret; }\r\n        let s: DState = store.getState();\r\n        let values: LValue[] = this.get_allSubValues(context, s);\r\n        let map: Dictionary<DocString<\"starting dvalue id\">, EdgeStarter[]> = {};\r\n        if (!state) state = store.getState();\r\n        outer:\r\n            for (let lval of values) {\r\n                if (!lval) continue;\r\n                let dval = lval.__raw;\r\n                let values: any[] = dval.values || [];\r\n                // NB: ELiterals can be pointers in L, but string or ordinal numbers in D, but they won't make edges, so i use .__raw\r\n                inner:\r\n                    for (let valindex = 0; valindex < values.length; valindex++) {\r\n                        let v: any = values[valindex];\r\n                        if (!Pointers.isPointer(v, state)) continue inner;\r\n                        let snode = lval.notEdge;\r\n                        if (!snode || !snode.html) continue outer;\r\n                        if (v === dval.id) continue inner; // pointing to itself\r\n                        let ltarget: undefined | LEnumLiteral | LObject = LPointerTargetable.fromPointer(v, state);\r\n                        if (!ltarget) continue;\r\n                        if (ltarget.className !== DObject.cname) continue inner;\r\n                        let enode = ltarget.notEdge;\r\n                        if (!enode || !enode.html) continue inner;\r\n                        if (!map[dval.id]) map[dval.id] = [];\r\n                        map[dval.id].push(new EdgeStarter(lval, ltarget, snode, enode, [], valindex, 'values'));\r\n                    }\r\n            }\r\n        ret.reference = Object.values(map).flat();\r\n        return ret;\r\n    }\r\n    private impl_get_suggestedEdgesM2(context: Context): this[\"suggestedEdges\"]{\r\n        let ret: this[\"suggestedEdges\"] = {extend: [], reference: [], packageDependencies: []};\r\n        if (!context.data.isMetamodel) { Log.ww(\"cannot call suggestedEdgesM2() on a model\"); return ret; }\r\n        let s: DState = store.getState();\r\n        let classes: LClass[] = this.get_classes(context, s);\r\n        let references: LReference[] = Debug.lightMode ? [] : classes.flatMap(c=>c.references);\r\n        ret.reference = references.map( (r) => {\r\n            let sn = r?.notEdge;\r\n            if (!sn || !sn.html) return undefined;\r\n            let end = r.type;\r\n            // if (end.id === r.id) return undefined;\r\n            let en = end?.notEdge;\r\n            if (!en || !en.html) return undefined;\r\n            //console.log('pre edgestarter', {r, end, sn, en});\r\n            return new EdgeStarter(r, end, sn, en, [], 0, 'association');\r\n        }).filter<EdgeStarter>(function(e):e is EdgeStarter{ return !!e});\r\n        // ret.extend = classes.flatMap( c => EdgeStarter.oneToMany(c, c.extends));\r\n\r\n        let alreadyAdded: Dictionary<Pointer, LClass> = {};\r\n        // if A extends B1, B2;    B1 extends C1, C2;    and node B1 is hidden. instead of edge from A to B, i display edge from A~C1, A~C2, A~B2\r\n        function SkipExtendNodeHidden(start: LClass): ({start: LClass, end: LClass, sn: LGraphElement, en: LGraphElement, oth:LGraphElement[]})[] {\r\n            return SkipExtendNodeHidden_recstep(start);\r\n        }\r\n        function SkipExtendNodeHidden_recstep(start: LClass, sn?: LGraphElement, end?: LClass[], startgraphid: Pointer|null = null): ({start: LClass, end: LClass, sn: LGraphElement, en: LGraphElement, oth:LGraphElement[]})[] {\r\n            let ret: {start: LClass, end: LClass, sn: LGraphElement, en: LGraphElement, oth:LGraphElement[]}[] = [] as any;\r\n            // ret.start = start;\r\n            let isRootcall = !startgraphid;\r\n            if (isRootcall) {\r\n                // end classes can get added twice if from a different starting subclass path:\r\n                // in classes.flatMap -> do not initialize the dict, it must be shared and initialized here locally\r\n                alreadyAdded = {[start.id]: start};\r\n                sn = start.nodes.find(node=>filternode(node, null)); // start.notEdge;\r\n                if (!sn || !sn.html) return [];\r\n                startgraphid = sn.graph?.id;\r\n                if (!startgraphid) return [];\r\n                if (!end) end = start.extends;\r\n            }\r\n            if (!end) return [];\r\n            for (let e of end) {\r\n                if (!e) continue;\r\n                let eid = e.id;\r\n                if (alreadyAdded[eid]) continue; // without this there might be duplicates if A extends B1, B2;  and both B1 & B2 extends C\r\n                alreadyAdded[eid] = e;\r\n                let nodes = e.nodes.filter(o=>filternode(o, startgraphid));// let en = e.notEdge; if (en && en.html) { ret.push({start, end:e, sn, en}); continue; }\r\n                if (nodes.length) {\r\n                    ret.push({start, sn:sn as LGraphElement, end:e, en:nodes[0], oth:nodes});\r\n                    continue;\r\n                }\r\n                let secondTierExtends = e.extends;\r\n                ret.push(...SkipExtendNodeHidden_recstep(start, sn, secondTierExtends, startgraphid));\r\n            }\r\n            return ret;\r\n        }\r\n        windoww.SkipExtendNodeHidden = SkipExtendNodeHidden;\r\n\r\n        function filternode(c: LGraphElement, startgraphid: Pointer | null): boolean {\r\n            if (!c || !c.rendered) return false;\r\n            let qualify = U.categorizeNode(c);\r\n            if (qualify.edge || qualify.edgepoint || qualify.puregraph) return false;\r\n            if (startgraphid && startgraphid !== c.root?.id) return false;\r\n            return true;\r\n        }\r\n        ret.extend = classes.flatMap( (c) => SkipExtendNodeHidden(c).map(es=>{\r\n            return new EdgeStarter(es.start, es.end, es.sn, es.en, es.oth, 0, 'extend');\r\n        }));\r\n\r\n        if (false) ret.extend = classes.flatMap(c => SkipExtendNodeHidden(c)).map( (es) => {\r\n            let otherEdgeEnds = es;/*.start.extendsChain.flatMap(c=>(c?.nodes||[])).filter(c=> {\r\n                if (!c || !c.rendered) return false;\r\n                let qualify = U.categorizeNode(c);\r\n                if (qualify.edge || qualify.edgepoint || qualify.puregraph) return false;\r\n                if (es.sn?.root?.id !== c.root?.id) return false;\r\n                return true;\r\n            }) as LGraphElement[];\r\n*/\r\n            return new EdgeStarter(es.start, es.end, es.sn, es.en, [], 0, 'extend');\r\n        });\r\n\r\n        let dependencies: {src:LModelElement, ends: LModelElement[]}[] =\r\n            Debug.lightMode ? [] : [\r\n                ...(classes.map(c=>{ return {src:c, ends:c.superclasses}})),\r\n                ...(references.map(r=> { return {src:r, ends:[r.type]}}))\r\n            ]\r\n        let pkgdependencies: {src: LPackage, sn: LGraphElement, ends: Dictionary<Pointer, {end:LPackage, en:LGraphElement}>}[] = []; // transform form in dictionary to prevent duplicates\r\n        //dependencies.map( d=> { let end = d.end.package; return {src:d.src.package, end, endid:end.id}})\r\n\r\n        for (let d of dependencies) {\r\n            let src: LPackage | null = d.src.package;\r\n            if (!src) continue;\r\n            let srcnode: LGraphElement | undefined = src.notEdge;\r\n            if (!srcnode || !srcnode.html) continue;\r\n            let ends: Dictionary<Pointer, {end:LPackage, en:LGraphElement}> = {};\r\n            for (let end of d.ends) {\r\n                let ep: LPackage|null = end.package;\r\n                if (!ep) continue;\r\n                let epnode: LGraphElement | undefined = ep.notEdge;\r\n                if (!epnode || !epnode.html) continue;\r\n                ends[ep.id] = {end:ep, en:epnode};\r\n            }\r\n            pkgdependencies.push( {src, sn:srcnode, ends});\r\n        }\r\n        // todo: check\r\n        ret.packageDependencies = pkgdependencies.flatMap(\r\n            (pd) => ( Object.values(pd.ends).map((end) => new EdgeStarter(pd.src, end.end, pd.sn, end.en, [], 0, 'pkg_dep')))\r\n        );\r\n        return ret;\r\n    }\r\n\r\n\r\n    protected get_models(context: Context): LModel[] { // todo: should this not be data.instances instead?\r\n        return LModel.fromPointer(context.data.models);\r\n    }\r\n    protected set_models(val: PackArr<this['models']>, context: Context): boolean {\r\n        const list = val.map((lItem) => { return Pointers.from(lItem) });\r\n        const oldList = context.data.models;\r\n        const diff = U.arrayDifference(oldList, list);\r\n        TRANSACTION(this.get_name(context)+'.models', ()=>{\r\n            SetFieldAction.new(context.data, 'models', list, '', true);\r\n            for (let id of diff.added) {\r\n                SetFieldAction.new(id, 'father', context.data.id, '', true);\r\n                SetFieldAction.new(id, 'parent', context.data.id, '+=', true);\r\n            }\r\n            for (let id of diff.removed as Pointer<DModelElement>[]) {\r\n                SetFieldAction.new(id, 'father', undefined, '', true);\r\n                const parent = DPointerTargetable.from(id).parent;\r\n                U.arrayRemoveAll(parent, context.data.id);\r\n                SetFieldAction.new(id, 'parent', parent, '', true);\r\n            }\r\n        })\r\n        return true;\r\n    }\r\n\r\n    public duplicate(deep: boolean = true): this { throw new Error(\"Model.duplicate(): use export/import ecore instead.\"); }\r\n\r\n    protected set_instanceof(val: Pack1<this[\"instanceof\"]>, c: Context): boolean {\r\n        let ptr = Pointers.from<DNamedElement>(val as any);// as (undefined | Pointer<DNamedElement>);\r\n        if (c.data.instanceof === ptr) return true;\r\n        TRANSACTION(this.get_name(c)+'.instanceof', ()=>{\r\n            SetFieldAction.new(c.data.id, \"instanceof\", ptr, undefined, true);\r\n            // update father's collections (pointedby's here are set automatically)\r\n            // todo: ptr && SetFieldAction.new(ptr, \"instances\", context.data.id, '+=', true);\r\n        }, this.get_instanceof(c)?.fullname, LPointerTargetable.wrap(ptr)?.fullname)\r\n        return true; }\r\n    protected get_instanceof(c: Context): this[\"instanceof\"] {\r\n        return c.data.instanceof ? LPointerTargetable.fromPointer(c.data.instanceof) : undefined;\r\n    }\r\n\r\n    protected set_name(val: this['name'], c: Context): boolean {\r\n        const models: LModel[] = LModel.fromPointer(store.getState()['models']);\r\n        if (models.filter((model) => { return model.name === val }).length > 0) {\r\n            U.alert('e', 'Cannot rename the selected model, this name is already taken.');\r\n        } else {\r\n            if (c.data.name === val) return true;\r\n            TRANSACTION(this.get_name(c)+'.name', ()=>{\r\n                SetFieldAction.new(c.data, 'name', val, '', false);\r\n            }, undefined, val)\r\n        }\r\n        return true;\r\n    }\r\n    protected get_children_idlist(context: Context): Pointer<DAnnotation | (DPackage|DObject), 1, 'N'> {\r\n        let children: Pointer<(DPackage|DObject), 0, 'N', (LPackage|LObject)>;\r\n        if(context.data.isMetamodel) children = context.data.packages;\r\n        else children = context.proxyObject.allSubObjects.map(o => o.id);\r\n        return [...super.get_children_idlist(context) as Pointer<DAnnotation | (DPackage|DObject), 1, 'N'>,\r\n            ...children];\r\n    }\r\n\r\n    protected get_isMetamodel(context: Context): this['isMetamodel'] {\r\n        return !!context.data.isMetamodel;\r\n    }\r\n    protected set_isMetamodel(val: this['isMetamodel'], c: Context): boolean {\r\n        val = !!val;\r\n        if (!!c.data.isMetamodel === val) return true;\r\n        TRANSACTION(this.get_name(c)+'.isMetamodel', ()=>{\r\n            SetFieldAction.new(c.data, 'isMetamodel', val, '', false);\r\n        }, c.data.isMetamodel, val)\r\n        return true;\r\n    }\r\n\r\n    protected get_crossObjects(context: Context): this[\"objects\"] { return this.get_objects(context, true); }\r\n    protected get_objects(context: Context, includeCrossReferences: boolean = false): this['objects'] {\r\n        let ret: LObject[] = context.data.objects.map((pointer) => LPointerTargetable.from(pointer));\r\n        if (includeCrossReferences) U.arrayMergeInPlace(ret, context.proxyObject.allDependencies.flatMap(dep=>dep.objects));\r\n        return ret;\r\n    }\r\n    protected get_crossPackages(context: Context): this[\"packages\"] { return this.get_packages(context, true); }\r\n\r\n    protected get_packages(context: Context, includeCrossReferences: boolean = false): this[\"packages\"] {\r\n        if (!context.data.isMetamodel) { return context.data.instanceof ? (this.get_instanceof(context) as LModel).packages : []; }\r\n        let ret: LPackage[] = context.data.packages.map((pointer) => LPointerTargetable.from(pointer));\r\n        if (includeCrossReferences) U.arrayMergeInPlace(ret, context.proxyObject.allDependencies.flatMap(dep=>dep.packages));\r\n        return ret;\r\n    }\r\n\r\n    protected set_packages(val: PackArr<this[\"packages\"]>, c: Context): boolean {\r\n        const list = val.map((lItem) => { return Pointers.from(lItem) });\r\n        const oldList = c.data.packages;\r\n        const diff = U.arrayDifference(oldList, list);\r\n        TRANSACTION(this.get_name(c)+'.packages', ()=>{\r\n            SetFieldAction.new(c.data, 'packages', list, \"\", true);\r\n            for (let id of diff.added) {\r\n                SetFieldAction.new(id, 'father', c.data.id, '', true);\r\n                SetFieldAction.new(id, 'parent', c.data.id, '+=', true);\r\n            }\r\n            for (let id of diff.removed as Pointer<DModelElement>[]) {\r\n                SetFieldAction.new(id, 'father', undefined, '', true);\r\n                const parent = DPointerTargetable.from(id).parent;\r\n                U.arrayRemoveAll(parent, c.data.id);\r\n                SetFieldAction.new(id, 'parent', parent, '', true);\r\n            }\r\n        })\r\n        return true;\r\n    }\r\n\r\n    protected get_crossRoots(context: Context): this[\"roots\"] { return this.get_roots(context, true); }\r\n    protected get_roots(context: Context, includeCross: boolean = false): this[\"roots\"] {\r\n        return this.get_objects(context, includeCross);//.filter( o => o.isRoot);\r\n    }\r\n\r\n    protected get_crossClasses(c: Context, s?: DState): this[\"classes\"] { return this.get_classes(c, s, true); }\r\n    protected get_classes(c: Context, s?: DState, includeCross: boolean = false): this[\"classes\"] {\r\n        let key = 'classes';\r\n        let crossKey = 'crossClasses';\r\n        let kind = DClass;\r\n        if (!c.data.isMetamodel) {\r\n            if (!c.data.instanceof) return [] as any;\r\n            let meta = this.get_instanceof(c) as GObject<LModel>;\r\n            if (includeCross && c.data.dependencies.length) return meta[crossKey];\r\n            return meta[key];\r\n        }\r\n        return this._getallSub(c, s, kind, includeCross);\r\n    }\r\n    protected get_crossReferences(c: Context, s?: DState): this[\"references\"] { return this.get_references(c, s, true); }\r\n    protected get_references(c: Context, s?: DState, includeCross: boolean = false): this[\"references\"] {\r\n        let key = 'references';\r\n        let crossKey = 'crossReferences';\r\n        let kind = DReference;\r\n        if (!c.data.isMetamodel) {\r\n            if (!c.data.instanceof) return [] as any;\r\n            let meta = this.get_instanceof(c) as GObject<LModel>;\r\n            if (includeCross && c.data.dependencies.length) return meta[crossKey];\r\n            return meta[key];\r\n        }\r\n        return this._getallSub(c, s, kind, includeCross);\r\n    }\r\n\r\n    protected get_crossEnums(context: Context): this[\"enums\"] { return this.get_enumerators(context, undefined, true); }\r\n    protected get_enums(context: Context): this[\"enums\"] {\r\n        if (!context.data.isMetamodel) { return context.data.instanceof ? (this.get_instanceof(context) as LModel).enumerators : [] as any; }\r\n        return this.get_enumerators(context, undefined, false);\r\n    }\r\n\r\n    protected get_crossEnumerators(context: Context, s?: DState): this[\"enums\"] { return this.get_enumerators(context, s, true); }\r\n    protected get_enumerators(c: Context, s?: DState, includeCross:boolean = false): this[\"enums\"] {\r\n        let key = 'enumerators';\r\n        let crossKey = 'crossEnumerators';\r\n        let kind = DEnumerator;\r\n        if (!c.data.isMetamodel) {\r\n            if (!c.data.instanceof) return [] as any;\r\n            let meta = this.get_instanceof(c) as GObject<LModel>;\r\n            if (includeCross && c.data.dependencies.length) return meta[crossKey];\r\n            return meta[key];\r\n        }\r\n        return this._getallSub(c, s, kind, includeCross);\r\n    }\r\n    protected get_allCrossSubPackages(c: Context, s?: DState): this[\"allCrossSubPackages\"] { return this.get_allSubPackages(c, s, true); }\r\n\r\n    protected get_allSubPackages(c: Context, s?: DState, includeCross: boolean = false): this[\"allSubPackages\"] {\r\n        let key = 'allSubPackages';\r\n        let crossKey = 'allCrossSubPackages';\r\n        let kind = DPackage;\r\n        if (!c.data.isMetamodel) {\r\n            if (!c.data.instanceof) return [] as any;\r\n            let meta = this.get_instanceof(c) as GObject<LModel>;\r\n            if (includeCross && c.data.dependencies.length) return meta[crossKey];\r\n            return meta[key];\r\n        }\r\n        return this._getallSub(c, s, kind, includeCross);\r\n        /*state = state || store.getState();\r\n        let tocheck: Pointer<DPackage>[] = context.data.packages || [];\r\n        let checked: Dictionary<Pointer, DPackage> = {};\r\n        while (tocheck.length) {\r\n            let newtocheck: Pointer<DPackage>[] = [];\r\n            for (let ptr of tocheck) {\r\n                if (checked[ptr]) throw new Error(\"loop in packages containing themselves\");\r\n                let dpackage: DPackage = DPointerTargetable.from(ptr, state);\r\n                checked[ptr] = dpackage;\r\n                U.arrayMergeInPlace(newtocheck, dpackage?.subpackages);\r\n            }\r\n            tocheck = newtocheck;\r\n        }\r\n        let darr: DPackage[] = Object.values(checked);\r\n        let larr: LPackage[] & Dictionary<DocString<\"$name\">, LPackage> = LPointerTargetable.fromArr(darr, state);\r\n        U.toNamedArray(larr, darr);\r\n        return larr;*/\r\n    }\r\n\r\n    protected get_allCrossSubValues(c: Context, s?: DState): this[\"allCrossSubValues\"] { return this.get_allSubValues(c, s, true); }\r\n    protected get_allSubValues(c: Context, s?: DState, includeCross?:boolean): this[\"allSubValues\"] { return this._getallSub(c, s, DValue, includeCross); }\r\n    // allCrossSubAnnotations!: LAnnotation[];     allCrossSubPackages!: LPackage[];     allCrossObjects!: LObject[];     allCrossSubValues!: LValue[];\r\n    protected get_allCrossSubObjects(c: Context, s?: DState): this[\"allCrossSubObjects\"] { return this.get_allSubObjects(c, s, true); }\r\n\r\n    protected get_allSubObjects(c: Context, s?: DState, includeCross?:boolean): this[\"allSubObjects\"] {\r\n        return this._getallSub(c, s, DObject, includeCross);\r\n    }\r\n    protected _getallSub(context: Context, state: DState|undefined, kind: Any<typeof DModelElement>, includeCross?:boolean): any[]&Dictionary<any, any> {\r\n        state = state || store.getState();\r\n        let darr = Selectors.getAll(kind, undefined, state, true, false) as DModelElement[];\r\n\r\n        //console.log('get_allSubPackages', {includeCross, kind});\r\n        // console.log(\"gao\", {darr:[...darr]});\r\n        let larr = [];\r\n        // let validModels = includeCross ? [c.data.id, ...c.data.dependencies] : [c.data.id];\r\n        let allDeps = includeCross ? this.get_allDependencies(context) : [];\r\n        let allDepPtrs = allDeps.map(m=>m.id);\r\n        for (let i = 0; i < darr.length; i++){\r\n            let l = LPointerTargetable.fromD(darr[i]);\r\n            if (!l) continue;\r\n            let lmodel = l.model;\r\n            // Log.exDev(!lmodel, \"missing model in model element\", {l, context}); normal for primitive types in \"m3\"\r\n            if (!lmodel) continue;\r\n            let lmodelid = l.model.id;\r\n            if (lmodelid === context.data.id || includeCross && allDepPtrs.includes(lmodelid)) {\r\n                larr.push(l);\r\n            }\r\n            darr[i] = undefined as any;\r\n            continue;\r\n        }\r\n        // console.log(\"gao\", {darr:[...darr], larr});\r\n        darr = darr.filter(d=>!!d);\r\n        // console.log(\"gao\", {darr, larr});\r\n        U.toNamedArray(larr, darr);\r\n        return larr;\r\n    }\r\n\r\n    public getClassByNameSpace(namespacedclass: string): LClass | undefined { return this.cannotCall(\"getClassByNameSpace\"); }\r\n    protected get_getClassByNameSpace(context: Context): this[\"getClassByNameSpace\"] {\r\n        if (!context.data.isMetamodel) { return context.data.instanceof ? (this.get_instanceof(context) as LModel).getClassByNameSpace : undefined as any; }\r\n        return (namespacedclass: string): LClass | undefined => {\r\n            let pos = namespacedclass.lastIndexOf(\":\");\r\n            let pkguri = namespacedclass.substring(0, pos);\r\n            let classname = namespacedclass.substring(pos+1);\r\n            let pkg: LPackage | undefined = this.get_getPackageByUri(context)(pkguri);\r\n            if (!pkg) return undefined;\r\n            // return pkg[\"@\" + classname];\r\n            return pkg.classes.filter((c) => c.name === classname)[0];\r\n        }; }\r\n    public getPackageByUri(uri: string): LPackage | undefined { return this.cannotCall(\"getPackageByUri\"); }\r\n    protected get_getPackageByUri(context: Context): this[\"getPackageByUri\"] {\r\n        return (uri: string)=>context.proxyObject.allSubPackages.filter((p)=>p.uri === uri)[0]; }\r\n\r\n\r\n    /* See src/api/persistance/save.ts */\r\n\r\n    protected get_attributes(context: Context): this['attributes'] {\r\n        if (!context.data.isMetamodel) { return context.data.instanceof ? (this.get_instanceof(context) as LModel).attributes : []; }\r\n        return context.proxyObject.classes.flatMap(c => c.attributes);\r\n    }\r\n\r\n    protected get_literals(context: Context): this['literals'] {\r\n        if (!context.data.isMetamodel) { return context.data.instanceof ? (this.get_instanceof(context) as LModel).literals : []; }\r\n        return context.proxyObject.enumerators.flatMap(e => e.literals);\r\n    }\r\n\r\n    protected get_values(context: Context): this['values'] {\r\n        return context.proxyObject.objects.flatMap(o => o.features);\r\n    }\r\n}\r\nRuntimeAccessibleClass.set_extend(DNamedElement, DModel);\r\nRuntimeAccessibleClass.set_extend(LNamedElement, LModel);\r\n\r\n\r\n@RuntimeAccessible('DFactory_useless_')\r\nexport abstract class DFactory_useless_ extends DPointerTargetable { // DModelElement\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // static singleton: LFactory_useless_;\r\n    // static logic: typeof LFactory_useless_;\r\n    // static structure: typeof DFactory_useless_;\r\n\r\n    // inherit redefine\r\n    id!: Pointer<DFactory_useless_, 1, 1, LFactory_useless_>;\r\n    parent: Pointer<DModelElement, 0, 'N', LModelElement> = [];\r\n    father!: Pointer<DModelElement, 1, 1, LModelElement>;\r\n    annotations: Pointer<DAnnotation, 0, 'N', LAnnotation> = [];\r\n    // personal\r\n    ePackage: Pointer<DPackage, 1, 1, LPackage> = '';\r\n    abstract create(DClass: DClass): DObject;\r\n    abstract createFromString(eDataType: DDataType, literalValue: string): EJavaObject;\r\n    abstract convertFromString(eDataType: DDataType, instanceValue: EJavaObject): string;\r\n    // ********************** my additions inherited ********************* //\r\n    // ********************** my additions personal ********************** //\r\n}\r\n@RuntimeAccessible('LFactory_useless_')\r\nexport abstract class LFactory_useless_<Context extends LogicContext<DFactory_useless_> = any, C extends Context = Context>  extends LModelElement {\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    public __raw!: DFactory_useless_;\r\n    id!: Pointer<DFactory_useless_, 1, 1, LFactory_useless_>;\r\n    // static singleton: LFactory_useless_;\r\n    // static logic: typeof LFactory_useless_;\r\n    // static structure: typeof DFactory_useless_;\r\n\r\n    // inherit redefine\r\n    parent!: LModelElement[];\r\n    father!: LModelElement;\r\n    annotations!: LAnnotation[];\r\n    // personal\r\n    ePackage!: LPackage;\r\n    abstract create(DClass: DClass): DObject;\r\n    abstract createFromString(eDataType: DDataType, literalValue: string): EJavaObject;\r\n    abstract convertFromString(eDataType: DDataType, instanceValue: EJavaObject): string;\r\n    // ********************** my additions inherited ********************* //\r\n    // ********************** my additions personal ********************** //\r\n}\r\n\r\n// DModelElement.subclasses.push('DFactory_useless_'); // because it's abstract and cannot be used as a value, it's pure type definition\r\n// DModelElement.subclasses.push('LFactory_useless_'); // because it's abstract and cannot be used as a value, it's pure type definition\r\n// RuntimeAccessibleClass.set_extend(DModelElement, DFactory_useless_);\r\n// RuntimeAccessibleClass.set_extend(LModelElement, LFactory_useless_);\r\n\r\n@RuntimeAccessible('EJavaObject')\r\nexport class EJavaObject{\r\n\r\n}// ??? EDataType instance?\r\n\r\n\r\n@RuntimeAccessible('DMap')\r\nexport class DMap extends RuntimeAccessibleClass { // DPointerTargetable\r\n    // static logic: typeof LModelElement;\r\n    // static structure: typeof DModelElement;\r\n    // static singleton: LModelElement;\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    __isDMap!: true;\r\n    constructor() {\r\n        super();\r\n    }\r\n\r\n    // id!: Pointer<DModelElement, 1, 1, LModelElement>;\r\n}\r\n\r\n@RuntimeAccessible('LMap')\r\nexport class LMap<Context extends LogicContext<DMap> = any, C extends Context = Context>  extends LPointerTargetable {\r\n    // static logic: typeof LModelElement;\r\n    // static structure: typeof DModelElement;\r\n    // static singleton: LModelElement;\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    __isLMap!: true;\r\n    // id!: Pointer<DModelElement, 1, 1, LModelElement>;\r\n}\r\nRuntimeAccessibleClass.set_extend(DPointerTargetable, DMap as any);\r\nRuntimeAccessibleClass.set_extend(LPointerTargetable, LMap);\r\n\r\n\r\n@Leaf\r\n@RuntimeAccessible('DObject')\r\nexport class DObject extends DPointerTargetable { // extends DNamedElement, m1 class instance\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n\r\n    // inherit redefine\r\n    annotations!: never[];\r\n    id!: Pointer<DObject, 1, 1, LObject>;\r\n    parent: Pointer<DModel | DValue, 0, 'N', LModel | LValue> = [];\r\n    father!: Pointer<DModel, 1, 1, LModel> |  Pointer<DValue, 1, 1, LValue>;\r\n    // annotations: Pointer<DAnnotation, 0, 'N', LAnnotation> = [];\r\n    name!: string;\r\n\r\n    // personal\r\n    instanceof!: Pointer<DClass>; // actually nullable now, but takes too much type refactoring. be careful to check if it's present\r\n    features: Pointer<DValue>[] = [];\r\n\r\n\r\n    public static new(instanceoff?: DObject[\"instanceof\"], father?: DObject[\"father\"], fatherType?: typeof DModel | typeof DValue, name?: DNamedElement[\"name\"], persist: boolean = true): DObject {\r\n        // if (!name) name = this.defaultname(((meta: LNamedElement) => meta.name + \" \"), father);\r\n        if (!name) name = this.defaultname(((meta: LNamedElement) => (meta?.name || \"obj\") + \"_\"), father, instanceoff);\r\n        let ret = new Constructors(new DObject('dwc'), father, persist, fatherType).DPointerTargetable().DModelElement()\r\n            .DNamedElement(name).DObject(instanceoff).end();\r\n        return ret;\r\n    }\r\n\r\n    public static new3(ptrs:Partial<ObjectPointers>, then:(d:DObject, c: Constructors)=>void, fatherType?: typeof DModel | typeof DValue, persist: boolean = true): DObject{\r\n        if (!ptrs.name) ptrs.name = this.defaultname(((meta: LNamedElement) => (meta?.name || \"obj\") + \"_\"), ptrs.father, ptrs.instanceof);\r\n        return new Constructors(new DObject('dwc'), ptrs.father, persist, fatherType, ptrs.id)\r\n            .DPointerTargetable().DModelElement()\r\n            .DNamedElement(ptrs.name).DObject(ptrs.instanceof).end(then);\r\n    }\r\n\r\n\r\n}\r\n\r\n@RuntimeAccessible('LObject')\r\nexport class LObject<Context extends LogicContext<DObject> = any, C extends Context = Context, D extends DObject = DObject> extends LNamedElement { // extends DNamedElement, m1 class instance\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    public __raw!: DObject;\r\n    id!: Pointer<DObject, 1, 1, LObject>;\r\n\r\n    // inherit redefine\r\n    annotations!: never[];\r\n    children!: LValue[];\r\n    allChildren!: LValue[]; // including hidden values\r\n    truechildren!: LValue[]; // real shape without \"mirage\" values\r\n    parent!: (LModel | LValue)[];\r\n    father!: LModel | LValue;\r\n    model!: LModel;\r\n    // annotations!: LAnnotation[];\r\n    // from LClass\r\n\r\n    name!: string;\r\n    ecoreRootName!: string;\r\n    namespace!: string;\r\n    defaultValue!: DClass[\"defaultValue\"];\r\n    // abstract!: boolean;\r\n    // interface!: boolean;\r\n    // references!: LReference[];\r\n    // attributes!: LAttribute[];\r\n    // operations!: LOperation[];\r\n\r\n    // personal\r\n    deepSubObjects!: LObject[]; // todo: itera features (lvalue[]) deep e vitando di inserire doppioni (salva una mappatura di di già aggiunti e skip se ricompaiono)\r\n    subObjects!: LObject[];\r\n    referenceFeatures!: LValue[]; // subset of features that are references.\r\n    attributeFeatures!: LValue[]; // subset of features that are attributes.\r\n    shapelessFeatures!: LValue[]; // subset of features that are not mapped and can have any kind of values.\r\n    // + tutte le funzioni di comodità navigazionale del modello, trattarlo un pò come se fosse un modello (e quasi può esserlo)\r\n    instanceof!: LClass;\r\n    features!: LValue[];\r\n    isRoot!: boolean;\r\n    readonly partial!: boolean;\r\n\r\n    protected get_name(context: Context): this['name'] {\r\n        return (context.proxyObject as GObject)['$name']?.value || context.data.name || context.proxyObject.instanceof.name;\r\n    }\r\n\r\n    composed!:boolean;\r\n    aggregated!:boolean;\r\n    contained!:boolean;\r\n    referencedBy!: LValue[];\r\n    protected get_composed(c: Context): this['composed'] { return (LClass.singleton as LClass).get_composed(c as any); }\r\n    protected get_aggregated(c: Context): this['aggregated'] { return (LClass.singleton as LClass).get_aggregated(c as any); }\r\n    protected get_contained(c: Context): this['contained'] { return (LClass.singleton as LClass).get_contained(c as any); }\r\n    /*\r\n    protected get_referencedBy(c: Context): this[\"referencedBy\"] { return (LClass.singleton as LClass).get_referencedBy(c as any) as any; }\r\n    */\r\n    get_referencedBy(context: Context): LObject[\"referencedBy\"] {\r\n        let state: DState = store.getState();\r\n        let targeting: LValue[] = LPointerTargetable.fromArr(context.data.pointedBy.map( p => {\r\n            let s: GObject = state;\r\n            for (let key of PointedBy.getPathArr(p)) {\r\n                s = s[key];\r\n                if (!s) return null;\r\n                if (s.className === DValue.cname) return s.id;\r\n            }\r\n        }));\r\n        return targeting;\r\n    }\r\n\r\n    protected get_truechildren(context: Context): this[\"children\"] {\r\n        let childs: LValue[] = super.get_children(context);\r\n        if (!context.data.instanceof) return childs;\r\n        return childs.filter( (c) => !c.isMirage);\r\n    }\r\n\r\n    protected get_allChildren(context: Context): this[\"children\"] { return super.get_children(context); }\r\n\r\n    protected get_children(context: Context, sort: boolean = true): this[\"children\"] {\r\n        const pointers = [...(new Set(super.get_children(context).map(c => c.id)))];\r\n        let childs: LValue[] = LValue.fromArr(pointers);\r\n        let meta: LClass = context.proxyObject.instanceof;\r\n        // if (!sort && (!meta || meta.partial)) return childs;\r\n        let conformchildren: undefined | Pointer[] = meta && !meta.partial ? meta.allChildren.map(c => c.id) : undefined;\r\n        if (!sort) {\r\n            // console.log(\"return get features:\", {context, meta, childs, conformchildren, ret:childs.filter((c) => (c.instanceof?.id) && conformchildren!.includes(c.instanceof?.id))});\r\n            if (!conformchildren) return childs;\r\n            return childs.filter((c) => (c.instanceof?.id) && conformchildren!.includes(c.instanceof?.id));\r\n        }\r\n\r\n        let bymetaparent: Dictionary<DocString<\"metaparent pointer\">, LValue[]> = {};\r\n        for (let v of childs) {\r\n            let vmeta = v.instanceof;\r\n            // console.log(\"get features filtering:\", {context, meta, vmeta, v, childs, conformchildren});\r\n\r\n            if (conformchildren && (!vmeta || !conformchildren.includes(vmeta.id))) continue;\r\n            let vmetaid: string = vmeta?.id as string; // undef as key is fine even if compiler complains, so i cast it\r\n            if (!bymetaparent[vmetaid]) bymetaparent[vmetaid] = [v]; else bymetaparent[vmetaid as any].push(v);\r\n        }\r\n        // console.log(\"return get features:\", {context, meta, childs, conformchildren, ret:Object.values(bymetaparent).flat()});\r\n        return Object.values(bymetaparent).flat();\r\n    }\r\n\r\n    typeStr!:string; // derivate attribute, abstract\r\n    typeString!:string; // derivate attribute, abstract\r\n    __info_of__typeStr: Info = {type: ShortAttribETypes.EString, txt: <div>Alias of<i>this.typeString</i></div>}\r\n    __info_of__typeString: Info = {type: ShortAttribETypes.EString, txt: <div>Stringified version of <i>this.type</i></div>}\r\n    protected get_typeString(c: Context): string { return this.get_typeStr(c); }\r\n    protected get_typeStr(c: Context): string {\r\n        let thiss: GObject<this> = this as any;\r\n        if (!thiss.get_instanceof) return 'shapeless';\r\n        let meta: any = thiss.get_instanceof(c);\r\n        return meta?.typeToShortString?.() || \"shapeless\"; }\r\n\r\n    // protected get_fromlclass<T extends keyof (LClass)>(meta: LClass, key: T): LClass[T] { return meta[key]; }\r\n    protected get_model(context: Context): LModelElement[\"model\"] {\r\n        let l: LValue | LObject | LModel = context.proxyObject;\r\n        while (l && l.className !== DModel.cname) l = l.father;\r\n        return l as LModel; }\r\n    // protected set_name(val: string, context: Context): boolean { return this.cannotSet(\"name\"); }\r\n    protected set_namespace(val: string, context: Context): boolean { return this.cannotSet(\"namespace\"); }\r\n    // protected get_namespace(context: Context): LClass[\"namespace\"] { return context.proxyObject.instanceof.namespace; }\r\n    protected set_fullname(val: string, context: Context): boolean { return this.cannotSet(\"fullname\"); }\r\n    // protected get_fullname(context: Context): LClass[\"fullname\"] { return context.proxyObject.instanceof.fullname; }\r\n    protected set_ecoreRootName(val: string, context: Context): boolean { return this.cannotSet(\"ecoreRootName\"); }\r\n    protected get_ecoreRootName(context: Context): LObject[\"ecoreRootName\"] {\r\n        let instanceoff: LClass = context.proxyObject.instanceof;\r\n        if (!instanceoff) return \"schemaless:Object\";\r\n        return this.get_uri(context) + \":\" + instanceoff.name; // optimize later in instanceoff.namespace + \":\" + instanceoff.name; and implement namespace all around\r\n    }\r\n    protected set_partialdefaultname(val: DClass[\"partialdefaultname\"], context: Context): boolean { return this.cannotSet(\"DObject.partialdefaultname()\"); }\r\n    protected get_partialdefaultname(context: Context): DClass[\"partialdefaultname\"] { return context.data.instanceof ? context.proxyObject.instanceof.partialdefaultname : \"val_\"; }\r\n    protected set_partial(val: DClass[\"partial\"], context: Context): boolean { return this.cannotSet(\"DObject.set_partial()\"); }\r\n    protected get_partial(context: Context): DClass[\"partial\"] { return context.data.instanceof ? context.proxyObject.instanceof?.partial : true; }\r\n\r\n    /*    protected set_abstract(val: string, context: Context): boolean { return this.cannotSet(\"abstract\"); }\r\n        protected get_abstract(context: Context): LClass[\"abstract\"] { return context.proxyObject.instanceof.abstract; }\r\n        protected set_interface(val: string, context: Context): boolean { return this.cannotSet(\"interface\"); }\r\n        protected get_interface(context: Context): LClass[\"interface\"] { return context.proxyObject.instanceof.interface; }*/\r\n    protected set_defaultValue(val: string, context: Context): boolean { return this.cannotSet(\"defaultValue\"); }\r\n    protected get_defaultValue(context: Context): LClass[\"defaultValue\"] { return context.proxyObject.instanceof.defaultValue; }\r\n    protected set_referencedBy(val: string, context: Context): boolean { return this.wrongAccessMessage(\"referencedBy cannot be set directly. It should be updated automatically as side effect\"); }\r\n\r\n    protected get_subObjects(context: Context): this[\"subObjects\"] {\r\n        let ref_features: LValue[] = this.get_referenceFeatures(context, false).filter( (f) => (f.instanceof as LReference)!.containment );\r\n        let shapeless_features: LValue[] = this.get_shapelessFeatures(context);\r\n        let vals: LObject[] = [\r\n            ...ref_features.flatMap((f) => (f.values as LObject[])).filter((val)=>!!val),\r\n            ...shapeless_features.flatMap((f) => (f.values as any))\r\n                .filter((val)=>(!!val && val.className === DObject.cname)) as LObject[]\r\n        ];\r\n        return vals;\r\n    }\r\n\r\n    protected get_deepSubObjects(context: Context): this[\"deepSubObjects\"] {\r\n        let alreadyparsed: Dictionary<Pointer, LObject> = {};\r\n        let arr: LObject[] = this.get_subObjects(context);\r\n        while(arr.length) {\r\n            let next: LObject[] = [];\r\n            for (let obj of arr) {\r\n                if (alreadyparsed[obj.id]) continue;\r\n                alreadyparsed[obj.id] = obj;\r\n                next.push(...obj.subObjects);\r\n            }\r\n            arr = next;\r\n        }\r\n        return Object.values(alreadyparsed) || [];\r\n    }\r\n\r\n    protected get_referenceFeatures(context: Context, includeshapeless: boolean = false): this[\"referenceFeatures\"] {\r\n        return context.proxyObject.features.filter((f) => (!f.instanceof ? includeshapeless : f.instanceof.className === DReference.cname));\r\n    }\r\n    protected get_attributeFeatures(context: Context, includeshapeless: boolean = false): this[\"attributeFeatures\"] {\r\n        return context.proxyObject.features.filter((f) => (!f.instanceof ? includeshapeless : f.instanceof.className === DAttribute.cname));\r\n    }\r\n\r\n    protected get_shapelessFeatures(context: Context): this[\"shapelessFeatures\"] {\r\n        return context.proxyObject.features.filter((f) => (!f.instanceof));\r\n    }\r\n\r\n    protected get_isRoot(context: Context): LObject[\"isRoot\"] { return context.proxyObject.father.className === DModel.cname; }\r\n    protected set_isRoot(val: never, context: Context): boolean { return this.wrongAccessMessage(\"isRoot cannot be set directly, change father element instead.\"); }\r\n\r\n    public feature(name: string): (PrimitiveType|LObject)|(PrimitiveType|LObject)[] { this.cannotCall('feature'); return null; }\r\n    private get_feature(context: Context): (name: string) => LValue[\"value\"] | LValue[\"values\"] {\r\n        return (name: string) => {\r\n            const lObject = context.proxyObject;\r\n            const features = lObject.features.filter((value) => {\r\n                return value.instanceof?.name === name\r\n            });\r\n            if(features.length > 0) {\r\n                const matchedFeature = features[0];\r\n                switch(matchedFeature.values.length) {\r\n                    case 0: return '';\r\n                    case 1: return matchedFeature.value;\r\n                    default: return matchedFeature.values;\r\n                }\r\n            } return '';\r\n        }\r\n    }\r\n\r\n\r\n    protected generateEcoreJson_impl(context: Context, loopDetectionObj: Dictionary<Pointer, DModelElement> = {}): Json {\r\n        loopDetectionObj[context.data.id] = context.data;\r\n        let asEcoreRoot = (context.proxyObject.isRoot);\r\n        // todo: actually use this loopdetectionobj\r\n        const json: GObject = {};\r\n        if (asEcoreRoot) {\r\n            console.log(\"generate object ecore\", {context, asEcoreRoot, json});\r\n            const lc: LClass = context.proxyObject.instanceof;\r\n            json[ECorePackage.xmiversion] = '2.0';\r\n            json[ECorePackage.xmlnsxmi] = 'http://www.omg.org/XMI';\r\n            // json[ECorePackage.xmlnsxsi] = 'http://www.w3.org/2001/XMLSchema-instance';\r\n            json[\"xmlns:\" + ( lc ? (lc.father.uri + \".\" +lc.father.name) : \"shapeless.model.uri\")] = 'http://www.eclipse.org/emf/2002/Ecore';\r\n        }\r\n\r\n        let features = context.proxyObject.features || [];\r\n        console.log(\"features\", {features});\r\n        for (let f of features) {\r\n            if (!f) continue;\r\n            let meta = f.instanceof;\r\n            if (meta?.volatile) { continue; }\r\n            (!json[f.name]) && (json[f.name] = f.generateEcoreJson(loopDetectionObj));\r\n        }\r\n        return json; }\r\n\r\n    public addValue(name?: DValue[\"name\"], instanceoff?: DValue[\"instanceof\"], value?: DValue[\"values\"], isMirage?: boolean): LValue { return this.cannotCall(\"addValue\"); }\r\n    protected get_addValue(context: Context): this[\"addValue\"] {\r\n        return (name?: DValue[\"name\"], instanceoff?: DValue[\"instanceof\"], value?: DValue[\"values\"], isMirage?: boolean) => {\r\n            return LPointerTargetable.fromD(DValue.new(name, instanceoff, value, context.data.id, true, isMirage));\r\n        }\r\n    }\r\n\r\n    protected get_namespace(context: Context): string {\r\n        return context.data.instanceof ? context.proxyObject.instanceof.father.prefix : \"schemaless\"; }\r\n    protected get_uri(context: Context): string {\r\n        if (!context.data.instanceof) return \"schemaless\";\r\n        let pkg = context.proxyObject.instanceof.father;\r\n        return pkg.uri;// + \".\" + pkg.name;\r\n    }\r\n    // protected get_namespace(context: Context): string { if (!context.data.instanceof) return \"schemaless\"; return context.proxyObject.instanceof.namespace; }\r\n\r\n    protected get_children_idlist(context: Context): Pointer<DAnnotation | DValue, 1, 'N'> {\r\n        return [...super.get_children_idlist(context) as Pointer<DAnnotation | DValue, 1, 'N'>,\r\n            ...context.data.features];\r\n    }\r\n\r\n    protected get_instanceof(context: Context): this[\"instanceof\"] {\r\n        const pointer = context.data.instanceof;\r\n        return pointer && LPointerTargetable.from(pointer)\r\n    }\r\n    protected set_instanceof(val: Pack1<this[\"instanceof\"]>, c: Context): boolean {\r\n        const metaptr: D[\"instanceof\"] = Pointers.from(val);\r\n        if (metaptr === c.data.instanceof) return true;\r\n        TRANSACTION(this.get_name(c)+'.instanceof', ()=>{\r\n            this._removeConformity(c);\r\n            SetFieldAction.new(c.data.id, \"instanceof\", metaptr, undefined, true);\r\n            // update father's collections (pointedby's here are set automatically)\r\n            metaptr && SetFieldAction.new(metaptr as Pointer<DClass>, \"instances\", c.data.id, '+=', true);\r\n            if (metaptr) this._forceConformity(c, metaptr);\r\n        }, this.get_instanceof(c)?.fullname, LPointerTargetable.wrap(metaptr)?.fullname)\r\n        return true;\r\n    }\r\n\r\n    private forceConformity(context: Context, meta: D[\"instanceof\"]): void {\r\n        let oldinstanceof = context.data.instanceof;\r\n        // context.data.instanceof = meta;\r\n        let ret = this._forceConformity(context, meta);\r\n        // context.data.instanceof = oldinstanceof;\r\n        return ret;\r\n    }\r\n    private _forceConformity(context: Context, meta: D[\"instanceof\"]): void {\r\n        let lmeta = meta && LPointerTargetable.wrap(meta) as this[\"instanceof\"];\r\n        if (!lmeta) return;\r\n        let attrs = lmeta.allAttributes;\r\n        let refs = lmeta.allReferences;\r\n        let values = context.proxyObject.allChildren;\r\n        let idmap: Dictionary<string, LAttribute | LReference> = {};\r\n        for (let a of attrs) { idmap[a.id] = a; }\r\n        for (let a of refs) { idmap[a.id] = a; }\r\n        console.log({idmap, values, data: context.data, l:context.proxyObject});\r\n        // damiano: todo quando viene cancellato una feature il puntatore in features e values rimane. use pointedby's\r\n        // then remove attributes and references that are already instantiated in the object\r\n        for (let v of values) { if(v && v.__raw.instanceof) delete idmap[v.__raw.instanceof]; }\r\n        console.log(\"forceconformity\", {attrs, refs, valuesPre: values.map(v => v && v.__raw.instanceof), toadd:idmap});\r\n        for (let id in idmap) {\r\n            // let l = idmap[id];\r\n            context.proxyObject.addValue(undefined, id, [],true);\r\n        }\r\n    }\r\n    private _removeConformity(context: Context): void {\r\n        let childs = context.proxyObject.features;\r\n        for (let child of childs) if (child.isMirage) child.delete();\r\n    }\r\n\r\n\r\n    protected get_delete(context: Context): () => void {\r\n        return () => {\r\n            let c: LClass = this.get_instanceof(context);\r\n            if(c && c.isSingleton) {\r\n                Log.ww('Object is a singleton and cannot be removed, remove his singleton flag in m2 first.', context.data);\r\n                return;\r\n            }\r\n            super.get_delete(context)();\r\n        }\r\n    }\r\n    protected get_features(context: Context): this['features'] {\r\n        return this.get_children(context);\r\n        // return context.data.features.map((feature) => { return LPointerTargetable.from(feature) });\r\n    }\r\n\r\n    public ecorePointer(): string { return this.cannotCall(\"ecorePointer\"); }\r\n    protected get_ecorePointer(context: Context): () => string {\r\n        let lastvisited: Pointer<DObject, 1, 1, LObject> = context.data.id;\r\n        return () => \"@//\" + this.get_fatherList(context).map( (f: LModelElement | LObject | LValue) => {\r\n            if (f.className === DObject.cname) { lastvisited = (f as LObject).id; return ''; }\r\n            if (f.className === DModel.cname) { return ''; }\r\n            console.log(\"get_ecorepointer\", f, f.__raw, lastvisited);\r\n            return (f as LValue).name + \".\" + ((f as LValue).__raw.values.indexOf(lastvisited));\r\n        }).filter(v=>!!v).join(\"@/\");\r\n    }\r\n\r\n}\r\nRuntimeAccessibleClass.set_extend(DNamedElement, DObject);\r\nRuntimeAccessibleClass.set_extend(LNamedElement, LObject);\r\n\r\n@Leaf\r\n@RuntimeAccessible('DValue')\r\nexport class DValue extends DModelElement { // extends DModelElement, m1 value (attribute | reference)\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // static singleton: LValue;\r\n    // static logic: typeof LModelElement;\r\n    // static structure: typeof DValue;\r\n\r\n    // inherit redefine\r\n    id!: Pointer<DValue, 1, 1, LValue>;\r\n    parent: Pointer<DObject, 0, 'N', LObject> = [];\r\n    father!: Pointer<DObject, 1, 1, LObject>;\r\n    annotations: Pointer<DAnnotation, 0, 'N', LAnnotation> = [];\r\n    //name!: string; // nome opzionale solo per modelli schema-less//, ma se manca restsituisce 'DValue'\r\n\r\n    // personal\r\n    // value: PrimitiveType | Pointer<DObject, 1, 1, LObject>; // vv4\r\n    // values: PrimitiveType[] | Pointer<DObject, 1, 'N', LObject> | Pointer<DEnumLiteral, 1, 'N', LEnumLiteral> = []; // vv4\r\n    values: PrimitiveType[] | Pointer<DObject|DEnumLiteral, 1, 'N', LObject|LEnumLiteral> = [];\r\n    instanceof!: Pointer<DAttribute, 1, 1, LAttribute > | Pointer<DReference, 1, 1, LReference> | undefined; // todo: maybe min lowerbound 0 if you want to allow free shape objects chiedere prof\r\n    edges!: Pointer<DEdge, 0, 'N', LEdge>;\r\n    // conformsTo!: Pointer<DStructuralFeature, 0, 'N', LStructuralFeature>; // low priority to do: attributo fittizio controlla a quali elementi m2 è conforme quando viene richiesto\r\n    isMirage!: boolean;\r\n    allowCrossReference!: boolean;\r\n    // IoT Section\r\n    topic: string = '';\r\n\r\n    public static new(name?: DNamedElement[\"name\"], instanceoff?: DValue[\"instanceof\"], val?: DValue[\"values\"],\r\n                      father?: DValue[\"father\"] | DObject, persist: boolean = true, isMirage: boolean = false): DValue {\r\n        if (!name) name = this.defaultname(\"property_\", father);\r\n        return new Constructors(new DValue('dwc'), (typeof father === \"string\" ? father : (father as DObject)?.id), persist, undefined)\r\n            .DPointerTargetable().DModelElement()\r\n            .DNamedElement(name)\r\n            .DValue(instanceoff, val, isMirage).end();\r\n    }\r\n\r\n    public static new3(a:Partial<ValuePointers>, then?:((d:DValue, c: Constructors)=>void), persist: boolean = true): DValue{\r\n        if (!a.name) a.name = this.defaultname(\"property_\", a.father);\r\n        return new Constructors(new DValue('dwc'), a.father, persist, undefined, a.id)\r\n            .DPointerTargetable().DModelElement()\r\n            .DNamedElement(a.name)\r\n            .DValue(a.instanceof, a.values)\r\n            .end(then);\r\n    }\r\n}\r\n@RuntimeAccessible('LValue')\r\nexport class LValue<Context extends LogicContext<DValue> = any, C extends Context = Context, D extends DValue = DValue> extends LModelElement { // extends DModelElement, m1 value (attribute | reference)\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    public __raw!: DValue;\r\n    id!: Pointer<DValue, 1, 1, LValue>;\r\n\r\n    // inherit redefine\r\n    parent!: (LObject | LModel)[];\r\n    father!: LObject | LModel;\r\n    model!: LModel;\r\n    // from namedelement\r\n    name!: string;\r\n    namespace!: string;\r\n    fullname!:string;\r\n    type!: LClassifier; // Classifiers describing PrimitiveTypes or the classes that can be pointed.\r\n    primitiveType!: LClass;\r\n    classType!: LClass;\r\n    enumType!: LEnumerator;\r\n// from structuralfeature (ref + attr)\r\n    ordered!: boolean;\r\n    unique!: boolean;\r\n    lowerBound!: number;\r\n    upperBound!: number;\r\n    many!: boolean;\r\n    required!: boolean;\r\n    allowCrossReference!: boolean;\r\n\r\n    changeable!: boolean;\r\n    volatile!: boolean;\r\n    transient!: boolean;\r\n    unsettable!: boolean;\r\n    public derived!: boolean;\r\n    /*protected */derived_read?: string;\r\n    /*protected */derived_write?: string;\r\n    /*protected*/ __info_of__derived: Info = {type: 'string', txt:'A ECore flag to signal the values of this feature depend on other features.\\n' +\r\n            'To make it usable at runtime in jjodel check derived_read and derived_write.'}\r\n    /*protected*/ __info_of__derived_read: Info = {type: 'string', txt:'A function in string format with 2 or less attributes: (data, oldValue).\\n' +\r\n            '- data is the LValue hosting this derived feature\\n' +\r\n            '- originalValues are the current **non-derived** values actually memorized in the data.values\\n'+\r\n            'The mandatory return value of this function will be returned when attempted to read data.values.'}\r\n    /*protected*/ __info_of__derived_write: Info = {type: 'string', txt:'A function in string format with 3 or less attributes: (value, data, oldValue).\\n' +\r\n            '- value is the value currently attempted to be set, which triggered the function call.\\n' +\r\n            '- data is the LValue hosting this derived feature\\n' +\r\n            '- originalValues are the current **non-derived** values actually memorized in the data.values\\n'+\r\n            'The optional return value of this function will be stored inside data, allowing for hybrid dependency-persistant features' +\r\n            '\\n or for a feature \"depending on itself\". like uppercasing his values before setting them.'}\r\n    defaultValue!: DStructuralFeature[\"defaultValue\"];\r\n    // defaultValueLiteral!: string;\r\n    // target!: LClass[]; is value[]\r\n    edges!: LEdge[];\r\n    // IoT Section\r\n    topic!: string;\r\n\r\n\r\n    // personal\r\n    value!: PrimitiveType | LObject | LEnumLiteral;\r\n    isMirage!: boolean;\r\n    // value!: PrimitiveType | LObject;\r\n    values!: PrimitiveType[] | LObject[] | LEnumLiteral[];\r\n    instanceof!: LAttribute | LReference | undefined;\r\n    conformsTo!:( LAttribute | LReference)[]; // low priority to do: attributo fittizio controlla a quali elementi m2 è conforme quando viene richiesto\r\n\r\n\r\n    length!: number;\r\n    __info_of__length: Info = {type: 'number', txt: \"shortcut for data.values.length.\"};\r\n    get_length(c: Context): number{\r\n        return this.get_values(c).length;\r\n    }\r\n\r\n\r\n\r\n    protected set___readonly(val: any, c: Context): boolean {\r\n        val = !!val;\r\n        if (val === !!c.data.__readonly) return true;\r\n        super.set___readonly(val, c);\r\n        let lref: LReference = this.get_instanceof(c) as LReference;\r\n        if (!lref) return true;\r\n        let dref = lref.__raw;\r\n        if (dref.composition || dref.aggregation) for(let v0 of this.get_values(c)) {\r\n            if (!v0) continue;\r\n            let v: GObject = v0 as any;\r\n            if (v.__isproxy) v.__readonly = val;\r\n        }\r\n        return true;\r\n    }\r\n    protected get_toPrimitive(c: Context): ()=>(string | number){\r\n        return ()=>this.get_value(c) as any;\r\n    }\r\n\r\n\r\n// from reference\r\n    container!: boolean;\r\n    opposite?: LValue; // if DRef have opposite DRef, when you set a value ref you also set a opposite value ref from target to this src. they are always mirroring.\r\n    containment!:boolean;\r\n    aggregation!:boolean;\r\n    composition!:boolean;\r\n    upperbound!:boolean;\r\n    lowerbound!:boolean;\r\n    protected _defaultGetter(c: Context, k: string | number): any {\r\n        if (k in c.data || typeof k === \"symbol\") return this.__defaultGetter(c, k);\r\n\r\n        // get from values\r\n        if (typeof k === \"number\") return this.get_values(c)[k];\r\n        if (TargetableProxyHandler.childKeys[k[0]]) {\r\n            k = k.substring(1);\r\n            let vals: any[] = this.get_values(c);\r\n            for (let v of vals) {\r\n                if (!v) continue;\r\n                let ret = v[k];\r\n                if (ret !== undefined) return ret;\r\n            }\r\n        }\r\n\r\n        // get from meta\r\n        let getk = 'get_'+k;\r\n        if (k in LReference.singleton || getk in LReference.singleton) return this.get_instanceof(c)?.[k as any];\r\n        if (k in LAttribute.singleton || getk in LAttribute.singleton) return this.get_instanceof(c)?.[k as any];\r\n\r\n        return this.__defaultGetter(c, k);\r\n    }\r\n\r\n    protected _defaultSetter(v: any, c: Context, k: keyof Context[\"data\"] & string): true { //\r\n        if (super._setterFor$stuff_canReturnFalse(v, c, k as string)) return true; // try setter for data.$feature = value; shortcut for data.$feature.value = value;\r\n        this.__defaultSetter(v, c, k);\r\n        return true;\r\n    }\r\n\r\n\r\n    protected get_derived(c: Context): this[\"derived\"] { return (this.get_instanceof(c) as LReference).derived; }\r\n    protected get_derived_read(c: Context): this[\"derived_read\"] { return (this.get_instanceof(c) as LReference).derived_read; }\r\n    protected get_derived_write(c: Context): this[\"derived_write\"] { return (this.get_instanceof(c) as LReference).derived_write; }\r\n    protected set_derived(val: this[\"derived\"], context: Context): boolean { return this.cannotSet('LValue.derived'); }\r\n    protected set_derived_read(val: this[\"derived_read\"], context: Context): boolean { return this.cannotSet('LValue.derived_read'); }\r\n    protected set_derived_write(val: this[\"derived_write\"], context: Context): boolean { return this.cannotSet('LValue.derived_write'); }\r\n\r\n    add(...val: any[]): void { return this.cannotCall(\"LValue.add\"); }\r\n    __info_of__add: Info = {type: \"(...val: any|any[]) => void\", txt: \"Adds a value in the current value collection\"}\r\n    get_add(c: Context): (...val: any[] | this[\"values\"])=>void{\r\n        return (...val: any[] | this[\"values\"]) => { this.set_values([...c.data.values, ...val.map(v => v?.id || v)], c); }\r\n    }\r\n    remove(...val: any[]): void{ return this.cannotCall(\"LValue.remove\"); }\r\n    __info_of__remove: Info = {type: \"(...val: any) => void\", txt: \"Deletes a value in the current value collection, or none if the element is not found.\"}\r\n    get_remove(c: Context): (...val: this[\"values\"])=>void {\r\n        return (...val: any[] | this[\"values\"]) => {\r\n            val = val.map(v => v?.id || v);\r\n            let indices = [];\r\n            let values = c.data.values;\r\n            for (let i = 0; i < values.length; i++) {\r\n                if (val.includes(values[i])) indices.push(i);\r\n            }\r\n            this.get_removeByIndex(c)(...indices); }\r\n    }\r\n    removeByIndex(...val: number[]): void{ return this.cannotCall(\"LValue.removeByIndex\"); }\r\n    __info_of__removeByIndex: Info = {type: \"(...indices: number) => removed[]\", txt: \"Deletes a value in the current value collection, or none if the element is not found.\"}\r\n    get_removeByIndex(c: Context): (...indices: number[])=>void{ return (...indices: number[]) => {\r\n        // reducer is ill-typed, so must force typings\r\n        const indexMap: GObject = indices.reduce<GObject|number>(((accumulator: GObject, currentValue: number) => { accumulator[currentValue] = true; return accumulator;}) as any, {} as GObject) as any;\r\n        this.set_values(c.data.values.filter((v,index) => !indexMap[index]), c);\r\n        // this.set_values(c.data.values.filter((v,index) => indices.includes(index)));\r\n    }\r\n    }\r\n\r\n    instantiableClasses(o?: GObject, loose: boolean = false):LClass[] { return this.cannotCall(\"instantiableClasses\"); }\r\n    __info_of__instantiableClasses: Info = {type: \"(o?: object, loose?: boolean) => LClass[]\",\r\n        txt: \"List of all subclasses of the specified type, which can be used as reference values.\" +\r\n            \"\\n<br>Abstract and Interface classes are excluded.\" +\r\n            \"\\n<br>If the parameter \\\"o\\\" is specified, it will filter only the instances conforming to the object schema.\" +\r\n            \"\\n<br>Results are sorted from tightest fit to loosest fit.\" +\r\n            \"\\n<br>loose parameter set to true makes return instead a list of matching scores of all subclasses.\", hidden: true}\r\n\r\n    // warning: this can be called through model, c.data might be either a value or a model.\r\n    get_instantiableClasses(c: Context): this[\"instantiableClasses\"] {\r\n        return (o?: GObject, loose: boolean = false) => LValue.getInstantiableClasses(this, c, o, loose); }\r\n\r\n\r\n    // @eligibleClasses: search only between those targets.\r\n    // @favoritematch: if this class is a valid match, it is given topmost priority regardless of tightness of excess features over the schema.\r\n    // if a class name actually starts with $ character, it needs to be placed twice to get a match, as in class.$$name\r\n    public static getInstantiableClasses(thiss: GObject<LValue|LModel>, c: LogicContext<DValue> | LogicContext<DModel>, schema?: GObject, loose: boolean = false, eligibleClasses?: LClass[], favoriteMatch?: LClass): LClass[] {\r\n        // find eligible classes\r\n        let isDValue: boolean =  c.data.className === \"DValue\";\r\n        let isDModel: boolean =  c.data.className === \"DModel\";\r\n        let isShapeless = !c.data.instanceof;\r\n        let type: LClass | undefined = isShapeless || !isDValue ? undefined : thiss.get_type(c) as LClass;\r\n        let isReference = !!type && type.className === \"DClass\";\r\n        if (isDValue && !isReference && !isShapeless) return []; // case DValue<Attribute>\r\n        if (!eligibleClasses) {\r\n            if (isReference && !isShapeless) { eligibleClasses = [type as LClass, ...(type as LClass).allSubClasses]; }\r\n            // @ts-ignore\r\n            else {eligibleClasses = thiss.get_model(c).instanceof?.classes || []; }\r\n        }\r\n        let scoreMap: Dictionary<Pointer, {\r\n            id: Pointer, score: number,\r\n            excessFeatures: Dictionary<string>, matchingFeatures: Dictionary<string>, missingFeatures: Dictionary<string>,\r\n            excessFeaturesCount: number, matchingFeaturesCount: number, missingFeaturesCount: number,\r\n            isPartial: boolean,\r\n            class:LClass, instantiable: boolean, namesMap: Dictionary<DocString<\"feature name\">>}> = {};\r\n        for (let c of eligibleClasses) {\r\n            let raw = c.__raw as DClass;\r\n            let instantiable = !(raw.abstract || raw.interface || raw.isSingleton);\r\n            // if (!loose && instantiable) return false;\r\n            if (scoreMap[raw.id]) continue;\r\n            else scoreMap[raw.id] = {class:c, instantiable, isPartial: raw.partial} as any;\r\n        }\r\n        if (schema) {\r\n            // const fix$ = (vals: string[]) => vals.map(v=> (TargetableProxyHandler.childKeys[k[0]]) ? v.substring(1) : v);\r\n            const fix$ = (obj: GObject) => {\r\n                let ret: GObject = {};\r\n                for (let k in obj) {\r\n                    let k1 :string = (TargetableProxyHandler.childKeys[k[0]]) ? k.substring(1) : k;\r\n                    ret[k1] = obj[k];\r\n                }\r\n                return ret;\r\n            }\r\n            schema = fix$(schema);\r\n            let keys: string[] = Object.keys(schema);\r\n            for (let ptr in scoreMap) {\r\n                let score = scoreMap[ptr];\r\n                score.namesMap = U.objectFromArrayValues(score.class.childNames);\r\n                let diff = Uobj.objdiff(score.namesMap, schema);\r\n                console.log( \"objDiff\", {schema, names:score.namesMap, data:score.class});\r\n                score.id = ptr;\r\n                score.excessFeatures = diff.removed;\r\n                score.missingFeatures = diff.added;\r\n                score.matchingFeatures = {...diff.changed, ...diff.unchanged}\r\n                score.excessFeaturesCount = Object.keys(score.excessFeatures).length;\r\n                score.missingFeaturesCount = Object.keys(score.missingFeatures).length;\r\n                score.matchingFeaturesCount = Object.keys(score.matchingFeatures).length;\r\n                score.score = Math.round(((score.instantiable ? 0 : -1) + (keys.length ? score.matchingFeaturesCount / keys.length : 1))*100)/100;\r\n            }\r\n        }\r\n        let sorted = Object.values(scoreMap);\r\n        if (!loose) sorted = sorted.filter((s) => s.instantiable && (!s.missingFeaturesCount || s.isPartial));\r\n        let favoriteMatchID: undefined | Pointer = favoriteMatch?.id;\r\n        sorted = sorted.sort((a, b): number => {\r\n            // return negative if a is less than b, positive if a is greater than b, and zero if they are equal.\r\n            // but since default order is ascending and i want descending, o reverse it.\r\n            if (a.instantiable && !b.instantiable) return -1;\r\n            if (!a.instantiable && b.instantiable) return +1;\r\n            if (a.missingFeaturesCount === 0 && b.missingFeaturesCount === 0) { // >100% match case (might have excess, take tighter)\r\n                // nly if they are both valid full matches, explicit preference takes precedence. then tightness.\r\n                if (a.id === favoriteMatchID) return -1;\r\n                if (b.id === favoriteMatchID) return +1;\r\n                if (a.matchingFeaturesCount !== b.matchingFeaturesCount) return -a.matchingFeaturesCount + b.matchingFeaturesCount;\r\n                if (a.excessFeaturesCount !== b.excessFeaturesCount) return +a.excessFeaturesCount - b.excessFeaturesCount;\r\n            }\r\n            // <99% match, but might be valid for partial classes.\r\n            if (a.isPartial && !b.isPartial) return -1;\r\n            if (!a.isPartial && b.isPartial) return +1;\r\n            if (a.isPartial && b.isPartial) {\r\n                // only if they are both valid partial matches, explicit preference takes precedence. then tightness.\r\n                if (a.id === favoriteMatchID) return -1;\r\n                if (b.id === favoriteMatchID) return +1;\r\n            }\r\n            // if both partials or none is partial\r\n            // if (a.missingFeaturesCount !== b.missingFeaturesCount) return -a.missingFeaturesCount + b.missingFeaturesCount; should be same as matchingFeaturesCount\r\n            if (a.matchingFeaturesCount !== b.matchingFeaturesCount) return -a.matchingFeaturesCount + b.matchingFeaturesCount;\r\n            if (a.excessFeaturesCount !== b.excessFeaturesCount) return +a.excessFeaturesCount - b.excessFeaturesCount;\r\n            return 0;\r\n        });\r\n        if (loose) return sorted as any;\r\n        return sorted.map(score => score.class);\r\n    }\r\n\r\n    addObject(json?: GObject, metaclass: LClass | Pointer<DClass> | DocString<\"ClassName\"> | undefined | null = undefined): LObject{ return this.cannotCall(\"LValue.addObject\"); }\r\n    __info_of__addObject: Info = {type: \"(json: object, instanceof?: LClass | string | null) => LObject\",\r\n        txt: \"Appends an object instancing \\\"instanceof\\\" to the values.\\n<br>Setting his own properties, and DValues according to the content of the parameter object.\\n<br>\" +\r\n            \"If instanceof is:<ul><li><b>a class or a class name</b>, it will instance that class, or a valid non-abstract subclass.\" +\r\n            \"\\n<br/><b>null</b>, it will instantiate a shapeless object.\" +\r\n            \"\\n<br/><b>undefined or missing</b>, it will first try to find a valid type in m2 or fail.</ul\"}\r\n\r\n    // warning: this can be called through model, c.data might be either a value or a model.\r\n    /*\r\n    @param metaclass: null means \"shapeless\", undefined means automatic or failure, never shapeless.\r\n    type assignment priority:\r\n    1) by explicit type argument\r\n    1.1) treating it as a pointer\r\n    1.2) treating it as a $class_name\r\n    1.3) treating it as a DClass\r\n*/\r\n    get_addObject(c: LogicContext<DValue> | LogicContext<DModel>): (json: GObject, metaclass?: Pack1<LClass> | DocString<\"ClassName\"> | null, forceCreation?:boolean)=>LObject{\r\n        return (json: GObject = {}, metaclass: Pack1<LClass> | DocString<\"ClassName\"> | undefined | null = undefined, forceCreation:boolean = false): LObject => {\r\n            let lobj: LObject = undefined as any;\r\n            let father: Pointer<DValue> | Pointer<DModel> = '';\r\n            let isDValue = c.data.className === \"DValue\";\r\n            let isDModel = c.data.className === \"DModel\";\r\n\r\n            TRANSACTION(this.get_name(c as any)+'.addObject()', () => {\r\n                let instanceoff: undefined | LAttribute | LReference = isDValue ? this.get_instanceof(c as Context) : undefined;\r\n                let dinstanceoff: undefined | DAttribute | DReference = instanceoff && instanceoff.__raw;\r\n                // let ShapelessObjectID =\r\n                let isShapeless: boolean = !dinstanceoff; // || dinstanceoff && ((dinstanceoff?.id | dinstanceoff) === ShapelessObjectID);\r\n                let isReference: boolean = !!(dinstanceoff && dinstanceoff.className === \"DReference\");\r\n                if (isDValue && !isReference && !isShapeless) return Log.ee(\"cannot call addObject() on a DValue implementing an attribute\", {dinstanceoff, thiss:c.data});\r\n                let isContainment: boolean = (isDValue && this.get_containment(c as Context)) || isDModel;\r\n                // if (metaclass === undefined) metaclass = \"object\"; // in this case, i first check if a class \"object\" exist, then make a shapeless object if not.\r\n                let state: DState = store.getState();\r\n\r\n                father = isContainment ? c.data.id : this.get_model(c).id;\r\n                let constructorPointers: Partial<ObjectPointers> = {...json, father};\r\n\r\n                // if undefined = explicitly told to make it shapeless. if null, it's automatic selectyion by value.type or m2-model classes.\r\n                //console.log('Object.new3', {metaclass, forceCreation, json});\r\n                if (metaclass !== null) {\r\n                    let lmetaclass: LClass | undefined;\r\n                    // find instance schema: 1) by explicit type argument\r\n                    if (metaclass) {\r\n                        // find instance schema: 1.1) by pointer AND 1.3) by Dclass\r\n                        lmetaclass = LPointerTargetable.from(metaclass, state);\r\n                        // find instance schema: 1.2) by $class_name\r\n                        if ((!lmetaclass || lmetaclass.className !== \"DClass\") && typeof metaclass === \"string\") {\r\n                            let m2classes = c.proxyObject.model?.instanceof?.classes;\r\n                            if (m2classes) lmetaclass = LPointerTargetable.from(m2classes[\"$\" + metaclass] || m2classes[metaclass], state);\r\n                            // if (!lmetaclass && typeof metaclass === \"string\" && metaclass.toLowerCase() === \"object\") lmetaclass = undefined;\r\n                        }\r\n                        //(window as any).debugg = LValue.getInstantiableClasses(this, c, json, true, lmetaclass ? [lmetaclass, ...lmetaclass.allSubClasses] : []);\r\n                        // check if metaclass is found\r\n                        if (!lmetaclass || lmetaclass.className !== \"DClass\") return Log.ee(\"provided schema type does not belong to a Class, cannot intantiate.\", {lmetaclass, schema:metaclass, this:c.data});\r\n                        // check if metaclass is valid (instantiable in the callee collection: .values or .objects)\r\n                        // console.log(\"isExtending\", {lmetaclass, type: isDValue && this.get_type?.(c as any)});\r\n                        if (isDValue && !lmetaclass.isExtending(this.get_type(c as Context) as LClass)) return Log.ee(\"provided schema type does not extend this.type, cannot intantiate.\", {lmetaclass, schema:metaclass, this:c.data});\r\n                    }\r\n                    // find instance schema: 2) by dvalue.type\r\n                    else if (isDValue && !isShapeless) {\r\n                        lmetaclass = this.get_type(c as Context) as LClass;\r\n                    }\r\n                    // phase 2: using lmetaclass (if found), i set constructorPointers.instanceof\r\n                    // if requested type is found. but might be abstract, so i filter the best subclass match\r\n                    if (lmetaclass) {\r\n                        if (forceCreation && metaclass) {\r\n                            constructorPointers.instanceof = (typeof metaclass === 'string' ? metaclass : (metaclass as any).id);\r\n                        }\r\n                        else {\r\n                            constructorPointers.instanceof = LValue.getInstantiableClasses(this, c, json, false,\r\n                                [lmetaclass, ...lmetaclass.allSubClasses], lmetaclass)[0] as any; // actually a L-class, but \"ObjectPointers\" can accept them too.\r\n                        }\r\n                        if (!constructorPointers.instanceof) { // the whole if is just printing error.\r\n                            let matches = LValue.getInstantiableClasses(this, c, json, true, [lmetaclass, ...lmetaclass.allSubClasses]);\r\n                            if (lmetaclass?.isSingleton) Log.ee(\"addObject(schema) cannot instantiate \" + metaclass + \" because it is a singleton.\", {json, matches, this: c.data});\r\n                            return Log.ee(\"addObject(schema) could not find a valid subtype of \" + metaclass +\r\n                                \" conforming ot that schema to instantiate an object.\\n\" + (matches.length ? \"closest match was: \" + matches[0].name : \"\"),\r\n                                {json, matches, this: c.data});\r\n                        }\r\n                    }\r\n                    // if not found, i look among all m2classes\r\n                    else if (!isDValue || isShapeless) {\r\n                        // if shapelessvalue.addObject() --> infer schema from json keys and ref sub-types best match\r\n                        // if model.addObject() --> find best match within all classes\r\n                        (window as any).debugg = this.get_model(c).instantiableClasses(json, true);\r\n                        constructorPointers.instanceof = this.get_model(c).instantiableClasses(json, false)[0] as any // actually a L-class, but \"ObjectPointers\" can accept them too.\r\n                        if (!constructorPointers.instanceof) { // the whole if is just printing error.\r\n                            let matches = isDValue ? this.get_instantiableClasses(c as Context)(json, true) : this.get_model(c).instantiableClasses(json, true);\r\n                            let type: LClassifier = isDValue ? this.get_type(c as Context) : undefined as any;\r\n                            return Log.ee(\"LValue.addObject(schema) could not find a valid \" + (c.data.className === \"DValue\" ? \"subtype of \" + type.name : \"type\") +\r\n                                \" conforming ot that schema to instantiate an object.\\n\" + (matches.length ? \"closest match was: \" + (matches[0] as any)?.class.name : \"\"), {json, type, matches, thiss: c.data});\r\n                        }\r\n                    }\r\n                    if (!constructorPointers.instanceof && isDValue && !isShapeless) {\r\n                        return Log.ee(\"could not find an instantiable subtype for given schema and type \" + instanceoff?.type?.name, {schema: json, type: instanceoff?.type})\r\n                    }\r\n                }\r\n                // both dmodel.objects nad dvalue.values are updated by the Constructors by passing father parameter.\r\n                // phase 3: create object according to schema (or shapeless) and update parent container collection.\r\n                console.log(\"Object.new3\", {constructorPointers});\r\n                if (!constructorPointers.name && constructorPointers.instanceof){\r\n                    let meta = L.from(constructorPointers.instanceof);\r\n                    if (meta.isSingleton){ constructorPointers.name = meta.name; }\r\n                }\r\n                let dobj = DObject.new3(constructorPointers, () => { }, isDModel?DModel:DValue, true);\r\n                if (isReference && !isContainment){\r\n                    // if is ref containment, object.father is set to value, which also appends the object to this.values\r\n                    // if it's model, object.father = model, and it goes in model.objects and not in values.\r\n                    // if it's non-containment value, it goes in model but also appended to this.values\r\n                    // ? if schemaless acts like a containment ref so still fine ?\r\n                    this.set_values([...(c as Context).data.values, dobj.id], c as Context)\r\n                }\r\n                // phase 4: set sub-DDalues.values according to json data provided, or create them if they were missing in partial class match.\r\n                lobj = LPointerTargetable.fromD(dobj);\r\n                let dobjkeys = Object.keys(dobj);\r\n\r\n                // update lmetaclass from candidate root, to selected instance (sub-type)\r\n                let lmetaclass: LClass | undefined = constructorPointers.instanceof && LPointerTargetable.wrap(constructorPointers.instanceof);\r\n                let isPartial: boolean = !!lmetaclass?.partial;\r\n                let childnames: Dictionary<string> = lmetaclass ? U.objectFromArrayValues(lmetaclass.childNames) : {};\r\n                // because at current time Constructor.setPtr actions are not executed yet. so dobject.features is empty, even through LPoint.from(valueid) canaccess the \"pending\" local dvalue not in store.\r\n                setTimeout(()=>TRANSACTION(this.get_name(c as any)+'.addObject() initializing values', ()=>{\r\n                    for (let key in json) {\r\n                        if (TargetableProxyHandler.childKeys[key[0]]) { // if $ is prepended, priority is first and only child values check\r\n                            if (key in childnames) { // if child dvalue with that name including char $ exist, like in \"$\" + \"$name\"\r\n                                (lobj as GObject<LObject>)[\"$\" + key].values = json[key];\r\n                                continue;\r\n                            }\r\n                            let key1 = key.substring(1);\r\n                            if (key1 in childnames) { // if child dvalue with that name excluding char $ exist, like in \"$\" + \"name\" (as normal)\r\n                                (lobj as GObject<LObject>)[\"$\" + key1].values = json[key];\r\n                                continue;\r\n                            }\r\n                            // if child dvalue with that name do not exist\r\n                            if (isShapeless || isPartial) { lobj.addValue(key, undefined, json[key], false); continue; }\r\n                            // this should never happen, if there is a mismatch in finding the correct type conforming to the schema, the function should have already stopped and returned before.\r\n                            Log.eDevv('addObject(schema) error: cannot find value collection named \"' + key + ' \" as defined in the schema parameter.',\r\n                                {lmetaclass, this:c.data, instanceof: constructorPointers.instanceof});\r\n                            continue;\r\n                        }\r\n                        // if $ is NOT prepended, priority is inverted: first DObject properties, then child values\r\n                        if (key in dobjkeys) { (lobj as GObject<LObject>)[key] = json[key]; continue; }\r\n                        else {\r\n                            // redoing the whole childmatch attempt for shaped and shapeless, when first char is not $, as a fallback.\r\n                            if (key in childnames) { // if child dvalue with that name excluding char $ exist, like in \"$\" + \"name\" (as normal)\r\n                                console.log(\"get_addObject() adding values\", {lobj, key, json, childnames, d:constructorPointers.instanceof});\r\n                                (lobj as GObject<LObject>)[\"$\" + key].values = json[key];\r\n                                continue;\r\n                            }\r\n                            else if (isShapeless || isPartial) { lobj.addValue(key, undefined, json[key], false); continue; }\r\n                            Log.eDevv('addObject(schema) error: cannot find value collection named \"' + key + ' \" as defined in the schema parameter.',\r\n                                {lmetaclass, this:c.data, instanceof: constructorPointers.instanceof, dobjkeys});\r\n                            continue;\r\n                        }\r\n                    }\r\n                }), 100);\r\n            });\r\n            return lobj;\r\n        }\r\n    }\r\n\r\n\r\n    protected get_edges(context: Context): this[\"edges\"] { return LPointerTargetable.fromPointer(context.data.edges) || []; }\r\n    protected get_fromlfeature<C, T extends keyof (NonNullable<C>)>(meta: C, key: T): NonNullable<C>[T] { return meta ? (meta as any)[key] : undefined; }\r\n    protected get_opposite(context: Context): LReference[\"opposite\"] { return this.get_fromlfeature(context.proxyObject.instanceof as LReference, \"opposite\"); }\r\n    protected get_container(context: Context): LReference[\"container\"] { return this.get_fromlfeature(context.proxyObject.instanceof as LReference, \"container\"); }\r\n    protected get_isContainment(c: Context): LReference[\"containment\"] { return this.get_containment(c); }\r\n    protected get_containment(context: Context): LReference[\"containment\"] {\r\n        let iof = context.proxyObject.instanceof;\r\n        if (!iof) return true; // shapeless\r\n        return this.get_fromlfeature(iof as LReference, \"containment\"); }\r\n    // protected get_defaultValueLiteral(context: Context): LStructuralFeature[\"defaultValueLiteral\"] { return this.get_fromlfeature(context.proxyObject.instanceof, \"defaultValueLiteral\"); }\r\n    protected get_defaultValue(context: Context): LStructuralFeature[\"defaultValue\"] { return this.get_fromlfeature(context.proxyObject.instanceof, \"defaultValue\"); }\r\n    protected get_defaultderived(context: Context): DStructuralFeature[\"derived\"] { return this.get_fromlfeature(context.proxyObject.instanceof, \"derived\"); }\r\n    protected get_defaultunsettable(context: Context): LStructuralFeature[\"unsettable\"] { return this.get_fromlfeature(context.proxyObject.instanceof, \"unsettable\"); }\r\n    protected get_defaulttransient(context: Context): LStructuralFeature[\"transient\"] { return this.get_fromlfeature(context.proxyObject.instanceof, \"transient\"); }\r\n    protected get_isVolatile(c: Context): LReference[\"volatile\"] { return this.get_volatile(c); }\r\n    protected get_volatile(context: Context): LStructuralFeature[\"volatile\"] { return this.get_fromlfeature(context.proxyObject.instanceof, \"volatile\"); }\r\n    protected get_isChangeable(context: Context): LStructuralFeature[\"changeable\"] { return this.get_changeable(context); }\r\n    protected get_changeable(context: Context): LStructuralFeature[\"changeable\"] { return this.get_fromlfeature(context.proxyObject.instanceof, \"changeable\"); }\r\n    protected get_isRequired(context: Context): LStructuralFeature[\"required\"] { return this.get_required(context); }\r\n    protected get_required(context: Context): LStructuralFeature[\"required\"] { return this.get_fromlfeature(context.proxyObject.instanceof, \"required\"); }\r\n    protected get_isUnique(context: Context): LStructuralFeature[\"unique\"] { return this.get_unique(context); }\r\n    protected get_unique(context: Context): LStructuralFeature[\"unique\"] { return this.get_fromlfeature(context.proxyObject.instanceof, \"unique\"); }\r\n    protected get_isMany(context: Context): LStructuralFeature[\"many\"] { return this.get_many(context); }\r\n    protected get_many(context: Context): LStructuralFeature[\"many\"] { return this.get_fromlfeature(context.proxyObject.instanceof, \"many\"); }\r\n    protected get_upperBound(context: Context): LStructuralFeature[\"upperBound\"] { return this.get_fromlfeature(context.proxyObject.instanceof, \"upperBound\"); }\r\n    protected get_lowerBound(context: Context): LStructuralFeature[\"lowerBound\"] { return this.get_fromlfeature(context.proxyObject.instanceof, \"lowerBound\"); }\r\n    protected get_ordered(context: Context): LStructuralFeature[\"ordered\"] { return this.get_fromlfeature(context.proxyObject.instanceof, \"ordered\"); }\r\n    protected get_enumType(context: Context): LStructuralFeature[\"enumType\"] { return this.get_fromlfeature(context.proxyObject.instanceof, \"enumType\"); }\r\n    protected get_classType(context: Context): LStructuralFeature[\"classType\"] { return this.get_fromlfeature(context.proxyObject.instanceof, \"classType\"); }\r\n    protected get_primitiveType(context: Context): LStructuralFeature[\"primitiveType\"] { return this.get_fromlfeature(context.proxyObject.instanceof, \"primitiveType\"); }\r\n    protected get_type(context: Context): LStructuralFeature[\"type\"] { return this.get_fromlfeature(context.proxyObject.instanceof, \"type\"); }\r\n    // protected get_fullname(context: Context): LStructuralFeature[\"fullname\"] { return this.get_fromlfeature(context.proxyObject.instanceof, \"fullname\"); }\r\n    protected get_namespace(context: Context): LStructuralFeature[\"namespace\"] { return this.get_fromlfeature(context.proxyObject.instanceof, \"namespace\"); }\r\n    protected get_name(context: Context): LStructuralFeature[\"name\"] { return context.data.instanceof ? this.get_fromlfeature(context.proxyObject.instanceof, \"name\") : context.data.name || ''; }\r\n\r\n    protected get_instanceof(context: Context): this[\"instanceof\"] {\r\n        const pointer = context.data.instanceof;\r\n        if (!pointer) return undefined;\r\n        return LPointerTargetable.from(pointer)\r\n    }\r\n    protected set_instanceof(val: Pack1<this[\"instanceof\"]>, c: Context): boolean {\r\n        // const list = val.map((lItem) => { return Pointers.from(lItem) });\r\n        let ptr = Pointers.from<DNamedElement>(val as any);\r\n        if (ptr === c.data.instanceof) return true;\r\n        TRANSACTION(this.get_name(c)+'.instanceof', ()=>{\r\n            SetFieldAction.new(c.data, 'instanceof', ptr, \"\", true);\r\n        }, this.get_instanceof(c)?.fullname, LPointerTargetable.wrap(ptr)?.fullname)\r\n        return true;\r\n    }\r\n\r\n    protected get_isMirage(context: Context): this[\"isMirage\"] { return !!context.data.isMirage; }\r\n    protected set_isMirage(val: this[\"isMirage\"], c: Context): boolean {\r\n        val = !!val;\r\n        if (val === !!c.data.isMirage) return true;\r\n        TRANSACTION(this.get_name(c)+'.isMirage', ()=>{\r\n            SetFieldAction.new(c.data, 'isMirage', val, \"\", false);\r\n        }, c.data.isMirage, val)\r\n        return true;\r\n    }\r\n\r\n    typeStr!:string; // derivate attribute, abstract\r\n    typeString!:string; // derivate attribute, abstract\r\n    __info_of__typeStr: Info = {type: ShortAttribETypes.EString, txt: <div>Alias of<i>this.typeString</i></div>}\r\n    __info_of__typeString: Info = {type: ShortAttribETypes.EString, txt: <div>Stringified version of <i>this.type</i></div>}\r\n    protected get_typeString(c: Context): string { return this.get_typeStr(c); }\r\n    // @ts-ignore\r\n    protected get_typeStr(c: Context): string { return LObject.singleton.get_typeStr.call(this, c); }\r\n\r\n    // individual value getters\r\n    // if withMetaInfo, returns a wrapper for the first non-empty value found containing his index and metainfo\r\n    protected get_value<T extends boolean>(context: Context, namedPointers: boolean = false, ecorePointers: boolean = false,\r\n                                           shapeless: boolean = false, keepempties: boolean = true, withmetainfo: T = false as T): T extends true ? ValueDetail : this[\"value\"]{\r\n        return this.get_values(context, true, namedPointers, ecorePointers, shapeless, keepempties, withmetainfo, 1)[0] as any;\r\n    }\r\n    public getValue<T extends boolean>(namedPointers: boolean = false, ecorePointers: boolean = false, shapeless: boolean = false, keepempties: boolean = true,\r\n                                       withmetainfo: T = false as T): T extends true ? ValueDetail : this[\"value\"]{ return this.cannotCall(\"getValue\"); }\r\n    protected get_getValue(context: Context): this[\"getValue\"] {\r\n        return function (namedPointers: boolean = false, ecorePointers: boolean = false, shapeless: boolean = false,\r\n                         keepempties: boolean = true, withmetainfo: boolean = false) {\r\n            return LValue.prototype.get_value(context, namedPointers, ecorePointers, shapeless, keepempties, withmetainfo) as any;\r\n        }\r\n    }\r\n\r\n    // multiple value getters\r\n    protected get_values<T extends boolean>(context: Context, fitSize: boolean = true, namedPointers: boolean = false, ecorePointers: boolean = false,\r\n                                            shapeless: boolean = false, keepempties: boolean = true, withmetainfo?: T, maxlimit?: number,\r\n                                            solveLiterals: \"ordinals\" | \"literal_obj\" | \"literal_str\" | \"original\" = \"literal_obj\")\r\n        : (T extends undefined ? this[\"values\"] : T extends false ? this[\"values\"] : ValueDetail[]) & {type?: string}  {\r\n        const ldata = context.proxyObject;\r\n        const ddata = context.data;\r\n        let typestr: string = this.get_typeString(context);\r\n        let ret: any[];\r\n\r\n        if (ddata.topic) {/*\r\n            let value: any = store.getState()['topics'];\r\n            const path = data.topic.split('.');\r\n            for(const field of path) value = value[field];\r\n            let ret: any = [value];*/\r\n            const topics = store.getState()['topics'];\r\n            const val = U.extractValueFromTopic(topics, ddata.topic);\r\n            ret = Array.isArray(val) ? val : [val];\r\n            //return ret;\r\n        }\r\n        else ret = [...ddata.values];\r\n        (ret as any).type = typestr; // 'topic';\r\n\r\n        let meta: LAttribute | LReference | undefined = shapeless ? undefined : ldata.instanceof;\r\n        let dmeta: undefined | DAttribute | DReference = meta?.__raw;\r\n\r\n        // if (meta && meta.className === DReference.name) ret = LPointerTargetable.fromArr(ret as DObject[]);\r\n\r\n\r\n        if (dmeta?.derived) {\r\n            let td = transientProperties.modelElement[dmeta.id];\r\n            if (!td.derived_read) {\r\n                try {\r\n                    let txt = dmeta.derived_read || '(data, originalValues)=>{return originalValues}';\r\n                    // data.derived examples: '(d, o)=>3', '(ddd, ooo)=>{return 3}',\r\n                    td.derived_read = new Function('data, originalValues', 'return ('+txt+')(data, originalValues)') as Function2;\r\n                }\r\n                catch (error: any) {\r\n                    Log.ee('invalid derived (get) attribute expression: ' + dmeta.name, {error, derivedText:dmeta.derived_read});\r\n                }\r\n                if (td.derived_read) try {\r\n                    ret = td.derived_read(ldata, ret);\r\n                    if (ret === undefined) ret = [];\r\n                    if (!Array.isArray(ret)) ret = [ret];\r\n                }\r\n                catch (error: any) {\r\n                    Log.ee('Error during derived (get) attribute evaluation: ' + dmeta.name, {error, derivedText:dmeta.derived_read});\r\n                }\r\n            }\r\n        }\r\n\r\n\r\n        (ret as GObject).type = typestr;\r\n        if (!Array.isArray(ret)) ret = [];\r\n        if (dmeta && fitSize && ret.length < dmeta.lowerBound && dmeta.lowerBound > 0) {\r\n            let times = dmeta.lowerBound - ret.length;\r\n            while (times-- > 0) ret.push(undefined);\r\n            // ret.length = meta.lowerBound; not really working for expanding, it says \"emptyx10\" or so. doing .map() only iterates \"existing\" elements. behaves like as it's smaller.\r\n        }\r\n        if (maxlimit !== undefined) ret.length = maxlimit;\r\n        else if (dmeta && fitSize && ret.length > dmeta.upperBound && dmeta.upperBound >= 0) ret.length = dmeta.upperBound;\r\n\r\n        // console.log(\"get_values sizefixed\", {fitSize, arguments, upperbound:dmeta?.upperBound, lowerbound: dmeta?.lowerBound, len: ret.length, len0: context.data.values.length});\r\n        let numbermax = 0, numbermin = 0, round = true;\r\n        // ret is always an array of raw values before this point, eventually padded with lowerbound or trimmed at upperbound\r\n\r\n        let index = 0;\r\n        if (withmetainfo) { ret = ret.map(r => {return {value:r, rawValue: r, index: index++, hidden: false} as ValueDetail}); }\r\n        let mapperfunc: (a:any)=>any = undefined as any;\r\n        let numbercasting = (v: any): number => {\r\n            if (typeof v !== \"number\") {\r\n                if (!v) v = 0;\r\n                else if (v === \"true\") v = 1;\r\n                else if (v.constructor?.name=== \"Date\") v = v.getTime();\r\n                else if (typeof v === \"string\") {\r\n                    // console.log(\"number casting:\", v,  U.getFirstNumber(v+'', true), {numbermax, numbermin});\r\n                    v = U.getFirstNumber(v+'', !round);\r\n                } else return NaN;\r\n            }\r\n            v = Math.min(numbermax, Math.max(numbermin, v));\r\n            return round ? Math.round(v) : v;\r\n        };\r\n        switch (typestr) {\r\n            case \"shapeless\":\r\n                let state: DState = store.getState();\r\n                mapperfunc = (val: any) => {\r\n                    if (!val || typeof val !== \"string\") return val;\r\n                    let l: any = LPointerTargetable.fromPointer(val, state);\r\n                    if (!l) return val;\r\n                    if (l.className === DEnumLiteral.cname) { l = (l as DEnumLiteral).literal; } else\r\n                    if (namedPointers) { l = (l.name ? (\"@\" + l.name) : (l as GObject)[\"@\"+l.name]?.__raw?.values?.[0] || (\"#\" + l.className));}\r\n                    else if (ecorePointers){ l = l.ecorePointer(); }\r\n                    return l;\r\n                };\r\n                if (withmetainfo) ret.forEach((struct: ValueDetail) => { struct.value = mapperfunc(struct.value); });\r\n                else ret = ret.map(mapperfunc);\r\n                break;\r\n            default: // it's a reference or enum\r\n                let lenum: LEnumerator = undefined as any;\r\n                let type: LClassifier = (meta as LStructuralFeature)?.type;\r\n                if (type?.className === DEnumerator.cname) {\r\n                    lenum = type as LEnumerator;\r\n                    mapperfunc = (r: any) => {\r\n                        if (solveLiterals === \"original\") return r;\r\n                        numbermin = 0;\r\n                        numbermax = (solveLiterals === \"ordinals\") ? Number.POSITIVE_INFINITY : 0;\r\n                        let lit: LEnumLiteral | undefined\r\n                        if (typeof r === \"string\") lit = Pointers.isPointer(r) ? LPointerTargetable.fromPointer(r) : (lenum as any)[\"@\"+r];\r\n                        else if (typeof r === \"number\") lit = lenum.ordinals[r];\r\n                        switch (solveLiterals) {\r\n                            default:\r\n                            case \"literal_obj\": return lit;\r\n                            // if r was a number and a valid ordinal (found literal through him) return r. if r was a string, don't return r but lenum[\"@\"+r].ordinal\r\n                            case \"ordinals\": return (typeof r === \"number\" ? (lit ? r : undefined) : lit?.ordinal);\r\n                            case \"literal_str\": return (typeof r === \"string\" ? (lit ? r : undefined) : lit?.literal);\r\n                        }\r\n                    }\r\n                } else if (!type.isPrimitive && type?.className === DClass.cname) mapperfunc = (r: any) => r && LPointerTargetable.fromPointer(r);\r\n                else mapperfunc = (r: any) => r;\r\n                if (withmetainfo) ret.forEach((struct: ValueDetail) => { struct.value = mapperfunc(struct.value); });\r\n                else ret = ret.map(mapperfunc);\r\n\r\n                // now ret is pointed DEnumLiteral or DObject or MetaInfoStructure<>\r\n                if (type?.className === DEnumerator.cname) {\r\n                    // replace numeric literals, mapped to literal ordinal. can happen with type switches\r\n                    /*\r\n                    if (solveLiterals) {\r\n                        mapperfunc = (lit: LEnumLiteral|number) => {\r\n                            numbermax = Number.POSITIVE_INFINITY;\r\n                            numbermin = 0;\r\n                            let ordinal = numbercasting(lit);\r\n                            return isNaN(ordinal) ? lit : (meta!.type as LEnumerator).ordinals[ordinal];\r\n                        }\r\n                        if (withmetainfo) ret.forEach((struct: ValueDetail) => { struct.value = mapperfunc(struct.value); });\r\n                        else ret = ret.map(mapperfunc);\r\n                    }*/\r\n                    let filterfunc = (l: LEnumLiteral) => { if (!l) return keepempties; return l.father?.id === (meta as LAttribute).type.id; };\r\n                    if (withmetainfo) for(let struct of ret as ValueDetail[]) { struct.hidden = !filterfunc(struct.value as LEnumLiteral); } // && 'literal target is not of the correct type requested by metamodel'; }\r\n                    else ret = ret.filter(filterfunc);\r\n                    // todo: questo comportamento implica che quando importo un literal come testo da .ecore, devo assegnargli\r\n                    //  il puntatore al suo literal se trovato, altrimenti resta val[i] di tipo string/shapeless\r\n                    if (namedPointers) {\r\n                        mapperfunc = (lit?: LEnumLiteral) => lit?.name;\r\n                        if (withmetainfo) ret.forEach((struct: ValueDetail) => { struct.value = mapperfunc(struct.value); });\r\n                        else ret = ret.map(mapperfunc);\r\n                    }\r\n                    break;\r\n                }\r\n                // is reference with assigned shape (and type) -> filter correct typed targets\r\n                if (meta) {\r\n                    let filterfunc = (l: LObject) => {\r\n                        // hide values with a value that is not a pointer to correct type (but keep empties if requested)\r\n                        //let isExtending = l.instanceof?.isExtending((meta as LReference).type); // damiano: todo test & debug isextending\r\n                        let isExtending = true;\r\n                        return keepempties && !l ? true : isExtending;\r\n                    };\r\n                    if (withmetainfo) for(let struct of ret as ValueDetail[]) { struct.hidden = !filterfunc(struct.value as LObject); } // && \"ref target is not of correct type\"; }\r\n                    else ret = ret.filter(filterfunc);\r\n                }\r\n                // shaped (with m2-reference) but pointing to a shapeless object. can happen\r\n                if (namedPointers) {\r\n                    let mapperfunc = (l:LObject) => l && (l.name ? (\"@\" + l.name) : (l as GObject)[\"@\"+l.name]?.__raw?.values?.[0] || (\"#\" + l.className));\r\n                    if (withmetainfo) ret.forEach((struct: ValueDetail)=>{ struct.value = mapperfunc(struct.value as LObject); });\r\n                    else ret = ret.map(mapperfunc);\r\n                }\r\n                else if (ecorePointers && !(meta as LReference).containment){\r\n                    mapperfunc = (lval: LObject) => lval && lval.ecorePointer();\r\n                    if (withmetainfo) ret.forEach((struct: ValueDetail)=>{ struct.value = mapperfunc(struct.value as LObject); });\r\n                    else ret = ret.map(mapperfunc);\r\n                    // throw new Error(\"values as EcorePointers: todo. for containment do nothing, just nest the obj. for non-containment put the ecore reference string in array vals\")\r\n                }\r\n                break;\r\n            case ShortAttribETypes.EByte:\r\n                numbermin = -128;\r\n                numbermax = 127;\r\n                break;\r\n            case ShortAttribETypes.EShort:\r\n                numbermin = -32768;\r\n                numbermax = 32767;\r\n                break;\r\n            case ShortAttribETypes.EInt:\r\n                numbermin = -2147483648;\r\n                numbermax = 2147483647;\r\n                break\r\n            case ShortAttribETypes.ELong:\r\n                numbermin = -9223372036854775808;\r\n                numbermax = 9223372036854775807;\r\n                break;\r\n            case ShortAttribETypes.EFloat:\r\n            case ShortAttribETypes.EDouble:\r\n                numbermin = Number.NEGATIVE_INFINITY;\r\n                numbermax = Number.POSITIVE_INFINITY;\r\n                round = false;\r\n                break;\r\n            case ShortAttribETypes.EString:\r\n            case ShortAttribETypes.EDate:\r\n                mapperfunc = v => v ? v + '' : ''\r\n                if (withmetainfo) ret.forEach((struct: ValueDetail)=>{ struct.value = mapperfunc(struct.value); });\r\n                else ret = ret.map(mapperfunc);\r\n                break;\r\n            case ShortAttribETypes.EChar:\r\n                mapperfunc = v => v ? (v + '')[0] : 'A';\r\n                if (withmetainfo) ret.forEach((struct: ValueDetail)=>{ struct.value = mapperfunc(struct.value); });\r\n                else ret = ret.map(mapperfunc);\r\n                break;\r\n            case ShortAttribETypes.EBoolean:\r\n                mapperfunc = v => typeof v === \"boolean\" ? v : U.fromBoolString(v+'', v?.length>0, false);\r\n                if (withmetainfo) ret.forEach((struct: ValueDetail)=>{ struct.value = mapperfunc(struct.value); });\r\n                else ret = ret.map(mapperfunc);\r\n                break;\r\n            case ShortAttribETypes.EVoid:\r\n                if (withmetainfo) ret.forEach((struct: ValueDetail)=>struct.hidden = true);\r\n                else ret = [];\r\n                break;\r\n        }\r\n        // some kind of numeric type\r\n        if (numbermax !== 0) {\r\n            if (withmetainfo) ret.forEach((struct: ValueDetail)=>{ struct.value = numbercasting(struct.value); });\r\n            else ret = ret.map(numbercasting);\r\n        }\r\n        return ret as any;\r\n    }\r\n\r\n    public getValues<T extends boolean>(fitSize: boolean = true, namedPointers: boolean = false, ecorePointers: boolean = false, shapeless: boolean = false,\r\n                                        keepempties: boolean = true, withmetainfo?: T, maxlimit?: number)\r\n        : (T extends undefined ? this[\"values\"] : T extends false ? this[\"values\"] : ValueDetail[]) & {type?: string} {\r\n        return this.cannotCall(\"getValues\"); }\r\n    protected get_getValues(context: Context): this[\"getValues\"] {\r\n        return function (fitSize: boolean = true, namedPointers: boolean = true, ecorePointers: boolean = false,\r\n                         shapeless: boolean = false, keepempties: boolean = false, withmetainfo: any = false, limit?: number) {\r\n            return LValue.prototype.get_values(context, fitSize, namedPointers, ecorePointers, shapeless, keepempties, withmetainfo, limit) as any;\r\n        }\r\n    }\r\n    // stringified value getters\r\n    public valuesString(keepemptyquotes?: boolean): string { return this.cannotCall(\"valuestring\"); }\r\n    public valuestring(keepemptyquotes?: boolean): string { return this.cannotCall(\"valuestring\"); }\r\n    private get_valuestring(context: Context): this[\"valuestring\"] { return (keepemptyquotes?: boolean) => this.valuestring_impl(context, keepemptyquotes); }\r\n    private get_valuesString(context: Context): this[\"valuestring\"] { return (keepemptyquotes?: boolean) => this.valuestring_impl(context, keepemptyquotes); }\r\n    private valuestring_impl(context: Context, keepemptyquotes?: boolean): string {\r\n        let val = this.get_values(context, true, true, false, false, true);\r\n        // console.log(\"valuestring_impl\", {val});\r\n        let ret: any;\r\n        switch (val.length) {\r\n            case 0: ret = ''; break;\r\n            case 1: ret = val[0]; break;\r\n            default:\r\n                let havestrings: boolean = val.type === ShortAttribETypes.EString;\r\n                let havechars: boolean = val.type === ShortAttribETypes.EChar;\r\n                let havepointers: boolean = false;\r\n                let haveLelements: boolean = false;\r\n                for (let vall of [val[0]]) {\r\n                    if ((vall as any)?.__isProxy) haveLelements = true;\r\n                    /*else if (typeof vall === \"string\") { havestrings = true; havepointers = havepointers || vall.includes(\"Pointer\"); }}\r\n                     */\r\n                }\r\n                /*if (havepointers) {\r\n                    val = LPointerTargetable.wrapAll(val);\r\n                    haveLelements = true;\r\n                }*//*\r\n                if (haveLelements) {\r\n                    val = val.map( l => l && (l.name ? (\"@\" + l.name) : (\"#\" + l.className)));\r\n                }*/\r\n                if (havestrings || havechars) {\r\n                    let valstr = JSON.stringify(val);\r\n                    if (!keepemptyquotes) valstr = U.replaceAll(valstr, \"\\\"\\\"\", \"\");\r\n                    ret = valstr.substring(1, valstr.length-1);\r\n                    break;\r\n                }\r\n                else ret = val.join(', ');\r\n        }\r\n        return (ret === undefined || ret === null ? '' : ret) + '';\r\n    }\r\n\r\n    public setValueAtPosition(index: number, val: this[\"values\"][0], info?: Partial<SetValueAtPositionInfoType>): {success: boolean, reason?: string} {\r\n        return this.cannotCall(\"setValueAtPosition\"); }\r\n\r\n    // only use through setValueAtPosition\r\n    protected _clearValueAtPosition(context: Context, index: number, info0?: Partial<SetValueAtPositionInfoType>, skipSettingUndefined: boolean = false) {\r\n        // if (!outactions) outactions = {clear:[], set:[]};\r\n        if (index < 0) return;\r\n        let info = (info0 || {}) as unknown as SetValueAtPositionInfoType;\r\n        let oldVal = context.data.values[index];\r\n        let oldTarget: LObject | undefined = typeof oldVal === \"string\" ? LObject.fromPointer(oldVal) : undefined;\r\n        /////////////////////// if oldTarget is LObject, update his pointedBy\r\n        // if (oldTarget) SetFieldAction.new(oldTarget, \"pointedBy\" '-=\", ... no need? reducer should do this)\r\n\r\n        /////////////////////// if ref is containment assign oldTarget father to DModel\r\n\r\n        if (info.isContainment === undefined) {\r\n            if (info.instanceof === undefined) info.instanceof = context.proxyObject.instanceof;\r\n            if (info.instanceof){\r\n                if (info.instanceof.className === DReference.cname) { info.isContainment = (info.instanceof as LReference).containment; }\r\n                else info.isContainment = false;\r\n            }\r\n            else { info.isContainment = true; }\r\n        }\r\n        if (info.isContainment && oldTarget?.className === \"DObject\") {\r\n            SetFieldAction.new(oldVal as Pointer<DObject>, \"father\", context.proxyObject.model.id, undefined, true);\r\n        }\r\n        if (!skipSettingUndefined) SetFieldAction.new(context.data, 'values.' + index as any, undefined, '', info.isPtr);\r\n    }\r\n    protected get_setValueAtPosition(c: Context): ((index: number, val: this[\"values\"][0], info?: Partial<SetValueAtPositionInfoType>, outactions?:outactions) => {success: boolean, reason?: string}) {\r\n        return (index: number, val: this[\"values\"][0] | any, info0?: Partial<SetValueAtPositionInfoType>, outactions?: outactions): { success: boolean, reason?: string } => {\r\n            if (!outactions) outactions = {clear:[], set:[], immediatefire: true}\r\n            let isPtr: boolean = undefined as any;\r\n            let lval: LObject | LEnumLiteral = undefined as any;\r\n            if (val === null) val = undefined;\r\n            let oldval = c.data.values[index];\r\n            if (oldval === val) return { success: false, reason: \"identical assignment\" };\r\n            let tmpval_id = Pointers.from(val) ;\r\n            if (oldval === tmpval_id) return { success: false, reason: \"identical object assignment\" };\r\n            let state = store.getState();\r\n            if (tmpval_id && (val as any)?.className) {\r\n                lval = LPointerTargetable.wrap<DObject>(val, state) as LObject | LEnumLiteral;\r\n                isPtr = !!(lval || Pointers.isPointer(oldval));//LPointerTargetable.wrap(oldval, state));\r\n                val = tmpval_id;\r\n            }\r\n            let info = (info0 || {}) as unknown as SetValueAtPositionInfoType;\r\n            if (isPtr === undefined) isPtr = (info.isPtr === undefined ? Pointers.isPointer(val) || Pointers.isPointer(oldval) : info.isPtr);\r\n\r\n\r\n            // set sideeffect part\r\n            if (val !== undefined) {\r\n                if (isPtr) {\r\n                    if (info.type === undefined) info.type = c.proxyObject.type;\r\n                    if (info.instanceof === undefined) info.instanceof = c.proxyObject.instanceof;\r\n                    if (info.isContainment === undefined) {\r\n                        info.isContainment = !info.instanceof || (info.instanceof.className === DReference.cname && (info.instanceof as LReference).containment);\r\n                    }\r\n                    lval = LPointerTargetable.fromPointer(val);\r\n                    if (!lval) return {success: false, reason: \"invalid pointer: \" + lval};\r\n                    // is enum\r\n                    if (lval.className === DEnumLiteral.cname) {\r\n                        let lvale: LEnumLiteral = lval as LEnumLiteral;\r\n                        if (info.instanceof && info.type && (lvale.father.id !== info.type.id)) return {success: false, reason: \"target is not of correct literal type\"};\r\n                        // no need to do checks / other sideeffects other than pointedBy i think.\r\n                    }\r\n                    // is ref\r\n                    if (lval.className === DObject.cname){\r\n\r\n                        let lvalo = lval as LObject;\r\n                        //let lvalmeta: LClassifier | undefined = lvalo.instanceof;\r\n                        // if (info.instanceof && info.type && (!(lvalmeta as LClass)?.isExtending(info.type))) return {success: false, reason: \"target is not of correct type\"}; damiano todo: enable and implement isExtending\r\n                        if (info.fatherList === undefined) info.fatherList = c.proxyObject.fatherList;\r\n                        if (info.isContainment) {\r\n                            if ((info.fatherList as LPointerTargetable[]).map(father => father.id).includes(val))\r\n                                return {success: false, reason: \"cannot create a containment loop\"}; // todo: in LReference.set_containment need to forbid setting to true if there is a loop\r\n                            let oldContainer: LValue | LModel = lvalo.father;\r\n                            let oldContainerValue: LValue = (oldContainer.className === DModel.cname) ? undefined as any : (oldContainer as LValue);\r\n                            // detach contaied object from old parent\r\n                            if (oldContainerValue && oldContainerValue.id !== c.data.id) outactions.clear.push(()=>{\r\n                                let valarr: any[] = oldContainerValue.__raw.values;\r\n\r\n                                for (let i = 0; i < valarr.length; i++) {\r\n                                    let v = valarr[i];\r\n                                    if (v === val) oldContainerValue.setValueAtPosition(i, undefined as any, undefined);\r\n                                }\r\n\r\n                            });\r\n                            outactions.set.push(()=> {\r\n                                SetFieldAction.new(val as Pointer<DObject>, \"father\", c.data.id, undefined, true)\r\n                            });\r\n                        }\r\n                    }\r\n                    // automatic? SetFieldAction.new(val as Pointer<DObject>, \"pointedBy\", PointedBy.fromID(c.data.id, \"values.\" + index as any), \"+=\");\r\n                } else {\r\n                    // loose checks, i can assign any primitive to any primitive (will cast on get)\r\n                    if (info.instanceof === undefined) info.instanceof = c.proxyObject.instanceof;\r\n                    let metatype: string = (info.instanceof as LAttribute)?.typeToShortString() || \"shapeless\";\r\n                    if (typeof val === \"object\") {\r\n                        if (val.constructor === Date && (metatype !== \"EString\" && metatype !== \"EDate\" && metatype !== \"shapeless\"))\r\n                            return {\r\n                                success: false,\r\n                                reason: \"dates can only be assigned to values of type string or Date\"\r\n                            };\r\n                        // return {success: false, reason: \"objects are not assignable except for dates\"}; maybe i allow this instead\r\n                    }\r\n                }\r\n            }\r\n\r\n            TRANSACTION(this.get_name(c)+'.setValue('+index+': index)', ()=>{\r\n                if (!outactions) return;\r\n                // clear sideeffect part\r\n                outactions.clear.push(()=>this._clearValueAtPosition(c, index, info, true));\r\n                // console.log('set value index', {index, val, isPtr});\r\n                // actual set\r\n                outactions.set.push(()=>SetFieldAction.new(c.data, 'values.' + index as any, val, '', isPtr));\r\n                if (info.setMirage !== false) SetFieldAction.new(c.data, 'isMirage', false, '', false);\r\n\r\n                if (outactions.immediatefire) {\r\n                    for (let a of outactions.clear) a();\r\n                    for (let a of outactions.set) a();\r\n                }\r\n            }, c.data.values[index], val)\r\n            // todo: wrap this func and set toaster with failure message if it fails or better launch Log.w and bind toasts of different colors to Log funcs\r\n            return {success: true};\r\n        }\r\n    }\r\n    protected set_values(val0: orArr<D[\"values\"]>, c: Context): boolean {\r\n        let val: any = val0 as any;\r\n        let modified = false;\r\n        let meta = this.get_instanceof(c);\r\n        let dmeta: DReference | DAttribute | undefined = meta?.__raw;\r\n        if (dmeta?.derived) {\r\n            let td = transientProperties.modelElement[dmeta.id];\r\n            if (!td.derived_write) {\r\n                try {\r\n                    let txt = dmeta.derived_write || '(values, data, oldValues)=>{ data.values = values; }';\r\n                    td.derived_write = new Function('values, data, oldValues', 'return ('+txt+')(data, originalValues)') as Function2;\r\n                }\r\n                catch (error: any) {\r\n                    Log.ee('invalid derived (set) attribute expression: ' + dmeta.name, {error, derivedText:dmeta.derived_write});\r\n                }\r\n                if(td.derived_write) try {\r\n                    TRANSACTION('changed ' + this.get_name(c)+' derived attributes', ()=>{\r\n                        let ret = td?.derived_write?.(val, c.proxyObject, c.data.values);\r\n                        if (ret !== undefined) {\r\n                            val = ret;\r\n                            modified = true;\r\n                        }\r\n                    })\r\n                }\r\n                catch (error: any) {\r\n                    Log.ee('Error during derived (set) attribute evaluation: ' + dmeta.name, {error, derivedText:dmeta.derived_write});\r\n                }\r\n            }\r\n        }\r\n\r\n        val = (Array.isArray(val0) ? val0 : [val0]) as D[\"values\"];\r\n        // val.length = Math.max(val.length, c.data.values.length);\r\n        let isContainment = this.get_isContainment(c);\r\n        if (isContainment) { // remove duplicates in containment\r\n            val = val.map((v: any) => v?.id || v);\r\n            let idmap: Dictionary<string, true> = {}\r\n            val = val.filter((e: any)=> { if (typeof e !== 'string' || !idmap[e]) return true; idmap[e] = true; return true;} )\r\n        }\r\n        TRANSACTION(this.get_fullname(c)+'.values', ()=>{\r\n            let outactions: outactions = {clear:[], set:[], immediatefire: false};\r\n            for (let i = 0; i < val.length; i++) {\r\n                let out = this.get_setValueAtPosition(c)(i, val[i], {setMirage: false} as any, outactions);\r\n                modified = out.success || modified;\r\n                // console.log('set_values', {val, i, modifiedreason:out});\r\n            }\r\n            let excess = c.data.values.length - val.length;\r\n            while (excess-- > 0) {\r\n                SetFieldAction.new(c.data.id, 'values', undefined as any, '-=', true);\r\n            }\r\n            for (let a of outactions.clear) a();\r\n            for (let a of outactions.set) a();\r\n            if (modified) c.data.isMirage && SetFieldAction.new(c.data, 'isMirage', false, '', false);\r\n        });\r\n        return true;\r\n\r\n        // old implementation\r\n        let list: any = val;\r\n        let context = c;\r\n        let l = context.proxyObject;\r\n        let instanceoff: LReference | LAttribute | undefined = l.instanceof;\r\n        let isRef: boolean | undefined = (!instanceoff ? undefined : instanceoff?.className === DReference.cname);\r\n        SetFieldAction.new(context.data, 'values', list as any, '', false);\r\n        // console.log(\"pre set_values actions\", l, list, val, context);\r\n\r\n        if (!l.instanceof || isRef && (instanceoff as LReference).containment) {\r\n            let i = 0;\r\n\r\n            for (let v0 of list) {\r\n                // console.log(\"loop set_value actions\", v, context.data, isRef, instanceoff, Pointers.isPointer(v));\r\n                i++;\r\n                if ((isRef || instanceoff === undefined) && Pointers.isPointer(v0)) { // if shapeless obj need to check val by val\r\n                    let v = v0 as Pointer<DModelElement> //Pointer<DObject> | Pointer<DEnumLiteral>;\r\n                    // console.log(\"loop set_value actions SET\", {v, data:context.data, isRef, instanceoff, isPtr:Pointers.isPointer(v)});\r\n                    let lval: LObject = LPointerTargetable.fromPointer(v);\r\n                    let oldContainer: LValue | LModel = lval.father;\r\n                    SetFieldAction.new(v, \"pointedBy\", PointedBy.fromID(context.data.id, \"values.\" + i as any), \"+=\");\r\n                    SetFieldAction.new(v, \"father\", context.data.id, undefined, true);\r\n                    if (oldContainer.className === DModel.cname) continue;\r\n                    let containerValue = (oldContainer as LValue);\r\n                    // let oldContainerValues = [...containerValue.__raw.value]; U.arrayRemoveAll(oldContainerValues, v);\r\n                    let oldContainerValues: Pointer[] = containerValue.__raw.values.map( va => va===v ? undefined as any : va);\r\n                    SetFieldAction.new(containerValue.id, \"values\", oldContainerValues, \"\", true);\r\n\r\n                    // todo: verify if works: remove val from old container\r\n                    let oldv = context.data.values[i];\r\n                    // if (Pointers.isPointer(oldv)) SetFieldAction.new(context.data.id, \"contains\", U.arrayRemoveAll([...context.data.contains], oldv), '', true);\r\n                    // SetFieldAction.new(context.data.id, \"contains\", oldv as DObject[\"id\"], undefined, true);\r\n\r\n                }\r\n            }\r\n        }\r\n        context.data.isMirage && SetFieldAction.new(context.data, 'isMirage', false, '', false);\r\n        return true;\r\n    }\r\n\r\n    protected set_value(val: D[\"values\"][0], c: Context): boolean {\r\n        let v: ValueDetail = this.get_value(c, false, false, false, true, true);\r\n        let val_id = (val as any)?.id || val;\r\n        if (Pointers.isPointer(val_id) && c.data.values.includes(val_id as any) && this.get_isContainment(c)) { return true; }\r\n        let r = this.get_setValueAtPosition(c)(v?.index || 0, val_id || val);\r\n        Log.e(!r.success,  r.reason);\r\n        return r.success;\r\n    }\r\n\r\n    get_crossReference(c: Context): this['allowCrossReference'] { return this.get_allowCrossReference(c); }\r\n    get_isCrossReference(c: Context): this['allowCrossReference'] { return this.get_allowCrossReference(c); }\r\n    set_crossReference(v: this['allowCrossReference'], c: Context): boolean { return this.set_allowCrossReference(v, c); }\r\n    set_isCrossReference(v: this['allowCrossReference'], c: Context): boolean { return this.set_allowCrossReference(v, c); }\r\n    get_allowCrossReference(c: Context): boolean { return c.data.instanceof ? !!c.proxyObject.instanceof?.allowCrossReference : true; }\r\n    set_allowCrossReference(v: this['allowCrossReference'], c: Context): boolean { return this.cannotSet('LValue.allowCrossReference'); }\r\n\r\n\r\n    validTargetOptions!: MultiSelectOptGroup[];\r\n    get_validTargetOptions(c: Context): this['validTargetOptions'] {\r\n        let opts: MultiSelectOptGroup[] = [];\r\n        this.get_validTargets(c, opts);\r\n        return opts;\r\n    }\r\n    validTargetsJSX!: JSX.Element[];\r\n    get_validTargetsJSX(c: Context): this['validTargetsJSX'] {\r\n        let opts: MultiSelectOptGroup[] = [];\r\n        this.get_validTargets(c, opts);\r\n        return UX.options(opts);\r\n    }\r\n    validTargets!: (LObject | LEnumLiteral)[];\r\n    get_validTargets(c: Context, out?: MultiSelectOptGroup[]): this['validTargets'] {\r\n        let meta: LReference | LAttribute = this.get_instanceof(c) as LReference | LAttribute;\r\n        let isShapeless = !meta;\r\n        let isReference = isShapeless || meta.className === 'DReference';\r\n        let isAttribute = isShapeless || meta.className === 'DAttribute';\r\n        let isCrossRef = this.get_isCrossReference(c);\r\n        let freeObjects: LObject[] = [];\r\n        let boundObjects: LObject[] = [];\r\n        let literals: LEnumLiteral[] = [];\r\n        let isContainment = isShapeless || isReference && (meta as LReference).containment;\r\n        let m1: LModel = this.get_model(c);\r\n        let m2 = m1.instanceof;\r\n        // let map = (object: LNamedElement) => ({value:object.id, label: object.name});\r\n        let map = (object: LNamedElement): MultiSelectOption => {\r\n            let fname = object.fullname;\r\n            return {value:object.id, label: isCrossRef ? fname : object.name, title: object.fullname}\r\n        };\r\n        if (isReference) {\r\n            let isContainment: boolean = this.get_containment(c);\r\n            let containerObjectsID: Pointer[] = this.get_fatherList(c).map(lm => lm.id);\r\n            let validObjects = (isCrossRef ? m1.allCrossSubObjects : m1.allSubObjects)\r\n            if (isContainment) validObjects = validObjects.filter(obj => !containerObjectsID.includes(obj.id));\r\n            let type = meta.type;\r\n            if (!isShapeless) validObjects = validObjects.filter((obj) => (type as LClass).isSuperClassOf(obj.instanceof, true))\r\n            // avoiding containment loops damiano todo: put this filter in set_value too\r\n            for (let o of validObjects) {\r\n                //  continue; // no self contain\r\n                if (o.isRoot) freeObjects.push(o);\r\n                else boundObjects.push(o);\r\n            }\r\n            if (out) out.push({label: 'Free     Objects', options: freeObjects.map(map)});\r\n            if (out) out.push({label: 'Bound Objects', options: boundObjects.map(map)});\r\n        }\r\n        if (isAttribute) {\r\n            let enumm: LEnumerator[];\r\n            if (isShapeless){\r\n                if (!m2) enumm = LPointerTargetable.from(Selectors.getAllEnumerators());\r\n                else enumm = (isCrossRef && m2) ? m2.crossEnumerators : m2.enumerators;\r\n            }\r\n            else {\r\n                let type = meta.type;\r\n                enumm = (type.className === 'DEnumerator') ? [type as LEnumerator] : [];\r\n            }\r\n            for (let e of enumm) {\r\n                let currLiterals = e.literals;\r\n                literals.push(...currLiterals);\r\n                if (out) out.push({label: 'Literals of ' + e.name, options: currLiterals.map(map)});\r\n            }}\r\n        return U.arrayMergeInPlace(freeObjects, boundObjects, literals as any);\r\n    }\r\n\r\n    protected generateEcoreJson_impl(c: Context, loopDetectionObj: Dictionary<Pointer, DModelElement> = {}): Json {\r\n        loopDetectionObj[c.data.id] = c.data;\r\n        let values = this.get_values(c, true, false, true, false, false);//, false, undefined, \"literal_str\");\r\n        delete values[\"type\"];\r\n        let ret: any = [];\r\n        the_loop: for (let v of values){\r\n            let l: LObject | LEnumLiteral = v as any;\r\n            if (!l?.__isProxy) { ret.push(l); continue; }\r\n            switch (l.className){\r\n                case \"DOperation\": continue the_loop;\r\n                case \"DEnumLiteral\": ret.push((l as LEnumLiteral).generateEcoreJsonM1()); break;\r\n                default: ret.push(l.generateEcoreJson(loopDetectionObj)); break;\r\n            }\r\n        }\r\n        // ret = ret.filter((j: any) => (j !== undefined || j !== ''));\r\n        return (ret.length <= 1) ? ret[0] : ret; }\r\n\r\n    protected get_toString(context: Context): () => string { return () => this._toString(context); }\r\n    protected _toString(context: Context): string {\r\n        let val: any = this.get_values(context, true, true, false, false, true);\r\n        if (!val) return val + '';\r\n        if (!Array.isArray(val)) val = [val];\r\n        // if (!context.proxyObject.instanceof) val = val.map( (e: GObject) => { return  e.name ? \"@\" + e.name : e; });\r\n        // else if (context.proxyObject.instanceof?.className === DReference.name) val = val.map( (e: GObject) => { return e.name ? \"@\" + e.name : e; });\r\n        switch(val.length) {\r\n            case 0: return '';\r\n            case 1: return val[0] + '';\r\n            default: return val + '';\r\n        }\r\n    }\r\n\r\n    public rawValues(): void { super.cannotCall('rawValues'); }\r\n    public get_rawValues(context: Context): this[\"values\"]{\r\n        return (this.get_getValues(context))(false, false, false, true, true, false, undefined);\r\n    }\r\n\r\n    protected get_topic(context: Context): this[\"topic\"] {\r\n        return context.data.topic;\r\n    }\r\n    protected set_topic(val: string, c: Context): boolean {\r\n        if (c.data.topic === val) return true;\r\n        TRANSACTION(this.get_name(c)+'.topic', ()=>{\r\n            SetFieldAction.new(c.data, 'topic', val, '', false);\r\n        }, c.data.topic, val)\r\n        return true;\r\n    }\r\n}\r\nRuntimeAccessibleClass.set_extend(DNamedElement, DValue);\r\nRuntimeAccessibleClass.set_extend(LNamedElement, LValue);\r\n\r\nexport type ValueDetail = {\r\n    value: LValue['value'];\r\n    rawValue: DValue['values'][0]; // PrimitiveType | Pointer<DObject> | Pointer<DEnumLiteral>\r\n    index: number;\r\n    hidden: boolean;\r\n};\r\nexport type SetValueAtPositionInfoType = {setMirage: boolean, isPtr: boolean, type: LValue['type'], instanceof: LValue['instanceof'], isContainment: boolean, fatherList: LValue['fatherList']};\r\n\r\nexport type WModelElement = getWParams<LModelElement, DModelElement>;\r\nexport type WModel = getWParams<LModel, DModel>;\r\nexport type WValue = getWParams<LValue, DValue>;\r\nexport type WNamedElement = getWParams<LNamedElement, DNamedElement>;\r\nexport type WObject = getWParams<LObject, DObject>;\r\nexport type WEnumerator = getWParams<LEnumerator, DEnumerator>;\r\nexport type WEnumLiteral = getWParams<LEnumLiteral, DEnumLiteral>;\r\nexport type WAttribute = getWParams<LAttribute, DAttribute>;\r\nexport type WReference = getWParams<LReference, DReference>;\r\nexport type WStructuralFeature = getWParams<LStructuralFeature, DStructuralFeature>;\r\nexport type WClassifier = getWParams<LClassifier, DClassifier>;\r\nexport type WDataType = getWParams<LDataType, DDataType>;\r\nexport type WClass = getWParams<LClass, DClass>;\r\nexport type WParameter = getWParams<LParameter, DParameter>;\r\nexport type WOperation = getWParams<LOperation, DOperation>;\r\nexport type WPackage = getWParams<LPackage, DPackage>;\r\nexport type WTypedElement = getWParams<LTypedElement, DTypedElement>;\r\nexport type WAnnotation = getWParams<LAnnotation, DAnnotation>;\r\n// export type WJavaObject = getWParams<LJavaObject, DJavaObject>;\r\nexport type WMap = getWParams<LMap, DMap>;\r\nexport type WFactory_useless_ = getWParams<LFactory_useless_, DFactory_useless_>;\r\n\r\nDModelElement.cname = 'DModelElement';\r\nLModelElement.cname = 'LModelElement';\r\nDAnnotationDetail.cname = 'DAnnotationDetail';\r\nLAnnotationDetail.cname = 'LAnnotationDetail';\r\nDAnnotation.cname = 'DAnnotation';\r\nLAnnotation.cname = 'LAnnotation';\r\nDNamedElement.cname = 'DNamedElement';\r\nLNamedElement.cname = 'LNamedElement';\r\nDTypedElement.cname = 'DTypedElement';\r\nLTypedElement.cname = 'LTypedElement';\r\nDClassifier.cname = 'DTypedElement';\r\nLClassifier.cname = 'LTypedElement';\r\nDPackage.cname = 'DPackage';\r\nLPackage.cname = 'LPackage';\r\nDOperation.cname = 'DOperation';\r\nLOperation.cname = 'LOperation';\r\nDParameter.cname = 'DParameter';\r\nLParameter.cname = 'LParameter';\r\nDClass.cname = 'DClass';\r\nLClass.cname = 'LClass';\r\n// ClassReferences.cname = 'ClassReferences';\r\nDDataType.cname = 'DDataType';\r\nLDataType.cname = 'LDataType';\r\nDStructuralFeature.cname = 'DStructuralFeature';\r\nLStructuralFeature.cname = 'LStructuralFeature';\r\nDReference.cname = 'DReference';\r\nLReference.cname = 'LReference';\r\nDAttribute.cname = 'DAttribute';\r\nLAttribute.cname = 'LAttribute';\r\nDEnumLiteral.cname = 'DEnumLiteral';\r\nLEnumLiteral.cname = 'LEnumLiteral';\r\nDModelM1.cname = 'DModelM1';\r\nLModelM1.cname = 'LModelM1';\r\nDEnumerator.cname = 'DEnumerator';\r\nLEnumerator.cname = 'LEnumerator';\r\nDModel.cname = 'DModel';\r\nLModel.cname = 'LModel';\r\nDMap.cname = 'DMap';\r\nLMap.cname = 'LMap';\r\nDObject.cname = 'DObject';\r\nLObject.cname = 'LObject';\r\nDValue.cname = 'DValue';\r\nLValue.cname = 'LValue';\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\pages\\index.ts",[],"C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\common\\Dummy.ts",["1313","1314","1315"],"import {\r\n    DeleteElementAction,\r\n    DState,\r\n    GObject,\r\n    Log,\r\n    LPointerTargetable, Pointer,\r\n    SetFieldAction, U,\r\n    SetRootFieldAction, TRANSACTION, DPointerTargetable, LViewPoint\r\n} from '../joiner';\r\nimport {Dependency} from \"../joiner/types\";\r\n\r\nexport class Dummy {\r\n    protected static get_dependencies(context: any): () => Dependency[] {\r\n        const data = context.data;\r\n        const dependencies: Dependency[] = [];\r\n        const ret = () => {\r\n            for (let pointedBy of data.pointedBy) {\r\n                const raw = pointedBy.source.split('.');\r\n                let root = raw[0];\r\n                const obj = raw[1] || '';\r\n                let field = raw[2] || '';\r\n\r\n                // Delete chars from end that are not in [azAZ].\r\n                const regex = /[^a-zA-Z]+$/;\r\n                root = root.replace(regex, '');\r\n                field = field.replace(regex, '');\r\n                // damiano: this is likely to cause a bug for sure somewhere when a key ends with \"s\" but is not an array. keep in mind when naming variables.\r\n                let op: ''|'-=' = (field && field.endsWith('s')) ? '-=' : '';\r\n                if(!field && root.endsWith('s')) op = '-=';\r\n\r\n                const dependency: Dependency = {root: root  as keyof DState, obj, field: field as keyof DPointerTargetable, op};\r\n                if(!dependencies.includes(dependency)) dependencies.push(dependency);\r\n            }\r\n            return dependencies\r\n        }\r\n        return ret;\r\n    }\r\n    static get_delete(thiss: any, context: any): () => void {\r\n        const lData: LPointerTargetable & GObject = context.proxyObject;\r\n        const dData = context.data;\r\n        const dependencies = Dummy.get_dependencies(context)();\r\n        console.log('get_delete '+(dData as any).name, {dData, dependencies});\r\n\r\n        const ret = () => {\r\n            console.log('0 get_delete() '+(dData as any)?.name, {dData, cn:dData?.className, dependencies});\r\n            SetRootFieldAction.new('_lastSelected', undefined, '');\r\n            const dataID = dData.id as any;\r\n\r\n            if (dData.id.indexOf('Pointer_View') !== -1 ) return; // cannot delete default views/viewpoints\r\n            if (dData.__readonly) return;\r\n            console.log('1 get_delete() '+(dData as any)?.name, {dData, cn:dData?.className, dependencies});\r\n            for (let child of lData.children) {\r\n                child.delete();\r\n                // todo: if a m1-dvalue which conforms to a m2-reference with \"containment\" is deleted, need to delete also target.\r\n                // maybe better to do through override?\r\n                // child.node?.delete();\r\n            }\r\n\r\n            console.log('2 get_delete() '+(dData as any)?.name, {dData, cn:dData?.className});\r\n            // those 2 are exceptions because the pointer is a key in an object instead of a normal value as a field or array member.\r\n            switch (dData.className) {\r\n                case 'DViewElement':\r\n                    SetFieldAction.new(dData.father, 'subViews', dataID, '-=', false);\r\n                    break;\r\n                case 'DViewPoint':\r\n                    let projectid = (lData as LViewPoint)?.project?.id;\r\n                    Log.eDevv('cannot find project id while deleting a viewpoint', {dData, context, dependencies});\r\n                    if (projectid) SetFieldAction.new(projectid, 'viewpoints', dataID, '-=', false);\r\n                    break;\r\n            }\r\n\r\n            for (let dependency of dependencies) {\r\n                const root: keyof DState = dependency.root;\r\n                if(root !== 'idlookup') {\r\n                    SetRootFieldAction.new(root, dataID, '-=', false);\r\n                    continue;\r\n                }\r\n                const pointer: Pointer<any>|null = dependency.obj; // the pointing element (delete a DClass => DAttribute)\r\n                const field = dependency.field;\r\n                const lObj: any = LPointerTargetable.wrap(pointer);\r\n                if (!pointer || !lObj) continue;\r\n                const dObj: any = lObj.__raw;\r\n                switch (field as string) {\r\n                    /* on '-=' pointedby would be removed from the element we are deleting, so it is irrelevant */\r\n                    default:\r\n                        Log.eDevv('Unexpected case in delete:', field, lData);\r\n                        break;\r\n                    case 'metamodels':\r\n                        console.log('mm filter', {newmm:dObj.metamodels.filter((id: Pointer) => id !== dataID), oldmm:dObj.metamodels, dataID})\r\n                        lObj.metamodels = dObj.metamodels.filter((id: Pointer) => id !== dataID);\r\n                        break;\r\n                    case 'dependencies':\r\n                        lObj.dependencies = dObj.dependencies.filter((id: Pointer) => id !== dataID);\r\n                        break;\r\n                    case 'values':\r\n                        lObj.values = dObj.values.filter((o: any) => o !== dataID);\r\n                        break;\r\n                    case 'type':\r\n                        switch (dObj.className) {\r\n                            case 'DAttribute': lObj.type = 'Pointer_ESTRING'; break;\r\n                            case 'DReference': case 'DOperation':\r\n                                // would be nice to set dObj.extends[0] instead but i cannot tell if it was deleted too.\r\n                                // dobj.father instead is safe as even if it's deleted it does not matter as it will delete the feature together\r\n                                lObj.type = dObj.father;\r\n                                break;\r\n                        }\r\n                        break;\r\n                    case 'model':\r\n                        if(dObj.className === 'DPackage') {\r\n                            lObj.father[field] = lObj.father.__raw[field].filter((id: any) => id != dataID);\r\n                            continue;\r\n                        } else {\r\n                            /* Node is deleted in nodes.delete() */\r\n                            continue;\r\n                        }\r\n                    case 'packages':\r\n                    case 'subpackages':\r\n                    case 'classifiers':\r\n                    case 'enumerators':\r\n                    case 'literals':\r\n                    case 'classes':\r\n                    case 'attributes':\r\n                    case 'references':\r\n                    case 'operations':\r\n                    case 'parameters':\r\n                    case 'features':\r\n                    case 'instances':\r\n                    case 'objects':\r\n                        lObj[field] = dObj[field].filter((id: any) => id != dataID);\r\n                        continue;\r\n                    case 'instanceof':\r\n                        lObj.delete();\r\n                        continue;\r\n                    /* No operations required (children) */\r\n                    case 'father':\r\n                    case 'subElements':\r\n                    case 'annotations':\r\n                        break;\r\n                }\r\n                /*\r\n                if ((root === 'idlookup') && obj && field) {\r\n                    console.log('Delete', `SetFieldAction.new('${obj}', '${field}', '${val}', '${op}');`, {dependency});\r\n                    SetFieldAction.new(obj, field, val, op, false);\r\n                } else {\r\n                    console.log('Delete', `SetRootFieldAction.new('${root}', '${val}', '${op}');`);\r\n                    SetRootFieldAction.new(root, val, op, false);\r\n                }\r\n                */\r\n            }\r\n\r\n            console.log('3 get_delete() '+(dData as any)?.name, {dData, cn:dData?.className});\r\n            if (lData.nodes) lData.nodes.map((node: any) => node.delete());\r\n            console.log('4 get_delete() '+(dData as any)?.name, {dData, cn:dData?.className});\r\n            SetRootFieldAction.new('ELEMENT_DELETED', dataID, '+=', false); // here no need to IsPointer because it only affects Transient stuff\r\n            //U.sleep(1).then(() => SetRootFieldAction.new(`idlookup.${dataID}`, undefined, '', false));\r\n            //SetRootFieldAction.new(`idlookup.${dataID}`, undefined, '', false);\r\n            console.log('5 get_delete() '+(dData as any)?.name, {dData, cn:dData?.className});\r\n            DeleteElementAction.new(dData.id);\r\n        };\r\n        console.log('00 get_delete '+(dData as any)?.name, {dData, cn:dData?.className});\r\n        return () => {\r\n            console.log('00 get_delete() '+(dData as any)?.name, {dData, cn:dData?.className});\r\n            TRANSACTION('delete ' + thiss.get_name(context), ()=>{\r\n                console.log('0000 get_delete '+(dData as any)?.name, {dData, cn:dData?.className}); ret(); })\r\n        }\r\n    }\r\n}\r\n","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\data\\storage.ts",[],"C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\common\\SimpleTree.ts",["1316","1317"],"import {Dictionary, GObject, Log, U} from \"../joiner\";\r\n\r\n\r\n/* problema: se creo una key per ordinare l'albero e trovare \"of\" in O(log n), allora perdo l'ordinamento arbitrario di sottoalberi = sottoclassi a prescindere dai nomi.\r\n   potrei fare un dizionario di alberi, 1 albero per ogni dclass e lclass, con sottoelementi\r\n    */\r\n\r\n// not binary, not rb tree, not balanced, just a tree\r\n// it is N-ary\r\n// ma probabilmente non dovrei usare affatto un albero, ma fare un dizionario per ogni classe con cosa estende direttamente\r\n// e uno con cosa estende direttamente e indirettamente popolato automaticamente in n*logn una volta e fine\r\n// navigando superclass\r\n\r\n// B.superclass = [a1, a2] --- > a1.pushdirectsubclass(b), a2 same.  poi se a1 estende c, c.pushindirectsubclass(b)... e si risale da b finchè ci sono superclassi (logn) volte, fatto per tutte le n classi\r\n// each node have a \"node<T>\" value and a subtree with all subelements.\r\n// iterable with for...of with width iterator (not depth)\r\nexport class SimpleTree<T extends GObject> {\r\n    subelements: SimpleTree<T>[];\r\n    node: T; // can be undef, if root was an array instead of a single element.\r\n    // the nodes containing the rooots will be the childrens instead, as if they are N trees\r\n    // with a fake node joining them in a single one\r\n    // up: SimpleTree<T>; maybe do this too\r\n\r\n    [Symbol.iterator] = function*(this:SimpleTree<T>) {\r\n    // [Symbol.iterator]: Generator<number, string, boolean> = function*() {\r\n    // [Symbol.iterator]: Generator<number, string, boolean>= () => {\r\n    // [Symbol.iterator] () {\r\n        yield this;\r\n        let fifo = this.subelements;\r\n        while (fifo.length) {\r\n            let nextLevel = [];\r\n            for (let subtree of fifo) {\r\n                yield subtree;\r\n                nextLevel.push(...subtree.subelements);\r\n            }\r\n            //@ts-ignore\r\n            // console.log(\"fifo -> next level\", fifo.map(f=>f?.node?.cname), nextLevel.map(f=>f?.node?.cname));\r\n            fifo = nextLevel;\r\n        }\r\n    }\r\n\r\n    getiIsSubElementMatrix(namekey: keyof T): Dictionary<string, Dictionary<string, boolean>>{\r\n        let ret: Dictionary<string, Dictionary<string, boolean>> = {}// matrix name x name telling if A extends B\r\n        for (let o of this) { // O(N^2), but optimal for this task, as the matrix size is O(N^2) as well\r\n            let name = o.node[namekey];\r\n            if (!name) Log.ee(\"missing key property  in tree node: \", {tree: this, node:o.node, namekey});\r\n            ret[name] = {};\r\n            // if (o === this) continue;\r\n            for (let subo of o) {\r\n                let subname = subo.node[namekey];\r\n                if (!subname) { console.log(\"skipped\"); continue; }\r\n                ret[name as string][subname as string] = true;\r\n            }\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    public add(e: T, childKey?: keyof T, loopdetector?: WeakMap<T, boolean>): SimpleTree<T> | undefined{\r\n        if (loopdetector) {\r\n            if (loopdetector.get(e)) {\r\n                Log.eDev(e.cname.indexOf(\"GraphVertex\") !== 1,\r\n                    \"A constructor is extending 2 different classes, or there is a loop in Tree constructor parameter.\",\r\n                    \"GraphVertex should be the only class doing that currently\",\r\n                    {e, cname:e.cname, childKey, loopdetector});\r\n                return;\r\n            }\r\n            loopdetector.set(e, true);\r\n        }\r\n        let subtree =  new SimpleTree<T>(e, childKey, loopdetector);\r\n        this.subelements.push(subtree);\r\n        return subtree; }\r\n\r\n    getSubtree(e: T): SimpleTree<T> | undefined {\r\n        for (let t of this) { if (t.node == e) return t; }\r\n        return undefined; }\r\n\r\n    // childkey: adds subobjects found in \"roots\" parameters as nodes<T> in the tree\r\n    // comparison: tells if a node comes first or after another, example: (a, b) => a.name.toUpperCase() < b.name.toUpperCase()\r\n    constructor(roots: GObject | GObject[], childKey?: keyof T, loopdetector?: WeakMap<T, boolean>) {\r\n        // if arr, add N roots as subelements, and delegate actual subelements of the root to subtree constructors\r\n        if (!loopdetector) loopdetector = new WeakMap();\r\n        /*(this as any)[Symbol.iterator] = function *(){\r\n            yield this;\r\n            let fifo = this.subelements;\r\n            while (fifo.length) {\r\n                let nextLevel = [];\r\n                for (let subtree of fifo) {\r\n                    yield subtree;\r\n                    nextLevel.push(subtree);\r\n                }\r\n                fifo = nextLevel;\r\n            }\r\n        }*/\r\n\r\n        //@ts-ignore\r\n        this.debug = roots.cname;\r\n        this.subelements = [];\r\n        if (Array.isArray(roots)) {\r\n            this.node = undefined as any;\r\n            for (let e of roots) {\r\n                if (!e) continue;\r\n                this.add(e as T, childKey, loopdetector);\r\n            }\r\n        }\r\n        // if not arr, add immediate subelements of root\r\n        else {\r\n            this.node = roots as T;\r\n            if (!childKey) return;\r\n            let child: T | T[] = this.node[childKey];\r\n            if (Array.isArray(child)) {\r\n                for (let c of child) this.add(c, childKey, loopdetector);\r\n            }\r\n            else this.add(child, childKey, loopdetector);\r\n        }\r\n    }\r\n\r\n\r\n}\r\n","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\DSL\\DSL.ts",[],"C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\components\\collaborative\\Collaborative.ts",[],"C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\redux\\VersionFixer.ts",["1318","1319","1320","1321","1322","1323","1324","1325","1326","1327","1328","1329","1330","1331","1332","1333","1334","1335","1336","1337","1338"],"import {\r\n    CoordinateMode,\r\n    Defaults,\r\n    Dictionary, DocString, DPointerTargetable, DReference,\r\n    DState, DStructuralFeature,\r\n    DViewElement,\r\n    EdgeBendingMode,\r\n    EdgeGapMode,\r\n    GObject,\r\n    GraphPoint,\r\n    GraphSize, LClass,\r\n    Log, LPointerTargetable, LState, Pointer, RuntimeAccessible, RuntimeAccessibleClass, store,\r\n    U\r\n} from \"../joiner\";\r\nimport {NumberControl, PaletteControl, PathControl, StringControl} from \"../view/viewElement/view\";\r\n\r\n/*\r\n                                    TODO for every update: check the VersionFixer.help() function\r\n*/\r\n\r\n@RuntimeAccessible('VersionFixer')\r\nexport class VersionFixer {\r\n    public static cname = 'VersionFixer';\r\n    private static versionAdapters: Dictionary<number/*version*/, {n: number, f:(s: DState)=>DState}> = VersionFixer.setup();\r\n    private static highestVersion: number = 0; // automatically updated from updater function names\r\n    private static prefix: string = '__jodel_versioning_';\r\n    public static help(){\r\n        console.clear();\r\n        let i: number  = 1;\r\n\r\n        console.log(`\r\nBefore deploying a new version you should:\r\n\r\n${i++}) Update changelog\r\n\r\n${i++}) make a separate build subfolder (so you can switch versions)\r\n\r\n${i++}) build a new empty versioning function with signature like: private ['2.1 -> 2.3'](s: DState): DState\r\n        fill this function in a way that translates from the state shape of the old version, to the state shape of the new one\r\n   \r\n        `);\r\n\r\n\r\n\r\n        // DEPRECATED stuff\r\n        false && console.log(`\r\nBefore deploying a new version you should:\r\n\r\n${i++}?) ONLY IF IT'S FIRST TIME;\r\n   run DState.registerFirstTimeOnly() in the deploy version and export the localStorage variables starting with ${VersionFixer.prefix} to the dev version.\r\n   or call it in dev version after having temporarly undone the pending updates if possible, otherwise next steps might fail.\r\n   \r\n${i++}?) ONLY IF there are entirely new kinds of D-objects or optional new sub-structures in D-objects (like View.palette), update buildVersionSignature() method\r\n \r\n\r\n${i++}) build a new empty versioning function with signature: private ['2.1 -> 2.3'](s: DState): DState\r\n\r\n${i++}) in DState update DState.version.n (leave date and conversionList unchanged)\r\n\r\n${i++}) open a new empty project (no models no metamodels)\r\n   to find out what changed in the state between version without risking human error, i made an automatic detection.\r\n   call VersionFixer.checkVersionChanges() in browser console to see what changed need conversion in the function (i would save the result as comment inside the func)\r\n\r\n${i++}) fill the empty function of step (1), in a way that translates from the state shape of the old version, to the state shape of the new one\r\n\r\n${i++}) only after the transition function is complete, call VersionFixer.registerNewVersion();\r\n   it will both validate the version update function and store the new version as baseline.\r\n   (needs to be done last because checkVersionChanges will stop working until a new version is ready)\r\n   \r\nBEWARE: this approach cannot detect changes of valid values where the type did not change. eg if view.appliableTo = 'string' change his valid string values but not his type;\r\neverytime you put hands into a D-Object shape or valid values, you should document them to be able to write a conversion function later on.\r\n        `);\r\n    }\r\n    public static get_highestversion(): number{\r\n        if (VersionFixer.highestVersion === 0) VersionFixer.setup();\r\n        return VersionFixer.highestVersion;\r\n    }\r\n\r\n    private static setup(): (typeof VersionFixer)[\"versionAdapters\"]{\r\n        VersionFixer.versionAdapters = {};\r\n        const errormsg = (k: string)=>\"Version auto-updater have a updater registered incorrectly: \\\"\" + k + \"\\\", please notify the developers.\"\r\n        let staticKeys = [] as string[];// no need for them Object.getOwnPropertyNames(VersionFixer);\r\n        let instanceKeys = Object.getOwnPropertyNames(VersionFixer.prototype); // object.keys does not list not-enumarable stuff (like class funcs)\r\n        let allKeys = [...staticKeys, ...instanceKeys];\r\n        for (let k of allKeys){\r\n            switch(k){\r\n                case 'constructor': case 'd': case 'className':\r\n                case 'prefix': case 'highestVersion': case 'versionAdapters':\r\n                case 'get_highestversion':\r\n                case 'staticClassName': case 'cname': case 'subclasses':\r\n                case 'help': case 'setup': case 'update': continue;\r\n            }\r\n            let [froms, tos] = k.split(' -> ');\r\n            Log.exDev(!froms?.length || !tos?.length, errormsg(k));\r\n            let from = +froms; let to = +tos;\r\n            Log.exDev(isNaN(from) || isNaN(to), errormsg(k));\r\n            Log.exDev(!!VersionFixer.versionAdapters[from], \"duplicate version adapter from \\\"\"+from+\"\\\", please notify the developers.\")\r\n            VersionFixer.highestVersion = Math.max(VersionFixer.highestVersion, to);\r\n            VersionFixer.versionAdapters[from] = {n:to, f: (VersionFixer.prototype as any)[k]}\r\n        }\r\n        return VersionFixer.versionAdapters;\r\n    }\r\n\r\n    public static update(s: DState): DState{\r\n        if (!VersionFixer.versionAdapters) VersionFixer.setup();\r\n        if (!s.version) s.version = {n: 2.1, date:\"_reconverted\", conversionList:[0]};\r\n        let prevVer = s.version.n || 0;\r\n        let currVer = prevVer;\r\n        let singleton = new VersionFixer();\r\n        while (currVer !== VersionFixer.highestVersion) {\r\n            Log.exDev(!VersionFixer.versionAdapters[currVer], \"missing version adapter from \\\"\"+ currVer+\"\\\", please notify the developers.\",\r\n                {adapers: VersionFixer.versionAdapters, curr: VersionFixer.versionAdapters[currVer]});\r\n            console.log('versionfixer update pre', {prevVer, currVer, entry: VersionFixer.versionAdapters[currVer]});\r\n            let {n, f} = VersionFixer.versionAdapters[currVer];\r\n            s.version.conversionList = [...s.version.conversionList, currVer];\r\n            s = f.call(singleton, s);\r\n            currVer = s.version.n = n || 0;\r\n            console.log('versionfixer update post', {prevVer, currVer, n});\r\n            //Log.exDev(currVer !== n, \"version updater updated to incorrect target versionn \\\"\"+prevVer+\"\\\" -> \\\"\"+n+\"\\\" , please notify the developers.\");\r\n            Log.exDev(currVer <= prevVer, \"version updater found loop at version \\\"\"+currVer+\"\\\", please notify the developers.\");\r\n            prevVer = currVer;\r\n        }\r\n        return s;\r\n    }\r\n\r\n\r\n    private d<D extends DPointerTargetable, L extends LPointerTargetable>(ptr: Pointer<D>, s: DState): D{\r\n        return s.idlookup[ptr] as any;\r\n        // {n}\r\n    }\r\n    private ['0 -> 2.1'](s: DState): DState {\r\n        s.version = {n: 2.1, date:\"_reconverted\", conversionList:[0]};\r\n        return s;\r\n    }\r\n    private ['2.1 -> 2.2'](s: DState): void {\r\n\r\n    }\r\n    private ['2.2 -> 2.201'](s: DState): DState {\r\n        // let ls: LState = LPointerTargetable.from(s); nope, avoid L-objects. actions would fire in present state instead of in parameter state\r\n        for (let c of (s.classs).map(p=> this.d(p, s))) {\r\n            c.isSingleton = !!c.isSingleton; // booleanize the undefined\r\n            c.sealed = [];\r\n            c.final = false;\r\n            c.rootable = undefined;\r\n        }\r\n        for (let c of Object.values(s.idlookup) as any[]) { if (c?.className && c.id && c.isCrossReference === undefined) c.isCrossReference = false; }\r\n        for (let c of (s.viewelements).map(p=> this.d(p, s))) { c.father = c.viewpoint; }\r\n        for (let c of (s.viewpoints).map(p=> this.d(p, s))) { c.cssIsGlobal = true; }\r\n        for (let c of (s.projects).map(p=> this.d(p, s))) { c.favorite = {}; c.description = ''; }\r\n        for (let c of (s.references).map(p=> this.d(p, s))) { if (c.composition === undefined) c.aggregation = !(c.composition = !!(c as any).containment); }\r\n        for (let c of (s.models).map(p=> this.d(p, s))) { if (c.dependencies === undefined) c.dependencies = []; }\r\n        for (let c of (s.attributes).map(p=> this.d(p, s))) {\r\n            c.derived = !!c.derived;\r\n            c.derived_write = undefined; // c.derived ? '' : undefined;\r\n            c.derived_read = undefined; // c.derived ? '' : undefined;\r\n        }\r\n\r\n        return s;\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n//deprecated stuff\r\n\r\n\r\n\r\n/*\r\npublic static checkVersionChanges(): GObject{\r\n    let lastVerName = localStorage.getItem(VersionFixer.prefix+'last');\r\n    let lastVerState = localStorage.getItem(VersionFixer.prefix+lastVerName);\r\n    let lastVersionSignature = JSON.parse(lastVerState || '{not:\"found\"}');\r\n    let newVersionSignature = this.buildVersionSignature();\r\n    return VersionFixer.checkVersionChanges_inner(lastVersionSignature, newVersionSignature);\r\n}\r\npublic static checkVersionChanges_inner(s1: DState, s2:DState): GObject{ return U.objectDelta(s1, s2, true); }\r\npublic static registerFirstTimeOnly(): void {\r\n    let newVersionSignature = VersionFixer.buildVersionSignature();\r\n    localStorage.setItem(VersionFixer.prefix+'last', ''+newVersionSignature.version.n);\r\n    localStorage.setItem(VersionFixer.prefix+''+newVersionSignature.version.n, JSON.stringify(newVersionSignature));\r\n}\r\n\r\npublic static registerNewVersion(): boolean {\r\n    let lastVerName = localStorage.getItem(VersionFixer.prefix+'last');\r\n    let prevVersionSignature: DState = JSON.parse(localStorage.getItem(VersionFixer.prefix+lastVerName) || '{not:\"found\"}') as any;\r\n    let newVersionSignature = VersionFixer.buildVersionSignature();\r\n    let updatedVersionSignature = this.update(prevVersionSignature);\r\n    let versionDiff: GObject = VersionFixer.checkVersionChanges_inner(updatedVersionSignature, newVersionSignature);\r\n    if (Object.keys(versionDiff).length !== 0) {\r\n        console.log(\"failed to save new version, the conversion function is not updating state properly.\",\r\n            {versionDiff, prevVersionSignature, newVersionSignature, updatedVersionSignature});\r\n        return false;\r\n    }\r\n    localStorage.setItem(VersionFixer.prefix+'last', ''+newVersionSignature.version.n);\r\n    localStorage.setItem(VersionFixer.prefix+''+newVersionSignature.version.n, JSON.stringify(newVersionSignature));\r\n    return true;\r\n}\r\nprivate static buildVersionSignature(): DState {\r\n    // purpose: save in state 1 of each D-objects with all the possible sub-objects in every possible structure shape\r\n    // values can be dummy but syntactical valid\r\n    //DState.new(); nope, i'm using current state, just call it from an empty project with no models.\r\n    DViewElement.new2(\"View\", \"jsx\", undefined,(d)=>{\r\n        d.appliableTo = 'Any';\r\n        d.subViews = {[\"Sample-fake-subView\"]: 3.5};\r\n        d.oclUpdateCondition = '(view: LViewElement) => { return false; } <--- as a string'\r\n        d.defaultVSize = new GraphSize(5,5,5,5);\r\n        d.palette = {\r\n            \"color\": {type:'color', value: [{r:0, g:0, b:0, a:0}]} as PaletteControl,\r\n            \"number\": {type:'number', value: 4, unit: 'px'} as NumberControl,\r\n            \"text\": {type:'text', value: 'stringa'} as StringControl,\r\n            \"path\": {type:'path', value: 'M 00 L 1 1 Z', x: '5', y: '10', options: [{k: 'optionnale', v:'option path M 0 0 L 5 5 Z'}]} as PathControl,\r\n        };\r\n        d.events = {[\"function name\"]: \"function body\"};\r\n        d.bendingMode = EdgeBendingMode.Bezier_QT;\r\n        d.edgeGapMode = EdgeGapMode.gap;\r\n        d.size = {[\"node or model Pointer\"]: new GraphSize(5,5,5,5)};\r\n        d.edgeStartOffset = new GraphPoint(5,5);\r\n        d.edgeEndOffset = new GraphPoint(5,5);\r\n        d.edgePointCoordMode = CoordinateMode.relativePercent;\r\n        d.edgeHeadSize = new GraphPoint(5,5);\r\n        d.edgeTailSize = new GraphPoint(5,5);\r\n    }, true, 'DViewElement');\r\n\r\n\r\n\r\n    return store.getState();\r\n}\r\n*/","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\iot\\IoT.ts",[],"C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\redux\\defaults\\views.ts",["1339","1340","1341"],"import {\r\n    DV,\r\n    DModel,\r\n    DViewElement,\r\n    DViewPoint,\r\n    Pointer,\r\n    DPackage,\r\n    DClass,\r\n    DEnumerator,\r\n    DAttribute,\r\n    DReference,\r\n    DOperation,\r\n    DEnumLiteral,\r\n    DObject,\r\n    DValue,\r\n    DParameter,\r\n    GraphSize,\r\n    CoordinateMode,\r\n    U\r\n} from '../../joiner';\r\nimport DSL from \"../../DSL/DSL\";\r\n\r\nvar nosize: GraphSize = {x:0, y:0, w:0, h:0, nosize:true} as any;\r\nvar defaultEdgePointSize: GraphSize = {x:0, y:0, w:5, h:5} as any;\r\nvar defaultVertexSize: GraphSize = {x:0, y:0, w:140.6818084716797, h:32.52840805053711} as any;\r\nvar defaultPackageSize = new GraphSize(0, 0, 400, 500);\r\n\r\nconst udLevel = 'ret.level = node.graph.state.level ?? 3\\n';\r\nconst udGrid = 'ret.grid = node.graph.state.grid ?? false\\n'\r\n\r\nconst udLevelG = 'ret.level = node.state.level ?? 3\\n';\r\nconst udGridG = 'ret.grid = node.state.grid ?? false\\n';\r\n\r\nconst udLevelPkg = udLevelG + 'ret.upperLevel = node.graph.state.level ?? 3\\n';\r\n\r\nclass DefaultViews {\r\n\r\n    static model(vp: DViewElement): DViewElement {\r\n        const view = DViewElement.new2(\r\n            'Model', DSL.parser(DV.modelView()), vp,(d)=> {\r\n                d.appliableTo = 'Graph';\r\n                d.appliableToClasses = [DModel.cname];\r\n                d.oclCondition = 'context DModel inv: true';\r\n                d.draggable = false; d.resizable = false;\r\n                d.palette = {\r\n                    'background-': U.hexToPalette('#fff'),\r\n                    'color-': U.hexToPalette('#123cd0', '#4b0082', '#ff0000', '#3191bb', '#3191bb')\r\n                };\r\n            }, false, 'Pointer_ViewModel');\r\n\r\n        view.css = `\r\n&, .Graph{\r\n  background-color: var(--background-1);\r\n  height: 100%;\r\n  width: -webkit-fill-available;\r\n}\r\n.edges {z-index: 101; position: absolute; top: 0; left: 0; height: 0; width: 0; overflow: visible; }\r\n.detail-level {\r\n    position: absolute;\r\n    right: -50px;\r\n    top: 50px;\r\n    display: flex;\r\n    transform: rotate(270deg);\r\n    &>div{\r\n        transform: rotate(90deg) translate(0, 100%);\r\n    }\r\n}\r\n\r\n/* stuff for subelements */\r\n[data-nodetype=\"GraphVertex\"] {\r\n  width: 50%;\r\n  height: 50%;\r\n}\r\n&,[data-nodetype]{\r\n  select, input{\r\n    background: inherit;\r\n    color: inherit;\r\n    &:empty{\r\n      font-style: italic;\r\n    }\r\n  }\r\n}\r\n[data-nodetype=\"Field\"] {\r\n  white-space: nowrap;\r\n}\r\n[data-nodetype=\"VoidVertex\"],\r\n[data-nodetype=\"Vertex\"],\r\n[data-nodetype=\"GraphVertex\"] {\r\n  &>*{ border: 0.1em solid #a3a3a3; }\r\n  &>.ui-resizable-handle{ border: none; }\r\n}\r\n&,[data-nodetype], [data-nodetype]>*{\r\n  /* for some reason focus does not work?? so this is a fallback but needs to be properly fixed */\r\n  overflow: hidden;\r\n  &.selected-by-me, &:has(.selected-by-me, .Edge), &:hover, &:active, &:focus-within, &:focus{\r\n    overflow: visible;\r\n    z-index: 100 !important;\r\n  }\r\n}\r\n.Edge{\r\n    overflow: visible;\r\n}\r\n\r\n/* level-specific rules */\r\n\r\n.model-0 {\r\n  height: 100%!important;\r\n  width: 100%!important;\r\n  display: flex;\r\n  justify-content: center;\r\n  align-items: center;\r\n}\r\n\r\n.metamodel {\r\n  position: absolute;\r\n  width: max-content;\r\n  height: max-content;\r\n  padding: 10px;\r\n  border: 1px solid var(--secondary)!important;\r\n  border-radius: var(--radius);\r\n}\r\n\r\n.model-1 {}\r\n.model-2 {}\r\n.model-3 {}\r\n\r\n.grid {\r\n    background-image: radial-gradient(silver 1px, transparent 0);\r\n    background-size: 15px 15px;\r\n    background-position: 10px 10px;\r\n}\r\n\r\n`;\r\n\r\n        view.usageDeclarations = '(ret) => {\\n' +\r\n            '// ** preparations and default behaviour here ** //\\n' +\r\n            'ret.node = node\\n' +\r\n            'ret.view = view\\n' +\r\n            '// custom preparations:\\n' +\r\n            'let packages = data && data.isMetamodel ? data.packages : [];\\n' +\r\n            'let suggestedEdges = data?.suggestedEdges || {};\\n' +\r\n            '// data, node, view are dependencies by default. delete them above if you want to remove them.\\n' +\r\n            '// add preparation code here (like for loops to count something), then list the dependencies below.\\n' +\r\n            // ¡ The element will update only if one of the listed dependencies has changed !\r\n            '// ** declarations here ** //\\n' +\r\n            'ret.firstPackage = packages[0]\\n'+\r\n            'ret.otherPackages = packages.slice(1)\\n'+\r\n            'ret.m1Objects = data && !data.isMetamodel ? data.allSubObjects : []\\n'+\r\n            'ret.refEdges = (suggestedEdges.reference || []).filter(e => !e.vertexOverlaps && e.sameGraph)\\n'+\r\n            'ret.extendEdges = (suggestedEdges.extend || []).filter(e => !e.vertexOverlaps && e.sameGraph)\\n'+\r\n            udLevelG + udGridG +\r\n            '}';\r\n        return view;\r\n    }\r\n\r\n    static package(vp: DViewElement): DViewElement {\r\n        const view = DViewElement.new2('Package', DV.packageView(), vp, (view)=>{\r\n            view.appliableToClasses = [DPackage.cname];\r\n            view.oclCondition = 'context DPackage inv: true';\r\n            view.appliableTo = 'GraphVertex';\r\n            view.palette = {'color-':  U.hexToPalette('#028012'), 'background-':  U.hexToPalette('#fff')};\r\n            view.css = `\r\n.package { background-color: var(--background-0); border-radius: 0.2em; border-left: 0.25em solid var(--color-1); }\r\n.package-children { height: -webkit-fill-available; width: -webkit-fill-available; }\r\n.summary { padding: 0.25rem; text-align: center; }\r\n.detail-level {\r\n    position: absolute;\r\n    right: -50px;\r\n    top: 50px;\r\n    display: flex;\r\n    transform: rotate(270deg);\r\n    &>div {\r\n        transform: rotate(90deg) translate(0, 100%);\r\n    }\r\n}`\r\n            view.defaultVSize = defaultPackageSize;\r\n            view.usageDeclarations = '(ret) => {\\n' +\r\n                '// ** preparations and default behaviour here ** //\\n' +\r\n                'ret.data = data\\n' +\r\n                'ret.node = node\\n' +\r\n                'ret.view = view\\n' +\r\n                '// custom preparations:\\n' +\r\n                '// data, node, view are dependencies by default. delete them above if you want to remove them.\\n' +\r\n                '// add preparation code here (like for loops to count something), then list the dependencies below.\\n' +\r\n                // ¡ The element will update only if one of the listed dependencies has changed !\r\n                '// ** declarations here ** //\\n' +\r\n                udLevelPkg +\r\n                '}';\r\n        }, false, 'Pointer_ViewPackage');\r\n        view.onDataUpdate = \"if (grid) {\\n   node.x = node.x - (node.x % 15);\\n   node.y = node.y - (node.y % 15);\\n}\";\r\n        return view\r\n    }\r\n\r\n    static class(vp: DViewElement): DViewElement {\r\n        const view = DViewElement.new2('Class', DV.classView(), vp, (view)=>{\r\n            view.appliableToClasses = [DClass.cname];\r\n            view.adaptWidth = true; view.adaptHeight = true;\r\n            view.appliableTo = 'Vertex';\r\n            view.oclCondition = 'context DClass inv: true';\r\n            view.palette = {'color-': U.hexToPalette('#f00', '#000', '#fff'), 'background-':  U.hexToPalette('#fff', '#eee', '#f00')};\r\n            view.css = `\r\n\r\n\r\n/* class */\r\n\r\n.class {\r\n    border-radius: var(--model-radius);\r\n    background: var(--model-background);\r\n    color:var(--model-color);\r\n\r\n    &>.header{\r\n        padding: 3px 6px;\r\n        white-space: pre;\r\n    }\r\n    .class-name{ \r\n        font-weight: bold; \r\n        color: var(--model-accent); \r\n    }\r\n    .bi {\r\n        color: var(--model-accent); \r\n        padding-right: 3px;\r\n    }\r\n    .class-children {\r\n        background-color: var(--model-background);\r\n        height: fit-content;\r\n        width: -webkit-fill-available;\r\n        &>*:last-child { padding-bottom: 0.125em; }\r\n    }\r\n    .abstract { font-style: italic; }\r\n    .summary { padding: 0.25rem; text-align: center; }\r\n}\r\n.abstract {\r\nborder-style: dotted!important;\r\nborder-color: silver!important;\r\n    }\r\n\r\n.class:hover {\r\n    box-shadow: var(--model-shadow);\r\n}\r\n            \r\n`;\r\n            view.defaultVSize = defaultVertexSize;\r\n            view.usageDeclarations = `(ret) => {\r\n    // ** preparations and default behaviour here ** //\r\n    // ret.data = data; intentionally excluded: i'm picking the used values individually reducing the re-renders.\r\n    ret.node = node\r\n    ret.view = view\r\n    // custom preparations:\r\n    // data, node, view are dependencies by default. delete them above if you want to remove them.\r\n    // add preparation code here (like for loops to count something), then list the dependencies below.\r\n    // ¡ The element will update only if one of the listed dependencies has changed !\r\n    // ** declarations here ** //\r\n    ret.attributes = data.attributes\r\n    ret.references = data.references\r\n    ret.operations = data.operations\r\n    ret.abstract = data.abstract\r\n    ret.interface = data.interface\r\n    ${udLevel}\r\n    ${udGrid}\r\n}`;\r\n            // view.events = {e1:\"(num) => {\\n\\tdata.name = num;\\n}\"}\r\n        }, false, 'Pointer_ViewClass');\r\n        view.onDataUpdate = \"if (grid) {\\n   node.x = node.x - (node.x % 15);\\n   node.y = node.y - (node.y % 15);\\n}\";\r\n\r\n        return view;\r\n    }\r\n\r\n    /* ENUM */\r\n\r\n    static enum(vp: DViewElement): DViewElement {\r\n        const view = DViewElement.new2('Enum', DV.enumeratorView(), vp, (view)=>{\r\n            view.appliableToClasses = [DEnumerator.cname];\r\n            view.adaptWidth = true; view.adaptHeight = true;\r\n            view.appliableTo = 'Vertex';\r\n            view.oclCondition = 'context DEnumerator inv: true';\r\n            view.palette = {'color-':  U.hexToPalette('#ffa500', '#000', '#fff'), 'background-':  U.hexToPalette('#fff', '#eee', '#f00')};\r\n//             view.css =  `\r\n// .enumerator {\r\n//     border-radius: 0.2em;\r\n//     border-left: 0.25em solid var(--color-1);\r\n//     background: var(--background-1);\r\n//     color:var(--color-2);\r\n//     &>.header{\r\n//         padding: 3px 6px;\r\n//         white-space: pre;\r\n//     }\r\n//     .enumerator-name { font-weight: bold; color: var(--color-1); }\r\n//     .enumerator-children {\r\n//         background-color: var(--background-2);\r\n//         height: fit-content;\r\n//         width: -webkit-fill-available;\r\n//         &>*:last-child { padding-bottom: 0.125em; }\r\n//     }\r\n//     .summary { padding: 0.25rem; text-align: center; }\r\n// }\r\n// `\r\n\r\n            view.css = `\r\n.enumerator {\r\n    border-radius: var(--radius);\r\n    background: white;\r\n    color:var(--model-color);\r\n    &>.header{\r\n        padding: 3px 6px;\r\n        white-space: pre;\r\n    }\r\n    .enumerator-name { font-weight: bold; color: var(--accent-secondary); }\r\n    .bi {\r\n        color: var(--accent-secondary);\r\n    }\r\n    .enumerator-children {\r\n        background-color: white; \r\n        height: fit-content;\r\n        width: -webkit-fill-available;\r\n        &>*:last-child { padding-bottom: 0.125em; }\r\n    }\r\n    .summary { padding: 0.25rem; text-align: center; }\r\n}\r\n\r\n.enumerator:hover {\r\n    box-shadow: 0 0 5px silver;\r\n}\r\n`\r\n            view.defaultVSize = defaultVertexSize;\r\n            view.usageDeclarations = `(ret) => {\r\n    // ** preparations and default behaviour here ** //\r\n    // ret.data = data; intentionally excluded: i'm picking the used values individually reducing the re-renders.\r\n    ret.node = node\r\n    ret.view = view\r\n    // custom preparations:\r\n    // data, node, view are dependencies by default. delete them above if you want to remove them.\r\n    // add preparation code here (like for loops to count something), then list the dependencies below.\r\n    // ¡ The element will update only if one of the listed dependencies has changed !\r\n    // ** declarations here ** //\r\n    ret.literals = data.literals\r\n    ${udLevel}\r\n}`;\r\n        }, false, 'Pointer_ViewEnum');\r\n        view.onDataUpdate = \"if (grid) {\\n   node.x = node.x - (node.x % 15);\\n   node.y = node.y - (node.y % 15);\\n}\";\r\n\r\n        return view;\r\n    }\r\n\r\n    /* ATTRIBUTE */\r\n\r\n    static attribute(vp: DViewElement): DViewElement {\r\n        const view = DViewElement.new2('Attribute', DV.attributeView(), vp, (view)=>{\r\n            view.appliableToClasses = [DAttribute.cname];\r\n            view.oclCondition = 'context DAttribute inv: true';\r\n            view.appliableTo = 'Field';\r\n            view.css = `\r\n.feature{\r\n    display: flex;\r\n    padding: 2px 5px;\r\n    select {\r\n        margin-left: auto;\r\n        width: max(33%, 75px);\r\n    }\r\n}`;\r\n        }, false, 'Pointer_ViewAttribute');\r\n        return view;\r\n    }\r\n\r\n    /* REFERENCE */\r\n\r\n    static reference(vp: DViewElement): DViewElement {\r\n        const view = DViewElement.new2('Reference', DV.referenceView(), vp, (view)=>{\r\n            view.appliableToClasses = [DReference.cname];\r\n            view.oclCondition = 'context DReference inv: true';\r\n            view.appliableTo = 'Field';\r\n            view.css = `\r\n.feature{\r\n    display: flex;\r\n    padding: 2px 5px;\r\n    select {\r\n        margin-left: auto;\r\n        width: max(33%, 75px);\r\n    }\r\n}`;\r\n        }, false, 'Pointer_ViewReference');\r\n        return view;\r\n    }\r\n\r\n    /* OPERATION */\r\n\r\n    static operation(vp: DViewElement): DViewElement {\r\n        const view = DViewElement.new2('Operation', DV.operationView(), vp, (view)=>{\r\n            view.appliableToClasses = [DOperation.cname];\r\n            view.oclCondition = 'context DOperation inv: true';\r\n            view.appliableTo = 'Field';\r\n            view.usageDeclarations = `(ret) => {\r\n    // ** preparations and default behaviour here ** //\r\n    ret.data = data\r\n    ret.node = node\r\n    ret.view = view\r\n    // custom preparations:\r\n    // data, node, view are dependencies by default. delete them above if you want to remove them.\r\n    // add preparation code here (like for loops to count something), then list the dependencies below.\r\n    // ¡ The element will update only if one of the listed dependencies has changed !\r\n    // ** declarations here ** //\r\n    ${udLevel}\r\n}`;\r\n            view.css = `\r\n.operation{\r\n    display: flex;\r\n    padding: 2px 5px;\r\n    select {\r\n        margin-left: auto;\r\n        width: max(33%, 75px);\r\n    }\r\n    .parameters{\r\n        background-color: var(--background-2);\r\n        left: 0;\r\n        top: 100%;\r\n        width: 100%;\r\n    }\r\n}`;\r\n        }, false, 'Pointer_ViewOperation');\r\n        return view;\r\n    }\r\n\r\n    /* PARAMETER */\r\n\r\n    static parameter(vp: DViewElement): DViewElement {\r\n        const view = DViewElement.new2('Parameter', DV.parameterView(), vp, (view)=>{\r\n            view.appliableToClasses = [DParameter.cname];\r\n            view.appliableTo = 'Field';\r\n        }, false, 'Pointer_ViewParameter');\r\n        view.css = `\r\n.parameter{\r\n    display: flex;\r\n    padding-left: 1em;\r\n    width: calc(100% - 1em);\r\n    .modifier{\r\n        width: 1ic;\r\n        text-align: center;\r\n    }\r\n}`\r\n        return view;\r\n    }\r\n\r\n    /* LITERAL */\r\n\r\n    static literal(vp: DViewElement): DViewElement {\r\n        const view: DViewElement = DViewElement.new2('Literal', DV.literalView(), vp, (view)=>{\r\n            view.appliableToClasses = [DEnumLiteral.cname];\r\n            view.oclCondition = 'context DEnumLiteral inv: true';\r\n            view.appliableTo = 'Field';\r\n            view.palette = {};\r\n            view.css = \"display: block;\";\r\n        }, false, 'Pointer_ViewLiteral');\r\n        return view;\r\n    }\r\n\r\n    /* OBJECT */\r\n\r\n    static object(vp: DViewElement): DViewElement {\r\n        const view = DViewElement.new2('Object', DV.objectView(), vp, (view)=>{\r\n            view.appliableToClasses = [DObject.cname];\r\n            view.adaptWidth = true; view.adaptHeight = true;\r\n            view.oclCondition = 'context DObject inv: true';\r\n            view.palette = {'color-':  U.hexToPalette('#f00', '#000', '#fff'), 'background-': U.hexToPalette('#fff', '#eee', '#f00')};\r\n\r\n            // view.css = '.object {border-radius: 0.2em; border-left: 0.25em solid var(--color-1); background: var(--background-1); color: var(--color-2);}\\n';\r\n            // view.css += '.object-name {font-weight: bold; color: var(--color-1);}\\n';\r\n            // view.css += '.object-children {background-color: var(--background-2); height: fit-content; width: -webkit-fill-available;}';\r\n\r\n            view.css = '.object {border-radius: var(--radius); background: white; color: var(--accent);}\\n';\r\n            view.css +='.object-name {padding: 10px; font-weight: 600; color: var(--accent);}\\n';\r\n            view.css += '.object-children {padding: 10px;background-color: white; height: fit-content; width: -webkit-fill-available;}';\r\n\r\n\r\n            view.defaultVSize = defaultVertexSize;\r\n            view.appliableTo = 'Vertex';\r\n            view.usageDeclarations = '(ret) => {\\n' +\r\n                '// ** preparations and default behaviour here ** //\\n' +\r\n                'ret.data = data\\n' +\r\n                'ret.node = node\\n' +\r\n                'ret.view = view\\n' +\r\n                '// data, node, view are dependencies by default. delete them above if you want to remove them.\\n' +\r\n                '// add preparation code here (like for loops to count something), then list the dependencies below.\\n' +\r\n                // ¡ The element will update only if one of the listed dependencies has changed !\r\n                '// ** declarations here ** //\\n' +\r\n                'ret.metaclassName = data.instanceof?.name || \\'Object\\'\\n' +\r\n                udLevel +\r\n                '}';\r\n        }, false, 'Pointer_ViewObject');\r\n        view.onDataUpdate = \"if (grid) {\\n   node.x = node.x - (node.x % 15);\\n   node.y = node.y - (node.y % 15);\\n}\";\r\n\r\n        return view;\r\n    }\r\n\r\n    /* SINGLETON OBJECT */\r\n\r\n    static singleton(vp: DViewElement): DViewElement {\r\n        const view = DViewElement.new2('Singleton', DV.singletonView(), vp, (view)=>{\r\n            view.appliableToClasses = [DObject.cname];\r\n            view.adaptWidth = false; view.adaptHeight = false;\r\n            view.jsCondition = 'return data.instanceof.isSingleton';\r\n            //view.oclCondition = 'context DObject inv: true';\r\n\r\n            //view.palette = {'color-':  U.hexToPalette('#f00', '#000', '#fff'), 'background-': U.hexToPalette('#fff', '#eee', '#f00')};\r\n\r\n            view.css = '.singleton {text-align: center; border: none; background-color: var(--accent); color: white; padding: 4px 30px; width: fit-content; border-radius: var(--radius);}\\n';\r\n            view.css += '.singleton::before {position: absolute; left: 10px; font-family: bootstrap-icons; content: \"\\\\F799\";}\\n';\r\n\r\n            view.defaultVSize = defaultVertexSize;\r\n            view.appliableTo = 'Vertex';\r\n            view.usageDeclarations = '(ret) => {\\n' +\r\n                '// ** preparations and default behaviour here ** //\\n' +\r\n                'ret.data = data\\n' +\r\n                'ret.node = node\\n' +\r\n                'ret.view = view\\n' +\r\n                '// data, node, view are dependencies by default. delete them above if you want to remove them.\\n' +\r\n                '// add preparation code here (like for loops to count something), then list the dependencies below.\\n' +\r\n                // ¡ The element will update only if one of the listed dependencies has changed !\r\n                '// ** declarations here ** //\\n' +\r\n                'ret.metaclassName = data.instanceof?.name || \\'Object\\'\\n' +\r\n                'ret.isSingleton = data.instanceof?.isSingleton || false\\n' +\r\n                udLevel +\r\n                '}';\r\n        }, false, 'Pointer_ViewSingleton');\r\n        view.onDataUpdate = \"if (grid) {\\n   node.x = node.x - (node.x % 15);\\n   node.y = node.y - (node.y % 15);\\n}\";\r\n\r\n        return view;\r\n    }\r\n\r\n    /* VALUE */\r\n\r\n    static value(vp: DViewElement): DViewElement {\r\n        const view = DViewElement.new2('Value', DV.valueView(), vp, (view)=>{\r\n            view.appliableToClasses = [DValue.cname];\r\n            view.oclCondition = 'context DValue inv: true';\r\n            view.palette = {};\r\n            view.css = `.value{\r\n    padding-right: 6px;\r\n    max-width: 300px;\r\n    min-width: 100%;\r\n    overflow:hidden;\r\n    &:hover, &:focus-within{ overflow: visible; }\r\n    /*.values_str{\r\n        maxWidth: 100px;\r\n    }*/\r\n}`;\r\n            view.appliableTo = 'Field';\r\n            view.usageDeclarations = '(ret) =>  {\\n' +\r\n                '// ** preparations and default behaviour here ** //\\n' +\r\n                'ret.node = node\\n' +\r\n                'ret.view = view\\n' +\r\n                '// data, node, view are dependencies by default. delete them above if you want to remove them.\\n' +\r\n                '// add preparation code here (like for loops to count something), then list the dependencies below.\\n' +\r\n                // ¡ The element will update only if one of the listed dependencies has changed !\r\n                '// ** declarations here ** //\\n' +\r\n                'ret.instanceofname = data.instanceof?.name\\n' +\r\n                'ret.valuesString = data.valuesString()\\n' +\r\n                'ret.typeString = data.typeString\\n' +\r\n                '}';\r\n        }, false, 'Pointer_ViewValue');\r\n        return view;\r\n    }\r\n    static edgepoint(vp: DViewElement): DViewElement{\r\n        let css = `.edgePoint{\r\n    border: 2px solid var(--border-1);\r\n    background: var(--background-1);\r\n    color: var(--color-1);\r\n    width: 100%;\r\n    height: 100%;\r\n    min-height: 15px;\r\n    min-width: 5px;\r\n    &:hover, &:focus-within, &:focus{\r\n        transform-origin: center;\r\n        transform: scale(1.3);\r\n    }\r\n}\r\n[hoverscale]:hover, [hoverscale]:focus-within, [hoverscale]:focus{\r\n    transform-origin: center;\r\n    transform: scale(var(--hover-scale));\r\n    &>[hoverscale]:hover, &>[hoverscale]:focus-within, &>[hoverscale]:focus{ transform: scale(1); }\r\n}\r\n\r\n`;\r\n        let usageDeclarations = \"(ret)=>{ // scope contains: data, node, view, constants, state\\n\" +\r\n            \"// ** preparations and default behaviour here ** //\\n\" +\r\n            \"ret.data = data\\n\" +\r\n            \"ret.node = node\\n\" +\r\n            \"ret.view = view\\n\" +\r\n            \"// data, node, view are dependencies by default. delete them above if you want to remove them.\\n\" +\r\n            \"// add preparation code here (like for loops to count something), then list the dependencies below.\\n\\n\" +\r\n            // ¡ The element will update only if one of the listed dependencies has changed !\r\n            \"// ** declarations here ** //\\n\" +\r\n            \"ret.edgestart = node.edge.start?.size+''\\n\" +\r\n            \"ret.edgeend = node.edge.end?.size+''\\n\" +\r\n            \"}\"\r\n        // edgePointView.edgePointCoordMode = CoordinateMode.relativePercent;\r\n        let view: DViewElement = DViewElement.new2('EdgePoint', DV.edgePointView(), vp, (d)=>{\r\n            d.appliableTo = 'EdgePoint';\r\n            d.resizable = false;\r\n            d.palette = {'color-':  U.hexToPalette('#000'), 'background-': U.hexToPalette('#fff'), 'border-':  U.hexToPalette('#000'), 'hover-scale':{type:'number', unit:'', value:1.3}};\r\n            d.css = css;\r\n            d.usageDeclarations = usageDeclarations;\r\n            d.edgePointCoordMode = CoordinateMode.absolute;\r\n            d.defaultVSize = defaultEdgePointSize;\r\n            // d.defaultVSize = new GraphSize(0, 0, 25, 25);\r\n        }, false, 'Pointer_ViewEdgePoint');\r\n        return view;\r\n    }\r\n\r\n    static anchor(vp: DViewElement): DViewElement {\r\n        let ret = DViewElement.new2('Anchors', DV.anchorJSX(), vp, (v) => {\r\n            v.isExclusiveView = false;\r\n            v.palette={'anchor-': U.hexToPalette('#77f', '#f77', '#007'),\r\n                'anchor-hover-': U.hexToPalette('#7f7', '#a44', '#070')};\r\n            v.usageDeclarations = \"(ret)=>{ // scope: data, node, view, state, \\n\" +\r\n                \"// ** preparations and default behaviour here ** //\\n\" +\r\n                \"// add preparation code here (like for loops to count something), then list the dependencies below.\\n\" +\r\n                \"// ** declarations here ** //\\n\" +\r\n                \"ret.anchors = (node && node.anchors || {});\\n\"+\r\n                \"ret.dragAnchor = node.events.dragAnchor; // @autogenerated, do not edit\\n\"+\r\n                \"ret.assignAnchor = node.events.assignAnchor; // @autogenerated, do not edit\\n\"+\r\n                \"}\";\r\n            v.events = {\r\n                dragAnchor: '(coords /*Point*/, anchorName /*string*/)=>{\\n' +\r\n                    '\\tconst updateAnchor = {};\\n'+\r\n                    '\\tupdateAnchor[anchorName] = coords;\\n'+\r\n                    '\\tnode.anchors=updateAnchor;\\n'+\r\n                    '}',\r\n                assignAnchor: '(anchorName /*string*/)=>{\\n' +\r\n                    '\\tnode.assignEdgeAnchor(anchorName);\\n'+\r\n                    '}'}\r\n            v.css = `\r\n.anchor.valid-anchor{\r\n    display:block;\r\n}\r\n\r\n.anchor{\r\n    display:none;\r\n    position: absolute;\r\n    background-color: var(--anchor-1);\r\n    outline: 2px solid var(--anchor-3);\r\n    transform: translate(-50%, -50%);\r\n    pointer-events: all;\r\n    cursor: crosshair;\r\n    \r\n    &:hover{\r\n        background-color: var(--anchor-hover-1);\r\n        outline: 2px solid var(--anchor-hover-3);\r\n    }\r\n    &.active-anchor{\r\n        background-color: var(--anchor-2);\r\n        &:hover{\r\n            background-color: var(--anchor-hover-2);\r\n        }\r\n    }\r\n}\r\n`\r\n        }, false, 'Pointer_ViewAnchors' );\r\n        return ret;\r\n    }\r\n}\r\n\r\nexport default DefaultViews;\r\n","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\graph\\graphElement\\graphElement.tsx",["1342","1343","1344","1345","1346","1347","1348","1349","1350","1351","1352","1353","1354","1355","1356","1357","1358","1359","1360","1361"],"import React, {Component, Dispatch, PureComponent, ReactElement, ReactNode,} from \"react\";\r\nimport {createPortal} from \"react-dom\";\r\nimport {connect} from \"react-redux\";\r\nimport './graphElement.scss';\r\nimport type {EdgeOwnProps} from \"./sharedTypes/sharedTypes\";\r\nimport {\r\n    GraphSize,\r\n    LGraph, MouseUpEvent, Point,\r\n    Pointers,\r\n    Selectors as Selectors_, Size, TRANSACTION, WGraph,\r\n    GraphDragManager, GraphPoint, Selectors, DNamedElement, DVoidEdge, LEdge, LPackage, LReference, LVoidEdge, LValue\r\n} from \"../../joiner\";\r\nimport {DefaultUsageDeclarations} from \"./sharedTypes/sharedTypes\";\r\n\r\nimport {EdgeStateProps, LGraphElement, store, VertexComponent,\r\n    CreateElementAction, DClass, Debug,\r\n    DEdge, DEnumerator,\r\n    DGraph,\r\n    DGraphElement,\r\n    Dictionary, DModel,\r\n    DModelElement, DObject,\r\n    DocString, DPackage,\r\n    DPointerTargetable,\r\n    DState,\r\n    DUser,\r\n    DV,\r\n    DViewElement,\r\n    EMeasurableEvents,\r\n    GObject,\r\n    GraphElementDispatchProps,\r\n    GraphElementOwnProps,\r\n    GraphElementReduxStateProps,\r\n    GraphElementStatee,\r\n    InOutParam,\r\n    JSXT, Keystrokes,\r\n    LClass,\r\n    LModelElement,\r\n    Log,\r\n    LPointerTargetable,\r\n    LViewElement,\r\n    MyProxyHandler,\r\n    Overlap,\r\n    Pointer,\r\n    RuntimeAccessible,\r\n    RuntimeAccessibleClass,\r\n    SetFieldAction,\r\n    SetRootFieldAction,\r\n    U,\r\n    UX,\r\n    windoww, transientProperties\r\n} from \"../../joiner\";\r\nimport {NodeTransientProperties, Pack1} from \"../../joiner/classes\";\r\n\r\n// const Selectors: typeof Selectors_ = windoww.Selectors;\r\n/*\r\nexport function makeEvalContext(view: LViewElement, state: DState, ownProps: GraphElementOwnProps, stateProps: GraphElementReduxStateProps): GObject {\r\n    let component = GraphElementComponent.map[ownProps.nodeid as Pointer<DGraphElement>];\r\n    let allProps = {...ownProps, ...stateProps};\r\n    let parsedConstants = stateProps.view._parsedConstants;\r\n    let evalContext: GObject = {\r\n        model: stateProps.data,\r\n        ...ownProps,\r\n        ...stateProps,\r\n        edge: (RuntimeAccessibleClass.extends(stateProps.node?.className, \"DVoidEdge\") ? stateProps.node : undefined),\r\n        state,\r\n        ownProps,\r\n        stateProps,\r\n        props: allProps,\r\n        component,\r\n        constants: parsedConstants,\r\n        // getSize:vcomponent?.getSize, setSize: vcomponent?.setSize,\r\n        ...parsedConstants,\r\n        // ...stateProps.usageDeclarations, NOT because they are not evaluated yet. i need a basic eval context to evaluate them\r\n    };\r\n    evalContext.__proto__ = windoww.defaultContext;\r\n    transientProperties.node[ownProps.nodeid as string].evalContext = evalContext;\r\n    return evalContext;\r\n}\r\n\r\nfunction setTemplateString(stateProps: InOutParam<GraphElementReduxStateProps>, ownProps: Readonly<GraphElementOwnProps>, state: DState): void {\r\n    //if (!jsxString) { this.setState({template: this.getDefaultTemplate()}); return; }\r\n    // sintassi: '||' + anything + (opzionale: '|' + anything)*N_Volte + '||' + jsx oppure direttamente: jsx\r\n    const view: LViewElement = stateProps.view; //data._transient.currentView;\r\n    // eslint-disable-next-line no-mixed-operators\r\n    const evalContext = makeEvalContext(view, state, ownProps, stateProps);\r\n    // Log.exDev(!evalContext.data, \"missing data\", {evalContext, ownProps, stateProps});\r\n\r\n    // const evalContextOld = U.evalInContext(this, constants);\r\n    // this.setState({evalContext});\r\n\r\n}*/\r\n\r\nfunction computeUsageDeclarations(component: GraphElementComponent, allProps: AllPropss, state: GraphElementStatee, lview: LViewElement): GObject {\r\n    // compute usageDeclarations\r\n    let udret: GObject = {__notInitialized: true};\r\n    const view: DViewElement = lview.__raw;\r\n    const vid: Pointer<DViewElement> = view.id;\r\n    const constants = transientProperties.view[vid].constants;\r\n    let UDEvalContext: GObject = {...allProps, ...constants, constants, component,\r\n        view:lview, // data and node are inherited through props, but view needs redefinition\r\n        usageDeclarations: undefined, stateProps: allProps, props:allProps, ownProps:allProps, state}//transientProperties.node[stateProps.nodeid].evalContext;\r\n/*\r\n*\r\n        \"constants\": true, \"usageDeclarations\": true,\r\n        \"component\": true,\r\n        \"htmlindex\": true,\r\n        \"state\": true, \"stateProps\": true, \"ownProps\": true,*/\r\n    if (!view.usageDeclarations) {\r\n        udret = {data: allProps.data, view, node: allProps.node};\r\n    } else try {\r\n        transientProperties.view[vid].UDFunction.call(UDEvalContext, UDEvalContext, udret);\r\n        // console.log(\"computing usage declarations: \", {f:transientProperties.view[vid].UDFunction, udret, UDEvalContext});\r\n    } catch (e: any) {\r\n        e.isSyntax = false;\r\n        udret = {data: allProps.data, view, node: allProps.node, __invalidUsageDeclarations: e};// \"@runtime:\" +e};\r\n        Log.ee(\"Invalid usage declarations on \" + view?.name, {e, str: view.usageDeclarations, view, data: allProps.data, stateProps: allProps});\r\n    }\r\n\r\n    transientProperties.node[allProps.nodeid].viewScores[vid].usageDeclarations = udret;\r\n    // do not merge to create jsx final context now, because if shouldcomponentupdate fails, i want to keep the OLD context for measurable events.\r\n    return udret;\r\n}\r\n\r\nlet debugcount = 0;\r\nlet maxRenderCounter = Number.POSITIVE_INFINITY;\r\nexport const lightModeAllowedElements = [DModel.cname, DPackage.cname, DClass.cname, DEnumerator.cname, DObject.cname];\r\n\r\nfunction getScores(ret: GraphElementReduxStateProps, ownProps: GraphElementOwnProps): NodeTransientProperties{\r\n    return Selectors.getAppliedViewsNew({data:ret.data, node: ret.node,\r\n        nid: ownProps.nodeid as string, pv: ownProps.parentViewId && DPointerTargetable.from(ownProps.parentViewId)});\r\n}\r\n\r\nconst countRenders = true;\r\n@RuntimeAccessible('GraphElementComponent')\r\nexport class GraphElementComponent<AllProps extends AllPropss = AllPropss, GraphElementState extends GraphElementStatee = GraphElementStatee>\r\n    extends Component<AllProps, GraphElementState>{\r\n    public static cname: string;\r\n    static all: Dictionary<number, GraphElementComponent> = {};\r\n    public static map: Dictionary<Pointer<DGraphElement>, GraphElementComponent> = {};\r\n    static defaultProps: Partial<GraphElementOwnProps> = GraphElementOwnProps.new();\r\n    static maxid: number = 0;\r\n    id: number;\r\n\r\n    public static defaultShouldComponentUpdate<AllProps extends GObject, State extends GObject, Context extends any>\r\n    (instance: React.Component, nextProps: Readonly<AllProps>, nextState: Readonly<State>, nextContext: Context) {\r\n        return (\r\n            !U.shallowEqual(instance.props, nextProps) ||\r\n            !U.shallowEqual(instance.state, nextState)\r\n        );\r\n    }\r\n\r\n    // requires data and node wrapping first\r\n    static mapViewStuff(state: DState, ret: GraphElementReduxStateProps, ownProps: GraphElementOwnProps) {\r\n        // let dnode: DGraphElement | undefined = ownProps?.nodeid && DPointerTargetable.from(ownProps.nodeid, state) as any;\r\n        // console.log(\"viewsss mapstate 3 \" + ret.node?.className + \" \" + ret.data?.name, {views:ret.views, vv:ret.view, ownProps, stateProps:{...ret}, thiss:this});\r\n        ret.parentviewid = ownProps.parentViewId;\r\n\r\n        const explicitView: Pack1<LViewElement> | string | undefined = ret.view || ownProps.view;\r\n        const explicitViews: (Pack1<LViewElement> | string | undefined)[] = ret.views || ownProps.views;\r\n\r\n        let scores: NodeTransientProperties = undefined as any;\r\n        let tn = transientProperties.node[ownProps.nodeid as string]; // tn === scores if getScore is called (getScore have a sideeffect)\r\n        if (!tn) transientProperties.node[ownProps.nodeid as string] = tn = new NodeTransientProperties();\r\n        if (explicitView) {\r\n            let idorname: string = Pointers.from(explicitView) || explicitView as any as string;\r\n            ret.view = tn.mainView = LPointerTargetable.fromD(Selectors.getViewByIDOrNameD(idorname, state) as DViewElement);\r\n\r\n        }\r\n        if (!ret.view) { // if view is not explicitly set or the assigned view is not found, match a new one.\r\n            if (!scores) scores = getScores(ret, ownProps);\r\n            ret.view = scores.mainView = LPointerTargetable.fromPointer((scores.mainView as any)?.id, state);\r\n            Log.w(!!explicitView, \"Requested main view \"+ownProps.view+\" not found. Another view got assigned: \" + ret.view?.__raw.name, {requested: ownProps.view, props: ownProps, state: ret});\r\n        }\r\n        if (!tn.validMainViews?.[0] || tn.validMainViews[0].id !== tn.mainView?.id) tn.validMainViews = [tn.mainView, ...(tn.validMainViews || [])];\r\n        // @ts-ignore\r\n        let vname: string = !ret.view && ownProps.view ? ' Check the manual assignment of props view={\"'+(ownProps.view?.name || ownProps.view) +'\"}' : '';\r\n        let pview: LViewElement|undefined = !ret.view ?  ret.node?.father?.view : undefined;\r\n        Log.ex(!ret.view, \"Could not find any view applicable to element.\" + vname + (pview ? ' in view \"'+pview.name+'\"' : ''),\r\n            {data:ret.data, props: ownProps, state: ret, scores: (ret as any).viewScores, nid: ownProps.nodeid, tn:transientProperties.node[ownProps.nodeid as any]});\r\n\r\n        if (explicitViews){\r\n            // ret.views = tn.stackViews = LPointerTargetable.fromArr(explicitView);\r\n            let views: LViewElement[] = [];\r\n            for (let v of explicitViews) {\r\n                let idorname: string = Pointers.from(v as DViewElement) || v as any as string;\r\n                let view: LViewElement = LPointerTargetable.fromD(Selectors.getViewByIDOrNameD(idorname, state) as DViewElement);\r\n                if (view) views.push(view);\r\n                else Log.ww(\"Requested decorative view \"+v+\" not found.\", {requested: v, idorname, props: ownProps, state: ret});\r\n            }\r\n            ret.views = tn.stackViews = views;\r\n        }\r\n        if (!ret.views) {\r\n            // if views is not explicitly set. (if some are not found, they are just missing by choice, will not replace)\r\n            if (!scores) {\r\n                scores = getScores(ret, ownProps);\r\n                ret.views = scores.stackViews;\r\n            }\r\n            else ret.views = scores.stackViews = LPointerTargetable.fromArr((scores.stackViews||[]).map((v:LViewElement)=>v?.id).filter(vid=>!!vid));\r\n        }\r\n        // console.log(\"viewsss mapstate 4 \" + ret.node?.className + \" \" + ret.data?.name, {views:ret.views, ownProps, stateProps: {...ret}, thiss:this});\r\n\r\n\r\n        ret.viewsid = Pointers.fromArr(ret.views) as Pointer<DViewElement>[];\r\n        ret.viewid = ret.view.id;\r\n\r\n        let dnode = ret.node?.__raw;\r\n        if (dnode) dnode.view = ret.viewid;\r\n        (ret as any).viewScores = tn; // debug only\r\n    }\r\n\r\n    static mapLModelStuff(state: DState, ownProps: GraphElementOwnProps, ret: GraphElementReduxStateProps): void {\r\n        // NB: Edge constructor might have set it from props.start, so keep the check before overwriting.\r\n        if (typeof ownProps.data === \"object\") { ret.dataid = (ownProps.data as any).id; }\r\n        else ret.dataid = ownProps.data as string | undefined;\r\n        ret.data = LPointerTargetable.wrap(ret.dataid) // forcing re-wrapping even if props was a dobject or lobject, because i want to get the latest version of it.\r\n\r\n        /*\r\n        const meid: string = (typeof ownProps.data === 'string' ? ownProps.data as string : (ownProps.data as any as DModelElement)?.id) as string;\r\n        // Log.exDev(!meid, \"model element id not found in GE.mapstatetoprops\", {meid, ret, ownProps, state});\r\n        ret.data = MyProxyHandler.wrap(meid, state);\r\n        // Log.ex(!ret.data, \"can't find model data:\", {meid, state, ownpropsdata:ownProps.data, ownProps});\r\n        */\r\n    }\r\n\r\n\r\n    static mapLGraphElementStuff(state: DState,\r\n                                 ownProps: GraphElementOwnProps,\r\n                                 ret: GraphElementReduxStateProps,\r\n                                 dGraphElementDataClass: typeof DGraphElement = DGraphElement,\r\n                                 isDGraph?: DGraph): void {\r\n        let nodeid: string = ownProps.nodeid as string;\r\n        let graphid: string = isDGraph ? isDGraph.id : ownProps.graphid as string;\r\n        let parentnodeid: string = ownProps.parentnodeid as string;\r\n        ret.nodeid = nodeid;\r\n        let tn = transientProperties.node[nodeid];\r\n        if (!tn) tn = transientProperties.node[nodeid] = new NodeTransientProperties();\r\n        // let data: Pointer<DModelElement, 0, 1, LModelElement> = ownProps.data || null;\r\n        // Log.exDev(!nodeid || !graphid, 'node id injection failed', {ownProps, data: ret.data, name:(ret.data as any)?.name || (ret.data as any)?.className}); /*\r\n        /*if (!nodeid) {\r\n            nodeid = 'nodeof_' + stateProps.data.id + (stateProps.view.storeSize ? '_' + stateProps.view.id : '') + '_1';\r\n            stateProps.nodeid = U.increaseEndingNumber(nodeid, false, false, id => !DPointerTargetable.from(id, state));\r\n            todo: quando il componente si aggiorna questo viene perso, come posso rendere permanente un settaggio di reduxstate in mapstatetoprops? o devo metterlo nello stato normale?\r\n        }*/\r\n\r\n        let graph: DGraph = DPointerTargetable.from(graphid, state) as DGraphElement as any; // se non c'è un grafo lo creo\r\n        if (!graph) {\r\n            // Log.exDev(!dataid, 'attempted to make a Graph element without model', {dataid, ownProps, ret, thiss:this});\r\n            if (ret.data) CreateElementAction.new(DGraph.new(0, ret.data.id, parentnodeid, graphid, graphid)); }\r\n        /*else {\r\n            graph = MyProxyHandler.wrap(graph);\r\n            Log.exDev(graph.__raw.className !== \"DGraph\", 'graph class is wrong', {graph: ret.graph, ownProps});\r\n        }*/\r\n        let dnode: DGraphElement = DPointerTargetable.from(nodeid, state) as DGraphElement;\r\n\r\n        // console.log('dragx GE mapstate addGEStuff', {dGraphElementDataClass, created: new dGraphElementDataClass(false, nodeid, graphid)});\r\n        if (!dnode && !DPointerTargetable.pendingCreation[nodeid]) {\r\n            /*\r\n            console.log(\"making node:\", {dGraphElementDataClass, nodeid, parentnodeid, graphid, dataid, ownProps, ret,\r\n                pendings: {...DPointerTargetable.pendingCreation}, pending:DPointerTargetable.pendingCreation[nodeid]});*/\r\n            // so this is called once, but createaction is triggered twice only for edgepoints? it works if i create it through console.\r\n            let dge;\r\n            /*\r\n            if (dGraphElementDataClass === DEdgePoint) { // made it same as dvertex\r\n                let initialSize = ownProps.initialSize;\r\n                dge = DEdgePoint.new(ownProps.htmlindex as number, dataid, parentnodeid, graphid, nodeid, initialSize);\r\n                ret.node =  MyProxyHandler.wrap(dge);\r\n            } else*/\r\n            if (dGraphElementDataClass === DEdge) {\r\n                // set start and end from ownprops;\r\n                let edgeOwnProps: EdgeOwnProps = ownProps as EdgeOwnProps;\r\n                let edgeStateProps: EdgeStateProps = ret as EdgeStateProps;\r\n                let startnodeid = LGraphElement.getNodeId(edgeOwnProps.start);\r\n                let endnodeid = LGraphElement.getNodeId(edgeOwnProps.end);\r\n                if (!startnodeid) {\r\n                    startnodeid = LGraphElement.getNodeId(ret.data);\r\n                }\r\n                edgeStateProps.start = LPointerTargetable.fromPointer(startnodeid)\r\n                edgeStateProps.end = LPointerTargetable.fromPointer(endnodeid);\r\n                Log.e(!startnodeid, \"Cannot create an edge without start node\", {startnodeid, data:ret.data, propsStart:edgeOwnProps.start});\r\n                Log.e(!endnodeid, \"Cannot create an edge without end node (yet)\", {endnodeid, data:ret.data, propsEnd:edgeOwnProps.end});\r\n                if (!startnodeid || !endnodeid) return;\r\n                let longestLabel = edgeOwnProps.label;\r\n                let labels = edgeOwnProps.labels;\r\n                // dge = DEdge.new(ownProps.htmlindex as number, ret.data?.id, parentnodeid, graphid, nodeid, startnodeid, endnodeid, longestLabel, labels);\r\n                let ddata = ret.data?.__raw;\r\n                dge = DEdge.new2(ddata?.id, parentnodeid, graphid, nodeid, startnodeid, endnodeid, (d: DEdge)=>{\r\n                    //d.longestLabel = longestLabel;\r\n                    //d.labels = labels;\r\n                    d.isReference = !!edgeOwnProps.isReference;\r\n                    if (edgeOwnProps.isValue !== undefined) d.isValue = !!edgeOwnProps.isValue;\r\n                    else d.isValue = !!(d.isReference && ddata && ddata.className === 'DValue');\r\n                    if (d.isValue) d.isReference = false;\r\n                    d.isDependency = !!edgeOwnProps.isDepencency;\r\n                    d.isExtend = !!edgeOwnProps.isExtend;\r\n                    let tn = (transientProperties.node[nodeid]);\r\n                    if (!tn) transientProperties.node[nodeid] = new NodeTransientProperties();\r\n                    tn.onDelete = edgeOwnProps.onDelete;\r\n                    tn.labels = labels;\r\n                    tn.longestLabel = longestLabel;\r\n                    d.zIndex = edgeOwnProps.htmlindex || 1;\r\n                    if (edgeOwnProps.anchorStart) d.anchorStart = edgeOwnProps.anchorStart;\r\n                    if (edgeOwnProps.anchorEnd) d.anchorEnd = edgeOwnProps.anchorEnd;\r\n                });\r\n                edgeStateProps.node = edgeStateProps.edge = MyProxyHandler.wrap(dge);\r\n            }\r\n            else {\r\n                let initialSize = ownProps.initialSize;\r\n                dge = dGraphElementDataClass.new(ownProps.htmlindex as number, ret.data?.id, parentnodeid, graphid, nodeid, initialSize);\r\n                if (!tn) transientProperties.node[nodeid] = new NodeTransientProperties();\r\n                tn.onDelete = ownProps.onDelete;\r\n                ret.node =  MyProxyHandler.wrap(dge);\r\n            }\r\n            // console.log(\"map ge2\", {nodeid: nodeid+'', dge: {...dge}, dgeid: dge.id});\r\n        }\r\n        else {\r\n            ret.node = MyProxyHandler.wrap(dnode);\r\n            if (dGraphElementDataClass === DEdge) (ret as EdgeStateProps).edge = ret.node as any;\r\n        }\r\n\r\n\r\n        if (ret.dataid) {\r\n            // set up transient model-> node map\r\n            let ta = transientProperties.modelElement[ret.dataid];\r\n            if (!ta) transientProperties.modelElement[ret.dataid] = {nodes: {}} as any;\r\n            ta.nodes[ownProps.nodeid as string] = ret.node;\r\n            ta.node = ret.node;\r\n        }\r\n\r\n\r\n    }\r\n\r\n    ////// mapper func\r\n    static mapStateToProps(state: DState, ownProps: GraphElementOwnProps, dGraphDataClass: (typeof DGraphElement | typeof DEdge) = DGraphElement, startingobj?: GObject): GraphElementReduxStateProps {\r\n        // console.log('dragx GE mapstate', {dGraphDataClass});\r\n        let ret: GraphElementReduxStateProps = (startingobj || GraphElementReduxStateProps.new()) as GraphElementReduxStateProps; // NB: cannot use a constructor, must be pojo\r\n        // console.log(\"viewsss mapstate 0 \" + ownProps.view + \" \" + ret.data?.name, {views:ret.views, ownProps, stateProps:{...ret}, thiss:this});\r\n\r\n        GraphElementComponent.mapLModelStuff(state, ownProps, ret);\r\n        if (Debug.lightMode && (!ret.data || !(lightModeAllowedElements.includes(ret.data.className)))){\r\n            return ret;\r\n        }\r\n        // console.log(\"map ge\", {ownProps, ret, state});\r\n        GraphElementComponent.mapLGraphElementStuff(state, ownProps, ret, dGraphDataClass);\r\n        // console.log(\"viewsss mapstate 2 \" + ret.node?.className + \" \" + ret.data?.name, {views:ret.views, ownProps, stateProps:{...ret}, thiss:this});\r\n\r\n        GraphElementComponent.mapViewStuff(state, ret, ownProps);\r\n        // console.log(\"viewsss mapstate 5 \" + ret.node?.className + \" \" + ret.data?.name, {views:ret.views, ownProps, stateProps:{...ret}, thiss:this});\r\n\r\n        Log.exDev(!ret.view || !ret.views, 'failed to assign view:', {state, ownProps, reduxProps: ret});\r\n        // @ts-ignore\r\n        ret.key = ret.key || ownProps.key;\r\n        // @ts-ignore\r\n        ret.forceupdate = state.forceupdate;\r\n\r\n        // Log.l((ret.data as any)?.name === \"concept 1\", \"mapstatetoprops concept 1\", {newnode: ret.node});\r\n        U.removeEmptyObjectKeys(ret);\r\n        return ret;\r\n    }\r\n\r\n    static mapDispatchToProps(dispatch: Dispatch<any>): GraphElementDispatchProps {\r\n        const ret: GraphElementDispatchProps = {} as any;\r\n        return ret;\r\n    }\r\n\r\n\r\n    countRenders: number;\r\n    _isMounted: boolean;\r\n    html: React.RefObject<HTMLElement | undefined>;\r\n    lastViewChanges: {t: number, vid: Pointer<DViewElement>, v: LViewElement, key?: string}[];\r\n    lastOnUpdateChanges: {t: number}[];\r\n    stopUpdateEvents?: number; // undefined or view.clonedCounter;\r\n    dataOldClonedCounter?: number; // undefined or data.clonedCounter;\r\n\r\n    public shouldComponentUpdate(nextProps: Readonly<AllProps>, nextState: Readonly<GraphElementState>, nextContext: any, oldProps?: Readonly<AllProps>): boolean {\r\n        if (!oldProps) oldProps = this.props;//for subviewcomponent\r\n        if (nextProps.__skipRender) return true;\r\n        let debug = false;\r\n        // return GraphElementComponent.defaultShouldComponentUpdate(this, nextProps, nextState, nextContext);\r\n        let data = nextProps.data?.__raw as DNamedElement | undefined;\r\n\r\n        let out = {reason:undefined};\r\n        let skipDeepKeys = {pointedBy:true, clonedCounter: true};// clonedCounter is checked manually before looping object keys\r\n        // let skipPropKeys = {...skipDeepKeys, usageDeclarations: true, node:true, data:true, initialSize: true};\r\n        let ret = false; // !U.isShallowEqualWithProxies(oldProps, nextProps, 0, 1, skipPropKeys, out);\r\n        // if node and data in props must be ignored and not checked for changes. but they are checked if present in usageDeclarations\r\n        let component = nextProps.node.component;\r\n        const nid = nextProps.nodeid;\r\n        // U.arrayDiff()\r\n        for (let v of nextProps.views) {\r\n            const vid: Pointer<DViewElement> = v.__raw.id;\r\n            let nodeviewentry = transientProperties.node[nid].viewScores[vid];\r\n            let old_ud = nodeviewentry.usageDeclarations;\r\n            computeUsageDeclarations(component, nextProps, nextState, v);\r\n            let new_ud = nodeviewentry.usageDeclarations;\r\n            nodeviewentry.shouldUpdate = !U.isShallowEqualWithProxies(old_ud, new_ud, skipDeepKeys, out);\r\n\r\n            nodeviewentry.shouldUpdate_reason = {...out};\r\n            (nodeviewentry as any).shouldUpdate_reasonDebug = {old_ud, new_ud};\r\n            Log.l(debug, \"DECORATIVE_VIEW ShouldComponentUpdate \" + data?.name + (nodeviewentry.shouldUpdate ? \" UPDATED \" : \" REJECTED \")  + vid,\r\n                {ret:nodeviewentry.shouldUpdate, reason: out.reason, old_ud, new_ud, oldProps:oldProps, nextProps, vid});\r\n\r\n            if (!ret && nodeviewentry.shouldUpdate) ret = true;\r\n        }\r\n\r\n        const vid: Pointer<DViewElement> = nextProps.view.__raw.id;\r\n        let nodeviewentry = transientProperties.node[nextProps.nodeid].viewScores[vid];\r\n        let old_ud = nodeviewentry.usageDeclarations;\r\n        computeUsageDeclarations(component, nextProps, nextState, nextProps.view);\r\n        let new_ud = nodeviewentry.usageDeclarations;\r\n        nodeviewentry.shouldUpdate = !U.isShallowEqualWithProxies(old_ud, new_ud,  skipDeepKeys, out);\r\n        nodeviewentry.shouldUpdate_reason = {...out};\r\n        (nodeviewentry as any).shouldUpdate_reasonDebug = {old_ud, new_ud};\r\n\r\n        Log.l(debug, \"ShouldComponentUpdate \" + data?.name + (nodeviewentry.shouldUpdate ? \" UPDATED \" : \" REJECTED \") + vid,\r\n            {ret:nodeviewentry.shouldUpdate, reason: out.reason, old_ud, new_ud, oldProps:oldProps, nextProps});\r\n        if (!ret && nodeviewentry.shouldUpdate) ret = true;\r\n        return ret; // if any of main view or decorative views need updating\r\n        // apparently node changes are not working? also check docklayout shouldupdate\r\n    }\r\n\r\n    protected doMeasurableEvent(type: EMeasurableEvents, vid: Pointer<DViewElement>): boolean {\r\n        if (Debug.lightMode) return false;\r\n        let measurableFunc: undefined | ((context:GObject)=>void) = (transientProperties.view[vid] as any)[type];\r\n        if (!measurableFunc) return false;\r\n        let context: GObject = this.getJSXContext(vid); // context + usagedeclarations of main view only\r\n        try {\r\n            measurableFunc.call(context, context);\r\n            console.log(\"measurable executed\", {type, measurableFunc, vid, transient:transientProperties.view[vid]});\r\n        }\r\n        catch (e: any) { Log.ee('Error in measurable \"'+type+'\" ' + e.message, {e, measurableFunc, context}); }\r\n        // it has executed at least partially.\r\n        // i just need to know if he had the chance to do side-effects and the answer is yes regardless of exceptions\r\n        return true;\r\n    }\r\n\r\n\r\n\r\n    select(forUser?: Pointer<DUser>): void {\r\n        // if (forUser === DUser.current && this.html.current) this.html.current.focus();\r\n        TRANSACTION('selection', ()=>{\r\n            this.props.node?.select(forUser);\r\n            SetRootFieldAction.new('_lastSelected', {\r\n                node: this.props.nodeid,\r\n                view: this.props.view.id,\r\n                modelElement: this.props.data?.id\r\n            }, (this.props.data as any).name);/*\r\n        // ? why this?\r\n        const id = this.props.data?.id;\r\n        if (id) {\r\n            //selected[forUser] = id;\r\n            SetRootFieldAction.new('selected', id, '', true);\r\n        }*/\r\n\r\n            // SetRootFieldAction.new(`selected.${DUser.current}`, nodeid, '', true);\r\n        })\r\n    }\r\n\r\n    constructor(props: AllProps, context: any) {\r\n        super(props, context);\r\n        this.lastViewChanges = [];\r\n        this.lastOnUpdateChanges = []\r\n        this.stopUpdateEvents = undefined;\r\n        this._isMounted = false;\r\n        this.countRenders = 0;\r\n        this.id = GraphElementComponent.maxid++;\r\n        GraphElementComponent.all[this.id] = this;\r\n        GraphElementComponent.map[props.nodeid as Pointer<DGraphElement>] = this; // props might change at runtime, setting in constructor is not enough\r\n        this.html = React.createRef();\r\n        let functionsToBind = [this.onClick,\r\n            this.onLeave, this.onEnter,\r\n            this.doContextMenu, this.onContextMenu,\r\n            this.onMouseDown, this.onMouseUp, this.onKeyDown, this.onScroll, this.onMouseMove];/*\r\n        this.onClick = this.onClick.bind(this);\r\n        this.onLeave = this.onLeave.bind(this);\r\n        this.onContextMenu = this.onContextMenu.bind(this);\r\n        this.onEnter = this.onEnter.bind(this);\r\n        this.select = this.select.bind(this);*/\r\n        for (let f of functionsToBind) (this as any)[f.name] = f.bind(this);\r\n        // @ts-ignore\r\n        this.state = {classes: [] as string[]};\r\n        this.shouldComponentUpdate(this.props, this.state, undefined, undefined);\r\n    }\r\n\r\n    // constants: evalutate solo durante il primo render, può essere una funzione con effetti collaterali sul componente,\r\n    // in tal caso la si esegue e si prende il valore di ritorno.\r\n    // preRenderFunc: funzione evalutata ed eseguita sempre prima del render, ha senso solo per generare effetti collaterali sulle \"costanti\".\r\n    // jsxString: funzione evalutata una sola volta durante il primo render ed eseguita ad ogni update dei dati.\r\n\r\n\r\n\r\n    componentDidMount(): void {\r\n        // after first render\r\n        this._isMounted = true;\r\n    }\r\n\r\n    componentWillUnmount(): void {\r\n        // todo: devo fare in modo che il nodo venga cancellato solo se sto modificando la vista in modo che questo vertice non esista più.\r\n        //  e non venga cancellato se il componente viene smontato perchè ho solo cambiato vista\r\n        //  LOW PRIORITY perchè funziona anche senza, pur sprecando memoria che potrebbe essere liberata.\r\n        // if (view_is_still_active_but_got_modified_and_vertex_is_deleted) new DeleteElementAction(this.getId());\r\n    }\r\n    /*\r\n        componentDidUpdate(oldProps: Readonly<AllProps {/*\r\n            const newProps = this.props\r\n            if (oldProps.view !== newProps.view) { this.setTemplateString(newProps.view); }\r\n    }*/\r\n\r\n\r\n\r\n    protected getJSXContext(vid: Pointer<DViewElement>): GObject{\r\n        let context: GObject = transientProperties.node[this.props.nodeid].viewScores[vid].evalContext;\r\n        if (context && context.component) return context;\r\n\r\n        // else rebuild + update it\r\n        let tnv = transientProperties.node[this.props.nodeid].viewScores[vid];\r\n        let tv = transientProperties.view[vid];\r\n        context = tnv.evalContext = {...this.props, ...tv.constants, ...tnv.usageDeclarations,\r\n            // add component stuff that could not be computed in reducer\r\n            component: this,\r\n            otherViews: this.props.views,\r\n            constants: tv.constants,\r\n            usageDeclarations: tnv.usageDeclarations,\r\n            props: this.props};\r\n        context._context = context;\r\n        return context;\r\n    }\r\n\r\n    public static displayError(e: Error, where: string, view: DViewElement, data?: DModelElement, node?: DGraphElement, asString:boolean = false, printData?: GObject): React.ReactNode {\r\n        // const view: LViewElement = this.props.view; //data._transient.currentView;\r\n        let errormsg = (where === \"preRenderFunc\" ? \"Pre-Render \" : \"\") +(e.message||\"\\n\").split(\"\\n\")[0];\r\n        if (e.message.indexOf(\"Unexpected token .\") >= 0 || view.jsxString.indexOf('?.') >= 0 || view.jsxString.indexOf('??') >= 0) {\r\n            errormsg += '\\n\\nReminder: nullish operators \".?\" and \"??\" are not supported.'; }\r\n        else if (view.jsxString.indexOf('?.') >= 0) { errormsg += '\\n\\nReminder: ?. operator and empty tags <></> are not supported.'; }\r\n        else if (e.message.indexOf(\"Unexpected token '<'\") !== -1) { errormsg += '\\n\\nDid you forgot to close a html </tag>?'; }\r\n        try {\r\n            let ee = e.stack || \"\";\r\n            let stackerrorlast = ee.split(\"\\n\")[1];\r\n\r\n            let icol = stackerrorlast.lastIndexOf(\":\");\r\n            let jsxString = view.jsxString;\r\n            // let col = stackerrorlast.substring(icol+1);\r\n            let irow = stackerrorlast.lastIndexOf(\":\", icol-1);\r\n            const offset={row:-2, col:1};\r\n            let stackerrorlinenum: GObject = {\r\n                row: Number.parseInt(stackerrorlast.substring(irow+1, icol)) + offset.row,\r\n                col: Number.parseInt(stackerrorlast.substring(icol+1)) + offset.col };\r\n            let linesPre = 1;\r\n            let linesPost = 1;\r\n            let jsxlines = jsxString.split(\"\\n\");\r\n            let culpritlinesPre: string[] = jsxlines.slice(stackerrorlinenum.row-linesPre-1, stackerrorlinenum.row - 1);\r\n            let culpritline: string = jsxlines[stackerrorlinenum.row - 1]; // stack start counting lines from 1\r\n            let culpritlinesPost: string[] = jsxlines.slice(stackerrorlinenum.row, stackerrorlinenum.row + linesPost);\r\n            console.error(\"errr\", {e, node, jsxlines, culpritlinesPre, culpritline, culpritlinesPost, stackerrorlinenum, icol, irow, stackerrorlast});\r\n\r\n            if (stackerrorlinenum.col - offset.col > culpritline?.length && stackerrorlinenum.row === 1) stackerrorlinenum.col = 0;\r\n            let caretCursor = \"▓\" // ⵊ ꕯ 𝙸 Ꮖ\r\n            if (culpritline && stackerrorlinenum.col - offset.col <= culpritline?.length && stackerrorlast.indexOf(\"main.chunk.js\") === -1) {\r\n                let rowPre = culpritline.substring(0, stackerrorlinenum.col);\r\n                let rowPost = culpritline.substring(stackerrorlinenum.col);\r\n                let jsxcode =\r\n                    <div style={{fontFamily: \"monospaced sans-serif\", color:\"#444\"}}>\r\n                        { culpritlinesPre.map(l => <div>{l}</div>) }\r\n                        <div>{rowPre} <b style={{color:\"red\"}}> {caretCursor} </b> {rowPost}</div>\r\n                        { culpritlinesPost.map(l => <div>{l}</div>) }\r\n                    </div>;\r\n                errormsg += \" @ line \" + stackerrorlinenum.row + \", col:\" + stackerrorlinenum.col;\r\n                if (asString) return DV.errorView_string('<div>'+errormsg+'\\n'+jsxcode+'</div>', {where:\"in \"+where+\"()\", e, template:view.jsxString, view: view}, where, data, node, view);\r\n                return DV.errorView(<div>{errormsg}{jsxcode}</div>, {where:\"in \"+where+\"()\", e, template:view.jsxString, view: view}, where, data, node, view);\r\n            } else {\r\n                // it means it is likely accessing a minified.js src code, sending generic error without source mapping\r\n            }\r\n        } catch(e2) {\r\n            Log.eDevv(\"internal error in error view\", {e, e2, where} );\r\n            return null;\r\n        }\r\n        if (asString) return DV.errorView_string('<div>'+errormsg+'</div>', {where:\"in \"+where+\"()\", e, template: view.jsxString, view: view}, where, data, node, view);\r\n        return DV.errorView(<div>{errormsg}</div>, {where:\"in \"+where+\"()\", e, template: view.jsxString, view: view, ...(printData || {})}, where, data, node, view);\r\n    }\r\n/*\r\n    protected getTemplate(): ReactNode {\r\n        /*if (!this.state.template) {\r\n            this.setTemplateString('{c1: 118}', '()=>{this.setState({c1: this.state.c1+1})}',\r\n                '<div><input value=\"{name}\" onInput=\"{setName}\"></input><p>c1:{this.state.c1}</p><Attribute prop1={daa} prop2={1 + 1.5} stringPropdaa=\\\"daa\\\" /><ul>{colors.map( color => <li>color: {color}</li>)}</ul></div>');\r\n        }* /\r\n        // console.log('getTemplate:', {props: this.props, template: this.props.template, ctx: this.props.evalContext});\r\n\r\n        // Log.exDev(debug && maxRenderCounter-- < 0, \"loop involving render\");\r\n        if (this.props.invalidUsageDeclarations) {\r\n            return this.displayError(this.props.invalidUsageDeclarations, \"Usage Declaration\");\r\n        }\r\n        let context: GObject = this.getContext();\r\n        // abababababab\r\n        // todo: invece di fare un mapping ricorsivo dei figli per inserirgli delle prop, forse posso farlo passando una mia factory che wrappa React.createElement\r\n\r\n        try {\r\n            let preRenderFuncStr: string | undefined = this.props.view.preRenderFunc;\r\n            if (preRenderFuncStr) {\r\n                // eval prerender\r\n                let obj: GObject = {};\r\n                let tempContext: GObject = {__param: obj};\r\n                tempContext.__proto__ = context;\r\n                U.evalInContextAndScopeNew(\"(\"+preRenderFuncStr+\")(this.__param)\", tempContext, true, false);\r\n                U.objectMergeInPlace(context, obj);\r\n            }\r\n        }\r\n        catch(e: any) { return this.displayError(e, \"Pre-Render\");  }\r\n\r\n        let ret;\r\n        // eval template\r\n        let jsxCodeString: DocString<ReactNode>;\r\n\r\n        try { jsxCodeString = JSXT.fromString(this.props.view.jsxString, {factory: 'React.createElement'}); }\r\n        catch (e: any) { return this.displayError(e, \"JSX Syntax\"); }\r\n\r\n        try { ret = U.evalInContextAndScope<() => ReactNode>('(()=>{ return ' + jsxCodeString + '})()', context); }\r\n        catch (e: any) { return this.displayError(e, \"JSX Semantic\"); }\r\n        return ret;\r\n    }*/\r\n    protected getTemplate3(vid: Pointer<DViewElement>, v: LViewElement, context: GObject): ReactNode {\r\n        let tnv = transientProperties.node[this.props.nodeid].viewScores[vid];\r\n        let tv = transientProperties.view[vid];\r\n        // console.log(\"getTemplate jsx\", {vid, v, context, tnv, tv, shouldUp: tnv.shouldUpdate, jsxFunc:tv.JSXFunction});\r\n        let ret = this.getTemplate3_(vid, v, context);\r\n        return ret;\r\n    }\r\n    protected getTemplate3_(vid: Pointer<DViewElement>, v: LViewElement, context: GObject): ReactNode{\r\n        let tnv = transientProperties.node[this.props.nodeid].viewScores[vid];\r\n        if (!tnv.shouldUpdate && tnv.jsxOutput) return tnv.jsxOutput;\r\n        let tv = transientProperties.view[vid];\r\n        let ret = tnv.jsxOutput = (tv.JSXFunction ? tv.JSXFunction.call(context, context) : null);\r\n        if (typeof ret === \"object\" && ret !== null && !React.isValidElement(ret)) {\r\n            // plain objects cannot be react nodes, but react noeds are objects. so i try serializing\r\n            // this only happens if someone puts an object in jsx\r\n            try{\r\n                ret = JSON.stringify(ret);\r\n            }\r\n            catch(e){ ret = \"{__ Cyclic Object __}\"; }\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    protected getTemplate2(v: LViewElement, udContext: GObject): ReactNode {\r\n        // todo: invece di fare un mapping ricorsivo dei figli per inserirgli delle prop, forse posso farlo passando una mia factory che wrappa React.createElement\r\n\r\n        /*\r\n        let thisContext: GObject = {};\r\n        try {\r\n            let preRenderFuncStr: string | undefined = v.preRenderFunc;\r\n            if (preRenderFuncStr) {\r\n                // eval prerender\r\n                let tempContext: GObject = {__param: thisContext};\r\n                this.addToContext(udContext, {__param: thisContext});\r\n                tempContext.__proto__ = sharedContext;\r\n                U.evalInContextAndScopeNew(\"(\"+preRenderFuncStr+\")(this.__param)\", tempContext, true, false);\r\n                U.objectMergeInPlace(thisContext, udContext);\r\n                // thisContext.__proto__ = sharedContext;\r\n            } else thisContext = udContext;\r\n        }\r\n        catch(e: any) { return this.displayError(e, \"Pre-Render\", v);  }*/\r\n\r\n        let ret;\r\n        // eval template\r\n        let jsxCodeString: DocString<ReactNode>;\r\n\r\n        try { jsxCodeString = JSXT.fromString(v.jsxString, {factory: 'React.createElement'}); }\r\n        catch (e: any) { return GraphElementComponent.displayError(e, \"JSX Syntax\", v.__raw, this.props.data?.__raw, this.props.node?.__raw); }\r\n\r\n        // console.log('context for ' + (this.props.data?.name), {udContext});\r\n        try {\r\n            let parsedFunc = U.parseFunctionWithContextAndScope('()=>{ return ' + jsxCodeString + '}', udContext, udContext);\r\n            ret = parsedFunc(udContext) as ReactNode;\r\n            /// ret = U.evalInContextAndScope<() => ReactNode>('(()=>{ return ' + jsxCodeString + '})()', udContext);\r\n        }\r\n        catch (e: any) { return GraphElementComponent.displayError(e, \"JSX Semantic\", v.__raw, this.props.data?.__raw, this.props.node?.__raw, false, {udContext}); }\r\n        return ret;\r\n    }\r\n\r\n    onContextMenu(e: React.MouseEvent<Element>) {\r\n        e.preventDefault();\r\n        e.stopPropagation();\r\n        // NOT executed here, but on mousedown because of IOS compatibility\r\n    }\r\n\r\n    doContextMenu(e: React.MouseEvent<Element>) {\r\n        TRANSACTION('contextmenu', ()=>{\r\n            this.props.node.select();\r\n            if (this.html.current) this.html.current.focus();\r\n            let state: DState = store.getState();\r\n            if (state.contextMenu?.x !== e.clientX) {\r\n                SetRootFieldAction.new(\"contextMenu\", {\r\n                    display: true,\r\n                    x: e.clientX,\r\n                    y: e.clientY,\r\n                    nodeid: this.props.node?.id\r\n                });\r\n            }\r\n        }, true, false)\r\n    }\r\n\r\n    onEnter(e: React.MouseEvent<Element>) { // instead of doing it here, might set this class on render, and trigger it visually operative with :hover selector css\r\n        const isEdgePending = this.props.isEdgePending?.source;\r\n        if (!isEdgePending || this.props.data?.className !== \"DClass\") return;\r\n        const extendError: {reason: string, allTargetSuperClasses: LClass[]} = {reason: '', allTargetSuperClasses: []}\r\n        const canBeExtend = isEdgePending.canExtend(this.props.data as any as LClass, extendError);\r\n\r\n        if (canBeExtend) this.setState({classes:[...this.state.classes, \"class-can-be-extended\"]});\r\n        else this.setState({classes:[...this.state.classes, \"class-cannot-be-extended\"]});\r\n    }\r\n    onLeave(e: React.MouseEvent<Element>) {\r\n        if (this.props.data?.className !== \"DClass\") return;\r\n        this.setState({classes: this.state.classes.filter((classname) => {\r\n            return classname !== \"class-can-be-extended\" && classname !== \"class-cannot-be-extended\"\r\n        })});\r\n    }\r\n\r\n    static mousedownComponent: GraphElementComponent | undefined;\r\n    onMouseDown(e: React.MouseEvent): void {\r\n        if (UX.isStoppedEvt(e)) return;\r\n        e.stopPropagation();\r\n        GraphElementComponent.mousedownComponent = this;\r\n        //TRANSACTION('contextmenu', ()=>{\r\n            if (e.button === Keystrokes.clickRight) { this.doContextMenu(e); }\r\n            let p: GObject = this.props;\r\n            // if ((p.isGraph && !p.isVertex) || (p.isGraph && p.isVertex && e.ctrlKey)) GraphDragManager.startPanning(e, this.props.node as LGraph);\r\n        //})\r\n    }\r\n\r\n\r\n\r\n    onScroll(e: React.MouseEvent): void {\r\n        console.log(\"onScroll\");\r\n        let scroll: Point = new Point(e.currentTarget.scrollLeft, e.currentTarget.scrollTop);\r\n        let scrollOrigin: Point = new Point(e.nativeEvent.offsetX, e.nativeEvent.offsetY);\r\n        let g: LGraph = this.props.node.graph;\r\n        let oldZoom: GraphPoint = g.zoom;\r\n        let newZoom: GraphPoint = new GraphPoint(oldZoom.x+0.1, oldZoom.y+0.1);\r\n        let oldOffset: GraphPoint = g.offset;\r\n        let gscrollOrigin: GraphPoint = oldOffset.add(scrollOrigin.multiply(oldZoom, true), true);\r\n        let newscrollOrigin: GraphPoint = oldOffset.add(scrollOrigin.multiply(newZoom, true), true);\r\n        let newOffset: GraphPoint = oldOffset.add( gscrollOrigin.subtract(newscrollOrigin, true), true);\r\n        TRANSACTION('scroll graph', ()=>{\r\n            g.offset = newOffset;\r\n            g.zoom = newZoom;\r\n        })\r\n        e.stopPropagation();\r\n    }\r\n    onMouseMove(e: React.MouseEvent): void {\r\n        //this.onMouseUp(e);\r\n    }\r\n    onMouseUp(e: React.MouseEvent, frommousemove: boolean = false): void {\r\n        e.stopPropagation();\r\n        TRANSACTION('Vertex click-events', ()=>{\r\n            //GraphDragManager.stopPanning(e);\r\n            if (GraphElementComponent.mousedownComponent !== this) { return; }\r\n            if (!frommousemove) this.doOnClick(e);\r\n        })\r\n    }\r\n    onKeyDown(e: React.KeyboardEvent){\r\n        console.log('keydown', e.key, {e, m:this.props.data?.name});\r\n        let target: HTMLElement = e.target as any;\r\n        switch (target?.tagName.toLowerCase()) {\r\n            case 'input':\r\n            case 'textarea':\r\n                e.stopPropagation(); return;\r\n            default: if (target?.getAttribute('contenteditable') === 'true') { e.stopPropagation(); return; }\r\n        }\r\n        if (!(this.props.isGraph && !this.props.isVertex)) e.stopPropagation();\r\n        if (e.key === Keystrokes.escape) {\r\n            this.props.node.deselect();\r\n            if (this.props.isEdgePending) { \r\n                // this.stopPendingEdge(); todo\r\n                return;\r\n            }\r\n        }\r\n        let isDelete: boolean = false;\r\n        if (e.key === Keystrokes.delete){ isDelete = true; }\r\n        if (e.shiftKey) {\r\n            // todo: make them a switch\r\n            if (e.key === \"D\" || e.key === \"d\") this.props.data?.duplicate(); else\r\n            if (e.key === \"R\" || e.key === \"r\") { isDelete = true; }\r\n        }\r\n        console.log('keydown isDelete', isDelete);\r\n        if (isDelete){\r\n            let nid = this.props.nodeid;\r\n            let tn = transientProperties.node[nid];\r\n            TRANSACTION('delete ' + this.props.node.name, ()=>{\r\n                if (tn && tn.onDelete && tn.onDelete(this.props.node) === false) return;\r\n                // if shapeless, erase the node directly.\r\n                if (!this.props.data) {\r\n                    this.props.node.delete();\r\n                    return;\r\n                }\r\n                // if dictated by the model, change the model to erase indirectly the node.\r\n                if (!this.props.isEdge) {\r\n                    this.props.data.delete();\r\n                    return;\r\n                }\r\n                // if edge\r\n                let e = this.props.node as LVoidEdge;\r\n                let de = e.__raw;\r\n                if (de.isExtend) {\r\n                    let data: LClass = this.props.data as any;\r\n                    data.unsetExtends( e.end.model as LClass);\r\n                    // SetFieldAction(data.id, 'extends', )\r\n                }\r\n                if (de.isReference){\r\n                    if (this.props.data.className === 'DReference'){\r\n                        let ref: LReference = this.props.data as any;\r\n                        ref.type = ref.father.id as any;\r\n                    } else {\r\n                        let lval: LValue = this.props.data as any;\r\n                        lval.remove(e.end.model);\r\n                    }\r\n                }\r\n                if (de.isDependency){ // pkg dependency\r\n                    let ref: LPackage = this.props.data as any;\r\n                }\r\n                else {}\r\n            })\r\n        }\r\n        if (e.ctrlKey) {\r\n            // if (e.key === Keystrokes.escape) this.props.node.toggleMinimize();\r\n            if (e.key === \"a\") this.props.data?.addChild(\"auto\"); else // add class if on package, literal if on enum...\r\n            if (e.key === \"r\") this.props.data?.addChild(\"reference\"); else\r\n            if (e.key === \"o\") this.props.data?.addChild(\"operation\") || this.props.data?.addChild(\"object\"); else\r\n            if (e.key === \"l\") this.props.data?.addChild(\"literal\"); else\r\n            if (e.key === \"p\") this.props.data?.addChild(\"package\") || this.props.data?.addChild(\"parameter\"); else\r\n            if (e.key === \"c\") this.props.data?.addChild(\"class\"); else\r\n            if (e.key === \"e\") this.props.data?.addChild(\"enumerator\"); else\r\n            if (e.key === \"q\") this.props.data?.addChild(\"annotation\"); else\r\n            ;\r\n        }\r\n    }\r\n\r\n    private doOnClick(e: React.MouseEvent): void {\r\n        // (e.target as any).focus();\r\n        e.stopPropagation();\r\n        let state: DState = store.getState();\r\n        if (e.button !== Keystrokes.clickRight && state.contextMenu?.display) SetRootFieldAction.new(\"contextMenu\", {display: false, x: 0, y: 0}); // todo: need to move it on document or <App>\r\n        const edgePendingSource = this.props.isEdgePending?.source;\r\n        //console.log('mousedown select() check PRE:', {e, name: this.props.data?.name, isSelected: this.props.node.isSelected(), 'nodeIsSelectedMapProxy': this.props.node?.isSelected, nodeIsSelectedRaw:this.props.node?.__raw.isSelected});\r\n\r\n        if (edgePendingSource) {\r\n            if (this.props.data?.className !== \"DClass\") return;\r\n            // const user = this.props.isEdgePending.user;\r\n            const extendError: {reason: string, allTargetSuperClasses: LClass[]} = {reason: '', allTargetSuperClasses: []}\r\n            const canBeExtend = this.props.data && edgePendingSource.canExtend(this.props.data as any as LClass, extendError);\r\n            if (canBeExtend && this.props.data) {\r\n                const lClass: LClass = LPointerTargetable.from(this.props.data.id);\r\n                // SetFieldAction.new(lClass.id, \"extendedBy\", source.id, \"\", true); // todo: this should throw a error for wrong type.\r\n                // todo: use source.addExtends(lClass); or something (source is LClass)\r\n                SetFieldAction.new(lClass.id, \"extendedBy\", edgePendingSource.id, \"+=\", true);\r\n                SetFieldAction.new(edgePendingSource.id, \"extends\", lClass.id, \"+=\", true);\r\n            }\r\n            SetRootFieldAction.new('isEdgePending', { user: '',  source: '' });\r\n            return;\r\n        }\r\n        //console.log('mousedown select() check:', {e, isSelected: this.props.node.isSelected(), 'nodeIsSelectedMapProxy': this.props.node?.isSelected, nodeIsSelectedRaw:this.props.node?.__raw.isSelected});\r\n        windoww.node = this.props.node;\r\n\r\n        TRANSACTION('select', ()=>{\r\n            this.props.node.toggleSelected(DUser.current);\r\n            if (state._lastSelected?.node !== this.props.nodeid) {\r\n                SetRootFieldAction.new('_lastSelected', {\r\n                    node: this.props.nodeid,\r\n                    view: this.props.view.id,\r\n                    modelElement: this.props.data?.id\r\n                });\r\n            }\r\n\r\n            if (e.shiftKey || e.ctrlKey) { }\r\n            else {\r\n                let allNodes: LGraphElement[] | undefined = this.props.node?.graph.allSubNodes;\r\n                let nid = this.props.node.id;\r\n                if (allNodes) for (let node of allNodes) if (node.id !== nid) node.deselect(DUser.current);\r\n            }\r\n        })\r\n    }\r\n\r\n    onClick(e: React.MouseEvent): void {\r\n\r\n    }\r\n\r\n    onDataUpdateMeasurable(view: LViewElement, vid: Pointer<DViewElement>, index: number): void{\r\n        if (index > 0) { this.doMeasurableEvent(EMeasurableEvents.onDataUpdate, vid); return; }\r\n        // only on first of a sequence of onDataUpdate events for all stackviews (the mainview),\r\n        // set time of current stack of updates, to check if they are generating a loop\r\n\r\n        // EMeasurableEvents.onDataUpdate -> handling and checking for loops\r\n        if (!this.stopUpdateEvents || this.stopUpdateEvents !== this.props.view.clonedCounter) {\r\n            this.stopUpdateEvents = undefined;\r\n            if (this.props.data && (this.dataOldClonedCounter !== this.props.data.clonedCounter) && this.doMeasurableEvent(EMeasurableEvents.onDataUpdate, vid)) {\r\n                this.dataOldClonedCounter = this.props.data.clonedCounter;\r\n                let thischange = {t: Date.now()};\r\n                this.lastOnUpdateChanges.push(thischange);\r\n                if (thischange.t - this.lastOnUpdateChanges[this.lastOnUpdateChanges.length - 10]?.t < 300) {\r\n                    // if N updates in <= 0.2 sec\r\n                    this.stopUpdateEvents = this.props.view.clonedCounter;\r\n                    Log.eDevv(\"loop in node.render() likely due to MeasurableEvent onDataUpdate. It has been disabled until the view changes.\",{\r\n                        change_log: this.lastOnUpdateChanges,\r\n                        component: this,\r\n                        timediff: (thischange.t - this.lastOnUpdateChanges[this.lastOnUpdateChanges.length - 10]?.t)\r\n                    } as any);\r\n                }\r\n            }\r\n    }\r\n    }\r\n\r\n\r\n    // returns: true if an action is fired and component needs re-rendering\r\n    updateNodeFromProps(props: GObject<AllProps>): boolean {\r\n        let ret = false;\r\n        TRANSACTION('update node from props', ()=>{\r\n            ret = this.updateNodeFromProps0(props);\r\n        });\r\n        return ret;\r\n    }\r\n    updateNodeFromProps0(props: GObject<AllProps>): boolean {\r\n        let ret = false;\r\n        let tn = transientProperties.node[props.nodeid];\r\n        if (tn && !tn.viewScores) console.error('tn error 1', {tn:tn && {...tn}});\r\n        let ptr: Pointer<any>;\r\n        if (!props.node) return false;\r\n        let node = props.node;\r\n        let dnode = node.__raw;\r\n        let edge: LVoidEdge = props.node as any;\r\n        let dedge: DVoidEdge = dnode as any;\r\n        // if edge.label props is func, do not set in the dedge, just in transientproperties. totally override the \"text\" system.\r\n        // it does not need collab sync:\r\n        // because if the view is active for the other user, his synched jsx will generate the same function in transientProperties.\r\n        // if it is inactive it does not matter, the value is not used.\r\n        if (props.label) { tn.longestLabel = props.label; }\r\n        if (props.onDelete) { tn.onDelete = props.onDelete; }\r\n        if (props.longestLabel) { tn.longestLabel = props.longestLabel; }\r\n        if (props.labels) { tn.labels = props.labels; }\r\n        if (props.anchorStart && props.isEdge) { edge.anchorStart = props.anchorStart; }\r\n        if (props.anchorEnd && props.isEdge) { edge.anchorEnd = props.anchorEnd; }\r\n        if (props.start && props.isEdge) {\r\n            ptr = Pointers.from(props.start);\r\n            if (dedge.id !== ptr) edge.start = ptr as any;\r\n        }\r\n        // console.log(\"changing endpt\", props, props.end, props.end?.model?.name);\r\n        if (props.end && props.isEdge) {\r\n            ptr = Pointers.from(props.end);\r\n            if (dedge.id !== ptr) edge.end = ptr as any;\r\n        }\r\n        if (props.anchorEnd) { tn.labels = props.labels; }\r\n        let todoremovethis = false;\r\n        // if (typeof props.viewid === 'string') { let old = props.viewid; if (old !== props.node.view.id) { this.forceUpdate(); ret = true;} }\r\n        if (todoremovethis || props.isReference !== undefined) { let old = dedge.isReference; let n = !!props.isReference; if (old !== n) { edge.isReference = n; ret = true;} }\r\n        if (todoremovethis || props.isExtend !== undefined) { let old = dedge.isExtend; let n = !!props.isExtend; if (old !== n) { edge.isExtend = n; ret = true;} }\r\n        if (todoremovethis || props.isValue !== undefined) { let old = dedge.isValue; let n = !!props.isValue; if (old !== n) { edge.isValue = n; ret = true;} }\r\n        if (todoremovethis || props.isDependency !== undefined) { let old = dedge.isDependency; let n = !!props.isDependency; if (old !== n) { edge.isDependency = n; ret = true;} }\r\n        if (typeof props.x === 'number') { let old = dnode.x; let n = +props.x; if (old !== n) { node.x = n; ret = true;} }\r\n        if (typeof props.y === 'number') { let old = dnode.y; let n = +props.y; if (old !== n) { node.y = n; ret = true;} }\r\n        // risk loop: todo loop detection and skip setting\r\n        if (typeof props.w === 'number') { let old = dnode.w; let n = +props.w; if (old !== n) { node.w = n; ret = true;} }\r\n        if (typeof props.h === 'number') { let old = dnode.h; let n = +props.h; if (old !== n) { node.h = n; ret = true;} }\r\n        if (typeof props.width  === 'number') { let old = dnode.w; let n = +props.width;  if (old !== n) { node.w = n; ret = true;} }\r\n        if (typeof props.height === 'number') { let old = dnode.h; let n = +props.height; if (old !== n) { node.h = n; ret = true;} }\r\n\r\n        return ret;\r\n    }\r\n\r\n    public render(nodeType:string = '', styleoverride:React.CSSProperties={}, classes: string[]=[]): ReactNode {\r\n        GraphElementComponent.map[this.props.nodeid as Pointer<DGraphElement>] = this; // props might change at runtime, setting in constructor is not enough\r\n        if (Debug.lightMode && (!this.props.data || !(lightModeAllowedElements.includes(this.props.data.className)))){\r\n            return this.props.data ? <div>{\" \" + ((this.props.data as any).name)}:{this.props.data.className}</div> : undefined;\r\n        }\r\n        if (!this.props.node) return \"Loading...\";\r\n        /*if (this.props.node.__raw.view !== this.props.view.id) {\r\n            this.onViewChange();\r\n            return \"Updating view...\";\r\n        }*/\r\n        if (this.updateNodeFromProps(this.props as GObject<any>)) return 'Updating...';\r\n        let nid = this.props.nodeid;\r\n        let allviews = [...this.props.views, this.props.view]; // main view must be last, for renderView ordering\r\n\r\n\r\n        for (let i = 0 ; i < allviews.length; i++){\r\n            let v = allviews[i];\r\n            const vid = v.id;\r\n            let viewnodescore = transientProperties.node[nid].viewScores[v.id];\r\n            if (!viewnodescore.shouldUpdate) continue;\r\n            viewnodescore.evalContext = undefined as any; // force rebuild jsx context, needs to be done before renderView and measurable events\r\n            // only if this exact view had UD changed, instead of being forced to rended by other in viewstack)\r\n            this.onDataUpdateMeasurable(v, vid, i);\r\n        }\r\n\r\n        /// set classes\r\n        if (this.props.node) {\r\n            let isSelected: Dictionary<Pointer<DUser>, boolean> = this.props.node.__raw.isSelected;\r\n            if(isSelected) {\r\n                if (isSelected[DUser.current]) { // todo: better to just use css attribute selectors [data-userselecting = \"userID\"]\r\n                    classes.push('selected-by-me');\r\n                    if (Object.keys(isSelected).length > 1) classes.push('selected-by-others');\r\n                } else if (Object.keys(isSelected).length) classes.push('selected-by-others');\r\n            }\r\n        }\r\n\r\n        classes.push(this.props.data?.className || 'DVoid');\r\n        U.arrayMergeInPlace(classes, this.state.classes);\r\n        if (Array.isArray(this.props.className)) { U.arrayMergeInPlace(classes, this.props.className); }\r\n        else if (this.props.className) { classes.push(this.props.className); }\r\n        if (Array.isArray(this.props.class)) { U.arrayMergeInPlace(classes, this.props.class); }\r\n        else if (this.props.class) { classes.push(this.props.class); }\r\n        /// end set classes\r\n\r\n\r\n        let mainView: LViewElement = this.props.view;\r\n        let otherViews: LViewElement[] = this.props.views;\r\n        let decoratorViewsOutput: (ReactNode | ReactElement)[] = [];/*\r\n        for (let v of this.props.views) {\r\n            if (v.isExclusiveView) {\r\n                if (mainView) continue;\r\n                mainView = v;\r\n            } else otherViews.push(v);\r\n        }*/\r\n\r\n        let jsxOutput: ReactNode = undefined as any;\r\n        const tn = transientProperties.node[nid]\r\n        //console.log(\"render\", {mainView, otherViews, scores:tn.viewScores, tnv:tn.viewScores[this.props.viewid], ud:tn.viewScores[this.props.viewid].usageDeclarations});\r\n        for (let v of allviews) { // main view is the last\r\n            let viewnodescore = transientProperties.node[nid].viewScores[v.id];\r\n            jsxOutput = viewnodescore.shouldUpdate ? undefined : viewnodescore.jsxOutput;\r\n            let isMain: true | undefined = v === mainView || undefined;\r\n            if (!jsxOutput) viewnodescore.jsxOutput = jsxOutput =\r\n                this.renderView(this.props, v, nodeType, classes, styleoverride,\r\n                    isMain && decoratorViewsOutput, mainView.id, isMain && otherViews.map(v=>v.id));\r\n            if (!isMain) decoratorViewsOutput.push(jsxOutput);\r\n            if (viewnodescore.shouldUpdate) viewnodescore.shouldUpdate = false; // this needs to be placed post renderView call\r\n        }\r\n\r\n        let mainViewOutput: ReactNode = jsxOutput;\r\n        return mainViewOutput;\r\n        // console.log('rendering view stack', {mainView, otherViews, mainViewOutput, decoratorsJSX:decoratorViewsOutput});\r\n        // windoww.debbugg = {mainViewOutput,otherViews, ret:<>renderrr{mainViewOutput}{otherViews}</>}\r\n        // return this.props.data?.className === \"DValue\" ? <div>{mainView.jsxString}{mainViewElement}</div> : mainViewElement;\r\n    }\r\n\r\n\r\n    protected renderView(props: AllProps, v: LViewElement, nodeType: string, classes: string[], styleoverride: React.CSSProperties,\r\n                         otherViews?: (ReactNode | ReactElement)[], mainviewid?: Pointer<DViewElement>, subViewsID: Pointer<DViewElement>[] = []): ReactNode | ReactElement {\r\n        let dv = v.__raw;\r\n        const nid = props.nodeid;\r\n        const vid = v.id;\r\n        const tnv = transientProperties.node[nid].viewScores[vid];\r\n        let ud: GObject | undefined = tnv.usageDeclarations;\r\n        /*if (false && !ud) {\r\n            this.forceUpdate();\r\n            return <div>Loading...</div>;\r\n        }*/\r\n\r\n        if (!ud) tnv.usageDeclarations = ud = computeUsageDeclarations(this, props, this.state, v);\r\n        //console.log(\"renderView\", {dv, tnv, ud});\r\n\r\n        if (ud.__invalidUsageDeclarations) {\r\n            console.error(\"renderView error ud:\", {dv, tnv, ud});\r\n            return GraphElementComponent.displayError(ud.__invalidUsageDeclarations, \"Usage Declaration \" + (ud.__invalidUsageDeclarations.isSyntax ? \"Syntax\" : \"Semantic\"), v.__raw,\r\n                this.props.data?.__raw, this.props.node?.__raw, false, {ud});\r\n        }\r\n        let isMainView: boolean = !!otherViews;\r\n        const context: GObject = this.getJSXContext(vid);\r\n\r\n        if (isMainView) context.decorators = otherViews;\r\n        let rnode: ReactNode;\r\n        try { rnode = this.getTemplate3(vid, v, context); }\r\n        catch (e: any) {\r\n            console.error(\"renderView error get template:\", {e, dv, tnv});\r\n            // rnode = undefined as any;\r\n            // todo: move in reducer parser of jsx: catch (e: any) { return GraphElementComponent.displayError(e, \"JSX Syntax\", v.__raw, this.props.data?.__raw, this.props.node?.__raw); }\r\n            rnode = GraphElementComponent.displayError(e, \"JSX Semantic\", v.__raw, this.props.data?.__raw, this.props.node?.__raw, false, {context});\r\n        }\r\n        let rawRElement: ReactElement | null = UX.ReactNodeAsElement(rnode);\r\n\r\n\r\n        // \\console.log('GE render', {thiss: this, data:me, rnode, rawRElement, props:this.props, name: (me as any)?.name});\r\n\r\n        function makeItArray(val?: any) { return val ? [] : (Array.isArray(val) ? val : [val]); }\r\n        function getNodeText(node?: any | ReactNode): string | undefined {\r\n            if (['string', 'number'].includes(typeof node)) return node;\r\n            if (node instanceof Array) return node.map(getNodeText).join('');\r\n            if (typeof node === 'object' && node) return getNodeText(node.props.children);\r\n        }\r\n        const addprops: boolean = true;\r\n        let fiximport = !!this.props.node;\r\n        //let a: false = true as any; if (a) return \"Loading...\";\r\n        // if (this.props.data?.name === \"Concept 1\") console.log(\"shouldcomponentupdate rendering \" + this.props.data?.name, {cc: this.props.data.clonedCounter, attrs: (this.props.data as any).attributes});\r\n        if (addprops && rawRElement && fiximport) {\r\n            if (windoww.debugcount && debugcount++>windoww.debugcount) throw new Error(\"debug triggered stop\");\r\n            let fixdoubleroot = true;\r\n            // add view props to GraphElement children (any level down)\r\n            const subElements: Dictionary<DocString<'nodeid'>, boolean> = {}; // this.props.getGVidMap();\r\n            try {\r\n                let viewStyle: GObject = {...(this.props.style || {})};\r\n                /*\r\n                    if (view.adaptWidth) viewStyle.width = view.adaptWidth; // '-webkit-fill-available';\r\n                    else viewStyle.height = (rootProps.view.height) && rootProps.view.height + 'px';\r\n                    if (view.adaptHeight) viewStyle.height = view.adaptHeight; //'fit-content'; // '-webkit-fill-available'; if needs to actually fill all it's not a vertex but a field.\r\n                    else viewStyle.width = (rootProps.view.width) && rootProps.view.width + 'px';\r\n                    viewStyle = {};\r\n                */\r\n                // viewStyle.pointerEvents = \"all\";\r\n                let injectProps: GObject = {};\r\n                if (isMainView) {\r\n                    viewStyle.order = viewStyle.zIndex = props.node?.zIndex; // alias? this.props.node.z\r\n                    viewStyle.display = v?.display;\r\n                    const me: LModelElement | undefined = props.data; // this.props.model;\r\n                    if (countRenders) {\r\n                        classes.push(this.countRenders%2 ? \"animate-on-update-even\" : \"animate-on-update-odd\");\r\n                    }                /// let excludeProps = ['data', 'node', 'view', 'children', ]\r\n                    classes.push(\"mainView\", dv.id);\r\n                    classes.push(...subViewsID);\r\n                    injectProps = {\r\n                        ref: this.html,\r\n                        // damiano: ref html viene settato correttamente a tutti tranne ad attribute, ref, operation (è perchè iniziano con <Select/> as root?)\r\n                        id: props.nodeid,\r\n                        \"data-nodeid\": props.nodeid,\r\n                        \"data-dataid\": me?.id,\r\n                        \"data-viewid\": dv.id,\r\n                        \"data-modelname\": me?.className || \"model-less\",\r\n                        \"data-userselecting\": JSON.stringify(props.node?.isSelected || {}),\r\n                        \"data-nodetype\": nodeType,\r\n                        // \"data-order\": this.props.node?.zIndex,\r\n                        style: {...viewStyle, ...styleoverride},\r\n                        className: classes.join(' '),\r\n                        onClick: this.onClick,\r\n                        onContextMenu: this.onContextMenu,\r\n                        onMouseDown: this.onMouseDown,\r\n                        onMouseUp: this.onMouseUp,\r\n                        onMouseMove: this.onMouseMove,\r\n                        onKeyDown: this.onKeyDown,\r\n                        // onKeyUp: this.onKeyUp,\r\n                        onwheel: this.onScroll,\r\n                        onMouseEnter: this.onEnter,\r\n                        onMouseLeave: this.onLeave,\r\n                        tabIndex: (props as any).tabIndex || -1,\r\n                        \"data-countrenders\": this.countRenders++,\r\n                        \"data-clonedcounter\": props.node?.clonedCounter || -1,\r\n                        // decorators: otherViews,\r\n                    };\r\n                    let p: GObject = this.props;\r\n                    for (let k in p) {\r\n                        if (typeof p[k] === 'object' || typeof p[k] === 'function') continue;\r\n                        if (!injectProps[k]) injectProps[k] = p[k];\r\n                    }\r\n                }\r\n                else injectProps = {\"data-viewid\": v.id, className: \"decorativeView \" + v.id, \"data-mainview\": mainviewid};\r\n\r\n\r\n                let debug: GObject = {};\r\n                injectProps.children = UX.recursiveMap(rawRElement/*.props.children*/,\r\n                    (rn: ReactNode, index: number, depthIndexes: number[]) => {\r\n                        let injectOffset: undefined | LGraph = ((this.props as any).isGraph && !depthIndexes[0] && !index) && (this.props.node as LGraph);\r\n                        //injectOffset&&console.log(\"inject offset props0:\", {injectOffset});\r\n                        //console.log(\"inject offset props00:\", {injectOffset, ig:(this.props as any).isGraph, props:this.props, depthIndexes, index});\r\n                        return UX.injectProp(this, rn, subElements, this.props.parentnodeid as string, index, depthIndexes, injectOffset)\r\n                    });\r\n/*\r\n                debug.injectPropsOriginal = injectProps.children;\r\n                debug.recursivemap = injectProps.children;\r\n                debug.injectChildrensAttempt = [...injectProps.children, ...makeItArray(props.children), ...(otherViews as any[])];\r\n                debug.rawRElement = {node:rawRElement, text: getNodeText(rawRElement)};*/\r\n\r\n                if (otherViews && false) injectProps.children = [...injectProps.children, ...makeItArray(props.children), ...(otherViews as any[])];\r\n\r\n                // injectProps.children = [...makeItArray(rawRElement.props.children), ...makeItArray(injectProps.children)];\r\n                let children = makeItArray(injectProps.children); // [...makeItArray(rawRElement.props.children), ...makeItArray(injectProps.children)]; rawRElement.child are already in injectprops\r\n                // injectProps.children = [<div>{children}</div>];//[]; making any change at injectprops.children breaks it?\r\n                rawRElement = React.cloneElement(rawRElement, injectProps);//, ...children); // adding chioldrens after injectprops seems pointless\r\n\r\n                debug.rawRElementPostInjection = {node:rawRElement, text: getNodeText(rawRElement)};\r\n                // rawRElement = React.cloneElement(rawRElement, {children: [...makeItArray(rawRElement.props.children), ...makeItArray(injectProps.children)]});\r\n                // console.log('rendering view stack fixing doubles', {v0:rnode, v1:rawRElement, fixed:rawRElement.props.children})\r\n                fixdoubleroot = false; // need to set the props to new root in that case.\r\n                if (fixdoubleroot) rawRElement = rawRElement.props.children;\r\n                // debug.rawRElementPostfixdoubleroot = {node:rawRElement, text: getNodeText(rawRElement)};\r\n                // console.log(\"probem\", {rawRElement, children:(rawRElement as any)?.children, pchildren:(rawRElement as any)?.props?.children});\r\n            } catch (e: any) {\r\n                console.error(\"renderView error inject props:\", {e, dv, tnv});\r\n                rawRElement = DV.errorView(\"error while injecting props to subnodes\\n:\" + (e.message || '').split('\\n')[0],\r\n                    {e, rawRElement, key: props.key, newid: props.nodeid},\r\n                    'Subelement props', props.data?.__raw, props.node?.__raw, dv) as ReactElement;\r\n                /*\r\n                rawRElement = U.eval InContextAndScope<ReactElement>('()=>{ return ' +\r\n                    DV.errorView(\"error while injecting props to subnodes\",\r\n                        {e, rawRElement, key:this.props.key, newid: this.props.nodeid}) + '}',\r\n                    {});*/\r\n\r\n                // rawRElement = DV.errorView(\"error while injecting props to subnodes\", {e, rawRElement, key:this.props.key, newid: this.props.nodeid});\r\n            }\r\n            /*console.log('tempdebug', {deepStrictEqual, okeys:Object.keys});\r\n            let isEqual = true;\r\n            try {deepStrictEqual(subElements, this.props.node.subElements)} catch(e) { isEqual = false; }\r\n            if (isEqual) {\r\n                this.props.node.subElements = Object.keys(subElements);\r\n            }*/\r\n        }\r\n        // const injectprops = {a:3, b:4} as DetailedHTMLProps<HTMLAttributes<HTMLDivElement>, HTMLDivElement>;\r\n        // rnode = React.cloneElement(rnode as ReactElement, injectprops);\r\n\r\n        // console.log(\"nodeee\", {thiss:this, props:this.props, node: this.props.node});\r\n        if (false && dv.isExclusiveView && (props.node?.__raw as DGraphElement).father) {\r\n            let $containedIn = $('#' + props.node.__raw.father);\r\n            let $containerDropArea = $containedIn.find(\".VertexContainer\");\r\n            const droparea = $containerDropArea[0] || $containedIn[0];\r\n            Log.exDev(!droparea, 'invalid vertex container target', {$containedIn, $containerDropArea});\r\n            if (droparea) return createPortal(rawRElement || rnode, droparea);\r\n        }/*\r\n        if (countRenders) return <>{[\r\n            rawRElement || rnode,\r\n            <div className={this.countRenders%2 ? \"animate-on-update-even\" : \"animate-on-update-odd\"} data-countrenders={this.countRenders++} />\r\n        ]}</>/*/\r\n\r\n        //console.log(\"renderView return:\", rawRElement || rnode);\r\n        return rawRElement || rnode;\r\n    }\r\n\r\n}\r\n\r\n// private\r\n// type AllPropss = GraphElementOwnProps & GraphElementDispatchProps & GraphElementReduxStateProps;\r\ntype AllPropss = Overlap<Overlap<GraphElementOwnProps, GraphElementDispatchProps>, GraphElementReduxStateProps>;\r\n\r\nconst GraphElementConnected = connect<GraphElementReduxStateProps, GraphElementDispatchProps, GraphElementOwnProps, DState>(\r\n    GraphElementComponent.mapStateToProps,\r\n    GraphElementComponent.mapDispatchToProps\r\n)(GraphElementComponent as any);\r\n\r\nexport const GraphElement = (props: GraphElementOwnProps, children: (string | React.Component)[] = []): ReactElement => {\r\n    return <GraphElementConnected {...{...props, children}} />; }\r\n// console.info('graphElement loaded');\r\n\r\n\r\nGraphElementComponent.cname = \"GraphElementComponent\";\r\nGraphElementConnected.cname = \"GraphElementConnected\";\r\nGraphElement.cname = \"GraphElement\";\r\n","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\components\\forEndUser\\GenericInput.tsx",["1362","1363","1364"],"import React, {Dispatch, InputHTMLAttributes, PureComponent, ReactNode} from 'react';\r\nimport {connect} from 'react-redux';\r\nimport './GenericInput.scss';\r\nimport {\r\n    Dictionary,\r\n    DocString,\r\n    DPointerTargetable,\r\n    DState,\r\n    DViewElement,\r\n    GObject,\r\n    Info,\r\n    Input,\r\n    Log,\r\n    LPointerTargetable,\r\n    LViewElement,\r\n    RuntimeAccessibleClass,\r\n    Select,\r\n    ShortAttribETypes,\r\n    TextArea,\r\n    U\r\n} from '../../joiner';\r\nimport {SizeInput} from './SizeInput';\r\nimport {JavascriptEditor} from \"../editors/languages\";\r\n\r\n// private\r\ninterface ThisState {\r\n}\r\ntype Dic<K extends string|number, V> = Dictionary<K, V>;\r\ntype String<T> = DocString<T>;\r\nclass GenericInputComponent extends PureComponent<AllProps, ThisState/*undefined*/>{\r\n    constructor(props: AllProps, context: any) {\r\n        super(props, context);\r\n    }\r\n\r\n    render(): ReactNode {\r\n        let d: DViewElement = ((this.props.data as LPointerTargetable).__raw || this.props.data) as any;\r\n        let l: LViewElement = LPointerTargetable.wrap(this.props.data) as LViewElement;\r\n        let field: keyof LViewElement = this.props.field as any;\r\n        let info: GObject<Info>;\r\n        if (!this.props.info){\r\n            let DConstructor: typeof DPointerTargetable = RuntimeAccessibleClass.get(d.className);\r\n            let singleton: GObject<LPointerTargetable> = DConstructor.singleton;\r\n            info = singleton['__info_of__' + this.props.field] ;\r\n        } else info = this.props.info;\r\n        if (!info) {\r\n            Log.eDevv(\"<GenericInput/> could not find info of \" + this.props.field, {props:this.props});\r\n            return <></>;\r\n        }\r\n\r\n        let type: string;\r\n        let enumOptions: Dic<String<'optgroup'>, Dic<String<'options'>, String<'values'>>> = {}; // 'Options' entry is a fallback for items without an optgroup\r\n        let enumOptionsJSX: JSX.Element | undefined;\r\n        if (info.enum) {\r\n            type = 'EEnum';\r\n            let prevoptgroup: string = 'Options';\r\n            let group: string;\r\n            let option: string;\r\n            for (let key in info.enum) {\r\n                let val: string = info.enum[key];\r\n                if (key.indexOf('(') === 0) {\r\n                    let end = key.indexOf(')');\r\n                    group = key.substring(1, end).trim();\r\n                    option = key.substring(end + 1).trim();\r\n                    prevoptgroup = group;\r\n                } else {\r\n                    option = key;\r\n                    group = prevoptgroup;\r\n                }\r\n                if (!enumOptions[group]) enumOptions[group] = {};\r\n                enumOptions[group][option] = val;\r\n            }\r\n            let unsorted = enumOptions.Options;\r\n            delete enumOptions.Options;\r\n            enumOptionsJSX = <>\r\n                {\r\n                    //data-selected={l[field] === unsorted[optkey]}\r\n                    unsorted && Object.keys(unsorted).map((optKey: string) => <option value={unsorted[optKey]}>{optKey}</option>)\r\n                }\r\n                {Object.keys(enumOptions).map((grpKey: string) => <optgroup label={grpKey}>{\r\n                Object.keys(enumOptions[grpKey]).map( (optKey: string) => <option value={enumOptions[grpKey][optKey]}>{optKey}</option>)\r\n            }</optgroup>)}</>;\r\n        }\r\n        else {\r\n            if (typeof info.type === 'string') {\r\n                if (info.type.toLowerCase().indexOf('function') === 0) type = 'Function';\r\n                else type = info.type as any;\r\n            }\r\n            else {\r\n                if (!info.type) { Log.exDevv('missing __info_of__ type for ' + d.className + '.' + this.props.field, {d, info, props: this.props}); return <></>}\r\n                let infoType: GObject = info.type;\r\n                type = infoType.cname || infoType.className || infoType.name;\r\n                Log.exDev(!type, 'missing type:', {type, info});\r\n            }\r\n        }\r\n\r\n        /*if (type.indexOf('|') !== -1) {\r\n            type = 'EEnum';\r\n            let options = type.split('|');\r\n            if (!enumOptions.Option) enumOptions.Option = {};\r\n            for (let o in options){\r\n                o = o.trim();\r\n                enumOptions.Option[o] = o;\r\n            }\r\n        }*/\r\n\r\n        // const otherProps: {[inputattribute:HTMLInputTypeAttribute]: any} = {...this.props};\r\n        const otherProps: InputHTMLAttributes<Event> = {...this.props} as any;\r\n        function setMinMax(max: number): void {\r\n            if (info.min !== undefined) otherProps.min = info.min;\r\n            else otherProps.min = info.positive === true ? 0 : -max / 2; // assume false if non specified\r\n\r\n            if (info.max !== undefined) otherProps.max = info.max;\r\n            else otherProps.max = info.positive === false ? max/2 - 1 : max-1; // assume true if non specified\r\n        }\r\n\r\n        let label: ReactNode = info.label || this.props.field;\r\n        if (typeof label === \"string\") label = U.uppercaseFirstLetter(info.label || this.props.field);\r\n\r\n        if (type.toLowerCase().indexOf(\"function(\") >=0 || type.indexOf(\"()=>\") >=0) type = \"Function\";\r\n        switch (type.toLowerCase()) {\r\n            default:\r\n                Log.ee('invalid type in GenericInput', {type, props:this.props, info, d});\r\n                return <div {...otherProps as any} className={'danger'} style={{color: 'red', border: '1px solid red'}}>Invalid GInput type: '{type}'</div>;\r\n            case 'point': case 'graphpoint': case 'size': case 'graphSsize':\r\n                return <SizeInput {...otherProps} data={l} field={this.props.field} label={label} />;\r\n            case 'text':\r\n                return <TextArea inputClassName={'input my-auto ms-auto '} {...otherProps as any} className={(this.props.rootClassName||'')+' '+(this.props.className||'')}\r\n                                 data={this.props.data} field={this.props.field}\r\n                                 jsxLabel={label} tooltip={this.props.tooltip} />;\r\n            case 'function':\r\n                return <JavascriptEditor className={(this.props.rootClassName||'')+' '+(this.props.className||'')} placeHolder={this.props.placeholder}\r\n                                         jsxLabel={this.props.label}\r\n                                         data={this.props.data} field={this.props.field} tooltip={this.props.tooltip}\r\n                                         hide={this.props.hide} style={this.props.style} title={this.props.title}\r\n                                         getter={this.props.getter} setter={this.props.setter} key={this.props.key}\r\n                                         readonly={this.props.readOnly}\r\n                                         height={this.props.height}\r\n                                         {...otherProps as any /*not working? i had to list them all*/}  />;\r\n            case 'eenum':\r\n                return <Select inputClassName={'my-auto ms-auto select'} {...otherProps as any} className={this.props.rootClassName}\r\n                               data={this.props.data} field={this.props.field} options={enumOptionsJSX}\r\n                               jsxLabel={label} tooltip={this.props.tooltip} />;\r\n                // <input> natives\r\n            case 'radio':\r\n                // problem: this would need to return a <form> and multiple inputs generated by a single element.\r\n                // it should be easy but unlikely it will be needed so i won't do it for now.\r\n                Log.eDevv('radio input type is unsupported'); break;\r\n            case 'datetime': type = 'datetime-local'; break;\r\n            case 'color': break;\r\n            case 'email': break;\r\n            case 'image': break; // ?\r\n            case 'password': break;\r\n            case 'range': break;\r\n            case 'month': break;\r\n            case 'week': break;\r\n            case 'datetime-local': break;\r\n            case 'time': break;\r\n            case 'url': break;\r\n            // ecore\r\n            case ShortAttribETypes.EChar.toLowerCase():\r\n                type = 'text';\r\n                if (undefined === otherProps.minLength) otherProps.minLength = 1;\r\n                otherProps.maxLength = 1;\r\n                // otherProps.pattern = '^.{1}$';\r\n                break;\r\n            case \"string\":\r\n            case ShortAttribETypes.EString.toLowerCase(): type = 'text'; break;\r\n            case ShortAttribETypes.EBoolean.toLowerCase(): type = 'checkbox'; break;\r\n            case ShortAttribETypes.EByte.toLowerCase():\r\n                type = 'number';\r\n                setMinMax(2**8);\r\n                break;\r\n            case ShortAttribETypes.EShort.toLowerCase():\r\n                type = 'number';\r\n                setMinMax(2**16);\r\n                break;\r\n            case ShortAttribETypes.EInt.toLowerCase():\r\n                type = 'number';\r\n                setMinMax(2**32);\r\n                break;\r\n            case ShortAttribETypes.ELong.toLowerCase():\r\n                type = 'number';\r\n                setMinMax(2**64);\r\n                break;\r\n            case ShortAttribETypes.EFloat.toLowerCase():\r\n            case ShortAttribETypes.EDouble.toLowerCase():\r\n                type = 'number';\r\n                if (!otherProps.step) otherProps.step = info.step || 0.1;\r\n                if (!otherProps.pattern) otherProps.pattern = info.pattern || '^[0-9]+\\.[0-9]{' + info.digits + '}$';\r\n                break;\r\n            case ShortAttribETypes.EDate.toLowerCase(): type = 'datetime-local'; break;\r\n        }\r\n        let className = (this.props.className || '') + ' ' + ( this.props.rootClassName||'');\r\n        // delete otherProps.field; delete otherProps.data; delete otherProps.infoof;\r\n        return <Input {...otherProps} className={className}\r\n                      data={this.props.data} field={this.props.field}\r\n                      jsxLabel={label} tooltip={this.props.tooltip} type={type as any}/>;\r\n    }\r\n}\r\n\r\n// private\r\ninterface _OwnProps {\r\n    // propsRequestedFromJSX_AsAttributes: string;\r\n    data: DPointerTargetable | LPointerTargetable;\r\n    field: string;\r\n    key?: string;\r\n    label?: ReactNode;\r\n    title?: ReactNode;\r\n    info?: Info | undefined;\r\n    tooltip?: boolean|string;\r\n\r\n    className?: string;\r\n    rootClassName?: string;\r\n    inputClassName?: string;\r\n    rootStyle?: GObject;// this goes to root\r\n    style?: GObject; // this goes at the root of <Input> or <Select> element(s)\r\n    inputStyle?: GObject; // this goes to the actual native <input> or <select> element(s)\r\n    hide?: undefined | boolean; // for autohiding Javascript editor\r\n    getter?: <T extends LPointerTargetable>(data: T, field: DocString<\"keyof T\">) => string;\r\n    setter?: <T extends LPointerTargetable>(value: string|boolean, data: T, field: DocString<\"keyof T\">) => void;\r\n\r\n    /*\r\n    they might be useful, but can just add them in without declaring all of them. i pass them like <input ...otherprops>\r\n    multiple?: boolean;  // multi value for select! works on file, email (just changes default validation pattern), and maybe others\r\n    size?: ??\r\n    accept?: string // only for type = 'file'\r\n    capture?: string // only for type = 'file'\r\n    autocomplete?: string; // only for <input> types\r\n    disabled?: boolean;\r\n    height?: string; // for 'image'\r\n    list?: string; // datalist\r\n    maxLength?: string; // chars\r\n    */\r\n    // many more skipped mostly for forms\r\n\r\n}\r\ntype OwnProps = _OwnProps & InputHTMLAttributes<Event>; // {[inputattribute:HTMLInputAttribute]: any};\r\n// private\r\ninterface StateProps {\r\n    // propsFromReduxStateOrOtherKindOfStateManagement: boolean; // flux or custom things too, unrelated to this.state of react.\r\n}\r\n\r\n// private\r\ninterface DispatchProps {\r\n    // propsFromReduxActions: typeof funzioneTriggeraAzioneDaImportare;\r\n}\r\n\r\n\r\n// private\r\ntype AllProps = OwnProps & StateProps & DispatchProps;\r\n\r\n////// mapper func\r\n\r\nfunction mapStateToProps(state: DState, ownProps: OwnProps): StateProps {\r\n    const ret: StateProps = {} as any;\r\n    /// to fill\r\n    return ret; }\r\n\r\nfunction mapDispatchToProps(dispatch: Dispatch<any>): DispatchProps {\r\n    const ret: DispatchProps = {} as any;\r\n    /// to fill\r\n    return ret; }\r\n\r\n\r\nexport const GenericInput = connect<StateProps, DispatchProps, OwnProps, DState>(\r\n    mapStateToProps,\r\n    mapDispatchToProps\r\n)(GenericInputComponent);\r\n\r\n\r\n/*\r\n\r\nSupported __info_of__.type values:\r\n\r\n\r\n- ShortAttribETypes     =   ecore type names\r\n- text                  =   for textarea\r\n- Function              =   for textarea\r\n- richtext              =   for monaco editor\r\n- native <input> types\r\n- DPointerTargetable    = will make a select out of available elements of that kind\r\n- GraphPoint            = will make a mini interactive square where you can select a point, output is in % [0, 1].\r\n                          NEED A SETTER AND GETTER to get from % to coords and the other way\r\n- GraphSize             = will make a mini interactive square where you can select a rectangle, output is in % [0, 1].\r\n                          NEED A SETTER AND GETTER to get from % to coords and the other way\r\n\r\n\r\n- typescript enumerators, with optgroups defined as following\r\n        (optgroup1) option1\r\n        option2 // assumed still in optgroup1\r\n        option3 // assumed still in optgroup1\r\n        (optgroup2) option4\r\n        if first option(s) are without optgroup, they are grouped in optgroup 'Options'\r\n\r\nNOT SUPPORT\r\n- 'EEnum' string, it is only used internally. pass it the whole enum.\r\nnative <input> not supported\r\n- radio\r\n- tel\r\n- search\r\n- reset\r\n- hidden\r\n- image\r\n- button\r\n- submit\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n* */\r\n","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\components\\forEndUser\\Aliases.tsx",["1365","1366","1367","1368","1369"],"import React, {Dispatch, ReactNode} from 'react';\r\nimport type {GObject} from '../../joiner';\r\nimport {U} from '../../joiner';\r\n\r\ntype OwnProps = GObject;\r\ntype StateProps = GObject;\r\ntype DispatchProps = GObject;\r\ntype AllProps = GObject; // Overlap<OwnProps, Overlap<StateProps, DispatchProps>>;\r\n\r\nexport function View(props: AllProps, children: ReactNode) {\r\n    // @ts-ignore\r\n    // console.log(\"VIEWW\", {props, thiss: this as any, args: arguments});\r\n    return(<view className={\"view \" + props.className}>{props.children || children}</view>); }\r\n\r\nView.cname = 'View';\r\n","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\components\\forEndUser\\Selector.tsx",["1370","1371","1372","1373","1374","1375","1376","1377","1378","1379","1380","1381"],"import {DPointerTargetable, LClass, LModel, Defaults, U, Input} from '../../joiner';\r\nimport {DState, GObject, LEnumerator, LPointerTargetable, Overlap, Pointer} from '../../joiner';\r\nimport React, {Dispatch, LegacyRef, ReactElement, ReactNode} from 'react';\r\nimport {connect} from 'react-redux';\r\nimport {useStateIfMounted} from 'use-state-if-mounted';\r\nimport './inputselect.scss';\r\n\r\n\r\nfunction SelectorComponent(props: AllProps) {\r\n    const data = props.data;\r\n    const [showTooltip, setShowTooltip] = useStateIfMounted(false);\r\n    if (!data) return(<></>);\r\n    let d: DPointerTargetable = data.__raw || data;\r\n    let l: LPointerTargetable = LPointerTargetable.fromD(data);\r\n    let gdata: GObject<LPointerTargetable> = data;\r\n    const field: (keyof LPointerTargetable & keyof DPointerTargetable) = props.field as any;\r\n    const readOnly = props.readonly !== undefined ? props.readonly : !props.debugmode && Defaults.check(data.id);\r\n    const value: string | Pointer = d[field] as string;\r\n    const label: string|undefined = props.label;\r\n    const jsxLabel: ReactNode|undefined = props.jsxLabel;\r\n    let tooltip: string|undefined = (props.tooltip === true) ? ((gdata['__info_of__' + field]) ? gdata['__info_of__' + field].txt: '') : props.tooltip;\r\n    tooltip = tooltip || '';\r\n    let css = '';//'my-auto select ';\r\n   // css += (jsxLabel) ? 'ms-1' : 'ms-auto';\r\n    css += (props.hidden) ? ' hidden-input' : '';\r\n\r\n    \r\n    /* @ts-ignore */\r\n    const setter = (id) => {l[field].value=id} \r\n    \r\n    /* @ts-ignore */\r\n\r\n    const getter = () => l[field].value;//l.$type.__raw.values[0];\r\n    \r\n\r\n    function SelectorChange(evt: React.ChangeEvent<HTMLSelectElement>) {\r\n        if (readOnly) return;\r\n\r\n        \r\n        const newValue = evt.target.value; \r\n        const oldValue = getter(); \r\n        setter(newValue);\r\n    }\r\n\r\n    // \r\n\r\n    function getOptions(): any {\r\n\r\n\r\n        {/*@ts-ignore*/}\r\n        switch (l[field].type.className) {\r\n            case 'DClass':\r\n                return (<>\r\n\r\n                    {/*@ts-ignore*/}\r\n                    {l[field].type.allInstances.map(cl =><>\r\n                        {/*@ts-ignore*/}\r\n                        {typeof(l[field].value) === 'undefined' ? \r\n                            <option value={cl.id}>{cl.name}</option> \r\n                            :\r\n                            <>\r\n                                {/*@ts-ignore*/}\r\n                                {l[field].value.id === cl.id ?\r\n                                <option value={cl.id} selected>{cl.name}</option> \r\n                                :\r\n                                <option value={cl.id}>{cl.name}</option>  \r\n                            }\r\n                            </>\r\n                        }\r\n        \r\n                    </>)}\r\n                </>); \r\n            break;\r\n            case 'DEnumerator':\r\n                \r\n                return (<>\r\n                    <option value=\"\" disabled selected>Select your option</option>\r\n                    {/*@ts-ignore*/}\r\n                    {l[field].type.literals.map(lit =><>\r\n                        \r\n                        {/*@ts-ignore*/}\r\n                        {typeof(l[field].value) === 'undefined' ? \r\n                            \r\n                            <option value={lit.id}>{lit.name}</option>\r\n                            :\r\n                            <>\r\n                                {/*@ts-ignore*/}\r\n                                {l[field].value.name === lit.name ?\r\n                                    <option value={lit.id} selected>{lit.name}</option> \r\n                                    :\r\n                                    <option value={lit.id}>{lit.name}</option>  \r\n                                }\r\n                            </>\r\n                        }\r\n        \r\n                    </>)}\r\n                </>);\r\n            break;\r\n            default:\r\n                return (U.alert('e', 'Unsupported type','Selector Component'));\r\n            break;\r\n\r\n        }\r\n\r\n\r\n\r\n        \r\n    }\r\n\r\n    const otherprops: GObject = {...props};\r\n    delete otherprops.data;\r\n    delete otherprops.getter;\r\n    delete otherprops.setter;\r\n    delete otherprops.jsxLabel;\r\n    delete otherprops.primitives;\r\n    delete otherprops.returns;\r\n    delete otherprops.hidden;\r\n    let cursor: string;\r\n    if (tooltip) cursor = 'help';\r\n    else if (readOnly) cursor = 'not-allowed';\r\n    else cursor = 'pointer';\r\n    let inputStyle = props.inputStyle || {};\r\n    if (!inputStyle.cursor && cursor === 'not-allowed') { inputStyle.cursor = cursor; }\r\n    U.objectMergeInPlace(inputStyle, props.inputStyle || {}, props.style || {});\r\n    let className = [props.className, props.inputClassName, css].join(' ');\r\n\r\n    let get_options = getOptions();\r\n\r\n    let select = (<select {...otherprops} className={className + ' model-select'} disabled={readOnly} placeholder={'-----'}\r\n            style={props.inputStyle}\r\n            value={value}\r\n            onChange={SelectorChange}>\r\n                {get_options ? get_options : U.alert('e', 'Error in Selector component', 'Something went wrong ...')}\r\n    </select>);\r\n\r\n\r\n    return select;\r\n}\r\n\r\nSelectorComponent.cname = 'SelectorComponent';\r\nexport interface SelectorOwnProps {\r\n    data?: DPointerTargetable | Pointer<DPointerTargetable, 1, 1, LPointerTargetable>;\r\n    field: string;\r\n    label?: string;\r\n    jsxLabel?: ReactNode;\r\n    tooltip?: boolean|string;\r\n    hidden?: boolean;\r\n    options?: JSX.Element;\r\n    key?: React.Key | null;\r\n    className?: string;\r\n    style?: GObject;\r\n    ref?: React.RefObject<HTMLElement> | LegacyRef<HTMLElement>;\r\n    readonly?: boolean;\r\n    inputClassName?: string;\r\n    inputStyle?: GObject;\r\n    // DANGER: use the data provided in parameters instead of using js closure, as the proxy accessed from using closure won't be updated in rerenders.\r\n    my_getter?: <T extends DPointerTargetable = any>(data: any | T | Pointer<T>, field: (string | number | symbol) | keyof T) => string;\r\n    // setter?: <T extends DPointerTargetable = any>(data: T | Pointer<T>, field: keyof T, selectedValue: string) => void;\r\n    // setter?: <T extends DPointerTargetable = any>(data: any | T | Pointer<T>, field: (string | number | symbol) | keyof T, selectedValue: string) => void;\r\n    my_setter?: (data: any, field: string, selectedValue: string) => void;\r\n\r\n}\r\ninterface StateProps {\r\n    debugmode: boolean,\r\n    data: LPointerTargetable;\r\n    primitives: LClass[];\r\n    returns: LClass[]; }\r\ninterface DispatchProps { }\r\n\r\ntype AllProps = Overlap<SelectorOwnProps, Overlap<StateProps, DispatchProps>>;\r\n\r\n\r\nfunction mapStateToProps(state: DState, ownProps: SelectorOwnProps): StateProps {\r\n    const ret: StateProps = {} as any;\r\n    if (!ownProps.data) return ret;\r\n    const pointer: Pointer = typeof ownProps.data === 'string' ? ownProps.data : ownProps.data.id;\r\n    ret.debugmode = state.debug;\r\n    ret.data = LPointerTargetable.fromPointer(pointer);\r\n    ret.primitives = LPointerTargetable.fromPointer(state.primitiveTypes);\r\n    ret.returns = LPointerTargetable.fromPointer(state.returnTypes);\r\n    return ret;\r\n}\r\n\r\nfunction mapDispatchToProps(dispatch: Dispatch<any>): DispatchProps {\r\n    const ret: DispatchProps = {};\r\n    return ret;\r\n}\r\n\r\n\r\nexport const SelectorConnected = connect<StateProps, DispatchProps, SelectorOwnProps, DState>(\r\n    mapStateToProps,\r\n    mapDispatchToProps\r\n)(SelectorComponent);\r\n\r\nexport const Selector = (props: SelectorOwnProps, children: (string | React.Component)[] = []): ReactElement => {\r\n    return <SelectorConnected {...{...props, children}} />;\r\n}\r\n\r\n\r\nSelectorComponent.cname = 'SelectorComponent';\r\nSelectorConnected.cname = 'SelectorConnected';\r\nSelector.cname = 'Selector';\r\nexport default Selector;\r\n","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\components\\forEndUser\\ControlPanel.tsx",[],"C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\components\\forEndUser\\Overlap.tsx",[],"C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\components\\forEndUser\\Input.tsx",["1382","1383","1384","1385","1386","1387","1388","1389","1390","1391","1392","1393","1394","1395","1396","1397"],"import React, {Dispatch, KeyboardEvent, LegacyRef, ReactElement, ReactNode, useRef} from 'react';\r\nimport {connect} from 'react-redux';\r\nimport {DState} from '../../redux/store';\r\nimport {\r\n    Any,\r\n    Defaults,\r\n    DObject,\r\n    DPointerTargetable,\r\n    GObject,\r\n    Keystrokes, LAttribute,\r\n    LClass, LEnumerator, LEnumLiteral, LModel, LObject,\r\n    LPointerTargetable, LReference, LStructuralFeature, LValue, MultiSelect, MultiSelectOptGroup,\r\n    MultiSelectOption,\r\n    Overlap,\r\n    Pointer, PrimitiveType, Selectors,\r\n    store,\r\n    U,\r\n    UX\r\n} from '../../joiner';\r\nimport {useStateIfMounted} from 'use-state-if-mounted';\r\nimport './inputselect.scss';\r\nimport { Tooltip } from './Tooltip';\r\n\r\nexport function getSelectOptions_raw(data: LPointerTargetable, field: string): MultiSelectOptGroup[] {\r\n    if (!data) return [];\r\n    switch (field){\r\n        default:\r\n        case 'extends':\r\n        case 'type':\r\n        case 'values': return (data as LValue | LStructuralFeature | LClass).validTargetOptions;\r\n    }\r\n    return [];\r\n}\r\n\r\nexport function getSelectOptions(data: LPointerTargetable, field: string, options: ReactNode, children?: ReactNode): ReactNode {\r\n    if (options) return options;\r\n    // children is auto-filled to empty array even if it is not set explicitly in jsx\r\n    if (Array.isArray(children) && children.length > 0) return children;\r\n    let ret: ReactNode | undefined;\r\n    switch (field) {\r\n        default:\r\n        case 'extends':\r\n        case 'type':\r\n        case 'values': return (data as LValue | LStructuralFeature | LClass).validTargetsJSX; break;\r\n    }\r\n    return ret;\r\n}\r\n    /*\r\n    export function getSelectOptions_raw(data: LPointerTargetable, field: string): MultiSelectOptGroup[] {\r\n        if (!data) return [];\r\n        // console.log(\"select options\", {data, field, children, options});\r\n        let returns: LClass[] | undefined;\r\n        let primitives: LClass[] | undefined;\r\n        let classes: LClass[] | undefined;\r\n        let enumerators: LEnumerator[] | undefined;\r\n        let objects: (LObject | LEnumLiteral)[] | undefined;\r\n        let m2classname: string | undefined;\r\n        let hasPrimitives: boolean = false;\r\n        let hasReturnTypes: boolean = false;\r\n        let cname = data.className;\r\n        if (!field) switch(cname) {\r\n            case 'DAttribute':  case 'DReference': case 'DOperation': case 'DParameter': field = 'type'; break;\r\n            case 'DValue': field = 'values'; break;\r\n            case 'DClass': field = 'extends'; break;\r\n        }\r\n    /*\r\n        let newmode = true;\r\n        if (newmode){\r\n            switch(field){\r\n                case 'extends': case 'type': return data.validTargetOptions;\r\n            }\r\n            return [];\r\n        }* /\r\n        switch(field) {\r\n            case 'type':\r\n                let model = (data as LStructuralFeature).model;\r\n                switch (cname) {\r\n                    default: break;\r\n                    case 'DAttribute': enumerators = model.enums; hasPrimitives = true; break;\r\n                    case 'DReference': classes = model.classes; break;\r\n                    case 'DOperation': classes = model.classes; enumerators = model.enums; hasPrimitives = hasReturnTypes = true; break;\r\n                    case 'DParameter': classes = model.classes; enumerators = model.enums; hasPrimitives = true; break;\r\n                }\r\n                break;\r\n            case 'value': case 'values':\r\n                if (cname !== 'DValue') break;\r\n                objects = (data as LValue).validTargets;\r\n                /*\r\n                let m2: LReference | LAttribute | undefined = (data as LValue).instanceof;\r\n                if (!m2) {\r\n                    objects = (data as LValue).model.allSubObjects;\r\n                    break;\r\n                }\r\n                let dm2 = m2.__raw;\r\n                if (dm2.className === \"DAttribute\") break;\r\n                let type: LClass = m2.type as LClass;\r\n                if (!type) break;\r\n                m2classname = type.name;\r\n                let m1modelid = data.model.id;\r\n                objects = (type.allInstances || []).filter( o => o.model.id === m1modelid);* /\r\n        }\r\n        let state: DState | undefined;\r\n        // todo: all this stuff might be better moved in mapstatetoprops, or the select list won't update properly.\r\n        if (hasPrimitives) {\r\n            if (!state) state = store.getState();\r\n            primitives = LPointerTargetable.fromPointer(state.primitiveTypes);\r\n        }\r\n        if (hasReturnTypes) {\r\n            if (!state) state = store.getState();\r\n            returns = LPointerTargetable.fromPointer(state.returnTypes);\r\n        }\r\n\r\n        // console.log(\"select options\", {data, field, returns, primitives, classes, enumerators});\r\n\r\n        let ret:MultiSelectOptGroup[] = [];\r\n        if (returns && returns.length) ret.push({label: 'Defaults', options: returns.map((r, i)=>({value: r.id, label:r.name}))});\r\n        if (primitives && primitives.length) ret.push({label: 'Primitives', options: primitives.map((r, i)=>({value: r.id, label:r.name}))});\r\n        if (enumerators && enumerators.length) ret.push({label: 'Enumerators', options: enumerators.map((r, i)=>({value: r.id, label:r.name}))});\r\n        if (classes && classes.length) ret.push({label: 'Classes#', options: classes.map((r, i)=>({value: r.id, label:r.name}))});\r\n        if (objects && objects.length) ret.push({label: m2classname ? 'Instances of ' + m2classname : \"All objects\", options:\r\n                [{value: undefined as any, label: '_empty_'}, ...objects.map((r, i)=>({value: r.id, label:r.name}))]});\r\n        return ret;\r\n    }\r\n    export function getSelectOptions(data: LPointerTargetable, field: string, options: ReactNode, children?: ReactNode): ReactNode {\r\n        if (options) return options;\r\n        // children is auto-filled to empty array even if it is not set explicitly in jsx\r\n        if (Array.isArray(children) && children.length > 0) return children;\r\n        let ret: ReactNode | undefined;\r\n        let newmode = true;\r\n        if (newmode){\r\n            switch(field){\r\n                case 'extends': case 'type': ret = (data as any).validTargetJSX; break;\r\n            }\r\n            console.log('msel ret opt', {ret, data, vt: (data as any).validTargetJSX, field})\r\n        }\r\n        if (ret) return ret;\r\n        let opts = getSelectOptions_raw(data, field); // old to remove?\r\n        return UX.options(opts); // selectOptionsToJSX(opts);\r\n    }\r\n    function selectOptionsToJSX(ret: MultiSelectOptGroup[]): ReactNode{\r\n        return(\r\n            <>{\r\n                ret.map(optgrp => <optgroup label={optgrp.label}>{\r\n                    optgrp.options.map((e, i) => <option key={i} value={e.value}>{e.label}</option>)\r\n                }</optgroup>).filter(e=>!!e)\r\n            }</>);\r\n    }*/\r\n\r\nexport function InputComponent(props: AllProps) {\r\n    const data = props.data;\r\n    const getter = props.getter;\r\n    const setter = props.setter;\r\n    const field: string = props.field as string;\r\n    const oldValue: PrimitiveType | PrimitiveType[] | LPointerTargetable = (getter) ? getter(data, field) : (data ? data[field] : undefined); // !== undefined); ? data[field] : 'undefined'\r\n    let [value, setValue] = useStateIfMounted<PrimitiveType | PrimitiveType[] | LPointerTargetable>(oldValue);\r\n\r\n    const [isTouched, setIsTouched] = useStateIfMounted(false);\r\n    const inputRef = useRef<Element | null>(null);\r\n    if (props.tag === 'select') value = oldValue; // select does not use state.\r\n    let serializeValue = (val: LPointerTargetable | PrimitiveType | PrimitiveType[], maxDepth=1, currDepth = 0): string | PrimitiveType | PrimitiveType[] => {\r\n        if (Array.isArray(val)) {\r\n            if (props.isMultiSelect && currDepth < maxDepth) {\r\n                // return val.map(e => serializeValue(e, maxDepth, currDepth + 1)) as PrimitiveType[];\r\n                return val.map(e => (e as any)?.id||e) as PrimitiveType[];\r\n            }\r\n            if (currDepth < maxDepth) return serializeValue(val[0], maxDepth, currDepth + 1);\r\n            else return undefined;\r\n        }\r\n        return (val as LPointerTargetable)?.id || (val as any);\r\n    };\r\n\r\n    function valueDidChange(v1: any, v2: any): boolean {\r\n\r\n        return serializeValue(v1) !== serializeValue(v2);\r\n        /*\r\n        let rawv1 = v1?.__raw || v1;\r\n        let rawv2 = v2?.__raw || v2;\r\n        if (rawv1 !== v1 || rawv2 !== v2) { return v1?.clonedCounter !== v2?.clonedCounter; }\r\n        return v1 !== v2;*/\r\n    }\r\n\r\n    // I check if the value that I have in my local state is being edited by other <Input />\r\n    if (props.tag !== 'select' && !isTouched && valueDidChange(value, oldValue)){\r\n        setValue(serializeValue(oldValue));\r\n        setIsTouched(false);\r\n    }\r\n\r\n\r\n    if (!((data && field) || (getter && setter))) return(<>Either props.data & field or both getter & setter are required.</>);\r\n    let readOnly: boolean;\r\n    if (props.readonly !== undefined) readOnly = props.readonly;\r\n    // else if (props.disabled !== undefined) readOnly = props.disabled;\r\n    else readOnly = props.debugmodee !== 'true' && Defaults.check(data?.id)\r\n\r\n    let type = (props.type) ? props.type : 'text';\r\n    let subtype: string = type;\r\n    switch (type) {\r\n        case 'toggle': type = 'checkbox'; subtype = 'switch'; break;\r\n        case 'checkbox3': case 'switch': type = 'checkbox'; break;\r\n        case 'slider': type = 'range'; break;\r\n    }\r\n    let label: ReactNode | undefined = props.jsxLabel || props.label;\r\n    let postlabel: ReactNode | undefined = props.postlabel;\r\n    let tooltip: ReactNode|string|undefined = ((props.tooltip === true) ? data?.['__info_of__' + field]?.txt : props.tooltip) || '';\r\n\r\n    let css = '';//'my-auto input ';\r\n    //css += (jsxLabel) ? 'ms-1' : (label) ? 'ms-auto' : '';\r\n    css += (props.hidden) ? ' hidden-input' : '';\r\n    let autosize: boolean = props.autosize === undefined ? false : props.autosize; // props.type==='text'\r\n    css += autosize ? ' autosize-input' : '';\r\n    const isBoolean = (['checkbox', 'radio'].includes(type));\r\n\r\n\r\n    const onChange = (evt: React.ChangeEvent<HTMLInputElement>) => {\r\n        (props as any).onChange?.(evt);\r\n        if (readOnly) return;\r\n\r\n        if (isBoolean) {\r\n            let target = evt.target.checked;\r\n            if (subtype === 'checkbox3' && !value) { target = undefined as any; }\r\n            if (setter) setter(target, data, field);\r\n            else data[field] = target;\r\n            setValue(target);\r\n            return;\r\n        }\r\n        if (props.tag === \"select\") {\r\n            confirmValue(evt as any);\r\n        } else {\r\n            //console.log(\"setValue\", {value, nv: getValueFromEvent(evt), evt, ev: evt.target.value});\r\n            setValue(getValueFromEvent(evt));\r\n            setIsTouched(true);     // I'm editing the element in my local state.\r\n            // the actual set is done in onBlur\r\n        }\r\n\r\n        \r\n    }\r\n    const onKeyDown = (evt: React.KeyboardEvent<HTMLInputElement>) => {\r\n        (props as any).onKeyDown?.(evt);\r\n        if (props.tag === 'select') return;\r\n        if (evt.key === Keystrokes.enter) confirmValue(evt as any);\r\n        if (evt.key === Keystrokes.escape) {\r\n            const oldValue = getter ? getter(data, field) : data[field];\r\n            writeHtmlValueFromEvent(evt as any, oldValue);\r\n            setValue(serializeValue(oldValue));\r\n            setIsTouched(false);\r\n            (evt.target as HTMLInputElement).blur();\r\n            // to optimize: probably can remove a large part of this function because this should trigger blur event as well. or move \"change\" event contents here\r\n            // optimize 2: memoize the whole component, so it won't update unless the displayed value changed. this would also fix cursor going to input end when pressing enter.\r\n        }\r\n    }\r\n    const getValueFromEvent = (evt: { target: HTMLInputElement | HTMLSelectElement | HTMLTextAreaElement }) => {\r\n        switch (props.tag){\r\n            case \"textarea\": case \"input\": case \"select\": case \"\": case null: case undefined: return evt.target.value;\r\n            default: return evt.target.innerText;\r\n        }\r\n    }\r\n    const writeHtmlValueFromEvent = (evt: { target: HTMLInputElement | HTMLSelectElement | HTMLTextAreaElement }, value: any) => {\r\n        value = serializeValue(value);\r\n        switch (props.tag){\r\n            case \"textarea\": case \"input\": case \"select\": case \"\": case null: case undefined: return evt.target.value = value;\r\n            default: return evt.target.innerText = value;\r\n        }\r\n    }\r\n\r\n    const onBlur = (evt: { target: HTMLInputElement | HTMLSelectElement | HTMLTextAreaElement }) => {\r\n        (props as any).onBlur?.(evt);\r\n        if (props.tag === 'select') return;\r\n        confirmValue(evt);\r\n    }\r\n    const confirmValue = (evt: { target: HTMLInputElement | HTMLSelectElement | HTMLTextAreaElement }|undefined, val?: PrimitiveType|PrimitiveType[]) => {\r\n        if (readOnly || isBoolean) return;\r\n        const newValue = val || (evt && getValueFromEvent(evt));\r\n        const oldValue = getter ? getter(data, field) : data[field];\r\n        console.log(\"onChange confirm\", {evt, newValue, oldValue, data, field, changed: valueDidChange(newValue, oldValue), readOnly, isBoolean, setter, nnv:serializeValue(newValue)});\r\n        if (valueDidChange(newValue, oldValue)){\r\n            if (setter) setter(newValue as any, data, field);\r\n            else data[field] = serializeValue(newValue);\r\n        }\r\n        // I terminate my editing, so I communicate it to other <Input /> that render the same field.\r\n        setIsTouched(false);\r\n    }\r\n\r\n    const otherprops: GObject = {...props};\r\n    delete otherprops.data;\r\n    delete otherprops.field;\r\n    delete otherprops.getter;\r\n    delete otherprops.setter;\r\n    delete otherprops.label;\r\n    delete otherprops.postlabel;\r\n    delete otherprops.jsxLabel;\r\n    delete otherprops.tooltip;\r\n    delete otherprops.hidden;\r\n    delete otherprops.inputStyle;\r\n    delete otherprops.children;\r\n    delete otherprops.autosize; // because react complains is bool in dom attribute or unknown attrib name\r\n\r\n    let checked: boolean | undefined = undefined;\r\n    if (isBoolean) checked = typeof value === \"boolean\" ? value : (typeof value === \"string\" ? U.fromBoolString(value) : !!value);\r\n\r\n    let cursor: string;\r\n    if (tooltip) cursor = 'help';\r\n    else if (readOnly) cursor = 'not-allowed';\r\n    else if (isBoolean) cursor = 'pointer';\r\n    else cursor = 'auto';\r\n\r\n    let inputProps: GObject = {...otherprops,\r\n        className: [props.inputClassName||'', css].join(' '),\r\n        style: (props.inputStyle || {}),\r\n        spellCheck: (props as any).spellCkeck || false, readOnly, disabled: readOnly, type,\r\n        value: serializeValue(value),\r\n        checked,\r\n        onChange, onBlur, onKeyDown} // key:`${field}.${data?.id}`\r\n    if (!inputProps.style.cursor && cursor === 'not-allowed') { inputProps.style.cursor = cursor; }\r\n    switch(subtype){\r\n        case 'checkbox3': case 'switch': case 'slider': inputProps.className += ' ' + subtype + (oldValue===undefined?'undetermined':''); break;\r\n        default: break;\r\n    }\r\n\r\n    let input: ReactNode;\r\n    let rootprops: GObject = {className: otherprops.className||'', style: otherprops.style||{}};\r\n    switch (typeof rootprops.ref) {\r\n        default: rootprops.ref = inputRef; break;\r\n        case \"object\":\r\n            let oldref = rootprops.ref;\r\n            rootprops.ref = (v: Element | null) => { oldref.current = inputRef.current = v; }\r\n            break;\r\n        case \"function\":\r\n            let oldreff = rootprops.ref;\r\n            rootprops.ref = (v: Element | null) => { oldreff(v); inputRef.current = v; }\r\n            break;\r\n    }\r\n    if (props.autosize) rootprops['data-value'] = inputProps.value;\r\n\r\n    if (tooltip) {\r\n        rootprops.onMouseEnter = () => Tooltip.show(tooltip, 'b', (rootprops.ref?.current) || rootprops.ref);\r\n        rootprops.onMouseLeave = () => Tooltip.hide();\r\n    }\r\n    /*let rootkeys = new Set(...Object.keys(rootprops));\r\n    //  merge events: might want to distinguish which events are merged between root and input and which not.\r\n    //  onChange surely needs merge. onMouseHover might not to let it trigger on label too.\r\n    for (let k of rootkeys) {\r\n        if (!(k[0] === 'o' && k[1] === 'n' && k[2] && k[2].toUpperCase() === k[2])) continue;\r\n        if (inputProps[k]) inputProps[k] = function(...a:any) { inputProps[k](arguments); rootprops[k](arguments); }\r\n        else inputProps[k] = rootprops[k];\r\n        delete rootprops[k];\r\n    }*/\r\n\r\n    let wrap = true;\r\n    if (autosize) rootprops.className = (rootprops.className || '') + ' autosize-input-container';\r\n    else if (!label && !postlabel && !props.isMultiSelect) {\r\n        if (rootprops.className) inputProps.className = rootprops.className + ' ' + inputProps.className;\r\n        if (rootprops.style) U.objectMergeInPlace(inputProps.style, rootprops.style);\r\n        inputProps = {...rootprops, ...inputProps};\r\n        wrap = false;\r\n    }\r\n\r\n    switch (props.tag){\r\n        case \"textarea\": input = <textarea {...inputProps}>{inputProps.value}</textarea>; break;\r\n        case \"select\":\r\n            if (props.isMultiSelect){\r\n                let options = props.options as any || getSelectOptions_raw(data, field);\r\n                let multiOptions = options as MultiSelectOptGroup[];\r\n                console.log('setting multiselect pre', {multiOptions, value, ivalue: inputProps.value, options, data, df:data[field], field});\r\n                let valuesMap = U.objectFromArrayValues((inputProps.value||[]));\r\n                delete valuesMap[undefined as any];\r\n                inputProps.value = [];\r\n                for (let optgrp of multiOptions) for (let opt of optgrp.options) if (valuesMap[opt.value]) inputProps.value.push(opt);\r\n                // rootprops.className = (rootprops.className || '') + ' clearfix';\r\n                let old = {...rootprops};\r\n                rootprops.onMouseMove = (e:any) => { UX.stopEvt(e); old.onMouseMove?.(); console.log('multiselect onmove'); };\r\n                /*rootprops.onMouseDown = (e:any) => { UX.stopEvt(e); old.onMouseDown?.(); console.log('multiselect onMouseDown'); };\r\n                rootprops.onMouseUp = (e:any) => { UX.stopEvt(e); old.onMouseUp?.(); console.log('multiselect onMouseUp'); };\r\n                rootprops.onClick = (e:any) => { UX.stopEvt(e); old.onClick?.(); console.log('multiselect onClick'); };\r\n                rootprops.onMouseLeave = (e:any) => { UX.stopEvt(e); old.onMouseLeave?.(); console.log('multiselect onMouseLeave'); };*/\r\n                // @ts-ignore\r\n                input = <MultiSelect {...inputProps} isMulti={true} options={options}\r\n                    onChange={((v0: MultiSelectOption[]) => {\r\n                        let v = v0.map(v => v.value);\r\n                        confirmValue(undefined, v);\r\n                        console.log('setting multiselect onchange', {v, v0, value, ivalue: inputProps.value, options});\r\n                    }) as any}\r\n                />;\r\n            }\r\n            else {\r\n                let options = getSelectOptions(data, field, props.options, props.children);\r\n                input = <select {...inputProps}>{options}</select>;\r\n            }\r\n            break;\r\n        case null: case undefined: case \"\": case \"input\": input = <input {...inputProps} />; break;\r\n        default:\r\n            inputProps.contentEditable = inputProps.contentEditable !== false;\r\n            input = React.createElement(props.tag, inputProps, props.children); break;\r\n    }\r\n    if (!wrap) return input;\r\n\r\n    if (typeof label === \"string\") label = <span>{label}</span>;\r\n    if (typeof postlabel === \"string\") postlabel = <span>{postlabel}</span>;\r\n\r\n    const openSelect = (e: any)=>{\r\n        /*\r\n        tried to make label click open the select but does not work easily in js, a solution was here but with css padding.\r\n        https://stackoverflow.com/questions/15249958/once-i-click-on-label-select-button-should-get-open\r\n        */\r\n        if (props.tag !== \"select\") return;\r\n        let t: HTMLElement = (e.target) as any;\r\n        let select = (t.tagName === 'select') ? t : t.querySelector('select');\r\n        console.log(\"click select root\", {t, select});\r\n        select?.click();\r\n    }\r\n    return <label className={'input-container'} {...rootprops} /*onClick={openSelect}*/>\r\n        {label || undefined}{input}{postlabel || undefined}</label>;\r\n    /*\r\n    return(<label className={'p-1'} {...otherprops}\r\n                  style={rootStyle}>\r\n\r\n        {label && <span className={'my-auto'} onMouseEnter={e => setShowTooltip(true)}\r\n                        onMouseLeave={e => setShowTooltip(false)}>{label}\r\n        </span>}\r\n\r\n        {jsxLabel && <span onMouseEnter={e => setShowTooltip(true)}\r\n                           onMouseLeave={e => setShowTooltip(false)} style={{width: '100%'}}>{jsxLabel}\r\n        </span>}\r\n\r\n        {(tooltip && showTooltip) && <div className={'my-tooltip'}>\r\n            <b className={'text-center text-capitalize'}>{field}</b>\r\n            <br />\r\n            <label>{tooltip}</label>\r\n        </div>}\r\n\r\n        {autosize ? <div className={(autosize ? 'autosize-input-container' : '') + (props.asLabel ? ' labelstyle' : '')}\r\n                         data-value={value}>{input}\r\n        </div> : input}\r\n    </label>);\r\n    */\r\n}\r\n\r\nexport interface InputOwnProps {\r\n    data?: LPointerTargetable | DPointerTargetable | Pointer<DPointerTargetable, 1, 1, LPointerTargetable>;\r\n    field?: string;\r\n    // DANGER: use the data provided in parameters instead of using js closure, as the proxy accessed from using closure won't be updated in rerenders.\r\n    getter?: (data: any/*LPointerTargetable*/, field: string) => string | boolean | undefined;\r\n    setter?: (value: string|boolean, data: any, field: string) => void;\r\n    label?: string | ReactNode;\r\n    postlabel?: string | ReactNode;\r\n    jsxLabel?: ReactNode; // @deprecated, use label\r\n    type?: 'checkbox'|'color'|'date'|'datetime-local'|'email'|'file'|'image'|'month'|'number'|'password'\r\n        |'radio'|'range'|'tel'|'text'|'time'|'url'|'week'\r\n        |'checkbox3'|'toggle'|'switch'|'slider';\r\n    className?: string;\r\n    style?: GObject;\r\n    readonly?: boolean;\r\n    tooltip?: boolean | ReactNode;\r\n    hidden?: boolean;\r\n    autosize?: boolean;\r\n    inputClassName?: string;\r\n    inputStyle?: GObject;\r\n    key?: React.Key | null;\r\n    placeholder?: string;\r\n    tag?: string;\r\n    children?: ReactNode;\r\n}\r\n\r\nexport interface SelectOwnProps extends Omit<InputOwnProps, 'setter'> {\r\n    options?: JSX.Element;\r\n    setter?: (value: string/*|PrimitiveType[]*/, data: any, field: string) => void; // parent select has value: string | boolean\r\n    isMultiSelect?: boolean;\r\n}\r\ninterface RealOwnProps extends Omit<SelectOwnProps, 'setter'>{\r\n    setter: InputOwnProps['setter'];\r\n}\r\n\r\ninterface StateProps {\r\n    debugmodee: string;\r\n    data: LPointerTargetable & GObject;\r\n    // selected: Dictionary<Pointer<DUser>, LModelElement | null>;\r\n}\r\ninterface DispatchProps { }\r\ntype AllProps = Overlap<RealOwnProps, Overlap<StateProps, DispatchProps>>;\r\n\r\n\r\nexport function InputMapStateToProps(state: DState, ownProps: RealOwnProps): StateProps {\r\n    const ret: StateProps = {} as any;\r\n    const pointer: Pointer | undefined = typeof ownProps.data === 'string' ? ownProps.data : ownProps.data?.id;\r\n    ret.debugmodee = state.debug ? 'true' : 'false';\r\n    if (pointer) ret.data = LPointerTargetable.fromPointer(pointer);\r\n    return ret;\r\n}\r\n\r\nfunction mapDispatchToProps(dispatch: Dispatch<any>): DispatchProps {\r\n    const ret: DispatchProps = {};\r\n    return ret;\r\n}\r\n\r\nexport const InputConnected =\r\n    // @ts-ignore\r\n    connect<StateProps, DispatchProps, RealOwnProps, DState>(InputMapStateToProps, mapDispatchToProps)(InputComponent);\r\n\r\n\r\n// export function Input(props: InputOwnProps, children: (string | React.Component)[] = []): ReactElement { return 'input' as any; }\r\nexport function Input(props: InputOwnProps): ReactElement {\r\n    // @ts-ignore\r\n    return <InputConnected {...props as any}>{props.children}</InputConnected>;\r\n}\r\n\r\n// export function TextArea(props: InputOwnProps, children: (string | React.Component)[] = []): ReactElement { return 'textarea' as any; }\r\nexport function TextArea(props: InputOwnProps, c: any): ReactElement {\r\n    // @ts-ignore\r\n    return <InputConnected {...{...props, tag:\"textarea\"} as any}>{props.children||c}</InputConnected>;\r\n}\r\n//export function Select(props: SelectOwnProps, children: (string | React.Component)[] = []): ReactElement { return 'select' as any; }\r\nexport function Select(props: SelectOwnProps, c: any): ReactElement {\r\n    // @ts-ignore\r\n    return <InputConnected {...{...props, tag:\"select\"} as any}>{props.children||c}</InputConnected>;\r\n}\r\nexport const Edit = Input;\r\n\r\n// @ts-ignore\r\nInputComponent.cname = 'InputComponent';\r\n// @ts-ignore\r\nInputConnected.cname = 'InputConnected';\r\nInput.cname = 'Input';\r\nTextArea.cname = 'TextArea';\r\nSelect.cname = 'Select';\r\nEdit.cname = 'Edit';\r\n","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\components\\forEndUser\\Try.tsx",["1398","1399","1400","1401","1402","1403","1404","1405","1406","1407","1408","1409"],"import React, {Dispatch, ErrorInfo, KeyboardEvent, ReactElement, ReactNode} from 'react';\r\nimport {connect} from 'react-redux';\r\nimport {DState} from '../../redux/store';\r\nimport {compressToBase64, compressToUTF16, decompressFromBase64, decompressFromUTF16} from \"async-lz-string\";\r\nimport {\r\n    Defaults,\r\n    DPointerTargetable,\r\n    DV,\r\n    GObject,\r\n    Keystrokes,\r\n    Log,\r\n    LPointerTargetable,\r\n    Overlap,\r\n    Pointer, store,\r\n    U, LoggerCategoryState\r\n} from '../../joiner';\r\nimport { DefaultView } from '../../common/DV';\r\n/*\r\n*   What's uncatched:\r\n*   - reducer\r\n*   - mapstatetoprops, if reducer doesn't do his job\r\n*\r\n*\r\n*\r\n*\r\n*\r\n* */\r\n\r\n// todo: after we have a server, instead of this, make an automatic error report with POST requests to the server without having the uri char limit\r\nclass TryComponent extends React.Component<AllProps, State> {\r\n    static cname: string = \"TryComponent\";\r\n    static mailRecipients = [\"damiano.divincenzo@student.univaq.it\", \"giordano.tinella@student.univaq.it\"];\r\n\r\n    constructor(props: AllProps) {\r\n        super(props);\r\n        this.state = { error: undefined, info: undefined, stateUpdateTime: 0, canUseClipboard: true};\r\n    }\r\n\r\n    static getDerivedStateFromError(error: Error) {\r\n        // Update state so the next render will show the fallback UI.\r\n        return { error, info: undefined }; // this first set an error and stops error propagation\r\n    }\r\n\r\n    private postGitIssue(content: string){\r\n        let owner = 'MDEGroup';\r\n        let repo = 'jjodel';\r\n        let obj = {\r\n            owner,\r\n            repo,\r\n            title: 'Automatic bug report',\r\n            body: content,\r\n            labels: [\r\n                'bug', 'auto-bug'\r\n            ],\r\n            headers: {\r\n                'X-GitHub-Api-Version': '2022-11-28'\r\n            }\r\n        }\r\n        this.postBugReport(`https://api.github.com/repos/${owner}/${repo}/issues`, JSON.stringify(obj));\r\n\r\n    }\r\n    private postBugReport(url: string, content: string){\r\n        var xhr = new XMLHttpRequest();\r\n        xhr.open(\"POST\", url, true);\r\n        xhr.setRequestHeader('Content-Type', 'application/json');\r\n        xhr.send(content);\r\n    }\r\n\r\n    componentDidCatch(error: Error, info: React.ErrorInfo): void {\r\n        console.error(\"uncatched error didcatch:\", {info});\r\n        // this is called after error propagation and a full render cycle is complete, i use it to trigger a rerender with more accurate infos.\r\n        this.setState({error, info, stateUpdateTime: this.props.stateUpdateTime});\r\n    }\r\n\r\n    render() {\r\n        /*\r\n        if (this.props.stateUpdateTime !== this.state.stateUpdateTime) {\r\n            // after a redux state update try checking if error is gone\r\n            return this.props.children;\r\n        }*/\r\n        if (this.state.error) {\r\n            // You can render any custom fallback UI\r\n            return this.catch(this.state.error, this.state.info);\r\n        }\r\n        if (Array.isArray(this.props.children)) {\r\n            console.error(\"<Try /> can have only 1 subcomponent\", this.props.children, this);\r\n            return this.catch({message: \"<Try /> can have only 1 subcomponent. If you need more wrap them inside a <>React.fragment</>\"} as any, undefined);\r\n        }\r\n        if (!React.isValidElement(this.props.children)) {\r\n            // You can render any custom fallback UI\r\n            console.error(\"Children is not a valid React Element\", this.props.children, this);\r\n            return this.catch({message: \"Children is not a valid React Element\"} as any, undefined);\r\n        }\r\n        return this.props.children;\r\n    }\r\n    reset(){\r\n        this.setState({error:undefined, info: undefined, lz: undefined});\r\n    }\r\n\r\n    catch(error: Error, info?: React.ErrorInfo): ReactNode{\r\n        console.error(\"uncatched error:\", {state:{...this.state}});\r\n        let debug = false;\r\n        if (debug) return<div>error</div>;\r\n        if (this.props.catch) {\r\n            try {\r\n                if (typeof this.props.catch === \"function\") return this.props.catch(error, info);\r\n                if (React.isValidElement(this.props.catch)) return this.props.catch;\r\n            }\r\n            catch (e) {\r\n                console.error(\"uncatched error WITH INVALID CATCHING FUNC\", {catcherFuncError:e});\r\n            }\r\n        }\r\n\r\n\r\n        let state: DState = store.getState();\r\n        let title = \"Jodel assisted error report V\"+state?.version?.n;\r\n        (window as any).tryerror = error;\r\n        let reportstr = this.state.lz || this.stringreport(Log.getByError(error));\r\n        let mongoreport = {state: state, when: new Date()+'', e:{'stack':error.stack, 'msg':error.message}, compostack: info?.componentStack};\r\n        // todo giordano: salva report su mongodb\r\n\r\n        const msgbody_notencoded: string = \"This mail is auto-generated, it might contain data of your views or model.\\n\" +\r\n            \"If your project have sensitive personal information please do a manual report instead.\"+// check the report below to omit them.\\n\\n\" +\r\n            \"\" + error?.message + \"\\n\\n\" +\r\n            (reportstr ? 'logger report'+(this.state.lz ? ' (lz-base64)' : '')+':\\n' + encodeURIComponent(reportstr) +'\\n\\n' : '') +\r\n            \"_stack:\\n\" + U.cropStr(error.stack || '', 30, 0, 35, 15) + '\\n\\n'+\r\n            \"_component_stack:\\n\" + (info ? U.cropStr(info.componentStack, 10, 0, 35, 5) : '');\r\n\r\n        let {mailto, gitissue} = U.mailerror(TryComponent.mailRecipients, title, msgbody_notencoded, this.state.canUseClipboard,\r\n            undefined, ()=>{this.setState({canUseClipboard: false})});\r\n\r\n        let shortErrorBody = (error?.message || \"\\n\").split(\"\\n\")[0];\r\n        let visibleMessage: ReactNode = <div onClick={()=> this.reset()}>\r\n            <div>{info ? \"has info\": \"###########\"}</div>\r\n            <div>ut:{this.state.stateUpdateTime}, { shortErrorBody }</div>\r\n            <div>What you can try:</div>\r\n            <ul>\r\n                <li>- Undo the last change</li>\r\n                <li>- {mailto && [<a href={mailto}>Mail the developers</a>, \" or\"]} <a href={gitissue} target=\"_blank\">open an issue</a></li>\r\n            </ul>\r\n            {state.debug ? this.decompress() : undefined}\r\n        </div>\r\n        return DefaultView.error(visibleMessage, \"unhandled\");\r\n    }\r\n\r\n    decompress(){\r\n        function dec(e:any){\r\n            e.stopPropagation();\r\n            let s: any=undefined, s1: any=undefined, s2:Promise<string>=undefined as any, o: any=undefined;\r\n            try { s = e.target.value; } catch (e) {\r\n                console.error(\"crashed decompress\", e);\r\n            }\r\n            try { s1 = decodeURIComponent(s); } catch (e) {\r\n                console.error(\"crashed decompress uri\", e);\r\n            }\r\n            try { s2 = decompressFromBase64(s1); } catch (e) {\r\n                console.error(\"crashed decompress lz\", e);\r\n            }\r\n            if (s2) {s2.then(v=> {\r\n                try { o = JSON.parse(s2=v as any) } catch (e) { console.error(\"crashed decompress p\", e, v); }\r\n            }).finally(()=>{\r\n                let out = {s, uri:s1, lz:s2, o};\r\n                console.log('decompress final', out);\r\n                $('#decompress')[0].innerText = JSON.stringify(o ||  out, null, 4);\r\n\r\n            })} else {\r\n                let out = {s, uri:s1, lz:s2, o};\r\n                console.log('decompress else', out);\r\n                $('#decompress')[0].innerText = JSON.stringify(o ||  out, null, 4);\r\n            }\r\n        }\r\n        return (<><span>Debug mode: paste error report to decompress it.</span><textarea className={\"w-100\"} onChange={dec}></textarea><textarea id={\"decompress\"} className={\"w-100\"} /></>);\r\n    }\r\n\r\n\r\n    private stringreport(loggerReport0?: GObject): string | undefined{\r\n        if (!loggerReport0) return undefined;\r\n        let loggerReport = {...loggerReport0};\r\n        (window as any).loggerReport = loggerReport;\r\n        delete loggerReport.exception;\r\n        loggerReport = U.cropDeepObject(loggerReport);\r\n        loggerReport.time = loggerReport0.time; // do not \"crop\" timestamp\r\n        delete loggerReport.short_string\r\n        let s = JSON.stringify(U.cropDeepObject(loggerReport));\r\n        /*(window as any).compressToUTF16 = compressToUTF16;\r\n        (window as any).decompressFromUTF16 = decompressFromUTF16;\r\n        (window as any).compressToBase64 = compressToBase64;\r\n        (window as any).decompressFromBase64 = decompressFromBase64;\r\n        (window as any).ss = s;*/\r\n        // or: LZString.compressToBase64()\r\n        if (s.length > 100) compressToBase64(s).then((v)=> this.setState({lz:v}));\r\n        return s;\r\n    }\r\n}\r\ninterface State{\r\n    error?: Error;\r\n    info?: React.ErrorInfo;\r\n    stateUpdateTime: number;\r\n    canUseClipboard: boolean;\r\n    lz?: string;\r\n}\r\ninterface OwnProps {\r\n    key?: React.Key | null;\r\n    catch?: ReactNode | ((error: Error, info?: React.ErrorInfo) => ReactNode);\r\n    children: ReactNode;\r\n}\r\ninterface StateProps {\r\n    stateUpdateTime: number;\r\n}\r\ninterface DispatchProps { }\r\ntype AllProps = Overlap<OwnProps, Overlap<StateProps, DispatchProps>>;\r\n\r\nlet rendercount: number = 0;\r\nfunction mapStateToProps(state: DState, ownProps: OwnProps): StateProps {\r\n    const ret: StateProps = {} as any;\r\n    ret.stateUpdateTime = rendercount++; // new Date().getTime();\r\n    return ret;\r\n}\r\n\r\nfunction mapDispatchToProps(dispatch: Dispatch<any>): DispatchProps {\r\n    const ret: DispatchProps = {};\r\n    return ret;\r\n}\r\n\r\nconst TryConnected =\r\n    connect<StateProps, DispatchProps, OwnProps, DState>(mapStateToProps, mapDispatchToProps)(TryComponent);\r\n\r\n\r\nexport function Try(props: OwnProps): ReactElement {\r\n    return <TryConnected {...{...props}}>{props.children}</TryConnected>;\r\n}\r\n\r\nTryComponent.cname = 'TryComponent';\r\nTryConnected.cname = 'TryConnected';\r\nTry.cname = 'Try';\r\n","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\components\\forEndUser\\Control.tsx",["1410","1411","1412","1413","1414","1415","1416","1417","1418","1419","1420"],"import {ClickEvent, ControlPanel, LGraphElement, SetRootFieldAction, U} from \"../../joiner\";\r\nimport { ReactElement, ReactNode, useEffect, useRef, useState } from \"react\";\r\n\r\nimport \"./control.scss\";\r\nimport { useStateIfMounted } from \"use-state-if-mounted\";\r\nimport { Tooltip } from \"./Tooltip\";\r\nimport { VertexOwnProps } from \"../../graph/graphElement/sharedTypes/sharedTypes\";\r\nimport { useEffectOnce } from \"usehooks-ts\";\r\n\r\n\r\n/* Notification */\r\n\r\ntype Widget = 'control'|'slider'|null;\r\ntype Field = 'node'|'name'|'children'|null;\r\ntype ErrorType = 'missing'|null;\r\n\r\ntype NotificationProps = {\r\n    widget: Widget,\r\n    field: Field,\r\n    type: ErrorType,\r\n    suggestion?: string\r\n}\r\nconst Notification = (props: NotificationProps) => {\r\n\r\n    return (\r\n        <div className=\"control-widget control-notification\">\r\n            <div className=\"control-header\">\r\n                <h1>You forgot something...</h1>\r\n                {props.type && <h2>Missing '{props.field}'' in '{props.widget}' in template definition.</h2>}\r\n            </div>\r\n\r\n            {props.suggestion && <p>{props.suggestion}</p>}\r\n        </div>\r\n    );\r\n\r\n}\r\n\r\ntype CheckReturnTYpe = {\r\n    error: boolean;\r\n    notification: any;\r\n}\r\n\r\nconst CheckProps = (widget: Widget, props: any): any => {\r\n\r\n    let result:any = false;\r\n    let notification: any|null = null;\r\n    let field: Field = null;\r\n    let type: ErrorType = null;\r\n    let suggestion = '';\r\n\r\n    switch(widget) {\r\n        case 'control':\r\n            if (!props.children) {\r\n                alert('You did not specify any children in <Control ...> </Control>');\r\n                // field = 'children';\r\n                // type = 'missing';\r\n                // suggestion = 'You did not specify any children in <Control ...> </Control>';\r\n                // notification = <Notification widget={widget} field={field} type={type} suggestion={suggestion}/>;\r\n                result = true;\r\n            }\r\n        break;\r\n        case 'slider':\r\n            if (!props.node) {\r\n                alert('You did not specify node in <Slider .../>');\r\n                // field = 'node';\r\n                // type = 'missing';\r\n                // suggestion = '';\r\n                // notification = <Notification widget={widget} field={field} type={type} suggestion={suggestion}/>;\r\n                result = true;\r\n\r\n            }\r\n            if (!props.name) {\r\n                alert('You did not specify name in <Slider .../>');\r\n                field = 'name';\r\n                type = 'missing';\r\n                suggestion = 'You did not specify name in <Slider .../>';\r\n                notification = <Notification widget={widget} field={field} type={type} suggestion={suggestion}/>;\r\n                result = true;\r\n            }\r\n        break;\r\n    }\r\n\r\n    return result;\r\n}\r\n\r\n\r\ntype ControlProps = {\r\n    children: any;\r\n    title?: string;\r\n    payoff?: string;\r\n    icon?: boolean;\r\n}\r\n\r\nfunction useClickOutside(ref: any, onClickOutside: any) {\r\n    useEffect(() => {\r\n\r\n        function handleClickOutside(event: Event) {\r\n            if (ref.current && !ref.current.contains(event.target)) {\r\n                onClickOutside();\r\n            }\r\n        }\r\n\r\n      // Bind\r\n      document.addEventListener(\"mousedown\", handleClickOutside);\r\n      return () => {\r\n        // dispose\r\n        document.removeEventListener(\"mousedown\", handleClickOutside);\r\n      };\r\n    }, [ref, onClickOutside]);\r\n  }\r\n\r\n\r\n/*  Control */\r\n\r\nconst ControlComponent = (props: ControlProps, children?:ReactNode) => {\r\n    \r\n    const [controlOpen, setControlOpen] = useStateIfMounted(false);\r\n\r\n    const toggleValue = () => {\r\n        setControlOpen(!controlOpen);\r\n\r\n    }\r\n\r\n\r\n    function onClick(e: any){\r\n        console.log('setup hide control');\r\n        U.clickedOutside(e, ()=> {\r\n            console.log('hide control');\r\n            setControlOpen(false)\r\n        });\r\n    }\r\n    return (<div className={`jjodel-control-root`} onClick={onClick}>\r\n        <div className={`jjodel-control d-flex flex-row ${controlOpen ? 'opened' : 'closed'}`}>\r\n            <div className={'control-header'}>\r\n                <h1>{props.title}</h1>\r\n                <h2>{props.payoff}</h2>\r\n            </div>\r\n            {props.children || children}\r\n        </div>\r\n        <div className={'jjodel-control-icon'}>\r\n            <i onClick={(e) => {toggleValue()}} className=\"bi bi-toggles\"/>\r\n        </div>\r\n    </div>);\r\n}\r\n\r\nconst Control = (props: VertexOwnProps, children: ReactNode = []): ReactElement => {\r\n    return <ControlComponent {...props}>{children || props.children}</ControlComponent>;\r\n}\r\n\r\n\r\n/* Slider */\r\n\r\ntype SliderProps = {\r\n    node: LGraphElement;\r\n    name?: string;\r\n    defaultValue?:number;\r\n    title?:string;\r\n    min?: number;\r\n    max?: number;\r\n    step?: number;\r\n    label?: string;\r\n}\r\n\r\nconst SliderComponent = (props: SliderProps) => {\r\n\r\n    const min = props.min ? props.min : 0;\r\n    const max = props.max ? props.max : 10;\r\n    const step = props.step ? props.step : 1;\r\n    const defaultValue = props.defaultValue ? props.defaultValue : max;\r\n    const name = props.name;\r\n\r\n    useEffectOnce(\r\n        () => {\r\n            {/* @ts-ignore */}\r\n            props.node.state = {[name] : defaultValue};\r\n        }\r\n    );\r\n\r\n    function updateValue(value: number) {\r\n        // @ts-ignore\r\n        props.node.state = {[name]: value};\r\n    }\r\n\r\n\r\n    return (\r\n        <>\r\n            {CheckProps('slider', props) || <div className={'control-widget control-slider'}>\r\n\r\n                <div className={'track'}\r\n                    style={{transition: 'width 0.3s', position: 'relative', left: '10px',\r\n                        width: `calc(((100%/${max} - 8px) * ${props.node.state[name as string]}))`}}\r\n                >\r\n\r\n                </div>\r\n\r\n                <input\r\n                    type={'range'}\r\n                    min={min}\r\n                    max={max}\r\n                    step={step}\r\n                    onChange={(e)=>{updateValue(+e.target.value)}} />\r\n\r\n                {/* @ts-ignore */}\r\n                {props.title && <div className={'tip'}>{props.title} <label>{props.node.state[name]}</label></div>}\r\n                </div>\r\n            }\r\n        </>);\r\n}\r\n\r\nconst Slider = (props: SliderProps, children: ReactNode = []): ReactElement => {\r\n    return <SliderComponent {...props} />;\r\n}\r\n\r\n\r\n/* Toggle */\r\n\r\ntype ToggleValues = {\r\n    true: string;\r\n    false: string;\r\n}\r\n\r\ntype ToggleProps = {\r\n    name: string;\r\n    values?: ToggleValues;\r\n    labels?: ToggleValues;\r\n    size?: string;\r\n    style?: React.CSSProperties;\r\n    title?: string;\r\n};\r\n\r\nconst ToggleComponent = (props: ToggleProps) => {\r\n    const [value, setValue] = useState<boolean>(false);\r\n    const defaultValue = false;\r\n\r\n    const labels = props.labels ? props.labels : {true: 'On', false: 'Off'};\r\n\r\n    useEffectOnce(\r\n        () => {\r\n            {/* @ts-ignore */}\r\n            props.node.state = {[props.name] : defaultValue};\r\n        }\r\n    );\r\n\r\n    function updateValue(value: boolean) {\r\n        // @ts-ignore\r\n        props.node.state = {[props.name]: value};\r\n    }\r\n\r\n    function toggleValue() {\r\n        const newValue = !value;\r\n        setValue(newValue);\r\n\r\n        // @ts-ignore\r\n        props.node.state = {[props.name]: newValue};\r\n    }\r\n    // // updateValue(+e.target.value) \r\n\r\n    return (<>\r\n        \r\n        <div className={'toggle'} onClick={(e) => {toggleValue()}}>\r\n            <input type={'checkbox'} className={'toggle-input'} id={props.name} checked={value} onChange={(e)=>{alert(e.target.value)}}  onClick={(e) => alert('input, click')} /> \r\n\r\n            <label onClick={() => alert()} className={'toggle-label'}></label>\r\n\r\n            <div className={\"toggle-labels\"}>\r\n                {value ?\r\n                    <span className={\"toggle-on\"}>{labels['true']}</span>\r\n                    :\r\n                    <span className={\"toggle-off\"}>{labels['false']}</span>\r\n                }\r\n            </div>\r\n            <div className={\"tip\"}>{props.title}</div>\r\n\r\n        </div></>\r\n    );\r\n}\r\n\r\nconst Toggle = (props: ToggleProps, children: ReactNode = []): ReactElement => {\r\n    return <ToggleComponent {...props} />;\r\n}\r\n\r\nexport {Control, Slider, Toggle};\r\n\r\n","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\components\\forEndUser\\Measurable.tsx",["1421","1422","1423","1424","1425","1426"],"import React, {Component, CSSProperties, PureComponent, ReactChild, ReactElement, ReactNode} from \"react\";\r\nimport {DGraphElement, Dictionary, GObject, GraphSize, LGraph, Log, RuntimeAccessible, Size, TRANSACTION, U} from \"../../joiner\";\r\nimport $ from \"jquery\";\r\n/// <reference path=\"../../common/libraries/jqui-types.ts\" />\r\nimport {JQueryUI} from \"../../common/libraries/jqui-types\"\r\nimport \"./Measurable.scss\";\r\n\r\ntype ResizableEvent = JQueryUI.ResizableEvent;\r\ntype DraggableEvent = JQueryUI.DraggableEvent;\r\ntype RotatableEvent = JQueryUI.RotatableEvent;\r\ntype DraggableOptions = JQueryUI.DraggableOptions;\r\ntype ResizableOptions = JQueryUI.ResizableOptions;\r\ntype RotatabeOptions = JQueryUI.RotatableOptions;\r\n// private\r\ninterface MeasurableState {\r\n}\r\ninterface ScrollState {\r\n}\r\n\r\ntype EventLetter = 's'|'ing'|'e';\r\ntype MeasurableUIEvent = ResizableEvent | DraggableEvent | RotatableEvent;\r\n\r\n@RuntimeAccessible('MeasurableComponent')\r\nexport class MeasurableComponent extends Component<MeasurableAllProps, MeasurableState>{\r\n    static cname: string = \"MeasurableComponent\";\r\n    static childmodekeys: (keyof CSSStyleDeclaration)[] = ['left', 'top', 'transform', 'position'];\r\n\r\n\r\n    private html: Element | null = null;\r\n    private $html!:  JQuery<Element>;\r\n    dragOptionsChanged: boolean = true;\r\n    resizeOptionsChanged: boolean = true;\r\n    rotateOptionsChanged: boolean = true;\r\n    defaultOptions: {\"draggable\": JQueryUI.DraggableOptions, resizable: JQueryUI.ResizableOptions, rotatable: GObject} = {\r\n        draggable: {\r\n            cancel: '.no-drag,[contenteditable=\"true\"],input,textarea,button,select,option',\r\n            cursor: 'grabbing',\r\n            // containment: 'parent',\r\n            distance: 5,\r\n            // helper: 'clone', // 'original' or 'csselector'? or func=>html\r\n            // disabled: !(view.draggable),}\r\n        },\r\n        resizable: {},\r\n        rotatable: {},\r\n    }\r\n    oldPos: Dictionary<string, number> = {left: undefined, top: undefined} as any;\r\n\r\n    componentDidMount() {\r\n        this.afterUpdate();\r\n    }\r\n    componentDidUpdate(prevProps: Readonly<MeasurableAllProps>, prevState: Readonly<MeasurableState>, snapshot?: any) {\r\n        this.afterUpdate();\r\n    }\r\n\r\n    afterUpdate(): void{\r\n        if (!this.html) return;\r\n        this.$html = $(this.html);\r\n        if (this.dragOptionsChanged) { this.afterUpdateSingle(\"draggable\"); }\r\n        if (this.resizeOptionsChanged) { this.afterUpdateSingle(\"resizable\"); }\r\n        if (this.rotateOptionsChanged) { this.afterUpdateSingle(\"rotatable\"); }\r\n    }\r\n    /*\r\n        afterUpdateSingle(type: \"draggable\" | \"resizable\" | \"rotatable\"): void{\r\n            if (this.props.draggable) this.afterUpdateDraggable\r\n        }/*\r\n        afterUpdateDraggable_old(): void{\r\n            nope, erase this and just make the previous _old genericversion with inner dynamic functions called 9 times like event('drag', 'while'); event('drag', 'end'); event('resize', 'while');...\r\n            make and extract new functions from code so that it dinamically build the jqui options object\r\n            if (!this.$html) return;\r\n            let $measurable = this.$html;\r\n            let jqui_options = this.props.draggable;\r\n            let jqui_start = jqui_options === 'object' ? jqui_options.start : undefined;\r\n            let jqui_end = jqui_options === 'object' ? jqui_options.stop : undefined;\r\n            let jqui_ing = jqui_options === 'object' ? jqui_options.drag : undefined;\r\n            let props_start = this.props.onDragStart;\r\n            let props_end = this.props.onDragEnd;\r\n            let props_ing = this.props.whileDragging;\r\n            let type = 'draggable';\r\n\r\n\r\n            //let positionMap = new WeakMap<HTMLElement, {left: number; top: number}>();\r\n            let childmode_drag = (e: HTMLElement, evt?: any, evtkind?: EventLetter, ui?:any): void => {\r\n                let oc = this.props.onChildren;\r\n                if (!oc) {\r\n                    Log.ee('not oc', {evt, oc, e, p: this.props}); return;\r\n                }\r\n                let child: HTMLElement;\r\n                if (typeof oc === 'function') child = oc(e);\r\n                else child = e.children[0] as HTMLElement;\r\n                if (!child) {\r\n                    Log.ee('child not found', {child, evt, oc, e}); return;\r\n                }\r\n                let oldpos = this.oldPos; // positionMap.get(e);\r\n                console.log('measurable default event child ' + evtkind, {ui, e, oc, oldpos});\r\n                //if (evtkind === 'e') { positionMap.set(e, ui.position); }\r\n\r\n                /*if (evtkind === 's') {\r\n                    ui.originalPosition.left = 300;\r\n                    ui.offset.left = 300;\r\n                    ui.position.left = 300;\r\n                    console.log('measurable sstart ', {type, e, oc, ui, el: e.style.left, cl: child.style.left});\r\n                }* /\r\n\r\n                let key: any;\r\n                for (key of childmodekeys) {\r\n                    let fixpos = () => {\r\n                        if (oldpos && (oldpos as any)[key] !== undefined) {\r\n                            if (key ==='left') console.log('measurable fixpos ' + evtkind, (oldpos as any)[key] + ui.position[key] + 'px', (oldpos as any)[key]);\r\n                            let newpos = (oldpos as any)[key] + ui.position[key];\r\n                            child.style[key] = (newpos) + 'px';\r\n                            if (evtkind === 'e') this.oldPos[key] = newpos;\r\n                        }\r\n                        else child.style[key] = e.style[key];\r\n                    }\r\n                    fixpos();\r\n                    if (evtkind === 'e')  setTimeout(fixpos, 1000);\r\n                    if (evtkind === 's' && !e.classList.contains('draggable-child-mode')) e.classList.add('draggable-child-mode');\r\n                    // delete e.style[key]\r\n                }\r\n            }\r\n\r\n            let translateeevents: Dictionary<string, Dictionary<string, DraggableEvent>> = {\r\n                'draggable': {\r\n                    's': (e, ui)=>{ this.absoluteToTransform(e.target as HTMLElement, e, 's'); },\r\n                    'ing': (e, ui)=>{ this.absoluteToTransform(e.target as HTMLElement, e, 'ing'); },\r\n                    'e': (e, ui)=>{ this.absoluteToTransform(e.target as HTMLElement, e, 'e'); }},\r\n            };\r\n            let defaulteevent = (evtkind: EventLetter): MeasurableUIEvent | null =>{\r\n                if (!this.props.transformMode && !this.props.onChildren) return null;\r\n                return (e: any, ui: any) => {\r\n                    //console.log('measurable default event', {type, evtkind, translateeevents, e, t: e.target});\r\n                    if (this.props.transformMode === true) translateeevents[type][evtkind](e, ui);\r\n                    childmode_drag(e.target, e, evtkind, ui);\r\n                }\r\n            };\r\n\r\n            if (props[optionkey] === false || !props[optionkey]) {\r\n                console.log(\"measurable off \" + type, {$measurable, type, datamap, optionkey, props});\r\n                if ($measurable.data(datamap[type])) ($measurable as GObject)[type]('disable');\r\n                return;\r\n            }\r\n            if (props[optionkey] === true) {\r\n                options = {};\r\n            } else options = {...props[optionkey]};\r\n\r\n            if (props_start && typeof props_start !== \"function\") { return Log.ee(\"<Measurable /> onDragStart props must be a function\"); }\r\n            if (props_end && typeof props_end !== \"function\") { return Log.ee(\"<Measurable /> onDragEnd props must be a function\"); }\r\n            if (props_ing && typeof props_ing !== \"function\") { return Log.ee(\"<Measurable /> whileDragging props must be a function\"); }\r\n            if (!jqui_start && !props_start && ! default_start) delete options.start,\r\n                else options.start = (evt, ui) => { default_start?.(evt, ui); jqui_start?.(evt, ui); props_start?.(thiss.getCoords(evt, ui), evt, ui); }\r\n\r\n            let propsOptions = {...options};\r\n            let defaultOptions = this.defaultOptions[type];\r\n            U.objectMergeInPlace(options, defaultOptions);\r\n            //console.log(\"measurable\", {type, $measurable, options, propsOptions, defaultOptions});\r\n            ($measurable as GObject)[type](options);\r\n        }*/\r\n\r\n    absoluteToTransform(e: HTMLElement, evt?: any, evtkind?: EventLetter): any {\r\n        let x = e.style.left;\r\n        let y = e.style.top;\r\n        /*\r\n            e.style.left = '0px';\r\n            e.style.top = '0px';*/\r\n        //e.style.position = 'unset';\r\n        e.style.transform = `translate(${x}, ${y})`;\r\n    }\r\n    childmode(e: HTMLElement, evt?: any, evtkind?: EventLetter, ui?:any): void{\r\n        let oc = this.props.onChildren;\r\n        if (!oc) {\r\n            Log.ee('not oc', {evt, oc, e, p: this.props}); return;\r\n        }\r\n        let child: HTMLElement;\r\n        console.log('cchild', {e, evt,  evtkind, ui});\r\n        if (typeof oc === 'function') child = oc(e);\r\n        else child = e.children[0] as HTMLElement;\r\n        if (!child) {\r\n            Log.ee('child not found', {child, evt, oc, e}); return;\r\n        }\r\n        console.log('measurable default event child ' + evtkind, {ui, e, oc, oldpos: this.oldPos});\r\n        //if (evtkind === 'e') { positionMap.set(e, ui.position); }\r\n\r\n        /*if (evtkind === 's') {\r\n            ui.originalPosition.left = 300;\r\n            ui.offset.left = 300;\r\n            ui.position.left = 300;\r\n            console.log('measurable sstart ', {type, e, oc, ui, el: e.style.left, cl: child.style.left});\r\n        }*/\r\n\r\n        let key: any;\r\n        for (key of MeasurableComponent.childmodekeys) {\r\n            let fixpos = () => {\r\n                let oldpos = this.oldPos; // positionMap.get(e); {x:-1000, y:-3000};//\r\n                if (oldpos && (oldpos as any)[key] !== undefined) {\r\n                    let newpos = (oldpos as any)[key] + ui.position[key];\r\n                    if (key ==='left') console.log('measurable fixpos ' + newpos + 'px', (oldpos as any)[key], {oldpos, uipos:ui.position, newpos});\r\n                    child.style[key] = (newpos) + 'px';\r\n                    if (evtkind === 'e') this.oldPos[key] = newpos;\r\n                }\r\n                else child.style[key] = e.style[key];\r\n            }\r\n            if (evtkind === 'e') setTimeout(fixpos, 1000);\r\n            if (evtkind === 's') {\r\n                let graph = this.props.isPanning;\r\n                if (this.oldPos.left === undefined && graph) {\r\n                    console.log('measurable fixposss ',{oldpos:{...this.oldPos}});\r\n                    this.oldPos.left = ui.position.left = graph.offset.x;\r\n                    this.oldPos.top = ui.position.top = graph.offset.y;\r\n                }\r\n                if (!e.classList.contains('draggable-child-mode')) e.classList.add('draggable-child-mode');\r\n            }\r\n            fixpos();\r\n            // delete e.style[key]\r\n        }\r\n    }\r\n    getDefaultEvent(type: \"draggable\" | \"resizable\" | \"rotatable\", evtkind: EventLetter): MeasurableUIEvent | null {\r\n        if (!this.props.transformMode && !(this.props.onChildren && type === 'draggable')) return null;\r\n        switch (type) {\r\n            case 'draggable': if (!this.props.transformMode && !this.props.onChildren) return null; break\r\n            case 'resizable': break\r\n            case 'rotatable': break\r\n        }\r\n\r\n        let translateeevents: Dictionary<string, Dictionary<string, DraggableEvent>> = {\r\n            'draggable': {\r\n                's': (e, ui)=>{ this.absoluteToTransform(e.target as HTMLElement, e, 's'); },\r\n                'ing': (e, ui)=>{ this.absoluteToTransform(e.target as HTMLElement, e, 'ing'); },\r\n                'e': (e, ui)=>{ this.absoluteToTransform(e.target as HTMLElement, e, 'e'); }},\r\n            /*'resizable': {\r\n                's': (e, ui)=>{ },\r\n                'ing': (e, ui)=>{ },\r\n                'e': (e, ui)=>{ }},\r\n            'rotatable': {\r\n                's': (e, ui)=>{ },\r\n                'ing': (e, ui)=>{ },\r\n                'e': (e, ui)=>{ }},*/\r\n        };\r\n        return (e: any, ui: any) => {\r\n            console.log('measurable default event', {type, evtkind, translateeevents, e, t: e.target});\r\n            if (this.props.transformMode === true) translateeevents[type]?.[evtkind]?.(e, ui);\r\n            this.childmode(e.target, e, evtkind, ui);\r\n        }\r\n    }\r\n    makeEvent(options: GObject<DraggableOptions>, type: string, evtkey: keyof typeof jquievent) {\r\n        let eventmap = {\r\n            's':    {'draggable': 'onDragStart',    'rotatable': 'onRotateStart',   'resizable': 'onResizeStart'},\r\n            'ing':  {'draggable': 'whileDragging',  'rotatable': 'whileRotating',   'resizable': 'whileResizing'},\r\n            'e':    {'draggable': 'onDragEnd',      'rotatable': 'onRotateEnd',     'resizable': 'onResizeEnd'  },\r\n        }\r\n        let jqui_ing: string;\r\n        switch (type){\r\n            default: jqui_ing = Log.eDevv(\"unexpected measurable event: \" + type); return;\r\n            case \"draggable\": jqui_ing = 'drag'; break;\r\n            case \"resizable\": jqui_ing = 'resize'; break;\r\n            case \"rotatable\": jqui_ing = 'rotate'; break;\r\n        }\r\n        //let jodelevent = {'s': eventmap.s[type], 'ing': eventmap.ing[type], 'e': eventmap.e[type]};\r\n        let jquievent = {'s': 'start', 'ing': jqui_ing, 'e':'stop'};\r\n\r\n        let jqkey = jquievent[evtkey] || '';\r\n        let props: GObject<MeasurableAllProps> = this.props;\r\n        let propsevent = props[eventmap[evtkey][type]];\r\n\r\n        if (propsevent && typeof propsevent !== \"function\") {\r\n            Log.ee(\"<Measurable /> \" + eventmap[evtkey][type] + \" props must be a function\");\r\n            return;\r\n        }\r\n        // call ondragend... jodel events\r\n        let jquievt = options[jqkey];\r\n        // let jodelevt = propsevent; // (...params: any) => propsevent(...params); // was made to preserve \"this\"?\r\n        let defaultevt: null | MeasurableUIEvent = this.getDefaultEvent(type, evtkey);\r\n        let allevents = [defaultevt, jquievt, propsevent].filter((e)=>!!e);\r\n        if (allevents.length) options[jqkey] = ((evt, ui)=>{\r\n            for (let e of allevents) {\r\n                propsevent = props[eventmap[evtkey][type]]; // if i don't redeclare it here, closure makes a mess taking always the last jodelevt for all iterations.\r\n                if (e === propsevent) { e(this.getCoords(evt, ui, this.props.isPanning), evt, ui); }\r\n                else e(evt, ui);\r\n            }\r\n        }) as DraggableEvent;\r\n    }\r\n    afterUpdateSingle(type: \"draggable\" | \"resizable\" | \"rotatable\"): void{\r\n        // was forced to move from general loop-style implementation to individual redundant stuff because of closure messes.\r\n        if (!this.$html) return;\r\n        let $measurable = this.$html;\r\n        let options: GObject;\r\n        const props: GObject = this.props;\r\n        const datamap = {draggable: \"uiDraggable\", resizable: \"uiResizable\", rotatable: \"uiRotatable\"};\r\n        const optionmap = {draggable: \"draggable\", resizable: \"resizable\", rotatable: \"rotatable\"};\r\n        const optionkey = optionmap[type];\r\n        if (props[optionkey] === false || !props[optionkey]) {\r\n            // console.log(\"measurable off \" + type, {$measurable, type, datamap, optionkey, props});\r\n            if ($measurable.data(datamap[type])) ($measurable as GObject)[type]('disable');\r\n            return;\r\n        }\r\n        if (props[optionkey] === true) {\r\n            options = {};\r\n        } else options = {...props[optionkey]};\r\n\r\n        // todo: changing options at runtime works, but changing children does not update\r\n\r\n        let jqui_ing: string;\r\n        switch (type){\r\n            default: jqui_ing = Log.eDevv(\"unexpected measurable event: \" + type); return;\r\n            case \"draggable\": jqui_ing = 'drag'; break;\r\n            case \"resizable\": jqui_ing = 'resize'; break;\r\n            case \"rotatable\": jqui_ing = 'rotate'; break;\r\n        }\r\n        let jquievent = {'s': 'start', 'ing': jqui_ing, 'e':'stop'};\r\n        let evtkey: keyof typeof jquievent;\r\n        for (evtkey in jquievent) { this.makeEvent(options, type, evtkey); }\r\n        let defaultOptions = this.defaultOptions[type];\r\n        U.objectMergeInPlace(options, defaultOptions);\r\n        ($measurable as GObject)[type](options);\r\n    }\r\n    shouldComponentUpdate(nextProps: Readonly<MeasurableAllProps>, nextState: Readonly<MeasurableState>, nextContext: any): boolean {\r\n        //console.log(\"measurable shouldup\", {nc:nextProps.children, tc:this.props.children, eq: nextProps.children == this.props.children});\r\n        // todo: would need to check if pros.children has changed, but that requires a deep search of subcomponents props and state.\r\n        // currently with just return true it works and rerenders every time the parent component rerenders. not when other elements are interacted.\r\n        // it works also with <Input> as direct child and it updates.\r\n        if (window) return true;\r\n        const oldProps = this.props || {};\r\n        this.dragOptionsChanged = false;\r\n        this.resizeOptionsChanged = false;\r\n        this.rotateOptionsChanged = false;\r\n        let ret: boolean = false;\r\n        const nestederr = \"Options cannot contain functions or nested objects\";\r\n        if (!U.isShallowEqualWithProxies(oldProps.draggable, nextProps.draggable)) {\r\n            const opt: GObject = oldProps.draggable as any;\r\n            if (opt && typeof opt === \"object\") for(let k in opt){ switch (typeof opt[k]){ case \"function\": case \"object\": Log.ee(\"drag\" + nestederr, k); } }\r\n            this.dragOptionsChanged = true;\r\n            ret = true;\r\n        }\r\n        if (!U.isShallowEqualWithProxies(oldProps.resizable, nextProps.resizable)) {\r\n            const opt: GObject = oldProps.resizable as any;\r\n            if (opt && typeof opt === \"object\") for(let k in opt){ switch (typeof opt[k]){ case \"function\": case \"object\": Log.ee(\"resize\" + nestederr, k); } }\r\n            this.resizeOptionsChanged = true;\r\n            ret = true;\r\n        }\r\n        if (!U.isShallowEqualWithProxies(oldProps.rotatable, nextProps.rotatable)) {\r\n            const opt: GObject = oldProps.rotatable as any;\r\n            if (opt && typeof opt === \"object\") for(let k in opt){ switch (typeof opt[k]){ case \"function\": case \"object\": Log.ee(\"rotate\" + nestederr, k); } }\r\n            this.rotateOptionsChanged = true;\r\n            return true;\r\n        }\r\n        if (ret) return true; // i don't need to set more this.variable stuff and i already determined something changed.\r\n        if (Object.keys(oldProps).length !== Object.keys(nextProps).length) return true;\r\n        let k: keyof typeof nextProps;\r\n        for (k in oldProps){\r\n            switch(k){\r\n                //case \"axis\": if (ok)\r\n                case \"draggable\": case \"resizable\": case \"rotatable\": continue;\r\n                case \"children\": continue;\r\n            }\r\n            if (!(k in nextProps)) return false;\r\n            let ok = oldProps[k];\r\n            let nk = nextProps[k];\r\n            if (ok === nk) continue;\r\n            let tk = typeof ok;\r\n            if (tk !== typeof nk) return false;\r\n            switch (tk) {\r\n                case \"object\": Log.ee(\"unexpected object in <Measurable/> props\", {k, nk, ok}); return true;\r\n                case \"function\": if (ok!.toString() !== nk!.toString()) return true; break;\r\n                default: return false; // already checked they are !==\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    updateDefaultOptions(){\r\n        /*let addClasses = this.props.children ? 'on-children' as any : undefined;\r\n                                          jqui.classes does not owrk? and addclass is only for draggable?\r\n        if (this.defaultOptions.draggable.addClasses !== addClasses) {\r\n            this.defaultOptions.resizable.classes = addClasses;\r\n            // this.defaultOptions.rotatable.classes = addClasses;\r\n        }*/\r\n    }\r\n    render(): ReactNode {\r\n        let child: ReactElement = this.props.children as any;\r\n\r\n        this.updateDefaultOptions();\r\n        if (!child) return child || null; // sometimes react passes {} as props.children?\r\n        if (!Object.keys(child).length) return Log.ee(\"Measurable can have only 1 subelement and it cannot be an array or a <>React.fragment</>\", child, this.props);\r\n        if (Array.isArray(child)) {\r\n            if (child.length !== 1) {\r\n                Log.ee(\"Measurable can have only 1 subelement and it cannot be an array or a <>React.fragment</>\", child, this.props);\r\n                return child;\r\n            }\r\n            else child = child[0];\r\n        }\r\n        if (child.type.toString() === React.Fragment.toString()) {\r\n            Log.ee(\"Measurable can have only 1 subelement and it cannot be an array or a <>React.fragment</>\", child, this.props);\r\n            return child; }\r\n\r\n        let oldProps = child.props;\r\n        let newProps = {\r\n            ref: (html: Element | null)=>{\r\n                if (html && !U.isHtmlNode(html)) {\r\n                    Log.ee('ref tring to set non-html element', html);\r\n                    return;\r\n                }\r\n                this.html = html;\r\n            }\r\n        };\r\n        U.objectMergeInPlace(newProps, oldProps);\r\n        let clonedChild = React.cloneElement(child, newProps);\r\n        return clonedChild;\r\n    }\r\n\r\n    private getCoords(evt: JQueryEventObject, ui: JQueryUI.DraggableEventUIParams, isPanning?: LGraph): GraphSize {\r\n        let size = Size.of(evt.target);\r\n        let graph: LGraph = DGraphElement.graphLFromHtml(evt.target) as LGraph;\r\n        let gsize: GraphSize = graph?.translateHtmlSize(size);\r\n        if (isPanning) {\r\n            let position = this.props.onChildren ? this.oldPos : ui.position;\r\n            gsize.x = position.left;\r\n            gsize.y = position.top;\r\n        }\r\n        return gsize;\r\n    }\r\n}\r\n\r\n@RuntimeAccessible('ScrollableComponent')\r\nexport class ScrollableComponent extends Component<ScrollOwnProps, ScrollState>{\r\n    static cname: string = \"ScrollableComponent\";\r\n    render(){\r\n        let graph = this.props.graph;\r\n        let create = (e: JQueryEventObject) => {/*\r\n            let target: HTMLElement = e.target.children[0] as HTMLElement;\r\n            target.style.left = graph.offset.x+'px';\r\n            target.style.top = graph.offset.y+'px';*/\r\n            // $(target).data({uiDraggable:{offset:{left: graph.offset.x, top: graph.offset.y}}});\r\n        }\r\n        return (\r\n            <div className={\"scrollable\"}>\r\n                <Measurable draggable={{create}}\r\n                            isPanning={graph}\r\n                            onDragEnd={graph ? (coords, ...args: any)=>{\r\n                                if (!graph) return; // just for ts-lint\r\n                                console.log(\"drag odee\", {coords, graph, args});\r\n                                let offset = graph.offset;\r\n                                if (!offset.equals(coords)) graph.offset = coords as any;\r\n                            } : undefined}\r\n                            onChildren={true}>\r\n                    <div className=\"panning-handle\">\r\n                        <div className=\"panning-content\">{ this.props.children }</div>\r\n                    </div>\r\n                </Measurable>\r\n            </div>);\r\n    }\r\n}\r\n\r\n// private\r\ninterface ScrollOwnProps {\r\n    children: ReactChild[] | ReactChild;\r\n    graph: LGraph;\r\n}\r\ninterface MeasurableOwnProps {\r\n    isPanning?: LGraph;\r\n    children: ReactChild[] | ReactChild;\r\n    //dragOptions?: Options;\r\n    //drag?: Options;\r\n    draggable?: JQueryUI.DraggableOptions | boolean;\r\n    onDragStart?: DraggableEvent;\r\n    whileDragging?: DraggableEvent;\r\n    onDragEnd?: (coords: GraphSize, ...args: Parameters<DraggableEvent>)=>void;\r\n    onChildren?: boolean | ((e: HTMLElement)=>HTMLElement);\r\n\r\n    //resizeOptions?: Options;\r\n    //resize?: Options;\r\n    resizable?: JQueryUI.ResizableOptions | boolean;\r\n    onResizeStart?: ResizableEvent;\r\n    whileResizing?: ResizableEvent;\r\n    onResizeEnd?: ResizableEvent;\r\n    transformMode?: boolean; // if true uses transform: translate() instead of pos:absolute; left; & top;\r\n\r\n    //rotateOptions?: Options;\r\n    //rotate?: Options;\r\n    rotatable?: GObject | boolean;\r\n    onRotationStart?: RotatableEvent;\r\n    whileRotating?: RotatableEvent;\r\n    onRotationEnd?: RotatableEvent;\r\n}\r\n// private\r\ninterface MeasurableStateProps {\r\n    // propsFromReduxStateOrOtherKindOfStateManagement: boolean; // flux or custom things too, unrelated to this.state of react.\r\n}\r\n\r\n// private\r\ninterface DispatchProps {\r\n    // propsFromReduxActions: typeof funzioneTriggeraAzioneDaImportare;\r\n}\r\n\r\n\r\n// private\r\ntype MeasurableAllProps = MeasurableOwnProps & MeasurableStateProps & DispatchProps;\r\n\r\n////// mapper func\r\n/*\r\nfunction mapStateToProps(state: DState, ownProps: MeasurableOwnProps): MeasurableStateProps {\r\n    const ret: MeasurableStateProps = {} as any;\r\n    /// to fill\r\n    return ret; }\r\n\r\nfunction mapDispatchToProps(dispatch: Dispatch<any>): DispatchProps {\r\n    const ret: DispatchProps = {} as any;\r\n    /// to fill\r\n    return ret; }\r\n*/\r\n\r\n(MeasurableComponent as any).defaultProps = {\r\n    autosizex: true,\r\n    autosizey: true,\r\n    style: undefined,\r\n    children: [],\r\n} as MeasurableOwnProps;\r\n\r\n\r\nexport function Measurable(props: MeasurableAllProps, children?: any): ReactElement {\r\n    return <MeasurableComponent {...{...props}}>{props.children||children}</MeasurableComponent>;\r\n}\r\n// shortcuts for Draggable Resizable Rotatable with whileDragging onDragStart props simplified to start, while, end\r\nexport function Draggable(props: GObject<MeasurableAllProps>, children?: any): ReactElement {\r\n    return <MeasurableComponent\r\n        {...{...props}}\r\n        draggable={props.options || props.draggable || true}\r\n        onDragStart={props.start || props.begin || props.onDragStart}\r\n        onDragEnd={props.end || props.stop || props.onDragEnd}\r\n        whileDragging={props.drag || props.while || props.ing || props.whileDragging}\r\n    >{props.children||children}</MeasurableComponent>;\r\n}\r\nexport function Resizable(props: GObject<MeasurableAllProps>, children?: any): ReactElement {\r\n    return <MeasurableComponent\r\n        {...{...props}}\r\n        resizable={props.options || props.resizable || true}\r\n        onResizeStart={props.start || props.begin || props.onResizeStart}\r\n        onResizeEnd={props.end || props.stop || props.onResizeEnd}\r\n        whileResizing={props.resize || props.while || props.ing || props.whileResizing}\r\n    >{props.children||children}</MeasurableComponent>;\r\n}\r\nexport function Rotatable(props: GObject<MeasurableAllProps>, children?: any): ReactElement {\r\n    return <MeasurableComponent\r\n        {...{...props}}\r\n        rotatable={props.options || props.rotatable || true}\r\n        onRotationStart={props.start || props.begin || props.onRotateStart|| props.onRotationStart}\r\n        onRotationEnd={props.end || props.stop || props.onRotateEnd|| props.onRotationEnd}\r\n        whileRotating={props.rotate || props.while || props.ing || props.whileRotate || props.whileRotating}\r\n    >{props.children||children}</MeasurableComponent>;\r\n}\r\n\r\n\r\nexport function Scrollable(props: MeasurableAllProps, children?: any): ReactElement {\r\n    // @ts-ignore\r\n    return <ScrollableComponent {...{...props}}>{props.children||children}</ScrollableComponent>;\r\n}/*\r\nexport function InfiniteScroll(props: MeasurableAllProps, children: ReactChild[] = []): ReactElement {\r\n    return <InfiniteScrollComponent {...{...props, children}}>{children}</InfiniteScrollComponent>;\r\n}*/\r\n\r\n/*connect<MeasurableStateProps, DispatchProps, MeasurableOwnProps, DState>(\r\n    mapStateToProps,\r\n    mapDispatchToProps\r\n)(MeasurableComponent);*/\r\n","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\graph\\damedges\\damedge.tsx",["1427","1428","1429","1430","1431","1432","1433","1434","1435","1436","1437","1438","1439","1440","1441","1442","1443","1444","1445","1446"],"import React, {Dispatch, ReactElement, ReactNode} from \"react\";\r\nimport {connect} from \"react-redux\";\r\nimport {\r\n    DEdge,\r\n    DGraph,\r\n    DGraphElement,\r\n    DGraphVertex, Dictionary,\r\n    DVoidVertex, EdgeBendingMode, GObject,\r\n    GraphElementComponent,\r\n    GraphElementDispatchProps,\r\n    GraphElementOwnProps,\r\n    GraphElementReduxStateProps,\r\n    GraphElementStatee, GraphPoint,\r\n    GraphSize,\r\n    DState,\r\n    LClass, LEdge, LGraphElement,\r\n    LModelElement,\r\n    LPointerTargetable,\r\n    LUser,\r\n    LVoidVertex, Overlap,\r\n    RuntimeAccessibleClass,\r\n    U,\r\n    EdgeOwnProps, EdgeStateProps,\r\n    LViewPoint, DModelElement, SetFieldAction, LVertex\r\n} from \"../../joiner\";\r\n\r\nlet groupingsize: Dictionary<EdgeBendingMode, number> = {} as any;\r\ngroupingsize[EdgeBendingMode.Line] = 1;\r\ngroupingsize[EdgeBendingMode.Bezier_quadratic] = 2;\r\ngroupingsize[EdgeBendingMode.Bezier_cubic] = 3;\r\n// groupingsize[EdgeBendingMode.Bezier_quadratic_mirrored] = 1;\r\n// groupingsize[EdgeBendingMode.Bezier_cubic_mirrored] = 2;\r\ngroupingsize[EdgeBendingMode.Elliptical_arc] = 2; // (1_coord), (rotation), (sweep    arc), (1_coord)\r\n\r\nconst superclassGraphElementComponent: typeof GraphElementComponent = RuntimeAccessibleClass.classes.GraphElementComponent as any as typeof GraphElementComponent;\r\nconst superclassGraphElementComponentuntyped: any = RuntimeAccessibleClass.classes.GraphElementComponent as any;\r\nclass ThisStatee extends GraphElementStatee {}\r\n\r\nexport class EdgeComponent<AllProps extends AllPropss = AllPropss, ThisState extends ThisStatee = ThisStatee>\r\n    extends superclassGraphElementComponent<AllProps, ThisState> {\r\n    public static cname: string = \"EdgeComponent\";\r\n    static defaultProps: Partial<EdgeOwnProps> = EdgeOwnProps.new();\r\n\r\n    constructor(props: AllProps, context: any) {\r\n        super(props, context);\r\n    }\r\n/*\r\n    path(): string {\r\n        let coords = this.pathCoords();\r\n        let svgletter: EdgeBendingMode = (this.props.view.bendingMode || \"L\");\r\n        let strings: string[] = coords.map(gp => gp.x+\" \" + gp.y);\r\n        return \"M\"+strings.join(\" \" + svgletter); }\r\n\r\n    pathCoords(): GraphPoint[] {\r\n        const ret = this.props;\r\n        let svgletter: EdgeBendingMode = (ret).view.bendingMode;\r\n        if (!ret.node) return []; // \"node missing\"\r\n        let coords: GraphPoint[] = (ret.node.midnodes as { x:number, y:number }[] as GraphPoint[]) || [];\r\n        let grouping = groupingsize[svgletter];\r\n        console.log(\"edgeee\", {coords, svgletter, groupingsize, midnodes:ret.node.midnodes, mnraw: ret.node.midnodes.map(mn=>mn.__raw), ret});\r\n        let scoord: GraphPoint = ret.node.startPoint || new GraphPoint(10, 10);\r\n        let ecoord: GraphPoint = ret.node.endPoint || new GraphPoint(100, 100);\r\n        return [scoord, ...coords, ecoord]; }\r\n\r\n    pathSegments(): GraphPoint[][]{\r\n        return U.pairArrayElements(this.pathCoords(), true); }\r\n*/\r\n    render(): ReactNode {\r\n        if (this.props.__skipRender) return null;\r\n        if (!this.props.node) return \"loading\";\r\n        // set classes\r\n        let nodeType = \"Edge\";\r\n        let classesoverride = [nodeType];\r\n        // set classes end\r\n        let styleoverride: React.CSSProperties = {}\r\n        return super.render(nodeType, styleoverride, classesoverride);\r\n    }\r\n\r\n}\r\n\r\n\r\n\r\nclass DispatchProps extends GraphElementDispatchProps {\r\n}\r\n\r\ntype AllPropss = Overlap<Overlap<EdgeOwnProps, EdgeStateProps>, DispatchProps>;\r\n\r\nfunction mapStateToProps(state: DState, ownProps: EdgeOwnProps): EdgeStateProps {\r\n    let ret: EdgeStateProps = EdgeStateProps.new();\r\n    if (!ownProps.data && !ownProps.start || !ownProps.end) return {__skipRender: true} as any;\r\n    if (!ownProps.data) {\r\n        let lstart = LPointerTargetable.from(ownProps.start);\r\n        if (RuntimeAccessibleClass.extends(lstart.className, DModelElement.cname)) ret.data = lstart as any;\r\n    }\r\n    ret = GraphElementComponent.mapStateToProps(state, ownProps, DEdge, ret) as EdgeStateProps;\r\n    // superret.lastSelected = state._lastSelected ? LPointerTargetable.from(state._lastSelected.modelElement) : null;\r\n    ret.isEdgePending = {\r\n        user: LPointerTargetable.from(state.isEdgePending.user),\r\n        source: LPointerTargetable.from(state.isEdgePending.source)\r\n    };\r\n    let l: GObject;\r\n\r\n    if (ownProps.start){ l = LPointerTargetable.from(ownProps.start); if (l) ret.start = l as LVertex; }\r\n    if (ownProps.end){ l = LPointerTargetable.from(ownProps.end); if (l) ret.end = l as LVertex; }\r\n\r\n    U.removeEmptyObjectKeys(ret);\r\n    if (!ret.start || !ret.end) return {__skipRender: true} as any;\r\n    return ret;\r\n}\r\n\r\nfunction mapDispatchToProps(dispatch: Dispatch<any>): DispatchProps {\r\n    const superret: GraphElementDispatchProps = GraphElementComponent.mapDispatchToProps(dispatch);\r\n    const ret: GraphElementDispatchProps = new GraphElementDispatchProps();\r\n    U.objectMergeInPlace(superret, ret);\r\n    U.removeEmptyObjectKeys(superret);\r\n    return superret;\r\n}\r\n\r\n\r\nexport const EdgeConnected = connect<EdgeStateProps, DispatchProps, EdgeOwnProps, DState>(\r\n    mapStateToProps,\r\n    mapDispatchToProps\r\n)(EdgeComponent as any);\r\n\r\nexport const Edge = (props: EdgeOwnProps, children: (string | React.Component)[] = []): ReactElement => {\r\n    return <EdgeConnected {...{...props, children}}\r\n                          isGraph={false} isGraphVertex={false} isVertex={false} isEdgePoint={false} isField={false} isEdge={true} isVoid={false} />;\r\n}\r\n\r\nEdgeComponent.cname = \"EdgeComponent\";\r\nEdgeConnected.cname = \"EdgeConnected\";\r\nEdge.cname = \"Edge\";\r\n","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\graph\\graph\\graphContainer.tsx",["1447","1448","1449","1450"],"import React, {Dispatch, PureComponent, ReactElement, ReactNode} from \"react\";\r\nimport {connect} from \"react-redux\";\r\n// import './graph.scss';\r\nimport {DGraph, DModel, DPointerTargetable, DState, LGraph, LModel, LPointerTargetable} from \"../../joiner\";\r\n\r\n\r\n// private\r\ninterface ThisState { }\r\n\r\nexport class GraphsContainerComponent extends PureComponent<AllProps, ThisState>{\r\n    public static cname: string = \"GraphsContainerComponent\";\r\n    constructor(props: AllProps, context: any) {\r\n        super(props, context);\r\n    }\r\n\r\n    // todo: per ogni vista crea un set di opzioni {enableAutocorrect: \"boolean(true)\", displayEdges: \"boolean(true)\", maximumGraphWidth: \"number(2000)\"} specificate dall\\'utente che deve specificare sia il tipo (Come se osse una funzione) che il valore predefinito\r\n    // il grafo deve leggere l'oggetto di opzioni e creare un menù che consente di cambiarle (una checkbox al posto dell'enableAutocorrect (bool), uno spinner per maximumGraphWidth (number...)\r\n\r\n    render(): ReactNode {\r\n        // const editinput = \"<input onChange={(e) => this.data.name = e.target.value } value={this.data.name} />\";\r\n        // const editinput = \"\";\r\n        // todo: rendi opzionale obj = this.data.id se non è specificato.\r\n        // const editinput = \"<Input obj={this.data.id} field={'name'} getter={val => val.toUpperCase()} setter={(val) => val.toLowerCase()} />\";\r\n        // \"<Input obj={this.data} field={'name'} getter={val => val.toUpperCase()} setter={(val) => val.toLowerCase()} />\";\r\n        return (<>\r\n            {\r\n                this.props.graphs.map( (m: LGraph) => (\r\n                    <>\r\n                        {/*<svg style={{backgroundColor: 'red'}}>\r\n                        <Overlap style={{width: '100px'}}>\r\n                            success, now i can test resize handler overlayed to content and dragndrop dnd\r\n                            <foreignObject className={\"rectangle\"} />\r\n                            <foreignObject className={\"ellipse\"} />\r\n                            <foreignObject className={\"point\"} />\r\n                        </Overlap>\r\n                        </svg><svg style={{backgroundColor: 'red'}}>\r\n                            <Overlap>\r\n                                <foreignObject className={\"rectangle\"} style={{width: '100px'}}/>\r\n                                <foreignObject className={\"ellipse\"} style={{width: '300px'}}/>\r\n                                <foreignObject className={\"point\"} />\r\n                            </Overlap>\r\n                        </svg>* /}\r\n                        <GraphElement data={m} />*/}\r\n                        {/*\r\n                            Giordano comment this problem with model's children\r\n                            <Graph graphid={m.id} data={m.model} view={undefined}>\r\n                                <Vertex data={m.model}/>\r\n                            </Graph>\r\n\r\n                        */}\r\n                        {this.props.children/*<QA />*/}\r\n                    </>)\r\n                )\r\n            }\r\n        </>); }\r\n}\r\n\r\n// private\r\ninterface OwnProps {\r\n    // propsRequestedFromHtmlAsAttributes: string;\r\n}\r\n// private\r\ninterface StateProps {\r\n    models: LModel[];\r\n    graphs: LGraph[];\r\n    // propsFromReduxStateOrOtherKindOfStateManagement: boolean; // flux or custom things too, unrelated to this.state of react.\r\n}\r\n\r\n// private\r\ninterface DispatchProps {\r\n    // propsFromReduxActions: typeof funzioneTriggeraAzioneDaImportare;\r\n}\r\n\r\n\r\n// private\r\ntype AllProps = OwnProps & StateProps & DispatchProps;\r\n\r\n////// mapper func\r\n\r\nfunction mapStateToProps(state: DState, ownProps: OwnProps): StateProps {\r\n    const ret: StateProps = {} as any;\r\n    console.log('mapStateToProps', {ret, state, ownProps, models: state.models})\r\n    ret.models = state.models.length ? LPointerTargetable.fromArr(state.models, state) as LModel[] : [];\r\n    ret.graphs = state.graphs.length ? LGraph.fromArr(state.graphs, state) as LGraph[] : [];\r\n    /// to fill\r\n    return ret; }\r\n\r\nfunction mapDispatchToProps(dispatch: Dispatch<any>): DispatchProps {\r\n    const ret: DispatchProps = {} as any;\r\n    /// to fill\r\n    return ret; }\r\n\r\n\r\nconst GraphsContainerConnected = connect<StateProps, DispatchProps, OwnProps, DState>(\r\n    mapStateToProps,\r\n    mapDispatchToProps\r\n)(GraphsContainerComponent);\r\n\r\nexport const GraphsContainer = (props: OwnProps, children: (string | React.Component)[] = []): ReactElement => {\r\n    return <GraphsContainerConnected {...{...props, children}} />; }\r\n\r\n\r\nGraphsContainer.cname = \"GraphsContainer\";\r\nGraphsContainerConnected.cname = \"GraphsContainerConnected\";\r\nGraphsContainerComponent.cname = \"GraphsContainerComponent\";\r\n","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\graph\\vertex\\Shapes.tsx",["1451","1452"],"import type { VertexOwnProps } from \"../graphElement/sharedTypes/sharedTypes\";\r\nimport React, {ReactElement, ReactNode} from \"react\";\r\nimport {GObject, Point, U} from \"../../joiner\";\r\nimport { Geom } from \"../../common/Geom\";\r\nimport {VertexConnected} from \"./Vertex\";\r\nimport {radian} from \"../../joiner/types\";\r\n\r\n\r\nfunction polygonSideLength(sides: number, radius: number = 1){\r\n    let rad = Math.PI/sides; // actual angle is twice, ut to do calculations i need half of it, to make it first a triangle slice out of a polygon, and then 2 right angle slices. this is the angle of 1 of the 2 right angle slices\r\n    return 2*(radius * Math.sin(rad)); }\r\n\r\nfunction makePolygon(sides: number, radius: number = 0.5, startingPoint?:Point, startingRad?: radian): Point[]{\r\n    let lastPt: Point = startingPoint || new Point(radius, 0);\r\n    let pts: Point[] = [lastPt];\r\n    let sideLength = polygonSideLength(sides, radius);\r\n    let rad0 = Math.PI/sides;\r\n    let currentRad: radian = startingRad !== undefined ? startingRad : rad0;\r\n    let sidesloop = sides;\r\n    while (sidesloop-- > 0) {\r\n        let nextPt = lastPt.move(currentRad, sideLength);\r\n        pts.push(nextPt);\r\n        lastPt = nextPt;\r\n        currentRad += rad0*2;\r\n    }\r\n    return pts;\r\n}\r\n\r\nfunction makeStar(sides: number, radius: number = 0.5, starRadius: number=0.25, niceBugVersion: boolean = true): Point[]{\r\n    console.log(\"make star\", {sides, starRadius});\r\n    let startRad;\r\n    let nextPtRad;\r\n    if (niceBugVersion && sides % 2 == 0) {\r\n        // nb: not fully correct, the correct \"bug\" version on even would be having an inner polygon identical to outer poly (not rotated)\r\n        // with points[0] = topmost point of the ex-circle for both odd polys. and then matching outer[i] with inner[i-1] points to make a line\r\n        startRad = Geom.degToRad(180/sides+90);\r\n        //nextPtRad = -startRad*2;\r\n        nextPtRad = -startRad*2*(sides-1);\r\n    } else {\r\n        startRad = -Geom.degToRad(-180/sides+90);\r\n        nextPtRad = (startRad - Geom.degToRad(90))*2;\r\n    }\r\n    let startPt: Point = new Point(0.5, 0.5).move(startRad, starRadius);\r\n    //startPt.y = 2*0.5 - startPt.y;\r\n    let poly = makePolygon(sides, radius);\r\n    let innerPoly = makePolygon(sides, starRadius, startPt, nextPtRad);\r\n    //innerPoly = [innerPoly[0], innerPoly[1]]\r\n    let ret: Point[] = []; // both go clockwise, but inner starts on opposide side\r\n    //return innerPoly;\r\n    for (let i = 0; i <= sides; i++) ret.push(poly[i], innerPoly[i]);\r\n    return ret.filter(r => !!r);\r\n}\r\n\r\nfunction makeAsterisk(sides: number, radius: number = 0.5, starRadius: number=0.25): Point[]{\r\n    console.log(\"make asterisk, todo\", {sides, starRadius});\r\n    return [];\r\n}\r\nfunction makeClipPath(pts:Point[]): string {\r\n    return 'polygon(' + pts.map(pt=> (pt.x*100 + '% ' + pt.y*100 + '%')).join(', ') + ')';\r\n}\r\n/*\r\nfunction makeSvg(pts: Point[]): string{\r\n    let val = 'M' + (pts.map(pt=> ('L' + pt.x*100 + ' ' + pt.y*100 + ' ')).join(', ')).substring(1) + '';\r\n    let html = document.querySelector('#p');\r\n    html.setAttribute('d', val);\r\n    html.style.display='block';\r\n    html = document.querySelector('#c'+0);\r\n    html.setAttribute(\"cx\", pts[0].x*100);\r\n    html.setAttribute(\"cy\", pts[0].y*100);\r\n\r\n    for (let i = 1; i < 20; i++) {\r\n        let v =  pts[i] ? \"M\" + pts[i-1].x*100 + ' ' + pts[i-1].y*100 + \" L\" + pts[i].x*100 + ' ' + pts[i].y*100 : \"\";\r\n        html = document.querySelector('#p'+i);\r\n        html.setAttribute('d', v);\r\n        html.style.display='block';\r\n        html.style.display='block';\r\n        html = document.querySelector('#c'+i);\r\n        if (!html) console.error(\"failed selector\", '#c'+i, {i, v, pts});\r\n        html.setAttribute(\"cx\", pts[i] ? pts[i].x*100 : -500);\r\n        html.setAttribute(\"cy\", pts[i] ? pts[i].y*100 : -500);\r\n    }\r\n    console.log(html);\r\n    return val;\r\n}*/\r\n\r\n\r\n\r\n\r\n\r\n// geom shortcuts\r\nfunction addStyle(props0: VertexOwnProps, children:any, childStyle: React.CSSProperties, style: React.CSSProperties = {}){\r\n    let props: GObject = {...props0, children, isGraph:false, isGraphVertex: false, isVertex:true, isEdgePoint: false, isField: false, isEdge: false, isVoid:true};\r\n    // props.style = !props0.style ? {} : {...props0.style};\r\n    props.childStyle = props.childStyle ? {...props.childStyle} : {};\r\n    props.style = props.style ? {...props.style} : {};\r\n    U.objectMergeInPlace(props.childStyle, childStyle, {\r\n        // custom fixed stuff\r\n    });\r\n    U.objectMergeInPlace(props.style, style, {\r\n        // custom fixed stuff\r\n        filter: 'drop-shadow(0px var(--border-width) 0px var(--border-color)) drop-shadow(var(--border-width) 0px 0px var(--border-color))' +\r\n            ' drop-shadow(calc( -1 * var(--border-width)) 0px 0px var(--border-color)) drop-shadow(0px calc( -1 * var(--border-width)) 0px var(--border-color))',\r\n    });\r\n    props.datastyle = JSON.stringify(props.style);\r\n    props.dataChildStyle = JSON.stringify(props.childStyle);\r\n    return props;}\r\n\r\nexport const Ellipse = (props: VertexOwnProps, children: ReactNode | undefined = []): ReactElement => {\r\n    return <VertexConnected {...addStyle(props, children, {borderRadius:'100%', // ellipse(50% 25% at 50% 50%)\r\n    })} />;}\r\nEllipse.cname = 'Ellipse';\r\n\r\nexport const Rectangle = (props: VertexOwnProps, children: ReactNode | undefined = []): ReactElement => { // default\r\n    return <VertexConnected {...addStyle(props, children, {})} />;}\r\nRectangle.cname = 'Rectangle (alias for default <Vertex />)';\r\n\r\nexport const Polygon = (props: VertexOwnProps, children: ReactNode | undefined = []): ReactElement => {\r\n    props = {...props};\r\n    if (!props.sides) props.sides = 6;\r\n    // if (!props.radius) props.radius = 0.5;\r\n    return <VertexConnected {...addStyle(props, children, {clipPath: makeClipPath(makePolygon(props.sides, 0.5))})} />;\r\n}\r\nPolygon.cname = 'N-Polygon';\r\n\r\nexport const Star = (props: VertexOwnProps, children: ReactNode | undefined = []): ReactElement => { // pointed lines, N endings (include 6-stars and more)\r\n    return props.decorated === false ? SimpleStar(props, children) : DecoratedStar(props, children);\r\n}\r\nStar.cname = 'N-Star';\r\nexport const DecoratedStar = (props: VertexOwnProps, children: ReactNode | undefined = []): ReactElement => {\r\n    props = {...props};\r\n    if (!props.sides) props.sides = 4;\r\n    // if (!props.radius) props.radius = 0.5;\r\n    if (!props.innerRadius) props.innerRadius = 0.25;\r\n    return <VertexConnected {...addStyle(props, children, {clipPath: makeClipPath(makeStar(props.sides, 0.5, props.innerRadius, true))})} />;\r\n}\r\nDecoratedStar.cname = 'N-DecoratedStar';\r\nexport const SimpleStar = (props: VertexOwnProps, children: ReactNode | undefined = []): ReactElement => {\r\n    props = {...props};\r\n    if (!props.sides) props.sides = 6;\r\n    // if (!props.radius) props.radius = 0.5;\r\n    if (!props.innerRadius) props.innerRadius = 0.25;\r\n    return <VertexConnected {...addStyle(props, children, {clipPath: makeClipPath(makeStar(props.sides, 0.5, props.innerRadius, false))})} />;\r\n}\r\nSimpleStar.cname = 'N-SimpleStar';\r\n\r\nexport const Cross = (props: VertexOwnProps, children: ReactNode | undefined = []): ReactElement => { // cut lines, N endings (includes asterisk)\r\n    return <div>N-Crosses (Asterisk-like) shapes yet to do</div>;\r\n}\r\nCross.cname = 'N-Cross';\r\n\r\nexport const Trapezoid = (props0: VertexOwnProps, children: ReactNode | undefined = []): ReactElement => { // cut lines, N endings (includes asterisk)\r\n    let props: VertexOwnProps & {ratio: number} = props0 as any;\r\n    if (!props0.ratio) props = {...props, ratio: 0.2 };\r\n    return <VertexConnected {...addStyle(props, children, {clipPath: 'polygon(' + props.ratio * 100 + '% 0%, ' + (1-props.ratio) * 100 + '% 0%, 100% 100%, 0% 100%)'})} />;}\r\nTrapezoid.cname = 'Trapezoid';\r\n\r\n\r\n//////////////// aliases (circle -> ellipse) ...\r\n\r\nexport const Circle = (props: VertexOwnProps, children: ReactNode | undefined = []): ReactElement => { // ellipse ellipse(50% 50% at 50% 50%)\r\n    return Ellipse(props, children); }\r\nCircle.cname = 'Ellipse/Circle';\r\n\r\n/*\r\nstep 1) put favoriteNode props on all GraphElememnt components except the most basic one like here,\r\nin a way that mirrirong components will have the mirror name instead of the implementation name (which is always GraphVertex)\r\n favoriteNode={props.favoriteNode || Square.cname}\r\nstep 2) when parsing jsx to build nodes, edges, check if props like edge.start or node.favoriteNode are different from the same prop in DVertex/DEdge/DView\r\nin that case, update such value\r\n*/\r\nexport const Square = (props: VertexOwnProps, children: ReactNode | undefined = []): ReactElement => { // rectangle\r\n    return <VertexConnected {...{...props, children}} isGraph={false} isVertex={true} isVoid={true} />; }\r\nSquare.cname = 'Rectangle/Square';\r\n/*\r\nexport const Rhombus = (props: VertexOwnProps, children: ReactNode | undefined = []): ReactElement => { // rectangle\r\n    return <VertexConnected {...{...props, children}} isGraph={false} isVertex={true} isVoid={true} rotate={props.rotate || 45} />; }\r\nRhombus.cname = 'Rectangle/Diamond';\r\n\r\nexport const Diamond = (props: VertexOwnProps, children: ReactNode | undefined = []): ReactElement => { return Rhombus(props, children); }\r\nDiamond.cname = 'Rectangle/Diamond';*/\r\n\r\n// polygon\r\nexport const Triangle = (props: VertexOwnProps, children: ReactNode | undefined = []): ReactElement => {\r\n    return <VertexConnected {...addStyle(props, children, {clipPath: 'polygon(50% 0%, 0% 100%, 100% 100%)'})} />;}\r\nTriangle.cname = 'Polygon/Triangle';\r\n\r\nexport const Pentagon = (props: VertexOwnProps, children: ReactNode | undefined = []): ReactElement => {\r\n    return <VertexConnected {...addStyle(props, children, {clipPath: 'polygon(50% 0%, 100% 38%, 82% 100%, 18% 100%, 0% 38%)'})} />;}\r\nPentagon.cname = 'Polygon/Pentagon';\r\n\r\nexport const Hexagon = (props: VertexOwnProps, children: ReactNode | undefined = []): ReactElement => {\r\n    return <VertexConnected {...addStyle(props, children, {clipPath: 'polygon(50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%)'})} />;}\r\nHexagon.cname = 'Polygon/Hexagon';\r\n\r\nexport const Heptagon = (props: VertexOwnProps, children: ReactNode | undefined = []): ReactElement => {\r\n    return <VertexConnected {...addStyle(props, children, {clipPath: 'polygon(50% 0%, 90% 20%, 100% 60%, 75% 100%, 25% 100%, 0% 60%, 10% 20%)'})} />;}\r\nHeptagon.cname = 'Polygon/Heptagon';\r\nexport const Septagon = (props: VertexOwnProps, children: ReactNode | undefined = []): ReactElement => {\r\n    return <VertexConnected {...addStyle(props, children, {clipPath: 'polygon(50% 0%, 90% 20%, 100% 60%, 75% 100%, 25% 100%, 0% 60%, 10% 20%)'})} />;}\r\nSeptagon.cname = 'Polygon/Heptagon';\r\n\r\nexport const Octagon = (props: VertexOwnProps, children: ReactNode | undefined = []): ReactElement => {\r\n    return <VertexConnected {...addStyle(props, children, {clipPath: 'polygon(30% 0%, 70% 0%, 100% 30%, 100% 70%, 70% 100%, 30% 100%, 0% 70%, 0% 30%)'})} />;}\r\nOctagon.cname = 'Polygon/Octagon';\r\n\r\nexport const Nonagon = (props: VertexOwnProps, children: ReactNode | undefined = []): ReactElement => {\r\n    return <VertexConnected {...addStyle(props, children, {clipPath: 'polygon(50% 0%, 83% 12%, 100% 43%, 94% 78%, 68% 100%, 32% 100%, 6% 78%, 0% 43%, 17% 12%)'})} />;}\r\nNonagon.cname = 'Polygon/Nonagon';\r\n\r\nexport const Enneagon = (props: VertexOwnProps, children: ReactNode | undefined = []): ReactElement => {\r\n    return <VertexConnected {...addStyle(props, children, {clipPath: 'polygon(50% 0%, 83% 12%, 100% 43%, 94% 78%, 68% 100%, 32% 100%, 6% 78%, 0% 43%, 17% 12%)'})} />;}\r\nEnneagon.cname = 'Polygon/Nonagon';\r\n\r\nexport const Decagon = (props: VertexOwnProps, children: ReactNode | undefined = []): ReactElement => {\r\n    return <VertexConnected {...addStyle(props, children, {clipPath: 'polygon(50% 0%, 80% 10%, 100% 35%, 100% 70%, 80% 90%, 50% 100%, 20% 90%, 0% 70%, 0% 35%, 20% 10%)'})} />;}\r\nDecagon.cname = 'Polygon/Decagon';\r\n\r\nexport const Asterisk = (props: VertexOwnProps, children: ReactNode | undefined = []): ReactElement => { // cut lines, N endings (includes asterisk)\r\n    return Star(props, children); }\r\nAsterisk.cname = 'Cross/Asterisk';\r\n","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\components\\logger\\DataOutput.tsx",["1453"],"import React, {PureComponent, ReactNode} from \"react\";\r\nimport ReactJson from 'react-json-view' // npm i react-json-view\r\nimport './logger.scss'\r\nimport {GObject} from \"../../joiner\";\r\n\r\n// private\r\ninterface ThisState { }\r\n\r\nexport class DataOutputComponent extends PureComponent<AllProps, ThisState>{\r\n    static cname: string = \"DataOutputComponent\";\r\n\r\n    render(): ReactNode {\r\n        {/* themes:\r\n                                        export interface ThemeObject {\r\n                                            base00: string;\r\n                                            base01: string;\r\n                                            base02: string;\r\n                                            base03: string;\r\n                                            base04: string;\r\n                                            base05: string;\r\n                                            base06: string;\r\n                                            base07: string;\r\n                                            base08: string;\r\n                                            base09: string;\r\n                                            base0A: string;\r\n                                            base0B: string;\r\n                                            base0C: string;\r\n                                            base0D: string;\r\n                                            base0E: string;\r\n                                            base0F: string;\r\n                                        }\r\n\r\n                                            export type ThemeKeys =\r\n                                              | 'apathy'\r\n                                              | 'apathy:inverted'\r\n                                              | 'ashes'\r\n                                              | 'bespin'\r\n                                              | 'brewer'\r\n                                              | 'bright:inverted'\r\n                                              | 'bright'\r\n                                              | 'chalk'\r\n                                              | 'codeschool'\r\n                                              | 'colors'\r\n                                              | 'eighties'\r\n                                              | 'embers'\r\n                                              | 'flat'\r\n                                              | 'google'\r\n                                              | 'grayscale'\r\n                                              | 'grayscale:inverted'\r\n                                              | 'greenscreen'\r\n                                              | 'harmonic'\r\n                                              | 'hopscotch'\r\n                                              | 'isotope'\r\n                                              | 'marrakesh'\r\n                                              | 'mocha'\r\n                                              | 'monokai'\r\n                                              | 'ocean'\r\n                                              | 'paraiso'\r\n                                              | 'pop'\r\n                                              | 'railscasts'\r\n                                              | 'rjv-default'\r\n                                              | 'shapeshifter'\r\n                                              | 'shapeshifter:inverted'\r\n                                              | 'solarized'\r\n                                              | 'summerfruit'\r\n                                              | 'summerfruit:inverted'\r\n                                              | 'threezerotwofour'\r\n                                              | 'tomorrow'\r\n                                              | 'tube'\r\n                                              | 'twilight'; */}\r\n        return <ReactJson src={this.props.data}\r\n                          collapsed={1}\r\n                          collapseStringsAfterLength={20}\r\n                          displayDataTypes={true}\r\n                          displayObjectSize={true}\r\n                          enableClipboard={true}\r\n                          groupArraysAfterLength={100}\r\n                          indentWidth={4}\r\n                          iconStyle={\"triangle\"}\r\n                          name={this.props.rootName}\r\n                          quotesOnKeys={true} shouldCollapse={ false /*((field: CollapsedFieldProps) => { return Object.keys(field.src).length > 3;*/ }\r\n                          sortKeys={false}\r\n                          theme={\"rjv-default\"}\r\n        >{this.props.children}</ReactJson>;\r\n    };\r\n\r\n}\r\n\r\n// private\r\ninterface OwnProps {\r\n    data: GObject;\r\n    rootName?: string;\r\n}\r\n// private\r\ntype AllProps = OwnProps;\r\n/*\r\nif (!windoww.mycomponents) windoww.mycomponents = {};\r\nwindoww.mycomponents.DataOutput = DataOutputComponent;\r\nwindoww.mycomponents.DataOutputComponent = DataOutputComponent;*/\r\n////// mapper func\r\n\r\n","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\graph\\defaultNode\\DefaultNode.tsx",["1454","1455","1456","1457","1458","1459","1460","1461","1462","1463","1464","1465","1466","1467","1468","1469","1470","1471","1472","1473","1474","1475","1476","1477","1478","1479","1480","1481","1482"],"import React, {ReactElement, ReactNode} from \"react\";\r\nimport {connect} from \"react-redux\";\r\nimport {\r\n    DClassifier,\r\n    DEnumerator,\r\n    Dictionary,\r\n    DModel,\r\n    DModelElement,\r\n    DPackage,\r\n    DV,\r\n    GObject,\r\n    GraphElementComponent,\r\n    GraphElementDispatchProps,\r\n    GraphElementOwnProps,\r\n    GraphElementReduxStateProps,\r\n    GraphElementStatee,\r\n    DState,\r\n    LModelElement,\r\n    Log,\r\n    LViewElement,\r\n    RuntimeAccessibleClass,\r\n    SetRootFieldAction,\r\n    windoww,\r\n    Field,\r\n    Graph,\r\n    GraphVertex,\r\n    Vertex,\r\n    VoidVertex,\r\n    RuntimeAccessible,\r\n    Polygon,\r\n    Circle,\r\n    Cross,\r\n    Decagon,\r\n    Asterisk,\r\n    Ellipse,\r\n    Enneagon,\r\n    Hexagon,\r\n    Nonagon,\r\n    Octagon,\r\n    Heptagon,\r\n    Pentagon,\r\n    Rectangle,\r\n    Septagon,\r\n    Square,\r\n    Star,\r\n    SimpleStar,\r\n    DecoratedStar,\r\n    Trapezoid,\r\n    Triangle,\r\n    Selectors,\r\n    LPointerTargetable,\r\n    Pointer,\r\n    DGraphElement,\r\n    DPointerTargetable, LGraphElement, transientProperties\r\n} from \"../../joiner\";\r\nimport { GraphElements } from \"../../joiner/components\";\r\n// import {Field, Graph, GraphVertex} from \"../vertex/Vertex\";\r\n\r\nconst superclass: typeof GraphElementComponent = RuntimeAccessibleClass.classes.GraphElementComponent as any as typeof GraphElementComponent;\r\n\r\n// private\r\nclass DefaultNodeStatee extends GraphElementStatee { }\r\n\r\n// from ownstateprops function getVertexID(props: AllPropss): Pointer<DVoidVertex, 0, 1, LVoidVertex> { return props.vertex?.id; }\r\n\r\n// Giordano: add ignore for webpack\r\n@RuntimeAccessible('DefaultNodeComponent')\r\n//@ts-ignore\r\nexport class DefaultNodeComponent<AllProps extends AllPropss = AllPropss, NodeState = DefaultNodeStatee> extends superclass<AllProps, NodeState>{\r\n    static defaultProps: Partial<DefaultNodeOwnProps> = {}; // cannot decide anything on this level, delegated to lower levels.\r\n\r\n    static mapStateToProps(state: DState, ownProps: GraphElementOwnProps): GraphElementReduxStateProps {\r\n        let ret: GraphElementReduxStateProps = {} as GraphElementReduxStateProps; // NB: cannot use a constructor, must be pojo\r\n        // GraphElementComponent.mapLModelStuff(state, ownProps, ret); // not necessary either?\r\n        // GraphElementComponent.mapLGraphElementStuff(state, ownProps, ret, dGraphDataClass); not necessary, it's demanded to sub-components\r\n/*        ret.data = LPointerTargetable.wrap(ownProps.data);\r\n        ret.node = undefined as any; // because DefaultNode is all about determining the correct node to create, so there is no node yet.\r\n        ret.nodeid = ownProps.nodeid as Pointer<DGraphElement>; // but nodeid exists, passed from the parent along graphid and parentview\r\n*/\r\n        // try{\r\n        ret.data = LPointerTargetable.wrap(ownProps.data);\r\n        ret.dataid = ownProps.data ? (typeof ownProps.data === \"string\" ? ownProps.data : ownProps.data.id) : undefined;\r\n        // if node does not exist yet it's fine, don't create it. let Vertex or Graph or Edge make it with appropriate constructor according fo first matching view on model.\r\n        // problem: what kind of node to make / initial view assign on shapeless objects? they have both data and node undefined at first render.\r\n        ret.node = LPointerTargetable.wrap(ownProps.nodeid) as LGraphElement;\r\n        if (ret.dataid) {\r\n            // set up transient model-> node map\r\n            if (!transientProperties.modelElement[ret.dataid]) transientProperties.modelElement[ret.dataid] = {nodes: {}} as any;\r\n            transientProperties.modelElement[ret.dataid].nodes[ownProps.nodeid as string] = ret.node;\r\n            transientProperties.modelElement[ret.dataid].node = ret.node;\r\n        }\r\n\r\n        GraphElementComponent.mapViewStuff(state, ret, ownProps);\r\n\r\n            // GraphElementComponent.mapViewStuff(state, ret, ownProps);\r\n            (ret as any).skiparenderforloading = false;\r\n        //} catch(e) {\r\n            //(ret as any).skiparenderforloading = true; // model id is updated, but he's still trying to load old model which got replaced and is not in state.\r\n            /* crashes on loading because old model and new model have different timestamps? looks by id of old model with same number and diffferent timestamp*/\r\n            // Log.eDev(!ret.data, \"can't find model data:\", {state, ret, ownpropsdata:ownProps.data, ownProps});\r\n            // Log.eDevv(\"cannot map state to props:\", {e, state, ret, ownpropsdata:ownProps.data, ownProps});\r\n        //}\r\n        return ret; }\r\n\r\n    constructor(props: AllProps, context: any) { super(props, context); }\r\n\r\n    shouldComponentUpdate(nextProps: Readonly<AllProps>, nextState: Readonly<NodeState>, nextContext: any): boolean {\r\n        // i want to avoid double check on this and Vertex or graph.\r\n        // actually should not use this and avoid double mapstatetoprops execution too\r\n        return true;\r\n    }\r\n\r\n    render(): ReactNode {\r\n        if ((this.props as any).skiparenderforloading) {\r\n            windoww.bugged = this;\r\n            console.log(\"realoading render: \", {thiss:this, data:this.props.data});\r\n            SetRootFieldAction.new(\"rerenderforloading\", new Date().getTime()); return <div>loading...</div>;}\r\n        const view: LViewElement = this.props.view;\r\n        const modelElement: LModelElement | undefined = this.props.data;\r\n        if (!view) { Log.exx(\"cannot find view in DefaultNode\", {props: this.props, thiss:this}); }\r\n        // if (!view) { SetRootFieldAction.new(\"uselessrefresh_afterload\", new Date().getTime()); return <div>Loading...</div>; }\r\n\r\n        let componentMap: Dictionary<string, (props: GObject, children?: (string | React.Component)[]) => ReactElement> = windoww.components;\r\n        let dmodelMap: Dictionary<string, typeof DModelElement> = RuntimeAccessibleClass.classes as any;\r\n\r\n        let serializableProps = {...this.props, data: this.props.data, view: this.props.view, views: this.props.views};\r\n        // let serializableProps = {...this.props, data: this.props.data?.id, view: this.props.view?.id, views: this.props.views?.map( v => v.id )};\r\n\r\n        // console.log('dnode render', {props: {...this.props}, serializableProps});\r\n        let componentfunction: typeof Graph = null as any;\r\n        let forceNodeType = view.forceNodeType;\r\n        if (forceNodeType && forceNodeType !== \"Any\") {\r\n            componentfunction = GraphElements[forceNodeType] as any;\r\n            Log.exDev(!componentfunction, 'unrecognized View.forceNodeType:' + view.forceNodeType, {view, modelElement, nt: forceNodeType, GraphElements, });\r\n            // console.log(\"force node type\", {requested:view.forceNodeType, G:  windoww.GraphComponent.name, GE: windoww.GraphElementComponent.name, GV: windoww.GraphVertexComponent.name, V: windoww.VertexComponent.name, F:windoww.FieldComponent.name})\r\n            return componentfunction(serializableProps, this.props.children); }\r\n\r\n        if (modelElement?.className) switch(modelElement.className) {\r\n            case \"DModel\": componentfunction = Graph; break;\r\n            case \"DPackage\": componentfunction = GraphVertex; break;\r\n            case \"DClassifier\":\r\n            case \"DEnumerator\":\r\n            case \"DObject\":\r\n            case \"DClass\": componentfunction = Vertex; break;\r\n            case \"DAnnotation\":\r\n            case \"DAttribute\":\r\n            case \"DOperation\":\r\n            case \"DParameter\":\r\n            case \"DReference\":\r\n            case \"DEnumLiteral\":\r\n            case \"DValue\":\r\n            case \"DModelElement\": componentfunction = Field; break;\r\n            default:\r\n                Log.exDevv('invalid model class, add a case in the switch', {modelElement, view, dmodelMap, componentMap});\r\n                // const dmodel: typeof DModelElement = dmodelMap[modelElement.className];\r\n                // Log.exDev(!dmodel || !dmodel.defaultComponent, 'invalid model class:', {dmodel, modelElement, view, dmodelMap, componentMap});\r\n                // return dmodel.defaultComponent(serializableProps, this.props.children);\r\n        } else componentfunction = VoidVertex; // model-less, VoidVertex\r\n\r\n        if (componentfunction) return componentfunction(serializableProps, this.props.children);\r\n        // errore: questoon passa gli id correttamente al sottoelemento vertex o field\r\n        return DV.errorView(\"DefaultNode is missing both view and model, please state node type explicitly: Graph, GraphVertex, Vertex or Field\",\r\n            '', 'DefaultNode', modelElement?.__raw, this.props.node?.__raw, view);\r\n    }\r\n\r\n}\r\n\r\n// private\r\nclass DefaultNodeOwnProps extends GraphElementOwnProps {}\r\nclass DefaultNodeReduxStateProps  extends GraphElementReduxStateProps {}\r\nclass DefaultNodeDispatchProps extends GraphElementDispatchProps {}\r\ntype AllPropss = DefaultNodeOwnProps & DefaultNodeReduxStateProps & DefaultNodeDispatchProps;\r\n\r\n\r\nconst DefaultNodeConnected = connect<DefaultNodeReduxStateProps, DefaultNodeDispatchProps, DefaultNodeOwnProps, DState>(\r\n    DefaultNodeComponent.mapStateToProps,\r\n    DefaultNodeComponent.mapDispatchToProps\r\n)(DefaultNodeComponent as any);\r\n// export const Vertex = VertexConnected;\r\n\r\n\r\nexport const DefaultNode = (props: DefaultNodeOwnProps, children: (string | React.Component)[] = []): ReactElement => {\r\n    return <DefaultNodeConnected {...{...props, children}} />; }\r\n\r\n\r\nDefaultNodeComponent.cname = \"DefaultNodeComponent\";\r\nDefaultNodeConnected.cname = \"DefaultNodeConnected\";\r\nDefaultNode.cname = \"DefaultNode\";\r\n","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\graph\\vertex\\Vertex.tsx",["1483","1484","1485","1486","1487","1488","1489","1490","1491","1492","1493","1494","1495","1496"],"import React, {Dispatch, ReactElement, ReactNode} from 'react';\r\nimport {connect} from 'react-redux';\r\nimport {\r\n    Debug,\r\n    DEdgePoint,\r\n    DGraph,\r\n    DGraphElement,\r\n    DGraphVertex,\r\n    DState, DUser,\r\n    DVertex, DViewElement,\r\n    DVoidVertex,\r\n    EMeasurableEvents,\r\n    GObject,\r\n    GraphElementComponent,\r\n    GraphElementDispatchProps,\r\n    GraphElementOwnProps,\r\n    GraphElementReduxStateProps,\r\n    GraphElementStatee,\r\n    GraphPoint,\r\n    GraphSize,\r\n    LClass, LGraph, LGraphElement,\r\n    LModelElement, LNamedElement,\r\n    Log,\r\n    LPointerTargetable,\r\n    LUser, LViewElement,\r\n    LViewPoint,\r\n    LVoidVertex, Pointer,\r\n    RuntimeAccessibleClass,\r\n    SetRootFieldAction,\r\n    Size,\r\n    TRANSACTION,\r\n    U,\r\n} from '../../joiner';\r\nimport $ from 'jquery';\r\nimport 'jqueryui';\r\nimport 'jqueryui/jquery-ui.css';\r\nimport { lightModeAllowedElements } from '../graphElement/graphElement';\r\nimport ContextMenu from \"../../components/contextMenu/ContextMenu\";\r\nimport {VertexOwnProps, VertexStateProps} from '../graphElement/sharedTypes/sharedTypes';\r\n\r\nconst superclassGraphElementComponent: typeof GraphElementComponent = RuntimeAccessibleClass.classes.GraphElementComponent as any as typeof GraphElementComponent;\r\nclass ThisStatee extends GraphElementStatee { forceupdate?: number }\r\n\r\nconst dragHelper = document.createElement('div');\r\ndragHelper.style.backgroundColor = 'transparent';\r\ndragHelper.style.outline = '1px dashed black'; // '4px dashed #333';\r\ndragHelper.style.zIndex = '9999';\r\n\r\n\r\nexport class VertexComponent<AllProps extends AllPropss = AllPropss, ThisState extends ThisStatee = ThisStatee>\r\n    extends superclassGraphElementComponent<AllProps, ThisState> {\r\n    public static cname: string = 'VertexComponent';\r\n    static defaultProps: Partial<VertexOwnProps> = VertexOwnProps.new();\r\n    draggableOptions: GObject | undefined;\r\n    resizableOptions: GObject | undefined;\r\n    rotableOptions: GObject | undefined;\r\n\r\n    constructor(props: AllProps, context: any) {\r\n        super(props, context);\r\n        this.getSize = this.getSize.bind(this);\r\n        this.setSize = this.setSize.bind(this);\r\n        // this.state={forceupdate:1};\r\n        /*// remove this?\r\n        setTimeout(()=>{\r\n            this.getSize = this.getSize.bind(this);\r\n            this.setSize = this.setSize.bind(this);\r\n            // this.get_size = console.error as any;\r\n            // this.r = (<RootVertex props={this.props} render={super.render()} super={this} />);\r\n            this.forceUpdate();\r\n            this.setState({forceupdate:2});\r\n        },1)*/\r\n    }\r\n/*\r\n    onViewChangeOld(): void {\r\n        super.onViewChangeOld();\r\n        this.draggableOptions = undefined;\r\n        this.resizableOptions = undefined;\r\n        this.rotableOptions = undefined;\r\n    }*/\r\n\r\n    onHtmlNodeChange(){\r\n        this.draggableOptions = undefined;\r\n        this.resizableOptions = undefined;\r\n        this.rotableOptions = undefined;\r\n        this.oldHtml = this.html.current;\r\n    }\r\n\r\n    setVertexProperties(){\r\n        if (!this.props.node || !this.html.current) return;\r\n        switch (this.nodeType){\r\n            case 'GraphVertex':\r\n            case 'Vertex':\r\n            case 'VoidVertex':\r\n            case 'EdgePoint': break;\r\n            default: return;\r\n        }\r\n\r\n        let html = this.html.current;\r\n        const $measurable: GObject<'JQuery + ui plugin'> = $(html); // todo: install typings\r\n\r\n        let view: LViewElement = this.props.view;\r\n        let isDraggable: boolean = view.draggable;\r\n        let isResizable: boolean = view.resizable;\r\n        let allviews: Pointer<DViewElement>[] = [view, ...this.props.views].map(v=>v.id);\r\n        // $element = $(html).find('.measurable').addBack();\r\n        try {\r\n        if (!isDraggable) {\r\n            if ($measurable.data(\"uiDraggable\")) $measurable.draggable('disable');\r\n        }\r\n        else if (this.draggableOptions) {\r\n            if ($measurable.data(\"uiDraggable\")) $measurable.draggable('enable');\r\n            // NB: this check is to see if draggable has been setup. i think if 2 refreshes happens to fast it can\r\n            // happen that this.draggableOptions i set, but jqui didn't set up the draggable infos and throws warnings.\r\n        }\r\n        else {\r\n            // first setup only\r\n            this.draggableOptions = {\r\n                cursor: 'grabbing',\r\n                cancel: '.no-drag,[contenteditable=\"true\"],input,textarea,button,select,option',\r\n                // cancel: '.no-drag,input,textarea,button,select,option',\r\n                containment: 'parent',\r\n                opacity: 0.0,\r\n                disabled: !(isDraggable), // this does not work, i think because once set the first time the whole declaration is not re-applied. would need to undo draggable\r\n                distance: 5,\r\n                helper: () => { // or 'clone'\r\n                    // dragHelper.style.display='block';\r\n                    let size = this.getSize();\r\n                    // let actualSize = Size.of(html);\r\n                    // if (size.w !== actualSize.w || size.h !== actualSize.h) this.setSize({w:actualSize.w, h:actualSize.h});\r\n                    dragHelper.style.width = size.w + 'px';\r\n                    dragHelper.style.height = size.h + 'px';\r\n                    dragHelper.style.opacity = '1'; // this.props.view.constraints.length ? '1' : '0.5';\r\n                    if (this.props.view.lazySizeUpdate) dragHelper.classList.add('lazySizeUpdate');\r\n                    else dragHelper.classList.remove('lazySizeUpdate');\r\n                    return dragHelper;\r\n                },\r\n                // disabled: !(view.draggable),\r\n                start: (event: GObject, obj: GObject) => {\r\n                    TRANSACTION('Vertex dragStart ' + this.props.node.name, ()=> {\r\n                        for (let vid of allviews) this.doMeasurableEvent(EMeasurableEvents.onDragStart, vid);\r\n                    })\r\n                },\r\n                drag: (event: GObject, obj: GObject) => {\r\n                    TRANSACTION('Vertex dragging ' + this.props.node.name, ()=>{\r\n                        // console.log('Vertex.setsize', obj);\r\n                        if (!this.props.view.lazySizeUpdate) this.setSize({x:obj.position.left, y:obj.position.top});\r\n                        for (let vid of allviews) this.doMeasurableEvent(EMeasurableEvents.whileDragging, vid);\r\n                    })\r\n                },\r\n                stop: (event: GObject, obj: GObject) => {\r\n                    TRANSACTION('Vertex dragEnd ' + this.props.node.name, ()=>{\r\n                        this.setSize({x:obj.position.left, y:obj.position.top});\r\n                        for (let vid of allviews) this.doMeasurableEvent(EMeasurableEvents.onDragEnd, vid);\r\n                    })\r\n                }\r\n            };\r\n            $measurable.draggable(this.draggableOptions);\r\n        }\r\n        } catch(e) {\r\n            this.draggableOptions = undefined;\r\n            Log.ee(\"failed to setup / update draggable uptions\", e, this, this.props.node, this.props.data);\r\n            return;\r\n            // might throw error if element is not visible or in the dom or similar, but i won't care in that case.\r\n            // but i reset draggableOptions so it can retry later if element enters the DOM instead of thinking it is already finished setup\r\n        }\r\n\r\n        try{\r\n        if (!isResizable) {\r\n            if ($measurable.data(\"uiResizable\")) $measurable.resizable('disable');\r\n        }\r\n        else if (this.resizableOptions) {\r\n            if ($measurable.data(\"uiResizable\")) $measurable.resizable('enable');\r\n        }\r\n        if (!this.resizableOptions) {\r\n            this.resizableOptions = {\r\n                helper: 'selected-by-me',\r\n                start: (event: GObject, obj: GObject) => {\r\n                    TRANSACTION('onResizeStart events ' + this.props.node.name, ()=>{\r\n                        if (!this.props.node.isResized) this.props.node.isResized = true; // set only on manual resize, so here and not on setSize()\r\n                        for (let vid of allviews) this.doMeasurableEvent(EMeasurableEvents.onResizeStart, vid);\r\n                    })\r\n                },\r\n                resize: (event: GObject, obj: GObject) => {\r\n                    TRANSACTION('resizing events ' + this.props.node.name, ()=>{\r\n                        if (!this.props.view.lazySizeUpdate) this.setSize({w:obj.position.width, h:obj.position.height});\r\n                        for (let vid of allviews) this.doMeasurableEvent(EMeasurableEvents.whileResizing, vid);\r\n                    })\r\n                },\r\n                stop: (event: GObject, obj: GObject) => {\r\n                    if (!this.state.classes.includes('resized')) this.setState({classes:[...this.state.classes, 'resized']});\r\n                    // if (!withSetSize) { node.width = obj.size.width; node.height = obj.size.height; } else {\r\n                    let absolutemode = true; // this one is less tested and safe, but should work even if html container is sized 0. best if made to work\r\n                    let newSize: Partial<GraphSize>;\r\n                    if (absolutemode) {\r\n                        let nativeevt: MouseEvent = event.originalEvent.originalEvent;\r\n                        let htmlSize = Size.of(event.target, false);\r\n                        newSize = this.props.node.graph.translateHtmlSize(htmlSize);\r\n                        /*n\r\n                        this is some pixels off, i think because inner coords are post the border of the container element,\r\n                         and the innermost graph size have coords before his borders, so the translation is off by the amount\r\n                          of border width of the innermost graph (and package default view does have a border)\r\n                           so in graph coord translate function should add: outersize.add( x: innergraph.html.getFinalComputedCSS('border-width-left'), y: ...border-width-top\r\n\r\n                    let cursorSize = new GraphSize(0, 0, nativeevt.clientX, nativeevt.clientY);//\r\n                    newSize = htmlSize.duplicate() as any; // .subtract( {w:cursorSize.x, h:cursorSize.y}, true);\r\n                    let handleClasses: string[] = [...event.originalEvent.target.classList];\r\n                    let handleKeyLength = 14; // equal to 'ui-resizable-'.length + 1;\r\n                    let handleClassName = handleClasses.find( // i check both length and indexOf, because i must match 'ui-resizable-se' but not 'ui-resizable-handle'\r\n                        (e) => (e.length === handleKeyLength || e.length === handleKeyLength + 1) && e.indexOf('ui-resizable-')===0);\r\n\r\n                        let handleType = handleClassName ? handleClassName.substring(13) : '';\r\n                        switch (handleType) {\r\n                            default: case '': case 'se':\r\n                                delete newSize.x;\r\n                                delete newSize.y;\r\n                                newSize.w = cursorSize.w - htmlSize.x;\r\n                                newSize.h = cursorSize.h - htmlSize.y;\r\n                                break;\r\n                            case 'n': case 's':\r\n                                delete newSize.x;\r\n                                delete newSize.y;\r\n                                delete newSize.w;\r\n                                newSize.h = cursorSize.h - htmlSize.y;\r\n                                break;\r\n                            case 'e': case 'W':\r\n                                delete newSize.x;\r\n                                delete newSize.y;\r\n                                newSize.w = cursorSize.w - htmlSize.x;\r\n                                delete newSize.h;\r\n                                break;\r\n                            case 'nw':\r\n                                let br = htmlSize.br();\r\n                                newSize.x = cursorSize.x;\r\n                                newSize.y = cursorSize.y;\r\n                                newSize.w = br.x - cursorSize.w;\r\n                                newSize.h = br.y - cursorSize.h;\r\n                                break;\r\n                            case 'ne':\r\n                                delete newSize.x;\r\n                                newSize.y = cursorSize.y;\r\n                                delete newSize.w;\r\n                                delete newSize.h;\r\n                            case '?':\r\n                                delete newSize.x;\r\n                                delete newSize.y;\r\n                                delete newSize.w;\r\n                                delete newSize.h;\r\n                                break;\r\n                        }*/\r\n                        // n, e, s, w, ne, se, sw, nw\r\n                        console.log('resizing', {newSize, htmlSize, event, nativeevt, sizeof_with_transforms: Size.of(event.target, true)});\r\n                        // NB: size.x and size.y are going crazy if the element have an edge, no idea why, i just deleted x & y before setSize()\r\n                    }\r\n                    else newSize = {w:obj.size.width, h:obj.size.height};\r\n                    // evt coordinates: clientX, layerX, offsetX, pageX, screenX\r\n                    TRANSACTION('onResizeEnd events ' + this.props.node.name, ()=>{/*\r\n                        delete newSize.x;\r\n                        delete newSize.y;*/\r\n                        this.setSize(newSize);\r\n                        // console.log('resize setsize:', obj, {w:obj.size.width, h:obj.size.height});\r\n                        for (let vid of allviews) this.doMeasurableEvent(EMeasurableEvents.onResizeEnd, vid);\r\n                    })\r\n\r\n                }\r\n            }\r\n            $measurable.resizable(this.resizableOptions);\r\n        }\r\n        } catch(e){\r\n            // check draggable catch comment\r\n            this.resizableOptions = undefined;\r\n            Log.ee(\"failed to setup / update resizable uptions\", e, this, this.props.node, this.props.data);\r\n            return;\r\n        }\r\n\r\n        try{\r\n            // edit dynamic draggable options post-setup\r\n            if (this.draggableOptions) {\r\n                // none so far?\r\n            }\r\n            // edit dynamic resizable options post-setup\r\n            if (this.resizableOptions) {\r\n                let lazySizeUpdate = view.lazySizeUpdate;\r\n                let containment = lazySizeUpdate ? false : 'parent';\r\n                let helper = lazySizeUpdate ? 'resizable-helper-bad' : 'original';\r\n                // helper does not accept a func or htmlElem, but only a classname...\r\n                // and makes his own empty proxy element to resize in his place. inchoherent.\r\n                if (this.resizableOptions?.containment !== containment){\r\n                    this.resizableOptions.containment = containment;\r\n                    $measurable.draggable( 'option', 'containment', containment);\r\n                }\r\n                if (this.resizableOptions?.helper !== helper){\r\n                    this.resizableOptions.helper = helper;\r\n                    $measurable.resizable( 'option', 'helper', helper);\r\n                }\r\n            }\r\n        } catch(e) {\r\n            // check draggable catch comment\r\n            this.draggableOptions = undefined;\r\n            this.resizableOptions = undefined;\r\n            this.rotableOptions = undefined;\r\n            Log.ee(\"failed to update measurable uptions\", e, this, this.props.node, this.props.data);\r\n            return;\r\n        }\r\n    }\r\n\r\n\r\n\r\n    getSize(): Readonly<GraphSize> {\r\n        return this.props.node.getSize(false, !this.props.node.isResized && this.props.view.adaptWidth);\r\n        /*console.log('get_size('+(this.props?.data as any).name+')', {\r\n            view:this.props.view.getSize(this.props.dataid || this.props.nodeid as string),\r\n            node:this.props.node?.size,\r\n            default: this.props.view.defaultVSize});*/\r\n        let ret = this.props.view.getSize(this.props.data?.id || this.props.nodeid as string)\r\n            || this.props.node?.size\r\n            || this.props.view.defaultVSize;\r\n        if (this.props.node.isResized) return ret;\r\n        let actualSize: Partial<Size>&{w:number, h:number} = this.html.current ? Size.of(this.html.current as Element) : {w:0, h:0};\r\n        if (this.props.view.adaptWidth && ret.w !== actualSize.w) {\r\n            this.setSize({w:actualSize.w});\r\n            ret.w = actualSize.w;\r\n        }\r\n        if (this.props.view.adaptHeight && ret.h !== actualSize.h) {\r\n            this.setSize({h:actualSize.h});\r\n            ret.h = actualSize.h;\r\n        }\r\n        return ret;\r\n    }\r\n    // setSize(x_or_size_or_point: number, y?: number, w?:number, h?:number): void;\r\n    setSize(x_or_size_or_point: Partial<GraphPoint>): void;\r\n    setSize(x_or_size_or_point: Partial<GraphSize>): void;\r\n    // setSize(x_or_size_or_point: number | GraphSize | GraphPoint, y?: number, w?:number, h?:number): void;\r\n    setSize(size0: Partial<GraphSize> | Partial<GraphPoint>): void {\r\n        let size: {x?:number, y?: number, w?:number, h?:number} = size0;\r\n        if (size.w !== undefined && size.w < 0) size.w = 0;\r\n        if (size.h !== undefined && size.h < 0) size.h = 0;\r\n\r\n        console.log('L.setsize', size, size0);\r\n        return this.props.node.size = size as any;\r\n        // console.log('setSize('+(this.props?.data as any).name+') thisss', this);\r\n        if (this.props.view.storeSize) {\r\n            let id = (this.props.data?.id || this.props.nodeid) as string;\r\n            this.props.view.updateSize(id, size);\r\n            return;\r\n        }\r\n        let olds = this.props.node.size;\r\n        size.x = size.x === undefined ? olds?.x : size.x;\r\n        size.y = size.y === undefined ? olds?.y : size.y;\r\n        size.w = size.w === undefined ? olds?.w : size.w;\r\n        size.h = size.h === undefined ? olds?.h : size.h;\r\n        this.props.node.size = size as GraphSize;\r\n    }\r\n\r\n    oldHtml?: Element | null = null;\r\n    nodeType!: string;\r\n    render(): ReactNode {\r\n        if (Debug.lightMode && (!this.props.data || !(lightModeAllowedElements.includes(this.props.data.className)))){\r\n            return this.props.data ? <div>{\" \" + ((this.props.data as any).name)}:{this.props.data.className}</div> : undefined;\r\n        }\r\n        if (!this.props.node) return 'Loading Node...';\r\n\r\n        if (this.html.current !== this.oldHtml){ this.onHtmlNodeChange(); }\r\n\r\n        const cssOverride: string[] = [];\r\n        // const selected = this.props.selected;\r\n        // if (selected && selected.id === this.props.nodeid) cssOverride.push('selected-by-me');\r\n\r\n        // if(!windoww.cpts) windoww.cpts = {};\r\n        // windoww.cpts[this.props.nodeid]=this;\r\n        // console.log('updated');\r\n        //return this.r || <div>loading...</div>;\r\n\r\n        // set classes\r\n        this.nodeType = 'NODE_TYPE_ERROR';\r\n        if ( this.props.isEdgePoint) this.nodeType = 'EdgePoint'; else\r\n        if ( this.props.isGraph &&  this.props.isVertex) this.nodeType = 'GraphVertex'; else\r\n        if ( this.props.isGraph && !this.props.isVertex) this.nodeType = 'Graph'; else\r\n        if (!this.props.isGraph &&  this.props.isVertex && (this.props.isVoid || !this.props.data)) this.nodeType = 'VoidVertex'; else\r\n        if (!this.props.isGraph &&  this.props.isVertex) this.nodeType = 'Vertex'; else\r\n        if (!this.props.isGraph && !this.props.isVertex) this.nodeType = 'Field';\r\n\r\n        // const named: LNamedElement = this.props.data as LNamedElement; // LNamedElement.fromPointer(this.props.dataid);\r\n        const classesOverride = [this.nodeType, ...cssOverride]; // , (named?.name === 'default') ? 'default' : ''];\r\n        const styleOverride: React.CSSProperties = {};\r\n        // set classes end\r\n        const size: Readonly<GraphSize> = this.getSize();\r\n\r\n        let isVertex: boolean= false, isEdge: boolean= false, isGraph: boolean = false;\r\n        switch (this.nodeType) {\r\n            case 'Graph': isGraph = true; break;\r\n            case 'GraphVertex': isGraph = isVertex = true; break;\r\n            case 'Vertex':\r\n            case 'VoidVertex':\r\n            case 'EdgePoint':\r\n                isVertex = true;\r\n                break;\r\n            default: break;\r\n        }\r\n\r\n        if (isGraph){\r\n            let offset = (this.props.node as any as LGraph).offset;\r\n            let zoom = (this.props.node as any as LGraph).zoom;\r\n            // @ts-ignore\r\n            styleOverride['--offset-x'] = offset.x + 'px';\r\n            // @ts-ignore\r\n            styleOverride['--offset-y'] = offset.y + 'px';\r\n            // @ts-ignore\r\n            styleOverride['--zoom-x'] = zoom.x;\r\n            // @ts-ignore\r\n            styleOverride['--zoom-y'] = zoom.y;\r\n        }\r\n        if (isVertex){\r\n            // @ts-ignore\r\n            styleOverride['--top'] = size.y + 'px';\r\n            // @ts-ignore\r\n            styleOverride['--left'] = size.x + 'px';\r\n            let isResized = this.props.node.isResized;\r\n            if (isResized || !this.props.view.adaptWidth) styleOverride.width = size.w+'px';\r\n            else styleOverride.width = undefined;\r\n            if (isResized || !this.props.view.adaptHeight) styleOverride.height = size.h+'px';\r\n            else styleOverride.height = undefined; // todo: the goal is to reset jqui inline style, but not override user-defined inline style\r\n        }\r\n\r\n\r\n        return super.render(this.nodeType, styleOverride, classesOverride);\r\n        // return <RootVertex props={this.props} render={super.render()} super={this} key={this.props.nodeid+'.'+this.state?.forceupdate} />;\r\n    }\r\n\r\n    select(forUser?: Pointer<DUser>): void{\r\n        super.select(forUser);\r\n    }\r\n    componentDidMount(){\r\n        this.setVertexProperties();\r\n    }\r\n    componentDidUpdate(prevProps: Readonly<AllProps>, prevState: Readonly<ThisState>, snapshot?: any) {\r\n        this.setVertexProperties();\r\n    }\r\n}\r\n\r\n\r\nclass DispatchProps extends GraphElementDispatchProps {\r\n}\r\n\r\nexport type AllPropss = VertexOwnProps & VertexStateProps & DispatchProps;\r\n\r\nfunction mapStateToProps(state: DState, ownProps: VertexOwnProps): VertexStateProps {\r\n    let DGraphElementClass: typeof DGraphElement;\r\n    if (ownProps.isEdgePoint) DGraphElementClass = DEdgePoint; else\r\n    if (ownProps.isVertex && ownProps.isGraph) DGraphElementClass = DGraphVertex; else\r\n    if (ownProps.isVertex && !ownProps.isGraph) DGraphElementClass = DVertex; else\r\n    if (!ownProps.isVertex && ownProps.isGraph) DGraphElementClass = DGraph;\r\n    else DGraphElementClass = DGraphElement; // DField;\r\n\r\n    if (DGraphElementClass === DVertex && ownProps.isVoid) DGraphElementClass = DVoidVertex;\r\n    const superret: VertexStateProps = GraphElementComponent.mapStateToProps(state, ownProps, DGraphElementClass, VertexStateProps.new()) as VertexStateProps;\r\n    // superret.lastSelected = state._lastSelected?.modelElement;\r\n    // superret.lastSelected = state._lastSelected ? LPointerTargetable.from(state._lastSelected.modelElement) : null;\r\n\r\n    // change current to correct user ID when authentication is implemented.\r\n    // const selected = state.selected[DUser.current];\r\n    // uperret.selected = (selected) ? LGraphElement.fromPointer(selected) : null;\r\n    /*  Uncomment this when we have user authentication.\r\n    superret.selected = {};\r\n    for(let user of Object.keys(selected)) {\r\n        const pointer = selected[user];\r\n        if (pointer) superret.selected[user] = LModelElement.fromPointer(pointer);\r\n        else superret.selected[user] = null;\r\n    }\r\n    */\r\n\r\n    superret.isEdgePending = {\r\n        user: LPointerTargetable.from(state.isEdgePending.user),\r\n        source: LPointerTargetable.from(state.isEdgePending.source)\r\n    };\r\n    // superret.viewpoint = LViewPoint.fromPointer(state.viewpoint);\r\n    /*const ret: VertexStateProps = VertexStateProps.new();\r\n    U.objectMergeInPlace(superret, ret);*/\r\n    U.removeEmptyObjectKeys(superret);\r\n    return superret;\r\n}\r\n\r\nfunction mapDispatchToProps(dispatch: Dispatch<any>): DispatchProps {\r\n    const superret: GraphElementDispatchProps = GraphElementComponent.mapDispatchToProps(dispatch);\r\n    const ret: GraphElementDispatchProps = new GraphElementDispatchProps();\r\n    U.objectMergeInPlace(superret, ret);\r\n    U.removeEmptyObjectKeys(superret);\r\n    return superret;\r\n}\r\nexport const VertexConnected = connect<VertexStateProps, DispatchProps, VertexOwnProps, DState>(\r\n    mapStateToProps,\r\n    mapDispatchToProps\r\n)(VertexComponent as any);\r\n\r\nexport const Vertex = (props: VertexOwnProps, children: ReactNode | undefined = []): ReactElement => { //  children: (string | React.Component)[]\r\n    return <VertexConnected {...{...props, children}}\r\n        isGraph={false} isGraphVertex={false} isVertex={true} isEdgePoint={false} isField={false} isEdge={false} isVoid={false}/>;\r\n}\r\nexport const VoidVertex = (props: VertexOwnProps, children: ReactNode | undefined = []): ReactElement => {\r\n    return <VertexConnected {...{...props, children}}\r\n                            isGraph={false} isGraphVertex={false} isVertex={true} isEdgePoint={false} isField={false} isEdge={false} isVoid={true}/>;\r\n}\r\nexport const EdgePoint = function EdgePoint (props: VertexOwnProps, children: ReactNode | undefined = []): ReactElement {\r\n    return <VertexConnected {...{...props, children}}\r\n                            isGraph={false} isGraphVertex={false} isVertex={true} isEdgePoint={true} isField={false} isEdge={false} isVoid={false}/>;\r\n}\r\n// todo: name them all or verify the name is still usable.\r\n\r\nexport const Graph = (props: VertexOwnProps, children: ReactNode | undefined = []): ReactElement => {\r\n    return <VertexConnected {...{...props, children}}\r\n                            isGraph={true} isGraphVertex={false} isVertex={false} isEdgePoint={false} isField={false} isEdge={false} isVoid={false} />;\r\n}\r\n\r\nexport const GraphVertex = (props: VertexOwnProps, children: ReactNode | undefined = []): ReactElement => {\r\n    return <VertexConnected {...{...props, children}}\r\n                            isGraph={true} isGraphVertex={true} isVertex={true} isEdgePoint={false} isField={false} isEdge={false} isVoid={false}/>;\r\n}\r\n\r\nexport const Field = (props: VertexOwnProps, children: ReactNode | undefined = []): ReactElement => {\r\n    return <VertexConnected {...{...props, children}}\r\n                            isGraph={false} isGraphVertex={false} isVertex={false} isEdgePoint={false} isField={true} isEdge={false} isVoid={false} />;\r\n}\r\n(window as any).componentdebug = {Graph, GraphVertex, Field, Vertex, VoidVertex, EdgePoint, VertexConnected, VertexComponent};\r\n\r\n\r\nGraph.cname = 'Graph';\r\nGraphVertex.cname = 'GraphVertex';\r\nField.cname = 'Field';\r\nVertex.cname = 'Vertex';\r\nVoidVertex.cname = 'VoidVertex';\r\nEdgePoint.cname = 'EdgePoint';\r\n\r\n// GraphConnected.cname = 'GraphConnected';\r\n// GraphVertexConnected.cname = 'GraphVertexConnected';\r\n// FieldConnected.cname = 'FieldConnected';\r\nVertexConnected.cname = 'VertexConnected';\r\n// VoidVertexConnected.cname = 'VoidVertexConnected';\r\n// EdgePointConnected.cname = 'EdgePointConnected';\r\n\r\n// GraphComponent.cname = 'GraphComponent';\r\n// GraphVertexComponent.cname = 'GraphVertexComponent';\r\n// FieldComponent.cname = 'FieldComponent';\r\nVertexComponent.cname = 'VertexComponent';\r\n// VoidVertexComponent.cname = 'VoidVertexComponent';\r\n// EdgePointComponent.cname = 'EdgePointComponent';\r\n","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\components\\logger\\loggerComponent.tsx",["1497","1498"],"import React, {PureComponent, ReactNode} from \"react\";\r\nimport './logger.scss';\r\nimport {DataOutputComponent, Log, U} from \"../../joiner\";\r\nimport type {Dictionary, GObject, LoggerType, LoggerCategoryState} from \"../../joiner\";\r\n\r\n// private\r\nclass ThisState {\r\n    categoriesActive: Dictionary<LoggerType, boolean> = {l: true, i: true, w: true, e: true, ex: true, eDev: true, exDev: true};\r\n    searchTag: string = '';\r\n    searchTagAsRegExp: boolean = false;\r\n    searchTagIsDeep: boolean = false;\r\n    regexpIsInvalid: boolean = false; // to mark the input as invalid without triggering a Log.e message loop\r\n\r\n    // counters to force update. (data source is in Log.messageMapping\r\n    l_counter: number = 0;\r\n    i_counter: number = 0;\r\n    w_counter: number = 0;\r\n    e_counter: number = 0;\r\n    ex_counter: number = 0;\r\n    eDev_counter: number = 0;\r\n    exDev_counter: number = 0;\r\n}\r\n/*interface ThisState\r\n    messages: Dictionary<string, Dictionary<string, any[]>>\r\n    filters: {category: ((cat: string) => boolean) | null, tag: ((tag: string) => boolean) | null, datafilter: ((data: any[]) => boolean) | null};\r\n    id: number;\r\n    minDate: UnixTimestamp;\r\n    maxDate: UnixTimestamp;\r\n}*/\r\nlet count = 0;\r\nconst msgdurations: Dictionary<LoggerType, number> = {\r\n    'exDev': 2,\r\n    'eDev': 2,\r\n    'ex': 2,\r\n    'e': 2,\r\n    'w': 1.5,\r\n    'l': 1.25,\r\n    'i': 1,\r\n}\r\nfunction getDuration(msg: LoggerCategoryState): number{\r\n    // average English reading speed is 250 WPM\r\n    // average english word is 4.5 char\r\n    // 18.5 char/sec;\r\n    let len = msg.short_string.length/18.5;\r\n    return (len < 1000 ? 100 : len) * (msgdurations[msg.category] || 1);\r\n}\r\nexport class LoggerComponent extends PureComponent<AllProps, ThisState>{\r\n    public static cname: string = \"LoggerComponent\";\r\n    public static loggers: LoggerComponent[] = [];\r\n    private static max_id: number = 0;\r\n    id: number;\r\n    categoryAliases: Partial<Dictionary<LoggerType, LoggerType>>;\r\n    /*public static Log(category: string, key: string, data: any[]): void{\r\n        for (let logger of LoggerComponent.loggers) { logger.log(category, key, data); }\r\n    }*/\r\n\r\n    constructor(props: AllProps, context: any) {\r\n        super(props, context);\r\n        this.id =  LoggerComponent.max_id++;\r\n        this.state = new ThisState();\r\n            // minDate: DDate.addYear(new Date(), -1, true).getTime(),\r\n            // maxDate: DDate.addYear(new Date(), +1, true).getTime()};\r\n        LoggerComponent.loggers.push(this);\r\n        Log._loggerComponent = this;\r\n\r\n        this.categoryAliases = {l: null as any, ex:\"e\", exDev:\"eDev\"};\r\n        // Log.registerLogger(this, Log.e);\r\n    }\r\n    private generateToasts(allMessages: LoggerCategoryState[], categories: LoggerType[]): JSX.Element {\r\n        let now = Date.now();\r\n        let old = allMessages;\r\n        return <div className={'jjtoast-holder text-selectable'}>\r\n            <button>{count++}</button>\r\n            {allMessages.map(msg=>this.toast(msg))}\r\n        </div>\r\n    }\r\n    private toast(msg: LoggerCategoryState): JSX.Element {\r\n        if (!msg.expireTime) msg.expireTime = msg.time + getDuration(msg);\r\n\r\n        return <div className={'jjtoast ' + msg.category}\r\n                    key={msg.time + msg.short_string[0]}\r\n                    data-duration={(msg.expireTime - msg.time)+''}\r\n                    onClick={() => { U.clipboardCopy(msg.long_string); (msg.expireTime as number) += getDuration(msg); }}>\r\n            <div className={'msg'}>{(msg as any).primitiveStringified}</div>\r\n            <i className={'bi bi-x-lg closebtn'} onClick={() => { msg.toastHidden = true; }} />\r\n            {/*\r\n            <div className={'preview inline'}>{msg.short_string}</div>\r\n            <div className={'content inline'}>{msg.long_string}</div>\r\n            */}\r\n        </div>\r\n    }\r\n\r\n    private isCatActive(cat: LoggerType): boolean {\r\n        if (this.categoryAliases[cat] !== undefined/* null must pass! */) cat = this.categoryAliases[cat] as LoggerType;\r\n        return !!this.state.categoriesActive[cat];\r\n    }\r\n\r\n    private changeSearch = (e: React.ChangeEvent<HTMLInputElement>): void => {\r\n        this.setState({...this.state, searchTag: e.target.value, regexpIsInvalid: false});\r\n    }\r\n    private changeRegexpSearch = (e: React.ChangeEvent<HTMLInputElement>) => {\r\n        this.setState({...this.state, searchTagAsRegExp: e.target.checked});\r\n    }\r\n    private changeDeepSearch = (e: React.ChangeEvent<HTMLInputElement>) => {\r\n        this.setState({...this.state, searchTagIsDeep: e.target.checked});\r\n    }\r\n    /*\r\n    private changeMinDate = (e: React.ChangeEvent<HTMLInputElement>) => {\r\n        this.setState({...this.state, minDate: new Date(e.target.value).getTime() });\r\n\r\n    }\r\n    private changeMaxDate = (e: React.ChangeEvent<HTMLInputElement>) => {\r\n        this.setState({...this.state, maxDate: new Date(e.target.value).getTime() });\r\n    }*/\r\n    filter(msg: LoggerCategoryState): boolean{\r\n        let s = this.state.searchTagIsDeep ?  msg.long_string : msg.short_string;\r\n        if (this.state.searchTagAsRegExp) {\r\n            try {\r\n                let regexp = new RegExp(this.state.searchTag);\r\n                return regexp.test(s);\r\n            } catch (e: any) {\r\n\r\n                // this is to avoid a loop of render-error\r\n                if (!this.state.regexpIsInvalid){\r\n                    this.setState({regexpIsInvalid: true});\r\n                    Log.ee(\"invalid regular expression in Logger.filter\", (e.message || '').split('\\n')[0]);\r\n                }\r\n            }\r\n        }\r\n        return s.indexOf(this.state.searchTag) >= 0;\r\n    }\r\n\r\n    toggleCat(cat: LoggerType): void{\r\n        this.setState({categoriesActive:{...this.state.categoriesActive, [cat]: !this.state.categoriesActive[cat]}} )\r\n    }\r\n    displayArgs(msg: LoggerCategoryState, category: LoggerType): ReactNode{\r\n        if (!msg?.raw_args) return undefined;\r\n        let args = msg.raw_args;\r\n        if (!Array.isArray(args)) args = [args];\r\n        let objs: GObject[] = [];\r\n        let primitives: any[] = [];\r\n\r\n        for (let a of args){\r\n            switch(typeof a){\r\n                case \"object\": case \"function\": objs.push(a); primitives.push(\"[\"+(typeof a)+\"_\"+(objs.length)+\"]\"); break;\r\n                case \"symbol\": primitives.push(a.toString()); break;\r\n                default: primitives.push(a);\r\n            }\r\n        }\r\n        (msg as any).primitiveStringified = primitives.join(' ');\r\n        let date = new Date(msg.time);\r\n\r\n        return <div className={\"cat hoverable cat_\"+category}>\r\n            <div className={\"text\"}>{(msg as any).primitiveStringified}</div>\r\n            <div className={\"text content\"} style={{right: 0, top: 0, boxShadow: 'none', background: 'inherit'}}>\r\n                {date.getDate() +'/'+ date.toLocaleTimeString()}\r\n                <button title={\"copy to clipboard\"} className={\"bg btn-clipboard my-auto ms-2\"}\r\n                        onClick={(e)=> {\r\n                            (window as any).lastmsg = msg;\r\n                            console.log(msg);\r\n                            U.clipboardCopy(msg.long_string)\r\n                        }}\r\n                ><i className={\"copy bi bi-clipboard\"} /></button>\r\n                <button title={\"report error\"} className={\"bg btn-clipboard my-auto ms-2\"}\r\n                        onClick={(e)=> {\r\n                            (window as any).lastmsg = msg;\r\n                            console.log(msg);\r\n                            U.clipboardCopy(msg.long_string)\r\n                        }}\r\n                ><i className={\"copy bi bi-clipboard\"} /></button>\r\n            </div>\r\n            { objs.map((o,i) => <DataOutputComponent key={i} data={o} rootName={\"\"+(typeof o)+\"_\"+(i+1)+\"\"} />) }\r\n        </div>;\r\n    }\r\n\r\n    clearLogs() {\r\n        for (let key in Log.messageMapping) Log.messageMapping[key as LoggerType] = [];\r\n        Log.allMessages = [];\r\n        this.forceUpdate();\r\n        // just need to modify any counter in a way that is different from both curr val and the next counter update\r\n        // this.setState({e_counter: -1});\r\n    }\r\n    getAllMessages(categories: LoggerType[]): LoggerCategoryState[] {\r\n        let key: LoggerType;\r\n        let allMessages: LoggerCategoryState[] = [];\r\n        for (key of categories) {\r\n            if (!this.isCatActive(key)) continue; // U.arrayMergeInPlace(allMessages, Log.messageMapping[key])\r\n            let msg: LoggerCategoryState;\r\n            for (msg of Log.messageMapping[key]) {\r\n                if (this.filter(msg)) allMessages.push(msg);\r\n            }\r\n        }\r\n        // order is reversed so newest is first in list\r\n        return allMessages.sort((a, b) => b.time - a.time);\r\n    }\r\n    render(): ReactNode {\r\n        const categoryAliases = this.categoryAliases;\r\n        const categories: LoggerType[] = (Object.keys(Log.messageMapping) as LoggerType[]).filter(c => categoryAliases[c] !== null);\r\n        // order is reversed so newest is first in list\r\n        let allMessages: LoggerCategoryState[] = this.getAllMessages(categories)\r\n        const labelAliases: Dictionary<string, string> = {i:\"Info\", w:\"Warning\", e:\"Errors\", eDev:\"Exceptions\"};\r\n\r\n        return (<div className={'logger-tab'}>\r\n            <div>\r\n                <div className={\"d-flex search-row p-1\"}>\r\n                    <input placeholder={\"filter\"} className={\"form-control search \" + (this.state.regexpIsInvalid && \"invalid\")} type={\"search\"} value={this.state.searchTag} onChange={ this.changeSearch } />\r\n                    <label className={\"checkbox\"}>\r\n                        <input className=\"input\" type=\"checkbox\" checked={this.state.searchTagAsRegExp} onChange={this.changeRegexpSearch} />\r\n                        <label>RegExp</label>\r\n                    </label>\r\n                    <label className={\"checkbox\"}>\r\n                        <input className=\"input\" type=\"checkbox\" checked={this.state.searchTagIsDeep} onChange={this.changeDeepSearch} />\r\n                        <label>Deep</label>\r\n                    </label>\r\n                    <button onClick={e => this.clearLogs()} className={'btn btn-danger ms-1'}>\r\n                        <i className={'p-1 bi bi-trash3-fill'}>Clear</i>\r\n                    </button>\r\n                </div>\r\n                {/*<input label={\"from\"} type=\"datetime-local\" value={ new Date(this.state.minDate).toString()} onChange={this.changeMinDate} />\r\n                <input label={\"to\"} type=\"datetime-local\" value={ new Date(this.state.maxDate).toString()} onChange={this.changeMaxDate} /> */}\r\n            </div>\r\n            <div className={\"categories\"}>\r\n                { categories.filter(cat => !(cat in categoryAliases)).map((cat) => (\r\n                    <button className={\"btn btn\"+(this.isCatActive(cat) && \"-outline\")+\"-danger cat cat_\" + cat + (this.isCatActive(cat) ? \" active\" : \" inactive\")}\r\n                            key={cat} onClick={e=>this.toggleCat(cat)}>{labelAliases[cat] || cat}</button>))\r\n                }\r\n            </div>\r\n            <ul className={\"entries\"}>\r\n                { allMessages.map( (msg) => (\r\n                        <li className={\"hoverable cat cat_\"+msg.category} key={msg.key/*time+'_'+msg.short_string*/}>\r\n                            {false && <span className={\"preview\"}>{msg.short_string}</span>}\r\n                            {false && <span className={\"content\"}>{msg.long_string}</span>}\r\n                            {this.displayArgs(msg, msg.category)}\r\n                        </li>))\r\n                }\r\n            </ul>\r\n        </div>); }\r\n\r\n\r\n/*\r\n    public log = (category: string, key: string, data: any[], fullconcat?: string): void => {\r\n        if (!this.state.categoriesActive.hasOwnProperty(category)) {\r\n            this.setState({categoriesActive: { ...this.state.categoriesActive, category: true}});\r\n            const category: GObject = {};\r\n            category[key] = data;\r\n            this.setState({messages: { ...this.state.messages, category} });\r\n        }\r\n\r\n        const messages: GObject = { ...this.state.messages};\r\n        messages[category] = messages[category] ? { ...messages[category]} : {};\r\n        messages[category][key] = messages[category][key] ? [ ...messages[category][key], data] : [data];\r\n        this.setState( {messages});\r\n    }// .bind(this);\r\n*/\r\n    componentWillUnmount(): void {\r\n        Log._loggerComponent = null;\r\n        // U.arrayRemoveAll(LoggerComponent.loggers, this);\r\n    }\r\n    componentDidMount() {\r\n        Log._loggerComponent = this;\r\n    }\r\n}\r\n\r\n// private\r\ninterface OwnProps {\r\n    // propsRequestedFromHtmlAsAttributes: string;\r\n}\r\n// private\r\ninterface StateProps {\r\n    // propsFromReduxStateOrOtherKindOfStateManagement: boolean; // flux or custom things too, unrelated to this.state of react.\r\n}\r\n\r\n// private\r\ninterface DispatchProps {\r\n    // propsFromReduxActions: typeof funzioneTriggeraAzioneDaImportare;\r\n}\r\n\r\n\r\n// private\r\ntype AllProps = OwnProps & StateProps & DispatchProps;\r\n\r\n////// mapper func\r\n\r\n/*\r\nfunction mapStateToProps(state: DState, ownProps: OwnProps): StateProps {\r\n    const ret: StateProps = {} as any;\r\n    /// to fill\r\n    return ret; }\r\n\r\nfunction mapDispatchToProps(dispatch: Dispatch<any>): DispatchProps {\r\n    const ret: DispatchProps = {} as any;\r\n    /// to fill\r\n    return ret; }\r\n\r\nexport const LoggerComponentConnected = connect<StateProps, DispatchProps, OwnProps, DState>(\r\n    mapStateToProps,\r\n    mapDispatchToProps\r\n)(LoggerComponent);*/\r\n","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\pages\\components\\BottomBar.tsx",["1499","1500","1501","1502","1503","1504"],"import './style.scss';\r\nimport {DState, DUser, LGraphElement, LModelElement, LUser, U} from \"../../joiner\";\r\nimport {FakeStateProps} from \"../../joiner/types\";\r\nimport React, {Dispatch, ReactElement, useState} from \"react\";\r\nimport {connect} from \"react-redux\";\r\n\r\n\r\nimport swen from '../../static/img/swen-splash.png';\r\nimport { About } from './about/About';\r\n\r\nenum notificationType {\r\n    Clients = 0,\r\n    Terminal = 1,\r\n    Messages = 2\r\n  }\r\n\r\nenum alertType {\r\n    Normal = 0,\r\n    Success = 1,\r\n    RequireAttention = 2,\r\n    Alert = 3,\r\n    Error = 4\r\n}\r\n\r\ntype Props = {\r\n    type: notificationType;\r\n    alert: alertType;\r\n    message: string;\r\n\r\n};\r\n\r\n\r\nconst JjodelName = () => {\r\nconst [animal, setAnimal] = useState(false);\r\n\r\n\r\n    return (<>\r\n        <div className={'jjodel'}>\r\n            <span><About ver={'1.6'} name={'manatee'} /></span>\r\n        </div>\r\n        </>);\r\n}\r\n\r\nfunction BottomBarComponent(props: AllProps): JSX.Element {\r\n    const [swenOpen, setSwen] = useState(false);\r\n    const {node,data} = props;\r\n    let nodepos: string | undefined;\r\n    if (node) {\r\n        let size = {...node.size};\r\n        if (size && typeof size === 'object'){\r\n            let ret = [\r\n                '', U.cropNum(+(+size.x||0).toFixed(2)),\r\n                ', ', U.cropNum(+(+size.y||0).toFixed(2)),\r\n                ', ', U.cropNum(+(+node.zIndex||0).toFixed(2)),\r\n                ' w:', U.cropNum(+(+size.w||0).toFixed(2)),\r\n                ' h:', U.cropNum(+(+size.h||0).toFixed(2)),\r\n            ]\r\n            nodepos = ret.join('');\r\n        }\r\n    }\r\n\r\n    return(<footer className={'footer'}>\r\n        <label className={'me-3'}>\r\n            Made with <i className=\"bi bi-heart-fill\" /> in the swen group\r\n        </label>\r\n        <div style={{width: '100px'}}></div>\r\n        <div className={'coordinates'} hidden={!node}>\r\n            {data?.name}&nbsp;\r\n            {nodepos}\r\n        </div>\r\n        {swenOpen && \r\n                <>\r\n                    <div className='modal-container'></div>\r\n                    <div className='swen'>\r\n                        <img src={swen} onClick={(e) => setSwen(false)} />\r\n                    </div>\r\n                </>\r\n        }\r\n        <JjodelName />\r\n\r\n    </footer>)\r\n}\r\n\r\ninterface OwnProps {}\r\ninterface StateProps {\r\n    node?: LGraphElement;\r\n    data?: LModelElement\r\n}\r\ninterface DispatchProps {}\r\ntype AllProps = OwnProps & StateProps & DispatchProps;\r\n\r\n\r\nfunction mapStateToProps(state: DState, ownProps: OwnProps): StateProps {\r\n    const ret: StateProps = {} as FakeStateProps;\r\n    const selected = state._lastSelected;\r\n    if(selected?.node) ret.node = LGraphElement.fromPointer(selected.node);\r\n    if(selected?.modelElement) ret.data = LModelElement.fromPointer(selected.modelElement);\r\n\r\n    return ret;\r\n}\r\n\r\nfunction mapDispatchToProps(dispatch: Dispatch<any>): DispatchProps {\r\n    const ret: DispatchProps = {};\r\n    return ret;\r\n}\r\n\r\nexport const BottomBarConnected = connect<StateProps, DispatchProps, OwnProps, DState>(\r\n    mapStateToProps,\r\n    mapDispatchToProps\r\n)(BottomBarComponent);\r\n\r\nconst BottomBar = (props: OwnProps, children: (string | React.Component)[] = []): ReactElement => {\r\n    return <BottomBarConnected {...{...props, children}} />;\r\n}\r\n\r\nexport {BottomBar};\r\n","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\pages\\components\\LeftBar.tsx",["1505","1506","1507","1508","1509","1510","1511","1512","1513","1514"],"import { meanBy } from 'lodash';\r\nimport { useState, MouseEventHandler } from 'react';\r\nimport { IconTheme } from 'react-hot-toast';\r\nimport {DProject, DUser, L, LProject, LUser, R, SetRootFieldAction, U, windoww} from '../../joiner';\r\n\r\nimport { icon } from './icons/Icons';\r\nimport {DashProps} from \"./Dashboard\";\r\nimport Collaborative from \"../../components/collaborative/Collaborative\";\r\nimport {ProjectsApi} from \"../../api/persistance\";\r\nimport storage from \"../../data/storage\";\r\nimport { isProjectModified } from '../../common/libraries/projectModified';\r\nimport { Tooltip } from '../../components/forEndUser/Tooltip';\r\nimport {SaveManager} from \"../../components/topbar/SaveManager\";\r\nimport {Link, useNavigate} from \"react-router-dom\";\r\n\r\ninterface StateProps {\r\n    projects: LProject[];\r\n}\r\n\r\n\r\nexport type LeftBarProps = {\r\n    user?: LUser;\r\n    active: DashProps['active']; // prende il tipo dal parent-component, così si evita di aggiornare entrambi o avere tipi discordanti.\r\n    projects?: LProject[];\r\n    project?: LProject;\r\n\r\n};\r\n\r\n\r\ntype ItemProps = {\r\n    children: string;\r\n    icon?: any;\r\n    action?: string | MouseEventHandler;\r\n    dot?: boolean;\r\n    onClick?: MouseEventHandler\r\n};\r\n\r\nconst Item = (props: ItemProps) => {\r\n    let action: (e:any)=>any = props.action as any;\r\n    let navigate = useNavigate();\r\n    if (typeof action === 'string') action = (e => R.navigate(`/${props.action}`, navigate));\r\n    let finalaction = (e:any) =>{ props.onClick?.(e); action(e); }\r\n/*\r\n    let url: string = '';\r\n    if (typeof props.action === 'string') url = props.action;*/\r\n    return (<>\r\n\r\n        {/*<Link to={url} className={'item ' + (props.dot ? 'red-dot' : '')}>{props.icon && props.icon}&nbsp;{props.children}</Link>*/}\r\n            <div onClick={finalaction} className={'item ' + (props.dot ? 'red-dot' : '')}>\r\n                {props.icon && props.icon}&nbsp;<span>{props.children}</span>\r\n            </div>\r\n    </>);\r\n}\r\n\r\nconst Upload = () => {\r\n    return(<></>);\r\n    return(\r\n        <div className={'upload'}>\r\n            <i className=\"bi bi-arrow-up-circle\"></i>\r\n            <p>Drop your jjodel project archive here to import it.</p>\r\n        </div>\r\n    );\r\n};\r\n\r\ntype MenuProps = {\r\n    children: any;\r\n    title?: string;\r\n    mode?: \"collapsable\";\r\n    project?: boolean;\r\n};\r\n\r\nconst Menu = (props: MenuProps) => {\r\n    const [open,setOpen] = useState(true);\r\n\r\n    return (<>\r\n\r\n        {props.title && props.mode && open && <i className={'bi bi-chevron-down'} onClick={(e) => setOpen(!open)}></i>}\r\n        {props.title && props.mode && !open && <i className={'bi bi-chevron-right'} onClick={(e) => setOpen(!open)}></i>}\r\n        \r\n\r\n        <div className='menu border-bottom'>\r\n            {isProjectModified() && props.title ? <h1>{props.title} <i className=\"bi bi-circle-fill modified\"></i> </h1> : <h1> {props.title} </h1>}\r\n            <div>\r\n                {open && props.children}\r\n            </div>\r\n        </div>\r\n    </>);\r\n}\r\n\r\nconst Divisor = () => {\r\n    return (<hr className='my-1' />);\r\n};\r\n\r\nMenu.Item = Item;\r\n\r\nfunction LeftBar(props: LeftBarProps): JSX.Element {\r\n\r\n    // export type LeftBarProps = {\r\n    //     active: DashProps['active']; // prende il tipo dal parent-component, così si evita di aggiornare entrambi o avere tipi discordanti.\r\n    //     projects: LProject[];\r\n    //     project?: LProject;\r\n\r\n    // };\r\n\r\n    const {active, project} = props;\r\n    let user: LUser = props.user || L.fromPointer(DUser.current);\r\n\r\n    const selectProject= (project: LProject) => {\r\n        R.navigate(`/project?id=${project.id}`, true);\r\n        U.resetState();\r\n    };\r\n\r\n    const closeProject = () => {\r\n        function doclose(){\r\n            R.navigate('/allProjects', true);\r\n            Collaborative.client.off('pullAction');\r\n            Collaborative.client.disconnect();\r\n            SetRootFieldAction.new('collaborativeSession', false);\r\n            U.resetState();\r\n        }\r\n        /*\r\n        if (isProjectModified()) {\r\n            U.dialog('Close the project without saving?', 'close project', ()=>{\r\n                doclose();\r\n            })\r\n        }\r\n        else doclose();*/\r\n        doclose();\r\n    }\r\n    const toggleFavorite = async() => {\r\n        await ProjectsApi.favorite(project?.__raw as DProject);\r\n    };\r\n    const exportProject = async() => {\r\n        if(project) {\r\n            await ProjectsApi.save(project);\r\n            U.download(`${project?.name}.jjodel`, JSON.stringify(project?.__raw));\r\n        }\r\n    }\r\n\r\n    \r\n\r\n    return(<>\r\n\r\n        {active === 'Project' ?\r\n            <div className={'leftbar border-end border-light-subtle '}>\r\n\r\n                <i className=\"bi bi-search\"></i>\r\n                <input placeholder={'Search for anything'} type={'text'} name='search-text' />\r\n                {/* @ts-ignore */}\r\n                <Menu title={props.project.name ? props.project.name : 'Unnamed Project'} project>\r\n                    {/*<Item icon={icon['edit']}>Edit </Item>*/}\r\n                    <Item action={exportProject} icon={icon['download']}>Download</Item>\r\n                    {/*<Item icon={icon['duplicate']}>Duplicate </Item>*/}\r\n                    <Item action={toggleFavorite} icon={!project?.isFavorite ? icon['favorite'] : icon['favoriteFill']}>{!project?.isFavorite ? 'Add to favorites ' : 'Remove from favorites '}</Item>\r\n                    {/*<Item icon={icon['share']}>Public link </Item>*/}\r\n                    {/*<Item icon={icon['delete']}>Delete </Item>*/}\r\n                    <Item action={closeProject} icon={icon['close']}>Close project </Item>\r\n                </Menu>\r\n\r\n                {/* {props.projects.filter(p => p.favorite).length > 0 &&\r\n                    <Menu title={\"Starred\"} mode={'collapsable'}>\r\n                        {props.projects.filter(p => p.favorite).map(p => <Item icon={icon['folder']} action={e => selectProject()}>{p.name}</Item>)}\r\n                    </Menu>\r\n                } *//*}\r\n\r\n                { <Menu>\r\n                    <Item action={'templates'} icon={icon['template2']}>Templates</Item>\r\n                    <Item action={'notes'} icon={icon['edit']}>Notes</Item>\r\n                </Menu>}\r\n\r\n                <Menu title={'Support'} mode={'collapsable'}>\r\n                    <Item icon={icon['whats-new']}>What's newwew</Item>\r\n                    <Item icon={icon['getting-started']}>Getting started</Item>\r\n                    <Item icon={icon['manual']}>User guide</Item>\r\n                </Menu>*/\r\n                }\r\n\r\n            </div>\r\n            :\r\n            <div className={'leftbar border-end border-light-subtle '}>\r\n\r\n                <i className=\"bi bi-search\"></i>\r\n                <input placeholder={'Search for anything'} type={'text'} name='search-text' />\r\n\r\n\r\n                {user && user.email === 'admin@gmail.it' && <Menu title={'Administration'} mode={'collapsable'}>\r\n                    <Item action={'usersInfo'} icon={icon['profile']}>Users</Item>\r\n                    <Item action={'projectsInfo'} icon={icon['folder']}>Projects</Item>\r\n                    <Item action={'news'} icon={icon['manual']}>News</Item>\r\n                </Menu>}\r\n\r\n                <Menu>\r\n                    <Item action={'allProjects'} icon={icon['dashboard']}>All projects </Item>\r\n                </Menu>\r\n                {props.projects && props.projects.filter(p => p.isFavorite).length > 0 &&\r\n                    <Menu title={\"Starred\"} mode={'collapsable'}>\r\n                        {props.projects\r\n                            .filter(p => p.isFavorite)\r\n                            .map(p => \r\n                                <Item icon={icon['folder']} action={e => selectProject(p)}>{p.name}</Item>\r\n                            )\r\n                        }\r\n                    </Menu>\r\n                }\r\n\r\n                {props.projects && props.projects.filter(p => p.isFavorite).length > 0 &&\r\n                    <Menu title={\"Recent\"} mode={'collapsable'}>\r\n                        {props.projects\r\n                            .sort((a,b) => (b.lastModified > a.lastModified) ?  1 : -1)\r\n                            .slice(0,5)\r\n                            .map(p => <Item icon={icon['folder']} action={e => selectProject(p)}>{p.name}</Item>)}\r\n                    </Menu>\r\n                }\r\n                \r\n                <Menu title={'Support'} mode={'collapsable'}>\r\n                    {/* <Item action={'updates'} icon={icon['whats-new']}\r\n                          dot={+(localStorage.getItem('_jj_update_seen')||0)<+(localStorage.getItem('_jj_update_date')||Number.POSITIVE_INFINITY)}\r\n                          onClick={()=>localStorage.setItem('_jj_update_seen', ''+Date.now())}\r\n                    >What's new</Item>*/}\r\n                    <Item \r\n                        action={() => {R.navigate(\"https://www.jjodel.io/whats-new/\")}}\r\n                        icon={icon['whats-new']}\r\n                    >What's new</Item>\r\n                    <Item \r\n                        action={() => {R.navigate(\"https://www.jjodel.io/getting-started/\")}}\r\n                        icon={icon['getting-started']}\r\n                    >Getting started</Item>\r\n                    <Item \r\n                        action={() => {R.navigate(\"https://www.jjodel.io/manual/\")}}\r\n                        icon={icon['manual']}\r\n                    >User guide</Item>\r\n                </Menu>\r\n\r\n                <Upload />\r\n\r\n            </div>\r\n        }\r\n\r\n    </>)\r\n}\r\n\r\nexport {LeftBar};\r\n","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\pages\\components\\Project.tsx",["1515","1516","1517","1518","1519","1520","1521","1522"],"C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\pages\\components\\Dashboard.tsx",["1523","1524","1525","1526","1527","1528","1529","1530","1531","1532","1533","1534"],"import {\r\n    Dictionary, DProject,\r\n    DState,\r\n    DUser,\r\n    DViewElement,\r\n    Input,\r\n    LPointerTargetable,\r\n    LProject,\r\n    LUser,\r\n    LViewElement,\r\n    LViewPoint,\r\n    Pointer,\r\n    SetFieldAction,\r\n    SetRootFieldAction,\r\n    U,\r\n    Try, TRANSACTION, L\r\n} from '../../joiner';\r\nimport {LeftBar, Navbar} from './';\r\n\r\nimport '../dashboard.scss'\r\nimport {ReactElement, useRef} from \"react\";\r\nimport {Btn, CommandBar, Sep} from '../../components/commandbar/CommandBar';\r\n\r\nimport colors from '../../static/img/colors.png';\r\nimport useQuery from '../../hooks/useQuery';\r\n\r\nimport {\r\n    TbSquareRoundedLetterM,\r\n    TbSquareRoundedLetterMFilled,\r\n    TbSquareRoundedLetterV,\r\n    TbSquareRoundedLetterVFilled,\r\n    TbSquareRoundedLetterE\r\n} from \"react-icons/tb\";\r\nimport DockManager from '../../components/abstract/DockManager';\r\nimport Dock from \"../../components/abstract/Dock\";\r\nimport {CSS_Units} from \"../../view/viewElement/view\";\r\nimport {useStateIfMounted} from 'use-state-if-mounted';\r\nimport { Tooltip } from '../../components/forEndUser/Tooltip';\r\nimport { ProjectsApi } from '../../api/persistance';\r\n\r\n\r\ntype UserProps = {\r\n    name: string;\r\n    initials: string;\r\n};\r\n\r\nconst User = (props: UserProps) => {\r\n    return (<>\r\n        <div className={'user'}>\r\n            <div className={'initials'}>{props.initials}</div>\r\n            <div className={'name'}><h2>{props.name}'s projects</h2></div>\r\n        </div>\r\n    </>);\r\n};\r\n\r\ntype TitleProps = {\r\n    projectID?: Pointer<DProject>;\r\n    active: string;\r\n    title: string;\r\n    icon: ReactElement;\r\n    description?: string;\r\n    type?: 'private'|'public'|'collaborative';\r\n}\r\n\r\n\r\nconst Title = (props: TitleProps) => {\r\n\r\n    let [title, setTitle] = useStateIfMounted(props.title);\r\n    let [description, setDescription] = useStateIfMounted(props.description);\r\n\r\n\r\n    const [editTitle, setEditTitle] = useStateIfMounted(false);\r\n    const [editDes, setEditDes] = useStateIfMounted(false);\r\n    //if (!editTitle && title !== props.title) setTitle(props.title);\r\n    //if (!editDes && description !== props.description) setDescription(props.description);\r\n\r\n    const titleRef = useRef();\r\n    const desRef = useRef();\r\n\r\n    const ProjectProperties = () => {\r\n\r\n        const server = 'http://app.jjodel.io';\r\n        const projectLink = '/#/project?id='+props.projectID;\r\n\r\n        function copyToClipboard(e: any) {\r\n            //const server = document.getElementById('server');\r\n            //const link = document.getElementById('link');\r\n            let full_link = server + projectLink;\r\n            console.log('copy to clipboard');\r\n            U.clipboardCopy(full_link, ()=>U.alert('i', \"Copied\", \"The project link has been copied to the Clipboard.\"));\r\n        }\r\n\r\n        let type = (props.type === \"public\");\r\n            return (<><label className='text-end nav-commands d-flex' \r\n                        style={{float: `${props.type === 'public' ? 'left': 'none'}`}}>\r\n                {props.type && <>\r\n                    <span className={\"my-auto me-1\"}>{props.type === \"public\" ? \"public\" : props.type === \"private\" ? \"private\" : \"collaborative\"}</span>\r\n                    \r\n                    {props.type !== \"collaborative\" && \r\n                        <Input type=\"toggle\"\r\n                            className={\"my-auto\"}\r\n                            style={{fontSize:'1.25em'}}\r\n                            setter={(v) => {\r\n                                if (!props.projectID) return;\r\n                                let project: LProject = L.fromPointer(props.projectID);\r\n                                project.type = v ? \"public\" : \"private\";\r\n                                if (v) U.alert('i', \"The project \"+title+\" is public\", \"It can be accessed only by those who have the public link.\");\r\n                            }}\r\n                            getter={() => type}\r\n                        />    \r\n                    }\r\n                </>\r\n                }\r\n            </label>\r\n            {props.type === \"public\" &&\r\n                <Tooltip tooltip={'Copy to Clipboard'} inline={true} position={'top'} offsetY={10}>\r\n                    <span onClick={(e) => copyToClipboard(e)}className={'project-link'}>\r\n                        <span id={'server'}>{server}</span><span id={'link'}>{projectLink}</span>\r\n                    </span>\r\n                </Tooltip>\r\n            }\r\n            </>\r\n            );\r\n        };\r\n\r\n        // <h2 onBlur={() => setEditTitle(!editTitle)} >\r\n\r\n        // function setTitle(e: any) {\r\n        //     if (title === '') {\r\n        //         U.alert('e', 'Title cannot be empty', 'Please enter a title for the project.');\r\n        //         e.target.focus();\r\n        //         return;\r\n        //     }\r\n        //     setProjectModified();\r\n        //     setEditTitle(!editTitle);\r\n        // }\r\n\r\n        // function setDescription(e: any) {\r\n\r\n        //     if (description === '') {\r\n        //         U.alert('e', 'Description cannot be empty', 'Please enter a description for the project.');\r\n        //         e.target.focus();\r\n        //         return;\r\n        //     }\r\n        //     setProjectModified();\r\n        //     setEditDes(!editDes);\r\n        // }\r\n\r\n        // function setPrivacy(e: any) {\r\n        //     setProjectModified();\r\n        // }\r\n\r\n\r\n\r\n    return (<>\r\n        <div className={'title'}>\r\n            {props.active === 'Project' ?\r\n                <div className={'project-list'}> {/* name */}\r\n                    {editTitle ?\r\n                        <h2>\r\n                            <div>\r\n                                {props.icon}\r\n                                <input\r\n                                    autoFocus\r\n                                    type={'text'}\r\n                                    value={title}\r\n                                    onChange={(e)=>setTitle(e.target.value)}\r\n                                    style={{padding: '0px', margin: '0'}}\r\n                                    onBlur={(e) => {\r\n                                        if (!props.projectID) return;\r\n                                        if (!e.target.value) {\r\n                                            U.alert('e', 'A Project Name is required.', 'Please provide a name to identify and organize your project effectively.');\r\n                                            e.target.focus();\r\n                                            return;\r\n                                        }\r\n                                        let project: LProject = L.fromPointer(props.projectID);\r\n                                        project.name = e.target.value;\r\n                                        setEditTitle(false);\r\n                                    }}\r\n                                />\r\n                            </div>\r\n                        </h2> :\r\n                        <>\r\n                        <Tooltip tooltip={'DoubleClick to edit'} inline={true} position={'left'} offsetX={10}>\r\n                            <h2 onDoubleClick={() => {setEditTitle(true)}}>\r\n                            {props.icon} {props.title}\r\n                        </h2></Tooltip>\r\n                         </>\r\n                    }\r\n                    <h6><ProjectProperties/></h6>\r\n                    \r\n                    {editDes ? \r\n                        <h3>\r\n                            <textarea\r\n                                autoFocus\r\n                                rows={4}\r\n                                cols={80}\r\n                                value={description}\r\n                                onChange={(e)=> {\r\n                                    console.log('onchange', {e, tv:e.target.value, pv:props.description, sv:description})\r\n                                    setDescription(e.target.value)\r\n                                }}\r\n                                onInput={(e)=> {\r\n                                    console.log('onInput', {e, tv:e.target, pv:props.description, sv:description})\r\n                                }}\r\n                                onBlur={e => {\r\n                                    if (!props.projectID) return;\r\n                                    if (!e.target.value) {\r\n                                        e.target.focus();\r\n                                        U.alert('e', 'A Project Description is required.', 'Adding a description helps provide clarity and context for your project.');\r\n                                        return;}\r\n                                    let project: LProject = L.fromPointer(props.projectID);\r\n                                    project.description = e.target.value;\r\n                                    setEditDes(false);\r\n                                }}\r\n                            />\r\n                        </h3>\r\n                        :\r\n                        <>\r\n                            {props.description && <Tooltip tooltip={'DoubleClick to edit'} inline={true} position={'left'} offsetX={10}>\r\n                                <h3 onDoubleClick={() => setEditDes(!editDes)}>{props.description}</h3>\r\n                            </Tooltip>}\r\n                        </>\r\n                    }\r\n                    \r\n                </div>\r\n                :\r\n                <div className={'header'}>\r\n                    <h2>{props.icon} {props.title}</h2>\r\n                    {props.description && <h3>{props.description}</h3>}\r\n                </div>\r\n            }\r\n        </div>\r\n    </>);\r\n};\r\n\r\n\r\nexport type DashProps = {\r\n    children?: JSX.Element,\r\n    className?: string;\r\n    // NB: account and profile are both used, i don't know which to keep\r\n    active: 'Account'|'Profile'|'Settings'|'Updates'|'Community'|'All'|'Archive'|'Templates'|'Recent' | 'Notes' | 'Project' | 'UsersInfo' | 'ProjectsInfo' | 'News';\r\n    version?: Partial<DState[\"version\"]>;\r\n    project?: LProject;\r\n    projects?:LProject[];\r\n    style?: any;\r\n};\r\n\r\n\r\ntype CatalogProps = {\r\n    children: any;\r\n}\r\n\r\nconst Catalog = (props: CatalogProps) => {\r\n\r\n    return props.children;\r\n};\r\n\r\ntype ProjectDashboardProps = {\r\n    children?: JSX.Element,\r\n    // NB: account and profile are both used, i don't know which to keep\r\n    active: 'Account'|'Profile'|'Settings'|'Updates'|'Community'|'All'|'Archive'|'Templates'|'Recent' | 'Notes' | 'Project';\r\n    version: Partial<DState[\"version\"]>;\r\n    project?: LProject;\r\n}\r\n\r\nfunction GenericDashboard(props: DashProps): any {\r\n    const {children, active} = props;\r\n    const user: LUser = LPointerTargetable.fromPointer(DUser.current);\r\n\r\n    return (<>\r\n        <Navbar />\r\n        <div className={\"dashboard-container\"} tabIndex={-1}>\r\n            <LeftBar active={active} projects={user?.projects}/>\r\n            <div className={`dash-content user ${props.style && props.style}`}>\r\n                <div>\r\n                    <>\r\n                        {active === \"All\" && <Title active={active} title={'Dashboard'} icon={<i className=\"bi bi-columns-gap\"></i>} />}\r\n                        {active === \"Recent\" && <Title  active={active} title={'Recent'} icon={<i className=\"bi bi-clock\"></i>} />}\r\n                        {active === \"Templates\" && <Title  active={active} title={'Templates'} icon={<i className=\"bi bi-lightbulb\"></i>} />}\r\n                        {active === \"Notes\" && <Title  active={active} title={'Project Notes'} icon={<i className=\"bi bi-pencil-square\"></i>} />}\r\n                        {active === \"Updates\" && <Title  active={active} title={'What\\'s new'} icon={<i className=\"bi bi-clock-history\"></i>} />}\r\n                        {active === \"Profile\" && <Title  active={active} title={'Profile'} icon={<i className=\"bi bi-clock-history\"></i>} />}\r\n                    </>\r\n                </div>\r\n                <Catalog children={children}/>\r\n            </div>\r\n        </div>\r\n    </>);\r\n}\r\n\r\ntype ProjectProps = {\r\n    project: LProject;\r\n}\r\n\r\nconst ProjectInfoCard = (props: ProjectProps) => {\r\n\r\n    const {project} = props;\r\n\r\n    /* to be refined */\r\n\r\n    return (\r\n        <div className={'details'}>\r\n            <>\r\n                <h5>{project.name ? project.name : 'Unnamed Project'}</h5>\r\n                {project.description && <p>{project.description}</p>}\r\n                <img src={colors} width={220} style={{paddingBottom: '10px'}}/>\r\n\r\n                {project.metamodels.length === 0 ?\r\n                    <p>This project does not contain any metamodel and consequently no models yet; it only contains the default viewpoints.</p>\r\n                    :\r\n                    <p>\r\n                    {project.metamodels.length === 1 && <>In this project, <b>one metamodel</b> is defined</>}\r\n                    {project.metamodels.length > 1 && <>In this project, <b>{project.metamodels.length} metamodels</b> are defined </>}\r\n                    {project.models.length === 0  ?\r\n                        <> and does not contain any model (it only includes the default viewpoints).</>\r\n                        :\r\n                        <>\r\n                        {project.models.length === 1  && <>, from which <b>one model</b> is instantiated. </>}\r\n                        {project.models.length > 1  && <>, from which <b>{project.models.length}</b> models are instantiated. </>}\r\n\r\n                        <>These models are explored and analyzed through <b>{project.viewpoints.length} viewpoints</b> (including the default ones), each offering a distinct perspective on different system concerns. </>\r\n                        </>\r\n                    }\r\n\r\n\r\n                    </p>\r\n                }\r\n            </>\r\n        </div>\r\n    );\r\n}\r\n\r\n/* Project Details / Project Summary */\r\n\r\nfunction ProjectCatalog(props: ProjectProps) {\r\n\r\n    const {project} = props;\r\n\r\n    return (<>\r\n        <ProjectInfoCard project={project}/>\r\n        <div className={'row project-list'}  >\r\n            \r\n            <div className='row header' >\r\n                <div className={'col-4 '}>Name</div>\r\n                <div className={'col-2 artifact-type'}>Type</div>\r\n                <div className={'col-1'}>Operation</div>\r\n            </div>\r\n\r\n            {project.metamodels.map(mm =>\r\n                <div className=\"row data\">\r\n                    <div className={'col-4 '} onClick={async () => await DockManager.open2(mm)}>\r\n                        <TbSquareRoundedLetterMFilled style={{fontSize: '1.5em'}}/> {mm.name}</div>\r\n                    <div className={'col-2 artifact-type'}>Metamodel</div>\r\n                    <div className={'buttons'}>\r\n                        <CommandBar noBorder={true} style={{marginBottom: '0'}}>\r\n                            <Btn icon={'open'} action={async () => await DockManager.open2(mm)}\r\n                                    tip={'Open metamodel'}/>\r\n                            <Btn icon={'minispace'}/>\r\n                            <Btn icon={'copy'} action={e => {\r\n                            }} tip={'Duplicate metamodel'}/>\r\n                            <Sep/>\r\n                            <Btn icon={'delete'} action={e => mm.delete()} tip={`Delete model \"${mm.name}\"`}/>\r\n                        </CommandBar>\r\n                    </div>\r\n                </div>)\r\n            }\r\n            {project.models.map(model =>\r\n                <div className=\"row data\">\r\n                    <div className={'col-4 '} key={model.id} onClick={async () => await DockManager.open2(model)}>\r\n                        <TbSquareRoundedLetterM style={{fontSize: '1.5em'}}/> {model.name}</div>\r\n                    <div className={'col-2 artifact-type'}>Model</div>\r\n                    <div className={'buttons'}>\r\n                        <CommandBar noBorder={true} style={{marginBottom: '0'}}>\r\n                            <Btn icon={'open'} action={async () => await DockManager.open2(model)}\r\n                                    tip={'Open model'}/>\r\n                            <Btn icon={'minispace'}/>\r\n                            <Btn icon={'copy'} action={e => {\r\n                            }} tip={'Duplicate model'}/>\r\n                            <Sep/>\r\n                            <Btn icon={'delete'} action={e => model.delete()} tip={`Delete model \"${model.name}\"`}/>\r\n                        </CommandBar>\r\n                    </div>\r\n                </div>)\r\n            }\r\n            {project.viewpoints.map(vp => !vp ? <div>errorvp: {vp+''}</div> :\r\n                <div className=\"row data viewpoint\">\r\n                    <div className={'col-4'}>{vp.isOverlay ? <TbSquareRoundedLetterVFilled style={{fontSize: '1.5em'}}/> : <TbSquareRoundedLetterV style={{fontSize: '1.5em'}}/>} {vp.name}</div>\r\n                    <div className={'col-2 artifact-type'}>Viewpoint</div>\r\n                    <div className={'buttons'}>\r\n                        <CommandBar noBorder={true} style={{marginBottom: '0'}}>\r\n                            <Btn icon={'open'} tip={'Open viewpoint'} disabled={true}/>\r\n                            <Btn icon={'minispace'} />\r\n                            <Btn icon={'copy'} action={e => vp.duplicate()} tip={'Duplicate viewpoint'}/>\r\n                            <Sep />\r\n                            <Btn icon={'delete'} action={e => vp.delete()} tip={'Delete viewpoint'} disabled={vp.name === 'Default' || vp.name === 'Validation default'}/>\r\n                        </CommandBar>\r\n                    </div>\r\n                </div>)\r\n            }\r\n            <div className={'legenda'}>\r\n                <h1>Legenda</h1>\r\n                <div className={'row'}>\r\n                    <div className={'col'}>\r\n                        <TbSquareRoundedLetterMFilled style={{fontSize: '1.3em'}}/> Metamodels\r\n                    </div>\r\n                    <div className={'col'}>\r\n                        <TbSquareRoundedLetterM style={{fontSize: '1.3em'}}/> Models\r\n                    </div>\r\n                    <div className={'col'}>\r\n                        <TbSquareRoundedLetterVFilled style={{fontSize: '1.3em'}}/> Viewpoints\r\n                    </div>\r\n                    <div className={'col'}>\r\n                        <TbSquareRoundedLetterV style={{fontSize: '1.3em'}}/> Overlay Viewpoints\r\n                    </div>\r\n                    <div className={'col disabled'}>\r\n                        <TbSquareRoundedLetterE className={'disabled'} style={{fontSize: '1.3em'}}/> Epsilon Transformations\r\n                    </div>\r\n                </div>\r\n            </div>\r\n        </div>\r\n    </>)}\r\n\r\n\r\nfunction ProjectDashboard(props: DashProps): any {\r\n\r\n    const {children, active} = props;\r\n    const user: LUser = LPointerTargetable.fromPointer(DUser.current);\r\n    const query = useQuery();\r\n    const id = query.get('id') || '';\r\n    const project: LProject = LProject.fromPointer(id);\r\n\r\n    let vparr = project?.viewpoints || [];\r\n    let allViews = vparr.flatMap((vp: LViewPoint) => vp && vp.allSubViews);\r\n    allViews.push(...vparr as LViewElement[]);\r\n    allViews = allViews.filter(v => v);\r\n    const viewsDeDuplicator: Dictionary<Pointer<DViewElement>, LViewElement> = {};\r\n    for (let v of allViews) viewsDeDuplicator[v.id] = v;\r\n\r\n    return (<>\r\n        <Try>\r\n            <>\r\n                <style id={\"views-css-injector-d\"}>\r\n                    {Object.values(viewsDeDuplicator).map(v => v.compiled_css).join('\\n\\n')}\r\n                </style>\r\n                {CSS_Units.jsx}\r\n            </>\r\n        </Try>\r\n        <Navbar />\r\n        <Try><Dock /></Try>\r\n    </>);\r\n}\r\n\r\nfunction Dashboard(props: DashProps): any {\r\n\r\n    return props.active === 'Project' ?\r\n            <ProjectDashboard {...props} className={(props.className||'') + ' bg'} /> :\r\n            <GenericDashboard {...props} />\r\n}\r\n\r\nexport {Dashboard, ProjectCatalog, Title};\r\n\r\n\r\n\r\n","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\pages\\components\\Navbar.tsx",["1535","1536","1537","1538","1539","1540","1541","1542","1543","1544","1545","1546","1547"],"import './style.scss';\r\nimport './navbar.scss';\r\nimport {\r\n    Dictionary,\r\n    DModel,\r\n    DProject,\r\n    DState,\r\n    DUser,\r\n    Input,\r\n    Keystrokes,\r\n    L,\r\n    LGraph,\r\n    LModel,\r\n    LPackage,\r\n    LProject,\r\n    LUser,\r\n    Selectors,\r\n    SetRootFieldAction,\r\n    TRANSACTION,\r\n    store,\r\n    U,\r\n    R\r\n} from '../../joiner';\r\n\r\nimport {icon} from '../components/icons/Icons';\r\n\r\nimport {useNavigate} from 'react-router-dom';\r\n\r\nimport React, {Component, Dispatch, ReactElement, useState} from 'react';\r\nimport {FakeStateProps} from '../../joiner/types';\r\nimport {connect} from 'react-redux';\r\nimport {MetamodelPopup, ModelPopup} from './popups';\r\nimport {AuthApi, ProjectsApi} from '../../api/persistance';\r\nimport TabDataMaker from \"../../../src/components/abstract/tabs/TabDataMaker\";\r\nimport DockManager from \"../../../src/components/abstract/DockManager\";\r\n\r\nimport {Divisor, Item, Menu} from '../components/menu/Menu';\r\n\r\nimport Collaborative from \"../../components/collaborative/Collaborative\";\r\nimport { isProjectModified } from '../../common/libraries/projectModified';\r\nimport { AboutModal } from './about/About';\r\nimport { MetricsPanelManager } from '../../components/metrics/Metrics';\r\n\r\nimport {Undoredocomponent} from \"../../components/topbar/undoredocomponent\";\r\n\r\n\r\nlet windoww = window as any;\r\n\r\nfunction createM2(project: LProject) {\r\n    let name = 'metamodel_' + 1;\r\n    let names: string[] = Selectors.getAllMetamodels().map(m => m.name);\r\n    name = U.increaseEndingNumber(name, false, false, newName => names.indexOf(newName) >= 0);\r\n    const dModel = DModel.new(name, undefined, true);\r\n    const lModel: LModel = LModel.fromD(dModel);\r\n    project.metamodels = [...project.metamodels, lModel];\r\n    project.graphs = [...project.graphs, lModel.node as LGraph];\r\n    const dPackage = lModel.addChild('package');\r\n    const lPackage: LPackage = LPackage.fromD(dPackage);\r\n    lPackage.name = 'default';\r\n    const tab = TabDataMaker.metamodel(dModel);\r\n    DockManager.open('models', tab);\r\n}\r\n\r\nconst createM1 = (project: LProject, metamodel: LModel) => {\r\n    let name = 'model_' + 1;\r\n    let modelNames: (string)[] = metamodel.models.map(m => m.name);\r\n    name = U.increaseEndingNumber(name, false, false, newName => modelNames.indexOf(newName) >= 0);\r\n    const dModel: DModel = DModel.new(name, metamodel.id, false, true);\r\n    const lModel: LModel = LModel.fromD(dModel);\r\n    project.models = [...project.models, lModel];\r\n    project.graphs = [...project.graphs, lModel.node as LGraph];\r\n    const tab = TabDataMaker.model(dModel);\r\n    DockManager.open('models', tab);\r\n}\r\nfunction getKeyStrokes(keys?: string[]){\r\n    if (!keys || !keys.length) return undefined;\r\n    return <div className={\"keystrokes\"}>\r\n        {keys.map(k => Keystrokes.getKeystrokeJsx(k))}\r\n    </div>\r\n}\r\n\r\nlet globalProject: LProject|undefined = undefined as any;\r\nfunction makeEntry(i: MenuEntry, index: number) {\r\n    if (!i) return;\r\n    let isUndo = (i.name === \"Undo\" || i.name === \"Redo\");\r\n    // if (true as any) return <li >{i.name}</li>;\r\n\r\n    if (i.name === \"Redo\") { return null; }\r\n    if (i.name === \"Undo\") {\r\n        if (!globalProject) return null;\r\n        return <Undoredocomponent key={'undo'} project={globalProject} />\r\n    }\r\n    if (i.name === \"divisor\") {\r\n        return (\r\n            <li key={index} className='divisor'>\r\n                <hr />\r\n            </li>\r\n        );\r\n    } else {\r\n        if (i.subItems && i.subItems.length === 0) return undefined;\r\n        let slength = i.subItems ? i.subItems.length : 0;\r\n\r\n        let hasSubItems = (!i.disabled && slength > 0) || isUndo;\r\n\r\n        return (\r\n            <li className={hasSubItems ? \"hoverable\" : \"\"} key={i.name} tabIndex={0} onClick={()=>i.function?.()}>\r\n                <label className={`highlight ${i.disabled ? 'disabled' : ''}`}>\r\n                    <span>{i.icon || <i className=\"bi bi-app hidden\"/>} <span>{i.name}</span></span>\r\n                    {!i.disabled && slength > 0 ?\r\n                        <i className='bi bi-chevron-right icon-expand-submenu'/> :\r\n                        getKeyStrokes(i.keystroke)\r\n                    }\r\n                </label>\r\n            {hasSubItems &&\r\n                <div className='content right'>\r\n                    <ul className='context-menu right'>\r\n                        {i.subItems && i.subItems.map((si, index) => makeEntry(si, index))}\r\n                    </ul>\r\n                </div>\r\n            }\r\n            </li>\r\n        );\r\n    }\r\n}\r\n\r\n\r\n\r\ntype UserProps = {}\r\nconst User = (props: UserProps) => {\r\n    const user: LUser = LUser.fromPointer(DUser.current);\r\n    const name = `${user?.name} ${user?.surname}`;\r\n    const initials = name.split(' ').map(n=>n[0]).join('');\r\n    return (<div className={'user text-end'}>\r\n        <div className={'initials'}>\r\n            {initials.toUpperCase()}\r\n        </div>\r\n        &nbsp;&nbsp;\r\n        <span>{name}</span>\r\n    </div>);\r\n};\r\n\r\ntype MenuEntry = {\r\n    name: string,\r\n    icon?: any,\r\n    function?: ()=>any,\r\n    keystroke?: string[],\r\n    subItems?:MenuEntry[],\r\n    disabled?: boolean;\r\n} | null;\r\n\r\nfunction NavbarComponent(props: AllProps) {\r\n    const {version, metamodels, advanced, debug, project} = props;\r\n    const [focussed, setFocussed] = useState('');\r\n    const [clicked, setClicked] = useState('');\r\n    const navigate = useNavigate();\r\n    globalProject = project;\r\n\r\n    const open = (url: string) => { window.open(url, '_blank'); }\r\n\r\n    const Key = Keystrokes;\r\n    let projectItems2: MenuEntry[] = [];\r\n\r\n    if (project){\r\n        projectItems2 = [\r\n\r\n            /* New Metamodel */\r\n\r\n            {name: 'New metamodel', icon: icon['new'], function: () => createM2(project), keystroke: [Key.alt, Key.cmd, 'M']},\r\n\r\n            /* New Model */\r\n            {\r\n                name: 'New model',\r\n                icon: icon['new'],\r\n                subItems: project.metamodels.filter(m2=>!!m2).map((m2, i)=>({\r\n                    name: m2.name, function: () => createM1(project, m2), keystroke: []\r\n                })),\r\n                disabled: project.metamodels.length == 0\r\n            },\r\n\r\n            /* ----- */\r\n\r\n            {name: 'divisor', function: () => {}, keystroke: []},\r\n\r\n            /* Close */\r\n\r\n            {name: 'Close', icon: icon['close'], function: () => {\r\n                if (isProjectModified()) {\r\n                    U.dialog('Close the project without saving?', 'close project', ()=>{\r\n                        R.navigate('/allProjects');\r\n                        Collaborative.client.off('pullAction');\r\n                        Collaborative.client.disconnect();\r\n                        SetRootFieldAction.new('collaborativeSession', false);\r\n                        U.resetState();\r\n                    });\r\n                } else {\r\n                    R.navigate('/allProjects');\r\n                    Collaborative.client.off('pullAction');\r\n                    Collaborative.client.disconnect();\r\n                    SetRootFieldAction.new('collaborativeSession', false);\r\n                    U.resetState();\r\n                }\r\n            }, keystroke: [Key.cmd, 'W']},\r\n\r\n            /* ----- */\r\n\r\n            {name: 'divisor', function: () => {}, keystroke: []},\r\n\r\n            /* Save & Close */\r\n\r\n            {name: 'Save & Close', icon: icon['close'], function: async () => {\r\n                if (isProjectModified()) {\r\n                    await ProjectsApi.save(project);\r\n                }\r\n\r\n                R.navigate('/allProjects');\r\n                Collaborative.client.off('pullAction');\r\n                Collaborative.client.disconnect();\r\n                SetRootFieldAction.new('collaborativeSession', false);\r\n                U.resetState();\r\n            }, keystroke: []},\r\n\r\n            /* Save */\r\n\r\n            {name: 'Save', icon: icon['save'], function: async() => {\r\n                await ProjectsApi.save(project);\r\n            }, keystroke: [Key.cmd, 'S']},\r\n\r\n\r\n\r\n            /* Download */\r\n\r\n            {name: 'Download', icon: icon['download'], function: async() => {\r\n                await ProjectsApi.save(project);\r\n                U.download(`${project.name}.jjodel`, JSON.stringify(project.__raw));\r\n            }, keystroke: []},\r\n\r\n\r\n\r\n            /* ----- */\r\n\r\n            {name: 'divisor', function: () => {}, keystroke: []},\r\n\r\n            /* Help */\r\n\r\n            {name: 'Help', icon: icon['help'], subItems: [\r\n                {name: 'What\\'s new', icon: icon['whats-new'], function: async() => {R.navigate(\"https://www.jjodel.io/whats-new/\")}, keystroke: []},\r\n                {name: 'divisor', function: async() => {}, keystroke: []},\r\n                {name: 'Homepage', icon: icon['home'], function: async() => {R.navigate(\"https://www.jjodel.io/\")}, keystroke: []},\r\n                {name: 'Getting started', icon: icon['getting-started'], function: async() => {R.navigate(\"https://www.jjodel.io/getting-started/\")}, keystroke: []},\r\n                {name: 'User guide', icon: icon['manual'], function: async() => {R.navigate(\"https://www.jjodel.io/manual/\")}, keystroke: []},\r\n                {name: 'divisor', function: async() => {}, keystroke: []},\r\n                {name: 'Legal terms', icon: icon['legal'], function: async() => {R.navigate(\"https://www.jjodel.io/terms-conditions-page/\")}, keystroke: []}\r\n            ],\r\n            keystroke: []}\r\n        ];\r\n    }\r\n\r\n    const dashboardItems2: MenuEntry[] = [\r\n\r\n        {name: 'New project', icon: <i className=\"bi bi-plus-square\"></i>, function:\r\n            async()=>{\r\n                R.navigate('/allProjects');\r\n                await ProjectsApi.create('public', undefined, undefined, undefined, props.user?.projects);\r\n                /*\r\n                SetRootFieldAction.new('isLoading', true);\r\n                await U.sleep(1);\r\n                await ProjectsApi.create('public', 'Unnamed Project');\r\n                SetRootFieldAction.new('isLoading', false);*/\r\n            },\r\n            keystroke: [Key.cmd, 'M']},\r\n            {name: 'divisor', function: () => {}, keystroke: []},\r\n\r\n        {name: 'Import...', icon: <i className=\"bi bi-arrow-bar-left\"></i>, function: ProjectsApi.import, keystroke: []},\r\n        {name: 'divisor', function: () => {}, keystroke: []},\r\n        {name: 'Help', icon: <i className=\"bi bi-question-square\"></i>, subItems: [\r\n            {name: 'What\\'s new', icon: <i className=\"bi bi-clock\"></i>, function: () => {R.navigate(\"https://www.jjodel.io/whats-new/\", navigate)}, keystroke: []},\r\n            {name: 'divisor', function: () => {}, keystroke: []},\r\n            {name: 'Homepage', icon: <i className=\"bi bi-house\"></i>, function: () => {R.navigate(\"https://www.jjodel.io/\", navigate)}, keystroke: []},\r\n            {name: 'Getting started', icon: <i className=\"bi bi-airplane\"></i>, function: () => {R.navigate(\"https://www.jjodel.io/getting-started/\", navigate)}, keystroke: []},\r\n            {name: 'User guide', icon: <i className=\"bi bi-journals\"></i>, function: () => {R.navigate(\"https://www.jjodel.io/manual/\", navigate)}, keystroke: []},\r\n            {name: 'divisor', function: () => {}, keystroke: []},\r\n            {name: 'Legal terms', icon: <i className=\"bi bi-mortarboard\"></i>, function: () => {R.navigate(\"https://www.jjodel.io/terms-conditions-page/\", navigate)}, keystroke: []}\r\n        ],\r\n        keystroke: []},\r\n\r\n        {name: 'About jjodel', icon: <i className=\"bi bi-info-square\"></i>, function: () => {}, keystroke: []},\r\n        {name: 'divisor', function: () => {}, keystroke: []},\r\n        {name: 'Logout', icon: <i className=\"bi bi-box-arrow-right\"></i>, function: async() => {\r\n                await AuthApi.logout();\r\n                R.navigate('/auth', true);\r\n            }, keystroke: [Key.cmd, 'Q']}\r\n    ];\r\n\r\n\r\n\r\n    /* -- */\r\n\r\n    const recentProjects: MenuEntry[] = [];\r\n    const recentProjectsDisabled: MenuEntry[] = [];\r\n    let user: LUser = L.fromPointer(DUser.current); // props.user || L.fromPointer(DUser.current);\r\n\r\n\r\n\r\n    /*\r\n\r\n        The following is used for toggling fullscreen mode from the View menu\r\n\r\n    */\r\n\r\n    const [fullscreen, setFullscreen] = useState(false);\r\n\r\n    function isFullscreen() {\r\n        return fullscreen;\r\n    }\r\n\r\n    function toggleFullScreen() {\r\n        const elem = document.body;\r\n        setFullscreen(U.toggleFullscreen(elem));\r\n    }\r\n\r\n    /*\r\n\r\n        An error occurs in 'Recent projects' when a project is selected, then is saved - at this points all projects in user.projects are lost\r\n\r\n    */\r\n\r\n    /* retrieve all projects */\r\n\r\n    // if (user.projects[0]) {\r\n    //     localStorage.setItem('projects', JSON.stringify(user.projects));\r\n    //     let projects = user.projects;\r\n    // } else {\r\n    //     let projects = JSON.parse(localStorage.getItem('projects') || '[]');\r\n    // }\r\n\r\n\r\n    /* -- */\r\n\r\n    if (user?.projects) {\r\n\r\n        user.projects\r\n            .sort((a,b) => (b.lastModified > a.lastModified) ?  1 : -1)\r\n            .slice(0,20)\r\n            .map(p =>\r\n                recentProjects.push({name: p.name, function: ()=>{alert(p.name)}, icon: icon['project']})\r\n            );\r\n\r\n        user.projects\r\n            .sort((a,b) => (b.lastModified > a.lastModified) ?  1 : -1)\r\n            .slice(0,20)\r\n            .map(p =>\r\n                recentProjectsDisabled.push({name: p.name, function: ()=>{alert(p.name)}, icon: icon['project'], disabled: true})\r\n            );\r\n    }\r\n\r\n    let newModel: MenuEntry[] = [];\r\n\r\n    if (project && project.metamodels.length > 0) {\r\n        newModel.push({\r\n            name: 'Model',\r\n            icon: icon['model'],\r\n            subItems: project.metamodels.filter(m2=>!!m2).map((m2, i)=>({\r\n                name: m2.name, function: () => createM1(project, m2), keystroke: []\r\n            }))\r\n        });\r\n    } else {\r\n        newModel.push({\r\n            name: 'Model',\r\n            icon: icon['model'],\r\n            disabled: true\r\n        });\r\n    }\r\n\r\n\r\n    const isDashboard = !project;\r\n    const isProject = !!project;\r\n\r\n    const items: MenuEntry[] = [\r\n\r\n        // Jjodel OK\r\n\r\n        {name: 'Jjodel',\r\n            subItems: [\r\n                {name: 'About Jjodel',function: () => {AboutModal.open();}, icon: icon['jjodel']},\r\n                {name: 'Roadmap',function: () => open('https://www.jjodel.io/roadmap/'), icon: icon['roadmap']},\r\n                {name: 'divisor'},\r\n\r\n                {name: 'Settings', function: ()=> alert(), icon: icon['settings'], disabled: true}, // TO-DO\r\n                {name: 'divisor'},\r\n                {name: 'Logout', function: async() => {\r\n                        if (isProjectModified()) {\r\n                            U.dialog('You are about to log out without saving your project. Do you want to proceed?', 'logout', async ()=>{\r\n                                await AuthApi.logout();\r\n                                R.navigate('/auth');\r\n                            });\r\n                        } else {\r\n                            await AuthApi.logout();\r\n                            R.navigate('/auth');\r\n                        }},\r\n                    icon: icon['logout']}\r\n            ]},\r\n\r\n        /* File */\r\n\r\n        {name: 'File',\r\n            subItems: [\r\n                {name: 'New',function: () => {}, icon: icon['new'],\r\n                    subItems: [\r\n                        {name: 'Project', function: () => {}, icon: icon['project'], disabled: true},\r\n                        isDashboard ? null : {name: 'Metamodel', icon: icon['metamodel'], function: ()=>{ project && createM2(project); }, keystroke: [Key.alt, Key.cmd, 'M']},\r\n                        isDashboard ? null : newModel[0]\r\n                    ]\r\n                },\r\n                /* Recent Projects OK - va sistemato il refersh dei progetti */\r\n                {name: 'Recent Projects',function: () => {}, icon: icon['recent'], subItems: recentProjects},\r\n\r\n                /* Import Project OK */\r\n                isProject ? null : {name: 'Import Project', function: ProjectsApi.import, icon: icon['import']},\r\n                {name: 'divisor'},\r\n\r\n                /* Save Project OK */\r\n\r\n                isDashboard ? null : {name: 'Save Project',\r\n                    function: async () => {\r\n                        if (project) {\r\n                            try {\r\n                                await ProjectsApi.save(project);\r\n                            } catch (error: any) {\r\n                                U.alert('e', 'Error while Saving Project', error.message);\r\n                            }\r\n                        }\r\n                    }\r\n                    , icon: icon['save'], keystroke: [Key.cmd, 'S']},\r\n\r\n                /* Close Project OK */\r\n\r\n                isDashboard ? null : {name: 'Close Project',function: async() => {\r\n                        if (isProjectModified()) {\r\n                            U.dialog('Close the project without saving?', 'close project', async()=>{\r\n                                Collaborative.client.off('pullAction');\r\n                                await Collaborative.client.disconnect();\r\n                                SetRootFieldAction.new('collaborativeSession', false);\r\n                                U.resetState();\r\n                                R.navigate('/allProjects', true);\r\n                            });\r\n                        } else {\r\n                            Collaborative.client.off('pullAction');\r\n                            await Collaborative.client.disconnect();\r\n                            SetRootFieldAction.new('collaborativeSession', false);\r\n                            U.resetState();\r\n                            R.navigate('/allProjects', true);\r\n                        }\r\n                    }, icon: icon['close'], keystroke: [Key.cmd, 'E']},\r\n\r\n                /* Delete Project - vedere come fare  TEMPORARLY DISABLED */\r\n                true as any ? null : {name: 'Delete Project', function: ()=>{}, icon: icon['delete'], disabled: true},\r\n\r\n                /* Download Project OK */\r\n\r\n                isDashboard ? null : {name: 'Download Project', function: async() => {\r\n                        if (project) {\r\n                            await ProjectsApi.save(project);\r\n                            U.download(`${project.name}.jjodel`, JSON.stringify(project.__raw));\r\n                        }\r\n                    }, icon: icon['download']}\r\n            ]},\r\n\r\n        /* Edit: Damiano aggiungere funzioni undo/redo */\r\n\r\n        isDashboard ? null : {name: 'Edit',\r\n            subItems: [\r\n                {name: 'Undo',function: () => {}, icon: icon['undo'], keystroke: [Key.cmd, 'Z']},\r\n                {name: 'Redo',function: () => {}, icon: icon['redo'], keystroke: [Key.cmd, 'Y'], subItems:[{name:\"i\"}]},\r\n                /*\r\n                {name: 'Undo',function:()=>{undo(1)}, disabled:disabledUndo, icon: icon['undo'],\r\n                    keystroke: [Key.cmd, 'Z'], subItems:hoverUndo},\r\n                {name: 'Redo',function:()=>{redo(1)}, disabled:disabledRedo, icon: icon['redo'],\r\n                    keystroke: [Key.shift, Key.cmd, 'Z'], subItems:hoverRedo},\r\n                */\r\n                {name: 'divisor'},\r\n                {name: 'Add to Favorites', function: () => {}, icon: icon['favorite']}, // vedere in leftbar // TODO\r\n                {name: 'Copy Public Link', function: () =>{}, icon: icon['link'], keystroke: [Key.cmd, Key.shift, 'S']} // vedere in scheda progetto // TODO\r\n            ]\r\n        },\r\n\r\n        /* View - da fare */\r\n        isDashboard ? null : {name: 'View',\r\n            subItems: [\r\n                {name: 'Zoom-in', function: ()=>{}, icon: icon['zoom-in'], disabled: true}, // TODO\r\n                {name: 'Zoom-out', function: ()=>{}, icon: icon['zoom-out'], disabled: true}, // TODO\r\n\r\n                {name: 'divisor'},\r\n                {name: 'Toggle Grid', function: ()=>{}, icon: icon['toggle-grid'], disabled: true}, // TODO\r\n                {name: 'Toggle Snap-to-Grid', function: ()=>{}, icon: icon['toggle-snap'], disabled: true}, // TODO\r\n\r\n                {name: 'divisor'},\r\n                {name: 'Show/Hide Sidebar', function: ()=>{}, icon: icon['sidebar'], disabled: true}, // TODO\r\n                {name: 'Show/Hide Toolbar', function: ()=>{}, icon: icon['toolbar2'], disabled: true}, // TODO\r\n\r\n                {name: `${isFullscreen() ? 'Exit Fullscreen Mode' : 'Fullscreen Mode'}`, function: ()=>{toggleFullScreen()}, icon: icon['fullscreen']},\r\n                {name: 'Reset Layout', function: ()=>{}, icon: icon['reset-layout'], disabled: true} // TODO\r\n            ]\r\n        },\r\n        /* ANALYZE - da fare */\r\n\r\n        isDashboard ? null : {name: 'Analyze',\r\n            subItems: [\r\n                {name: 'Live Validation',function: () => {},icon: icon['validation'], disabled: true}, // TODO\r\n                {name: 'Validate',function: () => {}, icon: icon['validate'], disabled: true}, // TODO\r\n                {name: 'divisor'},\r\n                {name: 'Analytics', function: () => {}, icon: icon['metrics'], disabled: true} // TODO\r\n\r\n            ]\r\n        },\r\n\r\n        /* HELP ok */\r\n\r\n        {name: 'Help',\r\n            subItems: [\r\n                {name: 'What\\'s New in Jjodel',function: () => open(\"https://www.jjodel.io/whats-new/\"),icon: <i className=\"bi bi-bell\" />},\r\n                {name: 'divisor'},\r\n                {name: 'Homepage',function: () => open(\"https://www.jjodel.io\"), icon: <i className=\"bi bi-house\" />},\r\n                {name: 'divisor'},\r\n                {name: 'Learn Jjodel', function: () => open(\"https://www.jjodel.io/learn-jjodel/\"), icon: icon['learn']},\r\n                {name: 'Getting Started', function: ()=> open(\"https://www.jjodel.io/getting-started/\"), icon: icon['getting-started']},\r\n                {name: 'Video Tutorials', function: ()=> open(\"https://www.jjodel.io/video-tutorials/\"), icon: icon['video']},\r\n                {name: 'User Guide', function: ()=> open('https://www.jjodel.io/getting-started/'), icon: <i className=\"bi bi-journal-text\" />},\r\n                {name: 'Glossary', function: ()=> open('https://www.jjodel.io/glossary/'), icon: <i className=\"bi bi-book\" />},\r\n                {name: 'FAQ',function: () => {}, icon: icon['faq'], disabled: true},\r\n                {name: 'divisor'},\r\n                {name: 'Support', function: ()=>{}, icon: icon['support'],\r\n                    subItems: [\r\n                        {name: 'Report a Bug', function: ()=>{}, icon: icon['report-bug'], disabled: true}, // TODO\r\n                        {name: 'Request a Feature', function: ()=>{}, icon: icon['feature-request'], disabled: true}, // TODO\r\n                        {name: 'Contact', function: ()=>{}, icon: icon['contact'], disabled: true} // TODO\r\n                    ]}\r\n            ]}\r\n\r\n    ];\r\n\r\n\r\n    let itemsToRegister: MenuEntry[] = items; // [...items]; // [...dashboardItems, ...projectItems];\r\n    let keybindings = U.flattenObjectByKey(itemsToRegister, 'subItems')\r\n        .filter(e=> e && (e.keystroke?.length));\r\n    Keystrokes.register('#root', keybindings);\r\n\r\n    type MenuProps = {\r\n        title?: string;\r\n        items: MenuEntry[];\r\n    }\r\n\r\n    const MainMenu = (props: MenuProps) => {\r\n        return(<>\r\n                { props.items.map(m => !m || !m.subItems?.length ? null : <Submenu title={m.name} items={m.subItems} />) }\r\n            </>\r\n        );\r\n    }\r\n\r\n    const Submenu = (props: MenuProps) => {\r\n        return (<div className='nav-hamburger hoverable inline' key={props.title} tabIndex={0}>\r\n            {props.title && <span className={'menu-title'}>{props.title}</span>}\r\n            <div className={'content context-menu'}>\r\n                <ul>\r\n                    {props.items && props.items.map((i, index) => makeEntry(i, index))}\r\n                </ul>\r\n            </div>\r\n        </div>\r\n    )}\r\n\r\n    const MainMenu2 = (props: MenuProps) => {\r\n\r\n        return(\r\n            <div className='nav-hamburger hoverable' tabIndex={0}>\r\n                <i className=\"bi bi-grid-3x3-gap-fill list\"></i>\r\n                <div className={'content context-menu'}>\r\n                    <ul>\r\n                        { props.items.map((i, index) => makeEntry(i, index)) }\r\n                    </ul>\r\n                </div>\r\n            </div>\r\n        );\r\n    };\r\n\r\n    const MainLogo = () => {\r\n        let toggleDebug = (e: any)=>{\r\n            e.preventDefault();\r\n            TRANSACTION('debug', ()=>SetRootFieldAction.new('debug', !props.debug), props.debug, !props.debug);\r\n        }\r\n        return (\r\n        <div className='nav-logo'>\r\n            <div className={\"aligner\"}>\r\n\r\n                {props.debug ?\r\n                    <div className='logo-on' onContextMenu={toggleDebug}></div>\r\n                    :\r\n                    <div className='logo' onContextMenu={toggleDebug}></div>\r\n                }\r\n                {props.debug && <i className=\"bi bi-bug-fill\"></i>}\r\n\r\n            </div>\r\n        </div>\r\n        );\r\n    }\r\n\r\n    const Commands = () => {\r\n        return (<label className='text-end nav-commands d-flex'>\r\n            {project && <>\r\n                <span className={\"my-auto me-1\"}>{props.advanced ? \"advanced\" : \"base\"}</span>\r\n                <Input type=\"toggle\"\r\n                       className={\"my-auto\"}\r\n                       style={{fontSize:'1.25em'}}\r\n                       setter={(v) => {\r\n                           SetRootFieldAction.new('advanced', v);\r\n                           windoww.advanced = v;\r\n                       }}\r\n                       getter={() => props.advanced}/>\r\n            </>\r\n            }\r\n        </label>);\r\n    };\r\n\r\n    const UserMenu = () => {\r\n        return (<>\r\n        <div className='text-end nav-side'>\r\n                <div style={{float: 'right', left: '300px!important', marginTop: '2px'}}>\r\n                    <Menu position={'left'}>\r\n                        <Item icon={icon['dashboard']} action={async() => {\r\n                            Collaborative.client.off('pullAction');\r\n                            await Collaborative.client.disconnect();\r\n                            SetRootFieldAction.new('collaborativeSession', false);\r\n                            U.resetState();\r\n                            R.navigate('/allProjects');\r\n                        }}>Dashboard</Item>\r\n                        <Divisor />\r\n                        <Item icon={icon['profile']} action={()=> {\r\n                            R.navigate('/account');\r\n                            U.resetState();\r\n                        }}>Profile</Item>\r\n                        <Item icon={icon['settings']} action={(e)=> {alert('')}}>Settings</Item>\r\n                        <Divisor />\r\n                        <Item icon={icon['logout']} action={async () => {\r\n                            if (isProjectModified()) {\r\n                                U.dialog('You are about to log out without saving your project. Do you want to proceed?', 'logout', async ()=>{\r\n                                    await AuthApi.logout();\r\n                                    R.navigate('/auth');\r\n                                });\r\n                            } else {\r\n                                await AuthApi.logout();\r\n                                R.navigate('/auth');\r\n\r\n                            }\r\n                        }}>Logout</Item>\r\n                    </Menu>\r\n                </div>\r\n            </div>\r\n        </>);\r\n    }\r\n\r\n    return(<>\r\n        <nav className={'w-100 nav-container d-flex'} style={{zIndex: 99}}>\r\n            <MainMenu items={items} />\r\n            <MainLogo />\r\n            <UserMenu />\r\n            <Commands />\r\n            <User />\r\n        </nav>\r\n\r\n        {project && clicked === 'new.metamodel' && <MetamodelPopup {...{project, setClicked}} />}\r\n        {project && clicked === 'new.model' && <ModelPopup {...{metamodels, project, setClicked}} />}\r\n    </>);\r\n}\r\n\r\ninterface OwnProps {}\r\ninterface StateProps {\r\n    user: LUser;\r\n    project?: LProject;\r\n    metamodels: LModel[];\r\n    version: DState['version'];\r\n    advanced: boolean;\r\n    debug: boolean;\r\n}\r\ninterface DispatchProps {}\r\ntype AllProps = OwnProps & StateProps & DispatchProps;\r\n\r\n\r\nfunction mapStateToProps(state: DState, ownProps: OwnProps): StateProps {\r\n    const ret: StateProps = {} as FakeStateProps;\r\n    ret.user = LUser.fromPointer(DUser.current);\r\n    ret.project = ret.user?.project || undefined;\r\n    ret.metamodels = LModel.fromArr(state.m2models);\r\n    ret.version = state.version;\r\n    ret.advanced = state.advanced;\r\n    ret.debug = state.debug;\r\n    return ret;\r\n}\r\n\r\nfunction mapDispatchToProps(dispatch: Dispatch<any>): DispatchProps {\r\n    const ret: DispatchProps = {};\r\n    return ret;\r\n}\r\n\r\nconst NavbarConnected = connect<StateProps, DispatchProps, OwnProps, DState>(\r\n    mapStateToProps,\r\n    mapDispatchToProps\r\n)(NavbarComponent);\r\n\r\nconst Navbar = (props: OwnProps, children: (string | Component)[] = []): ReactElement => {\r\n    return <NavbarConnected {...{...props, children}} />;\r\n}\r\n\r\nexport {Navbar};\r\n","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\pages\\Archive.tsx",[],"C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\pages\\Community.tsx",[],"C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\pages\\Project.tsx",["1548","1549","1550","1551","1552","1553","1554","1555","1556","1557","1558","1559"],"import React, {Dispatch, ReactElement, useEffect,  useState} from 'react';\r\nimport {connect} from 'react-redux';\r\nimport {\r\n    CreateElementAction,\r\n    Dictionary,\r\n    DState,\r\n    DUser,\r\n    DViewElement, GObject,\r\n    LProject,\r\n    LUser,\r\n    LViewElement,\r\n    LViewPoint,\r\n    Pointer,\r\n    R,\r\n    Try,\r\n    U\r\n} from '../joiner';\r\nimport {FakeStateProps} from '../joiner/types';\r\nimport useQuery from '../hooks/useQuery';\r\nimport {ProjectsApi} from '../api/persistance';\r\nimport {SaveManager} from '../components/topbar/SaveManager';\r\nimport {Dashboard} from \"./components\";\r\nimport CollaborativeAttacher from \"../components/collaborative/CollaborativeAttacher\";\r\nimport {Cards} from './components/cards/Cards';\r\nimport Storage from \"../data/storage\";\r\nimport Loader from '../components/loader/Loader';\r\nimport {Navbar} from \"./components\";\r\nimport {CSS_Units} from \"../view/viewElement/view\";\r\nimport {useEffectOnce} from \"usehooks-ts\";\r\n\r\nfunction ProjectComponent(props: AllProps): JSX.Element {\r\n    const {user} = props;\r\n    const query = useQuery();\r\n    const id = query.get('id') || '';\r\n\r\n    useEffect(() => {\r\n        (async function() {\r\n            const project = await ProjectsApi.getOne(id); \r\n            if(!project) {\r\n                U.resetState();\r\n                R.navigate('/allProject');\r\n                return;\r\n            }\r\n            if(project.state) {\r\n                const state = JSON.parse(await U.decompressState(project.state));\r\n                state['idlookup'][DUser.current] = user.__raw;\r\n                if(!state['users'].includes(DUser.current)) state['users'].push(DUser.current);\r\n                SaveManager.load(state);\r\n            }\r\n\r\n            user.project = LProject.fromPointer(project.id);\r\n        })();\r\n    }, [id]);\r\n\r\n    let vparr = user?.project?.viewpoints || [];\r\n    let allViews = vparr.flatMap((vp: LViewPoint) => vp && vp.allSubViews);\r\n    allViews.push(...vparr as LViewElement[]);\r\n    allViews = allViews.filter(v => v);\r\n    const viewsDeDuplicator: Dictionary<Pointer<DViewElement>, LViewElement> = {};\r\n    for (let v of allViews) viewsDeDuplicator[v.id] = v;\r\n    if (!user?.project) {\r\n        return (\r\n            <div className={'w-100 h-100 d-flex'}>\r\n                <div className={'m-auto d-flex p-5'} style={{flexFlow: 'column', cursor:'pointer'}}onClick={(e) => R.navigate('/allProjects')}>\r\n                    <h4 className={'mx-auto'}>Project loading...</h4>\r\n                    <div className={'mx-auto'}>if it takes too long try refreshing the page, or click to go back</div>\r\n                </div>\r\n            </div>\r\n        );\r\n    }\r\n\r\n    return (<>\r\n        <Try>\r\n        <Dashboard active={'Project'} version={props.version} project={user.project}>\r\n            <React.Fragment>\r\n                <style id={\"views-css-injector-p\"}>\r\n                    {Object.values(viewsDeDuplicator).map(v => v.compiled_css).join('\\n\\n')}\r\n                </style>\r\n                {CSS_Units.jsx}\r\n\r\n                <Cards>\r\n                    {user.project.metamodels.length === 0 ?\r\n                        <Cards.Item\r\n                            title={'Your first metamodel ?'}\r\n                            subtitle={'Create a new metamodel.'}\r\n                            icon={'add'}\r\n                            style={'red'}\r\n                            action={() => {\r\n                                alert('new metamodel')\r\n                            }}\r\n                        />\r\n                        :\r\n                        <React.Fragment>\r\n                            <Cards.Item\r\n                                title={'Create another metamodel ?'}\r\n                                subtitle={'Create a new metamodel.'}\r\n                                icon={'add'}\r\n                                style={'red'}\r\n                                action={() => {\r\n                                    alert('another metamodel')\r\n                                }}\r\n                            />\r\n                            <Cards.Item\r\n                                title={'Create a model ?'}\r\n                                subtitle={'Create a new model.'}\r\n                                icon={'add'}\r\n                                style={'red'}\r\n                                action={() => {\r\n                                    alert('new model')\r\n                                }}\r\n                            />\r\n                        </React.Fragment>\r\n                    }\r\n                    <Cards.Item icon={'question'} style={'clear'} title={'Ehy!'}\r\n                                subtitle={'What do you want to do today?'}/>\r\n                </Cards>\r\n\r\n            </React.Fragment>\r\n        </Dashboard>\r\n        </Try>\r\n\r\n        {/*<Try><Dock /></Try>*/}\r\n        {user.project.type === 'collaborative' && <CollaborativeAttacher project={user.project}/>}\r\n    </>);\r\n\r\n}\r\n\r\ninterface OwnProps {\r\n}\r\n\r\ninterface StateProps {\r\n    user: LUser,\r\n    version: DState[\"version\"],\r\n}\r\ninterface DispatchProps {}\r\ntype AllProps = OwnProps & StateProps & DispatchProps;\r\n\r\n\r\nfunction mapStateToProps(state: DState, ownProps: OwnProps): StateProps {\r\n    const ret: StateProps = {} as FakeStateProps;\r\n    ret.user = LUser.fromPointer(DUser.current);\r\n    return ret;\r\n}\r\n\r\nfunction mapDispatchToProps(dispatch: Dispatch<any>): DispatchProps {\r\n    const ret: DispatchProps = {};\r\n    return ret;\r\n}\r\n\r\nexport const ProjectConnected = connect<StateProps, DispatchProps, OwnProps, DState>(\r\n    mapStateToProps,\r\n    mapDispatchToProps\r\n)(ProjectComponent);\r\n\r\nconst ProjectPage = (props: OwnProps, children: (string | React.Component)[] = []): ReactElement => {\r\n    return <ProjectConnected {...{...props, children}} />;\r\n}\r\n\r\nexport {ProjectPage};\r\n\r\n","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\pages\\Profile.tsx",["1560","1561","1562","1563"],"import {Try} from '../joiner';\r\nimport {Dashboard} from './components';\r\n\r\nimport {Cards, Card} from './components/cards/Cards';\r\nimport { Catalog } from './components/catalog/Catalog';\r\n\r\nfunction ProfilePage(): JSX.Element {\r\n    // NB: this works only in production if you put subfolders with past builds in the new build root.\r\n    return(<Try>\r\n        <Dashboard active={'Profile'} version={{n: 0, date:'fake-date'}}>\r\n            <>                \r\n\r\n            <Cards>\r\n                <Cards.Item\r\n                    title={'Getting started'} \r\n                    subtitle={'Create your first notation.'}\r\n                    icon={'gettingstarted'} \r\n                    style={'rainbow'}   \r\n                />\r\n                {<Cards.Item icon={'question'} style={'clear'} title={'Ehy!'}\r\n                             subtitle={'What do you want to do today?'}/>}\r\n            </Cards>\r\n\r\n            <ul>\r\n                <li><a href={window.location.origin + '/jjodel'}>2.0</a></li>\r\n                <li><a href={window.location.origin + '/jjodel/2.1/'}>2.1</a></li>\r\n                <li><a href={window.location.origin + '/jjodel/2.2/'}>2.2 (to come)</a></li>\r\n            </ul>\r\n            </>\r\n            \r\n        </Dashboard>\r\n    </Try>);\r\n}\r\n\r\nexport {ProfilePage};\r\n","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\pages\\Notes.tsx",["1564","1565","1566","1567","1568","1569","1570","1571","1572","1573","1574","1575","1576","1577","1578","1579","1580","1581"],"import React, {ChangeEvent, MouseEventHandler, Component, Dispatch, ReactElement, useState, useRef } from 'react';\r\nimport {connect} from 'react-redux';\r\nimport {DProject, DState, LProject, Try, U} from '../joiner';\r\nimport {FakeStateProps} from '../joiner/types';\r\nimport {Dashboard, Project} from './components';\r\nimport Storage from \"../data/storage\";\r\n\r\nimport {Menu, Item, Divisor} from './components/menu/Menu';\r\n\r\nimport colors from '../static/img/colors.png';\r\nimport {CatalogInfoCard} from \"./components/catalog/Catalog\";\r\n\r\n\r\n\r\ntype CardsType = {\r\n    children: any;\r\n};\r\n\r\n\r\nconst Cards = (props: CardsType): any => {\r\n    return (\r\n        <React.Fragment>\r\n            <div className='row mb-5 commandbar'>\r\n                {props.children}\r\n            </div>\r\n        </React.Fragment>\r\n    );\r\n}\r\n\r\ntype CardType = {\r\n    icon: \"add\" | \"import\" | \"clone\" | \"question\";\r\n    style?: \"blue\" | \"red\" | \"dark\" | \"clear\" | \"rainbow\" | \"default\";\r\n    title: string;\r\n    subtitle: string;\r\n    action?: MouseEventHandler;\r\n    children?: JSX.Element[];\r\n};\r\n\r\nconst Card = (props: CardType) => {\r\n\r\n    const icons = {\r\n        add: \"bi-plus-circle\",\r\n        import: \"bi-box-arrow-in-up\",\r\n        question: \"bi-question-square\",\r\n        clone: \"bi-clipboard2-check\"\r\n    };\r\n\r\n    return (<>\r\n        <div className={`card ${props.style ? props.style : 'default' }`}>\r\n            <div className={'col icon'}>\r\n                {props.action ?\r\n                    <i onClick={props.action} className={`bi ${icons[props.icon]}`}></i> :\r\n                    <i className={`bi ${icons[props.icon]} disabled`}></i>\r\n                }\r\n            </div>\r\n            <div className={'col body'}>\r\n                <h5>{props.title}</h5>\r\n                {props.subtitle}\r\n            </div>\r\n        </div>\r\n        </>\r\n    );\r\n}\r\n\r\nCards.Item = Card;\r\n\r\ntype ChildrenType = {\r\n    projects?: any;\r\n    children?: JSX.Element[];\r\n};\r\n\r\n\r\n/* main component */\r\n\r\nconst Catalog = (props: ChildrenType) => {\r\n\r\n    const [filters, setFilters] = useState([false,false,false]);\r\n    const [mode, setMode] = useState<string>(\"cards\");\r\n\r\n    const Header = (props: ChildrenType) => {\r\n        return (\r\n            <div className='row catalog-header'>\r\n                {props.children}\r\n            </div>\r\n        );\r\n    }\r\n\r\n    const CatalogFilters = () => {\r\n\r\n        function toggleFilters(el: 0|1|2) {\r\n            switch(el) {\r\n                case 0:\r\n                    setFilters([!filters[0], filters[1], filters[2]]);\r\n                    break;\r\n                case 1:\r\n                    setFilters([filters[0], !filters[1], filters[2]]);\r\n                    break;\r\n                case 2:\r\n                    setFilters([filters[0], filters[1], !filters[2]]);\r\n                    break;\r\n            }\r\n        };\r\n\r\n        return (\r\n            <div className={'col left'}>\r\n                {filters[0] ? <button onClick={(e) => toggleFilters(0)} className='active'>public</button> : <button onClick={(e) => toggleFilters(0)}>public</button>}\r\n                {filters[1] ? <button onClick={(e) => toggleFilters(1)} className='active'>private</button> : <button onClick={(e) => toggleFilters(1)}>private</button>}\r\n                {filters[2] ? <button onClick={(e) => toggleFilters(2)} className='active'>collaborative</button> : <button onClick={(e) => toggleFilters(2)} >collaborative</button>}\r\n            </div>\r\n        );\r\n    }\r\n\r\n    const CatalogMode = () => { // unused component?\r\n        return (<>\r\n            <div className={'col left'}>\r\n                <div className=\"float-end\">sorted by\r\n                    <div className={'view-icons'}>\r\n                        <i onClick={(e) => setMode('cards')} className={`bi bi-grid ${mode === \"cards\" && 'selected'}`}></i>\r\n                        <i onClick={(e) => setMode('list')} className={`bi bi-list ${mode === \"list\" && 'selected'}`}></i>\r\n                    </div>\r\n                    <div style={{float: 'right'}}>\r\n                    <Menu position={'left'}>\r\n                        <Item action={(e)=> {alert('')}}>Alphabetical</Item>\r\n                        <Item>Date created</Item>\r\n                        <Item>Last modified</Item>\r\n                    </Menu>\r\n                    </div>\r\n                </div>\r\n            </div>\r\n        </>);\r\n    }\r\n\r\n    const CatalogSide = (props: ChildrenType) => {\r\n        return (\r\n            <div className={'catalog'}>\r\n                {props.children}\r\n            </div>\r\n        );\r\n    }\r\n\r\n\r\n    type CatalogType = {\r\n        projects: LProject[];\r\n    }\r\n\r\n    const CatalogReport = (props: CatalogType) =>{\r\n\r\n        let items_public: LProject[] = [];\r\n        let items_private: LProject[] = [];\r\n        let items_collaborative: LProject[] = [];\r\n\r\n\r\n        if (filters[0]) {\r\n            items_public = props.projects.filter(p => p.type === \"public\");\r\n        }\r\n        if (filters[1]) {\r\n            items_private = props.projects.filter(p => p.type === \"private\");\r\n        }\r\n        if (filters[2]) {\r\n            items_collaborative = props.projects.filter(p => p.type === \"collaborative\");\r\n        }\r\n\r\n        //var items  = items_public.concat(items_private,items_collaborative);\r\n\r\n        var items = props.projects.filter(p =>\r\n            (filters[0] && p.type ===\"public\" || filters[1] && p.type ===\"private\" || filters[2] && p.type ===\"collaborative\" || !filters[0] && !filters[1] && !filters[2]));\r\n\r\n        return (\r\n\r\n            mode == \"cards\" ?\r\n\r\n            <div style={{display: (items.length > 0) ? 'flex' : 'flex'}} className={'flex-wrap'} >\r\n\r\n                {items.length === 0 && <div>Sorry, there are no results matching your search criteria. Please try again with different filters.</div>}\r\n\r\n                {\r\n                    props.projects.map(p => <>\r\n                        {filters[0] && p.type === \"public\" && <Project key={p.id} data={p} mode={mode} />}\r\n                        {filters[1] && p.type === \"private\" && <Project key={p.id} data={p} mode={mode} />}\r\n                        {filters[2] && p.type === \"collaborative\" && <Project key={p.id} data={p} mode={mode} />}\r\n                        {!filters[0] && !filters[1] && !filters[2] && <Project key={p.id} data={p} mode={mode} />}\r\n                    </>)\r\n                }\r\n\r\n            </div>\r\n\r\n            :\r\n            <div className={'row project-list'}>\r\n                <div className='row header'>\r\n                    <div className={'col-6'}>Name</div><div className={'col-3'}>Last modified</div><div className={'col-3'}>Created</div>\r\n                </div>\r\n                {\r\n                    props.projects.map(p => <>\r\n                        {filters[0] && p.type === \"public\" && <Project key={p.id} data={p} mode={mode} />}\r\n                        {filters[1] && p.type === \"private\" && <Project key={p.id} data={p} mode={mode} />}\r\n                        {filters[2] && p.type === \"collaborative\" && <Project key={p.id} data={p} mode={mode} />}\r\n                        {!filters[0] && !filters[1] && !filters[2] && <Project key={p.id} data={p} mode={mode} />}\r\n                    </>)\r\n                }\r\n            </div>\r\n\r\n        );\r\n    };\r\n\r\n    return (\r\n        <div>\r\n            <Header>\r\n                <CatalogFilters/>\r\n                <CatalogMode/>\r\n            </Header>\r\n            <CatalogSide>\r\n                <CatalogInfoCard projects={props.projects}/>\r\n                <CatalogReport projects={props.projects}/>\r\n            </CatalogSide>\r\n        </div>\r\n    );\r\n}\r\n\r\nfunction AllProjectsComponent(props: AllProps): JSX.Element {\r\n    const {projects} = props;\r\n\r\n    const reader = new FileReader();\r\n    reader.onload = async e => {\r\n        /* Import Project File */\r\n        const content = String(e.target?.result);\r\n        if(!content) return;\r\n        try {\r\n            const project = JSON.parse(content) as DProject;\r\n            const projects = Storage.read<DProject[]>('projects') || [];\r\n            const filtered = projects.filter(p => p.id !== project.id);\r\n            filtered.push(project);\r\n            Storage.write('projects', filtered);\r\n            U.resetState();\r\n        } catch (e) {alert('Invalid File.')}\r\n    }\r\n\r\n    const importProject = async(e: ChangeEvent<HTMLInputElement>) => {\r\n        const files = e.target.files || [];\r\n        if(!files.length) return;\r\n        const file = files[0];\r\n        reader.readAsText(file);\r\n    }\r\n\r\n\r\n\r\n\r\n    return(<Try>\r\n        <Dashboard active={'Notes'} version={props.version}>\r\n\r\n            <React.Fragment>\r\n\r\n                <Cards>\r\n                    <Cards.Item\r\n                        title={'Clone a template'}\r\n                        subtitle={'Clone a template in your workspace.'}\r\n                        icon={'clone'}\r\n                        style={'rainbow'}\r\n                    />\r\n                    {true && <Cards.Item icon={'question'} style={'clear'} title={'Ehy!'} subtitle={'What do you want to do today?'}/>}\r\n                </Cards>\r\n\r\n                <Catalog projects={projects} />\r\n            </React.Fragment>\r\n\r\n        </Dashboard>\r\n    </Try>);\r\n}\r\n\r\ninterface OwnProps {}\r\ninterface StateProps {\r\n    projects: LProject[];\r\n    version: DState[\"version\"];\r\n}\r\ninterface DispatchProps {}\r\n\r\ntype AllProps = OwnProps & StateProps & DispatchProps;\r\n\r\n\r\nfunction mapStateToProps(state: DState, ownProps: OwnProps): StateProps {\r\n    const ret: StateProps = {} as FakeStateProps;\r\n    ret.projects = LProject.fromArr(state.projects);\r\n    ret.version = state.version;\r\n    return ret;\r\n}\r\n\r\nfunction mapDispatchToProps(dispatch: Dispatch<any>): DispatchProps {\r\n    const ret: DispatchProps = {};\r\n    return ret;\r\n}\r\n\r\nconst AllProjectsConnected = connect<StateProps, DispatchProps, OwnProps, DState>(\r\n    mapStateToProps,\r\n    mapDispatchToProps\r\n)(AllProjectsComponent);\r\n\r\nconst NotesPage = (props: OwnProps, children: (string | Component)[] = []): ReactElement => {\r\n    return <AllProjectsConnected {...{...props, children}} />;\r\n}\r\n\r\nexport {NotesPage};\r\n\r\n","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\pages\\Settings.tsx",[],"C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\pages\\ProjectsInfo.tsx",["1582"],"import {Try} from \"../components/forEndUser/Try\";\r\nimport {Dashboard} from \"./components\";\r\nimport {useState} from \"react\";\r\nimport {DProject, DUser, SetRootFieldAction} from \"../joiner\";\r\nimport {useEffectOnce} from \"usehooks-ts\";\r\nimport {AdminApi} from \"../api/persistance\";\r\n\r\ntype Props = {};\r\nfunction ProjectsInfoPage(props: Props) {\r\n    const [projects, setProjects] = useState<DProject[]>([]);\r\n    useEffectOnce(() => {\r\n        (async function() {\r\n            SetRootFieldAction.new('isLoading', true);\r\n            setProjects(await AdminApi.projects());\r\n            SetRootFieldAction.new('isLoading', false);\r\n        })();\r\n    });\r\n\r\n    return(<Try>\r\n        <Dashboard active={'UsersInfo'} version={{n: 0, date:'fake-date'}}>\r\n            <div>\r\n                Projects: {projects.length}\r\n                {projects.map(p => <div key={p.id}>\r\n                    {p.name} (State: {p.state.length}, M2: {p.metamodelsNumber}, M1: {p.modelsNumber}, VP: {p.viewpointsNumber})\r\n                </div>)}\r\n            </div>\r\n        </Dashboard>\r\n    </Try>);\r\n}\r\n\r\nexport {ProjectsInfoPage};\r\n","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\pages\\Error.tsx",[],"C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\pages\\Updates.tsx",["1583","1584","1585","1586","1587"],"import {Dictionary, R, Try, windoww} from '../joiner';\r\nimport {Dashboard} from './components';\r\n\r\nimport {Cards, Card} from './components/cards/Cards';\r\nimport {Catalog} from './components/catalog/Catalog';\r\nimport {ReactNode, useState} from \"react\";\r\nimport \"./DashStyles/updates.scss\"\r\n\r\ntype keys = 'fix' | 'newbug' | 'opt' | 'feat' | 'info';\r\n\r\nclass InfoEntry {\r\n    constructor(public title: ReactNode, public content: ReactNode, public key: keys) {\r\n    }\r\n}\r\n\r\nclass Version {\r\n    static all: Version[] = [];\r\n    entries: Dictionary<keys, InfoEntry[]>;\r\n    majorEntries: InfoEntry[];\r\n    minorEntries: InfoEntry[];\r\n    _minor: boolean;\r\n    number: string;\r\n    name: string;\r\n    date: string;\r\n\r\n    constructor(number: string, name: string, date: string) {\r\n        this.number = number;\r\n        this.name = name;\r\n        this.date = date;\r\n        this.entries = {fix: [], newbug: [], opt: [], feat: [], info: []};\r\n        this.majorEntries = [];\r\n        this.minorEntries = [];\r\n        this._minor = false;\r\n        Version.all.push(this);\r\n    }\r\n\r\n    add(key: keys, title: ReactNode, node: ReactNode = null): this {\r\n        let entry = new InfoEntry(title, node, key);\r\n        this.entries[key].push(entry);\r\n        // if (this._minor) this.minorEntries.push(entry) else\r\n        this.majorEntries.push(entry);\r\n        return this;\r\n    }\r\n\r\n    fix(title: ReactNode, node: ReactNode = null): this {\r\n        this.add('fix', title, node);\r\n        return this;\r\n    }\r\n\r\n    newbug(title: ReactNode, node: ReactNode = null): this {\r\n        this.add('newbug', title, node);\r\n        return this;\r\n    }\r\n\r\n    opt(title: ReactNode, node: ReactNode = null): this {\r\n        this.add('opt', title, node);\r\n        return this;\r\n    }\r\n\r\n    feat(title: ReactNode, node: ReactNode = null): this {\r\n        this.add('feat', title, node);\r\n        return this;\r\n    }\r\n\r\n    engine(title: ReactNode, node: ReactNode = null): this {\r\n        this.add('feat', title, node);\r\n        return this;\r\n    }\r\n\r\n    info(title: ReactNode, node: ReactNode = null): this {\r\n        this.add('info', title, node);\r\n        return this;\r\n    }\r\n\r\n    minor(): this {\r\n        this._minor = true;\r\n        return this;\r\n    }\r\n}\r\n\r\nlet warnicon = <i className=\"bi bi-exclamation-triangle-fill\"/>\r\n// <i className=\"bi bi-exclamation-diamond-fill\" />;\r\n// <i className=\"bi bi-exclamation-square-fill\" />;\r\n\r\nfunction versionsetup() {\r\n    localStorage.setItem('_jj_update_date', '' + Math.min(Date.now(), new Date('2024-11-19').getTime()));\r\n    new Version('2.2', 'manatee', '19/nov/2024')\r\n        .newbug(<>{warnicon} Edges</>, <>Some update were made on edge's internal behaviour, old saves might have side effects.\r\n            If edges are not behaving properly create a new project, copy the default model's JSX and paste it in the old project.\r\n            <br/>To enable edits on default views right-click on the jjodel logo at the top-center of the page.\r\n            <br/>On custom views try to make start and end point to vertexes (draggable items) instead of fields (inline items).</>)\r\n        .feat('console tips', 'When hovering a console output or suggested keys a tooltip will show documentation.')\r\n        .fix('delete viewpoints', 'But cannot delete the active viewpoint.') // what if i delete a non-exclusive vp?\r\n        .fix('delete models')\r\n        .fix('containment & parent', 'Containment references were inconsistently updating the .parent property of contained elements.')\r\n        .feat('model dependencies', <>Models can now \"depend\" on other models in a extend-like style. if A depends on B\r\n            (A→B), A can use concepts from B.\r\n            <br/>Dependency chains (A→B→C) and loops (A→B, B→A) are also supported\r\n            <br/>Cross-reference activation is required too.</>)\r\n        .feat('cross-Reference', <>Cross-reference can be activated for: classes (inheritance), features (type).<br/>\r\n            To reduce cluttering in the options, normally you can only reference concepts in the same model.<br/>\r\n            If Cross-Reference is enabled you can reference valid concepts from all model dependencies.\r\n        </>)\r\n        .feat('context-menu containment', <>The option to add containment objects has been expanded, it is now available\r\n            to individual features too.</>)\r\n        .engine('data.validTargets (JDL Engine)', <>Can be used to create custom DSL and filtered to restrict model transformations, it\r\n            provides a list of valid targets for:\r\n            <ul>\r\n                <li>class extension</li>\r\n                <li>parameter, operation and m2-feature type</li>\r\n                <li>m1-values</li>\r\n                <li>model-dependencies</li>\r\n            </ul>\r\n        </>)\r\n        .minor()\r\n        .feat('U.clickedOutside()',\r\n            <>Utility for interactive graphs: When a click is detected outside the first parameter (HTMLElement or Event), it triggers a callback function in the first parameter.\r\n                <br/>\r\n                Example: {\"<div onClick={(evt)=>{data.$active=true; U.clickedOutside(evt, ()=>data.$active=false)}} ></div>\"} where\r\n                data is a m1-object holding a boolean feature \"active\"\r\n                {warnicon} To ensure the node is properly updated, remember to add \"Listed dependencies\" accordingly to\r\n                the value edited in the view.\r\n                <br/>In this example you need the dependency \"active = data.$active\" or equivalent ones.\r\n                <br/>Without it the value would update immediately but the graphical representation would always be 1 state behind.\r\n            </>)\r\n        .fix('structure editor', 'The layout was occasionally breaking')\r\n        .feat('changelog', 'Yes, this one. It deserved a mention.')\r\n}\r\n\r\nfunction UpdatesPage(): JSX.Element {\r\n    // NB: this works only in production if you put subfolders with past builds in the new build root.\r\n    let [info, setInfo] = useState(true);\r\n    let [feat, setFeat] = useState(true);\r\n    let [fix, setFix] = useState(true);\r\n    let [newbug, setNewbug] = useState(true);\r\n    let [opt, setOpt] = useState(false);\r\n    let [versionCollapse, setVersionCollapse] = useState({} as Dictionary<string, boolean>);\r\n\r\n    if (!Version.all.length) versionsetup();\r\n    let allowedDict: Dictionary<keys, boolean> = {info, feat, fix, newbug, opt};\r\n    let cards: ReactNode =\r\n        <Cards>\r\n            <Cards.Item\r\n                title={'Getting started'}\r\n                subtitle={'Create your first notation.'}\r\n                icon={'gettingstarted'}\r\n                style={'rainbow'}\r\n            />\r\n            {true && <Cards.Item icon={'question'} style={'clear'} title={'Ehy!'}\r\n                                 subtitle={'What do you want to do today?'}/>}\r\n        </Cards>;\r\n    cards = null;\r\n\r\n    return (<Try>\r\n        <Dashboard active={'Updates'} version={{n: 0, date: 'fake-date'}}>\r\n            <div id={'updates-page'}>{cards}\r\n                <h2>Past versions\r\n                    <select className={'ms-2'}\r\n                            onChange={(e) => R.navigate(e.target.value)}>\r\n                        <option value='/jjodel/2.2' title={'13/nov/2024'}>2.2</option>\r\n                        <option value='/jjodel/2.1' disabled>2.1</option>\r\n                        <option value='/jjodel/2.0' disabled>2.0</option>\r\n                    </select>\r\n                </h2>\r\n                <div className={'filter-container'}>\r\n                    <button className={'feat btn btn-' + (feat ? '' : 'outline-') + 'info'}\r\n                            onClick={e => setFeat(!feat)}>Feature\r\n                    </button>\r\n                    <button className={'fix btn btn-' + (fix ? '' : 'outline-') + 'success'}\r\n                            onClick={e => setFix(!fix)}>Bugfix\r\n                    </button>\r\n                    <button className={'newbug btn btn-' + (newbug ? '' : 'outline-') + 'danger'}\r\n                            onClick={e => setNewbug(!newbug)}>New known bug\r\n                    </button>\r\n                    <button className={'info btn btn-' + (info ? '' : 'outline-') + 'secondary'}\r\n                            onClick={e => setInfo(!info)}>Information\r\n                    </button>\r\n                    <button className={'opt btn btn-' + (opt ? '' : 'outline-') + 'warning'}\r\n                            onClick={e => setOpt(!opt)}>Optimization\r\n                    </button>\r\n                </div>\r\n                <ul className={'version-list'}>\r\n                    {Version.all.map(v=>\r\n                    <li className={'version'}>\r\n                        <h2 className={'version-name'} onClick={()=>{setVersionCollapse({...versionCollapse, [v.number]: !versionCollapse[v.number]})}}>{\r\n                            <i className={\"bi bi-chevron-\" + (!versionCollapse[v.number] ? 'up' : 'down')}/>\r\n                        } {v.number} {v.name} {v.date}\r\n                        </h2>\r\n                        {!versionCollapse[v.number] && <ul className={'entry-list'}>\r\n                            {v.majorEntries.map(e => {\r\n                                if (!allowedDict[e.key]) return null;\r\n                                return <li className={'entry ' + e.key}>\r\n                                    <span className={'title'}>{e.title}</span>\r\n                                    <span className={'content'}>{e.content}</span>\r\n                                </li>\r\n                            })\r\n                            }\r\n                        </ul>}\r\n                    </li>)\r\n                    }\r\n                </ul>\r\n            </div>\r\n        </Dashboard>\r\n    </Try>)\r\n        ;\r\n}\r\n\r\nexport {UpdatesPage};\r\n","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\pages\\News.tsx",[],"C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\pages\\Recent.tsx",["1588","1589","1590","1591","1592","1593","1594","1595","1596","1597","1598","1599"],"import React, {ChangeEvent, MouseEventHandler, Component, Dispatch, ReactElement, useState, useRef } from 'react';\r\nimport {connect} from 'react-redux';\r\nimport {DProject, DState, LProject, Try, U} from '../joiner';\r\nimport {FakeStateProps} from '../joiner/types';\r\nimport {Dashboard, Project} from './components';\r\nimport Storage from \"../data/storage\";\r\n\r\nimport {Menu, Item, Divisor} from './components/menu/Menu';\r\nimport { Cards, Card } from './components/cards/Cards';\r\nimport { Catalog } from './components/catalog/Catalog';\r\n\r\nimport colors from '../static/img/colors.png';\r\n\r\n\r\nfunction AllProjectsComponent(props: AllProps): JSX.Element {\r\n    const {projects} = props;\r\n\r\n    const reader = new FileReader();\r\n    reader.onload = async e => {\r\n        /* Import Project File */\r\n        const content = String(e.target?.result);\r\n        if(!content) return;\r\n        try {\r\n            const project = JSON.parse(content) as DProject;\r\n            const projects = Storage.read<DProject[]>('projects') || [];\r\n            const filtered = projects.filter(p => p.id !== project.id);\r\n            filtered.push(project);\r\n            Storage.write('projects', filtered);\r\n            U.resetState();\r\n        } catch (e) {alert('Invalid File.')}\r\n    }\r\n    \r\n    const importProject = async(e: ChangeEvent<HTMLInputElement>) => {\r\n        const files = e.target.files || [];\r\n        if(!files.length) return;\r\n        const file = files[0];\r\n        reader.readAsText(file);\r\n    }\r\n\r\n\r\n\r\n\r\n    return(<Try>\r\n        <Dashboard active={'Recent'} version={props.version}>\r\n            \r\n            <React.Fragment>                \r\n\r\n                <Cards>\r\n                    <Cards.Item\r\n                        title={'Need help?'} \r\n                        subtitle={'Don\\' ask Alexa, click here instead.'}\r\n                        icon={'alexa'} \r\n                        style={'red-orange'}   \r\n                    />\r\n                    {false && <Cards.Item icon={'question'} style={'clear'} title={'Ehy!'} subtitle={'What do you want to do today?'}/>}\r\n                </Cards>\r\n\r\n                <Catalog projects={projects} />\r\n            </React.Fragment>\r\n            \r\n        </Dashboard>\r\n    </Try>);\r\n}\r\n\r\ninterface OwnProps {}\r\ninterface StateProps {\r\n    projects: LProject[];\r\n    version: DState[\"version\"];\r\n}\r\ninterface DispatchProps {}\r\n\r\ntype AllProps = OwnProps & StateProps & DispatchProps;\r\n\r\n\r\nfunction mapStateToProps(state: DState, ownProps: OwnProps): StateProps {\r\n    const ret: StateProps = {} as FakeStateProps;\r\n    ret.projects = LProject.fromArr(state.projects);\r\n    ret.version = state.version;\r\n    return ret;\r\n}\r\n\r\nfunction mapDispatchToProps(dispatch: Dispatch<any>): DispatchProps {\r\n    const ret: DispatchProps = {};\r\n    return ret;\r\n}\r\n\r\nconst AllProjectsConnected = connect<StateProps, DispatchProps, OwnProps, DState>(\r\n    mapStateToProps,\r\n    mapDispatchToProps\r\n)(AllProjectsComponent);\r\n\r\nconst RecentPage = (props: OwnProps, children: (string | Component)[] = []): ReactElement => {\r\n    return <AllProjectsConnected {...{...props, children}} />;\r\n}\r\n\r\nexport {RecentPage};\r\n\r\n","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\pages\\UsersInfo.tsx",[],"C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\pages\\Templates.tsx",["1600","1601","1602","1603","1604","1605","1606","1607","1608","1609","1610","1611","1612","1613","1614","1615","1616","1617"],"import React, {ChangeEvent, MouseEventHandler, Component, Dispatch, ReactElement, useState, useRef } from 'react';\r\nimport {connect} from 'react-redux';\r\nimport {DProject, DState, LProject, Try, U} from '../joiner';\r\nimport {FakeStateProps} from '../joiner/types';\r\nimport {Dashboard, Project} from './components';\r\nimport Storage from \"../data/storage\";\r\n\r\nimport {Menu, Item, Divisor} from './components/menu/Menu';\r\n\r\nimport colors from '../static/img/colors.png';\r\nimport {CatalogInfoCard} from \"./components/catalog/Catalog\";\r\n\r\n\r\n\r\ntype CardsType = {\r\n    children: any;\r\n};\r\n\r\nconst Cards = (props: CardsType): any => {\r\n    return (\r\n        <React.Fragment>\r\n            <div className='row mb-5 commandbar'>\r\n                {props.children}\r\n            </div>\r\n        </React.Fragment>\r\n    );\r\n}\r\n\r\ntype CardType = {\r\n    icon: \"add\" | \"import\" | \"clone\" | \"question\";\r\n    style?: \"blue\" | \"red\" | \"dark\" | \"clear\" | \"rainbow\" | \"default\";\r\n    title: string;\r\n    subtitle: string;\r\n    action?: MouseEventHandler;\r\n    children?: JSX.Element[];\r\n};\r\n\r\nconst Card = (props: CardType) => {\r\n\r\n    const icons = {\r\n        add: \"bi-plus-circle\",\r\n        import: \"bi-box-arrow-in-up\",\r\n        question: \"bi-question-square\",\r\n        clone: \"bi-clipboard2-check\"\r\n    };\r\n\r\n    return (<>\r\n        <div className={`card ${props.style ? props.style : 'default' }`}>\r\n            <div className={'col icon'}>\r\n                {props.action ?\r\n                    <i onClick={props.action} className={`bi ${icons[props.icon]}`}></i> :\r\n                    <i className={`bi ${icons[props.icon]} disabled`}></i>\r\n                }\r\n            </div>\r\n            <div className={'col body'}>\r\n                <h5>{props.title}</h5>\r\n                {props.subtitle}\r\n            </div>\r\n        </div>\r\n        </>\r\n    );\r\n}\r\n\r\nCards.Item = Card;\r\n\r\ntype ChildrenType = {\r\n    projects?: any;\r\n    children?: JSX.Element[];\r\n};\r\n\r\n\r\n/* main component */\r\n\r\nconst Catalog = (props: ChildrenType) => {\r\n\r\n    const [filters, setFilters] = useState([false,false,false]);\r\n    const [mode, setMode] = useState<string>(\"cards\");\r\n\r\n    const Header = (props: ChildrenType) => {\r\n        return (\r\n            <div className='row catalog-header'>\r\n                {props.children}\r\n            </div>\r\n        );\r\n    }\r\n\r\n    const CatalogFilters = () => {\r\n\r\n        function toggleFilters(el: 0|1|2) {\r\n            switch(el) {\r\n                case 0:\r\n                    setFilters([!filters[0], filters[1], filters[2]]);\r\n                    break;\r\n                case 1:\r\n                    setFilters([filters[0], !filters[1], filters[2]]);\r\n                    break;\r\n                case 2:\r\n                    setFilters([filters[0], filters[1], !filters[2]]);\r\n                    break;\r\n            }\r\n        };\r\n\r\n        return (\r\n            <div className={'col left'}>\r\n                {filters[0] ? <button onClick={(e) => toggleFilters(0)} className='active'>public</button> : <button onClick={(e) => toggleFilters(0)}>public</button>}\r\n                {filters[1] ? <button onClick={(e) => toggleFilters(1)} className='active'>private</button> : <button onClick={(e) => toggleFilters(1)}>private</button>}\r\n                {filters[2] ? <button onClick={(e) => toggleFilters(2)} className='active'>collaborative</button> : <button onClick={(e) => toggleFilters(2)} >collaborative</button>}\r\n            </div>\r\n        );\r\n    }\r\n\r\n    const CatalogMode = () => { // unused component?\r\n        return (<>\r\n            <div className={'col left'}>\r\n                <div className=\"float-end\">sorted by\r\n                    <div className={'view-icons'}>\r\n                        <i onClick={(e) => setMode('cards')} className={`bi bi-grid ${mode === \"cards\" && 'selected'}`}></i>\r\n                        <i onClick={(e) => setMode('list')} className={`bi bi-list ${mode === \"list\" && 'selected'}`}></i>\r\n                    </div>\r\n                    <div style={{float: 'right'}}>\r\n                    <Menu position={'left'}>\r\n                        <Item action={(e)=> {alert('')}}>Alphabetical</Item>\r\n                        <Item>Date created</Item>\r\n                        <Item>Last modified</Item>\r\n                    </Menu>\r\n                    </div>\r\n                </div>\r\n            </div>\r\n        </>);\r\n    }\r\n\r\n    const CatalogSide = (props: ChildrenType) => {\r\n        return (\r\n            <div className={'catalog'}>\r\n                {props.children}\r\n            </div>\r\n        );\r\n    }\r\n\r\n\r\n    type CatalogType = {\r\n        projects: LProject[];\r\n    }\r\n\r\n    const CatalogReport = (props: CatalogType) =>{\r\n\r\n        let items_public: LProject[] = [];\r\n        let items_private: LProject[] = [];\r\n        let items_collaborative: LProject[] = [];\r\n\r\n\r\n        if (filters[0]) {\r\n            items_public = props.projects.filter(p => p.type === \"public\");\r\n        }\r\n        if (filters[1]) {\r\n            items_private = props.projects.filter(p => p.type === \"private\");\r\n        }\r\n        if (filters[2]) {\r\n            items_collaborative = props.projects.filter(p => p.type === \"collaborative\");\r\n        }\r\n\r\n        //var items  = items_public.concat(items_private,items_collaborative);\r\n\r\n        var items = props.projects.filter(p =>\r\n            (filters[0] && p.type ===\"public\" || filters[1] && p.type ===\"private\" || filters[2] && p.type ===\"collaborative\" || !filters[0] && !filters[1] && !filters[2]));\r\n\r\n        return (\r\n\r\n            mode == \"cards\" ?\r\n\r\n            <div style={{display: (items.length > 0) ? 'flex' : 'flex'}} className={'flex-wrap'} >\r\n\r\n                {items.length === 0 && <div>Sorry, there are no results matching your search criteria. Please try again with different filters.</div>}\r\n\r\n                {\r\n                    props.projects.map(p => <>\r\n                        {filters[0] && p.type === \"public\" && <Project key={p.id} data={p} mode={mode} />}\r\n                        {filters[1] && p.type === \"private\" && <Project key={p.id} data={p} mode={mode} />}\r\n                        {filters[2] && p.type === \"collaborative\" && <Project key={p.id} data={p} mode={mode} />}\r\n                        {!filters[0] && !filters[1] && !filters[2] && <Project key={p.id} data={p} mode={mode} />}\r\n                    </>)\r\n                }\r\n\r\n            </div>\r\n\r\n            :\r\n            <div className={'row project-list'}>\r\n                <div className='row header'>\r\n                    <div className={'col-6'}>Name</div><div className={'col-3'}>Last modified</div><div className={'col-3'}>Created</div>\r\n                </div>\r\n                {\r\n                    props.projects.map(p => <>\r\n                        {filters[0] && p.type === \"public\" && <Project key={p.id} data={p} mode={mode} />}\r\n                        {filters[1] && p.type === \"private\" && <Project key={p.id} data={p} mode={mode} />}\r\n                        {filters[2] && p.type === \"collaborative\" && <Project key={p.id} data={p} mode={mode} />}\r\n                        {!filters[0] && !filters[1] && !filters[2] && <Project key={p.id} data={p} mode={mode} />}\r\n                    </>)\r\n                }\r\n            </div>\r\n\r\n        );\r\n    };\r\n\r\n    return (\r\n        <div>\r\n            <Header>\r\n                <CatalogFilters/>\r\n                <CatalogMode/>\r\n            </Header>\r\n            <CatalogSide>\r\n                <CatalogInfoCard projects={props.projects}/>\r\n                <CatalogReport projects={props.projects}/>\r\n            </CatalogSide>\r\n        </div>\r\n    );\r\n}\r\n\r\nfunction AllProjectsComponent(props: AllProps): JSX.Element {\r\n    const {projects} = props;\r\n\r\n    const reader = new FileReader();\r\n    reader.onload = async e => {\r\n        /* Import Project File */\r\n        const content = String(e.target?.result);\r\n        if(!content) return;\r\n        try {\r\n            const project = JSON.parse(content) as DProject;\r\n            const projects = Storage.read<DProject[]>('projects') || [];\r\n            const filtered = projects.filter(p => p.id !== project.id);\r\n            filtered.push(project);\r\n            Storage.write('projects', filtered);\r\n            U.resetState();\r\n        } catch (e) {alert('Invalid File.')}\r\n    }\r\n\r\n    const importProject = async(e: ChangeEvent<HTMLInputElement>) => {\r\n        const files = e.target.files || [];\r\n        if(!files.length) return;\r\n        const file = files[0];\r\n        reader.readAsText(file);\r\n    }\r\n\r\n\r\n\r\n\r\n    return(<Try>\r\n        <Dashboard active={'Templates'} version={props.version}>\r\n\r\n            <React.Fragment>\r\n\r\n                <Cards>\r\n                    <Cards.Item\r\n                        title={'Clone a template'}\r\n                        subtitle={'Clone a template in your workspace.'}\r\n                        icon={'clone'}\r\n                        style={'rainbow'}\r\n                    />\r\n                    {true && <Cards.Item icon={'question'} style={'clear'} title={'Ehy!'} subtitle={'What do you want to do today?'}/>}\r\n                    \r\n                </Cards>\r\n\r\n                <Catalog projects={projects} />\r\n            </React.Fragment>\r\n\r\n        </Dashboard>\r\n    </Try>);\r\n}\r\n\r\ninterface OwnProps {}\r\ninterface StateProps {\r\n    projects: LProject[];\r\n    version: DState[\"version\"];\r\n}\r\ninterface DispatchProps {}\r\n\r\ntype AllProps = OwnProps & StateProps & DispatchProps;\r\n\r\n\r\nfunction mapStateToProps(state: DState, ownProps: OwnProps): StateProps {\r\n    const ret: StateProps = {} as FakeStateProps;\r\n    ret.projects = LProject.fromArr(state.projects);\r\n    ret.version = state.version;\r\n    return ret;\r\n}\r\n\r\nfunction mapDispatchToProps(dispatch: Dispatch<any>): DispatchProps {\r\n    const ret: DispatchProps = {};\r\n    return ret;\r\n}\r\n\r\nconst AllProjectsConnected = connect<StateProps, DispatchProps, OwnProps, DState>(\r\n    mapStateToProps,\r\n    mapDispatchToProps\r\n)(AllProjectsComponent);\r\n\r\nconst TemplatePage = (props: OwnProps, children: (string | Component)[] = []): ReactElement => {\r\n    return <AllProjectsConnected {...{...props, children}} />;\r\n}\r\n\r\nexport {TemplatePage};\r\n\r\n","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\pages\\Auth.tsx",["1618"],"import {FormEvent} from 'react';\r\nimport {useStateIfMounted} from 'use-state-if-mounted';\r\nimport {DUser, R, SetRootFieldAction, U} from '../joiner';\r\nimport Storage from '../data/storage';\r\nimport {AuthApi} from \"../api/persistance\";\r\nimport logo from '../static/img/jjodel.jpg';\r\nimport {Tooltip} from '../components/forEndUser/Tooltip';\r\nimport { RegisterRequest } from '../api/DTO/RegisterRequest';\r\nimport { LoginRequest } from '../api/DTO/LoginRequest';\r\nimport { TokenResponse } from '../api/DTO/TokenResponse';\r\nimport {ResetPasswordRequest} from \"../api/DTO/ResetPasswordRequest\";\r\n\r\n\r\nfunction AuthPage(): JSX.Element {\r\n\r\n    const [action, setAction] = useStateIfMounted<'login'|'register'|'retrieve-password'>('login');\r\n\r\n    const [nickname, setNickname] = useStateIfMounted('');\r\n    const [name, setName] = useStateIfMounted('');\r\n    const [surname, setSurname] = useStateIfMounted('');\r\n    const [affiliation, setAffiliation] = useStateIfMounted('');\r\n    const [country, setCountry] = useStateIfMounted('Italy');\r\n    const [email, setEmail] = useStateIfMounted('');\r\n    const [password, setPassword] = useStateIfMounted('');\r\n    const [passwordCheck, setPasswordCheck] = useStateIfMounted('');\r\n    const [newsletter, setNewsletter] = useStateIfMounted(false);\r\n\r\n\r\n    const onSubmit = async(e: FormEvent<HTMLFormElement>) => {\r\n        e.preventDefault();\r\n        SetRootFieldAction.new('isLoading', true);\r\n\r\n        switch (action) {\r\n            case 'login':\r\n                await login();\r\n                break;\r\n            case 'register':\r\n                await register();\r\n                break;\r\n            case 'retrieve-password':\r\n                await reset_password();\r\n                break;\r\n        }\r\n\r\n        SetRootFieldAction.new('isLoading', false);\r\n    }\r\n\r\n\r\n\r\n    const reset_password = async () => {\r\n\r\n\r\n        try {\r\n            const resetPasswordRequest = new ResetPasswordRequest();\r\n\r\n            resetPasswordRequest.email = email;\r\n            const response = await AuthApi.reset_password(resetPasswordRequest);\r\n\r\n            if (response.code === 200) {\r\n                console.log(\"Ti abbiamo inviato una mail per il reset della password.\");\r\n            }\r\n\r\n        } catch (e) {\r\n            console.error(\"Errore nella richiesta:\", e);\r\n            alert(\"Errore imprevisto.\");\r\n\r\n        }\r\n    }\r\n\r\n    const login   = async () => {\r\n        try {\r\n          const loginRequest   = new LoginRequest();\r\n          loginRequest.email = email;\r\n          loginRequest.password = password;\r\n\r\n          const response = await AuthApi.login(loginRequest);\r\n          const raw: TokenResponse | null = response.data;\r\n\r\n\r\n          if (response.code !== 200 || !raw?.token || typeof raw.token !== 'string') {\r\n            U.alert('e', 'Login failed or invalid token.', '');\r\n            return;\r\n          }\r\n\r\n          const claims = AuthApi.readJwtToken(raw.token);\r\n          if (!claims) {\r\n            U.alert('e', 'Invalid token.', '');\r\n            return;\r\n          }\r\n\r\n          const user : DUser = DUser.new(claims.name, '', claims.nickname, '',  '', false, claims.email,  raw.token, claims.id,  true);\r\n\r\n          AuthApi.storeSessionData(raw.token, !claims.exp ? 0 : claims.exp, user);\r\n          U.resetState();\r\n          R.navigate('/allProjects');\r\n\r\n        } catch (e) {\r\n          console.error(\"Login error:\");\r\n          U.alert('e', 'Unexpected error during login.', '');\r\n        }\r\n      };\r\n\r\n    const register = async() => {\r\n   \r\n\r\n        if (password !== passwordCheck) {\r\n            U.alert('e', 'The two passwords are different','');\r\n            return;\r\n        }\r\n        const registerRequest : RegisterRequest = new RegisterRequest();\r\n        registerRequest.Name = name;\r\n        registerRequest.Surname = surname;\r\n        registerRequest.Country = country;\r\n        registerRequest.Affiliation = affiliation;\r\n        registerRequest.NewsletterEnabled = newsletter;\r\n        registerRequest.Nickname = nickname;\r\n        registerRequest.Email = email;\r\n        registerRequest.Password = password;\r\n        console.log(registerRequest);\r\n        const response = await AuthApi.register(registerRequest);\r\n\r\n        if (response.code !== 200) {\r\n            U.alert('e', 'Registration failed.', '');\r\n            return;\r\n        }\r\n        const data = U.wrapper<DUser>(response.data);\r\n        Storage.write('token', data.token);\r\n        const user = DUser.new(data.name, data.surname, data.nickname, data.affiliation, data.country, data.newsletter || false, data.email, data.token, data.id);\r\n        Storage.write('user', user);\r\n        Storage.write('offline', false);\r\n        R.navigate('/allProjects');\r\n        U.resetState();\r\n    }\r\n\r\n    const offline = () => {\r\n        AuthApi.offline();\r\n        R.navigate('/allProjects');\r\n        U.resetState();\r\n    }\r\n\r\n    return(<section className={`w-100 h-100 login bg ${action === 'register' ? 'register' : action === 'retrieve-password' && 'retrieve' } `}>\r\n\r\n        <form className={'d-block bg-white rounded border mx-auto w-fit px-5 py-4 mt-5'} onSubmit={onSubmit}>\r\n            <label className={'fs-1 d-block text-center text-primary login-header'}>\r\n\r\n                {action === 'register' && 'Create an Account'}\r\n                {action === 'login' && 'Sign In'}\r\n                {action === 'retrieve-password' && 'Retrieve your Password'}\r\n\r\n\r\n            </label>\r\n\r\n            {action === 'register' && <>\r\n\r\n                {/* REGISTRATION */}\r\n\r\n                <Tooltip tooltip={<div style={{padding: '10px', maxWidth: '600px'}}><h6>First Name</h6>Your first name will be visible to others whenever you interact with them, such as during collaboration on shared projects.</div>} >\r\n                    <label>\r\n                        First Name\r\n                        <input className={'w-100 input w-fit d-block mx-auto mt-2'}\r\n                            placeholder={'john'}\r\n                            value={name}\r\n                            onChange={e => setName(e.target.value)}\r\n                            type={'text'} required={true}\r\n                        />\r\n                    </label>\r\n                </Tooltip>\r\n\r\n                <Tooltip tooltip={<div style={{padding: '10px', maxWidth: '600px'}}><h6>Last Name</h6>Your last name will be visible to others whenever you interact with them, such as during collaboration on shared projects.</div>} >\r\n                    <label>\r\n                        Last Name\r\n                        <input className={'w-100 input w-fit d-block mx-auto mt-2'}\r\n                               placeholder={'doe'}\r\n                               value={surname}\r\n                               onChange={e => setSurname(e.target.value)}\r\n                               type={'text'} required={true}\r\n                        />\r\n                    </label>\r\n                </Tooltip>\r\n\r\n                    <Tooltip tooltip={<div style={{padding: '10px', maxWidth: '600px'}}><h6>Nickname</h6>Your nickname will be visible to others whenever you interact with them, such as during collaboration on shared projects.</div>} >\r\n                        <label>\r\n                            Nickname\r\n                            <input className={'w-100 input w-fit d-block mx-auto mt-2'}\r\n                                   placeholder={''}\r\n                                   value={nickname}\r\n                                   onChange={e => setNickname(e.target.value)}\r\n                                   type={'text'} required={true}\r\n                            />\r\n                        </label>\r\n                    </Tooltip>\r\n\r\n                <Tooltip tooltip={<div style={{padding: '10px', maxWidth: '600px'}}><h6>Affiliation</h6>Your affiliation refers to the organization, institution, or company you’re associated with, will be displayed in relevant contexts like project collaborations or professional interactions, and will help us keep track of where jjodel is being used.</div>} ><label>\r\n                    Affiliation\r\n                    <input className={'w-100 input w-fit d-block mx-auto mt-2'}\r\n                        placeholder={'eg: univaq'}\r\n                        value={affiliation}\r\n                        onChange={e => setAffiliation(e.target.value)}\r\n                        type={'text'} required={false}\r\n                    />\r\n                    </label>\r\n                </Tooltip>\r\n                <label>\r\n                    <label>Country</label>\r\n                    <select className={\"form-control\"} defaultValue={country} onChange={e => setCountry(e.target.value)}>\r\n                        <option value=\"Afghanistan\">Afghanistan</option>\r\n                        <option value=\"Åland Islands\">Åland Islands</option>\r\n                        <option value=\"Albania\">Albania</option>\r\n                        <option value=\"Algeria\">Algeria</option>\r\n                        <option value=\"American Samoa\">American Samoa</option>\r\n                        <option value=\"Andorra\">Andorra</option>\r\n                        <option value=\"Angola\">Angola</option>\r\n                        <option value=\"Anguilla\">Anguilla</option>\r\n                        <option value=\"Antarctica\">Antarctica</option>\r\n                        <option value=\"Antigua and Barbuda\">Antigua and Barbuda</option>\r\n                        <option value=\"Argentina\">Argentina</option>\r\n                        <option value=\"Armenia\">Armenia</option>\r\n                        <option value=\"Aruba\">Aruba</option>\r\n                        <option value=\"Australia\">Australia</option>\r\n                        <option value=\"Austria\">Austria</option>\r\n                        <option value=\"Azerbaijan\">Azerbaijan</option>\r\n                        <option value=\"Bahamas\">Bahamas</option>\r\n                        <option value=\"Bahrain\">Bahrain</option>\r\n                        <option value=\"Bangladesh\">Bangladesh</option>\r\n                        <option value=\"Barbados\">Barbados</option>\r\n                        <option value=\"Belarus\">Belarus</option>\r\n                        <option value=\"Belgium\">Belgium</option>\r\n                        <option value=\"Belize\">Belize</option>\r\n                        <option value=\"Benin\">Benin</option>\r\n                        <option value=\"Bermuda\">Bermuda</option>\r\n                        <option value=\"Bhutan\">Bhutan</option>\r\n                        <option value=\"Bolivia\">Bolivia</option>\r\n                        <option value=\"Bosnia and Herzegovina\">Bosnia and Herzegovina</option>\r\n                        <option value=\"Botswana\">Botswana</option>\r\n                        <option value=\"Bouvet Island\">Bouvet Island</option>\r\n                        <option value=\"Brazil\">Brazil</option>\r\n                        <option value=\"British Indian Ocean Territory\">British Indian Ocean Territory</option>\r\n                        <option value=\"Brunei Darussalam\">Brunei Darussalam</option>\r\n                        <option value=\"Bulgaria\">Bulgaria</option>\r\n                        <option value=\"Burkina Faso\">Burkina Faso</option>\r\n                        <option value=\"Burundi\">Burundi</option>\r\n                        <option value=\"Cambodia\">Cambodia</option>\r\n                        <option value=\"Cameroon\">Cameroon</option>\r\n                        <option value=\"Canada\">Canada</option>\r\n                        <option value=\"Cape Verde\">Cape Verde</option>\r\n                        <option value=\"Cayman Islands\">Cayman Islands</option>\r\n                        <option value=\"Central African Republic\">Central African Republic</option>\r\n                        <option value=\"Chad\">Chad</option>\r\n                        <option value=\"Chile\">Chile</option>\r\n                        <option value=\"China\">China</option>\r\n                        <option value=\"Christmas Island\">Christmas Island</option>\r\n                        <option value=\"Cocos (Keeling) Islands\">Cocos (Keeling) Islands</option>\r\n                        <option value=\"Colombia\">Colombia</option>\r\n                        <option value=\"Comoros\">Comoros</option>\r\n                        <option value=\"Congo\">Congo</option>\r\n                        <option value=\"Congo, The Democratic Republic of The\">Congo, The Democratic Republic of The</option>\r\n                        <option value=\"Cook Islands\">Cook Islands</option>\r\n                        <option value=\"Costa Rica\">Costa Rica</option>\r\n                        <option value=\"Cote D'ivoire\">Cote D'ivoire</option>\r\n                        <option value=\"Croatia\">Croatia</option>\r\n                        <option value=\"Cuba\">Cuba</option>\r\n                        <option value=\"Cyprus\">Cyprus</option>\r\n                        <option value=\"Czech Republic\">Czech Republic</option>\r\n                        <option value=\"Denmark\">Denmark</option>\r\n                        <option value=\"Djibouti\">Djibouti</option>\r\n                        <option value=\"Dominica\">Dominica</option>\r\n                        <option value=\"Dominican Republic\">Dominican Republic</option>\r\n                        <option value=\"Ecuador\">Ecuador</option>\r\n                        <option value=\"Egypt\">Egypt</option>\r\n                        <option value=\"El Salvador\">El Salvador</option>\r\n                        <option value=\"Equatorial Guinea\">Equatorial Guinea</option>\r\n                        <option value=\"Eritrea\">Eritrea</option>\r\n                        <option value=\"Estonia\">Estonia</option>\r\n                        <option value=\"Ethiopia\">Ethiopia</option>\r\n                        <option value=\"Falkland Islands (Malvinas)\">Falkland Islands (Malvinas)</option>\r\n                        <option value=\"Faroe Islands\">Faroe Islands</option>\r\n                        <option value=\"Fiji\">Fiji</option>\r\n                        <option value=\"Finland\">Finland</option>\r\n                        <option value=\"France\">France</option>\r\n                        <option value=\"French Guiana\">French Guiana</option>\r\n                        <option value=\"French Polynesia\">French Polynesia</option>\r\n                        <option value=\"French Southern Territories\">French Southern Territories</option>\r\n                        <option value=\"Gabon\">Gabon</option>\r\n                        <option value=\"Gambia\">Gambia</option>\r\n                        <option value=\"Georgia\">Georgia</option>\r\n                        <option value=\"Germany\">Germany</option>\r\n                        <option value=\"Ghana\">Ghana</option>\r\n                        <option value=\"Gibraltar\">Gibraltar</option>\r\n                        <option value=\"Greece\">Greece</option>\r\n                        <option value=\"Greenland\">Greenland</option>\r\n                        <option value=\"Grenada\">Grenada</option>\r\n                        <option value=\"Guadeloupe\">Guadeloupe</option>\r\n                        <option value=\"Guam\">Guam</option>\r\n                        <option value=\"Guatemala\">Guatemala</option>\r\n                        <option value=\"Guernsey\">Guernsey</option>\r\n                        <option value=\"Guinea\">Guinea</option>\r\n                        <option value=\"Guinea-bissau\">Guinea-bissau</option>\r\n                        <option value=\"Guyana\">Guyana</option>\r\n                        <option value=\"Haiti\">Haiti</option>\r\n                        <option value=\"Heard Island and Mcdonald Islands\">Heard Island and Mcdonald Islands</option>\r\n                        <option value=\"Holy See (Vatican City State)\">Holy See (Vatican City State)</option>\r\n                        <option value=\"Honduras\">Honduras</option>\r\n                        <option value=\"Hong Kong\">Hong Kong</option>\r\n                        <option value=\"Hungary\">Hungary</option>\r\n                        <option value=\"Iceland\">Iceland</option>\r\n                        <option value=\"India\">India</option>\r\n                        <option value=\"Indonesia\">Indonesia</option>\r\n                        <option value=\"Iran, Islamic Republic of\">Iran, Islamic Republic of</option>\r\n                        <option value=\"Iraq\">Iraq</option>\r\n                        <option value=\"Ireland\">Ireland</option>\r\n                        <option value=\"Isle of Man\">Isle of Man</option>\r\n                        <option value=\"Israel\">Israel</option>\r\n                        <option value=\"Italy\">Italy</option>\r\n                        <option value=\"Jamaica\">Jamaica</option>\r\n                        <option value=\"Japan\">Japan</option>\r\n                        <option value=\"Jersey\">Jersey</option>\r\n                        <option value=\"Jordan\">Jordan</option>\r\n                        <option value=\"Kazakhstan\">Kazakhstan</option>\r\n                        <option value=\"Kenya\">Kenya</option>\r\n                        <option value=\"Kiribati\">Kiribati</option>\r\n                        <option value=\"Korea, Democratic People's Republic of\">Korea, Democratic People's Republic of</option>\r\n                        <option value=\"Korea, Republic of\">Korea, Republic of</option>\r\n                        <option value=\"Kuwait\">Kuwait</option>\r\n                        <option value=\"Kyrgyzstan\">Kyrgyzstan</option>\r\n                        <option value=\"Lao People's Democratic Republic\">Lao People's Democratic Republic</option>\r\n                        <option value=\"Latvia\">Latvia</option>\r\n                        <option value=\"Lebanon\">Lebanon</option>\r\n                        <option value=\"Lesotho\">Lesotho</option>\r\n                        <option value=\"Liberia\">Liberia</option>\r\n                        <option value=\"Libyan Arab Jamahiriya\">Libyan Arab Jamahiriya</option>\r\n                        <option value=\"Liechtenstein\">Liechtenstein</option>\r\n                        <option value=\"Lithuania\">Lithuania</option>\r\n                        <option value=\"Luxembourg\">Luxembourg</option>\r\n                        <option value=\"Macao\">Macao</option>\r\n                        <option value=\"Macedonia, The Former Yugoslav Republic of\">Macedonia, The Former Yugoslav Republic of</option>\r\n                        <option value=\"Madagascar\">Madagascar</option>\r\n                        <option value=\"Malawi\">Malawi</option>\r\n                        <option value=\"Malaysia\">Malaysia</option>\r\n                        <option value=\"Maldives\">Maldives</option>\r\n                        <option value=\"Mali\">Mali</option>\r\n                        <option value=\"Malta\">Malta</option>\r\n                        <option value=\"Marshall Islands\">Marshall Islands</option>\r\n                        <option value=\"Martinique\">Martinique</option>\r\n                        <option value=\"Mauritania\">Mauritania</option>\r\n                        <option value=\"Mauritius\">Mauritius</option>\r\n                        <option value=\"Mayotte\">Mayotte</option>\r\n                        <option value=\"Mexico\">Mexico</option>\r\n                        <option value=\"Micronesia, Federated States of\">Micronesia, Federated States of</option>\r\n                        <option value=\"Moldova, Republic of\">Moldova, Republic of</option>\r\n                        <option value=\"Monaco\">Monaco</option>\r\n                        <option value=\"Mongolia\">Mongolia</option>\r\n                        <option value=\"Montenegro\">Montenegro</option>\r\n                        <option value=\"Montserrat\">Montserrat</option>\r\n                        <option value=\"Morocco\">Morocco</option>\r\n                        <option value=\"Mozambique\">Mozambique</option>\r\n                        <option value=\"Myanmar\">Myanmar</option>\r\n                        <option value=\"Namibia\">Namibia</option>\r\n                        <option value=\"Nauru\">Nauru</option>\r\n                        <option value=\"Nepal\">Nepal</option>\r\n                        <option value=\"Netherlands\">Netherlands</option>\r\n                        <option value=\"Netherlands Antilles\">Netherlands Antilles</option>\r\n                        <option value=\"New Caledonia\">New Caledonia</option>\r\n                        <option value=\"New Zealand\">New Zealand</option>\r\n                        <option value=\"Nicaragua\">Nicaragua</option>\r\n                        <option value=\"Niger\">Niger</option>\r\n                        <option value=\"Nigeria\">Nigeria</option>\r\n                        <option value=\"Niue\">Niue</option>\r\n                        <option value=\"Norfolk Island\">Norfolk Island</option>\r\n                        <option value=\"Northern Mariana Islands\">Northern Mariana Islands</option>\r\n                        <option value=\"Norway\">Norway</option>\r\n                        <option value=\"Oman\">Oman</option>\r\n                        <option value=\"Pakistan\">Pakistan</option>\r\n                        <option value=\"Palau\">Palau</option>\r\n                        <option value=\"Palestinian Territory, Occupied\">Palestinian Territory, Occupied</option>\r\n                        <option value=\"Panama\">Panama</option>\r\n                        <option value=\"Papua New Guinea\">Papua New Guinea</option>\r\n                        <option value=\"Paraguay\">Paraguay</option>\r\n                        <option value=\"Peru\">Peru</option>\r\n                        <option value=\"Philippines\">Philippines</option>\r\n                        <option value=\"Pitcairn\">Pitcairn</option>\r\n                        <option value=\"Poland\">Poland</option>\r\n                        <option value=\"Portugal\">Portugal</option>\r\n                        <option value=\"Puerto Rico\">Puerto Rico</option>\r\n                        <option value=\"Qatar\">Qatar</option>\r\n                        <option value=\"Reunion\">Reunion</option>\r\n                        <option value=\"Romania\">Romania</option>\r\n                        <option value=\"Russian Federation\">Russian Federation</option>\r\n                        <option value=\"Rwanda\">Rwanda</option>\r\n                        <option value=\"Saint Helena\">Saint Helena</option>\r\n                        <option value=\"Saint Kitts and Nevis\">Saint Kitts and Nevis</option>\r\n                        <option value=\"Saint Lucia\">Saint Lucia</option>\r\n                        <option value=\"Saint Pierre and Miquelon\">Saint Pierre and Miquelon</option>\r\n                        <option value=\"Saint Vincent and The Grenadines\">Saint Vincent and The Grenadines</option>\r\n                        <option value=\"Samoa\">Samoa</option>\r\n                        <option value=\"San Marino\">San Marino</option>\r\n                        <option value=\"Sao Tome and Principe\">Sao Tome and Principe</option>\r\n                        <option value=\"Saudi Arabia\">Saudi Arabia</option>\r\n                        <option value=\"Senegal\">Senegal</option>\r\n                        <option value=\"Serbia\">Serbia</option>\r\n                        <option value=\"Seychelles\">Seychelles</option>\r\n                        <option value=\"Sierra Leone\">Sierra Leone</option>\r\n                        <option value=\"Singapore\">Singapore</option>\r\n                        <option value=\"Slovakia\">Slovakia</option>\r\n                        <option value=\"Slovenia\">Slovenia</option>\r\n                        <option value=\"Solomon Islands\">Solomon Islands</option>\r\n                        <option value=\"Somalia\">Somalia</option>\r\n                        <option value=\"South Africa\">South Africa</option>\r\n                        <option value=\"South Georgia and The South Sandwich Islands\">South Georgia and The South Sandwich Islands</option>\r\n                        <option value=\"Spain\">Spain</option>\r\n                        <option value=\"Sri Lanka\">Sri Lanka</option>\r\n                        <option value=\"Sudan\">Sudan</option>\r\n                        <option value=\"Suriname\">Suriname</option>\r\n                        <option value=\"Svalbard and Jan Mayen\">Svalbard and Jan Mayen</option>\r\n                        <option value=\"Swaziland\">Swaziland</option>\r\n                        <option value=\"Sweden\">Sweden</option>\r\n                        <option value=\"Switzerland\">Switzerland</option>\r\n                        <option value=\"Syrian Arab Republic\">Syrian Arab Republic</option>\r\n                        <option value=\"Taiwan\">Taiwan</option>\r\n                        <option value=\"Tajikistan\">Tajikistan</option>\r\n                        <option value=\"Tanzania, United Republic of\">Tanzania, United Republic of</option>\r\n                        <option value=\"Thailand\">Thailand</option>\r\n                        <option value=\"Timor-leste\">Timor-leste</option>\r\n                        <option value=\"Togo\">Togo</option>\r\n                        <option value=\"Tokelau\">Tokelau</option>\r\n                        <option value=\"Tonga\">Tonga</option>\r\n                        <option value=\"Trinidad and Tobago\">Trinidad and Tobago</option>\r\n                        <option value=\"Tunisia\">Tunisia</option>\r\n                        <option value=\"Turkey\">Turkey</option>\r\n                        <option value=\"Turkmenistan\">Turkmenistan</option>\r\n                        <option value=\"Turks and Caicos Islands\">Turks and Caicos Islands</option>\r\n                        <option value=\"Tuvalu\">Tuvalu</option>\r\n                        <option value=\"Uganda\">Uganda</option>\r\n                        <option value=\"Ukraine\">Ukraine</option>\r\n                        <option value=\"United Arab Emirates\">United Arab Emirates</option>\r\n                        <option value=\"United Kingdom\">United Kingdom</option>\r\n                        <option value=\"United States\">United States</option>\r\n                        <option value=\"United States Minor Outlying Islands\">United States Minor Outlying Islands</option>\r\n                        <option value=\"Uruguay\">Uruguay</option>\r\n                        <option value=\"Uzbekistan\">Uzbekistan</option>\r\n                        <option value=\"Vanuatu\">Vanuatu</option>\r\n                        <option value=\"Venezuela\">Venezuela</option>\r\n                        <option value=\"Viet Nam\">Viet Nam</option>\r\n                        <option value=\"Virgin Islands, British\">Virgin Islands, British</option>\r\n                        <option value=\"Virgin Islands, U.S.\">Virgin Islands, U.S.</option>\r\n                        <option value=\"Wallis and Futuna\">Wallis and Futuna</option>\r\n                        <option value=\"Western Sahara\">Western Sahara</option>\r\n                        <option value=\"Yemen\">Yemen</option>\r\n                        <option value=\"Zambia\">Zambia</option>\r\n                        <option value=\"Zimbabwe\">Zimbabwe</option>\r\n                    </select>\r\n                </label>\r\n                <Tooltip tooltip={<div style={{padding: '10px', maxWidth: '600px'}}><h6>Email</h6>Your email address will be used for communication, notifications, and to identify you in the system, but it won’t be shared publicly without your consent.</div>} >\r\n                    <label>\r\n                        Email\r\n                        <input className={'w-100 input w-fit d-block mx-auto mt-2'}\r\n                            placeholder={'johndoe@mail.com'}\r\n                            value={email}\r\n                            onChange={e => setEmail(e.target.value)}\r\n                            type={'email'} name='email' autoComplete={'on'} required={true}\r\n                        />\r\n                    </label>\r\n                </Tooltip>\r\n                <br /><br /><br />\r\n                <label>\r\n                    Password\r\n                    <input className={'w-100 input w-fit d-block mx-auto mt-2'}\r\n                        placeholder={'password'}\r\n                        value={password}\r\n                        onChange={e => setPassword(e.target.value)}\r\n                        type={'password'} required={true}\r\n                    />\r\n                </label>\r\n\r\n\r\n                <label>\r\n                    Confirm Password\r\n                    <input className={'w-100 input w-fit d-block mx-auto mt-2'}\r\n                        placeholder={'confirm password'}\r\n                        value={passwordCheck}\r\n                        onChange={e => setPasswordCheck(e.target.value)}\r\n                        type={'password'} required={true}\r\n                    />\r\n                </label>\r\n\r\n                <br /><br /><br />\r\n                <Tooltip tooltip={<div style={{padding: '10px', maxWidth: '600px'}}><h6>Newsletter</h6>Select this option for remaining updated about Jjodel new releases, updates, and initiatives.</div>} >\r\n                    <label>\r\n                        <input className={'checkbox'}\r\n                            placeholder={'newsletter'}\r\n                            checked={newsletter}\r\n                            onChange={e => setNewsletter(e.target.checked)}\r\n                            type={'checkbox'}\r\n                            style={{outline: 'none', marginTop: '10px', float: 'left'}}\r\n                        />\r\n                        <div style={{display: 'block', width: '90%', float: 'left', marginBottom: '10px', paddingLeft: '10px'}}>Newsletter. Subscribe to the newsletter to receive updates and news. You can manage your registration preferences at any time. </div>\r\n                    </label>\r\n\r\n                </Tooltip>\r\n                <br />\r\n                <div style={{width: '100%', textAlign: 'center'}}>\r\n                    By proceeding you accept the terms and conditions.\r\n                </div>\r\n                <button className={'d-block btn btn-primary p-1 mx-auto mt-3 login-button'} type={'submit'}>\r\n                    Create\r\n                </button>\r\n            </>}\r\n\r\n            {action === 'login' &&\r\n\r\n            <>\r\n                {/* LOGIN */}\r\n                <label>\r\n                    Email\r\n                    <input className={'w-100 input w-fit d-block mx-auto mt-3'}\r\n                        placeholder={'e-mail'}\r\n                        value={email}\r\n                        onChange={e => setEmail(e.target.value)} type={'email'}\r\n                        required={true}\r\n                    />\r\n                </label>\r\n                <label>\r\n                    Password\r\n                    <input className={'w-100 input w-fit d-block mx-auto  mt-2'}\r\n                        placeholder={'password'}\r\n                        value={password}\r\n                        onChange={e => setPassword(e.target.value)}\r\n                        type={'password'}\r\n                        required={true}\r\n                />\r\n                </label>\r\n                <button className={'d-block btn btn-primary p-1 mx-auto mt-3 login-button'} type={'submit'}>\r\n                    Login\r\n                </button>\r\n                {(true || window.location.host.includes('localhost')) &&\r\n                    <button className={'d-block btn btn-primary p-1 mx-auto mt-3 login-button'} onClick={(e) => offline()}>Offline mode</button>\r\n                }\r\n            </>}\r\n\r\n            {action === 'retrieve-password' &&\r\n\r\n            <>\r\n                {/* RETRIEVE PASSWORD */}\r\n                <label>\r\n                    Enter your email\r\n                    <input className={'w-100 input w-fit d-block mx-auto mt-3'}\r\n                        placeholder={'e-mail'}\r\n                        value={email}\r\n                        onChange={e => setEmail(e.target.value)} type={'email'}\r\n                        required={true}\r\n                    />\r\n                </label>\r\n\r\n                <button className={'d-block btn btn-primary p-1 mx-auto mt-3 login-button'} type={'submit'}>\r\n                    Retrieve\r\n                </button>\r\n            </>}\r\n\r\n\r\n            <label className={'mt-3 d-block text-center'}>\r\n                {action === 'register' && <>Already have an account? <span tabIndex={-1} onClick={e => {setAction('login')}} className={'ms-1 text-primary text-decoration-none cursor-pointer login-link'}>Sign In</span></>}\r\n                {action === 'login' &&\r\n                    <>\r\n                        Don't have an account? <span tabIndex={-1} onClick={e => {setAction('register')}} className={'ms-1 text-primary text-decoration-none cursor-pointer login-link'}>Register</span><br/>\r\n                        <span tabIndex={-1} onClick={e => {setAction('retrieve-password')}} className={'ms-1 text-primary text-decoration-none cursor-pointer login-link'}>Forgot your password?</span>\r\n                    </>\r\n                }\r\n                {action === 'retrieve-password' &&\r\n                    <>\r\n                        Go back to the <span tabIndex={-1} onClick={e => {setAction('login')}} className={'ms-1 text-primary text-decoration-none cursor-pointer login-link'}>Sign In</span> page<br/>\r\n                        Don't have an account? <span tabIndex={-1} onClick={e => {setAction('register')}} className={'ms-1 text-primary text-decoration-none cursor-pointer login-link'}>Register</span><br/>\r\n                    </>\r\n                }\r\n\r\n            </label>\r\n            <div className='login-logo'><img src={logo}></img></div>\r\n        </form>\r\n    </section>);\r\n}\r\n\r\nexport {AuthPage};\r\n","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\pages\\ConfirmAccount.tsx",["1619"],"import {useNavigate, useParams} from \"react-router-dom\";\r\nimport {AuthApi} from \"../api/persistance\";\r\nimport {ConfirmAccountRequest} from \"../api/DTO/ConfirmAccountRequest\";\r\nimport {useEffect, useState} from \"react\";\r\n\r\n\r\nfunction ConfirmAccount() {\r\n    const { id, token } = useParams();\r\n    const navigate = useNavigate();\r\n    const [loading, setLoading] = useState(false);\r\n\r\n    const confirmAccount = () => {\r\n        setLoading(true);\r\n        try {\r\n            const confirmAccount: ConfirmAccountRequest = new ConfirmAccountRequest();\r\n            confirmAccount.token = token;\r\n            confirmAccount.userId = id;\r\n            AuthApi.confirmAccount(confirmAccount).then(() => {\r\n\r\n                setTimeout(() => {\r\n                    navigate(\"/\");\r\n                }, 2000);\r\n            }).catch(() => {\r\n                setLoading(false)\r\n                alert(\"Errore nella conferma dell'account!\");\r\n            });\r\n        } catch (e) {\r\n            console.log(\"Errore nella conferma account:\", e);\r\n            setLoading(false);\r\n        }\r\n    };\r\n\r\n    return (\r\n        <div style={styles.container}>\r\n            <div style={styles.card}>\r\n\r\n                <img\r\n                    src=\"https://www.jjodel.io/wp-content/uploads/2024/06/logo-pride.png\"\r\n                    alt=\"Logo JJodel\"\r\n                    style={styles.logo}\r\n                />\r\n                <h1 style={styles.title}>\r\n                    Conferma il tuo account ✉️\r\n                </h1>\r\n                <p style={styles.paragraph}>\r\n                    Clicca sul bottone qui sotto per confermare l'email e iniziare a utilizzare la piattaforma.\r\n                </p>\r\n\r\n                {loading ? (\r\n                    <p style={styles.loadingText}>Conferma in corso... 🔄</p>\r\n                ) : (\r\n                    <button\r\n                        onClick={confirmAccount}\r\n                        onMouseEnter={(e) => e.currentTarget.style.backgroundColor = '#1d4ed8'}\r\n                        onMouseLeave={(e) => e.currentTarget.style.backgroundColor = '#2563eb'}\r\n                        style={styles.button}\r\n                    >\r\n                        Conferma Account\r\n                    </button>\r\n                )}\r\n            </div>\r\n        </div>\r\n    );\r\n}\r\n\r\nconst styles = {\r\n    container: {\r\n        display: 'flex',\r\n        flexDirection: 'column' as const,\r\n        alignItems: 'center',\r\n        justifyContent: 'center',\r\n        minHeight: '100vh',\r\n        background: 'white',\r\n        color: 'white',\r\n        padding: '1rem',\r\n    },\r\n    card: {\r\n        backgroundColor: 'white',\r\n        color: '#1f2937',\r\n        padding: '2rem',\r\n        borderRadius: '1rem',\r\n        boxShadow: '0 10px 25px rgba(0, 0, 0, 0.2)',\r\n        maxWidth: '400px',\r\n        width: '100%',\r\n        textAlign: 'center' as const,\r\n    },\r\n    logo: {\r\n        width: '120px',\r\n        marginBottom: '1.5rem',\r\n    },\r\n    title: {\r\n        fontSize: '2rem',\r\n        fontWeight: 'bold' as const,\r\n        marginBottom: '1rem',\r\n    },\r\n    paragraph: {\r\n        marginBottom: '1.5rem',\r\n        fontSize: '1rem',\r\n    },\r\n    button: {\r\n        backgroundColor: '#2563eb',\r\n        color: 'white',\r\n        fontWeight: '600',\r\n        padding: '0.75rem 1.5rem',\r\n        borderRadius: '0.75rem',\r\n        width: '100%',\r\n        fontSize: '1.125rem',\r\n        border: 'none',\r\n        cursor: 'pointer',\r\n        transition: 'background-color 0.3s ease',\r\n    },\r\n    loadingText: {\r\n        fontSize: '1.125rem',\r\n        fontWeight: '600',\r\n        color: '#2563eb',\r\n    }\r\n};\r\n\r\n\r\nexport { ConfirmAccount };\r\n","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\pages\\AllProjects.tsx",["1620","1621","1622","1623","1624","1625","1626"],"/* DASHBOARD */\r\n/* ALLPROJECTS */\r\n\r\nimport React, {Component, Dispatch, ReactElement, useState } from 'react';\r\nimport {connect} from 'react-redux';\r\nimport {DProject, DState, Log, LProject, SetRootFieldAction, Try, U} from '../joiner';\r\nimport {FakeStateProps} from '../joiner/types';\r\nimport {Dashboard, Project} from './components';\r\n\r\nimport { Cards, Card } from './components/cards/Cards';\r\nimport { Catalog } from './components/catalog/Catalog';\r\n\r\nimport {ProjectsApi} from \"../api/persistance\";\r\nimport { LatestUpdates } from './components/LatestUpdates';\r\n\r\nfunction AllProjectsComponent(props: AllProps): JSX.Element {\r\n    const {projects} = props;\r\n    const [isDropping, setDropping] = useState(false);\r\n  \r\n    const createProject = async(type: DProject['type']) => {\r\n        console.log(\"sono nella classe AllProjects, metodo createProject\");\r\n\r\n        await ProjectsApi.create(type, undefined, undefined, undefined, projects);\r\n    }\r\n\r\n    function dropConfirm(e: React.DragEvent<HTMLElement>){\r\n        e.preventDefault();\r\n        e.stopPropagation();\r\n        console.log('dropevent', {e});\r\n\r\n        const droppedFiles = Array.from(e.dataTransfer.files);\r\n        if (droppedFiles.length > 0) {\r\n            for (let file of droppedFiles){\r\n            var reader = new FileReader();\r\n            reader.onload = function(e) {\r\n                if (!e.target) { Log.ee('invalid file', e); return; }\r\n                var contents = e.target.result;\r\n                console.log('read file', {contents, e, file});\r\n                let date: number = file.lastModified;\r\n                let name = file.name; // including extension\r\n                if (typeof contents === 'string') ProjectsApi.importFromText(contents, name, date);\r\n                else Log.ee('invalid file content', {e, contents});\r\n            };\r\n            reader.readAsText(file);\r\n            }\r\n        }\r\n        //let file = e.dataTransfer.getData('file');\r\n        setDropping(false);\r\n    }\r\n\r\n    function mouseleave(e: any){ // should use onDragLeave but it is flashing\r\n        setDropping(false);\r\n    }\r\n\r\n    function dropPreview(e: React.DragEvent<any>){\r\n        e.stopPropagation();\r\n        e.preventDefault();\r\n        setDropping(true);\r\n        e.dataTransfer.dropEffect = 'copy';\r\n    }\r\n    return(<Try>\r\n        <>\r\n        <Dashboard active={'All'} version={props.version}>\r\n            <div className={'droparea'} onDrop={dropConfirm} onDragOver={dropPreview} onMouseLeave={mouseleave}>\r\n                <div style={{opacity: isDropping ? 0.5 : 1}}>\r\n                <Cards>\r\n                    <Cards.Item\r\n                        title={'New Jjodel'}\r\n                        subtitle={'Create a new Jjodel project.'}\r\n                        icon={'add'}\r\n                        style={'green'}\r\n                        action={() => createProject('private')}\r\n                    />\r\n                    {!(U.isOffline()) && <Cards.Item\r\n                        title={'New Jjodel (Collaborative)'}\r\n                        subtitle={'Create a new Jjodel project.'}\r\n                        icon={'add'}\r\n                        style={'yellow'}\r\n                        action={() => createProject('collaborative')}\r\n                    />}\r\n                    <Cards.Item\r\n                        title={'Import Jjodel'}\r\n                        subtitle={'Import an existing Jjodel project.'}\r\n                        icon={'import'}\r\n                        style={'dark'}\r\n                        action={ProjectsApi.import}\r\n                    />\r\n                    {<Cards.Item icon={'gettingstarted'} url={'https://www.jjodel.io/getting-started/'} style={'red-orange'} title={'Getting Started'} subtitle={'New to Jjodel? No worries'}/>}\r\n                </Cards>\r\n                <Catalog projects={projects} />\r\n            </div>\r\n                {isDropping ? <div style={{\r\n                    position: 'absolute',\r\n                    left: '50%',\r\n                    marginLeft: '-50px',\r\n                    top: '50%',\r\n                    marginTop: '-50px',}}>Drop the file to import a .jJodel project</div> : null}\r\n            </div>\r\n        </Dashboard>\r\n        <LatestUpdates page={'AllProjects'}/>\r\n        </>\r\n\r\n    </Try>);\r\n}\r\n\r\ninterface OwnProps {}\r\ninterface StateProps {\r\n    projects: LProject[];\r\n    version: DState[\"version\"];\r\n}\r\ninterface DispatchProps {}\r\n\r\ntype AllProps = OwnProps & StateProps & DispatchProps;\r\n\r\n\r\nfunction mapStateToProps(state: DState, ownProps: OwnProps): StateProps {\r\n    const ret: StateProps = {} as FakeStateProps;\r\n    ret.projects = LProject.fromArr(state.projects);\r\n    ret.version = state.version;\r\n    return ret;\r\n}\r\n\r\nfunction mapDispatchToProps(dispatch: Dispatch<any>): DispatchProps {\r\n    const ret: DispatchProps = {};\r\n    return ret;\r\n}\r\n\r\nconst AllProjectsConnected = connect<StateProps, DispatchProps, OwnProps, DState>(\r\n    mapStateToProps,\r\n    mapDispatchToProps\r\n)(AllProjectsComponent);\r\n\r\nconst AllProjectsPage = (props: OwnProps, children: (string | Component)[] = []): ReactElement => {\r\n    return <AllProjectsConnected {...{...props, children}} />;\r\n}\r\n\r\nexport {AllProjectsPage};\r\n\r\n","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\pages\\Account.tsx",["1627","1628","1629","1630"],"import {DState, DUser, LUser, Try} from '../joiner';\r\nimport {Dashboard} from './components';\r\nimport {FakeStateProps, windoww} from '../joiner/types';\r\nimport React, {Component, Dispatch, ReactElement} from \"react\";\r\nimport {connect} from \"react-redux\";\r\nimport { Edit, EditCountry } from './components/Edit/Edit';\r\nimport {AuthApi, UsersApi} from '../api/persistance';\r\nimport { useStateIfMounted } from 'use-state-if-mounted';\r\nimport Storage from '../data/storage';\r\nimport { ResetPasswordRequest } from '../api/DTO/ResetPasswordRequest';\r\nimport {UpdateUserRequest} from \"../api/DTO/UpdateUserRequest\";\r\nimport {ChangePasswordRequest} from \"../api/DTO/ChangePasswordRequest\";\r\nimport {LoginRequest} from \"../api/DTO/LoginRequest\";\r\n\r\n\r\nfunction AccountComponent(props: AllProps): JSX.Element {\r\n    const {user} = props;\r\n\r\n    const [name, setName] = useStateIfMounted(user.name);\r\n    const [surname, setSurname] = useStateIfMounted(user.surname);\r\n    const [nickname, setNickname] = useStateIfMounted(user.nickname);\r\n    const [country, setCountry] = useStateIfMounted(user.country);\r\n    const [affiliation, setAffiliation] = useStateIfMounted(user.affiliation);\r\n    const [newsletter, setNewsletter] = useStateIfMounted(user.newsletter);\r\n    const [email, setEmail] = useStateIfMounted(user.email);\r\n\r\n    const [old_password, setOldPassword] = useStateIfMounted('01234567');\r\n    const [new_password, setNewPassword] = useStateIfMounted('12345678');\r\n    const [check_password, setCheckPassword] = useStateIfMounted('23456789');\r\n\r\n    async function update_password(old_password: string, new_password:string, check_password:string) {\r\n\r\n        const U = windoww.U;\r\n\r\n        /*\r\n        if(response.code !== 200) {\r\n            U.alert('e', 'Your password does not match our records.','');\r\n            return;\r\n        }\r\n        */\r\n\r\n        if (new_password !== check_password) {\r\n            U.alert('e', 'Paswords do not match.','');\r\n            return;\r\n        }\r\n\r\n        const changePasswordRequest :ChangePasswordRequest = new ChangePasswordRequest();\r\n        changePasswordRequest.UserName = nickname;\r\n        changePasswordRequest.OldPassword = old_password;\r\n        changePasswordRequest.Password= new_password;\r\n        changePasswordRequest.PasswordConfirm = check_password;\r\n\r\n        const response_password = await UsersApi.updatePassword(changePasswordRequest);\r\n\r\n        if(response_password === null) {\r\n            U.alert('e', 'Something went wrong.','');\r\n            return;\r\n        }\r\n\r\n        U.alert('i', 'Your password has been successfully updated!','');\r\n    }\r\n\r\n\r\n    /*\r\n\r\n    async function update_password(old_password: string, new_password:string, check_password:string) {\r\n\r\n        const U = windoww.U;\r\n        \r\n        //const response = await AuthApi.login(email, old_password);\r\n\r\n\r\n        if (response.code !== 200) {\r\n            U.alert('e', 'Your password does not match our records.','');\r\n            return;\r\n        } \r\n\r\n        if (new_password !== check_password) {\r\n            U.alert('e', 'Paswords do not match.','');\r\n            return;\r\n        }\r\n\r\n        const response_password = await UsersApi.updatePasswordById(user.id, new_password);\r\n\r\n        if (response_password === null) {\r\n            U.alert('e', 'Something went wrong.','');\r\n            return;\r\n        }\r\n\r\n        \r\n        U.alert('i', 'Your password has been successfully updated!','');\r\n        \r\n        \r\n        \r\n        \r\n        setNewPassword('01234567');\r\n        setCheckPassword('12345678');\r\n\r\n\r\n    }\r\n    */\r\n\r\n\r\n\r\n   \r\n    function update_newsletter(check_value: boolean): boolean {\r\n\r\n        if(!check_value) {\r\n            return false;\r\n        }\r\n        setNewsletter(check_value);\r\n        return true;\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n    function update_profile (id: string,  name: string,  surname: string,  nickname: string, email :string, country: string, affiliation: string, newsletter: boolean) {\r\n\r\n        const U = windoww.U;\r\n        const readUser = Storage.read<DUser>('user');\r\n\r\n        const updateUserRequest :UpdateUserRequest = new UpdateUserRequest();\r\n        updateUserRequest.id = readUser.id;\r\n        console.log(updateUserRequest.id);\r\n        updateUserRequest.name = name;\r\n        updateUserRequest.surname = surname;\r\n        updateUserRequest.nickname = nickname;\r\n        updateUserRequest.country = country;\r\n        updateUserRequest.email = email;\r\n        updateUserRequest.affiliation = affiliation;\r\n        updateUserRequest.newsletter = update_newsletter(newsletter);\r\n\r\n        console.log(updateUserRequest);\r\n\r\n        const response = UsersApi.updateUserById(updateUserRequest);\r\n\r\n\r\n        if (response === null) {\r\n            U.alert('e', 'Could not update your profile.', 'Something went wrong ...');\r\n            return;\r\n        }\r\n\r\n        const updated_user = DUser.new(name, surname, nickname, affiliation, country, newsletter, email, user.token, updateUserRequest.id);\r\n        console.log(\"NUOVO UTENTE\", updated_user);\r\n        Storage.write('user', updated_user);\r\n        U.resetState();\r\n\r\n        U.alert('i', 'Your profile has been updated!','');\r\n\r\n    }\r\n\r\n    /*\r\n\r\n    function update_profile (id: string,  name: string,  surname: string,  nickname: string, country: string, affiliation: string, newsletter: boolean) {\r\n\r\n        alert(\"sono nella funzione update_profile\")\r\n        const U = windoww.U;\r\n\r\n        const response = UsersApi.updateUserById(user.id, name, surname, nickname, country, affiliation, newsletter);\r\n\r\n\r\n        if (response === null) {\r\n            U.alert('e', 'Could not update your profile.', 'Something went wrong ...');\r\n            return;\r\n        } \r\n\r\n        const updated_user = DUser.new(name, surname, nickname, affiliation, country, newsletter, user.email, user.token, user.id);\r\n        Storage.write('user', updated_user);\r\n        U.resetState();\r\n        \r\n        U.alert('i', 'Your profile has been updated!','');\r\n        \r\n    }\r\n\r\n     */\r\n\r\n\r\n    return(<Try>\r\n        <Dashboard active={'Account'} version={props.version}>\r\n            <>\r\n            <div className={'p-2 edit-container'}>\r\n                <h2><i className=\"bi bi-person-square\"></i> Profile</h2>\r\n\r\n                <Edit \r\n                    id={user.id}\r\n                    name={'name'} \r\n                    label={'Name'} \r\n                    type={'text'} \r\n                    value={name} \r\n                    required={true}\r\n                    disabled={false}\r\n                    onChange={(e) => setName(e.target.value)}\r\n                    tooltip={'Your first name.'}  \r\n                />\r\n                <Edit \r\n                    id={user.id}\r\n                    name={'surname'} \r\n                    label={'Surname'} \r\n                    type={'text'} \r\n                    value={surname} \r\n                    required={true}\r\n                    onChange={(e) => setSurname(e.target.value)}\r\n                    tooltip={'Your family name.'}\r\n                />\r\n\r\n                <Edit\r\n                    id={user.id}\r\n                    name={'nickname'}\r\n                    label={'Nickname'}\r\n                    type={'text'}\r\n                    value={nickname}\r\n                    required={true}\r\n                    onChange={(e) => setNickname(e.target.value)}\r\n                    tooltip={'Your nickname, it will be used as a short form for addressing you.'}\r\n                />\r\n\r\n                <Edit\r\n                    id={user.id}\r\n                    name={'email'} \r\n                    label={'Email'} \r\n                    type={'email'} \r\n                    value={email}\r\n                    required={true}\r\n                    //required={true}\r\n                    onChange={(e) => setEmail(e.target.value)}\r\n                    tooltip={'Your email, it is not possible to change it.'}\r\n                />\r\n                <Edit \r\n                    id={user.id}\r\n                    name={'affiliation'} \r\n                    label={'Affiliation'} \r\n                    type={'text'} \r\n                    value={affiliation}\r\n                    required={true}\r\n                    onChange={(e) => setAffiliation(e.target.value)}\r\n                    tooltip={'Your current affiliation.'}\r\n                />\r\n                <Edit \r\n                    id={user.id}\r\n                    name={'country'} \r\n                    label={'Country'} \r\n                    type={'country'} \r\n                    value={country}\r\n                    onChange={(e) => setCountry(e.target.value)}\r\n                    tooltip={'Select your affiliation country.'}\r\n                />\r\n\r\n                \r\n                <Edit \r\n                    id={user.id}\r\n                    name={'newsletter'} \r\n                    label={'Newsletter'} \r\n                    type={'checkbox'} \r\n                    value={newsletter+''}\r\n                    onChange={(e) => update_newsletter(!newsletter)}\r\n                    tooltip={'Select it if you want to receive low-intensity updates from us (e.g., new releases, new learning and teaching material, and the likes).'}\r\n                />\r\n\r\n                <button \r\n                    className=\"btn alert-btn my-2 px-4 space-above\" \r\n                    onClick={(e) => {update_profile(\r\n                        user.id, \r\n                        name, \r\n                        surname, \r\n                        nickname,\r\n                        email,\r\n                        country,\r\n                        affiliation,\r\n                        newsletter)}}>save</button>\r\n\r\n\r\n            </div>\r\n            <div className={'p-2 edit-container space-above'}>\r\n                <div className={'password-container'}>\r\n                    <h3><i className=\"bi bi-fingerprint\"></i> Password</h3>\r\n\r\n                    <Edit \r\n                        id={user.id}\r\n                        name={'old_password'} \r\n                        label={'Password'} \r\n                        type={'password'} \r\n                        value={old_password}\r\n                        required={true}\r\n                        onChange={(e) => setOldPassword(e.target.value)}              \r\n                    />\r\n\r\n\r\n                    <Edit \r\n                        id={user.id}\r\n                        name={'new_password'} \r\n                        label={'New Password'} \r\n                        type={'password'} \r\n                        value={new_password}\r\n                        required={true}\r\n                        onChange={(e) => setNewPassword(e.target.value)} \r\n                        className={'space-above'}                 \r\n                    />\r\n                    <Edit \r\n                        id={user.id}\r\n                        name={'check_password'} \r\n                        label={'Confirm Password'} \r\n                        type={'password'} \r\n                        required={true}\r\n                        value={check_password}\r\n                        onChange={(e) => setCheckPassword(e.target.value)}              \r\n                    />\r\n                    <button \r\n                        className=\"btn alert-btn my-2  px-4 space-above\"\r\n                        onClick={(e) => update_password(old_password, new_password, check_password)}\r\n                        //onClick={(e) => update_password(old_password, new_password, check_password)}\r\n                        >change password</button>\r\n                </div>\r\n\r\n            </div>\r\n            </>\r\n        </Dashboard>\r\n    </Try>);\r\n}\r\n\r\ninterface OwnProps {}\r\ninterface StateProps {\r\n    user: LUser;\r\n    version: DState[\"version\"];\r\n}\r\ninterface DispatchProps {}\r\ntype AllProps = OwnProps & StateProps & DispatchProps;\r\n\r\n\r\nfunction mapStateToProps(state: DState, ownProps: OwnProps): StateProps {\r\n    const ret: StateProps = {} as FakeStateProps;\r\n    ret.user = LUser.fromPointer(DUser.current);\r\n    ret.version = state.version;\r\n    return ret;\r\n}\r\n\r\nfunction mapDispatchToProps(dispatch: Dispatch<any>): DispatchProps {\r\n    const ret: DispatchProps = {};\r\n    return ret;\r\n}\r\n\r\nconst AllProjectsConnected = connect<StateProps, DispatchProps, OwnProps, DState>(\r\n    mapStateToProps,\r\n    mapDispatchToProps\r\n)(AccountComponent);\r\n\r\nconst AccountPage = (props: OwnProps, children: (string | Component)[] = []): ReactElement => {\r\n    return <AllProjectsConnected {...{...props, children}} />;\r\n}\r\n\r\nexport {AccountPage};\r\n","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\api\\persistance\\index.ts",[],"C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\components\\forEndUser\\SizeInput.tsx",["1631","1632","1633","1634","1635","1636","1637"],"import React, {Dispatch, PureComponent, ReactNode} from \"react\";\r\nimport { connect } from \"react-redux\";\r\nimport toast from \"react-hot-toast\";\r\nimport type {GObject, Pointer, Info} from \"../../joiner\";\r\nimport {\r\n    DPointerTargetable,\r\n    DState,\r\n    GenericInput,\r\n    Log,\r\n    LPointerTargetable,\r\n    Input,\r\n    ISize,\r\n    SetFieldAction\r\n} from \"../../joiner\";\r\nexport let useless=1;\r\n\r\n// private\r\ninterface ThisState {\r\n}\r\n\r\nclass SizeInputComponent extends PureComponent<AllProps, ThisState>{\r\n    static cname: string;\r\n\r\n    constructor(props: AllProps, context: any) {\r\n        super(props, context);\r\n    }\r\n\r\n    render(): ReactNode {\r\n        let l: LPointerTargetable = this.props.data;\r\n        let ll: GObject = l;\r\n        let field: keyof LPointerTargetable = this.props.field as any;\r\n        let otherProps: GObject = {...this.props};\r\n        delete otherProps.xgetter;\r\n        delete otherProps.xsetter;\r\n        delete otherProps.ygetter;\r\n        delete otherProps.ysetter;\r\n        delete otherProps.wgetter;\r\n        delete otherProps.wsetter;\r\n        delete otherProps.hgetter;\r\n        delete otherProps.hsetter;\r\n        delete otherProps.data;\r\n        delete otherProps.field;\r\n        delete otherProps.label;\r\n        delete otherProps.tooltip;\r\n        delete otherProps.key;\r\n\r\n        let tooltip: JSX.Element;\r\n        if (this.props.tooltip === true) { tooltip = (ll[\"__info_of__\" + field])?.txt || ''; }\r\n        else { tooltip = (this.props.tooltip || '') as any; }\r\n\r\n        const notify = () => toast((t: GObject) => (\r\n            <div onClick={() => toast.dismiss(t.id)}>\r\n                <label className={'ms-1'}>{tooltip}</label>\r\n            </div>\r\n        ));\r\n\r\n\r\n        let size: Partial<ISize> = (l[field] || {}) as GObject;\r\n        console.log('sizeinput debug', {l, field, size})\r\n\r\n        const inputStyle = {justifyContent: \"right\", width: \"auto\", marginRight:\"5px\"};\r\n        let labelStyle = {height: '100%', display: 'inline-block', marginRight:\"5px\"}\r\n        return (<>\r\n            <label className={this.props.rootClassName} style={{fontFamily:'Inter Tight', ...(this.props.rootStyle||{})}}>\r\n                {(this.props.label) && <label className={'my-auto'} style={{fontFamily:'-webkit-body'}} onClick={() => { if (tooltip) notify() }}>\r\n                    {this.props.label}\r\n                </label>}\r\n                <label className={\"d-flex my-auto ms-auto\"} style={{flexWrap: \"wrap\"}}>\r\n                    {\"x\" in size && <Input {...otherProps} className={\"\"} data={l} label={<span style={labelStyle}>x</span>} field={field} type={\"number\"}\r\n                        getter={(ll)=>(l[field] as any as ISize).x+''}\r\n                        setter={(val)=>{\r\n                            // SetFieldAction.new(l.id, field as string, {x: +val}, '+=', false)\r\n                            (l[field] as any as Partial<ISize>) = {x: +val}; // {y:? x: +val, w:?, h:?}}\r\n                    }}\r\n                        inputStyle={inputStyle}\r\n                    />}\r\n                    {\"y\" in size && <Input {...otherProps} className={\"\"} data={l} label={<span style={labelStyle}>y</span>} field={field} type={\"number\"}\r\n                       getter={(ll)=>(l[field] as any as ISize).y+''}\r\n                       setter={(val)=>{(l[field] as any as Partial<ISize>) = {y: +val}}}\r\n                       inputStyle={inputStyle}\r\n                    />}\r\n                    {\"w\" in size && <Input {...otherProps} className={\"\"} data={l} label={<span style={labelStyle}>w</span>} field={field} type={\"number\"}\r\n                        getter={(ll)=>(l[field] as any as ISize).w+''}\r\n                        setter={(val)=>{(l[field] as any as Partial<ISize>) = {w: +val}}}\r\n                        inputStyle={inputStyle}\r\n                    />}\r\n                    {\"h\" in size && <Input {...otherProps} className={\"\"} data={l} label={<span style={labelStyle}>h</span>} field={field} type={\"number\"}\r\n                       getter={(ll)=>(l[field] as any as ISize).h+''}\r\n                       setter={(val)=>{(l[field] as any as Partial<ISize>) = {h: +val}}}\r\n                       inputStyle={inputStyle}\r\n                    />}\r\n                </label>\r\n            </label>\r\n        </>); }\r\n}\r\n\r\n// private\r\ninterface OwnProps {\r\n    data: LPointerTargetable;\r\n    field: string;\r\n    xgetter?: (data: LPointerTargetable) => string;\r\n    xsetter?: (value: string|boolean) => void;\r\n    ygetter?: (data: LPointerTargetable) => string;\r\n    ysetter?: (value: string|boolean) => void;\r\n    wgetter?: (data: LPointerTargetable) => string;\r\n    wsetter?: (value: string|boolean) => void;\r\n    hgetter?: (data: LPointerTargetable) => string;\r\n    hsetter?: (value: string|boolean) => void;\r\n    label?: ReactNode;\r\n    tooltip?: ReactNode | true; // if true picks it up from __info_of__\r\n    readonly?: boolean;\r\n    key?: React.Key | null;\r\n    className?: string;\r\n    rootClassName?: string;\r\n    inputClassName?: string;\r\n    rootStyle?: GObject;// this goes to root\r\n    style?: GObject; // this goes at the root of <Input> or <Select> element(s)\r\n    inputStyle?: GObject; // this goes to the actual native <input> or <select> element(s)\r\n}\r\n\r\n// private\r\ninterface StateProps {\r\n    // propsFromReduxStateOrOtherKindOfStateManagement: boolean; // flux or custom things too, unrelated to this.state of react.\r\n}\r\n\r\n// private\r\ninterface DispatchProps {\r\n    // propsFromReduxActions: typeof funzioneTriggeraAzioneDaImportare;\r\n}\r\n\r\n\r\n// private\r\ntype AllProps = OwnProps & StateProps & DispatchProps;\r\n\r\n////// mapper func\r\n\r\nfunction mapStateToProps(state: DState, ownProps: OwnProps): StateProps {\r\n    const ret: StateProps = {} as any;\r\n    /// to fill\r\n    return ret; }\r\n\r\nfunction mapDispatchToProps(dispatch: Dispatch<any>): DispatchProps {\r\n    const ret: DispatchProps = {} as any;\r\n    /// to fill\r\n    return ret; }\r\n\r\n\r\nexport const SizeInput = connect<StateProps, DispatchProps, OwnProps, DState>(\r\n    mapStateToProps,\r\n    mapDispatchToProps\r\n)(SizeInputComponent);\r\n\r\n\r\nSizeInputComponent.cname = \"SizeInputComponent\";\r\nSizeInput.cname = \"SizeInput\";\r\n","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\common\\libraries\\projectModified.ts",[],"C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\components\\topbar\\SaveManager.ts",["1638","1639","1640","1641","1642","1643"],"import {\r\n    Dictionary,\r\n    DUser,\r\n    EcoreParser,\r\n    GObject,\r\n    DState,\r\n    Json,\r\n    LModel,\r\n    LoadAction,\r\n    Log,\r\n    U,\r\n    LPointerTargetable,\r\n    prjson2xml,\r\n    prxml2json,\r\n    store,\r\n    RuntimeAccessible,\r\n    DModelElement,\r\n    SetRootFieldAction,\r\n    Selectors,\r\n    Debug,\r\n    DViewElement,\r\n    transientProperties,\r\n    LUser\r\n} from '../../joiner';\r\nimport {ProjectsApi} from \"../../api/persistance\";\r\nimport {VersionFixer} from \"../../redux/VersionFixer\";\r\n\r\n@RuntimeAccessible('SaveManager')\r\nexport class SaveManager {\r\n    private static tmpsave: DState;\r\n\r\n    static save(): void {\r\n        let project = LUser.fromPointer(DUser.current)?.project;\r\n        if (project) ProjectsApi.save(project);\r\n        U.isProjectModified = false;\r\n        /*SaveManager.tmpsave = store.getState();\r\n        localStorage.setItem(\"tmpsave\", JSON.stringify(SaveManager.tmpsave));\r\n        console.clear();\r\n        console.log(JSON.stringify(SaveManager.tmpsave))*/\r\n    }\r\n\r\n    static load(state0?: string | GObject<DState>): void {\r\n        if (!state0 && SaveManager.tmpsave) { LoadAction.new(SaveManager.tmpsave); return; }\r\n        state0 = state0 || localStorage.getItem('tmpsave') || 'null'; // priorities: 1) argument from file 2) state variable cached 3) localstorage 4) null prevent crash\r\n        let save: GObject<DState> = SaveManager.tmpsave = typeof state0 === 'string' ? JSON.parse(state0) : state0;\r\n        for (let vid of [...save.viewelements, ...save.viewpoints]) {\r\n            for (let key of DViewElement.RecompileKeys) {\r\n                if(!transientProperties.view[vid]) transientProperties.view[vid] = {name: (save.idlookup[vid] as any)?.name || 'Unnamed'} as any;\r\n                key = 'VIEWS_RECOMPILE_' + key;\r\n                if (!save[key]) save[key] = [];\r\n                save[key].push(vid);\r\n            }\r\n        }\r\n        VersionFixer.update(save);\r\n        LoadAction.new(save);\r\n    }\r\n\r\n    public static exportEcore_click(toXML: boolean = false, toFile: boolean = true): void { // e: React.MouseEvent,\r\n        let lmodel: null|LModel = Selectors.getActiveModel();\r\n        if (!lmodel) return;\r\n        let json = SaveManager.exportEcore(lmodel);\r\n        let str = JSON.stringify(json, null, \"\\t\");\r\n        if (toXML) {\r\n            str = prjson2xml.json2xml(json, '\\t');\r\n            str = U.formatXml(str);\r\n        }\r\n\r\n        if (!toFile) {\r\n            // (document.querySelector(\"#export-tmp\") as any).innerText = str;\r\n            localStorage.setItem(\"import\", str);\r\n            return;\r\n        }\r\n        let ism2 = (lmodel as LModel).isMetamodel;\r\n        let name = (lmodel.name || (ism2 ? 'M2' : 'M1') + '_unnamed')  + (toXML ? \".xml\" : '.json') + \".\"+ (ism2 ? \"ecore\" : lmodel.instanceof?.name || \"shapeless\");\r\n        console.log(\"download file:\", {name, ism2, toXML, lmodel, instanceof:lmodel.instanceof});\r\n        U.download(name, str);\r\n    }\r\n\r\n    public static importEcore_click(fromXML: boolean = false, fromfile: boolean = true): void {\r\n        try { this.importEcore_click0(fromXML, fromfile); } catch (e: any) {\r\n            let str = e?.message?.substring?.(0, 1000) || 'some error';\r\n            console.trace(str, e);\r\n            // throw new Error(str);\r\n        }\r\n    }\r\n    public static importEcore_click0(fromXML: boolean = false, fromfile: boolean = true): void {\r\n        const extensions: string[] = [(fromXML ? \"*.xml.*\" : \"*.json.*\")]; // [\".ecore\"]; // Selectors.getActiveModel().isM1() ? '.' + Selectors.getActiveModel().metamodel.fullname() : '.ecore';\r\n        let filestring: string, jsonstring: string, jsonobj: GObject = undefined as any;\r\n        console.log(\"importEcore: prefromfile\");\r\n        if (!fromfile) {\r\n            filestring = localStorage.getItem(\"import\") || 'null';\r\n            if (fromXML) {\r\n                const xmlDoc = new DOMParser().parseFromString(filestring,\"text/xml\");\r\n                jsonobj = prxml2json.xml2jsonobj(xmlDoc, ' ');\r\n            }\r\n            //if (filestring.includes(\"\\n\")) throw new Error(filestring.substring(0, 1000));\r\n            SaveManager.importEcore(jsonobj || filestring, true, undefined, true); // todo: trova il modo di determinare se è m1 o m2 senza filename\r\n            return; }\r\n\r\n        console.log(\"importEcore: pre file read\", {fromXML, fromfile});\r\n        let filename;\r\n        U.fileRead((e: Event, files?: FileList | null, fileContents?: string[]) => {\r\n            Log.ex(!fileContents || !files || fileContents.length !== files.length, 'Failed to get file contents:', files, fileContents);\r\n            Log.ex(!!fileContents && fileContents.length > 1, 'Should not be possible to input multiple files yet.');\r\n            if (!fileContents) return;\r\n            if (fileContents.length == 0) return;\r\n            // @ts-ignore\r\n            filename = e.target.files?.[0].name;\r\n            console.log(\"file read\", {e, fileContents, files, filename});\r\n            filestring = fileContents[0];\r\n\r\n            // if file is over 500kb, lightmode on\r\n            if (filestring.length >= 500*1024 && !Debug.lightMode) {\r\n                Debug.setLightMode(true);\r\n                // $(document).one(\"click\", (e) => { Debug.setLightMode(false); });\r\n            }\r\n\r\n            console.log('importEcore filestring input: ', filestring);\r\n            if (fromXML) {\r\n                let windoww = window as any;\r\n                windoww.file = filestring;\r\n                windoww.todoc = (str: any) => new DOMParser().parseFromString(str,\"text/xml\");\r\n                windoww.doctojson = (doc: any) => prxml2json.xml2jsonobj(doc, ' ');\r\n                // problemi doctojson or xmi parser: \\n replacemet causa crash per stringa in posizione invalida. \\\" anche per attributi inline che iniiano con \\\\\"\r\n                // filestring = U.multiReplaceAll(filestring, [\"\\t\", \"\\r\", \"\\n\", '&amp;', '&#38;', '&quot;', '&', '\\'', '\"'], [\"\\\\t\", \"\\\\r\", \"\\\\n\", '\\\\&', \"\\\\'\", '\\\\\"', '\\\\&', \"\\\\'\", '\\\\\"']);//,  \"\\\\t\"), \"\\r\", \"\\\\r\"), \"\\n\", \"\\\\n\");\r\n\r\n                const xmlDoc = new DOMParser().parseFromString(filestring,\"text/xml\");\r\n                console.log('importEcore xml:', xmlDoc);\r\n                let jsonstring0 = '';\r\n                jsonobj = prxml2json.xml2jsonobj(xmlDoc, ' ');//doto: non devo wrappare con \\\" i nomi di chiavi o valori ma solo i contenuti\r\n                /*jsonstring = jsonstring0;\r\n                //jsonstring = U.multiReplaceAll(jsonstring0, [\"\\t\", \"\\r\", \"\\n\", '&amp;', '&#38;', '&quot;', '&', '\\'', '\"'], [\"\\\\t\", \"\\\\r\", \"\\\\n\", '\\\\&', \"\\\\'\", '\\\\\"', '\\\\&', \"\\\\'\", '\\\\\"']);//,  \"\\\\t\"), \"\\r\", \"\\\\r\"), \"\\n\", \"\\\\n\");\r\n                *///jsonstring = jsonstring.replaceAll(/(\\{|\\,)\\\\n\\s*/gm, \"\")\r\n                /*if (jsonstring.includes(\"\\n\")) throw new Error(jsonstring0.substring(0, 1000)+\"\\n\\n\\n\\n\" + jsonstring.substring(0, 1000));\r\n                */\r\n                // jsonstring = JSON.stringify(jsonobj);\r\n                if (jsonobj.parsererror) { Log.ee(\"failed to parse XML->JSON\", {parseError:jsonobj.parseerror, jsonobj});  return; }\r\n                console.log('importEcore jsonstr input: ', jsonobj);\r\n            }\r\n            else jsonstring = filestring;\r\n            let isMetamodel = filename.indexOf(\".ecore\") === filename.length - \".ecore\".length;\r\n            console.log(\"ismetamodel\", {filename, isMetamodel});\r\n            let end = SaveManager.importEcore(jsonobj || jsonstring || 'null', isMetamodel, filename, true);\r\n        }, extensions, true);\r\n    }\r\n\r\n    public static exportEcore(model: LModel): Json {\r\n        let loopobj = {};\r\n        try { return model.generateEcoreJson(loopobj); }\r\n        catch(e) { Log.exx(\"possible loop in model:\\t\\n\" + (e as Error).message, {loopobj, e}); }\r\n        return {\"error\": true, loopobj};\r\n    }\r\n    public static importEcore(jsonstr: GObject | string | null, isMetamodel: boolean, filename: string | undefined, persist: boolean = true): DModelElement[] {\r\n        return EcoreParser.parse(jsonstr, isMetamodel, filename, persist);\r\n    }\r\n\r\n    static exportLayout_click(toFile: boolean) {\r\n        let lmodel: LModel = (LPointerTargetable.wrap(store.getState().models[0]) as LModel);\r\n        // lmodel.node?.allSubNodes\r\n\r\n    }\r\n    static importLayout_click(fromFile: boolean) {\r\n\r\n    }\r\n}\r\n\r\n","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\components\\abstract\\DockManager.ts",["1644"],"import {DockLayout, TabData} from 'rc-dock';\r\nimport {LModel, RuntimeAccessible, U} from '../../joiner';\r\nimport TabDataMaker from \"./tabs/TabDataMaker\";\r\n\r\n@RuntimeAccessible('DockManager')\r\nclass DockManager {\r\n    static cname = \"DockManager\";\r\n    static dock: DockLayout|null;\r\n\r\n    static async open(group: 'models'|'editors', tab: TabData): Promise<void> {\r\n        if(!DockManager.dock) return;\r\n        const index = (group === 'models') ? 0 : 1;\r\n        console.log(\"TabManager open()\", group, tab);\r\n        DockManager.dock.dockMove(tab, DockManager.dock.getLayout().dockbox.children[index], 'middle');\r\n    }\r\n\r\n    static async open2(me: LModel): Promise<void> {\r\n        const tab = (me.isMetamodel) ? TabDataMaker.metamodel(me) : TabDataMaker.model(me);\r\n        await DockManager.open('models', tab);\r\n    }\r\n\r\n}\r\n\r\nexport default DockManager;\r\n","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\api\\DTO\\RegisterRequest.ts",[],"C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\api\\DTO\\LoginRequest.ts",[],"C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\api\\DTO\\ResetPasswordRequest.ts",[],"C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\components\\collaborative\\CollaborativeAttacher.tsx",["1645"],"import Collaborative from './Collaborative';\r\nimport type {CompositeAction, GObject, LProject, Pointer} from '../../joiner';\r\nimport {Action, SetRootFieldAction} from '../../joiner';\r\nimport {useEffect, useState} from \"react\";\r\n\r\ninterface Props {project: LProject}\r\nfunction CollaborativeAttacher(props: Props) {\r\n    const project = props.project;\r\n    const [actions, setActions] = useState<Pointer[]>([]);\r\n\r\n    useEffect(() => {\r\n        SetRootFieldAction.new('collaborativeSession', true);\r\n        Collaborative.client.io.opts.query = {'project': project.id};\r\n        Collaborative.client.connect();\r\n        /*\r\n        return () => {\r\n            Collaborative.client.off('pullAction');\r\n            Collaborative.client.disconnect();\r\n            SetRootFieldAction.new('collaborativeSession', false);\r\n        }\r\n        */\r\n        Collaborative.client.on('pullAction', (action: GObject<Action & CompositeAction>) => {\r\n            const receivedAction = Action.fromJson(action);\r\n            console.log('Received Action from server.', action);\r\n            receivedAction.hasFired = 0;\r\n            if(!actions.includes(receivedAction.id)) {\r\n                console.log('Received actions', actions)\r\n                setActions([...actions, action.id]);\r\n                receivedAction.fire();\r\n            }\r\n        });\r\n    }, []);\r\n\r\n    return(<></>);\r\n}\r\n\r\nexport default CollaborativeAttacher;\r\n","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\api\\DTO\\ConfirmAccountRequest.ts",[],"C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\pages\\components\\about\\About.tsx",["1646","1647","1648","1649"],"import { useState } from \"react\";\r\nimport logo from '../../../static/img/logo-on.png';\r\nimport manatee from '../../../static/img/manatee.png';\r\nimport React from \"react\";\r\nimport ReactDOM from \"react-dom\";\r\n\r\nlet windoww = window as any;\r\n\r\ntype Props = {\r\n    type?: 'inline'|'menu';\r\n    ver: string;\r\n    name: string;\r\n    value?: boolean;\r\n};\r\n\r\nconst message: string = \"Manatees are large, fully aquatic, mostly herbivorous marine mammals sometimes known as sea cows.The main causes of death for manatees are human-related issues. As usual, we are the most dangerous animal on earth.\";\r\n\r\n\r\nclass AboutModal {\r\n  \r\n    static open() {\r\n        if (!document) return;\r\n\r\n        const aboutElement = document.createElement('div');\r\n        ReactDOM.render(React.createElement(About, { ver: '1.0', name: 'Jjodel', type: 'menu', value: true }), aboutElement);\r\n        document.body.append(aboutElement);\r\n    }\r\n}\r\n\r\nconst About = (props: Props) => {\r\n\r\n    const [open, setOpen] = useState<boolean>(props.value ? props.value : false);\r\n\r\n    const {type, ver, name} = props;\r\n\r\n    const AboutRaw = (props: Props) => {\r\n        return(\r\n            <>\r\n                <div className='modal-container'></div>\r\n                <div className='modal'>\r\n                    <div><img src={logo} /></div>\r\n                    <div>v{props.ver} {props.name}</div>\r\n                    <div>\r\n                        {message}\r\n                    </div>\r\n                    <div><img src={manatee} /></div>\r\n                    \r\n                    <button className={'close'} onClick={() => setOpen(!open)}>close</button>\r\n                </div>\r\n            </>\r\n        );\r\n    }\r\n\r\n    return (\r\n        <>\r\n            {props.type !== 'menu' && <span className={'about'} onClick={(e) => setOpen(!open)}>Jjodel v{props.ver} <i className=\"bi bi-globe-americas\"></i> {props.name}</span>}\r\n            {open  && <AboutRaw ver={ver} name={name} />}\r\n        </>\r\n\r\n    );\r\n};\r\n\r\n\r\nexport {About, AboutModal};\r\n","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\pages\\components\\menu\\Menu.tsx",["1650","1651","1652"],"import React, { useState, useRef, useEffect, MouseEventHandler, ReactNode, ReactHTML } from \"react\";\r\nimport parse from 'html-react-parser';\r\nimport \"./menu.scss\";\r\n\r\ntype MenuProps = {\r\n    children: any;\r\n    position?: \"left\"|\"right\";\r\n    style?: React.CSSProperties;\r\n    theme?: \"light\"\r\n    title?: string;\r\n};\r\n\r\nfunction getFragment(command: string): any {\r\n    return (<>\r\n            {command}\r\n    </>);\r\n}\r\n\r\nfunction useClickOutside(ref: any, onClickOutside: any) {\r\n    useEffect(() => {\r\n      \r\n        function handleClickOutside(event: Event) {\r\n            if (ref.current && !ref.current.contains(event.target)) {\r\n                onClickOutside();\r\n            }\r\n        }\r\n\r\n      // Bind\r\n      document.addEventListener(\"mousedown\", handleClickOutside);\r\n      return () => {\r\n        // dispose\r\n        document.removeEventListener(\"mousedown\", handleClickOutside);\r\n      };\r\n    }, [ref, onClickOutside]);\r\n  }\r\n\r\nexport const Menu = (props: MenuProps) => {\r\n\r\n    const [open, setOpen] = useState(false);\r\n    const menuRef = useRef(null);\r\n\r\n    useClickOutside(menuRef, () => {\r\n        setOpen(false);\r\n    });\r\n\r\n    // const my_style = (props.style ? props.style : {border: '1px solid blue'} );\r\n    return(<>\r\n        {props.title && <span onClick={(e) => {e.preventDefault();setOpen(!open);}} className={\"top-level\"}>{props.title}</span>}\r\n        <div className={`menu-button ${props.title && 'no-display'}`} ref={menuRef}  style={props.style}>\r\n            {open && <div className={`dropdown ${props.position ? props.position : 'right' }`}>\r\n                {props.children}\r\n            </div>}\r\n            {!props.title && <i onClick={() => setOpen(!open)} className=\"bi bi-chevron-down\" style={{fontSize: '10px!important'}}></i>}\r\n        </div>      \r\n    </>);\r\n};\r\n\r\nexport const Divisor = () => {\r\n    return(\r\n        <hr className=\"my-1 divisor\" />\r\n    );\r\n};\r\n\r\ntype ItemType = {\r\n    icon?: any;\r\n    children: any;\r\n    action?: MouseEventHandler;\r\n    keystroke?: string; \r\n    \r\n}\r\n\r\nexport const Item = (props: ItemType) => {\r\n\r\n    return(<>\r\n        {props.action && props.keystroke &&  \r\n            <div onClick={props.action} className={'item'}>\r\n                {props.icon ? \r\n                    props.icon \r\n                    : \r\n                    <i className=\"bi bi-app hidden\"></i>\r\n                } \r\n                {props.children} <span>{parse(props.keystroke)}</span>\r\n            </div>\r\n        } \r\n        {props.action && !props.keystroke &&  \r\n            <div onClick={props.action} className={'item'}>\r\n                {props.icon ? \r\n                    props.icon \r\n                : \r\n                    <i className=\"bi bi-app hidden\"></i>\r\n                } \r\n                {props.children}\r\n            </div>\r\n        } \r\n        {!props.action && \r\n            <div className={'item disabled'}>\r\n                {props.icon ? \r\n                    props.icon\r\n                : \r\n                    <i className=\"bi bi-app hidden\"></i>\r\n                } \r\n                {props.children}\r\n            </div>\r\n        } \r\n    </>);\r\n}\r\n\r\n","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\pages\\components\\cards\\Cards.tsx",["1653","1654"],"import React, {MouseEventHandler, ReactNode} from 'react';\r\nimport \"./cards.scss\";\r\nimport { Tooltip } from '../../../components/forEndUser/Tooltip';\r\n\r\ntype CardsType = {\r\n    children: any;\r\n};\r\n\r\nexport const Cards = (props: CardsProps): any => {\r\n    return (\r\n        <React.Fragment>\r\n            <div className='mb-5 commandbar'>\r\n                {props.children}\r\n            </div>\r\n        </React.Fragment>\r\n    );\r\n}\r\n\r\ntype CardProps = {\r\n    icon: \"add\" | \"import\" | \"question\" | \"gettingstarted\" | \"alexa\";\r\n    style: \"ottanio\" | \"red\" | \"dark\" | \"blue\" | \"clear\" | \"rainbow\" | \"red-orange\" | \"yellow\" | \"green\" | \"gray\" | \"light-green\" | \"azure\" | \"orange-yellow\" | \"dark-blue\" | \"default\";\r\n    title: string;\r\n    subtitle?: string;\r\n    action?: MouseEventHandler;\r\n    url?: string;\r\n};\r\ntype CardsProps = {\r\n    children: ReactNode;\r\n};\r\n\r\nexport const Card = (props: CardProps) => {\r\n\r\n    const icons = {\r\n        add: \"bi-plus-circle\",\r\n        import: \"bi-box-arrow-in-up\",\r\n        question: \"bi-question-square\",\r\n        gettingstarted: \"bi-airplane\" ,\r\n        alexa: \"bi-alexa\"\r\n    };\r\n\r\n    return (\r\n            <div className={`card ${props.style ? props.style : 'default' }`}>\r\n                <div className={'col icon'}>\r\n                    {props.action ?\r\n                        <i onClick={props.action} className={`bi ${icons[props.icon]}`}></i> :\r\n                            props.url ?\r\n                                <i onClick={() => {\r\n                                    window.open(\r\n                                        props.url,\r\n                                        '_blank' // <- This is what makes it open in a new window.\r\n                                      );\r\n                                }} className={`bi ${icons[props.icon]}`}></i> :\r\n                            <i className={`bi ${icons[props.icon]} disabled`}></i>\r\n                    }\r\n                </div>\r\n                <div className={'col body'}>\r\n                    <h5>{props.title}</h5>\r\n                    <span>{props.subtitle}</span>\r\n                </div>\r\n            </div>\r\n    );\r\n}\r\n\r\nCards.Item = Card;\r\n\r\n\r\n","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\components\\topbar\\undoredocomponent.tsx",["1655","1656","1657","1658","1659","1660","1661","1662","1663","1664","1665"],"import React, {Dispatch, PureComponent, ReactNode} from 'react';\r\nimport {\r\n    Dictionary, DUser,\r\n    GObject, DState,\r\n    Log, U, RedoAction,\r\n    statehistory,\r\n    UndoAction, store, DPointerTargetable, Pointer, LProject, UserHistory,\r\n} from '../../joiner';\r\nimport {connect} from \"react-redux\";\r\nimport \"./undoredo.scss\"\r\nimport {icon} from \"../../pages/components/icons/Icons\";\r\n\r\ninterface SaveManagerProps {}\r\n\r\nclass UndoRedoState{\r\n    hover: boolean = false;\r\n    jsx: any | null;\r\n    constructor(jsx: any) {  this.jsx = jsx; }\r\n}\r\n\r\n// private\r\ninterface ThisState {\r\n    undo: UndoRedoState;\r\n    redo: UndoRedoState;\r\n    user: Pointer<DUser>|'all';\r\n}\r\n\r\n// private\r\ninterface OwnProps {\r\n    // propsRequestedFromHtmlAsAttributes: string;\r\n    project: LProject;\r\n}\r\n// private\r\ninterface StateProps {\r\n    // propsFromReduxStateOrOtherKindOfStateManagement: boolean; // flux or custom things too, unrelated to this.state of react.\r\n    maxlistsize: number;\r\n    maxDetailSize: number;\r\n    //undo: GObject<\"delta\">[],\r\n    // redo: GObject<\"delta\">[],\r\n    debug: boolean\r\n}\r\n\r\n// private\r\ninterface DispatchProps {\r\n    // propsFromReduxActions: typeof funzioneTriggeraAzioneDaImportare;\r\n}\r\n\r\ntype R = {\r\n    str: string,\r\n    fullstr: string,\r\n    path:string[],\r\n    fullpath:string[],\r\n    fullpath_str?:string, // fullpath.join('.') only saved temporarly in render phase\r\n    val: string,\r\n    fullvalue: string,\r\n    pathlength?: number\r\n};\r\n\r\n// private\r\ntype AllProps = OwnProps & StateProps & DispatchProps;\r\nexport class SaveManagerComponent extends PureComponent<AllProps, ThisState>{\r\n    public static cname: string = \"SaveManagerComponent\";\r\n    private undoredolistoutdated: boolean;\r\n    do_undo = (index: number) => {\r\n        UndoAction.new(index+1, this.state.user, false).commit();\r\n        this.undoenter(); // updates list\r\n    }\r\n    do_redo = (index: number) => {\r\n        console.log(\"redo(\" + index + \")\");\r\n        RedoAction.new(index+1, this.state.user, false).commit();\r\n        this.redoenter();\r\n    }\r\n    printablePointer(pathsegment: string, state: DState){\r\n        let obj = DPointerTargetable.from(pathsegment, state) as GObject;\r\n        if (!obj) return pathsegment;\r\n        if (obj.name) return \"$\"+obj.name;\r\n        if (obj.className) return \"#\"+obj.className;\r\n        return pathsegment;\r\n    }\r\n\r\n    // redo list is updated only when the user mouse-enters it. for efficiency.\r\n    undoredoenter2 = (key: \"undo\"|\"redo\" = \"undo\") => {\r\n        let history = this.get_history(this.state.user);\r\n        let undoarr = history.undoable;\r\n        let redoarr = history.redoable;\r\n        console.log(\"statemanager undo update\", {thiss:this, undoarr, redoarr, user: this.state.user, props: this.props, state:this.state});\r\n        if (!this.undoredolistoutdated) return;\r\n        let s: DState = store.getState();\r\n        let arr = [...(key === 'undo' ? undoarr : redoarr)].reverse().slice(0, this.props.maxlistsize);\r\n        let out: {best: R, obj: GObject}&R[] = [] as any;\r\n        let strings = arr.map( delta => U.ObjectToAssignementStrings(delta, 10, 6, 20, \"…\", out, true));\r\n        //todo: make it just for current index, then get the next val from index+1 or current state, using R.path and replacing just the value. on mouseover switch it val of the delta vs next val\r\n            let list = arr.map((delta, index) => {})\r\n\r\n    }\r\n\r\n    improveText(e: R, s: DState) {\r\n        if (e.fullstr.includes(\"Pointer\")) {\r\n            let editedfullpath = e.fullpath.map( (pathsegment) => {\r\n                //  console.log(\"undoredo replace attempt\", {pathsegment, idlookup:s.idlookup, dobj:s.idlookup[pathsegment], replacement: this.printablePointer(pathsegment, s)});\r\n                return this.printablePointer(pathsegment, s); });\r\n            e.str = editedfullpath.join(\".\") + \" = \" + e.val;\r\n            console.log(\"undoredo replace attempt\", {editedfullpath, beststr:e.str, best: e});\r\n        }\r\n        if (e.path[0] === \"idlookup\") e.str = \"\" + e.str.substring(\"idlookup.\".length);\r\n        if (e.fullvalue.includes(\"Pointer\")) {\r\n            e.val = this.printablePointer(e.fullvalue.substring(1, e.fullvalue.length-1), s); // 1, -1 because string values have quotes \"\"\r\n            e.str = e.str.substring(0, e.str.lastIndexOf(\"=\")) + \"= \" + e.val;\r\n        }\r\n    }\r\n    undoredoenter = (key: \"undo\"|\"redo\" = \"undo??\" as any) => {\r\n        let debug = this.props.debug;\r\n        let history = this.get_history(this.state.user);\r\n        let undoarr = history.undoable;\r\n        let redoarr = history.redoable;\r\n        console.log(\"statemanager undo update\", {thiss:this, undoarr, redoarr, user: this.state.user, props: this.props, state:this.state});\r\n        if (!this.undoredolistoutdated) return;\r\n        let s: DState = store.getState();\r\n        // let arr = [...(this.props as GObject)[key]].reverse().slice(0, this.props.maxlistsize);\r\n        let fullarr = [...(key === 'undo' ? undoarr : redoarr)].reverse()\r\n        let arr = fullarr.slice(0, this.props.maxlistsize);\r\n\r\n        function getLatestDelta(i: number, searchPath: string[], direction: -1 | 1 = 1): GObject {\r\n            outer: for (; i < fullarr.length+1 && i >= -1; i+=direction) {\r\n                let rootdelta = fullarr[i] || s;\r\n                let currDelta = rootdelta;\r\n                for (let pathSeg of searchPath){\r\n                    if (!(pathSeg in currDelta)) continue outer;\r\n                    else currDelta = currDelta[pathSeg];\r\n                }\r\n                return rootdelta;\r\n            }\r\n            return s;\r\n        }\r\n        let list = arr.map((delta, index) => {\r\n            let out: {best: R, obj: GObject}&R[] = [] as GObject as any;\r\n            let out_otherdelta: {best: R, obj: GObject}&R[] = [] as any;\r\n            let titleindex = index + (key === 'undo' ? -1 : 0);\r\n            let titleDelta = arr[titleindex]\r\n            let otherDelta = arr[index + 1]; //[index + (key === 'undo' ? -1 : +1)]\r\n            // let actiodesc = key ==='undo' ? arr[index + 1] : ) || s;\r\n\r\n            let excludedPaths: Dictionary<string, boolean> = {'action.title': true, 'action.description': true};\r\n            let filterrow = (e:R)=> {\r\n                //console.log('filterrow', {debug, e});\r\n                return debug || !excludedPaths[key] && !e.fullpath.includes(\"clonedCounter\")\r\n                    && !e.fullpath.includes(\"timestamp\")\r\n                    && !e.fullpath.includes(\"timestampdiff\")\r\n                    && !e.fullpath.includes(\"pointedBy\")\r\n                    && !e.fullpath.includes(\"pointedBy\")\r\n                    && !e.fullpath.includes('__jjObjDiffIsArr');\r\n            }\r\n            U.ObjectToAssignementStrings(delta, 10, 6, 20, \"…\", out, true, filterrow);\r\n            if (otherDelta) U.ObjectToAssignementStrings(otherDelta, 10, 6, 20, \"…\", out_otherdelta, true, filterrow);\r\n            // if (!index) console.log('debug undoredo', {out, delta, arr});\r\n            // if out.best is undef, then get most recent titles until you find a delta with a title or the current(state)\r\n            let latestTitleDelta = getLatestDelta(titleindex, ['action_title'], (key === 'undo' ? -1 : +1));\r\n            let debugTitle = (titleDelta||s).action_title;\r\n            console.log('getLatestDelta', {delta, latestTitleDelta, best:out.best?.str, titleDelta, dt:(titleDelta||s).action_title, titleindex, out})\r\n            if (!out.best?.str) {\r\n                console.error('generated wrong delta??', {out, best:out?.best});\r\n                return <><div>errored</div></>;\r\n            }\r\n            if (latestTitleDelta.action_title) out.best.str = latestTitleDelta.action_title;\r\n            if (latestTitleDelta.action_description) out.best.fullstr = latestTitleDelta.action_description;\r\n            else out.best.fullstr = out.length + ' subchanges';\r\n            if (latestTitleDelta.action_title !== debugTitle) out.best.str = '* ' + out.best.str;\r\n            if ((otherDelta)?.action_title) out_otherdelta.best.str = (otherDelta||s).action_title;\r\n            if ((otherDelta)?.action_description) out_otherdelta.best.fullstr = (otherDelta||s).action_description;\r\n            out.best.str = U.cropStr(out.best.str, 1, 0, 13, 12);\r\n            out.best.fullstr = U.cropStr(out.best.fullstr, 1, 0, 250, 250);\r\n            //out_otherdelta.best.str = U.cropStr(out_otherdelta.best.str, 1, 0, 13, 12);\r\n            //out_otherdelta.best.fullstr = U.cropStr(out_otherdelta.best.fullstr, 1, 0, 250, 250);\r\n            //this.improveText(out.best, s);\r\n            let other = out.slice(0, this.props.maxDetailSize); //.map(e=>this.improveText(e));\r\n            let other2 = out_otherdelta.slice(0, this.props.maxDetailSize); //.map(e=>this.improveText(e));\r\n\r\n            let newstyle: boolean = true as any;\r\n\r\n            let entry = (): JSX.Element => {\r\n                return (\r\n                    <li onClick={() => ((this as GObject)[\"do_\" + key](index))} className=\"hoverable\" key={index} tabIndex={0}>\r\n                        <label className=\"highlight undefined\">\r\n                            <span><i className=\"bi bi-app hidden\"/> i</span>\r\n                        </label>\r\n                    </li>)\r\n            }\r\n            // if (newstyle) return entry();\r\n\r\n\r\n            for (let e of other2){ e.fullpath_str = e.fullpath.join(\".\")}\r\n            for (let e of other){ e.fullpath_str = e.fullpath.join(\".\")}\r\n            return <li onClick={() => ((this as GObject)[\"do_\" + key](index))} className=\"\" key={index}\r\n                       tabIndex={0}\r\n                       style={{/*overflow: \"visible\", height: \"24px\"*/}}>\r\n                <label className=\"highlight undefined hoverable\">\r\n                    <div className={\"my-auto preview\"}>{out.best.str}</div>\r\n                    <div className={\"my-auto content inline\"}>{out.best.fullstr}</div>\r\n                    <div className={\"content right detail-list\"}>\r\n                        <ul className=\"context-menu right\">{\r\n                            other.map((row, ii) => {\r\n                                let row2 = other2.filter(e=>e.fullpath_str === row.fullpath_str)[0];//other2[ii];\r\n                                return <li className={'detail-entry hoverable'} onClick={(e=> {\r\n                                    e.stopPropagation()\r\n                                })}>\r\n                                    <label className={`highlight disabled hoverable`}>\r\n                                    <span\r\n                                        className='preview inline'>{row.fullpath_str + \" = \" + row.fullvalue}</span>\r\n                                        <span className='content inline'>{row2 && (row2.fullpath_str + \" = \" + row2.fullvalue)}</span>\r\n                                    </label>\r\n                                </li>\r\n                            })}\r\n                            {out.length !== other.length ? <div className={'detail-entry'}>...</div> : null}\r\n                        </ul>\r\n                    </div>\r\n                </label>\r\n            </li>\r\n        });\r\n        let jsx =\r\n            <>{list}</>;\r\n        let obj: GObject = {};\r\n        obj[key] = {...(this.state as GObject)[key], hover: true, jsx};\r\n        // {undo: {...this.state.undo, hover: true, jsx}}\r\n        this.undoredolistoutdated = false;\r\n        this.setState(obj as ThisState);\r\n    }\r\n\r\n    undoenter = ()=>{ return this.undoredoenter(\"undo\"); }\r\n    redoenter = ()=>{ return this.undoredoenter(\"redo\"); }\r\n    undoleave = ()=>{ this.setState({undo: {...this.state.undo, hover: false}}); }\r\n    redoleave = ()=>{ this.setState({redo: {...this.state.redo, hover: false}}); }\r\n\r\n    constructor(props: AllProps, context: any) {\r\n        super(props, context);\r\n        let undo = new UndoRedoState(<div>undo list example</div>);\r\n        let redo = new UndoRedoState(<div>redo list example</div>);\r\n        this.state = {undo, redo, user: DUser.current};\r\n        this.undoredolistoutdated = true;\r\n        // this.setState({undo, redo});\r\n    }\r\n    get_history(user: Pointer<DUser> | 'all'): {redoable: GObject[], undoable: GObject[]}{\r\n        // let ret = {redoable: [] as GObject[], undoable: [] as GObject[]};\r\n        return statehistory[user];\r\n    }\r\n    erase_history(user: Pointer<DUser> | 'all', project: LProject){\r\n        if (user === 'all'){/*\r\n            for (let user of project.collaborators){\r\n                this.erase_history(user.id, project);\r\n            }\r\n            this.erase_history(DUser.current, project);*/\r\n            for (let user in statehistory){\r\n                statehistory[user].undoable = [];\r\n                statehistory[user].redoable = [];\r\n            }\r\n        } else {\r\n            statehistory[user].undoable = [];\r\n            statehistory[user].redoable = [];\r\n        }\r\n    }\r\n    render(): ReactNode {\r\n        let user = this.state.user;\r\n        this.undoredolistoutdated = true; // if render is called it means redux state props he's watching (redux-state) changed, so the preview list in component-state is outdated.\r\n        // console.log(\"undoredomanager\", {thiss:this, undo:this.props.undo, props: this.props, state:this.state});\r\n        let history: UserHistory = this.get_history(user);\r\n        let undo: GObject<\"delta\">[] = history?.undoable || [];\r\n        let redo: GObject<\"delta\">[] = history?.redoable || [];\r\n\r\n        let contextmenustyle =(undoStr: 'Undo'|'Redo', undoarr: GObject<\"delta\">[]): JSX.Element => {\r\n            let undostr = undoStr.toLowerCase() as 'undo'|'redo';\r\n            let isUndo = undoarr === undo;\r\n            return (\r\n            <li className={\"undoredo hoverable \" +(!undoarr.length?'disabled':'')} tabIndex={0}\r\n                onMouseEnter={isUndo?this.undoenter:this.redoenter}\r\n                onMouseLeave={isUndo?this.undoleave:this.redoleave}>\r\n\r\n                <label className=\"highlight undefined\" onClick={(e) => {\r\n                    isUndo ? this.do_undo(0) : this.do_redo(0)\r\n                }}>\r\n                    <span>{icon[undoStr.toLowerCase()]} <span>{undoStr + ' ' + ((undoarr).length || '')}</span></span>\r\n                    {<div className=\"keystrokes\">\r\n                        <i className=\"text-icon ctrl\" title=\"Control\" data-val=\"ctrl\" data-content=\"Control\"/>\r\n                        <span>{isUndo ? 'Z' : 'Y'}</span>\r\n                    </div>}\r\n                    {undoarr.length ? <i className=\"bi bi-chevron-right icon-expand-submenu\"/> : null}\r\n                </label>\r\n                <div className=\"content right\">\r\n                    {undoarr.length ? <ul className=\"context-menu right\">{this.state[undoStr.toLowerCase() as 'undo'|'redo'].jsx}</ul> : null}\r\n                </div>\r\n            </li>)\r\n        }\r\n\r\n        let testnew: boolean = true as any;\r\n        if (testnew) return <>\r\n            {contextmenustyle('Undo', undo)}\r\n            {contextmenustyle('Redo', redo)}\r\n        </>\r\n\r\n        return (<>\r\n            <div className='undoredo'>\r\n                <span className={\"hoverable\"} style={{position: \"relative\", background: \"white\"}}\r\n                      onMouseEnter={this.undoenter} onMouseLeave={this.undoleave}>\r\n                    <button className={'item border round ms-1'} onClick={(e) => {\r\n                        this.do_undo(0)\r\n                    }}>Undo ({undo.length})</button>\r\n                    {undo.length ?\r\n                        <ul style={{background: \"inherit\", width: \"max-content\", zIndex:10000}} className={\"content\"}>\r\n                            {this.state.undo.jsx}\r\n                        </ul>\r\n                        : null}\r\n                </span>\r\n                <span className={\"hoverable\"} style={{position: \"relative\", background: \"white\"}} onMouseEnter={this.redoenter} onMouseLeave={this.redoleave}>\r\n                    <button className={'item border round ms-1'} onClick={(e)=> { this.do_redo(0) }}>Redo ({redo.length})</button>\r\n                    { redo.length ? <ul style={{background: \"inherit\", width: \"max-content\", zIndex:10000}} className={\"content\"}>{this.state.redo.jsx}</ul> : null}\r\n                </span>\r\n                <button onClick={()=>{this.erase_history(user, this.props.project)}}>x</button>\r\n            </div>\r\n        </>);\r\n    }\r\n}\r\n\r\n\r\nfunction mapStateToProps(state: DState, ownProps: OwnProps): StateProps {\r\n    const ret: StateProps = {} as any;\r\n    //ret.undo = statehistory[DUser.current].undoable;\r\n    //ret.redo = statehistory[DUser.current].redoable;\r\n    ret.maxlistsize = 20;\r\n    ret.maxDetailSize = 30;\r\n    ret.debug = state.debug;\r\n    return ret; }\r\n\r\nfunction mapDispatchToProps(dispatch: Dispatch<any>): DispatchProps {\r\n    const ret: DispatchProps = {} as any;\r\n    /// to fill\r\n    return ret; }\r\n\r\nexport const SaveManagerConnected = connect<StateProps, DispatchProps, OwnProps, DState>(\r\n    mapStateToProps,\r\n    mapDispatchToProps\r\n)(SaveManagerComponent);\r\n\r\nexport default SaveManagerConnected;\r\nexport const Undoredocomponent = SaveManagerConnected;","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\components\\abstract\\tabs\\TabDataMaker.tsx",[],"C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\pages\\components\\catalog\\Catalog.tsx",["1666","1667","1668","1669","1670","1671","1672","1673","1674","1675","1676"],"import React, {useState} from \"react\";\r\nimport { LProject } from \"../../../joiner\";\r\nimport { Menu, Item } from \"../menu/Menu\";\r\nimport { Project } from \"../Project\";\r\n\r\nimport colors from '../../../static/img/colors.png';\r\nimport { icon } from \"../icons/Icons\";\r\nimport \"./catalog.scss\"\r\nimport _ from \"lodash\";\r\n\r\nexport const CatalogInfoCard = (props: any) => {\r\n    return (\r\n        <div className={'details'}>\r\n            {props.projects ?\r\n                <>\r\n                    <h5>Your projects</h5>\r\n                    <p>You developed <strong>{props.projects.length}</strong> projects{false && ' with an overall number of 12 artifacts'}.</p>\r\n                    <img src={colors} width={220} />\r\n                </>\r\n                :\r\n                <>\r\n                    <h5>No projects so far. Are you new to Jjodel? why not exploring the Getting Started section?</h5>\r\n                    <img src={colors} width={220} />\r\n                </>\r\n            }\r\n        </div>\r\n    );\r\n}\r\ntype ChildrenType = {\r\n    projects?: any;\r\n    children?: any;\r\n};\r\n\r\nconst Catalog = (props: ChildrenType) => {\r\n\r\n    const [filters, setFilters] = useState([true,true,true]);\r\n    const [mode, setMode] = useState<string>(\"cards\");\r\n\r\n    const [sortingMode, setSortingMode] = useState<string>(\"alphabetical\");\r\n\r\n    const Header = (props: ChildrenType) => {\r\n        return (\r\n            <div className='row catalog-header' style={{maxWidth: '1250px'}}>\r\n                {props.children}\r\n            </div>\r\n        );\r\n    }\r\n\r\n    const CatalogFilters = () => {\r\n\r\n        function toggleFilters(el: 0|1|2) {\r\n            switch(el) {\r\n                case 0:\r\n                    setFilters([!filters[0], filters[1], filters[2]]);\r\n                    break;\r\n                case 1:\r\n                    setFilters([filters[0], !filters[1], filters[2]]);\r\n                    break;\r\n                case 2:\r\n                    setFilters([filters[0], filters[1], !filters[2]]);\r\n                    break;\r\n            }\r\n        };\r\n\r\n        return (\r\n            <div className={'left'}>\r\n                {filters[0] ? <button onClick={(e) => toggleFilters(0)} className='active'>public</button> : <button onClick={(e) => toggleFilters(0)}>public</button>}\r\n                {filters[1] ? <button onClick={(e) => toggleFilters(1)} className='active'>private</button> : <button onClick={(e) => toggleFilters(1)}>private</button>}\r\n                {filters[2] ? <button onClick={(e) => toggleFilters(2)} className='active'>collaborative</button> : <button onClick={(e) => toggleFilters(2)} >collaborative</button>}\r\n            </div>\r\n        );\r\n    }\r\n\r\n    const CatalogMode = () => {\r\n        return (<>\r\n            <div className={'right'}>\r\n                <span>sorted by <span style={{paddingLeft: '6px'}}>{icon[sortingMode]} </span></span>\r\n                <Menu position={'left'}>\r\n                    <Item icon={icon['alphabetical']} action={(e)=> {setSortingMode('alphabetical')}}>Alphabetical {sortingMode === 'alphabetical' && <i style={{float: 'right'}} className=\"bi bi-check-lg\"></i>}</Item>\r\n                    <Item icon={icon['created']} action={(e)=> {setSortingMode('created')}}>Date created {sortingMode === 'created' && <i style={{float: 'right'}} className=\"bi bi-check-lg\"></i>}</Item>\r\n                    <Item icon={icon['modified']} action={(e)=> {setSortingMode('modified')}}>Last modified {sortingMode === 'modified' && <i style={{float: 'right'}} className=\"bi bi-check-lg\"></i>}</Item>\r\n                </Menu>\r\n                <div className={'view-icons'}>\r\n                    <i onClick={(e) => setMode('cards')} className={`bi bi-grid ${mode === \"cards\" && 'selected'}`}></i>\r\n                    <i onClick={(e) => setMode('list')} className={`bi bi-list ${mode === \"list\" && 'selected'}`}></i>\r\n                </div>\r\n            </div>\r\n        </>);\r\n    }\r\n\r\n    const CatalogSide = (props: ChildrenType) => {\r\n        return (\r\n            <div className={'catalog'}>\r\n                {props.children}\r\n            </div>\r\n        );\r\n    }\r\n\r\n\r\n\r\n    type CatalogType = {\r\n        projects: LProject[];\r\n    }\r\n\r\n    const CatalogReport = (props: CatalogType) => {\r\n\r\n\r\n        var items = props.projects\r\n            .filter(p =>\r\n                (filters[0] && p.type ===\"public\" || filters[1] && p.type ===\"private\" || filters[2] && p.type ===\"collaborative\" || !filters[0] && !filters[1] && !filters[2]));\r\n        \r\n        var sorted = items;\r\n        var iteratees: ((obj: LProject) => any) | string = 'created';\r\n\r\n        switch(sortingMode) {\r\n            case \"alphabetical\":\r\n                sorted = _.sortBy(items, 'name');\r\n                break;\r\n            case \"created\":\r\n                iteratees = (obj: LProject) => -new Date(obj.creation).getTime();\r\n                sorted = _.sortBy(items, iteratees);\r\n                break;\r\n            case \"modified\":\r\n                iteratees = (obj: LProject) => -new Date(obj.lastModified).getTime();\r\n                sorted = _.sortBy(items, iteratees);\r\n                break;\r\n        }\r\n\r\n        return (\r\n\r\n            mode == \"cards\" ?\r\n\r\n                /* cards mode */\r\n\r\n                <div className={'card-holder'}>\r\n\r\n                    {items.length === 0 && <div className={\"fallback-message\"}><span>\r\n                        Sorry, there are no results matching your search criteria. Please try again with different filters.\r\n                    </span></div>}\r\n\r\n                    {\r\n                        sorted.map((p,i) => <Project key={i} data={p} mode={mode} />)\r\n                    }\r\n\r\n                </div>\r\n\r\n            :\r\n                /* list mode */\r\n\r\n                <div className={'row project-list'}>\r\n                    <div className='row header'>\r\n                        <div className={'col-4'}>Name</div>\r\n                        <div className={'col-1'}>Type</div>\r\n                        <div className={'col-3'}>Created</div>\r\n                        <div className={'col-2'}>Last modified</div>\r\n                        <div className={'col-2'}>Operation</div>\r\n                    </div>\r\n                    {\r\n                        sorted.map(p => <>\r\n                            {filters[0] && p.type === \"public\" && <Project key={p.id} data={p} mode={mode} />}\r\n                            {filters[1] && p.type === \"private\" && <Project key={p.id} data={p} mode={mode} />}\r\n                            {filters[2] && p.type === \"collaborative\" && <Project key={p.id} data={p} mode={mode} />}\r\n                            {!filters[0] && !filters[1] && !filters[2] && <Project key={p.id} data={p} mode={mode} />}\r\n                        </>)\r\n                    }\r\n                </div>\r\n\r\n        );\r\n    };\r\n\r\n    return (\r\n        <>\r\n            <Header>\r\n                <CatalogFilters />\r\n                <CatalogMode />\r\n            </Header>\r\n            <CatalogSide>\r\n                <CatalogInfoCard projects={props.projects}/>\r\n                <CatalogReport projects={props.projects}/>\r\n            </CatalogSide>\r\n        </>\r\n    );\r\n}\r\n\r\nexport {Catalog}\r\n","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\pages\\components\\LatestUpdates.tsx",[],"C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\hooks\\useQuery.ts",[],"C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\pages\\components\\Edit\\Edit.tsx",["1677"],"\r\nimport { UsersApi } from '../../../api/persistance/users';\r\nimport { Tooltip } from '../../../components/forEndUser/Tooltip';\r\nimport './edit.scss';\r\n\r\ntype EditProps = {\r\n    id: string;\r\n    name: string;\r\n    label: string;\r\n    type: 'text' | 'email' | 'password' | 'checkbox' | 'country';\r\n    value: string;\r\n    required?: boolean;\r\n    disabled?: boolean;\r\n    tooltip?:string;\r\n    className?:string;\r\n    onChange?: (e: any)=>void; // MouseEvent\r\n}\r\n\r\nconst EditCountry = (props: EditProps) => {\r\n\r\n    let required = props.required ? props.required : false;\r\n    let disabled = props.disabled ? props.disabled : false;\r\n    let tooltip = props.tooltip ? props.tooltip : '';\r\n    let className = props.className ? props.className : '';\r\n    return(\r\n        <div className={'form-group edit'}>\r\n            <Tooltip tooltip={tooltip}>\r\n                <label>\r\n                    <span>{props.label}</span>\r\n                    <select className={\"form-control \" + className} \r\n                        name={props.name}\r\n                        style={{height: 'calc(var(--input-height)*1.3)'}} \r\n                        defaultValue={props.value} \r\n                        required={required}\r\n                        disabled = {disabled}\r\n                        onChange={props.onChange}>\r\n                            \r\n                        <option value=\"Afghanistan\">Afghanistan</option>\r\n                        <option value=\"Åland Islands\">Åland Islands</option>\r\n                        <option value=\"Albania\">Albania</option>\r\n                        <option value=\"Algeria\">Algeria</option>\r\n                        <option value=\"American Samoa\">American Samoa</option>\r\n                        <option value=\"Andorra\">Andorra</option>\r\n                        <option value=\"Angola\">Angola</option>\r\n                        <option value=\"Anguilla\">Anguilla</option>\r\n                        <option value=\"Antarctica\">Antarctica</option>\r\n                        <option value=\"Antigua and Barbuda\">Antigua and Barbuda</option>\r\n                        <option value=\"Argentina\">Argentina</option>\r\n                        <option value=\"Armenia\">Armenia</option>\r\n                        <option value=\"Aruba\">Aruba</option>\r\n                        <option value=\"Australia\">Australia</option>\r\n                        <option value=\"Austria\">Austria</option>\r\n                        <option value=\"Azerbaijan\">Azerbaijan</option>\r\n                        <option value=\"Bahamas\">Bahamas</option>\r\n                        <option value=\"Bahrain\">Bahrain</option>\r\n                        <option value=\"Bangladesh\">Bangladesh</option>\r\n                        <option value=\"Barbados\">Barbados</option>\r\n                        <option value=\"Belarus\">Belarus</option>\r\n                        <option value=\"Belgium\">Belgium</option>\r\n                        <option value=\"Belize\">Belize</option>\r\n                        <option value=\"Benin\">Benin</option>\r\n                        <option value=\"Bermuda\">Bermuda</option>\r\n                        <option value=\"Bhutan\">Bhutan</option>\r\n                        <option value=\"Bolivia\">Bolivia</option>\r\n                        <option value=\"Bosnia and Herzegovina\">Bosnia and Herzegovina</option>\r\n                        <option value=\"Botswana\">Botswana</option>\r\n                        <option value=\"Bouvet Island\">Bouvet Island</option>\r\n                        <option value=\"Brazil\">Brazil</option>\r\n                        <option value=\"British Indian Ocean Territory\">British Indian Ocean Territory</option>\r\n                        <option value=\"Brunei Darussalam\">Brunei Darussalam</option>\r\n                        <option value=\"Bulgaria\">Bulgaria</option>\r\n                        <option value=\"Burkina Faso\">Burkina Faso</option>\r\n                        <option value=\"Burundi\">Burundi</option>\r\n                        <option value=\"Cambodia\">Cambodia</option>\r\n                        <option value=\"Cameroon\">Cameroon</option>\r\n                        <option value=\"Canada\">Canada</option>\r\n                        <option value=\"Cape Verde\">Cape Verde</option>\r\n                        <option value=\"Cayman Islands\">Cayman Islands</option>\r\n                        <option value=\"Central African Republic\">Central African Republic</option>\r\n                        <option value=\"Chad\">Chad</option>\r\n                        <option value=\"Chile\">Chile</option>\r\n                        <option value=\"China\">China</option>\r\n                        <option value=\"Christmas Island\">Christmas Island</option>\r\n                        <option value=\"Cocos (Keeling) Islands\">Cocos (Keeling) Islands</option>\r\n                        <option value=\"Colombia\">Colombia</option>\r\n                        <option value=\"Comoros\">Comoros</option>\r\n                        <option value=\"Congo\">Congo</option>\r\n                        <option value=\"Congo, The Democratic Republic of The\">Congo, The Democratic Republic of The</option>\r\n                        <option value=\"Cook Islands\">Cook Islands</option>\r\n                        <option value=\"Costa Rica\">Costa Rica</option>\r\n                        <option value=\"Cote D'ivoire\">Cote D'ivoire</option>\r\n                        <option value=\"Croatia\">Croatia</option>\r\n                        <option value=\"Cuba\">Cuba</option>\r\n                        <option value=\"Cyprus\">Cyprus</option>\r\n                        <option value=\"Czech Republic\">Czech Republic</option>\r\n                        <option value=\"Denmark\">Denmark</option>\r\n                        <option value=\"Djibouti\">Djibouti</option>\r\n                        <option value=\"Dominica\">Dominica</option>\r\n                        <option value=\"Dominican Republic\">Dominican Republic</option>\r\n                        <option value=\"Ecuador\">Ecuador</option>\r\n                        <option value=\"Egypt\">Egypt</option>\r\n                        <option value=\"El Salvador\">El Salvador</option>\r\n                        <option value=\"Equatorial Guinea\">Equatorial Guinea</option>\r\n                        <option value=\"Eritrea\">Eritrea</option>\r\n                        <option value=\"Estonia\">Estonia</option>\r\n                        <option value=\"Ethiopia\">Ethiopia</option>\r\n                        <option value=\"Falkland Islands (Malvinas)\">Falkland Islands (Malvinas)</option>\r\n                        <option value=\"Faroe Islands\">Faroe Islands</option>\r\n                        <option value=\"Fiji\">Fiji</option>\r\n                        <option value=\"Finland\">Finland</option>\r\n                        <option value=\"France\">France</option>\r\n                        <option value=\"French Guiana\">French Guiana</option>\r\n                        <option value=\"French Polynesia\">French Polynesia</option>\r\n                        <option value=\"French Southern Territories\">French Southern Territories</option>\r\n                        <option value=\"Gabon\">Gabon</option>\r\n                        <option value=\"Gambia\">Gambia</option>\r\n                        <option value=\"Georgia\">Georgia</option>\r\n                        <option value=\"Germany\">Germany</option>\r\n                        <option value=\"Ghana\">Ghana</option>\r\n                        <option value=\"Gibraltar\">Gibraltar</option>\r\n                        <option value=\"Greece\">Greece</option>\r\n                        <option value=\"Greenland\">Greenland</option>\r\n                        <option value=\"Grenada\">Grenada</option>\r\n                        <option value=\"Guadeloupe\">Guadeloupe</option>\r\n                        <option value=\"Guam\">Guam</option>\r\n                        <option value=\"Guatemala\">Guatemala</option>\r\n                        <option value=\"Guernsey\">Guernsey</option>\r\n                        <option value=\"Guinea\">Guinea</option>\r\n                        <option value=\"Guinea-bissau\">Guinea-bissau</option>\r\n                        <option value=\"Guyana\">Guyana</option>\r\n                        <option value=\"Haiti\">Haiti</option>\r\n                        <option value=\"Heard Island and Mcdonald Islands\">Heard Island and Mcdonald Islands</option>\r\n                        <option value=\"Holy See (Vatican City State)\">Holy See (Vatican City State)</option>\r\n                        <option value=\"Honduras\">Honduras</option>\r\n                        <option value=\"Hong Kong\">Hong Kong</option>\r\n                        <option value=\"Hungary\">Hungary</option>\r\n                        <option value=\"Iceland\">Iceland</option>\r\n                        <option value=\"India\">India</option>\r\n                        <option value=\"Indonesia\">Indonesia</option>\r\n                        <option value=\"Iran, Islamic Republic of\">Iran, Islamic Republic of</option>\r\n                        <option value=\"Iraq\">Iraq</option>\r\n                        <option value=\"Ireland\">Ireland</option>\r\n                        <option value=\"Isle of Man\">Isle of Man</option>\r\n                        <option value=\"Israel\">Israel</option>\r\n                        <option value=\"Italy\">Italy</option>\r\n                        <option value=\"Jamaica\">Jamaica</option>\r\n                        <option value=\"Japan\">Japan</option>\r\n                        <option value=\"Jersey\">Jersey</option>\r\n                        <option value=\"Jordan\">Jordan</option>\r\n                        <option value=\"Kazakhstan\">Kazakhstan</option>\r\n                        <option value=\"Kenya\">Kenya</option>\r\n                        <option value=\"Kiribati\">Kiribati</option>\r\n                        <option value=\"Korea, Democratic People's Republic of\">Korea, Democratic People's Republic of</option>\r\n                        <option value=\"Korea, Republic of\">Korea, Republic of</option>\r\n                        <option value=\"Kuwait\">Kuwait</option>\r\n                        <option value=\"Kyrgyzstan\">Kyrgyzstan</option>\r\n                        <option value=\"Lao People's Democratic Republic\">Lao People's Democratic Republic</option>\r\n                        <option value=\"Latvia\">Latvia</option>\r\n                        <option value=\"Lebanon\">Lebanon</option>\r\n                        <option value=\"Lesotho\">Lesotho</option>\r\n                        <option value=\"Liberia\">Liberia</option>\r\n                        <option value=\"Libyan Arab Jamahiriya\">Libyan Arab Jamahiriya</option>\r\n                        <option value=\"Liechtenstein\">Liechtenstein</option>\r\n                        <option value=\"Lithuania\">Lithuania</option>\r\n                        <option value=\"Luxembourg\">Luxembourg</option>\r\n                        <option value=\"Macao\">Macao</option>\r\n                        <option value=\"Macedonia, The Former Yugoslav Republic of\">Macedonia, The Former Yugoslav Republic of</option>\r\n                        <option value=\"Madagascar\">Madagascar</option>\r\n                        <option value=\"Malawi\">Malawi</option>\r\n                        <option value=\"Malaysia\">Malaysia</option>\r\n                        <option value=\"Maldives\">Maldives</option>\r\n                        <option value=\"Mali\">Mali</option>\r\n                        <option value=\"Malta\">Malta</option>\r\n                        <option value=\"Marshall Islands\">Marshall Islands</option>\r\n                        <option value=\"Martinique\">Martinique</option>\r\n                        <option value=\"Mauritania\">Mauritania</option>\r\n                        <option value=\"Mauritius\">Mauritius</option>\r\n                        <option value=\"Mayotte\">Mayotte</option>\r\n                        <option value=\"Mexico\">Mexico</option>\r\n                        <option value=\"Micronesia, Federated States of\">Micronesia, Federated States of</option>\r\n                        <option value=\"Moldova, Republic of\">Moldova, Republic of</option>\r\n                        <option value=\"Monaco\">Monaco</option>\r\n                        <option value=\"Mongolia\">Mongolia</option>\r\n                        <option value=\"Montenegro\">Montenegro</option>\r\n                        <option value=\"Montserrat\">Montserrat</option>\r\n                        <option value=\"Morocco\">Morocco</option>\r\n                        <option value=\"Mozambique\">Mozambique</option>\r\n                        <option value=\"Myanmar\">Myanmar</option>\r\n                        <option value=\"Namibia\">Namibia</option>\r\n                        <option value=\"Nauru\">Nauru</option>\r\n                        <option value=\"Nepal\">Nepal</option>\r\n                        <option value=\"Netherlands\">Netherlands</option>\r\n                        <option value=\"Netherlands Antilles\">Netherlands Antilles</option>\r\n                        <option value=\"New Caledonia\">New Caledonia</option>\r\n                        <option value=\"New Zealand\">New Zealand</option>\r\n                        <option value=\"Nicaragua\">Nicaragua</option>\r\n                        <option value=\"Niger\">Niger</option>\r\n                        <option value=\"Nigeria\">Nigeria</option>\r\n                        <option value=\"Niue\">Niue</option>\r\n                        <option value=\"Norfolk Island\">Norfolk Island</option>\r\n                        <option value=\"Northern Mariana Islands\">Northern Mariana Islands</option>\r\n                        <option value=\"Norway\">Norway</option>\r\n                        <option value=\"Oman\">Oman</option>\r\n                        <option value=\"Pakistan\">Pakistan</option>\r\n                        <option value=\"Palau\">Palau</option>\r\n                        <option value=\"Palestinian Territory, Occupied\">Palestinian Territory, Occupied</option>\r\n                        <option value=\"Panama\">Panama</option>\r\n                        <option value=\"Papua New Guinea\">Papua New Guinea</option>\r\n                        <option value=\"Paraguay\">Paraguay</option>\r\n                        <option value=\"Peru\">Peru</option>\r\n                        <option value=\"Philippines\">Philippines</option>\r\n                        <option value=\"Pitcairn\">Pitcairn</option>\r\n                        <option value=\"Poland\">Poland</option>\r\n                        <option value=\"Portugal\">Portugal</option>\r\n                        <option value=\"Puerto Rico\">Puerto Rico</option>\r\n                        <option value=\"Qatar\">Qatar</option>\r\n                        <option value=\"Reunion\">Reunion</option>\r\n                        <option value=\"Romania\">Romania</option>\r\n                        <option value=\"Russian Federation\">Russian Federation</option>\r\n                        <option value=\"Rwanda\">Rwanda</option>\r\n                        <option value=\"Saint Helena\">Saint Helena</option>\r\n                        <option value=\"Saint Kitts and Nevis\">Saint Kitts and Nevis</option>\r\n                        <option value=\"Saint Lucia\">Saint Lucia</option>\r\n                        <option value=\"Saint Pierre and Miquelon\">Saint Pierre and Miquelon</option>\r\n                        <option value=\"Saint Vincent and The Grenadines\">Saint Vincent and The Grenadines</option>\r\n                        <option value=\"Samoa\">Samoa</option>\r\n                        <option value=\"San Marino\">San Marino</option>\r\n                        <option value=\"Sao Tome and Principe\">Sao Tome and Principe</option>\r\n                        <option value=\"Saudi Arabia\">Saudi Arabia</option>\r\n                        <option value=\"Senegal\">Senegal</option>\r\n                        <option value=\"Serbia\">Serbia</option>\r\n                        <option value=\"Seychelles\">Seychelles</option>\r\n                        <option value=\"Sierra Leone\">Sierra Leone</option>\r\n                        <option value=\"Singapore\">Singapore</option>\r\n                        <option value=\"Slovakia\">Slovakia</option>\r\n                        <option value=\"Slovenia\">Slovenia</option>\r\n                        <option value=\"Solomon Islands\">Solomon Islands</option>\r\n                        <option value=\"Somalia\">Somalia</option>\r\n                        <option value=\"South Africa\">South Africa</option>\r\n                        <option value=\"South Georgia and The South Sandwich Islands\">South Georgia and The South Sandwich Islands</option>\r\n                        <option value=\"Spain\">Spain</option>\r\n                        <option value=\"Sri Lanka\">Sri Lanka</option>\r\n                        <option value=\"Sudan\">Sudan</option>\r\n                        <option value=\"Suriname\">Suriname</option>\r\n                        <option value=\"Svalbard and Jan Mayen\">Svalbard and Jan Mayen</option>\r\n                        <option value=\"Swaziland\">Swaziland</option>\r\n                        <option value=\"Sweden\">Sweden</option>\r\n                        <option value=\"Switzerland\">Switzerland</option>\r\n                        <option value=\"Syrian Arab Republic\">Syrian Arab Republic</option>\r\n                        <option value=\"Taiwan\">Taiwan</option>\r\n                        <option value=\"Tajikistan\">Tajikistan</option>\r\n                        <option value=\"Tanzania, United Republic of\">Tanzania, United Republic of</option>\r\n                        <option value=\"Thailand\">Thailand</option>\r\n                        <option value=\"Timor-leste\">Timor-leste</option>\r\n                        <option value=\"Togo\">Togo</option>\r\n                        <option value=\"Tokelau\">Tokelau</option>\r\n                        <option value=\"Tonga\">Tonga</option>\r\n                        <option value=\"Trinidad and Tobago\">Trinidad and Tobago</option>\r\n                        <option value=\"Tunisia\">Tunisia</option>\r\n                        <option value=\"Turkey\">Turkey</option>\r\n                        <option value=\"Turkmenistan\">Turkmenistan</option>\r\n                        <option value=\"Turks and Caicos Islands\">Turks and Caicos Islands</option>\r\n                        <option value=\"Tuvalu\">Tuvalu</option>\r\n                        <option value=\"Uganda\">Uganda</option>\r\n                        <option value=\"Ukraine\">Ukraine</option>\r\n                        <option value=\"United Arab Emirates\">United Arab Emirates</option>\r\n                        <option value=\"United Kingdom\">United Kingdom</option>\r\n                        <option value=\"United States\">United States</option>\r\n                        <option value=\"United States Minor Outlying Islands\">United States Minor Outlying Islands</option>\r\n                        <option value=\"Uruguay\">Uruguay</option>\r\n                        <option value=\"Uzbekistan\">Uzbekistan</option>\r\n                        <option value=\"Vanuatu\">Vanuatu</option>\r\n                        <option value=\"Venezuela\">Venezuela</option>\r\n                        <option value=\"Viet Nam\">Viet Nam</option>\r\n                        <option value=\"Virgin Islands, British\">Virgin Islands, British</option>\r\n                        <option value=\"Virgin Islands, U.S.\">Virgin Islands, U.S.</option>\r\n                        <option value=\"Wallis and Futuna\">Wallis and Futuna</option>\r\n                        <option value=\"Western Sahara\">Western Sahara</option>\r\n                        <option value=\"Yemen\">Yemen</option>\r\n                        <option value=\"Zambia\">Zambia</option>\r\n                        <option value=\"Zimbabwe\">Zimbabwe</option>\r\n                    </select>\r\n                </label>\r\n            </Tooltip>\r\n        </div>\r\n    );\r\n}\r\n\r\nconst EditCheckbox = (props: EditProps) => {\r\n\r\n    let required = props.required ? props.required : false;\r\n    let disabled = props.disabled ? props.disabled : false;\r\n    let tooltip = props.tooltip ? props.tooltip : '';\r\n    let className = props.className ? props.className : '';\r\n\r\n    return (\r\n        <div className={'form-group edit checkbox'}>\r\n            <Tooltip tooltip={tooltip}>\r\n                <label>\r\n                    <input className={'input text-start d-block mt-2 '+className}\r\n                        type={\"checkbox\"} \r\n                        required={required}\r\n                        disabled={disabled}\r\n                        checked={props.value === 'true'? true: false}\r\n                        onChange={props.onChange}\r\n                    />\r\n                    <span>{props.label}{props.required && <> (*)</>}</span>\r\n                </label>\r\n            </Tooltip>\r\n        </div>\r\n    );\r\n\r\n}\r\n\r\nconst EditDefault = (props: EditProps) => {\r\n\r\n    let required = props.required ? props.required : false;\r\n    let disabled = props.disabled ? props.disabled : false;\r\n    let tooltip = props.tooltip ? props.tooltip : '';\r\n    let className = props.className ? props.className : '';\r\n    return (<>\r\n        \r\n        <div className={'form-group edit ' + className}>\r\n\r\n            <Tooltip tooltip={tooltip}>\r\n                <label>\r\n                    <span>{props.label}{props.required && <> (*)</>}</span>\r\n                    \r\n                    <input className={'input text-start d-block mt-2'}\r\n                        value={props.value}\r\n                        type={props.type}\r\n                        required={required}\r\n                        disabled = {disabled}\r\n                        onChange={props.onChange}\r\n                    />\r\n                    \r\n                </label>\r\n            </Tooltip>\r\n        </div>\r\n        \r\n    </>);\r\n}\r\n\r\nconst EditPassword = (props: EditProps) => {\r\n\r\n    let required = props.required ? props.required : false;\r\n    let disabled = props.disabled ? props.disabled : false;\r\n    let tooltip = props.tooltip ? props.tooltip : '';\r\n    let className = props.className ? props.className : '';\r\n\r\n    function focus_in(e: any) {\r\n        if (e.target.value === props.value) {\r\n            e.target.value = '';\r\n        } \r\n    }\r\n    function focus_out(e: any) {\r\n        if (e.target.value === '') {\r\n            e.target.value = props.value;\r\n        } \r\n    }\r\n\r\n    return (<>\r\n        \r\n        <div className={'form-group edit ' + className}>\r\n\r\n            <Tooltip tooltip={tooltip}>\r\n                <label>\r\n                    <span>{props.label}{props.required && <> (*)</>}</span>\r\n                    \r\n                    <input className={'input text-start d-block mt-2'}\r\n                        value={props.value}\r\n                        type={\"password\"}\r\n                        required={required}\r\n                        disabled = {disabled}\r\n                        onChange={props.onChange}\r\n                        onFocus={(e) => focus_in(e)}\r\n                        onBlur={(e) => focus_out(e)}\r\n                    />\r\n                    \r\n                </label>\r\n            </Tooltip>\r\n        </div>\r\n        \r\n    </>);\r\n}\r\n\r\n\r\nconst Edit = (props: EditProps) => {\r\n\r\n    return (<> \r\n        {props.type === 'country' && <EditCountry {...props}/>}\r\n        {props.type === 'checkbox' && <EditCheckbox {...props}/>}\r\n        {props.type === 'text' && <EditDefault {...props}/>}\r\n        {props.type === 'email' && <EditDefault {...props}/>}\r\n        {props.type === 'password' && <EditPassword {...props}/>}\r\n    </>);\r\n}\r\n\r\nexport {Edit, EditCountry};\r\n","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\components\\logo.tsx",["1678","1679","1680","1681","1682"],"import { TbHexagonLetterJ as Logo1} from \"react-icons/tb\";\r\nimport { IoLogoWebComponent as Logo2} from \"react-icons/io5\";\r\nimport {\r\n    TbSquareRoundedLetterM,\r\n    TbSquareRoundedLetterMFilled,\r\n    TbSquareRoundedLetterV,\r\n    TbSquareRoundedLetterVFilled,\r\n    TbSquareRoundedLetterE\r\n} from \"react-icons/tb\";\r\n\r\nimport { int } from \"../joiner/types\";\r\n\r\ntype LogoProps = {\r\n    style?: any;\r\n    className?: any;\r\n}\r\n\r\nexport const Logo = (props: LogoProps) => {\r\n    return (<Logo1 style={props.style && props.style} className={`logo ${props.className && props.className}`} />);\r\n}\r\n\r\nexport const MetamodelIcon = (props: LogoProps) => {\r\n    return (<TbSquareRoundedLetterMFilled style={props.style && props.style} className={`logo ${props.className && props.className}`} />);\r\n}\r\n\r\nexport const ModelIcon = (props: LogoProps) => {\r\n    return (<TbSquareRoundedLetterM style={props.style && props.style} className={`logo ${props.className && props.className}`} />);\r\n}","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\components\\abstract\\Dock.tsx",["1683","1684"],"import './style.scss';\r\nimport {Dispatch, ReactElement} from 'react';\r\nimport {connect} from 'react-redux';\r\nimport {DState, DUser, LProject, LUser} from '../../joiner';\r\nimport {FakeStateProps, windoww} from '../../joiner/types';\r\nimport {LayoutData} from 'rc-dock';\r\nimport {Collaborative, Console, Info, Logger, Skeleton, MetaData, NestedView} from \"../editors\";\r\nimport {NodeEditor} from \"../editors/NodeEditor\";\r\nimport DockManager from './DockManager';\r\nimport {PinnableDock, TabContent, TabHeader} from '../dock/MyRcDock';\r\nimport ModelsSummaryTab from \"./tabs/ModelsSummaryTab\";\r\nimport BrokerEditor from \"../editors/Broker\";\r\nimport {PermissionModelTab} from \"../editors/PermissionModelTab\";\r\nimport {MTM} from \"../editors/MTM\";\r\nimport { isProjectModified } from '../../common/libraries/projectModified';\r\nimport { Logo } from '../../components/logo';\r\n//import MqttEditor from \"../rightbar/mqtt/MqttEditor\";\r\n//import NestedView from \"../rightbar/nestedViewEditor/ViewEditorNestedVersion\";\r\n//import CollaboratorsEditor from \"../rightbar/collaboratorsEditor/CollaboratorsEditor\";\r\n\r\n\r\n\r\n\r\n\r\n\r\nconst tabidprefix = \"DockComponent_rightbar_\";\r\nlet idcounter = 0;\r\nfunction id(){ // NB: cannot use just indexes or tab title because the id is injected in html, so it must be unique in the whole page.\r\n    return tabidprefix + (++idcounter);\r\n}\r\nfunction tid(){\r\n    return tabidprefix + (idcounter);\r\n}\r\n\r\nfunction DockComponent(props: AllProps) {\r\n    const {user} = props;\r\n    const groups = {\r\n        'models': {floatable: true, maximizable: true},\r\n        'editors': {floatable: true, maximizable: true}\r\n    };\r\n\r\n    /* Models */\r\n    // const ModelsSummary = {id: id(), title: <TabHeader tid={tid()}><JLogo style={{marginLeft: '-10px', fontSize: '1.5rem', paddingRight: '6px'}}/> Summary</TabHeader>, group: 'models', closable: false, content: <TabContent tid={tid()}><ModelsSummaryTab /></TabContent>};\r\n\r\n    const ModelsSummary = {id: id(), title: <TabHeader tid={tid()}><Logo style={{marginLeft: '-10px', fontSize: '1.5rem', paddingRight: '6px'}}/> {user?.project?.name}</TabHeader>, group: 'models', closable: false, content: <TabContent tid={tid()}><ModelsSummaryTab /></TabContent>};\r\n\r\n\r\n    /* Editors */\r\n\r\n    let advanced:boolean = windoww.advanced;\r\n    \r\n    //const test = {id: id(), title: 'Test', group: 'editors', closable: false, content: <TestTab />};\r\n    const structure = {id: id(), title: <TabHeader tid={tid()}>Properties</TabHeader>, group: 'editors', closable: false, content: <TabContent tid={tid()}><Info /></TabContent>};\r\n    const metadata = {id: id(), title: <TabHeader tid={tid()}>Metadata</TabHeader>, group: 'editors', closable: false, content: <TabContent tid={tid()}><MetaData /></TabContent>};\r\n    const tree = {id: id(), title: <TabHeader tid={tid()}>Tree View</TabHeader>, group: 'editors', closable: false, content: <TabContent tid={tid()}><Skeleton /></TabContent>};\r\n    // const views = {id: id(), title: <TabHeader tid={tid()}>Views</TabHeader>, group: 'editors', closable: false, content: <TabContent tid={tid()}><Views /></TabContent>};\r\n    const node = {id: id(), title: <TabHeader tid={tid()}>Node</TabHeader>, group: 'editors', closable: false, content: <TabContent tid={tid()}><NodeEditor /></TabContent>};\r\n    const views = {id: id(), title: <TabHeader tid={tid()}>Viewpoints</TabHeader>, group: 'editors', closable: false, content: <TabContent tid={tid()}><NestedView /></TabContent>};\r\n    //const validation = {id: id(), title: <TabHeader tid={tid()}>Validation</TabHeader>, group: 'editors', closable: false, content: <TabContent tid={tid()}><ViewpointEditor validation={true} /></TabContent>};\r\n    const collaborative = {id: id(), title: <TabHeader tid={tid()}>Collaborative</TabHeader>, group: 'editors', closable: false, content: <TabContent tid={tid()}><Collaborative /></TabContent>};\r\n    //const mqtt = {id: id(), title: <TabHeader tid={tid()}>Mqtt</TabHeader>, group: 'editors', closable: false, content: <TabContent tid={tid()}><MqttEditor /></TabContent>};\r\n    const broker = {id: id(), title: <TabHeader tid={tid()}>Broker</TabHeader>, group: 'editors', closable: false, content: <TabContent tid={tid()}><BrokerEditor /></TabContent>};\r\n    const console = {id: id(), title: <TabHeader tid={tid()}>Console</TabHeader>, group: 'editors', closable: false, content: <TabContent tid={tid()}><Console /></TabContent>};\r\n    const logger = {id: id(), title: <TabHeader tid={tid()}>Logger</TabHeader>, group: 'editors', closable: false, content: <TabContent tid={tid()}><Logger/></TabContent>};\r\n    const permissions = {id: id(), title: <TabHeader tid={tid()}>Permissions</TabHeader>, group: 'editors', closable: false, content: <TabContent tid={tid()}><PermissionModelTab/></TabContent>};\r\n    const mtm = {id: id(), title: <TabHeader tid={tid()}>M→T→M</TabHeader>, group: 'editors', closable: false, content: <TabContent tid={tid()}><MTM/></TabContent>};\r\n\r\n    const layout: LayoutData = {dockbox: {mode: 'horizontal', children: []}};\r\n    layout.dockbox.children.push({tabs: [ModelsSummary]});\r\n\r\n    const tabs = [];\r\n    tabs.push(structure);\r\n    tabs.push(tree);\r\n    tabs.push(views);\r\n    if (advanced) tabs.push(metadata);\r\n    if (advanced) tabs.push(broker);\r\n    tabs.push(node);\r\n    tabs.push(console);\r\n    if (advanced) tabs.push(mtm);\r\n    if (advanced) tabs.push(logger);\r\n\r\n    if (user?.project?.type === 'collaborative') tabs.push(collaborative);\r\n    if (false && user?.project?.type === 'collaborative') tabs.push(permissions);\r\n    layout.dockbox.children.push({tabs});\r\n\r\n    return (<PinnableDock key={''+advanced} ref={dock => DockManager.dock = dock} defaultLayout={layout} groups={groups} />);\r\n}\r\ninterface OwnProps {}\r\ninterface StateProps {\r\n    user: LUser|null\r\n}\r\ninterface DispatchProps {}\r\ntype AllProps = OwnProps & StateProps & DispatchProps;\r\n\r\n\r\nfunction mapStateToProps(state: DState, ownProps: OwnProps): StateProps {\r\n    const ret: StateProps = {} as FakeStateProps;\r\n    if(DUser.current) ret.user = LUser.fromPointer(DUser.current);\r\n    else ret.user = null;\r\n    return ret;\r\n}\r\n\r\nfunction mapDispatchToProps(dispatch: Dispatch<any>): DispatchProps {\r\n    const ret: DispatchProps = {};\r\n    return ret;\r\n}\r\n\r\nexport const DockConnected = connect<StateProps, DispatchProps, OwnProps, DState>(\r\n    mapStateToProps,\r\n    mapDispatchToProps\r\n)(DockComponent);\r\n\r\nconst Dock = (props: OwnProps, children: (string | React.Component)[] = []): ReactElement => {\r\n    return <DockConnected {...{...props, children}} />;\r\n}\r\n\r\nexport default Dock;\r\n\r\n","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\pages\\components\\icons\\Icons.tsx",["1685","1686","1687","1688"],"import './icons.scss';\r\n\r\nimport jj from '../../../static/img/jj-k.png';\r\nimport { Tooltip } from '../../../components/forEndUser/Tooltip';\r\nimport { Logo, MetamodelIcon, ModelIcon } from '../../../components/logo';\r\n\r\nimport { LuPackage2 } from \"react-icons/lu\";\r\nimport { CgToolbarTop as Toolbar } from \"react-icons/cg\";\r\n\r\nexport let icon: { [name: string]: any} = {\r\n    'new': <i className=\"bi bi-plus-circle-dotted menuitem\"></i>,\r\n    close: <i className=\"bi bi-x-lg menuitem\"></i>,\r\n    edit: <i className=\"bi bi-pencil-square menuitem\"></i>,\r\n    duplicate: <i className=\"bi bi-files menuitem\"></i>,\r\n    copy: <i className=\"bi bi-files menuitem\"></i>,\r\n    undo: <i className=\"bi bi-arrow-counterclockwise menuitem\"></i>,\r\n    redo: <i className=\"bi bi-arrow-clockwise menuitem\"></i>,\r\n    save: <i className=\"bi bi-floppy menuitem\"></i>,\r\n    select: <i className=\"bi bi-check menuitem\"></i>,\r\n    deselect: <i className=\"bi bi-check2 menuitem\"></i>,\r\n    add: <i className=\"bi bi-plus-circle-dotted menuitem\"></i>,\r\n    validation: <i className=\"bi bi-check2-circle menuitem\"></i>,\r\n    validate: <i className=\"bi bi-clipboard-check menuitem\"></i>,\r\n    faq: <i className=\"bi bi-chat-left-dots menuitem\"></i>,\r\n    'user-guide': <i className=\"bi bi-journal-text menuitem\"></i>,\r\n    glossary: <i className=\"bi bi-book menuitem\"></i>,\r\n\r\n    'import': <i className=\"bi bi-cloud-upload menuitem\"></i>,\r\n    'export': <i className=\"bi bi-arrow-bar-right menuitem\"></i>,\r\n    download: <i className=\"bi bi-cloud-download menuitem\"></i>,\r\n\r\n    favorite: <i className=\"bi bi-star menuitem\"></i>,\r\n    favoriteFill: <i className=\"bi bi-star-fill menuitem\"></i>,\r\n    share: <i className=\"bi bi-share menuitem\"></i>,\r\n    delete: <i className=\"bi bi-trash3 menuitem\"></i>,\r\n    'delete-confirm': <i className=\"bi bi-question-square-fill menuitem confirm\"></i>,\r\n    refresh: <i className=\"bi bi-arrow-clockwise menuitem\"></i>,\r\n    up: <i className=\"bi bi-arrow-up menuitem\"></i>,\r\n    down: <i className=\"bi bi-arrow-down menuitem\"></i>,\r\n    lock: <i className=\"bi bi-lock menuitem\" style={{marginRight: '10px'}}></i>,\r\n    unlock: <i className=\"bi bi-unlock menuitem\" style={{marginRight: '10px'}}></i>,\r\n    view: <i className=\"bi bi-window-plus menuitem\"></i>,\r\n    grid: <i className=\"bi bi-grid-3x3-gap menuitem\"></i>,\r\n    maximize: <i className=\"bi bi-arrows-fullscreen menuitem\"></i>,\r\n    fullscreen: <i className=\"bi bi-arrows-fullscreen menuitem\"></i>,\r\n    'fullscreen-exit': <i className=\"bi bi-fullscreen-exit\"></i>,\r\n    'zoom-in': <i className=\"bi bi-zoom-in menuitem\"></i>,\r\n    'zoom-out': <i className=\"bi bi-zoom-out menuitem\"></i>,\r\n    help: <i className=\"bi bi-question-square menuitem\"></i>,\r\n    'whats-, Metamodel': <i className=\"bi bi-bell menuitem\"></i>,\r\n    home: <i className=\"bi bi-house menuitem\"></i>,\r\n    'getting-started': <i className=\"bi bi-airplane menuitem\"></i>,\r\n    manual: <i className=\"bi bi-journals menuitem\"></i>,\r\n    legal: <i className=\"bi bi-mortarboard menuitem\"></i>,\r\n    about: <Logo style={{width: 15}} className={'menuitem'}/>,\r\n    'jjodel-dark': <img src={jj} width={15} className={'menuitem'}/>,\r\n    'jjodel-clear': <img\r\n        style={{border: '1px solid var(--color)', borderRadius: '2px', marginTop: '2px', marginRight: '-2px'}} src={jj}\r\n        width={16} className={'menuitem'}/>,\r\n\r\n    jjodel: <Logo style={{fontSize: '1.5em'}} className={'menuitem'}/>,\r\n    metamodel: <MetamodelIcon className={'menuitem'} style={{fontSize: '1.5em'}}/>,\r\n    model: <ModelIcon className={'menuitem'} style={{fontSize: '1.5em'}}/>,\r\n    project: <LuPackage2 style={{fontSize: '1.5em'}} className='menuitem'/>,\r\n\r\n    logout: <i className=\"bi bi-box-arrow-right menuitem\"></i>,\r\n    dashboard2: <i className=\"bi bi-grid menuitem\"></i>,\r\n    dashboard: <i className=\"bi bi-columns-gap menuitem\"></i>,\r\n    profile: <i className=\"bi bi-person-square menuitem\"></i>,\r\n    settings: <i className=\"bi bi-sliders menuitem\"></i>,\r\n    recent: <i className=\"bi bi-clock-history menuitem\"></i>,\r\n    folder: <i className=\"bi bi-folder menuitem\"></i>,\r\n    template: <i className=\"bi bi-code-square menuitem\"></i>,\r\n    template2: <i className=\"bi bi-lightbulb menuitem\"></i>,\r\n    extend: <i className=\"bi bi-caret-up menuitem\" style={{paddingBottom: '2px'}}></i>,\r\n    ai: <i className=\"bi bi-stars\"></i>,\r\n    metrics: <i className=\"bi bi-graph-up\" style={{marginRight: '10px'}}></i>,\r\n    analytics: <i className=\"bi bi-graph-up menuitem\"></i>,\r\n    submenu: <i className=\"bi bi-chevron-right menuitem float-end\"></i>,\r\n    contract: <i className=\"bi bi-arrows-angle-contract\"></i>,\r\n    expand: <i className=\"bi bi-arrows-angle-expand\"></i>,\r\n    alphabetical: <i className=\"bi bi-sort-alpha-down\"></i>,\r\n    created: <i className=\"bi bi-calendar2-plus\"></i>,\r\n    modified: <i className=\"bi bi-clock\"></i>,\r\n    lastModified: <i className=\"bi bi-clock\"></i>,\r\n    link: <i style={{scale: '1.2'}}\r\n             className=\"bi bi-link-45deg menuitem\"></i>,\r\n    learn: <i className=\"bi bi-infinity menuitem\"></i>,\r\n    video: <i className=\"bi bi-youtube menuitem\"></i>,\r\n    roadmap: <i className=\"bi bi-calendar3 menuitem\"></i>,\r\n    support: <i className=\"bi bi-life-preserver menuitem\"></i>,\r\n    'report-bug': <i className=\"bi bi-bug menuitem\"></i>,\r\n    'feature-request': <i className=\"bi bi-hand-index menuitem\"></i>,\r\n    contact: <i className=\"bi bi-card-text menuitem\"></i>,\r\n    'toggle-grid': <i className=\"bi bi-grid-1x2 menuitem\"></i>,\r\n    'toggle-snap': <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"22\" height=\"22\" fill=\"currentColor\"\r\n                        className=\"bi bi-layout-sidebar\" viewBox=\"0 0 16 16\">\r\n        <path\r\n            d=\"M6 1H1v14h5z m9 0h-5v5h5zm0 9v5M0 1a1 1 0 0 1 1-1h5a1 1 0 0 1 1 1v14a1 1 0 0 1-1 1H1a1 1 0 0 1-1-1zm9 0a1 1 0 0 1 1-1h5a1 1 0 0 1 1 1v5a1 1 0 0 1-1 1h-5a1 1 0 0 1-1-1zm1 8a1 1 0 0 0-1 1v5a1 1 0 0 0 1 1h5a1 1 0 0 0 1-1v-5a1 1 0 0 0-1-1z\"/>\r\n    </svg>,\r\n    'reset-layout': <i className=\"bi bi-columns menuitem\"></i>,\r\n    sidebar: <i className=\"bi bi-layout-sidebar menuitem\"></i>,\r\n    toolbar2: <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"22\" height=\"22\" fill=\"currentColor\"\r\n                   className=\"bi bi-layout-sidebar\" viewBox=\"0 0 16 16\">\r\n        <path\r\n            d=\"M0 3a2 2 0 0 1 2-2h12a2 2 0 0 1 2 2v10a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2z m2 -1 a1 1 0 0 0 -1 1v2h14v-2a1 1 0 0 0 -1 -1zm -1 4l 0 7a1 1 0 0 0 1 1h12a1 1 0 0 0 1 -1v-7z\"/>\r\n    </svg>\r\n}\r\n\r\n","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\api\\persistance\\admin.ts",[],"C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\components\\commandbar\\CommandBar.tsx",["1689","1690","1691","1692","1693","1694","1695","1696"],"import React, {MouseEventHandler, ClassAttributes, useState, useRef, useEffect, ReactElement, ReactNode} from \"react\";\r\nimport './commandbar.scss';\r\nimport { inherits } from \"util\";\r\nimport { Tooltip } from \"../forEndUser/Tooltip\";\r\nimport { U } from \"../../joiner\";\r\n\r\ntype BtnProps = {\r\n    disabled?: boolean;\r\n    active?: boolean;\r\n    icon: \"up\"\r\n        | \"down\"\r\n        | \"back\"\r\n        | \"fwd\"\r\n        | \"add\"\r\n        | \"add2\"\r\n        | \"delete\"\r\n        | \"delete2\"\r\n        | \"open\"\r\n        | \"edit\"\r\n        | \"favorite\"\r\n        | \"shrink\"\r\n        | \"expand\"\r\n        | \"space\"\r\n        | \"minispace\"\r\n        | \"sep\"\r\n        | \"check\"\r\n        | \"copy\"\r\n        | \"close\"\r\n        | \"info\"\r\n        | \"show\"\r\n        | \"open-down\"\r\n        | \"close-up\"\r\n        | \"settings\"\r\n        | \"download\";\r\n\r\n    tip?: string | ReactNode;\r\n    label?: string;\r\n    theme?: \"dark\" | \"light\",\r\n    action?: MouseEventHandler,\r\n    size?: \"x-small\" | \"small\" | \"medium\" | \"large\",\r\n    style?: React.CSSProperties,\r\n    mode?: 'normal' | 'negative'\r\n    className?: string;\r\n    needConfirm?:boolean;\r\n}\r\n\r\n\r\nexport const Btn = (props: BtnProps) => {\r\n\r\n    const [askingConfirm, setConfirm] = useState(false);\r\n    const mode = (props.mode ? props.mode : 'normal');\r\n    let needConfirm = props.needConfirm || props.icon === 'delete' && !props.disabled;\r\n    let i_classes = (props.className||'') + ` bi tab-btn commandbar-btn ${askingConfirm ? 'bi-question-square-fill question': props.icon} ${props.theme ? props.theme : 'light'} ${props.size||''} ${mode} ${props.disabled ? 'disabled ' : ''}`\r\n    let action = (e: React.MouseEvent<any,any>) => {\r\n        console.log('commandbar action', {disabled: props.disabled, action:props.action, askingConfirm, needConfirm});\r\n        if (props.disabled || !props.action) return;\r\n        if (!askingConfirm && needConfirm) {\r\n            setConfirm(true);\r\n            U.clickedOutside(e, ()=> {\r\n                console.log('clicked outside remove confirm');\r\n                setConfirm(false)\r\n            });\r\n            return;\r\n        }\r\n        props.action(e);\r\n        e.stopPropagation();\r\n    }\r\n    let icon: ReactNode = null;\r\n\r\n    switch (props.icon){\r\n        case 'delete2':\r\n            icon = <div className={`delete2 ${props.theme ? props.theme : 'light'}`}>Delete</div>; break;\r\n\r\n        case 'delete':\r\n            icon = <Tooltip tooltip={askingConfirm ? 'Are you sure?' : props.tip} inline={true} position={'top'} offsetY={10} >\r\n                <i onClick={action} style={props.style} className={i_classes} />\r\n            </Tooltip>; break;\r\n\r\n        default:\r\n            icon = <Tooltip tooltip={props.tip} inline={true} position={'top'} offsetY={10}>\r\n                <i className={i_classes} onClick={action} style={props.style}/>\r\n            </Tooltip>; break;\r\n    }\r\n\r\n    if (props.icon === \"space\" || props.icon === \"minispace\") return <span style={{display: 'block', width: `${props.icon === 'space' ? '24px' : '4px'}`}} />;\r\n    return <div className={'btn-component '+(props.active ? 'active' : '')}>{icon}</div>;\r\n}\r\n\r\n\r\n\r\nexport const Sep = (style?: any) => {\r\n\r\n    return (<>\r\n            {style ?\r\n                <div>\r\n                    <div className={'tab-btn sep'}></div>\r\n                </div>\r\n            :\r\n                <div>\r\n                    <div className={'tab-btn sep'} style={style}></div>\r\n                </div>\r\n            }\r\n\r\n    </>);\r\n}\r\n\r\n\r\ntype CommandProps = {\r\n    children: any,\r\n    style?: React.CSSProperties,\r\n    className?: string,\r\n    noBorder?: boolean;\r\n}\r\n\r\nexport const CommandBar = (props: CommandProps) => {\r\n\r\n    let style = props.style;\r\n\r\n    let noBorder = (props.noBorder ? props.noBorder: false);\r\n\r\n    return(<>\r\n        {props.style ?\r\n            <div className={`command-bar ${props.className && props.className} ${noBorder && 'no-border'}`} style={props.style}>\r\n                {props.children}\r\n            </div>\r\n            :\r\n            <div className={`command-bar ${props.className && props.className} ${noBorder && 'no-border'}`} >\r\n                {props.children}\r\n            </div>\r\n        }\r\n\r\n    </>);\r\n};\r\n","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\api\\persistance\\auth.ts",["1697"],"import Api, {Response} from \"../api\";\r\nimport Storage from \"../../data/storage\";\r\nimport {DUser, U} from \"../../joiner\";\r\nimport {jwtDecode, JwtPayload} from \"jwt-decode\";\r\nimport { RegisterRequest } from \"../DTO/RegisterRequest\";\r\nimport { LoginRequest } from \"../DTO/LoginRequest\";\r\nimport { JwtClaims } from \"../DTO/JwtClaims\";\r\nimport { JwtPayloadKey } from \"../memorec/types\";\r\nimport {ResetPasswordRequest} from \"../DTO/ResetPasswordRequest\";\r\nimport {ConfirmAccountRequest} from \"../DTO/ConfirmAccountRequest\";\r\n\r\nclass AuthApi {\r\n\r\n    static async login(loginRequest: LoginRequest): Promise<Response> {\r\n        Storage.write('offline', false);\r\n\r\n        return await Api.post(`${Api.persistance}/account/login`, {...loginRequest}, true);\r\n\r\n    }\r\n  \r\n    static async register(request: RegisterRequest): Promise<Response> {\r\n        alert(\"TEST\")\r\n        Storage.write('offline', false);\r\n        return await Api.post(`${Api.persistance}/account/register`, {...request}, true);\r\n    \r\n    }\r\n\r\n    static async reset_password(request: ResetPasswordRequest): Promise<Response> {\r\n        return await Api.post(`${Api.persistance}/account/resetPasswordWithEmail`, {...request}, true);\r\n    }\r\n\r\n\r\n    static async logout(): Promise<void> {\r\n        Api.token = null;\r\n\r\n        U.resetState();\r\n        Storage.reset();\r\n    }\r\n    static async confirmAccount(request: ConfirmAccountRequest): Promise<Response> {\r\n        return await Api.post(`${Api.persistance}/account/confirm`, {...request}, true);\r\n    }\r\n\r\n\r\n    static offline(): void {\r\n        Storage.write('offline', true);\r\n        DUser.current = DUser.offline()?.id||'';\r\n    }\r\n\r\n    // decode jwt\r\n    static readJwtToken(token: string): JwtClaims | null {\r\n        try {\r\n            const decoded = jwtDecode<any>(token);\r\n            \r\n            const claims : JwtClaims = new JwtClaims();\r\n\r\n            claims.id = decoded[JwtPayloadKey.Id];\r\n            claims.nickname = decoded[JwtPayloadKey.Nickname];\r\n            console.log(\"readJwtToken per nickname\", claims.nickname);\r\n            claims.email = decoded[JwtPayloadKey.Email];\r\n            claims.role = decoded[JwtPayloadKey.Roles];\r\n            claims.exp = decoded[JwtPayloadKey.Exp];\r\n            claims.iss = decoded[JwtPayloadKey.Iss];\r\n            claims.aud = decoded[JwtPayloadKey.Aud];\r\n\r\n           return claims;\r\n\r\n        } catch (error) {\r\n            \r\n            console.error(\"Errore durante la decodifica del token:\", error);\r\n            return null;\r\n        }\r\n    }\r\n\r\n    // write storage\r\n    static storeSessionData(token: string, tokenExp: number, user :DUser): void {\r\n        Storage.write('token', token);\r\n        Storage.write('tokenExp', tokenExp);\r\n        Storage.write('user', user);\r\n        Storage.write('offline', false);\r\n    }\r\n}\r\n\r\nexport {AuthApi};\r\n","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\api\\persistance\\users.ts",["1698"],"import {DUser, LUser, U} from '../../joiner';\r\nimport Api from '../api';\r\nimport { ResetPasswordRequest } from '../DTO/ResetPasswordRequest';\r\nimport {UpdateUserRequest} from \"../DTO/UpdateUserRequest\";\r\nimport {ChangePasswordRequest} from \"../DTO/ChangePasswordRequest\";\r\n\r\nclass UsersApi {\r\n\r\n\r\n    static async getUserByEmail(email: string): Promise<LUser|null> {\r\n        const response = await Api.get(`${Api.persistance}/users?email=${email}`);\r\n        if(response.code !== 200) return null;\r\n        const user = U.wrapper<DUser>(response.data);\r\n        const rawUser = DUser.new(user.name, user.surname, user.nickname, user.affiliation, user.country, user.newsletter, user.email, '', user.id);\r\n        return LUser.fromD(rawUser);\r\n    }\r\n    static async getUserById(id: string): Promise<LUser|null> {\r\n        const response = await Api.get(`${Api.persistance}/users?id=${id}`);\r\n        if(response.code !== 200) return null;\r\n        const user = U.wrapper<DUser>(response.data);\r\n        const rawUser = DUser.new(user.name, user.surname, user.nickname, user.affiliation, user.country, user.newsletter, user.email, '', user.id);\r\n        return LUser.fromD(rawUser);\r\n    }\r\n\r\n    static async getAllEmails(): Promise<string[]> {\r\n        const response = await Api.get(`${Api.persistance}/users`);\r\n        if(response.code !== 200) return [];\r\n        const users = U.wrapper<DUser[]>(response.data);\r\n        return users.filter(u => u.id !== DUser.current).map(u => u.email);\r\n    }\r\n\r\n    static async updateUserById(updateUserRequest :UpdateUserRequest): Promise<LUser|null> {\r\n        console.log(\"JURI: \", updateUserRequest);\r\n\r\n        console.log({...updateUserRequest});\r\n        const response = await Api.put(`${Api.persistance}/account/`, {...updateUserRequest});\r\n        console.log(response.code, response.data);\r\n\r\n        if(response.code !== 200) {\r\n            return null\r\n        };\r\n        const user = U.wrapper<DUser>(response.data);  \r\n\r\n        return LUser.fromD(user); \r\n    }\r\n\r\n    /*\r\n    static async updateUserById(id: string, name: string, surname: string, nickname: string, country: string, affiliation: string, newsletter: boolean): Promise<LUser|null> {\r\n\r\n        const response = await Api.get(`${Api.persistance}/users?id=${id}`);\r\n\r\n        console.log(\"JURI: \", response);\r\n        alert();\r\n\r\n        if(response.code !== 200) return null;\r\n\r\n        const patch_response = await Api.patch(`${Api.persistance}/users/update?id=${id}`, {name: name, surname: surname, country: country, nickname: nickname, affiliation: affiliation, newsletter: newsletter});\r\n\r\n        if(patch_response.code !== 200) {\r\n            return null\r\n        };\r\n        const user = U.wrapper<DUser>(response.data);\r\n\r\n        return LUser.fromD(user);\r\n    }\r\n    */\r\n\r\n\r\n    static async updatePassword(changePasswordRequest :ChangePasswordRequest): Promise<LUser|null> {\r\n\r\n        console.log(changePasswordRequest);\r\n        const response = await Api.post(`${Api.persistance}/account/change-password`, {...changePasswordRequest});\r\n        if(response.code !== 200) {\r\n            return null;\r\n        }\r\n        const user = U.wrapper<DUser>(response.data);\r\n\r\n        return LUser.fromD(user);\r\n    }\r\n\r\n    /*\r\n    static async updatePasswordById(id: string, password: string): Promise<LUser|null> {\r\n\r\n        const patch_response = await Api.patch(`${Api.persistance}/users/set_password?id=${id}`, {password: password});\r\n\r\n        if (patch_response.code === 400) {\r\n            return null;\r\n        };\r\n\r\n        const user = U.wrapper<DUser>(patch_response.data);  \r\n        \r\n\r\n        return LUser.fromD(user); \r\n    }\r\n    */\r\n\r\n\r\n    static async resetPassword(resetPasswordRequest : ResetPasswordRequest) {\r\n        \r\n        return await Api.patch(`${Api.persistance}/account/resetPassword`, {... resetPasswordRequest})\r\n\r\n\r\n    }\r\n\r\n}\r\nexport {UsersApi};\r\n","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\api\\persistance\\projects.ts",[],"C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\components\\editors\\languages\\index.ts",[],"C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\components\\abstract\\tabs\\MetamodelTab.tsx",["1699","1700","1701","1702"],"import React, {Dispatch, ReactElement} from \"react\";\r\nimport {connect} from \"react-redux\";\r\nimport {DModel, Pointer, Try, U} from \"../../../joiner\";\r\nimport {\r\n    DState,\r\n    CreateElementAction,\r\n    DGraph,\r\n    LGraph,\r\n    LModel,\r\n    Edge,\r\n    DUser,\r\n    DClass,\r\n    SetRootFieldAction\r\n} from \"../../../joiner\";\r\nimport {DefaultNode} from \"../../../joiner/components\";\r\nimport ToolBar from \"../../toolbar/ToolBar\";\r\nimport ContextMenu from \"../../contextMenu/ContextMenu\";\r\nimport { MetricsPanel } from \"../../metrics/Metrics\";\r\n\r\n\r\nfunction MetamodelTabComponent(props: AllProps) {\r\n    const model = props.model;\r\n    const graph = props.graph;\r\n    const isEdgePending = props.isEdgePending;\r\n\r\n    if (!model) return(<>closed tab</>);\r\n    if (!graph) {\r\n        DGraph.new(0, model.id);\r\n        return(<div style={{width: \"100%\", height: \"100%\", display: \"flex\"}}>\r\n            <span style={{margin: \"auto\"}}>Building the Graph...</span>\r\n        </div>);\r\n    }\r\n\r\n    return(<div className={'w-100 h-100'}>\r\n        <MetricsPanel data={model}/>\r\n        <ContextMenu />\r\n        {/*<PendingEdge />*/}\r\n        {/* Temporary Edge Pending Manager */}\r\n        {isEdgePending.source && <div style={{position: 'absolute', top: 15, right: 15, zIndex: 999}}\r\n             className={'w-fit bg-white rounded border p-2'}>\r\n            <label className={'d-block text-center'}>Pending Edge...</label>\r\n            <label tabIndex={-1} onClick={e => SetRootFieldAction.new('isEdgePending', {user: '', source: ''})}\r\n               className={'cursor-pointer text-decoration-none d-block text-danger text-center'}>close</label>\r\n        </div>}\r\n\r\n        <div className={'d-flex h-100'}>\r\n            <ToolBar model={model.id} isMetamodel={model.isMetamodel} />\r\n            <Try>\r\n                <div className={\"GraphContainer h-100 w-100\"} style={{position:\"relative\"}}\r\n                     onClick={ e => {\r\n                         if(!U.isProjectModified) U.isProjectModified = U.userHasInteracted = true\r\n                     }}>\r\n                    {graph && <DefaultNode data={model} nodeid={graph.id} graphid={graph.id}/> || <div>Error: missing DGraph prop</div> }\r\n                </div>\r\n            </Try>\r\n        </div>\r\n    </div>);\r\n\r\n}\r\ninterface OwnProps { modelid: Pointer<DModel, 1, 1, LModel> }\r\ninterface StateProps {\r\n    model: LModel,\r\n    graph: LGraph,\r\n    isEdgePending: {user: Pointer<DUser>, source: Pointer<DClass>}\r\n}\r\ninterface DispatchProps { }\r\ntype AllProps = OwnProps & StateProps & DispatchProps;\r\n\r\n\r\nfunction mapStateToProps(state: DState, ownProps: OwnProps): StateProps {\r\n    const ret: StateProps = {} as any;\r\n    ret.model = LModel.fromPointer(ownProps.modelid);\r\n    const graphs: DGraph[] = DGraph.fromPointer(state.graphs);\r\n    const pointers = graphs.filter((graph) => { return graph.model === ret.model?.id });\r\n    if (pointers.length > 0) ret.graph = LGraph.fromPointer(pointers[0].id);\r\n    ret.isEdgePending = state.isEdgePending\r\n    return ret;\r\n}\r\n\r\nfunction mapDispatchToProps(dispatch: Dispatch<any>): DispatchProps {\r\n    const ret: DispatchProps = {};\r\n    return ret;\r\n}\r\n\r\n\r\nexport const MetamodelTabConnected = connect<StateProps, DispatchProps, OwnProps, DState>(\r\n    mapStateToProps,\r\n    mapDispatchToProps\r\n)(MetamodelTabComponent);\r\n\r\nexport const MetamodelTab = (props: OwnProps, children: (string | React.Component)[] = []): ReactElement => {\r\n    return <MetamodelTabConnected {...{...props, children}} />;\r\n}\r\nexport default MetamodelTab;\r\n","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\components\\abstract\\tabs\\ModelTab.tsx",["1703","1704"],"import React, {Dispatch, ReactElement} from \"react\";\r\nimport {connect} from \"react-redux\";\r\nimport {DModel, DPointerTargetable, Pointer, Try} from \"../../../joiner\";\r\nimport {CreateElementAction, DGraph, DModelElement, DState, LGraph, LModel, LModelElement} from \"../../../joiner\";\r\nimport {DefaultNode} from \"../../../joiner/components\";\r\nimport ToolBar from \"../../toolbar/ToolBar\";\r\nimport ContextMenu from \"../../contextMenu/ContextMenu\";\r\nimport { MetricsPanel } from \"../../metrics/Metrics\";\r\n\r\n\r\nfunction ModelTabComponent(props: AllProps) {\r\n    const model = props.model;\r\n    const graph = props.graph;\r\n\r\n    if (!model) return(<>closed tab</>);\r\n    if (!graph) {\r\n        DGraph.new(0, model.id);\r\n        console.log('create m1 graph', {model});\r\n        return(<div style={{width: \"100%\", height: \"100%\", display: \"flex\"}}>\r\n            <span style={{margin: \"auto\"}}>Building the Graph...</span>\r\n        </div>);\r\n    }\r\n\r\n    return(<div className={'w-100 h-100'}>\r\n        <ContextMenu />\r\n        <div className={'d-flex h-100'}>\r\n            <ToolBar model={model.id} isMetamodel={model.isMetamodel} metamodelId={props.metamodelid} />\r\n            <Try>\r\n                <div className={\"GraphContainer h-100 w-100\"} style={{position:\"relative\"}}>\r\n                    {graph && <DefaultNode data={model} nodeid={graph.id} graphid={graph.id} />}\r\n                </div>\r\n            </Try>\r\n        </div>\r\n    </div>);\r\n}\r\ninterface OwnProps {\r\n    modelid: Pointer<DModel, 1, 1, LModel>,\r\n    metamodelid?: Pointer<DModelElement, 1, 1, LModelElement>,\r\n}\r\ninterface StateProps { model: LModel, graph?: LGraph }\r\ninterface DispatchProps { }\r\ntype AllProps = OwnProps & StateProps & DispatchProps;\r\n\r\n\r\nfunction mapStateToProps(state: DState, ownProps: OwnProps): StateProps {\r\n    const ret: StateProps = {} as any;\r\n    ret.model = LModel.fromPointer(ownProps.modelid);\r\n    const graphs: DGraph[] = DGraph.fromPointer(state.graphs);\r\n    console.log('create m1 graph map', {pc:{...DPointerTargetable.pendingCreation}});\r\n    const pointers = graphs.filter((graph) => { return graph.model === ownProps.modelid });\r\n    if (pointers.length > 0) ret.graph = LGraph.fromPointer(pointers[0].id);\r\n    return ret;\r\n}\r\n\r\nfunction mapDispatchToProps(dispatch: Dispatch<any>): DispatchProps {\r\n    const ret: DispatchProps = {};\r\n    return ret;\r\n}\r\n\r\n\r\nexport const ModelTabConnected = connect<StateProps, DispatchProps, OwnProps, DState>(\r\n    mapStateToProps,\r\n    mapDispatchToProps\r\n)(ModelTabComponent);\r\n\r\nexport const ModelTab = (props: OwnProps, children: (string | React.Component)[] = []): ReactElement => {\r\n    return <ModelTabConnected {...{...props, children}} />;\r\n}\r\nexport default ModelTab;\r\n","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\pages\\components\\popups\\index.ts",[],"C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\components\\editors\\PermissionModelTab.tsx",["1705","1706","1707","1708"],"import {DState, Input, LPointerTargetable, Overlap, Pointer} from \"../../joiner\";\r\nimport {FakeStateProps} from \"../../joiner/types\";\r\nimport {Dispatch} from \"react\";\r\nimport {connect} from \"react-redux\";\r\nimport {DModelElement, LModelElement} from \"../../model/logicWrapper\";\r\nimport './views/data/permissions.scss';\r\n\r\nexport function PermissionModelTabComponent(props: AllProps): JSX.Element{\r\n    let groups={'Metamodelers':{}, 'Modelers':{}, 'Language designer':{}, 'Concrete Syntax designer':{}};\r\n    let groupsarr = Object.keys(groups);\r\n\r\n    return <section className={'permission-tab'}>\r\n        {groupsarr.map(group=> <section className={'group-permission'}>\r\n            <h2>{group} can:</h2>\r\n            <label className={'single-permission'}>\r\n                <Input type={'checkbox'} data={props.data} field={'example1'+group}/>\r\n                <span>Read</span>\r\n            </label>\r\n            <label className={'single-permission'}>\r\n                <Input type={'checkbox'} data={props.data} field={'example2'+group}/>\r\n                <span>Write</span>\r\n            </label>\r\n            <label className={'single-permission'}>\r\n                <Input type={'checkbox'} data={props.data} field={'example3'+group}/>\r\n                <span>Layout</span>\r\n            </label>\r\n        </section>)}\r\n    </section>;\r\n}\r\n\r\n\r\ninterface OwnProps {\r\n}\r\n\r\ninterface StateProps {\r\n    data?: LModelElement;\r\n}\r\n\r\ninterface DispatchProps {}\r\ntype AllProps = Overlap<Overlap<OwnProps, StateProps>, DispatchProps>;\r\n\r\nfunction mapStateToProps(state: DState, ownProps: OwnProps): StateProps {\r\n    const ret: StateProps = {} as StateProps;\r\n    const dataid = state._lastSelected?.modelElement;\r\n    if (dataid) ret.data = LModelElement.fromPointer(dataid);\r\n    return ret;\r\n}\r\n\r\nfunction mapDispatchToProps(dispatch: Dispatch<any>): DispatchProps { const ret: DispatchProps = {}; return ret; }\r\n\r\nexport const PermissionModelTab = connect<StateProps, DispatchProps, OwnProps, DState>(\r\n    mapStateToProps,\r\n    mapDispatchToProps\r\n)(PermissionModelTabComponent);\r\n\r\n(PermissionModelTab as any).cname = 'PermissionModelTab';\r\nPermissionModelTabComponent.cname = 'PermissionModelTabComponent';\r\n","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\components\\editors\\MTM.tsx",["1709","1710","1711","1712","1713","1714"],"import type * as monaco from \"monaco-editor\";\r\nimport {DState, Input, LPointerTargetable, Overlap, Pointer} from \"../../joiner\";\r\nimport {FakeStateProps} from \"../../joiner/types\";\r\nimport React, {Dispatch, useState} from \"react\";\r\nimport {connect} from \"react-redux\";\r\nimport {DModelElement, LModelElement} from \"../../model/logicWrapper\";\r\nimport './mtm.scss';\r\nimport {JsEditor} from \"./languages\";\r\nimport Editor from \"@monaco-editor/react\";\r\n\r\nconst monacooptions: monaco.editor.IStandaloneEditorConstructionOptions = {\r\n    fontSize: 12,\r\n    scrollbar: {vertical: 'hidden', horizontalScrollbarSize: 5},\r\n    minimap: {enabled: false},\r\n    readOnly: false\r\n};\r\n\r\nexport function MTMComponent(props: AllProps): JSX.Element{\r\n    let groups={'Metamodelers':{}, 'Modelers':{}, 'Language designer':{}, 'Concrete Syntax designer':{}};\r\n    let groupsarr = Object.keys(groups);\r\n    let [editor, setEditor] = useState(false);\r\n    let [language, setLanguage] = useState('MyCustomLanguage');\r\n\r\n    let m2t: string = 'not implemented, this is a placeholder';\r\n    switch (language){\r\n        case 'MyCustomLanguage':\r\n            m2t = 'Dog: kirk // ID is either here after class name (optional) or in [*] if it coincides with an attribute pointers are *\\n' +\r\n                '\\tname: kirk\\n' + // '\\tname: kirk[*]\\n' +\r\n                '\\towner: Damiano\\n' + // '\\towner: Damiano*\\n' +\r\n                '\\tage: 15\\n' +\r\n                '\\tweight: 13\\n' +\r\n                '\\tnode.initialX: 200\\n' +\r\n                '\\tnode.x: 200\\n';\r\n            break;\r\n        case 'JSON':\r\n            m2t = `{\r\n    id: 'kirk',\r\n    name: 'kirk',\r\n    owner: 'Damiano',\r\n    age: 15,\r\n    weight: 13,\r\n    node: {\r\n        initialX: 200,\r\n        x: 200\r\n    }\r\n}`;\r\n            break;\r\n        case 'Emfatic (m2 only)':\r\n            m2t = `@namespace(uri=\"psl\", prefix=\"\")\r\npackage psl;\r\nclass Dog{\r\n    attr String id;\r\n    attr String name;\r\n    attr Integer age;\r\n}\r\n`; break;\r\n        case 'flexmi/YAML':\r\n            m2t = `?nsuri: psl\r\ndog:\r\n- id: kirk\r\n- name: kirk\r\n- owner: Damiano\r\n- age: 15\r\n- weight: 13\r\n- node:\r\n  - initialX: 200\r\n  - x: 20\r\n`; break;\r\n        case 'flexmi/XMI':\r\n            m2t = `<?nsuri psl?>\r\n<dog name=\"kirk\" id=\"kirk\">\r\n    <owner>Damiano</owner>\r\n    <age>15</age>\r\n    <weight>13</weight>\r\n    <node>\r\n        <initialX>200</initialX>\r\n        <x>200</x>\r\n    </node>\r\n<dog>\r\n    `; break;\r\n        case 'eCore/JSON': break;\r\n        case 'eCore/XMI': break;\r\n        default: break;\r\n    }\r\n    if (editor) return M2T({...props, language} as any, setEditor);\r\n\r\n    return <section className={'w-100 h-100 p-2 MTM-tab'}>\r\n        <h1 className={\"rightbar-title\"}>Model → Text → Model</h1>\r\n        <label className={'d-flex'}>\r\n            <span className={'my-auto'}>Language&nbsp;</span>\r\n            <select className={'my-auto'} onChange={(e) => setLanguage(e.target.value)}>\r\n                <option value={'JSON'}>JSON</option>\r\n                <option value={'MyCustomLanguage'}>MyCustomLanguage</option>\r\n                <option value={'Emfatic (m2 only)'}>Emfatic (m2 only)</option>\r\n                <option value={'flexmi/YAML'}>flexmi/YAML</option>\r\n                <option value={'flexmi/XMI'}>flexmi/YAML</option>\r\n                <option value={'eCore/XMI'}>flexmi/YAML</option>\r\n                <option value={'eCore/JSON'}>eCore/JSON</option>\r\n                <option value={'eCore/XMI'}>eCore/XMI</option>\r\n            </select>\r\n            <label onClick={() => setEditor(true)} className='my-auto d-flex ms-1' style={{cursor: 'pointer'}}>\r\n                <i className=\"bi bi-pencil-square my-auto\"/><span className={'my-auto'}>Edit</span>\r\n            </label>\r\n        </label>\r\n        <Editor className={'mx-1'} options={monacooptions} defaultLanguage={'typescript'} value={m2t}\r\n                onChange={() => {}}/>\r\n        <div className={'d-flex'} style={{flexFlow: 'column'}}>\r\n            <button>Export</button>\r\n            <button>Import</button>\r\n        </div>\r\n    </section>\r\n        ;\r\n}\r\n\r\nexport function M2T(props: AllProps, setEditor: (v:boolean)=>void): JSX.Element{\r\n    let m2t_func: string = 'not implemented, this is a placeholder';\r\n    let t2m_func: string = 'not implemented, the m2t result will be read-only';\r\n    switch((props as any).language){\r\n        case 'MyCustomLanguage':\r\n            m2t_func = `\r\n            function (model, node){\r\n                let text: string = '' model.className + ':' + model.id;\r\n                for (let child of model.attributes) text += '\\\\n\\\\t'+child.name+':'+JSON.stringify(child.values);\r\n                for (let child of model.references) text += '\\\\n\\\\t'+child.name+':'+JSON.stringify(child.values.map(v=>v.id));\r\n                text+='\\\\n\\\\tnode.x' = node.initialX;\r\n                text+='\\\\n\\\\tnode.initialX' = node.x;\r\n                return text;\r\n            }\r\n            `\r\n            t2m_func = `\r\n    function (text) {\r\n        let lines = text.split('\\\\n');\r\n        lines = lines.map(line=>{ // uncomment\r\n            let comment_index = line.indexOf('//'); return (comment_index==-1) ? line : line.substr(0,comment_index);\r\n        }\r\n        let parsed = {};\r\n        for (let line of lines) {\r\n            let split = Indexline.indexOf(':');\r\n            let key = parsed.className = line.substring(0,splitIndex).trim();\r\n            let val = line.substring(splitIndex+1).trim();\r\n            if (line[0] !== ' ') { // first line contains the type and identifier\r\n                parsed.className = key;\r\n                parsed.id = val;\r\n            }\r\n            else {\r\n                splitIndex = key.indexOf('.');\r\n                if (splitIndex === -1) parsed.id = parsed[key] = val; // set simple value\r\n                else { // set nested value\r\n                    let current = parsed;\r\n                    let paths = key.split('.');\r\n                    for (let i = 0; i < paths.length; i++) {\r\n                        let k = paths[i];\r\n                        if (i === paths.length -1) current[k] = val; // perform assignment at the final index\r\n                        else { // else navigate inside the sub-object\r\n                            if (!current[k]) current[k] = {};\r\n                            current = current[k];\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            \r\n        }\r\n        return parsed;\r\n        \r\n    }\r\n    `;\r\n            break;\r\n        case 'JSON':\r\n            m2t_func = 'function(model) { return JSON.stringify(data); }';\r\n            t2m_func = 'function(text) { return JSON.parse(text); }';\r\n            break;\r\n        case 'eCore/JSON': break;\r\n        case 'Emfatic (m2 only)':break;\r\n        case 'flexmi/YAML': break;\r\n        case 'flexmi/XMI': break;\r\n        case 'eCore/XMI': break;\r\n    }\r\n\r\n    return <section className={'M2T-tab'}>\r\n        <h2>Language</h2>\r\n        <div className={'d-flex'} style={{flexFlow: 'column'}}>\r\n            <h2 style={{flexGrow: 1, margin: 'auto'}}>\r\n                <label>Editing:</label>\r\n                <Input hidden={true} getter={() => 'MyLanguage'} setter={() => {\r\n                }} style={{overflow: 'visible'}}/>\r\n            </h2>\r\n            <button onClick={() => setEditor(false)} style={{margin: '0 auto'}}>X</button>\r\n        </div>\r\n        <div className={'d-flex'} style={{flexFlow: 'row'}}>\r\n            <div className={'d-flex'} style={{flexGrow: 1, border:'1px solid red', flexWrap:'wrap'}}>\r\n                <h3 className={'w-100'}>M2T</h3>\r\n                <Editor className={'mx-1'} options={monacooptions} defaultLanguage={'typescript'} value={m2t_func}\r\n                        onChange={() => {}} />\r\n            </div>\r\n            <div className={'d-flex'} style={{flexGrow: 1, border:'1px solid red', flexWrap:'wrap'}}>\r\n                <h3 className={'w-100'}>T2M</h3>\r\n                <Editor className={'mx-1'} options={monacooptions} defaultLanguage={'typescript'} value={t2m_func}\r\n                        onChange={() => {}} />\r\n            </div>\r\n        </div>\r\n    </section>;\r\n}\r\n/*\r\nexport function T2M(props: AllProps): JSX.Element{\r\n\r\n    return <section className={'T2M-tab'}>\r\n        <h2>T2M</h2>\r\n    </section>;\r\n}*/\r\n\r\ninterface OwnProps {\r\n}\r\n\r\ninterface StateProps {\r\n    data?: LModelElement;\r\n}\r\n\r\ninterface DispatchProps {}\r\ntype AllProps = Overlap<Overlap<OwnProps, StateProps>, DispatchProps>;\r\n\r\nfunction mapStateToProps(state: DState, ownProps: OwnProps): StateProps {\r\n    const ret: StateProps = {} as StateProps;\r\n    const dataid = state._lastSelected?.modelElement;\r\n    if (dataid) ret.data = LModelElement.fromPointer(dataid);\r\n    return ret;\r\n}\r\n\r\nfunction mapDispatchToProps(dispatch: Dispatch<any>): DispatchProps { const ret: DispatchProps = {}; return ret; }\r\n\r\nexport const MTM = connect<StateProps, DispatchProps, OwnProps, DState>(\r\n    mapStateToProps,\r\n    mapDispatchToProps\r\n)(MTMComponent);\r\n\r\n(MTM as any).cname = 'MTM';\r\nMTMComponent.cname = 'MTMComponent';\r\n","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\components\\editors\\Broker.tsx",["1715","1716","1717","1718","1719"],"import {\r\n    Action,\r\n    CompositeAction,\r\n    DState,\r\n    DUser,\r\n    GObject, Input,\r\n    LUser,\r\n    Pointer,\r\n    SetRootFieldAction,\r\n    store,\r\n    U\r\n} from '../../joiner';\r\nimport React, {Dispatch, ReactElement, ReactNode, useState} from 'react';\r\nimport {connect} from 'react-redux';\r\nimport IoT from \"../../iot/IoT\";\r\nimport {FakeStateProps} from \"../../joiner/types\";\r\n\r\nfunction makeInput(label: string, type: 'text'|'number'|'password'): ReactNode {\r\n    return(<div className={'p-1 d-flex'}>\r\n        <label className={'my-auto'}>{label}</label>\r\n        <input type={type} className={'my-auto input ms-auto'} spellCheck={false} />\r\n    </div>);\r\n}\r\n\r\nfunction BrokerEditorComponent(props: AllProps) {\r\n    const {user} = props;\r\n    const [connected, setConnected] = useState(IoT.client.connected);\r\n    const [url, setUrl] = useState('http://localhost');\r\n    const [port, setPort] = useState(1883);\r\n    const [actions, setActions] = useState<Pointer[]>([]);\r\n\r\n\r\n    const connect = async() => {\r\n        //SetRootFieldAction.new('isLoading', true);\r\n        IoT.client.io.opts.query = {'project': user.project?.id, 'brokerUrl': `${url}:${port}`};\r\n        IoT.client.connect();\r\n        // IoT.client.off('pull-action');\r\n        IoT.client.on('pull-action', (receivedAction: GObject<Action & CompositeAction>) => {\r\n            // if(actions.includes(receivedAction.id)) return;\r\n            const action = Action.fromJson(receivedAction);\r\n            console.log('Received Action from server.', action);\r\n            action.fire();\r\n        });\r\n        await U.sleep(1);\r\n        //SetRootFieldAction.new('isLoading', false);\r\n        setConnected(IoT.client.connected);\r\n    }\r\n    const disconnect = async() => {\r\n        //SetRootFieldAction.new('isLoading', true);\r\n        IoT.client.off('pull-action');\r\n        IoT.client.disconnect();\r\n        await U.sleep(1);\r\n        //SetRootFieldAction.new('isLoading', false);\r\n        setConnected(IoT.client.connected);\r\n    }\r\n\r\n    return <section className={'properties-tab'}>\r\n        <div style={{position: 'absolute', bottom: 10, right: 10, width: '20px', height: '20px'}} className={`d-block ms-2 my-auto circle ${connected ? 'bg-success' : 'bg-danger'}`}></div>\r\n        <label className={'input-container'}>\r\n            <b className={'me-2'}>Url:</b>\r\n            <Input getter={() => url} setter={v => setUrl(String(v))} type={'text'} />\r\n        </label>\r\n        <label className={'input-container'}>\r\n            <b className={'me-2'}>Port:</b>\r\n            <Input getter={() => String(port)} setter={v => setPort(Number(v))} type={'number'} />\r\n        </label>\r\n        <label className={'input-container'}>\r\n            <b className={'me-2'}>Username:</b>\r\n            <Input getter={() => ''} setter={v => {}} type={'text'} />\r\n        </label>\r\n        <label className={'input-container'}>\r\n            <b className={'me-2'}>Password:</b>\r\n            <Input getter={() => ''} setter={v => {}} type={'text'} />\r\n        </label>\r\n        {!connected && <button onClick={connect} className={'mt-2 btn btn-primary w-25 p-2'}>Connect</button>}\r\n        {connected && <button onClick={disconnect} className={'mt-2 btn btn-primary w-25 p-2'}>Disconnect</button>}\r\n        {/*<button onClick={e => U.publish('sensors', {test: 15, other: true})}>click</button>*/}\r\n    </section>;\r\n}\r\ninterface OwnProps {}\r\ninterface StateProps {user: LUser}\r\ninterface DispatchProps {}\r\ntype AllProps = OwnProps & StateProps & DispatchProps;\r\n\r\n\r\nfunction mapStateToProps(state: DState, ownProps: OwnProps): StateProps {\r\n    const ret: StateProps = {} as FakeStateProps;\r\n    ret.user = LUser.fromPointer(DUser.current);\r\n    return ret;\r\n}\r\n\r\nfunction mapDispatchToProps(dispatch: Dispatch<any>): DispatchProps {\r\n    const ret: DispatchProps = {};\r\n    return ret;\r\n}\r\n\r\n\r\nexport const BrokerEditorConnected = connect<StateProps, DispatchProps, OwnProps, DState>(\r\n    mapStateToProps,\r\n    mapDispatchToProps\r\n)(BrokerEditorComponent);\r\n\r\nexport const BrokerEditor = (props: OwnProps, children: (string | React.Component)[] = []): ReactElement => {\r\n    return <BrokerEditorConnected {...{...props, children}} />;\r\n}\r\n\r\nBrokerEditorComponent.cname = 'BrokerEditorComponent';\r\nBrokerEditorConnected.cname = 'BrokerEditorConnected';\r\nBrokerEditor.cname = 'BrokerEditor';\r\nexport default BrokerEditor;\r\n","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\components\\abstract\\tabs\\ModelsSummaryTab.tsx",["1720","1721","1722","1723","1724"],"import type {DState, LProject} from '../../../joiner';\r\nimport {DUser, LModel, LUser} from '../../../joiner';\r\nimport React, {Dispatch, ReactElement} from 'react';\r\nimport {connect} from 'react-redux';\r\nimport type {Dictionary, FakeStateProps} from '../../../joiner/types';\r\nimport DockManager from \"../DockManager\";\r\nimport {LeftBar} from '../../../pages/components';\r\nimport {ProjectCatalog, Title} from '../../../pages/components/Dashboard';\r\nimport { Logo } from '../../../components/logo';\r\n\r\ntype Props = {\r\n    key: string;\r\n    name: string;\r\n    data: any;\r\n    metamodels: any;\r\n    models: any;\r\n};\r\n\r\nconst Project = (props: Props) => {\r\n    const {name, metamodels, models} = props;\r\n    const project = props.data;\r\n\r\n    return (\r\n        <React.Fragment>\r\n            <div className={\"dashboard-container\"} tabIndex={-1}>\r\n                <LeftBar active={'Project'} project={project} />\r\n                <div className={'user'}>\r\n                    <div className={'name'}>\r\n                        <Title projectID={project.id} active={'Project'} title={project.name} icon={<Logo className={project.type} style={{paddingLeft: '4px', fontSize: '2em'}}/>} description={project.description} type={project.type}/>                       \r\n                        <ProjectCatalog project={project} />\r\n                    </div>\r\n                </div>\r\n            </div>\r\n        </React.Fragment>\r\n    );\r\n}\r\n\r\nfunction m2Row(model: LModel) { return mRow(model, false) }\r\nfunction m1Row(model: LModel) { return mRow(model, true) }\r\n// too small to justify a separate file\r\n\r\nfunction mRow(model: LModel, showInstanceOf: boolean = false) {\r\n    if(!model) return(<></>);\r\n    return (\r\n        <p className={'d-block'} key={model.id} onClick={()=>DockManager.open2(model)} style={{cursor: 'pointer'}}>\r\n            <i className=\"bi bi-folder\"></i> {model.name}{\r\n                showInstanceOf && <><span className={'text-success'}> {model.instanceof ? 'conforming to' : 'is shapeless'}</span> {model.instanceof?.name}</>\r\n            }\r\n            <i className=\"bi bi-chevron-down hoverable\">\r\n                <div className=\"content context-menu\">\r\n                    <div className={'col item'}>Open</div>\r\n                    <div className={'col item'}>Duplicate</div>\r\n                    <div className={'col item'}>Close</div>\r\n                    <hr className={'my-1'} />\r\n                    <div className={'col item'}>Delete</div>\r\n                </div>\r\n            </i>\r\n        </p>)\r\n}\r\n\r\nfunction InfoTabComponent(props: AllProps) {\r\n    const project = props.project;\r\n    const metamodels = project.metamodels;\r\n    let models = project.models;\r\n    let modelmap: Dictionary<string, LModel[]> = {}\r\n    for (let m of models) {\r\n        let m2 = m.instanceof;\r\n        let m2name = m2?.name as string;\r\n        if (!modelmap[m2name]) modelmap[m2name] = [];\r\n        modelmap[m2name].push(m);\r\n    }\r\n    models = Object.values(modelmap).flat();  // this way they are sorted by metamodel\r\n    return(<Project key={project.id} name={project.name} data={project} metamodels={metamodels} models={models}/>);\r\n}\r\n\r\ninterface OwnProps {}\r\ninterface StateProps {project: LProject}\r\ninterface DispatchProps { }\r\ntype AllProps = OwnProps & StateProps & DispatchProps;\r\n\r\n\r\nfunction mapStateToProps(state: DState, ownProps: OwnProps): StateProps {\r\n    const ret: StateProps = {} as FakeStateProps;\r\n    const luser = LUser.fromPointer(DUser.current, state);\r\n    ret.project = luser.project as LProject;\r\n    return ret;\r\n}\r\n\r\nfunction mapDispatchToProps(dispatch: Dispatch<any>): DispatchProps {\r\n    const ret: DispatchProps = {};\r\n    return ret;\r\n}\r\n\r\n\r\nexport const InfoTabConnected = connect<StateProps, DispatchProps, OwnProps, DState>(\r\n    mapStateToProps,\r\n    mapDispatchToProps\r\n)(InfoTabComponent);\r\n\r\nexport const InfoTab = (props: OwnProps, children: (string | React.Component)[] = []): ReactElement => {\r\n    return <InfoTabConnected {...{...props, children}} />;\r\n}\r\nexport default InfoTab;\r\n","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\api\\DTO\\Project.ts",[],"C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\components\\editors\\NodeEditor.tsx",["1725","1726","1727","1728","1729","1730","1731","1732","1733","1734"],"import React, {Dispatch, ReactElement} from 'react';\r\nimport {connect} from 'react-redux';\r\nimport {DState} from '../../redux/store';\r\nimport type {\r\n    LModelElement,\r\n    LViewElement,\r\n    LGraphElement,\r\n    LVoidVertex,\r\n    LVoidEdge, LGraph,Pointer, DGraphElement,\r\n    DNamedElement, LNamedElement} from '../../joiner';\r\nimport {\r\n    LPointerTargetable,\r\n    L,\r\n    Input,\r\n    GenericInput,\r\n    TextArea,\r\n    RuntimeAccessibleClass,\r\n    SetRootFieldAction, DEdge,\r\n} from '../../joiner';\r\nimport './editors.scss';\r\nimport './node-editor.scss';\r\nimport {Empty} from \"./Empty\";\r\nimport { CommandBar, Btn } from '../commandbar/CommandBar';\r\n\r\nfunction NodeEditorComponent(props: AllProps) {\r\n    const selected = props.selected;\r\n    const editable = true;\r\n    if (!selected?.node) return <Empty msg={'Select a node.'} />;\r\n    const node = selected.node;\r\n    const dnode = (node.__raw || node) as DGraphElement\r\n    let cname = dnode.className;\r\n    let isGraph = ['DGraph', 'DGraphVertex'].includes(cname); // RuntimeAccessibleClass.extends(cname, 'DGraph');\r\n    let isVertex = ['DVoidVertex', 'DVertex', 'DEdgePoint'].includes(cname); // RuntimeAccessibleClass.extends(cname, 'DVoidVertex');\r\n    let isEdge = ['DVoidEdge', 'DEdge'].includes(cname); // RuntimeAccessibleClass.extends(cname, 'DVoidEdge');\r\n    let isField = (!isGraph && !isVertex && !isEdge);\r\n    let asGraph: LGraph | undefined = isGraph && node as any;\r\n    let asVertex: LVoidVertex | undefined  = isVertex && node as any;\r\n    let asEdge: LVoidEdge | undefined = isEdge && node as any;\r\n    let asField: LVoidEdge | undefined = isField && node as any;\r\n    function openNode(id: Pointer<DGraphElement>) {\r\n        SetRootFieldAction.new('_lastSelected.node', id, '', false);\r\n    }\r\n\r\n    function getNodeLabel(node: LGraphElement){\r\n        if (!node) return 'error';\r\n        let model: DNamedElement | undefined = node.model?.__raw as any;\r\n        if (!model) return node.className;\r\n        return node.className + ' - ' +(model.name || model.className)\r\n    }\r\n    function getEdgeLabel(edge: LVoidEdge){\r\n        let s: DNamedElement | undefined = edge?.start?.model?.__raw as any;\r\n        let e: DNamedElement | undefined = edge?.end?.model?.__raw as any;\r\n        return [\r\n            (s ? s.name || s.className : <i style={{color: 'orange'}}>empty</i>),\r\n            <i className={'bi bi-arrow-right ms-1 me-1'} />,\r\n            (e ? e.name || e.className : <i style={{color: 'orange'}}>empty</i>)\r\n        ];\r\n\r\n    }\r\n    const clickableStyle = {cursor:'pointer', color: 'gray'};\r\n    const headerStyle = {marginBottom:0, marginTop: '0.5em'};\r\n    const edgeStart: LGraphElement | undefined = asEdge && asEdge.start;\r\n    const edgeEnd: LGraphElement | undefined = asEdge && asEdge.end;\r\n    const notFoundStyle = {color: 'orange', cursor:'not-allowed'};\r\n    const subElements = node.subElements;\r\n    let edgesIn = !isEdge && node.edgesIn || [];\r\n    let edgesOut = !isEdge && node.edgesOut || [];\r\n\r\n\r\n\r\n\r\n\r\n    type InputRowProps = {\r\n        label: string,\r\n        as: any,\r\n        field: string,\r\n        type: string\r\n    }\r\n    const InputRow = (props: any) => {\r\n        return (\r\n            <div className='input-container'>\r\n                <b className={'me-2'}>{props.label}</b>\r\n                <Input data={props.as} field={props.field} type={props.type} readonly={!editable} />\r\n            </div>\r\n        );\r\n    };\r\n\r\n    let stackingOrder = <InputRow label={'Stacking order'} as={node} field={'zIndex'} type={'number'} />\r\n\r\n    return(<div className={'p-3 node-editor'}>\r\n        {/*<Input obj={selected.node} field={'id'} label={'ID'} type={'text'} readonly={true}/>*/}\r\n\r\n        {asGraph && <><h3>Graph</h3>\r\n            <GenericInput data={asGraph} field={'zoom'} />\r\n            <GenericInput data={asGraph} field={'offset'} />\r\n\r\n            {/*graphSize readonly on LGraph but not on DGraph, = internal graph size. put it for info.*/ }\r\n        </>}\r\n\r\n        {asVertex && <><h3>Vertex</h3>\r\n            {stackingOrder}\r\n\r\n            <InputRow label={'isResized'} as={asVertex} field={'isResized'} type={'checkbox'} />\r\n            <InputRow label={'X Position'} as={asVertex} field={'x'} type={'number'} />\r\n            <InputRow label={'Y Position'} as={asVertex} field={'y'} type={'number'} />\r\n            <InputRow label={'Width'} as={asVertex} field={'width'} type={'number'} />\r\n            <InputRow label={'Height'} as={asVertex} field={'height'} type={'number'} />\r\n        </>}\r\n\r\n        {asEdge && <><h3>Edge</h3>\r\n            {stackingOrder}\r\n\r\n            {\r\n            //  <>\r\n            //     moved to props & transient properties\r\n            //     <GenericInput data={asEdge} field={'longestLabel'}\r\n            //         placeholder={'(edge/*LEdge*/, segment/*EdgeSegment*/, subNodes/*LGraphElement[]*/, allSegments/*EdgeSegment[]*/) => {' +\r\n            //         '\\n\\t// a complex example. The label can be either a function like this or a simple string.' +\r\n            //         '\\n\\t return (edge.start.model)?.name + \\' ~ \\' + (e.end.model)?.name + \\'(\\' + segment.length.toFixed(1) + \\')\\';' +\r\n            //         '\\n}'}/>\r\n            //     <GenericInput data={asEdge} field={'labels'}\r\n            //         placeholder={'(edge/*LEdge*/, segment/*EdgeSegment*/, subNodes/*LGraphElement[]*/, allSegments/*EdgeSegment[]*/) => {' +\r\n            //         '\\n\\t// a complex example. The label can be either a function like this or a simple string.' +\r\n            //         '\\n\\t return (edge.start.model)?.name + \\' ~ \\' + (e.end.model)?.name + \\'(\\' + segment.length.toFixed(1) + \\')\\';' +\r\n            //         '\\n}'}/>\r\n            // </>\r\n            }\r\n\r\n            <GenericInput className='input-container' data={asEdge} field={\"anchorStart\"}/>\r\n            <GenericInput className='input-container' data={asEdge} field={\"anchorEnd\"}/>\r\n        </>}\r\n\r\n        {asField && <><h3>Field</h3>\r\n            {stackingOrder}\r\n        </>}\r\n\r\n        <div style={{marginTop:'1em', marginBottom:'1em', borderBottom:'1px solid gray'}}/>\r\n\r\n        {/* <div>\r\n            <h6 className={'super'}>\r\n                Super element:\r\n                {node.father?.className ?\r\n                    <span onClick={(e)=> dnode.father && openNode(dnode.father)} style={clickableStyle}>\r\n                        {[node.father?.className, <i style={{paddingLeft: '8px'}} className=\"bi bi-chevron-up\"></i>]}\r\n                    </span>\r\n                :\r\n                    <span style={notFoundStyle}>Not contained</span>\r\n                }\r\n            </h6>\r\n            </div>*/}\r\n\r\n        {node.father?.className && <div>\r\n            <h6 style={{display: 'flex'}}>\r\n                Super element\r\n                    {/*<span onClick={(e)=> dnode.father && openNode(dnode.father)} style={clickableStyle}>\r\n                        {[node.father?.className, <i style={{paddingLeft: '8px'}} className=\"bi bi-chevron-up\"></i>]}\r\n                    </span>*/}\r\n                    <CommandBar style={{paddingLeft: 'var(--tab-sep)', bottom: '3px'}}>\r\n                        <Btn icon={'up'} action={(e)=> dnode.father && openNode(dnode.father)} tip={'Go up'}/>\r\n                    </CommandBar>\r\n            </h6>\r\n        </div>}\r\n\r\n        {asEdge && [\r\n            <div><h6 style={headerStyle}>Edge start:{\r\n                edgeStart ?\r\n                    <span className={'ms-2'} onClick={(e)=> openNode(edgeStart.id)} style={clickableStyle}>\r\n                        {getNodeLabel(edgeStart)}<i className={'ms-1 bi bi-arrow-right'}/>\r\n                    </span>\r\n                    : <span style={notFoundStyle}>Missing</span>\r\n            }</h6></div>,\r\n            <div><h6 style={headerStyle}>Edge End:{\r\n                edgeEnd ?\r\n                    <span className={'ms-2'} onClick={(e)=> openNode(edgeEnd.id)} style={clickableStyle}>\r\n                        {getNodeLabel(edgeEnd)}<i className={'ms-1 bi bi-arrow-left'}/>\r\n                    </span>\r\n                    : <span style={notFoundStyle}>Missing</span>\r\n            }</h6></div>\r\n        ]}\r\n\r\n        {/* <div>\r\n            <h6 style={headerStyle} className='sub'>\r\n                Sub elements\r\n                {subElements.length ?\r\n                    <i style={{paddingLeft: '8px'}}className=\"bi bi-chevron-down\"></i>\r\n                :\r\n                    [': ', <span style={notFoundStyle}>None</span>]\r\n                }\r\n            </h6>\r\n            {subElements.map(\r\n                n => <div className={'w-100 ms-2'} onClick={(e)=> openNode(n.id)} style={clickableStyle}>{getNodeLabel(n)}</div>\r\n            )}\r\n            </div>*/}\r\n\r\n            {subElements.length > 0 && <div>\r\n            <h6 style={{display: 'flex'}}>\r\n                Sub elements\r\n\r\n                <CommandBar style={{paddingLeft: 'var(--tab-sep)', bottom: '3px'}}>\r\n                    <Btn icon={'down'} action={(e)=> {}} tip={'Go down'}/>\r\n                </CommandBar>\r\n            </h6>\r\n\r\n            {subElements.map(\r\n                n => <div className={'w-100 ms-2 sub-element'} onClick={(e)=> openNode(n.id)} style={clickableStyle}>{getNodeLabel(n)}</div>\r\n            )}\r\n            </div>}\r\n\r\n        {!asEdge && <>\r\n\r\n            {edgesOut.length > 0 && <div>\r\n                <h6 style={{display: 'flex'}}>\r\n                    Outgoing Edges\r\n                </h6>\r\n                {edgesOut.length && edgesOut.map(n => <div className={'w-100 ms-2 sub-element'} onClick={(e)=> openNode(n.id)} style={clickableStyle}>{getEdgeLabel(n)}</div>)}\r\n            </div>}\r\n\r\n            {edgesIn.length > 0 && <div>\r\n                <h6 style={{display: 'flex'}}>\r\n                    Incoming Edges\r\n                </h6>\r\n                {edgesIn.map(n => <div className={'w-100 ms-2 sub-element'} onClick={(e)=> openNode(n.id)} style={clickableStyle}>{getEdgeLabel(n)}</div>)}\r\n            </div>}\r\n\r\n            {/*<div>\r\n                <h6 style={headerStyle}>\r\n                    Outgoing Edges {edgesOut.length === 0 && <>: <span style={notFoundStyle}>None</span></>}\r\n                </h6>\r\n                {edgesOut.length && edgesOut.map(n => <div className={'w-100 ms-2'} onClick={(e)=> openNode(n.id)} style={clickableStyle}>{getEdgeLabel(n)}</div>)}\r\n            </div>\r\n\r\n            <div>\r\n                <h6 style={headerStyle}>Incoming Edges{edgesIn.length === 0 && <>:\r\n                    <span style={notFoundStyle}>None</span></>}\r\n                </h6>\r\n                {edgesIn.map(n => <div className={'w-100 ms-2'} onClick={(e)=> openNode(n.id)} style={clickableStyle}>{getEdgeLabel(n)}</div>)}\r\n            </div>*/}\r\n        </>}\r\n\r\n\r\n        <h6>Node state</h6>\r\n        <div className={'object-state'}>\r\n            {Object.keys(dnode._state).length === 0 && <pre> Empty</pre>}\r\n            <pre>{Object.keys(dnode._state).length ? JSON.stringify(dnode._state, null, '\\t') : undefined}</pre>\r\n        </div>\r\n\r\n    </div>);\r\n\r\n}\r\ninterface OwnProps {}\r\ninterface StateProps {\r\n    selected?: {\r\n        node: LGraphElement;\r\n        view: LViewElement;\r\n        modelElement?: LModelElement;\r\n    };\r\n}\r\ninterface DispatchProps {}\r\ntype AllProps = OwnProps & StateProps & DispatchProps;\r\n\r\n\r\nfunction mapStateToProps(state: DState, ownProps: OwnProps): StateProps {\r\n    let ret: StateProps = {};\r\n    const selected = state._lastSelected;\r\n    if(selected) {\r\n        const modelElement = state._lastSelected?.modelElement;\r\n        const node = state._lastSelected?.node;\r\n        const view = state._lastSelected?.view;\r\n        if(node && view) {\r\n            ret.selected = {\r\n                node: L.fromPointer(node),\r\n                view: L.fromPointer(node),\r\n                modelElement: (modelElement) ? L.fromPointer(modelElement) : undefined\r\n            }\r\n        }\r\n    }\r\n    return ret;\r\n}\r\n\r\nfunction mapDispatchToProps(dispatch: Dispatch<any>): DispatchProps {\r\n    const ret: DispatchProps = {};\r\n    return ret;\r\n}\r\n\r\n\r\nexport const NodeEditorConnected = connect<StateProps, DispatchProps, OwnProps, DState>(\r\n    mapStateToProps,\r\n    mapDispatchToProps\r\n)(NodeEditorComponent);\r\n\r\nexport const NodeEditor = (props: OwnProps, children: (string | React.Component)[] = []): ReactElement => {\r\n    return <NodeEditorConnected {...{...props, children}} />;\r\n}\r\nexport default NodeEditor;\r\n\r\n","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\api\\api.ts",["1735","1736","1737"],"import Axios from \"axios\";\r\nimport {Json, R} from \"../joiner\";\r\nimport Storage from \"../data/storage\";\r\nimport { AuthApi } from \"./persistance\";\r\nimport { JwtClaims } from \"./DTO/JwtClaims\";\r\n\r\nexport type Response = {code: number, data: Json|null}\r\nclass Api {\r\n\r\n    static persistance = `${process.env['REACT_APP_PERSISTANCE']}`;\r\n    static memorec = `${process.env['REACT_APP_MEMOREC']}/memorec`;\r\n    static token: string | null = null;\r\n    \r\n    private static headers() {\r\n        // check if token is null\r\n\r\n            try {\r\n                if(!Api.token) {\r\n                    Api.token = Storage.read('token') || '';\r\n                }\r\n                return {'Authorization': \"Bearer \" + Api.token};\r\n            } catch (e) {\r\n\r\n                console.log(\"error headers\");\r\n            }\r\n\r\n        \r\n    }\r\n\r\n\r\n    static async checkToken(): Promise<boolean> {\r\n\r\n        if(Api.token || Storage.read('token')) {\r\n\r\n            const exp :number = Storage.read('tokenExp');\r\n\r\n                if (exp && exp > Math.floor(Date.now() / 1000)) {\r\n\r\n\r\n                    return true;\r\n                }\r\n\r\n        }\r\n        console.log(\"token scaduto o non valido\");\r\n        return false;\r\n    }\r\n\r\n    static async get(path: string, allowAnonymous:boolean = false): Promise<Response> {\r\n        try {\r\n\r\n            if(allowAnonymous || await Api.checkToken()) {\r\n                const response = await Axios.get(path, {headers: this.headers()});\r\n                return {code: response.status, data: response.data};\r\n            }\r\n            return {code: 401, data: null};\r\n\r\n\r\n        } catch (e) {\r\n            return {code: 400, data: null};\r\n        }\r\n        \r\n    }\r\n   \r\n    static async post(path: string, obj: Json, allowAnonymous:boolean = false): Promise<Response> {\r\n        try {\r\n            if(allowAnonymous || await Api.checkToken()) {\r\n                const response = await Axios.post(path, obj, {headers: this.headers()});\r\n                return {code: response.status, data: response.data};\r\n            }\r\n            return {code: 401, data: null};\r\n        } catch (e) {\r\n            return {code: 400, data: null};\r\n        }\r\n    }\r\n\r\n    static async put(path: string, obj: Json, allowAnonymous:boolean = false): Promise<Response> {\r\n        try {\r\n            if(allowAnonymous || await Api.checkToken()) {\r\n                const response = await Axios.put(path, obj, {headers: this.headers()});\r\n                return {code: response.status, data: response.data};\r\n            }\r\n            return {code: 401, data: null};\r\n\r\n        } catch (e) {\r\n            return {code: 400, data: null};\r\n        }\r\n    }\r\n\r\n\r\n    static async patch(path: string, obj: Json, allowAnonymous:boolean = false): Promise<Response> {\r\n        try {\r\n            if(allowAnonymous || await Api.checkToken()) {\r\n                const response = await Axios.patch(path, obj, {headers: this.headers()});\r\n                return {code: response.status, data: response.data};\r\n            }\r\n            return {code: 401, data: null};\r\n\r\n        } catch (e) {\r\n            return {code: 400, data: null};\r\n        }\r\n    }\r\n\r\n    static async delete(path: string, allowAnonymous:boolean = false): Promise<Response> {\r\n        try {\r\n            if(allowAnonymous || await Api.checkToken()) {\r\n                const response = await Axios.delete(path, {headers: this.headers()});\r\n                return {code: response.status, data: response.data};\r\n            }\r\n            return {code: 401, data: null};\r\n        } catch (e) {\r\n            return {code: 400, data: null};\r\n        }\r\n    }\r\n}\r\n\r\nexport default Api;\r\n","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\api\\memorec\\types.ts",[],"C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\api\\DTO\\JwtClaims.ts",[],"C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\components\\dock\\MyRcDock.tsx",["1738","1739","1740","1741","1742","1743","1744","1745","1746"],"import React, {Component, PureComponent, ReactElement, ReactNode, useState} from \"react\";\r\nimport {\r\n    Dictionary,\r\n    DocString,\r\n    GObject,\r\n    Log,\r\n    LoggerComponent,\r\n    Point,\r\n    RuntimeAccessible,\r\n    Size,\r\n    Try,\r\n    U,\r\n    windoww\r\n} from \"../../joiner\";\r\nimport $ from \"jquery\";\r\nimport {BoxData, DockLayout, LayoutProps, PanelData, TabData, TabGroup} from \"rc-dock\";\r\nimport {MyPortal} from \"./MyDock\";\r\nimport \"./DockManagerStyles.scss\";\r\nimport {LayoutData} from \"rc-dock/src/DockData\";\r\n\r\n// needs to be class component because needs setState() to be called externally\r\ninterface TabHeaderProps{\r\n    tid: string;\r\n    children: ReactNode;\r\n}\r\nclass TabHeaderState{\r\n    fixed: boolean;\r\n    pinned: AnchorTypes | '';\r\n    constructor() {\r\n        this.fixed = false;\r\n        this.pinned = '';\r\n    }\r\n}\r\ninterface TabContentProps extends TabHeaderProps{}\r\nclass TabContentState extends TabHeaderState{}\r\n\r\n@RuntimeAccessible('TabHeader')\r\nexport class TabHeader extends React.Component<TabHeaderProps, TabHeaderState>{\r\n    static cname: string = 'TabHeader';\r\n    static instances: Dictionary<string, TabHeader> = {};\r\n    constructor(props:TabHeaderProps) {\r\n        super(props);\r\n        TabHeader.instances[props.tid] = this;\r\n        this.state = new TabHeaderState();\r\n    }\r\n\r\n    unpin(){\r\n        let oldPinned = this.state.pinned;\r\n        if (oldPinned === \"\") return Log.ee(\"tab already unpinned\", this.props.tid);\r\n        TabContent.instances[this.props.tid].setState({pinned: ''});\r\n        this.setState({pinned: ''}, ()=>{\r\n            let strip: PinnableStrip = PinnableStrip[oldPinned as AnchorTypes];\r\n            strip.unpin(this.props.tid);\r\n        });\r\n    }\r\n    toggleFixed(){\r\n        let fixed = !this.state.fixed;\r\n        TabContent.instances[this.props.tid].setState({fixed});\r\n        this.setState({fixed}, ()=>{\r\n            // let strip: PinnableStrip = PinnableStrip[oldPinned as AnchorTypes];\r\n            // strip.fixed(this.props.tid, fixed);\r\n        });\r\n    }\r\n    onMouseHoverExpand(){\r\n        this.setAsActiveTab();\r\n    }\r\n    onMouseLeaveExpand(){\r\n\r\n    }\r\n    getTabStrip(): PinnableStrip{\r\n        Log.exDev(!this.state.pinned, \"Cannot get strip, tab is not pinned\");\r\n        return PinnableStrip[this.state.pinned as AnchorTypes];\r\n    }\r\n    setAsActiveTab(){\r\n        let strip = this.getTabStrip();\r\n        const tabdata: TabData = strip.dockLayout!.find(this.props.tid+\"_pinned\") as TabData;\r\n        if (!this.html) return; // not pinned\r\n        strip.dockLayout!.updateTab(tabdata.id as string, tabdata, true);\r\n        // if (windoww) return;\r\n        let tabcontent: HTMLElement = document.getElementById(this.props.tid+\"_pinned\") as HTMLElement;\r\n        if (!tabcontent) return Log.eDevv(\"cannot find pinned tab content\", {tid: this.props.tid, tabdata});\r\n        // let e: HTMLElement = strip.html!.querySelector('.dock-content-holder') as HTMLElement;\r\n        let csize = Size.of(tabcontent);\r\n        let tabh: HTMLElement = this.html;\r\n        let tabsize = Size.of(tabh);\r\n        //let tabcenter: Point = new Point(tabsize.x + tabsize.w/2, tabsize.y + tabsize.h/2);\r\n        console.log(\"setActiveTab\", {strip, tabdata, tabcontent, csize, tabh, tabsize});\r\n        let offset: Point = new Point(tabsize.x + tabsize.w/2 - csize.w/2, tabsize.y + tabsize.h/2 - csize.h/2);\r\n        let s: string;\r\n        let tabcontentholder: HTMLElement|null|undefined = tabcontent.parentElement?.parentElement;\r\n        if (!tabcontentholder?.classList.contains('dock-content-holder'))\r\n            return Log.exDevv('rc-dock changed structure, need code update or downgrading of rc-dock library.', {tabcontent, tabcontentholder});\r\n        let $tabholder = $(tabcontentholder);\r\n        if (!$tabholder.data(\"uiResizable\")) {\r\n            let handles: string;\r\n            switch(strip.props.side){\r\n                default: handles = \"\"; break;\r\n                case \"t\": handles = \"s, se, sw\"; break;\r\n                case \"b\": handles = \"n, ne, nw\"; break;\r\n                case \"l\": handles = \"e, se, ne\"; break;\r\n                case \"r\": handles = \"w, sw, nw\"; break;\r\n            }\r\n            $tabholder.resizable({handles});\r\n            tabcontentholder.tabIndex = 0;\r\n        }\r\n        switch(strip.props.side){\r\n            default: return;\r\n            case \"t\": case \"b\":\r\n                s = \"clamp(0px, \" + offset.x + \"px, 100vw)\";\r\n                //s = \"clamp(0px, calc(\" + tabcenter.x + \"px ), 100vw)\";\r\n                console.log(\"clamp: \", s);\r\n                tabcontentholder.style.left = s;\r\n                break;\r\n            case \"l\": case \"r\":\r\n                s = \"clamp(0px, \" + offset.y + \"px, 100vw)\";\r\n                //s = \"clamp(0px, calc(\" + tabcenter.y + \"px ), 100vw)\";\r\n                console.log(\"clamp: \", s);\r\n                tabcontentholder.style.top = s;\r\n                break;\r\n        }\r\n    }\r\n\r\n    private html: HTMLElement | null = null\r\n    render(): ReactNode {\r\n        const props: TabHeaderProps = this.props;\r\n        let pinned = this.state.pinned;\r\n        let content = <div onMouseDown={()=>{console.log(\"tab dragging start\")}}>{props.children}\r\n            {/*<i className={\"pin-button bi bi-pin-angle\" + (this.state.fixed ? '-fill' : '')} onClick={()=>this.toggleFixed()}/>*/}\r\n            <i className={\"pin-button bi bi-arrow-down\"} onClick={()=>this.unpin()}/>\r\n        </div>;\r\n        if (!pinned) {\r\n            let selectTab = () => PinnableDock.instance.setAsActiveTab(props.tid);\r\n            return <div className={\"active-on-mouseenter not-pinned\"} onMouseDown={selectTab} /*onMouseEnter={selectTab}*/>{content}</div>;\r\n        }\r\n        const strip: PinnableStrip = (PinnableStrip as GObject)[pinned];\r\n        const html: Element|null = tabdict_title[props.tid + '_pinned'];\r\n        if (!html) { // unpinned tab\r\n            Log.exDevv(\"cannot find html\", {html, pinned, 'this': this});\r\n            let selectTab = () => PinnableDock.instance.setAsActiveTab(props.tid);\r\n            return <div className={\"active-on-mouseenter\"} onMouseDown={selectTab} /*onMouseEnter={selectTab}*/>{content}</div>;\r\n        }\r\n        function preventFocusOnOriginDock(e: any): void{\r\n            e.stopPropagation(); // otherwise the pinned tab will focus the hidden-tab on original dock\r\n        }\r\n        content = <div className={\"active-on-mouseenter\"} ref={(e) => this.html = e} onMouseDown={preventFocusOnOriginDock} onClick={preventFocusOnOriginDock} onMouseEnter={()=>this.onMouseHoverExpand()} onMouseLeave={()=>this.onMouseLeaveExpand()}>{content}</div>\r\n        return <><MyPortal container={html}>{content}</MyPortal><div className={\"moved-content\"}>moved</div></>;\r\n    }\r\n}\r\n@RuntimeAccessible('TabHeader')\r\nexport class TabContent extends React.Component<TabContentProps, TabContentState>{\r\n    static cname: string = 'TabContent';\r\n    static instances: Dictionary<string, TabContent> = {};\r\n    constructor(props:TabContentProps) {\r\n        super(props);\r\n        TabContent.instances[props.tid] = this;\r\n        this.state = new TabContentState();\r\n    }\r\n\r\n    render() {\r\n        const props: TabContentProps = this.props;\r\n        let pinned = this.state.pinned;\r\n        const content = <Try>{props.children}</Try>;\r\n        if (!pinned) return content;\r\n        const strip: PinnableStrip = (PinnableStrip as GObject)[pinned];\r\n        const html: Element|null = tabdict_content[props.tid + '_pinned'];\r\n        if (!html) return content;\r\n        return <MyPortal container={html}>{content}</MyPortal>;\r\n        /*\r\n        return <MyPortal container={html}>\r\n            <div className={\"pinned-tab-content-root \"+ (this.state.fixed ? \"fixed\" : '')}>{content}</div>\r\n        </MyPortal>;\r\n        */\r\n    }\r\n}\r\n\r\ntype AnchorTypes = \"t\" | \"l\" | \"r\" | \"b\";\r\ninterface PinnableStripProps{\r\n    side: AnchorTypes;\r\n}\r\nclass PinnableStripState{\r\n    // pinnedTabs: TabData[];// or what?\r\n    //pinnedTabsid: Dictionary<string, true>;\r\n    pinned: boolean;\r\n\r\n    constructor() {\r\n        this.pinned = false;\r\n       // this.pinnedTabsid = {};\r\n    }\r\n}\r\n@RuntimeAccessible(\"PinnableStrip\")\r\nexport class PinnableStrip extends PureComponent<PinnableStripProps, PinnableStripState>{\r\n    static cname = 'PinnableStrip';\r\n    public static t: PinnableStrip;\r\n    public static b: PinnableStrip;\r\n    public static l: PinnableStrip;\r\n    public static r: PinnableStrip;\r\n\r\n    html: Element | null = null;\r\n    headerHtml: Element | null = null;\r\n    contentHtml: Element | null = null;\r\n\r\n    constructor(props: PinnableStripProps) {\r\n        super(props);\r\n        PinnableStrip[props.side] = this;\r\n        this.state = new PinnableStripState();\r\n        this.groups = {\r\n            'pinned': {floatable: false, maximizable: false, tabLocked: true}\r\n        };\r\n        const tabsData: TabData[] = [];\r\n        /*\r\n        let tabdict: Dictionary<string, TabData> = {};\r\n        for (let tabid in this.state.pinnedTabsid) {\r\n            const id: string = tabid+'_pinned';\r\n            const tabdata: TabData = {\r\n                id,\r\n                group: 'pinned',\r\n                closable: false,\r\n                title: <div ref={(curr)=>this.tabdict_title[id] = curr}></div>,\r\n                content: <div ref={(curr)=>this.tabdict_content[id] = curr}></div>,\r\n                //title: <TabHeader tid={tid()}>Structure</TabHeader>, content: <TabContent tid={tid()}><StructureEditor /></TabContent>\r\n            };\r\n            tabdict[tabdata.id as string] = tabdata;\r\n            tabsData.push(tabdata);\r\n        }*/\r\n        this.layout = {dockbox: {mode: 'horizontal', children: []}};\r\n        this.panel = {id: 'side_panel' + this.props.side, tabs: tabsData};\r\n        this.layout.dockbox.children.push(this.panel);\r\n    }\r\n\r\n    private panel: PanelData;\r\n    dockLayout: DockLayout | null = null;\r\n\r\n    private layout: LayoutData;\r\n    private groups: {[p: string]: TabGroup};\r\n    private tabs: Dictionary<string, TabData> = {};\r\n    private afterUpdateCallback_funcs: ((...a:any)=>any)[] = [];\r\n\r\n    unpin(tid: string){\r\n        const stripdock: DockLayout = this.dockLayout as DockLayout;\r\n        let tabData: TabData = stripdock.find(tid+\"_pinned\") as TabData;\r\n        delete this.tabs[tid+\"_pinned\"];\r\n        stripdock.dockMove(tabData, null, 'remove');\r\n        if (!Object.keys(this.tabs).length) this.forceUpdate();\r\n        PinnableDock.instance.restoreTab(tid);\r\n    }\r\n    setAfterUpdateCallback(c: (...a:any)=>any){\r\n        this.afterUpdateCallback_funcs.push(c);\r\n    }\r\n    componentDidUpdate(prevProps: Readonly<PinnableStripProps>, prevState: Readonly<PinnableStripState>, snapshot?: any) {\r\n        this.onupdate();\r\n    }\r\n    componentDidMount() {\r\n        this.onupdate();\r\n    }\r\n    onupdate(){\r\n        for (let c of this.afterUpdateCallback_funcs) c();\r\n        this.afterUpdateCallback_funcs = [];\r\n    }\r\n\r\n    addTab(t: TabData): void{\r\n        const tid: string = t.id as string;\r\n        if (this.tabs[tid]) Log.eDevv(\"docking tab already exist\", this, t);\r\n        this.tabs[tid] = t;\r\n        // if (Object.keys(this.tabs).length === 1) this.forceUpdate(); // updates .empty class\r\n        console.log(\"addTab\", {t, pp1:this.dockLayout!.getLayout().dockbox.children[0], pp0: this.panel});\r\n        (window as any ).pinnableStrip = this;\r\n        //this.dockLayout!.dockMove(t, 'side_panel' + this.props.side, 'middle');\r\n        (window as any).addTab = (t: any)=> this.addTab(t);\r\n\r\n\r\n        this.dockLayout!.dockMove(t, this.dockLayout!.getLayout().dockbox.children[0], 'middle');\r\n        this.forceUpdate();\r\n        //this.dockLayout!.dockMove(t, this.panel, 'middle');\r\n\r\n    }\r\n    removeTab(tid: string): void{\r\n        if (!this.tabs[tid]) Log.eDevv(\"docking tab already removed\", this, tid);\r\n        Log.eDevv(\"docking removeTab() todo\", this, tid);\r\n        delete this.tabs[tid];\r\n        if (Object.keys(this.tabs).length === 0) this.forceUpdate(); // updates .empty class\r\n    }\r\n\r\n    render(){\r\n        const layout = this.layout;\r\n        const groups = this.groups;\r\n        return <div className={(Object.keys(this.tabs).length ? '' : 'empty') +\" pinnable-strip pinnable-strip-\" + this.props.side + (this.state.pinned ? ' pinned' : '')}\r\n                    ref={(curr)=>this.html = curr}>\r\n            <i className={\"side-pin-btn bi bi-pin-angle\" + (this.state.pinned ? '-fill' : '')} onClick={()=>this.setState({pinned: !this.state.pinned})} />\r\n            {/* loadTab={(d)=>tabdict[d.id as string]} */}\r\n            <DockLayout key=\"thestripdock\" ref={(e)=>this.dockLayout = e} defaultLayout={layout} groups={groups} style={{width: '100%', height: '100%'}} />\r\n            {/*<div className={\"tab-row\"} ref={(curr)=>this.headerHtml = curr}></div>\r\n            <div className={\"content-row\"} ref={(curr)=>this.contentHtml = curr}></div>*/}\r\n        </div>;\r\n    }\r\n}\r\n\r\n/// todo: lodash _.debounce on whileDragging and similar stuff triggered too often\r\ninterface LayoutState {\r\n    layout: LayoutData;\r\n    /** @ignore */\r\n    dropRect?: any;// {left: number, width: number, top: number, height: number, element: HTMLElement, source?: any, direction?: DropDirection};\r\n}\r\nlet currentDropRect!: LayoutState[\"dropRect\"];\r\nlet currentDropArea!: Element;\r\nlet dockLayout!: Element;\r\nlet dropIndicator: Element = U.toHtml('<div class=\"dock-drop-indicator\" style=\"left: 0px; top: 0px; width: 0px; height: 60px; display: block;')\r\n\r\nfunction getStrip(side: string): PinnableStrip {\r\n    let s = side[0];\r\n    return (PinnableStrip as any)[s];\r\n}\r\nfunction getStripHtml(side: string): Element {\r\n    return getStrip(side).html as Element;\r\n}\r\n\r\nwindoww.highlightAnchorArea = function(side: string){\r\n    //let highlightdiv = dockLayout.querySelector('.dock-drop-indicator') as HTMLElement;\r\n    //if (!highlightdiv) return;\r\n    //highlightdiv.style.background = '#ff000077';\r\n    let strip = getStripHtml(side);\r\n    console.log(\"highlightpin\", {strip, side, PinnableStrip});\r\n    strip.classList.add('dock-drop-indicator');\r\n}\r\nwindoww.hideAnchorArea = function(side: string){\r\n    let strip = getStripHtml(side);\r\n    strip.classList.remove('dock-drop-indicator');\r\n}\r\n\r\n\r\nconst tabdict_title: Dictionary<DocString<\"tabdata.id\">, HTMLElement | null> = {};\r\nconst tabdict_content: Dictionary<DocString<\"tabdata.id\">, HTMLElement | null> = {};\r\nwindoww.confirmSetAnchor = function(side: AnchorTypes){\r\n    windoww.hideAnchorArea(side);\r\n    const tabdata: TabData = PinnableDock.getTabFromDropRect(currentDropRect);\r\n    let strip = getStrip(side);\r\n    let content: TabContent = TabContent.instances[tabdata.id as string];\r\n    let title: TabHeader = TabHeader.instances[tabdata.id as string];\r\n    const id: string = tabdata.id+'_pinned';// + '_' + side;\r\n    const newtabdata: TabData = {\r\n        //...tabdata, parent: undefined,\r\n        id,\r\n        group: 'pinned',\r\n        closable: false,\r\n        title: <div ref={(curr)=>tabdict_title[id] = curr}></div>,\r\n        content: <div ref={(curr)=>tabdict_content[id] = curr}></div>,\r\n        //title: <TabHeader tid={tid()}>Structure</TabHeader>, content: <TabContent tid={tid()}><StructureEditor /></TabContent>\r\n    };\r\n    strip.setAfterUpdateCallback(()=>{\r\n        content.setState({pinned: side}); title.setState({pinned: side});\r\n        console.log(\"confirm pin anchor\", {content, title, strip, side, tabdata, newtabdata, currentDropRect});\r\n    });\r\n    strip.addTab( newtabdata );\r\n    PinnableDock.instance.hideTab(tabdata.id as string, side);\r\n\r\n    /*strip.setState({pinnedTabsid:{...strip.state.pinnedTabsid, [tabdata.id as string]:true}},\r\n        ()=>{\r\n        content.setState({pinned: side}); title.setState({pinned: side});\r\n        console.log(\"confirm pin anchor\", {content, title, strip, side, tabdata, currentDropRect});\r\n    });*/\r\n    console.log(\"confirm pin anchor 0\", {tid:tabdata.id, TabHeader, TabContent});\r\n\r\n\r\n    // how to? i create a new dockiing here for each strip?\r\n    // no i scrap the tabstuf, take the tabdata.header as preview. the tabdata.content as content. then add a un-pin button to the header\r\n    //strip.classList.remove('dock-drop-indicator');\r\n}\r\n/*\r\nlet htmltablist = <div className=\"dock-bar drag-initiator\" role=\"tablist\" tabIndex=\"-1\">\r\n    <div role=\"tablist\" className=\"dock-nav\">\r\n        <div className=\"dock-nav-wrap\">\r\n            <div className=\"dock-nav-list\" style=\"transform: translate(0px, 0px);\">\r\n                <div className=\"dock-tab dock-tab-active\">\r\n                    <div role=\"tab\" aria-selected=\"true\" className=\"dock-tab-btn\" tabIndex=\"0\" id={tabid+'_pinned'} aria-controls={tabid+'_pinned'}>\r\n                        <div className=\"drag-initiator\">\r\n                            <TabSlot />\r\n                            <div className=\"dock-tab-hit-area\"></div>\r\n                        </div>\r\n                    </div>\r\n                </div>\r\n                <div className=\"dock-tab\">\r\n                    <div role=\"tab\" aria-selected=\"false\" className=\"dock-tab-btn\" tabIndex=\"0\" id={tabid} aria-controls={tabid}>\r\n                        <div className=\"drag-initiator\">\r\n                            <TabSlot />\r\n                            <div className=\"dock-tab-hit-area\"></div>\r\n                        </div>\r\n                    </div>\r\n                </div>\r\n                <div className=\"dock-ink-bar dock-ink-bar-animated\" style=\"left: 0px; width: 30px;\"></div>\r\n            </div>\r\n        </div>\r\n        <div className=\"dock-nav-operations dock-nav-operations-hidden\">\r\n            <button type=\"button\" className=\"dock-nav-more\" tabIndex=\"-1\" aria-hidden=\"true\" aria-haspopup=\"listbox\"\r\n                    aria-controls=\"rc-tabs-1-more-popup\" id=\"rc-tabs-1-more\" aria-expanded=\"false\"\r\n                    style=\"visibility: hidden; order: 1;\">...\r\n            </button>\r\n        </div>\r\n        <div className=\"dock-extra-content\">\r\n            <div className=\"dock-panel-max-btn\"></div>\r\n        </div>\r\n    </div>\r\n</div>;\r\n    */\r\n// <LayoutProps, LayoutState>\r\nfunction makeAnchorControl(side: string){\r\n    let s = side[0];\r\n\r\n\r\n    const str = `<div class=\"dock-drop-square dock-drop-${side}-anchor\" onmouseup=\"confirmSetAnchor('${s}')\" onmouseenter=\"highlightAnchorArea('${s}')\" onmouseleave=\"hideAnchorArea('${s}')\"\">\r\n<div class=\"dock-drop-square-box\">\r\n<i class=\"bi bi-pin-angle-fill\"></i>\r\n</div>\r\n</div>`;\r\n    return U.toHtml(str);\r\n}\r\nconst anchorControls = [\r\n    makeAnchorControl('top'),\r\n    makeAnchorControl('bottom'),\r\n    makeAnchorControl('left'),\r\n    makeAnchorControl('right'),\r\n];\r\n\r\n// todo: how to drop pinned tabs in the main layout https://github.com/ticlo/rc-dock/issues/97there is also an official example with a different strat\r\nexport class PinnableDock extends DockLayout{\r\n    static instance: PinnableDock;\r\n    constructor(props: any) {\r\n        super(props);\r\n        console.trace(\"pinnableDock instance\", this);\r\n        //Log.exDevv(PinnableDock.instance, \"current PinnableDock is a singleton, cannot make 2 instances\", {thiss:this, oldnstance: PinnableDock.instance});\r\n        PinnableDock.instance = this;\r\n        let debug:boolean = false;\r\n        if (!debug) return;\r\n        let t: GObject = this;\r\n        // for debug only, discovery of inner events\r\n        for (let k in t) {\r\n            let originalfunc = t[k];\r\n            if (typeof t[k] === \"function\") t[k] = function (...a:any): any {\r\n                console.warn('PinnableDock called ' + k, {arguments});\r\n                return originalfunc(...a);\r\n            }\r\n        }\r\n    }\r\n\r\n    hideTab(tid: string, pinnedSide: AnchorTypes){\r\n        let tabdata: TabData = this.find(tid) as TabData;\r\n        this.updateTab(tid, {...tabdata, pinned:pinnedSide} as any, false);\r\n        let siblings = this.getSiblings(tid);\r\n        let i = siblings.findIndex((t)=> t.id === tid);\r\n        let newActiveTab = this.getAdiacentTab(tid);\r\n        console.log(\"hideTab\", {siblings, i, newActiveTab, tabdata});\r\n        if (newActiveTab) this.updateTab(newActiveTab.id as string, newActiveTab, true);\r\n        else this.hidePanel(this.getPanelFromTab(tabdata));\r\n    }\r\n    getPanelFromTab(t: TabData): PanelData{\r\n        return t.parent as any;\r\n    }\r\n    hidePanel(p:PanelData): void {\r\n        // document.findElementById(p.id)\r\n    }\r\n    restoreTab(tid: string){\r\n        let tabdata = this.find(tid);\r\n        this.updateTab(tid, {...tabdata, pinned:undefined} as any, true);\r\n    }\r\n    setAsActiveTab(tid: string, tabdata?: TabData): void{ // todo: on mousehover on unpinned tabs\r\n        tabdata = tabdata || this.find(tid) as TabData;\r\n        this.updateTab(tid, tabdata, true);\r\n    }\r\n    setState<K extends keyof LayoutState>(state: ((prevState: Readonly<LayoutState>, props: Readonly<LayoutProps>) => (Pick<LayoutState, K> | LayoutState | null)) | Pick<LayoutState, K> | LayoutState | null, callback?: () => void) {\r\n        // console.warn(\"set state\", state, (state as any)?.dropRect?.element);\r\n        super.setState(state, callback);\r\n    }\r\n    getSiblings(tid: string): TabData[]{\r\n        let tabdata = this.find(tid);\r\n        let panel: PanelData = tabdata.parent as PanelData;\r\n        return panel.tabs;\r\n    }\r\n    getAdiacentTab(tid: string): TabData | undefined{\r\n        let siblings: GObject<TabData>[] = this.getSiblings(tid);\r\n        let i0 = siblings.findIndex((t)=> t.id === tid);\r\n        let i = i0;\r\n        while (++i < siblings.length) if(!siblings[i].pinned) return siblings[i];\r\n        i = i0;\r\n        while (--i >= 0) if(!siblings[i].pinned) return siblings[i];\r\n        return undefined;\r\n    }\r\n    getNextTab(tid: string): TabData | undefined{\r\n        let siblings: GObject<TabData>[] = this.getSiblings(tid);\r\n        let i = siblings.findIndex((t)=> t.id === tid);\r\n        while (++i < siblings.length) if(!siblings[i].pinned) return siblings[i];\r\n        return undefined;\r\n    }\r\n    getPrevTab(tid: string): TabData | undefined{\r\n        let siblings: GObject<TabData>[] = this.getSiblings(tid);\r\n        let i = siblings.findIndex((t)=> t.id === tid);\r\n        while (--i >= 0) if(!siblings[i].pinned) return siblings[i];\r\n        return undefined;\r\n    }\r\n    public static getTabFromDropRect(dropRect: LayoutState['dropRect']): TabData{\r\n        if (!dropRect.source) return undefined as any;\r\n        const panel: PanelData = dropRect.source.props.panelData;\r\n        console.log(\"getTabFromDropRect\", {dropRect, panel, active: panel.activeId});\r\n        const tabdata: TabData = panel.tabs.filter(t=> t.id === panel.activeId)[0];\r\n        return tabdata;\r\n    }\r\n\r\n    componentDidUpdate(prevProps: Readonly<LayoutProps>, prevState: Readonly<LayoutState>, snapshot?: any) {\r\n        super.componentDidUpdate(prevProps, prevState, snapshot);\r\n        if (this.state.dropRect) {\r\n            let droparea = this.state.dropRect.element;\r\n            if (!droparea || droparea.classList.contains('dock-style-models')) return;\r\n            /*<div class=\"dock-drop-square dock-drop-top anchor\"><div class=\"dock-drop-square-box\"></div></div>*/\r\n            let droplayer = droparea.querySelector('.dock-drop-layer');\r\n            currentDropArea = droparea;\r\n            dockLayout = windoww.htmldockLayout = this._ref;\r\n            currentDropRect = this.state.dropRect;\r\n            if (!droplayer) return;\r\n            droplayer.append(...anchorControls);\r\n            let tab = PinnableDock.getTabFromDropRect(droparea);\r\n            console.log('activating pin buttons', {tab, currentDropRect, dockLayout, droparea, prevProps, prevState, snapshot}, );\r\n            // todo: tabfocus but not the active one, the clicked one\r\n            // droparea.style.backgroundColor = \"red\";\r\n        }\r\n        // document.querySelectorAll('.dock-drop-layer')\r\n    }\r\n    //\r\n    // onDragStateChange = (draggingScope: any) => void{\r\n    //     //super.onDragStateChange(draggingScope);\r\n    // }\r\n    // onSilentChange(currentTabId?: string, direction?: DropDirection) {\r\n    //     super.onSilentChange(currentTabId, direction);\r\n    // }\r\n    // dockMove(source: TabData | PanelData, target: string | TabData | PanelData | BoxData | null, direction: DropDirection) {\r\n    //     super.dockMove(source, target, direction);\r\n    // }\r\n    //\r\n    // setDropRect(element: HTMLElement, direction?: DropDirection, source?: any, event?: { clientX: number; clientY: number }, panelSize?: [number, number]) {\r\n    //     super.setDropRect(element, direction, source, event, panelSize);\r\n    // }\r\n    //\r\n    // changeLayout(layoutData: LayoutData, currentTabId: string, direction: DropDirection, silent?: boolean) {\r\n    //     super.changeLayout(layoutData, currentTabId, direction, silent);\r\n    // }\r\n    // updateTab(id: string, newTab: TabData, makeActive?: boolean): boolean {\r\n    //     return super.updateTab(id, newTab, makeActive);\r\n    // }\r\n\r\n    render(): React.ReactNode {\r\n        return <div className={\"pinnable-dock-root white-style\"}>\r\n            <PinnableStrip side={\"t\"} />\r\n            <div className={\"pinnable-dock-middle-strip\"}>\r\n                <PinnableStrip side={\"l\"} />\r\n                <div className={\"not-strip\"}>{super.render()}</div>\r\n                <PinnableStrip side={\"r\"} />\r\n            </div>\r\n            <PinnableStrip side={\"b\"} />\r\n        </div>\r\n    }\r\n}\r\n","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\components\\editors\\languages\\Ocl.tsx",["1747","1748"],"import React, {CSSProperties, Dispatch, ReactElement} from 'react';\r\nimport {connect} from 'react-redux';\r\nimport Editor from '@monaco-editor/react';\r\nimport {DState, DViewElement, LViewElement, Pointer, Defaults} from '../../../joiner';\r\nimport {useStateIfMounted} from 'use-state-if-mounted';\r\nimport {FakeStateProps} from '../../../joiner/types';\r\nimport { Btn, CommandBar } from '../../commandbar/CommandBar';\r\n\r\nfunction OclEditorComponent(props: AllProps) {\r\n    const view = props.view;\r\n    const [ocl, setOcl] = useStateIfMounted(view.oclCondition);\r\n    const [show, setShow] = useStateIfMounted(true);\r\n\r\n    const [expand, setExpand] = useStateIfMounted(false);\r\n\r\n    if(!view) return(<></>);\r\n    const readOnly = props.readonly !== undefined ? props.readonly : Defaults.check(view.id);\r\n    const change = (value: string|undefined) => { // save in local state for frequent changes.\r\n        if(value !== undefined) setOcl(value);\r\n    }\r\n    const blur = () => { view.oclCondition = ocl } // confirm in redux state for final state\r\n\r\n    const lines = (Math.round(view.oclCondition.split(/\\r|\\r\\n|\\n/).length*1.8) < 5 ? 10 : Math.round(view.oclCondition.split(/\\r|\\r\\n|\\n/).length*1.8));\r\n\r\n    return(<>\r\n        <div style={{...(props.style || {})}} className={'cursor-pointer d-flex'} onClick={e => setShow(!show)}>\r\n            <span className={'chevron-holder'} tabIndex={-1} >\r\n                <i className={'bi bi-chevron-' + (show ? 'down' : 'right')} />\r\n                {/*show ? <i className={'bi bi-eye-fill'} /> : <i className={'bi bi-eye-slash-fill'} /> */}\r\n            </span>\r\n            <label className={'editor-label'}>\r\n                OCL Editor {/*(OCL engine by Stephan Köninger,\r\n                <a className={'ms-1'} target={'_blank'} href={'https://ocl.stekoe.de/#examples'}>Supported instructions</a>)*/}\r\n            </label>\r\n            {/* show && <CommandBar style={{paddingTop: '10px'}}>\r\n                {expand ?\r\n                    <Btn icon={'shrink'} action={(e) => {setExpand(false); setShow(true)}} tip={'Minimize editor'}/>\r\n                    :\r\n                    <Btn icon={'expand'} action={(e) => {setExpand(true); setShow(true)}} tip={'Enlarge editor'}/>\r\n                }\r\n            </CommandBar>*/}\r\n        </div>\r\n\r\n        {show && <div className={\"monaco-editor-wrapper\"}\r\n                style={{padding: '5px', minHeight: '20px', height:`${expand ? lines+'lvh' : '5lvh'}`, transition: 'height 0.3s', resize: 'vertical', overflow:'hidden'}}\r\n                      tabIndex={-1}\r\n                      onFocus={() => setExpand(true)}\r\n                    onBlur={() => {setExpand(false); blur();}}>\r\n            <Editor className={'mx-1'} onChange={change}\r\n                    options={{fontSize: 12, scrollbar: {vertical: 'hidden', horizontalScrollbarSize: 5}, minimap: {enabled: false}, readOnly: readOnly}}\r\n                    defaultLanguage={'js'} value={view.oclCondition} />\r\n        </div>}\r\n    </>);\r\n}\r\ninterface OwnProps {\r\n    readonly?: boolean;\r\n    viewID: Pointer<DViewElement, 1, 1, LViewElement>;\r\n    style?: CSSProperties;\r\n}\r\ninterface StateProps { view: LViewElement }\r\ninterface DispatchProps {}\r\ntype AllProps = OwnProps & StateProps & DispatchProps;\r\n\r\nfunction mapStateToProps(state: DState, ownProps: OwnProps): StateProps {\r\n    const ret: StateProps = {} as FakeStateProps;\r\n    ret.view = LViewElement.fromPointer(ownProps.viewID);\r\n    return ret;\r\n}\r\n\r\nfunction mapDispatchToProps(dispatch: Dispatch<any>): DispatchProps {\r\n    const ret: DispatchProps = {};\r\n    return ret;\r\n}\r\n\r\n\r\nexport const OclEditorConnected = connect<StateProps, DispatchProps, OwnProps, DState>(\r\n    mapStateToProps,\r\n    mapDispatchToProps\r\n)(OclEditorComponent);\r\n\r\nexport const OclEditor = (props: OwnProps, children: (string | React.Component)[] = []): ReactElement => {\r\n    return <OclEditorConnected {...{...props, children}} />;\r\n}\r\n\r\nOclEditorComponent.cname = 'OclEditorComponent';\r\nOclEditorConnected.cname = 'OclEditorConnected';\r\nOclEditor.cname = 'OclEditor';\r\nexport default OclEditor;\r\n","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\components\\editors\\languages\\Jsx.tsx",["1749","1750","1751","1752","1753","1754"],"import React, {Dispatch, ReactElement, ReactNode, useEffect} from \"react\";\r\nimport {connect} from \"react-redux\";\r\nimport {useStateIfMounted} from \"use-state-if-mounted\";\r\nimport type {FakeStateProps} from \"../../../joiner/types\";\r\nimport {DState, DViewElement, LViewElement, Pointer, Defaults} from \"../../../joiner\";\r\nimport Editor, { useMonaco } from \"@monaco-editor/react\";\r\n\r\n// import monacoTypes2 from '!raw-loader!../../../static/monacotypes';\r\nimport monacoTypes from '../../../static/monacotypes';\r\nimport { CommandBar, Btn } from \"../../commandbar/CommandBar\";\r\nimport { uniqueId } from \"lodash\";\r\n\r\nfunction JsxEditorComponent(props: AllProps) {\r\n    const monaco = useMonaco();\r\n    const view = props.view;\r\n    const dview = view.__raw;\r\n    const readOnly = props.readonly !== undefined ? props.readonly : !props.debugmode && Defaults.check(dview.id);\r\n    const [jsx, setJsx] = useStateIfMounted(dview.jsxString || '');\r\n    const [show, setShow] = useStateIfMounted(true);\r\n\r\n    const [expand, setExpand] = useStateIfMounted(false);\r\n\r\n    const change = (value: string|undefined) => { // save in local state for frequent changes.\r\n        if (value !== undefined) setJsx(value);\r\n    }\r\n\r\n\r\n    const blur = (evt?: React.FocusEvent) => { // confirm in redux state for final state\r\n        view.jsxString = jsx;\r\n    }\r\n\r\n    useEffect(() => {\r\n        if (!monaco) return;\r\n        monaco.languages.typescript.typescriptDefaults.setCompilerOptions({\r\n            target: monaco.languages.typescript.ScriptTarget.Latest,\r\n            allowNonTsExtensions: true,\r\n            moduleResolution: monaco.languages.typescript.ModuleResolutionKind.NodeJs,\r\n            module: monaco.languages.typescript.ModuleKind.CommonJS,\r\n            noEmit: true,\r\n            esModuleInterop: true,\r\n            jsx: monaco.languages.typescript.JsxEmit.React,\r\n            reactNamespace: \"React\",\r\n            allowJs: true,\r\n            typeRoots: [\"node_modules/@types\"]//, 'src/static/'], // doubt those can be accesed at runtime but trying\r\n        });\r\n\r\n        monaco.languages.typescript.typescriptDefaults.setDiagnosticsOptions({ noSemanticValidation: false, noSyntaxValidation: false });\r\n        monaco.languages.typescript.javascriptDefaults.setEagerModelSync(true);\r\n\r\n        monaco.languages.typescript.typescriptDefaults.addExtraLib(\"declare var data: 'datatype';\");\r\n        /*\r\n        // doubt those files can be accesed at runtime but trying\r\n        monaco.languages.typescript.javascriptDefaults.addExtraLib('declare var data: LModelElement; declare var node: LGraphElement;', 'src/static/monacotypes.d.ts');\r\n\r\n        monaco.languages.typescript.typescriptDefaults.addExtraLib(\r\n            '<<react-definition-file>>',\r\n            `file:///node_modules/@react/types/index.d.ts`\r\n        );*/\r\n\r\n\r\n\r\n    }, [monaco]);\r\n\r\n    //const lines = (Math.round(dview.jsxString.split(/\\r|\\r\\n|\\n/).length*1.8) < 5 ? 5 : Math.round(dview.jsxString.split(/\\r|\\r\\n|\\n/).length*1.8));\r\n\r\n    let lines: number;\r\n    if (expand) {\r\n        lines = 1;\r\n        for (let i = 0; i < dview.jsxString.length; i++) if (dview.jsxString[i] === '\\n') lines++;\r\n        lines += 2; // \"margin\"\r\n    } else {\r\n        lines = 5;\r\n    }\r\n    if (lines < 5) lines = 5;\r\n    return(<>\r\n        <div className={'cursor-pointer d-flex'} onClick={e => setShow(!show)}>\r\n            <span className={'my-auto'} tabIndex={-1} >\r\n                <i className={'bi bi-chevron-' + (show ? 'down' : 'right')} />\r\n                {/*show ? <i className={'bi bi-eye-fill'} /> : <i className={'bi bi-eye-slash-fill'} /> */}\r\n            </span>\r\n            <label className={'editor-label'}>\r\n                JSX Editor\r\n            </label>\r\n\r\n            {/* show && <CommandBar style={{paddingTop: '10px'}}>\r\n                {expand ?\r\n                    <Btn icon={'shrink'} action={(e) => {setExpand(false); setShow(true)}} tip={'Minimize editor'}/>\r\n                    :\r\n                    <Btn icon={'expand'} action={(e) => {setExpand(true); setShow(true)}} tip={'Enlarge editor'}/>\r\n                }\r\n            </CommandBar>*/}\r\n        </div>\r\n        {show && <div className={'mt-1'}>\r\n            {jsx.match(/{\\s*\\(.+\\?.+\\:.+\\)\\s*}/gm) && <label>\r\n                <b className={'text-warning'}>Warning:</b>\r\n                Please remove the round parenthesis, concatenate it with an empty string as in &#123; (a ? b : c) + '' &#125;\r\n                or replace the ternary operator as in (a && b || c).\r\n            </label>}\r\n            {(jsx).indexOf('<>') >= 0 && <label>\r\n                <b className={'text-warning'}>Warning:</b>\r\n                JSX.Fragment {'<>'} is valid JSX but is not supported by our compiler.\r\n                Please replace it with an array [] instead.\r\n            </label>}\r\n            {(jsx).indexOf('?.') >= 0 && <label>\r\n                <b className={'text-warning'}>Warning:</b>\r\n                Optional chaining {'.?'} is valid JS but is not supported by our compiler.\r\n                Please replace it with && instead. Eg: from (a?.b) to (a && a.b).\r\n            </label>}\r\n            {(jsx).indexOf('??') >= 0 && <label>\r\n                <b className={'text-warning'}>Warning:</b>\r\n                Nullish coalescing {'??'} is valid JS but is not supported by our compiler.\r\n                Please replace it with explicit null and undefined checks, or a ||.\r\n            </label>}\r\n        </div>}\r\n        {show && <div className={'monaco-editor-wrapper'}\r\n                    style={{padding: '5px', minHeight: '20px', transition: 'height 0.3s', height:`${expand ? 'calc('+(lines-1)+' * 16px)' : (5*16)+'px'}`, resize: 'vertical', overflow:'hidden'}}\r\n                    onFocus={() => setExpand(true)}\r\n                    onBlur={(e) => {setExpand(false); blur(e);}}\r\n                    tabIndex={-1} >\r\n            <Editor className={'mx-1'} onChange={change} language={\"typescript\"}\r\n                    options={{fontSize: 12, scrollbar: {vertical: 'hidden', horizontalScrollbarSize: 5}, minimap: {enabled: false}, readOnly: readOnly}}\r\n                    defaultLanguage={'typescript'} value={dview.jsxString} />\r\n        </div>}\r\n    </>);\r\n}\r\ninterface OwnProps {\r\n    viewid: Pointer<DViewElement, 1, 1, LViewElement>;\r\n    readonly?: boolean;\r\n}\r\n\r\ninterface StateProps {\r\n    view: LViewElement;\r\n    debugmode: boolean;\r\n}\r\ninterface DispatchProps {}\r\ntype AllProps = OwnProps & StateProps & DispatchProps;\r\n\r\n\r\nfunction mapStateToProps(state: DState, ownProps: OwnProps): StateProps {\r\n    const ret: StateProps = {} as FakeStateProps;\r\n    ret.debugmode = state.debug;\r\n    ret.view = LViewElement.fromPointer(ownProps.viewid);\r\n    return ret;\r\n}\r\n\r\nfunction mapDispatchToProps(dispatch: Dispatch<any>): DispatchProps {\r\n    const ret: DispatchProps = {};\r\n    return ret;\r\n}\r\n\r\n\r\nexport const JsxEditorConnected = connect<StateProps, DispatchProps, OwnProps, DState>(\r\n    mapStateToProps,\r\n    mapDispatchToProps\r\n)(JsxEditorComponent);\r\n\r\nexport const JsxEditor = (props: OwnProps, children: (string | React.Component)[] = []): ReactElement => {\r\n    return <JsxEditorConnected {...{...props, children}} />;\r\n}\r\n\r\nJsxEditorComponent.cname = \"JsxEditorComponent\";\r\nJsxEditorConnected.cname = \"JsxEditorConnected\";\r\nJsxEditor.cname = \"JsxEditor\";\r\nexport default JsxEditor;\r\n","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\components\\editors\\languages\\Js.tsx",["1755","1756","1757","1758"],"import React, {CSSProperties, Dispatch, ReactElement, ReactNode, useEffect} from 'react';\r\nimport {connect} from 'react-redux';\r\nimport Editor, {useMonaco} from '@monaco-editor/react';\r\nimport {\r\n    Defaults,\r\n    DPointerTargetable,\r\n    DState,\r\n    DViewElement,\r\n    LPointerTargetable,\r\n    LViewElement, Overlap,\r\n    Pointer\r\n} from '../../../joiner';\r\nimport {useStateIfMounted} from 'use-state-if-mounted';\r\nimport {FakeStateProps} from '../../../joiner/types';\r\nimport { CommandBar, Btn } from '../../commandbar/CommandBar';\r\n\r\nfunction JsEditorComponent(props: AllProps) {\r\n    const {placeHolder, height, title, getter, setter, jsxLabel, field} = props;\r\n    let data: LPointerTargetable = LPointerTargetable.wrap(props.data) as any;\r\n    let value = getter ? getter(data, field) : ((data|| {}) as any)[field as any];\r\n    const [js, setJs] = useStateIfMounted(value);\r\n    const [show, setShow] = useStateIfMounted(props.initialExpand ? props.initialExpand(data, field) : false);\r\n    const [expand, setExpand] = useStateIfMounted(false);\r\n    const monaco = useMonaco();\r\n    (window as any).monaco = monaco;\r\n\r\n    const readOnly = props.readonly !== undefined ? props.readonly : !props.debugmode && Defaults.check(data.id);\r\n    const change = (value: string|undefined) => {\r\n        /* save in local state for frequent changes */\r\n        if (value !== undefined) setJs(value);\r\n    }\r\n    const blur = () => {\r\n        /* confirm in redux state for final state */\r\n        if (js && setter) setter(js, data, field);\r\n        else if(field) (data as any)[field] = js;\r\n    }\r\n\r\n    useEffect(() => {\r\n        if (!monaco) return;\r\n        monaco.languages.typescript.typescriptDefaults.setCompilerOptions({\r\n            target: monaco.languages.typescript.ScriptTarget.Latest,\r\n            allowNonTsExtensions: true,\r\n            moduleResolution: monaco.languages.typescript.ModuleResolutionKind.NodeJs,\r\n            module: monaco.languages.typescript.ModuleKind.CommonJS,\r\n            noEmit: true,\r\n            esModuleInterop: true,\r\n            reactNamespace: 'React',\r\n            allowJs: true,\r\n            typeRoots: ['node_modules/@types']//, 'src/static/'], // doubt those can be accesed at runtime but trying\r\n        });\r\n        monaco.languages.typescript.typescriptDefaults.setDiagnosticsOptions({ noSemanticValidation: false, noSyntaxValidation: false });\r\n        monaco.languages.typescript.javascriptDefaults.setEagerModelSync(true);\r\n        monaco.languages.typescript.typescriptDefaults.addExtraLib(`declare var data: 'datatype';`);\r\n    }, [monaco]);\r\n    if (!((data && field) || (getter && setter))) return(<>Either props.data & field or both getter & setter are required.</>);\r\n\r\n    if (placeHolder && !js) value = placeHolder;\r\n    if (!value) value = '';\r\n    const lines = (Math.round(value.split(/\\r|\\r\\n|\\n/).length*1.8) < 5 ? 10 : Math.round(value.split(/\\r|\\r\\n|\\n/).length*1.8));\r\n\r\n    return <>\r\n        <div style={{...(props.style || {})}} className={'cursor-pointer d-flex'} onClick={e => setShow(!show)}>\r\n            <span className={'my-auto'} tabIndex={-1}>\r\n                <i className={'bi bi-chevron-' + (show ? 'down' : 'right')} />\r\n                {/*show ? <i className={'bi bi-eye-fill'} /> : <i className={'bi bi-eye-slash-fill'} /> */}\r\n            </span>\r\n            <label className={'editor-label'}>\r\n                {title || 'JS Editor'}\r\n            </label>\r\n            {jsxLabel && jsxLabel}\r\n            {/* show && <CommandBar style={{paddingTop: '10px'}}>\r\n                {expand ?\r\n                    <Btn icon={'shrink'} action={(e) => {setExpand(false); setShow(true)}} tip={'Minimize editor'}/>\r\n                    :\r\n                    <Btn icon={'expand'} action={(e) => {setExpand(true); setShow(true)}} tip={'Enlarge editor'}/>\r\n                }\r\n            </CommandBar>*/}\r\n        </div>\r\n        {show && <div className={'monaco-editor-wrapper'}\r\n                /* style={{padding: '5px', minHeight: '20px', height: height ? `${height}px` : '100px', resize: 'vertical', overflow:'hidden'}}*/\r\n                style={{padding: '5px', minHeight: '20px', height:`${expand ? lines+'lvh' : '5lvh'}`, transition: 'height 0.3s', resize: 'vertical', overflow:'hidden'}}\r\n                tabIndex={-1}\r\n                onFocus={() => setExpand(true)}\r\n                onBlur={() => {setExpand(false);blur()}}>\r\n            <Editor className={'mx-1'} onChange={change}\r\n                    options={{fontSize: 12, scrollbar: {vertical: 'hidden', horizontalScrollbarSize: 5}, minimap: {enabled: false}, readOnly: readOnly}}\r\n                    defaultLanguage={'typescript'} value={value} />\r\n        </div>}\r\n    </>;\r\n}\r\ninterface OwnProps {\r\n    readonly?: boolean;\r\n    data?: Pointer | DPointerTargetable | LPointerTargetable;\r\n    field?: string;\r\n    placeHolder?: string;\r\n    title?: ReactNode;\r\n    height?: number;\r\n    style?: CSSProperties;\r\n    jsxLabel?: ReactNode;\r\n    getter?: (data?:LPointerTargetable, field?: string) => string;\r\n    setter?: (js: string, data?:LPointerTargetable, field?: string) => void;\r\n    initialExpand?: (data: LPointerTargetable, field?: string) => boolean;\r\n}\r\ninterface StateProps {\r\n    data?: LPointerTargetable;\r\n    debugmode: boolean;}\r\ninterface DispatchProps {}\r\ntype AllProps = Overlap<Overlap<OwnProps, StateProps>, DispatchProps>;\r\n\r\n\r\nfunction mapStateToProps(state: DState, ownProps: OwnProps): StateProps {\r\n    const ret: StateProps = {} as FakeStateProps;\r\n    ret.data = LViewElement.wrap(ownProps.data);\r\n    ret.debugmode = state.debug;\r\n    return ret;\r\n}\r\n\r\nfunction mapDispatchToProps(dispatch: Dispatch<any>): DispatchProps {\r\n    const ret: DispatchProps = {};\r\n    return ret;\r\n}\r\n\r\n\r\nexport const JsEditorConnected = connect<StateProps, DispatchProps, OwnProps, DState>(\r\n    mapStateToProps,\r\n    mapDispatchToProps\r\n)(JsEditorComponent);\r\n\r\nexport const JsEditor = (props: OwnProps, children: (string | React.Component)[] = []): ReactElement => {\r\n    return <JsEditorConnected {...{...props, children}} />;\r\n}\r\n\r\nJsEditorComponent.cname = 'JsEditorComponent';\r\nJsEditorConnected.cname = 'JsEditorConnected';\r\nJsEditor.cname = 'JsEditor';\r\n","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\components\\editors\\languages\\Javascript.tsx",["1759","1760","1761"],"import React, {CSSProperties, Dispatch, ReactElement, ReactNode, useEffect} from 'react';\r\nimport {connect} from 'react-redux';\r\nimport Editor, {useMonaco} from '@monaco-editor/react';\r\nimport {\r\n    DState,\r\n    DViewElement,\r\n    LViewElement,\r\n    Pointer,\r\n    Defaults,\r\n    LPointerTargetable,\r\n    Pack1,\r\n    Overlap, GObject, Log, Info\r\n} from '../../../joiner';\r\nimport {useStateIfMounted} from 'use-state-if-mounted';\r\nimport {Btn, CommandBar} from '../../commandbar/CommandBar';\r\n\r\nfunction JavascriptEditorComponent(props: AllProps) {\r\n    let {placeHolder, height, title, jsxLabel, data, field} = props;\r\n    let getter = ((): string => data && field && (data as any)[field]) || props.getter;\r\n    let setter = ((val: string) => {\r\n        data && field && ((data as any)[field] = val)\r\n        return;\r\n    }) || props.setter;\r\n    const [js, setJs] = useStateIfMounted(getter());\r\n    const [show, setShow] = useStateIfMounted(props.hide === false ? false : true);\r\n\r\n    const [expand, setExpand] = useStateIfMounted(false);\r\n\r\n    const [showTooltip, setShowTooltip] = useStateIfMounted(false);\r\n    const readOnly = props.readonly !== undefined ? props.readonly : data && Defaults.check(data.id);\r\n    const change = (value: string|undefined) => {\r\n        /* save in local state for frequent changes */\r\n        setJs(value || '');\r\n    }\r\n    const blur = () => {\r\n        /* confirm in redux state for final state */\r\n        setter(js);\r\n    }\r\n    const monaco = useMonaco();\r\n    (window as any).monaco = monaco;\r\n\r\n    useEffect(() => {\r\n        if (!monaco) return;\r\n        monaco.languages.typescript.typescriptDefaults.setCompilerOptions({\r\n            target: monaco.languages.typescript.ScriptTarget.Latest,\r\n            allowNonTsExtensions: true,\r\n            moduleResolution: monaco.languages.typescript.ModuleResolutionKind.NodeJs,\r\n            module: monaco.languages.typescript.ModuleKind.CommonJS,\r\n            noEmit: true,\r\n            esModuleInterop: true,\r\n            reactNamespace: 'React',\r\n            allowJs: true,\r\n            typeRoots: ['node_modules/@types']//, 'src/static/'], // doubt those can be accesed at runtime but trying\r\n        });\r\n        monaco.languages.typescript.typescriptDefaults.setDiagnosticsOptions({ noSemanticValidation: false, noSyntaxValidation: false });\r\n        monaco.languages.typescript.javascriptDefaults.setEagerModelSync(true);\r\n        monaco.languages.typescript.typescriptDefaults.addExtraLib(`declare var data: 'datatype';`);\r\n    }, [monaco]);\r\n\r\n    let value = js || placeHolder;\r\n    let gata = data as GObject;\r\n    const info: Info | undefined = data && field && gata['__info_of__' + field];\r\n    let tooltip: ReactNode = ((props.tooltip === true) ? (info ? info.txt: '') : props.tooltip) || '';\r\n\r\n    if (jsxLabel === undefined && info) jsxLabel = typeof info.label === \"string\" ? <label className={'editor-label'}>{info.label}</label> : info.label || undefined;\r\n\r\n    if (typeof value === 'function') { value = (value as any).toString(); }\r\n    if (typeof value !== 'string') {\r\n        try { value = JSON.stringify(value); }\r\n        catch (e){\r\n            let msg = 'found invalid value for JsEditor. a string is required, found instead:' + typeof value;\r\n            Log.ee(msg, {e, value, field:props.field, data:props.data});\r\n            value = msg;\r\n        }\r\n    }\r\n    console.log('jsEditor', {value, p: props.field, t:props.title, l:props.jsxLabel});\r\n    return <>\r\n        <div style={{...(props.style || {})}} className={'cursor-pointer d-flex'} onMouseEnter={e => setShowTooltip(true)} onMouseLeave={e => setShowTooltip(false)} onClick={e => setShow(!show)}>\r\n            {props.hide !== undefined ? <span className={'my-auto'} tabIndex={-1}>\r\n                <i className={'bi bi-chevron-' + (show ? 'down' : 'right')} />\r\n                {/*show ? <i className={'bi bi-eye-fill'}/> : <i className={'bi bi-eye-slash-fill'}/>*/}\r\n            </span> : undefined}\r\n            {title}\r\n            {jsxLabel}\r\n\r\n            {show && <CommandBar style={{paddingTop: '10px'}}>\r\n                {expand ?\r\n                    <Btn icon={'shrink'} action={(e) => {setExpand(false); setShow(true)}} tip={'Minimize editor'}/>\r\n                    :\r\n                    <Btn icon={'expand'} action={(e) => {setExpand(true); setShow(true)}} tip={'Enlarge editor'}/>\r\n                }\r\n            </CommandBar>}\r\n        </div>\r\n        {(tooltip && showTooltip) && <div className={'my-tooltip'}>\r\n            <b className={'text-center text-capitalize'}>{field}</b>\r\n            <br />\r\n            <label>{tooltip}</label>\r\n        </div>}\r\n        {show && <div className={'monaco-editor-wrapper'}\r\n            /* style={{padding: '5px', minHeight: '20px', height: height ? `${height}px` : '100px', resize: 'vertical', overflow:'hidden'}}*/\r\n                      style={{padding: '5px', minHeight: '20px', height:`${expand ? '10lvh' : '5lvh'}`, transition: 'height 0.3s', resize: 'vertical', overflow:'hidden'}}\r\n                      tabIndex={-1} onBlur={blur}>\r\n            <Editor className={'mx-1'} onChange={change}\r\n                    options={{fontSize: 12, scrollbar: {vertical: 'hidden', horizontalScrollbarSize: 5}, minimap: {enabled: false}, readOnly: readOnly}}\r\n                    defaultLanguage={'typescript'} value={value} />\r\n        </div>}\r\n    </>;\r\n}\r\ninterface OwnProps {\r\n    data?: Pack1<LPointerTargetable>;\r\n    field?: string;\r\n    getter?: () => string;\r\n    setter?: (js: string) => void;\r\n    readonly?: boolean;\r\n    placeHolder?: string;\r\n    hide: boolean | undefined; // undefined = show and disable autohiding. boolean, set initial state and allow hiding button.\r\n    title?: ReactNode;\r\n    jsxLabel?: ReactNode;\r\n    tooltip?: ReactNode;\r\n    style?: CSSProperties;\r\n    height?: number;\r\n}\r\ninterface StateProps { data?: LPointerTargetable; }\r\ninterface DispatchProps {}\r\ntype AllProps = Overlap<Overlap<OwnProps, DispatchProps>, StateProps>;\r\n\r\n\r\nfunction mapStateToProps(state: DState, ownProps: OwnProps): StateProps {\r\n    const ret: StateProps = {} as any;\r\n    ret.data = LViewElement.wrap(ownProps.data);\r\n    return ret;\r\n}\r\n\r\nfunction mapDispatchToProps(dispatch: Dispatch<any>): DispatchProps {\r\n    const ret: DispatchProps = {};\r\n    return ret;\r\n}\r\n\r\n\r\nexport const JavascriptEditorConnected = connect<StateProps, DispatchProps, OwnProps, DState>(\r\n    mapStateToProps,\r\n    mapDispatchToProps\r\n)(JavascriptEditorComponent);\r\n\r\nexport const JavascriptEditor = (props: OwnProps, children: (string | React.Component)[] = []): ReactElement => {\r\n    return <JavascriptEditorConnected {...{...props, children}} />;\r\n}\r\n\r\nJavascriptEditorComponent.cname = 'JavascriptEditorComponent';\r\nJavascriptEditorConnected.cname = 'JavascriptEditorConnected';\r\nJavascriptEditor.cname = 'JavascriptEditor';\r\n","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\components\\editors\\index.ts",[],"C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\pages\\components\\popups\\Model.tsx",["1762","1763","1764","1765"],"import {DModel, Input, LGraph, LModel, LPackage, LProject, Pointer, Selectors, U} from '../../../joiner';\r\nimport TabDataMaker from '../../../components/abstract/tabs/TabDataMaker';\r\nimport DockManager from '../../../components/abstract/DockManager';\r\nimport './style.scss';\r\nimport React, {Dispatch, SetStateAction, useState} from 'react';\r\n\r\ntype Props = {metamodels: LModel[], project: LProject, setClicked: Dispatch<SetStateAction<string>>};\r\nfunction ModelPopup(props: Props): JSX.Element {\r\n    const {metamodels, project, setClicked} = props;\r\n    const [name, setName] = useState('');\r\n    const [metamodel, setMetamodel] = useState<Pointer>('');\r\n\r\n    const createM1 = async() => {\r\n        const dModel: DModel = DModel.new(name, metamodel as Pointer<DModel, 1, 1, LModel>, false, true);\r\n        const lModel: LModel = LModel.fromD(dModel);\r\n        project.models = [...project.models, lModel];\r\n        project.graphs = [...project.graphs, lModel.node as LGraph];\r\n        const tab = TabDataMaker.model(dModel);\r\n        await DockManager.open('models', tab);\r\n        setClicked('');\r\n    }\r\n\r\n    return(<div className={'popup-container'}>\r\n        <div className={'popup'}>\r\n            <div className={'close-container'}>\r\n                <i onClick={e => setClicked('')} className={'bi bi-x-lg text-danger close'} />\r\n            </div>\r\n            <section className={'px-3'}>\r\n                <div className={'input-container'}>\r\n                    <b className={'me-2'}>Name:</b>\r\n                    <input className={'input'} onChange={e => setName(e.target.value)} />\r\n                </div>\r\n                <div className={'input-container'}>\r\n                    <b className={'me-2'}>Metamodel:</b>\r\n                    <select className={'select'} onChange={e => setMetamodel(e.target.value)}>\r\n                        <option value={''}>----------</option>\r\n                        {metamodels.map(m => <option key={m.id} value={m.id}>{m.name}</option>)}\r\n                    </select>\r\n                </div>\r\n                <button onClick={createM1} disabled={!name || !metamodel} className={'btn btn-success d-block w-100 mt-3'}>\r\n                        Create\r\n                </button>\r\n            </section>\r\n        </div>\r\n    </div>);\r\n}\r\n\r\nexport {ModelPopup};\r\n","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\components\\metrics\\Metrics.tsx",["1766","1767","1768","1769","1770","1771","1772","1773","1774","1775","1776","1777","1778","1779","1780","1781","1782","1783","1784"],"import React, {useState} from \"react\";\r\nimport {\r\n    DModel, LModel,\r\n    DClass, DNamedElement,\r\n    DState,\r\n    DUser,\r\n    DValue,\r\n    DViewElement,\r\n    DViewPoint,\r\n    GObject,\r\n    LClass,\r\n    LGraphElement,\r\n    LNamedElement, LObject,\r\n    LPackage,\r\n    LProject,\r\n    LUser,\r\n    LValue, Pointer, U,\r\n    windoww,\r\n    LModelElement,\r\n    DModelElement\r\n} from '../../joiner';\r\nimport { CommandBar, Btn } from \"../commandbar/CommandBar\";\r\nimport { SetRootFieldAction } from \"../../joiner\";\r\nimport './metrics.scss';\r\nimport { int } from \"../../joiner/types\";\r\nimport ReactDOM from \"react-dom\";\r\n\r\ntype MetricsProps = {\r\n    data: LModelElement;\r\n    type?: string;\r\n    tip?: string;\r\n}\r\n\r\nfunction getAttributes(c: LClass): number {\r\n    let sum = 0;\r\n    if (c.extends.length === 0) {\r\n        return c.attributes.length;\r\n    } else {\r\n        c.extends.map(s => sum += getAttributes(s));\r\n        return c.attributes.length + sum;\r\n    }\r\n}\r\nfunction getReferences(c: LClass): number {\r\n    let sum = 0;\r\n    if (c.extends.length === 0) {\r\n        return c.references.length;\r\n    } else {\r\n        c.extends.map(s => sum += getAttributes(s));\r\n        return c.references.length + sum;\r\n    }\r\n}\r\n\r\nexport const showMetrics = () => {\r\n    windoww.MetricsPanelVisible = true;\r\n}\r\nexport const hideMetrics = () => {\r\n    windoww.MetricsPanelVisible = false;\r\n    SetRootFieldAction.new('metrics-panel', {display: false});\r\n}\r\nexport const toggleMetrics = () => {\r\n    if (!windoww.MetricsPanelVisible) {\r\n        windoww.MetricsPanelVisible = true;\r\n    } else {\r\n        windoww.MetricsPanelVisible = !windoww.MetricsPanelVisible;\r\n    }\r\n}\r\n\r\nclass MetricsPanelManager {\r\n    static open(model: any) {\r\n        if (!document) return;\r\n        \r\n        const metricsElement = document.createElement('div');\r\n        ReactDOM.render(React.createElement(MetricsPanel, {data: model}), metricsElement);\r\n        document.body.append(metricsElement);\r\n    }\r\n}\r\n\r\nexport const MetricsPanel = (props: MetricsProps) => {\r\n\r\n    const [mode,setMode] = useState<string>('EMF');\r\n\r\n    const getWidth = (value:int, scale: int) => {\r\n        return 100/scale * value + '%';\r\n    }\r\n\r\n    return (<>\r\n        {windoww.MetricsPanelVisible &&\r\n            <div className={'metrics-panel'}>\r\n                <h1>Metamodel Analytics\r\n                    <CommandBar style={{float: 'right', height: '20px'}}>\r\n                        <Btn icon={'close'} action={(e) => {hideMetrics(); return false;}} theme={'dark'} tip={'Close panel'}/>\r\n                    </CommandBar>\r\n                </h1>\r\n\r\n                <div className={'analytics-panel'}>\r\n\r\n                <div className={'category'}>\r\n                    <label>\r\n                        <CommandBar style={{float: 'left'}}>\r\n                            <Btn icon={\"info\"} action={(e) => {alert('information page')}} theme={'dark'}/>\r\n                        </CommandBar>\r\n                        Metamodel classification as\r\n                    </label>\r\n                    <select id={'category'} onChange={(e) => {setMode(e.target.value)}}>\r\n                        <option value={'EMF'}>EMF-based</option>\r\n                        <option value={'DSML'}>DSML</option>\r\n                        <option value={'GPML'}>GPML</option>\r\n                    </select>\r\n\r\n                </div>\r\n\r\n\r\n                {mode === 'GPML' && <>\r\n                    <div className={'chart GPML'}>\r\n                        <div className={'legenda small'} >small</div>\r\n                        <div className={'legenda medium'}>medium</div>\r\n                        <div className={'legenda large'}>large</div>\r\n                    </div>\r\n                    <div className={'chart GPML'}>\r\n                        <div className={'small section'}>50</div>\r\n                        <div className={'medium section'}>150</div>\r\n                        <div className={'large section'}>250</div>\r\n                    </div>\r\n                    <div className={'chart current'}\r\n                        style={{gridTemplateColumns: `${getWidth(props.data.model.classes.length, 250)} auto`}}>\r\n                        <div></div>\r\n                        <div>\r\n                            <div>{props.data.model.classes.length}</div>\r\n                            <div>{props.data.model.name}</div>\r\n                        </div>\r\n                    </div>\r\n                </>}\r\n                {mode === 'EMF' && <>\r\n                    <div className={'chart EMF'}>\r\n                        <div className={'legenda small'} >small</div>\r\n                        <div className={'legenda medium'}>medium</div>\r\n                        <div className={'legenda large'}>large</div>\r\n                    </div>\r\n                    <div className={'chart EMF'}>\r\n                        <div className={'small section'}>30</div>\r\n                        <div className={'medium section'}>50</div>\r\n                        <div className={'large section'}>80</div>\r\n                    </div>\r\n                    <div className={'chart current'}\r\n                        style={{gridTemplateColumns: `${getWidth(props.data.model.classes.length, 80)} auto`}}>\r\n                        <div></div>\r\n                        <div>\r\n                            <div>{props.data.model.classes.length}</div>\r\n                            <div>{props.data.model.name}</div>\r\n                        </div>\r\n                    </div>\r\n                </>}\r\n                {mode === 'DSML' && <>\r\n                    <div className={'chart DSML'}>\r\n                        <div className={'legenda small'} >small</div>\r\n                        <div className={'legenda medium'}>medium</div>\r\n                        <div className={'legenda large'}>large</div>\r\n                    </div>\r\n                    <div className={'chart DSML'}>\r\n                        <div className={'small section'}>10</div>\r\n                        <div className={'medium section'}>30</div>\r\n                        <div className={'large section'}>50</div>\r\n                    </div>\r\n                    <div className={'chart current'}\r\n                        style={{gridTemplateColumns: `${getWidth(props.data.model.classes.length, 50)} auto`}}>\r\n                        <div></div>\r\n                        <div>\r\n                            <div>{props.data.model.classes.length}</div>\r\n                            <div>{props.data.model.name}</div>\r\n                        </div>\r\n                    </div>\r\n                </>}\r\n                </div>\r\n\r\n\r\n                <hr style={{display: 'block', marginBottom: '5px'}}/>\r\n\r\n                <div className={'container'}>\r\n                    <div className={'hd'}>Acronym</div>\r\n                    <div className={'hd'}>Name</div>\r\n                    <div className={'hd value'}>Value</div>\r\n\r\n                    <div>PKG</div>\r\n                    <div># Packages</div>\r\n                    <Metrics type={'package'} data={props.data}/>\r\n\r\n                    <div>MC</div>\r\n                    <div># Metaclasses</div>\r\n                    <Metrics type={'metaclass'} data={props.data}/>\r\n\r\n                    <div>AMC</div>\r\n                    <div># Abstract Metaclasses</div>\r\n                    <Metrics type={'abstract'} data={props.data}/>\r\n\r\n                    <div>CMC</div>\r\n                    <div># Concrete Metaclasses</div>\r\n                    <Metrics type={'concrete'} data={props.data}/>\r\n\r\n                    <div>IFLMC</div>\r\n                    <div># Concrete Featureless Metaclasses</div>\r\n                    <Metrics type={'iflmc'} data={props.data}/>\r\n\r\n                    <div>MCWS</div>\r\n                    <div># Metaclasses with Superclass</div>\r\n                    <Metrics type={'mcws'} data={props.data}/>\r\n\r\n                    <div>LMC</div>\r\n                    <div>% Isolated Metaclasses</div>\r\n                    <Metrics type={'lmc'} data={props.data}/>\r\n\r\n                    <div>SF</div>\r\n                    <div># Structural Features</div>\r\n                    <Metrics type={'sf'} data={props.data}/>\r\n\r\n                    <div>ASF</div>\r\n                    <div>Avg # Structural Features</div>\r\n                    <Metrics type={'asf'} data={props.data}/>\r\n\r\n                    <div>EN/LIT</div>\r\n                    <div># Enumeration/Literals</div>\r\n                    <Metrics type={'enum'} data={props.data}/>\r\n                </div>\r\n                {/* <p><a target=\"_blank\" href=\"https://dl.acm.org/doi/abs/10.1145/2593770.2593774\">https://dl.acm.org/doi/abs/10.1145/2593770.2593774</a></p>*/}\r\n            </div>\r\n            }\r\n    </>);\r\n}\r\n\r\nexport const Metrics = (props: MetricsProps) => {\r\n\r\n\r\n\r\n/*\r\n    function getAttributes(c: LClass): number {\r\n        let sum = 0;\r\n        if (c.extends.length === 0) {\r\n            return c.attributes.length;\r\n        } else {\r\n            c.extends.map(s => sum += getAttributes(s));\r\n            return c.attributes.length + sum;\r\n        }\r\n    }\r\n    function getReferences(c: LClass): number {\r\n        let sum = 0;\r\n        if (c.extends.length === 0) {\r\n            return c.references.length;\r\n        } else {\r\n            c.extends.map(s => sum += getAttributes(s));\r\n            return c.references.length + sum;\r\n        }\r\n    }*/\r\n    let model: LModel = props.data.model;\r\n    let classes: LClass[] = model.classes;\r\n    let dclasses: DClass[] = classes.map(c=>c.__raw);\r\n    function getAllAttributes(): number {\r\n        let sum = 0;\r\n        //props.data?.model.classes.map(c => sum += getAttributes(c));\r\n        classes.forEach(c => sum += c.allAttributes.length); // includes attributes from inheritance at any level\r\n        return sum;\r\n    }\r\n    function getAllReferences(): number {\r\n        let sum = 0;\r\n        //props.data?.model.classes.map(d => sum += getReferences(d));\r\n        classes.forEach(c => sum += c.allReferences.length);\r\n        return sum;\r\n    }\r\n\r\n    let allRefsCount = getAllReferences();\r\n    let allAttrCount = getAllAttributes();\r\n    return (<div className={\"value\"}>\r\n        {props.type === \"package\" && <>{model.allSubPackages.length}</>}\r\n        {props.type === \"metaclass\" && <>{classes.length}</>}\r\n        {props.type === \"abstract\" && <>{dclasses.filter(c => c.abstract).length}</>}\r\n        {props.type === \"concrete\" && <>{classes.length - dclasses.filter(c => c.abstract).length}</>}\r\n        {props.type === \"iflmc\" && <>{dclasses.filter(c => (c.attributes.length + c.references.length) === 0).length}</>}\r\n        {props.type === \"mcws\" && <>{dclasses.filter(c => c.extends.length > 0).length}</>}\r\n        {props.type === \"sf\" && <>{allAttrCount + allRefsCount}</>}\r\n        {props.type === \"asf\" && <>{((allAttrCount + allRefsCount)/(dclasses.filter(c => !c.abstract).length)).toFixed(2)}</>}\r\n        {props.type === \"enum\" && <>{model.enumerators.length}/{model.literals.length}</>}\r\n        {props.type === \"attr\" && <>{model.attributes.length}/{allAttrCount}</>}\r\n        {props.type === \"ref\" && <>{model.references.length}/{allRefsCount}</>}\r\n        {props.type === \"lmc\" && <>{((model.classes.filter(c => c.extends.length === 0 && c.extendedBy.length === 0).length/model.classes.length)*100).toFixed(2)}%</>}\r\n        {props.type === \"ext\" && <>{dclasses.reduce((acc, c) => acc+c.extends.length, 0)}</>}\r\n        </div>);\r\n    // {props.type === \"ext\" && <>{model?.subNodes.filter(c => c.name === \"EdgeInheritance\").length}</>}\r\n    // contare gli archi per gli extend non è corretto, uno potrebbe nasconderli.\r\n\r\n}\r\n\r\nexport {MetricsPanelManager};","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\components\\contextMenu\\ContextMenu.tsx",["1785","1786","1787","1788"],"import React, {Dispatch, ReactElement, ReactNode} from 'react';\r\nimport {connect} from 'react-redux';\r\nimport './style.scss';\r\nimport {SetRootFieldAction} from '../../redux/action/action';\r\nimport {\r\n    DClass,\r\n    DNamedElement,\r\n    DState,\r\n    DUser,\r\n    DValue,\r\n    DViewElement,\r\n    GObject,\r\n    LClass,\r\n    LGraphElement, LModel,\r\n    LNamedElement,\r\n    LObject,\r\n    LPackage,\r\n    LProject, LReference,\r\n    LUser,\r\n    LValue,\r\n    U,\r\n    windoww,\r\n} from '../../joiner';\r\nimport MemoRec from '../../api/memorec';\r\nimport {useStateIfMounted} from 'use-state-if-mounted';\r\nimport ModellingIcon from \"../forEndUser/ModellingIcon\";\r\nimport {FakeStateProps} from \"../../joiner/types\";\r\nimport {toggleMetrics} from '../metrics/Metrics';\r\nimport {icon} from '../../pages/components/icons/Icons';\r\n\r\nfunction ContextMenuComponent(props: AllProps) {\r\n    const user = props.user;\r\n    // const project = user.project as LProject;\r\n    const display = props.display;\r\n    const position = props.position;\r\n    const node = props.node;\r\n    const [memorec, setMemorec] = useStateIfMounted<{data:GObject[], type:'class'|'package'}|null>(null);\r\n    const [suggestedName, setSuggestedName] = useStateIfMounted('');\r\n    const [childrenMenu, setChildrenMenu] = useStateIfMounted(false);\r\n    if (!node || !display) return(<></>);\r\n    const data: LNamedElement | undefined = LNamedElement.fromPointer(node?.model?.id);\r\n    let jsxList: ReactNode[] = [];\r\n\r\n    let ldata: LNamedElement = data as LNamedElement;\r\n    let ddata: DNamedElement = ldata?.__raw as DNamedElement;\r\n    let model = ldata?.model;\r\n\r\n    const close = () => {\r\n        // if (!windoww.ContextMenuVisible) return;\r\n        windoww.ContextMenuVisible = false;\r\n        setSuggestedName('');\r\n        setMemorec(null);\r\n        SetRootFieldAction.new('contextMenu', {display: false, x: 0, y: 0});\r\n        setChildrenMenu(false);\r\n    }\r\n\r\n    const addView = async() => {\r\n        DViewElement.newDefault(ddata as DNamedElement || undefined);\r\n        close();\r\n    }\r\n\r\n    const structuralFeature = async () => {\r\n        setMemorec(await MemoRec.structuralFeature(ldata));\r\n    }\r\n\r\n    const classifier = async() => {\r\n        setMemorec(await MemoRec.classifier(ldata));\r\n    }\r\n\r\n    const suggestOnClass = (isAttribute:boolean) => {\r\n        const lClass: LClass = (ldata as LClass);\r\n        if (isAttribute) lClass.addAttribute(suggestedName);\r\n        else lClass.addReference(suggestedName);\r\n        close();\r\n\r\n    }\r\n    const suggestOnPackage = () => { (ldata as LPackage).addClass(suggestedName); close(); }\r\n\r\n    /* Handling the add of composition children to specific M1 Object */\r\n\r\n\r\n    const getAddChildren = (l:LValue, model: LModel, out: LClass[] = []): ReactNode => {\r\n        let d = l.__raw;\r\n        const lref = l.instanceof as LReference;\r\n        if (!lref) return [];\r\n        let dref = lref.__raw;\r\n        if (dref.className !== 'DReference') return [];\r\n        if (!(dref.aggregation || dref.composition)) return [];\r\n        let values: any[] = l.values;\r\n        if (dref.upperBound !== -1 && values.filter(o=>!!o).length >= dref.upperBound) return [];\r\n        let type = lref.type;\r\n        out = [type, ...type.allSubClasses].filter(e=>!!e);\r\n        let jsxret: ReactNode;\r\n        if (out.length === 1) jsxret = <div onClick={() => { close(); l.addObject({}, out[0]); }} className={'col item'}>{icon['add']} Add {out[0].name}</div>\r\n        else jsxret = <div onClick={(e) => { setChildrenMenu(!childrenMenu)}} className={'col item'}>\r\n            {icon['add']} Add {icon['submenu']}\r\n            {childrenMenu && <div className={'context-menu round submenu'} style={{top: position.y - 216, left: position.x - 333}} onContextMenu={(e)=>e.preventDefault()}>\r\n                {out.map(lc =>\r\n                    <div onClick={() => {\r\n                        close();\r\n                        setChildrenMenu(false);\r\n                        const child = l.addObject({}, lc);\r\n                        l.values = [...(l.values as LObject[]), child];\r\n                    }} className={'col item'}>\r\n                        {lc.name}\r\n                    </div>\r\n                )}\r\n            </div>}\r\n        </div>;\r\n        return jsxret;\r\n    }\r\n\r\n    if (display) {\r\n\r\n\r\n        if (ddata?.name) {\r\n            if (ldata && model?.isMetamodel) {\r\n                jsxList.push(<div className={'mt-1 col'} style={{fontSize: '0.9rem', paddingLeft: '12px', fontWeight: '300'}}>{ddata.className}: <i>{ldata.name}</i></div>);\r\n            } else {\r\n                jsxList.push(<div className={'mt-1 col'} style={{fontSize: '0.9rem', paddingLeft: '12px', fontWeight: '300'}}>{ldata.name}</div>);\r\n            }\r\n            jsxList.push(<hr className={'my-1'} />);\r\n        }\r\n\r\n        // if (ddata?.className === 'DObject') {\r\n        //     jsxList.push(...(ldata as LObject).features.map(feat=>getAddChildren(feat, model, [])));\r\n        //     jsxList.push(<hr className={'my-1'} />);\r\n        // }\r\n\r\n        if (ddata?.className === 'DObject') {\r\n            let children = (ldata as LObject).features.map(feat=>getAddChildren(feat, model, []));\r\n            jsxList.push(...(ldata as LObject).features.map(feat=>getAddChildren(feat, model, []))); \r\n            /* @ts-ignore */\r\n            if (children[1]['$$typeof'] !== undefined) jsxList.push(<hr className={'my-1'}/>);\r\n        }\r\n\r\n        if (ddata?.className === 'DValue') {\r\n            jsxList.push(getAddChildren(ldata as any as LValue, model, []));\r\n            jsxList.push(<hr className={'my-1'}/>);\r\n        }\r\n\r\n        \r\n\r\n\r\n        /* Memorec */\r\n        if(ddata && !U.isOffline()) {\r\n            if(ddata.className === 'DClass') {\r\n                jsxList.push(<div onClick={structuralFeature} className={'col item'}>{icon['ai']} AI Suggest <i\r\n                    className='bi bi-chevron-right' style={{fontSize: '0.75em', float: 'right', paddingTop: '2px', fontWeight: '800'}} /></div>);\r\n                jsxList.push(<hr className={'my-1'} />);\r\n            }\r\n            if(ddata.className === 'DPackage') {\r\n                jsxList.push(<div onClick={classifier} className={'col item'}>{icon['ai']} AI Suggest <i\r\n                    className={'ms-1 bi bi-chevron-right'} style={{fontSize: '0.75em', float: 'right', paddingTop: '2px', fontWeight: '800'}} /></div>);\r\n                jsxList.push(<hr className={'my-1'} />);\r\n            }\r\n        }\r\n\r\n        /* Extend */\r\n\r\n        switch (ddata.className) {\r\n\r\n            default:\r\n            case undefined: break;\r\n            case 'DValue': if ((ldata as any as LValue).instanceof) jsxList.pop();break;\r\n            case 'DClass':\r\n                jsxList.push(<div onClick={() => {\r\n                    close();\r\n                    SetRootFieldAction.new('isEdgePending', {user: user.id, source: ddata.id});\r\n                }} className={'col item'}>{icon['extend']} Extend<div><i\r\n                    className='bi bi-command'></i> E</div></div>);\r\n                jsxList.push(<hr className={'my-1'} />);\r\n                \r\n                break;\r\n        }\r\n\r\n        /* Deselect */\r\n\r\n        jsxList.push(<div onClick={() => {\r\n            close();\r\n            SetRootFieldAction.new(`selected.${DUser.current}`, '', '', false);\r\n        }} className={'col item'}>{icon['deselect']} Deselect</div>);\r\n        //jsxList.push(<hr className={'my-1'} />);\r\n\r\n        \r\n        /* Delete */\r\n        \r\n        jsxList.push(<div onClick={() => { \r\n            close();\r\n            console.log('delete ctxmenu', {data, node});\r\n            if (ldata) ldata.delete();\r\n            else node.delete();// if there is data, then the node is indirectly deleted, no need to call it too.\r\n            //node.delete();\r\n        }} className={'col item'}>{icon['delete']} Delete<i\r\n            className='bi bi-backspace' style={{fontSize: '1em', float: 'right', paddingTop: '2px', fontWeight: '800'}} /></div>);\r\n        jsxList.push(<hr className={'my-1'} />);\r\n        \r\n        /* Refresh */\r\n\r\n        // jsxList.push(<div onClick={() => {alert('refresh')}} className={'col item'}>{icon['refresh']} Refresh</div>);\r\n        // jsxList.push(<hr className={'my-1'} />);\r\n\r\n        /* Up / Down */\r\n        jsxList.push(<div onClick={() => {close(); node.zIndex += 1;}} className={'col item'}>{icon['up']} Up<div>\r\n            <i className='bi bi-command' /><i className=\"bi bi-arrow-up\" /></div></div>);\r\n        jsxList.push(<div onClick={() => {close(); node.zIndex -= 1;}} className={'col item'}>{icon['down']} Down<div>\r\n            <i className='bi bi-command' /><i className=\"bi bi-arrow-down\" /></div></div>);\r\n        let gn = node as GObject;\r\n        jsxList.push(<hr className={'my-1'} />);\r\n        \r\n        /* AUTO-SIZING */\r\n        if (gn.isResized) jsxList.push(<div onClick={() => {close(); gn.isResized = false; }} className={'col item'}>{icon['contract']} Restore auto-sizing<div> <i\r\n            className='bi bi-command'></i> T</div></div>);\r\n        else jsxList.push(<div onClick={() => {close(); gn.isResized = true; }} className={'col item'}>{icon['expand']} Disable auto-sizing<div> <i\r\n            className='bi bi-command'></i> T</div></div>);\r\n        \r\n        // /* LOCK-UNLOCK */\r\n        // jsxList.push(<div onClick={() => {close(); ldata.delete(); /*node.delete();*/}} className={'col item'}>{icon['lock']} Lock/Unlock<div> <i\r\n        //     className='bi bi-command'></i> L</div></div>);\r\n        // /* UNLOCK ALL ELEMENTS */\r\n        // jsxList.push(<div onClick={() => {close(); ldata.delete(); /* node.delete();*/}} className={'col item'}>{icon['unlock']} Unlock all<div><i className=\"bi bi-alt\"></i> <i\r\n        //     className='bi bi-command'></i> L</div></div>);\r\n\r\n        jsxList.push(<hr className={'my-1'} />);\r\n        \r\n        /* METRICS */\r\n        if (ldata && model?.isMetamodel) {\r\n            jsxList.push(<div onClick={() => {close(); toggleMetrics();}} className={'col item'}>{icon['metrics']} Analytics<div>\r\n                <i className='bi bi-command' /> A</div></div>);\r\n            jsxList.push(<hr className={'my-1'} />);\r\n        }\r\n\r\n\r\n        /* ADD VIEW */\r\n        jsxList.push(<div onClick={async () => {close(); addView();}} className={'col item'}>{icon['view']} Add View<div>\r\n            <i className='bi bi-alt' /> <i className='bi bi-command' /> A</div></div>);\r\n    }\r\n\r\n    return(<>\r\n        <div className={'context-menu round'} style={{top: position.y - 100, left: position.x - 10}} onContextMenu={(e)=>e.preventDefault()}>\r\n            {jsxList.map((jsx, index) => {return <div key={index}>{jsx}</div>})}\r\n        </div>\r\n\r\n\r\n        {(data && memorec?.data) && <div className={'context-menu round'} style={{overflow: 'auto', maxHeight: '12em', top: position.y - 100, left: position.x + 130}}>\r\n            {(memorec.data.map((obj, index) => {\r\n                return (<div key={index}>\r\n                    <div className={'col item d-block'} onClick={e => setSuggestedName(obj.recommendedItem)}>\r\n                        {obj.recommendedItem} :\r\n                        <span className={'ms-1 text-primary'}>{Math.round(obj.score * 100) / 100}</span>\r\n                    </div>\r\n                </div>)\r\n            }))}\r\n        </div>}\r\n\r\n        {(memorec && suggestedName) && <div className={'memorec-overlay'}>\r\n            <div tabIndex={-1} onBlur={e => close()} className={'memorec-popup'}>\r\n                <div className={'d-block text-center mb-1'}>Add <b>{suggestedName}</b> as:</div>\r\n                {(memorec.type === 'class') ? <>\r\n                        <div tabIndex={-1} onClick={e =>suggestOnClass(true)} className={'d-flex memorec-button'}>\r\n                            <ModellingIcon className={'my-auto'} name={'attribute'} /> Attribute\r\n                        </div>\r\n                        <div tabIndex={-1} onClick={e =>suggestOnClass(false)} className={'d-flex memorec-button mt-1'}>\r\n                            <ModellingIcon className={'my-auto'} name={'reference'} /> Reference\r\n                        </div>\r\n                    </> :\r\n                    <div tabIndex={-1} onClick={e =>suggestOnPackage()} className={'d-flex memorec-button mt-1'}>\r\n                        <ModellingIcon className={'my-auto'} name={'class'} /> Class\r\n                    </div>\r\n                }\r\n                <div className={'d-flex memorec-button mt-3'} tabIndex={-1} onClick={e => close()}>\r\n                    <span className={'mx-auto text-danger'}>Close</span>\r\n                </div>\r\n            </div>\r\n        </div>}\r\n\r\n\r\n\r\n\r\n    </>);\r\n}\r\ninterface OwnProps {}\r\ninterface StateProps {\r\n    user: LUser,\r\n    display: boolean,\r\n    position: {x: number, y: number},\r\n    node: LGraphElement|null\r\n}\r\n\r\ninterface DispatchProps {}\r\ntype AllProps = OwnProps & StateProps & DispatchProps;\r\n\r\n\r\nfunction mapStateToProps(state: DState, ownProps: OwnProps): StateProps {\r\n    const ret: StateProps = {} as FakeStateProps;\r\n    ret.user = LUser.fromPointer(DUser.current);\r\n    ret.display = state.contextMenu.display;\r\n    ret.position = {x: state.contextMenu.x, y: state.contextMenu.y};\r\n\r\n    const nodeid = state.contextMenu.nodeid; //state._lastSelected?.node;\r\n    if (nodeid) ret.node = LGraphElement.fromPointer(nodeid);\r\n    else ret.node = null;\r\n    return ret;\r\n}\r\n\r\nfunction mapDispatchToProps(dispatch: Dispatch<any>): DispatchProps {\r\n    const ret: DispatchProps = {};\r\n    return ret;\r\n}\r\n\r\n\r\nexport const ContextMenuConnected = connect<StateProps, DispatchProps, OwnProps, DState>(\r\n    mapStateToProps,\r\n    mapDispatchToProps\r\n)(ContextMenuComponent);\r\n\r\nexport const ContextMenu = (props: OwnProps, childrens: (string | React.Component)[] = []): ReactElement => {\r\n    return <ContextMenuConnected {...{...props, childrens}} />;\r\n}\r\nexport default ContextMenu;\r\n","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\components\\editors\\Empty.tsx",[],"C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\pages\\components\\popups\\Metamodel.tsx",["1789","1790","1791"],"import {DModel, Input, LGraph, LModel, LPackage, LProject, Selectors, U} from '../../../joiner';\r\nimport TabDataMaker from '../../../components/abstract/tabs/TabDataMaker';\r\nimport DockManager from '../../../components/abstract/DockManager';\r\nimport './style.scss';\r\nimport React, {Dispatch, SetStateAction, useState} from 'react';\r\n\r\ntype Props = {project: LProject, setClicked: Dispatch<SetStateAction<string>>};\r\nfunction MetamodelPopup(props: Props): JSX.Element {\r\n    const {project, setClicked} = props;\r\n    const [name, setName] = useState('');\r\n\r\n    const createM2 = async() => {\r\n        const dModel = DModel.new(name, undefined, true);\r\n        const lModel: LModel = LModel.fromD(dModel);\r\n        project.metamodels = [...project.metamodels, lModel];\r\n        project.graphs = [...project.graphs, lModel.node as LGraph];\r\n        const dPackage = lModel.addChild('package');\r\n        const lPackage: LPackage = LPackage.fromD(dPackage);\r\n        lPackage.name = 'default';\r\n        const tab = TabDataMaker.metamodel(dModel);\r\n        await DockManager.open('models', tab);\r\n        setClicked('');\r\n    }\r\n\r\n    return(<div className={'popup-container'}>\r\n        <div className={'popup'}>\r\n            <div className={'close-container'}>\r\n                <i onClick={e => setClicked('')} className={'bi bi-x-lg text-danger close'} />\r\n            </div>\r\n            <section className={'px-3'}>\r\n                <div className={'input-container'}>\r\n                    <b className={'me-2'}>Name:</b>\r\n                    <input className={'input'} onChange={e => setName(e.target.value)} />\r\n                </div>\r\n                <button onClick={createM2} disabled={!name} className={'btn btn-success d-block w-100 mt-3'}>\r\n                        Create\r\n                </button>\r\n            </section>\r\n        </div>\r\n    </div>);\r\n}\r\n\r\nexport {MetamodelPopup};\r\n","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\components\\dock\\MyDock.tsx",["1792","1793","1794","1795","1796","1797","1798","1799","1800","1801","1802","1803","1804"],"import JqxDockingLayout, {IDockingLayoutProps} from \"jqwidgets-scripts/jqwidgets-react-tsx/jqxdockinglayout\";\r\nimport React, {PureComponent, ReactElement, ReactNode} from \"react\";\r\nimport ReactDOM from \"react-dom\";\r\n/*import \"./jqx.base.css\"\r\nimport \"./jqx.darkblue.css\"*/\r\nimport \"./jqx.custom-styling.scss\"\r\nimport \"./smartdock.custom-styling.scss\"\r\nimport 'jqwidgets-scripts/jqwidgets/styles/jqx.base.css';\r\nimport 'jqwidgets-scripts/jqwidgets/styles/jqx.material-purple.css';\r\nimport $ from \"jquery\";\r\nimport {Dictionary, DocString, GObject, Log} from \"../../joiner\";\r\nimport { DockingLayout } from 'smart-webcomponents-react/dockinglayout';\r\n\r\nimport {DockLayout, LayoutData} from 'rc-dock';\r\nimport { Slider } from 'smart-webcomponents-react/slider';\r\nimport { MultilineTextBox } from 'smart-webcomponents-react/multilinetextbox';\r\nclass PortalOwnProps{\r\n    children!: ReactNode;\r\n    container!: string | Element;\r\n}\r\n\r\nexport class MyPortal extends React.Component<PortalOwnProps> {\r\n    container: Element | null = null;\r\n    maxRetries: number = 10;\r\n    retries: number = 0;\r\n\r\n    constructor(props: PortalOwnProps) {\r\n        super(props);\r\n    }\r\n\r\n    render() {\r\n        if (!this.container) {\r\n            if (!this.props.container) return <div>Error: Portal container is {this.props.container}</div>;\r\n            if (typeof this.props.container === 'object') this.container = this.props.container; else\r\n            if (typeof this.props.container === 'string') this.container = document.querySelector(this.props.container);\r\n        }\r\n        if (!this.container) {\r\n            if (this.retries++ < this.maxRetries) this.forceUpdate();\r\n            console.log('MyPortal retry getting container', {thiss: this, props: this.props});\r\n            return this.props.children;\r\n        }\r\n        this.retries = 0;\r\n        return ReactDOM.createPortal(this.props.children, this.container);\r\n    }\r\n}\r\nconst defaultLayout = [{\r\n    type: 'LayoutGroup',\r\n    orientation: 'horizontal',\r\n    items: [{\r\n        type: 'LayoutGroup',\r\n        items: [{\r\n            type: 'LayoutPanel',\r\n            id: 'tabPanel',\r\n            label: 'Input',\r\n            items: [{\r\n                id: 'tab1',\r\n                label: 'first TextBox Tab',\r\n                content: '<div class=\"tab-root\" idata-d=\"do not use those content at all. the whole content is lost when you save state\"><div>firstcontainer content</div></div>'\r\n            },\r\n                {\r\n                    id: 'tabslider',\r\n                    label: 'Slider Tab',\r\n                    content: '<div style=\"padding:10px;\" id=\"secondContainer\"></div>'\r\n                }\r\n            ]\r\n        },\r\n            {\r\n                type: 'LayoutPanel',\r\n                label: 'Output',\r\n                items: [{\r\n                    id: 'outputTab',\r\n                    label: 'Output',\r\n                    headerPosition: 'none',\r\n                    content: 'Write more text here ...'\r\n                }]\r\n            }\r\n        ],\r\n        orientation: 'vertical'\r\n    },\r\n        {\r\n            id: 'item0',\r\n            label: 'Tabs 0',\r\n            items: [{\r\n                id: 'tab A',\r\n                label: 'Tab A',\r\n                selected: true,\r\n                content: 'What is Lorem Ipsum?\\n' +\r\n                    'Lorem Ipsum is simply dummy text of the printing and typesetting industry. Lorem Ipsum has been the industry\\'s standard dummy text ever since the 1500s, when an unknown printer took a galley of' + 'type and scrambled it to make a type specimen book. It has survived not only five centuries, but also the leap into electronic typesetting, remaining essentially unchanged. It was popularised in ' + 'the 1960s with the release of Letraset sheets containing Lorem Ipsum passages, and more recently with desktop publishing software like Aldus PageMaker including versions of Lorem Ipsum.\\n' +\r\n                    'Why do we use it?\\n' +\r\n                    'It is a long established fact that a reader will be distracted by the readable content of a page when looking at its layout. The point of using Lorem Ipsum is that it has a more-or-less normal ' + 'distribution of letters, as opposed to using \\'Content here, content here\\', making it look like readable English. Many desktop publishing packages and web page editors now use Lorem Ipsum as their' + 'default model text, and a search for \\'lorem ipsum\\' will uncover many web sites still in their infancy. Various versions have evolved over the years, sometimes by accident, sometimes on ' + 'purpose (injected humour and the like).'\r\n            }]\r\n        }\r\n    ]\r\n}];\r\n\r\nexport class SmartDock extends React.Component {\r\n    public layout: GObject;\r\n    constructor(props: any) {\r\n        super(props);\r\n        let layoutstr = localStorage.getItem('smartDockingLayoutdocking-smart-1');\r\n        let layout: GObject | null = layoutstr ? JSON.parse(layoutstr) : null;\r\n        if (!layout) {\r\n            layout = defaultLayout;\r\n        }\r\n        this.layout = layout;\r\n    }\r\n\r\n    private html: HTMLElement | null = null;\r\n    private dock: DockingLayout | null = null;\r\n    // componentDidMount() { this.afterUpdate(); }\r\n    dockReady() { this.afterUpdate(); }\r\n    componentDidUpdate(prevProps: Readonly<{}>, prevState: Readonly<{}>, snapshot?: any) { this.afterUpdate(); }\r\n\r\n    saveHtmlMap: Dictionary<DocString<'id'>, NodeListOf<ChildNode>> = {}\r\n    beforeUpdate(){\r\n        if (!this.html) return;\r\n        let $tabs = $(this.html).find('smart-tab-item.smart-element.smart-tab-item');\r\n        let tab: HTMLElement;\r\n        for (tab of $tabs){\r\n            if (!tab.id) { Log.eDevv('tabs must have id\\'s', {tab}); }\r\n            this.saveHtmlMap[tab.id] = tab.childNodes;\r\n        }\r\n    }\r\n    afterUpdate(){\r\n        if ((this.dock as any).items.length === 0) {\r\n            this.layout = defaultLayout;\r\n            this.forceUpdate();\r\n            // dock failed to load from localStorage, i'm forcing rerender.\r\n        }\r\n        (window as any).debugAfterUpdate = () => {\r\n            this.forceUpdate();\r\n        }\r\n        if (window) return; // weirdly it works also without this?\r\n        // ReactDOM.render(<MultilineTextBox />, document.querySelector(\"#firstContainer\"));\r\n        //ReactDOM.render(<Slider />, document.querySelector(\"#secondContainer\"));\r\n        if (!this.html) return;\r\n        // let $html = $(this.html);\r\n        let id: string;\r\n        for (id in this.saveHtmlMap){\r\n            let elem = document.getElementById(id);\r\n            if (!elem) { continue; }\r\n            for (let c of this.saveHtmlMap[id]) {\r\n                elem.append(c);\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    render() {\r\n        const random = Math.random();\r\n        let layout: GObject = this.layout;\r\n        let r = (random * 255).toFixed(0);\r\n        this.beforeUpdate();\r\n        return (\r\n            <div onMouseEnter={() => this.forceUpdate()} ref={e => this.html = e}>\r\n                <h1>{r}</h1>\r\n                <DockingLayout id={'docking-smart-1'} autoSaveState={true} autoLoadState={true}\r\n                               ref={(e)=> {\r\n                                   this.dock = e;\r\n                                   if (!this.dock) return;\r\n                                   // this.dock.loadState(layout);\r\n                               }}\r\n                               style={{backgroundColor: `rgb(${r}, ${r}, ${r})`}}\r\n                    onReady={() => this.dockReady()} layout={layout} draggable={true}>\r\n                </DockingLayout>\r\n                <MyPortal container={'#tab1'}>\r\n                    <div id={'tab1content'}>tab1 content!</div>\r\n                </MyPortal>\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\n/*\r\nhow to do custom pinned tabs:\r\n\r\nto show preview after is pinned:\r\nkeep a fake tab in a sidebar outside rc-dock. keep the rc-dock tab hidden in floating mode but anchored to the side of the pin.\r\nwhen hover on a sidebar title, set display: block on the hovering tab.\r\n\r\nto unpin: set display: block on the hovering tab and remove the sidebar fake tab\r\nto pin: set tab on float mode, position it near the pin fake sidebar, make a fake sidebar entry, then hide the float tab\r\n\r\nbonus: add pin buttons at the 4 edges near the current position of the 4\r\n .jqx-docking-layout-overlay-square.jqx-docking-layout-overlay-square-edge\r\n\r\n*/\r\nexport class JQDock extends React.PureComponent<{}, IDockingLayoutProps> {\r\n    constructor(props: {}) {\r\n        super(props);\r\n        const layout: IDockingLayoutProps['layout'] = [\r\n            {\r\n                items: [{\r\n                    alignment: 'left',\r\n                    items: [{\r\n                        contentContainer: 'ToolboxPanel',\r\n                        title: 'toolbox', //<b color={\"red\"}>Toolbox red</b>,\r\n                        type: 'layoutPanel'\r\n                    }, {\r\n                        contentContainer: 'HelpPanel',\r\n                        title: 'Help',\r\n                        type: 'layoutPanel'\r\n                    }],\r\n                    type: 'autoHideGroup',\r\n                    unpinnedWidth: 200,\r\n                    width: 80\r\n                },\r\n                    {\r\n                        items: [{\r\n                            height: 400,\r\n                            items: [{\r\n                                contentContainer: 'Document1Panel',\r\n                                title: 'Document 1',\r\n                                type: 'documentPanel',\r\n                            },\r\n                                {\r\n                                    contentContainer: 'Document2Panel',\r\n                                    title: 'Document 2',\r\n                                    type: 'documentPanel'\r\n                                }],\r\n                            minHeight: 200,\r\n                            type: 'documentGroup'\r\n                        },\r\n                            {\r\n                                height: 200,\r\n                                items: [{\r\n                                    contentContainer: 'ErrorListPanel',\r\n                                    title: 'Error List',\r\n                                    type: 'layoutPanel'\r\n                                }],\r\n                                pinnedHeight: 30,\r\n                                type: 'tabbedGroup'\r\n                            }],\r\n                        orientation: 'vertical',\r\n                        type: 'layoutGroup',\r\n                        width: 500\r\n                    },\r\n                    {\r\n                        items: [\r\n                            {\r\n                                contentContainer: 'SolutionExplorerPanel',\r\n                                initContent: () => {\r\n                                    // initialize a jqxTree inside the Solution Explorer Panel\r\n                                    const source = [{\r\n                                        expanded: true,\r\n                                        icon: './../images/earth.png',\r\n                                        items: [\r\n                                            {\r\n                                                expanded: true,\r\n                                                icon: './../images/folder.png',\r\n                                                items: [{\r\n                                                    icon: './../images/nav1.png',\r\n                                                    label: 'jqx.base.css'\r\n                                                },\r\n                                                    {\r\n                                                        icon: './../images/nav1.png',\r\n                                                        label: 'jqx.energyblue.css'\r\n                                                    }, {\r\n                                                        icon: './../images/nav1.png',\r\n                                                        label: 'jqx.orange.css'\r\n                                                    }],\r\n                                                label: 'css'\r\n                                            },\r\n                                            {\r\n                                                icon: './../images/folder.png',\r\n                                                items: [{\r\n                                                    icon: './../images/nav1.png',\r\n                                                    label: 'jqxcore.js'\r\n                                                },\r\n                                                    {\r\n                                                        icon: './../images/nav1.png',\r\n                                                        label: 'jqxdata.js'\r\n                                                    }, {\r\n                                                        icon: './../images/nav1.png',\r\n                                                        label: 'jqxgrid.js'\r\n                                                    }],\r\n                                                label: 'scripts',\r\n                                            },\r\n                                            {\r\n                                                icon: './../images/nav1.png',\r\n                                                label: 'index.htm'\r\n                                            }],\r\n                                        label: 'Project',\r\n                                    }];\r\n                                    ReactDOM.render(<div>tree?</div>, document.querySelector('#treeContainer'));\r\n                                },\r\n                                title: 'Solution Explorer',\r\n                                type: 'layoutPanel'\r\n                            },\r\n                            {\r\n                                contentContainer: 'PropertiesPanel',\r\n                                title: 'Properties',\r\n                                type: 'layoutPanel'\r\n                            }],\r\n                        minWidth: 200,\r\n                        type: 'tabbedGroup',\r\n                        width: 220\r\n                    }],\r\n                orientation: 'horizontal',\r\n                type: 'layoutGroup'\r\n            },\r\n            {\r\n                height: 300,\r\n                items: [{\r\n                    contentContainer: 'OutputPanel',\r\n                    selected: true,\r\n                    title: 'Output',\r\n                    type: 'layoutPanel'\r\n                }],\r\n                position: {\r\n                    x: 350,\r\n                    y: 250\r\n                },\r\n                type: 'floatGroup',\r\n                width: 500\r\n            }\r\n        ];\r\n        this.state = {\r\n            layout\r\n        }\r\n    }\r\n    public html: Element | null = null;\r\n    callbackReference(e: HTMLElement | null) {\r\n        this.html = e;\r\n        if (!e) return;\r\n        $(e).on('float', function (event: JQuery.Event & GObject) {\r\n            var floatedItem = event.args.item;\r\n            const $allfloats = $('.jqx-docking-layout-group-floating');\r\n            console.log(\"something is afloat\", {event, args:event.args, floatedItem, e, $allfloats});\r\n            // @ts-ignore\r\n            e.prepend(...($allfloats as any));\r\n\r\n        });\r\n    }\r\n    public render() {\r\n        return (\r\n            <div id={\"dock-roottt\"}  ref={(e)=> this.callbackReference(e)}>\r\n            <JqxDockingLayout width={500} height={300} layout={this.state.layout}>\r\n                {/* The panel content divs can have a flat structure */}\r\n                {/* autoHideGroup */}\r\n                <div data-container={'ToolboxPanel'}>\r\n                    List of tools\r\n                </div>\r\n                <div data-container={'HelpPanel'}>\r\n                    Help topics\r\n                </div>\r\n                {/* documentGroup */}\r\n                <div data-container={'Document1Panel'}>\r\n                    Document 1 content\r\n                </div>\r\n                <div data-container={'Document2Panel'}>\r\n                    Document 2 content\r\n                </div>\r\n                {/* bottom tabbedGroup */}\r\n                <div data-container={'ErrorListPanel'}>\r\n                    List of errors\r\n                </div>\r\n                {/* right tabbedGroup */}\r\n                <div data-container={'SolutionExplorerPanel'}>\r\n                    <div id=\"treeContainer\" style={{ border: 'none', width: '99%', height: '100%' }} />\r\n                </div>\r\n                <div data-container={'PropertiesPanel'}>\r\n                    List of properties\r\n                </div>\r\n                {/* floatGroup */}\r\n                <div data-container={'OutputPanel'}>\r\n                    <div style={{ fontFamily: 'Inter Tight' }}>\r\n                        <p>\r\n                            Themes installation complete.\r\n                        </p>\r\n                        <p>\r\n                            List of installed stylesheet files. Include at least one stylesheet Theme file and\r\n                            the images folder:\r\n                        </p>\r\n                        <ul>\r\n                            <li>\r\n                                styles/jqx.base.css: Stylesheet for the base Theme. The jqx.base.css file should\r\n                                be always included in your project.\r\n                            </li>\r\n                            <li>styles/jqx.arctic.css: Stylesheet for the Arctic Theme</li>\r\n                            <li>styles/jqx.web.css: Stylesheet for the Web Theme</li>\r\n                            <li>styles/jqx.bootstrap.css: Stylesheet for the Bootstrap Theme</li>\r\n                            <li>styles/jqx.classic.css: Stylesheet for the Classic Theme</li>\r\n                            <li>styles/jqx.darkblue.css: Stylesheet for the DarkBlue Theme</li>\r\n                            <li>styles/jqx.energyblue.css: Stylesheet for the EnergyBlue Theme</li>\r\n                            <li>styles/jqx.shinyblack.css: Stylesheet for the ShinyBlack Theme</li>\r\n                            <li>styles/jqx.office.css: Stylesheet for the Office Theme</li>\r\n                            <li>styles/jqx.metro.css: Stylesheet for the Metro Theme</li>\r\n                            <li>styles/jqx.metrodark.css: Stylesheet for the Metro Dark Theme</li>\r\n                            <li>styles/jqx.orange.css: Stylesheet for the Orange Theme</li>\r\n                            <li>styles/jqx.summer.css: Stylesheet for the Summer Theme</li>\r\n                            <li>styles/jqx.black.css: Stylesheet for the Black Theme</li>\r\n                            <li>styles/jqx.fresh.css: Stylesheet for the Fresh Theme</li>\r\n                            <li>styles/jqx.highcontrast.css: Stylesheet for the HighContrast Theme</li>\r\n                            <li>styles/jqx.blackberry.css: Stylesheet for the Blackberry Theme</li>\r\n                            <li>styles/jqx.android.css: Stylesheet for the Android Theme</li>\r\n                            <li>styles/jqx.mobile.css: Stylesheet for the Mobile Theme</li>\r\n                            <li>styles/jqx.windowsphone.css: Stylesheet for the Windows Phone Theme</li>\r\n                            <li>styles/jqx.ui-darkness.css: Stylesheet for the UI Darkness Theme</li>\r\n                            <li>styles/jqx.ui-lightness.css: Stylesheet for the UI Lightness Theme</li>\r\n                            <li>styles/jqx.ui-le-frog.css: Stylesheet for the UI Le Frog Theme</li>\r\n                            <li>styles/jqx.ui-overcast.css: Stylesheet for the UI Overcast Theme</li>\r\n                            <li>styles/jqx.ui-redmond.css: Stylesheet for the UI Redmond Theme</li>\r\n                            <li>styles/jqx.ui-smoothness.css: Stylesheet for the UI Smoothness Theme</li>\r\n                            <li>styles/jqx.ui-start.css: Stylesheet for the UI Start Theme</li>\r\n                            <li>styles/jqx.ui-sunny.css: Stylesheet for the UI Sunny Theme</li>\r\n                            <li>styles/images: contains images referenced in the stylesheet files</li>\r\n                        </ul>\r\n                    </div>\r\n                </div>\r\n            </JqxDockingLayout>\r\n            </div>\r\n        );\r\n    }\r\n}\r\nexport const MyDock = JQDock;\r\n// export class MyDock extends JQDock{}\r\n\r\n\r\n/*\r\n// @ts-ignore\r\nexport function MyDock(...a:any) {\r\n// @ts-ignore\r\n    return <igc-dockmanager id=\"dockManager\" onClick={()=>new IgcDockManager()}>\r\n        <div slot=\"content1\" className=\"dockManagerContent\">Content 1</div>\r\n        <div slot=\"content2\" className=\"dockManagerContent\">Content 2</div>\r\n        <div slot=\"content3\" className=\"dockManagerContent\">Content 3</div>\r\n        <div slot=\"content4\" className=\"dockManagerContent\">Content 4</div>\r\n        <div slot=\"content5\" className=\"dockManagerContent\">Content 5</div>\r\n        <div slot=\"content6\" className=\"dockManagerContent\">Content 6</div>\r\n        <div slot=\"content7\" className=\"dockManagerContent\">Content 7</div>\r\n        <div slot=\"content8\" className=\"dockManagerContent\">Content 8</div>\r\n        <div slot=\"content9\" className=\"dockManagerContent\">Content 9</div>\r\n        <div slot=\"content10\" className=\"dockManagerContent\">Content 10</div>\r\n        <div slot=\"content11\" className=\"dockManagerContent\">Content 11</div>\r\n        <div slot=\"content12\" className=\"dockManagerContent\">Content 12</div>\r\n        {/* @ts-ignore * /}\r\n    </igc-dockmanager>\r\n\r\n\r\n//    return <IgcDockManager {...a}></IgcDockManager>;\r\n}\r\n*/\r\n","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\components\\toolbar\\ToolBar.tsx",["1805","1806","1807","1808","1809","1810","1811","1812","1813","1814","1815","1816","1817","1818","1819","1820","1821","1822","1823"],"import React, {Dispatch, ReactElement, ReactNode, useEffect, useRef, useState} from \"react\";\r\nimport {connect} from \"react-redux\";\r\nimport \"./toolbar.scss\";\r\nimport {\r\n    DState,\r\n    DGraphElement,\r\n    Dictionary,\r\n    DModel,\r\n    DModelElement,\r\n    DNamedElement,\r\n    DObject,\r\n    DocString,\r\n    DPointerTargetable,\r\n    DViewElement,\r\n    LGraphElement,\r\n    LModel,\r\n    LModelElement,\r\n    LObject,\r\n    LValue,\r\n    LViewElement,\r\n    MyProxyHandler,\r\n    Pointer,\r\n    SetFieldAction,\r\n    RuntimeAccessibleClass,\r\n    DVoidEdge,\r\n    DEdge,\r\n    DEdgePoint,\r\n    EdgeSegment,\r\n    LVoidEdge,\r\n    Constructors,\r\n    WVoidEdge,\r\n    Log,\r\n    LEdgePoint, DUser,\r\n    U, LPointerTargetable, SetRootFieldAction, GObject, EMeasurableEvents, TRANSACTION\r\n} from \"../../joiner\";\r\n\r\nimport {InitialVertexSizeObj} from \"../../joiner/types\";\r\nimport ModellingIcon from \"../forEndUser/ModellingIcon\";\r\n\r\ninterface ThisState {}\r\n\r\nlet ti = 0; // tabindex counter\r\n\r\nfunction toolbarClick(item_dname: string, data: LModelElement|undefined, myDictValidator: Dictionary<DocString<\"DClassName\">, DocString<\"hisChildren\">[]>, node?:LGraphElement) {\r\n    switch(item_dname){\r\n        case DVoidEdge.cname:\r\n        case DEdge.cname:\r\n            // no add edges through toolbar for now\r\n            break;\r\n        case DEdgePoint.cname:\r\n            let ledge: LVoidEdge = (node as LEdgePoint | LVoidEdge).edge;\r\n            let dedge: DVoidEdge = ledge.__raw;\r\n            let wedge: WVoidEdge = ledge as any;\r\n            // if (!myDictValidator[item_dname]) return;\r\n            let longestSeg: EdgeSegment = undefined as any; // just because compiler does not know it is always found through the for loop\r\n            let longestIndex: number = 0;\r\n            let segms = ledge.segments.segments;\r\n            // longestIndex = segms.length - 1;// i just put it at end because this edgepoint\r\n            for (; longestIndex < segms.length; longestIndex++) if (segms[longestIndex].isLongest) { longestSeg = segms[longestIndex]; break;}\r\n            // let index = edge.segments.all.findIndex((s: EdgeSegment) => s.isLongest);\r\n            let newmp: InitialVertexSizeObj = {...(longestSeg.start.pt.add(longestSeg.end.pt, true).divide(2)), w: 15, h: 15, index:longestIndex};\r\n            // @ts-ignore\r\n            newmp.x -= newmp.w/2; newmp.y -= newmp.h/2;\r\n\r\n            newmp.id = Constructors.makeID();\r\n            let subelements = [...dedge.subElements];\r\n            let prevNodeid = longestSeg.start.ge.id;\r\n            let prevnodeindex = subelements.indexOf(prevNodeid);\r\n            if (prevnodeindex === -1) {\r\n                if (prevNodeid === dedge.start) prevnodeindex = 0; // first and last are not subelements\r\n                else if (prevNodeid === dedge.end) prevnodeindex = subelements.length;\r\n                else Log.exDevv(\"edgepoint insert position not found\", {subelements, prevNodeid, longestSeg, dedge, ledge});\r\n            } else prevnodeindex += 1;\r\n            newmp.index = prevnodeindex;\r\n            // delete (newmp as any).id;\r\n            let mp = [...dedge.midPoints];\r\n            mp.splice(longestIndex, 0, newmp);\r\n            wedge.midPoints = mp;\r\n            let olddebug = [...subelements];\r\n            subelements.splice(prevnodeindex, 0, newmp.id as string);\r\n            console.log(\"injecting ep\", {prevnodeindex, newmp, prevNodeid, longestSeg, old: olddebug, new: subelements, ledge, dedge});\r\n            break;\r\n        default:\r\n            if (!data || !myDictValidator) return;\r\n            let item = item_dname.substring(1).toLowerCase();\r\n            let d = data.addChild(item);\r\n            try {\r\n                let d2 = (d as any)();\r\n                if (myDictValidator[item_dname]) select(d2);\r\n            } catch(e) {\r\n                if (myDictValidator[item_dname]) select(d);\r\n            }\r\n            break;\r\n    }\r\n}\r\nlet n_agonSides = 10; //this shuld be in react.setState(), but the function handling it is outside a component, so i don't wanna rewrite it.\r\n// it should be fine, except for the input value being shared on different sidebar components, which might even be better.\r\nfunction getItems(data: LModelElement|undefined, myDictValidator: Dictionary<DocString<\"DClassName\">, DocString<\"hisChildren\">[]>, items: DocString<\"D-ClassNames\">[], node?:LGraphElement): ReactNode[] {\r\n    const reactNodes: ReactNode[] = [];\r\n    // todo: does myDictValidator have any reason to exist? if something is invalid it should not make it on toolbar jsx generated list\r\n    for (let item_dname of items) {\r\n        if (item_dname[0]==\"_\") {\r\n            item_dname = item_dname.substring(2);\r\n            data = data?.father || data;\r\n        }\r\n        let item = item_dname.substring(1).toLowerCase();\r\n        reactNodes.push(<div className={'toolbar-item'} tabIndex={ti} style={{cursor:\"pointer\"}} key={item_dname} onClick={()=>toolbarClick(item_dname, data, myDictValidator, node)}>\r\n            <ModellingIcon name={item} />\r\n            <span className={'ms-1 my-auto text-capitalize'}>{item}</span>\r\n            {/*\r\n            <i className=\"bi bi-arrow-right-short hoverable\">\r\n                <ul className={\"content\"}>\r\n                    <li className={\"hoverable\"}>\r\n                        <span className={'ms-1 my-auto text-capitalize'}>Polygon</span>\r\n                        <i className=\"bi bi-arrow-right-short hoverable\">\r\n                            <ul className={\"content\"}>\r\n                                <span className={'ms-1 my-auto text-capitalize'}>Triangle</span>\r\n                                <span className={'ms-1 my-auto text-capitalize'}>Pentagon</span>\r\n                                <span className={'ms-1 my-auto text-capitalize'}>Hexagon</span>\r\n                                <span className={'ms-1 my-auto text-capitalize'}>Octagon</span>\r\n                                <span className={'ms-1 my-auto text-capitalize'}>\r\n                                    <input className={\"autosize-input\"} type={\"number\"} min={3} step={1}\r\n                                           value={n_agonSides} onClick{(evt) => { evt.stopPropagation()}}\r\n                                        onChange={(evt) => {\r\n                                            n_agonSides = +evt.target.value || 10;\r\n                                            if (n_agonSides<3) n_agonSides = 10;\r\n                                        }}\r\n                                    />-agon</span>\r\n                            </ul>\r\n                        </i>\r\n                    </li>\r\n                </ul>\r\n            </i>\r\n            <i className=\"bi bi-arrow-right-short hoverable\">\r\n                <ul className={\"content\"}>\r\n                    <li className={\"hoverable\"}>\r\n                        <span className={'ms-1 my-auto text-capitalize'}>Polygon</span>\r\n                    </li>\r\n                </ul>\r\n            </i>\r\n                */\r\n            }\r\n\r\n        </div>);\r\n    }\r\n    return reactNodes;\r\n}\r\nfunction select(dl: DModelElement | LModelElement): DModelElement {\r\n    let d: DModelElement = (dl as LModelElement)?.__raw || dl as DModelElement;\r\n    //console.log(\"selecting\", {d, dl, selector:\".Graph [data-dataid='\"+d?.id+\"']\", $ : $(\".Graph [data-dataid='\"+d?.id+\"']\")});\r\n    if (d && d.id) setTimeout(()=>$(\".Graph [data-dataid='\"+d?.id+\"']\").trigger(\"click\"), 10);\r\n    return d; }\r\n\r\nfunction selectNode(d: DGraphElement|{id: string}): any {\r\n    if (d && d.id) setTimeout(()=>$(\".Graph [data-nodeid='\"+d?.id+\"']\").trigger(\"click\"), 10);\r\n    return d; }\r\n\r\nfunction useClickOutside(ref: any, onClickOutside: any) {\r\n    useEffect(() => {\r\n        \r\n        function handleClickOutside(event: Event) {\r\n            if (ref.current && !ref.current.contains(event.target)) {\r\n                onClickOutside();\r\n            }\r\n        }\r\n\r\n        // Bind\r\n        document.addEventListener(\"mousedown\", handleClickOutside);\r\n        return () => {\r\n        // dispose\r\n        document.removeEventListener(\"mousedown\", handleClickOutside);\r\n        };\r\n    }, [ref, onClickOutside]);\r\n}\r\n\r\nfunction ToolBarComponent(props: AllProps, state: ThisState) {\r\n    \r\n    const node = props.node;\r\n    let [pinned, setPinned] = useState(true);\r\n    let [collapsed, setCollapsed] = useState(true);\r\n    let [position, setPosition] = useState([20,50]); \r\n\r\n    const menuRef = useRef();\r\n\r\n    useClickOutside(menuRef, () => {\r\n        setCollapsed(true);\r\n    });\r\n\r\n    const minimize = (ref: any) => {\r\n        ref.current.style.opacity = 0;\r\n\r\n        // ref.current.style.visibility = 'hidden';\r\n        // ref.current.style.display = 'none'; \r\n        setCollapsed(true);\r\n    }\r\n    const maximize = (ref: any) => {\r\n        ref.current.style.opacity = 1;\r\n        setCollapsed(false);\r\n    }\r\n\r\n    const htmlref: React.MutableRefObject<null | HTMLDivElement>= useRef(null);\r\n    useEffect(() => {\r\n        if (!htmlref.current) return;\r\n        let draggableOptions = {\r\n            cursor: 'grabbing',\r\n            axis: \"y\",\r\n            opacity: 0.0,\r\n            distance: 5,\r\n            containment: 'parent',\r\n            // helper: 'clone'\r\n        };\r\n        ($(htmlref.current) as GObject<'JQuery + ui plugin'>).draggable(draggableOptions);\r\n    }, [htmlref.current]);\r\n\r\n    if (!node) return null;\r\n    const data: LModelElement|LModel = (node.model) ? node.model : LModel.fromPointer(props.model);\r\n\r\n    const isMetamodel: boolean = props.isMetamodel;\r\n    const metamodel: LModel|undefined = props.metamodel;\r\n    const downward: Dictionary<DocString<\"DClassName\">, DocString<\"hisChildren\">[]> = {}\r\n    const addChildren = (items: string[]) => items ? getItems(data, downward, [...new Set(items)], node) : [];\r\n\r\n    // downward[\"DModel\"] = [\"DPackage\"];\r\n    // downward[\"DModel\"] = [\"DPackage\"];\r\n\r\n    downward[\"DPackage\"] = [\"DPackage\", \"DClass\", \"DEnumerator\"];\r\n    downward[\"DClass\"] = [\"DAttribute\", \"DReference\", \"DOperation\"];\r\n    downward[\"DEnumerator\"] = [\"DLiteral\"];\r\n    downward[\"DOperation\"] = [\"DParameter\", \"DException\"];\r\n\r\n\r\n    // nodes\r\n    downward[\"DEdge\"] = [\"DEdgePoint\"]\r\n    downward[\"DVoidEdge\"] = [\"DEdgePoint\"]\r\n\r\n    // for (let parentKey in downward) myDictValidator.set(parentKey, addChildren(\"package\"));\r\n\r\n    let upward: Dictionary<DocString<\"DClassName (model)\">, DocString<\"hisDParents\">[]> = {};\r\n    for (let parentKey in downward){\r\n        let vals = downward[parentKey];\r\n        if(!vals) continue;\r\n        for (let child of vals) {\r\n            if (!upward[child]) upward[child] = [];\r\n            upward[child].push(parentKey)\r\n            upward[child].push(...(downward[parentKey]||[]));\r\n        }\r\n    }\r\n    downward[\"DModel\"] = downward[\"DPackage\"];\r\n\r\n    // exceptions:\r\n    upward[\"DPackage\"] = [\"_pDPackage\"]; //, \"DModel\"]; because from a package, i don't want to prompt the user to create a model in toolbar.\r\n    upward[\"DEdgePoint\"] = [\"DEdgePoint\"]; //, \"DEdge\", \"DVoidEdge\"]; because from a edgeNode, i don't want to prompt the user to create a edge in toolbar.\r\n    // upward[\"DClass\"] = [\"_pDPackage\", \"DClass\", \"DEnumerator\"];\r\n\r\n    let content: ReactNode;\r\n    // if (RuntimeAccessibleClass.extends(props.selected?.node?.className, DVoidEdge)) { }\r\n    let contentarr: ReactNode[][] = [];\r\n    if (isMetamodel) {\r\n        let siblings = data ? addChildren(upward[data.className]) : [];\r\n        if (node) siblings.push(...addChildren(upward[node.className]));\r\n        let subelements = data ? addChildren(downward[data.className]) : [];\r\n\r\n\r\n        if (siblings.length > 0)    { contentarr.push([<span className={'toolbar-section-label'}>Structure</span>, <hr className={'my-1'} />, siblings]); }\r\n        if (subelements.length > 0) { contentarr.push([<span className={'toolbar-section-label'}>Features</span>, <hr className={'my-1'} />, subelements]); }\r\n\r\n    }\r\n    else {\r\n        const classes = metamodel?.classes;\r\n        const model: LModel = LModel.fromPointer(props.model);\r\n        const lobj: LObject | undefined = data.className === \"DObject\" ? data as LObject : undefined;\r\n        const lfeat: LValue | undefined = data.className === \"DValue\" ? data as LValue : undefined;\r\n\r\n        let subleveloptions = [];\r\n        if (lobj && (!lobj.instanceof || lobj.partial)) subleveloptions.push(\r\n            <div key={\"Feature\"} className={\"toolbar-item feature\"} tabIndex={ti} onClick={() => { lobj.addValue(); }}>+Feature</div>\r\n        );\r\n        if (lfeat && lfeat.values.length < lfeat.upperBound) subleveloptions.push(\r\n            <div key={\"Value\"} className={\"toolbar-item value\"} tabIndex={ti} onClick={() => {SetFieldAction.new(lfeat.id, 'value' as any, undefined, '+=', false); alert(280);}}>\r\n                <ModellingIcon name={'value'} />\r\n                <span className={'ms-1 my-auto text-capitalize'}>value</span>\r\n            </div>\r\n        );\r\n        if (node) subleveloptions.push(...addChildren(downward[node.className]));\r\n        let rootobjs = classes?.filter((lClass) => lClass.rootable).map((lClass, index) => {\r\n            let dclass = lClass.__raw;\r\n            return <><div\r\n                onMouseEnter={e => SetRootFieldAction.new('tooltip', lClass.annotations.map(a => a.source).join(' '))}\r\n                onMouseLeave={e => SetRootFieldAction.new('tooltip', '')}\r\n                key={\"LObject_\"+dclass.id} className={\"toolbar-item LObject\"} tabIndex={ti} onClick={()=> select(model.addObject({}, lClass)) }>\r\n                {dclass._state.icon ? <ModellingIcon src={dclass._state.icon}/> : <ModellingIcon name={'object'} />}\r\n                <span className={'ms-1 my-auto text-capitalize'}>{U.stringMiddleCut(dclass.name, 14)}</span>\r\n            </div></>\r\n        }) || [];\r\n\r\n        rootobjs.push(<><hr className={'my-1 toolbar-hr'}/><div key={\"RawObject\"} className={'toolbar-item'} tabIndex={ti} onClick={()=> select(model.addObject({}, null)) }>\r\n            \r\n            <ModellingIcon name={'object'} />\r\n        \r\n            <span className={'ms-1 my-auto text-capitalize'}>Object</span>\r\n        </div></>);\r\n\r\n\r\n        if (rootobjs.length > 0) {\r\n            contentarr.push([<b className={'toolbar-section-label'} style={{marginRight:\"1.5em\"/*to avoid overlap with pin*/}}>Root level</b>, rootobjs]);\r\n        }\r\n        if (subleveloptions.length > 0) {\r\n            contentarr.push([<b className={'toolbar-section-label'}>Sublevel</b>, subleveloptions]);\r\n        }\r\n    }\r\n\r\n\r\n    let shapes = node ? addChildren(downward[node.className]) : [];\r\n    if (shapes.length > 0) {\r\n        contentarr.push([<b className={'toolbar-section-label'}>Shape</b>, shapes]);\r\n    }\r\n\r\n    let separator = <hr className={'my-1'} /> as any;\r\n    // @ts-ignore\r\n    content = contentarr.separator(separator);// .flat() as any;\r\n\r\n    return (<>\r\n    \r\n        <div className=\"toolbar-draggable\"\r\n            ref={htmlref}\r\n            style={{ border: 'none', top: '35px', position: \"absolute\", backgroundColor: 'red !important' }} // refuses to focus without event...\r\n            onClick={(e) => {\r\n                console.log(\"click focus\", { htmlref }); setTimeout(() => {\r\n                    if (htmlref.current) (htmlref.current as any).children[0].focus();\r\n                }, 1)\r\n            }}>\r\n            <div className={\"toolbar hoverable\" + (pinned ? \" pinned\" : '')} tabIndex={0}>\r\n                <i style={{marginTop: '8px'}} className={\"content pin bi bi-x-lg\"} onClick={() => minimize(htmlref)} />\r\n                <div className={\"content inline w-100\"}>\r\n                    {content}\r\n                </div>\r\n            </div>\r\n        </div>\r\n        \r\n        {collapsed ? \r\n            <div className=\"toolbar-collapsed\" onClick={() => maximize(htmlref)}></div>\r\n            :\r\n            <div className=\"toolbar-collapsed\" onClick={() => minimize(htmlref)}></div>\r\n        }\r\n    </>);\r\n}\r\n\r\ninterface OwnProps {\r\n    model: Pointer<DModel, 1, 1, LModel>;\r\n    isMetamodel: boolean;\r\n    metamodelId?: Pointer<DModelElement, 1, 1, LModelElement>;\r\n}\r\n\r\ninterface StateProps {\r\n    node: LGraphElement|null;\r\n    metamodel?: LModel;\r\n}\r\ninterface DispatchProps {}\r\ntype AllProps = OwnProps & StateProps & DispatchProps;\r\n\r\n//* 23/11 versione giordano\r\nfunction mapStateToProps(state: DState, ownProps: OwnProps): StateProps {\r\n    const ret: StateProps = {} as any;\r\n    const nodeid = state._lastSelected?.node;\r\n    if (nodeid) ret.node = LGraphElement.fromPointer(nodeid);\r\n    else ret.node = null;\r\n    if (ownProps.metamodelId) { ret.metamodel = LModel.fromPointer(ownProps.metamodelId); }\r\n    return ret;\r\n}\r\n\r\nfunction mapDispatchToProps(dispatch: Dispatch<any>): DispatchProps {\r\n    const ret: DispatchProps = {} as any;\r\n    return ret;\r\n}\r\n\r\n\r\nexport const ToolBarConnected = connect<StateProps, DispatchProps, OwnProps, DState>(\r\n    mapStateToProps,\r\n    mapDispatchToProps\r\n)(ToolBarComponent);\r\n\r\nexport const ToolBar = (props: OwnProps, children: (string | React.Component)[] = []): ReactElement => {\r\n    return <ToolBarConnected {...{...props, children}} />;\r\n}\r\nexport default ToolBar;\r\n\r\n\r\n\r\n\r\n","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\components\\editors\\Skeleton.tsx",["1824"],"import type {FakeStateProps} from '../../joiner/types';\r\nimport {DState, LModelElement,} from '../../joiner';\r\nimport React, {Component, Dispatch, ReactElement, ReactNode} from 'react';\r\nimport {connect} from 'react-redux';\r\nimport './editors.scss';\r\nimport './skeleton.scss';\r\nimport Tree from \"../forEndUser/Tree\";\r\nimport {Empty} from \"./Empty\";\r\n\r\nfunction SkeletonComponent(props: AllProps) {\r\n    const {data} = props;\r\n\r\n    if(!data) return(<Empty />);\r\n    else return(<section className={'tree-view'}>\r\n        <Tree data={data} />\r\n    </section>)\r\n\r\n}\r\n\r\ninterface OwnProps {}\r\ninterface StateProps {\r\n    data?: LModelElement\r\n}\r\ninterface DispatchProps {}\r\n\r\ntype AllProps = OwnProps & StateProps & DispatchProps;\r\n\r\nfunction mapStateToProps(state: DState, ownProps: OwnProps): StateProps {\r\n    const ret: StateProps = {} as FakeStateProps;\r\n    const dataID = state._lastSelected?.modelElement;\r\n    if(dataID) ret.data = LModelElement.fromPointer(dataID);\r\n    return ret;\r\n}\r\n\r\nfunction mapDispatchToProps(dispatch: Dispatch<any>): DispatchProps {\r\n    const ret: DispatchProps = {} as any;\r\n    return ret;\r\n}\r\n\r\n\r\nexport const SkeletonConnected = connect<StateProps, DispatchProps, OwnProps, DState>(\r\n    mapStateToProps,\r\n    mapDispatchToProps\r\n)(SkeletonComponent);\r\n\r\nexport const Skeleton = (props: OwnProps, children: (string | Component)[] = []): ReactElement => {\r\n    return <SkeletonConnected {...{...props, children}} />;\r\n}\r\nexport default Skeleton;\r\n","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\model\\logicWrapper\\index.ts",[],"C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\components\\editors\\views\\NestedView.tsx",["1825","1826","1827","1828","1829","1830"],"/* Viewpoints */\r\n\r\nimport React, {Dispatch, ReactElement, useState} from 'react';\r\nimport {connect} from 'react-redux';\r\nimport {\r\n    DPointerTargetable,\r\n    DState,\r\n    DUser,\r\n    DViewElement,\r\n    DViewPoint,\r\n    Input,\r\n    LPointerTargetable,\r\n    LProject,\r\n    LUser,\r\n    LViewElement,\r\n    LViewPoint,\r\n    Pointer,\r\n    TRANSACTION,\r\n    U,\r\n    windoww\r\n} from '../../../joiner';\r\nimport {useStateIfMounted} from 'use-state-if-mounted';\r\nimport {Dictionary, FakeStateProps} from '../../../joiner/types';\r\nimport {GenericTree} from \"../../forEndUser/Tree\";\r\nimport \"./nestedView.scss\"\r\nimport {ViewData} from './ViewData';\r\nimport {Tooltip} from \"../../forEndUser/Tooltip\";\r\nimport {Btn, CommandBar, Sep} from '../../commandbar/CommandBar';\r\nimport {InternalToggle} from '../../widgets/Widgets';\r\n\r\ntype Metadata = {setView: (p: Pointer)=>any, scoreBoost: number}\r\nfunction NestedViewComponent(props: AllProps) {\r\n    const project = props.project;\r\n    const viewpoints = props.viewpoints;\r\n    const active = props.active;\r\n\r\n    const editName = (evt: React.ChangeEvent<HTMLInputElement>, vp: LViewElement) => { vp.name = evt.target.value; }\r\n    const addVP = () => {\r\n        let name = 'viewpoint_' + 0;\r\n        let viewpointNames: string[] = viewpoints.map(vp => vp && vp.name);\r\n        name = U.increaseEndingNumber(name, false, false, newName => viewpointNames.indexOf(newName) >= 0);\r\n        DViewPoint.newVP(name);\r\n    }\r\n    const deleteV = (e: React.MouseEvent, viewPoint: LViewElement) => {\r\n        e.stopPropagation();\r\n        TRANSACTION('delete ' + viewPoint.name, ()=>{\r\n            // viewPoint.subViews.map(v => v.delete());\r\n            viewPoint.delete();\r\n            // SetFieldAction.new(project.id, 'viewpoints', viewPoint.id as any, '-=', false);\r\n        });\r\n    }\r\n    const deleteVP = (e: React.MouseEvent, viewPoint: LViewPoint) => {\r\n        e.stopPropagation();\r\n        TRANSACTION('delete viewpoint '+viewPoint.name, ()=>{\r\n            // viewPoint.subViews.map(v => v.delete());\r\n            viewPoint.delete();\r\n            // SetFieldAction.new(project.id, 'viewpoints', viewPoint.id as any, '-=', false);\r\n        });\r\n    }\r\n\r\n\r\n    // function mapStateToProps(state: DState, ownProps: OwnProps): StateProps {\r\n    //     const ret: StateProps = {} as FakeStateProps;\r\n    //     // const user = LUser.fromPointer(DUser.current, state);\r\n    //     // ret.project = user.project as LProject;\r\n    //     ret.priority = LPointerTargetable.fromArr(ownProps.priority); // ret.project.viewpoints;\r\n    //     ret.debug = state.debug;\r\n    //     ret.view = LPointerTargetable.fromPointer(ownProps.viewid, state);\r\n    //     return ret;\r\n    // }\r\n\r\n    const getSubElements = (v: DViewElement) => v?.subViews || {}; //\r\n    let activeViewpointId: Pointer<DPointerTargetable> = project.activeViewpoint.id;\r\n\r\n    let [collapseAll, setCollapseAll] = useState<boolean | undefined>( undefined );\r\n\r\n    function renderEntry(e: DViewElement, childrens: Dictionary<Pointer, number>, isExpanded: boolean, toggleExpansion: ()=>any, depth: number, path: number[], metadata: Metadata): JSX.Element{\r\n        let d = e;\r\n        let appliableTo: string;\r\n\r\n        if (collapseAll !== undefined && collapseAll === isExpanded) toggleExpansion();\r\n        let expandClick = () => {\r\n            setCollapseAll(undefined);\r\n            toggleExpansion();\r\n        }\r\n\r\n        if (d.appliableToClasses.length === 1) appliableTo = d.appliableToClasses[0].substring(1);\r\n        else if (d.appliableToClasses.length === 0) appliableTo = d.appliableTo;\r\n        else appliableTo = \"Any\";\r\n        appliableTo = U.replaceAll(appliableTo, \"Void\", \"\");\r\n        let parr = Object.keys(childrens);\r\n        let scoreBoost = metadata?.scoreBoost || 0;\r\n        let l: LViewElement = LPointerTargetable.fromD(d);\r\n\r\n        const preventClick = (e: any)=>e.stopPropagation();\r\n        let isVP = d.className === DViewPoint.cname;\r\n        let isDefault = d.id.indexOf('Pointer_View') === 0;\r\n\r\n        function select(ptr: Pointer<DViewPoint>){ project.activeViewpoint = ptr as any; }\r\n\r\n        let appliableToEnhanced = (d.name === 'Singleton' ? 'Singleton' : appliableTo);\r\n\r\n        let isActive = d.id === activeViewpointId;\r\n        let canDelete = !isActive && !isDefault;\r\n        return <li className={\"entry-root \" + d.className + (isActive ? ' selected' : '')} key={d.id}>\r\n\r\n            <div className={'inline-row'} onClick={()=>setView(d.id)} onDoubleClick={(e) => {select(d.id)}}> {/* activate anche con il dblclick */}\r\n\r\n                <div className={\"left-stuff vertical-centering \"} onClick={preventClick}>\r\n                    {parr.length >= 1 ?\r\n                        <>\r\n                            <i style={{fontSize: '0.55em', marginRight: '24px!important'}} className={'bi cursor-pointer d-block my-auto bi-chevron-' + (isExpanded ? 'down' : 'right')} onClick={expandClick} />\r\n                            {isExpanded && <div className={\"expansion-line\"} />}\r\n                        </>\r\n                        :\r\n                        <></>\r\n                    }\r\n                </div>\r\n                <div className={\"mid-stuff vertical-centering\"} style={{marginLeft: '8px'}}>\r\n                    <div className={`icon type tree-${appliableToEnhanced} ${d.className}`} style={{width: '24px', height: '24px'}}>{\r\n                        isVP ? 'VP' : (appliableToEnhanced === \"Any\" ? \"✲\" : appliableToEnhanced[0])\r\n                    }</div>\r\n                    <div style={{marginLeft: '4px'}}>{d.name}</div>\r\n                </div>\r\n                <div className={\"hover-stuff vertical-centering d-flex \"}>\r\n                    <div className={\"ms-auto d-flex\"} onClick={preventClick}>\r\n                        {isVP &&\r\n                            <CommandBar style={{transition: '1s 0.3s', marginTop: '2px'}}>\r\n                                <Btn icon={'check'} action={() => {select(d.id)}} tip={'Activate'}/>\r\n                            </CommandBar>\r\n\r\n                            /* <button className=\"bg btn-delete my-auto ms-2 green\" disabled={active.id === d.id}\r\n                                onClick={(evt) => {select(d.id)}}>\r\n                                <i className='bi bi-check2' />\r\n                            </button>*/\r\n                        }\r\n\r\n\r\n                        <CommandBar style={{transition: '1s 0.3s', marginTop: '2px'}}>\r\n                            <Btn icon={'delete'} action={(e)=> { l.delete(); preventClick(e);}} disabled={!canDelete} tip={\r\n                                isActive ? 'Cannot delete active viewpoint' : (isDefault ? 'Cannot delete default views' : 'Delete' )} />\r\n                            <Tooltip tooltip={'Duplicate'} inline={true} position={'top'} offsetY={10} >\r\n                                <i onClick={(e)=> { l.duplicate(); preventClick(e); }} className={'bx bx-copy'}/>\r\n                            </Tooltip>\r\n                            <Tooltip tooltip={'Deep duplication'} inline={true} position={'top'} offsetY={10} >\r\n                                <i onClick={(e)=> { l.duplicate(true); preventClick(e); }} className={'bx bx-duplicate'}/>\r\n                            </Tooltip>\r\n                        </CommandBar>\r\n\r\n                        {/* <button className=\"bg btn-delete my-auto ms-2 green\" onClick={(e)=> { l.duplicate(); preventClick(e);}}><i className='bx bx-duplicate' /></button>\r\n                        <button className=\"bg btn-delete my-auto ms-2\" onClick={(e)=> { l.delete(); preventClick(e);}}><i className=\"p-1 bi bi-dash\" /></button>*/}\r\n                    </div>\r\n                </div>\r\n                <div className={\"right-stuff vertical-centering\"}>\r\n                    <div className={\"right-content\"} onClick={preventClick} >\r\n                        {\r\n                            isVP ? <>\r\n                                <div className={\"spacer\"}/>\r\n                            </> : <>{ props.isAdvanced && <>\r\n                                <span className={\"priority\"}>priority: {l.explicitApplicationPriority} </span><i style={{paddingTop: '4px'}} className=\"bi bi-x\"></i>\r\n                                <div className={\"spacer\"}/>\r\n                                <Input type=\"number\"\r\n                                       className={\"change-boost hidden-input priority-booster\"}\r\n                                       inputClassName={\"change-boost hidden-input\"}\r\n                                       readonly={false}\r\n                                       data={l}\r\n                                       getter={()=>scoreBoost + ''}\r\n                                       setter={(v)=>{l.subViews = {...childrens, [d.id]: +v} as any}}\r\n                                />\r\n                            </>}\r\n                                <span className={\"right-icon feature-border ocl-icon vertical-centering \" + (d.oclCondition.length ? \"\" : \"hidden\")}></span>\r\n                                <span className={\"right-icon feature-border js-icon vertical-centering \" + (d.jsCondition.length ? \"\" : \"hidden\")}></span>\r\n                            </>\r\n                        }\r\n                        <Tooltip tooltip={<div>is {d.isExclusiveView ? \"\" : \"not\"} mutually exclusive with other \"Ex\" views.</div>} position={\"bottom\"} inline={true}>\r\n                            <span className={\"right-icon feature-border ex-icon vertical-centering \" + (d.isExclusiveView ? '' : \"hidden\")}\r\n                                  onClick={()=>l.isExclusiveView = !d.isExclusiveView}\r\n                            /></Tooltip>\r\n                    </div>\r\n                </div>\r\n            </div>\r\n\r\n            <ul>{isExpanded && parr.map( (ptr, i) => (\r\n                <GenericTree key={ptr}\r\n                             data={DPointerTargetable.from(ptr)}\r\n                             getSubElements={getSubElements}\r\n                             renderEntry={renderEntry}\r\n                             depth={depth + 1} path={[...path, i]}\r\n                             metadata={{setView:metadata.setView, scoreBoost:childrens[ptr]} as Metadata}\r\n                             initialHidingState={depth < 100}\r\n                    // metadata={{...metadata, depth: metadata.depth + 1, path:[...metadata.path, i], scoreBoost: }}\r\n                />))}</ul>\r\n        </li>;\r\n    }\r\n\r\n\r\n    let [view, setView] = useStateIfMounted(undefined as (undefined | Pointer<DViewElement>));\r\n    let vieweditor = view && <div className={\"single-view-content\"}><ViewData key={view} viewid={view} viewpoints={viewpoints.map(v=>v.id)} setSelectedView={setView} /></div>;\r\n    return(<div className={\"view-editor-root\"}>\r\n        <section className={'viewpoint-tab'}>\r\n            <div className={\"view-editor-fullsize-content\"}>\r\n                <div className={'d-flexd-flex'}>\r\n                    <h1>Viewpoints\r\n\r\n\r\n                        <CommandBar style={{float: 'right'}}>\r\n                            <Btn icon={'shrink'} active={collapseAll}         action={() => {setCollapseAll(true)}}  tip={'Collapse all'} />\r\n                            <Btn icon={'expand'} active={collapseAll===false} action={() => {setCollapseAll(false)}} tip={'Expand all'}   />\r\n                            <Sep />\r\n                            <Btn icon={'add'} action={addVP} tip={'Create a new viewpoint'} />\r\n                        </CommandBar>\r\n\r\n                    </h1>\r\n                </div>\r\n                {vieweditor}\r\n                <ul className={\"ps-2 pt-2\"}>\r\n                    {viewpoints.map(vp=><GenericTree\r\n                        data={vp.__raw}\r\n                        getSubElements={getSubElements}\r\n                        renderEntry={renderEntry}\r\n                        metadata={{setView, scoreBoost:0}}\r\n                        initialHidingState={vp.id === activeViewpointId} />)}\r\n                </ul>\r\n            </div>\r\n        </section>\r\n    </div>);\r\n\r\n}\r\ninterface OwnProps {\r\n}\r\ninterface StateProps {\r\n    project: LProject;\r\n    viewpoints: LViewPoint[];\r\n    active: LViewPoint;\r\n    isAdvanced: boolean;\r\n}\r\ninterface DispatchProps { }\r\ntype AllProps = OwnProps & StateProps & DispatchProps;\r\n\r\n\r\nfunction mapStateToProps(state: DState, ownProps: OwnProps): StateProps {\r\n    const ret: StateProps = {} as FakeStateProps;\r\n    const user: LUser = LUser.fromPointer(DUser.current, state);\r\n    ret.project = user.project as LProject;\r\n    ret.viewpoints = ret.project.viewpoints.filter( (vp) => !!vp/* && vp.isValidation === ownProps.validation*/);\r\n    ret.active = ret.project.activeViewpoint;\r\n    ret.isAdvanced = state.advanced;\r\n    return ret;\r\n}\r\n\r\nfunction mapDispatchToProps(dispatch: Dispatch<any>): DispatchProps {\r\n    const ret: DispatchProps = {};\r\n    return ret;\r\n}\r\n\r\n\r\nexport const NestedViewConnected = connect<StateProps, DispatchProps, OwnProps, DState>(\r\n    mapStateToProps,\r\n    mapDispatchToProps\r\n)(NestedViewComponent);\r\n\r\nexport const NestedView = (props: OwnProps, children: (string | React.Component)[] = []): ReactElement => {\r\n    return <NestedViewConnected {...{...props, children}} />;\r\n}\r\n","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\components\\editors\\Console.tsx",["1831","1832","1833","1834","1835","1836","1837","1838","1839"],"import {\r\n    DEdge,\r\n    DGraphElement,\r\n    Dictionary,\r\n    DState,\r\n    GObject, Info,\r\n    LGraphElement,\r\n    LModelElement,\r\n    Log,\r\n    LPointerTargetable,\r\n    LViewElement,\r\n    Pointer,\r\n    RuntimeAccessibleClass,\r\n    transientProperties,\r\n    U,\r\n    windoww\r\n} from '../../joiner';\r\nimport {FakeStateProps} from '../../joiner/types';\r\nimport React, {Component, Dispatch, PureComponent, ReactElement, ReactNode} from 'react';\r\nimport {connect} from 'react-redux';\r\n\r\nimport './style.scss'; // <-- tenuto per retro-compatibilità ma dovrebbe sparire\r\nimport './editors.scss'; // <-- stile comune a tutte le tab editor (idealmente da tenere leggero)\r\nimport './console.scss'; // <-- stile di questa tab\r\nimport ReactDOM from \"react-dom\";\r\nimport {Empty} from \"./Empty\";\r\nimport {Tooltip} from \"../forEndUser/Tooltip\";\r\n\r\nconst Convert = require('ansi-to-html');\r\n\r\nlet ansiConvert = (window as any).ansiConvert;\r\nif (!ansiConvert) (window as any).ansiconvert = ansiConvert = new Convert();\r\n\r\nclass ThisState{\r\n    expression: string = '';\r\n    output: any = null;\r\n    expressionIndex: number = 0;\r\n    expressionHistory: string[] = [''];\r\n    initialState: boolean = true;\r\n    time: number = 0;\r\n}\r\n\r\n// trasformato in class component così puoi usare il this nella console. e non usa accidentalmente window come contesto\r\n\r\nlet hiddenkeys = [\"jsxString\", \"pointedBy\", \"clonedCounter\", \"parent\", \"_subMaps\", \"inspect\", \"__random\", '__serialize'];\r\nfunction fixproxy(output: any/*but not array*/, addDKeys: boolean = true, addLKeys: boolean = true):\r\n    { output: any, shortcuts?: GObject<'L singleton'>, comments?: Dictionary<string, string | {type:string, txt:string}>, hiddenkeys?: GObject} {\r\n\r\n    let ret: ReturnType<typeof fixproxy> = {output};\r\n    if (!output) return ret;\r\n\r\n    let proxy: LPointerTargetable | undefined;\r\n    if (output?.__isProxy) {\r\n        proxy = output;\r\n        output = output.__raw; //Object.fromEntries(Object.getOwnPropertyNames(p).map(k => [k, p[k]]));\r\n    } else proxy = undefined;\r\n\r\n    console.log('console short in 1', {output, proxy, ret, addLKeys, iff:addLKeys && proxy});\r\n\r\n    switch (typeof output) {\r\n        case \"function\": {\r\n            let fdata =  U.buildFunctionDocumentation(output);\r\n            return {output: fdata};\r\n        }\r\n        default: return ret;\r\n        case \"object\":\r\n            // if (Array.isArray(output)) { ret.output = output; break; /* no need to go inside, it is already done at render phase */ }\r\n            ret.output = output = {...output};\r\n            // if (ret.output.anchors) ret.output.anchors = JSON.stringify(ret.output.anchors);\r\n            if (addLKeys && proxy) {\r\n                let Lsingleton: GObject<'L singleton'> = (RuntimeAccessibleClass.get(output?.className)?.logic?.singleton) || {};\r\n                let comments: Dictionary<string, string | {type:string, txt:string}> = {};\r\n                ret.shortcuts = {...Lsingleton};\r\n                console.log('console short in 2', {output, rett:{...ret, shortt:{...(ret.shortcuts||{})}}, Lsingleton, DClass:RuntimeAccessibleClass.get(output?.className), LClass:RuntimeAccessibleClass.get(output?.className)?.logic});\r\n                ret.comments = comments;\r\n                for (let key in output) {\r\n                    if (Lsingleton[\"__info_of__\" + key]) comments[key] = Lsingleton[\"__info_of__\" + key];\r\n                }\r\n                for (let key in Lsingleton) {\r\n                    if ((key in output) || (key.indexOf(\"__info_of__\") === 0)) {\r\n                        delete ret.shortcuts[key];\r\n                        continue;\r\n                    } else { if (ret.shortcuts[key] === undefined) ret.shortcuts[key] = ''; }\r\n                    if (key.indexOf(\"info\") >=0 && key.indexOf(\"of\") >=0){\r\n                        Log.eDevv('Possible error on __info_of__ misnamed as '+key+', if the name was intentional' +\r\n                            ' and not an Info object add an allowal rule here.');\r\n                        continue;\r\n                    }\r\n                    if (Lsingleton[\"__info_of__\" + key]) comments[key] = Lsingleton[\"__info_of__\" + key];\r\n                    if (comments[key]) continue; // if explicitly commented, i will not attempt to generate documentation.\r\n                    let entryvalue = Lsingleton[key];\r\n                    switch (typeof entryvalue) {\r\n                        default:\r\n                        case \"object\":\r\n                            ret.shortcuts[key] = entryvalue;\r\n                            break;\r\n                        case \"function\":\r\n                            ret.shortcuts[key] = U.buildFunctionDocumentation(entryvalue);\r\n                            break;\r\n                    }\r\n                }\r\n                console.log('console short in 3', {ret});\r\n\r\n            }\r\n            if (hiddenkeys) {\r\n                ret.hiddenkeys = {};\r\n                for (let key of hiddenkeys) {\r\n                    ret.hiddenkeys[key] = output[key];\r\n                    delete output[key];\r\n                    if (ret.shortcuts) delete ret.shortcuts[key];\r\n                }\r\n            }\r\n            break;\r\n    }\r\n\r\n    //@ts-ignore\r\n    //ret ={...ret, shortcuts: undefined, comments: undefined, hiddenkeys: undefined};\r\n\r\n    return ret;\r\n}\r\n\r\n\r\nclass ConsoleComponent extends PureComponent<AllProps, ThisState>{\r\n    public static cname: string = \"ConsoleComponent\";\r\n    lastNode?: Pointer<DGraphElement>;\r\n    constructor(props: AllProps) {\r\n        super(props);\r\n        this.state = new ThisState();\r\n        this.change = this.change.bind(this);\r\n        this.change(undefined);\r\n    }\r\n    private _context: GObject = {};\r\n    change(evt?: React.ChangeEvent<HTMLTextAreaElement>) {\r\n        if (!this) return; // component being destroyed and remade after code hot update\r\n        let expression0: string = (evt ? evt.target.value : this.state.expression) || '';\r\n        let expression: string = expression0.trim();\r\n        let output;\r\n        // let context = {...this.props, props: this.props}; // makeEvalContext(this.props as any, {} as any);\r\n\r\n        let nid = this.props.node?.id;\r\n        let tn = transientProperties.node[nid as string];\r\n        if (nid && tn) {\r\n            // let component = GraphElementComponent.map[this.props.node.id];\r\n            this._context = {...tn.viewScores[tn.mainView.id].evalContext};\r\n            this._context.fromcomponent = true;\r\n        }\r\n        else {\r\n            this._context = {...this.props, props: this.props};\r\n        }\r\n        try {\r\n            // if (expression === 'this') expression = 'data'; // it does a mess by taking a L-singleton with all his __info_of__ stuff\r\n            if (expression === 'this') output = this._context;\r\n            else output = U.evalInContextAndScope(expression || '<span class=\"console-msg\">undefined</span>', this._context, this._context);\r\n        }\r\n        catch (e: any) {\r\n            console.error(\"console error\", e);\r\n            // output = '<span class=\"console-error\">Invalid Syntax!</span> <span class=\"console-error-msg\">' + e.toString() + '<span>' ; }\r\n            output = '<span class=\"console-error-msg\"><i class=\"bi bi-exclamation-square-fill\"></i><span>' + e.toString() + '</span></span>' ; }\r\n        this.setState({expression:expression0, output });\r\n    }\r\n\r\n    // textarea: HTMLTextAreaElement | null = null;\r\n    getClickableEntry(jsxComments: Dictionary<string, ReactNode>, strcomments: Dictionary<string, Info>, expression: string, k: string, arr?: any): JSX.Element{\r\n        let isReactNode = !!jsxComments[k];\r\n        let infoof_tooltip: string | ReactNode;\r\n        if (isReactNode){\r\n            infoof_tooltip = <span id={'console_output_comment_key_' + k} className='my-tooltip output-comment tooltip-msg'/>;//jsxComments[k];\r\n        } else {\r\n            let str = (strcomments[k]?.txt as string)||'';\r\n            if (str) infoof_tooltip = <div className=\"my-tooltip output-comment\" dangerouslySetInnerHTML={{__html:str}}/>;\r\n            else infoof_tooltip = null;\r\n        }\r\n        if (k === 'father') console.log('jsx comment', {k, infoof_tooltip, jsxComments:{...jsxComments}});\r\n        if (k === 'isM1') console.log('jsx comment', {k, infoof_tooltip, jsxComments:{...jsxComments}});\r\n        return <li onClick={()=> {\r\n            let isnum = !isNaN(+k);\r\n            let isregular: boolean = isnum ? true : /\\w/.test(k);\r\n            let append: string;\r\n            if (isnum) append = '['+k+']';\r\n            else if (isregular) append = '.'+k;\r\n            else append = '['+JSON.stringify(k)+']';\r\n            this.setState({expression: (expression ? expression + append : k)}/*, ()=> { this.change(); }*/);\r\n        }}>{k}{arr && arr[k] || null}{infoof_tooltip}</li>;\r\n    }\r\n\r\n    outputhtml: HTMLElement | null = null;\r\n    setState(s: GObject<Partial<ThisState>> | null, callback?: (...a:any) => any): void{\r\n        if (s){\r\n            if (s.initialState) {\r\n                delete s.initialState;\r\n                return super.setState(s as any);\r\n            }\r\n            let s0: GObject<ThisState> = {...s} as any;\r\n            let olds = this.state;\r\n            if (s0.expressionIndex !== undefined && s0.expressionIndex !== olds.expressionIndex) s.expression = olds.expressionHistory[s0.expressionIndex];\r\n            if (s0.expression && s0.expression !== olds.expression) {\r\n                let time = new Date().getTime();\r\n                let oldtime = olds.time;\r\n                Log.exDev(s0.expressionIndex !== undefined, 'cannot set both index and expression together');\r\n                let i = s.expressionIndex ?? olds.expressionIndex;\r\n                let slice: string[];\r\n                if (time - oldtime < 1000) {\r\n                    slice = olds.expressionHistory.slice(0, i);\r\n                }\r\n                else {\r\n                    slice = olds.expressionHistory.slice(0, i+1);\r\n                    s.expressionIndex = i + 1;\r\n                }\r\n                s.time = time;\r\n                s.expressionHistory = [...slice, s0.expression];\r\n                console.log('setstate', {olds: {...olds}, s, slice, i, s0});\r\n            }\r\n            if (s.expression !== olds.expression && !('output' in s)) {\r\n                let call0 = callback;\r\n                callback = () => { call0?.(); this.change(); }\r\n            }\r\n        }\r\n        super.setState(s as any, callback);\r\n    }\r\n    render(){\r\n        /*const [expression, setExpression] = useStateIfMounted('data');\r\n        const [output, setOutput] = useStateIfMounted('');*/\r\n\r\n        if (!this.props.node) return <Empty msg={\"Select a node.\"} />;\r\n        let postprocess: boolean = true;\r\n        let expression = this.state.expression.trim();\r\n        if (expression === 'this') expression = 'data';\r\n        const data = this.props.data;\r\n        if (this.lastNode !== this.props.node.id) this.change(); // force reevaluation if selected node changed\r\n        this.lastNode = this.props.node.id;\r\n\r\n        /*display history*/\r\n        let history = this.state.expressionHistory||[];\r\n        let hlen = history.length;\r\n        let hindex = this.state.expressionIndex;\r\n        const entries = 10;\r\n        let max = Math.floor(Math.min(hindex+entries/2, hlen));\r\n        let min = Math.floor(hindex + entries - Math.max((hlen-max), entries/2));\r\n        history = history.slice(min, max);\r\n        console.log('chistory', {min, max, oldh: this.state.expressionHistory, h: history, selected: history[entries/2]});\r\n\r\n\r\n        let outstr;\r\n        // try { outstr = U.circularStringify(this.state.output, (key, value)=> { return value.__isProxy ? value.name : value; }, \"\\t\", 1) }\r\n        // (window as any).inspect = util.inspect;\r\n        // (window as any).tmpp = this.state.output;\r\n        let ashtml: boolean\r\n        let output: any = this.state.output;\r\n        let shortcuts: GObject<'L singleton'> | undefined = undefined;\r\n        let comments: Dictionary<string, string | {type:string, txt:string}> | undefined = undefined;\r\n        let hidden: Dictionary<string, string> | undefined = undefined;\r\n        let jsxComments: Dictionary<string, JSX.Element[]> = {};\r\n        let shortcutsjsx: ReactNode = undefined;\r\n        try {\r\n            if (Array.isArray(output)){\r\n                comments = {\"separator\": '<span>Similar to <a href={\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/join\"}>Array.join(separator)</a>' +\r\n                        ', but supports array of JSX nodes and JSX as separator argument.</span>'};\r\n                shortcuts = {\"separator\": \"\"};\r\n                output = output.map(o => fixproxy(o).output);\r\n            }\r\n            else {\r\n                console.log('console short pre', {output});\r\n                let ret = fixproxy(output);\r\n                output = ret.output;\r\n                comments = ret.comments;\r\n                shortcuts = ret.shortcuts;\r\n                console.log('console short', {shortcuts, ret, output});\r\n                hidden = ret.hiddenkeys;\r\n            }\r\n            // todo: as i fix the displaying of a LViewElement without replacing it with __raw,\r\n            //  i will fix window, component and props displaying too i think they crash for props.data, props.view...\r\n            if (output?._reactInternals) {\r\n                output = {\"React.Component\": {props:\"...navigate to expand...\", state:\"\", _isMounted:output._isMounted}}\r\n            }\r\n            outstr = '<h4>Result</h4><section class=\"group result-container\"><div class=\"output-row\" tabindex=\"984\">' + U.objectInspect(output)+\"<span>\";\r\n            let commentsPopup = \"\";\r\n            if (shortcuts || comments){\r\n                // if(!shortcuts) shortcuts = {};\r\n                if (!comments) comments = {};\r\n                for (let commentKey in comments){\r\n                    let commentVal: any = comments[commentKey];\r\n                    let txt = commentVal?.txt;\r\n                    if (txt && typeof txt !== \"string\") {// only for infoof that have txt = reactNode\r\n                        // try to inject jsx\r\n                        jsxComments[commentKey] = txt;\r\n                        txt = \"<span id='console_output_comment_\" + commentKey + \"'  class='tooltip-msg'/>\";\r\n                        // fallback read text, that should go deep iteration, but 1 level deep should be enough.\r\n                        // let arr: any[] = (Array.isArray(txt?.props?.children) ? txt.props.children : (txt.props.children ? [txt.props.children] : []));\r\n                        // txt = arr.map(e => typeof e === \"string\" ? e : e?.props?.children + '' || '').join(\"\");\r\n                    }\r\n                    if (commentVal?.type) commentVal = \"\\t\\t<span class='console-msg'>\" + (commentVal?.type?.cname || commentVal.type)+\"</span>\"; // + \" ~ \" + txt;\r\n                    // warning: unicode char but should not make a problem. 𐀹\r\n                    commentVal += '<div class=\"output-comment my-tooltip\">' + txt + '</div></div><div class=\"output-row\" tabindex=\"984\">'\r\n\r\n                    if (postprocess){\r\n                        let commentKeyEscaped = U.multiReplaceAll(commentKey, [\"$\", \"-\"], [\"\\\\$\", \"\\\\-\"]); // _ should be safe, .-,?^ not happening?\r\n\r\n                        let regexp = new RegExp(\"^({?\\\\s*\" +commentKeyEscaped+\":.*)$\", \"gm\");\r\n                        let regexpCloseTags = new RegExp(\"(\\\\<span style\\\\=\\\"color\\\\:\\\\#)\", \"gm\");\r\n                        outstr = U.replaceAll(outstr, \"$\", \"£\");\r\n                        outstr = outstr.replace(regexp, \"$1\" + commentVal);\r\n                        outstr = outstr.replace(regexpCloseTags,  \"</span>$1\");\r\n                        outstr = U.replaceAll(outstr, \"£\", \"$\");\r\n                    }\r\n                }\r\n\r\n\r\n                /*if (shortcuts) outstr += \"</div></section><br><br>\" +\r\n                    \"<h4>Shortcuts</h4><section class='group shortcuts-container'><div class=\\\"output-row\\\" tabindex=\\\"984\\\">\" + U.objectInspect(shortcuts)+\"</section>\";\r\n                */\r\n\r\n                // if (hidden) outstr +=\"</div><br><br><h4>Other less useful properties</h4><div class=\\\"output-row\\\" tabindex=\\\"984\\\">\" + format(hidden);\r\n                // warning: unicode char but should not make a problem.\r\n                // outstr = U.replaceAll( outstr, '𐀹,\\n', '],</span>\\n</div><div class=\"output-row\" tabindex=\"984\"><span style=\"color:#000\">');\r\n                windoww.outstr = outstr.substring(0, 500);\r\n                windoww.outstrr = outstr;\r\n                // [length]: <span style=\"color:#A50\">1<span style=\"color:#000\"> ]\r\n                if (postprocess){\r\n                    // let closetagsafely = '</span>';\r\n                    let closetagsafely = '</span></span></span></span></span></span></span></span></span></span>';\r\n\r\n                    outstr = U.replaceAll( outstr, '<span style=\"color:#000\">,\\n',\r\n                        closetagsafely+'\\n</div>' + '<div class=\"output-row\" tabindex=\"984\"><span class=\"console-msg\" style=\"color:#000\">');\r\n\r\n                    outstr = U.replaceAll( outstr, '<span style=\"color:#000\"> ],\\n',\r\n                        ']</span>\\n</div>' + '<div class=\"output-row\" tabindex=\"984\"><span class=\"console-msg\" style=\"color:#000\">');\r\n\r\n                    outstr = U.replaceAll( outstr, ': {},\\n',\r\n                        ': {}</span>\\n</div>' + '<div class=\"output-row\" tabindex=\"984\">');\r\n                    // let regexpFixArray = /,?\\s\\[length\\]:\\s<span style=\"color:#A50\">\\d<span style=\"color:#000\">\\s/gm;\r\n                    windoww.outp = outstr;\r\n                    // let regexpFixArray = /,?\\s\\[length\\]:\\s(<\\/span>)+<span style=\"color:#A50\">\\d(<\\/span>)+]/gm;\r\n                    let regexpFixArray = /,?\\s\\[length\\]:\\s(<\\/span>)+<span style=\"color:#A50\">\\d(<\\/span>)+(<span style=\"color:#000\">\\s){0,1}]/gm\r\n                    outstr = outstr.replaceAll(regexpFixArray, \"&nbsp;]</span>\");\r\n                    outstr = U.replaceAll( outstr, ': [&nbsp;]', ': []');\r\n\r\n                }\r\n                let postprocessold: boolean = false;\r\n                if (postprocessold){\r\n                    outstr = U.replaceAll( outstr, '<span style=\"color:#000\" class=\"console-msg\">,\\n',\r\n                        '</span><span style=\"color:#000\" class=\"console-msg\">,</span>\\n</div><div class=\"output-row\" tabindex=\"984\"><span class=\"console-msg\" style=\"color:#000\">');\r\n                    /*outstr = U.replaceAll( outstr, '<span style=\"color:#000\" class=\"console-msg\">,\\n',\r\n                        '</span><span style=\"color:#000\" class=\"console-msg\">,</span>\\n</div><div class=\"output-row\" tabindex=\"984\"><span class=\"console-msg\" style=\"color:#000\">');*/\r\n\r\n                    outstr = U.replaceAll( outstr, '],\\n', '],</span>\\n</div><div class=\"output-row\" tabindex=\"984\"><span class=\"console-msg\" style=\"color:#000\">');\r\n                    outstr = U.replaceAll( outstr, '},\\n', '},</span>\\n</div><div class=\"output-row\" tabindex=\"984\"><span class=\"console-msg\" style=\"color:#000\">');\r\n\r\n                }\r\n            }\r\n            ashtml = true; }\r\n        catch(e: any) {\r\n            console.error(e);\r\n            throw e;\r\n            outstr = \"[circular object]: \" + e.toString();\r\n            ashtml = false;\r\n        }\r\n        let contextkeysarr: (string)[];\r\n        let contextkeys: ReactNode = '';\r\n        if (this.state.expression.trim() === \"this\") contextkeys = \"Warning: \\\"this\\\" in the console is aliased to data instead of the whole context of a GraphElement component.\";\r\n\r\n        let objraw = this.state.output?.__raw || (typeof this.state.output === \"object\" ? this.state.output : \"[primitiveValue]\") || {};\r\n        if (this.state.expression.trim() === \"\") contextkeysarr = [\"data\", \"node\", \"view\", \"component\"];\r\n        else if (typeof objraw === \"string\") { contextkeysarr = Object.keys(String.prototype); }\r\n        else contextkeysarr = (Array.isArray(objraw) ?\r\n                [...(Object.keys(objraw) as any as number[]).filter(k => (k) <= 10).map(k=>k===10 ? '...' : ''+k), ...Object.keys(Array.prototype)]\r\n                : Object.getOwnPropertyNames(objraw)) || [];\r\n\r\n\r\n        let injectCommentJSX = () => {\r\n            try{ for (let key in jsxComments) {\r\n                if (hiddenkeys.includes(key)) continue;\r\n                let commentNode: HTMLElement | null = document.getElementById(\"console_output_comment_\"+key);\r\n                Log.eDev(!commentNode, \"failed to find comment placeholder\", {key, v:jsxComments[key], jsxComments});\r\n                if (commentNode) ReactDOM.render(jsxComments[key], commentNode);\r\n                // for shortcut or context keys, this can fail without warning as some shortcuts are missing\r\n                commentNode = document.getElementById(\"console_output_comment_key_\"+key);\r\n                if (commentNode) ReactDOM.render(jsxComments[key], commentNode);\r\n            } }\r\n            catch (e) { console.error(\"failed to inject console output comment:\", e)}\r\n        }\r\n        setTimeout(injectCommentJSX, 1)\r\n        this.setNativeConsoleVariables();\r\n        windoww.output = output;\r\n        const undo = ()=>{\r\n            let expressionIndex = Math.max(0, this.state.expressionIndex - 1);\r\n            if (expressionIndex === this.state.expressionIndex) return;\r\n            this.setState({ expressionIndex })\r\n        }\r\n        const redo = ()=>{\r\n            const expressionHistory = this.state.expressionHistory;\r\n            let expressionIndex = Math.min(expressionHistory.length-1, this.state.expressionIndex + 1);\r\n            if (expressionIndex === this.state.expressionIndex) return;\r\n            this.setState({ expressionIndex })\r\n        }\r\n        let canredo = this.state.expressionIndex < this.state.expressionHistory.length - 1;\r\n        let canundo = this.state.expressionIndex > 0;\r\n        let advanced = this.props.advanced;\r\n\r\n        contextkeys = <ul>{\r\n            contextkeysarr.sort().map(k=>this.getClickableEntry(jsxComments, comments||{} as any, expression, k))\r\n        }</ul>;\r\n\r\n        if (shortcuts) {\r\n            shortcutsjsx = <ul>{\r\n                Object.keys(shortcuts).sort().map(k=>this.getClickableEntry(jsxComments, comments||{} as any, expression, k, shortcuts))\r\n            }</ul>\r\n        }\r\n\r\n        return(<div className={'w-100 h-100 p-2 console'}>\r\n            <h1>\r\n                On {((data as GObject)?.name || \"model-less node (\" + this.props.node?.className + \")\") + \" - \" + this.props.node?.className}\r\n            </h1>\r\n            <div className='console-terminal p-0 mb-2 w-100'>\r\n                <div className='commands'>\r\n                    <i onClick={(e) => {\r\n                        this.setState({expression: '', expressionHistory:[''], expressionIndex:0})\r\n                    }} title={'Empty console'} className=\"bi bi-slash-circle\"/>\r\n                    <i onClick={(e) => {\r\n                        if (!this.state.expression.trim()) {\r\n                            return Tooltip.show('Nothing to copy', undefined, undefined, 2);\r\n                        }\r\n                        let s = this.outputhtml?.innerText || '';\r\n                        s = s.substring('Result'.length).trim();\r\n                        U.clipboardCopy(s, () => Tooltip.show('Content copied to clipboard', undefined, undefined, 2));\r\n                    }} title={'Copy in the clipboard'} className=\"bi bi-clipboard-plus\"/>\r\n                    {/* @ts-ignore */}\r\n                    <i onClick={redo} title={'redo'}\r\n                       className={\"redo bi bi-arrow-right-square\" + (canredo ? '' : \" disabled\")}/>\r\n                    {/* @ts-ignore */}\r\n                    <i onClick={undo} title={'undo'}\r\n                       className={\"undo bi bi-arrow-left-square\" + (canundo ? '' : \" disabled\")}/>\r\n                </div>\r\n                <textarea id={'console'} spellCheck={false} className={'p-0 input w-100'} onChange={this.change}\r\n                          value={this.state.expression}></textarea>\r\n            </div>\r\n            {advanced && history.length>1 && <div>Advanced query history (index = {this.state.expressionIndex})\r\n                {history.map((s, i) => i === 0 ? null : <>\r\n                    <div style={{\r\n                        border: '1px solid ' + (i === history.length/2) ? 'red' : 'gray',\r\n                        marginTop: '5px',\r\n                        height: '30px'\r\n                    }}>{(i) + ') ' + s}</div>\r\n                </>)}</div>}\r\n            {/*<label>Query {(this.state.expression)}</label>*/}\r\n            <hr className={'mt-1 mb-1'}/>\r\n            {this.state.expression && ashtml && <div className={\"console-output-container console-msg\"}\r\n                                                     ref={(e) => this.outputhtml = e}\r\n                                                     dangerouslySetInnerHTML={ashtml ? {__html: outstr as string} : undefined}/>}\r\n\r\n            {this.state.expression && !ashtml && <div className={\"console-output-container console-msg\"}\r\n                                                      ref={(e) => this.outputhtml = e}\r\n                                                      style={{whiteSpace: \"pre\"}}>{outstr}</div>}\r\n\r\n\r\n            {contextkeysarr.length && <section className={'group suggestion-keys context-keys-list'} style={{whiteSpace: \"pre\"}}>\r\n                    <label className={\"context-keys\"}>Context keys</label>\r\n                    {contextkeys}\r\n                </section>\r\n            }\r\n            {shortcutsjsx && <section className='group  suggestion-keys shortcuts-container'>\r\n                <label className={\"context-keys pt-0\"}>Shortcuts</label>\r\n                {shortcutsjsx}\r\n            </section>}\r\n        </div>)\r\n    }\r\n\r\n    private setNativeConsoleVariables(): void { // just fordebugging\r\n        let context = this._context;\r\n        windoww.context = context;\r\n        windoww.data = context.data;\r\n        windoww.node = context.node;\r\n        windoww.edge = context.edge;\r\n        windoww.output = this.state.output;\r\n        if (context.data?.model) windoww.model = context.data?.model;\r\n    }\r\n}\r\n\r\ninterface OwnProps {}\r\ninterface StateProps {\r\n    data: LModelElement|null;\r\n    node: LGraphElement|null;\r\n    view: LViewElement|null;\r\n    advanced: boolean;\r\n}\r\ninterface DispatchProps {}\r\n\r\ntype AllProps = OwnProps & StateProps & DispatchProps;\r\n\r\nfunction mapStateToProps(state: DState, ownProps: OwnProps): StateProps {\r\n    const ret: StateProps = {} as FakeStateProps;\r\n    const nodeid = state._lastSelected?.node;\r\n    const node: LGraphElement|null = (nodeid) ? LGraphElement.fromPointer(nodeid) : null;\r\n    ret.node = node;\r\n    ret.data = (node?.model) ? node.model : null;\r\n    ret.view = (node?.view) ? node.view : null;\r\n    ret.advanced = state.advanced;\r\n    return ret;\r\n}\r\n\r\nfunction mapDispatchToProps(dispatch: Dispatch<any>): DispatchProps {\r\n    const ret: DispatchProps = {} as any;\r\n    return ret;\r\n}\r\n\r\n\r\nexport const ConsoleConnected = connect<StateProps, DispatchProps, OwnProps, DState>(\r\n    mapStateToProps,\r\n    mapDispatchToProps\r\n)(ConsoleComponent);\r\n\r\nexport const Console = (props: OwnProps, children: (string | Component)[] = []): ReactElement => {\r\n    return <ConsoleConnected {...{...props, children}} />;\r\n}\r\nexport default Console;\r\n","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\components\\editors\\MetaData.tsx",[],"C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\components\\editors\\Info.tsx",["1840","1841","1842","1843","1844","1845"],"import {\r\n    Any,\r\n    DAttribute, DClass, DEnumerator, Dictionary, DModel, DocString, DReference,\r\n    DState,\r\n    Input, LAttribute, LClass, LClassifier, LEnumerator,\r\n    LGraphElement,\r\n    LModel,\r\n    LModelElement,\r\n    LObject, LPointerTargetable, LReference, LStructuralFeature, LValue,\r\n    LViewElement, MultiSelect, Pointer, Pointers,\r\n    Select,\r\n    Selectors, SetFieldAction, store, TRANSACTION, U, ValueDetail\r\n} from '../../joiner';\r\nimport {FakeStateProps} from '../../joiner/types';\r\nimport React, {Component, Dispatch, ReactElement, ReactNode} from 'react';\r\nimport {connect} from 'react-redux';\r\nimport './editors.scss';\r\nimport './info.scss';\r\nimport './style.scss';\r\nimport {Empty} from \"./Empty\";\r\nimport { CommandBar, Btn } from '../commandbar/CommandBar';\r\nimport { Tooltip } from '../forEndUser/Tooltip';\r\n\r\nclass builder {\r\n    static named(data: LModelElement, advanced: boolean): ReactNode {\r\n        return (<><h1>{data.name}</h1>\r\n            <label className={'input-container'}>\r\n                <b className={'me-2'}>Name:</b>\r\n                <Input data={data} field={'name'} type={'text'}/>\r\n            </label>\r\n\r\n            <label className={'input-container'}>\r\n                <b className={'me-2'}>Readonly:</b>\r\n                <Input data={data} field={'__readonly'} type={'checkbox'}/>\r\n            </label>\r\n        </>);\r\n    }\r\n\r\n    static model(data: LModelElement, advanced: boolean): JSX.Element {\r\n        let l = data as LModel;\r\n        let d = l.__raw;\r\n        let multiselectArr = d.dependencies;\r\n        let multiselectValue: {value: string, label: string}[] = [];\r\n        let state = store.getState();\r\n        let validoptionsarr = Selectors.getAll(DModel, undefined, state, true, false) as DModel[];\r\n        let multiselectOptions: {value: string, label: string}[] = validoptionsarr.map(c => {\r\n            let opt = {value:c.id, label: c.name};\r\n            if (opt.value === d.id) return undefined;\r\n            if (!multiselectArr.includes(opt.value)) return opt;\r\n            multiselectValue.push(opt);\r\n            return undefined;\r\n        }).filter(e=>!!e) as {value: string, label: string}[];\r\n        // <Select data={data} isMulti={true} field={'dependencies'}/>\r\n\r\n        return (<section className={'properties-tab'}>\r\n            {this.named(data, advanced)}\r\n\r\n            <label className={'input-container'}>\r\n                <b className={'me-2'}>Dependends from models:</b>\r\n                <MultiSelect isMulti={true} options={multiselectOptions as any} value={multiselectValue} onChange={(v) => {\r\n                    console.log('setting model dependencies', v);\r\n                    l.dependencies = v.map(e => e.value) as Any<string[]>;\r\n                }} />\r\n            </label>\r\n        </section>);\r\n    }\r\n\r\n    static package(data: LModelElement, advanced: boolean): JSX.Element {\r\n        return (<section className={'properties-tab'}>\r\n            <h1>{data.name}</h1>\r\n            {this.named(data, advanced)}\r\n            <label className={'input-container'}>\r\n                <b className={'me-2'}>Uri:</b>\r\n                <Input data={data} field={'uri'} type={'text'}/>\r\n            </label>\r\n            <label className={'input-container'}>\r\n                <b className={'me-2'}>Prefix:</b>\r\n                <Input data={data} field={'prefix'} type={'text'}/>\r\n            </label>\r\n        </section>);\r\n    }\r\n\r\n    static class(data: LModelElement, advanced: boolean): JSX.Element {\r\n        let lclass: LClass = data as any;\r\n        // let extendOptions: {value: string, label: string}[] lclass.extends.map(lsubclass=> ({value: lsubclass.id, label: lsubclass.name}));\r\n        let m2: LModel = lclass.model;\r\n        let pkgs = m2.allSubPackages;\r\n        let dclass = lclass.__raw;\r\n        let extendsarr = dclass.extends;\r\n        let extendValue: {value: string, label: string}[] = [];\r\n        let extendOptions: {label: string, options: {value: string, label: string}[]}[] = pkgs.map(p => (\r\n            {label: p.fullname, options: p.classes.map(c=> {\r\n                let opt = {value:c.id, label: c.name};\r\n                if (opt.value === dclass.id) return undefined;\r\n                if (!extendsarr.includes(opt.value)) return opt;\r\n                extendValue.push(opt);\r\n                return undefined;\r\n            }).filter(e=>!!e) as {value: string, label: string}[]}));\r\n        //let extendOptions = pkgs.map(p => ({label: p.fullname, options: p.classes.map(c=> ({value:c.id as string, label:c.name}))}));\r\n\r\n\r\n        return (<section className={'properties-tab'}>\r\n            {this.named(data, advanced)}\r\n            <label className={'input-container'}>\r\n                <b className={'me-2'}>Abstract:</b>\r\n                <Input data={data} field={'abstract'} type={'checkbox'}/>\r\n            </label>\r\n            <label className={'input-container'}>\r\n                <b className={'me-2'}>Interface:</b>\r\n                <Input data={data} field={'interface'} type={'checkbox'}/>\r\n            </label>\r\n            <label className={'input-container'}>\r\n                <b className={'me-2'}>Extends:</b>\r\n                <MultiSelect isMulti={true} options={extendOptions as any} value={extendValue} onChange={(v) => {\r\n                    console.log('setting extend', v);\r\n                    lclass.extends = v.map(e => e.value) as Any<string[]>;\r\n                }} />\r\n            </label>\r\n            <label className={'input-container'}>\r\n                <b className={'me-2'}>Final:</b>\r\n                <Tooltip tooltip={\"Defines if the class can be extended.\"}>\r\n                    <Input data={data} field={'final'} type={'checkbox'}/>\r\n                </Tooltip>\r\n            </label>\r\n            {false &&\r\n                <label className={'input-container'}>\r\n                    <b className={'me-2'}>Rootable:</b>\r\n                    <Tooltip tooltip={\"Whether the element can be a m1 root (present in toolbar).\"}>\r\n                        <Input data={data} field={'rootable'} type={'checkbox3' }/>\r\n                    </Tooltip>\r\n                </label>}\r\n            <label className={'input-container'}>\r\n                <b className={'me-2'}>Singleton:</b>\r\n                <Tooltip tooltip={'A singleton element is always present exactly 1 time in every model.' +\r\n                    '\\nA single instance is created dynamically and cannot be created by the user.'}>\r\n                    <Input data={data} field={'singleton'} type={'checkbox'}/>\r\n                </Tooltip>\r\n            </label>\r\n            {advanced && <label className={'input-container'}>\r\n                <b className={'me-2'}>Partial:</b>\r\n                <Input data={data} field={'partial'} type={'checkbox'}/>\r\n            </label>}\r\n            <label className={'input-container'}>\r\n                <b className={'me-2'}>Rootable:</b>\r\n                <Tooltip tooltip={\"Whether the element can be a m1 root (present in toolbar).\"}>\r\n                    <Input data={data} field={'rootable'} type={'checkbox'} getter={()=>dclass.rootable} setter={(val)=>{\r\n                        lclass.rootable = val as any;\r\n                        console.log('setter', val);\r\n                    }}/>\r\n                </Tooltip>\r\n            </label>\r\n        </section>);\r\n    }\r\n\r\n    static enum(data: LModelElement, advanced: boolean): JSX.Element {\r\n        return (<section className={'properties-tab'}>\r\n            {this.named(data, advanced)}\r\n            {advanced && <label className={'input-container'}>\r\n                <b className={'me-2'}>Serializable:</b>\r\n                <Input data={data} field={'serializable'} type={'checkbox'}/>\r\n            </label>}\r\n        </section>);\r\n    }\r\n\r\n    static feature(data: LModelElement, advanced: boolean): JSX.Element {\r\n        return (<>\r\n            {this.named(data, advanced)}\r\n            <label className={'input-container'}>\r\n                <b className={'me-2'}>Type:</b>\r\n                <Select data={data} field={'type'} />\r\n            </label>\r\n            <label className={'input-container'}>\r\n                <b className={'me-2'}>Lower Bound:</b>\r\n                <Input data={data} field={'lowerBound'} type={'number'} />\r\n            </label>\r\n            <label className={'input-container'}>\r\n                <b className={'me-2'}>Upper Bound:</b>\r\n                <Input data={data} field={'upperBound'} type={'number'} />\r\n            </label>\r\n            {advanced && <>\r\n                <label className={'input-container'}>\r\n                    <b className={'me-2'}>Unique:</b>\r\n                    <Input data={data} field={'unique'} type={'checkbox'}/>\r\n                </label>\r\n                <label className={'input-container'}>\r\n                    <b className={'me-2'}>Ordered:</b>\r\n                    <Input data={data} field={'ordered'} type={'checkbox'}/>\r\n                </label>\r\n                <label className={'input-container'}>\r\n                    <b className={'me-2'}>Changeable:</b>\r\n                    <Input data={data} field={'changeable'} type={'checkbox'}/>\r\n                </label>\r\n                <label className={'input-container'}>\r\n                    <b className={'me-2'}>Volatile:</b>\r\n                    <Input data={data} field={'volatile'} type={'checkbox'}/>\r\n                </label>\r\n                <label className={'input-container'}>\r\n                    <b className={'me-2'}>Transient:</b>\r\n                    <Input data={data} field={'transient'} type={'checkbox'}/>\r\n                </label>\r\n                <label className={'input-container'}>\r\n                    <b className={'me-2'}>Unsettable:</b>\r\n                    <Input data={data} field={'unsettable'} type={'checkbox'}/>\r\n                </label>\r\n                <label className={'input-container'}>\r\n                    <b className={'me-2'}>Derived:</b>\r\n                    <Input data={data} field={'derived'} type={'checkbox'}/>\r\n                </label>\r\n                <label className={'input-container'}>\r\n                    <b className={'me-2'}>Cross Reference:</b>\r\n                    <Input data={data} field={'allowCrossReference'} type={'checkbox'}/>\r\n                </label>\r\n            </>}\r\n        </>);\r\n    }\r\n\r\n    static attribute(data: LModelElement, advanced: boolean): JSX.Element {\r\n        return (<section className={'properties-tab'}>\r\n            {this.feature(data, advanced)}\r\n            {advanced && <>\r\n                <label className={'input-container'}>\r\n                    <b className={'me-2'}>ID:</b>\r\n                    <Input data={data} field={'isID'} type={'checkbox'} />\r\n                </label>\r\n                <label className={'input-container'}>\r\n                    <b className={'me-2'}>IoT:</b>\r\n                    <Input data={data} field={'isIoT'} type={'checkbox'} />\r\n                </label>\r\n            </>}\r\n        </section>);\r\n    }\r\n    static reference(data: LModelElement, advanced: boolean): JSX.Element {\r\n        return (<section className={'properties-tab'}>\r\n            {this.feature(data, advanced)}\r\n            <label className={'input-container'}>\r\n                <b className={'me-2'}>Composition:</b>\r\n                <Input data={data} field={'composition'} type={'checkbox'} />\r\n            </label>\r\n            <label className={'input-container'}>\r\n                <b className={'me-2'}>Aggregation:</b>\r\n                <Input data={data} field={'aggregation'} type={'checkbox'} />\r\n            </label>\r\n            <label className={'input-container'}>\r\n                <b className={'me-2'}>Container:</b>\r\n                <Input data={data} field={'container'} type={'checkbox'} />\r\n            </label>\r\n        </section>);\r\n    }\r\n    static operation(data: LModelElement, advanced: boolean): JSX.Element {\r\n        return (<section className={'properties-tab'}>\r\n            {this.named(data, advanced)}\r\n            <label className={'input-container'}>\r\n                <b className={'me-2'}>Return:</b>\r\n                <Select data={data} field={'type'} />\r\n            </label>\r\n        </section>);\r\n    }\r\n    static literal(data: LModelElement, advanced: boolean): JSX.Element {\r\n        return (<section className={'properties-tab'}>\r\n            {this.named(data, advanced)}\r\n            <label className={'input-container'}>\r\n                <b className={'me-2'}>Ordinal:</b>\r\n                <Input data={data} field={'ordinal'} type={'number'} />\r\n            </label>\r\n        </section>);\r\n    }\r\n    static object(data: LModelElement, topics: Dictionary<string, unknown>, advanced: boolean): JSX.Element {\r\n        const object: LObject = LObject.fromPointer(data.id);\r\n        let conform = true;\r\n        for(const feature of object.features) {\r\n            let upperBound =  feature.instanceof ? feature.instanceof.upperBound : -1;\r\n            upperBound = (upperBound === -1) ? 999 : upperBound;\r\n            const lowerBound =  feature.instanceof ? feature.instanceof.lowerBound : -1;\r\n            const value = feature.values;\r\n            conform = (value.length >= lowerBound && value.length <= upperBound);\r\n        }\r\n        return(<section className={'properties-tab'}>\r\n            <h1>{data.name}</h1>\r\n            {object.instanceof && conform && <label className={'d-block text-center'}>\r\n                The instance <b className={'text-success'}>CONFORMS</b> to {object.instanceof.name}\r\n            </label>}\r\n            {object.instanceof && !conform && <label className={'d-block text-center'}>\r\n                The instance <b className={'text-danger'}>NOT CONFORMS</b> to {object.instanceof.name}\r\n            </label>}\r\n            {!object.instanceof && <label className={'d-block text-center'}>\r\n                The instance is <b className={'text-warning'}>SHAPELESS</b>\r\n            </label>}\r\n            {!object.partial ? null :\r\n                <label className={'input-container'}>\r\n                    <b className={'me-2'}>Features:</b>\r\n                    <button className={'btn btn-primary ms-auto'} onClick={e => object.addValue()}>\r\n                        <i className={'p-1 bi bi-plus'} />\r\n                    </button>\r\n                </label>\r\n            }\r\n            {this.forceConform(object)}\r\n            {object.features.map(f => <div id={`Object-${f.id}`}>\r\n                {this.value(f, topics, advanced)}\r\n            </div>)}\r\n        </section>);\r\n    }\r\n    static forceConform(me: LObject) {\r\n        let mm: LModel = Selectors.getLastSelectedModel().m2 as LModel;\r\n        if (!mm) return <></>\r\n        return(<label className={'input-container'}>\r\n            <b className={'me-2'}>Force Type:</b>\r\n            <select className={'my-auto ms-auto select'} onChange={ (event)=>{\r\n                (window as any).debugmm = mm;\r\n                (window as any).debugm = me;\r\n                me.instanceof = event.target.value === 'undefined' ? undefined : event.target.value as any;\r\n            } } value={me.instanceof?.id || 'undefined'}>\r\n                <optgroup label={mm.name}>\r\n                    {(mm.classes || []).map( c =>\r\n                            <option value={c.id}>{c?.name || c.id}</option>\r\n                    )}\r\n                    <option value={'undefined'}>Object</option>\r\n                </optgroup>\r\n            </select>\r\n        </label>);\r\n    }\r\n    static value(data: LModelElement, topics: Dictionary<string, unknown>, advanced: boolean): JSX.Element {\r\n        let value: LValue = LValue.fromPointer(data.id);\r\n        const feature: LStructuralFeature = LStructuralFeature.fromPointer(value.instanceof?.id);\r\n        let field = 'text'; let stepSize = 1; let maxLength = 524288;\r\n        const min = -9223372036854775808;\r\n        const max = 9223372036854775807;\r\n        switch (feature?.type.name) {\r\n            case 'EChar': maxLength = 1; break;\r\n            case 'EInt':\r\n            case 'ELong':\r\n            case 'EShort':\r\n            case 'Byte': field = 'number'; break;\r\n            case 'EFloat': field = 'number'; stepSize = 0.1; break;\r\n            case 'EDouble': field = 'number'; stepSize = 0.01; break;\r\n            case 'EBoolean': field = 'checkbox'; break;\r\n            case 'EDate': field = 'date'; break;\r\n            default: field = 'text'; break;\r\n        }\r\n        let upperBound = feature ? (feature as LReference | LAttribute).__raw.upperBound : -1;\r\n        if (upperBound < 0) upperBound = 999;\r\n        let filteredValues: ValueDetail[] = value.getValues(true, false, false, false, true, true) as any;\r\n\r\n        const add = () => {\r\n            value = value.r;\r\n            SetFieldAction.new(value.id, 'values', U.initializeValue(feature?.type), '+=', false);\r\n        }\r\n        const remove = (index: number, isPointer: boolean | undefined) => {\r\n            console.log('remove clicked');\r\n            value = value.r;\r\n            if (isPointer === undefined) isPointer = Pointers.isPointer(filteredValues[index].rawValue); // !!(filteredValues[index].value as any)?.__isProxy ||\r\n            // SetFieldAction.new(value.id, 'values', index, '-=', isPointer);\r\n\r\n            let result = value.setValueAtPosition(index, undefined, {isPtr: isPointer});\r\n            console.log('clearing containment DValue', {result, index, value});\r\n        }\r\n        function changeDValue(event: React.ChangeEvent<HTMLInputElement|HTMLSelectElement>, index: number, isPointer: boolean | undefined) {\r\n            TRANSACTION('change value (sidebar)', ()=>{\r\n                value = value.r;\r\n                let inputValue: string | boolean = field === 'checkbox' ? (event.target as HTMLInputElement).checked : event.target.value;\r\n                if (inputValue === 'undefined') inputValue = undefined as any;\r\n                let raw_values = value.__raw.values;\r\n                isPointer = isPointer || Pointers.isPointer(raw_values[index]) || Pointers.isPointer(inputValue);\r\n\r\n                let oldvi = raw_values[index];\r\n                if (isPointer && value.containment){\r\n                    let indexDuplicate = raw_values.indexOf(inputValue as any);\r\n                    if (indexDuplicate === index) return;\r\n                    if (indexDuplicate >= 0) {\r\n                        let result = value.setValueAtPosition(indexDuplicate, undefined, {isPtr: true});\r\n                        console.log('clearing containment DValue', {inputValue, result, indexDuplicate, raw_values, index, oldvi});\r\n                    }\r\n                }\r\n                let result = value.setValueAtPosition(index, inputValue, {isPtr: isPointer});\r\n                console.log('setting DValue', {inputValue, result, value, index, oldvi});\r\n            })\r\n        }\r\n        const featureType: LClassifier = feature?.type;\r\n        let isAttribute = false, isEnumerator = false, isReference = false, isShapeless = false;\r\n        switch(feature?.className){\r\n            case DAttribute.cname:\r\n                if (featureType.className === DClass.cname) isAttribute = true; else\r\n                if (featureType.className === DEnumerator.cname) isEnumerator = true;\r\n                break;\r\n            case DReference.cname: isReference = true; break;\r\n            default: isShapeless = true; break;\r\n        }\r\n        let selectOptions: JSX.Element | JSX.Element[] | null = value.validTargetsJSX;\r\n\r\n        let isPtr = isAttribute ? false : (isEnumerator || isReference ? true : undefined);\r\n        const valueslist = (filteredValues).map((val, index) =>\r\n            val.hidden ? null :\r\n                <label className={'mt-1 d-flex ms-4'} key={index}>\r\n                    <div className={'border border-dark'}></div>\r\n                    {isAttribute && <Input key={'a'+index} setter={(val: any) => { changeDValue({target:{value:val}} as any, index, false) }}\r\n                                           className={'input m-auto ms-1' /*@ts-ignore*/}\r\n                                           getter={()=>val.value as any} min={min} max={max} type={field as any} step={stepSize}\r\n                                           maxLength={maxLength} placeholder={'empty'}/> }\r\n                    {isEnumerator && <select key={'e'+index} onChange={(evt) => {changeDValue(evt, index, true)}} className={'m-auto ms-1 select'} value={val.rawValue+''} data-valuedebug={val.rawValue}>\r\n                        {<option key='undefined' value={'undefined'}>-----</option>}\r\n                        {selectOptions}\r\n                    </select>}\r\n                    {isReference && <select key={'r'+index} onChange={(evt) => {changeDValue(evt, index, true)}} className={'m-auto ms-1 select'} value={val.rawValue+''} data-valuedebug={val.rawValue}>\r\n                        <option value={'undefined'}>-----</option>\r\n                        {selectOptions}\r\n                    </select>}\r\n                    {isShapeless && <>\r\n                        {<Input key={'raw' + index} setter={(val: any) => {changeDValue({target:{value:val}} as any, index, false)}}\r\n                                className={'input m-auto ms-1' /*@ts-ignore*/}\r\n                                getter={()=>val.rawValue} list={'objectdatalist'} type={'text'} placeholder={'empty'}/>}\r\n                        <span className={'ms-1 my-auto'}>→</span>\r\n                        {<select key={index} onChange={(evt) => {changeDValue(evt, index, undefined)}} className={'select m-auto ms-1'} value={val.rawValue+''}>\r\n                            {selectOptions}\r\n                        </select>}\r\n                    </>}\r\n                    <CommandBar>\r\n                        <Btn icon={'delete'} tip={'Remove value'} action={(evt) => {remove(index, isPtr)}} />\r\n                    </CommandBar>\r\n                    {/*<button className={'btn btn-danger m-auto ms-2'} onClick={(evt) => {remove(index, isPtr)}}>\r\n                        <i className={'p-1 bi bi-trash3'}></i>\r\n                    </button>*/}\r\n                </label>);\r\n\r\n        return(<section className={'properties-tab'}>\r\n            <h1>{data.name}</h1>\r\n            <label className={'d-flex'}>\r\n                <label className={'ms-1 my-auto'}>Values</label>\r\n                <CommandBar style={{marginLeft: 'auto', marginTop: '6px'}}>\r\n                    <Btn icon={'add'} action={add} tip={`Add a ${data.name} value`} disabled={filteredValues.length >= upperBound}/>\r\n                </CommandBar>\r\n                {/* <button className={'btn btn-primary ms-auto me-1'} disabled={filteredValues.length >= upperBound} onClick={add}>\r\n                    <i className={'p-1 bi bi-plus'}></i>\r\n                </button>*/}\r\n            </label>\r\n            {valueslist}\r\n            {value.instanceof?.className === 'DAttribute' && (value.instanceof as LAttribute).isIoT && <label className={'mt-2 input-container'}>\r\n                <b className={'me-2'}>Topic:</b>\r\n                <select className={'my-auto ms-auto select'} defaultValue={value.topic} onChange={e => value.topic = e.target.value}>\r\n                    <optgroup label={'topics'}>\r\n                        <option value={''}>------</option>\r\n                        {U.extractTopics(topics).map(t => <option key={t} value={t}>{t}</option>)}\r\n                    </optgroup>\r\n                </select>\r\n            </label>}\r\n        </section>)\r\n    }\r\n}\r\n\r\nfunction InfoComponent(props: AllProps) {\r\n    const {data, node, view, topics, advanced} = props;\r\n\r\n    switch (data?.className) {\r\n        case 'DModel':\r\n            return builder.model(data, advanced);\r\n        case 'DPackage':\r\n            return builder.package(data, advanced);\r\n        case 'DClass':\r\n            return builder.class(data, advanced);\r\n        case 'DEnumerator':\r\n            return builder.enum(data, advanced);\r\n        case 'DAttribute':\r\n            return builder.attribute(data, advanced);\r\n        case 'DReference':\r\n            return builder.reference(data, advanced);\r\n        case 'DOperation':\r\n            return builder.operation(data, advanced);\r\n        case 'DParameter':\r\n            return builder.operation(data.father, advanced);\r\n        case 'DEnumLiteral':\r\n            return builder.literal(data, advanced);\r\n        case 'DObject':\r\n            return builder.object(data, topics, advanced);\r\n        case 'DValue':\r\n            return builder.value(data, topics, advanced);\r\n    }\r\n    return <Empty />;\r\n\r\n}\r\n\r\ninterface OwnProps {}\r\ninterface StateProps {\r\n    node?: LGraphElement\r\n    view?: LViewElement\r\n    data?: LModelElement\r\n    topics: Dictionary<string, unknown>\r\n    advanced: boolean\r\n}\r\ninterface DispatchProps {}\r\n\r\ntype AllProps = OwnProps & StateProps & DispatchProps;\r\n\r\nfunction mapStateToProps(state: DState, ownProps: OwnProps): StateProps {\r\n    const ret: StateProps = {} as FakeStateProps;\r\n    const nodeID = state._lastSelected?.node;\r\n    const viewID = state._lastSelected?.view;\r\n    const dataID = state._lastSelected?.modelElement;\r\n    if(nodeID) ret.node = LGraphElement.fromPointer(nodeID);\r\n    if(viewID) ret.view = LViewElement.fromPointer(viewID);\r\n    if(dataID) ret.data = LModelElement.fromPointer(dataID);\r\n    ret.topics = state.topics;\r\n    ret.advanced = state.advanced;\r\n    return ret;\r\n}\r\n\r\nfunction mapDispatchToProps(dispatch: Dispatch<any>): DispatchProps {\r\n    const ret: DispatchProps = {} as any;\r\n    return ret;\r\n}\r\n\r\n\r\nexport const InfoConnected = connect<StateProps, DispatchProps, OwnProps, DState>(\r\n    mapStateToProps,\r\n    mapDispatchToProps\r\n)(InfoComponent);\r\n\r\nexport const Info = (props: OwnProps, children: (string | Component)[] = []): ReactElement => {\r\n    return <InfoConnected {...{...props, children}} />;\r\n}\r\nexport default Info;\r\n","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\components\\forEndUser\\ModellingIcon.tsx",["1846","1847","1848","1849","1850","1851","1852","1853","1854"],"import React from 'react';\r\nimport EPackage from '../../static/icon/modelling/package.png';\r\nimport EClass from '../../static/icon/modelling/class.png';\r\nimport EAttribute from '../../static/icon/modelling/attribute.png';\r\nimport EReference from '../../static/icon/modelling/reference.png';\r\nimport EOperation from '../../static/icon/modelling/operation.png';\r\nimport EEnumerator from '../../static/icon/modelling/enumerator.png';\r\nimport ELiteral from '../../static/icon/modelling/literal.png';\r\nimport Utility from '../../static/img/utility.png';\r\n\r\ninterface Props {name?: string, className?: string, src?:string}\r\n\r\n/* function ModellingIcon(props: Props) {\r\n    const name = props.name;\r\n    const className = props.className ? props.className : '';\r\n    const pprops = {width:20, height:20, className:`my-auto ${className||''} ` + (name || '')}\r\n    if (props.src) return <img {...pprops} src={props.src} />;\r\n    switch (name) {\r\n        case 'package': return(<img {...pprops} src={EPackage} />);\r\n        case 'object':\r\n        case 'class':\r\n            return(<img {...pprops} src={EClass} />);\r\n        case 'reference': return(<img {...pprops} src={EReference} />);\r\n        case 'operation': return(<img {...pprops} src={EOperation} />);\r\n        case 'enumerator': return(<img {...pprops} src={EEnumerator} />);\r\n        case 'literal': return(<img {...pprops} src={ELiteral} />);\r\n        case 'value':\r\n        case 'attribute':\r\n            return(<img {...pprops} src={EAttribute} />);\r\n        default:\r\n            return(<img {...pprops} src={Utility} />);\r\n\r\n    }\r\n}*/\r\n\r\ntype IconProps = {\r\n    letter: string\r\n}\r\nfunction Icon(props: IconProps) {\r\n\r\n    return (\r\n        <label className={'element-icon'}>{props.letter}</label>\r\n    );\r\n\r\n};\r\n\r\nfunction ModellingIcon(props: Props) {\r\n    const name = props.name;\r\n    const className = props.className ? props.className : '';\r\n    const pprops = {width:20, height:20, className:`my-auto ${className||''} ` + (name || '')}\r\n    if (props.src) return <img {...pprops} src={props.src} />;\r\n    switch (name) {\r\n        case 'package': return(<Icon letter={'P'} />);\r\n        case 'object':\r\n        case 'class':\r\n            return(<Icon letter={'C'} />);\r\n        case 'reference': return(<Icon letter={'R'} />)\r\n        case 'operation': return(<Icon letter={'O'} />)\r\n        case 'enumerator': return(<Icon letter={'E'} />)\r\n        case 'literal': return(<Icon letter={'L'} />)\r\n        case 'value':\r\n        case 'attribute':\r\n            return(<Icon letter={'A'} />)\r\n        default:\r\n            return(<Icon letter={'U'} />)\r\n    }\r\n}\r\n\r\nexport default ModellingIcon;\r\n","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\api\\memorec\\index.ts",[],"C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\components\\forEndUser\\Tree.tsx",["1855","1856","1857","1858","1859","1860","1861","1862"],"import React, {ReactNode, MouseEventHandler} from \"react\";\r\nimport {\r\n    DClass,\r\n    Dictionary,\r\n    DViewElement,\r\n    GObject,\r\n    LClass,\r\n    LModelElement,\r\n    LNamedElement, LPointerTargetable,\r\n    LViewElement,\r\n    LViewPoint, Pointer,\r\n    SetRootFieldAction,\r\n    U\r\n} from '../../joiner';\r\nimport {useStateIfMounted} from 'use-state-if-mounted';\r\nimport './tree.scss';\r\nimport {useEffectOnce} from \"usehooks-ts\";\r\n\r\nimport { MyTooltip } from \"../tooltip/MyTooltip\";\r\nimport { CommandBar, Btn } from \"../commandbar/CommandBar\";\r\n\r\n/*\r\ntype BtnProps = {\r\n    icon: \"up\" | \"down\" | \"back\" | \"fwd\" | \"add\" | \"delete\" | \"edit\",\r\n    tip?: string,\r\n    action?: MouseEventHandler,\r\n    size?: \"small\" | \"medium\" | \"large\"\r\n}\r\n\r\nconst Btn = (props: BtnProps) => {\r\n    return (<>\r\n        {props.action ?\r\n            <div><i onClick={props.action} title={`${props.tip && props.tip}`} className={`bi tab-btn ${props.icon} ${props.size && props.size}`}></i></div>\r\n        :\r\n            <i className={`bi tab-btn ${props.icon} ${props.size && props.size} disabled`}></i>\r\n        }\r\n    </>);\r\n}\r\n\r\n\r\n\r\ntype CommandProps = {\r\n    children: any;\r\n}\r\nconst CommandBar = (props: CommandProps) => {\r\n\r\n    return(<div className={'command-bar'}>\r\n        {props.children}\r\n    </div>);\r\n};*/\r\n\r\n\r\ninterface TreeProps {data?: LModelElement, depth?: string[], children?: GObject}\r\n\r\nfunction Tree(props: TreeProps) {\r\n    const data = (props.data) ? props.data : null;\r\n    const children = props.children;\r\n    const [id, setId] = useStateIfMounted('');\r\n    const depth = (props.depth) ? [...props.depth, id] : [id];\r\n    const [filter, applyFilter] = useStateIfMounted('');\r\n    const hide = depth.includes(filter);\r\n\r\n    useEffectOnce(() => {\r\n        setId((data && data.id) ? data.id : U.getRandomString(5));\r\n    })\r\n\r\n    const setFilter = (): void => {\r\n        if(filter === id) applyFilter('');\r\n        else applyFilter(id);\r\n    }\r\n\r\n    function setME(data?: LModelElement): void {\r\n        if (!data) return;\r\n        let node = data.node;\r\n        SetRootFieldAction.new('_lastSelected', {\r\n            node: node?.id,\r\n            view: node?.view.id,\r\n            modelElement: data.id\r\n        }, '', false);\r\n    }\r\n\r\n    let up = data?.father;\r\n    let down = data?.children[0];\r\n    if (data) return(\r\n        <>\r\n            {!props.depth && <CommandBar>\r\n                <Btn icon={'up'} size={'medium'} disabled={!up} action={(e) => { setME(up)} } tip={'Click to go up to the ancestor element'} />\r\n                <Btn icon={'down'} size={'medium'} disabled={!down} action={(e) => { setME(down)} } tip={'Select the first child'} />\r\n            </CommandBar>}\r\n            <DataTree data={data} depth={depth} hide={hide} setFilter={setFilter} />\r\n        </>)\r\n    if (children) return(<><HtmlTree data={children} hide={hide} depth={depth} setFilter={setFilter} /></>);\r\n    return(<></>);\r\n}\r\n\r\ninterface DataTreeProps {data: LModelElement, hide: boolean, depth: string[], setFilter: () => void}\r\nfunction DataTree(props: DataTreeProps): JSX.Element {\r\n    const hide = props.hide;\r\n    const data: LNamedElement = LNamedElement.fromPointer(props.data.id);\r\n    if(!data) return(<div>Error Data is <b>undefined</b></div>);\r\n    const depth = props.depth;\r\n    const setFilter = props.setFilter;\r\n\r\n    const click = () => {\r\n        let node = data.node;\r\n        SetRootFieldAction.new('_lastSelected', {\r\n            node: node?.id,\r\n            view: node?.view.id,\r\n            modelElement: data.id\r\n        }, '', false);\r\n    }\r\n\r\n    /*let icon = 'box';\r\n    switch(data.className) {\r\n        case 'DModel': icon = 'diagram-2'; break;\r\n        case 'DPackage': icon = 'boxes'; break;\r\n        case 'DClass': icon = 'folder'; break;\r\n        case 'DAttribute': icon = 'stop'; break;\r\n        case 'DReference': icon = 'stop-fill'; break; //beliezer2 // folder-symlink\r\n        case 'DOperation': icon = 'gear-wide'; break;\r\n        case 'DObject': icon = ''; break;\r\n        case 'DValue': icon = ''; break;\r\n    }*/\r\n\r\n    return(<section className={'datatree-entry-root'}>\r\n\r\n        <div className={'d-flex tree'}>\r\n            {data.children?.length >= 1 ? ((data.children?.length && hide) ?\r\n                <i style={{fontSize: '0.7em', color: 'gray'}} className={'bi bi-chevron-right cursor-pointer d-block my-auto'} onClick={setFilter} /> :\r\n                <i style={{fontSize: '0.7em', color: 'gray'}} className={'bi bi-chevron-down cursor-pointer d-block my-auto'} onClick={setFilter} />\r\n            ) :\r\n                <i style={{fontSize: '0.75em', color: 'whitesmoke'}} className={'bi bi-caret-right-fill d-block my-auto'} />\r\n            }\r\n\r\n            <div className={'tree-item'} onClick={click}>\r\n                {/* <div className={`type tree-${data.className} ${(data as any).abstract && 'abstract-class'}`}>\r\n                    <div className={'icon'}>{data.className.slice(1, 2)}</div>*/}\r\n\r\n                <div className={'type'}>\r\n                    <div className={`icon tree-${data.className} ${(data as any).abstract && 'abstract-class'}`}>\r\n                        {data.className === 'DEnumLiteral' ? 'L' : data.className.slice(1, 2)}\r\n                    </div>\r\n                    <MyTooltip text={`${(data as any).abstract ? 'Abstract ':''}` + data.className} />\r\n                </div>\r\n                <div className={'name'}>\r\n                    <span className={'class-name'}>\r\n                        {(data.name) ? data.name : 'unnamed'}\r\n                        {(data as LClass).extends && (data as LClass).extends.length > 0 &&\r\n                            <span className={'extends'}>\r\n                                &nbsp; <i className=\"bi bi-caret-right\"></i> [{(data as LClass).extends.map((s,i) => <><i>{s.name}</i>{i < (data as LClass).extends.length - 1 ? ', ' :''}</>)}]\r\n                            </span>\r\n                        }\r\n                    </span>\r\n                    </div>\r\n            </div>\r\n\r\n        </div>\r\n        {!hide && Array.isArray(data.children) && data.children?.map((child: LModelElement) => {\r\n            return(<div style={{marginLeft: '1em'}}>\r\n                <Tree data={child} depth={depth} />\r\n            </div>);\r\n        })}\r\n    </section>);\r\n}\r\n\r\ninterface HtmlTreeProps {data: GObject, hide: boolean, depth: string[], setFilter: () => void}\r\nfunction HtmlTree(props: HtmlTreeProps) {\r\n    const data: (string|ReactNode)[] = (Array.isArray(props.data)) ? props.data : [props.data];\r\n    const hide = props.hide;\r\n    const depth = props.depth;\r\n    const setFilter = props.setFilter;\r\n\r\n    return(<div>\r\n        {data.map((element: string|ReactNode) => {\r\n            if(!React.isValidElement(element)) return(<></>);\r\n            const children: (string|ReactNode)[] = (Array.isArray(element.props.children)) ? element.props.children: [element.props.children];\r\n            return(<>\r\n                <div className={'d-flex'}>\r\n                    {(children.length > 0 && hide) ?\r\n                        <i className={'bi bi-chevron-up cursor-pointer d-block my-auto'} onClick={setFilter} /> :\r\n                        <i className={'bi bi-chevron-down cursor-pointer d-block my-auto'} onClick={setFilter} />\r\n                    }\r\n                    <label className={'ms-1 my-auto'}>\r\n                        {element.props['label'] ? element.props['label'] : 'unnamed'}\r\n                    </label>\r\n                </div>\r\n                {!hide && children.map((child) => {\r\n                    if(!React.isValidElement(child)) return(<></>);\r\n                    return(<div className={'ms-2'}>\r\n                        <Tree depth={depth}>\r\n                            {child}\r\n                        </Tree>\r\n                    </div>);\r\n                })}\r\n            </>);\r\n        })}\r\n    </div>);\r\n}\r\n\r\ninterface GenericTreeProps<T extends any = any> {\r\n    data: any,\r\n    getSubElements: (o: any)=>(GObject[] | Dictionary<any, any>),\r\n    //getKey: (o:any) => string,\r\n    renderEntry: (e: any, childrens: any, isExpanded: boolean, toggleExpansion: () => any, depth: number, path: number[], metadata?:any)=>JSX.Element,\r\n    initialHidingState?: boolean,\r\n    depth?: number,\r\n    path?: number[],\r\n    metadata?: any,\r\n}\r\n\r\nexport function GenericTree(props: GenericTreeProps): JSX.Element {\r\n    let [isExpanded, setExpanded] = useStateIfMounted(props.initialHidingState || false);\r\n    const data: GObject = props.data;\r\n    const childrens = props.getSubElements(data) || [];\r\n    // if (typeof childrens === \"object\" && (Array.isArray(childrens) && childrens.length === 0) || Object.keys(childrens)) isExpanded = false;\r\n    return props.renderEntry(data, childrens, isExpanded, ()=>setExpanded(!isExpanded), props.depth || 0, props.path || [], props.metadata);\r\n    /*\r\n    if (!data) return(<div>Error Data is <b>undefined</b></div>);\r\n    const depth = props.depth;\r\n    const setFilter = props.setFilter;\r\n\r\n    const click = () => {\r\n        let node = data.node;\r\n        SetRootFieldAction.new('_lastSelected', {\r\n            node: node?.id,\r\n            view: node?.view.id,\r\n            modelElement: data.id\r\n        }, '', false);\r\n    }\r\n\r\n    let className: string = data.className;\r\n    let name: string = data.name;\r\n    let vp: LViewPoint | undefined = className === LViewPoint.cname ? (data as any) : undefined;\r\n    let view: LViewElement | undefined = vp || (className === DViewElement.cname ? (data as any) : undefined);\r\n    let subType: string = '';\r\n    if (view) {\r\n        let appliableTo = view.appliableToClasses;\r\n        subType = appliableTo.length > 1 ? \"multi\" : appliableTo[0];\r\n    }\r\n    let subelements: GObject[] = props.getSubElements ? props.getSubElements(data) : (view ? view.subViews : data.children);\r\n    return(<section>\r\n        <div className={'d-flex tree ' + className + ' ' + subType}>\r\n            {subelements?.length >= 1 ? ((subelements?.length && hide) ?\r\n                        <i style={{fontSize: '0.7em', color: 'gray'}} className={'bi bi-chevron-right cursor-pointer d-block my-auto'} onClick={setFilter} /> :\r\n                        <i style={{fontSize: '0.7em', color: 'gray'}} className={'bi bi-chevron-down cursor-pointer d-block my-auto'} onClick={setFilter} />\r\n                ) :\r\n                <i style={{fontSize: '0.75em', color: 'whitesmoke'}} className={'bi bi-caret-right-fill d-block my-auto'} />\r\n            }\r\n\r\n            <div className={'tree-icon'}>\r\n                <div className={`type tree-${className}`}>{className.slice(1, 2)}</div>\r\n                <div className={'name'} onClick={click}>{(data.name) ? data.name : 'unnamed'}</div>\r\n            </div>\r\n        </div>\r\n        {!hide && Array.isArray(subelements) && subelements?.map((child: LPointerTargetable) => {\r\n            return(<div style={{marginLeft: '1em'}}>\r\n                <Tree data={child} depth={depth} />\r\n            </div>);\r\n        })}\r\n    </section>);*/\r\n}\r\n\r\nTree.cname = \"Tree\";\r\nDataTree.cname = \"DataTree\";\r\nHtmlTree.cname = \"HtmlTree\";\r\nGenericTree.cname = \"GenericTree\";\r\nexport default Tree;\r\n","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\components\\editors\\views\\ViewData.tsx",[],"C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\components\\editors\\Collaborative.tsx",["1863","1864"],"import {Dispatch, ReactElement, useEffect, useState} from 'react';\r\nimport {connect} from 'react-redux';\r\nimport type {DState, LProject} from '../../joiner';\r\nimport {DUser, GObject, LUser, U} from '../../joiner';\r\nimport {FakeStateProps} from '../../joiner/types';\r\nimport {UsersApi} from \"../../api/persistance\";\r\nimport {Btn, CommandBar} from '../commandbar/CommandBar';\r\nimport {useEffectOnce} from \"usehooks-ts\";\r\n\r\nfunction CollaborativeComponent(props: AllProps) {\r\n    const {project, users} = props;\r\n    const [emails, setEmails] = useState<string[]>([]);\r\n    const [filteredEmails, setFilteredEmails] = useState<string[]>([]);\r\n    const [email, setEmail] = useState<string>('');\r\n\r\n    useEffectOnce(() => {\r\n        (async function() {\r\n            setEmails(await UsersApi.getAllEmails());\r\n        })();\r\n    });\r\n\r\n    useEffect(() => {\r\n        if(!email) setFilteredEmails([]);\r\n        else setFilteredEmails(emails.filter(e => e.startsWith(email)));\r\n    }, [email])\r\n\r\n    const addCollaborator = async(e: string) => {\r\n        const user = await UsersApi.getUserByEmail(e);\r\n        if(!user) {\r\n            U.alert('e', 'Cannot retrieve user data.', 'Something went wrong ...');\r\n            return;\r\n        }\r\n        if(!users.map(u => u.id).includes(user.id))\r\n            DUser.new(user.name, user.surname, user.nickname, user.affiliation, user.country, user.newsletter, user.email, '', user.id);\r\n        if(project.collaborators.map(c => c.id).includes(user.id)) return;\r\n        project.collaborators = [...project.collaborators, user];\r\n    }\r\n\r\n    return(<section className={'page-root collaborative-tab'}>\r\n        <h1 className={'view'}>Collaborative Modeling</h1>\r\n        <div className={'p-1 w-100  d-flex'} style={{borderRadius: 'var(--radius)'}}>\r\n            <h5><i className=\"bi bi-person-video3\"></i> Editor</h5>\r\n            <label className={'ms-auto'}>{project.author.nickname}</label>\r\n        </div>\r\n        {project.collaborators.length > 0 && <div className={'mt-2 p-1 w-100 border'} style={{borderRadius: 'var(--radius'}}>\r\n            <h5><i className=\"bi bi-person-video3\"></i> Collaborators</h5>\r\n            <div className={'ms-auto'}>\r\n                {project.collaborators.map((c, index) => {\r\n                    return(<label className={'ms-1'} key={index}>{c.surname}</label>);\r\n                })}\r\n            </div>\r\n        </div>}\r\n        <input placeholder={'contributor email'} className={'input w-25 float-end'} defaultValue={email} onChange={e => setEmail(e.target.value)} />\r\n        <div>\r\n            {filteredEmails.map(e => <div key={e}>\r\n                <CommandBar className={'float-end'} style={{marginLeft: '5px'}}>\r\n                    {e}\r\n                    <Btn icon={'add'} action={() => addCollaborator(e)} tip={'Invite contributor'} />\r\n                </CommandBar>\r\n            </div>)}\r\n        </div>\r\n        <div className={'alert'}>\r\n            <i className=\"bi bi-exclamation-circle\"></i>\r\n            Important: After sending the invitation, save the project!\r\n        </div>\r\n    </section>);\r\n}\r\ninterface OwnProps {}\r\ninterface StateProps {project: LProject, users: LUser[]}\r\ninterface DispatchProps {}\r\ntype AllProps = OwnProps & StateProps & DispatchProps;\r\n\r\n\r\nfunction mapStateToProps(state: DState, ownProps: OwnProps): StateProps {\r\n    const ret: StateProps = {} as FakeStateProps;\r\n    const user = LUser.fromPointer(DUser.current);\r\n    ret.project = user.project as LProject;\r\n    ret.users = LUser.fromPointer(state.users);\r\n    return ret;\r\n}\r\n\r\nfunction mapDispatchToProps(dispatch: Dispatch<any>): DispatchProps {\r\n    const ret: DispatchProps = {};\r\n    return ret;\r\n}\r\n\r\nexport const CollaborativeConnected = connect<StateProps, DispatchProps, OwnProps, DState>(\r\n    mapStateToProps,\r\n    mapDispatchToProps\r\n)(CollaborativeComponent);\r\n\r\nexport const Collaborative = (props: OwnProps, children: (string | React.Component)[] = []): ReactElement => {\r\n    return <CollaborativeConnected {...{...props, children}} />;\r\n}\r\n","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\components\\editors\\Logger.tsx",[],"C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\components\\editors\\Settings.tsx",["1865"],"import {DState, Select} from '../../joiner';\r\nimport {FakeStateProps} from '../../joiner/types';\r\nimport React, {Component, Dispatch, ReactElement} from 'react';\r\nimport {connect} from 'react-redux';\r\nimport './style.scss';\r\n\r\nfunction SettingsComponent(props: AllProps) {\r\n    const {background, setBackground, color, setColor} = props;\r\n    return(<section>\r\n        <div className={'input-container'}>\r\n            <b className={'me-2'}>Background:</b>\r\n            <input className={'input'} type={'color'} defaultValue={background} onChange={e => setBackground(e.target.value)} />\r\n        </div>\r\n        <div className={'input-container'}>\r\n            <b className={'me-2'}>Color:</b>\r\n            <input className={'input'} type={'color'} defaultValue={color} onChange={e => setColor(e.target.value)} />\r\n        </div>\r\n    </section>);\r\n\r\n}\r\n\r\ninterface OwnProps {\r\n    background: string\r\n    setBackground: React.Dispatch<React.SetStateAction<string>>\r\n    color: string\r\n    setColor: React.Dispatch<React.SetStateAction<string>>\r\n}\r\ninterface StateProps {}\r\ninterface DispatchProps {}\r\n\r\ntype AllProps = OwnProps & StateProps & DispatchProps;\r\n\r\nfunction mapStateToProps(state: DState, ownProps: OwnProps): StateProps {\r\n    const ret: StateProps = {} as FakeStateProps;\r\n    return ret;\r\n}\r\n\r\nfunction mapDispatchToProps(dispatch: Dispatch<any>): DispatchProps {\r\n    const ret: DispatchProps = {} as any;\r\n    return ret;\r\n}\r\n\r\n\r\nexport const SettingsConnected = connect<StateProps, DispatchProps, OwnProps, DState>(\r\n    mapStateToProps,\r\n    mapDispatchToProps\r\n)(SettingsComponent);\r\n\r\nexport const Settings = (props: OwnProps, children: (string | Component)[] = []): ReactElement => {\r\n    return <SettingsConnected {...{...props, children}} />;\r\n}\r\nexport default Settings;\r\n","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\components\\editors\\views\\data\\CustomData.tsx",["1866","1867","1868","1869","1870","1871"],"/* Viewpoints > Events */\r\n\r\nimport React, {Dispatch, EventHandler, MouseEventHandler, ReactElement} from 'react';\r\nimport {DState, DViewElement, GObject, LViewElement, Pointer, TextArea, U} from '../../../../joiner';\r\nimport {connect} from \"react-redux\";\r\nimport {JsEditor} from \"../../languages\";\r\nimport {Function} from \"../../../forEndUser/FunctionComponent\";\r\n// import JsEditor from \"../../jsEditor/JsEditor\";\r\n\r\nimport { CommandBar, Btn, Sep } from '../../../commandbar/CommandBar';\r\n\r\nfunction ViewEventsComponent(props: AllProps) {\r\n    const view = props.view;\r\n    const dview = props.view.__raw;\r\n    const readOnly = props.readonly;\r\n\r\n    function addEvent() {\r\n        let eventname = \"customEvent1\";\r\n        eventname = U.increaseEndingNumber(eventname, false, false, (s)=> s in dview.events);\r\n        let newevent: GObject = {};\r\n        newevent[eventname] = '(parameter1, parameter2) => {\\n\\t// example, replace with your function\\n\\treturn parameter1 + parameter2;\\n}';\r\n        view.events = newevent;\r\n    }\r\n\r\n    let initialExpand = (v: any, field: any)=>!!(v as any)[field as string];\r\n    return(<section className={'p-3 events-tab'}>\r\n        <h1 className={'view'}>View: {view.name}</h1>\r\n        <h2>Default Events</h2>\r\n        <JsEditor key='odu' data={view} field={'onDataUpdate'} title={'onDataUpdate'} initialExpand={initialExpand} readonly={readOnly}/>\r\n        <JsEditor key='ods' data={view} field={'onDragStart'} title={'onDragStart'} initialExpand={initialExpand} readonly={readOnly}/>\r\n        <JsEditor key='odw' data={view} field={'whileDragging'} title={'whileDragging'} initialExpand={initialExpand} readonly={readOnly}/>\r\n        <JsEditor key='ode' data={view} field={'onDragEnd'} title={'onDragEnd'} initialExpand={initialExpand} readonly={readOnly}/>\r\n        <JsEditor key='ors' data={view} field={'onResizeStart'} title={'onResizeStart'} initialExpand={initialExpand} readonly={readOnly}/>\r\n        <JsEditor key='orw' data={view} field={'whileResizing'} title={'whileResizing'} initialExpand={initialExpand} readonly={readOnly}/>\r\n        <JsEditor key='ore' data={view} field={'onResizeEnd'} title={'onResizeEnd'} initialExpand={initialExpand} readonly={readOnly}/>\r\n        <div className={'d-flex mx-auto'} style={{marginTop: '14px'}}>\r\n            <h2>Custom Events</h2>\r\n            <CommandBar className={'ms-auto'} style={{paddingTop: '12px'}}>\r\n                <Btn icon={'add'} action={addEvent}  tip={'New event'}/>\r\n            </CommandBar>\r\n        </div>\r\n\r\n        {Object.keys(dview.events).map((k) => {\r\n            let val = dview.events[k];\r\n            if (!val) return;\r\n            return <>\r\n            <JsEditor\r\n            data={view} key={k/* if val does not update, concatenate it to the key (k+val)*/}\r\n            readonly={readOnly}\r\n            initialExpand={()=>true}\r\n            title={<input defaultValue={k} disabled={readOnly} onBlur={(e)=>{\r\n                let newname = e.target.value;\r\n                if (k === newname) return;\r\n                let newEvent: GObject = {};\r\n                newEvent[newname] = dview.events[k];\r\n                newEvent[k] = undefined;\r\n                view.events = newEvent;\r\n            }}/>}\r\n            jsxLabel={<CommandBar className={'ms-auto'} style={{paddingTop: '9px'}}>\r\n                <Btn icon={'delete'} tip={'Remove event'} action={() => {\r\n                    let newEvent: GObject = {};\r\n                    newEvent[k] = undefined; // this is how you trigger deletion with object -= action\r\n                    view.events = newEvent;\r\n                }}/>\r\n            </CommandBar>}\r\n\r\n            /* jsxLabel={<button className={'btn btn-danger my-auto ms-auto'} onClick={() => {\r\n                let newEvent: GObject = {};\r\n                newEvent[k] = undefined; // this is how you trigger deletion with object -= action\r\n                view.events = newEvent;\r\n            }}>\r\n                <i className={'p-1 bi bi-trash3-fill'} />\r\n            </button>}*/\r\n\r\n\r\n            getter={() => val}\r\n            setter={(js) => {\r\n                let newEvent: GObject = {};\r\n                newEvent[k] = js;\r\n                view.events = newEvent;\r\n            }}\r\n        /></>})}\r\n        <div className={'p-4'}></div>\r\n    </section>);\r\n}\r\n\r\ninterface OwnProps {viewID: Pointer<DViewElement, 1, 1, LViewElement>, readonly: boolean}\r\ninterface StateProps {view: LViewElement}\r\ninterface DispatchProps { }\r\ntype AllProps = OwnProps & StateProps & DispatchProps;\r\n\r\n\r\nfunction mapStateToProps(state: DState, ownProps: OwnProps): StateProps {\r\n    const view = LViewElement.fromPointer(ownProps.viewID);\r\n    return {view};\r\n}\r\n\r\nfunction mapDispatchToProps(dispatch: Dispatch<any>): DispatchProps {\r\n    const ret: DispatchProps = {};\r\n    return ret;\r\n}\r\n\r\n\r\nexport const ViewEventsConnected = connect<StateProps, DispatchProps, OwnProps, DState>(\r\n    mapStateToProps,\r\n    mapDispatchToProps\r\n)(ViewEventsComponent);\r\n\r\nexport const ViewEvents = (props: OwnProps, children: (string | React.Component)[] = []): ReactElement => {\r\n    return <ViewEventsConnected {...{...props, children}} />;\r\n}\r\nexport default ViewEvents;\r\n","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\components\\editors\\views\\data\\InfoData.tsx",["1872","1873"],"/* Apply to */\r\n\r\nimport React, {Dispatch} from 'react';\r\nimport {\r\n    DState,\r\n    DViewElement,\r\n    DViewPoint,\r\n    Edges,\r\n    Fields,\r\n    GraphElements,\r\n    Graphs,\r\n    Input,\r\n    LPointerTargetable,\r\n    LViewElement,\r\n    LViewPoint, MultiSelect,\r\n    Pointer,\r\n    Select,\r\n    Vertexes\r\n} from '../../../../joiner';\r\nimport {JsEditor, OclEditor} from \"../../languages\";\r\nimport {FakeStateProps} from \"../../../../joiner/types\";\r\nimport {connect} from \"react-redux\";\r\nimport \"./viewapplyto.scss\";\r\nimport \"./viewoptions.scss\"\r\n\r\n\r\nfunction InfoDataComponent(props: AllProps) {\r\n    const view = props.view;\r\n    const viewpoints = props.viewpoints;\r\n    let readOnly = props.readonly;\r\n    let vp = view.viewpoint;\r\n    let vpid = vp?.id;\r\n    let dallVP: DViewPoint[] = viewpoints.map(v=>v.__raw); //Selectors.getAll(DViewPoint, undefined, undefined, true, false);\r\n    // readOnly = false;\r\n\r\n    const objectTypes = ['', 'DModel', 'DPackage', 'DEnumerator', 'DEnumLiteral', 'DClass', 'DAttribute', 'DReference', 'DOperation', 'DParameter', 'DObject', 'DValue', 'DStructuralFeature'];\r\n    const classesOptionsJSX = <optgroup label={'Object type'}>\r\n            {objectTypes.map((o)=><option key={o} value={o}>{o ? o.substring(1) : 'anything'}</option>)}\r\n    </optgroup>;\r\n    const classesOptions = [{label:'apply to', options: objectTypes.map(o=>({value:o, label:o ? o.substring(1) : 'anything'}))}];\r\n\r\n    let isVP: boolean = view.className === DViewPoint.cname;\r\n    let isV: boolean = !isVP;\r\n\r\n    return(<section className={'page-root properties-tab'}>\r\n        <h1 className={'view'}>View: {view.name}</h1>\r\n        <Input data={view} field={'name'} label={'Name:'} readonly={readOnly}/>\r\n        <Input data={view} field={'isExclusiveView'} label={'Is Exclusive:'} type={\"checkbox\"} readonly={readOnly}\r\n               //setter={(val) => { view.isExclusiveView = !val}}\r\n               //getter={(data) => !(data as LViewElement).isExclusiveView as any\r\n        />\r\n        {isV && <>\r\n            <Input data={view} field={'explicitApplicationPriority'} label={'Priority:'} type={'number'} readonly={readOnly}\r\n               getter={(data: LViewElement)=>{ let v = data.__raw.explicitApplicationPriority; return v === undefined ? v : ''+v; }}\r\n               setter={(v)=>{ view.explicitApplicationPriority = (v ? +v as number : undefined as any); }}\r\n               placeholder={'automatic: ' + view.explicitApplicationPriority}\r\n               key={''+view.explicitApplicationPriority/*just to force reupdate if placeholder changes*/}\r\n        />\r\n            <Select data={view} field={'forceNodeType'} label={'Preferred appearance:'} readonly={readOnly} options={\r\n                <>\r\n                    <option value={'unset'} key={-1}>Automatic by model type (package, object, feature...)</option>\r\n                    <optgroup label={'Graph'} key={0}>{\r\n                        Object.keys(Graphs).map((key: string) => <option value={key} key={key}>{GraphElements[key].cname}</option>)\r\n                    }</optgroup>\r\n                    <optgroup label={'Edge'} key={1}>{\r\n                        Object.keys(Edges).map((key: string) => <option value={key} key={key}>{GraphElements[key].cname}</option>)\r\n                    }</optgroup>\r\n                    <optgroup label={'Field'} key={3}>{\r\n                        Object.keys(Fields).map((key: string) => <option value={key} key={key}>{GraphElements[key].cname}</option>)\r\n                    }</optgroup>\r\n                    <optgroup label={'Vertex'} key={2}>{\r\n                        Object.keys(Vertexes).map((key: string) => <option value={key} key={key}>{GraphElements[key].cname}</option>)\r\n                    }</optgroup>\r\n                </>\r\n            } setter={(val, data, key) => { view.forceNodeType = val === 'unset' ? undefined : val; }}\r\n                    getter={(data, key) => { return data[key] || 'unset_'; }} />\r\n\r\n            <Select data={view} field={'appliableToClasses'} label={'Appliable to:'} readonly={readOnly} isMultiSelect={true} options={classesOptions as any} />\r\n            {/*<Select data={view} field={'appliableToClasses'} label={'Appliable to:'} readonly={readOnly} options={classesOptions} />*/}\r\n\r\n            <Select readonly={readOnly} data={view} field={'father'} label={\"Viewpoint:\"} getter={()=> vpid}>\r\n                {dallVP.map((viewpoint) => (\r\n                    <option key={viewpoint.id} value={viewpoint.id}>{viewpoint.name}</option>\r\n                ))}\r\n            </Select>\r\n            <Select readonly={readOnly} data={view} field={'father'} label={\"Parent view:\"}>\r\n                {view.allPossibleParentViews.filter(v=>v.viewpoint?.id === vpid).map((view) => (\r\n                    <option key={view.id} value={view.id}>{view.name}</option>\r\n                ))}\r\n            </Select>\r\n            <OclEditor viewID={view.id} readonly={readOnly} />\r\n            <JsEditor\r\n                data={view} field={'jsCondition'}\r\n                placeHolder={'/* Last line must return a boolean */'}\r\n            />\r\n        </>}\r\n    </section>);\r\n}\r\n\r\ninterface OwnProps {\r\n    viewID: Pointer<DViewElement>;\r\n    viewpointsID: Pointer<DViewPoint>[];\r\n    readonly: boolean;\r\n}\r\n\r\ninterface StateProps {\r\n    view: LViewElement;\r\n    viewpoints: LViewPoint[];\r\n}\r\n\r\ninterface DispatchProps {}\r\ntype AllProps = OwnProps & StateProps & DispatchProps;\r\n\r\nfunction mapStateToProps(state: DState, ownProps: OwnProps): StateProps {\r\n    const ret: StateProps = {} as FakeStateProps;\r\n    ret.view = LPointerTargetable.fromPointer(ownProps.viewID);\r\n    ret.viewpoints = LPointerTargetable.fromPointer(ownProps.viewpointsID);\r\n    return ret;\r\n}\r\n\r\nfunction mapDispatchToProps(dispatch: Dispatch<any>): DispatchProps {\r\n    const ret: DispatchProps = {};\r\n    return ret;\r\n}\r\n\r\nexport const InfoData = connect<StateProps, DispatchProps, OwnProps, DState>(\r\n    mapStateToProps,\r\n    mapDispatchToProps\r\n)(InfoDataComponent);\r\n\r\nexport default InfoData;\r\n","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\components\\editors\\views\\data\\GenericNodeData.tsx",[],"C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\components\\editors\\views\\data\\ComponentsTab.tsx",[],"C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\components\\editors\\views\\data\\PermissionViewpointTab.tsx",[],"C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\components\\editors\\views\\data\\PermissionViewTab.tsx",[],"C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\components\\editors\\views\\data\\PaletteData.tsx",["1874","1875","1876","1877","1878","1879","1880","1881"],"/* Viewpoints > Style */\r\n\r\nimport React, {Dispatch, ReactElement, ReactNode, Ref, RefObject, SyntheticEvent, useState, useRef, useEffect} from 'react';\r\nimport {connect} from \"react-redux\";\r\nimport {useStateIfMounted} from \"use-state-if-mounted\";\r\nimport tinycolor, {Instance} from \"tinycolor2\";\r\nimport Editor from \"@monaco-editor/react\";\r\nimport DropDownButton from \"smart-webcomponents-react/dropdownbutton\";\r\nimport 'smart-webcomponents-react/source/styles/smart.default.css';\r\nimport type {Dictionary, GObject, Pointer,} from '../../../../joiner';\r\nimport {DState, DViewElement, EdgeHead, Input, Keystrokes, Log, LViewElement, U,} from '../../../../joiner';\r\nimport type {\r\n    NumberControl,\r\n    PaletteControl,\r\n    PaletteType,\r\n    PathControl,\r\n    StringControl\r\n} from '../../../../view/viewElement/view';\r\nimport {CSS_Units} from '../../../../view/viewElement/view';\r\nimport {Color} from '../../../forEndUser/Color';\r\n\r\nimport {Btn, CommandBar} from '../../../commandbar/CommandBar';\r\nimport {HRule} from '../../../widgets/Widgets';\r\n\r\n\r\nfunction makeNumericInput(prefix: string, number: NumberControl,\r\n                          setNumber: (e: React.FocusEvent<HTMLInputElement>, prefix: string) => void,\r\n                          setText: (e: React.FocusEvent<HTMLInputElement>, prefix: string) => void, readOnly: boolean) {\r\n    let min: number | undefined;\r\n    let max: number | undefined;\r\n    let step: number | undefined = undefined;\r\n    switch (number.unit) {\r\n        case '':\r\n        case 'px': min = 0; max = 300; break;\r\n        case 'pt': break; // 1pt = 1.33 px; 1px = 0.75pt\r\n        case 'cm':\r\n        case 'mm': min = 0; max = 200; break; // 1mm = 3.7px\r\n        case 'ch':\r\n        case 'ex':\r\n        case 'em':\r\n        case 'rem':\r\n        case 'in': // 1in = 96px\r\n        case 'pc': // 2px = 0.125 picas; 18.75pc = 300px\r\n        case 'fr': min=0; max=20; step = 0.5; break;\r\n        case \"%\": case \"vh\": case \"vw\": case \"vmax\": case \"vmin\":\r\n            min = 0;\r\n            max = 100;\r\n            break;\r\n    }\r\n    let roundedValue0 = Math.round(((number.value || 0) - (typeof step === \"number\" ? number.value % step : number.value % 0.1))*10000)/10000; // % works on decimals right.\r\n    let roundedValue = typeof step === \"number\" ? Math.round(((number.value || 0)  * (1/step))) * step : Math.round(number.value*100)/100; // % works on decimals right.\r\n    return <>\r\n        <input className={\"value\"} placeholder={\"value\"} type={\"range\"} disabled={readOnly}\r\n            key={\"s\"+number.value} defaultValue={number.value}\r\n            min={min}\r\n            max={max}\r\n            step={\"any\"}\r\n            onBlur={e => {setNumber(e as any, prefix)}}\r\n            onMouseUp={e => { setNumber(e as any, prefix); }} />\r\n        <input className={\"spinner\"} placeholder={\"value\"} type={\"number\"} disabled={readOnly}\r\n            key={roundedValue} defaultValue={roundedValue} data-dv={roundedValue} data-dv2={number.value}\r\n            step={step}\r\n            onBlur={e => {setNumber(e as any, prefix)}}\r\n            onKeyDown={e => {\r\n               if (e.key === Keystrokes.enter) setNumber(e as any, prefix);\r\n               if (e.key === Keystrokes.escape) (e.target as any).value = '' + number.value; }} />\r\n    </>\r\n}\r\n\r\n\r\n\r\n// delete button <button className=\"btn btn-danger ms-1\"><i className=\"p-1 bi bi-trash3-fill\"/></button>\r\nfunction PaletteDataComponent(props: AllProps) {\r\n    const view = props.view;\r\n    const readOnly = props.readonly;\r\n    let palette: Readonly<PaletteType> = {...view.palette};\r\n    let tmp: PaletteType = undefined as any;\r\n    const [css, setCss] = useStateIfMounted(view.css);\r\n\r\n    const [expand, setExpand] = useStateIfMounted(false);\r\n\r\n    const change = (value: string|undefined) => { if(value !== undefined) setCss(value); } // save in local state for frequent changes.\r\n    const blur = () => view.css = css; // confirm in redux state for final state\r\n\r\n    /* *** alfonso *** */\r\n\r\n\r\n    function useClickOutside(ref: any, onClickOutside: any) {\r\n        useEffect(() => {\r\n            function handleClickOutside(event: Event) {\r\n                if (ref.current && !ref.current.contains(event.target)) {\r\n                    onClickOutside();\r\n                }\r\n            }\r\n\r\n          // Bind\r\n\r\n          // @ts-ignore\r\n            document.addEventListener(\"mousedown\", handleClickOutside);\r\n          return () => {\r\n            // dispose\r\n            // @ts-ignore\r\n            document.removeEventListener(\"mousedown\", handleClickOutside);\r\n          };\r\n        }, [ref, onClickOutside]);\r\n    }\r\n\r\n    const AddPalette = () => {\r\n        const [open,setOpen] = useState(false);\r\n        const menuRef = useRef(null);\r\n\r\n        useClickOutside(menuRef, () => {\r\n            setOpen(false);\r\n        });\r\n\r\n\r\n        return (<>\r\n            {/* {open ?\r\n                <div className='palette-buttons'>\r\n                    <button onClick={()=>addControl('palette')} className='btn btn-success my-btn btn-color'>Add palette</button>\r\n                    <button onClick={()=> addControl('number')} className='btn btn-success my-btn btn-number'>Add number</button>\r\n                    <button onClick={()=>addControl('text')} className='btn btn-success my-btn btn-textual'>Add text</button>\r\n                    <button onClick={()=>addControl('path')}className='btn btn-success my-btn btn-path'>Add path</button>\r\n                </div>\r\n            :\r\n                <button onClick={() => setOpen(!open)} className='btn btn-success my-btn'>Add new</button>\r\n            }*/}\r\n\r\n            {!open ?\r\n                <div className={'add-palette-item'} onClick={() => {setOpen(true)}}>\r\n                    <i style={{color: 'white'}} className=\"bi bi-plus\"></i>\r\n                    <span>Add new</span>\r\n                </div>\r\n                :\r\n                <>\r\n                    <div className={'add-palette-item active'} onClick={() => {setOpen(false)}}>\r\n                        <i style={{color: 'white'}} className=\"bi bi-plus\"></i>\r\n                    </div>\r\n                    <button onClick={()=>addControl('palette')} className='btn btn-success my-btn btn-color'>Palette</button>\r\n                    <button onClick={()=> addControl('number')} className='btn btn-success my-btn btn-number'>Number</button>\r\n                    <button onClick={()=>addControl('text')} className='btn btn-success my-btn btn-textual'>Text</button>\r\n                    <button onClick={()=>addControl('path')}className='btn btn-success my-btn btn-path'>Path</button>\r\n\r\n                </>\r\n            }\r\n\r\n        </>);\r\n    };\r\n\r\n    /* *** */\r\n\r\n\r\n\r\n\r\n\r\n\r\n    const addControl = (type: 'palette' | 'number' | 'text' | 'path') => {\r\n        if (readOnly) return;\r\n        let i: number;\r\n        let prefix0: string;//= 'palette_' + i + '-';\r\n        switch (type){\r\n            default: Log.exDevv(\"unexpected case in addControl:\" + type); return;\r\n            case 'path':\r\n                i = Object.values(palette).filter( o => (o as PathControl).type === \"path\").length + 1;\r\n                prefix0 = 'path_';\r\n                break;\r\n            case 'text':\r\n                i = Object.values(palette).filter( o => (o as StringControl).type === \"text\").length + 1;\r\n                prefix0 = 'text_';\r\n                break;\r\n            case 'number':\r\n                i = Object.values(palette).filter( o => (o as NumberControl).type === \"number\").length + 1;\r\n                prefix0 = 'numeric_';\r\n                break;\r\n            case 'palette':\r\n                i = Object.values(palette).filter( o => Array.isArray(o as any)).length + 1;\r\n                prefix0 = 'palette_';\r\n                break;\r\n        }\r\n        let prefix: string;\r\n        while (true){\r\n            prefix = prefix0 + i++;\r\n            if (prefix in palette) continue;\r\n            break;\r\n        }\r\n        switch (type){\r\n            default: Log.exDevv(\"unexpected case in addControl:\" + type); return;\r\n            case 'path':\r\n                const agglabel = \"◇ Aggregation / Composition\";\r\n                const extendlabel = \"△ \"+EdgeHead.extend;\r\n                const asslabel = \"Λ \"+EdgeHead.reference;\r\n                let headdict: Dictionary<string, string> = {\r\n                    [asslabel]: 'M 0 0   L x y/2   L 0 y',\r\n                    [extendlabel]: 'M 0 0   L x y/2   L 0 y   Z',\r\n                    [agglabel]: 'M 0 y/2   L x/2 0   L x y/2   L x/2 y   Z',\r\n                };\r\n                let predefinedPaths: {k:string, v:string}[] = Object.entries(headdict).map((e)=>({k:e[0], v:e[1]}));\r\n\r\n                tmp = {...palette};\r\n                tmp[prefix] = {type: 'path', value: '', x:'edgeHeadSize.x', y:'edgeHeadSize.y', options: predefinedPaths};\r\n                break;\r\n            case 'text':\r\n                tmp = {...palette};\r\n                tmp[prefix] = {type: 'text', value: ''};\r\n                break;\r\n            case 'number':\r\n                tmp = {...palette};\r\n                tmp[prefix] = {type: 'number', value: 0, unit: 'px'};\r\n                break;\r\n            case 'palette':\r\n                tmp = {...palette};\r\n                tmp[prefix] = {type:'color', value:[]};\r\n                break;\r\n        }\r\n        view.palette = palette = tmp;\r\n    }\r\n\r\n\r\n\r\n\r\n    const setGeneric = (e: any, prefix: string, key: string) => {\r\n        const val: string = e.target.value;\r\n        if (readOnly || (palette[prefix] as any)[key] === val) return;\r\n        let tmp: Dictionary<string, StringControl> = {...palette} as any;\r\n        (tmp[prefix] as any)[key] = val;\r\n        view.palette = palette = tmp; }\r\n    const setText = (e: any, prefix: string) => {\r\n        const val: string = e.target.value;\r\n        if (readOnly || (palette[prefix] as StringControl).value === val) return;\r\n        let tmp: Dictionary<string, StringControl> = {...palette} as any;\r\n        tmp[prefix].value = val;\r\n        view.palette = palette = tmp; }\r\n    const setNumber = (e: any, prefix: string) => {\r\n        const val: number = +e.target.value || 0;\r\n        if (readOnly || (palette[prefix] as NumberControl).value === val) return;\r\n        let tmp: Dictionary<string, NumberControl> = {...palette} as any;\r\n        tmp[prefix].value = val;\r\n        view.palette = palette = tmp; }\r\n    const setUnit = (e: any, prefix: string) => {\r\n        const val: string = e.target.value === undefined ? 'px' : e.target.value;\r\n        if (readOnly || val === (palette[prefix] as NumberControl).unit) return;\r\n        let tmp: Dictionary<string, NumberControl> = {...palette} as any;\r\n        tmp[prefix].unit = val;\r\n        view.palette = palette = tmp; }\r\n    const changePrefix = (oldPrefix: string, newPrefix: string) => {\r\n        // @ts-ignore\r\n        newPrefix = newPrefix.replaceAll(/[^\\w\\-]/g,'-'); // /^[^a-zA-Z0-9_\\-]*$/, '-');\r\n        if (readOnly || palette[newPrefix]) return; // refuse to overwrite existing palette name (2 different palettes with same name)\r\n        tmp = {...palette};\r\n        tmp[newPrefix] = palette[oldPrefix];\r\n        delete tmp[oldPrefix];\r\n        view.palette = palette = tmp;\r\n    }\r\n    const removeControl = (prefix: string) => {\r\n        if (readOnly || !palette[prefix]) return;\r\n        tmp = {...palette};\r\n        delete tmp[prefix];\r\n        view.palette = palette = tmp;\r\n    }\r\n\r\n    const addColor = (prefix: string, colors: Instance[] | Instance, index: number = -1, skipFirst: boolean = true) => {\r\n        if (readOnly) return;\r\n        if (!Array.isArray(colors)) {\r\n            colors = [colors as Instance];\r\n            skipFirst = false;\r\n        }\r\n        let tmp: Dictionary<string, PaletteControl> = {...palette} as GObject;\r\n        let lastAdded: tinycolor.ColorFormats.RGBA = undefined as any;\r\n        for (let i = colors.length-1; i >= (skipFirst ? 1 : 0); i--) {\r\n            let color: Instance = colors[i];\r\n            let rgba = color.toRgb();\r\n            console.log(\"addingColor:\", {rgba, lastAdded, color});\r\n            if (rgba === lastAdded) continue;\r\n            lastAdded = rgba;\r\n            if (!tmp[prefix]) tmp[prefix] = {type:'color', value:[]};\r\n            else tmp[prefix] = {...tmp[prefix]};\r\n            tmp[prefix].value = [...tmp[prefix].value];\r\n            if (index >= 0) tmp[prefix].value.splice(index + 1, 0, rgba);\r\n            else tmp[prefix].value.push(rgba);\r\n        }\r\n        view.palette = palette = tmp;\r\n    }\r\n\r\n    const setColor = (prefix: string, index: number, hex?: string, alpha?: number) => {\r\n        let tmp: Dictionary<string, PaletteControl> = {...palette} as any;\r\n        if (readOnly || !tmp[prefix]) tmp[prefix] = {type:'color', value:[]};\r\n        else tmp[prefix] = {...tmp[prefix]};\r\n        let oldColor = tmp[prefix].value[index];\r\n        if (hex) {\r\n            let color = tinycolor(hex);\r\n            if (alpha !== undefined) color.setAlpha(alpha);\r\n            let rgba = color.toRgb();\r\n            if (oldColor && oldColor.a !== undefined) rgba.a = oldColor.a;\r\n            tmp[prefix].value[index] = oldColor = rgba;\r\n            view.palette = palette = tmp;\r\n        }\r\n        if (alpha !== undefined) tmp[prefix].value[index] = {...oldColor, a:alpha};\r\n    }\r\n    const transparencyColor = (prefix: string, index: number, color: tinycolor.Instance, alpha: number) => {\r\n        if (readOnly || !palette[prefix]) return;\r\n        let tmp: Dictionary<string, PaletteControl> = {...palette} as any;\r\n        if (!alpha && alpha !== 0) alpha = 1;\r\n        tmp[prefix] = {...tmp[prefix]};\r\n        tmp[prefix].value = [...tmp[prefix].value];\r\n        tmp[prefix].value[index] = {...tmp[prefix].value[index]};\r\n        tmp[prefix].value[index].a = alpha;\r\n        color.setAlpha(alpha);\r\n        console.log(\"set transparency\", {color, tinycolor, oldcolor: tmp[prefix].value[index]});\r\n        view.palette = palette = tmp;\r\n    }\r\n    const removeColor = (prefix: string, index: number) => {\r\n        if (readOnly || !palette[prefix]) return;\r\n\r\n        let tmp: Dictionary<string, PaletteControl> = {...palette} as any;\r\n        tmp[prefix].value = [...tmp[prefix].value];\r\n        tmp[prefix].value = tmp[prefix].value.filter((c, i) => i !== index);\r\n        view.palette = palette = tmp;\r\n    }\r\n\r\n    const cssIsGlobal = view.cssIsGlobal;\r\n    let a: DropDownButton;\r\n    let dropDownButton: RefObject<DropDownButton> = {current: null};\r\n    function addcss(color: Instance): GObject {\r\n        let ret: GObject = {};\r\n        ret.background = color.toRgbString();\r\n        // ret.opacity = color.getAlpha();\r\n        return ret;\r\n    }\r\n    function invert(color: Instance, transformGrays: number = 0.2): string {\r\n        transformGrays = transformGrays * 128;\r\n        let {r, g, b, a} = color.toRgb();\r\n        r = Math.abs(r-128) <= transformGrays ? (r >= 128 ? 0 : 255) : 255 - r;\r\n        g = Math.abs(g-128) <= transformGrays ? (g >= 128 ? 0 : 255) : 255 - g;\r\n        b = Math.abs(b-128) <= transformGrays ? (b >= 128 ? 0 : 255) : 255 - b;\r\n        if (a || a === 0) a = 255 - a;\r\n        return (tinycolor({r, g, b, a})).toRgbString();\r\n    }\r\n    function style(c: Instance): GObject{\r\n        return {backgroundColor: c.toRgbString(), color:invert(c)};\r\n    }\r\n\r\n    let palettes = U.paletteSplit(palette);\r\n    function palettewrap(prefix: string, node: ReactNode): ReactNode{\r\n        return (\r\n            <div className=\"palette-row-container\">\r\n                {/* <button className=\"btn btn-danger me-1\" onClick={()=>removeControl(prefix)} disabled={readOnly}><i className=\"p-1 bi bi-trash3-fill\"/></button>*/}\r\n\r\n                <input className={\"prefix\"}\r\n                    style={{maxHeight: 'var(--input-height)', borderRadius: 'var(--radius)'}}\r\n                    placeholder={\"variable name\"}\r\n                    defaultValue={prefix}\r\n                    onBlur={(e: any)=> changePrefix(prefix, e.target.value)}\r\n                    disabled={readOnly} />\r\n                {node}\r\n            </div>)\r\n    }\r\n    const vcss = view.css;\r\n\r\n    let colors = Object.keys(palettes.color).sort();\r\n    const lines = (Math.round(vcss.split(/\\r|\\r\\n|\\n/).length*1.8) < 5 ? 10 : Math.round(vcss.split(/\\r|\\r\\n|\\n/).length*1.8));\r\n\r\n    return(<section className={'p-3 style-tab'}>\r\n        <h1 className={'view'}>View: {props.view.name}</h1>\r\n        <div className={\"controls\"} style={{position:'relative', zIndex:2}}>\r\n\r\n            {colors.map((entry, index, entries)=>{\r\n                let prefix = entry;\r\n                let paletteobj: PaletteControl = palettes.color[prefix] as PaletteControl;\r\n                let colors: Instance[] = paletteobj.value.map(v=> tinycolor(v));\r\n                let suggestions = [tinycolor('#ffaaaa')]; // todo: compute according to current row \"colors\"\r\n                return palettewrap(prefix, <>\r\n                    <div className=\"palette-row\">\r\n\r\n                        <div className=\"color-container\" style={{maxHeight: 'var(--input-height)', borderRadius: 'var(--radius)'}}>{\r\n                            colors.map((color, i) => <Color key={prefix+i} readonly={readOnly}\r\n                                                            data={view} field={'palette'} canDelete={!readOnly}\r\n                                                            getter={()=>colors[i].toHexString()} setter={(newVal) => { setColor(prefix, i, newVal) }}\r\n                                                            style ={{background: 'white'}}\r\n                                                            inputStyle ={{opacity: color.getAlpha()}}\r\n                                                            childrenn={\r\n                                                                <div className={\"content suggestions\"} tabIndex={-1} style={{backgroundColor: \"inherit\"}} onClick={(e) => {e.preventDefault(); e.stopPropagation();}}>\r\n                                                                    {(()=>{ return <>\r\n                                                                        <h6 title={\"Alter current color transparency\"}>Opacity</h6>\r\n\r\n                                                                        <input style={{width: \"auto\", marginLeft:\"1em\", marginRight:\"1em\"}}\r\n                                                                            type={\"range\"} min={0} max={1} step={\"any\"}\r\n                                                                            value={color.getAlpha()}\r\n                                                                            onChange={(e: any)=>{ transparencyColor(prefix, i, color, +e.target.value) }} />\r\n\r\n                                                                        {/* Add all colors */}\r\n                                                                        <h6 title={\"Add all the colors\"}>\r\n                                                                            <CommandBar style={{float: 'left', paddingRight: '8px'}}>\r\n                                                                                <Btn icon={'add'} size={'x-small'}  action={()=>addColor(prefix, color.analogous(7, 30/1.5), i)} theme={'dark'} tip={'Add all the colors'}/>\r\n                                                                            </CommandBar>\r\n                                                                            <span>Analogous</span>\r\n                                                                        </h6>\r\n\r\n                                                                        <div className={\"roww\"}>\r\n                                                                            {color.analogous(7, 30/1.5).map((c,ii) => ii===0?undefined:\r\n                                                                                <button style={style(c)}\r\n                                                                                    onClick={(e)=>{addColor(prefix, c, i)}}\r\n                                                                                    className=\"btn color-suggestion\">\r\n                                                                                        <i style={style(c)} className=\"bi bi-plus-lg\"></i>\r\n                                                                                </button>\r\n                                                                            )}\r\n                                                                        </div>{/*\r\n                                    <h6 onClick={()=>addColor(prefix, color.monochromatic(7), i)} title={\"Add all the colors\"}>Monochromatic</h6>\r\n                                    <div className={\"roww\"}>\r\n                                        {color.monochromatic(7).map((c,ii) => ii===0?undefined: <button style={style(c)}\r\n                                                                                                        onClick={(e)=>{addColor(prefix, c, i)}} className=\"btn color-suggestion\">+</button>)}\r\n                                    </div>{/*[6/12, 5/12, 4/12, 3/12, 2/12, 1/12]*/}\r\n\r\n                                                                        {/* Add all colors */}\r\n                                                                        <h6 title={\"Add all the colors\"}>\r\n                                                                            <CommandBar style={{\r\n                                                                                float: 'left',\r\n                                                                                paddingRight: '8px'\r\n                                                                            }}>\r\n                                                                                <Btn icon={'add'} size={'x-small'}\r\n                                                                                     tip={'Add all the colors'}\r\n                                                                                     theme={'dark'}\r\n                                                                                     action={() => addColor(prefix, [1 / 12, 2 / 12, 3 / 12, 4 / 12, 5 / 12, 6 / 12].map(n => color.clone().lighten(n * 100)), i, false)}/>\r\n                                                                            </CommandBar>\r\n                                                                            <span>Lighten</span>\r\n\r\n                                                                        </h6>\r\n\r\n                                                                        <div className={\"roww\"}>\r\n                                                                            {[1/12, 2/12, 3/12, 4/12, 5/12, 6/12].map(n=>color.clone().lighten(n*100))\r\n                                                                                .map((c,ii) => <button style={style(c)} className=\"btn color-suggestion\"\r\n                                                                                                       onClick={(e)=>{addColor(prefix, c, i)}}><i style={style(c)} className=\"bi bi-plus-lg\"></i></button>)}\r\n                                                                        </div>\r\n\r\n                                                                        {/* Add all colors */}\r\n                                                                        <h6 title={\"Add all the colors\"}>\r\n                                                                            <CommandBar style={{\r\n                                                                                float: 'left',\r\n                                                                                paddingRight: '8px'\r\n                                                                            }}>\r\n                                                                                <Btn icon={'add'} theme={'dark'}\r\n                                                                                     tip={'Add all the colors'}\r\n                                                                                     size={'x-small'}\r\n                                                                                     action={() => addColor(prefix, [6 / 12, 5 / 12, 4 / 12, 3 / 12, 2 / 12, 1 / 12].map(n => color.clone().darken(n * 100)), i, false)}/>\r\n                                                                            </CommandBar>\r\n                                                                            <span>Darken</span>\r\n                                                                        </h6>\r\n\r\n                                                                        <div className={\"roww\"}>\r\n                                                                            {[6/12, 5/12, 4/12, 3/12, 2/12, 1/12].reverse().map(n=>color.clone().darken(n*100))\r\n                                                                                .map((c,ii) => <button style={style(c)} className=\"btn color-suggestion\"\r\n                                                                                                       onClick={(e)=>{addColor(prefix, c, i)}}><i style={style(c)} className=\"bi bi-plus-lg\"></i></button>)}\r\n                                                                        </div>\r\n\r\n                                                                        {/* Add all colors */}\r\n                                                                        <h6 title={\"Add all the colors\"}>\r\n                                                                            <CommandBar style={{\r\n                                                                                float: 'left',\r\n                                                                                paddingRight: '8px'\r\n                                                                            }}>\r\n                                                                                <Btn icon={'add'}\r\n                                                                                     tip={'Add all the colors'}\r\n                                                                                     theme={'dark'} size={'x-small'}\r\n                                                                                     action={() => addColor(prefix, [color.complement(), tinycolor(invert(color))], i, false)}/>\r\n                                                                            </CommandBar>\r\n                                                                            <span>Complementary / Opposite</span>\r\n                                                                        </h6>\r\n\r\n                                                                        <div className={\"roww\"}>\r\n                                                                            <button style={style(color.complement())} className=\"btn color-suggestion\"\r\n                                                                                    onClick={(e)=>{addColor(prefix, color.complement(), i)}}><i style={style(color.complement())} className=\"bi bi-plus-lg\"></i></button>\r\n                                                                            <button style={style(color)} className=\"btn color-suggestion\"\r\n                                                                                    onClick={(e)=>{addColor(prefix, tinycolor(invert(color)), i)}}><i style={style(color)} className=\"bi bi-plus-lg\"></i></button>\r\n                                                                        </div>\r\n\r\n                                                                        {/* Add all colors */}\r\n                                                                        <h6 title={\"Add all the colors\"}>\r\n                                                                            <CommandBar style={{\r\n                                                                                float: 'left',\r\n                                                                                paddingRight: '8px'\r\n                                                                            }}>\r\n                                                                                <Btn icon={'add'}\r\n                                                                                     tip={'Add all the colors'}\r\n                                                                                     theme={'dark'} size={'x-small'}\r\n                                                                                     action={() => addColor(prefix, color.splitcomplement(), i)}/>\r\n                                                                            </CommandBar>\r\n                                                                            <span>Split Complementary</span>\r\n                                                                        </h6>\r\n\r\n                                                                        <div className={\"roww\"}>\r\n                                                                            {color.splitcomplement().map((c) => <button style={{...style(c)}} className=\"btn color-suggestion\"\r\n                                                                                                                        onClick={(e)=>{addColor(prefix, c, i)}}><i style={style(c)} className=\"bi bi-plus-lg\"></i></button>)}\r\n                                                                        </div>\r\n\r\n                                                                        <h6 title={\"Add all the colors\"}>\r\n                                                                            <CommandBar style={{\r\n                                                                                float: 'left',\r\n                                                                                paddingRight: '8px'\r\n                                                                            }}>\r\n                                                                                <Btn icon={'add'}\r\n                                                                                     tip={'Add all the colors'}\r\n                                                                                     theme={'dark'} size={'x-small'}\r\n                                                                                     action={() => addColor(prefix, color.triad(), i)}/>\r\n                                                                            </CommandBar>\r\n                                                                            <span>Triadic</span>\r\n                                                                        </h6>\r\n\r\n                                                                        <div className={\"roww\"}>\r\n                                                                            {color.triad().map ( (c) => <button style={{...style(c)}} className=\"btn color-suggestion\"\r\n                                                                                                                onClick={(e)=>{addColor(prefix, c, i)}}><i style={style(c)} className=\"bi bi-plus-lg\"></i></button>)}\r\n                                                                        </div>\r\n\r\n                                                                        {/* Add all colors */}\r\n                                                                        <h6 title={\"Add all the colors\"}>\r\n                                                                            <CommandBar style={{\r\n                                                                                float: 'left',\r\n                                                                                paddingRight: '8px'\r\n                                                                            }}>\r\n                                                                                <Btn icon={'add'}\r\n                                                                                     tip={'Add all the colors'}\r\n                                                                                     theme={'dark'} size={'x-small'}\r\n                                                                                     action={() => addColor(prefix, color.tetrad(), i)}/>\r\n                                                                            </CommandBar>\r\n                                                                            <span>Tetradic</span>\r\n                                                                        </h6>\r\n                                                                        <div className={\"roww\"}>\r\n                                                                            {color.tetrad().map ( (c) => <button style={{...style(c)}} className=\"btn color-suggestion\"\r\n                                                                                                                 onClick={(e)=>{addColor(prefix, c, i)}}><i style={style(c)} className=\"bi bi-plus-lg\"></i></button>)}\r\n                                                                        </div>\r\n                                                                    </>})()}\r\n\r\n\r\n                                                                    <button\r\n                                                                        className={'btn btn-danger content delete-color mt-2 jj-delete'}\r\n                                                                        onClick={()=>removeColor(prefix, i)}\r\n                                                                        disabled={readOnly}\r\n                                                                    >\r\n                                                                        <i className=\"bi p-1 bi-trash-fill\"/> Delete\r\n                                                                    </button>\r\n                                                                </div>\r\n                                                            }\r\n                            />)\r\n                        }\r\n                        </div>\r\n                        <div className=\"suggestion-container\">{\r\n                            suggestions.map((c, i) => <label className=\"p-1\">\r\n\r\n                                {/* Palette */}\r\n                                <CommandBar style={{float: 'right'}}>\r\n                                    <Btn icon={'add'} tip={'Add color to palette'} action={() => addColor(prefix, c)} />\r\n                                    <Btn icon={'delete'} tip={'Remove color from palette'} action={() => {\r\n                                        if (Array.isArray(palette[prefix].value) && (palette[prefix].value as any).length) {\r\n                                            removeColor(prefix, i)\r\n                                        } else {\r\n                                            removeControl(prefix);\r\n                                        }\r\n                                    }}\r\n                                    />\r\n                                </CommandBar>\r\n\r\n                                {/* <button className=\"btn color-suggestion\" style={style(c)} onClick={()=>{addColor(prefix, c)}} disabled={readOnly}>+</button>*/}\r\n                            </label>)\r\n                        }</div>\r\n                    </div>\r\n                </>); })\r\n            }\r\n            {Object.entries(palettes.path).map((entry, index, entries)=>{\r\n                    let prefix = entry[0];\r\n                    let path: PathControl = entry[1] as any;\r\n                    return palettewrap(prefix,\r\n                        <div className=\"palette-row path\" title={\"todo: proper tooltip.\\nedgeHeadSize is in the \\\"Options\\\" tab and determines the position of the head.\\nBasic math operators are allowed, but the minus and plus must have spaces around them or they will be traated as unary operators.\\nx and y are variables local to this path used to scale his shape.\"}>\r\n                            <div className={\"value hoverable\"} >\r\n                                <div className={\"d-flex w-100\"}>\r\n                                    <input className={\"value w-100 my-auto\"} placeholder={\"svg path [d]\"} defaultValue={path.value} key={path.value} onBlur={e => {setText(e as any, prefix)}} disabled={readOnly}\r\n                                           onKeyDown={e => {\r\n                                               if (e.key === Keystrokes.enter) setText(e as any, prefix);\r\n                                               if (e.key === Keystrokes.escape) (e.target as any).value = path.value; }}\r\n                                    />\r\n                                </div>\r\n                                <div className={\"content d-flex w-100\"} style={{position: 'relative', backgroundColor: 'whitesmoke'}}>\r\n                                    <input className={\"spacer w-100\"}/>\r\n                                    <label className={\"mx-auto\"}>x:&nbsp;<input className=\"x\" placeholder={\"x\"} defaultValue={path.x} disabled={readOnly} onChange={(e)=>setGeneric(e, prefix, \"x\")}/></label>\r\n                                    <label className={\"mx-auto\"}>y:&nbsp;<input className=\"y\" placeholder={\"y\"} defaultValue={path.y} disabled={readOnly} onChange={(e)=>setGeneric(e, prefix, \"y\")}/></label>\r\n                                </div>\r\n                            </div>\r\n                            <select className={'d-flex'} style={{width: '100px!important'}} value={path.value} disabled={readOnly} onChange={(e)=>setText(e as any, prefix)}>\r\n                                {[<option style={{fontStyle:'italic', color:'gray'}} value={\"\"}>Custom</option>, path.options.map((e)=>{\r\n                                let k = e.k;\r\n                                let v = e.v;\r\n                                return <option value={v}>{k}</option>\r\n                            })]}</select>\r\n\r\n                            {/* Path */}\r\n                            <CommandBar  style={{paddingRight: '4px', marginLeft: 'auto'}}>\r\n                                <Btn icon={'space'} />\r\n                                <Btn icon={\"delete\"} action={(e) => {removeControl(prefix)}} tip={'Remove path'}/>\r\n                            </CommandBar>\r\n\r\n                        </div>)\r\n                }\r\n            )}\r\n            {Object.entries(palettes.number).map((entry, index, entries)=>{\r\n                    let prefix = entry[0];\r\n                    let number: NumberControl = entry[1] as any;\r\n                    return palettewrap(prefix,\r\n                        <div className=\"palette-row numeric\">\r\n                            {makeNumericInput(prefix, number, setNumber, setText, readOnly)}\r\n                            <input className={\"unit\"} placeholder={\"unit\"} value={number.unit} pattern={CSS_Units.pattern} disabled={readOnly}\r\n                                   list={\"__jodel_CSS_units\"} onChange={e => {setUnit(e as any, prefix)}} />\r\n\r\n                            {/* Numeric */}\r\n                            <CommandBar  style={{paddingRight: '4px', marginLeft: 'auto'}}>\r\n                                <Btn icon={'space'} />\r\n                                <Btn icon={\"delete\"} action={(e) => {removeControl(prefix)}} tip={'Remove number'}/>\r\n                            </CommandBar>\r\n                        </div>)\r\n                }\r\n            )}\r\n            {Object.entries(palettes.text).map((entry, index, entries)=>{\r\n                    let prefix = entry[0];\r\n                    let string: StringControl = entry[1] as any;\r\n                    return palettewrap(prefix,\r\n                        <div className={\"palette-row textual\"}>\r\n                            <input className={\"value\"} placeholder={\"value\"} defaultValue={string.value} onBlur={e => {setText(e as any, prefix)}} disabled={readOnly}\r\n                                   onKeyDown={e => {\r\n                                       if (e.key === Keystrokes.enter) setText(e as any, prefix);\r\n                                       if (e.key === Keystrokes.escape) (e.target as any).value = string.value; }} />\r\n\r\n                            {/* Text */}\r\n                            <CommandBar  style={{paddingRight: '4px', marginLeft: 'auto'}}>\r\n                                <Btn icon={'space'} />\r\n                                <Btn icon={\"delete\"} action={(e) => {removeControl(prefix)}} tip={'Remove text'}/>\r\n                            </CommandBar>\r\n                        </div>)\r\n                }\r\n            )}\r\n        </div>\r\n\r\n\r\n        <AddPalette />\r\n\r\n\r\n        {/* <div className={\"w-100\"} style={{display: 'grid', gridTemplateColumns: 'repeat(10, 1fr)', position: 'relative', zIndex:1}}\r\n             onMouseEnter={(e)=>{ dropDownButton.current?.open()}}\r\n             onMouseLeave={(e)=>{ dropDownButton.current?.close()}}\r\n        >\r\n            <button className=\"btn btn-success\" style={{flexBasis:0, flexGrow:9, gridArea: '1 / 1 / 1 / 1', zIndex: 2, minWidth: 'calc(1000% - var(--smart-editor-addon-width))'}} onClick={()=>addControl('palette')}>+ Palette</button>\r\n            <DropDownButton ref={dropDownButton} style={{flexBasis:0, flexGrow:1, minWidth:0, gridArea: '1 / 1 / 1 / 11', zIndex:1, transform: 'scaleX(-1)'}}>\r\n                <div onClick={(e)=> dropDownButton.current?.close()} style={{transform: 'scaleX(-1)'}}>\r\n                    <button className={\"w-100 btn btn-outline-success\"} style={{height: 'var(--smart-editor-height)'}}\r\n                            onClick={()=>addControl('number')}>+ Number</button>\r\n                    <button className={\"w-100 btn btn-outline-success\"} style={{height: 'var(--smart-editor-height)'}}\r\n                            onClick={()=>addControl('text')}>+ Text</button>\r\n                    <button className={\"w-100 btn btn-outline-success\"} style={{height: 'var(--smart-editor-height)'}}\r\n                            onClick={()=>addControl('path')}>+ Path</button>\r\n                </div>\r\n            </DropDownButton>\r\n            </div>*/}\r\n\r\n        <HRule theme={'light'} style={{display: 'block', padding: '30px 0px!important'}}/>\r\n\r\n        <Input data={view} field={'cssIsGlobal'} type={\"checkbox\"}  jsxLabel={\r\n            <div style={{width:'100%', display:'block', float: 'left'}}>\r\n                {cssIsGlobal ? <b style={{color: 'inherit'}}>Global</b> : <b style={{color: 'inherit'}}>Local</b>}\r\n                {' CSS & LESS Editor '}\r\n                {cssIsGlobal ? '(Use with caution)' : ''}\r\n            </div>\r\n        } />\r\n\r\n        {/* <CommandBar style={{paddingTop: '10px', float: 'right'}}>\r\n            {expand ?\r\n                <Btn icon={'shrink'} action={(e) => {setExpand(false)}} tip={'Minimize editor'}/>\r\n                :\r\n                <Btn icon={'expand'} action={(e) => {setExpand(true)}} tip={'Enlarge editor'}/>\r\n            }\r\n        </CommandBar>*/}\r\n\r\n        {/* ****** */}\r\n\r\n        {/*<label className={'ms-1 mb-1'}>{view.cssIsGlobal ? 'Global' : 'Local'} CSS Editor</label>*/}\r\n        {vcss.indexOf('//') >= 0 && <b><span style={{color:'red'}}>Warning:</span> Inline comments // are not supported by our compiler.<br/>\r\n            Please replace them with /* block comments */</b>}\r\n\r\n            <div className={\"monaco-editor-wrapper\"} style={{\r\n                minHeight: '20px',\r\n                height:`${expand ? '30lvh' : '10lvh'}`,\r\n                transition: 'height 0.3s',\r\n                resize: 'vertical', overflow:'hidden',\r\n                display: 'flex',\r\n                flexDirection: 'column'\r\n            }}\r\n            onFocus={() => setExpand(true)}\r\n            onBlur={() => {setExpand(false);blur()}}>\r\n            <Editor className={'mx-1'}\r\n                    options={{fontSize: 12, scrollbar: {vertical: 'hidden', horizontalScrollbarSize: 5}, minimap: {enabled: false}, readOnly: readOnly}}\r\n                    defaultLanguage={'less'} value={vcss} onChange={change}/>\r\n        </div>\r\n        {false && <div className={\"debug\"}><div style={{whiteSpace:'pre'}}>{view.compiled_css}</div></div>}\r\n        {/*<textarea>\r\n            '[data-viewid=\"'+view.id+'\"]{\\n' +\r\n            Object.entries(palette).flatMap((entry, index, entries)=>{\r\n                let prefix = entry[0];\r\n                let colors = entry[1];\r\n                return colors.map((color, i)=> \"\\t--\" + prefix + i + \": \" + color + \";\\n\");\r\n            }).join('')+'\\n' + (cssISGlobal ? '}\\n' : '\\n') +\r\n            '/ *** custom css area *** /\\n' + view.css + (!cssISGlobal ? '}\\n' : '\\n')\r\n            view.css\r\n        </textarea>*/}\r\n        {\r\n            // todo: if row have only 1 color can be accessed both as palette prefix-1 or as palett prefix without number, so i can name colors.\r\n        }\r\n\r\n    </section>);\r\n}\r\n\r\ninterface OwnProps {viewID: Pointer<DViewElement, 1, 1, LViewElement>, readonly: boolean}\r\ninterface StateProps {view: LViewElement}\r\ninterface DispatchProps { }\r\ntype AllProps = OwnProps & StateProps & DispatchProps;\r\n\r\n\r\nfunction mapStateToProps(state: DState, ownProps: OwnProps): StateProps {\r\n    const view = LViewElement.fromPointer(ownProps.viewID);\r\n    return {view};\r\n}\r\n\r\nfunction mapDispatchToProps(dispatch: Dispatch<any>): DispatchProps {\r\n    const ret: DispatchProps = {};\r\n    return ret;\r\n}\r\n\r\n\r\nexport const PaletteDataConnected = connect<StateProps, DispatchProps, OwnProps, DState>(\r\n    mapStateToProps,\r\n    mapDispatchToProps\r\n)(PaletteDataComponent);\r\n\r\nexport const PaletteData = (props: OwnProps, children: (string | React.Component)[] = []): ReactElement => {\r\n    return <PaletteDataConnected {...{...props, children}} />;\r\n}\r\nexport default PaletteData;\r\n","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\components\\editors\\views\\data\\TemplateData.tsx",[],"C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\components\\tooltip\\MyTooltip.tsx",["1882","1883","1884","1885","1886"],"import React, {Dispatch, ReactElement} from 'react';\r\nimport {connect} from 'react-redux';\r\nimport {DState} from '../../joiner';\r\nimport {FakeStateProps} from '../../joiner/types';\r\nimport './mytooltip.scss';\r\n\r\n\r\ntype TooltipProps = {\r\n    text: string;\r\n}\r\n\r\nexport const MyTooltip = (props: TooltipProps) => {\r\n    const tooltip = props.text;\r\n\r\n    return(\r\n        <label className={'my-tooltip'}>{tooltip}</label>\r\n    );\r\n}\r\n\r\n/*\r\nfunction TooltipComponent(props: TooltipProps) {\r\n    const tooltip = props.label;\r\n\r\n    return(\r\n        <label className={'my-tooltip'}>{tooltip}</label>\r\n    );\r\n}\r\n\r\ninterface OwnProps {}\r\ninterface StateProps {tooltip: string}\r\ninterface DispatchProps {}\r\ntype AllProps = OwnProps & StateProps & DispatchProps;\r\n\r\nfunction mapStateToProps(state: DState, ownProps: OwnProps): StateProps {\r\n    const ret: StateProps = {} as FakeStateProps;\r\n    ret.tooltip = state.tooltip;\r\n    return ret;\r\n}\r\n\r\nfunction mapDispatchToProps(dispatch: Dispatch<any>): DispatchProps {\r\n    const ret: DispatchProps = {};\r\n    return ret;\r\n}\r\n\r\n\r\nexport const TooltipConnected = connect<StateProps, DispatchProps, OwnProps, DState>(\r\n    mapStateToProps,\r\n    mapDispatchToProps\r\n)(TooltipComponent);\r\n\r\nexport const Tooltip = (props: OwnProps, children: (string | React.Component)[] = []): ReactElement => {\r\n    return(<TooltipConnected {...{...props, children}} />);\r\n}\r\nexport default Tooltip;\r\n*/\r\n","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\components\\editors\\views\\data\\NodeData.tsx",[],"C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\components\\editors\\views\\data\\EdgePointData.tsx",[],"C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\components\\editors\\views\\data\\FieldData.tsx",["1887"],"/* Viewpoints > Options */\r\n\r\nimport React, {Dispatch} from 'react';\r\nimport {DState, DViewElement, LPointerTargetable, LViewElement, Pointer, Select} from '../../../../joiner';\r\nimport {FakeStateProps} from '../../../../joiner/types';\r\nimport {connect} from 'react-redux';\r\n\r\nfunction FieldDataComponent(props: AllProps) {\r\n    const view = props.view;\r\n    const readOnly = props.readonly;\r\n    let dview = view.__raw;\r\n    /*const changeFN = (evt: React.ChangeEvent<HTMLSelectElement>) => {\r\n        const value = evt.target.value;\r\n        view.forceNodeType = value;\r\n        // SetFieldAction.new(dview.id, 'forceNodeType', value, '', false);\r\n    }*/\r\n\r\n    const appliableTo = dview.appliableTo;\r\n    let preferredDisplay: string = dview.forceNodeType as string;\r\n    switch (appliableTo){\r\n        case undefined: case 'Any': break;\r\n        case 'GraphVertex': if (preferredDisplay !== 'Graph' || (preferredDisplay as any) !== 'Vertex') preferredDisplay = appliableTo; break;\r\n        default: preferredDisplay = appliableTo; break;\r\n    }\r\n    let graphElementOptions = <optgroup label={'Type of GraphElement'}>\r\n        <option>Any</option>\r\n        <option>Graph</option>\r\n        <option>GraphVertex</option>\r\n        <option>Vertex</option>\r\n        <option>Edge</option>\r\n        <option>EdgePoint</option>\r\n        <option>Field</option>\r\n    </optgroup>;\r\n    return(<section className={'options-field'}>\r\n        <h5>Field</h5>\r\n        <div>\r\n            <div className={'input-container'}>\r\n                <p>Appliable to:</p>\r\n                <Select data={view} field={'appliableTo'}\r\n                        options={graphElementOptions}\r\n                        getter={() => dview.appliableTo || 'Any'}\r\n                        setter={(v: string, data: DViewElement, field: string, )=>view.appliableTo = v as any} />\r\n            </div>\r\n        </div>\r\n    </section>);\r\n}\r\n\r\ninterface OwnProps {\r\n    viewID: Pointer<DViewElement>;\r\n    readonly : boolean;\r\n}\r\n\r\ninterface StateProps {\r\n    view: LViewElement;\r\n}\r\n\r\ninterface DispatchProps {}\r\ntype AllProps = OwnProps & StateProps & DispatchProps;\r\n\r\nfunction mapStateToProps(state: DState, ownProps: OwnProps): StateProps {\r\n    const ret: StateProps = {} as FakeStateProps;\r\n    ret.view = LPointerTargetable.fromPointer(ownProps.viewID);\r\n    return ret;\r\n}\r\n\r\nfunction mapDispatchToProps(dispatch: Dispatch<any>): DispatchProps {\r\n    const ret: DispatchProps = {};\r\n    return ret;\r\n}\r\n\r\nexport const FieldData = connect<StateProps, DispatchProps, OwnProps, DState>(\r\n    mapStateToProps,\r\n    mapDispatchToProps\r\n)(FieldDataComponent);\r\n\r\nexport default FieldData;\r\n","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\components\\forEndUser\\Color.tsx",["1888"],"import React, {Dispatch, ReactElement, ReactNode} from 'react';\r\nimport {connect} from 'react-redux';\r\nimport {DState} from '../../redux/store';\r\nimport {Defaults, DPointerTargetable, GObject, LPointerTargetable, Overlap, Pointer} from '../../joiner';\r\nimport {useStateIfMounted} from 'use-state-if-mounted';\r\nimport './color.scss';\r\n\r\n\r\nfunction ColorComponent(props: AllProps) {\r\n    const [showTooltip, setShowTooltip] = useStateIfMounted(false);\r\n\r\n    if (!props.data && (!props.getter || !props.setter)) return(<></>);\r\n\r\n    const getter = props.getter || (() => props.data[props.field]);\r\n    const setter = props.setter || ((value:string) => { props.data[props.field] = value; });\r\n    //const field = props.field;\r\n    // const oldValue = (!data) ? undefined : (getter) ? getter(data) : data[field]; // !== undefined); ? data[field] : 'undefined'\r\n    const readOnly = (props.readonly !== undefined) ? props.readonly : props.debugmodee !== 'true' && Defaults.check(props.data.id);\r\n    const type = (props.type) ? props.type : 'text';\r\n    const label: string|undefined = props.label;\r\n    const jsxLabel: ReactNode|undefined = props.jsxLabel;\r\n    let tooltip: ReactNode|string|undefined = ((props.tooltip === true) ? props.data?.['__info_of__' + props.field]?.txt : props.tooltip) || '';\r\n\r\n    let css = 'my-auto input ';\r\n    css += (jsxLabel) ? 'ms-1' : (label) ? 'ms-auto' : '';\r\n    css += (props.hidden) ? ' hidden-input' : '';\r\n    let autosize: boolean = props.autosize === undefined ? false : props.autosize; // props.type==='text'\r\n    css += autosize ? ' autosize-input' : '';\r\n\r\n    const blur = (evt: React.FocusEvent<HTMLInputElement>) => {\r\n        if (readOnly) return;\r\n        const newValue = evt.target.value;\r\n        const oldValue = getter(props.data, props.field); // !== undefined) ? data[field] : 'undefined'\r\n        if (newValue !== oldValue) setter(newValue);\r\n    }\r\n\r\n    const otherprops: GObject = {...props};\r\n    delete otherprops.data;\r\n    delete otherprops.field;\r\n    delete otherprops.getter;\r\n    delete otherprops.setter;\r\n    delete otherprops.label;\r\n    delete otherprops.jsxLabel;\r\n    delete otherprops.tooltip;\r\n    delete otherprops.hidden;\r\n    delete otherprops.inputStyle;\r\n    delete otherprops.children;\r\n    delete otherprops.autosize; // because react complains is bool in dom attribute or unknown attrib name\r\n    let input = <input {...otherprops}\r\n                       // key={props.data?.id + props.field}\r\n                       className={props.inputClassName || css}\r\n                       style={props.inputStyle}\r\n                       spellCheck={false}\r\n                       readOnly={readOnly}\r\n                       type={'color'} value={getter(props.data, props.field)} onChange={blur} onBlur={blur}\r\n    />\r\n\r\n    console.log(\"color component\", {label, jsxLabel, tooltip, c:props.children})\r\n    \r\n    return(<label className={(props.className ? props.className : 'color-picker-root') + ' hoverable'} {...otherprops}\r\n                  style={{display: (jsxLabel || label) ? 'flex' : 'block', cursor: tooltip ? 'help' : 'auto', ...((props as any).style || {})}}>\r\n\r\n        {label && <label className={'my-auto'} onMouseEnter={e => setShowTooltip(true)}\r\n                         onMouseLeave={e => setShowTooltip(false)}>{label}\r\n        </label>}\r\n\r\n        {jsxLabel && <label onMouseEnter={e => setShowTooltip(true)}\r\n                            onMouseLeave={e => setShowTooltip(false)}>{jsxLabel}\r\n        </label>}\r\n\r\n        {(tooltip && showTooltip) && <div className={'my-tooltip'}>\r\n            <b className={'text-center text-capitalize'}>{props.field}</b>\r\n            <br />\r\n            <label>{tooltip}</label>\r\n        </div>}\r\n        {input}\r\n        {props.canDelete && false && <label className=\"p-1\"><button className={'content delete-color mt-2'} style={{position:'relative'}}/></label>}\r\n        {props.children && Object.keys(props.children).length > 0 ? props.children : undefined}\r\n        {props.childrenn && Object.keys(props.childrenn).length > 0 ? props.childrenn : undefined}\r\n    </label>);\r\n}\r\n\r\nexport interface InputOwnProps {\r\n    data: LPointerTargetable | DPointerTargetable | Pointer<DPointerTargetable, 1, 1, LPointerTargetable>;\r\n    field: string;\r\n    getter?: (data: LPointerTargetable, field: string) => string;\r\n    setter?: (value: string) => void;\r\n    label?: string;\r\n    jsxLabel?: ReactNode;\r\n    type?: 'checkbox'|'color'|'date'|'datetime-local'|'email'|'file'|'image'|'month'|\r\n        'number'|'password'|'radio'|'range'|'tel'|'text'|'time'|'url'|'week';\r\n    className?: string;\r\n    style?: GObject;\r\n    readonly?: boolean;\r\n    tooltip?: string | boolean | ReactElement;\r\n    hidden?: boolean;\r\n    autosize?: boolean;\r\n    inputClassName?: string;\r\n    inputStyle?: GObject;\r\n    key?: React.Key | null;\r\n    canDelete?: boolean;\r\n    children?: any;\r\n    childrenn?: any;\r\n}\r\ninterface StateProps {\r\n    debugmodee: string;\r\n    data: LPointerTargetable & GObject;\r\n    // selected: Dictionary<Pointer<DUser>, LModelElement | null>;\r\n}\r\ninterface DispatchProps { }\r\ntype AllProps = Overlap<InputOwnProps, Overlap<StateProps, DispatchProps>>;\r\n\r\n\r\nfunction mapStateToProps(state: DState, ownProps: InputOwnProps): StateProps {\r\n    const ret: StateProps = {} as any;\r\n    const pointer: Pointer = typeof ownProps.data === 'string' ? ownProps.data : ownProps.data.id;\r\n    ret.debugmodee = state.debug ? 'true' : 'false';\r\n    ret.data = LPointerTargetable.fromPointer(pointer);\r\n    /*\r\n    const selected = state.selected;\r\n    ret.selected = {};\r\n    for(let user of Object.keys(selected)) {\r\n        const pointer = selected[user];\r\n        if(pointer) ret.selected[user] = LModelElement.fromPointer(pointer);\r\n        else ret.selected[user] = null;\r\n    }\r\n\r\n    */\r\n    return ret;\r\n}\r\n\r\nfunction mapDispatchToProps(dispatch: Dispatch<any>): DispatchProps {\r\n    const ret: DispatchProps = {};\r\n    return ret;\r\n}\r\n\r\nexport const ColorConnected =\r\n    connect<StateProps, DispatchProps, InputOwnProps, DState>(mapStateToProps, mapDispatchToProps)(ColorComponent);\r\n\r\n\r\nexport function Color(props: InputOwnProps, children: (string | React.Component)[] = []): ReactElement {\r\n    return <ColorConnected {...{...props, children}} />;\r\n}\r\n\r\nColorComponent.cname = 'ColorComponent';\r\nColorConnected.cname = 'ColorConnected';\r\nColor.cname = 'Color';\r\n","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\components\\editors\\views\\data\\GraphData.tsx",["1889","1890","1891"],"import React, {Dispatch} from 'react';\r\nimport {DState, DViewElement, LPointerTargetable, LViewElement, Pointer} from '../../../../joiner';\r\nimport {FakeStateProps} from \"../../../../joiner/types\";\r\nimport {connect} from \"react-redux\";\r\n\r\nfunction GraphDataComponent(props: AllProps) {\r\n    const view = props.view;\r\n    const readOnly = props.readonly;\r\n    let empty = true;\r\n    // if (empty) return null;\r\n    return(<section>\r\n        <h5>Graph</h5>\r\n        <div className={'px-2 no-padding-left'}>\r\n            <div className={'input-container'}>\r\n                <b className={'me-2'}>No options for Graph so far...</b>\r\n            </div>\r\n        </div>\r\n    </section>);\r\n}\r\n\r\ninterface OwnProps {\r\n    viewID: Pointer<DViewElement>;\r\n    readonly : boolean;\r\n}\r\n\r\ninterface StateProps {\r\n    view: LViewElement;\r\n}\r\n\r\ninterface DispatchProps {}\r\ntype AllProps = OwnProps & StateProps & DispatchProps;\r\n\r\nfunction mapStateToProps(state: DState, ownProps: OwnProps): StateProps {\r\n    const ret: StateProps = {} as FakeStateProps;\r\n    ret.view = LPointerTargetable.fromPointer(ownProps.viewID);\r\n    return ret;\r\n}\r\n\r\nfunction mapDispatchToProps(dispatch: Dispatch<any>): DispatchProps {\r\n    const ret: DispatchProps = {};\r\n    return ret;\r\n}\r\n\r\nexport const GraphData = connect<StateProps, DispatchProps, OwnProps, DState>(\r\n    mapStateToProps,\r\n    mapDispatchToProps\r\n)(GraphDataComponent);\r\n\r\nexport default GraphData;\r\n","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\components\\editors\\views\\data\\EdgeData.tsx",[],"C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\components\\forEndUser\\FunctionComponent.tsx",["1892","1893","1894","1895","1896","1897","1898","1899","1900","1901","1902","1903","1904","1905","1906"],"import React, {Dispatch, ReactElement, ReactNode, useEffect, useState} from 'react';\r\nimport {connect} from \"react-redux\";\r\nimport type {Dictionary, DocString, GObject, DState, LViewElement, Pointer, Info} from \"../../joiner\";\r\nimport {Log, LPointerTargetable, U} from \"../../joiner\";\r\nimport {useStateIfMounted} from \"use-state-if-mounted\";\r\nimport {stringify} from \"querystring\";\r\nimport \"./FunctionComponent.scss\";\r\nimport { CommandBar, Btn, Sep } from '../commandbar/CommandBar';\r\nimport { Tooltip } from './Tooltip';\r\n\r\n/*\r\n Rationale behind this:\r\n To do this properly, one would need a complete js parser to make sure comments, ifs, loops, newlines,\r\n   expressions inside array indexing for objects... are all correctly parsed.\r\n\r\n\r\n Instead, to make it faster, i'm forcing the valid \"function string\" value to hold a much more definite structure\r\n   for which i can do an extremely simpler inline parser.\r\n The getter and setter properties and the interface, are making sure the user cannot write a \"function string\"\r\n   not respecting my format, and that it is as much turing-complete as javascript is.\r\n\r\n legenda:\r\n  - ALL_CAPS identifiers, are not literals and the user can change their names.\r\n  - Newlines are included in the format, spaces are not.\r\n  - ... are explaining the format and are not part of it.\r\n  - // **   ** // Styled comments ARE part of the format.\r\n  - Excess spaces in the format are not preserved (might be added/removed by getter/setter), but not mandatory and not relevant.\r\n\r\n my structure is:\r\n (OBJECT_NAME)=> {\\n\r\n   STATEMENT_A1\r\n   STATEMENT_A2\r\n   ...\r\n   STATEMENT_AN\r\n   \\n// ** declarations here ** //\\n\r\n   OBJECT_NAME.IDENTIFIER_1 = STATEMENT_1;\\n\r\n   OBJECT_NAME.IDENTIFIER_2 = STATEMENT_2;\\n\r\n   ...\r\n   OBJECT_NAME.IDENTIFIER_N = STATEMENT_N;\\n\r\n }\r\n */\r\n\r\ntype StrPos = {value: string, line?: number, startindex?: number, endindex?: number};\r\ntype RowData = {index: number; key: number, id: StrPos & { prefix: string }; exp: StrPos, isDirty?: boolean};\r\ntype TextAreaState = {v:string, isDirty?: boolean};\r\ntype FunctionComponentState = {advancedMode: boolean, collapsed: boolean, ta: TextAreaState, arr: RowData[]};\r\ntype SetState = (value: FunctionComponentState)=>void;\r\nconst minimalTextareaValue = '(ret)=>{\\n';\r\n\r\nfunction parseFunction(props: AllProps): FunctionComponentState {\r\n    Log.exDev(!props.data, \"FunctionComponent: missing data props\", {props});\r\n    let getter = props.getter || ((a: GObject) => a[props.field]); // ((lobj: GObject<LPointerTargetable>, key: string) => U.wrapUserFunction(lobj[key]));\r\n    let val: string = getter(props.data);\r\n    if (!val || val.length <= 2) val = \"(ret)=>{\\n    // ** declarations here ** //\\n\\n}\"; // fallback for empty string and {}\r\n    else val = val.trim();\r\n    let txtparts = val.split(\"// ** declarations here ** //\");\r\n    if (txtparts.length !== 2) {\r\n        Log.eDevv(\"cannot find declaration section\", {val, props});\r\n        txtparts = [val.substring(0, val.length-1), val.substring(val.length-1)];\r\n    }\r\n    let declarations: string[] = (txtparts[1] || '').split(\"\\n\");\r\n    let stateArrayValues: RowData[] = [];\r\n    let textAreaState: TextAreaState = {v: txtparts[0]};\r\n    let i: number = -1;\r\n    for (let dec of declarations) {\r\n        let splitindex = dec.indexOf(\"=\");\r\n        if (splitindex === -1) continue; // for ending \\n} line\r\n        i++; // don't loop by i, the index ending in state must increase only for non-empty rows filtering them out.\r\n        let expression = dec.substring(splitindex+1);\r\n        let identifier = dec.substring(0, splitindex);\r\n        let idsplitindex = identifier.indexOf(\".\");\r\n        let identifierPrefix = identifier.substring(0, idsplitindex);\r\n        let identifierName = identifier.substring(idsplitindex+1);\r\n        stateArrayValues.push({\r\n            index: i,\r\n            key: i,\r\n            id: {prefix: identifierPrefix, value: identifierName.trim(), line: i, startindex: idsplitindex, endindex: splitindex},\r\n            exp:{                          value: expression.trim(),     line: i, startindex: splitindex,   endindex: -1}\r\n        });\r\n    }\r\n    return {advancedMode: !!props.advancedMode, collapsed: props.collapsed === !!props.collapsed, ta: textAreaState, arr:stateArrayValues};\r\n}\r\n\r\n// event listing start\r\n// it's not on purpose, but this function is a candidate for obscure code context XD\r\nfunction addClick(v: FunctionComponentState, set: SetState): void {\r\n    let lasti: number = (v.arr[v.arr.length-1]?.index ?? -1) +1;\r\n    let lastk: number = (v.arr[v.arr.length-1]?.key ?? -1) +1;\r\n    set({...v, arr: [...v.arr, {index: lasti, key: lastk,\r\n            id: {prefix: v.arr[0]?.id.prefix || \"ret\", value: \"\"},\r\n            exp: {value: \"\"} }]\r\n    });\r\n}\r\n\r\n// function fixIndex(i: number, rows: RowData[]): number{ for (let row of rows) if (row.index === ) }\r\nfunction deleteClick(v0: FunctionComponentState, set: SetState, i: number, props: AllProps, row:RowData): void {\r\n    // do i really need to shallow copy nested objects too? it should not be necessary\r\n    let v = {...v0} //, arr:[...v0.arr]};\r\n    /// problem: deleting an element in the middle invalidetes the row.index values\r\n    /// solution 1: update the row.index values, move the rect key to a different field that is initial = index, but never changes.\r\n    /// implemented\r\n    v.arr.splice(i, 1);\r\n    for (; i < v.arr.length; i++) v.arr[i].index = i;\r\n    /// solution 2: keep original indexes, use a fixIndex function to map the index in html (without holes) to index in row structure (with holes).\r\n    ///  discareded\r\n\r\n    set(v);\r\n    onBlur(v, set, props, undefined, true);\r\n}\r\n\r\nfunction expressionChange(e: React.FormEvent<HTMLInputElement>, i: number, v: FunctionComponentState, set: SetState): void {\r\n    v = {...v, arr:[...v.arr]};\r\n    v.arr[i] = {\r\n        ...v.arr[i],\r\n        isDirty: true,\r\n        exp: {...v.arr[i].exp, value: e.currentTarget.value}\r\n    };\r\n    set(v);\r\n}\r\n\r\nfunction identifierChange(e: React.FormEvent<HTMLInputElement>, i: number, v: FunctionComponentState, set: SetState): void {\r\n    let nv = e.currentTarget.value;\r\n    v = {...v, arr:[...v.arr]};\r\n    v.arr[i] = {\r\n        ...v.arr[i],\r\n        isDirty: true,\r\n        // empty string is fine, as long value is empty too the entire row is ignored. but identifiers cannot start with a number are not allowed.\r\n        id: {...v.arr[i].id, value: isNaN(+nv[0]) ? nv : \"A\" + nv}\r\n    };\r\n    set(v);\r\n}\r\n\r\nfunction textAreaChange(e: React.FormEvent<HTMLTextAreaElement>, v: FunctionComponentState, set: SetState): void {\r\n    set({...v, ta: {v:e.currentTarget.value, isDirty: true} });\r\n}\r\n\r\nfunction onBlur(v: FunctionComponentState, set: SetState, props: AllProps, i?: number, isDelete?: boolean) {\r\n    if (isDelete) {\r\n        // force update without checking dirty (the row is not present anymore)\r\n    }\r\n    // problem: this might be called before the onChange setState() actually edits the state, so it finds isDirty false or even a non-yet existing index\r\n        // for now i will just hope the user is not typing and blurring extra fast, i don't think a simple solution exists\r\n    else if (i !== undefined) {\r\n        if (!v.arr[i]?.isDirty) return;\r\n        v = {...v, arr:[...v.arr]};\r\n        v.arr[i] = {\r\n            ...v.arr[i],\r\n            isDirty: false,\r\n        };\r\n        set(v);\r\n    }\r\n    else {\r\n        if (!v.ta.isDirty) return;\r\n        set({...v, ta: {v: v.ta.v, isDirty: false} });\r\n    }\r\n    updateFunctionValue(props, v.ta.v, v.arr);\r\n}\r\n\r\nfunction updateFunctionValue(props: AllProps, textAreaContent: string, stateArrayValues: RowData[]){\r\n    let declarations: string[] = stateArrayValues.map( o => o.id.value && o.exp.value ? o.id.prefix + \".\" + o.id.value + \" = \" + o.exp.value : '');\r\n    let setter = props.setter || ((v: string) => (props.data as GObject)[props.field] = v);\r\n    setter(textAreaContent + \"\\n// ** declarations here ** //\\n\" + declarations.filter(d=>!!d).join(\"\\n\") + \"\\n}\")\r\n}\r\n// event listing end\r\n\r\nfunction FunctionComponent(props: AllProps) {\r\n    // if (false) return asTextArea(props) // i gave up\r\n    const [state, setState] = useStateIfMounted(parseFunction(props));\r\n    const [showTooltip, setShowTooltip] = useStateIfMounted(false);\r\n    // if (!props.data) return <></>;\r\n    let advancedMode: boolean = state.advancedMode,\r\n        readOnly = props.readonly; // (props.readonly !== undefined) ? props.readonly : !props.debugMode && props.data.id.indexOf(\"Pointer_View\") !== -1;\r\n\r\n    // NB: could be heavily optimized by cutting the original string with indexes and substring,\r\n    // but it is a function called too rarely and not impactful on overall performances\r\n\r\n    let tooltip: string|undefined | ReactNode = (props.tooltip === true) ? (props.data as GObject)['__info_of__' + props.field]?.txt : props.tooltip;\r\n\r\n\r\n    // JSX building start\r\n    let inputs: JSX.Element[] = [];\r\n    // console.log(\"funccomp\", {stateArrayValues, textAreaState, props});\r\n\r\n\r\n    for (let row of state.arr) {\r\n        inputs.push(<label className={\"d-flex template-item\" + (advancedMode ? \"\" : \" my-1\")} key={row.index} data-key={row.index}>\r\n            <span className={\"my-auto detailedMode\"}>{row.id.prefix}.</span>\r\n            <input className={\"my-auto input\"}\r\n                placeholder={\"identifier\"} value={row.id.value}  disabled={readOnly}\r\n                tabIndex={row.index*2}\r\n                onInput={(e)=>identifierChange(e, row.index, state, setState)}\r\n                onBlur={(e)=> !readOnly && onBlur(state, setState, props, row.index)}\r\n                style={{width: '30%'}}\r\n            />\r\n            <span className={\"my-auto mx-1 simpleMode\"} style={{paddingRight: '6px', paddingLeft: '6px'}}><i style={{fontSize: '1.2em'}} className=\"bi bi-arrow-left-square\"></i></span>\r\n            <span className={\"my-auto mx-1 detailedMode\"}>=</span> {/*  */}\r\n            <input className={\"my-auto input\"}\r\n                placeholder={\"expression\"}\r\n                value={row.exp.value}\r\n                disabled={readOnly}\r\n                tabIndex={row.index*2+1}\r\n                onInput={(e)=>expressionChange(e, row.index, state, setState)}\r\n                onBlur={(e)=> !readOnly && onBlur(state, setState, props, row.index)}\r\n                style={{marginRight: '6px'}}\r\n            />\r\n            <span className={\"my-auto detailedMode\"}>;</span>\r\n            <CommandBar style={{paddingTop: '10px'}}>\r\n                <Btn icon={'delete'} tip={'Delete'} action={()=>!readOnly && deleteClick(state, setState, row.index, props, row)} />\r\n            </CommandBar>\r\n            {/* <button className={\"bg btn-delete my-auto ms-2\"} tabIndex={state.arr.length*2 +1 +row.index} disabled={readOnly} onClick={()=>!readOnly && deleteClick(state, setState, row.index, props, row)}>\r\n                <i className={\"p-1 bi bi-dash\"} /></button> */}\r\n        </label>);\r\n    }\r\n\r\n    let transitionTime = 300;\r\n\r\n    return <div className={\"function-editor-root\"} data-mode={advancedMode ? \"detailedMode\" : \"simpleMode\"} style={{fontSize: \"0.9rem\"}}>\r\n        <div className={\"d-flex w-100 function-editor-header\"}>\r\n        {/* <div className={\"d-flex w-100 function-editor-header\"} style={{transition: \"all 300ms\",  cursor: tooltip ? 'help' : 'auto'}}\r\n             onMouseEnter={e => tooltip && setShowTooltip(true)} onMouseLeave={e =>  tooltip && setShowTooltip(false)}></div>*/}\r\n            <div className={\"function-editor-label\"}>\r\n                {props.jsxLabel}\r\n                <p style={{fontSize: '0.8em', paddingBottom: '0px'}}>{props.payoff}</p>\r\n                {/* <button className={\"btn button-add\"} tabIndex={state.arr.length*2}\r\n                        disabled={readOnly} onClick={()=> !readOnly && addClick(state, setState)}>+</button> */}\r\n            </div>\r\n\r\n            <CommandBar style={{marginLeft: 'auto'}}>\r\n                {!state.collapsed ?\r\n                    <>\r\n                        <Btn icon={'add'} action={()=> !readOnly && addClick(state, setState)} tip={'Add new constant'}/>\r\n                        <Sep />\r\n                        {showTooltip ?\r\n                            <Btn icon={'info'} action={()=> {setShowTooltip(false)}} tip={'Hide information'} mode={'negative'}/>\r\n                            :\r\n                            <Btn icon={'info'} action={()=> {setShowTooltip(true)}} tip={'Show information'} />\r\n                        }\r\n\r\n                        {advancedMode?\r\n                            <Btn icon={'settings'} action={()=>setState( {...state, advancedMode:!state.advancedMode})} tip={'Close advanced mode'} mode={'negative'}/>\r\n                            :\r\n                            <Btn icon={'settings'} action={()=>setState( {...state, advancedMode:!state.advancedMode})} tip={'Open advanced mode'}/>\r\n                        }\r\n\r\n                        <Sep />\r\n                        <Btn icon={'open-down'} action={()=>setState( {...state, collapsed:!state.collapsed})} tip={'Hide definitions'}/>\r\n                    </>\r\n                    :\r\n                    <Btn icon={'close-up'} action={()=>setState( {...state, collapsed:!state.collapsed})} tip={'Show definitions'}/>\r\n                }\r\n\r\n            </CommandBar>\r\n\r\n\r\n            {/*\r\n            <span className={\"m-auto me-1\"} style={{border: '1px solid red', cursor: 'auto'}}>\r\n\r\n            {tooltip && <i className={\"p1 m-auto me-1 bi bi-info-square\"} style={{cursor: 'help'}} />}\r\n\r\n                <span className={\"m-auto\"} style={{cursor: 'auto', height: \"100%\", display: \"inline-block\"}}\r\n                      onMouseEnter={e => tooltip && setShowTooltip(false)} onMouseLeave={e =>  tooltip && setShowTooltip(true)}\r\n                >\r\n\r\n                <i className={ \"p1 m-auto mx-1 bi \" + (advancedMode ? \"btn-outline-secondary bi-eye-slash\" : \"btn-outline-secondary bi-eye\")}\r\n                   onClick={()=>setState( {...state, advancedMode:!state.advancedMode})} style={{cursor: 'pointer'}} />\r\n\r\n                   <i className={ \"p1 bi m-auto mx-1 bi bi-chevron-down btn-outline-secondary\"}\r\n                   onClick={()=>setState( {...state, collapsed:!state.collapsed})}\r\n                   style={{cursor: 'pointer', transition:transitionTime/2 + \"ms all\",\r\n                       transform: \"scaleY(\"+(state.collapsed ? 1 : -1 )+\")  translateY(\" + (state.collapsed ? -0 : 0.1) +\"em)\",\r\n                   }} />\r\n\r\n                </span>\r\n            </span>\r\n            */}\r\n\r\n\r\n\r\n        </div>\r\n        {(tooltip && showTooltip) && <div className={'my-tooltip'} style={{marginBottom: '10px'}}>\r\n            {/*\r\n            <b className={'text-center text-capitalize'}>{props.field}</b>\r\n            <br />\r\n            */}\r\n            <label>{tooltip}</label>\r\n        </div>}\r\n        {<div\r\n            className={\"collapsable-section \" + (state.collapsed ? \"collapsed\" : \"expanded\")}\r\n            data-comment={\"collapsable-section\"}\r\n            style={{/*\r\n                transition: transitionTime + \"ms all\", // transformOrigin: \"top\", transform: \"rotateX(\"+(state.collapsed ? 0 : 90 )+\"deg)\",\r\n                transform: \"scaleY(\"+(state.collapsed ? 0 : 1 )+\") \",\r\n                transformOrigin: \"top\",\r\n                overflow:\"hidden\"*/\r\n            }}>\r\n\r\n            <textarea className={\"detailedMode input w-100\"} disabled={readOnly} rows={Math.min(10, state.ta.v.split(\"\\n\").length)}\r\n                  onInput={(e)=>textAreaChange(e, state, setState)}\r\n                  onBlur={(e)=> !readOnly && onBlur(state, setState, props)}\r\n                  data-txtcontent={state.ta.v}\r\n                  value={state.ta.v} />\r\n            {inputs}\r\n            {false && <div style={{whiteSpace:\"pre\"}}>{(props.data as any)[props.field]}</div>}\r\n        </div>}\r\n    </div>;\r\n}\r\n\r\ninterface OwnProps {\r\n    advancedMode?: boolean; // toggle textbox pre-declarations, initial value to set state. after initialization only state.advancedMode is used\r\n    collapsed?: boolean; // start collapsed or visible, default value is false = visible\r\n    data: LPointerTargetable;\r\n    field: string;\r\n    getter?: (data: LPointerTargetable) => string;\r\n    setter?: (value: string|boolean) => void;\r\n    readonly?: boolean;\r\n    // not used for now\r\n    label?: string;\r\n    jsxLabel?: ReactNode;\r\n    payoff?: string;\r\n    className?: string;\r\n    style?: GObject;\r\n    tooltip?: string | boolean | ReactElement;\r\n    hidden?: boolean;\r\n    autosize?: boolean;\r\n    inputClassName?: string;\r\n    inputStyle?: GObject;\r\n    key?: React.Key | null;\r\n}\r\n\r\ninterface StateProps {\r\n}\r\n\r\ninterface DispatchProps { }\r\ntype AllProps = OwnProps & StateProps & DispatchProps;\r\n\r\n/*\r\nfunction mapStateToProps(state: DState, ownProps: OwnProps): StateProps {\r\n  return ownProps;\r\n}\r\n\r\nfunction mapDispatchToProps(dispatch: Dispatch<any>): DispatchProps {\r\n    const ret: DispatchProps = {};\r\n    return ret;\r\n}\r\n\r\n\r\nexport const FunctionConnected = connect<StateProps, DispatchProps, OwnProps, DState>(\r\n    mapStateToProps,\r\n    mapDispatchToProps\r\n)(FunctionComponent);\r\n*/\r\n// export const Function = (props: OwnProps, children: (string | React.Component)[] = []): ReactElement => (<FunctionConnected {...{...props, children}} />);\r\nexport const Function = (props: OwnProps, children: (string | React.Component)[] = []): ReactElement => (<FunctionComponent {...{...props, children}} tooltip={true} />);\r\n\r\nFunction.cname = \"FunctionComponent\";\r\n// FunctionConnected.cname = \"FunctionComponent_Connected\";\r\nFunctionComponent.cname = \"FunctionComponent_Disconnected\";\r\n\r\n","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\components\\widgets\\Widgets.tsx",["1907","1908","1909","1910","1911","1912","1913","1914"],"import React, { useState } from 'react';\r\nimport './widgets.scss';\r\nimport { event } from 'jquery';\r\nimport {int, PrimitiveType} from '../../joiner/types';\r\nimport { windoww } from '../../joiner/types';\r\nimport { SetRootFieldAction } from '../../joiner';\r\nimport { MapStateToProps } from 'react-redux';\r\nimport { InputMapStateToProps } from '../forEndUser/Input';\r\nimport { DState } from '../../joiner';\r\nimport { VertexOwnProps, VertexStateProps } from '../../graph/graphElement/sharedTypes/sharedTypes';\r\n\r\n\r\n\r\ntype InToggleValues = {\r\n    true: PrimitiveType;\r\n    false: PrimitiveType;\r\n}\r\n\r\ntype InToggleProps = {\r\n    name: string;\r\n    values?: InToggleValues;\r\n    labels?: InToggleValues;\r\n    size?: string; // \"small\" | \"medium\" | \"large\";\r\n    style?: React.CSSProperties;\r\n};\r\n\r\nexport const InternalToggle = (props: InToggleProps) => {\r\n    const [value, setValue] = useState<boolean>(false);\r\n\r\n    const labels = props.labels ? props.labels : {true: props.name+' on', false: props.name+' off'};\r\n\r\n    const toggleValue = () => {\r\n        const newValue = !value;\r\n        setValue(newValue);\r\n        SetRootFieldAction.new(props.name, newValue);\r\n    };\r\n    let trueval = props.values ? props.values.true : true;\r\n    let falseval = props.values ? props.values.false : false;\r\n\r\n    return (\r\n        <div className={'toggle ' + (props.size || 'medium')} onClick={() => {toggleValue()}} style={props.style}>\r\n\r\n            <input className={'toggle-input'} id={props.name} type={'checkbox'} checked={value}  />\r\n            <label className={'toggle-label'}></label>\r\n            <div className={\"toggle-labels\"}>\r\n                {value === trueval && <span className={\"toggle-on\"}>{labels['true']}</span>}\r\n                {value === falseval && <span className={\"toggle-off\"}>{labels['false']}</span>}\r\n            </div>\r\n        </div>\r\n    );\r\n}\r\n\r\ntype HRuleProps = {\r\n    theme?:  'normal' | 'light' | 'dark';\r\n    style?: React.CSSProperties;\r\n}\r\nexport const HRule = (props: HRuleProps) => {\r\n\r\n    const theme = (!props.theme ? 'normal' : props.theme);\r\n    return (<>\r\n        {props.style ?\r\n            <hr className={`hrule ${theme}`} style={props.style}></hr>\r\n        :\r\n            <hr className={`hrule ${theme}`} ></hr>\r\n        }\r\n    </>);\r\n}\r\n","C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\api\\DTO\\ChangePasswordRequest.ts",[],"C:\\Users\\Andrea\\Documents\\Capoweb\\Jjodel\\Code\\jjodel\\frontend\\src\\api\\DTO\\UpdateUserRequest.ts",[],{"ruleId":"1915","severity":1,"message":"1916","line":5,"column":24,"nodeType":"1917","messageId":"1918","endLine":5,"endColumn":29},{"ruleId":"1915","severity":1,"message":"1919","line":5,"column":40,"nodeType":"1917","messageId":"1918","endLine":5,"endColumn":41},{"ruleId":"1915","severity":1,"message":"1920","line":5,"column":43,"nodeType":"1917","messageId":"1918","endLine":5,"endColumn":61},{"ruleId":"1915","severity":1,"message":"1921","line":5,"column":63,"nodeType":"1917","messageId":"1918","endLine":5,"endColumn":75},{"ruleId":"1915","severity":1,"message":"1922","line":9,"column":9,"nodeType":"1917","messageId":"1918","endLine":9,"endColumn":22},{"ruleId":"1915","severity":1,"message":"1923","line":10,"column":21,"nodeType":"1917","messageId":"1918","endLine":10,"endColumn":34},{"ruleId":"1915","severity":1,"message":"1924","line":45,"column":10,"nodeType":"1917","messageId":"1918","endLine":45,"endColumn":17},{"ruleId":"1915","severity":1,"message":"1925","line":11,"column":21,"nodeType":"1917","messageId":"1918","endLine":11,"endColumn":28},{"ruleId":"1915","severity":1,"message":"1926","line":13,"column":5,"nodeType":"1917","messageId":"1918","endLine":13,"endColumn":21},{"ruleId":"1915","severity":1,"message":"1927","line":250,"column":5,"nodeType":"1917","messageId":"1918","endLine":250,"endColumn":11},{"ruleId":"1915","severity":1,"message":"1928","line":292,"column":7,"nodeType":"1917","messageId":"1918","endLine":292,"endColumn":13},{"ruleId":"1915","severity":1,"message":"1929","line":293,"column":7,"nodeType":"1917","messageId":"1918","endLine":293,"endColumn":13},{"ruleId":"1930","severity":1,"message":"1931","line":14,"column":8,"nodeType":"1932","endLine":14,"endColumn":18,"suggestions":"1933"},{"ruleId":"1915","severity":1,"message":"1934","line":10,"column":9,"nodeType":"1917","messageId":"1918","endLine":10,"endColumn":15},{"ruleId":"1915","severity":1,"message":"1935","line":13,"column":11,"nodeType":"1917","messageId":"1918","endLine":13,"endColumn":24},{"ruleId":"1915","severity":1,"message":"1936","line":14,"column":11,"nodeType":"1917","messageId":"1918","endLine":14,"endColumn":25},{"ruleId":"1915","severity":1,"message":"1937","line":1,"column":9,"nodeType":"1917","messageId":"1918","endLine":1,"endColumn":21},{"ruleId":"1915","severity":1,"message":"1938","line":1,"column":23,"nodeType":"1917","messageId":"1918","endLine":1,"endColumn":32},{"ruleId":"1915","severity":1,"message":"1939","line":2,"column":5,"nodeType":"1917","messageId":"1918","endLine":2,"endColumn":13},{"ruleId":"1915","severity":1,"message":"1940","line":4,"column":5,"nodeType":"1917","messageId":"1918","endLine":4,"endColumn":18},{"ruleId":"1915","severity":1,"message":"1941","line":5,"column":5,"nodeType":"1917","messageId":"1918","endLine":5,"endColumn":14},{"ruleId":"1915","severity":1,"message":"1937","line":6,"column":5,"nodeType":"1917","messageId":"1918","endLine":6,"endColumn":17},{"ruleId":"1915","severity":1,"message":"1942","line":11,"column":9,"nodeType":"1917","messageId":"1918","endLine":11,"endColumn":16},{"ruleId":"1915","severity":1,"message":"1943","line":12,"column":9,"nodeType":"1917","messageId":"1918","endLine":12,"endColumn":15},{"ruleId":"1915","severity":1,"message":"1944","line":14,"column":5,"nodeType":"1917","messageId":"1918","endLine":14,"endColumn":13},{"ruleId":"1915","severity":1,"message":"1945","line":15,"column":5,"nodeType":"1917","messageId":"1918","endLine":15,"endColumn":23},{"ruleId":"1915","severity":1,"message":"1946","line":16,"column":5,"nodeType":"1917","messageId":"1918","endLine":16,"endColumn":7},{"ruleId":"1915","severity":1,"message":"1947","line":18,"column":5,"nodeType":"1917","messageId":"1918","endLine":18,"endColumn":15},{"ruleId":"1915","severity":1,"message":"1948","line":20,"column":5,"nodeType":"1917","messageId":"1918","endLine":20,"endColumn":23},{"ruleId":"1915","severity":1,"message":"1949","line":22,"column":5,"nodeType":"1917","messageId":"1918","endLine":22,"endColumn":12},{"ruleId":"1915","severity":1,"message":"1950","line":22,"column":14,"nodeType":"1917","messageId":"1918","endLine":22,"endColumn":19},{"ruleId":"1915","severity":1,"message":"1951","line":23,"column":5,"nodeType":"1917","messageId":"1918","endLine":23,"endColumn":6},{"ruleId":"1915","severity":1,"message":"1952","line":23,"column":8,"nodeType":"1917","messageId":"1918","endLine":23,"endColumn":27},{"ruleId":"1915","severity":1,"message":"1953","line":107,"column":17,"nodeType":"1917","messageId":"1918","endLine":107,"endColumn":18},{"ruleId":"1915","severity":1,"message":"1954","line":108,"column":17,"nodeType":"1917","messageId":"1918","endLine":108,"endColumn":18},{"ruleId":"1955","severity":1,"message":"1956","line":19,"column":29,"nodeType":"1957","messageId":"1958","endLine":19,"endColumn":31},{"ruleId":"1959","severity":1,"message":"1960","line":26,"column":22,"nodeType":"1917","messageId":"1961","endLine":26,"endColumn":23},{"ruleId":"1955","severity":1,"message":"1956","line":27,"column":22,"nodeType":"1957","messageId":"1958","endLine":27,"endColumn":24},{"ruleId":"1955","severity":1,"message":"1956","line":29,"column":27,"nodeType":"1957","messageId":"1958","endLine":29,"endColumn":29},{"ruleId":"1955","severity":1,"message":"1962","line":31,"column":37,"nodeType":"1957","messageId":"1958","endLine":31,"endColumn":39},{"ruleId":"1955","severity":1,"message":"1956","line":34,"column":45,"nodeType":"1957","messageId":"1958","endLine":34,"endColumn":47},{"ruleId":"1955","severity":1,"message":"1956","line":11,"column":23,"nodeType":"1957","messageId":"1958","endLine":11,"endColumn":25},{"ruleId":"1955","severity":1,"message":"1956","line":18,"column":30,"nodeType":"1957","messageId":"1958","endLine":18,"endColumn":32},{"ruleId":"1955","severity":1,"message":"1956","line":19,"column":35,"nodeType":"1957","messageId":"1958","endLine":19,"endColumn":37},{"ruleId":"1955","severity":1,"message":"1956","line":20,"column":35,"nodeType":"1957","messageId":"1958","endLine":20,"endColumn":37},{"ruleId":"1959","severity":1,"message":"1963","line":25,"column":28,"nodeType":"1917","messageId":"1961","endLine":25,"endColumn":29},{"ruleId":"1955","severity":1,"message":"1956","line":26,"column":37,"nodeType":"1957","messageId":"1958","endLine":26,"endColumn":39},{"ruleId":"1955","severity":1,"message":"1956","line":28,"column":42,"nodeType":"1957","messageId":"1958","endLine":28,"endColumn":44},{"ruleId":"1959","severity":1,"message":"1963","line":57,"column":28,"nodeType":"1917","messageId":"1961","endLine":57,"endColumn":29},{"ruleId":"1955","severity":1,"message":"1956","line":63,"column":28,"nodeType":"1957","messageId":"1958","endLine":63,"endColumn":30},{"ruleId":"1955","severity":1,"message":"1956","line":97,"column":28,"nodeType":"1957","messageId":"1958","endLine":97,"endColumn":30},{"ruleId":"1955","severity":1,"message":"1956","line":110,"column":33,"nodeType":"1957","messageId":"1958","endLine":110,"endColumn":35},{"ruleId":"1955","severity":1,"message":"1956","line":112,"column":33,"nodeType":"1957","messageId":"1958","endLine":112,"endColumn":35},{"ruleId":"1964","severity":1,"message":"1965","line":123,"column":22,"nodeType":"1966","messageId":"1967","endLine":123,"endColumn":23,"suggestions":"1968"},{"ruleId":"1955","severity":1,"message":"1956","line":130,"column":25,"nodeType":"1957","messageId":"1958","endLine":130,"endColumn":27},{"ruleId":"1955","severity":1,"message":"1956","line":139,"column":30,"nodeType":"1957","messageId":"1958","endLine":139,"endColumn":32},{"ruleId":"1955","severity":1,"message":"1956","line":150,"column":21,"nodeType":"1957","messageId":"1958","endLine":150,"endColumn":23},{"ruleId":"1915","severity":1,"message":"1969","line":28,"column":13,"nodeType":"1917","messageId":"1918","endLine":28,"endColumn":18},{"ruleId":"1915","severity":1,"message":"1970","line":42,"column":27,"nodeType":"1917","messageId":"1918","endLine":42,"endColumn":35},{"ruleId":"1915","severity":1,"message":"1971","line":42,"column":95,"nodeType":"1917","messageId":"1918","endLine":42,"endColumn":105},{"ruleId":"1915","severity":1,"message":"1970","line":43,"column":28,"nodeType":"1917","messageId":"1918","endLine":43,"endColumn":36},{"ruleId":"1915","severity":1,"message":"1971","line":43,"column":96,"nodeType":"1917","messageId":"1918","endLine":43,"endColumn":106},{"ruleId":"1915","severity":1,"message":"1972","line":109,"column":23,"nodeType":"1917","messageId":"1918","endLine":109,"endColumn":24},{"ruleId":"1915","severity":1,"message":"1973","line":109,"column":26,"nodeType":"1917","messageId":"1918","endLine":109,"endColumn":33},{"ruleId":"1915","severity":1,"message":"1972","line":117,"column":18,"nodeType":"1917","messageId":"1918","endLine":117,"endColumn":19},{"ruleId":"1915","severity":1,"message":"1972","line":188,"column":24,"nodeType":"1917","messageId":"1918","endLine":188,"endColumn":25},{"ruleId":"1915","severity":1,"message":"1972","line":189,"column":17,"nodeType":"1917","messageId":"1918","endLine":189,"endColumn":18},{"ruleId":"1915","severity":1,"message":"1974","line":191,"column":6,"nodeType":"1917","messageId":"1918","endLine":191,"endColumn":19},{"ruleId":"1915","severity":1,"message":"1975","line":200,"column":6,"nodeType":"1917","messageId":"1918","endLine":200,"endColumn":13},{"ruleId":"1915","severity":1,"message":"1976","line":143,"column":10,"nodeType":"1917","messageId":"1918","endLine":143,"endColumn":24},{"ruleId":"1915","severity":1,"message":"1951","line":2,"column":9,"nodeType":"1917","messageId":"1918","endLine":2,"endColumn":10},{"ruleId":"1915","severity":1,"message":"1977","line":1,"column":23,"nodeType":"1917","messageId":"1918","endLine":1,"endColumn":32},{"ruleId":"1915","severity":1,"message":"1951","line":2,"column":9,"nodeType":"1917","messageId":"1918","endLine":2,"endColumn":10},{"ruleId":"1915","severity":1,"message":"1978","line":20,"column":6,"nodeType":"1917","messageId":"1918","endLine":20,"endColumn":11},{"ruleId":"1915","severity":1,"message":"1979","line":230,"column":87,"nodeType":"1917","messageId":"1918","endLine":230,"endColumn":94},{"ruleId":"1915","severity":1,"message":"1980","line":318,"column":13,"nodeType":"1917","messageId":"1918","endLine":318,"endColumn":37},{"ruleId":"1915","severity":1,"message":"1981","line":319,"column":13,"nodeType":"1917","messageId":"1918","endLine":319,"endColumn":31},{"ruleId":"1915","severity":1,"message":"1982","line":424,"column":13,"nodeType":"1917","messageId":"1918","endLine":424,"endColumn":21},{"ruleId":"1983","severity":1,"message":"1984","line":429,"column":13,"nodeType":"1985","messageId":"1986","endLine":429,"endColumn":61},{"ruleId":"1915","severity":1,"message":"1951","line":1,"column":56,"nodeType":"1917","messageId":"1918","endLine":1,"endColumn":57},{"ruleId":"1915","severity":1,"message":"1987","line":105,"column":50,"nodeType":"1917","messageId":"1918","endLine":105,"endColumn":63},{"ruleId":"1915","severity":1,"message":"1921","line":135,"column":5,"nodeType":"1917","messageId":"1918","endLine":135,"endColumn":17},{"ruleId":"1915","severity":1,"message":"1988","line":142,"column":9,"nodeType":"1917","messageId":"1918","endLine":142,"endColumn":20},{"ruleId":"1989","severity":1,"message":"1990","line":188,"column":9,"nodeType":"1991","messageId":"1958","endLine":188,"endColumn":62},{"ruleId":"1992","severity":1,"message":"1993","line":190,"column":9,"nodeType":"1994","messageId":"1958","endLine":190,"endColumn":13},{"ruleId":"1915","severity":1,"message":"1995","line":227,"column":9,"nodeType":"1917","messageId":"1918","endLine":227,"endColumn":12},{"ruleId":"1915","severity":1,"message":"1996","line":449,"column":9,"nodeType":"1917","messageId":"1918","endLine":449,"endColumn":18},{"ruleId":"1997","severity":1,"message":"1998","line":574,"column":20,"nodeType":"1999","messageId":"2000","endLine":574,"endColumn":22},{"ruleId":"1997","severity":1,"message":"1998","line":574,"column":44,"nodeType":"1999","messageId":"2000","endLine":574,"endColumn":46},{"ruleId":"1915","severity":1,"message":"2001","line":584,"column":37,"nodeType":"1917","messageId":"1918","endLine":584,"endColumn":38},{"ruleId":"1915","severity":1,"message":"2001","line":599,"column":31,"nodeType":"1917","messageId":"1918","endLine":599,"endColumn":32},{"ruleId":"1915","severity":1,"message":"2002","line":906,"column":13,"nodeType":"1917","messageId":"1918","endLine":906,"endColumn":29},{"ruleId":"1915","severity":1,"message":"2003","line":924,"column":13,"nodeType":"1917","messageId":"1918","endLine":924,"endColumn":26},{"ruleId":"1915","severity":1,"message":"2002","line":1081,"column":15,"nodeType":"1917","messageId":"1918","endLine":1081,"endColumn":32},{"ruleId":"1915","severity":1,"message":"2004","line":1252,"column":62,"nodeType":"1917","messageId":"1918","endLine":1252,"endColumn":64},{"ruleId":"1915","severity":1,"message":"2005","line":1259,"column":9,"nodeType":"1917","messageId":"1918","endLine":1259,"endColumn":17},{"ruleId":"1915","severity":1,"message":"2004","line":1283,"column":64,"nodeType":"1917","messageId":"1918","endLine":1283,"endColumn":66},{"ruleId":"1915","severity":1,"message":"2005","line":1295,"column":9,"nodeType":"1917","messageId":"1918","endLine":1295,"endColumn":17},{"ruleId":"1915","severity":1,"message":"1995","line":1342,"column":63,"nodeType":"1917","messageId":"1918","endLine":1342,"endColumn":66},{"ruleId":"1915","severity":1,"message":"2004","line":1366,"column":64,"nodeType":"1917","messageId":"1918","endLine":1366,"endColumn":66},{"ruleId":"1915","severity":1,"message":"1972","line":1471,"column":24,"nodeType":"1917","messageId":"1918","endLine":1471,"endColumn":25},{"ruleId":"1915","severity":1,"message":"2006","line":1522,"column":15,"nodeType":"1917","messageId":"1918","endLine":1522,"endColumn":48},{"ruleId":"1915","severity":1,"message":"2007","line":1536,"column":13,"nodeType":"1917","messageId":"1918","endLine":1536,"endColumn":24},{"ruleId":"1964","severity":1,"message":"2008","line":1583,"column":74,"nodeType":"1966","messageId":"1967","endLine":1583,"endColumn":75,"suggestions":"2009"},{"ruleId":"1964","severity":1,"message":"2008","line":1583,"column":97,"nodeType":"1966","messageId":"1967","endLine":1583,"endColumn":98,"suggestions":"2010"},{"ruleId":"1915","severity":1,"message":"2011","line":1662,"column":13,"nodeType":"1917","messageId":"1918","endLine":1662,"endColumn":34},{"ruleId":"1915","severity":1,"message":"2012","line":1663,"column":13,"nodeType":"1917","messageId":"1918","endLine":1663,"endColumn":34},{"ruleId":"1915","severity":1,"message":"2013","line":1664,"column":13,"nodeType":"1917","messageId":"1918","endLine":1664,"endColumn":34},{"ruleId":"2014","severity":1,"message":"2015","line":1696,"column":104,"nodeType":"2016","messageId":"2017","endLine":1696,"endColumn":106},{"ruleId":"1997","severity":1,"message":"1998","line":1839,"column":28,"nodeType":"1999","messageId":"2000","endLine":1839,"endColumn":30},{"ruleId":"1997","severity":1,"message":"1998","line":1839,"column":38,"nodeType":"1999","messageId":"2000","endLine":1839,"endColumn":40},{"ruleId":"1997","severity":1,"message":"1998","line":1850,"column":89,"nodeType":"1999","messageId":"2000","endLine":1850,"endColumn":91},{"ruleId":"1997","severity":1,"message":"1998","line":1850,"column":97,"nodeType":"1999","messageId":"2000","endLine":1850,"endColumn":99},{"ruleId":"1997","severity":1,"message":"1998","line":1851,"column":50,"nodeType":"1999","messageId":"2000","endLine":1851,"endColumn":52},{"ruleId":"1997","severity":1,"message":"1998","line":1851,"column":63,"nodeType":"1999","messageId":"2000","endLine":1851,"endColumn":65},{"ruleId":"1915","severity":1,"message":"1972","line":1869,"column":31,"nodeType":"1917","messageId":"1918","endLine":1869,"endColumn":32},{"ruleId":"1915","severity":1,"message":"2004","line":1990,"column":62,"nodeType":"1917","messageId":"1918","endLine":1990,"endColumn":64},{"ruleId":"1915","severity":1,"message":"2005","line":1997,"column":9,"nodeType":"1917","messageId":"1918","endLine":1997,"endColumn":17},{"ruleId":"1915","severity":1,"message":"2004","line":2012,"column":64,"nodeType":"1917","messageId":"1918","endLine":2012,"endColumn":66},{"ruleId":"1915","severity":1,"message":"2005","line":2026,"column":9,"nodeType":"1917","messageId":"1918","endLine":2026,"endColumn":17},{"ruleId":"1915","severity":1,"message":"2004","line":2038,"column":64,"nodeType":"1917","messageId":"1918","endLine":2038,"endColumn":66},{"ruleId":"1915","severity":1,"message":"2005","line":2053,"column":9,"nodeType":"1917","messageId":"1918","endLine":2053,"endColumn":17},{"ruleId":"1915","severity":1,"message":"2018","line":2150,"column":5,"nodeType":"1917","messageId":"1918","endLine":2150,"endColumn":8},{"ruleId":"1915","severity":1,"message":"2019","line":2151,"column":5,"nodeType":"1917","messageId":"1918","endLine":2151,"endColumn":8},{"ruleId":"1915","severity":1,"message":"2001","line":2253,"column":63,"nodeType":"1917","messageId":"1918","endLine":2253,"endColumn":64},{"ruleId":"1997","severity":1,"message":"2020","line":2363,"column":24,"nodeType":"1999","messageId":"2000","endLine":2363,"endColumn":26},{"ruleId":"1997","severity":1,"message":"2020","line":2363,"column":57,"nodeType":"1999","messageId":"2000","endLine":2363,"endColumn":59},{"ruleId":"1915","severity":1,"message":"2001","line":2437,"column":69,"nodeType":"1917","messageId":"1918","endLine":2437,"endColumn":70},{"ruleId":"1997","severity":1,"message":"2020","line":2570,"column":16,"nodeType":"1999","messageId":"2000","endLine":2570,"endColumn":18},{"ruleId":"1997","severity":1,"message":"2020","line":2570,"column":27,"nodeType":"1999","messageId":"2000","endLine":2570,"endColumn":29},{"ruleId":"1915","severity":1,"message":"2021","line":3051,"column":54,"nodeType":"1917","messageId":"1918","endLine":3051,"endColumn":56},{"ruleId":"1915","severity":1,"message":"2022","line":3051,"column":76,"nodeType":"1917","messageId":"1918","endLine":3051,"endColumn":78},{"ruleId":"1915","severity":1,"message":"2023","line":3051,"column":98,"nodeType":"1917","messageId":"1918","endLine":3051,"endColumn":100},{"ruleId":"1915","severity":1,"message":"2024","line":3153,"column":9,"nodeType":"1917","messageId":"1918","endLine":3153,"endColumn":22},{"ruleId":"1915","severity":1,"message":"2025","line":3194,"column":6,"nodeType":"1917","messageId":"1918","endLine":3194,"endColumn":14},{"ruleId":"1915","severity":1,"message":"2026","line":3195,"column":6,"nodeType":"1917","messageId":"1918","endLine":3195,"endColumn":14},{"ruleId":"1915","severity":1,"message":"2027","line":3196,"column":6,"nodeType":"1917","messageId":"1918","endLine":3196,"endColumn":14},{"ruleId":"1915","severity":1,"message":"2028","line":3205,"column":6,"nodeType":"1917","messageId":"1918","endLine":3205,"endColumn":22},{"ruleId":"1915","severity":1,"message":"2001","line":3239,"column":54,"nodeType":"1917","messageId":"1918","endLine":3239,"endColumn":55},{"ruleId":"1915","severity":1,"message":"2029","line":3381,"column":6,"nodeType":"1917","messageId":"1918","endLine":3381,"endColumn":35},{"ruleId":"1915","severity":1,"message":"2030","line":195,"column":13,"nodeType":"1917","messageId":"1918","endLine":195,"endColumn":26},{"ruleId":"1983","severity":1,"message":"1984","line":209,"column":9,"nodeType":"2031","messageId":"1986","endLine":209,"endColumn":34},{"ruleId":"1997","severity":1,"message":"2020","line":286,"column":22,"nodeType":"1999","messageId":"2000","endLine":286,"endColumn":24},{"ruleId":"1997","severity":1,"message":"2020","line":286,"column":41,"nodeType":"1999","messageId":"2000","endLine":286,"endColumn":43},{"ruleId":"1997","severity":1,"message":"2020","line":287,"column":22,"nodeType":"1999","messageId":"2000","endLine":287,"endColumn":24},{"ruleId":"1997","severity":1,"message":"2020","line":287,"column":41,"nodeType":"1999","messageId":"2000","endLine":287,"endColumn":43},{"ruleId":"1997","severity":1,"message":"2020","line":288,"column":22,"nodeType":"1999","messageId":"2000","endLine":288,"endColumn":24},{"ruleId":"1997","severity":1,"message":"2020","line":288,"column":41,"nodeType":"1999","messageId":"2000","endLine":288,"endColumn":43},{"ruleId":"1997","severity":1,"message":"2020","line":289,"column":22,"nodeType":"1999","messageId":"2000","endLine":289,"endColumn":24},{"ruleId":"1997","severity":1,"message":"2020","line":289,"column":41,"nodeType":"1999","messageId":"2000","endLine":289,"endColumn":43},{"ruleId":"1997","severity":1,"message":"2020","line":290,"column":26,"nodeType":"1999","messageId":"2000","endLine":290,"endColumn":28},{"ruleId":"1997","severity":1,"message":"2020","line":290,"column":50,"nodeType":"1999","messageId":"2000","endLine":290,"endColumn":52},{"ruleId":"1997","severity":1,"message":"2020","line":291,"column":27,"nodeType":"1999","messageId":"2000","endLine":291,"endColumn":29},{"ruleId":"1997","severity":1,"message":"2020","line":291,"column":52,"nodeType":"1999","messageId":"2000","endLine":291,"endColumn":54},{"ruleId":"1915","severity":1,"message":"2032","line":450,"column":6,"nodeType":"1917","messageId":"1918","endLine":450,"endColumn":15},{"ruleId":"1915","severity":1,"message":"2033","line":470,"column":15,"nodeType":"1917","messageId":"1918","endLine":470,"endColumn":23},{"ruleId":"1915","severity":1,"message":"2034","line":472,"column":13,"nodeType":"1917","messageId":"1918","endLine":472,"endColumn":16},{"ruleId":"1983","severity":1,"message":"1984","line":619,"column":13,"nodeType":"2035","messageId":"1986","endLine":626,"endColumn":42},{"ruleId":"1915","severity":1,"message":"2036","line":631,"column":66,"nodeType":"1917","messageId":"1918","endLine":631,"endColumn":70},{"ruleId":"1983","severity":1,"message":"1984","line":806,"column":9,"nodeType":"2031","messageId":"1986","endLine":806,"endColumn":19},{"ruleId":"1955","severity":1,"message":"1956","line":922,"column":57,"nodeType":"1957","messageId":"1958","endLine":922,"endColumn":59},{"ruleId":"1915","severity":1,"message":"2037","line":13,"column":5,"nodeType":"1917","messageId":"1918","endLine":13,"endColumn":11},{"ruleId":"1915","severity":1,"message":"2038","line":34,"column":5,"nodeType":"1917","messageId":"1918","endLine":34,"endColumn":24},{"ruleId":"1915","severity":1,"message":"2039","line":43,"column":65,"nodeType":"1917","messageId":"1918","endLine":43,"endColumn":70},{"ruleId":"1915","severity":1,"message":"2040","line":48,"column":6,"nodeType":"1917","messageId":"1918","endLine":48,"endColumn":9},{"ruleId":"1915","severity":1,"message":"2041","line":61,"column":6,"nodeType":"1917","messageId":"1918","endLine":61,"endColumn":18},{"ruleId":"1915","severity":1,"message":"2042","line":436,"column":52,"nodeType":"1917","messageId":"1918","endLine":436,"endColumn":56},{"ruleId":"1983","severity":1,"message":"1984","line":502,"column":9,"nodeType":"2035","messageId":"1986","endLine":514,"endColumn":58},{"ruleId":"1983","severity":1,"message":"1984","line":520,"column":9,"nodeType":"2031","messageId":"1986","endLine":520,"endColumn":28},{"ruleId":"1983","severity":1,"message":"1984","line":585,"column":9,"nodeType":"2043","messageId":"1986","endLine":611,"endColumn":26},{"ruleId":"1915","severity":1,"message":"2044","line":761,"column":15,"nodeType":"1917","messageId":"1918","endLine":761,"endColumn":21},{"ruleId":"1915","severity":1,"message":"2044","line":778,"column":15,"nodeType":"1917","messageId":"1918","endLine":778,"endColumn":21},{"ruleId":"1915","severity":1,"message":"2044","line":801,"column":15,"nodeType":"1917","messageId":"1918","endLine":801,"endColumn":21},{"ruleId":"1915","severity":1,"message":"2044","line":821,"column":15,"nodeType":"1917","messageId":"1918","endLine":821,"endColumn":21},{"ruleId":"2045","severity":1,"message":"2046","line":857,"column":30,"nodeType":"1917","messageId":"2047","endLine":857,"endColumn":44},{"ruleId":"1915","severity":1,"message":"1951","line":19,"column":5,"nodeType":"1917","messageId":"1918","endLine":19,"endColumn":6},{"ruleId":"1915","severity":1,"message":"2048","line":168,"column":6,"nodeType":"1917","messageId":"1918","endLine":168,"endColumn":16},{"ruleId":"1915","severity":1,"message":"2049","line":170,"column":6,"nodeType":"1917","messageId":"1918","endLine":170,"endColumn":15},{"ruleId":"1915","severity":1,"message":"2050","line":203,"column":6,"nodeType":"1917","messageId":"1918","endLine":203,"endColumn":25},{"ruleId":"1915","severity":1,"message":"2051","line":205,"column":6,"nodeType":"1917","messageId":"1918","endLine":205,"endColumn":19},{"ruleId":"1915","severity":1,"message":"2052","line":606,"column":26,"nodeType":"1917","messageId":"1918","endLine":606,"endColumn":27},{"ruleId":"1915","severity":1,"message":"2053","line":2,"column":5,"nodeType":"1917","messageId":"1918","endLine":2,"endColumn":24},{"ruleId":"1915","severity":1,"message":"2054","line":4,"column":5,"nodeType":"1917","messageId":"1918","endLine":4,"endColumn":16},{"ruleId":"1915","severity":1,"message":"2055","line":5,"column":5,"nodeType":"1917","messageId":"1918","endLine":5,"endColumn":15},{"ruleId":"1915","severity":1,"message":"2056","line":8,"column":5,"nodeType":"1917","messageId":"1918","endLine":8,"endColumn":16},{"ruleId":"1915","severity":1,"message":"2057","line":32,"column":5,"nodeType":"1917","messageId":"1918","endLine":32,"endColumn":15},{"ruleId":"1915","severity":1,"message":"1944","line":35,"column":5,"nodeType":"1917","messageId":"1918","endLine":35,"endColumn":13},{"ruleId":"1915","severity":1,"message":"2058","line":54,"column":5,"nodeType":"1917","messageId":"1918","endLine":54,"endColumn":13},{"ruleId":"1915","severity":1,"message":"2059","line":141,"column":13,"nodeType":"1917","messageId":"1918","endLine":141,"endColumn":30},{"ruleId":"1992","severity":1,"message":"1993","line":349,"column":20,"nodeType":"1994","messageId":"1958","endLine":349,"endColumn":24},{"ruleId":"1915","severity":1,"message":"2060","line":499,"column":88,"nodeType":"1917","messageId":"1918","endLine":499,"endColumn":110},{"ruleId":"1997","severity":1,"message":"1998","line":507,"column":59,"nodeType":"1999","messageId":"2000","endLine":507,"endColumn":61},{"ruleId":"1997","severity":1,"message":"1998","line":507,"column":82,"nodeType":"1999","messageId":"2000","endLine":507,"endColumn":84},{"ruleId":"1915","severity":1,"message":"2061","line":568,"column":23,"nodeType":"1917","messageId":"1918","endLine":568,"endColumn":31},{"ruleId":"1915","severity":1,"message":"2062","line":739,"column":13,"nodeType":"1917","messageId":"1918","endLine":739,"endColumn":23},{"ruleId":"1915","severity":1,"message":"2063","line":769,"column":7,"nodeType":"1917","messageId":"1918","endLine":769,"endColumn":13},{"ruleId":"1915","severity":1,"message":"2064","line":6,"column":5,"nodeType":"1917","messageId":"1918","endLine":6,"endColumn":18},{"ruleId":"1915","severity":1,"message":"2065","line":9,"column":5,"nodeType":"1917","messageId":"1918","endLine":9,"endColumn":11},{"ruleId":"1915","severity":1,"message":"2066","line":11,"column":5,"nodeType":"1917","messageId":"1918","endLine":11,"endColumn":17},{"ruleId":"1915","severity":1,"message":"2067","line":12,"column":5,"nodeType":"1917","messageId":"1918","endLine":12,"endColumn":19},{"ruleId":"1915","severity":1,"message":"2068","line":15,"column":5,"nodeType":"1917","messageId":"1918","endLine":15,"endColumn":9},{"ruleId":"1915","severity":1,"message":"2069","line":18,"column":20,"nodeType":"1917","messageId":"1918","endLine":18,"endColumn":24},{"ruleId":"1915","severity":1,"message":"2070","line":19,"column":11,"nodeType":"1917","messageId":"1918","endLine":19,"endColumn":23},{"ruleId":"1915","severity":1,"message":"2071","line":20,"column":5,"nodeType":"1917","messageId":"1918","endLine":20,"endColumn":13},{"ruleId":"1915","severity":1,"message":"2058","line":21,"column":5,"nodeType":"1917","messageId":"1918","endLine":21,"endColumn":13},{"ruleId":"1915","severity":1,"message":"1916","line":22,"column":5,"nodeType":"1917","messageId":"1918","endLine":22,"endColumn":10},{"ruleId":"1915","severity":1,"message":"1919","line":22,"column":25,"nodeType":"1917","messageId":"1918","endLine":22,"endColumn":26},{"ruleId":"1915","severity":1,"message":"2072","line":50,"column":16,"nodeType":"1917","messageId":"1918","endLine":50,"endColumn":22},{"ruleId":"1915","severity":1,"message":"2073","line":54,"column":9,"nodeType":"1917","messageId":"1918","endLine":54,"endColumn":18},{"ruleId":"1915","severity":1,"message":"2074","line":56,"column":8,"nodeType":"1917","messageId":"1918","endLine":56,"endColumn":15},{"ruleId":"1997","severity":1,"message":"1998","line":217,"column":44,"nodeType":"1999","messageId":"2000","endLine":217,"endColumn":46},{"ruleId":"1997","severity":1,"message":"1998","line":217,"column":53,"nodeType":"1999","messageId":"2000","endLine":217,"endColumn":55},{"ruleId":"1915","severity":1,"message":"2075","line":400,"column":5,"nodeType":"1917","messageId":"1918","endLine":400,"endColumn":25},{"ruleId":"2076","severity":1,"message":"2077","line":677,"column":79,"nodeType":"2078","messageId":"2079","endLine":677,"endColumn":135},{"ruleId":"1964","severity":1,"message":"2080","line":707,"column":109,"nodeType":"1966","messageId":"1967","endLine":707,"endColumn":110,"suggestions":"2081"},{"ruleId":"2076","severity":1,"message":"2077","line":723,"column":29,"nodeType":"2078","messageId":"2079","endLine":723,"endColumn":93},{"ruleId":"2076","severity":1,"message":"2077","line":732,"column":29,"nodeType":"2078","messageId":"2079","endLine":732,"endColumn":72},{"ruleId":"2076","severity":1,"message":"2077","line":773,"column":38,"nodeType":"2078","messageId":"2079","endLine":773,"endColumn":66},{"ruleId":"2076","severity":1,"message":"2077","line":812,"column":30,"nodeType":"2078","messageId":"2079","endLine":812,"endColumn":58},{"ruleId":"2076","severity":1,"message":"2077","line":834,"column":57,"nodeType":"2078","messageId":"2079","endLine":834,"endColumn":85},{"ruleId":"2076","severity":1,"message":"2077","line":869,"column":63,"nodeType":"2078","messageId":"2079","endLine":869,"endColumn":90},{"ruleId":"1915","severity":1,"message":"2082","line":975,"column":17,"nodeType":"1917","messageId":"1918","endLine":975,"endColumn":22},{"ruleId":"1983","severity":1,"message":"1984","line":1002,"column":21,"nodeType":"2043","messageId":"1986","endLine":1020,"endColumn":124},{"ruleId":"1915","severity":1,"message":"2082","line":1067,"column":9,"nodeType":"1917","messageId":"1918","endLine":1067,"endColumn":14},{"ruleId":"1915","severity":1,"message":"2083","line":1068,"column":9,"nodeType":"1917","messageId":"1918","endLine":1068,"endColumn":16},{"ruleId":"1915","severity":1,"message":"2084","line":1168,"column":10,"nodeType":"1917","messageId":"1918","endLine":1168,"endColumn":23},{"ruleId":"1915","severity":1,"message":"2012","line":1204,"column":13,"nodeType":"1917","messageId":"1918","endLine":1204,"endColumn":14},{"ruleId":"1915","severity":1,"message":"2085","line":5,"column":5,"nodeType":"1917","messageId":"1918","endLine":5,"endColumn":14},{"ruleId":"1915","severity":1,"message":"2086","line":40,"column":25,"nodeType":"1917","messageId":"1918","endLine":40,"endColumn":32},{"ruleId":"1915","severity":1,"message":"2001","line":40,"column":85,"nodeType":"1917","messageId":"1918","endLine":40,"endColumn":86},{"ruleId":"1915","severity":1,"message":"2087","line":6,"column":23,"nodeType":"1917","messageId":"1918","endLine":6,"endColumn":44},{"ruleId":"1915","severity":1,"message":"2088","line":7,"column":24,"nodeType":"1917","messageId":"1918","endLine":7,"endColumn":34},{"ruleId":"1915","severity":1,"message":"2089","line":7,"column":67,"nodeType":"1917","messageId":"1918","endLine":7,"endColumn":82},{"ruleId":"1915","severity":1,"message":"2090","line":9,"column":43,"nodeType":"1917","messageId":"1918","endLine":9,"endColumn":50},{"ruleId":"1915","severity":1,"message":"2091","line":10,"column":45,"nodeType":"1917","messageId":"1918","endLine":10,"endColumn":53},{"ruleId":"1915","severity":1,"message":"2092","line":11,"column":13,"nodeType":"1917","messageId":"1918","endLine":11,"endColumn":17},{"ruleId":"1915","severity":1,"message":"2093","line":13,"column":9,"nodeType":"1917","messageId":"1918","endLine":13,"endColumn":20},{"ruleId":"1915","severity":1,"message":"2094","line":13,"column":22,"nodeType":"1917","messageId":"1918","endLine":13,"endColumn":42},{"ruleId":"1915","severity":1,"message":"2095","line":14,"column":9,"nodeType":"1917","messageId":"1918","endLine":14,"endColumn":24},{"ruleId":"1915","severity":1,"message":"2096","line":14,"column":26,"nodeType":"1917","messageId":"1918","endLine":14,"endColumn":50},{"ruleId":"1915","severity":1,"message":"2097","line":15,"column":15,"nodeType":"1917","messageId":"1918","endLine":15,"endColumn":28},{"ruleId":"1915","severity":1,"message":"2098","line":16,"column":9,"nodeType":"1917","messageId":"1918","endLine":16,"endColumn":21},{"ruleId":"1915","severity":1,"message":"1951","line":17,"column":9,"nodeType":"1917","messageId":"1918","endLine":17,"endColumn":10},{"ruleId":"1915","severity":1,"message":"2099","line":18,"column":10,"nodeType":"1917","messageId":"1918","endLine":18,"endColumn":17},{"ruleId":"1915","severity":1,"message":"2100","line":16,"column":5,"nodeType":"1917","messageId":"1918","endLine":16,"endColumn":22},{"ruleId":"1915","severity":1,"message":"2101","line":17,"column":5,"nodeType":"1917","messageId":"1918","endLine":17,"endColumn":16},{"ruleId":"1915","severity":1,"message":"2102","line":22,"column":5,"nodeType":"1917","messageId":"1918","endLine":22,"endColumn":10},{"ruleId":"1915","severity":1,"message":"2103","line":34,"column":5,"nodeType":"1917","messageId":"1918","endLine":34,"endColumn":12},{"ruleId":"1915","severity":1,"message":"2104","line":48,"column":8,"nodeType":"1917","messageId":"1918","endLine":48,"endColumn":21},{"ruleId":"1915","severity":1,"message":"2105","line":49,"column":9,"nodeType":"1917","messageId":"1918","endLine":49,"endColumn":14},{"ruleId":"1915","severity":1,"message":"2106","line":534,"column":15,"nodeType":"1917","messageId":"1918","endLine":534,"endColumn":21},{"ruleId":"1983","severity":1,"message":"1984","line":600,"column":9,"nodeType":"2031","messageId":"1986","endLine":600,"endColumn":23},{"ruleId":"1915","severity":1,"message":"2107","line":619,"column":13,"nodeType":"1917","messageId":"1918","endLine":619,"endColumn":18},{"ruleId":"1983","severity":1,"message":"1984","line":638,"column":9,"nodeType":"2031","messageId":"1986","endLine":638,"endColumn":20},{"ruleId":"1997","severity":1,"message":"1998","line":732,"column":33,"nodeType":"1999","messageId":"2000","endLine":732,"endColumn":35},{"ruleId":"1997","severity":1,"message":"1998","line":732,"column":54,"nodeType":"1999","messageId":"2000","endLine":732,"endColumn":56},{"ruleId":"1964","severity":1,"message":"2108","line":745,"column":27,"nodeType":"1966","messageId":"1967","endLine":745,"endColumn":28,"suggestions":"2109"},{"ruleId":"1964","severity":1,"message":"2110","line":745,"column":29,"nodeType":"1966","messageId":"1967","endLine":745,"endColumn":30,"suggestions":"2111"},{"ruleId":"1915","severity":1,"message":"1972","line":778,"column":81,"nodeType":"1917","messageId":"1918","endLine":778,"endColumn":82},{"ruleId":"1992","severity":1,"message":"1993","line":816,"column":13,"nodeType":"1994","messageId":"1958","endLine":816,"endColumn":17},{"ruleId":"2076","severity":1,"message":"2077","line":818,"column":26,"nodeType":"2078","messageId":"2079","endLine":818,"endColumn":97},{"ruleId":"1992","severity":1,"message":"1993","line":921,"column":20,"nodeType":"1994","messageId":"1958","endLine":921,"endColumn":24},{"ruleId":"2076","severity":1,"message":"2077","line":948,"column":19,"nodeType":"2078","messageId":"2079","endLine":948,"endColumn":151},{"ruleId":"1992","severity":1,"message":"1993","line":954,"column":20,"nodeType":"1994","messageId":"1958","endLine":954,"endColumn":24},{"ruleId":"2076","severity":1,"message":"2077","line":963,"column":17,"nodeType":"2078","messageId":"2079","endLine":963,"endColumn":61},{"ruleId":"1992","severity":1,"message":"1993","line":969,"column":36,"nodeType":"1994","messageId":"1958","endLine":969,"endColumn":40},{"ruleId":"1997","severity":1,"message":"1998","line":1014,"column":29,"nodeType":"1999","messageId":"2000","endLine":1014,"endColumn":31},{"ruleId":"1997","severity":1,"message":"1998","line":1014,"column":38,"nodeType":"1999","messageId":"2000","endLine":1014,"endColumn":40},{"ruleId":"1997","severity":1,"message":"2020","line":1285,"column":24,"nodeType":"1999","messageId":"2000","endLine":1285,"endColumn":26},{"ruleId":"1997","severity":1,"message":"2020","line":1285,"column":38,"nodeType":"1999","messageId":"2000","endLine":1285,"endColumn":40},{"ruleId":"1915","severity":1,"message":"1972","line":1320,"column":27,"nodeType":"1917","messageId":"1918","endLine":1320,"endColumn":28},{"ruleId":"1915","severity":1,"message":"2112","line":1365,"column":13,"nodeType":"1917","messageId":"1918","endLine":1365,"endColumn":14},{"ruleId":"1915","severity":1,"message":"2113","line":1379,"column":13,"nodeType":"1917","messageId":"1918","endLine":1379,"endColumn":22},{"ruleId":"1997","severity":1,"message":"2020","line":1858,"column":44,"nodeType":"1999","messageId":"2000","endLine":1858,"endColumn":46},{"ruleId":"1997","severity":1,"message":"2020","line":1858,"column":64,"nodeType":"1999","messageId":"2000","endLine":1858,"endColumn":66},{"ruleId":"1983","severity":1,"message":"1984","line":1935,"column":9,"nodeType":"2031","messageId":"1986","endLine":1935,"endColumn":26},{"ruleId":"1915","severity":1,"message":"2114","line":1991,"column":27,"nodeType":"1917","messageId":"1918","endLine":1991,"endColumn":32},{"ruleId":"1955","severity":1,"message":"1962","line":2110,"column":53,"nodeType":"1957","messageId":"1958","endLine":2110,"endColumn":55},{"ruleId":"1955","severity":1,"message":"1962","line":2115,"column":63,"nodeType":"1957","messageId":"1958","endLine":2115,"endColumn":65},{"ruleId":"1955","severity":1,"message":"1962","line":2120,"column":58,"nodeType":"1957","messageId":"1958","endLine":2120,"endColumn":60},{"ruleId":"1955","severity":1,"message":"1962","line":2125,"column":52,"nodeType":"1957","messageId":"1958","endLine":2125,"endColumn":54},{"ruleId":"1955","severity":1,"message":"1962","line":2130,"column":54,"nodeType":"1957","messageId":"1958","endLine":2130,"endColumn":56},{"ruleId":"1955","severity":1,"message":"1962","line":2133,"column":55,"nodeType":"1957","messageId":"1958","endLine":2133,"endColumn":57},{"ruleId":"1955","severity":1,"message":"1962","line":2138,"column":53,"nodeType":"1957","messageId":"1958","endLine":2138,"endColumn":55},{"ruleId":"1955","severity":1,"message":"1962","line":2143,"column":52,"nodeType":"1957","messageId":"1958","endLine":2143,"endColumn":54},{"ruleId":"1955","severity":1,"message":"1962","line":2148,"column":53,"nodeType":"1957","messageId":"1958","endLine":2148,"endColumn":55},{"ruleId":"1955","severity":1,"message":"1962","line":2153,"column":55,"nodeType":"1957","messageId":"1958","endLine":2153,"endColumn":57},{"ruleId":"1955","severity":1,"message":"1962","line":2158,"column":55,"nodeType":"1957","messageId":"1958","endLine":2158,"endColumn":57},{"ruleId":"1955","severity":1,"message":"1962","line":2161,"column":55,"nodeType":"1957","messageId":"1958","endLine":2161,"endColumn":57},{"ruleId":"1955","severity":1,"message":"1962","line":2166,"column":56,"nodeType":"1957","messageId":"1958","endLine":2166,"endColumn":58},{"ruleId":"1955","severity":1,"message":"1962","line":2171,"column":43,"nodeType":"1957","messageId":"1958","endLine":2171,"endColumn":45},{"ruleId":"1955","severity":1,"message":"1956","line":2179,"column":39,"nodeType":"1957","messageId":"1958","endLine":2179,"endColumn":41},{"ruleId":"1955","severity":1,"message":"1962","line":2184,"column":41,"nodeType":"1957","messageId":"1958","endLine":2184,"endColumn":43},{"ruleId":"1955","severity":1,"message":"1962","line":2185,"column":41,"nodeType":"1957","messageId":"1958","endLine":2185,"endColumn":43},{"ruleId":"1955","severity":1,"message":"1962","line":2186,"column":41,"nodeType":"1957","messageId":"1958","endLine":2186,"endColumn":43},{"ruleId":"1964","severity":1,"message":"2080","line":2260,"column":98,"nodeType":"1966","messageId":"1967","endLine":2260,"endColumn":99,"suggestions":"2115"},{"ruleId":"1964","severity":1,"message":"2116","line":2260,"column":100,"nodeType":"1966","messageId":"1967","endLine":2260,"endColumn":101,"suggestions":"2117"},{"ruleId":"2118","severity":1,"message":"2119","line":2430,"column":38,"nodeType":"2016","messageId":"2120","endLine":2439,"endColumn":18},{"ruleId":"2045","severity":1,"message":"2121","line":2584,"column":12,"nodeType":"1917","messageId":"2047","endLine":2584,"endColumn":24},{"ruleId":"2045","severity":1,"message":"2122","line":2589,"column":81,"nodeType":"1917","messageId":"2047","endLine":2589,"endColumn":96},{"ruleId":"1915","severity":1,"message":"2123","line":1,"column":8,"nodeType":"1917","messageId":"1918","endLine":1,"endColumn":17},{"ruleId":"1915","severity":1,"message":"2124","line":16,"column":5,"nodeType":"1917","messageId":"1918","endLine":16,"endColumn":27},{"ruleId":"1915","severity":1,"message":"2125","line":24,"column":5,"nodeType":"1917","messageId":"1918","endLine":24,"endColumn":12},{"ruleId":"1915","severity":1,"message":"2126","line":99,"column":25,"nodeType":"1917","messageId":"1918","endLine":99,"endColumn":40},{"ruleId":"2127","severity":1,"message":"2128","line":126,"column":13,"nodeType":"2129","messageId":"2130","endLine":126,"endColumn":64},{"ruleId":"2127","severity":1,"message":"2128","line":129,"column":13,"nodeType":"2129","messageId":"2130","endLine":129,"endColumn":26},{"ruleId":"2127","severity":1,"message":"2128","line":133,"column":13,"nodeType":"2129","messageId":"2130","endLine":133,"endColumn":38},{"ruleId":"1915","severity":1,"message":"2131","line":209,"column":15,"nodeType":"1917","messageId":"1918","endLine":209,"endColumn":22},{"ruleId":"1964","severity":1,"message":"2132","line":228,"column":83,"nodeType":"1966","messageId":"1967","endLine":228,"endColumn":84,"suggestions":"2133"},{"ruleId":"2134","severity":1,"message":"2135","line":330,"column":53,"nodeType":"1991","messageId":"2136","endLine":330,"endColumn":93},{"ruleId":"2134","severity":1,"message":"2135","line":336,"column":52,"nodeType":"1991","messageId":"2136","endLine":336,"endColumn":91},{"ruleId":"1915","severity":1,"message":"2137","line":5,"column":5,"nodeType":"1917","messageId":"1918","endLine":5,"endColumn":15},{"ruleId":"1915","severity":1,"message":"2138","line":6,"column":5,"nodeType":"1917","messageId":"1918","endLine":6,"endColumn":14},{"ruleId":"1915","severity":1,"message":"1949","line":11,"column":5,"nodeType":"1917","messageId":"1918","endLine":11,"endColumn":12},{"ruleId":"1915","severity":1,"message":"2139","line":14,"column":8,"nodeType":"1917","messageId":"1918","endLine":14,"endColumn":17},{"ruleId":"1915","severity":1,"message":"2140","line":16,"column":27,"nodeType":"1917","messageId":"1918","endLine":16,"endColumn":35},{"ruleId":"1915","severity":1,"message":"2141","line":109,"column":17,"nodeType":"1917","messageId":"1918","endLine":109,"endColumn":18},{"ruleId":"1915","severity":1,"message":"2142","line":353,"column":6,"nodeType":"1917","messageId":"1918","endLine":353,"endColumn":16},{"ruleId":"2143","severity":1,"message":"2144","line":371,"column":34,"nodeType":"1957","messageId":"2145","endLine":371,"endColumn":35},{"ruleId":"2146","severity":1,"message":"2147","line":371,"column":36,"nodeType":"1966","messageId":"2148","endLine":371,"endColumn":55},{"ruleId":"2143","severity":1,"message":"2144","line":371,"column":56,"nodeType":"1957","messageId":"2145","endLine":371,"endColumn":57},{"ruleId":"1983","severity":1,"message":"1984","line":653,"column":17,"nodeType":"2149","messageId":"1986","endLine":653,"endColumn":23},{"ruleId":"1983","severity":1,"message":"1984","line":659,"column":17,"nodeType":"2149","messageId":"1986","endLine":659,"endColumn":23},{"ruleId":"1915","severity":1,"message":"2150","line":2,"column":5,"nodeType":"1917","messageId":"1918","endLine":2,"endColumn":13},{"ruleId":"1915","severity":1,"message":"2151","line":3,"column":5,"nodeType":"1917","messageId":"1918","endLine":3,"endColumn":11},{"ruleId":"1915","severity":1,"message":"2152","line":5,"column":5,"nodeType":"1917","messageId":"1918","endLine":5,"endColumn":19},{"ruleId":"1915","severity":1,"message":"2153","line":6,"column":26,"nodeType":"1917","messageId":"1918","endLine":6,"endColumn":31},{"ruleId":"1915","severity":1,"message":"2154","line":9,"column":18,"nodeType":"1917","messageId":"1918","endLine":9,"endColumn":25},{"ruleId":"1915","severity":1,"message":"2155","line":9,"column":27,"nodeType":"1917","messageId":"1918","endLine":9,"endColumn":40},{"ruleId":"1915","severity":1,"message":"2156","line":14,"column":5,"nodeType":"1917","messageId":"1918","endLine":14,"endColumn":13},{"ruleId":"1915","severity":1,"message":"2157","line":28,"column":5,"nodeType":"1917","messageId":"1918","endLine":28,"endColumn":13},{"ruleId":"1915","severity":1,"message":"2138","line":35,"column":5,"nodeType":"1917","messageId":"1918","endLine":35,"endColumn":14},{"ruleId":"1915","severity":1,"message":"2158","line":35,"column":16,"nodeType":"1917","messageId":"1918","endLine":35,"endColumn":20},{"ruleId":"1915","severity":1,"message":"2159","line":36,"column":5,"nodeType":"1917","messageId":"1918","endLine":36,"endColumn":20},{"ruleId":"1915","severity":1,"message":"2160","line":37,"column":15,"nodeType":"1917","messageId":"1918","endLine":37,"endColumn":24},{"ruleId":"1915","severity":1,"message":"2161","line":37,"column":26,"nodeType":"1917","messageId":"1918","endLine":37,"endColumn":33},{"ruleId":"1915","severity":1,"message":"2162","line":38,"column":5,"nodeType":"1917","messageId":"1918","endLine":38,"endColumn":13},{"ruleId":"1915","severity":1,"message":"2163","line":38,"column":15,"nodeType":"1917","messageId":"1918","endLine":38,"endColumn":20},{"ruleId":"1915","severity":1,"message":"2164","line":39,"column":14,"nodeType":"1917","messageId":"1918","endLine":39,"endColumn":19},{"ruleId":"1915","severity":1,"message":"2165","line":39,"column":21,"nodeType":"1917","messageId":"1918","endLine":39,"endColumn":33},{"ruleId":"1915","severity":1,"message":"2085","line":41,"column":5,"nodeType":"1917","messageId":"1918","endLine":41,"endColumn":14},{"ruleId":"1915","severity":1,"message":"2166","line":41,"column":16,"nodeType":"1917","messageId":"1918","endLine":41,"endColumn":27},{"ruleId":"1915","severity":1,"message":"2167","line":41,"column":29,"nodeType":"1917","messageId":"1918","endLine":41,"endColumn":37},{"ruleId":"1915","severity":1,"message":"2168","line":41,"column":39,"nodeType":"1917","messageId":"1918","endLine":41,"endColumn":46},{"ruleId":"1915","severity":1,"message":"2169","line":46,"column":5,"nodeType":"1917","messageId":"1918","endLine":46,"endColumn":15},{"ruleId":"1915","severity":1,"message":"2170","line":47,"column":5,"nodeType":"1917","messageId":"1918","endLine":47,"endColumn":13},{"ruleId":"1915","severity":1,"message":"2171","line":48,"column":5,"nodeType":"1917","messageId":"1918","endLine":48,"endColumn":15},{"ruleId":"1915","severity":1,"message":"2071","line":49,"column":25,"nodeType":"1917","messageId":"1918","endLine":49,"endColumn":33},{"ruleId":"1915","severity":1,"message":"2172","line":50,"column":5,"nodeType":"1917","messageId":"1918","endLine":50,"endColumn":13},{"ruleId":"1915","severity":1,"message":"2173","line":51,"column":5,"nodeType":"1917","messageId":"1918","endLine":51,"endColumn":15},{"ruleId":"1915","severity":1,"message":"2174","line":55,"column":5,"nodeType":"1917","messageId":"1918","endLine":55,"endColumn":15},{"ruleId":"1915","severity":1,"message":"2090","line":55,"column":17,"nodeType":"1917","messageId":"1918","endLine":55,"endColumn":24},{"ruleId":"1915","severity":1,"message":"2175","line":55,"column":26,"nodeType":"1917","messageId":"1918","endLine":55,"endColumn":33},{"ruleId":"1915","severity":1,"message":"2176","line":56,"column":5,"nodeType":"1917","messageId":"1918","endLine":56,"endColumn":13},{"ruleId":"1915","severity":1,"message":"2177","line":58,"column":15,"nodeType":"1917","messageId":"1918","endLine":58,"endColumn":22},{"ruleId":"1915","severity":1,"message":"2178","line":58,"column":24,"nodeType":"1917","messageId":"1918","endLine":58,"endColumn":33},{"ruleId":"1915","severity":1,"message":"2091","line":60,"column":29,"nodeType":"1917","messageId":"1918","endLine":60,"endColumn":37},{"ruleId":"1915","severity":1,"message":"2179","line":60,"column":39,"nodeType":"1917","messageId":"1918","endLine":60,"endColumn":53},{"ruleId":"1915","severity":1,"message":"2180","line":62,"column":24,"nodeType":"1917","messageId":"1918","endLine":62,"endColumn":34},{"ruleId":"1915","severity":1,"message":"2181","line":62,"column":36,"nodeType":"1917","messageId":"1918","endLine":62,"endColumn":42},{"ruleId":"1915","severity":1,"message":"2092","line":62,"column":44,"nodeType":"1917","messageId":"1918","endLine":62,"endColumn":48},{"ruleId":"1915","severity":1,"message":"2182","line":63,"column":25,"nodeType":"1917","messageId":"1918","endLine":63,"endColumn":34},{"ruleId":"1915","severity":1,"message":"2183","line":63,"column":36,"nodeType":"1917","messageId":"1918","endLine":63,"endColumn":44},{"ruleId":"1915","severity":1,"message":"1951","line":63,"column":46,"nodeType":"1917","messageId":"1918","endLine":63,"endColumn":47},{"ruleId":"1915","severity":1,"message":"2184","line":63,"column":62,"nodeType":"1917","messageId":"1918","endLine":63,"endColumn":68},{"ruleId":"1915","severity":1,"message":"2088","line":63,"column":70,"nodeType":"1917","messageId":"1918","endLine":63,"endColumn":80},{"ruleId":"1915","severity":1,"message":"2185","line":68,"column":10,"nodeType":"1917","messageId":"1918","endLine":68,"endColumn":23},{"ruleId":"1915","severity":1,"message":"2186","line":68,"column":25,"nodeType":"1917","messageId":"1918","endLine":68,"endColumn":31},{"ruleId":"1915","severity":1,"message":"2187","line":68,"column":33,"nodeType":"1917","messageId":"1918","endLine":68,"endColumn":41},{"ruleId":"1915","severity":1,"message":"2188","line":68,"column":43,"nodeType":"1917","messageId":"1918","endLine":68,"endColumn":48},{"ruleId":"1915","severity":1,"message":"2189","line":68,"column":50,"nodeType":"1917","messageId":"1918","endLine":68,"endColumn":56},{"ruleId":"1915","severity":1,"message":"1938","line":71,"column":9,"nodeType":"1917","messageId":"1918","endLine":71,"endColumn":18},{"ruleId":"1915","severity":1,"message":"2190","line":260,"column":22,"nodeType":"1917","messageId":"1918","endLine":260,"endColumn":39},{"ruleId":"1915","severity":1,"message":"2191","line":461,"column":65,"nodeType":"1917","messageId":"1918","endLine":461,"endColumn":66},{"ruleId":"1915","severity":1,"message":"2001","line":461,"column":94,"nodeType":"1917","messageId":"1918","endLine":461,"endColumn":95},{"ruleId":"1915","severity":1,"message":"2192","line":11,"column":5,"nodeType":"1917","messageId":"1918","endLine":11,"endColumn":22},{"ruleId":"1915","severity":1,"message":"2193","line":133,"column":13,"nodeType":"1917","messageId":"1918","endLine":133,"endColumn":22},{"ruleId":"1915","severity":1,"message":"2193","line":203,"column":7,"nodeType":"1917","messageId":"1918","endLine":203,"endColumn":16},{"ruleId":"1915","severity":1,"message":"2065","line":1,"column":22,"nodeType":"1917","messageId":"1918","endLine":1,"endColumn":28},{"ruleId":"1915","severity":1,"message":"1920","line":2,"column":48,"nodeType":"1917","messageId":"1918","endLine":2,"endColumn":66},{"ruleId":"1915","severity":1,"message":"2194","line":49,"column":14,"nodeType":"1917","messageId":"1918","endLine":49,"endColumn":23},{"ruleId":"1915","severity":1,"message":"2191","line":115,"column":79,"nodeType":"1917","messageId":"1918","endLine":115,"endColumn":80},{"ruleId":"1997","severity":1,"message":"2020","line":202,"column":62,"nodeType":"1999","messageId":"2000","endLine":202,"endColumn":64},{"ruleId":"1997","severity":1,"message":"2020","line":202,"column":89,"nodeType":"1999","messageId":"2000","endLine":202,"endColumn":91},{"ruleId":"1915","severity":1,"message":"2195","line":491,"column":13,"nodeType":"1917","messageId":"1918","endLine":491,"endColumn":30},{"ruleId":"1997","severity":1,"message":"2020","line":810,"column":22,"nodeType":"1999","messageId":"2000","endLine":810,"endColumn":24},{"ruleId":"1997","severity":1,"message":"2020","line":810,"column":42,"nodeType":"1999","messageId":"2000","endLine":810,"endColumn":44},{"ruleId":"1915","severity":1,"message":"2001","line":881,"column":65,"nodeType":"1917","messageId":"1918","endLine":881,"endColumn":66},{"ruleId":"1955","severity":1,"message":"1956","line":916,"column":88,"nodeType":"1957","messageId":"1958","endLine":916,"endColumn":90},{"ruleId":"1915","severity":1,"message":"2196","line":1060,"column":17,"nodeType":"1917","messageId":"1918","endLine":1060,"endColumn":48},{"ruleId":"1915","severity":1,"message":"2191","line":1159,"column":75,"nodeType":"1917","messageId":"1918","endLine":1159,"endColumn":76},{"ruleId":"1915","severity":1,"message":"2191","line":1239,"column":73,"nodeType":"1917","messageId":"1918","endLine":1239,"endColumn":74},{"ruleId":"2118","severity":1,"message":"2197","line":1359,"column":54,"nodeType":"2016","messageId":"2120","endLine":1359,"endColumn":105},{"ruleId":"1955","severity":1,"message":"1962","line":1360,"column":27,"nodeType":"1957","messageId":"1958","endLine":1360,"endColumn":29},{"ruleId":"1955","severity":1,"message":"1962","line":1361,"column":30,"nodeType":"1957","messageId":"1958","endLine":1361,"endColumn":32},{"ruleId":"1997","severity":1,"message":"1998","line":1368,"column":58,"nodeType":"1999","messageId":"2000","endLine":1368,"endColumn":60},{"ruleId":"1997","severity":1,"message":"1998","line":1369,"column":36,"nodeType":"1999","messageId":"2000","endLine":1369,"endColumn":38},{"ruleId":"1915","severity":1,"message":"2086","line":1471,"column":22,"nodeType":"1917","messageId":"1918","endLine":1471,"endColumn":29},{"ruleId":"1915","severity":1,"message":"2001","line":1471,"column":63,"nodeType":"1917","messageId":"1918","endLine":1471,"endColumn":64},{"ruleId":"1915","severity":1,"message":"2086","line":1559,"column":27,"nodeType":"1917","messageId":"1918","endLine":1559,"endColumn":34},{"ruleId":"1915","severity":1,"message":"2001","line":1559,"column":68,"nodeType":"1917","messageId":"1918","endLine":1559,"endColumn":69},{"ruleId":"2127","severity":1,"message":"2128","line":1747,"column":13,"nodeType":"2129","messageId":"2130","endLine":1747,"endColumn":44},{"ruleId":"1915","severity":1,"message":"2198","line":2020,"column":13,"nodeType":"1917","messageId":"1918","endLine":2020,"endColumn":29},{"ruleId":"1915","severity":1,"message":"2199","line":2340,"column":18,"nodeType":"1917","messageId":"1918","endLine":2340,"endColumn":34},{"ruleId":"1915","severity":1,"message":"2200","line":2353,"column":13,"nodeType":"1917","messageId":"1918","endLine":2353,"endColumn":25},{"ruleId":"1915","severity":1,"message":"2201","line":2394,"column":13,"nodeType":"1917","messageId":"1918","endLine":2394,"endColumn":32},{"ruleId":"1915","severity":1,"message":"2202","line":2500,"column":17,"nodeType":"1917","messageId":"1918","endLine":2500,"endColumn":26},{"ruleId":"1915","severity":1,"message":"2203","line":2575,"column":21,"nodeType":"1917","messageId":"1918","endLine":2575,"endColumn":29},{"ruleId":"1915","severity":1,"message":"2086","line":2760,"column":20,"nodeType":"1917","messageId":"1918","endLine":2760,"endColumn":27},{"ruleId":"1915","severity":1,"message":"2001","line":2760,"column":63,"nodeType":"1917","messageId":"1918","endLine":2760,"endColumn":64},{"ruleId":"1915","severity":1,"message":"2204","line":1,"column":31,"nodeType":"1917","messageId":"1918","endLine":1,"endColumn":44},{"ruleId":"1915","severity":1,"message":"2205","line":8,"column":5,"nodeType":"1917","messageId":"1918","endLine":8,"endColumn":9},{"ruleId":"1915","severity":1,"message":"1987","line":13,"column":14,"nodeType":"1917","messageId":"1918","endLine":13,"endColumn":27},{"ruleId":"1915","severity":1,"message":"2192","line":15,"column":68,"nodeType":"1917","messageId":"1918","endLine":15,"endColumn":85},{"ruleId":"1915","severity":1,"message":"2206","line":16,"column":37,"nodeType":"1917","messageId":"1918","endLine":16,"endColumn":42},{"ruleId":"2207","severity":1,"message":"2208","line":168,"column":5,"nodeType":"2209","messageId":"2210","endLine":172,"endColumn":6},{"ruleId":"1915","severity":1,"message":"2211","line":4,"column":12,"nodeType":"1917","messageId":"1918","endLine":4,"endColumn":22},{"ruleId":"1915","severity":1,"message":"2212","line":15,"column":18,"nodeType":"1917","messageId":"1918","endLine":15,"endColumn":29},{"ruleId":"1915","severity":1,"message":"2213","line":22,"column":11,"nodeType":"1917","messageId":"1918","endLine":22,"endColumn":16},{"ruleId":"1915","severity":1,"message":"2214","line":22,"column":30,"nodeType":"1917","messageId":"1918","endLine":22,"endColumn":43},{"ruleId":"1915","severity":1,"message":"2071","line":25,"column":25,"nodeType":"1917","messageId":"1918","endLine":25,"endColumn":33},{"ruleId":"1915","severity":1,"message":"2215","line":27,"column":5,"nodeType":"1917","messageId":"1918","endLine":27,"endColumn":14},{"ruleId":"1915","severity":1,"message":"1987","line":30,"column":15,"nodeType":"1917","messageId":"1918","endLine":30,"endColumn":28},{"ruleId":"1915","severity":1,"message":"2216","line":38,"column":14,"nodeType":"1917","messageId":"1918","endLine":38,"endColumn":29},{"ruleId":"1915","severity":1,"message":"2217","line":42,"column":8,"nodeType":"1917","messageId":"1918","endLine":42,"endColumn":11},{"ruleId":"1915","severity":1,"message":"2061","line":1445,"column":39,"nodeType":"1917","messageId":"1918","endLine":1445,"endColumn":47},{"ruleId":"1915","severity":1,"message":"2218","line":1496,"column":21,"nodeType":"1917","messageId":"1918","endLine":1496,"endColumn":35},{"ruleId":"1915","severity":1,"message":"2219","line":4,"column":5,"nodeType":"1917","messageId":"1918","endLine":4,"endColumn":17},{"ruleId":"1915","severity":1,"message":"2220","line":5,"column":5,"nodeType":"1917","messageId":"1918","endLine":5,"endColumn":23},{"ruleId":"1915","severity":1,"message":"2221","line":11,"column":5,"nodeType":"1917","messageId":"1918","endLine":11,"endColumn":18},{"ruleId":"1915","severity":1,"message":"2222","line":14,"column":5,"nodeType":"1917","messageId":"1918","endLine":14,"endColumn":19},{"ruleId":"1915","severity":1,"message":"2093","line":25,"column":12,"nodeType":"1917","messageId":"1918","endLine":25,"endColumn":23},{"ruleId":"1915","severity":1,"message":"2223","line":76,"column":9,"nodeType":"1917","messageId":"1918","endLine":76,"endColumn":29},{"ruleId":"1915","severity":1,"message":"1938","line":78,"column":16,"nodeType":"1917","messageId":"1918","endLine":78,"endColumn":25},{"ruleId":"1915","severity":1,"message":"2001","line":129,"column":79,"nodeType":"1917","messageId":"1918","endLine":129,"endColumn":80},{"ruleId":"1915","severity":1,"message":"2224","line":178,"column":13,"nodeType":"1917","messageId":"1918","endLine":178,"endColumn":22},{"ruleId":"1915","severity":1,"message":"2225","line":179,"column":13,"nodeType":"1917","messageId":"1918","endLine":179,"endColumn":24},{"ruleId":"1983","severity":1,"message":"1984","line":235,"column":17,"nodeType":"2031","messageId":"1986","endLine":235,"endColumn":30},{"ruleId":"1983","severity":1,"message":"1984","line":332,"column":9,"nodeType":"2031","messageId":"1986","endLine":332,"endColumn":19},{"ruleId":"1915","severity":1,"message":"2226","line":336,"column":15,"nodeType":"1917","messageId":"1918","endLine":336,"endColumn":29},{"ruleId":"1915","severity":1,"message":"2227","line":340,"column":18,"nodeType":"1917","messageId":"1918","endLine":340,"endColumn":25},{"ruleId":"1915","severity":1,"message":"2228","line":594,"column":21,"nodeType":"1917","messageId":"1918","endLine":594,"endColumn":26},{"ruleId":"1915","severity":1,"message":"2001","line":785,"column":75,"nodeType":"1917","messageId":"1918","endLine":785,"endColumn":76},{"ruleId":"1955","severity":1,"message":"1962","line":1087,"column":35,"nodeType":"1957","messageId":"1958","endLine":1087,"endColumn":37},{"ruleId":"2229","severity":1,"message":"2230","line":1170,"column":13,"nodeType":"1957","messageId":"2231","endLine":1170,"endColumn":48},{"ruleId":"1915","severity":1,"message":"2191","line":1353,"column":69,"nodeType":"1917","messageId":"1918","endLine":1353,"endColumn":70},{"ruleId":"1915","severity":1,"message":"2232","line":1426,"column":21,"nodeType":"1917","messageId":"1918","endLine":1426,"endColumn":26},{"ruleId":"1915","severity":1,"message":"2191","line":1668,"column":73,"nodeType":"1917","messageId":"1918","endLine":1668,"endColumn":74},{"ruleId":"1992","severity":1,"message":"1993","line":1745,"column":34,"nodeType":"1994","messageId":"1958","endLine":1745,"endColumn":38},{"ruleId":"1915","severity":1,"message":"2191","line":1877,"column":73,"nodeType":"1917","messageId":"1918","endLine":1877,"endColumn":74},{"ruleId":"1915","severity":1,"message":"2191","line":2034,"column":92,"nodeType":"1917","messageId":"1918","endLine":2034,"endColumn":93},{"ruleId":"1915","severity":1,"message":"2233","line":2341,"column":13,"nodeType":"1917","messageId":"1918","endLine":2341,"endColumn":26},{"ruleId":"1915","severity":1,"message":"2232","line":2366,"column":21,"nodeType":"1917","messageId":"1918","endLine":2366,"endColumn":26},{"ruleId":"2234","severity":1,"message":"2235","line":2451,"column":32,"nodeType":"2236","messageId":"2237","endLine":2451,"endColumn":39,"fix":"2238"},{"ruleId":"1915","severity":1,"message":"2239","line":2523,"column":13,"nodeType":"1917","messageId":"1918","endLine":2523,"endColumn":21},{"ruleId":"1915","severity":1,"message":"2240","line":2767,"column":13,"nodeType":"1917","messageId":"1918","endLine":2767,"endColumn":19},{"ruleId":"1915","severity":1,"message":"2191","line":2953,"column":71,"nodeType":"1917","messageId":"1918","endLine":2953,"endColumn":72},{"ruleId":"1915","severity":1,"message":"2191","line":3052,"column":5,"nodeType":"1917","messageId":"1918","endLine":3052,"endColumn":6},{"ruleId":"1915","severity":1,"message":"2241","line":3144,"column":13,"nodeType":"1917","messageId":"1918","endLine":3144,"endColumn":16},{"ruleId":"1915","severity":1,"message":"2191","line":3354,"column":73,"nodeType":"1917","messageId":"1918","endLine":3354,"endColumn":74},{"ruleId":"1915","severity":1,"message":"2242","line":3593,"column":10,"nodeType":"1917","messageId":"1918","endLine":3593,"endColumn":22},{"ruleId":"1915","severity":1,"message":"2243","line":3596,"column":10,"nodeType":"1917","messageId":"1918","endLine":3596,"endColumn":28},{"ruleId":"1915","severity":1,"message":"2191","line":3681,"column":74,"nodeType":"1917","messageId":"1918","endLine":3681,"endColumn":75},{"ruleId":"1915","severity":1,"message":"2191","line":3842,"column":77,"nodeType":"1917","messageId":"1918","endLine":3842,"endColumn":78},{"ruleId":"1915","severity":1,"message":"2191","line":3983,"column":75,"nodeType":"1917","messageId":"1918","endLine":3983,"endColumn":76},{"ruleId":"1915","severity":1,"message":"2244","line":4120,"column":6,"nodeType":"1917","messageId":"1918","endLine":4120,"endColumn":20},{"ruleId":"1915","severity":1,"message":"2245","line":4121,"column":6,"nodeType":"1917","messageId":"1918","endLine":4121,"endColumn":20},{"ruleId":"1915","severity":1,"message":"2246","line":4183,"column":26,"nodeType":"1917","messageId":"1918","endLine":4183,"endColumn":28},{"ruleId":"1915","severity":1,"message":"2021","line":4183,"column":34,"nodeType":"1917","messageId":"1918","endLine":4183,"endColumn":36},{"ruleId":"1915","severity":1,"message":"2191","line":4258,"column":65,"nodeType":"1917","messageId":"1918","endLine":4258,"endColumn":66},{"ruleId":"1915","severity":1,"message":"2001","line":4258,"column":94,"nodeType":"1917","messageId":"1918","endLine":4258,"endColumn":95},{"ruleId":"2247","severity":1,"message":"2248","line":4618,"column":69,"nodeType":"1917","messageId":"1958","endLine":4618,"endColumn":74,"fix":"2249"},{"ruleId":"2247","severity":1,"message":"2248","line":4621,"column":53,"nodeType":"1917","messageId":"1958","endLine":4621,"endColumn":58,"fix":"2250"},{"ruleId":"2247","severity":1,"message":"2248","line":4624,"column":75,"nodeType":"1917","messageId":"1958","endLine":4624,"endColumn":80,"fix":"2251"},{"ruleId":"2247","severity":1,"message":"2248","line":4626,"column":61,"nodeType":"1917","messageId":"1958","endLine":4626,"endColumn":66,"fix":"2252"},{"ruleId":"1915","severity":1,"message":"2253","line":4701,"column":17,"nodeType":"1917","messageId":"1918","endLine":4701,"endColumn":30},{"ruleId":"1997","severity":1,"message":"1998","line":4956,"column":46,"nodeType":"1999","messageId":"2000","endLine":4956,"endColumn":48},{"ruleId":"1997","severity":1,"message":"1998","line":4956,"column":62,"nodeType":"1999","messageId":"2000","endLine":4956,"endColumn":64},{"ruleId":"1915","severity":1,"message":"2191","line":5028,"column":96,"nodeType":"1917","messageId":"1918","endLine":5028,"endColumn":97},{"ruleId":"2207","severity":1,"message":"2208","line":5069,"column":5,"nodeType":"2209","messageId":"2210","endLine":5071,"endColumn":6},{"ruleId":"1915","severity":1,"message":"2191","line":5077,"column":61,"nodeType":"1917","messageId":"1918","endLine":5077,"endColumn":62},{"ruleId":"1915","severity":1,"message":"2191","line":5128,"column":67,"nodeType":"1917","messageId":"1918","endLine":5128,"endColumn":68},{"ruleId":"2014","severity":1,"message":"2015","line":5183,"column":92,"nodeType":"2016","messageId":"2017","endLine":5183,"endColumn":94},{"ruleId":"1915","severity":1,"message":"2254","line":5389,"column":13,"nodeType":"1917","messageId":"1918","endLine":5389,"endColumn":26},{"ruleId":"1915","severity":1,"message":"2191","line":5497,"column":65,"nodeType":"1917","messageId":"1918","endLine":5497,"endColumn":66},{"ruleId":"1915","severity":1,"message":"2255","line":5678,"column":13,"nodeType":"1917","messageId":"1918","endLine":5678,"endColumn":30},{"ruleId":"2076","severity":1,"message":"2077","line":6041,"column":39,"nodeType":"2078","messageId":"2079","endLine":6041,"endColumn":117},{"ruleId":"1915","severity":1,"message":"2256","line":6254,"column":21,"nodeType":"1917","messageId":"1918","endLine":6254,"endColumn":42},{"ruleId":"1915","severity":1,"message":"2257","line":6257,"column":51,"nodeType":"1917","messageId":"1918","endLine":6257,"endColumn":64},{"ruleId":"2076","severity":1,"message":"2077","line":6414,"column":40,"nodeType":"2078","messageId":"2079","endLine":6414,"endColumn":121},{"ruleId":"1983","severity":1,"message":"1984","line":6460,"column":9,"nodeType":"2035","messageId":"1986","endLine":6496,"endColumn":21},{"ruleId":"1997","severity":1,"message":"1998","line":6468,"column":27,"nodeType":"1999","messageId":"2000","endLine":6468,"endColumn":29},{"ruleId":"1997","severity":1,"message":"1998","line":6468,"column":36,"nodeType":"1999","messageId":"2000","endLine":6468,"endColumn":38},{"ruleId":"1915","severity":1,"message":"2258","line":6488,"column":25,"nodeType":"1917","messageId":"1918","endLine":6488,"endColumn":29},{"ruleId":"1915","severity":1,"message":"2259","line":6538,"column":13,"nodeType":"1917","messageId":"1918","endLine":6538,"endColumn":26},{"ruleId":"1997","severity":1,"message":"1998","line":6538,"column":41,"nodeType":"1999","messageId":"2000","endLine":6538,"endColumn":43},{"ruleId":"1997","severity":1,"message":"1998","line":6538,"column":56,"nodeType":"1999","messageId":"2000","endLine":6538,"endColumn":58},{"ruleId":"1915","severity":1,"message":"1951","line":7,"column":21,"nodeType":"1917","messageId":"1918","endLine":7,"endColumn":22},{"ruleId":"1955","severity":1,"message":"1962","line":110,"column":98,"nodeType":"1957","messageId":"1958","endLine":110,"endColumn":100},{"ruleId":"1955","severity":1,"message":"1962","line":129,"column":74,"nodeType":"1957","messageId":"1958","endLine":129,"endColumn":76},{"ruleId":"1915","severity":1,"message":"1951","line":1,"column":35,"nodeType":"1917","messageId":"1918","endLine":1,"endColumn":36},{"ruleId":"1955","severity":1,"message":"1956","line":74,"column":42,"nodeType":"1957","messageId":"1958","endLine":74,"endColumn":44},{"ruleId":"1915","severity":1,"message":"2152","line":2,"column":5,"nodeType":"1917","messageId":"1918","endLine":2,"endColumn":19},{"ruleId":"1915","severity":1,"message":"1944","line":3,"column":5,"nodeType":"1917","messageId":"1918","endLine":3,"endColumn":13},{"ruleId":"1915","severity":1,"message":"2260","line":4,"column":17,"nodeType":"1917","messageId":"1918","endLine":4,"endColumn":26},{"ruleId":"1915","severity":1,"message":"2261","line":4,"column":48,"nodeType":"1917","messageId":"1918","endLine":4,"endColumn":58},{"ruleId":"1915","severity":1,"message":"2262","line":5,"column":13,"nodeType":"1917","messageId":"1918","endLine":5,"endColumn":31},{"ruleId":"1915","severity":1,"message":"2263","line":6,"column":5,"nodeType":"1917","messageId":"1918","endLine":6,"endColumn":17},{"ruleId":"1915","severity":1,"message":"2159","line":7,"column":5,"nodeType":"1917","messageId":"1918","endLine":7,"endColumn":20},{"ruleId":"1915","severity":1,"message":"2264","line":8,"column":5,"nodeType":"1917","messageId":"1918","endLine":8,"endColumn":16},{"ruleId":"1915","severity":1,"message":"2265","line":9,"column":5,"nodeType":"1917","messageId":"1918","endLine":9,"endColumn":12},{"ruleId":"1915","severity":1,"message":"2266","line":10,"column":5,"nodeType":"1917","messageId":"1918","endLine":10,"endColumn":15},{"ruleId":"1915","severity":1,"message":"2085","line":11,"column":5,"nodeType":"1917","messageId":"1918","endLine":11,"endColumn":14},{"ruleId":"1915","severity":1,"message":"2267","line":11,"column":16,"nodeType":"1917","messageId":"1918","endLine":11,"endColumn":22},{"ruleId":"1915","severity":1,"message":"2268","line":12,"column":30,"nodeType":"1917","messageId":"1918","endLine":12,"endColumn":36},{"ruleId":"1915","severity":1,"message":"2124","line":12,"column":66,"nodeType":"1917","messageId":"1918","endLine":12,"endColumn":88},{"ruleId":"1915","severity":1,"message":"1950","line":12,"column":90,"nodeType":"1917","messageId":"1918","endLine":12,"endColumn":95},{"ruleId":"1915","severity":1,"message":"1951","line":13,"column":5,"nodeType":"1917","messageId":"1918","endLine":13,"endColumn":6},{"ruleId":"1915","severity":1,"message":"2269","line":15,"column":9,"nodeType":"1917","messageId":"1918","endLine":15,"endColumn":22},{"ruleId":"1915","severity":1,"message":"2270","line":15,"column":24,"nodeType":"1917","messageId":"1918","endLine":15,"endColumn":38},{"ruleId":"1915","severity":1,"message":"2271","line":15,"column":40,"nodeType":"1917","messageId":"1918","endLine":15,"endColumn":51},{"ruleId":"1915","severity":1,"message":"2272","line":15,"column":53,"nodeType":"1917","messageId":"1918","endLine":15,"endColumn":66},{"ruleId":"1915","severity":1,"message":"2273","line":127,"column":45,"nodeType":"1917","messageId":"1918","endLine":127,"endColumn":46},{"ruleId":"1915","severity":1,"message":"2137","line":5,"column":5,"nodeType":"1917","messageId":"1918","endLine":5,"endColumn":15},{"ruleId":"1915","severity":1,"message":"1949","line":6,"column":5,"nodeType":"1917","messageId":"1918","endLine":6,"endColumn":12},{"ruleId":"1915","severity":1,"message":"2274","line":23,"column":5,"nodeType":"1917","messageId":"1918","endLine":23,"endColumn":22},{"ruleId":"1915","severity":1,"message":"2204","line":1,"column":37,"nodeType":"1917","messageId":"1918","endLine":1,"endColumn":50},{"ruleId":"1915","severity":1,"message":"2085","line":7,"column":5,"nodeType":"1917","messageId":"1918","endLine":7,"endColumn":14},{"ruleId":"1915","severity":1,"message":"2275","line":8,"column":13,"nodeType":"1917","messageId":"1918","endLine":8,"endColumn":25},{"ruleId":"1915","severity":1,"message":"2276","line":10,"column":18,"nodeType":"1917","messageId":"1918","endLine":10,"endColumn":28},{"ruleId":"1915","severity":1,"message":"2277","line":10,"column":30,"nodeType":"1917","messageId":"1918","endLine":10,"endColumn":34},{"ruleId":"1915","severity":1,"message":"2278","line":10,"column":49,"nodeType":"1917","messageId":"1918","endLine":10,"endColumn":55},{"ruleId":"1915","severity":1,"message":"2279","line":11,"column":5,"nodeType":"1917","messageId":"1918","endLine":11,"endColumn":21},{"ruleId":"1915","severity":1,"message":"2213","line":11,"column":72,"nodeType":"1917","messageId":"1918","endLine":11,"endColumn":77},{"ruleId":"1915","severity":1,"message":"2280","line":13,"column":9,"nodeType":"1917","messageId":"1918","endLine":13,"endColumn":33},{"ruleId":"1915","severity":1,"message":"2089","line":15,"column":47,"nodeType":"1917","messageId":"1918","endLine":15,"endColumn":62},{"ruleId":"1915","severity":1,"message":"2281","line":34,"column":5,"nodeType":"1917","messageId":"1918","endLine":34,"endColumn":15},{"ruleId":"1915","severity":1,"message":"2124","line":45,"column":5,"nodeType":"1917","messageId":"1918","endLine":45,"endColumn":27},{"ruleId":"1915","severity":1,"message":"2282","line":125,"column":5,"nodeType":"1917","messageId":"1918","endLine":125,"endColumn":21},{"ruleId":"1915","severity":1,"message":"2283","line":620,"column":13,"nodeType":"1917","messageId":"1918","endLine":620,"endColumn":16},{"ruleId":"1915","severity":1,"message":"2284","line":621,"column":13,"nodeType":"1917","messageId":"1918","endLine":621,"endColumn":15},{"ruleId":"1915","severity":1,"message":"2285","line":723,"column":17,"nodeType":"1917","messageId":"1918","endLine":723,"endColumn":27},{"ruleId":"1915","severity":1,"message":"2286","line":732,"column":13,"nodeType":"1917","messageId":"1918","endLine":732,"endColumn":26},{"ruleId":"1915","severity":1,"message":"2287","line":816,"column":25,"nodeType":"1917","messageId":"1918","endLine":816,"endColumn":38},{"ruleId":"1915","severity":1,"message":"2288","line":1021,"column":15,"nodeType":"1917","messageId":"1918","endLine":1021,"endColumn":17},{"ruleId":"1915","severity":1,"message":"2289","line":1168,"column":21,"nodeType":"1917","messageId":"1918","endLine":1168,"endColumn":29},{"ruleId":"2207","severity":1,"message":"2208","line":31,"column":5,"nodeType":"2209","messageId":"2210","endLine":33,"endColumn":6},{"ruleId":"1915","severity":1,"message":"2290","line":38,"column":13,"nodeType":"1917","messageId":"1918","endLine":38,"endColumn":38},{"ruleId":"1964","severity":1,"message":"2080","line":189,"column":87,"nodeType":"1966","messageId":"1967","endLine":189,"endColumn":88,"suggestions":"2291"},{"ruleId":"1915","severity":1,"message":"1939","line":1,"column":16,"nodeType":"1917","messageId":"1918","endLine":1,"endColumn":24},{"ruleId":"1915","severity":1,"message":"1951","line":3,"column":9,"nodeType":"1917","messageId":"1918","endLine":3,"endColumn":10},{"ruleId":"1915","severity":1,"message":"2292","line":5,"column":6,"nodeType":"1917","messageId":"1918","endLine":5,"endColumn":14},{"ruleId":"1915","severity":1,"message":"2293","line":6,"column":6,"nodeType":"1917","messageId":"1918","endLine":6,"endColumn":16},{"ruleId":"1915","severity":1,"message":"2294","line":7,"column":6,"nodeType":"1917","messageId":"1918","endLine":7,"endColumn":19},{"ruleId":"1915","severity":1,"message":"2295","line":1,"column":37,"nodeType":"1917","messageId":"1918","endLine":1,"endColumn":43},{"ruleId":"1915","severity":1,"message":"2296","line":1,"column":58,"nodeType":"1917","messageId":"1918","endLine":1,"endColumn":63},{"ruleId":"1915","severity":1,"message":"2297","line":2,"column":26,"nodeType":"1917","messageId":"1918","endLine":2,"endColumn":37},{"ruleId":"1915","severity":1,"message":"2298","line":11,"column":12,"nodeType":"1917","messageId":"1918","endLine":11,"endColumn":23},{"ruleId":"1915","severity":1,"message":"2299","line":11,"column":25,"nodeType":"1917","messageId":"1918","endLine":11,"endColumn":39},{"ruleId":"1915","severity":1,"message":"2300","line":19,"column":11,"nodeType":"1917","messageId":"1918","endLine":19,"endColumn":34},{"ruleId":"1915","severity":1,"message":"2301","line":20,"column":11,"nodeType":"1917","messageId":"1918","endLine":20,"endColumn":40},{"ruleId":"1915","severity":1,"message":"2302","line":41,"column":15,"nodeType":"1917","messageId":"1918","endLine":41,"endColumn":23},{"ruleId":"2303","severity":1,"message":"2304","line":50,"column":9,"nodeType":"2305","messageId":"2306","endLine":50,"endColumn":25},{"ruleId":"1983","severity":1,"message":"1984","line":73,"column":13,"nodeType":"2149","messageId":"1986","endLine":73,"endColumn":19},{"ruleId":"1983","severity":1,"message":"1984","line":98,"column":13,"nodeType":"2149","messageId":"1986","endLine":98,"endColumn":19},{"ruleId":"1983","severity":1,"message":"1984","line":101,"column":13,"nodeType":"2149","messageId":"1986","endLine":101,"endColumn":19},{"ruleId":"1915","severity":1,"message":"1940","line":1,"column":26,"nodeType":"1917","messageId":"1918","endLine":1,"endColumn":39},{"ruleId":"1915","severity":1,"message":"1941","line":1,"column":41,"nodeType":"1917","messageId":"1918","endLine":1,"endColumn":50},{"ruleId":"1915","severity":1,"message":"2307","line":5,"column":5,"nodeType":"1917","messageId":"1918","endLine":5,"endColumn":8},{"ruleId":"1915","severity":1,"message":"2308","line":7,"column":5,"nodeType":"1917","messageId":"1918","endLine":7,"endColumn":12},{"ruleId":"1915","severity":1,"message":"2309","line":10,"column":17,"nodeType":"1917","messageId":"1918","endLine":10,"endColumn":27},{"ruleId":"1915","severity":1,"message":"2297","line":11,"column":13,"nodeType":"1917","messageId":"1918","endLine":11,"endColumn":24},{"ruleId":"1915","severity":1,"message":"2310","line":11,"column":26,"nodeType":"1917","messageId":"1918","endLine":11,"endColumn":38},{"ruleId":"1915","severity":1,"message":"2295","line":11,"column":40,"nodeType":"1917","messageId":"1918","endLine":11,"endColumn":46},{"ruleId":"1915","severity":1,"message":"2311","line":11,"column":48,"nodeType":"1917","messageId":"1918","endLine":11,"endColumn":55},{"ruleId":"1915","severity":1,"message":"2173","line":12,"column":25,"nodeType":"1917","messageId":"1918","endLine":12,"endColumn":35},{"ruleId":"1915","severity":1,"message":"2312","line":15,"column":29,"nodeType":"1917","messageId":"1918","endLine":15,"endColumn":38},{"ruleId":"1915","severity":1,"message":"1950","line":16,"column":5,"nodeType":"1917","messageId":"1918","endLine":16,"endColumn":10},{"ruleId":"1983","severity":1,"message":"1984","line":32,"column":5,"nodeType":"2031","messageId":"1986","endLine":32,"endColumn":15},{"ruleId":"1983","severity":1,"message":"1984","line":44,"column":95,"nodeType":"2149","messageId":"1986","endLine":44,"endColumn":101},{"ruleId":"1983","severity":1,"message":"1984","line":46,"column":5,"nodeType":"2031","messageId":"1986","endLine":46,"endColumn":16},{"ruleId":"1915","severity":1,"message":"2313","line":399,"column":11,"nodeType":"1917","messageId":"1918","endLine":399,"endColumn":21},{"ruleId":"1915","severity":1,"message":"1940","line":1,"column":37,"nodeType":"1917","messageId":"1918","endLine":1,"endColumn":50},{"ruleId":"1915","severity":1,"message":"2314","line":4,"column":27,"nodeType":"1917","messageId":"1918","endLine":4,"endColumn":42},{"ruleId":"1915","severity":1,"message":"2315","line":4,"column":66,"nodeType":"1917","messageId":"1918","endLine":4,"endColumn":85},{"ruleId":"1915","severity":1,"message":"1944","line":6,"column":5,"nodeType":"1917","messageId":"1918","endLine":6,"endColumn":13},{"ruleId":"1915","severity":1,"message":"1945","line":7,"column":5,"nodeType":"1917","messageId":"1918","endLine":7,"endColumn":23},{"ruleId":"1915","severity":1,"message":"1946","line":8,"column":5,"nodeType":"1917","messageId":"1918","endLine":8,"endColumn":7},{"ruleId":"1915","severity":1,"message":"1947","line":10,"column":5,"nodeType":"1917","messageId":"1918","endLine":10,"endColumn":15},{"ruleId":"1915","severity":1,"message":"1948","line":12,"column":5,"nodeType":"1917","messageId":"1918","endLine":12,"endColumn":23},{"ruleId":"1915","severity":1,"message":"1949","line":14,"column":5,"nodeType":"1917","messageId":"1918","endLine":14,"endColumn":12},{"ruleId":"1915","severity":1,"message":"1952","line":15,"column":8,"nodeType":"1917","messageId":"1918","endLine":15,"endColumn":27},{"ruleId":"1915","severity":1,"message":"2316","line":119,"column":13,"nodeType":"1917","messageId":"1918","endLine":119,"endColumn":24},{"ruleId":"2317","severity":1,"message":"2318","line":139,"column":85,"nodeType":"2319","messageId":"2320","endLine":139,"endColumn":120,"fix":"2321"},{"ruleId":"1915","severity":1,"message":"2322","line":1,"column":9,"nodeType":"1917","messageId":"1918","endLine":1,"endColumn":19},{"ruleId":"1915","severity":1,"message":"2323","line":1,"column":21,"nodeType":"1917","messageId":"1918","endLine":1,"endColumn":33},{"ruleId":"1915","severity":1,"message":"1920","line":1,"column":50,"nodeType":"1917","messageId":"1918","endLine":1,"endColumn":68},{"ruleId":"1915","severity":1,"message":"2324","line":2,"column":46,"nodeType":"1917","messageId":"1918","endLine":2,"endColumn":52},{"ruleId":"1915","severity":1,"message":"2325","line":6,"column":10,"nodeType":"1917","messageId":"1918","endLine":6,"endColumn":17},{"ruleId":"1915","severity":1,"message":"2326","line":38,"column":6,"nodeType":"1917","messageId":"1918","endLine":38,"endColumn":21},{"ruleId":"1915","severity":1,"message":"2327","line":77,"column":17,"nodeType":"1917","messageId":"1918","endLine":77,"endColumn":29},{"ruleId":"1915","severity":1,"message":"2328","line":94,"column":10,"nodeType":"1917","messageId":"1918","endLine":94,"endColumn":25},{"ruleId":"2303","severity":1,"message":"2304","line":174,"column":13,"nodeType":"2305","messageId":"2306","endLine":174,"endColumn":31},{"ruleId":"2303","severity":1,"message":"2304","line":239,"column":13,"nodeType":"2305","messageId":"2306","endLine":239,"endColumn":31},{"ruleId":"1915","severity":1,"message":"2329","line":244,"column":14,"nodeType":"1917","messageId":"1918","endLine":244,"endColumn":25},{"ruleId":"1915","severity":1,"message":"2330","line":1,"column":27,"nodeType":"1917","messageId":"1918","endLine":1,"endColumn":40},{"ruleId":"1915","severity":1,"message":"2204","line":1,"column":42,"nodeType":"1917","messageId":"1918","endLine":1,"endColumn":55},{"ruleId":"1915","severity":1,"message":"2101","line":2,"column":94,"nodeType":"1917","messageId":"1918","endLine":2,"endColumn":105},{"ruleId":"1915","severity":1,"message":"2331","line":12,"column":6,"nodeType":"1917","messageId":"1918","endLine":12,"endColumn":22},{"ruleId":"1915","severity":1,"message":"2332","line":13,"column":6,"nodeType":"1917","messageId":"1918","endLine":13,"endColumn":21},{"ruleId":"2118","severity":1,"message":"2333","line":192,"column":26,"nodeType":"2016","messageId":"2120","endLine":201,"endColumn":14},{"ruleId":"1915","severity":1,"message":"2334","line":5,"column":5,"nodeType":"1917","messageId":"1918","endLine":5,"endColumn":11},{"ruleId":"1915","severity":1,"message":"2335","line":6,"column":5,"nodeType":"1917","messageId":"1918","endLine":6,"endColumn":18},{"ruleId":"1915","severity":1,"message":"2336","line":7,"column":5,"nodeType":"1917","messageId":"1918","endLine":7,"endColumn":17},{"ruleId":"1915","severity":1,"message":"2337","line":8,"column":5,"nodeType":"1917","messageId":"1918","endLine":8,"endColumn":16},{"ruleId":"1915","severity":1,"message":"2338","line":11,"column":5,"nodeType":"1917","messageId":"1918","endLine":11,"endColumn":25},{"ruleId":"1915","severity":1,"message":"2339","line":12,"column":5,"nodeType":"1917","messageId":"1918","endLine":12,"endColumn":32},{"ruleId":"1915","severity":1,"message":"2266","line":13,"column":25,"nodeType":"1917","messageId":"1918","endLine":13,"endColumn":35},{"ruleId":"1915","severity":1,"message":"2085","line":14,"column":5,"nodeType":"1917","messageId":"1918","endLine":14,"endColumn":14},{"ruleId":"1915","severity":1,"message":"2267","line":16,"column":5,"nodeType":"1917","messageId":"1918","endLine":16,"endColumn":11},{"ruleId":"1915","severity":1,"message":"2213","line":16,"column":13,"nodeType":"1917","messageId":"1918","endLine":16,"endColumn":18},{"ruleId":"1915","severity":1,"message":"2214","line":16,"column":20,"nodeType":"1917","messageId":"1918","endLine":16,"endColumn":33},{"ruleId":"1915","severity":1,"message":"2340","line":17,"column":5,"nodeType":"1917","messageId":"1918","endLine":17,"endColumn":18},{"ruleId":"1915","severity":1,"message":"1916","line":19,"column":5,"nodeType":"1917","messageId":"1918","endLine":19,"endColumn":10},{"ruleId":"1915","severity":1,"message":"2341","line":20,"column":5,"nodeType":"1917","messageId":"1918","endLine":20,"endColumn":16},{"ruleId":"1915","severity":1,"message":"2174","line":24,"column":5,"nodeType":"1917","messageId":"1918","endLine":24,"endColumn":15},{"ruleId":"1915","severity":1,"message":"2179","line":24,"column":32,"nodeType":"1917","messageId":"1918","endLine":24,"endColumn":46},{"ruleId":"1915","severity":1,"message":"2342","line":36,"column":7,"nodeType":"1917","messageId":"1918","endLine":36,"endColumn":50},{"ruleId":"2207","severity":1,"message":"2208","line":44,"column":5,"nodeType":"2209","messageId":"2210","endLine":46,"endColumn":6},{"ruleId":"1997","severity":1,"message":"2020","line":90,"column":24,"nodeType":"1999","messageId":"2000","endLine":90,"endColumn":26},{"ruleId":"1997","severity":1,"message":"2020","line":90,"column":43,"nodeType":"1999","messageId":"2000","endLine":90,"endColumn":45},{"ruleId":"1915","severity":1,"message":"2334","line":4,"column":9,"nodeType":"1917","messageId":"1918","endLine":4,"endColumn":15},{"ruleId":"1915","severity":1,"message":"2065","line":4,"column":17,"nodeType":"1917","messageId":"1918","endLine":4,"endColumn":23},{"ruleId":"1915","severity":1,"message":"1945","line":4,"column":25,"nodeType":"1917","messageId":"1918","endLine":4,"endColumn":43},{"ruleId":"2207","severity":1,"message":"2208","line":12,"column":5,"nodeType":"2209","messageId":"2210","endLine":14,"endColumn":6},{"ruleId":"1955","severity":1,"message":"1956","line":33,"column":37,"nodeType":"1957","messageId":"1958","endLine":33,"endColumn":39},{"ruleId":"1915","severity":1,"message":"2343","line":54,"column":10,"nodeType":"1917","messageId":"1918","endLine":54,"endColumn":22},{"ruleId":"2303","severity":1,"message":"2304","line":13,"column":9,"nodeType":"2305","messageId":"2306","endLine":70,"endColumn":64},{"ruleId":"1915","severity":1,"message":"2344","line":4,"column":5,"nodeType":"1917","messageId":"1918","endLine":4,"endColumn":16},{"ruleId":"1915","severity":1,"message":"2056","line":5,"column":5,"nodeType":"1917","messageId":"1918","endLine":5,"endColumn":16},{"ruleId":"1915","severity":1,"message":"2065","line":7,"column":5,"nodeType":"1917","messageId":"1918","endLine":7,"endColumn":11},{"ruleId":"1915","severity":1,"message":"2345","line":9,"column":5,"nodeType":"1917","messageId":"1918","endLine":9,"endColumn":13},{"ruleId":"1915","severity":1,"message":"2177","line":30,"column":5,"nodeType":"1917","messageId":"1918","endLine":30,"endColumn":12},{"ruleId":"1915","severity":1,"message":"2151","line":31,"column":5,"nodeType":"1917","messageId":"1918","endLine":31,"endColumn":11},{"ruleId":"1915","severity":1,"message":"2153","line":32,"column":5,"nodeType":"1917","messageId":"1918","endLine":32,"endColumn":10},{"ruleId":"1915","severity":1,"message":"2154","line":33,"column":5,"nodeType":"1917","messageId":"1918","endLine":33,"endColumn":12},{"ruleId":"1915","severity":1,"message":"2150","line":34,"column":5,"nodeType":"1917","messageId":"1918","endLine":34,"endColumn":13},{"ruleId":"1915","severity":1,"message":"2161","line":35,"column":5,"nodeType":"1917","messageId":"1918","endLine":35,"endColumn":12},{"ruleId":"1915","severity":1,"message":"2162","line":36,"column":5,"nodeType":"1917","messageId":"1918","endLine":36,"endColumn":13},{"ruleId":"1915","severity":1,"message":"2168","line":37,"column":5,"nodeType":"1917","messageId":"1918","endLine":37,"endColumn":12},{"ruleId":"1915","severity":1,"message":"2090","line":38,"column":5,"nodeType":"1917","messageId":"1918","endLine":38,"endColumn":12},{"ruleId":"1915","severity":1,"message":"2175","line":39,"column":5,"nodeType":"1917","messageId":"1918","endLine":39,"endColumn":12},{"ruleId":"1915","severity":1,"message":"2167","line":40,"column":5,"nodeType":"1917","messageId":"1918","endLine":40,"endColumn":13},{"ruleId":"1915","severity":1,"message":"2176","line":41,"column":5,"nodeType":"1917","messageId":"1918","endLine":41,"endColumn":13},{"ruleId":"1915","severity":1,"message":"2178","line":42,"column":5,"nodeType":"1917","messageId":"1918","endLine":42,"endColumn":14},{"ruleId":"1915","severity":1,"message":"2091","line":43,"column":5,"nodeType":"1917","messageId":"1918","endLine":43,"endColumn":13},{"ruleId":"1915","severity":1,"message":"2181","line":44,"column":5,"nodeType":"1917","messageId":"1918","endLine":44,"endColumn":11},{"ruleId":"1915","severity":1,"message":"2092","line":45,"column":5,"nodeType":"1917","messageId":"1918","endLine":45,"endColumn":9},{"ruleId":"1915","severity":1,"message":"2180","line":46,"column":5,"nodeType":"1917","messageId":"1918","endLine":46,"endColumn":15},{"ruleId":"1915","severity":1,"message":"2155","line":47,"column":5,"nodeType":"1917","messageId":"1918","endLine":47,"endColumn":18},{"ruleId":"1915","severity":1,"message":"2182","line":48,"column":5,"nodeType":"1917","messageId":"1918","endLine":48,"endColumn":14},{"ruleId":"1915","severity":1,"message":"2183","line":49,"column":5,"nodeType":"1917","messageId":"1918","endLine":49,"endColumn":13},{"ruleId":"1915","severity":1,"message":"2312","line":50,"column":5,"nodeType":"1917","messageId":"1918","endLine":50,"endColumn":14},{"ruleId":"1915","severity":1,"message":"1949","line":52,"column":5,"nodeType":"1917","messageId":"1918","endLine":52,"endColumn":12},{"ruleId":"1915","severity":1,"message":"2335","line":53,"column":5,"nodeType":"1917","messageId":"1918","endLine":53,"endColumn":18},{"ruleId":"1915","severity":1,"message":"1945","line":54,"column":5,"nodeType":"1917","messageId":"1918","endLine":54,"endColumn":23},{"ruleId":"2207","severity":1,"message":"2208","line":105,"column":5,"nodeType":"2209","messageId":"2210","endLine":105,"endColumn":74},{"ruleId":"1915","severity":1,"message":"2338","line":16,"column":5,"nodeType":"1917","messageId":"1918","endLine":16,"endColumn":25},{"ruleId":"1915","severity":1,"message":"2339","line":17,"column":5,"nodeType":"1917","messageId":"1918","endLine":17,"endColumn":32},{"ruleId":"1915","severity":1,"message":"2267","line":21,"column":5,"nodeType":"1917","messageId":"1918","endLine":21,"endColumn":11},{"ruleId":"1915","severity":1,"message":"2214","line":21,"column":21,"nodeType":"1917","messageId":"1918","endLine":21,"endColumn":34},{"ruleId":"1915","severity":1,"message":"2340","line":22,"column":5,"nodeType":"1917","messageId":"1918","endLine":22,"endColumn":18},{"ruleId":"1915","severity":1,"message":"2346","line":22,"column":20,"nodeType":"1917","messageId":"1918","endLine":22,"endColumn":33},{"ruleId":"1915","severity":1,"message":"1916","line":25,"column":5,"nodeType":"1917","messageId":"1918","endLine":25,"endColumn":10},{"ruleId":"1915","severity":1,"message":"2174","line":26,"column":5,"nodeType":"1917","messageId":"1918","endLine":26,"endColumn":15},{"ruleId":"1915","severity":1,"message":"2341","line":27,"column":5,"nodeType":"1917","messageId":"1918","endLine":27,"endColumn":16},{"ruleId":"1915","severity":1,"message":"1920","line":29,"column":5,"nodeType":"1917","messageId":"1918","endLine":29,"endColumn":23},{"ruleId":"1915","severity":1,"message":"2347","line":38,"column":8,"nodeType":"1917","messageId":"1918","endLine":38,"endColumn":19},{"ruleId":"1983","severity":1,"message":"1984","line":314,"column":9,"nodeType":"2035","messageId":"1986","endLine":327,"endColumn":20},{"ruleId":"1983","severity":1,"message":"1984","line":341,"column":9,"nodeType":"2043","messageId":"1986","endLine":351,"endColumn":50},{"ruleId":"1915","severity":1,"message":"2348","line":388,"column":39,"nodeType":"1917","messageId":"1918","endLine":388,"endColumn":54},{"ruleId":"1915","severity":1,"message":"2349","line":70,"column":13,"nodeType":"1917","messageId":"1918","endLine":70,"endColumn":16},{"ruleId":"1915","severity":1,"message":"2350","line":71,"column":13,"nodeType":"1917","messageId":"1918","endLine":71,"endColumn":16},{"ruleId":"1915","severity":1,"message":"2102","line":2,"column":17,"nodeType":"1917","messageId":"1918","endLine":2,"endColumn":22},{"ruleId":"1915","severity":1,"message":"1916","line":2,"column":54,"nodeType":"1917","messageId":"1918","endLine":2,"endColumn":59},{"ruleId":"1915","severity":1,"message":"2351","line":25,"column":6,"nodeType":"1917","messageId":"1918","endLine":25,"endColumn":11},{"ruleId":"1915","severity":1,"message":"2352","line":34,"column":8,"nodeType":"1917","messageId":"1918","endLine":34,"endColumn":14},{"ruleId":"1915","severity":1,"message":"2353","line":34,"column":16,"nodeType":"1917","messageId":"1918","endLine":34,"endColumn":25},{"ruleId":"2354","severity":1,"message":"2355","line":75,"column":25,"nodeType":"2319","endLine":75,"endColumn":75},{"ruleId":"1915","severity":1,"message":"2356","line":1,"column":10,"nodeType":"1917","messageId":"1918","endLine":1,"endColumn":16},{"ruleId":"1915","severity":1,"message":"2357","line":3,"column":10,"nodeType":"1917","messageId":"1918","endLine":3,"endColumn":19},{"ruleId":"1915","severity":1,"message":"2358","line":4,"column":72,"nodeType":"1917","messageId":"1918","endLine":4,"endColumn":79},{"ruleId":"1915","severity":1,"message":"2359","line":10,"column":8,"nodeType":"1917","messageId":"1918","endLine":10,"endColumn":15},{"ruleId":"1915","severity":1,"message":"2325","line":12,"column":10,"nodeType":"1917","messageId":"1918","endLine":12,"endColumn":17},{"ruleId":"1915","severity":1,"message":"2360","line":13,"column":9,"nodeType":"1917","messageId":"1918","endLine":13,"endColumn":20},{"ruleId":"1915","severity":1,"message":"2361","line":14,"column":9,"nodeType":"1917","messageId":"1918","endLine":14,"endColumn":13},{"ruleId":"1915","severity":1,"message":"2293","line":16,"column":11,"nodeType":"1917","messageId":"1918","endLine":16,"endColumn":21},{"ruleId":"1983","severity":1,"message":"1984","line":57,"column":5,"nodeType":"2031","messageId":"1986","endLine":62,"endColumn":7},{"ruleId":"1915","severity":1,"message":"2362","line":90,"column":7,"nodeType":"1917","messageId":"1918","endLine":90,"endColumn":14},{"ruleId":"1915","severity":1,"message":"2363","line":15,"column":21,"nodeType":"1917","messageId":"1918","endLine":15,"endColumn":26},{"ruleId":"1915","severity":1,"message":"2364","line":20,"column":10,"nodeType":"1917","messageId":"1918","endLine":20,"endColumn":14},{"ruleId":"1915","severity":1,"message":"2365","line":59,"column":10,"nodeType":"1917","messageId":"1918","endLine":59,"endColumn":21},{"ruleId":"1915","severity":1,"message":"2366","line":113,"column":9,"nodeType":"1917","messageId":"1918","endLine":113,"endColumn":21},{"ruleId":"1915","severity":1,"message":"2367","line":122,"column":11,"nodeType":"1917","messageId":"1918","endLine":122,"endColumn":16},{"ruleId":"1955","severity":1,"message":"1956","line":124,"column":45,"nodeType":"1957","messageId":"1958","endLine":124,"endColumn":47},{"ruleId":"1955","severity":1,"message":"1956","line":124,"column":80,"nodeType":"1957","messageId":"1958","endLine":124,"endColumn":82},{"ruleId":"1915","severity":1,"message":"2368","line":215,"column":19,"nodeType":"1917","messageId":"1918","endLine":215,"endColumn":33},{"ruleId":"1915","severity":1,"message":"2179","line":13,"column":5,"nodeType":"1917","messageId":"1918","endLine":13,"endColumn":19},{"ruleId":"1915","severity":1,"message":"1920","line":14,"column":5,"nodeType":"1917","messageId":"1918","endLine":14,"endColumn":23},{"ruleId":"1915","severity":1,"message":"2101","line":16,"column":10,"nodeType":"1917","messageId":"1918","endLine":16,"endColumn":21},{"ruleId":"1915","severity":1,"message":"1988","line":39,"column":10,"nodeType":"1917","messageId":"1918","endLine":39,"endColumn":21},{"ruleId":"1915","severity":1,"message":"2369","line":47,"column":7,"nodeType":"1917","messageId":"1918","endLine":47,"endColumn":11},{"ruleId":"1915","severity":1,"message":"2370","line":77,"column":11,"nodeType":"1917","messageId":"1918","endLine":77,"endColumn":19},{"ruleId":"1915","severity":1,"message":"2371","line":78,"column":11,"nodeType":"1917","messageId":"1918","endLine":78,"endColumn":17},{"ruleId":"1915","severity":1,"message":"2372","line":259,"column":6,"nodeType":"1917","messageId":"1918","endLine":259,"endColumn":27},{"ruleId":"2354","severity":1,"message":"2355","line":307,"column":17,"nodeType":"2319","endLine":307,"endColumn":80},{"ruleId":"1915","severity":1,"message":"2289","line":427,"column":12,"nodeType":"1917","messageId":"1918","endLine":427,"endColumn":20},{"ruleId":"1915","severity":1,"message":"2373","line":427,"column":22,"nodeType":"1917","messageId":"1918","endLine":427,"endColumn":28},{"ruleId":"1915","severity":1,"message":"2374","line":428,"column":11,"nodeType":"1917","messageId":"1918","endLine":428,"endColumn":22},{"ruleId":"1915","severity":1,"message":"2057","line":4,"column":5,"nodeType":"1917","messageId":"1918","endLine":4,"endColumn":15},{"ruleId":"1915","severity":1,"message":"2058","line":6,"column":5,"nodeType":"1917","messageId":"1918","endLine":6,"endColumn":13},{"ruleId":"1915","severity":1,"message":"1950","line":20,"column":5,"nodeType":"1917","messageId":"1918","endLine":20,"endColumn":10},{"ruleId":"1915","severity":1,"message":"2375","line":42,"column":10,"nodeType":"1917","messageId":"1918","endLine":42,"endColumn":29},{"ruleId":"1915","severity":1,"message":"2376","line":152,"column":12,"nodeType":"1917","messageId":"1918","endLine":152,"endColumn":19},{"ruleId":"1915","severity":1,"message":"2377","line":152,"column":33,"nodeType":"1917","messageId":"1918","endLine":152,"endColumn":41},{"ruleId":"1915","severity":1,"message":"2082","line":152,"column":43,"nodeType":"1917","messageId":"1918","endLine":152,"endColumn":48},{"ruleId":"1915","severity":1,"message":"2378","line":153,"column":12,"nodeType":"1917","messageId":"1918","endLine":153,"endColumn":20},{"ruleId":"1915","severity":1,"message":"2379","line":153,"column":22,"nodeType":"1917","messageId":"1918","endLine":153,"endColumn":33},{"ruleId":"1915","severity":1,"message":"2380","line":164,"column":9,"nodeType":"1917","messageId":"1918","endLine":164,"endColumn":22},{"ruleId":"1955","severity":1,"message":"1956","line":177,"column":53,"nodeType":"1957","messageId":"1958","endLine":177,"endColumn":55},{"ruleId":"1915","severity":1,"message":"2381","line":258,"column":11,"nodeType":"1917","messageId":"1918","endLine":258,"endColumn":39},{"ruleId":"1915","severity":1,"message":"2382","line":570,"column":11,"nodeType":"1917","messageId":"1918","endLine":570,"endColumn":20},{"ruleId":"1915","severity":1,"message":"2140","line":1,"column":52,"nodeType":"1917","messageId":"1918","endLine":1,"endColumn":60},{"ruleId":"1915","severity":1,"message":"2038","line":4,"column":5,"nodeType":"1917","messageId":"1918","endLine":4,"endColumn":24},{"ruleId":"1915","severity":1,"message":"2265","line":8,"column":19,"nodeType":"1917","messageId":"1918","endLine":8,"endColumn":26},{"ruleId":"1915","severity":1,"message":"2074","line":25,"column":8,"nodeType":"1917","messageId":"1918","endLine":25,"endColumn":15},{"ruleId":"1915","severity":1,"message":"2383","line":26,"column":8,"nodeType":"1917","messageId":"1918","endLine":26,"endColumn":14},{"ruleId":"1915","severity":1,"message":"2384","line":27,"column":9,"nodeType":"1917","messageId":"1918","endLine":27,"endColumn":15},{"ruleId":"1915","severity":1,"message":"1922","line":29,"column":9,"nodeType":"1917","messageId":"1918","endLine":29,"endColumn":22},{"ruleId":"1930","severity":1,"message":"2385","line":53,"column":8,"nodeType":"1932","endLine":53,"endColumn":12,"suggestions":"2386"},{"ruleId":"2387","severity":1,"message":"2388","line":87,"column":29,"nodeType":"2389","messageId":"2390","endLine":87,"endColumn":42},{"ruleId":"2387","severity":1,"message":"2388","line":98,"column":33,"nodeType":"2389","messageId":"2390","endLine":98,"endColumn":46},{"ruleId":"2387","severity":1,"message":"2388","line":107,"column":33,"nodeType":"2389","messageId":"2390","endLine":107,"endColumn":46},{"ruleId":"2387","severity":1,"message":"2388","line":114,"column":51,"nodeType":"2389","messageId":"2390","endLine":114,"endColumn":66},{"ruleId":"1915","severity":1,"message":"2391","line":4,"column":16,"nodeType":"1917","messageId":"1918","endLine":4,"endColumn":20},{"ruleId":"1915","severity":1,"message":"2392","line":5,"column":10,"nodeType":"1917","messageId":"1918","endLine":5,"endColumn":17},{"ruleId":"2387","severity":1,"message":"2388","line":18,"column":21,"nodeType":"2389","messageId":"2390","endLine":18,"endColumn":38},{"ruleId":"2387","severity":1,"message":"2388","line":20,"column":48,"nodeType":"2389","messageId":"2390","endLine":20,"endColumn":63},{"ruleId":"1915","severity":1,"message":"2324","line":1,"column":93,"nodeType":"1917","messageId":"1918","endLine":1,"endColumn":99},{"ruleId":"1915","severity":1,"message":"2393","line":8,"column":21,"nodeType":"1917","messageId":"1918","endLine":8,"endColumn":28},{"ruleId":"1915","severity":1,"message":"2394","line":10,"column":8,"nodeType":"1917","messageId":"1918","endLine":10,"endColumn":14},{"ruleId":"1915","severity":1,"message":"2395","line":154,"column":13,"nodeType":"1917","messageId":"1918","endLine":154,"endColumn":25},{"ruleId":"1915","severity":1,"message":"2396","line":157,"column":13,"nodeType":"1917","messageId":"1918","endLine":157,"endColumn":26},{"ruleId":"1915","severity":1,"message":"2397","line":160,"column":13,"nodeType":"1917","messageId":"1918","endLine":160,"endColumn":32},{"ruleId":"1997","severity":1,"message":"2020","line":166,"column":25,"nodeType":"1999","messageId":"2000","endLine":166,"endColumn":27},{"ruleId":"1997","severity":1,"message":"2020","line":166,"column":47,"nodeType":"1999","messageId":"2000","endLine":166,"endColumn":49},{"ruleId":"1997","severity":1,"message":"1998","line":166,"column":47,"nodeType":"1999","messageId":"2000","endLine":166,"endColumn":49},{"ruleId":"1997","severity":1,"message":"1998","line":166,"column":61,"nodeType":"1999","messageId":"2000","endLine":166,"endColumn":63},{"ruleId":"1997","severity":1,"message":"1998","line":166,"column":84,"nodeType":"1999","messageId":"2000","endLine":166,"endColumn":86},{"ruleId":"1997","severity":1,"message":"1998","line":166,"column":98,"nodeType":"1999","messageId":"2000","endLine":166,"endColumn":100},{"ruleId":"1997","severity":1,"message":"1998","line":166,"column":127,"nodeType":"1999","messageId":"2000","endLine":166,"endColumn":129},{"ruleId":"1997","severity":1,"message":"1998","line":166,"column":157,"nodeType":"1999","messageId":"2000","endLine":166,"endColumn":159},{"ruleId":"1955","severity":1,"message":"1956","line":170,"column":18,"nodeType":"1957","messageId":"1958","endLine":170,"endColumn":20},{"ruleId":"1915","severity":1,"message":"2398","line":237,"column":11,"nodeType":"1917","messageId":"1918","endLine":237,"endColumn":24},{"ruleId":"2387","severity":1,"message":"2388","line":257,"column":25,"nodeType":"2389","messageId":"2390","endLine":257,"endColumn":42},{"ruleId":"2387","severity":1,"message":"2388","line":259,"column":60,"nodeType":"2389","messageId":"2390","endLine":259,"endColumn":75},{"ruleId":"1915","severity":1,"message":"2102","line":4,"column":19,"nodeType":"1917","messageId":"1918","endLine":4,"endColumn":24},{"ruleId":"1915","severity":1,"message":"2358","line":1,"column":29,"nodeType":"1917","messageId":"1918","endLine":1,"endColumn":36},{"ruleId":"1915","severity":1,"message":"2391","line":4,"column":16,"nodeType":"1917","messageId":"1918","endLine":4,"endColumn":20},{"ruleId":"1915","severity":1,"message":"2392","line":5,"column":9,"nodeType":"1917","messageId":"1918","endLine":5,"endColumn":16},{"ruleId":"2387","severity":1,"message":"2388","line":147,"column":17,"nodeType":"2389","messageId":"2390","endLine":147,"endColumn":34},{"ruleId":"2387","severity":1,"message":"2388","line":149,"column":52,"nodeType":"2389","messageId":"2390","endLine":149,"endColumn":67},{"ruleId":"1915","severity":1,"message":"2399","line":1,"column":29,"nodeType":"1917","messageId":"1918","endLine":1,"endColumn":46},{"ruleId":"1915","severity":1,"message":"2140","line":1,"column":83,"nodeType":"1917","messageId":"1918","endLine":1,"endColumn":91},{"ruleId":"1915","severity":1,"message":"2324","line":1,"column":93,"nodeType":"1917","messageId":"1918","endLine":1,"endColumn":99},{"ruleId":"1915","severity":1,"message":"2400","line":5,"column":20,"nodeType":"1917","messageId":"1918","endLine":5,"endColumn":27},{"ruleId":"1915","severity":1,"message":"2401","line":8,"column":9,"nodeType":"1917","messageId":"1918","endLine":8,"endColumn":13},{"ruleId":"1915","severity":1,"message":"2402","line":8,"column":15,"nodeType":"1917","messageId":"1918","endLine":8,"endColumn":19},{"ruleId":"1915","severity":1,"message":"2393","line":8,"column":21,"nodeType":"1917","messageId":"1918","endLine":8,"endColumn":28},{"ruleId":"1915","severity":1,"message":"2391","line":9,"column":17,"nodeType":"1917","messageId":"1918","endLine":9,"endColumn":21},{"ruleId":"1915","severity":1,"message":"2394","line":12,"column":8,"nodeType":"1917","messageId":"1918","endLine":12,"endColumn":14},{"ruleId":"1915","severity":1,"message":"2398","line":33,"column":11,"nodeType":"1917","messageId":"1918","endLine":33,"endColumn":24},{"ruleId":"2387","severity":1,"message":"2388","line":53,"column":25,"nodeType":"2389","messageId":"2390","endLine":53,"endColumn":45},{"ruleId":"2387","severity":1,"message":"2388","line":55,"column":61,"nodeType":"2389","messageId":"2390","endLine":55,"endColumn":76},{"ruleId":"1915","severity":1,"message":"2324","line":1,"column":93,"nodeType":"1917","messageId":"1918","endLine":1,"endColumn":99},{"ruleId":"1915","severity":1,"message":"2393","line":8,"column":21,"nodeType":"1917","messageId":"1918","endLine":8,"endColumn":28},{"ruleId":"1915","severity":1,"message":"2394","line":10,"column":8,"nodeType":"1917","messageId":"1918","endLine":10,"endColumn":14},{"ruleId":"1915","severity":1,"message":"2395","line":153,"column":13,"nodeType":"1917","messageId":"1918","endLine":153,"endColumn":25},{"ruleId":"1915","severity":1,"message":"2396","line":156,"column":13,"nodeType":"1917","messageId":"1918","endLine":156,"endColumn":26},{"ruleId":"1915","severity":1,"message":"2397","line":159,"column":13,"nodeType":"1917","messageId":"1918","endLine":159,"endColumn":32},{"ruleId":"1997","severity":1,"message":"2020","line":165,"column":25,"nodeType":"1999","messageId":"2000","endLine":165,"endColumn":27},{"ruleId":"1997","severity":1,"message":"2020","line":165,"column":47,"nodeType":"1999","messageId":"2000","endLine":165,"endColumn":49},{"ruleId":"1997","severity":1,"message":"1998","line":165,"column":47,"nodeType":"1999","messageId":"2000","endLine":165,"endColumn":49},{"ruleId":"1997","severity":1,"message":"1998","line":165,"column":61,"nodeType":"1999","messageId":"2000","endLine":165,"endColumn":63},{"ruleId":"1997","severity":1,"message":"1998","line":165,"column":84,"nodeType":"1999","messageId":"2000","endLine":165,"endColumn":86},{"ruleId":"1997","severity":1,"message":"1998","line":165,"column":98,"nodeType":"1999","messageId":"2000","endLine":165,"endColumn":100},{"ruleId":"1997","severity":1,"message":"1998","line":165,"column":127,"nodeType":"1999","messageId":"2000","endLine":165,"endColumn":129},{"ruleId":"1997","severity":1,"message":"1998","line":165,"column":157,"nodeType":"1999","messageId":"2000","endLine":165,"endColumn":159},{"ruleId":"1955","severity":1,"message":"1956","line":169,"column":18,"nodeType":"1957","messageId":"1958","endLine":169,"endColumn":20},{"ruleId":"1915","severity":1,"message":"2398","line":236,"column":11,"nodeType":"1917","messageId":"1918","endLine":236,"endColumn":24},{"ruleId":"2387","severity":1,"message":"2388","line":256,"column":25,"nodeType":"2389","messageId":"2390","endLine":256,"endColumn":42},{"ruleId":"2387","severity":1,"message":"2388","line":258,"column":60,"nodeType":"2389","messageId":"2390","endLine":258,"endColumn":75},{"ruleId":"2354","severity":1,"message":"2355","line":575,"column":41,"nodeType":"2319","endLine":575,"endColumn":57},{"ruleId":"1915","severity":1,"message":"2403","line":4,"column":9,"nodeType":"1917","messageId":"1918","endLine":4,"endColumn":18},{"ruleId":"1915","severity":1,"message":"1920","line":6,"column":42,"nodeType":"1917","messageId":"1918","endLine":6,"endColumn":60},{"ruleId":"1915","severity":1,"message":"2400","line":8,"column":20,"nodeType":"1917","messageId":"1918","endLine":8,"endColumn":27},{"ruleId":"1915","severity":1,"message":"2391","line":10,"column":17,"nodeType":"1917","messageId":"1918","endLine":10,"endColumn":21},{"ruleId":"2387","severity":1,"message":"2388","line":71,"column":25,"nodeType":"2389","messageId":"2390","endLine":71,"endColumn":40},{"ruleId":"2387","severity":1,"message":"2388","line":78,"column":25,"nodeType":"2389","messageId":"2390","endLine":78,"endColumn":41},{"ruleId":"2387","severity":1,"message":"2388","line":85,"column":25,"nodeType":"2389","messageId":"2390","endLine":85,"endColumn":39},{"ruleId":"2387","severity":1,"message":"2388","line":88,"column":105,"nodeType":"2389","messageId":"2390","endLine":88,"endColumn":125},{"ruleId":"1915","severity":1,"message":"2404","line":6,"column":16,"nodeType":"1917","messageId":"1918","endLine":6,"endColumn":27},{"ruleId":"1915","severity":1,"message":"2405","line":7,"column":9,"nodeType":"1917","messageId":"1918","endLine":7,"endColumn":16},{"ruleId":"1915","severity":1,"message":"2406","line":10,"column":10,"nodeType":"1917","messageId":"1918","endLine":10,"endColumn":30},{"ruleId":"1915","severity":1,"message":"2407","line":13,"column":9,"nodeType":"1917","messageId":"1918","endLine":13,"endColumn":21},{"ruleId":"1915","severity":1,"message":"1949","line":4,"column":23,"nodeType":"1917","messageId":"1918","endLine":4,"endColumn":30},{"ruleId":"1915","severity":1,"message":"2408","line":4,"column":32,"nodeType":"1917","messageId":"1918","endLine":4,"endColumn":36},{"ruleId":"1915","severity":1,"message":"1945","line":6,"column":5,"nodeType":"1917","messageId":"1918","endLine":6,"endColumn":23},{"ruleId":"1915","severity":1,"message":"2098","line":8,"column":5,"nodeType":"1917","messageId":"1918","endLine":8,"endColumn":17},{"ruleId":"1915","severity":1,"message":"2409","line":9,"column":5,"nodeType":"1917","messageId":"1918","endLine":9,"endColumn":8},{"ruleId":"1915","severity":1,"message":"2179","line":13,"column":5,"nodeType":"1917","messageId":"1918","endLine":13,"endColumn":19},{"ruleId":"2207","severity":1,"message":"2208","line":24,"column":5,"nodeType":"2209","messageId":"2210","endLine":26,"endColumn":6},{"ruleId":"1915","severity":1,"message":"2057","line":2,"column":5,"nodeType":"1917","messageId":"1918","endLine":2,"endColumn":15},{"ruleId":"1915","severity":1,"message":"1920","line":18,"column":5,"nodeType":"1917","messageId":"1918","endLine":18,"endColumn":23},{"ruleId":"1955","severity":1,"message":"1956","line":106,"column":37,"nodeType":"1957","messageId":"1958","endLine":106,"endColumn":39},{"ruleId":"1915","severity":1,"message":"2410","line":129,"column":21,"nodeType":"1917","messageId":"1918","endLine":129,"endColumn":32},{"ruleId":"1915","severity":1,"message":"2411","line":143,"column":17,"nodeType":"1917","messageId":"1918","endLine":143,"endColumn":20},{"ruleId":"1915","severity":1,"message":"2412","line":158,"column":13,"nodeType":"1917","messageId":"1918","endLine":158,"endColumn":27},{"ruleId":"1915","severity":1,"message":"1951","line":2,"column":36,"nodeType":"1917","messageId":"1918","endLine":2,"endColumn":37},{"ruleId":"1930","severity":1,"message":"2413","line":32,"column":8,"nodeType":"1932","endLine":32,"endColumn":10,"suggestions":"2414"},{"ruleId":"1915","severity":1,"message":"2415","line":7,"column":5,"nodeType":"1917","messageId":"1918","endLine":7,"endColumn":12},{"ruleId":"1915","severity":1,"message":"2416","line":34,"column":12,"nodeType":"1917","messageId":"1918","endLine":34,"endColumn":16},{"ruleId":"2354","severity":1,"message":"2355","line":41,"column":26,"nodeType":"2319","endLine":41,"endColumn":44},{"ruleId":"2354","severity":1,"message":"2355","line":46,"column":26,"nodeType":"2319","endLine":46,"endColumn":47},{"ruleId":"1915","severity":1,"message":"1938","line":1,"column":65,"nodeType":"1917","messageId":"1918","endLine":1,"endColumn":74},{"ruleId":"1915","severity":1,"message":"2417","line":1,"column":76,"nodeType":"1917","messageId":"1918","endLine":1,"endColumn":85},{"ruleId":"1915","severity":1,"message":"2418","line":13,"column":10,"nodeType":"1917","messageId":"1918","endLine":13,"endColumn":21},{"ruleId":"1915","severity":1,"message":"2325","line":3,"column":10,"nodeType":"1917","messageId":"1918","endLine":3,"endColumn":17},{"ruleId":"1915","severity":1,"message":"2419","line":5,"column":6,"nodeType":"1917","messageId":"1918","endLine":5,"endColumn":15},{"ruleId":"1915","severity":1,"message":"2409","line":5,"column":5,"nodeType":"1917","messageId":"1918","endLine":5,"endColumn":8},{"ruleId":"1915","severity":1,"message":"2420","line":13,"column":11,"nodeType":"1917","messageId":"1918","endLine":13,"endColumn":27},{"ruleId":"1915","severity":1,"message":"2421","line":88,"column":13,"nodeType":"1917","messageId":"1918","endLine":88,"endColumn":22},{"ruleId":"1915","severity":1,"message":"2422","line":91,"column":13,"nodeType":"1917","messageId":"1918","endLine":91,"endColumn":20},{"ruleId":"1915","severity":1,"message":"2423","line":93,"column":17,"nodeType":"1917","messageId":"1918","endLine":93,"endColumn":21},{"ruleId":"2014","severity":1,"message":"2424","line":93,"column":47,"nodeType":"2016","messageId":"2425","endLine":93,"endColumn":49},{"ruleId":"1997","severity":1,"message":"1998","line":146,"column":30,"nodeType":"1999","messageId":"2000","endLine":146,"endColumn":32},{"ruleId":"1997","severity":1,"message":"1998","line":151,"column":21,"nodeType":"1999","messageId":"2000","endLine":151,"endColumn":23},{"ruleId":"1915","severity":1,"message":"2426","line":178,"column":17,"nodeType":"1917","messageId":"1918","endLine":178,"endColumn":34},{"ruleId":"1915","severity":1,"message":"2427","line":180,"column":17,"nodeType":"1917","messageId":"1918","endLine":180,"endColumn":22},{"ruleId":"1915","severity":1,"message":"2428","line":269,"column":17,"nodeType":"1917","messageId":"1918","endLine":269,"endColumn":24},{"ruleId":"2354","severity":1,"message":"2355","line":18,"column":21,"nodeType":"2319","endLine":18,"endColumn":53},{"ruleId":"2354","severity":1,"message":"2355","line":23,"column":21,"nodeType":"2319","endLine":23,"endColumn":53},{"ruleId":"1997","severity":1,"message":"2020","line":110,"column":29,"nodeType":"1999","messageId":"2000","endLine":110,"endColumn":31},{"ruleId":"1997","severity":1,"message":"2020","line":110,"column":51,"nodeType":"1999","messageId":"2000","endLine":110,"endColumn":53},{"ruleId":"1997","severity":1,"message":"1998","line":110,"column":51,"nodeType":"1999","messageId":"2000","endLine":110,"endColumn":53},{"ruleId":"1997","severity":1,"message":"1998","line":110,"column":65,"nodeType":"1999","messageId":"2000","endLine":110,"endColumn":67},{"ruleId":"1997","severity":1,"message":"1998","line":110,"column":88,"nodeType":"1999","messageId":"2000","endLine":110,"endColumn":90},{"ruleId":"1997","severity":1,"message":"1998","line":110,"column":102,"nodeType":"1999","messageId":"2000","endLine":110,"endColumn":104},{"ruleId":"1997","severity":1,"message":"1998","line":110,"column":131,"nodeType":"1999","messageId":"2000","endLine":110,"endColumn":133},{"ruleId":"1997","severity":1,"message":"1998","line":110,"column":161,"nodeType":"1999","messageId":"2000","endLine":110,"endColumn":163},{"ruleId":"1955","severity":1,"message":"1956","line":131,"column":18,"nodeType":"1957","messageId":"1958","endLine":131,"endColumn":20},{"ruleId":"1915","severity":1,"message":"2429","line":2,"column":10,"nodeType":"1917","messageId":"1918","endLine":2,"endColumn":18},{"ruleId":"1915","severity":1,"message":"2430","line":2,"column":32,"nodeType":"1917","messageId":"1918","endLine":2,"endColumn":37},{"ruleId":"1915","severity":1,"message":"2431","line":6,"column":5,"nodeType":"1917","messageId":"1918","endLine":6,"endColumn":27},{"ruleId":"1915","severity":1,"message":"2432","line":7,"column":5,"nodeType":"1917","messageId":"1918","endLine":7,"endColumn":33},{"ruleId":"1915","severity":1,"message":"2433","line":8,"column":5,"nodeType":"1917","messageId":"1918","endLine":8,"endColumn":27},{"ruleId":"1915","severity":1,"message":"2434","line":11,"column":10,"nodeType":"1917","messageId":"1918","endLine":11,"endColumn":13},{"ruleId":"1915","severity":1,"message":"2071","line":4,"column":24,"nodeType":"1917","messageId":"1918","endLine":4,"endColumn":32},{"ruleId":"1915","severity":1,"message":"2435","line":15,"column":10,"nodeType":"1917","messageId":"1918","endLine":15,"endColumn":27},{"ruleId":"1915","severity":1,"message":"2325","line":4,"column":10,"nodeType":"1917","messageId":"1918","endLine":4,"endColumn":17},{"ruleId":"1915","severity":1,"message":"2436","line":8,"column":26,"nodeType":"1917","messageId":"1918","endLine":8,"endColumn":33},{"ruleId":"2354","severity":1,"message":"2355","line":56,"column":20,"nodeType":"2319","endLine":56,"endColumn":69},{"ruleId":"2354","severity":1,"message":"2355","line":57,"column":21,"nodeType":"2319","endLine":59,"endColumn":44},{"ruleId":"1915","severity":1,"message":"2437","line":1,"column":35,"nodeType":"1917","messageId":"1918","endLine":1,"endColumn":50},{"ruleId":"1915","severity":1,"message":"2324","line":1,"column":62,"nodeType":"1917","messageId":"1918","endLine":1,"endColumn":68},{"ruleId":"1915","severity":1,"message":"2403","line":1,"column":70,"nodeType":"1917","messageId":"1918","endLine":1,"endColumn":79},{"ruleId":"1915","severity":1,"message":"1937","line":1,"column":81,"nodeType":"1917","messageId":"1918","endLine":1,"endColumn":93},{"ruleId":"1915","severity":1,"message":"2438","line":3,"column":10,"nodeType":"1917","messageId":"1918","endLine":3,"endColumn":18},{"ruleId":"1997","severity":1,"message":"1998","line":52,"column":41,"nodeType":"1999","messageId":"2000","endLine":52,"endColumn":43},{"ruleId":"1997","severity":1,"message":"1998","line":52,"column":68,"nodeType":"1999","messageId":"2000","endLine":52,"endColumn":70},{"ruleId":"1915","severity":1,"message":"2439","line":117,"column":9,"nodeType":"1917","messageId":"1918","endLine":117,"endColumn":14},{"ruleId":"1915","severity":1,"message":"2440","line":4,"column":20,"nodeType":"1917","messageId":"1918","endLine":4,"endColumn":30},{"ruleId":"2441","severity":1,"message":"2442","line":100,"column":80,"nodeType":"2443","messageId":"2237","endLine":100,"endColumn":81,"fix":"2444"},{"ruleId":"1915","severity":1,"message":"2038","line":6,"column":5,"nodeType":"1917","messageId":"1918","endLine":6,"endColumn":24},{"ruleId":"1915","severity":1,"message":"2158","line":10,"column":5,"nodeType":"1917","messageId":"1918","endLine":10,"endColumn":9},{"ruleId":"1997","severity":1,"message":"2020","line":53,"column":28,"nodeType":"1999","messageId":"2000","endLine":53,"endColumn":30},{"ruleId":"1997","severity":1,"message":"2020","line":53,"column":96,"nodeType":"1999","messageId":"2000","endLine":53,"endColumn":98},{"ruleId":"1915","severity":1,"message":"2038","line":4,"column":9,"nodeType":"1917","messageId":"1918","endLine":4,"endColumn":28},{"ruleId":"1915","severity":1,"message":"2445","line":8,"column":10,"nodeType":"1917","messageId":"1918","endLine":8,"endColumn":22},{"ruleId":"1915","severity":1,"message":"1948","line":1,"column":24,"nodeType":"1917","messageId":"1918","endLine":1,"endColumn":42},{"ruleId":"1915","severity":1,"message":"1949","line":1,"column":53,"nodeType":"1917","messageId":"1918","endLine":1,"endColumn":60},{"ruleId":"1915","severity":1,"message":"2446","line":2,"column":9,"nodeType":"1917","messageId":"1918","endLine":2,"endColumn":23},{"ruleId":"1915","severity":1,"message":"2064","line":5,"column":9,"nodeType":"1917","messageId":"1918","endLine":5,"endColumn":22},{"ruleId":"1915","severity":1,"message":"1948","line":2,"column":24,"nodeType":"1917","messageId":"1918","endLine":2,"endColumn":42},{"ruleId":"1915","severity":1,"message":"1949","line":2,"column":53,"nodeType":"1917","messageId":"1918","endLine":2,"endColumn":60},{"ruleId":"1915","severity":1,"message":"2446","line":3,"column":9,"nodeType":"1917","messageId":"1918","endLine":3,"endColumn":23},{"ruleId":"1915","severity":1,"message":"2064","line":6,"column":9,"nodeType":"1917","messageId":"1918","endLine":6,"endColumn":22},{"ruleId":"1915","severity":1,"message":"2447","line":8,"column":9,"nodeType":"1917","messageId":"1918","endLine":8,"endColumn":17},{"ruleId":"1915","severity":1,"message":"2448","line":20,"column":9,"nodeType":"1917","messageId":"1918","endLine":20,"endColumn":18},{"ruleId":"1915","severity":1,"message":"1920","line":9,"column":5,"nodeType":"1917","messageId":"1918","endLine":9,"endColumn":23},{"ruleId":"1915","severity":1,"message":"1950","line":10,"column":5,"nodeType":"1917","messageId":"1918","endLine":10,"endColumn":10},{"ruleId":"1915","severity":1,"message":"2449","line":18,"column":10,"nodeType":"1917","messageId":"1918","endLine":18,"endColumn":19},{"ruleId":"1915","severity":1,"message":"2450","line":30,"column":12,"nodeType":"1917","messageId":"1918","endLine":30,"endColumn":19},{"ruleId":"1915","severity":1,"message":"2451","line":30,"column":21,"nodeType":"1917","messageId":"1918","endLine":30,"endColumn":31},{"ruleId":"1915","severity":1,"message":"2452","line":20,"column":12,"nodeType":"1917","messageId":"1918","endLine":20,"endColumn":16},{"ruleId":"1915","severity":1,"message":"2453","line":20,"column":18,"nodeType":"1917","messageId":"1918","endLine":20,"endColumn":28},{"ruleId":"1915","severity":1,"message":"2454","line":20,"column":30,"nodeType":"1917","messageId":"1918","endLine":20,"endColumn":36},{"ruleId":"1915","severity":1,"message":"2455","line":38,"column":10,"nodeType":"1917","messageId":"1918","endLine":38,"endColumn":15},{"ruleId":"1915","severity":1,"message":"2456","line":39,"column":10,"nodeType":"1917","messageId":"1918","endLine":39,"endColumn":15},{"ruleId":"1915","severity":1,"message":"2346","line":10,"column":20,"nodeType":"1917","messageId":"1918","endLine":10,"endColumn":33},{"ruleId":"1915","severity":1,"message":"1948","line":12,"column":5,"nodeType":"1917","messageId":"1918","endLine":12,"endColumn":23},{"ruleId":"1915","severity":1,"message":"2457","line":16,"column":5,"nodeType":"1917","messageId":"1918","endLine":16,"endColumn":13},{"ruleId":"1915","severity":1,"message":"2124","line":17,"column":5,"nodeType":"1917","messageId":"1918","endLine":17,"endColumn":27},{"ruleId":"1915","severity":1,"message":"2458","line":18,"column":25,"nodeType":"1917","messageId":"1918","endLine":18,"endColumn":30},{"ruleId":"1997","severity":1,"message":"2020","line":66,"column":27,"nodeType":"1999","messageId":"2000","endLine":66,"endColumn":29},{"ruleId":"1997","severity":1,"message":"2020","line":66,"column":43,"nodeType":"1999","messageId":"2000","endLine":66,"endColumn":45},{"ruleId":"1997","severity":1,"message":"2020","line":67,"column":28,"nodeType":"1999","messageId":"2000","endLine":67,"endColumn":30},{"ruleId":"1997","severity":1,"message":"2020","line":67,"column":45,"nodeType":"1999","messageId":"2000","endLine":67,"endColumn":47},{"ruleId":"1915","severity":1,"message":"2459","line":73,"column":10,"nodeType":"1917","messageId":"1918","endLine":73,"endColumn":23},{"ruleId":"1915","severity":1,"message":"1919","line":2,"column":15,"nodeType":"1917","messageId":"1918","endLine":2,"endColumn":16},{"ruleId":"1915","severity":1,"message":"2405","line":4,"column":10,"nodeType":"1917","messageId":"1918","endLine":4,"endColumn":17},{"ruleId":"1915","severity":1,"message":"2460","line":5,"column":10,"nodeType":"1917","messageId":"1918","endLine":5,"endColumn":19},{"ruleId":"1915","severity":1,"message":"2461","line":1,"column":16,"nodeType":"1917","messageId":"1918","endLine":1,"endColumn":25},{"ruleId":"1915","severity":1,"message":"1937","line":1,"column":42,"nodeType":"1917","messageId":"1918","endLine":1,"endColumn":54},{"ruleId":"1915","severity":1,"message":"2140","line":1,"column":67,"nodeType":"1917","messageId":"1918","endLine":1,"endColumn":75},{"ruleId":"1915","severity":1,"message":"2462","line":7,"column":5,"nodeType":"1917","messageId":"1918","endLine":7,"endColumn":20},{"ruleId":"1915","severity":1,"message":"2463","line":16,"column":9,"nodeType":"1917","messageId":"1918","endLine":16,"endColumn":16},{"ruleId":"1915","severity":1,"message":"2464","line":135,"column":15,"nodeType":"1917","messageId":"1918","endLine":135,"endColumn":35},{"ruleId":"1915","severity":1,"message":"2464","line":164,"column":15,"nodeType":"1917","messageId":"1918","endLine":164,"endColumn":35},{"ruleId":"1915","severity":1,"message":"2465","line":306,"column":5,"nodeType":"1917","messageId":"1918","endLine":306,"endColumn":27},{"ruleId":"1915","severity":1,"message":"2466","line":512,"column":13,"nodeType":"1917","messageId":"1918","endLine":512,"endColumn":28},{"ruleId":"1915","severity":1,"message":"2467","line":7,"column":10,"nodeType":"1917","messageId":"1918","endLine":7,"endColumn":13},{"ruleId":"1915","severity":1,"message":"2468","line":7,"column":15,"nodeType":"1917","messageId":"1918","endLine":7,"endColumn":25},{"ruleId":"1915","severity":1,"message":"1938","line":1,"column":40,"nodeType":"1917","messageId":"1918","endLine":1,"endColumn":49},{"ruleId":"1915","severity":1,"message":"2469","line":9,"column":8,"nodeType":"1917","messageId":"1918","endLine":9,"endColumn":19},{"ruleId":"1915","severity":1,"message":"2468","line":10,"column":10,"nodeType":"1917","messageId":"1918","endLine":10,"endColumn":20},{"ruleId":"1915","severity":1,"message":"2467","line":10,"column":22,"nodeType":"1917","messageId":"1918","endLine":10,"endColumn":25},{"ruleId":"1915","severity":1,"message":"2470","line":11,"column":10,"nodeType":"1917","messageId":"1918","endLine":11,"endColumn":18},{"ruleId":"1964","severity":1,"message":"2471","line":94,"column":37,"nodeType":"1966","messageId":"1967","endLine":94,"endColumn":38,"suggestions":"2472"},{"ruleId":"1915","severity":1,"message":"2263","line":8,"column":5,"nodeType":"1917","messageId":"1918","endLine":8,"endColumn":17},{"ruleId":"1915","severity":1,"message":"2468","line":15,"column":10,"nodeType":"1917","messageId":"1918","endLine":15,"endColumn":20},{"ruleId":"1915","severity":1,"message":"2467","line":15,"column":22,"nodeType":"1917","messageId":"1918","endLine":15,"endColumn":25},{"ruleId":"1915","severity":1,"message":"2473","line":18,"column":25,"nodeType":"1917","messageId":"1918","endLine":18,"endColumn":31},{"ruleId":"1915","severity":1,"message":"2263","line":6,"column":5,"nodeType":"1917","messageId":"1918","endLine":6,"endColumn":17},{"ruleId":"1915","severity":1,"message":"1949","line":8,"column":5,"nodeType":"1917","messageId":"1918","endLine":8,"endColumn":12},{"ruleId":"1915","severity":1,"message":"2473","line":18,"column":23,"nodeType":"1917","messageId":"1918","endLine":18,"endColumn":29},{"ruleId":"1915","severity":1,"message":"2296","line":1,"column":17,"nodeType":"1917","messageId":"1918","endLine":1,"endColumn":22},{"ruleId":"1915","severity":1,"message":"2170","line":1,"column":40,"nodeType":"1917","messageId":"1918","endLine":1,"endColumn":48},{"ruleId":"1915","severity":1,"message":"2312","line":1,"column":69,"nodeType":"1917","messageId":"1918","endLine":1,"endColumn":78},{"ruleId":"1915","severity":1,"message":"1951","line":1,"column":80,"nodeType":"1917","messageId":"1918","endLine":1,"endColumn":81},{"ruleId":"1915","severity":1,"message":"2065","line":3,"column":5,"nodeType":"1917","messageId":"1918","endLine":3,"endColumn":11},{"ruleId":"1915","severity":1,"message":"2474","line":4,"column":13,"nodeType":"1917","messageId":"1918","endLine":4,"endColumn":26},{"ruleId":"1915","severity":1,"message":"1943","line":5,"column":5,"nodeType":"1917","messageId":"1918","endLine":5,"endColumn":11},{"ruleId":"1915","severity":1,"message":"2102","line":6,"column":5,"nodeType":"1917","messageId":"1918","endLine":6,"endColumn":10},{"ruleId":"1915","severity":1,"message":"2475","line":7,"column":5,"nodeType":"1917","messageId":"1918","endLine":7,"endColumn":11},{"ruleId":"1915","severity":1,"message":"2263","line":8,"column":5,"nodeType":"1917","messageId":"1918","endLine":8,"endColumn":17},{"ruleId":"1915","severity":1,"message":"2137","line":9,"column":5,"nodeType":"1917","messageId":"1918","endLine":9,"endColumn":15},{"ruleId":"1915","severity":1,"message":"2265","line":10,"column":5,"nodeType":"1917","messageId":"1918","endLine":10,"endColumn":12},{"ruleId":"1915","severity":1,"message":"2214","line":12,"column":5,"nodeType":"1917","messageId":"1918","endLine":12,"endColumn":18},{"ruleId":"1915","severity":1,"message":"2346","line":13,"column":5,"nodeType":"1917","messageId":"1918","endLine":13,"endColumn":18},{"ruleId":"1915","severity":1,"message":"2311","line":13,"column":20,"nodeType":"1917","messageId":"1918","endLine":13,"endColumn":27},{"ruleId":"1915","severity":1,"message":"2170","line":14,"column":5,"nodeType":"1917","messageId":"1918","endLine":14,"endColumn":13},{"ruleId":"1915","severity":1,"message":"2071","line":15,"column":5,"nodeType":"1917","messageId":"1918","endLine":15,"endColumn":13},{"ruleId":"1915","severity":1,"message":"1916","line":16,"column":5,"nodeType":"1917","messageId":"1918","endLine":16,"endColumn":10},{"ruleId":"1915","severity":1,"message":"2037","line":17,"column":5,"nodeType":"1917","messageId":"1918","endLine":17,"endColumn":11},{"ruleId":"1915","severity":1,"message":"1949","line":17,"column":13,"nodeType":"1917","messageId":"1918","endLine":17,"endColumn":20},{"ruleId":"1915","severity":1,"message":"1951","line":17,"column":22,"nodeType":"1917","messageId":"1918","endLine":17,"endColumn":23},{"ruleId":"1915","severity":1,"message":"2064","line":20,"column":5,"nodeType":"1917","messageId":"1918","endLine":20,"endColumn":18},{"ruleId":"1915","severity":1,"message":"2476","line":43,"column":10,"nodeType":"1917","messageId":"1918","endLine":43,"endColumn":23},{"ruleId":"1915","severity":1,"message":"2477","line":6,"column":5,"nodeType":"1917","messageId":"1918","endLine":6,"endColumn":11},{"ruleId":"1915","severity":1,"message":"2475","line":10,"column":5,"nodeType":"1917","messageId":"1918","endLine":10,"endColumn":11},{"ruleId":"1915","severity":1,"message":"2071","line":18,"column":5,"nodeType":"1917","messageId":"1918","endLine":18,"endColumn":13},{"ruleId":"1915","severity":1,"message":"2141","line":83,"column":13,"nodeType":"1917","messageId":"1918","endLine":83,"endColumn":14},{"ruleId":"1915","severity":1,"message":"2296","line":1,"column":17,"nodeType":"1917","messageId":"1918","endLine":1,"endColumn":22},{"ruleId":"1915","severity":1,"message":"2312","line":1,"column":60,"nodeType":"1917","messageId":"1918","endLine":1,"endColumn":69},{"ruleId":"1915","severity":1,"message":"1951","line":1,"column":71,"nodeType":"1917","messageId":"1918","endLine":1,"endColumn":72},{"ruleId":"1915","severity":1,"message":"2204","line":2,"column":16,"nodeType":"1917","messageId":"1918","endLine":2,"endColumn":29},{"ruleId":"1915","severity":1,"message":"1937","line":2,"column":31,"nodeType":"1917","messageId":"1918","endLine":2,"endColumn":43},{"ruleId":"1915","severity":1,"message":"2478","line":14,"column":9,"nodeType":"1917","messageId":"1918","endLine":14,"endColumn":19},{"ruleId":"1915","severity":1,"message":"2479","line":14,"column":21,"nodeType":"1917","messageId":"1918","endLine":14,"endColumn":31},{"ruleId":"1915","severity":1,"message":"2480","line":15,"column":10,"nodeType":"1917","messageId":"1918","endLine":15,"endColumn":16},{"ruleId":"1915","severity":1,"message":"2481","line":16,"column":10,"nodeType":"1917","messageId":"1918","endLine":16,"endColumn":26},{"ruleId":"2207","severity":1,"message":"2208","line":27,"column":5,"nodeType":"2209","messageId":"2210","endLine":29,"endColumn":6},{"ruleId":"2143","severity":1,"message":"2144","line":88,"column":218,"nodeType":"1957","messageId":"2145","endLine":88,"endColumn":219},{"ruleId":"2143","severity":1,"message":"2144","line":88,"column":418,"nodeType":"1957","messageId":"2145","endLine":88,"endColumn":419},{"ruleId":"2143","severity":1,"message":"2144","line":90,"column":217,"nodeType":"1957","messageId":"2145","endLine":90,"endColumn":218},{"ruleId":"2143","severity":1,"message":"2144","line":90,"column":419,"nodeType":"1957","messageId":"2145","endLine":90,"endColumn":420},{"ruleId":"2143","severity":1,"message":"2144","line":90,"column":611,"nodeType":"1957","messageId":"2145","endLine":90,"endColumn":612},{"ruleId":"1915","severity":1,"message":"2482","line":244,"column":43,"nodeType":"1917","messageId":"1918","endLine":244,"endColumn":49},{"ruleId":"1915","severity":1,"message":"2474","line":10,"column":5,"nodeType":"1917","messageId":"1918","endLine":10,"endColumn":18},{"ruleId":"1915","severity":1,"message":"2308","line":11,"column":5,"nodeType":"1917","messageId":"1918","endLine":11,"endColumn":12},{"ruleId":"1915","severity":1,"message":"1945","line":13,"column":5,"nodeType":"1917","messageId":"1918","endLine":13,"endColumn":23},{"ruleId":"1915","severity":1,"message":"2263","line":14,"column":5,"nodeType":"1917","messageId":"1918","endLine":14,"endColumn":17},{"ruleId":"1915","severity":1,"message":"2483","line":20,"column":5,"nodeType":"1917","messageId":"1918","endLine":20,"endColumn":17},{"ruleId":"1915","severity":1,"message":"2484","line":21,"column":5,"nodeType":"1917","messageId":"1918","endLine":21,"endColumn":19},{"ruleId":"1915","severity":1,"message":"2124","line":24,"column":5,"nodeType":"1917","messageId":"1918","endLine":24,"endColumn":27},{"ruleId":"1915","severity":1,"message":"2102","line":33,"column":17,"nodeType":"1917","messageId":"1918","endLine":33,"endColumn":22},{"ruleId":"1915","severity":1,"message":"1948","line":34,"column":8,"nodeType":"1917","messageId":"1918","endLine":34,"endColumn":26},{"ruleId":"1915","severity":1,"message":"2100","line":34,"column":57,"nodeType":"1917","messageId":"1918","endLine":34,"endColumn":74},{"ruleId":"1915","severity":1,"message":"2101","line":34,"column":76,"nodeType":"1917","messageId":"1918","endLine":34,"endColumn":87},{"ruleId":"1915","severity":1,"message":"2485","line":96,"column":5,"nodeType":"1917","messageId":"1918","endLine":96,"endColumn":16},{"ruleId":"1955","severity":1,"message":"1956","line":102,"column":26,"nodeType":"1957","messageId":"1958","endLine":102,"endColumn":28},{"ruleId":"2118","severity":1,"message":"2486","line":107,"column":124,"nodeType":"2016","messageId":"2120","endLine":107,"endColumn":181},{"ruleId":"1915","severity":1,"message":"2487","line":154,"column":10,"nodeType":"1917","messageId":"1918","endLine":154,"endColumn":20},{"ruleId":"1915","severity":1,"message":"2488","line":179,"column":18,"nodeType":"1917","messageId":"1918","endLine":179,"endColumn":27},{"ruleId":"1915","severity":1,"message":"2489","line":181,"column":10,"nodeType":"1917","messageId":"1918","endLine":181,"endColumn":18},{"ruleId":"1915","severity":1,"message":"2490","line":181,"column":20,"nodeType":"1917","messageId":"1918","endLine":181,"endColumn":31},{"ruleId":"1930","severity":1,"message":"2491","line":213,"column":8,"nodeType":"1932","endLine":213,"endColumn":25,"suggestions":"2492"},{"ruleId":"1915","severity":1,"message":"1938","line":3,"column":51,"nodeType":"1917","messageId":"1918","endLine":3,"endColumn":60},{"ruleId":"1915","severity":1,"message":"2358","line":20,"column":5,"nodeType":"1917","messageId":"1918","endLine":20,"endColumn":12},{"ruleId":"1915","severity":1,"message":"2493","line":29,"column":9,"nodeType":"1917","messageId":"1918","endLine":29,"endColumn":23},{"ruleId":"1915","severity":1,"message":"2373","line":35,"column":11,"nodeType":"1917","messageId":"1918","endLine":35,"endColumn":17},{"ruleId":"1915","severity":1,"message":"2494","line":37,"column":11,"nodeType":"1917","messageId":"1918","endLine":37,"endColumn":19},{"ruleId":"1915","severity":1,"message":"2495","line":44,"column":11,"nodeType":"1917","messageId":"1918","endLine":44,"endColumn":18},{"ruleId":"1915","severity":1,"message":"2496","line":52,"column":11,"nodeType":"1917","messageId":"1918","endLine":52,"endColumn":19},{"ruleId":"1915","severity":1,"message":"2458","line":2,"column":5,"nodeType":"1917","messageId":"1918","endLine":2,"endColumn":10},{"ruleId":"1997","severity":1,"message":"2020","line":183,"column":20,"nodeType":"1999","messageId":"2000","endLine":183,"endColumn":22},{"ruleId":"1997","severity":1,"message":"2020","line":183,"column":30,"nodeType":"1999","messageId":"2000","endLine":183,"endColumn":32},{"ruleId":"1915","severity":1,"message":"2497","line":268,"column":17,"nodeType":"1917","messageId":"1918","endLine":268,"endColumn":23},{"ruleId":"1915","severity":1,"message":"2498","line":276,"column":17,"nodeType":"1917","messageId":"1918","endLine":276,"endColumn":30},{"ruleId":"2143","severity":1,"message":"2144","line":323,"column":51,"nodeType":"1957","messageId":"2145","endLine":323,"endColumn":52},{"ruleId":"2143","severity":1,"message":"2144","line":326,"column":44,"nodeType":"1957","messageId":"2145","endLine":326,"endColumn":45},{"ruleId":"2143","severity":1,"message":"2144","line":329,"column":47,"nodeType":"1957","messageId":"2145","endLine":329,"endColumn":48},{"ruleId":"1983","severity":1,"message":"1984","line":354,"column":13,"nodeType":"1985","messageId":"1986","endLine":355,"endColumn":28},{"ruleId":"1915","severity":1,"message":"2260","line":3,"column":58,"nodeType":"1917","messageId":"1918","endLine":3,"endColumn":67},{"ruleId":"1915","severity":1,"message":"2297","line":5,"column":45,"nodeType":"1917","messageId":"1918","endLine":5,"endColumn":56},{"ruleId":"1915","severity":1,"message":"1948","line":9,"column":14,"nodeType":"1917","messageId":"1918","endLine":9,"endColumn":32},{"ruleId":"1915","severity":1,"message":"1949","line":10,"column":32,"nodeType":"1917","messageId":"1918","endLine":10,"endColumn":39},{"ruleId":"1915","severity":1,"message":"2499","line":449,"column":18,"nodeType":"1917","messageId":"1918","endLine":449,"endColumn":22},{"ruleId":"1915","severity":1,"message":"2500","line":449,"column":24,"nodeType":"1917","messageId":"1918","endLine":449,"endColumn":28},{"ruleId":"1915","severity":1,"message":"2501","line":2,"column":8,"nodeType":"1917","messageId":"1918","endLine":2,"endColumn":16},{"ruleId":"1915","severity":1,"message":"2502","line":3,"column":8,"nodeType":"1917","messageId":"1918","endLine":3,"endColumn":14},{"ruleId":"1915","severity":1,"message":"2503","line":4,"column":8,"nodeType":"1917","messageId":"1918","endLine":4,"endColumn":18},{"ruleId":"1915","severity":1,"message":"2504","line":5,"column":8,"nodeType":"1917","messageId":"1918","endLine":5,"endColumn":18},{"ruleId":"1915","severity":1,"message":"2505","line":6,"column":8,"nodeType":"1917","messageId":"1918","endLine":6,"endColumn":18},{"ruleId":"1915","severity":1,"message":"2506","line":7,"column":8,"nodeType":"1917","messageId":"1918","endLine":7,"endColumn":19},{"ruleId":"1915","severity":1,"message":"2507","line":8,"column":8,"nodeType":"1917","messageId":"1918","endLine":8,"endColumn":16},{"ruleId":"1915","severity":1,"message":"2508","line":9,"column":8,"nodeType":"1917","messageId":"1918","endLine":9,"endColumn":15},{"ruleId":"2354","severity":1,"message":"2355","line":51,"column":27,"nodeType":"2319","endLine":51,"endColumn":62},{"ruleId":"1915","severity":1,"message":"2399","line":1,"column":27,"nodeType":"1917","messageId":"1918","endLine":1,"endColumn":44},{"ruleId":"1915","severity":1,"message":"2477","line":3,"column":5,"nodeType":"1917","messageId":"1918","endLine":3,"endColumn":11},{"ruleId":"1915","severity":1,"message":"2263","line":5,"column":5,"nodeType":"1917","messageId":"1918","endLine":5,"endColumn":17},{"ruleId":"1915","severity":1,"message":"1948","line":9,"column":20,"nodeType":"1917","messageId":"1918","endLine":9,"endColumn":38},{"ruleId":"1915","severity":1,"message":"2483","line":10,"column":5,"nodeType":"1917","messageId":"1918","endLine":10,"endColumn":17},{"ruleId":"1915","severity":1,"message":"2174","line":11,"column":5,"nodeType":"1917","messageId":"1918","endLine":11,"endColumn":15},{"ruleId":"1915","severity":1,"message":"1949","line":11,"column":17,"nodeType":"1917","messageId":"1918","endLine":11,"endColumn":24},{"ruleId":"1915","severity":1,"message":"1972","line":200,"column":28,"nodeType":"1917","messageId":"1918","endLine":200,"endColumn":29},{"ruleId":"1915","severity":1,"message":"2265","line":4,"column":16,"nodeType":"1917","messageId":"1918","endLine":4,"endColumn":23},{"ruleId":"1930","severity":1,"message":"2509","line":25,"column":8,"nodeType":"1932","endLine":25,"endColumn":15,"suggestions":"2510"},{"ruleId":"1915","severity":1,"message":"2511","line":1,"column":17,"nodeType":"1917","messageId":"1918","endLine":1,"endColumn":23},{"ruleId":"1915","severity":1,"message":"2512","line":3,"column":26,"nodeType":"1917","messageId":"1918","endLine":3,"endColumn":38},{"ruleId":"1915","severity":1,"message":"2399","line":3,"column":40,"nodeType":"1917","messageId":"1918","endLine":3,"endColumn":57},{"ruleId":"1915","severity":1,"message":"2457","line":4,"column":63,"nodeType":"1917","messageId":"1918","endLine":4,"endColumn":71},{"ruleId":"1915","severity":1,"message":"2513","line":7,"column":9,"nodeType":"1917","messageId":"1918","endLine":7,"endColumn":17},{"ruleId":"1915","severity":1,"message":"2514","line":10,"column":27,"nodeType":"1917","messageId":"1918","endLine":10,"endColumn":30},{"ruleId":"2014","severity":1,"message":"2424","line":45,"column":23,"nodeType":"2031","messageId":"2515","endLine":45,"endColumn":30},{"ruleId":"1915","severity":1,"message":"2516","line":15,"column":17,"nodeType":"1917","messageId":"1918","endLine":15,"endColumn":28},{"ruleId":"1915","severity":1,"message":"2517","line":37,"column":11,"nodeType":"1917","messageId":"1918","endLine":37,"endColumn":28},{"ruleId":"1915","severity":1,"message":"2518","line":3,"column":51,"nodeType":"1917","messageId":"1918","endLine":3,"endColumn":54},{"ruleId":"1915","severity":1,"message":"2519","line":3,"column":67,"nodeType":"1917","messageId":"1918","endLine":3,"endColumn":81},{"ruleId":"1915","severity":1,"message":"2520","line":50,"column":9,"nodeType":"1917","messageId":"1918","endLine":50,"endColumn":22},{"ruleId":"1964","severity":1,"message":"2521","line":247,"column":47,"nodeType":"1966","messageId":"1967","endLine":247,"endColumn":48,"suggestions":"2522"},{"ruleId":"1915","severity":1,"message":"2523","line":321,"column":9,"nodeType":"1917","messageId":"1918","endLine":321,"endColumn":26},{"ruleId":"1915","severity":1,"message":"2524","line":322,"column":9,"nodeType":"1917","messageId":"1918","endLine":322,"endColumn":50},{"ruleId":"1915","severity":1,"message":"2525","line":323,"column":14,"nodeType":"1917","messageId":"1918","endLine":323,"endColumn":20},{"ruleId":"1915","severity":1,"message":"2526","line":360,"column":11,"nodeType":"1917","messageId":"1918","endLine":360,"endColumn":16},{"ruleId":"1915","severity":1,"message":"1939","line":1,"column":16,"nodeType":"1917","messageId":"1918","endLine":1,"endColumn":24},{"ruleId":"1915","severity":1,"message":"1937","line":1,"column":26,"nodeType":"1917","messageId":"1918","endLine":1,"endColumn":38},{"ruleId":"1915","severity":1,"message":"1942","line":2,"column":9,"nodeType":"1917","messageId":"1918","endLine":2,"endColumn":16},{"ruleId":"1915","severity":1,"message":"1943","line":3,"column":9,"nodeType":"1917","messageId":"1918","endLine":3,"endColumn":15},{"ruleId":"1915","severity":1,"message":"2446","line":4,"column":9,"nodeType":"1917","messageId":"1918","endLine":4,"endColumn":23},{"ruleId":"1915","severity":1,"message":"2527","line":10,"column":11,"nodeType":"1917","messageId":"1918","endLine":10,"endColumn":19},{"ruleId":"1915","severity":1,"message":"2416","line":19,"column":11,"nodeType":"1917","messageId":"1918","endLine":19,"endColumn":15},{"ruleId":"1915","severity":1,"message":"2500","line":7,"column":11,"nodeType":"1917","messageId":"1918","endLine":7,"endColumn":15},{"ruleId":"1915","severity":1,"message":"2527","line":8,"column":11,"nodeType":"1917","messageId":"1918","endLine":8,"endColumn":19},{"ruleId":"1915","severity":1,"message":"2528","line":9,"column":9,"nodeType":"1917","messageId":"1918","endLine":9,"endColumn":14},{"ruleId":"1915","severity":1,"message":"1939","line":1,"column":16,"nodeType":"1917","messageId":"1918","endLine":1,"endColumn":24},{"ruleId":"1915","severity":1,"message":"2403","line":1,"column":51,"nodeType":"1917","messageId":"1918","endLine":1,"endColumn":60},{"ruleId":"1915","severity":1,"message":"2140","line":1,"column":62,"nodeType":"1917","messageId":"1918","endLine":1,"endColumn":70},{"ruleId":"1915","severity":1,"message":"1942","line":2,"column":9,"nodeType":"1917","messageId":"1918","endLine":2,"endColumn":16},{"ruleId":"1915","severity":1,"message":"2057","line":3,"column":14,"nodeType":"1917","messageId":"1918","endLine":3,"endColumn":24},{"ruleId":"1915","severity":1,"message":"2260","line":3,"column":26,"nodeType":"1917","messageId":"1918","endLine":3,"endColumn":35},{"ruleId":"1915","severity":1,"message":"1943","line":3,"column":46,"nodeType":"1917","messageId":"1918","endLine":3,"endColumn":52},{"ruleId":"1915","severity":1,"message":"2483","line":3,"column":54,"nodeType":"1917","messageId":"1918","endLine":3,"endColumn":66},{"ruleId":"1915","severity":1,"message":"1949","line":3,"column":68,"nodeType":"1917","messageId":"1918","endLine":3,"endColumn":75},{"ruleId":"1915","severity":1,"message":"2408","line":3,"column":77,"nodeType":"1917","messageId":"1918","endLine":3,"endColumn":81},{"ruleId":"1915","severity":1,"message":"1951","line":4,"column":34,"nodeType":"1917","messageId":"1918","endLine":4,"endColumn":35},{"ruleId":"1915","severity":1,"message":"2529","line":6,"column":9,"nodeType":"1917","messageId":"1918","endLine":6,"endColumn":18},{"ruleId":"1915","severity":1,"message":"2325","line":9,"column":10,"nodeType":"1917","messageId":"1918","endLine":9,"endColumn":17},{"ruleId":"1915","severity":1,"message":"2530","line":48,"column":7,"nodeType":"1917","messageId":"1918","endLine":48,"endColumn":27},{"ruleId":"1915","severity":1,"message":"2531","line":215,"column":9,"nodeType":"1917","messageId":"1918","endLine":215,"endColumn":23},{"ruleId":"1915","severity":1,"message":"2532","line":3,"column":10,"nodeType":"1917","messageId":"1918","endLine":3,"endColumn":15},{"ruleId":"1915","severity":1,"message":"2434","line":4,"column":9,"nodeType":"1917","messageId":"1918","endLine":4,"endColumn":12},{"ruleId":"1915","severity":1,"message":"2358","line":5,"column":10,"nodeType":"1917","messageId":"1918","endLine":5,"endColumn":17},{"ruleId":"1915","severity":1,"message":"2533","line":7,"column":10,"nodeType":"1917","messageId":"1918","endLine":7,"endColumn":25},{"ruleId":"1915","severity":1,"message":"2534","line":8,"column":10,"nodeType":"1917","messageId":"1918","endLine":8,"endColumn":30},{"ruleId":"1915","severity":1,"message":"1943","line":9,"column":10,"nodeType":"1917","messageId":"1918","endLine":9,"endColumn":16},{"ruleId":"1915","severity":1,"message":"2535","line":10,"column":10,"nodeType":"1917","messageId":"1918","endLine":10,"endColumn":24},{"ruleId":"1915","severity":1,"message":"2536","line":10,"column":26,"nodeType":"1917","messageId":"1918","endLine":10,"endColumn":42},"@typescript-eslint/no-unused-vars","'LUser' is defined but never used.","Identifier","unusedVar","'R' is defined but never used.","'SetRootFieldAction' is defined but never used.","'statehistory' is defined but never used.","'useEffectOnce' is defined but never used.","'BrowserRouter' is defined but never used.","'useless' is assigned a value but never used.","'LogType' is defined but never used.","'pathDataPolyfill' is assigned a value but never used.","'w' is assigned a value but never used.","'joiner' is defined but never used.","'Joiner' is defined but never used.","react-hooks/exhaustive-deps","React Hook useEffect has a missing dependency: 'renders'. Either include it or remove the dependency array.","ArrayExpression",["2537"],"'paused' is assigned a value but never used.","'cancel_button' is assigned a value but never used.","'confirm_button' is assigned a value but never used.","'ReactElement' is defined but never used.","'ReactNode' is defined but never used.","'Dispatch' is defined but never used.","'KeyboardEvent' is defined but never used.","'LegacyRef' is defined but never used.","'connect' is defined but never used.","'DState' is defined but never used.","'Defaults' is defined but never used.","'DPointerTargetable' is defined but never used.","'DV' is defined but never used.","'Keystrokes' is defined but never used.","'LPointerTargetable' is defined but never used.","'Pointer' is defined but never used.","'store' is defined but never used.","'U' is defined but never used.","'LoggerCategoryState' is defined but never used.","'l' is assigned a value but never used.","'t' is assigned a value but never used.","eqeqeq","Expected '===' and instead saw '=='.","BinaryExpression","unexpected","no-redeclare","'m' is already defined.","redeclared","Expected '!==' and instead saw '!='.","'n' is already defined.","no-useless-escape","Unnecessary escape character: \\\".","Literal","unnecessaryEscape",["2538","2539"],"'React' is defined but never used.","'CtorArgs' is defined but never used.","'IsAbstract' is defined but never used.","'T' is defined but never used.","'COMMENT' is defined but never used.","'KeysnotOfType' is defined but never used.","'refkeys' is defined but never used.","'afterStoreLoad' is defined but never used.","'PointedBy' is defined but never used.","'ERROR' is defined but never used.","'isError' is assigned a value but never used.","'context' is assigned a value but never used.","'retRaw' is assigned a value but never used.","'val' is assigned a value but never used.","no-unreachable","Unreachable code.","ExpressionStatement","unreachableCode","'PrimitiveType' is defined but never used.","'ProjectsApi' is defined but never used.","no-extend-native","Array prototype is read only, properties should not be added.","AssignmentExpression","no-eval","eval can be harmful.","CallExpression","'RET' is defined but never used.","'outerthis' is assigned a value but never used.","no-mixed-operators","Unexpected mix of '||' and '&&'. Use parentheses to clarify the intended order of operations.","LogicalExpression","unexpectedMixedOperator","'D' is defined but never used.","'thiss' is assigned a value but never used.","'ll' is assigned a value but never used.","'UP' is defined but never used.","'INFERRED' is defined but never used.","'target' is assigned a value but never used.","'objectChain' is assigned a value but never used.","Unnecessary escape character: \\'.",["2540","2541"],["2542","2543"],"'a' is assigned a value but never used.","'c' is assigned a value but never used.","'b' is assigned a value but never used.","array-callback-return","Array.prototype.map() expects a value to be returned at the end of arrow function.","ArrowFunctionExpression","expectedAtEnd","'bbb' is assigned a value but never used.","'bb2' is assigned a value but never used.","Unexpected mix of '&&' and '||'. Use parentheses to clarify the intended order of operations.","'T2' is defined but never used.","'T3' is defined but never used.","'T4' is defined but never used.","'goalSignature' is assigned a value but never used.","'subtract' is defined but never used.","'Exclude3' is defined but never used.","'Override' is defined but never used.","'RemoveKeysOfType' is defined but never used.","'TransientPropertiesByGraphTab' is defined but never used.","'str' is defined but never used.","ReturnStatement","'PointLike' is defined but never used.","'$element' is assigned a value but never used.","'tmp' is defined but never used.","VariableDeclaration","'main' is assigned a value but never used.","'LValue' is defined but never used.","'CreateElementAction' is defined but never used.","'Debug' is defined but never used.","'Ret' is defined but never used.","'JsonSavePack' is defined but never used.","'key1' is assigned a value but never used.","IfStatement","'childs' is assigned a value but never used.","@typescript-eslint/no-use-before-define","'AccessModifier' was used before it was defined.","noUseBeforeDefine","'NotPromise' is defined but never used.","'NoAsyncFn' is defined but never used.","'arrayFieldNameTypes' is defined but never used.","'StrictExclude' is defined but never used.","'F' is defined but never used.","'AbstractConstructor' is defined but never used.","'Constructor' is defined but never used.","'DAttribute' is defined but never used.","'DEnumerator' is defined but never used.","'Dictionary' is defined but never used.","'DProject' is defined but never used.","'shorttype' is assigned a value but never used.","'firstEvaluationForNode' is assigned a value but never used.","'oldScore' is assigned a value but never used.","'printstuff' is assigned a value but never used.","'Scored' is defined but never used.","'DModelElement' is defined but never used.","'DModel' is defined but never used.","'EdgeOwnProps' is defined but never used.","'EdgeStateProps' is defined but never used.","'bool' is defined but never used.","'Uarr' is defined but never used.","'LocalStorage' is defined but never used.","'LProject' is defined but never used.","'COMMIT' is defined but never used.","'OclEngine' is defined but never used.","'Storage' is defined but never used.","'storeLoaded' is assigned a value but never used.","no-new-func","The Function constructor is eval.","NewExpression","noFunctionConstructor","Unnecessary escape character: \\..",["2544","2545"],"'debug' is assigned a value but never used.","'forUser' is assigned a value but never used.","'fixResizables' is defined but never used.","'GraphSize' is defined but never used.","'Context' is defined but never used.","'GraphElementComponent' is defined but never used.","'VoidVertex' is defined but never used.","'VertexComponent' is defined but never used.","'Nonagon' is defined but never used.","'Septagon' is defined but never used.","'Star' is defined but never used.","'DefaultNode' is defined but never used.","'DefaultNodeComponent' is defined but never used.","'GraphsContainer' is defined but never used.","'GraphsContainerComponent' is defined but never used.","'EdgeComponent' is defined but never used.","'GenericInput' is defined but never used.","'Control' is defined but never used.","'EMeasurableEvents' is defined but never used.","'TRANSACTION' is defined but never used.","'DUser' is defined but never used.","'MyError' is defined but never used.","'Collaborative' is defined but never used.","'Await' is defined but never used.","'result' is assigned a value but never used.","'base0' is assigned a value but never used.","Unnecessary escape character: \\/.",["2546","2547"],"Unnecessary escape character: \\,.",["2548","2549"],"'i' is assigned a value but never used.","'countsize' is assigned a value but never used.","'child' is assigned a value but never used.",["2550","2551"],"Unnecessary escape character: \\_.",["2552","2553"],"no-loop-func","Function declared in a loop contains unsafe references to variable(s) 'fileLetti', 'fileLetti'.","unsafeRefs","'AttribETypes' was used before it was defined.","'DefaultEClasses' was used before it was defined.","'ReactJson' is defined but never used.","'RuntimeAccessibleClass' is defined but never used.","'Convert' is assigned a value but never used.","'istyle' is assigned a value but never used.","no-fallthrough","Expected a 'break' statement before 'case'.","SwitchCase","case","'confirm' is assigned a value but never used.","Unnecessary escape character: \\].",["2554","2555"],"no-cond-assign","Expected a conditional expression and instead saw an assignment.","missing","'DViewPoint' is defined but never used.","'DVoidEdge' is defined but never used.","'Draggable' is defined but never used.","'useState' is defined but never used.","'d' is assigned a value but never used.","'ErrorProps' is defined but never used.","no-useless-concat","Unexpected string concatenation of literals.","unexpectedConcat","no-template-curly-in-string","Unexpected template string expression.","unexpectedTemplateExpression","BreakStatement","'Asterisk' is defined but never used.","'Circle' is defined but never used.","'CoordinateMode' is defined but never used.","'Cross' is defined but never used.","'Decagon' is defined but never used.","'DecoratedStar' is defined but never used.","'DExtEdge' is defined but never used.","'DRefEdge' is defined but never used.","'Edge' is defined but never used.","'EdgeBendingMode' is defined but never used.","'EdgePoint' is defined but never used.","'Ellipse' is defined but never used.","'Enneagon' is defined but never used.","'Field' is defined but never used.","'Graph' is defined but never used.","'GraphElement' is defined but never used.","'GraphVertex' is defined but never used.","'Heptagon' is defined but never used.","'Hexagon' is defined but never used.","'LOperation' is defined but never used.","'LPackage' is defined but never used.","'LParameter' is defined but never used.","'LRefEdge' is defined but never used.","'LReference' is defined but never used.","'LViewPoint' is defined but never used.","'Octagon' is defined but never used.","'Pentagon' is defined but never used.","'Polygon' is defined but never used.","'Rectangle' is defined but never used.","'SetFieldAction' is defined but never used.","'SimpleStar' is defined but never used.","'Square' is defined but never used.","'Trapezoid' is defined but never used.","'Triangle' is defined but never used.","'Vertex' is defined but never used.","'GraphElements' is defined but never used.","'Graphs' is defined but never used.","'Vertexes' is defined but never used.","'Edges' is defined but never used.","'Fields' is defined but never used.","'defaultEcoreClass' is assigned a value but never used.","'C' is defined but never used.","'RuntimeAccessible' is defined but never used.","'oclResult' is assigned a value but never used.","'RefObject' is defined but never used.","'testmode' is assigned a value but never used.","'commonAncestor' is assigned a value but never used.","Function declared in a loop contains unsafe references to variable(s) 's0', 's00'.","'zoom' is assigned a value but never used.","'printablesegment' is defined but never used.","'longestLabel' is assigned a value but never used.","'bm' is assigned a value but never used.","'prevendpt' is assigned a value but never used.","'selector' is assigned a value but never used.","'PureComponent' is defined but never used.","'Json' is defined but never used.","'orArr' is defined but never used.","@typescript-eslint/no-useless-constructor","Useless constructor.","MethodDefinition","noUselessConstructor","'DEdgePoint' is defined but never used.","'EdgeSegment' is defined but never used.","'LEdge' is defined but never used.","'LGraphElement' is defined but never used.","'LVoidEdge' is defined but never used.","'ViewEClassMatch' is defined but never used.","'DSL' is defined but never used.","'vp' is assigned a value but never used.","'EdgePointers' is defined but never used.","'AnnotationPointers' is defined but never used.","'GraphPointers' is defined but never used.","'VertexPointers' is defined but never used.","'ShortDefaultEClasses' is defined but never used.","'targetObj' is assigned a value but never used.","'proxyitself' is assigned a value but never used.","'lclass' is assigned a value but never used.","'mapfunc' is defined but never used.","'type0' is assigned a value but never used.","no-self-compare","Comparing to itself is potentially pointless.","comparingToSelf","'de' is assigned a value but never used.","'supertypesstr' is assigned a value but never used.","no-whitespace-before-property","Unexpected whitespace before property data.","MemberExpression","unexpectedWhitespace",{"range":"2556","text":"2557"},"'le' is assigned a value but never used.","'ebyIDS' is assigned a value but never used.","'map' is assigned a value but never used.","'has_opposite' is defined but never used.","'obsolete_attribute' is defined but never used.","'DPrimitiveType' is defined but never used.","'LPrimitiveType' is defined but never used.","'T1' is defined but never used.","no-extra-label","This label 'inner' is unnecessary.",{"range":"2558","text":"2559"},{"range":"2560","text":"2559"},{"range":"2561","text":"2559"},{"range":"2562","text":"2559"},"'otherEdgeEnds' is assigned a value but never used.","'oldinstanceof' is assigned a value but never used.","'isDModel' is assigned a value but never used.","'havepointers' is assigned a value but never used.","'haveLelements' is assigned a value but never used.","'oldv' is assigned a value but never used.","'isContainment' is assigned a value but never used.","'DocString' is defined but never used.","'DReference' is defined but never used.","'DStructuralFeature' is defined but never used.","'DViewElement' is defined but never used.","'EdgeGapMode' is defined but never used.","'GObject' is defined but never used.","'GraphPoint' is defined but never used.","'LClass' is defined but never used.","'LState' is defined but never used.","'NumberControl' is defined but never used.","'PaletteControl' is defined but never used.","'PathControl' is defined but never used.","'StringControl' is defined but never used.","'L' is defined but never used.","'nosize' is assigned a value but never used.","'MouseUpEvent' is defined but never used.","'Selectors_' is defined but never used.","'Size' is defined but never used.","'WGraph' is defined but never used.","'GraphDragManager' is defined but never used.","'DefaultUsageDeclarations' is defined but never used.","'InOutParam' is defined but never used.","'maxRenderCounter' is assigned a value but never used.","'tnv' is assigned a value but never used.","'tv' is assigned a value but never used.","'p' is assigned a value but never used.","'scroll' is assigned a value but never used.","'ref' is assigned a value but never used.","'tn' is assigned a value but never used.","'children' is assigned a value but never used.","'field' is assigned a value but never used.",["2563","2564"],"'OwnProps' is defined but never used.","'StateProps' is defined but never used.","'DispatchProps' is defined but never used.","'LModel' is defined but never used.","'Input' is defined but never used.","'LEnumerator' is defined but never used.","'showTooltip' is assigned a value but never used.","'setShowTooltip' is assigned a value but never used.","'label' is assigned a value but never used.","'jsxLabel' is assigned a value but never used.","'oldValue' is assigned a value but never used.","no-lone-blocks","Nested block is redundant.","BlockStatement","redundantNestedBlock","'Any' is defined but never used.","'DObject' is defined but never used.","'LAttribute' is defined but never used.","'LEnumLiteral' is defined but never used.","'LObject' is defined but never used.","'Selectors' is defined but never used.","'openSelect' is assigned a value but never used.","'compressToUTF16' is defined but never used.","'decompressFromUTF16' is defined but never used.","'mongoreport' is assigned a value but never used.","react/jsx-no-target-blank","Using target=\"_blank\" without rel=\"noreferrer\" (which implies rel=\"noopener\") is a security risk in older browsers: see https://mathiasbynens.github.io/rel-noopener/#recommendations","JSXOpeningElement","noTargetBlankWithoutNoreferrer",{"range":"2565","text":"2566"},"'ClickEvent' is defined but never used.","'ControlPanel' is defined but never used.","'useRef' is defined but never used.","'Tooltip' is defined but never used.","'CheckReturnTYpe' is defined but never used.","'notification' is assigned a value but never used.","'useClickOutside' is defined but never used.","'updateValue' is defined but never used.","'CSSProperties' is defined but never used.","'ResizableOptions' is defined but never used.","'RotatabeOptions' is defined but never used.","Function declared in a loop contains unsafe references to variable(s) 'key', 'key', 'key', 'key', 'key', 'key', 'key', 'key', 'key'.","'DGraph' is defined but never used.","'DGraphElement' is defined but never used.","'DGraphVertex' is defined but never used.","'DVoidVertex' is defined but never used.","'GraphElementOwnProps' is defined but never used.","'GraphElementReduxStateProps' is defined but never used.","'LModelElement' is defined but never used.","'LVoidVertex' is defined but never used.","'superclassGraphElementComponentuntyped' is assigned a value but never used.","'makeAsterisk' is defined but never used.","'DClassifier' is defined but never used.","'DPackage' is defined but never used.","'LNamedElement' is defined but never used.","'ContextMenu' is defined but never used.","'isEdge' is assigned a value but never used.","'now' is assigned a value but never used.","'old' is assigned a value but never used.","'Props' is defined but never used.","'animal' is assigned a value but never used.","'setAnimal' is assigned a value but never used.","jsx-a11y/alt-text","img elements must have an alt prop, either with meaningful text, or an empty string for decorative images.","'meanBy' is defined but never used.","'IconTheme' is defined but never used.","'windoww' is defined but never used.","'storage' is defined but never used.","'SaveManager' is defined but never used.","'Link' is defined but never used.","'Divisor' is assigned a value but never used.","'Share' is defined but never used.","'time' is defined but never used.","'ProjectType' is defined but never used.","'sectionStyle' is assigned a value but never used.","'Empty' is assigned a value but never used.","'formattedDate2' is assigned a value but never used.","'User' is assigned a value but never used.","'titleRef' is assigned a value but never used.","'desRef' is assigned a value but never used.","'ProjectDashboardProps' is defined but never used.","'active' is assigned a value but never used.","'user' is assigned a value but never used.","'MetricsPanelManager' is defined but never used.","'version' is assigned a value but never used.","'advanced' is assigned a value but never used.","'focussed' is assigned a value but never used.","'setFocussed' is assigned a value but never used.","'projectItems2' is assigned a value but never used.","'dashboardItems2' is assigned a value but never used.","'MainMenu2' is assigned a value but never used.","'Loader' is defined but never used.","'Navbar' is defined but never used.","React Hook useEffect has a missing dependency: 'user'. Either include it or remove the dependency array.",["2567"],"react/style-prop-object","Style prop value must be an object","JSXAttribute","stylePropNotObject","'Card' is defined but never used.","'Catalog' is defined but never used.","'Divisor' is defined but never used.","'colors' is defined but never used.","'items_public' is assigned a value but never used.","'items_private' is assigned a value but never used.","'items_collaborative' is assigned a value but never used.","'importProject' is assigned a value but never used.","'MouseEventHandler' is defined but never used.","'Project' is defined but never used.","'Menu' is defined but never used.","'Item' is defined but never used.","'useEffect' is defined but never used.","'EditCountry' is defined but never used.","'AuthApi' is defined but never used.","'ResetPasswordRequest' is defined but never used.","'LoginRequest' is defined but never used.","'Info' is defined but never used.","'Log' is defined but never used.","'jsonstring0' is assigned a value but never used.","'end' is assigned a value but never used.","'lmodel' is assigned a value but never used.","React Hook useEffect has missing dependencies: 'actions' and 'project.id'. Either include them or remove the dependency array. You can also do a functional update 'setActions(a => ...)' if you only need 'actions' in the 'setActions' call.",["2568"],"'windoww' is assigned a value but never used.","'type' is assigned a value but never used.","'ReactHTML' is defined but never used.","'getFragment' is defined but never used.","'CardsType' is defined but never used.","'SaveManagerProps' is defined but never used.","'s' is assigned a value but never used.","'strings' is assigned a value but never used.","'list' is assigned a value but never used.","Array.prototype.map() expects a return value from arrow function.","expectedInside","'newstyle' is assigned a value but never used.","'entry' is assigned a value but never used.","'undostr' is assigned a value but never used.","'UsersApi' is defined but never used.","'Logo2' is defined but never used.","'TbSquareRoundedLetterV' is defined but never used.","'TbSquareRoundedLetterVFilled' is defined but never used.","'TbSquareRoundedLetterE' is defined but never used.","'int' is defined but never used.","'isProjectModified' is defined but never used.","'Toolbar' is defined but never used.","'ClassAttributes' is defined but never used.","'inherits' is defined but never used.","'style' is assigned a value but never used.","'JwtPayload' is defined but never used.","rest-spread-spacing","Unexpected whitespace after spread property operator.","SpreadElement",{"range":"2569","text":"2559"},"'MetricsPanel' is defined but never used.","'FakeStateProps' is defined but never used.","'JsEditor' is defined but never used.","'groupsarr' is assigned a value but never used.","'makeInput' is defined but never used.","'actions' is assigned a value but never used.","'setActions' is assigned a value but never used.","'name' is assigned a value but never used.","'metamodels' is assigned a value but never used.","'models' is assigned a value but never used.","'m2Row' is defined but never used.","'m1Row' is defined but never used.","'TextArea' is defined but never used.","'DEdge' is defined but never used.","'InputRowProps' is defined but never used.","'JwtClaims' is defined but never used.","'Component' is defined but never used.","'LoggerComponent' is defined but never used.","'BoxData' is defined but never used.","'strip' is assigned a value but never used.","'dropIndicator' is assigned a value but never used.","'currentDropArea' is assigned a value but never used.","'Btn' is defined but never used.","'CommandBar' is defined but never used.","'monacoTypes' is defined but never used.","'uniqueId' is defined but never used.","Unnecessary escape character: \\:.",["2570","2571"],"'height' is assigned a value but never used.","'DNamedElement' is defined but never used.","'DValue' is defined but never used.","'getReferences' is defined but never used.","'DClass' is defined but never used.","'DockLayout' is defined but never used.","'LayoutData' is defined but never used.","'Slider' is defined but never used.","'MultilineTextBox' is defined but never used.","'source' is assigned a value but never used.","'LViewElement' is defined but never used.","'MyProxyHandler' is defined but never used.","'n_agonSides' is assigned a value but never used.","Function declared in a loop contains unsafe references to variable(s) 'data'.","'selectNode' is defined but never used.","'setPinned' is assigned a value but never used.","'position' is assigned a value but never used.","'setPosition' is assigned a value but never used.","React Hook useEffect has an unnecessary dependency: 'htmlref.current'. Either exclude it or remove the dependency array. Mutable values like 'htmlref.current' aren't valid dependencies because mutating them doesn't re-render the component.",["2572"],"'InternalToggle' is defined but never used.","'editName' is assigned a value but never used.","'deleteV' is assigned a value but never used.","'deleteVP' is assigned a value but never used.","'hidden' is assigned a value but never used.","'commentsPopup' is assigned a value but never used.","'node' is assigned a value but never used.","'view' is assigned a value but never used.","'EPackage' is defined but never used.","'EClass' is defined but never used.","'EAttribute' is defined but never used.","'EReference' is defined but never used.","'EOperation' is defined but never used.","'EEnumerator' is defined but never used.","'ELiteral' is defined but never used.","'Utility' is defined but never used.","React Hook useEffect has a missing dependency: 'emails'. Either include it or remove the dependency array. You can also replace multiple useState variables with useReducer if 'setFilteredEmails' needs the current value of 'emails'.",["2573"],"'Select' is defined but never used.","'EventHandler' is defined but never used.","'Function' is defined but never used.","'Sep' is defined but never used.","expectedReturnValue","'MultiSelect' is defined but never used.","'classesOptionsJSX' is assigned a value but never used.","'Ref' is defined but never used.","'SyntheticEvent' is defined but never used.","'roundedValue0' is assigned a value but never used.","Unnecessary escape character: \\-.",["2574","2575"],"'a' is defined but never used.","'dropDownButton' is assigned a value but never used.","'addcss' is defined but never used.","'lines' is assigned a value but never used.","'readOnly' is assigned a value but never used.","'empty' is assigned a value but never used.","'stringify' is defined but never used.","'minimalTextareaValue' is assigned a value but never used.","'transitionTime' is assigned a value but never used.","'event' is defined but never used.","'MapStateToProps' is defined but never used.","'InputMapStateToProps' is defined but never used.","'VertexOwnProps' is defined but never used.","'VertexStateProps' is defined but never used.",{"desc":"2576","fix":"2577"},{"messageId":"2578","fix":"2579","desc":"2580"},{"messageId":"2581","fix":"2582","desc":"2583"},{"messageId":"2578","fix":"2584","desc":"2580"},{"messageId":"2581","fix":"2585","desc":"2583"},{"messageId":"2578","fix":"2586","desc":"2580"},{"messageId":"2581","fix":"2587","desc":"2583"},{"messageId":"2578","fix":"2588","desc":"2580"},{"messageId":"2581","fix":"2589","desc":"2583"},{"messageId":"2578","fix":"2590","desc":"2580"},{"messageId":"2581","fix":"2591","desc":"2583"},{"messageId":"2578","fix":"2592","desc":"2580"},{"messageId":"2581","fix":"2593","desc":"2583"},{"messageId":"2578","fix":"2594","desc":"2580"},{"messageId":"2581","fix":"2595","desc":"2583"},{"messageId":"2578","fix":"2596","desc":"2580"},{"messageId":"2581","fix":"2597","desc":"2583"},{"messageId":"2578","fix":"2598","desc":"2580"},{"messageId":"2581","fix":"2599","desc":"2583"},[118592,118594],".",[236141,236147],"",[236320,236326],[236590,236596],[236712,236718],{"messageId":"2578","fix":"2600","desc":"2580"},{"messageId":"2581","fix":"2601","desc":"2583"},[6141,6141]," rel=\"noreferrer\"",{"desc":"2602","fix":"2603"},{"desc":"2604","fix":"2605"},[3856,3857],{"messageId":"2578","fix":"2606","desc":"2580"},{"messageId":"2581","fix":"2607","desc":"2583"},{"desc":"2608","fix":"2609"},{"desc":"2610","fix":"2611"},{"messageId":"2578","fix":"2612","desc":"2580"},{"messageId":"2581","fix":"2613","desc":"2583"},"Update the dependencies array to be: [pathname, renders]",{"range":"2614","text":"2615"},"removeEscape",{"range":"2616","text":"2559"},"Remove the `\\`. This maintains the current functionality.","escapeBackslash",{"range":"2617","text":"2618"},"Replace the `\\` with `\\\\` to include the actual backslash character.",{"range":"2619","text":"2559"},{"range":"2620","text":"2618"},{"range":"2621","text":"2559"},{"range":"2622","text":"2618"},{"range":"2623","text":"2559"},{"range":"2624","text":"2618"},{"range":"2625","text":"2559"},{"range":"2626","text":"2618"},{"range":"2627","text":"2559"},{"range":"2628","text":"2618"},{"range":"2629","text":"2559"},{"range":"2630","text":"2618"},{"range":"2631","text":"2559"},{"range":"2632","text":"2618"},{"range":"2633","text":"2559"},{"range":"2634","text":"2618"},{"range":"2635","text":"2559"},{"range":"2636","text":"2618"},"Update the dependencies array to be: [id, user]",{"range":"2637","text":"2638"},"Update the dependencies array to be: [actions, project.id]",{"range":"2639","text":"2640"},{"range":"2641","text":"2559"},{"range":"2642","text":"2618"},"Update the dependencies array to be: []",{"range":"2643","text":"2644"},"Update the dependencies array to be: [email, emails]",{"range":"2645","text":"2646"},{"range":"2647","text":"2559"},{"range":"2648","text":"2618"},[450,460],"[pathname, renders]",[5160,5161],[5160,5160],"\\",[93044,93045],[93044,93044],[93067,93068],[93067,93067],[37891,37892],[37891,37891],[34504,34505],[34504,34504],[34506,34507],[34506,34506],[116978,116979],[116978,116978],[116980,116981],[116980,116980],[14743,14744],[14743,14743],[9384,9385],[9384,9384],[1788,1792],"[id, user]",[1347,1349],"[actions, project.id]",[4229,4230],[4229,4229],[9295,9312],"[]",[979,986],"[email, emails]",[10858,10859],[10858,10858]]