{"ast":null,"code":"import { Action, CompositeAction, CreateElementAction, DeleteElementAction, IStore, Log, MyError, RuntimeAccessibleClass, SetFieldAction, SetRootFieldAction, getPath, Selectors, PointedBy, PendingPointedByPaths, statehistory, DUser } from \"../../joiner\";\nimport React from \"react\";\nimport { LoadAction, RedoAction, UndoAction } from \"../action/action\";\nlet windoww = window;\nlet U = windoww.U;\nfunction deepCopyButOnlyFollowingPath(oldStateDoNotModify, action, prevAction, newVal) {\n  var _action$path;\n  let newRoot = {\n    ...oldStateDoNotModify\n  };\n  let current = newRoot;\n  if (!((_action$path = action.path) === null || _action$path === void 0 ? void 0 : _action$path.length)) throw new MyError(\"path length must be at least 1\", {\n    action\n  });\n  let gotChanged = false; // dovrebbe cambiare sempre, se non cambia non lancio neanche l'azione e non faccio la shallow copy, ma non si sa mai, così posso evitare un render se succede l' \"insuccedibile\"\n  let alreadyPastDivergencePoint = false; // true dal momento in cui il path dell'azione attuale e della azione precedente divergono, false fino al sotto-segmento in cui combaciano\n  // console.log('deepCopyButOnlyFollowingPath', arguments);\n  for (let i = 0; i < action.pathArray.length; i++) {\n    let key = action.pathArray[i].trim();\n    let prevActionPathKey = prevAction === null || prevAction === void 0 ? void 0 : prevAction.pathArray[i];\n    // middle execution: not on final loop\n    // console.log('deepCopyButOnlyFollowingPath', {current, i, imax:action.pathArray.length, key, gotChanged, alreadyPastDivergencePoint});\n    if (i !== action.pathArray.length - 1) {\n      if (alreadyPastDivergencePoint || key !== prevActionPathKey) {\n        // se l'oggetto è stato già duplicato in una azione composita, non lo duplico 2 volte.\n        alreadyPastDivergencePoint = true;\n        current[key] = Array.isArray(current[key]) ? [...current[key]] : {\n          ...current[key]\n        };\n        current[key].clonedCounter = 1 + (current[key].clonedCounter || 0);\n      }\n      current = current[key];\n      continue;\n    }\n\n    // perform final assignment\n    if (i >= action.pathArray.length - 1) {\n      let isArrayAppend = false;\n      let isArrayRemove = false;\n      // console.log('isarrayappend?', {endswith: U.endsWith(key, ['+=', '[]', '-1']), key, action, i});\n      // console.log('isarraydelete?', {endswith: U.endsWith(key, ['-='])});\n      if (U.endsWith(key, ['+=', '[]'])) {\n        key = key.substr(0, key.length - 2).trim();\n        isArrayAppend = true;\n      }\n      if (U.endsWith(key, ['-='])) {\n        key = key.substr(0, key.length - 2).trim();\n        isArrayRemove = true;\n      }\n      let oldValue;\n      let unpointedElement;\n      // perform final assignment\n      if (isArrayAppend) {\n        gotChanged = true;\n        if (!Array.isArray(current[key])) {\n          current[key] = [];\n        }\n        oldValue = [...current[key]];\n        current[key] = [...current[key]];\n        current[key].push(newVal);\n        unpointedElement = undefined;\n        if (action.isPointer) {\n          newRoot = PointedBy.add(newVal, action, newRoot, \"+=\");\n        }\n      } else if (isArrayRemove) {\n        if (!Array.isArray(current[key])) {\n          current[key] = [];\n        }\n        oldValue = [...current[key]];\n        let index = U.isNumber(newVal) ? +newVal : -1;\n        if (index === -1) index = current[key].length - 1;\n        gotChanged = index >= 0 && index < current[key].length;\n        if (gotChanged) {\n          current[key] = [...current[key]];\n          let removedval = current[key].splice(index, 1); // in-place edit\n          if (action.isPointer) {\n            newRoot = PointedBy.remove(removedval, action, newRoot, '-=');\n          }\n\n          /// a.pointsto = [x, y, z]; a.pointsto = [x, z]       --->    remove a from y.pointedby\n          /*\r\n          const elementsThatChangedIndex: DPointerTargetable[] = current[key].slice(index);\r\n          todo: problema: se ho [dobj1, dobj2]... e li swappo, cambia un indice nel percorso \"pointedby\" e non me ne accorgo mai e un oggetto risulta \"pointedby\" da oggetti che non lo puntano o non esistono più a quell'indice\r\n          for (let j = 0; j < elementsThatChangedIndex.length; j++) {\r\n              let newindex = index + j - 1;\r\n              let oldFullpathTrimmed = action.pathArray.join('.');\r\n              se realizzi \"pointedby\" qui è to do: remove old paths and re-add them with updated index\r\n          }*/\n          //unpointedElement = newRoot.idlookup[oldValue];\n        }\n      } else if (current[key] !== newVal) {\n        // todo: caso in cui setto manualmente classes.1 = pointer; // the latest element is array and not DPointerTargetable, so might need to buffer upper level in the tree? or instead of \"current\" keep an array of sub-objects encountered navigating the path in state.\n        oldValue = current[key];\n        gotChanged = true;\n        unpointedElement = newRoot.idlookup[oldValue];\n        // NB: se elimino un oggetto che contiene array di puntatori, o resetto l'array di puntatori kinda like store.arr= [ptr1, ptr2, ...]; store.arr = [];\n        // i puntati dall'array hanno i loro pointedBY non aggiornati, non voglio fare un deep check di tutto l'oggetto a cercare puntatori per efficienza.\n        if (newVal === undefined) delete current[key];else current[key] = newVal;\n        if (action.isPointer) {\n          if (Array.isArray(action.value)) {\n            let oldpointerdestinations = oldValue;\n            let difference = U.arrayDifference(oldpointerdestinations, current[key]); // : {added: Pointer[], removed: Pointer[], starting: Pointer[], final: Pointer[]}\n            for (let rem of difference.removed) {\n              newRoot = PointedBy.remove(rem, action, newRoot);\n            }\n            for (let add of difference.added) {\n              newRoot = PointedBy.add(add, action, newRoot);\n            }\n            // a.pointsto = [a, b, c];  a.pointsto = [a, b, x];    ------>     c.pointedby.remove(a) & x.pointedby.add(a)\n            // idlookup.somelongid.pointsto = [...b];\n          } else {\n            // a.pointsto = b;  a.pointsto = c;    ------>     b.pointedby.remove(a)\n            newRoot = PointedBy.remove(oldValue, action, newRoot);\n            newRoot = PointedBy.add(current[key], action, newRoot);\n          }\n        }\n      } else {\n        gotChanged = false;\n        // value not changed\n      }\n      let fullpathTrimmed = action.pathArray.join('.');\n      /*if (unpointedElement) {\r\n          if (isArrayAppend || isArrayAppend) fullpathTrimmed.substr(0, fullpathTrimmed.length - 2);\r\n          U.arrayRemoveAll(unpointedElement.pointedBy, fullpathTrimmed); // todo: se faccio una insert in mezzo ad un array devo aggiustare tutti i path di pointedby...\r\n      }\r\n      let newlyPointedElement = newRoot.idlookup[newVal];\r\n      if (newlyPointedElement) {\r\n          U.ArrayAdd(newlyPointedElement.pointedBy, fullpathTrimmed);\r\n      }*/\n      // console.log('deepCopyButOnlyFollowingPath final', {current, i, imax:action.pathArray.length, key, isArrayAppend, gotChanged, alreadyPastDivergencePoint});\n      break;\n    }\n    Log.exDevv('should not reach here: reducer');\n  }\n  return gotChanged ? newRoot : oldStateDoNotModify;\n}\n\n// const pendingPointedByPaths: {from: DocString<\"Path in store\">, field: DocString<\"keyof object found in from path\">, to: Pointer}[] = [];\nfunction CompositeActionReducer(oldState, actionBatch) {\n  // per via di thunk se arrivo qui lo stato cambia sicuro in mono-client non synchro (non ri-assegno valori equivalenti)\n  // todo: ma se arrivano in ordine sbagliato da altri client? posso permetterlo?\n  let actions;\n  if (actionBatch.actions) actions = Action.parse(actionBatch.actions);else actions = [Action.parse(actionBatch)]; // else-case is if it's a single action and not an actual compositeaction\n  if (PendingPointedByPaths.all.length) actions.push(...PendingPointedByPaths.getSolveableActions(oldState)); //.all.map( p=> p.resolve() ) );\n\n  Action.possibleInconsistencies = {};\n\n  // estraggo le azioni derivate\n  let derivedActions = [];\n  for (let action of actions) {\n    switch (action.type) {\n      default:\n        break;\n      case LoadAction.type:\n        return action.value;\n      case CreateElementAction.type:\n        const elem = action.value;\n        elem.className = elem.className || elem.constructor.name;\n        let statefoldername = elem.className.substring(1).toLowerCase() + 's';\n        derivedActions.push(Action.parse(SetRootFieldAction.create(statefoldername, elem.id, '[]', true)));\n        if (!Array.isArray(elem.pointedBy)) elem.pointedBy = [];\n        elem.pointedBy.push(PointedBy.new(statefoldername));\n        /*if (false && action.isPointer) {\r\n            if (Array.isArray(action.value)) {\r\n                const ptr: Pointer[] = action.value;\r\n                // todo but replaced by side actions in execution of the main action instead of triggering derived actions\r\n            }\r\n            else {\r\n                const ptr: Pointer = action.value;\r\n                const target: DPointerTargetable | null = oldState.idlookup[ptr];\r\n                let pendingPointedBy = PendingPointedByPaths.new(action, oldState);\r\n                if (!target) PendingPointedByPaths.new(action, oldState).saveForLater(); // {from: action.path, field: action.field, to: target});\r\n                // @ts-ignore\r\n                else derivedActions.push(pendingPointedBy.resolve());\r\n                // a -> x\r\n                // a -> y     unset x.pointedby(a)\r\n            }\r\n        }*/\n        break;\n    }\n  }\n  // console.error({U, Umip:U.arrayMergeInPlace, WU: windoww.U, WUmip: windoww.U.arrayMergeInPlace});\n  actions = U.arrayMergeInPlace(actions, derivedActions);\n\n  // ordino i path con segmenti comuni\n  actions = actions.sort((a1, a2) => U.stringCompare(a1.path, a2.path));\n\n  // destrutturo solo i nodi intermedi e solo la prima volta che li incontro (richiede le azioni ordinate in base al path)\n  let newState = oldState;\n  for (let i = 0; i < actions.length; i++) {\n    const prevAction = actions[i - 1];\n    const action = actions[i];\n    const actiontype = action.type.indexOf('@@') === 0 ? 'redux' : action.type;\n    console.log('executing action:', {\n      action,\n      actiontype,\n      count: ++action.executionCount\n    });\n    switch (actiontype) {\n      /*\r\n      case '@@redux/INIT6.x.f.d.r.e':\r\n      case '@@redux/INITm.f.1.s.o.g':\r\n      case '@@redux/INIT5.t.4.v.d.o':\r\n      case '@@redux/INITy.a.d.r.l.a':\r\n      case '@@redux/INIT4.2.q.u.z.k':\r\n      case '@@redux/INITj.8.e.g.y.p':\r\n      case '@@redux/INITp.k.q.g.z.w':\r\n      case '@@redux/INITq.c.u.w.f.e': ... etc*/\n      default:\n        if (action.type.indexOf('@@redux/') === 0) break;\n        return Log.exDevv('unexpected action type:', action.type);\n      case CreateElementAction.type:\n      case SetRootFieldAction.type:\n      case DeleteElementAction.type:\n      case SetFieldAction.type:\n        newState = deepCopyButOnlyFollowingPath(newState, action, prevAction, action.value);\n        break;\n    }\n\n    // and that's all, the reducer is really simple as actions are really simple.\n  }\n\n  // effetti collaterali, aggiornamento di ridondanze\n  newState = updateRedundancies_OBSOLETE(newState, oldState, Action.possibleInconsistencies);\n  return newState;\n}\n_c = CompositeActionReducer;\nfunction updateRedundancies_OBSOLETE(state, oldState, possibleInconsistencies) {\n  for (let subType in possibleInconsistencies) switch (subType) {\n    default:\n      break;\n    case Action.SubType.vertexSubElements: /*\r\n                                           risolto triggrerando più azioni da LGraphElement setter\r\n                                           let dvertexid: Pointer, newdvertex: DGraphElement, olddvertex: DGraphElement;\r\n                                           for (newdvertex of possibleInconsistencies[subType] as DGraphElement[]){\r\n                                           const olddvertex: DGraphElement = oldState.idlookup[newdvertex.id] as DGraphElement;\r\n                                           const notContainedAnymoreOut: Pointer<DGraphElement> = [];\r\n                                           const newlyInsertedOut: Pointer<DGraphElement>[] = [];\r\n                                           U.arraySymmetricDifference(olddvertex.subElements, newdvertex.subElements, notContainedAnymoreOut, newlyInsertedOut);\r\n                                           for (let geid of notContainedAnymoreOut) {\r\n                                           const oldge = oldState.idlookup[geid] as DGraphElement;\r\n                                           const newge = state.idlookup[geid] as DGraphElement;\r\n                                           if (oldge.containedIn === newge.containedIn) continue;\r\n                                           }\r\n                                           for (let geid of notContainedAnymoreOut) {\r\n                                           const ge = idlookup[geid] as DGraphElement;\r\n                                           if (ge.containedIn === context.data.id) set container = context.data.id\r\n                                           meglio se sti 2 cicli li fai nel reducer perchè  potrebbe esserci una azione pending che setta il parent = someotherid e qui faccio partire una azione che setta il parent a null, \"annullando\" una azione pending non ancora eseguita\r\n                                           }\r\n                                           }\r\n                                           break;*/\n  }\n  // if state is updated shallow copy state before returning it\n  return state;\n}\nlet initialState = null;\nlet storeLoaded = false;\nexport function reducer /*<S extends StateNoFunc, A extends Action>*/() {\n  let oldState = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : initialState;\n  let action = arguments.length > 1 ? arguments[1] : undefined;\n  let times;\n  let state;\n  switch (action.type) {\n    case UndoAction.type:\n      times = action.value;\n      state = oldState;\n      Log.exDev(times <= 0, \"undo must be positive\", action);\n      while (times--) {\n        state = undo(state, statehistory[DUser.current].undoable.pop());\n      }\n      return state;\n    case RedoAction.type:\n      times = action.value;\n      state = oldState;\n      Log.exDev(times <= 0, \"redo must be positive\", action);\n      while (times--) {\n        state = undo(state, statehistory[DUser.current].redoable.pop(), false);\n      }\n      return state;\n    // case CombineHistoryAction.type: return combineHistory(oldState); break;\n    // todo: se al posto di \"annullare l'undo\" memorizzo l'azione e la rieseguo, posso ripetere l'ultimo passo N volte e questa azione diventa utile per combinare passi e ripetere blocchi di azioni assieme\n    default:\n      let ret = doreducer(oldState, action);\n      if (ret === oldState) return ret;\n      statehistory[DUser.current].redoable = [];\n      let delta = U.objectDelta(ret, oldState);\n      if (!filterundoableactions(delta)) return ret;\n      // console.log(\"setting undoable action:\", {ret, oldState0:{...oldState}, oldState, delta});\n      if (oldState !== null) statehistory[DUser.current].undoable.push(delta);\n      return ret;\n  }\n}\nfunction filterundoableactions(delta) {\n  if (!statehistory.globalcanundostate) return false;\n  if (Object.keys(delta).length === 1 && \"dragging\" in delta) return false;\n  if (Object.keys(delta).length === 1 && \"_lastSelected\" in delta) return false;\n  if (Object.keys(delta).length === 1 && \"contextMenu\" in delta) return false;\n  return true;\n}\nfunction undo(state, delta) {\n  let isundo = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n  if (!delta) return state;\n  let undonestate = {\n    ...state\n  };\n  //   controlla se vengono shallow-copied solo e tutti gli oggetti nested lungo la catena del percorso delle modifiche\n  //   es: root.a.b.c=3 + root.a.b.d=3 = 4+1 modifiche, 5 shallow copies including the root\n  undorecursive(delta, undonestate);\n  if (isundo) statehistory[DUser.current].redoable.push(U.objectDelta(undonestate, state)); // reverses from undo to redo and viceversa swapping arguments, so the target result after appliying the delta changes\n  else statehistory[DUser.current].undoable.push(U.objectDelta(undonestate, state)); // redo is \"undoing an undo\", reversing his changes just like an undo reverses an ordinary action changes.\n  return undonestate;\n}\nfunction undorecursive(deltalevel, statelevel) {\n  // statelevel = {...statelevel}; not working if i do it here, just a new var. first time copy id done in caller func undo(). recursive copies are done before recursive step\n  for (let key in deltalevel) {\n    let delta = deltalevel[key];\n    console.log(\"undoing\", {\n      delta,\n      key,\n      deltalevel,\n      statelevel\n    });\n    if (key.indexOf(\"_-\") === 0) {\n      delete statelevel[key.substring(2)];\n      continue;\n    }\n    if (typeof delta === \"object\") {\n      // if (U.isObject(delta, false, false, true)) {\n      statelevel[key] = {\n        ...statelevel[key]\n      };\n      undorecursive(deltalevel[key], statelevel[key]);\n    } else {\n      statelevel[key] = delta;\n    }\n  }\n}\nfunction doreducer /*<S extends StateNoFunc, A extends Action>*/() {\n  let oldState = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : initialState;\n  let action = arguments.length > 1 ? arguments[1] : undefined;\n  if (!oldState) {\n    oldState = initialState = new IStore();\n  }\n  let ca;\n  // console.log('external REDUCER', {action, CEtype:CreateElementAction.type});\n  if (!storeLoaded) {\n    // new SetRootFieldAction('forceinit', true);\n    storeLoaded = true;\n  }\n  if (!oldState.forceinit) {\n    // afterStoreLoad();\n    // new SetRootFieldAction('forceinit', true);\n  } //  setTimeout(afterStoreLoad, 1);\n  switch (action.type) {\n    case CompositeAction.type:\n      ca = action;\n      break;\n    case LoadAction.type:\n    default:\n      if (action.type.indexOf('@@redux/') === 0) {\n        //storeLoaded = true;\n        return oldState;\n      }\n      ca = new CompositeAction([action], false);\n      break;\n  }\n  let ret = CompositeActionReducer(oldState, ca);\n  /*if (state.current !== ret) {\r\n      state.current = ret;\r\n      state.past.push(ret);\r\n  }*/\n  return ret;\n}\nfunction buildLSingletons(alld, alll) {\n  for (let dname in alld) {\n    switch (dname) {\n      case \"DeleteElementAction\":\n        continue;\n      case \"DV\":\n        continue;\n      default:\n        break;\n    }\n    let tagless = dname.substring(1);\n    let d = alld[dname];\n    let l = alll['L' + tagless];\n    d.logic = l;\n    if (!l) console.error('lllllllll', l, d);\n    // @ts-ignore\n    d.singleton = new l('dwc');\n    d.structure = d;\n    l.logic = d.logic;\n    l.singleton = d.singleton;\n    l.structure = d.structure;\n    if (!d.subclasses) d.subclasses = [];\n    // @ts-ignore\n    for (let sc of d.subclasses) {\n      if (!sc[\"_extends\"]) sc[\"_extends\"] = [];\n      sc[\"_extends\"].push(d);\n    }\n  }\n}\nexport function jodelInit() {\n  RuntimeAccessibleClass.fixStatics();\n  let dClasses = RuntimeAccessibleClass.getAllNames().filter(rc => rc[0] === 'D');\n  let lClasses = RuntimeAccessibleClass.getAllNames().filter(rc => rc[0] === 'L');\n  let dClassesmap = dClasses.reduce((acc, curr) => (acc[curr] = RuntimeAccessibleClass.get(curr), acc), {});\n  let lClassesmap = lClasses.reduce((acc, curr) => (acc[curr] = RuntimeAccessibleClass.get(curr), acc), {});\n  buildLSingletons(dClassesmap, lClassesmap);\n  windoww.defaultContext = {\n    $: windoww.$,\n    getPath,\n    React: React,\n    Selectors,\n    ...RuntimeAccessibleClass.getAllClassesDictionary(),\n    ...windoww.Components\n  };\n  console.log('EXecute on read RuntimeClasses:', {\n    dClasses,\n    allClasses: {\n      ...RuntimeAccessibleClass.classes\n    }\n  });\n  /*for (let dclassname of dClasses) {\r\n      const dclass = RuntimeAccessibleClass.get(dclassname) as typeof DPointerTargetable;\r\n      const lclass = RuntimeAccessibleClass.get('L' + dclassname.substr(1)) as typeof LPointerTargetable;\r\n      dclass.logic = lclass;\r\n      console.log('EXecute on read set singletons:', {dclass, lclass});\r\n      if (!lclass) continue;\r\n      lclass.singleton = new lclass();\r\n      lclass.structure = dclass;\r\n  }*/\n\n  IStore.fakeinit();\n  //    setTimeout( () => createOrOpenModelTab('m3'), 1);\n  // GraphDragHandler.init();\n}\n\n// ideally launched before component render, verify it. maybe move the callback to <App> component mounting\nfunction afterStoreLoad() {\n  jodelInit();\n}\nvar _c;\n$RefreshReg$(_c, \"CompositeActionReducer\");","map":{"version":3,"names":["Action","CompositeAction","CreateElementAction","DeleteElementAction","IStore","Log","MyError","RuntimeAccessibleClass","SetFieldAction","SetRootFieldAction","getPath","Selectors","PointedBy","PendingPointedByPaths","statehistory","DUser","React","LoadAction","RedoAction","UndoAction","windoww","window","U","deepCopyButOnlyFollowingPath","oldStateDoNotModify","action","prevAction","newVal","_action$path","newRoot","current","path","length","gotChanged","alreadyPastDivergencePoint","i","pathArray","key","trim","prevActionPathKey","Array","isArray","clonedCounter","isArrayAppend","isArrayRemove","endsWith","substr","oldValue","unpointedElement","push","undefined","isPointer","add","index","isNumber","removedval","splice","remove","idlookup","value","oldpointerdestinations","difference","arrayDifference","rem","removed","added","fullpathTrimmed","join","exDevv","CompositeActionReducer","oldState","actionBatch","actions","parse","all","getSolveableActions","possibleInconsistencies","derivedActions","type","elem","className","constructor","name","statefoldername","substring","toLowerCase","create","id","pointedBy","new","arrayMergeInPlace","sort","a1","a2","stringCompare","newState","actiontype","indexOf","console","log","count","executionCount","updateRedundancies_OBSOLETE","_c","state","subType","SubType","vertexSubElements","initialState","storeLoaded","reducer","arguments","times","exDev","undo","undoable","pop","redoable","ret","doreducer","delta","objectDelta","filterundoableactions","globalcanundostate","Object","keys","isundo","undonestate","undorecursive","deltalevel","statelevel","ca","forceinit","buildLSingletons","alld","alll","dname","tagless","d","l","logic","error","singleton","structure","subclasses","sc","jodelInit","fixStatics","dClasses","getAllNames","filter","rc","lClasses","dClassesmap","reduce","acc","curr","get","lClassesmap","defaultContext","$","getAllClassesDictionary","Components","allClasses","classes","fakeinit","afterStoreLoad","$RefreshReg$"],"sources":["C:/0Programmi/Dev/projects/frontend/jjodel/src/redux/reducer/reducer.ts"],"sourcesContent":["import type {U as UType} from '../../joiner';\r\nimport {\r\n    Action,\r\n    CompositeAction,\r\n    CreateElementAction,\r\n    DeleteElementAction,\r\n    Dictionary,\r\n    DocString,\r\n    DPointerTargetable,\r\n    IStore,\r\n    Log,\r\n    MyError,\r\n    ParsedAction,\r\n    Pointer,\r\n    RuntimeAccessibleClass,\r\n    SetFieldAction,\r\n    SetRootFieldAction,\r\n    LPointerTargetable,\r\n    store,\r\n    getPath,\r\n    Selectors,\r\n    PointedBy,\r\n    PendingPointedByPaths,\r\n    statehistory, DUser, GObject\r\n} from \"../../joiner\";\r\nimport React from \"react\";\r\nimport {CombineHistoryAction, LoadAction, RedoAction, UndoAction} from \"../action/action\";\r\n\r\nlet windoww = window as any;\r\nlet U: typeof UType = windoww.U;\r\n\r\nfunction deepCopyButOnlyFollowingPath(oldStateDoNotModify: IStore, action: ParsedAction, prevAction: ParsedAction, newVal: any): IStore {\r\n    let newRoot: IStore = {...oldStateDoNotModify} as IStore;\r\n    let current: any = newRoot;\r\n    if (!action.path?.length) throw new MyError(\"path length must be at least 1\", {action});\r\n    let gotChanged: boolean = false; // dovrebbe cambiare sempre, se non cambia non lancio neanche l'azione e non faccio la shallow copy, ma non si sa mai, così posso evitare un render se succede l' \"insuccedibile\"\r\n    let alreadyPastDivergencePoint = false; // true dal momento in cui il path dell'azione attuale e della azione precedente divergono, false fino al sotto-segmento in cui combaciano\r\n    // console.log('deepCopyButOnlyFollowingPath', arguments);\r\n    for (let i = 0; i < action.pathArray.length; i++) {\r\n        let key = action.pathArray[i].trim();\r\n        let prevActionPathKey = prevAction?.pathArray[i];\r\n        // middle execution: not on final loop\r\n        // console.log('deepCopyButOnlyFollowingPath', {current, i, imax:action.pathArray.length, key, gotChanged, alreadyPastDivergencePoint});\r\n        if (i !== action.pathArray.length - 1) {\r\n            if (alreadyPastDivergencePoint || key !== prevActionPathKey) {\r\n                // se l'oggetto è stato già duplicato in una azione composita, non lo duplico 2 volte.\r\n                alreadyPastDivergencePoint = true;\r\n                current[key] = Array.isArray(current[key]) ? [...current[key]] : {...current[key]};\r\n                current[key].clonedCounter = 1 + (current[key].clonedCounter || 0);\r\n            }\r\n            current = current[key];\r\n            continue; }\r\n\r\n        // perform final assignment\r\n        if (i >= action.pathArray.length - 1) {\r\n            let isArrayAppend = false;\r\n            let isArrayRemove = false;\r\n            // console.log('isarrayappend?', {endswith: U.endsWith(key, ['+=', '[]', '-1']), key, action, i});\r\n            // console.log('isarraydelete?', {endswith: U.endsWith(key, ['-='])});\r\n            if (U.endsWith(key, ['+=', '[]'])) {\r\n                key = key.substr(0, key.length - 2).trim();\r\n                isArrayAppend = true; }\r\n            if (U.endsWith(key, ['-='])) {\r\n                key = key.substr(0, key.length - 2).trim();\r\n                isArrayRemove = true; }\r\n\r\n            let oldValue: any;\r\n            let unpointedElement: DPointerTargetable | undefined;\r\n            // perform final assignment\r\n            if (isArrayAppend) {\r\n                gotChanged = true;\r\n                if (!Array.isArray(current[key])) { current[key] = []; }\r\n                oldValue = [...current[key]];\r\n                current[key] = [...current[key]];\r\n                current[key].push(newVal);\r\n                unpointedElement = undefined;\r\n                if (action.isPointer) { newRoot = PointedBy.add(newVal as Pointer, action, newRoot, \"+=\"); }\r\n            } else\r\n            if (isArrayRemove){\r\n                if (!Array.isArray(current[key])) { current[key] = []; }\r\n                oldValue = [...current[key]];\r\n                let index = U.isNumber(newVal) ? +newVal : -1;\r\n                if (index === -1) index = current[key].length - 1;\r\n                gotChanged = index >=0 && index < current[key].length;\r\n                if (gotChanged){\r\n                    current[key] = [...current[key]];\r\n                    let removedval = current[key].splice(index, 1); // in-place edit\r\n                    if (action.isPointer) { newRoot = PointedBy.remove(removedval as Pointer, action, newRoot, '-='); }\r\n\r\n                    /// a.pointsto = [x, y, z]; a.pointsto = [x, z]       --->    remove a from y.pointedby\r\n                    /*\r\n                    const elementsThatChangedIndex: DPointerTargetable[] = current[key].slice(index);\r\n                    todo: problema: se ho [dobj1, dobj2]... e li swappo, cambia un indice nel percorso \"pointedby\" e non me ne accorgo mai e un oggetto risulta \"pointedby\" da oggetti che non lo puntano o non esistono più a quell'indice\r\n                    for (let j = 0; j < elementsThatChangedIndex.length; j++) {\r\n                        let newindex = index + j - 1;\r\n                        let oldFullpathTrimmed = action.pathArray.join('.');\r\n                        se realizzi \"pointedby\" qui è to do: remove old paths and re-add them with updated index\r\n                    }*/\r\n                    //unpointedElement = newRoot.idlookup[oldValue];\r\n                }\r\n            }\r\n            else if (current[key] !== newVal) {\r\n                // todo: caso in cui setto manualmente classes.1 = pointer; // the latest element is array and not DPointerTargetable, so might need to buffer upper level in the tree? or instead of \"current\" keep an array of sub-objects encountered navigating the path in state.\r\n                oldValue = current[key];\r\n                gotChanged = true;\r\n                unpointedElement = newRoot.idlookup[oldValue];\r\n                // NB: se elimino un oggetto che contiene array di puntatori, o resetto l'array di puntatori kinda like store.arr= [ptr1, ptr2, ...]; store.arr = [];\r\n                // i puntati dall'array hanno i loro pointedBY non aggiornati, non voglio fare un deep check di tutto l'oggetto a cercare puntatori per efficienza.\r\n                if (newVal === undefined) delete current[key];\r\n                else current[key] = newVal;\r\n\r\n                if (action.isPointer) {\r\n                    if (Array.isArray(action.value)) {\r\n                        let oldpointerdestinations: Pointer[] = oldValue;\r\n                        let difference = U.arrayDifference(oldpointerdestinations, current[key]); // : {added: Pointer[], removed: Pointer[], starting: Pointer[], final: Pointer[]}\r\n                        for (let rem of difference.removed) { newRoot = PointedBy.remove(rem as Pointer, action, newRoot); }\r\n                        for (let add of difference.added) { newRoot = PointedBy.add(add as Pointer, action, newRoot); }\r\n                        // a.pointsto = [a, b, c];  a.pointsto = [a, b, x];    ------>     c.pointedby.remove(a) & x.pointedby.add(a)\r\n                        // idlookup.somelongid.pointsto = [...b];\r\n                    }\r\n                    else {\r\n                        // a.pointsto = b;  a.pointsto = c;    ------>     b.pointedby.remove(a)\r\n                        newRoot = PointedBy.remove(oldValue as Pointer, action, newRoot);\r\n                        newRoot = PointedBy.add(current[key] as Pointer, action, newRoot);\r\n                    }\r\n                }\r\n            } else {\r\n                gotChanged = false;\r\n                // value not changed\r\n            }\r\n\r\n            let fullpathTrimmed = action.pathArray.join('.');\r\n            /*if (unpointedElement) {\r\n                if (isArrayAppend || isArrayAppend) fullpathTrimmed.substr(0, fullpathTrimmed.length - 2);\r\n                U.arrayRemoveAll(unpointedElement.pointedBy, fullpathTrimmed); // todo: se faccio una insert in mezzo ad un array devo aggiustare tutti i path di pointedby...\r\n            }\r\n            let newlyPointedElement = newRoot.idlookup[newVal];\r\n            if (newlyPointedElement) {\r\n                U.ArrayAdd(newlyPointedElement.pointedBy, fullpathTrimmed);\r\n            }*/\r\n            // console.log('deepCopyButOnlyFollowingPath final', {current, i, imax:action.pathArray.length, key, isArrayAppend, gotChanged, alreadyPastDivergencePoint});\r\n            break;\r\n        }\r\n        Log.exDevv('should not reach here: reducer');\r\n    }\r\n    return gotChanged ? newRoot : oldStateDoNotModify;\r\n}\r\n\r\n\r\n// const pendingPointedByPaths: {from: DocString<\"Path in store\">, field: DocString<\"keyof object found in from path\">, to: Pointer}[] = [];\r\nfunction CompositeActionReducer(oldState: IStore, actionBatch: CompositeAction): IStore {\r\n    // per via di thunk se arrivo qui lo stato cambia sicuro in mono-client non synchro (non ri-assegno valori equivalenti)\r\n    // todo: ma se arrivano in ordine sbagliato da altri client? posso permetterlo?\r\n    let actions: ParsedAction[];\r\n    if (actionBatch.actions) actions = Action.parse(actionBatch.actions);\r\n    else actions = [Action.parse(actionBatch)]; // else-case is if it's a single action and not an actual compositeaction\r\n    if (PendingPointedByPaths.all.length) actions.push(...PendingPointedByPaths.getSolveableActions(oldState)); //.all.map( p=> p.resolve() ) );\r\n\r\n    Action.possibleInconsistencies = {};\r\n\r\n    // estraggo le azioni derivate\r\n    let derivedActions: ParsedAction[] = [];\r\n    for (let action of actions) {\r\n        switch (action.type){\r\n            default: break;\r\n            case LoadAction.type: return action.value;\r\n            case CreateElementAction.type:\r\n                const elem: DPointerTargetable = action.value;\r\n                elem.className = elem.className || elem.constructor.name;\r\n                let statefoldername = elem.className.substring(1).toLowerCase() + 's';\r\n                derivedActions.push(\r\n                    Action.parse(SetRootFieldAction.create(statefoldername, elem.id,'[]', true)));\r\n                if (!Array.isArray(elem.pointedBy)) elem.pointedBy = [];\r\n                elem.pointedBy.push(PointedBy.new(statefoldername));\r\n                /*if (false && action.isPointer) {\r\n                    if (Array.isArray(action.value)) {\r\n                        const ptr: Pointer[] = action.value;\r\n                        // todo but replaced by side actions in execution of the main action instead of triggering derived actions\r\n                    }\r\n                    else {\r\n                        const ptr: Pointer = action.value;\r\n                        const target: DPointerTargetable | null = oldState.idlookup[ptr];\r\n                        let pendingPointedBy = PendingPointedByPaths.new(action, oldState);\r\n                        if (!target) PendingPointedByPaths.new(action, oldState).saveForLater(); // {from: action.path, field: action.field, to: target});\r\n                        // @ts-ignore\r\n                        else derivedActions.push(pendingPointedBy.resolve());\r\n                        // a -> x\r\n                        // a -> y     unset x.pointedby(a)\r\n                    }\r\n                }*/\r\n                break;\r\n        }\r\n    }\r\n    // console.error({U, Umip:U.arrayMergeInPlace, WU: windoww.U, WUmip: windoww.U.arrayMergeInPlace});\r\n    actions = U.arrayMergeInPlace<ParsedAction>(actions, derivedActions);\r\n\r\n    // ordino i path con segmenti comuni\r\n    actions = actions.sort( (a1, a2) => U.stringCompare(a1.path, a2.path));\r\n\r\n    // destrutturo solo i nodi intermedi e solo la prima volta che li incontro (richiede le azioni ordinate in base al path)\r\n    let newState = oldState;\r\n    for (let i = 0; i < actions.length; i++) {\r\n        const prevAction: ParsedAction = actions[i-1];\r\n        const action: ParsedAction = actions[i];\r\n        const actiontype = action.type.indexOf('@@') === 0 ? 'redux' : action.type;\r\n        console.log('executing action:', {action, actiontype, count: ++action.executionCount});\r\n\r\n        switch (actiontype) {\r\n            /*\r\n            case '@@redux/INIT6.x.f.d.r.e':\r\n            case '@@redux/INITm.f.1.s.o.g':\r\n            case '@@redux/INIT5.t.4.v.d.o':\r\n            case '@@redux/INITy.a.d.r.l.a':\r\n            case '@@redux/INIT4.2.q.u.z.k':\r\n            case '@@redux/INITj.8.e.g.y.p':\r\n            case '@@redux/INITp.k.q.g.z.w':\r\n            case '@@redux/INITq.c.u.w.f.e': ... etc*/\r\n            default:\r\n                if (action.type.indexOf('@@redux/') === 0) break;\r\n                return Log.exDevv('unexpected action type:', action.type);\r\n            case CreateElementAction.type:\r\n            case SetRootFieldAction.type:\r\n            case DeleteElementAction.type:\r\n            case SetFieldAction.type:\r\n                newState = deepCopyButOnlyFollowingPath(newState, action, prevAction, action.value);\r\n                break;\r\n        }\r\n\r\n        // and that's all, the reducer is really simple as actions are really simple.\r\n    }\r\n\r\n    // effetti collaterali, aggiornamento di ridondanze\r\n    newState = updateRedundancies_OBSOLETE(newState, oldState, Action.possibleInconsistencies);\r\n    return newState;\r\n}\r\n\r\nfunction updateRedundancies_OBSOLETE(state: IStore, oldState:IStore, possibleInconsistencies: Dictionary<DocString<'subtype'>, (Pointer | DPointerTargetable)[]>): IStore {\r\n    for (let subType in possibleInconsistencies)\r\n    switch (subType) {\r\n        default: break;\r\n        case Action.SubType.vertexSubElements:/*\r\n            risolto triggrerando più azioni da LGraphElement setter\r\n            let dvertexid: Pointer, newdvertex: DGraphElement, olddvertex: DGraphElement;\r\n            for (newdvertex of possibleInconsistencies[subType] as DGraphElement[]){\r\n                const olddvertex: DGraphElement = oldState.idlookup[newdvertex.id] as DGraphElement;\r\n                const notContainedAnymoreOut: Pointer<DGraphElement> = [];\r\n                const newlyInsertedOut: Pointer<DGraphElement>[] = [];\r\n                U.arraySymmetricDifference(olddvertex.subElements, newdvertex.subElements, notContainedAnymoreOut, newlyInsertedOut);\r\n                for (let geid of notContainedAnymoreOut) {\r\n                    const oldge = oldState.idlookup[geid] as DGraphElement;\r\n                    const newge = state.idlookup[geid] as DGraphElement;\r\n                    if (oldge.containedIn === newge.containedIn) continue;\r\n                }\r\n                for (let geid of notContainedAnymoreOut) {\r\n                    const ge = idlookup[geid] as DGraphElement;\r\n                    if (ge.containedIn === context.data.id) set container = context.data.id\r\n                    meglio se sti 2 cicli li fai nel reducer perchè  potrebbe esserci una azione pending che setta il parent = someotherid e qui faccio partire una azione che setta il parent a null, \"annullando\" una azione pending non ancora eseguita\r\n                }\r\n            }\r\n            break;*/\r\n    }\r\n    // if state is updated shallow copy state before returning it\r\n    return state;\r\n}\r\n\r\nlet initialState: IStore = null as any;\r\nlet storeLoaded: boolean = false;\r\n\r\nexport function reducer/*<S extends StateNoFunc, A extends Action>*/(oldState: IStore = initialState, action: Action): IStore{\r\n    let times: number;\r\n    let state: IStore;\r\n    switch(action.type) {\r\n        case UndoAction.type:\r\n            times = action.value;\r\n            state = oldState;\r\n            Log.exDev(times<=0, \"undo must be positive\", action);\r\n            while (times--) {\r\n                state = undo(state, statehistory[DUser.current].undoable.pop());\r\n            }\r\n            return state;\r\n\r\n        case RedoAction.type:\r\n            times = action.value;\r\n            state = oldState;\r\n            Log.exDev(times<=0, \"redo must be positive\", action);\r\n            while (times--) {\r\n                state = undo(state, statehistory[DUser.current].redoable.pop(), false);\r\n            }\r\n            return state;\r\n        // case CombineHistoryAction.type: return combineHistory(oldState); break;\r\n        // todo: se al posto di \"annullare l'undo\" memorizzo l'azione e la rieseguo, posso ripetere l'ultimo passo N volte e questa azione diventa utile per combinare passi e ripetere blocchi di azioni assieme\r\n        default:\r\n            let ret = doreducer(oldState, action);\r\n            if (ret === oldState) return ret;\r\n            statehistory[DUser.current].redoable = [];\r\n            let delta =  U.objectDelta(ret, oldState);\r\n            if (!filterundoableactions(delta)) return ret;\r\n            // console.log(\"setting undoable action:\", {ret, oldState0:{...oldState}, oldState, delta});\r\n            if (oldState !== null) statehistory[DUser.current].undoable.push(delta);\r\n            return ret;\r\n    }\r\n}\r\n\r\nfunction filterundoableactions(delta: Partial<IStore>): boolean {\r\n    if (!statehistory.globalcanundostate) return false;\r\n    if (Object.keys(delta).length === 1 && \"dragging\" in delta) return false;\r\n    if (Object.keys(delta).length === 1 && \"_lastSelected\" in delta) return false;\r\n    if (Object.keys(delta).length === 1 && \"contextMenu\" in delta) return false;\r\n    return true;\r\n}\r\nfunction undo(state: IStore, delta: GObject | undefined, isundo = true): IStore {\r\n    if (!delta) return state;\r\n    let undonestate = {...state};\r\n    //   controlla se vengono shallow-copied solo e tutti gli oggetti nested lungo la catena del percorso delle modifiche\r\n    //   es: root.a.b.c=3 + root.a.b.d=3 = 4+1 modifiche, 5 shallow copies including the root\r\n    undorecursive(delta, undonestate);\r\n    if (isundo) statehistory[DUser.current].redoable.push( U.objectDelta(undonestate, state) ); // reverses from undo to redo and viceversa swapping arguments, so the target result after appliying the delta changes\r\n    else statehistory[DUser.current].undoable.push( U.objectDelta(undonestate, state) ); // redo is \"undoing an undo\", reversing his changes just like an undo reverses an ordinary action changes.\r\n    return undonestate;\r\n}\r\n\r\nfunction undorecursive(deltalevel: GObject, statelevel: GObject): void {\r\n    // statelevel = {...statelevel}; not working if i do it here, just a new var. first time copy id done in caller func undo(). recursive copies are done before recursive step\r\n    for (let key in deltalevel) {\r\n        let delta = deltalevel[key];\r\n        console.log(\"undoing\", {delta, key, deltalevel, statelevel})\r\n        if (key.indexOf(\"_-\") === 0) { delete statelevel[key.substring(2)]; continue; }\r\n        if (typeof delta === \"object\") {\r\n        // if (U.isObject(delta, false, false, true)) {\r\n            statelevel[key] = {...statelevel[key]};\r\n            undorecursive(deltalevel[key], statelevel[key]); }\r\n        else { statelevel[key] = delta; }\r\n    }\r\n}\r\n\r\nfunction doreducer/*<S extends StateNoFunc, A extends Action>*/(oldState: IStore = initialState, action: Action): IStore{\r\n    if (!oldState) { oldState = initialState = new IStore(); }\r\n    let ca: CompositeAction;\r\n    // console.log('external REDUCER', {action, CEtype:CreateElementAction.type});\r\n    if (!storeLoaded) {\r\n        // new SetRootFieldAction('forceinit', true);\r\n        storeLoaded = true;\r\n    }\r\n    if (!(oldState as any).forceinit) {\r\n        // afterStoreLoad();\r\n        // new SetRootFieldAction('forceinit', true);\r\n    } //  setTimeout(afterStoreLoad, 1);\r\n    switch (action.type) {\r\n        case CompositeAction.type: ca = action as CompositeAction; break;\r\n        case LoadAction.type:\r\n        default:\r\n            if (action.type.indexOf('@@redux/') === 0) {\r\n                //storeLoaded = true;\r\n                return oldState;\r\n            }\r\n            ca = new CompositeAction([action], false);\r\n            break;\r\n    }\r\n    let ret = CompositeActionReducer(oldState, ca);\r\n    /*if (state.current !== ret) {\r\n        state.current = ret;\r\n        state.past.push(ret);\r\n    }*/\r\n    return ret;\r\n}\r\n\r\nfunction buildLSingletons(alld: Dictionary<string, typeof DPointerTargetable>, alll: Dictionary<string, typeof LPointerTargetable>) {\r\n    for (let dname in alld) {\r\n        switch (dname) {\r\n            case \"DeleteElementAction\": continue;\r\n            case \"DV\": continue;\r\n            default: break;\r\n        }\r\n        let tagless = dname.substring(1);\r\n        let d = alld[dname];\r\n        let l = alll['L'+tagless];\r\n        d.logic = l;\r\n        if (!l) console.error('lllllllll', l, d);\r\n        // @ts-ignore\r\n        d.singleton = new l('dwc');\r\n        d.structure = d;\r\n\r\n        l.logic = d.logic;\r\n        l.singleton = d.singleton;\r\n        l.structure = d.structure;\r\n\r\n        if (!d.subclasses) d.subclasses = [];\r\n        // @ts-ignore\r\n        for (let sc of d.subclasses) { if (!sc[\"_extends\"]) sc[\"_extends\"] = [];  sc[\"_extends\"].push(d); }\r\n    }\r\n}\r\n\r\nexport function jodelInit() {\r\n    RuntimeAccessibleClass.fixStatics();\r\n\r\n    let dClasses: string[] = RuntimeAccessibleClass.getAllNames().filter( rc => rc[0] === 'D');\r\n    let lClasses: string[] = RuntimeAccessibleClass.getAllNames().filter( rc => rc[0] === 'L');\r\n    let dClassesmap: Dictionary<string, typeof DPointerTargetable> = dClasses.reduce((acc: any,curr)=> (acc[curr] = RuntimeAccessibleClass.get(curr), acc),{});\r\n    let lClassesmap: Dictionary<string, typeof LPointerTargetable> = lClasses.reduce((acc: any,curr)=> (acc[curr] = RuntimeAccessibleClass.get(curr), acc),{});\r\n    buildLSingletons(dClassesmap, lClassesmap);\r\n\r\n\r\n    windoww.defaultContext = {$: windoww.$, getPath, React: React, Selectors, ...RuntimeAccessibleClass.getAllClassesDictionary(), ...windoww.Components};\r\n\r\n    console.log('EXecute on read RuntimeClasses:', {dClasses, allClasses: {...RuntimeAccessibleClass.classes}});\r\n    /*for (let dclassname of dClasses) {\r\n        const dclass = RuntimeAccessibleClass.get(dclassname) as typeof DPointerTargetable;\r\n        const lclass = RuntimeAccessibleClass.get('L' + dclassname.substr(1)) as typeof LPointerTargetable;\r\n        dclass.logic = lclass;\r\n        console.log('EXecute on read set singletons:', {dclass, lclass});\r\n        if (!lclass) continue;\r\n        lclass.singleton = new lclass();\r\n        lclass.structure = dclass;\r\n    }*/\r\n\r\n    IStore.fakeinit();\r\n//    setTimeout( () => createOrOpenModelTab('m3'), 1);\r\n    // GraphDragHandler.init();\r\n\r\n}\r\n\r\n// ideally launched before component render, verify it. maybe move the callback to <App> component mounting\r\nfunction afterStoreLoad() {\r\n    jodelInit();\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}