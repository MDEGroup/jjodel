{"ast":null,"code":"import _regeneratorRuntime from\"C:/d/Programming/web/jodel-mde/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";import _asyncToGenerator from\"C:/d/Programming/web/jodel-mde/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";import _createForOfIteratorHelper from\"C:/d/Programming/web/jodel-mde/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";import _toConsumableArray from\"C:/d/Programming/web/jodel-mde/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";import _objectSpread from\"C:/d/Programming/web/jodel-mde/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2\";import{DViewElement,UX,GraphElementComponent,ViewEClassMatch}from'../../joiner';import{Action,CompositeAction,CreateElementAction,DeleteElementAction,DPointerTargetable,DState,DUser,getPath,Log,MyError,PendingPointedByPaths,PointedBy,Pointers,RuntimeAccessibleClass,SetFieldAction,SetRootFieldAction,statehistory}from\"../../joiner\";import React from\"react\";import{LoadAction,RedoAction,UndoAction}from\"../action/action\";import Collaborative from\"../../components/collaborative/Collaborative\";import{SimpleTree}from\"../../common/SimpleTree\";import{transientProperties,Selectors}from\"../../joiner\";import{contextFixedKeys}from'../../graph/graphElement/sharedTypes/sharedTypes';import Storage from\"../../data/storage\";import{ProjectsApi}from\"../../api/persistance\";import DSL from\"../../DSL/DSL\";var windoww=window;var U=windoww.U;function deepCopyButOnlyFollowingPath(oldStateDoNotModify,action,prevAction,newVal){var _action$path;var newRoot=_objectSpread({},oldStateDoNotModify);var current=newRoot;if(!((_action$path=action.path)===null||_action$path===void 0?void 0:_action$path.length))throw new MyError(\"path length must be at least 1\",{action:action});var gotChanged=false;// dovrebbe cambiare sempre, se non cambia non lancio neanche l'azione e non faccio la shallow copy, ma non si sa mai, così posso evitare un render se succede l' \"insuccedibile\"\nvar alreadyPastDivergencePoint=false;// true dal momento in cui il path dell'azione attuale e della azione precedente divergono, false fino al sotto-segmento in cui combaciano\n// console.log('deepCopyButOnlyFollowingPath', arguments);\nfor(var i=0;i<action.pathArray.length;i++){var key=action.pathArray[i].trim();var prevActionPathKey=prevAction===null||prevAction===void 0?void 0:prevAction.pathArray[i];// middle execution: not on final loop\n// console.log('deepCopyButOnlyFollowingPath', {current, i, imax:action.pathArray.length, key, gotChanged, alreadyPastDivergencePoint});\nif(i!==action.pathArray.length-1){if(alreadyPastDivergencePoint||key!==prevActionPathKey){// se l'oggetto è stato già duplicato in una azione composita, non lo duplico 2 volte.\nalreadyPastDivergencePoint=true;current[key]=Array.isArray(current[key])?_toConsumableArray(current[key]):_objectSpread({},current[key]);current[key].clonedCounter=1+(current[key].clonedCounter||0);}current=current[key];continue;}// Giordano: added this on 03/12/2023 to prevent \"Cannot read properties of undefined\".\n// if(!current) continue; damiano: temp removed to check if there are invalid actions firing\n// perform final assignment\nif(i>=action.pathArray.length-1){var isArrayAppend=false;var isArrayRemove=false;var isObjectMerge=false;var isObjectDifference=false;// console.log('isarrayappend?', {endswith: U.endsWith(key, ['+=', '[]', '-1']), key, action, i});\n// console.log('isarraydelete?', {endswith: U.endsWith(key, ['-='])});\nvar oldValue=void 0;if(U.endsWith(key,['+=','[]'])){key=key.substr(0,key.length-2).trim();oldValue=current[key];switch(typeof oldValue){case'object':if(Array.isArray(oldValue))isArrayAppend=true;else isObjectMerge=true;break;default:newVal+=oldValue;break;}}if(U.endsWith(key,['-='])){key=key.substr(0,key.length-2).trim();oldValue=current[key];switch(typeof oldValue){case'object':if(Array.isArray(oldValue))isArrayRemove=true;else isObjectDifference=true;break;case\"string\":newVal=U.replaceAll(oldValue,newVal,'');break;default:newVal-=oldValue;break;}isArrayRemove=true;}// let unpointedElement: DPointerTargetable | undefined;\n// perform final assignment\nif(action.type===CreateElementAction.type&&current[key]){oldValue=current[key];gotChanged=false;Log.ee(\"rejected CreateElementAction, rollback occurring:\",{action:action,preexistingValue:current[key],isShallowEqual:current[key]===action.value});return false;// warning: use return only when you want to abort and skip subsequent CompositeAction sub-actions like now.\n}if(isObjectMerge){if(typeof newVal==='string'){var tmp={};tmp[newVal]=true;newVal=tmp;}oldValue=_objectSpread({},current[key]);current[key]=_objectSpread({},current[key]);for(var subkey in newVal){// console.warn(\"object merge\", {current, key, subkey, newVal, old:current[key][subkey], new:newVal[subkey]});\nif(current[key][subkey]===newVal[subkey])continue;current[key][subkey]=newVal[subkey];gotChanged=true;if(action.isPointer){newRoot=PointedBy.add(key,action,newRoot,\"+=\");}}}else if(isObjectDifference){if(typeof newVal==='string'){var _tmp={};_tmp[newVal]=true;newVal=_tmp;}oldValue=_objectSpread({},current[key]);current[key]=_objectSpread({},current[key]);for(var _subkey in newVal){if(!(_subkey in current[key]))continue;delete current[key][_subkey];gotChanged=true;if(action.isPointer){newRoot=PointedBy.add(key,action,newRoot,\"-=\");}}}else if(isArrayAppend){gotChanged=true;if(!Array.isArray(current[key])){current[key]=[];}oldValue=_toConsumableArray(current[key]);current[key]=_toConsumableArray(current[key]);current[key].push(newVal);// unpointedElement = undefined;\nif(action.isPointer){newRoot=PointedBy.add(newVal,action,newRoot,\"+=\");}}else if(isArrayRemove){if(!Array.isArray(current[key])){current[key]=[];}oldValue=_toConsumableArray(current[key]);var index=void 0;if(U.isNumber(newVal)){// delete by index\nindex=newVal;if(index<0)index=oldValue.length+index;// if index is -2, i remove the penultimate element\n}else if(newVal===undefined){index=oldValue.length-1;}else{index=oldValue.indexOf(newVal);}// if it's negatively or positively out of boundary, i skip it\ngotChanged=index>=0&&index<current[key].length;if(gotChanged){current[key]=_toConsumableArray(current[key]);var removedval=current[key].splice(index,1);// in-place edit\nif(action.isPointer){newRoot=PointedBy.remove(removedval,action,newRoot,'-=');}/*\r\n                    fixed problem: se ho [dobj1, dobj2]... e li swappo, cambia un indice nel percorso \"pointedby\" e non me ne accorgo mai e un oggetto risulta \"pointedby\" da oggetti che non lo puntano o non esistono più a quell'indice\r\n                    SOLVED! by not including index in pointedBy path, but making it like \"parentObject.arrayKey+=\" instead of \"parentObject.arrayKey.4\"\r\n                    and knowing it's in the array it's enough info.\r\n\r\n                    // a.pointsto = [x, y, z]; a.pointsto = [x, z]       --->    remove a from y.pointedby\r\n                    const elementsThatChangedIndex: DPointerTargetable[] = current[key].slice(index);\r\n\r\n                    for (let j = 0; j < elementsThatChangedIndex.length; j++) {\r\n                        let newindex = index + j - 1;\r\n                        let oldFullpathTrimmed = action.pathArray.join('.');\r\n                        se realizzi \"pointedby\" qui è to do: remove old paths and re-add them with updated index\r\n                    }\r\n                    unpointedElement = newRoot.idlookup[oldValue];\r\n                    */}}else if(action.type===DeleteElementAction.type&&!(key in current)||current[key]===newVal){// value not changed\ngotChanged=false;}else{// value changed\n// todo: caso in cui setto manualmente classes.1 = pointer;\n//  the latest element is array and not DPointerTargetable, so might need to buffer upper level in the tree? or instead of \"current\" keep an array of sub-objects encountered navigating the path in state.\noldValue=current[key];gotChanged=true;// unpointedElement = newRoot.idlookup[oldValue];\n// NB: se elimino un oggetto che contiene array di puntatori, o resetto l'array di puntatori kinda like store.arr= [ptr1, ptr2, ...]; store.arr = [];\n// i puntati dall'array hanno i loro pointedBY non aggiornati, non voglio fare un deep check di tutto l'oggetto a cercare puntatori per efficienza.\n// if (newVal === undefined) delete current[key];\nif(newVal===undefined||false&&action.type===DeleteElementAction.type)delete current[key];else current[key]=newVal;// update pointedBy's\n// NB: even if the current action have isPointer=true, it doesn't mean the old value is a pointer as well for sure. so need to check old values.\n// also what if old val is pointer, and new one isn't? will it be just removed without updating pointedBy's?\n// already fixed: might need to evaluate this if block always regardless of action.isPointer,\n// and do checks every time both on old and new value if they actually are ptrs.\nif(true||action.isPointer){var oldpointerdestinations=void 0;var newpointerdestinations=void 0;if(Array.isArray(newVal)){newpointerdestinations=newVal;if(Array.isArray(oldValue)){// case: path.array = array;\noldpointerdestinations=oldValue;}else{// case: path.object = array; + case: path.value = array;\noldpointerdestinations=[oldValue];}}else{// case: path.array = object; + case: path.array = value;\nnewpointerdestinations=[newVal];if(Array.isArray(oldValue)){oldpointerdestinations=oldValue;}else{// case: path.object = object; and all other cases without arrays involved\noldpointerdestinations=[oldValue];}}// after i mapped all cases to path.array = array; i solve it for that case.\nvar difference=U.arrayDifference(oldpointerdestinations,newpointerdestinations);// : {added: Pointer[], removed: Pointer[], starting: Pointer[], final: Pointer[]}\nvar _iterator=_createForOfIteratorHelper(difference.removed),_step;try{for(_iterator.s();!(_step=_iterator.n()).done;){var rem=_step.value;if(Pointers.isPointer(rem))newRoot=PointedBy.remove(rem,action,newRoot,undefined,oldStateDoNotModify);}}catch(err){_iterator.e(err);}finally{_iterator.f();}var _iterator2=_createForOfIteratorHelper(difference.added),_step2;try{for(_iterator2.s();!(_step2=_iterator2.n()).done;){var add=_step2.value;if(Pointers.isPointer(add))newRoot=PointedBy.add(add,action,newRoot,undefined,oldStateDoNotModify);}// a.pointsto = [a, b, c];  a.pointsto = [a, b, x];    ------>     c.pointedby.remove(a) & x.pointedby.add(a)\n// idlookup.somelongid.pointsto = [...b];\n}catch(err){_iterator2.e(err);}finally{_iterator2.f();}}}break;}Log.exDevv('should not reach here: reducer');}return gotChanged?newRoot:oldStateDoNotModify;}// const pendingPointedByPaths: {from: DocString<\"Path in store\">, field: DocString<\"keyof object found in from path\">, to: Pointer}[] = [];\nfunction CompositeActionReducer(oldState,actionBatch){var _actions;// per via di thunk se arrivo qui lo stato cambia sicuro in mono-client non synchro (non ri-assegno valori equivalenti)\n// todo: ma se arrivano in ordine sbagliato da altri client? posso permetterlo?\nvar actions;if(actionBatch.actions)actions=Action.parse(actionBatch.actions);else actions=[Action.parse(actionBatch)];// else-case is if it's a single action and not an actual compositeaction\nif(PendingPointedByPaths.all.length)(_actions=actions).push.apply(_actions,_toConsumableArray(PendingPointedByPaths.getSolveableActions(oldState)));//.all.map( p=> p.resolve() ) );\nAction.possibleInconsistencies={};// estraggo le azioni derivate\nvar derivedActions=[];var newState=oldState;var _iterator3=_createForOfIteratorHelper(actions),_step3;try{for(_iterator3.s();!(_step3=_iterator3.n()).done;){var _action=_step3.value;switch(_action.type){default:break;case CreateElementAction.type:var elem=_action.value;delete DPointerTargetable.pendingCreation[elem.id];/*\r\n                if (oldState.idlookup[elem.id]) {\r\n                    Log.ee(\"rejected CreateElementAction, rollback occurring:\", {action, elem:{...elem},\r\n                        preexistingValue: {...oldState.idlookup[elem.id]}, isEqual: elem === oldState.idlookup[elem.id] });\r\n                    return oldState; // warning: use return only when you want to abort and skip subsequent CompositeAction sub-actions like now.\r\n\r\n                    action.value = \"An element with that id already existed.\";\r\n                    action.path = action.field = \"CreateActionRejected\";\r\n                    action.className = SetRootFieldAction.name;\r\n                    action.type = SetRootFieldAction.type;\r\n                    action.pathArray = [action.path]; //a\r\n                    action.isPointer = false;\r\n                    // just to log it in undo-redo action list and have a feedback\r\n                    return oldState;}*/elem.className=elem.className||elem.constructor.cname||elem.constructor.name;var statefoldername=elem.className.substring(1).toLowerCase()+'s';derivedActions.push(Action.parse(SetRootFieldAction.create(statefoldername,elem.id,'[]',true)));if(!Array.isArray(elem.pointedBy))elem.pointedBy=[];elem.pointedBy.push(PointedBy.new(statefoldername));/*if (false && action.isPointer) {\r\n                    if (Array.isArray(action.value)) {\r\n                        const ptr: Pointer[] = action.value;\r\n                        // todo but replaced by side actions in execution of the main action instead of triggering derived actions\r\n                    }\r\n                    else {\r\n                        const ptr: Pointer = action.value;\r\n                        const target: DPointerTargetable | null = oldState.idlookup[ptr];\r\n                        let pendingPointedBy = PendingPointedByPaths.new(action, oldState);\r\n                        if (!target) PendingPointedByPaths.new(action, oldState).saveForLater(); // {from: action.path, field: action.field, to: target});\r\n                        // @ts-ignore\r\n                        else derivedActions.push(pendingPointedBy.resolve());\r\n                        // a -> x\r\n                        // a -> y     unset x.pointedby(a)\r\n                    }\r\n                }*/break;}}// console.error({U, Umip:U.arrayMergeInPlace, WU: windoww.U, WUmip: windoww.U.arrayMergeInPlace});\n}catch(err){_iterator3.e(err);}finally{_iterator3.f();}actions=U.arrayMergeInPlace(actions,derivedActions);// ordino i path con segmenti comuni\nactions=actions.sort(function(a1,a2){return U.stringCompare(a1.path,a2.path);});// destrutturo solo i nodi intermedi e solo la prima volta che li incontro (richiede le azioni ordinate in base al path)\nfor(var i=0;i<actions.length;i++){var prevAction=actions[i-1];var action=actions[i];var actiontype=action.type.indexOf('@@')===0?'redux':action.type;console.log('executing action:',{a:action,t:actiontype,field:action.field,v:action.value});//, count: ++action.executionCount});\nswitch(actiontype){/*\r\n            case '@@redux/INIT6.x.f.d.r.e':\r\n            case '@@redux/INITm.f.1.s.o.g':\r\n            case '@@redux/INIT5.t.4.v.d.o':\r\n            case '@@redux/INITy.a.d.r.l.a':\r\n            case '@@redux/INIT4.2.q.u.z.k':\r\n            case '@@redux/INITj.8.e.g.y.p':\r\n            case '@@redux/INITp.k.q.g.z.w':\r\n            case '@@redux/INITq.c.u.w.f.e': ... etc*/default:if(action.type.indexOf('@@redux/')===0)break;return Log.exDevv('unexpected action type:',action.type);case LoadAction.type:newState=action.value;break;case CreateElementAction.type:case SetRootFieldAction.type:case DeleteElementAction.type:case SetFieldAction.type:var tmp=deepCopyButOnlyFollowingPath(newState,action,prevAction,action.value);if(!tmp)return oldState;// rollback due to invalid action in transaction\nnewState=tmp;break;}// and that's all, the reducer is really simple as actions are really simple.\n}// effetti collaterali, aggiornamento di ridondanze\nnewState=updateRedundancies_OBSOLETE(newState,oldState,Action.possibleInconsistencies);return newState;}function updateRedundancies_OBSOLETE(state,oldState,possibleInconsistencies){for(var subType in possibleInconsistencies){switch(subType){default:break;case Action.SubType.vertexSubElements:/*\r\n            risolto triggrerando più azioni da LGraphElement setter\r\n            let dvertexid: Pointer, newdvertex: DGraphElement, olddvertex: DGraphElement;\r\n            for (newdvertex of possibleInconsistencies[subType] as DGraphElement[]){\r\n                const olddvertex: DGraphElement = oldState.idlookup[newdvertex.id] as DGraphElement;\r\n                const notContainedAnymoreOut: Pointer<DGraphElement> = [];\r\n                const newlyInsertedOut: Pointer<DGraphElement>[] = [];\r\n                U.arraySymmetricDifference(olddvertex.subElements, newdvertex.subElements, notContainedAnymoreOut, newlyInsertedOut);\r\n                for (let geid of notContainedAnymoreOut) {\r\n                    const oldge = oldState.idlookup[geid] as DGraphElement;\r\n                    const newge = state.idlookup[geid] as DGraphElement;\r\n                    if (oldge.containedIn === newge.containedIn) continue;\r\n                }\r\n                for (let geid of notContainedAnymoreOut) {\r\n                    const ge = idlookup[geid] as DGraphElement;\r\n                    if (ge.containedIn === context.data.id) set container = context.data.id\r\n                    meglio se sti 2 cicli li fai nel reducer perchè  potrebbe esserci una azione pending che setta il parent = someotherid e qui faccio partire una azione che setta il parent a null, \"annullando\" una azione pending non ancora eseguita\r\n                }\r\n            }\r\n            break;*/}}// if state is updated shallow copy state before returning it\nreturn state;}var initialState=null;var storeLoaded=false;var UDRegexp=/(?:^|\\s|;|}|\\n|\\t|\\(|,)ret\\s*\\.\\s*[a-zA-Z_$][0-9a-zA-Z_$]*\\s*=/g;/* tested with:\r\nif (ret.key = stuff) ret.key2=morestuff;\r\n;ret.k=3;\r\n}ret. kk=3,ret. a = 3\r\n\r\nret .b = 3\r\n*/ // then add to it: content of props, constants, usageDeclarations\nexport function reducer(){var oldState=arguments.length>0&&arguments[0]!==undefined?arguments[0]:initialState;var action=arguments.length>1?arguments[1]:undefined;try{return unsafereducer(oldState,action);}catch(e){console.error('unhandled error in reducer',{oldState:oldState,action:action});return oldState;}}function unsafereducer(){var _ret$VIEWS_RECOMPILE_,_ret$VIEWS_RECOMPILE_2,_ret$VIEWS_RECOMPILE_3,_ret$VIEWS_RECOMPILE_4,_ret$VIEWS_RECOMPILE_5;var oldState=arguments.length>0&&arguments[0]!==undefined?arguments[0]:initialState;var action=arguments.length>1?arguments[1]:undefined;var ret=_reducer(oldState,action);if(ret===oldState)return oldState;ret.idlookup.__proto__=DPointerTargetable.pendingCreation;// client synchronization stuff\nif(oldState===null||oldState===void 0?void 0:oldState.collaborativeSession){var ignoredFields=['contextMenu','_lastSelected','isLoading','collaborativeSession'];/* Checking if CompositeAction has some actions that MUST be ignored */var compositeAction=null;if(action.type===CompositeAction.type){compositeAction=action;var subActions=compositeAction.actions||[];compositeAction.actions=subActions.filter(function(a){return!ignoredFields.includes(a.field);});}if(compositeAction&&!compositeAction.actions.length)return ret;action=compositeAction?compositeAction:action;if(action.sender===DUser.current&&!ignoredFields.includes(action.field)){var parsedAction=JSON.parse(JSON.stringify(action));Collaborative.client.emit('pushAction',parsedAction);}}if(ret.VIEWS_RECOMPILE_all===true)ret.VIEWS_RECOMPILE_all=Object.keys(ret.idlookup);if((_ret$VIEWS_RECOMPILE_=ret.VIEWS_RECOMPILE_all)===null||_ret$VIEWS_RECOMPILE_===void 0?void 0:_ret$VIEWS_RECOMPILE_.length){var resetAllNodes=false;var _iterator4=_createForOfIteratorHelper(new Set(ret.VIEWS_RECOMPILE_all)),_step4;try{for(_iterator4.s();!(_step4=_iterator4.n()).done;){var id=_step4.value;var d=ret.idlookup[id];if(RuntimeAccessibleClass.extends(d.className,\"DViewElement\")){d.css_MUST_RECOMPILE=true;transientProperties.view[d.id]={};var _iterator5=_createForOfIteratorHelper(DViewElement.MeasurableKeys),_step5;try{for(_iterator5.s();!(_step5=_iterator5.n()).done;){var k=_step5.value;ret['VIEWS_RECOMPILE_'+k].push(d.id);}}catch(err){_iterator5.e(err);}finally{_iterator5.f();}if(!resetAllNodes)resetAllNodes=true;}if(RuntimeAccessibleClass.extends(d.className,\"DModelElement\")){if(d.className===\"DClass\"){var _oldState$idlookup$d$,_ret$idlookup$d$id;var oldname=(_oldState$idlookup$d$=oldState.idlookup[d.id])===null||_oldState$idlookup$d$===void 0?void 0:_oldState$idlookup$d$.name;var newname=(_ret$idlookup$d$id=ret.idlookup[d.id])===null||_ret$idlookup$d$id===void 0?void 0:_ret$idlookup$d$id.name;if(oldname!==newname)ret.ClassNameChanged[d.id]=oldname;}// transientProperties.modelElement[d.id] = { } as any; stuff in here does not need replacement, can never be dangerous.\n}if(RuntimeAccessibleClass.extends(d.className,\"DGraphElement\")){transientProperties.node[d.id]={};}}}catch(err){_iterator4.e(err);}finally{_iterator4.f();}if(resetAllNodes)for(var nid in transientProperties.node){transientProperties.node[nid]={};}}// local changes to out-of-redux stuff\nif(ret.VIEWS_RECOMPILE_ocl.length){// for (let gid of ret.graphs) Selectors.updateViewMatchings(gid, ret.modelElements, Object.values(ret.idlookup).map( d => RuntimeAccessibleClass.extends(d, DModelElement.cname)));\n// for (let vid of ret.VIEW_APPLIABLETO_NEEDS_RECALCULATION) { }\nvar _iterator6=_createForOfIteratorHelper(new Set(ret.VIEWS_RECOMPILE_ocl)),_step6;try{for(_iterator6.s();!(_step6=_iterator6.n()).done;){var vid=_step6.value;if(!transientProperties.view[vid])transientProperties.view[vid]={};transientProperties.view[vid].oclEngine=undefined;// force re-parse\ntransientProperties.view[vid].oclChanged=true;for(var _nid in transientProperties.node){var tnv=transientProperties.node[_nid].viewScores[vid];if((tnv===null||tnv===void 0?void 0:tnv.OCLScore)!==ViewEClassMatch.NOT_EVALUATED_YET)tnv.OCLScore=ViewEClassMatch.NOT_EVALUATED_YET;}}}catch(err){_iterator6.e(err);}finally{_iterator6.f();}ret.VIEWS_RECOMPILE_ocl=[];}/*\r\n    if (ret.VIEWOCL_UPDATE_NEEDS_RECALCULATION.length) {\r\n        // not implemented for now\r\n        ret.VIEWOCL_UPDATE_NEEDS_RECALCULATION = [];\r\n    }*/if(ret.VIEWS_RECOMPILE_preconditions.length){var _iterator7=_createForOfIteratorHelper(new Set(ret.VIEWS_RECOMPILE_preconditions)),_step7;try{for(_iterator7.s();!(_step7=_iterator7.n()).done;){var _vid=_step7.value;for(var _nid2 in transientProperties.node){var _tnv=transientProperties.node[_nid2].viewScores[_vid];if((_tnv===null||_tnv===void 0?void 0:_tnv.metaclassScore)!==ViewEClassMatch.NOT_EVALUATED_YET)_tnv.metaclassScore=ViewEClassMatch.NOT_EVALUATED_YET;}}}catch(err){_iterator7.e(err);}finally{_iterator7.f();}ret.VIEWS_RECOMPILE_preconditions=[];}if((_ret$VIEWS_RECOMPILE_2=ret.VIEWS_RECOMPILE_constants)===null||_ret$VIEWS_RECOMPILE_2===void 0?void 0:_ret$VIEWS_RECOMPILE_2.length){var _iterator8=_createForOfIteratorHelper(new Set(ret.VIEWS_RECOMPILE_constants)),_step8;try{for(_iterator8.s();!(_step8=_iterator8.n()).done;){var _vid2=_step8.value;// compiled in func, and executed, result does not vary between nodes.\nvar dv=DPointerTargetable.fromPointer(_vid2,ret);// transientProperties.view[vid].constantsList = dv.constants?.match(UDRegexp).map(s=>s.substring(4, s.length-1).trim()) || [];\n// let allContextKeys = {...contextFixedKeys};\nif(!dv.constants){if(!transientProperties.view[_vid2])transientProperties.view[_vid2]={};transientProperties.view[_vid2].constants={};transientProperties.view[_vid2].constantsList=[];// no need to recompile UD, jsx or measurables, they will have additional parameters in scope but they are undefined and cause no problems.\ncontinue;}var constantsOutput={};var context={view:dv};// context at this point holds only static stuff, which are in gloval scope (window) plus view.\nvar paramStr='{'+Object.keys(context).join(',')+'}, ret';try{// the scope of new Function() is \"window\" and not the function where is called, unlike eval();\nvar constantsFunction=new Function(paramStr,'return ('+dv.constants+')(ret)').bind(context);constantsFunction(context,constantsOutput);}catch(e){console.error('error constants parse',{vid:_vid2,e:e,paramStr:paramStr,body:'return ('+dv.constants+')(ret)'});// todo: how do i render an error from here? even if i set jsx or ud.__invalidDeclarations it will be recompiled. need a constants.__invalidDeclarations too?\n}transientProperties.view[_vid2].constants=constantsOutput;transientProperties.view[_vid2].constantsList=Object.keys(transientProperties.view[_vid2].constants);// implies recompilation of: jsCondition, ud, jsx and all measurable events\nret.VIEWS_RECOMPILE_jsCondition.push(_vid2);ret.VIEWS_RECOMPILE_usageDeclarations.push(_vid2);ret.VIEWS_RECOMPILE_jsxString.push(_vid2);ret.VIEWS_RECOMPILE_events.push(_vid2);var _iterator9=_createForOfIteratorHelper(DViewElement.MeasurableKeys),_step9;try{for(_iterator9.s();!(_step9=_iterator9.n()).done;){var _k=_step9.value;ret['VIEWS_RECOMPILE_'+_k].push(_vid2);}}catch(err){_iterator9.e(err);}finally{_iterator9.f();}}}catch(err){_iterator8.e(err);}finally{_iterator8.f();}}ret.VIEWS_RECOMPILE_constants=[];if((_ret$VIEWS_RECOMPILE_3=ret.VIEWS_RECOMPILE_usageDeclarations)===null||_ret$VIEWS_RECOMPILE_3===void 0?void 0:_ret$VIEWS_RECOMPILE_3.length){var _iterator10=_createForOfIteratorHelper(new Set(ret.VIEWS_RECOMPILE_usageDeclarations)),_step10;try{for(_iterator10.s();!(_step10=_iterator10.n()).done;){var _dv$usageDeclarations;var _vid3=_step10.value;// compiled in func, but NOT executed, result varies between nodes.\nvar _dv=DPointerTargetable.fromPointer(_vid3,ret);var tv=transientProperties.view[_vid3];if(!tv)transientProperties.view[_vid3]=tv={};if(!_dv.usageDeclarations){tv.UDList=[];tv.UDFunction=undefined;// no need to recompile jsx or measurables, they will have additional parameters in scope but they are undefined and cause no problems.\ncontinue;}var matches=((_dv$usageDeclarations=_dv.usageDeclarations)===null||_dv$usageDeclarations===void 0?void 0:_dv$usageDeclarations.match(UDRegexp))||[];transientProperties.view[_vid3].UDList=matches.map(function(s){s=s.trim();return s.substring(s.indexOf('\\.')+1,s.length-2).trim();});console.log('matches',{matches:matches,udlist:transientProperties.view[_vid3].UDList});// warning for user: do not redeclare ret in nested blocks.\n// do not use ret[key] syntax.\n// do not set nested values directly (ret.key.subkey syntax).\n// do not use ret.key +=, -= or any other operator assignment different than \"=\"\n// if that is ever required, do instead\n// do not assign values to ret in block comments\n// those restrictions only apply to the ret object, all those violations can be done on other objects.\n// so the following is valid, and a way to overcome the previous limitations:\n// let subobject = {}; subobject[key] += stuff; ret.somefixedname = subobject;\nvar allContextKeys=_objectSpread({},contextFixedKeys);var _iterator11=_createForOfIteratorHelper(tv.constantsList),_step11;try{for(_iterator11.s();!(_step11=_iterator11.n()).done;){var _k2=_step11.value;if(!allContextKeys[_k2])allContextKeys[_k2]=true;}}catch(err){_iterator11.e(err);}finally{_iterator11.f();}var _paramStr='{'+Object.keys(allContextKeys).join(',')+'}, ret';if(_vid3.includes('Model'))console.log(\"modelparse, ud\",{paramStr:_paramStr,udstr:_dv.usageDeclarations,udlist:transientProperties.view[_vid3].UDList});try{tv.UDFunction=new Function(_paramStr,'return ('+_dv.usageDeclarations+')(ret)');}catch(e){var strerr=JSON.stringify((e.message||'').split('\\n')[0]);var errbody=\"ret.__invalidUsageDeclarations = \"+strerr+\"; ret.__invalidUsageDeclarations.isSyntax = true; return ret;\";console.error('error udparse',{vid:_vid3,e:e,paramStr:_paramStr,body:'return ('+_dv.usageDeclarations+')(ret)',strerr:strerr,errbody:errbody});tv.UDFunction=new Function(\"ret\",errbody);}// implies recompilation of: jsx and all measurable events\nret.VIEWS_RECOMPILE_jsxString.push(_vid3);ret.VIEWS_RECOMPILE_events.push(_vid3);var _iterator12=_createForOfIteratorHelper(DViewElement.MeasurableKeys),_step12;try{for(_iterator12.s();!(_step12=_iterator12.n()).done;){var _k3=_step12.value;ret['VIEWS_RECOMPILE_'+_k3].push(_vid3);}}catch(err){_iterator12.e(err);}finally{_iterator12.f();}}}catch(err){_iterator10.e(err);}finally{_iterator10.f();}}ret.VIEWS_RECOMPILE_usageDeclarations=[];if(ret.VIEWS_RECOMPILE_events.length){// for (let gid of ret.graphs) Selectors.updateViewMatchings(gid, ret.modelElements, Object.values(ret.idlookup).map( d => RuntimeAccessibleClass.extends(d, DModelElement.cname)));\n// for (let vid of ret.VIEW_APPLIABLETO_NEEDS_RECALCULATION) { }\nvar _iterator13=_createForOfIteratorHelper(new Set(ret.VIEWS_RECOMPILE_events)),_step13;try{for(_iterator13.s();!(_step13=_iterator13.n()).done;){var entry=_step13.value;var _vid4=void 0;var _dv2=void 0;var keys=void 0;if(typeof entry===\"object\"){_vid4=entry.vid;_dv2=DPointerTargetable.fromPointer(_vid4,ret);keys=entry.keys||Object.keys(_dv2.events);}else{_vid4=entry;_dv2=DPointerTargetable.fromPointer(_vid4,ret);keys=Object.keys(_dv2.events);}var _tv=transientProperties.view[_vid4];if(!_tv)transientProperties.view[_vid4]=_tv={};if(!_tv.events)_tv.events={};// if (!tv.events_raw) tv.events_raw = {};\nvar _iterator14=_createForOfIteratorHelper(keys),_step14;try{for(_iterator14.s();!(_step14=_iterator14.n()).done;){var key=_step14.value;if(!key){delete _tv.events[key];continue;}var _allContextKeys=_objectSpread({},contextFixedKeys);var _iterator15=_createForOfIteratorHelper(transientProperties.view[_vid4].constantsList),_step15;try{for(_iterator15.s();!(_step15=_iterator15.n()).done;){var _k4=_step15.value;if(!_allContextKeys[_k4])_allContextKeys[_k4]=true;}}catch(err){_iterator15.e(err);}finally{_iterator15.f();}var _iterator16=_createForOfIteratorHelper(transientProperties.view[_vid4].UDList),_step16;try{for(_iterator16.s();!(_step16=_iterator16.n()).done;){var _k5=_step16.value;if(!_allContextKeys[_k5])_allContextKeys[_k5]=true;}}catch(err){_iterator16.e(err);}finally{_iterator16.f();}var _paramStr2='{'+Object.keys(_allContextKeys).join(',')+'}, ..._params';// dv.events[key] = (...params)=> code\nvar body='return ('+_dv2.events[key]+')(..._params)';// if (vid.includes('Model')) console.log(\"modelparse, jsx\", {paramStr, body});\ntry{_tv.events[key]=new Function(_paramStr2,body);// tv.events_raw[key] = new Function(paramStr, body) as ((...a:any)=>any);\n// attempt to auto obtain node context\n// impossile with view.event.name\n// could with node.event.name if node.get_event sets a current node thing__, no he must wrap the func!! in the getter\n// tv.events[key] = (..._params2:any) => { return tv.events_raw[key](context, ..._params2) };\n}catch(e){console.error('error jsxparse',{vid:_vid4,e:e,paramStr:_paramStr2,body:body});_tv.events[key]=function(context){return Log.ee(\"failed to parse function body: \"+e.message.split(\"\\n\")[0],e.message);};}}}catch(err){_iterator14.e(err);}finally{_iterator14.f();}}}catch(err){_iterator13.e(err);}finally{_iterator13.f();}ret.VIEWS_RECOMPILE_events=[];// triggers recompile of nothing\n}if((_ret$VIEWS_RECOMPILE_4=ret.VIEWS_RECOMPILE_jsCondition)===null||_ret$VIEWS_RECOMPILE_4===void 0?void 0:_ret$VIEWS_RECOMPILE_4.length){var _iterator17=_createForOfIteratorHelper(new Set(ret.VIEWS_RECOMPILE_jsCondition)),_step17;try{for(_iterator17.s();!(_step17=_iterator17.n()).done;){var _vid5=_step17.value;var _dv3=DPointerTargetable.fromPointer(_vid5,ret);var _tv2=transientProperties.view[_vid5];if(!_tv2)transientProperties.view[_vid5]=_tv2={};_tv2.jsConditionChanged=true;if(!_dv3.jsCondition){_tv2.jsCondition=undefined;continue;}var lines=_dv3.jsCondition.trim().split('\\n');var lastLine=lines[lines.length-1];if(lastLine.indexOf('return')!==0)lines[lines.length-1]=\"return (\".concat(lastLine,\")\");if(!_dv3.jsxString){transientProperties.view[_vid5].JSXFunction=undefined;continue;}var _allContextKeys2=_objectSpread({},contextFixedKeys);var _iterator18=_createForOfIteratorHelper(transientProperties.view[_vid5].constantsList),_step18;try{for(_iterator18.s();!(_step18=_iterator18.n()).done;){var _k6=_step18.value;if(!_allContextKeys2[_k6])_allContextKeys2[_k6]=true;}}catch(err){_iterator18.e(err);}finally{_iterator18.f();}var _paramStr3='{'+Object.keys(_allContextKeys2).join(',')+'}';var _body=lines.join('\\n');try{_tv2.jsCondition=new Function(_paramStr3,_body);}catch(e){_tv2.jsCondition=undefined;console.log('JS Condition parsed error',e);}}}catch(err){_iterator17.e(err);}finally{_iterator17.f();}}ret.VIEWS_RECOMPILE_jsCondition=[];if((_ret$VIEWS_RECOMPILE_5=ret.VIEWS_RECOMPILE_jsxString)===null||_ret$VIEWS_RECOMPILE_5===void 0?void 0:_ret$VIEWS_RECOMPILE_5.length){var _iterator19=_createForOfIteratorHelper(new Set(ret.VIEWS_RECOMPILE_jsxString)),_step19;try{var _loop=function _loop(){var vid=_step19.value;// compiled in func, but NOT executed, result varies between nodes.\nvar dv=DPointerTargetable.fromPointer(vid,ret);var tv=transientProperties.view[vid];if(!tv)transientProperties.view[vid]=tv={};if(!dv.jsxString){transientProperties.view[vid].JSXFunction=undefined;return\"continue\";}var allContextKeys=_objectSpread({},contextFixedKeys);var _iterator20=_createForOfIteratorHelper(transientProperties.view[vid].constantsList),_step20;try{for(_iterator20.s();!(_step20=_iterator20.n()).done;){var _k7=_step20.value;if(!allContextKeys[_k7])allContextKeys[_k7]=true;}}catch(err){_iterator20.e(err);}finally{_iterator20.f();}var _iterator21=_createForOfIteratorHelper(transientProperties.view[vid].UDList),_step21;try{for(_iterator21.s();!(_step21=_iterator21.n()).done;){var _k8=_step21.value;if(!allContextKeys[_k8])allContextKeys[_k8]=true;}}catch(err){_iterator21.e(err);}finally{_iterator21.f();}var paramStr='{'+Object.keys(allContextKeys).join(',')+'}';console.log('jsxparse',{allContextKeys:allContextKeys,ud:transientProperties.view[vid].UDList,c:transientProperties.view[vid].constantsList});var body='return ('+UX.parseAndInject(DSL.parser(dv.jsxString),dv)+')';// if (vid.includes('Model')) console.log(\"modelparse, jsx\", {paramStr, body});\nconsole.log('jsxparse',{vid:vid,paramStr:paramStr,body:body});try{transientProperties.view[vid].JSXFunction=new Function(paramStr,body);}catch(e){/*try{\r\n                let try_to_get_better_error = eval(\"let __f = function(\" + paramStr+\") {\\n\" + body + \"}\");\r\n            } catch(eeval){\r\n                console.error(\"eval error same as func error\", {e, eeval});\r\n                e = eeval;\r\n            }*/console.error('error jsxparse',{vid:vid,e:e,paramStr:paramStr,body:body});transientProperties.view[vid].JSXFunction=function(context){return GraphElementComponent.displayError(e,'JSX Syntax',dv);};}// implies recompilation of: ... nothing?\n};for(_iterator19.s();!(_step19=_iterator19.n()).done;){var _ret=_loop();if(_ret===\"continue\")continue;}}catch(err){_iterator19.e(err);}finally{_iterator19.f();}}ret.VIEWS_RECOMPILE_jsxString=[];var _iterator22=_createForOfIteratorHelper(DViewElement.MeasurableKeys),_step22;try{var _loop2=function _loop2(){var _ref;var key=_step22.value;if((_ref=ret['VIEWS_RECOMPILE_'+key])===null||_ref===void 0?void 0:_ref.length){var _iterator23=_createForOfIteratorHelper(new Set(ret['VIEWS_RECOMPILE_'+key])),_step23;try{var _loop3=function _loop3(){var vid=_step23.value;var dv=DPointerTargetable.fromPointer(vid,ret);var tv=transientProperties.view[vid];if(!tv)transientProperties.view[vid]=tv={};var str=dv[key];if(!str){transientProperties.view[vid][key]=undefined;return\"continue\";}var allContextKeys=_objectSpread({},contextFixedKeys);var _iterator24=_createForOfIteratorHelper(transientProperties.view[vid].constantsList),_step24;try{for(_iterator24.s();!(_step24=_iterator24.n()).done;){var _k9=_step24.value;if(!allContextKeys[_k9])allContextKeys[_k9]=true;}}catch(err){_iterator24.e(err);}finally{_iterator24.f();}var _iterator25=_createForOfIteratorHelper(transientProperties.view[vid].UDList),_step25;try{for(_iterator25.s();!(_step25=_iterator25.n()).done;){var _k10=_step25.value;if(!allContextKeys[_k10])allContextKeys[_k10]=true;}}catch(err){_iterator25.e(err);}finally{_iterator25.f();}var paramStr='{'+Object.keys(allContextKeys).join(',')+'}';console.log('measurable parse '+key,{allContextKeys:allContextKeys,ud:transientProperties.view[vid].UDList,c:transientProperties.view[vid].constantsList});console.log('measurable parse '+key,{vid:vid,paramStr:paramStr,body:str});try{transientProperties.view[vid][key]=new Function(paramStr,str);}catch(e){console.error('error measurable parse '+key,{vid:vid,e:e,paramStr:paramStr,body:str});transientProperties.view[vid][key]=undefined;// display error in jsx\ntransientProperties.view[vid].JSXFunction=function(context){return GraphElementComponent.displayError(e,'Measurable '+key+' Syntax',dv);};return\"break\";}};for(_iterator23.s();!(_step23=_iterator23.n()).done;){var _ret2=_loop3();if(_ret2===\"continue\")continue;if(_ret2===\"break\")break;}}catch(err){_iterator23.e(err);}finally{_iterator23.f();}}ret['VIEWS_RECOMPILE_'+key]=[];};for(_iterator22.s();!(_step22=_iterator22.n()).done;){_loop2();}}catch(err){_iterator22.e(err);}finally{_iterator22.f();}for(var dataid in ret.ClassNameChanged){if(dataid==='clonedCounter')continue;// NB: if i ever want to access a constructor's other properties in ocl, like \"context Persona inv: self.$somecounter === Persona.instances.length\",\n// i would need to update this every time a DClass property changes instead of only when name changes.\n// if it's first creation of a modelpiece\nif(!transientProperties.modelElement[dataid]){transientProperties.modelElement[dataid]={nodes:{}};}// update ocl type names\nvar data=ret.idlookup[dataid];RuntimeAccessibleClass.makeOCLConstructor(data,ret,oldState);// here i should reset all tnv.oclEngine too and set all ocl scores to notevaluated, but it is too computationally heavy\n// and it's useful to keep the old ocl condition valid with past names until manually edited.\n}ret.ClassNameChanged={};return ret;}export function _reducer/*<S extends StateNoFunc, A extends Action>*/(){var oldState=arguments.length>0&&arguments[0]!==undefined?arguments[0]:initialState;var action=arguments.length>1?arguments[1]:undefined;var times;var state;var removedDeltas=[];switch(action.type){case UndoAction.type:times=action.value;state=oldState;Log.exDev(times<=0,\"undo must be positive\",action);while(times--){var _delta=statehistory[DUser.current].undoable.pop();removedDeltas.push(_delta);state=undo(state,_delta);}state.VIEWS_RECOMPILE_all=removedDeltas.flatMap(function(d){return Object.keys((d===null||d===void 0?void 0:d.idlookup)||{});});// state.VIEWS_RECOMPILE_all = true;\nreturn state;case RedoAction.type:times=action.value;state=oldState;Log.exDev(times<=0,\"redo must be positive\",action);while(times--){var _delta2=statehistory[DUser.current].redoable.pop();removedDeltas.push(_delta2);state=undo(state,_delta2,false);}state.VIEWS_RECOMPILE_all=removedDeltas.flatMap(function(d){return Object.keys((d===null||d===void 0?void 0:d.idlookup)||{});});// state.VIEWS_RECOMPILE_all = true;\nreturn state;// case CombineHistoryAction.type: return combineHistory(oldState); break;\n// todo: se al posto di \"annullare l'undo\" memorizzo l'azione e la rieseguo, posso ripetere l'ultimo passo N volte e questa azione diventa utile per combinare passi e ripetere blocchi di azioni assieme\ndefault:var ret=doreducer(oldState,action);if(ret===oldState)return ret;// statehistory[DUser.current].redoable = [];   <-- Moved to stateInitializer()\nvar delta=U.objectDelta(ret,oldState);if(!filterundoableactions(delta))return ret;// console.log(\"setting undoable action:\", {ret, oldState0:{...oldState}, oldState, delta});\nif(oldState!==null)statehistory[DUser.current].undoable.push(delta);return ret;}}function filterundoableactions(delta){if(!statehistory.globalcanundostate)return false;if(Object.keys(delta).length===1){if(\"dragging\"in delta)return false;if(\"_lastSelected\"in delta)return false;if(\"contextMenu\"in delta)return false;}return true;}function undo(state,delta){var isundo=arguments.length>2&&arguments[2]!==undefined?arguments[2]:true;if(!delta)return state;var undonestate=_objectSpread({},state);//   controlla se vengono shallow-copied solo e tutti gli oggetti nested lungo la catena del percorso delle modifiche\n//   es: root.a.b.c=3 + root.a.b.d=3 = 4+1 modifiche, 5 shallow copies including the root\nundorecursive(delta,undonestate);if(isundo)statehistory[DUser.current].redoable.push(U.objectDelta(undonestate,state));// reverses from undo to redo and viceversa swapping arguments, so the target result after appliying the delta changes\nelse statehistory[DUser.current].undoable.push(U.objectDelta(undonestate,state));// redo is \"undoing an undo\", reversing his changes just like an undo reverses an ordinary action changes.\nreturn undonestate;}function undorecursive(deltalevel,statelevel){// statelevel = {...statelevel}; not working if i do it here, just a new var. first time copy id done in caller func undo(). recursive copies are done before recursive step\nfor(var key in deltalevel){var delta=deltalevel[key];console.log(\"undoing\",{delta:delta,key:key,deltalevel:deltalevel,statelevel:statelevel});if(key.indexOf(\"_-\")===0){delete statelevel[key.substring(2)];continue;}if(typeof delta===\"object\"){// if (U.isObject(delta, false, false, true)) {\nstatelevel[key]=_objectSpread({},statelevel[key]);undorecursive(deltalevel[key],statelevel[key]);}else{statelevel[key]=delta;}}}function doreducer/*<S extends StateNoFunc, A extends Action>*/(){var oldState=arguments.length>0&&arguments[0]!==undefined?arguments[0]:initialState;var action=arguments.length>1?arguments[1]:undefined;if(!oldState){oldState=initialState=DState.new();}var ca;// console.log('external REDUCER', {action, CEtype:CreateElementAction.type});\nif(!storeLoaded){// new SetRootFieldAction('forceinit', true);\nstoreLoaded=true;}if(!oldState.forceinit){// afterStoreLoad();\n// new SetRootFieldAction('forceinit', true);\n}//  setTimeout(afterStoreLoad, 1);\nswitch(action.type){case CompositeAction.type:ca=action;break;case LoadAction.type:default:if(action.type.indexOf('@@redux/')===0){//storeLoaded = true;\nreturn oldState;}ca=new CompositeAction([action],false);break;}var ret=CompositeActionReducer(oldState,ca);/*if (state.current !== ret) {\r\n        state.current = ret;\r\n        state.past.push(ret);\r\n    }*/return ret;}function setSubclasses(roots){RuntimeAccessibleClass.extendMatrix=new SimpleTree(roots,\"subclasses\").getiIsSubElementMatrix(\"cname\");/*\r\n    let tree = new TreeModel({\r\n        childrenPropertyName: \"subclasses\"\r\n    });\r\n    for (let key in dict){\r\n        let constructor = dict[key];\r\n        if(!constructor.hasOwnProperty(\"subclasses\")) constructor.subclasses = [];\r\n    }\r\n    RuntimeAccessibleClass.extendTree = (tree as any).safe_parse(RuntimeAccessibleClass);*/}// windoww.TreeModel = TreeModel;\nfunction buildLSingletons(alld,alll){for(var dname in alld){switch(dname){case\"DeleteElementAction\":continue;case\"DV\":continue;case\"Debug\":continue;default:break;}if((dname[1]||\"\").toLowerCase()===dname[1])continue;// if second letter is lowercase, it's not a \"D\" class\nvar tagless=dname.substring(1);var d=alld[dname];var l=alll['L'+tagless];if(!d||!l)console.error(\"missing d constructor\",{d:d,l:l});d.logic=l;if(!l)console.error('init() could not find L-class during mapping',l,d);// @ts-ignore\nd.singleton=new l('dwc');d.structure=d;l.logic=d.logic;l.singleton=d.singleton;l.structure=d.structure;// if (!d.subclasses) d.subclasses = [];\n// @ts-ignore\n// for (let sc of d.subclasses) { if (!sc[\"_extends\"]) sc[\"_extends\"] = [];  sc[\"_extends\"].push(d); }\n}}export function stateInitializer(){return _stateInitializer.apply(this,arguments);}function _stateInitializer(){_stateInitializer=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee(){var dClassesMap,lClassesMap,name,user;return _regeneratorRuntime.wrap(function _callee$(_context){while(1){switch(_context.prev=_context.next){case 0:statehistory[DUser.current]={redoable:[],undoable:[]};RuntimeAccessibleClass.fixStatics();dClassesMap={};lClassesMap={};_context.t0=_regeneratorRuntime.keys(RuntimeAccessibleClass.classes);case 5:if((_context.t1=_context.t0()).done){_context.next=17;break;}name=_context.t1.value;_context.t2=name[0];_context.next=_context.t2===\"D\"?11:_context.t2===\"L\"?13:10;break;case 10:return _context.abrupt(\"break\",15);case 11:dClassesMap[name]=RuntimeAccessibleClass.classes[name];return _context.abrupt(\"break\",15);case 13:lClassesMap[name]=RuntimeAccessibleClass.classes[name];return _context.abrupt(\"break\",15);case 15:_context.next=5;break;case 17:/*\r\n    let dClasses: string[] = RuntimeAccessibleClass.getAllNames().filter(rc => rc[0] === 'D');\r\n    let lClasses: string[] = RuntimeAccessibleClass.getAllNames().filter(rc => rc[0] === 'L');\r\n    let dClassesMap: Dictionary<string, typeof DPointerTargetable> =\r\n        dClasses.reduce((acc: GObject, curr) => {acc[curr] = RuntimeAccessibleClass.get(curr); return acc}, {});\r\n    let lClassesMap: Dictionary<string, typeof LPointerTargetable> =\r\n        lClasses.reduce((acc: GObject, curr) => {acc[curr] = RuntimeAccessibleClass.get(curr); return acc}, {}); */buildLSingletons(dClassesMap,lClassesMap);setSubclasses(RuntimeAccessibleClass.get(\"DPointerTargetable\"));// setSubclasses(lClassesMap);\nwindoww.defaultContext=_objectSpread(_objectSpread({$:windoww.$,getPath:getPath,React:React,Selectors:Selectors},RuntimeAccessibleClass.getAllClassesDictionary()),windoww.Components);// global document events\n// do not use typings or class constructors here or it will change import order\nsetTimeout(function(){return $(document).on(\"mouseup\",function(e){return RuntimeAccessibleClass.get(\"GraphDragManager\").stopPanning(e);});},// ()=> $(document).on(\"mouseup\", (e: MouseUpEvent) => (window as any).GraphDragManager.stopPanning(e)), //a\n1);DState.init();user=Storage.read('user');if(user){_context.next=25;break;}return _context.abrupt(\"return\");case 25:DUser.new(user.username,user.id);DUser.current=user.id;_context.next=29;return ProjectsApi.getAll();case 29:case\"end\":return _context.stop();}}},_callee);}));return _stateInitializer.apply(this,arguments);}","map":{"version":3,"names":["DViewElement","UX","GraphElementComponent","ViewEClassMatch","Action","CompositeAction","CreateElementAction","DeleteElementAction","DPointerTargetable","DState","DUser","getPath","Log","MyError","PendingPointedByPaths","PointedBy","Pointers","RuntimeAccessibleClass","SetFieldAction","SetRootFieldAction","statehistory","React","LoadAction","RedoAction","UndoAction","Collaborative","SimpleTree","transientProperties","Selectors","contextFixedKeys","Storage","ProjectsApi","DSL","windoww","window","U","deepCopyButOnlyFollowingPath","oldStateDoNotModify","action","prevAction","newVal","_action$path","newRoot","_objectSpread","current","path","length","gotChanged","alreadyPastDivergencePoint","i","pathArray","key","trim","prevActionPathKey","Array","isArray","_toConsumableArray","clonedCounter","isArrayAppend","isArrayRemove","isObjectMerge","isObjectDifference","oldValue","endsWith","substr","replaceAll","type","ee","preexistingValue","isShallowEqual","value","tmp","subkey","isPointer","add","push","index","isNumber","undefined","indexOf","removedval","splice","remove","oldpointerdestinations","newpointerdestinations","difference","arrayDifference","_iterator","_createForOfIteratorHelper","removed","_step","s","n","done","rem","err","e","f","_iterator2","added","_step2","exDevv","CompositeActionReducer","oldState","actionBatch","_actions","actions","parse","all","apply","getSolveableActions","possibleInconsistencies","derivedActions","newState","_iterator3","_step3","elem","pendingCreation","id","className","constructor","cname","name","statefoldername","substring","toLowerCase","create","pointedBy","new","arrayMergeInPlace","sort","a1","a2","stringCompare","actiontype","console","log","a","t","field","v","updateRedundancies_OBSOLETE","state","subType","SubType","vertexSubElements","initialState","storeLoaded","UDRegexp","reducer","arguments","unsafereducer","error","_ret$VIEWS_RECOMPILE_","_ret$VIEWS_RECOMPILE_2","_ret$VIEWS_RECOMPILE_3","_ret$VIEWS_RECOMPILE_4","_ret$VIEWS_RECOMPILE_5","ret","_reducer","idlookup","__proto__","collaborativeSession","ignoredFields","compositeAction","subActions","filter","includes","sender","parsedAction","JSON","stringify","client","emit","VIEWS_RECOMPILE_all","Object","keys","resetAllNodes","_iterator4","Set","_step4","d","extends","css_MUST_RECOMPILE","view","_iterator5","MeasurableKeys","_step5","k","_oldState$idlookup$d$","_ret$idlookup$d$id","oldname","newname","ClassNameChanged","node","nid","VIEWS_RECOMPILE_ocl","_iterator6","_step6","vid","oclEngine","oclChanged","tnv","viewScores","OCLScore","NOT_EVALUATED_YET","VIEWS_RECOMPILE_preconditions","_iterator7","_step7","metaclassScore","VIEWS_RECOMPILE_constants","_iterator8","_step8","dv","fromPointer","constants","constantsList","constantsOutput","context","paramStr","join","constantsFunction","Function","bind","body","VIEWS_RECOMPILE_jsCondition","VIEWS_RECOMPILE_usageDeclarations","VIEWS_RECOMPILE_jsxString","VIEWS_RECOMPILE_events","_iterator9","_step9","_iterator10","_step10","_dv$usageDeclarations","tv","usageDeclarations","UDList","UDFunction","matches","match","map","udlist","allContextKeys","_iterator11","_step11","udstr","strerr","message","split","errbody","_iterator12","_step12","_iterator13","_step13","entry","events","_iterator14","_step14","_iterator15","_step15","_iterator16","_step16","_iterator17","_step17","jsConditionChanged","jsCondition","lines","lastLine","concat","jsxString","JSXFunction","_iterator18","_step18","_iterator19","_step19","_loop","_iterator20","_step20","_iterator21","_step21","ud","c","parseAndInject","parser","displayError","_ret","_iterator22","_step22","_loop2","_ref","_iterator23","_step23","_loop3","str","_iterator24","_step24","_iterator25","_step25","_ret2","dataid","modelElement","nodes","data","makeOCLConstructor","times","removedDeltas","exDev","delta","undoable","pop","undo","flatMap","redoable","doreducer","objectDelta","filterundoableactions","globalcanundostate","isundo","undonestate","undorecursive","deltalevel","statelevel","ca","forceinit","setSubclasses","roots","extendMatrix","getiIsSubElementMatrix","buildLSingletons","alld","alll","dname","tagless","l","logic","singleton","structure","stateInitializer","_stateInitializer","_asyncToGenerator","_regeneratorRuntime","mark","_callee","dClassesMap","lClassesMap","user","wrap","_callee$","_context","prev","next","fixStatics","t0","classes","t1","t2","abrupt","get","defaultContext","$","getAllClassesDictionary","Components","setTimeout","document","on","stopPanning","init","read","username","getAll","stop"],"sources":["C:/d/Programming/web/jodel-mde/src/redux/reducer/reducer.ts"],"sourcesContent":["import {\r\n    U as UType,\r\n    GraphDragManager,\r\n    MouseUpEvent,\r\n    orArr,\r\n    DModelElement,\r\n    DViewElement,\r\n    DClass,\r\n    DModel,\r\n    UX, EdgeOwnProps, EdgeStateProps, GraphElementComponent, ViewEClassMatch, bool\r\n} from '../../joiner';\r\nimport {\r\n    Action,\r\n    CompositeAction,\r\n    CreateElementAction,\r\n    DeleteElementAction,\r\n    Dictionary,\r\n    DocString,\r\n    DPointerTargetable,\r\n    DState,\r\n    DUser,\r\n    getPath,\r\n    GObject,\r\n    Log,\r\n    LPointerTargetable,\r\n    MyError,\r\n    ParsedAction,\r\n    PendingPointedByPaths,\r\n    PointedBy,\r\n    Pointer,\r\n    Pointers,\r\n    RuntimeAccessibleClass,\r\n    SetFieldAction,\r\n    SetRootFieldAction,\r\n    statehistory\r\n} from \"../../joiner\";\r\nimport React from \"react\";\r\nimport {LoadAction, RedoAction, UndoAction} from \"../action/action\";\r\nimport Collaborative from \"../../components/collaborative/Collaborative\";\r\nimport {SimpleTree} from \"../../common/SimpleTree\";\r\nimport {transientProperties, Selectors} from \"../../joiner\";\r\nimport {OclEngine} from \"@stekoe/ocl.js\";\r\nimport { contextFixedKeys } from '../../graph/graphElement/sharedTypes/sharedTypes';\r\nimport Storage from \"../../data/storage\";\r\nimport {ProjectsApi} from \"../../api/persistance\";\r\nimport DSL from \"../../DSL/DSL\";\r\n\r\nlet windoww = window as any;\r\nlet U: typeof UType = windoww.U;\r\n\r\n\r\nfunction deepCopyButOnlyFollowingPath(oldStateDoNotModify: DState, action: ParsedAction, prevAction: ParsedAction, newVal: any): DState | false{\r\n    let newRoot: DState = {...oldStateDoNotModify} as DState;\r\n    let current: any = newRoot;\r\n    if (!action.path?.length) throw new MyError(\"path length must be at least 1\", {action});\r\n    let gotChanged: boolean = false; // dovrebbe cambiare sempre, se non cambia non lancio neanche l'azione e non faccio la shallow copy, ma non si sa mai, così posso evitare un render se succede l' \"insuccedibile\"\r\n    let alreadyPastDivergencePoint = false; // true dal momento in cui il path dell'azione attuale e della azione precedente divergono, false fino al sotto-segmento in cui combaciano\r\n    // console.log('deepCopyButOnlyFollowingPath', arguments);\r\n    for (let i = 0; i < action.pathArray.length; i++) {\r\n        let key = action.pathArray[i].trim();\r\n        let prevActionPathKey = prevAction?.pathArray[i];\r\n        // middle execution: not on final loop\r\n        // console.log('deepCopyButOnlyFollowingPath', {current, i, imax:action.pathArray.length, key, gotChanged, alreadyPastDivergencePoint});\r\n        if (i !== action.pathArray.length - 1) {\r\n            if (alreadyPastDivergencePoint || key !== prevActionPathKey) {\r\n                // se l'oggetto è stato già duplicato in una azione composita, non lo duplico 2 volte.\r\n                alreadyPastDivergencePoint = true;\r\n                current[key] = Array.isArray(current[key]) ? [...current[key]] : {...current[key]};\r\n                current[key].clonedCounter = 1 + (current[key].clonedCounter || 0);\r\n            }\r\n            current = current[key];\r\n            continue;\r\n        }\r\n        // Giordano: added this on 03/12/2023 to prevent \"Cannot read properties of undefined\".\r\n        // if(!current) continue; damiano: temp removed to check if there are invalid actions firing\r\n        // perform final assignment\r\n        if (i >= action.pathArray.length - 1) {\r\n            let isArrayAppend = false;\r\n            let isArrayRemove = false;\r\n            let isObjectMerge = false;\r\n            let isObjectDifference = false;\r\n            // console.log('isarrayappend?', {endswith: U.endsWith(key, ['+=', '[]', '-1']), key, action, i});\r\n            // console.log('isarraydelete?', {endswith: U.endsWith(key, ['-='])});\r\n\r\n            let oldValue: any;\r\n            if (U.endsWith(key, ['+=', '[]'])) {\r\n                key = key.substr(0, key.length - 2).trim();\r\n                oldValue = current[key];\r\n                switch (typeof oldValue){\r\n                    case 'object':\r\n                    if (Array.isArray(oldValue)) isArrayAppend = true;\r\n                    else isObjectMerge = true;\r\n                    break;\r\n                    default: newVal += oldValue; break;\r\n                }\r\n            }\r\n            if (U.endsWith(key, ['-='])) {\r\n                key = key.substr(0, key.length - 2).trim();\r\n                oldValue = current[key];\r\n                switch (typeof oldValue){\r\n                    case 'object':\r\n                        if (Array.isArray(oldValue)) isArrayRemove = true;\r\n                        else isObjectDifference = true;\r\n                        break;\r\n                    case \"string\":\r\n                        newVal = U.replaceAll(oldValue, newVal, '');\r\n                        break;\r\n                    default: newVal -= oldValue; break;\r\n                }\r\n                isArrayRemove = true; }\r\n\r\n            // let unpointedElement: DPointerTargetable | undefined;\r\n            // perform final assignment\r\n            if (action.type === CreateElementAction.type && current[key]) {\r\n                oldValue = current[key];\r\n                gotChanged = false;\r\n                Log.ee(\"rejected CreateElementAction, rollback occurring:\", {action,\r\n                    preexistingValue: current[key], isShallowEqual: current[key] === action.value });\r\n                return false; // warning: use return only when you want to abort and skip subsequent CompositeAction sub-actions like now.\r\n            }\r\n            if (isObjectMerge) {\r\n                if (typeof newVal === 'string') { let tmp: any = {}; tmp[newVal] = true; newVal = tmp; }\r\n                oldValue = {...current[key]};\r\n                current[key] = {...current[key]};\r\n                for (let subkey in newVal) {\r\n                    // console.warn(\"object merge\", {current, key, subkey, newVal, old:current[key][subkey], new:newVal[subkey]});\r\n                    if (current[key][subkey] === newVal[subkey]) continue;\r\n                    current[key][subkey] = newVal[subkey];\r\n                    gotChanged = true;\r\n                    if (action.isPointer) { newRoot = PointedBy.add(key as Pointer, action, newRoot, \"+=\"); }\r\n                }\r\n            } else\r\n            if (isObjectDifference) {\r\n                if (typeof newVal === 'string') { let tmp: any = {}; tmp[newVal] = true; newVal = tmp; }\r\n                oldValue = {...current[key]};\r\n                current[key] = {...current[key]};\r\n                for (let subkey in newVal) {\r\n                    if (!(subkey in current[key])) continue;\r\n                    delete current[key][subkey];\r\n                    gotChanged = true;\r\n                    if (action.isPointer) { newRoot = PointedBy.add(key as Pointer, action, newRoot, \"-=\"); }\r\n                }\r\n            } else\r\n            if (isArrayAppend) {\r\n                gotChanged = true;\r\n                if (!Array.isArray(current[key])) { current[key] = []; }\r\n                oldValue = [...current[key]];\r\n                current[key] = [...current[key]];\r\n                current[key].push(newVal);\r\n                // unpointedElement = undefined;\r\n                if (action.isPointer) { newRoot = PointedBy.add(newVal as Pointer, action, newRoot, \"+=\"); }\r\n            } else\r\n            if (isArrayRemove) {\r\n                if (!Array.isArray(current[key])) { current[key] = []; }\r\n                oldValue = [...current[key]];\r\n                let index: number;\r\n                if (U.isNumber(newVal)) { // delete by index\r\n                    index = newVal;\r\n                    if (index < 0) index = oldValue.length + index; // if index is -2, i remove the penultimate element\r\n                } else\r\n                if (newVal === undefined) {\r\n                    index = oldValue.length - 1;\r\n                }\r\n                else {\r\n                    index = oldValue.indexOf(newVal);\r\n                }\r\n                // if it's negatively or positively out of boundary, i skip it\r\n                gotChanged = index >= 0 && index < current[key].length;\r\n                if (gotChanged) {\r\n                    current[key] = [...current[key]];\r\n                    let removedval = current[key].splice(index, 1); // in-place edit\r\n                    if (action.isPointer) { newRoot = PointedBy.remove(removedval as Pointer, action, newRoot, '-='); }\r\n                    /*\r\n                    fixed problem: se ho [dobj1, dobj2]... e li swappo, cambia un indice nel percorso \"pointedby\" e non me ne accorgo mai e un oggetto risulta \"pointedby\" da oggetti che non lo puntano o non esistono più a quell'indice\r\n                    SOLVED! by not including index in pointedBy path, but making it like \"parentObject.arrayKey+=\" instead of \"parentObject.arrayKey.4\"\r\n                    and knowing it's in the array it's enough info.\r\n\r\n                    // a.pointsto = [x, y, z]; a.pointsto = [x, z]       --->    remove a from y.pointedby\r\n                    const elementsThatChangedIndex: DPointerTargetable[] = current[key].slice(index);\r\n\r\n                    for (let j = 0; j < elementsThatChangedIndex.length; j++) {\r\n                        let newindex = index + j - 1;\r\n                        let oldFullpathTrimmed = action.pathArray.join('.');\r\n                        se realizzi \"pointedby\" qui è to do: remove old paths and re-add them with updated index\r\n                    }\r\n                    unpointedElement = newRoot.idlookup[oldValue];\r\n                    */\r\n                }\r\n            } else\r\n            if ((action.type === DeleteElementAction.type && !(key in current)) || current[key] === newVal) {\r\n                // value not changed\r\n                gotChanged = false;\r\n            } else {\r\n                // value changed\r\n                // todo: caso in cui setto manualmente classes.1 = pointer;\r\n                //  the latest element is array and not DPointerTargetable, so might need to buffer upper level in the tree? or instead of \"current\" keep an array of sub-objects encountered navigating the path in state.\r\n                oldValue = current[key];\r\n                gotChanged = true;\r\n                // unpointedElement = newRoot.idlookup[oldValue];\r\n                // NB: se elimino un oggetto che contiene array di puntatori, o resetto l'array di puntatori kinda like store.arr= [ptr1, ptr2, ...]; store.arr = [];\r\n                // i puntati dall'array hanno i loro pointedBY non aggiornati, non voglio fare un deep check di tutto l'oggetto a cercare puntatori per efficienza.\r\n                // if (newVal === undefined) delete current[key];\r\n                if ((newVal === undefined) || false && action.type === DeleteElementAction.type) delete current[key];\r\n                else current[key] = newVal;\r\n\r\n                // update pointedBy's\r\n                // NB: even if the current action have isPointer=true, it doesn't mean the old value is a pointer as well for sure. so need to check old values.\r\n                // also what if old val is pointer, and new one isn't? will it be just removed without updating pointedBy's?\r\n                // already fixed: might need to evaluate this if block always regardless of action.isPointer,\r\n                // and do checks every time both on old and new value if they actually are ptrs.\r\n                if (true || action.isPointer) {\r\n                    let oldpointerdestinations: unknown[];\r\n                    let newpointerdestinations: unknown[];\r\n                    if (Array.isArray(newVal)) {\r\n                        newpointerdestinations = newVal;\r\n                        if (Array.isArray(oldValue)) { // case: path.array = array;\r\n                            oldpointerdestinations = oldValue;\r\n                        }\r\n                        else { // case: path.object = array; + case: path.value = array;\r\n                            oldpointerdestinations = [oldValue];\r\n                        }\r\n                    }\r\n                    else {\r\n                        // case: path.array = object; + case: path.array = value;\r\n                        newpointerdestinations = [newVal];\r\n                        if (Array.isArray(oldValue)) {\r\n                            oldpointerdestinations = oldValue;\r\n                        } else {\r\n                            // case: path.object = object; and all other cases without arrays involved\r\n                            oldpointerdestinations = [oldValue];\r\n                        }\r\n                    }\r\n                    // after i mapped all cases to path.array = array; i solve it for that case.\r\n                    let difference = U.arrayDifference(oldpointerdestinations, newpointerdestinations); // : {added: Pointer[], removed: Pointer[], starting: Pointer[], final: Pointer[]}\r\n                    for (let rem of difference.removed) {if (Pointers.isPointer(rem))\r\n                        newRoot = PointedBy.remove(rem, action, newRoot, undefined, oldStateDoNotModify); }\r\n                    for (let add of difference.added) { if (Pointers.isPointer(add))\r\n                        newRoot = PointedBy.add(add, action, newRoot, undefined, oldStateDoNotModify); }\r\n                    // a.pointsto = [a, b, c];  a.pointsto = [a, b, x];    ------>     c.pointedby.remove(a) & x.pointedby.add(a)\r\n                    // idlookup.somelongid.pointsto = [...b];\r\n                }\r\n            }\r\n            break;\r\n        }\r\n        Log.exDevv('should not reach here: reducer');\r\n    }\r\n    return gotChanged ? newRoot : oldStateDoNotModify;\r\n}\r\n\r\n\r\n// const pendingPointedByPaths: {from: DocString<\"Path in store\">, field: DocString<\"keyof object found in from path\">, to: Pointer}[] = [];\r\nfunction CompositeActionReducer(oldState: DState, actionBatch: CompositeAction): DState {\r\n    // per via di thunk se arrivo qui lo stato cambia sicuro in mono-client non synchro (non ri-assegno valori equivalenti)\r\n    // todo: ma se arrivano in ordine sbagliato da altri client? posso permetterlo?\r\n    let actions: ParsedAction[];\r\n    if (actionBatch.actions) actions = Action.parse(actionBatch.actions);\r\n    else actions = [Action.parse(actionBatch)]; // else-case is if it's a single action and not an actual compositeaction\r\n    if (PendingPointedByPaths.all.length) actions.push(...PendingPointedByPaths.getSolveableActions(oldState)); //.all.map( p=> p.resolve() ) );\r\n\r\n    Action.possibleInconsistencies = {};\r\n\r\n    // estraggo le azioni derivate\r\n    let derivedActions: ParsedAction[] = [];\r\n    let newState = oldState;\r\n    for (let action of actions) {\r\n        switch (action.type){\r\n            default: break;\r\n            case CreateElementAction.type:\r\n                const elem: DPointerTargetable = action.value;\r\n                delete DPointerTargetable.pendingCreation[elem.id];\r\n                /*\r\n                if (oldState.idlookup[elem.id]) {\r\n                    Log.ee(\"rejected CreateElementAction, rollback occurring:\", {action, elem:{...elem},\r\n                        preexistingValue: {...oldState.idlookup[elem.id]}, isEqual: elem === oldState.idlookup[elem.id] });\r\n                    return oldState; // warning: use return only when you want to abort and skip subsequent CompositeAction sub-actions like now.\r\n\r\n                    action.value = \"An element with that id already existed.\";\r\n                    action.path = action.field = \"CreateActionRejected\";\r\n                    action.className = SetRootFieldAction.name;\r\n                    action.type = SetRootFieldAction.type;\r\n                    action.pathArray = [action.path]; //a\r\n                    action.isPointer = false;\r\n                    // just to log it in undo-redo action list and have a feedback\r\n                    return oldState;}*/\r\n\r\n                elem.className = elem.className || (elem.constructor as typeof RuntimeAccessibleClass).cname || elem.constructor.name;\r\n                let statefoldername = elem.className.substring(1).toLowerCase() + 's';\r\n                derivedActions.push(\r\n                    Action.parse(SetRootFieldAction.create(statefoldername, elem.id,'[]', true)));\r\n                if (!Array.isArray(elem.pointedBy)) elem.pointedBy = [];\r\n                elem.pointedBy.push(PointedBy.new(statefoldername));\r\n                /*if (false && action.isPointer) {\r\n                    if (Array.isArray(action.value)) {\r\n                        const ptr: Pointer[] = action.value;\r\n                        // todo but replaced by side actions in execution of the main action instead of triggering derived actions\r\n                    }\r\n                    else {\r\n                        const ptr: Pointer = action.value;\r\n                        const target: DPointerTargetable | null = oldState.idlookup[ptr];\r\n                        let pendingPointedBy = PendingPointedByPaths.new(action, oldState);\r\n                        if (!target) PendingPointedByPaths.new(action, oldState).saveForLater(); // {from: action.path, field: action.field, to: target});\r\n                        // @ts-ignore\r\n                        else derivedActions.push(pendingPointedBy.resolve());\r\n                        // a -> x\r\n                        // a -> y     unset x.pointedby(a)\r\n                    }\r\n                }*/\r\n                break;\r\n        }\r\n    }\r\n    // console.error({U, Umip:U.arrayMergeInPlace, WU: windoww.U, WUmip: windoww.U.arrayMergeInPlace});\r\n    actions = U.arrayMergeInPlace<ParsedAction>(actions, derivedActions);\r\n\r\n    // ordino i path con segmenti comuni\r\n    actions = actions.sort( (a1, a2) => U.stringCompare(a1.path, a2.path));\r\n\r\n    // destrutturo solo i nodi intermedi e solo la prima volta che li incontro (richiede le azioni ordinate in base al path)\r\n\r\n    for (let i = 0; i < actions.length; i++) {\r\n        const prevAction: ParsedAction = actions[i-1];\r\n        const action: ParsedAction = actions[i];\r\n        const actiontype = action.type.indexOf('@@') === 0 ? 'redux' : action.type;\r\n        console.log('executing action:', {a:action, t:actiontype, field: action.field, v:action.value}); //, count: ++action.executionCount});\r\n\r\n        switch (actiontype) {\r\n            /*\r\n            case '@@redux/INIT6.x.f.d.r.e':\r\n            case '@@redux/INITm.f.1.s.o.g':\r\n            case '@@redux/INIT5.t.4.v.d.o':\r\n            case '@@redux/INITy.a.d.r.l.a':\r\n            case '@@redux/INIT4.2.q.u.z.k':\r\n            case '@@redux/INITj.8.e.g.y.p':\r\n            case '@@redux/INITp.k.q.g.z.w':\r\n            case '@@redux/INITq.c.u.w.f.e': ... etc*/\r\n            default:\r\n                if (action.type.indexOf('@@redux/') === 0) break;\r\n                return Log.exDevv('unexpected action type:', action.type);\r\n            case LoadAction.type: newState = action.value; break;\r\n            case CreateElementAction.type:\r\n            case SetRootFieldAction.type:\r\n            case DeleteElementAction.type:\r\n            case SetFieldAction.type:\r\n                let tmp: false | DState = deepCopyButOnlyFollowingPath(newState, action, prevAction, action.value);\r\n                if (!tmp) return oldState; // rollback due to invalid action in transaction\r\n                newState = tmp;\r\n                break;\r\n        }\r\n\r\n        // and that's all, the reducer is really simple as actions are really simple.\r\n    }\r\n\r\n    // effetti collaterali, aggiornamento di ridondanze\r\n    newState = updateRedundancies_OBSOLETE(newState, oldState, Action.possibleInconsistencies);\r\n    return newState;\r\n}\r\n\r\nfunction updateRedundancies_OBSOLETE(state: DState, oldState:DState, possibleInconsistencies: Dictionary<DocString<'subtype'>, (Pointer | DPointerTargetable)[]>): DState {\r\n    for (let subType in possibleInconsistencies)\r\n    switch (subType) {\r\n        default: break;\r\n        case Action.SubType.vertexSubElements:/*\r\n            risolto triggrerando più azioni da LGraphElement setter\r\n            let dvertexid: Pointer, newdvertex: DGraphElement, olddvertex: DGraphElement;\r\n            for (newdvertex of possibleInconsistencies[subType] as DGraphElement[]){\r\n                const olddvertex: DGraphElement = oldState.idlookup[newdvertex.id] as DGraphElement;\r\n                const notContainedAnymoreOut: Pointer<DGraphElement> = [];\r\n                const newlyInsertedOut: Pointer<DGraphElement>[] = [];\r\n                U.arraySymmetricDifference(olddvertex.subElements, newdvertex.subElements, notContainedAnymoreOut, newlyInsertedOut);\r\n                for (let geid of notContainedAnymoreOut) {\r\n                    const oldge = oldState.idlookup[geid] as DGraphElement;\r\n                    const newge = state.idlookup[geid] as DGraphElement;\r\n                    if (oldge.containedIn === newge.containedIn) continue;\r\n                }\r\n                for (let geid of notContainedAnymoreOut) {\r\n                    const ge = idlookup[geid] as DGraphElement;\r\n                    if (ge.containedIn === context.data.id) set container = context.data.id\r\n                    meglio se sti 2 cicli li fai nel reducer perchè  potrebbe esserci una azione pending che setta il parent = someotherid e qui faccio partire una azione che setta il parent a null, \"annullando\" una azione pending non ancora eseguita\r\n                }\r\n            }\r\n            break;*/\r\n    }\r\n    // if state is updated shallow copy state before returning it\r\n    return state;\r\n}\r\n\r\nlet initialState: DState = null as any;\r\nlet storeLoaded: boolean = false;\r\n\r\nconst UDRegexp = /(?:^|\\s|;|}|\\n|\\t|\\(|,)ret\\s*\\.\\s*[a-zA-Z_$][0-9a-zA-Z_$]*\\s*=/g;\r\n/* tested with:\r\nif (ret.key = stuff) ret.key2=morestuff;\r\n;ret.k=3;\r\n}ret. kk=3,ret. a = 3\r\n\r\nret .b = 3\r\n*/\r\n\r\n\r\n// then add to it: content of props, constants, usageDeclarations\r\n\r\nexport function reducer(oldState: DState = initialState, action: Action): DState {\r\n    try{ return unsafereducer(oldState, action); }\r\n    catch(e) {\r\n        console.error('unhandled error in reducer', {oldState, action});\r\n        return oldState;\r\n    }\r\n}\r\n\r\nfunction unsafereducer(oldState: DState = initialState, action: Action): DState {\r\n    const ret = _reducer(oldState, action);\r\n    if (ret === oldState) return oldState;\r\n    ret.idlookup.__proto__ = DPointerTargetable.pendingCreation as any;\r\n\r\n    // client synchronization stuff\r\n    if (oldState?.collaborativeSession) {\r\n        const ignoredFields: (keyof DState)[]  = ['contextMenu', '_lastSelected', 'isLoading', 'collaborativeSession'];\r\n        /* Checking if CompositeAction has some actions that MUST be ignored */\r\n        let compositeAction: CompositeAction|null = null;\r\n        if(action.type === CompositeAction.type) {\r\n            compositeAction = action as CompositeAction;\r\n            const subActions = compositeAction.actions || [];\r\n            compositeAction.actions = subActions.filter(a => !ignoredFields.includes(a.field as keyof DState));\r\n        }\r\n        if(compositeAction && !compositeAction.actions.length) return ret;\r\n        action = (compositeAction) ? compositeAction : action;\r\n        if(action.sender === DUser.current && !ignoredFields.includes(action.field as keyof DState)) {\r\n            const parsedAction: JSON & GObject = JSON.parse(JSON.stringify(action));\r\n            Collaborative.client.emit('pushAction', parsedAction);\r\n        }\r\n    }\r\n\r\n    if (ret.VIEWS_RECOMPILE_all === true) ret.VIEWS_RECOMPILE_all = Object.keys(ret.idlookup);\r\n    if ((ret.VIEWS_RECOMPILE_all as Pointer[])?.length) {\r\n        let resetAllNodes: boolean = false;\r\n        for (let id of new Set(ret.VIEWS_RECOMPILE_all as Pointer[])){\r\n            let d = ret.idlookup[id];\r\n            if (RuntimeAccessibleClass.extends(d.className, \"DViewElement\")) {\r\n                (d as DViewElement).css_MUST_RECOMPILE = true;\r\n                transientProperties.view[d.id as string] = { } as any;\r\n                for (let k of DViewElement.MeasurableKeys) (ret as any)['VIEWS_RECOMPILE_'+k].push(d.id);\r\n                if (!resetAllNodes) resetAllNodes = true;\r\n            }\r\n            if (RuntimeAccessibleClass.extends(d.className, \"DModelElement\")) {\r\n                if (d.className === \"DClass\") {\r\n                    let oldname = (oldState.idlookup[d.id] as DClass)?.name;\r\n                    let newname = (ret.idlookup[d.id] as DClass)?.name;\r\n                    if (oldname !== newname) ret.ClassNameChanged[d.id as Pointer<DClass>] = oldname;\r\n                }\r\n                // transientProperties.modelElement[d.id] = { } as any; stuff in here does not need replacement, can never be dangerous.\r\n            }\r\n            if (RuntimeAccessibleClass.extends(d.className, \"DGraphElement\")) {\r\n                transientProperties.node[d.id as string] = { } as any;\r\n            }\r\n        }\r\n        if (resetAllNodes) for (let nid in transientProperties.node) transientProperties.node[nid] = {} as any;\r\n    }\r\n\r\n    // local changes to out-of-redux stuff\r\n    if (ret.VIEWS_RECOMPILE_ocl.length) {\r\n        // for (let gid of ret.graphs) Selectors.updateViewMatchings(gid, ret.modelElements, Object.values(ret.idlookup).map( d => RuntimeAccessibleClass.extends(d, DModelElement.cname)));\r\n        // for (let vid of ret.VIEW_APPLIABLETO_NEEDS_RECALCULATION) { }\r\n        for (let vid of new Set(ret.VIEWS_RECOMPILE_ocl)) {\r\n            if (!transientProperties.view[vid]) transientProperties.view[vid] = {} as any;\r\n            transientProperties.view[vid].oclEngine = undefined as any; // force re-parse\r\n            transientProperties.view[vid].oclChanged = true;\r\n            for (let nid in transientProperties.node) {\r\n                let tnv = transientProperties.node[nid].viewScores[vid];\r\n                if (tnv?.OCLScore !== ViewEClassMatch.NOT_EVALUATED_YET) tnv.OCLScore = ViewEClassMatch.NOT_EVALUATED_YET as any as boolean;\r\n            }\r\n        }\r\n        ret.VIEWS_RECOMPILE_ocl = [];\r\n    }\r\n    /*\r\n    if (ret.VIEWOCL_UPDATE_NEEDS_RECALCULATION.length) {\r\n        // not implemented for now\r\n        ret.VIEWOCL_UPDATE_NEEDS_RECALCULATION = [];\r\n    }*/\r\n\r\n    if (ret.VIEWS_RECOMPILE_preconditions.length) {\r\n        for (let vid of new Set(ret.VIEWS_RECOMPILE_preconditions)) {\r\n            for (let nid in transientProperties.node) {\r\n                let tnv = transientProperties.node[nid].viewScores[vid];\r\n                if (tnv?.metaclassScore !== ViewEClassMatch.NOT_EVALUATED_YET) tnv.metaclassScore = ViewEClassMatch.NOT_EVALUATED_YET as any as number;\r\n            }\r\n        }\r\n        ret.VIEWS_RECOMPILE_preconditions = [];\r\n    }\r\n\r\n    if (ret.VIEWS_RECOMPILE_constants?.length)\r\n    for (const vid of new Set(ret.VIEWS_RECOMPILE_constants)) { // compiled in func, and executed, result does not vary between nodes.\r\n        let dv: DViewElement = DPointerTargetable.fromPointer(vid, ret);\r\n        // transientProperties.view[vid].constantsList = dv.constants?.match(UDRegexp).map(s=>s.substring(4, s.length-1).trim()) || [];\r\n        // let allContextKeys = {...contextFixedKeys};\r\n        if (!dv.constants) {\r\n            if (!transientProperties.view[vid]) transientProperties.view[vid] = {} as any;\r\n            transientProperties.view[vid].constants = {};\r\n            transientProperties.view[vid].constantsList = [];\r\n            // no need to recompile UD, jsx or measurables, they will have additional parameters in scope but they are undefined and cause no problems.\r\n            continue;\r\n        }\r\n        const constantsOutput: GObject = {};\r\n        const context = {view:dv}; // context at this point holds only static stuff, which are in gloval scope (window) plus view.\r\n        let paramStr = '{'+Object.keys(context).join(',')+'}, ret';\r\n        try {\r\n            // the scope of new Function() is \"window\" and not the function where is called, unlike eval();\r\n            let constantsFunction: (context: GObject, ret: GObject) => void = new Function(paramStr, 'return ('+dv.constants+')(ret)').bind(context);\r\n            constantsFunction(context, constantsOutput);\r\n        } catch(e:any){\r\n            console.error('error constants parse', {vid, e, paramStr, body:'return ('+dv.constants+')(ret)'});\r\n            // todo: how do i render an error from here? even if i set jsx or ud.__invalidDeclarations it will be recompiled. need a constants.__invalidDeclarations too?\r\n        }\r\n\r\n        transientProperties.view[vid].constants = constantsOutput;\r\n        transientProperties.view[vid].constantsList = Object.keys(transientProperties.view[vid].constants);\r\n        // implies recompilation of: jsCondition, ud, jsx and all measurable events\r\n        ret.VIEWS_RECOMPILE_jsCondition.push(vid);\r\n        ret.VIEWS_RECOMPILE_usageDeclarations.push(vid);\r\n        ret.VIEWS_RECOMPILE_jsxString.push(vid);\r\n        ret.VIEWS_RECOMPILE_events.push(vid);\r\n        for (let k of DViewElement.MeasurableKeys) (ret as any)['VIEWS_RECOMPILE_'+k].push(vid);\r\n    }\r\n    ret.VIEWS_RECOMPILE_constants = [];\r\n\r\n    if (ret.VIEWS_RECOMPILE_usageDeclarations?.length)\r\n    for (const vid of new Set(ret.VIEWS_RECOMPILE_usageDeclarations)) { // compiled in func, but NOT executed, result varies between nodes.\r\n        let dv: DViewElement = DPointerTargetable.fromPointer(vid, ret);\r\n        let tv = transientProperties.view[vid];\r\n        if (!tv) transientProperties.view[vid] = tv = {} as any;\r\n        if (!dv.usageDeclarations) {\r\n            tv.UDList = [];\r\n            tv.UDFunction = undefined as any;\r\n            // no need to recompile jsx or measurables, they will have additional parameters in scope but they are undefined and cause no problems.\r\n            continue;\r\n        }\r\n        let matches = dv.usageDeclarations?.match(UDRegexp) || [];\r\n        transientProperties.view[vid].UDList = matches.map(s=>{ s = s.trim(); return s.substring(s.indexOf('\\.')+1, s.length-2).trim()});\r\n        console.log('matches', {matches, udlist:transientProperties.view[vid].UDList});\r\n        // warning for user: do not redeclare ret in nested blocks.\r\n        // do not use ret[key] syntax.\r\n        // do not set nested values directly (ret.key.subkey syntax).\r\n        // do not use ret.key +=, -= or any other operator assignment different than \"=\"\r\n        // if that is ever required, do instead\r\n        // do not assign values to ret in block comments\r\n        // those restrictions only apply to the ret object, all those violations can be done on other objects.\r\n        // so the following is valid, and a way to overcome the previous limitations:\r\n        // let subobject = {}; subobject[key] += stuff; ret.somefixedname = subobject;\r\n\r\n        let allContextKeys: Dictionary = {...contextFixedKeys};\r\n        for (let k of tv.constantsList) if (!allContextKeys[k]) allContextKeys[k] = true;\r\n        let paramStr = '{'+Object.keys(allContextKeys).join(',')+'}, ret';\r\n        if (vid.includes('Model')) console.log(\"modelparse, ud\", {paramStr, udstr:dv.usageDeclarations, udlist:transientProperties.view[vid].UDList});\r\n        try {\r\n            tv.UDFunction = new Function(paramStr, 'return ('+dv.usageDeclarations+')(ret)') as (...a:any)=>any;\r\n        } catch (e:any) {\r\n            let strerr = JSON.stringify((e.message || '').split('\\n')[0]);\r\n            let errbody = \"ret.__invalidUsageDeclarations = \"+strerr+\"; ret.__invalidUsageDeclarations.isSyntax = true; return ret;\"\r\n            console.error('error udparse', {vid, e, paramStr, body: 'return ('+dv.usageDeclarations+')(ret)', strerr, errbody});\r\n            tv.UDFunction = new Function(\"ret\", errbody) as (...a:any)=>any;\r\n        }\r\n\r\n\r\n        // implies recompilation of: jsx and all measurable events\r\n        ret.VIEWS_RECOMPILE_jsxString.push(vid);\r\n        ret.VIEWS_RECOMPILE_events.push(vid);\r\n        for (let k of DViewElement.MeasurableKeys) (ret as any)['VIEWS_RECOMPILE_'+k].push(vid);\r\n    }\r\n    ret.VIEWS_RECOMPILE_usageDeclarations = [];\r\n\r\n    if (ret.VIEWS_RECOMPILE_events.length) {\r\n        // for (let gid of ret.graphs) Selectors.updateViewMatchings(gid, ret.modelElements, Object.values(ret.idlookup).map( d => RuntimeAccessibleClass.extends(d, DModelElement.cname)));\r\n        // for (let vid of ret.VIEW_APPLIABLETO_NEEDS_RECALCULATION) { }\r\n        for (let entry of new Set(ret.VIEWS_RECOMPILE_events)) {\r\n            let vid: string;\r\n            let dv: DViewElement;\r\n            let keys: string[];\r\n            if (typeof entry === \"object\") {\r\n                vid = entry.vid;\r\n                dv = DPointerTargetable.fromPointer(vid, ret);\r\n                keys = entry.keys || Object.keys(dv.events);\r\n            }\r\n            else {\r\n                vid = entry;\r\n                dv = DPointerTargetable.fromPointer(vid, ret);\r\n                keys = Object.keys(dv.events);\r\n            }\r\n            let tv = transientProperties.view[vid];\r\n            if (!tv) transientProperties.view[vid] = tv = {} as any;\r\n            if (!tv.events) tv.events = {};\r\n            // if (!tv.events_raw) tv.events_raw = {};\r\n            for (let key of keys) {\r\n                if (!key) { delete tv.events[key]; continue; }\r\n                let allContextKeys = {...contextFixedKeys};\r\n                for (let k of transientProperties.view[vid].constantsList) if (!allContextKeys[k]) allContextKeys[k] = true;\r\n                for (let k of transientProperties.view[vid].UDList) if (!allContextKeys[k]) allContextKeys[k] = true;\r\n                let paramStr = '{'+Object.keys(allContextKeys).join(',')+'}, ..._params';\r\n                // dv.events[key] = (...params)=> code\r\n                const body: string = 'return (' +dv.events[key]+')(..._params)';\r\n                // if (vid.includes('Model')) console.log(\"modelparse, jsx\", {paramStr, body});\r\n                try {\r\n                    tv.events[key] = new Function(paramStr, body) as ((...a:any[])=>any);\r\n                    // tv.events_raw[key] = new Function(paramStr, body) as ((...a:any)=>any);\r\n                    // attempt to auto obtain node context\r\n                    // impossile with view.event.name\r\n                    // could with node.event.name if node.get_event sets a current node thing__, no he must wrap the func!! in the getter\r\n                    // tv.events[key] = (..._params2:any) => { return tv.events_raw[key](context, ..._params2) };\r\n                }\r\n                catch (e: any) {\r\n                    console.error('error jsxparse', {vid, e, paramStr, body});\r\n                    tv.events[key] = (context) => Log.ee(\"failed to parse function body: \" + e.message.split(\"\\n\")[0], e.message);\r\n                }\r\n            }\r\n        }\r\n        ret.VIEWS_RECOMPILE_events = [];\r\n        // triggers recompile of nothing\r\n    }\r\n\r\n    if (ret.VIEWS_RECOMPILE_jsCondition?.length)\r\n    for (const vid of new Set(ret.VIEWS_RECOMPILE_jsCondition)) {\r\n        const dv: DViewElement = DPointerTargetable.fromPointer(vid, ret);\r\n        let tv = transientProperties.view[vid];\r\n        if (!tv) transientProperties.view[vid] = tv = {} as any;\r\n        tv.jsConditionChanged = true;\r\n        if (!dv.jsCondition) {\r\n            tv.jsCondition = undefined;\r\n            continue;\r\n        }\r\n        const lines = dv.jsCondition.trim().split('\\n');\r\n        let lastLine = lines[lines.length - 1];\r\n        if (lastLine.indexOf('return') !== 0) lines[lines.length - 1] = `return (${lastLine})`;\r\n\r\n\r\n        if (!dv.jsxString) { transientProperties.view[vid].JSXFunction = undefined as any; continue; }\r\n        let allContextKeys = {...contextFixedKeys};\r\n        for (let k of transientProperties.view[vid].constantsList) if (!allContextKeys[k]) allContextKeys[k] = true;\r\n\r\n        let paramStr = '{'+Object.keys(allContextKeys).join(',')+'}';\r\n        const body = lines.join('\\n');\r\n        try {\r\n            tv.jsCondition = new Function(paramStr, body) as ((...a:any)=>any);\r\n        } catch (e) {\r\n            tv.jsCondition = undefined;\r\n            console.log('JS Condition parsed error', e);\r\n        }\r\n    }\r\n    ret.VIEWS_RECOMPILE_jsCondition = [];\r\n\r\n\r\n    if (ret.VIEWS_RECOMPILE_jsxString?.length)\r\n    for (const vid of new Set(ret.VIEWS_RECOMPILE_jsxString)) { // compiled in func, but NOT executed, result varies between nodes.\r\n        let dv: DViewElement = DPointerTargetable.fromPointer(vid, ret);\r\n        let tv = transientProperties.view[vid];\r\n        if (!tv) transientProperties.view[vid] = tv = {} as any;\r\n        if (!dv.jsxString) { transientProperties.view[vid].JSXFunction = undefined as any; continue; }\r\n        let allContextKeys = {...contextFixedKeys};\r\n        for (let k of transientProperties.view[vid].constantsList) if (!allContextKeys[k]) allContextKeys[k] = true;\r\n        for (let k of transientProperties.view[vid].UDList) if (!allContextKeys[k]) allContextKeys[k] = true;\r\n        let paramStr = '{'+Object.keys(allContextKeys).join(',')+'}';\r\n        console.log('jsxparse', { allContextKeys, ud:transientProperties.view[vid].UDList, c:transientProperties.view[vid].constantsList });\r\n        const body: string =  'return (' + UX.parseAndInject(DSL.parser(dv.jsxString), dv) + ')';\r\n        // if (vid.includes('Model')) console.log(\"modelparse, jsx\", {paramStr, body});\r\n        console.log('jsxparse', {vid, paramStr, body});\r\n        try {\r\n            transientProperties.view[vid].JSXFunction = new Function(paramStr, body) as ((...a: any) => any);\r\n        }\r\n        catch (e: any) {\r\n            /*try{\r\n                let try_to_get_better_error = eval(\"let __f = function(\" + paramStr+\") {\\n\" + body + \"}\");\r\n            } catch(eeval){\r\n                console.error(\"eval error same as func error\", {e, eeval});\r\n                e = eeval;\r\n            }*/\r\n            console.error('error jsxparse', {vid, e, paramStr, body});\r\n            transientProperties.view[vid].JSXFunction = (context) => GraphElementComponent.displayError(e, 'JSX Syntax', dv);\r\n        }\r\n        // implies recompilation of: ... nothing?\r\n    }\r\n    ret.VIEWS_RECOMPILE_jsxString = [];\r\n\r\n\r\n\r\n    for (const key of DViewElement.MeasurableKeys) {\r\n        if ((ret as any)['VIEWS_RECOMPILE_'+key]?.length)\r\n        for (let vid of new Set((ret as any)['VIEWS_RECOMPILE_'+key]) as any) {\r\n            let dv: DViewElement = DPointerTargetable.fromPointer(vid, ret);\r\n            let tv = transientProperties.view[vid];\r\n            if (!tv) transientProperties.view[vid] = tv = {} as any;\r\n            let str: string = (dv as any)[key];\r\n            if (!str) {\r\n                (transientProperties.view[vid] as any)[key] = undefined;\r\n                continue;\r\n            }\r\n            let allContextKeys = {...contextFixedKeys};\r\n            for (let k of transientProperties.view[vid].constantsList) if (!allContextKeys[k]) allContextKeys[k] = true;\r\n            for (let k of transientProperties.view[vid].UDList) if (!allContextKeys[k]) allContextKeys[k] = true;\r\n            let paramStr = '{'+Object.keys(allContextKeys).join(',')+'}';\r\n            console.log('measurable parse '+key, {allContextKeys, ud:transientProperties.view[vid].UDList, c:transientProperties.view[vid].constantsList });\r\n            console.log('measurable parse '+key, {vid, paramStr, body:str});\r\n            try {\r\n                (transientProperties.view[vid] as any)[key] = new Function(paramStr, str);\r\n            }\r\n            catch (e: any) {\r\n                console.error('error measurable parse '+key, {vid, e, paramStr, body:str});\r\n                (transientProperties.view[vid] as any)[key] = undefined;\r\n                // display error in jsx\r\n                transientProperties.view[vid].JSXFunction = (context) => GraphElementComponent.displayError(e, 'Measurable ' + key + ' Syntax', dv);\r\n                break;\r\n            }\r\n        }\r\n        (ret as any)['VIEWS_RECOMPILE_'+key] = [];\r\n    }\r\n\r\n    for (let dataid in ret.ClassNameChanged) {\r\n        if (dataid === 'clonedCounter') continue;\r\n        // NB: if i ever want to access a constructor's other properties in ocl, like \"context Persona inv: self.$somecounter === Persona.instances.length\",\r\n        // i would need to update this every time a DClass property changes instead of only when name changes.\r\n\r\n        // if it's first creation of a modelpiece\r\n        if (!transientProperties.modelElement[dataid]) {\r\n            transientProperties.modelElement[dataid] = {nodes: {}};\r\n        }\r\n        // update ocl type names\r\n        let data: DClass = ret.idlookup[dataid] as DClass;\r\n        RuntimeAccessibleClass.makeOCLConstructor(data, ret, oldState);\r\n        // here i should reset all tnv.oclEngine too and set all ocl scores to notevaluated, but it is too computationally heavy\r\n        // and it's useful to keep the old ocl condition valid with past names until manually edited.\r\n    }\r\n    ret.ClassNameChanged = {};\r\n\r\n    return ret;\r\n\r\n}\r\n\r\nexport function _reducer/*<S extends StateNoFunc, A extends Action>*/(oldState: DState = initialState, action: Action): DState{\r\n    let times: number;\r\n    let state: DState;\r\n    let removedDeltas: (GObject | undefined)[] = [];\r\n    switch (action.type) {\r\n        case UndoAction.type:\r\n            times = action.value;\r\n            state = oldState;\r\n            Log.exDev(times<=0, \"undo must be positive\", action);\r\n            while (times--) {\r\n                const delta = statehistory[DUser.current].undoable.pop();\r\n                removedDeltas.push(delta);\r\n                state = undo(state, delta);\r\n            }\r\n            state.VIEWS_RECOMPILE_all = removedDeltas.flatMap( d => Object.keys(d?.idlookup||{}));\r\n            // state.VIEWS_RECOMPILE_all = true;\r\n            return state;\r\n\r\n        case RedoAction.type:\r\n            times = action.value;\r\n            state = oldState;\r\n            Log.exDev(times<=0, \"redo must be positive\", action);\r\n            while (times--) {\r\n                const delta = statehistory[DUser.current].redoable.pop();\r\n                removedDeltas.push(delta);\r\n                state = undo(state, delta, false);\r\n            }\r\n            state.VIEWS_RECOMPILE_all = removedDeltas.flatMap( d => Object.keys(d?.idlookup||{}));\r\n            // state.VIEWS_RECOMPILE_all = true;\r\n            return state;\r\n        // case CombineHistoryAction.type: return combineHistory(oldState); break;\r\n        // todo: se al posto di \"annullare l'undo\" memorizzo l'azione e la rieseguo, posso ripetere l'ultimo passo N volte e questa azione diventa utile per combinare passi e ripetere blocchi di azioni assieme\r\n        default:\r\n            let ret = doreducer(oldState, action);\r\n            if (ret === oldState) return ret;\r\n            // statehistory[DUser.current].redoable = [];   <-- Moved to stateInitializer()\r\n            let delta =  U.objectDelta(ret, oldState);\r\n            if (!filterundoableactions(delta)) return ret;\r\n            // console.log(\"setting undoable action:\", {ret, oldState0:{...oldState}, oldState, delta});\r\n            if (oldState !== null) statehistory[DUser.current].undoable.push(delta);\r\n            return ret;\r\n    }\r\n}\r\n\r\nfunction filterundoableactions(delta: Partial<DState>): boolean {\r\n    if (!statehistory.globalcanundostate) return false;\r\n    if (Object.keys(delta).length === 1) {\r\n        if (\"dragging\" in delta) return false;\r\n        if (\"_lastSelected\" in delta) return false;\r\n        if (\"contextMenu\" in delta) return false;\r\n    }\r\n    return true;\r\n}\r\nfunction undo(state: DState, delta: GObject | undefined, isundo = true): DState {\r\n    if (!delta) return state;\r\n    let undonestate: DState = {...state} as DState;\r\n    //   controlla se vengono shallow-copied solo e tutti gli oggetti nested lungo la catena del percorso delle modifiche\r\n    //   es: root.a.b.c=3 + root.a.b.d=3 = 4+1 modifiche, 5 shallow copies including the root\r\n    undorecursive(delta, undonestate);\r\n    if (isundo) statehistory[DUser.current].redoable.push( U.objectDelta(undonestate, state) ); // reverses from undo to redo and viceversa swapping arguments, so the target result after appliying the delta changes\r\n    else statehistory[DUser.current].undoable.push( U.objectDelta(undonestate, state) ); // redo is \"undoing an undo\", reversing his changes just like an undo reverses an ordinary action changes.\r\n    return undonestate;\r\n}\r\n\r\nfunction undorecursive(deltalevel: GObject, statelevel: GObject): void {\r\n    // statelevel = {...statelevel}; not working if i do it here, just a new var. first time copy id done in caller func undo(). recursive copies are done before recursive step\r\n    for (let key in deltalevel) {\r\n        let delta = deltalevel[key];\r\n        console.log(\"undoing\", {delta, key, deltalevel, statelevel})\r\n        if (key.indexOf(\"_-\") === 0) { delete statelevel[key.substring(2)]; continue; }\r\n        if (typeof delta === \"object\") {\r\n        // if (U.isObject(delta, false, false, true)) {\r\n            statelevel[key] = {...statelevel[key]};\r\n            undorecursive(deltalevel[key], statelevel[key]); }\r\n        else { statelevel[key] = delta; }\r\n    }\r\n}\r\n\r\nfunction doreducer/*<S extends StateNoFunc, A extends Action>*/(oldState: DState = initialState, action: Action): DState{\r\n    if (!oldState) { oldState = initialState = DState.new(); }\r\n    let ca: CompositeAction;\r\n    // console.log('external REDUCER', {action, CEtype:CreateElementAction.type});\r\n    if (!storeLoaded) {\r\n        // new SetRootFieldAction('forceinit', true);\r\n        storeLoaded = true;\r\n    }\r\n    if (!(oldState as any).forceinit) {\r\n        // afterStoreLoad();\r\n        // new SetRootFieldAction('forceinit', true);\r\n    } //  setTimeout(afterStoreLoad, 1);\r\n    switch (action.type) {\r\n        case CompositeAction.type: ca = action as CompositeAction; break;\r\n        case LoadAction.type:\r\n        default:\r\n            if (action.type.indexOf('@@redux/') === 0) {\r\n                //storeLoaded = true;\r\n                return oldState;\r\n            }\r\n            ca = new CompositeAction([action], false);\r\n            break;\r\n    }\r\n    let ret = CompositeActionReducer(oldState, ca);\r\n    /*if (state.current !== ret) {\r\n        state.current = ret;\r\n        state.past.push(ret);\r\n    }*/\r\n    return ret;\r\n}\r\nfunction setSubclasses(roots: orArr<typeof RuntimeAccessibleClass>){\r\n    RuntimeAccessibleClass.extendMatrix =\r\n        new SimpleTree<(typeof RuntimeAccessibleClass)>(roots, \"subclasses\")\r\n            .getiIsSubElementMatrix(\"cname\");\r\n    /*\r\n    let tree = new TreeModel({\r\n        childrenPropertyName: \"subclasses\"\r\n    });\r\n    for (let key in dict){\r\n        let constructor = dict[key];\r\n        if(!constructor.hasOwnProperty(\"subclasses\")) constructor.subclasses = [];\r\n    }\r\n    RuntimeAccessibleClass.extendTree = (tree as any).safe_parse(RuntimeAccessibleClass);*/\r\n}\r\n// windoww.TreeModel = TreeModel;\r\nfunction buildLSingletons(alld: Dictionary<string, typeof DPointerTargetable>, alll: Dictionary<string, typeof LPointerTargetable>) {\r\n    for (let dname in alld) {\r\n        switch (dname) {\r\n            case \"DeleteElementAction\": continue;\r\n            case \"DV\": continue;\r\n            case \"Debug\": continue;\r\n            default: break;\r\n        }\r\n        if ((dname[1] || \"\").toLowerCase() === dname[1]) continue; // if second letter is lowercase, it's not a \"D\" class\r\n        let tagless = dname.substring(1);\r\n        let d = alld[dname];\r\n        let l = alll['L'+tagless];\r\n        if (!d||!l) console.error(\"missing d constructor\", {d, l});\r\n        d.logic = l;\r\n        if (!l) console.error('init() could not find L-class during mapping', l, d);\r\n        // @ts-ignore\r\n        d.singleton = new l('dwc');\r\n        d.structure = d;\r\n\r\n        l.logic = d.logic;\r\n        l.singleton = d.singleton;\r\n        l.structure = d.structure;\r\n\r\n        // if (!d.subclasses) d.subclasses = [];\r\n        // @ts-ignore\r\n        // for (let sc of d.subclasses) { if (!sc[\"_extends\"]) sc[\"_extends\"] = [];  sc[\"_extends\"].push(d); }\r\n    }\r\n}\r\n\r\nexport async function stateInitializer() {\r\n    statehistory[DUser.current] = {redoable: [], undoable: []};\r\n    RuntimeAccessibleClass.fixStatics();\r\n    let dClassesMap: Dictionary<string, typeof DPointerTargetable> = {};\r\n    let lClassesMap: Dictionary<string, typeof LPointerTargetable> = {};\r\n    for (let name in RuntimeAccessibleClass.classes) {\r\n        switch(name[0]) {\r\n            default: break;\r\n            case \"D\": dClassesMap[name] = RuntimeAccessibleClass.classes[name] as typeof DPointerTargetable; break;\r\n            case \"L\": lClassesMap[name] = RuntimeAccessibleClass.classes[name] as typeof LPointerTargetable; break;\r\n        }\r\n    }\r\n    /*\r\n    let dClasses: string[] = RuntimeAccessibleClass.getAllNames().filter(rc => rc[0] === 'D');\r\n    let lClasses: string[] = RuntimeAccessibleClass.getAllNames().filter(rc => rc[0] === 'L');\r\n    let dClassesMap: Dictionary<string, typeof DPointerTargetable> =\r\n        dClasses.reduce((acc: GObject, curr) => {acc[curr] = RuntimeAccessibleClass.get(curr); return acc}, {});\r\n    let lClassesMap: Dictionary<string, typeof LPointerTargetable> =\r\n        lClasses.reduce((acc: GObject, curr) => {acc[curr] = RuntimeAccessibleClass.get(curr); return acc}, {}); */\r\n\r\n    buildLSingletons(dClassesMap, lClassesMap);\r\n    setSubclasses(RuntimeAccessibleClass.get(\"DPointerTargetable\"));// setSubclasses(lClassesMap);\r\n    windoww.defaultContext = {$: windoww.$, getPath, React: React, Selectors, ...RuntimeAccessibleClass.getAllClassesDictionary(), ...windoww.Components};\r\n    // global document events\r\n\r\n    // do not use typings or class constructors here or it will change import order\r\n    setTimeout(\r\n        ()=> $(document).on(\"mouseup\",\r\n            (e: MouseUpEvent) => RuntimeAccessibleClass.get<typeof GraphDragManager>(\"GraphDragManager\").stopPanning(e)),\r\n        // ()=> $(document).on(\"mouseup\", (e: MouseUpEvent) => (window as any).GraphDragManager.stopPanning(e)), //a\r\n        1\r\n    );\r\n    DState.init();\r\n    const user = Storage.read<DUser>('user');\r\n    if(!user) return;\r\n    DUser.new(user.username, user.id);\r\n    DUser.current = user.id;\r\n    await ProjectsApi.getAll();\r\n}\r\n"],"mappings":"qwBAAA,OAMIA,YAAY,CAGZC,EAAE,CAAgCC,qBAAqB,CAAEC,eAAe,KACrE,cAAc,CACrB,OACIC,MAAM,CACNC,eAAe,CACfC,mBAAmB,CACnBC,mBAAmB,CAGnBC,kBAAkB,CAClBC,MAAM,CACNC,KAAK,CACLC,OAAO,CAEPC,GAAG,CAEHC,OAAO,CAEPC,qBAAqB,CACrBC,SAAS,CAETC,QAAQ,CACRC,sBAAsB,CACtBC,cAAc,CACdC,kBAAkB,CAClBC,YAAY,KACT,cAAc,CACrB,MAAO,CAAAC,KAAK,KAAM,OAAO,CACzB,OAAQC,UAAU,CAAEC,UAAU,CAAEC,UAAU,KAAO,kBAAkB,CACnE,MAAO,CAAAC,aAAa,KAAM,8CAA8C,CACxE,OAAQC,UAAU,KAAO,yBAAyB,CAClD,OAAQC,mBAAmB,CAAEC,SAAS,KAAO,cAAc,CAE3D,OAASC,gBAAgB,KAAQ,kDAAkD,CACnF,MAAO,CAAAC,OAAO,KAAM,oBAAoB,CACxC,OAAQC,WAAW,KAAO,uBAAuB,CACjD,MAAO,CAAAC,GAAG,KAAM,eAAe,CAE/B,GAAI,CAAAC,OAAO,CAAGC,MAAa,CAC3B,GAAI,CAAAC,CAAe,CAAGF,OAAO,CAACE,CAAC,CAG/B,QAAS,CAAAC,4BAA4BA,CAACC,mBAA2B,CAAEC,MAAoB,CAAEC,UAAwB,CAAEC,MAAW,CAAiB,KAAAC,YAAA,CAC3I,GAAI,CAAAC,OAAe,CAAAC,aAAA,IAAON,mBAAmB,CAAW,CACxD,GAAI,CAAAO,OAAY,CAAGF,OAAO,CAC1B,GAAI,GAAAD,YAAA,CAACH,MAAM,CAACO,IAAI,UAAAJ,YAAA,iBAAXA,YAAA,CAAaK,MAAM,EAAE,KAAM,IAAI,CAAAjC,OAAO,CAAC,gCAAgC,CAAE,CAACyB,MAAM,CAANA,MAAM,CAAC,CAAC,CACvF,GAAI,CAAAS,UAAmB,CAAG,KAAK,CAAE;AACjC,GAAI,CAAAC,0BAA0B,CAAG,KAAK,CAAE;AACxC;AACA,IAAK,GAAI,CAAAC,CAAC,CAAG,CAAC,CAAEA,CAAC,CAAGX,MAAM,CAACY,SAAS,CAACJ,MAAM,CAAEG,CAAC,EAAE,CAAE,CAC9C,GAAI,CAAAE,GAAG,CAAGb,MAAM,CAACY,SAAS,CAACD,CAAC,CAAC,CAACG,IAAI,CAAC,CAAC,CACpC,GAAI,CAAAC,iBAAiB,CAAGd,UAAU,SAAVA,UAAU,iBAAVA,UAAU,CAAEW,SAAS,CAACD,CAAC,CAAC,CAChD;AACA;AACA,GAAIA,CAAC,GAAKX,MAAM,CAACY,SAAS,CAACJ,MAAM,CAAG,CAAC,CAAE,CACnC,GAAIE,0BAA0B,EAAIG,GAAG,GAAKE,iBAAiB,CAAE,CACzD;AACAL,0BAA0B,CAAG,IAAI,CACjCJ,OAAO,CAACO,GAAG,CAAC,CAAGG,KAAK,CAACC,OAAO,CAACX,OAAO,CAACO,GAAG,CAAC,CAAC,CAAAK,kBAAA,CAAOZ,OAAO,CAACO,GAAG,CAAC,EAAAR,aAAA,IAAQC,OAAO,CAACO,GAAG,CAAC,CAAC,CAClFP,OAAO,CAACO,GAAG,CAAC,CAACM,aAAa,CAAG,CAAC,EAAIb,OAAO,CAACO,GAAG,CAAC,CAACM,aAAa,EAAI,CAAC,CAAC,CACtE,CACAb,OAAO,CAAGA,OAAO,CAACO,GAAG,CAAC,CACtB,SACJ,CACA;AACA;AACA;AACA,GAAIF,CAAC,EAAIX,MAAM,CAACY,SAAS,CAACJ,MAAM,CAAG,CAAC,CAAE,CAClC,GAAI,CAAAY,aAAa,CAAG,KAAK,CACzB,GAAI,CAAAC,aAAa,CAAG,KAAK,CACzB,GAAI,CAAAC,aAAa,CAAG,KAAK,CACzB,GAAI,CAAAC,kBAAkB,CAAG,KAAK,CAC9B;AACA;AAEA,GAAI,CAAAC,QAAa,QACjB,GAAI3B,CAAC,CAAC4B,QAAQ,CAACZ,GAAG,CAAE,CAAC,IAAI,CAAE,IAAI,CAAC,CAAC,CAAE,CAC/BA,GAAG,CAAGA,GAAG,CAACa,MAAM,CAAC,CAAC,CAAEb,GAAG,CAACL,MAAM,CAAG,CAAC,CAAC,CAACM,IAAI,CAAC,CAAC,CAC1CU,QAAQ,CAAGlB,OAAO,CAACO,GAAG,CAAC,CACvB,OAAQ,MAAO,CAAAW,QAAQ,EACnB,IAAK,QAAQ,CACb,GAAIR,KAAK,CAACC,OAAO,CAACO,QAAQ,CAAC,CAAEJ,aAAa,CAAG,IAAI,CAAC,IAC7C,CAAAE,aAAa,CAAG,IAAI,CACzB,MACA,QAASpB,MAAM,EAAIsB,QAAQ,CAAE,MACjC,CACJ,CACA,GAAI3B,CAAC,CAAC4B,QAAQ,CAACZ,GAAG,CAAE,CAAC,IAAI,CAAC,CAAC,CAAE,CACzBA,GAAG,CAAGA,GAAG,CAACa,MAAM,CAAC,CAAC,CAAEb,GAAG,CAACL,MAAM,CAAG,CAAC,CAAC,CAACM,IAAI,CAAC,CAAC,CAC1CU,QAAQ,CAAGlB,OAAO,CAACO,GAAG,CAAC,CACvB,OAAQ,MAAO,CAAAW,QAAQ,EACnB,IAAK,QAAQ,CACT,GAAIR,KAAK,CAACC,OAAO,CAACO,QAAQ,CAAC,CAAEH,aAAa,CAAG,IAAI,CAAC,IAC7C,CAAAE,kBAAkB,CAAG,IAAI,CAC9B,MACJ,IAAK,QAAQ,CACTrB,MAAM,CAAGL,CAAC,CAAC8B,UAAU,CAACH,QAAQ,CAAEtB,MAAM,CAAE,EAAE,CAAC,CAC3C,MACJ,QAASA,MAAM,EAAIsB,QAAQ,CAAE,MACjC,CACAH,aAAa,CAAG,IAAI,CAAE,CAE1B;AACA;AACA,GAAIrB,MAAM,CAAC4B,IAAI,GAAK5D,mBAAmB,CAAC4D,IAAI,EAAItB,OAAO,CAACO,GAAG,CAAC,CAAE,CAC1DW,QAAQ,CAAGlB,OAAO,CAACO,GAAG,CAAC,CACvBJ,UAAU,CAAG,KAAK,CAClBnC,GAAG,CAACuD,EAAE,CAAC,mDAAmD,CAAE,CAAC7B,MAAM,CAANA,MAAM,CAC/D8B,gBAAgB,CAAExB,OAAO,CAACO,GAAG,CAAC,CAAEkB,cAAc,CAAEzB,OAAO,CAACO,GAAG,CAAC,GAAKb,MAAM,CAACgC,KAAM,CAAC,CAAC,CACpF,MAAO,MAAK,CAAE;AAClB,CACA,GAAIV,aAAa,CAAE,CACf,GAAI,MAAO,CAAApB,MAAM,GAAK,QAAQ,CAAE,CAAE,GAAI,CAAA+B,GAAQ,CAAG,CAAC,CAAC,CAAEA,GAAG,CAAC/B,MAAM,CAAC,CAAG,IAAI,CAAEA,MAAM,CAAG+B,GAAG,CAAE,CACvFT,QAAQ,CAAAnB,aAAA,IAAOC,OAAO,CAACO,GAAG,CAAC,CAAC,CAC5BP,OAAO,CAACO,GAAG,CAAC,CAAAR,aAAA,IAAOC,OAAO,CAACO,GAAG,CAAC,CAAC,CAChC,IAAK,GAAI,CAAAqB,MAAM,GAAI,CAAAhC,MAAM,CAAE,CACvB;AACA,GAAII,OAAO,CAACO,GAAG,CAAC,CAACqB,MAAM,CAAC,GAAKhC,MAAM,CAACgC,MAAM,CAAC,CAAE,SAC7C5B,OAAO,CAACO,GAAG,CAAC,CAACqB,MAAM,CAAC,CAAGhC,MAAM,CAACgC,MAAM,CAAC,CACrCzB,UAAU,CAAG,IAAI,CACjB,GAAIT,MAAM,CAACmC,SAAS,CAAE,CAAE/B,OAAO,CAAG3B,SAAS,CAAC2D,GAAG,CAACvB,GAAG,CAAab,MAAM,CAAEI,OAAO,CAAE,IAAI,CAAC,CAAE,CAC5F,CACJ,CAAC,IACD,IAAImB,kBAAkB,CAAE,CACpB,GAAI,MAAO,CAAArB,MAAM,GAAK,QAAQ,CAAE,CAAE,GAAI,CAAA+B,IAAQ,CAAG,CAAC,CAAC,CAAEA,IAAG,CAAC/B,MAAM,CAAC,CAAG,IAAI,CAAEA,MAAM,CAAG+B,IAAG,CAAE,CACvFT,QAAQ,CAAAnB,aAAA,IAAOC,OAAO,CAACO,GAAG,CAAC,CAAC,CAC5BP,OAAO,CAACO,GAAG,CAAC,CAAAR,aAAA,IAAOC,OAAO,CAACO,GAAG,CAAC,CAAC,CAChC,IAAK,GAAI,CAAAqB,OAAM,GAAI,CAAAhC,MAAM,CAAE,CACvB,GAAI,EAAEgC,OAAM,GAAI,CAAA5B,OAAO,CAACO,GAAG,CAAC,CAAC,CAAE,SAC/B,MAAO,CAAAP,OAAO,CAACO,GAAG,CAAC,CAACqB,OAAM,CAAC,CAC3BzB,UAAU,CAAG,IAAI,CACjB,GAAIT,MAAM,CAACmC,SAAS,CAAE,CAAE/B,OAAO,CAAG3B,SAAS,CAAC2D,GAAG,CAACvB,GAAG,CAAab,MAAM,CAAEI,OAAO,CAAE,IAAI,CAAC,CAAE,CAC5F,CACJ,CAAC,IACD,IAAIgB,aAAa,CAAE,CACfX,UAAU,CAAG,IAAI,CACjB,GAAI,CAACO,KAAK,CAACC,OAAO,CAACX,OAAO,CAACO,GAAG,CAAC,CAAC,CAAE,CAAEP,OAAO,CAACO,GAAG,CAAC,CAAG,EAAE,CAAE,CACvDW,QAAQ,CAAAN,kBAAA,CAAOZ,OAAO,CAACO,GAAG,CAAC,CAAC,CAC5BP,OAAO,CAACO,GAAG,CAAC,CAAAK,kBAAA,CAAOZ,OAAO,CAACO,GAAG,CAAC,CAAC,CAChCP,OAAO,CAACO,GAAG,CAAC,CAACwB,IAAI,CAACnC,MAAM,CAAC,CACzB;AACA,GAAIF,MAAM,CAACmC,SAAS,CAAE,CAAE/B,OAAO,CAAG3B,SAAS,CAAC2D,GAAG,CAAClC,MAAM,CAAaF,MAAM,CAAEI,OAAO,CAAE,IAAI,CAAC,CAAE,CAC/F,CAAC,IACD,IAAIiB,aAAa,CAAE,CACf,GAAI,CAACL,KAAK,CAACC,OAAO,CAACX,OAAO,CAACO,GAAG,CAAC,CAAC,CAAE,CAAEP,OAAO,CAACO,GAAG,CAAC,CAAG,EAAE,CAAE,CACvDW,QAAQ,CAAAN,kBAAA,CAAOZ,OAAO,CAACO,GAAG,CAAC,CAAC,CAC5B,GAAI,CAAAyB,KAAa,QACjB,GAAIzC,CAAC,CAAC0C,QAAQ,CAACrC,MAAM,CAAC,CAAE,CAAE;AACtBoC,KAAK,CAAGpC,MAAM,CACd,GAAIoC,KAAK,CAAG,CAAC,CAAEA,KAAK,CAAGd,QAAQ,CAAChB,MAAM,CAAG8B,KAAK,CAAE;AACpD,CAAC,IACD,IAAIpC,MAAM,GAAKsC,SAAS,CAAE,CACtBF,KAAK,CAAGd,QAAQ,CAAChB,MAAM,CAAG,CAAC,CAC/B,CAAC,IACI,CACD8B,KAAK,CAAGd,QAAQ,CAACiB,OAAO,CAACvC,MAAM,CAAC,CACpC,CACA;AACAO,UAAU,CAAG6B,KAAK,EAAI,CAAC,EAAIA,KAAK,CAAGhC,OAAO,CAACO,GAAG,CAAC,CAACL,MAAM,CACtD,GAAIC,UAAU,CAAE,CACZH,OAAO,CAACO,GAAG,CAAC,CAAAK,kBAAA,CAAOZ,OAAO,CAACO,GAAG,CAAC,CAAC,CAChC,GAAI,CAAA6B,UAAU,CAAGpC,OAAO,CAACO,GAAG,CAAC,CAAC8B,MAAM,CAACL,KAAK,CAAE,CAAC,CAAC,CAAE;AAChD,GAAItC,MAAM,CAACmC,SAAS,CAAE,CAAE/B,OAAO,CAAG3B,SAAS,CAACmE,MAAM,CAACF,UAAU,CAAa1C,MAAM,CAAEI,OAAO,CAAE,IAAI,CAAC,CAAE,CAClG;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBACgB,CACJ,CAAC,IACD,IAAKJ,MAAM,CAAC4B,IAAI,GAAK3D,mBAAmB,CAAC2D,IAAI,EAAI,EAAEf,GAAG,GAAI,CAAAP,OAAO,CAAC,EAAKA,OAAO,CAACO,GAAG,CAAC,GAAKX,MAAM,CAAE,CAC5F;AACAO,UAAU,CAAG,KAAK,CACtB,CAAC,IAAM,CACH;AACA;AACA;AACAe,QAAQ,CAAGlB,OAAO,CAACO,GAAG,CAAC,CACvBJ,UAAU,CAAG,IAAI,CACjB;AACA;AACA;AACA;AACA,GAAKP,MAAM,GAAKsC,SAAS,EAAK,KAAK,EAAIxC,MAAM,CAAC4B,IAAI,GAAK3D,mBAAmB,CAAC2D,IAAI,CAAE,MAAO,CAAAtB,OAAO,CAACO,GAAG,CAAC,CAAC,IAChG,CAAAP,OAAO,CAACO,GAAG,CAAC,CAAGX,MAAM,CAE1B;AACA;AACA;AACA;AACA;AACA,GAAI,IAAI,EAAIF,MAAM,CAACmC,SAAS,CAAE,CAC1B,GAAI,CAAAU,sBAAiC,QACrC,GAAI,CAAAC,sBAAiC,QACrC,GAAI9B,KAAK,CAACC,OAAO,CAACf,MAAM,CAAC,CAAE,CACvB4C,sBAAsB,CAAG5C,MAAM,CAC/B,GAAIc,KAAK,CAACC,OAAO,CAACO,QAAQ,CAAC,CAAE,CAAE;AAC3BqB,sBAAsB,CAAGrB,QAAQ,CACrC,CAAC,IACI,CAAE;AACHqB,sBAAsB,CAAG,CAACrB,QAAQ,CAAC,CACvC,CACJ,CAAC,IACI,CACD;AACAsB,sBAAsB,CAAG,CAAC5C,MAAM,CAAC,CACjC,GAAIc,KAAK,CAACC,OAAO,CAACO,QAAQ,CAAC,CAAE,CACzBqB,sBAAsB,CAAGrB,QAAQ,CACrC,CAAC,IAAM,CACH;AACAqB,sBAAsB,CAAG,CAACrB,QAAQ,CAAC,CACvC,CACJ,CACA;AACA,GAAI,CAAAuB,UAAU,CAAGlD,CAAC,CAACmD,eAAe,CAACH,sBAAsB,CAAEC,sBAAsB,CAAC,CAAE;AAAA,IAAAG,SAAA,CAAAC,0BAAA,CACpEH,UAAU,CAACI,OAAO,EAAAC,KAAA,KAAlC,IAAAH,SAAA,CAAAI,CAAA,KAAAD,KAAA,CAAAH,SAAA,CAAAK,CAAA,IAAAC,IAAA,EAAoC,IAA3B,CAAAC,GAAG,CAAAJ,KAAA,CAAApB,KAAA,CAAyB,GAAItD,QAAQ,CAACyD,SAAS,CAACqB,GAAG,CAAC,CAC5DpD,OAAO,CAAG3B,SAAS,CAACmE,MAAM,CAACY,GAAG,CAAExD,MAAM,CAAEI,OAAO,CAAEoC,SAAS,CAAEzC,mBAAmB,CAAC,CAAE,CAAC,OAAA0D,GAAA,EAAAR,SAAA,CAAAS,CAAA,CAAAD,GAAA,WAAAR,SAAA,CAAAU,CAAA,QAAAC,UAAA,CAAAV,0BAAA,CACvEH,UAAU,CAACc,KAAK,EAAAC,MAAA,KAAhC,IAAAF,UAAA,CAAAP,CAAA,KAAAS,MAAA,CAAAF,UAAA,CAAAN,CAAA,IAAAC,IAAA,EAAkC,IAAzB,CAAAnB,GAAG,CAAA0B,MAAA,CAAA9B,KAAA,CAAwB,GAAItD,QAAQ,CAACyD,SAAS,CAACC,GAAG,CAAC,CAC3DhC,OAAO,CAAG3B,SAAS,CAAC2D,GAAG,CAACA,GAAG,CAAEpC,MAAM,CAAEI,OAAO,CAAEoC,SAAS,CAAEzC,mBAAmB,CAAC,CAAE,CACnF;AACA;AAAA,OAAA0D,GAAA,EAAAG,UAAA,CAAAF,CAAA,CAAAD,GAAA,WAAAG,UAAA,CAAAD,CAAA,IACJ,CACJ,CACA,MACJ,CACArF,GAAG,CAACyF,MAAM,CAAC,gCAAgC,CAAC,CAChD,CACA,MAAO,CAAAtD,UAAU,CAAGL,OAAO,CAAGL,mBAAmB,CACrD,CAGA;AACA,QAAS,CAAAiE,sBAAsBA,CAACC,QAAgB,CAAEC,WAA4B,CAAU,KAAAC,QAAA,CACpF;AACA;AACA,GAAI,CAAAC,OAAuB,CAC3B,GAAIF,WAAW,CAACE,OAAO,CAAEA,OAAO,CAAGtG,MAAM,CAACuG,KAAK,CAACH,WAAW,CAACE,OAAO,CAAC,CAAC,IAChE,CAAAA,OAAO,CAAG,CAACtG,MAAM,CAACuG,KAAK,CAACH,WAAW,CAAC,CAAC,CAAE;AAC5C,GAAI1F,qBAAqB,CAAC8F,GAAG,CAAC9D,MAAM,CAAE,CAAA2D,QAAA,CAAAC,OAAO,EAAC/B,IAAI,CAAAkC,KAAA,CAAAJ,QAAA,CAAAjD,kBAAA,CAAI1C,qBAAqB,CAACgG,mBAAmB,CAACP,QAAQ,CAAC,EAAC,CAAE;AAE5GnG,MAAM,CAAC2G,uBAAuB,CAAG,CAAC,CAAC,CAEnC;AACA,GAAI,CAAAC,cAA8B,CAAG,EAAE,CACvC,GAAI,CAAAC,QAAQ,CAAGV,QAAQ,CAAC,IAAAW,UAAA,CAAA1B,0BAAA,CACLkB,OAAO,EAAAS,MAAA,KAA1B,IAAAD,UAAA,CAAAvB,CAAA,KAAAwB,MAAA,CAAAD,UAAA,CAAAtB,CAAA,IAAAC,IAAA,EAA4B,IAAnB,CAAAvD,OAAM,CAAA6E,MAAA,CAAA7C,KAAA,CACX,OAAQhC,OAAM,CAAC4B,IAAI,EACf,QAAS,MACT,IAAK,CAAA5D,mBAAmB,CAAC4D,IAAI,CACzB,GAAM,CAAAkD,IAAwB,CAAG9E,OAAM,CAACgC,KAAK,CAC7C,MAAO,CAAA9D,kBAAkB,CAAC6G,eAAe,CAACD,IAAI,CAACE,EAAE,CAAC,CAClD;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAEgBF,IAAI,CAACG,SAAS,CAAGH,IAAI,CAACG,SAAS,EAAKH,IAAI,CAACI,WAAW,CAAmCC,KAAK,EAAIL,IAAI,CAACI,WAAW,CAACE,IAAI,CACrH,GAAI,CAAAC,eAAe,CAAGP,IAAI,CAACG,SAAS,CAACK,SAAS,CAAC,CAAC,CAAC,CAACC,WAAW,CAAC,CAAC,CAAG,GAAG,CACrEb,cAAc,CAACrC,IAAI,CACfvE,MAAM,CAACuG,KAAK,CAACxF,kBAAkB,CAAC2G,MAAM,CAACH,eAAe,CAAEP,IAAI,CAACE,EAAE,CAAC,IAAI,CAAE,IAAI,CAAC,CAAC,CAAC,CACjF,GAAI,CAAChE,KAAK,CAACC,OAAO,CAAC6D,IAAI,CAACW,SAAS,CAAC,CAAEX,IAAI,CAACW,SAAS,CAAG,EAAE,CACvDX,IAAI,CAACW,SAAS,CAACpD,IAAI,CAAC5D,SAAS,CAACiH,GAAG,CAACL,eAAe,CAAC,CAAC,CACnD;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBACgB,MACR,CACJ,CACA;AAAA,OAAA5B,GAAA,EAAAmB,UAAA,CAAAlB,CAAA,CAAAD,GAAA,WAAAmB,UAAA,CAAAjB,CAAA,IACAS,OAAO,CAAGvE,CAAC,CAAC8F,iBAAiB,CAAevB,OAAO,CAAEM,cAAc,CAAC,CAEpE;AACAN,OAAO,CAAGA,OAAO,CAACwB,IAAI,CAAE,SAACC,EAAE,CAAEC,EAAE,QAAK,CAAAjG,CAAC,CAACkG,aAAa,CAACF,EAAE,CAACtF,IAAI,CAAEuF,EAAE,CAACvF,IAAI,CAAC,GAAC,CAEtE;AAEA,IAAK,GAAI,CAAAI,CAAC,CAAG,CAAC,CAAEA,CAAC,CAAGyD,OAAO,CAAC5D,MAAM,CAAEG,CAAC,EAAE,CAAE,CACrC,GAAM,CAAAV,UAAwB,CAAGmE,OAAO,CAACzD,CAAC,CAAC,CAAC,CAAC,CAC7C,GAAM,CAAAX,MAAoB,CAAGoE,OAAO,CAACzD,CAAC,CAAC,CACvC,GAAM,CAAAqF,UAAU,CAAGhG,MAAM,CAAC4B,IAAI,CAACa,OAAO,CAAC,IAAI,CAAC,GAAK,CAAC,CAAG,OAAO,CAAGzC,MAAM,CAAC4B,IAAI,CAC1EqE,OAAO,CAACC,GAAG,CAAC,mBAAmB,CAAE,CAACC,CAAC,CAACnG,MAAM,CAAEoG,CAAC,CAACJ,UAAU,CAAEK,KAAK,CAAErG,MAAM,CAACqG,KAAK,CAAEC,CAAC,CAACtG,MAAM,CAACgC,KAAK,CAAC,CAAC,CAAE;AAEjG,OAAQgE,UAAU,EACd;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDACY,QACI,GAAIhG,MAAM,CAAC4B,IAAI,CAACa,OAAO,CAAC,UAAU,CAAC,GAAK,CAAC,CAAE,MAC3C,MAAO,CAAAnE,GAAG,CAACyF,MAAM,CAAC,yBAAyB,CAAE/D,MAAM,CAAC4B,IAAI,CAAC,CAC7D,IAAK,CAAA5C,UAAU,CAAC4C,IAAI,CAAE+C,QAAQ,CAAG3E,MAAM,CAACgC,KAAK,CAAE,MAC/C,IAAK,CAAAhE,mBAAmB,CAAC4D,IAAI,CAC7B,IAAK,CAAA/C,kBAAkB,CAAC+C,IAAI,CAC5B,IAAK,CAAA3D,mBAAmB,CAAC2D,IAAI,CAC7B,IAAK,CAAAhD,cAAc,CAACgD,IAAI,CACpB,GAAI,CAAAK,GAAmB,CAAGnC,4BAA4B,CAAC6E,QAAQ,CAAE3E,MAAM,CAAEC,UAAU,CAAED,MAAM,CAACgC,KAAK,CAAC,CAClG,GAAI,CAACC,GAAG,CAAE,MAAO,CAAAgC,QAAQ,CAAE;AAC3BU,QAAQ,CAAG1C,GAAG,CACd,MACR,CAEA;AACJ,CAEA;AACA0C,QAAQ,CAAG4B,2BAA2B,CAAC5B,QAAQ,CAAEV,QAAQ,CAAEnG,MAAM,CAAC2G,uBAAuB,CAAC,CAC1F,MAAO,CAAAE,QAAQ,CACnB,CAEA,QAAS,CAAA4B,2BAA2BA,CAACC,KAAa,CAAEvC,QAAe,CAAEQ,uBAA2F,CAAU,CACtK,IAAK,GAAI,CAAAgC,OAAO,GAAI,CAAAhC,uBAAuB,EAC3C,OAAQgC,OAAO,EACX,QAAS,MACT,IAAK,CAAA3I,MAAM,CAAC4I,OAAO,CAACC,iBAAiB,CAAC;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBACI,CAAC,CACD;AACA,MAAO,CAAAH,KAAK,CAChB,CAEA,GAAI,CAAAI,YAAoB,CAAG,IAAW,CACtC,GAAI,CAAAC,WAAoB,CAAG,KAAK,CAEhC,GAAM,CAAAC,QAAQ,CAAG,iEAAiE,CAClF;AACA;AACA;AACA;AACA;AACA;AACA,EANA,CASA;AAEA,MAAO,SAAS,CAAAC,OAAOA,CAAA,CAA0D,IAAzD,CAAA9C,QAAgB,CAAA+C,SAAA,CAAAxG,MAAA,IAAAwG,SAAA,MAAAxE,SAAA,CAAAwE,SAAA,IAAGJ,YAAY,IAAE,CAAA5G,MAAc,CAAAgH,SAAA,CAAAxG,MAAA,GAAAwG,SAAA,IAAAxE,SAAA,CACnE,GAAG,CAAE,MAAO,CAAAyE,aAAa,CAAChD,QAAQ,CAAEjE,MAAM,CAAC,CAAE,CAC7C,MAAM0D,CAAC,CAAE,CACLuC,OAAO,CAACiB,KAAK,CAAC,4BAA4B,CAAE,CAACjD,QAAQ,CAARA,QAAQ,CAAEjE,MAAM,CAANA,MAAM,CAAC,CAAC,CAC/D,MAAO,CAAAiE,QAAQ,CACnB,CACJ,CAEA,QAAS,CAAAgD,aAAaA,CAAA,CAA0D,KAAAE,qBAAA,CAAAC,sBAAA,CAAAC,sBAAA,CAAAC,sBAAA,CAAAC,sBAAA,IAAzD,CAAAtD,QAAgB,CAAA+C,SAAA,CAAAxG,MAAA,IAAAwG,SAAA,MAAAxE,SAAA,CAAAwE,SAAA,IAAGJ,YAAY,IAAE,CAAA5G,MAAc,CAAAgH,SAAA,CAAAxG,MAAA,GAAAwG,SAAA,IAAAxE,SAAA,CAClE,GAAM,CAAAgF,GAAG,CAAGC,QAAQ,CAACxD,QAAQ,CAAEjE,MAAM,CAAC,CACtC,GAAIwH,GAAG,GAAKvD,QAAQ,CAAE,MAAO,CAAAA,QAAQ,CACrCuD,GAAG,CAACE,QAAQ,CAACC,SAAS,CAAGzJ,kBAAkB,CAAC6G,eAAsB,CAElE;AACA,GAAId,QAAQ,SAARA,QAAQ,iBAARA,QAAQ,CAAE2D,oBAAoB,CAAE,CAChC,GAAM,CAAAC,aAA+B,CAAI,CAAC,aAAa,CAAE,eAAe,CAAE,WAAW,CAAE,sBAAsB,CAAC,CAC9G,uEACA,GAAI,CAAAC,eAAqC,CAAG,IAAI,CAChD,GAAG9H,MAAM,CAAC4B,IAAI,GAAK7D,eAAe,CAAC6D,IAAI,CAAE,CACrCkG,eAAe,CAAG9H,MAAyB,CAC3C,GAAM,CAAA+H,UAAU,CAAGD,eAAe,CAAC1D,OAAO,EAAI,EAAE,CAChD0D,eAAe,CAAC1D,OAAO,CAAG2D,UAAU,CAACC,MAAM,CAAC,SAAA7B,CAAC,QAAI,CAAC0B,aAAa,CAACI,QAAQ,CAAC9B,CAAC,CAACE,KAAqB,CAAC,GAAC,CACtG,CACA,GAAGyB,eAAe,EAAI,CAACA,eAAe,CAAC1D,OAAO,CAAC5D,MAAM,CAAE,MAAO,CAAAgH,GAAG,CACjExH,MAAM,CAAI8H,eAAe,CAAIA,eAAe,CAAG9H,MAAM,CACrD,GAAGA,MAAM,CAACkI,MAAM,GAAK9J,KAAK,CAACkC,OAAO,EAAI,CAACuH,aAAa,CAACI,QAAQ,CAACjI,MAAM,CAACqG,KAAqB,CAAC,CAAE,CACzF,GAAM,CAAA8B,YAA4B,CAAGC,IAAI,CAAC/D,KAAK,CAAC+D,IAAI,CAACC,SAAS,CAACrI,MAAM,CAAC,CAAC,CACvEb,aAAa,CAACmJ,MAAM,CAACC,IAAI,CAAC,YAAY,CAAEJ,YAAY,CAAC,CACzD,CACJ,CAEA,GAAIX,GAAG,CAACgB,mBAAmB,GAAK,IAAI,CAAEhB,GAAG,CAACgB,mBAAmB,CAAGC,MAAM,CAACC,IAAI,CAAClB,GAAG,CAACE,QAAQ,CAAC,CACzF,IAAAP,qBAAA,CAAKK,GAAG,CAACgB,mBAAmB,UAAArB,qBAAA,iBAAxBA,qBAAA,CAAwC3G,MAAM,CAAE,CAChD,GAAI,CAAAmI,aAAsB,CAAG,KAAK,CAAC,IAAAC,UAAA,CAAA1F,0BAAA,CACpB,GAAI,CAAA2F,GAAG,CAACrB,GAAG,CAACgB,mBAAgC,CAAC,EAAAM,MAAA,KAA5D,IAAAF,UAAA,CAAAvF,CAAA,KAAAyF,MAAA,CAAAF,UAAA,CAAAtF,CAAA,IAAAC,IAAA,EAA6D,IAApD,CAAAyB,EAAE,CAAA8D,MAAA,CAAA9G,KAAA,CACP,GAAI,CAAA+G,CAAC,CAAGvB,GAAG,CAACE,QAAQ,CAAC1C,EAAE,CAAC,CACxB,GAAIrG,sBAAsB,CAACqK,OAAO,CAACD,CAAC,CAAC9D,SAAS,CAAE,cAAc,CAAC,CAAE,CAC5D8D,CAAC,CAAkBE,kBAAkB,CAAG,IAAI,CAC7C5J,mBAAmB,CAAC6J,IAAI,CAACH,CAAC,CAAC/D,EAAE,CAAW,CAAG,CAAE,CAAQ,CAAC,IAAAmE,UAAA,CAAAjG,0BAAA,CACxCxF,YAAY,CAAC0L,cAAc,EAAAC,MAAA,KAAzC,IAAAF,UAAA,CAAA9F,CAAA,KAAAgG,MAAA,CAAAF,UAAA,CAAA7F,CAAA,IAAAC,IAAA,MAAS,CAAA+F,CAAC,CAAAD,MAAA,CAAArH,KAAA,CAAkCwF,GAAG,CAAS,kBAAkB,CAAC8B,CAAC,CAAC,CAACjH,IAAI,CAAC0G,CAAC,CAAC/D,EAAE,CAAC,CAAC,QAAAvB,GAAA,EAAA0F,UAAA,CAAAzF,CAAA,CAAAD,GAAA,WAAA0F,UAAA,CAAAxF,CAAA,IACzF,GAAI,CAACgF,aAAa,CAAEA,aAAa,CAAG,IAAI,CAC5C,CACA,GAAIhK,sBAAsB,CAACqK,OAAO,CAACD,CAAC,CAAC9D,SAAS,CAAE,eAAe,CAAC,CAAE,CAC9D,GAAI8D,CAAC,CAAC9D,SAAS,GAAK,QAAQ,CAAE,KAAAsE,qBAAA,CAAAC,kBAAA,CAC1B,GAAI,CAAAC,OAAO,EAAAF,qBAAA,CAAItF,QAAQ,CAACyD,QAAQ,CAACqB,CAAC,CAAC/D,EAAE,CAAC,UAAAuE,qBAAA,iBAAxBA,qBAAA,CAAqCnE,IAAI,CACvD,GAAI,CAAAsE,OAAO,EAAAF,kBAAA,CAAIhC,GAAG,CAACE,QAAQ,CAACqB,CAAC,CAAC/D,EAAE,CAAC,UAAAwE,kBAAA,iBAAnBA,kBAAA,CAAgCpE,IAAI,CAClD,GAAIqE,OAAO,GAAKC,OAAO,CAAElC,GAAG,CAACmC,gBAAgB,CAACZ,CAAC,CAAC/D,EAAE,CAAoB,CAAGyE,OAAO,CACpF,CACA;AACJ,CACA,GAAI9K,sBAAsB,CAACqK,OAAO,CAACD,CAAC,CAAC9D,SAAS,CAAE,eAAe,CAAC,CAAE,CAC9D5F,mBAAmB,CAACuK,IAAI,CAACb,CAAC,CAAC/D,EAAE,CAAW,CAAG,CAAE,CAAQ,CACzD,CACJ,CAAC,OAAAvB,GAAA,EAAAmF,UAAA,CAAAlF,CAAA,CAAAD,GAAA,WAAAmF,UAAA,CAAAjF,CAAA,IACD,GAAIgF,aAAa,CAAE,IAAK,GAAI,CAAAkB,GAAG,GAAI,CAAAxK,mBAAmB,CAACuK,IAAI,EAAEvK,mBAAmB,CAACuK,IAAI,CAACC,GAAG,CAAC,CAAG,CAAC,CAAQ,CAAC,CAC3G,CAEA;AACA,GAAIrC,GAAG,CAACsC,mBAAmB,CAACtJ,MAAM,CAAE,CAChC;AACA;AAAA,IAAAuJ,UAAA,CAAA7G,0BAAA,CACgB,GAAI,CAAA2F,GAAG,CAACrB,GAAG,CAACsC,mBAAmB,CAAC,EAAAE,MAAA,KAAhD,IAAAD,UAAA,CAAA1G,CAAA,KAAA2G,MAAA,CAAAD,UAAA,CAAAzG,CAAA,IAAAC,IAAA,EAAkD,IAAzC,CAAA0G,GAAG,CAAAD,MAAA,CAAAhI,KAAA,CACR,GAAI,CAAC3C,mBAAmB,CAAC6J,IAAI,CAACe,GAAG,CAAC,CAAE5K,mBAAmB,CAAC6J,IAAI,CAACe,GAAG,CAAC,CAAG,CAAC,CAAQ,CAC7E5K,mBAAmB,CAAC6J,IAAI,CAACe,GAAG,CAAC,CAACC,SAAS,CAAG1H,SAAgB,CAAE;AAC5DnD,mBAAmB,CAAC6J,IAAI,CAACe,GAAG,CAAC,CAACE,UAAU,CAAG,IAAI,CAC/C,IAAK,GAAI,CAAAN,IAAG,GAAI,CAAAxK,mBAAmB,CAACuK,IAAI,CAAE,CACtC,GAAI,CAAAQ,GAAG,CAAG/K,mBAAmB,CAACuK,IAAI,CAACC,IAAG,CAAC,CAACQ,UAAU,CAACJ,GAAG,CAAC,CACvD,GAAI,CAAAG,GAAG,SAAHA,GAAG,iBAAHA,GAAG,CAAEE,QAAQ,IAAKzM,eAAe,CAAC0M,iBAAiB,CAAEH,GAAG,CAACE,QAAQ,CAAGzM,eAAe,CAAC0M,iBAAmC,CAC/H,CACJ,CAAC,OAAA9G,GAAA,EAAAsG,UAAA,CAAArG,CAAA,CAAAD,GAAA,WAAAsG,UAAA,CAAApG,CAAA,IACD6D,GAAG,CAACsC,mBAAmB,CAAG,EAAE,CAChC,CACA;AACJ;AACA;AACA;AACA,OAEI,GAAItC,GAAG,CAACgD,6BAA6B,CAAChK,MAAM,CAAE,KAAAiK,UAAA,CAAAvH,0BAAA,CAC1B,GAAI,CAAA2F,GAAG,CAACrB,GAAG,CAACgD,6BAA6B,CAAC,EAAAE,MAAA,KAA1D,IAAAD,UAAA,CAAApH,CAAA,KAAAqH,MAAA,CAAAD,UAAA,CAAAnH,CAAA,IAAAC,IAAA,EAA4D,IAAnD,CAAA0G,IAAG,CAAAS,MAAA,CAAA1I,KAAA,CACR,IAAK,GAAI,CAAA6H,KAAG,GAAI,CAAAxK,mBAAmB,CAACuK,IAAI,CAAE,CACtC,GAAI,CAAAQ,IAAG,CAAG/K,mBAAmB,CAACuK,IAAI,CAACC,KAAG,CAAC,CAACQ,UAAU,CAACJ,IAAG,CAAC,CACvD,GAAI,CAAAG,IAAG,SAAHA,IAAG,iBAAHA,IAAG,CAAEO,cAAc,IAAK9M,eAAe,CAAC0M,iBAAiB,CAAEH,IAAG,CAACO,cAAc,CAAG9M,eAAe,CAAC0M,iBAAkC,CAC1I,CACJ,CAAC,OAAA9G,GAAA,EAAAgH,UAAA,CAAA/G,CAAA,CAAAD,GAAA,WAAAgH,UAAA,CAAA9G,CAAA,IACD6D,GAAG,CAACgD,6BAA6B,CAAG,EAAE,CAC1C,CAEA,IAAApD,sBAAA,CAAII,GAAG,CAACoD,yBAAyB,UAAAxD,sBAAA,iBAA7BA,sBAAA,CAA+B5G,MAAM,MAAAqK,UAAA,CAAA3H,0BAAA,CACvB,GAAI,CAAA2F,GAAG,CAACrB,GAAG,CAACoD,yBAAyB,CAAC,EAAAE,MAAA,KAAxD,IAAAD,UAAA,CAAAxH,CAAA,KAAAyH,MAAA,CAAAD,UAAA,CAAAvH,CAAA,IAAAC,IAAA,EAA0D,IAA/C,CAAA0G,KAAG,CAAAa,MAAA,CAAA9I,KAAA,CAA8C;AACxD,GAAI,CAAA+I,EAAgB,CAAG7M,kBAAkB,CAAC8M,WAAW,CAACf,KAAG,CAAEzC,GAAG,CAAC,CAC/D;AACA;AACA,GAAI,CAACuD,EAAE,CAACE,SAAS,CAAE,CACf,GAAI,CAAC5L,mBAAmB,CAAC6J,IAAI,CAACe,KAAG,CAAC,CAAE5K,mBAAmB,CAAC6J,IAAI,CAACe,KAAG,CAAC,CAAG,CAAC,CAAQ,CAC7E5K,mBAAmB,CAAC6J,IAAI,CAACe,KAAG,CAAC,CAACgB,SAAS,CAAG,CAAC,CAAC,CAC5C5L,mBAAmB,CAAC6J,IAAI,CAACe,KAAG,CAAC,CAACiB,aAAa,CAAG,EAAE,CAChD;AACA,SACJ,CACA,GAAM,CAAAC,eAAwB,CAAG,CAAC,CAAC,CACnC,GAAM,CAAAC,OAAO,CAAG,CAAClC,IAAI,CAAC6B,EAAE,CAAC,CAAE;AAC3B,GAAI,CAAAM,QAAQ,CAAG,GAAG,CAAC5C,MAAM,CAACC,IAAI,CAAC0C,OAAO,CAAC,CAACE,IAAI,CAAC,GAAG,CAAC,CAAC,QAAQ,CAC1D,GAAI,CACA;AACA,GAAI,CAAAC,iBAA2D,CAAG,GAAI,CAAAC,QAAQ,CAACH,QAAQ,CAAE,UAAU,CAACN,EAAE,CAACE,SAAS,CAAC,QAAQ,CAAC,CAACQ,IAAI,CAACL,OAAO,CAAC,CACxIG,iBAAiB,CAACH,OAAO,CAAED,eAAe,CAAC,CAC/C,CAAE,MAAMzH,CAAK,CAAC,CACVuC,OAAO,CAACiB,KAAK,CAAC,uBAAuB,CAAE,CAAC+C,GAAG,CAAHA,KAAG,CAAEvG,CAAC,CAADA,CAAC,CAAE2H,QAAQ,CAARA,QAAQ,CAAEK,IAAI,CAAC,UAAU,CAACX,EAAE,CAACE,SAAS,CAAC,QAAQ,CAAC,CAAC,CACjG;AACJ,CAEA5L,mBAAmB,CAAC6J,IAAI,CAACe,KAAG,CAAC,CAACgB,SAAS,CAAGE,eAAe,CACzD9L,mBAAmB,CAAC6J,IAAI,CAACe,KAAG,CAAC,CAACiB,aAAa,CAAGzC,MAAM,CAACC,IAAI,CAACrJ,mBAAmB,CAAC6J,IAAI,CAACe,KAAG,CAAC,CAACgB,SAAS,CAAC,CAClG;AACAzD,GAAG,CAACmE,2BAA2B,CAACtJ,IAAI,CAAC4H,KAAG,CAAC,CACzCzC,GAAG,CAACoE,iCAAiC,CAACvJ,IAAI,CAAC4H,KAAG,CAAC,CAC/CzC,GAAG,CAACqE,yBAAyB,CAACxJ,IAAI,CAAC4H,KAAG,CAAC,CACvCzC,GAAG,CAACsE,sBAAsB,CAACzJ,IAAI,CAAC4H,KAAG,CAAC,CAAC,IAAA8B,UAAA,CAAA7I,0BAAA,CACvBxF,YAAY,CAAC0L,cAAc,EAAA4C,MAAA,KAAzC,IAAAD,UAAA,CAAA1I,CAAA,KAAA2I,MAAA,CAAAD,UAAA,CAAAzI,CAAA,IAAAC,IAAA,MAAS,CAAA+F,EAAC,CAAA0C,MAAA,CAAAhK,KAAA,CAAkCwF,GAAG,CAAS,kBAAkB,CAAC8B,EAAC,CAAC,CAACjH,IAAI,CAAC4H,KAAG,CAAC,CAAC,QAAAxG,GAAA,EAAAsI,UAAA,CAAArI,CAAA,CAAAD,GAAA,WAAAsI,UAAA,CAAApI,CAAA,IAC5F,CAAC,OAAAF,GAAA,EAAAoH,UAAA,CAAAnH,CAAA,CAAAD,GAAA,WAAAoH,UAAA,CAAAlH,CAAA,KACD6D,GAAG,CAACoD,yBAAyB,CAAG,EAAE,CAElC,IAAAvD,sBAAA,CAAIG,GAAG,CAACoE,iCAAiC,UAAAvE,sBAAA,iBAArCA,sBAAA,CAAuC7G,MAAM,MAAAyL,WAAA,CAAA/I,0BAAA,CAC/B,GAAI,CAAA2F,GAAG,CAACrB,GAAG,CAACoE,iCAAiC,CAAC,EAAAM,OAAA,KAAhE,IAAAD,WAAA,CAAA5I,CAAA,KAAA6I,OAAA,CAAAD,WAAA,CAAA3I,CAAA,IAAAC,IAAA,EAAkE,KAAA4I,qBAAA,IAAvD,CAAAlC,KAAG,CAAAiC,OAAA,CAAAlK,KAAA,CAAsD;AAChE,GAAI,CAAA+I,GAAgB,CAAG7M,kBAAkB,CAAC8M,WAAW,CAACf,KAAG,CAAEzC,GAAG,CAAC,CAC/D,GAAI,CAAA4E,EAAE,CAAG/M,mBAAmB,CAAC6J,IAAI,CAACe,KAAG,CAAC,CACtC,GAAI,CAACmC,EAAE,CAAE/M,mBAAmB,CAAC6J,IAAI,CAACe,KAAG,CAAC,CAAGmC,EAAE,CAAG,CAAC,CAAQ,CACvD,GAAI,CAACrB,GAAE,CAACsB,iBAAiB,CAAE,CACvBD,EAAE,CAACE,MAAM,CAAG,EAAE,CACdF,EAAE,CAACG,UAAU,CAAG/J,SAAgB,CAChC;AACA,SACJ,CACA,GAAI,CAAAgK,OAAO,CAAG,EAAAL,qBAAA,CAAApB,GAAE,CAACsB,iBAAiB,UAAAF,qBAAA,iBAApBA,qBAAA,CAAsBM,KAAK,CAAC3F,QAAQ,CAAC,GAAI,EAAE,CACzDzH,mBAAmB,CAAC6J,IAAI,CAACe,KAAG,CAAC,CAACqC,MAAM,CAAGE,OAAO,CAACE,GAAG,CAAC,SAAArJ,CAAC,CAAE,CAAEA,CAAC,CAAGA,CAAC,CAACvC,IAAI,CAAC,CAAC,CAAE,MAAO,CAAAuC,CAAC,CAACiC,SAAS,CAACjC,CAAC,CAACZ,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC,CAAEY,CAAC,CAAC7C,MAAM,CAAC,CAAC,CAAC,CAACM,IAAI,CAAC,CAAC,EAAC,CAAC,CAChImF,OAAO,CAACC,GAAG,CAAC,SAAS,CAAE,CAACsG,OAAO,CAAPA,OAAO,CAAEG,MAAM,CAACtN,mBAAmB,CAAC6J,IAAI,CAACe,KAAG,CAAC,CAACqC,MAAM,CAAC,CAAC,CAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA,GAAI,CAAAM,cAA0B,CAAAvM,aAAA,IAAOd,gBAAgB,CAAC,CAAC,IAAAsN,WAAA,CAAA3J,0BAAA,CACzCkJ,EAAE,CAAClB,aAAa,EAAA4B,OAAA,KAA9B,IAAAD,WAAA,CAAAxJ,CAAA,KAAAyJ,OAAA,CAAAD,WAAA,CAAAvJ,CAAA,IAAAC,IAAA,MAAS,CAAA+F,GAAC,CAAAwD,OAAA,CAAA9K,KAAA,CAAsB,GAAI,CAAC4K,cAAc,CAACtD,GAAC,CAAC,CAAEsD,cAAc,CAACtD,GAAC,CAAC,CAAG,IAAI,CAAC,QAAA7F,GAAA,EAAAoJ,WAAA,CAAAnJ,CAAA,CAAAD,GAAA,WAAAoJ,WAAA,CAAAlJ,CAAA,IACjF,GAAI,CAAA0H,SAAQ,CAAG,GAAG,CAAC5C,MAAM,CAACC,IAAI,CAACkE,cAAc,CAAC,CAACtB,IAAI,CAAC,GAAG,CAAC,CAAC,QAAQ,CACjE,GAAIrB,KAAG,CAAChC,QAAQ,CAAC,OAAO,CAAC,CAAEhC,OAAO,CAACC,GAAG,CAAC,gBAAgB,CAAE,CAACmF,QAAQ,CAARA,SAAQ,CAAE0B,KAAK,CAAChC,GAAE,CAACsB,iBAAiB,CAAEM,MAAM,CAACtN,mBAAmB,CAAC6J,IAAI,CAACe,KAAG,CAAC,CAACqC,MAAM,CAAC,CAAC,CAC7I,GAAI,CACAF,EAAE,CAACG,UAAU,CAAG,GAAI,CAAAf,QAAQ,CAACH,SAAQ,CAAE,UAAU,CAACN,GAAE,CAACsB,iBAAiB,CAAC,QAAQ,CAAoB,CACvG,CAAE,MAAO3I,CAAK,CAAE,CACZ,GAAI,CAAAsJ,MAAM,CAAG5E,IAAI,CAACC,SAAS,CAAC,CAAC3E,CAAC,CAACuJ,OAAO,EAAI,EAAE,EAAEC,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,CAC7D,GAAI,CAAAC,OAAO,CAAG,mCAAmC,CAACH,MAAM,CAAC,+DAA+D,CACxH/G,OAAO,CAACiB,KAAK,CAAC,eAAe,CAAE,CAAC+C,GAAG,CAAHA,KAAG,CAAEvG,CAAC,CAADA,CAAC,CAAE2H,QAAQ,CAARA,SAAQ,CAAEK,IAAI,CAAE,UAAU,CAACX,GAAE,CAACsB,iBAAiB,CAAC,QAAQ,CAAEW,MAAM,CAANA,MAAM,CAAEG,OAAO,CAAPA,OAAO,CAAC,CAAC,CACnHf,EAAE,CAACG,UAAU,CAAG,GAAI,CAAAf,QAAQ,CAAC,KAAK,CAAE2B,OAAO,CAAoB,CACnE,CAGA;AACA3F,GAAG,CAACqE,yBAAyB,CAACxJ,IAAI,CAAC4H,KAAG,CAAC,CACvCzC,GAAG,CAACsE,sBAAsB,CAACzJ,IAAI,CAAC4H,KAAG,CAAC,CAAC,IAAAmD,WAAA,CAAAlK,0BAAA,CACvBxF,YAAY,CAAC0L,cAAc,EAAAiE,OAAA,KAAzC,IAAAD,WAAA,CAAA/J,CAAA,KAAAgK,OAAA,CAAAD,WAAA,CAAA9J,CAAA,IAAAC,IAAA,MAAS,CAAA+F,GAAC,CAAA+D,OAAA,CAAArL,KAAA,CAAkCwF,GAAG,CAAS,kBAAkB,CAAC8B,GAAC,CAAC,CAACjH,IAAI,CAAC4H,KAAG,CAAC,CAAC,QAAAxG,GAAA,EAAA2J,WAAA,CAAA1J,CAAA,CAAAD,GAAA,WAAA2J,WAAA,CAAAzJ,CAAA,IAC5F,CAAC,OAAAF,GAAA,EAAAwI,WAAA,CAAAvI,CAAA,CAAAD,GAAA,WAAAwI,WAAA,CAAAtI,CAAA,KACD6D,GAAG,CAACoE,iCAAiC,CAAG,EAAE,CAE1C,GAAIpE,GAAG,CAACsE,sBAAsB,CAACtL,MAAM,CAAE,CACnC;AACA;AAAA,IAAA8M,WAAA,CAAApK,0BAAA,CACkB,GAAI,CAAA2F,GAAG,CAACrB,GAAG,CAACsE,sBAAsB,CAAC,EAAAyB,OAAA,KAArD,IAAAD,WAAA,CAAAjK,CAAA,KAAAkK,OAAA,CAAAD,WAAA,CAAAhK,CAAA,IAAAC,IAAA,EAAuD,IAA9C,CAAAiK,KAAK,CAAAD,OAAA,CAAAvL,KAAA,CACV,GAAI,CAAAiI,KAAW,QACf,GAAI,CAAAc,IAAgB,QACpB,GAAI,CAAArC,IAAc,QAClB,GAAI,MAAO,CAAA8E,KAAK,GAAK,QAAQ,CAAE,CAC3BvD,KAAG,CAAGuD,KAAK,CAACvD,GAAG,CACfc,IAAE,CAAG7M,kBAAkB,CAAC8M,WAAW,CAACf,KAAG,CAAEzC,GAAG,CAAC,CAC7CkB,IAAI,CAAG8E,KAAK,CAAC9E,IAAI,EAAID,MAAM,CAACC,IAAI,CAACqC,IAAE,CAAC0C,MAAM,CAAC,CAC/C,CAAC,IACI,CACDxD,KAAG,CAAGuD,KAAK,CACXzC,IAAE,CAAG7M,kBAAkB,CAAC8M,WAAW,CAACf,KAAG,CAAEzC,GAAG,CAAC,CAC7CkB,IAAI,CAAGD,MAAM,CAACC,IAAI,CAACqC,IAAE,CAAC0C,MAAM,CAAC,CACjC,CACA,GAAI,CAAArB,GAAE,CAAG/M,mBAAmB,CAAC6J,IAAI,CAACe,KAAG,CAAC,CACtC,GAAI,CAACmC,GAAE,CAAE/M,mBAAmB,CAAC6J,IAAI,CAACe,KAAG,CAAC,CAAGmC,GAAE,CAAG,CAAC,CAAQ,CACvD,GAAI,CAACA,GAAE,CAACqB,MAAM,CAAErB,GAAE,CAACqB,MAAM,CAAG,CAAC,CAAC,CAC9B;AAAA,IAAAC,WAAA,CAAAxK,0BAAA,CACgBwF,IAAI,EAAAiF,OAAA,KAApB,IAAAD,WAAA,CAAArK,CAAA,KAAAsK,OAAA,CAAAD,WAAA,CAAApK,CAAA,IAAAC,IAAA,EAAsB,IAAb,CAAA1C,GAAG,CAAA8M,OAAA,CAAA3L,KAAA,CACR,GAAI,CAACnB,GAAG,CAAE,CAAE,MAAO,CAAAuL,GAAE,CAACqB,MAAM,CAAC5M,GAAG,CAAC,CAAE,SAAU,CAC7C,GAAI,CAAA+L,eAAc,CAAAvM,aAAA,IAAOd,gBAAgB,CAAC,CAAC,IAAAqO,WAAA,CAAA1K,0BAAA,CAC7B7D,mBAAmB,CAAC6J,IAAI,CAACe,KAAG,CAAC,CAACiB,aAAa,EAAA2C,OAAA,KAAzD,IAAAD,WAAA,CAAAvK,CAAA,KAAAwK,OAAA,CAAAD,WAAA,CAAAtK,CAAA,IAAAC,IAAA,MAAS,CAAA+F,GAAC,CAAAuE,OAAA,CAAA7L,KAAA,CAAiD,GAAI,CAAC4K,eAAc,CAACtD,GAAC,CAAC,CAAEsD,eAAc,CAACtD,GAAC,CAAC,CAAG,IAAI,CAAC,QAAA7F,GAAA,EAAAmK,WAAA,CAAAlK,CAAA,CAAAD,GAAA,WAAAmK,WAAA,CAAAjK,CAAA,QAAAmK,WAAA,CAAA5K,0BAAA,CAC9F7D,mBAAmB,CAAC6J,IAAI,CAACe,KAAG,CAAC,CAACqC,MAAM,EAAAyB,OAAA,KAAlD,IAAAD,WAAA,CAAAzK,CAAA,KAAA0K,OAAA,CAAAD,WAAA,CAAAxK,CAAA,IAAAC,IAAA,MAAS,CAAA+F,GAAC,CAAAyE,OAAA,CAAA/L,KAAA,CAA0C,GAAI,CAAC4K,eAAc,CAACtD,GAAC,CAAC,CAAEsD,eAAc,CAACtD,GAAC,CAAC,CAAG,IAAI,CAAC,QAAA7F,GAAA,EAAAqK,WAAA,CAAApK,CAAA,CAAAD,GAAA,WAAAqK,WAAA,CAAAnK,CAAA,IACrG,GAAI,CAAA0H,UAAQ,CAAG,GAAG,CAAC5C,MAAM,CAACC,IAAI,CAACkE,eAAc,CAAC,CAACtB,IAAI,CAAC,GAAG,CAAC,CAAC,eAAe,CACxE;AACA,GAAM,CAAAI,IAAY,CAAG,UAAU,CAAEX,IAAE,CAAC0C,MAAM,CAAC5M,GAAG,CAAC,CAAC,eAAe,CAC/D;AACA,GAAI,CACAuL,GAAE,CAACqB,MAAM,CAAC5M,GAAG,CAAC,CAAG,GAAI,CAAA2K,QAAQ,CAACH,UAAQ,CAAEK,IAAI,CAAwB,CACpE;AACA;AACA;AACA;AACA;AACJ,CACA,MAAOhI,CAAM,CAAE,CACXuC,OAAO,CAACiB,KAAK,CAAC,gBAAgB,CAAE,CAAC+C,GAAG,CAAHA,KAAG,CAAEvG,CAAC,CAADA,CAAC,CAAE2H,QAAQ,CAARA,UAAQ,CAAEK,IAAI,CAAJA,IAAI,CAAC,CAAC,CACzDU,GAAE,CAACqB,MAAM,CAAC5M,GAAG,CAAC,CAAG,SAACuK,OAAO,QAAK,CAAA9M,GAAG,CAACuD,EAAE,CAAC,iCAAiC,CAAG6B,CAAC,CAACuJ,OAAO,CAACC,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAExJ,CAAC,CAACuJ,OAAO,CAAC,GACjH,CACJ,CAAC,OAAAxJ,GAAA,EAAAiK,WAAA,CAAAhK,CAAA,CAAAD,GAAA,WAAAiK,WAAA,CAAA/J,CAAA,IACL,CAAC,OAAAF,GAAA,EAAA6J,WAAA,CAAA5J,CAAA,CAAAD,GAAA,WAAA6J,WAAA,CAAA3J,CAAA,IACD6D,GAAG,CAACsE,sBAAsB,CAAG,EAAE,CAC/B;AACJ,CAEA,IAAAxE,sBAAA,CAAIE,GAAG,CAACmE,2BAA2B,UAAArE,sBAAA,iBAA/BA,sBAAA,CAAiC9G,MAAM,MAAAwN,WAAA,CAAA9K,0BAAA,CACzB,GAAI,CAAA2F,GAAG,CAACrB,GAAG,CAACmE,2BAA2B,CAAC,EAAAsC,OAAA,KAA1D,IAAAD,WAAA,CAAA3K,CAAA,KAAA4K,OAAA,CAAAD,WAAA,CAAA1K,CAAA,IAAAC,IAAA,EAA4D,IAAjD,CAAA0G,KAAG,CAAAgE,OAAA,CAAAjM,KAAA,CACV,GAAM,CAAA+I,IAAgB,CAAG7M,kBAAkB,CAAC8M,WAAW,CAACf,KAAG,CAAEzC,GAAG,CAAC,CACjE,GAAI,CAAA4E,IAAE,CAAG/M,mBAAmB,CAAC6J,IAAI,CAACe,KAAG,CAAC,CACtC,GAAI,CAACmC,IAAE,CAAE/M,mBAAmB,CAAC6J,IAAI,CAACe,KAAG,CAAC,CAAGmC,IAAE,CAAG,CAAC,CAAQ,CACvDA,IAAE,CAAC8B,kBAAkB,CAAG,IAAI,CAC5B,GAAI,CAACnD,IAAE,CAACoD,WAAW,CAAE,CACjB/B,IAAE,CAAC+B,WAAW,CAAG3L,SAAS,CAC1B,SACJ,CACA,GAAM,CAAA4L,KAAK,CAAGrD,IAAE,CAACoD,WAAW,CAACrN,IAAI,CAAC,CAAC,CAACoM,KAAK,CAAC,IAAI,CAAC,CAC/C,GAAI,CAAAmB,QAAQ,CAAGD,KAAK,CAACA,KAAK,CAAC5N,MAAM,CAAG,CAAC,CAAC,CACtC,GAAI6N,QAAQ,CAAC5L,OAAO,CAAC,QAAQ,CAAC,GAAK,CAAC,CAAE2L,KAAK,CAACA,KAAK,CAAC5N,MAAM,CAAG,CAAC,CAAC,YAAA8N,MAAA,CAAcD,QAAQ,KAAG,CAGtF,GAAI,CAACtD,IAAE,CAACwD,SAAS,CAAE,CAAElP,mBAAmB,CAAC6J,IAAI,CAACe,KAAG,CAAC,CAACuE,WAAW,CAAGhM,SAAgB,CAAE,SAAU,CAC7F,GAAI,CAAAoK,gBAAc,CAAAvM,aAAA,IAAOd,gBAAgB,CAAC,CAAC,IAAAkP,WAAA,CAAAvL,0BAAA,CAC7B7D,mBAAmB,CAAC6J,IAAI,CAACe,KAAG,CAAC,CAACiB,aAAa,EAAAwD,OAAA,KAAzD,IAAAD,WAAA,CAAApL,CAAA,KAAAqL,OAAA,CAAAD,WAAA,CAAAnL,CAAA,IAAAC,IAAA,MAAS,CAAA+F,GAAC,CAAAoF,OAAA,CAAA1M,KAAA,CAAiD,GAAI,CAAC4K,gBAAc,CAACtD,GAAC,CAAC,CAAEsD,gBAAc,CAACtD,GAAC,CAAC,CAAG,IAAI,CAAC,QAAA7F,GAAA,EAAAgL,WAAA,CAAA/K,CAAA,CAAAD,GAAA,WAAAgL,WAAA,CAAA9K,CAAA,IAE5G,GAAI,CAAA0H,UAAQ,CAAG,GAAG,CAAC5C,MAAM,CAACC,IAAI,CAACkE,gBAAc,CAAC,CAACtB,IAAI,CAAC,GAAG,CAAC,CAAC,GAAG,CAC5D,GAAM,CAAAI,KAAI,CAAG0C,KAAK,CAAC9C,IAAI,CAAC,IAAI,CAAC,CAC7B,GAAI,CACAc,IAAE,CAAC+B,WAAW,CAAG,GAAI,CAAA3C,QAAQ,CAACH,UAAQ,CAAEK,KAAI,CAAsB,CACtE,CAAE,MAAOhI,CAAC,CAAE,CACR0I,IAAE,CAAC+B,WAAW,CAAG3L,SAAS,CAC1ByD,OAAO,CAACC,GAAG,CAAC,2BAA2B,CAAExC,CAAC,CAAC,CAC/C,CACJ,CAAC,OAAAD,GAAA,EAAAuK,WAAA,CAAAtK,CAAA,CAAAD,GAAA,WAAAuK,WAAA,CAAArK,CAAA,KACD6D,GAAG,CAACmE,2BAA2B,CAAG,EAAE,CAGpC,IAAApE,sBAAA,CAAIC,GAAG,CAACqE,yBAAyB,UAAAtE,sBAAA,iBAA7BA,sBAAA,CAA+B/G,MAAM,MAAAmO,WAAA,CAAAzL,0BAAA,CACvB,GAAI,CAAA2F,GAAG,CAACrB,GAAG,CAACqE,yBAAyB,CAAC,EAAA+C,OAAA,SAAAC,KAAA,UAAAA,MAAA,KAA7C,CAAA5E,GAAG,CAAA2E,OAAA,CAAA5M,KAAA,CAA8C;AACxD,GAAI,CAAA+I,EAAgB,CAAG7M,kBAAkB,CAAC8M,WAAW,CAACf,GAAG,CAAEzC,GAAG,CAAC,CAC/D,GAAI,CAAA4E,EAAE,CAAG/M,mBAAmB,CAAC6J,IAAI,CAACe,GAAG,CAAC,CACtC,GAAI,CAACmC,EAAE,CAAE/M,mBAAmB,CAAC6J,IAAI,CAACe,GAAG,CAAC,CAAGmC,EAAE,CAAG,CAAC,CAAQ,CACvD,GAAI,CAACrB,EAAE,CAACwD,SAAS,CAAE,CAAElP,mBAAmB,CAAC6J,IAAI,CAACe,GAAG,CAAC,CAACuE,WAAW,CAAGhM,SAAgB,CAAE,iBAAU,CAC7F,GAAI,CAAAoK,cAAc,CAAAvM,aAAA,IAAOd,gBAAgB,CAAC,CAAC,IAAAuP,WAAA,CAAA5L,0BAAA,CAC7B7D,mBAAmB,CAAC6J,IAAI,CAACe,GAAG,CAAC,CAACiB,aAAa,EAAA6D,OAAA,KAAzD,IAAAD,WAAA,CAAAzL,CAAA,KAAA0L,OAAA,CAAAD,WAAA,CAAAxL,CAAA,IAAAC,IAAA,MAAS,CAAA+F,GAAC,CAAAyF,OAAA,CAAA/M,KAAA,CAAiD,GAAI,CAAC4K,cAAc,CAACtD,GAAC,CAAC,CAAEsD,cAAc,CAACtD,GAAC,CAAC,CAAG,IAAI,CAAC,QAAA7F,GAAA,EAAAqL,WAAA,CAAApL,CAAA,CAAAD,GAAA,WAAAqL,WAAA,CAAAnL,CAAA,QAAAqL,WAAA,CAAA9L,0BAAA,CAC9F7D,mBAAmB,CAAC6J,IAAI,CAACe,GAAG,CAAC,CAACqC,MAAM,EAAA2C,OAAA,KAAlD,IAAAD,WAAA,CAAA3L,CAAA,KAAA4L,OAAA,CAAAD,WAAA,CAAA1L,CAAA,IAAAC,IAAA,MAAS,CAAA+F,GAAC,CAAA2F,OAAA,CAAAjN,KAAA,CAA0C,GAAI,CAAC4K,cAAc,CAACtD,GAAC,CAAC,CAAEsD,cAAc,CAACtD,GAAC,CAAC,CAAG,IAAI,CAAC,QAAA7F,GAAA,EAAAuL,WAAA,CAAAtL,CAAA,CAAAD,GAAA,WAAAuL,WAAA,CAAArL,CAAA,IACrG,GAAI,CAAA0H,QAAQ,CAAG,GAAG,CAAC5C,MAAM,CAACC,IAAI,CAACkE,cAAc,CAAC,CAACtB,IAAI,CAAC,GAAG,CAAC,CAAC,GAAG,CAC5DrF,OAAO,CAACC,GAAG,CAAC,UAAU,CAAE,CAAE0G,cAAc,CAAdA,cAAc,CAAEsC,EAAE,CAAC7P,mBAAmB,CAAC6J,IAAI,CAACe,GAAG,CAAC,CAACqC,MAAM,CAAE6C,CAAC,CAAC9P,mBAAmB,CAAC6J,IAAI,CAACe,GAAG,CAAC,CAACiB,aAAc,CAAC,CAAC,CACnI,GAAM,CAAAQ,IAAY,CAAI,UAAU,CAAG/N,EAAE,CAACyR,cAAc,CAAC1P,GAAG,CAAC2P,MAAM,CAACtE,EAAE,CAACwD,SAAS,CAAC,CAAExD,EAAE,CAAC,CAAG,GAAG,CACxF;AACA9E,OAAO,CAACC,GAAG,CAAC,UAAU,CAAE,CAAC+D,GAAG,CAAHA,GAAG,CAAEoB,QAAQ,CAARA,QAAQ,CAAEK,IAAI,CAAJA,IAAI,CAAC,CAAC,CAC9C,GAAI,CACArM,mBAAmB,CAAC6J,IAAI,CAACe,GAAG,CAAC,CAACuE,WAAW,CAAG,GAAI,CAAAhD,QAAQ,CAACH,QAAQ,CAAEK,IAAI,CAAyB,CACpG,CACA,MAAOhI,CAAM,CAAE,CACX;AACZ;AACA;AACA;AACA;AACA,eACYuC,OAAO,CAACiB,KAAK,CAAC,gBAAgB,CAAE,CAAC+C,GAAG,CAAHA,GAAG,CAAEvG,CAAC,CAADA,CAAC,CAAE2H,QAAQ,CAARA,QAAQ,CAAEK,IAAI,CAAJA,IAAI,CAAC,CAAC,CACzDrM,mBAAmB,CAAC6J,IAAI,CAACe,GAAG,CAAC,CAACuE,WAAW,CAAG,SAACpD,OAAO,QAAK,CAAAxN,qBAAqB,CAAC0R,YAAY,CAAC5L,CAAC,CAAE,YAAY,CAAEqH,EAAE,CAAC,GACpH,CACA;AAAA,EA1BJ,IAAA4D,WAAA,CAAAtL,CAAA,KAAAuL,OAAA,CAAAD,WAAA,CAAArL,CAAA,IAAAC,IAAA,EAA0D,KAAAgM,IAAA,CAAAV,KAAA,MAAAU,IAAA,cAI6B,SAuBvF,CAAC,OAAA9L,GAAA,EAAAkL,WAAA,CAAAjL,CAAA,CAAAD,GAAA,WAAAkL,WAAA,CAAAhL,CAAA,KACD6D,GAAG,CAACqE,yBAAyB,CAAG,EAAE,CAAC,IAAA2D,WAAA,CAAAtM,0BAAA,CAIjBxF,YAAY,CAAC0L,cAAc,EAAAqG,OAAA,SAAAC,MAAA,UAAAA,OAAA,MAAAC,IAAA,IAAlC,CAAA9O,GAAG,CAAA4O,OAAA,CAAAzN,KAAA,CACV,IAAA2N,IAAA,CAAKnI,GAAG,CAAS,kBAAkB,CAAC3G,GAAG,CAAC,UAAA8O,IAAA,iBAApCA,IAAA,CAAsCnP,MAAM,MAAAoP,WAAA,CAAA1M,0BAAA,CAChC,GAAI,CAAA2F,GAAG,CAAErB,GAAG,CAAS,kBAAkB,CAAC3G,GAAG,CAAC,CAAC,EAAAgP,OAAA,SAAAC,MAAA,UAAAA,OAAA,KAApD,CAAA7F,GAAG,CAAA4F,OAAA,CAAA7N,KAAA,CACR,GAAI,CAAA+I,EAAgB,CAAG7M,kBAAkB,CAAC8M,WAAW,CAACf,GAAG,CAAEzC,GAAG,CAAC,CAC/D,GAAI,CAAA4E,EAAE,CAAG/M,mBAAmB,CAAC6J,IAAI,CAACe,GAAG,CAAC,CACtC,GAAI,CAACmC,EAAE,CAAE/M,mBAAmB,CAAC6J,IAAI,CAACe,GAAG,CAAC,CAAGmC,EAAE,CAAG,CAAC,CAAQ,CACvD,GAAI,CAAA2D,GAAW,CAAIhF,EAAE,CAASlK,GAAG,CAAC,CAClC,GAAI,CAACkP,GAAG,CAAE,CACL1Q,mBAAmB,CAAC6J,IAAI,CAACe,GAAG,CAAC,CAASpJ,GAAG,CAAC,CAAG2B,SAAS,CACvD,iBACJ,CACA,GAAI,CAAAoK,cAAc,CAAAvM,aAAA,IAAOd,gBAAgB,CAAC,CAAC,IAAAyQ,WAAA,CAAA9M,0BAAA,CAC7B7D,mBAAmB,CAAC6J,IAAI,CAACe,GAAG,CAAC,CAACiB,aAAa,EAAA+E,OAAA,KAAzD,IAAAD,WAAA,CAAA3M,CAAA,KAAA4M,OAAA,CAAAD,WAAA,CAAA1M,CAAA,IAAAC,IAAA,MAAS,CAAA+F,GAAC,CAAA2G,OAAA,CAAAjO,KAAA,CAAiD,GAAI,CAAC4K,cAAc,CAACtD,GAAC,CAAC,CAAEsD,cAAc,CAACtD,GAAC,CAAC,CAAG,IAAI,CAAC,QAAA7F,GAAA,EAAAuM,WAAA,CAAAtM,CAAA,CAAAD,GAAA,WAAAuM,WAAA,CAAArM,CAAA,QAAAuM,WAAA,CAAAhN,0BAAA,CAC9F7D,mBAAmB,CAAC6J,IAAI,CAACe,GAAG,CAAC,CAACqC,MAAM,EAAA6D,OAAA,KAAlD,IAAAD,WAAA,CAAA7M,CAAA,KAAA8M,OAAA,CAAAD,WAAA,CAAA5M,CAAA,IAAAC,IAAA,MAAS,CAAA+F,IAAC,CAAA6G,OAAA,CAAAnO,KAAA,CAA0C,GAAI,CAAC4K,cAAc,CAACtD,IAAC,CAAC,CAAEsD,cAAc,CAACtD,IAAC,CAAC,CAAG,IAAI,CAAC,QAAA7F,GAAA,EAAAyM,WAAA,CAAAxM,CAAA,CAAAD,GAAA,WAAAyM,WAAA,CAAAvM,CAAA,IACrG,GAAI,CAAA0H,QAAQ,CAAG,GAAG,CAAC5C,MAAM,CAACC,IAAI,CAACkE,cAAc,CAAC,CAACtB,IAAI,CAAC,GAAG,CAAC,CAAC,GAAG,CAC5DrF,OAAO,CAACC,GAAG,CAAC,mBAAmB,CAACrF,GAAG,CAAE,CAAC+L,cAAc,CAAdA,cAAc,CAAEsC,EAAE,CAAC7P,mBAAmB,CAAC6J,IAAI,CAACe,GAAG,CAAC,CAACqC,MAAM,CAAE6C,CAAC,CAAC9P,mBAAmB,CAAC6J,IAAI,CAACe,GAAG,CAAC,CAACiB,aAAc,CAAC,CAAC,CAC/IjF,OAAO,CAACC,GAAG,CAAC,mBAAmB,CAACrF,GAAG,CAAE,CAACoJ,GAAG,CAAHA,GAAG,CAAEoB,QAAQ,CAARA,QAAQ,CAAEK,IAAI,CAACqE,GAAG,CAAC,CAAC,CAC/D,GAAI,CACC1Q,mBAAmB,CAAC6J,IAAI,CAACe,GAAG,CAAC,CAASpJ,GAAG,CAAC,CAAG,GAAI,CAAA2K,QAAQ,CAACH,QAAQ,CAAE0E,GAAG,CAAC,CAC7E,CACA,MAAOrM,CAAM,CAAE,CACXuC,OAAO,CAACiB,KAAK,CAAC,yBAAyB,CAACrG,GAAG,CAAE,CAACoJ,GAAG,CAAHA,GAAG,CAAEvG,CAAC,CAADA,CAAC,CAAE2H,QAAQ,CAARA,QAAQ,CAAEK,IAAI,CAACqE,GAAG,CAAC,CAAC,CACzE1Q,mBAAmB,CAAC6J,IAAI,CAACe,GAAG,CAAC,CAASpJ,GAAG,CAAC,CAAG2B,SAAS,CACvD;AACAnD,mBAAmB,CAAC6J,IAAI,CAACe,GAAG,CAAC,CAACuE,WAAW,CAAG,SAACpD,OAAO,QAAK,CAAAxN,qBAAqB,CAAC0R,YAAY,CAAC5L,CAAC,CAAE,aAAa,CAAG7C,GAAG,CAAG,SAAS,CAAEkK,EAAE,CAAC,GACnI,cACJ,CAAC,EAxBL,IAAA6E,WAAA,CAAAvM,CAAA,KAAAwM,OAAA,CAAAD,WAAA,CAAAtM,CAAA,IAAAC,IAAA,EAAsE,KAAA6M,KAAA,CAAAN,MAAA,MAAAM,KAAA,cAO9D,SAAS,GAAAA,KAAA,WAgBT,MAER,CAAC,OAAA3M,GAAA,EAAAmM,WAAA,CAAAlM,CAAA,CAAAD,GAAA,WAAAmM,WAAA,CAAAjM,CAAA,KACA6D,GAAG,CAAS,kBAAkB,CAAC3G,GAAG,CAAC,CAAG,EAAE,CAAC,EA5B9C,IAAA2O,WAAA,CAAAnM,CAAA,KAAAoM,OAAA,CAAAD,WAAA,CAAAlM,CAAA,IAAAC,IAAA,EAA+C,CAAAmM,MAAA,GA6B/C,CAAC,OAAAjM,GAAA,EAAA+L,WAAA,CAAA9L,CAAA,CAAAD,GAAA,WAAA+L,WAAA,CAAA7L,CAAA,IAED,IAAK,GAAI,CAAA0M,MAAM,GAAI,CAAA7I,GAAG,CAACmC,gBAAgB,CAAE,CACrC,GAAI0G,MAAM,GAAK,eAAe,CAAE,SAChC;AACA;AAEA;AACA,GAAI,CAAChR,mBAAmB,CAACiR,YAAY,CAACD,MAAM,CAAC,CAAE,CAC3ChR,mBAAmB,CAACiR,YAAY,CAACD,MAAM,CAAC,CAAG,CAACE,KAAK,CAAE,CAAC,CAAC,CAAC,CAC1D,CACA;AACA,GAAI,CAAAC,IAAY,CAAGhJ,GAAG,CAACE,QAAQ,CAAC2I,MAAM,CAAW,CACjD1R,sBAAsB,CAAC8R,kBAAkB,CAACD,IAAI,CAAEhJ,GAAG,CAAEvD,QAAQ,CAAC,CAC9D;AACA;AACJ,CACAuD,GAAG,CAACmC,gBAAgB,CAAG,CAAC,CAAC,CAEzB,MAAO,CAAAnC,GAAG,CAEd,CAEA,MAAO,SAAS,CAAAC,QAAQ,6CAAAA,CAAA,CAAsG,IAAxD,CAAAxD,QAAgB,CAAA+C,SAAA,CAAAxG,MAAA,IAAAwG,SAAA,MAAAxE,SAAA,CAAAwE,SAAA,IAAGJ,YAAY,IAAE,CAAA5G,MAAc,CAAAgH,SAAA,CAAAxG,MAAA,GAAAwG,SAAA,IAAAxE,SAAA,CACjH,GAAI,CAAAkO,KAAa,CACjB,GAAI,CAAAlK,KAAa,CACjB,GAAI,CAAAmK,aAAsC,CAAG,EAAE,CAC/C,OAAQ3Q,MAAM,CAAC4B,IAAI,EACf,IAAK,CAAA1C,UAAU,CAAC0C,IAAI,CAChB8O,KAAK,CAAG1Q,MAAM,CAACgC,KAAK,CACpBwE,KAAK,CAAGvC,QAAQ,CAChB3F,GAAG,CAACsS,KAAK,CAACF,KAAK,EAAE,CAAC,CAAE,uBAAuB,CAAE1Q,MAAM,CAAC,CACpD,MAAO0Q,KAAK,EAAE,CAAE,CACZ,GAAM,CAAAG,MAAK,CAAG/R,YAAY,CAACV,KAAK,CAACkC,OAAO,CAAC,CAACwQ,QAAQ,CAACC,GAAG,CAAC,CAAC,CACxDJ,aAAa,CAACtO,IAAI,CAACwO,MAAK,CAAC,CACzBrK,KAAK,CAAGwK,IAAI,CAACxK,KAAK,CAAEqK,MAAK,CAAC,CAC9B,CACArK,KAAK,CAACgC,mBAAmB,CAAGmI,aAAa,CAACM,OAAO,CAAE,SAAAlI,CAAC,QAAI,CAAAN,MAAM,CAACC,IAAI,CAAC,CAAAK,CAAC,SAADA,CAAC,iBAADA,CAAC,CAAErB,QAAQ,GAAE,CAAC,CAAC,CAAC,GAAC,CACrF;AACA,MAAO,CAAAlB,KAAK,CAEhB,IAAK,CAAAvH,UAAU,CAAC2C,IAAI,CAChB8O,KAAK,CAAG1Q,MAAM,CAACgC,KAAK,CACpBwE,KAAK,CAAGvC,QAAQ,CAChB3F,GAAG,CAACsS,KAAK,CAACF,KAAK,EAAE,CAAC,CAAE,uBAAuB,CAAE1Q,MAAM,CAAC,CACpD,MAAO0Q,KAAK,EAAE,CAAE,CACZ,GAAM,CAAAG,OAAK,CAAG/R,YAAY,CAACV,KAAK,CAACkC,OAAO,CAAC,CAAC4Q,QAAQ,CAACH,GAAG,CAAC,CAAC,CACxDJ,aAAa,CAACtO,IAAI,CAACwO,OAAK,CAAC,CACzBrK,KAAK,CAAGwK,IAAI,CAACxK,KAAK,CAAEqK,OAAK,CAAE,KAAK,CAAC,CACrC,CACArK,KAAK,CAACgC,mBAAmB,CAAGmI,aAAa,CAACM,OAAO,CAAE,SAAAlI,CAAC,QAAI,CAAAN,MAAM,CAACC,IAAI,CAAC,CAAAK,CAAC,SAADA,CAAC,iBAADA,CAAC,CAAErB,QAAQ,GAAE,CAAC,CAAC,CAAC,GAAC,CACrF;AACA,MAAO,CAAAlB,KAAK,CAChB;AACA;AACA,QACI,GAAI,CAAAgB,GAAG,CAAG2J,SAAS,CAAClN,QAAQ,CAAEjE,MAAM,CAAC,CACrC,GAAIwH,GAAG,GAAKvD,QAAQ,CAAE,MAAO,CAAAuD,GAAG,CAChC;AACA,GAAI,CAAAqJ,KAAK,CAAIhR,CAAC,CAACuR,WAAW,CAAC5J,GAAG,CAAEvD,QAAQ,CAAC,CACzC,GAAI,CAACoN,qBAAqB,CAACR,KAAK,CAAC,CAAE,MAAO,CAAArJ,GAAG,CAC7C;AACA,GAAIvD,QAAQ,GAAK,IAAI,CAAEnF,YAAY,CAACV,KAAK,CAACkC,OAAO,CAAC,CAACwQ,QAAQ,CAACzO,IAAI,CAACwO,KAAK,CAAC,CACvE,MAAO,CAAArJ,GAAG,CAClB,CACJ,CAEA,QAAS,CAAA6J,qBAAqBA,CAACR,KAAsB,CAAW,CAC5D,GAAI,CAAC/R,YAAY,CAACwS,kBAAkB,CAAE,MAAO,MAAK,CAClD,GAAI7I,MAAM,CAACC,IAAI,CAACmI,KAAK,CAAC,CAACrQ,MAAM,GAAK,CAAC,CAAE,CACjC,GAAI,UAAU,EAAI,CAAAqQ,KAAK,CAAE,MAAO,MAAK,CACrC,GAAI,eAAe,EAAI,CAAAA,KAAK,CAAE,MAAO,MAAK,CAC1C,GAAI,aAAa,EAAI,CAAAA,KAAK,CAAE,MAAO,MAAK,CAC5C,CACA,MAAO,KAAI,CACf,CACA,QAAS,CAAAG,IAAIA,CAACxK,KAAa,CAAEqK,KAA0B,CAAyB,IAAvB,CAAAU,MAAM,CAAAvK,SAAA,CAAAxG,MAAA,IAAAwG,SAAA,MAAAxE,SAAA,CAAAwE,SAAA,IAAG,IAAI,CAClE,GAAI,CAAC6J,KAAK,CAAE,MAAO,CAAArK,KAAK,CACxB,GAAI,CAAAgL,WAAmB,CAAAnR,aAAA,IAAOmG,KAAK,CAAW,CAC9C;AACA;AACAiL,aAAa,CAACZ,KAAK,CAAEW,WAAW,CAAC,CACjC,GAAID,MAAM,CAAEzS,YAAY,CAACV,KAAK,CAACkC,OAAO,CAAC,CAAC4Q,QAAQ,CAAC7O,IAAI,CAAExC,CAAC,CAACuR,WAAW,CAACI,WAAW,CAAEhL,KAAK,CAAE,CAAC,CAAE;AAAA,IACvF,CAAA1H,YAAY,CAACV,KAAK,CAACkC,OAAO,CAAC,CAACwQ,QAAQ,CAACzO,IAAI,CAAExC,CAAC,CAACuR,WAAW,CAACI,WAAW,CAAEhL,KAAK,CAAE,CAAC,CAAE;AACrF,MAAO,CAAAgL,WAAW,CACtB,CAEA,QAAS,CAAAC,aAAaA,CAACC,UAAmB,CAAEC,UAAmB,CAAQ,CACnE;AACA,IAAK,GAAI,CAAA9Q,GAAG,GAAI,CAAA6Q,UAAU,CAAE,CACxB,GAAI,CAAAb,KAAK,CAAGa,UAAU,CAAC7Q,GAAG,CAAC,CAC3BoF,OAAO,CAACC,GAAG,CAAC,SAAS,CAAE,CAAC2K,KAAK,CAALA,KAAK,CAAEhQ,GAAG,CAAHA,GAAG,CAAE6Q,UAAU,CAAVA,UAAU,CAAEC,UAAU,CAAVA,UAAU,CAAC,CAAC,CAC5D,GAAI9Q,GAAG,CAAC4B,OAAO,CAAC,IAAI,CAAC,GAAK,CAAC,CAAE,CAAE,MAAO,CAAAkP,UAAU,CAAC9Q,GAAG,CAACyE,SAAS,CAAC,CAAC,CAAC,CAAC,CAAE,SAAU,CAC9E,GAAI,MAAO,CAAAuL,KAAK,GAAK,QAAQ,CAAE,CAC/B;AACIc,UAAU,CAAC9Q,GAAG,CAAC,CAAAR,aAAA,IAAOsR,UAAU,CAAC9Q,GAAG,CAAC,CAAC,CACtC4Q,aAAa,CAACC,UAAU,CAAC7Q,GAAG,CAAC,CAAE8Q,UAAU,CAAC9Q,GAAG,CAAC,CAAC,CAAE,CAAC,IACjD,CAAE8Q,UAAU,CAAC9Q,GAAG,CAAC,CAAGgQ,KAAK,CAAE,CACpC,CACJ,CAEA,QAAS,CAAAM,SAAS,6CAAAA,CAAA,CAAsG,IAAxD,CAAAlN,QAAgB,CAAA+C,SAAA,CAAAxG,MAAA,IAAAwG,SAAA,MAAAxE,SAAA,CAAAwE,SAAA,IAAGJ,YAAY,IAAE,CAAA5G,MAAc,CAAAgH,SAAA,CAAAxG,MAAA,GAAAwG,SAAA,IAAAxE,SAAA,CAC3G,GAAI,CAACyB,QAAQ,CAAE,CAAEA,QAAQ,CAAG2C,YAAY,CAAGzI,MAAM,CAACuH,GAAG,CAAC,CAAC,CAAE,CACzD,GAAI,CAAAkM,EAAmB,CACvB;AACA,GAAI,CAAC/K,WAAW,CAAE,CACd;AACAA,WAAW,CAAG,IAAI,CACtB,CACA,GAAI,CAAE5C,QAAQ,CAAS4N,SAAS,CAAE,CAC9B;AACA;AAAA,CACF;AACF,OAAQ7R,MAAM,CAAC4B,IAAI,EACf,IAAK,CAAA7D,eAAe,CAAC6D,IAAI,CAAEgQ,EAAE,CAAG5R,MAAyB,CAAE,MAC3D,IAAK,CAAAhB,UAAU,CAAC4C,IAAI,CACpB,QACI,GAAI5B,MAAM,CAAC4B,IAAI,CAACa,OAAO,CAAC,UAAU,CAAC,GAAK,CAAC,CAAE,CACvC;AACA,MAAO,CAAAwB,QAAQ,CACnB,CACA2N,EAAE,CAAG,GAAI,CAAA7T,eAAe,CAAC,CAACiC,MAAM,CAAC,CAAE,KAAK,CAAC,CACzC,MACR,CACA,GAAI,CAAAwH,GAAG,CAAGxD,sBAAsB,CAACC,QAAQ,CAAE2N,EAAE,CAAC,CAC9C;AACJ;AACA;AACA,OACI,MAAO,CAAApK,GAAG,CACd,CACA,QAAS,CAAAsK,aAAaA,CAACC,KAA2C,CAAC,CAC/DpT,sBAAsB,CAACqT,YAAY,CAC/B,GAAI,CAAA5S,UAAU,CAAkC2S,KAAK,CAAE,YAAY,CAAC,CAC/DE,sBAAsB,CAAC,OAAO,CAAC,CACxC;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2FACA,CACA;AACA,QAAS,CAAAC,gBAAgBA,CAACC,IAAmD,CAAEC,IAAmD,CAAE,CAChI,IAAK,GAAI,CAAAC,KAAK,GAAI,CAAAF,IAAI,CAAE,CACpB,OAAQE,KAAK,EACT,IAAK,qBAAqB,CAAE,SAC5B,IAAK,IAAI,CAAE,SACX,IAAK,OAAO,CAAE,SACd,QAAS,MACb,CACA,GAAI,CAACA,KAAK,CAAC,CAAC,CAAC,EAAI,EAAE,EAAE9M,WAAW,CAAC,CAAC,GAAK8M,KAAK,CAAC,CAAC,CAAC,CAAE,SAAU;AAC3D,GAAI,CAAAC,OAAO,CAAGD,KAAK,CAAC/M,SAAS,CAAC,CAAC,CAAC,CAChC,GAAI,CAAAyD,CAAC,CAAGoJ,IAAI,CAACE,KAAK,CAAC,CACnB,GAAI,CAAAE,CAAC,CAAGH,IAAI,CAAC,GAAG,CAACE,OAAO,CAAC,CACzB,GAAI,CAACvJ,CAAC,EAAE,CAACwJ,CAAC,CAAEtM,OAAO,CAACiB,KAAK,CAAC,uBAAuB,CAAE,CAAC6B,CAAC,CAADA,CAAC,CAAEwJ,CAAC,CAADA,CAAC,CAAC,CAAC,CAC1DxJ,CAAC,CAACyJ,KAAK,CAAGD,CAAC,CACX,GAAI,CAACA,CAAC,CAAEtM,OAAO,CAACiB,KAAK,CAAC,8CAA8C,CAAEqL,CAAC,CAAExJ,CAAC,CAAC,CAC3E;AACAA,CAAC,CAAC0J,SAAS,CAAG,GAAI,CAAAF,CAAC,CAAC,KAAK,CAAC,CAC1BxJ,CAAC,CAAC2J,SAAS,CAAG3J,CAAC,CAEfwJ,CAAC,CAACC,KAAK,CAAGzJ,CAAC,CAACyJ,KAAK,CACjBD,CAAC,CAACE,SAAS,CAAG1J,CAAC,CAAC0J,SAAS,CACzBF,CAAC,CAACG,SAAS,CAAG3J,CAAC,CAAC2J,SAAS,CAEzB;AACA;AACA;AACJ,CACJ,CAEA,eAAsB,CAAAC,gBAAgBA,CAAA,SAAAC,iBAAA,CAAArO,KAAA,MAAAyC,SAAA,GAsCrC,SAAA4L,kBAAA,EAAAA,iBAAA,CAAAC,iBAAA,cAAAC,mBAAA,CAAAC,IAAA,CAtCM,SAAAC,QAAA,MAAAC,WAAA,CAAAC,WAAA,CAAA9N,IAAA,CAAA+N,IAAA,QAAAL,mBAAA,CAAAM,IAAA,UAAAC,SAAAC,QAAA,kBAAAA,QAAA,CAAAC,IAAA,CAAAD,QAAA,CAAAE,IAAA,SACH1U,YAAY,CAACV,KAAK,CAACkC,OAAO,CAAC,CAAG,CAAC4Q,QAAQ,CAAE,EAAE,CAAEJ,QAAQ,CAAE,EAAE,CAAC,CAC1DnS,sBAAsB,CAAC8U,UAAU,CAAC,CAAC,CAC/BR,WAA0D,CAAG,CAAC,CAAC,CAC/DC,WAA0D,CAAG,CAAC,CAAC,CAAAI,QAAA,CAAAI,EAAA,CAAAZ,mBAAA,CAAApK,IAAA,CAClD/J,sBAAsB,CAACgV,OAAO,aAAAL,QAAA,CAAAM,EAAA,CAAAN,QAAA,CAAAI,EAAA,IAAAnQ,IAAA,EAAA+P,QAAA,CAAAE,IAAA,WAAtCpO,IAAI,CAAAkO,QAAA,CAAAM,EAAA,CAAA5R,KAAA,CAAAsR,QAAA,CAAAO,EAAA,CACFzO,IAAI,CAAC,CAAC,CAAC,CAAAkO,QAAA,CAAAE,IAAA,CAAAF,QAAA,CAAAO,EAAA,GAEL,GAAG,IAAAP,QAAA,CAAAO,EAAA,GACH,GAAG,4BAAAP,QAAA,CAAAQ,MAAA,qBADEb,WAAW,CAAC7N,IAAI,CAAC,CAAGzG,sBAAsB,CAACgV,OAAO,CAACvO,IAAI,CAA8B,CAAC,OAAAkO,QAAA,CAAAQ,MAAA,qBACtFZ,WAAW,CAAC9N,IAAI,CAAC,CAAGzG,sBAAsB,CAACgV,OAAO,CAACvO,IAAI,CAA8B,CAAC,OAAAkO,QAAA,CAAAQ,MAAA,qBAAAR,QAAA,CAAAE,IAAA,iBAGxG;AACJ;AACA;AACA;AACA;AACA;AACA,mHAEItB,gBAAgB,CAACe,WAAW,CAAEC,WAAW,CAAC,CAC1CpB,aAAa,CAACnT,sBAAsB,CAACoV,GAAG,CAAC,oBAAoB,CAAC,CAAC,CAAC;AAChEpU,OAAO,CAACqU,cAAc,CAAA3T,aAAA,CAAAA,aAAA,EAAI4T,CAAC,CAAEtU,OAAO,CAACsU,CAAC,CAAE5V,OAAO,CAAPA,OAAO,CAAEU,KAAK,CAAEA,KAAK,CAAEO,SAAS,CAATA,SAAS,EAAKX,sBAAsB,CAACuV,uBAAuB,CAAC,CAAC,EAAKvU,OAAO,CAACwU,UAAU,CAAC,CACrJ;AAEA;AACAC,UAAU,CACN,iBAAK,CAAAH,CAAC,CAACI,QAAQ,CAAC,CAACC,EAAE,CAAC,SAAS,CACzB,SAAC5Q,CAAe,QAAK,CAAA/E,sBAAsB,CAACoV,GAAG,CAA0B,kBAAkB,CAAC,CAACQ,WAAW,CAAC7Q,CAAC,CAAC,GAAC,GAChH;AACA,CACJ,CAAC,CACDvF,MAAM,CAACqW,IAAI,CAAC,CAAC,CACPrB,IAAI,CAAG3T,OAAO,CAACiV,IAAI,CAAQ,MAAM,CAAC,IACpCtB,IAAI,EAAAG,QAAA,CAAAE,IAAA,kBAAAF,QAAA,CAAAQ,MAAA,mBACR1V,KAAK,CAACsH,GAAG,CAACyN,IAAI,CAACuB,QAAQ,CAAEvB,IAAI,CAACnO,EAAE,CAAC,CACjC5G,KAAK,CAACkC,OAAO,CAAG6S,IAAI,CAACnO,EAAE,CAACsO,QAAA,CAAAE,IAAA,UAClB,CAAA/T,WAAW,CAACkV,MAAM,CAAC,CAAC,0BAAArB,QAAA,CAAAsB,IAAA,OAAA5B,OAAA,GAC7B,UAAAJ,iBAAA,CAAArO,KAAA,MAAAyC,SAAA"},"metadata":{},"sourceType":"module"}