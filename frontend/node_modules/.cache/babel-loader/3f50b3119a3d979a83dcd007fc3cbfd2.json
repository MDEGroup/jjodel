{"ast":null,"code":"var _class, _class2, _class3, _class4, _class5, _class6, _class7, _class8, _class9, _class10, _class11, _class12, _class14, _class15, _class16, _class17, _class18;\nimport { Mixin } from \"ts-mixer\";\n\n// import type {Pointer} from \"./typeconverter\";\n\nimport { Action, BEGIN, CreateElementAction, DeleteElementAction, END, GraphPoint, GraphSize, Log, SetFieldAction, SetRootFieldAction, store, U } from \"./index\";\nvar windoww = window;\n// qui dichiarazioni di tipi che non sono importabili con \"import type\", ma che devono essere davvero importate a run-time (eg. per fare un \"extend\", chiamare un costruttore o usare un metodo statico)\n\nconsole.warn('ts loading classes');\n\n// annotation @RuntimeAccessible\n// import {store} from \"../redux/createStore\";\n\nclass AbstractMixedClass {\n  // superclass!: Dictionary<DocString<'parent class name', Class>>;\n\n  // static [key: string]: any;\n  static init_constructor() {}\n}\nAbstractMixedClass.logic = void 0;\nAbstractMixedClass.structure = void 0;\nAbstractMixedClass.singleton = void 0;\nexport class RuntimeAccessibleClass extends AbstractMixedClass {\n  static fixStatics() {\n    // problem: se lo statico è un valore primitivo ne genera una copia.\n    for (let classs of Object.values(RuntimeAccessibleClass.annotatedClasses)) {\n      let gclass = classs;\n      console.log('fix statics', {\n        gclass,\n        s: gclass.s\n      });\n      for (let statickey in gclass.s) {\n        gclass[statickey] = gclass.s[statickey];\n      }\n    }\n  }\n  // static allRuntimeClasses: string[] = [];\n\n  static getAllNames() {\n    let annotated = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    return Object.keys(annotated ? RuntimeAccessibleClass.annotatedClasses : RuntimeAccessibleClass.classes);\n  }\n  static getAllClasses() {\n    let annotated = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    return Object.values(annotated ? RuntimeAccessibleClass.annotatedClasses : RuntimeAccessibleClass.classes);\n  }\n  static getAllClassesDictionary() {\n    let annotated = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    return annotated ? RuntimeAccessibleClass.annotatedClasses : RuntimeAccessibleClass.classes;\n  }\n  static wrapAll(data, baseObjInLookup) {\n    let path = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n    let canThrow = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    let state = arguments.length > 4 ? arguments[4] : undefined;\n    if (!Array.isArray(data)) return [];\n    return data.map(d => DPointerTargetable.wrap(d, baseObjInLookup, path, canThrow, state));\n  }\n  static wrap(data, baseObjInLookup) {\n    let path = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n    let canThrow = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    let state = arguments.length > 4 ? arguments[4] : undefined;\n    if (!data || data.__isProxy) return data;\n    if (typeof data === 'string') {\n      if (!state) state = windoww.store.getState();\n      data = state.idlookup[data];\n      if (!data) {\n        if (canThrow) return windoww.Log.exx('Cannot wrap:', {\n          data,\n          baseObjInLookup,\n          path\n        });else return undefined;\n      }\n    }\n    if (Array.isArray(data)) {\n      console.error('use WrapAll instead for arrays', {\n        data,\n        baseObjInLookup,\n        path,\n        canThrow\n      });\n      throw new Error(\"use WrapAll instead for arrays\");\n    }\n    if (!data) return data;\n    // console.log('ProxyWrapping:', {data, baseObjInLookup, path});\n    return new Proxy(data, new windoww.TargetableProxyHandler(data, baseObjInLookup, path));\n  }\n  /*\r\n      static mapWrap2<D extends DPointerTargetable, L extends LPointerTargetable>(map: RuntimeAccessibleClass, container: D, baseObjInLookup?: DPointerTargetable, path: string = ''): L{\r\n          if (!map || (map as any).__isProxy) return map as any;\r\n          if (typeof container === 'string') {\r\n              container = store.getState().idlookup[container] as unknown as D;\r\n              if (!container) { return Log.exx('Cannot wrap map:', {map, container, baseObjInLookup, path}); }\r\n          }\r\n          // console.log('ProxyWrapping:', {data, baseObjInLookup, path});\r\n          return new Proxy(map, new MapProxyHandler(map, baseObjInLookup, path));\r\n      }\r\n    */\n\n  static mapWrap(data, baseObjInLookup, path) {\n    let subMapKeys = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];\n    if (!data || data.__isProxy) return data;\n    // console.error('GETMAP', {data, logicContext, path});\n    return new Proxy(data, new windoww.MapProxyHandler(data, baseObjInLookup, path));\n  }\n  constructor() {\n    super();\n    // RuntimeAccessibleClass.init_constructor(this, ...a);\n    // this.className = this.constructor.name;\n    // nb: per i mixin questo settaggio viene sovrascritto. perchè il mixin crea le 2 classi ereditate separatamente con i loro costruttori e le incrocia. quindi devo settarlo dall'annotazione @ tramite prototype\n    // RuntimeAccessibleClass.allRuntimeClasses.push(this.className);\n    this.className = void 0;\n  }\n  static init_constructor(thiss) {\n\n    // this.className = this.constructor.name;\n    // let finalObject = this;\n    // if (finalObject.constructor.name === \"DVoidVertex\" || finalObject.constructor.name === \"DGraphElement\") { let breakp = true; }\n    // this.init0(...arguments);\n    // thiss.className = this.name;\n  }\n  static get(dclassname) {\n    let annotated = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    return (annotated ? RuntimeAccessibleClass.annotatedClasses : this.classes)[dclassname];\n  }\n  static extends(className, superClassName) {\n    let returnIfEqual = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    let superclass = RuntimeAccessibleClass.get(superClassName);\n    const thisclass = RuntimeAccessibleClass.get(className);\n    if (superclass === thisclass) return returnIfEqual;\n    if (!superclass || !thisclass) return false;\n    return thisclass instanceof superclass; // todo: check if works with constructors\n  }\n  getAllPrototypeSuperClasses() {\n    let currentlevel = this;\n    let ret = [];\n    while (true) {\n      if (!currentlevel) break;\n      ret.push(currentlevel);\n      // @ts-ignore\n      currentlevel = currentlevel.__proto__;\n    }\n    console.log('constructor chain:', ret);\n    return ret;\n  }\n  /*initBase(){\r\n      let superclasses = this.getAllPrototypeSuperClasses();\r\n      for (let sc of superclasses) {\r\n          if (!sc.hasOwnProperty('init0')) continue;\r\n          console.log('initbase calling ', {thiss: this, sc, init0: sc.init0, args:sc.constructorArguments});\r\n          sc.init0.apply(this, ...(sc.constructorArguments || []));\r\n      }\r\n  }*/\n  // protected abstract init(...constructorParameters: any): void;\n  // NB: per colpa della limitazione #3 di ts-mixer,\n  // DEVO chiamare init su ogni oggetto per settargli il corretto this.className, altrimenti prende quello dell'ultima superclasse\n  /*protected init0(...constructorParameters: any): void {\r\n      let a = this;\r\n      let finalObject = this;\r\n      console.log('creation of___ ', {thiss: this, finalObject});\r\n      if (finalObject.constructor.name === \"DVoidVertex\" || finalObject.constructor.name === \"DGraphElement\") {\r\n          let breakp = true; }\r\n        (window as any)[finalObject.constructor.name] =\r\n          RuntimeAccessibleClass.classes[finalObject.constructor.name] = finalObject.constructor as any;\r\n      // @ts-ignore\r\n      // delete this.className;\r\n      this.className = (finalObject as any).__proto__.className;\r\n  }*/\n}\nRuntimeAccessibleClass.classes = {};\nRuntimeAccessibleClass.annotatedClasses = {};\nexport function Obsolete(constructor) {\n  return constructor;\n}\n_c = Obsolete;\nexport function Leaf(constructor) {\n  return constructor;\n}\n_c2 = Leaf;\nexport function Node(constructor) {\n  return constructor;\n}\n_c3 = Node;\nexport function Abstract(constructor) {\n  return constructor;\n}\n_c4 = Abstract;\nexport function Instantiable(constructor, instanceConstructor) {\n  return constructor;\n} // for m2 cklasses that have m1 instances\n_c5 = Instantiable;\nexport function RuntimeAccessible(constructor) {\n  // console.log('DecoratorTest', {constructor, arguments});\n  // @ts-ignore\n  RuntimeAccessibleClass.classes[constructor.name] = constructor;\n  if (!window[constructor.name]) window[constructor.name] = constructor;\n  constructor.prototype.className = constructor.name;\n  //constructor.prototype.$$typeof = constructor.name;\n  //constructor.prototype.typeName = constructor.name;\n  constructor.staticClassName = constructor.name;\n  // @ts-ignore\n  console.log('runtimeaccessible annotation:', {\n    thiss: this,\n    constructor\n  });\n  //    const classnameFixedConstructor = constructor; //  function (...args) { let obj = new constructor(...args); obj.init?.(); obj.init0?.(); return obj; }\n\n  // @ts-ignore\n  let outerthis = this;\n  // @ts-ignore\n  const classnameFixedConstructorDoNotRenameWithoutSearchStrings = function () {\n    var _obj$initBase;\n    // @ts-ignore\n    console.log('runtimeaccessible annotation inner:', {\n      thiss: this,\n      outerthis,\n      constructor\n    });\n    // @ts-ignore\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    let obj = new constructor(...args);\n    obj.classNameFromAnnotation = constructor.name;\n    obj.className = constructor.name;\n    //obj.prototype.$$typeof = constructor.name;\n    // obj.prototype.typeName = constructor.name;\n    // obj.init?.();\n    // obj.init0?.();\n    (_obj$initBase = obj.initBase) === null || _obj$initBase === void 0 ? void 0 : _obj$initBase.call(obj);\n    // @ts-ignore\n    console.log('runtimeaccessible annotation inner end:', {\n      thiss: this,\n      outerthis,\n      constructor,\n      obj\n    });\n    return obj;\n  };\n  RuntimeAccessibleClass.annotatedClasses[constructor.name] = classnameFixedConstructorDoNotRenameWithoutSearchStrings;\n  for (let key in constructor) classnameFixedConstructorDoNotRenameWithoutSearchStrings[key] = constructor[key];\n  // constructor.constructor = classnameFixedConstructorDoNotRenameWithoutSearchStrings; return constructor;\n\n  // @ts-ignore\n  // for (let staticKey of constructor as GObject) { classnameFixedConstructorDoNotRenameWithoutSearchStrings[staticKey] = constructor[staticKey]; }\n  classnameFixedConstructorDoNotRenameWithoutSearchStrings.prototype = constructor.prototype;\n  classnameFixedConstructorDoNotRenameWithoutSearchStrings.prototype.constructor = constructor.prototype.constructor;\n\n  // required for inheriting static methods\n  classnameFixedConstructorDoNotRenameWithoutSearchStrings.__proto__ = constructor.__proto__;\n  classnameFixedConstructorDoNotRenameWithoutSearchStrings.s = constructor;\n  // return classnameFixedConstructorDoNotRenameWithoutSearchStrings as any;\n  return constructor;\n}\n_c6 = RuntimeAccessible;\nwindow.RuntimeAccessibleClass = RuntimeAccessibleClass;\n// todo: problema: per creare un PointerTargetable ho bisogno dell'userid, e devo generarlo prima che venga generato l'initialState... dovrebbe venir servito con la pagina dal server. o passato come navigation props dalla pagina di login\n\n// export type DtoW<DX extends GObject, WX = Omit<DtoW0<DX>, 'id'>> = WX;\n\nlet canFireActions = true;\nexport let Constructors = RuntimeAccessible(_class = (_class2 = class Constructors {\n  constructor(t, father) {\n    let persist = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    let fatherType = arguments.length > 3 ? arguments[3] : undefined;\n    this.thiss = void 0;\n    this.persist = void 0;\n    this.callbacks = void 0;\n    this.fatherType = void 0;\n    persist = persist && canFireActions;\n    this.thiss = t;\n    this.persist = persist;\n    this.callbacks = [];\n    if (this.thiss.hasOwnProperty(\"father\")) {\n      this.thiss.father = father;\n      persist && father && SetFieldAction.new(father, \"pointedBy\", PointedBy.fromID(t.id, \"father\"), '+=');\n    }\n    this.fatherType = fatherType;\n    if (this.persist) BEGIN();\n  }\n  static pause() {\n    canFireActions = false;\n  }\n  static resume() {\n    canFireActions = true;\n  }\n  // start(thiss: any): this { this.thiss = thiss; return this; }\n  end(simpledatacallback) {\n    if (simpledatacallback) simpledatacallback(this.thiss); // callback for setting primitive types, not pointers not context-dependant values (name being potentially invalid / chosen according to parent)\n    if (!this.persist) return this.thiss;\n    setTimeout(() => {\n      for (let cb of this.callbacks) cb();\n    }, 0);\n    END([CreateElementAction.new(this.thiss, true)]);\n    return this.thiss;\n  }\n  DModelElement() {\n    return this;\n  }\n  DClassifier() {\n    return this;\n  }\n  DParameter() {\n    let thiss = this.thiss;\n    this.persist && thiss.father && SetFieldAction.new(thiss.father, \"parameters\", thiss.id, '+=', true);\n    return this;\n  }\n  DStructuralFeature() {\n    if (this.thiss.className === 'DOperation') return this;\n    if (!this.persist) return this;\n    let thiss = this.thiss;\n    const _DClass = windoww.DClass;\n    const _DValue = windoww.DValue;\n    let targets = [_DClass.fromPointer(thiss.father)];\n    let alreadyParsed = {};\n    while (targets.length) {\n      let nextTargets = [];\n      for (let target of targets) {\n        if (alreadyParsed[target.id]) continue;\n        alreadyParsed[target.id] = target;\n        for (let ext of target.extendedBy) nextTargets.push(_DClass.fromPointer(ext));\n      }\n      targets = nextTargets;\n    }\n    this.persist && this.callbacks.push(() => {\n      for (let pointer in alreadyParsed) {\n        for (let instance of alreadyParsed[pointer].instances) {\n          _DValue.new(thiss.name, thiss.id, undefined, instance);\n        }\n      }\n    });\n    return this;\n  }\n  DReference() {\n    let thiss = this.thiss;\n    // update father's collections (pointedby's here are set automatically)\n    this.persist && thiss.father && SetFieldAction.new(thiss.father, \"references\", thiss.id, '+=', true);\n    return this;\n  }\n  DAttribute() {\n    let thiss = this.thiss;\n    // update father's collections (pointedby's here are set automatically)\n    console.log('dattrmake', {\n      persist: this.persist,\n      father: thiss.father,\n      thiss,\n      id: thiss.id\n    });\n    this.persist && thiss.father && SetFieldAction.new(thiss.father, \"attributes\", thiss.id, '+=', true);\n    return this;\n  }\n  DDataType() {\n    return this;\n  }\n  DObject(instanceoff) {\n    let thiss = this.thiss;\n    if (this.persist && thiss.father) {\n      if (this.fatherType.name === \"DModel\") {\n        this.persist && thiss.father && SetFieldAction.new(thiss.father, \"objects\", thiss.id, '+=', true);\n      } else {\n        // object containing object is not in any direct child collection. access through values\n        // this.persist && thiss.father && SetFieldAction.new(thiss.father as Pointer<DObject>, \"subpackages\", thiss.id, '+=', true);\n      }\n    }\n    if (this.persist && instanceoff) this.callbacks.push(() => {\n      LPointerTargetable.wrap(thiss).instanceof = instanceoff;\n    });else thiss.instanceof = instanceoff || null;\n    //old ver: this.persist && instanceoff && SetFieldAction.new(thiss.id, \"instanceof\", instanceoff, undefined, true);\n    // update father's collections (pointedby's here are set automatically)\n    // this.persist && instanceoff && SetFieldAction.new(instanceoff, \"instances\", thiss.id, '+=', true);\n\n    return this;\n  }\n  DValue(instanceoff, val, isMirage) {\n    let thiss = this.thiss;\n    thiss.edges = [];\n    thiss.value = val || [];\n    thiss.instanceof = instanceoff;\n    thiss.isMirage = isMirage || false;\n\n    // update father's collections (pointedby's here are set automatically)\n    if (this.persist && instanceoff) {\n      SetFieldAction.new(thiss.id, \"instanceof\", instanceoff, undefined, true);\n      SetFieldAction.new(instanceoff, \"instances\", thiss.id, '+=', true);\n    } else thiss.instanceof = instanceoff;\n    this.persist && thiss.father && SetFieldAction.new(thiss.father, \"features\", thiss.id, '+=', true);\n    return this;\n  }\n  DAnnotation(source, details) {\n    const thiss = this.thiss;\n    thiss.source = source || '';\n    thiss.details = details || [];\n    if (this.persist && details) {\n      BEGIN();\n      for (let det of details) SetFieldAction.new(det, \"pointedBy\", PointedBy.fromID(thiss.id, \"details\"), '+=');\n      // update father's collections (pointedby's here are set automatically)\n      this.persist && thiss.father && SetFieldAction.new(thiss.father, \"annotations\", thiss.id, '+=', true);\n      END();\n    }\n    return this;\n  }\n  DPointerTargetable() {\n    let isUser = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    let id = arguments.length > 1 ? arguments[1] : undefined;\n    const thiss = this.thiss;\n    thiss.id = id || (isUser ? \"USER\" : DUser.current) + \"_\" + DPointerTargetable.maxID++ + \"_\" + new Date().getTime();\n    thiss.className = thiss.constructor.name;\n    // this.className = thiss.className;\n    if (this.persist) {\n      // no pointedBy\n    }\n    return this;\n  }\n  DUser(id) {\n    const thiss = this.thiss;\n    thiss.id = id ? id : 'USER_' + DPointerTargetable.maxID++ + \"_\" + new Date().getTime();\n    if (this.persist) {\n      // no pointedBy\n    }\n    return this;\n  }\n  DNamedElement(name) {\n    const thiss = this.thiss;\n    thiss.name = name !== undefined ? name || '' : thiss.constructor.name.substring(1) + \" 1\";\n    if (this.persist) {\n      // no pointedBy\n    }\n    return this;\n  }\n  DTypedElement(type) {\n    const thiss = this.thiss;\n    thiss.type = type;\n    if (this.persist) {\n      type && SetFieldAction.new(type, \"pointedBy\", PointedBy.fromID(thiss.id, \"type\"), '+=');\n    }\n    return this;\n  }\n  DPackage(uri, prefix) {\n    const thiss = this.thiss;\n    thiss.uri = uri || ''; // || 'org.jodel-react.username';\n    thiss.prefix = prefix || '';\n    if (this.persist) {\n      // no pointedBy\n      // update father's collections (pointedby's here are set automatically)\n      if (this.persist && thiss.father) {\n        if (this.fatherType.name === \"DModel\") {\n          this.persist && thiss.father && SetFieldAction.new(thiss.father, \"packages\", thiss.id, '+=', true);\n        } else {\n          this.persist && thiss.father && SetFieldAction.new(thiss.father, \"subpackages\", thiss.id, '+=', true);\n        }\n      }\n    }\n    return this;\n  }\n  DModel(instanceoff, isMetamodel) {\n    const thiss = this.thiss;\n    thiss.packages = []; // packages;\n    thiss.instanceof = instanceoff || null;\n    thiss.isMetamodel = isMetamodel || false;\n    if (this.persist) {\n      if (instanceoff) SetFieldAction.new(instanceoff, \"pointedBy\", PointedBy.fromID(thiss.id, \"instanceof\"), '+=');\n      // instanceoff && SetFieldAction.new(instanceoff, 'models', thiss.id, '+=', true);\n      SetRootFieldAction.new(isMetamodel ? \"m2models\" : \"m1models\", thiss.id, \"+=\", true);\n    }\n    return this;\n  }\n  DOperation() {\n    let exceptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    const thiss = this.thiss;\n    // thiss.parameters = parameters;\n    thiss.exceptions = exceptions;\n    if (this.persist) {\n      BEGIN();\n      // if (parameters) for (let par of parameters) SetFieldAction.new(par, \"pointedBy\", PointedBy.fromID(thiss.id, \"parameters\"), '+=');\n      if (exceptions) for (let exc of exceptions) SetFieldAction.new(exc, \"pointedBy\", PointedBy.fromID(thiss.id, \"exceptions\"), '+=');\n      // update father's collections (pointedby's here are set automatically)\n      this.persist && thiss.father && SetFieldAction.new(thiss.father, \"operations\", thiss.id, '+=', true);\n      END();\n    }\n    return this;\n  }\n  DClass() {\n    let isInterface = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    let isAbstract = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    let isPrimitive = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    let partial = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    let partialdefaultname = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : '';\n    const thiss = this.thiss;\n    thiss.interface = isInterface;\n    thiss.abstract = isAbstract;\n    thiss.isPrimitive = isPrimitive;\n    thiss.partial = partial;\n    thiss.partialdefaultname = partialdefaultname;\n    // thiss.isClass = !isPrimitive;\n    // thiss.isEnum = false;\n\n    if (this.persist) {\n      // no pointedBy\n      // update father's collections (pointedby's here are set automatically)\n      this.persist && thiss.father && SetFieldAction.new(thiss.father, \"classifiers\", thiss.id, '+=', true);\n    }\n    return this;\n  }\n  DEnumLiteral() {\n    let value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    const thiss = this.thiss;\n    thiss.value = value;\n    thiss.literal = thiss.name;\n    if (this.persist) {\n      // no pointedBy?\n      // update father's collections (pointedby's here are set automatically)\n      this.persist && thiss.father && SetFieldAction.new(thiss.father, \"literals\", thiss.id, '+=', true);\n    }\n    return this;\n  }\n  DEnumerator( /*set it from DLiteral.new() instead literals: DEnumerator[\"literals\"] = []*/\n  ) {\n    const thiss = this.thiss;\n    // thiss.literals = literals;\n    // thiss.isClass = false;\n    // thiss.isEnum = true;\n    if (this.persist) {\n      // if (literals) for (let lit of literals) SetFieldAction.new(lit, \"pointedBy\", PointedBy.fromID(thiss.id, \"literals\"), '+=');\n      // update father's collections (pointedby's here are set automatically)\n      this.persist && thiss.father && SetFieldAction.new(thiss.father, \"classifiers\", thiss.id, '+=', true);\n    }\n    return this;\n  }\n  DEdgePoint() {\n    return this;\n  }\n  DVoidEdge() {\n    let thiss = this.thiss;\n    thiss.midnodes = [];\n    return this;\n  }\n  DVertex() {\n    return this;\n  }\n  DEdge() {\n    return this;\n  }\n  DExtEdge() {\n    return this;\n  }\n  DRefEdge() {\n    return this;\n  }\n  DGraphElement(model, parentNodeID, parentgraphID, nodeID) {\n    const thiss = this.thiss;\n    if (parentNodeID) thiss.father = parentNodeID;\n    if (parentgraphID) thiss.graph = parentgraphID;\n    thiss.model = model;\n    thiss.subElements = [];\n    if (nodeID) thiss.id = nodeID;\n    if (this.persist) {\n      model && SetFieldAction.new(model, \"pointedBy\", PointedBy.fromID(thiss.id, \"model\"), '+=');\n      parentgraphID && SetFieldAction.new(parentgraphID, \"pointedBy\", PointedBy.fromID(thiss.id, \"graph\"), '+=');\n      parentNodeID && SetFieldAction.new(thiss.father, \"pointedBy\", PointedBy.fromID(thiss.id, \"father\"), '+=');\n      // update collections (pointedby's here are set automatically)\n      parentNodeID && SetFieldAction.new(thiss.father, \"subElements\", thiss.id, '+=', true);\n    }\n    return this;\n  }\n  DViewElement(name, jsxString, defaultVSize) {\n    let usageDeclarations = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '';\n    let constants = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : '';\n    let preRenderFunc = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : '';\n    let appliableToClasses = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : [];\n    let oclApplyCondition = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : '';\n    let priority = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : 1;\n    const thiss = this.thiss;\n    thiss.name = name;\n    thiss.appliableToClasses = appliableToClasses;\n    thiss.jsxString = jsxString;\n    thiss.usageDeclarations = usageDeclarations;\n    thiss.constants = constants;\n    thiss.preRenderFunc = preRenderFunc;\n    // thiss.__transient = new DViewTransientProperties();\n    thiss.subViews = [];\n    thiss.oclApplyCondition = '';\n    thiss.explicitApplicationPriority = priority;\n    thiss.defaultVSize = defaultVSize || new GraphSize(0, 0, 350, 200);\n    thiss.adaptHeight = false;\n    thiss.adaptWidth = false;\n    thiss.width = 200;\n    thiss.height = 100;\n    if (this.persist) {\n      // no pointedBy?\n    }\n    return this;\n  }\n  DViewPoint(name) {\n    const thiss = this.thiss;\n    thiss.name = name;\n    return this;\n  }\n  static DGraph_makeID(modelid) {\n    if (!modelid) {\n      throw new Error(\"graph without model, currently not supported.\");\n      return '_GraphWithoutModel_';\n    }\n    return modelid + '^graph' + Constructors.DGraph_maxID++;\n  }\n  DGraph(model, id) {\n    const thiss = this.thiss;\n    thiss.id = id || Constructors.DGraph_makeID(model);\n    thiss.graph = thiss.id;\n    thiss.zoom = new GraphPoint(1, 1);\n    thiss.graphSize = new GraphSize(0, 0, 0, 0); // GraphSize.apply(this, [0, 0, 0 ,0]);\n    thiss._subMaps = {\n      zoom: true,\n      graphSize: true\n    };\n    if (this.persist) {\n      // no pointedBy?\n    }\n    return this;\n  }\n  DVoidVertex(defaultVSize) {\n    const thiss = this.thiss;\n    thiss.x = defaultVSize.x;\n    thiss.y = defaultVSize.y;\n    thiss.w = defaultVSize.w;\n    thiss.h = defaultVSize.h;\n    if (this.persist) {\n      // no pointedBy?\n    }\n    return this;\n  }\n}, _class2.DGraph_maxID = 0, _class2)) || _class;\n// export const Constructors = new _Constructors();\n\nexport let DPointerTargetable = RuntimeAccessible(_class3 = (_class4 = class DPointerTargetable extends RuntimeAccessibleClass {\n  // pointedBy: DocString<'path in store'>[] = []; // NB: potrebbe contenere puntatori invalidi.\n  // se viene cancellato un intero oggetto A che contiene una lista di puntatori, gli oggetti che puntano ad A rimuovono A dai loro \"poitnedBy\",\n  // ma gli oggetti puntati da A tramite sotto-oggetti o attributi (subviews...) non vengono aggiornati in \"pointedby\"\n\n  static defaultname(startingPrefix, father, metaptr) {\n    let lfather;\n    // startingPrefix = \"model_\", father = ((name: string) => !dmodelnames.includes(name))\n    if (father) {\n      if (typeof father === \"string\" || father.className) {\n        // Pointer or D\n        lfather = LPointerTargetable.wrap(father);\n        if (!lfather) return typeof startingPrefix === \"string\" ? startingPrefix : \"unnamed_elem\"; // can happen during parse when father ptr exist but it's not in store yet. not a prob\n        if (typeof startingPrefix !== \"string\") {\n          let meta = LPointerTargetable.from(metaptr);\n          startingPrefix = startingPrefix(meta);\n        }\n        console.log({\n          father,\n          lfather\n        });\n        const childrenNames = lfather.childrens.map(c => c.name);\n        return U.increaseEndingNumber(startingPrefix + '0', false, false, newname => childrenNames.indexOf(newname) >= 0);\n      } else {\n        let condition = father;\n        return U.increaseEndingNumber(startingPrefix + '0', false, false, condition);\n      }\n    }\n    return startingPrefix + \"1\";\n  }\n  static new() {\n    //father?: Pointer, persist: boolean = false, fatherType?: Constructor, ...a:any): DPointerTargetable {\n    Log.exx(\"cannot instantiate abstract class DPointerTargetable\");\n    return null;\n    // return new Constructors(new DPointerTargetable('dwc'), father, persist, fatherType).DPointerTargetable().end();\n  }\n  constructor(fakearg_detectwrongcalls) {\n    super();\n    this._storePath = void 0;\n    this._subMaps = void 0;\n    this.id = void 0;\n    this.pointedBy = [];\n    if (!fakearg_detectwrongcalls) throw new Error(\"cannot build D-objects using new keyword, use the static D-Class.new method instead\");\n  }\n  static fromL(data) {\n    return data.__raw;\n  }\n  static fromPointer(ptr, s) {\n    s = s || store.getState();\n    if (Array.isArray(ptr)) {\n      return ptr.map(p => DPointerTargetable.fromPointer(p, s));\n    }\n    if (typeof ptr !== \"string\") {\n      var _ptr;\n      ptr = (_ptr = ptr) === null || _ptr === void 0 ? void 0 : _ptr.id;\n    }\n    if (typeof ptr !== \"string\") {\n      throw new Error(\"wrong parameter in DPointerTargetable.fromPointers()\");\n    }\n    return s.idlookup[ptr];\n  }\n  static from(ptr, s) {\n    s = s || store.getState();\n    return s.idlookup[ptr];\n  }\n  static from0(a) {\n    return null;\n  }\n  static writeable(l) {\n    return l;\n  }\n}, _class4.defaultComponent = void 0, _class4.maxID = 0, _class4.logic = void 0, _class4.subclasses = [], _class4._extends = [], _class4)) || _class3;\n/*\r\nlet d0: LClassifier = null as any;\r\nlet ptrr: Pointer<DPackage, 1, 'N', LPackage> = null as any;\r\nlet ptr1: Pointer<DPackage, 1, 1, LPackage> = null as any;\r\nlet dd = DPointerTargetable.from(d0.id);\r\n*/\n\n/*\r\ntype Pack1<D extends DPointerTargetable, L extends LPointerTargetable = DtoL<D>, P extends Pointer<D, 0, 1, L> = Pointer<D, 0, 1, L>, R = {D:D, L:L, P:P} > = P|D|L\r\ntype PackArr<D extends DPointerTargetable, L extends LPointerTargetable = DtoL<D>, P extends Pointer<D, 0, 1, L> = Pointer<D, 0, 1, L> , ARR = Pack1<D>> = (ARR)[];\r\ntype Pack<D extends DPointerTargetable, L extends LPointerTargetable = DtoL<D>, P extends Pointer<D, 0, 1, L> = Pointer<D, 0, 1, L> , ARR = Pack1<D>> = ARR | (ARR)[];*/\n\nexport let Pointers = RuntimeAccessible(_class5 = class Pointers {\n  static filterValid(p) {\n    const pointerval = DPointerTargetable.from(p);\n    if (Array.isArray(pointerval)) return pointerval.filter(p => !!p).map(p => p.id);\n    if (!pointerval) return null;\n    return pointerval.id;\n  }\n  fromArr(val) {\n    if (!val) val = [];\n    if (!Array.isArray(val)) {\n      val = [val];\n    }\n    if (!val.length) {\n      return [];\n    }\n    if (val[0].id) {\n      val = val.filter(v => !!v).map(v => v.id);\n    }\n    return val.filter(v => !!v);\n  }\n  fromm(val) {\n    return !val ? null : val.id;\n  }\n  from0(data) {\n    return null;\n  }\n  static from00(data) {\n    // RET | RET[] {\n    if (Array.isArray(data)) return data.filter(d => !!d).map(d => typeof d === \"string\" ? d : d.id);else return data ? data.id : null;\n  } // stavolta fai infer so D|l.id\n\n  // | {D:any};\n  // | {DD:any};\n  // | {L:any};\n  // | {LL:any};\n  // | {W:any};\n  // | {WW:any};\n  // | {P:any};\n  // | {PP:any};\n  //{TEST1:any};\n  //{TEST111:any};\n  //{TEST0:any};\n  //{TEST0:any};\n  //{TESTARR:any};\n  //{TEST1:any};\n  //{TEST111:any};\n  //{TEST0:any};\n  //{TESTARR:any};\n\n  /*\r\n      public static from(data:undefined): undefined; // | {D:any};\r\n      public static from<DX extends DPointerTargetable | undefined | null>(data:DX): DX extends DPointerTargetable ? DX[\"id\"] : DX; // | {D:any};\r\n      public static from<DX extends DPointerTargetable | undefined | null>(data:DX[]): DX extends DPointerTargetable ? DX[\"id\"][] : DX; // | {DD:any};\r\n      public static from<LX extends LPointerTargetable | undefined | null>(data:LX): LX extends LPointerTargetable ? LX[\"id\"] : LX; // | {L:any};\r\n      public static from<LX extends LPointerTargetable | undefined | null>(data:LX[]): LX extends LPointerTargetable ? LX[\"id\"][] : LX; // | {LL:any};\r\n      public static from<WX extends WPointerTargetable | undefined | null>(data:WX): WX extends WPointerTargetable ? WX[\"id\"] : WX; // | {W:any};\r\n      public static from<WX extends WPointerTargetable | undefined | null>(data:WX[]): WX extends WPointerTargetable ? WX[\"id\"][] : WX; // | {WW:any};\r\n      public static from<PTR extends Pointer<DPointerTargetable, 1, 1, LPointerTargetable> | undefined | null>(data:PTR): PTR extends Pointer<DPointerTargetable, 1, 1, LPointerTargetable> ? PTR : PTR; // | {P:any};\r\n      public static from<PTR extends Pointer<DPointerTargetable, 1, 1, LPointerTargetable> | undefined | null>(data:PTR[]): PTR extends Pointer<DPointerTargetable, 1, 1, LPointerTargetable> ? PTR[] : PTR; // | {PP:any};\r\n      public static from<T extends LPointerTargetable | undefined | null>(data:Pack1<T>): T extends LPointerTargetable ? Pointer<LtoD<T>, 1, 1, T> : T; //{TEST1:any};\r\n      public static from<T extends LPointerTargetable | undefined | null>(data:Pack1<T>[]): T extends LPointerTargetable ? Pointer<LtoD<T>, 1, 1, T>[] : T; //{TEST111:any};\r\n      public static from<T extends LPointerTargetable | undefined | null>(data:Pack<T>): T extends LPointerTargetable ? Pointer<LtoD<T>, 1, 1, T>[] : T; //{TEST0:any};\r\n      public static from<T extends LPointerTargetable | undefined | null>(data:PackArr<T>): T extends LPointerTargetable ? Pointer<LtoD<T>, 1, 1, T>[] : T; //{TESTARR:any};\r\n      // public static from<T extends LPointerTargetable | undefined | null>(data:Pack1<T[]>): T extends LPointerTargetable ? Pointer<LtoD<T>, 1, 1, T> : T; //{TEST1:any};\r\n      // public static from<T extends LPointerTargetable | undefined | null>(data:Pack1<T[]>[]): T extends LPointerTargetable ? Pointer<LtoD<T>, 1, 1, T>[] : T; //{TEST111:any};\r\n      // DDD extends (T extends Pointer<infer D> ? D : 'undefined D'),*/\n\n  //{TEST0:any};\n  // @ts-ignore\n  //{TESTARR:any};\n  // | {Dn:any};\n  // | {Dnn:any};\n\n  // | {Dn0:any};\n\n  // function from<PTR extends Pointer<DPointerTargetable, 1, 1, LPointerTargetable>>(data:unknown | unknown[]): PTR | PTR[] | GObject {\n  static from(data) {\n    if (!data) return null;\n    if (Array.isArray(data)) return data.filter(d => !!d).map(d => typeof d === \"string\" ? d : d.id);\n    return typeof data === \"string\" ? data : data.id;\n  }\n  static isPointer(val) {\n    // todo: must refine this in a safer way\n    return (val === null || val === void 0 ? void 0 : val.includes) ? val.includes(\"Pointer\") : false;\n  }\n}) || _class5;\n/*\r\nexport type Pack1<L extends LPointerTargetable | undefined | null,\r\n    // L extends LPointerTargetable | undefined | null = LL extends LPointerTargetable[] ? LPointerTargetable : null | undefined,\r\n    D extends (L extends LPointerTargetable ? LtoD<L> : undefined | null) = (L extends LPointerTargetable ? LtoD<L> : undefined | null)> =\r\n    L extends LPointerTargetable ? ( D extends DPointerTargetable ? D | L /*| LtoW<L>* / | Pointer<D, 1, 1, L> : L) : undefined;\r\nexport type PackArr<LL extends orArr<LPointerTargetable> | undefined | null,\r\n    L extends LPointerTargetable | undefined | null = LL extends undefined | null ? undefined : unArr<LL>> = Pack1<L>[];\r\nexport type Pack<\r\n    LL extends orArr<LPointerTargetable> | undefined | null,\r\n    L extends unArr<LL> = unArr<LL>,\r\n    // L extends (LL extends orArr<LPointerTargetable> ? LPointerTargetable : undefined | null) = (LL extends orArr<LPointerTargetable> ? unArr<LL> : undefined)\r\n    >\r\n    = LL extends undefined ? undefined : Pack1<L> | PackArr<L>;\r\n*/\n\n/*\r\nlet n: any = null;\r\nlet aa: DClass = n;\r\nlet ptrr = Pointers.from(aa.parent);\r\naa.parent = ptrr;*/\n\nexport let PendingPointedByPaths = RuntimeAccessible(_class6 = (_class7 = class PendingPointedByPaths {\n  // static pendingMoreThanTwice: ParsedAction[] = [];\n\n  // tmp fields, not sure what i need\n  // todo: remove\n  static new(action, oldState) {\n    const ptr = action.value;\n    const target = oldState.idlookup[ptr];\n    let pendingPointedBy = new PendingPointedByPaths(action.path, ptr);\n    pendingPointedBy.action = action;\n    return pendingPointedBy;\n  }\n  constructor(from,\n  // todo 6: how about actions that do not include index but just += -= [] ?\n  to) {\n    this.from = from;\n    this.to = to;\n    this.solveAttempts = 1;\n    this.stackTrace = void 0;\n    this.action = void 0;\n    this.stackTrace = U.getStackTrace();\n  }\n  static attemptimplementationdelete(pb) {\n    let state = store.getState();\n    let objectChain = U.followPath(state, pb.source);\n  }\n  attemptResolve(state) {\n    if (this.canBeResolved(state)) return this.resolve();\n    return null;\n  }\n  resolve() {\n    U.arrayRemoveAll(PendingPointedByPaths.all, this);\n    return Action.parse(SetRootFieldAction.create(\"idlookup.\" + this.to + '.pointedBy', PointedBy.new(this.action.path), '+=', false));\n  }\n  saveForLater() {\n    PendingPointedByPaths.all.push(this);\n  }\n  canBeResolved(state) {\n    this.solveAttempts++;\n    if (this.solveAttempts >= PendingPointedByPaths.maxSolveAttempts) Log.ex(\"pending PointedBy action is not revolved for too long, some pointer was wrongly set up.\", this.stackTrace, this, state);\n    return !!state.idlookup[this.to];\n  }\n  static getSolveableActions(oldState) {\n    let allClone = [...this.all]; // necessary because the array will remove some elements during iteration as they are solved.\n    return allClone.map(p => p.attemptResolve(oldState)).filter(p => !!p);\n  }\n}, _class7.all = [], _class7.maxSolveAttempts = 20, _class7)) || _class6;\nexport let PointedBy = RuntimeAccessible(_class8 = (_class9 = class PointedBy {\n  // elemento da cui parte il puntatore\n  // field: keyof DPointerTargetable;\n  // il bersaglio non c'è qui, perchè è l'oggetto che contiene questo dentro l'array pointedBy\n\n  /*private constructor(source: DPointerTargetable, field: any) {\r\n      this.source = source;\r\n      this.field = field;\r\n  }*/\n\n  static getPath(p) {\n    return p.source.substring(0, p.source.lastIndexOf(\".\"));\n  }\n  static getLastKey(p) {\n    return p.source.substring(p.source.lastIndexOf(\".\"));\n  }\n  static getPathArr(p) {\n    return p.source.split('.');\n  }\n  constructor(source) {\n    this.source = void 0;\n    this.source = source;\n  }\n  static fromID(ptr, field) {\n    // Giordano: add ignore for webpack\n    //@ts-ignore\n    return PointedBy.new(\"idlookup.\" + ptr + \".\" + field);\n  }\n  static new(source) {\n    let modifier = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n    let action = arguments.length > 2 ? arguments[2] : undefined;\n    // let source: DocString<\"full path in store including key\"> = action.path;\n    // if (source.includes(\"true\")) { console.error(this, action); throw new Error(\"mixed a bool\"); }\n    if (modifier) source = source.substring(0, source.length - ((modifier === null || modifier === void 0 ? void 0 : modifier.length) || 0));\n    return new PointedBy(source);\n  }\n  // static new0<D extends DPointerTargetable> (source: D, field: keyof D): PointedBy { return new PointedBy(source, field); }\n\n  static remove(oldValue, action, state) {\n    let casee = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : undefined;\n    if (!oldValue) return state;\n    let oldtarget = state.idlookup[oldValue]; // todo: if += -=\n    if (!oldtarget) return state;\n    let index = -1;\n    let actionpath = action.path.substring(0, action.path.length - ((casee === null || casee === void 0 ? void 0 : casee.length) || 0));\n    for (let i = 0; i < oldtarget.pointedBy.length; i++) {\n      if (oldtarget.pointedBy[i].source === actionpath) {\n        index = i;\n        break;\n      }\n    }\n    if (index >= 0) {\n      state = {\n        ...state\n      };\n      state.idlookup = {\n        ...state.idlookup\n      };\n      state.idlookup[oldValue] = {\n        ...oldtarget,\n        pointedBy: [...oldtarget.pointedBy]\n      };\n      state.idlookup[oldValue].pointedBy.splice(index, 1); // in-place edit\n    }\n    // console.warn('pointedby remove:', {from: oldtarget.pointedBy, to: state.idlookup[oldValue].pointedBy, obj: state.idlookup[oldValue], index, oldValue, actionpath});\n    return state;\n  }\n  static add(newtargetptr, action, state) {\n    let casee = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : undefined;\n    if (!newtargetptr) return state;\n    // todo: if can't be done because newtarget doesn't exist, build an action from this and set it pending.\n    let newtarget = state.idlookup[newtargetptr];\n    if (!newtarget) {\n      PendingPointedByPaths.new(action, state).saveForLater(); // {from: action.path, field: action.field, to: target});\n      return state;\n    }\n    let oldtarget = {\n      ...newtarget,\n      pointedBy: [...newtarget.pointedBy]\n    };\n    state = {\n      ...state\n    };\n    state.idlookup = {\n      ...state.idlookup\n    };\n    state.idlookup[newtargetptr] = {\n      ...newtarget,\n      pointedBy: [...newtarget.pointedBy, PointedBy.new(action.path, casee)]\n    };\n    // console.warn('pointedby add:', {from: oldtarget.pointedBy, to: state.idlookup[newtargetptr].pointedBy, obj: state.idlookup[newtargetptr]});\n    return state;\n  }\n}, _class9.list = [\"father\", \"parent\", \"annotations\", \"packages\", \"type\", \"subpackages\", \"classifiers\", \"exceptions\", \"parameters\", \"defaultValue\", \"instances\", \"operations\", \"features\", \"attributes\", \"references\", \"extends\", \"extendedBy\", \"implements\", \"implementedBy\", \"instanceof\", \"edges\", \"target\", \"opposite\", \"parameters\", \"exceptions\", \"literals\"], _class9)) || _class8;\nexport let LPointerTargetable = RuntimeAccessible(_class10 = (_class11 = class LPointerTargetable extends DPointerTargetable {\n  constructor() {\n    super(...arguments);\n    this.__raw = void 0;\n    this.pointedBy = void 0;\n  }\n  wrongAccessMessage(str) {\n    let msg = \"Method \" + str + \" should not be called directly, attempting to do so should trigger get_\" + str + \"(). This is only a signature for type checking.\";\n    Log.ex(msg);\n    throw new Error(msg);\n  }\n  toString() {\n    throw this.wrongAccessMessage(\"toString\");\n  }\n  get_toString(context) {\n    const data = context.data;\n    return () => data.name ? data.name : data.className.substring(0);\n    // return () => data.id;\n  }\n  cannotSet(field) {\n    return Log.exx('\"' + field + '\" field is read-only', this);\n  }\n  get_id(context) {\n    return context.data.id;\n  }\n  set_id() {\n    return this.cannotSet('id');\n  }\n  _get_default(data, key) {\n    // @ts-ignore\n    return LPointerTargetable.from(data[key]);\n  }\n  delete() {\n    throw this.wrongAccessMessage(\"delete\");\n  }\n  _delete(context) {\n    new DeleteElementAction(context.data);\n  }\n  get_delete(context) {\n    return () => {\n      alert(\"Delete in LPOINTER\");\n      this._delete(context);\n    };\n  }\n  get__extends(superClassName, context) {\n    return RuntimeAccessibleClass.extends(context.data.className, superClassName);\n  }\n\n  /*\r\n  public get_pointedBy(superClassName: string, context: LogicContext<DPointerTargetable>): LPointerTargetable[] {\r\n      let state: GObject = windoww.store.getState();\r\n      function getForemostObjectInPath(path: DocString<'storePath'>): undefined | LPointerTargetable {\r\n          let lastPointableObject: undefined | DPointerTargetable;\r\n          let pathArray = path.split('.');\r\n          for (let key of pathArray) {\r\n              let currentObj: GObject = state[key];\r\n              if (!currentObj) break;\r\n              if (currentObj && currentObj.id && state.idlookup[currentObj.id]) lastPointableObject = state.idlookup[currentObj.id];\r\n          }\r\n          return lastPointableObject && DPointerTargetable.wrap(lastPointableObject);\r\n      }\r\n      return (context.data.pointedBy || []).map(getForemostObjectInPath).filter( lobj => !!lobj) as LPointerTargetable[];\r\n  }*/\n\n  set_pointedBy(val, context) {\n    windoww.Log.exx('pointedBy field should never be directly edited.', {\n      context,\n      val\n    });\n    return false;\n  }\n  static fromD(data) {\n    // return null as any;\n    if (Array.isArray(data)) return LPointerTargetable.wrapAll(data);\n    return LPointerTargetable.wrap(data);\n  }\n  static fromPointer(ptr, state) {\n    // return null as any;\n    if (Array.isArray(ptr)) return LPointerTargetable.wrapAll(ptr, undefined, '', false, state);\n    return LPointerTargetable.wrap(ptr);\n  }\n  static fromArr(ptr) {\n    return LPointerTargetable.from(ptr);\n  }\n  static from(ptr, s) {\n    // return null as any;\n    if (Array.isArray(ptr)) return LPointerTargetable.wrapAll(ptr);\n    return LPointerTargetable.wrap(ptr);\n  }\n\n  // static from0(a: any, ...aa: any): any { return null; }\n}, _class11.subclasses = [], _class11._extends = [], _class11.structure = void 0, _class11.singleton = void 0, _class11)) || _class10;\n/*\r\nlet pttr: Pointer<DClassifier, 0, 1, LClassifier> = null as any;\r\nlet ptrany: Pointer<DClassifier, 0|1, 1|'N'>[] = null as any;\r\nlet ptrarr: Pointer<DClassifier>[] = null as any;\r\nlet ptrarr2: Pointer<DClassifier, 1, 'N'> = null as any;\r\nlet d: DClassifier = null as any;\r\nlet darr: DClassifier[] = null as any;\r\n\r\ntype VoidPtr = null | undefined | '';\r\nfunction dfrom<\r\n    PARAM extends orArr<AnyPointer | VoidPtr>,//orArr<WPointerTargetable | LPointerTargetable | DPointerTargetable | AnyPointer>,\r\n\r\n\r\n    DDD extends (PARAM extends Pointer<infer DD> ? DD : 'undefined_D'),\r\n    LOW extends (PARAM extends Pointer<any, infer LO> ? LO : 'undefined_low'),\r\n    LOW0 extends (PARAM extends Pointer<any, 0, any, any> ? 0 : never),\r\n    LOW1 extends (PARAM extends Pointer<any, 1, any, any> ? 1 : never),\r\n    LOW2 extends (VoidPtr extends PARAM ? 0 | 'first' : (PARAM extends VoidPtr ? 0 | 1 | 'second': 1|'third')),\r\n    UPP extends (PARAM extends Pointer<any, number, infer UP> ? UP : 'undefined_upp'),\r\n    LLL extends (PARAM extends Pointer<any, number, any, infer LL> ? LL : 'undefined_L'),\r\n\r\n\r\n\r\n    ISVOID extends PARAM extends VoidPtr  ? 'isvoid' : never,\r\n    ISARR extends PARAM extends [] ? true : false,\r\n    ISPTR extends (PARAM extends AnyPointer | VoidPtr ? 'ptr' : never),\r\n    ISPTRARR extends (PARAM extends (AnyPointer | VoidPtr)[] | Pointer<DPointerTargetable, 1|0, 'N', LPointerTargetable> ? 'ptr_arr' : never),\r\n    ISD extends (PARAM extends DPointerTargetable ? 'd' : never),\r\n    ISDARR extends (PARAM extends DPointerTargetable[] ? 'd_arr' : never),\r\n    ISL extends (PARAM extends LPointerTargetable ? 'l' : never),\r\n    ISLARR extends (PARAM extends LPointerTargetable[] ? 'l_arr' : never),\r\n    ISW extends (PARAM extends WPointerTargetable ? 'w' : never),\r\n    ISWARR extends (PARAM extends WPointerTargetable[] ? 'w_arr' : never),\r\n    // INFER = {LOW:LOW, UPP:UPP, DDD:DDD, LLL:LLL, LOW2:LOW2},\r\n    INFER = { LOW2:LOW2},\r\n    RET = ISVOID | ISPTR | ISPTRARR | ISD | ISDARR | ISL | ISLARR | ISW | ISWARR | INFER\r\n    >\r\n(ptr: PARAM): RET { return null as any; }\r\nlet Lptr = dfrom(pttr as Pointer<DClassifier, 0, 1, LClassifier> );\r\nlet Lptrany = dfrom(ptrany);\r\nlet Lptrarr = dfrom(ptrarr);\r\nlet Lptrarr2 = dfrom(ptrarr2);\r\nlet Ld = dfrom(d);\r\nlet Ldarr = dfrom(darr);*/\n\nexport let WPointerTargetable = RuntimeAccessible(_class12 = class WPointerTargetable extends DPointerTargetable {\n  constructor() {\n    super(...arguments);\n    this.id = void 0;\n    this._storePath = void 0;\n    this._subMaps = void 0;\n    this.pointedBy = void 0;\n  }\n  // todo: WfromD, WfromL, WfromPointer, Wfrom\n\n  static fromD(data) {\n    return LPointerTargetable.fromD(data);\n  }\n}) || _class12;\nDPointerTargetable.subclasses.push(LPointerTargetable);\nDPointerTargetable.subclasses.push(WPointerTargetable);\nfunction fffff(t) {\n  return null;\n}\nlet a = null;\nlet bbb = LPointerTargetable.from(a);\nlet bb2 = fffff(a);\nexport let DUser = Leaf(_class14 = RuntimeAccessible(_class14 = (_class15 = class DUser extends DPointerTargetable {\n  constructor() {\n    super(...arguments);\n    this.username = '';\n    this.email = '';\n    this.token = '';\n    this.cursorPositionX = 0;\n    this.cursorPositionY = 0;\n    this.id = void 0;\n    this.__isUser = true;\n  } // todo\n  // public static structure: typeof DPointerTargetable;\n  // public static singleton: LPointerTargetable;\n  // necessary to trick duck typing to think this is NOT the superclass of anything that extends PointerTargetable.\n  static new(id) {\n    let triggerActions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    return new Constructors(new DUser('dwc'), undefined, false).DPointerTargetable().DUser(id).end();\n  }\n}, _class15.current = \"Pointer\", _class15.subclasses = [], _class15._extends = [], _class15)) || _class14) || _class14;\nexport let LUser = RuntimeAccessible(_class16 = (_class17 = class LUser extends LPointerTargetable {\n  constructor() {\n    super(...arguments);\n    this.username = void 0;\n    this.email = void 0;\n    this.token = void 0;\n    this.__raw = void 0;\n    this.id = void 0;\n    this.__isUser = void 0;\n    this.cursorPosition = void 0;\n  } // MixOnlyFuncs(DUser, LPointerTargetable)\n  // public static structure: typeof DPointerTargetable;\n  // public static singleton: LPointerTargetable;\n  //todo\n}, _class17.subclasses = [], _class17._extends = [], _class17)) || _class16;\nDPointerTargetable.subclasses.push(DUser);\nLPointerTargetable.subclasses.push(LUser);\nexport let MyError = RuntimeAccessible(_class18 = class MyError extends Error {\n  constructor(message) {\n    // 'Error' breaks prototype chain here\n    super(message);\n    const proto = this.__proto__;\n    for (var _len2 = arguments.length, otherMsg = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n      otherMsg[_key2 - 1] = arguments[_key2];\n    }\n    console.error(proto.constructor.name, message, ...otherMsg);\n    // restore prototype chain\n    const actualProto = new.target.prototype;\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(this, actualProto);\n    } else {\n      this.__proto__ = actualProto;\n    }\n    this.className = this.constructor.name;\n  }\n}) || _class18;\n\n// @RuntimeAccessible\nexport class JsType {\n  constructor(printableTypeName, check, isExclusiveType) {\n    this.printableTypeName = printableTypeName;\n    this.check = check;\n    this.isExclusiveType = isExclusiveType;\n    JsType.all.push(this);\n  }\n  toString() {\n    return this.printableTypeName;\n  }\n  /*\r\n  * example: isObject but not Date, not function...\r\n  * */\n  static isOnlyType(data, type) {\n    return !JsType.getTypes(data, type).length;\n  }\n  static isAnyOfTypes(data) {\n    for (var _len3 = arguments.length, acceptables = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n      acceptables[_key3 - 1] = arguments[_key3];\n    }\n    return !!windoww.Uarr.arrayIntersection(JsType.getTypes(data), acceptables).length;\n  }\n  static getTypes(data, stopIfTypeIsNot) {\n    const ret = [];\n    for (const type of JsType.all) {\n      if (type.check(data)) {\n        ret.push(data);\n        if (stopIfTypeIsNot !== type) {\n          return [];\n        }\n        if (type.isExclusiveType) return ret;\n      }\n    }\n    return ret;\n  }\n\n  /// is...\n  static isObject(data) {\n    return typeof data === \"object\";\n  }\n  static isFunction(data) {\n    return typeof data === \"function\";\n  }\n  static isLambdaFunction(data) {\n    if (!JsType.isFunction(data)) return false;\n    return windoww.U.getFunctionSignatureFromComments(data).isLambda;\n  }\n  static isNonLambdaFunction(data) {\n    return JsType.isFunction(data) && !JsType.isNonLambdaFunction(data);\n  }\n  static isArray(data) {\n    return Array.isArray(data);\n  }\n  static isSymbol(data) {\n    return typeof data === \"symbol\";\n  }\n  static isBoolean(data) {\n    return !!data === data;\n  }\n  static isNumber(data) {\n    return typeof data === \"number\";\n  }\n  static isBigint(data) {\n    return typeof data === \"bigint\";\n  }\n  static isString(data) {\n    return typeof data === \"string\";\n  }\n  static isNull(data) {\n    return data === null;\n  }\n  static isUndefined(data) {\n    return data === undefined;\n  }\n  static isDate(data) {\n    return data instanceof Date;\n  }\n\n  /// as...\n  static asObject(data, fallbackReturn) {\n    return JsType.isObject(data) ? data : fallbackReturn;\n  }\n  static asFunction(data, fallbackReturn) {\n    return JsType.isFunction(data) ? data : fallbackReturn;\n  }\n  static asLambdaFunction(data, fallbackReturn) {\n    return JsType.isLambdaFunction(data) ? data : fallbackReturn;\n  }\n  static asNonLambdaFunction(data, fallbackReturn) {\n    return JsType.isNonLambdaFunction(data) ? data : fallbackReturn;\n  }\n  static asArray(data, fallbackReturn) {\n    return JsType.isArray(data) ? data : fallbackReturn;\n  }\n  static asSymbol(data, fallbackReturn) {\n    return JsType.isSymbol(data) ? data : fallbackReturn;\n  }\n  static asBoolean(data, fallbackReturn) {\n    return JsType.isBoolean(data) ? data : fallbackReturn;\n  }\n  static asNumber(data, fallbackReturn) {\n    return JsType.isNumber(data) ? data : fallbackReturn;\n  }\n  static asBigint(data, fallbackReturn) {\n    return JsType.isBigint(data) ? data : fallbackReturn;\n  }\n  static asString(data, fallbackReturn) {\n    return JsType.isString(data) ? data : fallbackReturn;\n  }\n  static asNull(data, fallbackReturn) {\n    return JsType.isNull(data) ? data : fallbackReturn;\n  }\n  static asUndefined(data, fallbackReturn) {\n    return JsType.isUndefined(data) ? data : fallbackReturn;\n  }\n  static asDate(data, fallbackReturn) {\n    return JsType.isDate(data) ? data : fallbackReturn;\n  }\n  static isPrimitive(data) {\n    return !JsType.isAnyOfTypes(data, JsType.object, JsType.function, JsType.array);\n  }\n}\nJsType.all = [];\nJsType.object = new JsType(\"object\", JsType.isObject, false);\nJsType.function = new JsType(\"function\", JsType.isFunction, false);\nJsType.array = new JsType(\"array\", JsType.isArray, false);\nJsType.date = new JsType(\"Date\", JsType.isDate, false);\nJsType.lambdaFunction = new JsType(\"lambda-function\", JsType.isLambdaFunction, true);\nJsType.nonLambdaFunction = new JsType(\"non-lambda-function\", JsType.isNonLambdaFunction, true);\nJsType.symbol = new JsType(\"symbol\", JsType.isSymbol, true);\nJsType.undefined = new JsType(\"undefined\", JsType.isUndefined, true);\nJsType.null = new JsType(\"null\", JsType.isNull, true);\nJsType.boolean = new JsType(\"boolean\", JsType.isBoolean, true);\nJsType.number = new JsType(\"number\", JsType.isNumber, true);\nJsType.bigint = new JsType(\"bigint\", JsType.isBigint, true);\nJsType.string = new JsType(\"string\", JsType.isString, true);\nfunction invalidSuperClassError( /*callee: Class,*/scname, superclass) {\n  return () => {\n    windoww.Log.exDevv('parent super class \"' + scname + '\" is not implementing init_constructor', {\n      scname,\n      superclass\n    });\n    throw new Error();\n  };\n}\n// @ts-ignore\nfunction MixinFakeConstructor() {\n  this.isMixinFakeConstructor = true;\n}\n_c7 = MixinFakeConstructor;\nexport function MixOnlyFuncs(c1, c2) {\n  // strategia: passo dei finti valori che copiano i prototipi delle classi sovrascrivendo i costruttori per evitare che chiami i costruttori delle superclassi\n  // ma che comunque erediti campi e funzioni\n  // @ts-ignore\n  let c1noconstructor = MixinFakeConstructor;\n  let c2noconstructor = MixinFakeConstructor;\n  c1noconstructor.prototype = c1.prototype;\n  c2noconstructor.prototype = c2.prototype;\n  let disableconstructor = false;\n  if (!disableconstructor) {\n    c1noconstructor = c1;\n    c2noconstructor = c2;\n  }\n  let ret = Mixin(c1noconstructor, c2noconstructor);\n  let c1name = c1.name === 'classnameFixedConstructorDoNotRenameWithoutSearchStrings' ? c1.prototype.className : c1.name;\n  let c2name = c2.name === 'classnameFixedConstructorDoNotRenameWithoutSearchStrings' ? c2.prototype.className : c2.name;\n  //ret.prototype['superclass'] = {};\n  // ret.prototype['superclass'][c1name] = c1.prototype.init_constructor || invalidSuperClassError(c1name, c1);\n  // ret.prototype['superclass'][c2name] = c2.init_constructor || invalidSuperClassError(c2name, c2);\n  ret.prototype['superclass1'] = {};\n  ret.prototype['superclass2'] = {};\n  ret.prototype['superclass1'][c1name] = c1.init_constructor || invalidSuperClassError(c1name, c1);\n  ret.prototype['superclass2'][c2name] = c2.init_constructor || invalidSuperClassError(c2name, c2);\n  return ret;\n}\n_c8 = MixOnlyFuncs;\nconsole.warn('ts loaded classes');\n\n//*********************************************************************************************\n//*********************************************************************************************\n///////                              type juggling starts here                          ///////\n//*********************************************************************************************\n//*********************************************************************************************\n\n// export type NotAString<T extends any = 'uselessval'> = Omit<string, 'bold'> & {big: T};\n// export type NotAString<T extends any = 'uselessval'> = Omit<string, 'bold'>;\n// export type NotAString<T extends any = 'uselessval', T2 extends any = any, T3 extends any = any, T4 extends any = any> = string & Omit<string, 'bold'> & {bold: ()=>string};\n\n// export type NotAString<T> = string;\n// type Pointer<T> = NotAString<T>;\n\n// to convert Pointers to strings more explicitly then using as any\n// let ptr: Pointer<Object> = null as any;\n\nclass D extends DPointerTargetable {\n  constructor() {\n    super(...arguments);\n    this.parent = void 0;\n    this.dattrib = void 0;\n    this.juststring = void 0;\n    this.nattrib = void 0;\n    this.ddattrib = void 0;\n  }\n}\nclass D2 extends D {\n  constructor() {\n    super(...arguments);\n    this.d2 = void 0;\n  }\n}\nclass D3 extends D {\n  constructor() {\n    super(...arguments);\n    this.d3 = void 0;\n  }\n}\n\n// usage:  OverrideTypes<A, { x: number }>;\n\nclass P {\n  // singleton\n  get_parent() {}\n  set_parent() {}\n}\nclass P2 extends P {\n  // singleton\n  get_d2() {}\n}\nclass P3 extends P {\n  // singleton\n  get_d3() {}\n}\n// RegExp extends Animal ? number : string\n\nfunction buildWrapSignature() {\n  let maxdepth = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 100;\n  let arr = windoww[\"DPointerTargetable\"].subclasses;\n  /*\r\n  let dict0 = arr.reduce((a, v) => ({ ...a, [v.name]: v}), {});\r\n  let dict = {}\r\n  for (let name in dict0) { let n = name.substring(1); dict[n] = {\"D\":dict0[\"D\"+n], \"L\":dict0[\"L\"+n]}; dict[\"D\"+n] = dict0[\"L\"+n]; dict[\"L\"+n] = dict0[\"D\"+n]; }\r\n  console.log(\"dict\", dict);\r\n  console.table(dict);\r\n  */\n  function onlyUnique(value, index, self) {\n    return self.indexOf(value) === index;\n  }\n  let dep = arr; // .map( (me) => { return {\"name\": me.name, \"me\": me, \"Derror\": (dict[me.name] || me).name, \"Lerror\": (dict[me.name] || me).name, \"subclasses\": [...me.subclasses]}});\n  let depsorted = [];\n  let byLevels = [];\n  let loopdetecter = [arr];\n  while (dep.length && maxdepth--) {\n    let namelist = dep.map(e => e.name).filter(onlyUnique);\n    depsorted.push(...namelist);\n    byLevels.push([...namelist]);\n    let olddep = dep;\n    dep = dep.flatMap(d => d.subclasses).filter(onlyUnique);\n    for (let d of dep) {\n      windoww.loopdetecter = loopdetecter;\n      windoww.dep = dep;\n      windoww.olddep = olddep;\n      windoww.byLevels = byLevels;\n      windoww.d = d;\n      if (loopdetecter.includes(d.subclasses)) throw new Error(\"class is not redefining subclasses static array: \" + d.name);\n      loopdetecter.push(d.subclasses);\n    }\n  }\n  console.log(\"byLevels\");\n  console.table(byLevels);\n  console.log(\"depsorted\", depsorted);\n\n  // console.log(\"map\");\n  // console.table(depsorted.map(dn => {let d = window[dn]; return !d ? \"\" :{name:d.name, scount: d.subclasses.length, subclasses:d.subclasses}}));\n\n  let goalSignature = \"function wrap<DX extends D, LX = DX extends D2 ? L2: (DX extends D3 ? L3: (DX extends D ? L : ERROR))>(data: DX): LX {\";\n  let lparam = \"ERROR\";\n  let epsorted = depsorted.map(e => e.substring(1)).filter(onlyUnique);\n  console.table(epsorted);\n  for (let e of epsorted) {\n    let D = \"D\" + e;\n    let L = \"L\" + e;\n    lparam = \"DX extends \" + D + \" ? \" + L + \" : (\" + lparam + \")\";\n  }\n  let signature = \"function wrap<DX extends DPointerTargetable, LX = \" + lparam + \">(data: DX): LX {\";\n  return signature;\n}\nwindoww.buildWrapSignature = buildWrapSignature;\n// function wrap<DX extends D, LX = DX extends D2 ? L2: (DX extends D3 ? L3: (DX extends D ? L : ERROR))>(data: DX): LX {\n\n/*\r\n* NO    L -> D    /// l.__raw\r\n* NO    L -> Ptr  /// l.id\r\n*\r\n* NO    D -> Ptr   // d.id\r\n* YES   D -> L     // wrap\r\n*\r\n* NO    Ptr -> D\r\n* NO    Ptr -> L\r\n*\r\n*\r\n*\r\n*\r\n* DpointerTargetable.from( L or pointer )\r\n* LpointerTargetable.from( D or pointer )\r\n*\r\n* MyProxyHandler.wrap = LpointerTargetable.from;\r\n*\r\n* DpointerTargetable.toPointer( d );\r\n*\r\n* */\n\n//////////////////////////////////////////// best solution so far\n\n// todo: can't automatically convert D to L (generating the type instead of manual defining L) rules are: LClass <--- Pointer<LClass>, LClass[] <-- Pointer<LClass, 0, 'N'>, subobject = ? should not be there\n\n/**\r\n i have a documentation type that is actually a string, but it\\'s have a different purpose from the others, and i made a type to keep documentally separated.\r\n let's say it's\r\n type StringOf<P> = string; // regardless of P\r\n\r\n and i use it to define objects\r\n\r\n class C {\r\n   str: StringOf<Date>;\r\n   str2: StringOf<number>;\r\n   purestring: string;\r\n   num: number\r\n }\r\n now i want to crete a derivate type that excludes all properties of type StringOf from C\r\n\r\n\r\n\r\n type OnlyKeysOfTypeTmp<T, IncludeType> = ({[P in keyof T]: T[P] extends IncludeType ? P : never })[keyof T];\r\n type OnlyKeysOfType<T, IncludeType> = Pick<T, OnlyKeysOfTypeTmp<T, IncludeType>>;\r\n type RemoveKeysOfType<T, ExcludeType> = Exclude2<T, OnlyKeysOfType<T, string>>;\r\n\r\n type D = RemoveKeysOfType<C, StringOf<any>>\r\n due to duck typing, this removes all StringOf attributes, but also \"purestring\" attribute.\r\n how can i remove only StringOf attributes?\r\n\r\n\r\n */\n\n// & L\nvar _c, _c2, _c3, _c4, _c5, _c6, _c7, _c8;\n$RefreshReg$(_c, \"Obsolete\");\n$RefreshReg$(_c2, \"Leaf\");\n$RefreshReg$(_c3, \"Node\");\n$RefreshReg$(_c4, \"Abstract\");\n$RefreshReg$(_c5, \"Instantiable\");\n$RefreshReg$(_c6, \"RuntimeAccessible\");\n$RefreshReg$(_c7, \"MixinFakeConstructor\");\n$RefreshReg$(_c8, \"MixOnlyFuncs\");","map":{"version":3,"names":["Mixin","Action","BEGIN","CreateElementAction","DeleteElementAction","END","GraphPoint","GraphSize","Log","SetFieldAction","SetRootFieldAction","store","U","windoww","window","console","warn","AbstractMixedClass","init_constructor","logic","structure","singleton","RuntimeAccessibleClass","fixStatics","classs","Object","values","annotatedClasses","gclass","log","s","statickey","getAllNames","annotated","arguments","length","undefined","keys","classes","getAllClasses","getAllClassesDictionary","wrapAll","data","baseObjInLookup","path","canThrow","state","Array","isArray","map","d","DPointerTargetable","wrap","__isProxy","getState","idlookup","exx","error","Error","Proxy","TargetableProxyHandler","mapWrap","subMapKeys","MapProxyHandler","constructor","className","thiss","get","dclassname","extends","superClassName","returnIfEqual","superclass","thisclass","getAllPrototypeSuperClasses","currentlevel","ret","push","__proto__","Obsolete","_c","Leaf","_c2","Node","_c3","Abstract","_c4","Instantiable","instanceConstructor","_c5","RuntimeAccessible","name","prototype","staticClassName","outerthis","classnameFixedConstructorDoNotRenameWithoutSearchStrings","_obj$initBase","_len","args","_key","obj","classNameFromAnnotation","initBase","call","key","_c6","canFireActions","Constructors","_class","_class2","t","father","persist","fatherType","callbacks","hasOwnProperty","new","PointedBy","fromID","id","pause","resume","end","simpledatacallback","setTimeout","cb","DModelElement","DClassifier","DParameter","DStructuralFeature","_DClass","DClass","_DValue","DValue","targets","fromPointer","alreadyParsed","nextTargets","target","ext","extendedBy","pointer","instance","instances","DReference","DAttribute","DDataType","DObject","instanceoff","LPointerTargetable","instanceof","val","isMirage","edges","value","DAnnotation","source","details","det","isUser","DUser","current","maxID","Date","getTime","DNamedElement","substring","DTypedElement","type","DPackage","uri","prefix","DModel","isMetamodel","packages","DOperation","exceptions","exc","isInterface","isAbstract","isPrimitive","partial","partialdefaultname","interface","abstract","DEnumLiteral","literal","DEnumerator","DEdgePoint","DVoidEdge","midnodes","DVertex","DEdge","DExtEdge","DRefEdge","DGraphElement","model","parentNodeID","parentgraphID","nodeID","graph","subElements","DViewElement","jsxString","defaultVSize","usageDeclarations","constants","preRenderFunc","appliableToClasses","oclApplyCondition","priority","subViews","explicitApplicationPriority","adaptHeight","adaptWidth","width","height","DViewPoint","DGraph_makeID","modelid","DGraph_maxID","DGraph","zoom","graphSize","_subMaps","DVoidVertex","x","y","w","h","_class3","_class4","defaultname","startingPrefix","metaptr","lfather","meta","from","childrenNames","childrens","c","increaseEndingNumber","newname","indexOf","condition","fakearg_detectwrongcalls","_storePath","pointedBy","fromL","__raw","ptr","p","_ptr","from0","a","writeable","l","defaultComponent","subclasses","_extends","Pointers","_class5","filterValid","pointerval","filter","fromArr","v","fromm","from00","isPointer","includes","PendingPointedByPaths","_class6","_class7","action","oldState","pendingPointedBy","to","solveAttempts","stackTrace","getStackTrace","attemptimplementationdelete","pb","objectChain","followPath","attemptResolve","canBeResolved","resolve","arrayRemoveAll","all","parse","create","saveForLater","maxSolveAttempts","ex","getSolveableActions","allClone","_class8","_class9","getPath","lastIndexOf","getLastKey","getPathArr","split","field","modifier","remove","oldValue","casee","oldtarget","index","actionpath","i","splice","add","newtargetptr","newtarget","list","_class10","_class11","wrongAccessMessage","str","msg","toString","get_toString","context","cannotSet","get_id","set_id","_get_default","delete","_delete","get_delete","alert","get__extends","set_pointedBy","fromD","WPointerTargetable","_class12","fffff","bbb","bb2","_class14","_class15","username","email","token","cursorPositionX","cursorPositionY","__isUser","triggerActions","LUser","_class16","_class17","cursorPosition","MyError","_class18","message","proto","_len2","otherMsg","_key2","actualProto","setPrototypeOf","JsType","printableTypeName","check","isExclusiveType","isOnlyType","getTypes","isAnyOfTypes","_len3","acceptables","_key3","Uarr","arrayIntersection","stopIfTypeIsNot","isObject","isFunction","isLambdaFunction","getFunctionSignatureFromComments","isLambda","isNonLambdaFunction","isSymbol","isBoolean","isNumber","isBigint","isString","isNull","isUndefined","isDate","asObject","fallbackReturn","asFunction","asLambdaFunction","asNonLambdaFunction","asArray","asSymbol","asBoolean","asNumber","asBigint","asString","asNull","asUndefined","asDate","object","function","array","date","lambdaFunction","nonLambdaFunction","symbol","null","boolean","number","bigint","string","invalidSuperClassError","scname","exDevv","MixinFakeConstructor","isMixinFakeConstructor","_c7","MixOnlyFuncs","c1","c2","c1noconstructor","c2noconstructor","disableconstructor","c1name","c2name","_c8","D","parent","dattrib","juststring","nattrib","ddattrib","D2","d2","D3","d3","P","get_parent","set_parent","P2","get_d2","P3","get_d3","buildWrapSignature","maxdepth","arr","onlyUnique","self","dep","depsorted","byLevels","loopdetecter","namelist","e","olddep","flatMap","table","goalSignature","lparam","epsorted","L","signature","$RefreshReg$"],"sources":["C:/0Programmi/Dev/projects/frontend/jjodel/src/joiner/classes.ts"],"sourcesContent":["import { Mixin } from \"ts-mixer\";\r\nimport type {\r\n    DEdge,\r\n    DEdgePoint,\r\n    DExtEdge,\r\n    DGraph,\r\n    DGraphElement,\r\n    DGraphVertex,\r\n    DRefEdge,\r\n    DVertex,\r\n    DVoidEdge,\r\n    DVoidVertex,\r\n    LEdge,\r\n    LEdgePoint,\r\n    LExtEdge,\r\n    LGraph,\r\n    LGraphElement,\r\n    LGraphVertex,\r\n    LRefEdge,\r\n    LVertex,\r\n    LVoidEdge,\r\n    LVoidVertex,\r\n    WEdge,\r\n    WEdgePoint,\r\n    WExtEdge,\r\n    WGraph,\r\n    WGraphElement,\r\n    WGraphVertex,\r\n    WRefEdge,\r\n    WVertex,\r\n    WVoidEdge,\r\n    WVoidVertex\r\n} from \"../model/dataStructure\";\r\nimport type { Class, Longest } from \"ts-mixer/dist/types/types\";\r\nimport type {\r\n    DAnnotation,\r\n    DAttribute,\r\n    DClass,\r\n    DClassifier,\r\n    DDataType,\r\n    DEnumerator,\r\n    DEnumLiteral,\r\n    DMap,\r\n    DModel,\r\n    DModelElement,\r\n    DNamedElement,\r\n    DObject,\r\n    DOperation,\r\n    DPackage,\r\n    DParameter,\r\n    DReference,\r\n    DStructuralFeature,\r\n    DTypedElement,\r\n    DValue,\r\n    LAnnotation,\r\n    LAttribute,\r\n    LClass,\r\n    LClassifier,\r\n    LDataType,\r\n    LEnumerator,\r\n    LEnumLiteral,\r\n    LMap,\r\n    LModel,\r\n    LModelElement,\r\n    LNamedElement,\r\n    LObject,\r\n    LOperation,\r\n    LPackage,\r\n    LParameter,\r\n    LReference,\r\n    LStructuralFeature,\r\n    LTypedElement,\r\n    LValue,\r\n    WAnnotation,\r\n    WAttribute,\r\n    WClass,\r\n    WClassifier,\r\n    WDataType,\r\n    WEnumerator,\r\n    WEnumLiteral,\r\n    WMap,\r\n    WModel,\r\n    WModelElement,\r\n    WNamedElement,\r\n    WObject,\r\n    WOperation,\r\n    WPackage,\r\n    WParameter,\r\n    WReference,\r\n    WStructuralFeature,\r\n    WTypedElement,\r\n    WValue\r\n} from \"../model/logicWrapper\";\r\n// import type {Pointer} from \"./typeconverter\";\r\nimport type { CClass, Constructor, Dictionary, DocString, GObject, orArr, Proxyfied, unArr } from \"./types\";\r\nimport type {\r\n    DViewElement,\r\n    DViewTransientProperties,\r\n    LViewElement,\r\n    LViewTransientProperties,\r\n    WViewElement,\r\n    WViewTransientProperties\r\n} from \"../view/viewElement/view\";\r\nimport type { LogicContext } from \"./proxy\";\r\nimport type { IStore, } from \"./index\";\r\nimport {\r\n    Action, BEGIN, CreateElementAction,\r\n    DeleteElementAction, END,\r\n    GraphPoint,\r\n    GraphSize,\r\n    IPoint,\r\n    Log,\r\n    ParsedAction, Selectors, SetFieldAction,\r\n    SetRootFieldAction,\r\n    store,\r\n    U,\r\n} from \"./index\";\r\nimport { DViewPoint } from \"../view/viewPoint/viewpoint\";\r\nimport value from \"../components/rightbar/structureEditor/editors/Value\";\r\n\r\nvar windoww = window as any;\r\n// qui dichiarazioni di tipi che non sono importabili con \"import type\", ma che devono essere davvero importate a run-time (eg. per fare un \"extend\", chiamare un costruttore o usare un metodo statico)\r\n\r\n\r\nconsole.warn('ts loading classes');\r\n\r\n\r\n// annotation @RuntimeAccessible\r\n// import {store} from \"../redux/createStore\";\r\n\r\nabstract class AbstractMixedClass {\r\n    // superclass!: Dictionary<DocString<'parent class name', Class>>;\r\n    static logic: typeof LPointerTargetable;\r\n    static structure: typeof DPointerTargetable;\r\n    static singleton: LPointerTargetable;\r\n    // static [key: string]: any;\r\n    static init_constructor(...constructorArguments: any): void { }\r\n}\r\n\r\nexport abstract class RuntimeAccessibleClass extends AbstractMixedClass {\r\n    static fixStatics() {\r\n        // problem: se lo statico è un valore primitivo ne genera una copia.\r\n        for (let classs of Object.values(RuntimeAccessibleClass.annotatedClasses)) {\r\n            let gclass = classs as GObject;\r\n            console.log('fix statics', { gclass, s: gclass.s });\r\n            for (let statickey in gclass.s) { gclass[statickey] = gclass.s[statickey]; }\r\n        }\r\n    }\r\n    // static allRuntimeClasses: string[] = [];\r\n    static classes: Dictionary<string, typeof RuntimeAccessibleClass> = {};\r\n    static annotatedClasses: Dictionary<string, typeof RuntimeAccessibleClass> = {};\r\n\r\n    static getAllNames(annotated = false): string[] {\r\n        return Object.keys(annotated ? RuntimeAccessibleClass.annotatedClasses : RuntimeAccessibleClass.classes);\r\n    }\r\n    static getAllClasses(annotated = false): typeof RuntimeAccessibleClass[] {\r\n        return Object.values(annotated ? RuntimeAccessibleClass.annotatedClasses : RuntimeAccessibleClass.classes);\r\n    }\r\n    static getAllClassesDictionary(annotated = false): Dictionary<string, typeof RuntimeAccessibleClass> {\r\n        return annotated ? RuntimeAccessibleClass.annotatedClasses : RuntimeAccessibleClass.classes;\r\n    }\r\n\r\n    static wrapAll<D extends RuntimeAccessibleClass, L extends LPointerTargetable = LPointerTargetable, CAN_THROW extends boolean = false,\r\n        RET extends CAN_THROW extends true ? L[] : L[] = CAN_THROW extends true ? L[] : L[]>\r\n        (data: D[] | Pointer<DPointerTargetable, 0, 'N'>, baseObjInLookup?: DPointerTargetable, path: string = '', canThrow: CAN_THROW = false as CAN_THROW, state?: IStore): CAN_THROW extends true ? L[] : L[] {\r\n        if (!Array.isArray(data)) return [];\r\n        return data.map(d => DPointerTargetable.wrap(d, baseObjInLookup, path, canThrow, state)) as L[];\r\n    }\r\n\r\n    static wrap<D extends RuntimeAccessibleClass, L extends LPointerTargetable = LPointerTargetable, CAN_THROW extends boolean = false,\r\n        RET extends CAN_THROW extends true ? L : L | undefined = CAN_THROW extends true ? L : L | undefined>\r\n        (data: D | Pointer | undefined, baseObjInLookup?: DPointerTargetable, path: string = '', canThrow: CAN_THROW = false as CAN_THROW, state?: IStore): CAN_THROW extends true ? L : L | undefined {\r\n        if (!data || (data as any).__isProxy) return data as any;\r\n        if (typeof data === 'string') {\r\n            if (!state) state = windoww.store.getState() as IStore;\r\n            data = state.idlookup[data] as unknown as D;\r\n            if (!data) {\r\n                if (canThrow) return windoww.Log.exx('Cannot wrap:', { data, baseObjInLookup, path });\r\n                else return undefined as RET;\r\n            }\r\n        }\r\n        if (Array.isArray(data)) { console.error('use WrapAll instead for arrays', { data, baseObjInLookup, path, canThrow }); throw new Error(\"use WrapAll instead for arrays\"); }\r\n        if (!data) return data;\r\n        // console.log('ProxyWrapping:', {data, baseObjInLookup, path});\r\n        return new Proxy(data, new windoww.TargetableProxyHandler(data, baseObjInLookup, path)) as L;\r\n    }\r\n    /*\r\n        static mapWrap2<D extends DPointerTargetable, L extends LPointerTargetable>(map: RuntimeAccessibleClass, container: D, baseObjInLookup?: DPointerTargetable, path: string = ''): L{\r\n            if (!map || (map as any).__isProxy) return map as any;\r\n            if (typeof container === 'string') {\r\n                container = store.getState().idlookup[container] as unknown as D;\r\n                if (!container) { return Log.exx('Cannot wrap map:', {map, container, baseObjInLookup, path}); }\r\n            }\r\n            // console.log('ProxyWrapping:', {data, baseObjInLookup, path});\r\n            return new Proxy(map, new MapProxyHandler(map, baseObjInLookup, path));\r\n        }\r\n\r\n    */\r\n\r\n    static mapWrap(data: Dictionary, baseObjInLookup: DPointerTargetable, path: string, subMapKeys: string[] = []): Proxyfied<Dictionary> {\r\n        if (!data || (data as any).__isProxy) return data as any;\r\n        // console.error('GETMAP', {data, logicContext, path});\r\n        return new Proxy(data, new windoww.MapProxyHandler(data, baseObjInLookup, path));\r\n    }\r\n\r\n    className!: string;\r\n    protected constructor(...a: any) {\r\n        super();\r\n        // RuntimeAccessibleClass.init_constructor(this, ...a);\r\n        // this.className = this.constructor.name;\r\n        // nb: per i mixin questo settaggio viene sovrascritto. perchè il mixin crea le 2 classi ereditate separatamente con i loro costruttori e le incrocia. quindi devo settarlo dall'annotazione @ tramite prototype\r\n        // RuntimeAccessibleClass.allRuntimeClasses.push(this.className);\r\n    }\r\n\r\n    static init_constructor(thiss: any, ...args: any): void {\r\n\r\n        // this.className = this.constructor.name;\r\n        // let finalObject = this;\r\n        // if (finalObject.constructor.name === \"DVoidVertex\" || finalObject.constructor.name === \"DGraphElement\") { let breakp = true; }\r\n        // this.init0(...arguments);\r\n        // thiss.className = this.name;\r\n    }\r\n\r\n    public static get<T extends typeof RuntimeAccessibleClass = typeof RuntimeAccessibleClass>(dclassname: string, annotated = false)\r\n        : T & { logic?: typeof LPointerTargetable } { return (annotated ? RuntimeAccessibleClass.annotatedClasses : this.classes)[dclassname] as any; }\r\n\r\n    public static extends(className: string, superClassName: string, returnIfEqual: boolean = true): boolean {\r\n        let superclass = RuntimeAccessibleClass.get(superClassName);\r\n        const thisclass = RuntimeAccessibleClass.get(className);\r\n        if (superclass === thisclass) return returnIfEqual;\r\n        if (!superclass || !thisclass) return false;\r\n        return (thisclass instanceof superclass); // todo: check if works with constructors\r\n    }\r\n\r\n    getAllPrototypeSuperClasses(): GObject[] {\r\n        let currentlevel = this;\r\n        let ret: GObject[] = [];\r\n        while (true) {\r\n            if (!currentlevel) break;\r\n            ret.push(currentlevel);\r\n            // @ts-ignore\r\n            currentlevel = currentlevel.__proto__;\r\n        }\r\n        console.log('constructor chain:', ret);\r\n        return ret;\r\n    }\r\n    /*initBase(){\r\n        let superclasses = this.getAllPrototypeSuperClasses();\r\n        for (let sc of superclasses) {\r\n            if (!sc.hasOwnProperty('init0')) continue;\r\n            console.log('initbase calling ', {thiss: this, sc, init0: sc.init0, args:sc.constructorArguments});\r\n            sc.init0.apply(this, ...(sc.constructorArguments || []));\r\n        }\r\n    }*/\r\n    // protected abstract init(...constructorParameters: any): void;\r\n    // NB: per colpa della limitazione #3 di ts-mixer,\r\n    // DEVO chiamare init su ogni oggetto per settargli il corretto this.className, altrimenti prende quello dell'ultima superclasse\r\n    /*protected init0(...constructorParameters: any): void {\r\n        let a = this;\r\n        let finalObject = this;\r\n        console.log('creation of___ ', {thiss: this, finalObject});\r\n        if (finalObject.constructor.name === \"DVoidVertex\" || finalObject.constructor.name === \"DGraphElement\") {\r\n            let breakp = true; }\r\n\r\n        (window as any)[finalObject.constructor.name] =\r\n            RuntimeAccessibleClass.classes[finalObject.constructor.name] = finalObject.constructor as any;\r\n        // @ts-ignore\r\n        // delete this.className;\r\n        this.className = (finalObject as any).__proto__.className;\r\n    }*/\r\n\r\n}\r\nexport function Obsolete<T extends any>(constructor: T & GObject): T { return constructor; }\r\nexport function Leaf<T extends any>(constructor: T & GObject): T { return constructor; }\r\nexport function Node<T extends any>(constructor: T & GObject): T { return constructor; }\r\nexport function Abstract<T extends any>(constructor: T & GObject): T { return constructor; }\r\nexport function Instantiable<T extends any>(constructor: T & GObject, instanceConstructor?: Constructor): T { return constructor; } // for m2 cklasses that have m1 instances\r\nexport function RuntimeAccessible<T extends any>(constructor: T & GObject): T {\r\n    // console.log('DecoratorTest', {constructor, arguments});\r\n    // @ts-ignore\r\n    RuntimeAccessibleClass.classes[constructor.name] = constructor as any as typeof RuntimeAccessibleClass;\r\n    if (!window[constructor.name]) (window[constructor.name] as any) = constructor;\r\n    constructor.prototype.className = constructor.name;\r\n    //constructor.prototype.$$typeof = constructor.name;\r\n    //constructor.prototype.typeName = constructor.name;\r\n    (constructor as any).staticClassName = constructor.name;\r\n    // @ts-ignore\r\n    console.log('runtimeaccessible annotation:', { thiss: this, constructor });\r\n    //    const classnameFixedConstructor = constructor; //  function (...args) { let obj = new constructor(...args); obj.init?.(); obj.init0?.(); return obj; }\r\n\r\n    // @ts-ignore\r\n    let outerthis = this;\r\n    // @ts-ignore\r\n    const classnameFixedConstructorDoNotRenameWithoutSearchStrings = function (...args) {\r\n        // @ts-ignore\r\n        console.log('runtimeaccessible annotation inner:', { thiss: this, outerthis, constructor });\r\n        // @ts-ignore\r\n        let obj = new constructor(...args);\r\n        obj.classNameFromAnnotation = constructor.name;\r\n        obj.className = constructor.name;\r\n        //obj.prototype.$$typeof = constructor.name;\r\n        // obj.prototype.typeName = constructor.name;\r\n        // obj.init?.();\r\n        // obj.init0?.();\r\n        obj.initBase?.();\r\n        // @ts-ignore\r\n        console.log('runtimeaccessible annotation inner end:', { thiss: this, outerthis, constructor, obj });\r\n        return obj;\r\n    }\r\n    RuntimeAccessibleClass.annotatedClasses[constructor.name] = classnameFixedConstructorDoNotRenameWithoutSearchStrings as any as typeof RuntimeAccessibleClass;\r\n\r\n    for (let key in constructor) (classnameFixedConstructorDoNotRenameWithoutSearchStrings as GObject)[key] = constructor[key];\r\n    // constructor.constructor = classnameFixedConstructorDoNotRenameWithoutSearchStrings; return constructor;\r\n\r\n    // @ts-ignore\r\n    // for (let staticKey of constructor as GObject) { classnameFixedConstructorDoNotRenameWithoutSearchStrings[staticKey] = constructor[staticKey]; }\r\n    classnameFixedConstructorDoNotRenameWithoutSearchStrings.prototype = constructor.prototype;\r\n    classnameFixedConstructorDoNotRenameWithoutSearchStrings.prototype.constructor = constructor.prototype.constructor;\r\n\r\n    // required for inheriting static methods\r\n    classnameFixedConstructorDoNotRenameWithoutSearchStrings.__proto__ = constructor.__proto__;\r\n    classnameFixedConstructorDoNotRenameWithoutSearchStrings.s = constructor;\r\n    // return classnameFixedConstructorDoNotRenameWithoutSearchStrings as any;\r\n    return constructor;\r\n}\r\n\r\n\r\n(window as any).RuntimeAccessibleClass = RuntimeAccessibleClass;\r\n// todo: problema: per creare un PointerTargetable ho bisogno dell'userid, e devo generarlo prima che venga generato l'initialState... dovrebbe venir servito con la pagina dal server. o passato come navigation props dalla pagina di login\r\n\r\n\r\n\r\nexport type DtoL<DX extends GObject, LX = DX extends DEnumerator ? LEnumerator : (DX extends DAttribute ? LAttribute : (DX extends DReference ? LReference : (DX extends DRefEdge ? LRefEdge : (DX extends DExtEdge ? LExtEdge : (DX extends DDataType ? LDataType : (DX extends DClass ? LClass : (DX extends DStructuralFeature ? LStructuralFeature : (DX extends DParameter ? LParameter : (DX extends DOperation ? LOperation : (DX extends DEdge ? LEdge : (DX extends DEdgePoint ? LEdgePoint : (DX extends DGraphVertex ? LGraphVertex : (DX extends DModel ? LModel : (DX extends DValue ? LValue : (DX extends DObject ? LObject : (DX extends DEnumLiteral ? LEnumLiteral : (DX extends DPackage ? LPackage : (DX extends DClassifier ? LClassifier : (DX extends DTypedElement ? LTypedElement : (DX extends DVertex ? LVertex : (DX extends DVoidEdge ? LVoidEdge : (DX extends DVoidVertex ? LVoidVertex : (DX extends DGraph ? LGraph : (DX extends DNamedElement ? LNamedElement : (DX extends DAnnotation ? LAnnotation : (DX extends DGraphElement ? LGraphElement : (DX extends DMap ? LMap : (DX extends DModelElement ? LModelElement : (DX extends DUser ? LUser : (DX extends DPointerTargetable ? LPointerTargetable : (ERROR)))))))))))))))))))))))))))))))> = LX;\r\nexport type DtoW<DX extends GObject, WX = DX extends DEnumerator ? WEnumerator : (DX extends DAttribute ? WAttribute : (DX extends DReference ? WReference : (DX extends DRefEdge ? WRefEdge : (DX extends DExtEdge ? WExtEdge : (DX extends DDataType ? WDataType : (DX extends DClass ? WClass : (DX extends DStructuralFeature ? WStructuralFeature : (DX extends DParameter ? WParameter : (DX extends DOperation ? WOperation : (DX extends DEdge ? WEdge : (DX extends DEdgePoint ? WEdgePoint : (DX extends DGraphVertex ? WGraphVertex : (DX extends DModel ? WModel : (DX extends DValue ? WValue : (DX extends DObject ? WObject : (DX extends DEnumLiteral ? WEnumLiteral : (DX extends DPackage ? WPackage : (DX extends DClassifier ? WClassifier : (DX extends DTypedElement ? WTypedElement : (DX extends DVertex ? WVertex : (DX extends DVoidEdge ? WVoidEdge : (DX extends DVoidVertex ? WVoidVertex : (DX extends DGraph ? WGraph : (DX extends DNamedElement ? WNamedElement : (DX extends DAnnotation ? WAnnotation : (DX extends DGraphElement ? WGraphElement : (DX extends DMap ? WMap : (DX extends DModelElement ? WModelElement : (DX extends DUser ? WUser : (DX extends DPointerTargetable ? WPointerTargetable : (ERROR)))))))))))))))))))))))))))))))> = WX;\r\n// export type DtoW<DX extends GObject, WX = Omit<DtoW0<DX>, 'id'>> = WX;\r\nexport type LtoD<LX extends LPointerTargetable, DX = LX extends LEnumerator ? DEnumerator : (LX extends LAttribute ? DAttribute : (LX extends LReference ? DReference : (LX extends LRefEdge ? DRefEdge : (LX extends LExtEdge ? DExtEdge : (LX extends LDataType ? DDataType : (LX extends LClass ? DClass : (LX extends LStructuralFeature ? DStructuralFeature : (LX extends LParameter ? DParameter : (LX extends LOperation ? DOperation : (LX extends LEdge ? DEdge : (LX extends LEdgePoint ? DEdgePoint : (LX extends LGraphVertex ? DGraphVertex : (LX extends LModel ? DModel : (LX extends LValue ? DValue : (LX extends LObject ? DObject : (LX extends LEnumLiteral ? DEnumLiteral : (LX extends LPackage ? DPackage : (LX extends LClassifier ? DClassifier : (LX extends LTypedElement ? DTypedElement : (LX extends LVertex ? DVertex : (LX extends LVoidEdge ? DVoidEdge : (LX extends LVoidVertex ? DVoidVertex : (LX extends LGraph ? DGraph : (LX extends LNamedElement ? DNamedElement : (LX extends LAnnotation ? DAnnotation : (LX extends LGraphElement ? DGraphElement : (LX extends LMap ? DMap : (LX extends LModelElement ? DModelElement : (LX extends LUser ? DUser : (LX extends LPointerTargetable ? DPointerTargetable : (ERROR)))))))))))))))))))))))))))))))> = DX;\r\nexport type LtoW<LX extends LPointerTargetable, WX = LX extends LEnumerator ? WEnumerator : (LX extends LAttribute ? WAttribute : (LX extends LReference ? WReference : (LX extends LRefEdge ? WRefEdge : (LX extends LExtEdge ? WExtEdge : (LX extends LDataType ? WDataType : (LX extends LClass ? WClass : (LX extends LStructuralFeature ? WStructuralFeature : (LX extends LParameter ? WParameter : (LX extends LOperation ? WOperation : (LX extends LEdge ? WEdge : (LX extends LEdgePoint ? WEdgePoint : (LX extends LGraphVertex ? WGraphVertex : (LX extends LModel ? WModel : (LX extends LValue ? WValue : (LX extends LObject ? WObject : (LX extends LEnumLiteral ? WEnumLiteral : (LX extends LPackage ? WPackage : (LX extends LClassifier ? WClassifier : (LX extends LTypedElement ? WTypedElement : (LX extends LVertex ? WVertex : (LX extends LVoidEdge ? WVoidEdge : (LX extends LVoidVertex ? WVoidVertex : (LX extends LGraph ? WGraph : (LX extends LNamedElement ? WNamedElement : (LX extends LAnnotation ? WAnnotation : (LX extends LGraphElement ? WGraphElement : (LX extends LMap ? WMap : (LX extends LModelElement ? WModelElement : (LX extends LUser ? WUser : (LX extends LPointerTargetable ? WPointerTargetable : (ERROR)))))))))))))))))))))))))))))))> = WX;\r\nexport type WtoD<IN extends WPointerTargetable, OUT = IN extends WEnumerator ? DEnumerator : (IN extends WAttribute ? DAttribute : (IN extends WReference ? DReference : (IN extends WRefEdge ? DRefEdge : (IN extends WExtEdge ? DExtEdge : (IN extends WDataType ? DDataType : (IN extends WClass ? DClass : (IN extends WStructuralFeature ? DStructuralFeature : (IN extends WParameter ? DParameter : (IN extends WOperation ? DOperation : (IN extends WEdge ? DEdge : (IN extends WEdgePoint ? DEdgePoint : (IN extends WGraphVertex ? DGraphVertex : (IN extends WModel ? DModel : (IN extends WValue ? DValue : (IN extends WObject ? DObject : (IN extends WEnumLiteral ? DEnumLiteral : (IN extends WPackage ? DPackage : (IN extends WClassifier ? DClassifier : (IN extends WTypedElement ? DTypedElement : (IN extends WVertex ? DVertex : (IN extends WVoidEdge ? DVoidEdge : (IN extends WVoidVertex ? DVoidVertex : (IN extends WGraph ? DGraph : (IN extends WNamedElement ? DNamedElement : (IN extends WAnnotation ? DAnnotation : (IN extends WGraphElement ? DGraphElement : (IN extends WMap ? DMap : (IN extends WModelElement ? DModelElement : (IN extends WUser ? DUser : (IN extends WPointerTargetable ? DPointerTargetable : (IN extends WViewElement ? DViewElement : (IN extends WViewTransientProperties ? DViewTransientProperties : (ERROR)))))))))))))))))))))))))))))))))> = OUT;\r\nexport type WtoL<IN extends WPointerTargetable, OUT = IN extends WEnumerator ? LEnumerator : (IN extends WAttribute ? LAttribute : (IN extends WReference ? LReference : (IN extends WRefEdge ? LRefEdge : (IN extends WExtEdge ? LExtEdge : (IN extends WDataType ? LDataType : (IN extends WClass ? LClass : (IN extends WStructuralFeature ? LStructuralFeature : (IN extends WParameter ? LParameter : (IN extends WOperation ? LOperation : (IN extends WEdge ? LEdge : (IN extends WEdgePoint ? LEdgePoint : (IN extends WGraphVertex ? LGraphVertex : (IN extends WModel ? LModel : (IN extends WValue ? LValue : (IN extends WObject ? LObject : (IN extends WEnumLiteral ? LEnumLiteral : (IN extends WPackage ? LPackage : (IN extends WClassifier ? LClassifier : (IN extends WTypedElement ? LTypedElement : (IN extends WVertex ? LVertex : (IN extends WVoidEdge ? LVoidEdge : (IN extends WVoidVertex ? LVoidVertex : (IN extends WGraph ? LGraph : (IN extends WNamedElement ? LNamedElement : (IN extends WAnnotation ? LAnnotation : (IN extends WGraphElement ? LGraphElement : (IN extends WMap ? LMap : (IN extends WModelElement ? LModelElement : (IN extends WUser ? LUser : (IN extends WPointerTargetable ? LPointerTargetable : (IN extends WViewElement ? LViewElement : (IN extends WViewTransientProperties ? LViewTransientProperties : (ERROR)))))))))))))))))))))))))))))))))> = OUT;\r\n\r\nlet canFireActions: boolean = true;\r\n@RuntimeAccessible\r\nexport class Constructors<T extends DPointerTargetable>{\r\n    private thiss: T;\r\n    private persist: boolean;\r\n    private callbacks: Function[];\r\n    fatherType?: Constructor;\r\n    constructor(t: T, father?: Pointer, persist: boolean = true, fatherType?: Constructor) {\r\n        persist = persist && canFireActions;\r\n        this.thiss = t;\r\n        this.persist = persist;\r\n        this.callbacks = [];\r\n        if (this.thiss.hasOwnProperty(\"father\")) {\r\n            (this.thiss as any).father = father;\r\n            persist && father && SetFieldAction.new(father, \"pointedBy\", PointedBy.fromID(t.id, \"father\" as any), '+=');\r\n        }\r\n        this.fatherType = fatherType;\r\n        if (this.persist) BEGIN()\r\n    }\r\n\r\n    static pause(): void { canFireActions = false; }\r\n    static resume(): void { canFireActions = true; }\r\n    // start(thiss: any): this { this.thiss = thiss; return this; }\r\n    end(simpledatacallback?: (d: T) => void): T {\r\n        if (simpledatacallback) simpledatacallback(this.thiss); // callback for setting primitive types, not pointers not context-dependant values (name being potentially invalid / chosen according to parent)\r\n        if (!this.persist) return this.thiss;\r\n        setTimeout(() => { for (let cb of this.callbacks) cb(); }, 0);\r\n        END([CreateElementAction.new(this.thiss, true)]);\r\n        return this.thiss;\r\n    }\r\n    DModelElement(): this { return this; }\r\n    DClassifier(): this { return this; }\r\n    DParameter(): this {\r\n        let thiss: DParameter = this.thiss as any;\r\n        this.persist && thiss.father && SetFieldAction.new(thiss.father, \"parameters\", thiss.id, '+=', true);\r\n        return this;\r\n    }\r\n    DStructuralFeature(): this {\r\n        if (this.thiss.className === 'DOperation') return this;\r\n        if (!this.persist) return this;\r\n        let thiss: DAttribute | DReference = this.thiss as any;\r\n        const _DClass: typeof DClass = windoww.DClass;\r\n        const _DValue: typeof DValue = windoww.DValue;\r\n\r\n\r\n        let targets: DClass[] = [_DClass.fromPointer(thiss.father)];\r\n        let alreadyParsed: Dictionary<Pointer, DClass> = {};\r\n        while (targets.length) {\r\n            let nextTargets = [];\r\n            for (let target of targets) {\r\n                if (alreadyParsed[target.id]) continue;\r\n                alreadyParsed[target.id] = target;\r\n                for (let ext of target.extendedBy) nextTargets.push(_DClass.fromPointer(ext));\r\n            }\r\n            targets = nextTargets;\r\n        }\r\n        this.persist && this.callbacks.push(() => {\r\n            for (let pointer in alreadyParsed) {\r\n                for (let instance of alreadyParsed[pointer].instances) {\r\n                    _DValue.new(thiss.name, thiss.id, undefined, instance);\r\n                }\r\n            }\r\n        });\r\n\r\n\r\n        return this;\r\n    }\r\n    DReference(): this {\r\n        let thiss: DReference = this.thiss as any;\r\n        // update father's collections (pointedby's here are set automatically)\r\n        this.persist && thiss.father && SetFieldAction.new(thiss.father, \"references\", thiss.id, '+=', true);\r\n        return this;\r\n    }\r\n    DAttribute(): this {\r\n        let thiss: DAttribute = this.thiss as any;\r\n        // update father's collections (pointedby's here are set automatically)\r\n        console.log('dattrmake', { persist: this.persist, father: thiss.father, thiss, id: thiss.id });\r\n        this.persist && thiss.father && SetFieldAction.new(thiss.father, \"attributes\", thiss.id, '+=', true);\r\n        return this;\r\n    }\r\n    DDataType(): this { return this; }\r\n    DObject(instanceoff?: DObject[\"instanceof\"]): this {\r\n        let thiss: DObject = this.thiss as any;\r\n\r\n        if (this.persist && thiss.father) {\r\n            if (this.fatherType!.name === \"DModel\") {\r\n                this.persist && thiss.father && SetFieldAction.new(thiss.father as Pointer<DModel>, \"objects\", thiss.id, '+=', true);\r\n            }\r\n            else {\r\n                // object containing object is not in any direct child collection. access through values\r\n                // this.persist && thiss.father && SetFieldAction.new(thiss.father as Pointer<DObject>, \"subpackages\", thiss.id, '+=', true);\r\n            }\r\n        }\r\n\r\n        if (this.persist && instanceoff) this.callbacks.push(() => {\r\n            (LPointerTargetable.wrap(thiss) as LObject).instanceof = instanceoff as any;\r\n        })\r\n        else thiss.instanceof = instanceoff || null;\r\n        //old ver: this.persist && instanceoff && SetFieldAction.new(thiss.id, \"instanceof\", instanceoff, undefined, true);\r\n        // update father's collections (pointedby's here are set automatically)\r\n        // this.persist && instanceoff && SetFieldAction.new(instanceoff, \"instances\", thiss.id, '+=', true);\r\n\r\n        return this;\r\n    }\r\n\r\n    DValue(instanceoff?: DValue[\"instanceof\"], val?: DValue[\"value\"], isMirage?: DValue[\"isMirage\"]): this {\r\n        let thiss: DValue = this.thiss as any; thiss.edges = [];\r\n        thiss.value = val || [];\r\n        thiss.instanceof = instanceoff;\r\n        thiss.isMirage = isMirage || false;\r\n\r\n        // update father's collections (pointedby's here are set automatically)\r\n        if (this.persist && instanceoff) {\r\n            SetFieldAction.new(thiss.id, \"instanceof\", instanceoff, undefined, true);\r\n            SetFieldAction.new(instanceoff as Pointer<DAttribute>, \"instances\", thiss.id, '+=', true);\r\n        }\r\n        else thiss.instanceof = instanceoff;\r\n        this.persist && thiss.father && SetFieldAction.new(thiss.father, \"features\", thiss.id, '+=', true);\r\n        return this;\r\n    }\r\n\r\n    DAnnotation(source?: DAnnotation[\"source\"], details?: DAnnotation[\"details\"]): this {\r\n        const thiss: DAnnotation = this.thiss as any;\r\n        thiss.source = source || '';\r\n        thiss.details = details || [];\r\n        if (this.persist && details) {\r\n            BEGIN()\r\n            for (let det of details) SetFieldAction.new(det, \"pointedBy\", PointedBy.fromID(thiss.id, \"details\"), '+=');\r\n            // update father's collections (pointedby's here are set automatically)\r\n            this.persist && thiss.father && SetFieldAction.new(thiss.father, \"annotations\", thiss.id, '+=', true);\r\n            END()\r\n        }\r\n        return this;\r\n    }\r\n\r\n    DPointerTargetable(isUser: boolean = false, id?: string): this {\r\n        const thiss: DPointerTargetable = this.thiss as any;\r\n        thiss.id = id || (isUser ? \"USER\" : DUser.current) + \"_\" + (DPointerTargetable.maxID++) + \"_\" + new Date().getTime();\r\n        thiss.className = thiss.constructor.name;\r\n        // this.className = thiss.className;\r\n        if (this.persist) {\r\n            // no pointedBy\r\n        }\r\n        return this;\r\n    }\r\n\r\n    DUser(id?: DUser[\"id\"]): this {\r\n        const thiss: DPointerTargetable = this.thiss as any;\r\n        thiss.id = id ? id : 'USER_' + (DPointerTargetable.maxID++) + \"_\" + new Date().getTime();\r\n        if (this.persist) {\r\n            // no pointedBy\r\n        }\r\n        return this;\r\n    }\r\n\r\n    DNamedElement(name?: DNamedElement[\"name\"]): this {\r\n        const thiss: DNamedElement = this.thiss as any;\r\n        thiss.name = (name !== undefined) ? name || '' : thiss.constructor.name.substring(1) + \" 1\";\r\n        if (this.persist) {\r\n            // no pointedBy\r\n        }\r\n        return this;\r\n    }\r\n\r\n    DTypedElement(type?: DTypedElement[\"type\"]): this {\r\n        const thiss: DTypedElement = this.thiss as any;\r\n        thiss.type = type as Pointer<DClassifier, 1, 1, LClassifier>;\r\n        if (this.persist) {\r\n            type && SetFieldAction.new(type, \"pointedBy\", PointedBy.fromID(thiss.id, \"type\"), '+=');\r\n        }\r\n        return this;\r\n    }\r\n\r\n    DPackage(uri?: DPackage[\"uri\"], prefix?: DPackage[\"prefix\"]): this {\r\n        const thiss: DPackage = this.thiss as any;\r\n        thiss.uri = uri || '';// || 'org.jodel-react.username';\r\n        thiss.prefix = prefix || '';\r\n        if (this.persist) {\r\n            // no pointedBy\r\n            // update father's collections (pointedby's here are set automatically)\r\n            if (this.persist && thiss.father) {\r\n                if (this.fatherType!.name === \"DModel\") {\r\n                    this.persist && thiss.father && SetFieldAction.new(thiss.father as Pointer<DModel>, \"packages\", thiss.id, '+=', true);\r\n                }\r\n                else {\r\n                    this.persist && thiss.father && SetFieldAction.new(thiss.father as Pointer<DPackage>, \"subpackages\", thiss.id, '+=', true);\r\n                }\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n\r\n    DModel(instanceoff?: DModel[\"instanceof\"], isMetamodel?: DModel[\"isMetamodel\"]): this {\r\n        const thiss: DModel = this.thiss as any;\r\n        thiss.packages = []; // packages;\r\n        thiss.instanceof = instanceoff || null;\r\n        thiss.isMetamodel = isMetamodel || false;\r\n        if (this.persist) {\r\n            if (instanceoff) SetFieldAction.new(instanceoff, \"pointedBy\", PointedBy.fromID(thiss.id, \"instanceof\"), '+=');\r\n            // instanceoff && SetFieldAction.new(instanceoff, 'models', thiss.id, '+=', true);\r\n            SetRootFieldAction.new(isMetamodel ? \"m2models\" : \"m1models\", thiss.id, \"+=\", true);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    DOperation(exceptions: DOperation[\"exceptions\"] = []/*, parameters: DOperation[\"parameters\"] = []*/): this {\r\n        const thiss: DOperation = this.thiss as any;\r\n        // thiss.parameters = parameters;\r\n        thiss.exceptions = exceptions;\r\n        if (this.persist) {\r\n            BEGIN()\r\n            // if (parameters) for (let par of parameters) SetFieldAction.new(par, \"pointedBy\", PointedBy.fromID(thiss.id, \"parameters\"), '+=');\r\n            if (exceptions) for (let exc of exceptions) SetFieldAction.new(exc, \"pointedBy\", PointedBy.fromID(thiss.id, \"exceptions\"), '+=');\r\n            // update father's collections (pointedby's here are set automatically)\r\n            this.persist && thiss.father && SetFieldAction.new(thiss.father, \"operations\", thiss.id, '+=', true);\r\n            END()\r\n        }\r\n        return this;\r\n    }\r\n\r\n    DClass(isInterface: DClass[\"interface\"] = false, isAbstract: DClass[\"abstract\"] = false, isPrimitive: LClassifier[\"isPrimitive\"] = false,\r\n        partial: DClass[\"partial\"] = false, partialdefaultname: DClass[\"partialdefaultname\"] = ''): this {\r\n        const thiss: DClass = this.thiss as any;\r\n        thiss.interface = isInterface;\r\n        thiss.abstract = isAbstract;\r\n        thiss.isPrimitive = isPrimitive;\r\n        thiss.partial = partial;\r\n        thiss.partialdefaultname = partialdefaultname;\r\n        // thiss.isClass = !isPrimitive;\r\n        // thiss.isEnum = false;\r\n\r\n        if (this.persist) {\r\n            // no pointedBy\r\n            // update father's collections (pointedby's here are set automatically)\r\n            this.persist && thiss.father && SetFieldAction.new(thiss.father, \"classifiers\", thiss.id, '+=', true);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    DEnumLiteral(value: DEnumLiteral[\"value\"] = 0): this {\r\n        const thiss: DEnumLiteral = this.thiss as any;\r\n        thiss.value = value;\r\n        thiss.literal = thiss.name;\r\n        if (this.persist) {\r\n            // no pointedBy?\r\n            // update father's collections (pointedby's here are set automatically)\r\n            this.persist && thiss.father && SetFieldAction.new(thiss.father, \"literals\", thiss.id, '+=', true);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    DEnumerator(/*set it from DLiteral.new() instead literals: DEnumerator[\"literals\"] = []*/): this {\r\n        const thiss: DEnumerator = this.thiss as any;\r\n        // thiss.literals = literals;\r\n        // thiss.isClass = false;\r\n        // thiss.isEnum = true;\r\n        if (this.persist) {\r\n            // if (literals) for (let lit of literals) SetFieldAction.new(lit, \"pointedBy\", PointedBy.fromID(thiss.id, \"literals\"), '+=');\r\n            // update father's collections (pointedby's here are set automatically)\r\n            this.persist && thiss.father && SetFieldAction.new(thiss.father, \"classifiers\", thiss.id, '+=', true);\r\n        }\r\n        return this;\r\n    }\r\n    DEdgePoint(): this { return this; }\r\n    DVoidEdge(): this {\r\n        let thiss: DVoidEdge = this.thiss as any;\r\n        (thiss).midnodes = [];\r\n        return this;\r\n    }\r\n    DVertex(): this { return this; }\r\n    DEdge(): this {\r\n        return this;\r\n    }\r\n    DExtEdge(): this { return this; }\r\n    DRefEdge(): this { return this; }\r\n\r\n    DGraphElement(model: DGraphElement[\"model\"], parentNodeID?: DGraphElement[\"father\"], parentgraphID?: DGraphElement[\"graph\"], nodeID?: DGraphElement[\"id\"]): this {\r\n        const thiss: DGraphElement = this.thiss as any;\r\n        if (parentNodeID) thiss.father = parentNodeID;\r\n        if (parentgraphID) thiss.graph = parentgraphID;\r\n        thiss.model = model;\r\n        thiss.subElements = [];\r\n        if (nodeID) thiss.id = nodeID;\r\n        if (this.persist) {\r\n            model && SetFieldAction.new(model, \"pointedBy\", PointedBy.fromID(thiss.id, \"model\"), '+=');\r\n            parentgraphID && SetFieldAction.new(parentgraphID, \"pointedBy\", PointedBy.fromID(thiss.id, \"graph\"), '+=');\r\n            parentNodeID && SetFieldAction.new(thiss.father, \"pointedBy\", PointedBy.fromID(thiss.id, \"father\"), '+=');\r\n            // update collections (pointedby's here are set automatically)\r\n            parentNodeID && SetFieldAction.new(thiss.father, \"subElements\", thiss.id, '+=', true);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    DViewElement(name: string, jsxString: string, defaultVSize?: GraphSize, usageDeclarations: string = '', constants: string = '',\r\n        preRenderFunc: string = '', appliableToClasses: string[] = [], oclApplyCondition: string = '', priority: number = 1): this {\r\n        const thiss: DViewElement = this.thiss as any;\r\n        thiss.name = name;\r\n        thiss.appliableToClasses = appliableToClasses;\r\n        thiss.jsxString = jsxString;\r\n        thiss.usageDeclarations = usageDeclarations;\r\n        thiss.constants = constants;\r\n        thiss.preRenderFunc = preRenderFunc;\r\n        // thiss.__transient = new DViewTransientProperties();\r\n        thiss.subViews = [];\r\n        thiss.oclApplyCondition = '';\r\n        thiss.explicitApplicationPriority = priority;\r\n        thiss.defaultVSize = defaultVSize || new GraphSize(0, 0, 350, 200);\r\n        thiss.adaptHeight = false;\r\n        thiss.adaptWidth = false;\r\n        thiss.width = 200;\r\n        thiss.height = 100;\r\n\r\n        if (this.persist) {\r\n            // no pointedBy?\r\n        }\r\n        return this;\r\n    }\r\n\r\n    DViewPoint(name: string): this {\r\n        const thiss: DViewPoint = this.thiss as any;\r\n        thiss.name = name;\r\n        return this;\r\n    }\r\n\r\n    static DGraph_maxID: number = 0;\r\n    private static DGraph_makeID(modelid: DGraph[\"model\"]): Pointer<DGraph, 1, 1, LGraph> {\r\n        if (!modelid) {\r\n            throw new Error(\"graph without model, currently not supported.\");\r\n            return '_GraphWithoutModel_';\r\n        }\r\n        return modelid + '^graph' + Constructors.DGraph_maxID++;\r\n    }\r\n    DGraph(model: DGraph[\"model\"], id: string | undefined): this {\r\n        const thiss: DGraph = this.thiss as any;\r\n        thiss.id = id || Constructors.DGraph_makeID(model);\r\n        thiss.graph = thiss.id;\r\n        thiss.zoom = new GraphPoint(1, 1);\r\n        thiss.graphSize = new GraphSize(0, 0, 0, 0);  // GraphSize.apply(this, [0, 0, 0 ,0]);\r\n        thiss._subMaps = { zoom: true, graphSize: true }\r\n        if (this.persist) {\r\n            // no pointedBy?\r\n        }\r\n        return this;\r\n    }\r\n\r\n    DVoidVertex(defaultVSize: GraphSize): this {\r\n        const thiss: DVoidVertex = this.thiss as any;\r\n        thiss.x = defaultVSize.x;\r\n        thiss.y = defaultVSize.y;\r\n        thiss.w = defaultVSize.w;\r\n        thiss.h = defaultVSize.h;\r\n        if (this.persist) {\r\n            // no pointedBy?\r\n        }\r\n        return this;\r\n    }\r\n\r\n\r\n}\r\n// export const Constructors = new _Constructors();\r\n\r\n@RuntimeAccessible\r\nexport class DPointerTargetable extends RuntimeAccessibleClass {\r\n    static defaultComponent: (ownProps: GObject, childrens?: (string | React.Component)[]) => React.ReactElement;\r\n    public static maxID: number = 0;\r\n    public static logic: typeof LPointerTargetable;\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    _storePath?: string[];\r\n    _subMaps?: Dictionary<string, boolean>;\r\n    id!: Pointer<DPointerTargetable, 1, 1, LPointerTargetable>;\r\n    // pointedBy: DocString<'path in store'>[] = []; // NB: potrebbe contenere puntatori invalidi.\r\n    // se viene cancellato un intero oggetto A che contiene una lista di puntatori, gli oggetti che puntano ad A rimuovono A dai loro \"poitnedBy\",\r\n    // ma gli oggetti puntati da A tramite sotto-oggetti o attributi (subviews...) non vengono aggiornati in \"pointedby\"\r\n    pointedBy: PointedBy[] = [];\r\n\r\n\r\n    static defaultname<L extends LModelElement = LModelElement>(startingPrefix: string | ((meta: L) => string), father?: Pointer | DPointerTargetable | ((a: string) => boolean), metaptr?: Pointer | null): string {\r\n        let lfather: LModelElement;\r\n        // startingPrefix = \"model_\", father = ((name: string) => !dmodelnames.includes(name))\r\n        if (father) {\r\n            if (typeof father === \"string\" || (father as any).className) { // Pointer or D\r\n                lfather = LPointerTargetable.wrap(father as DModelElement) as LModelElement;\r\n                if (!lfather) return (typeof startingPrefix === \"string\" ? startingPrefix : \"unnamed_elem\"); // can happen during parse when father ptr exist but it's not in store yet. not a prob\r\n                if (typeof startingPrefix !== \"string\") {\r\n                    let meta = LPointerTargetable.from(metaptr as Pointer);\r\n                    startingPrefix = startingPrefix(meta as L);\r\n                }\r\n                console.log({ father, lfather });\r\n                const childrenNames: (string)[] = lfather.childrens.map(c => (c as LNamedElement).name);\r\n                return U.increaseEndingNumber(startingPrefix + '0', false, false, (newname) => childrenNames.indexOf(newname) >= 0);\r\n            }\r\n            else {\r\n                let condition: (a: string) => boolean = father as any;\r\n                return U.increaseEndingNumber(startingPrefix + '0', false, false, condition);\r\n            }\r\n        }\r\n        return startingPrefix + \"1\";\r\n    }\r\n\r\n    public static new(...a: any): DPointerTargetable { //father?: Pointer, persist: boolean = false, fatherType?: Constructor, ...a:any): DPointerTargetable {\r\n        Log.exx(\"cannot instantiate abstract class DPointerTargetable\");\r\n        return null as any;\r\n        // return new Constructors(new DPointerTargetable('dwc'), father, persist, fatherType).DPointerTargetable().end();\r\n    }\r\n    constructor(fakearg_detectwrongcalls: 'dwc') {\r\n        super();\r\n        if (!fakearg_detectwrongcalls) throw new Error(\"cannot build D-objects using new keyword, use the static D-Class.new method instead\");\r\n    }\r\n\r\n    static fromL<LX extends LPointerTargetable,\r\n        DX = LX extends LEnumerator ? LEnumerator : (LX extends LAttribute ? LAttribute : (LX extends LReference ? LReference : (LX extends LRefEdge ? LRefEdge : (LX extends LExtEdge ? LExtEdge : (LX extends LDataType ? LDataType : (LX extends LClass ? LClass : (LX extends LStructuralFeature ? LStructuralFeature : (LX extends LParameter ? LParameter : (LX extends LOperation ? LOperation : (LX extends LEdge ? LEdge : (LX extends LEdgePoint ? LEdgePoint : (LX extends LGraphVertex ? LGraphVertex : (LX extends LModel ? LModel : (LX extends LValue ? LValue : (LX extends LObject ? LObject : (LX extends LEnumLiteral ? LEnumLiteral : (LX extends LPackage ? LPackage : (LX extends LClassifier ? LClassifier : (LX extends LTypedElement ? LTypedElement : (LX extends LVertex ? LVertex : (LX extends LVoidEdge ? LVoidEdge : (LX extends LVoidVertex ? LVoidVertex : (LX extends LGraph ? LGraph : (LX extends LNamedElement ? LNamedElement : (LX extends LAnnotation ? LAnnotation : (LX extends LGraphElement ? LGraphElement : (LX extends LMap ? LMap : (LX extends LModelElement ? LModelElement : (LX extends LUser ? LUser : (LX extends LPointerTargetable ? LPointerTargetable : (ERROR)))))))))))))))))))))))))))))))\r\n    >(data: LX): DX {\r\n        return data.__raw as any;\r\n    }\r\n\r\n\r\n    static fromPointer<// LOW extends number, UPP extends number | 'N',\r\n        T extends Pointer | Pointer[], // <DPointerTargetable, 1, 'N', LPointerTargetable>,\r\n        DDD extends (T extends Pointer<infer D> ? D : 'undefined D'),\r\n        LOW extends (T extends Pointer<any, infer LO> ? LO : 'undefined_upp'),\r\n        UPP extends (T extends Pointer<any, number, infer UP> ? UP : 'undefined_low'),\r\n\r\n        DDDARR extends (T extends Pointer<infer D>[] ? D : 'undefined_DARR'),\r\n        LOWARR extends (T extends Pointer<any, infer LO>[] ? LO : 'undefined_uppARR'),\r\n        UPPARR extends (T extends Pointer<any, number, infer UP>[] ? 'UP_is_N' : 'undefined_lowARR'),\r\n\r\n        RET = UPPARR extends 'UP_is_N' ?\r\n        (DDDARR[]) : // 0...N\r\n        (UPP extends 1 ? (LOW extends 0 ? DDD | null : DDD) : // 0...1 && 1...1\r\n            (LOW extends 1 ? DDD : undefined)  //1...1\r\n        ),\r\n        INFERRED = { ret: RET, upp: UPP, low: LOW, ddd: DDD, dddARR: DDDARR, lowARR: LOWARR, uppARR: UPPARR },>(ptr: T, s?: IStore)\r\n        : RET {\r\n        s = s || store.getState();\r\n        if (Array.isArray(ptr)) {\r\n            return ptr.map((p: Pointer) => DPointerTargetable.fromPointer(p, s)) as any;\r\n        }\r\n        if (typeof ptr !== \"string\") { ptr = (ptr as any)?.id; }\r\n        if (typeof ptr !== \"string\") { throw new Error(\"wrong parameter in DPointerTargetable.fromPointers()\"); }\r\n        return s.idlookup[ptr as string] as any;\r\n    }\r\n    static from<// LOW extends number, UPP extends number | 'N',\r\n        PTR extends Pointer | Pointer[], // <DPointerTargetable, 1, 'N', LPointerTargetable>,\r\n        DDD extends (PTR extends Pointer<infer D> ? D : 'undefined D'),\r\n        LOW extends (PTR extends Pointer<any, infer LO> ? LO : 'undefined_upp'),\r\n        UPP extends (PTR extends Pointer<any, number, infer UP> ? UP : 'undefined_low'),\r\n\r\n        DDDARR extends (PTR extends Pointer<infer D>[] ? D : 'undefined_DARR'),\r\n        LOWARR extends (PTR extends Pointer<any, infer LO>[] ? LO : 'undefined_uppARR'),\r\n        UPPARR extends (PTR extends Pointer<any, number, infer UP>[] ? 'UP_is_N' : 'undefined_lowARR'),\r\n\r\n        LX extends LPointerTargetable,\r\n\r\n        RETPTR = UPPARR extends 'UP_is_N' ?\r\n        (DDDARR[]) : // 0...N\r\n        (UPP extends 1 ? (LOW extends 0 ? DDD | null : DDD) : // 0...1 && 1...1\r\n            (LOW extends 1 ? DDD : undefined)  //1...1\r\n        ),\r\n\r\n\r\n        // DX = LX extends LEnumerator ? DEnumerator : (LX extends LAttribute ? DAttribute : (LX extends LReference ? DReference : (LX extends LDataType ? DDataType : (LX extends LClass ? DClass : (LX extends LStructuralFeature ? DStructuralFeature : (LX extends LParameter ? DParameter : (LX extends LOperation ? DOperation : (LX extends LModel ? DModel : (LX extends LValue ? DValue : (LX extends LObject ? DObject : (LX extends LEnumLiteral ? DEnumLiteral : (LX extends LPackage ? DPackage : (LX extends LClassifier ? DClassifier : (LX extends LTypedElement ? DTypedElement : (LX extends LNamedElement ? DNamedElement : (LX extends LAnnotation ? DAnnotation : ('ERROR'))))))))))))))))),\r\n        DX = LX extends LEnumerator ? DEnumerator : (LX extends LAttribute ? DAttribute : (LX extends LReference ? DReference : (LX extends LRefEdge ? DRefEdge : (LX extends LExtEdge ? DExtEdge : (LX extends LDataType ? DDataType : (LX extends LClass ? DClass : (LX extends LStructuralFeature ? DStructuralFeature : (LX extends LParameter ? DParameter : (LX extends LOperation ? DOperation : (LX extends LEdge ? DEdge : (LX extends LEdgePoint ? DEdgePoint : (LX extends LGraphVertex ? DGraphVertex : (LX extends LModel ? DModel : (LX extends LValue ? DValue : (LX extends LObject ? DObject : (LX extends LEnumLiteral ? DEnumLiteral : (LX extends LPackage ? DPackage : (LX extends LClassifier ? DClassifier : (LX extends LTypedElement ? DTypedElement : (LX extends LVertex ? DVertex : (LX extends LVoidEdge ? DVoidEdge : (LX extends LVoidVertex ? DVoidVertex : (LX extends LGraph ? DGraph : (LX extends LNamedElement ? DNamedElement : (LX extends LAnnotation ? DAnnotation : (LX extends LGraphElement ? DGraphElement : (LX extends LMap ? DMap : (LX extends LModelElement ? DModelElement : (LX extends LUser ? DUser : (LX extends LPointerTargetable ? DPointerTargetable : (ERROR))))))))))))))))))))))))))))))),\r\n        RET = DX extends 'ERROR' ? RETPTR : (RETPTR extends DX ? RETPTR : DX),\r\n        INFERRED = { ret: RET, RETPTR: RETPTR, upp: UPP, low: LOW, ddd: DDD, dddARR: DDDARR, lowARR: LOWARR, uppARR: UPPARR, LX: LX, DX: DX }>(ptr: PTR | LX, s?: IStore)\r\n        : RET {\r\n        s = s || store.getState();\r\n        return s.idlookup[ptr as string] as any;\r\n    }\r\n    static from0(a: any, ...aa: any): any { return null; }\r\n    static writeable<LX extends LPointerTargetable, WX = LtoW<LX>>(l: LX): WX { return l as any; }\r\n}\r\n/*\r\nlet d0: LClassifier = null as any;\r\nlet ptrr: Pointer<DPackage, 1, 'N', LPackage> = null as any;\r\nlet ptr1: Pointer<DPackage, 1, 1, LPackage> = null as any;\r\nlet dd = DPointerTargetable.from(d0.id);\r\n*/\r\n\r\n\r\n/*\r\ntype Pack1<D extends DPointerTargetable, L extends LPointerTargetable = DtoL<D>, P extends Pointer<D, 0, 1, L> = Pointer<D, 0, 1, L>, R = {D:D, L:L, P:P} > = P|D|L\r\ntype PackArr<D extends DPointerTargetable, L extends LPointerTargetable = DtoL<D>, P extends Pointer<D, 0, 1, L> = Pointer<D, 0, 1, L> , ARR = Pack1<D>> = (ARR)[];\r\ntype Pack<D extends DPointerTargetable, L extends LPointerTargetable = DtoL<D>, P extends Pointer<D, 0, 1, L> = Pointer<D, 0, 1, L> , ARR = Pack1<D>> = ARR | (ARR)[];*/\r\n\r\n\r\n\r\n@RuntimeAccessible\r\nexport class Pointers {\r\n    static filterValid<P extends (Pointer | Pointer[]) = any, RET = P extends Pointer[] ? P : P | null>\r\n        (p: P): P | null {\r\n        const pointerval: DPointerTargetable | DPointerTargetable[] = DPointerTargetable.from(p);\r\n        if (Array.isArray(pointerval)) return pointerval.filter(p => !!p).map(p => p.id) as P;\r\n        if (!pointerval) return null;\r\n        return pointerval.id as P;\r\n    }\r\n\r\n    fromArr<D extends DPointerTargetable, L extends LPointerTargetable, P extends Pointer>(val: (P | D | L | null | undefined)[] | (P | D | L | null | undefined)): P[] {\r\n        if (!val) val = [];\r\n        if (!Array.isArray(val)) { val = [val]; }\r\n        if (!val.length) { return []; }\r\n        if ((val[0] as any).id) { val = (val as any as (LModelElement | DModelElement)[]).filter(v => !!v).map((v) => v.id) as any[]; }\r\n        return val.filter(v => !!v) as any[];\r\n    }\r\n\r\n    fromm<D extends DPointerTargetable, L extends LPointerTargetable, P extends Pointer>(val: (P | D | L)): P | null { return !val ? null : (val as any).id; }\r\n\r\n    from0<// LOW extends number, UPP extends number | 'N',\r\n        PTR extends Pointer | Pointer[], // <DPointerTargetable, 1, 'N', LPointerTargetable>,\r\n        // DDD extends (PTR extends Pointer<infer D> ? D : 'undefined_D'),\r\n        LOW extends (PTR extends Pointer<any, infer LO> ? LO : 'undefined_upp'),\r\n        UPP extends (PTR extends Pointer<any, number, infer UP> ? UP : 'undefined_low'),\r\n        DDD extends (PTR extends Pointer<any, number, any, infer LL> ? LL : 'undefined_L'),\r\n\r\n        LOWARR extends (PTR extends Pointer<any, infer LO>[] ? LO : 'undefined_uppARR'),\r\n        UPPARR extends (PTR extends Pointer<any, number, infer UP>[] ? 'UP_is_N' : 'undefined_lowARR'),\r\n        DDDARR extends (PTR extends Pointer<any, any, any, infer LL>[] ? LL : 'undefined_LARR'),\r\n\r\n        DX extends DPointerTargetable,\r\n        LX extends LPointerTargetable,\r\n        WX extends WPointerTargetable,\r\n        RETPTR = UPPARR extends 'UP_is_N' ?\r\n        (DDDARR[]) : // 0...N\r\n        (UPP extends 1 ? (LOW extends 0 ? DDD | null : DDD) : // 0...1 && 1...1\r\n            (LOW extends 1 ? DDD : undefined)  //1...1\r\n        ),\r\n\r\n\r\n        // DX = LX extends LEnumerator ? DEnumerator : (LX extends LAttribute ? DAttribute : (LX extends LReference ? DReference : (LX extends LDataType ? DDataType : (LX extends LClass ? DClass : (LX extends LStructuralFeature ? DStructuralFeature : (LX extends LParameter ? DParameter : (LX extends LOperation ? DOperation : (LX extends LModel ? DModel : (LX extends LValue ? DValue : (LX extends LObject ? DObject : (LX extends LEnumLiteral ? DEnumLiteral : (LX extends LPackage ? DPackage : (LX extends LClassifier ? DClassifier : (LX extends LTypedElement ? DTypedElement : (LX extends LNamedElement ? DNamedElement : (LX extends LAnnotation ? DAnnotation : ('ERROR'))))))))))))))))),\r\n        LXX = DtoL<DX>,\r\n        DXX = LtoD<LX>,\r\n        LXFinal = LXX extends 'ERROR' ? LX : LXX,\r\n        DXFinal = DXX extends 'ERROR' ? DX : DXX,\r\n        RET = { d: DXFinal, l: LXFinal }, // Pointer<DX, 0 | 1, 1 | 'N', LX>\r\n        INFERRED = { ret: RET, RETPTR: RETPTR, LXX: LXX, DXX: DXX, upp: UPP, low: LOW, ddd: DDD, dddARR: DDDARR, lowARR: LOWARR, uppARR: UPPARR, LX: LX, DX: DX }>(data: LX | DX | WX)\r\n        : INFERRED {\r\n        return null as any;\r\n    }\r\n\r\n\r\n    static from00<\r\n        // LOW extends number, UPP extends number | 'N',\r\n        // DDD extends (PTR extends Pointer<infer D> ? D : 'undefined_D'),\r\n        DWL extends { id: any },\r\n        // PCK extends (T extends Pack<infer PPP> ? PPP : never),\r\n        //ISARR extends (T extends any[] ? true : false),\r\n        // PCK1 extends (T extends any[] ? null : T extends Pack1<infer PPP> ? PPP : never), //         PCK1 extends (T extends any[] ? true : false),\r\n        // PCKA extends (T extends PackArr<infer PPP> ? PPP : 'undefined_arrpack'),\r\n        // PTR extends DWL[\"id\"], // <DPointerTargetable, 1, 'N', LPointerTargetable>,\r\n        // T extends DWL | DWL[] | null | undefined,\r\n        /*DX extends (PTR extends Pointer<infer D0> ? D0 : 'undefined_D'),\r\n        LOW extends (PTR extends Pointer<any, infer LO> ? LO : 'undefined_upp'),\r\n        UPP extends (PTR extends Pointer<any, number, infer UP> ? UP : 'undefined_low'),\r\n        LX extends (PTR extends Pointer<any, number, any, infer LL> ? LL : 'undefined_L'),\r\n\r\n        LOWARR extends (PTR extends Pointer<any, infer LO>[] ? LO : 'undefined_uppARR'),\r\n        UPPARR extends (PTR extends Pointer<any, number, infer UP>[] ? 'UP_is_N' : 'undefined_lowARR'),\r\n        DDDARR extends (PTR extends Pointer<any, any, any, infer LL>[] ? LL : 'undefined_LARR'),\r\n        RET = DX extends DPointerTargetable ? ( LOW extends number ? ( UPP extends number ? ( LX extends LPointerTargetable ? Pointer<DX, LOW, UPP, LX> : '_notret_L_') : '_notret_UPP_') : '_notret_LOW_') : '_notret_D_'\r\n        */\r\n        PTRPARAM = Pointer | Pointer[],\r\n        T = Exclude<DWL | DWL[] | PTRPARAM, unknown[]>,\r\n        // @ts-ignore\r\n        PTR = T extends null ? null : T extends undefined ? null : (T extends PTRPARAM ? T : (T extends any[] ? T[number]['id'][] : T['id'])),\r\n    // RET extends Pointer<DPointerTargetable, any, any, LPointerTargetable> = T extends DWL ? DWL[\"id\"] : (T extends DWL[] ? DWL[\"id\"] : null),\r\n    // INF = { PCK:PCK, ISARR: ISARR,  PTR: PTR, DWL: DWL, RET: RET}, // {DD:DD, LL: LL}//\r\n    >(data: T | T[]): PTR { // RET | RET[] {\r\n        if (Array.isArray(data)) return data.filter(d => !!d).map(d => (typeof d === \"string\" ? d : (d as any as DWL).id)) as any;\r\n        else return (data ? (data as any).id : null);\r\n    } // stavolta fai infer so D|l.id\r\n\r\n\r\n    public static from<DX extends DPointerTargetable>(data: DX): DX[\"id\"]; // | {D:any};\r\n    public static from<DX extends DPointerTargetable>(data: DX[]): DX[\"id\"][]; // | {DD:any};\r\n    public static from<LX extends LPointerTargetable>(data: LX): LX[\"id\"]; // | {L:any};\r\n    public static from<LX extends LPointerTargetable>(data: LX[]): LX[\"id\"][]; // | {LL:any};\r\n    public static from<WX extends WPointerTargetable>(data: WX): WX[\"id\"]; // | {W:any};\r\n    public static from<WX extends WPointerTargetable>(data: WX[]): WX[\"id\"][]; // | {WW:any};\r\n    public static from<PTR extends Pointer<DPointerTargetable, 1, 1, LPointerTargetable>>(data: PTR): PTR; // | {P:any};\r\n    public static from<PTR extends Pointer<DPointerTargetable, 1, 1, LPointerTargetable>>(data: PTR[]): PTR[]; // | {PP:any};\r\n    public static from<T extends LPointerTargetable>(data: Pack1<T>): Pointer<LtoD<T>, 1, 1, T>; //{TEST1:any};\r\n    public static from<T extends LPointerTargetable>(data: Pack1<T>[]): Pointer<LtoD<T>, 1, 1, T>[]; //{TEST111:any};\r\n    public static from<T extends LPointerTargetable>(data: Pack<T>): Pointer<LtoD<T>, 1, 1, T>[]; //{TEST0:any};\r\n    public static from<P extends Pack<T> | undefined, T extends LPointerTargetable>(data: P): Pointer<LtoD<T>, 1, 1, T>[]; //{TEST0:any};\r\n    public static from<T extends LPointerTargetable>(data: PackArr<T>): Pointer<LtoD<T>, 1, 1, T>[]; //{TESTARR:any};\r\n    public static from<T extends LPointerTargetable>(data: Pack1<T[]>): Pointer<LtoD<T>, 1, 1, T>; //{TEST1:any};\r\n    public static from<T extends LPointerTargetable>(data: Pack1<T[]>[]): Pointer<LtoD<T>, 1, 1, T>[]; //{TEST111:any};\r\n    public static from<T extends LPointerTargetable>(data: Pack<T[]>): Pointer<LtoD<T>, 1, 1, T>[]; //{TEST0:any};\r\n    public static from<T extends LPointerTargetable>(data: PackArr<T[]>): Pointer<LtoD<T>, 1, 1, T>[]; //{TESTARR:any};\r\n\r\n    /*\r\n        public static from(data:undefined): undefined; // | {D:any};\r\n        public static from<DX extends DPointerTargetable | undefined | null>(data:DX): DX extends DPointerTargetable ? DX[\"id\"] : DX; // | {D:any};\r\n        public static from<DX extends DPointerTargetable | undefined | null>(data:DX[]): DX extends DPointerTargetable ? DX[\"id\"][] : DX; // | {DD:any};\r\n        public static from<LX extends LPointerTargetable | undefined | null>(data:LX): LX extends LPointerTargetable ? LX[\"id\"] : LX; // | {L:any};\r\n        public static from<LX extends LPointerTargetable | undefined | null>(data:LX[]): LX extends LPointerTargetable ? LX[\"id\"][] : LX; // | {LL:any};\r\n        public static from<WX extends WPointerTargetable | undefined | null>(data:WX): WX extends WPointerTargetable ? WX[\"id\"] : WX; // | {W:any};\r\n        public static from<WX extends WPointerTargetable | undefined | null>(data:WX[]): WX extends WPointerTargetable ? WX[\"id\"][] : WX; // | {WW:any};\r\n        public static from<PTR extends Pointer<DPointerTargetable, 1, 1, LPointerTargetable> | undefined | null>(data:PTR): PTR extends Pointer<DPointerTargetable, 1, 1, LPointerTargetable> ? PTR : PTR; // | {P:any};\r\n        public static from<PTR extends Pointer<DPointerTargetable, 1, 1, LPointerTargetable> | undefined | null>(data:PTR[]): PTR extends Pointer<DPointerTargetable, 1, 1, LPointerTargetable> ? PTR[] : PTR; // | {PP:any};\r\n        public static from<T extends LPointerTargetable | undefined | null>(data:Pack1<T>): T extends LPointerTargetable ? Pointer<LtoD<T>, 1, 1, T> : T; //{TEST1:any};\r\n        public static from<T extends LPointerTargetable | undefined | null>(data:Pack1<T>[]): T extends LPointerTargetable ? Pointer<LtoD<T>, 1, 1, T>[] : T; //{TEST111:any};\r\n        public static from<T extends LPointerTargetable | undefined | null>(data:Pack<T>): T extends LPointerTargetable ? Pointer<LtoD<T>, 1, 1, T>[] : T; //{TEST0:any};\r\n        public static from<T extends LPointerTargetable | undefined | null>(data:PackArr<T>): T extends LPointerTargetable ? Pointer<LtoD<T>, 1, 1, T>[] : T; //{TESTARR:any};\r\n        // public static from<T extends LPointerTargetable | undefined | null>(data:Pack1<T[]>): T extends LPointerTargetable ? Pointer<LtoD<T>, 1, 1, T> : T; //{TEST1:any};\r\n        // public static from<T extends LPointerTargetable | undefined | null>(data:Pack1<T[]>[]): T extends LPointerTargetable ? Pointer<LtoD<T>, 1, 1, T>[] : T; //{TEST111:any};\r\n        // DDD extends (T extends Pointer<infer D> ? D : 'undefined D'),*/\r\n    public static from<TT extends Pack<LPointerTargetable[]> | undefined | null,\r\n        // @ts-ignore\r\n        T extends (TT extends Pack<infer PTYPE> ? PTYPE : undefined)>(data: T): T extends null | undefined ? T : Pointer<LtoD<T>, 1, 1, T>[]; //{TEST0:any};\r\n    // @ts-ignore\r\n    public static from<T extends LPointerTargetable | undefined | null>(data: PackArr<T[]>): T extends null | undefined ? T : Pointer<LtoD<T>, 1, 1, T>[]; //{TESTARR:any};\r\n    public static from(data: null | undefined): null; // | {Dn:any};\r\n    public static from(data: (null | undefined)[]): []; // | {Dnn:any};\r\n    public static from(data: (null | undefined) | (null | undefined)[]): []; // | {Dn0:any};\r\n\r\n    // function from<PTR extends Pointer<DPointerTargetable, 1, 1, LPointerTargetable>>(data:unknown | unknown[]): PTR | PTR[] | GObject {\r\n    public static from<T extends LClass, PTR extends Pointer<DPointerTargetable, 1, 1, LPointerTargetable>>(data: unknown | unknown[]): null | PTR | PTR[] {\r\n        if (!data) return null;\r\n        if (Array.isArray(data)) return data.filter(d => !!d).map(d => (typeof d === \"string\" ? d : (d as any).id)) as any;\r\n        return typeof data === \"string\" ? data : (data as any).id;\r\n    }\r\n\r\n    static isPointer(val: any): boolean {\r\n        // todo: must refine this in a safer way\r\n        return val?.includes ? val.includes(\"Pointer\") : false;\r\n    }\r\n}\r\n/*\r\nexport type Pack1<L extends LPointerTargetable | undefined | null,\r\n    // L extends LPointerTargetable | undefined | null = LL extends LPointerTargetable[] ? LPointerTargetable : null | undefined,\r\n    D extends (L extends LPointerTargetable ? LtoD<L> : undefined | null) = (L extends LPointerTargetable ? LtoD<L> : undefined | null)> =\r\n    L extends LPointerTargetable ? ( D extends DPointerTargetable ? D | L /*| LtoW<L>* / | Pointer<D, 1, 1, L> : L) : undefined;\r\nexport type PackArr<LL extends orArr<LPointerTargetable> | undefined | null,\r\n    L extends LPointerTargetable | undefined | null = LL extends undefined | null ? undefined : unArr<LL>> = Pack1<L>[];\r\nexport type Pack<\r\n    LL extends orArr<LPointerTargetable> | undefined | null,\r\n    L extends unArr<LL> = unArr<LL>,\r\n    // L extends (LL extends orArr<LPointerTargetable> ? LPointerTargetable : undefined | null) = (LL extends orArr<LPointerTargetable> ? unArr<LL> : undefined)\r\n    >\r\n    = LL extends undefined ? undefined : Pack1<L> | PackArr<L>;\r\n*/\r\nexport type Pack1<LL extends orArr<LPointerTargetable> | undefined, L extends LPointerTargetable | undefined = unArr<LL>,\r\n    D extends (L extends LPointerTargetable ? LtoD<L> : undefined) = (L extends LPointerTargetable ? LtoD<L> : undefined)> =\r\n    L extends LPointerTargetable ? (D extends DPointerTargetable ? D | L | Pointer<D, 1, 1, L> : undefined) : undefined;\r\nexport type PackArr<LL extends orArr<LPointerTargetable> | undefined, L extends LPointerTargetable | undefined = unArr<LL>> = Pack1<L>[];\r\nexport type Pack<LL extends orArr<LPointerTargetable> | undefined, L extends LPointerTargetable | undefined = unArr<LL>> = L extends undefined ? undefined : Pack1<L> | PackArr<L>;\r\n/*\r\nlet n: any = null;\r\nlet aa: DClass = n;\r\nlet ptrr = Pointers.from(aa.parent);\r\naa.parent = ptrr;*/\r\n\r\n@RuntimeAccessible\r\nexport class PendingPointedByPaths {\r\n    static all: PendingPointedByPaths[] = [];\r\n    // static pendingMoreThanTwice: ParsedAction[] = [];\r\n    static maxSolveAttempts: number = 20;\r\n    public solveAttempts: number = 1;\r\n    private stackTrace: string[];\r\n\r\n    // tmp fields, not sure what i need\r\n    public action!: ParsedAction; // todo: remove\r\n    static new(action: ParsedAction, oldState: IStore): PendingPointedByPaths {\r\n        const ptr: Pointer = action.value;\r\n        const target: DPointerTargetable | null = oldState.idlookup[ptr as string];\r\n        let pendingPointedBy = new PendingPointedByPaths(action.path, ptr);\r\n        pendingPointedBy.action = action;\r\n        return pendingPointedBy;\r\n    }\r\n\r\n    private constructor(\r\n        public from: DocString<\"full Path in store including field key\">,\r\n        // todo 6: how about actions that do not include index but just += -= [] ?\r\n        public to: Pointer) {\r\n        this.stackTrace = U.getStackTrace();\r\n    }\r\n    static attemptimplementationdelete(pb: PointedBy) {\r\n        let state: IStore = store.getState();\r\n        let objectChain = U.followPath(state, pb.source);\r\n    }\r\n\r\n    public attemptResolve(state: IStore): ParsedAction | null {\r\n        if (this.canBeResolved(state)) return this.resolve();\r\n        return null;\r\n    }\r\n\r\n    private resolve(): ParsedAction {\r\n        U.arrayRemoveAll(PendingPointedByPaths.all, this);\r\n        return Action.parse(SetRootFieldAction.create(\"idlookup.\" + this.to + '.pointedBy', PointedBy.new(this.action.path), '+=', false));\r\n    }\r\n\r\n    public saveForLater(): void { PendingPointedByPaths.all.push(this); }\r\n    private canBeResolved(state: IStore): boolean {\r\n        this.solveAttempts++;\r\n        if (this.solveAttempts >= PendingPointedByPaths.maxSolveAttempts) Log.ex(\"pending PointedBy action is not revolved for too long, some pointer was wrongly set up.\", this.stackTrace, this, state);\r\n        return !!state.idlookup[this.to];\r\n    }\r\n\r\n    static getSolveableActions(oldState: IStore): ParsedAction[] {\r\n        let allClone = [...this.all]; // necessary because the array will remove some elements during iteration as they are solved.\r\n        return allClone.map(p => p.attemptResolve(oldState)).filter(p => (!!p)) as ParsedAction[];\r\n    }\r\n}\r\n\r\n@RuntimeAccessible\r\nexport class PointedBy {\r\n    static list: string[] = [\"father\", \"parent\", \"annotations\", \"packages\", \"type\", \"subpackages\", \"classifiers\", \"exceptions\", \"parameters\", \"defaultValue\", \"instances\", \"operations\", \"features\", \"attributes\", \"references\", \"extends\", \"extendedBy\", \"implements\", \"implementedBy\", \"instanceof\", \"edges\", \"target\", \"opposite\", \"parameters\", \"exceptions\", \"literals\"];\r\n    source: string; // elemento da cui parte il puntatore\r\n    // field: keyof DPointerTargetable;\r\n    // il bersaglio non c'è qui, perchè è l'oggetto che contiene questo dentro l'array pointedBy\r\n\r\n    /*private constructor(source: DPointerTargetable, field: any) {\r\n        this.source = source;\r\n        this.field = field;\r\n    }*/\r\n\r\n    static getPath(p: PointedBy): string { return p.source.substring(0, p.source.lastIndexOf(\".\")); }\r\n    static getLastKey(p: PointedBy): string { return p.source.substring(p.source.lastIndexOf(\".\")); }\r\n    static getPathArr(p: PointedBy): string[] { return p.source.split('.'); }\r\n    private constructor(source: string) {\r\n        this.source = source;\r\n    }\r\n    static fromID<D extends DPointerTargetable>(ptr: Pointer<D>, field: keyof D) {\r\n        // Giordano: add ignore for webpack\r\n        //@ts-ignore\r\n        return PointedBy.new(\"idlookup.\" + ptr + \".\" + field);\r\n    }\r\n    static new(source: DocString<\"full path in store including key. like \\'idlookup.id.extends\\'\">, modifier: \"-=\" | \"+=\" | undefined = undefined, action?: ParsedAction): PointedBy {\r\n        // let source: DocString<\"full path in store including key\"> = action.path;\r\n        // if (source.includes(\"true\")) { console.error(this, action); throw new Error(\"mixed a bool\"); }\r\n        if (modifier) source = source.substring(0, source.length - (modifier?.length || 0));\r\n        return new PointedBy(source);\r\n    }\r\n    // static new0<D extends DPointerTargetable> (source: D, field: keyof D): PointedBy { return new PointedBy(source, field); }\r\n\r\n\r\n\r\n    public static remove(oldValue: Pointer | undefined, action: ParsedAction, state: IStore, casee: \"+=\" | \"-=\" | undefined = undefined): IStore {\r\n        if (!oldValue) return state;\r\n        let oldtarget: DPointerTargetable = state.idlookup[oldValue];// todo: if += -=\r\n        if (!oldtarget) return state;\r\n        let index = -1;\r\n        let actionpath: string = action.path.substring(0, action.path.length - (casee?.length || 0))\r\n        for (let i = 0; i < oldtarget.pointedBy.length; i++) { if (oldtarget.pointedBy[i].source === actionpath) { index = i; break; } }\r\n        if (index >= 0) {\r\n            state = { ...state };\r\n            state.idlookup = { ...state.idlookup };\r\n            state.idlookup[oldValue] = { ...oldtarget, pointedBy: [...oldtarget.pointedBy] } as any;\r\n            state.idlookup[oldValue].pointedBy.splice(index, 1) // in-place edit\r\n        }\r\n        // console.warn('pointedby remove:', {from: oldtarget.pointedBy, to: state.idlookup[oldValue].pointedBy, obj: state.idlookup[oldValue], index, oldValue, actionpath});\r\n        return state;\r\n    }\r\n\r\n    public static add(newtargetptr: Pointer | undefined, action: ParsedAction, state: IStore, casee: \"+=\" | \"-=\" | undefined = undefined): IStore {\r\n        if (!newtargetptr) return state;\r\n        // todo: if can't be done because newtarget doesn't exist, build an action from this and set it pending.\r\n        let newtarget: DPointerTargetable = state.idlookup[newtargetptr];\r\n        if (!newtarget) {\r\n            PendingPointedByPaths.new(action, state).saveForLater(); // {from: action.path, field: action.field, to: target});\r\n            return state;\r\n        }\r\n        let oldtarget = { ...newtarget, pointedBy: [...newtarget.pointedBy] }\r\n        state = { ...state };\r\n        state.idlookup = { ...state.idlookup };\r\n        state.idlookup[newtargetptr] = { ...newtarget, pointedBy: [...newtarget.pointedBy, PointedBy.new(action.path, casee)] } as any;\r\n        // console.warn('pointedby add:', {from: oldtarget.pointedBy, to: state.idlookup[newtargetptr].pointedBy, obj: state.idlookup[newtargetptr]});\r\n        return state;\r\n    }\r\n}\r\n\r\ntype AnyPointer = Pointer<DPointerTargetable, number, number | 'N', LPointerTargetable>;\r\n\r\n@RuntimeAccessible\r\nexport class LPointerTargetable<Context extends LogicContext<DPointerTargetable> = any, D extends DPointerTargetable = DPointerTargetable> extends DPointerTargetable {\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    public static structure: typeof DPointerTargetable;\r\n    public static singleton: LPointerTargetable;\r\n    public __raw!: DPointerTargetable;\r\n    public pointedBy!: PointedBy[];\r\n\r\n    protected wrongAccessMessage(str: string): any {\r\n        let msg = \"Method \" + str + \" should not be called directly, attempting to do so should trigger get_\" + str + \"(). This is only a signature for type checking.\";\r\n        Log.ex(msg);\r\n        throw new Error(msg);\r\n    }\r\n\r\n    public toString(): string { throw this.wrongAccessMessage(\"toString\"); }\r\n    protected get_toString(context: Context): () => string {\r\n        const data = context.data as DNamedElement;\r\n        return () => (data.name ? data.name : data.className.substring(0));\r\n        // return () => data.id;\r\n    }\r\n\r\n\r\n    protected cannotSet(field: string): boolean { return Log.exx('\"' + field + '\" field is read-only', this); }\r\n    protected get_id(context: Context): this[\"id\"] { return context.data.id; }\r\n    protected set_id(): boolean { return this.cannotSet('id'); }\r\n\r\n    protected _get_default<DD extends DPointerTargetable, T extends string & keyof (DD) & keyof (L), L extends LModelElement = LModelElement>(data: DD, key: T): L[T] {\r\n        // @ts-ignore\r\n        return LPointerTargetable.from(data[key]);\r\n    }\r\n\r\n    public delete(): void { throw this.wrongAccessMessage(\"delete\"); }\r\n    public _delete(context: Context): void { new DeleteElementAction(context.data); }\r\n    protected get_delete(context: Context): () => void {\r\n        return () => {\r\n            alert(\"Delete in LPOINTER\")\r\n            this._delete(context);\r\n        }\r\n    }\r\n\r\n    public get__extends(superClassName: string, context: LogicContext<DPointerTargetable>): boolean {\r\n        return RuntimeAccessibleClass.extends(context.data.className, superClassName);\r\n    }\r\n\r\n    /*\r\n    public get_pointedBy(superClassName: string, context: LogicContext<DPointerTargetable>): LPointerTargetable[] {\r\n        let state: GObject = windoww.store.getState();\r\n        function getForemostObjectInPath(path: DocString<'storePath'>): undefined | LPointerTargetable {\r\n            let lastPointableObject: undefined | DPointerTargetable;\r\n            let pathArray = path.split('.');\r\n            for (let key of pathArray) {\r\n                let currentObj: GObject = state[key];\r\n                if (!currentObj) break;\r\n                if (currentObj && currentObj.id && state.idlookup[currentObj.id]) lastPointableObject = state.idlookup[currentObj.id];\r\n            }\r\n            return lastPointableObject && DPointerTargetable.wrap(lastPointableObject);\r\n        }\r\n        return (context.data.pointedBy || []).map(getForemostObjectInPath).filter( lobj => !!lobj) as LPointerTargetable[];\r\n    }*/\r\n\r\n    public set_pointedBy(val: never, context: LogicContext<DPointerTargetable>): boolean {\r\n        windoww.Log.exx('pointedBy field should never be directly edited.', { context, val });\r\n        return false;\r\n    }\r\n\r\n\r\n\r\n\r\n    static fromD<DX extends DPointerTargetable,\r\n        LX = DX extends DEnumerator ? LEnumerator : (DX extends DAttribute ? LAttribute : (DX extends DReference ? LReference : (DX extends DRefEdge ? LRefEdge : (DX extends DExtEdge ? LExtEdge : (DX extends DDataType ? LDataType : (DX extends DClass ? LClass : (DX extends DStructuralFeature ? LStructuralFeature : (DX extends DParameter ? LParameter : (DX extends DOperation ? LOperation : (DX extends DEdge ? LEdge : (DX extends DEdgePoint ? LEdgePoint : (DX extends DGraphVertex ? LGraphVertex : (DX extends DModel ? LModel : (DX extends DValue ? LValue : (DX extends DObject ? LObject : (DX extends DEnumLiteral ? LEnumLiteral : (DX extends DPackage ? LPackage : (DX extends DClassifier ? LClassifier : (DX extends DTypedElement ? LTypedElement : (DX extends DVertex ? LVertex : (DX extends DVoidEdge ? LVoidEdge : (DX extends DVoidVertex ? LVoidVertex : (DX extends DGraph ? LGraph : (DX extends DNamedElement ? LNamedElement : (DX extends DAnnotation ? LAnnotation : (DX extends DGraphElement ? LGraphElement : (DX extends DMap ? LMap : (DX extends DModelElement ? LModelElement : (DX extends DUser ? LUser : (DX extends DPointerTargetable ? LPointerTargetable : (ERROR))))))))))))))))))))))))))))))),\r\n    >(data: DX): LX {\r\n        // return null as any;\r\n        if (Array.isArray(data)) return LPointerTargetable.wrapAll(data) as any;\r\n        return LPointerTargetable.wrap(data) as any;\r\n    }\r\n\r\n\r\n    static fromPointer<\r\n        T extends AnyPointer | AnyPointer[], // <DPointerTargetable, 1, 'N', LPointerTargetable>,\r\n        DDD extends (T extends Pointer<any, any, any, infer D> ? D : 'undefined L'),\r\n        LOW extends (T extends Pointer<any, infer LO> ? LO : 'undefined_upp'),\r\n        UPP extends (T extends Pointer<any, number, infer UP> ? UP : 'undefined_low'),\r\n\r\n        DDDARR extends (T extends Pointer<any, any, any, infer D>[] ? D : 'undefined_DARR'),\r\n        LOWARR extends (T extends Pointer<any, infer LO>[] ? LO : 'undefined_uppARR'),\r\n        UPPARR extends (T extends Pointer<any, number, infer UP>[] ? 'UP_is_N' : 'undefined_lowARR'),\r\n\r\n        RET = UPPARR extends 'UP_is_N' ?\r\n        (DDDARR[]) : // 0...N\r\n        (UPP extends 1 ? (LOW extends 0 ? DDD | null : DDD) : // 0...1 && 1...1\r\n            (LOW extends 1 ? DDD : undefined)  //1...1\r\n        ),\r\n        INFERRED = { ret: RET, upp: UPP, low: LOW, ddd: DDD, dddARR: DDDARR, lowARR: LOWARR, uppARR: UPPARR },>(ptr: T | undefined, state?: IStore)\r\n        : RET {\r\n        // return null as any;\r\n        if (Array.isArray(ptr)) return LPointerTargetable.wrapAll(ptr as any, undefined, '', false, state) as any;\r\n        return LPointerTargetable.wrap(ptr) as any;\r\n    }\r\n    static fromArr<\r\n        PTR extends Pointer | Pointer[], // <DPointerTargetable, 1, 'N', LPointerTargetable>,\r\n        // DDD extends (PTR extends Pointer<infer D> ? D : 'undefined_D'),\r\n        LOW extends (PTR extends Pointer<any, infer LO> ? LO : 'undefined_upp'),\r\n        UPP extends (PTR extends Pointer<any, number, infer UP> ? UP : 'undefined_low'),\r\n        DDD extends (PTR extends Pointer<any, number, any, infer LL> ? LL : 'undefined_L'),\r\n\r\n        LOWARR extends (PTR extends Pointer<any, infer LO>[] ? LO : 'undefined_uppARR'),\r\n        UPPARR extends (PTR extends Pointer<any, number, infer UP>[] ? 'UP_is_N' : 'undefined_lowARR'),\r\n        DDDARR extends (PTR extends Pointer<any, any, any, infer LL>[] ? LL : 'undefined_LARR'),\r\n\r\n        DX extends DPointerTargetable,\r\n\r\n        RETPTR = UPPARR extends 'UP_is_N' ?\r\n        (DDDARR[]) : // 0...N\r\n        (UPP extends 1 ? (LOW extends 0 ? DDD | null : DDD) : // 0...1 && 1...1\r\n            (LOW extends 1 ? DDD : undefined)  //1...1\r\n        ),\r\n\r\n        // DX = LX extends LEnumerator ? DEnumerator : (LX extends LAttribute ? DAttribute : (LX extends LReference ? DReference : (LX extends LDataType ? DDataType : (LX extends LClass ? DClass : (LX extends LStructuralFeature ? DStructuralFeature : (LX extends LParameter ? DParameter : (LX extends LOperation ? DOperation : (LX extends LModel ? DModel : (LX extends LValue ? DValue : (LX extends LObject ? DObject : (LX extends LEnumLiteral ? DEnumLiteral : (LX extends LPackage ? DPackage : (LX extends LClassifier ? DClassifier : (LX extends LTypedElement ? DTypedElement : (LX extends LNamedElement ? DNamedElement : (LX extends LAnnotation ? DAnnotation : ('ERROR'))))))))))))))))),\r\n        LX = DX extends DEnumerator ? LEnumerator : (DX extends DAttribute ? LAttribute : (DX extends DReference ? LReference : (DX extends DRefEdge ? LRefEdge : (DX extends DExtEdge ? LExtEdge : (DX extends DDataType ? LDataType : (DX extends DClass ? LClass : (DX extends DStructuralFeature ? LStructuralFeature : (DX extends DParameter ? LParameter : (DX extends DOperation ? LOperation : (DX extends DEdge ? LEdge : (DX extends DEdgePoint ? LEdgePoint : (DX extends DGraphVertex ? LGraphVertex : (DX extends DModel ? LModel : (DX extends DValue ? LValue : (DX extends DObject ? LObject : (DX extends DEnumLiteral ? LEnumLiteral : (DX extends DPackage ? LPackage : (DX extends DClassifier ? LClassifier : (DX extends DTypedElement ? LTypedElement : (DX extends DVertex ? LVertex : (DX extends DVoidEdge ? LVoidEdge : (DX extends DVoidVertex ? LVoidVertex : (DX extends DGraph ? LGraph : (DX extends DNamedElement ? LNamedElement : (DX extends DAnnotation ? LAnnotation : (DX extends DGraphElement ? LGraphElement : (DX extends DMap ? LMap : (DX extends DModelElement ? LModelElement : (DX extends DUser ? LUser : (DX extends DPointerTargetable ? LPointerTargetable : (ERROR))))))))))))))))))))))))))))))),\r\n        RET = LX extends 'ERROR' ? RETPTR : (RETPTR extends LX ? RETPTR : LX),\r\n        INFERRED = { ret: RET, RETPTR: RETPTR, upp: UPP, low: LOW, ddd: DDD, dddARR: DDDARR, lowARR: LOWARR, uppARR: UPPARR, LX: LX, DX: DX }>(ptr: PTR[] | DX[])\r\n        : RET[] {\r\n        return LPointerTargetable.from(ptr as any);\r\n    }\r\n\r\n    static from<// LOW extends number, UPP extends number | 'N',\r\n        PTR extends Pointer<DPointerTargetable, 0 | 1, 1 | 'N', LPointerTargetable> | Pointer[], // <DPointerTargetable, 1, 'N', LPointerTargetable>,\r\n        // DDD extends (PTR extends Pointer<infer D> ? D : 'undefined_D'),\r\n        LOW extends (PTR extends Pointer<any, infer LO> ? LO : 'undefined_upp'),\r\n        UPP extends (PTR extends Pointer<any, number, infer UP> ? UP : 'undefined_low'),\r\n        DDD extends (PTR extends Pointer<any, number, any, infer LL> ? LL : 'undefined_L'),\r\n\r\n        LOWARR extends (PTR extends Pointer<any, infer LO>[] ? LO : 'undefined_uppARR'),\r\n        UPPARR extends (PTR extends Pointer<any, number, infer UP>[] ? 'UP_is_N' : 'undefined_lowARR'),\r\n        DDDARR extends (PTR extends Pointer<any, any, any, infer LL>[] ? LL : 'undefined_LARR'),\r\n\r\n        DX extends DPointerTargetable,\r\n\r\n        RETPTR = UPPARR extends 'UP_is_N' ?\r\n        (DDDARR[]) : // 0...N\r\n        (UPP extends 1 ? (LOW extends 0 ? DDD | null : DDD) : // 0...1 && 1...1\r\n            (LOW extends 1 ? DDD : undefined)  //1...1\r\n        ),\r\n\r\n\r\n        // DX = LX extends LEnumerator ? DEnumerator : (LX extends LAttribute ? DAttribute : (LX extends LReference ? DReference : (LX extends LDataType ? DDataType : (LX extends LClass ? DClass : (LX extends LStructuralFeature ? DStructuralFeature : (LX extends LParameter ? DParameter : (LX extends LOperation ? DOperation : (LX extends LModel ? DModel : (LX extends LValue ? DValue : (LX extends LObject ? DObject : (LX extends LEnumLiteral ? DEnumLiteral : (LX extends LPackage ? DPackage : (LX extends LClassifier ? DClassifier : (LX extends LTypedElement ? DTypedElement : (LX extends LNamedElement ? DNamedElement : (LX extends LAnnotation ? DAnnotation : ('ERROR'))))))))))))))))),\r\n        LX = DX extends DEnumerator ? LEnumerator : (DX extends DAttribute ? LAttribute : (DX extends DReference ? LReference : (DX extends DRefEdge ? LRefEdge : (DX extends DExtEdge ? LExtEdge : (DX extends DDataType ? LDataType : (DX extends DClass ? LClass : (DX extends DStructuralFeature ? LStructuralFeature : (DX extends DParameter ? LParameter : (DX extends DOperation ? LOperation : (DX extends DEdge ? LEdge : (DX extends DEdgePoint ? LEdgePoint : (DX extends DGraphVertex ? LGraphVertex : (DX extends DModel ? LModel : (DX extends DValue ? LValue : (DX extends DObject ? LObject : (DX extends DEnumLiteral ? LEnumLiteral : (DX extends DPackage ? LPackage : (DX extends DClassifier ? LClassifier : (DX extends DTypedElement ? LTypedElement : (DX extends DVertex ? LVertex : (DX extends DVoidEdge ? LVoidEdge : (DX extends DVoidVertex ? LVoidVertex : (DX extends DGraph ? LGraph : (DX extends DNamedElement ? LNamedElement : (DX extends DAnnotation ? LAnnotation : (DX extends DGraphElement ? LGraphElement : (DX extends DMap ? LMap : (DX extends DModelElement ? LModelElement : (DX extends DUser ? LUser : (DX extends DPointerTargetable ? LPointerTargetable : (ERROR))))))))))))))))))))))))))))))),\r\n        RET = LX extends 'ERROR' ? RETPTR : (RETPTR extends LX ? RETPTR : LX),\r\n        INFERRED = { ret: RET, RETPTR: RETPTR, upp: UPP, low: LOW, ddd: DDD, dddARR: DDDARR, lowARR: LOWARR, uppARR: UPPARR, LX: LX, DX: DX }>(ptr: PTR | DX, s?: IStore)\r\n        : RET {\r\n        // return null as any;\r\n        if (Array.isArray(ptr)) return LPointerTargetable.wrapAll(ptr) as any;\r\n        return LPointerTargetable.wrap(ptr as any) as any;\r\n    }\r\n\r\n    // static from0(a: any, ...aa: any): any { return null; }\r\n}\r\n/*\r\nlet pttr: Pointer<DClassifier, 0, 1, LClassifier> = null as any;\r\nlet ptrany: Pointer<DClassifier, 0|1, 1|'N'>[] = null as any;\r\nlet ptrarr: Pointer<DClassifier>[] = null as any;\r\nlet ptrarr2: Pointer<DClassifier, 1, 'N'> = null as any;\r\nlet d: DClassifier = null as any;\r\nlet darr: DClassifier[] = null as any;\r\n\r\ntype VoidPtr = null | undefined | '';\r\nfunction dfrom<\r\n    PARAM extends orArr<AnyPointer | VoidPtr>,//orArr<WPointerTargetable | LPointerTargetable | DPointerTargetable | AnyPointer>,\r\n\r\n\r\n    DDD extends (PARAM extends Pointer<infer DD> ? DD : 'undefined_D'),\r\n    LOW extends (PARAM extends Pointer<any, infer LO> ? LO : 'undefined_low'),\r\n    LOW0 extends (PARAM extends Pointer<any, 0, any, any> ? 0 : never),\r\n    LOW1 extends (PARAM extends Pointer<any, 1, any, any> ? 1 : never),\r\n    LOW2 extends (VoidPtr extends PARAM ? 0 | 'first' : (PARAM extends VoidPtr ? 0 | 1 | 'second': 1|'third')),\r\n    UPP extends (PARAM extends Pointer<any, number, infer UP> ? UP : 'undefined_upp'),\r\n    LLL extends (PARAM extends Pointer<any, number, any, infer LL> ? LL : 'undefined_L'),\r\n\r\n\r\n\r\n    ISVOID extends PARAM extends VoidPtr  ? 'isvoid' : never,\r\n    ISARR extends PARAM extends [] ? true : false,\r\n    ISPTR extends (PARAM extends AnyPointer | VoidPtr ? 'ptr' : never),\r\n    ISPTRARR extends (PARAM extends (AnyPointer | VoidPtr)[] | Pointer<DPointerTargetable, 1|0, 'N', LPointerTargetable> ? 'ptr_arr' : never),\r\n    ISD extends (PARAM extends DPointerTargetable ? 'd' : never),\r\n    ISDARR extends (PARAM extends DPointerTargetable[] ? 'd_arr' : never),\r\n    ISL extends (PARAM extends LPointerTargetable ? 'l' : never),\r\n    ISLARR extends (PARAM extends LPointerTargetable[] ? 'l_arr' : never),\r\n    ISW extends (PARAM extends WPointerTargetable ? 'w' : never),\r\n    ISWARR extends (PARAM extends WPointerTargetable[] ? 'w_arr' : never),\r\n    // INFER = {LOW:LOW, UPP:UPP, DDD:DDD, LLL:LLL, LOW2:LOW2},\r\n    INFER = { LOW2:LOW2},\r\n    RET = ISVOID | ISPTR | ISPTRARR | ISD | ISDARR | ISL | ISLARR | ISW | ISWARR | INFER\r\n    >\r\n(ptr: PARAM): RET { return null as any; }\r\nlet Lptr = dfrom(pttr as Pointer<DClassifier, 0, 1, LClassifier> );\r\nlet Lptrany = dfrom(ptrany);\r\nlet Lptrarr = dfrom(ptrarr);\r\nlet Lptrarr2 = dfrom(ptrarr2);\r\nlet Ld = dfrom(d);\r\nlet Ldarr = dfrom(darr);*/\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n@RuntimeAccessible\r\nexport class WPointerTargetable extends DPointerTargetable {\r\n    id!: never;\r\n    _storePath!: never;\r\n    _subMaps!: never;\r\n    pointedBy!: never;\r\n    // todo: WfromD, WfromL, WfromPointer, Wfrom\r\n\r\n    static fromD<DX extends DPointerTargetable, WX extends DtoW<DX>>(data: DX): WX { return LPointerTargetable.fromD(data) as any; }\r\n}\r\nDPointerTargetable.subclasses.push(LPointerTargetable);\r\nDPointerTargetable.subclasses.push(WPointerTargetable);\r\n\r\nfunction fffff<DX, LX = DX extends DRefEdge ? LRefEdge : 'not'>(t: DX): LX { return null as any; }\r\nlet a: DGraphElement = null as any;\r\nlet bbb = LPointerTargetable.from(a);\r\nlet bb2 = fffff(a);\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n@Leaf\r\n@RuntimeAccessible\r\nexport class DUser extends DPointerTargetable {\r\n    static current: DocString<Pointer<DUser, 1, 1>> = \"Pointer\"; // todo\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    username: string = '';\r\n    email: string = '';\r\n    token: string = ''\r\n    cursorPositionX: number = 0;\r\n    cursorPositionY: number = 0;\r\n    // public static structure: typeof DPointerTargetable;\r\n    // public static singleton: LPointerTargetable;\r\n    id!: Pointer<DUser, 1, 1, LUser>;\r\n    __isUser: true = true; // necessary to trick duck typing to think this is NOT the superclass of anything that extends PointerTargetable.\r\n    public static new(id?: DUser[\"id\"], triggerActions: boolean = true): DUser {\r\n        return new Constructors(new DUser('dwc'), undefined, false).DPointerTargetable().DUser(id).end();\r\n    }\r\n}\r\n\r\n@RuntimeAccessible\r\nexport class LUser extends LPointerTargetable { // MixOnlyFuncs(DUser, LPointerTargetable)\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    username!: string;\r\n    email!: string;\r\n    token!: string;\r\n    // public static structure: typeof DPointerTargetable;\r\n    // public static singleton: LPointerTargetable;\r\n    public __raw!: DUser;\r\n    id!: Pointer<DUser, 1, 1, LUser>;\r\n    __isUser!: true;\r\n    cursorPosition!: IPoint; //todo\r\n}\r\nDPointerTargetable.subclasses.push(DUser);\r\nLPointerTargetable.subclasses.push(LUser);\r\n\r\nexport type WUser = getWParams<LUser, DUser>;\r\n\r\n@RuntimeAccessible\r\nexport class MyError extends Error {\r\n    constructor(message?: string, ...otherMsg: any[]) {\r\n        // 'Error' breaks prototype chain here\r\n        super(message);\r\n        const proto = (this as any).__proto__;\r\n\r\n        console.error(proto.constructor.name, message, ...otherMsg);\r\n        // restore prototype chain\r\n        const actualProto = new.target.prototype;\r\n\r\n        if (Object.setPrototypeOf) { Object.setPrototypeOf(this, actualProto); }\r\n        else { (this as any).__proto__ = actualProto; }\r\n        (this as any).className = this.constructor.name;\r\n    }\r\n}\r\n\r\n// @RuntimeAccessible\r\nexport class JsType {\r\n    public static all: JsType[] = [];\r\n    public static object: JsType = new JsType(\"object\", JsType.isObject, false);\r\n    public static function: JsType = new JsType(\"function\", JsType.isFunction, false);\r\n    public static array: JsType = new JsType(\"array\", JsType.isArray, false);\r\n    public static date: JsType = new JsType(\"Date\", JsType.isDate, false);\r\n\r\n    public static lambdaFunction: JsType = new JsType(\"lambda-function\", JsType.isLambdaFunction, true);\r\n    public static nonLambdaFunction: JsType = new JsType(\"non-lambda-function\", JsType.isNonLambdaFunction, true);\r\n    public static symbol: JsType = new JsType(\"symbol\", JsType.isSymbol, true);\r\n    public static undefined: JsType = new JsType(\"undefined\", JsType.isUndefined, true);\r\n    public static null: JsType = new JsType(\"null\", JsType.isNull, true);\r\n    public static boolean: JsType = new JsType(\"boolean\", JsType.isBoolean, true);\r\n    public static number: JsType = new JsType(\"number\", JsType.isNumber, true);\r\n    public static bigint: JsType = new JsType(\"bigint\", JsType.isBigint, true);\r\n    public static string: JsType = new JsType(\"string\", JsType.isString, true);\r\n\r\n    private constructor(public printableTypeName: string, public check: (data: any) => boolean, public isExclusiveType: boolean) {\r\n        JsType.all.push(this);\r\n    }\r\n    public toString(): string { return this.printableTypeName; }\r\n    /*\r\n    * example: isObject but not Date, not function...\r\n    * */\r\n    public static isOnlyType(data: any, type: JsType): boolean { return !JsType.getTypes(data, type).length; }\r\n    public static isAnyOfTypes(data: any, ...acceptables: JsType[]): boolean { return !!windoww.Uarr.arrayIntersection(JsType.getTypes(data), acceptables).length; }\r\n    public static getTypes(data: any, stopIfTypeIsNot?: JsType): JsType[] {\r\n        const ret: JsType[] = [];\r\n        for (const type of JsType.all) {\r\n            if (type.check(data)) {\r\n                ret.push(data);\r\n                if (stopIfTypeIsNot !== type) { return []; }\r\n                if (type.isExclusiveType) return ret;\r\n            }\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    /// is...\r\n    public static isObject(data: GObject | any): boolean { return typeof data === \"object\"; }\r\n    public static isFunction(data: Function | any): boolean { return typeof data === \"function\"; }\r\n    public static isLambdaFunction(data: Function | any): boolean {\r\n        if (!JsType.isFunction(data)) return false;\r\n        return windoww.U.getFunctionSignatureFromComments(data).isLambda;\r\n    }\r\n    public static isNonLambdaFunction(data: Function | any): boolean { return JsType.isFunction(data) && !JsType.isNonLambdaFunction(data); }\r\n    public static isArray(data: Array<any> | any): boolean { return Array.isArray(data); }\r\n    public static isSymbol(data: symbol | any): boolean { return typeof data === \"symbol\"; }\r\n    public static isBoolean(data: symbol | any): boolean { return !!data === data; }\r\n    public static isNumber(data: number | any): boolean { return typeof data === \"number\"; }\r\n    public static isBigint(data: bigint | any): boolean { return typeof data === \"bigint\"; }\r\n    public static isString(data: string | any): boolean { return typeof data === \"string\"; }\r\n    public static isNull(data: null | any): boolean { return data === null; }\r\n    public static isUndefined(data: undefined | any): boolean { return data === undefined; }\r\n    public static isDate(data: Date | any): boolean { return data instanceof Date; }\r\n\r\n    /// as...\r\n    public static asObject<T>(data: GObject | any, fallbackReturn: T): T | GObject { return JsType.isObject(data) ? data : fallbackReturn; }\r\n    public static asFunction<T>(data: Function | any, fallbackReturn: T): T | Function { return JsType.isFunction(data) ? data : fallbackReturn; }\r\n    public static asLambdaFunction<T>(data: Function | any, fallbackReturn: T): T | Function { return JsType.isLambdaFunction(data) ? data : fallbackReturn; }\r\n    public static asNonLambdaFunction<T>(data: Function | any, fallbackReturn: T): T | Function { return JsType.isNonLambdaFunction(data) ? data : fallbackReturn; }\r\n    public static asArray<T, A>(data: Array<A> | any, fallbackReturn: T): T | Array<A> { return JsType.isArray(data) ? data : fallbackReturn; }\r\n    public static asSymbol<T>(data: symbol | any, fallbackReturn: T): T | symbol { return JsType.isSymbol(data) ? data : fallbackReturn; }\r\n    public static asBoolean<T>(data: boolean | any, fallbackReturn: T): T | boolean { return JsType.isBoolean(data) ? data : fallbackReturn; }\r\n    public static asNumber<T>(data: number | any, fallbackReturn: T): T | number { return JsType.isNumber(data) ? data : fallbackReturn; }\r\n    public static asBigint<T>(data: bigint | any, fallbackReturn: T): T | bigint { return JsType.isBigint(data) ? data : fallbackReturn; }\r\n    public static asString<T>(data: string | any, fallbackReturn: T): T | string { return JsType.isString(data) ? data : fallbackReturn; }\r\n    public static asNull<T>(data: null | any, fallbackReturn: T): T | null { return JsType.isNull(data) ? data : fallbackReturn; }\r\n    public static asUndefined<T>(data: undefined | any, fallbackReturn: T): T | undefined { return JsType.isUndefined(data) ? data : fallbackReturn; }\r\n    public static asDate<T>(data: Date | any, fallbackReturn: T): T | Date { return JsType.isDate(data) ? data : fallbackReturn; }\r\n    public static isPrimitive(data: any) { return !JsType.isAnyOfTypes(data, JsType.object, JsType.function, JsType.array); }\r\n}\r\n\r\n\r\nfunction invalidSuperClassError(/*callee: Class,*/ scname: string, superclass: Class): (() => never) {\r\n    return () => { windoww.Log.exDevv('parent super class \"' + scname + '\" is not implementing init_constructor', { scname, superclass, }); throw new Error(); }\r\n}\r\n// @ts-ignore\r\nfunction MixinFakeConstructor() { this.isMixinFakeConstructor = true; }\r\nexport function MixOnlyFuncs<A1 extends any[], I1, S1, A2 extends any[], I2, S2>(c1: Class<A1, I1, S1> & typeof RuntimeAccessibleClass, c2: Class<A2, I2, S2> & typeof RuntimeAccessibleClass):\r\n    CClass<Longest<A1, A2>, I1 & I2\r\n        & {\r\n            // superclass: Dictionary<string, (/*thiss: I1 & I2,* / ...superConstructorParams:ConstructorParameters<Class<A1, I1, S1>> | ConstructorParameters<Class<A2, I2, S2>>) => void>,\r\n            superclass1: Dictionary<DocString<'constructor name to make sure the user knows what superclass constructor is calling'>, (...superConstructor1Params: ConstructorParameters<Class<A1, I1, S1>>) => void>,\r\n            superclass2: Dictionary<DocString<'constructor name to make sure the user knows what superclass constructor is calling'>, (...superConstructor2Params: ConstructorParameters<Class<A2, I2, S2>>) => void>,\r\n            // initt: Class<A1, I1, S1>\r\n        } & AbstractMixedClass\r\n        // , Omit<Omit<Omit<S1 & S2, 'init_constructor'>, 'logic'>, 'maxID'> & typeof AbstractMixedClass> {\r\n        , S1 & S2 & GObject & typeof AbstractMixedClass> {\r\n    // strategia: passo dei finti valori che copiano i prototipi delle classi sovrascrivendo i costruttori per evitare che chiami i costruttori delle superclassi\r\n    // ma che comunque erediti campi e funzioni\r\n    // @ts-ignore\r\n    let c1noconstructor: any = MixinFakeConstructor;\r\n    let c2noconstructor: any = MixinFakeConstructor;\r\n    c1noconstructor.prototype = c1.prototype;\r\n    c2noconstructor.prototype = c2.prototype;\r\n\r\n    let disableconstructor = false;\r\n    if (!disableconstructor) {\r\n        c1noconstructor = c1;\r\n        c2noconstructor = c2;\r\n    }\r\n\r\n\r\n    let ret = Mixin(c1noconstructor, c2noconstructor);\r\n    let c1name = c1.name === 'classnameFixedConstructorDoNotRenameWithoutSearchStrings' ? c1.prototype.className : c1.name;\r\n    let c2name = c2.name === 'classnameFixedConstructorDoNotRenameWithoutSearchStrings' ? c2.prototype.className : c2.name;\r\n    //ret.prototype['superclass'] = {};\r\n    // ret.prototype['superclass'][c1name] = c1.prototype.init_constructor || invalidSuperClassError(c1name, c1);\r\n    // ret.prototype['superclass'][c2name] = c2.init_constructor || invalidSuperClassError(c2name, c2);\r\n    ret.prototype['superclass1'] = {};\r\n    ret.prototype['superclass2'] = {};\r\n    ret.prototype['superclass1'][c1name] = c1.init_constructor || invalidSuperClassError(c1name, c1);\r\n    ret.prototype['superclass2'][c2name] = c2.init_constructor || invalidSuperClassError(c2name, c2);\r\n    return ret;\r\n}\r\nconsole.warn('ts loaded classes');\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n//*********************************************************************************************\r\n//*********************************************************************************************\r\n///////                              type juggling starts here                          ///////\r\n//*********************************************************************************************\r\n//*********************************************************************************************\r\n\r\n// export type NotAString<T extends any = 'uselessval'> = Omit<string, 'bold'> & {big: T};\r\n// export type NotAString<T extends any = 'uselessval'> = Omit<string, 'bold'>;\r\n// export type NotAString<T extends any = 'uselessval', T2 extends any = any, T3 extends any = any, T4 extends any = any> = string & Omit<string, 'bold'> & {bold: ()=>string};\r\nexport type NotAString<T extends any = 'uselessval', T2 extends any = any, T3 extends any = any, T4 extends any = any> = string & Omit<string, 'bold'> & { bolda?: T };\r\n// export type NotAString<T> = string;\r\n// type Pointer<T> = NotAString<T>;\r\nexport type Pointer<T extends DPointerTargetable = DPointerTargetable, lowerbound extends number = 1, upperbound extends number | 'N' = 1,\r\n    RET extends LPointerTargetable = DtoL<T>> =\r\n    upperbound extends 'N' ? NotAString<T, lowerbound, upperbound, RET>[] : (\r\n        upperbound extends 0 ? never : (\r\n            lowerbound extends 0 ? (NotAString<T, lowerbound, upperbound, RET> | null) : NotAString<T, upperbound, lowerbound, RET>));\r\n\r\n\r\nexport type PtrString = any; // to convert Pointers to strings more explicitly then using as any\r\n// let ptr: Pointer<Object> = null as any;\r\n\r\nclass D extends DPointerTargetable {\r\n    parent!: Pointer<D>;\r\n    dattrib!: boolean;\r\n    juststring!: string;\r\n    nattrib!: number;\r\n    ddattrib!: Date\r\n}\r\n\r\nclass D2 extends D {\r\n    d2!: string;\r\n}\r\nclass D3 extends D {\r\n    d3!: string;\r\n}\r\n\r\n\r\n\r\ntype OverrideTypes<M, N> = { [P in keyof M]: P extends keyof N ? N[P] : M[P] }; // usage:  OverrideTypes<A, { x: number }>;\r\n\r\ninterface LFix {\r\n    parent: L;\r\n}\r\ninterface L { // no instances ever\r\n    parent: L;\r\n    lattrib: boolean;\r\n}\r\ninterface L2 extends L { // no instances ever\r\n    l2: string;\r\n}\r\ninterface L3 extends L { // no instances ever\r\n    l3: string;\r\n}\r\n\r\nclass P { // singleton\r\n    get_parent() { }\r\n    set_parent() { }\r\n}\r\nclass P2 extends P { // singleton\r\n    get_d2() { }\r\n}\r\nclass P3 extends P { // singleton\r\n    get_d3() { }\r\n}\r\n\r\ntype ERROR = \"_TYPE_ERROR_\";\r\n// RegExp extends Animal ? number : string\r\n\r\n\r\nfunction buildWrapSignature(maxdepth = 100) {\r\n    let arr = windoww[\"DPointerTargetable\"].subclasses;\r\n    /*\r\n    let dict0 = arr.reduce((a, v) => ({ ...a, [v.name]: v}), {});\r\n    let dict = {}\r\n    for (let name in dict0) { let n = name.substring(1); dict[n] = {\"D\":dict0[\"D\"+n], \"L\":dict0[\"L\"+n]}; dict[\"D\"+n] = dict0[\"L\"+n]; dict[\"L\"+n] = dict0[\"D\"+n]; }\r\n    console.log(\"dict\", dict);\r\n    console.table(dict);\r\n    */\r\n    function onlyUnique(value: any, index: number, self: any) { return self.indexOf(value) === index; }\r\n\r\n    let dep = arr; // .map( (me) => { return {\"name\": me.name, \"me\": me, \"Derror\": (dict[me.name] || me).name, \"Lerror\": (dict[me.name] || me).name, \"subclasses\": [...me.subclasses]}});\r\n    let depsorted = [];\r\n\r\n    let byLevels = [];\r\n    let loopdetecter: any[] = [arr];\r\n    while (dep.length && maxdepth--) {\r\n        let namelist = dep.map((e: any) => e.name).filter(onlyUnique);\r\n        depsorted.push(...namelist);\r\n        byLevels.push([...namelist]);\r\n        let olddep = dep;\r\n        dep = dep.flatMap((d: any) => d.subclasses).filter(onlyUnique);\r\n        for (let d of dep) {\r\n            windoww.loopdetecter = loopdetecter;\r\n            windoww.dep = dep;\r\n            windoww.olddep = olddep;\r\n            windoww.byLevels = byLevels;\r\n            windoww.d = d;\r\n            if (loopdetecter.includes(d.subclasses)) throw new Error(\"class is not redefining subclasses static array: \" + d.name);\r\n            loopdetecter.push(d.subclasses);\r\n        }\r\n    }\r\n    console.log(\"byLevels\");\r\n    console.table(byLevels);\r\n\r\n    console.log(\"depsorted\", depsorted);\r\n\r\n    // console.log(\"map\");\r\n    // console.table(depsorted.map(dn => {let d = window[dn]; return !d ? \"\" :{name:d.name, scount: d.subclasses.length, subclasses:d.subclasses}}));\r\n\r\n\r\n    let goalSignature = \"function wrap<DX extends D, LX = DX extends D2 ? L2: (DX extends D3 ? L3: (DX extends D ? L : ERROR))>(data: DX): LX {\";\r\n    let lparam = \"ERROR\";\r\n    let epsorted = depsorted.map(e => e.substring(1)).filter(onlyUnique);\r\n    console.table(epsorted)\r\n    for (let e of epsorted) {\r\n        let D = \"D\" + e;\r\n        let L = \"L\" + e;\r\n        lparam = \"DX extends \" + D + \" ? \" + L + \" : (\" + (lparam) + \")\";\r\n    }\r\n    let signature = \"function wrap<DX extends DPointerTargetable, LX = \" + lparam + \">(data: DX): LX {\";\r\n    return signature;\r\n}\r\nwindoww.buildWrapSignature = buildWrapSignature;\r\n// function wrap<DX extends D, LX = DX extends D2 ? L2: (DX extends D3 ? L3: (DX extends D ? L : ERROR))>(data: DX): LX {\r\n\r\n/*\r\n* NO    L -> D    /// l.__raw\r\n* NO    L -> Ptr  /// l.id\r\n*\r\n* NO    D -> Ptr   // d.id\r\n* YES   D -> L     // wrap\r\n*\r\n* NO    Ptr -> D\r\n* NO    Ptr -> L\r\n*\r\n*\r\n*\r\n*\r\n* DpointerTargetable.from( L or pointer )\r\n* LpointerTargetable.from( D or pointer )\r\n*\r\n* MyProxyHandler.wrap = LpointerTargetable.from;\r\n*\r\n* DpointerTargetable.toPointer( d );\r\n*\r\n* */\r\n\r\n\r\n\r\ntype subtract<P, C> = { [F in keyof P]: keyof C extends undefined ? undefined : P[F] };\r\ntype subtractDL = subtract<D, L>;\r\ntype Exclude3<T, U> = T & { [T in keyof U]: never };\r\ntype Override<A, B> = Omit<A, keyof B> & B; //////////////////////////////////////////// best solution so far\r\n\r\ntype Exclude2<Type, field> = {\r\n    [Property in keyof Type as Exclude<Property, keyof field>]: Type[Property]      /////////////////////////equally best solution\r\n};\r\n\r\n\r\ntype OnlyKeysOfTypeTmp<T, IncludeType> = ({ [P in keyof T]: T[P] extends IncludeType ? P : never })[keyof T];\r\ntype OnlyKeysOfType<T, IncludeType> = Pick<T, OnlyKeysOfTypeTmp<T, IncludeType>>;\r\ntype RemoveKeysOfType<T, ExcludeType> = Exclude2<T, OnlyKeysOfType<T, ExcludeType>>;\r\n\r\n// todo: can't automatically convert D to L (generating the type instead of manual defining L) rules are: LClass <--- Pointer<LClass>, LClass[] <-- Pointer<LClass, 0, 'N'>, subobject = ? should not be there\r\n\r\n/**\r\n i have a documentation type that is actually a string, but it\\'s have a different purpose from the others, and i made a type to keep documentally separated.\r\n let's say it's\r\n type StringOf<P> = string; // regardless of P\r\n\r\n and i use it to define objects\r\n\r\n class C {\r\n   str: StringOf<Date>;\r\n   str2: StringOf<number>;\r\n   purestring: string;\r\n   num: number\r\n }\r\n now i want to crete a derivate type that excludes all properties of type StringOf from C\r\n\r\n\r\n\r\n type OnlyKeysOfTypeTmp<T, IncludeType> = ({[P in keyof T]: T[P] extends IncludeType ? P : never })[keyof T];\r\n type OnlyKeysOfType<T, IncludeType> = Pick<T, OnlyKeysOfTypeTmp<T, IncludeType>>;\r\n type RemoveKeysOfType<T, ExcludeType> = Exclude2<T, OnlyKeysOfType<T, string>>;\r\n\r\n type D = RemoveKeysOfType<C, StringOf<any>>\r\n due to duck typing, this removes all StringOf attributes, but also \"purestring\" attribute.\r\n how can i remove only StringOf attributes?\r\n\r\n\r\n */\r\n\r\n\r\n\r\nexport type getWParams<L extends LPointerTargetable, D extends Object> = {\r\n    // [Property in keyof ValidObj<L>]: L[Property] extends never ? never : L[Property]\r\n    [Property in keyof L]:/*\r\n    Property extends \"opposite\" ? LReference | DReference | Pointer<DReference> :\r\n    Property extends \"parent\" ? LModelElement | DModelElement | Pointer<DModelElement> :\r\n    Property extends \"annotations\" ? LAnnotation | DAnnotation | Pointer<DAnnotation> :*/\r\n    (Property extends string ? (\r\n        Property extends \"id\" ? 'id is read-only' :\r\n        //@ts-ignore\r\n        (L[`set_${Property}`] extends (a: any, b: any, ...b: any) => any ? // at least 2 params: 1 for val and 1 for Context\r\n            // if a set_ first parameter is Context it means the set_ is ill-defined, need to change actual method signature.\r\n            //@ts-ignore\r\n            Parameters<L[`set_${Property}`]>[0] // if set_X function is defined, get first param\r\n            //@ts-ignore\r\n            : never ///D[Property] | `todo: should define set_${Property}` // default type if it's not assigned = type in the D version\r\n        )) : never)\r\n} // & L\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}