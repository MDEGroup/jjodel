{"ast":null,"code":"var _dec, _class;\n// npm i react-json-view\nimport React from \"react\";\nimport withReactContent from \"sweetalert2-react-content\";\nimport Swal from \"sweetalert2\";\nimport { U, Log, windoww, RuntimeAccessible, EdgeComponent } from \"../joiner\";\n\n// U-functions that require jsx\nexport let UX = (_dec = RuntimeAccessible('UX'), _dec(_class = class UX {\n  static recursiveMap(children, fn) {\n    let depthIndices = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n    // NB: depthIndices is correct but if there is an expression children evaluated to false like {false && <jsx>},\n    // it counts as children iterated regardless. so html indices might be apparently off, but like this is even safer as indices won't change when conditions are changed.\n    const innermap = (child, i1, depthIndices) => {\n      if (! /*#__PURE__*/React.isValidElement(child)) {\n        return child;\n      }\n      if (child.props.children) {\n        // let deeperDepthIndices = [...depthIndices, i1];  // depthIndices; //\n        // should probably change deeperDepthIndices in [...deeperDepthIndices, i] in next uncommented line.\n        // Giordano: add ignore for webpack\n        //@ts-ignore\n        child = /*#__PURE__*/React.cloneElement(child, {\n          children: UX.recursiveMap(child.props.children, (e, i2, ii) => fn(e, i2, ii), depthIndices)\n        });\n      }\n      return fn(child, i1, depthIndices);\n    };\n    if (!Array.isArray(children)) return innermap(children, 0, [...depthIndices, 0]);\n    return React.Children.map(children, (c, i3) => innermap(c, i3, [...depthIndices, i3]));\n  }\n  static injectProp(parentComponent, e, gvidmap_useless, parentnodeid, index, indices, injectOffset) {\n    var _WrappedComponent, _parentComponent$prop, _parentComponent$prop2, _parentComponent$prop3, _parentComponent$prop4, _re$props$data, _re$props$initialSize, _re$props$startingSiz, _WrappedComponent2;\n    let re = UX.ReactNodeAsElement(e);\n    injectOffset && console.log(\"inject offset props 1:\", {\n      e,\n      re,\n      injectOffset\n    });\n    if (!re) return e;\n    // @ts-ignore this\n    // const parentComponent = this;\n    const type = ((_WrappedComponent = re.type.WrappedComponent) === null || _WrappedComponent === void 0 ? void 0 : _WrappedComponent.name) || re.type;\n    let injectProps = {};\n    if (injectOffset) {\n      var _re$props;\n      const style = {\n        ...(((_re$props = re.props) === null || _re$props === void 0 ? void 0 : _re$props.style) || {})\n      };\n      let offset = injectOffset.offset;\n      let scale = injectOffset.zoom;\n      style.position = \"absolute\";\n      style.left = offset.x;\n      style.top = offset.y;\n      style.transform = \"scale(\" + scale.x + \",\" + scale.y + \")\";\n      injectProps = {\n        style\n      };\n      let oldre = re;\n      console.log(\"inject offset props 2:\", {\n        oldre,\n        re,\n        injectProps\n      });\n      re = /*#__PURE__*/React.cloneElement(re, injectProps);\n    }\n    // const windoww = window as any;\n    // console.log('ux.injectingProp pre ', {type: (re.type as any).WrappedComponent?.name || re.type}, {mycomponents: windoww.mycomponents, re, props:re.props});\n    // add \"view\" (view id) prop as default to sub-elements of any depth to inherit the view of the parent unless the user forced another view to apply\n    switch (type) {\n      default:\n        // console.count('ux.injectingProp case default: ' + type);\n        if (indices.length <= 2 && (parentComponent === null || parentComponent === void 0 ? void 0 : (_parentComponent$prop = parentComponent.props) === null || _parentComponent$prop === void 0 ? void 0 : _parentComponent$prop.childStyle)) {\n          // if first non-component child of a GraphElement with a clipPath shape, i assign clip path to it.\n          console.log('injecting to first child (A):', {\n            re,\n            indices,\n            il: indices.length,\n            pc: parentComponent,\n            injectProps,\n            cs: parentComponent.props.childStyle\n          });\n          let istyle = injectProps.style = {\n            ...(injectProps.style || {})\n          };\n          injectProps.style = injectProps.style ? {\n            ...injectProps.style\n          } : {};\n          U.objectMergeInPlace(injectProps.style, parentComponent.props.childStyle);\n        } else return re;\n        break;\n      /*\r\n      case windoww.Components.Input.name:\r\n      case windoww.Components.Textarea.name:\r\n          const objid =  re.props.obj?.id || re.props.obj || parentComponent.props.data.id;\r\n          const ret = React.cloneElement(re, {key: re.props.key || parentComponent.props.view.id + '_' + parentComponent.props.data.id + '_' + re.props.field, obj: objid, obj2: objid});\r\n          //console.log('relement Input set props',\r\n          //    {'re.props.obj.id': re.props.obj?.id, 're.props.obj': re.props.obj, 'thiss.props.data.id': thiss.props.data.id, thiss, re, objid, ret, 'ret.props': ret.props});\r\n          return ret;*/\n      // case windoww.Components.GraphElement.name:\n      case windoww.Components.Input.cname + \"Component\":\n      case windoww.Components.Select.cname + \"Component\":\n      case windoww.Components.TextArea.cname + \"Component\":\n        // todo: can i do a injector that if the user provides a ModelElement list raw <div>{this.children}</div> it wraps them in DefaultNode?\n        const injectProps2 = {};\n        const parentnodeid = (_parentComponent$prop2 = parentComponent.props.node) === null || _parentComponent$prop2 === void 0 ? void 0 : _parentComponent$prop2.id;\n        injectProps2.data = re.props.data || (typeof parentComponent.props.data === \"string\" ? parentComponent.props.data : (_parentComponent$prop3 = parentComponent.props.data) === null || _parentComponent$prop3 === void 0 ? void 0 : _parentComponent$prop3.id);\n        // !IMPORTANT! this key does not remove the responsability of adding keys to <GraphElement>s. this is assigning the key to the first returned element by component A,\n        // but react needs to distinguish component A from other components, and he still doesn't have a key. in fact this is useless as this component can only have 1 child\n        injectProps2.key = re.props.key || parentnodeid + \"^input_\" + index;\n        return /*#__PURE__*/React.cloneElement(re, injectProps2);\n      case windoww.Components.GraphElementComponent.cname:\n      // case windoww.Components.DefaultNode.name:\n      case windoww.Components.DefaultNodeComponent.cname:\n      // case windoww.Components.Graph.name:\n      // case windoww.Components.GraphComponent.cname:\n      case \"Graph\":\n      case \"GraphComponent\":\n      // case windoww.Components.Field.name:\n      // case windoww.Components.FieldComponent.cname:\n      // case windoww.Components.Vertex.name:\n      case EdgeComponent.cname:\n      case windoww.Components.VertexComponent.cname:\n        injectProps.parentViewId = parentComponent.props.view.id || parentComponent.props.view; // re.props.view ||  thiss.props.view\n        injectProps.parentnodeid = (_parentComponent$prop4 = parentComponent.props.node) === null || _parentComponent$prop4 === void 0 ? void 0 : _parentComponent$prop4.id;\n        injectProps.graphid = parentComponent.props.graphid;\n        // const vidmap = GraphElementRaw.graphVertexID_counter;\n        // if (!vidmap[injectProps.graphid]) vidmap[injectProps.graphid] = {};\n        // const gvidmap = vidmap[injectProps.graphid];\n        // const validVertexIdCondition = (id: string): boolean => gvidmap_useless[id];\n        // todo: come butto dei sotto-vertici dentro un vertice contenitore? o dentro un sotto-grafo? senza modificare il jsx ma solo draggando? React-portals?\n        const dataid = (typeof re.props.data === \"string\" ? re.props.data : (_re$props$data = re.props.data) === null || _re$props$data === void 0 ? void 0 : _re$props$data.id) || \"shapeless\";\n        let idbasename;\n        if ((_re$props$initialSize = re.props.initialSize) === null || _re$props$initialSize === void 0 ? void 0 : _re$props$initialSize.id) {\n          var _re$props$initialSize2;\n          idbasename = (_re$props$initialSize2 = re.props.initialSize) === null || _re$props$initialSize2 === void 0 ? void 0 : _re$props$initialSize2.id;\n        } else if (re.props.nodeid) {\n          idbasename = injectProps.parentnodeid + \"^\" + re.props.nodeid;\n        } else switch (type) {\n          default:\n            idbasename = injectProps.parentnodeid + \"^\" + dataid + \"N\";\n            break;\n          case windoww.Components.EdgePoint.cname:\n            idbasename = injectProps.parentnodeid + \"^\" + (dataid || ((_re$props$startingSiz = re.props.startingSize) === null || _re$props$startingSiz === void 0 ? void 0 : _re$props$startingSiz.id) || indices.join(\",\")) + \"EP\";\n            break;\n          case EdgeComponent.cname:\n          case \"Edge\":\n            let edgeProps = re.props;\n            let edgestart_id = edgeProps.start.id || edgeProps.start;\n            let edgeend_id = edgeProps.end.id || edgeProps.end;\n            idbasename = injectProps.parentnodeid + \"^\" + edgestart_id + \"~\" + edgeend_id;\n        }\n        // (injectProps.parentnodeid)+\"^\"+(dataid)+indices.join(\",\");//injectProps.graphid + '^' + dataid;\n        // console.log(\"setting nodeid\", {injectProps, props:re.props, re});\n        // Log.exDev(!injectProps.graphid || !dataid, 'vertex is missing mandatory props.', {graphid: injectProps.graphid, dataid, props: re.props});\n        Log.exDev(!injectProps.graphid, 'vertex is missing mandatory props (graphid).', {\n          graphid: injectProps.graphid,\n          dataid,\n          props: re.props\n        });\n        if (false && indices.length === 2) {\n          var _parentComponent$prop5, _parentComponent$prop6;\n          // if first component child, of a component? like (DefaultNode -> Vertex)?\n          console.log('injecting to first child (B):', {\n            re,\n            pc: parentComponent,\n            injectProps\n          });\n          if (parentComponent === null || parentComponent === void 0 ? void 0 : (_parentComponent$prop5 = parentComponent.props.style) === null || _parentComponent$prop5 === void 0 ? void 0 : _parentComponent$prop5.clipPath) injectProps.style = {\n            ...(injectProps.style || {}),\n            clipPath: (parentComponent === null || parentComponent === void 0 ? void 0 : (_parentComponent$prop6 = parentComponent.props.style) === null || _parentComponent$prop6 === void 0 ? void 0 : _parentComponent$prop6.clipPath) || ''\n          };\n        }\n        injectProps.nodeid = idbasename; // U.increaseEndingNumber(idbasename, false, false, validVertexIdCondition);\n        injectProps.htmlindex = indices[indices.length - 1]; // re.props.node ? re.props.node.htmlindex : indices[indices.length - 1];\n        injectProps.key = re.props.key || injectProps.nodeid;\n        // console.log(\"cloning jsx:\", re, injectProps);\n        Log.ex((injectProps.nodeid === injectProps.graphid || injectProps.nodeid === injectProps.parentnodeid) && type != \"GraphComponent\", \"User manually assigned a invalid node id. please remove or change prop \\\"nodeid\\\"\", {\n          type: ((_WrappedComponent2 = re.type.WrappedComponent) === null || _WrappedComponent2 === void 0 ? void 0 : _WrappedComponent2.cname) || re.type\n        }, {\n          mycomponents: windoww.mycomponents,\n          re,\n          props: re.props\n        });\n    }\n    return /*#__PURE__*/React.cloneElement(re, injectProps);\n  }\n  static ReactNodeAsElement(e) {\n    return e && e.type ? e : null;\n  }\n  static async deleteWithAlarm(lItem) {\n    const MySwal = withReactContent(Swal);\n    const confirm = await MySwal.fire({\n      title: \"Delete \" + lItem.toString() + \"?\",\n      showCancelButton: true,\n      confirmButtonText: \"Yes\",\n      cancelButtonText: \"No\",\n      showLoaderOnConfirm: true\n    });\n    if (confirm.value === true) {\n      lItem.delete();\n    }\n  }\n  static async info(text) {\n    const MySwal = withReactContent(Swal);\n    const confirm = await MySwal.fire({\n      title: text,\n      showCancelButton: false,\n      confirmButtonText: \"Got It\"\n    });\n  }\n}) || _class);","map":{"version":3,"names":["React","withReactContent","Swal","U","Log","windoww","RuntimeAccessible","EdgeComponent","UX","_dec","_class","recursiveMap","children","fn","depthIndices","arguments","length","undefined","innermap","child","i1","isValidElement","props","cloneElement","e","i2","ii","Array","isArray","Children","map","c","i3","injectProp","parentComponent","gvidmap_useless","parentnodeid","index","indices","injectOffset","_WrappedComponent","_parentComponent$prop","_parentComponent$prop2","_parentComponent$prop3","_parentComponent$prop4","_re$props$data","_re$props$initialSize","_re$props$startingSiz","_WrappedComponent2","re","ReactNodeAsElement","console","log","type","WrappedComponent","name","injectProps","_re$props","style","offset","scale","zoom","position","left","x","top","y","transform","oldre","childStyle","il","pc","cs","istyle","objectMergeInPlace","Components","Input","cname","Select","TextArea","injectProps2","node","id","data","key","GraphElementComponent","DefaultNodeComponent","VertexComponent","parentViewId","view","graphid","dataid","idbasename","initialSize","_re$props$initialSize2","nodeid","EdgePoint","startingSize","join","edgeProps","edgestart_id","start","edgeend_id","end","exDev","_parentComponent$prop5","_parentComponent$prop6","clipPath","htmlindex","ex","mycomponents","deleteWithAlarm","lItem","MySwal","confirm","fire","title","toString","showCancelButton","confirmButtonText","cancelButtonText","showLoaderOnConfirm","value","delete","info","text"],"sources":["C:/0Programmi/Dev/projects/frontend/jjodel/src/common/UX.tsx"],"sourcesContent":["import ReactJson from 'react-json-view' // npm i react-json-view\r\nimport React, {ReactElement, ReactNode} from \"react\";\r\nimport withReactContent from \"sweetalert2-react-content\";\r\nimport Swal from \"sweetalert2\";\r\nimport type { GraphElementOwnProps, GObject, Dictionary, DocString, Pointer, LGraph } from \"../joiner\";\r\nimport type { InputOwnProps } from '../components/forEndUser/Input';\r\nimport type { SelectOwnProps } from '../components/forEndUser/Select';\r\nimport type { TextAreaOwnProps } from '../components/forEndUser/TextArea';\r\nimport {\r\n    LPointerTargetable, U, Log, GraphElementComponent,\r\n    windoww, RuntimeAccessible, EdgeComponent, RuntimeAccessibleClass, EdgeOwnProps, DGraphElement, DModelElement\r\n} from \"../joiner\";\r\n\r\n// U-functions that require jsx\r\n@RuntimeAccessible('UX')\r\nexport class UX{\r\n\r\n    static recursiveMap<T extends ReactNode | ReactNode[] | null | undefined>(children: T, fn: (rn: T, i: number, depthIndices: number[])=>T, depthIndices: number[] = []): T {\r\n        // NB: depthIndices is correct but if there is an expression children evaluated to false like {false && <jsx>},\r\n        // it counts as children iterated regardless. so html indices might be apparently off, but like this is even safer as indices won't change when conditions are changed.\r\n        const innermap = (child: ReactNode, i1: number, depthIndices: number[]): T => {\r\n            if (!React.isValidElement(child)) { return child as T; }\r\n            if (child.props.children) {\r\n                // let deeperDepthIndices = [...depthIndices, i1];  // depthIndices; //\r\n                // should probably change deeperDepthIndices in [...deeperDepthIndices, i] in next uncommented line.\r\n                // Giordano: add ignore for webpack\r\n                //@ts-ignore\r\n                child = React.cloneElement(child, { children: UX.recursiveMap(child.props.children,\r\n                        (e: T, i2: number, ii) => fn(e, i2, ii), depthIndices) });\r\n            }\r\n            return fn(child as T, i1, depthIndices);\r\n        };\r\n        if (!Array.isArray(children)) return innermap(children as ReactNode, 0, [...depthIndices, 0]) as T;\r\n        return React.Children.map(children, (c: T, i3: number)=>innermap(c, i3, [...depthIndices,i3])) as T;\r\n    }\r\n    static injectProp(parentComponent: GraphElementComponent, e: ReactNode, gvidmap_useless: Dictionary<DocString<'VertexID'>, boolean>,\r\n                      parentnodeid: string, index: number, indices: number[], injectOffset?: LGraph): ReactNode {\r\n        let re: ReactElement | null = UX.ReactNodeAsElement(e);\r\n\r\n        injectOffset&&console.log(\"inject offset props 1:\", {e, re, injectOffset});\r\n        if (!re) return e;\r\n        // @ts-ignore this\r\n        // const parentComponent = this;\r\n        const type = (re.type as any).WrappedComponent?.name || re.type;\r\n        let injectProps: GraphElementOwnProps = {} as any;\r\n        if (injectOffset) {\r\n            const style = {...(re.props?.style || {})};\r\n            let offset = injectOffset.offset;\r\n            let scale = injectOffset.zoom;\r\n            style.position = \"absolute\";\r\n            style.left = offset.x;\r\n            style.top = offset.y;\r\n            style.transform = \"scale(\" + scale.x + \",\" + scale.y + \")\"\r\n            injectProps = {style};\r\n            let oldre = re;\r\n            console.log(\"inject offset props 2:\", {oldre, re, injectProps});\r\n            re = React.cloneElement(re, injectProps);\r\n        }\r\n        // const windoww = window as any;\r\n        // console.log('ux.injectingProp pre ', {type: (re.type as any).WrappedComponent?.name || re.type}, {mycomponents: windoww.mycomponents, re, props:re.props});\r\n        // add \"view\" (view id) prop as default to sub-elements of any depth to inherit the view of the parent unless the user forced another view to apply\r\n        switch (type) {\r\n            default:\r\n                // console.count('ux.injectingProp case default: ' + type);\r\n                if (indices.length <= 2 && (parentComponent?.props?.childStyle)) {\r\n                    // if first non-component child of a GraphElement with a clipPath shape, i assign clip path to it.\r\n                    console.log('injecting to first child (A):', {re, indices, il: indices.length, pc: parentComponent, injectProps, cs:parentComponent.props.childStyle});\r\n                    let istyle: GObject = injectProps.style = {...(injectProps.style || {})};\r\n                    injectProps.style = injectProps.style ? {...injectProps.style} : {};\r\n                    U.objectMergeInPlace(injectProps.style, parentComponent.props.childStyle);\r\n                } else return re;\r\n                break;\r\n            /*\r\n            case windoww.Components.Input.name:\r\n            case windoww.Components.Textarea.name:\r\n                const objid =  re.props.obj?.id || re.props.obj || parentComponent.props.data.id;\r\n                const ret = React.cloneElement(re, {key: re.props.key || parentComponent.props.view.id + '_' + parentComponent.props.data.id + '_' + re.props.field, obj: objid, obj2: objid});\r\n                //console.log('relement Input set props',\r\n                //    {'re.props.obj.id': re.props.obj?.id, 're.props.obj': re.props.obj, 'thiss.props.data.id': thiss.props.data.id, thiss, re, objid, ret, 'ret.props': ret.props});\r\n                return ret;*/\r\n            // case windoww.Components.GraphElement.name:\r\n            case windoww.Components.Input.cname+\"Component\":\r\n            case windoww.Components.Select.cname+\"Component\":\r\n            case windoww.Components.TextArea.cname+\"Component\":\r\n                // todo: can i do a injector that if the user provides a ModelElement list raw <div>{this.children}</div> it wraps them in DefaultNode?\r\n                const injectProps2: InputOwnProps | SelectOwnProps | TextAreaOwnProps = {} as any;\r\n                const parentnodeid = parentComponent.props.node?.id;\r\n                injectProps2.data = re.props.data || (typeof parentComponent.props.data === \"string\" ? parentComponent.props.data : parentComponent.props.data?.id);\r\n                // !IMPORTANT! this key does not remove the responsability of adding keys to <GraphElement>s. this is assigning the key to the first returned element by component A,\r\n                // but react needs to distinguish component A from other components, and he still doesn't have a key. in fact this is useless as this component can only have 1 child\r\n                injectProps2.key = re.props.key || (parentnodeid + \"^input_\"+index);\r\n                return React.cloneElement(re, injectProps2);\r\n            case windoww.Components.GraphElementComponent.cname:\r\n            // case windoww.Components.DefaultNode.name:\r\n            case windoww.Components.DefaultNodeComponent.cname:\r\n            // case windoww.Components.Graph.name:\r\n            // case windoww.Components.GraphComponent.cname:\r\n            case \"Graph\": case \"GraphComponent\":\r\n            // case windoww.Components.Field.name:\r\n            // case windoww.Components.FieldComponent.cname:\r\n            // case windoww.Components.Vertex.name:\r\n            case EdgeComponent.cname:\r\n            case windoww.Components.VertexComponent.cname:\r\n                injectProps.parentViewId = parentComponent.props.view.id || (parentComponent.props.view as any); // re.props.view ||  thiss.props.view\r\n                injectProps.parentnodeid = parentComponent.props.node?.id;\r\n                injectProps.graphid = parentComponent.props.graphid;\r\n                // const vidmap = GraphElementRaw.graphVertexID_counter;\r\n                // if (!vidmap[injectProps.graphid]) vidmap[injectProps.graphid] = {};\r\n                // const gvidmap = vidmap[injectProps.graphid];\r\n                // const validVertexIdCondition = (id: string): boolean => gvidmap_useless[id];\r\n                // todo: come butto dei sotto-vertici dentro un vertice contenitore? o dentro un sotto-grafo? senza modificare il jsx ma solo draggando? React-portals?\r\n                const dataid = (typeof re.props.data === \"string\" ? re.props.data : re.props.data?.id) || \"shapeless\";\r\n                let idbasename: string;\r\n                if (re.props.initialSize?.id) { idbasename = re.props.initialSize?.id; } else\r\n                if (re.props.nodeid) { idbasename = (injectProps.parentnodeid) + \"^\" + re.props.nodeid; } else\r\n                switch (type) {\r\n                    default:\r\n                        idbasename = injectProps.parentnodeid + \"^\" + dataid + \"N\";\r\n                        break;\r\n                    case windoww.Components.EdgePoint.cname:\r\n                        idbasename = injectProps.parentnodeid + \"^\" + (dataid || re.props.startingSize?.id || indices.join(\",\")) + \"EP\";\r\n                        break;\r\n                    case EdgeComponent.cname: case \"Edge\":\r\n                        let edgeProps:EdgeOwnProps = re.props;\r\n                        let edgestart_id: Pointer<DGraphElement> | Pointer<DModelElement> = (edgeProps.start as any).id || edgeProps.start;\r\n                        let edgeend_id: Pointer<DGraphElement> | Pointer<DModelElement> = (edgeProps.end as any).id || edgeProps.end;\r\n                        idbasename = injectProps.parentnodeid + \"^\" + edgestart_id + \"~\" + edgeend_id;\r\n                }\r\n                // (injectProps.parentnodeid)+\"^\"+(dataid)+indices.join(\",\");//injectProps.graphid + '^' + dataid;\r\n                // console.log(\"setting nodeid\", {injectProps, props:re.props, re});\r\n                // Log.exDev(!injectProps.graphid || !dataid, 'vertex is missing mandatory props.', {graphid: injectProps.graphid, dataid, props: re.props});\r\n                Log.exDev(!injectProps.graphid, 'vertex is missing mandatory props (graphid).', {graphid: injectProps.graphid, dataid, props: re.props});\r\n                if (false && indices.length === 2) {\r\n                    // if first component child, of a component? like (DefaultNode -> Vertex)?\r\n                    console.log('injecting to first child (B):', {re, pc: parentComponent, injectProps})\r\n                    if (parentComponent?.props.style?.clipPath) injectProps.style = {...(injectProps.style || {}), clipPath: parentComponent?.props.style?.clipPath||''}\r\n                }\r\n                injectProps.nodeid = idbasename; // U.increaseEndingNumber(idbasename, false, false, validVertexIdCondition);\r\n                injectProps.htmlindex = indices[indices.length - 1]; // re.props.node ? re.props.node.htmlindex : indices[indices.length - 1];\r\n                injectProps.key = re.props.key || injectProps.nodeid;\r\n                // console.log(\"cloning jsx:\", re, injectProps);\r\n                Log.ex((injectProps.nodeid === injectProps.graphid||injectProps.nodeid === injectProps.parentnodeid) && type != \"GraphComponent\", \"User manually assigned a invalid node id. please remove or change prop \\\"nodeid\\\"\", {type: (re.type as any).WrappedComponent?.cname || re.type}, {mycomponents: windoww.mycomponents, re, props:re.props});\r\n        }\r\n        return React.cloneElement(re, injectProps);\r\n    }\r\n\r\n    static ReactNodeAsElement(e: React.ReactNode): React.ReactElement | null { return e && (e as ReactElement).type ? e as ReactElement : null; }\r\n\r\n    public static async deleteWithAlarm(lItem: LPointerTargetable) {\r\n        const MySwal = withReactContent(Swal);\r\n        const confirm = await MySwal.fire({\r\n            title: \"Delete \" + lItem.toString() + \"?\",\r\n            showCancelButton: true,\r\n            confirmButtonText: \"Yes\",\r\n            cancelButtonText: \"No\",\r\n            showLoaderOnConfirm: true\r\n        });\r\n        if (confirm.value === true) {\r\n            lItem.delete();\r\n        }\r\n    }\r\n    public static async info(text: string) {\r\n        const MySwal = withReactContent(Swal);\r\n        const confirm = await MySwal.fire({\r\n            title: text,\r\n            showCancelButton: false,\r\n            confirmButtonText: \"Got It\"\r\n        });\r\n    }\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}