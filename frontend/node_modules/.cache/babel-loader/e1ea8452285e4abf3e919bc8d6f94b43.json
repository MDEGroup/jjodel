{"ast":null,"code":"import React from 'react';\nimport ReactDOM from 'react-dom';\nimport debounce from 'lodash/debounce';\nimport { isSafari, popupSupported, popupWindowBorder } from './BrowserPopupWindow';\nconst onNewWindowResize = debounce(() => {\n  // add/remove element on main document, force it to dispatch resize observer event on the popup window\n  let div = document.createElement('div');\n  document.body.append(div);\n  div.remove();\n  // TODO update resize event\n}, 200);\n/**\n * The NewWindow class object.\n * @public\n */\nclass NewWindow extends React.PureComponent {\n  /**\n   * The NewWindow function constructor.\n   * @param {Object} props\n   */\n  constructor(props) {\n    super(props);\n    this.released = false;\n    this.container = document.createElement('div');\n    this.state = {\n      mounted: false\n    };\n    this.onMainWindowUnload = () => {\n      if (this.window) {\n        this.window.close();\n      }\n    };\n    /**\n     * Release the new window and anything that was bound to it.\n     */\n    this.release = event => {\n      // This method can be called once.\n      if (this.released) {\n        return;\n      }\n      this.released = true;\n      if (this.windowCheckerInterval) {\n        clearInterval(this.windowCheckerInterval);\n        this.windowCheckerInterval = null;\n      }\n      window.removeEventListener('beforeunload', this.onMainWindowUnload);\n      this.window.removeEventListener('beforeunload', this.release);\n      if (event) {\n        // Call any function bound to the `onUnload` prop.\n        const {\n          onClose\n        } = this.props;\n        if (typeof onClose === 'function') {\n          onClose();\n        }\n      }\n    };\n  }\n  /**\n   * Render the NewWindow component.\n   */\n  render() {\n    if (!this.state.mounted) return null;\n    return ReactDOM.createPortal(this.props.children, this.container);\n  }\n  componentDidMount() {\n    this.openChild();\n    this.setState({\n      mounted: true\n    });\n  }\n  /**\n   * Create the new window when NewWindow component mount.\n   */\n  openChild() {\n    const {\n      url,\n      title,\n      name,\n      width,\n      height,\n      initPopupInnerRect,\n      initPopupOuterRect,\n      onBlock,\n      onOpen,\n      onClose\n    } = this.props;\n    let features = {\n      width,\n      height\n    };\n    if (initPopupOuterRect) {\n      features = initPopupOuterRect();\n      const [topBorder, sideBorder, bottomBorder] = popupWindowBorder;\n      if (!isSafari) {\n        features.width -= sideBorder * 2;\n        features.height -= topBorder + bottomBorder;\n      }\n    } else if (initPopupInnerRect) {\n      features = initPopupInnerRect();\n      const [topBorder, sideBorder] = popupWindowBorder;\n      features.left -= sideBorder;\n      features.top -= topBorder;\n      if (isSafari) {\n        features.height += topBorder;\n      }\n    } else {\n      features.left = window.top.outerWidth / 2 + window.top.screenX - width / 2;\n      features.top = window.top.outerHeight / 2 + window.top.screenY - height / 2;\n    }\n    // Open a new window.\n    this.window = window.open(url, name, toWindowFeatures(features));\n    // Check if the new window was successfully opened.\n    if (this.window) {\n      window.addEventListener('beforeunload', this.onMainWindowUnload);\n      this.window.addEventListener('resize', onNewWindowResize);\n      this.window.document.title = title || document.title;\n      this.window.document.body.appendChild(this.container);\n      // If specified, copy styles from parent window's document.\n      if (this.props.copyStyles) {\n        setTimeout(() => copyStyles(document, this.window.document), 0);\n      }\n      if (typeof onOpen === 'function') {\n        onOpen(this.window);\n      }\n      if (url && onClose) {\n        this.windowCheckerInterval = setInterval(() => {\n          if (!this.window || this.window.closed) {\n            this.release(true);\n          }\n        }, 50);\n      }\n      // Release anything bound to this component before the new window unload.\n      this.window.addEventListener('beforeunload', this.release);\n    } else {\n      // Handle error on opening of new window.\n      if (typeof onBlock === 'function') {\n        onBlock();\n      } else {\n        console.warn('A new window could not be opened. Maybe it was blocked.');\n      }\n    }\n  }\n  /**\n   * Close the opened window (if any) when NewWindow will unmount.\n   */\n  componentWillUnmount() {\n    if (this.window) {\n      this.release();\n      this.window.close();\n    }\n  }\n}\nNewWindow.supported = popupSupported;\n/**\n * NewWindow default props.\n */\nNewWindow.defaultProps = {\n  url: '',\n  name: '',\n  width: 640,\n  height: 480,\n  copyStyles: true\n};\n/**\n * Utility functions.\n * @private\n */\n/**\n * Copy styles from a source document to a target.\n * @param {Object} source\n * @param {Object} target\n * @private\n */\nfunction copyStyles(source, target) {\n  Array.from(source.styleSheets).forEach(styleSheet => {\n    // For <style> elements\n    let rules;\n    if (styleSheet.href) {\n      // for <link> elements loading CSS from a URL\n      const newLinkEl = source.createElement('link');\n      newLinkEl.rel = 'stylesheet';\n      newLinkEl.href = styleSheet.href;\n      target.head.appendChild(newLinkEl);\n    } else {\n      try {\n        rules = styleSheet.cssRules;\n      } catch (err) {\n        // can't access crossdomain rules\n      }\n      if (rules) {\n        const newStyleEl = source.createElement('style');\n        // Write the text of each rule into the body of the style element\n        Array.from(styleSheet.cssRules).forEach(cssRule => {\n          const {\n            cssText,\n            type\n          } = cssRule;\n          let returnText = cssText;\n          // Check if the cssRule type is CSSImportRule (3) or CSSFontFaceRule (5) to handle local imports on a about:blank page\n          // '/custom.css' turns to 'http://my-site.com/custom.css'\n          if ([3, 5].includes(type)) {\n            returnText = cssText.split('url(').map(line => {\n              if (line[1] === '/') {\n                return `${line.slice(0, 1)}${window.location.origin}${line.slice(1)}`;\n              }\n              return line;\n            }).join('url(');\n          }\n          newStyleEl.appendChild(source.createTextNode(returnText));\n        });\n        target.head.appendChild(newStyleEl);\n      }\n    }\n  });\n}\n/**\n * Convert features props to window features format (name=value,other=value).\n * @param {Object} obj\n * @return {String}\n * @private\n */\nfunction toWindowFeatures(obj) {\n  return Object.keys(obj).reduce((features, name) => {\n    const value = obj[name];\n    if (typeof value === 'boolean') {\n      features.push(`${name}=${value ? 'yes' : 'no'}`);\n    } else {\n      features.push(`${name}=${value}`);\n    }\n    return features;\n  }, []).join(',');\n}\n/**\n * Component export.\n * @private\n */\nexport default NewWindow;","map":{"version":3,"names":["React","ReactDOM","debounce","isSafari","popupSupported","popupWindowBorder","onNewWindowResize","div","document","createElement","body","append","remove","NewWindow","PureComponent","constructor","props","released","container","state","mounted","onMainWindowUnload","window","close","release","event","windowCheckerInterval","clearInterval","removeEventListener","onClose","render","createPortal","children","componentDidMount","openChild","setState","url","title","name","width","height","initPopupInnerRect","initPopupOuterRect","onBlock","onOpen","features","topBorder","sideBorder","bottomBorder","left","top","outerWidth","screenX","outerHeight","screenY","open","toWindowFeatures","addEventListener","appendChild","copyStyles","setTimeout","setInterval","closed","console","warn","componentWillUnmount","supported","defaultProps","source","target","Array","from","styleSheets","forEach","styleSheet","rules","href","newLinkEl","rel","head","cssRules","err","newStyleEl","cssRule","cssText","type","returnText","includes","split","map","line","slice","location","origin","join","createTextNode","obj","Object","keys","reduce","value","push"],"sources":["C:/d/Programming/web/jodel-mde/node_modules/rc-new-window/es/index.js"],"sourcesContent":["import React from 'react';\nimport ReactDOM from 'react-dom';\nimport debounce from 'lodash/debounce';\nimport { isSafari, popupSupported, popupWindowBorder } from './BrowserPopupWindow';\nconst onNewWindowResize = debounce(() => {\n    // add/remove element on main document, force it to dispatch resize observer event on the popup window\n    let div = document.createElement('div');\n    document.body.append(div);\n    div.remove();\n    // TODO update resize event\n}, 200);\n/**\n * The NewWindow class object.\n * @public\n */\nclass NewWindow extends React.PureComponent {\n    /**\n     * The NewWindow function constructor.\n     * @param {Object} props\n     */\n    constructor(props) {\n        super(props);\n        this.released = false;\n        this.container = document.createElement('div');\n        this.state = { mounted: false };\n        this.onMainWindowUnload = () => {\n            if (this.window) {\n                this.window.close();\n            }\n        };\n        /**\n         * Release the new window and anything that was bound to it.\n         */\n        this.release = (event) => {\n            // This method can be called once.\n            if (this.released) {\n                return;\n            }\n            this.released = true;\n            if (this.windowCheckerInterval) {\n                clearInterval(this.windowCheckerInterval);\n                this.windowCheckerInterval = null;\n            }\n            window.removeEventListener('beforeunload', this.onMainWindowUnload);\n            this.window.removeEventListener('beforeunload', this.release);\n            if (event) {\n                // Call any function bound to the `onUnload` prop.\n                const { onClose } = this.props;\n                if (typeof onClose === 'function') {\n                    onClose();\n                }\n            }\n        };\n    }\n    /**\n     * Render the NewWindow component.\n     */\n    render() {\n        if (!this.state.mounted)\n            return null;\n        return ReactDOM.createPortal(this.props.children, this.container);\n    }\n    componentDidMount() {\n        this.openChild();\n        this.setState({ mounted: true });\n    }\n    /**\n     * Create the new window when NewWindow component mount.\n     */\n    openChild() {\n        const { url, title, name, width, height, initPopupInnerRect, initPopupOuterRect, onBlock, onOpen, onClose, } = this.props;\n        let features = { width, height };\n        if (initPopupOuterRect) {\n            features = initPopupOuterRect();\n            const [topBorder, sideBorder, bottomBorder] = popupWindowBorder;\n            if (!isSafari) {\n                features.width -= sideBorder * 2;\n                features.height -= topBorder + bottomBorder;\n            }\n        }\n        else if (initPopupInnerRect) {\n            features = initPopupInnerRect();\n            const [topBorder, sideBorder] = popupWindowBorder;\n            features.left -= sideBorder;\n            features.top -= topBorder;\n            if (isSafari) {\n                features.height += topBorder;\n            }\n        }\n        else {\n            features.left = window.top.outerWidth / 2 + window.top.screenX - width / 2;\n            features.top = window.top.outerHeight / 2 + window.top.screenY - height / 2;\n        }\n        // Open a new window.\n        this.window = window.open(url, name, toWindowFeatures(features));\n        // Check if the new window was successfully opened.\n        if (this.window) {\n            window.addEventListener('beforeunload', this.onMainWindowUnload);\n            this.window.addEventListener('resize', onNewWindowResize);\n            this.window.document.title = title || document.title;\n            this.window.document.body.appendChild(this.container);\n            // If specified, copy styles from parent window's document.\n            if (this.props.copyStyles) {\n                setTimeout(() => copyStyles(document, this.window.document), 0);\n            }\n            if (typeof onOpen === 'function') {\n                onOpen(this.window);\n            }\n            if (url && onClose) {\n                this.windowCheckerInterval = setInterval(() => {\n                    if (!this.window || this.window.closed) {\n                        this.release(true);\n                    }\n                }, 50);\n            }\n            // Release anything bound to this component before the new window unload.\n            this.window.addEventListener('beforeunload', this.release);\n        }\n        else {\n            // Handle error on opening of new window.\n            if (typeof onBlock === 'function') {\n                onBlock();\n            }\n            else {\n                console.warn('A new window could not be opened. Maybe it was blocked.');\n            }\n        }\n    }\n    /**\n     * Close the opened window (if any) when NewWindow will unmount.\n     */\n    componentWillUnmount() {\n        if (this.window) {\n            this.release();\n            this.window.close();\n        }\n    }\n}\nNewWindow.supported = popupSupported;\n/**\n * NewWindow default props.\n */\nNewWindow.defaultProps = {\n    url: '',\n    name: '',\n    width: 640,\n    height: 480,\n    copyStyles: true,\n};\n/**\n * Utility functions.\n * @private\n */\n/**\n * Copy styles from a source document to a target.\n * @param {Object} source\n * @param {Object} target\n * @private\n */\nfunction copyStyles(source, target) {\n    Array.from(source.styleSheets).forEach(styleSheet => {\n        // For <style> elements\n        let rules;\n        if (styleSheet.href) {\n            // for <link> elements loading CSS from a URL\n            const newLinkEl = source.createElement('link');\n            newLinkEl.rel = 'stylesheet';\n            newLinkEl.href = styleSheet.href;\n            target.head.appendChild(newLinkEl);\n        }\n        else {\n            try {\n                rules = styleSheet.cssRules;\n            }\n            catch (err) {\n                // can't access crossdomain rules\n            }\n            if (rules) {\n                const newStyleEl = source.createElement('style');\n                // Write the text of each rule into the body of the style element\n                Array.from(styleSheet.cssRules).forEach(cssRule => {\n                    const { cssText, type } = cssRule;\n                    let returnText = cssText;\n                    // Check if the cssRule type is CSSImportRule (3) or CSSFontFaceRule (5) to handle local imports on a about:blank page\n                    // '/custom.css' turns to 'http://my-site.com/custom.css'\n                    if ([3, 5].includes(type)) {\n                        returnText = cssText\n                            .split('url(')\n                            .map(line => {\n                            if (line[1] === '/') {\n                                return `${line.slice(0, 1)}${window.location.origin}${line.slice(1)}`;\n                            }\n                            return line;\n                        })\n                            .join('url(');\n                    }\n                    newStyleEl.appendChild(source.createTextNode(returnText));\n                });\n                target.head.appendChild(newStyleEl);\n            }\n        }\n    });\n}\n/**\n * Convert features props to window features format (name=value,other=value).\n * @param {Object} obj\n * @return {String}\n * @private\n */\nfunction toWindowFeatures(obj) {\n    return Object.keys(obj)\n        .reduce((features, name) => {\n        const value = obj[name];\n        if (typeof value === 'boolean') {\n            features.push(`${name}=${value ? 'yes' : 'no'}`);\n        }\n        else {\n            features.push(`${name}=${value}`);\n        }\n        return features;\n    }, [])\n        .join(',');\n}\n/**\n * Component export.\n * @private\n */\nexport default NewWindow;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}