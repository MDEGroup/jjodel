{"ast":null,"code":"import _regeneratorRuntime from\"C:/d/Programming/web/jodel-mde/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";import _toConsumableArray from\"C:/d/Programming/web/jodel-mde/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";import _createForOfIteratorHelper from\"C:/d/Programming/web/jodel-mde/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";import _classCallCheck from\"C:/d/Programming/web/jodel-mde/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";import _createClass from\"C:/d/Programming/web/jodel-mde/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";var _Symbol$iterator;import{Log}from\"../joiner\";/* problema: se creo una key per ordinare l'albero e trovare \"of\" in O(log n), allora perdo l'ordinamento arbitrario di sottoalberi = sottoclassi a prescindere dai nomi.\r\n   potrei fare un dizionario di alberi, 1 albero per ogni dclass e lclass, con sottoelementi\r\n    */ // not binary, not rb tree, not balanced, just a tree\n// it is N-ary\n// ma probabilmente non dovrei usare affatto un albero, ma fare un dizionario per ogni classe con cosa estende direttamente\n// e uno con cosa estende direttamente e indirettamente popolato automaticamente in n*logn una volta e fine\n// navigando superclass\n// B.superclass = [a1, a2] --- > a1.pushdirectsubclass(b), a2 same.  poi se a1 estende c, c.pushindirectsubclass(b)... e si risale da b finchè ci sono superclassi (logn) volte, fatto per tutte le n classi\n// each node have a \"node<T>\" value and a subtree with all subelements.\n// iterable with for...of with width iterator (not depth)\n_Symbol$iterator=Symbol.iterator;export var SimpleTree=/*#__PURE__*/function(){// childkey: adds subobjects found in \"roots\" parameters as nodes<T> in the tree\n// comparison: tells if a node comes first or after another, example: (a, b) => a.name.toUpperCase() < b.name.toUpperCase()\nfunction SimpleTree(roots,childKey,loopdetector){_classCallCheck(this,SimpleTree);this.subelements=void 0;this.node=void 0;this[_Symbol$iterator]=/*#__PURE__*/_regeneratorRuntime.mark(function _callee(){var fifo,nextLevel,_iterator,_step,subtree;return _regeneratorRuntime.wrap(function _callee$(_context){while(1){switch(_context.prev=_context.next){case 0:_context.next=2;return this;case 2:fifo=this.subelements;case 3:if(!fifo.length){_context.next=26;break;}nextLevel=[];_iterator=_createForOfIteratorHelper(fifo);_context.prev=6;_iterator.s();case 8:if((_step=_iterator.n()).done){_context.next=15;break;}subtree=_step.value;_context.next=12;return subtree;case 12:nextLevel.push.apply(nextLevel,_toConsumableArray(subtree.subelements));case 13:_context.next=8;break;case 15:_context.next=20;break;case 17:_context.prev=17;_context.t0=_context[\"catch\"](6);_iterator.e(_context.t0);case 20:_context.prev=20;_iterator.f();return _context.finish(20);case 23://@ts-ignore\n// console.log(\"fifo -> next level\", fifo.map(f=>f?.node?.cname), nextLevel.map(f=>f?.node?.cname));\nfifo=nextLevel;_context.next=3;break;case 26:case\"end\":return _context.stop();}}},_callee,this,[[6,17,20,23]]);});// if arr, add N roots as subelements, and delegate actual subelements of the root to subtree constructors\nif(!loopdetector)loopdetector=new WeakMap();/*(this as any)[Symbol.iterator] = function *(){\r\n            yield this;\r\n            let fifo = this.subelements;\r\n            while (fifo.length) {\r\n                let nextLevel = [];\r\n                for (let subtree of fifo) {\r\n                    yield subtree;\r\n                    nextLevel.push(subtree);\r\n                }\r\n                fifo = nextLevel;\r\n            }\r\n        }*/ //@ts-ignore\nthis.debug=roots.cname;this.subelements=[];if(Array.isArray(roots)){this.node=undefined;var _iterator2=_createForOfIteratorHelper(roots),_step2;try{for(_iterator2.s();!(_step2=_iterator2.n()).done;){var e=_step2.value;if(!e)continue;this.add(e,childKey,loopdetector);}}catch(err){_iterator2.e(err);}finally{_iterator2.f();}}// if not arr, add immediate subelements of root\nelse{this.node=roots;if(!childKey)return;var child=this.node[childKey];if(Array.isArray(child)){var _iterator3=_createForOfIteratorHelper(child),_step3;try{for(_iterator3.s();!(_step3=_iterator3.n()).done;){var c=_step3.value;this.add(c,childKey,loopdetector);}}catch(err){_iterator3.e(err);}finally{_iterator3.f();}}else this.add(child,childKey,loopdetector);}}_createClass(SimpleTree,[{key:\"getiIsSubElementMatrix\",value:// can be undef, if root was an array instead of a single element.\n// the nodes containing the rooots will be the childrens instead, as if they are N trees\n// with a fake node joining them in a single one\n// up: SimpleTree<T>; maybe do this too\nfunction getiIsSubElementMatrix(namekey){var ret={};// matrix name x name telling if A extends B\nvar _iterator4=_createForOfIteratorHelper(this),_step4;try{for(_iterator4.s();!(_step4=_iterator4.n()).done;){var o=_step4.value;// O(N^2), but optimal for this task, as the matrix size is O(N^2) as well\nvar name=o.node[namekey];if(!name)Log.ee(\"missing key property  in tree node: \",{tree:this,node:o.node,namekey:namekey});ret[name]={};// if (o === this) continue;\nvar _iterator5=_createForOfIteratorHelper(o),_step5;try{for(_iterator5.s();!(_step5=_iterator5.n()).done;){var subo=_step5.value;var subname=subo.node[namekey];if(!subname){console.log(\"skipped\");continue;}ret[name][subname]=true;}}catch(err){_iterator5.e(err);}finally{_iterator5.f();}}}catch(err){_iterator4.e(err);}finally{_iterator4.f();}return ret;}},{key:\"add\",value:function add(e,childKey,loopdetector){if(loopdetector){if(loopdetector.get(e)){Log.eDev(e.cname.indexOf(\"GraphVertex\")!==1,\"A constructor is extending 2 different classes, or there is a loop in Tree constructor parameter.\",\"GraphVertex should be the only class doing that currently\",{e:e,cname:e.cname,childKey:childKey,loopdetector:loopdetector});return;}loopdetector.set(e,true);}var subtree=new SimpleTree(e,childKey,loopdetector);this.subelements.push(subtree);return subtree;}},{key:\"getSubtree\",value:function getSubtree(e){var _iterator6=_createForOfIteratorHelper(this),_step6;try{for(_iterator6.s();!(_step6=_iterator6.n()).done;){var t=_step6.value;if(t.node==e)return t;}}catch(err){_iterator6.e(err);}finally{_iterator6.f();}return undefined;}}]);return SimpleTree;}();","map":{"version":3,"names":["Log","_Symbol$iterator","Symbol","iterator","SimpleTree","roots","childKey","loopdetector","_classCallCheck","subelements","node","_regeneratorRuntime","mark","_callee","fifo","nextLevel","_iterator","_step","subtree","wrap","_callee$","_context","prev","next","length","_createForOfIteratorHelper","s","n","done","value","push","apply","_toConsumableArray","t0","e","f","finish","stop","WeakMap","debug","cname","Array","isArray","undefined","_iterator2","_step2","add","err","child","_iterator3","_step3","c","_createClass","key","getiIsSubElementMatrix","namekey","ret","_iterator4","_step4","o","name","ee","tree","_iterator5","_step5","subo","subname","console","log","get","eDev","indexOf","set","getSubtree","_iterator6","_step6","t"],"sources":["C:/d/Programming/web/jodel-mde/src/common/SimpleTree.ts"],"sourcesContent":["import {Dictionary, GObject, Log, U} from \"../joiner\";\r\n\r\n\r\n/* problema: se creo una key per ordinare l'albero e trovare \"of\" in O(log n), allora perdo l'ordinamento arbitrario di sottoalberi = sottoclassi a prescindere dai nomi.\r\n   potrei fare un dizionario di alberi, 1 albero per ogni dclass e lclass, con sottoelementi\r\n    */\r\n\r\n// not binary, not rb tree, not balanced, just a tree\r\n// it is N-ary\r\n// ma probabilmente non dovrei usare affatto un albero, ma fare un dizionario per ogni classe con cosa estende direttamente\r\n// e uno con cosa estende direttamente e indirettamente popolato automaticamente in n*logn una volta e fine\r\n// navigando superclass\r\n\r\n// B.superclass = [a1, a2] --- > a1.pushdirectsubclass(b), a2 same.  poi se a1 estende c, c.pushindirectsubclass(b)... e si risale da b finchè ci sono superclassi (logn) volte, fatto per tutte le n classi\r\n// each node have a \"node<T>\" value and a subtree with all subelements.\r\n// iterable with for...of with width iterator (not depth)\r\nexport class SimpleTree<T extends GObject> {\r\n    subelements: SimpleTree<T>[];\r\n    node: T; // can be undef, if root was an array instead of a single element.\r\n    // the nodes containing the rooots will be the childrens instead, as if they are N trees\r\n    // with a fake node joining them in a single one\r\n    // up: SimpleTree<T>; maybe do this too\r\n\r\n    [Symbol.iterator] = function*(this:SimpleTree<T>) {\r\n    // [Symbol.iterator]: Generator<number, string, boolean> = function*() {\r\n    // [Symbol.iterator]: Generator<number, string, boolean>= () => {\r\n    // [Symbol.iterator] () {\r\n        yield this;\r\n        let fifo = this.subelements;\r\n        while (fifo.length) {\r\n            let nextLevel = [];\r\n            for (let subtree of fifo) {\r\n                yield subtree;\r\n                nextLevel.push(...subtree.subelements);\r\n            }\r\n            //@ts-ignore\r\n            // console.log(\"fifo -> next level\", fifo.map(f=>f?.node?.cname), nextLevel.map(f=>f?.node?.cname));\r\n            fifo = nextLevel;\r\n        }\r\n    }\r\n\r\n    getiIsSubElementMatrix(namekey: keyof T): Dictionary<string, Dictionary<string, boolean>>{\r\n        let ret: Dictionary<string, Dictionary<string, boolean>> = {}// matrix name x name telling if A extends B\r\n        for (let o of this) { // O(N^2), but optimal for this task, as the matrix size is O(N^2) as well\r\n            let name = o.node[namekey];\r\n            if (!name) Log.ee(\"missing key property  in tree node: \", {tree: this, node:o.node, namekey});\r\n            ret[name] = {};\r\n            // if (o === this) continue;\r\n            for (let subo of o) {\r\n                let subname = subo.node[namekey];\r\n                if (!subname) { console.log(\"skipped\"); continue; }\r\n                ret[name as string][subname as string] = true;\r\n            }\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    public add(e: T, childKey?: keyof T, loopdetector?: WeakMap<T, boolean>): SimpleTree<T> | undefined{\r\n        if (loopdetector) {\r\n            if (loopdetector.get(e)) {\r\n                Log.eDev(e.cname.indexOf(\"GraphVertex\") !== 1,\r\n                    \"A constructor is extending 2 different classes, or there is a loop in Tree constructor parameter.\",\r\n                    \"GraphVertex should be the only class doing that currently\",\r\n                    {e, cname:e.cname, childKey, loopdetector});\r\n                return;\r\n            }\r\n            loopdetector.set(e, true);\r\n        }\r\n        let subtree =  new SimpleTree<T>(e, childKey, loopdetector);\r\n        this.subelements.push(subtree);\r\n        return subtree; }\r\n\r\n    getSubtree(e: T): SimpleTree<T> | undefined {\r\n        for (let t of this) { if (t.node == e) return t; }\r\n        return undefined; }\r\n\r\n    // childkey: adds subobjects found in \"roots\" parameters as nodes<T> in the tree\r\n    // comparison: tells if a node comes first or after another, example: (a, b) => a.name.toUpperCase() < b.name.toUpperCase()\r\n    constructor(roots: GObject | GObject[], childKey?: keyof T, loopdetector?: WeakMap<T, boolean>) {\r\n        // if arr, add N roots as subelements, and delegate actual subelements of the root to subtree constructors\r\n        if (!loopdetector) loopdetector = new WeakMap();\r\n        /*(this as any)[Symbol.iterator] = function *(){\r\n            yield this;\r\n            let fifo = this.subelements;\r\n            while (fifo.length) {\r\n                let nextLevel = [];\r\n                for (let subtree of fifo) {\r\n                    yield subtree;\r\n                    nextLevel.push(subtree);\r\n                }\r\n                fifo = nextLevel;\r\n            }\r\n        }*/\r\n\r\n        //@ts-ignore\r\n        this.debug = roots.cname;\r\n        this.subelements = [];\r\n        if (Array.isArray(roots)) {\r\n            this.node = undefined as any;\r\n            for (let e of roots) {\r\n                if (!e) continue;\r\n                this.add(e as T, childKey, loopdetector);\r\n            }\r\n        }\r\n        // if not arr, add immediate subelements of root\r\n        else {\r\n            this.node = roots as T;\r\n            if (!childKey) return;\r\n            let child: T | T[] = this.node[childKey];\r\n            if (Array.isArray(child)) {\r\n                for (let c of child) this.add(c, childKey, loopdetector);\r\n            }\r\n            else this.add(child, childKey, loopdetector);\r\n        }\r\n    }\r\n\r\n\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}