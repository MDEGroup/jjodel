{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.mapWindowToElement = exports.mapElementToScreenRect = exports.estimateWindowBorder = exports.estimateBrowserZoom = void 0;\nconst BrowserPopupWindow_1 = require(\"./BrowserPopupWindow\");\nfunction estimateBrowserZoom(_window) {\n  // one of them might be off by a lot due to developer console or other browser plugin\n  let [topBorder, sideBorder, bottomBorder] = BrowserPopupWindow_1.gerWindowBorder();\n  if (_window.outerWidth === _window.screen.availWidth) {\n    sideBorder = 0;\n    bottomBorder = 0;\n  }\n  let xRatio = (_window.outerWidth - sideBorder * 2) / _window.innerWidth;\n  let yRatio = (_window.outerHeight - topBorder - bottomBorder) / _window.innerHeight;\n  let zoomRatio = Math.min(yRatio, xRatio);\n  if (zoomRatio > 1.8) {\n    zoomRatio = Math.round(zoomRatio);\n  } else if (zoomRatio > 0.73) {\n    zoomRatio = Math.round(zoomRatio * 20) / 20;\n  } else {\n    zoomRatio = 2 / Math.round(2 / zoomRatio);\n  }\n  return zoomRatio;\n}\nexports.estimateBrowserZoom = estimateBrowserZoom;\nfunction estimateWindowBorder(_window) {\n  let addBorder = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  let zoom = _window ? estimateBrowserZoom(_window) : 1;\n  let xBorder = _window.outerWidth - _window.innerWidth * zoom >> 1;\n  let yBorder = Math.round(_window.outerHeight - _window.innerHeight * zoom);\n  if (xBorder > 32) {\n    // probably because of debugger console, assume it's in the right side\n    xBorder = 8;\n  } else {\n    yBorder -= xBorder;\n  }\n  return [xBorder, yBorder, zoom];\n}\nexports.estimateWindowBorder = estimateWindowBorder;\nclass MapRect2D {\n  init(x1, y1, w1, h1, x2, y2, w2, h2) {\n    this.scaleX = w2 / w1;\n    this.scaleY = h2 / h1;\n    this.offsetX = x2 - x1 * this.scaleX;\n    this.offsetY = y2 - y1 * this.scaleY;\n  }\n  map(pt) {\n    return {\n      x: pt.x * this.scaleX + this.offsetX,\n      y: pt.y * this.scaleY + this.offsetY\n    };\n  }\n  revertMap(pt) {\n    return {\n      x: (pt.x - this.offsetX) / this.scaleX,\n      y: (pt.y - this.offsetY) / this.scaleY\n    };\n  }\n}\nfunction mapElementToScreenRect(element, rect) {\n  if (!element) {\n    return null;\n  }\n  let clientRect = element.getBoundingClientRect();\n  let mapRect = new MapRect2D();\n  mapRect.init(0, 0, element.offsetWidth, element.offsetHeight, clientRect.x, clientRect.y, clientRect.width, clientRect.height);\n  let mappedRect;\n  if (rect) {\n    let {\n      x,\n      y\n    } = mapRect.map({\n      x: rect.left,\n      y: rect.top\n    });\n    let {\n      x: x2,\n      y: y2\n    } = mapRect.map({\n      x: rect.left + rect.width,\n      y: rect.top + rect.height\n    });\n    mappedRect = {\n      left: x,\n      top: y,\n      width: x2 - x,\n      height: y2 - y\n    };\n  } else {\n    mappedRect = {\n      left: clientRect.left,\n      top: clientRect.top,\n      width: clientRect.width,\n      height: clientRect.height\n    };\n  }\n  let _document = element.ownerDocument;\n  let _window = _document.defaultView;\n  if (!_window) {\n    return clientRect;\n  }\n  // recursively get rect if it's an iframe\n  if (_window.frameElement) {\n    return mapElementToScreenRect(_window.frameElement, mappedRect);\n  }\n  let [xBorder, yBorder, zoom] = estimateWindowBorder(_window);\n  if (zoom !== 1) {\n    mappedRect.left *= zoom;\n    mappedRect.top *= zoom;\n    mappedRect.width *= zoom;\n    mappedRect.height *= zoom;\n  }\n  mappedRect.left += _window.screenX + xBorder;\n  mappedRect.top += _window.screenY + yBorder;\n  return mappedRect;\n}\nexports.mapElementToScreenRect = mapElementToScreenRect;\nfunction mapWindowToElement(targetElement, fromWindow, fromRect) {\n  let removeBorder = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n  if (!targetElement) {\n    return null;\n  }\n  if (fromWindow) {\n    fromRect = {\n      left: fromWindow.screenX,\n      top: fromWindow.screenY,\n      width: fromWindow.outerWidth,\n      height: fromWindow.outerHeight\n    };\n    if (removeBorder) {\n      const [topBorder, sideBorder, bottomBorder] = BrowserPopupWindow_1.popupWindowBorder;\n      fromRect.left += sideBorder;\n      fromRect.top += topBorder;\n      fromRect.width -= sideBorder * 2;\n      fromRect.height -= topBorder + bottomBorder;\n    }\n  } else if (!fromRect) {\n    return null;\n  }\n  let _document = targetElement.ownerDocument;\n  let _window = _document.defaultView;\n  if (!_window) {\n    return fromRect;\n  }\n  // recursively get rect if it's an iframe\n  if (_window.frameElement) {\n    fromRect = mapWindowToElement(_window.frameElement, null, fromRect);\n  } else {\n    let [xBorder, yBorder, zoom] = estimateWindowBorder(_window);\n    fromRect.left -= _window.screenX + xBorder;\n    fromRect.top -= _window.screenY + yBorder;\n    if (zoom !== 1) {\n      fromRect.left /= zoom;\n      fromRect.top /= zoom;\n      fromRect.width /= zoom;\n      fromRect.height /= zoom;\n    }\n  }\n  let clientRect = targetElement.getBoundingClientRect();\n  let mapRect = new MapRect2D();\n  mapRect.init(0, 0, targetElement.offsetWidth, targetElement.offsetHeight, clientRect.x, clientRect.y, clientRect.width, clientRect.height);\n  let mappedRect;\n  let {\n    x,\n    y\n  } = mapRect.revertMap({\n    x: fromRect.left,\n    y: fromRect.top\n  });\n  let {\n    x: x2,\n    y: y2\n  } = mapRect.revertMap({\n    x: fromRect.left + fromRect.width,\n    y: fromRect.top + fromRect.height\n  });\n  mappedRect = {\n    left: x,\n    top: y,\n    width: x2 - x,\n    height: y2 - y\n  };\n  return mappedRect;\n}\nexports.mapWindowToElement = mapWindowToElement;","map":{"version":3,"names":["Object","defineProperty","exports","value","mapWindowToElement","mapElementToScreenRect","estimateWindowBorder","estimateBrowserZoom","BrowserPopupWindow_1","require","_window","topBorder","sideBorder","bottomBorder","gerWindowBorder","outerWidth","screen","availWidth","xRatio","innerWidth","yRatio","outerHeight","innerHeight","zoomRatio","Math","min","round","addBorder","arguments","length","undefined","zoom","xBorder","yBorder","MapRect2D","init","x1","y1","w1","h1","x2","y2","w2","h2","scaleX","scaleY","offsetX","offsetY","map","pt","x","y","revertMap","element","rect","clientRect","getBoundingClientRect","mapRect","offsetWidth","offsetHeight","width","height","mappedRect","left","top","_document","ownerDocument","defaultView","frameElement","screenX","screenY","targetElement","fromWindow","fromRect","removeBorder","popupWindowBorder"],"sources":["C:/d/Programming/web/jodel-mde/node_modules/rc-new-window/lib/ScreenPosition.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.mapWindowToElement = exports.mapElementToScreenRect = exports.estimateWindowBorder = exports.estimateBrowserZoom = void 0;\nconst BrowserPopupWindow_1 = require(\"./BrowserPopupWindow\");\nfunction estimateBrowserZoom(_window) {\n    // one of them might be off by a lot due to developer console or other browser plugin\n    let [topBorder, sideBorder, bottomBorder] = BrowserPopupWindow_1.gerWindowBorder();\n    if (_window.outerWidth === _window.screen.availWidth) {\n        sideBorder = 0;\n        bottomBorder = 0;\n    }\n    let xRatio = (_window.outerWidth - sideBorder * 2) / _window.innerWidth;\n    let yRatio = (_window.outerHeight - topBorder - bottomBorder) / _window.innerHeight;\n    let zoomRatio = Math.min(yRatio, xRatio);\n    if (zoomRatio > 1.8) {\n        zoomRatio = Math.round(zoomRatio);\n    }\n    else if (zoomRatio > 0.73) {\n        zoomRatio = Math.round(zoomRatio * 20) / 20;\n    }\n    else {\n        zoomRatio = 2 / Math.round(2 / zoomRatio);\n    }\n    return zoomRatio;\n}\nexports.estimateBrowserZoom = estimateBrowserZoom;\nfunction estimateWindowBorder(_window, addBorder = false) {\n    let zoom = _window ? estimateBrowserZoom(_window) : 1;\n    let xBorder = (_window.outerWidth - _window.innerWidth * zoom) >> 1;\n    let yBorder = Math.round(_window.outerHeight - _window.innerHeight * zoom);\n    if (xBorder > 32) {\n        // probably because of debugger console, assume it's in the right side\n        xBorder = 8;\n    }\n    else {\n        yBorder -= xBorder;\n    }\n    return [xBorder, yBorder, zoom];\n}\nexports.estimateWindowBorder = estimateWindowBorder;\nclass MapRect2D {\n    init(x1, y1, w1, h1, x2, y2, w2, h2) {\n        this.scaleX = w2 / w1;\n        this.scaleY = h2 / h1;\n        this.offsetX = x2 - x1 * this.scaleX;\n        this.offsetY = y2 - y1 * this.scaleY;\n    }\n    map(pt) {\n        return { x: pt.x * this.scaleX + this.offsetX, y: pt.y * this.scaleY + this.offsetY };\n    }\n    revertMap(pt) {\n        return { x: (pt.x - this.offsetX) / this.scaleX, y: (pt.y - this.offsetY) / this.scaleY };\n    }\n}\nfunction mapElementToScreenRect(element, rect) {\n    if (!element) {\n        return null;\n    }\n    let clientRect = element.getBoundingClientRect();\n    let mapRect = new MapRect2D();\n    mapRect.init(0, 0, element.offsetWidth, element.offsetHeight, clientRect.x, clientRect.y, clientRect.width, clientRect.height);\n    let mappedRect;\n    if (rect) {\n        let { x, y } = mapRect.map({ x: rect.left, y: rect.top });\n        let { x: x2, y: y2 } = mapRect.map({ x: rect.left + rect.width, y: rect.top + rect.height });\n        mappedRect = { left: x, top: y, width: x2 - x, height: y2 - y };\n    }\n    else {\n        mappedRect = {\n            left: clientRect.left,\n            top: clientRect.top,\n            width: clientRect.width,\n            height: clientRect.height,\n        };\n    }\n    let _document = element.ownerDocument;\n    let _window = _document.defaultView;\n    if (!_window) {\n        return clientRect;\n    }\n    // recursively get rect if it's an iframe\n    if (_window.frameElement) {\n        return mapElementToScreenRect(_window.frameElement, mappedRect);\n    }\n    let [xBorder, yBorder, zoom] = estimateWindowBorder(_window);\n    if (zoom !== 1) {\n        mappedRect.left *= zoom;\n        mappedRect.top *= zoom;\n        mappedRect.width *= zoom;\n        mappedRect.height *= zoom;\n    }\n    mappedRect.left += _window.screenX + xBorder;\n    mappedRect.top += _window.screenY + yBorder;\n    return mappedRect;\n}\nexports.mapElementToScreenRect = mapElementToScreenRect;\nfunction mapWindowToElement(targetElement, fromWindow, fromRect, removeBorder = true) {\n    if (!targetElement) {\n        return null;\n    }\n    if (fromWindow) {\n        fromRect = {\n            left: fromWindow.screenX,\n            top: fromWindow.screenY,\n            width: fromWindow.outerWidth,\n            height: fromWindow.outerHeight,\n        };\n        if (removeBorder) {\n            const [topBorder, sideBorder, bottomBorder] = BrowserPopupWindow_1.popupWindowBorder;\n            fromRect.left += sideBorder;\n            fromRect.top += topBorder;\n            fromRect.width -= sideBorder * 2;\n            fromRect.height -= topBorder + bottomBorder;\n        }\n    }\n    else if (!fromRect) {\n        return null;\n    }\n    let _document = targetElement.ownerDocument;\n    let _window = _document.defaultView;\n    if (!_window) {\n        return fromRect;\n    }\n    // recursively get rect if it's an iframe\n    if (_window.frameElement) {\n        fromRect = mapWindowToElement(_window.frameElement, null, fromRect);\n    }\n    else {\n        let [xBorder, yBorder, zoom] = estimateWindowBorder(_window);\n        fromRect.left -= _window.screenX + xBorder;\n        fromRect.top -= _window.screenY + yBorder;\n        if (zoom !== 1) {\n            fromRect.left /= zoom;\n            fromRect.top /= zoom;\n            fromRect.width /= zoom;\n            fromRect.height /= zoom;\n        }\n    }\n    let clientRect = targetElement.getBoundingClientRect();\n    let mapRect = new MapRect2D();\n    mapRect.init(0, 0, targetElement.offsetWidth, targetElement.offsetHeight, clientRect.x, clientRect.y, clientRect.width, clientRect.height);\n    let mappedRect;\n    let { x, y } = mapRect.revertMap({ x: fromRect.left, y: fromRect.top });\n    let { x: x2, y: y2 } = mapRect.revertMap({\n        x: fromRect.left + fromRect.width,\n        y: fromRect.top + fromRect.height,\n    });\n    mappedRect = { left: x, top: y, width: x2 - x, height: y2 - y };\n    return mappedRect;\n}\nexports.mapWindowToElement = mapWindowToElement;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script"}