{"ast":null,"code":"import { Log, DModel, DValue, DObject, DEnumerator, DEnumLiteral, DAttribute, DReference, DClass, DParameter, DOperation, DPackage, DAnnotation, AttribETypes, U, CreateElementAction, Selectors, PointedBy, LPointerTargetable, windoww, SetRootFieldAction, Constructors, store, SetFieldAction } from \"../joiner\";\nclass SavePack {\n  constructor() {\n    let model = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n    let vertexpos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n    let view = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n    this.model = void 0;\n    this.vertexpos = void 0;\n    this.view = void 0;\n    this.model = model;\n    this.vertexpos = vertexpos;\n    this.view = view;\n  }\n}\nexport class IStorage {\n  static get() {\n    return Log.exx(\"IStorage.get (static) should be overridden\");\n  }\n  constructor(prefix, autosave) {\n    this.prefix = void 0;\n    this.autosave = void 0;\n    this.prefix = prefix;\n    this.autosave = autosave;\n  }\n  del(key) {\n    let isOverwrite = this.get(key) !== null;\n    this.set(key, '');\n    return isOverwrite;\n  }\n  get(key) {\n    let parse = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    return Log.exx(\"IStorage.get should be overridden\");\n  }\n  serialize(val) {\n    // serialize\n    try {\n      return JSON.stringify(val);\n    } catch (e) {\n      return \"\" + val;\n    }\n  }\n  deserialize(val) {\n    // de-serialize\n    try {\n      return JSON.parse(val);\n    } catch (e) {\n      return val;\n    }\n  }\n  set0(val) {\n    return this.serialize(val);\n  }\n  get0(val) {\n    return this.deserialize(val);\n  }\n  parse(val) {\n    return this.deserialize(val);\n  }\n}\nexport class LocalStorage extends IStorage {\n  static get() {\n    return new LocalStorage(\"_j\", true);\n  }\n  constructor(prefix, autosave) {\n    super(prefix, autosave);\n  }\n  get(key) {\n    let parse = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    let val = localStorage.getItem(this.prefix + key);\n    return parse ? this.parse(val) : val;\n  }\n  set(key, val) {\n    val = this.serialize(val);\n    // let isOverwrite = localStorage.getItem(this.prefix+key);\n    localStorage.set(this.prefix + key, val);\n    return true;\n  }\n  getLastOpened(modelNumber) {\n    let modelname = \"m\" + modelNumber + \"_\";\n    const ret = new SavePack();\n    ret.model = this.get(modelname + LocalStorage.KeyList.lastOpenedModel, false) || '';\n    ret.view = this.get(modelNumber + LocalStorage.KeyList.lastOpenedView, false) || '';\n    ret.vertexpos = this.get(modelNumber + LocalStorage.KeyList.lastOpenedPosition, false) || '';\n    return ret;\n  }\n  deleteLastOpened(modelNumber) {\n    this.setLastOpened(modelNumber, '', '', '');\n  }\n  setLastOpened(modelNumber) {\n    let model = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n    let view = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n    let vertex = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '';\n    let modelname = \"m\" + modelNumber + \"_\";\n    if (model) this.set(modelname + LocalStorage.KeyList.lastOpenedModel, model);else this.del(modelname + LocalStorage.KeyList.lastOpenedModel);\n    if (view) this.set(modelname + LocalStorage.KeyList.lastOpenedView, view);else this.del(modelname + LocalStorage.KeyList.lastOpenedView);\n    if (vertex) this.set(modelname + LocalStorage.KeyList.lastOpenedPosition, vertex);else this.del(modelname + LocalStorage.KeyList.lastOpenedPosition);\n  }\n}\nLocalStorage.KeyList = {\n  lastOpenedModel: \"lastOpenedModel\",\n  lastOpenedView: \"lastOpenedView\",\n  lastOpenedPosition: \"lastOpenedPosition\"\n};\nexport class EcoreParser {\n  static parse(ecorejson, isMetamodel, filename) {\n    let persist = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n    if (!ecorejson) return [];\n    let parsedjson;\n    if (typeof ecorejson === \"string\") try {\n      parsedjson = JSON.parse(ecorejson);\n    } catch (e) {\n      windoww.temp = ecorejson;\n      Log.exx(\"error while parsing json:\", e, ecorejson.substring(0, 1000));\n      throw e;\n    } else parsedjson = ecorejson;\n    console.log(\"root parse\", ecorejson);\n    isMetamodel = !!parsedjson[ECoreRoot.ecoreEPackage];\n    Constructors.pause();\n    let parsedElements = isMetamodel ? EcoreParser.parseM2Model(parsedjson, filename) : EcoreParser.parseM1Model(parsedjson, undefined, filename);\n    console.warn(\"parse.result D\", parsedElements);\n    this.LinkAllNamesToIDs(parsedElements);\n    this.fixNamingConflicts(parsedElements);\n    Constructors.resume();\n    if (persist) {\n      CreateElementAction.newBatch(parsedElements);\n    }\n    // update m1 object pointers (need them to be persistent to navigate .fathers and get ecore pointer strings using LObject)\n    setTimeout(() => this.fixObjectPointers(parsedElements), 1);\n    windoww.tmpparse = () => LPointerTargetable.wrapAll(parsedElements);\n    this.tempfix_untilopennewtabisdone(parsedElements, isMetamodel);\n    console.log('parsedElem', parsedElements);\n    return parsedElements;\n  }\n  static fixObjectPointers(parsedElements) {\n    let dobjects = parsedElements.filter(e => e.className === DObject.name);\n    let values = parsedElements.filter(e => e.className === DValue.name);\n    let lobjects = LPointerTargetable.fromArr(dobjects);\n    let m1pointermap = {}; //    \"//@rootrefname.index@/refname.index/@....etc\"\n    for (let o of lobjects) {\n      m1pointermap[o.ecorePointer()] = o;\n    }\n    for (let v of values) {\n      if (v.isMirage) continue;\n      let modified = false;\n      let newvalues = v.value.map(e => {\n        if (!m1pointermap[e]) return e;\n        modified = true;\n        console.log(\"m1 pointer resolved:\", {\n          from: e,\n          to: m1pointermap[e].id\n        });\n        return m1pointermap[e].id;\n      });\n      if (!modified) continue;\n      let lv = LPointerTargetable.from(v);\n      lv.value = newvalues;\n    }\n  }\n  static tempfix_untilopennewtabisdone(parsedElements, isMetamodel) {\n    // replaces current model with parsed model. this needs to be removed to open a new tab later on.\n    let model = null;\n    for (let elem of parsedElements) {\n      if (elem.className === DModel.name) {\n        model = elem;\n        break;\n      }\n    }\n    SetRootFieldAction.new(isMetamodel ? \"m2models\" : \"m1models\", model.id, '+=', false); // it is pointer but no need to update pointedby's this time\n  }\n\n  // resolve eCore pointers to Jodel pointers and set the PointedBy\n  static LinkAllNamesToIDs(parsedElements) {\n    // todo: Ã¨ post-parse che legga i nomi e assegni gli id aggiustando le references e extends settati by name. trova i campi temporanei cercando i @ts-ignore\n    // update mref, attribute, parameter type\n    // update operation exception\n    // replace those names with id's\n\n    let idMap = {};\n    let nameMap = {};\n    let replacePrimitiveMap = {};\n    let d_Estring = Selectors.getAllPrimitiveTypes()[0];\n    replacePrimitiveMap[AttribETypes.EString] = d_Estring;\n    // todo: do the same for all other primitives\n\n    // let longprefixlength = 'ecore:EDataType http://www.eclipse.org/emf/2002/Ecore'.length;\n    const typeprefix = \"#//\";\n    for (let shortkey in AttribETypes) {\n      let longkey = AttribETypes[shortkey];\n      // fallback for missing type instead of crash\n      if (!replacePrimitiveMap[longkey]) replacePrimitiveMap[longkey] = d_Estring;\n\n      // allow shortcuts to work too\n      replacePrimitiveMap[typeprefix + shortkey] = replacePrimitiveMap[longkey];\n    }\n    for (let ecorename in replacePrimitiveMap) {\n      idMap[replacePrimitiveMap[ecorename].id] = replacePrimitiveMap[ecorename];\n    }\n    let prereplace = name => name.replaceAll(\"#//\", \"\"); // todo: if\n    let replaceRules = [\"extends\", /*\"extendedBy\",*/\"exceptions\", \"type\"];\n    let dobj;\n    for (dobj of parsedElements) {\n      if (dobj.name) {\n        nameMap[dobj.name] = dobj;\n        nameMap[typeprefix + dobj.name] = dobj;\n      }\n      idMap[dobj.id] = dobj;\n    }\n    for (let replacekey of replaceRules) {\n      for (dobj of parsedElements) {\n        let valtmp = dobj[replacekey];\n        if (valtmp === undefined) continue; // for missing properties in a d-object like looking for extends on a dmodel.\n        let values;\n        let isArray = Array.isArray(valtmp);\n        if (isArray) {\n          values = valtmp;\n          dobj[replacekey] = [];\n        } else {\n          values = [valtmp];\n        }\n        for (let value of values) {\n          if (!value) continue;\n          // console.log(\"fixalltypes\", {replacekey, dobj, value, values});\n          const isType = value.indexOf(\"#//\") == 0;\n          let target = replacePrimitiveMap[value];\n          if (!target) target = nameMap[value];\n          // if (Pointers.isPointer(value)) { target = value;  if it happen to be a pointer it's a mistake in parser }\n\n          if (isType) {\n            console.log(\"attempt to replace primitive type to his id\", {\n              target,\n              dobj,\n              replacekey,\n              value,\n              replacePrimitiveMap,\n              nameMap,\n              idMap,\n              parsedElements\n            });\n          }\n          if (replacekey === \"extends\") {\n            if (!target) continue;\n            Log.ex(target.className !== DClass.name, \"found a class attempting to extend an object that is not a class\", {\n              target,\n              dobj,\n              replacePrimitiveMap,\n              nameMap,\n              idMap\n            });\n            target.extendedBy.push(dobj.id);\n          }\n          Log.ex(!target, \"LinkAllNames() can't find type target:\", {\n            value,\n            nameMap,\n            replacePrimitiveMap,\n            dobj,\n            replacekey\n          });\n          if (isArray) dobj[replacekey].push(target.id);else dobj[replacekey] = target.id;\n        }\n      }\n    }\n    let idlookup = store.getState().idlookup;\n    for (let ptrkey of PointedBy.list) for (dobj of parsedElements) {\n      let valtmp = dobj[ptrkey];\n      let values;\n      if (Array.isArray(valtmp)) {\n        values = valtmp;\n      } else {\n        if (valtmp === undefined) values = [];\n        // if (valtmp === \"modeltmp\") { dobj[ptrkey] = null; values = []; } // because model.father is null, but i want to error check others and let them crash if missing father\n        else values = [valtmp];\n      }\n      console.log(\"fixalltypes[]\", {\n        ptrkey,\n        valtmp,\n        dobj,\n        values\n      });\n      for (let value of values) {\n        if (!value) continue;\n        // errore: per operazione.type l'import mi restituisce puntatore a oggetto stringa, ma non Ã¨ tra gli oggetti parsed\n        let target = idMap[value];\n        if (target) {\n          target.pointedBy.push(PointedBy.new(\"idlookup.\" + dobj.id + \".\" + ptrkey));\n        } else {\n          target = idlookup[value];\n          console.log(\"fixalltypes\", {\n            ptrkey,\n            valtmp,\n            dobj,\n            value,\n            values,\n            target,\n            idMap\n          });\n          if (!target) throw new Error(\"target undefined\");\n          SetFieldAction.new(target, \"pointedBy\", PointedBy.new(\"idlookup.\" + dobj.id + \".\" + ptrkey), '+=', false);\n        }\n      }\n    }\n    // update superclasses\n    this.updateSuperClasses(parsedElements);\n  }\n  static todoGetPrimitiveTypenope(type) {\n    // akready fixed in LinkAllNamesToID\n    return 'todoGetPrimitiveType from parser';\n  }\n  static updateSuperClasses(parsedElements) {\n    // todo:3\n  }\n  static fixNamingConflicts(parsedElements) {\n    // todo:4 final\n  }\n  static parseM2Model(json, filename) {\n    let generated = [];\n    if (!json) {\n      json = {};\n    }\n    let modelname = json[ECoreNamed.namee];\n    if (!modelname && filename) {\n      let pos = filename.indexOf(\".\");\n      modelname = pos === -1 ? filename : filename.substring(0, pos);\n    }\n    let dObject = DModel.new(modelname || \"imported_metamodel_1\", undefined, true, true);\n    console.log(\"made model\", json);\n    generated.push(dObject); // dObject.father = 'modeltmp' as any;\n    /// *** specific  *** ///\n    const childrens = EcoreParser.getChildrens(json);\n    const annotations = EcoreParser.getAnnotations(json);\n    // dObject.name = json[ECoreNamed.namee] as string || \"imported_metamodel_1\";\n    console.log(\"made model 2\", childrens, annotations);\n    for (let child of annotations) {\n      EcoreParser.parseDAnnotation(dObject, child, generated);\n    }\n    console.log(\"made annotations\");\n    for (let child of childrens) {\n      EcoreParser.parseDPackage(dObject, child, generated);\n    }\n    console.log(\"made packages\");\n    return generated;\n  }\n  static parseM1Model(json, meta, filename) {\n    var _meta;\n    let generated = [];\n    if (!json) {\n      json = {};\n    }\n    /// *** specific  *** ///\n    // this.parseDObject(json, dObject, DModel,undefined, generated);\n    let allmodels;\n    if (!meta && filename) {\n      allmodels = Selectors.getAll(DModel);\n      allmodels = allmodels.filter(m => m.name === filename);\n      meta = LPointerTargetable.fromD(allmodels[0]);\n    } else allmodels = [];\n    let xmlns = EcoreParser.XMLinlineMarker + \"xmlns:\";\n    let ns = undefined;\n    function findns(key) {\n      let pos = key.indexOf(\":\");\n      if (pos <= 0) return false;\n      return ns = key.substring(0, pos); // through namespace before the name of the root objects;\n      // additional method: through xmlns key\n      // if (key.indexOf(xmlns)) continue; // \"-xmlns:org.eclipse.example.modelname\": \"https://org/eclipse/example/modelname\",\n      // ns = key.substring(xmlns.length); break;\n    }\n    outerloop: for (let key0 in json) {\n      // ns can be at most in sublevel 3, this is annoying but i need it at beginning of parsing\n      if (findns(key0)) break;\n      let val0 = json[key0];\n      if (typeof val0 === \"object\") for (let key1 in val0) {\n        if (findns(key0)) break outerloop;\n      }\n    }\n    if (ns && !meta) {\n      var _matchpkg$;\n      let allpkgs = Selectors.getAll(DPackage, undefined, undefined, true, true);\n      let matchpkg = allpkgs.filter(d => d.uri === ns);\n      meta = (_matchpkg$ = matchpkg[0]) === null || _matchpkg$ === void 0 ? void 0 : _matchpkg$.model;\n      // Log.exDev(!meta, \"metamodel not found: \", {ns, json, filename, allmodels, allpkgs, matchpkg}) // todo: after tests remove this check and allow shapeless models.\n    }\n    let modelname = '';\n    if (!modelname && filename) {\n      let pos = filename.indexOf(\".\");\n      modelname = pos === -1 ? filename : filename.substring(0, pos);\n    }\n    let dObject = DModel.new(modelname || \"imported_model_1\", (_meta = meta) === null || _meta === void 0 ? void 0 : _meta.id, false, true);\n    console.log(\"made model\", json);\n    generated.push(dObject);\n    for (let key in json) {\n      switch (key) {\n        case ECoreObject.xmi_version:\n          // this is only on roots\n          Log.ex(json[key] !== \"2.0\", \"The only supported ecore version is \\\"2.0\\\", found instead: \\\"\" + json[key] + \"\\\"\");\n          break;\n        // case ECoreObject.xmlnsecore:\n        case ECoreObject.xmlns_xmi:\n          let expected = \"http://www.omg.org/XMI\";\n          Log.ex(json[key] !== expected, \"Unexpected XMI schema. Should be \\\"\" + expected + \"\\\", found instead: \\\"\" + json[key] + \"\\\"\");\n          break;\n        default:\n          // a feature name\n          let val = json[key];\n          if (!val) continue;\n          if (key.indexOf(xmlns) === 0) continue; // \"-xmlns:org.eclipse.example.modelname\": \"https://org/eclipse/example/modelname\",\n          if (key[0] === EcoreParser.XMLinlineMarker) key = key.substring(EcoreParser.XMLinlineMarker.length);\n          const namespacedclass = key;\n          const mmclass = meta && meta.getClassByNameSpace(namespacedclass);\n          if (!mmclass) console.log(\"failed to get mmclass\", {\n            meta,\n            key,\n            mmclass\n          });\n          const roots_for_this_metaclass = Array.isArray(val) ? val : [val]; // there might be N roots of class A, M of type B...\n          for (let rootjson of roots_for_this_metaclass) {\n            // DObject.new(mmclass.id, dObject.id, DModel, undefined, true)\n            EcoreParser.parseDObject(rootjson, dObject, DModel, mmclass, generated);\n          }\n      }\n    }\n    return generated;\n  }\n  /*\r\n  {\r\n    \"org.eclipse.example.bowling:League\": { <-- :classroot\r\n      \"-xmlns:xmi\": \"http://www.omg.org/XMI\",\r\n      \"-xmlns:org.eclipse.example.bowling\": \"https://org/eclipse/example/bowling\",\r\n      \"-xmi:version\": \"2.0\",\r\n      \"Players\": [\r\n        { \"-name\": \"tizio\" },\r\n        { \"-name\": \"asd\" }\r\n      ]\r\n    }\r\n  }\r\n  */\n\n  /// In Ecore parsing when you find a value list, it is possible to recover only the type for the meta-feature,<br>\n  /// but an array of Mammals might have some Whales, Pigs, etc mixed in. and you have to get the correct subclass for each\n  static getobjectmetaclass(json, metaSuperClass) {\n    return metaSuperClass; // todo: comment this and execute below\n    let subclasses = !metaSuperClass ? [] : []; // meta.metaSuperClass todo, enable this case\n    let subclasseshapes = {};\n    for (let sc of subclasses) {\n      subclasseshapes[sc.id] = {\n        l: sc\n      };\n      let row = subclasseshapes[sc.id];\n      for (let feat of sc.childrens) {\n        let lfeat = feat;\n        let dfeat = lfeat.__raw;\n        if (!dfeat.name || !dfeat.type) continue;\n        row[dfeat.name] = lfeat.type;\n      }\n    }\n    return this.findBestMatch(subclasseshapes, json);\n  }\n  static findBestMatch(m2classes, json) {\n    throw new Error(\"todo\");\n    return null;\n  }\n  static parseDObject(json, parent, parentType, meta, generated) {\n    var _meta2, _meta3;\n    if (!json) {\n      json = {};\n    }\n    meta = meta && this.getobjectmetaclass(json, meta);\n    // let dObject: DObject = DObject.new(meta?.id, parent.id, parentType, json[\"name\"] as string || \"obj_1\");\n    // let data: Partial<DObject> = {};\n    let dObject = DObject.new((_meta2 = meta) === null || _meta2 === void 0 ? void 0 : _meta2.id, parent.id, parentType, json[\"name\"] || \"obj_1\");\n    generated.push(dObject);\n    dObject.father = parent.id;\n    if (parent) {\n      if (parentType === DModel) parent.objects.push(dObject.id);else parent.value.push(dObject.id);\n    }\n    console.log(\"made dobject\", {\n      json,\n      dObject,\n      meta,\n      metaname: (_meta3 = meta) === null || _meta3 === void 0 ? void 0 : _meta3.name\n    });\n    /// *** specific  *** ///\n    for (let key in json) {\n      switch (key) {\n        case ECoreObject.xmi_version:\n          // this is only on roots\n          Log.ex(json[key] !== \"2.0\", \"The only supported ecore version is \\\"2.0\\\", found instead: \\\"\" + json[key] + \"\\\"\");\n          break;\n        // case ECoreObject.xmlnsecore:\n        case ECoreObject.xmlns_xmi:\n          let expected = \"http://www.omg.org/XMI\";\n          Log.ex(json[key] !== expected, \"Unexpected XMI schema. Should be \\\"\" + expected + \"\\\", found instead: \\\"\" + json[key] + \"\\\"\");\n          break;\n        default:\n          // a feature name\n          let val = json[key];\n          if (!val) continue;\n          if (key[0] === EcoreParser.XMLinlineMarker) key = key.substring(1);\n          if (key.indexOf(\"xmlns:\") === 0) continue; // \"-xmlns:org.eclipse.example.modelname\": \"https://org/eclipse/example/modelname\",\n          let metafeature = meta && meta[\"@\" + key];\n          console.log(\"feature meta\", {\n            json,\n            dObject,\n            key,\n            val,\n            metafeature,\n            classmeta: meta\n          });\n          const values = Array.isArray(val) ? val : [val];\n          EcoreParser.parseDValue(key, values, dObject /*father*/, metafeature /*meta*/, generated);\n        // DValue.new(key, metafeature?.id, values, dObject, true, false);\n      }\n    }\n    return generated;\n  }\n  static parseDValue(name, jsonvalues, parent, meta, generated) {\n    if (!jsonvalues) {\n      jsonvalues = [];\n    }\n    // let dObject: DObject = DObject.new(meta?.id, parent.id, parentType, json[\"name\"] as string || \"obj_1\");\n    console.log(\"DValue.new(meta ? undefined : name, meta?.id, jsonvalues, parent.id, true, false)\");\n    console.log(\"DValue.new(\", meta ? undefined : name, \",\", meta === null || meta === void 0 ? void 0 : meta.id, \",\", jsonvalues, \",\", parent.id);\n    let dValue = DValue.new(meta ? undefined : name, meta === null || meta === void 0 ? void 0 : meta.id, [], parent.id, true, false);\n    generated.push(dValue);\n    dValue.father = parent.id;\n    parent.features.push(dValue.id);\n    console.log(\"made dValue\", {\n      jsonvalues,\n      dValue,\n      meta,\n      metaname: meta === null || meta === void 0 ? void 0 : meta.name\n    });\n    if (meta && meta.className === DAttribute.name) {\n      dValue.value = jsonvalues;\n      return generated;\n    }\n    for (let v of jsonvalues) {\n      if (typeof v !== \"object\") {\n        dValue.value.push(v);\n        continue;\n      }\n      // let subdObject: DObject = DObject.new((meta as LReference)?.type.id, parent.id, DValue, undefined);\n      // generated.push(subdObject);\n      EcoreParser.parseDObject(v, dValue, DValue, meta === null || meta === void 0 ? void 0 : meta.type, generated);\n    }\n    return generated;\n  }\n  static parseDAnnotation(parent, json, generated) {\n    if (!generated) generated = [];\n    if (!json) {\n      json = {};\n    }\n    let dObject = DAnnotation.new();\n    generated.push(dObject);\n    dObject.father = parent.id;\n    dObject.father = parent.id;\n    if (parent) parent.annotations.push(dObject.id);\n\n    /// *** specific  *** ///\n    let key;\n    for (key in json) {\n      const value = json[key];\n      switch (key) {\n        default:\n          Log.exx('unexpected field in EAnnotation:  ' + key + ' => |' + value + '|');\n          break;\n        case ECoreAnnotation.details:\n          break;\n        case ECoreAnnotation.references:\n          break;\n        case ECoreAnnotation.source:\n          break;\n      }\n    }\n    // annotation.referencesStr = this.read(json, ECoreAnnotation.source, '#/');\n    // annotation.name = this.read(json, ECoreAnnotation.name, 'EAnnotation_1');\n    // const details: Json[] = this.getDetails(json);\n    // for (let i = 0; i < details.length; i++) { new EAnnotationDetail(this, details[i]); }\n    return generated;\n  }\n  static parseDPackage(parent, json, generated) {\n    if (!generated) generated = [];\n    if (!json) {\n      json = {};\n    }\n    const childs = this.getChildrens(json);\n    console.warn(\"parseDPackage.childrens\", childs, generated);\n    let dObject = DPackage.new();\n    generated.push(dObject);\n    dObject.father = parent.id;\n    if (parent) parent.packages.push(dObject.id);\n    let version = json[EcoreParser.prefix + \"xmlns:ecore\"] || '';\n    // model.xmi = json[EcoreParser.prefix+\"xmlns:xmi\"]; // http://www.omg.org/XMI\n    // model.xsi = json[EcoreParser.prefix+\"xmlns:xsi\"]; // http://www.w3.org/2001/XMLSchema-instance\n\n    console.log(json);\n    Log.ex(!EcoreParser.supportedEcoreVersions.includes(version), \"unsupported ecore version, must be one of:\" + EcoreParser.supportedEcoreVersions + \" found instead: \" + version);\n    dObject.name = this.read(json, ECoreNamed.namee, 'defaultPackage');\n    /// *** specific start *** ///\n    dObject.uri = this.read(json, ECorePackage.nsURI, null);\n    dObject.prefix = this.read(json, ECorePackage.nsPrefix, null);\n    // if (!parent.uri) parent.uri = dObject.uri;\n    // if (!parent.prefix) parent.prefix = dObject.prefix; // namespace\n    for (let child of childs) {\n      switch (child[ECoreClass.xsitype]) {\n        default:\n          Log.exx('unexpected xsitype:', child[ECoreClass.xsitype], ' found in jsonfragment:', child, ', in json:', json, ' package:', dObject);\n          break;\n        case 'ecore:EClass':\n          this.parseDClass(dObject, child, generated);\n          break;\n        case 'ecore:EEnum':\n          this.parseDEnum(dObject, child, generated);\n          break;\n      }\n    }\n    /// *** specific end *** ///\n    return generated;\n  }\n  static parseDClass(parent, json, generated) {\n    if (!generated) generated = [];\n    if (!json) {\n      json = {};\n    }\n    let dObject = DClass.new();\n    generated.push(dObject);\n    dObject.father = parent.id;\n    if (parent) parent.classifiers.push(dObject.id);\n    dObject.name = this.read(json, ECoreNamed.namee, 'Class_1');\n    /// *** specific start *** ///\n    for (let key in json) {\n      switch (key) {\n        default:\n          Log.exx('unexpected field in parseDClass() |' + key + '|', json);\n          break;\n        case ECoreClass.instanceTypeName:\n        case ECoreClass.eSuperTypes:\n        case ECoreClass.xsitype:\n        case ECoreClass.eOperations:\n        case ECoreClass.eStructuralFeatures:\n        case ECoreClass.abstract:\n        case ECoreClass.interface:\n        case ECoreClass.namee:\n          break;\n      }\n    }\n    dObject.instanceClassName = this.read(json, ECoreClass.instanceTypeName, '');\n    dObject.interface = this.read(json, ECoreClass.interface, 'false') === 'true';\n    dObject.abstract = this.read(json, ECoreClass.abstract, 'false') === 'true';\n    let tmps = this.read(json, ECoreClass.eSuperTypes, '');\n    dObject.extends = tmps.split(' ');\n    const features = this.getChildrens(json);\n    const functions = this.getChildrens(json, false, true);\n    for (let child of functions) {\n      this.parseDOperation(dObject, json, generated);\n    }\n    for (let child of features) {\n      const xsiType = this.read(child, ECoreAttribute.xsitype);\n      switch (xsiType) {\n        default:\n          Log.exx('unexpected xsi:type: ', xsiType, ' in feature:', child);\n          break;\n        case 'ecore:EAttribute':\n          this.parseDAttribute(dObject, child, generated);\n          break;\n        case 'ecore:EReference':\n          this.parseDReference(dObject, child, generated);\n          break;\n      }\n    }\n    /// *** specific end *** ///\n    return generated;\n  }\n  static parseDEnum(parent, json, generated) {\n    if (!generated) generated = [];\n    if (!json) {\n      json = {};\n    }\n    const childs = this.getChildrens(json);\n    let dObject = DEnumerator.new();\n    generated.push(dObject);\n    dObject.father = parent.id;\n    if (parent) parent.classifiers.push(dObject.id);\n    dObject.name = this.read(json, ECoreNamed.namee, 'Enum_1');\n    /// *** specific start *** ///\n    for (let key in json) {\n      const value = json[key];\n      switch (key) {\n        default:\n          Log.exx('Enum.parse() unexpected key:', key, 'in json:', json);\n          break;\n        case ECoreEnum.xsitype:\n        case ECoreNamed.namee:\n          break;\n        case ECoreEnum.eLiterals:\n          break;\n        case ECoreEnum.serializable:\n          dObject.serializable = value === 'true';\n          break;\n        case ECoreEnum.instanceTypeName:\n          dObject.instanceClassName = value + '';\n          break;\n      }\n    }\n    for (let child of childs) {\n      this.parseDEnumLiteral(dObject, child, generated);\n    }\n\n    /// *** specific end *** ///\n    return generated;\n  }\n  static parseDEnumLiteral(parent, json, generated) {\n    if (!generated) generated = [];\n    if (!json) {\n      json = {};\n    }\n    const childs = this.getChildrens(json);\n    let dObject = DEnumLiteral.new();\n    generated.push(dObject);\n    dObject.father = parent.id;\n    if (parent) parent.literals.push(dObject.id);\n    /// *** specific start *** ///\n    dObject.ordinal = +this.read(json, EcoreLiteral.value, Number.NEGATIVE_INFINITY);\n    dObject.literal = this.read(json, EcoreLiteral.literal, '');\n    dObject.name = this.read(json, ECoreNamed.namee, dObject.literal || 'literal_1');\n    /// *** specific end *** ///\n    return generated;\n  }\n  static parseDAttribute(parent, json, generated) {\n    if (!generated) generated = [];\n    if (!json) {\n      json = {};\n    }\n    const childs = this.getChildrens(json);\n    let dObject = DAttribute.new();\n    generated.push(dObject);\n    dObject.father = parent.id;\n    if (parent) parent.attributes.push(dObject.id);\n    dObject.name = this.read(json, ECoreNamed.namee, 'attr_1');\n    /// *** specific start *** ///\n    dObject.lowerBound = +this.read(json, ECoreAttribute.lowerbound, 0);\n    dObject.upperBound = +this.read(json, ECoreAttribute.upperbound, 1);\n    dObject.type = this.read(json, ECoreAttribute.eType, AttribETypes.EString);\n    /// *** specific end *** ///\n    return generated;\n  }\n  static parseDReference(parent, json, generated) {\n    if (!generated) generated = [];\n    if (!json) {\n      json = {};\n    }\n    const childs = this.getChildrens(json);\n    let dObject = DReference.new();\n    generated.push(dObject);\n    dObject.father = parent.id;\n    if (parent) parent.references.push(dObject.id);\n    dObject.name = this.read(json, ECorePackage.namee, 'Ref_1');\n    /// *** specific start *** ///\n    dObject.containment = U.fromBoolString(this.read(json, ECoreReference.containment, false), false);\n    dObject.lowerBound = +this.read(json, ECoreAttribute.lowerbound, 0);\n    dObject.upperBound = +this.read(json, ECoreAttribute.upperbound, 1);\n    dObject.type = this.read(json, ECoreReference.eType, this.getEcoreTypeName(parent));\n    console.log(\"attempting to parse dref\", {\n      dObject,\n      json,\n      parent,\n      typekey: ECoreReference.eType\n    });\n\n    /// *** specific end *** ///\n    return generated;\n  }\n  static parseDParameter(parent, json, generated) {\n    if (!generated) generated = [];\n    if (!json) {\n      json = {};\n    }\n    const childs = this.getChildrens(json);\n    let dObject = DParameter.new();\n    generated.push(dObject);\n    dObject.father = parent.id;\n    if (parent) parent.parameters.push(dObject.id);\n    dObject.name = this.read(json, ECoreNamed.namee, 'arg1');\n    /// *** specific start *** ///\n    dObject.lowerBound = +this.read(json, ECoreAttribute.lowerbound, 0);\n    dObject.upperBound = +this.read(json, ECoreAttribute.upperbound, 1);\n    dObject.type = this.read(json, ECoreAttribute.eType, AttribETypes.EString);\n    dObject.ordered = U.fromBoolString(this.read(json, ECoreOperation.ordered, 'false'), false);\n    dObject.unique = U.fromBoolString(this.read(json, ECoreOperation.unique, 'false'), false);\n    /// *** specific end *** ///\n    return generated;\n  }\n  static parseDOperation(parent, json, generated) {\n    if (!generated) generated = [];\n    if (!json) {\n      json = {};\n    }\n    const childs = this.getChildrens(json);\n    let dObject = DOperation.new();\n    generated.push(dObject);\n    dObject.father = parent.id;\n    if (parent) parent.operations.push(dObject.id);\n    dObject.name = this.read(json, ECoreNamed.namee, 'operation_1');\n    /// *** specific start *** ///\n    dObject.lowerBound = +this.read(json, ECoreAttribute.lowerbound, 1);\n    dObject.upperBound = +this.read(json, ECoreAttribute.upperbound, 1);\n    dObject.type = this.read(json, ECoreAttribute.eType, AttribETypes.EString);\n    dObject.exceptions = [this.read(json, ECoreOperation.eexceptions, '')];\n    dObject.ordered = U.fromBoolString(this.read(json, ECoreOperation.ordered, 'false'));\n    dObject.unique = U.fromBoolString(this.read(json, ECoreOperation.unique, 'false'));\n    dObject.visibility = AccessModifier.package;\n    for (let child of childs) {\n      this.parseDParameter(dObject, json, generated);\n    }\n    /// *** specific end *** ///\n    return generated;\n  }\n\n  /*\r\n  static parseTEMPLATE(parent: DSomething, json: Json, generated: DModelElement[]): DModelElement[] {\r\n      if (!generated) generated = [];\r\n      if (!json) { json = {}; }\r\n      const childs = this.getChildrens(json);\r\n      let dObject: DSomething = DSomething.new();\r\n      generated.push(dObject); dObject.father = parent.id;\r\n      if (parent) parent.CHILDCOLLECTION.push(dObject.id);\r\n      dObject.name = this.read(json, ECoreNamed.namee, defaultNameTODO);\r\n      /// *** specific start *** ///\r\n      for (let child of childs) {\r\n          this.parseDSOMETHING(dObject, json, generated);\r\n      }\r\n      /// *** specific end *** ///\r\n      return generated; }*/\n\n  /////////////////////////////////// generic\n\n  static getAnnotations(thiss) {\n    const ret = thiss[ECorePackage.eAnnotations];\n    if (!ret || $.isEmptyObject(ret)) {\n      return [];\n    }\n    if (Array.isArray(ret)) {\n      return ret;\n    } else {\n      return [ret];\n    }\n  }\n  static getDetails(thiss) {\n    const ret = thiss[ECoreAnnotation.details];\n    if (!ret || $.isEmptyObject(ret)) {\n      return [];\n    }\n    if (Array.isArray(ret)) {\n      return ret;\n    } else {\n      return [ret];\n    }\n  }\n  static getChildrens(thiss) {\n    let throwError = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    let functions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    if (!thiss && !throwError) {\n      return [];\n    }\n    const mod = thiss[ECoreRoot.ecoreEPackage];\n    const pkg = thiss[ECorePackage.eClassifiers];\n    const cla = thiss[functions ? ECoreClass.eOperations : ECoreClass.eStructuralFeatures];\n    const fun = thiss[ECoreOperation.eParameters];\n    const lit = thiss[ECoreEnum.eLiterals];\n    const ret = mod || pkg || cla || fun || lit;\n    /*if ( ret === undefined || ret === null ) {\r\n      if (thiss['@name'] !== undefined) { ret = thiss; } // if it's the root with only 1 child arrayless\r\n    }*/\n    Log.ex(throwError && !ret, 'getChildrens() Failed: ', thiss, ret);\n    // console.log('ret = ', ret, ' === ', {}, ' ? ', ($.isEmptyObject(ret) ? [] : [ret]));\n    if (!ret || $.isEmptyObject(ret)) {\n      return [];\n    }\n    if (Array.isArray(ret)) {\n      return ret;\n    } else {\n      return [ret];\n    }\n  }\n  static read(json, field) {\n    let valueIfNotFound = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'read<T>()CanThrowError';\n    let ret = json ? json[field] : null;\n    if (ret !== null && ret !== undefined && field.indexOf(this.XMLinlineMarker) !== -1) {\n      Log.ex(U.isObject(ret, false, false, true), 'inline value |' + field + '| must be primitive.', ret);\n      ret = U.multiReplaceAll('' + ret, ['&amp;', '&#38;', '&quot;'], ['&', '\\'', '\"']);\n    }\n    if (ret === null || ret === undefined) {\n      Log.ex(valueIfNotFound === 'read<T>()CanThrowError', 'this.read<', '> failed: field[' + field + '], json: ', json);\n      return valueIfNotFound;\n    }\n    return ret;\n  }\n  static write(json, field, val) {\n    if (val !== null && field.indexOf(EcoreParser.XMLinlineMarker) !== -1) {\n      Log.ex(val !== '' + val, 'inline value |' + field + '| must be a string.', val);\n      val = U.multiReplaceAll(val, ['&', '\\'', '\"'], ['&amp;', '&#38;', '&quot;']);\n    } else Log.ex(val !== '' + val || !U.isObject(val, true), 'primitive values should be inserted only inline in the xml:', field, val);\n    json[field] = val;\n    return val;\n  }\n  static getEcoreTypeName(parent) {\n    if (parent.className === DEnumerator.name || parent.className === DClass.name) return this.classTypePrefix + this.name;\n    // return Type.classTypePrefix + parent.parent.name; problem: need L-object to navigate\n    return Log.ex(\"getEcoreTypeName failed\", parent);\n  }\n}\nEcoreParser.supportedEcoreVersions = [\"http://www.eclipse.org/emf/2002/Ecore\"];\nEcoreParser.prefix = '@';\nEcoreParser.XMLinlineMarker = '@';\nEcoreParser.classTypePrefix = '#//';\nexport let AccessModifier;\n(function (AccessModifier) {\n  AccessModifier[\"public\"] = \"public\";\n  AccessModifier[\"private\"] = \"private\";\n  AccessModifier[\"protected\"] = \"protected\";\n  AccessModifier[\"internal\"] = \"internal\";\n  AccessModifier[\"package\"] = \"package\";\n  AccessModifier[\"protectedinternal\"] = \"protected internal\";\n  AccessModifier[\"protectedprivate\"] = \"protected private\";\n})(AccessModifier || (AccessModifier = {}));\nexport class ECoreRoot {}\nECoreRoot.ecoreEPackage = void 0;\nexport class ECoreAnnotation {}\nECoreAnnotation.source = void 0;\nECoreAnnotation.references = void 0;\nECoreAnnotation.details = void 0;\nexport class ECoreNamed {}\nECoreNamed.namee = void 0;\nexport class ECoreDetail {}\nECoreDetail.key = void 0;\nECoreDetail.value = void 0;\nexport class ECorePackage {}\nECorePackage.eAnnotations = void 0;\nECorePackage.eClassifiers = void 0;\nECorePackage.xmlnsxmi = void 0;\nECorePackage.xmlnsxsi = void 0;\nECorePackage.xmiversion = void 0;\nECorePackage.xmlnsecore = void 0;\nECorePackage.nsURI = void 0;\nECorePackage.nsPrefix = void 0;\nECorePackage.namee = void 0;\nexport class ECoreClass {}\nECoreClass.eAnnotations = void 0;\nECoreClass.eStructuralFeatures = void 0;\nECoreClass.xsitype = void 0;\nECoreClass.namee = void 0;\nECoreClass.eOperations = void 0;\nECoreClass.instanceTypeName = void 0;\nECoreClass.eSuperTypes = void 0;\nECoreClass.abstract = void 0;\nECoreClass.interface = void 0;\nexport class ECoreEnum {}\nECoreEnum.eAnnotations = void 0;\nECoreEnum.xsitype = void 0;\nECoreEnum.namee = void 0;\nECoreEnum.instanceTypeName = void 0;\nECoreEnum.serializable = void 0;\nECoreEnum.eLiterals = void 0;\nexport class EcoreLiteral {}\nEcoreLiteral.eAnnotations = void 0;\nEcoreLiteral.namee = void 0;\nEcoreLiteral.value = void 0;\nEcoreLiteral.literal = void 0;\nexport class ECoreReference {}\nECoreReference.eAnnotations = void 0;\nECoreReference.xsitype = void 0;\nECoreReference.eType = void 0;\nECoreReference.containment = void 0;\nECoreReference.upperbound = void 0;\nECoreReference.lowerbound = void 0;\nECoreReference.namee = void 0;\nexport class ECoreAttribute {}\nECoreAttribute.eAnnotations = void 0;\nECoreAttribute.xsitype = void 0;\nECoreAttribute.eType = void 0;\nECoreAttribute.namee = void 0;\nECoreAttribute.lowerbound = void 0;\nECoreAttribute.upperbound = void 0;\nexport class ECoreOperation {}\nECoreOperation.eAnnotations = void 0;\nECoreOperation.eType = void 0;\nECoreOperation.eexceptions = void 0;\nECoreOperation.upperBound = void 0;\nECoreOperation.lowerBound = void 0;\nECoreOperation.unique = void 0;\nECoreOperation.ordered = void 0;\nECoreOperation.namee = void 0;\nECoreOperation.eParameters = void 0;\nexport class ECoreParameter {}\nECoreParameter.eAnnotations = void 0;\nECoreParameter.namee = void 0;\nECoreParameter.ordered = void 0;\nECoreParameter.unique = void 0;\nECoreParameter.lowerBound = void 0;\nECoreParameter.upperBound = void 0;\nECoreParameter.eType = void 0;\nexport class ECoreObject {}\nECoreObject.xmlns_xmi = void 0;\nECoreObject.xmlns_uri = void 0;\nECoreObject.xmi_version = void 0;\nexport class XMIModel {}\n\n///////////////\nXMIModel.type = void 0;\nXMIModel.namee = void 0;\nECoreRoot.ecoreEPackage = 'ecore:EPackage';\nECoreNamed.namee = EcoreParser.XMLinlineMarker + 'name';\nECorePackage.eAnnotations = ECoreClass.eAnnotations = ECoreEnum.eAnnotations = EcoreLiteral.eAnnotations = ECoreReference.eAnnotations = ECoreAttribute.eAnnotations = ECoreOperation.eAnnotations = ECoreParameter.eAnnotations = 'eAnnotations';\nECoreAnnotation.source = EcoreParser.XMLinlineMarker + 'source';\nECoreAnnotation.references = EcoreParser.XMLinlineMarker + 'references'; // \"#/\" for target = package.\nECoreAnnotation.details = 'details'; // arr\nECoreDetail.key = EcoreParser.XMLinlineMarker + 'key'; // can have spaces\nECoreDetail.value = EcoreParser.XMLinlineMarker + 'value';\nECorePackage.eClassifiers = 'eClassifiers';\nECorePackage.xmlnsxmi = EcoreParser.XMLinlineMarker + 'xmlns:xmi'; // typical value: http://www.omg.org/XMI\nECorePackage.xmlnsxsi = EcoreParser.XMLinlineMarker + 'xmlns:xsi'; // typical value: http://www.w3.org/2001/XMLSchema-instance\nECorePackage.xmiversion = EcoreParser.XMLinlineMarker + 'xmi:version'; // typical value: \"2.0\"\nECorePackage.xmlnsecore = EcoreParser.XMLinlineMarker + 'xmlns:ecore';\nECorePackage.nsURI = EcoreParser.XMLinlineMarker + 'nsURI'; // typical value: \"http://org/eclipse/example/modelname\"\nECorePackage.nsPrefix = EcoreParser.XMLinlineMarker + 'nsPrefix'; // typical value: org.eclipse.example.modelname\nECorePackage.namee = EcoreParser.XMLinlineMarker + 'name';\nECoreClass.eStructuralFeatures = 'eStructuralFeatures';\nECoreClass.eOperations = 'eOperations';\nECoreClass.xsitype = EcoreParser.XMLinlineMarker + 'xsi:type'; // \"ecore:EClass\"\nECoreClass.namee = ECorePackage.namee;\nECoreClass.eSuperTypes = EcoreParser.XMLinlineMarker + 'eSuperTypes'; // space separated: \"#name1 #name2\"...\nECoreClass.instanceTypeName = EcoreParser.XMLinlineMarker + 'instanceTypeName'; // raw str\nECoreClass.instanceTypeName = EcoreParser.XMLinlineMarker + 'instanceTypeName';\nECoreClass.abstract = EcoreParser.XMLinlineMarker + 'abstract'; // bool\nECoreClass.interface = EcoreParser.XMLinlineMarker + 'interface'; // bool\n\nECoreEnum.instanceTypeName = ECoreClass.instanceTypeName;\nECoreEnum.serializable = 'serializable'; // \"false\", \"true\"\nECoreEnum.xsitype = ECoreClass.xsitype; // \"ecore:EEnum\"\nECoreEnum.eLiterals = 'eLiterals';\nECoreEnum.namee = ECorePackage.namee;\nEcoreLiteral.literal = 'literal';\nEcoreLiteral.namee = ECorePackage.namee;\nEcoreLiteral.value = 'value'; // any integer (-inf, +inf), not null. limiti = a type int 32 bit?\n\nECoreReference.xsitype = EcoreParser.XMLinlineMarker + 'xsi:type'; // \"ecore:EReference\"\nECoreReference.eType = EcoreParser.XMLinlineMarker + 'eType'; // \"#//Player\"\nECoreReference.containment = EcoreParser.XMLinlineMarker + 'containment'; // \"true\"\nECoreReference.upperbound = EcoreParser.XMLinlineMarker + 'upperBound'; // \"@1\"\nECoreReference.lowerbound = EcoreParser.XMLinlineMarker + 'lowerBound'; // does even exists?\nECoreReference.namee = EcoreParser.XMLinlineMarker + 'name';\nECoreAttribute.xsitype = EcoreParser.XMLinlineMarker + 'xsi:type'; // \"ecore:EAttribute\",\nECoreAttribute.eType = EcoreParser.XMLinlineMarker + 'eType'; // \"ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EString\"\nECoreAttribute.namee = EcoreParser.XMLinlineMarker + 'name';\nECoreAttribute.lowerbound = EcoreParser.XMLinlineMarker + 'lowerBound';\nECoreAttribute.upperbound = EcoreParser.XMLinlineMarker + 'upperBound';\nECoreOperation.eParameters = 'eParameters';\nECoreOperation.namee = EcoreParser.XMLinlineMarker + 'name'; // \"EExceptionNameCustom\",\nECoreOperation.ordered = EcoreParser.XMLinlineMarker + 'ordered'; // \"false\",\nECoreOperation.unique = EcoreParser.XMLinlineMarker + 'unique'; // \"false\",\nECoreOperation.lowerBound = EcoreParser.XMLinlineMarker + 'lowerBound'; // \"5\", ma che senso ha su una funzione?? Ã¨ il return?\nECoreOperation.upperBound = EcoreParser.XMLinlineMarker + 'upperBound';\nECoreOperation.eType = EcoreParser.XMLinlineMarker + 'eType'; // \"#//Classname\",\nECoreOperation.eexceptions = EcoreParser.XMLinlineMarker + 'eExceptions';\n// \"#//ClassnameException1 #//ClassNameException2 (also custom classes) ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EInt\n\nECoreParameter.namee = EcoreParser.XMLinlineMarker + 'name';\nECoreParameter.ordered = EcoreParser.XMLinlineMarker + 'ordered'; // \"false\";\nECoreParameter.unique = EcoreParser.XMLinlineMarker + 'unique'; // \"false\"\nECoreParameter.lowerBound = EcoreParser.XMLinlineMarker + 'lowerBound'; // \"1\"\nECoreParameter.upperBound = EcoreParser.XMLinlineMarker + 'upperBound'; // \"2\"\nECoreParameter.eType = EcoreParser.XMLinlineMarker + 'eType'; // \"ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EDoubl\n\nECoreObject.xmlns_xmi = EcoreParser.XMLinlineMarker + 'xmlns:xmi'; // \"http://www.omg.org/XMI\"\n// ECoreObject.xmlns_uri = EcoreParser.XMLinlineMarker + 'xmlns:org.eclipse.example.modelname'; // \"https://org/eclipse/example/modelname\"\nECoreObject.xmi_version = EcoreParser.XMLinlineMarker + 'xmi:version'; // \"2.0\"\n\nXMIModel.type = EcoreParser.XMLinlineMarker + 'type';\nXMIModel.namee = EcoreParser.XMLinlineMarker + 'name';","map":{"version":3,"names":["Log","DModel","DValue","DObject","DEnumerator","DEnumLiteral","DAttribute","DReference","DClass","DParameter","DOperation","DPackage","DAnnotation","AttribETypes","U","CreateElementAction","Selectors","PointedBy","LPointerTargetable","windoww","SetRootFieldAction","Constructors","store","SetFieldAction","SavePack","constructor","model","arguments","length","undefined","vertexpos","view","IStorage","get","exx","prefix","autosave","del","key","isOverwrite","set","parse","serialize","val","JSON","stringify","e","deserialize","set0","get0","LocalStorage","localStorage","getItem","getLastOpened","modelNumber","modelname","ret","KeyList","lastOpenedModel","lastOpenedView","lastOpenedPosition","deleteLastOpened","setLastOpened","vertex","EcoreParser","ecorejson","isMetamodel","filename","persist","parsedjson","temp","substring","console","log","ECoreRoot","ecoreEPackage","pause","parsedElements","parseM2Model","parseM1Model","warn","LinkAllNamesToIDs","fixNamingConflicts","resume","newBatch","setTimeout","fixObjectPointers","tmpparse","wrapAll","tempfix_untilopennewtabisdone","dobjects","filter","className","name","values","lobjects","fromArr","m1pointermap","o","ecorePointer","v","isMirage","modified","newvalues","value","map","from","to","id","lv","elem","new","idMap","nameMap","replacePrimitiveMap","d_Estring","getAllPrimitiveTypes","EString","typeprefix","shortkey","longkey","ecorename","prereplace","replaceAll","replaceRules","dobj","replacekey","valtmp","isArray","Array","isType","indexOf","target","ex","extendedBy","push","idlookup","getState","ptrkey","list","pointedBy","Error","updateSuperClasses","todoGetPrimitiveTypenope","type","json","generated","ECoreNamed","namee","pos","dObject","childrens","getChildrens","annotations","getAnnotations","child","parseDAnnotation","parseDPackage","meta","_meta","allmodels","getAll","m","fromD","xmlns","XMLinlineMarker","ns","findns","outerloop","key0","val0","key1","_matchpkg$","allpkgs","matchpkg","d","uri","ECoreObject","xmi_version","xmlns_xmi","expected","namespacedclass","mmclass","getClassByNameSpace","roots_for_this_metaclass","rootjson","parseDObject","getobjectmetaclass","metaSuperClass","subclasses","subclasseshapes","sc","l","row","feat","lfeat","dfeat","__raw","findBestMatch","m2classes","parent","parentType","_meta2","_meta3","father","objects","metaname","metafeature","classmeta","parseDValue","jsonvalues","dValue","features","ECoreAnnotation","details","references","source","childs","packages","version","supportedEcoreVersions","includes","read","ECorePackage","nsURI","nsPrefix","ECoreClass","xsitype","parseDClass","parseDEnum","classifiers","instanceTypeName","eSuperTypes","eOperations","eStructuralFeatures","abstract","interface","instanceClassName","tmps","extends","split","functions","parseDOperation","xsiType","ECoreAttribute","parseDAttribute","parseDReference","ECoreEnum","eLiterals","serializable","parseDEnumLiteral","literals","ordinal","EcoreLiteral","Number","NEGATIVE_INFINITY","literal","attributes","lowerBound","lowerbound","upperBound","upperbound","eType","containment","fromBoolString","ECoreReference","getEcoreTypeName","typekey","parseDParameter","parameters","ordered","ECoreOperation","unique","operations","exceptions","eexceptions","visibility","AccessModifier","package","thiss","eAnnotations","$","isEmptyObject","getDetails","throwError","mod","pkg","eClassifiers","cla","fun","eParameters","lit","field","valueIfNotFound","isObject","multiReplaceAll","write","classTypePrefix","ECoreDetail","xmlnsxmi","xmlnsxsi","xmiversion","xmlnsecore","ECoreParameter","xmlns_uri","XMIModel"],"sources":["C:/0Programmi/Dev/projects/frontend/jjodel/src/api/data.ts"],"sourcesContent":["import {\r\n    Json,\r\n    Log,\r\n\r\n\r\n    DModelElement,\r\n    LModelElement,\r\n    DModel,\r\n    LModel,\r\n    DValue,\r\n    LValue,\r\n    DNamedElement,\r\n    LNamedElement,\r\n    DObject,\r\n    LObject,\r\n    DEnumerator,\r\n    LEnumerator,\r\n    DEnumLiteral,\r\n    LEnumLiteral,\r\n    DAttribute,\r\n    LAttribute,\r\n    DReference,\r\n    LReference,\r\n    DStructuralFeature,\r\n    LStructuralFeature,\r\n    DClassifier,\r\n    LClassifier,\r\n    DDataType,\r\n    LDataType,\r\n    DClass,\r\n    LClass,\r\n    DParameter,\r\n    LParameter,\r\n    DOperation,\r\n    LOperation,\r\n    DPackage,\r\n    LPackage,\r\n    DTypedElement,\r\n    LTypedElement,\r\n    DAnnotation,\r\n    LAnnotation,\r\n    EJavaObject,\r\n    DMap,\r\n    LMap,\r\n    DFactory_useless_,\r\n    LFactory_useless_,\r\n    AttribETypes,\r\n    U,\r\n    Pointer,\r\n    CreateElementAction,\r\n    Selectors,\r\n    GObject,\r\n    Dictionary,\r\n    PointedBy, LPointerTargetable, windoww, SetRootFieldAction, Constructors, DocString, store, SetFieldAction, Pointers\r\n\r\n} from \"../joiner\";\r\n\r\ntype RET<T = boolean> = T | Promise<T>;\r\ntype Ret = RET;\r\n\r\nclass SavePack{\r\n    model: string;\r\n    vertexpos: string;\r\n    view: string;\r\n    constructor(model: string='', vertexpos: string='', view:string='') {\r\n        this.model = model;\r\n        this.vertexpos = vertexpos;\r\n        this.view = view;\r\n    }\r\n}\r\n\r\ntype JsonSavePack = {[key in keyof SavePack]: Json | null }\r\n\r\n\r\nexport abstract class IStorage{\r\n    static get():IStorage { return Log.exx(\"IStorage.get (static) should be overridden\"); }\r\n    public prefix: string;\r\n    public autosave: boolean;\r\n    constructor(prefix: string, autosave: boolean) {\r\n        this.prefix = prefix;\r\n        this.autosave = autosave;\r\n    }\r\n\r\n\r\n    public del(key: string | number): boolean{\r\n        let isOverwrite = this.get(key) !== null;\r\n        this.set(key, '');\r\n        return isOverwrite; }\r\n    public abstract set(key: string | number, val: string | any): RET;\r\n    get<T extends boolean>(key: string | number, parse: T = false as any): T extends false ? null | string : null | any{ return Log.exx(\"IStorage.get should be overridden\"); }\r\n\r\n    protected serialize(val: any): string { // serialize\r\n        try { return JSON.stringify(val); } catch(e){ return \"\"+val; }\r\n    }\r\n    protected deserialize(val: string): any{ // de-serialize\r\n        try { return JSON.parse(val); } catch(e){ return val; }\r\n    }\r\n    protected set0(val: any): string { return this.serialize(val); }\r\n    protected get0(val: any): string { return this.deserialize(val); }\r\n    protected parse(val: any): string { return this.deserialize(val); }\r\n}\r\n\r\nexport class LocalStorage extends IStorage{\r\n    public static get():LocalStorage {return new LocalStorage(\"_j\", true); }\r\n    private constructor (prefix: string, autosave: boolean) { super(prefix, autosave); }\r\n\r\n    private static KeyList= {lastOpenedModel: \"lastOpenedModel\",lastOpenedView: \"lastOpenedView\",lastOpenedPosition: \"lastOpenedPosition\",}\r\n\r\n\r\n    get<T extends boolean>(key: string | number, parse: T = false as any): T extends false ? null | string : null | any{\r\n        let val = localStorage.getItem(this.prefix+key);\r\n        return parse ? this.parse(val) : val;\r\n    }\r\n\r\n    set(key?: string | number, val?: string | any): boolean {\r\n        val = this.serialize(val);\r\n        // let isOverwrite = localStorage.getItem(this.prefix+key);\r\n        localStorage.set(this.prefix+key, val);\r\n        return true;\r\n    }\r\n\r\n\r\n    public getLastOpened(modelNumber: 1 | 2): SavePack {\r\n        let modelname = \"m\" + modelNumber + \"_\";\r\n        const ret: SavePack = new SavePack();\r\n        ret.model = this.get(modelname + LocalStorage.KeyList.lastOpenedModel, false) || '';\r\n        ret.view = this.get(modelNumber + LocalStorage.KeyList.lastOpenedView, false) || '';\r\n        ret.vertexpos = this.get(modelNumber + LocalStorage.KeyList.lastOpenedPosition, false) || '';\r\n        return ret; }\r\n\r\n    public deleteLastOpened(modelNumber: 1 | 2): void { this.setLastOpened(modelNumber, '', '', ''); }\r\n\r\n    public setLastOpened(modelNumber: 1 | 2, model: string = '', view: string = '', vertex: string = ''): void {\r\n        let modelname = \"m\" + modelNumber + \"_\";\r\n        if (model) this.set(modelname + LocalStorage.KeyList.lastOpenedModel, model);\r\n        else this.del(modelname +  LocalStorage.KeyList.lastOpenedModel);\r\n        if (view) this.set(modelname + LocalStorage.KeyList.lastOpenedView, view);\r\n        else this.del(modelname +  LocalStorage.KeyList.lastOpenedView);\r\n        if (vertex) this.set(modelname + LocalStorage.KeyList.lastOpenedPosition, vertex);\r\n        else this.del(modelname +  LocalStorage.KeyList.lastOpenedPosition); }\r\n\r\n\r\n}\r\n\r\nexport class EcoreParser{\r\n    static supportedEcoreVersions = [\"http://www.eclipse.org/emf/2002/Ecore\"];\r\n    static prefix:string = '@';\r\n\r\n    static parse(ecorejson: GObject | string | null, isMetamodel: boolean, filename: string | undefined, persist: boolean = true): DModelElement[]{\r\n        if (!ecorejson) return [];\r\n        let parsedjson: GObject;\r\n        if (typeof ecorejson === \"string\") try { parsedjson = JSON.parse(ecorejson); } catch(e) { windoww.temp = ecorejson; Log.exx(\"error while parsing json:\", e, ecorejson.substring(0, 1000)); throw e; }\r\n        else parsedjson = ecorejson;\r\n\r\n        console.log(\"root parse\", ecorejson);\r\n\r\n        isMetamodel = !!parsedjson[ECoreRoot.ecoreEPackage];\r\n\r\n        Constructors.pause();\r\n            let parsedElements: DModelElement[] = isMetamodel ? EcoreParser.parseM2Model(parsedjson, filename) : EcoreParser.parseM1Model(parsedjson, undefined, filename);\r\n            console.warn(\"parse.result D\", parsedElements);\r\n            this.LinkAllNamesToIDs(parsedElements);\r\n            this.fixNamingConflicts(parsedElements);\r\n        Constructors.resume();\r\n        if (persist) {\r\n            CreateElementAction.newBatch(parsedElements);\r\n        }\r\n        // update m1 object pointers (need them to be persistent to navigate .fathers and get ecore pointer strings using LObject)\r\n        setTimeout(() => this.fixObjectPointers(parsedElements), 1);\r\n\r\n        windoww.tmpparse = () => LPointerTargetable.wrapAll(parsedElements);\r\n\r\n        this.tempfix_untilopennewtabisdone(parsedElements, isMetamodel);\r\n\r\n        console.log('parsedElem', parsedElements)\r\n        return parsedElements;\r\n    }\r\n\r\n    private static fixObjectPointers(parsedElements: DModelElement[]): void {\r\n        let dobjects: DObject[] = parsedElements.filter(e=>e.className === DObject.name) as any[];\r\n        let values: DValue[] = parsedElements.filter(e=>e.className === DValue.name) as any[];\r\n        let lobjects: LObject[] = LPointerTargetable.fromArr(dobjects);\r\n        let m1pointermap: Dictionary<string, LObject> = { }; //    \"//@rootrefname.index@/refname.index/@....etc\"\r\n        for (let o of lobjects){ m1pointermap[o.ecorePointer()] = o; }\r\n        for (let v of values) {\r\n            if (v.isMirage) continue;\r\n            let modified = false;\r\n            let newvalues = v.value.map((e) => {\r\n                if (!m1pointermap[e as any]) return e;\r\n                modified = true;\r\n                console.log(\"m1 pointer resolved:\", {from:e, to:m1pointermap[e as any].id});\r\n                return m1pointermap[e as any].id;\r\n            });\r\n            if (!modified) continue;\r\n            let lv: LValue = LPointerTargetable.from(v);\r\n            lv.value = newvalues;\r\n        }\r\n\r\n    }\r\n    private static tempfix_untilopennewtabisdone(parsedElements: DModelElement[], isMetamodel: boolean) {\r\n        // replaces current model with parsed model. this needs to be removed to open a new tab later on.\r\n        let model: DModel = null as any;\r\n        for (let elem of parsedElements) { if (elem.className === DModel.name) { model = elem as any; break; } }\r\n        SetRootFieldAction.new(isMetamodel ? \"m2models\" : \"m1models\", model.id, '+=', false); // it is pointer but no need to update pointedby's this time\r\n    }\r\n\r\n    // resolve eCore pointers to Jodel pointers and set the PointedBy\r\n    private static LinkAllNamesToIDs(parsedElements: DModelElement[]): void {\r\n        // todo: Ã¨ post-parse che legga i nomi e assegni gli id aggiustando le references e extends settati by name. trova i campi temporanei cercando i @ts-ignore\r\n        // update mref, attribute, parameter type\r\n        // update operation exception\r\n        // replace those names with id's\r\n\r\n        let idMap: Dictionary<Pointer, DModelElement> = {};\r\n        let nameMap: Dictionary<string, DModelElement> = {};\r\n        let replacePrimitiveMap: Dictionary<string, DClassifier> = {};\r\n        let d_Estring: DClassifier = Selectors.getAllPrimitiveTypes()[0];\r\n        replacePrimitiveMap[AttribETypes.EString] = d_Estring;\r\n        // todo: do the same for all other primitives\r\n\r\n        // let longprefixlength = 'ecore:EDataType http://www.eclipse.org/emf/2002/Ecore'.length;\r\n        const typeprefix = \"#//\";\r\n        for (let shortkey in AttribETypes){\r\n            let longkey: string = (AttribETypes as GObject)[shortkey];\r\n            // fallback for missing type instead of crash\r\n            if (!replacePrimitiveMap[longkey]) replacePrimitiveMap[longkey] = d_Estring;\r\n\r\n            // allow shortcuts to work too\r\n            replacePrimitiveMap[typeprefix + shortkey] = replacePrimitiveMap[longkey];\r\n\r\n        }\r\n\r\n\r\n        for (let ecorename in replacePrimitiveMap) {\r\n            idMap[replacePrimitiveMap[ecorename].id] = replacePrimitiveMap[ecorename];\r\n        }\r\n\r\n        let prereplace = (name: string) => name.replaceAll(\"#//\", \"\"); // todo: if\r\n        let replaceRules = [\"extends\", /*\"extendedBy\",*/ \"exceptions\", \"type\"];\r\n        let dobj: GObject & DModelElement;\r\n\r\n        for (dobj of parsedElements) {\r\n            if (dobj.name) { nameMap[dobj.name] = dobj; nameMap[typeprefix + dobj.name] = dobj;}\r\n            idMap[dobj.id] = dobj;\r\n        }\r\n\r\n        for (let replacekey of replaceRules){\r\n            for (dobj of parsedElements) {\r\n                let valtmp: string | string[] = dobj[replacekey] as string | string[];\r\n                if (valtmp === undefined) continue; // for missing properties in a d-object like looking for extends on a dmodel.\r\n                let values: string[]\r\n                let isArray = Array.isArray(valtmp);\r\n                if (isArray) {\r\n                    values = valtmp as string[];\r\n                    dobj[replacekey] = [];\r\n                }\r\n                else {\r\n                    values = [valtmp as string];\r\n                }\r\n                for (let value of values) {\r\n                    if (!value) continue;\r\n                    // console.log(\"fixalltypes\", {replacekey, dobj, value, values});\r\n                    const isType = value.indexOf(\"#//\") == 0;\r\n                    let target: DModelElement = replacePrimitiveMap[value];\r\n                    if (!target) target = nameMap[value];\r\n                    // if (Pointers.isPointer(value)) { target = value;  if it happen to be a pointer it's a mistake in parser }\r\n\r\n\r\n                    if (isType) {\r\n                        console.log(\"attempt to replace primitive type to his id\", {target, dobj, replacekey, value, replacePrimitiveMap, nameMap, idMap, parsedElements});\r\n                    }\r\n\r\n                    if (replacekey === \"extends\") {\r\n                        if (!target) continue;\r\n                        Log.ex(target.className !== DClass.name, \"found a class attempting to extend an object that is not a class\", {target, dobj, replacePrimitiveMap, nameMap, idMap});\r\n                        (target as DClass).extendedBy.push((dobj as DClass).id);\r\n                    }\r\n                    Log.ex(!target, \"LinkAllNames() can't find type target:\", {value, nameMap, replacePrimitiveMap, dobj, replacekey});\r\n                    if (isArray) dobj[replacekey].push(target.id);\r\n                    else dobj[replacekey] = target.id;\r\n                }\r\n            }\r\n\r\n        }\r\n\r\n        let idlookup: Dictionary<string, DModelElement> = store.getState().idlookup as any;\r\n        for (let ptrkey of PointedBy.list) for(dobj of parsedElements) {\r\n            let valtmp: string | string[] = dobj[ptrkey] as string | string[];\r\n            let values: string[]\r\n            if (Array.isArray(valtmp)) {\r\n                values = valtmp as string[];\r\n            }\r\n            else {\r\n                if (valtmp === undefined) values = [];\r\n                // if (valtmp === \"modeltmp\") { dobj[ptrkey] = null; values = []; } // because model.father is null, but i want to error check others and let them crash if missing father\r\n                else values = [valtmp as string];\r\n            }\r\n            console.log(\"fixalltypes[]\", {ptrkey, valtmp, dobj, values});\r\n            for (let value of values) {\r\n                if (!value) continue;\r\n                // errore: per operazione.type l'import mi restituisce puntatore a oggetto stringa, ma non Ã¨ tra gli oggetti parsed\r\n                let target: DModelElement = idMap[value];\r\n                if (target) {\r\n                    target.pointedBy.push(PointedBy.new(\"idlookup.\" + dobj.id + \".\" + ptrkey));\r\n                } else {\r\n                    target = idlookup[value];\r\n                    console.log(\"fixalltypes\", {ptrkey, valtmp, dobj, value, values, target, idMap});\r\n                    if (!target) throw new Error(\"target undefined\");\r\n                    SetFieldAction.new(target, \"pointedBy\", PointedBy.new(\"idlookup.\" + dobj.id + \".\" + ptrkey),'+=', false);\r\n                }\r\n            }\r\n        }\r\n        // update superclasses\r\n        this.updateSuperClasses(parsedElements);\r\n    }\r\n\r\n    private static todoGetPrimitiveTypenope(type: AttribETypes.EString | string): Pointer<DClass, 1, 1, LClass> {\r\n        // akready fixed in LinkAllNamesToID\r\n        return 'todoGetPrimitiveType from parser';\r\n    }\r\n\r\n    private static updateSuperClasses(parsedElements: DModelElement[]): void {\r\n        // todo:3\r\n\r\n    }\r\n    private static fixNamingConflicts(parsedElements: DModelElement[]): void {\r\n        // todo:4 final\r\n    }\r\n\r\n    static parseM2Model(json: Json, filename: string | undefined): DModelElement[] {\r\n        let generated: DModelElement[] = [];\r\n        if (!json) { json = {}; }\r\n        let modelname = json[ECoreNamed.namee] as string;\r\n        if (!modelname && filename) {\r\n            let pos = filename.indexOf(\".\");\r\n            modelname = pos === -1 ? filename : filename.substring(0, pos); }\r\n        let dObject: DModel = DModel.new( modelname || \"imported_metamodel_1\", undefined, true, true);\r\n        console.log(\"made model\", json);\r\n        generated.push(dObject); // dObject.father = 'modeltmp' as any;\r\n        /// *** specific  *** ///\r\n        const childrens = EcoreParser.getChildrens(json);\r\n        const annotations = EcoreParser.getAnnotations(json);\r\n        // dObject.name = json[ECoreNamed.namee] as string || \"imported_metamodel_1\";\r\n        console.log(\"made model 2\", childrens, annotations);\r\n        for (let child of annotations) {\r\n            EcoreParser.parseDAnnotation(dObject, child, generated);\r\n        }\r\n        console.log(\"made annotations\");\r\n        for (let child of childrens) {\r\n            EcoreParser.parseDPackage(dObject, child, generated);\r\n        }\r\n        console.log(\"made packages\");\r\n        return generated;\r\n    }\r\n\r\n    static parseM1Model(json: Json, meta?: LModel, filename?: string): DModelElement[] {\r\n        let generated: DModelElement[] = [];\r\n        if (!json) { json = {}; }\r\n        /// *** specific  *** ///\r\n        // this.parseDObject(json, dObject, DModel,undefined, generated);\r\n        let allmodels: DModel[];\r\n        if (!meta && filename) {\r\n            allmodels = Selectors.getAll(DModel);\r\n            allmodels = allmodels.filter( (m) => m.name === filename);\r\n            meta = LPointerTargetable.fromD(allmodels[0]);\r\n        } else allmodels = [];\r\n\r\n        let xmlns =  EcoreParser.XMLinlineMarker + \"xmlns:\";\r\n        let ns: string | undefined = undefined as any;\r\n        function findns(key: string): false | string {\r\n            let pos = key.indexOf(\":\");\r\n            if (pos <= 0) return false;\r\n            return ns = key.substring(0, pos); // through namespace before the name of the root objects;\r\n            // additional method: through xmlns key\r\n            // if (key.indexOf(xmlns)) continue; // \"-xmlns:org.eclipse.example.modelname\": \"https://org/eclipse/example/modelname\",\r\n            // ns = key.substring(xmlns.length); break;\r\n        }\r\n        outerloop: for (let key0 in json) { // ns can be at most in sublevel 3, this is annoying but i need it at beginning of parsing\r\n            if (findns(key0)) break;\r\n            let val0 = json[key0];\r\n            if (typeof val0 === \"object\") for (let key1 in val0) {\r\n                if (findns(key0)) break outerloop;\r\n            }\r\n        }\r\n        if (ns && !meta) {\r\n            let allpkgs: LPackage[] = Selectors.getAll(DPackage, undefined, undefined, true, true);\r\n            let matchpkg: LPackage[] = allpkgs.filter( (d) => d.uri === ns);\r\n            meta = matchpkg[0]?.model;\r\n            // Log.exDev(!meta, \"metamodel not found: \", {ns, json, filename, allmodels, allpkgs, matchpkg}) // todo: after tests remove this check and allow shapeless models.\r\n        }\r\n\r\n        let modelname = '';\r\n        if (!modelname && filename) {\r\n            let pos = filename.indexOf(\".\");\r\n            modelname = (pos === -1 ? filename : filename.substring(0, pos)); }\r\n        let dObject: DModel = DModel.new( modelname || \"imported_model_1\", meta?.id, false, true);\r\n        console.log(\"made model\", json);\r\n        generated.push(dObject);\r\n\r\n        for (let key in json) {\r\n            switch(key) {\r\n                case ECoreObject.xmi_version: // this is only on roots\r\n                    Log.ex(json[key] !== \"2.0\",\"The only supported ecore version is \\\"2.0\\\", found instead: \\\"\"+json[key] +\"\\\"\");\r\n                    break;\r\n                // case ECoreObject.xmlnsecore:\r\n                case ECoreObject.xmlns_xmi:\r\n                    let expected = \"http://www.omg.org/XMI\";\r\n                    Log.ex(json[key] !== expected,\"Unexpected XMI schema. Should be \\\"\"+expected+\"\\\", found instead: \\\"\"+json[key] +\"\\\"\");\r\n                    break;\r\n                default: // a feature name\r\n                    let val = json[key];\r\n                    if (!val) continue;\r\n                    if (key.indexOf(xmlns) === 0) continue; // \"-xmlns:org.eclipse.example.modelname\": \"https://org/eclipse/example/modelname\",\r\n                    if (key[0] === EcoreParser.XMLinlineMarker) key = key.substring(EcoreParser.XMLinlineMarker.length);\r\n\r\n                    const namespacedclass: string = key;\r\n                    const mmclass: LClass | undefined = meta && meta.getClassByNameSpace(namespacedclass);\r\n                    if (!mmclass) console.log(\"failed to get mmclass\", {meta, key, mmclass})\r\n                    const roots_for_this_metaclass: Json[] = Array.isArray(val) ? val : [val]; // there might be N roots of class A, M of type B...\r\n                    for(let rootjson of roots_for_this_metaclass) {\r\n                        // DObject.new(mmclass.id, dObject.id, DModel, undefined, true)\r\n                        EcoreParser.parseDObject(rootjson, dObject, DModel, mmclass, generated);\r\n                    }\r\n            }\r\n        }\r\n        return generated;\r\n    }\r\n    /*\r\n    {\r\n      \"org.eclipse.example.bowling:League\": { <-- :classroot\r\n        \"-xmlns:xmi\": \"http://www.omg.org/XMI\",\r\n        \"-xmlns:org.eclipse.example.bowling\": \"https://org/eclipse/example/bowling\",\r\n        \"-xmi:version\": \"2.0\",\r\n        \"Players\": [\r\n          { \"-name\": \"tizio\" },\r\n          { \"-name\": \"asd\" }\r\n        ]\r\n      }\r\n    }\r\n    */\r\n\r\n\r\n    /// In Ecore parsing when you find a value list, it is possible to recover only the type for the meta-feature,<br>\r\n    /// but an array of Mammals might have some Whales, Pigs, etc mixed in. and you have to get the correct subclass for each\r\n    static getobjectmetaclass(json: Json, metaSuperClass: LClass): LClass {\r\n        return metaSuperClass; // todo: comment this and execute below\r\n        let subclasses: LClass[] | [] = !metaSuperClass ? [] : []; // meta.metaSuperClass todo, enable this case\r\n        let subclasseshapes: Dictionary<Pointer<DClass>, {l: LClass } & Dictionary<DocString<\"feature name\">,  LTypedElement[\"type\"]/*feature type*/>> = {}\r\n        for (let sc of subclasses) {\r\n            subclasseshapes[sc.id] = {l: sc};\r\n            let row = subclasseshapes[sc.id];\r\n            for (let feat of sc.childrens) {\r\n                let lfeat: LTypedElement = feat as any;\r\n                let dfeat: DTypedElement = lfeat.__raw as any;\r\n                if (!dfeat.name || !dfeat.type) continue;\r\n                row[dfeat.name] = lfeat.type;\r\n            }\r\n        }\r\n        return this.findBestMatch(subclasseshapes, json);\r\n    }\r\n    static findBestMatch(\r\n        m2classes: Dictionary<Pointer<DClass>,  {l: LClass } & Dictionary<DocString<\"feature name\">, LTypedElement[\"type\"]>>,\r\n        json: Dictionary<DocString<\"feature name\">, any/*actual val instead of type*/>): LClass{\r\n        throw new Error(\"todo\");\r\n        return null as any;\r\n    }\r\n    static parseDObject(json: Json, parent: DModel | DValue, parentType: typeof DModel | typeof DValue, meta: LClass | undefined, generated: DModelElement[]): DModelElement[]{\r\n        if (!json) { json = {}; }\r\n        meta = meta && this.getobjectmetaclass(json, meta);\r\n        // let dObject: DObject = DObject.new(meta?.id, parent.id, parentType, json[\"name\"] as string || \"obj_1\");\r\n        // let data: Partial<DObject> = {};\r\n        let dObject: DObject = DObject.new(meta?.id, parent.id, parentType, json[\"name\"] as string || \"obj_1\");\r\n        generated.push(dObject); dObject.father = parent.id;\r\n        if (parent) {\r\n            if (parentType === DModel) (parent as DModel).objects.push(dObject.id);\r\n            else (parent as DValue).value.push(dObject.id);\r\n        }\r\n        console.log(\"made dobject\", {json, dObject, meta, metaname: meta?.name});\r\n        /// *** specific  *** ///\r\n        for (let key in json) {\r\n            switch(key) {\r\n                case ECoreObject.xmi_version: // this is only on roots\r\n                    Log.ex(json[key] !== \"2.0\",\"The only supported ecore version is \\\"2.0\\\", found instead: \\\"\"+json[key] +\"\\\"\");\r\n                    break;\r\n                // case ECoreObject.xmlnsecore:\r\n                case ECoreObject.xmlns_xmi:\r\n                    let expected = \"http://www.omg.org/XMI\";\r\n                    Log.ex(json[key] !== expected,\"Unexpected XMI schema. Should be \\\"\"+expected+\"\\\", found instead: \\\"\"+json[key] +\"\\\"\");\r\n                    break;\r\n                default: // a feature name\r\n                    let val = json[key];\r\n                    if (!val) continue;\r\n                    if (key[0] === EcoreParser.XMLinlineMarker) key = key.substring(1);\r\n                    if (key.indexOf(\"xmlns:\") === 0) continue; // \"-xmlns:org.eclipse.example.modelname\": \"https://org/eclipse/example/modelname\",\r\n                    let metafeature: LAttribute | LReference | undefined = meta && (meta as any)[\"@\"+key];\r\n                    console.log(\"feature meta\", {json, dObject, key, val, metafeature, classmeta: meta});\r\n                    const values: any[] = Array.isArray(val) ? val : [val];\r\n                    EcoreParser.parseDValue(key, values, dObject/*father*/, metafeature/*meta*/, generated);\r\n                    // DValue.new(key, metafeature?.id, values, dObject, true, false);\r\n            }\r\n        }\r\n        return generated;\r\n    }\r\n\r\n    private static parseDValue(name:string | undefined, jsonvalues: any[], parent: DObject, meta: LAttribute | LReference | undefined, generated: DModelElement[]): DModelElement[] {\r\n        if (!jsonvalues) { jsonvalues = []; }\r\n        // let dObject: DObject = DObject.new(meta?.id, parent.id, parentType, json[\"name\"] as string || \"obj_1\");\r\n        console.log(\"DValue.new(meta ? undefined : name, meta?.id, jsonvalues, parent.id, true, false)\")\r\n        console.log(\"DValue.new(\", meta ? undefined : name, \",\",meta?.id, \",\",jsonvalues, \",\",parent.id);\r\n        let dValue: DValue = DValue.new(meta ? undefined : name, meta?.id, [], parent.id, true, false);\r\n        generated.push(dValue); dValue.father = parent.id;\r\n        parent.features.push(dValue.id);\r\n        console.log(\"made dValue\", {jsonvalues, dValue, meta, metaname: meta?.name});\r\n        if (meta && meta.className === DAttribute.name) { dValue.value = jsonvalues; return generated; }\r\n\r\n        for (let v of jsonvalues) {\r\n            if (typeof v !== \"object\") { dValue.value.push(v); continue; }\r\n            // let subdObject: DObject = DObject.new((meta as LReference)?.type.id, parent.id, DValue, undefined);\r\n            // generated.push(subdObject);\r\n            EcoreParser.parseDObject(v, dValue, DValue, (meta as LReference)?.type, generated);\r\n        }\r\n        return generated;\r\n    }\r\n\r\n    static parseDAnnotation(parent: DModelElement, json: Json, generated: DModelElement[]): DModelElement[] {\r\n        if (!generated) generated = [];\r\n        if (!json) { json = {}; }\r\n        let dObject: DAnnotation = DAnnotation.new();\r\n        generated.push(dObject); dObject.father = parent.id;\r\n        dObject.father = parent.id;\r\n        if (parent) parent.annotations.push(dObject.id);\r\n\r\n        /// *** specific  *** ///\r\n        let key: string;\r\n        for (key in json){\r\n            const value = json[key];\r\n            switch (key) {\r\n                default: Log.exx('unexpected field in EAnnotation:  ' + key + ' => |' + value + '|'); break;\r\n                case ECoreAnnotation.details: break;\r\n                case ECoreAnnotation.references: break;\r\n                case ECoreAnnotation.source: break;\r\n            }\r\n        }\r\n        // annotation.referencesStr = this.read(json, ECoreAnnotation.source, '#/');\r\n        // annotation.name = this.read(json, ECoreAnnotation.name, 'EAnnotation_1');\r\n        // const details: Json[] = this.getDetails(json);\r\n        // for (let i = 0; i < details.length; i++) { new EAnnotationDetail(this, details[i]); }\r\n        return generated; }\r\n\r\n    static parseDPackage(parent: DModel, json: Json, generated: DModelElement[]): DModelElement[] {\r\n        if (!generated) generated = [];\r\n        if (!json) { json = {}; }\r\n        const childs = this.getChildrens(json);\r\n\r\n        console.warn(\"parseDPackage.childrens\", childs, generated);\r\n        let dObject: DPackage = DPackage.new();\r\n        generated.push(dObject); dObject.father = parent.id;\r\n        if (parent) parent.packages.push(dObject.id);\r\n\r\n        let version = (json[EcoreParser.prefix+\"xmlns:ecore\"] || '') as string;\r\n        // model.xmi = json[EcoreParser.prefix+\"xmlns:xmi\"]; // http://www.omg.org/XMI\r\n        // model.xsi = json[EcoreParser.prefix+\"xmlns:xsi\"]; // http://www.w3.org/2001/XMLSchema-instance\r\n\r\n        console.log(json);\r\n        Log.ex(!EcoreParser.supportedEcoreVersions.includes(version), \"unsupported ecore version, must be one of:\" + EcoreParser.supportedEcoreVersions + \" found instead: \"+version);\r\n\r\n        dObject.name = this.read(json, ECoreNamed.namee, 'defaultPackage');\r\n        /// *** specific start *** ///\r\n        dObject.uri = this.read(json, ECorePackage.nsURI, null);\r\n        dObject.prefix = this.read(json, ECorePackage.nsPrefix, null);\r\n        // if (!parent.uri) parent.uri = dObject.uri;\r\n        // if (!parent.prefix) parent.prefix = dObject.prefix; // namespace\r\n        for (let child of childs) {\r\n            switch (child[ECoreClass.xsitype]) {\r\n                default: Log.exx('unexpected xsitype:', child[ECoreClass.xsitype], ' found in jsonfragment:', child, ', in json:', json, ' package:', dObject); break;\r\n                case 'ecore:EClass': this.parseDClass(dObject, child, generated); break;\r\n                case 'ecore:EEnum': this.parseDEnum(dObject, child, generated); break;\r\n            }\r\n        }\r\n        /// *** specific end *** ///\r\n        return generated; }\r\n\r\n    static parseDClass(parent: DPackage, json: Json, generated: DModelElement[]): DModelElement[] {\r\n        if (!generated) generated = [];\r\n        if (!json) { json = {}; }\r\n        let dObject: DClass = DClass.new();\r\n        generated.push(dObject); dObject.father = parent.id;\r\n        if (parent) parent.classifiers.push(dObject.id);\r\n        dObject.name = this.read(json, ECoreNamed.namee, 'Class_1');\r\n        /// *** specific start *** ///\r\n        for (let key in json) {\r\n            switch (key) {\r\n                default: Log.exx('unexpected field in parseDClass() |' + key + '|', json); break;\r\n                case ECoreClass.instanceTypeName:\r\n                case ECoreClass.eSuperTypes:\r\n                case ECoreClass.xsitype:\r\n                case ECoreClass.eOperations:\r\n                case ECoreClass.eStructuralFeatures:\r\n                case ECoreClass.abstract:\r\n                case ECoreClass.interface:\r\n                case ECoreClass.namee: break; } }\r\n        dObject.instanceClassName = this.read(json, ECoreClass.instanceTypeName, '');\r\n        dObject.interface = this.read(json, ECoreClass.interface, 'false') === 'true';\r\n        dObject.abstract = this.read(json, ECoreClass.abstract, 'false') === 'true';\r\n        let tmps: string = this.read(json, ECoreClass.eSuperTypes, '');\r\n        dObject.extends = tmps.split(' ');\r\n        const features: Json[] = this.getChildrens(json);\r\n        const functions: Json[] = this.getChildrens(json, false, true);\r\n        for (let child of functions) {\r\n            this.parseDOperation(dObject, json, generated);\r\n        }\r\n        for (let child of features) {\r\n            const xsiType = this.read(child, ECoreAttribute.xsitype);\r\n            switch (xsiType) {\r\n                default: Log.exx( 'unexpected xsi:type: ', xsiType, ' in feature:', child); break;\r\n                case 'ecore:EAttribute':\r\n                    this.parseDAttribute(dObject, child, generated); break;\r\n                case 'ecore:EReference':\r\n                    this.parseDReference(dObject, child, generated); break;\r\n            }\r\n        }\r\n        /// *** specific end *** ///\r\n        return generated; }\r\n\r\n    static parseDEnum(parent: DPackage, json: Json, generated: DModelElement[]): DModelElement[] {\r\n        if (!generated) generated = [];\r\n        if (!json) { json = {}; }\r\n        const childs = this.getChildrens(json);\r\n        let dObject: DEnumerator = DEnumerator.new();\r\n        generated.push(dObject); dObject.father = parent.id;\r\n        if (parent) parent.classifiers.push(dObject.id);\r\n        dObject.name = this.read(json, ECoreNamed.namee, 'Enum_1');\r\n        /// *** specific start *** ///\r\n        for (let key in json) {\r\n            const value = json[key];\r\n            switch (key) {\r\n                default: Log.exx('Enum.parse() unexpected key:', key, 'in json:', json); break;\r\n                case ECoreEnum.xsitype: case ECoreNamed.namee: break;\r\n                case ECoreEnum.eLiterals: break;\r\n                case ECoreEnum.serializable: dObject.serializable = value === 'true'; break;\r\n                case ECoreEnum.instanceTypeName: dObject.instanceClassName = value + ''; break;\r\n            }\r\n        }\r\n        for (let child of childs) {\r\n            this.parseDEnumLiteral(dObject, child, generated);\r\n        }\r\n\r\n        /// *** specific end *** ///\r\n        return generated; }\r\n\r\n\r\n\r\n    static parseDEnumLiteral(parent: DEnumerator, json: Json, generated: DModelElement[]): DModelElement[] {\r\n        if (!generated) generated = [];\r\n        if (!json) { json = {}; }\r\n        const childs = this.getChildrens(json);\r\n        let dObject: DEnumLiteral = DEnumLiteral.new();\r\n        generated.push(dObject); dObject.father = parent.id;\r\n        if (parent) parent.literals.push(dObject.id);\r\n        /// *** specific start *** ///\r\n        dObject.ordinal = +this.read(json, EcoreLiteral.value, Number.NEGATIVE_INFINITY);\r\n        dObject.literal = this.read(json, EcoreLiteral.literal, '');\r\n        dObject.name = this.read(json, ECoreNamed.namee,  dObject.literal || 'literal_1');\r\n        /// *** specific end *** ///\r\n        return generated; }\r\n\r\n    static parseDAttribute(parent: DClass, json: Json, generated: DModelElement[]): DModelElement[] {\r\n        if (!generated) generated = [];\r\n        if (!json) { json = {}; }\r\n        const childs = this.getChildrens(json);\r\n        let dObject: DAttribute = DAttribute.new();\r\n        generated.push(dObject); dObject.father = parent.id;\r\n        if (parent) parent.attributes.push(dObject.id);\r\n        dObject.name = this.read(json, ECoreNamed.namee, 'attr_1');\r\n        /// *** specific start *** ///\r\n        dObject.lowerBound = +this.read(json, ECoreAttribute.lowerbound, 0);\r\n        dObject.upperBound = +this.read(json, ECoreAttribute.upperbound, 1);\r\n        dObject.type = this.read(json, ECoreAttribute.eType, AttribETypes.EString);\r\n        /// *** specific end *** ///\r\n        return generated; }\r\n\r\n    static parseDReference(parent: DClass, json: Json, generated: DModelElement[]): DModelElement[] {\r\n        if (!generated) generated = [];\r\n        if (!json) { json = {}; }\r\n        const childs = this.getChildrens(json);\r\n        let dObject: DReference = DReference.new();\r\n        generated.push(dObject); dObject.father = parent.id;\r\n        if (parent) parent.references.push(dObject.id);\r\n        dObject.name = this.read(json, ECorePackage.namee, 'Ref_1');\r\n        /// *** specific start *** ///\r\n        dObject.containment = U.fromBoolString(this.read(json, ECoreReference.containment, false), false);\r\n        dObject.lowerBound = +this.read(json, ECoreAttribute.lowerbound, 0);\r\n        dObject.upperBound = +this.read(json, ECoreAttribute.upperbound, 1);\r\n\r\n        dObject.type = this.read(json, ECoreReference.eType, this.getEcoreTypeName(parent));\r\n\r\n        console.log(\"attempting to parse dref\", {dObject, json, parent, typekey:  ECoreReference.eType})\r\n\r\n        /// *** specific end *** ///\r\n        return generated; }\r\n\r\n    static parseDParameter(parent: DOperation, json: Json, generated: DModelElement[]): DModelElement[] {\r\n        if (!generated) generated = [];\r\n        if (!json) { json = {}; }\r\n        const childs = this.getChildrens(json);\r\n        let dObject: DParameter = DParameter.new();\r\n        generated.push(dObject); dObject.father = parent.id;\r\n        if (parent) parent.parameters.push(dObject.id);\r\n        dObject.name = this.read(json, ECoreNamed.namee, 'arg1');\r\n        /// *** specific start *** ///\r\n        dObject.lowerBound = +this.read(json, ECoreAttribute.lowerbound, 0);\r\n        dObject.upperBound = +this.read(json, ECoreAttribute.upperbound, 1);\r\n        dObject.type = this.read(json, ECoreAttribute.eType, AttribETypes.EString);\r\n        dObject.ordered = U.fromBoolString(this.read(json, ECoreOperation.ordered, 'false'), false);\r\n        dObject.unique = U.fromBoolString(this.read(json, ECoreOperation.unique, 'false'), false);\r\n        /// *** specific end *** ///\r\n        return generated; }\r\n\r\n    static parseDOperation(parent: DClass, json: Json, generated: DModelElement[]): DModelElement[] {\r\n        if (!generated) generated = [];\r\n        if (!json) { json = {}; }\r\n        const childs = this.getChildrens(json);\r\n        let dObject: DOperation = DOperation.new();\r\n        generated.push(dObject); dObject.father = parent.id;\r\n        if (parent) parent.operations.push(dObject.id);\r\n        dObject.name = this.read(json, ECoreNamed.namee, 'operation_1');\r\n        /// *** specific start *** ///\r\n        dObject.lowerBound = +this.read(json, ECoreAttribute.lowerbound, 1);\r\n        dObject.upperBound = +this.read(json, ECoreAttribute.upperbound, 1);\r\n        dObject.type = this.read(json, ECoreAttribute.eType, AttribETypes.EString);\r\n        dObject.exceptions = [this.read(json, ECoreOperation.eexceptions, '')];\r\n        dObject.ordered = U.fromBoolString(this.read(json, ECoreOperation.ordered, 'false'));\r\n        dObject.unique = U.fromBoolString(this.read(json, ECoreOperation.unique, 'false'));\r\n        dObject.visibility = AccessModifier.package;\r\n        for (let child of childs) {\r\n            this.parseDParameter(dObject, json, generated);\r\n        }\r\n        /// *** specific end *** ///\r\n        return generated; }\r\n\r\n\r\n    /*\r\n    static parseTEMPLATE(parent: DSomething, json: Json, generated: DModelElement[]): DModelElement[] {\r\n        if (!generated) generated = [];\r\n        if (!json) { json = {}; }\r\n        const childs = this.getChildrens(json);\r\n        let dObject: DSomething = DSomething.new();\r\n        generated.push(dObject); dObject.father = parent.id;\r\n        if (parent) parent.CHILDCOLLECTION.push(dObject.id);\r\n        dObject.name = this.read(json, ECoreNamed.namee, defaultNameTODO);\r\n        /// *** specific start *** ///\r\n        for (let child of childs) {\r\n            this.parseDSOMETHING(dObject, json, generated);\r\n        }\r\n        /// *** specific end *** ///\r\n        return generated; }*/\r\n\r\n\r\n\r\n\r\n\r\n    /////////////////////////////////// generic\r\n    static XMLinlineMarker: string = '@';\r\n    static classTypePrefix: string = '#//'\r\n    private static getAnnotations(thiss: Json): Json[] {\r\n        const ret: any = thiss[ECorePackage.eAnnotations];\r\n        if (!ret || $.isEmptyObject(ret)) { return []; }\r\n        if (Array.isArray(ret)) { return ret; } else { return [ret]; } }\r\n\r\n    private static getDetails(thiss: Json): Json[] {\r\n        const ret: any = thiss[ECoreAnnotation.details];\r\n        if (!ret || $.isEmptyObject(ret)) { return []; }\r\n        if (Array.isArray(ret)) { return ret; } else { return [ret]; } }\r\n\r\n    private static getChildrens(thiss: Json, throwError: boolean = false, functions: boolean = false): Json[] {\r\n        if (!thiss && !throwError) { return []; }\r\n        const mod = thiss[ECoreRoot.ecoreEPackage];\r\n        const pkg = thiss[ECorePackage.eClassifiers];\r\n        const cla = thiss[functions ? ECoreClass.eOperations : ECoreClass.eStructuralFeatures];\r\n        const fun = thiss[ECoreOperation.eParameters];\r\n        const lit = thiss[ECoreEnum.eLiterals];\r\n\r\n        const ret: any = mod || pkg || cla || fun || lit;\r\n        /*if ( ret === undefined || ret === null ) {\r\n          if (thiss['@name'] !== undefined) { ret = thiss; } // if it's the root with only 1 child arrayless\r\n        }*/\r\n        Log.ex( throwError && !ret, 'getChildrens() Failed: ', thiss, ret);\r\n        // console.log('ret = ', ret, ' === ', {}, ' ? ', ($.isEmptyObject(ret) ? [] : [ret]));\r\n        if (!ret || $.isEmptyObject(ret)) { return []; }\r\n        if (Array.isArray(ret)) { return ret; } else { return [ret]; }\r\n    }\r\n\r\n    private static read(json: Json, field: string, valueIfNotFound: any = 'read<T>()CanThrowError'): string {\r\n        let ret: any = json ? json[field] : null;\r\n        if (ret !== null && ret !== undefined && field.indexOf(this.XMLinlineMarker) !== -1) {\r\n            Log.ex(U.isObject(ret, false, false, true), 'inline value |' + field + '| must be primitive.', ret);\r\n            ret = U.multiReplaceAll('' + ret, ['&amp;', '&#38;', '&quot;'], ['&', '\\'', '\"']);\r\n        }\r\n        if ((ret === null || ret === undefined)) {\r\n            Log.ex(valueIfNotFound === 'read<T>()CanThrowError', 'this.read<',  '> failed: field[' + field + '], json: ', json);\r\n            return valueIfNotFound; }\r\n        return ret; }\r\n\r\n    static write(json: Json, field: string, val: string | any[]): string | any[] {\r\n        if (val !== null && field.indexOf(EcoreParser.XMLinlineMarker) !== -1) {\r\n            Log.ex(val !== '' + val, 'inline value |' + field + '| must be a string.', val);\r\n            val = U.multiReplaceAll(val as string, ['&', '\\'', '\"'], ['&amp;', '&#38;', '&quot;']);\r\n        }\r\n        else Log.ex(val !== '' + val || !U.isObject(val, true), 'primitive values should be inserted only inline in the xml:', field, val);\r\n        json[field] = val;\r\n        return val; }\r\n\r\n    private static getEcoreTypeName(parent: DClassifier): string {\r\n        if (parent.className === DEnumerator.name || parent.className === DClass.name) return this.classTypePrefix + this.name;\r\n        // return Type.classTypePrefix + parent.parent.name; problem: need L-object to navigate\r\n        return Log.ex(\"getEcoreTypeName failed\", parent);\r\n    }\r\n\r\n}\r\n\r\nexport enum AccessModifier {\r\n    public = 'public',\r\n    private = 'private',\r\n    protected = 'protected',\r\n    internal = 'internal',\r\n    package = 'package',\r\n    protectedinternal = 'protected internal',\r\n    protectedprivate = 'protected private', }\r\n\r\nexport class ECoreRoot {\r\n    static ecoreEPackage: string;\r\n}\r\n\r\nexport class ECoreAnnotation {\r\n    static source: string;\r\n    static references: string;\r\n    static details: string;}\r\nexport class ECoreNamed {\r\n    static namee: string; }\r\n\r\nexport class ECoreDetail {\r\n    static key: string;\r\n    static value: string; }\r\n\r\nexport class ECorePackage {\r\n    static eAnnotations: string;\r\n    static eClassifiers: string;\r\n    static xmlnsxmi: string;\r\n    static xmlnsxsi: string;\r\n    static xmiversion: string;\r\n    static xmlnsecore: string;\r\n    static nsURI: string;\r\n    static nsPrefix: string;\r\n    static namee: string;\r\n}\r\n\r\n\r\nexport class ECoreClass {\r\n    static eAnnotations: string;\r\n    static eStructuralFeatures: string;\r\n    static xsitype: string;\r\n    static namee: string;\r\n    static eOperations: string;\r\n    static instanceTypeName: string;\r\n    static eSuperTypes: string;\r\n    static abstract: string;\r\n    static interface: string;\r\n\r\n    // static defaultValue = EcoreParser.XMLinlineMarker + 'defaultValue';  // visualizzato in ecore ma mai salvato dentro il file. inutilizzato\r\n    // nelle classi, assume il valore di \"[name] = [NumericValue]\" senza le [] negli enum.\r\n}\r\n\r\nexport class ECoreEnum {\r\n    static eAnnotations: string;\r\n    static xsitype: string;\r\n    static namee: string;\r\n    static instanceTypeName: string;\r\n    static serializable: string;\r\n    static eLiterals: string;\r\n}\r\n\r\nexport class EcoreLiteral {\r\n    static eAnnotations: string;\r\n    static namee: string;\r\n    static value: string;\r\n    static literal: string;\r\n}\r\n\r\n\r\nexport class ECoreReference {\r\n    static eAnnotations: string;\r\n    static xsitype: string;\r\n    static eType: string;\r\n    static containment: string;\r\n    static upperbound: string;\r\n    static lowerbound: string;\r\n    static namee: string; }\r\n\r\nexport class ECoreAttribute {\r\n    static eAnnotations: string;\r\n    static xsitype: string;\r\n    static eType: string;\r\n    static namee: string;\r\n    static lowerbound: string;\r\n    static upperbound: string;\r\n}\r\n\r\nexport class ECoreOperation {\r\n    static eAnnotations: string;\r\n    static eType: string;\r\n    static eexceptions: string;\r\n    static upperBound: string;\r\n    static lowerBound: string;\r\n    static unique: string;\r\n    static ordered: string;\r\n    static namee: string;\r\n    static eParameters: string; }\r\n\r\nexport class ECoreParameter {\r\n    static eAnnotations: string;\r\n    static namee: string;\r\n    static ordered: string;\r\n    static unique: string;\r\n    static lowerBound: string;\r\n    static upperBound: string;\r\n    static eType: string;\r\n}\r\n\r\nexport class ECoreObject{\r\n    static xmlns_xmi: string;\r\n    static xmlns_uri: never; // \"-xmlns:org.eclipse.example.modelname\": \"https://org/eclipse/example/modelname\", <b>key is dynamic</b>\r\n    static xmi_version: string;\r\n}\r\nexport class XMIModel {\r\n    static type: string;\r\n    static namee: string; }\r\n\r\n\r\n///////////////\r\n\r\nECoreRoot.ecoreEPackage = 'ecore:EPackage';\r\nECoreNamed.namee = EcoreParser.XMLinlineMarker + 'name';\r\n\r\nECorePackage.eAnnotations = ECoreClass.eAnnotations = ECoreEnum.eAnnotations = EcoreLiteral.eAnnotations =\r\n    ECoreReference.eAnnotations = ECoreAttribute.eAnnotations = ECoreOperation.eAnnotations = ECoreParameter.eAnnotations = 'eAnnotations';\r\n\r\nECoreAnnotation.source = EcoreParser.XMLinlineMarker + 'source';\r\nECoreAnnotation.references = EcoreParser.XMLinlineMarker + 'references'; // \"#/\" for target = package.\r\nECoreAnnotation.details = 'details'; // arr\r\nECoreDetail.key = EcoreParser.XMLinlineMarker + 'key'; // can have spaces\r\nECoreDetail.value = EcoreParser.XMLinlineMarker + 'value';\r\n\r\nECorePackage.eClassifiers = 'eClassifiers';\r\nECorePackage.xmlnsxmi = EcoreParser.XMLinlineMarker + 'xmlns:xmi'; // typical value: http://www.omg.org/XMI\r\nECorePackage.xmlnsxsi = EcoreParser.XMLinlineMarker + 'xmlns:xsi'; // typical value: http://www.w3.org/2001/XMLSchema-instance\r\nECorePackage.xmiversion = EcoreParser.XMLinlineMarker + 'xmi:version'; // typical value: \"2.0\"\r\nECorePackage.xmlnsecore = EcoreParser.XMLinlineMarker + 'xmlns:ecore';\r\nECorePackage.nsURI = EcoreParser.XMLinlineMarker + 'nsURI'; // typical value: \"http://org/eclipse/example/modelname\"\r\nECorePackage.nsPrefix = EcoreParser.XMLinlineMarker + 'nsPrefix'; // typical value: org.eclipse.example.modelname\r\nECorePackage.namee = EcoreParser.XMLinlineMarker + 'name';\r\n\r\nECoreClass.eStructuralFeatures = 'eStructuralFeatures';\r\nECoreClass.eOperations = 'eOperations';\r\nECoreClass.xsitype = EcoreParser.XMLinlineMarker + 'xsi:type'; // \"ecore:EClass\"\r\nECoreClass.namee = ECorePackage.namee;\r\nECoreClass.eSuperTypes = EcoreParser.XMLinlineMarker + 'eSuperTypes'; // space separated: \"#name1 #name2\"...\r\nECoreClass.instanceTypeName = EcoreParser.XMLinlineMarker + 'instanceTypeName';  // raw str\r\nECoreClass.instanceTypeName = EcoreParser.XMLinlineMarker + 'instanceTypeName';\r\nECoreClass.abstract = EcoreParser.XMLinlineMarker + 'abstract'; // bool\r\nECoreClass.interface = EcoreParser.XMLinlineMarker + 'interface'; // bool\r\n\r\nECoreEnum.instanceTypeName = ECoreClass.instanceTypeName;\r\nECoreEnum.serializable = 'serializable'; // \"false\", \"true\"\r\nECoreEnum.xsitype = ECoreClass.xsitype; // \"ecore:EEnum\"\r\nECoreEnum.eLiterals = 'eLiterals';\r\nECoreEnum.namee = ECorePackage.namee;\r\n\r\nEcoreLiteral.literal = 'literal';\r\nEcoreLiteral.namee = ECorePackage.namee;\r\nEcoreLiteral.value = 'value'; // any integer (-inf, +inf), not null. limiti = a type int 32 bit?\r\n\r\nECoreReference.xsitype = EcoreParser.XMLinlineMarker + 'xsi:type'; // \"ecore:EReference\"\r\nECoreReference.eType = EcoreParser.XMLinlineMarker + 'eType'; // \"#//Player\"\r\nECoreReference.containment = EcoreParser.XMLinlineMarker + 'containment'; // \"true\"\r\nECoreReference.upperbound = EcoreParser.XMLinlineMarker + 'upperBound'; // \"@1\"\r\nECoreReference.lowerbound = EcoreParser.XMLinlineMarker + 'lowerBound'; // does even exists?\r\nECoreReference.namee = EcoreParser.XMLinlineMarker + 'name';\r\n\r\nECoreAttribute.xsitype = EcoreParser.XMLinlineMarker + 'xsi:type'; // \"ecore:EAttribute\",\r\nECoreAttribute.eType = EcoreParser.XMLinlineMarker + 'eType'; // \"ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EString\"\r\nECoreAttribute.namee = EcoreParser.XMLinlineMarker + 'name';\r\nECoreAttribute.lowerbound = EcoreParser.XMLinlineMarker + 'lowerBound';\r\nECoreAttribute.upperbound = EcoreParser.XMLinlineMarker + 'upperBound';\r\n\r\n\r\nECoreOperation.eParameters = 'eParameters';\r\nECoreOperation.namee = EcoreParser.XMLinlineMarker + 'name'; // \"EExceptionNameCustom\",\r\nECoreOperation.ordered = EcoreParser.XMLinlineMarker + 'ordered'; // \"false\",\r\nECoreOperation.unique = EcoreParser.XMLinlineMarker + 'unique'; // \"false\",\r\nECoreOperation.lowerBound = EcoreParser.XMLinlineMarker + 'lowerBound'; // \"5\", ma che senso ha su una funzione?? Ã¨ il return?\r\nECoreOperation.upperBound = EcoreParser.XMLinlineMarker + 'upperBound';\r\nECoreOperation.eType = EcoreParser.XMLinlineMarker + 'eType'; // \"#//Classname\",\r\nECoreOperation.eexceptions = EcoreParser.XMLinlineMarker + 'eExceptions';\r\n// \"#//ClassnameException1 #//ClassNameException2 (also custom classes) ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EInt\r\n\r\nECoreParameter.namee = EcoreParser.XMLinlineMarker + 'name';\r\nECoreParameter.ordered = EcoreParser.XMLinlineMarker + 'ordered'; // \"false\";\r\nECoreParameter.unique = EcoreParser.XMLinlineMarker + 'unique'; // \"false\"\r\nECoreParameter.lowerBound = EcoreParser.XMLinlineMarker + 'lowerBound'; // \"1\"\r\nECoreParameter.upperBound = EcoreParser.XMLinlineMarker + 'upperBound'; // \"2\"\r\nECoreParameter.eType = EcoreParser.XMLinlineMarker + 'eType'; // \"ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EDoubl\r\n\r\nECoreObject.xmlns_xmi = EcoreParser.XMLinlineMarker + 'xmlns:xmi'; // \"http://www.omg.org/XMI\"\r\n// ECoreObject.xmlns_uri = EcoreParser.XMLinlineMarker + 'xmlns:org.eclipse.example.modelname'; // \"https://org/eclipse/example/modelname\"\r\nECoreObject.xmi_version = EcoreParser.XMLinlineMarker + 'xmi:version'; // \"2.0\"\r\n\r\nXMIModel.type = EcoreParser.XMLinlineMarker + 'type';\r\nXMIModel.namee = EcoreParser.XMLinlineMarker + 'name';\r\n\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}