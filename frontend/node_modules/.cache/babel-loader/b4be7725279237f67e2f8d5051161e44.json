{"ast":null,"code":"var _dec, _class, _class2;\nimport { Log, RuntimeAccessible } from \"../joiner\";\n/*\r\n                                    TODO for every update: check the VersionFixer.help() function\r\n*/\n\nexport let VersionFixer = (_dec = RuntimeAccessible('VersionFixer'), _dec(_class = (_class2 = class VersionFixer {\n  // automatically updated from updater function names\n\n  static help() {\n    console.clear();\n    let i = 1;\n    console.log(`\nBefore deploying a new version you should:\n\n${i++}) Update changelog\n\n${i++}) make a separate build subfolder (so you can switch versions)\n\n${i++}) build a new empty versioning function with signature like: private ['2.1 -> 2.3'](s: DState): DState\n        fill this function in a way that translates from the state shape of the old version, to the state shape of the new one\n   \n        `);\n\n    // DEPRECATED stuff\n    false && console.log(`\nBefore deploying a new version you should:\n\n${i++}?) ONLY IF IT'S FIRST TIME;\n   run DState.registerFirstTimeOnly() in the deploy version and export the localStorage variables starting with ${VersionFixer.prefix} to the dev version.\n   or call it in dev version after having temporarly undone the pending updates if possible, otherwise next steps might fail.\n   \n${i++}?) ONLY IF there are entirely new kinds of D-objects or optional new sub-structures in D-objects (like View.palette), update buildVersionSignature() method\n \n\n${i++}) build a new empty versioning function with signature: private ['2.1 -> 2.3'](s: DState): DState\n\n${i++}) in DState update DState.version.n (leave date and conversionList unchanged)\n\n${i++}) open a new empty project (no models no metamodels)\n   to find out what changed in the state between version without risking human error, i made an automatic detection.\n   call VersionFixer.checkVersionChanges() in browser console to see what changed need conversion in the function (i would save the result as comment inside the func)\n\n${i++}) fill the empty function of step (1), in a way that translates from the state shape of the old version, to the state shape of the new one\n\n${i++}) only after the transition function is complete, call VersionFixer.registerNewVersion();\n   it will both validate the version update function and store the new version as baseline.\n   (needs to be done last because checkVersionChanges will stop working until a new version is ready)\n   \nBEWARE: this approach cannot detect changes of valid values where the type did not change. eg if view.appliableTo = 'string' change his valid string values but not his type;\neverytime you put hands into a D-Object shape or valid values, you should document them to be able to write a conversion function later on.\n        `);\n  }\n  static get_highestversion() {\n    if (VersionFixer.highestVersion === 0) VersionFixer.setup();\n    return VersionFixer.highestVersion;\n  }\n  static setup() {\n    VersionFixer.versionAdapters = {};\n    const errormsg = k => \"Version auto-updater have a updater registered incorrectly: \\\"\" + k + \"\\\", please notify the developers.\";\n    let staticKeys = []; // no need for them Object.getOwnPropertyNames(VersionFixer);\n    let instanceKeys = Object.getOwnPropertyNames(VersionFixer.prototype); // object.keys does not list not-enumarable stuff (like class funcs)\n    let allKeys = [...staticKeys, ...instanceKeys];\n    for (let k of allKeys) {\n      switch (k) {\n        case 'constructor':\n        case 'd':\n        case 'className':\n        case 'prefix':\n        case 'highestVersion':\n        case 'versionAdapters':\n        case 'get_highestversion':\n        case 'staticClassName':\n        case 'cname':\n        case 'subclasses':\n        case 'help':\n        case 'setup':\n        case 'update':\n          continue;\n      }\n      let [froms, tos] = k.split(' -> ');\n      Log.exDev(!(froms === null || froms === void 0 ? void 0 : froms.length) || !(tos === null || tos === void 0 ? void 0 : tos.length), errormsg(k));\n      let from = +froms;\n      let to = +tos;\n      Log.exDev(isNaN(from) || isNaN(to), errormsg(k));\n      Log.exDev(!!VersionFixer.versionAdapters[from], \"duplicate version adapter from \\\"\" + from + \"\\\", please notify the developers.\");\n      VersionFixer.highestVersion = Math.max(VersionFixer.highestVersion, to);\n      VersionFixer.versionAdapters[from] = {\n        n: to,\n        f: VersionFixer[k]\n      };\n    }\n    return VersionFixer.versionAdapters;\n  }\n  static update(s) {\n    if (!VersionFixer.versionAdapters) VersionFixer.setup();\n    if (!s.version) s.version = {\n      n: 2.1,\n      date: \"_reconverted\",\n      conversionList: [0]\n    };\n    let prevVer = s.version.n || 0;\n    let currVer = prevVer;\n    while (currVer !== VersionFixer.highestVersion) {\n      Log.exDev(!VersionFixer.versionAdapters[currVer], \"missing version adapter from \\\"\" + currVer + \"\\\", please notify the developers.\", {\n        adapers: VersionFixer.versionAdapters,\n        curr: VersionFixer.versionAdapters[currVer]\n      });\n      console.log('versionfixer update pre', {\n        prevVer,\n        currVer,\n        entry: VersionFixer.versionAdapters[currVer]\n      });\n      let {\n        n,\n        f\n      } = VersionFixer.versionAdapters[currVer];\n      s.version.conversionList = [...s.version.conversionList, currVer];\n      s = f(s);\n      currVer = s.version.n = n || 0;\n      console.log('versionfixer update post', {\n        prevVer,\n        currVer,\n        n\n      });\n      //Log.exDev(currVer !== n, \"version updater updated to incorrect target versionn \\\"\"+prevVer+\"\\\" -> \\\"\"+n+\"\\\" , please notify the developers.\");\n      Log.exDev(currVer <= prevVer, \"version updater found loop at version \\\"\" + currVer + \"\\\", please notify the developers.\");\n      prevVer = currVer;\n    }\n    return s;\n  }\n  d(ptr, s) {\n    return s.idlookup[ptr];\n    // {n}\n  }\n  ['0 -> 2.1'](s) {\n    s.version = {\n      n: 2.1,\n      date: \"_reconverted\",\n      conversionList: [0]\n    };\n    return s;\n  }\n  ['2.1 -> 2.2'](s) {}\n  ['2.2 -> 2.201'](s) {\n    // let ls: LState = LPointerTargetable.from(s); nope, avoid L-objects. actions would fire in present state instead of in parameter state\n    for (let c of s.classs.map(p => this.d(p, s))) {\n      c.isSingleton = !!c.isSingleton; // booleanize the undefined\n      c.sealed = [];\n      c.final = false;\n      c.rootable = undefined;\n    }\n    for (let c of Object.values(s.idlookup)) {\n      if ((c === null || c === void 0 ? void 0 : c.className) && c.id && c.isCrossReference === undefined) c.isCrossReference = false;\n    }\n    for (let c of s.viewelements.map(p => this.d(p, s))) {\n      c.father = c.viewpoint;\n    }\n    for (let c of s.viewpoints.map(p => this.d(p, s))) {\n      c.cssIsGlobal = true;\n    }\n    for (let c of s.projects.map(p => this.d(p, s))) {\n      c.favorite = {};\n      c.description = '';\n    }\n    for (let c of s.references.map(p => this.d(p, s))) {\n      if (c.composition === undefined) c.aggregation = !(c.composition = !!c.containment);\n    }\n    for (let c of s.models.map(p => this.d(p, s))) {\n      if (c.dependencies === undefined) c.dependencies = [];\n    }\n    for (let c of s.attributes.map(p => this.d(p, s))) {\n      c.derived = !!c.derived;\n      c.derived_write = undefined; // c.derived ? '' : undefined;\n      c.derived_read = undefined; // c.derived ? '' : undefined;\n    }\n    return s;\n  }\n}, _class2.cname = 'VersionFixer', _class2.versionAdapters = _class2.setup(), _class2.highestVersion = 0, _class2.prefix = '__jodel_versioning_', _class2)) || _class);\n\n//deprecated stuff\n\n/*\r\npublic static checkVersionChanges(): GObject{\r\n    let lastVerName = localStorage.getItem(VersionFixer.prefix+'last');\r\n    let lastVerState = localStorage.getItem(VersionFixer.prefix+lastVerName);\r\n    let lastVersionSignature = JSON.parse(lastVerState || '{not:\"found\"}');\r\n    let newVersionSignature = this.buildVersionSignature();\r\n    return VersionFixer.checkVersionChanges_inner(lastVersionSignature, newVersionSignature);\r\n}\r\npublic static checkVersionChanges_inner(s1: DState, s2:DState): GObject{ return U.objectDelta(s1, s2, true); }\r\npublic static registerFirstTimeOnly(): void {\r\n    let newVersionSignature = VersionFixer.buildVersionSignature();\r\n    localStorage.setItem(VersionFixer.prefix+'last', ''+newVersionSignature.version.n);\r\n    localStorage.setItem(VersionFixer.prefix+''+newVersionSignature.version.n, JSON.stringify(newVersionSignature));\r\n}\r\n\r\npublic static registerNewVersion(): boolean {\r\n    let lastVerName = localStorage.getItem(VersionFixer.prefix+'last');\r\n    let prevVersionSignature: DState = JSON.parse(localStorage.getItem(VersionFixer.prefix+lastVerName) || '{not:\"found\"}') as any;\r\n    let newVersionSignature = VersionFixer.buildVersionSignature();\r\n    let updatedVersionSignature = this.update(prevVersionSignature);\r\n    let versionDiff: GObject = VersionFixer.checkVersionChanges_inner(updatedVersionSignature, newVersionSignature);\r\n    if (Object.keys(versionDiff).length !== 0) {\r\n        console.log(\"failed to save new version, the conversion function is not updating state properly.\",\r\n            {versionDiff, prevVersionSignature, newVersionSignature, updatedVersionSignature});\r\n        return false;\r\n    }\r\n    localStorage.setItem(VersionFixer.prefix+'last', ''+newVersionSignature.version.n);\r\n    localStorage.setItem(VersionFixer.prefix+''+newVersionSignature.version.n, JSON.stringify(newVersionSignature));\r\n    return true;\r\n}\r\nprivate static buildVersionSignature(): DState {\r\n    // purpose: save in state 1 of each D-objects with all the possible sub-objects in every possible structure shape\r\n    // values can be dummy but syntactical valid\r\n    //DState.new(); nope, i'm using current state, just call it from an empty project with no models.\r\n    DViewElement.new2(\"View\", \"jsx\", undefined,(d)=>{\r\n        d.appliableTo = 'Any';\r\n        d.subViews = {[\"Sample-fake-subView\"]: 3.5};\r\n        d.oclUpdateCondition = '(view: LViewElement) => { return false; } <--- as a string'\r\n        d.defaultVSize = new GraphSize(5,5,5,5);\r\n        d.palette = {\r\n            \"color\": {type:'color', value: [{r:0, g:0, b:0, a:0}]} as PaletteControl,\r\n            \"number\": {type:'number', value: 4, unit: 'px'} as NumberControl,\r\n            \"text\": {type:'text', value: 'stringa'} as StringControl,\r\n            \"path\": {type:'path', value: 'M 00 L 1 1 Z', x: '5', y: '10', options: [{k: 'optionnale', v:'option path M 0 0 L 5 5 Z'}]} as PathControl,\r\n        };\r\n        d.events = {[\"function name\"]: \"function body\"};\r\n        d.bendingMode = EdgeBendingMode.Bezier_QT;\r\n        d.edgeGapMode = EdgeGapMode.gap;\r\n        d.size = {[\"node or model Pointer\"]: new GraphSize(5,5,5,5)};\r\n        d.edgeStartOffset = new GraphPoint(5,5);\r\n        d.edgeEndOffset = new GraphPoint(5,5);\r\n        d.edgePointCoordMode = CoordinateMode.relativePercent;\r\n        d.edgeHeadSize = new GraphPoint(5,5);\r\n        d.edgeTailSize = new GraphPoint(5,5);\r\n    }, true, 'DViewElement');\r\n\r\n\r\n\r\n    return store.getState();\r\n}\r\n*/","map":{"version":3,"names":["Log","RuntimeAccessible","VersionFixer","_dec","_class","_class2","help","console","clear","i","log","prefix","get_highestversion","highestVersion","setup","versionAdapters","errormsg","k","staticKeys","instanceKeys","Object","getOwnPropertyNames","prototype","allKeys","froms","tos","split","exDev","length","from","to","isNaN","Math","max","n","f","update","s","version","date","conversionList","prevVer","currVer","adapers","curr","entry","d","ptr","idlookup","0 -> 2.1","2.1 -> 2.2","2.2 -> 2.201","c","classs","map","p","isSingleton","sealed","final","rootable","undefined","values","className","id","isCrossReference","viewelements","father","viewpoint","viewpoints","cssIsGlobal","projects","favorite","description","references","composition","aggregation","containment","models","dependencies","attributes","derived","derived_write","derived_read","cname"],"sources":["C:/0Programmi/Dev/projects/frontend/jjodel/src/redux/VersionFixer.ts"],"sourcesContent":["import {\r\n    CoordinateMode,\r\n    Defaults,\r\n    Dictionary, DocString, DPointerTargetable, DReference,\r\n    DState, DStructuralFeature,\r\n    DViewElement,\r\n    EdgeBendingMode,\r\n    EdgeGapMode,\r\n    GObject,\r\n    GraphPoint,\r\n    GraphSize, LClass,\r\n    Log, LPointerTargetable, LState, Pointer, RuntimeAccessible, RuntimeAccessibleClass, store,\r\n    U\r\n} from \"../joiner\";\r\nimport {NumberControl, PaletteControl, PathControl, StringControl} from \"../view/viewElement/view\";\r\n\r\n/*\r\n                                    TODO for every update: check the VersionFixer.help() function\r\n*/\r\n\r\n@RuntimeAccessible('VersionFixer')\r\nexport class VersionFixer {\r\n    public static cname = 'VersionFixer';\r\n    private static versionAdapters: Dictionary<number/*version*/, {n: number, f:(s: DState)=>DState}> = VersionFixer.setup();\r\n    private static highestVersion: number = 0; // automatically updated from updater function names\r\n    private static prefix: string = '__jodel_versioning_';\r\n    public static help(){\r\n        console.clear();\r\n        let i: number  = 1;\r\n\r\n        console.log(`\r\nBefore deploying a new version you should:\r\n\r\n${i++}) Update changelog\r\n\r\n${i++}) make a separate build subfolder (so you can switch versions)\r\n\r\n${i++}) build a new empty versioning function with signature like: private ['2.1 -> 2.3'](s: DState): DState\r\n        fill this function in a way that translates from the state shape of the old version, to the state shape of the new one\r\n   \r\n        `);\r\n\r\n\r\n\r\n        // DEPRECATED stuff\r\n        false && console.log(`\r\nBefore deploying a new version you should:\r\n\r\n${i++}?) ONLY IF IT'S FIRST TIME;\r\n   run DState.registerFirstTimeOnly() in the deploy version and export the localStorage variables starting with ${VersionFixer.prefix} to the dev version.\r\n   or call it in dev version after having temporarly undone the pending updates if possible, otherwise next steps might fail.\r\n   \r\n${i++}?) ONLY IF there are entirely new kinds of D-objects or optional new sub-structures in D-objects (like View.palette), update buildVersionSignature() method\r\n \r\n\r\n${i++}) build a new empty versioning function with signature: private ['2.1 -> 2.3'](s: DState): DState\r\n\r\n${i++}) in DState update DState.version.n (leave date and conversionList unchanged)\r\n\r\n${i++}) open a new empty project (no models no metamodels)\r\n   to find out what changed in the state between version without risking human error, i made an automatic detection.\r\n   call VersionFixer.checkVersionChanges() in browser console to see what changed need conversion in the function (i would save the result as comment inside the func)\r\n\r\n${i++}) fill the empty function of step (1), in a way that translates from the state shape of the old version, to the state shape of the new one\r\n\r\n${i++}) only after the transition function is complete, call VersionFixer.registerNewVersion();\r\n   it will both validate the version update function and store the new version as baseline.\r\n   (needs to be done last because checkVersionChanges will stop working until a new version is ready)\r\n   \r\nBEWARE: this approach cannot detect changes of valid values where the type did not change. eg if view.appliableTo = 'string' change his valid string values but not his type;\r\neverytime you put hands into a D-Object shape or valid values, you should document them to be able to write a conversion function later on.\r\n        `);\r\n    }\r\n    public static get_highestversion(): number{\r\n        if (VersionFixer.highestVersion === 0) VersionFixer.setup();\r\n        return VersionFixer.highestVersion;\r\n    }\r\n\r\n    private static setup(): (typeof VersionFixer)[\"versionAdapters\"]{\r\n        VersionFixer.versionAdapters = {};\r\n        const errormsg = (k: string)=>\"Version auto-updater have a updater registered incorrectly: \\\"\" + k + \"\\\", please notify the developers.\"\r\n        let staticKeys = [] as string[];// no need for them Object.getOwnPropertyNames(VersionFixer);\r\n        let instanceKeys = Object.getOwnPropertyNames(VersionFixer.prototype); // object.keys does not list not-enumarable stuff (like class funcs)\r\n        let allKeys = [...staticKeys, ...instanceKeys];\r\n        for (let k of allKeys){\r\n            switch(k){\r\n                case 'constructor': case 'd': case 'className':\r\n                case 'prefix': case 'highestVersion': case 'versionAdapters':\r\n                case 'get_highestversion':\r\n                case 'staticClassName': case 'cname': case 'subclasses':\r\n                case 'help': case 'setup': case 'update': continue;\r\n            }\r\n            let [froms, tos] = k.split(' -> ');\r\n            Log.exDev(!froms?.length || !tos?.length, errormsg(k));\r\n            let from = +froms; let to = +tos;\r\n            Log.exDev(isNaN(from) || isNaN(to), errormsg(k));\r\n            Log.exDev(!!VersionFixer.versionAdapters[from], \"duplicate version adapter from \\\"\"+from+\"\\\", please notify the developers.\")\r\n            VersionFixer.highestVersion = Math.max(VersionFixer.highestVersion, to);\r\n            VersionFixer.versionAdapters[from] = {n:to, f: (VersionFixer as any)[k]}\r\n        }\r\n        return VersionFixer.versionAdapters;\r\n    }\r\n\r\n    public static update(s: DState): DState{\r\n        if (!VersionFixer.versionAdapters) VersionFixer.setup();\r\n        if (!s.version) s.version = {n: 2.1, date:\"_reconverted\", conversionList:[0]};\r\n        let prevVer = s.version.n || 0;\r\n        let currVer = prevVer;\r\n        while (currVer !== VersionFixer.highestVersion) {\r\n            Log.exDev(!VersionFixer.versionAdapters[currVer], \"missing version adapter from \\\"\"+ currVer+\"\\\", please notify the developers.\",\r\n                {adapers: VersionFixer.versionAdapters, curr: VersionFixer.versionAdapters[currVer]});\r\n            console.log('versionfixer update pre', {prevVer, currVer, entry: VersionFixer.versionAdapters[currVer]});\r\n            let {n, f} = VersionFixer.versionAdapters[currVer];\r\n            s.version.conversionList = [...s.version.conversionList, currVer];\r\n            s = f(s);\r\n            currVer = s.version.n = n || 0;\r\n            console.log('versionfixer update post', {prevVer, currVer, n});\r\n            //Log.exDev(currVer !== n, \"version updater updated to incorrect target versionn \\\"\"+prevVer+\"\\\" -> \\\"\"+n+\"\\\" , please notify the developers.\");\r\n            Log.exDev(currVer <= prevVer, \"version updater found loop at version \\\"\"+currVer+\"\\\", please notify the developers.\");\r\n            prevVer = currVer;\r\n        }\r\n        return s;\r\n    }\r\n\r\n\r\n    private d<D extends DPointerTargetable, L extends LPointerTargetable>(ptr: Pointer<D>, s: DState): D{\r\n        return s.idlookup[ptr] as any;\r\n        // {n}\r\n    }\r\n    private ['0 -> 2.1'](s: DState): DState {\r\n        s.version = {n: 2.1, date:\"_reconverted\", conversionList:[0]};\r\n        return s;\r\n    }\r\n    private ['2.1 -> 2.2'](s: DState): void {\r\n\r\n    }\r\n    private ['2.2 -> 2.201'](s: DState): DState {\r\n        // let ls: LState = LPointerTargetable.from(s); nope, avoid L-objects. actions would fire in present state instead of in parameter state\r\n        for (let c of (s.classs).map(p=> this.d(p, s))) {\r\n            c.isSingleton = !!c.isSingleton; // booleanize the undefined\r\n            c.sealed = [];\r\n            c.final = false;\r\n            c.rootable = undefined;\r\n        }\r\n        for (let c of Object.values(s.idlookup) as any[]) { if (c?.className && c.id && c.isCrossReference === undefined) c.isCrossReference = false; }\r\n        for (let c of (s.viewelements).map(p=> this.d(p, s))) { c.father = c.viewpoint; }\r\n        for (let c of (s.viewpoints).map(p=> this.d(p, s))) { c.cssIsGlobal = true; }\r\n        for (let c of (s.projects).map(p=> this.d(p, s))) { c.favorite = {}; c.description = ''; }\r\n        for (let c of (s.references).map(p=> this.d(p, s))) { if (c.composition === undefined) c.aggregation = !(c.composition = !!(c as any).containment); }\r\n        for (let c of (s.models).map(p=> this.d(p, s))) { if (c.dependencies === undefined) c.dependencies = []; }\r\n        for (let c of (s.attributes).map(p=> this.d(p, s))) {\r\n            c.derived = !!c.derived;\r\n            c.derived_write = undefined; // c.derived ? '' : undefined;\r\n            c.derived_read = undefined; // c.derived ? '' : undefined;\r\n        }\r\n\r\n        return s;\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n//deprecated stuff\r\n\r\n\r\n\r\n/*\r\npublic static checkVersionChanges(): GObject{\r\n    let lastVerName = localStorage.getItem(VersionFixer.prefix+'last');\r\n    let lastVerState = localStorage.getItem(VersionFixer.prefix+lastVerName);\r\n    let lastVersionSignature = JSON.parse(lastVerState || '{not:\"found\"}');\r\n    let newVersionSignature = this.buildVersionSignature();\r\n    return VersionFixer.checkVersionChanges_inner(lastVersionSignature, newVersionSignature);\r\n}\r\npublic static checkVersionChanges_inner(s1: DState, s2:DState): GObject{ return U.objectDelta(s1, s2, true); }\r\npublic static registerFirstTimeOnly(): void {\r\n    let newVersionSignature = VersionFixer.buildVersionSignature();\r\n    localStorage.setItem(VersionFixer.prefix+'last', ''+newVersionSignature.version.n);\r\n    localStorage.setItem(VersionFixer.prefix+''+newVersionSignature.version.n, JSON.stringify(newVersionSignature));\r\n}\r\n\r\npublic static registerNewVersion(): boolean {\r\n    let lastVerName = localStorage.getItem(VersionFixer.prefix+'last');\r\n    let prevVersionSignature: DState = JSON.parse(localStorage.getItem(VersionFixer.prefix+lastVerName) || '{not:\"found\"}') as any;\r\n    let newVersionSignature = VersionFixer.buildVersionSignature();\r\n    let updatedVersionSignature = this.update(prevVersionSignature);\r\n    let versionDiff: GObject = VersionFixer.checkVersionChanges_inner(updatedVersionSignature, newVersionSignature);\r\n    if (Object.keys(versionDiff).length !== 0) {\r\n        console.log(\"failed to save new version, the conversion function is not updating state properly.\",\r\n            {versionDiff, prevVersionSignature, newVersionSignature, updatedVersionSignature});\r\n        return false;\r\n    }\r\n    localStorage.setItem(VersionFixer.prefix+'last', ''+newVersionSignature.version.n);\r\n    localStorage.setItem(VersionFixer.prefix+''+newVersionSignature.version.n, JSON.stringify(newVersionSignature));\r\n    return true;\r\n}\r\nprivate static buildVersionSignature(): DState {\r\n    // purpose: save in state 1 of each D-objects with all the possible sub-objects in every possible structure shape\r\n    // values can be dummy but syntactical valid\r\n    //DState.new(); nope, i'm using current state, just call it from an empty project with no models.\r\n    DViewElement.new2(\"View\", \"jsx\", undefined,(d)=>{\r\n        d.appliableTo = 'Any';\r\n        d.subViews = {[\"Sample-fake-subView\"]: 3.5};\r\n        d.oclUpdateCondition = '(view: LViewElement) => { return false; } <--- as a string'\r\n        d.defaultVSize = new GraphSize(5,5,5,5);\r\n        d.palette = {\r\n            \"color\": {type:'color', value: [{r:0, g:0, b:0, a:0}]} as PaletteControl,\r\n            \"number\": {type:'number', value: 4, unit: 'px'} as NumberControl,\r\n            \"text\": {type:'text', value: 'stringa'} as StringControl,\r\n            \"path\": {type:'path', value: 'M 00 L 1 1 Z', x: '5', y: '10', options: [{k: 'optionnale', v:'option path M 0 0 L 5 5 Z'}]} as PathControl,\r\n        };\r\n        d.events = {[\"function name\"]: \"function body\"};\r\n        d.bendingMode = EdgeBendingMode.Bezier_QT;\r\n        d.edgeGapMode = EdgeGapMode.gap;\r\n        d.size = {[\"node or model Pointer\"]: new GraphSize(5,5,5,5)};\r\n        d.edgeStartOffset = new GraphPoint(5,5);\r\n        d.edgeEndOffset = new GraphPoint(5,5);\r\n        d.edgePointCoordMode = CoordinateMode.relativePercent;\r\n        d.edgeHeadSize = new GraphPoint(5,5);\r\n        d.edgeTailSize = new GraphPoint(5,5);\r\n    }, true, 'DViewElement');\r\n\r\n\r\n\r\n    return store.getState();\r\n}\r\n*/"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}