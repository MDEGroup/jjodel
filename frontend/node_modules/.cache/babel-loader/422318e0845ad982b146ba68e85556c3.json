{"ast":null,"code":"var _dec, _class, _dec2, _class3, _dec3, _class5, _dec4, _class7, _class8, _dec5, _class9, _dec6, _class11;\nimport { DPointerTargetable, JsType, Log, LPointerTargetable, RuntimeAccessible, RuntimeAccessibleClass, SetFieldAction, SetRootFieldAction, U } from \"../joiner\";\n// (DX extends DUser ? LUser : (DX extends DPointerTargetable ? LPointerTargetable : (ERROR))\n// (DX extends DUser ? LUser : (DX extends DPointerTargetable ? LPointerTargetable : (           WViewElement\n//\n// (IN extends WViewElement ? LViewElement : (IN extends WViewTransientProperties ? LWiewTransientProperties : (ERROR)))\n// ))\n// type WtoL<WX extends WPointerTargetable> ='';\nconst childrenKeys = [\"@\", \"$\"];\nexport let LogicContext = (_dec = RuntimeAccessible('LogicContext'), _dec(_class = class LogicContext extends RuntimeAccessibleClass {\n  // & GObject;\n\n  constructor(proxyObject, data) {\n    super();\n    this.proxyObject = void 0;\n    this.data = void 0;\n    this.write = void 0;\n    this.className = this.constructor.cname || this.constructor.name;\n    this.data = data;\n    this.proxyObject = proxyObject;\n    this.write = proxyObject;\n  }\n  /*\r\n      saveToRedux(propkey: \"keyof data\" | string, val: \"typeof data[path]\" | any): void { // todo: ask non stackoverflow\r\n          // todo, put data in redux store, path is \"obj1.obj2.obj3...\" might replace it with a path funciton that return the foremost nested object container\r\n          if (!propkey) {\r\n              // todo: set whole object instead of a property\r\n          }\r\n      }*/\n}) || _class);\nRuntimeAccessibleClass.set_extend(RuntimeAccessibleClass, LogicContext);\nexport let MapLogicContext = (_dec2 = RuntimeAccessible('MapLogicContext'), _dec2(_class3 = class MapLogicContext extends LogicContext {\n  constructor(proxy, data, path) {\n    let subMaps = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];\n    super(proxy, data);\n    // this.proxyfyFunction = proxyfyFunction;\n    this.data = void 0;\n    this.path = void 0;\n    this.subMaps = void 0;\n    this.proxyObject = proxy;\n    this.data = data;\n    this.path = path;\n    this.subMaps = subMaps;\n    this.className = this.constructor.cname || this.constructor.name;\n  }\n}) || _class3);\nRuntimeAccessibleClass.set_extend(LogicContext, MapLogicContext);\nexport let MyProxyHandler = (_dec3 = RuntimeAccessible('MyProxyHandler'), _dec3(_class5 = class MyProxyHandler extends RuntimeAccessibleClass {\n  constructor() {\n    super(...arguments);\n    this.s = 'set_';\n    this.g = 'get_';\n  }\n  /*get(target: T, p: string | number | symbol, proxyitself: Proxyfied<T>): boolean {\r\n      switch (p) {\r\n          case '_isProxy': return true;\r\n          case 'init': return (this as any).init;\r\n          case 'init0': return (this as any).init0;\r\n          default: throw new Error('proxy get must be overridden, called for key: ' + (p as string));\r\n      }}*/\n  set(target, p, value, proxyitself) {\n    throw new Error('proxy set must be overridden');\n  }\n  deleteProperty(target, p) {\n    throw new Error('proxy delete must be overridden');\n  }\n  ownKeys(target) {\n    // return Object.getOwnPropertyNames(target);\n    console.log(\"ownkeys trap 1\", {\n      thiss: this,\n      target\n    });\n    console.log(\"ownkeys trap 2\", {\n      thiss: this,\n      target,\n      ret: Reflect.ownKeys(target)\n    });\n    return Reflect.ownKeys(target);\n  }\n  /// proxy methods not used\n  /* setPrototypeOf(target: T, v: object | null): boolean { ?? }\r\n  apply(target: T, thisArg: any, argArray: any[]): any { }\r\n  defineProperty(target: T, p: string | symbol, attributes: PropertyDescriptor): boolean { }\r\n  construct(target: T, argArray: any[], newTarget: Function): object { }\r\n  getOwnPropertyDescriptor(target: T, p: string | symbol): PropertyDescriptor | undefined { }\r\n  has(target: T, p: string | symbol): boolean { return p in target; }\r\n  getPrototypeOf(target: T): object | null { }\r\n  isExtensible(target: T): boolean { }\r\n  preventExtensions(target: T): boolean { }*/\n\n  static wrap(data, baseObjInLookup) {\n    let path = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n    let canThrow = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    //    static wrap<D extends RuntimeAccessibleClass, L extends LPointerTargetable, RET extends boolean = false>\n    //        (data: D | Pointer<DViewElement>, baseObjInLookup?: DPointerTargetable, path: string = '', canthrow: RET = false as RET): RET {\n    return DPointerTargetable.wrap(data, baseObjInLookup, path);\n  }\n  static isProxy(data) {\n    return (data === null || data === void 0 ? void 0 : data.__isProxy) || false;\n  }\n}) || _class5);\nRuntimeAccessibleClass.set_extend(RuntimeAccessibleClass, MyProxyHandler);\n/*\r\n* handling proxy += and proxy -=\r\n*\r\n* will become var = var + add; which will call Symbol.getPrimitive\r\nconsole.log(+obj2);     // 10        — hint is \"number\"         NaN with +array with multiple vals, +array[0] with array of size 1, NaN with functions & objects\r\nconsole.log(`${obj2}`); // \"hello\"   — hint is \"string\"         array => array.join(','), object => \"[object Object]\", function => function.toString() whole func definition with body code\r\nconsole.log(obj2 + \"\"); // \"true\"    — hint is \"default\"        array, object, function => same as with hint \"string\"\r\n*\r\n* */\n// NB: lclass.extends += somepointer will become: lclass.extends = lclass.extends + somepointer;\n// array + string will cause getPrimitive(\"default\") to array, then .join(',') on it, and finally and toString() to be called on all array members.\n// so pointers cannot include \",\" char and toString() must return a pointer to keep lclass.extends += somepointer as a valid expression;\n// -= will call getPrimitive(\"number\") which will result in array -> NaN, so NaN = NaN - pointer and cannot be done.\nlet GetPathHandler = (_dec4 = RuntimeAccessible('GetPathHandler'), _dec4(_class7 = (_class8 = class GetPathHandler extends MyProxyHandler {\n  constructor() {\n    super();\n    this.strbuilder = '';\n    this.array = [];\n    this.calls = [];\n  }\n  get(targetObj, propKey, proxyitself) {\n    // console.log('GetPathHandler', {targetObj, propKey, proxyitself});\n    if (propKey === \"start\") {\n      this.strbuilder = '';\n      this.array = [];\n    }\n    if (propKey === '$') {\n      const ret = GetPathHandler.__asCalls ? this.calls : GetPathHandler.__asArray ? this.array : this.strbuilder;\n      this.array = [];\n      this.strbuilder = '';\n      return ret;\n    }\n    this.array.push(propKey);\n    this.calls.push(arguments);\n    if (propKey === Symbol.toPrimitive) {\n      console.log(\"toprimitive\");\n      return function () {\n        for (var _len = arguments.length, a = new Array(_len), _key = 0; _key < _len; _key++) {\n          a[_key] = arguments[_key];\n        }\n        console.log(\"toprimitive called with parameters\", a);\n      };\n    }\n    if (!GetPathHandler.__asArray && !GetPathHandler.__asCalls) {\n      if (typeof propKey === \"symbol\") {\n        this.strbuilder += propKey.toString();\n      } else {\n        // Giordano: add ignore for webpack\n        //@ts-ignore\n        this.strbuilder += (this.strbuilder ? '.' : '') + propKey;\n      }\n    }\n    return GetPathHandler.__nested ? proxyitself : {};\n  }\n  set(target, p, value, proxyitself) {\n    switch (p) {\n      case '__asArray':\n      case '__asCalls':\n      case '__nested':\n        GetPathHandler[p] = value;\n        return true;\n      default:\n        throw new Error('getPath proxy cannot be written');\n    }\n  }\n}, _class8.__asCalls = false, _class8.__asArray = false, _class8.__nested = true, _class8)) || _class7);\nRuntimeAccessibleClass.set_extend(MyProxyHandler, GetPathHandler);\nexport let TargetableProxyHandler = (_dec5 = RuntimeAccessible('TargetableProxyHandler'), _dec5(_class9 = class TargetableProxyHandler extends MyProxyHandler {\n  // permette di fare cose tipo: user.name_surname che ritorna la concatenazione di nome e cognome anche se il campo name_surname non esiste.\n  // to disable type check easily and access 'set_' + varname dynamically\n\n  constructor(d, baseObjInLookup) {\n    let additionalPath = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n    let l = arguments.length > 3 ? arguments[3] : undefined;\n    super();\n    this.lg = void 0;\n    this.l = void 0;\n    this.d = void 0;\n    this.additionalPath = void 0;\n    this.baseObjInLookup = void 0;\n    this.d = d;\n    if (!l) {\n      var _RuntimeAccessibleCla, _RuntimeAccessibleCla2;\n      l = (_RuntimeAccessibleCla = RuntimeAccessibleClass.get(d === null || d === void 0 ? void 0 : d.className)) === null || _RuntimeAccessibleCla === void 0 ? void 0 : (_RuntimeAccessibleCla2 = _RuntimeAccessibleCla.logic) === null || _RuntimeAccessibleCla2 === void 0 ? void 0 : _RuntimeAccessibleCla2.singleton;\n      Log.exDev(!l, 'Trying to wrap class without singleton or logic mapped: ' + (d === null || d === void 0 ? void 0 : d.className), {\n        object: d,\n        className: d.className\n      });\n    }\n    this.baseObjInLookup = baseObjInLookup || d;\n    this.additionalPath = additionalPath;\n    this.l = l;\n    this.lg = this.l;\n    this.className = this.constructor.cname || this.constructor.name;\n  }\n\n  // damiano todo: this does not work\n  concatenableHandler(targetObj, propKey, proxyitself) {\n    //console.log(\"concatenableHandler 1\", {targetObj, propKey, proxyitself});\n    if (propKey in targetObj) return null;\n    const propKeyStr = U.asString(propKey, null);\n    let _index = propKeyStr ? propKeyStr.indexOf('_') : -1;\n    //console.log(\"concatenableHandler 2\", {targetObj, propKey, propKeyStr, proxyitself, _index});\n    if (_index < 0) return null;\n    let isConcatenable = true;\n    let ret = propKey.split('_').map(subKey => {\n      //console.log(\"concatenableHandler 3.0\", {targetObj, subKey, propKeyStr, proxyitself});\n      // se trovo multipli ___ li tratto come spazi aggiuntivi invece che come proprietà '' che ritornano undefined, così posso fare name___surname --> \"damiano   di vincenzo\"\n      let val = subKey === '' ? ' ' : this.get(targetObj, subKey, proxyitself);\n      isConcatenable = isConcatenable && JsType.isPrimitive(val);\n      return val;\n    });\n    //console.log(\"concatenableHandler 4\", {targetObj, propKey, propKeyStr, proxyitself, ret, isConcatenable});\n    return isConcatenable ? ret.join(' ') : ret;\n  }\n  get(targetObj, propKey, proxyitself) {\n    let ret;\n    let isError = false;\n    // console.error('_proxy get PRE:', {targetObj, propKey, proxyitself, arguments});\n    try {\n      ret = this.get0(targetObj, propKey, proxyitself);\n    } catch (e) {\n      ret = e;\n      isError = true;\n    }\n\n    // if (isError) throw ret;\n    // console.error('_proxy get POST:', {targetObj, propKey, ret, isError});\n    return ret;\n  }\n  get0(targetObj, propKey, proxyitself) {\n    // console.log('proxy keysearch', {propKey, targetObj, l: this.l, proxyitself, d: this.d});\n    let canThrowErrors = true;\n    if (propKey === \"__raw\") return targetObj;\n    switch (typeof propKey) {\n      case \"symbol\":\n        switch (String(propKey)) {\n          default:\n            Log.exDevv('unexpected  in proxy getter:', propKey);\n            break;\n          case \"Symbol(Symbol.toPrimitive)\":\n            return targetObj[propKey];\n          //  || typeof targetObj;\n        }\n\n        return null;\n      case \"number\":\n        return null;\n    }\n    switch (propKey) {\n      case '__l':\n        return this.l;\n      case '__d':\n        return this.d;\n      case 'inspect': // node.js util\n      case \"r\":\n      case \"_refresh\":\n      case \"_reload\":\n        return LPointerTargetable.wrap(targetObj.id);\n      case '__Raw':\n      case '__raw':\n        return targetObj;\n      case '__serialize':\n        return JSON.stringify(targetObj);\n      case '__isproxy':\n      case '__isProxy':\n        return true;\n      case '__random':\n        return Math.random();\n      case 'editCount':\n      case 'clonedcounter':\n      case 'clonedCounter':\n        return targetObj.clonedCounter || 0;\n    }\n    if (propKey[0] === \"_\" && propKey.indexOf(\"__info_of__\") === 0) {\n      return this.l[propKey];\n    }\n    const proxyacceptables = {\n      typeName: '',\n      $$typeof: ''\n    };\n    // check if exist directly in D.key, L.key or through a get_key\n    if (propKey in this.l || propKey in this.d || this.l[this.g + propKey] || propKey in proxyacceptables) {\n      // todo: il LogicContext passato come parametro risulta nell'autocompletion editor automaticamente generato, come passo un parametro senza passargli il parametro? uso arguments senza dichiararlo?\n      if (typeof propKey !== 'symbol' && this.g + propKey in this.lg) return this.lg[this.g + propKey](new LogicContext(proxyitself, targetObj));\n\n      // if specific custom getter exist\n      if (typeof propKey !== 'symbol' && this.g + propKey in this.lg) {\n        let getterMethod = this.lg[this.g + propKey]; // || this.defaultGetter;\n        // console.log(\"gets method\", {getterMethod, lg:this.lg, thiss: this});\n        if (getterMethod) return getterMethod(new LogicContext(proxyitself, targetObj));\n      }\n      switch (propKey) {\n        default:\n          //constructor.prototype.typeName\n          // se esiste la proprietà ma non esiste il getter, che fare? do errore?\n          // Log.eDevv(\"dev error: property exist but getter does not: \", propKey, this);\n          // console.error('proxy GET direct match', {targetObj, propKey, ret: this.d[propKey as keyof ME]});\n          // console.error('proxy GET direct match', {l:this.l});\n          return this.d[propKey];\n        case '$$typeof':\n        case \"typeName\":\n          return this.d.className;\n      }\n    }\n    // @ts-ignore\n    //console.trace(\"proxy $getter 2\", {targetObj, n:targetObj.name, propKey, l:this.lg, dg:this.lg._defaultGetter});\n\n    // if not exist check for children names\n\n    if (typeof propKey === \"string\" && propKey !== \"children\" && \"children\" in this.l) {\n      // __info_of_children__\n      let lchildren;\n      try {\n        lchildren = this.get(targetObj, 'children', proxyitself);\n      } catch (e) {\n        lchildren = [];\n      }\n      // let dchildren: DPointerTargetable[] = lchildren.map<DPointerTargetable>(l => l.__raw as any);\n      let lc;\n      let pk;\n      if (childrenKeys.includes(propKey[0])) {\n        pk = propKey.substring(1);\n        canThrowErrors = false;\n      } else pk = propKey;\n      for (lc of lchildren) {\n        var _lc;\n        let n = (_lc = lc) === null || _lc === void 0 ? void 0 : _lc.name;\n        if (n && n.toLowerCase() === pk.toLowerCase()) return lc;\n      }\n    }\n\n    // if custom generic getter exist\n    if (this.lg._defaultGetter) return this.lg._defaultGetter(new LogicContext(proxyitself, targetObj), propKey);\n\n    // if property do not exist, try a concatenation\n    let concatenationTentative = null;\n    try {\n      concatenationTentative = this.concatenableHandler(targetObj, propKey, proxyitself);\n    } catch (e) {}\n    if (concatenationTentative !== null) return concatenationTentative;\n    Log.ex(canThrowErrors, 'GET property \"' + propKey + '\" do not exist in object of type \"' + U.getType(this.l) + \" DType:\" + U.getType(this.l), {\n      logic: this.l,\n      data: targetObj\n    });\n    return undefined;\n    // todo: credo che con espressioni sui tipi siano tipizzabili tutti i return di proprietà note eccetto quelle ottenute per concatenazione.\n  }\n\n  defaultGetter(targetObj, key, proxyitself) {\n    if (!targetObj) return targetObj;\n    if (!targetObj._subMaps || !targetObj._subMaps[key]) return targetObj[key];\n    // if is a nexted subobject\n    let context = new MapLogicContext(proxyitself, targetObj, key, []);\n    let retRaw = this.lg[this.s + key];\n    return MapProxyHandler.mapWrap(targetObj[key], targetObj, this.additionalPath + '.' + key);\n  }\n  defaultSetter(targetObj, propKey, value, proxyitself) {\n    SetFieldAction.new(targetObj, propKey, value);\n    return true;\n  }\n  set(targetObj, propKey, value, proxyitself) {\n    let enableFallbackSetter = true;\n\n    // console.error('_proxy set PRE:', {targetObj, propKey, value, proxyitself, arguments});\n    // if (propKey in this.l || propKey in this.d || (this.l as GObject)[this.s + (propKey as string)] || (this.l as GObject)[(propKey as string)]) {\n    if (propKey in this.l || propKey in this.d || this.l[this.s + propKey]) {\n      // todo: il LogicContext passato come parametro risulta nell'autocompletion editor automaticamente generato, come passo un parametro senza passargli il parametro? uso arguments senza dichiararlo?\n      if (typeof propKey !== 'symbol' && this.s + propKey in this.lg) return this.lg[this.s + propKey](value, new LogicContext(proxyitself, targetObj));\n\n      // if custom generic getter exist\n      if (this.lg._defaultSetter) return this.lg._defaultSetter(value, new LogicContext(proxyitself, targetObj), propKey);\n      if (enableFallbackSetter) {\n        return this.defaultSetter(targetObj, propKey, value, proxyitself);\n        // new SetFieldAction(new LogicContext(proxyitself as any, targetObj).data as any, propKey as string, value); return true;\n      }\n      // if custom generic getter exist\n      if (this.lg._defaultSetter) return this.lg._defaultSetter(value, new LogicContext(proxyitself, targetObj), propKey);\n      // se esiste la proprietà ma non esiste il setter, che fare? do errore.\n      Log.eDevv(\"dev error: property exist but setter does not: \", propKey, this);\n      return false;\n    }\n    // if property do not exist\n    let breakpoint = 1;\n\n    // if custom generic getter exist\n    if (this.lg._defaultSetter) return this.lg._defaultSetter(value, new LogicContext(proxyitself, targetObj), propKey);\n    if (enableFallbackSetter && typeof (propKey === \"string\") && (propKey[0] === '_' || propKey.indexOf('tmp') > 0)) {\n      return this.defaultSetter(targetObj, propKey, value, proxyitself);\n      // new SetFieldAction(new LogicContext(proxyitself as any, targetObj).data as any, propKey as string, value); return true;\n    }\n\n    Log.exx('SET property \"set_' + propKey + '\" do not exist in object of type \"' + U.getType(this.l) + \" DType:\" + U.getType(this.l), {\n      'this': this,\n      targetObj\n    });\n    return false;\n  }\n  /*      problema: ogni oggetto deve avere multipli puntatori, quando ne modifico uno devo modificarli tutti, come tengo traccia?\r\n          ipotesi 1: lo memorizzo in un solo posto (store.idlookup) e uso Pointer<type, lb, ub> che è una stringa che simula un puntatore\r\n          problema 1: se fornisco l'intero store ai componenti si aggiornano ad ogni singola modifica, se estraggo i campi interesasti le stringhe puntatore sono invariate ma il contenuto puntato è cambiato e il componente non lo sa...\r\n          problemone 2: non so a quali proprietà dello store devo abbonarmi, devo leggere sempre tutto lo store?\r\n          !!!!! soluzione 2?: dovrei dichiarare le variabili a cui mi abbono, salvarle nello stato e precaricarle tramite mapStateToProps*/\n\n  deleteProperty(target, key, proxyItself) {\n    if (typeof key === \"symbol\") return false;\n    this.set(target, key, undefined, proxyItself);\n    delete target[key];\n    return true;\n  }\n  mergedObject(target) {\n    let ret = {\n      ...target\n    }; // U.arrayMergeInPlace(Object.keys(target), Object.keys(this.l).filter(k => k.indexOf('set_') !== 0 && k.indexOf('get_') !== 0));\n    for (let k in this.l) {\n      if (!(k in ret) && k.lastIndexOf('get_', 4) !== 0 && k.lastIndexOf('set_', 4) !== 0) ret[k] = true;\n    }\n    return ret;\n  }\n  ownKeys(target) {\n    const ret = this.mergedObject(target);\n    // ret = Reflect.ownKeys(ret);\n    return Reflect.ownKeys(ret);\n  }\n\n  // has(target: ME, p: string | symbol): boolean { return p in this.mergedObject(target); }\n  has(target, p) {\n    return p in target || p in this.l;\n  }\n\n  /*\r\n  apply(target: DModelElement, thisArg: any, argArray: any[]): any {\r\n      // will i ever use it? dovrei pasare una funzione invece di una classe, quindi in questo caso credo wrappi solo il costruttore\r\n  }*/\n}) || _class9);\nRuntimeAccessibleClass.set_extend(MyProxyHandler, TargetableProxyHandler);\nexport let MapProxyHandler = (_dec6 = RuntimeAccessible('MapProxyHandler'), _dec6(_class11 = class MapProxyHandler extends TargetableProxyHandler {\n  // todo: sposta alcune funzioni da TargetableProxy a MyProxy e fai estendere direttamente MyProxy a questa classe\n\n  constructor(d, baseObjInLookup) {\n    let additionalPath = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n    let subMapKeys = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    super(d, baseObjInLookup, additionalPath, LPointerTargetable.singleton);\n    this.subMapKeys = void 0;\n    this.subMapKeys = subMapKeys;\n  }\n  get(target, key, proxyitself) {\n    if (typeof key === \"symbol\") return this.d[key];\n    let val = this.d[key];\n    if (key in this.subMapKeys && !(key in target)) {\n      Log.exx('property not found in dictionary', {\n        target,\n        key,\n        thiss: this,\n        proxyitself,\n        submapkeys: this.subMapKeys\n      });\n      return undefined;\n    }\n    if (key in this.subMapKeys) {\n      this.additionalPath += '.';\n      return MapProxyHandler.mapWrap(this.d, this.baseObjInLookup, this.additionalPath, this.subMapKeys[key]);\n      Log.exDevv('todo: wrap sub-map', {\n        thiss: this\n      });\n    }\n    return target[key];\n  }\n  set(target, key, value, proxyitself) {\n    if (typeof key === \"symbol\") {\n      Log.exx('cannot set a symbol in dictionary', {\n        target,\n        key,\n        value,\n        proxyitself\n      });\n      return false;\n    }\n    SetRootFieldAction.new(this.additionalPath + '.' + key, value, '', false);\n    return true;\n  }\n  deleteProperty(target, key, proxyItself) {\n    if (typeof key === \"symbol\") return false;\n    this.set(target, key, undefined, proxyItself);\n    delete target[key];\n    return true;\n  }\n}) || _class11);\nRuntimeAccessibleClass.set_extend(MyProxyHandler, MapProxyHandler);\n// 15-20 min + 5 di domande entro il 1° ottobre, discussione 10-12 ottobre\nexport const getPath = new Proxy({}, new GetPathHandler());\nwindow.getPath = getPath;\n// usage: pathstring = ((getPath as DType).some.path.to.follow as any).$; // = \"some.path.to.follow\" with compilation-time validation","map":{"version":3,"names":["DPointerTargetable","JsType","Log","LPointerTargetable","RuntimeAccessible","RuntimeAccessibleClass","SetFieldAction","SetRootFieldAction","U","childrenKeys","LogicContext","_dec","_class","constructor","proxyObject","data","write","className","cname","name","set_extend","MapLogicContext","_dec2","_class3","proxy","path","subMaps","arguments","length","undefined","MyProxyHandler","_dec3","_class5","s","g","set","target","p","value","proxyitself","Error","deleteProperty","ownKeys","console","log","thiss","ret","Reflect","wrap","baseObjInLookup","canThrow","isProxy","__isProxy","GetPathHandler","_dec4","_class7","_class8","strbuilder","array","calls","get","targetObj","propKey","__asCalls","__asArray","push","Symbol","toPrimitive","_len","a","Array","_key","toString","__nested","TargetableProxyHandler","_dec5","_class9","d","additionalPath","l","lg","_RuntimeAccessibleCla","_RuntimeAccessibleCla2","logic","singleton","exDev","object","concatenableHandler","propKeyStr","asString","_index","indexOf","isConcatenable","split","map","subKey","val","isPrimitive","join","isError","get0","e","canThrowErrors","String","exDevv","id","JSON","stringify","Math","random","clonedCounter","proxyacceptables","typeName","$$typeof","getterMethod","lchildren","lc","pk","includes","substring","_lc","n","toLowerCase","_defaultGetter","concatenationTentative","ex","getType","defaultGetter","key","_subMaps","context","retRaw","MapProxyHandler","mapWrap","defaultSetter","new","enableFallbackSetter","_defaultSetter","eDevv","breakpoint","exx","proxyItself","mergedObject","k","lastIndexOf","has","_dec6","_class11","subMapKeys","submapkeys","getPath","Proxy","window"],"sources":["C:/d/Programming/web/jodel-mde/src/joiner/proxy.ts"],"sourcesContent":["import type {DocString, DtoL, DtoW, GObject, Proxyfied, WPointerTargetable,} from \"../joiner\";\r\nimport {\r\n    Dictionary,\r\n    DModelElement,\r\n    DPointerTargetable,\r\n    JsType,\r\n    LModelElement,\r\n    Log,\r\n    LPointerTargetable,\r\n    Pointer,\r\n    RuntimeAccessible,\r\n    RuntimeAccessibleClass,\r\n    SetFieldAction,\r\n    SetRootFieldAction,\r\n    U\r\n} from \"../joiner\";\r\n\r\ntype NotAConcatenation = null;\r\ntype ERROR = \"_Type_Error_\";\r\n\r\n// (DX extends DUser ? LUser : (DX extends DPointerTargetable ? LPointerTargetable : (ERROR))\r\n// (DX extends DUser ? LUser : (DX extends DPointerTargetable ? LPointerTargetable : (           WViewElement\r\n//\r\n// (IN extends WViewElement ? LViewElement : (IN extends WViewTransientProperties ? LWiewTransientProperties : (ERROR)))\r\n// ))\r\n// type WtoL<WX extends WPointerTargetable> ='';\r\n\r\nconst childrenKeys = [\"@\", \"$\"];\r\n@RuntimeAccessible('LogicContext')\r\nexport class LogicContext<\r\n    DX extends GObject = DModelElement,\r\n    LX = DtoL<DX>,\r\n    // PF extends MyProxyHandler<DX> = MyProxyHandler<DX>,\r\n    WX = DtoW<DX>\r\n    > extends RuntimeAccessibleClass{\r\n    public proxyObject: LX;\r\n    public data: DX;// & GObject;\r\n    public write: WX;\r\n    constructor(proxyObject: LX, data: DX) {\r\n        super();\r\n        this.className = (this.constructor as typeof RuntimeAccessibleClass).cname || this.constructor.name;\r\n        this.data = data;\r\n        this.proxyObject = proxyObject;\r\n        this.write = proxyObject as any;\r\n    }\r\n    /*\r\n        saveToRedux(propkey: \"keyof data\" | string, val: \"typeof data[path]\" | any): void { // todo: ask non stackoverflow\r\n            // todo, put data in redux store, path is \"obj1.obj2.obj3...\" might replace it with a path funciton that return the foremost nested object container\r\n            if (!propkey) {\r\n                // todo: set whole object instead of a property\r\n            }\r\n        }*/\r\n}\r\n\r\nRuntimeAccessibleClass.set_extend(RuntimeAccessibleClass, LogicContext);\r\n@RuntimeAccessible('MapLogicContext')\r\nexport class MapLogicContext extends LogicContext<GObject, LPointerTargetable, WPointerTargetable> {\r\n    data: GObject;\r\n    path: string;\r\n    subMaps: string[];\r\n    constructor(proxy: LPointerTargetable, data: GObject, path: string, subMaps: string[] = []) {\r\n        super(proxy, data);\r\n        // this.proxyfyFunction = proxyfyFunction;\r\n        this.proxyObject = proxy;\r\n        this.data = data;\r\n        this.path = path;\r\n        this.subMaps = subMaps;\r\n        this.className = (this.constructor as typeof RuntimeAccessibleClass).cname || this.constructor.name;\r\n    }\r\n}\r\nRuntimeAccessibleClass.set_extend(LogicContext, MapLogicContext);\r\n\r\n@RuntimeAccessible('MyProxyHandler')\r\nexport abstract class MyProxyHandler<T extends GObject> extends RuntimeAccessibleClass implements ProxyHandler<T>{\r\n    s: string = 'set_';\r\n    g: string = 'get_';\r\n    /*get(target: T, p: string | number | symbol, proxyitself: Proxyfied<T>): boolean {\r\n        switch (p) {\r\n            case '_isProxy': return true;\r\n            case 'init': return (this as any).init;\r\n            case 'init0': return (this as any).init0;\r\n            default: throw new Error('proxy get must be overridden, called for key: ' + (p as string));\r\n        }}*/\r\n    set(target: T, p: string | number | symbol, value: any, proxyitself: Proxyfied<T>): boolean { throw new Error('proxy set must be overridden'); }\r\n    deleteProperty(target: T, p: string | symbol): boolean { throw new Error('proxy delete must be overridden'); }\r\n\r\n    ownKeys(target: T): ArrayLike<string | symbol>{\r\n        // return Object.getOwnPropertyNames(target);\r\n        console.log(\"ownkeys trap 1\", {thiss:this, target})\r\n        console.log(\"ownkeys trap 2\", {thiss:this, target, ret:Reflect.ownKeys(target)});\r\n        return Reflect.ownKeys(target);\r\n    }\r\n    /// proxy methods not used\r\n    /* setPrototypeOf(target: T, v: object | null): boolean { ?? }\r\n    apply(target: T, thisArg: any, argArray: any[]): any { }\r\n    defineProperty(target: T, p: string | symbol, attributes: PropertyDescriptor): boolean { }\r\n    construct(target: T, argArray: any[], newTarget: Function): object { }\r\n    getOwnPropertyDescriptor(target: T, p: string | symbol): PropertyDescriptor | undefined { }\r\n    has(target: T, p: string | symbol): boolean { return p in target; }\r\n    getPrototypeOf(target: T): object | null { }\r\n    isExtensible(target: T): boolean { }\r\n    preventExtensions(target: T): boolean { }*/\r\n\r\n    static wrap<D extends RuntimeAccessibleClass, L extends LPointerTargetable = LPointerTargetable, CAN_THROW extends boolean = false,\r\n        RET extends CAN_THROW extends true ? L : L | undefined  = CAN_THROW extends true ? L : L>\r\n    (data: D | Pointer | undefined | null, baseObjInLookup?: DPointerTargetable, path: string = '', canThrow: CAN_THROW = false as CAN_THROW): RET{\r\n\r\n//    static wrap<D extends RuntimeAccessibleClass, L extends LPointerTargetable, RET extends boolean = false>\r\n//        (data: D | Pointer<DViewElement>, baseObjInLookup?: DPointerTargetable, path: string = '', canthrow: RET = false as RET): RET {\r\n        return DPointerTargetable.wrap(data, baseObjInLookup, path) as RET; }\r\n\r\n    static isProxy(data: GObject): boolean { return data?.__isProxy || false; }\r\n}\r\nRuntimeAccessibleClass.set_extend(RuntimeAccessibleClass, MyProxyHandler);\r\nexport type GetPath<T = GObject> = T;\r\n/*\r\n* handling proxy += and proxy -=\r\n*\r\n* will become var = var + add; which will call Symbol.getPrimitive\r\nconsole.log(+obj2);     // 10        — hint is \"number\"         NaN with +array with multiple vals, +array[0] with array of size 1, NaN with functions & objects\r\nconsole.log(`${obj2}`); // \"hello\"   — hint is \"string\"         array => array.join(','), object => \"[object Object]\", function => function.toString() whole func definition with body code\r\nconsole.log(obj2 + \"\"); // \"true\"    — hint is \"default\"        array, object, function => same as with hint \"string\"\r\n*\r\n* */\r\n\r\n// NB: lclass.extends += somepointer will become: lclass.extends = lclass.extends + somepointer;\r\n// array + string will cause getPrimitive(\"default\") to array, then .join(',') on it, and finally and toString() to be called on all array members.\r\n// so pointers cannot include \",\" char and toString() must return a pointer to keep lclass.extends += somepointer as a valid expression;\r\n// -= will call getPrimitive(\"number\") which will result in array -> NaN, so NaN = NaN - pointer and cannot be done.\r\n\r\n@RuntimeAccessible('GetPathHandler')\r\nclass GetPathHandler<T extends GObject> extends MyProxyHandler<T>{\r\n    public static __asCalls: boolean = false;\r\n    public static __asArray: boolean = false;\r\n    public static __nested: boolean = true;\r\n    private strbuilder: string = '';\r\n    private array: (string | number | symbol)[] = [];\r\n    private calls: (GObject<'parameters of get calls'>)[] = [];\r\n\r\n    public constructor() { super(); }\r\n\r\n    get(targetObj: T, propKey: keyof T | string, proxyitself: Proxyfied<T>): any {\r\n        // console.log('GetPathHandler', {targetObj, propKey, proxyitself});\r\n        if (propKey === \"start\") { this.strbuilder = ''; this.array = []; }\r\n        if (propKey === '$') {\r\n            const ret = GetPathHandler.__asCalls ? this.calls : (GetPathHandler.__asArray ? this.array : this.strbuilder);\r\n            this.array = [];\r\n            this.strbuilder = '';\r\n            return ret; }\r\n        this.array.push(propKey);\r\n        this.calls.push(arguments);\r\n        if (propKey === Symbol.toPrimitive) {\r\n            console.log(\"toprimitive\");\r\n            return (...a: any)=> {console.log(\"toprimitive called with parameters\", a); }\r\n        }\r\n        if (!GetPathHandler.__asArray && !GetPathHandler.__asCalls) {\r\n            if (typeof propKey === \"symbol\") { this.strbuilder += propKey.toString(); }\r\n            else {\r\n                // Giordano: add ignore for webpack\r\n                //@ts-ignore\r\n                this.strbuilder += (this.strbuilder ? '.' : '') + propKey;\r\n            }\r\n        }\r\n        return GetPathHandler.__nested ? proxyitself : {};\r\n    }\r\n\r\n    set(target: T, p: string | number | symbol, value: any, proxyitself: Proxyfied<T>): boolean {\r\n        switch(p){\r\n            case '__asArray':\r\n            case '__asCalls':\r\n            case '__nested':\r\n                (GetPathHandler as any)[p] = value;\r\n                return true;\r\n            default:\r\n                throw new Error('getPath proxy cannot be written');\r\n        }\r\n    }\r\n}\r\nRuntimeAccessibleClass.set_extend(MyProxyHandler, GetPathHandler);\r\n@RuntimeAccessible('TargetableProxyHandler')\r\nexport class TargetableProxyHandler<ME extends GObject = DModelElement, LE extends LPointerTargetable = LModelElement> extends MyProxyHandler<ME> {\r\n// permette di fare cose tipo: user.name_surname che ritorna la concatenazione di nome e cognome anche se il campo name_surname non esiste.\r\n    lg: LE & GObject; // to disable type check easily and access 'set_' + varname dynamically\r\n    l: LE;\r\n    d: ME;\r\n    additionalPath: string;\r\n\r\n    public baseObjInLookup: DPointerTargetable;\r\n\r\n    constructor(d: ME, baseObjInLookup?: DPointerTargetable, additionalPath: string = '', l?: LE) {\r\n        super();\r\n        this.d = d;\r\n        if (!l) {\r\n            l = RuntimeAccessibleClass.get(d?.className)?.logic?.singleton as LE;\r\n            Log.exDev(!l, 'Trying to wrap class without singleton or logic mapped: ' + d?.className, { object: d, className: d.className })\r\n        }\r\n        this.baseObjInLookup = baseObjInLookup || d as any;\r\n        this.additionalPath = additionalPath;\r\n        this.l = l as LE;\r\n        this.lg = this.l;\r\n        this.className = (this.constructor as typeof RuntimeAccessibleClass).cname || this.constructor.name;\r\n    }\r\n\r\n    // damiano todo: this does not work\r\n    private concatenableHandler(targetObj: ME, propKey: number | string | symbol, proxyitself: Proxyfied<ME>): NotAConcatenation | any[] | string {\r\n        //console.log(\"concatenableHandler 1\", {targetObj, propKey, proxyitself});\r\n        if (propKey in targetObj)  return null as NotAConcatenation;\r\n        const propKeyStr: null | string = U.asString(propKey, null);\r\n        let _index: number = propKeyStr ? propKeyStr.indexOf('_') : -1;\r\n        //console.log(\"concatenableHandler 2\", {targetObj, propKey, propKeyStr, proxyitself, _index});\r\n        if (_index < 0) return null as NotAConcatenation;\r\n\r\n        let isConcatenable = true;\r\n        let ret: any[] = (propKey as string).split('_').map( (subKey: string) => {\r\n            //console.log(\"concatenableHandler 3.0\", {targetObj, subKey, propKeyStr, proxyitself});\r\n            // se trovo multipli ___ li tratto come spazi aggiuntivi invece che come proprietà '' che ritornano undefined, così posso fare name___surname --> \"damiano   di vincenzo\"\r\n            let val: any = subKey === '' ? ' ' : this.get(targetObj, subKey, proxyitself);\r\n            isConcatenable = isConcatenable && JsType.isPrimitive(val);\r\n            return val;\r\n        });\r\n        //console.log(\"concatenableHandler 4\", {targetObj, propKey, propKeyStr, proxyitself, ret, isConcatenable});\r\n        return isConcatenable ? ret.join(' ') : ret; }\r\n\r\n    public get(targetObj: ME, propKey: string | symbol, proxyitself: Proxyfied<ME>): any {\r\n        let ret;\r\n        let isError = false;\r\n        // console.error('_proxy get PRE:', {targetObj, propKey, proxyitself, arguments});\r\n        try { ret = this.get0(targetObj, propKey, proxyitself); } catch(e) { ret = e; isError = true;}\r\n\r\n        // if (isError) throw ret;\r\n        // console.error('_proxy get POST:', {targetObj, propKey, ret, isError});\r\n        return ret;\r\n    }\r\n\r\n    public get0(targetObj: ME, propKey: string | symbol, proxyitself: Proxyfied<ME>): any {\r\n        // console.log('proxy keysearch', {propKey, targetObj, l: this.l, proxyitself, d: this.d});\r\n        let canThrowErrors = true;\r\n        if (propKey === \"__raw\") return targetObj;\r\n\r\n        switch(typeof propKey){\r\n            case \"symbol\":\r\n                switch(String(propKey)){\r\n                    default: Log.exDevv('unexpected  in proxy getter:', propKey); break;\r\n                    case \"Symbol(Symbol.toPrimitive)\": return (targetObj as any)[propKey];//  || typeof targetObj;\r\n                }\r\n                return null;\r\n            case \"number\": return null;\r\n        }\r\n\r\n        switch (propKey) {\r\n            case '__l': return this.l;\r\n            case '__d': return this.d;\r\n            case 'inspect': // node.js util\r\n            case \"r\":\r\n            case \"_refresh\":\r\n            case \"_reload\": return LPointerTargetable.wrap(targetObj.id);\r\n            case '__Raw':\r\n            case '__raw': return targetObj;\r\n            case '__serialize': return JSON.stringify(targetObj);\r\n            case '__isproxy':\r\n            case '__isProxy': return true;\r\n            case '__random': return Math.random();\r\n            case 'editCount':\r\n            case 'clonedcounter':\r\n            case 'clonedCounter':\r\n                return targetObj.clonedCounter || 0;\r\n        }\r\n        if (propKey[0] === \"_\" && propKey.indexOf(\"__info_of__\")===0) {\r\n            return (this.l as GObject)[propKey];\r\n        }\r\n\r\n\r\n        const proxyacceptables = {typeName:'', $$typeof:''};\r\n        // check if exist directly in D.key, L.key or through a get_key\r\n        if (propKey in this.l || propKey in this.d || (this.l as GObject)[this.g + (propKey as string)] || propKey in proxyacceptables) {\r\n            // todo: il LogicContext passato come parametro risulta nell'autocompletion editor automaticamente generato, come passo un parametro senza passargli il parametro? uso arguments senza dichiararlo?\r\n            if (typeof propKey !== 'symbol' && this.g + propKey in this.lg) return this.lg[this.g + propKey](new LogicContext(proxyitself as any, targetObj));\r\n\r\n\r\n\r\n            // if specific custom getter exist\r\n            if (typeof propKey !== 'symbol' && this.g + propKey in this.lg) {\r\n                let getterMethod: Function = this.lg[this.g + propKey]; // || this.defaultGetter;\r\n                // console.log(\"gets method\", {getterMethod, lg:this.lg, thiss: this});\r\n                if (getterMethod) return getterMethod(new LogicContext(proxyitself as any, targetObj));\r\n\r\n            }\r\n\r\n\r\n            switch (propKey){\r\n                default:\r\n                    //constructor.prototype.typeName\r\n                    // se esiste la proprietà ma non esiste il getter, che fare? do errore?\r\n                    // Log.eDevv(\"dev error: property exist but getter does not: \", propKey, this);\r\n                    // console.error('proxy GET direct match', {targetObj, propKey, ret: this.d[propKey as keyof ME]});\r\n                    // console.error('proxy GET direct match', {l:this.l});\r\n                    return this.d[propKey as keyof ME];\r\n                case '$$typeof':\r\n                case \"typeName\":\r\n                    return this.d.className;\r\n            }\r\n        }\r\n        // @ts-ignore\r\n        //console.trace(\"proxy $getter 2\", {targetObj, n:targetObj.name, propKey, l:this.lg, dg:this.lg._defaultGetter});\r\n\r\n        // if not exist check for children names\r\n\r\n        if (typeof propKey === \"string\" && propKey !== \"children\" && (\"children\" in this.l)) { // __info_of_children__\r\n            let lchildren: LPointerTargetable[];\r\n            try { lchildren = this.get(targetObj, 'children', proxyitself); }\r\n            catch (e) { lchildren = []; }\r\n            // let dchildren: DPointerTargetable[] = lchildren.map<DPointerTargetable>(l => l.__raw as any);\r\n            let lc: GObject;\r\n            let pk: string;\r\n            if (childrenKeys.includes(propKey[0])) { pk = propKey.substring(1); canThrowErrors = false; }\r\n            else pk = propKey;\r\n            for (lc of lchildren) {\r\n                let n = lc?.name;\r\n                if (n && n.toLowerCase() === pk.toLowerCase()) return lc;\r\n            }\r\n        }\r\n\r\n        // if custom generic getter exist\r\n        if (this.lg._defaultGetter) return this.lg._defaultGetter(new LogicContext(proxyitself as any, targetObj), propKey);\r\n\r\n        // if property do not exist, try a concatenation\r\n        let concatenationTentative = null;\r\n        try {concatenationTentative = this.concatenableHandler(targetObj, propKey, proxyitself); } catch(e) {}\r\n        if (concatenationTentative !== null) return concatenationTentative;\r\n        Log.ex(canThrowErrors,'GET property \"'+ (propKey as any)+ '\" do not exist in object of type \"' + U.getType(this.l) + \" DType:\" +  U.getType(this.l), {logic: this.l, data: targetObj});\r\n        return undefined;\r\n        // todo: credo che con espressioni sui tipi siano tipizzabili tutti i return di proprietà note eccetto quelle ottenute per concatenazione.\r\n    }\r\n\r\n    public defaultGetter(targetObj: ME, key: string, proxyitself: Proxyfied<ME>): any {\r\n        if (!targetObj) return targetObj;\r\n        if (!targetObj._subMaps || !targetObj._subMaps[key]) return (targetObj as Dictionary)[key];\r\n        // if is a nexted subobject\r\n        let context: MapLogicContext = new MapLogicContext(proxyitself as any, targetObj, key, []);\r\n        let retRaw: Dictionary = this.lg[this.s + key]\r\n        return MapProxyHandler.mapWrap((targetObj as Dictionary)[key], targetObj as any, this.additionalPath + '.' + key)\r\n    }\r\n\r\n    public defaultSetter(targetObj: DPointerTargetable, propKey: string, value: any, proxyitself?: Proxyfied<ME>): boolean {\r\n        SetFieldAction.new(targetObj, propKey as any, value);\r\n        return true;\r\n    }\r\n\r\n    public set(targetObj: ME, propKey: string | symbol, value: any, proxyitself?: Proxyfied<ME>): boolean {\r\n        let enableFallbackSetter = true;\r\n\r\n        // console.error('_proxy set PRE:', {targetObj, propKey, value, proxyitself, arguments});\r\n        // if (propKey in this.l || propKey in this.d || (this.l as GObject)[this.s + (propKey as string)] || (this.l as GObject)[(propKey as string)]) {\r\n        if (propKey in this.l || propKey in this.d || (this.l as GObject)[this.s + (propKey as string)]) {\r\n            // todo: il LogicContext passato come parametro risulta nell'autocompletion editor automaticamente generato, come passo un parametro senza passargli il parametro? uso arguments senza dichiararlo?\r\n            if (typeof propKey !== 'symbol' && this.s + propKey in this.lg) return this.lg[this.s + propKey](value, new LogicContext(proxyitself as any, targetObj));\r\n\r\n\r\n\r\n            // if custom generic getter exist\r\n            if (this.lg._defaultSetter) return this.lg._defaultSetter(value, new LogicContext(proxyitself as any, targetObj), propKey);\r\n            if (enableFallbackSetter) {\r\n                return this.defaultSetter(targetObj as any as DPointerTargetable, propKey as string, value, proxyitself);\r\n                // new SetFieldAction(new LogicContext(proxyitself as any, targetObj).data as any, propKey as string, value); return true;\r\n            }\r\n            // if custom generic getter exist\r\n            if (this.lg._defaultSetter) return this.lg._defaultSetter(value, new LogicContext(proxyitself as any, targetObj), propKey);\r\n            // se esiste la proprietà ma non esiste il setter, che fare? do errore.\r\n            Log.eDevv(\"dev error: property exist but setter does not: \", propKey, this);\r\n            return false;\r\n        }\r\n        // if property do not exist\r\n        let breakpoint = 1;\r\n\r\n        // if custom generic getter exist\r\n        if (this.lg._defaultSetter) return this.lg._defaultSetter(value, new LogicContext(proxyitself as any, targetObj), propKey);\r\n        if (enableFallbackSetter && typeof (propKey === \"string\") && ((propKey as string)[0] === '_' || (propKey as string).indexOf('tmp') > 0)) {\r\n            return this.defaultSetter(targetObj as any as DPointerTargetable, propKey as string, value, proxyitself);\r\n            // new SetFieldAction(new LogicContext(proxyitself as any, targetObj).data as any, propKey as string, value); return true;\r\n        }\r\n        Log.exx('SET property \"set_' + (propKey as any) + '\" do not exist in object of type \"' + U.getType(this.l) + \" DType:\" +  U.getType(this.l), {'this': this, targetObj});\r\n        return false; }\r\n    /*      problema: ogni oggetto deve avere multipli puntatori, quando ne modifico uno devo modificarli tutti, come tengo traccia?\r\n            ipotesi 1: lo memorizzo in un solo posto (store.idlookup) e uso Pointer<type, lb, ub> che è una stringa che simula un puntatore\r\n            problema 1: se fornisco l'intero store ai componenti si aggiornano ad ogni singola modifica, se estraggo i campi interesasti le stringhe puntatore sono invariate ma il contenuto puntato è cambiato e il componente non lo sa...\r\n            problemone 2: non so a quali proprietà dello store devo abbonarmi, devo leggere sempre tutto lo store?\r\n            !!!!! soluzione 2?: dovrei dichiarare le variabili a cui mi abbono, salvarle nello stato e precaricarle tramite mapStateToProps*/\r\n\r\n    public deleteProperty(target: ME, key: string | symbol, proxyItself?: Proxyfied<any>): boolean {\r\n        if (typeof key === \"symbol\") return false;\r\n        this.set(target, key, undefined, proxyItself);\r\n        delete target[key];\r\n        return true; }\r\n\r\n    private mergedObject(target: ME): GObject{\r\n        let ret: GObject = {...target}; // U.arrayMergeInPlace(Object.keys(target), Object.keys(this.l).filter(k => k.indexOf('set_') !== 0 && k.indexOf('get_') !== 0));\r\n        for (let k in this.l) {\r\n            if (!(k in ret) && k.lastIndexOf('get_', 4) !== 0 && k.lastIndexOf('set_', 4) !== 0) ret[k] = true;\r\n        }\r\n        return ret;\r\n    }\r\n    ownKeys(target: ME): ArrayLike<string | symbol>{\r\n        const ret: GObject = this.mergedObject(target);\r\n        // ret = Reflect.ownKeys(ret);\r\n        return Reflect.ownKeys(ret);\r\n    }\r\n\r\n    // has(target: ME, p: string | symbol): boolean { return p in this.mergedObject(target); }\r\n    has(target: ME, p: string | symbol): boolean { return (p in target) || (p in this.l); }\r\n\r\n    /*\r\n    apply(target: DModelElement, thisArg: any, argArray: any[]): any {\r\n        // will i ever use it? dovrei pasare una funzione invece di una classe, quindi in questo caso credo wrappi solo il costruttore\r\n    }*/\r\n}\r\nRuntimeAccessibleClass.set_extend(MyProxyHandler, TargetableProxyHandler);\r\n@RuntimeAccessible('MapProxyHandler')\r\nexport class MapProxyHandler extends TargetableProxyHandler<Dictionary, LPointerTargetable> {\r\n    // todo: sposta alcune funzioni da TargetableProxy a MyProxy e fai estendere direttamente MyProxy a questa classe\r\n    public subMapKeys: Dictionary<string, any | Dictionary<DocString<'nested map keys'>>>;\r\n\r\n    constructor(d: Dictionary, baseObjInLookup: DPointerTargetable, additionalPath: string = '', subMapKeys: Dictionary<string, any | Dictionary<DocString<'nested map keys'>>> = {}) {\r\n        super(d, baseObjInLookup, additionalPath, LPointerTargetable.singleton);\r\n        this.subMapKeys = subMapKeys;\r\n    }\r\n\r\n    get(target: Dictionary, key: string | number | symbol, proxyitself: Proxyfied<Dictionary>): any {\r\n        if (typeof key === \"symbol\") return this.d[key as any];\r\n        let val: any = this.d[key];\r\n        if (key in this.subMapKeys && !(key in target)) { Log.exx('property not found in dictionary', {target, key, thiss:this, proxyitself, submapkeys: this.subMapKeys}); return undefined; }\r\n        if (key in this.subMapKeys) {\r\n            this.additionalPath += '.';\r\n            return MapProxyHandler.mapWrap( this.d, this.baseObjInLookup, this.additionalPath, this.subMapKeys[key]);\r\n            Log.exDevv('todo: wrap sub-map', {thiss: this});\r\n        }\r\n        return target[key as string]; }\r\n\r\n    set(target: Dictionary, key: string | number | symbol, value: any, proxyitself: Proxyfied<Dictionary>): boolean {\r\n        if (typeof key === \"symbol\") { Log.exx('cannot set a symbol in dictionary', {target, key, value, proxyitself}); return false; }\r\n        SetRootFieldAction.new(this.additionalPath + '.' + key, value, '',false)\r\n        return true;\r\n    }\r\n\r\n    public deleteProperty(target: Dictionary, key: string | symbol, proxyItself?: Proxyfied<any>): boolean {\r\n        if (typeof key === \"symbol\") return false;\r\n        this.set(target, key, undefined, proxyItself);\r\n        delete target[key];\r\n        return true; }\r\n}\r\nRuntimeAccessibleClass.set_extend(MyProxyHandler, MapProxyHandler);\r\n// 15-20 min + 5 di domande entro il 1° ottobre, discussione 10-12 ottobre\r\nexport const getPath: GetPath = new Proxy( {}, new GetPathHandler());\r\n(window as any).getPath = getPath;\r\n// usage: pathstring = ((getPath as DType).some.path.to.follow as any).$; // = \"some.path.to.follow\" with compilation-time validation\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}