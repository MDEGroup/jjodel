{"ast":null,"code":"import _slicedToArray from \"C:/d/Programming/web/jodel-mde/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _toConsumableArray from \"C:/d/Programming/web/jodel-mde/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _createForOfIteratorHelper from \"C:/d/Programming/web/jodel-mde/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\nimport { maximePlaceHolderId, placeHolderStyle } from \"./DockData\";\nvar _watchObjectChange = new WeakMap();\nexport function getUpdatedObject(obj) {\n  var result = _watchObjectChange.get(obj);\n  if (result) {\n    return getUpdatedObject(result);\n  }\n  return obj;\n}\nfunction clearObjectCache() {\n  _watchObjectChange = new WeakMap();\n}\nfunction clone(value, extra) {\n  var newValue = Object.assign(Object.assign({}, value), extra);\n  if (Array.isArray(newValue.tabs)) {\n    newValue.tabs = newValue.tabs.concat();\n  }\n  if (Array.isArray(newValue.children)) {\n    newValue.children = newValue.children.concat();\n  }\n  _watchObjectChange.set(value, newValue);\n  return newValue;\n}\nvar _idCount = 0;\nexport function nextId() {\n  ++_idCount;\n  return \"+\".concat(_idCount);\n}\nvar _zCount = 0;\nexport function nextZIndex(current) {\n  if (current === _zCount) {\n    // already the top\n    return current;\n  }\n  return ++_zCount;\n}\nfunction findInPanel(panel, id, filter) {\n  if (panel.id === id && filter & Filter.Panel) {\n    return panel;\n  }\n  if (filter & Filter.Tab) {\n    var _iterator = _createForOfIteratorHelper(panel.tabs),\n      _step;\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var tab = _step.value;\n        if (tab.id === id) {\n          return tab;\n        }\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n  }\n  return null;\n}\nfunction findInBox(box, id, filter) {\n  var result;\n  if (filter | Filter.Box && box.id === id) {\n    return box;\n  }\n  var _iterator2 = _createForOfIteratorHelper(box.children),\n    _step2;\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var child = _step2.value;\n      if ('children' in child) {\n        if (result = findInBox(child, id, filter)) {\n          break;\n        }\n      } else if ('tabs' in child) {\n        if (result = findInPanel(child, id, filter)) {\n          break;\n        }\n      }\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n  return result;\n}\nexport var Filter;\n(function (Filter) {\n  Filter[Filter[\"Tab\"] = 1] = \"Tab\";\n  Filter[Filter[\"Panel\"] = 2] = \"Panel\";\n  Filter[Filter[\"Box\"] = 4] = \"Box\";\n  Filter[Filter[\"Docked\"] = 8] = \"Docked\";\n  Filter[Filter[\"Floated\"] = 16] = \"Floated\";\n  Filter[Filter[\"Windowed\"] = 32] = \"Windowed\";\n  Filter[Filter[\"Max\"] = 64] = \"Max\";\n  Filter[Filter[\"EveryWhere\"] = 120] = \"EveryWhere\";\n  Filter[Filter[\"AnyTab\"] = 121] = \"AnyTab\";\n  Filter[Filter[\"AnyPanel\"] = 122] = \"AnyPanel\";\n  Filter[Filter[\"AnyTabPanel\"] = 123] = \"AnyTabPanel\";\n  Filter[Filter[\"All\"] = 127] = \"All\";\n})(Filter || (Filter = {}));\nexport function find(layout, id) {\n  var filter = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Filter.AnyTabPanel;\n  var result;\n  if (filter & Filter.Docked) {\n    result = findInBox(layout.dockbox, id, filter);\n  }\n  if (result) return result;\n  if (filter & Filter.Floated) {\n    result = findInBox(layout.floatbox, id, filter);\n  }\n  if (result) return result;\n  if (filter & Filter.Windowed) {\n    result = findInBox(layout.windowbox, id, filter);\n  }\n  if (result) return result;\n  if (filter & Filter.Max) {\n    result = findInBox(layout.maxbox, id, filter);\n  }\n  return result;\n}\nexport function addNextToTab(layout, source, target, direction) {\n  var pos = target.parent.tabs.indexOf(target);\n  if (pos >= 0) {\n    if (direction === 'after-tab') {\n      ++pos;\n    }\n    return addTabToPanel(layout, source, target.parent, pos);\n  }\n  return layout;\n}\nexport function addTabToPanel(layout, source, panel) {\n  var idx = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : -1;\n  if (idx === -1) {\n    idx = panel.tabs.length;\n  }\n  var tabs;\n  var activeId;\n  if ('tabs' in source) {\n    // source is PanelData\n    tabs = source.tabs;\n    activeId = source.activeId;\n  } else {\n    // source is TabData\n    tabs = [source];\n  }\n  if (tabs.length) {\n    var _newPanel$tabs;\n    var newPanel = clone(panel);\n    (_newPanel$tabs = newPanel.tabs).splice.apply(_newPanel$tabs, [idx, 0].concat(_toConsumableArray(tabs)));\n    newPanel.activeId = tabs[tabs.length - 1].id;\n    var _iterator3 = _createForOfIteratorHelper(tabs),\n      _step3;\n    try {\n      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n        var tab = _step3.value;\n        tab.parent = newPanel;\n      }\n    } catch (err) {\n      _iterator3.e(err);\n    } finally {\n      _iterator3.f();\n    }\n    if (activeId) {\n      newPanel.activeId = activeId;\n    }\n    layout = replacePanel(layout, panel, newPanel);\n  }\n  return layout;\n}\nexport function converToPanel(source) {\n  if ('tabs' in source) {\n    // source is already PanelData\n    return source;\n  } else {\n    var newPanel = {\n      tabs: [source],\n      group: source.group,\n      activeId: source.id\n    };\n    source.parent = newPanel;\n    return newPanel;\n  }\n}\nexport function dockPanelToPanel(layout, newPanel, panel, direction) {\n  var box = panel.parent;\n  var dockMode = direction === 'left' || direction === 'right' ? 'horizontal' : 'vertical';\n  var afterPanel = direction === 'bottom' || direction === 'right';\n  var pos = box.children.indexOf(panel);\n  if (pos >= 0) {\n    var newBox = clone(box);\n    if (dockMode === box.mode) {\n      if (afterPanel) {\n        ++pos;\n      }\n      panel.size *= 0.5;\n      newPanel.size = panel.size;\n      newBox.children.splice(pos, 0, newPanel);\n    } else {\n      var newChildBox = {\n        mode: dockMode,\n        children: []\n      };\n      newChildBox.size = panel.size;\n      if (afterPanel) {\n        newChildBox.children = [panel, newPanel];\n      } else {\n        newChildBox.children = [newPanel, panel];\n      }\n      panel.parent = newChildBox;\n      panel.size = 200;\n      newPanel.parent = newChildBox;\n      newPanel.size = 200;\n      newBox.children[pos] = newChildBox;\n      newChildBox.parent = newBox;\n    }\n    return replaceBox(layout, box, newBox);\n  }\n  return layout;\n}\nexport function dockPanelToBox(layout, newPanel, box, direction) {\n  var parentBox = box.parent;\n  var dockMode = direction === 'left' || direction === 'right' ? 'horizontal' : 'vertical';\n  var afterPanel = direction === 'bottom' || direction === 'right';\n  if (parentBox) {\n    var pos = parentBox.children.indexOf(box);\n    if (pos >= 0) {\n      var newParentBox = clone(parentBox);\n      if (dockMode === parentBox.mode) {\n        if (afterPanel) {\n          ++pos;\n        }\n        newPanel.size = box.size * 0.3;\n        box.size *= 0.7;\n        newParentBox.children.splice(pos, 0, newPanel);\n      } else {\n        var newChildBox = {\n          mode: dockMode,\n          children: []\n        };\n        newChildBox.size = box.size;\n        if (afterPanel) {\n          newChildBox.children = [box, newPanel];\n        } else {\n          newChildBox.children = [newPanel, box];\n        }\n        box.parent = newChildBox;\n        box.size = 280;\n        newPanel.parent = newChildBox;\n        newPanel.size = 120;\n        newParentBox.children[pos] = newChildBox;\n      }\n      return replaceBox(layout, parentBox, newParentBox);\n    }\n  } else if (box === layout.dockbox) {\n    var newBox = clone(box);\n    if (dockMode === box.mode) {\n      var _pos = 0;\n      if (afterPanel) {\n        _pos = newBox.children.length;\n      }\n      newPanel.size = box.size * 0.3;\n      box.size *= 0.7;\n      newBox.children.splice(_pos, 0, newPanel);\n      return replaceBox(layout, box, newBox);\n    } else {\n      // replace root dockbox\n      var newDockBox = {\n        mode: dockMode,\n        children: []\n      };\n      newDockBox.size = box.size;\n      if (afterPanel) {\n        newDockBox.children = [newBox, newPanel];\n      } else {\n        newDockBox.children = [newPanel, newBox];\n      }\n      newBox.size = 280;\n      newPanel.size = 120;\n      return replaceBox(layout, box, newDockBox);\n    }\n  } else if (box === layout.maxbox) {\n    var _newBox = clone(box);\n    _newBox.children.push(newPanel);\n    return replaceBox(layout, box, _newBox);\n  }\n  return layout;\n}\nexport function floatPanel(layout, newPanel, rect) {\n  var newBox = clone(layout.floatbox);\n  if (rect) {\n    newPanel.x = rect.left;\n    newPanel.y = rect.top;\n    newPanel.w = rect.width;\n    newPanel.h = rect.height;\n  }\n  newBox.children.push(newPanel);\n  return replaceBox(layout, layout.floatbox, newBox);\n}\nexport function panelToWindow(layout, newPanel) {\n  var newBox = clone(layout.windowbox);\n  newBox.children.push(newPanel);\n  return replaceBox(layout, layout.windowbox, newBox);\n}\nexport function removeFromLayout(layout, source) {\n  if (source) {\n    var panelData;\n    if ('tabs' in source) {\n      panelData = source;\n      layout = removePanel(layout, panelData);\n    } else {\n      panelData = source.parent;\n      layout = removeTab(layout, source);\n    }\n    if (panelData && panelData.parent && panelData.parent.mode === 'maximize') {\n      var newPanel = layout.maxbox.children[0];\n      if (!newPanel || newPanel.tabs.length === 0 && !newPanel.panelLock) {\n        // max panel is gone, remove the place holder\n        var placeHolder = find(layout, maximePlaceHolderId);\n        if (placeHolder) {\n          return removePanel(layout, placeHolder);\n        }\n      }\n    }\n  }\n  return layout;\n}\nfunction removePanel(layout, panel) {\n  var box = panel.parent;\n  if (box) {\n    var pos = box.children.indexOf(panel);\n    if (pos >= 0) {\n      var newBox = clone(box);\n      newBox.children.splice(pos, 1);\n      return replaceBox(layout, box, newBox);\n    }\n  }\n  return layout;\n}\nfunction removeTab(layout, tab) {\n  var panel = tab.parent;\n  if (panel) {\n    var pos = panel.tabs.indexOf(tab);\n    if (pos >= 0) {\n      var newPanel = clone(panel);\n      newPanel.tabs.splice(pos, 1);\n      if (newPanel.activeId === tab.id) {\n        // update selection id\n        if (newPanel.tabs.length > pos) {\n          newPanel.activeId = newPanel.tabs[pos].id;\n        } else if (newPanel.tabs.length) {\n          newPanel.activeId = newPanel.tabs[0].id;\n        }\n      }\n      return replacePanel(layout, panel, newPanel);\n    }\n  }\n  return layout;\n}\nexport function moveToFront(layout, source) {\n  if (source) {\n    var panelData;\n    var needUpdate = false;\n    var changes = {};\n    if ('tabs' in source) {\n      panelData = source;\n    } else {\n      panelData = source.parent;\n      if (panelData.activeId !== source.id) {\n        // move tab to front\n        changes.activeId = source.id;\n        needUpdate = true;\n      }\n    }\n    if (panelData && panelData.parent && panelData.parent.mode === 'float') {\n      // move float panel to front\n      var newZ = nextZIndex(panelData.z);\n      if (newZ !== panelData.z) {\n        changes.z = newZ;\n        needUpdate = true;\n      }\n    }\n    if (needUpdate) {\n      layout = replacePanel(layout, panelData, clone(panelData, changes));\n    }\n  }\n  return layout;\n}\n// maximize or restore the panel\nexport function maximize(layout, source) {\n  if (source) {\n    if ('tabs' in source) {\n      if (source.parent.mode === 'maximize') {\n        return restorePanel(layout, source);\n      } else {\n        return maximizePanel(layout, source);\n      }\n    } else {\n      return maximizeTab(layout, source);\n    }\n  }\n  return layout;\n}\nfunction maximizePanel(layout, panel) {\n  var maxbox = layout.maxbox;\n  if (maxbox.children.length) {\n    // invalid maximize\n    return layout;\n  }\n  var placeHodlerPanel = Object.assign(Object.assign({}, panel), {\n    id: maximePlaceHolderId,\n    tabs: [],\n    panelLock: {}\n  });\n  layout = replacePanel(layout, panel, placeHodlerPanel);\n  layout = dockPanelToBox(layout, panel, layout.maxbox, 'middle');\n  return layout;\n}\nfunction restorePanel(layout, panel) {\n  layout = removePanel(layout, panel);\n  var placeHolder = find(layout, maximePlaceHolderId);\n  if (placeHolder) {\n    var x = placeHolder.x,\n      y = placeHolder.y,\n      z = placeHolder.z,\n      w = placeHolder.w,\n      h = placeHolder.h;\n    panel = Object.assign(Object.assign({}, panel), {\n      x: x,\n      y: y,\n      z: z,\n      w: w,\n      h: h\n    });\n    return replacePanel(layout, placeHolder, panel);\n  } else {\n    return dockPanelToBox(layout, panel, layout.dockbox, 'right');\n  }\n}\nfunction maximizeTab(layout, tab) {\n  // TODO to be implemented\n  return layout;\n}\n// move float panel into the screen\nexport function fixFloatPanelPos(layout, layoutWidth, layoutHeight) {\n  var layoutChanged = false;\n  if (layout && layout.floatbox && layoutWidth > 200 && layoutHeight > 200) {\n    var newFloatChildren = layout.floatbox.children.concat();\n    for (var i = 0; i < newFloatChildren.length; ++i) {\n      var panel = newFloatChildren[i];\n      var panelChange = {};\n      if (panel.w > layoutWidth) {\n        panelChange.w = layoutWidth;\n      }\n      if (panel.h > layoutHeight) {\n        panelChange.h = layoutHeight;\n      }\n      if (panel.y > layoutHeight - 16) {\n        panelChange.y = Math.max(layoutHeight - 16 - (panel.h >> 1), 0);\n      } else if (panel.y < 0) {\n        panelChange.y = 0;\n      }\n      if (panel.x + panel.w < 16) {\n        panelChange.x = 16 - (panel.w >> 1);\n      } else if (panel.x > layoutWidth - 16) {\n        panelChange.x = layoutWidth - 16 - (panel.w >> 1);\n      }\n      if (Object.keys(panelChange).length) {\n        newFloatChildren[i] = clone(panel, panelChange);\n        layoutChanged = true;\n      }\n    }\n    if (layoutChanged) {\n      var newBox = clone(layout.floatbox);\n      newBox.children = newFloatChildren;\n      return replaceBox(layout, layout.floatbox, newBox);\n    }\n  }\n  return layout;\n}\nexport function fixLayoutData(layout, loadTab) {\n  function fixpanelOrBox(d) {\n    if (d.id == null) {\n      d.id = nextId();\n    } else if (d.id.startsWith('+')) {\n      var idnum = Number(d.id);\n      if (idnum > _idCount) {\n        // make sure generated id is unique\n        _idCount = idnum;\n      }\n    }\n    if (!(d.size >= 0)) {\n      d.size = 200;\n    }\n    d.minWidth = 0;\n    d.minHeight = 0;\n  }\n  function fixPanelData(panel) {\n    fixpanelOrBox(panel);\n    var findActiveId = false;\n    if (loadTab) {\n      for (var i = 0; i < panel.tabs.length; ++i) {\n        panel.tabs[i] = loadTab(panel.tabs[i]);\n      }\n    }\n    var _iterator4 = _createForOfIteratorHelper(panel.tabs),\n      _step4;\n    try {\n      for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n        var child = _step4.value;\n        child.parent = panel;\n        if (child.id === panel.activeId) {\n          findActiveId = true;\n        }\n        if (child.minWidth > panel.minWidth) panel.minWidth = child.minWidth;\n        if (child.minHeight > panel.minHeight) panel.minHeight = child.minHeight;\n      }\n    } catch (err) {\n      _iterator4.e(err);\n    } finally {\n      _iterator4.f();\n    }\n    if (!findActiveId && panel.tabs.length) {\n      panel.activeId = panel.tabs[0].id;\n    }\n    if (panel.minWidth <= 0) {\n      panel.minWidth = 1;\n    }\n    if (panel.minHeight <= 0) {\n      panel.minHeight = 1;\n    }\n    if (panel.panelLock) {\n      if (panel.minWidth < panel.panelLock.minWidth) {\n        panel.minWidth = panel.panelLock.minWidth;\n      }\n      if (panel.minHeight < panel.panelLock.minHeight) {\n        panel.minHeight = panel.panelLock.minHeight;\n      }\n    }\n    if (panel.group == null && panel.tabs.length) {\n      panel.group = panel.tabs[0].group;\n    }\n    if (panel.z > _zCount) {\n      // make sure next zIndex is on top\n      _zCount = panel.z;\n    }\n    return panel;\n  }\n  function fixBoxData(box) {\n    fixpanelOrBox(box);\n    for (var i = 0; i < box.children.length; ++i) {\n      var child = box.children[i];\n      child.parent = box;\n      if ('children' in child) {\n        fixBoxData(child);\n        if (child.children.length === 0) {\n          // remove box with no child\n          box.children.splice(i, 1);\n          --i;\n        } else if (child.children.length === 1) {\n          // box with one child should be merged back to parent box\n          var subChild = child.children[0];\n          if (subChild.mode === box.mode) {\n            var _box$children;\n            // sub child is another box that can be merged into current box\n            var totalSubSize = 0;\n            var _iterator5 = _createForOfIteratorHelper(subChild.children),\n              _step5;\n            try {\n              for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n                var subsubChild = _step5.value;\n                totalSubSize += subsubChild.size;\n              }\n            } catch (err) {\n              _iterator5.e(err);\n            } finally {\n              _iterator5.f();\n            }\n            var sizeScale = child.size / totalSubSize;\n            var _iterator6 = _createForOfIteratorHelper(subChild.children),\n              _step6;\n            try {\n              for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n                var _subsubChild = _step6.value;\n                _subsubChild.size *= sizeScale;\n              }\n              // merge children up\n            } catch (err) {\n              _iterator6.e(err);\n            } finally {\n              _iterator6.f();\n            }\n            (_box$children = box.children).splice.apply(_box$children, [i, 1].concat(_toConsumableArray(subChild.children)));\n          } else {\n            // sub child can be moved up one layer\n            subChild.size = child.size;\n            box.children[i] = subChild;\n          }\n          --i;\n        }\n      } else if ('tabs' in child) {\n        fixPanelData(child);\n        if (child.tabs.length === 0) {\n          // remove panel with no tab\n          if (!child.panelLock) {\n            box.children.splice(i, 1);\n            --i;\n          } else if (child.group === placeHolderStyle && (box.children.length > 1 || box.parent)) {\n            // remove placeHolder Group\n            box.children.splice(i, 1);\n            --i;\n          }\n        }\n      }\n      // merge min size\n      switch (box.mode) {\n        case 'horizontal':\n          if (child.minWidth > 0) box.minWidth += child.minWidth;\n          if (child.minHeight > box.minHeight) box.minHeight = child.minHeight;\n          break;\n        case 'vertical':\n          if (child.minWidth > box.minWidth) box.minWidth = child.minWidth;\n          if (child.minHeight > 0) box.minHeight += child.minHeight;\n          break;\n      }\n    }\n    // add divider size\n    if (box.children.length > 1) {\n      switch (box.mode) {\n        case 'horizontal':\n          box.minWidth += (box.children.length - 1) * 4;\n          break;\n        case 'vertical':\n          box.minHeight += (box.children.length - 1) * 4;\n          break;\n      }\n    }\n    return box;\n  }\n  if (layout.floatbox) {\n    layout.floatbox.mode = 'float';\n  } else {\n    layout.floatbox = {\n      mode: 'float',\n      children: [],\n      size: 1\n    };\n  }\n  if (layout.windowbox) {\n    layout.windowbox.mode = 'window';\n  } else {\n    layout.windowbox = {\n      mode: 'window',\n      children: [],\n      size: 1\n    };\n  }\n  if (layout.maxbox) {\n    layout.maxbox.mode = 'maximize';\n  } else {\n    layout.maxbox = {\n      mode: 'maximize',\n      children: [],\n      size: 1\n    };\n  }\n  fixBoxData(layout.dockbox);\n  fixBoxData(layout.floatbox);\n  fixBoxData(layout.windowbox);\n  fixBoxData(layout.maxbox);\n  if (layout.dockbox.children.length === 0) {\n    // add place holder panel when root box is empty\n    var newPanel = {\n      id: '+0',\n      group: placeHolderStyle,\n      panelLock: {},\n      size: 200,\n      tabs: []\n    };\n    newPanel.parent = layout.dockbox;\n    layout.dockbox.children.push(newPanel);\n  } else {\n    // merge and replace root box when box has only one child\n    while (layout.dockbox.children.length === 1 && 'children' in layout.dockbox.children[0]) {\n      var newDockBox = clone(layout.dockbox.children[0]);\n      layout.dockbox = newDockBox;\n      var _iterator7 = _createForOfIteratorHelper(newDockBox.children),\n        _step7;\n      try {\n        for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n          var child = _step7.value;\n          child.parent = newDockBox;\n        }\n      } catch (err) {\n        _iterator7.e(err);\n      } finally {\n        _iterator7.f();\n      }\n    }\n  }\n  layout.dockbox.parent = null;\n  layout.floatbox.parent = null;\n  layout.windowbox.parent = null;\n  layout.maxbox.parent = null;\n  clearObjectCache();\n  return layout;\n}\nfunction replacePanel(layout, panel, newPanel) {\n  var _iterator8 = _createForOfIteratorHelper(newPanel.tabs),\n    _step8;\n  try {\n    for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n      var tab = _step8.value;\n      tab.parent = newPanel;\n    }\n  } catch (err) {\n    _iterator8.e(err);\n  } finally {\n    _iterator8.f();\n  }\n  var box = panel.parent;\n  if (box) {\n    var pos = box.children.indexOf(panel);\n    if (pos >= 0) {\n      var newBox = clone(box);\n      newBox.children[pos] = newPanel;\n      return replaceBox(layout, box, newBox);\n    }\n  }\n  return layout;\n}\nfunction replaceBox(layout, box, newBox) {\n  var _iterator9 = _createForOfIteratorHelper(newBox.children),\n    _step9;\n  try {\n    for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n      var child = _step9.value;\n      child.parent = newBox;\n    }\n  } catch (err) {\n    _iterator9.e(err);\n  } finally {\n    _iterator9.f();\n  }\n  var parentBox = box.parent;\n  if (parentBox) {\n    var pos = parentBox.children.indexOf(box);\n    if (pos >= 0) {\n      var newParentBox = clone(parentBox);\n      newParentBox.children[pos] = newBox;\n      return replaceBox(layout, parentBox, newParentBox);\n    }\n  } else {\n    if (box.id === layout.dockbox.id || box === layout.dockbox) {\n      return Object.assign(Object.assign({}, layout), {\n        dockbox: newBox\n      });\n    } else if (box.id === layout.floatbox.id || box === layout.floatbox) {\n      return Object.assign(Object.assign({}, layout), {\n        floatbox: newBox\n      });\n    } else if (box.id === layout.windowbox.id || box === layout.windowbox) {\n      return Object.assign(Object.assign({}, layout), {\n        windowbox: newBox\n      });\n    } else if (box.id === layout.maxbox.id || box === layout.maxbox) {\n      return Object.assign(Object.assign({}, layout), {\n        maxbox: newBox\n      });\n    }\n  }\n  return layout;\n}\nexport function getFloatPanelSize(panel, tabGroup) {\n  if (!panel) {\n    return [300, 300];\n  }\n  var panelWidth = panel.offsetWidth;\n  var panelHeight = panel.offsetHeight;\n  var _ref = tabGroup.preferredFloatWidth || [100, 600],\n    _ref2 = _slicedToArray(_ref, 2),\n    minWidth = _ref2[0],\n    maxWidth = _ref2[1];\n  var _ref3 = tabGroup.preferredFloatHeight || [50, 500],\n    _ref4 = _slicedToArray(_ref3, 2),\n    minHeight = _ref4[0],\n    maxHeight = _ref4[1];\n  if (!(panelWidth >= minWidth)) {\n    panelWidth = minWidth;\n  } else if (!(panelWidth <= maxWidth)) {\n    panelWidth = maxWidth;\n  }\n  if (!(panelHeight >= minHeight)) {\n    panelHeight = minHeight;\n  } else if (!(panelHeight <= maxHeight)) {\n    panelHeight = maxHeight;\n  }\n  return [panelWidth, panelHeight];\n}\nexport function findNearestPanel(rectFrom, rectTo, direction) {\n  var distance = -1;\n  var overlap = -1;\n  var alignment = 0;\n  switch (direction) {\n    case 'ArrowUp':\n      {\n        distance = rectFrom.top - rectTo.bottom + rectFrom.height;\n        overlap = Math.min(rectFrom.right, rectTo.right) - Math.max(rectFrom.left, rectTo.left);\n        break;\n      }\n    case 'ArrowDown':\n      {\n        distance = rectTo.top - rectFrom.bottom + rectFrom.height;\n        overlap = Math.min(rectFrom.right, rectTo.right) - Math.max(rectFrom.left, rectTo.left);\n        break;\n      }\n    case 'ArrowLeft':\n      {\n        distance = rectFrom.left - rectTo.right + rectFrom.width;\n        overlap = Math.min(rectFrom.bottom, rectTo.bottom) - Math.max(rectFrom.top, rectTo.top);\n        alignment = Math.abs(rectFrom.top - rectTo.top);\n        break;\n      }\n    case 'ArrowRight':\n      {\n        distance = rectTo.left - rectFrom.right + rectFrom.width;\n        overlap = Math.min(rectFrom.bottom, rectTo.bottom) - Math.max(rectFrom.top, rectTo.top);\n        alignment = Math.abs(rectFrom.top - rectTo.top);\n        break;\n      }\n  }\n  if (distance < 0 || overlap <= 0) {\n    return -1;\n  }\n  return distance * (alignment + 1) - overlap * 0.001;\n}","map":{"version":3,"names":["maximePlaceHolderId","placeHolderStyle","_watchObjectChange","WeakMap","getUpdatedObject","obj","result","get","clearObjectCache","clone","value","extra","newValue","Object","assign","Array","isArray","tabs","concat","children","set","_idCount","nextId","_zCount","nextZIndex","current","findInPanel","panel","id","filter","Filter","Panel","Tab","_iterator","_createForOfIteratorHelper","_step","s","n","done","tab","err","e","f","findInBox","box","Box","_iterator2","_step2","child","find","layout","arguments","length","undefined","AnyTabPanel","Docked","dockbox","Floated","floatbox","Windowed","windowbox","Max","maxbox","addNextToTab","source","target","direction","pos","parent","indexOf","addTabToPanel","idx","activeId","_newPanel$tabs","newPanel","splice","apply","_toConsumableArray","_iterator3","_step3","replacePanel","converToPanel","group","dockPanelToPanel","dockMode","afterPanel","newBox","mode","size","newChildBox","replaceBox","dockPanelToBox","parentBox","newParentBox","newDockBox","push","floatPanel","rect","x","left","y","top","w","width","h","height","panelToWindow","removeFromLayout","panelData","removePanel","removeTab","panelLock","placeHolder","moveToFront","needUpdate","changes","newZ","z","maximize","restorePanel","maximizePanel","maximizeTab","placeHodlerPanel","fixFloatPanelPos","layoutWidth","layoutHeight","layoutChanged","newFloatChildren","i","panelChange","Math","max","keys","fixLayoutData","loadTab","fixpanelOrBox","d","startsWith","idnum","Number","minWidth","minHeight","fixPanelData","findActiveId","_iterator4","_step4","fixBoxData","subChild","_box$children","totalSubSize","_iterator5","_step5","subsubChild","sizeScale","_iterator6","_step6","_iterator7","_step7","_iterator8","_step8","_iterator9","_step9","getFloatPanelSize","tabGroup","panelWidth","offsetWidth","panelHeight","offsetHeight","_ref","preferredFloatWidth","_ref2","_slicedToArray","maxWidth","_ref3","preferredFloatHeight","_ref4","maxHeight","findNearestPanel","rectFrom","rectTo","distance","overlap","alignment","bottom","min","right","abs"],"sources":["C:/d/Programming/web/jodel-mde/node_modules/rc-dock/es/Algorithm.js"],"sourcesContent":["import { maximePlaceHolderId, placeHolderStyle } from \"./DockData\";\nlet _watchObjectChange = new WeakMap();\nexport function getUpdatedObject(obj) {\n    let result = _watchObjectChange.get(obj);\n    if (result) {\n        return getUpdatedObject(result);\n    }\n    return obj;\n}\nfunction clearObjectCache() {\n    _watchObjectChange = new WeakMap();\n}\nfunction clone(value, extra) {\n    let newValue = Object.assign(Object.assign({}, value), extra);\n    if (Array.isArray(newValue.tabs)) {\n        newValue.tabs = newValue.tabs.concat();\n    }\n    if (Array.isArray(newValue.children)) {\n        newValue.children = newValue.children.concat();\n    }\n    _watchObjectChange.set(value, newValue);\n    return newValue;\n}\nlet _idCount = 0;\nexport function nextId() {\n    ++_idCount;\n    return `+${_idCount}`;\n}\nlet _zCount = 0;\nexport function nextZIndex(current) {\n    if (current === _zCount) {\n        // already the top\n        return current;\n    }\n    return ++_zCount;\n}\nfunction findInPanel(panel, id, filter) {\n    if (panel.id === id && (filter & Filter.Panel)) {\n        return panel;\n    }\n    if (filter & Filter.Tab) {\n        for (let tab of panel.tabs) {\n            if (tab.id === id) {\n                return tab;\n            }\n        }\n    }\n    return null;\n}\nfunction findInBox(box, id, filter) {\n    let result;\n    if ((filter | Filter.Box) && box.id === id) {\n        return box;\n    }\n    for (let child of box.children) {\n        if ('children' in child) {\n            if (result = findInBox(child, id, filter)) {\n                break;\n            }\n        }\n        else if ('tabs' in child) {\n            if (result = findInPanel(child, id, filter)) {\n                break;\n            }\n        }\n    }\n    return result;\n}\nexport var Filter;\n(function (Filter) {\n    Filter[Filter[\"Tab\"] = 1] = \"Tab\";\n    Filter[Filter[\"Panel\"] = 2] = \"Panel\";\n    Filter[Filter[\"Box\"] = 4] = \"Box\";\n    Filter[Filter[\"Docked\"] = 8] = \"Docked\";\n    Filter[Filter[\"Floated\"] = 16] = \"Floated\";\n    Filter[Filter[\"Windowed\"] = 32] = \"Windowed\";\n    Filter[Filter[\"Max\"] = 64] = \"Max\";\n    Filter[Filter[\"EveryWhere\"] = 120] = \"EveryWhere\";\n    Filter[Filter[\"AnyTab\"] = 121] = \"AnyTab\";\n    Filter[Filter[\"AnyPanel\"] = 122] = \"AnyPanel\";\n    Filter[Filter[\"AnyTabPanel\"] = 123] = \"AnyTabPanel\";\n    Filter[Filter[\"All\"] = 127] = \"All\";\n})(Filter || (Filter = {}));\nexport function find(layout, id, filter = Filter.AnyTabPanel) {\n    let result;\n    if (filter & Filter.Docked) {\n        result = findInBox(layout.dockbox, id, filter);\n    }\n    if (result)\n        return result;\n    if (filter & Filter.Floated) {\n        result = findInBox(layout.floatbox, id, filter);\n    }\n    if (result)\n        return result;\n    if (filter & Filter.Windowed) {\n        result = findInBox(layout.windowbox, id, filter);\n    }\n    if (result)\n        return result;\n    if (filter & Filter.Max) {\n        result = findInBox(layout.maxbox, id, filter);\n    }\n    return result;\n}\nexport function addNextToTab(layout, source, target, direction) {\n    let pos = target.parent.tabs.indexOf(target);\n    if (pos >= 0) {\n        if (direction === 'after-tab') {\n            ++pos;\n        }\n        return addTabToPanel(layout, source, target.parent, pos);\n    }\n    return layout;\n}\nexport function addTabToPanel(layout, source, panel, idx = -1) {\n    if (idx === -1) {\n        idx = panel.tabs.length;\n    }\n    let tabs;\n    let activeId;\n    if ('tabs' in source) {\n        // source is PanelData\n        tabs = source.tabs;\n        activeId = source.activeId;\n    }\n    else {\n        // source is TabData\n        tabs = [source];\n    }\n    if (tabs.length) {\n        let newPanel = clone(panel);\n        newPanel.tabs.splice(idx, 0, ...tabs);\n        newPanel.activeId = tabs[tabs.length - 1].id;\n        for (let tab of tabs) {\n            tab.parent = newPanel;\n        }\n        if (activeId) {\n            newPanel.activeId = activeId;\n        }\n        layout = replacePanel(layout, panel, newPanel);\n    }\n    return layout;\n}\nexport function converToPanel(source) {\n    if ('tabs' in source) {\n        // source is already PanelData\n        return source;\n    }\n    else {\n        let newPanel = { tabs: [source], group: source.group, activeId: source.id };\n        source.parent = newPanel;\n        return newPanel;\n    }\n}\nexport function dockPanelToPanel(layout, newPanel, panel, direction) {\n    let box = panel.parent;\n    let dockMode = (direction === 'left' || direction === 'right') ? 'horizontal' : 'vertical';\n    let afterPanel = (direction === 'bottom' || direction === 'right');\n    let pos = box.children.indexOf(panel);\n    if (pos >= 0) {\n        let newBox = clone(box);\n        if (dockMode === box.mode) {\n            if (afterPanel) {\n                ++pos;\n            }\n            panel.size *= 0.5;\n            newPanel.size = panel.size;\n            newBox.children.splice(pos, 0, newPanel);\n        }\n        else {\n            let newChildBox = { mode: dockMode, children: [] };\n            newChildBox.size = panel.size;\n            if (afterPanel) {\n                newChildBox.children = [panel, newPanel];\n            }\n            else {\n                newChildBox.children = [newPanel, panel];\n            }\n            panel.parent = newChildBox;\n            panel.size = 200;\n            newPanel.parent = newChildBox;\n            newPanel.size = 200;\n            newBox.children[pos] = newChildBox;\n            newChildBox.parent = newBox;\n        }\n        return replaceBox(layout, box, newBox);\n    }\n    return layout;\n}\nexport function dockPanelToBox(layout, newPanel, box, direction) {\n    let parentBox = box.parent;\n    let dockMode = (direction === 'left' || direction === 'right') ? 'horizontal' : 'vertical';\n    let afterPanel = (direction === 'bottom' || direction === 'right');\n    if (parentBox) {\n        let pos = parentBox.children.indexOf(box);\n        if (pos >= 0) {\n            let newParentBox = clone(parentBox);\n            if (dockMode === parentBox.mode) {\n                if (afterPanel) {\n                    ++pos;\n                }\n                newPanel.size = box.size * 0.3;\n                box.size *= 0.7;\n                newParentBox.children.splice(pos, 0, newPanel);\n            }\n            else {\n                let newChildBox = { mode: dockMode, children: [] };\n                newChildBox.size = box.size;\n                if (afterPanel) {\n                    newChildBox.children = [box, newPanel];\n                }\n                else {\n                    newChildBox.children = [newPanel, box];\n                }\n                box.parent = newChildBox;\n                box.size = 280;\n                newPanel.parent = newChildBox;\n                newPanel.size = 120;\n                newParentBox.children[pos] = newChildBox;\n            }\n            return replaceBox(layout, parentBox, newParentBox);\n        }\n    }\n    else if (box === layout.dockbox) {\n        let newBox = clone(box);\n        if (dockMode === box.mode) {\n            let pos = 0;\n            if (afterPanel) {\n                pos = newBox.children.length;\n            }\n            newPanel.size = box.size * 0.3;\n            box.size *= 0.7;\n            newBox.children.splice(pos, 0, newPanel);\n            return replaceBox(layout, box, newBox);\n        }\n        else {\n            // replace root dockbox\n            let newDockBox = { mode: dockMode, children: [] };\n            newDockBox.size = box.size;\n            if (afterPanel) {\n                newDockBox.children = [newBox, newPanel];\n            }\n            else {\n                newDockBox.children = [newPanel, newBox];\n            }\n            newBox.size = 280;\n            newPanel.size = 120;\n            return replaceBox(layout, box, newDockBox);\n        }\n    }\n    else if (box === layout.maxbox) {\n        let newBox = clone(box);\n        newBox.children.push(newPanel);\n        return replaceBox(layout, box, newBox);\n    }\n    return layout;\n}\nexport function floatPanel(layout, newPanel, rect) {\n    let newBox = clone(layout.floatbox);\n    if (rect) {\n        newPanel.x = rect.left;\n        newPanel.y = rect.top;\n        newPanel.w = rect.width;\n        newPanel.h = rect.height;\n    }\n    newBox.children.push(newPanel);\n    return replaceBox(layout, layout.floatbox, newBox);\n}\nexport function panelToWindow(layout, newPanel) {\n    let newBox = clone(layout.windowbox);\n    newBox.children.push(newPanel);\n    return replaceBox(layout, layout.windowbox, newBox);\n}\nexport function removeFromLayout(layout, source) {\n    if (source) {\n        let panelData;\n        if ('tabs' in source) {\n            panelData = source;\n            layout = removePanel(layout, panelData);\n        }\n        else {\n            panelData = source.parent;\n            layout = removeTab(layout, source);\n        }\n        if (panelData && panelData.parent && panelData.parent.mode === 'maximize') {\n            let newPanel = layout.maxbox.children[0];\n            if (!newPanel || (newPanel.tabs.length === 0 && !newPanel.panelLock)) {\n                // max panel is gone, remove the place holder\n                let placeHolder = find(layout, maximePlaceHolderId);\n                if (placeHolder) {\n                    return removePanel(layout, placeHolder);\n                }\n            }\n        }\n    }\n    return layout;\n}\nfunction removePanel(layout, panel) {\n    let box = panel.parent;\n    if (box) {\n        let pos = box.children.indexOf(panel);\n        if (pos >= 0) {\n            let newBox = clone(box);\n            newBox.children.splice(pos, 1);\n            return replaceBox(layout, box, newBox);\n        }\n    }\n    return layout;\n}\nfunction removeTab(layout, tab) {\n    let panel = tab.parent;\n    if (panel) {\n        let pos = panel.tabs.indexOf(tab);\n        if (pos >= 0) {\n            let newPanel = clone(panel);\n            newPanel.tabs.splice(pos, 1);\n            if (newPanel.activeId === tab.id) {\n                // update selection id\n                if (newPanel.tabs.length > pos) {\n                    newPanel.activeId = newPanel.tabs[pos].id;\n                }\n                else if (newPanel.tabs.length) {\n                    newPanel.activeId = newPanel.tabs[0].id;\n                }\n            }\n            return replacePanel(layout, panel, newPanel);\n        }\n    }\n    return layout;\n}\nexport function moveToFront(layout, source) {\n    if (source) {\n        let panelData;\n        let needUpdate = false;\n        let changes = {};\n        if ('tabs' in source) {\n            panelData = source;\n        }\n        else {\n            panelData = source.parent;\n            if (panelData.activeId !== source.id) {\n                // move tab to front\n                changes.activeId = source.id;\n                needUpdate = true;\n            }\n        }\n        if (panelData && panelData.parent && panelData.parent.mode === 'float') {\n            // move float panel to front\n            let newZ = nextZIndex(panelData.z);\n            if (newZ !== panelData.z) {\n                changes.z = newZ;\n                needUpdate = true;\n            }\n        }\n        if (needUpdate) {\n            layout = replacePanel(layout, panelData, clone(panelData, changes));\n        }\n    }\n    return layout;\n}\n// maximize or restore the panel\nexport function maximize(layout, source) {\n    if (source) {\n        if ('tabs' in source) {\n            if (source.parent.mode === 'maximize') {\n                return restorePanel(layout, source);\n            }\n            else {\n                return maximizePanel(layout, source);\n            }\n        }\n        else {\n            return maximizeTab(layout, source);\n        }\n    }\n    return layout;\n}\nfunction maximizePanel(layout, panel) {\n    let maxbox = layout.maxbox;\n    if (maxbox.children.length) {\n        // invalid maximize\n        return layout;\n    }\n    let placeHodlerPanel = Object.assign(Object.assign({}, panel), { id: maximePlaceHolderId, tabs: [], panelLock: {} });\n    layout = replacePanel(layout, panel, placeHodlerPanel);\n    layout = dockPanelToBox(layout, panel, layout.maxbox, 'middle');\n    return layout;\n}\nfunction restorePanel(layout, panel) {\n    layout = removePanel(layout, panel);\n    let placeHolder = find(layout, maximePlaceHolderId);\n    if (placeHolder) {\n        let { x, y, z, w, h } = placeHolder;\n        panel = Object.assign(Object.assign({}, panel), { x, y, z, w, h });\n        return replacePanel(layout, placeHolder, panel);\n    }\n    else {\n        return dockPanelToBox(layout, panel, layout.dockbox, 'right');\n    }\n}\nfunction maximizeTab(layout, tab) {\n    // TODO to be implemented\n    return layout;\n}\n// move float panel into the screen\nexport function fixFloatPanelPos(layout, layoutWidth, layoutHeight) {\n    let layoutChanged = false;\n    if (layout && layout.floatbox && layoutWidth > 200 && layoutHeight > 200) {\n        let newFloatChildren = layout.floatbox.children.concat();\n        for (let i = 0; i < newFloatChildren.length; ++i) {\n            let panel = newFloatChildren[i];\n            let panelChange = {};\n            if (panel.w > layoutWidth) {\n                panelChange.w = layoutWidth;\n            }\n            if (panel.h > layoutHeight) {\n                panelChange.h = layoutHeight;\n            }\n            if (panel.y > layoutHeight - 16) {\n                panelChange.y = Math.max(layoutHeight - 16 - (panel.h >> 1), 0);\n            }\n            else if (panel.y < 0) {\n                panelChange.y = 0;\n            }\n            if (panel.x + panel.w < 16) {\n                panelChange.x = 16 - (panel.w >> 1);\n            }\n            else if (panel.x > layoutWidth - 16) {\n                panelChange.x = layoutWidth - 16 - (panel.w >> 1);\n            }\n            if (Object.keys(panelChange).length) {\n                newFloatChildren[i] = clone(panel, panelChange);\n                layoutChanged = true;\n            }\n        }\n        if (layoutChanged) {\n            let newBox = clone(layout.floatbox);\n            newBox.children = newFloatChildren;\n            return replaceBox(layout, layout.floatbox, newBox);\n        }\n    }\n    return layout;\n}\nexport function fixLayoutData(layout, loadTab) {\n    function fixpanelOrBox(d) {\n        if (d.id == null) {\n            d.id = nextId();\n        }\n        else if (d.id.startsWith('+')) {\n            let idnum = Number(d.id);\n            if (idnum > _idCount) {\n                // make sure generated id is unique\n                _idCount = idnum;\n            }\n        }\n        if (!(d.size >= 0)) {\n            d.size = 200;\n        }\n        d.minWidth = 0;\n        d.minHeight = 0;\n    }\n    function fixPanelData(panel) {\n        fixpanelOrBox(panel);\n        let findActiveId = false;\n        if (loadTab) {\n            for (let i = 0; i < panel.tabs.length; ++i) {\n                panel.tabs[i] = loadTab(panel.tabs[i]);\n            }\n        }\n        for (let child of panel.tabs) {\n            child.parent = panel;\n            if (child.id === panel.activeId) {\n                findActiveId = true;\n            }\n            if (child.minWidth > panel.minWidth)\n                panel.minWidth = child.minWidth;\n            if (child.minHeight > panel.minHeight)\n                panel.minHeight = child.minHeight;\n        }\n        if (!findActiveId && panel.tabs.length) {\n            panel.activeId = panel.tabs[0].id;\n        }\n        if (panel.minWidth <= 0) {\n            panel.minWidth = 1;\n        }\n        if (panel.minHeight <= 0) {\n            panel.minHeight = 1;\n        }\n        if (panel.panelLock) {\n            if (panel.minWidth < panel.panelLock.minWidth) {\n                panel.minWidth = panel.panelLock.minWidth;\n            }\n            if (panel.minHeight < panel.panelLock.minHeight) {\n                panel.minHeight = panel.panelLock.minHeight;\n            }\n        }\n        if (panel.group == null && panel.tabs.length) {\n            panel.group = panel.tabs[0].group;\n        }\n        if (panel.z > _zCount) {\n            // make sure next zIndex is on top\n            _zCount = panel.z;\n        }\n        return panel;\n    }\n    function fixBoxData(box) {\n        fixpanelOrBox(box);\n        for (let i = 0; i < box.children.length; ++i) {\n            let child = box.children[i];\n            child.parent = box;\n            if ('children' in child) {\n                fixBoxData(child);\n                if (child.children.length === 0) {\n                    // remove box with no child\n                    box.children.splice(i, 1);\n                    --i;\n                }\n                else if (child.children.length === 1) {\n                    // box with one child should be merged back to parent box\n                    let subChild = child.children[0];\n                    if (subChild.mode === box.mode) {\n                        // sub child is another box that can be merged into current box\n                        let totalSubSize = 0;\n                        for (let subsubChild of subChild.children) {\n                            totalSubSize += subsubChild.size;\n                        }\n                        let sizeScale = child.size / totalSubSize;\n                        for (let subsubChild of subChild.children) {\n                            subsubChild.size *= sizeScale;\n                        }\n                        // merge children up\n                        box.children.splice(i, 1, ...subChild.children);\n                    }\n                    else {\n                        // sub child can be moved up one layer\n                        subChild.size = child.size;\n                        box.children[i] = subChild;\n                    }\n                    --i;\n                }\n            }\n            else if ('tabs' in child) {\n                fixPanelData(child);\n                if (child.tabs.length === 0) {\n                    // remove panel with no tab\n                    if (!child.panelLock) {\n                        box.children.splice(i, 1);\n                        --i;\n                    }\n                    else if (child.group === placeHolderStyle && (box.children.length > 1 || box.parent)) {\n                        // remove placeHolder Group\n                        box.children.splice(i, 1);\n                        --i;\n                    }\n                }\n            }\n            // merge min size\n            switch (box.mode) {\n                case 'horizontal':\n                    if (child.minWidth > 0)\n                        box.minWidth += child.minWidth;\n                    if (child.minHeight > box.minHeight)\n                        box.minHeight = child.minHeight;\n                    break;\n                case 'vertical':\n                    if (child.minWidth > box.minWidth)\n                        box.minWidth = child.minWidth;\n                    if (child.minHeight > 0)\n                        box.minHeight += child.minHeight;\n                    break;\n            }\n        }\n        // add divider size\n        if (box.children.length > 1) {\n            switch (box.mode) {\n                case 'horizontal':\n                    box.minWidth += (box.children.length - 1) * 4;\n                    break;\n                case 'vertical':\n                    box.minHeight += (box.children.length - 1) * 4;\n                    break;\n            }\n        }\n        return box;\n    }\n    if (layout.floatbox) {\n        layout.floatbox.mode = 'float';\n    }\n    else {\n        layout.floatbox = { mode: 'float', children: [], size: 1 };\n    }\n    if (layout.windowbox) {\n        layout.windowbox.mode = 'window';\n    }\n    else {\n        layout.windowbox = { mode: 'window', children: [], size: 1 };\n    }\n    if (layout.maxbox) {\n        layout.maxbox.mode = 'maximize';\n    }\n    else {\n        layout.maxbox = { mode: 'maximize', children: [], size: 1 };\n    }\n    fixBoxData(layout.dockbox);\n    fixBoxData(layout.floatbox);\n    fixBoxData(layout.windowbox);\n    fixBoxData(layout.maxbox);\n    if (layout.dockbox.children.length === 0) {\n        // add place holder panel when root box is empty\n        let newPanel = { id: '+0', group: placeHolderStyle, panelLock: {}, size: 200, tabs: [] };\n        newPanel.parent = layout.dockbox;\n        layout.dockbox.children.push(newPanel);\n    }\n    else {\n        // merge and replace root box when box has only one child\n        while (layout.dockbox.children.length === 1 && 'children' in layout.dockbox.children[0]) {\n            let newDockBox = clone(layout.dockbox.children[0]);\n            layout.dockbox = newDockBox;\n            for (let child of newDockBox.children) {\n                child.parent = newDockBox;\n            }\n        }\n    }\n    layout.dockbox.parent = null;\n    layout.floatbox.parent = null;\n    layout.windowbox.parent = null;\n    layout.maxbox.parent = null;\n    clearObjectCache();\n    return layout;\n}\nfunction replacePanel(layout, panel, newPanel) {\n    for (let tab of newPanel.tabs) {\n        tab.parent = newPanel;\n    }\n    let box = panel.parent;\n    if (box) {\n        let pos = box.children.indexOf(panel);\n        if (pos >= 0) {\n            let newBox = clone(box);\n            newBox.children[pos] = newPanel;\n            return replaceBox(layout, box, newBox);\n        }\n    }\n    return layout;\n}\nfunction replaceBox(layout, box, newBox) {\n    for (let child of newBox.children) {\n        child.parent = newBox;\n    }\n    let parentBox = box.parent;\n    if (parentBox) {\n        let pos = parentBox.children.indexOf(box);\n        if (pos >= 0) {\n            let newParentBox = clone(parentBox);\n            newParentBox.children[pos] = newBox;\n            return replaceBox(layout, parentBox, newParentBox);\n        }\n    }\n    else {\n        if (box.id === layout.dockbox.id || box === layout.dockbox) {\n            return Object.assign(Object.assign({}, layout), { dockbox: newBox });\n        }\n        else if (box.id === layout.floatbox.id || box === layout.floatbox) {\n            return Object.assign(Object.assign({}, layout), { floatbox: newBox });\n        }\n        else if (box.id === layout.windowbox.id || box === layout.windowbox) {\n            return Object.assign(Object.assign({}, layout), { windowbox: newBox });\n        }\n        else if (box.id === layout.maxbox.id || box === layout.maxbox) {\n            return Object.assign(Object.assign({}, layout), { maxbox: newBox });\n        }\n    }\n    return layout;\n}\nexport function getFloatPanelSize(panel, tabGroup) {\n    if (!panel) {\n        return [300, 300];\n    }\n    let panelWidth = panel.offsetWidth;\n    let panelHeight = panel.offsetHeight;\n    let [minWidth, maxWidth] = tabGroup.preferredFloatWidth || [100, 600];\n    let [minHeight, maxHeight] = tabGroup.preferredFloatHeight || [50, 500];\n    if (!(panelWidth >= minWidth)) {\n        panelWidth = minWidth;\n    }\n    else if (!(panelWidth <= maxWidth)) {\n        panelWidth = maxWidth;\n    }\n    if (!(panelHeight >= minHeight)) {\n        panelHeight = minHeight;\n    }\n    else if (!(panelHeight <= maxHeight)) {\n        panelHeight = maxHeight;\n    }\n    return [panelWidth, panelHeight];\n}\nexport function findNearestPanel(rectFrom, rectTo, direction) {\n    let distance = -1;\n    let overlap = -1;\n    let alignment = 0;\n    switch (direction) {\n        case 'ArrowUp': {\n            distance = rectFrom.top - rectTo.bottom + rectFrom.height;\n            overlap = Math.min(rectFrom.right, rectTo.right) - Math.max(rectFrom.left, rectTo.left);\n            break;\n        }\n        case 'ArrowDown': {\n            distance = rectTo.top - rectFrom.bottom + rectFrom.height;\n            overlap = Math.min(rectFrom.right, rectTo.right) - Math.max(rectFrom.left, rectTo.left);\n            break;\n        }\n        case 'ArrowLeft': {\n            distance = rectFrom.left - rectTo.right + rectFrom.width;\n            overlap = Math.min(rectFrom.bottom, rectTo.bottom) - Math.max(rectFrom.top, rectTo.top);\n            alignment = Math.abs(rectFrom.top - rectTo.top);\n            break;\n        }\n        case 'ArrowRight': {\n            distance = rectTo.left - rectFrom.right + rectFrom.width;\n            overlap = Math.min(rectFrom.bottom, rectTo.bottom) - Math.max(rectFrom.top, rectTo.top);\n            alignment = Math.abs(rectFrom.top - rectTo.top);\n            break;\n        }\n    }\n    if (distance < 0 || overlap <= 0) {\n        return -1;\n    }\n    return distance * (alignment + 1) - overlap * 0.001;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}