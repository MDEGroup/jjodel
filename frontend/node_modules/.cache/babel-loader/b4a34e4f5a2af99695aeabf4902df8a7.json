{"ast":null,"code":"var _dec,_class,_class2,_dec2,_class3,_dec3,_class5,_dec4,_class7,_class8,_dec5,_class9,_class10,_dec6,_class11,_dec7,_class13,_class14,_dec8,_class15,_class16;import{U}from\"../joiner\";import{DPointerTargetable,RuntimeAccessible,windoww,Log,RuntimeAccessibleClass}from\"../joiner\";export let IPoint=(_dec=RuntimeAccessible('IPoint'),_dec(_class=(_class2=class IPoint extends RuntimeAccessibleClass{// @ts-ignore static getM is not null but must be declared nullable to achieve subclass mixing\n// public static getM? = function(firstPt: IPoint, secondPt: IPoint): number { return (firstPt.y - secondPt.y) / (firstPt.x - secondPt.x); }\nstatic getM(firstPt,secondPt){return(firstPt.y-secondPt.y)/(firstPt.x-secondPt.x);}static getQ(firstPt,secondPt,m){if(m===undefined)m=IPoint.getM(firstPt,secondPt);return firstPt.y-m*firstPt.x;}constructor(){let x=arguments.length>0&&arguments[0]!==undefined?arguments[0]:0;let y=arguments.length>1&&arguments[1]!==undefined?arguments[1]:0;super();// super('dwc');\nthis.x=void 0;this.y=void 0;IPoint.init_constructor(this,x,y);}static init_constructor(thiss){let x=arguments.length>1&&arguments[1]!==undefined?arguments[1]:0;let y=arguments.length>2&&arguments[2]!==undefined?arguments[2]:0;thiss.id=\"POINT_\"+DPointerTargetable.maxID++ +\"_\"+new Date().getTime();thiss.className=thiss.constructor.name;if(x===null||x===undefined)thiss.x=undefined;else if(isNaN(+x)){thiss.x=0;}else thiss.x=+x;if(y===null||y===undefined)thiss.y=undefined;else if(isNaN(+y)){thiss.y=0;}else thiss.y=+y;thiss.className=this.cname;}raw(){return{x:this.x,y:this.y};}toString(){let letters=arguments.length>0&&arguments[0]!==undefined?arguments[0]:true;let separator=arguments.length>1&&arguments[1]!==undefined?arguments[1]:\" \";if(letters)return JSON.stringify({x:this.x,y:this.y});else return this.x+separator+this.y+separator;}clone(other){this.x=other.x;this.y=other.y;return this;}duplicate(){const ret=this.new();ret.clone(this);return ret;}distanceFromPoint(tentativeEnd){let skipSqrt=arguments.length>1&&arguments[1]!==undefined?arguments[1]:false;let d_pow2=(this.x-tentativeEnd.x)**2+(this.y-tentativeEnd.y)**2;return skipSqrt?d_pow2:Math.sqrt(d_pow2);// return this.subtract(tentativeEnd, true).absolute();\n}subtract(p2,newInstance){Log.e(!p2,'subtract argument must be a valid point: ',p2);let p1;if(!newInstance){p1=this;}else{p1=this.duplicate();}if(p2.x!==undefined)p1.x-=p2.x;if(p2.y!==undefined)p1.y-=p2.y;return p1;}add(p2,newInstance){Log.e(!p2,'add argument must be a valid point: ',p2);let p1;if(!newInstance){p1=this;}else{p1=this.duplicate();}if(p2.x!==undefined)p1.x+=p2.x;if(p2.y!==undefined)p1.y+=p2.y;return p1;}addAll(p,newInstance){let i;let p0;if(!newInstance){p0=this;}else{p0=this.duplicate();}for(i=0;i<p.length;i++){p0.add(p[i],true);}return p0;}subtractAll(p,newInstance){let i;let p0;if(!newInstance){p0=this;}else{p0=this.duplicate();}for(i=0;i<p.length;i++){p0.subtract(p[i],true);}return p0;}multiply(pt){let newInstance=arguments.length>1&&arguments[1]!==undefined?arguments[1]:false;let ret=newInstance?this.duplicate():this;if(typeof pt===\"number\"){ret.x*=pt;ret.y*=pt;}else{if(pt.x!==undefined)ret.x*=pt.x;if(pt.y!==undefined)ret.y*=pt.y;}return ret;}divide(pt){let newInstance=arguments.length>1&&arguments[1]!==undefined?arguments[1]:false;let ret=newInstance?this.duplicate():this;if(typeof pt===\"number\"){ret.x/=pt;ret.y/=pt;}else{ret.x/=pt.x;ret.y/=pt.y;}return ret;}multiplyScalar(scalar,newInstance){Log.e(isNaN(+scalar),'IPoint.multiply()','scalar argument must be a valid number: ',scalar);let p1;if(!newInstance){p1=this;}else{p1=this.duplicate();}p1.x*=scalar;p1.y*=scalar;return p1;}divideScalar(scalar,newInstance){Log.e(isNaN(+scalar),'IPoint.divide()','scalar argument must be a valid number: ',scalar);let p1;if(!newInstance){p1=this;}else{p1=this.duplicate();}p1.x/=scalar;p1.y/=scalar;return p1;}isInTheMiddleOf(firstPt,secondPt,tolleranza){const rectangle=Size.fromPoints(firstPt,secondPt);const tolleranzaX=tolleranza;// actually should be cos * arctan(m);\nconst tolleranzaY=tolleranza;// actually should be sin * arctan(m);\nif(this.x<rectangle.x-tolleranzaX||this.x>rectangle.x+rectangle.w+tolleranzaX){return false;}if(this.y<rectangle.y-tolleranzaX||this.y>rectangle.y+rectangle.h+tolleranzaY){return false;}// const m = IPoint.getM(firstPt, secondPt);\n// const q = IPoint.getQ(firstPt, secondPt);\nconst lineDistance=this.distanceFromLine(firstPt,secondPt);// console.log('distance:', lineDistance, ', this:', this, ', p1:', firstPt, ', p2:', secondPt);\nreturn lineDistance<=tolleranza;}distanceFromLine(p1,p2){const top=+(p2.y-p1.y)*this.x-(p2.x-p1.x)*this.y+p2.x*p1.y-p1.x*p2.y;const bot=(p2.y-p1.y)*(p2.y-p1.y)+(p2.x-p1.x)*(p2.x-p1.x);return Math.abs(top)/Math.sqrt(bot);}equals(pt){let tolleranzaX=arguments.length>1&&arguments[1]!==undefined?arguments[1]:0;let tolleranzaY=arguments.length>2&&arguments[2]!==undefined?arguments[2]:0;if(pt===null){return false;}return Math.abs(this.x-pt.x)<=tolleranzaX&&Math.abs(this.y-pt.y)<=tolleranzaY;}moveOnNearestBorder(startVertexSize,clone,graph){let debug=arguments.length>3&&arguments[3]!==undefined?arguments[3]:true;const pt=clone?this.duplicate():this;const tl=startVertexSize.tl();const tr=startVertexSize.tr();const bl=startVertexSize.bl();const br=startVertexSize.br();const L=pt.distanceFromLine(tl,bl);const R=pt.distanceFromLine(tr,br);const T=pt.distanceFromLine(tl,tr);const B=pt.distanceFromLine(bl,br);const min=Math.min(L,R,T,B);if(min===L){pt.x=tl.x;}if(min===R){pt.x=tr.x;}if(min===T){pt.y=tr.y;}if(min===B){pt.y=br.y;}if(debug&&graph&&pt instanceof GraphPoint){graph.markg(pt,false,'purple');}return pt;}getM(pt2){var _IPoint$getM;return(_IPoint$getM=IPoint.getM)===null||_IPoint$getM===void 0?void 0:_IPoint$getM.call(IPoint,this,pt2);}degreeWith(pt2,toRadians){const directionVector=this.subtract(pt2,true);const ret=Math.atan2(directionVector.y,directionVector.x);return toRadians?ret:windoww.U.RadToDegree(ret);}absolute(){return Math.sqrt(this.x*this.x+this.y*this.y);}set(x,y){this.x=x;this.y=y;}// move the point by a vector with direction and distance (module)\nmove(rad,distance){let clone=arguments.length>2&&arguments[2]!==undefined?arguments[2]:true;let pt=clone?this.duplicate():this;pt.x+=distance*Math.cos(rad);pt.y+=distance*Math.sin(rad);return pt;}},_class2.subclasses=[],_class2._extends=[],_class2))||_class);export let GraphPoint=(_dec2=RuntimeAccessible('GraphPoint'),_dec2(_class3=class GraphPoint extends IPoint{constructor(){super(...arguments);this.dontmixwithPoint=void 0;}static fromEvent(e){if(!e){return null;}const p=new Point(e.pageX,e.pageY);const g=null;throw new Error(\"todo: const g: IGraph = Status.status.getActiveModel().graph;\");return g.toGraphCoord(p);}new(){return new GraphPoint();}toSize(w,h){return new GraphSize(this.x,this.y,w,h===undefined?w:h);}})||_class3);export let Point=(_dec3=RuntimeAccessible('Point'),_dec3(_class5=class Point extends IPoint{constructor(){super(...arguments);this.dontmixwithGPoint=void 0;}/// https://stackoverflow.com/questions/6073505/what-is-the-difference-between-screenx-y-clientx-y-and-pagex-y\nstatic fromEvent(e){const p=new Point(e.pageX,e.pageY);return p;}new(){return new Point();}toSize(w,h){return new Size(this.x,this.y,w,h===undefined?w:h);}})||_class5);RuntimeAccessibleClass.set_extend(RuntimeAccessibleClass,IPoint);RuntimeAccessibleClass.set_extend(IPoint,GraphPoint);RuntimeAccessibleClass.set_extend(IPoint,Point);export let ISize=(_dec4=RuntimeAccessible('ISize'),_dec4(_class7=(_class8=class ISize extends RuntimeAccessibleClass{constructor(){let x=arguments.length>0&&arguments[0]!==undefined?arguments[0]:0;let y=arguments.length>1&&arguments[1]!==undefined?arguments[1]:0;let w=arguments.length>2&&arguments[2]!==undefined?arguments[2]:0;let h=arguments.length>3&&arguments[3]!==undefined?arguments[3]:0;super();// super('dwc');\n// do not override any fields from the DPointerTargetable, otherwise the ! in the override will reinizialize the attribute\n// erasing the value set in super or in the functions called by the constructor as side effect (static_init called from constructor will be overridden too)\n// if need to override types, build the \"new\" static function like in DModelElement\nthis.x=void 0;this.y=void 0;this.w=void 0;this.h=void 0;ISize.init_constructor(this,x,y,w,h);}static init_constructor(thiss){let x=arguments.length>1&&arguments[1]!==undefined?arguments[1]:0;let y=arguments.length>2&&arguments[2]!==undefined?arguments[2]:0;let w=arguments.length>3&&arguments[3]!==undefined?arguments[3]:0;let h=arguments.length>4&&arguments[4]!==undefined?arguments[4]:0;thiss.id=\"SIZE_\"+DPointerTargetable.maxID++ +\"_\"+new Date().getTime();thiss.className=thiss.constructor.cname;if(x===null||x===undefined)thiss.x=undefined;else if(isNaN(+x)){thiss.x=0;}else thiss.x=+x;if(y===null||y===undefined)thiss.y=undefined;else if(isNaN(+y)){thiss.y=0;}else thiss.y=+y;if(w===null||w===undefined)thiss.w=undefined;else if(isNaN(+w)){thiss.w=0;}else thiss.w=+w;if(h===null||h===undefined)thiss.h=undefined;else if(isNaN(+h)){thiss.h=0;}else thiss.h=+h;thiss.className=this.cname;}toString(){let letters=arguments.length>0&&arguments[0]!==undefined?arguments[0]:true;let separator=arguments.length>1&&arguments[1]!==undefined?arguments[1]:\" \";if(letters)return JSON.stringify({x:this.x,y:this.y,w:this.w,h:this.h});else return this.x+separator+this.y+separator+this.w+separator+this.h;}set(x,y,w,h){if(x!==undefined)this.x=+x;if(y!==undefined)this.y=+y;if(w!==undefined)this.w=+w;if(h!==undefined)this.h=+h;}clone(json){this.x=json.x;this.y=json.y;this.w=json.w;this.h=json.h;return this;}duplicate(){return this.new().clone(this);}add(pt2,newInstance){let thiss=newInstance?this.duplicate():this;if(typeof pt2===\"number\"){thiss.x+=pt2;thiss.y+=pt2;thiss.w+=pt2;thiss.h+=pt2;return thiss;}if(pt2.x!==undefined)thiss.x+=pt2.x;if(pt2.y!==undefined)thiss.y+=pt2.y;if(pt2.w!==undefined)thiss.w+=pt2.w;if(pt2.h!==undefined)thiss.h+=pt2.h;return thiss;}subtract(pt2,newInstance){let thiss=newInstance?this.duplicate():this;if(typeof pt2===\"number\"){thiss.x-=pt2;thiss.y-=pt2;thiss.w-=pt2;thiss.h-=pt2;return thiss;}if(pt2.x!==undefined)thiss.x-=pt2.x;if(pt2.y!==undefined)thiss.y-=pt2.y;if(pt2.w!==undefined)thiss.w-=pt2.w;if(pt2.h!==undefined)thiss.h-=pt2.h;return thiss;}multiply(pt2,newInstance){let thiss=newInstance?this.duplicate():this;if(typeof pt2===\"number\"){thiss.x*=pt2;thiss.y*=pt2;thiss.w*=pt2;thiss.h*=pt2;return thiss;}if(pt2.x!==undefined)thiss.x*=pt2.x;if(pt2.y!==undefined)thiss.y*=pt2.y;if(pt2.w!==undefined)thiss.w*=pt2.w;if(pt2.h!==undefined)thiss.h*=pt2.h;return thiss;}divide(pt2,newInstance){let thiss=newInstance?this.duplicate():this;if(typeof pt2===\"number\"){thiss.x/=pt2;thiss.y/=pt2;thiss.w/=pt2;thiss.h/=pt2;return thiss;}if(pt2.x!==undefined)thiss.x/=pt2.x;if(pt2.y!==undefined)thiss.y/=pt2.y;if(pt2.w!==undefined)thiss.w/=pt2.w;if(pt2.h!==undefined)thiss.h/=pt2.h;return thiss;}tl(){return this.makePoint(this.x,this.y);}tr(){return this.makePoint(this.x+this.w,this.y);}bl(){return this.makePoint(this.x,this.y+this.h);}br(){return this.makePoint(this.x+this.w,this.y+this.h);}center(){return this.makePoint(this.x+this.w/2,this.y+this.h/2);}relativePoint(xPercent,yPercent){return this.makePoint(this.x+this.w*xPercent,this.y+this.h*yPercent);}equals(size){return this.x===size.x&&this.y===size.y&&this.w===size.w&&this.h===size.h;}/// field-wise Math.min()\nmin(minSize,clone){const ret=clone?this.new():this;if(!isNaN(minSize.x)&&ret.x<minSize.x){ret.x=minSize.x;}if(!isNaN(minSize.y)&&ret.y<minSize.y){ret.y=minSize.y;}if(!isNaN(minSize.w)&&ret.w<minSize.w){ret.w=minSize.w;}if(!isNaN(minSize.h)&&ret.h<minSize.h){ret.h=minSize.h;}return ret;}max(maxSize,clone){const ret=clone?this.new():this;if(!isNaN(maxSize.x)&&ret.x>maxSize.x){ret.x=maxSize.x;}if(!isNaN(maxSize.y)&&ret.y>maxSize.y){ret.y=maxSize.y;}if(!isNaN(maxSize.w)&&ret.w>maxSize.w){ret.w=maxSize.w;}if(!isNaN(maxSize.h)&&ret.h>maxSize.h){ret.h=maxSize.h;}return ret;}intersection(size){if(!size)return null;// anche \"isinside\"\nlet startx,starty,endx,endy;startx=Math.max(this.x,size.x);starty=Math.max(this.y,size.y);endx=Math.min(this.x+this.w,size.x+size.w);endy=Math.min(this.y+this.h,size.y+size.h);const intersection=this.new();// intersection.set(0, 0, 0, 0);\nintersection.x=startx;intersection.y=starty;intersection.w=endx-startx;intersection.h=endy-starty;const doesintersect=intersection.w>0&&intersection.h>0;return doesintersect?intersection:null;}contains(pt){return pt.x>=this.x&&pt.x<=this.x+this.w&&pt.y>=this.y&&pt.y<=this.y+this.h;}isOverlapping(size2){return!!this.intersection(size2);}isOverlappingAnyOf(sizes){if(!sizes)return false;for(let size of sizes){if(this.isOverlapping(size))return true;}return false;}multiplyPoint(other,newInstance){const ret=newInstance?this.new():this;ret.x*=other.x;ret.w*=other.x;ret.y*=other.y;ret.h*=other.y;return ret;}dividePoint(other,newInstance){const ret=newInstance?this.new():this;ret.x/=other.x;ret.w/=other.x;ret.y/=other.y;ret.h/=other.y;return ret;}boundary(size2){/*let minx, maxx, miny, maxy;\r\n        if (size2.y < this.y) { miny = size2.y; /*maxy = this.y;* / } else { miny = this.y; /*maxy = size2.y;* / }\r\n        if (size2.x < this.x) { minx = size2.y; /*maxx = this.x;* / } else { minx = this.x; /*maxy = size2.x;* / }\r\n        if (size2.y + size2.h < this.y + this.h) maxy = this.y + this.h; else maxy = size2.y + size2.h;\r\n        if (size2.x + size2.w < this.x + this.w) maxx = this.x + this.w; else maxx = size2.x + size2.w;\r\n        */this.h=size2.y+size2.h>this.y+this.h?size2.y+size2.h:this.y+this.h;// -miny\nthis.w=size2.x+size2.w>this.x+this.w?size2.x+size2.w:this.x+this.w;// -minx\nif(this.y<size2.y)this.y=size2.y;if(this.x<size2.x)this.x=size2.x;this.h-=this.y;this.w-=this.x;}},_class8.subclasses=[],_class8._extends=[],_class8))||_class7);export let Size=(_dec5=RuntimeAccessible('Size'),_dec5(_class9=(_class10=class Size extends ISize{constructor(){super(...arguments);this.dontMixWithGraphSize=void 0;}/**\r\n     * measure a node size\r\n     * @param {Element} element0 - the emelemnt to measure;\r\n     * @param {boolean} sizePostTransform - includes css transform instructions for computing his size. like transform: scale(1.5)\r\n     * */static of(element0){var _element$ownerDocumen;let sizePostTransform=arguments.length>1&&arguments[1]!==undefined?arguments[1]:true;let element=element0;if(element===document){Log.ww('trying to measure document, rerouted to measuring body.');element=document.body;}const $element=$(element);Log.ex(!element||element.tagName==='foreignObject','sizeof()','SvgForeignElementObject have a bug with size, measure a child instead.',element);let tmp;let size;if(!Size.sizeofvar){Size.sizeofvar=document.createElement('div');document.body.append(Size.sizeofvar);}const isOrphan=element.parentNode===null;// var visible = element.style.display !== 'none';\n// var visible = $element.is(\":visible\"); crea bug quando un elemento è teoricamente visibile ma orfano\nconst ancestors=windoww.U.ancestorArray(element);const displayStyles=ancestors.map(e=>{var _e$style;return e===null||e===void 0?void 0:(_e$style=e.style)===null||_e$style===void 0?void 0:_e$style.display;});if(isOrphan){Size.sizeofvar.append(element);}// show all and saveToDB visibility to restore it later\nfor(let i=0;i<ancestors.length;i++){var _ancestors$i,_ancestors$i$style;// document has undefined style\ndisplayStyles[i]=(_ancestors$i=ancestors[i])===null||_ancestors$i===void 0?void 0:(_ancestors$i$style=_ancestors$i.style)===null||_ancestors$i$style===void 0?void 0:_ancestors$i$style.display;if(displayStyles[i]==='none'||displayStyles[i]===''&&getComputedStyle(ancestors[i]).display==='none'){ancestors[i].style.display='block';}}// size = new Size(tmp.left, tmp.top, 0, 0);\nlet rect=element.getBoundingClientRect();size=new Size(0,0,0,0);let win=((_element$ownerDocumen=element.ownerDocument)===null||_element$ownerDocumen===void 0?void 0:_element$ownerDocumen.defaultView)||window;size.x=rect.left+win.scrollX;size.y=rect.top+win.scrollY;if(sizePostTransform){size.w=rect.width;size.h=rect.height;}else{size.w=element.offsetWidth;// element.scrollWidth;\nsize.h=element.offsetHeight;}// restore visibility\nfor(let i=0;i<ancestors.length;i++){var _ancestors$i$style2;if(displayStyles[i]===((_ancestors$i$style2=ancestors[i].style)===null||_ancestors$i$style2===void 0?void 0:_ancestors$i$style2.display))continue;if(displayStyles[i])ancestors[i].style.display=displayStyles[i];else ancestors[i].style.removeProperty('display');}if(isOrphan){windoww.U.clear(Size.sizeofvar);}// Status.status.getActiveModel().graph.markS(size, false);\nreturn size;}static fromPoints(firstPt,secondPt){const minX=Math.min(firstPt.x,secondPt.x);const maxX=Math.max(firstPt.x,secondPt.x);const minY=Math.min(firstPt.y,secondPt.y);const maxY=Math.max(firstPt.y,secondPt.y);return new Size(minX,minY,maxX-minX,maxY-minY);}makePoint(x,y){return new Point(x,y);}new(){for(var _len=arguments.length,args=new Array(_len),_key=0;_key<_len;_key++){args[_key]=arguments[_key];}return new Size(...args);}},_class10.subclasses=[],_class10.sizeofvar=void 0,_class10.$sizeofvar=void 0,_class10))||_class9);export let GraphSize=(_dec6=RuntimeAccessible('GraphSize'),_dec6(_class11=class GraphSize extends ISize{constructor(){super(...arguments);this.dontMixWithSize=void 0;}static fromPoints(firstPt,secondPt){const minX=Math.min(firstPt.x,secondPt.x);const maxX=Math.max(firstPt.x,secondPt.x);const minY=Math.min(firstPt.y,secondPt.y);const maxY=Math.max(firstPt.y,secondPt.y);return new GraphSize(minX,minY,maxX-minX,maxY-minY);}// both pt and targetPt are readonly-safe parameters\nstatic closestIntersection(size,pt,targetPt,gridAlign,m0,q0){// let pt: GraphPoint = pt0.duplicate();\nconst m=m0||GraphPoint.getM(targetPt,pt);const q=q0||GraphPoint.getQ(targetPt,pt);// console.log(\"closestIntersection()\", {size, pt0, targetPt, m, q});\n// if perfectly vertical line\nif(m===Number.POSITIVE_INFINITY/* && q === Number.NEGATIVE_INFINITY*/){// top center\nif(Math.abs(targetPt.y-size.y)<=Math.abs(targetPt.y-size.y-size.h))return pt;// bottom center\nelse return new GraphPoint(pt.x,size.y+size.h);}let tl=size.tl(),tr=size.tr(),bl=size.bl(),br=size.br();let allowT,allowB,allowL,allowR;/*let distanceT: number = Number.POSITIVE_INFINITY, distanceB: number = Number.POSITIVE_INFINITY,\r\n            distanceL: number = Number.POSITIVE_INFINITY, distanceR: number = Number.POSITIVE_INFINITY;*/let intersectionT,intersectionB,intersectionL,intersectionR;allowT=Geom.isNumberBetween(tl.y,bl.y,targetPt.y);allowB=Geom.isNumberBetween(bl.y,tl.y,targetPt.y);allowL=Geom.isNumberBetween(tl.x,tr.x,targetPt.x);allowR=Geom.isNumberBetween(tr.x,tl.x,targetPt.x);// console.log(\"closestIntersection pt0\", {size, targetPt, pt0:pt0.raw(), gridAlign,\n//     corners:{tl:tl.raw(), tr:tr.raw(), bl:bl.raw(), br:br.raw()}, allows:{allowT, allowB, allowL, allowR}});\nif(!(allowT||allowB||allowL||allowR))return undefined;// point is internal to size\nif(allowT)intersectionT=Geom.lineToSegmentIntersection(tl,tr,q,m);else if(allowB)intersectionB=Geom.lineToSegmentIntersection(bl,br,q,m);// NOT else, (T|B) AND (L|R) can happen, or just 1 or 0 of those.\nif(allowL)intersectionL=Geom.lineToSegmentIntersection(tl,bl,q,m);else if(allowR)intersectionR=Geom.lineToSegmentIntersection(tr,br,q,m);// console.log(\"closestIntersection pt2\", {intersectionT, intersectionB, intersectionL, intersectionR});\n// only 1 intersection can happen\nreturn intersectionT||intersectionB||intersectionL||intersectionR;}static closestIntersection_old(size,prevPt,pt0,gridAlign){let ret=GraphSize.closestIntersection0(size,prevPt,pt0,gridAlign);// Log.exDev(!Geom.isOnEdge(ret, size), 'ClosestIntersection failed. not on Vertex edge.', {ret, size, prevPt, pt0, gridAlign});\nreturn ret;}static closestIntersection0(vertexGSize,prevPt,pt0,gridAlign){let pt=pt0.duplicate();const m=GraphPoint.getM(prevPt,pt);const q=GraphPoint.getQ(prevPt,pt);// U.pe( Math.abs((pt.y - m * pt.x) - (prevPt.y - m * prevPt.x)) > .001, 'wrong math in Q:', (pt.y - m * pt.x), ' vs ', (prevPt.y - m * prevPt.x));\n/*const isL = prevPt.x < pt.x;\r\n    const isT = prevPt.y < pt.y;\r\n    const isR = !isL;\r\n    const isB = !isT; */if(m===Number.POSITIVE_INFINITY&&q===Number.NEGATIVE_INFINITY){// bottom middle\nreturn new GraphPoint(vertexGSize.x+vertexGSize.w/2,vertexGSize.y+vertexGSize.h);}// console.log('pt:', pt, 'm:', m, 'q:', q);\nlet L=new GraphPoint(0,0);let T=new GraphPoint(0,0);let R=new GraphPoint(0,0);let B=new GraphPoint(0,0);L.x=vertexGSize.x;L.y=m*L.x+q;R.x=vertexGSize.x+vertexGSize.w;R.y=m*R.x+q;T.y=vertexGSize.y;T.x=(T.y-q)/m;B.y=vertexGSize.y+vertexGSize.h;B.x=(B.y-q)/m;// prendo solo il compreso pt ~ prevPt (escludo così il \"pierce\" sulla faccia opposta), prendo il più vicino al centro.\n// console.log('4 possibili punti di intersezione (LTBR):', L, T, B, R);\n/* this.owner.mark(this.owner.toHtmlCoord(T), true, 'blue');\r\n    this.owner.mark(this.owner.toHtmlCoord(B), false, 'violet');\r\n    this.owner.mark(this.owner.toHtmlCoord(L), false, 'red');\r\n    this.owner.mark(this.owner.toHtmlCoord(R), false, 'orange');*/console.log(\"intersect pt1:\",{T,B,L,R});if(B.x>=pt.x&&B.x<=prevPt.x||B.x>=prevPt.x&&B.x<=pt.x){}else{B=null;}if(T.x>=pt.x&&T.x<=prevPt.x||T.x>=prevPt.x&&T.x<=pt.x){}else{T=null;}if(L.y>=pt.y&&L.y<=prevPt.y||L.y>=prevPt.y&&L.y<=pt.y){}else{L=null;}if(R.y>=pt.y&&R.y<=prevPt.y||R.y>=prevPt.y&&R.y<=pt.y){}else{R=null;}console.log(\"intersect pt2:\",{T,B,L,R});function closestmix(pt,closest,segStart,segEnd,mode){// changes pt\npt.x=closest.x;pt.y=closest.y;return;let main,sub;if(mode===\"TB\"){main=\"y\";sub=\"x\";}else{main=\"x\";sub=\"y\";}pt[main]=closest[main];// if T[sub] is inside the top segment, take T[sub], otherwise closest between size.tl[sub] and size.tr[sub]\n// pt[sub] = Math.max(segStart[sub], Math.min(segStart[sub], closest[sub]));\nif(closest[sub]<=segEnd[sub]&&closest[sub]>=segStart[sub])pt[sub]=closest[sub];else if(Math.abs(closest[sub]-segEnd[sub])<Math.abs(closest[sub]-segStart[sub]))pt[sub]=segEnd[sub];else pt[sub]=segStart[sub];}function closestmix2(pt,closest,segStart,segEnd,mode){// changes closest\nlet main,sub;if(mode===\"TB\"){main=\"y\";sub=\"x\";}else{main=\"x\";sub=\"y\";}// closest[main] = pt[main];\n// if T[sub] is inside the top segment, take T[sub], otherwise closest between size.tl[sub] and size.tr[sub]\n// pt[sub] = Math.max(segStart[sub], Math.min(segStart[sub], closest[sub]));\nif(closest[sub]<=segEnd[sub]&&closest[sub]>=segStart[sub]){/*no-op*/}else if(Math.abs(closest[sub]-segEnd[sub])<Math.abs(closest[sub]-segStart[sub]))closest[sub]=segEnd[sub];else closest[sub]=segStart[sub];}console.log(\"intersect pt2.5:\");try{if(T)closestmix2(pt,T,vertexGSize.tl(),vertexGSize.tr(),\"TB\");if(B)closestmix2(pt,B,vertexGSize.bl(),vertexGSize.br(),\"TB\");if(R)closestmix2(pt,R,vertexGSize.tr(),vertexGSize.br(),\"LR\");if(L)closestmix2(pt,L,vertexGSize.tl(),vertexGSize.bl(),\"LR\");}catch(e){console.error(\"intersect error\",e);}// console.log('superstiti step1: (LTBR):', L, T, B, R);\nconsole.log(\"intersect pt2.9:\");const vicinanzaT=!T?Number.POSITIVE_INFINITY:(T.x-pt.x)*(T.x-pt.x)+(T.y-pt.y)*(T.y-pt.y);const vicinanzaB=!B?Number.POSITIVE_INFINITY:(B.x-pt.x)*(B.x-pt.x)+(B.y-pt.y)*(B.y-pt.y);const vicinanzaL=!L?Number.POSITIVE_INFINITY:(L.x-pt.x)*(L.x-pt.x)+(L.y-pt.y)*(L.y-pt.y);const vicinanzaR=!R?Number.POSITIVE_INFINITY:(R.x-pt.x)*(R.x-pt.x)+(R.y-pt.y)*(R.y-pt.y);const closest=Math.min(vicinanzaT,vicinanzaB,vicinanzaL,vicinanzaR);console.log(\"intersect pt3:\",{vicinanzaT,vicinanzaB,vicinanzaL,vicinanzaR,closest});// console.log( 'closest:', closest);\n// succede quando pt e prevPt sono entrambi all'interno del rettangolo del vertice.\n// L'edge non è visibile e il valore ritornato è irrilevante.\nif(closest===Number.POSITIVE_INFINITY){/* top center */pt=vertexGSize.tl();pt.x+=vertexGSize.w/2;}else if(closest===Number.POSITIVE_INFINITY){/* bottom center */pt=vertexGSize.br();pt.x-=vertexGSize.w/2;}else if(closest===vicinanzaT&&T){closestmix(pt,T,vertexGSize.tl(),vertexGSize.tr(),\"TB\");/*pt.y = T.y;\r\n            // if T.x is inside the top segment, take T.x, otherwise closest between size.tl.x and size.tr.x\r\n            if ((T.x <= tr.x && T.x >= tl.x)) pt.x = T.x;\r\n            else if (Math.abs(T.x-tr.x) < Math.abs(T.x-tl.x)) pt.x = tr.x;\r\n            else pt.x = tl.x;*/}if(closest===vicinanzaB){closestmix(pt,B,vertexGSize.bl(),vertexGSize.br(),\"TB\");}else if(closest===vicinanzaR){closestmix(pt,R,vertexGSize.tr(),vertexGSize.br(),\"LR\");}else if(closest===vicinanzaL){closestmix(pt,L,vertexGSize.tl(),vertexGSize.bl(),\"LR\");}if(!gridAlign){return pt;}if(!pt)return null;if(gridAlign.x&&(pt===T||pt===B||isNaN(closest))){const floorX=Math.floor(pt.x/gridAlign.x)*gridAlign.x;const ceilX=Math.ceil(pt.x/gridAlign.x)*gridAlign.x;let closestX;let farthestX;if(Math.abs(floorX-pt.x)<Math.abs(ceilX-pt.x)){closestX=floorX;farthestX=ceilX;}else{closestX=ceilX;farthestX=floorX;}// todo: possibile causa del bug che non allinea punti fake a punti reali. nel calcolo realPT questo non viene fatto.\n// if closest grid intersection is inside the vertex.\nif(closestX>=vertexGSize.x&&closestX<=vertexGSize.x+vertexGSize.w){pt.x=closestX;}else// if 2° closer grid intersection is inside the vertex.\nif(closestX>=vertexGSize.x&&closestX<=vertexGSize.x+vertexGSize.w){pt.x=farthestX;// if no intersection are inside the vertex (ignore grid)\n}else{/* do nothing */}}else if(gridAlign.y&&(pt===L||pt===R)){const floorY=Math.floor(pt.y/gridAlign.y)*gridAlign.y;const ceilY=Math.ceil(pt.y/gridAlign.y)*gridAlign.y;let closestY;let farthestY;if(Math.abs(floorY-pt.y)<Math.abs(ceilY-pt.y)){closestY=floorY;farthestY=ceilY;}else{closestY=ceilY;farthestY=floorY;}// if closest grid intersection is inside the vertex.\nif(closestY>=vertexGSize.y&&closestY<=vertexGSize.y+vertexGSize.h){pt.y=closestY;}else// if 2° closer grid intersection is inside the vertex.\nif(closestY>=vertexGSize.y&&closestY<=vertexGSize.y+vertexGSize.h){pt.y=farthestY;// if no intersection are inside the vertex (ignore grid)\n}else{/* do nothing */}}return pt;}new(){for(var _len2=arguments.length,args=new Array(_len2),_key2=0;_key2<_len2;_key2++){args[_key2]=arguments[_key2];}return new GraphSize(...args);}makePoint(x,y){return new GraphPoint(x,y);}closestPoint(pt){return Geom.closestPoint(this,pt);}})||_class11);RuntimeAccessibleClass.set_extend(RuntimeAccessibleClass,ISize);RuntimeAccessibleClass.set_extend(ISize,Size);RuntimeAccessibleClass.set_extend(ISize,GraphSize);export let PositionStr=(_dec7=RuntimeAccessible('PositionStr'),_dec7(_class13=(_class14=class PositionStr{// left, centered, right\nconstructor(x,y){this.x=void 0;this.y=void 0;this.x=x!==null&&x!==void 0?x:0;this.y=y!==null&&y!==void 0?y:-1;}toString(){return PositionStr.toPosString(this);}invert(){let x=arguments.length>0&&arguments[0]!==undefined?arguments[0]:true;let y=arguments.length>1&&arguments[1]!==undefined?arguments[1]:true;if(x)this.x=-this.x;if(y)this.y=-this.y;return this;}static toPosString(o){let s;if(o.y===-1)s='t';else if(o.y===1)s='b';else s='';if(o.x===-1)s+='l';else if(o.x===1)s+='r';// else s = +'';\n// if (!s) return \"c\";\nreturn s;}static fromPosString(position){let ret=new PositionStr(0,0);let posarr=(position!==null&&position!==void 0?position:'t').split(' ');// .map(s=>s[0]);\nfor(let p of posarr)switch(p){default:case\"t\":case\"top\":ret.y=-1;break;case\"b\":case\"bottom\":ret.y=1;break;case\"l\":case\"left\":ret.x=-1;break;case\"r\":case\"right\":ret.x=1;break;case\"tl\":case\"lt\":case\"top left\":ret.y=-1;ret.x=-1;break;case\"tr\":case\"rt\":case\"top right\":ret.y=-1;ret.x=1;break;case'':case'c':ret.x=0;ret.y=0;break;case\"bl\":case\"lb\":case\"bottom left\":ret.y=1;ret.x=-1;break;case\"br\":case\"rb\":case\"bottom right\":ret.y=1;ret.x=1;break;}return ret;}static invertPosStr(pos){return PositionStr.fromPosString(pos).invert().toString();}static toFullLabelSingle(position){switch(position===null||position===void 0?void 0:position.trim()[0]){case'c':case'':return'center';case't':return'top';default:if(position.trim()==='')return'center';return'bottom';case'b':return'bottom';case'l':return'left';case'r':return'right';}}// tl -> top left\nstatic toSeparateFullLabels(position){let pos=(position!==null&&position!==void 0?position:'b').trim();if(pos.length===2){return PositionStr.toFullLabelSingle(pos[0])+' '+PositionStr.toFullLabelSingle(pos[1]);}else if(pos.indexOf(' ')){return pos.split(' ').map(s=>PositionStr.toFullLabelSingle(s)).join(' ');}else return PositionStr.toFullLabelSingle(pos[0]);return\"\";}},_class14.cname='PositionStr',_class14))||_class13);export let Geom=(_dec8=RuntimeAccessible('Geom'),_dec8(_class15=(_class16=class Geom extends RuntimeAccessibleClass{static unmark(key){if(!Geom.markings[key])return false;let e=Geom.markings[key];U.removeFromDom(e);delete Geom.markings[key];return true;}static markPt(key,pt,color,label){return Geom.mark(key,pt.x,pt.y,1,1,color,label);}static markSize(key,pt,color,label){var _pt$w,_pt$h;return Geom.mark(key,pt.x,pt.y,(_pt$w=pt.w)!==null&&_pt$w!==void 0?_pt$w:1,(_pt$h=pt.h)!==null&&_pt$h!==void 0?_pt$h:1,color,label);}static mark(key,x,y){let w=arguments.length>3&&arguments[3]!==undefined?arguments[3]:1;let h=arguments.length>4&&arguments[4]!==undefined?arguments[4]:1;let color=arguments.length>5&&arguments[5]!==undefined?arguments[5]:'red';let label=arguments.length>6&&arguments[6]!==undefined?arguments[6]:'';if(Geom.markings[key])Geom.unmark(key);let e;let pre='<div class=\"debug-mark\" data-key=\"'+key+'\" data-label=\"'+label+'\" style=\"position: absolute; z-index:99999; left:'+x+'px; top:'+y+'px; width: '+w+'px; height: '+h+'px;';let post='\"/>';if(w+h>2){e=U.toHtml(pre+'border-radius:0; background: transparent;'+post);}else{e=U.toHtml(pre+'border-radius:100%; background: '+color+'; outline: 1px solid '+color+'; outline-offset: 5px;'+post);}document.body.append(e);Geom.markings[key]=e;return e;}// warning: nodes from other iframes will say are not instance from Element of the current frame, in that case need duck typing.\nstatic isHtmlNode(element){return element instanceof Element||element instanceof HTMLDocument||element instanceof SVGElement;}static isPositiveZero(m){if(!!Object.is){return Object.is(m,+0);}return 1/m===Number.POSITIVE_INFINITY;}static isNegativeZero(m){if(!!Object.is){return Object.is(m,-0);}return 1/m===Number.NEGATIVE_INFINITY;}static TanToRadian(n){return Geom.DegreeToRad(Geom.TanToDegree(n));}static TanToDegree(n){if(Geom.isPositiveZero(n)){return 0;}if(n===Number.POSITIVE_INFINITY){return 90;}if(Geom.isNegativeZero(n)){return 180;}if(n===Number.POSITIVE_INFINITY){return 270;}return Geom.RadToDegree(window.Math.atan(n));}static RadToDegree(radians){return Geom.radToDeg(radians);}static DegreeToRad(degree){return Geom.degToRad(degree);}static radToDeg(radians){return radians*(180/Math.PI);}static degToRad(degree){return degree*(Math.PI/180);}// 0.001;\nstatic isOnEdge(pt,shape){let tolerance=arguments.length>2&&arguments[2]!==undefined?arguments[2]:Geom.GeomTolerance;return Geom.isOnHorizontalEdges(pt,shape,tolerance)||Geom.isOnVerticalEdges(pt,shape,tolerance);}static isOnVerticalEdges(pt,shape){let tolerance=arguments.length>2&&arguments[2]!==undefined?arguments[2]:Geom.GeomTolerance;return Geom.isOnLeftEdge(pt,shape,tolerance)||Geom.isOnRightEdge(pt,shape,tolerance);}static isOnHorizontalEdges(pt,shape){let tolerance=arguments.length>2&&arguments[2]!==undefined?arguments[2]:Geom.GeomTolerance;return Geom.isOnTopEdge(pt,shape,tolerance)||Geom.isOnBottomEdge(pt,shape,tolerance);}static isOnRightEdge(pt,shape){let tolerance=arguments.length>2&&arguments[2]!==undefined?arguments[2]:Geom.GeomTolerance;if(!pt||!shape){return false;}if(tolerance)return Math.abs(pt.x-(shape.x+shape.w))<tolerance&&pt.y-shape.y>tolerance&&pt.y-(shape.y+shape.h)<tolerance;return pt.x===shape.x+shape.w&&pt.y>=shape.y&&pt.y<=shape.y+shape.h;}static isOnLeftEdge(pt,shape){let tolerance=arguments.length>2&&arguments[2]!==undefined?arguments[2]:Geom.GeomTolerance;if(!pt||!shape){return false;}if(tolerance)return Math.abs(pt.x-shape.x)<tolerance&&pt.y-shape.y>tolerance&&pt.y-(shape.y+shape.h)<tolerance;return pt.x===shape.x&&pt.y>=shape.y&&pt.y<=shape.y+shape.h;}static isOnTopEdge(pt,shape){let tolerance=arguments.length>2&&arguments[2]!==undefined?arguments[2]:Geom.GeomTolerance;if(!pt||!shape){return false;}if(tolerance)return Math.abs(pt.y-shape.y)<tolerance&&pt.x-shape.x>tolerance&&pt.x-(shape.x+shape.w)<tolerance;return pt.y===shape.y&&pt.x>=shape.x&&pt.x<=shape.x+shape.w;}static isOnBottomEdge(pt,shape,tolerance){if(!pt||!shape){return false;}if(tolerance)return Math.abs(pt.y-shape.y+shape.h)<tolerance&&pt.x-shape.x>tolerance&&pt.x-(shape.x+shape.w)<tolerance;return pt.y===shape.y+shape.h&&pt.x>=shape.x&&pt.x<=shape.x+shape.w;}static closestPoint(size,pt){let top_closest=Geom.closestPointToSegment(size.tl(),size.tr(),pt);let bot_closest=Geom.closestPointToSegment(size.bl(),size.br(),pt);let left_closest=Geom.closestPointToSegment(size.tl(),size.bl(),pt);let right_closest=Geom.closestPointToSegment(size.tr(),size.br(),pt);let top_distance=top_closest.distanceFromPoint(pt,false);let bot_distance=bot_closest.distanceFromPoint(pt,false);let left_distance=left_closest.distanceFromPoint(pt,false);let right_distance=right_closest.distanceFromPoint(pt,false);let min_distance=Math.min(top_distance,bot_distance,left_distance,right_distance);if(min_distance===top_distance)return top_closest;if(min_distance===bot_distance)return bot_closest;if(min_distance===left_distance)return left_closest;return right_closest;}static isMinusZero(number){return 1/number==-Infinity;}static closestPointToSegment(segStart,segEnd,pt){// 1) find equation of line passing for start, end.\n// 2) then find all perpendicular lines, then the perpendicular line that pass through pt\n// 3) find intersection between Line(s,e) and line of point 2.\n// 4A) IF intersection is part of segment(s,e) that is closest.\n// 4B) ELSE, one of the 2 extremes of the segment is closest.\nlet x_intersect,y_intersect;let s=segStart;let e=segEnd;let mse=(e.y-s.y)/(e.x-s.x);if(mse===Number.POSITIVE_INFINITY||mse===Number.NEGATIVE_INFINITY){// s and e are both on the same y vertical line (same x)      // new GraphPoint(segStart.x, pt.y);\nx_intersect=segStart.x;y_intersect=pt.y;// 1), 2), 3) all done shortcut\n}else if(mse===0||Geom.isNegativeZero(mse)){// s and e are both on the same x horizontal line (same y)    // new GraphPoint(pt.x, segStart.y);\nx_intersect=pt.x;y_intersect=segStart.y;// 1), 2), 3) all done shortcut\n}else{let q=s.y-mse*s.x;// y = mx + q           q = y-mx\n// 1) done\nlet pmse=-1/mse;// perpendicular to mse\nlet pq=pt.y-pmse*pt.x;// 2) done\n//  m1 * x + q1 = y    -->   m1 * x + q1 = m2 * x + q2    -->    (m1-m2)x = q2-q1      -->     x=(q2-q1)/(m1-m2)\nx_intersect=(pq-q)/(mse-pmse);y_intersect=mse*x_intersect+q;//  y = mx +q\n// 3) done\n}let maxX,minX;let maxY,minY;if(s.x>e.x){maxX=s.x;minX=e.x;}else{maxX=e.x;minX=s.x;}if(s.y>e.y){maxY=s.y;minY=e.y;}else{maxY=e.y;minY=s.y;}if(x_intersect>=minX&&x_intersect<=maxX&&y_intersect>=minY&&y_intersect<=maxY)return new GraphPoint(x_intersect,y_intersect);// 4A) IF done\nlet sdist=(s.x-x_intersect)**2+(s.y-y_intersect)**2;// actual distance is sqrt() of this, but i just need to find closest, not correct distance.\nlet edist=(e.x-x_intersect)**2+(e.y-y_intersect)**2;return sdist<edist?new GraphPoint(s.x,s.y):new GraphPoint(e.x,e.y);// 4B) ELSE done\n}static lineToSegmentIntersection(segStart,segEnd,q,m){if(segStart.x===segEnd.x){let y=m*segStart.x+q;if(Geom.isNumberBetween(y,segStart.y,segEnd.y))return new GraphPoint(segStart.x,y);else return undefined;}else if(segStart.y===segEnd.y){let x=(segStart.y-q)/m;if(Geom.isNumberBetween(x,segStart.x,segEnd.x))return new GraphPoint(x,segStart.y);else return undefined;//\n}let m2=segStart.getM(segEnd);let q2=IPoint.getQ(segStart,segEnd);if(m===m2){if(q2===q)return segStart;// line and segment coincident\nreturn undefined;// parallel\n}let intersect=Geom.lineToLineIntersection(m,q,m2,q2);if(intersect&&Geom.isNumberBetween(intersect.x,segStart.x,segEnd.x)&&Geom.isNumberBetween(intersect.y,segStart.y,segEnd.y))return intersect;else return undefined;}static isNumberBetween(target,s,e){let max=Math.max(s,e);let min=Math.min(s,e);return target>=min&&target<=max;}static lineToLineIntersection(m,q,m2,q2){let retIfParallel=arguments.length>4&&arguments[4]!==undefined?arguments[4]:undefined;let retIfCoincident=arguments.length>5&&arguments[5]!==undefined?arguments[5]:undefined;if(m===m2){if(q===q2)return retIfCoincident;return retIfParallel;}if(m===Number.POSITIVE_INFINITY||m===Number.NEGATIVE_INFINITY||m2===Number.POSITIVE_INFINITY||m2===Number.NEGATIVE_INFINITY){// m or m2 are a vertical line, Q must be invalid too and i don't have a single point of the line.\n// it's actually infinite possible vertical parallel lines.\nreturn undefined;}/*\r\n            y = mx + q\r\n            y = nx + w\r\n            -->\r\n            mx + q = nx + w\r\n            -->\r\n            mx - nx = w - q\r\n            -->\r\n            x (m - n) = w - q\r\n            -->\r\n            x = (w - q)/(m - n)\r\n        */let x=(q2-q)/(m-m2);return new GraphPoint(x,m*x+q);}// @param start, end: are for determining direction. every m is a line that can be seen in 2 direction\nstatic mToRad(m,start,end){let rad;if(start.x===end.x){rad=start.y<end.y?Math.PI*3/2:Math.PI/2;}else{// console.log(\"rad diagonal\", {base:  Math.atan(m), add: start.x > end.x, sx: start.x, ex: end.x});\nrad=Math.atan(m)+(start.x>end.x?0:Math.PI);}return rad;}// intersect a rectangle with a line or segment (if end parameter is specified)\n// @return: [0, 2] intersections\nstatic lineToSizeIntersection_TODO(size,m,startLine,endIfSegment){// todo: use GraphSize.closestIntersection which is close. it is size-segment returning only the closest intersection\nreturn[];}},_class16.markings={},_class16.GeomTolerance=0,_class16))||_class15);RuntimeAccessibleClass.set_extend(RuntimeAccessibleClass,Geom);","map":{"version":3,"names":["U","DPointerTargetable","RuntimeAccessible","windoww","Log","RuntimeAccessibleClass","IPoint","_dec","_class","_class2","getM","firstPt","secondPt","y","x","getQ","m","undefined","constructor","arguments","length","init_constructor","thiss","id","maxID","Date","getTime","className","name","isNaN","cname","raw","toString","letters","separator","JSON","stringify","clone","other","duplicate","ret","new","distanceFromPoint","tentativeEnd","skipSqrt","d_pow2","Math","sqrt","subtract","p2","newInstance","e","p1","add","addAll","p","i","p0","subtractAll","multiply","pt","divide","multiplyScalar","scalar","divideScalar","isInTheMiddleOf","tolleranza","rectangle","Size","fromPoints","tolleranzaX","tolleranzaY","w","h","lineDistance","distanceFromLine","top","bot","abs","equals","moveOnNearestBorder","startVertexSize","graph","debug","tl","tr","bl","br","L","R","T","B","min","GraphPoint","markg","pt2","_IPoint$getM","call","degreeWith","toRadians","directionVector","atan2","RadToDegree","absolute","set","move","rad","distance","cos","sin","subclasses","_extends","_dec2","_class3","dontmixwithPoint","fromEvent","Point","pageX","pageY","g","Error","toGraphCoord","toSize","GraphSize","_dec3","_class5","dontmixwithGPoint","set_extend","ISize","_dec4","_class7","_class8","json","makePoint","center","relativePoint","xPercent","yPercent","size","minSize","max","maxSize","intersection","startx","starty","endx","endy","doesintersect","contains","isOverlapping","size2","isOverlappingAnyOf","sizes","multiplyPoint","dividePoint","boundary","_dec5","_class9","_class10","dontMixWithGraphSize","of","element0","_element$ownerDocumen","sizePostTransform","element","document","ww","body","$element","$","ex","tagName","tmp","sizeofvar","createElement","append","isOrphan","parentNode","ancestors","ancestorArray","displayStyles","map","_e$style","style","display","_ancestors$i","_ancestors$i$style","getComputedStyle","rect","getBoundingClientRect","win","ownerDocument","defaultView","window","left","scrollX","scrollY","width","height","offsetWidth","offsetHeight","_ancestors$i$style2","removeProperty","clear","minX","maxX","minY","maxY","_len","args","Array","_key","$sizeofvar","_dec6","_class11","dontMixWithSize","closestIntersection","targetPt","gridAlign","m0","q0","q","Number","POSITIVE_INFINITY","allowT","allowB","allowL","allowR","intersectionT","intersectionB","intersectionL","intersectionR","Geom","isNumberBetween","lineToSegmentIntersection","closestIntersection_old","prevPt","pt0","closestIntersection0","vertexGSize","NEGATIVE_INFINITY","console","log","closestmix","closest","segStart","segEnd","mode","main","sub","closestmix2","error","vicinanzaT","vicinanzaB","vicinanzaL","vicinanzaR","floorX","floor","ceilX","ceil","closestX","farthestX","floorY","ceilY","closestY","farthestY","_len2","_key2","closestPoint","PositionStr","_dec7","_class13","_class14","toPosString","invert","o","s","fromPosString","position","posarr","split","invertPosStr","pos","toFullLabelSingle","trim","toSeparateFullLabels","indexOf","join","_dec8","_class15","_class16","unmark","key","markings","removeFromDom","markPt","color","label","mark","markSize","_pt$w","_pt$h","pre","post","toHtml","isHtmlNode","Element","HTMLDocument","SVGElement","isPositiveZero","Object","is","isNegativeZero","TanToRadian","n","DegreeToRad","TanToDegree","atan","radians","radToDeg","degree","degToRad","PI","isOnEdge","shape","tolerance","GeomTolerance","isOnHorizontalEdges","isOnVerticalEdges","isOnLeftEdge","isOnRightEdge","isOnTopEdge","isOnBottomEdge","top_closest","closestPointToSegment","bot_closest","left_closest","right_closest","top_distance","bot_distance","left_distance","right_distance","min_distance","isMinusZero","number","Infinity","x_intersect","y_intersect","mse","pmse","pq","sdist","edist","m2","q2","intersect","lineToLineIntersection","target","retIfParallel","retIfCoincident","mToRad","start","end","lineToSizeIntersection_TODO","startLine","endIfSegment"],"sources":["C:/0Programmi/Dev/projects/frontend/jjodel/src/common/Geom.ts"],"sourcesContent":["import {GObject, Temporary, TODO, U} from \"../joiner\";\r\nimport {DPointerTargetable, RuntimeAccessible, windoww, Log, RuntimeAccessibleClass, Dictionary} from \"../joiner\";\r\nimport React from \"react\";\r\nimport {radian} from \"../joiner/types\";\r\n\r\n@RuntimeAccessible('IPoint')\r\nexport abstract class IPoint extends RuntimeAccessibleClass {\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    public x!: number;\r\n    public y!: number;\r\n\r\n    // @ts-ignore static getM is not null but must be declared nullable to achieve subclass mixing\r\n    // public static getM? = function(firstPt: IPoint, secondPt: IPoint): number { return (firstPt.y - secondPt.y) / (firstPt.x - secondPt.x); }\r\n    public static getM(firstPt: IPoint, secondPt: IPoint): number { return (firstPt.y - secondPt.y) / (firstPt.x - secondPt.x); }\r\n    public static getQ(firstPt: IPoint, secondPt: IPoint, m?: number): number {\r\n        if (m === undefined) m = IPoint.getM(firstPt, secondPt);\r\n        return firstPt.y - (m * firstPt.x);\r\n    }\r\n\r\n    public constructor(x: number = 0, y: number = 0) {\r\n        super(); // super('dwc');\r\n        IPoint.init_constructor(this, x, y);\r\n    }\r\n\r\n    static init_constructor(thiss: GObject, x: any = 0, y: any = 0, ...a: any): void {\r\n        thiss.id = \"POINT_\" + (DPointerTargetable.maxID++) + \"_\" + new Date().getTime();\r\n        thiss.className = thiss.constructor.name;\r\n        if (x === null || x === undefined) thiss.x = undefined as Temporary;\r\n        else if (isNaN(+x)) { thiss.x = 0; }\r\n        else thiss.x = +x;\r\n        if (y === null || y === undefined) thiss.y = undefined as Temporary;\r\n        else if (isNaN(+y)) { thiss.y = 0; }\r\n        else thiss.y = +y;\r\n        thiss.className = this.cname;\r\n    }\r\n\r\n    public raw(): {x: number, y: number} { return {x: this.x, y: this.y}; }\r\n\r\n    public toString(letters: boolean=true, separator: string = \" \"): string {\r\n        if (letters) return  JSON.stringify({x:this.x, y: this.y});\r\n        else return this.x + separator + this.y + separator;\r\n    }\r\n    public clone(other: { x: number, y: number }): this { this.x = other.x; this.y = other.y; return this; }\r\n\r\n    protected abstract new(): this;\r\n    abstract toSize(w: number, h?: number): ISize;\r\n    public duplicate(): this { const ret = this.new(); ret.clone(this); return ret; }\r\n\r\n    public distanceFromPoint(tentativeEnd: IPoint, skipSqrt: boolean = false): number {\r\n        let d_pow2 = (this.x - tentativeEnd.x)**2 + (this.y - tentativeEnd.y)**2;\r\n        return skipSqrt ? d_pow2 : Math.sqrt(d_pow2);\r\n        // return this.subtract(tentativeEnd, true).absolute();\r\n    }\r\n\r\n    public subtract(p2: { x?: number, y?: number }, newInstance: boolean): this {\r\n        Log.e(!p2, 'subtract argument must be a valid point: ', p2);\r\n        let p1: this;\r\n        if (!newInstance) { p1 = this; } else { p1 = this.duplicate(); }\r\n        if (p2.x !== undefined) p1.x -= p2.x;\r\n        if (p2.y !== undefined) p1.y -= p2.y;\r\n        return p1; }\r\n\r\n    public add(p2: { x?: number, y?: number }, newInstance: boolean): this {\r\n        Log.e(!p2, 'add argument must be a valid point: ', p2);\r\n        let p1: this;\r\n        if (!newInstance) { p1 = this; } else { p1 = this.duplicate(); }\r\n        if (p2.x !== undefined) p1.x += p2.x;\r\n        if (p2.y !== undefined) p1.y += p2.y;\r\n        return p1; }\r\n\r\n    public addAll(p: IPoint[], newInstance: boolean): this {\r\n        let i;\r\n        let p0: this;\r\n        if (!newInstance) { p0 = this; } else { p0 = this.duplicate(); }\r\n        for (i = 0; i < p.length; i++) { p0.add(p[i], true); }\r\n        return p0; }\r\n\r\n    public subtractAll(p: this[], newInstance: boolean): this {\r\n        let i;\r\n        let p0: this;\r\n        if (!newInstance) { p0 = this; } else { p0 = this.duplicate(); }\r\n        for (i = 0; i < p.length; i++) { p0.subtract(p[i], true); }\r\n        return p0; }\r\n\r\n    public multiply(pt: {x?: number, y?: number} | number, newInstance: boolean = false): this {\r\n        let ret: this = (newInstance ? this.duplicate() : this);\r\n        if (typeof pt === \"number\") {\r\n            ret.x *= pt;\r\n            ret.y *= pt;\r\n        }\r\n        else {\r\n            if (pt.x !== undefined) ret.x *= pt.x;\r\n            if (pt.y !== undefined) ret.y *= pt.y;\r\n        }\r\n        return ret; }\r\n\r\n    public divide(pt: Partial<this> | number, newInstance: boolean = false): this {\r\n        let ret = (newInstance ? this.duplicate() : this);\r\n        if (typeof pt === \"number\") {\r\n            ret.x /= pt;\r\n            ret.y /= pt;\r\n        }\r\n        else {\r\n            ret.x /= pt.x as number;\r\n            ret.y /= pt.y as number;\r\n        }\r\n        return ret; }\r\n\r\n    public multiplyScalar(scalar: number, newInstance: boolean): this {\r\n        Log.e(isNaN(+scalar), 'IPoint.multiply()', 'scalar argument must be a valid number: ', scalar);\r\n        let p1: this;\r\n        if (!newInstance) { p1 = this; } else { p1 = this.duplicate(); }\r\n        p1.x *= scalar;\r\n        p1.y *= scalar;\r\n        return p1; }\r\n\r\n    public divideScalar(scalar: number, newInstance: boolean): this {\r\n        Log.e(isNaN(+scalar), 'IPoint.divide()', 'scalar argument must be a valid number: ', scalar);\r\n        let p1: this;\r\n        if (!newInstance) { p1 = this; } else { p1 = this.duplicate(); }\r\n        p1.x /= scalar;\r\n        p1.y /= scalar;\r\n        return p1; }\r\n\r\n    public isInTheMiddleOf(firstPt: this, secondPt: this, tolleranza: number): boolean {\r\n        const rectangle: Size = Size.fromPoints(firstPt, secondPt);\r\n        const tolleranzaX = tolleranza; // actually should be cos * arctan(m);\r\n        const tolleranzaY = tolleranza; // actually should be sin * arctan(m);\r\n        if (this.x < rectangle.x - tolleranzaX || this.x > rectangle.x + rectangle.w + tolleranzaX) { return false; }\r\n        if (this.y < rectangle.y - tolleranzaX || this.y > rectangle.y + rectangle.h + tolleranzaY) { return false; }\r\n        // const m = IPoint.getM(firstPt, secondPt);\r\n        // const q = IPoint.getQ(firstPt, secondPt);\r\n        const lineDistance = this.distanceFromLine(firstPt, secondPt);\r\n        // console.log('distance:', lineDistance, ', this:', this, ', p1:', firstPt, ', p2:', secondPt);\r\n        return lineDistance <= tolleranza; }\r\n\r\n    public distanceFromLine(p1: IPoint, p2: IPoint): number {\r\n        const top: number =\r\n            + (p2.y - p1.y) * this.x\r\n            - (p2.x - p1.x) * this.y\r\n            + p2.x * p1.y\r\n            - p1.x * p2.y;\r\n        const bot =\r\n            (p2.y - p1.y) * (p2.y - p1.y) +\r\n            (p2.x - p1.x) * (p2.x - p1.x);\r\n        return Math.abs(top) / Math.sqrt(bot);  }\r\n\r\n    public equals(pt: {x:number, y:number}, tolleranzaX: number = 0, tolleranzaY: number = 0): boolean {\r\n        if (pt === null) { return false; }\r\n        return Math.abs(this.x - pt.x) <= tolleranzaX && Math.abs(this.y - pt.y) <= tolleranzaY; }\r\n\r\n    public moveOnNearestBorder(startVertexSize: ISize, clone: boolean, graph: TODO/*IGraph*/, debug: boolean = true): IPoint {\r\n        const pt: IPoint = clone ? this.duplicate() : this;\r\n        const tl: IPoint = startVertexSize.tl();\r\n        const tr: IPoint = startVertexSize.tr();\r\n        const bl: IPoint = startVertexSize.bl();\r\n        const br: IPoint = startVertexSize.br();\r\n        const L: number = pt.distanceFromLine(tl, bl);\r\n        const R: number = pt.distanceFromLine(tr, br);\r\n        const T: number = pt.distanceFromLine(tl, tr);\r\n        const B: number = pt.distanceFromLine(bl, br);\r\n        const min: number = Math.min(L, R, T, B);\r\n        if (min === L) { pt.x = tl.x; }\r\n        if (min === R) { pt.x = tr.x; }\r\n        if (min === T) { pt.y = tr.y; }\r\n        if (min === B) { pt.y = br.y; }\r\n        if (debug && graph && pt instanceof GraphPoint) { graph.markg(pt, false, 'purple'); }\r\n        return pt; }\r\n\r\n    public getM(pt2: IPoint): number { return IPoint.getM?.(this, pt2) as unknown as number; }\r\n\r\n    public degreeWith(pt2: IPoint, toRadians: boolean): number {\r\n        const directionVector: IPoint = this.subtract(pt2, true);\r\n        const ret: number = Math.atan2(directionVector.y, directionVector.x);\r\n        return toRadians ? ret : windoww.U.RadToDegree(ret); }\r\n\r\n    public absolute(): number { return Math.sqrt(this.x * this.x + this.y * this.y); }\r\n    public set(x: number, y: number) { this.x = x; this.y = y; }\r\n\r\n    // move the point by a vector with direction and distance (module)\r\n    move(rad: radian /*in radians!*/, distance: number, clone:boolean = true): this{\r\n        let pt = clone ? this.duplicate() : this;\r\n        pt.x += distance * Math.cos(rad);\r\n        pt.y += distance * Math.sin(rad);\r\n        return pt;\r\n    }\r\n}\r\n\r\n@RuntimeAccessible('GraphPoint')\r\nexport class GraphPoint extends IPoint{\r\n    private dontmixwithPoint: any;\r\n    public static fromEvent(e: JQuery.ClickEvent | JQuery.MouseMoveEvent | JQuery.MouseUpEvent | JQuery.MouseDownEvent | JQuery.MouseEnterEvent | JQuery.MouseLeaveEvent | JQuery.MouseEventBase)\r\n        : GraphPoint | null {\r\n        if (!e) { return null; }\r\n        const p: Point = new Point(e.pageX, e.pageY);\r\n        const g: any = null;\r\n        throw new Error(\"todo: const g: IGraph = Status.status.getActiveModel().graph;\");\r\n        return g.toGraphCoord(p); }\r\n\r\n    protected new(): this { return new GraphPoint() as this;}\r\n    public toSize(w: number, h?: number): GraphSize {\r\n        return new GraphSize(this.x, this.y, w, (h === undefined) ? w : h);\r\n    }\r\n\r\n}\r\n\r\n\r\n@RuntimeAccessible('Point')\r\nexport class Point extends IPoint{\r\n    private dontmixwithGPoint: any;\r\n    /// https://stackoverflow.com/questions/6073505/what-is-the-difference-between-screenx-y-clientx-y-and-pagex-y\r\n    public static fromEvent(e: JQuery.ClickEvent | JQuery.MouseMoveEvent | JQuery.MouseUpEvent | JQuery.MouseDownEvent\r\n        | JQuery.MouseEnterEvent | JQuery.MouseLeaveEvent | JQuery.MouseEventBase | React.MouseEvent)\r\n        : Point {\r\n        const p: Point = new Point(e.pageX, e.pageY);\r\n        return p; }\r\n\r\n    protected new(): this { return new Point() as this;}\r\n    public toSize(w: number, h?: number): Size {\r\n        return new Size(this.x, this.y, w, (h === undefined) ? w : h);\r\n    }\r\n}\r\n\r\nRuntimeAccessibleClass.set_extend(RuntimeAccessibleClass, IPoint);\r\nRuntimeAccessibleClass.set_extend(IPoint, GraphPoint);\r\nRuntimeAccessibleClass.set_extend(IPoint, Point);\r\n\r\n@RuntimeAccessible('ISize')\r\nexport abstract class ISize<PT extends IPoint = IPoint> extends RuntimeAccessibleClass {\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    public x!: number;\r\n    public y!: number;\r\n    public w!: number;\r\n    public h!: number;\r\n    public constructor(x: number = 0, y: number = 0, w: number = 0, h: number = 0) {\r\n        super(); // super('dwc');\r\n        // do not override any fields from the DPointerTargetable, otherwise the ! in the override will reinizialize the attribute\r\n        // erasing the value set in super or in the functions called by the constructor as side effect (static_init called from constructor will be overridden too)\r\n        // if need to override types, build the \"new\" static function like in DModelElement\r\n        ISize.init_constructor(this, x, y, w, h);\r\n    }\r\n\r\n    static init_constructor(thiss: GObject, x: any = 0, y: any = 0, w: any = 0, h: any = 0, ...a: any): void {\r\n        thiss.id = \"SIZE_\" + (DPointerTargetable.maxID++) + \"_\" + new Date().getTime();\r\n        thiss.className = (thiss.constructor as typeof RuntimeAccessibleClass).cname;\r\n        if (x === null || x === undefined) thiss.x = undefined as Temporary;\r\n        else if (isNaN(+x)) { thiss.x = 0; }\r\n        else thiss.x = +x;\r\n        if (y === null || y === undefined) thiss.y = undefined as Temporary;\r\n        else if (isNaN(+y)) { thiss.y = 0; }\r\n        else thiss.y = +y;\r\n        if (w === null || w === undefined) thiss.w = undefined as Temporary;\r\n        else if (isNaN(+w)) { thiss.w = 0; }\r\n        else thiss.w = +w;\r\n        if (h === null || h === undefined) thiss.h = undefined as Temporary;\r\n        else if (isNaN(+h)) { thiss.h = 0; }\r\n        else thiss.h = +h;\r\n        thiss.className = this.cname; }\r\n\r\n    public toString(letters: boolean=true, separator: string = \" \"): string {\r\n        if (letters) return JSON.stringify({x: this.x, y: this.y, w: this.w, h: this.h});\r\n        else return this.x + separator + this.y + separator + this.w + separator + this.h;\r\n    }\r\n\r\n    public set(x?: number, y?: number, w?: number, h?: number): void {\r\n        if (x !== undefined) (this.x = +x);\r\n        if (y !== undefined) (this.y = +y);\r\n        if (w !== undefined) (this.w = +w);\r\n        if (h !== undefined) (this.h = +h);\r\n    }\r\n\r\n    protected abstract makePoint(x: number, y: number): PT;\r\n    protected abstract new(...args:any): this;\r\n    public clone(json: this): this { this.x = json.x; this.y = json.y; this.w = json.w; this.h = json.h; return this; }\r\n    public duplicate(): this { return this.new().clone(this); }\r\n\r\n    public add(pt2: number | {x?:number, y?:number, w?:number, h?:number}, newInstance?: boolean): this {\r\n        let thiss = newInstance ? this.duplicate() : this;\r\n        if (typeof pt2 === \"number\") { thiss.x += pt2; thiss.y += pt2; thiss.w += pt2; thiss.h += pt2; return thiss; }\r\n        if (pt2.x !== undefined) thiss.x += pt2.x;\r\n        if (pt2.y !== undefined) thiss.y += pt2.y;\r\n        if (pt2.w !== undefined) thiss.w += pt2.w;\r\n        if (pt2.h !== undefined) thiss.h += pt2.h;\r\n        return thiss; }\r\n\r\n    public subtract(pt2: number | {x?:number, y?:number, w?:number, h?:number}, newInstance?: boolean): this {\r\n        let thiss = newInstance ? this.duplicate() : this;\r\n        if (typeof pt2 === \"number\") { thiss.x -= pt2; thiss.y -= pt2; thiss.w -= pt2; thiss.h -= pt2; return thiss; }\r\n        if (pt2.x !== undefined) thiss.x -= pt2.x;\r\n        if (pt2.y !== undefined) thiss.y -= pt2.y;\r\n        if (pt2.w !== undefined) thiss.w -= pt2.w;\r\n        if (pt2.h !== undefined) thiss.h -= pt2.h;\r\n        return thiss; }\r\n\r\n    public multiply(pt2: number | {x?:number, y?:number, w?:number, h?:number}, newInstance?: boolean): this {\r\n        let thiss = newInstance ? this.duplicate() : this;\r\n        if (typeof pt2 === \"number\") { thiss.x *= pt2; thiss.y *= pt2; thiss.w *= pt2; thiss.h *= pt2; return thiss; }\r\n        if (pt2.x !== undefined) thiss.x *= pt2.x;\r\n        if (pt2.y !== undefined) thiss.y *= pt2.y;\r\n        if (pt2.w !== undefined) thiss.w *= pt2.w;\r\n        if (pt2.h !== undefined) thiss.h *= pt2.h;\r\n        return thiss; }\r\n\r\n    public divide(pt2: number | {x?:number, y?:number, w?:number, h?:number}, newInstance?: boolean): this {\r\n        let thiss = newInstance ? this.duplicate() : this;\r\n        if (typeof pt2 === \"number\") { thiss.x /= pt2; thiss.y /= pt2; thiss.w /= pt2; thiss.h /= pt2; return thiss; }\r\n        if (pt2.x !== undefined) thiss.x /= pt2.x;\r\n        if (pt2.y !== undefined) thiss.y /= pt2.y;\r\n        if (pt2.w !== undefined) thiss.w /= pt2.w;\r\n        if (pt2.h !== undefined) thiss.h /= pt2.h;\r\n        return thiss; }\r\n\r\n\r\n    public tl(): PT {     return this.makePoint(   this.x,                 this.y             ); }\r\n    public tr(): PT {     return this.makePoint(this.x + this.w,        this.y             ); }\r\n    public bl(): PT {     return this.makePoint(   this.x,              this.y + this.h    ); }\r\n    public br(): PT {     return this.makePoint(this.x + this.w,     this.y + this.h    ); }\r\n    public center(): PT { return this.makePoint(this.x + this.w / 2, this.y + this.h / 2); }\r\n    public relativePoint(xPercent: number, yPercent: number): PT { return this.makePoint(this.x + this.w * xPercent, this.y + this.h * yPercent); }\r\n    public equals(size: this): boolean { return this.x === size.x && this.y === size.y && this.w === size.w && this.h === size.h; }\r\n\r\n    /// field-wise Math.min()\r\n    public min(minSize: this, clone: boolean): this {\r\n        const ret: this = clone ? this.new() : this;\r\n        if (!isNaN(minSize.x) && ret.x < minSize.x) { ret.x = minSize.x; }\r\n        if (!isNaN(minSize.y) && ret.y < minSize.y) { ret.y = minSize.y; }\r\n        if (!isNaN(minSize.w) && ret.w < minSize.w) { ret.w = minSize.w; }\r\n        if (!isNaN(minSize.h) && ret.h < minSize.h) { ret.h = minSize.h; }\r\n        return ret; }\r\n    public max(maxSize: this, clone: boolean): this {\r\n        const ret: this = clone ? this.new() : this;\r\n        if (!isNaN(maxSize.x) && ret.x > maxSize.x) { ret.x = maxSize.x; }\r\n        if (!isNaN(maxSize.y) && ret.y > maxSize.y) { ret.y = maxSize.y; }\r\n        if (!isNaN(maxSize.w) && ret.w > maxSize.w) { ret.w = maxSize.w; }\r\n        if (!isNaN(maxSize.h) && ret.h > maxSize.h) { ret.h = maxSize.h; }\r\n        return ret; }\r\n\r\n    public intersection(size: this): this | null {\r\n        if (!size) return null;\r\n        // anche \"isinside\"\r\n        let startx, starty, endx, endy;\r\n        startx = Math.max(this.x, size.x);\r\n        starty = Math.max(this.y, size.y);\r\n        endx = Math.min(this.x + this.w, size.x + size.w);\r\n        endy = Math.min(this.y + this.h, size.y + size.h);\r\n        const intersection: this = this.new();\r\n        // intersection.set(0, 0, 0, 0);\r\n        intersection.x = startx;\r\n        intersection.y = starty;\r\n        intersection.w = endx - startx;\r\n        intersection.h = endy - starty;\r\n        const doesintersect: boolean = intersection.w > 0 && intersection.h > 0;\r\n        return (doesintersect) ? intersection: null; }\r\n\r\n    public contains(pt: PT): boolean {\r\n        return  pt.x >= this.x && pt.x <= this.x + this.w && pt.y >= this.y && pt.y <= this.y + this.h; }\r\n\r\n    public isOverlapping(size2: this): boolean { return !!this.intersection(size2); }\r\n    public isOverlappingAnyOf(sizes: this[]): boolean {\r\n        if (!sizes) return false;\r\n        for (let size of sizes) { if (this.isOverlapping(size)) return true; }\r\n        return false;\r\n    }\r\n\r\n    public multiplyPoint(other: PT, newInstance: boolean): this {\r\n        const ret: this = newInstance ? this.new() : this;\r\n        ret.x *= other.x;\r\n        ret.w *= other.x;\r\n        ret.y *= other.y;\r\n        ret.h *= other.y;\r\n        return ret; }\r\n\r\n    public dividePoint(other: PT, newInstance: boolean): this {\r\n        const ret: this = newInstance ? this.new() : this;\r\n        ret.x /= other.x;\r\n        ret.w /= other.x;\r\n        ret.y /= other.y;\r\n        ret.h /= other.y;\r\n        return ret; }\r\n\r\n    public boundary(size2: this): void {\r\n        /*let minx, maxx, miny, maxy;\r\n        if (size2.y < this.y) { miny = size2.y; /*maxy = this.y;* / } else { miny = this.y; /*maxy = size2.y;* / }\r\n        if (size2.x < this.x) { minx = size2.y; /*maxx = this.x;* / } else { minx = this.x; /*maxy = size2.x;* / }\r\n        if (size2.y + size2.h < this.y + this.h) maxy = this.y + this.h; else maxy = size2.y + size2.h;\r\n        if (size2.x + size2.w < this.x + this.w) maxx = this.x + this.w; else maxx = size2.x + size2.w;\r\n        */\r\n        this.h = (size2.y + size2.h > this.y + this.h ? size2.y + size2.h : this.y + this.h); // -miny\r\n        this.w = (size2.x + size2.w > this.x + this.w ? size2.x + size2.w : this.x + this.w); // -minx\r\n        if (this.y < size2.y) this.y = size2.y;\r\n        if (this.x < size2.x) this.x = size2.x;\r\n        this.h -= this.y;\r\n        this.w -= this.x;\r\n    }\r\n}\r\n\r\n@RuntimeAccessible('Size')\r\nexport class Size extends ISize<Point> {\r\n    static subclasses: any[] = [];\r\n    private static sizeofvar: HTMLElement;\r\n    private static $sizeofvar: JQuery<HTMLElement>;\r\n    private dontMixWithGraphSize: any;\r\n\r\n    /**\r\n     * measure a node size\r\n     * @param {Element} element0 - the emelemnt to measure;\r\n     * @param {boolean} sizePostTransform - includes css transform instructions for computing his size. like transform: scale(1.5)\r\n     * */\r\n    public static of(element0: Element, sizePostTransform: boolean = true): Size {\r\n        let element: HTMLElement = element0 as HTMLElement;\r\n        if (element as unknown === document) {\r\n            Log.ww('trying to measure document, rerouted to measuring body.');\r\n            element = document.body as any;\r\n        }\r\n        const $element = $(element);\r\n        Log.ex(!element || element.tagName === 'foreignObject', 'sizeof()', 'SvgForeignElementObject have a bug with size, measure a child instead.', element);\r\n        let tmp;\r\n        let size: Size;\r\n        if (!Size.sizeofvar) {\r\n            Size.sizeofvar = document.createElement('div');\r\n            document.body.append(Size.sizeofvar); }\r\n\r\n        const isOrphan = element.parentNode === null;\r\n        // var visible = element.style.display !== 'none';\r\n        // var visible = $element.is(\":visible\"); crea bug quando un elemento è teoricamente visibile ma orfano\r\n        const ancestors =  windoww.U.ancestorArray(element);\r\n        const displayStyles: string[] = ancestors.map( (e: HTMLElement) => e?.style?.display);\r\n        if (isOrphan) { Size.sizeofvar.append(element); }\r\n        // show all and saveToDB visibility to restore it later\r\n        for (let i = 0; i < ancestors.length; i++) { // document has undefined style\r\n            displayStyles[i] = ancestors[i]?.style?.display;\r\n            if (displayStyles[i] === 'none' || (displayStyles[i] === '' && getComputedStyle(ancestors[i]).display === 'none')) { ancestors[i].style.display = 'block' }\r\n        }\r\n        // size = new Size(tmp.left, tmp.top, 0, 0);\r\n        let rect = element.getBoundingClientRect();\r\n        size = new Size(0, 0, 0, 0);\r\n\r\n        let win = (element.ownerDocument?.defaultView || window);\r\n        size.x = rect.left + win.scrollX;\r\n        size.y = rect.top + win.scrollY;\r\n        if (sizePostTransform) {\r\n            size.w = rect.width;\r\n            size.h = rect.height;\r\n        }\r\n        else {\r\n            size.w = element.offsetWidth; // element.scrollWidth;\r\n            size.h = element.offsetHeight;\r\n        }\r\n        // restore visibility\r\n        for (let i = 0; i < ancestors.length; i++) {\r\n            if (displayStyles[i] === ancestors[i].style?.display) continue;\r\n            if (displayStyles[i]) ancestors[i].style.display = displayStyles[i];\r\n            else ancestors[i].style.removeProperty('display');\r\n        }\r\n        if (isOrphan) {  windoww.U.clear(Size.sizeofvar); }\r\n        // Status.status.getActiveModel().graph.markS(size, false);\r\n        return size;\r\n    }\r\n\r\n    public static fromPoints(firstPt: IPoint, secondPt: IPoint): Size {\r\n        const minX = Math.min(firstPt.x, secondPt.x);\r\n        const maxX = Math.max(firstPt.x, secondPt.x);\r\n        const minY = Math.min(firstPt.y, secondPt.y);\r\n        const maxY = Math.max(firstPt.y, secondPt.y);\r\n        return new Size(minX, minY, maxX - minX, maxY - minY); }\r\n\r\n    protected makePoint(x: number, y: number): Point { return new Point(x, y); }\r\n    protected new(...args:any): this { return new Size(...args) as this; }\r\n}\r\n@RuntimeAccessible('GraphSize')\r\nexport class GraphSize extends ISize<GraphPoint> {\r\n    private dontMixWithSize: any;\r\n\r\n    public static fromPoints(firstPt: GraphPoint, secondPt: GraphPoint): GraphSize {\r\n        const minX = Math.min(firstPt.x, secondPt.x);\r\n        const maxX = Math.max(firstPt.x, secondPt.x);\r\n        const minY = Math.min(firstPt.y, secondPt.y);\r\n        const maxY = Math.max(firstPt.y, secondPt.y);\r\n        return new GraphSize(minX, minY, maxX - minX, maxY - minY); }\r\n\r\n    // both pt and targetPt are readonly-safe parameters\r\n    public static closestIntersection(size: GraphSize, pt: GraphPoint, targetPt: GraphPoint, gridAlign?: GraphPoint, m0?:number, q0?:number): GraphPoint | undefined {\r\n        // let pt: GraphPoint = pt0.duplicate();\r\n        const m = m0 || GraphPoint.getM(targetPt, pt);\r\n        const q = q0 || GraphPoint.getQ(targetPt, pt);\r\n        // console.log(\"closestIntersection()\", {size, pt0, targetPt, m, q});\r\n        // if perfectly vertical line\r\n        if (m === Number.POSITIVE_INFINITY/* && q === Number.NEGATIVE_INFINITY*/) {\r\n            // top center\r\n            if (Math.abs(targetPt.y - size.y) <= Math.abs(targetPt.y - size.y - size.h)) return pt;\r\n            // bottom center\r\n            else return new GraphPoint(pt.x, size.y + size.h);\r\n        }\r\n        let tl = size.tl(), tr = size.tr(),\r\n            bl = size.bl(), br = size.br();\r\n        let allowT: boolean, allowB: boolean,\r\n            allowL: boolean, allowR: boolean;\r\n        /*let distanceT: number = Number.POSITIVE_INFINITY, distanceB: number = Number.POSITIVE_INFINITY,\r\n            distanceL: number = Number.POSITIVE_INFINITY, distanceR: number = Number.POSITIVE_INFINITY;*/\r\n        let intersectionT: GraphPoint | undefined, intersectionB: GraphPoint | undefined,\r\n            intersectionL: GraphPoint | undefined, intersectionR: GraphPoint | undefined;\r\n\r\n\r\n        allowT = Geom.isNumberBetween(tl.y, bl.y, targetPt.y);\r\n        allowB = Geom.isNumberBetween(bl.y, tl.y, targetPt.y);\r\n        allowL = Geom.isNumberBetween(tl.x, tr.x, targetPt.x);\r\n        allowR = Geom.isNumberBetween(tr.x, tl.x, targetPt.x);\r\n        // console.log(\"closestIntersection pt0\", {size, targetPt, pt0:pt0.raw(), gridAlign,\r\n        //     corners:{tl:tl.raw(), tr:tr.raw(), bl:bl.raw(), br:br.raw()}, allows:{allowT, allowB, allowL, allowR}});\r\n        if (!(allowT || allowB || allowL || allowR)) return undefined; // point is internal to size\r\n        if (allowT) intersectionT = Geom.lineToSegmentIntersection(tl, tr, q, m); else\r\n        if (allowB) intersectionB = Geom.lineToSegmentIntersection(bl, br, q, m); // NOT else, (T|B) AND (L|R) can happen, or just 1 or 0 of those.\r\n        if (allowL) intersectionL = Geom.lineToSegmentIntersection(tl, bl, q, m); else\r\n        if (allowR) intersectionR = Geom.lineToSegmentIntersection(tr, br, q, m);\r\n\r\n        // console.log(\"closestIntersection pt2\", {intersectionT, intersectionB, intersectionL, intersectionR});\r\n        // only 1 intersection can happen\r\n        return intersectionT || intersectionB || intersectionL || intersectionR;\r\n    }\r\n    public static closestIntersection_old(size: GraphSize, prevPt: GraphPoint, pt0: GraphPoint, gridAlign?: GraphPoint): GraphPoint | null {\r\n        let ret = GraphSize.closestIntersection0(size, prevPt, pt0, gridAlign) as any;\r\n        // Log.exDev(!Geom.isOnEdge(ret, size), 'ClosestIntersection failed. not on Vertex edge.', {ret, size, prevPt, pt0, gridAlign});\r\n        return ret;\r\n    }\r\n    private static closestIntersection0(vertexGSize: GraphSize, prevPt: GraphPoint, pt0: GraphPoint, gridAlign?: GraphPoint): GraphPoint | null {\r\n        let pt: GraphPoint | null = pt0.duplicate();\r\n        const m = GraphPoint.getM(prevPt, pt) as number;\r\n        const q = GraphPoint.getQ(prevPt, pt) as number;\r\n        // U.pe( Math.abs((pt.y - m * pt.x) - (prevPt.y - m * prevPt.x)) > .001, 'wrong math in Q:', (pt.y - m * pt.x), ' vs ', (prevPt.y - m * prevPt.x));\r\n        /*const isL = prevPt.x < pt.x;\r\n    const isT = prevPt.y < pt.y;\r\n    const isR = !isL;\r\n    const isB = !isT; */\r\n        if (m === Number.POSITIVE_INFINITY && q === Number.NEGATIVE_INFINITY) { // bottom middle\r\n            return new GraphPoint(vertexGSize.x + vertexGSize.w / 2, vertexGSize.y + vertexGSize.h); }\r\n        // console.log('pt:', pt, 'm:', m, 'q:', q);\r\n        let L: GraphPoint | null = new GraphPoint(0, 0);\r\n        let T: GraphPoint | null = new GraphPoint(0, 0);\r\n        let R: GraphPoint | null = new GraphPoint(0, 0);\r\n        let B: GraphPoint | null = new GraphPoint(0, 0);\r\n        L.x = vertexGSize.x;\r\n        L.y = m * L.x + q;\r\n        R.x = vertexGSize.x + vertexGSize.w;\r\n        R.y = m * R.x + q;\r\n        T.y = vertexGSize.y;\r\n        T.x = (T.y - q) / m;\r\n        B.y = vertexGSize.y + vertexGSize.h;\r\n        B.x = (B.y - q) / m;\r\n        // prendo solo il compreso pt ~ prevPt (escludo così il \"pierce\" sulla faccia opposta), prendo il più vicino al centro.\r\n        // console.log('4 possibili punti di intersezione (LTBR):', L, T, B, R);\r\n        /* this.owner.mark(this.owner.toHtmlCoord(T), true, 'blue');\r\n    this.owner.mark(this.owner.toHtmlCoord(B), false, 'violet');\r\n    this.owner.mark(this.owner.toHtmlCoord(L), false, 'red');\r\n    this.owner.mark(this.owner.toHtmlCoord(R), false, 'orange');*/\r\n        console.log(\"intersect pt1:\", {T, B, L, R});\r\n        if ( (B.x >= pt.x && B.x <= prevPt.x) || (B.x >= prevPt.x && B.x <= pt.x) ) { } else { B = null; }\r\n        if ( (T.x >= pt.x && T.x <= prevPt.x) || (T.x >= prevPt.x && T.x <= pt.x) ) { } else { T = null; }\r\n        if ( (L.y >= pt.y && L.y <= prevPt.y) || (L.y >= prevPt.y && L.y <= pt.y) ) { } else { L = null; }\r\n        if ( (R.y >= pt.y && R.y <= prevPt.y) || (R.y >= prevPt.y && R.y <= pt.y) ) { } else { R = null; }\r\n        console.log(\"intersect pt2:\", {T, B, L, R});\r\n        function closestmix(pt: GraphPoint, closest: GraphPoint, segStart: GraphPoint, segEnd: GraphPoint, mode: \"TB\" | \"LR\"): void {\r\n            // changes pt\r\n            pt.x = closest.x; pt.y = closest.y; return;\r\n            let main: \"x\" | \"y\", sub: \"x\" | \"y\";\r\n            if (mode === \"TB\") { main = \"y\"; sub = \"x\"; } else { main = \"x\"; sub = \"y\"; }\r\n            pt[main] = closest[main];\r\n            // if T[sub] is inside the top segment, take T[sub], otherwise closest between size.tl[sub] and size.tr[sub]\r\n            // pt[sub] = Math.max(segStart[sub], Math.min(segStart[sub], closest[sub]));\r\n            if (closest[sub] <= segEnd[sub] && closest[sub] >= segStart[sub]) pt[sub] = closest[sub];\r\n            else if (Math.abs(closest[sub]-segEnd[sub]) < Math.abs(closest[sub]-segStart[sub])) pt[sub] = segEnd[sub];\r\n            else pt[sub] = segStart[sub];\r\n        }\r\n        function closestmix2(pt: GraphPoint, closest: GraphPoint, segStart: GraphPoint, segEnd: GraphPoint, mode: \"TB\" | \"LR\"): void {\r\n            // changes closest\r\n            let main: \"x\" | \"y\", sub: \"x\" | \"y\";\r\n            if (mode === \"TB\") { main = \"y\"; sub = \"x\"; } else { main = \"x\"; sub = \"y\"; }\r\n            // closest[main] = pt[main];\r\n            // if T[sub] is inside the top segment, take T[sub], otherwise closest between size.tl[sub] and size.tr[sub]\r\n            // pt[sub] = Math.max(segStart[sub], Math.min(segStart[sub], closest[sub]));\r\n            if (closest[sub] <= segEnd[sub] && closest[sub] >= segStart[sub]) {/*no-op*/}\r\n            else if (Math.abs(closest[sub]-segEnd[sub]) < Math.abs(closest[sub]-segStart[sub])) closest[sub] = segEnd[sub];\r\n            else closest[sub] = segStart[sub];\r\n        }\r\n        console.log(\"intersect pt2.5:\");\r\n        try{\r\n            if(T) closestmix2(pt, T, vertexGSize.tl(), vertexGSize.tr(), \"TB\");\r\n            if(B) closestmix2(pt, B, vertexGSize.bl(), vertexGSize.br(), \"TB\");\r\n            if(R) closestmix2(pt, R, vertexGSize.tr(), vertexGSize.br(), \"LR\");\r\n            if(L) closestmix2(pt, L, vertexGSize.tl(), vertexGSize.bl(), \"LR\");\r\n        } catch(e){ console.error(\"intersect error\",e)}\r\n        // console.log('superstiti step1: (LTBR):', L, T, B, R);\r\n        console.log(\"intersect pt2.9:\");\r\n        const vicinanzaT = !T ? Number.POSITIVE_INFINITY : ((T.x - pt.x) * (T.x - pt.x)) + ((T.y - pt.y) * (T.y - pt.y));\r\n        const vicinanzaB = !B ? Number.POSITIVE_INFINITY : ((B.x - pt.x) * (B.x - pt.x)) + ((B.y - pt.y) * (B.y - pt.y));\r\n        const vicinanzaL = !L ? Number.POSITIVE_INFINITY : ((L.x - pt.x) * (L.x - pt.x)) + ((L.y - pt.y) * (L.y - pt.y));\r\n        const vicinanzaR = !R ? Number.POSITIVE_INFINITY : ((R.x - pt.x) * (R.x - pt.x)) + ((R.y - pt.y) * (R.y - pt.y));\r\n        const closest = Math.min(vicinanzaT, vicinanzaB, vicinanzaL, vicinanzaR);\r\n        console.log(\"intersect pt3:\", {vicinanzaT, vicinanzaB, vicinanzaL, vicinanzaR, closest});\r\n\r\n        // console.log( 'closest:', closest);\r\n        // succede quando pt e prevPt sono entrambi all'interno del rettangolo del vertice.\r\n        // L'edge non è visibile e il valore ritornato è irrilevante.\r\n\r\n        if (closest === Number.POSITIVE_INFINITY) {\r\n            /* top center */\r\n            pt = vertexGSize.tl();\r\n            pt.x += vertexGSize.w / 2; } else\r\n        if (closest === Number.POSITIVE_INFINITY) {\r\n            /* bottom center */\r\n            pt = vertexGSize.br();\r\n            pt.x -= vertexGSize.w / 2; } else\r\n        if (closest === vicinanzaT && T) {\r\n            closestmix(pt, T as any, vertexGSize.tl(), vertexGSize.tr(), \"TB\");\r\n            /*pt.y = T.y;\r\n            // if T.x is inside the top segment, take T.x, otherwise closest between size.tl.x and size.tr.x\r\n            if ((T.x <= tr.x && T.x >= tl.x)) pt.x = T.x;\r\n            else if (Math.abs(T.x-tr.x) < Math.abs(T.x-tl.x)) pt.x = tr.x;\r\n            else pt.x = tl.x;*/\r\n        }\r\n        if (closest === vicinanzaB) { closestmix(pt, B as any, vertexGSize.bl(), vertexGSize.br(), \"TB\"); } else\r\n        if (closest === vicinanzaR) { closestmix(pt, R as any, vertexGSize.tr(), vertexGSize.br(), \"LR\"); } else\r\n        if (closest === vicinanzaL) { closestmix(pt, L as any, vertexGSize.tl(), vertexGSize.bl(), \"LR\"); }\r\n\r\n        if (!gridAlign) { return pt; }\r\n        if (!pt) return null;\r\n        if (gridAlign.x && (pt === T || pt === B || isNaN(closest))) {\r\n            const floorX: number = Math.floor(pt.x / gridAlign.x) * gridAlign.x;\r\n            const ceilX: number = Math.ceil(pt.x / gridAlign.x) * gridAlign.x;\r\n            let closestX;\r\n            let farthestX;\r\n            if (Math.abs(floorX - pt.x) < Math.abs(ceilX - pt.x)) {\r\n                closestX = floorX; farthestX = ceilX;\r\n            } else { closestX = ceilX; farthestX = floorX; }\r\n\r\n            // todo: possibile causa del bug che non allinea punti fake a punti reali. nel calcolo realPT questo non viene fatto.\r\n            // if closest grid intersection is inside the vertex.\r\n            if (closestX >= vertexGSize.x && closestX <= vertexGSize.x + vertexGSize.w) { pt.x = closestX; } else\r\n                // if 2° closer grid intersection is inside the vertex.\r\n            if (closestX >= vertexGSize.x && closestX <= vertexGSize.x + vertexGSize.w) { pt.x = farthestX;\r\n                // if no intersection are inside the vertex (ignore grid)\r\n            } else { /* do nothing */ }\r\n        } else if (gridAlign.y && (pt === L || pt === R)) {\r\n            const floorY: number = Math.floor(pt.y / gridAlign.y) * gridAlign.y;\r\n            const ceilY: number = Math.ceil(pt.y / gridAlign.y) * gridAlign.y;\r\n            let closestY;\r\n            let farthestY;\r\n            if (Math.abs(floorY - pt.y) < Math.abs(ceilY - pt.y)) {\r\n                closestY = floorY; farthestY = ceilY;\r\n            } else { closestY = ceilY; farthestY = floorY; }\r\n\r\n            // if closest grid intersection is inside the vertex.\r\n            if (closestY >= vertexGSize.y && closestY <= vertexGSize.y + vertexGSize.h) { pt.y = closestY; } else\r\n                // if 2° closer grid intersection is inside the vertex.\r\n            if (closestY >= vertexGSize.y && closestY <= vertexGSize.y + vertexGSize.h) { pt.y = farthestY;\r\n                // if no intersection are inside the vertex (ignore grid)\r\n            } else { /* do nothing */ }\r\n        }\r\n        return pt; }\r\n\r\n\r\n    protected new(...args: any): this { return new GraphSize(...args) as this; }\r\n    protected makePoint(x: number, y: number): GraphPoint { return new GraphPoint(x, y) as GraphPoint; }\r\n\r\n    closestPoint(pt: GraphPoint): GraphPoint { return Geom.closestPoint(this, pt); }\r\n}\r\n\r\nRuntimeAccessibleClass.set_extend(RuntimeAccessibleClass, ISize);\r\nRuntimeAccessibleClass.set_extend(ISize, Size);\r\nRuntimeAccessibleClass.set_extend(ISize, GraphSize);\r\n\r\n\r\n\r\nexport type PositionStrTypes =\r\n    \"top\" | \"bottom\" | \"left\" | \"right\" | \"\" | // '' = x&y center, undefined = top\r\n    \"top right\" | \"top left\" | \"bottom left\" | \"bottom right\" |\r\n    \"right top\" | \"left top\" | \"left bottom\" | \"right bottom\" |\r\n    \"t\" | \"b\" | \"l\" | \"r\" |\r\n    \"tl\" | \"tr\" | \"bl\" | \"br\" |\r\n    \"lt\" | \"rt\" | \"lb\" | \"rb\";\r\n\r\n@RuntimeAccessible('PositionStr')\r\nexport class PositionStr{\r\n    public static cname = 'PositionStr';\r\n\r\n    x: -1 | 0 | 1; // left, centered, right\r\n    y: -1 | 0 | 1;\r\n    constructor(x?: PositionStr['x'], y? :PositionStr['y']){\r\n        this.x = x ?? 0;\r\n        this.y = y ?? -1;\r\n    }\r\n    toString(): PositionStrTypes{\r\n        return PositionStr.toPosString(this);\r\n    }\r\n    invert(x = true, y = true): this {\r\n        if (x) this.x = -this.x as 1|0|-1;\r\n        if (y) this.y = -this.y as 1|0|-1;\r\n        return this;\r\n    }\r\n    public static toPosString(o: PositionStr): PositionStrTypes{\r\n        let s: string;\r\n        if (o.y === -1) s = 't';\r\n        else if (o.y === 1) s = 'b';\r\n        else s = '';\r\n\r\n        if (o.x === -1) s += 'l';\r\n        else if (o.x === 1) s += 'r';\r\n        // else s = +'';\r\n        // if (!s) return \"c\";\r\n        return s as PositionStrTypes;\r\n    }\r\n    public static fromPosString(position?: PositionStrTypes): PositionStr{\r\n        let ret = new PositionStr(0, 0);\r\n        let posarr = (position ?? 't').split(' '); // .map(s=>s[0]);\r\n        for (let p of posarr)\r\n            switch (p) {\r\n                default:\r\n                case \"t\": case \"top\":                       ret.y = -1; break;\r\n                case \"b\": case \"bottom\":                    ret.y =  1; break;\r\n                case \"l\": case \"left\":                      ret.x = -1; break;\r\n                case \"r\": case \"right\":                     ret.x =  1; break;\r\n                case \"tl\": case \"lt\": case \"top left\":      ret.y = -1; ret.x = -1; break;\r\n                case \"tr\": case \"rt\": case \"top right\":     ret.y = -1; ret.x =  1; break;\r\n                case '': case 'c':                          ret.x =  0; ret.y =  0; break;\r\n                case \"bl\": case \"lb\": case \"bottom left\":   ret.y =  1; ret.x = -1; break;\r\n                case \"br\": case \"rb\": case \"bottom right\":  ret.y =  1; ret.x =  1; break;\r\n            }\r\n        return ret;\r\n    }\r\n    public static invertPosStr(pos?: PositionStrTypes): PositionStrTypes{\r\n        return PositionStr.fromPosString(pos).invert().toString() as any;\r\n    }\r\n\r\n    private static toFullLabelSingle(position: string | \"\" | \"c\" | \"t\" | \"b\" | \"l\" | \"r\"): \"top\" | \"bottom\" | \"left\" | \"right\" | \"center\" {\r\n        switch (position?.trim()[0]){\r\n            case 'c': case '': return 'center';\r\n            case 't': return 'top';\r\n            default: if (position.trim() === '') return 'center'; return 'bottom';\r\n            case 'b': return 'bottom';\r\n            case 'l': return 'left';\r\n            case 'r': return 'right';\r\n        }\r\n    }\r\n    // tl -> top left\r\n    static toSeparateFullLabels(position?: PositionStrTypes): string {\r\n        let pos = (position ?? 'b').trim();\r\n\r\n        if (pos.length === 2) {\r\n            return PositionStr.toFullLabelSingle(pos[0]) + ' ' + PositionStr.toFullLabelSingle(pos[1]);\r\n        } else if (pos.indexOf(' ')) { return pos.split(' ').map(s => PositionStr.toFullLabelSingle(s as any)).join(' '); }\r\n        else return PositionStr.toFullLabelSingle(pos[0]);\r\n        return \"\";\r\n    }\r\n}\r\n\r\n@RuntimeAccessible('Geom')\r\nexport class Geom extends RuntimeAccessibleClass {\r\n\r\n    static markings: Dictionary<string, HTMLElement> = {};\r\n    static unmark(key: string): boolean{\r\n        if (!Geom.markings[key]) return false;\r\n        let e = Geom.markings[key];\r\n        U.removeFromDom(e);\r\n        delete Geom.markings[key];\r\n        return true;\r\n    }\r\n    static markPt(key: string, pt: Point, color?: string, label?: string): HTMLElement{ return Geom.mark(key, pt.x, pt.y, 1, 1, color, label); }\r\n    static markSize(key: string, pt: Size, color?: string, label?: string): HTMLElement{ return Geom.mark(key, pt.x, pt.y, pt.w??1, pt.h??1, color, label); }\r\n    static mark(key: string, x: number, y: number, w: number=1, h: number=1, color: string='red', label: string=''): HTMLElement{\r\n        if (Geom.markings[key]) Geom.unmark(key);\r\n        let e: HTMLElement;\r\n        let pre = '<div class=\"debug-mark\" data-key=\"'+key+'\" data-label=\"'+label+'\" style=\"position: absolute; z-index:99999; left:'+x+'px; top:'+y+'px; width: '+w+'px; height: '+h+'px;';\r\n        let post = '\"/>';\r\n        if (w + h > 2) {\r\n            e = U.toHtml(pre+'border-radius:0; background: transparent;'+post) as HTMLElement;\r\n        }\r\n        else {\r\n            e = U.toHtml(pre+'border-radius:100%; background: '+color+'; outline: 1px solid '+color+'; outline-offset: 5px;'+post) as HTMLElement;\r\n        }\r\n        document.body.append(e);\r\n        Geom.markings[key] = e;\r\n        return e;\r\n    }\r\n    // warning: nodes from other iframes will say are not instance from Element of the current frame, in that case need duck typing.\r\n    public static isHtmlNode(element: any): element is Element {\r\n        return element instanceof Element || element instanceof HTMLDocument || element instanceof SVGElement;\r\n    }\r\n\r\n\r\n    static isPositiveZero(m: number): boolean {\r\n        if (!!Object.is) { return Object.is(m, +0); }\r\n        return (1 / m === Number.POSITIVE_INFINITY); }\r\n\r\n    static isNegativeZero(m: number): boolean {\r\n        if (!!Object.is) { return Object.is(m, -0); }\r\n        return (1 / m === Number.NEGATIVE_INFINITY); }\r\n\r\n    static TanToRadian(n: number): number { return Geom.DegreeToRad(Geom.TanToDegree(n)); }\r\n    static TanToDegree(n: number): number {\r\n        if (Geom.isPositiveZero(n)) { return 0; }\r\n        if (n === Number.POSITIVE_INFINITY) { return 90; }\r\n        if (Geom.isNegativeZero(n)) { return 180; }\r\n        if (n === Number.POSITIVE_INFINITY) { return 270; }\r\n        return Geom.RadToDegree((window as any).Math.atan(n)); }\r\n\r\n    static RadToDegree(radians: number): number { return Geom.radToDeg(radians); }\r\n    static DegreeToRad(degree: number): number { return Geom.degToRad(degree); }\r\n    static radToDeg(radians: number): number { return radians * (180 / Math.PI); }\r\n    static degToRad(degree: number): number { return degree * (Math.PI / 180); }\r\n\r\n\r\n\r\n    private static GeomTolerance = 0; // 0.001;\r\n    static isOnEdge(pt: GraphPoint, shape: GraphSize, tolerance: number = Geom.GeomTolerance): boolean {\r\n        return Geom.isOnHorizontalEdges(pt, shape, tolerance) || Geom.isOnVerticalEdges(pt, shape, tolerance); }\r\n\r\n    static isOnVerticalEdges(pt: GraphPoint, shape: GraphSize, tolerance: number = Geom.GeomTolerance): boolean {\r\n        return Geom.isOnLeftEdge(pt, shape, tolerance) || Geom.isOnRightEdge(pt, shape, tolerance); }\r\n\r\n    static isOnHorizontalEdges(pt: GraphPoint, shape: GraphSize, tolerance: number = Geom.GeomTolerance): boolean {\r\n        return Geom.isOnTopEdge(pt, shape, tolerance) || Geom.isOnBottomEdge(pt, shape, tolerance); }\r\n\r\n    static isOnRightEdge(pt: GraphPoint, shape: GraphSize, tolerance: number = Geom.GeomTolerance): boolean {\r\n        if (!pt || !shape) { return false; }\r\n        if (tolerance) return Math.abs(pt.x - (shape.x + shape.w)) < tolerance\r\n            && ( pt.y - shape.y > tolerance && pt.y - (shape.y + shape.h) < tolerance);\r\n        return (pt.x === shape.x + shape.w) && (pt.y >= shape.y && pt.y <= shape.y + shape.h);\r\n    }\r\n\r\n    static isOnLeftEdge(pt: GraphPoint, shape: GraphSize, tolerance: number = Geom.GeomTolerance): boolean {\r\n        if (!pt || !shape) { return false; }\r\n        if (tolerance) return Math.abs(pt.x - shape.x) < tolerance\r\n            && (pt.y - shape.y > tolerance && pt.y - (shape.y + shape.h) < tolerance);\r\n        return (pt.x === shape.x) && (pt.y >= shape.y && pt.y <= shape.y + shape.h);\r\n    }\r\n\r\n    static isOnTopEdge(pt: GraphPoint, shape: GraphSize, tolerance: number = Geom.GeomTolerance): boolean {\r\n        if (!pt || !shape) { return false; }\r\n        if (tolerance) return Math.abs(pt.y - shape.y) < tolerance\r\n            && (pt.x - shape.x > tolerance && pt.x - (shape.x + shape.w) < tolerance);\r\n        return (pt.y === shape.y) && (pt.x >= shape.x && pt.x <= shape.x + shape.w);\r\n    }\r\n\r\n    static isOnBottomEdge(pt: GraphPoint, shape: GraphSize, tolerance?: number): boolean {\r\n        if (!pt || !shape) { return false; }\r\n        if (tolerance) return Math.abs(pt.y - shape.y + shape.h) < tolerance\r\n            && (pt.x - shape.x > tolerance && pt.x - (shape.x + shape.w) < tolerance);\r\n        return (pt.y === shape.y + shape.h) && (pt.x >= shape.x && pt.x <= shape.x + shape.w);\r\n    }\r\n\r\n    static closestPoint(size: GraphSize, pt: GraphPoint): GraphPoint {\r\n        let top_closest = Geom.closestPointToSegment(size.tl(), size.tr(), pt);\r\n        let bot_closest = Geom.closestPointToSegment(size.bl(), size.br(), pt);\r\n        let left_closest = Geom.closestPointToSegment(size.tl(), size.bl(), pt);\r\n        let right_closest = Geom.closestPointToSegment(size.tr(), size.br(), pt);\r\n\r\n        let top_distance = top_closest.distanceFromPoint(pt, false);\r\n        let bot_distance = bot_closest.distanceFromPoint(pt, false);\r\n        let left_distance = left_closest.distanceFromPoint(pt, false);\r\n        let right_distance = right_closest.distanceFromPoint(pt, false);\r\n\r\n        let min_distance = Math.min(top_distance, bot_distance, left_distance, right_distance);\r\n        if (min_distance === top_distance) return top_closest;\r\n        if (min_distance === bot_distance) return bot_closest;\r\n        if (min_distance === left_distance) return left_closest;\r\n        return right_closest;\r\n    }\r\n    static isMinusZero(number: number) {return 1/number == -Infinity;}\r\n    static closestPointToSegment(segStart: GraphPoint, segEnd:GraphPoint, pt: GraphPoint): GraphPoint{\r\n        // 1) find equation of line passing for start, end.\r\n        // 2) then find all perpendicular lines, then the perpendicular line that pass through pt\r\n        // 3) find intersection between Line(s,e) and line of point 2.\r\n        // 4A) IF intersection is part of segment(s,e) that is closest.\r\n        // 4B) ELSE, one of the 2 extremes of the segment is closest.\r\n\r\n        let x_intersect: number, y_intersect: number;\r\n        let s = segStart;\r\n        let e = segEnd;\r\n        let mse = (e.y - s.y) / (e.x - s.x);\r\n        if (mse === Number.POSITIVE_INFINITY || mse === Number.NEGATIVE_INFINITY) {\r\n            // s and e are both on the same y vertical line (same x)      // new GraphPoint(segStart.x, pt.y);\r\n            x_intersect = segStart.x;\r\n            y_intersect = pt.y;\r\n            // 1), 2), 3) all done shortcut\r\n        } else if (mse === 0 || Geom.isNegativeZero(mse)) {\r\n            // s and e are both on the same x horizontal line (same y)    // new GraphPoint(pt.x, segStart.y);\r\n            x_intersect = pt.x;\r\n            y_intersect = segStart.y\r\n            // 1), 2), 3) all done shortcut\r\n        }\r\n        else {\r\n            let q = s.y - mse*s.x; // y = mx + q           q = y-mx\r\n            // 1) done\r\n            let pmse = -1/mse; // perpendicular to mse\r\n            let pq = pt.y - pmse*pt.x;\r\n            // 2) done\r\n            //  m1 * x + q1 = y    -->   m1 * x + q1 = m2 * x + q2    -->    (m1-m2)x = q2-q1      -->     x=(q2-q1)/(m1-m2)\r\n            x_intersect = (pq-q)/(mse-pmse);\r\n            y_intersect = mse*(x_intersect) + q; //  y = mx +q\r\n            // 3) done\r\n        }\r\n\r\n        let maxX: number, minX: number;\r\n        let maxY: number, minY: number;\r\n        if (s.x > e.x) { maxX = s.x; minX = e.x; } else {  maxX = e.x; minX = s.x; }\r\n        if (s.y > e.y) { maxY = s.y; minY = e.y; } else {  maxY = e.y; minY = s.y; }\r\n        if (x_intersect >= minX && x_intersect <= maxX && y_intersect >= minY && y_intersect <= maxY) return new GraphPoint(x_intersect, y_intersect);\r\n        // 4A) IF done\r\n\r\n        let sdist = (s.x - x_intersect)**2 + (s.y - y_intersect)**2;  // actual distance is sqrt() of this, but i just need to find closest, not correct distance.\r\n        let edist = (e.x - x_intersect)**2 + (e.y - y_intersect)**2;\r\n        return (sdist < edist) ? new GraphPoint(s.x, s.y) : new GraphPoint(e.x, e.y);\r\n        // 4B) ELSE done\r\n    }\r\n\r\n    static lineToSegmentIntersection(segStart: GraphPoint, segEnd: GraphPoint, q: number, m: number): GraphPoint | undefined {\r\n        if (segStart.x === segEnd.x){\r\n            let y = m*segStart.x + q;\r\n            if (Geom.isNumberBetween(y, segStart.y, segEnd.y)) return new GraphPoint(segStart.x, y);\r\n            else return undefined;\r\n        }\r\n        else if (segStart.y === segEnd.y) {\r\n            let x = (segStart.y-q)/m;\r\n            if (Geom.isNumberBetween(x, segStart.x, segEnd.x)) return new GraphPoint(x, segStart.y);\r\n            else return undefined;\r\n            //\r\n        }\r\n\r\n        let m2 = segStart.getM(segEnd);\r\n        let q2 = IPoint.getQ(segStart, segEnd);\r\n        if (m === m2) {\r\n            if (q2 === q) return segStart; // line and segment coincident\r\n            return undefined; // parallel\r\n        }\r\n        let intersect = Geom.lineToLineIntersection(m, q, m2, q2);\r\n        if (intersect && Geom.isNumberBetween(intersect.x, segStart.x, segEnd.x) && Geom.isNumberBetween(intersect.y, segStart.y, segEnd.y)) return intersect;\r\n        else return undefined;\r\n    }\r\n\r\n    static isNumberBetween(target: number, s: number, e: number): boolean {\r\n        let max = Math.max(s, e);\r\n        let min = Math.min(s, e);\r\n        return target >= min && target <= max; }\r\n\r\n    private static lineToLineIntersection(m: number, q: number, m2: number, q2: number, retIfParallel: any = undefined, retIfCoincident: any = undefined): undefined | GraphPoint {\r\n        if (m === m2) {\r\n            if (q === q2) return retIfCoincident;\r\n            return retIfParallel;\r\n        }\r\n        if (m === Number.POSITIVE_INFINITY || m === Number.NEGATIVE_INFINITY || m2 === Number.POSITIVE_INFINITY || m2 === Number.NEGATIVE_INFINITY) {\r\n            // m or m2 are a vertical line, Q must be invalid too and i don't have a single point of the line.\r\n            // it's actually infinite possible vertical parallel lines.\r\n            return undefined;\r\n        }\r\n        /*\r\n            y = mx + q\r\n            y = nx + w\r\n            -->\r\n            mx + q = nx + w\r\n            -->\r\n            mx - nx = w - q\r\n            -->\r\n            x (m - n) = w - q\r\n            -->\r\n            x = (w - q)/(m - n)\r\n        */\r\n        let x = (q2-q)/(m-m2);\r\n        return new GraphPoint(x, m*x+q); }\r\n    // @param start, end: are for determining direction. every m is a line that can be seen in 2 direction\r\n    static mToRad(m: number, start: GraphPoint, end: GraphPoint): number {\r\n        let rad: number;\r\n        if (start.x === end.x) {\r\n            rad = (start.y < end.y) ? Math.PI * 3/2 :  Math.PI / 2;\r\n        } else {\r\n            // console.log(\"rad diagonal\", {base:  Math.atan(m), add: start.x > end.x, sx: start.x, ex: end.x});\r\n            rad = Math.atan(m) + (start.x > end.x ? 0 : Math.PI);\r\n        }\r\n        return rad; }\r\n\r\n    // intersect a rectangle with a line or segment (if end parameter is specified)\r\n    // @return: [0, 2] intersections\r\n    static lineToSizeIntersection_TODO(size: GraphSize, m: number, startLine: GraphPoint, endIfSegment?: GraphPoint): [] | [GraphPoint] | [GraphPoint, GraphPoint] {\r\n         // todo: use GraphSize.closestIntersection which is close. it is size-segment returning only the closest intersection\r\n        return [];\r\n    }\r\n}\r\n\r\nRuntimeAccessibleClass.set_extend(RuntimeAccessibleClass, Geom);\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}