{"ast":null,"code":"import{DViewElement,UX,GraphElementComponent,ViewEClassMatch}from'../../joiner';import{Action,CompositeAction,CreateElementAction,DeleteElementAction,DPointerTargetable,DState,DUser,getPath,Log,MyError,PendingPointedByPaths,PointedBy,Pointers,RuntimeAccessibleClass,SetFieldAction,SetRootFieldAction,statehistory}from\"../../joiner\";import React from\"react\";import{LoadAction,RedoAction,UndoAction}from\"../action/action\";import Collaborative from\"../../components/collaborative/Collaborative\";import{SimpleTree}from\"../../common/SimpleTree\";import{transientProperties,Selectors}from\"../../joiner\";import{contextFixedKeys}from'../../graph/graphElement/sharedTypes/sharedTypes';import Storage from\"../../data/storage\";import{ProjectsApi}from\"../../api/persistance\";import DSL from\"../../DSL/DSL\";let windoww=window;let U=windoww.U;function deepCopyButOnlyFollowingPath(oldStateDoNotModify,action,prevAction,newVal){var _action$path;let newRoot={...oldStateDoNotModify};let current=newRoot;if(!((_action$path=action.path)===null||_action$path===void 0?void 0:_action$path.length))throw new MyError(\"path length must be at least 1\",{action});let gotChanged=false;// dovrebbe cambiare sempre, se non cambia non lancio neanche l'azione e non faccio la shallow copy, ma non si sa mai, così posso evitare un render se succede l' \"insuccedibile\"\nlet alreadyPastDivergencePoint=false;// true dal momento in cui il path dell'azione attuale e della azione precedente divergono, false fino al sotto-segmento in cui combaciano\n// console.log('deepCopyButOnlyFollowingPath', arguments);\nfor(let i=0;i<action.pathArray.length;i++){let key=action.pathArray[i].trim();let prevActionPathKey=prevAction===null||prevAction===void 0?void 0:prevAction.pathArray[i];// middle execution: not on final loop\n// console.log('deepCopyButOnlyFollowingPath', {current, i, imax:action.pathArray.length, key, gotChanged, alreadyPastDivergencePoint});\nif(i!==action.pathArray.length-1){if(alreadyPastDivergencePoint||key!==prevActionPathKey){// se l'oggetto è stato già duplicato in una azione composita, non lo duplico 2 volte.\nalreadyPastDivergencePoint=true;current[key]=Array.isArray(current[key])?[...current[key]]:{...current[key]};current[key].clonedCounter=1+(current[key].clonedCounter||0);}current=current[key];continue;}// Giordano: added this on 03/12/2023 to prevent \"Cannot read properties of undefined\".\n// if(!current) continue; damiano: temp removed to check if there are invalid actions firing\n// perform final assignment\nif(i>=action.pathArray.length-1){let isArrayAppend=false;let isArrayRemove=false;let isObjectMerge=false;let isObjectDifference=false;// console.log('isarrayappend?', {endswith: U.endsWith(key, ['+=', '[]', '-1']), key, action, i});\n// console.log('isarraydelete?', {endswith: U.endsWith(key, ['-='])});\nlet oldValue;if(U.endsWith(key,['+=','[]'])){key=key.substr(0,key.length-2).trim();oldValue=current[key];switch(typeof oldValue){case'object':if(Array.isArray(oldValue))isArrayAppend=true;else isObjectMerge=true;break;default:newVal+=oldValue;break;}}if(U.endsWith(key,['-='])){key=key.substr(0,key.length-2).trim();oldValue=current[key];switch(typeof oldValue){case'object':if(Array.isArray(oldValue))isArrayRemove=true;else isObjectDifference=true;break;case\"string\":newVal=U.replaceAll(oldValue,newVal,'');break;case'number':newVal=oldValue-newVal;break;default:isArrayRemove=true;break;}// isArrayRemove = true;\n}// let unpointedElement: DPointerTargetable | undefined;\n// perform final assignment\nif(action.type===CreateElementAction.type&&current[key]){oldValue=current[key];gotChanged=false;Log.ee(\"rejected CreateElementAction, rollback occurring:\",{action,preexistingValue:current[key],isShallowEqual:current[key]===action.value});return false;// warning: use return only when you want to abort and skip subsequent CompositeAction sub-actions like now.\n}if(isObjectMerge){if(typeof newVal==='string'){let tmp={};tmp[newVal]=true;newVal=tmp;}oldValue={...current[key]};current[key]={...current[key]};for(let subkey in newVal){// console.warn(\"object merge\", {current, key, subkey, newVal, old:current[key][subkey], new:newVal[subkey]});\nif(current[key][subkey]===newVal[subkey])continue;current[key][subkey]=newVal[subkey];gotChanged=true;if(action.isPointer){newRoot=PointedBy.add(key,action,newRoot,\"+=\");}}}else if(isObjectDifference){if(typeof newVal==='string'){let tmp={};tmp[newVal]=true;newVal=tmp;}oldValue={...current[key]};current[key]={...current[key]};for(let subkey in newVal){if(!(subkey in current[key]))continue;delete current[key][subkey];gotChanged=true;if(action.isPointer){newRoot=PointedBy.add(key,action,newRoot,\"-=\");}}}else if(isArrayAppend){gotChanged=true;if(!Array.isArray(current[key])){current[key]=[];}oldValue=[...current[key]];current[key]=[...current[key]];current[key].push(newVal);// unpointedElement = undefined;\nif(action.isPointer){newRoot=PointedBy.add(newVal,action,newRoot,\"+=\");}}else if(isArrayRemove){if(!Array.isArray(current[key])){current[key]=[];}oldValue=[...current[key]];let index;if(U.isNumber(newVal)){// delete by index\nindex=newVal;if(index<0)index=oldValue.length+index;// if index is -2, i remove the penultimate element\n}else if(newVal===undefined){index=oldValue.length-1;}else{index=oldValue.indexOf(newVal);}// if it's negatively or positively out of boundary, i skip it\ngotChanged=index>=0&&index<current[key].length;if(gotChanged){current[key]=[...current[key]];let removedval=current[key].splice(index,1);// in-place edit\nif(action.isPointer){newRoot=PointedBy.remove(removedval,action,newRoot,'-=');}/*\r\n                    fixed problem: se ho [dobj1, dobj2]... e li swappo, cambia un indice nel percorso \"pointedby\" e non me ne accorgo mai e un oggetto risulta \"pointedby\" da oggetti che non lo puntano o non esistono più a quell'indice\r\n                    SOLVED! by not including index in pointedBy path, but making it like \"parentObject.arrayKey+=\" instead of \"parentObject.arrayKey.4\"\r\n                    and knowing it's in the array it's enough info.\r\n\r\n                    // a.pointsto = [x, y, z]; a.pointsto = [x, z]       --->    remove a from y.pointedby\r\n                    const elementsThatChangedIndex: DPointerTargetable[] = current[key].slice(index);\r\n\r\n                    for (let j = 0; j < elementsThatChangedIndex.length; j++) {\r\n                        let newindex = index + j - 1;\r\n                        let oldFullpathTrimmed = action.pathArray.join('.');\r\n                        se realizzi \"pointedby\" qui è to do: remove old paths and re-add them with updated index\r\n                    }\r\n                    unpointedElement = newRoot.idlookup[oldValue];\r\n                    */}}else if(action.type===DeleteElementAction.type&&!(key in current)||current[key]===newVal){// value not changed\ngotChanged=false;}else{// value changed\n// todo: caso in cui setto manualmente classes.1 = pointer;\n//  the latest element is array and not DPointerTargetable, so might need to buffer upper level in the tree? or instead of \"current\" keep an array of sub-objects encountered navigating the path in state.\noldValue=current[key];gotChanged=true;// unpointedElement = newRoot.idlookup[oldValue];\n// NB: se elimino un oggetto che contiene array di puntatori, o resetto l'array di puntatori kinda like store.arr= [ptr1, ptr2, ...]; store.arr = [];\n// i puntati dall'array hanno i loro pointedBY non aggiornati, non voglio fare un deep check di tutto l'oggetto a cercare puntatori per efficienza.\n// if (newVal === undefined) delete current[key];\nif(newVal===undefined||false&&action.type===DeleteElementAction.type)delete current[key];else current[key]=newVal;// update pointedBy's\n// NB: even if the current action have isPointer=true, it doesn't mean the old value is a pointer as well for sure. so need to check old values.\n// also what if old val is pointer, and new one isn't? will it be just removed without updating pointedBy's?\n// already fixed: might need to evaluate this if block always regardless of action.isPointer,\n// and do checks every time both on old and new value if they actually are ptrs.\nif(true||action.isPointer){let oldpointerdestinations;let newpointerdestinations;if(Array.isArray(newVal)){newpointerdestinations=newVal;if(Array.isArray(oldValue)){// case: path.array = array;\noldpointerdestinations=oldValue;}else{// case: path.object = array; + case: path.value = array;\noldpointerdestinations=[oldValue];}}else{// case: path.array = object; + case: path.array = value;\nnewpointerdestinations=[newVal];if(Array.isArray(oldValue)){oldpointerdestinations=oldValue;}else{// case: path.object = object; and all other cases without arrays involved\noldpointerdestinations=[oldValue];}}// after i mapped all cases to path.array = array; i solve it for that case.\nlet difference=U.arrayDifference(oldpointerdestinations,newpointerdestinations);// : {added: Pointer[], removed: Pointer[], starting: Pointer[], final: Pointer[]}\nfor(let rem of difference.removed){if(Pointers.isPointer(rem))newRoot=PointedBy.remove(rem,action,newRoot,undefined,oldStateDoNotModify);}for(let add of difference.added){if(Pointers.isPointer(add))newRoot=PointedBy.add(add,action,newRoot,undefined,oldStateDoNotModify);}// a.pointsto = [a, b, c];  a.pointsto = [a, b, x];    ------>     c.pointedby.remove(a) & x.pointedby.add(a)\n// idlookup.somelongid.pointsto = [...b];\n}}break;}Log.exDevv('should not reach here: reducer');}return gotChanged?newRoot:oldStateDoNotModify;}// const pendingPointedByPaths: {from: DocString<\"Path in store\">, field: DocString<\"keyof object found in from path\">, to: Pointer}[] = [];\nfunction CompositeActionReducer(oldState,actionBatch){// per via di thunk se arrivo qui lo stato cambia sicuro in mono-client non synchro (non ri-assegno valori equivalenti)\n// todo: ma se arrivano in ordine sbagliato da altri client? posso permetterlo?\nlet actions;if(actionBatch.actions)actions=Action.parse(actionBatch.actions);else actions=[Action.parse(actionBatch)];// else-case is if it's a single action and not an actual compositeaction\nif(PendingPointedByPaths.all.length)actions.push(...PendingPointedByPaths.getSolveableActions(oldState));//.all.map( p=> p.resolve() ) );\nAction.possibleInconsistencies={};// estraggo le azioni derivate\nlet derivedActions=[];let newState=oldState;for(let action of actions){switch(action.type){default:break;case CreateElementAction.type:const elem=action.value;delete DPointerTargetable.pendingCreation[elem.id];/*\r\n                if (oldState.idlookup[elem.id]) {\r\n                    Log.ee(\"rejected CreateElementAction, rollback occurring:\", {action, elem:{...elem},\r\n                        preexistingValue: {...oldState.idlookup[elem.id]}, isEqual: elem === oldState.idlookup[elem.id] });\r\n                    return oldState; // warning: use return only when you want to abort and skip subsequent CompositeAction sub-actions like now.\r\n\r\n                    action.value = \"An element with that id already existed.\";\r\n                    action.path = action.field = \"CreateActionRejected\";\r\n                    action.className = SetRootFieldAction.name;\r\n                    action.type = SetRootFieldAction.type;\r\n                    action.pathArray = [action.path]; //a\r\n                    action.isPointer = false;\r\n                    // just to log it in undo-redo action list and have a feedback\r\n                    return oldState;}*/elem.className=elem.className||elem.constructor.cname||elem.constructor.name;let statefoldername=elem.className.substring(1).toLowerCase()+'s';derivedActions.push(Action.parse(SetRootFieldAction.create(statefoldername,elem.id,'[]',true)));if(!Array.isArray(elem.pointedBy))elem.pointedBy=[];elem.pointedBy.push(PointedBy.new(statefoldername));/*if (false && action.isPointer) {\r\n                    if (Array.isArray(action.value)) {\r\n                        const ptr: Pointer[] = action.value;\r\n                        // todo but replaced by side actions in execution of the main action instead of triggering derived actions\r\n                    }\r\n                    else {\r\n                        const ptr: Pointer = action.value;\r\n                        const target: DPointerTargetable | null = oldState.idlookup[ptr];\r\n                        let pendingPointedBy = PendingPointedByPaths.new(action, oldState);\r\n                        if (!target) PendingPointedByPaths.new(action, oldState).saveForLater(); // {from: action.path, field: action.field, to: target});\r\n                        // @ts-ignore\r\n                        else derivedActions.push(pendingPointedBy.resolve());\r\n                        // a -> x\r\n                        // a -> y     unset x.pointedby(a)\r\n                    }\r\n                }*/break;}}// console.error({U, Umip:U.arrayMergeInPlace, WU: windoww.U, WUmip: windoww.U.arrayMergeInPlace});\nactions=U.arrayMergeInPlace(actions,derivedActions);// ordino i path con segmenti comuni\nactions=actions.sort((a1,a2)=>U.stringCompare(a1.path,a2.path));// destrutturo solo i nodi intermedi e solo la prima volta che li incontro (richiede le azioni ordinate in base al path)\nfor(let i=0;i<actions.length;i++){const prevAction=actions[i-1];const action=actions[i];const actiontype=action.type.indexOf('@@')===0?'redux':action.type;console.log('executing action:',{a:action,t:actiontype,field:action.field,v:action.value});//, count: ++action.executionCount});\nswitch(actiontype){/*\r\n            case '@@redux/INIT6.x.f.d.r.e':\r\n            case '@@redux/INITm.f.1.s.o.g':\r\n            case '@@redux/INIT5.t.4.v.d.o':\r\n            case '@@redux/INITy.a.d.r.l.a':\r\n            case '@@redux/INIT4.2.q.u.z.k':\r\n            case '@@redux/INITj.8.e.g.y.p':\r\n            case '@@redux/INITp.k.q.g.z.w':\r\n            case '@@redux/INITq.c.u.w.f.e': ... etc*/default:if(action.type.indexOf('@@redux/')===0)break;return Log.exDevv('unexpected action type:',action.type);case LoadAction.type:newState=action.value;break;case CreateElementAction.type:case SetRootFieldAction.type:case DeleteElementAction.type:case SetFieldAction.type:let tmp=deepCopyButOnlyFollowingPath(newState,action,prevAction,action.value);if(!tmp)return oldState;// rollback due to invalid action in transaction\nnewState=tmp;break;}// and that's all, the reducer is really simple as actions are really simple.\n}// effetti collaterali, aggiornamento di ridondanze\nnewState=updateRedundancies_OBSOLETE(newState,oldState,Action.possibleInconsistencies);return newState;}function updateRedundancies_OBSOLETE(state,oldState,possibleInconsistencies){for(let subType in possibleInconsistencies)switch(subType){default:break;case Action.SubType.vertexSubElements:/*\r\n            risolto triggrerando più azioni da LGraphElement setter\r\n            let dvertexid: Pointer, newdvertex: DGraphElement, olddvertex: DGraphElement;\r\n            for (newdvertex of possibleInconsistencies[subType] as DGraphElement[]){\r\n                const olddvertex: DGraphElement = oldState.idlookup[newdvertex.id] as DGraphElement;\r\n                const notContainedAnymoreOut: Pointer<DGraphElement> = [];\r\n                const newlyInsertedOut: Pointer<DGraphElement>[] = [];\r\n                U.arraySymmetricDifference(olddvertex.subElements, newdvertex.subElements, notContainedAnymoreOut, newlyInsertedOut);\r\n                for (let geid of notContainedAnymoreOut) {\r\n                    const oldge = oldState.idlookup[geid] as DGraphElement;\r\n                    const newge = state.idlookup[geid] as DGraphElement;\r\n                    if (oldge.containedIn === newge.containedIn) continue;\r\n                }\r\n                for (let geid of notContainedAnymoreOut) {\r\n                    const ge = idlookup[geid] as DGraphElement;\r\n                    if (ge.containedIn === context.data.id) set container = context.data.id\r\n                    meglio se sti 2 cicli li fai nel reducer perchè  potrebbe esserci una azione pending che setta il parent = someotherid e qui faccio partire una azione che setta il parent a null, \"annullando\" una azione pending non ancora eseguita\r\n                }\r\n            }\r\n            break;*/}// if state is updated shallow copy state before returning it\nreturn state;}let initialState=null;let storeLoaded=false;const UDRegexp=/(?:^|\\s|;|}|\\n|\\t|\\(|,)ret\\s*\\.\\s*[a-zA-Z_$][0-9a-zA-Z_$]*\\s*=/g;/* tested with:\r\nif (ret.key = stuff) ret.key2=morestuff;\r\n;ret.k=3;\r\n}ret. kk=3,ret. a = 3\r\n\r\nret .b = 3\r\n*/ // then add to it: content of props, constants, usageDeclarations\nexport function reducer(){let oldState=arguments.length>0&&arguments[0]!==undefined?arguments[0]:initialState;let action=arguments.length>1?arguments[1]:undefined;try{return unsafereducer(oldState,action);}catch(e){console.error('unhandled error in reducer',{e,oldState,action});return oldState;}}function unsafereducer(){var _ret$VIEWS_RECOMPILE_,_ret$VIEWS_RECOMPILE_2,_ret$VIEWS_RECOMPILE_3,_ret$VIEWS_RECOMPILE_4,_ret$VIEWS_RECOMPILE_5;let oldState=arguments.length>0&&arguments[0]!==undefined?arguments[0]:initialState;let action=arguments.length>1?arguments[1]:undefined;const ret=_reducer(oldState,action);if(ret===oldState)return oldState;ret.idlookup.__proto__=DPointerTargetable.pendingCreation;// client synchronization stuff\nif(oldState===null||oldState===void 0?void 0:oldState.collaborativeSession){const ignoredFields=['version','env','debug','isEdgePending','contextMenu','_lastSelected','isLoading','collaborativeSession','VIEWS_RECOMPILE_onDataUpdate','VIEWS_RECOMPILE_onDragStart','VIEWS_RECOMPILE_onDragEnd','VIEWS_RECOMPILE_whileDragging','VIEWS_RECOMPILE_onResizeStart','VIEWS_RECOMPILE_onResizeEnd','VIEWS_RECOMPILE_whileResizing','VIEWS_RECOMPILE_onRotationStart','VIEWS_RECOMPILE_onRotationEnd','VIEWS_RECOMPILE_whileRotating','VIEWS_RECOMPILE_constants','VIEWS_RECOMPILE_usageDeclarations','VIEWS_RECOMPILE_jsxString','VIEWS_RECOMPILE_preconditions','VIEWS_RECOMPILE_jsCondition','VIEWS_RECOMPILE_ocl','VIEWS_RECOMPILE_events','VIEWS_RECOMPILE_all','ClassNameChanged','tooltip','advanced','alert'];/* Checking if CompositeAction has some actions that MUST be ignored */let compositeAction=null;if(action.type===CompositeAction.type){compositeAction=action;const subActions=compositeAction.actions||[];compositeAction.actions=subActions.filter(a=>!ignoredFields.includes(a.field));}if(compositeAction&&!compositeAction.actions.length)return ret;action=compositeAction?compositeAction:action;if(action.sender===DUser.current&&!ignoredFields.includes(action.field)){const parsedAction=JSON.parse(JSON.stringify(action));Collaborative.client.emit('pushAction',parsedAction);}}for(let ptr of ret.ELEMENT_CREATED){let d=ret.idlookup[ptr];if(!d)continue;// creation rejected, no-op\nswitch(d.className){default:break;case\"DViewElement\":for(let nid in transientProperties.node){let tn=transientProperties.node[nid];tn.viewScores[d.id]={};}}}ret.ELEMENT_CREATED=[];for(let ptr of ret.ELEMENT_DELETED){let d=oldState.idlookup[ptr];if(!d)continue;// already deleted, no-op\nswitch(d.className){default:break;case\"DViewElement\":for(let nid in transientProperties.node){let tn=transientProperties.node[nid];// delete tn.stackViews; // trigger recalc of all scores.\ndelete tn.viewScores[d.id];tn.needSorting=true;}}}ret.ELEMENT_DELETED=[];if(ret.VIEWS_RECOMPILE_all===true)ret.VIEWS_RECOMPILE_all=Object.keys(ret.idlookup);if((_ret$VIEWS_RECOMPILE_=ret.VIEWS_RECOMPILE_all)===null||_ret$VIEWS_RECOMPILE_===void 0?void 0:_ret$VIEWS_RECOMPILE_.length){let resetAllNodes=false;let sk;for(let id of new Set(ret.VIEWS_RECOMPILE_all)){let d=ret.idlookup[id];if(!d)continue;if(RuntimeAccessibleClass.extends(d.className,\"DViewElement\")){d.css_MUST_RECOMPILE=true;transientProperties.view[d.id]={};// for (let k of DViewElement.MeasurableKeys) (ret as any)['VIEWS_RECOMPILE_'+k].push(d.id);\n// for (let k of DViewElement.RecompileKeys) (ret as any)['VIEWS_RECOMPILE_'+k].push(d.id);\nfor(sk in ret)if(sk.indexOf('VIEWS_RECOMPILE')===0)ret[sk].push(id);// ret.NODES_RECOMPILE_labels.push(id); ret.NODES_RECOMPILE_longestLabel.push(id);\nif(!resetAllNodes)resetAllNodes=true;}if(RuntimeAccessibleClass.extends(d.className,\"DModelElement\")){if(d.className===\"DClass\"){var _oldState$idlookup$d$,_ret$idlookup$d$id;let oldname=(_oldState$idlookup$d$=oldState.idlookup[d.id])===null||_oldState$idlookup$d$===void 0?void 0:_oldState$idlookup$d$.name;let newname=(_ret$idlookup$d$id=ret.idlookup[d.id])===null||_ret$idlookup$d$id===void 0?void 0:_ret$idlookup$d$id.name;if(oldname!==newname)ret.ClassNameChanged[d.id]=oldname;}for(sk in ret)if(sk.indexOf('MODELS_RECOMPILE')===0)ret[sk].push(id);// transientProperties.modelElement[d.id] = { } as any; stuff in here does not need replacement, can never be dangerous (currently).\n}if(RuntimeAccessibleClass.extends(d.className,\"DGraphElement\")){transientProperties.node[d.id]={};for(sk in ret)if(sk.indexOf('NODES_RECOMPILE')===0)ret[sk].push(id);//ret.NODES_RECOMPILE_labels.push(id); ret.NODES_RECOMPILE_longestLabel.push(id);\n}}if(resetAllNodes)for(let nid in transientProperties.node){transientProperties.node[nid]={};for(sk in ret)if(sk.indexOf('NODES_RECOMPILE')===0)ret[sk].push(nid);//ret.NODES_RECOMPILE_labels.push(id); ret.NODES_RECOMPILE_longestLabel.push(id);\n}}ret.VIEWS_RECOMPILE_all=[];function parseLabel(ptr,key,isNode){var _mainView;let dv=DPointerTargetable.fromPointer(ptr,ret);let tp=(isNode?transientProperties.node:transientProperties.view)[ptr];if(!tp)(isNode?transientProperties.node:transientProperties.view)[ptr]=tp={};let val=dv[key];if(!val){tp[key]=undefined;return true;}if(typeof val===\"function\"){tp[key]=val;return true;}let allContextKeys={...contextFixedKeys};let vid=isNode?(_mainView=tp.mainView)===null||_mainView===void 0?void 0:_mainView.id:ptr;if(!vid)return false;// leave pending & recompute them on next reducer action\nlet tv=transientProperties.view[vid];for(let k of tv.constantsList)if(!allContextKeys[k])allContextKeys[k]=true;for(let k of tv.UDList)if(!allContextKeys[k])allContextKeys[k]=true;let paramStr='{'+Object.keys(allContextKeys).join(',')+'}';console.log('labels parse',{allContextKeys,ud:tv.UDList,c:tv.constantsList});const body='return ('+val+')';// if (vid.includes('Model')) console.log(\"modelparse, laels\", {paramStr, body});\nconsole.log('labels parse',{vid:ptr,paramStr,body});try{if(isNode){// need to store the function in tnv instead of tn since if v changes, ud changes as well? in all of them?what if i make a new view?\n}else{// tp[key] = new Function(paramStr, body) as ((...a: any) => any);\n}tp[key]=function(){return'label as an option is disabled, pass it through props instead.';};}catch(e){/*try{\r\n                let try_to_get_better_error = eval(\"let __f = function(\" + paramStr+\") {\\n\" + body + \"}\");\r\n            } catch(eeval){\r\n                console.error(\"eval error same as func error\", {e, eeval});\r\n                e = eeval;\r\n            }*/console.error('error labels parse',{vid:ptr,e,paramStr,body});tp[key]=val;// (context: GObject) => 'Error during label evaluation';\n}return true;// implies recompilation of: ... nothing?\n}let arr;arr=ret.NODES_RECOMPILE_labels;if(arr.length){let successfullyParsed={};for(const id of new Set(arr))successfullyParsed[id]=parseLabel(id,'labels',true);ret.NODES_RECOMPILE_labels=arr.filter(e=>!successfullyParsed[e]);}arr=ret.NODES_RECOMPILE_longestLabel;if(arr.length){let successfullyParsed={};for(const id of new Set(arr))successfullyParsed[id]=parseLabel(id,'longestLabel',true);ret.NODES_RECOMPILE_longestLabel=arr.filter(e=>!successfullyParsed[e]);}arr=ret.VIEWS_RECOMPILE_labels;if(arr.length){let successfullyParsed={};for(const id of new Set(arr))successfullyParsed[id]=parseLabel(id,'labels',false);ret.VIEWS_RECOMPILE_labels=arr.filter(e=>!successfullyParsed[e]);}arr=ret.VIEWS_RECOMPILE_longestLabel;if(arr.length){let successfullyParsed={};for(const id of new Set(arr))successfullyParsed[id]=parseLabel(id,'longestLabel',false);ret.VIEWS_RECOMPILE_longestLabel=arr.filter(e=>!successfullyParsed[e]);}// local changes to out-of-redux stuff\nif(ret.VIEWS_RECOMPILE_ocl.length){// for (let gid of ret.graphs) Selectors.updateViewMatchings(gid, ret.modelElements, Object.values(ret.idlookup).map( d => RuntimeAccessibleClass.extends(d, DModelElement.cname)));\n// for (let vid of ret.VIEW_APPLIABLETO_NEEDS_RECALCULATION) { }\nfor(let vid of new Set(ret.VIEWS_RECOMPILE_ocl)){if(!transientProperties.view[vid])transientProperties.view[vid]={};transientProperties.view[vid].oclEngine=undefined;// force re-parse\ntransientProperties.view[vid].oclChanged=true;for(let nid in transientProperties.node){let tnv=transientProperties.node[nid].viewScores[vid];if((tnv===null||tnv===void 0?void 0:tnv.OCLScore)!==ViewEClassMatch.NOT_EVALUATED_YET)tnv.OCLScore=ViewEClassMatch.NOT_EVALUATED_YET;}}ret.VIEWS_RECOMPILE_ocl=[];}/*\r\n    if (ret.VIEWOCL_UPDATE_NEEDS_RECALCULATION.length) {\r\n        // not implemented for now\r\n        ret.VIEWOCL_UPDATE_NEEDS_RECALCULATION = [];\r\n    }*/if(ret.VIEWS_RECOMPILE_preconditions.length){for(let vid of new Set(ret.VIEWS_RECOMPILE_preconditions)){for(let nid in transientProperties.node){let tnv=transientProperties.node[nid].viewScores[vid];if((tnv===null||tnv===void 0?void 0:tnv.metaclassScore)!==ViewEClassMatch.NOT_EVALUATED_YET)tnv.metaclassScore=ViewEClassMatch.NOT_EVALUATED_YET;}}ret.VIEWS_RECOMPILE_preconditions=[];}if((_ret$VIEWS_RECOMPILE_2=ret.VIEWS_RECOMPILE_constants)===null||_ret$VIEWS_RECOMPILE_2===void 0?void 0:_ret$VIEWS_RECOMPILE_2.length)for(const vid of new Set(ret.VIEWS_RECOMPILE_constants)){// compiled in func, and executed, result does not vary between nodes.\nlet dv=DPointerTargetable.fromPointer(vid,ret);// transientProperties.view[vid].constantsList = dv.constants?.match(UDRegexp).map(s=>s.substring(4, s.length-1).trim()) || [];\n// let allContextKeys = {...contextFixedKeys};\nif(!dv.constants){if(!transientProperties.view[vid])transientProperties.view[vid]={};transientProperties.view[vid].constants={};transientProperties.view[vid].constantsList=[];// no need to recompile UD, jsx or measurables, they will have additional parameters in scope but they are undefined and cause no problems.\ncontinue;}const constantsOutput={};const context={view:dv};// context at this point holds only static stuff, which are in gloval scope (window) plus view.\nlet paramStr='{'+Object.keys(context).join(',')+'}, ret';try{// the scope of new Function() is \"window\" and not the function where is called, unlike eval();\nlet constantsFunction=new Function(paramStr,'return ('+dv.constants+')(ret)').bind(context);constantsFunction(context,constantsOutput);}catch(e){console.error('error constants parse',{vid,e,paramStr,body:'return ('+dv.constants+')(ret)'});// todo: how do i render an error from here? even if i set jsx or ud.__invalidDeclarations it will be recompiled. need a constants.__invalidDeclarations too?\n}transientProperties.view[vid].constants=constantsOutput;transientProperties.view[vid].constantsList=Object.keys(transientProperties.view[vid].constants);// implies recompilation of: jsCondition, ud, jsx and all measurable events\nret.VIEWS_RECOMPILE_jsCondition.push(vid);ret.VIEWS_RECOMPILE_usageDeclarations.push(vid);ret.VIEWS_RECOMPILE_jsxString.push(vid);ret.VIEWS_RECOMPILE_events.push(vid);for(let k of DViewElement.MeasurableKeys)ret['VIEWS_RECOMPILE_'+k].push(vid);}ret.VIEWS_RECOMPILE_constants=[];if((_ret$VIEWS_RECOMPILE_3=ret.VIEWS_RECOMPILE_usageDeclarations)===null||_ret$VIEWS_RECOMPILE_3===void 0?void 0:_ret$VIEWS_RECOMPILE_3.length)for(const vid of new Set(ret.VIEWS_RECOMPILE_usageDeclarations)){var _dv$usageDeclarations;// compiled in func, but NOT executed, result varies between nodes.\nlet dv=DPointerTargetable.fromPointer(vid,ret);let tv=transientProperties.view[vid];if(!tv)transientProperties.view[vid]=tv={};if(!dv.usageDeclarations){tv.UDList=[];tv.UDFunction=undefined;// no need to recompile jsx or measurables, they will have additional parameters in scope but they are undefined and cause no problems.\ncontinue;}let matches=((_dv$usageDeclarations=dv.usageDeclarations)===null||_dv$usageDeclarations===void 0?void 0:_dv$usageDeclarations.match(UDRegexp))||[];transientProperties.view[vid].UDList=matches.map(s=>{s=s.trim();return s.substring(s.indexOf('\\.')+1,s.length-2).trim();});// warning for user: do not redeclare ret in nested blocks.\n// do not use ret[key] syntax.\n// do not set nested values directly (ret.key.subkey syntax).\n// do not use ret.key +=, -= or any other operator assignment different than \"=\"\n// if that is ever required, do instead\n// do not assign values to ret in block comments\n// those restrictions only apply to the ret object, all those violations can be done on other objects.\n// so the following is valid, and a way to overcome the previous limitations:\n// let subobject = {}; subobject[key] += stuff; ret.somefixedname = subobject;\nlet allContextKeys={...contextFixedKeys};for(let k of tv.constantsList)if(!allContextKeys[k])allContextKeys[k]=true;let paramStr='{'+Object.keys(allContextKeys).join(',')+'}, ret';if(vid.includes('Model'))console.log(\"modelparse, ud\",{paramStr,udstr:dv.usageDeclarations,udlist:transientProperties.view[vid].UDList});try{tv.UDFunction=new Function(paramStr,'return ('+dv.usageDeclarations+')(ret)');}catch(e){// problem: errors cannot be serialized in any way? they have no keys. let strerr = JSON.stringify(e); //(e.message || '').split('\\n')[0]);\nlet udErrors=windoww.udErrors;if(!windoww.udErrors)windoww.udErrors=udErrors={maxi:0};udErrors[\"e\"+ ++udErrors.maxi]=e;e.isSyntax=true;let errbody=\"ret.__invalidUsageDeclarations = window.udErrors.e\"+udErrors.maxi+\"; return ret;\";console.error('error udparse',{vid,e,paramStr,body:'return ('+dv.usageDeclarations+')(ret)',errbody});tv.UDFunction=new Function(\"unusedContext, ret\",errbody);}// implies recompilation of: jsx and all measurable events\nret.VIEWS_RECOMPILE_jsxString.push(vid);ret.VIEWS_RECOMPILE_events.push(vid);for(let k of DViewElement.MeasurableKeys)ret['VIEWS_RECOMPILE_'+k].push(vid);}ret.VIEWS_RECOMPILE_usageDeclarations=[];if(ret.VIEWS_RECOMPILE_events.length){// for (let gid of ret.graphs) Selectors.updateViewMatchings(gid, ret.modelElements, Object.values(ret.idlookup).map( d => RuntimeAccessibleClass.extends(d, DModelElement.cname)));\n// for (let vid of ret.VIEW_APPLIABLETO_NEEDS_RECALCULATION) { }\nfor(let entry of new Set(ret.VIEWS_RECOMPILE_events)){let vid;let dv;let keys;if(typeof entry===\"object\"){vid=entry.vid;dv=DPointerTargetable.fromPointer(vid,ret);keys=entry.keys||Object.keys(dv.events);}else{vid=entry;dv=DPointerTargetable.fromPointer(vid,ret);keys=Object.keys(dv.events);}let tv=transientProperties.view[vid];if(!tv)transientProperties.view[vid]=tv={};if(!tv.events)tv.events={};// if (!tv.events_raw) tv.events_raw = {};\nfor(let key of keys){if(!key){delete tv.events[key];continue;}let allContextKeys={...contextFixedKeys};for(let k of transientProperties.view[vid].constantsList)if(!allContextKeys[k])allContextKeys[k]=true;for(let k of transientProperties.view[vid].UDList)if(!allContextKeys[k])allContextKeys[k]=true;let paramStr='{'+Object.keys(allContextKeys).join(',')+'}, ..._params';// dv.events[key] = (...params)=> code\nconst body='return ('+dv.events[key]+')(..._params)';// if (vid.includes('Model')) console.log(\"modelparse, jsx\", {paramStr, body});\ntry{tv.events[key]=new Function(paramStr,body);// tv.events_raw[key] = new Function(paramStr, body) as ((...a:any)=>any);\n// attempt to auto obtain node context\n// impossile with view.event.name\n// could with node.event.name if node.get_event sets a current node thing__, no he must wrap the func!! in the getter\n// tv.events[key] = (..._params2:any) => { return tv.events_raw[key](context, ..._params2) };\n}catch(e){console.error('error jsxparse',{vid,e,paramStr,body});tv.events[key]=context=>Log.ee(\"failed to parse function body: \"+e.message.split(\"\\n\")[0],e.message);}}}ret.VIEWS_RECOMPILE_events=[];// triggers recompile of nothing\n}if((_ret$VIEWS_RECOMPILE_4=ret.VIEWS_RECOMPILE_jsCondition)===null||_ret$VIEWS_RECOMPILE_4===void 0?void 0:_ret$VIEWS_RECOMPILE_4.length)for(const vid of new Set(ret.VIEWS_RECOMPILE_jsCondition)){const dv=DPointerTargetable.fromPointer(vid,ret);let tv=transientProperties.view[vid];if(!tv)transientProperties.view[vid]=tv={};tv.jsConditionChanged=true;if(!dv.jsCondition){tv.jsCondition=undefined;continue;}const lines=dv.jsCondition.trim().split('\\n');let lastLine=lines[lines.length-1];if(lastLine.indexOf('return')!==0)lines[lines.length-1]=\"return (\".concat(lastLine,\")\");if(!dv.jsxString){transientProperties.view[vid].JSXFunction=undefined;continue;}let allContextKeys={...contextFixedKeys};for(let k of transientProperties.view[vid].constantsList)if(!allContextKeys[k])allContextKeys[k]=true;let paramStr='{'+Object.keys(allContextKeys).join(',')+'}';const body=lines.join('\\n');try{tv.jsCondition=new Function(paramStr,body);}catch(e){tv.jsCondition=undefined;console.log('JS Condition parsed error',e);}}ret.VIEWS_RECOMPILE_jsCondition=[];if((_ret$VIEWS_RECOMPILE_5=ret.VIEWS_RECOMPILE_jsxString)===null||_ret$VIEWS_RECOMPILE_5===void 0?void 0:_ret$VIEWS_RECOMPILE_5.length)for(const vid of new Set(ret.VIEWS_RECOMPILE_jsxString)){// compiled in func, but NOT executed, result varies between nodes.\nlet dv=DPointerTargetable.fromPointer(vid,ret);let tv=transientProperties.view[vid];if(!tv)transientProperties.view[vid]=tv={};if(!dv.jsxString){transientProperties.view[vid].JSXFunction=undefined;continue;}let allContextKeys={...contextFixedKeys};for(let k of transientProperties.view[vid].constantsList)if(!allContextKeys[k])allContextKeys[k]=true;for(let k of transientProperties.view[vid].UDList)if(!allContextKeys[k])allContextKeys[k]=true;let paramStr='{'+Object.keys(allContextKeys).join(',')+'}';const body='return ('+UX.parseAndInject(DSL.parser(dv.jsxString),dv)+')';// if (vid.includes('Model')) console.log(\"modelparse, jsx\", {paramStr, body});\ntry{transientProperties.view[vid].JSXFunction=new Function(paramStr,body);}catch(e){/*try{\r\n                let try_to_get_better_error = eval(\"let __f = function(\" + paramStr+\") {\\n\" + body + \"}\");\r\n            } catch(eeval){\r\n                console.error(\"eval error same as func error\", {e, eeval});\r\n                e = eeval;\r\n            }*/console.error('error jsxparse',{vid,e,paramStr,body});transientProperties.view[vid].JSXFunction=context=>GraphElementComponent.displayError(e,'JSX Syntax',dv);}// implies recompilation of: ... nothing?\n}ret.VIEWS_RECOMPILE_jsxString=[];for(const key of DViewElement.MeasurableKeys){var _ref;if((_ref=ret['VIEWS_RECOMPILE_'+key])===null||_ref===void 0?void 0:_ref.length)for(let vid of new Set(ret['VIEWS_RECOMPILE_'+key])){let dv=DPointerTargetable.fromPointer(vid,ret);let tv=transientProperties.view[vid];if(!tv)transientProperties.view[vid]=tv={};let str=dv[key];if(!str){transientProperties.view[vid][key]=undefined;continue;}let allContextKeys={...contextFixedKeys};for(let k of transientProperties.view[vid].constantsList)if(!allContextKeys[k])allContextKeys[k]=true;for(let k of transientProperties.view[vid].UDList)if(!allContextKeys[k])allContextKeys[k]=true;let paramStr='{'+Object.keys(allContextKeys).join(',')+'}';console.log('measurable parse '+key,{allContextKeys,ud:transientProperties.view[vid].UDList,c:transientProperties.view[vid].constantsList});console.log('measurable parse '+key,{vid,paramStr,body:str});try{transientProperties.view[vid][key]=new Function(paramStr,str);}catch(e){console.error('error measurable parse '+key,{vid,e,paramStr,body:str});transientProperties.view[vid][key]=undefined;// display error in jsx\ntransientProperties.view[vid].JSXFunction=context=>GraphElementComponent.displayError(e,'Measurable '+key+' Syntax',dv);break;}}ret['VIEWS_RECOMPILE_'+key]=[];}for(let dataid in ret.ClassNameChanged){if(dataid==='clonedCounter')continue;// NB: if i ever want to access a constructor's other properties in ocl, like \"context Persona inv: self.$somecounter === Persona.instances.length\",\n// i would need to update this every time a DClass property changes instead of only when name changes.\n// if it's first creation of a modelpiece\nif(!transientProperties.modelElement[dataid]){transientProperties.modelElement[dataid]={nodes:{}};}// update ocl type names\nlet data=ret.idlookup[dataid];RuntimeAccessibleClass.makeOCLConstructor(data,ret,oldState);// here i should reset all tnv.oclEngine too and set all ocl scores to notevaluated, but it is too computationally heavy\n// and it's useful to keep the old ocl condition valid with past names until manually edited.\n}ret.ClassNameChanged={};return ret;}export function _reducer/*<S extends StateNoFunc, A extends Action>*/(){let oldState=arguments.length>0&&arguments[0]!==undefined?arguments[0]:initialState;let action=arguments.length>1?arguments[1]:undefined;let times;let state;let removedDeltas=[];switch(action.type){case UndoAction.type:times=action.value;state=oldState;Log.exDev(times<=0,\"undo must be positive\",action);while(times--){const delta=statehistory[DUser.current].undoable.pop();removedDeltas.push(delta);state=undo(state,delta);}state.VIEWS_RECOMPILE_all=removedDeltas.flatMap(d=>Object.keys((d===null||d===void 0?void 0:d.idlookup)||{}));// state.VIEWS_RECOMPILE_all = true;\nreturn state;case RedoAction.type:times=action.value;state=oldState;Log.exDev(times<=0,\"redo must be positive\",action);while(times--){const delta=statehistory[DUser.current].redoable.pop();removedDeltas.push(delta);state=undo(state,delta,false);}state.VIEWS_RECOMPILE_all=removedDeltas.flatMap(d=>Object.keys((d===null||d===void 0?void 0:d.idlookup)||{}));// state.VIEWS_RECOMPILE_all = true;\nreturn state;// case CombineHistoryAction.type: return combineHistory(oldState); break;\n// todo: se al posto di \"annullare l'undo\" memorizzo l'azione e la rieseguo, posso ripetere l'ultimo passo N volte e questa azione diventa utile per combinare passi e ripetere blocchi di azioni assieme\ndefault:let ret=doreducer(oldState,action);if(ret===oldState)return ret;// statehistory[DUser.current].redoable = [];   <-- Moved to stateInitializer()\nlet delta=U.objectDelta(ret,oldState);if(!filterundoableactions(delta))return ret;// console.log(\"setting undoable action:\", {ret, oldState0:{...oldState}, oldState, delta});\nif(oldState!==null)statehistory[DUser.current].undoable.push(delta);return ret;}}function filterundoableactions(delta){if(!statehistory.globalcanundostate)return false;if(Object.keys(delta).length===1){if(\"dragging\"in delta)return false;if(\"_lastSelected\"in delta)return false;if(\"contextMenu\"in delta)return false;}return true;}function undo(state,delta){let isundo=arguments.length>2&&arguments[2]!==undefined?arguments[2]:true;if(!delta)return state;let undonestate={...state};//   controlla se vengono shallow-copied solo e tutti gli oggetti nested lungo la catena del percorso delle modifiche\n//   es: root.a.b.c=3 + root.a.b.d=3 = 4+1 modifiche, 5 shallow copies including the root\nundorecursive(delta,undonestate);if(isundo)statehistory[DUser.current].redoable.push(U.objectDelta(undonestate,state));// reverses from undo to redo and viceversa swapping arguments, so the target result after appliying the delta changes\nelse statehistory[DUser.current].undoable.push(U.objectDelta(undonestate,state));// redo is \"undoing an undo\", reversing his changes just like an undo reverses an ordinary action changes.\nreturn undonestate;}function undorecursive(deltalevel,statelevel){// statelevel = {...statelevel}; not working if i do it here, just a new var. first time copy id done in caller func undo(). recursive copies are done before recursive step\nfor(let key in deltalevel){let delta=deltalevel[key];console.log(\"undoing\",{delta,key,deltalevel,statelevel});if(key.indexOf(\"_-\")===0){delete statelevel[key.substring(2)];continue;}if(typeof delta===\"object\"){// if (U.isObject(delta, false, false, true)) {\nstatelevel[key]={...statelevel[key]};undorecursive(deltalevel[key],statelevel[key]);}else{statelevel[key]=delta;}}}function doreducer/*<S extends StateNoFunc, A extends Action>*/(){let oldState=arguments.length>0&&arguments[0]!==undefined?arguments[0]:initialState;let action=arguments.length>1?arguments[1]:undefined;if(!oldState){oldState=initialState=DState.new();}let ca;// console.log('external REDUCER', {action, CEtype:CreateElementAction.type});\nif(!storeLoaded){// new SetRootFieldAction('forceinit', true);\nstoreLoaded=true;}if(!oldState.forceinit){// afterStoreLoad();\n// new SetRootFieldAction('forceinit', true);\n}//  setTimeout(afterStoreLoad, 1);\nswitch(action.type){case CompositeAction.type:ca=action;break;case LoadAction.type:default:if(action.type.indexOf('@@redux/')===0){//storeLoaded = true;\nreturn oldState;}ca=new CompositeAction([action],false);break;}let ret=CompositeActionReducer(oldState,ca);/*if (state.current !== ret) {\r\n        state.current = ret;\r\n        state.past.push(ret);\r\n    }*/return ret;}function setSubclasses(roots){RuntimeAccessibleClass.extendMatrix=new SimpleTree(roots,\"subclasses\").getiIsSubElementMatrix(\"cname\");/*\r\n    let tree = new TreeModel({\r\n        childrenPropertyName: \"subclasses\"\r\n    });\r\n    for (let key in dict){\r\n        let constructor = dict[key];\r\n        if(!constructor.hasOwnProperty(\"subclasses\")) constructor.subclasses = [];\r\n    }\r\n    RuntimeAccessibleClass.extendTree = (tree as any).safe_parse(RuntimeAccessibleClass);*/}// windoww.TreeModel = TreeModel;\nfunction buildLSingletons(alld,alll){for(let dname in alld){switch(dname){case\"DeleteElementAction\":continue;case\"DV\":continue;case\"Debug\":continue;default:break;}if((dname[1]||\"\").toLowerCase()===dname[1])continue;// if second letter is lowercase, it's not a \"D\" class\nlet tagless=dname.substring(1);let d=alld[dname];let l=alll['L'+tagless];if(!d||!l)console.error(\"missing d constructor\",{d,l});d.logic=l;if(!l)console.error('init() could not find L-class during mapping',l,d);// @ts-ignore\nd.singleton=new l('dwc');d.structure=d;l.logic=d.logic;l.singleton=d.singleton;l.structure=d.structure;// if (!d.subclasses) d.subclasses = [];\n// @ts-ignore\n// for (let sc of d.subclasses) { if (!sc[\"_extends\"]) sc[\"_extends\"] = [];  sc[\"_extends\"].push(d); }\n}}function setDocumentEvents(){// do not use typings or class constructors here or it will change import order\nsetTimeout(()=>$(document).on(\"mouseup\",e=>RuntimeAccessibleClass.get(\"GraphDragManager\").stopPanning(e)),// ()=> $(document).on(\"mouseup\", (e: MouseUpEvent) => (window as any).GraphDragManager.stopPanning(e)), //a\n1);// document.body.addEventListener(\"mousedown\", fixResizables, false);\n}function fixResizables(e){/*let parents = U.ancestorArray(e.target as HTMLElement);\r\n    for (let e of parents){\r\n        if (e.classList.contains(\"draggable\")) U.makeDraggable(e, e.dataset.draggableOptions, e.attributes.disabled);\r\n        if (e.classList.contains(\"resizable\")) U.makeResizable(e, e.dataset.draggableOptions);\r\n        if (e.classList.contains(\"resizable\")) U.makeRotatable(e, e.dataset.draggableOptions);\r\n    }*/}export async function stateInitializer(){RuntimeAccessibleClass.fixStatics();let dClassesMap={};let lClassesMap={};for(let name in RuntimeAccessibleClass.classes){switch(name[0]){case'D':dClassesMap[name]=RuntimeAccessibleClass.classes[name];break;case'L':lClassesMap[name]=RuntimeAccessibleClass.classes[name];break;default:break;}}buildLSingletons(dClassesMap,lClassesMap);setSubclasses(RuntimeAccessibleClass.get('DPointerTargetable'));windoww.defaultContext={$:windoww.$,getPath,React:React,Selectors,...RuntimeAccessibleClass.getAllClassesDictionary(),...windoww.Components};setDocumentEvents();DState.init();const user=Storage.read('user');if(user){DUser.new(user.name,user.surname,user.nickname,user.affiliation,user.country,user.newsletter,user.email,user.token,user.id);DUser.current=user.id;statehistory[user.id]={redoable:[],undoable:[]};await ProjectsApi.getAll();}else DUser.current='';}","map":{"version":3,"names":["DViewElement","UX","GraphElementComponent","ViewEClassMatch","Action","CompositeAction","CreateElementAction","DeleteElementAction","DPointerTargetable","DState","DUser","getPath","Log","MyError","PendingPointedByPaths","PointedBy","Pointers","RuntimeAccessibleClass","SetFieldAction","SetRootFieldAction","statehistory","React","LoadAction","RedoAction","UndoAction","Collaborative","SimpleTree","transientProperties","Selectors","contextFixedKeys","Storage","ProjectsApi","DSL","windoww","window","U","deepCopyButOnlyFollowingPath","oldStateDoNotModify","action","prevAction","newVal","_action$path","newRoot","current","path","length","gotChanged","alreadyPastDivergencePoint","i","pathArray","key","trim","prevActionPathKey","Array","isArray","clonedCounter","isArrayAppend","isArrayRemove","isObjectMerge","isObjectDifference","oldValue","endsWith","substr","replaceAll","type","ee","preexistingValue","isShallowEqual","value","tmp","subkey","isPointer","add","push","index","isNumber","undefined","indexOf","removedval","splice","remove","oldpointerdestinations","newpointerdestinations","difference","arrayDifference","rem","removed","added","exDevv","CompositeActionReducer","oldState","actionBatch","actions","parse","all","getSolveableActions","possibleInconsistencies","derivedActions","newState","elem","pendingCreation","id","className","constructor","cname","name","statefoldername","substring","toLowerCase","create","pointedBy","new","arrayMergeInPlace","sort","a1","a2","stringCompare","actiontype","console","log","a","t","field","v","updateRedundancies_OBSOLETE","state","subType","SubType","vertexSubElements","initialState","storeLoaded","UDRegexp","reducer","arguments","unsafereducer","e","error","_ret$VIEWS_RECOMPILE_","_ret$VIEWS_RECOMPILE_2","_ret$VIEWS_RECOMPILE_3","_ret$VIEWS_RECOMPILE_4","_ret$VIEWS_RECOMPILE_5","ret","_reducer","idlookup","__proto__","collaborativeSession","ignoredFields","compositeAction","subActions","filter","includes","sender","parsedAction","JSON","stringify","client","emit","ptr","ELEMENT_CREATED","d","nid","node","tn","viewScores","ELEMENT_DELETED","needSorting","VIEWS_RECOMPILE_all","Object","keys","resetAllNodes","sk","Set","extends","css_MUST_RECOMPILE","view","_oldState$idlookup$d$","_ret$idlookup$d$id","oldname","newname","ClassNameChanged","parseLabel","isNode","_mainView","dv","fromPointer","tp","val","allContextKeys","vid","mainView","tv","k","constantsList","UDList","paramStr","join","ud","c","body","arr","NODES_RECOMPILE_labels","successfullyParsed","NODES_RECOMPILE_longestLabel","VIEWS_RECOMPILE_labels","VIEWS_RECOMPILE_longestLabel","VIEWS_RECOMPILE_ocl","oclEngine","oclChanged","tnv","OCLScore","NOT_EVALUATED_YET","VIEWS_RECOMPILE_preconditions","metaclassScore","VIEWS_RECOMPILE_constants","constants","constantsOutput","context","constantsFunction","Function","bind","VIEWS_RECOMPILE_jsCondition","VIEWS_RECOMPILE_usageDeclarations","VIEWS_RECOMPILE_jsxString","VIEWS_RECOMPILE_events","MeasurableKeys","_dv$usageDeclarations","usageDeclarations","UDFunction","matches","match","map","s","udstr","udlist","udErrors","maxi","isSyntax","errbody","entry","events","message","split","jsConditionChanged","jsCondition","lines","lastLine","concat","jsxString","JSXFunction","parseAndInject","parser","displayError","_ref","str","dataid","modelElement","nodes","data","makeOCLConstructor","times","removedDeltas","exDev","delta","undoable","pop","undo","flatMap","redoable","doreducer","objectDelta","filterundoableactions","globalcanundostate","isundo","undonestate","undorecursive","deltalevel","statelevel","ca","forceinit","setSubclasses","roots","extendMatrix","getiIsSubElementMatrix","buildLSingletons","alld","alll","dname","tagless","l","logic","singleton","structure","setDocumentEvents","setTimeout","$","document","on","get","stopPanning","fixResizables","stateInitializer","fixStatics","dClassesMap","lClassesMap","classes","defaultContext","getAllClassesDictionary","Components","init","user","read","surname","nickname","affiliation","country","newsletter","email","token","getAll"],"sources":["C:/0Programmi/Dev/projects/frontend/jjodel/frontend/src/redux/reducer/reducer.ts"],"sourcesContent":["import {\r\n    U as UType,\r\n    GraphDragManager,\r\n    MouseUpEvent,\r\n    orArr,\r\n    DModelElement,\r\n    DViewElement,\r\n    DClass,\r\n    DModel,\r\n    UX,\r\n    EdgeOwnProps,\r\n    EdgeStateProps,\r\n    GraphElementComponent,\r\n    ViewEClassMatch,\r\n    bool,\r\n    NodeTransientProperties,\r\n    ViewTransientProperties,\r\n    DGraphElement, Uarr\r\n} from '../../joiner';\r\nimport {\r\n    Action,\r\n    CompositeAction,\r\n    CreateElementAction,\r\n    DeleteElementAction,\r\n    Dictionary,\r\n    DocString,\r\n    DPointerTargetable,\r\n    DState,\r\n    DUser,\r\n    getPath,\r\n    GObject,\r\n    Log,\r\n    LPointerTargetable,\r\n    MyError,\r\n    ParsedAction,\r\n    PendingPointedByPaths,\r\n    PointedBy,\r\n    Pointer,\r\n    Pointers,\r\n    RuntimeAccessibleClass,\r\n    SetFieldAction,\r\n    SetRootFieldAction,\r\n    statehistory\r\n} from \"../../joiner\";\r\nimport React from \"react\";\r\nimport {LoadAction, RedoAction, UndoAction} from \"../action/action\";\r\nimport Collaborative from \"../../components/collaborative/Collaborative\";\r\nimport {SimpleTree} from \"../../common/SimpleTree\";\r\nimport {transientProperties, Selectors} from \"../../joiner\";\r\nimport {OclEngine} from \"@stekoe/ocl.js\";\r\nimport { contextFixedKeys } from '../../graph/graphElement/sharedTypes/sharedTypes';\r\nimport Storage from \"../../data/storage\";\r\nimport {ProjectsApi} from \"../../api/persistance\";\r\nimport DSL from \"../../DSL/DSL\";\r\n\r\nlet windoww = window as any;\r\nlet U: typeof UType = windoww.U;\r\n\r\n\r\nfunction deepCopyButOnlyFollowingPath(oldStateDoNotModify: DState, action: ParsedAction, prevAction: ParsedAction, newVal: any): DState | false{\r\n    let newRoot: DState = {...oldStateDoNotModify} as DState;\r\n    let current: any = newRoot;\r\n    if (!action.path?.length) throw new MyError(\"path length must be at least 1\", {action});\r\n    let gotChanged: boolean = false; // dovrebbe cambiare sempre, se non cambia non lancio neanche l'azione e non faccio la shallow copy, ma non si sa mai, così posso evitare un render se succede l' \"insuccedibile\"\r\n    let alreadyPastDivergencePoint = false; // true dal momento in cui il path dell'azione attuale e della azione precedente divergono, false fino al sotto-segmento in cui combaciano\r\n    // console.log('deepCopyButOnlyFollowingPath', arguments);\r\n    for (let i = 0; i < action.pathArray.length; i++) {\r\n        let key = action.pathArray[i].trim();\r\n        let prevActionPathKey = prevAction?.pathArray[i];\r\n        // middle execution: not on final loop\r\n        // console.log('deepCopyButOnlyFollowingPath', {current, i, imax:action.pathArray.length, key, gotChanged, alreadyPastDivergencePoint});\r\n        if (i !== action.pathArray.length - 1) {\r\n            if (alreadyPastDivergencePoint || key !== prevActionPathKey) {\r\n                // se l'oggetto è stato già duplicato in una azione composita, non lo duplico 2 volte.\r\n                alreadyPastDivergencePoint = true;\r\n                current[key] = Array.isArray(current[key]) ? [...current[key]] : {...current[key]};\r\n                current[key].clonedCounter = 1 + (current[key].clonedCounter || 0);\r\n            }\r\n            current = current[key];\r\n            continue;\r\n        }\r\n        // Giordano: added this on 03/12/2023 to prevent \"Cannot read properties of undefined\".\r\n        // if(!current) continue; damiano: temp removed to check if there are invalid actions firing\r\n        // perform final assignment\r\n        if (i >= action.pathArray.length - 1) {\r\n            let isArrayAppend = false;\r\n            let isArrayRemove = false;\r\n            let isObjectMerge = false;\r\n            let isObjectDifference = false;\r\n            // console.log('isarrayappend?', {endswith: U.endsWith(key, ['+=', '[]', '-1']), key, action, i});\r\n            // console.log('isarraydelete?', {endswith: U.endsWith(key, ['-='])});\r\n\r\n            let oldValue: any;\r\n            if (U.endsWith(key, ['+=', '[]'])) {\r\n                key = key.substr(0, key.length - 2).trim();\r\n                oldValue = current[key];\r\n                switch (typeof oldValue){\r\n                    case 'object':\r\n                    if (Array.isArray(oldValue)) isArrayAppend = true;\r\n                    else isObjectMerge = true;\r\n                    break;\r\n                    default: newVal += oldValue; break;\r\n                }\r\n            }\r\n            if (U.endsWith(key, ['-='])) {\r\n                key = key.substr(0, key.length - 2).trim();\r\n                oldValue = current[key];\r\n                switch (typeof oldValue){\r\n                    case 'object':\r\n                        if (Array.isArray(oldValue)) isArrayRemove = true;\r\n                        else isObjectDifference = true;\r\n                        break;\r\n                    case \"string\":\r\n                        newVal = U.replaceAll(oldValue, newVal, '');\r\n                        break;\r\n                    case 'number': newVal = oldValue - newVal; break;\r\n                    default: isArrayRemove = true; break;\r\n                }\r\n                // isArrayRemove = true;\r\n            }\r\n\r\n            // let unpointedElement: DPointerTargetable | undefined;\r\n            // perform final assignment\r\n            if (action.type === CreateElementAction.type && current[key]) {\r\n                oldValue = current[key];\r\n                gotChanged = false;\r\n                Log.ee(\"rejected CreateElementAction, rollback occurring:\", {action,\r\n                    preexistingValue: current[key], isShallowEqual: current[key] === action.value });\r\n                return false; // warning: use return only when you want to abort and skip subsequent CompositeAction sub-actions like now.\r\n            }\r\n            if (isObjectMerge) {\r\n                if (typeof newVal === 'string') { let tmp: any = {}; tmp[newVal] = true; newVal = tmp; }\r\n                oldValue = {...current[key]};\r\n                current[key] = {...current[key]};\r\n                for (let subkey in newVal) {\r\n                    // console.warn(\"object merge\", {current, key, subkey, newVal, old:current[key][subkey], new:newVal[subkey]});\r\n                    if (current[key][subkey] === newVal[subkey]) continue;\r\n                    current[key][subkey] = newVal[subkey];\r\n                    gotChanged = true;\r\n                    if (action.isPointer) { newRoot = PointedBy.add(key as Pointer, action, newRoot, \"+=\"); }\r\n                }\r\n            } else\r\n            if (isObjectDifference) {\r\n                if (typeof newVal === 'string') { let tmp: any = {}; tmp[newVal] = true; newVal = tmp; }\r\n                oldValue = {...current[key]};\r\n                current[key] = {...current[key]};\r\n                for (let subkey in newVal) {\r\n                    if (!(subkey in current[key])) continue;\r\n                    delete current[key][subkey];\r\n                    gotChanged = true;\r\n                    if (action.isPointer) { newRoot = PointedBy.add(key as Pointer, action, newRoot, \"-=\"); }\r\n                }\r\n            } else\r\n            if (isArrayAppend) {\r\n                gotChanged = true;\r\n                if (!Array.isArray(current[key])) { current[key] = []; }\r\n                oldValue = [...current[key]];\r\n                current[key] = [...current[key]];\r\n                current[key].push(newVal);\r\n                // unpointedElement = undefined;\r\n                if (action.isPointer) { newRoot = PointedBy.add(newVal as Pointer, action, newRoot, \"+=\"); }\r\n            } else\r\n            if (isArrayRemove) {\r\n                if (!Array.isArray(current[key])) { current[key] = []; }\r\n                oldValue = [...current[key]];\r\n                let index: number;\r\n                if (U.isNumber(newVal)) { // delete by index\r\n                    index = newVal;\r\n                    if (index < 0) index = oldValue.length + index; // if index is -2, i remove the penultimate element\r\n                } else\r\n                if (newVal === undefined) {\r\n                    index = oldValue.length - 1;\r\n                }\r\n                else {\r\n                    index = oldValue.indexOf(newVal);\r\n                }\r\n                // if it's negatively or positively out of boundary, i skip it\r\n                gotChanged = index >= 0 && index < current[key].length;\r\n                if (gotChanged) {\r\n                    current[key] = [...current[key]];\r\n                    let removedval = current[key].splice(index, 1); // in-place edit\r\n                    if (action.isPointer) { newRoot = PointedBy.remove(removedval as Pointer, action, newRoot, '-='); }\r\n                    /*\r\n                    fixed problem: se ho [dobj1, dobj2]... e li swappo, cambia un indice nel percorso \"pointedby\" e non me ne accorgo mai e un oggetto risulta \"pointedby\" da oggetti che non lo puntano o non esistono più a quell'indice\r\n                    SOLVED! by not including index in pointedBy path, but making it like \"parentObject.arrayKey+=\" instead of \"parentObject.arrayKey.4\"\r\n                    and knowing it's in the array it's enough info.\r\n\r\n                    // a.pointsto = [x, y, z]; a.pointsto = [x, z]       --->    remove a from y.pointedby\r\n                    const elementsThatChangedIndex: DPointerTargetable[] = current[key].slice(index);\r\n\r\n                    for (let j = 0; j < elementsThatChangedIndex.length; j++) {\r\n                        let newindex = index + j - 1;\r\n                        let oldFullpathTrimmed = action.pathArray.join('.');\r\n                        se realizzi \"pointedby\" qui è to do: remove old paths and re-add them with updated index\r\n                    }\r\n                    unpointedElement = newRoot.idlookup[oldValue];\r\n                    */\r\n                }\r\n            } else\r\n            if ((action.type === DeleteElementAction.type && !(key in current)) || current[key] === newVal) {\r\n                // value not changed\r\n                gotChanged = false;\r\n            } else {\r\n                // value changed\r\n                // todo: caso in cui setto manualmente classes.1 = pointer;\r\n                //  the latest element is array and not DPointerTargetable, so might need to buffer upper level in the tree? or instead of \"current\" keep an array of sub-objects encountered navigating the path in state.\r\n                oldValue = current[key];\r\n                gotChanged = true;\r\n                // unpointedElement = newRoot.idlookup[oldValue];\r\n                // NB: se elimino un oggetto che contiene array di puntatori, o resetto l'array di puntatori kinda like store.arr= [ptr1, ptr2, ...]; store.arr = [];\r\n                // i puntati dall'array hanno i loro pointedBY non aggiornati, non voglio fare un deep check di tutto l'oggetto a cercare puntatori per efficienza.\r\n                // if (newVal === undefined) delete current[key];\r\n                if ((newVal === undefined) || false && action.type === DeleteElementAction.type) delete current[key];\r\n                else current[key] = newVal;\r\n\r\n                // update pointedBy's\r\n                // NB: even if the current action have isPointer=true, it doesn't mean the old value is a pointer as well for sure. so need to check old values.\r\n                // also what if old val is pointer, and new one isn't? will it be just removed without updating pointedBy's?\r\n                // already fixed: might need to evaluate this if block always regardless of action.isPointer,\r\n                // and do checks every time both on old and new value if they actually are ptrs.\r\n                if (true || action.isPointer) {\r\n                    let oldpointerdestinations: unknown[];\r\n                    let newpointerdestinations: unknown[];\r\n                    if (Array.isArray(newVal)) {\r\n                        newpointerdestinations = newVal;\r\n                        if (Array.isArray(oldValue)) { // case: path.array = array;\r\n                            oldpointerdestinations = oldValue;\r\n                        }\r\n                        else { // case: path.object = array; + case: path.value = array;\r\n                            oldpointerdestinations = [oldValue];\r\n                        }\r\n                    }\r\n                    else {\r\n                        // case: path.array = object; + case: path.array = value;\r\n                        newpointerdestinations = [newVal];\r\n                        if (Array.isArray(oldValue)) {\r\n                            oldpointerdestinations = oldValue;\r\n                        } else {\r\n                            // case: path.object = object; and all other cases without arrays involved\r\n                            oldpointerdestinations = [oldValue];\r\n                        }\r\n                    }\r\n                    // after i mapped all cases to path.array = array; i solve it for that case.\r\n                    let difference = U.arrayDifference(oldpointerdestinations, newpointerdestinations); // : {added: Pointer[], removed: Pointer[], starting: Pointer[], final: Pointer[]}\r\n                    for (let rem of difference.removed) {if (Pointers.isPointer(rem))\r\n                        newRoot = PointedBy.remove(rem, action, newRoot, undefined, oldStateDoNotModify); }\r\n                    for (let add of difference.added) { if (Pointers.isPointer(add))\r\n                        newRoot = PointedBy.add(add, action, newRoot, undefined, oldStateDoNotModify); }\r\n                    // a.pointsto = [a, b, c];  a.pointsto = [a, b, x];    ------>     c.pointedby.remove(a) & x.pointedby.add(a)\r\n                    // idlookup.somelongid.pointsto = [...b];\r\n                }\r\n            }\r\n            break;\r\n        }\r\n        Log.exDevv('should not reach here: reducer');\r\n    }\r\n    return gotChanged ? newRoot : oldStateDoNotModify;\r\n}\r\n\r\n\r\n// const pendingPointedByPaths: {from: DocString<\"Path in store\">, field: DocString<\"keyof object found in from path\">, to: Pointer}[] = [];\r\nfunction CompositeActionReducer(oldState: DState, actionBatch: CompositeAction): DState {\r\n    // per via di thunk se arrivo qui lo stato cambia sicuro in mono-client non synchro (non ri-assegno valori equivalenti)\r\n    // todo: ma se arrivano in ordine sbagliato da altri client? posso permetterlo?\r\n    let actions: ParsedAction[];\r\n    if (actionBatch.actions) actions = Action.parse(actionBatch.actions);\r\n    else actions = [Action.parse(actionBatch)]; // else-case is if it's a single action and not an actual compositeaction\r\n    if (PendingPointedByPaths.all.length) actions.push(...PendingPointedByPaths.getSolveableActions(oldState)); //.all.map( p=> p.resolve() ) );\r\n\r\n    Action.possibleInconsistencies = {};\r\n\r\n    // estraggo le azioni derivate\r\n    let derivedActions: ParsedAction[] = [];\r\n    let newState = oldState;\r\n    for (let action of actions) {\r\n        switch (action.type){\r\n            default: break;\r\n            case CreateElementAction.type:\r\n                const elem: DPointerTargetable = action.value;\r\n                delete DPointerTargetable.pendingCreation[elem.id];\r\n                /*\r\n                if (oldState.idlookup[elem.id]) {\r\n                    Log.ee(\"rejected CreateElementAction, rollback occurring:\", {action, elem:{...elem},\r\n                        preexistingValue: {...oldState.idlookup[elem.id]}, isEqual: elem === oldState.idlookup[elem.id] });\r\n                    return oldState; // warning: use return only when you want to abort and skip subsequent CompositeAction sub-actions like now.\r\n\r\n                    action.value = \"An element with that id already existed.\";\r\n                    action.path = action.field = \"CreateActionRejected\";\r\n                    action.className = SetRootFieldAction.name;\r\n                    action.type = SetRootFieldAction.type;\r\n                    action.pathArray = [action.path]; //a\r\n                    action.isPointer = false;\r\n                    // just to log it in undo-redo action list and have a feedback\r\n                    return oldState;}*/\r\n\r\n                elem.className = elem.className || (elem.constructor as typeof RuntimeAccessibleClass).cname || elem.constructor.name;\r\n                let statefoldername = elem.className.substring(1).toLowerCase() + 's';\r\n                derivedActions.push(\r\n                    Action.parse(SetRootFieldAction.create(statefoldername, elem.id,'[]', true)));\r\n                if (!Array.isArray(elem.pointedBy)) elem.pointedBy = [];\r\n                elem.pointedBy.push(PointedBy.new(statefoldername));\r\n                /*if (false && action.isPointer) {\r\n                    if (Array.isArray(action.value)) {\r\n                        const ptr: Pointer[] = action.value;\r\n                        // todo but replaced by side actions in execution of the main action instead of triggering derived actions\r\n                    }\r\n                    else {\r\n                        const ptr: Pointer = action.value;\r\n                        const target: DPointerTargetable | null = oldState.idlookup[ptr];\r\n                        let pendingPointedBy = PendingPointedByPaths.new(action, oldState);\r\n                        if (!target) PendingPointedByPaths.new(action, oldState).saveForLater(); // {from: action.path, field: action.field, to: target});\r\n                        // @ts-ignore\r\n                        else derivedActions.push(pendingPointedBy.resolve());\r\n                        // a -> x\r\n                        // a -> y     unset x.pointedby(a)\r\n                    }\r\n                }*/\r\n                break;\r\n        }\r\n    }\r\n    // console.error({U, Umip:U.arrayMergeInPlace, WU: windoww.U, WUmip: windoww.U.arrayMergeInPlace});\r\n    actions = U.arrayMergeInPlace<ParsedAction>(actions, derivedActions);\r\n\r\n    // ordino i path con segmenti comuni\r\n    actions = actions.sort( (a1, a2) => U.stringCompare(a1.path, a2.path));\r\n\r\n    // destrutturo solo i nodi intermedi e solo la prima volta che li incontro (richiede le azioni ordinate in base al path)\r\n\r\n    for (let i = 0; i < actions.length; i++) {\r\n        const prevAction: ParsedAction = actions[i-1];\r\n        const action: ParsedAction = actions[i];\r\n        const actiontype = action.type.indexOf('@@') === 0 ? 'redux' : action.type;\r\n        console.log('executing action:', {a:action, t:actiontype, field: action.field, v:action.value}); //, count: ++action.executionCount});\r\n\r\n        switch (actiontype) {\r\n            /*\r\n            case '@@redux/INIT6.x.f.d.r.e':\r\n            case '@@redux/INITm.f.1.s.o.g':\r\n            case '@@redux/INIT5.t.4.v.d.o':\r\n            case '@@redux/INITy.a.d.r.l.a':\r\n            case '@@redux/INIT4.2.q.u.z.k':\r\n            case '@@redux/INITj.8.e.g.y.p':\r\n            case '@@redux/INITp.k.q.g.z.w':\r\n            case '@@redux/INITq.c.u.w.f.e': ... etc*/\r\n            default:\r\n                if (action.type.indexOf('@@redux/') === 0) break;\r\n                return Log.exDevv('unexpected action type:', action.type);\r\n            case LoadAction.type: newState = action.value; break;\r\n            case CreateElementAction.type:\r\n            case SetRootFieldAction.type:\r\n            case DeleteElementAction.type:\r\n            case SetFieldAction.type:\r\n                let tmp: false | DState = deepCopyButOnlyFollowingPath(newState, action, prevAction, action.value);\r\n                if (!tmp) return oldState; // rollback due to invalid action in transaction\r\n                newState = tmp;\r\n                break;\r\n        }\r\n\r\n        // and that's all, the reducer is really simple as actions are really simple.\r\n    }\r\n\r\n    // effetti collaterali, aggiornamento di ridondanze\r\n    newState = updateRedundancies_OBSOLETE(newState, oldState, Action.possibleInconsistencies);\r\n    return newState;\r\n}\r\n\r\nfunction updateRedundancies_OBSOLETE(state: DState, oldState:DState, possibleInconsistencies: Dictionary<DocString<'subtype'>, (Pointer | DPointerTargetable)[]>): DState {\r\n    for (let subType in possibleInconsistencies)\r\n    switch (subType) {\r\n        default: break;\r\n        case Action.SubType.vertexSubElements:/*\r\n            risolto triggrerando più azioni da LGraphElement setter\r\n            let dvertexid: Pointer, newdvertex: DGraphElement, olddvertex: DGraphElement;\r\n            for (newdvertex of possibleInconsistencies[subType] as DGraphElement[]){\r\n                const olddvertex: DGraphElement = oldState.idlookup[newdvertex.id] as DGraphElement;\r\n                const notContainedAnymoreOut: Pointer<DGraphElement> = [];\r\n                const newlyInsertedOut: Pointer<DGraphElement>[] = [];\r\n                U.arraySymmetricDifference(olddvertex.subElements, newdvertex.subElements, notContainedAnymoreOut, newlyInsertedOut);\r\n                for (let geid of notContainedAnymoreOut) {\r\n                    const oldge = oldState.idlookup[geid] as DGraphElement;\r\n                    const newge = state.idlookup[geid] as DGraphElement;\r\n                    if (oldge.containedIn === newge.containedIn) continue;\r\n                }\r\n                for (let geid of notContainedAnymoreOut) {\r\n                    const ge = idlookup[geid] as DGraphElement;\r\n                    if (ge.containedIn === context.data.id) set container = context.data.id\r\n                    meglio se sti 2 cicli li fai nel reducer perchè  potrebbe esserci una azione pending che setta il parent = someotherid e qui faccio partire una azione che setta il parent a null, \"annullando\" una azione pending non ancora eseguita\r\n                }\r\n            }\r\n            break;*/\r\n    }\r\n    // if state is updated shallow copy state before returning it\r\n    return state;\r\n}\r\n\r\nlet initialState: DState = null as any;\r\nlet storeLoaded: boolean = false;\r\n\r\nconst UDRegexp = /(?:^|\\s|;|}|\\n|\\t|\\(|,)ret\\s*\\.\\s*[a-zA-Z_$][0-9a-zA-Z_$]*\\s*=/g;\r\n/* tested with:\r\nif (ret.key = stuff) ret.key2=morestuff;\r\n;ret.k=3;\r\n}ret. kk=3,ret. a = 3\r\n\r\nret .b = 3\r\n*/\r\n\r\n\r\n// then add to it: content of props, constants, usageDeclarations\r\n\r\nexport function reducer(oldState: DState = initialState, action: Action): DState {\r\n    try{ return unsafereducer(oldState, action); }\r\n    catch(e) {\r\n        console.error('unhandled error in reducer', {e, oldState, action});\r\n        return oldState;\r\n    }\r\n}\r\n\r\nfunction unsafereducer(oldState: DState = initialState, action: Action): DState {\r\n    const ret = _reducer(oldState, action);\r\n    if (ret === oldState) return oldState;\r\n    ret.idlookup.__proto__ = DPointerTargetable.pendingCreation as any;\r\n    // client synchronization stuff\r\n    if (oldState?.collaborativeSession) {\r\n        const ignoredFields: (keyof DState)[]  = [\r\n            'version',\r\n            'env',\r\n            'debug',\r\n            'isEdgePending',\r\n            'contextMenu',\r\n            '_lastSelected',\r\n            'isLoading',\r\n            'collaborativeSession',\r\n            'VIEWS_RECOMPILE_onDataUpdate',\r\n            'VIEWS_RECOMPILE_onDragStart',\r\n            'VIEWS_RECOMPILE_onDragEnd',\r\n            'VIEWS_RECOMPILE_whileDragging',\r\n            'VIEWS_RECOMPILE_onResizeStart',\r\n            'VIEWS_RECOMPILE_onResizeEnd',\r\n            'VIEWS_RECOMPILE_whileResizing',\r\n            'VIEWS_RECOMPILE_onRotationStart',\r\n            'VIEWS_RECOMPILE_onRotationEnd',\r\n            'VIEWS_RECOMPILE_whileRotating',\r\n            'VIEWS_RECOMPILE_constants',\r\n            'VIEWS_RECOMPILE_usageDeclarations',\r\n            'VIEWS_RECOMPILE_jsxString',\r\n            'VIEWS_RECOMPILE_preconditions',\r\n            'VIEWS_RECOMPILE_jsCondition',\r\n            'VIEWS_RECOMPILE_ocl',\r\n            'VIEWS_RECOMPILE_events',\r\n            'VIEWS_RECOMPILE_all',\r\n            'ClassNameChanged',\r\n            'tooltip',\r\n            'advanced',\r\n            'alert'\r\n        ];\r\n        /* Checking if CompositeAction has some actions that MUST be ignored */\r\n        let compositeAction: CompositeAction|null = null;\r\n        if(action.type === CompositeAction.type) {\r\n            compositeAction = action as CompositeAction;\r\n            const subActions = compositeAction.actions || [];\r\n            compositeAction.actions = subActions.filter(a => !ignoredFields.includes(a.field as keyof DState));\r\n        }\r\n        if(compositeAction && !compositeAction.actions.length) return ret;\r\n        action = (compositeAction) ? compositeAction : action;\r\n        if(action.sender === DUser.current && !ignoredFields.includes(action.field as keyof DState)) {\r\n            const parsedAction: JSON & GObject = JSON.parse(JSON.stringify(action));\r\n            Collaborative.client.emit('pushAction', parsedAction);\r\n        }\r\n    }\r\n\r\n    for (let ptr of ret.ELEMENT_CREATED){\r\n        let d = ret.idlookup[ptr];\r\n        if (!d) continue; // creation rejected, no-op\r\n        switch(d.className){\r\n            default: break;\r\n            case \"DViewElement\":\r\n                for(let nid in transientProperties.node){\r\n                    let tn = transientProperties.node[nid];\r\n                    tn.viewScores[d.id as any] = {} as any;\r\n                }\r\n        }\r\n    }\r\n    ret.ELEMENT_CREATED = [];\r\n    for (let ptr of ret.ELEMENT_DELETED){\r\n        let d = oldState.idlookup[ptr];\r\n        if (!d) continue; // already deleted, no-op\r\n        switch(d.className){\r\n            default: break;\r\n            case \"DViewElement\":\r\n                for (let nid in transientProperties.node) {\r\n                    let tn = transientProperties.node[nid];\r\n                    // delete tn.stackViews; // trigger recalc of all scores.\r\n                    delete tn.viewScores[d.id as any];\r\n                    tn.needSorting = true;\r\n                }\r\n        }\r\n    }\r\n    ret.ELEMENT_DELETED = [];\r\n\r\n    if (ret.VIEWS_RECOMPILE_all === true) ret.VIEWS_RECOMPILE_all = Object.keys(ret.idlookup);\r\n    if ((ret.VIEWS_RECOMPILE_all as Pointer[])?.length) {\r\n        let resetAllNodes: boolean = false;\r\n        let sk: keyof DState;\r\n        for (let id of new Set(ret.VIEWS_RECOMPILE_all as Pointer[])){\r\n            let d = ret.idlookup[id];\r\n            if (!d) continue;\r\n            if (RuntimeAccessibleClass.extends(d.className, \"DViewElement\")) {\r\n                (d as DViewElement).css_MUST_RECOMPILE = true;\r\n                transientProperties.view[d.id as string] = { } as any;\r\n                // for (let k of DViewElement.MeasurableKeys) (ret as any)['VIEWS_RECOMPILE_'+k].push(d.id);\r\n                // for (let k of DViewElement.RecompileKeys) (ret as any)['VIEWS_RECOMPILE_'+k].push(d.id);\r\n                for (sk in ret) if (sk.indexOf('VIEWS_RECOMPILE') === 0) (ret[sk] as Pointer[]).push(id);\r\n                // ret.NODES_RECOMPILE_labels.push(id); ret.NODES_RECOMPILE_longestLabel.push(id);\r\n                if (!resetAllNodes) resetAllNodes = true;\r\n            }\r\n            if (RuntimeAccessibleClass.extends(d.className, \"DModelElement\")) {\r\n                if (d.className === \"DClass\") {\r\n                    let oldname = (oldState.idlookup[d.id] as DClass)?.name;\r\n                    let newname = (ret.idlookup[d.id] as DClass)?.name;\r\n                    if (oldname !== newname) ret.ClassNameChanged[d.id as Pointer<DClass>] = oldname;\r\n                }\r\n                for (sk in ret) if (sk.indexOf('MODELS_RECOMPILE') === 0) (ret[sk] as Pointer[]).push(id);\r\n                // transientProperties.modelElement[d.id] = { } as any; stuff in here does not need replacement, can never be dangerous (currently).\r\n            }\r\n            if (RuntimeAccessibleClass.extends(d.className, \"DGraphElement\")) {\r\n                transientProperties.node[d.id as string] = { } as any;\r\n                for (sk in ret) if (sk.indexOf('NODES_RECOMPILE') === 0) (ret[sk] as Pointer[]).push(id);\r\n                //ret.NODES_RECOMPILE_labels.push(id); ret.NODES_RECOMPILE_longestLabel.push(id);\r\n            }\r\n        }\r\n        if (resetAllNodes) for (let nid in transientProperties.node) {\r\n            transientProperties.node[nid] = {} as any;\r\n            for (sk in ret) if (sk.indexOf('NODES_RECOMPILE') === 0) (ret[sk] as Pointer[]).push(nid);\r\n            //ret.NODES_RECOMPILE_labels.push(id); ret.NODES_RECOMPILE_longestLabel.push(id);\r\n        }\r\n    }\r\n    ret.VIEWS_RECOMPILE_all = [];\r\n\r\n\r\n\r\n    function parseLabel(ptr: Pointer, key: \"labels\" | \"longestLabel\", isNode: boolean): boolean{\r\n        let dv: GObject<DViewElement | DGraphElement> = DPointerTargetable.fromPointer(ptr, ret);\r\n        let tp: NodeTransientProperties | ViewTransientProperties = ((isNode ? transientProperties.node : transientProperties.view) as GObject)[ptr];\r\n        if (!tp) ((isNode ? transientProperties.node : transientProperties.view) as GObject)[ptr] = tp = {} as any;\r\n        let val: string = dv[key];\r\n        if (!val) { tp[key] = undefined as any; return true; }\r\n        if (typeof val === \"function\") { tp[key] = val; return true; }\r\n        let allContextKeys = {...contextFixedKeys};\r\n        let vid: Pointer<DViewElement> = isNode ? (tp as NodeTransientProperties).mainView?.id : ptr as any;\r\n        if (!vid) return false; // leave pending & recompute them on next reducer action\r\n        let tv = transientProperties.view[vid];\r\n        for (let k of tv.constantsList) if (!allContextKeys[k]) allContextKeys[k] = true;\r\n        for (let k of tv.UDList) if (!allContextKeys[k]) allContextKeys[k] = true;\r\n        let paramStr = '{'+Object.keys(allContextKeys).join(',')+'}';\r\n        console.log('labels parse', { allContextKeys, ud:tv.UDList, c:tv.constantsList });\r\n        const body: string =  'return (' + val + ')';\r\n        // if (vid.includes('Model')) console.log(\"modelparse, laels\", {paramStr, body});\r\n        console.log('labels parse', {vid: ptr, paramStr, body});\r\n        try {\r\n            if (isNode) {\r\n                // need to store the function in tnv instead of tn since if v changes, ud changes as well? in all of them?what if i make a new view?\r\n            }\r\n            else {\r\n                // tp[key] = new Function(paramStr, body) as ((...a: any) => any);\r\n            }\r\n            tp[key] = function(){ return 'label as an option is disabled, pass it through props instead.'; }\r\n        }\r\n        catch (e: any) {\r\n            /*try{\r\n                let try_to_get_better_error = eval(\"let __f = function(\" + paramStr+\") {\\n\" + body + \"}\");\r\n            } catch(eeval){\r\n                console.error(\"eval error same as func error\", {e, eeval});\r\n                e = eeval;\r\n            }*/\r\n            console.error('error labels parse', {vid: ptr, e, paramStr, body});\r\n            tp[key] = val;// (context: GObject) => 'Error during label evaluation';\r\n        }\r\n        return true;\r\n        // implies recompilation of: ... nothing?\r\n    }\r\n    let arr: Pointer<any>[]\r\n    arr = ret.NODES_RECOMPILE_labels;\r\n    if (arr.length) {\r\n        let successfullyParsed: Dictionary<string, boolean> = {};\r\n        for (const id of new Set(arr)) successfullyParsed[id] = parseLabel(id, 'labels', true);\r\n        ret.NODES_RECOMPILE_labels = arr.filter(e => !successfullyParsed[e]);\r\n    }\r\n    arr = ret.NODES_RECOMPILE_longestLabel;\r\n    if (arr.length) {\r\n        let successfullyParsed: Dictionary<string, boolean> = {};\r\n        for (const id of new Set(arr)) successfullyParsed[id] = parseLabel(id, 'longestLabel', true);\r\n        ret.NODES_RECOMPILE_longestLabel = arr.filter(e => !successfullyParsed[e]);\r\n    }\r\n    arr = ret.VIEWS_RECOMPILE_labels;\r\n    if (arr.length) {\r\n        let successfullyParsed: Dictionary<string, boolean> = {};\r\n        for (const id of new Set(arr)) successfullyParsed[id] = parseLabel(id, 'labels', false);\r\n        ret.VIEWS_RECOMPILE_labels = arr.filter(e => !successfullyParsed[e]);\r\n    }\r\n    arr = ret.VIEWS_RECOMPILE_longestLabel;\r\n    if (arr.length) {\r\n        let successfullyParsed: Dictionary<string, boolean> = {};\r\n        for (const id of new Set(arr)) successfullyParsed[id] = parseLabel(id, 'longestLabel', false);\r\n        ret.VIEWS_RECOMPILE_longestLabel = arr.filter(e => !successfullyParsed[e]);\r\n    }\r\n\r\n    // local changes to out-of-redux stuff\r\n    if (ret.VIEWS_RECOMPILE_ocl.length) {\r\n        // for (let gid of ret.graphs) Selectors.updateViewMatchings(gid, ret.modelElements, Object.values(ret.idlookup).map( d => RuntimeAccessibleClass.extends(d, DModelElement.cname)));\r\n        // for (let vid of ret.VIEW_APPLIABLETO_NEEDS_RECALCULATION) { }\r\n        for (let vid of new Set(ret.VIEWS_RECOMPILE_ocl)) {\r\n            if (!transientProperties.view[vid]) transientProperties.view[vid] = {} as any;\r\n            transientProperties.view[vid].oclEngine = undefined as any; // force re-parse\r\n            transientProperties.view[vid].oclChanged = true;\r\n            for (let nid in transientProperties.node) {\r\n                let tnv = transientProperties.node[nid].viewScores[vid];\r\n                if (tnv?.OCLScore !== ViewEClassMatch.NOT_EVALUATED_YET) tnv.OCLScore = ViewEClassMatch.NOT_EVALUATED_YET as any as boolean;\r\n            }\r\n        }\r\n        ret.VIEWS_RECOMPILE_ocl = [];\r\n    }\r\n    /*\r\n    if (ret.VIEWOCL_UPDATE_NEEDS_RECALCULATION.length) {\r\n        // not implemented for now\r\n        ret.VIEWOCL_UPDATE_NEEDS_RECALCULATION = [];\r\n    }*/\r\n\r\n    if (ret.VIEWS_RECOMPILE_preconditions.length) {\r\n        for (let vid of new Set(ret.VIEWS_RECOMPILE_preconditions)) {\r\n            for (let nid in transientProperties.node) {\r\n                let tnv = transientProperties.node[nid].viewScores[vid];\r\n                if (tnv?.metaclassScore !== ViewEClassMatch.NOT_EVALUATED_YET) tnv.metaclassScore = ViewEClassMatch.NOT_EVALUATED_YET as any as number;\r\n            }\r\n        }\r\n        ret.VIEWS_RECOMPILE_preconditions = [];\r\n    }\r\n\r\n    if (ret.VIEWS_RECOMPILE_constants?.length)\r\n    for (const vid of new Set(ret.VIEWS_RECOMPILE_constants)) { // compiled in func, and executed, result does not vary between nodes.\r\n        let dv: DViewElement = DPointerTargetable.fromPointer(vid, ret);\r\n        // transientProperties.view[vid].constantsList = dv.constants?.match(UDRegexp).map(s=>s.substring(4, s.length-1).trim()) || [];\r\n        // let allContextKeys = {...contextFixedKeys};\r\n        if (!dv.constants) {\r\n            if (!transientProperties.view[vid]) transientProperties.view[vid] = {} as any;\r\n            transientProperties.view[vid].constants = {};\r\n            transientProperties.view[vid].constantsList = [];\r\n            // no need to recompile UD, jsx or measurables, they will have additional parameters in scope but they are undefined and cause no problems.\r\n            continue;\r\n        }\r\n        const constantsOutput: GObject = {};\r\n        const context = {view:dv}; // context at this point holds only static stuff, which are in gloval scope (window) plus view.\r\n        let paramStr = '{'+Object.keys(context).join(',')+'}, ret';\r\n        try {\r\n            // the scope of new Function() is \"window\" and not the function where is called, unlike eval();\r\n            let constantsFunction: (context: GObject, ret: GObject) => void = new Function(paramStr, 'return ('+dv.constants+')(ret)').bind(context);\r\n            constantsFunction(context, constantsOutput);\r\n        } catch(e:any){\r\n            console.error('error constants parse', {vid, e, paramStr, body:'return ('+dv.constants+')(ret)'});\r\n            // todo: how do i render an error from here? even if i set jsx or ud.__invalidDeclarations it will be recompiled. need a constants.__invalidDeclarations too?\r\n        }\r\n\r\n        transientProperties.view[vid].constants = constantsOutput;\r\n        transientProperties.view[vid].constantsList = Object.keys(transientProperties.view[vid].constants);\r\n        // implies recompilation of: jsCondition, ud, jsx and all measurable events\r\n        ret.VIEWS_RECOMPILE_jsCondition.push(vid);\r\n        ret.VIEWS_RECOMPILE_usageDeclarations.push(vid);\r\n        ret.VIEWS_RECOMPILE_jsxString.push(vid);\r\n        ret.VIEWS_RECOMPILE_events.push(vid);\r\n        for (let k of DViewElement.MeasurableKeys) (ret as any)['VIEWS_RECOMPILE_'+k].push(vid);\r\n    }\r\n    ret.VIEWS_RECOMPILE_constants = [];\r\n\r\n    if (ret.VIEWS_RECOMPILE_usageDeclarations?.length)\r\n    for (const vid of new Set(ret.VIEWS_RECOMPILE_usageDeclarations)) { // compiled in func, but NOT executed, result varies between nodes.\r\n        let dv: DViewElement = DPointerTargetable.fromPointer(vid, ret);\r\n        let tv = transientProperties.view[vid];\r\n        if (!tv) transientProperties.view[vid] = tv = {} as any;\r\n        if (!dv.usageDeclarations) {\r\n            tv.UDList = [];\r\n            tv.UDFunction = undefined as any;\r\n            // no need to recompile jsx or measurables, they will have additional parameters in scope but they are undefined and cause no problems.\r\n            continue;\r\n        }\r\n        let matches = dv.usageDeclarations?.match(UDRegexp) || [];\r\n        transientProperties.view[vid].UDList = matches.map(s=>{ s = s.trim(); return s.substring(s.indexOf('\\.')+1, s.length-2).trim()});\r\n        // warning for user: do not redeclare ret in nested blocks.\r\n        // do not use ret[key] syntax.\r\n        // do not set nested values directly (ret.key.subkey syntax).\r\n        // do not use ret.key +=, -= or any other operator assignment different than \"=\"\r\n        // if that is ever required, do instead\r\n        // do not assign values to ret in block comments\r\n        // those restrictions only apply to the ret object, all those violations can be done on other objects.\r\n        // so the following is valid, and a way to overcome the previous limitations:\r\n        // let subobject = {}; subobject[key] += stuff; ret.somefixedname = subobject;\r\n\r\n        let allContextKeys: Dictionary = {...contextFixedKeys};\r\n        for (let k of tv.constantsList) if (!allContextKeys[k]) allContextKeys[k] = true;\r\n        let paramStr = '{'+Object.keys(allContextKeys).join(',')+'}, ret';\r\n        if (vid.includes('Model')) console.log(\"modelparse, ud\", {paramStr, udstr:dv.usageDeclarations, udlist:transientProperties.view[vid].UDList});\r\n        try {\r\n            tv.UDFunction = new Function(paramStr, 'return ('+dv.usageDeclarations+')(ret)') as (...a:any)=>any;\r\n        } catch (e:any) {\r\n            // problem: errors cannot be serialized in any way? they have no keys. let strerr = JSON.stringify(e); //(e.message || '').split('\\n')[0]);\r\n            let udErrors: GObject =  windoww.udErrors;\r\n            if (!windoww.udErrors) windoww.udErrors = udErrors = {maxi: 0};\r\n            udErrors[\"e\"+(++udErrors.maxi)] = e;\r\n            e.isSyntax = true;\r\n            let errbody = \"ret.__invalidUsageDeclarations = window.udErrors.e\"+udErrors.maxi+\"; return ret;\";\r\n            console.error('error udparse', {vid, e, paramStr, body: 'return ('+dv.usageDeclarations+')(ret)', errbody});\r\n            tv.UDFunction = new Function(\"unusedContext, ret\", errbody) as (...a:any)=>any;\r\n        }\r\n\r\n\r\n        // implies recompilation of: jsx and all measurable events\r\n        ret.VIEWS_RECOMPILE_jsxString.push(vid);\r\n        ret.VIEWS_RECOMPILE_events.push(vid);\r\n        for (let k of DViewElement.MeasurableKeys) (ret as any)['VIEWS_RECOMPILE_'+k].push(vid);\r\n    }\r\n    ret.VIEWS_RECOMPILE_usageDeclarations = [];\r\n\r\n    if (ret.VIEWS_RECOMPILE_events.length) {\r\n        // for (let gid of ret.graphs) Selectors.updateViewMatchings(gid, ret.modelElements, Object.values(ret.idlookup).map( d => RuntimeAccessibleClass.extends(d, DModelElement.cname)));\r\n        // for (let vid of ret.VIEW_APPLIABLETO_NEEDS_RECALCULATION) { }\r\n        for (let entry of new Set(ret.VIEWS_RECOMPILE_events)) {\r\n            let vid: string;\r\n            let dv: DViewElement;\r\n            let keys: string[];\r\n            if (typeof entry === \"object\") {\r\n                vid = entry.vid;\r\n                dv = DPointerTargetable.fromPointer(vid, ret);\r\n                keys = entry.keys || Object.keys(dv.events);\r\n            }\r\n            else {\r\n                vid = entry;\r\n                dv = DPointerTargetable.fromPointer(vid, ret);\r\n                keys = Object.keys(dv.events);\r\n            }\r\n            let tv = transientProperties.view[vid];\r\n            if (!tv) transientProperties.view[vid] = tv = {} as any;\r\n            if (!tv.events) tv.events = {};\r\n            // if (!tv.events_raw) tv.events_raw = {};\r\n            for (let key of keys) {\r\n                if (!key) { delete tv.events[key]; continue; }\r\n                let allContextKeys = {...contextFixedKeys};\r\n                for (let k of transientProperties.view[vid].constantsList) if (!allContextKeys[k]) allContextKeys[k] = true;\r\n                for (let k of transientProperties.view[vid].UDList) if (!allContextKeys[k]) allContextKeys[k] = true;\r\n                let paramStr = '{'+Object.keys(allContextKeys).join(',')+'}, ..._params';\r\n                // dv.events[key] = (...params)=> code\r\n                const body: string = 'return (' +dv.events[key]+')(..._params)';\r\n                // if (vid.includes('Model')) console.log(\"modelparse, jsx\", {paramStr, body});\r\n                try {\r\n                    tv.events[key] = new Function(paramStr, body) as ((...a:any[])=>any);\r\n                    // tv.events_raw[key] = new Function(paramStr, body) as ((...a:any)=>any);\r\n                    // attempt to auto obtain node context\r\n                    // impossile with view.event.name\r\n                    // could with node.event.name if node.get_event sets a current node thing__, no he must wrap the func!! in the getter\r\n                    // tv.events[key] = (..._params2:any) => { return tv.events_raw[key](context, ..._params2) };\r\n                }\r\n                catch (e: any) {\r\n                    console.error('error jsxparse', {vid, e, paramStr, body});\r\n                    tv.events[key] = (context) => Log.ee(\"failed to parse function body: \" + e.message.split(\"\\n\")[0], e.message);\r\n                }\r\n            }\r\n        }\r\n        ret.VIEWS_RECOMPILE_events = [];\r\n        // triggers recompile of nothing\r\n    }\r\n\r\n    if (ret.VIEWS_RECOMPILE_jsCondition?.length)\r\n    for (const vid of new Set(ret.VIEWS_RECOMPILE_jsCondition)) {\r\n        const dv: DViewElement = DPointerTargetable.fromPointer(vid, ret);\r\n        let tv = transientProperties.view[vid];\r\n        if (!tv) transientProperties.view[vid] = tv = {} as any;\r\n        tv.jsConditionChanged = true;\r\n        if (!dv.jsCondition) {\r\n            tv.jsCondition = undefined;\r\n            continue;\r\n        }\r\n        const lines = dv.jsCondition.trim().split('\\n');\r\n        let lastLine = lines[lines.length - 1];\r\n        if (lastLine.indexOf('return') !== 0) lines[lines.length - 1] = `return (${lastLine})`;\r\n\r\n\r\n        if (!dv.jsxString) { transientProperties.view[vid].JSXFunction = undefined as any; continue; }\r\n        let allContextKeys = {...contextFixedKeys};\r\n        for (let k of transientProperties.view[vid].constantsList) if (!allContextKeys[k]) allContextKeys[k] = true;\r\n\r\n        let paramStr = '{'+Object.keys(allContextKeys).join(',')+'}';\r\n        const body = lines.join('\\n');\r\n        try {\r\n            tv.jsCondition = new Function(paramStr, body) as ((...a:any)=>any);\r\n        } catch (e) {\r\n            tv.jsCondition = undefined;\r\n            console.log('JS Condition parsed error', e);\r\n        }\r\n    }\r\n    ret.VIEWS_RECOMPILE_jsCondition = [];\r\n\r\n\r\n    if (ret.VIEWS_RECOMPILE_jsxString?.length)\r\n    for (const vid of new Set(ret.VIEWS_RECOMPILE_jsxString)) { // compiled in func, but NOT executed, result varies between nodes.\r\n        let dv: DViewElement = DPointerTargetable.fromPointer(vid, ret);\r\n        let tv = transientProperties.view[vid];\r\n        if (!tv) transientProperties.view[vid] = tv = {} as any;\r\n        if (!dv.jsxString) { transientProperties.view[vid].JSXFunction = undefined as any; continue; }\r\n        let allContextKeys = {...contextFixedKeys};\r\n        for (let k of transientProperties.view[vid].constantsList) if (!allContextKeys[k]) allContextKeys[k] = true;\r\n        for (let k of transientProperties.view[vid].UDList) if (!allContextKeys[k]) allContextKeys[k] = true;\r\n        let paramStr = '{'+Object.keys(allContextKeys).join(',')+'}';\r\n\r\n        const body: string =  'return (' + UX.parseAndInject(DSL.parser(dv.jsxString), dv) + ')';\r\n        // if (vid.includes('Model')) console.log(\"modelparse, jsx\", {paramStr, body});\r\n        try {\r\n            transientProperties.view[vid].JSXFunction = new Function(paramStr, body) as ((...a: any) => any);\r\n        }\r\n        catch (e: any) {\r\n            /*try{\r\n                let try_to_get_better_error = eval(\"let __f = function(\" + paramStr+\") {\\n\" + body + \"}\");\r\n            } catch(eeval){\r\n                console.error(\"eval error same as func error\", {e, eeval});\r\n                e = eeval;\r\n            }*/\r\n            console.error('error jsxparse', {vid, e, paramStr, body});\r\n            transientProperties.view[vid].JSXFunction = (context) => GraphElementComponent.displayError(e, 'JSX Syntax', dv);\r\n        }\r\n        // implies recompilation of: ... nothing?\r\n    }\r\n    ret.VIEWS_RECOMPILE_jsxString = [];\r\n\r\n\r\n\r\n    for (const key of DViewElement.MeasurableKeys) {\r\n        if ((ret as any)['VIEWS_RECOMPILE_'+key]?.length)\r\n        for (let vid of new Set((ret as any)['VIEWS_RECOMPILE_'+key]) as any) {\r\n            let dv: DViewElement = DPointerTargetable.fromPointer(vid, ret);\r\n            let tv = transientProperties.view[vid];\r\n            if (!tv) transientProperties.view[vid] = tv = {} as any;\r\n            let str: string = (dv as any)[key];\r\n            if (!str) {\r\n                (transientProperties.view[vid] as any)[key] = undefined;\r\n                continue;\r\n            }\r\n            let allContextKeys = {...contextFixedKeys};\r\n            for (let k of transientProperties.view[vid].constantsList) if (!allContextKeys[k]) allContextKeys[k] = true;\r\n            for (let k of transientProperties.view[vid].UDList) if (!allContextKeys[k]) allContextKeys[k] = true;\r\n            let paramStr = '{'+Object.keys(allContextKeys).join(',')+'}';\r\n            console.log('measurable parse '+key, {allContextKeys, ud:transientProperties.view[vid].UDList, c:transientProperties.view[vid].constantsList });\r\n            console.log('measurable parse '+key, {vid, paramStr, body:str});\r\n            try {\r\n                (transientProperties.view[vid] as any)[key] = new Function(paramStr, str);\r\n            }\r\n            catch (e: any) {\r\n                console.error('error measurable parse '+key, {vid, e, paramStr, body:str});\r\n                (transientProperties.view[vid] as any)[key] = undefined;\r\n                // display error in jsx\r\n                transientProperties.view[vid].JSXFunction = (context) => GraphElementComponent.displayError(e, 'Measurable ' + key + ' Syntax', dv);\r\n                break;\r\n            }\r\n        }\r\n        (ret as any)['VIEWS_RECOMPILE_'+key] = [];\r\n    }\r\n\r\n    for (let dataid in ret.ClassNameChanged) {\r\n        if (dataid === 'clonedCounter') continue;\r\n        // NB: if i ever want to access a constructor's other properties in ocl, like \"context Persona inv: self.$somecounter === Persona.instances.length\",\r\n        // i would need to update this every time a DClass property changes instead of only when name changes.\r\n\r\n        // if it's first creation of a modelpiece\r\n        if (!transientProperties.modelElement[dataid]) {\r\n            transientProperties.modelElement[dataid] = {nodes: {}};\r\n        }\r\n        // update ocl type names\r\n        let data: DClass = ret.idlookup[dataid] as DClass;\r\n        RuntimeAccessibleClass.makeOCLConstructor(data, ret, oldState);\r\n        // here i should reset all tnv.oclEngine too and set all ocl scores to notevaluated, but it is too computationally heavy\r\n        // and it's useful to keep the old ocl condition valid with past names until manually edited.\r\n    }\r\n    ret.ClassNameChanged = {};\r\n\r\n    return ret;\r\n\r\n}\r\n\r\nexport function _reducer/*<S extends StateNoFunc, A extends Action>*/(oldState: DState = initialState, action: Action): DState{\r\n    let times: number;\r\n    let state: DState;\r\n    let removedDeltas: (GObject | undefined)[] = [];\r\n    switch (action.type) {\r\n        case UndoAction.type:\r\n            times = action.value;\r\n            state = oldState;\r\n            Log.exDev(times<=0, \"undo must be positive\", action);\r\n            while (times--) {\r\n                const delta = statehistory[DUser.current].undoable.pop();\r\n                removedDeltas.push(delta);\r\n                state = undo(state, delta);\r\n            }\r\n            state.VIEWS_RECOMPILE_all = removedDeltas.flatMap( d => Object.keys(d?.idlookup||{}));\r\n            // state.VIEWS_RECOMPILE_all = true;\r\n            return state;\r\n\r\n        case RedoAction.type:\r\n            times = action.value;\r\n            state = oldState;\r\n            Log.exDev(times<=0, \"redo must be positive\", action);\r\n            while (times--) {\r\n                const delta = statehistory[DUser.current].redoable.pop();\r\n                removedDeltas.push(delta);\r\n                state = undo(state, delta, false);\r\n            }\r\n            state.VIEWS_RECOMPILE_all = removedDeltas.flatMap( d => Object.keys(d?.idlookup||{}));\r\n            // state.VIEWS_RECOMPILE_all = true;\r\n            return state;\r\n        // case CombineHistoryAction.type: return combineHistory(oldState); break;\r\n        // todo: se al posto di \"annullare l'undo\" memorizzo l'azione e la rieseguo, posso ripetere l'ultimo passo N volte e questa azione diventa utile per combinare passi e ripetere blocchi di azioni assieme\r\n        default:\r\n            let ret = doreducer(oldState, action);\r\n            if (ret === oldState) return ret;\r\n            // statehistory[DUser.current].redoable = [];   <-- Moved to stateInitializer()\r\n            let delta =  U.objectDelta(ret, oldState);\r\n            if (!filterundoableactions(delta)) return ret;\r\n            // console.log(\"setting undoable action:\", {ret, oldState0:{...oldState}, oldState, delta});\r\n            if (oldState !== null) statehistory[DUser.current].undoable.push(delta);\r\n            return ret;\r\n    }\r\n}\r\n\r\nfunction filterundoableactions(delta: Partial<DState>): boolean {\r\n    if (!statehistory.globalcanundostate) return false;\r\n    if (Object.keys(delta).length === 1) {\r\n        if (\"dragging\" in delta) return false;\r\n        if (\"_lastSelected\" in delta) return false;\r\n        if (\"contextMenu\" in delta) return false;\r\n    }\r\n    return true;\r\n}\r\nfunction undo(state: DState, delta: GObject | undefined, isundo = true): DState {\r\n    if (!delta) return state;\r\n    let undonestate: DState = {...state} as DState;\r\n    //   controlla se vengono shallow-copied solo e tutti gli oggetti nested lungo la catena del percorso delle modifiche\r\n    //   es: root.a.b.c=3 + root.a.b.d=3 = 4+1 modifiche, 5 shallow copies including the root\r\n    undorecursive(delta, undonestate);\r\n    if (isundo) statehistory[DUser.current].redoable.push( U.objectDelta(undonestate, state) ); // reverses from undo to redo and viceversa swapping arguments, so the target result after appliying the delta changes\r\n    else statehistory[DUser.current].undoable.push( U.objectDelta(undonestate, state) ); // redo is \"undoing an undo\", reversing his changes just like an undo reverses an ordinary action changes.\r\n    return undonestate;\r\n}\r\n\r\nfunction undorecursive(deltalevel: GObject, statelevel: GObject): void {\r\n    // statelevel = {...statelevel}; not working if i do it here, just a new var. first time copy id done in caller func undo(). recursive copies are done before recursive step\r\n    for (let key in deltalevel) {\r\n        let delta = deltalevel[key];\r\n        console.log(\"undoing\", {delta, key, deltalevel, statelevel})\r\n        if (key.indexOf(\"_-\") === 0) { delete statelevel[key.substring(2)]; continue; }\r\n        if (typeof delta === \"object\") {\r\n        // if (U.isObject(delta, false, false, true)) {\r\n            statelevel[key] = {...statelevel[key]};\r\n            undorecursive(deltalevel[key], statelevel[key]); }\r\n        else { statelevel[key] = delta; }\r\n    }\r\n}\r\n\r\nfunction doreducer/*<S extends StateNoFunc, A extends Action>*/(oldState: DState = initialState, action: Action): DState{\r\n    if (!oldState) { oldState = initialState = DState.new(); }\r\n    let ca: CompositeAction;\r\n    // console.log('external REDUCER', {action, CEtype:CreateElementAction.type});\r\n    if (!storeLoaded) {\r\n        // new SetRootFieldAction('forceinit', true);\r\n        storeLoaded = true;\r\n    }\r\n    if (!(oldState as any).forceinit) {\r\n        // afterStoreLoad();\r\n        // new SetRootFieldAction('forceinit', true);\r\n    } //  setTimeout(afterStoreLoad, 1);\r\n    switch (action.type) {\r\n        case CompositeAction.type: ca = action as CompositeAction; break;\r\n        case LoadAction.type:\r\n        default:\r\n            if (action.type.indexOf('@@redux/') === 0) {\r\n                //storeLoaded = true;\r\n                return oldState;\r\n            }\r\n            ca = new CompositeAction([action], false);\r\n            break;\r\n    }\r\n    let ret = CompositeActionReducer(oldState, ca);\r\n    /*if (state.current !== ret) {\r\n        state.current = ret;\r\n        state.past.push(ret);\r\n    }*/\r\n    return ret;\r\n}\r\nfunction setSubclasses(roots: orArr<typeof RuntimeAccessibleClass>){\r\n    RuntimeAccessibleClass.extendMatrix =\r\n        new SimpleTree<(typeof RuntimeAccessibleClass)>(roots, \"subclasses\")\r\n            .getiIsSubElementMatrix(\"cname\");\r\n    /*\r\n    let tree = new TreeModel({\r\n        childrenPropertyName: \"subclasses\"\r\n    });\r\n    for (let key in dict){\r\n        let constructor = dict[key];\r\n        if(!constructor.hasOwnProperty(\"subclasses\")) constructor.subclasses = [];\r\n    }\r\n    RuntimeAccessibleClass.extendTree = (tree as any).safe_parse(RuntimeAccessibleClass);*/\r\n}\r\n// windoww.TreeModel = TreeModel;\r\nfunction buildLSingletons(alld: Dictionary<string, typeof DPointerTargetable>, alll: Dictionary<string, typeof LPointerTargetable>) {\r\n    for (let dname in alld) {\r\n        switch (dname) {\r\n            case \"DeleteElementAction\": continue;\r\n            case \"DV\": continue;\r\n            case \"Debug\": continue;\r\n            default: break;\r\n        }\r\n        if ((dname[1] || \"\").toLowerCase() === dname[1]) continue; // if second letter is lowercase, it's not a \"D\" class\r\n        let tagless = dname.substring(1);\r\n        let d = alld[dname];\r\n        let l = alll['L'+tagless];\r\n        if (!d||!l) console.error(\"missing d constructor\", {d, l});\r\n        d.logic = l;\r\n        if (!l) console.error('init() could not find L-class during mapping', l, d);\r\n        // @ts-ignore\r\n        d.singleton = new l('dwc');\r\n        d.structure = d;\r\n\r\n        l.logic = d.logic;\r\n        l.singleton = d.singleton;\r\n        l.structure = d.structure;\r\n\r\n        // if (!d.subclasses) d.subclasses = [];\r\n        // @ts-ignore\r\n        // for (let sc of d.subclasses) { if (!sc[\"_extends\"]) sc[\"_extends\"] = [];  sc[\"_extends\"].push(d); }\r\n    }\r\n}\r\nfunction setDocumentEvents(){\r\n    // do not use typings or class constructors here or it will change import order\r\n    setTimeout(\r\n        ()=> $(document).on(\"mouseup\",\r\n            (e: MouseUpEvent) => RuntimeAccessibleClass.get<typeof GraphDragManager>(\"GraphDragManager\").stopPanning(e)),\r\n        // ()=> $(document).on(\"mouseup\", (e: MouseUpEvent) => (window as any).GraphDragManager.stopPanning(e)), //a\r\n        1\r\n    );\r\n    // document.body.addEventListener(\"mousedown\", fixResizables, false);\r\n}\r\nfunction fixResizables(e: MouseEvent){\r\n    /*let parents = U.ancestorArray(e.target as HTMLElement);\r\n    for (let e of parents){\r\n        if (e.classList.contains(\"draggable\")) U.makeDraggable(e, e.dataset.draggableOptions, e.attributes.disabled);\r\n        if (e.classList.contains(\"resizable\")) U.makeResizable(e, e.dataset.draggableOptions);\r\n        if (e.classList.contains(\"resizable\")) U.makeRotatable(e, e.dataset.draggableOptions);\r\n    }*/\r\n}\r\n\r\nexport async function stateInitializer() {\r\n    RuntimeAccessibleClass.fixStatics();\r\n    let dClassesMap: Dictionary<string, typeof DPointerTargetable> = {};\r\n    let lClassesMap: Dictionary<string, typeof LPointerTargetable> = {};\r\n    for (let name in RuntimeAccessibleClass.classes) {\r\n        switch(name[0]) {\r\n            case 'D': dClassesMap[name] = RuntimeAccessibleClass.classes[name] as typeof DPointerTargetable; break;\r\n            case 'L': lClassesMap[name] = RuntimeAccessibleClass.classes[name] as typeof LPointerTargetable; break;\r\n            default: break;\r\n        }\r\n    }\r\n\r\n    buildLSingletons(dClassesMap, lClassesMap);\r\n    setSubclasses(RuntimeAccessibleClass.get('DPointerTargetable'));\r\n    windoww.defaultContext = {$: windoww.$, getPath, React: React, Selectors, ...RuntimeAccessibleClass.getAllClassesDictionary(), ...windoww.Components};\r\n\r\n    setDocumentEvents();\r\n\r\n    DState.init();\r\n    const user = Storage.read<DUser>('user');\r\n    if(user) {\r\n        DUser.new(user.name, user.surname, user.nickname, user.affiliation, user.country, user.newsletter, user.email, user.token, user.id);\r\n        DUser.current = user.id;\r\n        statehistory[user.id] = {redoable: [], undoable: []};\r\n        await ProjectsApi.getAll();\r\n    } else DUser.current = '';\r\n\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}