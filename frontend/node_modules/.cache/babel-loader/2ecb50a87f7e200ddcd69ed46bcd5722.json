{"ast":null,"code":"var _jsxFileName = \"C:\\\\d\\\\Programming\\\\web\\\\jodel-mde\\\\src\\\\components\\\\forEndUser\\\\Measurable.tsx\",\n  _dec,\n  _class,\n  _class2;\nimport React, { Component } from \"react\";\nimport { DGraphElement, Log, RuntimeAccessible, Size, TRANSACTION, U } from \"../../joiner\";\nimport $ from \"jquery\";\n\n// todo\n\n// private\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nexport let MeasurableComponent = (_dec = RuntimeAccessible('MeasurableComponent'), _dec(_class = (_class2 = class MeasurableComponent extends Component {\n  constructor() {\n    super(...arguments);\n    this.html = null;\n    this.$html = void 0;\n    this.dragOptionsChanged = true;\n    this.resizeOptionsChanged = true;\n    this.rotateOptionsChanged = true;\n    this.defaultOptions = {\n      draggable: {\n        cursor: 'grabbing',\n        // containment: 'parent',\n        distance: 5\n        // helper: 'clone', // 'original' or 'csselector'? or func=>html\n        // disabled: !(view.draggable),}\n      },\n      resizable: {},\n      rotatable: {}\n    };\n    this.oldPos = {\n      left: 0,\n      top: 0\n    };\n  }\n  componentDidMount() {\n    this.afterUpdate();\n  }\n  componentDidUpdate(prevProps, prevState, snapshot) {\n    this.afterUpdate();\n  }\n  absoluteToTransform(e, evt, evtkind) {\n    let x = e.style.left;\n    let y = e.style.top; /*\r\n                         e.style.left = '0px';\r\n                         e.style.top = '0px';*/\n    //e.style.position = 'unset';\n    e.style.transform = `translate(${x}, ${y})`;\n  }\n  afterUpdate() {\n    if (!this.html) return;\n    this.$html = $(this.html);\n    if (this.dragOptionsChanged) {\n      this.afterUpdateSingle(\"draggable\");\n    }\n    if (this.resizeOptionsChanged) {\n      this.afterUpdateSingle(\"resizable\");\n    }\n    if (this.rotateOptionsChanged) {\n      this.afterUpdateSingle(\"rotatable\");\n    }\n  }\n  afterUpdateSingle(type) {\n    if (this.props.draggable) this.afterUpdateDraggable();\n  } /*\r\n    afterUpdateDraggable_single_old(): void{\r\n       nope, erase this and just make the previous _old genericversion with inner dynamic functions called 9 times like event('drag', 'while'); event('drag', 'end'); event('resize', 'while');...\r\n       make and extract new functions from code so that it dinamically build the jqui options object\r\n       if (!this.$html) return;\r\n       let $measurable = this.$html;\r\n       let jqui_options = this.props.draggable;\r\n       let jqui_start = jqui_options === 'object' ? jqui_options.start : undefined;\r\n       let jqui_end = jqui_options === 'object' ? jqui_options.stop : undefined;\r\n       let jqui_ing = jqui_options === 'object' ? jqui_options.drag : undefined;\r\n       let props_start = this.props.onDragStart;\r\n       let props_end = this.props.onDragEnd;\r\n       let props_ing = this.props.whileDragging;\r\n       let type = 'draggable';\r\n           let childmodekeys: (keyof CSSStyleDeclaration)[] = ['left', 'top', 'transform', 'position'];\r\n       //let positionMap = new WeakMap<HTMLElement, {left: number; top: number}>();\r\n       let childmode_drag = (e: HTMLElement, evt?: any, evtkind?: EventLetter, ui?:any): void => {\r\n           let oc = this.props.onChildren;\r\n           if (!oc) {\r\n               Log.ee('not oc', {evt, oc, e, p: this.props}); return;\r\n           }\r\n           let child: HTMLElement;\r\n           if (typeof oc === 'function') child = oc(e);\r\n           else child = e.children[0] as HTMLElement;\r\n           if (!child) {\r\n               Log.ee('child not found', {child, evt, oc, e}); return;\r\n           }\r\n           let oldpos = this.oldPos; // positionMap.get(e);\r\n           console.log('measurable default event child ' + evtkind, {ui, e, oc, oldpos});\r\n           //if (evtkind === 'e') { positionMap.set(e, ui.position); }\r\n             /*if (evtkind === 's') {\r\n               ui.originalPosition.left = 300;\r\n               ui.offset.left = 300;\r\n               ui.position.left = 300;\r\n               console.log('measurable sstart ', {type, e, oc, ui, el: e.style.left, cl: child.style.left});\r\n           }* /\r\n             let key: any;\r\n           for (key of childmodekeys) {\r\n               let fixpos = () => {\r\n                   if (oldpos && (oldpos as any)[key] !== undefined) {\r\n                       if (key ==='left') console.log('measurable fixpos ' + evtkind, (oldpos as any)[key] + ui.position[key] + 'px', (oldpos as any)[key]);\r\n                       let newpos = (oldpos as any)[key] + ui.position[key];\r\n                       child.style[key] = (newpos) + 'px';\r\n                       if (evtkind === 'e') this.oldPos[key] = newpos;\r\n                   }\r\n                   else child.style[key] = e.style[key];\r\n               }\r\n               fixpos();\r\n               if (evtkind === 'e')  setTimeout(fixpos, 1000);\r\n               if (evtkind === 's' && !e.classList.contains('draggable-child-mode')) e.classList.add('draggable-child-mode');\r\n               // delete e.style[key]\r\n           }\r\n       }\r\n         let translateeevents: Dictionary<string, Dictionary<string, DraggableEvent>> = {\r\n           'draggable': {\r\n               's': (e, ui)=>{ this.absoluteToTransform(e.target as HTMLElement, e, 's'); },\r\n               'ing': (e, ui)=>{ this.absoluteToTransform(e.target as HTMLElement, e, 'ing'); },\r\n               'e': (e, ui)=>{ this.absoluteToTransform(e.target as HTMLElement, e, 'e'); }},\r\n       };\r\n       let defaulteevent = (evtkind: EventLetter): MeasurableUIEvent | null =>{\r\n           if (!this.props.transformMode && !this.props.onChildren) return null;\r\n           return (e: any, ui: any) => {\r\n               //console.log('measurable default event', {type, evtkind, translateeevents, e, t: e.target});\r\n               if (this.props.transformMode === true) translateeevents[type][evtkind](e, ui);\r\n               childmode_drag(e.target, e, evtkind, ui);\r\n           }\r\n       };\r\n         if (props[optionkey] === false || !props[optionkey]) {\r\n           console.log(\"measurable off \" + type, {$measurable, type, datamap, optionkey, props});\r\n           if ($measurable.data(datamap[type])) ($measurable as GObject)[type]('disable');\r\n           return;\r\n       }\r\n       if (props[optionkey] === true) {\r\n           options = {};\r\n       } else options = {...props[optionkey]};\r\n         if (props_start && typeof props_start !== \"function\") { return Log.ee(\"<Measurable /> onDragStart props must be a function\"); }\r\n       if (props_end && typeof props_end !== \"function\") { return Log.ee(\"<Measurable /> onDragEnd props must be a function\"); }\r\n       if (props_ing && typeof props_ing !== \"function\") { return Log.ee(\"<Measurable /> whileDragging props must be a function\"); }\r\n       if (!jqui_start && !props_start && ! default_start) delete options.start,\r\n           else options.start = (evt, ui) => { default_start?.(evt, ui); jqui_start?.(evt, ui); props_start?.(thiss.getCoords(evt, ui), evt, ui); }\r\n         let propsOptions = {...options};\r\n       let defaultOptions = this.defaultOptions[type];\r\n       U.objectMergeInPlace(options, defaultOptions);\r\n       //console.log(\"measurable\", {type, $measurable, options, propsOptions, defaultOptions});\r\n       ($measurable as GObject)[type](options);\r\n    }*/\n  afterUpdateSingle(type) {\n    // was forced to move from general loop-style implementation to individual redundant stuff because of closure messes.\n    if (!this.$html) return;\n    let $measurable = this.$html;\n\n    // todo: changing options at runtime works, but changing children does not update\n\n    let eventmap = {\n      's': {\n        'draggable': 'onDragStart',\n        'rotatable': 'onRotateStart',\n        'resizable': 'onResizeStart'\n      },\n      'ing': {\n        'draggable': 'whileDragging',\n        'rotatable': 'whileRotating',\n        'resizable': 'whileResizing'\n      },\n      'e': {\n        'draggable': 'onDragEnd',\n        'rotatable': 'onRotateEnd',\n        'resizable': 'onResizeEnd'\n      }\n    };\n    let childmodekeys = ['left', 'top', 'transform', 'position'];\n    //let positionMap = new WeakMap<HTMLElement, {left: number; top: number}>();\n    let childmode = (e, evt, evtkind, ui) => {\n      let oc = this.props.onChildren;\n      if (!oc) {\n        Log.ee('not oc', {\n          evt,\n          oc,\n          e,\n          p: this.props\n        });\n        return;\n      }\n      let child;\n      if (typeof oc === 'function') child = oc(e);else child = e.children[0];\n      if (!child) {\n        Log.ee('child not found', {\n          child,\n          evt,\n          oc,\n          e\n        });\n        return;\n      }\n      let oldpos = this.oldPos; // positionMap.get(e);\n      console.log('measurable default event child ' + evtkind, {\n        ui,\n        e,\n        oc,\n        oldpos\n      });\n      //if (evtkind === 'e') { positionMap.set(e, ui.position); }\n\n      /*if (evtkind === 's') {\r\n          ui.originalPosition.left = 300;\r\n          ui.offset.left = 300;\r\n          ui.position.left = 300;\r\n          console.log('measurable sstart ', {type, e, oc, ui, el: e.style.left, cl: child.style.left});\r\n      }*/\n\n      let key;\n      for (key of childmodekeys) {\n        let fixpos = () => {\n          if (oldpos && oldpos[key] !== undefined) {\n            if (key === 'left') console.log('measurable fixpos ' + evtkind, oldpos[key] + ui.position[key] + 'px', oldpos[key]);\n            let newpos = oldpos[key] + ui.position[key];\n            child.style[key] = newpos + 'px';\n            if (evtkind === 'e') this.oldPos[key] = newpos;\n          } else child.style[key] = e.style[key];\n        };\n        fixpos();\n        if (evtkind === 'e') setTimeout(fixpos, 1000);\n        if (evtkind === 's' && !e.classList.contains('draggable-child-mode')) e.classList.add('draggable-child-mode');\n        // delete e.style[key]\n      }\n    };\n    function absoluteToTransform(e, evt, evtkind) {\n      let x = e.style.left;\n      let y = e.style.top; /*\r\n                           e.style.left = '0px';\r\n                           e.style.top = '0px';*/\n      //e.style.position = 'unset';\n      e.style.transform = `translate(${x}, ${y})`;\n    }\n    let translateeevents = {\n      'draggable': {\n        's': (e, ui) => {\n          this.absoluteToTransform(e.target, e, 's');\n        },\n        'ing': (e, ui) => {\n          this.absoluteToTransform(e.target, e, 'ing');\n        },\n        'e': (e, ui) => {\n          this.absoluteToTransform(e.target, e, 'e');\n        }\n      },\n      'resizable': {\n        's': (e, ui) => {},\n        'ing': (e, ui) => {},\n        'e': (e, ui) => {}\n      },\n      'rotatable': {\n        's': (e, ui) => {},\n        'ing': (e, ui) => {},\n        'e': (e, ui) => {}\n      }\n    };\n    let defaulteevent = evtkind => {\n      if (!this.props.transformMode && !this.props.onChildren) return null;\n      return (e, ui) => {\n        //console.log('measurable default event', {type, evtkind, translateeevents, e, t: e.target});\n        if (this.props.transformMode === true) translateeevents[type][evtkind](e, ui);\n        childmode(e.target, e, evtkind, ui);\n      };\n    };\n    let jqui_ing;\n    switch (type) {\n      default:\n        jqui_ing = Log.eDevv(\"unexpected measurable event: \" + type);\n        return;\n      case \"draggable\":\n        jqui_ing = 'drag';\n        break;\n      case \"resizable\":\n        jqui_ing = 'resize';\n        break;\n      case \"rotatable\":\n        jqui_ing = 'rotate';\n        break;\n    }\n    defaultoptions.start = (event, obj) => {\n      TRANSACTION(() => {\n        aaaaaaaaaaaa;\n        //for (let vid of allviews) this.doMeasurableEvent((EMeasurableEvents as any)[eventmap.s[type]], vid);\n      });\n    };\n    defaultoptions[jqui_ing] = (event, obj) => {\n      TRANSACTION(() => {\n        //for (let vid of allviews) this.doMeasurableEvent((EMeasurableEvents as any)[eventmap.s[type]], vid);\n      });\n    };\n    defaultoptions.stop = (event, obj) => {\n      TRANSACTION(() => {\n        //for (let vid of allviews) this.doMeasurableEvent((EMeasurableEvents as any)[eventmap.s[type]], vid);\n      });\n    };\n    let options;\n    const props = this.props;\n    const datamap = {\n      draggable: \"uiDraggable\",\n      resizable: \"uiResizable\",\n      rotatable: \"uiRotatable\"\n    };\n    const optionmap = {\n      draggable: \"draggable\",\n      resizable: \"resizable\",\n      rotatable: \"rotatable\"\n    };\n    const optionkey = optionmap[type];\n    if (props[optionkey] === false || !props[optionkey]) {\n      console.log(\"measurable off \" + type, {\n        $measurable,\n        type,\n        datamap,\n        optionkey,\n        props\n      });\n      if ($measurable.data(datamap[type])) $measurable[type]('disable');\n      return;\n    }\n    if (props[optionkey] === true) {\n      options = {};\n    } else options = {\n      ...props[optionkey]\n    };\n\n    //let jodelevent = {'s': eventmap.s[type], 'ing': eventmap.ing[type], 'e': eventmap.e[type]};\n    let jquievent = {\n      's': 'start',\n      'ing': jqui_ing,\n      'e': 'stop'\n    };\n    let thiss = this;\n    const setupEvent = evtkey => {\n      let jqkey = jquievent[evtkey] || '';\n      let propsevent = props[eventmap[evtkey][type]];\n      if (propsevent && typeof propsevent !== \"function\") {\n        Log.ee(\"<Measurable /> \" + eventmap[evtkey][type] + \" props must be a function\");\n        return;\n      }\n      options[jqkey + \"_debug\"] = propsevent;\n      // call ondragend... jodel events\n      let jquievt = options[jqkey];\n      // let jodelevt = propsevent; // (...params: any) => propsevent(...params); // was made to preserve \"this\"?\n      let defaultevt = defaulteevent(evtkey);\n      let allevents = [jquievt, propsevent, defaultevt].filter(e => !!e);\n      console.log('checking for jodelevent 00', {\n        propsevent,\n        allevents,\n        props,\n        k: eventmap[evtkey][type],\n        pe: props[eventmap[evtkey][type]],\n        evtkey,\n        type,\n        eventmap\n      });\n      if (allevents.length) options[jqkey] = function (evt, ui) {\n        let allevents_i = allevents;\n        for (let e of allevents_i) {\n          let evtkey_i = evtkey;\n          let jodelevt = propsevent = props[eventmap[evtkey_i][type]]; // if i don't redeclare it here, closure makes a mess taking always the last jodelevt for all iterations.\n          console.log('checking for jodelevent', e === jodelevt, {\n            e,\n            jodelevt,\n            allevents,\n            props,\n            k: eventmap[evtkey0][type],\n            pe: props[eventmap[evtkey_i][type]],\n            evtkey,\n            evtkey_i,\n            evtkey0,\n            type,\n            eventmap\n          });\n          if (e === jodelevt) {\n            e(thiss.getCoords(evt, ui), evt, ui);\n          } else e(thiss.getCoords(evt, ui), evt, ui);\n        }\n      };\n    };\n    let evtkey0;\n    for (evtkey0 in jquievent) {\n      setupEvent(evtkey0);\n    }\n    let defaultOptions = this.defaultOptions[type];\n    U.objectMergeInPlace(options, defaultOptions);\n    //console.log(\"measurable\", {type, $measurable, options, propsOptions, defaultOptions});\n    $measurable[type](options);\n  }\n  shouldComponentUpdate(nextProps, nextState, nextContext) {\n    //console.log(\"measurable shouldup\", {nc:nextProps.children, tc:this.props.children, eq: nextProps.children == this.props.children});\n    // todo: would need to check if pros.children has changed, but that requires a deep search of subcomponents props and state.\n    // currently with just return true it works and rerenders every time the parent component rerenders. not when other elements are interacted.\n    // it works also with <Input> as direct child and it updates.\n    if (window) return true;\n    const oldProps = this.props || {};\n    this.dragOptionsChanged = false;\n    this.resizeOptionsChanged = false;\n    this.rotateOptionsChanged = false;\n    let ret = false;\n    const nestederr = \"Options cannot contain functions or nested objects\";\n    if (!U.isShallowEqualWithProxies(oldProps.draggable, nextProps.draggable)) {\n      const opt = oldProps.draggable;\n      if (opt && typeof opt === \"object\") for (let k in opt) {\n        switch (typeof opt[k]) {\n          case \"function\":\n          case \"object\":\n            Log.ee(\"drag\" + nestederr, k);\n        }\n      }\n      this.dragOptionsChanged = true;\n      ret = true;\n    }\n    if (!U.isShallowEqualWithProxies(oldProps.resizable, nextProps.resizable)) {\n      const opt = oldProps.resizable;\n      if (opt && typeof opt === \"object\") for (let k in opt) {\n        switch (typeof opt[k]) {\n          case \"function\":\n          case \"object\":\n            Log.ee(\"resize\" + nestederr, k);\n        }\n      }\n      this.resizeOptionsChanged = true;\n      ret = true;\n    }\n    if (!U.isShallowEqualWithProxies(oldProps.rotatable, nextProps.rotatable)) {\n      const opt = oldProps.rotatable;\n      if (opt && typeof opt === \"object\") for (let k in opt) {\n        switch (typeof opt[k]) {\n          case \"function\":\n          case \"object\":\n            Log.ee(\"rotate\" + nestederr, k);\n        }\n      }\n      this.rotateOptionsChanged = true;\n      return true;\n    }\n    if (ret) return true; // i don't need to set more this.variable stuff and i already determined something changed.\n    if (Object.keys(oldProps).length !== Object.keys(nextProps).length) return true;\n    let k;\n    for (k in oldProps) {\n      switch (k) {\n        //case \"axis\": if (ok)\n        case \"draggable\":\n        case \"resizable\":\n        case \"rotatable\":\n          continue;\n        case \"children\":\n          continue;\n      }\n      if (!(k in nextProps)) return false;\n      let ok = oldProps[k];\n      let nk = nextProps[k];\n      if (ok === nk) continue;\n      let tk = typeof ok;\n      if (tk !== typeof nk) return false;\n      switch (tk) {\n        case \"object\":\n          Log.ee(\"unexpected object in <Measurable/> props\", {\n            k,\n            nk,\n            ok\n          });\n          return true;\n        case \"function\":\n          if (ok.toString() !== nk.toString()) return true;\n          break;\n        default:\n          return false;\n        // already checked they are !==\n      }\n    }\n    return false;\n  }\n  updateDefaultOptions() {\n    /*let addClasses = this.props.children ? 'on-children' as any : undefined;\r\n                                      jqui.classes does not owrk? and addclass is only for draggable?\r\n    if (this.defaultOptions.draggable.addClasses !== addClasses) {\r\n        this.defaultOptions.resizable.classes = addClasses;\r\n        // this.defaultOptions.rotatable.classes = addClasses;\r\n    }*/\n  }\n  render() {\n    let child = this.props.children;\n    this.updateDefaultOptions();\n    if (!child) return child || null; // sometimes react passes {} as props.children?\n    if (!Object.keys(child).length) return Log.ee(\"Measurable can have only 1 subelement and it cannot be an array or a <>React.fragment</>\", child, this.props);\n    if (Array.isArray(child)) {\n      if (child.length !== 1) {\n        Log.ee(\"Measurable can have only 1 subelement and it cannot be an array or a <>React.fragment</>\", child, this.props);\n        return child;\n      } else child = child[0];\n    }\n    if (child.type.toString() === React.Fragment.toString()) {\n      Log.ee(\"Measurable can have only 1 subelement and it cannot be an array or a <>React.fragment</>\", child, this.props);\n      return child;\n    }\n    let oldProps = child.props;\n    let newProps = {\n      ref: html => {\n        if (html && !U.isHtmlNode(html)) {\n          Log.ee('ref tring to set non-html element', html);\n          return;\n        }\n        this.html = html;\n      }\n    };\n    U.objectMergeInPlace(newProps, oldProps);\n    let clonedChild = /*#__PURE__*/React.cloneElement(child, newProps);\n    return clonedChild;\n  }\n  getCoords(evt, ui) {\n    let size = Size.of(evt.target);\n    let graph = DGraphElement.graphLFromHtml(evt.target);\n    return graph === null || graph === void 0 ? void 0 : graph.translateHtmlSize(size);\n  }\n}, _class2.cname = \"MeasurableComponent\", _class2)) || _class);\n/*\r\n@RuntimeAccessible('InfiniteScrollComponent')\r\nexport class InfiniteScrollComponent extends Component<ScrollOwnProps, ScrollState>{\r\n    static cname: string = \"InfiniteScrollComponent\";\r\n    render(){\r\n        return <Measurable transformMode={false} onChildren={true}>{ this.props.children}</Measurable>\r\n    }\r\n}\r\n*/\n// private\n\n// private\n\n// private\n\n// private\n\n////// mapper func\n/*\r\nfunction mapStateToProps(state: DState, ownProps: MeasurableOwnProps): MeasurableStateProps {\r\n    const ret: MeasurableStateProps = {} as any;\r\n    /// to fill\r\n    return ret; }\r\n\r\nfunction mapDispatchToProps(dispatch: Dispatch<any>): DispatchProps {\r\n    const ret: DispatchProps = {} as any;\r\n    /// to fill\r\n    return ret; }\r\n*/\n\nMeasurableComponent.defaultProps = {\n  autosizex: true,\n  autosizey: true,\n  style: undefined,\n  children: []\n};\nexport class InfiniteScrollComponent extends Component {}\nexport function Measurable(props) {\n  let children = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  return /*#__PURE__*/_jsxDEV(MeasurableComponent, {\n    ...props,\n    children,\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 495,\n    columnNumber: 12\n  }, this);\n}\n// todo: shortcuts for Draggable Resizable Rotatable with whileDragging onDragStart props simplified to start, while, end\n_c = Measurable;\nexport function InfiniteScroll(props) {\n  let children = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  return /*#__PURE__*/_jsxDEV(Measurable, {\n    ...props,\n    children,\n    transformMode: false,\n    onChildren: true,\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 499,\n    columnNumber: 12\n  }, this);\n} /*\r\n  export function InfiniteScroll(props: MeasurableAllProps, children: ReactChild[] = []): ReactElement {\r\n     return <InfiniteScrollComponent {...{...props, children}}>{children}</InfiniteScrollComponent>;\r\n  }*/\n\n/*connect<MeasurableStateProps, DispatchProps, MeasurableOwnProps, DState>(\r\n    mapStateToProps,\r\n    mapDispatchToProps\r\n)(MeasurableComponent);*/\n_c2 = InfiniteScroll;\nvar _c, _c2;\n$RefreshReg$(_c, \"Measurable\");\n$RefreshReg$(_c2, \"InfiniteScroll\");","map":{"version":3,"names":["React","Component","DGraphElement","Log","RuntimeAccessible","Size","TRANSACTION","U","$","jsxDEV","_jsxDEV","MeasurableComponent","_dec","_class","_class2","constructor","arguments","html","$html","dragOptionsChanged","resizeOptionsChanged","rotateOptionsChanged","defaultOptions","draggable","cursor","distance","resizable","rotatable","oldPos","left","top","componentDidMount","afterUpdate","componentDidUpdate","prevProps","prevState","snapshot","absoluteToTransform","e","evt","evtkind","x","style","y","transform","afterUpdateSingle","type","props","afterUpdateDraggable","$measurable","eventmap","childmodekeys","childmode","ui","oc","onChildren","ee","p","child","children","oldpos","console","log","key","fixpos","undefined","position","newpos","setTimeout","classList","contains","add","translateeevents","s","target","ing","defaulteevent","transformMode","jqui_ing","eDevv","defaultoptions","start","event","obj","aaaaaaaaaaaa","stop","options","datamap","optionmap","optionkey","data","jquievent","thiss","setupEvent","evtkey","jqkey","propsevent","jquievt","defaultevt","allevents","filter","k","pe","length","allevents_i","evtkey_i","jodelevt","evtkey0","getCoords","objectMergeInPlace","shouldComponentUpdate","nextProps","nextState","nextContext","window","oldProps","ret","nestederr","isShallowEqualWithProxies","opt","Object","keys","ok","nk","tk","toString","updateDefaultOptions","render","Array","isArray","Fragment","newProps","ref","isHtmlNode","clonedChild","cloneElement","size","of","graph","graphLFromHtml","translateHtmlSize","cname","defaultProps","autosizex","autosizey","InfiniteScrollComponent","Measurable","fileName","_jsxFileName","lineNumber","columnNumber","_c","InfiniteScroll","_c2","$RefreshReg$"],"sources":["C:/d/Programming/web/jodel-mde/src/components/forEndUser/Measurable.tsx"],"sourcesContent":["import React, {Component, CSSProperties, PureComponent, ReactChild, ReactElement, ReactNode} from \"react\";\r\nimport {DGraphElement, Dictionary, GObject, GraphSize, LGraph, Log, RuntimeAccessible, Size, TRANSACTION, U} from \"../../joiner\";\r\nimport $ from \"jquery\";\r\nimport {JQueryUI} from \"../../common/libraries/jqui-types\";\r\nimport {OwnProps} from \"../rightbar/structureEditor/ModelMetaData\";\r\ntype ResizableEvent = JQueryUI.ResizableEvent;\r\ntype DraggableEvent = JQueryUI.DraggableEvent;\r\ntype RotatableEvent = ()=>void; // todo\r\n\r\n// private\r\ninterface MeasurableState {\r\n}\r\ninterface ScrollState {\r\n}\r\n\r\ntype EventLetter = 's'|'ing'|'e';\r\ntype MeasurableUIEvent = ResizableEvent | DraggableEvent | RotatableEvent;\r\n\r\n@RuntimeAccessible('MeasurableComponent')\r\nexport class MeasurableComponent extends Component<MeasurableAllProps, MeasurableState>{\r\n    static cname: string = \"MeasurableComponent\";\r\n\r\n\r\n    private html: Element | null = null;\r\n    private $html!:  JQuery<Element>;\r\n    dragOptionsChanged: boolean = true;\r\n    resizeOptionsChanged: boolean = true;\r\n    rotateOptionsChanged: boolean = true;\r\n    defaultOptions: {\"draggable\": JQueryUI.DraggableOptions, resizable: JQueryUI.ResizableOptions, rotatable: GObject} = {\r\n        draggable: {\r\n            cursor: 'grabbing',\r\n            // containment: 'parent',\r\n            distance: 5,\r\n            // helper: 'clone', // 'original' or 'csselector'? or func=>html\r\n            // disabled: !(view.draggable),}\r\n        },\r\n        resizable: {},\r\n        rotatable: {},\r\n    }\r\n    oldPos: Dictionary<string, number> =  {left: 0, top: 0};\r\n\r\n    componentDidMount() {\r\n        this.afterUpdate();\r\n    }\r\n    componentDidUpdate(prevProps: Readonly<MeasurableAllProps>, prevState: Readonly<MeasurableState>, snapshot?: any) {\r\n        this.afterUpdate();\r\n    }\r\n\r\n    absoluteToTransform(e: HTMLElement, evt?: any, evtkind?: EventLetter): any {\r\n        let x = e.style.left;\r\n        let y = e.style.top;/*\r\n            e.style.left = '0px';\r\n            e.style.top = '0px';*/\r\n        //e.style.position = 'unset';\r\n        e.style.transform = `translate(${x}, ${y})`;\r\n    }\r\n    afterUpdate(): void{\r\n        if (!this.html) return;\r\n        this.$html = $(this.html);\r\n        if (this.dragOptionsChanged) { this.afterUpdateSingle(\"draggable\"); }\r\n        if (this.resizeOptionsChanged) { this.afterUpdateSingle(\"resizable\"); }\r\n        if (this.rotateOptionsChanged) { this.afterUpdateSingle(\"rotatable\"); }\r\n    }\r\n\r\n    afterUpdateSingle(type: \"draggable\" | \"resizable\" | \"rotatable\"): void{\r\n        if (this.props.draggable) this.afterUpdateDraggable()\r\n    }/*\r\n    afterUpdateDraggable_single_old(): void{\r\n        nope, erase this and just make the previous _old genericversion with inner dynamic functions called 9 times like event('drag', 'while'); event('drag', 'end'); event('resize', 'while');...\r\n        make and extract new functions from code so that it dinamically build the jqui options object\r\n        if (!this.$html) return;\r\n        let $measurable = this.$html;\r\n        let jqui_options = this.props.draggable;\r\n        let jqui_start = jqui_options === 'object' ? jqui_options.start : undefined;\r\n        let jqui_end = jqui_options === 'object' ? jqui_options.stop : undefined;\r\n        let jqui_ing = jqui_options === 'object' ? jqui_options.drag : undefined;\r\n        let props_start = this.props.onDragStart;\r\n        let props_end = this.props.onDragEnd;\r\n        let props_ing = this.props.whileDragging;\r\n        let type = 'draggable';\r\n\r\n\r\n        let childmodekeys: (keyof CSSStyleDeclaration)[] = ['left', 'top', 'transform', 'position'];\r\n        //let positionMap = new WeakMap<HTMLElement, {left: number; top: number}>();\r\n        let childmode_drag = (e: HTMLElement, evt?: any, evtkind?: EventLetter, ui?:any): void => {\r\n            let oc = this.props.onChildren;\r\n            if (!oc) {\r\n                Log.ee('not oc', {evt, oc, e, p: this.props}); return;\r\n            }\r\n            let child: HTMLElement;\r\n            if (typeof oc === 'function') child = oc(e);\r\n            else child = e.children[0] as HTMLElement;\r\n            if (!child) {\r\n                Log.ee('child not found', {child, evt, oc, e}); return;\r\n            }\r\n            let oldpos = this.oldPos; // positionMap.get(e);\r\n            console.log('measurable default event child ' + evtkind, {ui, e, oc, oldpos});\r\n            //if (evtkind === 'e') { positionMap.set(e, ui.position); }\r\n\r\n            /*if (evtkind === 's') {\r\n                ui.originalPosition.left = 300;\r\n                ui.offset.left = 300;\r\n                ui.position.left = 300;\r\n                console.log('measurable sstart ', {type, e, oc, ui, el: e.style.left, cl: child.style.left});\r\n            }* /\r\n\r\n            let key: any;\r\n            for (key of childmodekeys) {\r\n                let fixpos = () => {\r\n                    if (oldpos && (oldpos as any)[key] !== undefined) {\r\n                        if (key ==='left') console.log('measurable fixpos ' + evtkind, (oldpos as any)[key] + ui.position[key] + 'px', (oldpos as any)[key]);\r\n                        let newpos = (oldpos as any)[key] + ui.position[key];\r\n                        child.style[key] = (newpos) + 'px';\r\n                        if (evtkind === 'e') this.oldPos[key] = newpos;\r\n                    }\r\n                    else child.style[key] = e.style[key];\r\n                }\r\n                fixpos();\r\n                if (evtkind === 'e')  setTimeout(fixpos, 1000);\r\n                if (evtkind === 's' && !e.classList.contains('draggable-child-mode')) e.classList.add('draggable-child-mode');\r\n                // delete e.style[key]\r\n            }\r\n        }\r\n\r\n        let translateeevents: Dictionary<string, Dictionary<string, DraggableEvent>> = {\r\n            'draggable': {\r\n                's': (e, ui)=>{ this.absoluteToTransform(e.target as HTMLElement, e, 's'); },\r\n                'ing': (e, ui)=>{ this.absoluteToTransform(e.target as HTMLElement, e, 'ing'); },\r\n                'e': (e, ui)=>{ this.absoluteToTransform(e.target as HTMLElement, e, 'e'); }},\r\n        };\r\n        let defaulteevent = (evtkind: EventLetter): MeasurableUIEvent | null =>{\r\n            if (!this.props.transformMode && !this.props.onChildren) return null;\r\n            return (e: any, ui: any) => {\r\n                //console.log('measurable default event', {type, evtkind, translateeevents, e, t: e.target});\r\n                if (this.props.transformMode === true) translateeevents[type][evtkind](e, ui);\r\n                childmode_drag(e.target, e, evtkind, ui);\r\n            }\r\n        };\r\n\r\n        if (props[optionkey] === false || !props[optionkey]) {\r\n            console.log(\"measurable off \" + type, {$measurable, type, datamap, optionkey, props});\r\n            if ($measurable.data(datamap[type])) ($measurable as GObject)[type]('disable');\r\n            return;\r\n        }\r\n        if (props[optionkey] === true) {\r\n            options = {};\r\n        } else options = {...props[optionkey]};\r\n\r\n        if (props_start && typeof props_start !== \"function\") { return Log.ee(\"<Measurable /> onDragStart props must be a function\"); }\r\n        if (props_end && typeof props_end !== \"function\") { return Log.ee(\"<Measurable /> onDragEnd props must be a function\"); }\r\n        if (props_ing && typeof props_ing !== \"function\") { return Log.ee(\"<Measurable /> whileDragging props must be a function\"); }\r\n        if (!jqui_start && !props_start && ! default_start) delete options.start,\r\n            else options.start = (evt, ui) => { default_start?.(evt, ui); jqui_start?.(evt, ui); props_start?.(thiss.getCoords(evt, ui), evt, ui); }\r\n\r\n        let propsOptions = {...options};\r\n        let defaultOptions = this.defaultOptions[type];\r\n        U.objectMergeInPlace(options, defaultOptions);\r\n        //console.log(\"measurable\", {type, $measurable, options, propsOptions, defaultOptions});\r\n        ($measurable as GObject)[type](options);\r\n    }*/\r\n    afterUpdateSingle(type: \"draggable\" | \"resizable\" | \"rotatable\"): void{\r\n        // was forced to move from general loop-style implementation to individual redundant stuff because of closure messes.\r\n        if (!this.$html) return;\r\n        let $measurable = this.$html;\r\n\r\n        // todo: changing options at runtime works, but changing children does not update\r\n\r\n\r\n        let eventmap = {\r\n            's':    {'draggable': 'onDragStart',    'rotatable': 'onRotateStart',   'resizable': 'onResizeStart'},\r\n            'ing':  {'draggable': 'whileDragging',  'rotatable': 'whileRotating',   'resizable': 'whileResizing'},\r\n            'e':    {'draggable': 'onDragEnd',      'rotatable': 'onRotateEnd',     'resizable': 'onResizeEnd'  },\r\n        }\r\n        let childmodekeys: (keyof CSSStyleDeclaration)[] = ['left', 'top', 'transform', 'position'];\r\n        //let positionMap = new WeakMap<HTMLElement, {left: number; top: number}>();\r\n        let childmode = (e: HTMLElement, evt?: any, evtkind?: EventLetter, ui?:any): void => {\r\n            let oc = this.props.onChildren;\r\n            if (!oc) {\r\n                Log.ee('not oc', {evt, oc, e, p: this.props}); return;\r\n            }\r\n            let child: HTMLElement;\r\n            if (typeof oc === 'function') child = oc(e);\r\n            else child = e.children[0] as HTMLElement;\r\n            if (!child) {\r\n                Log.ee('child not found', {child, evt, oc, e}); return;\r\n            }\r\n            let oldpos = this.oldPos; // positionMap.get(e);\r\n            console.log('measurable default event child ' + evtkind, {ui, e, oc, oldpos});\r\n            //if (evtkind === 'e') { positionMap.set(e, ui.position); }\r\n\r\n            /*if (evtkind === 's') {\r\n                ui.originalPosition.left = 300;\r\n                ui.offset.left = 300;\r\n                ui.position.left = 300;\r\n                console.log('measurable sstart ', {type, e, oc, ui, el: e.style.left, cl: child.style.left});\r\n            }*/\r\n\r\n            let key: any;\r\n            for (key of childmodekeys) {\r\n                let fixpos = () => {\r\n                    if (oldpos && (oldpos as any)[key] !== undefined) {\r\n                        if (key ==='left') console.log('measurable fixpos ' + evtkind, (oldpos as any)[key] + ui.position[key] + 'px', (oldpos as any)[key]);\r\n                        let newpos = (oldpos as any)[key] + ui.position[key];\r\n                        child.style[key] = (newpos) + 'px';\r\n                        if (evtkind === 'e') this.oldPos[key] = newpos;\r\n                    }\r\n                    else child.style[key] = e.style[key];\r\n                }\r\n                fixpos();\r\n                if (evtkind === 'e')  setTimeout(fixpos, 1000);\r\n                if (evtkind === 's' && !e.classList.contains('draggable-child-mode')) e.classList.add('draggable-child-mode');\r\n                // delete e.style[key]\r\n            }\r\n        }\r\n\r\n        function absoluteToTransform(e: HTMLElement, evt?: any, evtkind?: EventLetter): void {\r\n            let x = e.style.left;\r\n            let y = e.style.top;/*\r\n            e.style.left = '0px';\r\n            e.style.top = '0px';*/\r\n            //e.style.position = 'unset';\r\n            e.style.transform = `translate(${x}, ${y})`;\r\n        }\r\n        let translateeevents: Dictionary<string, Dictionary<string, DraggableEvent>> = {\r\n            'draggable': {\r\n                's': (e, ui)=>{ this.absoluteToTransform(e.target as HTMLElement, e, 's'); },\r\n                'ing': (e, ui)=>{ this.absoluteToTransform(e.target as HTMLElement, e, 'ing'); },\r\n                'e': (e, ui)=>{ this.absoluteToTransform(e.target as HTMLElement, e, 'e'); }},\r\n            'resizable': {\r\n                's': (e, ui)=>{},\r\n                'ing': (e, ui)=>{},\r\n                'e': (e, ui)=>{}},\r\n            'rotatable': {\r\n                's': (e, ui)=>{},\r\n                'ing': (e, ui)=>{},\r\n                'e': (e, ui)=>{}},\r\n        };\r\n        let defaulteevent = (evtkind: EventLetter): MeasurableUIEvent | null =>{\r\n            if (!this.props.transformMode && !this.props.onChildren) return null;\r\n            return (e: any, ui: any) => {\r\n                //console.log('measurable default event', {type, evtkind, translateeevents, e, t: e.target});\r\n                if (this.props.transformMode === true) translateeevents[type][evtkind](e, ui);\r\n                childmode(e.target, e, evtkind, ui);\r\n            }\r\n        };\r\n        let jqui_ing: string;\r\n        switch (type){\r\n            default: jqui_ing = Log.eDevv(\"unexpected measurable event: \" + type); return;\r\n            case \"draggable\": jqui_ing = 'drag'; break;\r\n            case \"resizable\": jqui_ing = 'resize'; break;\r\n            case \"rotatable\": jqui_ing = 'rotate'; break;\r\n        }\r\n        defaultoptions.start = (event: GObject, obj: GObject) => {\r\n            TRANSACTION(()=>{\r\n                aaaaaaaaaaaa\r\n                //for (let vid of allviews) this.doMeasurableEvent((EMeasurableEvents as any)[eventmap.s[type]], vid);\r\n            })\r\n        }\r\n        defaultoptions[jqui_ing] = (event: GObject, obj: GObject) => {\r\n            TRANSACTION(()=>{\r\n                //for (let vid of allviews) this.doMeasurableEvent((EMeasurableEvents as any)[eventmap.s[type]], vid);\r\n            })\r\n        };\r\n        defaultoptions.stop = (event: GObject, obj: GObject) => {\r\n            TRANSACTION(()=>{\r\n                //for (let vid of allviews) this.doMeasurableEvent((EMeasurableEvents as any)[eventmap.s[type]], vid);\r\n            })\r\n        }\r\n        let options: GObject;\r\n        const props: GObject = this.props;\r\n        const datamap = {draggable: \"uiDraggable\", resizable: \"uiResizable\", rotatable: \"uiRotatable\"};\r\n        const optionmap = {draggable: \"draggable\", resizable: \"resizable\", rotatable: \"rotatable\"};\r\n        const optionkey = optionmap[type];\r\n        if (props[optionkey] === false || !props[optionkey]) {\r\n            console.log(\"measurable off \" + type, {$measurable, type, datamap, optionkey, props});\r\n            if ($measurable.data(datamap[type])) ($measurable as GObject)[type]('disable');\r\n            return;\r\n        }\r\n        if (props[optionkey] === true) {\r\n            options = {};\r\n        } else options = {...props[optionkey]};\r\n\r\n        //let jodelevent = {'s': eventmap.s[type], 'ing': eventmap.ing[type], 'e': eventmap.e[type]};\r\n        let jquievent = {'s': 'start', 'ing': jqui_ing, 'e':'stop'};\r\n        let thiss = this;\r\n        const setupEvent = (evtkey: keyof typeof jquievent) => {\r\n            let jqkey = jquievent[evtkey] || '';\r\n            let propsevent = props[eventmap[evtkey][type]];\r\n\r\n            if (propsevent && typeof propsevent !== \"function\") {\r\n                Log.ee(\"<Measurable /> \" + eventmap[evtkey][type] + \" props must be a function\");\r\n                return;\r\n            }\r\n            options[jqkey+\"_debug\"] = propsevent;\r\n            // call ondragend... jodel events\r\n            let jquievt = options[jqkey];\r\n            // let jodelevt = propsevent; // (...params: any) => propsevent(...params); // was made to preserve \"this\"?\r\n            let defaultevt: null | MeasurableUIEvent = defaulteevent(evtkey);\r\n            let allevents = [jquievt, propsevent, defaultevt].filter((e)=>!!e);\r\n            console.log('checking for jodelevent 00', {propsevent, allevents, props, k: eventmap[evtkey][type], pe: props[eventmap[evtkey][type]], evtkey, type, eventmap});\r\n\r\n            if (allevents.length) options[jqkey] = (function(evt, ui) {\r\n                let allevents_i = allevents;\r\n                for (let e of allevents_i) {\r\n                    let evtkey_i = evtkey;\r\n                    let jodelevt = propsevent = props[eventmap[evtkey_i][type]]; // if i don't redeclare it here, closure makes a mess taking always the last jodelevt for all iterations.\r\n                    console.log('checking for jodelevent', e === jodelevt, {e, jodelevt, allevents, props, k: eventmap[evtkey0][type], pe: props[eventmap[evtkey_i][type]], evtkey, evtkey_i, evtkey0, type, eventmap});\r\n                    if (e === jodelevt) { e(thiss.getCoords(evt, ui), evt, ui); }\r\n                    else e(thiss.getCoords(evt, ui), evt, ui);\r\n                }\r\n            }) as DraggableEvent;\r\n        }\r\n        let evtkey0: keyof typeof jquievent;\r\n        for (evtkey0 in jquievent) { setupEvent(evtkey0); }\r\n        let defaultOptions = this.defaultOptions[type];\r\n        U.objectMergeInPlace(options, defaultOptions);\r\n        //console.log(\"measurable\", {type, $measurable, options, propsOptions, defaultOptions});\r\n        ($measurable as GObject)[type](options);\r\n    }\r\n    shouldComponentUpdate(nextProps: Readonly<MeasurableAllProps>, nextState: Readonly<MeasurableState>, nextContext: any): boolean {\r\n        //console.log(\"measurable shouldup\", {nc:nextProps.children, tc:this.props.children, eq: nextProps.children == this.props.children});\r\n        // todo: would need to check if pros.children has changed, but that requires a deep search of subcomponents props and state.\r\n        // currently with just return true it works and rerenders every time the parent component rerenders. not when other elements are interacted.\r\n        // it works also with <Input> as direct child and it updates.\r\n        if (window) return true;\r\n        const oldProps = this.props || {};\r\n        this.dragOptionsChanged = false;\r\n        this.resizeOptionsChanged = false;\r\n        this.rotateOptionsChanged = false;\r\n        let ret: boolean = false;\r\n        const nestederr = \"Options cannot contain functions or nested objects\";\r\n        if (!U.isShallowEqualWithProxies(oldProps.draggable, nextProps.draggable)) {\r\n            const opt: GObject = oldProps.draggable as any;\r\n            if (opt && typeof opt === \"object\") for(let k in opt){ switch (typeof opt[k]){ case \"function\": case \"object\": Log.ee(\"drag\" + nestederr, k); } }\r\n            this.dragOptionsChanged = true;\r\n            ret = true;\r\n        }\r\n        if (!U.isShallowEqualWithProxies(oldProps.resizable, nextProps.resizable)) {\r\n            const opt: GObject = oldProps.resizable as any;\r\n            if (opt && typeof opt === \"object\") for(let k in opt){ switch (typeof opt[k]){ case \"function\": case \"object\": Log.ee(\"resize\" + nestederr, k); } }\r\n            this.resizeOptionsChanged = true;\r\n            ret = true;\r\n        }\r\n        if (!U.isShallowEqualWithProxies(oldProps.rotatable, nextProps.rotatable)) {\r\n            const opt: GObject = oldProps.rotatable as any;\r\n            if (opt && typeof opt === \"object\") for(let k in opt){ switch (typeof opt[k]){ case \"function\": case \"object\": Log.ee(\"rotate\" + nestederr, k); } }\r\n            this.rotateOptionsChanged = true;\r\n            return true;\r\n        }\r\n        if (ret) return true; // i don't need to set more this.variable stuff and i already determined something changed.\r\n        if (Object.keys(oldProps).length !== Object.keys(nextProps).length) return true;\r\n        let k: keyof typeof nextProps;\r\n        for (k in oldProps){\r\n            switch(k){\r\n                //case \"axis\": if (ok)\r\n                case \"draggable\": case \"resizable\": case \"rotatable\": continue;\r\n                case \"children\": continue;\r\n            }\r\n            if (!(k in nextProps)) return false;\r\n            let ok = oldProps[k];\r\n            let nk = nextProps[k];\r\n            if (ok === nk) continue;\r\n            let tk = typeof ok;\r\n            if (tk !== typeof nk) return false;\r\n            switch (tk) {\r\n                case \"object\": Log.ee(\"unexpected object in <Measurable/> props\", {k, nk, ok}); return true;\r\n                case \"function\": if (ok!.toString() !== nk!.toString()) return true; break;\r\n                default: return false; // already checked they are !==\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    updateDefaultOptions(){\r\n        /*let addClasses = this.props.children ? 'on-children' as any : undefined;\r\n                                          jqui.classes does not owrk? and addclass is only for draggable?\r\n        if (this.defaultOptions.draggable.addClasses !== addClasses) {\r\n            this.defaultOptions.resizable.classes = addClasses;\r\n            // this.defaultOptions.rotatable.classes = addClasses;\r\n        }*/\r\n    }\r\n    render(): ReactNode {\r\n        let child: ReactElement = this.props.children as any;\r\n\r\n        this.updateDefaultOptions();\r\n        if (!child) return child || null; // sometimes react passes {} as props.children?\r\n        if (!Object.keys(child).length) return Log.ee(\"Measurable can have only 1 subelement and it cannot be an array or a <>React.fragment</>\", child, this.props);\r\n        if (Array.isArray(child)) {\r\n            if (child.length !== 1) {\r\n                Log.ee(\"Measurable can have only 1 subelement and it cannot be an array or a <>React.fragment</>\", child, this.props);\r\n                return child;\r\n            }\r\n            else child = child[0];\r\n        }\r\n        if (child.type.toString() === React.Fragment.toString()) {\r\n            Log.ee(\"Measurable can have only 1 subelement and it cannot be an array or a <>React.fragment</>\", child, this.props);\r\n            return child; }\r\n\r\n        let oldProps = child.props;\r\n        let newProps = {\r\n            ref: (html: Element | null)=>{\r\n                if (html && !U.isHtmlNode(html)) {\r\n                    Log.ee('ref tring to set non-html element', html);\r\n                    return;\r\n                }\r\n                this.html = html;\r\n            }\r\n        };\r\n        U.objectMergeInPlace(newProps, oldProps);\r\n        let clonedChild = React.cloneElement(child, newProps);\r\n        return clonedChild;\r\n    }\r\n\r\n    private getCoords(evt: JQueryEventObject, ui: JQueryUI.DraggableEventUIParams): GraphSize {\r\n        let size = Size.of(evt.target);\r\n        let graph: LGraph = DGraphElement.graphLFromHtml(evt.target) as LGraph;\r\n        return graph?.translateHtmlSize(size);\r\n    }\r\n}\r\n/*\r\n@RuntimeAccessible('InfiniteScrollComponent')\r\nexport class InfiniteScrollComponent extends Component<ScrollOwnProps, ScrollState>{\r\n    static cname: string = \"InfiniteScrollComponent\";\r\n    render(){\r\n        return <Measurable transformMode={false} onChildren={true}>{ this.props.children}</Measurable>\r\n    }\r\n}\r\n*/\r\n// private\r\ninterface ScrollOwnProps {\r\n    children: ReactChild[] | ReactChild;\r\n}\r\ninterface MeasurableOwnProps {\r\n    children: ReactChild[] | ReactChild;\r\n    //dragOptions?: Options;\r\n    //drag?: Options;\r\n    draggable?: JQueryUI.DraggableOptions | boolean;\r\n    onDragStart?: DraggableEvent;\r\n    whileDragging?: DraggableEvent;\r\n    onDragEnd?: DraggableEvent;\r\n    onChildren?: boolean | ((e: HTMLElement)=>HTMLElement);\r\n\r\n    //resizeOptions?: Options;\r\n    //resize?: Options;\r\n    resizable?: JQueryUI.ResizableOptions | boolean;\r\n    onResizeStart?: ResizableEvent;\r\n    whileResizing?: ResizableEvent;\r\n    onResizeEnd?: ResizableEvent;\r\n    transformMode?: boolean; // if true uses transform: translate() instead of pos:absolute; left; & top;\r\n\r\n    //rotateOptions?: Options;\r\n    //rotate?: Options;\r\n    rotatable?: GObject | boolean;\r\n    onRotationStart?: RotatableEvent;\r\n    whileRotating?: RotatableEvent;\r\n    onRotationEnd?: RotatableEvent;\r\n}\r\n// private\r\ninterface MeasurableStateProps {\r\n    // propsFromReduxStateOrOtherKindOfStateManagement: boolean; // flux or custom things too, unrelated to this.state of react.\r\n}\r\n\r\n// private\r\ninterface DispatchProps {\r\n    // propsFromReduxActions: typeof funzioneTriggeraAzioneDaImportare;\r\n}\r\n\r\n\r\n// private\r\ntype MeasurableAllProps = MeasurableOwnProps & MeasurableStateProps & DispatchProps;\r\n\r\n////// mapper func\r\n/*\r\nfunction mapStateToProps(state: DState, ownProps: MeasurableOwnProps): MeasurableStateProps {\r\n    const ret: MeasurableStateProps = {} as any;\r\n    /// to fill\r\n    return ret; }\r\n\r\nfunction mapDispatchToProps(dispatch: Dispatch<any>): DispatchProps {\r\n    const ret: DispatchProps = {} as any;\r\n    /// to fill\r\n    return ret; }\r\n*/\r\n\r\n(MeasurableComponent as any).defaultProps = {\r\n    autosizex: true,\r\n    autosizey: true,\r\n    style: undefined,\r\n    children: [],\r\n} as MeasurableOwnProps;\r\n\r\nexport class InfiniteScrollComponent extends Component<any, any>{ }\r\n\r\nexport function Measurable(props: MeasurableAllProps, children: ReactChild[] = []): ReactElement {\r\n    return <MeasurableComponent {...{...props, children}}>{children}</MeasurableComponent>;\r\n}\r\n// todo: shortcuts for Draggable Resizable Rotatable with whileDragging onDragStart props simplified to start, while, end\r\nexport function InfiniteScroll(props: MeasurableAllProps, children: ReactChild[] = []): ReactElement {\r\n    return <Measurable {...{...props, children}} transformMode={false} onChildren={true}>{children}</Measurable>;\r\n}/*\r\nexport function InfiniteScroll(props: MeasurableAllProps, children: ReactChild[] = []): ReactElement {\r\n    return <InfiniteScrollComponent {...{...props, children}}>{children}</InfiniteScrollComponent>;\r\n}*/\r\n\r\n/*connect<MeasurableStateProps, DispatchProps, MeasurableOwnProps, DState>(\r\n    mapStateToProps,\r\n    mapDispatchToProps\r\n)(MeasurableComponent);*/\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}