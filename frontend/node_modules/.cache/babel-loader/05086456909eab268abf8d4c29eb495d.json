{"ast":null,"code":"var _dec, _class, _class2;\n// npm i react-json-view\nimport React from \"react\";\nimport withReactContent from \"sweetalert2-react-content\";\nimport Swal from \"sweetalert2\";\nimport { U, Log, GraphElementComponent, windoww, RuntimeAccessible, EdgeComponent, transientProperties, JSXT } from \"../joiner\";\n// U-functions that require jsx\nexport let UX = (_dec = RuntimeAccessible('UX'), _dec(_class = (_class2 = class UX {\n  static recursiveMap(children, fn) {\n    let depthIndices = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n    // NB: depthIndices is correct but if there is an expression children evaluated to false like {false && <jsx>},\n    // it counts as children iterated regardless. so html indices might be apparently off, but like this is even safer as indices won't change when conditions are changed.\n    const innermap = (child, i1, depthIndices) => {\n      if (! /*#__PURE__*/React.isValidElement(child)) {\n        if (Array.isArray(child)) return React.Children.map(child, (c, i3) => innermap(c, i3, [...depthIndices, i3]));\n        if (child && typeof child === \"object\") {\n          var _child;\n          if (!windoww.invalidObjsReact) windoww.invalidObjsReact = [];\n          windoww.invalidObjsReact.push(child);\n          return \"<! Objects cannot be rendered in jsx : \" + ((_child = child) === null || _child === void 0 ? void 0 : _child.name) + \">\";\n        }\n        return child;\n      }\n      if (child.props.children) {\n        // let deeperDepthIndices = [...depthIndices, i1];  // depthIndices; //\n        // should probably change deeperDepthIndices in [...deeperDepthIndices, i] in next uncommented line.\n        // Giordano: add ignore for webpack\n        //@ts-ignore\n        child = /*#__PURE__*/React.cloneElement(child, {\n          children: UX.recursiveMap(child.props.children, (e, i2, ii) => fn(e, i2, ii), depthIndices)\n        });\n        // this can be optimized, and i think i can avoid cloning here, as the nodes are already cloned in \"fn\" = ux.injectprops\n      }\n\n      return fn(child, i1, depthIndices);\n    };\n    if (!Array.isArray(children)) return innermap(children, 0, [...depthIndices, 0]);\n    // if (typeof children[0] === \"object\") return (children).map( (c: T, i3: number)=>innermap(c, i3, [...depthIndices,i3])) as any as T;\n    return React.Children.map(children, (c, i3) => innermap(c, i3, [...depthIndices, i3]));\n  }\n  static injectProp(parentComponent, e, gvidmap_useless, parentnodeid, index, indices, injectOffset) {\n    var _WrappedComponent, _parentComponent$prop, _parentComponent$prop2, _parentComponent$prop3, _parentComponent$prop4, _re$props$data, _re$props$initialSize, _re$props$startingSiz, _WrappedComponent2;\n    let re = UX.ReactNodeAsElement(e);\n\n    // injectOffset&&console.log(\"inject offset props 1:\", {e, re, injectOffset});\n    if (!re) return e;\n    // @ts-ignore this\n    // const parentComponent = this;\n    const type = ((_WrappedComponent = re.type.WrappedComponent) === null || _WrappedComponent === void 0 ? void 0 : _WrappedComponent.name) || re.type;\n    let injectProps = {};\n    if (injectOffset) {\n      var _re$props;\n      const style = {\n        ...(((_re$props = re.props) === null || _re$props === void 0 ? void 0 : _re$props.style) || {})\n      };\n      let offset = injectOffset.offset;\n      let scale = injectOffset.zoom;\n      style.position = \"absolute\";\n      style.left = offset.x;\n      style.top = offset.y;\n      style.transform = \"scale(\" + scale.x + \",\" + scale.y + \")\";\n      injectProps.style = style;\n      console.log(\"inject offset props:\", {\n        re,\n        injectProps\n      });\n    }\n    //  fix the injection somehow. override Edge() Vertex() Asterisk() ...\n    // const windoww = window as any;\n    // console.log('ux.injectingProp pre ', {type: (re.type as any).WrappedComponent?.name || re.type}, {mycomponents: windoww.mycomponents, re, props:re.props});\n    // add \"view\" (view id) prop as default to sub-elements of any depth to inherit the view of the parent unless the user forced another view to apply\n    switch (type) {\n      default:\n        // console.count('ux.injectingProp case default: ' + type);\n        if (indices.length <= 2 && (parentComponent === null || parentComponent === void 0 ? void 0 : (_parentComponent$prop = parentComponent.props) === null || _parentComponent$prop === void 0 ? void 0 : _parentComponent$prop.childStyle)) {\n          // if first non-component child of a GraphElement with a clipPath shape, i assign clip path to it.\n          console.log('injecting to first child (A):', {\n            re,\n            indices,\n            il: indices.length,\n            pc: parentComponent,\n            injectProps,\n            cs: parentComponent.props.childStyle\n          });\n          let istyle = injectProps.style = {\n            ...(injectProps.style || {})\n          };\n          injectProps.style = injectProps.style ? {\n            ...injectProps.style\n          } : {};\n          U.objectMergeInPlace(injectProps.style, parentComponent.props.childStyle);\n        } else return re;\n        break;\n      /*\r\n      case windoww.Components.Input.name:\r\n      case windoww.Components.Textarea.name:\r\n          const objid =  re.props.obj?.id || re.props.obj || parentComponent.props.data.id;\r\n          const ret = React.cloneElement(re, {key: re.props.key || parentComponent.props.view.id + '_' + parentComponent.props.data.id + '_' + re.props.field, obj: objid, obj2: objid});\r\n          //console.log('relement Input set props',\r\n          //    {'re.props.obj.id': re.props.obj?.id, 're.props.obj': re.props.obj, 'thiss.props.data.id': thiss.props.data.id, thiss, re, objid, ret, 'ret.props': ret.props});\r\n          return ret;*/\n      // case windoww.Components.GraphElement.name:\n      case windoww.Components.Input.cname + \"Component\":\n      case windoww.Components.Select.cname + \"Component\":\n      case windoww.Components.TextArea.cname + \"Component\":\n        // todo: can i do a injector that if the user provides a ModelElement list raw <div>{this.children}</div> it wraps them in DefaultNode?\n        const injectProps2 = {};\n        const parentnodeid = (_parentComponent$prop2 = parentComponent.props.node) === null || _parentComponent$prop2 === void 0 ? void 0 : _parentComponent$prop2.id;\n        injectProps2.data = re.props.data || (typeof parentComponent.props.data === \"string\" ? parentComponent.props.data : (_parentComponent$prop3 = parentComponent.props.data) === null || _parentComponent$prop3 === void 0 ? void 0 : _parentComponent$prop3.id);\n        // !IMPORTANT! this key does not remove the responsability of adding keys to <GraphElement>s. this is assigning the key to the first returned element by component A,\n        // but react needs to distinguish component A from other components, and he still doesn't have a key. in fact this is useless as this component can only have 1 child\n        injectProps2.key = re.props.key || parentnodeid + \"^input_\" + index;\n        return /*#__PURE__*/React.cloneElement(re, injectProps2);\n      case windoww.Components.GraphElementComponent.cname:\n      // case windoww.Components.DefaultNode.name:\n      case windoww.Components.DefaultNodeComponent.cname:\n      // case windoww.Components.Graph.name:\n      // case windoww.Components.GraphComponent.cname:\n      case \"Graph\":\n      case \"GraphComponent\":\n      // case windoww.Components.Field.name:\n      // case windoww.Components.FieldComponent.cname:\n      // case windoww.Components.Vertex.name:\n      case EdgeComponent.cname:\n      case windoww.Components.VertexComponent.cname:\n        injectProps.parentViewId = parentComponent.props.view.id || parentComponent.props.view; // re.props.view ||  thiss.props.view\n        injectProps.parentnodeid = (_parentComponent$prop4 = parentComponent.props.node) === null || _parentComponent$prop4 === void 0 ? void 0 : _parentComponent$prop4.id;\n        injectProps.graphid = parentComponent.props.graphid;\n        // const vidmap = GraphElementRaw.graphVertexID_counter;\n        // if (!vidmap[injectProps.graphid]) vidmap[injectProps.graphid] = {};\n        // const gvidmap = vidmap[injectProps.graphid];\n        // const validVertexIdCondition = (id: string): boolean => gvidmap_useless[id];\n        // todo: come butto dei sotto-vertici dentro un vertice contenitore? o dentro un sotto-grafo? senza modificare il jsx ma solo draggando? React-portals?\n        const dataid = (typeof re.props.data === \"string\" ? re.props.data : (_re$props$data = re.props.data) === null || _re$props$data === void 0 ? void 0 : _re$props$data.id) || \"shapeless\";\n        let idbasename;\n        console.log('injecting props ' + type, {\n          re,\n          pc: parentComponent,\n          injectProps,\n          ownProps: re.props\n        });\n        if ((_re$props$initialSize = re.props.initialSize) === null || _re$props$initialSize === void 0 ? void 0 : _re$props$initialSize.id) {\n          var _re$props$initialSize2;\n          idbasename = (_re$props$initialSize2 = re.props.initialSize) === null || _re$props$initialSize2 === void 0 ? void 0 : _re$props$initialSize2.id;\n        } else if (re.props.nodeid) {\n          idbasename = re.props.nodeid;\n        } else if (re.props.id) {\n          idbasename = re.props.id;\n        } else if (re.props.key) {\n          idbasename = injectProps.parentnodeid + \"^\" + re.props.key;\n        } else switch (type) {\n          default:\n            idbasename = injectProps.parentnodeid + \"^\" + dataid + \"N\";\n            break;\n          case windoww.Components.EdgePoint.cname:\n            idbasename = injectProps.parentnodeid + \"^\" + (dataid || ((_re$props$startingSiz = re.props.startingSize) === null || _re$props$startingSiz === void 0 ? void 0 : _re$props$startingSiz.id) || indices.join(\",\")) + \"EP\";\n            break;\n          case EdgeComponent.cname:\n          case \"Edge\":\n            console.log('injecting props ' + type + \" without key\", {\n              re,\n              pc: parentComponent,\n              injectProps,\n              ownProps: re.props\n            });\n            let edgeProps = re.props;\n            let edgestart_id = edgeProps.start.id || edgeProps.start;\n            let edgeend_id = edgeProps.end.id || edgeProps.end;\n            idbasename = injectProps.parentnodeid + \"^\" + edgestart_id + \"~\" + edgeend_id;\n        }\n        // (injectProps.parentnodeid)+\"^\"+(dataid)+indices.join(\",\");//injectProps.graphid + '^' + dataid;\n        // console.log(\"setting nodeid\", {injectProps, props:re.props, re});\n        // Log.exDev(!injectProps.graphid || !dataid, 'vertex is missing mandatory props.', {graphid: injectProps.graphid, dataid, props: re.props});\n        Log.exDev(!injectProps.graphid, 'vertex is missing mandatory props (graphid).', {\n          graphid: injectProps.graphid,\n          dataid,\n          props: re.props\n        });\n        if (false && indices.length === 2) {\n          var _parentComponent$prop5, _parentComponent$prop6;\n          // if first component child, of a component? like (DefaultNode -> Vertex)?\n          console.log('injecting to first child (B):', {\n            re,\n            pc: parentComponent,\n            injectProps\n          });\n          if (parentComponent === null || parentComponent === void 0 ? void 0 : (_parentComponent$prop5 = parentComponent.props.style) === null || _parentComponent$prop5 === void 0 ? void 0 : _parentComponent$prop5.clipPath) injectProps.style = {\n            ...(injectProps.style || {}),\n            clipPath: (parentComponent === null || parentComponent === void 0 ? void 0 : (_parentComponent$prop6 = parentComponent.props.style) === null || _parentComponent$prop6 === void 0 ? void 0 : _parentComponent$prop6.clipPath) || ''\n          };\n        }\n        injectProps.nodeid = idbasename; // U.increaseEndingNumber(idbasename, false, false, validVertexIdCondition);\n        injectProps.htmlindex = indices[indices.length - 1]; // re.props.node ? re.props.node.htmlindex : indices[indices.length - 1];\n        injectProps.key = re.props.key || injectProps.nodeid;\n        // console.log(\"cloning jsx:\", re, injectProps);\n        Log.ex((injectProps.nodeid === injectProps.graphid || injectProps.nodeid === injectProps.parentnodeid) && type !== \"GraphComponent\", \"User manually assigned a invalid node id. please remove or change prop \\\"nodeid\\\"\", {\n          type: ((_WrappedComponent2 = re.type.WrappedComponent) === null || _WrappedComponent2 === void 0 ? void 0 : _WrappedComponent2.cname) || re.type\n        }, {\n          mycomponents: windoww.mycomponents,\n          re,\n          props: re.props\n        });\n    }\n    console.log('injecting props ' + type, {\n      re,\n      pc: parentComponent,\n      injectProps\n    });\n    return /*#__PURE__*/React.cloneElement(re, injectProps);\n  }\n  static ReactNodeAsElement(e) {\n    return e && e.type ? e : null;\n  }\n  static async deleteWithAlarm(lItem) {\n    const MySwal = withReactContent(Swal);\n    const confirm = await MySwal.fire({\n      title: \"Delete \" + lItem.toString() + \"?\",\n      showCancelButton: true,\n      confirmButtonText: \"Yes\",\n      cancelButtonText: \"No\",\n      showLoaderOnConfirm: true\n    });\n    if (confirm.value === true) {\n      lItem.delete();\n    }\n  }\n  static async info(text) {\n    const MySwal = withReactContent(Swal);\n    const confirm = await MySwal.fire({\n      title: text,\n      showCancelButton: false,\n      confirmButtonText: \"Got It\"\n    });\n  }\n  static initPropInjectionStuff() {\n    UX.graphComponents = ['GraphElement', '...more'];\n    UX.inputComponents = ['Input', 'Select', 'TextArea', '...more'];\n    UX.graphComponentsRegexp = new RegExp(UX.graphComponents.map(s => '(?:;\\\\}\\\\)\\\\]\\\\,\\\\;\\\\s)' + s + '\\\\(').join('|'));\n    UX.inputComponentRegexp = new RegExp(UX.graphComponents.map(s => '(?:;\\\\}\\\\)\\]\\\\,\\\\;\\\\s)' + s + '\\\\(').join('|'));\n    UX.viewRootProps = '\"data-viewid\": props.viewid,' + ' addStyle: (offset ? {position:\"absolute\", left:offset.x, top:offset.y/*,transform:\"scale(\"+zoom.x+\",\"+zoom.y+\")\"*/} : undefined)';\n    UX.mainViewRootProps = 'ref: component.html, id: props.nodeid, \"data-nodeid\": props.nodeid, \"data-dataid\": props.dataid,\\n' + '\"data-modelname\": data?.className || \"model-less\",' + '\"data-userselecting\": JSON.stringify(node.isSelected || {}),' + '\"data-nodetype\": node.className, ' + '\"data-parentview\": props.parentviewid, ' +\n    //'\"data-order\": node.zIndex,' +\n    'onClick: component.onClick,' + 'onContextMenu: component.onContextMenu,' + 'onMouseDown: component.onMouseDown,' + 'onMouseUp: component.onMouseUp,' + 'onMouseWheel: component.onScroll,' + 'onMouseEnter: component.onEnter,' + 'onMouseLeave: component.onLeave,' + 'tabIndex: (props as any).tabIndex || node.zIndex || -1,' + '\"data-countrenders\": component.countRenders++,' + 'decorators: otherViews,' +\n    // used in user jsx to inject decorator views\n    'classNameAdd: [(component.countRenders%2 ? \"animate-on-update-even\" : \"animate-on-update-odd\"),\"mainView\", props.viewid, ...props.viewsid].join(\",\"),' + '...this.props';\n    UX.decorativeViewRootProps += 'classNameAdd: \"decorativeView \" + props.viewid, \"data-mainview\": mainviewid';\n    return UX.graphComponents;\n  }\n  static GC_propsAdder(index) {\n    return \"nodeid: window._assignnodeid(props, \" + index + \"), key:\" + index;\n  }\n  static Input_propsAdder(index) {\n    return \"key:\" + index;\n  }\n  static injectPropsToString_addstuff(s, index, props, type, propsAdder) {\n    // move out in global scope\n    switch (s[index]) {\n      case '{':\n        // props object\n        // let propstr = JSON.stringify(propsToInjectAtRoot);\n        // propstr = propstr.substring(1, propstr.length-2);\n        s = s.substring(0, index + 1) + props + (propsAdder ? ',' + propsAdder(index) : '') + ',' + s.substring(index + 1);\n        break;\n      case 'n':\n        // null:\n        // let propstr = JSON.stringify(propsToInjectAtRoot)\n        s = s.substring(0, index) + '{' + props + (propsAdder ? ',' + propsAdder(index) : '') + '}' + s.substring(index + 4);\n        break;\n      default:\n        Log.exDevv('unexpected string in ' + type + ' props injection parser', {\n          s_pre: s.substring(index - 10, 10),\n          s_post: s.substring(index, index + 10),\n          index,\n          c: s[index],\n          fullstr: s\n        });\n        break;\n    }\n    return s;\n  }\n  // propsToInject cannot be an object because i need variable names as prop values, NOT strings, not their immediate values. so i pass a string with a list of props\n  static injectPropsToString(s, asMainView, graphComponentsProps, inputComponentProps) {\n    // non-root props are injected through Component constructors instead\n    // plan B instead: make it  \"DefaultNde({pa: \"pa\"}, [\"a\", [b,c]])\" ---> \"Root(DefaultNde, {pa: \"pa\"}, [\"a\", [b,c]]) and handle injection in Root func\n    const propsToInjectAtRoot = UX.viewRootProps + ',' + (asMainView ? UX.mainViewRootProps : UX.decorativeViewRootProps);\n    //add in context: component = (this as GraphElementComponent), otherViews\n    // 'style: {...viewStyle, ...styleoverride},' + need to fix this\n    // 'className: classes.join(\\' \\'),' + and this\n    // and otherViews as ReactNode[]\n    // context.mainviewid (different from context.view in decorative views)\n    s = s.trim();\n    if (propsToInjectAtRoot.length) {\n      let argStartIndex = s.indexOf('(', 1) + 1; //.match(/[A-Za-z_$0-9]+\\(/)\n      // todo: hamdle props.addstyle\n      // add im props: offset: this.props.isGraph ££ this.props.ode.offset, zoom: this.props.isGraph ££ this.props.ode.zoom\n\n      if (s[argStartIndex] === \"'\") argStartIndex = s.indexOf(\"'\", argStartIndex + 1); // it is a lowercase component with name as string in first param\n      s = UX.injectPropsToString_addstuff(s, argStartIndex, propsToInjectAtRoot, 'root');\n\n      // used in GC_propsAdder as a string to be eval-ed\n      window._assignnodeid = function _assignnodeid(props, index) {\n        const tnv = transientProperties.node[props.nodeid].viewScores[props.viewid];\n        if (!tnv.nodeidcounter) tnv.nodeidcounter = {};\n        if (tnv.nodeidcounter[index] === undefined) tnv.nodeidcounter[index] = 0;else tnv.nodeidcounter[index]++;\n        return props.nodeid + '^' + index + '.' + tnv.nodeidcounter[index];\n        // every time before jsx render, \" let nc = transientProperties.node[props.nodeid].viewScores[props.viewid].nodeidcounter; for (let k of nc) nc[k]=0; or just nodeidcounter={}\n      };\n    }\n\n    // lowercase, no props          React.createElement('defaultNde', null, [\"a\", [a,b,c]])\n    // uppercase, ++ props          DefaultNde({pa: \"pa\", pb: b, pc: \"c\"}, [\"a\", [a,b,c]])\n    // lowercase, ++ props          React.createElement('defaultNde', {a: \"1\"}, [\"a\", [a,b,c]])\n    // uppercase, no props          DefaultNde(null, [\"a\", [a,b,c]])\n    // might have () wrapping all\n    // or array wrapping all\n    // or comments (both inline and line)\n    // or even a string at beginning\n    // nightmare case is:          `([\"a()\", /*comment()*/ React.createElement('defaultNde', {a: \"1\"}, [\"a\", [a,b,c]]),2])`\n    // !! fix: force users to have < as first char?? and editor tells it's wrong if this is not the case?\n    // that forces mono-root, but arrays would be hard to inject root-level props and prone to break anyway\n    let match;\n    //here i give up, because i cannot compute nodeid without htmlindex[] from root to component\n    // cannot even get nodeid according to jsxstr position because of loops / map generate multiple nodes from same string index\n    // NO! i can do srtindex+counters[strindex]++?\n    //\n\n    graphComponentsProps = 'parentnodeid: props.nodeid, graphid:this.props.node.className.indexOf(\"Graph\")>=0 ? props.nodeid : props.graphid,' + ' parentViewId:props.viewid'; // + dynamically: 'nodeid, key' // - removed: htmlindex\n    inputComponentProps = 'data: props.data, field:\"name\"'; // + dynamically: 'key'\n\n    if (graphComponentsProps.length > 0) while (match = UX.graphComponentsRegexp.exec(s)) {\n      let matchstr = match[0];\n      //let pre = s.substring(0, match.index) + matchstr;\n      let argStartIndex = match.index + matchstr.length;\n      s = UX.injectPropsToString_addstuff(s, argStartIndex, graphComponentsProps, 'graphElement', UX.GC_propsAdder);\n    }\n    if (inputComponentProps.length > 0) while (match = UX.inputComponentRegexp.exec(s)) {\n      let matchstr = match[0];\n      //let pre = s.substring(0, match.index) + matchstr;\n      let argStartIndex = match.index + matchstr.length;\n      s = UX.injectPropsToString_addstuff(s, argStartIndex, inputComponentProps, 'inputComponent', UX.Input_propsAdder);\n    }\n    return s;\n  }\n  static parseAndInject(jsxString, v) {\n    let jsxCompiled;\n    let e;\n    try {\n      jsxCompiled = JSXT.fromString(jsxString, {\n        factory: 'React.createElement'\n      });\n    } catch (ee) {\n      e = ee;\n      jsxCompiled = GraphElementComponent.displayError(e, \"JSX Syntax\", v, undefined, undefined, true);\n    }\n    console.log('jsxparse' + (e ? '_ERROR' : '_ok'), {\n      e,\n      jsxString,\n      jsxCompiled,\n      v\n    });\n    return jsxCompiled;\n  }\n}, _class2.graphComponents = _class2.initPropInjectionStuff(), _class2.inputComponents = undefined, _class2.graphComponentsRegexp = undefined, _class2.inputComponentRegexp = undefined, _class2.viewRootProps = void 0, _class2.decorativeViewRootProps = void 0, _class2.mainViewRootProps = void 0, _class2)) || _class);","map":{"version":3,"names":["React","withReactContent","Swal","U","Log","GraphElementComponent","windoww","RuntimeAccessible","EdgeComponent","transientProperties","JSXT","UX","_dec","_class","_class2","recursiveMap","children","fn","depthIndices","arguments","length","undefined","innermap","child","i1","isValidElement","Array","isArray","Children","map","c","i3","_child","invalidObjsReact","push","name","props","cloneElement","e","i2","ii","injectProp","parentComponent","gvidmap_useless","parentnodeid","index","indices","injectOffset","_WrappedComponent","_parentComponent$prop","_parentComponent$prop2","_parentComponent$prop3","_parentComponent$prop4","_re$props$data","_re$props$initialSize","_re$props$startingSiz","_WrappedComponent2","re","ReactNodeAsElement","type","WrappedComponent","injectProps","_re$props","style","offset","scale","zoom","position","left","x","top","y","transform","console","log","childStyle","il","pc","cs","istyle","objectMergeInPlace","Components","Input","cname","Select","TextArea","injectProps2","node","id","data","key","DefaultNodeComponent","VertexComponent","parentViewId","view","graphid","dataid","idbasename","ownProps","initialSize","_re$props$initialSize2","nodeid","EdgePoint","startingSize","join","edgeProps","edgestart_id","start","edgeend_id","end","exDev","_parentComponent$prop5","_parentComponent$prop6","clipPath","htmlindex","ex","mycomponents","deleteWithAlarm","lItem","MySwal","confirm","fire","title","toString","showCancelButton","confirmButtonText","cancelButtonText","showLoaderOnConfirm","value","delete","info","text","initPropInjectionStuff","graphComponents","inputComponents","graphComponentsRegexp","RegExp","s","inputComponentRegexp","viewRootProps","mainViewRootProps","decorativeViewRootProps","GC_propsAdder","Input_propsAdder","injectPropsToString_addstuff","propsAdder","substring","exDevv","s_pre","s_post","fullstr","injectPropsToString","asMainView","graphComponentsProps","inputComponentProps","propsToInjectAtRoot","trim","argStartIndex","indexOf","window","_assignnodeid","tnv","viewScores","viewid","nodeidcounter","match","exec","matchstr","parseAndInject","jsxString","v","jsxCompiled","fromString","factory","ee","displayError"],"sources":["C:/d/Programming/web/jodel-mde/src/common/UX.tsx"],"sourcesContent":["import ReactJson from 'react-json-view' // npm i react-json-view\r\nimport React, {ReactElement, ReactNode} from \"react\";\r\nimport withReactContent from \"sweetalert2-react-content\";\r\nimport Swal from \"sweetalert2\";\r\nimport type { GraphElementOwnProps, GObject, Dictionary, DocString, Pointer, LGraph } from \"../joiner\";\r\nimport type { InputOwnProps } from '../components/forEndUser/Input';\r\nimport type { SelectOwnProps } from '../components/forEndUser/Select';\r\nimport type { TextAreaOwnProps } from '../components/forEndUser/TextArea';\r\nimport {\r\n    LPointerTargetable,\r\n    U,\r\n    Log,\r\n    GraphElementComponent,\r\n    windoww,\r\n    RuntimeAccessible,\r\n    EdgeComponent,\r\n    RuntimeAccessibleClass,\r\n    EdgeOwnProps,\r\n    DGraphElement,\r\n    DModelElement,\r\n    transientProperties, JSXT, DViewElement\r\n} from \"../joiner\";\r\nimport {AllPropss} from \"../graph/vertex/Vertex\";\r\n\r\n// U-functions that require jsx\r\n@RuntimeAccessible('UX')\r\nexport class UX{\r\n\r\n    static recursiveMap<T extends ReactNode | ReactNode[] | null | undefined>(children: T, fn: (rn: T, i: number, depthIndices: number[])=>T, depthIndices: number[] = []): T {\r\n        // NB: depthIndices is correct but if there is an expression children evaluated to false like {false && <jsx>},\r\n        // it counts as children iterated regardless. so html indices might be apparently off, but like this is even safer as indices won't change when conditions are changed.\r\n        const innermap = (child: ReactNode, i1: number, depthIndices: number[]): T => {\r\n            if (!React.isValidElement(child)) {\r\n                if (Array.isArray(child)) return React.Children.map(child as T, (c: T, i3: number)=>innermap(c, i3, [...depthIndices,i3])) as T;\r\n                if (child && typeof child === \"object\") {\r\n                    if (!windoww.invalidObjsReact) windoww.invalidObjsReact = [];\r\n                    windoww.invalidObjsReact.push(child);\r\n                    return \"<! Objects cannot be rendered in jsx : \" + (child as any)?.name + \">\" as T;\r\n                }\r\n                return child as T; }\r\n            if (child.props.children) {\r\n                // let deeperDepthIndices = [...depthIndices, i1];  // depthIndices; //\r\n                // should probably change deeperDepthIndices in [...deeperDepthIndices, i] in next uncommented line.\r\n                // Giordano: add ignore for webpack\r\n                //@ts-ignore\r\n                child = React.cloneElement(child, { children: UX.recursiveMap(child.props.children,\r\n                        (e: T, i2: number, ii) => fn(e, i2, ii), depthIndices) });\r\n                // this can be optimized, and i think i can avoid cloning here, as the nodes are already cloned in \"fn\" = ux.injectprops\r\n            }\r\n            return fn(child as T, i1, depthIndices);\r\n        };\r\n        if (!Array.isArray(children)) return innermap(children as ReactNode, 0, [...depthIndices, 0]) as T;\r\n        // if (typeof children[0] === \"object\") return (children).map( (c: T, i3: number)=>innermap(c, i3, [...depthIndices,i3])) as any as T;\r\n        return React.Children.map(children, (c: T, i3: number)=>innermap(c, i3, [...depthIndices,i3])) as T;\r\n    }\r\n    static injectProp(parentComponent: GraphElementComponent, e: ReactNode, gvidmap_useless: Dictionary<DocString<'VertexID'>, boolean>,\r\n                      parentnodeid: string, index: number, indices: number[], injectOffset?: LGraph): ReactNode {\r\n        let re: ReactElement | null = UX.ReactNodeAsElement(e);\r\n\r\n        // injectOffset&&console.log(\"inject offset props 1:\", {e, re, injectOffset});\r\n        if (!re) return e;\r\n        // @ts-ignore this\r\n        // const parentComponent = this;\r\n        const type = (re.type as any).WrappedComponent?.name || re.type;\r\n        let injectProps: GraphElementOwnProps = {} as any;\r\n        if (injectOffset) {\r\n            const style = {...(re.props?.style || {})};\r\n            let offset = injectOffset.offset;\r\n            let scale = injectOffset.zoom;\r\n            style.position = \"absolute\";\r\n            style.left = offset.x;\r\n            style.top = offset.y;\r\n            style.transform = \"scale(\" + scale.x + \",\" + scale.y + \")\"\r\n            injectProps.style = style;\r\n            console.log(\"inject offset props:\", {re, injectProps});\r\n        }\r\n        //  fix the injection somehow. override Edge() Vertex() Asterisk() ...\r\n        // const windoww = window as any;\r\n        // console.log('ux.injectingProp pre ', {type: (re.type as any).WrappedComponent?.name || re.type}, {mycomponents: windoww.mycomponents, re, props:re.props});\r\n        // add \"view\" (view id) prop as default to sub-elements of any depth to inherit the view of the parent unless the user forced another view to apply\r\n        switch (type) {\r\n            default:\r\n                // console.count('ux.injectingProp case default: ' + type);\r\n                if (indices.length <= 2 && (parentComponent?.props?.childStyle)) {\r\n                    // if first non-component child of a GraphElement with a clipPath shape, i assign clip path to it.\r\n                    console.log('injecting to first child (A):', {re, indices, il: indices.length, pc: parentComponent, injectProps, cs:parentComponent.props.childStyle});\r\n                    let istyle: GObject = injectProps.style = {...(injectProps.style || {})};\r\n                    injectProps.style = injectProps.style ? {...injectProps.style} : {};\r\n                    U.objectMergeInPlace(injectProps.style, parentComponent.props.childStyle);\r\n                } else return re;\r\n                break;\r\n            /*\r\n            case windoww.Components.Input.name:\r\n            case windoww.Components.Textarea.name:\r\n                const objid =  re.props.obj?.id || re.props.obj || parentComponent.props.data.id;\r\n                const ret = React.cloneElement(re, {key: re.props.key || parentComponent.props.view.id + '_' + parentComponent.props.data.id + '_' + re.props.field, obj: objid, obj2: objid});\r\n                //console.log('relement Input set props',\r\n                //    {'re.props.obj.id': re.props.obj?.id, 're.props.obj': re.props.obj, 'thiss.props.data.id': thiss.props.data.id, thiss, re, objid, ret, 'ret.props': ret.props});\r\n                return ret;*/\r\n            // case windoww.Components.GraphElement.name:\r\n            case windoww.Components.Input.cname+\"Component\":\r\n            case windoww.Components.Select.cname+\"Component\":\r\n            case windoww.Components.TextArea.cname+\"Component\":\r\n                // todo: can i do a injector that if the user provides a ModelElement list raw <div>{this.children}</div> it wraps them in DefaultNode?\r\n                const injectProps2: InputOwnProps | SelectOwnProps | TextAreaOwnProps = {} as any;\r\n                const parentnodeid = parentComponent.props.node?.id;\r\n                injectProps2.data = re.props.data || (typeof parentComponent.props.data === \"string\" ? parentComponent.props.data : parentComponent.props.data?.id);\r\n                // !IMPORTANT! this key does not remove the responsability of adding keys to <GraphElement>s. this is assigning the key to the first returned element by component A,\r\n                // but react needs to distinguish component A from other components, and he still doesn't have a key. in fact this is useless as this component can only have 1 child\r\n                injectProps2.key = re.props.key || (parentnodeid + \"^input_\"+index);\r\n                return React.cloneElement(re, injectProps2);\r\n            case windoww.Components.GraphElementComponent.cname:\r\n            // case windoww.Components.DefaultNode.name:\r\n            case windoww.Components.DefaultNodeComponent.cname:\r\n            // case windoww.Components.Graph.name:\r\n            // case windoww.Components.GraphComponent.cname:\r\n            case \"Graph\": case \"GraphComponent\":\r\n            // case windoww.Components.Field.name:\r\n            // case windoww.Components.FieldComponent.cname:\r\n            // case windoww.Components.Vertex.name:\r\n            case EdgeComponent.cname:\r\n            case windoww.Components.VertexComponent.cname:\r\n                injectProps.parentViewId = parentComponent.props.view.id || (parentComponent.props.view as any); // re.props.view ||  thiss.props.view\r\n                injectProps.parentnodeid = parentComponent.props.node?.id;\r\n                injectProps.graphid = parentComponent.props.graphid;\r\n                // const vidmap = GraphElementRaw.graphVertexID_counter;\r\n                // if (!vidmap[injectProps.graphid]) vidmap[injectProps.graphid] = {};\r\n                // const gvidmap = vidmap[injectProps.graphid];\r\n                // const validVertexIdCondition = (id: string): boolean => gvidmap_useless[id];\r\n                // todo: come butto dei sotto-vertici dentro un vertice contenitore? o dentro un sotto-grafo? senza modificare il jsx ma solo draggando? React-portals?\r\n                const dataid = (typeof re.props.data === \"string\" ? re.props.data : re.props.data?.id) || \"shapeless\";\r\n                let idbasename: string;\r\n\r\n                console.log('injecting props ' + type, {re, pc: parentComponent, injectProps, ownProps: re.props});\r\n                if (re.props.initialSize?.id) { idbasename = re.props.initialSize?.id; } else\r\n                if (re.props.nodeid) { idbasename = re.props.nodeid; } else\r\n                if (re.props.id) { idbasename = re.props.id; } else\r\n                if (re.props.key) { idbasename = injectProps.parentnodeid + \"^\" + re.props.key; }\r\n                else switch (type) {\r\n                    default:\r\n                        idbasename = injectProps.parentnodeid + \"^\" + dataid + \"N\";\r\n                        break;\r\n                    case windoww.Components.EdgePoint.cname:\r\n                        idbasename = injectProps.parentnodeid + \"^\" + (dataid || re.props.startingSize?.id || indices.join(\",\")) + \"EP\";\r\n                        break;\r\n                    case EdgeComponent.cname: case \"Edge\":\r\n\r\n                        console.log('injecting props ' + type + \" without key\", {re, pc: parentComponent, injectProps, ownProps: re.props});\r\n                        let edgeProps:EdgeOwnProps = re.props;\r\n                        let edgestart_id: Pointer<DGraphElement> | Pointer<DModelElement> = (edgeProps.start as any).id || edgeProps.start;\r\n                        let edgeend_id: Pointer<DGraphElement> | Pointer<DModelElement> = (edgeProps.end as any).id || edgeProps.end;\r\n                        idbasename = injectProps.parentnodeid + \"^\" + edgestart_id + \"~\" + edgeend_id;\r\n                }\r\n                // (injectProps.parentnodeid)+\"^\"+(dataid)+indices.join(\",\");//injectProps.graphid + '^' + dataid;\r\n                // console.log(\"setting nodeid\", {injectProps, props:re.props, re});\r\n                // Log.exDev(!injectProps.graphid || !dataid, 'vertex is missing mandatory props.', {graphid: injectProps.graphid, dataid, props: re.props});\r\n                Log.exDev(!injectProps.graphid, 'vertex is missing mandatory props (graphid).', {graphid: injectProps.graphid, dataid, props: re.props});\r\n                if (false && indices.length === 2) {\r\n                    // if first component child, of a component? like (DefaultNode -> Vertex)?\r\n                    console.log('injecting to first child (B):', {re, pc: parentComponent, injectProps});\r\n                    if (parentComponent?.props.style?.clipPath) injectProps.style = {...(injectProps.style || {}), clipPath: parentComponent?.props.style?.clipPath||''}\r\n                }\r\n                injectProps.nodeid = idbasename; // U.increaseEndingNumber(idbasename, false, false, validVertexIdCondition);\r\n                injectProps.htmlindex = indices[indices.length - 1]; // re.props.node ? re.props.node.htmlindex : indices[indices.length - 1];\r\n                injectProps.key = re.props.key || injectProps.nodeid;\r\n                // console.log(\"cloning jsx:\", re, injectProps);\r\n                Log.ex((injectProps.nodeid === injectProps.graphid||injectProps.nodeid === injectProps.parentnodeid) && type !== \"GraphComponent\", \"User manually assigned a invalid node id. please remove or change prop \\\"nodeid\\\"\", {type: (re.type as any).WrappedComponent?.cname || re.type}, {mycomponents: windoww.mycomponents, re, props:re.props});\r\n        }\r\n        console.log('injecting props ' + type, {re, pc: parentComponent, injectProps});\r\n        return React.cloneElement(re, injectProps);\r\n    }\r\n\r\n    static ReactNodeAsElement(e: React.ReactNode): React.ReactElement | null { return e && (e as ReactElement).type ? e as ReactElement : null; }\r\n\r\n    public static async deleteWithAlarm(lItem: LPointerTargetable) {\r\n        const MySwal = withReactContent(Swal);\r\n        const confirm = await MySwal.fire({\r\n            title: \"Delete \" + lItem.toString() + \"?\",\r\n            showCancelButton: true,\r\n            confirmButtonText: \"Yes\",\r\n            cancelButtonText: \"No\",\r\n            showLoaderOnConfirm: true\r\n        });\r\n        if (confirm.value === true) {\r\n            lItem.delete();\r\n        }\r\n    }\r\n    public static async info(text: string) {\r\n        const MySwal = withReactContent(Swal);\r\n        const confirm = await MySwal.fire({\r\n            title: text,\r\n            showCancelButton: false,\r\n            confirmButtonText: \"Got It\"\r\n        });\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    private static initPropInjectionStuff(): string[]{\r\n        UX.graphComponents = ['GraphElement', '...more'];\r\n        UX.inputComponents = ['Input', 'Select', 'TextArea','...more'];\r\n        UX.graphComponentsRegexp = new RegExp(UX.graphComponents.map(s=>'(?:;\\\\}\\\\)\\\\]\\\\,\\\\;\\\\s)'+s+'\\\\(').join('|'));\r\n        UX.inputComponentRegexp = new RegExp(UX.graphComponents.map(s=>'(?:;\\\\}\\\\)\\]\\\\,\\\\;\\\\s)'+s+'\\\\(').join('|'));\r\n        UX.viewRootProps = '\"data-viewid\": props.viewid,' +\r\n            ' addStyle: (offset ? {position:\"absolute\", left:offset.x, top:offset.y/*,transform:\"scale(\"+zoom.x+\",\"+zoom.y+\")\"*/} : undefined)';\r\n        UX.mainViewRootProps = 'ref: component.html, id: props.nodeid, \"data-nodeid\": props.nodeid, \"data-dataid\": props.dataid,\\n' +\r\n            '\"data-modelname\": data?.className || \"model-less\",' +\r\n            '\"data-userselecting\": JSON.stringify(node.isSelected || {}),' +\r\n            '\"data-nodetype\": node.className, ' +\r\n            '\"data-parentview\": props.parentviewid, ' +\r\n            //'\"data-order\": node.zIndex,' +\r\n            'onClick: component.onClick,' +\r\n            'onContextMenu: component.onContextMenu,' +\r\n            'onMouseDown: component.onMouseDown,' +\r\n            'onMouseUp: component.onMouseUp,' +\r\n            'onMouseWheel: component.onScroll,' +\r\n            'onMouseEnter: component.onEnter,' +\r\n            'onMouseLeave: component.onLeave,' +\r\n            'tabIndex: (props as any).tabIndex || node.zIndex || -1,' +\r\n            '\"data-countrenders\": component.countRenders++,' +\r\n            'decorators: otherViews,'+// used in user jsx to inject decorator views\r\n            'classNameAdd: [(component.countRenders%2 ? \"animate-on-update-even\" : \"animate-on-update-odd\"),\"mainView\", props.viewid, ...props.viewsid].join(\",\"),' +\r\n            '...this.props';\r\n        UX.decorativeViewRootProps +='classNameAdd: \"decorativeView \" + props.viewid, \"data-mainview\": mainviewid';\r\n        return UX.graphComponents\r\n    }\r\n    private static graphComponents: string[] = UX.initPropInjectionStuff();\r\n    private static inputComponents: string[] = undefined as any;\r\n    private static graphComponentsRegexp: RegExp = undefined as any;\r\n    private static inputComponentRegexp: RegExp = undefined as any;\r\n    private static GC_propsAdder(index: number): string { return \"nodeid: window._assignnodeid(props, \"+index+\"), key:\"+index; }\r\n    private static Input_propsAdder(index: number):string { return \"key:\"+index; }\r\n    private static injectPropsToString_addstuff(s: string, index: number, props: string, type: string, propsAdder?:((index: number)=>string) | undefined): string { // move out in global scope\r\n        switch (s[index]) {\r\n            case '{': // props object\r\n                // let propstr = JSON.stringify(propsToInjectAtRoot);\r\n                // propstr = propstr.substring(1, propstr.length-2);\r\n                s = s.substring(0, index+1) + props + (propsAdder ? ','+propsAdder(index) : '') + ',' + s.substring(index+1);\r\n                break;\r\n            case 'n': // null:\r\n                // let propstr = JSON.stringify(propsToInjectAtRoot)\r\n                s = s.substring(0, index) + '{'+props+(propsAdder ? ','+propsAdder(index) : '') + '}' + s.substring(index+4);\r\n                break;\r\n            default: Log.exDevv('unexpected string in '+type+' props injection parser',\r\n                {s_pre:s.substring(index-10, 10), s_post:s.substring(index, index+10), index, c:s[index], fullstr:s});\r\n                break;\r\n        }\r\n        return s;\r\n    }\r\n    private static viewRootProps: string;\r\n    private static decorativeViewRootProps: string;\r\n    private static mainViewRootProps: string;\r\n// propsToInject cannot be an object because i need variable names as prop values, NOT strings, not their immediate values. so i pass a string with a list of props\r\n    static injectPropsToString(s: string, asMainView:boolean, graphComponentsProps: string, inputComponentProps: string){\r\n        // non-root props are injected through Component constructors instead\r\n        // plan B instead: make it  \"DefaultNde({pa: \"pa\"}, [\"a\", [b,c]])\" ---> \"Root(DefaultNde, {pa: \"pa\"}, [\"a\", [b,c]]) and handle injection in Root func\r\n        const propsToInjectAtRoot = UX.viewRootProps + ','+(asMainView ? UX.mainViewRootProps : UX.decorativeViewRootProps);\r\n        //add in context: component = (this as GraphElementComponent), otherViews\r\n        // 'style: {...viewStyle, ...styleoverride},' + need to fix this\r\n        // 'className: classes.join(\\' \\'),' + and this\r\n        // and otherViews as ReactNode[]\r\n        // context.mainviewid (different from context.view in decorative views)\r\n        s = s.trim();\r\n        if (propsToInjectAtRoot.length) {\r\n            let argStartIndex = s.indexOf('(', 1) + 1;//.match(/[A-Za-z_$0-9]+\\(/)\r\n            // todo: hamdle props.addstyle\r\n            // add im props: offset: this.props.isGraph ££ this.props.ode.offset, zoom: this.props.isGraph ££ this.props.ode.zoom\r\n\r\n            if (s[argStartIndex] === \"'\") argStartIndex = s.indexOf(\"'\", argStartIndex+1);// it is a lowercase component with name as string in first param\r\n            s = UX.injectPropsToString_addstuff(s, argStartIndex, propsToInjectAtRoot, 'root');\r\n\r\n            // used in GC_propsAdder as a string to be eval-ed\r\n            (window as any)._assignnodeid = function _assignnodeid(props: AllPropss, index:number): string {\r\n                const tnv = transientProperties.node[props.nodeid].viewScores[props.viewid];\r\n                if (!tnv.nodeidcounter) tnv.nodeidcounter = {};\r\n                if (tnv.nodeidcounter[index] === undefined) tnv.nodeidcounter[index] = 0;\r\n                else tnv.nodeidcounter[index]++;\r\n\r\n                return props.nodeid+'^'+index+'.'+tnv.nodeidcounter[index];\r\n                // every time before jsx render, \" let nc = transientProperties.node[props.nodeid].viewScores[props.viewid].nodeidcounter; for (let k of nc) nc[k]=0; or just nodeidcounter={}\r\n            }\r\n        }\r\n\r\n        // lowercase, no props          React.createElement('defaultNde', null, [\"a\", [a,b,c]])\r\n        // uppercase, ++ props          DefaultNde({pa: \"pa\", pb: b, pc: \"c\"}, [\"a\", [a,b,c]])\r\n        // lowercase, ++ props          React.createElement('defaultNde', {a: \"1\"}, [\"a\", [a,b,c]])\r\n        // uppercase, no props          DefaultNde(null, [\"a\", [a,b,c]])\r\n        // might have () wrapping all\r\n        // or array wrapping all\r\n        // or comments (both inline and line)\r\n        // or even a string at beginning\r\n        // nightmare case is:          `([\"a()\", /*comment()*/ React.createElement('defaultNde', {a: \"1\"}, [\"a\", [a,b,c]]),2])`\r\n        // !! fix: force users to have < as first char?? and editor tells it's wrong if this is not the case?\r\n        // that forces mono-root, but arrays would be hard to inject root-level props and prone to break anyway\r\n        let match: RegExpExecArray | null;\r\n        //here i give up, because i cannot compute nodeid without htmlindex[] from root to component\r\n        // cannot even get nodeid according to jsxstr position because of loops / map generate multiple nodes from same string index\r\n        // NO! i can do srtindex+counters[strindex]++?\r\n        //\r\n\r\n        graphComponentsProps = 'parentnodeid: props.nodeid, graphid:this.props.node.className.indexOf(\"Graph\")>=0 ? props.nodeid : props.graphid,' +\r\n            ' parentViewId:props.viewid';// + dynamically: 'nodeid, key' // - removed: htmlindex\r\n        inputComponentProps = 'data: props.data, field:\"name\"'; // + dynamically: 'key'\r\n\r\n        if (graphComponentsProps.length > 0) while (match = UX.graphComponentsRegexp.exec(s)) {\r\n            let matchstr: string = match[0];\r\n            //let pre = s.substring(0, match.index) + matchstr;\r\n            let argStartIndex = match.index + matchstr.length;\r\n            s = UX.injectPropsToString_addstuff(s, argStartIndex, graphComponentsProps, 'graphElement', UX.GC_propsAdder);\r\n        }\r\n        if (inputComponentProps.length > 0) while (match = UX.inputComponentRegexp.exec(s)) {\r\n            let matchstr: string = match[0];\r\n            //let pre = s.substring(0, match.index) + matchstr;\r\n            let argStartIndex = match.index + matchstr.length;\r\n            s = UX.injectPropsToString_addstuff(s, argStartIndex, inputComponentProps, 'inputComponent', UX.Input_propsAdder);\r\n        }\r\n        return s;\r\n    }\r\n\r\n    static parseAndInject(jsxString: string, v: DViewElement): string {\r\n        let jsxCompiled: DocString<ReactNode>;\r\n        let e: any;\r\n        try { jsxCompiled = JSXT.fromString(jsxString, {factory: 'React.createElement'}); }\r\n        catch (ee: any) { e = ee; jsxCompiled = GraphElementComponent.displayError(e, \"JSX Syntax\", v, undefined, undefined, true) as any; }\r\n        console.log('jsxparse' + (e ? '_ERROR' : '_ok'), {e, jsxString, jsxCompiled, v});\r\n        return jsxCompiled;\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}