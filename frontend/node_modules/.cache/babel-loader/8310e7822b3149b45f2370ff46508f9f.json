{"ast":null,"code":"export class GraphElementStatee {/*\r\n                                 constructor(preRenderFunc: string | undefined, evalContext: GObject, templatefunc: () => React.ReactNode) {\r\n                                 this.preRenderFunc = preRenderFunc;\r\n                                 this.evalContext = evalContext;\r\n                                 this.template = templatefunc;\r\n                                 }\r\n                                 preRenderFunc?: string;\r\n                                 evalContext: Json;\r\n                                 template: () => ReactNode;* /\r\n                                 nodeid: Pointer<DGraphElement, 1, 1, LGraphElement>;\r\n                                 constructor(nodeid: Pointer<DGraphElement, 1, 1, LGraphElement>) {\r\n                                 this.nodeid = nodeid;\r\n                                 }*/\n  // displayPosition?: GraphSize; // used while dragging to prevent flood of redux events\n}\nexport class GraphElementReduxStateProps {\n  constructor() {\n    this.view = void 0;\n    this.views = void 0;\n    this.data = void 0;\n    this.preRenderFunc = void 0;\n    this.evalContext = void 0;\n    this.template = void 0;\n    this.node = void 0;\n    this.graph = void 0;\n  } // userexample?: UserState; // todo: make and repace with proxy wrapper \"User\", or make a \"cached\" global variable synchronized with redux state for easier access\n  // all applicable views\n  // graphID!: string;\n  // model?: LModel;\n  // [userMappedFromRedux: string]: any; // roba che l'utente ha dichiarato di voler prendere dallo stato e redux gli carica nelle props\n}\nexport class GraphElementDispatchProps {}\nexport class GraphElementOwnProps {\n  constructor() {\n    this.data = void 0;\n    this.view = void 0;\n    this.children = void 0;\n    this.style = void 0;\n    this['class'] = void 0;\n    this['className'] = void 0;\n    this.key = void 0;\n    this.parentnodeid = void 0;\n    this.nodeid = void 0;\n    this.graphid = void 0;\n    this.parentViewId = void 0;\n  } // | LViewElement\n  // generic props for every component that this component will need to extend joining user-specified values and component-specific built-in values\n  // Injected\n  // Injected\n  // injected\n  // injected\n}","map":{"version":3,"names":["GraphElementStatee","GraphElementReduxStateProps","constructor","view","views","data","preRenderFunc","evalContext","template","node","graph","GraphElementDispatchProps","GraphElementOwnProps","children","style","key","parentnodeid","nodeid","graphid","parentViewId"],"sources":["C:/0Programmi/Dev/projects/frontend/jjodel/src/graph/graphElement/sharedTypes/sharedTypes.tsx"],"sourcesContent":["import React, {CSSProperties, ReactNode} from \"react\";\r\nimport type {\r\n    DGraph,\r\n    DGraphElement,\r\n    DModelElement,\r\n    DViewElement,\r\n    Json,\r\n    LGraph,\r\n    LGraphElement,\r\n    LModelElement,\r\n    LViewElement,\r\n    Pointer\r\n} from \"../../../joiner\";\r\n\r\nexport class GraphElementStatee {/*\r\n    constructor(preRenderFunc: string | undefined, evalContext: GObject, templatefunc: () => React.ReactNode) {\r\n        this.preRenderFunc = preRenderFunc;\r\n        this.evalContext = evalContext;\r\n        this.template = templatefunc;\r\n    }\r\n    preRenderFunc?: string;\r\n    evalContext: Json;\r\n    template: () => ReactNode;* /\r\n    nodeid: Pointer<DGraphElement, 1, 1, LGraphElement>;\r\n    constructor(nodeid: Pointer<DGraphElement, 1, 1, LGraphElement>) {\r\n        this.nodeid = nodeid;\r\n    }*/\r\n    // displayPosition?: GraphSize; // used while dragging to prevent flood of redux events\r\n}\r\n\r\nexport class GraphElementReduxStateProps {\r\n    // userexample?: UserState; // todo: make and repace with proxy wrapper \"User\", or make a \"cached\" global variable synchronized with redux state for easier access\r\n    view!: LViewElement;\r\n    views!: LViewElement[]; // all applicable views\r\n    // graphID!: string;\r\n    data!: LModelElement;\r\n    // model?: LModel;\r\n    // [userMappedFromRedux: string]: any; // roba che l'utente ha dichiarato di voler prendere dallo stato e redux gli carica nelle props\r\n    preRenderFunc?: string;\r\n    evalContext!: Json;\r\n    template!: () => ReactNode;\r\n    node!: LGraphElement;\r\n    graph!: LGraph;\r\n}\r\n\r\nexport class GraphElementDispatchProps {\r\n}\r\n\r\nexport class GraphElementOwnProps {\r\n    data?: Pointer<DModelElement, 0, 1, LModelElement>;\r\n    view?:Pointer<DViewElement, 1, 1, LViewElement>; // | LViewElement\r\n    // generic props for every component that this component will need to extend joining user-specified values and component-specific built-in values\r\n    children?: any;\r\n    style?: CSSProperties;\r\n    'class'?: string | string[];\r\n    'className'?: string | string[];\r\n    key?: string;\r\n    parentnodeid?: Pointer<DGraphElement, 1, 1, LGraphElement>; // Injected\r\n    nodeid?: Pointer<DGraphElement, 1, 1, LGraphElement>; // Injected\r\n    graphid?: Pointer<DGraph, 1, 1, LGraph>; // injected\r\n    parentViewId?: Pointer<DViewElement, 1, 1, LViewElement>// injected\r\n}\r\n"],"mappings":"AAcA,OAAO,MAAMA,kBAAkB,CAAC,CAAC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI;AAAA;AAGJ,OAAO,MAAMC,2BAA2B,CAAC;EAAAC,YAAA;IAAA,KAErCC,IAAI;IAAA,KACJC,KAAK;IAAA,KAELC,IAAI;IAAA,KAGJC,aAAa;IAAA,KACbC,WAAW;IAAA,KACXC,QAAQ;IAAA,KACRC,IAAI;IAAA,KACJC,KAAK;EAAA,EAXL;EAEwB;EACxB;EAEA;EACA;AAMJ;AAEA,OAAO,MAAMC,yBAAyB,CAAC;AAGvC,OAAO,MAAMC,oBAAoB,CAAC;EAAAV,YAAA;IAAA,KAC9BG,IAAI;IAAA,KACJF,IAAI;IAAA,KAEJU,QAAQ;IAAA,KACRC,KAAK;IAAA,KACL,OAAO;IAAA,KACP,WAAW;IAAA,KACXC,GAAG;IAAA,KACHC,YAAY;IAAA,KACZC,MAAM;IAAA,KACNC,OAAO;IAAA,KACPC,YAAY;EAAA,EAVqC;EACjD;EAM4D;EACN;EACb;EACe;AAC5D","ignoreList":[]},"metadata":{},"sourceType":"module"}