{"ast":null,"code":"import React from \"react\";\nimport { DockContextType } from \"./DockData\";\nimport { DragDropDiv } from \"./dragdrop/DragDropDiv\";\nimport { DragState } from \"./dragdrop/DragManager\";\nexport class DockDropEdge extends React.PureComponent {\n  constructor() {\n    super(...arguments);\n    this.getRef = r => {\n      this._ref = r;\n    };\n    this.onDragOver = e => {\n      var _a;\n      let {\n        panelData,\n        panelElement,\n        dropFromPanel\n      } = this.props;\n      let dockId = this.context.getDockId();\n      let draggingPanel = DragState.getData('panel', dockId);\n      let fromGroup = this.context.getGroup(dropFromPanel.group);\n      if (draggingPanel && ((_a = draggingPanel.parent) === null || _a === void 0 ? void 0 : _a.mode) === 'float') {\n        // ignore float panel in edge mode\n        return;\n      }\n      let {\n        direction,\n        mode,\n        depth\n      } = this.getDirection(e, fromGroup, draggingPanel === panelData);\n      depth = this.getActualDepth(depth, mode, direction);\n      if (!direction || direction === 'float' && dropFromPanel.panelLock) {\n        this.context.setDropRect(null, 'remove', this);\n        return;\n      }\n      let targetElement = panelElement;\n      for (let i = 0; i < depth; ++i) {\n        targetElement = targetElement.parentElement;\n      }\n      let panelSize = DragState.getData('panelSize', dockId);\n      this.context.setDropRect(targetElement, direction, this, e, panelSize);\n      e.accept('');\n    };\n    this.onDragLeave = e => {\n      this.context.setDropRect(null, 'remove', this);\n    };\n    this.onDrop = e => {\n      let {\n        panelData,\n        dropFromPanel\n      } = this.props;\n      let dockId = this.context.getDockId();\n      let fromGroup = this.context.getGroup(dropFromPanel.group);\n      let source = DragState.getData('tab', dockId);\n      let draggingPanel = DragState.getData('panel', dockId);\n      if (!source) {\n        source = draggingPanel;\n      }\n      if (source) {\n        let {\n          direction,\n          mode,\n          depth\n        } = this.getDirection(e, fromGroup, draggingPanel === panelData);\n        depth = this.getActualDepth(depth, mode, direction);\n        if (!direction) {\n          return;\n        }\n        let target = panelData;\n        for (let i = 0; i < depth; ++i) {\n          target = target.parent;\n        }\n        this.context.dockMove(source, target, direction);\n      }\n    };\n  }\n  getDirection(e, group, samePanel) {\n    let rect = this._ref.getBoundingClientRect();\n    let widthRate = Math.min(rect.width, 500);\n    let heightRate = Math.min(rect.height, 500);\n    let left = (e.clientX - rect.left) / widthRate;\n    let right = (rect.right - e.clientX) / widthRate;\n    let top = (e.clientY - rect.top) / heightRate;\n    let bottom = (rect.bottom - e.clientY) / heightRate;\n    let min = Math.min(left, right, top, bottom);\n    let depth = 0;\n    if (group.disableDock || samePanel) {\n      // use an impossible min value to disable dock drop\n      min = 1;\n    }\n    if (min < 0) {\n      return {\n        direction: null,\n        depth: 0\n      };\n    } else if (min < 0.075) {\n      depth = 3; // depth 3 or 4\n    } else if (min < 0.15) {\n      depth = 1; // depth 1 or 2\n    } else if (min < 0.3) {\n      // default\n    } else if (group.floatable) {\n      return {\n        direction: 'float',\n        mode: 'float',\n        depth: 0\n      };\n    }\n    switch (min) {\n      case left:\n        {\n          return {\n            direction: 'left',\n            mode: 'horizontal',\n            depth\n          };\n        }\n      case right:\n        {\n          return {\n            direction: 'right',\n            mode: 'horizontal',\n            depth\n          };\n        }\n      case top:\n        {\n          return {\n            direction: 'top',\n            mode: 'vertical',\n            depth\n          };\n        }\n      case bottom:\n        {\n          return {\n            direction: 'bottom',\n            mode: 'vertical',\n            depth\n          };\n        }\n    }\n    // probably a invalid input causing everything to be NaN?\n    return {\n      direction: null,\n      depth: 0\n    };\n  }\n  getActualDepth(depth, mode, direction) {\n    let afterPanel = direction === 'bottom' || direction === 'right';\n    if (!depth) {\n      return depth;\n    }\n    let {\n      panelData\n    } = this.props;\n    let previousTarget = panelData;\n    let targetBox = panelData.parent;\n    let lastDepth = 0;\n    if (panelData.parent.mode === mode) {\n      ++depth;\n    }\n    while (targetBox && lastDepth < depth) {\n      if (targetBox.mode === mode) {\n        if (afterPanel) {\n          if (targetBox.children[targetBox.children.length - 1] !== previousTarget) {\n            // dont go deeper if current target is on different side of the box\n            break;\n          }\n        } else {\n          if (targetBox.children[0] !== previousTarget) {\n            // dont go deeper if current target is on different side of the box\n            break;\n          }\n        }\n      }\n      previousTarget = targetBox;\n      targetBox = targetBox.parent;\n      ++lastDepth;\n    }\n    while (depth > lastDepth) {\n      depth -= 2;\n    }\n    return depth;\n  }\n  render() {\n    return React.createElement(DragDropDiv, {\n      getRef: this.getRef,\n      className: 'dock-drop-edge',\n      onDragOverT: this.onDragOver,\n      onDragLeaveT: this.onDragLeave,\n      onDropT: this.onDrop\n    });\n  }\n  componentWillUnmount() {\n    this.context.setDropRect(null, 'remove', this);\n  }\n}\nDockDropEdge.contextType = DockContextType;","map":{"version":3,"names":["React","DockContextType","DragDropDiv","DragState","DockDropEdge","PureComponent","constructor","arguments","getRef","r","_ref","onDragOver","e","_a","panelData","panelElement","dropFromPanel","props","dockId","context","getDockId","draggingPanel","getData","fromGroup","getGroup","group","parent","mode","direction","depth","getDirection","getActualDepth","panelLock","setDropRect","targetElement","i","parentElement","panelSize","accept","onDragLeave","onDrop","source","target","dockMove","samePanel","rect","getBoundingClientRect","widthRate","Math","min","width","heightRate","height","left","clientX","right","top","clientY","bottom","disableDock","floatable","afterPanel","previousTarget","targetBox","lastDepth","children","length","render","createElement","className","onDragOverT","onDragLeaveT","onDropT","componentWillUnmount","contextType"],"sources":["C:/0Programmi/Dev/projects/frontend/jjodel/frontend/node_modules/rc-dock/es/DockDropEdge.js"],"sourcesContent":["import React from \"react\";\nimport { DockContextType } from \"./DockData\";\nimport { DragDropDiv } from \"./dragdrop/DragDropDiv\";\nimport { DragState } from \"./dragdrop/DragManager\";\nexport class DockDropEdge extends React.PureComponent {\n    constructor() {\n        super(...arguments);\n        this.getRef = (r) => {\n            this._ref = r;\n        };\n        this.onDragOver = (e) => {\n            var _a;\n            let { panelData, panelElement, dropFromPanel } = this.props;\n            let dockId = this.context.getDockId();\n            let draggingPanel = DragState.getData('panel', dockId);\n            let fromGroup = this.context.getGroup(dropFromPanel.group);\n            if (draggingPanel && ((_a = draggingPanel.parent) === null || _a === void 0 ? void 0 : _a.mode) === 'float') {\n                // ignore float panel in edge mode\n                return;\n            }\n            let { direction, mode, depth } = this.getDirection(e, fromGroup, draggingPanel === panelData);\n            depth = this.getActualDepth(depth, mode, direction);\n            if (!direction || (direction === 'float' && dropFromPanel.panelLock)) {\n                this.context.setDropRect(null, 'remove', this);\n                return;\n            }\n            let targetElement = panelElement;\n            for (let i = 0; i < depth; ++i) {\n                targetElement = targetElement.parentElement;\n            }\n            let panelSize = DragState.getData('panelSize', dockId);\n            this.context.setDropRect(targetElement, direction, this, e, panelSize);\n            e.accept('');\n        };\n        this.onDragLeave = (e) => {\n            this.context.setDropRect(null, 'remove', this);\n        };\n        this.onDrop = (e) => {\n            let { panelData, dropFromPanel } = this.props;\n            let dockId = this.context.getDockId();\n            let fromGroup = this.context.getGroup(dropFromPanel.group);\n            let source = DragState.getData('tab', dockId);\n            let draggingPanel = DragState.getData('panel', dockId);\n            if (!source) {\n                source = draggingPanel;\n            }\n            if (source) {\n                let { direction, mode, depth } = this.getDirection(e, fromGroup, draggingPanel === panelData);\n                depth = this.getActualDepth(depth, mode, direction);\n                if (!direction) {\n                    return;\n                }\n                let target = panelData;\n                for (let i = 0; i < depth; ++i) {\n                    target = target.parent;\n                }\n                this.context.dockMove(source, target, direction);\n            }\n        };\n    }\n    getDirection(e, group, samePanel) {\n        let rect = this._ref.getBoundingClientRect();\n        let widthRate = Math.min(rect.width, 500);\n        let heightRate = Math.min(rect.height, 500);\n        let left = (e.clientX - rect.left) / widthRate;\n        let right = (rect.right - e.clientX) / widthRate;\n        let top = (e.clientY - rect.top) / heightRate;\n        let bottom = (rect.bottom - e.clientY) / heightRate;\n        let min = Math.min(left, right, top, bottom);\n        let depth = 0;\n        if (group.disableDock || samePanel) {\n            // use an impossible min value to disable dock drop\n            min = 1;\n        }\n        if (min < 0) {\n            return { direction: null, depth: 0 };\n        }\n        else if (min < 0.075) {\n            depth = 3; // depth 3 or 4\n        }\n        else if (min < 0.15) {\n            depth = 1; // depth 1 or 2\n        }\n        else if (min < 0.3) {\n            // default\n        }\n        else if (group.floatable) {\n            return { direction: 'float', mode: 'float', depth: 0 };\n        }\n        switch (min) {\n            case left: {\n                return { direction: 'left', mode: 'horizontal', depth };\n            }\n            case right: {\n                return { direction: 'right', mode: 'horizontal', depth };\n            }\n            case top: {\n                return { direction: 'top', mode: 'vertical', depth };\n            }\n            case bottom: {\n                return { direction: 'bottom', mode: 'vertical', depth };\n            }\n        }\n        // probably a invalid input causing everything to be NaN?\n        return { direction: null, depth: 0 };\n    }\n    getActualDepth(depth, mode, direction) {\n        let afterPanel = (direction === 'bottom' || direction === 'right');\n        if (!depth) {\n            return depth;\n        }\n        let { panelData } = this.props;\n        let previousTarget = panelData;\n        let targetBox = panelData.parent;\n        let lastDepth = 0;\n        if (panelData.parent.mode === mode) {\n            ++depth;\n        }\n        while (targetBox && lastDepth < depth) {\n            if (targetBox.mode === mode) {\n                if (afterPanel) {\n                    if (targetBox.children[targetBox.children.length - 1] !== previousTarget) {\n                        // dont go deeper if current target is on different side of the box\n                        break;\n                    }\n                }\n                else {\n                    if (targetBox.children[0] !== previousTarget) {\n                        // dont go deeper if current target is on different side of the box\n                        break;\n                    }\n                }\n            }\n            previousTarget = targetBox;\n            targetBox = targetBox.parent;\n            ++lastDepth;\n        }\n        while (depth > lastDepth) {\n            depth -= 2;\n        }\n        return depth;\n    }\n    render() {\n        return (React.createElement(DragDropDiv, { getRef: this.getRef, className: 'dock-drop-edge', onDragOverT: this.onDragOver, onDragLeaveT: this.onDragLeave, onDropT: this.onDrop }));\n    }\n    componentWillUnmount() {\n        this.context.setDropRect(null, 'remove', this);\n    }\n}\nDockDropEdge.contextType = DockContextType;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}