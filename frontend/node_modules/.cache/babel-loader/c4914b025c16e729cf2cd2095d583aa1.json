{"ast":null,"code":"var _dec, _class, _class2;\nimport { LPointerTargetable, RuntimeAccessible } from \"../joiner\";\nlet windoww = window;\nexport let Debug = (_dec = RuntimeAccessible('Debug'), _dec(_class = (_class2 = class Debug {\n  // performance ligher mode for potato pc, huge models or complex simulations / measurables\n\n  // manually activated: counts how many times each node is rendered in a component.\n  static getComponentMap() {\n    let nodes = Object.values(windoww.GraphElementComponent.all).map(a => a.props.node).filter(a => !!a);\n    let nodeids = [...new Set(nodes.map(a => a.id).filter(a => !!a))];\n    let allids = {};\n    for (let o of nodeids) allids[o] = 0;\n    for (let n of nodes) allids[n === null || n === void 0 ? void 0 : n.id]++;\n    allids.nodes = nodeids;\n    allids.components = Object.values(windoww.GraphElementComponent.all);\n    return allids;\n  }\n  static timeoutTasks() {}\n  static largeTimeoutTasks() {\n    var _windoww$s$model;\n    windoww.model = windoww.LPointerTargetable.wrap((_windoww$s$model = windoww.s().model) === null || _windoww$s$model === void 0 ? void 0 : _windoww$s$model[0]);\n  }\n  static remakeEdges() {\n    // warning: might break undo/redo for direct state editing\n    let eids = windoww.LPointerTargetable.wrapAll(windoww.LState.get().edges).map(e => e.id);\n    let epids = windoww.LPointerTargetable.wrapAll(windoww.LState.get().edgepoints).map(e => e.id);\n    let ss = windoww.store.getState();\n    ss.edges = [];\n    ss.edgepoints = [];\n    for (let e of eids) delete ss.idlookup[e];\n    for (let e of epids) delete ss.idlookup[e];\n    windoww.SetRootFieldAction.new(\"clonedCounter\", ss.clonedCounter + 1, '', false);\n  }\n  static setLightMode(b) {\n    // i don't want to use react or actions here because they cause a re-render and are heavy. this is a performance emergency mode.\n    if (this.lightMode === b) return;\n    this.lightMode = b;\n    if (!Debug.lightModeInput) {\n      Debug.lightModeInput = $(\"#lightmode\")[0];\n      if (!Debug.lightModeInput) return;\n    }\n    Debug.lightModeInput.checked = b;\n  }\n  static refresh() {\n    for (let key in windoww.GraphElementComponent.all) {\n      windoww.GraphElementComponent.all[key].forceUpdate();\n    }\n    console.log(windoww.GraphElementComponent.all);\n  }\n\n  // 16s 50 classi vuote\n  static benchmarkCreateElement() {\n    let times = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 100;\n    let disableConsole = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    let state = windoww.s();\n    let checkDelayMax = 300;\n    let checkDelayMin = 50;\n    let diff = checkDelayMax - checkDelayMin;\n    let callbacks = {\n      checkCompletionFunction,\n      checkDelayMin,\n      additionalDelayMax: diff,\n      times,\n      disableConsole\n    };\n    callbacks.startTime = new Date();\n    if (disableConsole) windoww.Log.disableConsole();\n    let lmodel = LPointerTargetable.wrap(state.idlookup[state.models[0]]);\n    for (let i = 0; i < times; i++) {\n      lmodel.addChild(\"Class\");\n    }\n    function checkCompletionFunction() {\n      return $(\".DClass\").length;\n    }\n    Debug.timeMeasurer(callbacks);\n    return callbacks;\n  }\n  // 4s 10 istanze con 5 attributi\n  static benchmarkCreateInstance() {\n    let metaclassName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"Concept 1\";\n    let times = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 100;\n    let disableConsole = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    let checkDelayMax = 300;\n    let checkDelayMin = 50;\n    let diff = checkDelayMax - checkDelayMin;\n    let callbacks = {\n      checkCompletionFunction,\n      checkDelayMin,\n      additionalDelayMax: diff,\n      times,\n      disableConsole\n    };\n    callbacks.startTime = new Date();\n    if (disableConsole) windoww.Log.disableConsole();\n    let state = windoww.s();\n    let lmodel = LPointerTargetable.wrap(state.idlookup[state.models[1]]);\n    let lclass = LPointerTargetable.wrap(state.classs.map(cid => state.idlookup[cid]).filter(c => c.name === metaclassName)[0]);\n    for (let i = 0; i < times; i++) {\n      lmodel.addObject(lclass === null || lclass === void 0 ? void 0 : lclass.id);\n    }\n    function checkCompletionFunction() {\n      return $(\"[data-modelname=\\\"DObject\\\"]\").length;\n    }\n    Debug.timeMeasurer(callbacks);\n    return callbacks;\n  }\n  static timeMeasurer(callbacks0) {\n    let callbacks = callbacks0;\n    if (!callbacks) callbacks = {};\n    // if (!callbacks.startTime) callbacks.startTime = new Date();\n    if (!callbacks.maxStuckTime) callbacks.maxStuckTime = 10000;\n    if (!callbacks.checkDelayMin) callbacks.checkDelayMin = 300;\n    if (!callbacks.additionalDelayMax) callbacks.additionalDelayMax = 2000;\n    if (!callbacks.onStuck) callbacks.onStuck = (time, start, end, $complete) => {\n      console.log(\"Benchmarked operation stuck at same completion% for: \" + callbacks.maxStuckTime / 1000 + \" s. \\n\" + \"After \" + time / 100 + \"s total time passed and \" + $complete * 100 + \"% of the task was completed. \\nBenchmark aborted.\");\n    };\n    if (!callbacks.onFinish) callbacks.onFinish = (time, start, end) => {\n      console.log(\"Benchmarked operation completed after: \" + time / 1000 + \" s.\");\n    };\n    windoww.Log.exDev(!callbacks.times, \".times is a mandatory option\");\n    windoww.Log.exDev(!callbacks.checkCompletionFunction, \".checkCompletionFunction is a mandatory option\");\n    windoww.Log.exDev(!callbacks.checkCompletionFunction, \".startTime is a mandatory option. set it **before** doing the main task, then call the benchmark.\");\n    callbacks.completionHistory = [];\n    if (callbacks.disableConsole) windoww.Log.disableConsole();\n    Debug.timeMeasurer_inner(callbacks);\n    return callbacks;\n  }\n  static timeMeasurer_inner(callbacks) {\n    let completedTimes = callbacks.checkCompletionFunction();\n    callbacks.completionHistory.push(completedTimes);\n    if (completedTimes === callbacks.times) {\n      callbacks.endTime = new Date();\n      callbacks.totTime = callbacks.endTime.getTime() - callbacks.startTime.getTime();\n      if (callbacks.disableConsole) windoww.Log.enableConsole();\n      callbacks.onFinish(callbacks.totTime, callbacks.startTime, callbacks.endTime);\n      callbacks.endStatus = \"FINISH\";\n      return;\n    }\n    let $complete = completedTimes / callbacks.times;\n    if (callbacks.completedTimes !== completedTimes) {\n      callbacks.stuckSince = new Date().getTime();\n      callbacks.completedTimes = completedTimes;\n    } else if (callbacks.stuckSince > callbacks.maxStuckTime) {\n      callbacks.endTime = new Date();\n      let $complete = completedTimes / callbacks.times;\n      callbacks.totTime = callbacks.endTime.getTime() - callbacks.startTime.getTime();\n      if (callbacks.disableConsole) windoww.Log.enableConsole();\n      callbacks.onStuck(callbacks.totTime, callbacks.startTime, callbacks.endTime, $complete);\n      callbacks.endStatus = \"STUCK\";\n      return;\n    }\n    let delay = callbacks.checkDelayMin;\n    if ($complete !== 0) delay += callbacks.additionalDelayMax * (1 - $complete);\n    setTimeout(() => Debug.timeMeasurer_inner(callbacks), delay);\n  }\n}, _class2.lightMode = false, _class2.lightModeInput = void 0, _class2)) || _class);\nsetTimeout(Debug.timeoutTasks, 500);\nsetTimeout(Debug.largeTimeoutTasks, 5000);\nwindoww.Debug = Debug;","map":{"version":3,"names":["LPointerTargetable","RuntimeAccessible","windoww","window","Debug","_dec","_class","_class2","getComponentMap","nodes","Object","values","GraphElementComponent","all","map","a","props","node","filter","nodeids","Set","id","allids","o","n","components","timeoutTasks","largeTimeoutTasks","_windoww$s$model","model","wrap","s","remakeEdges","eids","wrapAll","LState","get","edges","e","epids","edgepoints","ss","store","getState","idlookup","SetRootFieldAction","new","clonedCounter","setLightMode","b","lightMode","lightModeInput","$","checked","refresh","key","forceUpdate","console","log","benchmarkCreateElement","times","arguments","length","undefined","disableConsole","state","checkDelayMax","checkDelayMin","diff","callbacks","checkCompletionFunction","additionalDelayMax","startTime","Date","Log","lmodel","models","i","addChild","timeMeasurer","benchmarkCreateInstance","metaclassName","lclass","classs","cid","c","name","addObject","callbacks0","maxStuckTime","onStuck","time","start","end","$complete","onFinish","exDev","completionHistory","timeMeasurer_inner","completedTimes","push","endTime","totTime","getTime","enableConsole","endStatus","stuckSince","delay","setTimeout"],"sources":["C:/d/Programming/web/jodel-mde/src/debugtools/debug.tsx"],"sourcesContent":["import type {DClass, DModel, GObject, LClass, LModel} from \"../joiner\";\r\nimport {LPointerTargetable, RuntimeAccessible, SetRootFieldAction} from \"../joiner\";\r\nlet windoww = window as any;\r\n\r\n@RuntimeAccessible('Debug')\r\nexport class Debug {\r\n    public static lightMode: boolean = false; // performance ligher mode for potato pc, huge models or complex simulations / measurables\r\n    private static lightModeInput: HTMLInputElement;\r\n\r\n    // manually activated: counts how many times each node is rendered in a component.\r\n    static getComponentMap(){\r\n        let nodes = Object.values(windoww.GraphElementComponent.all).map((a:any)=>a.props.node).filter(a=>!!a);\r\n        let nodeids = [...new Set(nodes.map(a=>a.id).filter(a=>!!a))];\r\n        let allids: GObject = {};\r\n        for (let o of nodeids) allids[o] = 0;\r\n        for (let n of nodes) allids[n?.id]++;\r\n        allids.nodes = nodeids;\r\n        allids.components = Object.values(windoww.GraphElementComponent.all);\r\n        return allids; }\r\n\r\n    static timeoutTasks(){}\r\n    static largeTimeoutTasks(){\r\n        windoww.model = windoww.LPointerTargetable.wrap(windoww.s().model?.[0]);\r\n    }\r\n\r\n    static remakeEdges(): void{\r\n        // warning: might break undo/redo for direct state editing\r\n        let eids = windoww.LPointerTargetable.wrapAll(windoww.LState.get().edges).map((e: any)=>e.id)\r\n        let epids = windoww.LPointerTargetable.wrapAll(windoww.LState.get().edgepoints).map((e: any)=>e.id)\r\n        let ss = windoww.store.getState();\r\n        ss.edges = [];\r\n        ss.edgepoints = [];\r\n        for (let e of eids) delete ss.idlookup[e];\r\n        for (let e of epids) delete ss.idlookup[e];\r\n        windoww.SetRootFieldAction.new(\"clonedCounter\" , ss.clonedCounter + 1, '', false);\r\n    }\r\n\r\n    static setLightMode(b: boolean): void {\r\n        // i don't want to use react or actions here because they cause a re-render and are heavy. this is a performance emergency mode.\r\n        if (this.lightMode === b) return;\r\n        this.lightMode = b;\r\n        if (!Debug.lightModeInput) {\r\n            Debug.lightModeInput = ($(\"#lightmode\") as any as HTMLInputElement[])[0];\r\n            if (!Debug.lightModeInput) return;\r\n        }\r\n        Debug.lightModeInput.checked = b;\r\n    }\r\n    public static refresh(): void {\r\n        for (let key in windoww.GraphElementComponent.all) {\r\n            windoww.GraphElementComponent.all[key].forceUpdate();\r\n        }\r\n        console.log(windoww.GraphElementComponent.all);\r\n    }\r\n\r\n    // 16s 50 classi vuote\r\n    static benchmarkCreateElement(times: number = 100, disableConsole: boolean = true): BenchmarkOptions{\r\n        let state = windoww.s();\r\n\r\n        let checkDelayMax = 300;\r\n        let checkDelayMin = 50;\r\n        let diff = checkDelayMax - checkDelayMin;\r\n        let callbacks: any = {checkCompletionFunction, checkDelayMin, additionalDelayMax: diff, times, disableConsole};\r\n        callbacks.startTime = new Date();\r\n        if(disableConsole) windoww.Log.disableConsole();\r\n        let lmodel = (LPointerTargetable.wrap(state.idlookup[ state.models[0] ]) as LModel);\r\n        for (let i = 0; i < times; i++){\r\n            lmodel.addChild(\"Class\");\r\n        }\r\n        function checkCompletionFunction() { return $(\".DClass\").length; }\r\n\r\n        Debug.timeMeasurer(callbacks);\r\n        return callbacks;\r\n    }\r\n    // 4s 10 istanze con 5 attributi\r\n    static benchmarkCreateInstance(metaclassName: string=\"Concept 1\", times: number = 100, disableConsole: boolean = true): BenchmarkOptions{\r\n        let checkDelayMax = 300;\r\n        let checkDelayMin = 50;\r\n        let diff = checkDelayMax - checkDelayMin;\r\n        let callbacks: any = {checkCompletionFunction, checkDelayMin, additionalDelayMax: diff, times, disableConsole};\r\n        callbacks.startTime = new Date();\r\n        if(disableConsole) windoww.Log.disableConsole();\r\n\r\n        let state = windoww.s();\r\n        let lmodel = (LPointerTargetable.wrap(state.idlookup[ state.models[1] ]) as LModel);\r\n        let lclass = LPointerTargetable.wrap(state.classs.map((cid: string)=>state.idlookup[cid]).filter((c:DClass) => c.name === metaclassName)[0]) as LClass;\r\n        for (let i = 0; i < times; i++) {\r\n            lmodel.addObject(lclass?.id);\r\n        }\r\n        function checkCompletionFunction() { return $(\"[data-modelname=\\\"DObject\\\"]\").length; }\r\n\r\n        Debug.timeMeasurer(callbacks);\r\n        return callbacks;\r\n    }\r\n\r\n\r\n    static timeMeasurer(callbacks0:Partial<BenchmarkOptions> | undefined): BenchmarkOptions {\r\n        let callbacks: BenchmarkOptions = callbacks0 as any;\r\n        if (!callbacks) callbacks = {} as any;\r\n        // if (!callbacks.startTime) callbacks.startTime = new Date();\r\n        if (!callbacks.maxStuckTime) callbacks.maxStuckTime = 10000;\r\n        if (!callbacks.checkDelayMin) callbacks.checkDelayMin = 300;\r\n        if (!callbacks.additionalDelayMax) callbacks.additionalDelayMax = 2000;\r\n        if (!callbacks.onStuck) callbacks.onStuck = (time:number, start: Date, end:Date, $complete: number) => {\r\n            console.log(\"Benchmarked operation stuck at same completion% for: \" + callbacks.maxStuckTime/1000+\" s. \\n\" +\r\n                \"After \" + time/100 + \"s total time passed and \" + $complete*100 + \"% of the task was completed. \\nBenchmark aborted.\"); }\r\n        if (!callbacks.onFinish) callbacks.onFinish = (time:number, start: Date, end:Date) => {\r\n            console.log(\"Benchmarked operation completed after: \" + time/1000 + \" s.\"); }\r\n\r\n        windoww.Log.exDev(!callbacks.times, \".times is a mandatory option\");\r\n        windoww.Log.exDev(!callbacks.checkCompletionFunction, \".checkCompletionFunction is a mandatory option\");\r\n        windoww.Log.exDev(!callbacks.checkCompletionFunction, \".startTime is a mandatory option. set it **before** doing the main task, then call the benchmark.\");\r\n        (callbacks as any).completionHistory = [];\r\n\r\n        if(callbacks.disableConsole) windoww.Log.disableConsole();\r\n        Debug.timeMeasurer_inner(callbacks);\r\n        return callbacks;\r\n    }\r\n\r\n    private static timeMeasurer_inner(callbacks:BenchmarkOptions): void {\r\n        let completedTimes = callbacks.checkCompletionFunction();\r\n        (callbacks as any).completionHistory.push(completedTimes);\r\n        if (completedTimes === callbacks.times) {\r\n            callbacks.endTime = new Date();\r\n            callbacks.totTime = callbacks.endTime.getTime() - callbacks.startTime.getTime();\r\n            if(callbacks.disableConsole) windoww.Log.enableConsole();\r\n            callbacks.onFinish(callbacks.totTime, callbacks.startTime, callbacks.endTime);\r\n            callbacks.endStatus = \"FINISH\";\r\n            return;\r\n        }\r\n        let $complete = completedTimes / callbacks.times;\r\n        if (callbacks.completedTimes !== completedTimes) {\r\n            callbacks.stuckSince = new Date().getTime();\r\n            callbacks.completedTimes = completedTimes;\r\n        } else\r\n        if (callbacks.stuckSince > callbacks.maxStuckTime) {\r\n            callbacks.endTime = new Date();\r\n            let $complete = completedTimes / callbacks.times;\r\n            callbacks.totTime = callbacks.endTime.getTime() - callbacks.startTime.getTime();\r\n            if(callbacks.disableConsole) windoww.Log.enableConsole();\r\n            callbacks.onStuck(callbacks.totTime, callbacks.startTime, callbacks.endTime, $complete);\r\n            callbacks.endStatus = \"STUCK\";\r\n            return;\r\n        }\r\n        let delay = callbacks.checkDelayMin;\r\n        if ($complete !== 0) delay += callbacks.additionalDelayMax * (1-$complete);\r\n        setTimeout(()=>Debug.timeMeasurer_inner(callbacks), delay );\r\n\r\n    }\r\n}\r\ntype BenchmarkOptions = {\r\n    onFinish:(time:number, start: Date, end:Date)=>void,\r\n    onStuck:(time:number, start: Date, end:Date, $complete: number)=>void,\r\n    disableConsole: boolean, endStatus: string,\r\n    // completionFunction returns how many steps are completed.\r\n    // times how many steps need to be completed to mark the test as finished.\r\n    checkCompletionFunction: () => number, times: number, completedTimes: number,\r\n    // those are automatically set\r\n    startTime:Date, endTime:Date, stuckSince: number, totTime: number,\r\n    // check how often completion or abortion is checked\r\n    checkDelayMin: number, additionalDelayMax: number, maxStuckTime:number\r\n};\r\n\r\nsetTimeout(Debug.timeoutTasks, 500);\r\nsetTimeout(Debug.largeTimeoutTasks, 5000);\r\nwindoww.Debug = Debug;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}