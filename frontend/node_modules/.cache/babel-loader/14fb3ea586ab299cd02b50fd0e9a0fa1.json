{"ast":null,"code":"var _dec,_class,_dec2,_class3,_dec3,_class5,_dec4,_class7,_class8,_dec5,_class9,_class10,_dec6,_class11;import{ABORT,DPointerTargetable,JsType,Log,LPointerTargetable,RuntimeAccessible,RuntimeAccessibleClass,SetFieldAction,SetRootFieldAction,U}from\"../joiner\";// (DX extends DUser ? LUser : (DX extends DPointerTargetable ? LPointerTargetable : (ERROR))\n// (DX extends DUser ? LUser : (DX extends DPointerTargetable ? LPointerTargetable : (           WViewElement\n//\n// (IN extends WViewElement ? LViewElement : (IN extends WViewTransientProperties ? LWiewTransientProperties : (ERROR)))\n// ))\n// type WtoL<WX extends WPointerTargetable> ='';\nexport let LogicContext=(_dec=RuntimeAccessible('LogicContext'),_dec(_class=class LogicContext extends RuntimeAccessibleClass{// & GObject;\nconstructor(proxyObject,data){super();this.proxyObject=void 0;this.data=void 0;this.write=void 0;this.className=this.constructor.cname||this.constructor.name;this.data=data;this.proxyObject=proxyObject;this.write=proxyObject;}/*\r\n        saveToRedux(propkey: \"keyof data\" | string, val: \"typeof data[path]\" | any): void { // todo: ask non stackoverflow\r\n            // todo, put data in redux store, path is \"obj1.obj2.obj3...\" might replace it with a path funciton that return the foremost nested object container\r\n            if (!propkey) {\r\n                // todo: set whole object instead of a property\r\n            }\r\n        }*/})||_class);RuntimeAccessibleClass.set_extend(RuntimeAccessibleClass,LogicContext);export let MapLogicContext=(_dec2=RuntimeAccessible('MapLogicContext'),_dec2(_class3=class MapLogicContext extends LogicContext{constructor(proxy,data,path){let subMaps=arguments.length>3&&arguments[3]!==undefined?arguments[3]:[];super(proxy,data);// this.proxyfyFunction = proxyfyFunction;\nthis.data=void 0;this.path=void 0;this.subMaps=void 0;this.proxyObject=proxy;this.data=data;this.path=path;this.subMaps=subMaps;this.className=this.constructor.cname||this.constructor.name;}})||_class3);RuntimeAccessibleClass.set_extend(LogicContext,MapLogicContext);export let MyProxyHandler=(_dec3=RuntimeAccessible('MyProxyHandler'),_dec3(_class5=class MyProxyHandler extends RuntimeAccessibleClass{constructor(){super(...arguments);this.s='set_';this.g='get_';}/*get(target: T, p: string | number | symbol, proxyitself: Proxyfied<T>): boolean {\r\n        switch (p) {\r\n            case '_isProxy': return true;\r\n            case 'init': return (this as any).init;\r\n            case 'init0': return (this as any).init0;\r\n            default: throw new Error('proxy get must be overridden, called for key: ' + (p as string));\r\n        }}*/set(target,p,value,proxyitself){throw new Error('proxy set must be overridden');}deleteProperty(target,p){throw new Error('proxy delete must be overridden');}ownKeys(target){// return Object.getOwnPropertyNames(target);\nconsole.log(\"ownkeys trap 1\",{thiss:this,target});console.log(\"ownkeys trap 2\",{thiss:this,target,ret:Reflect.ownKeys(target)});return Reflect.ownKeys(target);}/// proxy methods not used\n/* setPrototypeOf(target: T, v: object | null): boolean { ?? }\r\n    apply(target: T, thisArg: any, argArray: any[]): any { }\r\n    defineProperty(target: T, p: string | symbol, attributes: PropertyDescriptor): boolean { }\r\n    construct(target: T, argArray: any[], newTarget: Function): object { }\r\n    getOwnPropertyDescriptor(target: T, p: string | symbol): PropertyDescriptor | undefined { }\r\n    has(target: T, p: string | symbol): boolean { return p in target; }\r\n    getPrototypeOf(target: T): object | null { }\r\n    isExtensible(target: T): boolean { }\r\n    preventExtensions(target: T): boolean { }*/static wrap(data,baseObjInLookup){let path=arguments.length>2&&arguments[2]!==undefined?arguments[2]:'';let canThrow=arguments.length>3&&arguments[3]!==undefined?arguments[3]:false;//    static wrap<D extends RuntimeAccessibleClass, L extends LPointerTargetable, RET extends boolean = false>\n//        (data: D | Pointer<DViewElement>, baseObjInLookup?: DPointerTargetable, path: string = '', canthrow: RET = false as RET): RET {\nreturn DPointerTargetable.wrap(data,baseObjInLookup,path);}static isProxy(data){return(data===null||data===void 0?void 0:data.__isProxy)||false;}})||_class5);RuntimeAccessibleClass.set_extend(RuntimeAccessibleClass,MyProxyHandler);/*\r\n* handling proxy += and proxy -=\r\n*\r\n* will become var = var + add; which will call Symbol.getPrimitive\r\nconsole.log(+obj2);     // 10        — hint is \"number\"         NaN with +array with multiple vals, +array[0] with array of size 1, NaN with functions & objects\r\nconsole.log(`${obj2}`); // \"hello\"   — hint is \"string\"         array => array.join(','), object => \"[object Object]\", function => function.toString() whole func definition with body code\r\nconsole.log(obj2 + \"\"); // \"true\"    — hint is \"default\"        array, object, function => same as with hint \"string\"\r\n*\r\n* */ // NB: lclass.extends += somepointer will become: lclass.extends = lclass.extends + somepointer;\n// array + string will cause getPrimitive(\"default\") to array, then .join(',') on it, and finally and toString() to be called on all array members.\n// so pointers cannot include \",\" char and toString() must return a pointer to keep lclass.extends += somepointer as a valid expression;\n// -= will call getPrimitive(\"number\") which will result in array -> NaN, so NaN = NaN - pointer and cannot be done.\n// or maybe it can because if getPrimitive fails it calls toString as fallback, and viceversa\nlet GetPathHandler=(_dec4=RuntimeAccessible('GetPathHandler'),_dec4(_class7=(_class8=class GetPathHandler extends MyProxyHandler{constructor(){super();this.strbuilder='';this.array=[];this.calls=[];}get(targetObj,propKey,proxyitself){// console.log('GetPathHandler', {targetObj, propKey, proxyitself});\nif(propKey===\"start\"){this.strbuilder='';this.array=[];}if(propKey==='$'){const ret=GetPathHandler.__asCalls?this.calls:GetPathHandler.__asArray?this.array:this.strbuilder;this.array=[];this.strbuilder='';return ret;}this.array.push(propKey);this.calls.push(arguments);if(propKey===Symbol.toPrimitive){console.log(\"toprimitive\");return function(){for(var _len=arguments.length,a=new Array(_len),_key=0;_key<_len;_key++){a[_key]=arguments[_key];}console.log(\"toprimitive called with parameters\",a);};}if(!GetPathHandler.__asArray&&!GetPathHandler.__asCalls){if(typeof propKey===\"symbol\"){this.strbuilder+=propKey.toString();}else{// Giordano: add ignore for webpack\n//@ts-ignore\nthis.strbuilder+=(this.strbuilder?'.':'')+propKey;}}return GetPathHandler.__nested?proxyitself:{};}set(target,p,value,proxyitself){switch(p){case'__asArray':case'__asCalls':case'__nested':GetPathHandler[p]=value;return true;default:throw new Error('getPath proxy cannot be written');}}},_class8.__asCalls=false,_class8.__asArray=false,_class8.__nested=true,_class8))||_class7);RuntimeAccessibleClass.set_extend(MyProxyHandler,GetPathHandler);export let TargetableProxyHandler=(_dec5=RuntimeAccessible('TargetableProxyHandler'),_dec5(_class9=(_class10=class TargetableProxyHandler extends MyProxyHandler{// permette di fare cose tipo: user.name_surname che ritorna la concatenazione di nome e cognome anche se il campo name_surname non esiste.\n// to disable type check easily and access 'set_' + varname dynamically\nconstructor(d,baseObjInLookup){let additionalPath=arguments.length>2&&arguments[2]!==undefined?arguments[2]:'';let l=arguments.length>3?arguments[3]:undefined;super();this.lg=void 0;this.l=void 0;this.d=void 0;this.additionalPath=void 0;this.baseObjInLookup=void 0;this.d=d;if(!l){var _RuntimeAccessibleCla,_RuntimeAccessibleCla2;l=(_RuntimeAccessibleCla=RuntimeAccessibleClass.get(d===null||d===void 0?void 0:d.className))===null||_RuntimeAccessibleCla===void 0?void 0:(_RuntimeAccessibleCla2=_RuntimeAccessibleCla.logic)===null||_RuntimeAccessibleCla2===void 0?void 0:_RuntimeAccessibleCla2.singleton;Log.exDev(!l,'Trying to wrap class without singleton or logic mapped: '+(d===null||d===void 0?void 0:d.className),{object:d,className:d.className});}this.baseObjInLookup=baseObjInLookup||d;this.additionalPath=additionalPath;this.l=l;this.lg=this.l;this.className=this.constructor.cname||this.constructor.name;}// damiano todo: this does not work\nconcatenableHandler(targetObj,propKey,proxyitself){//console.log(\"concatenableHandler 1\", {targetObj, propKey, proxyitself});\nif(propKey in targetObj)return null;const propKeyStr=U.asString(propKey,null);let _index=propKeyStr?propKeyStr.indexOf('_'):-1;//console.log(\"concatenableHandler 2\", {targetObj, propKey, propKeyStr, proxyitself, _index});\nif(_index<0)return null;let isConcatenable=true;let ret=propKey.split('_').map(subKey=>{//console.log(\"concatenableHandler 3.0\", {targetObj, subKey, propKeyStr, proxyitself});\n// se trovo multipli ___ li tratto come spazi aggiuntivi invece che come proprietà '' che ritornano undefined, così posso fare name___surname --> \"damiano   di vincenzo\"\nlet val=subKey===''?' ':this.get(targetObj,subKey,proxyitself);isConcatenable=isConcatenable&&JsType.isPrimitive(val);return val;});//console.log(\"concatenableHandler 4\", {targetObj, propKey, propKeyStr, proxyitself, ret, isConcatenable});\nreturn isConcatenable?ret.join(' '):ret;}get(targetObj,propKey,proxyitself){let ret;let isError=false;// console.error('_proxy get PRE:', {targetObj, propKey, proxyitself, arguments});\ntry{ret=this.get0(targetObj,propKey,proxyitself);}catch(e){ret=e;isError=true;}// if (isError) throw ret;\n// console.error('_proxy get POST:', {targetObj, propKey, ret, isError});\nreturn ret;}get0(targetObj,propKey,proxyitself){// console.log('proxy keysearch', {propKey, targetObj, l: this.l, proxyitself, d: this.d});\nlet canThrowErrors=true;switch(typeof propKey){case\"symbol\":propKey=String(propKey);// console.log('get symbol', {propKey});\nswitch(propKey){default:Log.exDevv('unexpected symbol in proxy getter:',propKey);break;case'Symbol(Symbol.toStringTag)':propKey='toString';break;//return (()=>\"[Proxy]\");\ncase\"Symbol(Symbol.toPrimitive)\":propKey='toPrimitive';break;}break;// case \"number\": return null;\n}switch(propKey){case'__l':return this.l;case'__d':return this.d;case'inspect':// node.js util\ncase\"r\":case\"_refresh\":case\"_reload\":return LPointerTargetable.wrap(targetObj.id);case'__Raw':case'__raw':return targetObj;case'__serialize':return JSON.stringify(targetObj);case'__isproxy':case'__isProxy':return true;case'__random':return Math.random();case'editCount':case'clonedcounter':case'clonedCounter':return targetObj.clonedCounter||0;case'$$typeof':case\"typeName\":return this.d.className;case'parent':propKey='father';break;}if(propKey[0]===\"_\"&&propKey.indexOf(\"__info_of__\")===0){return this.l[propKey];}// check if exist directly in D.key, L.key or through a get_key\nif(propKey in this.l||propKey in this.d||this.l[this.g+propKey]){// todo: il LogicContext passato come parametro risulta nell'autocompletion editor automaticamente generato, come passo un parametro senza passargli il parametro? uso arguments senza dichiararlo?\nif(typeof propKey!=='symbol'&&this.g+propKey in this.lg)return this.lg[this.g+propKey](new LogicContext(proxyitself,targetObj));// if specific custom getter exist\nif(typeof propKey!=='symbol'&&this.g+propKey in this.lg){let getterMethod=this.lg[this.g+propKey];// || this.defaultGetter;\n// console.log(\"gets method\", {getterMethod, lg:this.lg, thiss: this});\nif(getterMethod)return getterMethod(new LogicContext(proxyitself,targetObj));}}// @ts-ignore\n//console.trace(\"proxy $getter 2\", {targetObj, n:targetObj.name, propKey, l:this.lg, dg:this.lg._defaultGetter});\n// if custom generic getter exist\n// @ts-ignore\nif(this.lg._defaultGetter)return this.lg._defaultGetter(new LogicContext(proxyitself,targetObj),propKey);// if property do not exist, try a concatenation\n/*let concatenationTentative = null;\r\n        try {concatenationTentative = this.concatenableHandler(targetObj, propKey, proxyitself); } catch(e) {}\r\n        if (concatenationTentative !== null) return concatenationTentative;\r\n        */Log.e(canThrowErrors,'GET property \"'+propKey+'\" do not exist in object of type \"'+U.getType(this.l)+\" DType:\"+U.getType(this.d),{data:targetObj});return undefined;// todo: credo che con espressioni sui tipi siano tipizzabili tutti i return di proprietà note eccetto quelle ottenute per concatenazione.\n}defaultGetter(targetObj,key,proxyitself){if(!targetObj)return targetObj;if(!targetObj._subMaps||!targetObj._subMaps[key])return targetObj[key];// if is a nexted subobject\nlet context=new MapLogicContext(proxyitself,targetObj,key,[]);let retRaw=this.lg[this.s+key];return MapProxyHandler.mapWrap(targetObj[key],targetObj,this.additionalPath+'.'+key);}defaultSetter(targetObj,propKey,value,proxyitself){SetFieldAction.new(targetObj,propKey,value);return true;}set(targetObj,propKey,value,proxyitself){// console.error('_proxy set PRE:', {targetObj, propKey, value, proxyitself, arguments});\n// if (propKey in this.l || propKey in this.d || (this.l as GObject)[this.s + (propKey as string)] || (this.l as GObject)[(propKey as string)]) {\nif(this.d.__readonly&&propKey!=='__readonly'){//todo if there is a transaction open i should throw exception?\nif(ABORT()){Log.ee('Transaction aborted because an object is readonly:',this.d);}return true;}switch(typeof propKey){case\"symbol\":propKey=String(propKey);Log.exDevv('unexpected symbol in proxy setter:',propKey);break;default:break;}switch(propKey){case'parent':propKey='father';break;}if(propKey in this.l||propKey in this.d||this.l[this.s+propKey]){// todo: il LogicContext passato come parametro risulta nell'autocompletion editor automaticamente generato, come passo un parametro senza passargli il parametro? uso arguments senza dichiararlo?\nif(typeof propKey!=='symbol'&&this.s+propKey in this.lg){this.lg[this.s+propKey](value,new LogicContext(proxyitself,targetObj));return true;}// se esiste la proprietà ma non esiste il setter?\n// Log.eDevv(\"dev error: property exist but setter does not: \", propKey, this);\n// return false;\n}// if property do not exist\n// if custom generic setter exist\n// @ts-ignore private property\nif(this.lg._defaultSetter){// @ts-ignore private property\nthis.lg._defaultSetter(value,new LogicContext(proxyitself,targetObj),propKey);return true;}/*if (enableFallbackSetter && typeof (propKey === \"string\") && ((propKey as string)[0] === '_' || (propKey as string).indexOf('tmp') > 0)) {\r\n            return this.defaultSetter(targetObj as any as DPointerTargetable, propKey as string, value, proxyitself);\r\n            // new SetFieldAction(new LogicContext(proxyitself as any, targetObj).data as any, propKey as string, value); return true;\r\n        }*/let canThrowErrors=true;Log.ex(canThrowErrors,'SET property \"set_'+propKey+'\" do not exist in object of type \"'+U.getType(this.l)+\" DType:\"+U.getType(this.l),{'this':this,targetObj});return false;}/*      problema: ogni oggetto deve avere multipli puntatori, quando ne modifico uno devo modificarli tutti, come tengo traccia?\r\n            ipotesi 1: lo memorizzo in un solo posto (store.idlookup) e uso Pointer<type, lb, ub> che è una stringa che simula un puntatore\r\n            problema 1: se fornisco l'intero store ai componenti si aggiornano ad ogni singola modifica, se estraggo i campi interesasti le stringhe puntatore sono invariate ma il contenuto puntato è cambiato e il componente non lo sa...\r\n            problemone 2: non so a quali proprietà dello store devo abbonarmi, devo leggere sempre tutto lo store?\r\n            !!!!! soluzione 2?: dovrei dichiarare le variabili a cui mi abbono, salvarle nello stato e precaricarle tramite mapStateToProps*/deleteProperty(target,key,proxyItself){if(typeof key===\"symbol\")return false;this.set(target,key,undefined,proxyItself);delete target[key];return true;}mergedObject(target){let ret={...target};// U.arrayMergeInPlace(Object.keys(target), Object.keys(this.l).filter(k => k.indexOf('set_') !== 0 && k.indexOf('get_') !== 0));\nfor(let k in this.l){if(!(k in ret)&&k.lastIndexOf('get_',4)!==0&&k.lastIndexOf('set_',4)!==0)ret[k]=true;}return ret;}ownKeys(target){const ret=this.mergedObject(target);// ret = Reflect.ownKeys(ret);\nreturn Reflect.ownKeys(ret);}// has(target: ME, p: string | symbol): boolean { return p in this.mergedObject(target); }\nhas(target,p){return p in target||p in this.l;}/*\r\n    apply(target: DModelElement, thisArg: any, argArray: any[]): any {\r\n        // will i ever use it? dovrei pasare una funzione invece di una classe, quindi in questo caso credo wrappi solo il costruttore\r\n    }*/},_class10.childKeys={'$':true,'@':true},_class10))||_class9);RuntimeAccessibleClass.set_extend(MyProxyHandler,TargetableProxyHandler);export let MapProxyHandler=(_dec6=RuntimeAccessible('MapProxyHandler'),_dec6(_class11=class MapProxyHandler extends TargetableProxyHandler{// todo: sposta alcune funzioni da TargetableProxy a MyProxy e fai estendere direttamente MyProxy a questa classe\nconstructor(d,baseObjInLookup){let additionalPath=arguments.length>2&&arguments[2]!==undefined?arguments[2]:'';let subMapKeys=arguments.length>3&&arguments[3]!==undefined?arguments[3]:{};super(d,baseObjInLookup,additionalPath,LPointerTargetable.singleton);this.subMapKeys=void 0;this.subMapKeys=subMapKeys;}get(target,key,proxyitself){if(typeof key===\"symbol\")return this.d[key];let val=this.d[key];if(key in this.subMapKeys&&!(key in target)){Log.exx('property not found in dictionary',{target,key,thiss:this,proxyitself,submapkeys:this.subMapKeys});return undefined;}if(key in this.subMapKeys){this.additionalPath+='.';return MapProxyHandler.mapWrap(this.d,this.baseObjInLookup,this.additionalPath,this.subMapKeys[key]);Log.exDevv('todo: wrap sub-map',{thiss:this});}return target[key];}set(target,key,value,proxyitself){if(typeof key===\"symbol\"){Log.exx('cannot set a symbol in dictionary',{target,key,value,proxyitself});return false;}SetRootFieldAction.new(this.additionalPath+'.'+key,value,'',false);return true;}deleteProperty(target,key,proxyItself){if(typeof key===\"symbol\")return false;this.set(target,key,undefined,proxyItself);delete target[key];return true;}})||_class11);RuntimeAccessibleClass.set_extend(MyProxyHandler,MapProxyHandler);// 15-20 min + 5 di domande entro il 1° ottobre, discussione 10-12 ottobre\nexport const getPath=new Proxy({},new GetPathHandler());window.getPath=getPath;// usage: pathstring = ((getPath as DType).some.path.to.follow as any).$; // = \"some.path.to.follow\" with compilation-time validation","map":{"version":3,"names":["ABORT","DPointerTargetable","JsType","Log","LPointerTargetable","RuntimeAccessible","RuntimeAccessibleClass","SetFieldAction","SetRootFieldAction","U","LogicContext","_dec","_class","constructor","proxyObject","data","write","className","cname","name","set_extend","MapLogicContext","_dec2","_class3","proxy","path","subMaps","arguments","length","undefined","MyProxyHandler","_dec3","_class5","s","g","set","target","p","value","proxyitself","Error","deleteProperty","ownKeys","console","log","thiss","ret","Reflect","wrap","baseObjInLookup","canThrow","isProxy","__isProxy","GetPathHandler","_dec4","_class7","_class8","strbuilder","array","calls","get","targetObj","propKey","__asCalls","__asArray","push","Symbol","toPrimitive","_len","a","Array","_key","toString","__nested","TargetableProxyHandler","_dec5","_class9","_class10","d","additionalPath","l","lg","_RuntimeAccessibleCla","_RuntimeAccessibleCla2","logic","singleton","exDev","object","concatenableHandler","propKeyStr","asString","_index","indexOf","isConcatenable","split","map","subKey","val","isPrimitive","join","isError","get0","e","canThrowErrors","String","exDevv","id","JSON","stringify","Math","random","clonedCounter","getterMethod","_defaultGetter","getType","defaultGetter","key","_subMaps","context","retRaw","MapProxyHandler","mapWrap","defaultSetter","new","__readonly","ee","_defaultSetter","ex","proxyItself","mergedObject","k","lastIndexOf","has","childKeys","_dec6","_class11","subMapKeys","exx","submapkeys","getPath","Proxy","window"],"sources":["C:/0Programmi/Dev/projects/frontend/jjodel/src/joiner/proxy.ts"],"sourcesContent":["import type {DocString, DtoL, DtoW, GObject, Proxyfied, WPointerTargetable,} from \"../joiner\";\r\nimport {\r\n    ABORT,\r\n    Dictionary,\r\n    DModelElement,\r\n    DPointerTargetable,\r\n    JsType,\r\n    LModelElement,\r\n    Log,\r\n    LPointerTargetable,\r\n    Pointer,\r\n    RuntimeAccessible,\r\n    RuntimeAccessibleClass,\r\n    SetFieldAction,\r\n    SetRootFieldAction,\r\n    U\r\n} from \"../joiner\";\r\n\r\ntype NotAConcatenation = null;\r\ntype ERROR = \"_Type_Error_\";\r\n\r\n// (DX extends DUser ? LUser : (DX extends DPointerTargetable ? LPointerTargetable : (ERROR))\r\n// (DX extends DUser ? LUser : (DX extends DPointerTargetable ? LPointerTargetable : (           WViewElement\r\n//\r\n// (IN extends WViewElement ? LViewElement : (IN extends WViewTransientProperties ? LWiewTransientProperties : (ERROR)))\r\n// ))\r\n// type WtoL<WX extends WPointerTargetable> ='';\r\n\r\n@RuntimeAccessible('LogicContext')\r\nexport class LogicContext<\r\n    DX extends GObject = DModelElement,\r\n    LX = DtoL<DX>,\r\n    // PF extends MyProxyHandler<DX> = MyProxyHandler<DX>,\r\n    WX = DtoW<DX>\r\n    > extends RuntimeAccessibleClass{\r\n    public proxyObject: LX;\r\n    public data: DX;// & GObject;\r\n    public write: WX;\r\n    constructor(proxyObject: LX, data: DX) {\r\n        super();\r\n        this.className = (this.constructor as typeof RuntimeAccessibleClass).cname || this.constructor.name;\r\n        this.data = data;\r\n        this.proxyObject = proxyObject;\r\n        this.write = proxyObject as any;\r\n    }\r\n    /*\r\n        saveToRedux(propkey: \"keyof data\" | string, val: \"typeof data[path]\" | any): void { // todo: ask non stackoverflow\r\n            // todo, put data in redux store, path is \"obj1.obj2.obj3...\" might replace it with a path funciton that return the foremost nested object container\r\n            if (!propkey) {\r\n                // todo: set whole object instead of a property\r\n            }\r\n        }*/\r\n}\r\n\r\nRuntimeAccessibleClass.set_extend(RuntimeAccessibleClass, LogicContext);\r\n@RuntimeAccessible('MapLogicContext')\r\nexport class MapLogicContext extends LogicContext<GObject, LPointerTargetable, WPointerTargetable> {\r\n    data: GObject;\r\n    path: string;\r\n    subMaps: string[];\r\n    constructor(proxy: LPointerTargetable, data: GObject, path: string, subMaps: string[] = []) {\r\n        super(proxy, data);\r\n        // this.proxyfyFunction = proxyfyFunction;\r\n        this.proxyObject = proxy;\r\n        this.data = data;\r\n        this.path = path;\r\n        this.subMaps = subMaps;\r\n        this.className = (this.constructor as typeof RuntimeAccessibleClass).cname || this.constructor.name;\r\n    }\r\n}\r\nRuntimeAccessibleClass.set_extend(LogicContext, MapLogicContext);\r\n\r\n@RuntimeAccessible('MyProxyHandler')\r\nexport abstract class MyProxyHandler<T extends GObject> extends RuntimeAccessibleClass implements ProxyHandler<T>{\r\n    s: string = 'set_';\r\n    g: string = 'get_';\r\n    /*get(target: T, p: string | number | symbol, proxyitself: Proxyfied<T>): boolean {\r\n        switch (p) {\r\n            case '_isProxy': return true;\r\n            case 'init': return (this as any).init;\r\n            case 'init0': return (this as any).init0;\r\n            default: throw new Error('proxy get must be overridden, called for key: ' + (p as string));\r\n        }}*/\r\n    set(target: T, p: string | number | symbol, value: any, proxyitself: Proxyfied<T>): boolean { throw new Error('proxy set must be overridden'); }\r\n    deleteProperty(target: T, p: string | symbol): boolean { throw new Error('proxy delete must be overridden'); }\r\n\r\n    ownKeys(target: T): ArrayLike<string | symbol>{\r\n        // return Object.getOwnPropertyNames(target);\r\n        console.log(\"ownkeys trap 1\", {thiss:this, target})\r\n        console.log(\"ownkeys trap 2\", {thiss:this, target, ret:Reflect.ownKeys(target)});\r\n        return Reflect.ownKeys(target);\r\n    }\r\n    /// proxy methods not used\r\n    /* setPrototypeOf(target: T, v: object | null): boolean { ?? }\r\n    apply(target: T, thisArg: any, argArray: any[]): any { }\r\n    defineProperty(target: T, p: string | symbol, attributes: PropertyDescriptor): boolean { }\r\n    construct(target: T, argArray: any[], newTarget: Function): object { }\r\n    getOwnPropertyDescriptor(target: T, p: string | symbol): PropertyDescriptor | undefined { }\r\n    has(target: T, p: string | symbol): boolean { return p in target; }\r\n    getPrototypeOf(target: T): object | null { }\r\n    isExtensible(target: T): boolean { }\r\n    preventExtensions(target: T): boolean { }*/\r\n\r\n    static wrap<D extends RuntimeAccessibleClass, L extends LPointerTargetable = LPointerTargetable, CAN_THROW extends boolean = false,\r\n        RET extends CAN_THROW extends true ? L : L | undefined  = CAN_THROW extends true ? L : L>\r\n    (data: D | Pointer | undefined | null, baseObjInLookup?: DPointerTargetable, path: string = '', canThrow: CAN_THROW = false as CAN_THROW): RET{\r\n\r\n//    static wrap<D extends RuntimeAccessibleClass, L extends LPointerTargetable, RET extends boolean = false>\r\n//        (data: D | Pointer<DViewElement>, baseObjInLookup?: DPointerTargetable, path: string = '', canthrow: RET = false as RET): RET {\r\n        return DPointerTargetable.wrap(data, baseObjInLookup, path) as RET; }\r\n\r\n    static isProxy(data: GObject): boolean { return data?.__isProxy || false; }\r\n}\r\nRuntimeAccessibleClass.set_extend(RuntimeAccessibleClass, MyProxyHandler);\r\nexport type GetPath<T = GObject> = T;\r\n/*\r\n* handling proxy += and proxy -=\r\n*\r\n* will become var = var + add; which will call Symbol.getPrimitive\r\nconsole.log(+obj2);     // 10        — hint is \"number\"         NaN with +array with multiple vals, +array[0] with array of size 1, NaN with functions & objects\r\nconsole.log(`${obj2}`); // \"hello\"   — hint is \"string\"         array => array.join(','), object => \"[object Object]\", function => function.toString() whole func definition with body code\r\nconsole.log(obj2 + \"\"); // \"true\"    — hint is \"default\"        array, object, function => same as with hint \"string\"\r\n*\r\n* */\r\n\r\n// NB: lclass.extends += somepointer will become: lclass.extends = lclass.extends + somepointer;\r\n// array + string will cause getPrimitive(\"default\") to array, then .join(',') on it, and finally and toString() to be called on all array members.\r\n// so pointers cannot include \",\" char and toString() must return a pointer to keep lclass.extends += somepointer as a valid expression;\r\n// -= will call getPrimitive(\"number\") which will result in array -> NaN, so NaN = NaN - pointer and cannot be done.\r\n// or maybe it can because if getPrimitive fails it calls toString as fallback, and viceversa\r\n\r\n@RuntimeAccessible('GetPathHandler')\r\nclass GetPathHandler<T extends GObject> extends MyProxyHandler<T>{\r\n    public static __asCalls: boolean = false;\r\n    public static __asArray: boolean = false;\r\n    public static __nested: boolean = true;\r\n    private strbuilder: string = '';\r\n    private array: (string | number | symbol)[] = [];\r\n    private calls: (GObject<'parameters of get calls'>)[] = [];\r\n\r\n    public constructor() { super(); }\r\n\r\n    get(targetObj: T, propKey: keyof T | string, proxyitself: Proxyfied<T>): any {\r\n        // console.log('GetPathHandler', {targetObj, propKey, proxyitself});\r\n        if (propKey === \"start\") { this.strbuilder = ''; this.array = []; }\r\n        if (propKey === '$') {\r\n            const ret = GetPathHandler.__asCalls ? this.calls : (GetPathHandler.__asArray ? this.array : this.strbuilder);\r\n            this.array = [];\r\n            this.strbuilder = '';\r\n            return ret; }\r\n        this.array.push(propKey);\r\n        this.calls.push(arguments);\r\n        if (propKey === Symbol.toPrimitive) {\r\n            console.log(\"toprimitive\");\r\n            return (...a: any)=> {console.log(\"toprimitive called with parameters\", a); }\r\n        }\r\n        if (!GetPathHandler.__asArray && !GetPathHandler.__asCalls) {\r\n            if (typeof propKey === \"symbol\") { this.strbuilder += propKey.toString(); }\r\n            else {\r\n                // Giordano: add ignore for webpack\r\n                //@ts-ignore\r\n                this.strbuilder += (this.strbuilder ? '.' : '') + propKey;\r\n            }\r\n        }\r\n        return GetPathHandler.__nested ? proxyitself : {};\r\n    }\r\n\r\n    set(target: T, p: string | number | symbol, value: any, proxyitself: Proxyfied<T>): boolean {\r\n        switch(p){\r\n            case '__asArray':\r\n            case '__asCalls':\r\n            case '__nested':\r\n                (GetPathHandler as any)[p] = value;\r\n                return true;\r\n            default:\r\n                throw new Error('getPath proxy cannot be written');\r\n        }\r\n    }\r\n}\r\nRuntimeAccessibleClass.set_extend(MyProxyHandler, GetPathHandler);\r\n@RuntimeAccessible('TargetableProxyHandler')\r\nexport class TargetableProxyHandler<ME extends GObject = DModelElement, LE extends LPointerTargetable = LModelElement> extends MyProxyHandler<ME> {\r\n// permette di fare cose tipo: user.name_surname che ritorna la concatenazione di nome e cognome anche se il campo name_surname non esiste.\r\n    lg: LE & GObject; // to disable type check easily and access 'set_' + varname dynamically\r\n    l: LE;\r\n    d: ME;\r\n    additionalPath: string;\r\n\r\n    public baseObjInLookup: DPointerTargetable;\r\n    static childKeys: Dictionary<string, true> = {'$': true, '@': true};\r\n\r\n    constructor(d: ME, baseObjInLookup?: DPointerTargetable, additionalPath: string = '', l?: LE) {\r\n        super();\r\n        this.d = d;\r\n        if (!l) {\r\n            l = RuntimeAccessibleClass.get(d?.className)?.logic?.singleton as LE;\r\n            Log.exDev(!l, 'Trying to wrap class without singleton or logic mapped: ' + d?.className, { object: d, className: d.className })\r\n        }\r\n        this.baseObjInLookup = baseObjInLookup || d as any;\r\n        this.additionalPath = additionalPath;\r\n        this.l = l as LE;\r\n        this.lg = this.l;\r\n        this.className = (this.constructor as typeof RuntimeAccessibleClass).cname || this.constructor.name;\r\n    }\r\n\r\n    // damiano todo: this does not work\r\n    private concatenableHandler(targetObj: ME, propKey: number | string | symbol, proxyitself: Proxyfied<ME>): NotAConcatenation | any[] | string {\r\n        //console.log(\"concatenableHandler 1\", {targetObj, propKey, proxyitself});\r\n        if (propKey in targetObj)  return null as NotAConcatenation;\r\n        const propKeyStr: null | string = U.asString(propKey, null);\r\n        let _index: number = propKeyStr ? propKeyStr.indexOf('_') : -1;\r\n        //console.log(\"concatenableHandler 2\", {targetObj, propKey, propKeyStr, proxyitself, _index});\r\n        if (_index < 0) return null as NotAConcatenation;\r\n\r\n        let isConcatenable = true;\r\n        let ret: any[] = (propKey as string).split('_').map( (subKey: string) => {\r\n            //console.log(\"concatenableHandler 3.0\", {targetObj, subKey, propKeyStr, proxyitself});\r\n            // se trovo multipli ___ li tratto come spazi aggiuntivi invece che come proprietà '' che ritornano undefined, così posso fare name___surname --> \"damiano   di vincenzo\"\r\n            let val: any = subKey === '' ? ' ' : this.get(targetObj, subKey, proxyitself);\r\n            isConcatenable = isConcatenable && JsType.isPrimitive(val);\r\n            return val;\r\n        });\r\n        //console.log(\"concatenableHandler 4\", {targetObj, propKey, propKeyStr, proxyitself, ret, isConcatenable});\r\n        return isConcatenable ? ret.join(' ') : ret; }\r\n\r\n    public get(targetObj: ME, propKey: string | symbol, proxyitself: Proxyfied<ME>): any {\r\n        let ret;\r\n        let isError = false;\r\n        // console.error('_proxy get PRE:', {targetObj, propKey, proxyitself, arguments});\r\n        try { ret = this.get0(targetObj, propKey, proxyitself); } catch(e) { ret = e; isError = true;}\r\n\r\n        // if (isError) throw ret;\r\n        // console.error('_proxy get POST:', {targetObj, propKey, ret, isError});\r\n        return ret;\r\n    }\r\n\r\n    public get0(targetObj: ME, propKey: string | symbol, proxyitself: Proxyfied<ME>): any {\r\n        // console.log('proxy keysearch', {propKey, targetObj, l: this.l, proxyitself, d: this.d});\r\n        let canThrowErrors = true;\r\n\r\n        switch(typeof propKey) {\r\n            case \"symbol\":\r\n                propKey = String(propKey);\r\n                // console.log('get symbol', {propKey});\r\n                switch (propKey) {\r\n                    default: Log.exDevv('unexpected symbol in proxy getter:', propKey); break;\r\n                    case 'Symbol(Symbol.toStringTag)': propKey = 'toString'; break; //return (()=>\"[Proxy]\");\r\n                    case \"Symbol(Symbol.toPrimitive)\": propKey = 'toPrimitive'; break;\r\n                }\r\n                break;\r\n            // case \"number\": return null;\r\n        }\r\n\r\n        switch (propKey) {\r\n            case '__l': return this.l;\r\n            case '__d': return this.d;\r\n            case 'inspect': // node.js util\r\n            case \"r\":\r\n            case \"_refresh\":\r\n            case \"_reload\": return LPointerTargetable.wrap(targetObj.id);\r\n            case '__Raw':\r\n            case '__raw': return targetObj;\r\n            case '__serialize': return JSON.stringify(targetObj);\r\n            case '__isproxy':\r\n            case '__isProxy': return true;\r\n            case '__random': return Math.random();\r\n            case 'editCount':\r\n            case 'clonedcounter':\r\n            case 'clonedCounter':\r\n                return targetObj.clonedCounter || 0;\r\n            case '$$typeof':\r\n            case \"typeName\":\r\n                return this.d.className;\r\n            case 'parent': propKey = 'father'; break;\r\n        }\r\n        if (propKey[0] === \"_\" && propKey.indexOf(\"__info_of__\")===0) {\r\n            return (this.l as GObject)[propKey];\r\n        }\r\n\r\n\r\n        // check if exist directly in D.key, L.key or through a get_key\r\n        if (propKey in this.l || propKey in this.d || (this.l as GObject)[this.g + (propKey as string)]) {\r\n            // todo: il LogicContext passato come parametro risulta nell'autocompletion editor automaticamente generato, come passo un parametro senza passargli il parametro? uso arguments senza dichiararlo?\r\n            if (typeof propKey !== 'symbol' && this.g + propKey in this.lg) return this.lg[this.g + propKey](new LogicContext(proxyitself as any, targetObj));\r\n\r\n\r\n\r\n            // if specific custom getter exist\r\n            if (typeof propKey !== 'symbol' && this.g + propKey in this.lg) {\r\n                let getterMethod: Function = this.lg[this.g + propKey]; // || this.defaultGetter;\r\n                // console.log(\"gets method\", {getterMethod, lg:this.lg, thiss: this});\r\n                if (getterMethod) return getterMethod(new LogicContext(proxyitself as any, targetObj));\r\n            }\r\n\r\n        }\r\n        // @ts-ignore\r\n        //console.trace(\"proxy $getter 2\", {targetObj, n:targetObj.name, propKey, l:this.lg, dg:this.lg._defaultGetter});\r\n\r\n\r\n        // if custom generic getter exist\r\n        // @ts-ignore\r\n        if (this.lg._defaultGetter) return this.lg._defaultGetter(new LogicContext(proxyitself as any, targetObj), propKey);\r\n\r\n        // if property do not exist, try a concatenation\r\n        /*let concatenationTentative = null;\r\n        try {concatenationTentative = this.concatenableHandler(targetObj, propKey, proxyitself); } catch(e) {}\r\n        if (concatenationTentative !== null) return concatenationTentative;\r\n        */\r\n        Log.e(canThrowErrors, 'GET property \"'+ (propKey as any)+ '\" do not exist in object of type \"' + U.getType(this.l) + \" DType:\" +  U.getType(this.d), {data: targetObj});\r\n        return undefined;\r\n        // todo: credo che con espressioni sui tipi siano tipizzabili tutti i return di proprietà note eccetto quelle ottenute per concatenazione.\r\n    }\r\n\r\n    public defaultGetter(targetObj: ME, key: string, proxyitself: Proxyfied<ME>): any {\r\n        if (!targetObj) return targetObj;\r\n        if (!targetObj._subMaps || !targetObj._subMaps[key]) return (targetObj as Dictionary)[key];\r\n        // if is a nexted subobject\r\n        let context: MapLogicContext = new MapLogicContext(proxyitself as any, targetObj, key, []);\r\n        let retRaw: Dictionary = this.lg[this.s + key]\r\n        return MapProxyHandler.mapWrap((targetObj as Dictionary)[key], targetObj as any, this.additionalPath + '.' + key)\r\n    }\r\n\r\n    public defaultSetter(targetObj: DPointerTargetable, propKey: string, value: any, proxyitself?: Proxyfied<ME>): boolean {\r\n        SetFieldAction.new(targetObj, propKey as any, value);\r\n        return true;\r\n    }\r\n\r\n    public set(targetObj: ME, propKey: string | symbol, value: any, proxyitself?: Proxyfied<ME>): boolean {\r\n        // console.error('_proxy set PRE:', {targetObj, propKey, value, proxyitself, arguments});\r\n        // if (propKey in this.l || propKey in this.d || (this.l as GObject)[this.s + (propKey as string)] || (this.l as GObject)[(propKey as string)]) {\r\n\r\n        if ((this.d as GObject).__readonly && propKey !== '__readonly') {\r\n            //todo if there is a transaction open i should throw exception?\r\n            if(ABORT()){\r\n                Log.ee('Transaction aborted because an object is readonly:', this.d);\r\n            }\r\n            return true;\r\n        }\r\n        switch (typeof propKey) {\r\n            case \"symbol\":\r\n                propKey = String(propKey);\r\n                Log.exDevv('unexpected symbol in proxy setter:', propKey);\r\n                break;\r\n            default: break;\r\n        }\r\n\r\n        switch (propKey) {\r\n            case 'parent': propKey = 'father'; break;\r\n        }\r\n\r\n        if (propKey in this.l || propKey in this.d || (this.l as GObject)[this.s + (propKey as string)]) {\r\n            // todo: il LogicContext passato come parametro risulta nell'autocompletion editor automaticamente generato, come passo un parametro senza passargli il parametro? uso arguments senza dichiararlo?\r\n            if (typeof propKey !== 'symbol' && this.s + propKey in this.lg) {\r\n                this.lg[this.s + propKey](value, new LogicContext(proxyitself as any, targetObj));\r\n                return true;\r\n            }\r\n\r\n\r\n            // se esiste la proprietà ma non esiste il setter?\r\n            // Log.eDevv(\"dev error: property exist but setter does not: \", propKey, this);\r\n            // return false;\r\n        }\r\n        // if property do not exist\r\n\r\n        // if custom generic setter exist\r\n        // @ts-ignore private property\r\n        if (this.lg._defaultSetter) { // @ts-ignore private property\r\n            this.lg._defaultSetter(value, new LogicContext(proxyitself as any, targetObj), propKey);\r\n            return true;\r\n        }\r\n        /*if (enableFallbackSetter && typeof (propKey === \"string\") && ((propKey as string)[0] === '_' || (propKey as string).indexOf('tmp') > 0)) {\r\n            return this.defaultSetter(targetObj as any as DPointerTargetable, propKey as string, value, proxyitself);\r\n            // new SetFieldAction(new LogicContext(proxyitself as any, targetObj).data as any, propKey as string, value); return true;\r\n        }*/\r\n        let canThrowErrors = true;\r\n        Log.ex(canThrowErrors,'SET property \"set_' + (propKey as any) + '\" do not exist in object of type \"' + U.getType(this.l) + \" DType:\" +  U.getType(this.l), {'this': this, targetObj});\r\n        return false; }\r\n    /*      problema: ogni oggetto deve avere multipli puntatori, quando ne modifico uno devo modificarli tutti, come tengo traccia?\r\n            ipotesi 1: lo memorizzo in un solo posto (store.idlookup) e uso Pointer<type, lb, ub> che è una stringa che simula un puntatore\r\n            problema 1: se fornisco l'intero store ai componenti si aggiornano ad ogni singola modifica, se estraggo i campi interesasti le stringhe puntatore sono invariate ma il contenuto puntato è cambiato e il componente non lo sa...\r\n            problemone 2: non so a quali proprietà dello store devo abbonarmi, devo leggere sempre tutto lo store?\r\n            !!!!! soluzione 2?: dovrei dichiarare le variabili a cui mi abbono, salvarle nello stato e precaricarle tramite mapStateToProps*/\r\n\r\n    public deleteProperty(target: ME, key: string | symbol, proxyItself?: Proxyfied<any>): boolean {\r\n        if (typeof key === \"symbol\") return false;\r\n        this.set(target, key, undefined, proxyItself);\r\n        delete target[key];\r\n        return true; }\r\n\r\n    private mergedObject(target: ME): GObject{\r\n        let ret: GObject = {...target}; // U.arrayMergeInPlace(Object.keys(target), Object.keys(this.l).filter(k => k.indexOf('set_') !== 0 && k.indexOf('get_') !== 0));\r\n        for (let k in this.l) {\r\n            if (!(k in ret) && k.lastIndexOf('get_', 4) !== 0 && k.lastIndexOf('set_', 4) !== 0) ret[k] = true;\r\n        }\r\n        return ret;\r\n    }\r\n    ownKeys(target: ME): ArrayLike<string | symbol>{\r\n        const ret: GObject = this.mergedObject(target);\r\n        // ret = Reflect.ownKeys(ret);\r\n        return Reflect.ownKeys(ret);\r\n    }\r\n\r\n    // has(target: ME, p: string | symbol): boolean { return p in this.mergedObject(target); }\r\n    has(target: ME, p: string | symbol): boolean { return (p in target) || (p in this.l); }\r\n\r\n    /*\r\n    apply(target: DModelElement, thisArg: any, argArray: any[]): any {\r\n        // will i ever use it? dovrei pasare una funzione invece di una classe, quindi in questo caso credo wrappi solo il costruttore\r\n    }*/\r\n}\r\nRuntimeAccessibleClass.set_extend(MyProxyHandler, TargetableProxyHandler);\r\n@RuntimeAccessible('MapProxyHandler')\r\nexport class MapProxyHandler extends TargetableProxyHandler<Dictionary, LPointerTargetable> {\r\n    // todo: sposta alcune funzioni da TargetableProxy a MyProxy e fai estendere direttamente MyProxy a questa classe\r\n    public subMapKeys: Dictionary<string, any | Dictionary<DocString<'nested map keys'>>>;\r\n\r\n    constructor(d: Dictionary, baseObjInLookup: DPointerTargetable, additionalPath: string = '', subMapKeys: Dictionary<string, any | Dictionary<DocString<'nested map keys'>>> = {}) {\r\n        super(d, baseObjInLookup, additionalPath, LPointerTargetable.singleton);\r\n        this.subMapKeys = subMapKeys;\r\n    }\r\n\r\n    get(target: Dictionary, key: string | number | symbol, proxyitself: Proxyfied<Dictionary>): any {\r\n        if (typeof key === \"symbol\") return this.d[key as any];\r\n        let val: any = this.d[key];\r\n        if (key in this.subMapKeys && !(key in target)) { Log.exx('property not found in dictionary', {target, key, thiss:this, proxyitself, submapkeys: this.subMapKeys}); return undefined; }\r\n        if (key in this.subMapKeys) {\r\n            this.additionalPath += '.';\r\n            return MapProxyHandler.mapWrap( this.d, this.baseObjInLookup, this.additionalPath, this.subMapKeys[key]);\r\n            Log.exDevv('todo: wrap sub-map', {thiss: this});\r\n        }\r\n        return target[key as string]; }\r\n\r\n    set(target: Dictionary, key: string | number | symbol, value: any, proxyitself: Proxyfied<Dictionary>): boolean {\r\n        if (typeof key === \"symbol\") { Log.exx('cannot set a symbol in dictionary', {target, key, value, proxyitself}); return false; }\r\n        SetRootFieldAction.new(this.additionalPath + '.' + key, value, '',false)\r\n        return true;\r\n    }\r\n\r\n    public deleteProperty(target: Dictionary, key: string | symbol, proxyItself?: Proxyfied<any>): boolean {\r\n        if (typeof key === \"symbol\") return false;\r\n        this.set(target, key, undefined, proxyItself);\r\n        delete target[key];\r\n        return true; }\r\n}\r\nRuntimeAccessibleClass.set_extend(MyProxyHandler, MapProxyHandler);\r\n// 15-20 min + 5 di domande entro il 1° ottobre, discussione 10-12 ottobre\r\nexport const getPath: GetPath = new Proxy( {}, new GetPathHandler());\r\n(window as any).getPath = getPath;\r\n// usage: pathstring = ((getPath as DType).some.path.to.follow as any).$; // = \"some.path.to.follow\" with compilation-time validation\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}