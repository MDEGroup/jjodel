{"ast":null,"code":"/**\n * Copyright 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/*jslint node: true*/\n\"use strict\";\n\nvar esprima = require('esprima-fb');\nvar utils = require('./utils');\nvar getBoundaryNode = utils.getBoundaryNode;\nvar declareIdentInScope = utils.declareIdentInLocalScope;\nvar initScopeMetadata = utils.initScopeMetadata;\nvar Syntax = esprima.Syntax;\n\n/**\n * @param {object} node\n * @param {object} parentNode\n * @return {boolean}\n */\nfunction _nodeIsClosureScopeBoundary(node, parentNode) {\n  if (node.type === Syntax.Program) {\n    return true;\n  }\n  var parentIsFunction = parentNode.type === Syntax.FunctionDeclaration || parentNode.type === Syntax.FunctionExpression || parentNode.type === Syntax.ArrowFunctionExpression;\n  var parentIsCurlylessArrowFunc = parentNode.type === Syntax.ArrowFunctionExpression && node === parentNode.body;\n  return parentIsFunction && (node.type === Syntax.BlockStatement || parentIsCurlylessArrowFunc);\n}\nfunction _nodeIsBlockScopeBoundary(node, parentNode) {\n  if (node.type === Syntax.Program) {\n    return false;\n  }\n  return node.type === Syntax.BlockStatement && parentNode.type === Syntax.CatchClause;\n}\n\n/**\n * @param {object} node\n * @param {array} path\n * @param {object} state\n */\nfunction traverse(node, path, state) {\n  /*jshint -W004*/\n  // Create a scope stack entry if this is the first node we've encountered in\n  // its local scope\n  var startIndex = null;\n  var parentNode = path[0];\n  if (!Array.isArray(node) && state.localScope.parentNode !== parentNode) {\n    if (_nodeIsClosureScopeBoundary(node, parentNode)) {\n      var scopeIsStrict = state.scopeIsStrict;\n      if (!scopeIsStrict && (node.type === Syntax.BlockStatement || node.type === Syntax.Program)) {\n        scopeIsStrict = node.body.length > 0 && node.body[0].type === Syntax.ExpressionStatement && node.body[0].expression.type === Syntax.Literal && node.body[0].expression.value === 'use strict';\n      }\n      if (node.type === Syntax.Program) {\n        startIndex = state.g.buffer.length;\n        state = utils.updateState(state, {\n          scopeIsStrict: scopeIsStrict\n        });\n      } else {\n        startIndex = state.g.buffer.length + 1;\n        state = utils.updateState(state, {\n          localScope: {\n            parentNode: parentNode,\n            parentScope: state.localScope,\n            identifiers: {},\n            tempVarIndex: 0,\n            tempVars: []\n          },\n          scopeIsStrict: scopeIsStrict\n        });\n\n        // All functions have an implicit 'arguments' object in scope\n        declareIdentInScope('arguments', initScopeMetadata(node), state);\n\n        // Include function arg identifiers in the scope boundaries of the\n        // function\n        if (parentNode.params.length > 0) {\n          var param;\n          var metadata = initScopeMetadata(parentNode, path.slice(1), path[0]);\n          for (var i = 0; i < parentNode.params.length; i++) {\n            param = parentNode.params[i];\n            if (param.type === Syntax.Identifier) {\n              declareIdentInScope(param.name, metadata, state);\n            }\n          }\n        }\n\n        // Include rest arg identifiers in the scope boundaries of their\n        // functions\n        if (parentNode.rest) {\n          var metadata = initScopeMetadata(parentNode, path.slice(1), path[0]);\n          declareIdentInScope(parentNode.rest.name, metadata, state);\n        }\n\n        // Named FunctionExpressions scope their name within the body block of\n        // themselves only\n        if (parentNode.type === Syntax.FunctionExpression && parentNode.id) {\n          var metaData = initScopeMetadata(parentNode, path.parentNodeslice, parentNode);\n          declareIdentInScope(parentNode.id.name, metaData, state);\n        }\n      }\n\n      // Traverse and find all local identifiers in this closure first to\n      // account for function/variable declaration hoisting\n      collectClosureIdentsAndTraverse(node, path, state);\n    }\n    if (_nodeIsBlockScopeBoundary(node, parentNode)) {\n      startIndex = state.g.buffer.length;\n      state = utils.updateState(state, {\n        localScope: {\n          parentNode: parentNode,\n          parentScope: state.localScope,\n          identifiers: {},\n          tempVarIndex: 0,\n          tempVars: []\n        }\n      });\n      if (parentNode.type === Syntax.CatchClause) {\n        var metadata = initScopeMetadata(parentNode, path.slice(1), parentNode);\n        declareIdentInScope(parentNode.param.name, metadata, state);\n      }\n      collectBlockIdentsAndTraverse(node, path, state);\n    }\n  }\n\n  // Only catchup() before and after traversing a child node\n  function traverser(node, path, state) {\n    node.range && utils.catchup(node.range[0], state);\n    traverse(node, path, state);\n    node.range && utils.catchup(node.range[1], state);\n  }\n  utils.analyzeAndTraverse(walker, traverser, node, path, state);\n\n  // Inject temp variables into the scope.\n  if (startIndex !== null) {\n    utils.injectTempVarDeclarations(state, startIndex);\n  }\n}\nfunction collectClosureIdentsAndTraverse(node, path, state) {\n  utils.analyzeAndTraverse(visitLocalClosureIdentifiers, collectClosureIdentsAndTraverse, node, path, state);\n}\nfunction collectBlockIdentsAndTraverse(node, path, state) {\n  utils.analyzeAndTraverse(visitLocalBlockIdentifiers, collectBlockIdentsAndTraverse, node, path, state);\n}\nfunction visitLocalClosureIdentifiers(node, path, state) {\n  var metaData;\n  switch (node.type) {\n    case Syntax.ArrowFunctionExpression:\n    case Syntax.FunctionExpression:\n      // Function expressions don't get their names (if there is one) added to\n      // the closure scope they're defined in\n      return false;\n    case Syntax.ClassDeclaration:\n    case Syntax.ClassExpression:\n    case Syntax.FunctionDeclaration:\n      if (node.id) {\n        metaData = initScopeMetadata(getBoundaryNode(path), path.slice(), node);\n        declareIdentInScope(node.id.name, metaData, state);\n      }\n      return false;\n    case Syntax.VariableDeclarator:\n      // Variables have function-local scope\n      if (path[0].kind === 'var') {\n        metaData = initScopeMetadata(getBoundaryNode(path), path.slice(), node);\n        declareIdentInScope(node.id.name, metaData, state);\n      }\n      break;\n  }\n}\nfunction visitLocalBlockIdentifiers(node, path, state) {\n  // TODO: Support 'let' here...maybe...one day...or something...\n  if (node.type === Syntax.CatchClause) {\n    return false;\n  }\n}\nfunction walker(node, path, state) {\n  var visitors = state.g.visitors;\n  for (var i = 0; i < visitors.length; i++) {\n    if (visitors[i].test(node, path, state)) {\n      return visitors[i](traverse, node, path, state);\n    }\n  }\n}\nvar _astCache = {};\nfunction getAstForSource(source, options) {\n  if (_astCache[source] && !options.disableAstCache) {\n    return _astCache[source];\n  }\n  var ast = esprima.parse(source, {\n    comment: true,\n    loc: true,\n    range: true,\n    sourceType: options.sourceType\n  });\n  if (!options.disableAstCache) {\n    _astCache[source] = ast;\n  }\n  return ast;\n}\n\n/**\n * Applies all available transformations to the source\n * @param {array} visitors\n * @param {string} source\n * @param {?object} options\n * @return {object}\n */\nfunction transform(visitors, source, options) {\n  options = options || {};\n  var ast;\n  try {\n    ast = getAstForSource(source, options);\n  } catch (e) {\n    e.message = 'Parse Error: ' + e.message;\n    throw e;\n  }\n  var state = utils.createState(source, ast, options);\n  state.g.visitors = visitors;\n  if (options.sourceMap) {\n    var SourceMapGenerator = require('source-map').SourceMapGenerator;\n    state.g.sourceMap = new SourceMapGenerator({\n      file: options.filename || 'transformed.js'\n    });\n  }\n  traverse(ast, [], state);\n  utils.catchup(source.length, state);\n  var ret = {\n    code: state.g.buffer,\n    extra: state.g.extra\n  };\n  if (options.sourceMap) {\n    ret.sourceMap = state.g.sourceMap;\n    ret.sourceMapFilename = options.filename || 'source.js';\n  }\n  return ret;\n}\nexports.transform = transform;\nexports.Syntax = Syntax;","map":{"version":3,"names":["esprima","require","utils","getBoundaryNode","declareIdentInScope","declareIdentInLocalScope","initScopeMetadata","Syntax","_nodeIsClosureScopeBoundary","node","parentNode","type","Program","parentIsFunction","FunctionDeclaration","FunctionExpression","ArrowFunctionExpression","parentIsCurlylessArrowFunc","body","BlockStatement","_nodeIsBlockScopeBoundary","CatchClause","traverse","path","state","startIndex","Array","isArray","localScope","scopeIsStrict","length","ExpressionStatement","expression","Literal","value","g","buffer","updateState","parentScope","identifiers","tempVarIndex","tempVars","params","param","metadata","slice","i","Identifier","name","rest","id","metaData","parentNodeslice","collectClosureIdentsAndTraverse","collectBlockIdentsAndTraverse","traverser","range","catchup","analyzeAndTraverse","walker","injectTempVarDeclarations","visitLocalClosureIdentifiers","visitLocalBlockIdentifiers","ClassDeclaration","ClassExpression","VariableDeclarator","kind","visitors","test","_astCache","getAstForSource","source","options","disableAstCache","ast","parse","comment","loc","sourceType","transform","e","message","createState","sourceMap","SourceMapGenerator","file","filename","ret","code","extra","sourceMapFilename","exports"],"sources":["C:/d/Programming/web/jodel-mde/node_modules/jstransform/src/jstransform.js"],"sourcesContent":["/**\n * Copyright 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n\n/*jslint node: true*/\n\"use strict\";\n\nvar esprima = require('esprima-fb');\nvar utils = require('./utils');\n\nvar getBoundaryNode = utils.getBoundaryNode;\nvar declareIdentInScope = utils.declareIdentInLocalScope;\nvar initScopeMetadata = utils.initScopeMetadata;\nvar Syntax = esprima.Syntax;\n\n/**\n * @param {object} node\n * @param {object} parentNode\n * @return {boolean}\n */\nfunction _nodeIsClosureScopeBoundary(node, parentNode) {\n  if (node.type === Syntax.Program) {\n    return true;\n  }\n\n  var parentIsFunction =\n    parentNode.type === Syntax.FunctionDeclaration\n    || parentNode.type === Syntax.FunctionExpression\n    || parentNode.type === Syntax.ArrowFunctionExpression;\n\n  var parentIsCurlylessArrowFunc =\n    parentNode.type === Syntax.ArrowFunctionExpression\n    && node === parentNode.body;\n\n  return parentIsFunction\n         && (node.type === Syntax.BlockStatement || parentIsCurlylessArrowFunc);\n}\n\nfunction _nodeIsBlockScopeBoundary(node, parentNode) {\n  if (node.type === Syntax.Program) {\n    return false;\n  }\n\n  return node.type === Syntax.BlockStatement\n         && parentNode.type === Syntax.CatchClause;\n}\n\n/**\n * @param {object} node\n * @param {array} path\n * @param {object} state\n */\nfunction traverse(node, path, state) {\n  /*jshint -W004*/\n  // Create a scope stack entry if this is the first node we've encountered in\n  // its local scope\n  var startIndex = null;\n  var parentNode = path[0];\n  if (!Array.isArray(node) && state.localScope.parentNode !== parentNode) {\n    if (_nodeIsClosureScopeBoundary(node, parentNode)) {\n      var scopeIsStrict = state.scopeIsStrict;\n      if (!scopeIsStrict\n          && (node.type === Syntax.BlockStatement\n              || node.type === Syntax.Program)) {\n          scopeIsStrict =\n            node.body.length > 0\n            && node.body[0].type === Syntax.ExpressionStatement\n            && node.body[0].expression.type === Syntax.Literal\n            && node.body[0].expression.value === 'use strict';\n      }\n\n      if (node.type === Syntax.Program) {\n        startIndex = state.g.buffer.length;\n        state = utils.updateState(state, {\n          scopeIsStrict: scopeIsStrict\n        });\n      } else {\n        startIndex = state.g.buffer.length + 1;\n        state = utils.updateState(state, {\n          localScope: {\n            parentNode: parentNode,\n            parentScope: state.localScope,\n            identifiers: {},\n            tempVarIndex: 0,\n            tempVars: []\n          },\n          scopeIsStrict: scopeIsStrict\n        });\n\n        // All functions have an implicit 'arguments' object in scope\n        declareIdentInScope('arguments', initScopeMetadata(node), state);\n\n        // Include function arg identifiers in the scope boundaries of the\n        // function\n        if (parentNode.params.length > 0) {\n          var param;\n          var metadata = initScopeMetadata(parentNode, path.slice(1), path[0]);\n          for (var i = 0; i < parentNode.params.length; i++) {\n            param = parentNode.params[i];\n            if (param.type === Syntax.Identifier) {\n              declareIdentInScope(param.name, metadata, state);\n            }\n          }\n        }\n\n        // Include rest arg identifiers in the scope boundaries of their\n        // functions\n        if (parentNode.rest) {\n          var metadata = initScopeMetadata(\n            parentNode,\n            path.slice(1),\n            path[0]\n          );\n          declareIdentInScope(parentNode.rest.name, metadata, state);\n        }\n\n        // Named FunctionExpressions scope their name within the body block of\n        // themselves only\n        if (parentNode.type === Syntax.FunctionExpression && parentNode.id) {\n          var metaData =\n            initScopeMetadata(parentNode, path.parentNodeslice, parentNode);\n          declareIdentInScope(parentNode.id.name, metaData, state);\n        }\n      }\n\n      // Traverse and find all local identifiers in this closure first to\n      // account for function/variable declaration hoisting\n      collectClosureIdentsAndTraverse(node, path, state);\n    }\n\n    if (_nodeIsBlockScopeBoundary(node, parentNode)) {\n      startIndex = state.g.buffer.length;\n      state = utils.updateState(state, {\n        localScope: {\n          parentNode: parentNode,\n          parentScope: state.localScope,\n          identifiers: {},\n          tempVarIndex: 0,\n          tempVars: []\n        }\n      });\n\n      if (parentNode.type === Syntax.CatchClause) {\n        var metadata = initScopeMetadata(\n          parentNode,\n          path.slice(1),\n          parentNode\n        );\n        declareIdentInScope(parentNode.param.name, metadata, state);\n      }\n      collectBlockIdentsAndTraverse(node, path, state);\n    }\n  }\n\n  // Only catchup() before and after traversing a child node\n  function traverser(node, path, state) {\n    node.range && utils.catchup(node.range[0], state);\n    traverse(node, path, state);\n    node.range && utils.catchup(node.range[1], state);\n  }\n\n  utils.analyzeAndTraverse(walker, traverser, node, path, state);\n\n  // Inject temp variables into the scope.\n  if (startIndex !== null) {\n    utils.injectTempVarDeclarations(state, startIndex);\n  }\n}\n\nfunction collectClosureIdentsAndTraverse(node, path, state) {\n  utils.analyzeAndTraverse(\n    visitLocalClosureIdentifiers,\n    collectClosureIdentsAndTraverse,\n    node,\n    path,\n    state\n  );\n}\n\nfunction collectBlockIdentsAndTraverse(node, path, state) {\n  utils.analyzeAndTraverse(\n    visitLocalBlockIdentifiers,\n    collectBlockIdentsAndTraverse,\n    node,\n    path,\n    state\n  );\n}\n\nfunction visitLocalClosureIdentifiers(node, path, state) {\n  var metaData;\n  switch (node.type) {\n    case Syntax.ArrowFunctionExpression:\n    case Syntax.FunctionExpression:\n      // Function expressions don't get their names (if there is one) added to\n      // the closure scope they're defined in\n      return false;\n    case Syntax.ClassDeclaration:\n    case Syntax.ClassExpression:\n    case Syntax.FunctionDeclaration:\n      if (node.id) {\n        metaData = initScopeMetadata(getBoundaryNode(path), path.slice(), node);\n        declareIdentInScope(node.id.name, metaData, state);\n      }\n      return false;\n    case Syntax.VariableDeclarator:\n      // Variables have function-local scope\n      if (path[0].kind === 'var') {\n        metaData = initScopeMetadata(getBoundaryNode(path), path.slice(), node);\n        declareIdentInScope(node.id.name, metaData, state);\n      }\n      break;\n  }\n}\n\nfunction visitLocalBlockIdentifiers(node, path, state) {\n  // TODO: Support 'let' here...maybe...one day...or something...\n  if (node.type === Syntax.CatchClause) {\n    return false;\n  }\n}\n\nfunction walker(node, path, state) {\n  var visitors = state.g.visitors;\n  for (var i = 0; i < visitors.length; i++) {\n    if (visitors[i].test(node, path, state)) {\n      return visitors[i](traverse, node, path, state);\n    }\n  }\n}\n\nvar _astCache = {};\n\nfunction getAstForSource(source, options) {\n  if (_astCache[source] && !options.disableAstCache) {\n    return _astCache[source];\n  }\n  var ast = esprima.parse(source, {\n    comment: true,\n    loc: true,\n    range: true,\n    sourceType: options.sourceType\n  });\n  if (!options.disableAstCache) {\n    _astCache[source] = ast;\n  }\n  return ast;\n}\n\n/**\n * Applies all available transformations to the source\n * @param {array} visitors\n * @param {string} source\n * @param {?object} options\n * @return {object}\n */\nfunction transform(visitors, source, options) {\n  options = options || {};\n  var ast;\n  try {\n    ast = getAstForSource(source, options);\n    } catch (e) {\n    e.message = 'Parse Error: ' + e.message;\n    throw e;\n  }\n  var state = utils.createState(source, ast, options);\n  state.g.visitors = visitors;\n\n  if (options.sourceMap) {\n    var SourceMapGenerator = require('source-map').SourceMapGenerator;\n    state.g.sourceMap = new SourceMapGenerator({file: options.filename || 'transformed.js'});\n  }\n\n  traverse(ast, [], state);\n  utils.catchup(source.length, state);\n\n  var ret = {code: state.g.buffer, extra: state.g.extra};\n  if (options.sourceMap) {\n    ret.sourceMap = state.g.sourceMap;\n    ret.sourceMapFilename =  options.filename || 'source.js';\n  }\n  return ret;\n}\n\nexports.transform = transform;\nexports.Syntax = Syntax;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}