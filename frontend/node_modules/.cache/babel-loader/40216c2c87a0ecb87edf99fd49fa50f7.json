{"ast":null,"code":"let _Symbol$iterator;\nimport { Log } from \"../joiner\";\n\n/* problema: se creo una key per ordinare l'albero e trovare \"of\" in O(log n), allora perdo l'ordinamento arbitrario di sottoalberi = sottoclassi a prescindere dai nomi.\r\n   potrei fare un dizionario di alberi, 1 albero per ogni dclass e lclass, con sottoelementi\r\n    */\n\n// not binary, not rb tree, not balanced, just a tree\n// it is N-ary\n// ma probabilmente non dovrei usare affatto un albero, ma fare un dizionario per ogni classe con cosa estende direttamente\n// e uno con cosa estende direttamente e indirettamente popolato automaticamente in n*logn una volta e fine\n// navigando superclass\n\n// B.superclass = [a1, a2] --- > a1.pushdirectsubclass(b), a2 same.  poi se a1 estende c, c.pushindirectsubclass(b)... e si risale da b finchè ci sono superclassi (logn) volte, fatto per tutte le n classi\n// each node have a \"node<T>\" value and a subtree with all subelements.\n// iterable with for...of with width iterator (not depth)\n_Symbol$iterator = Symbol.iterator;\nexport class SimpleTree {\n  // can be undef, if root was an array instead of a single element.\n  // the nodes containing the rooots will be the childrens instead, as if they are N trees\n  // with a fake node joining them in a single one\n  // up: SimpleTree<T>; maybe do this too\n  getiIsSubElementMatrix(namekey) {\n    let ret = {}; // matrix name x name telling if A extends B\n    for (let o of this) {\n      // O(N^2), but optimal for this task, as the matrix size is O(N^2) as well\n      let name = o.node[namekey];\n      if (!name) Log.ee(\"missing key property  in tree node: \", {\n        tree: this,\n        node: o.node,\n        namekey\n      });\n      ret[name] = {};\n      // if (o === this) continue;\n      for (let subo of o) {\n        let subname = subo.node[namekey];\n        if (!subname) {\n          console.log(\"skipped\");\n          continue;\n        }\n        ret[name][subname] = true;\n      }\n    }\n    return ret;\n  }\n  add(e, childKey, loopdetector) {\n    if (loopdetector) {\n      if (loopdetector.get(e)) {\n        Log.eDev(e.cname.indexOf(\"GraphVertex\") !== 1, \"A constructor is extending 2 different classes, or there is a loop in Tree constructor parameter.\", \"GraphVertex should be the only class doing that currently\", {\n          e,\n          cname: e.cname,\n          childKey,\n          loopdetector\n        });\n        return;\n      }\n      loopdetector.set(e, true);\n    }\n    let subtree = new SimpleTree(e, childKey, loopdetector);\n    this.subelements.push(subtree);\n    return subtree;\n  }\n  getSubtree(e) {\n    for (let t of this) {\n      if (t.node == e) return t;\n    }\n    return undefined;\n  }\n\n  // childkey: adds subobjects found in \"roots\" parameters as nodes<T> in the tree\n  // comparison: tells if a node comes first or after another, example: (a, b) => a.name.toUpperCase() < b.name.toUpperCase()\n  constructor(roots, childKey, loopdetector) {\n    this.subelements = void 0;\n    this.node = void 0;\n    this[_Symbol$iterator] = function* () {\n      // [Symbol.iterator]: Generator<number, string, boolean> = function*() {\n      // [Symbol.iterator]: Generator<number, string, boolean>= () => {\n      // [Symbol.iterator] () {\n      yield this;\n      let fifo = this.subelements;\n      while (fifo.length) {\n        let nextLevel = [];\n        for (let subtree of fifo) {\n          yield subtree;\n          nextLevel.push(...subtree.subelements);\n        }\n        //@ts-ignore\n        // console.log(\"fifo -> next level\", fifo.map(f=>f?.node?.cname), nextLevel.map(f=>f?.node?.cname));\n        fifo = nextLevel;\n      }\n    };\n    // if arr, add N roots as subelements, and delegate actual subelements of the root to subtree constructors\n    if (!loopdetector) loopdetector = new WeakMap();\n    /*(this as any)[Symbol.iterator] = function *(){\r\n        yield this;\r\n        let fifo = this.subelements;\r\n        while (fifo.length) {\r\n            let nextLevel = [];\r\n            for (let subtree of fifo) {\r\n                yield subtree;\r\n                nextLevel.push(subtree);\r\n            }\r\n            fifo = nextLevel;\r\n        }\r\n    }*/\n\n    //@ts-ignore\n    this.debug = roots.cname;\n    this.subelements = [];\n    if (Array.isArray(roots)) {\n      this.node = undefined;\n      for (let e of roots) {\n        if (!e) continue;\n        this.add(e, childKey, loopdetector);\n      }\n    }\n    // if not arr, add immediate subelements of root\n    else {\n      this.node = roots;\n      if (!childKey) return;\n      let child = this.node[childKey];\n      if (Array.isArray(child)) {\n        for (let c of child) this.add(c, childKey, loopdetector);\n      } else this.add(child, childKey, loopdetector);\n    }\n  }\n}","map":{"version":3,"names":["Log","_Symbol$iterator","Symbol","iterator","SimpleTree","getiIsSubElementMatrix","namekey","ret","o","name","node","ee","tree","subo","subname","console","log","add","e","childKey","loopdetector","get","eDev","cname","indexOf","set","subtree","subelements","push","getSubtree","t","undefined","constructor","roots","fifo","length","nextLevel","WeakMap","debug","Array","isArray","child","c"],"sources":["C:/d/Programming/web/jodel-mde/src/common/SimpleTree.ts"],"sourcesContent":["import {Dictionary, GObject, Log, U} from \"../joiner\";\r\n\r\n\r\n/* problema: se creo una key per ordinare l'albero e trovare \"of\" in O(log n), allora perdo l'ordinamento arbitrario di sottoalberi = sottoclassi a prescindere dai nomi.\r\n   potrei fare un dizionario di alberi, 1 albero per ogni dclass e lclass, con sottoelementi\r\n    */\r\n\r\n// not binary, not rb tree, not balanced, just a tree\r\n// it is N-ary\r\n// ma probabilmente non dovrei usare affatto un albero, ma fare un dizionario per ogni classe con cosa estende direttamente\r\n// e uno con cosa estende direttamente e indirettamente popolato automaticamente in n*logn una volta e fine\r\n// navigando superclass\r\n\r\n// B.superclass = [a1, a2] --- > a1.pushdirectsubclass(b), a2 same.  poi se a1 estende c, c.pushindirectsubclass(b)... e si risale da b finchè ci sono superclassi (logn) volte, fatto per tutte le n classi\r\n// each node have a \"node<T>\" value and a subtree with all subelements.\r\n// iterable with for...of with width iterator (not depth)\r\nexport class SimpleTree<T extends GObject> {\r\n    subelements: SimpleTree<T>[];\r\n    node: T; // can be undef, if root was an array instead of a single element.\r\n    // the nodes containing the rooots will be the childrens instead, as if they are N trees\r\n    // with a fake node joining them in a single one\r\n    // up: SimpleTree<T>; maybe do this too\r\n\r\n    [Symbol.iterator] = function*(this:SimpleTree<T>) {\r\n    // [Symbol.iterator]: Generator<number, string, boolean> = function*() {\r\n    // [Symbol.iterator]: Generator<number, string, boolean>= () => {\r\n    // [Symbol.iterator] () {\r\n        yield this;\r\n        let fifo = this.subelements;\r\n        while (fifo.length) {\r\n            let nextLevel = [];\r\n            for (let subtree of fifo) {\r\n                yield subtree;\r\n                nextLevel.push(...subtree.subelements);\r\n            }\r\n            //@ts-ignore\r\n            // console.log(\"fifo -> next level\", fifo.map(f=>f?.node?.cname), nextLevel.map(f=>f?.node?.cname));\r\n            fifo = nextLevel;\r\n        }\r\n    }\r\n\r\n    getiIsSubElementMatrix(namekey: keyof T): Dictionary<string, Dictionary<string, boolean>>{\r\n        let ret: Dictionary<string, Dictionary<string, boolean>> = {}// matrix name x name telling if A extends B\r\n        for (let o of this) { // O(N^2), but optimal for this task, as the matrix size is O(N^2) as well\r\n            let name = o.node[namekey];\r\n            if (!name) Log.ee(\"missing key property  in tree node: \", {tree: this, node:o.node, namekey});\r\n            ret[name] = {};\r\n            // if (o === this) continue;\r\n            for (let subo of o) {\r\n                let subname = subo.node[namekey];\r\n                if (!subname) { console.log(\"skipped\"); continue; }\r\n                ret[name as string][subname as string] = true;\r\n            }\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    public add(e: T, childKey?: keyof T, loopdetector?: WeakMap<T, boolean>): SimpleTree<T> | undefined{\r\n        if (loopdetector) {\r\n            if (loopdetector.get(e)) {\r\n                Log.eDev(e.cname.indexOf(\"GraphVertex\") !== 1,\r\n                    \"A constructor is extending 2 different classes, or there is a loop in Tree constructor parameter.\",\r\n                    \"GraphVertex should be the only class doing that currently\",\r\n                    {e, cname:e.cname, childKey, loopdetector});\r\n                return;\r\n            }\r\n            loopdetector.set(e, true);\r\n        }\r\n        let subtree =  new SimpleTree<T>(e, childKey, loopdetector);\r\n        this.subelements.push(subtree);\r\n        return subtree; }\r\n\r\n    getSubtree(e: T): SimpleTree<T> | undefined {\r\n        for (let t of this) { if (t.node == e) return t; }\r\n        return undefined; }\r\n\r\n    // childkey: adds subobjects found in \"roots\" parameters as nodes<T> in the tree\r\n    // comparison: tells if a node comes first or after another, example: (a, b) => a.name.toUpperCase() < b.name.toUpperCase()\r\n    constructor(roots: GObject | GObject[], childKey?: keyof T, loopdetector?: WeakMap<T, boolean>) {\r\n        // if arr, add N roots as subelements, and delegate actual subelements of the root to subtree constructors\r\n        if (!loopdetector) loopdetector = new WeakMap();\r\n        /*(this as any)[Symbol.iterator] = function *(){\r\n            yield this;\r\n            let fifo = this.subelements;\r\n            while (fifo.length) {\r\n                let nextLevel = [];\r\n                for (let subtree of fifo) {\r\n                    yield subtree;\r\n                    nextLevel.push(subtree);\r\n                }\r\n                fifo = nextLevel;\r\n            }\r\n        }*/\r\n\r\n        //@ts-ignore\r\n        this.debug = roots.cname;\r\n        this.subelements = [];\r\n        if (Array.isArray(roots)) {\r\n            this.node = undefined as any;\r\n            for (let e of roots) {\r\n                if (!e) continue;\r\n                this.add(e as T, childKey, loopdetector);\r\n            }\r\n        }\r\n        // if not arr, add immediate subelements of root\r\n        else {\r\n            this.node = roots as T;\r\n            if (!childKey) return;\r\n            let child: T | T[] = this.node[childKey];\r\n            if (Array.isArray(child)) {\r\n                for (let c of child) this.add(c, childKey, loopdetector);\r\n            }\r\n            else this.add(child, childKey, loopdetector);\r\n        }\r\n    }\r\n\r\n\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}