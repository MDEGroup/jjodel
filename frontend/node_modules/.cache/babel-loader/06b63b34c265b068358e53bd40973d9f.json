{"ast":null,"code":"var _dec, _class, _class2, _dec2, _class3, _class4, _dec3, _class5, _dec4, _class6, _class7, _dec5, _class8, _class9, _dec6, _class10, _class11, _dec7, _class12, _dec8, _class13, _dec9, _class14, _dec10, _class15, _dec11, _class17, _class18, _dec12, _class19, _class20, _dec13, _class21, _class22, _dec14, _class23, _class24, _dec15, _class25;\nimport { Mixin } from \"ts-mixer\";\nimport { EdgeBendingMode, EdgeGapMode } from \"./types\";\nimport { Action, CreateElementAction, Defaults, DeleteElementAction, GraphPoint, GraphSize, LGraph, LModel, Log, LViewPoint, SetFieldAction, SetRootFieldAction, ShortAttribETypes, statehistory, store, TRANSACTION, U } from \"./index\";\nvar windoww = window;\n// qui dichiarazioni di tipi che non sono importabili con \"import type\", ma che devono essere davvero importate a run-time (eg. per fare un \"extend\", chiamare un costruttore o usare un metodo statico)\n\nconsole.warn('ts loading classes');\n\n// annotation @RuntimeAccessible\n// import {store} from \"../redux/createStore\";\n\nclass AbstractMixedClass {\n  // superclass!: Dictionary<DocString<'parent class name', Class>>;\n\n  // static [key: string]: any;\n  static init_constructor() {}\n}\nAbstractMixedClass.logic = void 0;\nAbstractMixedClass.structure = void 0;\nAbstractMixedClass.singleton = void 0;\nexport class RuntimeAccessibleClass extends AbstractMixedClass {\n  //static extendTree: TreeModel.Node<typeof RuntimeAccessibleClass>// Tree<string, typeof RuntimeAccessibleClass>;\n\n  // static name: never; // it breaks with minification, don't use it\n\n  static set_extend(superclass, subclass) {\n    if (!superclass.hasOwnProperty(\"subclasses\")) superclass.subclasses = [subclass];else if (superclass.subclasses.indexOf(subclass) === -1) superclass.subclasses.push(subclass);\n    if (!subclass.hasOwnProperty(\"_extends\")) subclass._extends = [superclass];else if (subclass._extends.indexOf(superclass) === -1) subclass._extends.push(superclass);\n  }\n  static extendPrototypes() {\n    Array.prototype.contains = function (o) {\n      return this.indexOf(o) !== -1;\n    };\n    Array.prototype.joinOriginal = Array.prototype.join;\n    // @ts-ignore\n    Array.prototype.first = function () {\n      return this[0];\n    };\n    // @ts-ignore\n    eval(\"Array.prototype.last = function(){ return this[this.length-1]; }\"); // without eval it still gives typescript error even with tsignore\n    // @ts-ignore\n    Array.prototype.separator = function () {\n      for (var _len = arguments.length, separators = new Array(_len), _key = 0; _key < _len; _key++) {\n        separators[_key] = arguments[_key];\n      }\n      if (Array.isArray(separators[0])) separators = separators[0]; // case .join([1,2,3])  --> .join(1, 2, 3)\n      // console.log(\"separators debug\", this, separators, this[0], typeof this[0]);\n      // if (typeof this[0] !== \"object\") return (this as any).joinOriginal(separators);\n      // if JSX\n      // it handles empty cells like it handles '', but this is how native .join() handles them too: [emptyx5, \"a\", emptyx1, \"b\"].join(\",\") ->  ,,,,,a,,b\n      let ret /*:JSX.Element[]*/ = [];\n      for (let i = 0; i < this.length; i++) {\n        if (i === 0) {\n          ret.push(this[i]);\n          continue;\n        }\n        ret.push(...separators);\n        ret.push(this[i]);\n      }\n      return ret;\n    };\n  }\n  static fixStatics() {\n    this.extendPrototypes();\n    for (let classs of Object.values(RuntimeAccessibleClass.annotatedClasses)) {\n      let gclass = classs;\n      for (let statickey in gclass.s) {\n        gclass[statickey] = gclass.s[statickey];\n      }\n    }\n  }\n  // static allRuntimeClasses: string[] = [];\n\n  static getAllNames() {\n    let annotated = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    return Object.keys(annotated ? RuntimeAccessibleClass.annotatedClasses : RuntimeAccessibleClass.classes);\n  }\n  static getAllClasses() {\n    let annotated = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    return Object.values(annotated ? RuntimeAccessibleClass.annotatedClasses : RuntimeAccessibleClass.classes);\n  }\n  static getAllClassesDictionary() {\n    let annotated = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    return annotated ? RuntimeAccessibleClass.annotatedClasses : RuntimeAccessibleClass.classes;\n  }\n  static wrapAll(data, baseObjInLookup) {\n    let path = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n    let canThrow = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    let state = arguments.length > 4 ? arguments[4] : undefined;\n    let filter = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;\n    if (!Array.isArray(data)) return [];\n    if (!data.length) return [];\n    if (!state) state = windoww.store.getState();\n    if (!filter) return data.map(d => DPointerTargetable.wrap(d, baseObjInLookup, path, canThrow, state));\n    let ret = [];\n    for (let o of data) {\n      if (o) ret.push(DPointerTargetable.wrap(o, baseObjInLookup, path, canThrow, state));\n    }\n    return ret;\n  }\n  static wrap(data, baseObjInLookup) {\n    let path = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n    let canThrow = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    let state = arguments.length > 4 ? arguments[4] : undefined;\n    if (!data || data.__isProxy) return data;\n    if (typeof data === 'string') {\n      data = DPointerTargetable.from(data, state);\n      if (!data) {\n        windoww.Log.e(canThrow, 'Cannot wrap:', {\n          data,\n          baseObjInLookup,\n          path\n        });\n        return undefined;\n      }\n    }\n    if (Array.isArray(data)) {\n      console.error('use WrapAll instead for arrays', {\n        data,\n        baseObjInLookup,\n        path,\n        canThrow\n      });\n      if (canThrow) throw new Error(\"use WrapAll instead for arrays\");else return undefined;\n    }\n    if (!data) return data;\n    // console.log('ProxyWrapping:', {data, baseObjInLookup, path});\n    return new Proxy(data, new windoww.TargetableProxyHandler(data, baseObjInLookup, path));\n  }\n\n  // if v can be wrapped, wrap it. otherwise return the parameter v.\n  static attemptWrap(v, s) {\n    let ret = undefined;\n    switch (typeof v) {\n      case \"string\":\n        s = store.getState();\n        ret = LPointerTargetable.fromPointer(v, s);\n        break;\n      case \"object\":\n        if (v.__isProxy) return v;\n        if (v.className) {\n          var _RuntimeAccessibleCla, _RuntimeAccessibleCla2;\n          if (!((_RuntimeAccessibleCla = RuntimeAccessibleClass.get(v === null || v === void 0 ? void 0 : v.className)) === null || _RuntimeAccessibleCla === void 0 ? void 0 : (_RuntimeAccessibleCla2 = _RuntimeAccessibleCla.logic) === null || _RuntimeAccessibleCla2 === void 0 ? void 0 : _RuntimeAccessibleCla2.singleton)) break;\n          ret = LPointerTargetable.fromD(v);\n        }\n        break;\n      default:\n        break;\n    }\n    return ret || v;\n  }\n  /*\r\n      static mapWrap2<D extends DPointerTargetable, L extends LPointerTargetable>(map: RuntimeAccessibleClass, container: D, baseObjInLookup?: DPointerTargetable, path: string = ''): L{\r\n          if (!map || (map as any).__isProxy) return map as any;\r\n          if (typeof container === 'string') {\r\n              container = store.getState().idlookup[container] as unknown as D;\r\n              if (!container) { return Log.exx('Cannot wrap map:', {map, container, baseObjInLookup, path}); }\r\n          }\r\n          // console.log('ProxyWrapping:', {data, baseObjInLookup, path});\r\n          return new Proxy(map, new MapProxyHandler(map, baseObjInLookup, path));\r\n      }\r\n    */\n\n  static mapWrap(data, baseObjInLookup, path) {\n    let subMapKeys = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];\n    if (!data || data.__isProxy) return data;\n    // console.error('GETMAP', {data, logicContext, path});\n    return new Proxy(data, new windoww.MapProxyHandler(data, baseObjInLookup, path));\n  }\n  constructor() {\n    super();\n    // RuntimeAccessibleClass.init_constructor(this, ...a);\n    // this.className = this.constructor.name;\n    // nb: per i mixin questo settaggio viene sovrascritto. perch√® il mixin crea le 2 classi ereditate separatamente con i loro costruttori e le incrocia. quindi devo settarlo dall'annotazione @ tramite prototype\n    // RuntimeAccessibleClass.allRuntimeClasses.push(this.className);\n    this.className = void 0;\n  }\n  static init_constructor(thiss) {\n\n    // this.className = this.constructor.name;\n    // let finalObject = this;\n    // if (finalObject.constructor.name === \"DVoidVertex\" || finalObject.constructor.name === \"DGraphElement\") { let breakp = true; }\n    // this.init0(...arguments);\n    // thiss.className = this.name;\n  }\n  static get(dclassname, mode) {\n    // believe it or not there are actually 3 different versions generated, with different static method contexts, it's a mess.\n    return this.classes[dclassname];\n    /*\r\n    switch(mode) {\r\n        case \"annotated version\":\r\n            /* it is like this in console\r\n            () {\r\n                var _obj$initBase;\r\n                for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\r\n            ...* /\r\n            return RuntimeAccessibleClass.annotatedClasses[dclassname] as any;\r\n        case \"local definition version\":\r\n        default: // same as window.classname\r\n        case \"module export version\":\r\n            /* it was like this in console, it is not anymore after reworking cname\r\n            // don't know how to get it now, but default version should be always the correct one,\r\n                class DClassifier extends _joiner__WEBPACK_IMPORTED_MODULE_0__[\"DPointerTargetable\"]\r\n            which is even wrong as i asked for DPointerTargetable and not DClassifier. * /\r\n        return null as any;\r\n    }*/\n  }\n\n  static extends(className, superClassName) {\n    var _RuntimeAccessibleCla3;\n    let returnIfEqual = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    if (!className || !superClassName) return false;\n    const superclass = typeof superClassName === \"string\" ? RuntimeAccessibleClass.get(superClassName) : superClassName;\n    const thisclass = typeof className === \"string\" ? RuntimeAccessibleClass.get(className) : className;\n    if (!superclass || !thisclass) return false;\n    //console.trace(\"extends.1:\", {thisclass, superclass});\n    // console.log(\"extends.2:\", {iof:(thisclass instanceof superclass),\n    //     tree: !!(RuntimeAccessibleClass.extendTree.first((node) => node.model === superclass)?.first((node) => node.model === thisclass))});\n    if (superclass === thisclass) return returnIfEqual;\n    // for (let aaa in RuntimeAccessibleClass.extendTree.find(superClassName)) { }\n\n    return thisclass instanceof superclass || ((_RuntimeAccessibleCla3 = RuntimeAccessibleClass.extendMatrix[superclass.cname]) === null || _RuntimeAccessibleCla3 === void 0 ? void 0 : _RuntimeAccessibleCla3[thisclass.cname]);\n    // !!(RuntimeAccessibleClass.extendTree.first((node) => node.model === superclass)?.first((node) => node.model === thisclass))\n    // || true;\n  }\n\n  getAllPrototypeSuperClasses() {\n    let currentlevel = this;\n    let ret = [];\n    while (true) {\n      if (!currentlevel) break;\n      ret.push(currentlevel);\n      // @ts-ignore\n      currentlevel = currentlevel.__proto__;\n    }\n    console.log('constructor chain:', ret);\n    return ret;\n  }\n  /*initBase(){\r\n      let superclasses = this.getAllPrototypeSuperClasses();\r\n      for (let sc of superclasses) {\r\n          if (!sc.hasOwnProperty('init0')) continue;\r\n          console.log('initbase calling ', {thiss: this, sc, init0: sc.init0, args:sc.constructorArguments});\r\n          sc.init0.apply(this, ...(sc.constructorArguments || []));\r\n      }\r\n  }*/\n  // protected abstract init(...constructorParameters: any): void;\n  // NB: per colpa della limitazione #3 di ts-mixer,\n  // DEVO chiamare init su ogni oggetto per settargli il corretto this.className, altrimenti prende quello dell'ultima superclasse\n  /*protected init0(...constructorParameters: any): void {\r\n      let a = this;\r\n      let finalObject = this;\r\n      console.log('creation of___ ', {thiss: this, finalObject});\r\n      if (finalObject.constructor.name === \"DVoidVertex\" || finalObject.constructor.name === \"DGraphElement\") {\r\n          let breakp = true; }\r\n        (window as any)[finalObject.constructor.name] =\r\n          RuntimeAccessibleClass.classes[finalObject.constructor.name] = finalObject.constructor as any;\r\n      // @ts-ignore\r\n      // delete this.className;\r\n      this.className = (finalObject as any).__proto__.className;\r\n  }*/\n\n  static makeOCLConstructor(data, state, oldState) {\n    var _rootModel;\n    let rootModel = data;\n    while (rootModel && rootModel.className !== \"DModel\") rootModel = DPointerTargetable.fromPointer(rootModel.father, state);\n    let mid = (_rootModel = rootModel) === null || _rootModel === void 0 ? void 0 : _rootModel.id; // NB: for EBoolean etc, primitive type meteclasses don't have a model;\n    if (!RuntimeAccessibleClass.OCL_Constructors[mid]) {\n      RuntimeAccessibleClass.OCL_Constructors[mid] = {\n        ...RuntimeAccessibleClass.classes\n      };\n    }\n    const OclConstructor = data;\n    let namefixed;\n    if (oldState && oldState.idlookup[data.id]) {\n      let oldname = oldState.idlookup[data.id].name;\n      namefixed = U.replaceAll(U.replaceAll(oldname, '-', '_'), ' ', '_');\n      delete RuntimeAccessibleClass.OCL_Constructors[mid][oldname];\n      delete RuntimeAccessibleClass.OCL_Constructors[mid][namefixed];\n    }\n    namefixed = U.replaceAll(U.replaceAll(data.name, '-', '_'), ' ', '_');\n    RuntimeAccessibleClass.OCL_Constructors[mid][data.name] = OclConstructor;\n    RuntimeAccessibleClass.OCL_Constructors[mid][namefixed] = OclConstructor;\n    return data;\n  }\n  static getOCLClasses(model_id) {\n    // return { ...(RuntimeAccessibleClass.OCL_Constructors[model_id] || {}), ...RuntimeAccessibleClass.classes}\n    return RuntimeAccessibleClass.OCL_Constructors[model_id] || RuntimeAccessibleClass.classes;\n  }\n}\nRuntimeAccessibleClass.subclasses = [];\nRuntimeAccessibleClass._extends = [];\nRuntimeAccessibleClass.extendMatrix = void 0;\nRuntimeAccessibleClass.cname = void 0;\nRuntimeAccessibleClass.OCL_Constructors = {};\nRuntimeAccessibleClass.classes = {};\nRuntimeAccessibleClass.annotatedClasses = {};\nexport function Obsolete(constructor) {\n  return constructor;\n}\n_c = Obsolete;\nexport function Leaf(constructor) {\n  return constructor;\n}\n_c2 = Leaf;\nexport function Node(constructor) {\n  return constructor;\n}\n_c3 = Node;\nexport function Abstract(constructor) {\n  return constructor;\n}\n_c4 = Abstract;\nexport function Instantiable(constructor, instanceConstructor) {\n  return constructor;\n} // for m2 cklasses that have m1 instances\n// export function RuntimeAccessible<T extends any>(cname: string): ((constructor: T & GObject) => T) {\n_c5 = Instantiable;\nexport function RuntimeAccessible(cname) {\n  return ctor => RuntimeAccessible_inner(ctor, cname);\n}\n_c6 = RuntimeAccessible;\nfunction RuntimeAccessible_inner(constructor, cname) {\n  // console.log('DecoratorTest', {constructor, arguments});\n  constructor.cname = cname;\n  if (!constructor.hasOwnProperty(\"subclasses\")) constructor.subclasses = [];\n  // @ts-ignore\n  RuntimeAccessibleClass.classes[constructor.cname] = constructor;\n  // console.log(\"setting runtime accessible\", {key: constructor.cname, constructor, pre: predebug, post: {...RuntimeAccessibleClass.classes}});\n  if (!windoww[constructor.cname]) windoww[constructor.cname] = constructor;\n  constructor.prototype.className = constructor.cname;\n  //constructor.prototype.$$typeof = constructor.cname;\n  //constructor.prototype.typeName = constructor.cname;\n  constructor.staticClassName = constructor.cname;\n  // @ts-ignore\n  // console.log('runtimeaccessible annotation:', {thiss:this, constructor});\n  //    const classnameFixedConstructor = constructor; //  function (...args) { let obj = new constructor(...args); obj.init?.(); obj.init0?.(); return obj; }\n\n  // @ts-ignore\n  let outerthis = this;\n  // @ts-ignore\n  const classnameFixedConstructorDoNotRenameWithoutSearchStrings = function () {\n    var _obj$initBase;\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n    // @ts-ignore\n    // console.log('runtimeaccessible annotation inner:', {thiss:this, outerthis, constructor});\n    // @ts-ignore\n    let obj = new constructor(...args);\n    obj.classNameFromAnnotation = constructor.cname;\n    obj.className = constructor.cname;\n    //obj.prototype.$$typeof = constructor.name;\n    // obj.prototype.typeName = constructor.name;\n    // obj.init?.();\n    // obj.init0?.();\n    (_obj$initBase = obj.initBase) === null || _obj$initBase === void 0 ? void 0 : _obj$initBase.call(obj);\n    // @ts-ignore\n    // console.log('runtimeaccessible annotation inner end:', {thiss:this, outerthis, constructor, obj});\n    return obj;\n  };\n  RuntimeAccessibleClass.annotatedClasses[constructor.cname] = classnameFixedConstructorDoNotRenameWithoutSearchStrings;\n  for (let key in constructor) classnameFixedConstructorDoNotRenameWithoutSearchStrings[key] = constructor[key];\n  // constructor.constructor = classnameFixedConstructorDoNotRenameWithoutSearchStrings; return constructor;\n\n  // @ts-ignore\n  // for (let staticKey of constructor as GObject) { classnameFixedConstructorDoNotRenameWithoutSearchStrings[staticKey] = constructor[staticKey]; }\n  classnameFixedConstructorDoNotRenameWithoutSearchStrings.prototype = constructor.prototype;\n  classnameFixedConstructorDoNotRenameWithoutSearchStrings.prototype.constructor = constructor.prototype.constructor;\n\n  // required for inheriting static methods\n  classnameFixedConstructorDoNotRenameWithoutSearchStrings.__proto__ = constructor.__proto__;\n  classnameFixedConstructorDoNotRenameWithoutSearchStrings.s = constructor;\n  // return classnameFixedConstructorDoNotRenameWithoutSearchStrings as any;\n  return constructor;\n}\n_c7 = RuntimeAccessible_inner;\nwindow.RuntimeAccessibleClass = RuntimeAccessibleClass;\n// todo: problema: per creare un PointerTargetable ho bisogno dell'userid, e devo generarlo prima che venga generato l'initialState... dovrebbe venir servito con la pagina dal server. o passato come navigation props dalla pagina di login\n\n// export type DtoW<DX extends GObject, WX = Omit<DtoW0<DX>, 'id'>> = WX;\n\nexport let CoordinateMode;\n(function (CoordinateMode) {\n  CoordinateMode[\"absolute\"] = \"absolute\";\n  CoordinateMode[\"relativePercent\"] = \"relative%\";\n  CoordinateMode[\"relativeOffset\"] = \"relativeOffset\";\n  CoordinateMode[\"relativeOffsetStart\"] = \"relativeOffsetStart\";\n  CoordinateMode[\"relativeOffsetEnd\"] = \"relativeOffsetEnd\";\n})(CoordinateMode || (CoordinateMode = {}));\nexport let EdgeHead;\n(function (EdgeHead) {\n  EdgeHead[\"composition\"] = \"Composition\";\n  EdgeHead[\"aggregation\"] = \"Aggregation\";\n  EdgeHead[\"reference\"] = \"Association\";\n  EdgeHead[\"extend\"] = \"Extension\";\n})(EdgeHead || (EdgeHead = {}));\nlet canFireActions = true;\nexport let Constructors = (_dec = RuntimeAccessible('Constructors'), _dec(_class = (_class2 = class Constructors {\n  // private callbacks: Function[];\n\n  // T['father'];\n  // set only if requested by setWithSideEffect\n  /*\r\n  problem: if isPersistent is set to false, but the object is later made persistent with an action, you lose all the callback effects afecting other elements (as setting opposite relations like instances-typeof or losing pointedBy's)\r\n  solution 1: store in the D-object a function executing the callbacks called by CreateNewElement action, then delete that field before persisting.\r\n  continued: instead of setting the pointedBy's this way (and increasing clonedcounter for nothing) erase all PointedBy mentionings here, and make all pointer values assigned separately with a SetAction,' +\r\n  '         if new2 is used that set manually a d-field, set it to undefined in the in the .end() part, then trigger the setaction with correct value.\r\n  continued: sort actions by path, but always make sure CreateElement are first in the sort regardless of path. make also sure 2 actions with the same path keep the order they are launched/created (oldest first)\r\n  */\n  constructor(t, father) {\n    let persist = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    let fatherType = arguments.length > 3 ? arguments[3] : undefined;\n    let id = arguments.length > 4 ? arguments[4] : undefined;\n    let isUser = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n    this.thiss = void 0;\n    this.persist = void 0;\n    this.nonPersistentCallbacks = void 0;\n    this.fatherType = void 0;\n    this.fatherPtr = void 0;\n    this.state = void 0;\n    persist = persist && canFireActions;\n    this.thiss = t;\n    this.setID(id, isUser);\n    // the same thing is done in reducer/createelementaction, but if the object is destructured before then, it will lose the constructor and reducer will fail to assign classname\n    t.className = t.className || t.constructor.cname || t.constructor.name;\n    DPointerTargetable.pendingCreation[t.id] = t;\n    this.persist = persist;\n    t._persistCallbacks = [];\n    t._derivedSubElements = [];\n    this.nonPersistentCallbacks = [];\n    this.fatherPtr = father;\n    if (this.thiss.hasOwnProperty(\"father\")) {\n      this.fatherType = fatherType;\n      this.setPtr(\"father\", father);\n    }\n  }\n  static makeID() {\n    let isUser = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    return \"Pointer\" + new Date().getTime() + \"_\" + (isUser ? DUser.current : 'USER') + \"_\" + DPointerTargetable.maxID++;\n  }\n  setID(id) {\n    let isUser = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    this.thiss.id = id || Constructors.makeID(isUser);\n  }\n\n  // cannot use Lobjects as they will set PointedBy in persistent state, also might access an incomplete version of the object crashing\n  setPtr(property, value, checkPointerValidity) {\n    this.thiss[property] = value;\n    if (!value) return;\n    if (Array.isArray(value)) for (let v of value) {\n      if (!value) continue;\n      if (typeof v === \"object\") v = v.id;\n      if (!v || checkPointerValidity && !Pointers.isPointer(v, checkPointerValidity)) continue;\n      this.thiss._persistCallbacks.push(SetFieldAction.create(v, \"pointedBy\", PointedBy.fromID(this.thiss.id, property), '+='));\n    } else {\n      if (typeof value === \"object\") value = value.id;\n      value && this.thiss._persistCallbacks.push(SetFieldAction.create(value, \"pointedBy\", PointedBy.fromID(this.thiss.id, property), '+='));\n    }\n    // todo: in delete if the element was not persistent, just do nothing.\n  }\n\n  setExternalRootProperty(path, val, accessModifier, isPointer) {\n    this.thiss._persistCallbacks.push(SetRootFieldAction.create(path, val, accessModifier, isPointer));\n    return this;\n  }\n  setExternalPtr(target, property) {\n    let accessModifier = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"\";\n    let val = arguments.length > 3 ? arguments[3] : undefined;\n    if (!target) return this;\n    if (typeof target === \"object\") target = target.id;\n    if (!val) val = this.thiss.id;\n    this.thiss._persistCallbacks.push(SetFieldAction.create(target, property, val, accessModifier, true));\n    return this;\n    // PointedBy is set by reducer directly in this case.\n    // this.thiss._persistCallbacks.push(SetFieldAction.create(this.thiss.id, \"pointedBy\", PointedBy.fromID(target, property as any), '+='));\n  }\n\n  setWithSideEffect(property, val) {\n    if (!val) return this;\n    if (!this.state) this.state = store.getState();\n    if (typeof val === \"object\") val = val.id;\n    this.thiss._persistCallbacks.push(() => {\n      LPointerTargetable.from(this.thiss, this.state)[property] = val;\n    });\n    return this;\n  }\n\n  //static pause(): void { canFireActions = false; }\n  //static resume(): void { canFireActions = true; }\n  static persist(d, fromCreateAction) {\n    if (Constructors.paused) return;\n    TRANSACTION(() => {\n      if (!Array.isArray(d)) d = [d];\n      // first create \"this\"\n      for (let e of d) {\n        let subElements = e._derivedSubElements;\n        let callbacks = e._persistCallbacks;\n        delete e._derivedSubElements;\n        delete e._persistCallbacks;\n        // then create subelements (object -> values) and fire their actions.\n        if (!fromCreateAction) CreateElementAction.new(e, false);\n        for (let c of subElements) Constructors.persist([c]);\n        // finally fire the actions for \"this\"\n        for (let c of callbacks) c.fire ? c.fire() : c();\n        SetRootFieldAction.new('ELEMENT_CREATED', e.id, '+=', false); // here no need to IsPointer because it only affects Transient stuff\n      }\n    });\n  }\n  // start(thiss: any): this { this.thiss = thiss; return this; }\n  end(simpledatacallback) {\n    if (simpledatacallback) simpledatacallback(this.thiss, this); // callback for setting primitive types, not pointers not context-dependant values (name being potentially invalid / chosen according to parent)\n    if (this.nonPersistentCallbacks.length) {\n      for (let cb of this.nonPersistentCallbacks) cb();\n    }\n    if (!this.persist) return this.thiss;\n    Constructors.persist(this.thiss);\n    /// todo: warning: there is a transaction at .persist method, do not use BEGIN+END/TRANSACTION inside\n\n    return this.thiss;\n  }\n  DState() {\n    let thiss = this.thiss;\n    thiss.debug = !!localStorage.getItem('debug');\n    return this;\n  }\n  DModelElement() {\n    return this;\n  }\n  DClassifier() {\n    return this;\n  }\n  DParameter(defaultValue) {\n    let thiss = this.thiss;\n    thiss.defaultValue = defaultValue;\n    this.setExternalPtr(thiss.father, \"parameters\", \"+=\");\n    return this;\n  }\n  DStructuralFeature() {\n    if (this.thiss.className === 'DOperation') return this;\n    // if (!this.persist) return this;\n    let thiss = this.thiss;\n    const _DClass = windoww.DClass;\n    const _DValue = windoww.DValue;\n    let targets = [_DClass.from(thiss.father, this.state)];\n    let alreadyParsed = {};\n    /*\r\n    todo: build a Tree<DClass> of all superclasses tree nested by level.\r\n        only then instantiate DValues by depth level, if same level from right to left (last extend on right takes priority) and erase this stuff below.*/\n    // let superClassesByLevel: Dictionary<Pointer, DClass> = ;\n    while (targets.length) {\n      // gather superclasses in map \"alreadyParsed\"\n      let nextTargets = [];\n      for (let target of targets) {\n        if (!target) {\n          Log.ww(\"Invalid father pointer in DStructuralFeature\", {\n            feature: thiss,\n            father: target,\n            superclasses: alreadyParsed\n          });\n          continue;\n        }\n        if (alreadyParsed[target.id]) continue;\n        alreadyParsed[target.id] = target;\n        for (let ext of target.extendedBy) nextTargets.push(_DClass.from(ext));\n      }\n      targets = nextTargets;\n    }\n    //(thiss as DPointerTargetable)._persistCallbacks.push(()=>{\n    // When a feature is added in m2, i loop instanced m1 objects to add that feature as a DValue.\n    for (let pointer in alreadyParsed) {\n      for (let instanceObjPtr of alreadyParsed[pointer].instances) {\n        // this._derivedSubElements.push(_DValue.new(thiss.name, thiss.id, undefined, instanceObjPtr));\n        thiss._derivedSubElements.push(_DValue.new3({\n          name: undefined,\n          instanceof: thiss.id,\n          father: instanceObjPtr\n        }, undefined, false));\n      }\n      //}\n    }\n\n    return this;\n  }\n  DReference() {\n    let thiss = this.thiss;\n    this.setExternalPtr(thiss.father, \"references\", \"+=\");\n    return this;\n  }\n  DAttribute() {\n    let thiss = this.thiss;\n    this.setExternalPtr(thiss.father, \"attributes\", \"+=\");\n    return this;\n  }\n  DDataType() {\n    return this;\n  }\n  DObject(instanceoff) {\n    let thiss = this.thiss;\n    if (thiss.father) {\n      if (this.fatherType.cname === \"DModel\") {\n        this.setExternalPtr(thiss.father, \"objects\", \"+=\");\n      } else {\n        // object containing object is not in any direct child collection. access through values\n        this.setExternalPtr(thiss.father, \"values\", \"+=\");\n      }\n    }\n    instanceoff && this.setWithSideEffect(\"instanceof\", instanceoff);\n    return this;\n  }\n  DValue(instanceoff, val, isMirage) {\n    let thiss = this.thiss;\n    thiss.edges = [];\n    // thiss.values = val || [];\n    thiss.instanceof = instanceoff;\n    thiss.isMirage = isMirage || false;\n    if (val === undefined) val = [];else if (!Array.isArray(val)) val = [val];\n    thiss.values = []; // because reducer calculating newly added pointedby must find something to start comparison\n    this.setPtr(\"values\", val, this.state);\n\n    // update father's collections (pointedby's here are set automatically)\n    if (instanceoff) {\n      this.setPtr(\"instanceof\", instanceoff);\n      this.setExternalPtr(instanceoff, \"instances\", \"+=\");\n    }\n    this.setExternalPtr(thiss.father, \"features\", \"+=\");\n    return this;\n  }\n  DAnnotation(source, details) {\n    const thiss = this.thiss;\n    thiss.source = source || '';\n    thiss.details = details || [];\n    this.setExternalPtr(thiss.father, \"annotations\", \"+=\");\n    if (details) for (let det of details) thiss._persistCallbacks.push(SetFieldAction.create(det, \"pointedBy\", PointedBy.fromID(thiss.id, \"details\"), '+='));\n    return this;\n  }\n  DPointerTargetable() {\n    const thiss = this.thiss;\n    thiss.className = thiss.constructor.cname;\n    // this.className = thiss.className;\n    return this;\n  }\n  DUser(username) {\n    const _this = this.thiss;\n    _this.username = username;\n    statehistory[_this.id] = {\n      undoable: [],\n      redoable: []\n    };\n    // todo: make it able to combine last 2 changes with a keystroke.\n    //  reapeat N times to combine N actions.\n    //  let it \"redo\" multiple times, it's like recording a macro.\n\n    if (this.persist) {\n      // no pointedBy\n    }\n    return this;\n  }\n  DNamedElement(name) {\n    const thiss = this.thiss;\n    thiss.name = name !== undefined ? name || '' : thiss.constructor.name.substring(1) + \" 1\";\n    return this;\n  }\n  DTypedElement(type) {\n    const thiss = this.thiss;\n    this.setPtr(\"type\", type);\n    return this;\n  }\n  DPackage(uri, prefix) {\n    const thiss = this.thiss;\n    thiss.uri = uri || ''; // || 'org.jodel-react.username';\n    thiss.prefix = prefix || '';\n    if (thiss.father) {\n      if (this.fatherType.cname === \"DModel\") {\n        this.setExternalPtr(thiss.father, \"packages\", \"+=\");\n      } else {\n        this.setExternalPtr(thiss.father, \"subpackages\", \"+=\");\n      }\n    }\n    return this;\n  }\n  DModel(instanceoff, isMetamodel) {\n    const thiss = this.thiss;\n    thiss.packages = []; // packages;\n    thiss.isMetamodel = isMetamodel || false;\n    this.setPtr(\"instanceof\", instanceoff || null);\n    instanceoff && this.setExternalPtr(instanceoff, \"instances\", \"+=\");\n    // todo: check all D.new calls to make sure there are not actions in callbacks in new2() versions that will go outside the Transaction of persist(),, better move ptrs as .new() parameters\n    // or make it so new2 splits pointer and non-pointer declarations (or just allow non-ptrs and ptrs must be DSomething.new() explicit parameters)\n    thiss._persistCallbacks.push(SetRootFieldAction.create(isMetamodel ? \"m2models\" : \"m1models\", thiss.id, \"+=\", true));\n    return this;\n  }\n  DOperation() {\n    let exceptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    let implementation = arguments.length > 1 ? arguments[1] : undefined;\n    const thiss = this.thiss;\n    // thiss.parameters = parameters;\n    thiss.implementation = implementation || 'return \"default placeholder function called\";';\n    this.setPtr(\"exceptions\", exceptions);\n    this.setExternalPtr(thiss.father, \"operations\", \"+=\");\n    return this;\n  }\n  DClass() {\n    let isInterface = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    let isAbstract = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    let isPrimitive = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    let partial = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    let partialdefaultname = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : '';\n    const thiss = this.thiss;\n    thiss.interface = isInterface;\n    thiss.abstract = isAbstract;\n    thiss.isPrimitive = isPrimitive;\n    thiss.partial = partial;\n    thiss.partialdefaultname = partialdefaultname;\n    thiss.isSingleton = false;\n    this.setExternalPtr(thiss.father, \"classifiers\", \"+=\");\n    this.setExternalRootProperty('ClassNameChanged.' + thiss.id, thiss.name, '', false);\n\n    // thiss.isClass = !isPrimitive;\n    // thiss.isEnum = false;\n    return this;\n  }\n  DEnumLiteral(value) {\n    // vv4\n    const thiss = this.thiss;\n    thiss.value = value; // undef is ok, handled in getter as automatic ordinal index\n    thiss.literal = thiss.name;\n    this.setExternalPtr(thiss.father, \"literals\", \"+=\");\n    return this;\n  }\n  DEnumerator() {\n    let literals = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    const thiss = this.thiss;\n    this.setExternalPtr(thiss.father, \"classifiers\", \"+=\");\n    this.setPtr(\"literals\", literals);\n    // thiss.literals = literals;\n    // thiss.isClass = false;\n    // thiss.isEnum = true;\n    return this;\n  }\n  DEdgePoint() {\n    return this;\n  }\n  DEdge() {\n    let thiss = this.thiss;\n    return this;\n  }\n  DVertex() {\n    return this;\n  }\n  DVoidEdge(start, end, longestLabel, labels) {\n    const thiss = this.thiss;\n    let startid = windoww.LGraphElement.getNodeId(start);\n    let endid = windoww.LGraphElement.getNodeId(end);\n    Log.ex(!startid || !endid, \"cannot create an edge without start or ending nodes\", {\n      start,\n      end,\n      startid,\n      endid\n    });\n    thiss.anchorStart = '0';\n    thiss.anchorEnd = '0';\n    // thiss.startFollow = false;\n    // thiss.endFollow = false;\n    thiss.midnodes = [];\n    thiss.midPoints = []; // the logic part which instructs to generate the midnodes\n    // if (!thiss.model && isDModelElementPointer(startid)) thiss.model = startid;\n    // thiss.labels = undefined;\n    let ll = (e, s, allNodes, allSegments) => /*defining the edge label (e.start.model as any)?.name + \" ~ \" + (e.end.model as any)?.name */\" (\" + s.length.toFixed(1) + \")\";\n    // complex edge label func example: (thiss.longestLabel = ll)\n    thiss.longestLabel = longestLabel;\n    this.setPtr(\"start\", startid);\n    this.setPtr(\"end\", endid);\n    this.setExternalPtr(startid, \"edgesOut\", \"+=\");\n    this.setExternalPtr(endid, \"edgesIn\", \"+=\");\n    let gthis = thiss;\n    delete gthis.x;\n    delete gthis.y;\n    delete gthis.w;\n    delete gthis.h;\n    delete gthis.edgesIn;\n    delete gthis.edgesOut;\n    delete gthis.anchors;\n    delete gthis.__isDVoidEdge;\n    delete gthis.__isDEdge;\n    return this;\n  }\n  DExtEdge() {\n    return this;\n  }\n  DRefEdge() {\n    return this;\n  }\n  DGraphElement(model, parentgraphID) {\n    let htmlindex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n    const thiss = this.thiss;\n    thiss.subElements = [];\n    thiss.favoriteNode = false;\n    thiss.zIndex = htmlindex;\n    thiss.isSelected = {};\n    thiss.edgesIn = [];\n    thiss.edgesOut = [];\n    // thiss.state = {id: thiss.id+\".state\", className: thiss.className};\n    // 5-way anchors thiss.anchors = {'0':{x:0.5, y:0.5}, '1':{x:0.5, y:0}, '2':{x:1, y:0.5}, '3':{x:0.5, y:1}, '4':{x:0, y:0.5}} as any;\n    thiss.anchors = {\n      '0': {\n        x: 0.5,\n        y: 0.5\n      },\n      't': {\n        x: 0.5,\n        y: 0\n      },\n      'tr': {\n        x: 1,\n        y: 0\n      },\n      'r': {\n        x: 1,\n        y: 0.5\n      },\n      'br': {\n        x: 1,\n        y: 1\n      },\n      'b': {\n        x: 0.5,\n        y: 1\n      },\n      'bl': {\n        x: 0,\n        y: 1\n      },\n      'l': {\n        x: 0,\n        y: 0.5\n      },\n      'tl': {\n        x: 0,\n        y: 0\n      }\n    };\n    for (let k in thiss.anchors) {\n      let a = thiss.anchors[k];\n      if (!a.name) a.name = k;\n      if (!a.w) a.w = 15;\n      if (!a.h) a.h = 15;\n    }\n    this.setPtr(\"model\", model);\n    this.setPtr(\"graph\", parentgraphID);\n    this.setExternalPtr(thiss.father, \"subElements\", \"+=\");\n    Log.eDev(thiss.father && DPointerTargetable.fromPointer(thiss.father).subElements.indexOf(thiss.id) !== -1, \"subelemnts+= addition have duplicates\", {\n      adding: thiss,\n      d: thiss.father && DPointerTargetable.fromPointer(thiss.father).subElements.indexOf(thiss.id)\n    });\n    return this;\n  }\n  DViewElement(name, jsxString, vp, defaultVSize) {\n    var _user$project;\n    let usageDeclarations = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : '';\n    let constants = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : '';\n    let preRenderFunc = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : '';\n    let appliableToClasses = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : [];\n    let oclCondition = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : '';\n    let priority = arguments.length > 9 ? arguments[9] : undefined;\n    const thiss = this.thiss;\n    const vid = thiss.id;\n    let tv = transientProperties.view[vid];\n    if (!tv) transientProperties.view[vid] = tv = {};\n    thiss.name = name;\n    thiss.appliableToClasses = appliableToClasses;\n    thiss.appliableTo = 'Any';\n    thiss.jsxString = jsxString;\n    thiss.usageDeclarations = usageDeclarations;\n    thiss.constants = undefined; // '{}';\n    thiss.preRenderFunc = ''; // '() => {return{}}';\n    thiss.onDragEnd = thiss.onDragStart = thiss.whileDragging = thiss.onResizeEnd = thiss.onResizeStart = thiss.whileResizing = '';\n    thiss.onRotationEnd = thiss.onRotationStart = thiss.whileRotating = '';\n    thiss.onDataUpdate = '';\n    thiss.events = {};\n    // thiss.__transient = new DViewTransientProperties();\n    thiss.subViews = {};\n    thiss.oclCondition = oclCondition || '';\n    thiss.jsCondition = '';\n    thiss.oclUpdateCondition = '';\n    thiss.OCL_NEEDS_RECALCULATION = true;\n    thiss.explicitApplicationPriority = undefined; //priority as any as number;\n    thiss.isExclusiveView = true;\n    thiss.size = {};\n    thiss.storeSize = false;\n    thiss.lazySizeUpdate = true;\n    thiss.isValidation = false;\n    //thiss.constraints = [];\n    thiss.palette = {\n      'color-': U.hexToPalette(),\n      //['#ffffff', '#ff0000', '#00ff00', '#0000ff','#aaaaaa', '#ffaaaa', '#aaffaa', '#aaaaff'],\n      'background-': U.hexToPalette() // ['#000000', '#33333', '#777777']};\n    };\n\n    thiss.css = '';\n    thiss.compiled_css = '';\n    thiss.css_MUST_RECOMPILE = true;\n    thiss.cssIsGlobal = false;\n    // thiss.palette = {};\n\n    // thiss.useSizeFrom = EuseSizeFrom.node;\n    // thiss.adaptHeight = false;\n    // thiss.adaptWidth = false;\n\n    thiss.draggable = true;\n    thiss.resizable = true;\n    //thiss.display = 'flex' as any;\n    thiss.defaultVSize = defaultVSize || new GraphSize(0, 0, 140.6818084716797, 32.52840805053711);\n    thiss.adaptWidth = false;\n    thiss.adaptHeight = true; //'fit-content';\n\n    thiss.edgeStartOffset = new GraphPoint(50, 50);\n    thiss.edgeEndOffset = new GraphPoint(50, 50);\n    thiss.edgeStartOffset_isPercentage = true;\n    thiss.edgeEndOffset_isPercentage = true;\n    thiss.edgeStartStopAtBoundaries = true;\n    thiss.edgeEndStopAtBoundaries = true;\n    thiss.bendingMode = EdgeBendingMode.Bezier_quadratic;\n    thiss.edgeGapMode = EdgeGapMode.center;\n    thiss.edgePointCoordMode = CoordinateMode.relativeOffset;\n    thiss.usageDeclarations = undefined;\n\n    /// edge only\n\n    thiss.edgeHeadSize = new GraphPoint(20, 20);\n    thiss.edgeTailSize = new GraphPoint(20, 20);\n    if (thiss.className !== 'DViewElement') return this;\n    const user = LUser.fromPointer(DUser.current);\n    // const project = user?.project; if(!project) return this;\n    if (!vp) vp = (user === null || user === void 0 ? void 0 : (_user$project = user.project) === null || _user$project === void 0 ? void 0 : _user$project.activeViewpoint.id) || Defaults.viewpoints[0];\n    if (vp !== 'skip') {\n      // let dvp = DPointerTargetable.fromPointer(vp);\n      // let subviews = {...dvp.subViews}; subviews[thiss.id] = 1.5;\n      // this.setExternalPtr(vp, 'subViews', '', subviews);\n      this.setPtr('viewpoint', vp);\n    }\n    this.setExternalPtr(this.fatherPtr, 'subViews', '+=', {\n      [thiss.id]: 1.5\n    });\n    transientProperties.view[thiss.id] = {};\n\n    // let trview = transientProperties.view[thiss.id];\n    // trview.?? = ???\n\n    TRANSACTION(() => {\n      // add relation to vp\n      for (let key of windoww.DViewElement.RecompileKeys) this.setExternalRootProperty('VIEWS_RECOMPILE_' + key, thiss.id, '+=', false); // is pointer, but no need to set pointedby\n    });\n\n    // this.setExternalPtr(project.id, 'views', '+=');\n    // this.setExternalPtr(project.id, 'stackViews', '+=');\n    return this;\n  }\n  DViewPoint() {\n    const thiss = this.thiss;\n    const user = LUser.fromPointer(DUser.current);\n    const project = user === null || user === void 0 ? void 0 : user.project;\n    if (!project) return this;\n    this.setExternalPtr(project.id, 'viewpoints', '+=');\n    // thiss._persistCallbacks.push( SetFieldAction.create(project.id, 'stackViews', [], '', false) );\n    return this;\n  }\n  DProject(type, name, state, m2, m1, id) {\n    const _this = U.wrapper(this.thiss);\n    _this.metamodels = m2;\n    _this.models = m1;\n    _this.type = type;\n    _this.name = name;\n    _this.state = state || '';\n    if (id) _this.id = id;\n    _this.favorite = {};\n    _this.description = 'A new Project. Created by ' + DPointerTargetable.from(DUser.current).username + ' @' + new Date().toLocaleString();\n    this.setExternalPtr(DUser.current, 'projects', '+=');\n    return this;\n  }\n  static DGraph_makeID(modelid) {\n    if (!modelid) modelid = \"shapeless\";\n    return modelid + '_graph' + Constructors.DGraph_maxID++;\n  }\n  DGraph() {\n    const thiss = this.thiss;\n    thiss.graph = thiss.id; // no setPtr because i want to avoid circular pointedby reference\n    thiss.zoom = new GraphPoint(1, 1);\n    thiss.offset = new GraphPoint(0, 0); // GraphSize.apply(this, [0, 0, 0 ,0]);\n    thiss._subMaps = {\n      zoom: true,\n      graphSize: true\n    };\n    const user = LUser.fromPointer(DUser.current);\n    if (thiss.className === 'DGraph') {\n      // to exclude GraphVertex\n      user.project && this.setExternalPtr(user.project.id, 'graphs', \"+=\");\n      thiss.x = 0;\n      thiss.y = 0;\n      thiss.w = 0;\n      thiss.h = 0;\n    } else {\n      // todo: set to default graphvertex size, so it can skip a rerender\n      thiss.x = 0;\n      thiss.y = 0;\n      //thiss.w = packageDefaultSize.w;\n      //thiss.h = packageDefaultSize.h;\n    }\n\n    return this;\n  }\n  DVoidVertex(defaultVSize) {\n    const thiss = this.thiss;\n    /*[]{}<>\r\n    ?'^~\r\n    &&||\\+\r\n    6nb*/\n    let defaultVSizeObj;\n    let defaultVSizeFunc;\n    thiss.isResized = false;\n    let lvertex = LPointerTargetable.fromD(thiss);\n    if (typeof defaultVSize !== \"function\") {\n      defaultVSizeObj = defaultVSize;\n    } else {\n      defaultVSizeFunc = defaultVSize;\n      try {\n        defaultVSizeObj = defaultVSizeFunc(lvertex.father, lvertex);\n      } catch (e) {\n        Log.exx(\"Error in user DefaultVSize function:\", {\n          e,\n          defaultVSizeFunc,\n          txt: defaultVSizeFunc.toString()\n        });\n      }\n    }\n    if (defaultVSizeObj) {\n      if (defaultVSizeObj.x !== undefined) thiss.x = defaultVSizeObj.x;\n      if (defaultVSizeObj.y !== undefined) thiss.y = defaultVSizeObj.y;\n      if (defaultVSizeObj.w !== undefined) thiss.w = defaultVSizeObj.w;\n      if (defaultVSizeObj.h !== undefined) thiss.h = defaultVSizeObj.h;\n      if (defaultVSizeObj.index >= 0 && thiss.className === \"DEdgePoint\") {\n        let updateEPindex = () => {\n          var _defaultVSizeObj;\n          let lep = lvertex;\n          let le = lep.father;\n          let de = le.__raw;\n          let subelements = [...de.subElements];\n          U.arrayRemoveAll(subelements, thiss.id);\n          subelements.splice((_defaultVSizeObj = defaultVSizeObj) === null || _defaultVSizeObj === void 0 ? void 0 : _defaultVSizeObj.index, 0, thiss.id);\n          // console.log(\"setting subelements\", {oldsubelements, subelements, de, le, thiss});\n          le.subElements = subelements;\n          // todo: this might break \"pointedBy\" x984\n        };\n        // updateEPindex();\n        // it's already wrapped in a callback\n        // but needs a second one because after node is created, id is auto-appended to this collection\n        // and i need to rewrite that append by inserting my own customized index position\n        console.log(\"setting subelements 0\", {\n          updateEPindex\n        });\n        setTimeout(updateEPindex, 0);\n        // NB: do not use this.callbacks.push because the body of this func is executed after Constructors.end() so end() can never find and execute it.\n      }\n    }\n\n    return this;\n  }\n}, _class2.paused = false, _class2.DGraph_maxID = 0, _class2)) || _class);\n// export const Constructors = new _Constructors();\n\nexport let DPointerTargetable = (_dec2 = RuntimeAccessible(\"DPointerTargetable\"), _dec2(_class3 = (_class4 = class DPointerTargetable extends RuntimeAccessibleClass {\n  //\n\n  // pointedBy: DocString<'path in store'>[] = []; // NB: potrebbe contenere puntatori invalidi.\n  // se viene cancellato un intero oggetto A che contiene una lista di puntatori, gli oggetti che puntano ad A rimuovono A dai loro \"poitnedBy\",\n  // ma gli oggetti puntati da A tramite sotto-oggetti o attributi (subviews...) non vengono aggiornati in \"pointedby\"\n  static defaultname(startingPrefix, father, metaptr) {\n    let lfather;\n    // startingPrefix = \"model_\", father = ((name: string) => !dmodelnames.includes(name))\n    if (father) {\n      if (typeof father === \"string\" || father.className) {\n        // Pointer or D\n        lfather = LPointerTargetable.wrap(father);\n        if (!lfather) return typeof startingPrefix === \"string\" ? startingPrefix : \"unnamed_elem\"; // can happen during parse when father ptr exist but it's not in store yet. not a prob\n        if (typeof startingPrefix !== \"string\") {\n          let meta = LPointerTargetable.from(metaptr);\n          startingPrefix = startingPrefix(meta);\n        }\n        const childrenNames = lfather.children.map(c => c === null || c === void 0 ? void 0 : c.name);\n        return U.increaseEndingNumber(startingPrefix + '0', false, false, newname => childrenNames.indexOf(newname) >= 0);\n      } else {\n        let condition = father;\n        return U.increaseEndingNumber(startingPrefix + '0', false, false, condition);\n      }\n    }\n    return startingPrefix + \"1\";\n  }\n  static new() {\n    //father?: Pointer, persist: boolean = false, fatherType?: Constructor, ...a:any): DPointerTargetable {\n    Log.exx(\"cannot instantiate abstract class DPointerTargetable\");\n    return null;\n    // return new Constructors(new DPointerTargetable('dwc'), father, persist, fatherType).DPointerTargetable().end();\n  }\n\n  constructor(fakearg_detectwrongcalls) {\n    super();\n    this.clonedCounter = void 0;\n    this._storePath = void 0;\n    this._subMaps = void 0;\n    this.id = void 0;\n    this.pointedBy = [];\n    this.className = void 0;\n    this._state = {};\n    this._persistCallbacks = void 0;\n    this._derivedSubElements = void 0;\n    if (!fakearg_detectwrongcalls) throw new Error(\"cannot build D-objects using new keyword, use the static D-Class.new method instead\");\n  }\n  static fromL(data) {\n    return data.__raw;\n  }\n  static fromPointer(ptr, s) {\n    s = s || store.getState();\n    if (!ptr) {\n      return ptr;\n    }\n    if (Array.isArray(ptr)) {\n      return ptr.map(p => DPointerTargetable.fromPointer(p, s));\n    }\n    if (typeof ptr !== \"string\") {\n      console.error(\"wrong parameter in DPointerTargetable.fromPointers()\", ptr);\n      throw new Error(\"wrong parameter in DPointerTargetable.fromPointers()\");\n    }\n    if (s && s.idlookup[ptr]) return s.idlookup[ptr];\n    return DPointerTargetable.pendingCreation[ptr] || s.idlookup[ptr];\n    // return ((s || store.getState()).idlookup[ptr as string] || DPointerTargetable.pendingCreation[ptr as string]) as any;\n  }\n\n  static from(ptr, s) {\n    if (!ptr) return ptr;\n    if (Array.isArray(ptr)) return DPointerTargetable.fromArr(ptr, true, s);\n    if (ptr.__isProxy) return ptr.__raw;\n    if (typeof ptr === \"string\") {\n      if (s && s.idlookup[ptr]) return s.idlookup[ptr];\n      return DPointerTargetable.pendingCreation[ptr] || store.getState().idlookup[ptr];\n    } else if (ptr.className) return ptr;else return undefined;\n  }\n  static fromArr(arr) {\n    let filter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    let s = arguments.length > 2 ? arguments[2] : undefined;\n    let ret = [];\n    s = s || store.getState();\n    for (let a of arr) {\n      let d = DPointerTargetable.from(a, s);\n      if (!filter || d) ret.push(d);\n    }\n    return ret;\n  }\n  //static from0(a: any, ...aa: any): any { return null; }\n  static writeable(l) {\n    return l;\n  }\n\n  // deleted when it becomes persistent\n  // deleted when it becomes persistent\n  // persist(): void { Constructors.persist(this); }// deleted when it becomes persistent\n}, _class4.defaultComponent = void 0, _class4.maxID = 0, _class4.logic = void 0, _class4.subclasses = [], _class4._extends = [], _class4.pendingCreation = {}, _class4)) || _class3);\nRuntimeAccessibleClass.set_extend(RuntimeAccessibleClass, DPointerTargetable);\n/*\r\nlet d0: LClassifier = null as any;\r\nlet ptrr: Pointer<DPackage, 1, 'N', LPackage> = null as any;\r\nlet ptr1: Pointer<DPackage, 1, 1, LPackage> = null as any;\r\nlet dd = DPointerTargetable.from(d0.id);\r\n*/\n\n/*\r\ntype Pack1<D extends DPointerTargetable, L extends LPointerTargetable = DtoL<D>, P extends Pointer<D, 0, 1, L> = Pointer<D, 0, 1, L>, R = {D:D, L:L, P:P} > = P|D|L\r\ntype PackArr<D extends DPointerTargetable, L extends LPointerTargetable = DtoL<D>, P extends Pointer<D, 0, 1, L> = Pointer<D, 0, 1, L> , ARR = Pack1<D>> = (ARR)[];\r\ntype Pack<D extends DPointerTargetable, L extends LPointerTargetable = DtoL<D>, P extends Pointer<D, 0, 1, L> = Pointer<D, 0, 1, L> , ARR = Pack1<D>> = ARR | (ARR)[];*/\n\nexport let Pointers = (_dec3 = RuntimeAccessible('Pointers'), _dec3(_class5 = class Pointers {\n  static filterValid(p) {\n    const pointerval = DPointerTargetable.from(p);\n    if (Array.isArray(pointerval)) return pointerval.filter(p => !!p).map(p => p.id);\n    if (!pointerval) return null;\n    return pointerval.id;\n  }\n  static fromArr(val) {\n    if (!val) val = [];\n    if (!Array.isArray(val)) {\n      val = [val];\n    }\n    if (!val.length) {\n      return [];\n    }\n    if (val[0].id) {\n      val = val.filter(v => !!v).map(v => v.id);\n    }\n    return val.filter(v => !!v);\n  }\n  fromm(val) {\n    return !val ? null : val.id;\n  }\n  from0(data) {\n    return null;\n  }\n  static from00(data) {\n    // RET | RET[] {\n    if (Array.isArray(data)) return data.filter(d => !!d).map(d => typeof d === \"string\" ? d : d.id);else return data ? data.id : null;\n  } // stavolta fai infer so D|l.id\n\n  // | {D:any};\n  // | {DD:any};\n  // | {L:any};\n  // | {LL:any};\n  // | {W:any};\n  // | {WW:any};\n  // | {P:any};\n  // | {PP:any};\n  //{TEST1:any};\n  //{TEST111:any};\n  //{TEST0:any};\n  //{TEST0:any};\n  //{TESTARR:any};\n  //{TEST1:any};\n  //{TEST111:any};\n  //{TEST0:any};\n  //{TESTARR:any};\n\n  /*\r\n      public static from(data:undefined): undefined; // | {D:any};\r\n      public static from<DX extends DPointerTargetable | undefined | null>(data:DX): DX extends DPointerTargetable ? DX[\"id\"] : DX; // | {D:any};\r\n      public static from<DX extends DPointerTargetable | undefined | null>(data:DX[]): DX extends DPointerTargetable ? DX[\"id\"][] : DX; // | {DD:any};\r\n      public static from<LX extends LPointerTargetable | undefined | null>(data:LX): LX extends LPointerTargetable ? LX[\"id\"] : LX; // | {L:any};\r\n      public static from<LX extends LPointerTargetable | undefined | null>(data:LX[]): LX extends LPointerTargetable ? LX[\"id\"][] : LX; // | {LL:any};\r\n      public static from<WX extends WPointerTargetable | undefined | null>(data:WX): WX extends WPointerTargetable ? WX[\"id\"] : WX; // | {W:any};\r\n      public static from<WX extends WPointerTargetable | undefined | null>(data:WX[]): WX extends WPointerTargetable ? WX[\"id\"][] : WX; // | {WW:any};\r\n      public static from<PTR extends Pointer<DPointerTargetable, 1, 1, LPointerTargetable> | undefined | null>(data:PTR): PTR extends Pointer<DPointerTargetable, 1, 1, LPointerTargetable> ? PTR : PTR; // | {P:any};\r\n      public static from<PTR extends Pointer<DPointerTargetable, 1, 1, LPointerTargetable> | undefined | null>(data:PTR[]): PTR extends Pointer<DPointerTargetable, 1, 1, LPointerTargetable> ? PTR[] : PTR; // | {PP:any};\r\n      public static from<T extends LPointerTargetable | undefined | null>(data:Pack1<T>): T extends LPointerTargetable ? Pointer<LtoD<T>, 1, 1, T> : T; //{TEST1:any};\r\n      public static from<T extends LPointerTargetable | undefined | null>(data:Pack1<T>[]): T extends LPointerTargetable ? Pointer<LtoD<T>, 1, 1, T>[] : T; //{TEST111:any};\r\n      public static from<T extends LPointerTargetable | undefined | null>(data:Pack<T>): T extends LPointerTargetable ? Pointer<LtoD<T>, 1, 1, T>[] : T; //{TEST0:any};\r\n      public static from<T extends LPointerTargetable | undefined | null>(data:PackArr<T>): T extends LPointerTargetable ? Pointer<LtoD<T>, 1, 1, T>[] : T; //{TESTARR:any};\r\n      // public static from<T extends LPointerTargetable | undefined | null>(data:Pack1<T[]>): T extends LPointerTargetable ? Pointer<LtoD<T>, 1, 1, T> : T; //{TEST1:any};\r\n      // public static from<T extends LPointerTargetable | undefined | null>(data:Pack1<T[]>[]): T extends LPointerTargetable ? Pointer<LtoD<T>, 1, 1, T>[] : T; //{TEST111:any};\r\n      // DDD extends (T extends Pointer<infer D> ? D : 'undefined D'),*/\n  // returns:\n  // if ptr is unvalid = undefined;\n  // if [ptr] is unvalid = []\n  //{TEST0:any};\n  // @ts-ignore\n  //{TESTARR:any};\n  // | {Dn:any};\n  // | {Dnn:any};\n  // | {Dn0:any};\n  // function from<PTR extends Pointer<DPointerTargetable, 1, 1, LPointerTargetable>>(data:unknown | unknown[]): PTR | PTR[] | GObject {\n  static from(data) {\n    if (!data) return null;\n    if (Array.isArray(data)) return data.filter(d => !!d).map(d => typeof d === \"string\" ? d : d === null || d === void 0 ? void 0 : d.id);\n    return typeof data === \"string\" ? data : data === null || data === void 0 ? void 0 : data.id;\n  }\n  static isPointer(val, state) {\n    let doArrayCheck = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    // might cause endless loop if there are subarrays in a containment loop.\n    if (doArrayCheck && Array.isArray(val)) return val.some(v => Pointers.isPointer(val, state, true));\n    if (state) return DPointerTargetable.from(val, state);\n    return typeof val === \"string\" ? val.includes(\"Pointer\") : false;\n  }\n}) || _class5);\n\n/*\r\nexport type Pack1<L extends LPointerTargetable | undefined | null,\r\n    // L extends LPointerTargetable | undefined | null = LL extends LPointerTargetable[] ? LPointerTargetable : null | undefined,\r\n    D extends (L extends LPointerTargetable ? LtoD<L> : undefined | null) = (L extends LPointerTargetable ? LtoD<L> : undefined | null)> =\r\n    L extends LPointerTargetable ? ( D extends DPointerTargetable ? D | L /*| LtoW<L>* / | Pointer<D, 1, 1, L> : L) : undefined;\r\nexport type PackArr<LL extends orArr<LPointerTargetable> | undefined | null,\r\n    L extends LPointerTargetable | undefined | null = LL extends undefined | null ? undefined : unArr<LL>> = Pack1<L>[];\r\nexport type Pack<\r\n    LL extends orArr<LPointerTargetable> | undefined | null,\r\n    L extends unArr<LL> = unArr<LL>,\r\n    // L extends (LL extends orArr<LPointerTargetable> ? LPointerTargetable : undefined | null) = (LL extends orArr<LPointerTargetable> ? unArr<LL> : undefined)\r\n    >\r\n    = LL extends undefined ? undefined : Pack1<L> | PackArr<L>;\r\n*/\n\n/*\r\nlet n: any = null;\r\nlet aa: DClass = n;\r\nlet ptrr = Pointers.from(aa.parent);\r\naa.parent = ptrr;*/\n\nexport let PendingPointedByPaths = (_dec4 = RuntimeAccessible('PendingPointedByPaths'), _dec4(_class6 = (_class7 = class PendingPointedByPaths {\n  // static pendingMoreThanTwice: ParsedAction[] = [];\n\n  // tmp fields, not sure what i need\n  // todo: remove\n  static new(action, oldState) {\n    const ptr = action.value;\n    const target = oldState.idlookup[ptr];\n    let pendingPointedBy = new PendingPointedByPaths(action.path, ptr);\n    pendingPointedBy.action = action;\n    return pendingPointedBy;\n  }\n  constructor(from,\n  // todo 6: how about actions that do not include index but just += -= [] ?\n  to) {\n    this.from = from;\n    this.to = to;\n    this.solveAttempts = 1;\n    this.stackTrace = void 0;\n    this.action = void 0;\n    this.stackTrace = U.getStackTrace();\n  }\n  static attemptimplementationdelete(pb) {\n    let state = store.getState();\n    let objectChain = U.followPath(state, pb.source);\n  }\n  attemptResolve(state) {\n    if (this.canBeResolved(state)) return this.resolve();\n    return null;\n  }\n  resolve() {\n    U.arrayRemoveAll(PendingPointedByPaths.all, this);\n    return Action.parse(SetRootFieldAction.create(\"idlookup.\" + this.to + '.pointedBy', PointedBy.new(this.action.path), '+=', false));\n  }\n  saveForLater() {\n    PendingPointedByPaths.all.push(this);\n  }\n  canBeResolved(state) {\n    this.solveAttempts++;\n    Log.exDev(this.solveAttempts >= PendingPointedByPaths.maxSolveAttempts, \"pending PointedBy action is not revolved for too long, some pointer was wrongly set up.\", this.stackTrace, this, state);\n    return !!state.idlookup[this.to];\n  }\n  static getSolveableActions(oldState) {\n    let allClone = [...this.all]; // necessary because the array will remove some elements during iteration as they are solved.\n    return allClone.map(p => p.attemptResolve(oldState)).filter(p => !!p);\n  }\n}, _class7.all = [], _class7.maxSolveAttempts = 2099999, _class7)) || _class6);\nexport let PointedBy = (_dec5 = RuntimeAccessible('PointedBy'), _dec5(_class8 = (_class9 = class PointedBy {\n  // elemento da cui parte il puntatore\n  // field: keyof DPointerTargetable;\n  // il bersaglio non c'√® qui, perch√® √® l'oggetto che contiene questo dentro l'array pointedBy\n  /*private constructor(source: DPointerTargetable, field: any) {\r\n      this.source = source;\r\n      this.field = field;\r\n  }*/\n  static getPath(p) {\n    return p.source.substring(0, p.source.lastIndexOf(\".\"));\n  }\n  static getLastKey(p) {\n    return p.source.substring(p.source.lastIndexOf(\".\"));\n  }\n  static getPathArr(p) {\n    return p.source.split('.');\n  }\n  constructor(source) {\n    this.source = void 0;\n    this.source = source;\n  }\n  // don't use modifiers here,\n  static fromID(ptr, field, NoAccessModifiersHere) {\n    return PointedBy.new(\"idlookup.\" + ptr + \".\" + field);\n  }\n  static new(source) {\n    let modifier = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n    let action = arguments.length > 2 ? arguments[2] : undefined;\n    // let source: DocString<\"full path in store including key\"> = action.path;\n    // if (source.includes(\"true\")) { console.error(this, action); throw new Error(\"mixed a bool\"); }\n    if (modifier) source = source.substring(0, source.length - ((modifier === null || modifier === void 0 ? void 0 : modifier.length) || 0));\n    return new PointedBy(source);\n  }\n  // static new0<D extends DPointerTargetable> (source: D, field: keyof D): PointedBy { return new PointedBy(source, field); }\n\n  static remove(oldValue, action, state) {\n    let casee = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : undefined;\n    let oldState = arguments.length > 4 ? arguments[4] : undefined;\n    if (!oldValue) return state;\n    let oldtarget = state.idlookup[oldValue];\n    if (!oldtarget) return state;\n    let index = -1;\n    let actionpath = action.path.substring(0, action.path.length - ((casee === null || casee === void 0 ? void 0 : casee.length) || 0));\n    for (let i = 0; i < oldtarget.pointedBy.length; i++) {\n      if (oldtarget.pointedBy[i].source === actionpath) {\n        index = i;\n        break;\n      }\n    }\n    if (index < 0) return state;\n    if (oldState === state) state = {\n      ...state\n    };\n    if ((oldState === null || oldState === void 0 ? void 0 : oldState.idlookup) === state.idlookup) state.idlookup = {\n      ...state.idlookup\n    };\n    if ((oldState === null || oldState === void 0 ? void 0 : oldState.idlookup[oldValue]) === state.idlookup[oldValue]) {\n      state.idlookup[oldValue] = {\n        ...oldtarget\n      };\n    } else {\n      // no need\n    }\n    state.idlookup[oldValue].pointedBy.splice(index, 1); // in-place edit\n\n    // console.warn('pointedby remove:', {from: oldtarget.pointedBy, to: state.idlookup[oldValue].pointedBy, obj: state.idlookup[oldValue], index, oldValue, actionpath});\n    return state;\n  }\n\n  // important! must be called only in reducer\n  static add(newtargetptr, action, state) {\n    let casee = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : undefined;\n    let oldState = arguments.length > 4 ? arguments[4] : undefined;\n    if (!newtargetptr) return state;\n    // todo: if can't be done because newtarget doesn't exist, build an action from this and set it pending.\n    let newtarget = state.idlookup[newtargetptr];\n    if (!newtarget) {\n      PendingPointedByPaths.new(action, state).saveForLater(); // {from: action.path, field: action.field, to: target});\n      return state;\n    }\n    /* simpler version but does unnecessary shallow copies\r\n    state = {...state} as DState;\r\n    state.idlookup = {...state.idlookup};\r\n    state.idlookup[newtargetptr] = {...newtarget, pointedBy:  [...newtarget.pointedBy, PointedBy.new(action.path, casee)]} as any;*/\n    if (oldState === state) state = {\n      ...state\n    };\n    if ((oldState === null || oldState === void 0 ? void 0 : oldState.idlookup) === state.idlookup) state.idlookup = {\n      ...state.idlookup\n    };\n    if ((oldState === null || oldState === void 0 ? void 0 : oldState.idlookup[newtargetptr]) === state.idlookup[newtargetptr]) {\n      state.idlookup[newtargetptr] = {\n        ...newtarget,\n        pointedBy: [...newtarget.pointedBy, PointedBy.new(action.path, casee)]\n      };\n    } else {\n      state.idlookup[newtargetptr].pointedBy = [...newtarget.pointedBy, PointedBy.new(action.path, casee)];\n    }\n    // console.warn('pointedby add:', {from: oldtarget.pointedBy, to: state.idlookup[newtargetptr].pointedBy, obj: state.idlookup[newtargetptr]});\n    return state;\n  }\n}, _class9.list = [\"father\", \"parent\", \"annotations\", \"packages\", \"type\", \"subpackages\", \"classifiers\", \"exceptions\", \"parameters\", \"defaultValue\", \"instances\", \"operations\", \"features\", \"attributes\", \"references\", \"extends\", \"extendedBy\", \"implements\", \"implementedBy\", \"instanceof\", \"edges\", \"target\", \"opposite\", \"parameters\", \"exceptions\", \"literals\", \"values\"], _class9)) || _class8);\nexport let LPointerTargetable = (_dec6 = RuntimeAccessible('LPointerTargetable'), _dec6(_class10 = (_class11 = class LPointerTargetable extends DPointerTargetable {\n  constructor() {\n    super(...arguments);\n    this.__raw = void 0;\n    this.pointedBy = void 0;\n    this.clonedCounter = void 0;\n    this.__isProxy = void 0;\n    this.__serialize = void 0;\n    this.inspect = void 0;\n    this.__random = void 0;\n    this.__info_of__id = {\n      type: \"Pointer&lt;this&gt;\",\n      txt: \"<a href=\\\"https://github.com/DamianoNaraku/jodel-react/wiki/identifiers\\\">\" + \"<span>Unique identifier, and value used to point this object.</span></a>\"\n    };\n    this._state = void 0;\n    this.__info_of___state = {\n      type: \"GObject\",\n      txt: `<div>A space where the user can store informations for their operations/views.<br/>\n            Example: The Validation viewpoint uses it to store validation messages.<br/>\n            WARNING! do not set proxies in the state, set pointers instead.<br/>\n            <a href='https://github.com/MDEGroup/jjodel/wiki/L%E2%80%90Object-state'>Learn more on the wiki</a></div>`\n    };\n  } // public r!: this;\n  wrongAccessMessage(str) {\n    let msg = \"Method \" + str + \" should not be called directly, attempting to do so should trigger get_\" + str + \"(). This is only a signature for type checking.\";\n    Log.ex(true, msg);\n    throw new Error(msg);\n  }\n  toString() {\n    throw this.wrongAccessMessage(\"toString\");\n  }\n  get_toString(context) {\n    const data = context.data;\n    return () => data.name || data.className.substring(0);\n    // return () => data.id;\n  }\n\n  toPrimitive() {\n    throw this.wrongAccessMessage(\"toPrimitive\");\n  }\n  get_toPrimitive(c) {\n    return hint => {\n      switch (hint) {\n        default:\n        case \"number\":\n          return c.data.clonedCounter || -1;\n        case \"string\":\n        case \"default\":\n          return this.get_toString(c)();\n      }\n    };\n  }\n  cannotSet(field) {\n    return Log.exx('\"' + field + '\" field is read-only', this);\n  }\n  get_id(context) {\n    return context.data.id;\n  }\n  set_id() {\n    return this.cannotSet('id');\n  }\n  _get_default(data, key) {\n    // @ts-ignore\n    return LPointerTargetable.from(data[key]);\n  }\n  // get__state(c: Context): any { return this.wrongAccessMessage('_state',', use obj.state instead.'); }\n  // set__state(val: this[\"_state\"], c: Context): boolean { return this.cannotSet('_state', 'use obj.state instead.'); }\n  get_state(context) /*this['_state']*/{\n    if (!context.data._state) return {};\n    return this.__shallowSolver(context.data._state, true, true); // to solve pointers in state\n    // return LPointerTargetable.wrap(context.data._state); // this should work, because data._state have id = this.id+\"._state\"\n  }\n\n  set_state(val, c) {\n    // todo: put those lobjects -> pointer checks into defaultsetter to improve it\n\n    // 3 options:\n    // 1) if state === node, then setting whole state is invalid\n    // 2) if state is a proxified obj with id = node.id+\".state\" so actions and proxy getters/setters will act on the subobject properties still invalid setting whole obj.\n    // 3) forbid to set the whole state, merge old state with new one, if val === undefined, state is reset.\n\n    // i choose 3)\n    let newState;\n    let oldState = c.data._state ? {\n      ...c.data._state\n    } : {};\n    let changed = false;\n    if (val === undefined) {\n      if (!oldState || !Object.keys(oldState).length) return true;\n      newState = {};\n      changed = true;\n    } else if (typeof val !== \"object\") {\n      Log.ee(\"state can only be assigned with an object or undefined\");\n      return true;\n    } else {\n      val = this.__sanitizeValue(val);\n      newState = {\n        ...oldState\n      };\n      for (let k in val) {\n        if (val[k] === undefined) {\n          if (oldState[k] === undefined) continue;\n          delete newState[k];\n          changed = true;\n          continue;\n        }\n        if (oldState[k] === val[k]) continue;\n        newState[k] = val[k];\n        changed = true;\n      }\n    }\n    if (!changed) return true;\n    SetFieldAction.new(c.data, \"_state\", newState, undefined, false);\n    return true;\n  }\n  __sanitizeValue(val) {\n    let canEditVal = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    let canEditValDeep = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    if (val === undefined) {\n      return val;\n    }\n    if (val.__isProxy || val.id && val.className) return val.id;\n    // if (typeof val === \"string\") { return val; } else\n    if (typeof val !== \"object\") {\n      return val;\n    } else if (Array.isArray(val)) {\n      return val.map(v => this.__sanitizeValue(v, canEditValDeep, canEditValDeep));\n    }\n    // case val is object not array, not proxy, not D. just a POJO\n    let ret = canEditVal ? val : {\n      ...val\n    };\n    for (let k in val) {\n      if (Array.isArray(val[k])) ret[k] = val[k].map(v => v && (v.__isProxy || v.id && v.className) ? v.id : v);else if (val[k] && (val[k].__isProxy || val[k].id && val[k].className)) ret[k] = val[k].id;\n    }\n    return ret;\n  }\n\n  // protected _defaultCollectionGetter(c: Context, k: keyof Context[\"data\"]): LPointerTargetable[] { return LPointerTargetable.fromPointer((c.data as any)[k]); }\n  _defaultGetter(c, k) {\n    return this.__defaultGetter(c, k);\n  }\n  _defaultSetter(v0, c, k) {\n    this.__defaultSetter(v0, c, k);\n    return true;\n  }\n  __defaultGetter(c, k) {\n    // console.log(\"default Getter\");\n    let v = c.data[k];\n    return this.__shallowSolver(v, true, false);\n  }\n  __shallowSolver(val, solveArrayValues, solveObjectKeys) {\n    if (!val) return val;\n    let state = store.getState();\n    if (solveArrayValues && Array.isArray(val)) {\n      if (val.length === 0) return [];\n      return val.map(v => LPointerTargetable.attemptWrap(v));\n      // else if (Pointers.isPointer(val[0] as any)) return LPointerTargetable.fromArr(val, state);\n      // return val;\n    }\n\n    if (solveObjectKeys && typeof val === \"object\") {\n      let ret = {\n        ...val\n      };\n      for (let key in val) {\n        ret[key] = LPointerTargetable.attemptWrap(val[key]);\n      }\n      return ret;\n    }\n    return val && Pointers.isPointer(val, undefined) ? LPointerTargetable.fromPointer(val, state) : val;\n  }\n  __defaultSetter(v0, c, k) {\n    // todo: get the those lobjects -> pointer checks from set_state\n    let v = this.__sanitizeValue(v0, false, false);\n    if (true || k in c.data) {\n      var _ref;\n      // check if is pointer\n      let isPointer;\n      if (Array.isArray(v)) {\n        if (v.length === 0) isPointer = true; // assumed, should not cause harm if it is not.\n        // it will delete remove an entry in pointedBy from all oldValue entries in the array that should not be present anyway.\n        // like oldVal.map( id => U.arrayRemove(LData.wrap(id).pointedBy, c.data.this_id)\n        else isPointer = Pointers.isPointer(v[0]);\n      } else isPointer = Pointers.isPointer(v);\n\n      // autofix value\n      let bytes = 0;\n      let type = (_ref = this[\"__info_of__\" + k]) === null || _ref === void 0 ? void 0 : _ref.type;\n      if (type) type = U.multiReplaceAll(type, [\"array\", \"Array\", \"<\", \">\", \"[]\"], []);\n      switch (type) {\n        case ShortAttribETypes.EDate:\n          break;\n        default:\n          break;\n        case ShortAttribETypes.EBoolean:\n          v = !!v;\n          break;\n        case ShortAttribETypes.EByte:\n          bytes = 8;\n          break;\n        case ShortAttribETypes.EShort:\n          bytes = 16;\n          break;\n        case ShortAttribETypes.EInt:\n          bytes = 32;\n          break;\n        case ShortAttribETypes.ELong:\n          bytes = 64;\n          break;\n        case ShortAttribETypes.EString:\n          v = \"\" + v;\n          break;\n        case ShortAttribETypes.EChar:\n          v = (\"\" + v)[0];\n          break;\n        case ShortAttribETypes.EVoid:\n          Log.exx(\"cannot set a void-typed value\", {\n            c,\n            d: c.data,\n            k,\n            v\n          });\n          return true;\n        case ShortAttribETypes.EDouble:\n        case ShortAttribETypes.EFloat:\n          v = +v;\n          break;\n      }\n      if (bytes) {\n        v = Math.round(+v);\n        let max = v << bytes; // left shift is the same as multiplying by a power of 2, but binary and more efficient.\n        let min = -max + 1;\n        if (v > max) v = max;else if (v < min) v = min;\n      }\n      console.log(\"default Setter[\" + k + \"] = \" + v, {\n        type,\n        v,\n        v0,\n        oldv: c.data[k],\n        isPointer\n      });\n      SetFieldAction.new(c.data, k, v, '', isPointer);\n      return true;\n    }\n    return true;\n  }\n  get__extends(superClassName, context) {\n    return RuntimeAccessibleClass.extends(context.data.className, superClassName);\n  }\n\n  /*\r\n  public get_pointedBy(superClassName: string, context: LogicContext<DPointerTargetable>): LPointerTargetable[] {\r\n      let state: GObject = windoww.store.getState();\r\n      function getForemostObjectInPath(path: DocString<'storePath'>): undefined | LPointerTargetable {\r\n          let lastPointableObject: undefined | DPointerTargetable;\r\n          let pathArray = path.split('.');\r\n          for (let key of pathArray) {\r\n              let currentObj: GObject = state[key];\r\n              if (!currentObj) break;\r\n              if (currentObj && currentObj.id && state.idlookup[currentObj.id]) lastPointableObject = state.idlookup[currentObj.id];\r\n          }\r\n          return lastPointableObject && DPointerTargetable.wrap(lastPointableObject);\r\n      }\r\n      return (context.data.pointedBy || []).map(getForemostObjectInPath).filter( lobj => !!lobj) as LPointerTargetable[];\r\n  }*/\n\n  set_pointedBy(val, context) {\n    windoww.Log.exx('pointedBy field should never be directly edited.', {\n      context,\n      val\n    });\n    return false;\n  }\n  static fromD(data) {\n    // return null as any;\n    if (Array.isArray(data)) return LPointerTargetable.wrapAll(data);\n    return LPointerTargetable.wrap(data);\n  }\n  static fromPointer(ptr, state) {\n    // return null as any;\n    if (Array.isArray(ptr)) return LPointerTargetable.wrapAll(ptr, undefined, '', false, state);\n    return LPointerTargetable.wrap(ptr);\n  }\n  // because otherwise it complains about inheriting from DPointerTargetable.fromArr\n  static fromArr(ptr, state) {\n    return LPointerTargetable.from(ptr, state);\n  }\n  static from(ptr, s) {\n    // return null as any;\n    if (Array.isArray(ptr)) return LPointerTargetable.wrapAll(ptr);\n    return LPointerTargetable.wrap(ptr);\n  }\n\n  // static from0(a: any, ...aa: any): any { return null; }\n\n  /* OLD DELETE\r\n  public delete(): void { throw this.wrongAccessMessage(\"delete\"); }\r\n  public _delete(context: Context): void { new DeleteElementAction(context.data); }\r\n  protected get_delete(context: Context): () => void {\r\n      return () => {\r\n          alert(\"Delete in LPOINTER\")\r\n          this._delete(context);\r\n      }\r\n  }\r\n  */\n  dependencies() {\n    return [];\n  }\n  get_dependencies(context) {\n    const data = context.proxyObject;\n    const dependencies = [];\n    const ret = () => {\n      for (let pointedBy of data.pointedBy) {\n        const raw = pointedBy.source.split('.');\n        let root = raw[0];\n        const obj = raw[1] || '';\n        let field = raw[2] || '';\n\n        // Delete chars from end that are not in [azAZ].\n        const regex = /[^a-zA-Z]+$/;\n        root = root.replace(regex, '');\n        field = field.replace(regex, '');\n        // damiano: this is likely to cause a bug for sure somewhere when a key ends with \"s\" but is not an array. keep in mind when naming variables.\n        let op = field && field.endsWith('s') ? '-=' : '';\n        if (!field && root.endsWith('s')) op = '-=';\n        const dependency = {\n          root: root,\n          obj,\n          field: field,\n          op\n        };\n        if (!dependencies.includes(dependency)) dependencies.push(dependency);\n      }\n      return dependencies;\n    };\n    return ret;\n  }\n  delete() {}\n  get_delete(context) {\n    const data = context.proxyObject;\n    const dependencies = data.dependencies();\n    const ret = () => {\n      for (let child of data.children) {\n        var _child$node;\n        child.delete();\n        // todo: if a m1-dvalue which conforms to a m2-reference with \"containment\" is deleted, need to delete also target.\n        // maybe better to do through override?\n        (_child$node = child.node) === null || _child$node === void 0 ? void 0 : _child$node.delete();\n      }\n      for (let dependency of dependencies) {\n        const root = dependency.root;\n        const obj = dependency.obj;\n        const field = dependency.field;\n        const op = dependency.op;\n        const val = op === '-=' ? data.id : '';\n        if (root === 'idlookup' && obj && field) {\n          console.log('Delete', `SetFieldAction.new('${obj}', '${field}', '${val}', '${op}');`);\n          SetFieldAction.new(obj, field, val, op, false);\n        } else {\n          console.log('Delete', `SetRootFieldAction.new('${root}', '${val}', '${op}');`);\n          SetRootFieldAction.new(root, val, op, false);\n        }\n      }\n      if (data.nodes) data.nodes.map(node => node.delete());\n      SetRootFieldAction.new('ELEMENT_DELETED', data.id, '+=', false); // here no need to IsPointer because it only affects Transient stuff\n      SetRootFieldAction.new('idlookup', data.id, '-=', false); // damiano: shouldn't be isPointer = true?\n      DeleteElementAction.new(data.id);\n    };\n    return () => TRANSACTION(ret);\n  }\n}, _class11.subclasses = [], _class11._extends = [], _class11.structure = void 0, _class11.singleton = void 0, _class11)) || _class10);\nRuntimeAccessibleClass.set_extend(RuntimeAccessibleClass, LPointerTargetable);\nexport let D = (_dec7 = RuntimeAccessible('D'), _dec7(_class12 = class D extends DPointerTargetable {}) || _class12);\nexport let L = (_dec8 = RuntimeAccessible('L'), _dec8(_class13 = class L extends LPointerTargetable {}) || _class13);\nexport let P = (_dec9 = RuntimeAccessible('P'), _dec9(_class14 = class P extends Pointers {}) || _class14);\n\n/*\r\nlet pttr: Pointer<DClassifier, 0, 1, LClassifier> = null as any;\r\nlet ptrany: Pointer<DClassifier, 0|1, 1|'N'>[] = null as any;\r\nlet ptrarr: Pointer<DClassifier>[] = null as any;\r\nlet ptrarr2: Pointer<DClassifier, 1, 'N'> = null as any;\r\nlet d: DClassifier = null as any;\r\nlet darr: DClassifier[] = null as any;\r\n\r\ntype VoidPtr = null | undefined | '';\r\nfunction dfrom<\r\n    PARAM extends orArr<AnyPointer | VoidPtr>,//orArr<WPointerTargetable | LPointerTargetable | DPointerTargetable | AnyPointer>,\r\n\r\n\r\n    DDD extends (PARAM extends Pointer<infer DD> ? DD : 'undefined_D'),\r\n    LOW extends (PARAM extends Pointer<any, infer LO> ? LO : 'undefined_low'),\r\n    LOW0 extends (PARAM extends Pointer<any, 0, any, any> ? 0 : never),\r\n    LOW1 extends (PARAM extends Pointer<any, 1, any, any> ? 1 : never),\r\n    LOW2 extends (VoidPtr extends PARAM ? 0 | 'first' : (PARAM extends VoidPtr ? 0 | 1 | 'second': 1|'third')),\r\n    UPP extends (PARAM extends Pointer<any, number, infer UP> ? UP : 'undefined_upp'),\r\n    LLL extends (PARAM extends Pointer<any, number, any, infer LL> ? LL : 'undefined_L'),\r\n\r\n\r\n\r\n    ISVOID extends PARAM extends VoidPtr  ? 'isvoid' : never,\r\n    ISARR extends PARAM extends [] ? true : false,\r\n    ISPTR extends (PARAM extends AnyPointer | VoidPtr ? 'ptr' : never),\r\n    ISPTRARR extends (PARAM extends (AnyPointer | VoidPtr)[] | Pointer<DPointerTargetable, 1|0, 'N', LPointerTargetable> ? 'ptr_arr' : never),\r\n    ISD extends (PARAM extends DPointerTargetable ? 'd' : never),\r\n    ISDARR extends (PARAM extends DPointerTargetable[] ? 'd_arr' : never),\r\n    ISL extends (PARAM extends LPointerTargetable ? 'l' : never),\r\n    ISLARR extends (PARAM extends LPointerTargetable[] ? 'l_arr' : never),\r\n    ISW extends (PARAM extends WPointerTargetable ? 'w' : never),\r\n    ISWARR extends (PARAM extends WPointerTargetable[] ? 'w_arr' : never),\r\n    // INFER = {LOW:LOW, UPP:UPP, DDD:DDD, LLL:LLL, LOW2:LOW2},\r\n    INFER = { LOW2:LOW2},\r\n    RET = ISVOID | ISPTR | ISPTRARR | ISD | ISDARR | ISL | ISLARR | ISW | ISWARR | INFER\r\n    >\r\n(ptr: PARAM): RET { return null as any; }\r\nlet Lptr = dfrom(pttr as Pointer<DClassifier, 0, 1, LClassifier> );\r\nlet Lptrany = dfrom(ptrany);\r\nlet Lptrarr = dfrom(ptrarr);\r\nlet Lptrarr2 = dfrom(ptrarr2);\r\nlet Ld = dfrom(d);\r\nlet Ldarr = dfrom(darr);*/\n\nexport let WPointerTargetable = (_dec10 = RuntimeAccessible('WPointerTargetable'), _dec10(_class15 = class WPointerTargetable extends DPointerTargetable {\n  constructor() {\n    super(...arguments);\n    this.id = void 0;\n    this._storePath = void 0;\n    this._subMaps = void 0;\n    this.pointedBy = void 0;\n  }\n  // todo: WfromD, WfromL, WfromPointer, Wfrom\n\n  static fromD(data) {\n    return LPointerTargetable.fromD(data);\n  }\n}) || _class15);\nRuntimeAccessibleClass.set_extend(DPointerTargetable, LPointerTargetable);\nRuntimeAccessibleClass.set_extend(DPointerTargetable, WPointerTargetable);\nfunction fffff(t) {\n  return null;\n}\nlet a = null;\nlet bbb = LPointerTargetable.from(a);\nlet bb2 = fffff(a);\nexport let DUser = (_dec11 = RuntimeAccessible('DUser'), Leaf(_class17 = _dec11(_class17 = (_class18 = class DUser extends DPointerTargetable {\n  constructor() {\n    super(...arguments);\n    this.id = void 0;\n    this.username = void 0;\n    this.token = void 0;\n    this.projects = [];\n    this.project = '';\n    this.__isUser = true;\n  } // static current: Pointer<DUser> = 'Pointer_AnonymousUser';\n  // necessary to trick duck typing to think this is NOT the superclass of anything that extends PointerTargetable.\n  /*public static new(id?: DUser[\"id\"], triggerActions: boolean = true): DUser {\r\n      return new Constructors(new DUser('dwc'), undefined, false, undefined, id, true).DPointerTargetable().DUser().end(); }*/\n  static new(username, id) {\n    let persist = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    return new Constructors(new DUser('dwc'), undefined, persist, undefined, id).DPointerTargetable().DUser(username).end();\n  }\n}, _class18.offlineMode = !!localStorage.getItem(\"offlineMode\"), _class18.isStateMachine = false, _class18.current = '', _class18.subclasses = [], _class18._extends = [], _class18)) || _class17) || _class17);\nexport let LUser = (_dec12 = RuntimeAccessible('LUser'), _dec12(_class19 = (_class20 = class LUser extends LPointerTargetable {\n  constructor() {\n    super(...arguments);\n    this.__raw = void 0;\n    this.id = void 0;\n    this.username = void 0;\n    this.projects = void 0;\n    this.project = void 0;\n    this.__isUser = void 0;\n  }\n  get_projects(context) {\n    return LProject.fromPointer(context.data.projects);\n  }\n  set_projects(val, context) {\n    const data = context.data;\n    SetFieldAction.new(data.id, 'projects', Pointers.from(val), '', true);\n    return true;\n  }\n  get_project(context) {\n    const project = context.data.project;\n    if (project) return LProject.fromPointer(project);\n    return null;\n  }\n  set_project(val, context) {\n    const data = context.data;\n    if (val === null) SetFieldAction.new(data.id, 'project', '', '', false);else SetFieldAction.new(data.id, 'project', Pointers.from(val), '', true);\n    return true;\n  }\n}, _class20.subclasses = [], _class20._extends = [], _class20)) || _class19);\nRuntimeAccessibleClass.set_extend(DPointerTargetable, DUser);\nRuntimeAccessibleClass.set_extend(LPointerTargetable, LUser);\nexport let DProject = (_dec13 = RuntimeAccessible('DProject'), Leaf(_class21 = _dec13(_class21 = (_class22 = class DProject extends DPointerTargetable {\n  constructor() {\n    super(...arguments);\n    this.id = void 0;\n    this.type = 'collaborative';\n    this.name = void 0;\n    this.author = DUser.current;\n    this.collaborators = [];\n    this.onlineUsers = 0;\n    this.metamodels = [];\n    this.models = [];\n    this.graphs = [];\n    this.viewpoints = [];\n    this.activeViewpoint = Defaults.viewpoints[0];\n    this.favorite = void 0;\n    this.description = void 0;\n    this.state = void 0;\n  } // views: Pointer<DViewElement, 0, 'N'> = []; // can be retrieved from viewpoints.subviews\n  // stackViews: Pointer<DViewPoint, 0, 'N'> = []; // ??\n  // collaborators dict user: priority\n  static new(type, name, state, m2, m1, id, otherProjects) {\n    // fix name\n    if (!otherProjects) otherProjects = LPointerTargetable.fromPointer(DUser.current).projects;\n    if (!name) {\n      // autofix default name\n      let regexp = /Project (\\d+)/;\n      const matches = otherProjects.map(p => {\n        var _regexp$exec;\n        return +((_regexp$exec = regexp.exec(p.name)) === null || _regexp$exec === void 0 ? void 0 : _regexp$exec[1]) || 0;\n      });\n      let maxnum = Math.max(...matches, 0);\n      name = 'Project ' + (1 + maxnum);\n    } else {\n      // autofix manually inputted name\n      let allProjectNames = U.objectFromArray(otherProjects, p => p.name);\n      name = U.increaseEndingNumber(name, false, false, s => !!allProjectNames[s]);\n    }\n    return new Constructors(new DProject('dwc'), undefined, true, undefined).DPointerTargetable().DProject(type, name, state || '', m2 || [], m1 || [], id).end();\n  }\n}, _class22.subclasses = [], _class22._extends = [], _class22)) || _class21) || _class21);\nexport let LProject = (_dec14 = RuntimeAccessible('LProject'), _dec14(_class23 = (_class24 = class LProject extends LPointerTargetable {\n  constructor() {\n    super(...arguments);\n    this.id = void 0;\n    this.type = void 0;\n    this.author = void 0;\n    this.collaborators = void 0;\n    this.onlineUsers = void 0;\n    this.name = void 0;\n    this.metamodels = void 0;\n    this.models = void 0;\n    this.graphs = void 0;\n    this.viewpoints = void 0;\n    this.activeViewpoint = void 0;\n    this.favorite = void 0;\n    this.description = void 0;\n    this.state = void 0;\n    this.packages = void 0;\n    this.classes = void 0;\n    this.attributes = void 0;\n    this.references = void 0;\n    this.operations = void 0;\n    this.parameters = void 0;\n    this.enumerators = void 0;\n    this.literals = void 0;\n    this.objects = void 0;\n    this.values = void 0;\n    this.allNodes = void 0;\n    this.graphVertexes = void 0;\n    this.voidVertexes = void 0;\n    this.vertexes = void 0;\n    this.fields = void 0;\n    this.edges = void 0;\n    this.edgePoints = void 0;\n    this.children = void 0;\n    this.views = void 0;\n  } // stackViews!: LViewElement[];\n  // stringify state\n  /* DATA */\n  /* NODES */\n  /* UTILS */\n  // derived from viewpoints.subView\n  /* Functions */\n  get_favorite(c) {\n    const uid = DUser.current;\n    if (!c.data.favorite) return false;\n    return !!c.data.favorite[uid];\n  }\n  set_favorite(v, c) {\n    let favMap = c.data.favorite;\n    if (!favMap) {\n      favMap = {};\n      SetFieldAction.new(c.data.id, 'favorite', favMap);\n    }\n    const uid = DUser.current;\n    if (v) {\n      // case favorite\n      if (favMap[uid]) return true;\n      SetFieldAction.new(c.data.id, 'favorite', {\n        [uid]: true\n      }, '+=');\n    } else {\n      // case un-favorite\n      if (!favMap[uid]) return true;\n      SetFieldAction.new(c.data.id, 'favorite', {\n        [uid]: undefined\n      }, '-=');\n    }\n    return true;\n  }\n  get_name(context) {\n    return context.data.name;\n  }\n  set_name(val, context) {\n    const data = context.data;\n    SetFieldAction.new(data.id, 'name', val, '', false);\n    return true;\n  }\n  get_author(context) {\n    return LUser.fromPointer(context.data.author);\n  }\n  set_author(val, context) {\n    const data = context.data;\n    SetFieldAction.new(data.id, 'author', Pointers.from(val), '', true);\n    return true;\n  }\n  get_state(context) {\n    return context.data.state;\n  }\n  set_state(val, context) {\n    const data = context.data;\n    SetFieldAction.new(data.id, 'state', val, '', false);\n    return true;\n  }\n  get_collaborators(context) {\n    return LUser.fromPointer(context.data.collaborators);\n  }\n  set_collaborators(val, context) {\n    const data = context.data;\n    SetFieldAction.new(data.id, 'collaborators', Pointers.from(val), '', true);\n    return true;\n  }\n  get_onlineUsers(context) {\n    return context.data.onlineUsers;\n  }\n  set_onlineUsers(val, context) {\n    const data = context.data;\n    SetFieldAction.new(data.id, 'onlineUsers', val, '', false);\n    return true;\n  }\n  get_metamodels(context) {\n    return LModel.fromPointer(context.data.metamodels);\n  }\n  set_metamodels(val, context) {\n    const data = context.data;\n    SetFieldAction.new(data.id, 'metamodels', Pointers.from(val), '', true);\n    return true;\n  }\n  get_models(context) {\n    return LModel.fromPointer(context.data.models);\n  }\n  set_models(val, context) {\n    const data = context.data;\n    SetFieldAction.new(data.id, 'models', Pointers.from(val), '', true);\n    return true;\n  }\n  get_graphs(context) {\n    return LGraph.fromPointer(context.data.graphs);\n  }\n  set_graphs(val, context) {\n    const data = context.data;\n    SetFieldAction.new(data.id, 'graphs', Pointers.from(val), '', true);\n    return true;\n  }\n  get_views(c) {\n    // return LViewElement.fromPointer([...c.data.views, ...Defaults.views]);\n    let duplicateRemover = {};\n    let varr = this.get_viewpoints(c).flatMap(vp => vp.allSubViews);\n    for (let v of varr) duplicateRemover[v.id] = v;\n    return Object.values(duplicateRemover);\n  }\n  set_views(val, context) {\n    return Log.exx(\"cannot set project.views, set them as subviews of a project viewpoint.\");\n    /*\r\n    const data = context.data;\r\n    let ptrs = Pointers.from(val);\r\n    let defaultViewsMap: Dictionary<Pointer, boolean> = U.objectFromArrayValues(Defaults.views);\r\n    ptrs = ptrs.filter(ptr => !defaultViewsMap[ptr]);\r\n    SetFieldAction.new(data.id, 'views', ptrs, '', true);\r\n    return true;*/\n  }\n  /*\r\n      protected get_stackViews(context: Context): this['stackViews'] {\r\n          return LViewElement.fromPointer(context.data.stackViews || []);\r\n      }\r\n      protected set_stackViews(val: PackArr<this['stackViews']>, context: Context): boolean {\r\n          const data = context.data;\r\n          SetFieldAction.new(data.id, 'stackViews', Pointers.from(val), '', true);\r\n          return true;\r\n      }*/\n\n  get_viewpoints(context) {\n    return LViewPoint.fromPointer([...Defaults.viewpoints, ...context.data.viewpoints]);\n  }\n  set_viewpoints(val, context) {\n    const data = context.data;\n    SetFieldAction.new(data.id, 'viewpoints', Pointers.from(val), '', true);\n    return true;\n  }\n  get_activeViewpoint(context) {\n    return LViewPoint.fromPointer(context.data.activeViewpoint || Defaults.viewpoints[0]);\n  }\n  set_activeViewpoint(val, context) {\n    const data = context.data;\n    SetFieldAction.new(data.id, 'activeViewpoint', Pointers.from(val), '', true);\n    return true;\n  }\n\n  /* DATA Getter */\n  get_packages(context) {\n    const data = context.proxyObject;\n    return data.metamodels.flatMap(m => m.allSubPackages);\n  }\n  get_classes(context) {\n    const data = context.proxyObject;\n    return data.packages.flatMap(p => p.classes);\n  }\n  get_attributes(context) {\n    const data = context.proxyObject;\n    return data.classes.flatMap(c => c.attributes);\n  }\n  get_references(context) {\n    const data = context.proxyObject;\n    return data.classes.flatMap(c => c.references);\n  }\n  get_operations(context) {\n    const data = context.proxyObject;\n    return data.classes.flatMap(c => c.operations);\n  }\n  get_parameters(context) {\n    const data = context.proxyObject;\n    return data.operations.flatMap(o => o.parameters);\n  }\n  get_enumerators(context) {\n    const data = context.proxyObject;\n    return data.packages.flatMap(p => p.enumerators);\n  }\n  get_literals(context) {\n    const data = context.proxyObject;\n    return data.enumerators.flatMap(e => e.literals);\n  }\n  get_objects(context) {\n    const data = context.proxyObject;\n    return data.models.flatMap(m => m.allSubObjects);\n  }\n  get_values(context) {\n    const data = context.proxyObject;\n    return data.models.flatMap(m => m.allSubValues);\n  }\n\n  /* NODES Getter */\n  get_allNodes(context) {\n    const data = context.proxyObject;\n    const nodes = [];\n    // nodes.push(...(data.metamodels.flatMap(m => m.node).filter(n => n !== undefined) as NodeTypes[]));\n    nodes.push(...data.packages.flatMap(m => m.node).filter(n => n !== undefined));\n    nodes.push(...data.classes.flatMap(m => m.node).filter(n => n !== undefined));\n    nodes.push(...data.attributes.flatMap(m => m.node).filter(n => n !== undefined));\n    nodes.push(...data.references.flatMap(m => m.node).filter(n => n !== undefined));\n    nodes.push(...data.operations.flatMap(m => m.node).filter(n => n !== undefined));\n    nodes.push(...data.parameters.flatMap(m => m.node).filter(n => n !== undefined));\n    nodes.push(...data.enumerators.flatMap(m => m.node).filter(n => n !== undefined));\n    nodes.push(...data.literals.flatMap(m => m.node).filter(n => n !== undefined));\n    // nodes.push(...(data.models.flatMap(m => m.node).filter(n => n !== undefined) as NodeTypes[]));\n    nodes.push(...data.objects.flatMap(m => m.node).filter(n => n !== undefined));\n    nodes.push(...data.values.flatMap(m => m.node).filter(n => n !== undefined));\n    return nodes;\n  }\n  get_graphVertexes(context) {\n    const data = context.proxyObject;\n    return data.allNodes.filter(n => n.className === 'DGraphVertex');\n  }\n  get_voidVertexes(context) {\n    const data = context.proxyObject;\n    return data.allNodes.filter(n => n.className === 'DVoidVertex');\n  }\n  get_vertexes(context) {\n    const data = context.proxyObject;\n    return data.allNodes.filter(n => n.className === 'DVertex');\n  }\n  get_fields(context) {\n    const data = context.proxyObject;\n    return data.allNodes.filter(n => n.className === 'DGraphElement');\n  }\n  get_edges(context) {\n    const data = context.proxyObject;\n    return data.graphs.flatMap(g => g.subElements.filter(e => e.className === 'DEdge'));\n  }\n  get_edgePoints(context) {\n    const data = context.proxyObject;\n    return data.edges.flatMap(e => e.subElements);\n  }\n\n  /* CUSTOM Functions */\n  get_children(context) {\n    const data = context.proxyObject;\n    return [/* Data */\n    ...data.metamodels, ...data.packages, ...data.classes, ...data.attributes, ...data.references, ...data.operations, ...data.parameters, ...data.enumerators, ...data.literals, ...data.models, ...data.objects, ...data.values, /* Views & Viewpoints */\n    ...data.views.filter(v => v && !Defaults.views.includes(v.id)), ...data.viewpoints.filter(vp => vp && !Defaults.viewpoints.includes(vp.id)), /* Nodes */\n    ...data.allNodes];\n  }\n\n  /*\r\n      public pushToStackViews(view: Pack<LViewElement>): void {\r\n          throw new Error('cannot be called directly, should trigger getter. this is only for correct signature');\r\n      }\r\n      protected get_pushToStackViews(context: Context): (view: Pack<LViewElement>) => void {\r\n          return (view) => {\r\n              const data = context.data;\r\n              SetFieldAction.new(data.id, 'stackViews', Pointers.from(view), ', true);\r\n          }\r\n      }\r\n  /*\r\n      public popFromStackViews(): void {\r\n          throw new Error('cannot be called directly, should trigger getter. this is only for correct signature');\r\n      }\r\n      protected get_popFromStackViews(context: Context): () => void {\r\n          return () => {\r\n              const data = context.data;\r\n              const view = data.stackViews?.at(-1);\r\n              if(!view) return;\r\n              SetFieldAction.new(data.id, 'stackViews', view as any, '-=', true);\r\n          }\r\n      }\r\n  */\n  delete() {\n    throw new Error('cannot be called directly, should trigger getter. this is only for correct signature');\n  }\n  get_delete(c) {\n    const data = c.proxyObject;\n    return () => {\n      TRANSACTION(() => {\n        // this crashes, there is no get_children() (data.children || []).map(c => c && c.delete());\n        SetFieldAction.new(DUser.current, 'projects', c.data.id, '-=', true);\n        DeleteElementAction.new(data.id);\n        SetRootFieldAction.new('projects', c.data.id, '-=', true);\n      });\n    };\n  }\n  duplicate() {\n    return this.wrongAccessMessage('LProject.duplicate()');\n  }\n  get_duplicate(c) {\n    return () => {\n      let clone = DProject.new(c.data.type, c.data.name + ' Copy');\n      for (let key in c.data) {\n        switch (key) {\n          case 'pointedBy':\n          case 'name':\n            continue;\n          default:\n            // @ts-ignore\n            clone[key] = c.data[key];\n            break;\n        }\n      }\n      clone.author = DUser.current;\n      clone.onlineUsers = 0; // i think this should not be a presistent data, but a fake attribute available only on LProject\n      // todo per giordano: assign project to user & set persistent stuff with ProjectsAPI ?\n      return LPointerTargetable.fromD(clone);\n    };\n  }\n}, _class24.subclasses = [], _class24._extends = [], _class24)) || _class23);\nRuntimeAccessibleClass.set_extend(DPointerTargetable, DProject);\nRuntimeAccessibleClass.set_extend(LPointerTargetable, LProject);\nexport let MyError = (_dec15 = RuntimeAccessible('MyError'), _dec15(_class25 = class MyError extends Error {\n  constructor(message) {\n    // 'Error' breaks prototype chain here\n    super(message);\n    const proto = this.__proto__;\n    for (var _len3 = arguments.length, otherMsg = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n      otherMsg[_key3 - 1] = arguments[_key3];\n    }\n    console.error(proto.constructor.cname || proto.constructor.name, message, ...otherMsg);\n    // restore prototype chain\n    const actualProto = new.target.prototype;\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(this, actualProto);\n    } else {\n      this.__proto__ = actualProto;\n    }\n    this.className = this.constructor.cname;\n  }\n}) || _class25);\n\n// @RuntimeAccessible\nexport class JsType {\n  constructor(printableTypeName, check, isExclusiveType) {\n    this.printableTypeName = printableTypeName;\n    this.check = check;\n    this.isExclusiveType = isExclusiveType;\n    JsType.all.push(this);\n  }\n  toString() {\n    return this.printableTypeName;\n  }\n  /*\r\n  * example: isObject but not Date, not function...\r\n  * */\n  static isOnlyType(data, type) {\n    return !JsType.getTypes(data, type).length;\n  }\n  static isAnyOfTypes(data) {\n    for (var _len4 = arguments.length, acceptables = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {\n      acceptables[_key4 - 1] = arguments[_key4];\n    }\n    return !!windoww.Uarr.arrayIntersection(JsType.getTypes(data), acceptables).length;\n  }\n  static getTypes(data, stopIfTypeIsNot) {\n    const ret = [];\n    for (const type of JsType.all) {\n      if (type.check(data)) {\n        ret.push(data);\n        if (stopIfTypeIsNot !== type) {\n          return [];\n        }\n        if (type.isExclusiveType) return ret;\n      }\n    }\n    return ret;\n  }\n\n  /// is...\n  static isObject(data) {\n    let returnIfNull = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    return data === null ? returnIfNull : typeof data === \"object\";\n  }\n  static isFunction(data) {\n    return typeof data === \"function\";\n  }\n  static isLambdaFunction(data) {\n    if (!JsType.isFunction(data)) return false;\n    return windoww.U.getFunctionSignatureFromComments(data).isLambda;\n  }\n  static isNonLambdaFunction(data) {\n    return JsType.isFunction(data) && !JsType.isNonLambdaFunction(data);\n  }\n  static isArray(data) {\n    return Array.isArray(data);\n  }\n  static isSymbol(data) {\n    return typeof data === \"symbol\";\n  }\n  static isBoolean(data) {\n    return !!data === data;\n  }\n  static isNumber(data) {\n    return typeof data === \"number\";\n  }\n  static isBigint(data) {\n    return typeof data === \"bigint\";\n  }\n  static isString(data) {\n    return typeof data === \"string\";\n  }\n  static isNull(data) {\n    return data === null;\n  }\n  static isUndefined(data) {\n    return data === undefined;\n  }\n  static isDate(data) {\n    return data instanceof Date;\n  }\n\n  /// as...\n  static asObject(data, fallbackReturn) {\n    return JsType.isObject(data) ? data : fallbackReturn;\n  }\n  static asFunction(data, fallbackReturn) {\n    return JsType.isFunction(data) ? data : fallbackReturn;\n  }\n  static asLambdaFunction(data, fallbackReturn) {\n    return JsType.isLambdaFunction(data) ? data : fallbackReturn;\n  }\n  static asNonLambdaFunction(data, fallbackReturn) {\n    return JsType.isNonLambdaFunction(data) ? data : fallbackReturn;\n  }\n  static asArray(data, fallbackReturn) {\n    return JsType.isArray(data) ? data : fallbackReturn;\n  }\n  static asSymbol(data, fallbackReturn) {\n    return JsType.isSymbol(data) ? data : fallbackReturn;\n  }\n  static asBoolean(data, fallbackReturn) {\n    return JsType.isBoolean(data) ? data : fallbackReturn;\n  }\n  static asNumber(data, fallbackReturn) {\n    return JsType.isNumber(data) ? data : fallbackReturn;\n  }\n  static asBigint(data, fallbackReturn) {\n    return JsType.isBigint(data) ? data : fallbackReturn;\n  }\n  static asString(data, fallbackReturn) {\n    return JsType.isString(data) ? data : fallbackReturn;\n  }\n  static asNull(data, fallbackReturn) {\n    return JsType.isNull(data) ? data : fallbackReturn;\n  }\n  static asUndefined(data, fallbackReturn) {\n    return JsType.isUndefined(data) ? data : fallbackReturn;\n  }\n  static asDate(data, fallbackReturn) {\n    return JsType.isDate(data) ? data : fallbackReturn;\n  }\n  static isPrimitive(data) {\n    return !JsType.isAnyOfTypes(data, JsType.object, JsType.function, JsType.array);\n  }\n}\nJsType.all = [];\nJsType.object = new JsType(\"object\", JsType.isObject, false);\nJsType.function = new JsType(\"function\", JsType.isFunction, false);\nJsType.array = new JsType(\"array\", JsType.isArray, false);\nJsType.date = new JsType(\"Date\", JsType.isDate, false);\nJsType.lambdaFunction = new JsType(\"lambda-function\", JsType.isLambdaFunction, true);\nJsType.nonLambdaFunction = new JsType(\"non-lambda-function\", JsType.isNonLambdaFunction, true);\nJsType.symbol = new JsType(\"symbol\", JsType.isSymbol, true);\nJsType.undefined = new JsType(\"undefined\", JsType.isUndefined, true);\nJsType.null = new JsType(\"null\", JsType.isNull, true);\nJsType.boolean = new JsType(\"boolean\", JsType.isBoolean, true);\nJsType.number = new JsType(\"number\", JsType.isNumber, true);\nJsType.bigint = new JsType(\"bigint\", JsType.isBigint, true);\nJsType.string = new JsType(\"string\", JsType.isString, true);\nfunction invalidSuperClassError( /*callee: Class,*/scname, superclass) {\n  return () => {\n    windoww.Log.exDevv('parent super class \"' + scname + '\" is not implementing init_constructor', {\n      scname,\n      superclass\n    });\n    throw new Error();\n  };\n}\n// @ts-ignore\nfunction MixinFakeConstructor() {\n  this.isMixinFakeConstructor = true;\n}\n_c8 = MixinFakeConstructor;\nexport function MixOnlyFuncs2(c1, c2) {\n  return MixOnlyFuncs(c1, c2);\n}\n_c9 = MixOnlyFuncs2;\nexport function MixOnlyFuncs3(c1, c2) {\n  return MixOnlyFuncs(c1, c2);\n}\n_c10 = MixOnlyFuncs3;\nexport function MixOnlyFuncs(c1, c2) {\n  // strategia: passo dei finti valori che copiano i prototipi delle classi sovrascrivendo i costruttori per evitare che chiami i costruttori delle superclassi\n  // ma che comunque erediti campi e funzioni\n  // @ts-ignore\n  let c1noconstructor = MixinFakeConstructor;\n  let c2noconstructor = MixinFakeConstructor;\n  c1noconstructor.prototype = c1.prototype;\n  c2noconstructor.prototype = c2.prototype;\n  let disableconstructor = false;\n  if (!disableconstructor) {\n    c1noconstructor = c1;\n    c2noconstructor = c2;\n  }\n  let ret = Mixin(c1noconstructor, c2noconstructor);\n  let c1name = (c1.cname || c1.name) === 'classnameFixedConstructorDoNotRenameWithoutSearchStrings' ? c1.prototype.className : c1.cname || c1.name;\n  let c2name = (c2.cname || c2.name) === 'classnameFixedConstructorDoNotRenameWithoutSearchStrings' ? c2.prototype.className : c2.cname || c2.name;\n  //ret.prototype['superclass'] = {};\n  // ret.prototype['superclass'][c1name] = c1.prototype.init_constructor || invalidSuperClassError(c1name, c1);\n  // ret.prototype['superclass'][c2name] = c2.init_constructor || invalidSuperClassError(c2name, c2);\n  ret.prototype['superclass1'] = {};\n  ret.prototype['superclass2'] = {};\n  ret.prototype['superclass1'][c1name] = c1.init_constructor || invalidSuperClassError(c1name, c1);\n  ret.prototype['superclass2'][c2name] = c2.init_constructor || invalidSuperClassError(c2name, c2);\n  return ret;\n}\n// console.info('ts loaded classes');\n\n//*********************************************************************************************\n//*********************************************************************************************\n///////                              type juggling starts here                          ///////\n//*********************************************************************************************\n//*********************************************************************************************\n\n// export type NotAString<T extends any = 'uselessval'> = Omit<string, 'bold'> & {big: T};\n// export type NotAString<T extends any = 'uselessval'> = Omit<string, 'bold'>;\n// export type NotAString<T extends any = 'uselessval', T2 extends any = any, T3 extends any = any, T4 extends any = any> = string & Omit<string, 'bold'> & {bold: ()=>string};\n_c11 = MixOnlyFuncs; // export type NotAString<T> = string;\n// type Pointer<T> = NotAString<T>;\n// to convert Pointers to strings more explicitly then using as any\n// let ptr: Pointer<Object> = null as any;\n/*\r\nclass D extends DPointerTargetable{\r\n    parent!: Pointer<D>;\r\n    dattrib!: boolean;\r\n    juststring!: string;\r\n    nattrib!: number;\r\n    ddattrib!: Date\r\n}\r\n\r\nclass D2 extends D{\r\n    d2!: string;\r\n}\r\nclass D3 extends D{\r\n    d3!: string;\r\n}\r\n\r\n\r\n\r\ntype OverrideTypes<M, N> = { [P in keyof M]: P extends keyof N ? N[P] : M[P] }; // usage:  OverrideTypes<A, { x: number }>;\r\n\r\ninterface LFix {\r\n    parent: L;\r\n}\r\ninterface L { // no instances ever\r\n    parent: L;\r\n    lattrib: boolean;\r\n}\r\ninterface L2 extends L { // no instances ever\r\n    l2: string;\r\n}\r\ninterface L3 extends L{ // no instances ever\r\n    l3: string;\r\n}\r\n\r\nclass P { // singleton\r\n    get_parent(){}\r\n    set_parent(){}\r\n}\r\nclass P2 extends P { // singleton\r\n    get_d2() {}\r\n}\r\nclass P3 extends P { // singleton\r\n    get_d3() {}\r\n}*/\n// RegExp extends Animal ? number : string\n\nfunction buildWrapSignature() {\n  let maxdepth = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 100;\n  let arr = windoww[\"DPointerTargetable\"].subclasses;\n  /*\r\n  let dict0 = arr.reduce((a, v) => ({ ...a, [v.name]: v}), {});\r\n  let dict = {}\r\n  for (let name in dict0) { let n = name.substring(1); dict[n] = {\"D\":dict0[\"D\"+n], \"L\":dict0[\"L\"+n]}; dict[\"D\"+n] = dict0[\"L\"+n]; dict[\"L\"+n] = dict0[\"D\"+n]; }\r\n  console.log(\"dict\", dict);\r\n  console.table(dict);\r\n  */\n  function onlyUnique(value, index, self) {\n    return self.indexOf(value) === index;\n  }\n  let dep = arr; // .map( (me) => { return {\"name\": me.name, \"me\": me, \"Derror\": (dict[me.name] || me).name, \"Lerror\": (dict[me.name] || me).name, \"subclasses\": [...me.subclasses]}});\n  let depsorted = [];\n  let byLevels = [];\n  let loopdetecter = [arr];\n  while (dep.length && maxdepth--) {\n    let namelist = dep.map(e => e.name).filter(onlyUnique);\n    depsorted.push(...namelist);\n    byLevels.push([...namelist]);\n    let olddep = dep;\n    dep = dep.flatMap(d => d.subclasses).filter(onlyUnique);\n    for (let d of dep) {\n      windoww.loopdetecter = loopdetecter;\n      windoww.dep = dep;\n      windoww.olddep = olddep;\n      windoww.byLevels = byLevels;\n      windoww.d = d;\n      if (loopdetecter.includes(d.subclasses)) throw new Error(\"class is not redefining subclasses static array: \" + d.name);\n      loopdetecter.push(d.subclasses);\n    }\n  }\n  console.log(\"byLevels\");\n  console.table(byLevels);\n  console.log(\"depsorted\", depsorted);\n\n  // console.log(\"map\");\n  // console.table(depsorted.map(dn => {let d = window[dn]; return !d ? \"\" :{name:d.name, scount: d.subclasses.length, subclasses:d.subclasses}}));\n\n  let goalSignature = \"function wrap<DX extends D, LX = DX extends D2 ? L2: (DX extends D3 ? L3: (DX extends D ? L : ERROR))>(data: DX): LX {\";\n  let lparam = \"ERROR\";\n  let epsorted = depsorted.map(e => e.substring(1)).filter(onlyUnique);\n  console.table(epsorted);\n  for (let e of epsorted) {\n    let D = \"D\" + e;\n    let L = \"L\" + e;\n    lparam = \"DX extends \" + D + \" ? \" + L + \" : (\" + lparam + \")\";\n  }\n  let signature = \"function wrap<DX extends DPointerTargetable, LX = \" + lparam + \">(data: DX): LX {\";\n  return signature;\n}\nwindoww.buildWrapSignature = buildWrapSignature;\n// function wrap<DX extends D, LX = DX extends D2 ? L2: (DX extends D3 ? L3: (DX extends D ? L : ERROR))>(data: DX): LX {\n\n/*\r\n* NO    L -> D    /// l.__raw\r\n* NO    L -> Ptr  /// l.id\r\n*\r\n* NO    D -> Ptr   // d.id\r\n* YES   D -> L     // wrap\r\n*\r\n* NO    Ptr -> D\r\n* NO    Ptr -> L\r\n*\r\n*\r\n*\r\n*\r\n* DpointerTargetable.from( L or pointer )\r\n* LpointerTargetable.from( D or pointer )\r\n*\r\n* MyProxyHandler.wrap = LpointerTargetable.from;\r\n*\r\n* DpointerTargetable.toPointer( d );\r\n*\r\n\r\ntype subtractDL = subtract<D, L>;\r\n* */ //////////////////////////////////////////// best solution so far\n// todo: can't automatically convert D to L (generating the type instead of manual defining L) rules are: LClass <--- Pointer<LClass>, LClass[] <-- Pointer<LClass, 0, 'N'>, subobject = ? should not be there\n/**\r\n i have a documentation type that is actually a string, but it\\'s have a different purpose from the others, and i made a type to keep documentally separated.\r\n let's say it's\r\n type StringOf<P> = string; // regardless of P\r\n\r\n and i use it to define objects\r\n\r\n class C {\r\n           str: StringOf<Date>;\r\n           str2: StringOf<number>;\r\n           purestring: string;\r\n           num: number\r\n         }\r\n now i want to crete a derivate type that excludes all properties of type StringOf from C\r\n\r\n\r\n\r\n type OnlyKeysOfTypeTmp<T, IncludeType> = ({[P in keyof T]: T[P] extends IncludeType ? P : never })[keyof T];\r\n type OnlyKeysOfType<T, IncludeType> = Pick<T, OnlyKeysOfTypeTmp<T, IncludeType>>;\r\n type RemoveKeysOfType<T, ExcludeType> = Exclude2<T, OnlyKeysOfType<T, string>>;\r\n\r\n type D = RemoveKeysOfType<C, StringOf<any>>\r\n due to duck typing, this removes all StringOf attributes, but also \"purestring\" attribute.\r\n how can i remove only StringOf attributes?\r\n\r\n\r\n */\n// & L\n\nexport let EGraphElements;\n(function (EGraphElements) {\n  EGraphElements[\"GraphElement\"] = \"GraphElement\";\n  EGraphElements[\"Field\"] = \"GraphElement\";\n  EGraphElements[\"Vertex\"] = \"Vertex\";\n  EGraphElements[\"todo\"] = \"todo\";\n})(EGraphElements || (EGraphElements = {}));\nexport let EModelElements;\n(function (EModelElements) {\n  EModelElements[\"(m2) Model\"] = \"DModel\";\n  EModelElements[\"(m2) Package\"] = \"DPackage\";\n  EModelElements[\"(m2) Class\"] = \"DClass\";\n  EModelElements[\"(m2) Enum\"] = \"DEnumerator\";\n  EModelElements[\"(m2) Literal\"] = \"DEnumLiteral\";\n  EModelElements[\"(m2) Operation\"] = \"DOperation\";\n  EModelElements[\"(m2) Parameter\"] = \"DParameter\";\n  EModelElements[\"(m2) Attribute\"] = \"DAttribute\";\n  EModelElements[\"(m2) Reference\"] = \"DReference\";\n  EModelElements[\"(m2) Annotation\"] = \"DAnnotation\";\n  EModelElements[\"(abstract m2) Feature\"] = \"DStructuralFeature\";\n  EModelElements[\"(abstract m2) Classifier\"] = \"DClassifier\";\n  EModelElements[\"(m1) Object\"] = \"DObject\";\n  EModelElements[\"(m1) Value\"] = \"DValue\";\n})(EModelElements || (EModelElements = {}));\nexport class ViewEClassMatch {}\nViewEClassMatch.NOT_EVALUATED_YET = undefined;\nViewEClassMatch.MISMATCH = Number.NEGATIVE_INFINITY;\nViewEClassMatch.MISMATCH_PRECONDITIONS = Number.NEGATIVE_INFINITY;\nViewEClassMatch.MISMATCH_JS = false;\nViewEClassMatch.MISMATCH_OCL = false;\nViewEClassMatch.IMPLICIT_MATCH = 1;\nViewEClassMatch.INHERITANCE_MATCH = 1.5;\nViewEClassMatch.EXACT_MATCH = 2;\nViewEClassMatch.VP_MISMATCH = Number.NEGATIVE_INFINITY;\nViewEClassMatch.VP_Default = 1;\nViewEClassMatch.VP_Decorative = 1;\nViewEClassMatch.VP_Explicit = 2;\nexport class NodeTransientProperties {\n  // L-version because it is used in oclUpdate function\n\n  // for each parentview, an array of Decorative Views[] sorted by score (including parent view influence).\n  // an array of Main Views[] sorted by score (including parent view influence).\n\n  // global for this node (without view-specific usageDeclaration)\n\n  //force1Update!: boolean;\n  constructor() {\n    this.viewSorted_modelused = void 0;\n    this.viewSorted_pvid_used = void 0;\n    this.viewSorted_nodeused = void 0;\n    this.stackViews = void 0;\n    this.validMainViews = void 0;\n    this.mainView = void 0;\n    this.viewScores = {};\n    this.evalContext = void 0;\n    this.needSorting = void 0;\n    // this.stackViews = []; this.validMainViews = [];\n    this.viewScores = {};\n  }\n}\nexport class ViewTransientProperties {\n  // css_MUST_RECOMPILE: boolean;\n  // compiled_css: string; maye those are better shared in sessions\n\n  // not used anymore? was like UD+shouldcompoupdate for jsx, a pre-ocl check\n\n  constructor() {\n    this.events = void 0;\n    this.oclChanged = void 0;\n    this.jsConditionChanged = void 0;\n    this.oclUpdateCondition_PARSED = void 0;\n    this.oclEngine = void 0;\n    this.jsCondition = void 0;\n    this.JSXFunction = void 0;\n    this.UDFunction = void 0;\n    this.constantsList = void 0;\n    this.UDList = void 0;\n    this.constants = void 0;\n    this.onDataUpdate = void 0;\n    this.onDragStart = void 0;\n    this.onDragEnd = void 0;\n    this.whileDragging = void 0;\n    this.onResizeStart = void 0;\n    this.onResizeEnd = void 0;\n    this.whileResizing = void 0;\n    this.onRotationStart = void 0;\n    this.onRotationEnd = void 0;\n    this.whileRotating = void 0;\n    this.events = {};\n  }\n}\nexport class DataTransientProperties {\n  constructor() {\n    this.nodes = void 0;\n    this.node = void 0;\n    this.nodes = {};\n  }\n}\n\n// score for all view ocl + sorted views by best match\n\nexport const transientProperties = {\n  node: {},\n  view: {},\n  modelElement: {}\n};\nwindow.transient = window.transientProperties = transientProperties;\n// transientProperties.nodes[nid].viewScores[vid]?.[pvid as string];\n/*\r\nexport const transientPropertiesByGraphTab: {viewMatchings: Dictionary<Pointer<DGraph>, Dictionary<Pointer<DModelElement>, TransientPropertiesByGraphTab>>} = {\r\n viewMatchings: {}\r\n};*/\nvar _c, _c2, _c3, _c4, _c5, _c6, _c7, _c8, _c9, _c10, _c11;\n$RefreshReg$(_c, \"Obsolete\");\n$RefreshReg$(_c2, \"Leaf\");\n$RefreshReg$(_c3, \"Node\");\n$RefreshReg$(_c4, \"Abstract\");\n$RefreshReg$(_c5, \"Instantiable\");\n$RefreshReg$(_c6, \"RuntimeAccessible\");\n$RefreshReg$(_c7, \"RuntimeAccessible_inner\");\n$RefreshReg$(_c8, \"MixinFakeConstructor\");\n$RefreshReg$(_c9, \"MixOnlyFuncs2\");\n$RefreshReg$(_c10, \"MixOnlyFuncs3\");\n$RefreshReg$(_c11, \"MixOnlyFuncs\");","map":{"version":3,"names":["Mixin","EdgeBendingMode","EdgeGapMode","Action","CreateElementAction","Defaults","DeleteElementAction","GraphPoint","GraphSize","LGraph","LModel","Log","LViewPoint","SetFieldAction","SetRootFieldAction","ShortAttribETypes","statehistory","store","TRANSACTION","U","windoww","window","console","warn","AbstractMixedClass","init_constructor","logic","structure","singleton","RuntimeAccessibleClass","set_extend","superclass","subclass","hasOwnProperty","subclasses","indexOf","push","_extends","extendPrototypes","Array","prototype","contains","o","joinOriginal","join","first","eval","separator","_len","arguments","length","separators","_key","isArray","ret","i","fixStatics","classs","Object","values","annotatedClasses","gclass","statickey","s","getAllNames","annotated","undefined","keys","classes","getAllClasses","getAllClassesDictionary","wrapAll","data","baseObjInLookup","path","canThrow","state","filter","getState","map","d","DPointerTargetable","wrap","__isProxy","from","e","error","Error","Proxy","TargetableProxyHandler","attemptWrap","v","LPointerTargetable","fromPointer","className","_RuntimeAccessibleCla","_RuntimeAccessibleCla2","get","fromD","mapWrap","subMapKeys","MapProxyHandler","constructor","thiss","dclassname","mode","extends","superClassName","_RuntimeAccessibleCla3","returnIfEqual","thisclass","extendMatrix","cname","getAllPrototypeSuperClasses","currentlevel","__proto__","log","makeOCLConstructor","oldState","_rootModel","rootModel","father","mid","id","OCL_Constructors","OclConstructor","namefixed","idlookup","oldname","name","replaceAll","getOCLClasses","model_id","Obsolete","_c","Leaf","_c2","Node","_c3","Abstract","_c4","Instantiable","instanceConstructor","_c5","RuntimeAccessible","ctor","RuntimeAccessible_inner","_c6","staticClassName","outerthis","classnameFixedConstructorDoNotRenameWithoutSearchStrings","_obj$initBase","_len2","args","_key2","obj","classNameFromAnnotation","initBase","call","key","_c7","CoordinateMode","EdgeHead","canFireActions","Constructors","_dec","_class","_class2","t","persist","fatherType","isUser","nonPersistentCallbacks","fatherPtr","setID","pendingCreation","_persistCallbacks","_derivedSubElements","setPtr","makeID","Date","getTime","DUser","current","maxID","property","value","checkPointerValidity","Pointers","isPointer","create","PointedBy","fromID","setExternalRootProperty","val","accessModifier","setExternalPtr","target","setWithSideEffect","fromCreateAction","paused","subElements","callbacks","new","c","fire","end","simpledatacallback","cb","DState","debug","localStorage","getItem","DModelElement","DClassifier","DParameter","defaultValue","DStructuralFeature","_DClass","DClass","_DValue","DValue","targets","alreadyParsed","nextTargets","ww","feature","superclasses","ext","extendedBy","pointer","instanceObjPtr","instances","new3","instanceof","DReference","DAttribute","DDataType","DObject","instanceoff","isMirage","edges","DAnnotation","source","details","det","username","_this","undoable","redoable","DNamedElement","substring","DTypedElement","type","DPackage","uri","prefix","DModel","isMetamodel","packages","DOperation","exceptions","implementation","isInterface","isAbstract","isPrimitive","partial","partialdefaultname","interface","abstract","isSingleton","DEnumLiteral","literal","DEnumerator","literals","DEdgePoint","DEdge","DVertex","DVoidEdge","start","longestLabel","labels","startid","LGraphElement","getNodeId","endid","ex","anchorStart","anchorEnd","midnodes","midPoints","ll","allNodes","allSegments","toFixed","gthis","x","y","w","h","edgesIn","edgesOut","anchors","__isDVoidEdge","__isDEdge","DExtEdge","DRefEdge","DGraphElement","model","parentgraphID","htmlindex","favoriteNode","zIndex","isSelected","k","a","eDev","adding","DViewElement","jsxString","vp","defaultVSize","_user$project","usageDeclarations","constants","preRenderFunc","appliableToClasses","oclCondition","priority","vid","tv","transientProperties","view","appliableTo","onDragEnd","onDragStart","whileDragging","onResizeEnd","onResizeStart","whileResizing","onRotationEnd","onRotationStart","whileRotating","onDataUpdate","events","subViews","jsCondition","oclUpdateCondition","OCL_NEEDS_RECALCULATION","explicitApplicationPriority","isExclusiveView","size","storeSize","lazySizeUpdate","isValidation","palette","hexToPalette","css","compiled_css","css_MUST_RECOMPILE","cssIsGlobal","draggable","resizable","adaptWidth","adaptHeight","edgeStartOffset","edgeEndOffset","edgeStartOffset_isPercentage","edgeEndOffset_isPercentage","edgeStartStopAtBoundaries","edgeEndStopAtBoundaries","bendingMode","Bezier_quadratic","edgeGapMode","center","edgePointCoordMode","relativeOffset","edgeHeadSize","edgeTailSize","user","LUser","project","activeViewpoint","viewpoints","RecompileKeys","DViewPoint","DProject","m2","m1","wrapper","metamodels","models","favorite","description","toLocaleString","DGraph_makeID","modelid","DGraph_maxID","DGraph","graph","zoom","offset","_subMaps","graphSize","DVoidVertex","defaultVSizeObj","defaultVSizeFunc","isResized","lvertex","exx","txt","toString","index","updateEPindex","_defaultVSizeObj","lep","le","de","__raw","subelements","arrayRemoveAll","splice","setTimeout","_dec2","_class3","_class4","defaultname","startingPrefix","metaptr","lfather","meta","childrenNames","children","increaseEndingNumber","newname","condition","fakearg_detectwrongcalls","clonedCounter","_storePath","pointedBy","_state","fromL","ptr","p","fromArr","arr","writeable","l","defaultComponent","_dec3","_class5","filterValid","pointerval","fromm","from0","from00","doArrayCheck","some","includes","PendingPointedByPaths","_dec4","_class6","_class7","action","pendingPointedBy","to","solveAttempts","stackTrace","getStackTrace","attemptimplementationdelete","pb","objectChain","followPath","attemptResolve","canBeResolved","resolve","all","parse","saveForLater","exDev","maxSolveAttempts","getSolveableActions","allClone","_dec5","_class8","_class9","getPath","lastIndexOf","getLastKey","getPathArr","split","field","NoAccessModifiersHere","modifier","remove","oldValue","casee","oldtarget","actionpath","add","newtargetptr","newtarget","list","_dec6","_class10","_class11","__serialize","inspect","__random","__info_of__id","__info_of___state","wrongAccessMessage","str","msg","get_toString","context","toPrimitive","get_toPrimitive","hint","cannotSet","get_id","set_id","_get_default","get_state","__shallowSolver","set_state","newState","changed","ee","__sanitizeValue","canEditVal","canEditValDeep","_defaultGetter","__defaultGetter","_defaultSetter","v0","__defaultSetter","solveArrayValues","solveObjectKeys","_ref","bytes","multiReplaceAll","EDate","EBoolean","EByte","EShort","EInt","ELong","EString","EChar","EVoid","EDouble","EFloat","Math","round","max","min","oldv","get__extends","set_pointedBy","dependencies","get_dependencies","proxyObject","raw","root","regex","replace","op","endsWith","dependency","delete","get_delete","child","_child$node","node","nodes","D","_dec7","_class12","L","_dec8","_class13","P","_dec9","_class14","WPointerTargetable","_dec10","_class15","fffff","bbb","bb2","_dec11","_class17","_class18","token","projects","__isUser","offlineMode","isStateMachine","_dec12","_class19","_class20","get_projects","LProject","set_projects","get_project","set_project","_dec13","_class21","_class22","author","collaborators","onlineUsers","graphs","otherProjects","regexp","matches","_regexp$exec","exec","maxnum","allProjectNames","objectFromArray","_dec14","_class23","_class24","attributes","references","operations","parameters","enumerators","objects","graphVertexes","voidVertexes","vertexes","fields","edgePoints","views","get_favorite","uid","set_favorite","favMap","get_name","set_name","get_author","set_author","get_collaborators","set_collaborators","get_onlineUsers","set_onlineUsers","get_metamodels","set_metamodels","get_models","set_models","get_graphs","set_graphs","get_views","duplicateRemover","varr","get_viewpoints","flatMap","allSubViews","set_views","set_viewpoints","get_activeViewpoint","set_activeViewpoint","get_packages","m","allSubPackages","get_classes","get_attributes","get_references","get_operations","get_parameters","get_enumerators","get_literals","get_objects","allSubObjects","get_values","allSubValues","get_allNodes","n","get_graphVertexes","get_voidVertexes","get_vertexes","get_fields","get_edges","g","get_edgePoints","get_children","duplicate","get_duplicate","clone","MyError","_dec15","_class25","message","proto","_len3","otherMsg","_key3","actualProto","setPrototypeOf","JsType","printableTypeName","check","isExclusiveType","isOnlyType","getTypes","isAnyOfTypes","_len4","acceptables","_key4","Uarr","arrayIntersection","stopIfTypeIsNot","isObject","returnIfNull","isFunction","isLambdaFunction","getFunctionSignatureFromComments","isLambda","isNonLambdaFunction","isSymbol","isBoolean","isNumber","isBigint","isString","isNull","isUndefined","isDate","asObject","fallbackReturn","asFunction","asLambdaFunction","asNonLambdaFunction","asArray","asSymbol","asBoolean","asNumber","asBigint","asString","asNull","asUndefined","asDate","object","function","array","date","lambdaFunction","nonLambdaFunction","symbol","null","boolean","number","bigint","string","invalidSuperClassError","scname","exDevv","MixinFakeConstructor","isMixinFakeConstructor","_c8","MixOnlyFuncs2","c1","c2","MixOnlyFuncs","_c9","MixOnlyFuncs3","_c10","c1noconstructor","c2noconstructor","disableconstructor","c1name","c2name","_c11","buildWrapSignature","maxdepth","onlyUnique","self","dep","depsorted","byLevels","loopdetecter","namelist","olddep","table","goalSignature","lparam","epsorted","signature","EGraphElements","EModelElements","ViewEClassMatch","NOT_EVALUATED_YET","MISMATCH","Number","NEGATIVE_INFINITY","MISMATCH_PRECONDITIONS","MISMATCH_JS","MISMATCH_OCL","IMPLICIT_MATCH","INHERITANCE_MATCH","EXACT_MATCH","VP_MISMATCH","VP_Default","VP_Decorative","VP_Explicit","NodeTransientProperties","viewSorted_modelused","viewSorted_pvid_used","viewSorted_nodeused","stackViews","validMainViews","mainView","viewScores","evalContext","needSorting","ViewTransientProperties","oclChanged","jsConditionChanged","oclUpdateCondition_PARSED","oclEngine","JSXFunction","UDFunction","constantsList","UDList","DataTransientProperties","modelElement","transient","$RefreshReg$"],"sources":["C:/d/Programming/web/jodel-mde/src/joiner/classes.ts"],"sourcesContent":["import {Mixin} from \"ts-mixer\";\r\nimport type {\r\n    DEdge,\r\n    DEdgePoint,\r\n    DExtEdge,\r\n    DGraph,\r\n    DGraphElement,\r\n    DGraphVertex,\r\n    DRefEdge,\r\n    DVertex,\r\n    DVoidEdge,\r\n    DVoidVertex,\r\n    LEdge,\r\n    LEdgePoint,\r\n    LExtEdge,\r\n    LGraphElement,\r\n    LGraphVertex,\r\n    LRefEdge,\r\n    LVertex,\r\n    LVoidEdge,\r\n    LVoidVertex,\r\n    WEdge,\r\n    WEdgePoint,\r\n    WExtEdge,\r\n    WGraph,\r\n    WGraphElement,\r\n    WGraphVertex,\r\n    WRefEdge,\r\n    WVertex,\r\n    WVoidEdge,\r\n    WVoidVertex\r\n} from \"../model/dataStructure\";\r\nimport type {Class, Longest} from \"ts-mixer/dist/types/types\";\r\nimport type {\r\n    DAnnotation,\r\n    DAttribute,\r\n    DClass,\r\n    DClassifier,\r\n    DDataType,\r\n    DEnumerator,\r\n    DEnumLiteral,\r\n    DMap,\r\n    DModel,\r\n    DModelElement,\r\n    DNamedElement,\r\n    DObject,\r\n    DOperation,\r\n    DPackage,\r\n    DParameter,\r\n    DReference,\r\n    DStructuralFeature,\r\n    DTypedElement,\r\n    DValue,\r\n    LAnnotation,\r\n    LAttribute,\r\n    LClass,\r\n    LClassifier,\r\n    LDataType,\r\n    LEnumerator,\r\n    LEnumLiteral,\r\n    LMap,\r\n    LModelElement,\r\n    LNamedElement,\r\n    LObject,\r\n    LOperation,\r\n    LPackage,\r\n    LParameter,\r\n    LReference,\r\n    LStructuralFeature,\r\n    LTypedElement,\r\n    LValue,\r\n    WAnnotation,\r\n    WAttribute,\r\n    WClass,\r\n    WClassifier,\r\n    WDataType,\r\n    WEnumerator,\r\n    WEnumLiteral,\r\n    WMap,\r\n    WModel,\r\n    WModelElement,\r\n    WNamedElement,\r\n    WObject,\r\n    WOperation,\r\n    WPackage,\r\n    WParameter,\r\n    WReference,\r\n    WStructuralFeature,\r\n    WTypedElement,\r\n    WValue\r\n} from \"../model/logicWrapper\";\r\nimport type {\r\n    CClass,\r\n    Constructor,\r\n    Dependency,\r\n    Dictionary,\r\n    DocString,\r\n    GObject,\r\n    // Info,\r\n    InitialVertexSize,\r\n    InitialVertexSizeFunc,\r\n    InitialVertexSizeObj,\r\n    orArr,\r\n    Proxyfied,\r\n    unArr\r\n} from \"./types\";\r\nimport {EdgeBendingMode, EdgeGapMode, NodeTypes, PrimitiveType} from \"./types\";\r\nimport type {\r\n    DViewElement,\r\n    DViewTransientProperties,\r\n    LViewTransientProperties,\r\n    WViewElement,\r\n    WViewTransientProperties\r\n} from \"../view/viewElement/view\";\r\nimport type {LogicContext} from \"./proxy\";\r\nimport {\r\n    Action,\r\n    BEGIN,\r\n    CreateElementAction,\r\n    Defaults,\r\n    DeleteElementAction,\r\n    DLog,\r\n    DState,\r\n    DViewPoint,\r\n    EdgeSegment,\r\n    END,\r\n    GraphPoint,\r\n    GraphSize,\r\n    LGraph,\r\n    LLog,\r\n    LModel,\r\n    Log,\r\n    LViewElement,\r\n    LViewPoint,\r\n    ParsedAction,\r\n    SetFieldAction,\r\n    SetRootFieldAction, ShortAttribETypes, statehistory,\r\n    store,\r\n    TRANSACTION,\r\n    U\r\n} from \"./index\";\r\nimport {OclEngine} from \"@stekoe/ocl.js\";\r\nimport {ReactNode} from \"react\";\r\nimport {ProjectsApi} from \"../api/persistance\";\r\n\r\nvar windoww = window as any;\r\n// qui dichiarazioni di tipi che non sono importabili con \"import type\", ma che devono essere davvero importate a run-time (eg. per fare un \"extend\", chiamare un costruttore o usare un metodo statico)\r\n\r\n\r\nconsole.warn('ts loading classes');\r\n\r\n\r\n// annotation @RuntimeAccessible\r\n// import {store} from \"../redux/createStore\";\r\n\r\nabstract class AbstractMixedClass {\r\n    // superclass!: Dictionary<DocString<'parent class name', Class>>;\r\n    static logic: typeof LPointerTargetable;\r\n    static structure: typeof DPointerTargetable;\r\n    static singleton: LPointerTargetable;\r\n    // static [key: string]: any;\r\n    static init_constructor(...constructorArguments: any): void{}\r\n}\r\n\r\nexport abstract class RuntimeAccessibleClass extends AbstractMixedClass {\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    //static extendTree: TreeModel.Node<typeof RuntimeAccessibleClass>// Tree<string, typeof RuntimeAccessibleClass>;\r\n    static extendMatrix: Dictionary<string, Dictionary<string, boolean>>;\r\n    // static name: never; // it breaks with minification, don't use it\r\n    static cname: string;\r\n    private static OCL_Constructors: Dictionary<Pointer<DModel>, Dictionary<DocString<\"DClass name\">, GObject<\"Fake constructors for ocl \\\"Context\\\"\">>> = {};\r\n\r\n    static set_extend(superclass: typeof RuntimeAccessibleClass, subclass: typeof RuntimeAccessibleClass): void{\r\n        if (!superclass.hasOwnProperty(\"subclasses\")) superclass.subclasses = [subclass];\r\n        else if (superclass.subclasses.indexOf(subclass) === -1) superclass.subclasses.push(subclass);\r\n        if (!subclass.hasOwnProperty(\"_extends\")) subclass._extends = [superclass];\r\n        else if (subclass._extends.indexOf(superclass) === -1) subclass._extends.push(superclass);\r\n    }\r\n\r\n    static extendPrototypes(){\r\n        (Array.prototype as any).contains = function (o:any): boolean{\r\n            return this.indexOf(o) !== -1;\r\n        };\r\n        (Array.prototype as any).joinOriginal = Array.prototype.join;\r\n        // @ts-ignore\r\n        Array.prototype.first = function(){ return this[0]; }\r\n        // @ts-ignore\r\n        eval(\"Array.prototype.last = function(){ return this[this.length-1]; }\");// without eval it still gives typescript error even with tsignore\r\n        // @ts-ignore\r\n        (Array.prototype as any).separator = function(...separators: any[]/*: orArr<(PrimitiveType | null | undefined | JSX.Element)[]>*/): (string|JSX.Element)[]{\r\n            if (Array.isArray(separators[0])) separators = separators[0]; // case .join([1,2,3])  --> .join(1, 2, 3)\r\n            // console.log(\"separators debug\", this, separators, this[0], typeof this[0]);\r\n            // if (typeof this[0] !== \"object\") return (this as any).joinOriginal(separators);\r\n            // if JSX\r\n            // it handles empty cells like it handles '', but this is how native .join() handles them too: [emptyx5, \"a\", emptyx1, \"b\"].join(\",\") ->  ,,,,,a,,b\r\n            let ret/*:JSX.Element[]*/ = [];\r\n            for (let i = 0; i < this.length; i++){\r\n                if (i === 0) {ret.push(this[i]); continue;}\r\n                ret.push(...separators);\r\n                ret.push(this[i]);\r\n            }\r\n            return ret;\r\n        }\r\n    }\r\n    static fixStatics() {\r\n        this.extendPrototypes();\r\n        for (let classs of Object.values(RuntimeAccessibleClass.annotatedClasses)) {\r\n            let gclass = classs as GObject;\r\n            for (let statickey in gclass.s) { gclass[statickey] = gclass.s[statickey]; }\r\n        }\r\n\r\n    }\r\n    // static allRuntimeClasses: string[] = [];\r\n    static classes: Dictionary<string, typeof RuntimeAccessibleClass> = {};\r\n    static annotatedClasses: Dictionary<string, typeof RuntimeAccessibleClass> = {};\r\n\r\n    static getAllNames(annotated = false): string[] {\r\n        return Object.keys(annotated ? RuntimeAccessibleClass.annotatedClasses : RuntimeAccessibleClass.classes); }\r\n    static getAllClasses(annotated = false): typeof RuntimeAccessibleClass[] {\r\n        return Object.values(annotated ? RuntimeAccessibleClass.annotatedClasses : RuntimeAccessibleClass.classes); }\r\n    static getAllClassesDictionary(annotated = false): Dictionary<string, typeof RuntimeAccessibleClass> {\r\n        return annotated ? RuntimeAccessibleClass.annotatedClasses : RuntimeAccessibleClass.classes; }\r\n\r\n    static wrapAll<D extends RuntimeAccessibleClass, L extends LPointerTargetable = LPointerTargetable, CAN_THROW extends boolean = false,\r\n        RET extends CAN_THROW extends true ? L[] : L[] = CAN_THROW extends true ? L[] : L[] >\r\n    (data: D[] | Pointer<DPointerTargetable, 0, 'N'>, baseObjInLookup?: DPointerTargetable, path: string = '', canThrow: CAN_THROW = false as CAN_THROW, state?: DState, filter:boolean=true): CAN_THROW extends true ? L[] : L[] {\r\n        if (!Array.isArray(data)) return [];\r\n        if (!data.length) return [];\r\n        if (!state) state = windoww.store.getState() as DState;\r\n        if (!filter) return data.map( d => DPointerTargetable.wrap(d, baseObjInLookup, path, canThrow, state)) as L[];\r\n        let ret = [];\r\n        for (let o of data) { if (o) ret.push( DPointerTargetable.wrap(o, baseObjInLookup, path, canThrow, state))}\r\n        return ret;\r\n    }\r\n\r\n    static wrap<D extends RuntimeAccessibleClass, L extends LPointerTargetable = LPointerTargetable, CAN_THROW extends boolean = false,\r\n        RET extends CAN_THROW extends true ? L : L | undefined = CAN_THROW extends true ? L : L | undefined>\r\n    (data: D | Pointer | undefined | null, baseObjInLookup?: DPointerTargetable, path: string = '', canThrow: CAN_THROW = false as CAN_THROW, state?: DState): CAN_THROW extends true ? L : L | undefined{\r\n        if (!data || (data as any).__isProxy) return data as any;\r\n        if (typeof data === 'string') {\r\n            data = DPointerTargetable.from(data, state) as D;\r\n            if (!data) {\r\n                windoww.Log.e(canThrow, 'Cannot wrap:', {data, baseObjInLookup, path});\r\n                return undefined as RET;\r\n            }\r\n        }\r\n        if (Array.isArray(data)) {\r\n            console.error('use WrapAll instead for arrays', {data, baseObjInLookup, path, canThrow});\r\n            if (canThrow) throw new Error(\"use WrapAll instead for arrays\");\r\n            else return undefined as any;\r\n        }\r\n        if (!data) return data;\r\n        // console.log('ProxyWrapping:', {data, baseObjInLookup, path});\r\n        return new Proxy(data, new windoww.TargetableProxyHandler(data, baseObjInLookup, path)) as L;\r\n    }\r\n\r\n    // if v can be wrapped, wrap it. otherwise return the parameter v.\r\n    public static attemptWrap(v: any, s?: DState): any{\r\n        let ret: any = undefined;\r\n        switch (typeof v){\r\n            case \"string\": s = store.getState(); ret = LPointerTargetable.fromPointer(v, s); break\r\n            case \"object\":\r\n                if(v.__isProxy) return v;\r\n                if (v.className) {\r\n                    if (!RuntimeAccessibleClass.get(v?.className)?.logic?.singleton) break;\r\n                    ret = LPointerTargetable.fromD(v);\r\n                }\r\n                break;\r\n            default: break;\r\n        }\r\n        return ret || v;\r\n    }\r\n    /*\r\n        static mapWrap2<D extends DPointerTargetable, L extends LPointerTargetable>(map: RuntimeAccessibleClass, container: D, baseObjInLookup?: DPointerTargetable, path: string = ''): L{\r\n            if (!map || (map as any).__isProxy) return map as any;\r\n            if (typeof container === 'string') {\r\n                container = store.getState().idlookup[container] as unknown as D;\r\n                if (!container) { return Log.exx('Cannot wrap map:', {map, container, baseObjInLookup, path}); }\r\n            }\r\n            // console.log('ProxyWrapping:', {data, baseObjInLookup, path});\r\n            return new Proxy(map, new MapProxyHandler(map, baseObjInLookup, path));\r\n        }\r\n\r\n    */\r\n\r\n    static mapWrap(data: Dictionary, baseObjInLookup: DPointerTargetable, path: string, subMapKeys: string[] = []): Proxyfied<Dictionary> {\r\n        if (!data || (data as any).__isProxy) return data as any;\r\n        // console.error('GETMAP', {data, logicContext, path});\r\n        return new Proxy(data, new windoww.MapProxyHandler(data, baseObjInLookup, path));\r\n    }\r\n\r\n    className!: string;\r\n    protected constructor(...a:any) {\r\n        super();\r\n        // RuntimeAccessibleClass.init_constructor(this, ...a);\r\n        // this.className = this.constructor.name;\r\n        // nb: per i mixin questo settaggio viene sovrascritto. perch√® il mixin crea le 2 classi ereditate separatamente con i loro costruttori e le incrocia. quindi devo settarlo dall'annotazione @ tramite prototype\r\n        // RuntimeAccessibleClass.allRuntimeClasses.push(this.className);\r\n    }\r\n\r\n    static init_constructor(thiss: any, ...args: any): void {\r\n\r\n        // this.className = this.constructor.name;\r\n        // let finalObject = this;\r\n        // if (finalObject.constructor.name === \"DVoidVertex\" || finalObject.constructor.name === \"DGraphElement\") { let breakp = true; }\r\n        // this.init0(...arguments);\r\n        // thiss.className = this.name;\r\n    }\r\n\r\n    public static get<T extends typeof RuntimeAccessibleClass = typeof RuntimeAccessibleClass>(dclassname: string, mode?: string )\r\n        : T & {logic?: typeof LPointerTargetable} {\r\n\r\n        // believe it or not there are actually 3 different versions generated, with different static method contexts, it's a mess.\r\n        return this.classes[dclassname] as any;\r\n        /*\r\n        switch(mode) {\r\n            case \"annotated version\":\r\n                /* it is like this in console\r\n                () {\r\n                    var _obj$initBase;\r\n                    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\r\n                ...* /\r\n                return RuntimeAccessibleClass.annotatedClasses[dclassname] as any;\r\n            case \"local definition version\":\r\n            default: // same as window.classname\r\n            case \"module export version\":\r\n                /* it was like this in console, it is not anymore after reworking cname\r\n                // don't know how to get it now, but default version should be always the correct one,\r\n                    class DClassifier extends _joiner__WEBPACK_IMPORTED_MODULE_0__[\"DPointerTargetable\"]\r\n                which is even wrong as i asked for DPointerTargetable and not DClassifier. * /\r\n            return null as any;\r\n        }*/\r\n    }\r\n\r\n    public static extends(className?: string | typeof RuntimeAccessibleClass, superClassName?: string| typeof RuntimeAccessibleClass, returnIfEqual: boolean = true): boolean {\r\n        if (!className || !superClassName) return false;\r\n        const superclass = typeof superClassName === \"string\" ? RuntimeAccessibleClass.get(superClassName) : superClassName;\r\n        const thisclass = typeof className === \"string\" ? RuntimeAccessibleClass.get(className) : className;\r\n        if (!superclass || !thisclass) return false;\r\n        //console.trace(\"extends.1:\", {thisclass, superclass});\r\n        // console.log(\"extends.2:\", {iof:(thisclass instanceof superclass),\r\n        //     tree: !!(RuntimeAccessibleClass.extendTree.first((node) => node.model === superclass)?.first((node) => node.model === thisclass))});\r\n        if (superclass === thisclass) return returnIfEqual;\r\n        // for (let aaa in RuntimeAccessibleClass.extendTree.find(superClassName)) { }\r\n\r\n        return (thisclass instanceof superclass)\r\n            || RuntimeAccessibleClass.extendMatrix[superclass.cname]?.[thisclass.cname]\r\n        // !!(RuntimeAccessibleClass.extendTree.first((node) => node.model === superclass)?.first((node) => node.model === thisclass))\r\n        // || true;\r\n    }\r\n\r\n    getAllPrototypeSuperClasses(): GObject[] {\r\n        let currentlevel = this;\r\n        let ret: GObject[] = [];\r\n        while (true) {\r\n            if (!currentlevel) break;\r\n            ret.push(currentlevel);\r\n            // @ts-ignore\r\n            currentlevel = currentlevel.__proto__;\r\n        }\r\n        console.log('constructor chain:', ret);\r\n        return ret;\r\n    }\r\n    /*initBase(){\r\n        let superclasses = this.getAllPrototypeSuperClasses();\r\n        for (let sc of superclasses) {\r\n            if (!sc.hasOwnProperty('init0')) continue;\r\n            console.log('initbase calling ', {thiss: this, sc, init0: sc.init0, args:sc.constructorArguments});\r\n            sc.init0.apply(this, ...(sc.constructorArguments || []));\r\n        }\r\n    }*/\r\n    // protected abstract init(...constructorParameters: any): void;\r\n    // NB: per colpa della limitazione #3 di ts-mixer,\r\n    // DEVO chiamare init su ogni oggetto per settargli il corretto this.className, altrimenti prende quello dell'ultima superclasse\r\n    /*protected init0(...constructorParameters: any): void {\r\n        let a = this;\r\n        let finalObject = this;\r\n        console.log('creation of___ ', {thiss: this, finalObject});\r\n        if (finalObject.constructor.name === \"DVoidVertex\" || finalObject.constructor.name === \"DGraphElement\") {\r\n            let breakp = true; }\r\n\r\n        (window as any)[finalObject.constructor.name] =\r\n            RuntimeAccessibleClass.classes[finalObject.constructor.name] = finalObject.constructor as any;\r\n        // @ts-ignore\r\n        // delete this.className;\r\n        this.className = (finalObject as any).__proto__.className;\r\n    }*/\r\n\r\n    static makeOCLConstructor(data: DClass, state: DState, oldState: DState): GObject<\"fake constructor of m2-class for ocl's Context\"> {\r\n        let rootModel: DModel = data as any;\r\n        while (rootModel && rootModel.className !== \"DModel\") rootModel = DPointerTargetable.fromPointer(rootModel.father, state);\r\n        let mid: Pointer<DModel> = rootModel?.id; // NB: for EBoolean etc, primitive type meteclasses don't have a model;\r\n        if (!RuntimeAccessibleClass.OCL_Constructors[mid]) {\r\n            RuntimeAccessibleClass.OCL_Constructors[mid] = {...RuntimeAccessibleClass.classes};\r\n        }\r\n        const OclConstructor: GObject = data;\r\n        let namefixed: string;\r\n\r\n        if (oldState && oldState.idlookup[data.id]) {\r\n            let oldname = (oldState.idlookup[data.id] as DClass).name;\r\n            namefixed = U.replaceAll(U.replaceAll(oldname, '-', '_'), ' ', '_');\r\n            delete RuntimeAccessibleClass.OCL_Constructors[mid][oldname];\r\n            delete RuntimeAccessibleClass.OCL_Constructors[mid][namefixed];\r\n\r\n        }\r\n        namefixed = U.replaceAll(U.replaceAll(data.name, '-', '_'), ' ', '_');\r\n        RuntimeAccessibleClass.OCL_Constructors[mid][data.name] = OclConstructor;\r\n        RuntimeAccessibleClass.OCL_Constructors[mid][namefixed] = OclConstructor;\r\n\r\n        return data;\r\n    }\r\n\r\n    static getOCLClasses(model_id: Pointer<DModel>): GObject {\r\n        // return { ...(RuntimeAccessibleClass.OCL_Constructors[model_id] || {}), ...RuntimeAccessibleClass.classes}\r\n        return RuntimeAccessibleClass.OCL_Constructors[model_id] || RuntimeAccessibleClass.classes;\r\n    }\r\n}\r\nexport function Obsolete<T extends any>( constructor: T & GObject): T { return constructor; }\r\nexport function Leaf<T extends any>( constructor: T & GObject): T { return constructor; }\r\nexport function Node<T extends any>( constructor: T & GObject): T { return constructor; }\r\nexport function Abstract<T extends any>( constructor: T & GObject): T { return constructor; }\r\nexport function Instantiable<T extends any>(constructor: T & GObject, instanceConstructor?: Constructor): T { return constructor; } // for m2 cklasses that have m1 instances\r\n// export function RuntimeAccessible<T extends any>(cname: string): ((constructor: T & GObject) => T) {\r\nexport function RuntimeAccessible(cname: string) {\r\n    return (ctor: any) => RuntimeAccessible_inner(ctor, cname);\r\n}\r\n\r\nfunction RuntimeAccessible_inner<T extends any>(constructor: T & GObject, cname: string): T {\r\n    // console.log('DecoratorTest', {constructor, arguments});\r\n    (constructor as GObject).cname = cname;\r\n    if (!constructor.hasOwnProperty(\"subclasses\")) (constructor as GObject).subclasses = [];\r\n    // @ts-ignore\r\n    RuntimeAccessibleClass.classes[constructor.cname] = constructor as any as typeof RuntimeAccessibleClass;\r\n    // console.log(\"setting runtime accessible\", {key: constructor.cname, constructor, pre: predebug, post: {...RuntimeAccessibleClass.classes}});\r\n    if (!windoww[constructor.cname]) (windoww[constructor.cname] as any) = constructor;\r\n    constructor.prototype.className = constructor.cname;\r\n    //constructor.prototype.$$typeof = constructor.cname;\r\n    //constructor.prototype.typeName = constructor.cname;\r\n    (constructor as any).staticClassName = constructor.cname;\r\n    // @ts-ignore\r\n    // console.log('runtimeaccessible annotation:', {thiss:this, constructor});\r\n    //    const classnameFixedConstructor = constructor; //  function (...args) { let obj = new constructor(...args); obj.init?.(); obj.init0?.(); return obj; }\r\n\r\n    // @ts-ignore\r\n    let outerthis = this;\r\n    // @ts-ignore\r\n    const classnameFixedConstructorDoNotRenameWithoutSearchStrings = function (...args) {\r\n        // @ts-ignore\r\n        // console.log('runtimeaccessible annotation inner:', {thiss:this, outerthis, constructor});\r\n        // @ts-ignore\r\n        let obj = new constructor(...args);\r\n        obj.classNameFromAnnotation = constructor.cname;\r\n        obj.className = constructor.cname;\r\n        //obj.prototype.$$typeof = constructor.name;\r\n        // obj.prototype.typeName = constructor.name;\r\n        // obj.init?.();\r\n        // obj.init0?.();\r\n        obj.initBase?.();\r\n        // @ts-ignore\r\n        // console.log('runtimeaccessible annotation inner end:', {thiss:this, outerthis, constructor, obj});\r\n        return obj; }\r\n    RuntimeAccessibleClass.annotatedClasses[constructor.cname] = classnameFixedConstructorDoNotRenameWithoutSearchStrings as any as typeof RuntimeAccessibleClass;\r\n\r\n    for (let key in constructor) (classnameFixedConstructorDoNotRenameWithoutSearchStrings as GObject)[key] = constructor[key];\r\n    // constructor.constructor = classnameFixedConstructorDoNotRenameWithoutSearchStrings; return constructor;\r\n\r\n    // @ts-ignore\r\n    // for (let staticKey of constructor as GObject) { classnameFixedConstructorDoNotRenameWithoutSearchStrings[staticKey] = constructor[staticKey]; }\r\n    classnameFixedConstructorDoNotRenameWithoutSearchStrings.prototype = constructor.prototype;\r\n    classnameFixedConstructorDoNotRenameWithoutSearchStrings.prototype.constructor = constructor.prototype.constructor;\r\n\r\n    // required for inheriting static methods\r\n    classnameFixedConstructorDoNotRenameWithoutSearchStrings.__proto__ = constructor.__proto__;\r\n    classnameFixedConstructorDoNotRenameWithoutSearchStrings.s = constructor;\r\n    // return classnameFixedConstructorDoNotRenameWithoutSearchStrings as any;\r\n    return constructor;\r\n}\r\n\r\n\r\n(window as any).RuntimeAccessibleClass = RuntimeAccessibleClass;\r\n// todo: problema: per creare un PointerTargetable ho bisogno dell'userid, e devo generarlo prima che venga generato l'initialState... dovrebbe venir servito con la pagina dal server. o passato come navigation props dalla pagina di login\r\n\r\n\r\n\r\nexport type DtoL<DX extends GObject, LX =\r\n    DX extends DEnumerator ? LEnumerator : (DX extends DAttribute ? LAttribute : (DX extends DReference ? LReference : (DX extends DRefEdge ? LRefEdge : (DX extends DExtEdge ? LExtEdge : (DX extends DDataType ? LDataType : (DX extends DClass ? LClass : (DX extends DStructuralFeature ? LStructuralFeature : (DX extends DParameter ? LParameter : (DX extends DOperation ? LOperation : (DX extends DEdge ? LEdge : (DX extends DEdgePoint ? LEdgePoint : (DX extends DGraphVertex ? LGraphVertex : (DX extends DModel ? LModel : (DX extends DValue ? LValue : (DX extends DObject ? LObject : (DX extends DEnumLiteral ? LEnumLiteral : (DX extends DPackage ? LPackage : (DX extends DClassifier ? LClassifier : (DX extends DTypedElement ? LTypedElement : (DX extends DVertex ? LVertex : (DX extends DVoidEdge ? LVoidEdge : (DX extends DVoidVertex ? LVoidVertex : (DX extends DGraph ? LGraph : (DX extends DNamedElement ? LNamedElement : (DX extends DAnnotation ? LAnnotation : (DX extends DGraphElement ? LGraphElement : (DX extends DMap ? LMap : (DX extends DModelElement ? LModelElement : (DX extends DUser ? LUser : (DX extends DPointerTargetable ? LPointerTargetable :\r\n        (DX extends DUser ? LUser : (DX extends DLog ? LLog : (ERROR)))\r\n        ))))))))))))))))))))))))))))))> = LX;\r\nexport type DtoW<DX extends GObject, WX = DX extends DEnumerator ? WEnumerator : (DX extends DAttribute ? WAttribute : (DX extends DReference ? WReference : (DX extends DRefEdge ? WRefEdge : (DX extends DExtEdge ? WExtEdge : (DX extends DDataType ? WDataType : (DX extends DClass ? WClass : (DX extends DStructuralFeature ? WStructuralFeature : (DX extends DParameter ? WParameter : (DX extends DOperation ? WOperation : (DX extends DEdge ? WEdge : (DX extends DEdgePoint ? WEdgePoint : (DX extends DGraphVertex ? WGraphVertex : (DX extends DModel ? WModel : (DX extends DValue ? WValue : (DX extends DObject ? WObject : (DX extends DEnumLiteral ? WEnumLiteral : (DX extends DPackage ? WPackage : (DX extends DClassifier ? WClassifier : (DX extends DTypedElement ? WTypedElement : (DX extends DVertex ? WVertex : (DX extends DVoidEdge ? WVoidEdge : (DX extends DVoidVertex ? WVoidVertex : (DX extends DGraph ? WGraph : (DX extends DNamedElement ? WNamedElement : (DX extends DAnnotation ? WAnnotation : (DX extends DGraphElement ? WGraphElement : (DX extends DMap ? WMap : (DX extends DModelElement ? WModelElement : (DX extends DUser ? WUser : (DX extends DPointerTargetable ? WPointerTargetable : (ERROR)))))))))))))))))))))))))))))))> = WX;\r\n// export type DtoW<DX extends GObject, WX = Omit<DtoW0<DX>, 'id'>> = WX;\r\nexport type LtoD<LX extends LPointerTargetable, DX = LX extends LEnumerator ? DEnumerator : (LX extends LAttribute ? DAttribute : (LX extends LReference ? DReference : (LX extends LRefEdge ? DRefEdge : (LX extends LExtEdge ? DExtEdge : (LX extends LDataType ? DDataType : (LX extends LClass ? DClass : (LX extends LStructuralFeature ? DStructuralFeature : (LX extends LParameter ? DParameter : (LX extends LOperation ? DOperation : (LX extends LEdge ? DEdge : (LX extends LEdgePoint ? DEdgePoint : (LX extends LGraphVertex ? DGraphVertex : (LX extends LModel ? DModel : (LX extends LValue ? DValue : (LX extends LObject ? DObject : (LX extends LEnumLiteral ? DEnumLiteral : (LX extends LPackage ? DPackage : (LX extends LClassifier ? DClassifier : (LX extends LTypedElement ? DTypedElement : (LX extends LVertex ? DVertex : (LX extends LVoidEdge ? DVoidEdge : (LX extends LVoidVertex ? DVoidVertex : (LX extends LGraph ? DGraph : (LX extends LNamedElement ? DNamedElement : (LX extends LAnnotation ? DAnnotation : (LX extends LGraphElement ? DGraphElement : (LX extends LMap ? DMap : (LX extends LModelElement ? DModelElement : (LX extends LUser ? DUser : (LX extends LPointerTargetable ? DPointerTargetable : (ERROR)))))))))))))))))))))))))))))))> = DX;\r\nexport type LtoW<LX extends LPointerTargetable, WX = LX extends LEnumerator ? WEnumerator : (LX extends LAttribute ? WAttribute : (LX extends LReference ? WReference : (LX extends LRefEdge ? WRefEdge : (LX extends LExtEdge ? WExtEdge : (LX extends LDataType ? WDataType : (LX extends LClass ? WClass : (LX extends LStructuralFeature ? WStructuralFeature : (LX extends LParameter ? WParameter : (LX extends LOperation ? WOperation : (LX extends LEdge ? WEdge : (LX extends LEdgePoint ? WEdgePoint : (LX extends LGraphVertex ? WGraphVertex : (LX extends LModel ? WModel : (LX extends LValue ? WValue : (LX extends LObject ? WObject : (LX extends LEnumLiteral ? WEnumLiteral : (LX extends LPackage ? WPackage : (LX extends LClassifier ? WClassifier : (LX extends LTypedElement ? WTypedElement : (LX extends LVertex ? WVertex : (LX extends LVoidEdge ? WVoidEdge : (LX extends LVoidVertex ? WVoidVertex : (LX extends LGraph ? WGraph : (LX extends LNamedElement ? WNamedElement : (LX extends LAnnotation ? WAnnotation : (LX extends LGraphElement ? WGraphElement : (LX extends LMap ? WMap : (LX extends LModelElement ? WModelElement : (LX extends LUser ? WUser : (LX extends LPointerTargetable ? WPointerTargetable : (ERROR)))))))))))))))))))))))))))))))> = WX;\r\nexport type WtoD<IN extends WPointerTargetable, OUT = IN extends WEnumerator ? DEnumerator : (IN extends WAttribute ? DAttribute : (IN extends WReference ? DReference : (IN extends WRefEdge ? DRefEdge : (IN extends WExtEdge ? DExtEdge : (IN extends WDataType ? DDataType : (IN extends WClass ? DClass : (IN extends WStructuralFeature ? DStructuralFeature : (IN extends WParameter ? DParameter : (IN extends WOperation ? DOperation : (IN extends WEdge ? DEdge : (IN extends WEdgePoint ? DEdgePoint : (IN extends WGraphVertex ? DGraphVertex : (IN extends WModel ? DModel : (IN extends WValue ? DValue : (IN extends WObject ? DObject : (IN extends WEnumLiteral ? DEnumLiteral : (IN extends WPackage ? DPackage : (IN extends WClassifier ? DClassifier : (IN extends WTypedElement ? DTypedElement : (IN extends WVertex ? DVertex : (IN extends WVoidEdge ? DVoidEdge : (IN extends WVoidVertex ? DVoidVertex : (IN extends WGraph ? DGraph : (IN extends WNamedElement ? DNamedElement : (IN extends WAnnotation ? DAnnotation : (IN extends WGraphElement ? DGraphElement : (IN extends WMap ? DMap : (IN extends WModelElement ? DModelElement : (IN extends WUser ? DUser : (IN extends WPointerTargetable ? DPointerTargetable : (IN extends WViewElement ? DViewElement : (IN extends WViewTransientProperties ? DViewTransientProperties : (ERROR)))))))))))))))))))))))))))))))))> = OUT;\r\nexport type WtoL<IN extends WPointerTargetable, OUT = IN extends WEnumerator ? LEnumerator : (IN extends WAttribute ? LAttribute : (IN extends WReference ? LReference : (IN extends WRefEdge ? LRefEdge : (IN extends WExtEdge ? LExtEdge : (IN extends WDataType ? LDataType : (IN extends WClass ? LClass : (IN extends WStructuralFeature ? LStructuralFeature : (IN extends WParameter ? LParameter : (IN extends WOperation ? LOperation : (IN extends WEdge ? LEdge : (IN extends WEdgePoint ? LEdgePoint : (IN extends WGraphVertex ? LGraphVertex : (IN extends WModel ? LModel : (IN extends WValue ? LValue : (IN extends WObject ? LObject : (IN extends WEnumLiteral ? LEnumLiteral : (IN extends WPackage ? LPackage : (IN extends WClassifier ? LClassifier : (IN extends WTypedElement ? LTypedElement : (IN extends WVertex ? LVertex : (IN extends WVoidEdge ? LVoidEdge : (IN extends WVoidVertex ? LVoidVertex : (IN extends WGraph ? LGraph : (IN extends WNamedElement ? LNamedElement : (IN extends WAnnotation ? LAnnotation : (IN extends WGraphElement ? LGraphElement : (IN extends WMap ? LMap : (IN extends WModelElement ? LModelElement : (IN extends WUser ? LUser : (IN extends WPointerTargetable ? LPointerTargetable : (IN extends WViewElement ? LViewElement : (IN extends WViewTransientProperties ? LViewTransientProperties : (ERROR)))))))))))))))))))))))))))))))))> = OUT;\r\nexport type labelfunc = (e:LVoidEdge, segment: EdgeSegment, allNodes: LEdge[\"allNodes\"], allSegments: EdgeSegment[]) => PrimitiveType;\r\nexport enum CoordinateMode {\r\n    \"absolute\"              = \"absolute\",\r\n    \"relativePercent\"       = \"relative%\",\r\n    \"relativeOffset\"        = \"relativeOffset\",\r\n    \"relativeOffsetStart\"   = \"relativeOffsetStart\",\r\n    \"relativeOffsetEnd\"     = \"relativeOffsetEnd\",\r\n}\r\n\r\nexport type EPSize = GraphSize & {currentCoordType: CoordinateMode};\r\nexport enum EdgeHead {\r\n    composition = \"Composition\",\r\n    aggregation = \"Aggregation\",\r\n    reference   = \"Association\",\r\n    extend      = \"Extension\"\r\n}\r\n\r\n\r\n\r\nlet canFireActions: boolean = true;\r\n@RuntimeAccessible('Constructors')\r\nexport class Constructors<T extends DPointerTargetable = DPointerTargetable>{\r\n    public static paused: boolean = false;\r\n    private thiss: T;\r\n    private persist: boolean;\r\n    // private callbacks: Function[];\r\n    private nonPersistentCallbacks: Function[];\r\n    fatherType?: typeof RuntimeAccessibleClass;\r\n    private fatherPtr?: Pointer // T['father'];\r\n    private state?: DState; // set only if requested by setWithSideEffect\r\n    /*\r\n    problem: if isPersistent is set to false, but the object is later made persistent with an action, you lose all the callback effects afecting other elements (as setting opposite relations like instances-typeof or losing pointedBy's)\r\n    solution 1: store in the D-object a function executing the callbacks called by CreateNewElement action, then delete that field before persisting.\r\n    continued: instead of setting the pointedBy's this way (and increasing clonedcounter for nothing) erase all PointedBy mentionings here, and make all pointer values assigned separately with a SetAction,' +\r\n    '         if new2 is used that set manually a d-field, set it to undefined in the in the .end() part, then trigger the setaction with correct value.\r\n    continued: sort actions by path, but always make sure CreateElement are first in the sort regardless of path. make also sure 2 actions with the same path keep the order they are launched/created (oldest first)\r\n    */\r\n    constructor(t:T, father?: Pointer, persist: boolean = true, fatherType?: Constructor, id?: string, isUser:boolean = false) {\r\n        persist = persist && canFireActions;\r\n        this.thiss = t;\r\n        this.setID(id, isUser);\r\n        // the same thing is done in reducer/createelementaction, but if the object is destructured before then, it will lose the constructor and reducer will fail to assign classname\r\n        t.className = t.className || (t.constructor as typeof RuntimeAccessibleClass).cname || t.constructor.name;\r\n        DPointerTargetable.pendingCreation[t.id] = t;\r\n        this.persist = persist;\r\n        t._persistCallbacks = [];\r\n        t._derivedSubElements = [];\r\n        this.nonPersistentCallbacks = [];\r\n        this.fatherPtr = father;\r\n\r\n        if (this.thiss.hasOwnProperty(\"father\")) {\r\n            this.fatherType = fatherType as any;\r\n            this.setPtr(\"father\", father);\r\n        }\r\n    }\r\n\r\n    static makeID(isUser:boolean=false): Pointer { return \"Pointer\" + new Date().getTime() + \"_\" + (isUser ? DUser.current : 'USER') + \"_\" + (DPointerTargetable.maxID++) }\r\n    private setID(id?: string, isUser:boolean = false){\r\n        this.thiss.id = id || Constructors.makeID(isUser);\r\n    }\r\n\r\n    // cannot use Lobjects as they will set PointedBy in persistent state, also might access an incomplete version of the object crashing\r\n    private setPtr(property: string, value: any, checkPointerValidity?: DState) {\r\n        (this.thiss as GObject)[property] = value;\r\n        if (!value) return;\r\n        if (Array.isArray(value)) for (let v of value) {\r\n            if (!value) continue;\r\n            if (typeof v === \"object\") v = v.id;\r\n            if (!v || checkPointerValidity && !Pointers.isPointer(v, checkPointerValidity)) continue;\r\n            this.thiss._persistCallbacks.push(SetFieldAction.create(v, \"pointedBy\", PointedBy.fromID(this.thiss.id, property as any), '+='));\r\n        }\r\n        else {\r\n            if (typeof value === \"object\") value = value.id;\r\n            value && this.thiss._persistCallbacks.push(SetFieldAction.create(value, \"pointedBy\", PointedBy.fromID(this.thiss.id, property as any), '+='));\r\n        }\r\n        // todo: in delete if the element was not persistent, just do nothing.\r\n    }\r\n\r\n    private setExternalRootProperty<D extends DPointerTargetable>(path: string, val: any, accessModifier: \"[]\" | \"+=\" | \"\", isPointer: boolean): this {\r\n        this.thiss._persistCallbacks.push(SetRootFieldAction.create(path, val, accessModifier, isPointer));\r\n        return this;\r\n    }\r\n\r\n    private setExternalPtr<D extends DPointerTargetable>(target: D | Pointer<any>, property: string, accessModifier: \"[]\" | \"+=\" | \"\" = \"\", val?: any): this {\r\n        if (!target) return this;\r\n        if (typeof target === \"object\") target = target.id;\r\n        if (!val) val = this.thiss.id;\r\n        this.thiss._persistCallbacks.push(SetFieldAction.create(target, property, val, accessModifier, true));\r\n        return this;\r\n        // PointedBy is set by reducer directly in this case.\r\n        // this.thiss._persistCallbacks.push(SetFieldAction.create(this.thiss.id, \"pointedBy\", PointedBy.fromID(target, property as any), '+='));\r\n    }\r\n\r\n    private setWithSideEffect<D extends DPointerTargetable>(property: string, val: any): this {\r\n        if (!val) return this;\r\n        if (!this.state) this.state = store.getState();\r\n        if (typeof val === \"object\") val = val.id;\r\n        this.thiss._persistCallbacks.push( () => {\r\n            (LPointerTargetable.from(this.thiss, this.state) as GObject<\"L\">)[property] = val;\r\n        });\r\n        return this;\r\n    }\r\n\r\n    //static pause(): void { canFireActions = false; }\r\n    //static resume(): void { canFireActions = true; }\r\n    static persist(d: DPointerTargetable, fromCreateAction?: boolean): void;\r\n    static persist(d: DPointerTargetable[]): void;\r\n    static persist(d: orArr<DPointerTargetable>, fromCreateAction?: boolean): void {\r\n        if (Constructors.paused) return;\r\n        TRANSACTION(()=> {\r\n            if (!Array.isArray(d)) d = [d];\r\n            // first create \"this\"\r\n            for (let e of d) {\r\n                let subElements = e._derivedSubElements;\r\n                let callbacks = e._persistCallbacks;\r\n                delete (e as Partial<DPointerTargetable>)._derivedSubElements;\r\n                delete (e as Partial<DPointerTargetable>)._persistCallbacks;\r\n                // then create subelements (object -> values) and fire their actions.\r\n                if (!fromCreateAction) CreateElementAction.new(e, false);\r\n                for (let c of subElements) Constructors.persist([c]);\r\n                // finally fire the actions for \"this\"\r\n                for (let c of callbacks) (c as Action).fire ? (c as Action).fire() : (c as () => void)();\r\n                SetRootFieldAction.new('ELEMENT_CREATED', e.id, '+=', false); // here no need to IsPointer because it only affects Transient stuff\r\n            }\r\n        })\r\n    }\r\n    // start(thiss: any): this { this.thiss = thiss; return this; }\r\n    end(simpledatacallback?: (d:T, c: this) => void): T {\r\n        if (simpledatacallback) simpledatacallback(this.thiss, this); // callback for setting primitive types, not pointers not context-dependant values (name being potentially invalid / chosen according to parent)\r\n        if (this.nonPersistentCallbacks.length) {\r\n            for (let cb of this.nonPersistentCallbacks) cb();\r\n        }\r\n        if (!this.persist) return this.thiss;\r\n        Constructors.persist(this.thiss);\r\n        /// todo: warning: there is a transaction at .persist method, do not use BEGIN+END/TRANSACTION inside\r\n\r\n        return this.thiss; }\r\n\r\n\r\n    DState(): this {\r\n        let thiss: DState = this.thiss as any;\r\n        thiss.debug = !!localStorage.getItem('debug');\r\n        return this;\r\n    }\r\n\r\n    DModelElement(): this { return this; }\r\n    DClassifier(): this { return this; }\r\n    DParameter(defaultValue?: any): this {\r\n        let thiss: DParameter = this.thiss as any;\r\n        thiss.defaultValue = defaultValue;\r\n        this.setExternalPtr(thiss.father, \"parameters\", \"+=\");\r\n        return this; }\r\n    DStructuralFeature(): this {\r\n        if (this.thiss.className === 'DOperation') return this;\r\n        // if (!this.persist) return this;\r\n        let thiss: DAttribute|DReference = this.thiss as any;\r\n        const _DClass: typeof DClass = windoww.DClass;\r\n        const _DValue: typeof DValue = windoww.DValue;\r\n\r\n\r\n        let targets: DClass[] = [(_DClass as typeof DPointerTargetable).from(thiss.father, this.state)];\r\n        let alreadyParsed: Dictionary<Pointer, DClass> = {};\r\n        /*\r\n        todo: build a Tree<DClass> of all superclasses tree nested by level.\r\n            only then instantiate DValues by depth level, if same level from right to left (last extend on right takes priority) and erase this stuff below.*/\r\n        // let superClassesByLevel: Dictionary<Pointer, DClass> = ;\r\n        while(targets.length) { // gather superclasses in map \"alreadyParsed\"\r\n            let nextTargets = [];\r\n            for (let target of targets) {\r\n                if (!target) { Log.ww(\"Invalid father pointer in DStructuralFeature\", {feature: thiss, father:target, superclasses: alreadyParsed}); continue; }\r\n                if (alreadyParsed[target.id]) continue;\r\n                alreadyParsed[target.id] = target;\r\n                for(let ext of target.extendedBy) nextTargets.push((_DClass as typeof DPointerTargetable).from(ext));\r\n            }\r\n            targets = nextTargets;\r\n        }\r\n        //(thiss as DPointerTargetable)._persistCallbacks.push(()=>{\r\n        // When a feature is added in m2, i loop instanced m1 objects to add that feature as a DValue.\r\n        for (let pointer in alreadyParsed) {\r\n            for (let instanceObjPtr of alreadyParsed[pointer].instances) {\r\n                // this._derivedSubElements.push(_DValue.new(thiss.name, thiss.id, undefined, instanceObjPtr));\r\n                thiss._derivedSubElements.push(_DValue.new3({name: undefined, instanceof: thiss.id, father: instanceObjPtr}, undefined, false));\r\n            }\r\n            //}\r\n        }\r\n\r\n\r\n        return this;\r\n    }\r\n    DReference(): this {\r\n        let thiss: DReference = this.thiss as any;\r\n        this.setExternalPtr(thiss.father, \"references\", \"+=\");\r\n        return this; }\r\n\r\n    DAttribute(): this {\r\n        let thiss: DAttribute = this.thiss as any;\r\n        this.setExternalPtr(thiss.father, \"attributes\", \"+=\");\r\n        return this; }\r\n\r\n    DDataType(): this { return this; }\r\n\r\n    DObject(instanceoff?: DObject[\"instanceof\"]): this {\r\n        let thiss: DObject = this.thiss as any;\r\n        if (thiss.father) {\r\n            if (this.fatherType!.cname === \"DModel\") {\r\n                this.setExternalPtr(thiss.father, \"objects\", \"+=\");\r\n            }\r\n            else {\r\n                // object containing object is not in any direct child collection. access through values\r\n                this.setExternalPtr(thiss.father, \"values\", \"+=\");\r\n            }\r\n        }\r\n        instanceoff && this.setWithSideEffect( \"instanceof\", instanceoff);\r\n        return this; }\r\n\r\n    DValue(instanceoff?: DValue[\"instanceof\"], val?: DValue[\"values\"], isMirage?: DValue[\"isMirage\"]): this {\r\n        let thiss: DValue = this.thiss as any; thiss.edges = [];\r\n        // thiss.values = val || [];\r\n        thiss.instanceof = instanceoff;\r\n        thiss.isMirage = isMirage || false;\r\n        if (val === undefined) val = [];\r\n        else if(!Array.isArray(val)) val = [val];\r\n        thiss.values = [];// because reducer calculating newly added pointedby must find something to start comparison\r\n        this.setPtr(\"values\", val, this.state);\r\n\r\n        // update father's collections (pointedby's here are set automatically)\r\n        if (instanceoff) {\r\n            this.setPtr(\"instanceof\", instanceoff);\r\n            this.setExternalPtr(instanceoff, \"instances\", \"+=\");\r\n        }\r\n        this.setExternalPtr(thiss.father, \"features\", \"+=\");\r\n        return this; }\r\n\r\n    DAnnotation(source?: DAnnotation[\"source\"], details?: DAnnotation[\"details\"]): this {\r\n        const thiss: DAnnotation = this.thiss as any;\r\n        thiss.source = source || '';\r\n        thiss.details = details || [];\r\n        this.setExternalPtr(thiss.father, \"annotations\", \"+=\");\r\n\r\n        if (details) for (let det of details)\r\n            thiss._persistCallbacks.push(SetFieldAction.create(det, \"pointedBy\", PointedBy.fromID(thiss.id, \"details\"), '+='));\r\n\r\n        return this; }\r\n\r\n    DPointerTargetable(): this {\r\n        const thiss: DPointerTargetable = this.thiss as any;\r\n        thiss.className = (thiss.constructor as typeof RuntimeAccessibleClass).cname;\r\n        // this.className = thiss.className;\r\n        return this; }\r\n\r\n    DUser(username: string): this {\r\n        const _this: DUser = this.thiss as unknown as DUser;\r\n        _this.username = username;\r\n        statehistory[_this.id] = {undoable:[], redoable:[]};\r\n        // todo: make it able to combine last 2 changes with a keystroke.\r\n        //  reapeat N times to combine N actions.\r\n        //  let it \"redo\" multiple times, it's like recording a macro.\r\n\r\n        if (this.persist) {\r\n            // no pointedBy\r\n        }\r\n        return this; }\r\n\r\n    DNamedElement(name?: DNamedElement[\"name\"]): this {\r\n        const thiss: DNamedElement = this.thiss as any;\r\n        thiss.name = (name !== undefined) ? name || '' : thiss.constructor.name.substring(1) + \" 1\";\r\n        return this; }\r\n\r\n    DTypedElement(type?: DTypedElement[\"type\"]): this {\r\n        const thiss: DTypedElement = this.thiss as any;\r\n        this.setPtr(\"type\", type);\r\n        return this; }\r\n\r\n    DPackage(uri?: DPackage[\"uri\"], prefix?: DPackage[\"prefix\"]): this {\r\n        const thiss: DPackage = this.thiss as any;\r\n        thiss.uri = uri || '';// || 'org.jodel-react.username';\r\n        thiss.prefix = prefix || '';\r\n        if (thiss.father) {\r\n            if (this.fatherType!.cname === \"DModel\") {\r\n                this.setExternalPtr(thiss.father, \"packages\", \"+=\");\r\n            }\r\n            else {\r\n                this.setExternalPtr(thiss.father, \"subpackages\", \"+=\");\r\n            }\r\n        }\r\n        return this; }\r\n\r\n    DModel(instanceoff?: DModel[\"instanceof\"], isMetamodel?: DModel[\"isMetamodel\"]): this {\r\n        const thiss: DModel = this.thiss as any;\r\n        thiss.packages = []; // packages;\r\n        thiss.isMetamodel = isMetamodel || false;\r\n        this.setPtr(\"instanceof\", instanceoff || null);\r\n        instanceoff && this.setExternalPtr(instanceoff, \"instances\", \"+=\");\r\n        // todo: check all D.new calls to make sure there are not actions in callbacks in new2() versions that will go outside the Transaction of persist(),, better move ptrs as .new() parameters\r\n        // or make it so new2 splits pointer and non-pointer declarations (or just allow non-ptrs and ptrs must be DSomething.new() explicit parameters)\r\n        thiss._persistCallbacks.push(SetRootFieldAction.create(isMetamodel ? \"m2models\" : \"m1models\", thiss.id, \"+=\", true));\r\n        return this;\r\n    }\r\n\r\n    DOperation(exceptions: DOperation[\"exceptions\"] = [], implementation?: string/*, parameters: DOperation[\"parameters\"] = []*/): this {\r\n        const thiss: DOperation = this.thiss as any;\r\n        // thiss.parameters = parameters;\r\n        thiss.implementation = implementation || 'return \"default placeholder function called\";'\r\n        this.setPtr(\"exceptions\", exceptions);\r\n        this.setExternalPtr(thiss.father, \"operations\", \"+=\");\r\n        return this; }\r\n\r\n    DClass(isInterface: DClass[\"interface\"] = false, isAbstract: DClass[\"abstract\"] = false, isPrimitive: LClassifier[\"isPrimitive\"] = false,\r\n           partial: DClass[\"partial\"] = false, partialdefaultname: DClass[\"partialdefaultname\"] = ''): this {\r\n        const thiss: DClass = this.thiss as any;\r\n        thiss.interface = isInterface;\r\n        thiss.abstract = isAbstract;\r\n        thiss.isPrimitive = isPrimitive;\r\n        thiss.partial = partial;\r\n        thiss.partialdefaultname = partialdefaultname;\r\n        thiss.isSingleton = false;\r\n        this.setExternalPtr(thiss.father, \"classifiers\", \"+=\");\r\n        this.setExternalRootProperty('ClassNameChanged.'+thiss.id, thiss.name, '', false);\r\n\r\n        // thiss.isClass = !isPrimitive;\r\n        // thiss.isEnum = false;\r\n        return this; }\r\n\r\n    DEnumLiteral(value?: DEnumLiteral[\"value\"]): this { // vv4\r\n        const thiss: DEnumLiteral = this.thiss as any;\r\n        thiss.value = value as any; // undef is ok, handled in getter as automatic ordinal index\r\n        thiss.literal = thiss.name;\r\n        this.setExternalPtr(thiss.father, \"literals\", \"+=\");\r\n        return this; }\r\n\r\n    DEnumerator(literals: DEnumerator[\"literals\"] = []): this {\r\n        const thiss: DEnumerator = this.thiss as any;\r\n        this.setExternalPtr(thiss.father, \"classifiers\", \"+=\");\r\n        this.setPtr(\"literals\", literals);\r\n        // thiss.literals = literals;\r\n        // thiss.isClass = false;\r\n        // thiss.isEnum = true;\r\n        return this; }\r\n    DEdgePoint(): this { return this; }\r\n    DEdge(): this {\r\n        let thiss: DVoidEdge = this.thiss as any;\r\n        return this; }\r\n    DVertex(): this { return this; }\r\n    DVoidEdge(start: DGraphElement[\"id\"] | DGraphElement | LGraphElement | DModelElement[\"id\"] | DModelElement | LModelElement,\r\n              end: DGraphElement[\"id\"] | DGraphElement | LGraphElement | DModelElement[\"id\"] | DModelElement | LModelElement,\r\n              longestLabel?: DEdge[\"longestLabel\"], labels?: DEdge[\"labels\"]): this {\r\n        const thiss: DVoidEdge = this.thiss as any;\r\n        let startid: DGraphElement[\"id\"] = (windoww.LGraphElement as typeof LGraphElement).getNodeId(start);\r\n        let endid: DGraphElement[\"id\"] = (windoww.LGraphElement as typeof LGraphElement).getNodeId(end);\r\n        Log.ex(!startid || !endid, \"cannot create an edge without start or ending nodes\", {start, end, startid, endid});\r\n        thiss.anchorStart = '0';\r\n        thiss.anchorEnd = '0';\r\n        // thiss.startFollow = false;\r\n        // thiss.endFollow = false;\r\n        thiss.midnodes = [];\r\n        thiss.midPoints = []; // the logic part which instructs to generate the midnodes\r\n        // if (!thiss.model && isDModelElementPointer(startid)) thiss.model = startid;\r\n        // thiss.labels = undefined;\r\n        let ll: labelfunc = (e: LVoidEdge, s: EdgeSegment, allNodes: LGraphElement[], allSegments: EdgeSegment[]\r\n        ) => /*defining the edge label (e.start.model as any)?.name + \" ~ \" + (e.end.model as any)?.name */\" (\" + s.length.toFixed(1) + \")\";\r\n        // complex edge label func example: (thiss.longestLabel = ll)\r\n        thiss.longestLabel = longestLabel;\r\n        this.setPtr(\"start\", startid);\r\n        this.setPtr(\"end\", endid);\r\n        this.setExternalPtr(startid, \"edgesOut\", \"+=\");\r\n        this.setExternalPtr(endid, \"edgesIn\", \"+=\");\r\n\r\n        let gthis: Partial<DVoidEdge> = thiss;\r\n        delete gthis.x;\r\n        delete gthis.y;\r\n        delete gthis.w;\r\n        delete gthis.h;\r\n        delete gthis.edgesIn;\r\n        delete gthis.edgesOut;\r\n        delete gthis.anchors;\r\n        delete gthis.__isDVoidEdge;\r\n        delete (gthis as Partial<DEdge>).__isDEdge;\r\n        return this; }\r\n\r\n    DExtEdge(): this { return this; }\r\n    DRefEdge(): this { return this; }\r\n\r\n    DGraphElement(model: DGraphElement[\"model\"]|null|undefined, parentgraphID: DGraphElement[\"graph\"]|undefined,\r\n                  htmlindex: number = 1): this {\r\n        const thiss: DGraphElement = this.thiss as any;\r\n        thiss.subElements = [];\r\n        thiss.favoriteNode = false;\r\n        thiss.zIndex = htmlindex;\r\n        thiss.isSelected = {};\r\n        thiss.edgesIn = [];\r\n        thiss.edgesOut = [];\r\n        // thiss.state = {id: thiss.id+\".state\", className: thiss.className};\r\n        // 5-way anchors thiss.anchors = {'0':{x:0.5, y:0.5}, '1':{x:0.5, y:0}, '2':{x:1, y:0.5}, '3':{x:0.5, y:1}, '4':{x:0, y:0.5}} as any;\r\n        thiss.anchors = {'0':{x:0.5, y:0.5}, 't':{x:0.5, y:0},\r\n            'tr':{x:1, y:0}, 'r':{x:1, y:0.5}, 'br':{x:1, y:1},\r\n            'b':{x:0.5, y:1},\r\n            'bl':{x:0, y:1}, 'l':{x:0, y:0.5}, 'tl':{x:0, y:0},\r\n        } as any;\r\n        for (let k in (thiss.anchors as GObject)) {\r\n            let a: GObject = thiss.anchors[k];\r\n            if (!a.name) a.name = k;\r\n            if (!a.w) a.w = 15;\r\n            if (!a.h) a.h = 15;\r\n        }\r\n\r\n        this.setPtr(\"model\", model);\r\n        this.setPtr(\"graph\", parentgraphID);\r\n        this.setExternalPtr(thiss.father, \"subElements\", \"+=\");\r\n\r\n        Log.eDev(thiss.father&&DPointerTargetable.fromPointer(thiss.father).subElements.indexOf(thiss.id)!==-1, \"subelemnts+= addition have duplicates\",\r\n            {adding:thiss, d:thiss.father&&DPointerTargetable.fromPointer(thiss.father).subElements.indexOf(thiss.id)});\r\n\r\n        return this;\r\n    }\r\n\r\n    DViewElement(name: string, jsxString: string, vp?: Pointer<DViewPoint>,\r\n                 defaultVSize?: GraphSize, usageDeclarations: string = '', constants: string = '',\r\n                 preRenderFunc: string = '', appliableToClasses: string[] = [], oclCondition: string = '', priority?: number): this {\r\n        const thiss: DViewElement = this.thiss as any;\r\n        const vid = thiss.id;\r\n        let tv = transientProperties.view[vid];\r\n        if (!tv) transientProperties.view[vid] = tv = {} as any;\r\n\r\n        thiss.name = name;\r\n        thiss.appliableToClasses = appliableToClasses;\r\n        thiss.appliableTo = 'Any';\r\n        thiss.jsxString = jsxString;\r\n        thiss.usageDeclarations = usageDeclarations;\r\n        thiss.constants = undefined; // '{}';\r\n        thiss.preRenderFunc = ''; // '() => {return{}}';\r\n        thiss.onDragEnd = thiss.onDragStart = thiss.whileDragging =\r\n        thiss.onResizeEnd = thiss.onResizeStart = thiss.whileResizing = '';\r\n        thiss.onRotationEnd = thiss.onRotationStart = thiss.whileRotating = '';\r\n        thiss.onDataUpdate = '';\r\n        thiss.events = {};\r\n        // thiss.__transient = new DViewTransientProperties();\r\n        thiss.subViews = {};\r\n        thiss.oclCondition = oclCondition || '';\r\n        thiss.jsCondition = '';\r\n        thiss.oclUpdateCondition = '';\r\n        thiss.OCL_NEEDS_RECALCULATION = true;\r\n        thiss.explicitApplicationPriority = undefined as any; //priority as any as number;\r\n        thiss.isExclusiveView = true;\r\n        thiss.size = {};\r\n        thiss.storeSize = false;\r\n        thiss.lazySizeUpdate = true;\r\n        thiss.isValidation = false;\r\n        //thiss.constraints = [];\r\n        thiss.palette = {\r\n            'color-': U.hexToPalette(), //['#ffffff', '#ff0000', '#00ff00', '#0000ff','#aaaaaa', '#ffaaaa', '#aaffaa', '#aaaaff'],\r\n            'background-': U.hexToPalette() // ['#000000', '#33333', '#777777']};\r\n        };\r\n        thiss.css = '';\r\n        thiss.compiled_css = '';\r\n        thiss.css_MUST_RECOMPILE = true;\r\n        thiss.cssIsGlobal = false;\r\n        // thiss.palette = {};\r\n\r\n        // thiss.useSizeFrom = EuseSizeFrom.node;\r\n        // thiss.adaptHeight = false;\r\n        // thiss.adaptWidth = false;\r\n\r\n\r\n        thiss.draggable = true;\r\n        thiss.resizable = true;\r\n        //thiss.display = 'flex' as any;\r\n        thiss.defaultVSize = defaultVSize || new GraphSize(0, 0, 140.6818084716797, 32.52840805053711);\r\n        thiss.adaptWidth = false;\r\n        thiss.adaptHeight = true; //'fit-content';\r\n\r\n        thiss.edgeStartOffset = new GraphPoint(50, 50);\r\n        thiss.edgeEndOffset = new GraphPoint(50, 50);\r\n        thiss.edgeStartOffset_isPercentage = true;\r\n        thiss.edgeEndOffset_isPercentage = true;\r\n        thiss.edgeStartStopAtBoundaries = true;\r\n        thiss.edgeEndStopAtBoundaries = true;\r\n        thiss.bendingMode = EdgeBendingMode.Bezier_quadratic;\r\n        thiss.edgeGapMode = EdgeGapMode.center;\r\n        thiss.edgePointCoordMode = CoordinateMode.relativeOffset;\r\n        thiss.usageDeclarations = undefined;\r\n\r\n        /// edge only\r\n\r\n        thiss.edgeHeadSize = new GraphPoint(20, 20);\r\n        thiss.edgeTailSize = new GraphPoint(20, 20);\r\n        if (thiss.className !== 'DViewElement') return this;\r\n        const user = LUser.fromPointer(DUser.current);\r\n        // const project = user?.project; if(!project) return this;\r\n        if (!vp) vp = user?.project?.activeViewpoint.id || Defaults.viewpoints[0];\r\n        if (vp !== 'skip') {\r\n            // let dvp = DPointerTargetable.fromPointer(vp);\r\n            // let subviews = {...dvp.subViews}; subviews[thiss.id] = 1.5;\r\n            // this.setExternalPtr(vp, 'subViews', '', subviews);\r\n            this.setPtr('viewpoint', vp);\r\n        }\r\n\r\n        this.setExternalPtr(this.fatherPtr as Pointer<DViewElement>, 'subViews', '+=', {[thiss.id]: 1.5});\r\n        transientProperties.view[thiss.id] = {} as any;\r\n\r\n        // let trview = transientProperties.view[thiss.id];\r\n        // trview.?? = ???\r\n\r\n        TRANSACTION(() => {\r\n            // add relation to vp\r\n            for(let key of (windoww.DViewElement as typeof DViewElement).RecompileKeys)\r\n                this.setExternalRootProperty('VIEWS_RECOMPILE_'+key, thiss.id, '+=', false) // is pointer, but no need to set pointedby\r\n        })\r\n\r\n        // this.setExternalPtr(project.id, 'views', '+=');\r\n        // this.setExternalPtr(project.id, 'stackViews', '+=');\r\n        return this;\r\n    }\r\n\r\n    DViewPoint(): this {\r\n        const thiss: DViewPoint = (this.thiss) as any;\r\n        const user = LUser.fromPointer(DUser.current);\r\n        const project = user?.project;\r\n        if (!project) return this;\r\n        this.setExternalPtr(project.id, 'viewpoints', '+=');\r\n        // thiss._persistCallbacks.push( SetFieldAction.create(project.id, 'stackViews', [], '', false) );\r\n        return this;\r\n    }\r\n\r\n    DProject(type: DProject['type'], name: string, state: DProject['state'], m2: DProject['metamodels'], m1: DProject['models'], id?: DProject['id']): this {\r\n        const _this: DProject = U.wrapper<DProject>(this.thiss);\r\n        _this.metamodels = m2;\r\n        _this.models = m1;\r\n        _this.type = type;\r\n        _this.name = name;\r\n        _this.state = state || '';\r\n        if(id) _this.id = id;\r\n        _this.favorite = {};\r\n        _this.description = 'A new Project. Created by ' + (DPointerTargetable.from(DUser.current) as DUser).username + ' @' + new Date().toLocaleString();\r\n        this.setExternalPtr(DUser.current, 'projects', '+=');\r\n        return this;\r\n    }\r\n\r\n    static DGraph_maxID: number = 0;\r\n    public static DGraph_makeID(modelid: DGraph[\"model\"]): Pointer<DGraph, 1, 1, LGraph> {\r\n        if (!modelid) modelid = \"shapeless\";\r\n        return modelid + '_graph' + Constructors.DGraph_maxID++;\r\n    }\r\n    DGraph(): this {\r\n        const thiss: DGraph = this.thiss as any;\r\n        thiss.graph = thiss.id; // no setPtr because i want to avoid circular pointedby reference\r\n        thiss.zoom = new GraphPoint(1, 1);\r\n        thiss.offset = new GraphPoint(0, 0);  // GraphSize.apply(this, [0, 0, 0 ,0]);\r\n        thiss._subMaps = {zoom: true, graphSize: true}\r\n\r\n        const user: LUser = LUser.fromPointer(DUser.current);\r\n        if (thiss.className === 'DGraph') { // to exclude GraphVertex\r\n            user.project && this.setExternalPtr(user.project.id, 'graphs', \"+=\");\r\n            thiss.x = 0;\r\n            thiss.y = 0;\r\n            thiss.w = 0;\r\n            thiss.h = 0;\r\n        }\r\n        else {\r\n            // todo: set to default graphvertex size, so it can skip a rerender\r\n            thiss.x = 0;\r\n            thiss.y = 0;\r\n            //thiss.w = packageDefaultSize.w;\r\n            //thiss.h = packageDefaultSize.h;\r\n        }\r\n        return this; }\r\n\r\n    DVoidVertex(defaultVSize?: InitialVertexSize): this {\r\n        const thiss: DVoidVertex = this.thiss as any;\r\n        /*[]{}<>\r\n?'^~\r\n&&||\\+\r\n6nb*/\r\n        let defaultVSizeObj: InitialVertexSizeObj | undefined;\r\n        let defaultVSizeFunc: InitialVertexSizeFunc;\r\n        thiss.isResized = false;\r\n\r\n        let lvertex: LVoidVertex = LPointerTargetable.fromD(thiss);\r\n        if (typeof defaultVSize !== \"function\") { defaultVSizeObj = defaultVSize; }\r\n        else {\r\n            defaultVSizeFunc = defaultVSize;\r\n            try { defaultVSizeObj = defaultVSizeFunc(lvertex.father, lvertex); }\r\n            catch (e) { Log.exx(\"Error in user DefaultVSize function:\", {e, defaultVSizeFunc, txt:defaultVSizeFunc.toString()}); }\r\n        }\r\n        if (defaultVSizeObj) {\r\n            if (defaultVSizeObj.x !== undefined) thiss.x = defaultVSizeObj.x;\r\n            if (defaultVSizeObj.y !== undefined) thiss.y = defaultVSizeObj.y;\r\n            if (defaultVSizeObj.w !== undefined) thiss.w = defaultVSizeObj.w;\r\n            if (defaultVSizeObj.h !== undefined) thiss.h = defaultVSizeObj.h;\r\n\r\n            if ((defaultVSizeObj as any).index >= 0 && thiss.className === \"DEdgePoint\") {\r\n                let updateEPindex = () => {\r\n                    let lep = lvertex as LEdgePoint;\r\n                    let le: LVoidEdge = lep.father;\r\n                    let de: DVoidEdge = le.__raw;\r\n                    let subelements = [...de.subElements];\r\n                    U.arrayRemoveAll(subelements, thiss.id);\r\n                    subelements.splice(defaultVSizeObj?.index as number, 0, thiss.id);\r\n                    // console.log(\"setting subelements\", {oldsubelements, subelements, de, le, thiss});\r\n                    le.subElements = subelements as any;\r\n                    // todo: this might break \"pointedBy\" x984\r\n                }\r\n                // updateEPindex();\r\n                // it's already wrapped in a callback\r\n                // but needs a second one because after node is created, id is auto-appended to this collection\r\n                // and i need to rewrite that append by inserting my own customized index position\r\n                console.log(\"setting subelements 0\", {updateEPindex});\r\n                setTimeout(updateEPindex, 0);\r\n                // NB: do not use this.callbacks.push because the body of this func is executed after Constructors.end() so end() can never find and execute it.\r\n            }\r\n        }\r\n\r\n        return this; }\r\n\r\n\r\n}\r\n// export const Constructors = new _Constructors();\r\n\r\n@RuntimeAccessible(\"DPointerTargetable\")\r\nexport class DPointerTargetable extends RuntimeAccessibleClass {\r\n    static defaultComponent: (ownProps: GObject, children?: (string | React.Component)[]) => React.ReactElement; //\r\n    public static maxID: number = 0;\r\n    public static logic: typeof LPointerTargetable;\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static pendingCreation: Record<Pointer<DPointerTargetable, 1, 1>, DPointerTargetable> = {};\r\n    clonedCounter?: number;\r\n    _storePath?: string[];\r\n    _subMaps?: Dictionary<string, boolean>;\r\n    id!: Pointer<DPointerTargetable, 1, 1, LPointerTargetable>;\r\n    // pointedBy: DocString<'path in store'>[] = []; // NB: potrebbe contenere puntatori invalidi.\r\n    // se viene cancellato un intero oggetto A che contiene una lista di puntatori, gli oggetti che puntano ad A rimuovono A dai loro \"poitnedBy\",\r\n    // ma gli oggetti puntati da A tramite sotto-oggetti o attributi (subviews...) non vengono aggiornati in \"pointedby\"\r\n    pointedBy: PointedBy[] = [];\r\n    public className!: string;\r\n    _state: GObject = {};\r\n\r\n    static defaultname<L extends LModelElement = LModelElement>(startingPrefix: string | ((meta:L)=>string), father?: Pointer | DPointerTargetable | ((a:string)=>boolean), metaptr?: Pointer | null): string {\r\n        let lfather: LModelElement;\r\n        // startingPrefix = \"model_\", father = ((name: string) => !dmodelnames.includes(name))\r\n        if (father) {\r\n            if (typeof father === \"string\" || (father as any).className) { // Pointer or D\r\n                lfather = LPointerTargetable.wrap(father as DModelElement) as LModelElement;\r\n                if (!lfather) return (typeof startingPrefix === \"string\" ? startingPrefix : \"unnamed_elem\"); // can happen during parse when father ptr exist but it's not in store yet. not a prob\r\n                if (typeof startingPrefix !== \"string\") {\r\n                    let meta = LPointerTargetable.from(metaptr as Pointer);\r\n                    startingPrefix = startingPrefix(meta as L);\r\n                }\r\n                const childrenNames: (string)[] = lfather.children.map(c => (c as LNamedElement)?.name);\r\n                return U.increaseEndingNumber(startingPrefix + '0', false, false, (newname) => childrenNames.indexOf(newname) >= 0);\r\n            }\r\n            else {\r\n                let condition: (a:string)=>boolean = father as any;\r\n                return U.increaseEndingNumber(startingPrefix + '0', false, false, condition);\r\n            }\r\n        }\r\n        return startingPrefix + \"1\"; }\r\n\r\n    public static new(...a:any): DPointerTargetable { //father?: Pointer, persist: boolean = false, fatherType?: Constructor, ...a:any): DPointerTargetable {\r\n        Log.exx(\"cannot instantiate abstract class DPointerTargetable\");\r\n        return null as any;\r\n        // return new Constructors(new DPointerTargetable('dwc'), father, persist, fatherType).DPointerTargetable().end();\r\n    }\r\n    constructor(fakearg_detectwrongcalls:'dwc') {\r\n        super();\r\n        if (!fakearg_detectwrongcalls) throw new Error( \"cannot build D-objects using new keyword, use the static D-Class.new method instead\");\r\n    }\r\n\r\n    static fromL<LX extends LPointerTargetable,\r\n        DX = LX extends LEnumerator ? LEnumerator : (LX extends LAttribute ? LAttribute : (LX extends LReference ? LReference : (LX extends LRefEdge ? LRefEdge : (LX extends LExtEdge ? LExtEdge : (LX extends LDataType ? LDataType : (LX extends LClass ? LClass : (LX extends LStructuralFeature ? LStructuralFeature : (LX extends LParameter ? LParameter : (LX extends LOperation ? LOperation : (LX extends LEdge ? LEdge : (LX extends LEdgePoint ? LEdgePoint : (LX extends LGraphVertex ? LGraphVertex : (LX extends LModel ? LModel : (LX extends LValue ? LValue : (LX extends LObject ? LObject : (LX extends LEnumLiteral ? LEnumLiteral : (LX extends LPackage ? LPackage : (LX extends LClassifier ? LClassifier : (LX extends LTypedElement ? LTypedElement : (LX extends LVertex ? LVertex : (LX extends LVoidEdge ? LVoidEdge : (LX extends LVoidVertex ? LVoidVertex : (LX extends LGraph ? LGraph : (LX extends LNamedElement ? LNamedElement : (LX extends LAnnotation ? LAnnotation : (LX extends LGraphElement ? LGraphElement : (LX extends LMap ? LMap : (LX extends LModelElement ? LModelElement : (LX extends LUser ? LUser : (LX extends LPointerTargetable ? LPointerTargetable : (ERROR)))))))))))))))))))))))))))))))\r\n        >(data: LX): DX {\r\n        return data.__raw as any;\r\n    }\r\n\r\n\r\n    static fromPointer<// LOW extends number, UPP extends number | 'N',\r\n        T extends Pointer | Pointer[], // <DPointerTargetable, 1, 'N', LPointerTargetable>,\r\n        DDD extends (T extends Pointer<infer D> ? D : 'undefined D'),\r\n        LOW extends (T extends Pointer<any, infer LO> ? LO : 'undefined_upp'),\r\n        UPP extends (T extends Pointer<any, number, infer UP> ? UP : 'undefined_low'),\r\n\r\n        DDDARR extends (T extends Pointer<infer D>[] ? D : 'undefined_DARR'),\r\n        LOWARR extends (T extends Pointer<any, infer LO>[] ? LO : 'undefined_uppARR'),\r\n        UPPARR extends (T extends Pointer<any, number, infer UP>[] ? 'UP_is_N' : 'undefined_lowARR'),\r\n\r\n        RET = UPPARR extends 'UP_is_N' ?\r\n            (DDDARR[]) : // 0...N\r\n            (UPP extends 1 ? (LOW extends 0 ? DDD | null : DDD) : // 0...1 && 1...1\r\n                (LOW extends 1 ? DDD : undefined)  //1...1\r\n                ),\r\n        INFERRED = {ret: RET, upp: UPP, low:LOW, ddd: DDD, dddARR: DDDARR, lowARR: LOWARR, uppARR: UPPARR},>(ptr: T, s?: DState)\r\n        : RET {\r\n        s = s || store.getState();\r\n        if (!ptr) { return ptr as any; }\r\n        if (Array.isArray(ptr)) {\r\n            return ptr.map( (p: Pointer) => DPointerTargetable.fromPointer(p, s)) as any;\r\n        }\r\n        if (typeof ptr !== \"string\") {\r\n            console.error(\"wrong parameter in DPointerTargetable.fromPointers()\", ptr);\r\n            throw new Error(\"wrong parameter in DPointerTargetable.fromPointers()\");\r\n        }\r\n        if (s && s.idlookup[ptr as string]) return s.idlookup[ptr as string] as any;\r\n        return (DPointerTargetable.pendingCreation[ptr as string] || s.idlookup[ptr as string]) as any;\r\n        // return ((s || store.getState()).idlookup[ptr as string] || DPointerTargetable.pendingCreation[ptr as string]) as any;\r\n    }\r\n\r\n    static from<// LOW extends number, UPP extends number | 'N',\r\n        PTR extends Pointer | Pointer[], // <DPointerTargetable, 1, 'N', LPointerTargetable>,\r\n        DDD extends (PTR extends Pointer<infer D> ? D : 'undefined D'),\r\n        LOW extends (PTR extends Pointer<any, infer LO> ? LO : 'undefined_upp'),\r\n        UPP extends (PTR extends Pointer<any, number, infer UP> ? UP : 'undefined_low'),\r\n\r\n        DDDARR extends (PTR extends Pointer<infer D>[] ? D : 'undefined_DARR'),\r\n        LOWARR extends (PTR extends Pointer<any, infer LO>[] ? LO : 'undefined_uppARR'),\r\n        UPPARR extends (PTR extends Pointer<any, number, infer UP>[] ? 'UP_is_N' : 'undefined_lowARR'),\r\n\r\n        LX extends LPointerTargetable,\r\n\r\n        RETPTR = UPPARR extends 'UP_is_N' ?\r\n            (DDDARR[]) : // 0...N\r\n            (UPP extends 1 ? (LOW extends 0 ? DDD | null : DDD) : // 0...1 && 1...1\r\n                (LOW extends 1 ? DDD : undefined)  //1...1\r\n                ),\r\n        // DX = LX extends LEnumerator ? DEnumerator : (LX extends LAttribute ? DAttribute : (LX extends LReference ? DReference : (LX extends LDataType ? DDataType : (LX extends LClass ? DClass : (LX extends LStructuralFeature ? DStructuralFeature : (LX extends LParameter ? DParameter : (LX extends LOperation ? DOperation : (LX extends LModel ? DModel : (LX extends LValue ? DValue : (LX extends LObject ? DObject : (LX extends LEnumLiteral ? DEnumLiteral : (LX extends LPackage ? DPackage : (LX extends LClassifier ? DClassifier : (LX extends LTypedElement ? DTypedElement : (LX extends LNamedElement ? DNamedElement : (LX extends LAnnotation ? DAnnotation : ('ERROR'))))))))))))))))),\r\n        DX = LX extends LEnumerator ? DEnumerator : (LX extends LAttribute ? DAttribute : (LX extends LReference ? DReference : (LX extends LRefEdge ? DRefEdge : (LX extends LExtEdge ? DExtEdge : (LX extends LDataType ? DDataType : (LX extends LClass ? DClass : (LX extends LStructuralFeature ? DStructuralFeature : (LX extends LParameter ? DParameter : (LX extends LOperation ? DOperation : (LX extends LEdge ? DEdge : (LX extends LEdgePoint ? DEdgePoint : (LX extends LGraphVertex ? DGraphVertex : (LX extends LModel ? DModel : (LX extends LValue ? DValue : (LX extends LObject ? DObject : (LX extends LEnumLiteral ? DEnumLiteral : (LX extends LPackage ? DPackage : (LX extends LClassifier ? DClassifier : (LX extends LTypedElement ? DTypedElement : (LX extends LVertex ? DVertex : (LX extends LVoidEdge ? DVoidEdge : (LX extends LVoidVertex ? DVoidVertex : (LX extends LGraph ? DGraph : (LX extends LNamedElement ? DNamedElement : (LX extends LAnnotation ? DAnnotation : (LX extends LGraphElement ? DGraphElement : (LX extends LMap ? DMap : (LX extends LModelElement ? DModelElement : (LX extends LUser ? DUser : (LX extends LPointerTargetable ? DPointerTargetable : (ERROR))))))))))))))))))))))))))))))),\r\n        RET = DX extends 'ERROR' ? RETPTR : (RETPTR extends DX ? RETPTR : DX),\r\n        INFERRED = {ret: RET, RETPTR:RETPTR, upp: UPP, low:LOW, ddd: DDD, dddARR: DDDARR, lowARR: LOWARR, uppARR: UPPARR, LX:LX, DX:DX}>(ptr: PTR | LX, s?: DState)\r\n        : RET {\r\n        if (!ptr) return ptr as any;\r\n        if (Array.isArray(ptr)) return DPointerTargetable.fromArr(ptr, true, s) as any;\r\n        if ((ptr as LX).__isProxy) return (ptr as LX).__raw as any;\r\n        if (typeof ptr === \"string\") {\r\n            if (s && s.idlookup[ptr as string]) return s.idlookup[ptr as string] as any;\r\n            return (DPointerTargetable.pendingCreation[ptr as string] || store.getState().idlookup[ptr as string]) as any;\r\n        }\r\n        else if ((ptr as any as GObject<DX>).className) return ptr as any;\r\n        else return undefined as any;\r\n    }\r\n    public static fromArr(arr:any[], filter: boolean = true, s?: DState): DPointerTargetable[]{\r\n        let ret: (DPointerTargetable)[] = [];\r\n        s = s || store.getState();\r\n        for (let a of arr) {\r\n            let d = DPointerTargetable.from(a, s);\r\n            if (!filter || d) ret.push(d as DPointerTargetable);\r\n        }\r\n        return ret;\r\n    }\r\n    //static from0(a: any, ...aa: any): any { return null; }\r\n    static writeable<LX extends LPointerTargetable, WX = LtoW<LX>>(l: LX): WX { return l as any; }\r\n\r\n    _persistCallbacks!: ((() => void) | Action)[]; // deleted when it becomes persistent\r\n    _derivedSubElements!: DModelElement[]; // deleted when it becomes persistent\r\n    // persist(): void { Constructors.persist(this); }// deleted when it becomes persistent\r\n}\r\n\r\nRuntimeAccessibleClass.set_extend(RuntimeAccessibleClass, DPointerTargetable);\r\n/*\r\nlet d0: LClassifier = null as any;\r\nlet ptrr: Pointer<DPackage, 1, 'N', LPackage> = null as any;\r\nlet ptr1: Pointer<DPackage, 1, 1, LPackage> = null as any;\r\nlet dd = DPointerTargetable.from(d0.id);\r\n*/\r\n\r\n\r\n/*\r\ntype Pack1<D extends DPointerTargetable, L extends LPointerTargetable = DtoL<D>, P extends Pointer<D, 0, 1, L> = Pointer<D, 0, 1, L>, R = {D:D, L:L, P:P} > = P|D|L\r\ntype PackArr<D extends DPointerTargetable, L extends LPointerTargetable = DtoL<D>, P extends Pointer<D, 0, 1, L> = Pointer<D, 0, 1, L> , ARR = Pack1<D>> = (ARR)[];\r\ntype Pack<D extends DPointerTargetable, L extends LPointerTargetable = DtoL<D>, P extends Pointer<D, 0, 1, L> = Pointer<D, 0, 1, L> , ARR = Pack1<D>> = ARR | (ARR)[];*/\r\n\r\n\r\n\r\n@RuntimeAccessible('Pointers')\r\nexport class Pointers{\r\n    static filterValid<P extends (Pointer | Pointer[]) = any, RET = P extends Pointer[] ? P : P | null>\r\n    (p: P): P | null {\r\n        const pointerval: DPointerTargetable | DPointerTargetable[] = DPointerTargetable.from(p);\r\n        if (Array.isArray(pointerval)) return pointerval.filter( p => !!p).map( p => p.id) as P;\r\n        if (!pointerval) return null;\r\n        return pointerval.id as P; }\r\n\r\n    static fromArr<D extends DPointerTargetable, L extends LPointerTargetable, P extends Pointer> (val: (P | D | L | null | undefined)[] |  (P | D | L | null | undefined)): P[] {\r\n        if (!val) val = [];\r\n        if (!Array.isArray(val)) { val = [val]; }\r\n        if (!val.length) { return []; }\r\n        if ((val[0] as any).id) { val = (val as any as (LModelElement | DModelElement)[]).filter(v => !!v).map( (v) => v.id) as any[]; }\r\n        return val.filter( v => !!v) as any[]; }\r\n\r\n    fromm<D extends DPointerTargetable, L extends LPointerTargetable, P extends Pointer> (val: (P | D | L)): P | null { return !val ? null : (val as any).id; }\r\n\r\n    from0<// LOW extends number, UPP extends number | 'N',\r\n        PTR extends Pointer | Pointer[], // <DPointerTargetable, 1, 'N', LPointerTargetable>,\r\n        // DDD extends (PTR extends Pointer<infer D> ? D : 'undefined_D'),\r\n        LOW extends (PTR extends Pointer<any, infer LO> ? LO : 'undefined_upp'),\r\n        UPP extends (PTR extends Pointer<any, number, infer UP> ? UP : 'undefined_low'),\r\n        DDD extends (PTR extends Pointer<any, number, any, infer LL> ? LL : 'undefined_L'),\r\n\r\n        LOWARR extends (PTR extends Pointer<any, infer LO>[] ? LO : 'undefined_uppARR'),\r\n        UPPARR extends (PTR extends Pointer<any, number, infer UP>[] ? 'UP_is_N' : 'undefined_lowARR'),\r\n        DDDARR extends (PTR extends Pointer<any, any, any, infer LL>[] ? LL : 'undefined_LARR'),\r\n\r\n        DX extends DPointerTargetable,\r\n        LX extends LPointerTargetable,\r\n        WX extends WPointerTargetable,\r\n        RETPTR = UPPARR extends 'UP_is_N' ?\r\n            (DDDARR[]) : // 0...N\r\n            (UPP extends 1 ? (LOW extends 0 ? DDD | null : DDD) : // 0...1 && 1...1\r\n                (LOW extends 1 ? DDD : undefined)  //1...1\r\n                ),\r\n\r\n\r\n        // DX = LX extends LEnumerator ? DEnumerator : (LX extends LAttribute ? DAttribute : (LX extends LReference ? DReference : (LX extends LDataType ? DDataType : (LX extends LClass ? DClass : (LX extends LStructuralFeature ? DStructuralFeature : (LX extends LParameter ? DParameter : (LX extends LOperation ? DOperation : (LX extends LModel ? DModel : (LX extends LValue ? DValue : (LX extends LObject ? DObject : (LX extends LEnumLiteral ? DEnumLiteral : (LX extends LPackage ? DPackage : (LX extends LClassifier ? DClassifier : (LX extends LTypedElement ? DTypedElement : (LX extends LNamedElement ? DNamedElement : (LX extends LAnnotation ? DAnnotation : ('ERROR'))))))))))))))))),\r\n        LXX = DtoL<DX>,\r\n        DXX = LtoD<LX>,\r\n        LXFinal = LXX extends 'ERROR' ? LX : LXX,\r\n        DXFinal = DXX extends 'ERROR' ? DX : DXX,\r\n        RET = {d: DXFinal, l:LXFinal}, // Pointer<DX, 0 | 1, 1 | 'N', LX>\r\n        INFERRED = {ret: RET, RETPTR: RETPTR, LXX: LXX, DXX: DXX, upp: UPP, low:LOW, ddd: DDD, dddARR: DDDARR, lowARR: LOWARR, uppARR: UPPARR, LX:LX, DX:DX}>(data: LX | DX | WX)\r\n        : INFERRED {\r\n        return null as any;\r\n    }\r\n\r\n\r\n    static from00<\r\n        // LOW extends number, UPP extends number | 'N',\r\n        // DDD extends (PTR extends Pointer<infer D> ? D : 'undefined_D'),\r\n        DWL extends {id: any},\r\n        // PCK extends (T extends Pack<infer PPP> ? PPP : never),\r\n        //ISARR extends (T extends any[] ? true : false),\r\n        // PCK1 extends (T extends any[] ? null : T extends Pack1<infer PPP> ? PPP : never), //         PCK1 extends (T extends any[] ? true : false),\r\n        // PCKA extends (T extends PackArr<infer PPP> ? PPP : 'undefined_arrpack'),\r\n        // PTR extends DWL[\"id\"], // <DPointerTargetable, 1, 'N', LPointerTargetable>,\r\n        // T extends DWL | DWL[] | null | undefined,\r\n        /*DX extends (PTR extends Pointer<infer D0> ? D0 : 'undefined_D'),\r\n        LOW extends (PTR extends Pointer<any, infer LO> ? LO : 'undefined_upp'),\r\n        UPP extends (PTR extends Pointer<any, number, infer UP> ? UP : 'undefined_low'),\r\n        LX extends (PTR extends Pointer<any, number, any, infer LL> ? LL : 'undefined_L'),\r\n\r\n        LOWARR extends (PTR extends Pointer<any, infer LO>[] ? LO : 'undefined_uppARR'),\r\n        UPPARR extends (PTR extends Pointer<any, number, infer UP>[] ? 'UP_is_N' : 'undefined_lowARR'),\r\n        DDDARR extends (PTR extends Pointer<any, any, any, infer LL>[] ? LL : 'undefined_LARR'),\r\n        RET = DX extends DPointerTargetable ? ( LOW extends number ? ( UPP extends number ? ( LX extends LPointerTargetable ? Pointer<DX, LOW, UPP, LX> : '_notret_L_') : '_notret_UPP_') : '_notret_LOW_') : '_notret_D_'\r\n        */\r\n        PTRPARAM = Pointer | Pointer[],\r\n        T = Exclude<DWL | DWL[] | PTRPARAM, unknown[]>,\r\n        // @ts-ignore\r\n        PTR = T extends null ? null : T extends undefined ? null : (T extends PTRPARAM ? T : (T extends any[] ? T[number]['id'][] : T['id'])),\r\n        // RET extends Pointer<DPointerTargetable, any, any, LPointerTargetable> = T extends DWL ? DWL[\"id\"] : (T extends DWL[] ? DWL[\"id\"] : null),\r\n        // INF = { PCK:PCK, ISARR: ISARR,  PTR: PTR, DWL: DWL, RET: RET}, // {DD:DD, LL: LL}//\r\n        >(data: T | T[] ): PTR { // RET | RET[] {\r\n        if (Array.isArray(data)) return data.filter(d => !!d).map(d => (typeof d === \"string\" ? d : (d as any as DWL).id)) as any;\r\n        else return (data ? (data as any).id : null);\r\n    } // stavolta fai infer so D|l.id\r\n\r\n\r\n    public static from<DX extends DPointerTargetable>(data:DX): DX[\"id\"]; // | {D:any};\r\n    public static from<DX extends DPointerTargetable>(data:DX[]): DX[\"id\"][]; // | {DD:any};\r\n    public static from<LX extends LPointerTargetable>(data:LX): LX[\"id\"]; // | {L:any};\r\n    public static from<LX extends LPointerTargetable>(data:LX[]): LX[\"id\"][]; // | {LL:any};\r\n    public static from<WX extends WPointerTargetable>(data:WX): WX[\"id\"]; // | {W:any};\r\n    public static from<WX extends WPointerTargetable>(data:WX[]): WX[\"id\"][]; // | {WW:any};\r\n    public static from<PTR extends Pointer<DPointerTargetable, 1, 1, LPointerTargetable>>(data:PTR): PTR; // | {P:any};\r\n    public static from<PTR extends Pointer<DPointerTargetable, 1, 1, LPointerTargetable>>(data:PTR[]): PTR[]; // | {PP:any};\r\n    public static from<T extends LPointerTargetable>(data:Pack1<T>): Pointer<LtoD<T>, 1, 1, T>; //{TEST1:any};\r\n    public static from<T extends LPointerTargetable>(data:Pack1<T>[]): Pointer<LtoD<T>, 1, 1, T>[]; //{TEST111:any};\r\n    public static from<T extends LPointerTargetable>(data:Pack<T>): Pointer<LtoD<T>, 1, 1, T>[]; //{TEST0:any};\r\n    public static from<P extends Pack<T> | undefined, T extends LPointerTargetable>(data: P): Pointer<LtoD<T>, 1, 1, T>[]; //{TEST0:any};\r\n    public static from<T extends LPointerTargetable>(data:PackArr<T>): Pointer<LtoD<T>, 1, 1, T>[]; //{TESTARR:any};\r\n    public static from<T extends LPointerTargetable>(data:Pack1<T[]>): Pointer<LtoD<T>, 1, 1, T>; //{TEST1:any};\r\n    public static from<T extends LPointerTargetable>(data:Pack1<T[]>[]): Pointer<LtoD<T>, 1, 1, T>[]; //{TEST111:any};\r\n    public static from<T extends LPointerTargetable>(data:Pack<T[]>): Pointer<LtoD<T>, 1, 1, T>[]; //{TEST0:any};\r\n    public static from<T extends LPointerTargetable>(data:PackArr<T[]>): Pointer<LtoD<T>, 1, 1, T>[]; //{TESTARR:any};\r\n\r\n    /*\r\n        public static from(data:undefined): undefined; // | {D:any};\r\n        public static from<DX extends DPointerTargetable | undefined | null>(data:DX): DX extends DPointerTargetable ? DX[\"id\"] : DX; // | {D:any};\r\n        public static from<DX extends DPointerTargetable | undefined | null>(data:DX[]): DX extends DPointerTargetable ? DX[\"id\"][] : DX; // | {DD:any};\r\n        public static from<LX extends LPointerTargetable | undefined | null>(data:LX): LX extends LPointerTargetable ? LX[\"id\"] : LX; // | {L:any};\r\n        public static from<LX extends LPointerTargetable | undefined | null>(data:LX[]): LX extends LPointerTargetable ? LX[\"id\"][] : LX; // | {LL:any};\r\n        public static from<WX extends WPointerTargetable | undefined | null>(data:WX): WX extends WPointerTargetable ? WX[\"id\"] : WX; // | {W:any};\r\n        public static from<WX extends WPointerTargetable | undefined | null>(data:WX[]): WX extends WPointerTargetable ? WX[\"id\"][] : WX; // | {WW:any};\r\n        public static from<PTR extends Pointer<DPointerTargetable, 1, 1, LPointerTargetable> | undefined | null>(data:PTR): PTR extends Pointer<DPointerTargetable, 1, 1, LPointerTargetable> ? PTR : PTR; // | {P:any};\r\n        public static from<PTR extends Pointer<DPointerTargetable, 1, 1, LPointerTargetable> | undefined | null>(data:PTR[]): PTR extends Pointer<DPointerTargetable, 1, 1, LPointerTargetable> ? PTR[] : PTR; // | {PP:any};\r\n        public static from<T extends LPointerTargetable | undefined | null>(data:Pack1<T>): T extends LPointerTargetable ? Pointer<LtoD<T>, 1, 1, T> : T; //{TEST1:any};\r\n        public static from<T extends LPointerTargetable | undefined | null>(data:Pack1<T>[]): T extends LPointerTargetable ? Pointer<LtoD<T>, 1, 1, T>[] : T; //{TEST111:any};\r\n        public static from<T extends LPointerTargetable | undefined | null>(data:Pack<T>): T extends LPointerTargetable ? Pointer<LtoD<T>, 1, 1, T>[] : T; //{TEST0:any};\r\n        public static from<T extends LPointerTargetable | undefined | null>(data:PackArr<T>): T extends LPointerTargetable ? Pointer<LtoD<T>, 1, 1, T>[] : T; //{TESTARR:any};\r\n        // public static from<T extends LPointerTargetable | undefined | null>(data:Pack1<T[]>): T extends LPointerTargetable ? Pointer<LtoD<T>, 1, 1, T> : T; //{TEST1:any};\r\n        // public static from<T extends LPointerTargetable | undefined | null>(data:Pack1<T[]>[]): T extends LPointerTargetable ? Pointer<LtoD<T>, 1, 1, T>[] : T; //{TEST111:any};\r\n        // DDD extends (T extends Pointer<infer D> ? D : 'undefined D'),*/\r\n    // returns:\r\n    // if ptr is unvalid = undefined;\r\n    // if [ptr] is unvalid = []\r\n    public static from<TT extends Pack<LPointerTargetable[]> | undefined | null,\r\n        // @ts-ignore\r\n        T extends (TT extends Pack<infer PTYPE> ? PTYPE : undefined)>(data:T): T extends null | undefined ? T : Pointer<LtoD<T>, 1, 1, T>[]; //{TEST0:any};\r\n    // @ts-ignore\r\n    public static from<T extends LPointerTargetable | undefined | null>(data: PackArr<T[]>): T extends null | undefined ? T : Pointer<LtoD<T>, 1, 1, T>[]; //{TESTARR:any};\r\n    public static from(data:null | undefined): null; // | {Dn:any};\r\n    public static from(data:(null | undefined)[]): []; // | {Dnn:any};\r\n    public static from(data:(null | undefined) | (null | undefined)[]): []; // | {Dn0:any};\r\n\r\n    // function from<PTR extends Pointer<DPointerTargetable, 1, 1, LPointerTargetable>>(data:unknown | unknown[]): PTR | PTR[] | GObject {\r\n    public static from<T extends LClass, PTR extends Pointer<DPointerTargetable, 1, 1, LPointerTargetable>>(data:unknown | unknown[]): null | PTR | PTR[]{\r\n        if (!data) return null;\r\n        if (Array.isArray(data)) return data.filter(d => !!d).map(d => (typeof d === \"string\" ? d : (d as any)?.id)) as any;\r\n        return typeof data === \"string\" ? data : (data as any)?.id;\r\n    }\r\n\r\n    static isPointer(val: any, state?: DState, doArrayCheck: boolean = false): val is Pointer {\r\n        // might cause endless loop if there are subarrays in a containment loop.\r\n        if (doArrayCheck && Array.isArray(val)) return (val as any[]).some((v) => Pointers.isPointer(val, state, true));\r\n        if (state) return DPointerTargetable.from(val, state);\r\n        return typeof val === \"string\" ? val.includes(\"Pointer\") : false;\r\n    }\r\n}\r\n\r\n/*\r\nexport type Pack1<L extends LPointerTargetable | undefined | null,\r\n    // L extends LPointerTargetable | undefined | null = LL extends LPointerTargetable[] ? LPointerTargetable : null | undefined,\r\n    D extends (L extends LPointerTargetable ? LtoD<L> : undefined | null) = (L extends LPointerTargetable ? LtoD<L> : undefined | null)> =\r\n    L extends LPointerTargetable ? ( D extends DPointerTargetable ? D | L /*| LtoW<L>* / | Pointer<D, 1, 1, L> : L) : undefined;\r\nexport type PackArr<LL extends orArr<LPointerTargetable> | undefined | null,\r\n    L extends LPointerTargetable | undefined | null = LL extends undefined | null ? undefined : unArr<LL>> = Pack1<L>[];\r\nexport type Pack<\r\n    LL extends orArr<LPointerTargetable> | undefined | null,\r\n    L extends unArr<LL> = unArr<LL>,\r\n    // L extends (LL extends orArr<LPointerTargetable> ? LPointerTargetable : undefined | null) = (LL extends orArr<LPointerTargetable> ? unArr<LL> : undefined)\r\n    >\r\n    = LL extends undefined ? undefined : Pack1<L> | PackArr<L>;\r\n*/\r\nexport type Pack1<LL extends orArr<LPointerTargetable> | undefined, L extends LPointerTargetable | undefined = unArr<LL>,\r\n    D extends (L extends LPointerTargetable ? LtoD<L> : undefined) = (L extends LPointerTargetable ? LtoD<L> : undefined)> =\r\n    L extends LPointerTargetable ? ( D extends DPointerTargetable ? D | L | Pointer<D, 1, 1, L> : undefined) : undefined;\r\nexport type PackArr<LL extends orArr<LPointerTargetable> | undefined, L extends LPointerTargetable | undefined = unArr<LL>> = Pack1<L>[];\r\nexport type Pack<LL extends orArr<LPointerTargetable> | undefined, L extends LPointerTargetable | undefined = unArr<LL>> = L extends undefined ? undefined : Pack1<L> | PackArr<L>;\r\n/*\r\nlet n: any = null;\r\nlet aa: DClass = n;\r\nlet ptrr = Pointers.from(aa.parent);\r\naa.parent = ptrr;*/\r\n\r\n@RuntimeAccessible('PendingPointedByPaths')\r\nexport class PendingPointedByPaths{\r\n    static all: PendingPointedByPaths[] = [];\r\n    // static pendingMoreThanTwice: ParsedAction[] = [];\r\n    static maxSolveAttempts: number = 2099999;\r\n    public solveAttempts: number = 1;\r\n    private stackTrace: string[];\r\n\r\n    // tmp fields, not sure what i need\r\n    public action!: ParsedAction; // todo: remove\r\n    static new(action: ParsedAction, oldState: DState): PendingPointedByPaths {\r\n        const ptr: Pointer = action.value;\r\n        const target: DPointerTargetable | null = oldState.idlookup[ptr as string];\r\n        let pendingPointedBy = new PendingPointedByPaths(action.path, ptr);\r\n        pendingPointedBy.action = action;\r\n        return pendingPointedBy;\r\n    }\r\n\r\n    private constructor(\r\n        public from: DocString<\"full Path in store including field key\">,\r\n        // todo 6: how about actions that do not include index but just += -= [] ?\r\n        public to: Pointer){\r\n        this.stackTrace = U.getStackTrace();\r\n    }\r\n    static attemptimplementationdelete(pb: PointedBy) {\r\n        let state: DState = store.getState();\r\n        let objectChain = U.followPath(state, pb.source);\r\n    }\r\n\r\n    public attemptResolve(state: DState): ParsedAction | null {\r\n        if (this.canBeResolved(state)) return this.resolve();\r\n        return null;\r\n    }\r\n\r\n    private resolve(): ParsedAction{\r\n        U.arrayRemoveAll(PendingPointedByPaths.all, this);\r\n        return Action.parse(SetRootFieldAction.create(\"idlookup.\" + this.to + '.pointedBy', PointedBy.new(this.action.path), '+=', false));\r\n    }\r\n\r\n    public saveForLater(): void { PendingPointedByPaths.all.push(this); }\r\n    private canBeResolved(state: DState): boolean {\r\n        this.solveAttempts++;\r\n        Log.exDev(this.solveAttempts >= PendingPointedByPaths.maxSolveAttempts, \"pending PointedBy action is not revolved for too long, some pointer was wrongly set up.\", this.stackTrace, this, state);\r\n        return !!state.idlookup[this.to]; }\r\n\r\n    static getSolveableActions(oldState: DState): ParsedAction[] {\r\n        let allClone = [...this.all]; // necessary because the array will remove some elements during iteration as they are solved.\r\n        return allClone.map( p => p.attemptResolve(oldState)).filter(p => (!!p)) as ParsedAction[];\r\n    }\r\n}\r\n\r\n@RuntimeAccessible('PointedBy')\r\nexport class PointedBy {\r\n    static list: string[] = [\"father\", \"parent\", \"annotations\", \"packages\", \"type\", \"subpackages\", \"classifiers\", \"exceptions\", \"parameters\", \"defaultValue\", \"instances\", \"operations\", \"features\", \"attributes\", \"references\", \"extends\", \"extendedBy\", \"implements\", \"implementedBy\", \"instanceof\", \"edges\", \"target\", \"opposite\", \"parameters\", \"exceptions\", \"literals\", \"values\"];\r\n    source: string; // elemento da cui parte il puntatore\r\n    // field: keyof DPointerTargetable;\r\n    // il bersaglio non c'√® qui, perch√® √® l'oggetto che contiene questo dentro l'array pointedBy\r\n\r\n    /*private constructor(source: DPointerTargetable, field: any) {\r\n        this.source = source;\r\n        this.field = field;\r\n    }*/\r\n\r\n    static getPath(p: PointedBy) : string { return p.source.substring(0, p.source.lastIndexOf(\".\")); }\r\n    static getLastKey(p: PointedBy) : string { return p.source.substring(p.source.lastIndexOf(\".\")); }\r\n    static getPathArr(p: PointedBy) : string[] { return p.source.split('.'); }\r\n    private constructor(source: string) {\r\n        this.source = source;\r\n    }\r\n    // don't use modifiers here,\r\n    static fromID<D extends DPointerTargetable>(ptr: Pointer<D>, field: keyof D, NoAccessModifiersHere?: never & (\"-=\" | \"+=\")) {\r\n        return PointedBy.new(\"idlookup.\" + ptr + \".\" + field);\r\n    }\r\n    static new(source: DocString<\"full path in store including key. like \\'idlookup.id.extends+=\\'\">, modifier: \"-=\" | \"+=\" | undefined = undefined, action?: ParsedAction): PointedBy {\r\n        // let source: DocString<\"full path in store including key\"> = action.path;\r\n        // if (source.includes(\"true\")) { console.error(this, action); throw new Error(\"mixed a bool\"); }\r\n        if (modifier) source = source.substring(0, source.length - (modifier?.length || 0));\r\n        return new PointedBy(source);\r\n    }\r\n    // static new0<D extends DPointerTargetable> (source: D, field: keyof D): PointedBy { return new PointedBy(source, field); }\r\n\r\n\r\n\r\n    public static remove(oldValue: Pointer | undefined, action: ParsedAction, state: DState, casee: \"+=\" | \"-=\" | undefined = undefined, oldState?:DState): DState {\r\n        if (!oldValue) return state;\r\n        let oldtarget: DPointerTargetable = state.idlookup[oldValue];\r\n        if (!oldtarget) return state;\r\n        let index = -1;\r\n        let actionpath: string = action.path.substring(0, action.path.length -(casee?.length || 0))\r\n        for (let i = 0; i < oldtarget.pointedBy.length; i++) { if (oldtarget.pointedBy[i].source === actionpath) { index = i; break; } }\r\n        if (index < 0) return state;\r\n\r\n        if (oldState === state) state = {...state} as DState;\r\n        if (oldState?.idlookup === state.idlookup) state.idlookup = {...state.idlookup};\r\n        if (oldState?.idlookup[oldValue] === state.idlookup[oldValue]) {\r\n            state.idlookup[oldValue] = {...oldtarget} as any;\r\n        }\r\n        else {\r\n            // no need\r\n        }\r\n        state.idlookup[oldValue].pointedBy.splice(index, 1) // in-place edit\r\n\r\n        // console.warn('pointedby remove:', {from: oldtarget.pointedBy, to: state.idlookup[oldValue].pointedBy, obj: state.idlookup[oldValue], index, oldValue, actionpath});\r\n        return state;\r\n    }\r\n\r\n    // important! must be called only in reducer\r\n    public static add(newtargetptr: Pointer | undefined, action: ParsedAction, state: DState, casee: \"+=\" | \"-=\" | undefined = undefined, oldState?:DState): DState {\r\n        if (!newtargetptr) return state;\r\n        // todo: if can't be done because newtarget doesn't exist, build an action from this and set it pending.\r\n        let newtarget: DPointerTargetable = state.idlookup[newtargetptr];\r\n        if (!newtarget) {\r\n            PendingPointedByPaths.new(action, state).saveForLater(); // {from: action.path, field: action.field, to: target});\r\n            return state;\r\n        }\r\n        /* simpler version but does unnecessary shallow copies\r\n        state = {...state} as DState;\r\n        state.idlookup = {...state.idlookup};\r\n        state.idlookup[newtargetptr] = {...newtarget, pointedBy:  [...newtarget.pointedBy, PointedBy.new(action.path, casee)]} as any;*/\r\n        if (oldState === state) state = {...state} as DState;\r\n        if (oldState?.idlookup === state.idlookup) state.idlookup = {...state.idlookup};\r\n        if (oldState?.idlookup[newtargetptr] === state.idlookup[newtargetptr]) {\r\n            state.idlookup[newtargetptr] = {...newtarget, pointedBy:  [...newtarget.pointedBy, PointedBy.new(action.path, casee)]} as any;\r\n        }\r\n        else {\r\n            state.idlookup[newtargetptr].pointedBy = [...newtarget.pointedBy, PointedBy.new(action.path, casee)];\r\n        }\r\n        // console.warn('pointedby add:', {from: oldtarget.pointedBy, to: state.idlookup[newtargetptr].pointedBy, obj: state.idlookup[newtargetptr]});\r\n        return state;\r\n    }\r\n}\r\n\r\ntype AnyPointer = Pointer<DPointerTargetable, number, number|'N', LPointerTargetable>;\r\n\r\n@RuntimeAccessible('LPointerTargetable')\r\nexport class LPointerTargetable<Context extends LogicContext<DPointerTargetable> = any, D extends DPointerTargetable = DPointerTargetable> extends DPointerTargetable {\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    public static structure: typeof DPointerTargetable;\r\n    public static singleton: LPointerTargetable;\r\n    public __raw!: D;\r\n    public pointedBy!: PointedBy[];\r\n    public clonedCounter?: number;\r\n\r\n    public __isProxy!: boolean;\r\n    public __serialize!: DocString<\"json\">;\r\n    private inspect!: D;\r\n    private __random!: number;\r\n    // public r!: this;\r\n\r\n    private __info_of__id = {type:\"Pointer&lt;this&gt;\",\r\n        txt:\"<a href=\\\"https://github.com/DamianoNaraku/jodel-react/wiki/identifiers\\\">\" +\r\n            \"<span>Unique identifier, and value used to point this object.</span></a>\"};\r\n\r\n    protected wrongAccessMessage(str: string): any {\r\n        let msg = \"Method \"+str+\" should not be called directly, attempting to do so should trigger get_\"+str+\"(). This is only a signature for type checking.\";\r\n        Log.ex(true, msg);\r\n        throw new Error(msg); }\r\n\r\n    public toString(): string { throw this.wrongAccessMessage(\"toString\"); }\r\n    protected get_toString(context: Context): () => string {\r\n        const data = context.data as DNamedElement;\r\n        return () => ( data.name || data.className.substring(0));\r\n        // return () => data.id;\r\n    }\r\n    public toPrimitive(): string { throw this.wrongAccessMessage(\"toPrimitive\"); }\r\n    protected get_toPrimitive(c: Context): ((hint?: \"number\" | \"string\" | \"default\" ) => (number | string)) {\r\n        return (hint?: \"number\" | \"string\" | \"default\") => {\r\n            switch (hint){\r\n                default:\r\n                case \"number\":\r\n                    return c.data.clonedCounter || -1;\r\n                case \"string\":\r\n                case \"default\":\r\n                    return this.get_toString(c)();\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    protected cannotSet(field: string): any { return Log.exx('\"' + field + '\" field is read-only', this); }\r\n    protected get_id(context: Context): this[\"id\"] { return context.data.id; }\r\n    protected set_id(): boolean { return this.cannotSet('id'); }\r\n\r\n    protected _get_default< DD extends DPointerTargetable, T extends string & keyof (DD) & keyof (L), L extends LModelElement = LModelElement>(data: DD, key: T): L[T]{\r\n        // @ts-ignore\r\n        return LPointerTargetable.from(data[key]);\r\n    }\r\n\r\n    _state!: GObject;\r\n    __info_of___state = {type:\"GObject\", txt: `<div>A space where the user can store informations for their operations/views.<br/>\r\n            Example: The Validation viewpoint uses it to store validation messages.<br/>\r\n            WARNING! do not set proxies in the state, set pointers instead.<br/>\r\n            <a href='https://github.com/MDEGroup/jjodel/wiki/L%E2%80%90Object-state'>Learn more on the wiki</a></div>`};\r\n\r\n    // get__state(c: Context): any { return this.wrongAccessMessage('_state',', use obj.state instead.'); }\r\n    // set__state(val: this[\"_state\"], c: Context): boolean { return this.cannotSet('_state', 'use obj.state instead.'); }\r\n    get_state(context: any): any /*this['_state']*/ {\r\n        if (!context.data._state) return {};\r\n        return this.__shallowSolver(context.data._state, true, true); // to solve pointers in state\r\n        // return LPointerTargetable.wrap(context.data._state); // this should work, because data._state have id = this.id+\"._state\"\r\n    }\r\n    set_state(val: any, c: Context): boolean {\r\n        // todo: put those lobjects -> pointer checks into defaultsetter to improve it\r\n\r\n        // 3 options:\r\n        // 1) if state === node, then setting whole state is invalid\r\n        // 2) if state is a proxified obj with id = node.id+\".state\" so actions and proxy getters/setters will act on the subobject properties still invalid setting whole obj.\r\n        // 3) forbid to set the whole state, merge old state with new one, if val === undefined, state is reset.\r\n\r\n        // i choose 3)\r\n        let newState: GObject;\r\n        let oldState = c.data._state ? {...c.data._state} : {};\r\n        let changed: boolean = false;\r\n        if (val === undefined) {\r\n            if (!oldState || !Object.keys(oldState).length) return true;\r\n            newState = {};\r\n            changed = true;\r\n        }\r\n        else if (typeof val !== \"object\") { Log.ee(\"state can only be assigned with an object or undefined\"); return true; }\r\n        else {\r\n            val = this.__sanitizeValue(val);\r\n            newState = {...oldState};\r\n            for (let k in val) {\r\n                if (val[k] === undefined) {\r\n                    if (oldState[k] === undefined) continue;\r\n                    delete newState[k];\r\n                    changed = true;\r\n                    continue;\r\n                }\r\n\r\n                if (oldState[k] === val[k]) continue;\r\n                newState[k] = val[k];\r\n                changed = true;\r\n            }\r\n        }\r\n\r\n        if (!changed) return true;\r\n\r\n        SetFieldAction.new(c.data, \"_state\", newState, undefined, false);\r\n        return true;\r\n    }\r\n    protected __sanitizeValue(val: any, canEditVal: boolean = true, canEditValDeep:boolean = false): any{\r\n        if (val === undefined) { return val; }\r\n        if (val.__isProxy || val.id && val.className) return val.id;\r\n        // if (typeof val === \"string\") { return val; } else\r\n        if (typeof val !== \"object\") { return val; }\r\n        else if (Array.isArray(val)) { return val.map(v => this.__sanitizeValue(v, canEditValDeep, canEditValDeep)); }\r\n        // case val is object not array, not proxy, not D. just a POJO\r\n        let ret = canEditVal ? val : {...val};\r\n        for (let k in val) {\r\n            if (Array.isArray(val[k])) ret[k] = val[k].map((v: any)=> v && (v.__isProxy || v.id && v.className) ? v.id : v);\r\n            else if (val[k] && (val[k].__isProxy || val[k].id && val[k].className)) ret[k] = val[k].id;\r\n        }\r\n        return ret;\r\n\r\n    }\r\n\r\n    // protected _defaultCollectionGetter(c: Context, k: keyof Context[\"data\"]): LPointerTargetable[] { return LPointerTargetable.fromPointer((c.data as any)[k]); }\r\n    protected _defaultGetter(c: Context, k: keyof Context[\"data\"]): any {\r\n        return this.__defaultGetter(c, k);\r\n    }\r\n    protected _defaultSetter(v0: any, c: Context, k: keyof Context[\"data\"]): boolean {\r\n        this.__defaultSetter(v0, c, k);\r\n        return true;\r\n    }\r\n    protected __defaultGetter(c: Context, k: keyof Context[\"data\"]): any {\r\n        // console.log(\"default Getter\");\r\n        let v = (c.data as any)[k];\r\n        return this.__shallowSolver(v, true, false);\r\n    }\r\n    protected __shallowSolver<T>(val: any, solveArrayValues: boolean, solveObjectKeys: boolean): any {\r\n        if (!val) return val;\r\n        let state: DState = store.getState();\r\n        if (solveArrayValues && Array.isArray(val)) {\r\n            if (val.length === 0) return [];\r\n            return val.map(v => LPointerTargetable.attemptWrap(v));\r\n            // else if (Pointers.isPointer(val[0] as any)) return LPointerTargetable.fromArr(val, state);\r\n            // return val;\r\n        }\r\n        if (solveObjectKeys && typeof val === \"object\"){\r\n            let ret = {...val};\r\n            for (let key in val){\r\n                ret[key] = LPointerTargetable.attemptWrap(val[key]);\r\n            }\r\n            return ret;\r\n        }\r\n        return val && Pointers.isPointer(val as any, undefined) ? LPointerTargetable.fromPointer(val, state) : val;\r\n    }\r\n\r\n    protected __defaultSetter(v0: any, c: Context, k: keyof Context[\"data\"]): boolean {\r\n        // todo: get the those lobjects -> pointer checks from set_state\r\n        let v: any = this.__sanitizeValue(v0, false, false);\r\n        if (true || k in c.data) {\r\n            // check if is pointer\r\n            let isPointer: boolean;\r\n            if (Array.isArray(v)) {\r\n                if (v.length === 0) isPointer = true; // assumed, should not cause harm if it is not.\r\n                    // it will delete remove an entry in pointedBy from all oldValue entries in the array that should not be present anyway.\r\n                // like oldVal.map( id => U.arrayRemove(LData.wrap(id).pointedBy, c.data.this_id)\r\n                else isPointer = Pointers.isPointer(v[0] as any);\r\n            } else isPointer = Pointers.isPointer(v);\r\n\r\n            // autofix value\r\n            let bytes = 0;\r\n            let type: string = (this as any)[\"__info_of__\"+k]?.type;\r\n            if (type) type = U.multiReplaceAll(type, [\"array\", \"Array\", \"<\", \">\", \"[]\"], []);\r\n            switch(type){\r\n                case ShortAttribETypes.EDate: break;\r\n                default: break;\r\n                case ShortAttribETypes.EBoolean: v = !!v; break;\r\n                case ShortAttribETypes.EByte: bytes = 8; break;\r\n                case ShortAttribETypes.EShort: bytes = 16; break;\r\n                case ShortAttribETypes.EInt: bytes = 32; break;\r\n                case ShortAttribETypes.ELong: bytes = 64; break;\r\n                case ShortAttribETypes.EString: v = \"\"+v; break;\r\n                case ShortAttribETypes.EChar: v = (\"\"+v)[0]; break;\r\n                case ShortAttribETypes.EVoid: Log.exx(\"cannot set a void-typed value\", {c, d:c.data, k, v}); return true;\r\n                case ShortAttribETypes.EDouble:\r\n                case ShortAttribETypes.EFloat: v = +v; break;\r\n            }\r\n            if (bytes) {\r\n                v = Math.round(+v);\r\n                let max = v << bytes; // left shift is the same as multiplying by a power of 2, but binary and more efficient.\r\n                let min = -max + 1\r\n                if (v > max) v = max;\r\n                else if (v < min) v = min;\r\n            }\r\n            console.log(\"default Setter[\"+k+\"] = \" + v , {type, v, v0, oldv:(c.data as any)[k], isPointer});\r\n            SetFieldAction.new(c.data, k as any, v, '', isPointer);\r\n            return true;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    public get__extends(superClassName: string, context: LogicContext<DPointerTargetable>): boolean {\r\n        return RuntimeAccessibleClass.extends(context.data.className, superClassName);\r\n    }\r\n\r\n    /*\r\n    public get_pointedBy(superClassName: string, context: LogicContext<DPointerTargetable>): LPointerTargetable[] {\r\n        let state: GObject = windoww.store.getState();\r\n        function getForemostObjectInPath(path: DocString<'storePath'>): undefined | LPointerTargetable {\r\n            let lastPointableObject: undefined | DPointerTargetable;\r\n            let pathArray = path.split('.');\r\n            for (let key of pathArray) {\r\n                let currentObj: GObject = state[key];\r\n                if (!currentObj) break;\r\n                if (currentObj && currentObj.id && state.idlookup[currentObj.id]) lastPointableObject = state.idlookup[currentObj.id];\r\n            }\r\n            return lastPointableObject && DPointerTargetable.wrap(lastPointableObject);\r\n        }\r\n        return (context.data.pointedBy || []).map(getForemostObjectInPath).filter( lobj => !!lobj) as LPointerTargetable[];\r\n    }*/\r\n\r\n    public set_pointedBy(val: never, context: LogicContext<DPointerTargetable>): boolean {\r\n        windoww.Log.exx('pointedBy field should never be directly edited.', {context, val});\r\n        return false;\r\n    }\r\n\r\n\r\n\r\n\r\n    static fromD<DX extends DPointerTargetable,\r\n        LX = DX extends DEnumerator ? LEnumerator : (DX extends DAttribute ? LAttribute : (DX extends DReference ? LReference : (DX extends DRefEdge ? LRefEdge : (DX extends DExtEdge ? LExtEdge : (DX extends DDataType ? LDataType : (DX extends DClass ? LClass : (DX extends DStructuralFeature ? LStructuralFeature : (DX extends DParameter ? LParameter : (DX extends DOperation ? LOperation : (DX extends DEdge ? LEdge : (DX extends DEdgePoint ? LEdgePoint : (DX extends DGraphVertex ? LGraphVertex : (DX extends DModel ? LModel : (DX extends DValue ? LValue : (DX extends DObject ? LObject : (DX extends DEnumLiteral ? LEnumLiteral : (DX extends DPackage ? LPackage : (DX extends DClassifier ? LClassifier : (DX extends DTypedElement ? LTypedElement : (DX extends DVertex ? LVertex : (DX extends DVoidEdge ? LVoidEdge : (DX extends DVoidVertex ? LVoidVertex : (DX extends DGraph ? LGraph : (DX extends DNamedElement ? LNamedElement : (DX extends DAnnotation ? LAnnotation : (DX extends DGraphElement ? LGraphElement : (DX extends DMap ? LMap : (DX extends DModelElement ? LModelElement : (DX extends DUser ? LUser : (DX extends DPointerTargetable ? LPointerTargetable : (ERROR))))))))))))))))))))))))))))))),\r\n        >(data: DX): LX;\r\n    static fromD<DX extends DPointerTargetable,\r\n        LX = DX extends DEnumerator ? LEnumerator : (DX extends DAttribute ? LAttribute : (DX extends DReference ? LReference : (DX extends DRefEdge ? LRefEdge : (DX extends DExtEdge ? LExtEdge : (DX extends DDataType ? LDataType : (DX extends DClass ? LClass : (DX extends DStructuralFeature ? LStructuralFeature : (DX extends DParameter ? LParameter : (DX extends DOperation ? LOperation : (DX extends DEdge ? LEdge : (DX extends DEdgePoint ? LEdgePoint : (DX extends DGraphVertex ? LGraphVertex : (DX extends DModel ? LModel : (DX extends DValue ? LValue : (DX extends DObject ? LObject : (DX extends DEnumLiteral ? LEnumLiteral : (DX extends DPackage ? LPackage : (DX extends DClassifier ? LClassifier : (DX extends DTypedElement ? LTypedElement : (DX extends DVertex ? LVertex : (DX extends DVoidEdge ? LVoidEdge : (DX extends DVoidVertex ? LVoidVertex : (DX extends DGraph ? LGraph : (DX extends DNamedElement ? LNamedElement : (DX extends DAnnotation ? LAnnotation : (DX extends DGraphElement ? LGraphElement : (DX extends DMap ? LMap : (DX extends DModelElement ? LModelElement : (DX extends DUser ? LUser : (DX extends DPointerTargetable ? LPointerTargetable : (ERROR))))))))))))))))))))))))))))))),\r\n        >(data: DX[]): LX[];\r\n    static fromD(data: any): any {\r\n        // return null as any;\r\n        if (Array.isArray(data)) return LPointerTargetable.wrapAll(data) as any;\r\n        return LPointerTargetable.wrap(data) as any;\r\n    }\r\n\r\n\r\n    static fromPointer<\r\n        T extends AnyPointer | AnyPointer[], // <DPointerTargetable, 1, 'N', LPointerTargetable>,\r\n        DDD extends (T extends Pointer<any, any, any, infer D> ? D : 'undefined L'),\r\n        LOW extends (T extends Pointer<any, infer LO> ? LO : 'undefined_upp'),\r\n        UPP extends (T extends Pointer<any, number, infer UP> ? UP : 'undefined_low'),\r\n\r\n        DDDARR extends (T extends Pointer<any, any, any, infer D>[] ? D : 'undefined_DARR'),\r\n        LOWARR extends (T extends Pointer<any, infer LO>[] ? LO : 'undefined_uppARR'),\r\n        UPPARR extends (T extends Pointer<any, number, infer UP>[] ? 'UP_is_N' : 'undefined_lowARR'),\r\n\r\n        RET = UPPARR extends 'UP_is_N' ?\r\n            (DDDARR[]) : // 0...N\r\n            (UPP extends 1 ? (LOW extends 0 ? DDD | null : DDD) : // 0...1 && 1...1\r\n                (LOW extends 1 ? DDD : undefined)  //1...1\r\n                ),\r\n        INFERRED = {ret: RET, upp: UPP, low:LOW, ddd: DDD, dddARR: DDDARR, lowARR: LOWARR, uppARR: UPPARR},>(ptr: T | undefined, state?: DState)\r\n        : RET {\r\n        // return null as any;\r\n        if (Array.isArray(ptr)) return LPointerTargetable.wrapAll(ptr as any, undefined, '', false, state) as any;\r\n        return LPointerTargetable.wrap(ptr) as any;\r\n    }\r\n    static fromArr(...a:any): any; // because otherwise it complains about inheriting from DPointerTargetable.fromArr\r\n    static fromArr<\r\n        PTR extends Pointer | Pointer[], // <DPointerTargetable, 1, 'N', LPointerTargetable>,\r\n        // DDD extends (PTR extends Pointer<infer D> ? D : 'undefined_D'),\r\n        LOW extends (PTR extends Pointer<any, infer LO> ? LO : 'undefined_upp'),\r\n        UPP extends (PTR extends Pointer<any, number, infer UP> ? UP : 'undefined_low'),\r\n        DDD extends (PTR extends Pointer<any, number, any, infer LL> ? LL : 'undefined_L'),\r\n\r\n        LOWARR extends (PTR extends Pointer<any, infer LO>[] ? LO : 'undefined_uppARR'),\r\n        UPPARR extends (PTR extends Pointer<any, number, infer UP>[] ? 'UP_is_N' : 'undefined_lowARR'),\r\n        DDDARR extends (PTR extends Pointer<any, any, any, infer LL>[] ? LL : 'undefined_LARR'),\r\n\r\n        DX extends DPointerTargetable,\r\n\r\n        RETPTR = UPPARR extends 'UP_is_N' ?\r\n            (DDDARR[]) : // 0...N\r\n            (UPP extends 1 ? (LOW extends 0 ? DDD | null : DDD) : // 0...1 && 1...1\r\n                (LOW extends 1 ? DDD : undefined)  //1...1\r\n                ),\r\n\r\n        // DX = LX extends LEnumerator ? DEnumerator : (LX extends LAttribute ? DAttribute : (LX extends LReference ? DReference : (LX extends LDataType ? DDataType : (LX extends LClass ? DClass : (LX extends LStructuralFeature ? DStructuralFeature : (LX extends LParameter ? DParameter : (LX extends LOperation ? DOperation : (LX extends LModel ? DModel : (LX extends LValue ? DValue : (LX extends LObject ? DObject : (LX extends LEnumLiteral ? DEnumLiteral : (LX extends LPackage ? DPackage : (LX extends LClassifier ? DClassifier : (LX extends LTypedElement ? DTypedElement : (LX extends LNamedElement ? DNamedElement : (LX extends LAnnotation ? DAnnotation : ('ERROR'))))))))))))))))),\r\n        LX = DX extends DEnumerator ? LEnumerator : (DX extends DAttribute ? LAttribute : (DX extends DReference ? LReference : (DX extends DRefEdge ? LRefEdge : (DX extends DExtEdge ? LExtEdge : (DX extends DDataType ? LDataType : (DX extends DClass ? LClass : (DX extends DStructuralFeature ? LStructuralFeature : (DX extends DParameter ? LParameter : (DX extends DOperation ? LOperation : (DX extends DEdge ? LEdge : (DX extends DEdgePoint ? LEdgePoint : (DX extends DGraphVertex ? LGraphVertex : (DX extends DModel ? LModel : (DX extends DValue ? LValue : (DX extends DObject ? LObject : (DX extends DEnumLiteral ? LEnumLiteral : (DX extends DPackage ? LPackage : (DX extends DClassifier ? LClassifier : (DX extends DTypedElement ? LTypedElement : (DX extends DVertex ? LVertex : (DX extends DVoidEdge ? LVoidEdge : (DX extends DVoidVertex ? LVoidVertex : (DX extends DGraph ? LGraph : (DX extends DNamedElement ? LNamedElement : (DX extends DAnnotation ? LAnnotation : (DX extends DGraphElement ? LGraphElement : (DX extends DMap ? LMap : (DX extends DModelElement ? LModelElement : (DX extends DUser ? LUser : (DX extends DPointerTargetable ? LPointerTargetable : (ERROR))))))))))))))))))))))))))))))),\r\n        RET = LX extends 'ERROR' ? RETPTR : (RETPTR extends LX ? RETPTR : LX),\r\n        INFERRED = {ret: RET, RETPTR: RETPTR, upp: UPP, low:LOW, ddd: DDD, dddARR: DDDARR, lowARR: LOWARR, uppARR: UPPARR, LX:LX, DX:DX}>(ptr: PTR[] | DX[], state?: DState)\r\n        : RET[] {\r\n        return LPointerTargetable.from(ptr as any, state); }\r\n\r\n    static from<// LOW extends number, UPP extends number | 'N',\r\n        PTR extends Pointer<DPointerTargetable, 0|1, 1|'N', LPointerTargetable> | Pointer[], // <DPointerTargetable, 1, 'N', LPointerTargetable>,\r\n        // DDD extends (PTR extends Pointer<infer D> ? D : 'undefined_D'),\r\n        LOW extends (PTR extends Pointer<any, infer LO> ? LO : 'undefined_upp'),\r\n        UPP extends (PTR extends Pointer<any, number, infer UP> ? UP : 'undefined_low'),\r\n        DDD extends (PTR extends Pointer<any, number, any, infer LL> ? LL : 'undefined_L'),\r\n\r\n        LOWARR extends (PTR extends Pointer<any, infer LO>[] ? LO : 'undefined_uppARR'),\r\n        UPPARR extends (PTR extends Pointer<any, number, infer UP>[] ? 'UP_is_N' : 'undefined_lowARR'),\r\n        DDDARR extends (PTR extends Pointer<any, any, any, infer LL>[] ? LL : 'undefined_LARR'),\r\n\r\n        DX extends DPointerTargetable,\r\n\r\n        RETPTR = UPPARR extends 'UP_is_N' ?\r\n            (DDDARR[]) : // 0...N\r\n            (UPP extends 1 ? (LOW extends 0 ? DDD | null : DDD) : // 0...1 && 1...1\r\n                (LOW extends 1 ? DDD : undefined)  //1...1\r\n                ),\r\n\r\n\r\n        // DX = LX extends LEnumerator ? DEnumerator : (LX extends LAttribute ? DAttribute : (LX extends LReference ? DReference : (LX extends LDataType ? DDataType : (LX extends LClass ? DClass : (LX extends LStructuralFeature ? DStructuralFeature : (LX extends LParameter ? DParameter : (LX extends LOperation ? DOperation : (LX extends LModel ? DModel : (LX extends LValue ? DValue : (LX extends LObject ? DObject : (LX extends LEnumLiteral ? DEnumLiteral : (LX extends LPackage ? DPackage : (LX extends LClassifier ? DClassifier : (LX extends LTypedElement ? DTypedElement : (LX extends LNamedElement ? DNamedElement : (LX extends LAnnotation ? DAnnotation : ('ERROR'))))))))))))))))),\r\n        LX = DX extends DEnumerator ? LEnumerator : (DX extends DAttribute ? LAttribute : (DX extends DReference ? LReference : (DX extends DRefEdge ? LRefEdge : (DX extends DExtEdge ? LExtEdge : (DX extends DDataType ? LDataType : (DX extends DClass ? LClass : (DX extends DStructuralFeature ? LStructuralFeature : (DX extends DParameter ? LParameter : (DX extends DOperation ? LOperation : (DX extends DEdge ? LEdge : (DX extends DEdgePoint ? LEdgePoint : (DX extends DGraphVertex ? LGraphVertex : (DX extends DModel ? LModel : (DX extends DValue ? LValue : (DX extends DObject ? LObject : (DX extends DEnumLiteral ? LEnumLiteral : (DX extends DPackage ? LPackage : (DX extends DClassifier ? LClassifier : (DX extends DTypedElement ? LTypedElement : (DX extends DVertex ? LVertex : (DX extends DVoidEdge ? LVoidEdge : (DX extends DVoidVertex ? LVoidVertex : (DX extends DGraph ? LGraph : (DX extends DNamedElement ? LNamedElement : (DX extends DAnnotation ? LAnnotation : (DX extends DGraphElement ? LGraphElement : (DX extends DMap ? LMap : (DX extends DModelElement ? LModelElement : (DX extends DUser ? LUser : (DX extends DPointerTargetable ? LPointerTargetable : (ERROR))))))))))))))))))))))))))))))),\r\n        RET = LX extends 'ERROR' ? RETPTR : (RETPTR extends LX ? RETPTR : LX),\r\n        INFERRED = {ret: RET, RETPTR: RETPTR, upp: UPP, low:LOW, ddd: DDD, dddARR: DDDARR, lowARR: LOWARR, uppARR: UPPARR, LX:LX, DX:DX}>(ptr: PTR | DX, s?: DState)\r\n        : RET {\r\n        // return null as any;\r\n        if (Array.isArray(ptr)) return LPointerTargetable.wrapAll(ptr) as any;\r\n        return LPointerTargetable.wrap(ptr as any) as any;\r\n    }\r\n\r\n    // static from0(a: any, ...aa: any): any { return null; }\r\n\r\n    /* OLD DELETE\r\n    public delete(): void { throw this.wrongAccessMessage(\"delete\"); }\r\n    public _delete(context: Context): void { new DeleteElementAction(context.data); }\r\n    protected get_delete(context: Context): () => void {\r\n        return () => {\r\n            alert(\"Delete in LPOINTER\")\r\n            this._delete(context);\r\n        }\r\n    }\r\n    */\r\n    public dependencies(): Dependency[] { return []; }\r\n    protected get_dependencies(context: Context): () => Dependency[] {\r\n        const data = context.proxyObject;\r\n        const dependencies: Dependency[] = [];\r\n        const ret = () => {\r\n            for(let pointedBy of data.pointedBy) {\r\n                const raw = pointedBy.source.split('.');\r\n                let root = raw[0];\r\n                const obj = raw[1] || '';\r\n                let field = raw[2] || '';\r\n\r\n                // Delete chars from end that are not in [azAZ].\r\n                const regex = /[^a-zA-Z]+$/;\r\n                root = root.replace(regex, '');\r\n                field = field.replace(regex, '');\r\n                // damiano: this is likely to cause a bug for sure somewhere when a key ends with \"s\" but is not an array. keep in mind when naming variables.\r\n                let op: ''|'-=' = (field && field.endsWith('s')) ? '-=' : '';\r\n                if(!field && root.endsWith('s')) op = '-=';\r\n\r\n                const dependency: Dependency = {root: root  as keyof DState, obj, field: field as keyof DPointerTargetable, op};\r\n                if(!dependencies.includes(dependency)) dependencies.push(dependency);\r\n            }\r\n            return dependencies\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    public delete(): void {}\r\n    protected get_delete(context: Context): () => void {\r\n        const data: LPointerTargetable & GObject = context.proxyObject;\r\n        const dependencies = data.dependencies();\r\n\r\n        const ret = () => {\r\n            for(let child of data.children) {\r\n                child.delete();\r\n                // todo: if a m1-dvalue which conforms to a m2-reference with \"containment\" is deleted, need to delete also target.\r\n                // maybe better to do through override?\r\n                child.node?.delete();\r\n            }\r\n\r\n            for (let dependency of dependencies) {\r\n                const root = dependency.root;\r\n                const obj = dependency.obj;\r\n                const field = dependency.field;\r\n                const op = dependency.op;\r\n                const val = (op === '-=') ? data.id : '';\r\n                if((root === 'idlookup') && obj && field) {\r\n                    console.log('Delete', `SetFieldAction.new('${obj}', '${field}', '${val}', '${op}');`);\r\n                    SetFieldAction.new(obj, field, val, op, false);\r\n                } else {\r\n                    console.log('Delete', `SetRootFieldAction.new('${root}', '${val}', '${op}');`);\r\n                    SetRootFieldAction.new(root, val, op, false);\r\n                }\r\n            }\r\n            if (data.nodes) data.nodes.map((node: any) => node.delete());\r\n\r\n            SetRootFieldAction.new('ELEMENT_DELETED', data.id, '+=', false); // here no need to IsPointer because it only affects Transient stuff\r\n            SetRootFieldAction.new('idlookup', data.id, '-=', false); // damiano: shouldn't be isPointer = true?\r\n            DeleteElementAction.new(data.id);\r\n        };\r\n        return () => TRANSACTION(ret);\r\n    }\r\n}\r\nRuntimeAccessibleClass.set_extend(RuntimeAccessibleClass, LPointerTargetable);\r\n\r\n@RuntimeAccessible('D') export class D extends DPointerTargetable{}\r\n@RuntimeAccessible('L') export class L extends LPointerTargetable{}\r\n@RuntimeAccessible('P') export class P extends Pointers{}\r\n\r\n/*\r\nlet pttr: Pointer<DClassifier, 0, 1, LClassifier> = null as any;\r\nlet ptrany: Pointer<DClassifier, 0|1, 1|'N'>[] = null as any;\r\nlet ptrarr: Pointer<DClassifier>[] = null as any;\r\nlet ptrarr2: Pointer<DClassifier, 1, 'N'> = null as any;\r\nlet d: DClassifier = null as any;\r\nlet darr: DClassifier[] = null as any;\r\n\r\ntype VoidPtr = null | undefined | '';\r\nfunction dfrom<\r\n    PARAM extends orArr<AnyPointer | VoidPtr>,//orArr<WPointerTargetable | LPointerTargetable | DPointerTargetable | AnyPointer>,\r\n\r\n\r\n    DDD extends (PARAM extends Pointer<infer DD> ? DD : 'undefined_D'),\r\n    LOW extends (PARAM extends Pointer<any, infer LO> ? LO : 'undefined_low'),\r\n    LOW0 extends (PARAM extends Pointer<any, 0, any, any> ? 0 : never),\r\n    LOW1 extends (PARAM extends Pointer<any, 1, any, any> ? 1 : never),\r\n    LOW2 extends (VoidPtr extends PARAM ? 0 | 'first' : (PARAM extends VoidPtr ? 0 | 1 | 'second': 1|'third')),\r\n    UPP extends (PARAM extends Pointer<any, number, infer UP> ? UP : 'undefined_upp'),\r\n    LLL extends (PARAM extends Pointer<any, number, any, infer LL> ? LL : 'undefined_L'),\r\n\r\n\r\n\r\n    ISVOID extends PARAM extends VoidPtr  ? 'isvoid' : never,\r\n    ISARR extends PARAM extends [] ? true : false,\r\n    ISPTR extends (PARAM extends AnyPointer | VoidPtr ? 'ptr' : never),\r\n    ISPTRARR extends (PARAM extends (AnyPointer | VoidPtr)[] | Pointer<DPointerTargetable, 1|0, 'N', LPointerTargetable> ? 'ptr_arr' : never),\r\n    ISD extends (PARAM extends DPointerTargetable ? 'd' : never),\r\n    ISDARR extends (PARAM extends DPointerTargetable[] ? 'd_arr' : never),\r\n    ISL extends (PARAM extends LPointerTargetable ? 'l' : never),\r\n    ISLARR extends (PARAM extends LPointerTargetable[] ? 'l_arr' : never),\r\n    ISW extends (PARAM extends WPointerTargetable ? 'w' : never),\r\n    ISWARR extends (PARAM extends WPointerTargetable[] ? 'w_arr' : never),\r\n    // INFER = {LOW:LOW, UPP:UPP, DDD:DDD, LLL:LLL, LOW2:LOW2},\r\n    INFER = { LOW2:LOW2},\r\n    RET = ISVOID | ISPTR | ISPTRARR | ISD | ISDARR | ISL | ISLARR | ISW | ISWARR | INFER\r\n    >\r\n(ptr: PARAM): RET { return null as any; }\r\nlet Lptr = dfrom(pttr as Pointer<DClassifier, 0, 1, LClassifier> );\r\nlet Lptrany = dfrom(ptrany);\r\nlet Lptrarr = dfrom(ptrarr);\r\nlet Lptrarr2 = dfrom(ptrarr2);\r\nlet Ld = dfrom(d);\r\nlet Ldarr = dfrom(darr);*/\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n@RuntimeAccessible('WPointerTargetable')\r\nexport class WPointerTargetable extends DPointerTargetable{\r\n    id!: never;\r\n    _storePath!: never;\r\n    _subMaps!: never;\r\n    pointedBy!: never;\r\n    // todo: WfromD, WfromL, WfromPointer, Wfrom\r\n\r\n    static fromD<DX extends DPointerTargetable, WX extends DtoW<DX>>(data: DX): WX { return LPointerTargetable.fromD(data) as any; }\r\n}\r\nRuntimeAccessibleClass.set_extend(DPointerTargetable, LPointerTargetable);\r\nRuntimeAccessibleClass.set_extend(DPointerTargetable, WPointerTargetable);\r\nfunction fffff<DX, LX = DX extends DRefEdge ? LRefEdge : 'not'>( t: DX): LX { return null as any; }\r\nlet a: DGraphElement = null as any;\r\nlet bbb = LPointerTargetable.from(a);\r\nlet bb2 = fffff(a);\r\n\r\n@Leaf\r\n@RuntimeAccessible('DUser')\r\nexport class DUser extends DPointerTargetable {\r\n    public static offlineMode: boolean = !!localStorage.getItem(\"offlineMode\");\r\n    public static isStateMachine = false;\r\n    // static current: Pointer<DUser> = 'Pointer_AnonymousUser';\r\n    static current: Pointer<DUser> = '';\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    id!: Pointer<DUser>;\r\n    username!: string;\r\n    token!: string;\r\n    projects: Pointer<DProject, 0, 'N', LProject> = [];\r\n    project: Pointer<DProject, 0, 1, LProject> = '';\r\n    __isUser: true = true; // necessary to trick duck typing to think this is NOT the superclass of anything that extends PointerTargetable.\r\n    /*public static new(id?: DUser[\"id\"], triggerActions: boolean = true): DUser {\r\n        return new Constructors(new DUser('dwc'), undefined, false, undefined, id, true).DPointerTargetable().DUser().end(); }*/\r\n    public static new(username: string, id?: DUser['id'], persist: boolean = true): DUser {\r\n        return new Constructors(new DUser('dwc'), undefined, persist, undefined, id).DPointerTargetable().DUser(username).end();\r\n    }\r\n}\r\n\r\n@RuntimeAccessible('LUser')\r\nexport class LUser<Context extends LogicContext<DUser> = any, D extends DUser = DUser> extends LPointerTargetable {\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    public __raw!: DUser;\r\n    id!: Pointer<DUser>;\r\n    username!: string;\r\n    projects!: LProject[];\r\n    project!: LProject|null;\r\n    __isUser!: true;\r\n\r\n    protected get_projects(context: Context): this['projects'] {\r\n        return LProject.fromPointer(context.data.projects);\r\n    }\r\n    protected set_projects(val: PackArr<this['projects']>, context: Context): boolean {\r\n        const data = context.data;\r\n        SetFieldAction.new(data.id, 'projects', Pointers.from(val), '', true);\r\n        return true;\r\n    }\r\n\r\n    protected get_project(context: Context): this['project'] {\r\n        const project = context.data.project;\r\n        if(project) return LProject.fromPointer(project);\r\n        return null;\r\n    }\r\n    protected set_project(val: Pack<Exclude<this['project'], null>>|null, context: Context): boolean {\r\n        const data = context.data;\r\n        if(val === null) SetFieldAction.new(data.id, 'project', '', '', false);\r\n        else SetFieldAction.new(data.id, 'project', Pointers.from(val), '', true);\r\n        return true;\r\n    }\r\n}\r\n\r\nRuntimeAccessibleClass.set_extend(DPointerTargetable, DUser);\r\nRuntimeAccessibleClass.set_extend(LPointerTargetable, LUser);\r\nexport type WUser = getWParams<LUser, DUser>;\r\n\r\n@Leaf\r\n@RuntimeAccessible('DProject')\r\nexport class DProject extends DPointerTargetable {\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n\r\n    id!: Pointer<DProject, 1, 1, LProject>;\r\n    type: 'public'|'private'|'collaborative' = 'collaborative';\r\n    name!: string;\r\n    author: Pointer<DUser> = DUser.current;\r\n    collaborators: Pointer<DUser, 0, 'N'> = [];\r\n    onlineUsers : number = 0;\r\n    metamodels: Pointer<DModel, 0, 'N'> = [];\r\n    models: Pointer<DModel, 0, 'N'> = [];\r\n    graphs: Pointer<DGraph, 0, 'N'> = [];\r\n    // views: Pointer<DViewElement, 0, 'N'> = []; // can be retrieved from viewpoints.subviews\r\n    // stackViews: Pointer<DViewPoint, 0, 'N'> = []; // ??\r\n    viewpoints: Pointer<DViewPoint, 0, 'N'> = [];\r\n    activeViewpoint: Pointer<DViewPoint, 1, 1> = Defaults.viewpoints[0];\r\n    favorite!: Dictionary<Pointer<DUser>, true | undefined>;\r\n    description!: string;\r\n    // collaborators dict user: priority\r\n\r\n    state!: string;\r\n\r\n    public static new(type: DProject['type'], name?: string, state?: DProject['state'],\r\n                      m2?: DProject['metamodels'], m1?: DProject['models'], id?: DProject['id'], otherProjects?:LProject[]): DProject {\r\n\r\n        // fix name\r\n        if (!otherProjects) otherProjects = LPointerTargetable.fromPointer(DUser.current).projects;\r\n        if (!name) {\r\n            // autofix default name\r\n            let regexp = /Project (\\d+)/;\r\n            const matches = otherProjects.map(p=>(+(regexp.exec(p.name)?.[1] as any) || 0));\r\n            let maxnum = Math.max(...matches, 0);\r\n            name = 'Project ' + ( 1 + maxnum);\r\n        }\r\n        else {\r\n            // autofix manually inputted name\r\n            let allProjectNames: Dictionary<string, LProject> = U.objectFromArray(otherProjects, (p)=>p.name);\r\n            name = U.increaseEndingNumber(name, false, false, (s)=>!!allProjectNames[s]);\r\n        }\r\n\r\n        return new Constructors(new DProject('dwc'), undefined, true, undefined)\r\n            .DPointerTargetable().DProject(type, name, state || '', m2 || [], m1 || [], id).end(); }\r\n}\r\n\r\n@RuntimeAccessible('LProject')\r\nexport class LProject<Context extends LogicContext<DProject> = any, D extends DProject = DProject> extends LPointerTargetable {\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n\r\n    readonly id!: Pointer<DProject>;\r\n    type!: 'public'|'private'|'collaborative';\r\n    author!: LUser;\r\n    collaborators!: LUser[];\r\n    onlineUsers!: number;\r\n    name!: string;\r\n    metamodels!: LModel[];\r\n    models!: LModel[];\r\n    graphs!: LGraph[];\r\n    // stackViews!: LViewElement[];\r\n    viewpoints!: LViewPoint[];\r\n    activeViewpoint!: LViewPoint;\r\n    favorite!: boolean;\r\n    description!: string;\r\n\r\n    // stringify state\r\n    state!: string;\r\n\r\n    /* DATA */\r\n    readonly packages!: LPackage[];\r\n    readonly classes!: LClass[];\r\n    readonly attributes!: LAttribute[];\r\n    readonly references!: LReference[];\r\n    readonly operations!: LOperation[];\r\n    readonly parameters!: LParameter[];\r\n    readonly enumerators!: LEnumerator[];\r\n    readonly literals!: LEnumLiteral[];\r\n    readonly objects!: LObject[];\r\n    readonly values!: LValue[];\r\n\r\n    /* NODES */\r\n    readonly allNodes!: NodeTypes[];\r\n    readonly graphVertexes!: LGraphVertex[];\r\n    readonly voidVertexes!: LVoidVertex[];\r\n    readonly vertexes!: LVertex[];\r\n    readonly fields!: LGraphElement[];\r\n    readonly edges!: LEdge[];\r\n    readonly edgePoints!: LEdgePoint[];\r\n\r\n    /* UTILS */\r\n    readonly children!: LPointerTargetable[];\r\n    readonly views!: LViewElement[]; // derived from viewpoints.subView\r\n\r\n    /* Functions */\r\n\r\n    protected get_favorite(c: Context): this['favorite'] {\r\n        const uid = DUser.current;\r\n        if (!c.data.favorite) return false;\r\n        return !!c.data.favorite[uid];\r\n    }\r\n    protected set_favorite(v: boolean, c: Context): true {\r\n        let favMap = c.data.favorite;\r\n        if (!favMap) {\r\n            favMap = {};\r\n            SetFieldAction.new(c.data.id, 'favorite', favMap);\r\n        }\r\n        const uid = DUser.current;\r\n        if (v) { // case favorite\r\n            if (favMap[uid]) return true;\r\n            SetFieldAction.new(c.data.id, 'favorite', {[uid]: true}, '+=');\r\n        }\r\n        else { // case un-favorite\r\n            if (!favMap[uid]) return true;\r\n            SetFieldAction.new(c.data.id, 'favorite', {[uid]: undefined} as any, '-=');\r\n        }\r\n        return true;\r\n    }\r\n    protected get_name(context: Context): this['name'] {\r\n        return context.data.name;\r\n    }\r\n    protected set_name(val: this['name'], context: Context): boolean {\r\n        const data = context.data;\r\n        SetFieldAction.new(data.id, 'name', val, '', false);\r\n        return true;\r\n    }\r\n\r\n    protected get_author(context: Context): this['author'] {\r\n        return LUser.fromPointer(context.data.author);\r\n    }\r\n    protected set_author(val: Pack<this['author']>, context: Context): boolean {\r\n        const data = context.data;\r\n        SetFieldAction.new(data.id, 'author', Pointers.from(val), '', true);\r\n        return true;\r\n    }\r\n\r\n    public get_state(context: any): this['state'] {\r\n        return context.data.state;\r\n    }\r\n    public set_state(val: this['state'], context: Context): boolean {\r\n        const data = context.data;\r\n        SetFieldAction.new(data.id, 'state', val, '', false);\r\n        return true;\r\n    }\r\n\r\n    protected get_collaborators(context: Context): this['collaborators'] {\r\n        return LUser.fromPointer(context.data.collaborators);\r\n    }\r\n    protected set_collaborators(val: PackArr<this['collaborators']>, context: Context): boolean {\r\n        const data = context.data;\r\n        SetFieldAction.new(data.id, 'collaborators', Pointers.from(val), '', true);\r\n        return true;\r\n    }\r\n\r\n    protected get_onlineUsers(context: Context): this['onlineUsers'] {\r\n        return context.data.onlineUsers;\r\n    }\r\n    protected set_onlineUsers(val: this['onlineUsers'], context: Context): boolean {\r\n        const data = context.data;\r\n        SetFieldAction.new(data.id, 'onlineUsers', val, '', false);\r\n        return true;\r\n    }\r\n\r\n    protected get_metamodels(context: Context): this['metamodels'] {\r\n        return LModel.fromPointer(context.data.metamodels);\r\n    }\r\n    protected set_metamodels(val: PackArr<this['metamodels']>, context: Context): boolean {\r\n        const data = context.data;\r\n        SetFieldAction.new(data.id, 'metamodels', Pointers.from(val), '', true);\r\n        return true;\r\n    }\r\n\r\n    protected get_models(context: Context): this['models'] {\r\n        return LModel.fromPointer(context.data.models);\r\n    }\r\n    protected set_models(val: PackArr<this['models']>, context: Context): boolean {\r\n        const data = context.data;\r\n        SetFieldAction.new(data.id, 'models', Pointers.from(val), '', true);\r\n        return true;\r\n    }\r\n\r\n    protected get_graphs(context: Context): this['graphs'] {\r\n        return LGraph.fromPointer(context.data.graphs);\r\n    }\r\n    protected set_graphs(val: PackArr<this['graphs']>, context: Context): boolean {\r\n        const data = context.data;\r\n        SetFieldAction.new(data.id, 'graphs', Pointers.from(val), '', true);\r\n        return true;\r\n    }\r\n\r\n    protected get_views(c: Context): this['views'] {\r\n        // return LViewElement.fromPointer([...c.data.views, ...Defaults.views]);\r\n        let duplicateRemover: Dictionary<Pointer, LViewElement> = {};\r\n        let varr = this.get_viewpoints(c).flatMap(vp => vp.allSubViews);\r\n        for (let v of varr) duplicateRemover[v.id] = v;\r\n        return Object.values(duplicateRemover);\r\n    }\r\n\r\n    protected set_views(val: PackArr<this['views']>, context: Context): boolean {\r\n        return Log.exx(\"cannot set project.views, set them as subviews of a project viewpoint.\");\r\n        /*\r\n        const data = context.data;\r\n        let ptrs = Pointers.from(val);\r\n        let defaultViewsMap: Dictionary<Pointer, boolean> = U.objectFromArrayValues(Defaults.views);\r\n        ptrs = ptrs.filter(ptr => !defaultViewsMap[ptr]);\r\n        SetFieldAction.new(data.id, 'views', ptrs, '', true);\r\n        return true;*/\r\n    }\r\n    /*\r\n        protected get_stackViews(context: Context): this['stackViews'] {\r\n            return LViewElement.fromPointer(context.data.stackViews || []);\r\n        }\r\n        protected set_stackViews(val: PackArr<this['stackViews']>, context: Context): boolean {\r\n            const data = context.data;\r\n            SetFieldAction.new(data.id, 'stackViews', Pointers.from(val), '', true);\r\n            return true;\r\n        }*/\r\n\r\n    protected get_viewpoints(context: Context): this['viewpoints'] {\r\n        return LViewPoint.fromPointer([...Defaults.viewpoints, ...context.data.viewpoints]);\r\n    }\r\n    protected set_viewpoints(val: PackArr<this['viewpoints']>, context: Context): boolean {\r\n        const data = context.data;\r\n        SetFieldAction.new(data.id, 'viewpoints', Pointers.from(val), '', true);\r\n        return true;\r\n    }\r\n\r\n    protected get_activeViewpoint(context: Context): this['activeViewpoint'] {\r\n        return LViewPoint.fromPointer(context.data.activeViewpoint || Defaults.viewpoints[0]);\r\n    }\r\n    protected set_activeViewpoint(val: Pack1<this['activeViewpoint']>, context: Context): boolean {\r\n        const data = context.data;\r\n        SetFieldAction.new(data.id, 'activeViewpoint', Pointers.from(val), '', true);\r\n        return true;\r\n    }\r\n\r\n    /* DATA Getter */\r\n    protected get_packages(context: Context): this['packages'] {\r\n        const data = context.proxyObject as LProject;\r\n        return data.metamodels.flatMap(m => m.allSubPackages);\r\n    }\r\n    protected get_classes(context: Context): this['classes'] {\r\n        const data = context.proxyObject as LProject;\r\n        return data.packages.flatMap(p => p.classes);\r\n    }\r\n    protected get_attributes(context: Context): this['attributes'] {\r\n        const data = context.proxyObject as LProject;\r\n        return data.classes.flatMap(c => c.attributes);\r\n    }\r\n    protected get_references(context: Context): this['references'] {\r\n        const data = context.proxyObject as LProject;\r\n        return data.classes.flatMap(c => c.references);\r\n    }\r\n    protected get_operations(context: Context): this['operations'] {\r\n        const data = context.proxyObject as LProject;\r\n        return data.classes.flatMap(c => c.operations);\r\n    }\r\n    protected get_parameters(context: Context): this['parameters'] {\r\n        const data = context.proxyObject as LProject;\r\n        return data.operations.flatMap(o => o.parameters);\r\n    }\r\n    protected get_enumerators(context: Context): this['enumerators'] {\r\n        const data = context.proxyObject as LProject;\r\n        return data.packages.flatMap(p => p.enumerators);\r\n    }\r\n    protected get_literals(context: Context): this['literals'] {\r\n        const data = context.proxyObject as LProject;\r\n        return data.enumerators.flatMap(e => e.literals);\r\n    }\r\n    protected get_objects(context: Context): this['objects'] {\r\n        const data = context.proxyObject as LProject;\r\n        return data.models.flatMap(m => m.allSubObjects);\r\n    }\r\n    protected get_values(context: Context): this['values'] {\r\n        const data = context.proxyObject as LProject;\r\n        return data.models.flatMap(m => m.allSubValues);\r\n    }\r\n\r\n    /* NODES Getter */\r\n    protected get_allNodes(context: Context): this['allNodes'] {\r\n        const data = context.proxyObject as LProject;\r\n        const nodes: NodeTypes[] = [];\r\n        // nodes.push(...(data.metamodels.flatMap(m => m.node).filter(n => n !== undefined) as NodeTypes[]));\r\n        nodes.push(...(data.packages.flatMap(m => m.node).filter(n => n !== undefined) as NodeTypes[]));\r\n        nodes.push(...(data.classes.flatMap(m => m.node).filter(n => n !== undefined) as NodeTypes[]));\r\n        nodes.push(...(data.attributes.flatMap(m => m.node).filter(n => n !== undefined) as NodeTypes[]));\r\n        nodes.push(...(data.references.flatMap(m => m.node).filter(n => n !== undefined) as NodeTypes[]));\r\n        nodes.push(...(data.operations.flatMap(m => m.node).filter(n => n !== undefined) as NodeTypes[]));\r\n        nodes.push(...(data.parameters.flatMap(m => m.node).filter(n => n !== undefined) as NodeTypes[]));\r\n        nodes.push(...(data.enumerators.flatMap(m => m.node).filter(n => n !== undefined) as NodeTypes[]));\r\n        nodes.push(...(data.literals.flatMap(m => m.node).filter(n => n !== undefined) as NodeTypes[]));\r\n        // nodes.push(...(data.models.flatMap(m => m.node).filter(n => n !== undefined) as NodeTypes[]));\r\n        nodes.push(...(data.objects.flatMap(m => m.node).filter(n => n !== undefined) as NodeTypes[]));\r\n        nodes.push(...(data.values.flatMap(m => m.node).filter(n => n !== undefined) as NodeTypes[]));\r\n        return nodes;\r\n    }\r\n    protected get_graphVertexes(context: Context): this['graphVertexes'] {\r\n        const data = context.proxyObject as LProject;\r\n        return data.allNodes.filter(n => n.className === 'DGraphVertex') as LGraphVertex[];\r\n    }\r\n    protected get_voidVertexes(context: Context): this['voidVertexes'] {\r\n        const data = context.proxyObject as LProject;\r\n        return data.allNodes.filter(n => n.className === 'DVoidVertex') as LVoidVertex[];\r\n    }\r\n    protected get_vertexes(context: Context): this['vertexes'] {\r\n        const data = context.proxyObject as LProject;\r\n        return data.allNodes.filter(n => n.className === 'DVertex') as LVertex[];\r\n    }\r\n    protected get_fields(context: Context): this['fields'] {\r\n        const data = context.proxyObject as LProject;\r\n        return data.allNodes.filter(n => n.className === 'DGraphElement') as LGraphElement[];\r\n    }\r\n    protected get_edges(context: Context): this['edges'] {\r\n        const data = context.proxyObject as LProject;\r\n        return data.graphs.flatMap(g => g.subElements.filter(e => e.className === 'DEdge')) as LEdge[];\r\n    }\r\n    protected get_edgePoints(context: Context): this['edgePoints'] {\r\n        const data = context.proxyObject as LProject;\r\n        return data.edges.flatMap(e => e.subElements) as LEdgePoint[];\r\n    }\r\n\r\n    /* CUSTOM Functions */\r\n    protected get_children(context: Context): this['children'] {\r\n        const data = context.proxyObject as LProject;\r\n        return [\r\n            /* Data */\r\n            ...data.metamodels,\r\n            ...data.packages,\r\n            ...data.classes,\r\n            ...data.attributes,\r\n            ...data.references,\r\n            ...data.operations,\r\n            ...data.parameters,\r\n            ...data.enumerators,\r\n            ...data.literals,\r\n            ...data.models,\r\n            ...data.objects,\r\n            ...data.values,\r\n            /* Views & Viewpoints */\r\n            ...data.views.filter(v => v && !Defaults.views.includes(v.id)),\r\n            ...data.viewpoints.filter(vp => vp && !Defaults.viewpoints.includes(vp.id)),\r\n            /* Nodes */\r\n            ...data.allNodes\r\n        ];\r\n    }\r\n\r\n    /*\r\n        public pushToStackViews(view: Pack<LViewElement>): void {\r\n            throw new Error('cannot be called directly, should trigger getter. this is only for correct signature');\r\n        }\r\n        protected get_pushToStackViews(context: Context): (view: Pack<LViewElement>) => void {\r\n            return (view) => {\r\n                const data = context.data;\r\n                SetFieldAction.new(data.id, 'stackViews', Pointers.from(view), ', true);\r\n            }\r\n        }\r\n    /*\r\n        public popFromStackViews(): void {\r\n            throw new Error('cannot be called directly, should trigger getter. this is only for correct signature');\r\n        }\r\n        protected get_popFromStackViews(context: Context): () => void {\r\n            return () => {\r\n                const data = context.data;\r\n                const view = data.stackViews?.at(-1);\r\n                if(!view) return;\r\n                SetFieldAction.new(data.id, 'stackViews', view as any, '-=', true);\r\n            }\r\n        }\r\n    */\r\n    public delete(): void {\r\n        throw new Error('cannot be called directly, should trigger getter. this is only for correct signature');\r\n    }\r\n    protected get_delete(c: Context): () => void {\r\n        const data = c.proxyObject as LProject;\r\n        return () => {\r\n            TRANSACTION(()=> {\r\n                // this crashes, there is no get_children() (data.children || []).map(c => c && c.delete());\r\n                SetFieldAction.new(DUser.current, 'projects', c.data.id as any, '-=', true);\r\n                DeleteElementAction.new(data.id);\r\n                SetRootFieldAction.new('projects', c.data.id, '-=', true);\r\n            });\r\n        }\r\n    }\r\n\r\n    duplicate(): LProject{ return this.wrongAccessMessage('LProject.duplicate()')};\r\n    get_duplicate(c: Context): ()=>LProject{\r\n        return () => {\r\n            let clone: DProject = DProject.new(c.data.type, c.data.name + ' Copy');\r\n            for (let key in c.data){\r\n                switch (key){\r\n                    case 'pointedBy': case 'name': continue;\r\n                    default:\r\n                        // @ts-ignore\r\n                        clone[key] = c.data[key];\r\n                        break;\r\n            }\r\n        }\r\n        clone.author = DUser.current;\r\n        clone.onlineUsers = 0;// i think this should not be a presistent data, but a fake attribute available only on LProject\r\n        // todo per giordano: assign project to user & set persistent stuff with ProjectsAPI ?\r\n        return LPointerTargetable.fromD(clone); }\r\n    }\r\n}\r\n\r\nRuntimeAccessibleClass.set_extend(DPointerTargetable, DProject);\r\nRuntimeAccessibleClass.set_extend(LPointerTargetable, LProject);\r\nexport type WProject = getWParams<LProject, DProject>;\r\n\r\n\r\n@RuntimeAccessible('MyError')\r\nexport class MyError extends Error {\r\n    constructor(message?: string, ...otherMsg: any[]) {\r\n        // 'Error' breaks prototype chain here\r\n        super(message);\r\n        const proto = (this as any).__proto__;\r\n\r\n        console.error(proto.constructor.cname || proto.constructor.name, message, ...otherMsg);\r\n        // restore prototype chain\r\n        const actualProto = new.target.prototype;\r\n\r\n        if (Object.setPrototypeOf) { Object.setPrototypeOf(this, actualProto); }\r\n        else { (this as any).__proto__ = actualProto; }\r\n        (this as any).className = (this.constructor as typeof RuntimeAccessibleClass).cname;\r\n    }\r\n}\r\n\r\n// @RuntimeAccessible\r\nexport class JsType{\r\n    public static all: JsType[] = [];\r\n    public static object: JsType = new JsType(\"object\", JsType.isObject, false);\r\n    public static function: JsType = new JsType(\"function\", JsType.isFunction, false);\r\n    public static array: JsType = new JsType(\"array\", JsType.isArray, false);\r\n    public static date: JsType = new JsType(\"Date\", JsType.isDate, false);\r\n\r\n    public static lambdaFunction: JsType = new JsType(\"lambda-function\", JsType.isLambdaFunction, true);\r\n    public static nonLambdaFunction: JsType = new JsType(\"non-lambda-function\", JsType.isNonLambdaFunction, true);\r\n    public static symbol: JsType = new JsType(\"symbol\", JsType.isSymbol, true);\r\n    public static undefined: JsType = new JsType(\"undefined\", JsType.isUndefined, true);\r\n    public static null: JsType = new JsType(\"null\", JsType.isNull, true);\r\n    public static boolean: JsType = new JsType(\"boolean\", JsType.isBoolean, true);\r\n    public static number: JsType = new JsType(\"number\", JsType.isNumber, true);\r\n    public static bigint: JsType = new JsType(\"bigint\", JsType.isBigint, true);\r\n    public static string: JsType = new JsType(\"string\", JsType.isString, true);\r\n\r\n    private constructor(public printableTypeName: string, public check: (data: any) => boolean, public isExclusiveType: boolean){\r\n        JsType.all.push(this);\r\n    }\r\n    public toString(): string { return this.printableTypeName; }\r\n    /*\r\n    * example: isObject but not Date, not function...\r\n    * */\r\n    public static isOnlyType(data: any, type: JsType): boolean { return !JsType.getTypes(data, type).length; }\r\n    public static isAnyOfTypes(data: any, ...acceptables: JsType[]): boolean { return !!windoww.Uarr.arrayIntersection(JsType.getTypes(data), acceptables).length; }\r\n    public static getTypes(data: any, stopIfTypeIsNot?: JsType): JsType[]{\r\n        const ret: JsType[] = [];\r\n        for (const type of JsType.all) {\r\n            if (type.check(data)) {\r\n                ret.push(data);\r\n                if (stopIfTypeIsNot !== type) { return []; }\r\n                if (type.isExclusiveType) return ret;\r\n            }\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    /// is...\r\n    public static isObject(data: GObject | any, returnIfNull: boolean = false): boolean { return data === null ? returnIfNull : typeof data === \"object\"; }\r\n    public static isFunction(data: Function | any): boolean { return typeof data === \"function\"; }\r\n    public static isLambdaFunction(data: Function | any): boolean {\r\n        if (!JsType.isFunction(data)) return false;\r\n        return windoww.U.getFunctionSignatureFromComments(data).isLambda; }\r\n    public static isNonLambdaFunction(data: Function | any): boolean { return JsType.isFunction(data) && !JsType.isNonLambdaFunction(data); }\r\n    public static isArray(data: Array<any> | any): boolean { return Array.isArray(data); }\r\n    public static isSymbol(data: symbol | any): boolean { return typeof data === \"symbol\"; }\r\n    public static isBoolean(data: symbol | any): boolean { return !!data === data; }\r\n    public static isNumber(data: number | any): boolean { return typeof data === \"number\"; }\r\n    public static isBigint(data: bigint | any): boolean { return typeof data === \"bigint\"; }\r\n    public static isString(data: string | any): boolean { return typeof data === \"string\"; }\r\n    public static isNull(data: null | any): boolean { return data === null; }\r\n    public static isUndefined(data: undefined | any): boolean { return data === undefined; }\r\n    public static isDate(data: Date | any): boolean { return data instanceof Date; }\r\n\r\n    /// as...\r\n    public static asObject<T>(data: GObject | any, fallbackReturn: T): T | GObject { return JsType.isObject(data) ? data : fallbackReturn; }\r\n    public static asFunction<T>(data: Function | any, fallbackReturn: T): T | Function { return JsType.isFunction(data) ? data : fallbackReturn; }\r\n    public static asLambdaFunction<T>(data: Function | any, fallbackReturn: T): T | Function { return JsType.isLambdaFunction(data) ? data : fallbackReturn; }\r\n    public static asNonLambdaFunction<T>(data: Function | any, fallbackReturn: T): T | Function { return JsType.isNonLambdaFunction(data) ? data : fallbackReturn; }\r\n    public static asArray<T, A>(data: Array<A> | any, fallbackReturn: T): T | Array<A> { return JsType.isArray(data) ? data : fallbackReturn; }\r\n    public static asSymbol<T>(data: symbol | any, fallbackReturn: T): T | symbol { return JsType.isSymbol(data) ? data : fallbackReturn; }\r\n    public static asBoolean<T>(data: boolean | any, fallbackReturn: T): T | boolean { return JsType.isBoolean(data) ? data : fallbackReturn; }\r\n    public static asNumber<T>(data: number | any, fallbackReturn: T): T | number { return JsType.isNumber(data) ? data : fallbackReturn; }\r\n    public static asBigint<T>(data: bigint | any, fallbackReturn: T): T | bigint { return JsType.isBigint(data) ? data : fallbackReturn; }\r\n    public static asString<T>(data: string | any, fallbackReturn: T): T | string { return JsType.isString(data) ? data : fallbackReturn; }\r\n    public static asNull<T>(data: null | any, fallbackReturn: T): T | null { return JsType.isNull(data) ? data : fallbackReturn; }\r\n    public static asUndefined<T>(data: undefined | any, fallbackReturn: T): T | undefined { return JsType.isUndefined(data) ? data : fallbackReturn; }\r\n    public static asDate<T>(data: Date | any, fallbackReturn: T): T | Date { return JsType.isDate(data) ? data : fallbackReturn; }\r\n    public static isPrimitive(data: any) { return !JsType.isAnyOfTypes(data, JsType.object, JsType.function, JsType.array); }\r\n}\r\n\r\n\r\nfunction invalidSuperClassError(/*callee: Class,*/ scname: string, superclass: Class): (() => never) {\r\n    return () => { windoww.Log.exDevv('parent super class \"' + scname + '\" is not implementing init_constructor', {scname, superclass, }); throw new Error(); }\r\n}\r\n// @ts-ignore\r\nfunction MixinFakeConstructor() { this.isMixinFakeConstructor = true; }\r\nexport function MixOnlyFuncs2<A1 extends any[], I1, S1, A2 extends any[], I2, S2>(c1: Class<A1, I1, S1> & typeof RuntimeAccessibleClass, c2: Class<A2, I2, S2> & typeof RuntimeAccessibleClass):\r\n    Class<A1, I1, S1> & Class<A2, I2, S2>{\r\n    return MixOnlyFuncs(c1, c2) as any;\r\n}\r\nexport function MixOnlyFuncs3<A1 extends any[], I1, S1, A2 extends any[], I2, S2>(c1: Class<A1, I1, S1> & typeof RuntimeAccessibleClass, c2: Class<A2, I2, S2> & typeof RuntimeAccessibleClass):\r\n    Class<A1&A2, I1&I2, S1&S2>{\r\n    return MixOnlyFuncs(c1, c2) as any;\r\n}\r\nexport function MixOnlyFuncs<A1 extends any[], I1, S1, A2 extends any[], I2, S2>(c1: Class<A1, I1, S1> & typeof RuntimeAccessibleClass, c2: Class<A2, I2, S2> & typeof RuntimeAccessibleClass):\r\n    CClass<Longest<A1, A2>, I1 & I2\r\n        & {\r\n        // superclass: Dictionary<string, (/*thiss: I1 & I2,* / ...superConstructorParams:ConstructorParameters<Class<A1, I1, S1>> | ConstructorParameters<Class<A2, I2, S2>>) => void>,\r\n        superclass1: Dictionary<DocString<'constructor name to make sure the user knows what superclass constructor is calling'>,  (...superConstructor1Params:ConstructorParameters<Class<A1, I1, S1>>) => void>,\r\n        superclass2: Dictionary<DocString<'constructor name to make sure the user knows what superclass constructor is calling'>,  (...superConstructor2Params:ConstructorParameters<Class<A2, I2, S2>>) => void>,\r\n        // initt: Class<A1, I1, S1>\r\n    } & AbstractMixedClass\r\n        // , Omit<Omit<Omit<S1 & S2, 'init_constructor'>, 'logic'>, 'maxID'> & typeof AbstractMixedClass> {\r\n        , S1 & S2 & GObject & typeof AbstractMixedClass> {\r\n    // strategia: passo dei finti valori che copiano i prototipi delle classi sovrascrivendo i costruttori per evitare che chiami i costruttori delle superclassi\r\n    // ma che comunque erediti campi e funzioni\r\n    // @ts-ignore\r\n    let c1noconstructor: any = MixinFakeConstructor;\r\n    let c2noconstructor: any = MixinFakeConstructor;\r\n    c1noconstructor.prototype = c1.prototype;\r\n    c2noconstructor.prototype = c2.prototype;\r\n\r\n    let disableconstructor = false;\r\n    if (!disableconstructor) {\r\n        c1noconstructor = c1;\r\n        c2noconstructor = c2; }\r\n\r\n\r\n    let ret = Mixin(c1noconstructor, c2noconstructor);\r\n    let c1name = (c1.cname || c1.name) === 'classnameFixedConstructorDoNotRenameWithoutSearchStrings' ? c1.prototype.className : c1.cname || c1.name;\r\n    let c2name = (c2.cname || c2.name) === 'classnameFixedConstructorDoNotRenameWithoutSearchStrings' ? c2.prototype.className : c2.cname || c2.name;\r\n    //ret.prototype['superclass'] = {};\r\n    // ret.prototype['superclass'][c1name] = c1.prototype.init_constructor || invalidSuperClassError(c1name, c1);\r\n    // ret.prototype['superclass'][c2name] = c2.init_constructor || invalidSuperClassError(c2name, c2);\r\n    ret.prototype['superclass1'] = {};\r\n    ret.prototype['superclass2'] = {};\r\n    ret.prototype['superclass1'][c1name] = c1.init_constructor || invalidSuperClassError(c1name, c1);\r\n    ret.prototype['superclass2'][c2name] = c2.init_constructor || invalidSuperClassError(c2name, c2);\r\n    return ret;\r\n}\r\n// console.info('ts loaded classes');\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n//*********************************************************************************************\r\n//*********************************************************************************************\r\n///////                              type juggling starts here                          ///////\r\n//*********************************************************************************************\r\n//*********************************************************************************************\r\n\r\n// export type NotAString<T extends any = 'uselessval'> = Omit<string, 'bold'> & {big: T};\r\n// export type NotAString<T extends any = 'uselessval'> = Omit<string, 'bold'>;\r\n// export type NotAString<T extends any = 'uselessval', T2 extends any = any, T3 extends any = any, T4 extends any = any> = string & Omit<string, 'bold'> & {bold: ()=>string};\r\nexport type NotAString<T extends any = 'uselessval', T2 extends any = any, T3 extends any = any, T4 extends any = any> = string & Omit<string, 'bold'> & {bolda?: T};\r\n// export type NotAString<T> = string;\r\n// type Pointer<T> = NotAString<T>;\r\nexport type Pointer<T extends DPointerTargetable = DPointerTargetable, lowerbound extends number = 1, upperbound extends number|'N' = 1,\r\n    RET extends LPointerTargetable = DtoL<T>> =\r\n    upperbound extends 'N' ? NotAString<T, lowerbound, upperbound, RET>[] : (\r\n        upperbound extends 0 ? never : (\r\n            lowerbound extends 0 ? (NotAString<T, lowerbound, upperbound, RET> | null) : NotAString<T, upperbound, lowerbound, RET>));\r\n\r\n\r\nexport type PtrString = any; // to convert Pointers to strings more explicitly then using as any\r\n// let ptr: Pointer<Object> = null as any;\r\n/*\r\nclass D extends DPointerTargetable{\r\n    parent!: Pointer<D>;\r\n    dattrib!: boolean;\r\n    juststring!: string;\r\n    nattrib!: number;\r\n    ddattrib!: Date\r\n}\r\n\r\nclass D2 extends D{\r\n    d2!: string;\r\n}\r\nclass D3 extends D{\r\n    d3!: string;\r\n}\r\n\r\n\r\n\r\ntype OverrideTypes<M, N> = { [P in keyof M]: P extends keyof N ? N[P] : M[P] }; // usage:  OverrideTypes<A, { x: number }>;\r\n\r\ninterface LFix {\r\n    parent: L;\r\n}\r\ninterface L { // no instances ever\r\n    parent: L;\r\n    lattrib: boolean;\r\n}\r\ninterface L2 extends L { // no instances ever\r\n    l2: string;\r\n}\r\ninterface L3 extends L{ // no instances ever\r\n    l3: string;\r\n}\r\n\r\nclass P { // singleton\r\n    get_parent(){}\r\n    set_parent(){}\r\n}\r\nclass P2 extends P { // singleton\r\n    get_d2() {}\r\n}\r\nclass P3 extends P { // singleton\r\n    get_d3() {}\r\n}*/\r\n\r\ntype ERROR = \"_TYPE_ERROR_\";\r\n// RegExp extends Animal ? number : string\r\n\r\n\r\nfunction buildWrapSignature(maxdepth = 100) {\r\n    let arr = windoww[\"DPointerTargetable\"].subclasses;\r\n    /*\r\n    let dict0 = arr.reduce((a, v) => ({ ...a, [v.name]: v}), {});\r\n    let dict = {}\r\n    for (let name in dict0) { let n = name.substring(1); dict[n] = {\"D\":dict0[\"D\"+n], \"L\":dict0[\"L\"+n]}; dict[\"D\"+n] = dict0[\"L\"+n]; dict[\"L\"+n] = dict0[\"D\"+n]; }\r\n    console.log(\"dict\", dict);\r\n    console.table(dict);\r\n    */\r\n    function onlyUnique(value: any, index: number, self: any) { return self.indexOf(value) === index; }\r\n\r\n    let dep = arr; // .map( (me) => { return {\"name\": me.name, \"me\": me, \"Derror\": (dict[me.name] || me).name, \"Lerror\": (dict[me.name] || me).name, \"subclasses\": [...me.subclasses]}});\r\n    let depsorted = [];\r\n\r\n    let byLevels = [];\r\n    let loopdetecter: any[] = [arr];\r\n    while (dep.length && maxdepth--) {\r\n        let namelist = dep.map((e: any) => e.name).filter(onlyUnique);\r\n        depsorted.push(...namelist);\r\n        byLevels.push([...namelist]);\r\n        let olddep = dep;\r\n        dep = dep.flatMap((d: any) => d.subclasses).filter(onlyUnique);\r\n        for (let d of dep) {\r\n            windoww.loopdetecter = loopdetecter;\r\n            windoww.dep = dep;\r\n            windoww.olddep = olddep;\r\n            windoww.byLevels = byLevels;\r\n            windoww.d = d;\r\n            if ( loopdetecter.includes(d.subclasses) ) throw new Error(\"class is not redefining subclasses static array: \" + d.name);\r\n            loopdetecter.push(d.subclasses);\r\n        }\r\n    }\r\n    console.log(\"byLevels\");\r\n    console.table(byLevels);\r\n\r\n    console.log(\"depsorted\", depsorted);\r\n\r\n    // console.log(\"map\");\r\n    // console.table(depsorted.map(dn => {let d = window[dn]; return !d ? \"\" :{name:d.name, scount: d.subclasses.length, subclasses:d.subclasses}}));\r\n\r\n\r\n    let goalSignature = \"function wrap<DX extends D, LX = DX extends D2 ? L2: (DX extends D3 ? L3: (DX extends D ? L : ERROR))>(data: DX): LX {\";\r\n    let lparam = \"ERROR\";\r\n    let epsorted = depsorted.map( e => e.substring(1)).filter(onlyUnique);\r\n    console.table(epsorted)\r\n    for (let e of epsorted) {\r\n        let D = \"D\" + e;\r\n        let L = \"L\" + e;\r\n        lparam = \"DX extends \" + D + \" ? \"  + L + \" : (\" + (lparam) + \")\";\r\n    }\r\n    let signature = \"function wrap<DX extends DPointerTargetable, LX = \" + lparam + \">(data: DX): LX {\";\r\n    return signature;\r\n}\r\nwindoww.buildWrapSignature = buildWrapSignature;\r\n// function wrap<DX extends D, LX = DX extends D2 ? L2: (DX extends D3 ? L3: (DX extends D ? L : ERROR))>(data: DX): LX {\r\n\r\n/*\r\n* NO    L -> D    /// l.__raw\r\n* NO    L -> Ptr  /// l.id\r\n*\r\n* NO    D -> Ptr   // d.id\r\n* YES   D -> L     // wrap\r\n*\r\n* NO    Ptr -> D\r\n* NO    Ptr -> L\r\n*\r\n*\r\n*\r\n*\r\n* DpointerTargetable.from( L or pointer )\r\n* LpointerTargetable.from( D or pointer )\r\n*\r\n* MyProxyHandler.wrap = LpointerTargetable.from;\r\n*\r\n* DpointerTargetable.toPointer( d );\r\n*\r\n\r\ntype subtractDL = subtract<D, L>;\r\n* */\r\n\r\n\r\n\r\ntype subtract<P, C> = { [F in keyof P]: keyof C extends undefined ? undefined : P[F] };\r\ntype Exclude3<T, U> = T & {[T in keyof U]: never};\r\ntype Override<A, B> = Omit<A, keyof B> & B; //////////////////////////////////////////// best solution so far\r\n\r\ntype Exclude2<Type, field> = {\r\n    [Property in keyof Type as Exclude<Property, keyof field>]: Type[Property]      /////////////////////////equally best solution\r\n};\r\n\r\n\r\ntype OnlyKeysOfTypeTmp<T, IncludeType> = ({[P in keyof T]: T[P] extends IncludeType ? P : never })[keyof T];\r\ntype OnlyKeysOfType<T, IncludeType> = Pick<T, OnlyKeysOfTypeTmp<T, IncludeType>>;\r\ntype RemoveKeysOfType<T, ExcludeType> = Exclude2<T, OnlyKeysOfType<T, ExcludeType>>;\r\n\r\n// todo: can't automatically convert D to L (generating the type instead of manual defining L) rules are: LClass <--- Pointer<LClass>, LClass[] <-- Pointer<LClass, 0, 'N'>, subobject = ? should not be there\r\n\r\n/**\r\n i have a documentation type that is actually a string, but it\\'s have a different purpose from the others, and i made a type to keep documentally separated.\r\n let's say it's\r\n type StringOf<P> = string; // regardless of P\r\n\r\n and i use it to define objects\r\n\r\n class C {\r\n           str: StringOf<Date>;\r\n           str2: StringOf<number>;\r\n           purestring: string;\r\n           num: number\r\n         }\r\n now i want to crete a derivate type that excludes all properties of type StringOf from C\r\n\r\n\r\n\r\n type OnlyKeysOfTypeTmp<T, IncludeType> = ({[P in keyof T]: T[P] extends IncludeType ? P : never })[keyof T];\r\n type OnlyKeysOfType<T, IncludeType> = Pick<T, OnlyKeysOfTypeTmp<T, IncludeType>>;\r\n type RemoveKeysOfType<T, ExcludeType> = Exclude2<T, OnlyKeysOfType<T, string>>;\r\n\r\n type D = RemoveKeysOfType<C, StringOf<any>>\r\n due to duck typing, this removes all StringOf attributes, but also \"purestring\" attribute.\r\n how can i remove only StringOf attributes?\r\n\r\n\r\n */\r\n\r\n\r\n\r\nexport type getWParams<L extends LPointerTargetable, D extends Object> ={\r\n    // [Property in keyof ValidObj<L>]: L[Property] extends never ? never : L[Property]\r\n    [Property in keyof L]:/*\r\n            Property extends \"opposite\" ? LReference | DReference | Pointer<DReference> :\r\n            Property extends \"parent\" ? LModelElement | DModelElement | Pointer<DModelElement> :\r\n            Property extends \"annotations\" ? LAnnotation | DAnnotation | Pointer<DAnnotation> :*/\r\n    (Property extends string ? (\r\n        Property extends \"id\" ? 'id is read-only' :\r\n            //@ts-ignore\r\n            (L[`set_${Property}`] extends (a:any, b: any, ...b:any)=> any ? // at least 2 params: 1 for val and 1 for Context\r\n                // if a set_ first parameter is Context it means the set_ is ill-defined, need to change actual method signature.\r\n                //@ts-ignore\r\n                Parameters<L[`set_${Property}`]>[0] // if set_X function is defined, get first param\r\n                //@ts-ignore\r\n                : never ///D[Property] | `todo: should define set_${Property}` // default type if it's not assigned = type in the D version\r\n                )): never)\r\n} // & L\r\n\r\n\r\nexport enum EGraphElements {\r\n    \"GraphElement\"=  \"GraphElement\",\r\n    \"Field\" =\"GraphElement\", // just an alias for now.\r\n    \"Vertex\"= \"Vertex\",\r\n    \"todo\" = \"todo\"\r\n}\r\nexport enum EModelElements{\r\n    // concrete m2\r\n    \"(m2) Model\" = \"DModel\",\r\n    \"(m2) Package\" = \"DPackage\",\r\n    \"(m2) Class\" = \"DClass\",\r\n    \"(m2) Enum\" = \"DEnumerator\",\r\n    \"(m2) Literal\" = \"DEnumLiteral\",\r\n    \"(m2) Operation\" = \"DOperation\",\r\n    \"(m2) Parameter\" = \"DParameter\",\r\n    \"(m2) Attribute\" = \"DAttribute\",\r\n    \"(m2) Reference\" = \"DReference\",\r\n    \"(m2) Annotation\" = \"DAnnotation\",\r\n    // abstract m2\r\n    \"(abstract m2) Feature\" = \"DStructuralFeature\",\r\n    \"(abstract m2) Classifier\" = \"DClassifier\",\r\n    // concrete m1\r\n    \"(m1) Object\" = \"DObject\",\r\n    \"(m1) Value\" = \"DValue\",\r\n}\r\nexport class ViewEClassMatch {\r\n    static NOT_EVALUATED_YET = undefined;\r\n    static MISMATCH = Number.NEGATIVE_INFINITY;\r\n    static MISMATCH_PRECONDITIONS = Number.NEGATIVE_INFINITY;\r\n    static MISMATCH_JS = false;\r\n    static MISMATCH_OCL = false;\r\n    static IMPLICIT_MATCH = 1;\r\n    static INHERITANCE_MATCH = 1.5;\r\n    static EXACT_MATCH = 2;\r\n    static VP_MISMATCH: number = Number.NEGATIVE_INFINITY;\r\n    static VP_Default = 1;\r\n    static VP_Decorative = 1;\r\n    static VP_Explicit = 2;\r\n}\r\n\r\nexport type ViewScore = {\r\n    viewPointMatch: number;\r\n    jsxOutput: React.ReactNode | React.ReactElement | undefined;\r\n    metaclassScore: number;\r\n    jsScore: number | boolean;\r\n    OCLScore: boolean;\r\n    finalScore: number;\r\n    usageDeclarations: GObject;\r\n    evalContext: GObject; // with added usageDeclarations for the current view\r\n    shouldUpdate: boolean; // computed along usageDeclarations in shouldComponentUpdate\r\n    shouldUpdate_reason: GObject;\r\n    nodeidcounter: Dictionary<number/*jsx char index*/, number/*counter:how many nodes generated by that jsx string line until now*/>\r\n\r\n    // usageDeclarations!: DefaultUsageDeclarations;\r\n    // oldNode: DGraphElement; moved to viewSorted_nodeused // ref to the actual node, not pointer. so even if it's modified through redux,\r\n    // it is still possible to compare old version and new version to check if view.oclUpdateCondition should trigger\r\n}\r\nexport class NodeTransientProperties{\r\n    viewSorted_modelused?: LModelElement; // L-version because it is used in oclUpdate function\r\n    viewSorted_pvid_used?: DViewElement;\r\n    viewSorted_nodeused?: LGraphElement;\r\n    stackViews!: LViewElement[]; // for each parentview, an array of Decorative Views[] sorted by score (including parent view influence).\r\n    validMainViews!: LViewElement[]; // an array of Main Views[] sorted by score (including parent view influence).\r\n    mainView!: LViewElement;\r\n    viewScores: Dictionary<Pointer<DViewElement>, ViewScore> = {} as any;\r\n    evalContext!: GObject; // global for this node (without view-specific usageDeclaration)\r\n    needSorting!: boolean;\r\n    //force1Update!: boolean;\r\n    constructor(){\r\n        // this.stackViews = []; this.validMainViews = [];\r\n        this.viewScores = {};\r\n    }\r\n}\r\nexport class ViewTransientProperties {\r\n    // css_MUST_RECOMPILE: boolean;\r\n    // compiled_css: string; maye those are better shared in sessions\r\n    events!: Dictionary<DocString<\"functionName\">, ((...a:any)=>any)>;\r\n    oclChanged!: boolean;\r\n    jsConditionChanged!: boolean;\r\n    oclUpdateCondition_PARSED!: (oldData: LModelElement, newData:LModelElement) => boolean;// not used anymore? was like UD+shouldcompoupdate for jsx, a pre-ocl check\r\n    oclEngine!: OclEngine;\r\n    jsCondition!: undefined | ((context:GObject) => boolean);\r\n    JSXFunction!: (scope: GObject)=>ReactNode;\r\n    UDFunction!: (scope: GObject, ret: GObject)=>void;\r\n    constantsList!: string[];\r\n    UDList!: string[];\r\n    constants!: GObject;\r\n    onDataUpdate!: undefined | ((context:GObject)=>void);\r\n    onDragStart!: undefined | ((context:GObject)=>void);\r\n    onDragEnd!: undefined | ((context:GObject)=>void);\r\n    whileDragging!: undefined | ((context:GObject)=>void);\r\n    onResizeStart!: undefined | ((context:GObject)=>void);\r\n    onResizeEnd!: undefined | ((context:GObject)=>void);\r\n    whileResizing!: undefined | ((context:GObject)=>void);\r\n    onRotationStart!: undefined | ((context:GObject)=>void);\r\n    onRotationEnd!: undefined | ((context:GObject)=>void);\r\n    whileRotating!: undefined | ((context:GObject)=>void);\r\n\r\n    constructor(){\r\n        this.events = {};\r\n    }\r\n\r\n\r\n}\r\nexport class DataTransientProperties {\r\n    nodes!: Dictionary<Pointer<DGraphElement>, LGraphElement>;\r\n    node?: LGraphElement;\r\n    constructor(){\r\n        this.nodes = {};\r\n    }\r\n}\r\n\r\n// score for all view ocl + sorted views by best match\r\ntype TransientPropertiesByGraphTab = Dictionary<Pointer<DViewElement, number>> & {\r\n    /*\r\n    need_sorting: boolean;\r\n    sorted: Pointer<DViewElement>[];\r\n    // viewMatchings: Scored<DViewElement>[];\r\n    when to update?\r\n    1) data.parent.view.id: when \"suviews\" in place are changed by a view on a container element has changed (if pkg view changed, class view might change as well)\r\n    2) data.any --> when a direct value of the doject changed, amd that value was declared in ocl\r\n    3) view.appliableto --> when d-type changes (never, a class cannot become a enum or reference\r\n    4) node stuff never? or maybe entire nodes?\r\n    other data or view properties?*/\r\n};\r\nexport const transientProperties = {\r\n    node: {} as Dictionary<Pointer<DGraphElement>, NodeTransientProperties>,\r\n    view: {} as Dictionary<Pointer<DViewElement>, ViewTransientProperties>,\r\n    modelElement: {} as Dictionary<Pointer<DModelElement>, DataTransientProperties>,\r\n};\r\n(window as any).transient = (window as any).transientProperties = transientProperties;\r\n// transientProperties.nodes[nid].viewScores[vid]?.[pvid as string];\r\n/*\r\nexport const transientPropertiesByGraphTab: {viewMatchings: Dictionary<Pointer<DGraph>, Dictionary<Pointer<DModelElement>, TransientPropertiesByGraphTab>>} = {\r\n viewMatchings: {}\r\n};*/\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}