{"ast":null,"code":"var _dec,_class,_class2,_dec2,_class3,_class4,_dec3,_class5,_class6,_dec4,_class7,_class8,_dec5,_class9,_class10,_dec6,_class11,_class12,_dec7,_class13,_class14,_dec8,_class15,_class16,_dec9,_class17,_class18,_dec10,_class19,_class20,_dec11,_class21,_class22,_dec12,_class23,_class24,_dec13,_class25,_class26,_dec14,_class27,_dec15,_class29,_class30,_dec16,_class31,_class32,_dec17,_class33,_class34,_dec18,_class35,_class36,_dec19,_class37,_class38,_dec20,_class39,_class40,_dec21,_class41,_class42;// import {Mixin} from \"ts-mixer\";\nimport{isDeepStrictEqual}from\"util\";import{BEGIN,Constructors,CoordinateMode,Debug,DPointerTargetable,DUser,EdgeBendingMode,END,GraphElementComponent,GraphPoint,GraphSize,Keystrokes,Leaf,Log,LPointerTargetable,MixOnlyFuncs,Node,Point,Pointers,RuntimeAccessible,RuntimeAccessibleClass,SetFieldAction,SetRootFieldAction,ShortAttribETypes,Size,store,TargetableProxyHandler,TRANSACTION,transientProperties,U,Uarr,windoww}from\"../../joiner\";import{EdgeGapMode}from\"../../joiner/types\";import{Geom}from\"../../common/Geom\";import{jsx as _jsx}from\"react/jsx-runtime\";import{jsxs as _jsxs}from\"react/jsx-runtime\";console.warn('ts loading graphDataElement');export let DGraphElement=(_dec=RuntimeAccessible('DGraphElement'),Node(_class=_dec(_class=(_class2=class DGraphElement extends DPointerTargetable{constructor(){super(...arguments);this.id=void 0;this.graph=void 0;this.model=void 0;this.isSelected=void 0;this.subElements=void 0;this.state=void 0;this.father=void 0;this.x=void 0;this.y=void 0;this.zIndex=100;this.w=void 0;this.h=void 0;this.view=void 0;this.favoriteNode=void 0;this.edgesIn=void 0;this.edgesOut=void 0;this.anchors=void 0;}// static _super = DPointerTargetable;\n// static singleton: LGraphElement;\n// static logic: typeof LGraphElement;\n// static structure: typeof DGraphElement;\n// containedIn!: Pointer<DGraphElement, 0, 1, LGraphElement>;\n// DMap\n// width: number = 300;\n// height: number = 400;\nstatic new(htmlindex,model,parentNodeID,graphID,nodeID,a,b){return new Constructors(new DGraphElement('dwc'),parentNodeID,true,undefined,nodeID).DPointerTargetable().DGraphElement(model,graphID,htmlindex).end();}static nodeLFromHtml(target){return LPointerTargetable.fromPointer(DGraphElement.nodePtrFromHtml(target));}static nodeDFromHtml(target){return DPointerTargetable.fromPointer(DGraphElement.nodePtrFromHtml(target));}static nodePtrFromHtml(target){while(target){if(target.attributes.nodeid)return target.attributes.nodeid.value;target=target.parentElement;}return undefined;}static graphLFromHtml(target){return LPointerTargetable.fromPointer(DGraphElement.graphPtrFromHtml(target));}static graphDFromHtml(target){return DPointerTargetable.fromPointer(DGraphElement.graphPtrFromHtml(target));}static graphPtrFromHtml(target){while(target){if(target.attributes.graphid)return target.attributes.graphid.value;target=target.parentElement;}return undefined;}},_class2.subclasses=[],_class2._extends=[],_class2))||_class)||_class);export let LGraphElement=(_dec2=RuntimeAccessible('LGraphElement'),_dec2(_class3=(_class4=class LGraphElement extends LPointerTargetable{constructor(){super(...arguments);this.__raw=void 0;this.id=void 0;this.father=void 0;this.model=void 0;this._state=void 0;this.x=void 0;this.y=void 0;this.width=void 0;this.height=void 0;this.z=void 0;this.zIndex=void 0;this.__info_of__z__={type:ShortAttribETypes.EInt,txt:\"alias for zIndex\"};this.__info_of__zIndex__={type:ShortAttribETypes.EInt,txt:\"Determine the z-axis priority of the element.<br/>Higher value tende to overlap other elements.<br/>Lower value tends to be on background.\"};this.zoom=void 0;this.html=void 0;this.w=void 0;this.h=void 0;this.size=void 0;this.position=void 0;this.htmlSize=void 0;this.htmlPosition=void 0;this.view=void 0;this.component=void 0;this.favoriteNode=void 0;this.vertex=void 0;this.__info_of__vertex={type:\"LVoidVertex\",txt:\"the foremost vertex containing this graphElement, or undefiened.\"};this.__info_of__favoriteNode={type:ShortAttribETypes.EBoolean,txt:\"<span>Indicates this is the primarly used (by default) node to refer to a modelling element that might have multiple representations.\"+\"<br> Can be used as favorite target for edges or other.\"};this.startPoint=void 0;this.endPoint=void 0;this.__info_of__startPoint={type:\"GraphPoint\",txt:/*#__PURE__*/_jsxs(\"span\",{children:[\"Where the outgoing edges should start their paths.\",/*#__PURE__*/_jsx(\"br\",{}),\"Obtained by combining anchoring point offset specified in view, before snapping to a Vertex border.\",/*#__PURE__*/_jsx(\"br\",{}),\"Defaults in outer coordinates.\"]})};this.__info_of__endPoint={type:\"GraphPoint\",txt:/*#__PURE__*/_jsxs(\"span\",{children:[\"Where the incoming edges should end their paths.\",/*#__PURE__*/_jsx(\"br\",{}),\"Obtained by combining anchoring point offset specified in view, before snapping to a Vertex border.\",/*#__PURE__*/_jsx(\"br\",{}),\"Defaults in outer coordinates.\"]})};this.graph=void 0;this.__info_of__graph={type:\"LGraph | LGraphVertex\",txt:\"Alias for innerGraph\"};this.innerGraph=void 0;this.__info_of__innnerGraph={type:\"LGraph | LGraphVertex\",txt:\"Gets the nearest-level graph (it might be a Sub-graph like a package usually is)\"};this.outerGraph=void 0;this.__info_of__outerGraphGraph={type:\"LGraph\",txt:\"Gets the root-level graph\"};this.root=void 0;this.__info_of__root={type:\"LGraph\",txt:\"Alias for outerGraph\"};this.__info_of__graphAncestors={type:\"LGraph[]\",txt:\"<span>collection of the stack of Graphs containing the current element where [0] is the most nested graph, and last is root graph.</span>\"};this.graphAncestors=void 0;this.anchors=void 0;this.__info_of__anchors={type:\"Dictionary<string, point>\",txt:/*#__PURE__*/_jsxs(\"div\",{children:[\"A named list of all anchor points where edges are allowed to land or depart from.\",/*#__PURE__*/_jsx(\"br\",{}),\"When writing it must be done in percentages, with the same rules as node.state.\"]})};this.edgesIn=void 0;this.edgesOut=void 0;this.__info_of__edgesIn={type:\"LEdge[]\",txt:/*#__PURE__*/_jsxs(\"div\",{children:[\"Edges incoming into this element. \",/*#__PURE__*/_jsx(\"code\",{children:\"this.edgesOut[i].end\"}),\" always equals to \",/*#__PURE__*/_jsx(\"code\",{children:\"this\"}),\".\"]})};this.__info_of__edgesOut={type:\"LEdge[]\",txt:/*#__PURE__*/_jsxs(\"div\",{children:[\"Edges outgoing from this element. \",/*#__PURE__*/_jsx(\"code\",{children:\"this.edgesIn[i].start\"}),\" always equals to \",/*#__PURE__*/_jsx(\"code\",{children:\"this\"}),\".\"]})};this.__info_of__edgesStart={type:\"LEdge[]\",txt:/*#__PURE__*/_jsx(\"div\",{children:\"Alias for this.edgesOut\"})};this.__info_of__edgesEnd={type:\"LEdge[]\",txt:/*#__PURE__*/_jsx(\"div\",{children:\"Alias for this.edgesIn\"})};this.outerSize=void 0;this.__info_of__outerSize={type:\"GraphSize\",txt:\"the size of the current element relative to the first (root) graph level.\"};this.innerSize=void 0;this.__info_of__innerSize={type:\"GraphSize\",txt:\"the size of the current element relative to the last (most nested) graph level.\"};this.__info_of__size={type:\"GraphSize\",txt:\"same as innerSize.\"};this.nodes=void 0;this.__type_of__nodes={type:'LVertex[]',txt:\"all direct sub-nodes. not including deep subelements (subelements of subelements)\"};this.edges=void 0;this.__type_of__edges={type:'LEdge[]',txt:\"all direct sub-edges. not including deep subelements (subelements of subelements)\"};this.graphs=void 0;this.__type_of__graphs={type:'LGraph[]',txt:\"all direct sub-graphs. not including deep subelements (subelements of subelements)\"};this.allSubNodes=void 0;this.__type_of__allSubNodes={type:'LVertex[]',txt:\"all deep sub-nodes. including subelements of subelements.\"};this.allSubEdges=void 0;this.__type_of__allSubEdges={type:'LEdge[]',txt:\"all deep sub-edges. including subelements of subelements.\"};this.allSubGraphs=void 0;this.__type_of__allSubGraphs={type:'LGraph[]',txt:\"all deep sub-graphs. including subelements of subelements.\"};this.subElements=void 0;this.__info_of__subElements={type:'LGraphElement[]',txt:\"all direct subelements (nodes, edges, edgepoints, subgraphs...). not including deep subelements (subelements of subelements)\"};this.allSubElements=void 0;this.__info_of__allSubElements={type:'LGraphElement[]',txt:\"all deep subelements (nodes, edges, edgepoints, subgraphs...). including subelements of subelements.\"};this.assignEdgeAnchor=void 0;this.__info_of__assignEdgeAnchor=void 0;this.__info_of__isselected={type:\"Dictionary<Pointer<User>, true>\",txt:/*#__PURE__*/_jsxs(\"div\",{children:[\"A map that contains all the users selecting this element as keys, and always true as a value (if present).\",/*#__PURE__*/_jsx(\"br\",{}),\"Edit it through node.select() and node.deselect()\"]})};this.__info_of__select={type:\"function(forUser?:Pointer<User>):void\",txt:\"Marks this node as selected by argument user.\"};this.__info_of__deselect={type:\"function(forUser?:Pointer<User>):void\",txt:\"Un-marks this node as selected by argument user.\"};this.__info_of__toggleSelect={type:\"function(usr?:Pointer<User>):void\",txt:\"Calls this.select(usr) if the node is selected by argument user, this.deselect(usr) otherwise. If omitted, argument \\\"usr\\\" is the current user id.<br>Returns the result of this.isSelected() after the toggle.\"};this.__info_of__isSelected={type:\"function(forUser?:Pointer<User>):void\",txt:\"Tells if this node is selected by argument user.\"};}static getNodeId(o){var _node;if(!o)return undefined;let node=o;// from L to D\n// let cname = (node.__raw || node).className;\n// from DModelE to LGraphE\nif(RuntimeAccessibleClass.extends(o.className,\"DModelElement\"))node=LPointerTargetable.from(o).node;return typeof node===\"string\"?node:(_node=node)===null||_node===void 0?void 0:_node.id;}// static singleton: LGraphElement;\n// static logic: typeof LGraphElement;\n// static structure: typeof DGraphElement;\n// protected isSelected!: Dictionary<DocString<Pointer<DUser>>, boolean>; //  & ((forUser?: Pointer<DUser>) => boolean);\n// containedIn?: LGraphElement;\n// LMap;\n// fittizi\n// size and position in global document coordinates.\nget_graph(context){return this.get_innerGraph(context);}get_root(context){return this.get_outerGraph(context);}get_anchors(c){return c.data.anchors;}set_anchors(v,c){if(v!==undefined&&(typeof v!==\"object\"||Array.isArray(v))){Log.ee('cannot set anchors: invalid value provided');return true;}if(v){// if !v it means clear all anchors?\nfor(let ka in v){//for each anchor\nif(!v[ka])continue;if(c.data.anchors[ka]){for(let kk in v[ka]){//for each key within an anchor (x, y, w, h)\n// if i was attempting to set a partial size, complete it with the old size values.\nif(v[ka][kk]===undefined&&c.data.anchors[ka][kk]!==undefined)v[ka][kk]=c.data.anchors[ka][kk];}}if(v[ka].x===undefined||isNaN(v[ka].x))v[ka].x=0.5;if(v[ka].y===undefined||isNaN(v[ka].y))v[ka].y=0.5;// if (v[ka].w === undefined || isNaN(v[ka].w)) v[ka].w = 5;\n// if (v[ka].h === undefined || isNaN(v[ka].h)) v[ka].h = 5;\n}}SetFieldAction.new(c.data,\"anchors\",v,'+=',false);return true;}get_edgesIn(context){return LPointerTargetable.fromArr(context.data.edgesIn);}get_edgesOut(context){return LPointerTargetable.fromArr(context.data.edgesOut);}set_edgesIn(val,c){return SetFieldAction.new(c.data.id,\"edgesIn\",Pointers.fromArr(val),'',true);}set_edgesOut(val,c){return SetFieldAction.new(c.data.id,\"edgesOut\",Pointers.fromArr(val),'',true);}get_edgesStart(context){return this.get_edgesIn(context);}get_edgesEnd(context){return this.get_edgesOut(context);}set_edgesStart(val,context){return this.set_edgesIn(val,context);}set_edgesEnd(val,context){return this.set_edgesOut(val,context);}_defaultGetter(c,k){if(k in c.data)return this.__defaultGetter(c,k);// if value not found in node, check in view.\nreturn this.get_view(c)[k];/*let ret: any;\r\n        let view = this.get_view(c);\r\n        try { ret = (view as any)[k] } catch (e) { Log.ee(\"Could not find get_ property \\\"\" + k + \"\\\" in node or view.\", {c, view, k}); return undefined; }\r\n        return ret;*/}_defaultSetter(v,c,k){this.__defaultSetter(v,c,k);return true;}get_graphAncestors(c){let current=c.proxyObject;let next=current.father;let ret=[];while(next){if(RuntimeAccessibleClass.extends(next.className,DGraph.cname))ret.push(next);if(current.id===next.id)break;current=next;next=next.father;}return ret;}get_outerGraph(context){// todo: this relies on the fact that GraphVertex are not passing their own id to their childrens, but the parent graph id\nreturn TargetableProxyHandler.wrap(context.data.graph);}get_vertex(context){let lcurrent=LPointerTargetable.fromPointer(context.data.id);let dcurrent=lcurrent.__raw;// iterate parents.\nwhile(dcurrent){switch(dcurrent.className){case DVertex.cname:case DVoidVertex.cname:case DGraphVertex.cname:return lcurrent||LPointerTargetable.fromD(dcurrent);default:if(!dcurrent.father||dcurrent.id===dcurrent.father)return undefined;Log.exDev(!dcurrent.father||dcurrent.id===dcurrent.father,\"node failed to get containing vertex\",context.data,dcurrent,lcurrent);lcurrent=LPointerTargetable.fromPointer(dcurrent.father);dcurrent=lcurrent.__raw;}}return undefined;}get_innerGraph(context){var _LPointerTargetable$f;let dcurrent=DPointerTargetable.fromPointer(context.data.father);// if no parent, but it's a graph, return itself.\nif(!dcurrent){dcurrent=context.data;switch(dcurrent.className){case DGraph.cname:case DGraphVertex.cname:return LPointerTargetable.fromD(dcurrent);default:return Log.exDevv(\"root node failed to get containing graph\",{cdata:context.data,dcurrent});}}// if it have a parent, iterate parents.\nwhile(true){var _dcurrent;switch((_dcurrent=dcurrent)===null||_dcurrent===void 0?void 0:_dcurrent.className){case DGraph.cname:case DGraphVertex.cname:return LPointerTargetable.fromD(dcurrent);default:Log.exDev(!dcurrent.father,\"node failed to get containing graph\",{cdata:context.data,dcurrent});Log.exDev(dcurrent.id===dcurrent.father,\"node failed to get containing graph, found loop\",{cdata:context.data,dcurrent,father:(_LPointerTargetable$f=LPointerTargetable.from(dcurrent))===null||_LPointerTargetable$f===void 0?void 0:_LPointerTargetable$f.father});dcurrent=DPointerTargetable.fromPointer(dcurrent.father);}}}// set_x(val: this[\"x\"], context: Context): boolean { SetFieldAction.new(context.data.id, \"x\", val, undefined, false); return true; }\n// get_x(context: Context): this[\"x\"] { return context.data.x; }\nget_x(context){return this.get_size(context).x;}set_x(val,context){return this.set_size({x:val},context);}get_y(context){return this.get_size(context).y;}set_y(val,context){return this.set_size({y:val},context);}get_w(context){return this.get_size(context).w;}set_w(val,context){return this.set_size({w:val},context);}get_h(context){return this.get_size(context).h;}set_h(val,context){return this.set_size({h:val},context);}get_width(context){return this.get_w(context);}set_width(val,context){return this.set_w(val,context);}get_height(context){return this.get_h(context);}set_height(val,context){return this.set_h(val,context);}get_position(context){return new GraphPoint(context.data.x,context.data.y);}set_position(val,context){BEGIN();SetFieldAction.new(context.data.id,\"x\",val.x,undefined,false);SetFieldAction.new(context.data.id,\"y\",val.y,undefined,false);END();return true;}get_sizeold(context){return new GraphSize(context.data.x,context.data.y,context.data.w,context.data.h);}get_component(context){// switch(context.data.className) { case DEdgePoint.name: return GraphElementComponent.map[context.data.father]; }\nreturn GraphElementComponent.map[context.data.id];}// get_view(context: Context): this[\"view\"] { return this.get_component(context).props.view; }\nget_view(context){var _transientProperties$,_transientProperties$2,_this$get_component,_this$get_component$p;return((_transientProperties$=transientProperties.node[context.data.id])===null||_transientProperties$===void 0?void 0:(_transientProperties$2=_transientProperties$.mainView)===null||_transientProperties$2===void 0?void 0:_transientProperties$2.r)||LPointerTargetable.fromPointer(context.data.view)||((_this$get_component=this.get_component(context))===null||_this$get_component===void 0?void 0:(_this$get_component$p=_this$get_component.props.view)===null||_this$get_component$p===void 0?void 0:_this$get_component$p.r);}set_view(val,context){Log.eDevv(\"node.view is readonly, change it through props or the model\");// let ptr: DGraphElement[\"view\"] = Pointers.from(val as this[\"view\"]);\n// return SetFieldAction.new(context.data.id, \"view\", ptr, '', true);\n}getSize(){let outer=arguments.length>0&&arguments[0]!==undefined?arguments[0]:false;let canTriggerSet=arguments.length>1&&arguments[1]!==undefined?arguments[1]:true;return this.wrongAccessMessage(\"getSize()\");}get_getSize(c){var _this=this;return function(){let outer=arguments.length>0&&arguments[0]!==undefined?arguments[0]:true;let canTriggerSet=arguments.length>1&&arguments[1]!==undefined?arguments[1]:true;return _this.get_innerSize(c,canTriggerSet,outer);};}get_outerSize(context){let canTriggerSet=arguments.length>1&&arguments[1]!==undefined?arguments[1]:true;return this.get_innerSize(context,canTriggerSet,true);}get_size(context){let canTriggerSet=arguments.length>1&&arguments[1]!==undefined?arguments[1]:true;return this.get_innerSize(context,canTriggerSet,false);}get_innerSize(context){let canTriggerSet=arguments.length>1&&arguments[1]!==undefined?arguments[1]:true;let outerSize=arguments.length>2&&arguments[2]!==undefined?arguments[2]:false;let r=this.get_innerSize_impl(context,canTriggerSet,outerSize);return new GraphSize(r.x,r.y,r.w,r.h);}get_innerSize_impl(context){var _this$get_component2,_this$get_component2$;let canTriggerSet=arguments.length>1&&arguments[1]!==undefined?arguments[1]:true;let outerSize=arguments.length>2&&arguments[2]!==undefined?arguments[2]:false;canTriggerSet=canTriggerSet&&!Debug.lightMode;let cname=context.data.className;// cname = DGraphElement.cname;\nswitch(cname){default:return Log.exDevv(\"unexpected classname in get_size switch: \"+context.data.className);case DEdge.cname:case DVoidEdge.cname:case DGraph.cname:return nosize;// case DField.cname:\ncase DGraphElement.cname:let graph=outerSize?this.get_outerGraph(context):this.get_innerGraph(context);return graph.coord(this.get_htmlSize(context));case DVoidVertex.cname:case DVertex.cname:case DEdgePoint.cname:case DGraphVertex.cname:break;}// low prio todo: memoization in proxy, as long state does not change keep a collection Dictionary[object][key] = returnval. it gets emptied when state is updated.\n// when loading a save, edge segements and edgepoints/nodes are computed before creating the edgepoint component\nlet view=this.get_view(context);// (window as any).retry = ()=>view.getSize(context.data.id);\nlet ret=view.getSize(context.data.id);// (this.props.dataid || this.props.nodeid as string)\nif(!ret){ret=new GraphSize();ret.x=context.data.x;ret.y=context.data.y;ret.w=context.data.w;ret.h=context.data.h;let def;if(undefined===ret.x){if(!def)def=view.defaultVSize;ret.x=def.x||0;}if(undefined===ret.y){if(!def)def=view.defaultVSize;ret.y=def.y||0;}if(undefined===ret.w){if(!def)def=view.defaultVSize;ret.w=def.w||10;}if(undefined===ret.h){if(!def)def=view.defaultVSize;ret.h=def.h|10;}ret.currentCoordType=context.data.currentCoordType;}if(context.data.className===DEdgePoint.cname){ret=this.decodePosCoords(context,ret,view);}/*\r\n                if ((context.data as DVoidVertex).isResized) {\r\n                    return ret;\r\n                }*/if(!canTriggerSet){if(outerSize)ret=this.get_outerGraph(context).translateSize(ret,this.get_innerGraph(context));return ret;}let html=(_this$get_component2=this.get_component(context))===null||_this$get_component2===void 0?void 0:(_this$get_component2$=_this$get_component2.html)===null||_this$get_component2$===void 0?void 0:_this$get_component2$.current;let actualSize=html?Size.of(html):{w:0,h:0};let isOldElement=context.data.clonedCounter>3;// if w = 0 i don't auto-set it as in first render it has w:0 because is not reredered and not resized.\n// console.log(\"getSize() cantriggerset html size\", {ret: ret ? {...ret} : ret, html, actualSize, hcc:html?.dataset?.clonedcounter, ncc: context.data.clonedCounter});\nif(!html||+html.dataset.clonedcounter!==context.data.clonedCounter)canTriggerSet=false;let updateSize=false;if(view.adaptWidth&&ret.w!==actualSize.w){if(canTriggerSet&&(isOldElement||actualSize.w!==0)){ret.w=actualSize.w;updateSize=true;}}if(view.adaptHeight&&ret.h!==actualSize.h){if(canTriggerSet&&(isOldElement||actualSize.h!==0)){ret.h=actualSize.h;updateSize=true;}}// console.log(\"getSize() from node merged with actualSize\", {ret: {...ret}});\nif(updateSize)this.set_size(ret,context);if(outerSize)ret=this.get_outerGraph(context).translateSize(ret,this.get_innerGraph(context));return ret;}// set_size(size: Partial<this[\"size\"]>, context: Context): boolean {\nset_size(size0,c){// console.log(\"setSize(\"+(this.props?.data as any).name+\") thisss\", this);\nif(!size0)return false;let size=size0;let view=this.get_view(c);let testmode=false;if(c.data.className===DEdgePoint.cname&&size.currentCoordType!==CoordinateMode.absolute)size=this.encodePosCoords(c,size,view);if(view.updateSize(c.data.id,size))return true;BEGIN();if(size.x!==c.data.x&&size.x!==undefined)SetFieldAction.new(c.data.id,\"x\",size.x,undefined,false);if(size.y!==c.data.y&&size.y!==undefined)SetFieldAction.new(c.data.id,\"y\",size.y,undefined,false);if(size.w!==c.data.w&&size.w!==undefined)SetFieldAction.new(c.data.id,\"w\",size.w,undefined,false);if(size.h!==c.data.h&&size.h!==undefined)SetFieldAction.new(c.data.id,\"h\",size.h,undefined,false);let epdata=c.data;if(size.currentCoordType!==epdata.currentCoordType&&size.currentCoordType!==undefined)SetFieldAction.new(epdata.id,\"currentCoordType\",size.currentCoordType,undefined,false);END();return true;}get_html(c){let component=this.get_component(c);let html=component===null||component===void 0?void 0:component.html.current;if(html)return html;html=$('[nodeid=\"'+c.data.id+'\"]')[0];if(!html)return undefined;if(component)component.html.current=html;return html;}// get_html(context: Context): this[\"html\"] { return $(\"[node-id='\" + context.data.id + \"']\")[0]; }\nset_html(val,context){return this.cannotSet(\"set_html(). html is generated through jsx. edit the view instead.\");}get_htmlSize(context){let html=this.get_html(context);return html?Size.of(html):new Size(0,0,0,0);/*\r\n        let graph = this.get_graph(context);\r\n        if (!html) return nosize as any;\r\n        let size = Size.of(html);\r\n        let zoom = graph.zoom;\r\n        size.x /= zoom.x;\r\n        size.y /= zoom.y;\r\n        return size;*/}set_htmlSize(val,context){// might be useful for fixed display size/location elements that stay in place even if you move tab or change zoom. debatable if needed\nthis.cannotSet(\"set_htmlSize(): todo extra low priority. set GraphSize through set_size instead.\");return true;}get_htmlPosition(context){return this.get_htmlSize(context).tl();}set_htmlPosition(val,context){// might be useful for fixed display size/location elements that stay in place even if you move tab or change zoom. debatable if needed\nthis.cannotSet(\"set_htmlPosition(): todo extra low priority. set graph position through set_position instead.\");return true;}/* how z-index work, it's really messy.\r\n    * cannot move html position. node id depends on it, and a node moving position would need to change id.\r\n    * so i use css order.\r\n    * first order is assigned through node constructor called by parent component injectProps, according to his last index in html.\r\n    * now z-index is set in node and updated properly.\r\n    * z-index is passed to a prop, rendered as html attribute.\r\n    * css takes the attribute value and uses it in \"order\" css rule.\r\n    * problem: updating node.z doesn't trigger the parent injectprops, so he inject html index and\r\n    * the outernmost html root cannot update his attribute without refreshing the parent and recalling injectprops\r\n    * fixed: by updating it directly in GraphElement.render()\r\n    * */get_zIndex(context){return+context.data.zIndex||0;}set_zIndex(val,context){var _val;SetFieldAction.new(context.data.id,\"zIndex\",(_val=+val)!==null&&_val!==void 0?_val:0,undefined,false);return true;}get_z(context){return context.data.zIndex;}set_z(val,context){return this.set_zIndex(val,context);}/*\r\n        get_containedIn(context: Context): this[\"containedIn\"] {\r\n            return context.data.containedIn ? LPointerTargetable.fromPointer(context.data.containedIn) : undefined; }\r\n        set_containedIn(val: Pack1<this[\"containedIn\"]>, context: LogicContext<DGraphElement>): boolean {\r\n            let ptr: DGraphElement[\"containedIn\"] = Pointers.from(val) as any;\r\n            SetFieldAction.new(context.data, 'containedIn', ptr, undefined, true);\r\n            if (ptr) SetFieldAction.new(ptr as any, 'subElements+=', context.data.id);\r\n            return true; }*/get_nodes(c){return this.get_subElements(c).filter(c=>c&&c.className.indexOf('Vertex')>=0);}set_nodes(val,c){return this.cannotSet('nodes');}get_edges(c){return this.get_subElements(c).filter(c=>c&&c.className.indexOf('Edge')>=0);}set_edges(val,c){return this.cannotSet('edges');}get_graphs(c){return this.get_subElements(c).filter(c=>c&&c.className.indexOf('Graph')>=0);}set_graphs(val,c){return this.cannotSet('graphs');}get_allSubNodes(c){return this.get_allSubElements(c).filter(c=>c&&c.className.indexOf('Vertex')>=0);}set_allSubNodes(val,c){return this.cannotSet('allSubNodes');}get_allSubEdges(c){return this.get_allSubElements(c).filter(c=>c&&c.className.indexOf('Edge')>=0);}set_allSubEdges(val,c){return this.cannotSet('allSubEdges');}get_allSubGraphs(c){return this.get_allSubElements(c).filter(c=>c&&c.className.indexOf('Graph')>=0);}set_allSubGraphs(val,c){return this.cannotSet('allSubGraphs');}// shallow, direct subelements\nget_subElements(context){return LPointerTargetable.fromArr([...new Set(context.data.subElements)]).filter(e=>!!e);}set_subElements(val,context){console.log(\"isDeepStrictEqual\",{isDeepStrictEqual});Log.eDev([...new Set(val)].length!==val.length,\"subelemnts setter have duplicates\",{val,context});// if (isDeepStrictEqual(context.data.subElements, val)) return true;\nlet pointers=Pointers.from(val)||[];if(Uarr.equals(pointers,context.data.subElements,false))return true;SetFieldAction.new(context.data,'subElements',pointers,'',true);const idlookup=store.getState().idlookup;let arrdiff=U.arrayDifference(context.data.subElements,pointers);// old subelements\nfor(let oldsubelementid of arrdiff.removed){let subelement=oldsubelementid&&idlookup[oldsubelementid];if(subelement.father!==context.data.id)continue;LPointerTargetable.from(subelement).father=null;// todo: can this happen? è transitorio o causa vertici senza parent permanenti?\n}// new subelements\nfor(let newsubelementid of arrdiff.added){let subelement=newsubelementid&&idlookup[newsubelementid];if(subelement.father===context.data.id)continue;LPointerTargetable.from(subelement).father=context.data.id;// trigger side-action\n}return true;}// deep, nested subelements\nget_allSubElements(context,state){// return context.data.packages.map(p => LPointerTargetable.from(p));\nstate=state||store.getState();let tocheck=context.data.subElements||[];let checked={};let dblcheck={};// <child, parent>  // debug only\nfor(let e of tocheck)dblcheck[e]=context.data.id;// debug only\nchecked[context.data.id]=true;//nb6[]{}&\nwhile(tocheck.length){let newtocheck=[];for(let ptr of tocheck){Log.eDev(checked[ptr],\"loop in GraphElements containing themselves\",{dblcheck,context,ptr,checked,fistContainer:dblcheck[ptr]});if(checked[ptr])continue;checked[ptr]=true;let subnode=DPointerTargetable.from(ptr,state);let se=subnode===null||subnode===void 0?void 0:subnode.subElements;//for (let e of se) dblcheck[e] = ptr; // debug only\nU.arrayMergeInPlace(newtocheck,se);}tocheck=newtocheck;}delete checked[context.data.id];return LPointerTargetable.from(Object.keys(checked),state);}set_allSubElements(val,c){return this.cannotSet('allSubElements');}get_isResized(context){return context.data.isResized;}set_isResized(val,context){return SetFieldAction.new(context.data.id,\"isResized\",val);}get_model(context){const modelElementId=context.data.model;//$('[id=\"' + context.data.id + '\"]')[0].dataset.dataid;\nconst lModelElement=LPointerTargetable.from(modelElementId);return lModelElement;}get_assignEdgeAnchor(c){return anchorName=>{if(anchorName&&!c.data.anchors[anchorName])anchorName=undefined;if(LVoidEdge.startFollow){let de=DPointerTargetable.fromPointer(LVoidEdge.startFollow);if(de.start!==c.data.id)return;// cannot change edge targets, only an anchor within the current targets\nlet le=LPointerTargetable.fromD(de);le.anchorStart=anchorName;le.startFollow=false;}if(LVoidEdge.endFollow){let de=DPointerTargetable.fromPointer(LVoidEdge.endFollow);if(de.end!==c.data.id)return;// cannot change edge targets, only an anchor within the current targets\nlet le=LPointerTargetable.fromD(de);le.anchorEnd=anchorName;le.endFollow=false;}};}get_events(c){const tn=transientProperties.node[c.data.id];let mainview=tn.mainView.__raw;let otherViews=tn.stackViews.map(v=>v.__raw);let allviews=[mainview,...otherViews].reverse();const keep_for_closure_original_funcs={};const ret={};for(let dv of allviews)U.objectMergeInPlace(keep_for_closure_original_funcs,transientProperties.view[dv.id].events);const lastContext=tn.viewScores[mainview.id].evalContext;const keys=Object.keys(keep_for_closure_original_funcs);// for (let k of keys) ret['_raw_'+k] = keep_for_closure_original_funcs[k];\nfor(let k of keys){if(!keep_for_closure_original_funcs[k])continue;ret[k]=function(){for(var _len=arguments.length,_params=new Array(_len),_key=0;_key<_len;_key++){_params[_key]=arguments[_key];}return keep_for_closure_original_funcs[k](lastContext,..._params);};}return ret;}get_father(context){return LPointerTargetable.fromPointer(context.data.father);}set_father(val,context){let ptr=Pointers.from(val);SetFieldAction.new(context.data,'father',ptr,undefined,true);if(ptr)SetFieldAction.new(ptr,'subElements+=',context.data.id);return true;}select(forUser){return this.wrongAccessMessage(\"node.select()\");}deselect(forUser){return this.wrongAccessMessage(\"node.deselect()\");}toggleSelected(forUser){return this.wrongAccessMessage(\"node.toggleSelected()\");}isSelected(forUser){return this.wrongAccessMessage(\"node.isSelected()\");}get_select(c){return forUser=>{if(!forUser)forUser=DUser.current;if(c.data.isSelected[forUser])return;// no-op\nlet map={...c.data.isSelected};map[forUser]=true;SetFieldAction.new(c.data.id,\"isSelected\",map,undefined,false);// todo: actually they are pointer to users, but i'm assuming users are not erased at runtime. on deselect too\n};}get_deselect(c){return forUser=>{if(!forUser)forUser=DUser.current;if(!c.data.isSelected[forUser])return;// no-op\nlet map={...c.data.isSelected};delete map[forUser];SetFieldAction.new(c.data.id,\"isSelected\",map,undefined,false);// todo: actually they are pointer to users, but i'm assuming users are not erased at runtime. on deselect too\n};}get_toggleSelected(context){return forUser=>{if(!forUser)forUser=DUser.current;if(this.get_isSelected(context)(forUser)){this.get_deselect(context)(forUser);return false;}else{this.get_select(context)(forUser);return true;}};}get_isSelected(context){return forUser=>{if(!forUser)forUser=DUser.current;return!!context.data.isSelected[forUser];};}set_isSelected(val,context){return this.cannotSet(\"graphElement.isSelected(): use this.select() or this.deselect() instead.\");}/*\r\n    get_isSelected(context: LogicContext<DVoidVertex>): GObject {\r\n        return DPointerTargetable.mapWrap(context.data.isSelected, context.data, 'idlookup.' + context.data.id + '.isSelected', []);\r\n    }*/ // for edges\nget_startPoint(c,size,view){return this.get_startEndPoint(c,size,view,true);}get_endPoint(c,size,view){return this.get_startEndPoint(c,size,view,false);}get_startEndPoint(c,size,view){let isStart=arguments.length>3&&arguments[3]!==undefined?arguments[3]:true;if(!size){if(c)size=this.get_size(c);else size=Log.exDevv(\"invalid arguments in get_startEndPoint\",{arguments});}if(!view){// if (c) view = this.get_view(c); else view = Log.exDevv(\"invalid arguments in get_startPoint\", {arguments});\nview=c&&this.get_view(c)||Log.exDevv(\"invalid arguments in get_startEndPoint\",{arguments});}let offset=view[isStart?\"edgeStartOffset\":\"edgeEndOffset\"];let isPercentage=view[isStart?\"edgeStartOffset_isPercentage\":\"edgeEndOffset_isPercentage\"];if(!size)size=new GraphSize(0,0,0,0);if(isPercentage)offset=new GraphPoint(offset.x/100*size.w,offset.y/100*size.h);return size.tl().add(offset,false);}},_class4.subclasses=[],_class4._extends=[],_class4))||_class3);RuntimeAccessibleClass.set_extend(DPointerTargetable,DGraphElement);RuntimeAccessibleClass.set_extend(LPointerTargetable,LGraphElement);export let DGraph=(_dec3=RuntimeAccessible('DGraph'),_dec3(_class5=(_class6=class DGraph extends DGraphElement{constructor(){super(...arguments);this.father=void 0;this.id=void 0;this.graph=void 0;this.model=void 0;this.isSelected=void 0;this.state=void 0;this.zoom=void 0;this.offset=void 0;}// static _super = DGraphElement;\n// static singleton: LGraph;\n// static logic: typeof LGraph;\n// static structure: typeof DGraph;\n// inherit redefine\n// containedIn!: Pointer<DGraphElement, 0, 1, LGraphElement>;\n// personal attributes\n// in-graph scrolling offset\nstatic new(htmlindex,model,parentNodeID,// immediate parent\nparentgraphID,// graph containing this subgraph (redudant? could get it from father chain)\nnodeID){return new Constructors(new DGraph('dwc'),parentNodeID,true,undefined,nodeID||Constructors.DGraph_makeID(model)).DPointerTargetable().DGraphElement(model,parentgraphID,htmlindex).DGraph().end();}static getNodes(dmp,out){let $allnodes=$('[data-dataid]');let matchedids=(dmp||[]).map(d=>d.id);let matchedidmap=U.objectFromArrayValues(matchedids);if(!out)out={};let allnodesarr=[...$allnodes];let filternode=d=>{var _d$dataset,_d$dataset2;if(!(d===null||d===void 0?void 0:(_d$dataset=d.dataset)===null||_d$dataset===void 0?void 0:_d$dataset.dataid))return false;let id=''+(d===null||d===void 0?void 0:(_d$dataset2=d.dataset)===null||_d$dataset2===void 0?void 0:_d$dataset2.dataid);return matchedidmap[id];};out.$matched=$(allnodesarr.filter(filternode));out.$notMatched=$(allnodesarr.filter(n=>!filternode(n)));return out.$matched;// throw new Error(\"Method not implemented.\");\n}},_class6.subclasses=[],_class6._extends=[],_class6))||_class5);var nosize={x:0,y:0,w:0,h:0,nosize:true};var defaultEdgePointSize=undefined;// = {x:0, y:0, w:5, h:5};\nvar defaultVertexSize=undefined;// {x:0, y:0, w:140.6818084716797, h:32.52840805053711};\nexport let LGraph=(_dec4=RuntimeAccessible('LGraph'),_dec4(_class7=(_class8=class LGraph extends LGraphElement{constructor(){super(...arguments);this.__raw=void 0;this.id=void 0;this.graph=void 0;this.model=void 0;this.subElements=void 0;this._state=void 0;this.zoom=void 0;this.graphSize=void 0;this.offset=void 0;this.cumulativeZoom=void 0;this.__info_of__cumulativeZoom={type:GraphPoint.cname,txt:\"the product of all the ownZoom of containing ancestor graphs.\"};this.ownZoom=void 0;this.__info_of__ownZoom={type:GraphPoint.cname,label:\"zoom\",txt:\"The individual zoom applied to this graph.\"};this.__info_of__zoom={type:GraphPoint.cname,label:\"zoom\",txt:\"Scales the graph and all subelements by a factor.\"};this.__info_of__offset={type:GraphPoint.cname,label:\"offset\",txt:\"In-graph scrolling position.\"};this.__info_of__graphSize={type:GraphSize.cname,label:\"graphSize\",txt:\"size internal to the graph, including internal scroll and panning.\"};this.__info_of__translateSize={type:\"(T, Graph)=>T where T is GraphSize | GraphPoint\",txt:\"Translates a coordinate set from the local coordinates of a SubGraph to this Graph containing it.\"};this.__info_of__translateHtmlSize={type:\"(Size|Point) => GraphSize|GraphPoint\",txt:'Translate page\\'s viewport coordinate set to this graph coordinate set.'};this.screenOffset=void 0;this.__info_of__screenOffset={type:GraphPoint.cname,txt:\"Distance of the subgraph origin in rendered pixels. to the top-left of graph container.\"};}// static singleton: LGraph;\n// static logic: typeof LGraph;\n// static structure: typeof DGraph;\n// inherit redefine\n// isSelected: Dictionary<DocString<Pointer<DUser>>, boolean> = {};\nisSelected(forUser){return this.wrongAccessMessage(\"node.isSelected()\");}// containedIn?: LGraphElement;\n// LMap;\n// personal attributes\n// derived attribute: bounding rect containing all subnodes, while \"size\" is instead external size of the vertex holding the graph in GraphVertexes\n// Scrolling position inside the graph\n// get_graphSize(context: LogicContext<DGraph>):  Readonly<GraphSize> { return todo: get bounding rect containing all subnodes.; }\nget_offset(context){let offset=context.data.offset||new GraphSize();return new GraphSize(offset.x,offset.y,offset.w,offset.h);}set_offset(val,context){if(!val)val={x:0,y:0,w:0,h:0};//if (val.x === undefined && val.y === undefined && val.w === undefined && val.h === undefined) return true;\nlet offset=context.data.offset||new GraphSize();if(val.x===undefined&&offset.x!==val.x)val.x=offset.x;if(val.y===undefined&&offset.y!==val.y)val.y=offset.y;if(val.w===undefined&&offset.w!==val.w)val.w=offset.w;if(val.h===undefined&&offset.h!==val.h)val.h=offset.h;if(offset.x===val.x&&offset.y===val.y&&offset.w===val.w&&offset.h==val.h)return true;SetFieldAction.new(context.data,\"offset\",val);return true;}get_cumulativeZoom(c){let ancestors=[c.proxyObject,...this.get_graphAncestors(c)];let zoom=new GraphPoint(1,1);for(let g of ancestors)zoom.multiply(g.ownZoom,false);return zoom;}get_zoom(c){return this.get_cumulativeZoom(c);}get_ownZoom(context){const zoom=context.data.zoom;let ret=new GraphPoint(zoom.x||1,zoom.y||1);// NB: do not use (??1), zero is not a valid value for zoom.\n// (zoom as any).debug = {rawgraph: context.data.__raw, zoomx: context.data.zoom.x, zoomy: context.data.zoom.y}\nreturn ret;}set_zoom(val,c){if(!val)val={x:1,y:1};//if (val.x === undefined && val.y === undefined) return true;\nlet zoom=c.data.zoom||new GraphSize();if(!val.x)val.x=zoom.x;// remember zero is not allowed value\nif(!val.y)val.y=zoom.y;if(zoom.x===val.x&&zoom.y===val.y)return true;SetFieldAction.new(c.data,'zoom',val,'+=',false);return true;}toGraphSize(){return this.wrongAccessMessage(\"toGraphSize\");}coord(htmlSize){return this.wrongAccessMessage(\"toGraphSize\");}get_coord(context){return htmlSize=>{let graphHtmlSize=this.get_htmlSize(context);let zoom=this.get_zoom(context);return new GraphSize((htmlSize.x-graphHtmlSize.x)/zoom.x,(htmlSize.y-graphHtmlSize.y)/zoom.y,htmlSize.w/zoom.x,htmlSize.h/zoom.y);};}// get_htmlSize(context: Context): Size { }\ntranslateSize(ret,innerGraph){return this.wrongAccessMessage(\"translateSize()\");}translateHtmlSize(size){return this.wrongAccessMessage(\"translateHtmlSize()\");}get_translateHtmlSize(c){return size=>{let rootGraph=this.get_root(c);if(rootGraph.id===c.data.id)return this.get_translateHtmlSize_fromRoot(c)(size);let fakeRootSize=rootGraph.translateHtmlSize_fromRoot(size);let screenOffset=this.get_screenOffset(c);//cumulative (g.size.tl()-offset.tl()*cumulativezoom)\n// distance from the origin of the subgraph in rendered pixels\nlet ret=new GraphSize(fakeRootSize.x-screenOffset.x,fakeRootSize.y-screenOffset.y,fakeRootSize.w,fakeRootSize.h);return ret.divide(this.get_cumulativeZoom(c),false);/*\r\n            // fake because it assumes all subgraphs have the same zoom level of current graph.\r\n            let ancestors = this.get_graphAncestors(c).reverse().slice(1);\r\n            let cumulativeZoom: GraphPoint = new GraphPoint(1, 1); // = this.get_ownZoom(c);\r\n            for (let g of ancestors){\r\n                let offset = g.offset;\r\n                let ownZoom = g.ownZoom;\r\n                cumulativeZoom.multiply(ownZoom);\r\n                // let a, b, c be graphs\r\n                // size is =  a.zoom + a.offset\r\n\r\n            }\r\n            */};}get_screenOffset(c){let ancestors=[c.proxyObject,...this.get_graphAncestors(c)].reverse();let ret=new GraphPoint(0,0);let cumulativeZoom=new GraphPoint(1,1);// = this.get_ownZoom(c);\nfor(let g of ancestors){let offset=g.offset;let ownZoom=g.ownZoom;let size=g.size;ret.add(size.tl().multiply(cumulativeZoom,false),false).subtract(offset,false);cumulativeZoom.multiply(ownZoom);ret.multiply(cumulativeZoom,false);}return ret;}translateHtmlSize_fromRoot(size){return this.wrongAccessMessage('translateHtmlSize_fromRoot');}/**\r\n     *  IMPORTANT!\r\n     *  this is a wrong partial result, do not call this function directly outside translateHtmlSize.\r\n     *  this is outercoord without zoom, needs ti be translated to container graph coords & de-apply zoom\r\n     */get_translateHtmlSize_fromRoot(c){return size=>{let graphHtmlSize=this.get_htmlSize(c);let a=size.subtract(graphHtmlSize.tl(),true);let offset={x:c.data.offset.x,y:c.data.offset.y};let b=a.subtract(offset,true);let r=b.divide(c.data.zoom,false);return r;};}// graph_of_size, the size parameter have coordinates based on this graph.\nget_translateSize(c){return(size,graph_of_size)=>{let targetGraph=c.proxyObject;let currGraph=graph_of_size;if(currGraph.id===c.data.id)return size;let currAncestors=[currGraph,...currGraph.graphAncestors];let targetAncestors=[targetGraph,...targetGraph.graphAncestors];let currAncestorsPtr=currAncestors.map(l=>l.id).reverse();let targetAncestorsPtr=targetAncestors.map(l=>l.id).reverse();Log.ex(targetAncestorsPtr[0]!==currAncestorsPtr[0],'translateSize() The root graph of 2 elements should always be the same, are you comparing nodes from different graphs?',{currGraph,targetGraph});let i=1;while(currAncestorsPtr[i]===targetAncestorsPtr[i]){i++;}let commonAncestor=targetAncestorsPtr[i-1];currAncestors=currAncestors.slice(0,currAncestors.length-i).filter(e=>!!e);targetAncestors=targetAncestors.slice(0,currAncestors.length-i).filter(e=>!!e);// d, c, b, a           currAncestors\n// d, c, x, y           targetAncestors\n// undo a,b, redo x,y        i = [2]\nLog.exDev(!currAncestors.length&&!targetAncestors.length,\"translateSize() found invalid intersection in container graphs\",{currGraph,targetGraph,currAncestors,targetAncestors});// @ts-ignore\nlet ret='w'in size?new GraphSize(size.x,size.y,size.w,size.h):new GraphPoint(size.x,size.y,size.w,size.h);console.log(\"translateSizee pre\",this.get_model(c).name,size.x,size.y,{size,ret,currAncestors,targetAncestors});for(let g of currAncestors){ret.subtract(g.offset,false);ret.divide(g.cumulativeZoom,false);ret.add(g.size.tl(),false);}for(let g of targetAncestors){ret.subtract(g.size.tl(),false);ret.multiply(g.cumulativeZoom,false);ret.add(g.offset,false);}console.log(\"translateSizee ret\",this.get_model(c).name,size.x,size.y,{size,ret,currAncestors,targetAncestors});return ret;};//todo: check how many passes you need to go down or up, and make the up version too\n}get_translateSize_down_old(c){return(size,graph_of_size)=>{graph_of_size=LPointerTargetable.wrap(graph_of_size);let ret=size.hasOwnProperty(\"w\")?new GraphSize(size.x,size.y,size.w,size.h):new GraphPoint(size.x,size.y);Log.ex(!graph_of_size,\"translateSize() graph parameter is invalid: \"+graph_of_size,graph_of_size,c);let ancestors=[graph_of_size,...graph_of_size.graphAncestors];console.log(\"translateSize\",{innerGraph:graph_of_size,ret,ancestors,c});Log.ex(ancestors.indexOf(c.proxyObject)!==-1,\"translateSize() graph parameter is invalid: it must be a graph containing the current one.\",graph_of_size,c);for(let g of ancestors)ret.add(g.size.tl(),false);// for (let g of ancestors) ret.subtract(g.offset, false);\n// console.log(\"translateSize\", {c, thiss:c.proxyObject, ancestors, ancestorSizes: ancestors.map(a=> a.size.tl()), size, ret});\nreturn ret;};}contains(elem){return this.wrongAccessMessage(\"contains()\");}get_contains(c){return elem=>{let current=elem;let next=elem.father;let targetid=c.proxyObject.id;if(current.id!==targetid)return true;while(next&&current.id!==next.id){current=next;next=next.father;if(current.id!==targetid)return true;}return false;};}},_class8.subclasses=[],_class8._extends=[],_class8))||_class7);RuntimeAccessibleClass.set_extend(DGraphElement,DGraph);RuntimeAccessibleClass.set_extend(LGraphElement,LGraph);// export const defaultVSize: GraphSize = new GraphSize(0, 0, 300, 160); // useless, now it's in view.DefaultVSize\n// export const defaultEPSize: GraphSize = new GraphSize(0, 0, 15, 15); // useless, now it's in view.DefaultVSize\nexport let DVoidVertex=(_dec5=RuntimeAccessible('DVoidVertex'),_dec5(_class9=(_class10=class DVoidVertex extends DGraphElement{constructor(){super(...arguments);this.id=void 0;this.graph=void 0;this.model=void 0;this.isSelected=void 0;this.subElements=void 0;this.state=void 0;this.zoom=void 0;this.x=void 0;this.y=void 0;this.w=void 0;this.h=void 0;this.isResized=void 0;}// static _super = DGraphElement;\n// static singleton: LVoidVertex;\n// static logic: typeof LVoidVertex;\n// static structure: typeof DVoidVertex;\n// inherit redefine\n// containedIn!: Pointer<DGraphElement, 0, 1, LGraphElement>;\n// personal attributes\n// size?: GraphSize; // virtual, gets extracted from this. x and y are stored directly here as it extends GraphSize\nstatic new(htmlindex,model,parentNodeID,graphID,nodeID,size){return new Constructors(new DVoidVertex('dwc'),parentNodeID,true,undefined,nodeID).DPointerTargetable().DGraphElement(model,graphID,htmlindex).DVoidVertex(size||defaultVertexSize).end();}},_class10.subclasses=[],_class10._extends=[],_class10))||_class9);export let LVoidVertex=(_dec6=RuntimeAccessible('LVoidVertex'),_dec6(_class11=(_class12=class LVoidVertex extends LGraphElement{constructor(){super(...arguments);this.__raw=void 0;this.id=void 0;this.graph=void 0;this.model=void 0;this.subElements=void 0;this._state=void 0;this.zoom=void 0;this.isResized=void 0;this.x=void 0;this.y=void 0;this.w=void 0;this.h=void 0;this.size=void 0;this.__info_of__size={type:\"?GraphSize\",txt:\"Size of the vertex, if null it means is utilizing the defaultSize from view. recommended to read component.getSize() instead of this.\"};}// <D extends DVoidVertex = any>\n// static singleton: LVoidVertex;\n// static logic: typeof LVoidVertex;\n// static structure: typeof DVoidVertex;\n// inherit redefine\n// isSelected: Dictionary<DocString<Pointer<DUser>>, boolean> = {};\nisSelected(forUser){return this.wrongAccessMessage(\"node.isSelected()\");}// containedIn?: LGraphElement;\n// LMap;\n// personal attributes\n// virtual, gets extracted from this. x and y are stored directly here as it extends GraphSize\nget_isResized(context){return context.data.isResized;}set_isResized(val,context){return SetFieldAction.new(context.data.id,\"isResized\",val);}},_class12.subclasses=[],_class12._extends=[],_class12))||_class11);RuntimeAccessibleClass.set_extend(DGraphElement,DVoidVertex);RuntimeAccessibleClass.set_extend(LGraphElement,LVoidVertex);export let DEdgePoint=(_dec7=RuntimeAccessible('DEdgePoint'),_dec7(_class13=(_class14=class DEdgePoint extends DVoidVertex{constructor(){super(...arguments);this.id=void 0;this.father=void 0;this.graph=void 0;this.model=void 0;this.isSelected=void 0;this.subElements=void 0;this.zoom=void 0;this.x=void 0;this.y=void 0;this.w=void 0;this.h=void 0;this.size=void 0;this.__isDEdgePoint=void 0;this.currentCoordType=void 0;}// DVoidVertex\n// static singleton: LEdgePoint;\n// static logic: typeof LEdgePoint;\n// static structure: typeof DEdgePoint;\n// inherit redefine\n// todo: if null gets model from this.father (edge)?\n// containedIn!: Pointer<DGraphElement, 0, 1, LGraphElement>;\n//／／ virtual, gets extracted from this. x and y are stored directly here as it extends GraphSize\n// personal attributes\nstatic new(htmlindex,model,parentNodeID,graphID,nodeID,size){return new Constructors(new DEdgePoint('dwc'),parentNodeID,true,undefined,nodeID).DGraphElement(undefined,graphID,htmlindex).DVoidVertex(size||defaultEdgePointSize).DEdgePoint().end();}},_class14.subclasses=[],_class14._extends=[],_class14))||_class13);export let LEdgePoint=(_dec8=RuntimeAccessible('LEdgePoint'),_dec8(_class15=(_class16=class LEdgePoint extends LVoidVertex{constructor(){super(...arguments);this.father=void 0;this.id=void 0;this.graph=void 0;this.model=void 0;this.subElements=void 0;this.zoom=void 0;this.x=void 0;this.y=void 0;this.w=void 0;this.h=void 0;this.size=void 0;this.__isLEdgePoint=void 0;this.edge=void 0;this.__info_of__edge={type:\"?LEdge\",txt:\"returns the containing edge if called on an EdgePoint, \\\"this\\\" if called on an edge, undefined otherwise.\"};}// static singleton: LEdgePoint;\n// static logic: typeof LEdgePoint;\n// static structure: typeof DEdgePoint;\n// inherit redefine\n// __raw!: DEdgePoint;\n// isSelected: Dictionary<DocString<Pointer<DUser>>, boolean> = {};\nisSelected(forUser){return this.wrongAccessMessage(\"node.isSelected()\");}// containedIn?: LGraphElement;\n// virtual, gets extracted from this. x and y are stored directly here as it extends GraphSize\n// personal attributes\n// returns container edge\nget_edge(c){return c.proxyObject.father;}set_edge(v,c){return this.set_father(v,c);}static decodeCoords(size0,sp,ep)/*absolute*/{let size=size0;let ret=\"w\"in size||\"h\"in size?new GraphSize():new GraphPoint();// GObject<Partial<GraphSize>>;\nswitch(size.currentCoordType){default:return Log.exDevv(\"translatePosCoords() invalid coordinate mode\",{mode:size.currentCoordType});// case CoordinateMode.absolute: return size;\ncase CoordinateMode.absolute:case undefined:case null:if(size.x!==undefined)ret.x=size.x;if(size.y!==undefined)ret.y=size.y;break;case CoordinateMode.relativePercent://maybe do: dampening factor on relative % offset? is it possible?\n// let s = this.getBasicSize(c);\n// MATH:\n// size.x = sp.x*x% + ep.x*(1-x%)\n// size.x = sp.x*x% + ep.x - ep.x*x%\n// size.x - ep.x= (sp.x - ep.x)*x%\n// (size.x - ep.x) / (sp.x - ep.x) = x% // actually i inverted <sp, ep> in first equation, so reverse them in result too.\nif(size.x!==undefined)ret.x=(1-size.x)*sp.x+size.x*ep.x;if(size.y!==undefined)ret.y=(1-size.y)*sp.y+size.y*ep.y;break;case CoordinateMode.relativeOffset:case CoordinateMode.relativeOffsetStart:case CoordinateMode.relativeOffsetEnd:let useStart;let useEnd;switch(size.currentCoordType){default:case CoordinateMode.relativeOffset:useStart=true;useEnd=true;break;case CoordinateMode.relativeOffsetStart:useStart=true;useEnd=false;break;case CoordinateMode.relativeOffsetEnd:useStart=false;useEnd=true;break;}// offset = sp - size\n// size = offset - sp\n// in reverse: actualsize = offset, size=offset\n// if coords are already in absolute mode.\nlet xIsAbsolute=size.x&&!Array.isArray(size.x)?size.x:undefined;let yIsAbsolute=size.x&&!Array.isArray(size.x)?size.x:undefined;Log.w(!!(xIsAbsolute||yIsAbsolute),\"decoding relative offset require an array size coordinate system. x=[x1, x2] --> x\",{size});let offsetsp=useStart?new GraphPoint(xIsAbsolute||size.x[0]+sp.x,yIsAbsolute||size.y[0]+sp.y):new GraphPoint();let offsetep=useEnd?new GraphPoint(xIsAbsolute||size.x[1]+ep.x,yIsAbsolute||size.y[1]+ep.y):new GraphPoint();// if the start and endpoint of the edge didn't move, offsetsp = offsetep.\n// if they moved, those 2 are discordant --> i pick middle\noffsetsp.add(offsetep,false);if(useStart&&useEnd)offsetsp.divide(2,false);if(!xIsAbsolute&&size.x!==undefined)ret.x=offsetsp.x;if(!yIsAbsolute&&size.y!==undefined)ret.y=offsetsp.y;if(xIsAbsolute){ret.x=size.x;}if(yIsAbsolute){ret.y=size.y;}break;}if(size.x===undefined)delete ret.x;if(size.y===undefined)delete ret.y;if(size.w===undefined)delete ret.w;else ret.w=size.w;if(size.h===undefined)delete ret.h;else ret.h=size.h;ret.currentCoordType=CoordinateMode.absolute;// console.log(\"decode coords\", {size, sp, ep, ret});\nreturn ret;}// from x,y as coords, to x%,y% as % of ((1-val)%*startpt) + ((val)%*endpt)\ndecodePosCoords(c,size,view,sp0,ep0){let le=c&&c.proxyObject.father;// console.log(\"decodepos:\", {le, sp0, lesp:le?.startPoint});\nlet sp=sp0||le.startPoint;let ep=ep0||le.endPoint;return LEdgePoint.decodeCoords(size,sp,ep);}static testCoords(){let range=arguments.length>0&&arguments[0]!==undefined?arguments[0]:30;outer:for(let mode of[\"absolute\",\"relative%\",\"relativeOffset\",\"relativeOffsetStart\",\"relativeOffsetEnd\"])for(let i=-range;i<range;i++)for(let j=-range;j<range;j++){var s0={x:i,y:j};var sp={x:10,y:10};var ep={x:10,y:-10};// @ts-ignore\nvar s1=LEdgePoint.encodeCoords(s0,mode,sp,ep);// @ts-ignore\nvar s00=LEdgePoint.decodeCoords(s1,sp,ep);// @ts-ignore\nvar error=Object.keys(s0).map(k=>s0[k].toFixed(3)===s00[k].toFixed(3)?'':k).join('');(mode!=\"relative%\"&&error?console.error:console.log)({diff:[s00.x-s0.x,s00.y-s0.y].join(),i,j,mode,s1:[s1.x,s1.y].join(),s0,s00,error});if(mode!=\"relative%\"&&error)break outer;}}// @ts-ignore a\nstatic encodeCoords(size0,edgePointCoordMode,sp,ep)/*absolute*/{let size=size0;if(edgePointCoordMode===size.currentCoordType||!size.currentCoordType&&edgePointCoordMode===CoordinateMode.absolute)return size;if(size.currentCoordType&&size.currentCoordType!==CoordinateMode.absolute)size=LEdgePoint.decodeCoords(size,sp,ep);let ret=\"w\"in size||\"h\"in size?new GraphSize():new GraphPoint();// GObject<Partial<GraphSize>>;\nswitch(edgePointCoordMode){default:return Log.exDevv(\"translatePosCoords() invalid coordinate mode\",{mode:edgePointCoordMode});// case CoordinateMode.absolute: return size;\ncase CoordinateMode.relativePercent:// let s = this.getBasicSize(c);\n// MATH:\n// size.x = sp.x*x% + ep.x*(1-x%)\n// size.x = sp.x*x% + ep.x - ep.x*x%\n// size.x - ep.x= (sp.x - ep.x)*x%\n// (size.x - ep.x) / (sp.x - ep.x) = x% // actually i inverted <sp, ep> in first equation, so reverse them in result too.\nif(sp.x===ep.x)ret.x=0.5;// because otherwise it is infinity. so i force him to return in line.\nelse if(size.x!==undefined)ret.x=(size.x-sp.x)/(ep.x-sp.x);if(sp.y===ep.y)ret.y=0.5;else if(size.y!==undefined)ret.y=(size.y-sp.y)/(ep.y-sp.y);break;case CoordinateMode.relativeOffset:case CoordinateMode.relativeOffsetStart:case CoordinateMode.relativeOffsetEnd:let useStart;let useEnd;switch(edgePointCoordMode){default:case CoordinateMode.relativeOffset:useStart=true;useEnd=true;break;case CoordinateMode.relativeOffsetStart:useStart=true;useEnd=false;break;case CoordinateMode.relativeOffsetEnd:useStart=false;useEnd=true;break;}if(size.x)ret.x=[useStart?size.x-sp.x:-1,useEnd?size.x-ep.x:-1];if(size.y)ret.y=[useStart?size.y-sp.y:-1,useEnd?size.y-ep.y:-1];/*\r\n                if (size.x) ret.x = [sp.x - size.x, ep.x - size.x];\r\n                if (size.y) ret.y = [sp.y - size.y, ep.y - size.y];*/break;}if(size.x===undefined)delete ret.x;if(size.y===undefined)delete ret.y;if(size.w===undefined)delete ret.w;else ret.w=size.w;if(size.h===undefined)delete ret.h;else ret.h=size.h;// console.log(\"encode coorde\", {size, sp, ep, ret});\nret.currentCoordType=edgePointCoordMode;return ret;}encodePosCoords(c,size0,view,sp0,ep0,mode){if(!view)view=this.get_view(c);let size=size0;let edgePointCoordMode=mode||(view.__raw||view).edgePointCoordMode;let le=c&&c.proxyObject.father;let sp=sp0||le.startPoint;let ep=ep0||le.endPoint;return LEdgePoint.encodeCoords(size,edgePointCoordMode,sp,ep);}/* 13/10/2023 Giordano comment (defined in LPointerTargetable\r\n    public get_delete(context: Context): () => void {\r\n        // careful: pointedBy might be broken due to comment x984 (search it)\r\n        return super.get_delete(context);\r\n    }\r\n    */},_class16.subclasses=[],_class16._extends=[],_class16))||_class15);RuntimeAccessibleClass.set_extend(DVoidVertex,DEdgePoint);RuntimeAccessibleClass.set_extend(LVoidVertex,LEdgePoint);export let DVertex=(_dec9=RuntimeAccessible('DVertex'),_dec9(_class17=(_class18=class DVertex extends DGraphElement{constructor(){super(...arguments);this.id=void 0;this.graph=void 0;this.model=void 0;this.isSelected=void 0;this.subElements=void 0;this.zoom=void 0;this.x=void 0;this.y=void 0;this.w=void 0;this.h=void 0;this.isResized=void 0;this.__isDVertex=void 0;}// DVoidVertex\n// static _super = DVoidVertex;\n// static singleton: LVertex;\n// static logic: typeof LVertex;\n// static structure: typeof DVertex;\n// inherit redefine\n// containedIn!: Pointer<DGraphElement, 0, 1, LGraphElement>;\n// size!: GraphSize; // virtual, gets extracted from this. x and y are stored directly here as it extends GraphSize\n// personal attributes\nstatic new(htmlindex,model,parentNodeID,graphID,nodeID,size){return new Constructors(new DVertex('dwc'),parentNodeID,true,undefined,nodeID).DPointerTargetable().DGraphElement(model,graphID,htmlindex).DVoidVertex(size||defaultVertexSize).DVertex().end();}},_class18.subclasses=[],_class18._extends=[],_class18))||_class17);export let LVertex=(_dec10=RuntimeAccessible('LVertex'),_dec10(_class19=(_class20=class LVertex extends LVoidVertex{constructor(){super(...arguments);this.__raw=void 0;this.id=void 0;this.graph=void 0;this.model=void 0;this.subElements=void 0;this.zoom=void 0;this.x=void 0;this.y=void 0;this.w=void 0;this.h=void 0;this.size=void 0;this.isResized=void 0;this.__isLVertex=void 0;}// static singleton: LVertex;\n// static logic: typeof LVertex;\n// static structure: typeof DVertex;\n// inherit redefine\n// isSelected: Dictionary<DocString<Pointer<DUser>>, boolean> = {};\nisSelected(forUser){return this.wrongAccessMessage(\"node.isSelected()\");}// containedIn?: LGraphElement;\n// virtual, gets extracted from this. x and y are stored directly here as it extends GraphSize\n// personal attributes\n},_class20.subclasses=[],_class20._extends=[],_class20))||_class19);RuntimeAccessibleClass.set_extend(DGraphElement,DVertex);RuntimeAccessibleClass.set_extend(LGraphElement,LVertex);export let DGraphVertex=(_dec11=RuntimeAccessible('DGraphVertex'),Leaf(_class21=_dec11(_class21=(_class22=class DGraphVertex extends DGraphElement{constructor(){super(...arguments);this.id=void 0;this.graph=void 0;this.model=void 0;this.isSelected=void 0;this.subElements=void 0;this.zoom=void 0;this.offset=void 0;this.x=void 0;this.y=void 0;this.w=void 0;this.h=void 0;this.isResized=void 0;this.__isDVertex=void 0;this.__isDGraph=void 0;this.__isDGraphVertex=void 0;}// MixOnlyFuncs(DGraph, DVertex)\n// static _super1 = DGraph;\n// static _super2 = DVertex;\n// static singleton: LGraphVertex;\n// static logic: typeof LGraphVertex;\n// static structure: typeof DGraphVertex;\n// inherit redefine\n// containedIn!: Pointer<DGraphElement, 0, 1, LGraphElement>;\n// from graph\n// in-graph scrolling position\n// from VoidVertex\n// size!: GraphSize; // virtual\n// from graph\n// personal attributes\nstatic new(htmlindex,model,parentNodeID,graphID,nodeID,size){return new Constructors(new DGraphVertex('dwc'),parentNodeID,true,undefined,nodeID).DPointerTargetable().DGraphElement(model,graphID,htmlindex).DVoidVertex(size||defaultVertexSize).DVertex().DGraph().end();}/*\r\n        static init_constructor(thiss: DGraphVertex, isUser: boolean = false, nodeID: string | undefined, graphID: string | undefined, model: Pointer<DModel>): void {\r\n            DGraph.init_constructor(thiss, isUser, nodeID, graphID, model);\r\n    //isUser: boolean = false, nodeID: string | undefined, graphID: string, model?: Pointer<DModel>\r\n            DVertex.init_constructor(thiss, isUser, nodeID, graphID as string, model);\r\n            thiss.className = this.name;\r\n        }*/},_class22.subclasses=[],_class22._extends=[],_class22))||_class21)||_class21);class LG extends LGraph{}class LV extends LVertex{}const Mixed=MixOnlyFuncs(LG,LV);export let LGraphVertex=(_dec12=RuntimeAccessible('LGraphVertex'),_dec12(_class23=(_class24=class LGraphVertex extends Mixed{constructor(){super(...arguments);this.__raw=void 0;this.id=void 0;this.graph=void 0;this.model=void 0;this.zoom=void 0;this.offset=void 0;this.graphSize=void 0;this.x=void 0;this.y=void 0;this.w=void 0;this.h=void 0;this.isResized=void 0;this.size=void 0;this.__isLVertex=void 0;this.__isLGraph=void 0;this.__isLGraphVertex=void 0;}// MixOnlyFuncs(LGraph, LVertex)\n// static singleton: LGraphVertex;\n// static logic: typeof LGraphVertex;\n// static structure: typeof DGraphVertex;\n// inherit redefine\n// isSelected: Dictionary<DocString<Pointer<DUser>>, boolean> = {};\nisSelected(forUser){return this.wrongAccessMessage(\"node.isSelected()\");}// containedIn?: LGraphElement;\n///////////////////////////////////////// subElements!: LGraphElement[];\n// from graph\n// in-graph scrolling position\n// internal size of the graph. can be huge even if the sub-graph is in a small window (scroll)\n// from VoidVertex\n// virtual\n// personal attributes\n},_class24.subclasses=[],_class24._extends=[],_class24))||_class23);RuntimeAccessibleClass.set_extend(DGraph,DGraphVertex);RuntimeAccessibleClass.set_extend(DVertex,DGraphVertex);RuntimeAccessibleClass.set_extend(LGraph,LGraphVertex);RuntimeAccessibleClass.set_extend(LVertex,LGraphVertex);export let DVoidEdge=(_dec13=RuntimeAccessible('DVoidEdge'),_dec13(_class25=(_class26=class DVoidEdge extends DGraphElement{constructor(){super(...arguments);this.id=void 0;this.graph=void 0;this.model=void 0;this.isSelected=void 0;this.subElements=void 0;this.start=void 0;this.end=void 0;this.__isDVoidEdge=void 0;this.midPoints=void 0;this.midnodes=void 0;this.longestLabel=void 0;this.labels=void 0;this.anchorStart=void 0;this.anchorEnd=void 0;this.isExtend=void 0;this.isReference=void 0;this.isValue=void 0;this.isDependency=void 0;}// static singleton: LVoidEdge;\n// static logic: typeof LVoidEdge;\n// static structure: typeof DVoidEdge;\n// isSelected: Dictionary<DocString<Pointer<DUser>>, boolean> = {};\n// containedIn!: Pointer<DGraphElement, 0, 1, LGraphElement>;\n// personal attributes\n// the logic part which instructs to generate the midnodes\n// using subelements instead most of times\n// endFollow!: boolean; they became derived attributes from static properties\n// startFollow!: boolean;\nstatic new(htmlindex,model,parentNodeID,graphID,nodeID,start,end,longestLabel,labels){return new Constructors(new DEdge('dwc'),parentNodeID,true,undefined,nodeID).DPointerTargetable().DGraphElement(model,graphID,htmlindex).DVoidEdge(start,end,longestLabel,labels).end();}static new2(model,parentNodeID,graphID,nodeID,start,end,setter){return new Constructors(new DEdge('dwc'),parentNodeID,true,undefined,nodeID).DPointerTargetable().DGraphElement(model,graphID).DVoidEdge(start,end).end(setter);}},_class26.subclasses=[],_class26._extends=[],_class26.isFollowingCoords=void 0,_class26))||_class25);/*\r\n@RuntimeAccessible\r\nexport class MidPoint{\r\n    readonly id: string; // not really a pointer, it's not on store.\r\n    x?: number; y?: number;\r\n    readonly w?: number; // if it's modified it's not ever here (initial size) but on DEdgePoint that is a Node.\r\n    readonly h?: number;/*\r\n    constructor2(x: number=5, y: number=5, w: number=5, h: number=5) {\r\n        this.x = x;\r\n        this.y = y;\r\n        this.w = w;\r\n        this.h = h;\r\n    }* /\r\nconstructor(id: string, w: number=5, h: number=5) {\r\n    this.id = id;\r\n    this.w = w;\r\n    this.h = h;\r\n}\r\n}*/export let EdgeSegment=(_dec14=RuntimeAccessible('EdgeSegment'),_dec14(_class27=class EdgeSegment{// if EdgeSegment is changed, shouldcomponentupdate needs update too: search in IDE for \"5khi2\"\n//  a segment of the whole path\n// m coefficient of the line between start and end.\n// for head and tails: radian angle of the segment.\n// for labels: it flips the angle when it's < PI/2 so the text is never upside down\n/*constructor(label: PrimitiveType|undefined, length: number, startp: GraphPoint, endp: GraphPoint, start: LGraphElement, end: LGraphElement,\r\n                bezierpts: GraphPoint[], mid: LGraphElement[],\r\n                svgLetter: EdgeBendingMode, index: number, fillMode: MidNodeHandling) {\r\n        this.label = label;\r\n        this.length = length;\r\n        this.length = length;\r\n        this.startp = startp;\r\n        this.bezierp = bezierpts;\r\n        this.endp = endp;\r\n        this.start = start;\r\n        this.end = end;\r\n        this.mid = mid;\r\n    }*/constructor(start,mid,end,svgLetter,gapMode,index,prevSegment){this.index=void 0;this.prev=void 0;this.start=void 0;this.bezier=void 0;this.end=void 0;this.length=void 0;this.d=void 0;this.dpart=void 0;this.m=void 0;this.rad=void 0;this.radLabels=void 0;this.isLongest=void 0;this.label=void 0;this.svgLetter=void 0;// console.log(\"segmentmaker:\", arguments, ((start.ge?.model as any)?.name)+\" ---> \" + ((end.ge?.model as any)?.name));\nthis.start=start;this.bezier=mid;this.end=end;this.index=index;this.prev=prevSegment;//this.segments = segments;\n// the idea: forbid all T and S or transform them in C, Q by calculating and manually adding their mirrored bezier pts\n// if (svgLetter[1]) svgLetter = (svgLetter[0]) as any;\nif(svgLetter===EdgeBendingMode.Bezier_QT){this.svgLetter=EdgeBendingMode.Bezier_QT[0];// this.svgLetter = (index === 0 ? EdgeBendingMode.Bezier_QT[0] : EdgeBendingMode.Bezier_QT[1]) as any as EdgeBendingMode;\nthis.addBezierPoint();}else if(svgLetter===EdgeBendingMode.Bezier_CS){this.svgLetter=EdgeBendingMode.Bezier_CS[0];// this.svgLetter = (index === 0 ? EdgeBendingMode.Bezier_CS[0] : EdgeBendingMode.Bezier_CS[1]) as any as EdgeBendingMode;\nthis.addBezierPoint();}else this.svgLetter=svgLetter;// fix if amount of bezier pts is invalid for current letter\nswitch(this.svgLetter){case EdgeBendingMode.Line:case EdgeBendingMode.Bezier_quadratic:if(this.bezier.length>=1)break;else this.svgLetter=EdgeBendingMode.Line;break;case EdgeBendingMode.Bezier_cubic:if(this.bezier.length>=2)break;else if(this.bezier.length>=1)this.svgLetter=EdgeBendingMode.Bezier_quadratic;else this.svgLetter=EdgeBendingMode.Line;break;case EdgeBendingMode.Elliptical_arc:if(this.bezier.length>=3)break;else this.svgLetter=EdgeBendingMode.Line;// straight to end ignoring midpoints that are NOT coordinates when using elliptical arc.\nbreak;default://case EdgeBendingMode.Bezier_quadratic_mirrored as string:\n//case EdgeBendingMode.Bezier_cubic_mirrored as string: // translated to Q or C by adding mirrored bezier points explicitly\ncase EdgeBendingMode.Bezier_QT:case EdgeBendingMode.Bezier_CS:// translated to Q or C by sending the right letter to each segment\nLog.exDevv(\"this svg letter should not appear here\",this.svgLetter);break;}}addBezierPoint(){let prev=this.prev;if(!prev)return;let prevedgemakerbezier=prev.bezier[prev.bezier.length-1]||prev.start;let mirroredBezier={...prevedgemakerbezier,pt:EdgeSegment.invertLastBezierPt(prevedgemakerbezier.pt,prev.end.pt),uncutPt:EdgeSegment.invertLastBezierPt(prevedgemakerbezier.uncutPt,prev.end.uncutPt)};this.bezier=[mirroredBezier,...this.bezier];// always only 1 assumed pt both in cubic and quadratic.\n// let next: this | undefined = this.segments[this.index+1];\n// EdgeSegment.invertLastBezierPt((next.mid[1] || next.end).pt, next.start.pt);\n}makeD(index,gapMode){this.m=GraphPoint.getM(this.start.pt,this.end.pt);this.rad=Geom.mToRad(this.m,this.start.pt,this.end.pt);this.radLabels=Math.atan(this.m);let svgLetter=this.svgLetter;// caller makes sure to pass right letter and resolve \"CS\" mixed letters. // this.bendingModeToLetter(bendingMode, index);\n// caller sends inverted pts as normal coords\n// let invertedBezPt = lastSegment && EdgeSegment.invertLastBezierPt(lastSegment.midp[lastSegment.mid.length-1] || lastSegment.startp, lastSegment.endp);\nswitch(this.svgLetter.length){case 2:return Log.exDevv(\"mixed letters are not allowed and should have been resolved to single svg letters before here, found:\"+svgLetter);/*return Log.exDevv(\"dev problem to fix:\\n\" +\r\n            \"the mirrored mode requires the first one to have explicit non-mirrored mode?? like M, C a1 a2 a3, S a1, S a1, S a1\\n\" +\r\n            \"So all segments with mixed modes needs to extract the last bezier point (penultimate coordinate) from previous segments, mirror it and insert in midp[0]\");*/case 1:let bezierpts=[...this.bezier.map(b=>b.pt),this.end.pt];let finalpart=svgLetter+\" \"+bezierpts.map(p=>p.x+\" \"+p.y).join(\", \");this.dpart=\"M \"+this.start.pt.x+\" \"+this.start.pt.y+\", \"+finalpart;let bezierptsUncut=[...this.bezier.map(b=>b.uncutPt),this.end.pt];// uncutPt exist for start and end too, but i want to use the cut one for those. or edgehead is off\nlet finalpartUncut=svgLetter+\" \"+bezierptsUncut.map(p=>p.x+\" \"+p.y).join(\", \");this.d=(index===0?\"M\"+this.start.pt.x+\" \"+this.start.pt.y+\", \":\"\")+finalpartUncut;//midp = [this.startp, ...this.midp];\n// d = M sp X mp2 ep // X = custom letter\n// dpart = T sp X mp2 ep // S = S if X = C,\n// sp is the startingpoint from the prev node, which might be != from endpoint of last node if last node have w>0 && h>0\n// so i'm \"filling\" the gap with a T, or L arc wich can use only 1 parameter (they are the only 1-parameter arcs)\n// if (this.prev && this.prev.end.pt.equals(this.start.pt)) gapMode = EdgeGapMode.average; // if the 2 points coincide, i use any 1 of the gapmodes that are continuous\n/*switch (gapMode){\r\n                    case EdgeGapMode.center:\r\n                    case EdgeGapMode.average:\r\n                        // continuous gap modes. they only differ in how the \"joining\" point is found, but not in how they behave after that.\r\n                        /*\r\n                        if (index === 0) {\r\n                             startletter = \"M \";\r\n                         }\r\n                         else {\r\n                             switch (svgLetter) {\r\n                                 case SvgLetter.A: case SvgLetter.C: case SvgLetter.S: case SvgLetter.Q: case SvgLetter.T: default:\r\n                                     startletter = SvgLetter.T + \" \"; break;\r\n                                 case SvgLetter.L: case SvgLetter.M:\r\n                                     startletter = SvgLetter.L + \" \"; break;\r\n                             }\r\n                         }* /\r\n                        if (index) {\r\n                            this.d = finalpart;\r\n                        }\r\n                        else { this.d = this.dpart; }\r\n                        break;\r\n                    case EdgeGapMode.gap:\r\n                    case EdgeGapMode.autoFill:\r\n                    case EdgeGapMode.lineFill:\r\n                    case EdgeGapMode.arcFill:\r\n                        // the filling itself is done by another segment (solving svg letter and simulating i=0), so i treat it as a gap.\r\n                        this.d = this.dpart;\r\n                        break;\r\n                    default:\r\n                        Log.exDevv(\"unexpected EdgeGapMode:\" + gapMode, {gapMode});\r\n                }*/break;default:return Log.exDevv(\"unexpected bending mode length:\"+this.svgLetter+\" or fillMode: \"+gapMode,{bendingMode:this.svgLetter,index,gapMode});}//using\n/*\r\n        88\r\n\r\n        // d should not have M set (except for segments[0]\r\n        // dpart have M abd beed to add explicit points for \"mirroring\" and transforming bezier quadratic mirrored in bezier quadratic normal etc.\r\n        //88 problem: the mirrored mode requires the first one to have explicit nonmirrored mode?? like M, C a1 a2 a3, S a1, S a1, S a1 .... ?\r\n        in any case the % letter part is wrong because it needs to subtract first element used for M*/return this.d;}static invertLastBezierPt(bezier,end){// vector = bezier - end\n// end + vector = bezier\n// end - vector = inverted bezier? = 2*end-bezier\nlet vector=bezier.subtract(end,true);return end.subtract(vector,true);}calcLength(){this.length=this.start.pt.distanceFromPoint(this.end.pt);}})||_class27);export class EdgeFillSegment extends EdgeSegment{makeD(index,gapMode){// if (gapMode === EdgeGapMode.autoFill) { gapMode = this.svgLetter === EdgeBendingMode.Line ? EdgeGapMode.lineFill : EdgeGapMode.arcFill; }\nswitch(gapMode){case\"closest\":// EdgeGapMode.closest:\ncase EdgeGapMode.center:case EdgeGapMode.average:case EdgeGapMode.gap:return\"\";// should not have filler arcs\ndefault:/*\r\n            case EdgeGapMode.autoFill as any:\r\n            case EdgeGapMode.lineFill:\r\n                this.bezier = [];\r\n                this.svgLetter = EdgeBendingMode.Line;\r\n                return super.makeD(index, gapMode);\r\n            case EdgeGapMode.arcFill:*/this.svgLetter=this.svgLetter[0];if(this.svgLetter===\"Q\")this.bezier=this.bezier.length?[this.bezier[0]]:[];return super.makeD(index,gapMode);}}}EdgeFillSegment.cname=\"EdgeFillSegment\";export let LVoidEdge=(_dec15=RuntimeAccessible('LVoidEdge'),_dec15(_class29=(_class30=class LVoidEdge extends LGraphElement{constructor(){super(...arguments);this.__raw=void 0;this.id=void 0;this.graph=void 0;this.model=void 0;this.subElements=void 0;this.__isLVoidEdge=void 0;this.midPoints=void 0;this.midnodes=void 0;this.edge=void 0;this.__info_of__edge={type:\"?LEdge\",txt:\"returns this if called on an edge, the containing edge if called on an EdgePoint, undefined otherwise.\"};this.isExtend=void 0;this.isReference=void 0;this.isValue=void 0;this.isDependency=void 0;this.allNodes=void 0;this.__info_of__allNodes={type:\"[LGraphElement, ...Array<LEdgePoint>, LGraphElement]\",txt:/*#__PURE__*/_jsx(\"span\",{children:\"first element is this.start. then all this.midnodes. this.end as last element\"})};this.label=void 0;this.longestLabel=void 0;this.labels=void 0;this.__info_of__longestLabel={label:\"Longest label\",type:\"function(edge)=>string\",readType:\"(edge:LEdge, segment: EdgeSegment, allNodes: DGraphElement[], allSegments: EdgeSegment[]) => PrimitiveType\",writeType:\"string\",txt:/*#__PURE__*/_jsx(\"span\",{children:\"Label assigned to the longest path segment.\"})};this.__info_of__label={type:\"\",txt:/*#__PURE__*/_jsx(\"span\",{children:\"Alias for longestLabel\"})};this.__info_of__labels={label:\"Multiple labels\",type:\"same type as longestLabel | longestLabel[]\",writeType:\"string\",txt:/*#__PURE__*/_jsx(\"span\",{children:\"Instructions to label to multiple or all path segments in an edge\"})};this.start=void 0;this.__info_of__start={type:\"LVertex\",txt:\"the source point of the edge.\"};this.end=void 0;this.__info_of__end={type:\"LVertex\",txt:\"the terminal point of the edge.\"};this.__info_of__startPoint={type:\"GraphPoint\",txt:/*#__PURE__*/_jsx(\"span\",{children:\"startPoint of this.start (element originating the edge). Defaults in outer coordinates.\"})};this.__info_of__endPoint={type:\"GraphPoint\",txt:/*#__PURE__*/_jsx(\"span\",{children:\"endPoint of this.end (element originating the edge). Defaults in outer coordinates.\"})};this.segments=void 0;this.segments_inner=void 0;this.segments_outer=void 0;this.__info_of__segments={type:\"{all:T, segments:T, fillers:T, head: GraphSize&{rad:number}, tail: as head} where T is EdgeSegment\",txt:/*#__PURE__*/_jsxs(\"span\",{children:[\"Collection of segments connecting in order vertex and EdgePoint without intersecting their area, aimed to be rendered in svg path.\",/*#__PURE__*/_jsx(\"br\",{}),\"fillers are arcs generated by view.edgeGapMode being autofill, arcfill or linefill.\",/*#__PURE__*/_jsx(\"br\",{}),\"length of this.segments array is Math.ceil(allNodes.length / svg_letter_size) specified on view.\",/*#__PURE__*/_jsx(\"br\",{}),\"\\\"head\\\" and \\\"tail\\\" are the position and angle of eventual edge decorators. Refer to this.headPos documentation.\"]})};this.d=void 0;this.__info_of__d={type:ShortAttribETypes.EString,txt:\"the full suggested path of SVG path \\\"d\\\" attribute, merging all segments.\"};this.anchorStart=void 0;this.anchorEnd=void 0;this.__info_of__anchorStart={writeType:\"string | undefined\",type:\"string\",isEdge:true,txt:\"The name of a node anchor where the edge should originate from.\"};this.__info_of__anchorEnd={writeType:\"string | undefined\",type:\"string\",isEdge:true,txt:\"The name of a node anchor where the edge should point to.\"};this.endFollow=void 0;this.startFollow=void 0;this.__info_of__endFollow={writeType:\"boolean\",readType:\"boolean\",type:\"boolean\",isEdge:true,// type:\"read:(()=>void), write:boolean\", readType:\"(()=>void))\",\ntxt:\"makes the ending point of an edge follow the cursor, so it can be assigned to a new anchor or target.\"};this.__info_of__startFollow={writeType:\"boolean\",readType:\"boolean\",type:\"boolean\",isEdge:true,// type:\"read:(()=>void), write:boolean\", readType:\"(()=>void))\",\ntxt:\"makes the starting point of an edge follow the cursor, so it can be assigned to a new anchor or source.\"};}// static singleton: LVoidEdge;\n// static logic: typeof LVoidEdge;\n// static structure: typeof DVoidEdge;\n// isSelected: Dictionary<DocString<Pointer<DUser>>, boolean> = {};\nisSelected(forUser){return this.wrongAccessMessage(\"node.isSelected()\");}// containedIn?: LGraphElemnt;\n// the logic part which instructs to generate the midnodes\n// returns self. useful to get edge from edgePoints without triggering error if you are already on edge.\n/*\r\nreplaced by startPoint\r\n    edgeStart!: GraphPoint;\r\n    edgeStart_inner!: GraphPoint;\r\n    edgeStart_outer!: GraphPoint;\r\n    __info_of__edgeStart: Info = {type: \"GraphPoint\", txt: \"Same as edgeStart_outer.\"}\r\n    __info_of__edgeStart_outer: Info = {type: \"GraphPoint\",\r\n     txt: \"Where the edge should start his path, in coordinates relative at the root Graph.\r\n     <br>Computed by combining the anchor offset option in View and the size of the starting node.\"}\r\n    __info_of__edgeStart_inner: Info = {type: \"GraphPoint\",\r\n     txt: \"Where the edge should start his path, in coordinates relative at the most nested Graph.\r\n     <br>Computed by combining the anchor offset option in View and the size of the starting node.\"}\r\n    edgeEnd!: GraphPoint;\r\n    edgeEnd_inner!: GraphPoint;\r\n    edgeEnd_outer!: GraphPoint;\r\n    __info_of__edgeEnd: Info = {type: \"GraphPoint\", txt: \"Same as edgeEnd_outer.\"}\r\n    __info_of__edgeEnd_outer: Info = {type: \"GraphPoint\",\r\n     txt: \"Where the edge should end his path, in coordinates relative at the root Graph.\r\n     <br>Computed by combining the anchor offset option in View and the size of the starting node.\"}\r\n    __info_of__edgeEnd_inner: Info = {type: \"GraphPoint\",\r\n     txt: \"Where the edge should end his path, in coordinates relative at the most nested Graph.\r\n     <br>Computed by combining the anchor offset option in View and the size of the starting node.\"}\r\n*/ // should never be read change their documentation in write only. their values is \"read\" in this.segments\nget_start(c){return LPointerTargetable.fromPointer(c.data.start);}set_start(val,c){let ptr=Pointers.from(val);if(!ptr){Log.exx(\"attempting to set an invalid LEdge.start: \"+ptr,{ptr,data:c.data});return true;}if(ptr!==c.data.start)SetFieldAction.new(c.data.id,'start',ptr,'',true);return true;}get_end(c){return LPointerTargetable.fromPointer(c.data.end);}set_end(val,c){let ptr=Pointers.from(val);if(!ptr){Log.exx(\"attempting to set an invalid LEdge.end: \"+ptr,{ptr,data:c.data});return true;}if(ptr!==c.data.end)SetFieldAction.new(c.data.id,'end',ptr,'',true);return true;}get_label(c){return this.get_longestLabel(c);}set_label(val,c){return this.set_longestLabel(val,c);}get_longestLabel(c){return transientProperties.node[c.data.id].longestLabel;/*if (transientProperties.node[c.data.id].longestLabel !== undefined) return transientProperties.node[c.data.id].longestLabel;\r\n        else return transientProperties.view[c.data.view].longestLabel;*/}get_labels(c){return transientProperties.node[c.data.id].labels;/*if (transientProperties.node[c.data.id].labels !== undefined) return transientProperties.node[c.data.id].labels;\r\n        else return transientProperties.view[c.data.view].labels;*/}set_longestLabel(val,c){Log.exDevv('Edge.labels are disabled, pass it through props instead');if(val===c.data.longestLabel)return true;TRANSACTION(()=>{SetFieldAction.new(c.data,\"longestLabel\",val);SetRootFieldAction.new(\"NODES_RECOMPILE_longestLabel+=\",c.data.id);});return true;}set_labels(val,c){Log.exDevv('Edge.labels are disabled, pass it through props instead');if(val===c.data.labels)return true;TRANSACTION(()=>{SetFieldAction.new(c.data,\"labels\",val);SetRootFieldAction.new(\"NODES_RECOMPILE_labels+=\",c.data.id);});return true;}headPos_impl(c,isHead,headSize0,segment0,zoom0){let segment=segment0||this.get_segments(c).segments[0];// let v: LViewElement = this.get_view(c);\nlet tmp=headSize0||(isHead?this.get_view(c).edgeHeadSize:this.get_view(c).edgeTailSize);if(!tmp||tmp.x===0||tmp.y===0){// head or tail missing\ntmp=new GraphSize(0,0,0,0);tmp.rad=0;return tmp;}let zoom=zoom0||this.get_graph(c).zoom;// ownZoom or cumulativeZoom?\nlet headPos=new GraphSize(0,0,tmp.x,tmp.y);//.multiply({w:zoom.x, h:zoom.y});\nlet useBezierPoints=true;let start,end;let m;if(useBezierPoints){if(isHead){start=segment.end.pt;end=(segment.bezier[segment.bezier.length-1]||segment.start).pt;}else{start=segment.start.pt;end=(segment.bezier[0]||segment.end).pt;}m=GraphPoint.getM(start,end);}else{if(isHead){start=segment.end.pt;end=segment.start.pt;}else{start=segment.start.pt;end=segment.end.pt;}m=segment.m;}// first find the center of where it should be positioned\n// let center: GraphPoint;\n// let distance: number = Math.sqrt(headPos.w*headPos.w + headPos.h*headPos.h);\n// let isVertical = m >=1 ;\nlet x4headsize=new GraphSize(start.x-headPos.w,start.y-headPos.h,headPos.w*2,headPos.h*2);// first intersection is segment origin. second is found with the box containing all possible edgeHead positions that touch the startPoint\n// (doing x4 his shape and placing 4 \"rectangles\" all around startPoint) to cover all possible segment directions.\n// or finding first direction (vertical if m >1, horizontal if m<0) and vector direction and intersecting with only the \"correct\" placed edgeHead rectangle.\n// then the intersection will likely not fall on the extreme angle of EdgeHead and i can re-center edgeHead\n// so that first and second intersections are equal spaced with the center segment\nlet secondIntersection;let segmentDistance=start.distanceFromPoint(end);if(segmentDistance<=Math.sqrt(headPos.w**2+headPos.h**2)){let safeDistance=Math.max(headPos.w,headPos.h)*5;end=new GraphPoint(end.y+safeDistance,end.y+m*safeDistance);// move the point away so it doesn't intersect anymore. i just need direction\n// too small to fit edgeHead, i simply put it centered on the whole segment\n// secondIntersection = end;\n}secondIntersection=GraphSize.closestIntersection(x4headsize,start,end,undefined);if(!secondIntersection){return Log.exDevv(\"failed to intersect edge head\",{x4headsize,segment,headPos,c,start,end,useBezierPoints});}tmp=secondIntersection.add(start,false).divide(2);// center of edgehead\nheadPos.x=tmp.x-headPos.w/2;// tl corner\nheadPos.y=tmp.y-headPos.h/2;// tl corner\nheadPos.rad=Geom.mToRad(m,start,end);/*\r\n        devo trovare la distanza tra il centro dell'egeHead e il punto di inizio in termini assoluti, così tramite M trovo distanza in x e y. o trovarla in altro modo\r\n        if (segment.m === Number.POSITIVE_INFINITY || segment.m === Number.NEGATIVE_INFINITY) {\r\n            center = segment.start.pt.add({x:0, y: distance}, true); }\r\n        else { center = segment.start.pt.add({x:segment.m*headPos.w/2, y:segment.m*headPos.h/2\r\n         this is wrong, cannot be the same for x and y, i should invert the line equation for x?}, true); }\r\n        headPos.x = center.x - headPos.w / 2;\r\n        headPos.y = center.y - headPos.h / 2;*/ // console.log(\"head intersected\", {headPos, secondIntersection, x4headsize, segment, c, start, end, useBezierPoints});\nreturn headPos;}headPos(headSize0,segment0,zoom0){return this.wrongAccessMessage(\"This is not headPos() implementation. it is just for typings. use the getter\");}tailPos(headSize0,segment0,zoom0){return this.wrongAccessMessage(\"This is not tailPos() implementation. it is just for typings. use the getter\");}get_headPos(c){return(headSize,segment,zoom)=>this.headPos_impl(c,true,headSize,segment,zoom);}get_tailPos(c){return(headSize,segment,zoom)=>this.headPos_impl(c,false,headSize,segment,zoom);}get_allNodes(c){return[this.get_start(c),...this.get_midnodes(c),this.get_end(c)];}get_edge(c){return c.proxyObject;}set_edge(v,c){return this.cannotSet(\"edge field, on an edge element\");}get_midPoints(c){return c.data.midPoints;}addMidPoint(v){return this.wrongAccessMessage(\"addMidPoint\");}get_addMidPoint(c){return v=>this.impl_addMidPoints(v,c);}set_midPoints(val,c){return SetFieldAction.new(c.data.id,\"midPoints\",val,undefined,false);}impl_addMidPoints(val,c){return SetFieldAction.new(c.data.id,\"midPoints\",val,'+=',false);}get_label_impl(c,segment,nodes,segments){let key=segment.isLongest?\"longestLabel\":\"labels\";// : keyof this\n// if (isLongestSegment) return this.get_longestLabel_impl(d, l, nodes, index):\nconst d=c.data;const l=c.proxyObject;let labelmaker=this['get_'+key](c);let labelmakerfunc=labelmaker;// let lastSeg = segments[i-1];\nswitch(typeof labelmaker){//nb{}[]<>\ncase\"number\":case\"undefined\":case\"boolean\":case\"string\":return labelmaker;// case \"function\": return nodes.map( (o, i) => d.labels(l, nodes, i)).slice(0, nodes.length-1);\n// (e:LVoidEdge, segment: EdgeSegment, allNodes: LEdge[\"allNodes\"], allSegments: EdgeSegment[]) => PrimitiveType\ncase\"function\":return labelmakerfunc(l,segment,nodes,segments);default:break;case\"object\":if(labelmaker===null)return null;if(!Array.isArray(labelmaker))break;let elem=labelmaker[segment.index%labelmaker.length];if(typeof elem===\"function\")return elem(l,segment,nodes,segments);return elem;}Log.exx(\"edge labels invalid type, must be a primitive value, a function or an array of such.\",{labelmaker,key,d});return undefined;}/*\r\n    private get_label_impl_old(d: DVoidEdge, l: LVoidEdge, nodes:this[\"allNodes\"], index: number, longestlabelindex?: number): PrimitiveType {\r\n        if (d.longestLabel !== undefined && index === longestlabelindex) return this.get_longestLabel_impl(d, l, nodes, index);\r\n        switch (typeof d.labels) {//nb{}[]<>\r\n            case \"number\":\r\n            case \"undefined\":\r\n            case \"boolean\":\r\n            case \"string\": return d.labels;\r\n            // case \"function\": return nodes.map( (o, i) => d.labels(l, nodes, i)).slice(0, nodes.length-1);\r\n            case \"function\": return d.labels(l, nodes[index], nodes[index+1], index, nodes);\r\n            default: break;\r\n            case \"object\": if (!Array.isArray(d.labels)) break;\r\n            if (typeof d.labels[0] === \"function\") return (d.labels as any)[index % d.labels.length](l, nodes[index], nodes[index+1], index, nodes);\r\n            return (d.labels as PrimitiveType[])[index % d.labels.length];\r\n        }\r\n        Log.exx(\"edge labels invalid type, must be a primitive value, a function or an array of such.\", d.labels);\r\n    }*/get_startPoint(context){return this.get_startPoint_Outer(context);}get_endPoint(context){return this.get_endPoint_Outer(context);}get_startPoint_Outer(c){// console.log(\"get_edgeStart_Outer\", {out:this.get_outerGraph(c), pos:this.get_startPoint_inner(c), inner:this.get_start(c).innerGraph});\nreturn this.get_outerGraph(c).translateSize(this.get_startPoint_inner(c),this.get_start(c).innerGraph);}get_endPoint_Outer(c){// console.log(\"get_edgeEnd_Outer\", {out:this.get_outerGraph(c), pos:this.get_endPoint_inner(c), inner:this.get_end(c).innerGraph});\nreturn this.get_outerGraph(c).translateSize(this.get_endPoint_inner(c),this.get_end(c).innerGraph);}get_startPoint_inner(c){return this.get_edgeStartEnd_inner(c,true);}get_endPoint_inner(c){return this.get_edgeStartEnd_inner(c,false);}get_edgeStartEnd_inner(c,isStart){return isStart?this.get_start(c).startPoint:this.get_end(c).endPoint;}svgLetterSize(s){let addM=arguments.length>1&&arguments[1]!==undefined?arguments[1]:true;let doublingMidPoints=arguments.length>2&&arguments[2]!==undefined?arguments[2]:true;let ret;switch(s){default:ret=Log.exDevv(\"unexpected svg path letter: \\\"\"+s+\"\\\"\",s);break;case EdgeBendingMode.Line://case EdgeBendingMode.Bezier_quadratic_mirrored:\nret={first:1,others:1};break;case EdgeBendingMode.Bezier_quadratic://case EdgeBendingMode.Bezier_cubic_mirrored:\nret={first:2,others:2};break;case EdgeBendingMode.Bezier_cubic:ret={first:3,others:3};break;case EdgeBendingMode.Elliptical_arc:ret={first:4,others:4};break;case EdgeBendingMode.Bezier_QT:ret={first:2,others:1};break;case EdgeBendingMode.Bezier_CS:ret={first:3,others:2};break;}// account for the fact that every midpoint is listed twice: at anchor start and anchor end.\nif(doublingMidPoints){// removing last point (first is already excluded because addM didn't trigger yet)\n// , the remaining are midpoints to double. then i add it back\nret.first=(ret.first-1)*2+1;ret.others=(ret.others-1)*2+1;}// account for the first M letter\n//    (if the segment is not mode.gap or first, M coord still exist in segment but are ignored)\nif(addM){ret.first+=1;ret.others+=1;}return ret;}// outer should be a redundant param and always == true\nget_points_impl(allNodes,outer,c){function getAnchorOffset(size,offset,isPercentage){let $factor=arguments.length>3&&arguments[3]!==undefined?arguments[3]:100;if(!size)size=new GraphSize(0,0,0,0);// else if (!size.tl) size = new GraphSize(size.x, size.y, size.w, size.h);\nif(isPercentage)offset=new GraphPoint(offset.x/$factor*size.w,offset.y/$factor*size.h);return size.tl().add(offset,false);}let innermost=this.get_graph(c);let root=this.get_root(c);const all=allNodes.flatMap((ge,i)=>{let dge=ge.__raw;let size=outer?ge.outerSize:ge.innerSize;if(outer&&root&&innermost&&innermost.id!==root.id){size=innermost.translateSize(size,root);}let base={view:ge.view,size,ge,pt:null,uncutPt:null};Log.exDev(typeof base.size!==\"object\",\"could not get node size:\",{base,c,outer});let rets;// = base as any;\nlet rete;// = {...base} as any;\nlet debug=true;if(debug){base.anchor_e=dge.anchors[c.data.anchorEnd||0]||dge.anchors[Object.keys(dge.anchors)[0]];base.anchor_s=dge.anchors[c.data.anchorStart||0]||dge.anchors[Object.keys(dge.anchors)[0]];}// get endpoint, then startpoint (land on midnode, then depart from it)\nif(i!==0){rete={rete:true,...base};if(i===allNodes.length-1){// get end anchor from node\nlet anchor=dge.anchors[c.data.anchorEnd||0];if(!anchor)anchor=dge.anchors[Object.keys(dge.anchors)[0]];if(anchor)rete.pt=getAnchorOffset(rete.size,anchor,true,1);}// if no anchor, treat the node as a midpoint\nif(!rete.pt){// get ending point from midpoint\n//rete.pt = (LEdgePoint.singleton as LEdgePoint).get_endPoint(undefined as any, rete.size, rete.view);\nrete.pt=getAnchorOffset(rete.size,rete.view.edgeStartOffset,rete.view.edgeStartOffset_isPercentage);}rete.uncutPt=rete.pt;}if(i!==allNodes.length-1){rets={rets:true,...base};if(i===0){// get start anchor from node\nlet anchor=dge.anchors[c.data.anchorStart||0];if(!anchor)anchor=dge.anchors[Object.keys(dge.anchors)[0]];if(anchor)rets.pt=getAnchorOffset(rets.size,anchor,true,1);}if(!rets.pt){// rets starting point from midpoint\n// rets.pt = (LEdgePoint.singleton as LEdgePoint).get_startPoint(undefined as any, rets.size, rets.view);\nrets.pt=getAnchorOffset(rets.size,rets.view.edgeStartOffset,rets.view.edgeStartOffset_isPercentage);}rets.uncutPt=rets.pt;}// ret.pt = ge.startPoint\nreturn rets&&rete?[rete,rets]:rets?[rets]:[rete];});if(DVoidEdge.isFollowingCoords){if(c.data.id===LVoidEdge.endFollow){let seg=all[all.length-1];seg.pt=DVoidEdge.isFollowingCoords;seg.size=new GraphSize(seg.pt.x,seg.pt.y,0.01,0.01);}if(c.data.id===LVoidEdge.startFollow){let seg=all[0];seg.pt=DVoidEdge.isFollowingCoords;seg.size=new GraphSize(seg.pt.x,seg.pt.y,0.01,0.01);}}return all;}get_pointsDebug(c){return this.get_points_impl(this.get_allNodes(c),true,c);}get_points(allNodes){let outer=arguments.length>1&&arguments[1]!==undefined?arguments[1]:false;let c=arguments.length>2?arguments[2]:undefined;return this.get_points_impl(allNodes,outer,c);}get_points_outer(allNodes,c){return this.get_points_impl(allNodes,true,c);}// private get_points_inner(allNodes: LGraphElement[], c: Context): segmentmaker[]{ return this.get_points_impl(allNodes, false, c); }\nget_d(c){return this.get_segments(c).all.map(s=>s.d).join(\" \");}/*\r\n    private get_fillingSegments(c: Context): Partial<this[\"segments\"]> {\r\n        return this.get_segments(c).fillers;\r\n    }*/get_segments(c){return this.get_segments_outer(c);}get_segments_outer(c){return this.get_segments_impl(c,true);}// public get_segments_inner(c: Context): this[\"segments\"] { return this.get_segments_impl(c, false); }\nget_segments_impl(c,outer){let l=c.proxyObject;let v=this.get_view(c);let allNodes=l.allNodes;windoww.edge=l;let all=this.get_points(allNodes,outer,c);//const all: {size: GraphSize, view: LViewElement, ge: LGraphElement}[] = allNodes.map((ge) => { return { view: ge.view, size: ge.size, ge}});\nlet ret=[];let bm=v.bendingMode;let gapMode=v.edgeGapMode;let segmentSize=this.svgLetterSize(bm,false,true);let increase=segmentSize.first;let segment=undefined;/// grouping points according to SvgLetter\nfor(let i=0;i<all.length-1;){// let start = all[i], end = all[i+increase];\nlet start=all[i];let endindex=i+increase<all.length-1?i+increase:all.length-1;let mid=all.slice(i+1,endindex).filter((e,i)=>i%2===0);let end=all[endindex];// makes sure the edge actually reaches his target even if there is an invalid amount of midnodes fot the current EdgeBendingMode\nif(i===endindex&&segment)start=segment.end;// segment = this.get_segmentv3(start, mid, end, getSvgLetter(i), i, segment, all);\nsegment=new EdgeSegment(start,mid,end,bm,gapMode,i,segment);// segment = this.get_segment(start.ge, start.size, start.view, end.ge, end.size, end.view, cut, v.bendingMode, mid, ret[ret.length -1], fillMode, segment);\nret.push(segment);i+=increase+1;// because increase index is already inserted at the end of prev segment\nif(increase!==segmentSize.others)increase=segmentSize.others;// if (longestLabel !== undefined && longest < s.length) { longest = s.length; longestindex = i; } todo: move to after snapping to borders\n}function printablesegment(s){let r={};for(let k in s){var _v;let v=s[k];v=((_v=v)===null||_v===void 0?void 0:_v.__raw)||v;if(typeof v===\"object\")r[k]=JSON.parse(JSON.stringify(v));else r[k]=v;}return r;}let fillSegments=[];this.snapSegmentsToNodeBorders(c,v,ret,fillSegments);let longestLabel=c.data.longestLabel;this.setLabels(c,ret,allNodes);// console.log(\"getSegments() labeled:\", {main:ret, fillSegments});\nlet rett={all:[...ret,...fillSegments],segments:ret,fillers:fillSegments};/*switch(bm){\r\n            default: break;\r\n            case EdgeBendingMode.Bezier_QT:\r\n            case EdgeBendingMode.Bezier_CS:\r\n                rett.\r\n        }*/for(let i=0;i<rett.all.length;i++){let s=rett.all[i];s.makeD(i,gapMode);}let zoom=new GraphPoint(1,1);rett.head=this.headPos_impl(c,true,v.edgeHeadSize,rett.segments[rett.segments.length-1],zoom);rett.tail=this.headPos_impl(c,false,v.edgeTailSize,rett.segments[0],zoom);return rett;}setLabels(c,segments,allNodes){// find longest segment\nlet longestindex=-1;let longest=0;for(let i=0;i<segments.length;i++){let s=segments[i];s.calcLength();if(longest<s.length){longest=s.length;longestindex=i;}s.isLongest=false;}if(longestindex>=0)segments[longestindex].isLongest=true;// apply labels\nfor(let s of segments)s.label=this.get_label_impl(c,s,allNodes,segments);}snapSegmentsToNodeBorders(c,v,ret,fillSegments){// snap segment start and end to a node border\nlet canCutStart=v.edgeStartStopAtBoundaries,canCutEnd=v.edgeEndStopAtBoundaries;let grid=undefined;// let fillSegments: EdgeSegment[] = [];\nlet gapMode=v.edgeGapMode;let bm=v.bendingMode;let ci;// cut i === 0 is cut regardless of gapmode.\nif(canCutStart){ci=GraphSize.closestIntersection(ret[0].start.size,ret[0].start.pt,(ret[0].bezier[0]||ret[0].end).pt,grid);if(ci)ret[0].start.pt=ci;/*\r\n            ret[0].start.pt =\r\n                GraphSize.closestIntersection(ret[0].start.size, ret[0].start.pt, (ret[0].bezier[0] || ret[0].end).pt, grid) as any\r\n                || Geom.closestPoint(ret[0].start.size, ret[0].start.pt);*/}// cut middle segments maybe\nlet prev;let curr=ret[0];// if (gapMode === EdgeGapMode.gap) return;\nif(canCutStart||canCutEnd)// do the for below\nfor(let i=1;i<ret.length;i++){prev=ret[i-1];curr=ret[i];let doStartCut,doEndCut;switch(gapMode){/*\r\n                    case EdgeGapMode.arcFill:\r\n                    case EdgeGapMode.lineFill:\r\n                    case EdgeGapMode.autoFill:\r\n                        // same as gap, but will insert 1 more segment to fill the hole\r\n                        doStartCut = true;\r\n                        doEndCut = true;\r\n                        if (prev.end.pt.equals(curr.start.pt)) break;\r\n                        fillSegments.push(new EdgeFillSegment(\r\n                            prev.end,\r\n                            [\r\n                                {...prev.end, pt: EdgeSegment.invertLastBezierPt(prev.end.pt, (prev.bezier[prev.bezier.length-1] || prev.start).pt)},\r\n                                {...curr.start, pt: EdgeSegment.invertLastBezierPt(curr.start.pt, (curr.bezier[0] || curr.end).pt)}\r\n                            ],\r\n                            curr.start,\r\n                            bm, gapMode, 0, undefined));\r\n                            / *\r\n                            fillSegments.push(new FillEdgeSegment( // M <start_gap> C <bez1> <bez2> <end_gap>\r\n                               // <start_gap> = end of last seg (start of gap) <end_gap> = first of curr seg (end of gap)\r\n                            prev.end.pt,\r\n                            EdgeSegment.invertLastBezierPt(prev.end.pt, prev.bezier[prev.bezier.length-1].pt || prev.start.pt),\r\n                            EdgeSegment.invertLastBezierPt(curr.start.pt, curr.bezier[0].pt || curr.end.pt),\r\n                            curr.start.pt)* /\r\n\r\n                        break;*/case EdgeGapMode.gap:// just snap to vertex edge         prevSegment.endp and ret.startp\ndoEndCut=true;doStartCut=true;break;// average: todo: maybe rename in join (merges start-end at closest pt to both (avg), then snap on edge)\ncase\"closest\"://EdgeGapMode.closest:\n// does not work properly, i think i need to get next.end instead of curr.end, just disabled for now\nlet nextpt=(curr.bezier[0]||curr.end).pt;let prevpt=(prev.bezier[prev.bezier.length-1]||prev.start).pt;let midexternalpt=prevpt.add(nextpt,true);let midedgepoint=curr.start.size.tl().add(curr.start.size.br(),false).divide(2,false);// od average between the 2 points before and after that are not part of this edgepoint, then raw a line from there to center of ep, find that intersection.\nci=GraphSize.closestIntersection(curr.start.size,midedgepoint,midexternalpt,grid);doEndCut=doStartCut=false;if(canCutEnd&&ci)prev.end.pt=ci;if(canCutStart&&ci)curr.start.pt=ci;break;case EdgeGapMode.average:// first move to average of the 2 points in the gap, then snap to edge\ndoEndCut=true;doStartCut=true;// indipendent from cutStart, cutEnd.\n// they merge if just 1 of cutting sides are true. (and if they are both false we don't even enter the for loop)\ncurr.start.pt=curr.start.pt.add(prev.end.pt,false).divide(2,false);prev.end.pt=curr.start.pt.duplicate();// intentionally not the same pt because during snap to edge they can diverge again.\nprev.start.uncutPt=prev.start.pt;prev.end.uncutPt=prev.end.pt;break;// center: first move it to center of edgePoint/node, then snap to edge.\n// this mode might be as well deleted, it can be specified with anchor points\ncase EdgeGapMode.center:doEndCut=false;doStartCut=false;curr.start.pt=curr.start.size.tl().add(curr.start.size.br(),false).divide(2,false);prev.end.pt=curr.start.pt.duplicate();// intentionally not the same pt because during snap to edge they can diverge again.\nprev.start.uncutPt=prev.start.pt;// only update them when point moves without being cut (average and center)\nprev.end.uncutPt=prev.end.pt;break;default:return Log.exDevv(\"unexpected EdgeGapMode:\"+gapMode);}if(canCutStart&&doStartCut){let nextpt=(curr.bezier[0]||curr.end).pt;ci=GraphSize.closestIntersection(curr.start.size,curr.start.pt,nextpt,grid);if(ci)curr.start.pt=ci;// || Geom.closestPoint(curr.start.size, curr.start.pt);\n//if (gapMode === EdgeGapMode.average && prev) { prev.end.pt = curr.start.pt.add(prev.end.pt, false).divide(2, false); }\n}if(canCutEnd&&doEndCut&&prev){let prevpt=(prev.bezier[prev.bezier.length-1]||prev.start).pt;ci=GraphSize.closestIntersection(prev.end.size,prev.end.pt,prevpt,grid);if(ci)prev.end.pt=ci;// || Geom.closestPoint(prev.end.size, prev.end.pt);\n// if average: first do average between start anchor points non-snapped. then i snap both,\n// then i do average again, and since it might snap out, i get closestPoint to EdgePoint size\nif(gapMode===EdgeGapMode.average)prev.end.pt=curr.start.pt=Geom.closestPoint(curr.start.size,curr.start.pt.add(prev.end.pt,false).divide(2,false));}}// cut end of last segment regardless of gapMode\nif(canCutEnd){let prevendpt=curr.end.pt;ci=GraphSize.closestIntersection(curr.end.size,curr.end.pt,(curr.bezier[curr.bezier.length-1]||curr.start).pt,grid);if(ci)curr.end.pt=ci;//|| Geom.closestPoint(prev.end.size, prev.end.pt);\n}}get_edgeEnd(context){return this.get_edgeEnd_outer(context);}get_edgeEnd_outer(c){// return this.get_outerGraph(c).translateSize(this.get_edgeEnd_inner(c), this.get_innerGraph(c));\nreturn this.get_outerGraph(c).translateSize(this.get_edgeEnd_inner(c),this.get_end(c).innerGraph);}get_edgeEnd_inner(c){return this.get_edgeStartEnd_inner(c,false);// return context.proxyObject.end?.size || new GraphPoint(0, 0);\n}get_midnodes(context){// return LPointerTargetable.wrapAll(context.data.midnodes);\nreturn LPointerTargetable.wrapAll(context.data.subElements);}set_midnodes(val,context){return SetFieldAction.new(context.data.id,\"midnodes\",val,'',true);}get_endFollow(c){return c.data.id===LVoidEdge.endFollow;}get_startFollow(c){return c.data.id===LVoidEdge.startFollow;}// // what in multieditor? needs to be moved in transientstuff?\nset_endFollow(val,c){return this._set_start_endFollow(val,c,false);}set_startFollow(val,c){return this._set_start_endFollow(val,c,true);}_set_start_endFollow(val,c,isStart){val=!!val;console.log(\"_set_start_endFollow\",{val,c,isStart});if(val){if(isStart)LVoidEdge.startFollow=c.data.id;else LVoidEdge.endFollow=c.data.id;if(!LVoidEdge.following){console.log(\"_set_start_endFollow event attached\");document.body.addEventListener(\"mousemove\",LVoidEdge.mousemove_pendingEdge,false);document.body.addEventListener(\"keydown\",LVoidEdge.onKeyDown_pendingEdge,false);LVoidEdge.following=true;LVoidEdge.followingContext=c;LVoidEdge.showAnchors();windoww.Tooltip.show(/*#__PURE__*/_jsxs(\"div\",{children:[\"Changing anchor, press \",/*#__PURE__*/_jsx(\"b\",{children:\"Esc\"}),\" to undo.\"]}));//let selector = \".Edge[nodeid='\" + (LVoidEdge.endFollow || LVoidEdge.startFollow as any)+\"']\";\n// [...document.querySelectorAll(selector)].map(e=>e.classList.add(\"no-transition-following\")); gets refreshed by react\ndocument.body.classList.add(\"no-transition-following\");}}else{if(LVoidEdge.following&&(isStart?LVoidEdge.startFollow:LVoidEdge.endFollow)===c.data.id){document.body.removeEventListener(\"mousemove\",LVoidEdge.mousemove_pendingEdge,false);document.body.removeEventListener(\"keydown\",LVoidEdge.onKeyDown_pendingEdge,false);let selector=\".Edge[nodeid='\"+(LVoidEdge.endFollow||LVoidEdge.startFollow)+\"']\";//[...document.querySelectorAll(selector)].map(e=>e.classList.remove(\"no-transition-following\"));\ndocument.body.classList.remove(\"no-transition-following\");if(isStart)LVoidEdge.startFollow=undefined;else LVoidEdge.endFollow=undefined;LVoidEdge.following=false;const $base=$(document.getElementById(isStart?c.data.start:c.data.end)||[]);if(!$base.length)return true;//const $deepAnchors = $base.find(\"[nodeid] .anchor\");\nconst $anchors=$base.find(\".anchor\");//.not($deepAnchors);\n$anchors.removeClass([\"valid-anchor\",\"active-anchor\"]);$base[0].style.overflow='';windoww.Tooltip.hide();}}//SetFieldAction.new(c.data, \"startFollow\", !!val, '', false);\nreturn true;}static getCursorPos(e0){return new Point(e0.pageX,e0.pageY);}/*public static getGCursorPos(e0: Event): GraphPoint {\r\n        return LVLoidEdge.getCursorPos(e0).subtract(svgsize.tl(), true).multiply(svgzoom) as any as GraphPoint;\r\n    }*/static onKeyDown_pendingEdge(e){if(e.key===Keystrokes.escape){const c=LVoidEdge.followingContext;if(!c||!LVoidEdge.startFollow&&!LVoidEdge.endFollow)return;let isStart=LVoidEdge.startFollow?true:false;let l=c.proxyObject;if(isStart)l.startFollow=false;else l.endFollow=false;// l.component?.forceUpdate(); does not work?\nl.clonedCounter=(l.clonedCounter||0)+2;}}static showAnchors(){const c=LVoidEdge.followingContext;if(!c||!LVoidEdge.startFollow&&!LVoidEdge.endFollow)return;let isStart=LVoidEdge.startFollow?true:false;let nodeid=isStart?c.data.start:c.data.end;let activeAnchor=(isStart?c.data.anchorStart:c.data.anchorEnd)||0;const $base=$(document.getElementById(nodeid)||[]);if(!$base.length)return;const $deepAnchors=$base.find(\"[nodeid] .anchor\");const $anchors=$base.find(\".anchor\").not($deepAnchors);$anchors.addClass(\"valid-anchor\");$anchors.filter('[data-anchorname=\"'+activeAnchor+'\"]').addClass(\"active-anchor\");$base[0].style.overflow=\"visible\";}static mousemove_pendingEdge(e0){let forcererendermode=true;if(forcererendermode){if(!LVoidEdge.following)return;if(!LVoidEdge.canForceUpdate)return;if(LVoidEdge.mousemovei++%30===0)LVoidEdge.showAnchors();let c=LVoidEdge.followingContext;let g=c.proxyObject.graph;let cursorPos=LVoidEdge.getCursorPos(e0);let gcursorpos=g.translateHtmlSize(cursorPos);// console.log(\"gcursorpos\", {cursorPos:cursorPos.toString(), gcursorpos:gcursorpos.toString(), g});\nDVoidEdge.isFollowingCoords=gcursorpos;let component=GraphElementComponent.map[LVoidEdge.startFollow||LVoidEdge.endFollow];LVoidEdge.canForceUpdate=false;let timer=setTimeout(()=>{LVoidEdge.canForceUpdate=true;},5000);let tn=transientProperties.node[c.data.id];for(let vid in tn.viewScores){// required to truly force an update\nlet tnv=tn.viewScores[vid];tnv.jsxOutput=undefined;tnv.usageDeclarations=undefined;tnv.shouldUpdate=true;}component.setState({forceupdate:new Date().getDate()},()=>{LVoidEdge.canForceUpdate=true;clearTimeout(timer);});// component.forceUpdate(()=>{LVoidEdge.canForceUpdate = true; clearTimeout(timer)});\nreturn;}LVoidEdge.tmp++;let selector=\".Edge[nodeid='\"+(LVoidEdge.endFollow||LVoidEdge.startFollow)+\"']\";let root=document.querySelector(selector);if(!root)return;let paths=[...root.querySelectorAll(\"path.full\")];let pathSegments=root.querySelectorAll(\"path.segment.preview\");// if (!paths.length) paths = pathSegments;\nlet pathSegmentContainers=[...new Set([...pathSegments].map(e=>e.parentElement))];for(let container of pathSegmentContainers){let se=[...container.querySelectorAll(\"path.segment.preview\")];paths.push(se[LVoidEdge.endFollow?se.length-1:0]);}let headTail=[...root.querySelectorAll(LVoidEdge.endFollow?'.edgeHead':'.edgeTail')];let cursorPos=LVoidEdge.getCursorPos(e0);let segList;for(let p of paths){let svg=U.parentUntil(\"svg\",p);let svgsize=Size.of(svg);let svgzoom=new Point(1,1);// todo: check viewbox and css zoom\nlet gcursorPos=cursorPos.subtract(svgsize.tl(),true).multiply(svgzoom);segList=[...p.getPathData()];let lastSeg={...segList[LVoidEdge.endFollow?segList.length-1:0]};switch(lastSeg.type){case'a':case'A':segList.push('fake new segment to get replaced instead of actual last segment which is A');lastSeg.type=\"L\";lastSeg.values=[gcursorPos.x,gcursorPos.y];break;case\"C\":case\"c\":// bezier curves, keep type just change last point\ncase\"Q\":case\"q\":case\"S\":case\"s\":case\"T\":case\"t\":lastSeg.values[lastSeg.values.length-2]=gcursorPos.x;lastSeg.values[lastSeg.values.length-1]=gcursorPos.y;break;case\"M\":case\"m\":lastSeg.type=LVoidEdge.endFollow?\"L\":\"M\";lastSeg.values=[gcursorPos.x,gcursorPos.y];break;case\"V\":case\"v\":// stuff forced to become a line\ncase\"H\":case\"h\":case\"L\":case\"l\":case\"Z\":case\"z\":lastSeg.type=\"L\";lastSeg.values=[gcursorPos.x,gcursorPos.y];break;}segList[LVoidEdge.endFollow?segList.length-1:0]=lastSeg;if(LVoidEdge.tmp%20===0)console.log(\"svg set path data,\",{segList,oldSeglist:p.getPathData(),p});p.setPathData(segList);}for(let ht of headTail){let svg=U.parentUntil(\"svg\",ht);let svgsize=Size.of(svg);let svgzoom=new Point(1,1);// todo: check viewbox and css zoom\nlet gcursorPos=cursorPos.subtract(svgsize.tl(),true).multiply(svgzoom);let rotation;let lastPt=segList&&segList[LVoidEdge.endFollow?segList.length-2:1].values;if(lastPt){let m=gcursorPos.getM(new Point(lastPt[LVoidEdge.endFollow?lastPt.length-2:1],lastPt[LVoidEdge.endFollow?lastPt.length-1:0]));if(Number.POSITIVE_INFINITY===m)rotation=Geom.degToRad(90);else if(Number.NEGATIVE_INFINITY===m)rotation=Geom.degToRad(270);else rotation=Math.atan(m);if(lastPt[LVoidEdge.endFollow?lastPt.length-2:1]>gcursorPos.x)rotation-=Geom.degToRad(180);}else{rotation=0;}let headSize=Size.of(ht);let headPos=gcursorPos.subtract({x:headSize.w/2,y:headSize.h/2},true);//.subtract({x:Math.cos(rotation)*headSize.w/2, y: -Math.sin(rotation)*headSize.h/2}, true);\nif(LVoidEdge.tmp%20===0)console.log(\"_set_start_endFollow move head\",{selector:LVoidEdge.endFollow?'.edgeHead':'.edgeTail',headTail,root});ht.style.transform='translate('+headPos.x+\"px, \"+headPos.y+\"px) rotate(\"+rotation+\"rad)\";}}},_class30.subclasses=[],_class30._extends=[],_class30.startFollow=undefined,_class30.endFollow=undefined,_class30.following=false,_class30.followingContext=void 0,_class30.tmp=1,_class30.canForceUpdate=true,_class30.mousemovei=0,_class30))||_class29);RuntimeAccessibleClass.set_extend(DGraphElement,DVoidEdge);RuntimeAccessibleClass.set_extend(LGraphElement,LVoidEdge);export let DEdge=(_dec16=RuntimeAccessible('DEdge'),_dec16(_class31=(_class32=class DEdge extends DVoidEdge{constructor(){super(...arguments);this.id=void 0;this.graph=void 0;this.model=void 0;this.isSelected=void 0;this.subElements=void 0;this.state=void 0;this.start=void 0;this.end=void 0;this.__isDEdge=void 0;this.__isDVoidEdge=void 0;this.midnodes=void 0;}// DVoidEdge\n// static singleton: LGraphElement;\n// static logic: typeof LGraphElement;\n// static structure: typeof DGraphElement;\n// isSelected: Dictionary<DocString<Pointer<DUser>>, boolean> = {};\n// containedIn!: Pointer<DGraphElement, 0, 1, LGraphElement>;\n},_class32.subclasses=[],_class32._extends=[],_class32))||_class31);export let LEdge=(_dec17=RuntimeAccessible('LEdge'),_dec17(_class33=(_class34=class LEdge extends LVoidEdge{constructor(){super(...arguments);this.__raw=void 0;this.id=void 0;this.graph=void 0;this.model=void 0;this.subElements=void 0;this._state=void 0;this.midnodes=void 0;this.__isLEdge=void 0;this.__isLVoidEdge=void 0;}// static singleton: LGraphElement;\n// static logic: typeof LGraphElement;\n// static structure: typeof DGraphElement;\n// isSelected: Dictionary<DocString<Pointer<DUser>>, boolean> = {};\nisSelected(forUser){return this.wrongAccessMessage(\"node.isSelected()\");}// containedIn!: LGraphElement;\n// LMap;\n},_class34.subclasses=[],_class34._extends=[],_class34))||_class33);RuntimeAccessibleClass.set_extend(DVoidEdge,DEdge);RuntimeAccessibleClass.set_extend(LVoidEdge,LEdge);export let DExtEdge=(_dec18=RuntimeAccessible('DExtEdge'),Leaf(_class35=_dec18(_class35=(_class36=class DExtEdge extends DEdge{constructor(){super(...arguments);this.id=void 0;this.graph=void 0;this.model=void 0;this.isSelected=void 0;this.subElements=void 0;this.state=void 0;this.start=void 0;this.end=void 0;this.__isDExtEdge=void 0;this.__isDEdge=void 0;this.__isDVoidEdge=void 0;}// etends DEdge\n// static singleton: LGraphElement;\n// static logic: typeof LGraphElement;\n// static structure: typeof DGraphElement;\n// isSelected: Dictionary<DocString<Pointer<DUser>>, boolean> = {};\n// containedIn!: Pointer<DGraphElement, 0, 1, LGraphElement>;\n/*\r\n        public static new(model: DGraph[\"model\"], parentNodeID: DGraphElement[\"father\"], graphID: DGraphElement[\"graph\"], nodeID?: DGraphElement[\"id\"], size?: GraphSize): DExtEdge {\r\n            return new Constructors(new DExtEdge('dwc')).DPointerTargetable().DGraphElement(model, parentNodeID, graphID, nodeID)\r\n                .DVoidEdge().DEdge().DExtEdge().end();\r\n        }*/},_class36.subclasses=[],_class36._extends=[],_class36))||_class35)||_class35);export let LExtEdge=(_dec19=RuntimeAccessible('LExtEdge'),_dec19(_class37=(_class38=class LExtEdge extends LEdge{constructor(){super(...arguments);this.__raw=void 0;this.id=void 0;this.graph=void 0;this.model=void 0;this.subElements=void 0;this._state=void 0;this.start=void 0;this.end=void 0;this.__isLExtEdge=void 0;this.__isLEdge=void 0;this.__isLVoidEdge=void 0;}// static singleton: LGraphElement;\n// static logic: typeof LGraphElement;\n// static structure: typeof DGraphElement;\n// isSelected: Dictionary<DocString<Pointer<DUser>>, boolean> = {};\nisSelected(forUser){return this.wrongAccessMessage(\"node.isSelected()\");}// containedIn!: LGraphElement;\n// LMap;\n},_class38.subclasses=[],_class38._extends=[],_class38))||_class37);RuntimeAccessibleClass.set_extend(DEdge,DExtEdge);RuntimeAccessibleClass.set_extend(LEdge,LExtEdge);export let DRefEdge=(_dec20=RuntimeAccessible('DRefEdge'),Leaf(_class39=_dec20(_class39=(_class40=class DRefEdge extends DEdge{constructor(){super(...arguments);this.start=void 0;this.end=void 0;this.isSelected=void 0;this.__isDRefEdge=void 0;}// extends DEdge\n/*\r\n        public static new(model: DGraph[\"model\"], parentNodeID: DGraphElement[\"father\"], graphID: DGraphElement[\"graph\"], nodeID?: DGraphElement[\"id\"]): DRefEdge {\r\n            return new Constructors(new DRefEdge('dwc')).DPointerTargetable().DGraphElement(model, parentNodeID, graphID, nodeID)\r\n                .DVoidEdge().DEdge().DRefEdge().end();\r\n        }*/},_class40.subclasses=[],_class40._extends=[],_class40))||_class39)||_class39);export let LRefEdge=(_dec21=RuntimeAccessible('LRefEdge'),_dec21(_class41=(_class42=class LRefEdge extends LEdge{constructor(){super(...arguments);this.start=void 0;this.end=void 0;this.__isLRefEdge=void 0;}// __raw!: DRefEdge;\n},_class42.subclasses=[],_class42._extends=[],_class42))||_class41);RuntimeAccessibleClass.set_extend(DEdge,DRefEdge);RuntimeAccessibleClass.set_extend(LEdge,LRefEdge);// for edges without a modelling element\n/*\r\n\r\nlet a = `DExtEdge, DRefEdge, DVoidEdge, LGraphVertex, LRefEdge, LEdgePoint, DVoidVertex, DGraphVertex, DEdgePoint,\r\n DVertex, DEdge, LVertex, LGraph, DGraph, LVoidVertex, LVoidEdge, LEdge, LGraphElement, LExtEdge, DGraphElement`;\r\n  // // ... get from export in index.ts\r\na = a.replaceAll(',,', \",\")\r\nlet aa = a.split(\",\").map(a => a.trim().substring(1));\r\n\r\nfunction onlyUnique(value, index, self) { return self.indexOf(value) === index; }\r\n\r\naa = aa.filter(onlyUnique).filter( a=> !!a)\r\nlet r = aa.filter(onlyUnique).filter( a=> !!a).map( a=> `export type W${a} = getWParams<L${a}, D${a}>;`).join('\\n')\r\ndocument.body.innerText = r;\r\n*/ // getWParams<LGraphVertex, DGraphVertex>;\nconsole.warn('ts loading graphDataElement');","map":{"version":3,"names":["isDeepStrictEqual","BEGIN","Constructors","CoordinateMode","Debug","DPointerTargetable","DUser","EdgeBendingMode","END","GraphElementComponent","GraphPoint","GraphSize","Keystrokes","Leaf","Log","LPointerTargetable","MixOnlyFuncs","Node","Point","Pointers","RuntimeAccessible","RuntimeAccessibleClass","SetFieldAction","SetRootFieldAction","ShortAttribETypes","Size","store","TargetableProxyHandler","TRANSACTION","transientProperties","U","Uarr","windoww","EdgeGapMode","Geom","jsx","_jsx","jsxs","_jsxs","console","warn","DGraphElement","_dec","_class","_class2","constructor","arguments","id","graph","model","isSelected","subElements","state","father","x","y","zIndex","w","h","view","favoriteNode","edgesIn","edgesOut","anchors","new","htmlindex","parentNodeID","graphID","nodeID","a","b","undefined","end","nodeLFromHtml","target","fromPointer","nodePtrFromHtml","nodeDFromHtml","attributes","nodeid","value","parentElement","graphLFromHtml","graphPtrFromHtml","graphDFromHtml","graphid","subclasses","_extends","LGraphElement","_dec2","_class3","_class4","__raw","_state","width","height","z","__info_of__z__","type","EInt","txt","__info_of__zIndex__","zoom","html","size","position","htmlSize","htmlPosition","component","vertex","__info_of__vertex","__info_of__favoriteNode","EBoolean","startPoint","endPoint","__info_of__startPoint","children","__info_of__endPoint","__info_of__graph","innerGraph","__info_of__innnerGraph","outerGraph","__info_of__outerGraphGraph","root","__info_of__root","__info_of__graphAncestors","graphAncestors","__info_of__anchors","__info_of__edgesIn","__info_of__edgesOut","__info_of__edgesStart","__info_of__edgesEnd","outerSize","__info_of__outerSize","innerSize","__info_of__innerSize","__info_of__size","nodes","__type_of__nodes","edges","__type_of__edges","graphs","__type_of__graphs","allSubNodes","__type_of__allSubNodes","allSubEdges","__type_of__allSubEdges","allSubGraphs","__type_of__allSubGraphs","__info_of__subElements","allSubElements","__info_of__allSubElements","assignEdgeAnchor","__info_of__assignEdgeAnchor","__info_of__isselected","__info_of__select","__info_of__deselect","__info_of__toggleSelect","__info_of__isSelected","getNodeId","o","_node","node","extends","className","from","get_graph","context","get_innerGraph","get_root","get_outerGraph","get_anchors","c","data","set_anchors","v","Array","isArray","ee","ka","kk","isNaN","get_edgesIn","fromArr","get_edgesOut","set_edgesIn","val","set_edgesOut","get_edgesStart","get_edgesEnd","set_edgesStart","set_edgesEnd","_defaultGetter","k","__defaultGetter","get_view","_defaultSetter","__defaultSetter","get_graphAncestors","current","proxyObject","next","ret","DGraph","cname","push","wrap","get_vertex","lcurrent","dcurrent","DVertex","DVoidVertex","DGraphVertex","fromD","exDev","_LPointerTargetable$f","exDevv","cdata","_dcurrent","get_x","get_size","set_x","set_size","get_y","set_y","get_w","set_w","get_h","set_h","get_width","set_width","get_height","set_height","get_position","set_position","get_sizeold","get_component","map","_transientProperties$","_transientProperties$2","_this$get_component","_this$get_component$p","mainView","r","props","set_view","eDevv","getSize","outer","length","canTriggerSet","wrongAccessMessage","get_getSize","_this","get_innerSize","get_outerSize","get_innerSize_impl","_this$get_component2","_this$get_component2$","lightMode","DEdge","DVoidEdge","nosize","coord","get_htmlSize","DEdgePoint","def","defaultVSize","currentCoordType","decodePosCoords","translateSize","actualSize","of","isOldElement","clonedCounter","dataset","clonedcounter","updateSize","adaptWidth","adaptHeight","size0","testmode","absolute","encodePosCoords","epdata","get_html","$","set_html","cannotSet","set_htmlSize","get_htmlPosition","tl","set_htmlPosition","get_zIndex","set_zIndex","_val","get_z","set_z","get_nodes","get_subElements","filter","indexOf","set_nodes","get_edges","set_edges","get_graphs","set_graphs","get_allSubNodes","get_allSubElements","set_allSubNodes","get_allSubEdges","set_allSubEdges","get_allSubGraphs","set_allSubGraphs","Set","e","set_subElements","log","eDev","pointers","equals","idlookup","getState","arrdiff","arrayDifference","oldsubelementid","removed","subelement","newsubelementid","added","tocheck","checked","dblcheck","newtocheck","ptr","fistContainer","subnode","se","arrayMergeInPlace","Object","keys","set_allSubElements","get_isResized","isResized","set_isResized","get_model","modelElementId","lModelElement","get_assignEdgeAnchor","anchorName","LVoidEdge","startFollow","de","start","le","anchorStart","endFollow","anchorEnd","get_events","tn","mainview","otherViews","stackViews","allviews","reverse","keep_for_closure_original_funcs","dv","objectMergeInPlace","events","lastContext","viewScores","evalContext","_len","_params","_key","get_father","set_father","select","forUser","deselect","toggleSelected","get_select","get_deselect","get_toggleSelected","get_isSelected","set_isSelected","get_startPoint","get_startEndPoint","get_endPoint","isStart","offset","isPercentage","add","set_extend","_dec3","_class5","_class6","parentgraphID","DGraph_makeID","getNodes","dmp","out","$allnodes","matchedids","d","matchedidmap","objectFromArrayValues","allnodesarr","filternode","_d$dataset","_d$dataset2","dataid","$matched","$notMatched","n","defaultEdgePointSize","defaultVertexSize","LGraph","_dec4","_class7","_class8","graphSize","cumulativeZoom","__info_of__cumulativeZoom","ownZoom","__info_of__ownZoom","label","__info_of__zoom","__info_of__offset","__info_of__graphSize","__info_of__translateSize","__info_of__translateHtmlSize","screenOffset","__info_of__screenOffset","get_offset","set_offset","get_cumulativeZoom","ancestors","g","multiply","get_zoom","get_ownZoom","set_zoom","toGraphSize","get_coord","graphHtmlSize","translateHtmlSize","get_translateHtmlSize","rootGraph","get_translateHtmlSize_fromRoot","fakeRootSize","translateHtmlSize_fromRoot","get_screenOffset","divide","subtract","get_translateSize","graph_of_size","targetGraph","currGraph","currAncestors","targetAncestors","currAncestorsPtr","l","targetAncestorsPtr","ex","i","commonAncestor","slice","name","get_translateSize_down_old","hasOwnProperty","contains","elem","get_contains","targetid","_dec5","_class9","_class10","LVoidVertex","_dec6","_class11","_class12","_dec7","_class13","_class14","__isDEdgePoint","LEdgePoint","_dec8","_class15","_class16","__isLEdgePoint","edge","__info_of__edge","get_edge","set_edge","decodeCoords","sp","ep","mode","relativePercent","relativeOffset","relativeOffsetStart","relativeOffsetEnd","useStart","useEnd","xIsAbsolute","yIsAbsolute","offsetsp","offsetep","sp0","ep0","testCoords","range","j","s0","s1","encodeCoords","s00","error","toFixed","join","diff","edgePointCoordMode","_dec9","_class17","_class18","__isDVertex","LVertex","_dec10","_class19","_class20","__isLVertex","_dec11","_class21","_class22","__isDGraph","__isDGraphVertex","LG","LV","Mixed","LGraphVertex","_dec12","_class23","_class24","__isLGraph","__isLGraphVertex","_dec13","_class25","_class26","__isDVoidEdge","midPoints","midnodes","longestLabel","labels","isExtend","isReference","isValue","isDependency","new2","setter","isFollowingCoords","EdgeSegment","_dec14","_class27","mid","svgLetter","gapMode","index","prevSegment","prev","bezier","dpart","m","rad","radLabels","isLongest","Bezier_QT","addBezierPoint","Bezier_CS","Line","Bezier_quadratic","Bezier_cubic","Elliptical_arc","prevedgemakerbezier","mirroredBezier","pt","invertLastBezierPt","uncutPt","makeD","getM","mToRad","Math","atan","bezierpts","finalpart","p","bezierptsUncut","finalpartUncut","bendingMode","vector","calcLength","distanceFromPoint","EdgeFillSegment","center","average","gap","_dec15","_class29","_class30","__isLVoidEdge","allNodes","__info_of__allNodes","__info_of__longestLabel","readType","writeType","__info_of__label","__info_of__labels","__info_of__start","__info_of__end","segments","segments_inner","segments_outer","__info_of__segments","__info_of__d","EString","__info_of__anchorStart","isEdge","__info_of__anchorEnd","__info_of__endFollow","__info_of__startFollow","get_start","set_start","exx","get_end","set_end","get_label","get_longestLabel","set_label","set_longestLabel","get_labels","set_labels","headPos_impl","isHead","headSize0","segment0","zoom0","segment","get_segments","tmp","edgeHeadSize","edgeTailSize","headPos","useBezierPoints","x4headsize","secondIntersection","segmentDistance","sqrt","safeDistance","max","closestIntersection","tailPos","get_headPos","headSize","get_tailPos","get_allNodes","get_midnodes","get_midPoints","addMidPoint","get_addMidPoint","impl_addMidPoints","set_midPoints","get_label_impl","key","labelmaker","labelmakerfunc","get_startPoint_Outer","get_endPoint_Outer","get_startPoint_inner","get_endPoint_inner","get_edgeStartEnd_inner","svgLetterSize","s","addM","doublingMidPoints","first","others","get_points_impl","getAnchorOffset","$factor","innermost","all","flatMap","ge","dge","base","rets","rete","debug","anchor_e","anchor_s","anchor","edgeStartOffset","edgeStartOffset_isPercentage","seg","get_pointsDebug","get_points","get_points_outer","get_d","get_segments_outer","get_segments_impl","bm","edgeGapMode","segmentSize","increase","endindex","printablesegment","_v","JSON","parse","stringify","fillSegments","snapSegmentsToNodeBorders","setLabels","rett","fillers","head","tail","longestindex","longest","canCutStart","edgeStartStopAtBoundaries","canCutEnd","edgeEndStopAtBoundaries","grid","ci","curr","doStartCut","doEndCut","nextpt","prevpt","midexternalpt","midedgepoint","br","duplicate","closestPoint","prevendpt","get_edgeEnd","get_edgeEnd_outer","get_edgeEnd_inner","wrapAll","set_midnodes","get_endFollow","get_startFollow","set_endFollow","_set_start_endFollow","set_startFollow","following","document","body","addEventListener","mousemove_pendingEdge","onKeyDown_pendingEdge","followingContext","showAnchors","Tooltip","show","classList","removeEventListener","selector","remove","$base","getElementById","$anchors","find","removeClass","style","overflow","hide","getCursorPos","e0","pageX","pageY","escape","activeAnchor","$deepAnchors","not","addClass","forcererendermode","canForceUpdate","mousemovei","cursorPos","gcursorpos","timer","setTimeout","vid","tnv","jsxOutput","usageDeclarations","shouldUpdate","setState","forceupdate","Date","getDate","clearTimeout","querySelector","paths","querySelectorAll","pathSegments","pathSegmentContainers","container","headTail","segList","svg","parentUntil","svgsize","svgzoom","gcursorPos","getPathData","lastSeg","values","oldSeglist","setPathData","ht","rotation","lastPt","Number","POSITIVE_INFINITY","degToRad","NEGATIVE_INFINITY","transform","_dec16","_class31","_class32","__isDEdge","LEdge","_dec17","_class33","_class34","__isLEdge","DExtEdge","_dec18","_class35","_class36","__isDExtEdge","LExtEdge","_dec19","_class37","_class38","__isLExtEdge","DRefEdge","_dec20","_class39","_class40","__isDRefEdge","LRefEdge","_dec21","_class41","_class42","__isLRefEdge"],"sources":["C:/0Programmi/Dev/projects/frontend/jjodel/src/model/dataStructure/GraphDataElements.tsx"],"sourcesContent":["// import {Mixin} from \"ts-mixer\";\r\nimport {isDeepStrictEqual} from \"util\";\r\nimport {\r\n    BEGIN,\r\n    Constructors,\r\n    CoordinateMode,\r\n    Debug,\r\n    Dictionary,\r\n    DModelElement,\r\n    DocString,\r\n    DPointerTargetable,\r\n    DState,\r\n    DUser,\r\n    DViewElement,\r\n    EdgeBendingMode,\r\n    END,\r\n    EPSize,\r\n    getWParams,\r\n    GObject,\r\n    GraphElementComponent,\r\n    GraphPoint,\r\n    GraphSize,\r\n    Info, IPoint, Keystrokes, L,\r\n    Leaf,\r\n    LModelElement,\r\n    Log,\r\n    LogicContext,\r\n    LPointerTargetable,\r\n    LViewElement,\r\n    MixOnlyFuncs,\r\n    Node, orArr,\r\n    Pack1,\r\n    PackArr,\r\n    Point,\r\n    Pointer,\r\n    Pointers,\r\n    PrimitiveType,\r\n    RuntimeAccessible,\r\n    RuntimeAccessibleClass,\r\n    SetFieldAction, SetRootFieldAction,\r\n    ShortAttribETypes,\r\n    Size,\r\n    store,\r\n    TargetableProxyHandler, TRANSACTION,\r\n    transientProperties,\r\n    U,\r\n    Uarr,\r\n    windoww\r\n} from \"../../joiner\";\r\nimport type {Tooltip} from \"../../components/forEndUser/Tooltip\";\r\nimport type {RefObject} from \"react\";\r\nimport type {SVGPathElementt, SVGPathSegment} from '../../common/libraries/pathdata';\r\nimport {EdgeGapMode, InitialVertexSize} from \"../../joiner/types\";\r\nimport {Geom, ISize} from \"../../common/Geom\";\r\n\r\n\r\nconsole.warn('ts loading graphDataElement');\r\n\r\n@Node\r\n@RuntimeAccessible('DGraphElement')\r\nexport class DGraphElement extends DPointerTargetable {\r\n    // static _super = DPointerTargetable;\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // static singleton: LGraphElement;\r\n    // static logic: typeof LGraphElement;\r\n    // static structure: typeof DGraphElement;\r\n    id!: Pointer<DGraphElement, 1, 1, LGraphElement>;\r\n    graph!: Pointer<DGraph, 1, 1, LGraph>;\r\n    model?: Pointer<DModelElement, 0, 1, LModelElement>;\r\n    isSelected!: Dictionary<DocString<Pointer<DUser>>, boolean>;\r\n    // containedIn!: Pointer<DGraphElement, 0, 1, LGraphElement>;\r\n    subElements!: Pointer<DGraphElement, 0, 'N', LGraphElement>;\r\n    state!: GObject; // DMap\r\n    father!: Pointer<DGraphElement, 1, 1, LGraphElement>;\r\n    x!: number;\r\n    y!: number;\r\n    zIndex: number = 100;\r\n    w!: number;\r\n    h!: number;\r\n    // width: number = 300;\r\n    // height: number = 400;\r\n    view!: Pointer<DViewElement, 1, 1, LViewElement>;\r\n    favoriteNode!: boolean;\r\n    edgesIn!: Pointer<DEdge>[];\r\n    edgesOut!: Pointer<DEdge>[];\r\n    anchors!: Dictionary<string, GraphPoint/* as % of node size.*/>;\r\n\r\n\r\n    public static new(htmlindex: number, model: DGraphElement[\"model\"]|null|undefined, parentNodeID: DGraphElement[\"father\"],\r\n                      graphID: DGraphElement[\"graph\"], nodeID?: DGraphElement[\"id\"]|undefined, a?: any, b?:any, ...c:any): DGraphElement {\r\n        return new Constructors(new DGraphElement('dwc'), parentNodeID, true, undefined, nodeID)\r\n            .DPointerTargetable()\r\n            .DGraphElement(model, graphID, htmlindex).end();\r\n    }\r\n\r\n    static nodeLFromHtml(target?: Element | null): LGraphElement | undefined { return LPointerTargetable.fromPointer(DGraphElement.nodePtrFromHtml(target) as Pointer); }\r\n    static nodeDFromHtml(target?: Element | null): DGraphElement | undefined { return DPointerTargetable.fromPointer(DGraphElement.nodePtrFromHtml(target) as Pointer); }\r\n    static nodePtrFromHtml(target?: Element | null): Pointer<DGraphElement> | undefined {\r\n        while (target) {\r\n            if ((target.attributes as any).nodeid) return (target.attributes as any).nodeid.value;\r\n            target = target.parentElement;\r\n        }\r\n        return undefined;\r\n    }\r\n    static graphLFromHtml(target?: Element | null): LGraph | undefined { return LPointerTargetable.fromPointer(DGraphElement.graphPtrFromHtml(target) as Pointer); }\r\n    static graphDFromHtml(target?: Element | null): DGraph | undefined { return DPointerTargetable.fromPointer(DGraphElement.graphPtrFromHtml(target) as Pointer); }\r\n    static graphPtrFromHtml(target?: Element | null): Pointer<DGraph> | undefined {\r\n        while (target) {\r\n            if ((target.attributes as any).graphid) return (target.attributes as any).graphid.value;\r\n            target = target.parentElement;\r\n        }\r\n        return undefined;\r\n    }\r\n}\r\n@RuntimeAccessible('LGraphElement')\r\nexport class LGraphElement<Context extends LogicContext<DGraphElement> = any, C extends Context = Context> extends LPointerTargetable {\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static getNodeId<L extends LGraphElement, D extends DGraphElement>(o?:L | D | Pointer<D> | LModelElement | DModelElement | Pointer<DModelElement>): Pointer<D> {\r\n        if (!o) return undefined as any;\r\n        let node: any = o;\r\n        // from L to D\r\n        // let cname = (node.__raw || node).className;\r\n        // from DModelE to LGraphE\r\n        if (RuntimeAccessibleClass.extends((o as any).className, \"DModelElement\")) node = LPointerTargetable.from(o as DModelElement).node as LGraphElement;\r\n        return (typeof node === \"string\") ? node : node?.id;\r\n    }\r\n    // static singleton: LGraphElement;\r\n    // static logic: typeof LGraphElement;\r\n    // static structure: typeof DGraphElement;\r\n    __raw!: DGraphElement;\r\n    id!: Pointer<DGraphElement, 1, 1, LGraphElement>;\r\n    father!: LGraphElement;\r\n    model?: LModelElement;\r\n    // protected isSelected!: Dictionary<DocString<Pointer<DUser>>, boolean>; //  & ((forUser?: Pointer<DUser>) => boolean);\r\n\r\n    // containedIn?: LGraphElement;\r\n    _state!: GObject<\"proxified\">; // LMap;\r\n    x!: number;\r\n    y!: number;\r\n    width!: number;\r\n    height!: number\r\n\r\n    z!:number;\r\n    zIndex!: number;\r\n    __info_of__z__: Info = {type:ShortAttribETypes.EInt, txt: \"alias for zIndex\"};\r\n    __info_of__zIndex__: Info = {type:ShortAttribETypes.EInt,\r\n        txt: \"Determine the z-axis priority of the element.<br/>Higher value tende to overlap other elements.<br/>Lower value tends to be on background.\"};\r\n    zoom!: GraphPoint;\r\n    html?: Element;\r\n\r\n    // fittizi\r\n    w!:number;\r\n    h!:number;\r\n    size!: GraphSize;\r\n    position!: GraphPoint;\r\n    htmlSize!: Size; // size and position in global document coordinates.\r\n    htmlPosition!: Point;\r\n    view!: LViewElement;\r\n    component!: GraphElementComponent;\r\n    favoriteNode!: boolean;\r\n    vertex?: LVoidVertex;\r\n    __info_of__vertex: Info = {type: \"LVoidVertex\", txt: \"the foremost vertex containing this graphElement, or undefiened.\"}\r\n    __info_of__favoriteNode: Info = {type: ShortAttribETypes.EBoolean,\r\n        txt: \"<span>Indicates this is the primarly used (by default) node to refer to a modelling element that might have multiple representations.\" +\r\n            \"<br> Can be used as favorite target for edges or other.\"}\r\n\r\n    startPoint!: GraphPoint;\r\n    endPoint!: GraphPoint;\r\n    __info_of__startPoint: Info = {type: \"GraphPoint\", txt:<span>Where the outgoing edges should start their paths.\r\n            <br/>Obtained by combining anchoring point offset specified in view, before snapping to a Vertex border.\r\n            <br/>Defaults in outer coordinates.</span>};\r\n    __info_of__endPoint: Info = {type: \"GraphPoint\", txt:<span>Where the incoming edges should end their paths.\r\n            <br/>Obtained by combining anchoring point offset specified in view, before snapping to a Vertex border.\r\n            <br/>Defaults in outer coordinates.</span>};\r\n\r\n    graph!: LGraph | LGraphVertex;\r\n    __info_of__graph: Info = {type:\"LGraph | LGraphVertex\", txt:\"Alias for innerGraph\"};\r\n    get_graph(context: Context): LGraph | LGraphVertex { return this.get_innerGraph(context); }\r\n    innerGraph!: LGraph|LGraphVertex;\r\n    __info_of__innnerGraph: Info = {type:\"LGraph | LGraphVertex\", txt:\"Gets the nearest-level graph (it might be a Sub-graph like a package usually is)\"};\r\n    outerGraph!: LGraph;\r\n    __info_of__outerGraphGraph: Info = {type:\"LGraph\", txt:\"Gets the root-level graph\"};\r\n    root!: LGraph;\r\n\r\n    __info_of__root: Info = {type:\"LGraph\", txt:\"Alias for outerGraph\"};\r\n    get_root(context: Context): LGraph { return this.get_outerGraph(context); }\r\n\r\n    __info_of__graphAncestors: Info = {type:\"LGraph[]\",\r\n        txt:\"<span>collection of the stack of Graphs containing the current element where [0] is the most nested graph, and last is root graph.</span>\"};\r\n    graphAncestors!: LGraph[];\r\n\r\n    anchors!: Dictionary<string, GraphPoint/* as % of node size.*/>;\r\n    __info_of__anchors: Info = {type:\"Dictionary<string, point>\", txt: <div>A named list of all anchor points where edges are allowed to land or depart from.<br/>\r\n            {/*When reading it is in absolute sizes.<br/>*/}\r\n            When writing it must be done in percentages, with the same rules as node.state.</div>}\r\n    get_anchors(c: Context): this[\"anchors\"]{ return c.data.anchors; }\r\n    set_anchors(v: this[\"anchors\"], c: Context):boolean{\r\n        if (v !== undefined && (typeof v !== \"object\" || Array.isArray(v))){\r\n            Log.ee('cannot set anchors: invalid value provided');\r\n            return true;\r\n        }\r\n        if (v){ // if !v it means clear all anchors?\r\n            for (let ka in v){//for each anchor\r\n                if (!v[ka]) continue;\r\n\r\n                if (c.data.anchors[ka]) {\r\n                    for (let kk in v[ka]) { //for each key within an anchor (x, y, w, h)\r\n                        // if i was attempting to set a partial size, complete it with the old size values.\r\n                        if ((v[ka][kk] === undefined) && (c.data.anchors[ka][kk] !== undefined)) v[ka][kk] = c.data.anchors[ka][kk];\r\n                    }\r\n                }\r\n                if (v[ka].x === undefined || isNaN(v[ka].x)) v[ka].x = 0.5;\r\n                if (v[ka].y === undefined || isNaN(v[ka].y)) v[ka].y = 0.5;\r\n                // if (v[ka].w === undefined || isNaN(v[ka].w)) v[ka].w = 5;\r\n                // if (v[ka].h === undefined || isNaN(v[ka].h)) v[ka].h = 5;\r\n            }\r\n        }\r\n        SetFieldAction.new(c.data, \"anchors\", v, '+=', false);\r\n        return true; }\r\n\r\n    edgesIn!: LVoidEdge[];\r\n    edgesOut!: LVoidEdge[];\r\n    __info_of__edgesIn: Info = {type:\"LEdge[]\", txt:<div>Edges incoming into this element. <code>this.edgesOut[i].end</code> always equals to <code>this</code>.</div>}\r\n    __info_of__edgesOut: Info = {type:\"LEdge[]\", txt:<div>Edges outgoing from this element. <code>this.edgesIn[i].start</code> always equals to <code>this</code>.</div>}\r\n    __info_of__edgesStart: Info = {type:\"LEdge[]\", txt:<div>Alias for this.edgesOut</div>}\r\n    __info_of__edgesEnd: Info = {type:\"LEdge[]\", txt:<div>Alias for this.edgesIn</div>}\r\n    public get_edgesIn(context: Context): this[\"edgesIn\"] { return LPointerTargetable.fromArr(context.data.edgesIn); }\r\n    public get_edgesOut(context: Context): this[\"edgesOut\"]  { return LPointerTargetable.fromArr(context.data.edgesOut); }\r\n    public set_edgesIn(val: PackArr<LVoidEdge>, c: Context): boolean { return SetFieldAction.new(c.data.id, \"edgesIn\", Pointers.fromArr(val), '', true); }\r\n    public set_edgesOut(val: PackArr<LVoidEdge>, c: Context): boolean { return SetFieldAction.new(c.data.id, \"edgesOut\", Pointers.fromArr(val), '', true); }\r\n    public get_edgesStart(context: Context): this[\"edgesIn\"]  { return this.get_edgesIn(context); }\r\n    public get_edgesEnd(context: Context): this[\"edgesOut\"]  { return this.get_edgesOut(context); }\r\n    public set_edgesStart(val: PackArr<LVoidEdge>, context: Context): boolean { return this.set_edgesIn(val, context); }\r\n    public set_edgesEnd(val: PackArr<LVoidEdge>, context: Context): boolean { return this.set_edgesOut(val, context); }\r\n\r\n\r\n    protected _defaultGetter(c: Context, k: keyof Context[\"data\"]): any {\r\n        if (k in c.data) return this.__defaultGetter(c, k);\r\n        // if value not found in node, check in view.\r\n        return (this.get_view(c) as any)[k];\r\n        /*let ret: any;\r\n        let view = this.get_view(c);\r\n        try { ret = (view as any)[k] } catch (e) { Log.ee(\"Could not find get_ property \\\"\" + k + \"\\\" in node or view.\", {c, view, k}); return undefined; }\r\n        return ret;*/\r\n    }\r\n\r\n    protected _defaultSetter(v: any, c: Context, k: keyof Context[\"data\"]): true {\r\n        this.__defaultSetter(v, c, k);\r\n        return true;\r\n    }\r\n\r\n    get_graphAncestors(c: Context): LGraph[] {\r\n        let current = c.proxyObject;\r\n        let next = current.father;\r\n        let ret: LGraph[] = [];\r\n        while(next) {\r\n            if (RuntimeAccessibleClass.extends(next.className, DGraph.cname)) ret.push(next as LGraph);\r\n            if (current.id === next.id) break;\r\n            current = next;\r\n            next = next.father;\r\n        }\r\n        return ret;\r\n    }\r\n    get_outerGraph(context: Context): LGraph {\r\n        // todo: this relies on the fact that GraphVertex are not passing their own id to their childrens, but the parent graph id\r\n        return TargetableProxyHandler.wrap(context.data.graph);\r\n    }\r\n    get_vertex(context: Context): this[\"vertex\"] {\r\n        let lcurrent: LGraphElement = LPointerTargetable.fromPointer(context.data.id);\r\n        let dcurrent = lcurrent.__raw;\r\n        // iterate parents.\r\n        while(dcurrent){\r\n            switch(dcurrent.className){\r\n                case DVertex.cname:\r\n                case DVoidVertex.cname:\r\n                case DGraphVertex.cname: return (lcurrent || LPointerTargetable.fromD(dcurrent)) as LVoidVertex;\r\n                default:\r\n                    if (!dcurrent.father || dcurrent.id === dcurrent.father) return undefined;\r\n                    Log.exDev(!dcurrent.father || dcurrent.id === dcurrent.father, \"node failed to get containing vertex\", context.data, dcurrent, lcurrent);\r\n                    lcurrent = LPointerTargetable.fromPointer(dcurrent.father);\r\n                    dcurrent = lcurrent.__raw;\r\n            }\r\n        }\r\n        return undefined;\r\n    }\r\n\r\n    get_innerGraph(context: Context): LGraph {\r\n        let dcurrent = DPointerTargetable.fromPointer(context.data.father);\r\n\r\n        // if no parent, but it's a graph, return itself.\r\n        if (!dcurrent) {\r\n            dcurrent = context.data;\r\n            switch(dcurrent.className){\r\n                case DGraph.cname:\r\n                case DGraphVertex.cname: return (LPointerTargetable.fromD(dcurrent)) as LGraph;\r\n                default: return Log.exDevv(\"root node failed to get containing graph\", {cdata:context.data, dcurrent});\r\n            }\r\n        }\r\n\r\n        // if it have a parent, iterate parents.\r\n        while(true){\r\n            switch(dcurrent?.className){\r\n                case DGraph.cname:\r\n                case DGraphVertex.cname: return (LPointerTargetable.fromD(dcurrent)) as LGraph;\r\n                default:\r\n                    Log.exDev(!dcurrent.father, \"node failed to get containing graph\", {cdata:context.data, dcurrent});\r\n                    Log.exDev(dcurrent.id === dcurrent.father, \"node failed to get containing graph, found loop\",\r\n                        {cdata:context.data, dcurrent, father: LPointerTargetable.from(dcurrent)?.father});\r\n                    dcurrent = DPointerTargetable.fromPointer(dcurrent.father);\r\n            }\r\n        }\r\n    }\r\n\r\n    // set_x(val: this[\"x\"], context: Context): boolean { SetFieldAction.new(context.data.id, \"x\", val, undefined, false); return true; }\r\n    // get_x(context: Context): this[\"x\"] { return context.data.x; }\r\n    get_x(context: Context): this[\"x\"] { return this.get_size(context).x; }\r\n    set_x(val: this[\"x\"], context: Context): boolean { return this.set_size({x:val}, context); }\r\n    get_y(context: Context): this[\"y\"] { return this.get_size(context).y; }\r\n    set_y(val: this[\"y\"], context: Context): boolean { return this.set_size({y:val}, context); }\r\n\r\n    get_w(context: Context): this[\"w\"] { return this.get_size(context).w; }\r\n    set_w(val: this[\"w\"], context: Context): boolean { return this.set_size({w:val}, context); }\r\n    get_h(context: Context): this[\"h\"] { return this.get_size(context).h; }\r\n    set_h(val: this[\"h\"], context: Context): boolean { return this.set_size({h:val}, context); }\r\n\r\n    get_width(context: Context): this[\"w\"] { return this.get_w(context); }\r\n    set_width(val: this[\"w\"], context: Context): boolean { return this.set_w(val, context); }\r\n    get_height(context: Context): this[\"h\"] { return this.get_h(context); }\r\n    set_height(val: this[\"h\"], context: Context): boolean { return this.set_h(val, context); }\r\n\r\n    get_position(context: Context): this[\"position\"] { return new GraphPoint(context.data.x, context.data.y); }\r\n    set_position(val: this[\"position\"], context: Context): boolean {\r\n        BEGIN()\r\n        SetFieldAction.new(context.data.id, \"x\", val.x, undefined, false);\r\n        SetFieldAction.new(context.data.id, \"y\", val.y, undefined, false);\r\n        END()\r\n        return true; }\r\n\r\n    get_sizeold(context: Context): this[\"size\"] { return new GraphSize(context.data.x, context.data.y, context.data.w, context.data.h); }\r\n    get_component(context: Context): this[\"component\"] {\r\n        // switch(context.data.className) { case DEdgePoint.name: return GraphElementComponent.map[context.data.father]; }\r\n        return GraphElementComponent.map[context.data.id]; }\r\n    // get_view(context: Context): this[\"view\"] { return this.get_component(context).props.view; }\r\n    get_view(context: Context): this[\"view\"] {\r\n        return transientProperties.node[context.data.id]?.mainView?.r || LPointerTargetable.fromPointer(context.data.view) || this.get_component(context)?.props.view?.r;\r\n    }\r\n    set_view(val: Pack1<this[\"view\"]>, context: Context){\r\n        Log.eDevv(\"node.view is readonly, change it through props or the model\");\r\n        // let ptr: DGraphElement[\"view\"] = Pointers.from(val as this[\"view\"]);\r\n        // return SetFieldAction.new(context.data.id, \"view\", ptr, '', true);\r\n    }\r\n\r\n    outerSize!: LGraphElement[\"size\"];\r\n    __info_of__outerSize: Info = {type:\"GraphSize\", txt:\"the size of the current element relative to the first (root) graph level.\"};\r\n    innerSize!: LGraphElement[\"size\"];\r\n    __info_of__innerSize: Info = {type:\"GraphSize\", txt:\"the size of the current element relative to the last (most nested) graph level.\"};\r\n    __info_of__size: Info = {type:\"GraphSize\", txt: \"same as innerSize.\"};\r\n\r\n\r\n    getSize(outer: boolean = false, canTriggerSet: boolean = true): Readonly<GraphSize> { return this.wrongAccessMessage(\"getSize()\"); }\r\n    get_getSize(c: Context): ((outer?: boolean, canTriggerSet?: boolean) => Readonly<GraphSize>) {\r\n        return (outer: boolean = true, canTriggerSet: boolean = true) => this.get_innerSize(c, canTriggerSet, outer); }\r\n\r\n    get_outerSize(context: Context, canTriggerSet: boolean = true): Readonly<GraphSize> {\r\n        return this.get_innerSize(context, canTriggerSet, true);\r\n    }\r\n    get_size(context: Context, canTriggerSet: boolean = true): Readonly<GraphSize> { return this.get_innerSize(context, canTriggerSet, false); }\r\n    get_innerSize(context: Context, canTriggerSet: boolean = true, outerSize: boolean = false): Readonly<GraphSize> {\r\n        let r = this.get_innerSize_impl(context, canTriggerSet, outerSize);\r\n        return new GraphSize(r.x, r.y, r.w, r.h);\r\n    }\r\n    protected get_innerSize_impl(context: Context, canTriggerSet: boolean = true, outerSize: boolean = false): Readonly<GraphSize> {\r\n        canTriggerSet = canTriggerSet && !Debug.lightMode;\r\n        let cname = context.data.className;\r\n        // cname = DGraphElement.cname;\r\n        switch (cname){\r\n            default: return Log.exDevv(\"unexpected classname in get_size switch: \" + context.data.className);\r\n            case DEdge.cname:\r\n            case DVoidEdge.cname:\r\n            case DGraph.cname: return nosize as any;\r\n            // case DField.cname:\r\n            case DGraphElement.cname:\r\n                let graph = outerSize ? this.get_outerGraph(context) : this.get_innerGraph(context);\r\n                return graph.coord(this.get_htmlSize(context));\r\n            case DVoidVertex.cname:\r\n            case DVertex.cname:\r\n            case DEdgePoint.cname:\r\n            case DGraphVertex.cname: break;\r\n        }\r\n\r\n        // low prio todo: memoization in proxy, as long state does not change keep a collection Dictionary[object][key] = returnval. it gets emptied when state is updated.\r\n\r\n        // when loading a save, edge segements and edgepoints/nodes are computed before creating the edgepoint component\r\n        let view: LViewElement = this.get_view(context);\r\n        // (window as any).retry = ()=>view.getSize(context.data.id);\r\n        let ret: EPSize = view.getSize(context.data.id) as any; // (this.props.dataid || this.props.nodeid as string)\r\n\r\n        if (!ret) {\r\n            ret = new GraphSize() as EPSize;\r\n            ret.x = context.data.x;\r\n            ret.y = context.data.y;\r\n            ret.w = context.data.w;\r\n            ret.h = context.data.h;\r\n            let def: GraphSize | undefined;\r\n            if (undefined===(ret.x)) { if (!def) def = view.defaultVSize; ret.x = def.x || 0;}\r\n            if (undefined===(ret.y)) { if (!def) def = view.defaultVSize; ret.y = def.y || 0;}\r\n            if (undefined===(ret.w)) { if (!def) def = view.defaultVSize; ret.w = def.w || 10;}\r\n            if (undefined===(ret.h)) { if (!def) def = view.defaultVSize; ret.h = def.h | 10;}\r\n            ret.currentCoordType = (context.data as DEdgePoint).currentCoordType as any;\r\n        }\r\n        if (context.data.className === DEdgePoint.cname) {\r\n            ret = (this as any as LEdgePoint).decodePosCoords(context, ret, view);\r\n        }\r\n\r\n        /*\r\n                if ((context.data as DVoidVertex).isResized) {\r\n                    return ret;\r\n                }*/\r\n        if (!canTriggerSet) {\r\n            if (outerSize) ret = this.get_outerGraph(context).translateSize(ret, this.get_innerGraph(context));\r\n            return ret;\r\n        }\r\n        let html: HTMLElement | undefined | null = this.get_component(context)?.html?.current;\r\n        let actualSize: Partial<Size> & {w:number, h:number} = html ? Size.of(html) : {w:0, h:0};\r\n        let isOldElement = (context.data.clonedCounter as number) > 3;\r\n        // if w = 0 i don't auto-set it as in first render it has w:0 because is not reredered and not resized.\r\n        // console.log(\"getSize() cantriggerset html size\", {ret: ret ? {...ret} : ret, html, actualSize, hcc:html?.dataset?.clonedcounter, ncc: context.data.clonedCounter});\r\n        if (!html || +(html.dataset.clonedcounter as string) !== context.data.clonedCounter) canTriggerSet = false;\r\n        let updateSize: boolean = false;\r\n        if (view.adaptWidth && ret.w !== actualSize.w) {\r\n            if (canTriggerSet && (isOldElement || actualSize.w !== 0)) {\r\n                ret.w = actualSize.w;\r\n                updateSize = true;\r\n            }\r\n        }\r\n        if (view.adaptHeight && ret.h !== actualSize.h) {\r\n            if (canTriggerSet && (isOldElement || actualSize.h !== 0)) {\r\n                ret.h = actualSize.h;\r\n                updateSize = true;\r\n            }\r\n        }\r\n        // console.log(\"getSize() from node merged with actualSize\", {ret: {...ret}});\r\n\r\n        if (updateSize) this.set_size(ret, context);\r\n        if (outerSize) ret = this.get_outerGraph(context).translateSize(ret, this.get_innerGraph(context));\r\n        return ret;\r\n    }\r\n    // set_size(size: Partial<this[\"size\"]>, context: Context): boolean {\r\n    set_size(size0: Partial<GraphSize>, c: Context): boolean {\r\n        // console.log(\"setSize(\"+(this.props?.data as any).name+\") thisss\", this);\r\n        if (!size0) return false;\r\n        let size = size0 as Partial<EPSize>;\r\n        let view = this.get_view(c);\r\n        let testmode: boolean = false;\r\n        if (c.data.className === DEdgePoint.cname && size.currentCoordType !== CoordinateMode.absolute) size = (this as any as LEdgePoint).encodePosCoords(c as any, size, view);\r\n\r\n        if (view.updateSize(c.data.id, size)) return true;\r\n        BEGIN()\r\n        if (size.x !== c.data.x && size.x !== undefined) SetFieldAction.new(c.data.id, \"x\", size.x, undefined, false);\r\n        if (size.y !== c.data.y && size.y !== undefined) SetFieldAction.new(c.data.id, \"y\", size.y, undefined, false);\r\n        if (size.w !== c.data.w && size.w !== undefined) SetFieldAction.new(c.data.id, \"w\", size.w, undefined, false);\r\n        if (size.h !== c.data.h && size.h !== undefined) SetFieldAction.new(c.data.id, \"h\", size.h, undefined, false);\r\n        let epdata: DEdgePoint = c.data as DEdgePoint;\r\n        if (size.currentCoordType !== epdata.currentCoordType && size.currentCoordType !== undefined) SetFieldAction.new(epdata.id, \"currentCoordType\", size.currentCoordType, undefined, false);\r\n        END()\r\n        return true; }\r\n\r\n    get_html(c: Context): this[\"html\"] {\r\n        let component = this.get_component(c);\r\n        let html = component?.html.current;\r\n        if (html) return html;\r\n        html = $('[nodeid=\"' + c.data.id + '\"]')[0];\r\n        if (!html) return undefined;\r\n        if (component) (component.html as any).current = html;\r\n        return html;\r\n    }\r\n    // get_html(context: Context): this[\"html\"] { return $(\"[node-id='\" + context.data.id + \"']\")[0]; }\r\n    set_html(val: this[\"htmlSize\"], context: Context): boolean { return this.cannotSet(\"set_html(). html is generated through jsx. edit the view instead.\"); }\r\n\r\n    get_htmlSize(context: Context): this[\"htmlSize\"] {\r\n        let html = this.get_html(context);\r\n        return html ? Size.of(html) : new Size(0, 0, 0, 0);\r\n        /*\r\n        let graph = this.get_graph(context);\r\n        if (!html) return nosize as any;\r\n        let size = Size.of(html);\r\n        let zoom = graph.zoom;\r\n        size.x /= zoom.x;\r\n        size.y /= zoom.y;\r\n        return size;*/}\r\n    set_htmlSize(val: this[\"htmlSize\"], context: Context): boolean {\r\n        // might be useful for fixed display size/location elements that stay in place even if you move tab or change zoom. debatable if needed\r\n        this.cannotSet(\"set_htmlSize(): todo extra low priority. set GraphSize through set_size instead.\");\r\n        return true; }\r\n    get_htmlPosition(context: Context): this[\"htmlPosition\"] { return this.get_htmlSize(context).tl(); }\r\n    set_htmlPosition(val: this[\"htmlPosition\"], context: Context): boolean {\r\n        // might be useful for fixed display size/location elements that stay in place even if you move tab or change zoom. debatable if needed\r\n        this.cannotSet(\"set_htmlPosition(): todo extra low priority. set graph position through set_position instead.\");\r\n        return true; }\r\n\r\n\r\n    /* how z-index work, it's really messy.\r\n    * cannot move html position. node id depends on it, and a node moving position would need to change id.\r\n    * so i use css order.\r\n    * first order is assigned through node constructor called by parent component injectProps, according to his last index in html.\r\n    * now z-index is set in node and updated properly.\r\n    * z-index is passed to a prop, rendered as html attribute.\r\n    * css takes the attribute value and uses it in \"order\" css rule.\r\n    * problem: updating node.z doesn't trigger the parent injectprops, so he inject html index and\r\n    * the outernmost html root cannot update his attribute without refreshing the parent and recalling injectprops\r\n    * fixed: by updating it directly in GraphElement.render()\r\n    * */\r\n    get_zIndex(context: Context): this[\"zIndex\"] { return (+context.data.zIndex || 0); }\r\n    set_zIndex(val: this[\"zIndex\"], context: Context): boolean {\r\n        SetFieldAction.new(context.data.id, \"zIndex\", +val ?? 0, undefined, false);\r\n        return true; }\r\n    get_z(context: Context): this[\"zIndex\"] { return context.data.zIndex; }\r\n    set_z(val: this[\"zIndex\"], context: Context): boolean { return this.set_zIndex(val, context); }\r\n    /*\r\n        get_containedIn(context: Context): this[\"containedIn\"] {\r\n            return context.data.containedIn ? LPointerTargetable.fromPointer(context.data.containedIn) : undefined; }\r\n        set_containedIn(val: Pack1<this[\"containedIn\"]>, context: LogicContext<DGraphElement>): boolean {\r\n            let ptr: DGraphElement[\"containedIn\"] = Pointers.from(val) as any;\r\n            SetFieldAction.new(context.data, 'containedIn', ptr, undefined, true);\r\n            if (ptr) SetFieldAction.new(ptr as any, 'subElements+=', context.data.id);\r\n            return true; }*/\r\n\r\n    nodes!:LVoidVertex[];\r\n    __type_of__nodes:Info = {type:'LVertex[]', txt: \"all direct sub-nodes. not including deep subelements (subelements of subelements)\"};\r\n    get_nodes(c: Context): this['nodes'] { return this.get_subElements(c).filter(c => c && c.className.indexOf('Vertex') >= 0) as any; }\r\n    set_nodes(val: never, c: Context): boolean { return this.cannotSet('nodes'); }\r\n    edges!:LVoidVertex[];\r\n    __type_of__edges:Info = {type:'LEdge[]', txt: \"all direct sub-edges. not including deep subelements (subelements of subelements)\"};\r\n    get_edges(c: Context): this['edges'] { return this.get_subElements(c).filter(c => c && c.className.indexOf('Edge') >= 0) as any; }\r\n    set_edges(val: never, c: Context): boolean { return this.cannotSet('edges'); }\r\n    graphs!:LVoidVertex[];\r\n    __type_of__graphs:Info = {type:'LGraph[]', txt: \"all direct sub-graphs. not including deep subelements (subelements of subelements)\"};\r\n    get_graphs(c: Context): this['graphs'] { return this.get_subElements(c).filter(c => c && c.className.indexOf('Graph') >= 0) as any; }\r\n    set_graphs(val: never, c: Context): boolean { return this.cannotSet('graphs'); }\r\n\r\n    allSubNodes!: LVoidVertex[];\r\n    __type_of__allSubNodes:Info = {type:'LVertex[]', txt: \"all deep sub-nodes. including subelements of subelements.\"};\r\n    get_allSubNodes(c: Context): this['allSubNodes'] { return this.get_allSubElements(c).filter(c => c && c.className.indexOf('Vertex') >= 0) as any; }\r\n    set_allSubNodes(val: never, c: Context): boolean { return this.cannotSet('allSubNodes'); }\r\n    allSubEdges!: LVoidEdge[];\r\n    __type_of__allSubEdges:Info = {type:'LEdge[]', txt: \"all deep sub-edges. including subelements of subelements.\"};\r\n    get_allSubEdges(c: Context): this['allSubEdges'] { return this.get_allSubElements(c).filter(c => c && c.className.indexOf('Edge') >= 0) as any; }\r\n    set_allSubEdges(val: never, c: Context): boolean { return this.cannotSet('allSubEdges'); }\r\n    allSubGraphs!: (LGraph | LGraphVertex)[];\r\n    __type_of__allSubGraphs:Info = {type:'LGraph[]', txt: \"all deep sub-graphs. including subelements of subelements.\"};\r\n    get_allSubGraphs(c: Context): this['allSubGraphs'] { return this.get_allSubElements(c).filter(c => c && c.className.indexOf('Graph') >= 0) as any; }\r\n    set_allSubGraphs(val: never, c: Context): boolean { return this.cannotSet('allSubGraphs'); }\r\n\r\n    subElements!: LGraphElement[]; // shallow, direct subelements\r\n    __info_of__subElements: Info = {type: 'LGraphElement[]',\r\n        txt: \"all direct subelements (nodes, edges, edgepoints, subgraphs...). not including deep subelements (subelements of subelements)\"}\r\n    get_subElements(context: Context): this[\"subElements\"] {\r\n        return LPointerTargetable.fromArr([...new Set(context.data.subElements)]).filter((e:L)=>!!e);\r\n    }\r\n    set_subElements(val: PackArr<this[\"subElements\"]>, context: LogicContext<DGraphElement>): boolean {\r\n        console.log(\"isDeepStrictEqual\", {isDeepStrictEqual});\r\n        Log.eDev([...new Set(val)].length !== val.length, \"subelemnts setter have duplicates\", {val, context});\r\n        // if (isDeepStrictEqual(context.data.subElements, val)) return true;\r\n        let pointers: Pointer<DGraphElement, 0, 'N', LGraphElement> = Pointers.from(val) || [];\r\n        if (Uarr.equals(pointers, context.data.subElements, false)) return true;\r\n        SetFieldAction.new(context.data, 'subElements', pointers, '', true);\r\n        const idlookup = store.getState().idlookup;\r\n        let arrdiff = U.arrayDifference(context.data.subElements, pointers);\r\n        // old subelements\r\n        for (let oldsubelementid of arrdiff.removed) {\r\n            let subelement: DGraphElement = (oldsubelementid && idlookup[oldsubelementid]) as DGraphElement;\r\n            if (subelement.father !== context.data.id) continue;\r\n            LPointerTargetable.from(subelement).father = null as any; // todo: can this happen? è transitorio o causa vertici senza parent permanenti?\r\n        }\r\n        // new subelements\r\n        for (let newsubelementid of arrdiff.added) {\r\n            let subelement: DGraphElement = (newsubelementid && idlookup[newsubelementid]) as DGraphElement;\r\n            if (subelement.father === context.data.id) continue;\r\n            LPointerTargetable.from(subelement).father = context.data.id as any; // trigger side-action\r\n        }\r\n        return true;\r\n    }\r\n\r\n    allSubElements!: LGraphElement[]; // deep, nested subelements\r\n    __info_of__allSubElements: Info = {type: 'LGraphElement[]',\r\n        txt: \"all deep subelements (nodes, edges, edgepoints, subgraphs...). including subelements of subelements.\"}\r\n    private get_allSubElements(context: Context, state?: DState): this[\"allSubElements\"] {\r\n        // return context.data.packages.map(p => LPointerTargetable.from(p));\r\n        state = state || store.getState();\r\n        let tocheck: Pointer<DGraphElement>[] = context.data.subElements || [];\r\n        let checked: Dictionary<Pointer, true> = {};\r\n        let dblcheck: Dictionary<Pointer, Pointer> = {}; // <child, parent>  // debug only\r\n        for (let e of tocheck) dblcheck[e] = context.data.id; // debug only\r\n        checked[context.data.id] = true;//nb6[]{}&\r\n        while (tocheck.length) {\r\n            let newtocheck: Pointer<DGraphElement>[] = [];\r\n            for (let ptr of tocheck) {\r\n                Log.eDev(checked[ptr], \"loop in GraphElements containing themselves\", {dblcheck, context, ptr, checked, fistContainer:dblcheck[ptr]});\r\n                if (checked[ptr]) continue;\r\n                checked[ptr] = true;\r\n                let subnode: DGraphElement = DPointerTargetable.from(ptr, state);\r\n                let se = subnode?.subElements;\r\n                //for (let e of se) dblcheck[e] = ptr; // debug only\r\n                U.arrayMergeInPlace(newtocheck, se);\r\n            }\r\n            tocheck = newtocheck;\r\n        }\r\n        delete checked[context.data.id];\r\n        return LPointerTargetable.from(Object.keys(checked), state);\r\n    }\r\n    set_allSubElements(val: never, c: Context): boolean { return this.cannotSet('allSubElements'); }\r\n\r\n    get_isResized(context: LogicContext<DVoidVertex>): DVoidVertex[\"isResized\"] { return context.data.isResized; }\r\n    set_isResized(val: DVoidVertex[\"isResized\"], context: LogicContext<DVoidVertex>): DVoidVertex[\"isResized\"] {\r\n        return SetFieldAction.new(context.data.id, \"isResized\", val);\r\n    }\r\n\r\n    get_model(context: Context): this[\"model\"] {\r\n        const modelElementId = context.data.model; //$('[id=\"' + context.data.id + '\"]')[0].dataset.dataid;\r\n        const lModelElement: LModelElement = LPointerTargetable.from(modelElementId as string);\r\n        return lModelElement;\r\n    }\r\n\r\n    assignEdgeAnchor!: ((anchorName?: string)=>void);\r\n    __info_of__assignEdgeAnchor!: {hidden:true, type:\"(anchorName?: string)=>void\", txt: \"Assign a specific anchor of this node to the edge currently following the cursor, if any.\"};\r\n    get_assignEdgeAnchor(c: Context): ((anchorName?: string)=>void) {\r\n        return (anchorName?: string)=>{\r\n            if (anchorName && !c.data.anchors[anchorName]) anchorName = undefined;\r\n            if (LVoidEdge.startFollow) {\r\n                let de: DEdge = DPointerTargetable.fromPointer(LVoidEdge.startFollow);\r\n                if (de.start !== c.data.id) return; // cannot change edge targets, only an anchor within the current targets\r\n                let le: LVoidEdge = LPointerTargetable.fromD(de);\r\n                le.anchorStart = anchorName;\r\n                le.startFollow = false;\r\n\r\n            }\r\n            if (LVoidEdge.endFollow) {\r\n                let de = DPointerTargetable.fromPointer(LVoidEdge.endFollow);\r\n                if (de.end !== c.data.id) return; // cannot change edge targets, only an anchor within the current targets\r\n                let le = LPointerTargetable.fromD(de);\r\n                le.anchorEnd = anchorName;\r\n                le.endFollow = false;\r\n            }\r\n        }\r\n    }\r\n    get_events(c: Context): LViewElement[\"events\"] {\r\n        const tn = transientProperties.node[c.data.id];\r\n        let mainview: DViewElement = tn.mainView.__raw;\r\n        let otherViews: DViewElement[] = tn.stackViews.map(v=>v.__raw);\r\n        let allviews: DViewElement[] = [mainview, ...otherViews].reverse();\r\n        const keep_for_closure_original_funcs: LViewElement[\"events\"] = {};\r\n        const ret: LViewElement[\"events\"] = {};\r\n        for (let dv of allviews) U.objectMergeInPlace(keep_for_closure_original_funcs, transientProperties.view[dv.id].events);\r\n\r\n        const lastContext: GObject = tn.viewScores[mainview.id].evalContext;\r\n        const keys = Object.keys(keep_for_closure_original_funcs);\r\n        // for (let k of keys) ret['_raw_'+k] = keep_for_closure_original_funcs[k];\r\n        for (let k of keys) {\r\n            if (!keep_for_closure_original_funcs[k]) continue;\r\n            ret[k] = (..._params: any) => keep_for_closure_original_funcs[k](lastContext, ..._params);\r\n        }\r\n\r\n        return ret; }\r\n\r\n\r\n    get_father(context: Context): this[\"father\"] { return LPointerTargetable.fromPointer(context.data.father); }\r\n    set_father(val: Pack1<this[\"father\"]>, context: Context): boolean {\r\n        let ptr: DGraphElement[\"father\"] = Pointers.from(val) as any;\r\n        SetFieldAction.new(context.data, 'father', ptr, undefined, true);\r\n        if (ptr) SetFieldAction.new(ptr as any, 'subElements+=', context.data.id);\r\n        return true; }\r\n\r\n    __info_of__isselected: Info = {type: \"Dictionary<Pointer<User>, true>\",\r\n        txt:<div>A map that contains all the users selecting this element as keys, and always true as a value (if present).\r\n            <br/>Edit it through node.select() and node.deselect()</div>}\r\n    __info_of__select: Info = {type:\"function(forUser?:Pointer<User>):void\", txt:\"Marks this node as selected by argument user.\"};\r\n    __info_of__deselect: Info = {type:\"function(forUser?:Pointer<User>):void\", txt:\"Un-marks this node as selected by argument user.\"};\r\n    __info_of__toggleSelect: Info = {type:\"function(usr?:Pointer<User>):void\", txt:\"Calls this.select(usr) if the node is selected by argument user, this.deselect(usr) otherwise. If omitted, argument \\\"usr\\\" is the current user id.<br>Returns the result of this.isSelected() after the toggle.\"};\r\n    __info_of__isSelected: Info = {type:\"function(forUser?:Pointer<User>):void\", txt:\"Tells if this node is selected by argument user.\"};\r\n    select(forUser?: Pointer<DUser>): void { return this.wrongAccessMessage(\"node.select()\"); }\r\n    deselect(forUser?: Pointer<DUser>): void { return this.wrongAccessMessage(\"node.deselect()\"); }\r\n    toggleSelected(forUser?: Pointer<DUser>): void { return this.wrongAccessMessage(\"node.toggleSelected()\"); }\r\n    isSelected(forUser?: Pointer<DUser>): boolean { return this.wrongAccessMessage(\"node.isSelected()\"); }\r\n    get_select(c: Context): (forUser?: Pointer<DUser>)=>void {\r\n        return (forUser?: Pointer<DUser>)=> {\r\n            if (!forUser) forUser = DUser.current;\r\n            if (c.data.isSelected[forUser]) return; // no-op\r\n            let map = {...c.data.isSelected};\r\n            map[forUser] = true;\r\n            SetFieldAction.new(c.data.id, \"isSelected\", map, undefined, false);\r\n            // todo: actually they are pointer to users, but i'm assuming users are not erased at runtime. on deselect too\r\n        }\r\n    }\r\n    get_deselect(c: Context): (forUser?: Pointer<DUser>)=>void {\r\n        return (forUser?: Pointer<DUser>)=> {\r\n            if (!forUser) forUser = DUser.current;\r\n            if (!c.data.isSelected[forUser]) return; // no-op\r\n            let map = {...c.data.isSelected};\r\n            delete map[forUser];\r\n            SetFieldAction.new(c.data.id, \"isSelected\", map, undefined, false);\r\n            // todo: actually they are pointer to users, but i'm assuming users are not erased at runtime. on deselect too\r\n        }\r\n    }\r\n    get_toggleSelected(context: Context): ((forUser?: Pointer<DUser>) => boolean) {\r\n        return (forUser?: Pointer<DUser>): boolean => {\r\n            if (!forUser) forUser = DUser.current;\r\n            if (this.get_isSelected(context)(forUser)) {\r\n                this.get_deselect(context)(forUser);\r\n                return false;\r\n            } else {\r\n                this.get_select(context)(forUser);\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    get_isSelected(context: Context): ((forUser?: Pointer<DUser>) => boolean) {\r\n        return (forUser?: Pointer<DUser>): boolean => {\r\n            if (!forUser) forUser = DUser.current;\r\n            return !!context.data.isSelected[forUser]; }\r\n    }\r\n    set_isSelected(val: this[\"isSelected\"], context: Context): boolean {\r\n        return this.cannotSet(\"graphElement.isSelected(): use this.select() or this.deselect() instead.\");\r\n    }\r\n    /*\r\n    get_isSelected(context: LogicContext<DVoidVertex>): GObject {\r\n        return DPointerTargetable.mapWrap(context.data.isSelected, context.data, 'idlookup.' + context.data.id + '.isSelected', []);\r\n    }*/\r\n\r\n\r\n\r\n    // for edges\r\n    public get_startPoint(c: Context|undefined, size?: GraphSize, view?: LViewElement): GraphPoint { return this.get_startEndPoint(c, size, view, true); }\r\n    public get_endPoint(c: Context|undefined, size?: GraphSize, view?: LViewElement): GraphPoint { return this.get_startEndPoint(c, size, view, false); }\r\n    private get_startEndPoint(c: Context|undefined, size?: GraphSize, view?: LViewElement, isStart:boolean=true): GraphPoint {\r\n        if (!size) {\r\n            if (c) size = this.get_size(c) as any; else size = Log.exDevv(\"invalid arguments in get_startEndPoint\", {arguments});\r\n        }\r\n        if (!view) {\r\n            // if (c) view = this.get_view(c); else view = Log.exDevv(\"invalid arguments in get_startPoint\", {arguments});\r\n            view = c && this.get_view(c) || Log.exDevv(\"invalid arguments in get_startEndPoint\", {arguments});\r\n        }\r\n        let offset: GraphPoint = (view as LViewElement)[isStart ? \"edgeStartOffset\" : \"edgeEndOffset\"];\r\n        let isPercentage: boolean = (view as LViewElement)[isStart ? \"edgeStartOffset_isPercentage\" : \"edgeEndOffset_isPercentage\"];\r\n        if (!size) size = new GraphSize(0, 0, 0, 0);\r\n        if (isPercentage) offset = new GraphPoint(offset.x/100*(size.w), offset.y/100*(size.h));\r\n        return size.tl().add(offset, false);\r\n    }\r\n\r\n}\r\nRuntimeAccessibleClass.set_extend(DPointerTargetable, DGraphElement);\r\nRuntimeAccessibleClass.set_extend(LPointerTargetable, LGraphElement)\r\n\r\n\r\n@RuntimeAccessible('DGraph')\r\nexport class DGraph extends DGraphElement {\r\n    // static _super = DGraphElement;\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // static singleton: LGraph;\r\n    // static logic: typeof LGraph;\r\n    // static structure: typeof DGraph;\r\n\r\n    // inherit redefine\r\n    father!: Pointer<DGraphElement, 1, 1, LGraphElement>;\r\n    id!: Pointer<DGraph, 1, 1, LGraph>;\r\n    graph!: Pointer<DGraph, 1, 1, LGraph>;\r\n    model!: Pointer<DModelElement, 1, 1, LModelElement>;\r\n    isSelected!: Dictionary<DocString<Pointer<DUser>>, boolean>;\r\n    // containedIn!: Pointer<DGraphElement, 0, 1, LGraphElement>;\r\n\r\n    state!: GObject;\r\n    // personal attributes\r\n    zoom!: GraphPoint;\r\n    offset!: GraphPoint; // in-graph scrolling offset\r\n\r\n    public static new(htmlindex: number, model: DGraph[\"model\"],\r\n                      parentNodeID?: DGraphElement[\"father\"], // immediate parent\r\n                      parentgraphID?: DGraphElement[\"graph\"], // graph containing this subgraph (redudant? could get it from father chain)\r\n                      nodeID?: DGraphElement[\"id\"] // this id\r\n    ): DGraph {\r\n        return new Constructors(new DGraph('dwc'), parentNodeID, true, undefined, nodeID || Constructors.DGraph_makeID(model))\r\n            .DPointerTargetable()\r\n            .DGraphElement(model, parentgraphID, htmlindex).DGraph().end();\r\n    }\r\n\r\n\r\n    static getNodes(dmp: import(\"../logicWrapper/LModelElement\").DModelElement[], out: {$matched: JQuery<HTMLElement>; $notMatched: JQuery<HTMLElement>; }): JQuery<HTMLElement> {\r\n        let $allnodes = $('[data-dataid]');\r\n        let matchedids: Pointer[] = (dmp || []).map(d => d.id);\r\n        let matchedidmap:Dictionary<string, boolean> = U.objectFromArrayValues(matchedids);\r\n        if (!out) out = {} as any;\r\n\r\n        let allnodesarr = [...$allnodes];\r\n        let filternode = (d: HTMLElement) => {\r\n            if (!d?.dataset?.dataid) return false;\r\n            let id: string = ''+d?.dataset?.dataid;\r\n            return matchedidmap[id]; };\r\n        out.$matched = $(allnodesarr.filter(filternode));\r\n        out.$notMatched = $(allnodesarr.filter((n) => !filternode(n)));\r\n        return out.$matched;\r\n        // throw new Error(\"Method not implemented.\");\r\n    }\r\n\r\n}\r\nvar nosize: GraphSize = {x:0, y:0, w:0, h:0, nosize:true} as any;\r\nvar defaultEdgePointSize: GraphSize = undefined as any; // = {x:0, y:0, w:5, h:5};\r\nvar defaultVertexSize: GraphSize = undefined as any; // {x:0, y:0, w:140.6818084716797, h:32.52840805053711};\r\n\r\n\r\n@RuntimeAccessible('LGraph')\r\nexport class LGraph<Context extends LogicContext<DGraph> = any, D extends DGraph = any> extends LGraphElement {\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // static singleton: LGraph;\r\n    // static logic: typeof LGraph;\r\n    // static structure: typeof DGraph;\r\n\r\n    // inherit redefine\r\n    __raw!: DGraph;\r\n    id!: Pointer<DGraph, 1, 1, LGraph>;\r\n    graph!: LGraph;\r\n    model?: LModelElement;\r\n    // isSelected: Dictionary<DocString<Pointer<DUser>>, boolean> = {};\r\n    isSelected(forUser?: Pointer<DUser>): boolean { return this.wrongAccessMessage(\"node.isSelected()\"); }\r\n    // containedIn?: LGraphElement;\r\n    subElements!: LGraphElement[];\r\n    _state!: GObject<\"proxified\">; // LMap;\r\n    // personal attributes\r\n    zoom!: GraphPoint;\r\n    graphSize!: GraphSize; // derived attribute: bounding rect containing all subnodes, while \"size\" is instead external size of the vertex holding the graph in GraphVertexes\r\n    offset!: GraphPoint; // Scrolling position inside the graph\r\n\r\n    // get_graphSize(context: LogicContext<DGraph>):  Readonly<GraphSize> { return todo: get bounding rect containing all subnodes.; }\r\n    get_offset(context: LogicContext<DGraph>):  Readonly<GraphSize> {\r\n        let offset: Partial<GraphSize> = (context.data.offset || new GraphSize()) as any;\r\n        return new GraphSize(offset.x, offset.y, offset.w, offset.h);\r\n    }\r\n    set_offset(val: Partial<GraphSize>, context: Context): boolean {\r\n        if (!val) val = {x:0, y:0, w:0, h:0};\r\n        //if (val.x === undefined && val.y === undefined && val.w === undefined && val.h === undefined) return true;\r\n        let offset: Partial<GraphSize> = (context.data.offset || new GraphSize()) as any\r\n        if (val.x === undefined && offset.x !== val.x) val.x = offset.x;\r\n        if (val.y === undefined && offset.y !== val.y) val.y = offset.y;\r\n        if (val.w === undefined && offset.w !== val.w) val.w = offset.w;\r\n        if (val.h === undefined && offset.h !== val.h) val.h = offset.h;\r\n        if (offset.x === val.x && offset.y === val.y && offset.w === val.w && offset.h == val.h) return true;\r\n        SetFieldAction.new(context.data, \"offset\", val as any);\r\n        return true;\r\n    }\r\n\r\n    public cumulativeZoom!: GraphPoint;\r\n    public __info_of__cumulativeZoom: Info = {type: GraphPoint.cname, txt: \"the product of all the ownZoom of containing ancestor graphs.\"};\r\n    private get_cumulativeZoom(c:Context): this['cumulativeZoom']{\r\n        let ancestors = [c.proxyObject, ...this.get_graphAncestors(c)];\r\n        let zoom: GraphPoint = new GraphPoint(1,1);\r\n        for (let g of ancestors) zoom.multiply(g.ownZoom, false);\r\n        return zoom;\r\n    }\r\n\r\n    get_zoom(c: Context): GraphPoint {\r\n        return this.get_cumulativeZoom(c);\r\n    }\r\n    public ownZoom!: GraphPoint;\r\n    __info_of__ownZoom: Info = {type:GraphPoint.cname, label:\"zoom\", txt:\"The individual zoom applied to this graph.\"};\r\n    __info_of__zoom: Info = {type:GraphPoint.cname, label:\"zoom\", txt:\"Scales the graph and all subelements by a factor.\"};\r\n    get_ownZoom(context: Context): GraphPoint {\r\n        const zoom: GraphPoint = context.data.zoom;\r\n        let ret = new GraphPoint(zoom.x||1, zoom.y||1); // NB: do not use (??1), zero is not a valid value for zoom.\r\n        // (zoom as any).debug = {rawgraph: context.data.__raw, zoomx: context.data.zoom.x, zoomy: context.data.zoom.y}\r\n        return ret; }\r\n    set_zoom(val: Partial<GraphPoint>, c: Context): boolean{\r\n        if (!val) val = {x:1, y:1};\r\n        //if (val.x === undefined && val.y === undefined) return true;\r\n        let zoom: Partial<GraphSize> = (c.data.zoom || new GraphSize()) as any;\r\n        if (!val.x) val.x = zoom.x; // remember zero is not allowed value\r\n        if (!val.y) val.y = zoom.y;\r\n        if (zoom.x === val.x && zoom.y === val.y) return true;\r\n        SetFieldAction.new(c.data, 'zoom', val as any, '+=', false);\r\n        return true;\r\n    }\r\n\r\n    toGraphSize(...a:Parameters<this[\"coord\"]>): ReturnType<this[\"coord\"]>{ return this.wrongAccessMessage(\"toGraphSize\"); }\r\n    coord(htmlSize: Size): GraphSize { return this.wrongAccessMessage(\"toGraphSize\"); }\r\n    get_coord(context: Context): (htmlSize: Size) => GraphSize {\r\n        return (htmlSize: Size)=> {\r\n            let graphHtmlSize: Size = this.get_htmlSize(context);\r\n            let zoom: GraphPoint = this.get_zoom(context);\r\n            return new GraphSize(\r\n                (htmlSize.x - graphHtmlSize.x) / zoom.x,\r\n                (htmlSize.y - graphHtmlSize.y) / zoom.y,\r\n                htmlSize.w/zoom.x,\r\n                htmlSize.h/zoom.y);\r\n        }\r\n    }\r\n    // get_htmlSize(context: Context): Size { }\r\n    translateSize<T extends GraphSize|GraphPoint>(ret: T, innerGraph: LGraph): T { return this.wrongAccessMessage(\"translateSize()\"); }\r\n    translateHtmlSize<T extends Size|Point, G = T extends Size ? GraphSize : GraphPoint>(size: T): G { return this.wrongAccessMessage(\"translateHtmlSize()\"); }\r\n\r\n    __info_of__offset: Info = {type:GraphPoint.cname, label:\"offset\", txt:\"In-graph scrolling position.\"};\r\n    __info_of__graphSize: Info = {type:GraphSize.cname, label:\"graphSize\", txt:\"size internal to the graph, including internal scroll and panning.\"};\r\n    __info_of__translateSize: Info = {type:\"(T, Graph)=>T where T is GraphSize | GraphPoint\", txt:\"Translates a coordinate set from the local coordinates of a SubGraph to this Graph containing it.\"};\r\n    __info_of__translateHtmlSize: Info = {type:\"(Size|Point) => GraphSize|GraphPoint\", txt:'Translate page\\'s viewport coordinate set to this graph coordinate set.'};\r\n    get_translateHtmlSize<T extends Size|Point, G = T extends Size ? GraphSize : GraphPoint>(c: Context): ((size: T) => G) {\r\n        return (size: T): G => {\r\n            let rootGraph: LGraph = this.get_root(c);\r\n            if (rootGraph.id === c.data.id) return this.get_translateHtmlSize_fromRoot<T, G>(c)(size);\r\n            let fakeRootSize = rootGraph.translateHtmlSize_fromRoot<T, G>(size) as any as ISize;\r\n            let screenOffset = this.get_screenOffset(c);//cumulative (g.size.tl()-offset.tl()*cumulativezoom)\r\n\r\n            // distance from the origin of the subgraph in rendered pixels\r\n            let ret = new GraphSize(fakeRootSize.x - screenOffset.x, fakeRootSize.y - screenOffset.y, fakeRootSize.w, fakeRootSize.h);\r\n            return ret.divide(this.get_cumulativeZoom(c) as any, false) as any;\r\n\r\n            /*\r\n            // fake because it assumes all subgraphs have the same zoom level of current graph.\r\n            let ancestors = this.get_graphAncestors(c).reverse().slice(1);\r\n            let cumulativeZoom: GraphPoint = new GraphPoint(1, 1); // = this.get_ownZoom(c);\r\n            for (let g of ancestors){\r\n                let offset = g.offset;\r\n                let ownZoom = g.ownZoom;\r\n                cumulativeZoom.multiply(ownZoom);\r\n                // let a, b, c be graphs\r\n                // size is =  a.zoom + a.offset\r\n\r\n            }\r\n            */\r\n        }\r\n    }\r\n    screenOffset!: GraphPoint;\r\n    __info_of__screenOffset: Info = {type: GraphPoint.cname, txt:\"Distance of the subgraph origin in rendered pixels. to the top-left of graph container.\"}\r\n    private get_screenOffset(c: Context): GraphPoint{\r\n        let ancestors = [c.proxyObject, ...this.get_graphAncestors(c)].reverse();\r\n        let ret = new GraphPoint(0, 0);\r\n        let cumulativeZoom: GraphPoint = new GraphPoint(1, 1); // = this.get_ownZoom(c);\r\n        for (let g of ancestors){\r\n            let offset = g.offset;\r\n            let ownZoom = g.ownZoom;\r\n            let size = g.size;\r\n            ret\r\n                .add(size.tl().multiply(cumulativeZoom, false), false)\r\n                .subtract(offset, false);\r\n            cumulativeZoom.multiply(ownZoom);\r\n            ret\r\n                .multiply(cumulativeZoom, false);\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    private translateHtmlSize_fromRoot<T extends Size|Point, G = T extends Size ? GraphSize : GraphPoint>(size: T):G {\r\n        return this.wrongAccessMessage('translateHtmlSize_fromRoot');\r\n    }\r\n\r\n    /**\r\n     *  IMPORTANT!\r\n     *  this is a wrong partial result, do not call this function directly outside translateHtmlSize.\r\n     *  this is outercoord without zoom, needs ti be translated to container graph coords & de-apply zoom\r\n     */\r\n    private get_translateHtmlSize_fromRoot<T extends Size|Point, G = T extends Size ? GraphSize : GraphPoint>(c: Context): ((size: T) => G) {\r\n        return (size: T): G => {\r\n            let graphHtmlSize = this.get_htmlSize(c);\r\n            let a = size.subtract(graphHtmlSize.tl(), true);\r\n            let offset = {x:c.data.offset.x, y:c.data.offset.y};\r\n            let b = a.subtract(offset, true);\r\n            let r = b.divide(c.data.zoom as any, false) as any as G;\r\n            return r;\r\n        }\r\n    }\r\n\r\n    // graph_of_size, the size parameter have coordinates based on this graph.\r\n    get_translateSize<T extends GraphSize|GraphPoint>(c: Context): ((size: T, graph_of_size: LGraph) => T) {\r\n        return (size: T, graph_of_size: LGraph): T => {\r\n            let targetGraph: LGraph = c.proxyObject;\r\n            let currGraph: LGraph = graph_of_size;\r\n            if (currGraph.id === c.data.id) return size;\r\n            let currAncestors: LGraph[] = [currGraph, ...currGraph.graphAncestors];\r\n            let targetAncestors: LGraph[] = [targetGraph, ...targetGraph.graphAncestors];\r\n            let currAncestorsPtr: Pointer<DGraph>[] = currAncestors.map(l=>l.id).reverse();\r\n            let targetAncestorsPtr: Pointer<DGraph>[] = targetAncestors.map(l=>l.id).reverse();\r\n            Log.ex(targetAncestorsPtr[0] !== currAncestorsPtr[0],\r\n                'translateSize() The root graph of 2 elements should always be the same, are you comparing nodes from different graphs?',\r\n                {currGraph, targetGraph});\r\n            let i: number = 1;\r\n            while (currAncestorsPtr[i] === targetAncestorsPtr[i]) { i++; }\r\n            let commonAncestor: Pointer<DGraph> = targetAncestorsPtr[i-1];\r\n            currAncestors = currAncestors.slice(0, currAncestors.length - i).filter(e=>!!e);\r\n            targetAncestors = targetAncestors.slice(0, currAncestors.length - i).filter(e=>!!e);\r\n            // d, c, b, a           currAncestors\r\n            // d, c, x, y           targetAncestors\r\n            // undo a,b, redo x,y        i = [2]\r\n\r\n            Log.exDev(!currAncestors.length && !targetAncestors.length, \"translateSize() found invalid intersection in container graphs\",\r\n                {currGraph, targetGraph, currAncestors, targetAncestors});\r\n            // @ts-ignore\r\n            let ret: T = 'w' in size ? new GraphSize(size.x, size.y, size.w, size.h) : new GraphPoint(size.x, size.y, size.w, size.h);\r\n            console.log(\"translateSizee pre\", (this.get_model(c) as any).name, size.x, size.y, {size, ret, currAncestors, targetAncestors} )\r\n            for (let g of currAncestors){\r\n                ret.subtract(g.offset, false);\r\n                ret.divide(g.cumulativeZoom, false);\r\n                ret.add(g.size.tl(), false);\r\n            }\r\n            for (let g of targetAncestors){\r\n                ret.subtract(g.size.tl(), false);\r\n                ret.multiply(g.cumulativeZoom, false);\r\n                ret.add(g.offset, false);\r\n            }\r\n            console.log(\"translateSizee ret\", (this.get_model(c) as any).name, size.x, size.y, {size, ret, currAncestors, targetAncestors} )\r\n\r\n            return ret; }\r\n        //todo: check how many passes you need to go down or up, and make the up version too\r\n\r\n    }\r\n    get_translateSize_down_old<T extends GraphSize|GraphPoint>(c: Context): ((size: T, innerGraph: LGraph) => T) {\r\n        return (size: T, graph_of_size: LGraph): T => {\r\n            graph_of_size = LPointerTargetable.wrap(graph_of_size) as LGraph;\r\n            let ret: T = (size.hasOwnProperty(\"w\") ? new GraphSize(size.x, size.y, (size as GraphSize).w, (size as GraphSize).h) : new GraphPoint(size.x, size.y)) as T;\r\n            Log.ex(!graph_of_size, \"translateSize() graph parameter is invalid: \"+graph_of_size, graph_of_size, c);\r\n            let ancestors: LGraph[] = [graph_of_size, ...graph_of_size.graphAncestors];\r\n            console.log(\"translateSize\", {innerGraph: graph_of_size, ret, ancestors, c});\r\n            Log.ex(ancestors.indexOf(c.proxyObject) !== -1, \"translateSize() graph parameter is invalid: it must be a graph containing the current one.\", graph_of_size, c);\r\n            for (let g of ancestors) ret.add(g.size.tl(), false);\r\n            // for (let g of ancestors) ret.subtract(g.offset, false);\r\n            // console.log(\"translateSize\", {c, thiss:c.proxyObject, ancestors, ancestorSizes: ancestors.map(a=> a.size.tl()), size, ret});\r\n            return ret; }\r\n    }\r\n    contains(elem: LGraphElement): boolean{ return this.wrongAccessMessage(\"contains()\"); }\r\n    get_contains(c: Context): ((elem: LGraphElement)=> boolean) {\r\n        return (elem: LGraphElement): boolean => {\r\n            let current = elem;\r\n            let next = elem.father;\r\n            let targetid = c.proxyObject.id;\r\n            if (current.id !== targetid) return true;\r\n            while(next && current.id !== next.id) {\r\n                current = next;\r\n                next = next.father;\r\n                if (current.id !== targetid) return true;\r\n            }\r\n            return false;\r\n        }}\r\n}\r\nRuntimeAccessibleClass.set_extend(DGraphElement, DGraph);\r\nRuntimeAccessibleClass.set_extend(LGraphElement, LGraph);\r\n// export const defaultVSize: GraphSize = new GraphSize(0, 0, 300, 160); // useless, now it's in view.DefaultVSize\r\n// export const defaultEPSize: GraphSize = new GraphSize(0, 0, 15, 15); // useless, now it's in view.DefaultVSize\r\n\r\n\r\n@RuntimeAccessible('DVoidVertex')\r\nexport class DVoidVertex extends DGraphElement {\r\n    // static _super = DGraphElement;\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // static singleton: LVoidVertex;\r\n    // static logic: typeof LVoidVertex;\r\n    // static structure: typeof DVoidVertex;\r\n\r\n    // inherit redefine\r\n    id!: Pointer<DVoidVertex, 1, 1, LVoidVertex>;\r\n    graph!: Pointer<DGraph, 1, 1, LGraph>;\r\n    model!: Pointer<DModelElement, 0, 1, LModelElement>;\r\n    isSelected!: Dictionary<DocString<Pointer<DUser>>, boolean>;\r\n    // containedIn!: Pointer<DGraphElement, 0, 1, LGraphElement>;\r\n    subElements!: Pointer<DGraphElement, 0, 'N', LGraphElement>;\r\n    state!: GObject;\r\n    zoom!: GraphPoint;\r\n    // personal attributes\r\n    x!: number;\r\n    y!: number;\r\n    w!: number;\r\n    h!: number;\r\n    isResized!: boolean;\r\n    // size?: GraphSize; // virtual, gets extracted from this. x and y are stored directly here as it extends GraphSize\r\n\r\n    public static new(htmlindex: number, model: DGraphElement[\"model\"], parentNodeID: DGraphElement[\"father\"], graphID: DGraphElement[\"graph\"], nodeID?: DGraphElement[\"id\"],\r\n                      size?: InitialVertexSize): DVoidVertex {\r\n        return new Constructors(new DVoidVertex('dwc'), parentNodeID, true, undefined, nodeID)\r\n            .DPointerTargetable()\r\n            .DGraphElement(model, graphID, htmlindex)\r\n            .DVoidVertex(size || defaultVertexSize).end();\r\n    }\r\n\r\n}\r\n\r\n@RuntimeAccessible('LVoidVertex')\r\nexport class LVoidVertex<Context extends LogicContext<DVoidVertex> = any, C extends Context = Context> extends LGraphElement {// <D extends DVoidVertex = any>\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // static singleton: LVoidVertex;\r\n    // static logic: typeof LVoidVertex;\r\n    // static structure: typeof DVoidVertex;\r\n\r\n    // inherit redefine\r\n    __raw!: DVoidVertex;\r\n    id!: Pointer<DVoidVertex, 1, 1, LVoidVertex>;\r\n    graph!: LGraph;\r\n    model?: LModelElement;\r\n    // isSelected: Dictionary<DocString<Pointer<DUser>>, boolean> = {};\r\n    isSelected(forUser?: Pointer<DUser>): boolean { return this.wrongAccessMessage(\"node.isSelected()\"); }\r\n    // containedIn?: LGraphElement;\r\n    subElements!: LGraphElement[];\r\n    _state!: GObject<\"proxified\">; // LMap;\r\n    zoom!: GraphPoint;\r\n    isResized!: boolean;\r\n\r\n    // personal attributes\r\n    x!: number;\r\n    y!: number;\r\n    w!: number;\r\n    h!: number;\r\n    size!: GraphSize; // virtual, gets extracted from this. x and y are stored directly here as it extends GraphSize\r\n    __info_of__size = {type: \"?GraphSize\", txt: \"Size of the vertex, if null it means is utilizing the defaultSize from view. recommended to read component.getSize() instead of this.\"};\r\n\r\n    get_isResized(context: LogicContext<DVoidVertex>): DVoidVertex[\"isResized\"] { return context.data.isResized; }\r\n    set_isResized(val: DVoidVertex[\"isResized\"], context: LogicContext<DVoidVertex>): DVoidVertex[\"isResized\"] {\r\n        return SetFieldAction.new(context.data.id, \"isResized\", val);\r\n    }\r\n\r\n\r\n\r\n}\r\n\r\nRuntimeAccessibleClass.set_extend(DGraphElement, DVoidVertex);\r\nRuntimeAccessibleClass.set_extend(LGraphElement, LVoidVertex);\r\n@RuntimeAccessible('DEdgePoint')\r\nexport class DEdgePoint extends DVoidVertex { // DVoidVertex\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // static singleton: LEdgePoint;\r\n    // static logic: typeof LEdgePoint;\r\n    // static structure: typeof DEdgePoint;\r\n\r\n    // inherit redefine\r\n    id!: Pointer<DEdgePoint, 1, 1, LEdgePoint>;\r\n    father!: Pointer<DVoidEdge, 1, 1, LVoidEdge>;\r\n    graph!: Pointer<DGraph, 1, 1, LGraph>;\r\n    model!: Pointer<DModelElement, 0, 1, LModelElement>; // todo: if null gets model from this.father (edge)?\r\n    isSelected!: Dictionary<DocString<Pointer<DUser>>, boolean>;\r\n    // containedIn!: Pointer<DGraphElement, 0, 1, LGraphElement>;\r\n    subElements!: Pointer<DGraphElement, 0, 'N', LGraphElement>;\r\n    zoom!: GraphPoint;\r\n    x!: number;\r\n    y!: number;\r\n    w!: number;\r\n    h!: number;\r\n    size?: GraphSize; //／／ virtual, gets extracted from this. x and y are stored directly here as it extends GraphSize\r\n    // personal attributes\r\n    __isDEdgePoint!: true;\r\n    currentCoordType?: CoordinateMode;\r\n\r\n    public static new(htmlindex: number, model: DEdgePoint[\"model\"] | undefined, parentNodeID: DEdgePoint[\"father\"], graphID?: DEdgePoint[\"graph\"], nodeID?: DGraphElement[\"id\"],\r\n                      size?: InitialVertexSize): DEdgePoint {\r\n        return new Constructors(new DEdgePoint('dwc'), parentNodeID, true, undefined, nodeID)\r\n            .DGraphElement(undefined, graphID, htmlindex)\r\n            .DVoidVertex(size || defaultEdgePointSize).DEdgePoint().end();\r\n    }\r\n\r\n}\r\n\r\n@RuntimeAccessible('LEdgePoint')\r\nexport class LEdgePoint<Context extends LogicContext<DEdgePoint> = any, C extends Context = Context> extends LVoidVertex {\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // static singleton: LEdgePoint;\r\n    // static logic: typeof LEdgePoint;\r\n    // static structure: typeof DEdgePoint;\r\n\r\n    // inherit redefine\r\n    father!: LVoidEdge;\r\n    // __raw!: DEdgePoint;\r\n    id!: Pointer<DEdgePoint, 1, 1, LEdgePoint>;\r\n    graph!: LGraph;\r\n    model?: LModelElement;\r\n    // isSelected: Dictionary<DocString<Pointer<DUser>>, boolean> = {};\r\n    isSelected(forUser?: Pointer<DUser>): boolean { return this.wrongAccessMessage(\"node.isSelected()\"); }\r\n    // containedIn?: LGraphElement;\r\n    subElements!: LGraphElement[];\r\n    zoom!: GraphPoint;\r\n    x!: number;\r\n    y!: number;\r\n    w!: number;\r\n    h!: number;\r\n    size!: GraphSize; // virtual, gets extracted from this. x and y are stored directly here as it extends GraphSize\r\n    // personal attributes\r\n    __isLEdgePoint!: true;\r\n    edge!: LVoidEdge; // returns container edge\r\n    __info_of__edge: Info = {type:\"?LEdge\", txt:\"returns the containing edge if called on an EdgePoint, \\\"this\\\" if called on an edge, undefined otherwise.\"}\r\n\r\n    public get_edge(c: Context): LVoidEdge { return c.proxyObject.father; }\r\n    public set_edge(v: Pack1<LVoidEdge>, c: Context): boolean { return this.set_father(v as any, c); }\r\n\r\n\r\n\r\n\r\n    static decodeCoords<T extends Partial<EPSize>>(size0: T, sp:GraphPoint, ep: GraphPoint): T/*absolute*/{\r\n        let size: any = size0;\r\n        let ret: any = ((\"w\" in size || \"h\" in size) ? new GraphSize() : new GraphPoint()); // GObject<Partial<GraphSize>>;\r\n        switch (size.currentCoordType) {\r\n            default: return Log.exDevv(\"translatePosCoords() invalid coordinate mode\", {mode:size.currentCoordType});\r\n            // case CoordinateMode.absolute: return size;\r\n            case CoordinateMode.absolute: case undefined: case null:\r\n                if (size.x !== undefined) ret.x = size.x;\r\n                if (size.y !== undefined) ret.y = size.y;\r\n                break;\r\n            case CoordinateMode.relativePercent:\r\n                //maybe do: dampening factor on relative % offset? is it possible?\r\n                // let s = this.getBasicSize(c);\r\n                // MATH:\r\n                // size.x = sp.x*x% + ep.x*(1-x%)\r\n                // size.x = sp.x*x% + ep.x - ep.x*x%\r\n                // size.x - ep.x= (sp.x - ep.x)*x%\r\n                // (size.x - ep.x) / (sp.x - ep.x) = x% // actually i inverted <sp, ep> in first equation, so reverse them in result too.\r\n                if (size.x !== undefined) ret.x = (1 - size.x) * sp.x + (size.x) * ep.x;\r\n                if (size.y !== undefined) ret.y = (1 - size.y) * sp.y + (size.y) * ep.y;\r\n                break;\r\n            case CoordinateMode.relativeOffset:\r\n            case CoordinateMode.relativeOffsetStart:\r\n            case CoordinateMode.relativeOffsetEnd:\r\n                let useStart: boolean;\r\n                let useEnd: boolean;\r\n                switch (size.currentCoordType) {\r\n                    default:\r\n                    case CoordinateMode.relativeOffset: useStart = true; useEnd = true; break;\r\n                    case CoordinateMode.relativeOffsetStart: useStart = true; useEnd = false; break;\r\n                    case CoordinateMode.relativeOffsetEnd: useStart = false; useEnd = true; break;\r\n                }\r\n                // offset = sp - size\r\n                // size = offset - sp\r\n                // in reverse: actualsize = offset, size=offset\r\n\r\n                // if coords are already in absolute mode.\r\n                let xIsAbsolute: number | undefined = (size.x&&!Array.isArray(size.x)) ? size.x : undefined;\r\n                let yIsAbsolute: number | undefined = (size.x&&!Array.isArray(size.x)) ? size.x : undefined;\r\n                Log.w(!!(xIsAbsolute || yIsAbsolute), \"decoding relative offset require an array size coordinate system. x=[x1, x2] --> x\", {size});\r\n\r\n                let offsetsp = useStart ? new GraphPoint(xIsAbsolute || size.x[0] + sp.x, yIsAbsolute || size.y[0] + sp.y) : new GraphPoint();\r\n                let offsetep = useEnd ? new GraphPoint(xIsAbsolute || size.x[1] + ep.x, yIsAbsolute || size.y[1] + ep.y) : new GraphPoint();\r\n                // if the start and endpoint of the edge didn't move, offsetsp = offsetep.\r\n                // if they moved, those 2 are discordant --> i pick middle\r\n                offsetsp.add(offsetep, false);\r\n                if (useStart && useEnd) offsetsp.divide(2, false);\r\n                if (!xIsAbsolute && size.x !== undefined) ret.x = offsetsp.x;\r\n                if (!yIsAbsolute && size.y !== undefined) ret.y = offsetsp.y;\r\n                if (xIsAbsolute) {\r\n                    ret.x = size.x;\r\n                }\r\n                if (yIsAbsolute) {\r\n                    ret.y = size.y;\r\n                }\r\n                break;\r\n        }\r\n        if (size.x === undefined) delete ret.x;\r\n        if (size.y === undefined) delete ret.y;\r\n        if ((size as any).w === undefined) delete ret.w; else ret.w = size.w;\r\n        if ((size as any).h === undefined) delete ret.h; else ret.h = size.h;\r\n        ret.currentCoordType = CoordinateMode.absolute;\r\n        // console.log(\"decode coords\", {size, sp, ep, ret});\r\n        return ret;\r\n    }\r\n    // from x,y as coords, to x%,y% as % of ((1-val)%*startpt) + ((val)%*endpt)\r\n    public decodePosCoords<T extends Partial<GraphSize> | Partial<GraphPoint>>(c: Context, size: T&any, view: LViewElement, sp0?: GraphPoint, ep0?: GraphPoint): T {\r\n        let le: LVoidEdge = c&&c.proxyObject.father;\r\n        // console.log(\"decodepos:\", {le, sp0, lesp:le?.startPoint});\r\n        let sp: GraphPoint = sp0||le.startPoint;\r\n        let ep: GraphPoint = ep0||le.endPoint;\r\n        return LEdgePoint.decodeCoords(size, sp, ep);\r\n    }\r\n\r\n    static testCoords(range: number = 30){\r\n        outer: for (let mode of [\"absolute\", \"relative%\", \"relativeOffset\", \"relativeOffsetStart\", \"relativeOffsetEnd\"])\r\n            for (let i = -range; i < range; i++)\r\n                for (let j = -range; j < range; j++){\r\n                    var s0 = {x:i, y:j};\r\n                    var sp = {x:10, y:10};\r\n                    var ep = {x:10, y:-10};\r\n                    // @ts-ignore\r\n                    var s1 = LEdgePoint.encodeCoords(s0, mode, sp, ep)\r\n                    // @ts-ignore\r\n                    var s00 = LEdgePoint.decodeCoords(s1, sp, ep);\r\n                    // @ts-ignore\r\n                    var error = Object.keys(s0).map( k=> s0[k].toFixed(3) === s00[k].toFixed(3) ? '' : k).join('');\r\n                    (mode != \"relative%\" && error ? console.error : console.log)({diff:[s00.x-s0.x, s00.y-s0.y].join(), i, j, mode, s1:[s1.x, s1.y].join(), s0, s00, error});\r\n                    if (mode != \"relative%\" && error ) break outer;\r\n                }\r\n    }\r\n    // @ts-ignore a\r\n\r\n    static encodeCoords<T extends Partial<EPSize>>(size0: T, edgePointCoordMode: CoordinateMode, sp:GraphPoint, ep: GraphPoint): T/*absolute*/{\r\n        let size: T = size0 as any;\r\n        if (edgePointCoordMode === size.currentCoordType ||\r\n            !size.currentCoordType && edgePointCoordMode === CoordinateMode.absolute) return size;\r\n        if (size.currentCoordType && size.currentCoordType !== CoordinateMode.absolute) size = LEdgePoint.decodeCoords(size, sp, ep);\r\n\r\n        let ret: any = ((\"w\" in size || \"h\" in size) ? new GraphSize() : new GraphPoint()); // GObject<Partial<GraphSize>>;\r\n        switch (edgePointCoordMode) {\r\n            default: return Log.exDevv(\"translatePosCoords() invalid coordinate mode\", {mode:edgePointCoordMode});\r\n            // case CoordinateMode.absolute: return size;\r\n            case CoordinateMode.relativePercent:\r\n                // let s = this.getBasicSize(c);\r\n                // MATH:\r\n                // size.x = sp.x*x% + ep.x*(1-x%)\r\n                // size.x = sp.x*x% + ep.x - ep.x*x%\r\n                // size.x - ep.x= (sp.x - ep.x)*x%\r\n                // (size.x - ep.x) / (sp.x - ep.x) = x% // actually i inverted <sp, ep> in first equation, so reverse them in result too.\r\n\r\n                if (sp.x === ep.x) ret.x = 0.5; // because otherwise it is infinity. so i force him to return in line.\r\n                else if (size.x !== undefined) ret.x = (size.x - sp.x) / (ep.x - sp.x);\r\n                if (sp.y === ep.y) ret.y = 0.5;\r\n                else if (size.y !== undefined) ret.y = (size.y - sp.y) / (ep.y - sp.y);\r\n                break;\r\n            case CoordinateMode.relativeOffset:\r\n            case CoordinateMode.relativeOffsetStart:\r\n            case CoordinateMode.relativeOffsetEnd:\r\n                let useStart: boolean;\r\n                let useEnd: boolean;\r\n                switch (edgePointCoordMode) {\r\n                    default:\r\n                    case CoordinateMode.relativeOffset: useStart = true; useEnd = true; break;\r\n                    case CoordinateMode.relativeOffsetStart: useStart = true; useEnd = false; break;\r\n                    case CoordinateMode.relativeOffsetEnd: useStart = false; useEnd = true; break;\r\n                }\r\n                if (size.x) ret.x = [useStart ? size.x - sp.x : -1, useEnd ? size.x - ep.x : -1];\r\n                if (size.y) ret.y = [useStart ? size.y - sp.y : -1, useEnd ? size.y - ep.y : -1];\r\n                /*\r\n                if (size.x) ret.x = [sp.x - size.x, ep.x - size.x];\r\n                if (size.y) ret.y = [sp.y - size.y, ep.y - size.y];*/\r\n                break;\r\n        }\r\n        if (size.x === undefined) delete ret.x;\r\n        if (size.y === undefined) delete ret.y;\r\n        if ((size as any).w === undefined) delete ret.w; else ret.w = (size as any).w;\r\n        if ((size as any).h === undefined) delete ret.h; else ret.h = (size as any).h;\r\n        // console.log(\"encode coorde\", {size, sp, ep, ret});\r\n        ret.currentCoordType = edgePointCoordMode;\r\n        return ret;\r\n    }\r\n    public encodePosCoords(c: Context, size0: Partial<EPSize>, view: LViewElement, sp0?: GraphPoint, ep0?: GraphPoint, mode?: CoordinateMode): Partial<EPSize> {\r\n        if (!view) view = this.get_view(c);\r\n        let size: Partial<EPSize> = size0 as any;\r\n        let edgePointCoordMode = mode || (view.__raw || view).edgePointCoordMode;\r\n        let le: LVoidEdge = c&&c.proxyObject.father;\r\n        let sp: GraphPoint = sp0 || le.startPoint;\r\n        let ep: GraphPoint = ep0 || le.endPoint;\r\n        return LEdgePoint.encodeCoords(size, edgePointCoordMode, sp, ep);\r\n    }\r\n\r\n    /* 13/10/2023 Giordano comment (defined in LPointerTargetable\r\n    public get_delete(context: Context): () => void {\r\n        // careful: pointedBy might be broken due to comment x984 (search it)\r\n        return super.get_delete(context);\r\n    }\r\n    */\r\n}\r\nRuntimeAccessibleClass.set_extend(DVoidVertex, DEdgePoint);\r\nRuntimeAccessibleClass.set_extend(LVoidVertex, LEdgePoint);\r\n\r\n@RuntimeAccessible('DVertex')\r\nexport class DVertex extends DGraphElement { // DVoidVertex\r\n    // static _super = DVoidVertex;\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // static singleton: LVertex;\r\n    // static logic: typeof LVertex;\r\n    // static structure: typeof DVertex;\r\n\r\n    // inherit redefine\r\n    id!: Pointer<DVertex, 1, 1, LVertex>;\r\n    graph!: Pointer<DGraph, 1, 1, LGraph>;\r\n    model!: Pointer<DModelElement, 0, 1, LModelElement>;\r\n    isSelected!: Dictionary<DocString<Pointer<DUser>>, boolean>;\r\n    // containedIn!: Pointer<DGraphElement, 0, 1, LGraphElement>;\r\n    subElements!: Pointer<DGraphElement, 0, 'N', LGraphElement>;\r\n    zoom!: GraphPoint;\r\n    x!: number;\r\n    y!: number;\r\n    w!: number;\r\n    h!: number;\r\n    isResized!: boolean;\r\n    // size!: GraphSize; // virtual, gets extracted from this. x and y are stored directly here as it extends GraphSize\r\n    // personal attributes\r\n    __isDVertex!: true;\r\n\r\n    public static new(htmlindex: number, model: DGraphElement[\"model\"], parentNodeID: DGraphElement[\"father\"],\r\n                      graphID: DGraphElement[\"graph\"], nodeID?: DGraphElement[\"id\"], size?: GraphSize): DVertex {\r\n        return new Constructors(new DVertex('dwc'), parentNodeID, true, undefined, nodeID)\r\n            .DPointerTargetable()\r\n            .DGraphElement(model, graphID, htmlindex)\r\n            .DVoidVertex(size || defaultVertexSize).DVertex().end();\r\n    }\r\n}\r\n\r\n@RuntimeAccessible('LVertex')\r\nexport class LVertex<Context extends LogicContext<any> = any, D = DVertex> extends LVoidVertex {\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // static singleton: LVertex;\r\n    // static logic: typeof LVertex;\r\n    // static structure: typeof DVertex;\r\n\r\n    // inherit redefine\r\n    __raw!: DVertex;\r\n    id!: Pointer<DVertex, 1, 1, LVertex>;\r\n    graph!: LGraph;\r\n    model?: LModelElement;\r\n    // isSelected: Dictionary<DocString<Pointer<DUser>>, boolean> = {};\r\n    isSelected(forUser?: Pointer<DUser>): boolean { return this.wrongAccessMessage(\"node.isSelected()\"); }\r\n    // containedIn?: LGraphElement;\r\n    subElements!: LGraphElement[];\r\n    zoom!: GraphPoint;\r\n    x!: number;\r\n    y!: number;\r\n    w!: number;\r\n    h!: number;\r\n    size!: GraphSize; // virtual, gets extracted from this. x and y are stored directly here as it extends GraphSize\r\n    isResized!: boolean;\r\n    // personal attributes\r\n    __isLVertex!: true;\r\n}\r\n\r\nRuntimeAccessibleClass.set_extend(DGraphElement, DVertex);\r\nRuntimeAccessibleClass.set_extend(LGraphElement, LVertex);\r\n\r\n@Leaf\r\n@RuntimeAccessible('DGraphVertex')\r\nexport class DGraphVertex extends DGraphElement { // MixOnlyFuncs(DGraph, DVertex)\r\n    // static _super1 = DGraph;\r\n    // static _super2 = DVertex;\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // static singleton: LGraphVertex;\r\n    // static logic: typeof LGraphVertex;\r\n    // static structure: typeof DGraphVertex;\r\n\r\n    // inherit redefine\r\n    id!: Pointer<DGraphVertex, 1, 1>;\r\n    graph!: Pointer<DGraph, 1, 1, LGraph>;\r\n    model!: Pointer<DModelElement, 1, 1, LModelElement>;\r\n    isSelected!: Dictionary<DocString<Pointer<DUser>>, boolean>;\r\n    // containedIn!: Pointer<DGraphElement, 0, 1, LGraphElement>;\r\n    subElements!: Pointer<DGraphElement, 0, 'N', LGraphElement>;\r\n    // from graph\r\n    zoom!: GraphPoint;\r\n    offset!: GraphPoint; // in-graph scrolling position\r\n\r\n    // from VoidVertex\r\n    x!: number;\r\n    y!: number;\r\n    w!: number;\r\n    h!: number;\r\n    isResized!: boolean;\r\n    // size!: GraphSize; // virtual\r\n    // from graph\r\n\r\n    // personal attributes\r\n    __isDVertex!: true;\r\n    __isDGraph!: true;\r\n    __isDGraphVertex!: true;\r\n\r\n    public static new(htmlindex: number, model: DGraph[\"model\"], parentNodeID: DGraphElement[\"father\"],\r\n                      graphID: DGraphElement[\"graph\"], nodeID?: DGraphElement[\"id\"], size?: GraphSize): DGraphVertex {\r\n        return new Constructors(new DGraphVertex('dwc'), parentNodeID, true, undefined, nodeID)\r\n            .DPointerTargetable().DGraphElement(model, graphID, htmlindex)\r\n            .DVoidVertex(size || defaultVertexSize).DVertex().DGraph().end();\r\n    }\r\n\r\n\r\n    /*\r\n        static init_constructor(thiss: DGraphVertex, isUser: boolean = false, nodeID: string | undefined, graphID: string | undefined, model: Pointer<DModel>): void {\r\n            DGraph.init_constructor(thiss, isUser, nodeID, graphID, model);\r\n    //isUser: boolean = false, nodeID: string | undefined, graphID: string, model?: Pointer<DModel>\r\n            DVertex.init_constructor(thiss, isUser, nodeID, graphID as string, model);\r\n            thiss.className = this.name;\r\n        }*/\r\n}\r\nclass LG extends LGraph{}\r\nclass LV extends LVertex{}\r\n\r\nconst Mixed = MixOnlyFuncs(LG, LV) as (typeof LG & typeof LV & typeof RuntimeAccessibleClass);\r\n@RuntimeAccessible('LGraphVertex')\r\n//@ts-ignore TS2510\r\nexport class LGraphVertex<Context extends LogicContext<any> = any, D extends DGraphVertex = any> extends Mixed { // MixOnlyFuncs(LGraph, LVertex)\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // static singleton: LGraphVertex;\r\n    // static logic: typeof LGraphVertex;\r\n    // static structure: typeof DGraphVertex;\r\n\r\n    // inherit redefine\r\n    __raw!: DGraphVertex;\r\n    id!: Pointer<DGraphVertex, 1, 1>;\r\n    graph!: LGraph;\r\n    model?: LModelElement;\r\n    // isSelected: Dictionary<DocString<Pointer<DUser>>, boolean> = {};\r\n    isSelected(forUser?: Pointer<DUser>): boolean { return this.wrongAccessMessage(\"node.isSelected()\"); }\r\n    // containedIn?: LGraphElement;\r\n    ///////////////////////////////////////// subElements!: LGraphElement[];\r\n    // from graph\r\n    zoom!: GraphPoint;\r\n    offset!: GraphPoint; // in-graph scrolling position\r\n    graphSize!: GraphSize; // internal size of the graph. can be huge even if the sub-graph is in a small window (scroll)\r\n\r\n    // from VoidVertex\r\n    x!: number;\r\n    y!: number;\r\n    w!: number;\r\n    h!: number;\r\n    isResized!: boolean;\r\n    size!: GraphSize; // virtual\r\n\r\n\r\n    // personal attributes\r\n    __isLVertex!: true;\r\n    __isLGraph!: true;\r\n    __isLGraphVertex!: true;\r\n}\r\n\r\nRuntimeAccessibleClass.set_extend(DGraph, DGraphVertex);\r\nRuntimeAccessibleClass.set_extend(DVertex, DGraphVertex);\r\nRuntimeAccessibleClass.set_extend(LGraph, LGraphVertex);\r\nRuntimeAccessibleClass.set_extend(LVertex, LGraphVertex);\r\n\r\n\r\n@RuntimeAccessible('DVoidEdge')\r\nexport class DVoidEdge extends DGraphElement {\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // static singleton: LVoidEdge;\r\n    // static logic: typeof LVoidEdge;\r\n    // static structure: typeof DVoidEdge;\r\n    id!: Pointer<DVoidEdge, 1, 1, LVoidEdge>;\r\n    graph!: Pointer<DGraph, 1, 1, LGraph>;\r\n    model!: Pointer<DModelElement, 0, 1, LModelElement>;\r\n    // isSelected: Dictionary<DocString<Pointer<DUser>>, boolean> = {};\r\n    isSelected!: Dictionary<DocString<Pointer<DUser>>, boolean>;\r\n    // containedIn!: Pointer<DGraphElement, 0, 1, LGraphElement>;\r\n    subElements!: Pointer<DGraphElement, 0, 'N', LGraphElement>;\r\n\r\n    // personal attributes\r\n    start!: Pointer<DGraphElement, 1, 1, LGraphElement>;\r\n    end!: Pointer<DGraphElement, 1, 1, LGraphElement>;\r\n    __isDVoidEdge!: true;\r\n\r\n    midPoints!: InitialVertexSize[]; // the logic part which instructs to generate the midnodes\r\n    midnodes!: Pointer<DEdgePoint, 1, 1, LEdgePoint>[]; // using subelements instead most of times\r\n\r\n    longestLabel?: DocString<\"function\">;\r\n    labels?: DocString<\"function\">;\r\n    anchorStart?: string;\r\n    anchorEnd?: string;\r\n\r\n    isExtend!: boolean;\r\n    isReference!: boolean;\r\n    isValue!: boolean;\r\n    isDependency!: boolean;\r\n    // endFollow!: boolean; they became derived attributes from static properties\r\n    // startFollow!: boolean;\r\n\r\n    static isFollowingCoords: GraphPoint;\r\n\r\n    public static new(htmlindex: number, model: DGraph[\"model\"]|null|undefined, parentNodeID: DGraphElement[\"father\"], graphID: DGraphElement[\"graph\"],\r\n                      nodeID: DGraphElement[\"id\"]|undefined, start: DGraphElement[\"id\"], end: DGraphElement[\"id\"],\r\n                      longestLabel?: DEdge[\"longestLabel\"], labels?: DEdge[\"labels\"]): DEdge {\r\n        return new Constructors(new DEdge('dwc'), parentNodeID, true, undefined, nodeID)\r\n            .DPointerTargetable()\r\n            .DGraphElement(model, graphID, htmlindex)\r\n            .DVoidEdge(start, end, longestLabel, labels).end();\r\n    }\r\n    public static new2(model: DGraph[\"model\"]|null|undefined, parentNodeID: DGraphElement[\"father\"], graphID: DGraphElement[\"graph\"],\r\n                       nodeID: DGraphElement[\"id\"]|undefined, start: DGraphElement[\"id\"], end: DGraphElement[\"id\"], setter:((d: DEdge) => any)): DEdge {\r\n        return new Constructors(new DEdge('dwc'), parentNodeID, true, undefined, nodeID)\r\n            .DPointerTargetable()\r\n            .DGraphElement(model, graphID)\r\n            .DVoidEdge(start, end).end(setter);\r\n    }\r\n}\r\n/*\r\n@RuntimeAccessible\r\nexport class MidPoint{\r\n    readonly id: string; // not really a pointer, it's not on store.\r\n    x?: number; y?: number;\r\n    readonly w?: number; // if it's modified it's not ever here (initial size) but on DEdgePoint that is a Node.\r\n    readonly h?: number;/*\r\n    constructor2(x: number=5, y: number=5, w: number=5, h: number=5) {\r\n        this.x = x;\r\n        this.y = y;\r\n        this.w = w;\r\n        this.h = h;\r\n    }* /\r\nconstructor(id: string, w: number=5, h: number=5) {\r\n    this.id = id;\r\n    this.w = w;\r\n    this.h = h;\r\n}\r\n}*/\r\n@RuntimeAccessible('EdgeSegment')\r\nexport class EdgeSegment{\r\n    index: number;\r\n    prev: EdgeSegment | undefined;\r\n    start: segmentmaker;\r\n    bezier: segmentmaker[];\r\n    end: segmentmaker;\r\n    length!: number;\r\n    // if EdgeSegment is changed, shouldcomponentupdate needs update too: search in IDE for \"5khi2\"\r\n    d!: string;\r\n    dpart!: string; //  a segment of the whole path\r\n    m!: number; // m coefficient of the line between start and end.\r\n    rad!: number; // for head and tails: radian angle of the segment.\r\n    radLabels!: number; // for labels: it flips the angle when it's < PI/2 so the text is never upside down\r\n\r\n    isLongest!: boolean;\r\n    label!: PrimitiveType | JSX.Element | undefined;\r\n    svgLetter: EdgeBendingMode;\r\n    /*constructor(label: PrimitiveType|undefined, length: number, startp: GraphPoint, endp: GraphPoint, start: LGraphElement, end: LGraphElement,\r\n                bezierpts: GraphPoint[], mid: LGraphElement[],\r\n                svgLetter: EdgeBendingMode, index: number, fillMode: MidNodeHandling) {\r\n        this.label = label;\r\n        this.length = length;\r\n        this.length = length;\r\n        this.startp = startp;\r\n        this.bezierp = bezierpts;\r\n        this.endp = endp;\r\n        this.start = start;\r\n        this.end = end;\r\n        this.mid = mid;\r\n    }*/\r\n    constructor(start: segmentmaker, mid: segmentmaker[], end: segmentmaker,\r\n                svgLetter: EdgeBendingMode, gapMode: EdgeGapMode,\r\n                index: number, prevSegment: EdgeSegment | undefined){\r\n        // console.log(\"segmentmaker:\", arguments, ((start.ge?.model as any)?.name)+\" ---> \" + ((end.ge?.model as any)?.name));\r\n        this.start = start;\r\n        this.bezier = mid;\r\n        this.end = end;\r\n        this.index = index;\r\n        this.prev = prevSegment;\r\n        //this.segments = segments;\r\n        // the idea: forbid all T and S or transform them in C, Q by calculating and manually adding their mirrored bezier pts\r\n        // if (svgLetter[1]) svgLetter = (svgLetter[0]) as any;\r\n        if (svgLetter === EdgeBendingMode.Bezier_QT) {\r\n            this.svgLetter = EdgeBendingMode.Bezier_QT[0] as any as EdgeBendingMode;\r\n            // this.svgLetter = (index === 0 ? EdgeBendingMode.Bezier_QT[0] : EdgeBendingMode.Bezier_QT[1]) as any as EdgeBendingMode;\r\n            this.addBezierPoint();\r\n        } else\r\n        if (svgLetter === EdgeBendingMode.Bezier_CS) {\r\n            this.svgLetter = EdgeBendingMode.Bezier_CS[0] as any as EdgeBendingMode;\r\n            // this.svgLetter = (index === 0 ? EdgeBendingMode.Bezier_CS[0] : EdgeBendingMode.Bezier_CS[1]) as any as EdgeBendingMode;\r\n            this.addBezierPoint();\r\n        }\r\n        else this.svgLetter = svgLetter;\r\n\r\n        // fix if amount of bezier pts is invalid for current letter\r\n        switch (this.svgLetter) {\r\n            case EdgeBendingMode.Line:\r\n            case EdgeBendingMode.Bezier_quadratic:\r\n                if (this.bezier.length >= 1) break;\r\n                else this.svgLetter = EdgeBendingMode.Line;\r\n                break;\r\n            case EdgeBendingMode.Bezier_cubic:\r\n                if (this.bezier.length >= 2) break;\r\n                else if (this.bezier.length >= 1) this.svgLetter = EdgeBendingMode.Bezier_quadratic;\r\n                else this.svgLetter = EdgeBendingMode.Line;\r\n                break;\r\n            case EdgeBendingMode.Elliptical_arc:\r\n                if (this.bezier.length >= 3) break;\r\n                else this.svgLetter = EdgeBendingMode.Line; // straight to end ignoring midpoints that are NOT coordinates when using elliptical arc.\r\n                break;\r\n            default:\r\n            //case EdgeBendingMode.Bezier_quadratic_mirrored as string:\r\n            //case EdgeBendingMode.Bezier_cubic_mirrored as string: // translated to Q or C by adding mirrored bezier points explicitly\r\n            case EdgeBendingMode.Bezier_QT:\r\n            case EdgeBendingMode.Bezier_CS: // translated to Q or C by sending the right letter to each segment\r\n                Log.exDevv(\"this svg letter should not appear here\", this.svgLetter);\r\n                break;\r\n        }\r\n    }\r\n    addBezierPoint(): void {\r\n        let prev: EdgeSegment | undefined = this.prev;\r\n        if (!prev) return;\r\n        let prevedgemakerbezier: segmentmaker = (prev.bezier[prev.bezier.length-1] || prev.start);\r\n        let mirroredBezier: segmentmaker = {...prevedgemakerbezier,\r\n            pt: EdgeSegment.invertLastBezierPt(prevedgemakerbezier.pt, prev.end.pt),\r\n            uncutPt: EdgeSegment.invertLastBezierPt(prevedgemakerbezier.uncutPt, prev.end.uncutPt),\r\n        };\r\n        this.bezier = [mirroredBezier, ...this.bezier];\r\n        // always only 1 assumed pt both in cubic and quadratic.\r\n        // let next: this | undefined = this.segments[this.index+1];\r\n        // EdgeSegment.invertLastBezierPt((next.mid[1] || next.end).pt, next.start.pt);\r\n    }\r\n\r\n    makeD(index: number, gapMode: EdgeGapMode): string {\r\n        this.m = GraphPoint.getM(this.start.pt, this.end.pt);\r\n        this.rad = Geom.mToRad(this.m, this.start.pt, this.end.pt);\r\n        this.radLabels = Math.atan(this.m);\r\n\r\n        let svgLetter = this.svgLetter; // caller makes sure to pass right letter and resolve \"CS\" mixed letters. // this.bendingModeToLetter(bendingMode, index);\r\n        // caller sends inverted pts as normal coords\r\n        // let invertedBezPt = lastSegment && EdgeSegment.invertLastBezierPt(lastSegment.midp[lastSegment.mid.length-1] || lastSegment.startp, lastSegment.endp);\r\n        switch (this.svgLetter.length) {\r\n            case 2:\r\n                return Log.exDevv(\"mixed letters are not allowed and should have been resolved to single svg letters before here, found:\" + svgLetter);\r\n            /*return Log.exDevv(\"dev problem to fix:\\n\" +\r\n            \"the mirrored mode requires the first one to have explicit non-mirrored mode?? like M, C a1 a2 a3, S a1, S a1, S a1\\n\" +\r\n            \"So all segments with mixed modes needs to extract the last bezier point (penultimate coordinate) from previous segments, mirror it and insert in midp[0]\");*/\r\n            case 1:\r\n                let bezierpts = [...this.bezier.map( b => b.pt), this.end.pt];\r\n                let finalpart = svgLetter + \" \" + bezierpts.map((p)=> p.x + \" \" + p.y).join(\", \");\r\n                this.dpart = \"M \" + this.start.pt.x + \" \" + this.start.pt.y + \", \" + finalpart;\r\n                let bezierptsUncut = [...this.bezier.map( b => b.uncutPt), this.end.pt]; // uncutPt exist for start and end too, but i want to use the cut one for those. or edgehead is off\r\n                let finalpartUncut = svgLetter + \" \" + bezierptsUncut.map((p)=> p.x + \" \" + p.y).join(\", \");\r\n                this.d = (index === 0 ? \"M\" + this.start.pt.x + \" \" + this.start.pt.y + \", \" : \"\") + finalpartUncut;\r\n\r\n                //midp = [this.startp, ...this.midp];\r\n                // d = M sp X mp2 ep // X = custom letter\r\n                // dpart = T sp X mp2 ep // S = S if X = C,\r\n                // sp is the startingpoint from the prev node, which might be != from endpoint of last node if last node have w>0 && h>0\r\n                // so i'm \"filling\" the gap with a T, or L arc wich can use only 1 parameter (they are the only 1-parameter arcs)\r\n                // if (this.prev && this.prev.end.pt.equals(this.start.pt)) gapMode = EdgeGapMode.average; // if the 2 points coincide, i use any 1 of the gapmodes that are continuous\r\n                /*switch (gapMode){\r\n                    case EdgeGapMode.center:\r\n                    case EdgeGapMode.average:\r\n                        // continuous gap modes. they only differ in how the \"joining\" point is found, but not in how they behave after that.\r\n                        /*\r\n                        if (index === 0) {\r\n                             startletter = \"M \";\r\n                         }\r\n                         else {\r\n                             switch (svgLetter) {\r\n                                 case SvgLetter.A: case SvgLetter.C: case SvgLetter.S: case SvgLetter.Q: case SvgLetter.T: default:\r\n                                     startletter = SvgLetter.T + \" \"; break;\r\n                                 case SvgLetter.L: case SvgLetter.M:\r\n                                     startletter = SvgLetter.L + \" \"; break;\r\n                             }\r\n                         }* /\r\n                        if (index) {\r\n                            this.d = finalpart;\r\n                        }\r\n                        else { this.d = this.dpart; }\r\n                        break;\r\n                    case EdgeGapMode.gap:\r\n                    case EdgeGapMode.autoFill:\r\n                    case EdgeGapMode.lineFill:\r\n                    case EdgeGapMode.arcFill:\r\n                        // the filling itself is done by another segment (solving svg letter and simulating i=0), so i treat it as a gap.\r\n                        this.d = this.dpart;\r\n                        break;\r\n                    default:\r\n                        Log.exDevv(\"unexpected EdgeGapMode:\" + gapMode, {gapMode});\r\n                }*/\r\n                break;\r\n            default: return Log.exDevv(\"unexpected bending mode length:\" + this.svgLetter + \" or fillMode: \" + gapMode, {bendingMode: this.svgLetter, index, gapMode});\r\n        }\r\n\r\n        //using\r\n        /*\r\n        88\r\n\r\n        // d should not have M set (except for segments[0]\r\n        // dpart have M abd beed to add explicit points for \"mirroring\" and transforming bezier quadratic mirrored in bezier quadratic normal etc.\r\n        //88 problem: the mirrored mode requires the first one to have explicit nonmirrored mode?? like M, C a1 a2 a3, S a1, S a1, S a1 .... ?\r\n        in any case the % letter part is wrong because it needs to subtract first element used for M*/\r\n        return this.d;\r\n    }\r\n\r\n    static invertLastBezierPt(bezier: GraphPoint, end: GraphPoint): GraphPoint{\r\n        // vector = bezier - end\r\n        // end + vector = bezier\r\n        // end - vector = inverted bezier? = 2*end-bezier\r\n        let vector = bezier.subtract(end, true);\r\n        return end.subtract(vector, true);\r\n    }\r\n\r\n    calcLength(): void {\r\n        this.length = this.start.pt.distanceFromPoint(this.end.pt);\r\n    }\r\n}\r\n\r\nexport class EdgeFillSegment extends EdgeSegment{\r\n    public static cname: string = \"EdgeFillSegment\";\r\n    makeD(index: number, gapMode: EdgeGapMode): string {\r\n        // if (gapMode === EdgeGapMode.autoFill) { gapMode = this.svgLetter === EdgeBendingMode.Line ? EdgeGapMode.lineFill : EdgeGapMode.arcFill; }\r\n        switch (gapMode) {\r\n            case \"closest\" as any:// EdgeGapMode.closest:\r\n            case EdgeGapMode.center:\r\n            case EdgeGapMode.average:\r\n            case EdgeGapMode.gap:\r\n                return \"\"; // should not have filler arcs\r\n            default:\r\n                /*\r\n            case EdgeGapMode.autoFill as any:\r\n            case EdgeGapMode.lineFill:\r\n                this.bezier = [];\r\n                this.svgLetter = EdgeBendingMode.Line;\r\n                return super.makeD(index, gapMode);\r\n            case EdgeGapMode.arcFill:*/\r\n                this.svgLetter = this.svgLetter[0] as EdgeBendingMode;\r\n                if (this.svgLetter === \"Q\") this.bezier = this.bezier.length ? [this.bezier[0]] : [];\r\n                return super.makeD(index, gapMode);\r\n        }\r\n    }\r\n}\r\nexport type labelfunc = (e:LVoidEdge, segment: EdgeSegment, allNodes: LEdge[\"allNodes\"], allSegments: EdgeSegment[]) => PrimitiveType;\r\nexport type labeltype = orArr<labelfunc | PrimitiveType>;\r\n\r\ntype segmentmaker = {size: GraphSize, view: LViewElement, ge: LGraphElement, pt: GraphPoint, uncutPt: GraphPoint};\r\n@RuntimeAccessible('LVoidEdge')\r\nexport class LVoidEdge<Context extends LogicContext<DVoidEdge> = any, D extends DEdge = DEdge> extends LGraphElement {\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // static singleton: LVoidEdge;\r\n    // static logic: typeof LVoidEdge;\r\n    // static structure: typeof DVoidEdge;\r\n    __raw!: DVoidEdge;\r\n    id!: Pointer<DVoidEdge, 1, 1, LVoidEdge>;\r\n    graph!: LGraph;\r\n    model?: LModelElement;\r\n    // isSelected: Dictionary<DocString<Pointer<DUser>>, boolean> = {};\r\n    isSelected(forUser?: Pointer<DUser>): boolean { return this.wrongAccessMessage(\"node.isSelected()\"); }\r\n    // containedIn?: LGraphElemnt;\r\n    subElements!: LGraphElement[];\r\n    __isLVoidEdge!: true;\r\n    midPoints!: InitialVertexSize[]; // the logic part which instructs to generate the midnodes\r\n    midnodes!: LEdgePoint[];\r\n    edge!: LVoidEdge; // returns self. useful to get edge from edgePoints without triggering error if you are already on edge.\r\n    __info_of__edge: Info = {type:\"?LEdge\", txt:\"returns this if called on an edge, the containing edge if called on an EdgePoint, undefined otherwise.\"}\r\n\r\n    isExtend!: boolean;\r\n    isReference!: boolean;\r\n    isValue!: boolean;\r\n    isDependency!: boolean;\r\n\r\n/*\r\nreplaced by startPoint\r\n    edgeStart!: GraphPoint;\r\n    edgeStart_inner!: GraphPoint;\r\n    edgeStart_outer!: GraphPoint;\r\n    __info_of__edgeStart: Info = {type: \"GraphPoint\", txt: \"Same as edgeStart_outer.\"}\r\n    __info_of__edgeStart_outer: Info = {type: \"GraphPoint\",\r\n     txt: \"Where the edge should start his path, in coordinates relative at the root Graph.\r\n     <br>Computed by combining the anchor offset option in View and the size of the starting node.\"}\r\n    __info_of__edgeStart_inner: Info = {type: \"GraphPoint\",\r\n     txt: \"Where the edge should start his path, in coordinates relative at the most nested Graph.\r\n     <br>Computed by combining the anchor offset option in View and the size of the starting node.\"}\r\n    edgeEnd!: GraphPoint;\r\n    edgeEnd_inner!: GraphPoint;\r\n    edgeEnd_outer!: GraphPoint;\r\n    __info_of__edgeEnd: Info = {type: \"GraphPoint\", txt: \"Same as edgeEnd_outer.\"}\r\n    __info_of__edgeEnd_outer: Info = {type: \"GraphPoint\",\r\n     txt: \"Where the edge should end his path, in coordinates relative at the root Graph.\r\n     <br>Computed by combining the anchor offset option in View and the size of the starting node.\"}\r\n    __info_of__edgeEnd_inner: Info = {type: \"GraphPoint\",\r\n     txt: \"Where the edge should end his path, in coordinates relative at the most nested Graph.\r\n     <br>Computed by combining the anchor offset option in View and the size of the starting node.\"}\r\n*/\r\n\r\n    allNodes!: [LGraphElement, ...Array<LEdgePoint>, LGraphElement];\r\n    __info_of__allNodes: Info = {type: \"[LGraphElement, ...Array<LEdgePoint>, LGraphElement]\", txt: <span>first element is this.start. then all this.midnodes. this.end as last element</span>};\r\n\r\n\r\n    label!: this[\"longestLabel\"];  // should never be read change their documentation in write only. their values is \"read\" in this.segments\r\n    longestLabel!: labeltype;\r\n    labels!: labeltype;\r\n    __info_of__longestLabel: Info = {label:\"Longest label\", type:\"function(edge)=>string\",\r\n        readType: \"(edge:LEdge, segment: EdgeSegment, allNodes: DGraphElement[], allSegments: EdgeSegment[]) => PrimitiveType\",\r\n        writeType:\"string\",\r\n        txt: <span>Label assigned to the longest path segment.</span>}\r\n    __info_of__label: Info = {type: \"\", txt: <span>Alias for longestLabel</span>};\r\n    __info_of__labels: Info = {label:\"Multiple labels\", type: \"same type as longestLabel | longestLabel[]\",\r\n        writeType: \"string\",\r\n        txt: <span>Instructions to label to multiple or all path segments in an edge</span>\r\n    };\r\n\r\n\r\n    start!: LGraphElement;\r\n    __info_of__start: Info = {type: \"LVertex\", txt:\"the source point of the edge.\"}\r\n    get_start(c: Context): this['start'] { return LPointerTargetable.fromPointer(c.data.start); }\r\n    set_start(val: Pack1<LGraphElement>, c: Context): boolean {\r\n        let ptr = Pointers.from(val);\r\n        if (!ptr) { Log.exx(\"attempting to set an invalid LEdge.start: \" + ptr, {ptr, data: c.data}); return true; }\r\n        if (ptr !== c.data.start) SetFieldAction.new(c.data.id, 'start', ptr, '', true);\r\n        return true;\r\n    }\r\n    end!: LGraphElement;\r\n    __info_of__end: Info = {type: \"LVertex\", txt:\"the terminal point of the edge.\"}\r\n    get_end(c: Context): this['end'] { return LPointerTargetable.fromPointer(c.data.end); }\r\n    set_end(val: Pack1<LGraphElement>, c: Context): boolean {\r\n        let ptr = Pointers.from(val);\r\n        if (!ptr) { Log.exx(\"attempting to set an invalid LEdge.end: \" + ptr, {ptr, data: c.data}); return true; }\r\n        if (ptr !== c.data.end) SetFieldAction.new(c.data.id, 'end', ptr, '', true);\r\n        return true;\r\n    }\r\n\r\n\r\n    get_label(c: Context): this[\"longestLabel\"] { return this.get_longestLabel(c); }\r\n    set_label(val: DVoidEdge[\"longestLabel\"], c: Context): boolean { return this.set_longestLabel(val, c); }\r\n    get_longestLabel(c: Context): this[\"longestLabel\"] {\r\n        return transientProperties.node[c.data.id].longestLabel;\r\n        /*if (transientProperties.node[c.data.id].longestLabel !== undefined) return transientProperties.node[c.data.id].longestLabel;\r\n        else return transientProperties.view[c.data.view].longestLabel;*/\r\n    }\r\n    get_labels(c: Context): this[\"labels\"] {\r\n        return transientProperties.node[c.data.id].labels;\r\n        /*if (transientProperties.node[c.data.id].labels !== undefined) return transientProperties.node[c.data.id].labels;\r\n        else return transientProperties.view[c.data.view].labels;*/\r\n    }\r\n    set_longestLabel(val: DVoidEdge[\"longestLabel\"], c: Context): boolean {\r\n        Log.exDevv('Edge.labels are disabled, pass it through props instead');\r\n        if (val === c.data.longestLabel) return true;\r\n        TRANSACTION(()=>{\r\n            SetFieldAction.new(c.data, \"longestLabel\", val);\r\n            SetRootFieldAction.new(\"NODES_RECOMPILE_longestLabel+=\", c.data.id);\r\n        });\r\n        return true;\r\n    }\r\n    set_labels(val: DVoidEdge[\"labels\"], c: Context): boolean {\r\n        Log.exDevv('Edge.labels are disabled, pass it through props instead');\r\n        if (val === c.data.labels) return true;\r\n        TRANSACTION(()=>{\r\n            SetFieldAction.new(c.data, \"labels\", val);\r\n            SetRootFieldAction.new(\"NODES_RECOMPILE_labels+=\", c.data.id);\r\n        });\r\n        return true; }\r\n\r\n    public headPos_impl(c: Context, isHead: boolean, headSize0?: GraphPoint, segment0?: EdgeSegment, zoom0?: GraphPoint): GraphSize & {rad: number} {\r\n        let segment: EdgeSegment = segment0 || this.get_segments(c).segments[0];\r\n        // let v: LViewElement = this.get_view(c);\r\n        let tmp: any = headSize0 || (isHead ? this.get_view(c).edgeHeadSize : this.get_view(c).edgeTailSize);\r\n        if (!tmp || tmp.x === 0 || tmp.y === 0) {\r\n            // head or tail missing\r\n            tmp = new GraphSize(0, 0, 0, 0);\r\n            tmp.rad = 0;\r\n            return tmp;\r\n        }\r\n        let zoom: GraphPoint = zoom0 || this.get_graph(c).zoom;// ownZoom or cumulativeZoom?\r\n        let headPos: GraphSize & {rad: number} = (new GraphSize(0, 0, tmp.x, tmp.y) as any); //.multiply({w:zoom.x, h:zoom.y});\r\n        let useBezierPoints = true;\r\n        let start: GraphPoint, end: GraphPoint;\r\n        let m: number;\r\n        if (useBezierPoints) {\r\n            if (isHead) {\r\n                start = segment.end.pt;\r\n                end = (segment.bezier[segment.bezier.length - 1] || segment.start).pt;\r\n            } else {\r\n                start = segment.start.pt;\r\n                end = (segment.bezier[0] || segment.end).pt;\r\n            }\r\n            m = GraphPoint.getM(start, end);\r\n        } else {\r\n            if (isHead) { start = segment.end.pt; end = segment.start.pt; }\r\n            else { start = segment.start.pt; end = segment.end.pt; }\r\n            m = segment.m;\r\n        }\r\n        // first find the center of where it should be positioned\r\n        // let center: GraphPoint;\r\n        // let distance: number = Math.sqrt(headPos.w*headPos.w + headPos.h*headPos.h);\r\n        // let isVertical = m >=1 ;\r\n        let x4headsize = new GraphSize(start.x - headPos.w, start.y - headPos.h, headPos.w*2, headPos.h*2);\r\n        // first intersection is segment origin. second is found with the box containing all possible edgeHead positions that touch the startPoint\r\n        // (doing x4 his shape and placing 4 \"rectangles\" all around startPoint) to cover all possible segment directions.\r\n        // or finding first direction (vertical if m >1, horizontal if m<0) and vector direction and intersecting with only the \"correct\" placed edgeHead rectangle.\r\n        // then the intersection will likely not fall on the extreme angle of EdgeHead and i can re-center edgeHead\r\n        // so that first and second intersections are equal spaced with the center segment\r\n        let secondIntersection: GraphPoint | undefined;\r\n        let segmentDistance = start.distanceFromPoint(end);\r\n        if (segmentDistance <= Math.sqrt(headPos.w**2 + headPos.h**2)){\r\n            let safeDistance = Math.max(headPos.w, headPos.h)*5;\r\n            end = new GraphPoint( end.y + safeDistance, end.y + m * safeDistance); // move the point away so it doesn't intersect anymore. i just need direction\r\n            // too small to fit edgeHead, i simply put it centered on the whole segment\r\n            // secondIntersection = end;\r\n        }\r\n        secondIntersection = GraphSize.closestIntersection(x4headsize, start, end, undefined);\r\n        if (!secondIntersection) {\r\n           return Log.exDevv(\"failed to intersect edge head\", {x4headsize, segment, headPos, c, start, end, useBezierPoints});\r\n        }\r\n        tmp = secondIntersection.add(start, false).divide(2); // center of edgehead\r\n        headPos.x = tmp.x - headPos.w / 2; // tl corner\r\n        headPos.y = tmp.y - headPos.h / 2; // tl corner\r\n        headPos.rad = Geom.mToRad(m, start, end);\r\n        /*\r\n        devo trovare la distanza tra il centro dell'egeHead e il punto di inizio in termini assoluti, così tramite M trovo distanza in x e y. o trovarla in altro modo\r\n        if (segment.m === Number.POSITIVE_INFINITY || segment.m === Number.NEGATIVE_INFINITY) {\r\n            center = segment.start.pt.add({x:0, y: distance}, true); }\r\n        else { center = segment.start.pt.add({x:segment.m*headPos.w/2, y:segment.m*headPos.h/2\r\n         this is wrong, cannot be the same for x and y, i should invert the line equation for x?}, true); }\r\n        headPos.x = center.x - headPos.w / 2;\r\n        headPos.y = center.y - headPos.h / 2;*/\r\n        // console.log(\"head intersected\", {headPos, secondIntersection, x4headsize, segment, c, start, end, useBezierPoints});\r\n\r\n        return headPos;\r\n    }\r\n\r\n    public headPos(headSize0?: GraphPoint, segment0?: EdgeSegment, zoom0?: GraphPoint): GraphSize & {rad: number} {\r\n        return this.wrongAccessMessage(\"This is not headPos() implementation. it is just for typings. use the getter\"); }\r\n    public tailPos(headSize0?: GraphPoint, segment0?: EdgeSegment, zoom0?: GraphPoint): GraphSize & {rad: number} {\r\n        return this.wrongAccessMessage(\"This is not tailPos() implementation. it is just for typings. use the getter\"); }\r\n    protected get_headPos(c: Context): this[\"headPos\"] {\r\n        return (headSize?: GraphPoint, segment?: EdgeSegment, zoom?: GraphPoint) => this.headPos_impl(c, true, headSize, segment, zoom); }\r\n    protected get_tailPos(c: Context): this[\"tailPos\"] {\r\n        return (headSize?: GraphPoint, segment?: EdgeSegment, zoom?: GraphPoint) => this.headPos_impl(c, false, headSize, segment, zoom); }\r\n    protected get_allNodes(c: Context): this[\"allNodes\"] { return [this.get_start(c), ...this.get_midnodes(c), this.get_end(c)]; }\r\n\r\n    protected get_edge(c: Context): this{ return c.proxyObject as this; }\r\n    protected set_edge(v: any, c: Context): false { return this.cannotSet(\"edge field, on an edge element\"); }\r\n    protected get_midPoints(c: Context):this[\"midPoints\"] { return c.data.midPoints; }\r\n    public addMidPoint(v: this[\"midPoints\"][0]): boolean { return this.wrongAccessMessage(\"addMidPoint\"); }\r\n    protected get_addMidPoint(c: Context): (v: this[\"midPoints\"][0]) => boolean { return (v:this[\"midPoints\"][0]) => this.impl_addMidPoints(v, c); }\r\n    protected set_midPoints(val: this[\"midPoints\"], c: Context): boolean {\r\n        return SetFieldAction.new(c.data.id, \"midPoints\", val, undefined, false);\r\n    }\r\n    protected impl_addMidPoints(val: this[\"midPoints\"][0], c: Context): boolean {\r\n        return SetFieldAction.new(c.data.id, \"midPoints\", val, '+=', false);\r\n    }\r\n    protected get_label_impl(c: Context, segment: EdgeSegment, nodes: this[\"allNodes\"], segments: EdgeSegment[]): PrimitiveType | undefined {\r\n        let key: \"longestLabel\" | \"labels\" = segment.isLongest ? \"longestLabel\" : \"labels\"; // : keyof this\r\n        // if (isLongestSegment) return this.get_longestLabel_impl(d, l, nodes, index):\r\n        const d = c.data;\r\n        const l = c.proxyObject;\r\n        let labelmaker: any = (this as any)['get_'+key](c);\r\n        let labelmakerfunc: labelfunc = labelmaker as any;\r\n        // let lastSeg = segments[i-1];\r\n        switch (typeof labelmaker) {//nb{}[]<>\r\n            case \"number\":\r\n            case \"undefined\":\r\n            case \"boolean\":\r\n            case \"string\": return labelmaker;\r\n            // case \"function\": return nodes.map( (o, i) => d.labels(l, nodes, i)).slice(0, nodes.length-1);\r\n            // (e:LVoidEdge, segment: EdgeSegment, allNodes: LEdge[\"allNodes\"], allSegments: EdgeSegment[]) => PrimitiveType\r\n            case \"function\": return labelmakerfunc(l, segment, nodes, segments);\r\n            default: break;\r\n            case \"object\":\r\n                if (labelmaker === null) return null;\r\n                if (!Array.isArray(labelmaker)) break;\r\n                let elem = (labelmaker as PrimitiveType[])[segment.index % labelmaker.length];\r\n                if (typeof elem === \"function\") return (elem as labelfunc)(l, segment, nodes, segments);\r\n                return elem;\r\n        }\r\n        Log.exx(\"edge labels invalid type, must be a primitive value, a function or an array of such.\", {labelmaker, key, d});\r\n        return undefined;\r\n    }/*\r\n    private get_label_impl_old(d: DVoidEdge, l: LVoidEdge, nodes:this[\"allNodes\"], index: number, longestlabelindex?: number): PrimitiveType {\r\n        if (d.longestLabel !== undefined && index === longestlabelindex) return this.get_longestLabel_impl(d, l, nodes, index);\r\n        switch (typeof d.labels) {//nb{}[]<>\r\n            case \"number\":\r\n            case \"undefined\":\r\n            case \"boolean\":\r\n            case \"string\": return d.labels;\r\n            // case \"function\": return nodes.map( (o, i) => d.labels(l, nodes, i)).slice(0, nodes.length-1);\r\n            case \"function\": return d.labels(l, nodes[index], nodes[index+1], index, nodes);\r\n            default: break;\r\n            case \"object\": if (!Array.isArray(d.labels)) break;\r\n            if (typeof d.labels[0] === \"function\") return (d.labels as any)[index % d.labels.length](l, nodes[index], nodes[index+1], index, nodes);\r\n            return (d.labels as PrimitiveType[])[index % d.labels.length];\r\n        }\r\n        Log.exx(\"edge labels invalid type, must be a primitive value, a function or an array of such.\", d.labels);\r\n    }*/\r\n\r\n    __info_of__startPoint: Info = {type: \"GraphPoint\", txt:<span>startPoint of this.start (element originating the edge). Defaults in outer coordinates.</span>};\r\n    __info_of__endPoint: Info = {type: \"GraphPoint\", txt:<span>endPoint of this.end (element originating the edge). Defaults in outer coordinates.</span>};\r\n    public get_startPoint(context: Context): GraphPoint{ return this.get_startPoint_Outer(context); }\r\n    public get_endPoint(context: Context): GraphPoint{ return this.get_endPoint_Outer(context); }\r\n    public get_startPoint_Outer(c: Context): GraphPoint{\r\n        // console.log(\"get_edgeStart_Outer\", {out:this.get_outerGraph(c), pos:this.get_startPoint_inner(c), inner:this.get_start(c).innerGraph});\r\n        return this.get_outerGraph(c).translateSize(this.get_startPoint_inner(c), this.get_start(c).innerGraph);\r\n    }\r\n    public get_endPoint_Outer(c: Context): GraphPoint{\r\n        // console.log(\"get_edgeEnd_Outer\", {out:this.get_outerGraph(c), pos:this.get_endPoint_inner(c), inner:this.get_end(c).innerGraph});\r\n        return this.get_outerGraph(c).translateSize(this.get_endPoint_inner(c), this.get_end(c).innerGraph);\r\n    }\r\n\r\n    public get_startPoint_inner(c: Context): GraphPoint{ return this.get_edgeStartEnd_inner(c, true); }\r\n    public get_endPoint_inner(c: Context): GraphPoint{ return this.get_edgeStartEnd_inner(c, false); }\r\n    private get_edgeStartEnd_inner(c: Context, isStart: boolean): GraphPoint{ return isStart ? this.get_start(c).startPoint : this.get_end(c).endPoint; }\r\n    segments!: {all: EdgeSegment[], segments: EdgeSegment[], fillers: EdgeSegment[], head: GraphSize&{rad:number}, tail: GraphSize&{rad:number}};\r\n    segments_inner!: {all: EdgeSegment[], segments: EdgeSegment[], fillers: EdgeSegment[], head: GraphSize&{rad:number}, tail: GraphSize&{rad:number}};\r\n    segments_outer!: {all: EdgeSegment[], segments: EdgeSegment[], fillers: EdgeSegment[], head: GraphSize&{rad:number}, tail: GraphSize&{rad:number}};\r\n    __info_of__segments: Info = {type: \"{all:T, segments:T, fillers:T, head: GraphSize&{rad:number}, tail: as head} where T is EdgeSegment\",\r\n        txt:<span>Collection of segments connecting in order vertex and EdgePoint without intersecting their area, aimed to be rendered in svg path.\r\n            <br/>fillers are arcs generated by view.edgeGapMode being autofill, arcfill or linefill.\r\n            <br/>length of this.segments array is Math.ceil(allNodes.length / svg_letter_size) specified on view.\r\n            <br/>\"head\" and \"tail\" are the position and angle of eventual edge decorators. Refer to this.headPos documentation.</span>}\r\n\r\n    private svgLetterSize(s: string, addM: boolean = true, doublingMidPoints: boolean = true): {first:number, others: number} {\r\n        let ret: {first:number, others: number};\r\n        switch (s) {\r\n            default: ret = Log.exDevv(\"unexpected svg path letter: \\\"\" + s + \"\\\"\", s); break;\r\n            case EdgeBendingMode.Line:\r\n            //case EdgeBendingMode.Bezier_quadratic_mirrored:\r\n                ret = {first:1, others:1}; break;\r\n            case EdgeBendingMode.Bezier_quadratic:\r\n            //case EdgeBendingMode.Bezier_cubic_mirrored:\r\n                ret = {first:2, others:2}; break;\r\n            case EdgeBendingMode.Bezier_cubic: ret = {first:3, others:3}; break;\r\n            case EdgeBendingMode.Elliptical_arc: ret = {first:4, others:4}; break;\r\n\r\n            case EdgeBendingMode.Bezier_QT: ret = {first:2, others:1}; break;\r\n            case EdgeBendingMode.Bezier_CS: ret = {first:3, others:2}; break;\r\n        }\r\n\r\n        // account for the fact that every midpoint is listed twice: at anchor start and anchor end.\r\n        if (doublingMidPoints) {\r\n            // removing last point (first is already excluded because addM didn't trigger yet)\r\n            // , the remaining are midpoints to double. then i add it back\r\n            ret.first = (ret.first - 1) * 2 + 1;\r\n            ret.others = (ret.others - 1) * 2 + 1;\r\n        }\r\n\r\n        // account for the first M letter\r\n        //    (if the segment is not mode.gap or first, M coord still exist in segment but are ignored)\r\n        if (addM) {\r\n            ret.first += 1;\r\n            ret.others += 1;\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    // outer should be a redundant param and always == true\r\n    private get_points_impl(allNodes: LGraphElement[], outer: boolean, c:Context): segmentmaker[] {\r\n        function getAnchorOffset(size: GraphSize, offset: GraphPoint, isPercentage: boolean, $factor: number = 100) {\r\n            if (!size) size = new GraphSize(0, 0, 0, 0);\r\n            // else if (!size.tl) size = new GraphSize(size.x, size.y, size.w, size.h);\r\n            if (isPercentage) offset = new GraphPoint(offset.x/$factor*(size.w), offset.y/$factor*(size.h));\r\n            return size.tl().add(offset, false);\r\n        }\r\n        let innermost: LGraph = this.get_graph(c);\r\n        let root: LGraph = this.get_root(c);\r\n        const all: segmentmaker[] = allNodes.flatMap((ge, i) => {\r\n            let dge = ge.__raw;\r\n            let size = outer ? ge.outerSize : ge.innerSize;\r\n\r\n            if (outer && root && innermost && innermost.id !== root.id) {\r\n                size = innermost.translateSize(size, root);\r\n            }\r\n            let base: segmentmaker = {view: ge.view, size, ge, pt: null as any, uncutPt: null as any};\r\n\r\n            Log.exDev(typeof base.size !== \"object\", \"could not get node size:\", {base, c, outer})\r\n            let rets: segmentmaker | undefined;// = base as any;\r\n            let rete: segmentmaker | undefined;// = {...base} as any;\r\n            let debug = true;\r\n            if (debug) {\r\n                (base as any).anchor_e = dge.anchors[c.data.anchorEnd || 0] || dge.anchors[Object.keys(dge.anchors)[0]];\r\n                (base as any).anchor_s = dge.anchors[c.data.anchorStart || 0] || dge.anchors[Object.keys(dge.anchors)[0]];\r\n            }\r\n\r\n            // get endpoint, then startpoint (land on midnode, then depart from it)\r\n            if (i !== 0){\r\n                rete = {rete:true, ...base} as any as segmentmaker;\r\n                if (i === allNodes.length - 1) {\r\n                    // get end anchor from node\r\n                    let anchor = dge.anchors[c.data.anchorEnd || 0];\r\n                    if (!anchor) anchor = dge.anchors[Object.keys(dge.anchors)[0]];\r\n                    if (anchor) rete.pt = getAnchorOffset(rete.size, anchor, true, 1);\r\n                }\r\n                // if no anchor, treat the node as a midpoint\r\n                if (!rete.pt) {\r\n                    // get ending point from midpoint\r\n                    //rete.pt = (LEdgePoint.singleton as LEdgePoint).get_endPoint(undefined as any, rete.size, rete.view);\r\n                    rete.pt = getAnchorOffset(rete.size, rete.view.edgeStartOffset, rete.view.edgeStartOffset_isPercentage);\r\n                }\r\n                rete.uncutPt = rete.pt;\r\n            }\r\n            if (i !== allNodes.length - 1){\r\n                rets = {rets: true, ...base} as any as segmentmaker;\r\n                if (i === 0) {\r\n                    // get start anchor from node\r\n                    let anchor = dge.anchors[c.data.anchorStart || 0];\r\n                    if (!anchor) anchor = dge.anchors[Object.keys(dge.anchors)[0]];\r\n                    if (anchor) rets.pt = getAnchorOffset(rets.size, anchor, true, 1);\r\n                }\r\n                if (!rets.pt) {\r\n                    // rets starting point from midpoint\r\n                    // rets.pt = (LEdgePoint.singleton as LEdgePoint).get_startPoint(undefined as any, rets.size, rets.view);\r\n                    rets.pt = getAnchorOffset(rets.size, rets.view.edgeStartOffset, rets.view.edgeStartOffset_isPercentage);\r\n                }\r\n                rets.uncutPt = rets.pt;\r\n            }\r\n\r\n            // ret.pt = ge.startPoint\r\n            return rets && rete ? [rete, rets] : (rets ? [rets] : [rete as segmentmaker]); }\r\n        );\r\n\r\n        if (DVoidEdge.isFollowingCoords){\r\n            if (c.data.id === LVoidEdge.endFollow) {\r\n                let seg = all[all.length - 1];\r\n                seg.pt = DVoidEdge.isFollowingCoords;\r\n                seg.size = new GraphSize(seg.pt.x, seg.pt.y, 0.01, 0.01);\r\n            }\r\n            if (c.data.id === LVoidEdge.startFollow) {\r\n                let seg = all[0];\r\n                seg.pt = DVoidEdge.isFollowingCoords;\r\n                seg.size = new GraphSize(seg.pt.x, seg.pt.y, 0.01, 0.01);\r\n            }\r\n        }\r\n        return all;\r\n    }\r\n    private get_pointsDebug(c: Context): segmentmaker[]{ return this.get_points_impl(this.get_allNodes(c), true, c); }\r\n    private get_points(allNodes: LGraphElement[], outer: boolean = false, c: Context): segmentmaker[]{\r\n        return this.get_points_impl(allNodes, outer, c);\r\n    }\r\n    private get_points_outer(allNodes: LGraphElement[], c: Context): segmentmaker[]{ return this.get_points_impl(allNodes, true, c); }\r\n    // private get_points_inner(allNodes: LGraphElement[], c: Context): segmentmaker[]{ return this.get_points_impl(allNodes, false, c); }\r\n    public d!: string;\r\n    public __info_of__d: Info = {type: ShortAttribETypes.EString, txt:\"the full suggested path of SVG path \\\"d\\\" attribute, merging all segments.\"}\r\n    public get_d(c: Context) {\r\n        return this.get_segments(c).all.map(s => s.d).join(\" \");\r\n    }/*\r\n    private get_fillingSegments(c: Context): Partial<this[\"segments\"]> {\r\n        return this.get_segments(c).fillers;\r\n    }*/\r\n\r\n\r\n    public get_segments(c:Context): this[\"segments\"] {\r\n        return this.get_segments_outer(c);\r\n    }\r\n    public get_segments_outer(c:Context): this[\"segments\"] { return this.get_segments_impl(c, true); }\r\n    // public get_segments_inner(c: Context): this[\"segments\"] { return this.get_segments_impl(c, false); }\r\n    private get_segments_impl(c: Context, outer: boolean): this[\"segments\"] {\r\n        let l = c.proxyObject;\r\n        let v = this.get_view(c);\r\n        let allNodes = l.allNodes;\r\n        windoww.edge = l;\r\n        let all: segmentmaker[] = this.get_points(allNodes, outer, c);\r\n        //const all: {size: GraphSize, view: LViewElement, ge: LGraphElement}[] = allNodes.map((ge) => { return { view: ge.view, size: ge.size, ge}});\r\n        let ret: EdgeSegment[] = [];\r\n        let bm: EdgeBendingMode = v.bendingMode;\r\n        let gapMode: EdgeGapMode = v.edgeGapMode;\r\n        let segmentSize = this.svgLetterSize(bm, false, true);\r\n        let increase: number = segmentSize.first;\r\n        let segment: EdgeSegment | undefined = undefined;\r\n        /// grouping points according to SvgLetter\r\n        for (let i = 0; i < all.length - 1; ) {\r\n            // let start = all[i], end = all[i+increase];\r\n            let start: segmentmaker = all[i];\r\n            let endindex = (i+increase < all.length - 1) ? i+increase : all.length - 1;\r\n            let mid: segmentmaker[] = all.slice(i+1, endindex).filter( (e, i)=> i % 2 === 0);\r\n            let end: segmentmaker = all[endindex];\r\n            // makes sure the edge actually reaches his target even if there is an invalid amount of midnodes fot the current EdgeBendingMode\r\n            if (i === endindex && segment) start = segment.end;\r\n            // segment = this.get_segmentv3(start, mid, end, getSvgLetter(i), i, segment, all);\r\n            segment = new EdgeSegment(start, mid, end, bm, gapMode, i, segment);\r\n            // segment = this.get_segment(start.ge, start.size, start.view, end.ge, end.size, end.view, cut, v.bendingMode, mid, ret[ret.length -1], fillMode, segment);\r\n            ret.push(segment);\r\n            i+= increase+1; // because increase index is already inserted at the end of prev segment\r\n            if (increase !== segmentSize.others) increase = segmentSize.others;\r\n            // if (longestLabel !== undefined && longest < s.length) { longest = s.length; longestindex = i; } todo: move to after snapping to borders\r\n        }\r\n        function printablesegment(s:GObject) {\r\n            let r: GObject = {};\r\n            for (let k in s) {\r\n                let v = s[k];\r\n                v = v?.__raw || v;\r\n                if (typeof v === \"object\") r[k] = JSON.parse(JSON.stringify(v));\r\n                else r[k] = v;\r\n            }\r\n            return r;\r\n        }\r\n\r\n        let fillSegments: EdgeSegment[] = [];\r\n        this.snapSegmentsToNodeBorders(c, v, ret, fillSegments);\r\n        let longestLabel = c.data.longestLabel;\r\n        this.setLabels(c, ret, allNodes);\r\n        // console.log(\"getSegments() labeled:\", {main:ret, fillSegments});\r\n        let rett: this[\"segments\"] = {all: [...ret, ...fillSegments], segments: ret, fillers: fillSegments} as any;\r\n        /*switch(bm){\r\n            default: break;\r\n            case EdgeBendingMode.Bezier_QT:\r\n            case EdgeBendingMode.Bezier_CS:\r\n                rett.\r\n        }*/\r\n        for (let i = 0; i < rett.all.length; i++) {\r\n            let s = rett.all[i];\r\n            s.makeD(i, gapMode);\r\n        }\r\n        let zoom = new GraphPoint(1, 1);\r\n        rett.head = this.headPos_impl(c, true, v.edgeHeadSize, rett.segments[rett.segments.length - 1], zoom);\r\n        rett.tail = this.headPos_impl(c, false, v.edgeTailSize, rett.segments[0], zoom);\r\n        return rett;\r\n    }\r\n    private setLabels(c: Context, segments: EdgeSegment[], allNodes: this[\"allNodes\"]): void {\r\n        // find longest segment\r\n        let longestindex = -1;\r\n        let longest = 0;\r\n        for (let i = 0; i < segments.length; i++) {\r\n            let s = segments[i];\r\n            s.calcLength();\r\n            if (longest < s.length) { longest = s.length; longestindex = i; }\r\n            s.isLongest = false;\r\n        }\r\n        if (longestindex >= 0) segments[longestindex].isLongest = true;\r\n        // apply labels\r\n        for (let s of segments) s.label = this.get_label_impl(c, s, allNodes, segments);\r\n    }\r\n\r\n    private snapSegmentsToNodeBorders(c: Context, v: LViewElement, ret: EdgeSegment[], fillSegments: EdgeSegment[]){\r\n        // snap segment start and end to a node border\r\n        let canCutStart: boolean = v.edgeStartStopAtBoundaries,\r\n            canCutEnd: boolean = v.edgeEndStopAtBoundaries;\r\n        let grid: GraphPoint | undefined = undefined;\r\n        // let fillSegments: EdgeSegment[] = [];\r\n        let gapMode: EdgeGapMode = v.edgeGapMode;\r\n        let bm: EdgeBendingMode = v.bendingMode;\r\n\r\n\r\n        let ci: GraphPoint | undefined;\r\n        // cut i === 0 is cut regardless of gapmode.\r\n        if (canCutStart) {\r\n            ci = GraphSize.closestIntersection(ret[0].start.size, ret[0].start.pt, (ret[0].bezier[0] || ret[0].end).pt, grid);\r\n            if (ci) ret[0].start.pt = ci;\r\n            /*\r\n            ret[0].start.pt =\r\n                GraphSize.closestIntersection(ret[0].start.size, ret[0].start.pt, (ret[0].bezier[0] || ret[0].end).pt, grid) as any\r\n                || Geom.closestPoint(ret[0].start.size, ret[0].start.pt);*/\r\n        }\r\n\r\n        // cut middle segments maybe\r\n        let prev: EdgeSegment;\r\n        let curr: EdgeSegment = ret[0];\r\n\r\n        // if (gapMode === EdgeGapMode.gap) return;\r\n        if (canCutStart || canCutEnd) // do the for below\r\n            for (let i = 1; i < ret.length; i++){\r\n                prev = ret[i-1];\r\n                curr = ret[i];\r\n                let doStartCut: boolean, doEndCut: boolean;\r\n                switch(gapMode){/*\r\n                    case EdgeGapMode.arcFill:\r\n                    case EdgeGapMode.lineFill:\r\n                    case EdgeGapMode.autoFill:\r\n                        // same as gap, but will insert 1 more segment to fill the hole\r\n                        doStartCut = true;\r\n                        doEndCut = true;\r\n                        if (prev.end.pt.equals(curr.start.pt)) break;\r\n                        fillSegments.push(new EdgeFillSegment(\r\n                            prev.end,\r\n                            [\r\n                                {...prev.end, pt: EdgeSegment.invertLastBezierPt(prev.end.pt, (prev.bezier[prev.bezier.length-1] || prev.start).pt)},\r\n                                {...curr.start, pt: EdgeSegment.invertLastBezierPt(curr.start.pt, (curr.bezier[0] || curr.end).pt)}\r\n                            ],\r\n                            curr.start,\r\n                            bm, gapMode, 0, undefined));\r\n                            / *\r\n                            fillSegments.push(new FillEdgeSegment( // M <start_gap> C <bez1> <bez2> <end_gap>\r\n                               // <start_gap> = end of last seg (start of gap) <end_gap> = first of curr seg (end of gap)\r\n                            prev.end.pt,\r\n                            EdgeSegment.invertLastBezierPt(prev.end.pt, prev.bezier[prev.bezier.length-1].pt || prev.start.pt),\r\n                            EdgeSegment.invertLastBezierPt(curr.start.pt, curr.bezier[0].pt || curr.end.pt),\r\n                            curr.start.pt)* /\r\n\r\n                        break;*/\r\n                    case EdgeGapMode.gap:\r\n                        // just snap to vertex edge         prevSegment.endp and ret.startp\r\n                        doEndCut = true; doStartCut = true;\r\n                        break;\r\n                    // average: todo: maybe rename in join (merges start-end at closest pt to both (avg), then snap on edge)\r\n                    case \"closest\" as any: //EdgeGapMode.closest:\r\n                        // does not work properly, i think i need to get next.end instead of curr.end, just disabled for now\r\n                        let nextpt: GraphPoint = (curr.bezier[0] || curr.end).pt;\r\n                        let prevpt: GraphPoint = (prev.bezier[prev.bezier.length-1] || prev.start).pt;\r\n                        let midexternalpt = prevpt.add(nextpt, true);\r\n                        let midedgepoint = curr.start.size.tl().add(curr.start.size.br(), false).divide(2, false);\r\n                        // od average between the 2 points before and after that are not part of this edgepoint, then raw a line from there to center of ep, find that intersection.\r\n                        ci = GraphSize.closestIntersection(curr.start.size, midedgepoint, midexternalpt, grid);\r\n                        doEndCut = doStartCut = false;\r\n                        if (canCutEnd && ci) prev.end.pt = ci;\r\n                        if (canCutStart && ci) curr.start.pt = ci;\r\n                        break;\r\n                    case EdgeGapMode.average:\r\n                        // first move to average of the 2 points in the gap, then snap to edge\r\n                        doEndCut = true; doStartCut = true;\r\n                        // indipendent from cutStart, cutEnd.\r\n                        // they merge if just 1 of cutting sides are true. (and if they are both false we don't even enter the for loop)\r\n                        curr.start.pt = curr.start.pt.add(prev.end.pt, false).divide(2, false);\r\n                        prev.end.pt = curr.start.pt.duplicate(); // intentionally not the same pt because during snap to edge they can diverge again.\r\n                        prev.start.uncutPt = prev.start.pt;\r\n                        prev.end.uncutPt = prev.end.pt;\r\n                        break;\r\n                    // center: first move it to center of edgePoint/node, then snap to edge.\r\n                    // this mode might be as well deleted, it can be specified with anchor points\r\n                    case EdgeGapMode.center:\r\n                        doEndCut = false; doStartCut = false;\r\n                        curr.start.pt = curr.start.size.tl().add(curr.start.size.br(), false).divide(2, false);\r\n                        prev.end.pt = curr.start.pt.duplicate(); // intentionally not the same pt because during snap to edge they can diverge again.\r\n                        prev.start.uncutPt = prev.start.pt; // only update them when point moves without being cut (average and center)\r\n                        prev.end.uncutPt = prev.end.pt;\r\n                        break;\r\n                    default:\r\n                        return Log.exDevv(\"unexpected EdgeGapMode:\" + gapMode);\r\n                }\r\n                if (canCutStart && doStartCut){\r\n                    let nextpt: GraphPoint = (curr.bezier[0] || curr.end).pt;\r\n                    ci = GraphSize.closestIntersection(curr.start.size, curr.start.pt, nextpt, grid);\r\n                    if (ci) curr.start.pt = ci;// || Geom.closestPoint(curr.start.size, curr.start.pt);\r\n                    //if (gapMode === EdgeGapMode.average && prev) { prev.end.pt = curr.start.pt.add(prev.end.pt, false).divide(2, false); }\r\n                }\r\n                if (canCutEnd && doEndCut && prev){\r\n                    let prevpt: GraphPoint = (prev.bezier[prev.bezier.length-1] || prev.start).pt;\r\n                    ci = GraphSize.closestIntersection(prev.end.size, prev.end.pt, prevpt, grid);\r\n                    if (ci) prev.end.pt = ci;// || Geom.closestPoint(prev.end.size, prev.end.pt);\r\n                    // if average: first do average between start anchor points non-snapped. then i snap both,\r\n                    // then i do average again, and since it might snap out, i get closestPoint to EdgePoint size\r\n                    if (gapMode === EdgeGapMode.average) prev.end.pt = curr.start.pt =\r\n                        Geom.closestPoint(curr.start.size, curr.start.pt.add(prev.end.pt, false).divide(2, false));\r\n                }\r\n            }\r\n        // cut end of last segment regardless of gapMode\r\n        if (canCutEnd) {\r\n            let prevendpt = curr.end.pt;\r\n            ci = GraphSize.closestIntersection(curr.end.size, curr.end.pt, (curr.bezier[curr.bezier.length-1] || curr.start).pt, grid);\r\n            if (ci) curr.end.pt = ci; //|| Geom.closestPoint(prev.end.size, prev.end.pt);\r\n        }\r\n\r\n    }\r\n\r\n\r\n\r\n    get_edgeEnd(context: Context){ return this.get_edgeEnd_outer(context); }\r\n    get_edgeEnd_outer(c: Context){\r\n        // return this.get_outerGraph(c).translateSize(this.get_edgeEnd_inner(c), this.get_innerGraph(c));\r\n        return this.get_outerGraph(c).translateSize(this.get_edgeEnd_inner(c), this.get_end(c).innerGraph);\r\n    }\r\n    get_edgeEnd_inner(c: Context){\r\n        return this.get_edgeStartEnd_inner(c, false);\r\n        // return context.proxyObject.end?.size || new GraphPoint(0, 0);\r\n    }\r\n\r\n\r\n    protected get_midnodes(context: Context): this[\"midnodes\"] {\r\n        // return LPointerTargetable.wrapAll(context.data.midnodes);\r\n        return LPointerTargetable.wrapAll(context.data.subElements);\r\n    }\r\n    protected set_midnodes(val: D[\"midnodes\"], context: Context): boolean {\r\n        return SetFieldAction.new(context.data.id, \"midnodes\", val, '', true);\r\n    }\r\n\r\n\r\n    anchorStart?: string;\r\n    anchorEnd?: string;\r\n    __info_of__anchorStart: Info = {writeType:\"string | undefined\", type:\"string\", isEdge: true,\r\n        txt:\"The name of a node anchor where the edge should originate from.\"};\r\n    __info_of__anchorEnd: Info = {writeType:\"string | undefined\", type:\"string\", isEdge: true,\r\n        txt:\"The name of a node anchor where the edge should point to.\"};\r\n    endFollow!: boolean;\r\n    startFollow!: boolean;\r\n    __info_of__endFollow: Info = {writeType:\"boolean\", readType:\"boolean\", type:\"boolean\", isEdge: true,// type:\"read:(()=>void), write:boolean\", readType:\"(()=>void))\",\r\n        txt:\"makes the ending point of an edge follow the cursor, so it can be assigned to a new anchor or target.\"};\r\n    __info_of__startFollow: Info = {writeType:\"boolean\", readType:\"boolean\", type:\"boolean\", isEdge: true,// type:\"read:(()=>void), write:boolean\", readType:\"(()=>void))\",\r\n        txt:\"makes the starting point of an edge follow the cursor, so it can be assigned to a new anchor or source.\"};\r\n    get_endFollow(c: Context): boolean { return (c.data.id === LVoidEdge.endFollow); }\r\n    get_startFollow(c: Context): boolean { return (c.data.id === LVoidEdge.startFollow); }\r\n    // // what in multieditor? needs to be moved in transientstuff?\r\n    set_endFollow(val: boolean, c: Context): boolean { return this._set_start_endFollow(val, c, false); }\r\n    set_startFollow(val: boolean, c: Context): boolean { return this._set_start_endFollow(val, c, true); }\r\n    _set_start_endFollow(val: boolean, c: Context, isStart: boolean): boolean {\r\n        val = !!val;\r\n        console.log(\"_set_start_endFollow\", {val, c, isStart});\r\n        if (val) {\r\n            if (isStart) LVoidEdge.startFollow = c.data.id;\r\n            else LVoidEdge.endFollow = c.data.id;\r\n            if (!LVoidEdge.following) {\r\n                console.log(\"_set_start_endFollow event attached\");\r\n                document.body.addEventListener(\"mousemove\", LVoidEdge.mousemove_pendingEdge, false);\r\n                document.body.addEventListener(\"keydown\", LVoidEdge.onKeyDown_pendingEdge, false);\r\n                LVoidEdge.following = true;\r\n                LVoidEdge.followingContext = c;\r\n                LVoidEdge.showAnchors();\r\n                (windoww.Tooltip as (typeof Tooltip)).show(<div>Changing anchor, press <b>Esc</b> to undo.</div>);\r\n\r\n                //let selector = \".Edge[nodeid='\" + (LVoidEdge.endFollow || LVoidEdge.startFollow as any)+\"']\";\r\n                // [...document.querySelectorAll(selector)].map(e=>e.classList.add(\"no-transition-following\")); gets refreshed by react\r\n                document.body.classList.add(\"no-transition-following\");\r\n            }\r\n        }\r\n        else {\r\n            if (LVoidEdge.following && ((isStart ? LVoidEdge.startFollow : LVoidEdge.endFollow) === c.data.id)) {\r\n                document.body.removeEventListener(\"mousemove\", LVoidEdge.mousemove_pendingEdge, false);\r\n                document.body.removeEventListener(\"keydown\", LVoidEdge.onKeyDown_pendingEdge, false);\r\n                let selector = \".Edge[nodeid='\" + (LVoidEdge.endFollow || LVoidEdge.startFollow as any)+\"']\";\r\n                //[...document.querySelectorAll(selector)].map(e=>e.classList.remove(\"no-transition-following\"));\r\n                document.body.classList.remove(\"no-transition-following\");\r\n                if (isStart) LVoidEdge.startFollow = undefined;\r\n                else LVoidEdge.endFollow = undefined;\r\n                LVoidEdge.following = false;\r\n                const $base = $(document.getElementById(isStart ? c.data.start : c.data.end) || []);\r\n                if (!$base.length) return true;\r\n                //const $deepAnchors = $base.find(\"[nodeid] .anchor\");\r\n                const $anchors = $base.find(\".anchor\")//.not($deepAnchors);\r\n                $anchors.removeClass([\"valid-anchor\", \"active-anchor\"]);\r\n                $base[0].style.overflow = '';\r\n                (windoww.Tooltip as (typeof Tooltip)).hide();\r\n            }\r\n        }\r\n        //SetFieldAction.new(c.data, \"startFollow\", !!val, '', false);\r\n        return true; }\r\n    public static startFollow: Pointer<DVoidEdge> | undefined = undefined;\r\n    public static endFollow: Pointer<DVoidEdge> | undefined = undefined;\r\n    public static following: boolean = false;\r\n    public static followingContext: LogicContext<DVoidEdge, LVoidEdge>;\r\n    public static tmp: number = 1;\r\n    public static canForceUpdate: boolean = true;\r\n    public static getCursorPos(e0: Event): Point { return new Point((e0 as any as MouseEvent).pageX, (e0 as any as MouseEvent).pageY); }\r\n    /*public static getGCursorPos(e0: Event): GraphPoint {\r\n        return LVLoidEdge.getCursorPos(e0).subtract(svgsize.tl(), true).multiply(svgzoom) as any as GraphPoint;\r\n    }*/\r\n    public static onKeyDown_pendingEdge(e: KeyboardEvent): void{\r\n        if (e.key === Keystrokes.escape) {\r\n            const c = LVoidEdge.followingContext;\r\n            if (!c || (!LVoidEdge.startFollow && !LVoidEdge.endFollow)) return;\r\n            let isStart = LVoidEdge.startFollow ? true : false;\r\n            let l = (c.proxyObject as any as LVoidEdge);\r\n            if (isStart) l.startFollow = false;\r\n            else l.endFollow = false;\r\n            // l.component?.forceUpdate(); does not work?\r\n            l.clonedCounter = (l.clonedCounter || 0) + 2;\r\n        }\r\n    }\r\n    public static showAnchors(): void{\r\n        const c = LVoidEdge.followingContext;\r\n        if (!c || (!LVoidEdge.startFollow && !LVoidEdge.endFollow)) return;\r\n        let isStart = LVoidEdge.startFollow ? true : false;\r\n        let nodeid: Pointer<DGraphElement> = isStart ? c.data.start : c.data.end;\r\n        let activeAnchor: string | number = (isStart ? c.data.anchorStart : c.data.anchorEnd) || 0;\r\n\r\n        const $base = $(document.getElementById(nodeid) || []);\r\n        if (!$base.length) return;\r\n        const $deepAnchors = $base.find(\"[nodeid] .anchor\");\r\n        const $anchors = $base.find(\".anchor\").not($deepAnchors);\r\n        $anchors.addClass(\"valid-anchor\");\r\n        $anchors.filter('[data-anchorname=\"'+activeAnchor+'\"]').addClass(\"active-anchor\");\r\n        $base[0].style.overflow = \"visible\";\r\n\r\n    }\r\n    private static mousemovei: number = 0;\r\n    public static mousemove_pendingEdge(e0: Event): void {\r\n        let forcererendermode = true;\r\n        if (forcererendermode) {\r\n            if (!LVoidEdge.following) return;\r\n            if (!LVoidEdge.canForceUpdate) return;\r\n            if (LVoidEdge.mousemovei++%30 === 0) LVoidEdge.showAnchors();\r\n\r\n\r\n            let c = LVoidEdge.followingContext;\r\n            let g: LGraph = c.proxyObject.graph;\r\n            let cursorPos = LVoidEdge.getCursorPos(e0);\r\n            let gcursorpos = g.translateHtmlSize(cursorPos);\r\n            // console.log(\"gcursorpos\", {cursorPos:cursorPos.toString(), gcursorpos:gcursorpos.toString(), g});\r\n            DVoidEdge.isFollowingCoords = gcursorpos;\r\n\r\n            let component: GraphElementComponent = GraphElementComponent.map[(LVoidEdge.startFollow || LVoidEdge.endFollow) as string];\r\n            LVoidEdge.canForceUpdate = false;\r\n            let timer = setTimeout(()=>{LVoidEdge.canForceUpdate = true; }, 5000);\r\n            let tn = transientProperties.node[c.data.id];\r\n            for (let vid in tn.viewScores) { // required to truly force an update\r\n                let tnv = tn.viewScores[vid];\r\n                tnv.jsxOutput = undefined;\r\n                tnv.usageDeclarations = undefined as any;\r\n                tnv.shouldUpdate = true;\r\n            }\r\n            component.setState({forceupdate:new Date().getDate()} as any, ()=>{LVoidEdge.canForceUpdate = true; clearTimeout(timer)});\r\n            // component.forceUpdate(()=>{LVoidEdge.canForceUpdate = true; clearTimeout(timer)});\r\n            return;\r\n        }\r\n\r\n        LVoidEdge.tmp++;\r\n        let selector = \".Edge[nodeid='\" + (LVoidEdge.endFollow || LVoidEdge.startFollow as any)+\"']\";\r\n        let root = document.querySelector(selector);\r\n        if (!root) return;\r\n        let paths: SVGPathElementt[] = [...root.querySelectorAll(\"path.full\")] as SVGPathElementt[];\r\n        let pathSegments = root.querySelectorAll(\"path.segment.preview\") as any as SVGPathElementt[];\r\n        // if (!paths.length) paths = pathSegments;\r\n        let pathSegmentContainers: Element[] = [...new Set([...pathSegments].map(e=>e.parentElement))] as Element[];\r\n        for (let container of pathSegmentContainers){\r\n            let se: SVGPathElementt[] = [...container.querySelectorAll(\"path.segment.preview\")] as SVGPathElementt[];\r\n            paths.push(se[LVoidEdge.endFollow ? se.length-1 : 0]);\r\n        }\r\n        let headTail = [...root.querySelectorAll(LVoidEdge.endFollow ? '.edgeHead' : '.edgeTail')] as HTMLElement[];\r\n        let cursorPos = LVoidEdge.getCursorPos(e0)\r\n\r\n        let segList: SVGPathSegment[] | undefined;\r\n        for (let p of paths) {\r\n            let svg: SVGElement = U.parentUntil(\"svg\", p) as SVGElement;\r\n            let svgsize: Size = Size.of(svg);\r\n            let svgzoom: Point = new Point(1,1); // todo: check viewbox and css zoom\r\n            let gcursorPos = cursorPos.subtract(svgsize.tl(), true).multiply(svgzoom) as any as GraphPoint;\r\n            segList = [...p.getPathData()];\r\n            let lastSeg = {...segList[LVoidEdge.endFollow ? segList.length-1 : 0]};\r\n            switch (lastSeg.type){\r\n                case 'a': case 'A':\r\n                    segList.push('fake new segment to get replaced instead of actual last segment which is A' as any);\r\n                    lastSeg.type=\"L\"; lastSeg.values = [gcursorPos.x, gcursorPos.y];\r\n                    break;\r\n                case \"C\": case \"c\": // bezier curves, keep type just change last point\r\n                case \"Q\": case \"q\":\r\n                case \"S\": case \"s\":\r\n                case \"T\": case \"t\":\r\n                    lastSeg.values[lastSeg.values.length-2] = gcursorPos.x;\r\n                    lastSeg.values[lastSeg.values.length-1] = gcursorPos.y; break;\r\n                case \"M\": case \"m\":\r\n                    lastSeg.type = LVoidEdge.endFollow ? \"L\" : \"M\";\r\n                    lastSeg.values = [gcursorPos.x, gcursorPos.y]; break;\r\n                case \"V\": case \"v\": // stuff forced to become a line\r\n                case \"H\": case \"h\":\r\n                case \"L\": case \"l\":\r\n                case \"Z\": case \"z\":\r\n                    lastSeg.type=\"L\"; lastSeg.values = [gcursorPos.x, gcursorPos.y];\r\n                    break;\r\n            }\r\n            segList[LVoidEdge.endFollow ? segList.length-1 : 0] = lastSeg;\r\n            if (LVoidEdge.tmp%20===0) console.log(\"svg set path data,\", {segList, oldSeglist:p.getPathData(), p});\r\n            p.setPathData(segList);\r\n        }\r\n\r\n        for (let ht of headTail){\r\n            let svg: SVGElement = U.parentUntil(\"svg\", ht) as SVGElement;\r\n            let svgsize: Size = Size.of(svg);\r\n            let svgzoom: Point = new Point(1,1); // todo: check viewbox and css zoom\r\n            let gcursorPos = cursorPos.subtract(svgsize.tl(), true).multiply(svgzoom) as any as GraphPoint;\r\n            let rotation: number;\r\n            let lastPt = segList && segList[LVoidEdge.endFollow ? segList.length-2 : 1].values;\r\n\r\n            if (lastPt) {\r\n                let m = gcursorPos.getM(new Point(lastPt[LVoidEdge.endFollow ? lastPt.length-2 : 1], lastPt[LVoidEdge.endFollow ? lastPt.length-1 : 0]));\r\n                if (Number.POSITIVE_INFINITY === m) rotation = Geom.degToRad(90); else\r\n                if (Number.NEGATIVE_INFINITY === m) rotation = Geom.degToRad(270); else\r\n                    rotation = Math.atan(m);\r\n                if (lastPt[LVoidEdge.endFollow ? lastPt.length-2 : 1] > gcursorPos.x) rotation -= Geom.degToRad(180);\r\n            } else { rotation = 0;}\r\n            let headSize = Size.of(ht);\r\n\r\n            let headPos = gcursorPos.subtract({x:headSize.w/2, y:headSize.h/2}, true);//.subtract({x:Math.cos(rotation)*headSize.w/2, y: -Math.sin(rotation)*headSize.h/2}, true);\r\n\r\n            if (LVoidEdge.tmp%20===0) console.log(\"_set_start_endFollow move head\", {selector:LVoidEdge.endFollow ? '.edgeHead' : '.edgeTail', headTail, root});\r\n            ht.style.transform = 'translate('+headPos.x+\"px, \"+headPos.y+\"px) rotate(\"+rotation+\"rad)\";\r\n        }\r\n    }\r\n}\r\nRuntimeAccessibleClass.set_extend(DGraphElement, DVoidEdge);\r\nRuntimeAccessibleClass.set_extend(LGraphElement, LVoidEdge);\r\n\r\n@RuntimeAccessible('DEdge')\r\nexport class DEdge extends DVoidEdge { // DVoidEdge\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // static singleton: LGraphElement;\r\n    // static logic: typeof LGraphElement;\r\n    // static structure: typeof DGraphElement;\r\n    id!: Pointer<DEdge, 1, 1, LEdge>;\r\n    graph!: Pointer<DGraph, 1, 1, LGraph>;\r\n    model!: Pointer<DModelElement, 0, 1, LModelElement>;\r\n    // isSelected: Dictionary<DocString<Pointer<DUser>>, boolean> = {};\r\n    isSelected!: Dictionary<DocString<Pointer<DUser>>, boolean>;\r\n    // containedIn!: Pointer<DGraphElement, 0, 1, LGraphElement>;\r\n    subElements!: Pointer<DGraphElement, 0, 'N', LGraphElement>;\r\n    state!: GObject;\r\n    start!: Pointer<DGraphElement, 1, 1, LGraphElement>;\r\n    end!: Pointer<DGraphElement, 1, 1, LGraphElement>;\r\n    __isDEdge!: true;\r\n    __isDVoidEdge!: true;\r\n    midnodes!: Pointer<DEdgePoint, 1, 1, LEdgePoint>[];\r\n}\r\n\r\n@RuntimeAccessible('LEdge')\r\nexport class LEdge<Context extends LogicContext<DEdge> = any, D extends DEdge = DEdge> extends LVoidEdge {\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // static singleton: LGraphElement;\r\n    // static logic: typeof LGraphElement;\r\n    // static structure: typeof DGraphElement;\r\n    __raw!: DEdge;\r\n    id!: Pointer<DEdge, 1, 1, LEdge>;\r\n    graph!: LGraph;\r\n    model?: LModelElement;\r\n    // isSelected: Dictionary<DocString<Pointer<DUser>>, boolean> = {};\r\n    isSelected(forUser?: Pointer<DUser>): boolean { return this.wrongAccessMessage(\"node.isSelected()\"); }\r\n    // containedIn!: LGraphElement;\r\n    subElements!: LGraphElement[];\r\n    _state!: GObject<\"proxified\">; // LMap;\r\n    midnodes!: LEdgePoint[];\r\n    __isLEdge!: true;\r\n    __isLVoidEdge!: true;\r\n\r\n}\r\nRuntimeAccessibleClass.set_extend(DVoidEdge, DEdge);\r\nRuntimeAccessibleClass.set_extend(LVoidEdge, LEdge);\r\n@Leaf\r\n@RuntimeAccessible('DExtEdge')\r\nexport class DExtEdge extends DEdge { // etends DEdge\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // static singleton: LGraphElement;\r\n    // static logic: typeof LGraphElement;\r\n    // static structure: typeof DGraphElement;\r\n    id!: Pointer<DExtEdge, 1, 1, LExtEdge>;\r\n    graph!: Pointer<DGraph, 1, 1, LGraph>;\r\n    model!: Pointer<DModelElement, 0, 1, LModelElement>;\r\n    // isSelected: Dictionary<DocString<Pointer<DUser>>, boolean> = {};\r\n    isSelected!: Dictionary<DocString<Pointer<DUser>>, boolean>;\r\n    // containedIn!: Pointer<DGraphElement, 0, 1, LGraphElement>;\r\n    subElements!: Pointer<DGraphElement, 0, 'N', LGraphElement>;\r\n    state!: GObject;\r\n    start!: Pointer<DGraphElement, 1, 1, LGraphElement>;\r\n    end!: Pointer<DGraphElement, 1, 1, LGraphElement>;\r\n    __isDExtEdge!: true;\r\n    __isDEdge!: true;\r\n    __isDVoidEdge!: true;\r\n    /*\r\n        public static new(model: DGraph[\"model\"], parentNodeID: DGraphElement[\"father\"], graphID: DGraphElement[\"graph\"], nodeID?: DGraphElement[\"id\"], size?: GraphSize): DExtEdge {\r\n            return new Constructors(new DExtEdge('dwc')).DPointerTargetable().DGraphElement(model, parentNodeID, graphID, nodeID)\r\n                .DVoidEdge().DEdge().DExtEdge().end();\r\n        }*/\r\n}\r\n\r\n@RuntimeAccessible('LExtEdge')\r\nexport class LExtEdge extends LEdge{\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // static singleton: LGraphElement;\r\n    // static logic: typeof LGraphElement;\r\n    // static structure: typeof DGraphElement;\r\n    __raw!: DExtEdge;\r\n    id!: Pointer<DExtEdge, 1, 1, LExtEdge>;\r\n    graph!: LGraph;\r\n    model?: LModelElement;\r\n    // isSelected: Dictionary<DocString<Pointer<DUser>>, boolean> = {};\r\n    isSelected(forUser?: Pointer<DUser>): boolean { return this.wrongAccessMessage(\"node.isSelected()\"); }\r\n    // containedIn!: LGraphElement;\r\n    subElements!: LGraphElement[];\r\n    _state!: GObject<\"proxified\">; // LMap;\r\n    start!: LGraphElement;\r\n    end!: LGraphElement;\r\n    __isLExtEdge!: true;\r\n    __isLEdge!: true;\r\n    __isLVoidEdge!: true;\r\n}\r\nRuntimeAccessibleClass.set_extend(DEdge, DExtEdge);\r\nRuntimeAccessibleClass.set_extend(LEdge, LExtEdge);\r\n@Leaf\r\n@RuntimeAccessible('DRefEdge')\r\nexport class DRefEdge extends DEdge { // extends DEdge\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    start!: Pointer<DGraphElement, 1, 1, LGraphElement>;\r\n    end!: Pointer<DGraphElement, 1, 1, LGraphElement>;\r\n    isSelected!: Dictionary<DocString<Pointer<DUser>>, boolean>;\r\n    __isDRefEdge!: true;\r\n    /*\r\n        public static new(model: DGraph[\"model\"], parentNodeID: DGraphElement[\"father\"], graphID: DGraphElement[\"graph\"], nodeID?: DGraphElement[\"id\"]): DRefEdge {\r\n            return new Constructors(new DRefEdge('dwc')).DPointerTargetable().DGraphElement(model, parentNodeID, graphID, nodeID)\r\n                .DVoidEdge().DEdge().DRefEdge().end();\r\n        }*/\r\n\r\n}\r\n@RuntimeAccessible('LRefEdge')\r\nexport class LRefEdge extends LEdge {\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // __raw!: DRefEdge;\r\n    start!: LGraphElement;\r\n    end!: LGraphElement;\r\n    __isLRefEdge!: true;\r\n}\r\nRuntimeAccessibleClass.set_extend(DEdge, DRefEdge);\r\nRuntimeAccessibleClass.set_extend(LEdge, LRefEdge);\r\n// for edges without a modelling element\r\n\r\n\r\n/*\r\n\r\nlet a = `DExtEdge, DRefEdge, DVoidEdge, LGraphVertex, LRefEdge, LEdgePoint, DVoidVertex, DGraphVertex, DEdgePoint,\r\n DVertex, DEdge, LVertex, LGraph, DGraph, LVoidVertex, LVoidEdge, LEdge, LGraphElement, LExtEdge, DGraphElement`;\r\n  // // ... get from export in index.ts\r\na = a.replaceAll(',,', \",\")\r\nlet aa = a.split(\",\").map(a => a.trim().substring(1));\r\n\r\nfunction onlyUnique(value, index, self) { return self.indexOf(value) === index; }\r\n\r\naa = aa.filter(onlyUnique).filter( a=> !!a)\r\nlet r = aa.filter(onlyUnique).filter( a=> !!a).map( a=> `export type W${a} = getWParams<L${a}, D${a}>;`).join('\\n')\r\ndocument.body.innerText = r;\r\n*/\r\nexport type WExtEdge = getWParams<LExtEdge, DExtEdge>;\r\nexport type WRefEdge = getWParams<LRefEdge, DRefEdge>;\r\nexport type WVoidEdge = getWParams<LVoidEdge, DVoidEdge>;\r\nexport type WGraphVertex = any; // getWParams<LGraphVertex, DGraphVertex>;\r\nexport type WEdgePoint = getWParams<LEdgePoint, DEdgePoint>;\r\nexport type WVoidVertex = getWParams<LVoidVertex, DVoidVertex>;\r\nexport type WVertex = getWParams<LVertex, DVertex>;\r\nexport type WEdge = getWParams<LEdge, DEdge>;\r\nexport type WGraph = getWParams<LGraph, DGraph>;\r\nexport type WGraphElement = getWParams<LGraphElement, DGraphElement>;\r\n\r\nconsole.warn('ts loading graphDataElement');\r\n\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}