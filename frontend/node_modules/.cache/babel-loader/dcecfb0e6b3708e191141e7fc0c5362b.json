{"ast":null,"code":"var __rest = this && this.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\nimport React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport debounce from 'lodash/debounce';\nimport { defaultGroup, DockContextProvider, placeHolderGroup, placeHolderStyle } from \"./DockData\";\nimport { DockBox } from \"./DockBox\";\nimport { FloatBox } from \"./FloatBox\";\nimport { DockPanel } from \"./DockPanel\";\nimport * as Algorithm from \"./Algorithm\";\nimport * as Serializer from \"./Serializer\";\nimport * as DragManager from \"./dragdrop/DragManager\";\nimport { MaxBox } from \"./MaxBox\";\nimport { WindowBox } from \"./WindowBox\";\nclass DockPortalManager extends React.PureComponent {\n  constructor() {\n    super(...arguments);\n    /** @ignore */\n    this._caches = new Map();\n    this.destroyRemovedPane = () => {\n      this._pendingDestroy = null;\n      let cacheRemoved = false;\n      for (let [id, cache] of this._caches) {\n        if (cache.owner == null) {\n          this._caches.delete(id);\n          cacheRemoved = true;\n        }\n      }\n      if (cacheRemoved) {\n        this.forceUpdate();\n      }\n    };\n  }\n  /** @ignore */\n  getTabCache(id, owner) {\n    let cache = this._caches.get(id);\n    if (!cache) {\n      let div = document.createElement('div');\n      div.className = 'dock-pane-cache';\n      cache = {\n        div,\n        id,\n        owner\n      };\n      this._caches.set(id, cache);\n    } else {\n      cache.owner = owner;\n    }\n    return cache;\n  }\n  /** @ignore */\n  removeTabCache(id, owner) {\n    let cache = this._caches.get(id);\n    if (cache && cache.owner === owner) {\n      cache.owner = null;\n      if (!this._pendingDestroy) {\n        // it could be reused by another component, so let's wait\n        this._pendingDestroy = setTimeout(this.destroyRemovedPane, 1);\n      }\n    }\n  }\n  /** @ignore */\n  updateTabCache(id, children) {\n    let cache = this._caches.get(id);\n    if (cache) {\n      cache.portal = ReactDOM.createPortal(children, cache.div, cache.id);\n      this.forceUpdate();\n    }\n  }\n}\nexport class DockLayout extends DockPortalManager {\n  constructor(props) {\n    super(props);\n    /** @ignore */\n    this.getRef = r => {\n      this._ref = r;\n    };\n    /** @ignore */\n    this.onDragStateChange = draggingScope => {\n      if (draggingScope == null) {\n        DockPanel.droppingPanel = null;\n        if (this.state.dropRect) {\n          this.setState({\n            dropRect: null\n          });\n        }\n      }\n    };\n    this._onWindowResize = debounce(() => {\n      let layout = this.getLayout();\n      if (this._ref) {\n        let newLayout = Algorithm.fixFloatPanelPos(layout, this._ref.offsetWidth, this._ref.offsetHeight);\n        if (layout !== newLayout) {\n          newLayout = Algorithm.fixLayoutData(newLayout); // panel parent might need a fix\n          this.changeLayout(newLayout, null, 'move');\n        }\n      }\n    }, 200);\n    let {\n      layout,\n      defaultLayout,\n      loadTab\n    } = props;\n    let preparedLayout;\n    if (defaultLayout) {\n      preparedLayout = this.prepareInitData(props.defaultLayout);\n    } else if (!loadTab) {\n      throw new Error('DockLayout.loadTab and DockLayout.defaultLayout should not both be undefined.');\n    }\n    if (layout) {\n      // controlled layout\n      this.state = {\n        layout: DockLayout.loadLayoutData(layout, props),\n        dropRect: null\n      };\n    } else {\n      this.state = {\n        layout: preparedLayout,\n        dropRect: null\n      };\n    }\n    DragManager.addDragStateListener(this.onDragStateChange);\n    window.addEventListener('resize', this._onWindowResize);\n  }\n  /** @ignore */\n  getRootElement() {\n    return this._ref;\n  }\n  /** @ignore */\n  prepareInitData(data) {\n    let layout = Object.assign({}, data);\n    Algorithm.fixLayoutData(layout, this.props.loadTab);\n    return layout;\n  }\n  /** @ignore */\n  getDockId() {\n    return this.props.dockId || this;\n  }\n  /** @inheritDoc */\n  getGroup(name) {\n    if (name) {\n      let {\n        groups\n      } = this.props;\n      if (groups && name in groups) {\n        return groups[name];\n      }\n      if (name === placeHolderStyle) {\n        return placeHolderGroup;\n      }\n    }\n    return defaultGroup;\n  }\n  /**\n   * @inheritDoc\n   * @param source @inheritDoc\n   * @param target @inheritDoc\n   * @param direction @inheritDoc\n   */\n  dockMove(source, target, direction) {\n    let layout = this.getLayout();\n    if (direction === 'maximize') {\n      layout = Algorithm.maximize(layout, source);\n      this.panelToFocus = source.id;\n    } else if (direction === 'front') {\n      layout = Algorithm.moveToFront(layout, source);\n    } else {\n      layout = Algorithm.removeFromLayout(layout, source);\n    }\n    if (typeof target === 'string') {\n      target = this.find(target, Algorithm.Filter.All);\n    } else {\n      target = Algorithm.getUpdatedObject(target); // target might change during removeTab\n    }\n\n    if (direction === 'float') {\n      let newPanel = Algorithm.converToPanel(source);\n      newPanel.z = Algorithm.nextZIndex(null);\n      if (this.state.dropRect) {\n        layout = Algorithm.floatPanel(layout, newPanel, this.state.dropRect);\n      } else {\n        layout = Algorithm.floatPanel(layout, newPanel);\n        if (this._ref) {\n          layout = Algorithm.fixFloatPanelPos(layout, this._ref.offsetWidth, this._ref.offsetHeight);\n        }\n      }\n    } else if (direction === 'new-window') {\n      let newPanel = Algorithm.converToPanel(source);\n      layout = Algorithm.panelToWindow(layout, newPanel);\n    } else if (target) {\n      if ('tabs' in target) {\n        // pandel target\n        if (direction === 'middle') {\n          layout = Algorithm.addTabToPanel(layout, source, target);\n        } else {\n          let newPanel = Algorithm.converToPanel(source);\n          layout = Algorithm.dockPanelToPanel(layout, newPanel, target, direction);\n        }\n      } else if ('children' in target) {\n        // box target\n        let newPanel = Algorithm.converToPanel(source);\n        layout = Algorithm.dockPanelToBox(layout, newPanel, target, direction);\n      } else {\n        // tab target\n        layout = Algorithm.addNextToTab(layout, source, target, direction);\n      }\n    }\n    if (layout !== this.getLayout()) {\n      layout = Algorithm.fixLayoutData(layout);\n      let currentTabId = null;\n      if (source.hasOwnProperty('tabs')) {\n        currentTabId = source.activeId;\n      } else {\n        // when source is tab\n        currentTabId = source.id;\n      }\n      this.changeLayout(layout, currentTabId, direction);\n    }\n    this.onDragStateChange(false);\n  }\n  /** @inheritDoc */\n  find(id, filter) {\n    return Algorithm.find(this.getLayout(), id, filter);\n  }\n  /** @ignore */\n  getLayoutSize() {\n    if (this._ref) {\n      return {\n        width: this._ref.offsetWidth,\n        height: this._ref.offsetHeight\n      };\n    }\n    return {\n      width: 0,\n      height: 0\n    };\n  }\n  /** @inheritDoc */\n  updateTab(id, newTab) {\n    let makeActive = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    let tab = this.find(id, Algorithm.Filter.AnyTab);\n    if (tab) {\n      let panelData = tab.parent;\n      let idx = panelData.tabs.indexOf(tab);\n      if (idx >= 0) {\n        let {\n          loadTab\n        } = this.props;\n        let layout = this.getLayout();\n        let activeId = panelData.activeId;\n        if (newTab) {\n          if (loadTab && !('content' in newTab && 'title' in newTab)) {\n            newTab = loadTab(newTab);\n          }\n          layout = Algorithm.removeFromLayout(layout, tab); // remove old tab\n          panelData = Algorithm.getUpdatedObject(panelData); // panelData might change during removeTab\n          layout = Algorithm.addTabToPanel(layout, newTab, panelData, idx); // add new tab\n          panelData = Algorithm.getUpdatedObject(panelData); // panelData might change during addTabToPanel\n        }\n\n        if (!makeActive) {\n          panelData.activeId = activeId;\n          this.panelToFocus = panelData.id;\n        }\n        layout = Algorithm.fixLayoutData(layout);\n        this.changeLayout(layout, newTab.id, 'update');\n        return true;\n      }\n    }\n    return false;\n  }\n  /** @inheritDoc */\n  navigateToPanel(fromElement, direction) {\n    if (!direction) {\n      if (!fromElement) {\n        fromElement = this._ref.querySelector('.dock-tab-active>.dock-tab-btn');\n      }\n      fromElement.focus();\n      return;\n    }\n    let targetTab;\n    // use panel rect when move left/right, and use tabbar rect for up/down\n    let selector = direction === 'ArrowUp' || direction === 'ArrowDown' ? '.dock>.dock-bar' : '.dock-box>.dock-panel';\n    let panels = Array.from(this._ref.querySelectorAll(selector));\n    let currentPanel = panels.find(panel => panel.contains(fromElement));\n    let currentRect = currentPanel.getBoundingClientRect();\n    let matches = [];\n    for (let panel of panels) {\n      if (panel !== currentPanel) {\n        let rect = panel.getBoundingClientRect();\n        let distance = Algorithm.findNearestPanel(currentRect, rect, direction);\n        if (distance >= 0) {\n          matches.push({\n            panel,\n            rect,\n            distance\n          });\n        }\n      }\n    }\n    matches.sort((a, b) => a.distance - b.distance);\n    for (let match of matches) {\n      targetTab = match.panel.querySelector('.dock-tab-active>.dock-tab-btn');\n      if (targetTab) {\n        break;\n      }\n    }\n    if (targetTab) {\n      targetTab.focus();\n    }\n  }\n  /** @ignore */\n  useEdgeDrop() {\n    return this.props.dropMode === 'edge';\n  }\n  /** @ignore */\n  setDropRect(element, direction, source, event) {\n    let panelSize = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [300, 300];\n    let {\n      dropRect\n    } = this.state;\n    if (dropRect) {\n      if (direction === 'remove') {\n        if (dropRect.source === source) {\n          this.setState({\n            dropRect: null\n          });\n        }\n        return;\n      } else if (dropRect.element === element && dropRect.direction === direction && direction !== 'float') {\n        // skip duplicated update except for float dragging\n        return;\n      }\n    }\n    if (!element) {\n      this.setState({\n        dropRect: null\n      });\n      return;\n    }\n    let layoutRect = this._ref.getBoundingClientRect();\n    let scaleX = this._ref.offsetWidth / layoutRect.width;\n    let scaleY = this._ref.offsetHeight / layoutRect.height;\n    let elemRect = element.getBoundingClientRect();\n    let left = (elemRect.left - layoutRect.left) * scaleX;\n    let top = (elemRect.top - layoutRect.top) * scaleY;\n    let width = elemRect.width * scaleX;\n    let height = elemRect.height * scaleY;\n    let ratio = 0.5;\n    if (element.classList.contains('dock-box')) {\n      ratio = 0.3;\n    }\n    switch (direction) {\n      case 'float':\n        {\n          let x = (event.clientX - layoutRect.left) * scaleX;\n          let y = (event.clientY - layoutRect.top) * scaleY;\n          top = y - 15;\n          width = panelSize[0];\n          height = panelSize[1];\n          left = x - (width >> 1);\n          break;\n        }\n      case 'right':\n        left += width * (1 - ratio);\n      case 'left':\n        // tslint:disable-line no-switch-case-fall-through\n        width *= ratio;\n        break;\n      case 'bottom':\n        top += height * (1 - ratio);\n      case 'top':\n        // tslint:disable-line no-switch-case-fall-through\n        height *= ratio;\n        break;\n      case 'after-tab':\n        left += width - 15;\n        width = 30;\n        break;\n      case 'before-tab':\n        left -= 15;\n        width = 30;\n        break;\n    }\n    this.setState({\n      dropRect: {\n        left,\n        top,\n        width,\n        height,\n        element,\n        source,\n        direction\n      }\n    });\n  }\n  /** @ignore */\n  render() {\n    // clear tempLayout\n    this.tempLayout = null;\n    let {\n      style,\n      maximizeTo\n    } = this.props;\n    let {\n      layout,\n      dropRect\n    } = this.state;\n    let dropRectStyle;\n    if (dropRect) {\n      let {\n          element,\n          direction\n        } = dropRect,\n        rect = __rest(dropRect, [\"element\", \"direction\"]);\n      dropRectStyle = Object.assign(Object.assign({}, rect), {\n        display: 'block'\n      });\n      if (direction === 'float') {\n        dropRectStyle.transition = 'none';\n      }\n    }\n    let maximize;\n    // if (layout.maxbox && layout.maxbox.children.length === 1) {\n    if (maximizeTo) {\n      if (typeof maximizeTo === 'string') {\n        maximizeTo = document.getElementById(maximizeTo);\n      }\n      maximize = ReactDOM.createPortal(React.createElement(MaxBox, {\n        boxData: layout.maxbox\n      }), maximizeTo);\n    } else {\n      maximize = React.createElement(MaxBox, {\n        boxData: layout.maxbox\n      });\n    }\n    // }\n    let portals = [];\n    for (let [key, cache] of this._caches) {\n      if (cache.portal) {\n        portals.push(cache.portal);\n      }\n    }\n    return React.createElement(\"div\", {\n      ref: this.getRef,\n      className: \"dock-layout\",\n      style: style\n    }, React.createElement(DockContextProvider, {\n      value: this\n    }, React.createElement(DockBox, {\n      size: 1,\n      boxData: layout.dockbox\n    }), React.createElement(FloatBox, {\n      boxData: layout.floatbox\n    }), React.createElement(WindowBox, {\n      boxData: layout.windowbox\n    }), maximize, portals), React.createElement(\"div\", {\n      className: \"dock-drop-indicator\",\n      style: dropRectStyle\n    }));\n  }\n  /** @ignore\n   * move focus to panelToFocus\n   */\n  componentDidUpdate(prevProps, prevState, snapshot) {\n    var _a;\n    if (this.panelToFocus) {\n      let panel = this._ref.querySelector(`.dock-panel[data-dockid=\"${this.panelToFocus}\"]`);\n      if (panel && !panel.contains(this._ref.ownerDocument.activeElement)) {\n        (_a = panel.querySelector('.dock-bar')) === null || _a === void 0 ? void 0 : _a.focus();\n      }\n      this.panelToFocus = null;\n    }\n  }\n  /** @ignore */\n  componentWillUnmount() {\n    window.removeEventListener('resize', this._onWindowResize);\n    DragManager.removeDragStateListener(this.onDragStateChange);\n    this._onWindowResize.cancel();\n  }\n  setLayout(layout) {\n    this.tempLayout = layout;\n    this.setState({\n      layout\n    });\n  }\n  getLayout() {\n    return this.tempLayout || this.state.layout;\n  }\n  /** @ignore\n   * change layout\n   */\n  changeLayout(layoutData, currentTabId, direction) {\n    let silent = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    let {\n      layout,\n      onLayoutChange\n    } = this.props;\n    let savedLayout;\n    if (onLayoutChange) {\n      savedLayout = Serializer.saveLayoutData(layoutData, this.props.saveTab, this.props.afterPanelSaved);\n      layoutData.loadedFrom = savedLayout;\n      onLayoutChange(savedLayout, currentTabId, direction);\n      if (layout) {\n        // if layout prop is defined, we need to force an update to make sure it's either updated or reverted back\n        this.forceUpdate();\n      }\n    }\n    if (!layout && !silent) {\n      // uncontrolled layout when Props.layout is not defined\n      this.setLayout(layoutData);\n    }\n  }\n  /** @ignore\n   * some layout change were handled by component silently\n   * but they should still call this function to trigger onLayoutChange\n   */\n  onSilentChange() {\n    let currentTabId = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    let direction = arguments.length > 1 ? arguments[1] : undefined;\n    let {\n      onLayoutChange\n    } = this.props;\n    if (onLayoutChange) {\n      let layout = this.getLayout();\n      this.changeLayout(layout, currentTabId, direction, true);\n    }\n  }\n  // public api\n  saveLayout() {\n    return Serializer.saveLayoutData(this.getLayout(), this.props.saveTab, this.props.afterPanelSaved);\n  }\n  /**\n   * load layout\n   * calling this api won't trigger the [[LayoutProps.onLayoutChange]] callback\n   */\n  loadLayout(savedLayout) {\n    this.setLayout(DockLayout.loadLayoutData(savedLayout, this.props, this._ref.offsetWidth, this._ref.offsetHeight));\n  }\n  /** @ignore */\n  static loadLayoutData(savedLayout, props) {\n    let width = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    let height = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n    let {\n      defaultLayout,\n      loadTab,\n      afterPanelLoaded\n    } = props;\n    let layout = Serializer.loadLayoutData(savedLayout, defaultLayout, loadTab, afterPanelLoaded);\n    layout = Algorithm.fixFloatPanelPos(layout, width, height);\n    layout = Algorithm.fixLayoutData(layout);\n    layout.loadedFrom = savedLayout;\n    return layout;\n  }\n  static getDerivedStateFromProps(props, state) {\n    let {\n      layout: layoutToLoad\n    } = props;\n    let {\n      layout: currentLayout\n    } = state;\n    if (layoutToLoad && layoutToLoad !== currentLayout.loadedFrom) {\n      // auto reload on layout prop change\n      return {\n        layout: DockLayout.loadLayoutData(layoutToLoad, props)\n      };\n    }\n    return null;\n  }\n}","map":{"version":3,"names":["__rest","s","e","t","p","Object","prototype","hasOwnProperty","call","indexOf","getOwnPropertySymbols","i","length","propertyIsEnumerable","React","ReactDOM","debounce","defaultGroup","DockContextProvider","placeHolderGroup","placeHolderStyle","DockBox","FloatBox","DockPanel","Algorithm","Serializer","DragManager","MaxBox","WindowBox","DockPortalManager","PureComponent","constructor","arguments","_caches","Map","destroyRemovedPane","_pendingDestroy","cacheRemoved","id","cache","owner","delete","forceUpdate","getTabCache","get","div","document","createElement","className","set","removeTabCache","setTimeout","updateTabCache","children","portal","createPortal","DockLayout","props","getRef","r","_ref","onDragStateChange","draggingScope","droppingPanel","state","dropRect","setState","_onWindowResize","layout","getLayout","newLayout","fixFloatPanelPos","offsetWidth","offsetHeight","fixLayoutData","changeLayout","defaultLayout","loadTab","preparedLayout","prepareInitData","Error","loadLayoutData","addDragStateListener","window","addEventListener","getRootElement","data","assign","getDockId","dockId","getGroup","name","groups","dockMove","source","target","direction","maximize","panelToFocus","moveToFront","removeFromLayout","find","Filter","All","getUpdatedObject","newPanel","converToPanel","z","nextZIndex","floatPanel","panelToWindow","addTabToPanel","dockPanelToPanel","dockPanelToBox","addNextToTab","currentTabId","activeId","filter","getLayoutSize","width","height","updateTab","newTab","makeActive","undefined","tab","AnyTab","panelData","parent","idx","tabs","navigateToPanel","fromElement","querySelector","focus","targetTab","selector","panels","Array","from","querySelectorAll","currentPanel","panel","contains","currentRect","getBoundingClientRect","matches","rect","distance","findNearestPanel","push","sort","a","b","match","useEdgeDrop","dropMode","setDropRect","element","event","panelSize","layoutRect","scaleX","scaleY","elemRect","left","top","ratio","classList","x","clientX","y","clientY","render","tempLayout","style","maximizeTo","dropRectStyle","display","transition","getElementById","boxData","maxbox","portals","key","ref","value","size","dockbox","floatbox","windowbox","componentDidUpdate","prevProps","prevState","snapshot","_a","ownerDocument","activeElement","componentWillUnmount","removeEventListener","removeDragStateListener","cancel","setLayout","layoutData","silent","onLayoutChange","savedLayout","saveLayoutData","saveTab","afterPanelSaved","loadedFrom","onSilentChange","saveLayout","loadLayout","afterPanelLoaded","getDerivedStateFromProps","layoutToLoad","currentLayout"],"sources":["C:/d/Programming/web/jodel-mde/node_modules/rc-dock/es/DockLayout.js"],"sourcesContent":["var __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nimport React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport debounce from 'lodash/debounce';\nimport { defaultGroup, DockContextProvider, placeHolderGroup, placeHolderStyle } from \"./DockData\";\nimport { DockBox } from \"./DockBox\";\nimport { FloatBox } from \"./FloatBox\";\nimport { DockPanel } from \"./DockPanel\";\nimport * as Algorithm from \"./Algorithm\";\nimport * as Serializer from \"./Serializer\";\nimport * as DragManager from \"./dragdrop/DragManager\";\nimport { MaxBox } from \"./MaxBox\";\nimport { WindowBox } from \"./WindowBox\";\nclass DockPortalManager extends React.PureComponent {\n    constructor() {\n        super(...arguments);\n        /** @ignore */\n        this._caches = new Map();\n        this.destroyRemovedPane = () => {\n            this._pendingDestroy = null;\n            let cacheRemoved = false;\n            for (let [id, cache] of this._caches) {\n                if (cache.owner == null) {\n                    this._caches.delete(id);\n                    cacheRemoved = true;\n                }\n            }\n            if (cacheRemoved) {\n                this.forceUpdate();\n            }\n        };\n    }\n    /** @ignore */\n    getTabCache(id, owner) {\n        let cache = this._caches.get(id);\n        if (!cache) {\n            let div = document.createElement('div');\n            div.className = 'dock-pane-cache';\n            cache = { div, id, owner };\n            this._caches.set(id, cache);\n        }\n        else {\n            cache.owner = owner;\n        }\n        return cache;\n    }\n    /** @ignore */\n    removeTabCache(id, owner) {\n        let cache = this._caches.get(id);\n        if (cache && cache.owner === owner) {\n            cache.owner = null;\n            if (!this._pendingDestroy) {\n                // it could be reused by another component, so let's wait\n                this._pendingDestroy = setTimeout(this.destroyRemovedPane, 1);\n            }\n        }\n    }\n    /** @ignore */\n    updateTabCache(id, children) {\n        let cache = this._caches.get(id);\n        if (cache) {\n            cache.portal = ReactDOM.createPortal(children, cache.div, cache.id);\n            this.forceUpdate();\n        }\n    }\n}\nexport class DockLayout extends DockPortalManager {\n    constructor(props) {\n        super(props);\n        /** @ignore */\n        this.getRef = (r) => {\n            this._ref = r;\n        };\n        /** @ignore */\n        this.onDragStateChange = (draggingScope) => {\n            if (draggingScope == null) {\n                DockPanel.droppingPanel = null;\n                if (this.state.dropRect) {\n                    this.setState({ dropRect: null });\n                }\n            }\n        };\n        this._onWindowResize = debounce(() => {\n            let layout = this.getLayout();\n            if (this._ref) {\n                let newLayout = Algorithm.fixFloatPanelPos(layout, this._ref.offsetWidth, this._ref.offsetHeight);\n                if (layout !== newLayout) {\n                    newLayout = Algorithm.fixLayoutData(newLayout); // panel parent might need a fix\n                    this.changeLayout(newLayout, null, 'move');\n                }\n            }\n        }, 200);\n        let { layout, defaultLayout, loadTab } = props;\n        let preparedLayout;\n        if (defaultLayout) {\n            preparedLayout = this.prepareInitData(props.defaultLayout);\n        }\n        else if (!loadTab) {\n            throw new Error('DockLayout.loadTab and DockLayout.defaultLayout should not both be undefined.');\n        }\n        if (layout) {\n            // controlled layout\n            this.state = {\n                layout: DockLayout.loadLayoutData(layout, props),\n                dropRect: null,\n            };\n        }\n        else {\n            this.state = {\n                layout: preparedLayout,\n                dropRect: null,\n            };\n        }\n        DragManager.addDragStateListener(this.onDragStateChange);\n        window.addEventListener('resize', this._onWindowResize);\n    }\n    /** @ignore */\n    getRootElement() {\n        return this._ref;\n    }\n    /** @ignore */\n    prepareInitData(data) {\n        let layout = Object.assign({}, data);\n        Algorithm.fixLayoutData(layout, this.props.loadTab);\n        return layout;\n    }\n    /** @ignore */\n    getDockId() {\n        return this.props.dockId || this;\n    }\n    /** @inheritDoc */\n    getGroup(name) {\n        if (name) {\n            let { groups } = this.props;\n            if (groups && name in groups) {\n                return groups[name];\n            }\n            if (name === placeHolderStyle) {\n                return placeHolderGroup;\n            }\n        }\n        return defaultGroup;\n    }\n    /**\n     * @inheritDoc\n     * @param source @inheritDoc\n     * @param target @inheritDoc\n     * @param direction @inheritDoc\n     */\n    dockMove(source, target, direction) {\n        let layout = this.getLayout();\n        if (direction === 'maximize') {\n            layout = Algorithm.maximize(layout, source);\n            this.panelToFocus = source.id;\n        }\n        else if (direction === 'front') {\n            layout = Algorithm.moveToFront(layout, source);\n        }\n        else {\n            layout = Algorithm.removeFromLayout(layout, source);\n        }\n        if (typeof target === 'string') {\n            target = this.find(target, Algorithm.Filter.All);\n        }\n        else {\n            target = Algorithm.getUpdatedObject(target); // target might change during removeTab\n        }\n        if (direction === 'float') {\n            let newPanel = Algorithm.converToPanel(source);\n            newPanel.z = Algorithm.nextZIndex(null);\n            if (this.state.dropRect) {\n                layout = Algorithm.floatPanel(layout, newPanel, this.state.dropRect);\n            }\n            else {\n                layout = Algorithm.floatPanel(layout, newPanel);\n                if (this._ref) {\n                    layout = Algorithm.fixFloatPanelPos(layout, this._ref.offsetWidth, this._ref.offsetHeight);\n                }\n            }\n        }\n        else if (direction === 'new-window') {\n            let newPanel = Algorithm.converToPanel(source);\n            layout = Algorithm.panelToWindow(layout, newPanel);\n        }\n        else if (target) {\n            if ('tabs' in target) {\n                // pandel target\n                if (direction === 'middle') {\n                    layout = Algorithm.addTabToPanel(layout, source, target);\n                }\n                else {\n                    let newPanel = Algorithm.converToPanel(source);\n                    layout = Algorithm.dockPanelToPanel(layout, newPanel, target, direction);\n                }\n            }\n            else if ('children' in target) {\n                // box target\n                let newPanel = Algorithm.converToPanel(source);\n                layout = Algorithm.dockPanelToBox(layout, newPanel, target, direction);\n            }\n            else {\n                // tab target\n                layout = Algorithm.addNextToTab(layout, source, target, direction);\n            }\n        }\n        if (layout !== this.getLayout()) {\n            layout = Algorithm.fixLayoutData(layout);\n            let currentTabId = null;\n            if (source.hasOwnProperty('tabs')) {\n                currentTabId = source.activeId;\n            }\n            else {\n                // when source is tab\n                currentTabId = source.id;\n            }\n            this.changeLayout(layout, currentTabId, direction);\n        }\n        this.onDragStateChange(false);\n    }\n    /** @inheritDoc */\n    find(id, filter) {\n        return Algorithm.find(this.getLayout(), id, filter);\n    }\n    /** @ignore */\n    getLayoutSize() {\n        if (this._ref) {\n            return { width: this._ref.offsetWidth, height: this._ref.offsetHeight };\n        }\n        return { width: 0, height: 0 };\n    }\n    /** @inheritDoc */\n    updateTab(id, newTab, makeActive = true) {\n        let tab = this.find(id, Algorithm.Filter.AnyTab);\n        if (tab) {\n            let panelData = tab.parent;\n            let idx = panelData.tabs.indexOf(tab);\n            if (idx >= 0) {\n                let { loadTab } = this.props;\n                let layout = this.getLayout();\n                let activeId = panelData.activeId;\n                if (newTab) {\n                    if (loadTab && !('content' in newTab && 'title' in newTab)) {\n                        newTab = loadTab(newTab);\n                    }\n                    layout = Algorithm.removeFromLayout(layout, tab); // remove old tab\n                    panelData = Algorithm.getUpdatedObject(panelData); // panelData might change during removeTab\n                    layout = Algorithm.addTabToPanel(layout, newTab, panelData, idx); // add new tab\n                    panelData = Algorithm.getUpdatedObject(panelData); // panelData might change during addTabToPanel\n                }\n                if (!makeActive) {\n                    panelData.activeId = activeId;\n                    this.panelToFocus = panelData.id;\n                }\n                layout = Algorithm.fixLayoutData(layout);\n                this.changeLayout(layout, newTab.id, 'update');\n                return true;\n            }\n        }\n        return false;\n    }\n    /** @inheritDoc */\n    navigateToPanel(fromElement, direction) {\n        if (!direction) {\n            if (!fromElement) {\n                fromElement = this._ref.querySelector('.dock-tab-active>.dock-tab-btn');\n            }\n            fromElement.focus();\n            return;\n        }\n        let targetTab;\n        // use panel rect when move left/right, and use tabbar rect for up/down\n        let selector = (direction === 'ArrowUp' || direction === 'ArrowDown') ?\n            '.dock>.dock-bar' : '.dock-box>.dock-panel';\n        let panels = Array.from(this._ref.querySelectorAll(selector));\n        let currentPanel = panels.find((panel) => panel.contains(fromElement));\n        let currentRect = currentPanel.getBoundingClientRect();\n        let matches = [];\n        for (let panel of panels) {\n            if (panel !== currentPanel) {\n                let rect = panel.getBoundingClientRect();\n                let distance = Algorithm.findNearestPanel(currentRect, rect, direction);\n                if (distance >= 0) {\n                    matches.push({ panel, rect, distance });\n                }\n            }\n        }\n        matches.sort((a, b) => a.distance - b.distance);\n        for (let match of matches) {\n            targetTab = match.panel.querySelector('.dock-tab-active>.dock-tab-btn');\n            if (targetTab) {\n                break;\n            }\n        }\n        if (targetTab) {\n            targetTab.focus();\n        }\n    }\n    /** @ignore */\n    useEdgeDrop() {\n        return this.props.dropMode === 'edge';\n    }\n    /** @ignore */\n    setDropRect(element, direction, source, event, panelSize = [300, 300]) {\n        let { dropRect } = this.state;\n        if (dropRect) {\n            if (direction === 'remove') {\n                if (dropRect.source === source) {\n                    this.setState({ dropRect: null });\n                }\n                return;\n            }\n            else if (dropRect.element === element && dropRect.direction === direction && direction !== 'float') {\n                // skip duplicated update except for float dragging\n                return;\n            }\n        }\n        if (!element) {\n            this.setState({ dropRect: null });\n            return;\n        }\n        let layoutRect = this._ref.getBoundingClientRect();\n        let scaleX = this._ref.offsetWidth / layoutRect.width;\n        let scaleY = this._ref.offsetHeight / layoutRect.height;\n        let elemRect = element.getBoundingClientRect();\n        let left = (elemRect.left - layoutRect.left) * scaleX;\n        let top = (elemRect.top - layoutRect.top) * scaleY;\n        let width = elemRect.width * scaleX;\n        let height = elemRect.height * scaleY;\n        let ratio = 0.5;\n        if (element.classList.contains('dock-box')) {\n            ratio = 0.3;\n        }\n        switch (direction) {\n            case 'float': {\n                let x = (event.clientX - layoutRect.left) * scaleX;\n                let y = (event.clientY - layoutRect.top) * scaleY;\n                top = y - 15;\n                width = panelSize[0];\n                height = panelSize[1];\n                left = x - (width >> 1);\n                break;\n            }\n            case 'right':\n                left += width * (1 - ratio);\n            case 'left': // tslint:disable-line no-switch-case-fall-through\n                width *= ratio;\n                break;\n            case 'bottom':\n                top += height * (1 - ratio);\n            case 'top': // tslint:disable-line no-switch-case-fall-through\n                height *= ratio;\n                break;\n            case 'after-tab':\n                left += width - 15;\n                width = 30;\n                break;\n            case 'before-tab':\n                left -= 15;\n                width = 30;\n                break;\n        }\n        this.setState({ dropRect: { left, top, width, height, element, source, direction } });\n    }\n    /** @ignore */\n    render() {\n        // clear tempLayout\n        this.tempLayout = null;\n        let { style, maximizeTo } = this.props;\n        let { layout, dropRect } = this.state;\n        let dropRectStyle;\n        if (dropRect) {\n            let { element, direction } = dropRect, rect = __rest(dropRect, [\"element\", \"direction\"]);\n            dropRectStyle = Object.assign(Object.assign({}, rect), { display: 'block' });\n            if (direction === 'float') {\n                dropRectStyle.transition = 'none';\n            }\n        }\n        let maximize;\n        // if (layout.maxbox && layout.maxbox.children.length === 1) {\n        if (maximizeTo) {\n            if (typeof maximizeTo === 'string') {\n                maximizeTo = document.getElementById(maximizeTo);\n            }\n            maximize = ReactDOM.createPortal(React.createElement(MaxBox, { boxData: layout.maxbox }), maximizeTo);\n        }\n        else {\n            maximize = React.createElement(MaxBox, { boxData: layout.maxbox });\n        }\n        // }\n        let portals = [];\n        for (let [key, cache] of this._caches) {\n            if (cache.portal) {\n                portals.push(cache.portal);\n            }\n        }\n        return (React.createElement(\"div\", { ref: this.getRef, className: \"dock-layout\", style: style },\n            React.createElement(DockContextProvider, { value: this },\n                React.createElement(DockBox, { size: 1, boxData: layout.dockbox }),\n                React.createElement(FloatBox, { boxData: layout.floatbox }),\n                React.createElement(WindowBox, { boxData: layout.windowbox }),\n                maximize,\n                portals),\n            React.createElement(\"div\", { className: \"dock-drop-indicator\", style: dropRectStyle })));\n    }\n    /** @ignore\n     * move focus to panelToFocus\n     */\n    componentDidUpdate(prevProps, prevState, snapshot) {\n        var _a;\n        if (this.panelToFocus) {\n            let panel = this._ref.querySelector(`.dock-panel[data-dockid=\"${this.panelToFocus}\"]`);\n            if (panel && !panel.contains(this._ref.ownerDocument.activeElement)) {\n                (_a = panel.querySelector('.dock-bar')) === null || _a === void 0 ? void 0 : _a.focus();\n            }\n            this.panelToFocus = null;\n        }\n    }\n    /** @ignore */\n    componentWillUnmount() {\n        window.removeEventListener('resize', this._onWindowResize);\n        DragManager.removeDragStateListener(this.onDragStateChange);\n        this._onWindowResize.cancel();\n    }\n    setLayout(layout) {\n        this.tempLayout = layout;\n        this.setState({ layout });\n    }\n    getLayout() {\n        return this.tempLayout || this.state.layout;\n    }\n    /** @ignore\n     * change layout\n     */\n    changeLayout(layoutData, currentTabId, direction, silent = false) {\n        let { layout, onLayoutChange } = this.props;\n        let savedLayout;\n        if (onLayoutChange) {\n            savedLayout = Serializer.saveLayoutData(layoutData, this.props.saveTab, this.props.afterPanelSaved);\n            layoutData.loadedFrom = savedLayout;\n            onLayoutChange(savedLayout, currentTabId, direction);\n            if (layout) {\n                // if layout prop is defined, we need to force an update to make sure it's either updated or reverted back\n                this.forceUpdate();\n            }\n        }\n        if (!layout && !silent) {\n            // uncontrolled layout when Props.layout is not defined\n            this.setLayout(layoutData);\n        }\n    }\n    /** @ignore\n     * some layout change were handled by component silently\n     * but they should still call this function to trigger onLayoutChange\n     */\n    onSilentChange(currentTabId = null, direction) {\n        let { onLayoutChange } = this.props;\n        if (onLayoutChange) {\n            let layout = this.getLayout();\n            this.changeLayout(layout, currentTabId, direction, true);\n        }\n    }\n    // public api\n    saveLayout() {\n        return Serializer.saveLayoutData(this.getLayout(), this.props.saveTab, this.props.afterPanelSaved);\n    }\n    /**\n     * load layout\n     * calling this api won't trigger the [[LayoutProps.onLayoutChange]] callback\n     */\n    loadLayout(savedLayout) {\n        this.setLayout(DockLayout.loadLayoutData(savedLayout, this.props, this._ref.offsetWidth, this._ref.offsetHeight));\n    }\n    /** @ignore */\n    static loadLayoutData(savedLayout, props, width = 0, height = 0) {\n        let { defaultLayout, loadTab, afterPanelLoaded } = props;\n        let layout = Serializer.loadLayoutData(savedLayout, defaultLayout, loadTab, afterPanelLoaded);\n        layout = Algorithm.fixFloatPanelPos(layout, width, height);\n        layout = Algorithm.fixLayoutData(layout);\n        layout.loadedFrom = savedLayout;\n        return layout;\n    }\n    static getDerivedStateFromProps(props, state) {\n        let { layout: layoutToLoad } = props;\n        let { layout: currentLayout } = state;\n        if (layoutToLoad && layoutToLoad !== currentLayout.loadedFrom) {\n            // auto reload on layout prop change\n            return {\n                layout: DockLayout.loadLayoutData(layoutToLoad, props),\n            };\n        }\n        return null;\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}