{"ast":null,"code":"import _objectSpread from\"C:/d/Programming/web/jodel-mde/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2\";import _toConsumableArray from\"C:/d/Programming/web/jodel-mde/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";import _createForOfIteratorHelper from\"C:/d/Programming/web/jodel-mde/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";import _classCallCheck from\"C:/d/Programming/web/jodel-mde/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";import _createClass from\"C:/d/Programming/web/jodel-mde/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";var _dec,_class,_class2;import{LUser,DUser,DViewElement,DPointerTargetable,DModel,DModelElement,OCL,Log,LPointerTargetable,RuntimeAccessible,RuntimeAccessibleClass,store,U,toShortEType,NodeTransientProperties,transientProperties,ViewEClassMatch}from\"../../joiner\";import{ShortDefaultEClasses,toShortEClass}from\"../../common/U\";export var Selectors=(_dec=RuntimeAccessible('Selectors'),_dec(_class=(_class2=/*#__PURE__*/function(){function Selectors(){_classCallCheck(this,Selectors);}_createClass(Selectors,null,[{key:\"getActiveModel\",value:function getActiveModel(){var _state$_lastSelected;var metamodel;var state=store.getState();var selected=(_state$_lastSelected=state._lastSelected)===null||_state$_lastSelected===void 0?void 0:_state$_lastSelected.modelElement;if(selected){var me=LPointerTargetable.fromPointer(selected);metamodel=me?me.model:null;}else metamodel=null;return metamodel;}},{key:\"getLastSelectedModel\",value:function getLastSelectedModel(state){var _state$_lastSelected2;state=state||store.getState();var me=(_state$_lastSelected2=state._lastSelected)===null||_state$_lastSelected2===void 0?void 0:_state$_lastSelected2.modelElement;if(!me)return{};var ret={element:LPointerTargetable.fromPointer(me,state)};ret.model=ret.element.model;if(ret.model.isMetamodel)ret.m2=ret.model;else{ret.m1=ret.model;ret.m2=ret.m1.instanceof;}return ret;}},{key:\"getAllViewElements\",value:function getAllViewElements(state0){// return Object.values(store.getState().idlookup).filter(v => v.className === DViewElement.name) as DViewElement[];\nvar state=state0||store.getState();var ptrs=Object.values(state.viewelements);var views=ptrs.map(function(ptr){return DPointerTargetable.fromPointer(ptr,state);});return views;}//Giordano: start\n},{key:\"getViewpoints\",value:function getViewpoints(){var state=store.getState();return LPointerTargetable.fromPointer(state.viewpoints);}},{key:\"getViewpoint\",value:function getViewpoint(){var state=store.getState();return LPointerTargetable.fromPointer(state.viewpoint);}},{key:\"getObjects\",value:function getObjects(){var state=store.getState();var ptrs=Object.values(state.objects);var dObjects=ptrs.map(function(ptr){return state.idlookup[ptr];});var lObjects=[];var _iterator=_createForOfIteratorHelper(dObjects),_step;try{for(_iterator.s();!(_step=_iterator.n()).done;){var dObject=_step.value;lObjects.push(LPointerTargetable.fromPointer(dObject.id));}}catch(err){_iterator.e(err);}finally{_iterator.f();}return lObjects;}},{key:\"getValues\",value:function getValues(){var state=store.getState();var ptrs=Object.values(state.values);var dValues=ptrs.map(function(ptr){return state.idlookup[ptr];});var lValues=[];var _iterator2=_createForOfIteratorHelper(dValues),_step2;try{for(_iterator2.s();!(_step2=_iterator2.n()).done;){var dValue=_step2.value;if(dValue===null||dValue===void 0?void 0:dValue.id){lValues.push(LPointerTargetable.fromPointer(dValue.id));}}}catch(err){_iterator2.e(err);}finally{_iterator2.f();}return lValues;}},{key:\"getDeleted\",value:function getDeleted(){var state=store.getState();return state.deleted;}},{key:\"getState\",value:function getState(){var state=store.getState();return state;}},{key:\"getDefaultEcoreClass\",value:function getDefaultEcoreClass(type,state){var shorttype=(toShortEClass(type)||type).toUpperCase();if(!state)state=store.getState();// todo: make other m3 classes and make this generic like getPrimitiveType\nreturn state.idlookup[\"Pointer_\"+ShortDefaultEClasses.EObject.toUpperCase()];}},{key:\"getPrimitiveType\",value:function getPrimitiveType(type,state){var shorttype=(toShortEType(type)||type).toUpperCase();if(!state)state=store.getState();return state.idlookup[\"Pointer_\"+shorttype];}},{key:\"getAllPrimitiveTypes\",value:function getAllPrimitiveTypes(){var state=store.getState();var ptrs=Object.values(state.primitiveTypes);var classifiers=ptrs.map(function(ptr){return state.idlookup[ptr];});return classifiers;}},{key:\"getFirstPrimitiveTypes\",value:function getFirstPrimitiveTypes(){return Selectors.getAllPrimitiveTypes()[0];}},{key:\"getRefEdges\",value:function getRefEdges(){var state=store.getState();var pointers=Object.values(state.refEdges);var dRefEdges=pointers.map(function(ptr){return state.idlookup[ptr];});return dRefEdges;}},{key:\"getField\",value:function getField(field){var state=store.getState();var pointers=Object.values(state[field]);return pointers;}},{key:\"getAllAttributes\",value:function getAllAttributes(){var state=store.getState();return Object.values(state.attributes);}},{key:\"getAllEnumLiterals\",value:function getAllEnumLiterals(){var state=store.getState();return Object.values(state.enumliterals);}},{key:\"getAllReferences\",value:function getAllReferences(){var state=store.getState();return Object.values(state.references);}// static getAllReferenceEdges(): string[] { const state: DState = store.getState(); return Object.values((state).refEdges); }\n},{key:\"getAllClasses\",value:function getAllClasses(){var state=store.getState();return Object.values(state.classs);}},{key:\"getReturnTypes\",value:function getReturnTypes(){var state=store.getState();return LPointerTargetable.from(Object.values(state.returnTypes));}},{key:\"getAllClassesWithoutPrimitive\",value:function getAllClassesWithoutPrimitive(){// this solution does not look good. what if a primitive type is inserted at runtime in between?\n// coould reach the same goal by taking all Classes of a model (m2), excluding classes from other models (types are classes from m3 model)\nvar state=store.getState();var classList=Object.values(state.classs);classList.splice(0,Selectors.getAllPrimitiveTypes().length);/* todo: need to change it in something like this once cross-references between models and instances are implemented\r\n        const m2: LModel;\r\n        m2.isInstanceOf = m3 as LModel;\r\n        m2.isInstanceOf.classes;*/return classList;}},{key:\"getAllEnumerators\",value:function getAllEnumerators(){var flag=arguments.length>0&&arguments[0]!==undefined?arguments[0]:false;var state=store.getState();return Object.values(state.enumerators);}},{key:\"getAllPackages\",value:function getAllPackages(){var state=store.getState();return Object.values(state.packages);}},{key:\"getAllParameters\",value:function getAllParameters(){var state=store.getState();return Object.values(state.parameters);}},{key:\"getAllOperations\",value:function getAllOperations(){var state=store.getState();return Object.values(state.operations);}},{key:\"getDElement\",value:function getDElement(pointer){var state=store.getState();var dElement=state.idlookup[pointer];return dElement;}},{key:\"getAllMetamodels\",value:function getAllMetamodels(){var state=store.getState();var dModels=Object.values(state.m2models);return LPointerTargetable.fromPointer(dModels);}},{key:\"getAllModels\",value:function getAllModels(){var state=store.getState();var dModels=Object.values(state.m1models);return LPointerTargetable.fromPointer(dModels);}//Giordano: end\n},{key:\"getVertex\",value:function getVertex(wrap,resolvePointers){var state=store.getState();var ptrs=[];U.ArrayMerge0(false,ptrs,// Object.values(state.graphs || {}),\nObject.values(state.voidvertexs||{}),Object.values(state.vertexs||{}),Object.values(state.graphvertexs||{}),Object.values(state.edgepoints||{}));console.log('selector getvertex: ',{ptrs:ptrs,g:Object.values(state.graphs||{}),vv:Object.values(state.voidvertexs||{}),v:Object.values(state.vertexs||{}),gv:Object.values(state.graphvertexs||{}),ep:Object.values(state.edgepoints||{})});if(wrap===undefined||wrap===true)return ptrs.map(function(p){return DPointerTargetable.wrap(p);});if(resolvePointers===undefined||resolvePointers===true)return ptrs.map(function(r){return state.idlookup[r];});return ptrs;}},{key:\"getAll\",value:function getAll(Classe,condition,state,resolvePointers,wrap){if(!state)state=store.getState();var GClass=Classe||{name:\"idlookup\",cname:\"idlookup\"};var className=((GClass===null||GClass===void 0?void 0:GClass.staticClassName)||GClass.cname).toLowerCase();var allIdByClassName=state[className]||state[className.substr(1)]||state[className+'s']||state[className.substr(1)+'s'];Log.exDev(!allIdByClassName,'cannot find store key:',{state:state,className:className,Classe:Classe});var allDByClassName=null;var allLByClassName=null;if(resolvePointers||wrap){allDByClassName=allIdByClassName.map(function(e){return state.idlookup[e];});if(wrap){allLByClassName=allDByClassName.map(function(e){return DPointerTargetable.wrap(e);});}}var ret=resolvePointers||wrap?wrap?allLByClassName:allDByClassName:allIdByClassName;if(!Array.isArray(ret))ret=Object.values(ret).filter(function(e){return e instanceof Object;});if(condition)return ret.filter(function(e){return condition(e);});return ret;}},{key:\"getModels\",value:function getModels(condition){return Selectors.getAll(DModel,undefined,undefined,true,false);}},{key:\"getModel\",value:function getModel(name){var caseSensitive=arguments.length>1&&arguments[1]!==undefined?arguments[1]:false;var wrap=arguments.length>2&&arguments[2]!==undefined?arguments[2]:false;if(!caseSensitive)name=name.toLowerCase();var ret=Selectors.getAll(DModel,function(d){return(caseSensitive?d.name:d.name.toLowerCase())===name;},undefined,true,wrap)[0];return ret;}},{key:\"getByName\",value:function getByName(classe,name){var caseSensitive=arguments.length>2&&arguments[2]!==undefined?arguments[2]:false;var wrap=arguments.length>3&&arguments[3]!==undefined?arguments[3]:false;return Selectors.getByField(classe,'name',name,caseSensitive,wrap);}},{key:\"getByField\",value:function getByField(classe,field,value){var caseSensitive=arguments.length>3&&arguments[3]!==undefined?arguments[3]:false;var wrap=arguments.length>4&&arguments[4]!==undefined?arguments[4]:false;if(!caseSensitive)value=value.toLowerCase();var condition=function condition(d){var _d$field;var ret=(caseSensitive?d[field]:(_d$field=d[field])===null||_d$field===void 0?void 0:_d$field.toLowerCase())===value;console.log('filtering getall by field:',{d:d,dfield:d[field],value:value,ret:ret});return ret;};var ret=Selectors.getAll(classe,condition,undefined,true,wrap)[0];return ret;}},{key:\"getViewIDs\",value:function getViewIDs(condition){return Selectors.getAll(DViewElement);}},{key:\"queryJS\",value:function queryJS(model,query){try{return eval(query);}catch(e){return[];}}/*static getCurrentView(data: LModelElement): DViewElement {\r\n        Log.exDevv('todo');\r\n        return undefined as any;\r\n    }*/},{key:\"matchesMetaClassTarget\",value:function matchesMetaClassTarget(v,data){if(!v)return ViewEClassMatch.MISMATCH_PRECONDITIONS;if(!v.appliableToClasses||!v.appliableToClasses.length)return ViewEClassMatch.IMPLICIT_MATCH;if(!data)return ViewEClassMatch.MISMATCH_PRECONDITIONS;var ThisClass=RuntimeAccessibleClass.get(data.className);Log.exDev(!ThisClass,'unable to find class type:',{v:v,data:data});// todo: v = view appliable to DModel, data = proxy<LModel>\nvar gotSubclassMatch=false;var _iterator3=_createForOfIteratorHelper(v.appliableToClasses),_step3;try{for(_iterator3.s();!(_step3=_iterator3.n()).done;){var classtarget=_step3.value;var ClassTarget=RuntimeAccessibleClass.get(classtarget);if(ThisClass===ClassTarget)return ViewEClassMatch.EXACT_MATCH;// explicit exact match\nif(!gotSubclassMatch&&U.classIsExtending(ThisClass,ClassTarget))gotSubclassMatch=true;// explicit subclass match\nif(gotSubclassMatch)return ViewEClassMatch.INHERITANCE_MATCH;}}catch(err){_iterator3.e(err);}finally{_iterator3.f();}return ViewEClassMatch.MISMATCH_PRECONDITIONS;}},{key:\"isOfSubclass\",value:function isOfSubclass(data,classTarget){var acceptEquality=arguments.length>2&&arguments[2]!==undefined?arguments[2]:false;var ThisClass=RuntimeAccessibleClass.get(data.className);Log.exDev(!ThisClass,'isOfSubclass() unable to find class type:',{data:data});var ClassTarget=typeof classTarget===\"string\"?RuntimeAccessibleClass.get(classTarget):classTarget;if(ThisClass===ClassTarget)return acceptEquality;return U.classIsExtending(ThisClass,ClassTarget);}},{key:\"getViewByIDOrNameD\",value:function getViewByIDOrNameD(name,state){var _state$idlookup$name,_state$idlookup$id;if(!state)state=store.getState();if(typeof name===\"object\"){return name.__raw||name;}if(((_state$idlookup$name=state.idlookup[name])===null||_state$idlookup$name===void 0?void 0:_state$idlookup$name.className)===DViewElement.cname)return state.idlookup[name];var id=Selectors.getViewIdFromName(name,state);if(id&&((_state$idlookup$id=state.idlookup[id])===null||_state$idlookup$id===void 0?void 0:_state$idlookup$id.className)===DViewElement.cname)return state.idlookup[id];return undefined;}// input: \"subview.subview2.targetview\"\n// output: returns pointer to targetview\n// path is not required to start with a root, it's also possible to start navigating from a subview (notviewpoint/model view)\n// in case multiple matches are given due to incomplete path not starting from a viewpoint, the oldest matching view is returned.\n},{key:\"getViewIdFromName\",value:function getViewIdFromName(namepath,state){if(!state)state=store.getState();var names=namepath.split(\".\");var eligibleContainers=state.viewelements;var _loop=function _loop(i){var name=names[i];eligibleContainers=eligibleContainers.filter(function(v){return state.idlookup[v].name===name;});if(i===names.length-1||eligibleContainers.length===0)return{v:eligibleContainers[0]};eligibleContainers=eligibleContainers.flatMap(function(v){return Object.keys(state.idlookup[v].subViews);});};for(var i=0;i<names.length;i++){var _ret=_loop(i);if(typeof _ret===\"object\")return _ret.v;}return undefined;}// todo: idea, set query complexity = explicitpriority amd autoset explicit priority to query lemgth\n},{key:\"getAllGraphElementPointers\",value:// todo: the more \"or\" and navigations there are, the more a query is \"complex\", the more the query match is a priority.\nfunction getAllGraphElementPointers(){// graphelements = fields;\nvar state=store.getState();return[].concat(_toConsumableArray(state.graphs),_toConsumableArray(state.graphvertexs),_toConsumableArray(state.graphelements),_toConsumableArray(state.vertexs),_toConsumableArray(state.edgepoints),_toConsumableArray(state.edges));}},{key:\"getFinalScore\",value:function getFinalScore(entry,vid,parentView,dview){if(entry.metaclassScore===ViewEClassMatch.MISMATCH_PRECONDITIONS)return ViewEClassMatch.MISMATCH;if(entry.viewPointMatch===ViewEClassMatch.VP_MISMATCH)return ViewEClassMatch.MISMATCH;if(entry.jsScore===ViewEClassMatch.MISMATCH_JS||entry.OCLScore===ViewEClassMatch.MISMATCH_JS)return ViewEClassMatch.MISMATCH;var pvMatch=parentView?vid in parentView.subViews:false;var pvScore=pvMatch?parentView.subViews[vid]:1;var explicitprio;if(typeof entry.jsScore==='number'){explicitprio=entry.jsScore;}else if(dview.explicitApplicationPriority===undefined){var _dview$jsCondition,_dview$oclCondition;// in editor put placeholder with computed expression\nexplicitprio=(((_dview$jsCondition=dview.jsCondition)===null||_dview$jsCondition===void 0?void 0:_dview$jsCondition.length)||1)+(((_dview$oclCondition=dview.oclCondition)===null||_dview$oclCondition===void 0?void 0:_dview$oclCondition.length)||1);}else explicitprio=dview.explicitApplicationPriority;return entry.viewPointMatch*entry.metaclassScore*pvScore*explicitprio;//score = precoditiom * paremtview(comfiguravle) * (explicitprio = jsValid*jslemgth + oclvalid*ocllemgth)\n// or if jscomditiom returmed mumver --> * jsscore\n}/*\r\n    //this function handles: what i do when view changes? do i recompute the score?\r\n    static updateViewMatchings(dview: DViewElement, updatePreconditions: boolean, updateOCLScore: boolean, store: DState, updateManualViews: boolean = false, forcedUpdateViews: boolean = false): void {\r\n\r\n        //  event           observed change         ignore change\r\n        //  ocl             data                    node, view (except view.ocl)\r\n        //  jsCondition     all                     none\r\n        //  appliableTo     view.appliableto\r\n        // if (!forcedUpdateViews && (dview.oclUpdateCondition === 'manual') !== updateManualViews) return;\r\n        // modularize getscoresnew split in setpreconditionscore, setoclscorem, setjscscore, and call those only if observed stuff changed\r\n\r\n        const allNodes: DGraphElement[] = DPointerTargetable.fromPointer(Selectors.getAllGraphElementPointers());\r\n        //let dview = view.__raw;\r\n        let vid = dview.id; // optimize searching multiple usages and replacing\r\n\r\n        // filter alldata to exclude modelpieces that didn't pass the view.appyto check\r\n        // let oclData: (LModelElement)[] = allData.filter(l => {\r\n        let oclnodes: (DGraphElement)[] = allNodes.filter((dg: DGraphElement) => {\r\n            if (!dg) return false;\r\n            if (true) {\r\n                let d: DModelElement | undefined = dg.model ? DPointerTargetable.fromPointer(dg.model) : undefined;\r\n                let firstEvaluationForNodeView: boolean = false;\r\n                if (!transientProperties.node[dg.id]) { transientProperties.node[dg.id] = {viewScores: {}} as any; firstEvaluationForNodeView = true; }\r\n                if (!transientProperties.node[dg.id].viewScores[vid]) { transientProperties.node[dg.id].viewScores[vid] = {score: undefined} as any; firstEvaluationForNodeView = true; }\r\n\r\n                if (firstEvaluationForNodeView || updatePreconditions) {\r\n                    const oldScore = transientProperties.node[dg.id].viewScores[vid].score;\r\n                    const newScore = transientProperties.node[dg.id].viewScores[vid].score = this.matchesMetaClassTarget(dview, d);\r\n                    if (oldScore !== newScore) transientProperties.node[dg.id].stackViews = undefined as any; // force re-sorting\r\n                    // 67{}[]'?^&&||nb>\r\n                } /* else {\r\n                    if (!transientProperties.view[dview.id].oclUpdateCondition_PARSED( transientProperties.node[dg.id].viewScores[vid].)) return;\r\n                }* /\r\n                // no need to check if parentview changed as well. i optimized by not having parentview affect the numeric scores, but only the view queue array sorting\r\n\r\n                // transient.node[dg.id].viewScores[vid].score = MISSING (hasOwnProperty);    if the view or model is new and they are not yet evaluated.\r\n                // transient.node[dg.id].viewScores[vid].score = Number.NEGATIVE_INFINITY;    if pre-ocl conditions failed (view.appliableTo)\r\n                // transient.node[dg.id].viewScores[vid].score = 0;                           if preconditions are met, but ocl failed\r\n                // transient.node[dg.id].viewScores[vid].score = number ocl score;            if preconditions are met and ocl matched\r\n                // transient.node[dg.id].viewScores[vid].score = number precondition score;   if preconditions are met, and there is no ocl condition\r\n                // changed: matching score and ocl score are summed.\r\n                return transientProperties.node[dg.id].viewScores[vid].score !== undefined;\r\n            }\r\n\r\n            // if (model_viewstack[vid]) { filledElementsInOclData++; return l; } return undefined;\r\n        });\r\n        function mergeViewScores(preconditionScore: number, oclScore: number): number{ return preconditionScore + oclScore; }\r\n    }*/},{key:\"updateScores\",value:function updateScores(data0,node,nid,pv){var needsorting=false;var firstEvaluationForNode=false;var firstEvaluationForNodeView=false;var tn=transientProperties.node[nid];if(!tn){transientProperties.node[nid]=tn=new NodeTransientProperties();firstEvaluationForNode=true;}var olddata=tn.viewSorted_modelused;//let oldnode = transientProperties.node[nid]?.viewSorted_nodeused as LGraphElement;\nvar data=data0;// console.error('changed', {data, olddata, node, oldnode, cdata:data?.clonedCounter, colddata:olddata?.clonedCounter})\nvar pvid=pv===null||pv===void 0?void 0:pv.id;var oldpv=tn.viewSorted_pvid_used;var datachanged=!!data!==!!olddata||!!(data&&olddata)&&data.clonedCounter!==olddata.clonedCounter;//let nodechanged: boolean = (!!node !== !!oldnode) || !!(node && oldnode) && (node.clonedCounter !== oldnode.clonedCounter);\nvar parentViewChanged=pvid!==(oldpv===null||oldpv===void 0?void 0:oldpv.id)||!!(pv&&oldpv)&&oldpv.subViews!==pv.subViews;// shallow comparison is fine.\nif(parentViewChanged)tn.viewSorted_pvid_used=pv;//if (nodechanged) transientProperties.node[nid].viewSorted_nodeused = node;\nif(datachanged)tn.viewSorted_modelused=data;// let nodechanged: boolean\n// important to remember: how i'm using parentView in score and storage.\n// i'm calculating and storing every score without parentView, then i apply it right before sorting the array,\n// the enhanced value is not sored anyway but affects array sorting.\n// so if parentView changes, or if his subviews changed, need to resort array without recomputing any score value.\n//console.log('2302, getviews 2', {datachanged, nodechanged, olddata, oldnode, data, node, allViews: Selectors.getAllViewElements()});\nvar state=store.getState();var allViews=Selectors.getAllViewElements(state);var user=LUser.fromPointer(DUser.current);var project=user.project;var activevpid=project.activeViewpoint.id;// check if scores needs to be updated\nvar _iterator4=_createForOfIteratorHelper(allViews),_step4;try{for(_iterator4.s();!(_step4=_iterator4.n()).done;){var dview=_step4.value;var vid=dview.id;var tv=transientProperties.view[vid];if(!tv)transientProperties.view[vid]=tv={};var tnv=tn.viewScores[vid];//console.log('2302, getviews evaluating view ' + vid, {vid, dview});\n// check initialization\nif(!tnv){transientProperties.node[nid].viewScores[vid]=tnv={};/*{\r\n                    score: ViewEClassMatch.NOT_EVALUATED_YET,\r\n                    metaclassScore: ViewEClassMatch.NOT_EVALUATED_YET,\r\n                    //jsScore:ViewEClassMatch.NOT_EVALUATED_YET,\r\n                    //OCLScore: ViewEClassMatch.NOT_EVALUATED_YET\r\n                } as any;*/firstEvaluationForNodeView=true;}else firstEvaluationForNodeView=tnv.metaclassScore===ViewEClassMatch.NOT_EVALUATED_YET;// todo: when changing view.appliableTo, delete all tnv using that view.\n// don't match exclusive views from other vp\nvar dvp=DPointerTargetable.fromPointer(dview.viewpoint,state);var oldVpMatch=tnv.viewPointMatch;// console.log(\"vp matching \" +vid, {vid, dvp, activevpid });\nif(dvp.id===activevpid)tnv.viewPointMatch=ViewEClassMatch.VP_Explicit;else if(dvp.id==='Pointer_ViewPointDefault')tnv.viewPointMatch=ViewEClassMatch.VP_Default;else if(!dvp.isExclusiveView)tnv.viewPointMatch=ViewEClassMatch.VP_Decorative;else tnv.viewPointMatch=ViewEClassMatch.VP_MISMATCH;if(!needsorting&&oldVpMatch!==tnv.viewPointMatch)needsorting=true;if(tnv.viewPointMatch===ViewEClassMatch.VP_MISMATCH){tnv.finalScore=ViewEClassMatch.VP_MISMATCH;continue;}// check preconditions\nif(firstEvaluationForNodeView){var oldScore=tnv.metaclassScore;tnv.metaclassScore=this.matchesMetaClassTarget(dview,data===null||data===void 0?void 0:data.__raw);needsorting=true;// sorting is mandatory here because it's the first evaluation of node-vie\n// if mismatch i stop computing the score.\nif(tnv.metaclassScore===ViewEClassMatch.MISMATCH_PRECONDITIONS){tnv.finalScore=ViewEClassMatch.MISMATCH;continue;}}else if(tnv.metaclassScore===ViewEClassMatch.MISMATCH_PRECONDITIONS)continue;if(true){// this needs to be called not only if datachanged || nodechanged, but everytime in case it is a reference like data.$value.name.length\n// also his performances are so fast that it might be more costly to check if it's supposed to be reevaluated than just calling it.\nvar jsScoreChanged=Selectors.updateJSScore(node,data,dview,tv,tnv);if(!needsorting&&jsScoreChanged)needsorting=true;// if mismatch i stop computing the score.\nif(tnv.jsScore===ViewEClassMatch.MISMATCH_JS){tnv.finalScore=ViewEClassMatch.MISMATCH;continue;}}// check pre-ocl guard\n// if (!tv.oclUpdateCondition_PARSED(data, olddata)) continue;\nif(datachanged||tnv.OCLScore===ViewEClassMatch.NOT_EVALUATED_YET){// check ocl: this can lead to mis-updating if ocl queries a reference.\n// but OCL is computationally heavy, so i decided it is now a requirement to update the model to reevaluate ocl.\nvar _oldScore=tnv.OCLScore;tnv.OCLScore=OCL.test(data,dview,node);//Selectors.calculateOCLScore({data, node, dview});\ntv.oclChanged=false;if(!needsorting&&tnv.OCLScore!==_oldScore)needsorting=true;if(tnv.OCLScore===ViewEClassMatch.MISMATCH_OCL){tnv.finalScore=ViewEClassMatch.MISMATCH;continue;}}}}catch(err){_iterator4.e(err);}finally{_iterator4.f();}if(parentViewChanged)needsorting=true;// scores saved in dictionaries are the same, but score in final sorted array changed.\nreturn needsorting;}// get final viewstack for a node, also updates OCL scores if needed because of a change in model or parentView (NOT from a change in view)\n},{key:\"getAppliedViewsNew\",value:function getAppliedViewsNew(_ref){var data0=_ref.data,node=_ref.node,pv=_ref.pv,nid=_ref.nid;// console.trace('2302, getviews', {tnode: transientProperties.node[nid], nid, pv})\nvar needsorting=Selectors.updateScores(data0,node,nid,pv);var tn=transientProperties.node[nid];// needs to be placed after updateScores() which will initialize it.\nif(needsorting||!tn.stackViews){var _mainViews$;var mainViews=[];var decorativeViews=[];var state=store.getState();for(var _i=0,_Object$keys=Object.keys(tn.viewScores);_i<_Object$keys.length;_i++){var vid=_Object$keys[_i];var tnv=tn.viewScores[vid];var dview=DPointerTargetable.fromPointer(vid,state);var _score=tnv.finalScore=Selectors.getFinalScore(tnv,vid,pv,dview);if(!(_score>0))continue;// do not flip to <=, because undefined and NEGATIVE_INFINITY always compute to false.\n(dview.isExclusiveView?mainViews:decorativeViews).push({element:vid,score:_score,view:LPointerTargetable.fromD(dview)});}decorativeViews.sort(function(s1,s2){return s2.score-s1.score;});// sorted from biggest to smallest\nmainViews.sort(function(s1,s2){return s2.score-s1.score;});// sorted from biggest to smallest\n// Log.exDev(!mainViews[0], 'cannot find a matching main view', {mainViews, decorativeViews, data0, scores: tn.viewScores})\ntn.mainView=(_mainViews$=mainViews[0])===null||_mainViews$===void 0?void 0:_mainViews$.view;tn.validMainViews=mainViews.map(function(s){return s.view;});tn.stackViews=decorativeViews.map(function(s){return s.view;});}// chamges to view or ocl comditiom are mot hamdled here, ut om multple mp/modes a omce\n//nb{}[]\n// if data or view changed update the score dict, them re-sort the view arr first, fimally update Sorted_modelused, Sorted_modelused\n// console.log('2302 getviews ret', {dn: data?.name, data, stack: transientProperties.node[nid].stackViews, stackn: transientProperties.node[nid].stackViews.map(v => v.name), scores: transientProperties.node[nid]});\n// throw new Error(\"stop debug\");\nreturn tn;}},{key:\"getAllMP\",value:function getAllMP(state){if(!state)state=store.getState();var allD=Object.values(state.idlookup);return allD.filter(function(d){return U.isObject(d)&&Selectors.isOfSubclass(d,DModelElement);});}},{key:\"toObject\",value:function toObject(ptrs,state){if(!state)state=store.getState();return ptrs.map(function(p){return state.idlookup[p];});}},{key:\"wrap\",value:function wrap(arr,state){if(!arr.length)return[];if(!state)state=store.getState();var objarr;if(typeof arr[0]===\"string\"){objarr=Selectors.toObject(arr,state);}else objarr=arr;return objarr.map(function(p){return RuntimeAccessibleClass.wrap(p);});}},{key:\"unwrap\",value:function unwrap(arr){return arr.map(function(a){return a.__raw;});}},{key:\"getSubNodeElements\",value:function getSubNodeElements(forGraph){var asPointers=arguments.length>1&&arguments[1]!==undefined?arguments[1]:false;var wrap=arguments.length>2&&arguments[2]!==undefined?arguments[2]:false;var state=store.getState();var g=state.idlookup[forGraph];if(asPointers)return g.subElements;var subelements=g.subElements.map(function(geid){return state.idlookup[geid];});if(wrap)return subelements.map(function(ge){return LPointerTargetable.from(ge);});return subelements;}//// giordano part\n},{key:\"getAllPackageClasses\",value:function getAllPackageClasses(id){var data=LPointerTargetable.from(id);var lPackage;var classes=[];if(data.className===\"DReference\"){var lClass=LPointerTargetable.from(data.father);lPackage=LPointerTargetable.from(lClass.father);}if(data.className===\"DParameter\"){var lOperation=LPointerTargetable.from(data.father);var _lClass=LPointerTargetable.from(lOperation.father);lPackage=LPointerTargetable.wrap(_lClass.father);}if(data.className===\"DOperation\"){var _lClass2=LPointerTargetable.from(data.father);lPackage=LPointerTargetable.wrap(_lClass2.father);}if(lPackage){var _iterator5=_createForOfIteratorHelper(lPackage.classifiers),_step5;try{for(_iterator5.s();!(_step5=_iterator5.n()).done;){var classifier=_step5.value;var lClassifier=LPointerTargetable.from(classifier);if(lClassifier.className===\"DClass\")classes.push(lClassifier);}}catch(err){_iterator5.e(err);}finally{_iterator5.f();}}return classes;}},{key:\"getAllPackageEnumerators\",value:function getAllPackageEnumerators(id){var data=LPointerTargetable.from(id);var lPackage;var enumerators=[];if(data.className===\"DAttribute\"){var lClass=LPointerTargetable.from(data.father);lPackage=LPointerTargetable.from(lClass.father);}if(data.className===\"DParameter\"){var lOperation=LPointerTargetable.from(data.father);var _lClass3=LPointerTargetable.from(lOperation.father);lPackage=LPointerTargetable.from(_lClass3.father);}if(data.className===\"DOperation\"){var _lClass4=LPointerTargetable.from(data.father);lPackage=LPointerTargetable.from(_lClass4.father);}if(lPackage){var _iterator6=_createForOfIteratorHelper(lPackage.classifiers),_step6;try{for(_iterator6.s();!(_step6=_iterator6.n()).done;){var classifier=_step6.value;var lClassifier=LPointerTargetable.from(classifier);if(lClassifier.className===\"DEnumerator\")enumerators.push(lClassifier);}}catch(err){_iterator6.e(err);}finally{_iterator6.f();}}return enumerators;}},{key:\"updateJSScore\",value:function updateJSScore(node,data,dview,tv,tnv){var oldjsScore=tnv.jsScore;var jsConditionChanged=tv.jsConditionChanged;tv.jsConditionChanged=false;// tnv.jsScore = ViewEClassMatch.NOT_EVALUATED_YET as any as number;\nvar printstuff={name:data===null||data===void 0?void 0:data.name,jsc:tv.jsCondition,tv:_objectSpread({},tv),data:data&&data.__raw,node:node&&_objectSpread({},node.__raw),nerr:node===null||node===void 0?void 0:node.errors};if(tv.jsCondition){try{tnv.jsScore=tv.jsCondition({data:data,node:node,view:LPointerTargetable.fromD(dview),constants:tv.constants});// if (tnv.jsScore === true) tnv.jsScore = dview.jsCondition.length;\nswitch(typeof tnv.jsScore){case\"boolean\":// bool is fine if true\nif(!tnv.jsScore)tnv.jsScore=ViewEClassMatch.MISMATCH_JS;break;case\"number\":// number is fine if not NaN and > 0\nif(isNaN(tnv.jsScore)||tnv.jsScore<0)tnv.jsScore=ViewEClassMatch.MISMATCH_JS;break;default:tnv.jsScore=ViewEClassMatch.MISMATCH_JS;break;}}catch(e){var _e$message;// crash = mismatch\nLog.ee(\"failed to evaluate jsCondition: \"+((_e$message=e.message)===null||_e$message===void 0?void 0:_e$message.split(\"\\n\")[0]),{e:e,data:data,node:node,tnv:tnv,jsc:tv.jsCondition+''});tnv.jsScore=ViewEClassMatch.MISMATCH_JS;}}else tnv.jsScore=true;// missing condition = match\n// jsConditionChanged: because even if score didn't change, if jsc.length changed the final computed score is affected\nreturn jsConditionChanged||tnv.jsScore!==oldjsScore;}}]);return Selectors;}(),_class2.getQueryComplexity=function(query){return query.length;},_class2))||_class);window.Selectors=Selectors;var Scored=function Scored(score,element){_classCallCheck(this,Scored);this.score=score;this.element=element;};","map":{"version":3,"names":["LUser","DUser","DViewElement","DPointerTargetable","DModel","DModelElement","OCL","Log","LPointerTargetable","RuntimeAccessible","RuntimeAccessibleClass","store","U","toShortEType","NodeTransientProperties","transientProperties","ViewEClassMatch","ShortDefaultEClasses","toShortEClass","Selectors","_dec","_class","_class2","_classCallCheck","_createClass","key","value","getActiveModel","_state$_lastSelected","metamodel","state","getState","selected","_lastSelected","modelElement","me","fromPointer","model","getLastSelectedModel","_state$_lastSelected2","ret","element","isMetamodel","m2","m1","instanceof","getAllViewElements","state0","ptrs","Object","values","viewelements","views","map","ptr","getViewpoints","viewpoints","getViewpoint","viewpoint","getObjects","objects","dObjects","idlookup","lObjects","_iterator","_createForOfIteratorHelper","_step","s","n","done","dObject","push","id","err","e","f","getValues","dValues","lValues","_iterator2","_step2","dValue","getDeleted","deleted","getDefaultEcoreClass","type","shorttype","toUpperCase","EObject","getPrimitiveType","getAllPrimitiveTypes","primitiveTypes","classifiers","getFirstPrimitiveTypes","getRefEdges","pointers","refEdges","dRefEdges","getField","field","getAllAttributes","attributes","getAllEnumLiterals","enumliterals","getAllReferences","references","getAllClasses","classs","getReturnTypes","from","returnTypes","getAllClassesWithoutPrimitive","classList","splice","length","getAllEnumerators","flag","arguments","undefined","enumerators","getAllPackages","packages","getAllParameters","parameters","getAllOperations","operations","getDElement","pointer","dElement","getAllMetamodels","dModels","m2models","getAllModels","m1models","getVertex","wrap","resolvePointers","ArrayMerge0","voidvertexs","vertexs","graphvertexs","edgepoints","console","log","g","graphs","vv","v","gv","ep","p","r","getAll","Classe","condition","GClass","name","cname","className","staticClassName","toLowerCase","allIdByClassName","substr","exDev","allDByClassName","allLByClassName","Array","isArray","filter","getModels","getModel","caseSensitive","d","getByName","classe","getByField","_d$field","dfield","getViewIDs","queryJS","query","eval","matchesMetaClassTarget","data","MISMATCH_PRECONDITIONS","appliableToClasses","IMPLICIT_MATCH","ThisClass","get","gotSubclassMatch","_iterator3","_step3","classtarget","ClassTarget","EXACT_MATCH","classIsExtending","INHERITANCE_MATCH","isOfSubclass","classTarget","acceptEquality","getViewByIDOrNameD","_state$idlookup$name","_state$idlookup$id","__raw","getViewIdFromName","namepath","names","split","eligibleContainers","_loop","i","flatMap","keys","subViews","_ret","getAllGraphElementPointers","concat","_toConsumableArray","graphelements","edges","getFinalScore","entry","vid","parentView","dview","metaclassScore","MISMATCH","viewPointMatch","VP_MISMATCH","jsScore","MISMATCH_JS","OCLScore","pvMatch","pvScore","explicitprio","explicitApplicationPriority","_dview$jsCondition","_dview$oclCondition","jsCondition","oclCondition","updateScores","data0","node","nid","pv","needsorting","firstEvaluationForNode","firstEvaluationForNodeView","tn","olddata","viewSorted_modelused","pvid","oldpv","viewSorted_pvid_used","datachanged","clonedCounter","parentViewChanged","allViews","user","current","project","activevpid","activeViewpoint","_iterator4","_step4","tv","view","tnv","viewScores","NOT_EVALUATED_YET","dvp","oldVpMatch","VP_Explicit","VP_Default","isExclusiveView","VP_Decorative","finalScore","oldScore","jsScoreChanged","updateJSScore","test","oclChanged","MISMATCH_OCL","getAppliedViewsNew","_ref","stackViews","_mainViews$","mainViews","decorativeViews","_i","_Object$keys","score","fromD","sort","s1","s2","mainView","validMainViews","getAllMP","allD","isObject","toObject","arr","objarr","unwrap","a","getSubNodeElements","forGraph","asPointers","subElements","subelements","geid","ge","getAllPackageClasses","lPackage","classes","lClass","father","lOperation","_iterator5","_step5","classifier","lClassifier","getAllPackageEnumerators","_iterator6","_step6","oldjsScore","jsConditionChanged","printstuff","jsc","_objectSpread","nerr","errors","constants","isNaN","_e$message","ee","message","getQueryComplexity","window","Scored"],"sources":["C:/d/Programming/web/jodel-mde/src/redux/selectors/selectors.ts"],"sourcesContent":["import {\r\n    AbstractConstructor,\r\n    AttribETypes,\r\n    Constructor,\r\n    DAttribute,\r\n    DClass,\r\n    DClassifier,\r\n    DEnumerator,\r\n    DGraph,\r\n    DGraphElement,\r\n    DObject,\r\n    DRefEdge,\r\n    DState,\r\n    DValue,\r\n    DVoidVertex,\r\n    GObject,\r\n    LClass,\r\n    LEnumerator,\r\n    LGraphElement,\r\n    LModel,\r\n    LModelElement,\r\n    LObject,\r\n    LOperation,\r\n    LPackage,\r\n    LRefEdge,\r\n    LValue,\r\n    LViewElement,\r\n    LViewPoint,\r\n    LVoidVertex,\r\n    Pointer,\r\n    ShortAttribETypes,\r\n    Dictionary,\r\n    LUser,\r\n    DUser,\r\n    Defaults, LProject, ViewScore,\r\n    DViewElement,\r\n    DPointerTargetable,\r\n    DModel,\r\n    DModelElement,\r\n    OCL,\r\n    Log,\r\n    LPointerTargetable,\r\n    RuntimeAccessible,\r\n    RuntimeAccessibleClass,\r\n    store,\r\n    U,\r\n    toShortEType,\r\n    NodeTransientProperties, transientProperties, ViewEClassMatch, ViewTransientProperties, DProject, DViewPoint\r\n} from \"../../joiner\";\r\nimport {DefaultEClasses, ShortDefaultEClasses, toShortEClass} from \"../../common/U\";\r\n\r\n\r\n@RuntimeAccessible('Selectors')\r\nexport class Selectors{\r\n\r\n    static getActiveModel(): null|LModel {\r\n        let metamodel: null|LModel;\r\n        let state: DState & GObject = store.getState();\r\n        const selected = state._lastSelected?.modelElement;\r\n        if(selected) {\r\n            const me = LPointerTargetable.fromPointer(selected)\r\n            metamodel = (me) ? me.model : null;\r\n        } else metamodel = null;\r\n        return metamodel;\r\n    }\r\n\r\n    public static getLastSelectedModel<RET extends {m1?:LModel, m2?:LModel, model?:LModel, element?:LModelElement}>(state?: DState): RET {\r\n        state = state || store.getState();\r\n        let me = state._lastSelected?.modelElement;\r\n        if (!me) return {} as RET;\r\n        let ret: RET = {element: LPointerTargetable.fromPointer(me, state)} as RET;\r\n        ret.model = ret.element!.model\r\n        if (ret.model.isMetamodel) ret.m2 = ret.model;\r\n        else {\r\n            ret.m1 = ret.model;\r\n            ret.m2 = ret.m1.instanceof;\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    static getAllViewElements(state0?: DState): DViewElement[] {\r\n        // return Object.values(store.getState().idlookup).filter(v => v.className === DViewElement.name) as DViewElement[];\r\n        const state: GObject<DState> = state0 || store.getState();\r\n        const ptrs: Pointer<DViewElement>[] = Object.values((state).viewelements);\r\n        let views: DViewElement[] = ptrs.map<DViewElement>( (ptr) => DPointerTargetable.fromPointer(ptr, state) as DViewElement);\r\n        return views;\r\n    }\r\n    //Giordano: start\r\n\r\n    public static getViewpoints() : LViewPoint[] {\r\n        const state: DState & GObject = store.getState();\r\n        return LPointerTargetable.fromPointer(state.viewpoints);\r\n    }\r\n    public static getViewpoint() : LViewPoint {\r\n        const state: DState & GObject = store.getState();\r\n        return LPointerTargetable.fromPointer(state.viewpoint);\r\n    }\r\n\r\n    public static getObjects(): LObject[] {\r\n        let state: DState & GObject = store.getState();\r\n        const ptrs: Pointer<DObject, 0, 'N'> = Object.values((state).objects);\r\n        const dObjects: DObject[] = ptrs.map<DObject>( (ptr) => state.idlookup[ptr] as DObject);\r\n        const lObjects: LObject[] = [];\r\n        for(let dObject of dObjects) {\r\n            lObjects.push(LPointerTargetable.fromPointer(dObject.id));\r\n        }\r\n        return lObjects;\r\n    }\r\n    public static getValues(): LValue[] {\r\n        let state: DState & GObject = store.getState();\r\n        const ptrs: Pointer<DValue, 0, 'N'> = Object.values((state).values);\r\n        const dValues: DValue[] = ptrs.map<DValue>( (ptr) => state.idlookup[ptr] as DValue);\r\n        const lValues: LValue[] = [];\r\n        for(let dValue of dValues) {\r\n            if(dValue?.id) {\r\n                lValues.push(LPointerTargetable.fromPointer(dValue.id));\r\n            }\r\n        }\r\n        return lValues;\r\n    }\r\n\r\n    public static getDeleted(): string [] {\r\n        const state: DState & GObject = store.getState();\r\n        return state.deleted;\r\n    }\r\n\r\n    public static getState(): any {\r\n        const state: DState & GObject = store.getState();\r\n        return state;\r\n    }\r\n\r\n    static getDefaultEcoreClass(type: DefaultEClasses | ShortDefaultEClasses, state?: DState): DClassifier {\r\n        let shorttype: string = (toShortEClass(type as any) || type).toUpperCase();\r\n        if (!state) state = store.getState();\r\n        // todo: make other m3 classes and make this generic like getPrimitiveType\r\n        return state.idlookup[\"Pointer_\"+ShortDefaultEClasses.EObject.toUpperCase()] as DClassifier;\r\n    }\r\n    static getPrimitiveType(type: AttribETypes | ShortAttribETypes, state?: DState): DClassifier {\r\n        let shorttype: string = (toShortEType(type as any) || type).toUpperCase();\r\n        if (!state) state = store.getState();\r\n        return state.idlookup[\"Pointer_\"+shorttype] as DClassifier;\r\n    }\r\n    static getAllPrimitiveTypes(): DClassifier[] {\r\n        let state: DState & GObject = store.getState();\r\n        const ptrs: Pointer<DClassifier, 0, 'N'> = Object.values((state).primitiveTypes);\r\n        const classifiers: DClassifier[] = ptrs.map<DClassifier>( (ptr) => state.idlookup[ptr] as DClassifier);\r\n        return classifiers;\r\n    }\r\n    static getFirstPrimitiveTypes(): DClassifier {\r\n        return Selectors.getAllPrimitiveTypes()[0];\r\n    }\r\n    static getRefEdges(): DRefEdge[] {\r\n        const state: DState & GObject = store.getState();\r\n        const pointers: Pointer<DRefEdge, 0, 'N', LRefEdge> = Object.values((state).refEdges);\r\n        const dRefEdges: DRefEdge[] = pointers.map<DRefEdge>( (ptr) => state.idlookup[ptr] as DRefEdge);\r\n        return dRefEdges;\r\n    }\r\n    static getField(field: string): string[] {\r\n        let state: DState & GObject = store.getState();\r\n        const pointers: Pointer<DModelElement, 0, 'N'> = Object.values((state)[field]);\r\n        return pointers;\r\n    }\r\n\r\n    static getAllAttributes(): string[] {\r\n        const state: DState = store.getState();\r\n        return Object.values((state).attributes);\r\n    }\r\n    static getAllEnumLiterals(): string[] {\r\n        const state: DState = store.getState();\r\n        return Object.values((state).enumliterals);\r\n    }\r\n    static getAllReferences(): string[] {\r\n        const state: DState = store.getState();\r\n        return Object.values((state).references);\r\n    }\r\n    // static getAllReferenceEdges(): string[] { const state: DState = store.getState(); return Object.values((state).refEdges); }\r\n    static getAllClasses(): string[] {\r\n        const state: DState = store.getState();\r\n        return Object.values((state).classs);\r\n    }\r\n    static getReturnTypes(): LClass[] {\r\n        const state: DState = store.getState();\r\n        return LPointerTargetable.from(Object.values((state).returnTypes));\r\n    }\r\n\r\n    static getAllClassesWithoutPrimitive(): string[] {\r\n        // this solution does not look good. what if a primitive type is inserted at runtime in between?\r\n        // coould reach the same goal by taking all Classes of a model (m2), excluding classes from other models (types are classes from m3 model)\r\n        const state: DState = store.getState();\r\n        const classList: string[] = Object.values((state).classs);\r\n        classList.splice(0, Selectors.getAllPrimitiveTypes().length);\r\n        /* todo: need to change it in something like this once cross-references between models and instances are implemented\r\n        const m2: LModel;\r\n        m2.isInstanceOf = m3 as LModel;\r\n        m2.isInstanceOf.classes;*/\r\n\r\n        return classList;\r\n    }\r\n\r\n    static getAllEnumerators(flag = false): string[] {\r\n        const state: DState = store.getState();\r\n        return Object.values((state).enumerators);\r\n    }\r\n    static getAllPackages(): string[] {\r\n        const state: DState = store.getState();\r\n        return Object.values((state).packages);\r\n    }\r\n\r\n    static getAllParameters(): string[] {\r\n        const state: DState = store.getState();\r\n        return Object.values((state).parameters);\r\n    }\r\n    static getAllOperations(): string[] {\r\n        const state: DState = store.getState();\r\n        return Object.values((state).operations);\r\n    }\r\n\r\n    static getDElement<T extends DModelElement>(pointer: string): T {\r\n        const state: DState & GObject = store.getState();\r\n        const dElement: T = state.idlookup[pointer] as T;\r\n        return dElement;\r\n    }\r\n\r\n    static getAllMetamodels(): LModel[] {\r\n        const state: DState = store.getState();\r\n        const dModels = Object.values((state).m2models);\r\n        return LPointerTargetable.fromPointer(dModels);\r\n    }\r\n\r\n    static getAllModels(): LModel[] {\r\n        const state: DState = store.getState();\r\n        const dModels = Object.values((state).m1models);\r\n        return LPointerTargetable.fromPointer(dModels);\r\n    }\r\n\r\n    //Giordano: end\r\n\r\n    static getVertex<W extends boolean = true, RP extends boolean = true>(wrap?: W /* = true */, resolvePointers?: RP /**/):\r\n        W extends false ? (RP extends false ? Pointer<DVoidVertex, 1, 1, LVoidVertex>[] : DVoidVertex[]) : LVoidVertex[] {\r\n        const state: DState = store.getState();\r\n        let ptrs: Pointer<DVoidVertex>[] = [];\r\n\r\n        U.ArrayMerge0(false, ptrs,\r\n            // Object.values(state.graphs || {}),\r\n            Object.values(state.voidvertexs || {}),\r\n            Object.values(state.vertexs || {}),\r\n            Object.values(state.graphvertexs || {}),\r\n            Object.values(state.edgepoints || {}));\r\n\r\n        console.log('selector getvertex: ', {ptrs, g: Object.values(state.graphs || {}), vv:Object.values(state.voidvertexs || {}), v:Object.values(state.vertexs || {}), gv:Object.values(state.graphvertexs || {}), ep:Object.values(state.edgepoints || {})});\r\n        if (wrap === undefined || wrap === true) return ptrs.map( p => DPointerTargetable.wrap(p)) as any[];\r\n        if (resolvePointers === undefined || resolvePointers === true) return ptrs.map( r => state.idlookup[r]) as any[];\r\n        return ptrs as any[];\r\n    }\r\n\r\n    static getAll<D extends DPointerTargetable, L extends LPointerTargetable, DT extends typeof DPointerTargetable = typeof DPointerTargetable,\r\n        W extends undefined | true | false = false, RP extends undefined | true | false = true, RET = W extends false ? (RP extends false ? Pointer<D, 1, 1, L> : D) : L>\r\n        (Classe?: DT, condition?: (e:RET) => boolean, state?: DState, resolvePointers?: RP /**/, wrap?: W /* = true */): RET[] {\r\n        if (!state) state = store.getState();\r\n        let GClass = (Classe as GObject) || {name:\"idlookup\", cname:\"idlookup\"};\r\n        const className: string = (GClass?.staticClassName || GClass.cname).toLowerCase();\r\n        const allIdByClassName: Pointer<D, 1, 1, L>[]\r\n            = (state as GObject)[className]\r\n            || (state as GObject)[className.substr(1)]\r\n            || (state as GObject)[className + 's']\r\n            || (state as GObject)[className.substr(1) + 's'];\r\n        Log.exDev(!allIdByClassName, 'cannot find store key:', {state, className, Classe});\r\n        let allDByClassName: D[] | null = null;\r\n        let allLByClassName: L[] | null = null;\r\n        if (resolvePointers || wrap) {\r\n            allDByClassName = allIdByClassName.map( (e) => (state as DState).idlookup[e] ) as D[];\r\n            if (wrap) {\r\n                allLByClassName = allDByClassName.map( e => DPointerTargetable.wrap(e)) as any as L[];\r\n            }\r\n        }\r\n        let ret: RET[] = (resolvePointers || wrap ? (wrap ? allLByClassName : allDByClassName) : allIdByClassName) as any[] as RET[];\r\n        if (!Array.isArray(ret)) ret = Object.values(ret).filter(e => e instanceof Object) as RET[];\r\n        if (condition) return ret.filter( e => condition(e));\r\n        return ret;\r\n    }\r\n\r\n    static getModels(condition?: (m: DModel) => boolean): DModel[] { return Selectors.getAll(DModel, undefined, undefined, true, false); }\r\n\r\n    static getModel(name: string, caseSensitive: boolean = false, wrap: boolean = false): DModel | LModel | null {\r\n        if (!caseSensitive) name = name.toLowerCase();\r\n        let ret = Selectors.getAll<DModel, LModel>(DModel, (d) => (caseSensitive ? d.name : d.name.toLowerCase()) === name, undefined, true, wrap as any)[0];\r\n        return ret;\r\n    }\r\n\r\n    static getByName(classe: typeof DPointerTargetable, name: string, caseSensitive: boolean = false, wrap: boolean = false): DPointerTargetable | LPointerTargetable | null {\r\n        return Selectors.getByField(classe, 'name', name, caseSensitive, wrap); }\r\n\r\n    static getByField(classe: typeof DPointerTargetable, field: string, value: string, caseSensitive: boolean = false, wrap: boolean = false): DPointerTargetable | LPointerTargetable | null {\r\n        if (!caseSensitive) value = value.toLowerCase();\r\n        let condition = (d: any) => {\r\n            let ret = (caseSensitive ? d[field] : d[field]?.toLowerCase()) === value;\r\n            console.log('filtering getall by field:', {d, dfield:d[field], value, ret});\r\n            return ret;\r\n        }\r\n        let ret = Selectors.getAll(classe, condition, undefined, true, wrap as any)[0];\r\n        return ret; }\r\n\r\n    static getViewIDs(condition?: (m: DModel) => boolean): Pointer<DViewElement>[] { return Selectors.getAll(DViewElement); }\r\n\r\n\r\n\r\n    private static queryJS(model: LModel, query: string): LPointerTargetable[] {\r\n        try {\r\n            return eval(query);\r\n        } catch (e) { return []; }\r\n    }\r\n    /*static getCurrentView(data: LModelElement): DViewElement {\r\n        Log.exDevv('todo');\r\n        return undefined as any;\r\n    }*/\r\n\r\n    private static matchesMetaClassTarget(v: DViewElement, data?: DModelElement | DGraphElement | undefined): number {\r\n        if (!v) return ViewEClassMatch.MISMATCH_PRECONDITIONS;\r\n        if (!v.appliableToClasses || !v.appliableToClasses.length) return ViewEClassMatch.IMPLICIT_MATCH;\r\n        if (!data) return ViewEClassMatch.MISMATCH_PRECONDITIONS;\r\n        let ThisClass: typeof DPointerTargetable = RuntimeAccessibleClass.get(data.className);\r\n        Log.exDev(!ThisClass, 'unable to find class type:', {v, data}); // todo: v = view appliable to DModel, data = proxy<LModel>\r\n        let gotSubclassMatch: boolean = false;\r\n        for (let classtarget of v.appliableToClasses) {\r\n            const ClassTarget: typeof DPointerTargetable = RuntimeAccessibleClass.get(classtarget);\r\n            if (ThisClass === ClassTarget) return ViewEClassMatch.EXACT_MATCH; // explicit exact match\r\n            if (!gotSubclassMatch && U.classIsExtending(ThisClass, ClassTarget)) gotSubclassMatch = true; // explicit subclass match\r\n            if (gotSubclassMatch) return ViewEClassMatch.INHERITANCE_MATCH;\r\n        }\r\n        return ViewEClassMatch.MISMATCH_PRECONDITIONS;\r\n }\r\n\r\n    private static isOfSubclass(data: DPointerTargetable, classTarget: string | typeof DPointerTargetable, acceptEquality: boolean = false): boolean {\r\n        let ThisClass: typeof DPointerTargetable = RuntimeAccessibleClass.get(data.className);\r\n        Log.exDev(!ThisClass, 'isOfSubclass() unable to find class type:', {data});\r\n        const ClassTarget: typeof DPointerTargetable = typeof classTarget === \"string\"? RuntimeAccessibleClass.get(classTarget) : classTarget;\r\n        if (ThisClass === ClassTarget) return acceptEquality;\r\n        return U.classIsExtending(ThisClass, ClassTarget);\r\n    }\r\n\r\n\r\n    static getViewByIDOrNameD(name: string | DViewElement | LViewElement, state?: DState): undefined | DViewElement {\r\n        if (!state) state = store.getState();\r\n        if (typeof name === \"object\") { return (name as any).__raw || name as any; }\r\n        if (state.idlookup[name]?.className === DViewElement.cname) return state.idlookup[name] as DViewElement;\r\n        let id = Selectors.getViewIdFromName(name, state);\r\n        if (id && state.idlookup[id]?.className === DViewElement.cname) return state.idlookup[id] as DViewElement;\r\n        return undefined;\r\n    }\r\n\r\n\r\n    // input: \"subview.subview2.targetview\"\r\n    // output: returns pointer to targetview\r\n    // path is not required to start with a root, it's also possible to start navigating from a subview (notviewpoint/model view)\r\n    // in case multiple matches are given due to incomplete path not starting from a viewpoint, the oldest matching view is returned.\r\n    static getViewIdFromName(namepath: string, state?: DState): undefined | Pointer<DViewElement> {\r\n        if (!state) state = store.getState();\r\n        let names: string[] = namepath.split(\".\");\r\n        let eligibleContainers: Pointer<DViewElement>[] = state.viewelements;\r\n        for (let i = 0; i < names.length; i++) {\r\n            let name = names[i];\r\n            eligibleContainers = eligibleContainers.filter(v => ((state as DState).idlookup[v] as DViewElement).name === name);\r\n            if (i === names.length-1 || eligibleContainers.length === 0) return eligibleContainers[0];\r\n            eligibleContainers = eligibleContainers.flatMap(v => Object.keys(((state as DState).idlookup[v] as DViewElement).subViews));\r\n        }\r\n        return undefined;\r\n    }\r\n\r\n\r\n    // todo: idea, set query complexity = explicitpriority amd autoset explicit priority to query lemgth\r\n    private static getQueryComplexity = (query: string) => query.length; // todo: the more \"or\" and navigations there are, the more a query is \"complex\", the more the query match is a priority.\r\n\r\n\r\n    static getAllGraphElementPointers(): Pointer<DGraphElement>[] {\r\n        // graphelements = fields;\r\n        let state: DState = store.getState();\r\n        return [...state.graphs, ...state.graphvertexs, ...state.graphelements, ...state.vertexs, ...state.edgepoints, ...state.edges];\r\n    }\r\n\r\n    private static getFinalScore(entry: ViewScore, vid: Pointer<DViewElement>, parentView: DViewElement | undefined, dview: DViewElement): number {\r\n        if (entry.metaclassScore === ViewEClassMatch.MISMATCH_PRECONDITIONS) return ViewEClassMatch.MISMATCH;\r\n        if (entry.viewPointMatch === ViewEClassMatch.VP_MISMATCH) return ViewEClassMatch.MISMATCH;\r\n        if (entry.jsScore === ViewEClassMatch.MISMATCH_JS || entry.OCLScore === ViewEClassMatch.MISMATCH_JS) return ViewEClassMatch.MISMATCH;\r\n        let pvMatch: boolean = parentView ? vid in parentView.subViews : false;\r\n        let pvScore: number = pvMatch ? (parentView as DViewElement).subViews[vid] : 1;\r\n        let explicitprio: number;\r\n        if (typeof entry.jsScore === 'number') {\r\n            explicitprio = entry.jsScore;\r\n        } else if (dview.explicitApplicationPriority === undefined) {\r\n            // in editor put placeholder with computed expression\r\n            explicitprio = (dview.jsCondition?.length || 1) + (dview.oclCondition?.length || 1);\r\n        } else explicitprio = dview.explicitApplicationPriority;\r\n\r\n        return entry.viewPointMatch * entry.metaclassScore * pvScore * explicitprio;\r\n        //score = precoditiom * paremtview(comfiguravle) * (explicitprio = jsValid*jslemgth + oclvalid*ocllemgth)\r\n        // or if jscomditiom returmed mumver --> * jsscore\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n/*\r\n    //this function handles: what i do when view changes? do i recompute the score?\r\n    static updateViewMatchings(dview: DViewElement, updatePreconditions: boolean, updateOCLScore: boolean, store: DState, updateManualViews: boolean = false, forcedUpdateViews: boolean = false): void {\r\n\r\n        //  event           observed change         ignore change\r\n        //  ocl             data                    node, view (except view.ocl)\r\n        //  jsCondition     all                     none\r\n        //  appliableTo     view.appliableto\r\n        // if (!forcedUpdateViews && (dview.oclUpdateCondition === 'manual') !== updateManualViews) return;\r\n        // modularize getscoresnew split in setpreconditionscore, setoclscorem, setjscscore, and call those only if observed stuff changed\r\n\r\n        const allNodes: DGraphElement[] = DPointerTargetable.fromPointer(Selectors.getAllGraphElementPointers());\r\n        //let dview = view.__raw;\r\n        let vid = dview.id; // optimize searching multiple usages and replacing\r\n\r\n        // filter alldata to exclude modelpieces that didn't pass the view.appyto check\r\n        // let oclData: (LModelElement)[] = allData.filter(l => {\r\n        let oclnodes: (DGraphElement)[] = allNodes.filter((dg: DGraphElement) => {\r\n            if (!dg) return false;\r\n            if (true) {\r\n                let d: DModelElement | undefined = dg.model ? DPointerTargetable.fromPointer(dg.model) : undefined;\r\n                let firstEvaluationForNodeView: boolean = false;\r\n                if (!transientProperties.node[dg.id]) { transientProperties.node[dg.id] = {viewScores: {}} as any; firstEvaluationForNodeView = true; }\r\n                if (!transientProperties.node[dg.id].viewScores[vid]) { transientProperties.node[dg.id].viewScores[vid] = {score: undefined} as any; firstEvaluationForNodeView = true; }\r\n\r\n                if (firstEvaluationForNodeView || updatePreconditions) {\r\n                    const oldScore = transientProperties.node[dg.id].viewScores[vid].score;\r\n                    const newScore = transientProperties.node[dg.id].viewScores[vid].score = this.matchesMetaClassTarget(dview, d);\r\n                    if (oldScore !== newScore) transientProperties.node[dg.id].stackViews = undefined as any; // force re-sorting\r\n                    // 67{}[]'?^&&||nb>\r\n                } /* else {\r\n                    if (!transientProperties.view[dview.id].oclUpdateCondition_PARSED( transientProperties.node[dg.id].viewScores[vid].)) return;\r\n                }* /\r\n                // no need to check if parentview changed as well. i optimized by not having parentview affect the numeric scores, but only the view queue array sorting\r\n\r\n                // transient.node[dg.id].viewScores[vid].score = MISSING (hasOwnProperty);    if the view or model is new and they are not yet evaluated.\r\n                // transient.node[dg.id].viewScores[vid].score = Number.NEGATIVE_INFINITY;    if pre-ocl conditions failed (view.appliableTo)\r\n                // transient.node[dg.id].viewScores[vid].score = 0;                           if preconditions are met, but ocl failed\r\n                // transient.node[dg.id].viewScores[vid].score = number ocl score;            if preconditions are met and ocl matched\r\n                // transient.node[dg.id].viewScores[vid].score = number precondition score;   if preconditions are met, and there is no ocl condition\r\n                // changed: matching score and ocl score are summed.\r\n                return transientProperties.node[dg.id].viewScores[vid].score !== undefined;\r\n            }\r\n\r\n            // if (model_viewstack[vid]) { filledElementsInOclData++; return l; } return undefined;\r\n        });\r\n        function mergeViewScores(preconditionScore: number, oclScore: number): number{ return preconditionScore + oclScore; }\r\n    }*/\r\n\r\n\r\n\r\n\r\n    static updateScores(data0: LModelElement | undefined, node: LGraphElement | undefined, nid: Pointer<DGraphElement>, pv: DViewElement | undefined){\r\n        let needsorting: boolean = false;\r\n        let firstEvaluationForNode: boolean = false;\r\n        let firstEvaluationForNodeView: boolean = false;\r\n        let tn = transientProperties.node[nid];\r\n        if (!tn) { transientProperties.node[nid] = tn = new NodeTransientProperties(); firstEvaluationForNode = true; }\r\n        let olddata = tn.viewSorted_modelused as LModelElement;\r\n        //let oldnode = transientProperties.node[nid]?.viewSorted_nodeused as LGraphElement;\r\n        const data: LModelElement = data0 as LModelElement;\r\n        // console.error('changed', {data, olddata, node, oldnode, cdata:data?.clonedCounter, colddata:olddata?.clonedCounter})\r\n        const pvid: Pointer<DViewElement> | undefined = pv?.id;\r\n        const oldpv: DViewElement | undefined = tn.viewSorted_pvid_used;\r\n        let datachanged: boolean = (!!data !== !!olddata) || !!(data && olddata) && (data.clonedCounter !== olddata.clonedCounter);\r\n        //let nodechanged: boolean = (!!node !== !!oldnode) || !!(node && oldnode) && (node.clonedCounter !== oldnode.clonedCounter);\r\n        let parentViewChanged: boolean = (pvid !== oldpv?.id || (!!(pv && oldpv) && oldpv.subViews !== pv.subViews)); // shallow comparison is fine.\r\n        if (parentViewChanged) tn.viewSorted_pvid_used = pv;\r\n        //if (nodechanged) transientProperties.node[nid].viewSorted_nodeused = node;\r\n        if (datachanged) tn.viewSorted_modelused = data;\r\n\r\n        // let nodechanged: boolean\r\n        // important to remember: how i'm using parentView in score and storage.\r\n        // i'm calculating and storing every score without parentView, then i apply it right before sorting the array,\r\n        // the enhanced value is not sored anyway but affects array sorting.\r\n        // so if parentView changes, or if his subviews changed, need to resort array without recomputing any score value.\r\n\r\n        //console.log('2302, getviews 2', {datachanged, nodechanged, olddata, oldnode, data, node, allViews: Selectors.getAllViewElements()});\r\n\r\n        let state: DState = store.getState();\r\n        const allViews: DViewElement[] = Selectors.getAllViewElements(state);\r\n\r\n        const user = LUser.fromPointer(DUser.current);\r\n        const project = user.project as LProject;\r\n        let activevpid: Pointer<DViewElement> = project.activeViewpoint.id;\r\n        // check if scores needs to be updated\r\n        for (const dview of allViews) {\r\n            let vid = dview.id;\r\n            let tv = transientProperties.view[vid];\r\n            if (!tv) transientProperties.view[vid] = tv = {} as any;\r\n            let tnv = tn.viewScores[vid];\r\n            //console.log('2302, getviews evaluating view ' + vid, {vid, dview});\r\n            // check initialization\r\n\r\n            if (!tnv) {\r\n                transientProperties.node[nid].viewScores[vid] = tnv = {} as any;\r\n                /*{\r\n                    score: ViewEClassMatch.NOT_EVALUATED_YET,\r\n                    metaclassScore: ViewEClassMatch.NOT_EVALUATED_YET,\r\n                    //jsScore:ViewEClassMatch.NOT_EVALUATED_YET,\r\n                    //OCLScore: ViewEClassMatch.NOT_EVALUATED_YET\r\n                } as any;*/\r\n                firstEvaluationForNodeView = true;\r\n            } else firstEvaluationForNodeView = tnv.metaclassScore === ViewEClassMatch.NOT_EVALUATED_YET; // todo: when changing view.appliableTo, delete all tnv using that view.\r\n\r\n            // don't match exclusive views from other vp\r\n            let dvp: DViewPoint = DPointerTargetable.fromPointer(dview.viewpoint, state);\r\n            let oldVpMatch: number = tnv.viewPointMatch;\r\n            // console.log(\"vp matching \" +vid, {vid, dvp, activevpid });\r\n            if (dvp.id === activevpid) tnv.viewPointMatch = ViewEClassMatch.VP_Explicit;\r\n            else if (dvp.id === 'Pointer_ViewPointDefault') tnv.viewPointMatch = ViewEClassMatch.VP_Default;\r\n            else if (!dvp.isExclusiveView) tnv.viewPointMatch = ViewEClassMatch.VP_Decorative;\r\n            else tnv.viewPointMatch = ViewEClassMatch.VP_MISMATCH;\r\n\r\n            if (!needsorting && (oldVpMatch !== tnv.viewPointMatch)) needsorting = true;\r\n            if (tnv.viewPointMatch === ViewEClassMatch.VP_MISMATCH) {\r\n                tnv.finalScore = ViewEClassMatch.VP_MISMATCH;\r\n                continue;\r\n            }\r\n\r\n\r\n            // check preconditions\r\n            if (firstEvaluationForNodeView) {\r\n                const oldScore = tnv.metaclassScore;\r\n                tnv.metaclassScore = this.matchesMetaClassTarget(dview, data?.__raw);\r\n                needsorting = true; // sorting is mandatory here because it's the first evaluation of node-vie\r\n                // if mismatch i stop computing the score.\r\n                if (tnv.metaclassScore === ViewEClassMatch.MISMATCH_PRECONDITIONS) {\r\n                    tnv.finalScore = ViewEClassMatch.MISMATCH;\r\n                    continue;\r\n                }\r\n            } else if (tnv.metaclassScore === ViewEClassMatch.MISMATCH_PRECONDITIONS) continue;\r\n\r\n            if (true) {\r\n                // this needs to be called not only if datachanged || nodechanged, but everytime in case it is a reference like data.$value.name.length\r\n                // also his performances are so fast that it might be more costly to check if it's supposed to be reevaluated than just calling it.\r\n                let jsScoreChanged: boolean = Selectors.updateJSScore(node, data, dview, tv, tnv);\r\n                if (!needsorting && jsScoreChanged) needsorting = true;\r\n                // if mismatch i stop computing the score.\r\n                if (tnv.jsScore === ViewEClassMatch.MISMATCH_JS) { tnv.finalScore = ViewEClassMatch.MISMATCH; continue; }\r\n            }\r\n\r\n            // check pre-ocl guard\r\n            // if (!tv.oclUpdateCondition_PARSED(data, olddata)) continue;\r\n\r\n            if (datachanged || tnv.OCLScore === ViewEClassMatch.NOT_EVALUATED_YET) {\r\n                // check ocl: this can lead to mis-updating if ocl queries a reference.\r\n                // but OCL is computationally heavy, so i decided it is now a requirement to update the model to reevaluate ocl.\r\n                let oldScore = tnv.OCLScore;\r\n                tnv.OCLScore = OCL.test(data, dview, node)//Selectors.calculateOCLScore({data, node, dview});\r\n                tv.oclChanged = false;\r\n                if (!needsorting && tnv.OCLScore !== oldScore) needsorting = true;\r\n                if (tnv.OCLScore === ViewEClassMatch.MISMATCH_OCL) { tnv.finalScore = ViewEClassMatch.MISMATCH; continue; }\r\n            }\r\n        }\r\n\r\n        if (parentViewChanged) needsorting = true; // scores saved in dictionaries are the same, but score in final sorted array changed.\r\n        return needsorting;\r\n    }\r\n\r\n    // get final viewstack for a node, also updates OCL scores if needed because of a change in model or parentView (NOT from a change in view)\r\n    static getAppliedViewsNew({data:data0, node, pv, nid}:{ node: LGraphElement | undefined; data: LModelElement | undefined; pv: DViewElement | undefined; nid: Pointer<DGraphElement>}): NodeTransientProperties {\r\n        // console.trace('2302, getviews', {tnode: transientProperties.node[nid], nid, pv})\r\n        let needsorting: boolean = Selectors.updateScores(data0, node, nid, pv);\r\n\r\n        let tn: NodeTransientProperties = transientProperties.node[nid]; // needs to be placed after updateScores() which will initialize it.\r\n        type ViewScoreEntry = {element: Pointer<DViewElement>, score: number, view: LViewElement};\r\n        if (needsorting || !tn.stackViews) {\r\n            let mainViews: ViewScoreEntry[] = [];\r\n            let decorativeViews: ViewScoreEntry[] = [];\r\n            let state = store.getState();\r\n            for (let vid of Object.keys(tn.viewScores)) {\r\n                let tnv = tn.viewScores[vid];\r\n                const dview: DViewElement = DPointerTargetable.fromPointer(vid, state);\r\n                const score = tnv.finalScore = Selectors.getFinalScore(tnv, vid, pv, dview);\r\n                if (!(score > 0)) continue; // do not flip to <=, because undefined and NEGATIVE_INFINITY always compute to false.\r\n                (dview.isExclusiveView ? mainViews : decorativeViews).push( {element:vid, score, view: LPointerTargetable.fromD(dview)} );\r\n            }\r\n            decorativeViews.sort((s1, s2)=> s2.score - s1.score); // sorted from biggest to smallest\r\n            mainViews.sort((s1, s2)=> s2.score - s1.score); // sorted from biggest to smallest\r\n\r\n            // Log.exDev(!mainViews[0], 'cannot find a matching main view', {mainViews, decorativeViews, data0, scores: tn.viewScores})\r\n            tn.mainView = mainViews[0]?.view;\r\n            tn.validMainViews = mainViews.map((s)=> s.view);\r\n            tn.stackViews = decorativeViews.map((s)=> s.view);\r\n        }\r\n        // chamges to view or ocl comditiom are mot hamdled here, ut om multple mp/modes a omce\r\n        //nb{}[]\r\n\r\n        // if data or view changed update the score dict, them re-sort the view arr first, fimally update Sorted_modelused, Sorted_modelused\r\n        // console.log('2302 getviews ret', {dn: data?.name, data, stack: transientProperties.node[nid].stackViews, stackn: transientProperties.node[nid].stackViews.map(v => v.name), scores: transientProperties.node[nid]});\r\n\r\n        // throw new Error(\"stop debug\");\r\n        return tn;\r\n\r\n    }\r\n\r\n    static getAllMP(state?: DState): DModelElement[] {\r\n        if (!state) state = store.getState();\r\n        let allD: DPointerTargetable[] = Object.values(state.idlookup);\r\n        return allD.filter( (d: DPointerTargetable) => U.isObject(d) && Selectors.isOfSubclass(d, DModelElement)) as DModelElement[]; }\r\n\r\n    static toObject<D extends DPointerTargetable>(ptrs: Pointer<D>[], state?: DState):D[] {\r\n        if (!state) state = store.getState();\r\n        return ptrs.map(p => (state as DState).idlookup[p]) as D[]; }\r\n\r\n    static wrap<D extends DPointerTargetable, L extends LPointerTargetable>(arr: (Pointer<D, 1, 1, L> | D)[], state?: DState): L[] {\r\n        if (!arr.length) return [];\r\n        if (!state) state = store.getState();\r\n        let objarr: D[];\r\n        if (typeof arr[0] === \"string\") { objarr = Selectors.toObject(arr as string[], state); }\r\n        else objarr = arr as D[];\r\n        return objarr.map(p => RuntimeAccessibleClass.wrap(p)) as L[]; }\r\n\r\n    static unwrap<D extends DPointerTargetable, L extends LPointerTargetable>(arr:L[]): D[] { return arr.map( (a)=> a.__raw) as any[]; }\r\n    static getSubNodeElements(forGraph: Pointer<DGraph, 1, 1>, asPointers: boolean = false, wrap: boolean = false): Pointer<DGraphElement>[] | DGraphElement[] | LGraphElement[] {\r\n        const state : DState = store.getState();\r\n        const g: DGraph = state.idlookup[forGraph] as DGraph;\r\n        if (asPointers) return g.subElements;\r\n        const subelements: DGraphElement[] = g.subElements.map( geid => state.idlookup[geid]) as DGraphElement[];\r\n        if (wrap) return subelements.map<LGraphElement>( (ge) => LPointerTargetable.from(ge));\r\n        return subelements; }\r\n\r\n\r\n\r\n\r\n    //// giordano part\r\n\r\n\r\n\r\n    public static getAllPackageClasses(id: string): LClass[] {\r\n        const data = LPointerTargetable.from(id) as GObject;\r\n        let lPackage : LPackage | undefined;\r\n        const classes: LClass[] = [];\r\n        if (data.className === \"DReference\") {\r\n            const lClass: LClass = LPointerTargetable.from(data.father);\r\n            lPackage = LPointerTargetable.from(lClass.father);\r\n        }\r\n        if (data.className === \"DParameter\") {\r\n            const lOperation: LOperation = LPointerTargetable.from(data.father);\r\n            const lClass: LClass = LPointerTargetable.from(lOperation.father);\r\n            lPackage = LPointerTargetable.wrap(lClass.father);\r\n        }\r\n        if (data.className === \"DOperation\") {\r\n            const lClass: LClass = LPointerTargetable.from(data.father);\r\n            lPackage = LPointerTargetable.wrap(lClass.father);\r\n        }\r\n        if (lPackage) {\r\n            for(let classifier of lPackage.classifiers) {\r\n                const lClassifier: LClass | LEnumerator = LPointerTargetable.from(classifier);\r\n                if(lClassifier.className === \"DClass\") classes.push(lClassifier as LClass);\r\n            }\r\n        }\r\n        return classes;\r\n    }\r\n    public static getAllPackageEnumerators(id: string): LEnumerator[] {\r\n        const data = LPointerTargetable.from(id) as GObject;\r\n        let lPackage : LPackage | undefined;\r\n        const enumerators: LEnumerator[] = [];\r\n        if(data.className === \"DAttribute\") {\r\n            const lClass: LClass = LPointerTargetable.from(data.father);\r\n            lPackage = LPointerTargetable.from(lClass.father);\r\n        }\r\n        if(data.className === \"DParameter\") {\r\n            const lOperation: LOperation = LPointerTargetable.from(data.father);\r\n            const lClass: LClass = LPointerTargetable.from(lOperation.father);\r\n            lPackage = LPointerTargetable.from(lClass.father);\r\n        }\r\n        if(data.className === \"DOperation\") {\r\n            const lClass: LClass = LPointerTargetable.from(data.father);\r\n            lPackage = LPointerTargetable.from(lClass.father);\r\n        }\r\n        if(lPackage) {\r\n            for(let classifier of lPackage.classifiers) {\r\n                const lClassifier: LClass | LEnumerator = LPointerTargetable.from(classifier);\r\n                if(lClassifier.className === \"DEnumerator\") enumerators.push(lClassifier as LEnumerator);\r\n            }\r\n        }\r\n        return enumerators;\r\n    }\r\n\r\n    private static updateJSScore(node: LGraphElement | undefined, data: LModelElement | undefined, dview: DViewElement, tv: ViewTransientProperties, tnv: ViewScore) {\r\n        let oldjsScore = tnv.jsScore;\r\n        let jsConditionChanged: boolean = tv.jsConditionChanged;\r\n        tv.jsConditionChanged = false;\r\n\r\n        // tnv.jsScore = ViewEClassMatch.NOT_EVALUATED_YET as any as number;\r\n        let printstuff = {name: data?.name, jsc:tv.jsCondition, tv:{...tv}, data:data&&data.__raw, node:node&&{...node.__raw}, nerr: (node as any)?.errors}\r\n        if (tv.jsCondition) {\r\n            try {\r\n                tnv.jsScore = tv.jsCondition({data, node, view: LPointerTargetable.fromD(dview), constants: tv.constants});\r\n                // if (tnv.jsScore === true) tnv.jsScore = dview.jsCondition.length;\r\n                switch (typeof tnv.jsScore) {\r\n                    case \"boolean\": // bool is fine if true\r\n                        if (!tnv.jsScore) tnv.jsScore = ViewEClassMatch.MISMATCH_JS;\r\n                        break;\r\n                    case \"number\": // number is fine if not NaN and > 0\r\n                        if (isNaN(tnv.jsScore) || tnv.jsScore < 0) tnv.jsScore = ViewEClassMatch.MISMATCH_JS;\r\n                        break;\r\n                    default:\r\n                        tnv.jsScore = ViewEClassMatch.MISMATCH_JS;\r\n                        break;\r\n                }\r\n            }\r\n            catch (e:any) { // crash = mismatch\r\n                Log.ee(\"failed to evaluate jsCondition: \" + e.message?.split(\"\\n\")[0], {e, data, node, tnv, jsc:tv.jsCondition+''});\r\n                tnv.jsScore = ViewEClassMatch.MISMATCH_JS;\r\n            }\r\n        } else tnv.jsScore = true; // missing condition = match\r\n\r\n        // jsConditionChanged: because even if score didn't change, if jsc.length changed the final computed score is affected\r\n        return jsConditionChanged || tnv.jsScore !== oldjsScore;\r\n    }\r\n}\r\n\r\n(window as any).Selectors = Selectors;\r\n\r\nclass Scored<T extends GObject> {\r\n    constructor(public score: number, public element: T) {}\r\n}\r\n"],"mappings":"8xBAAA,OAgCIA,KAAK,CACLC,KAAK,CAELC,YAAY,CACZC,kBAAkB,CAClBC,MAAM,CACNC,aAAa,CACbC,GAAG,CACHC,GAAG,CACHC,kBAAkB,CAClBC,iBAAiB,CACjBC,sBAAsB,CACtBC,KAAK,CACLC,CAAC,CACDC,YAAY,CACZC,uBAAuB,CAAEC,mBAAmB,CAAEC,eAAe,KAC1D,cAAc,CACrB,OAAyBC,oBAAoB,CAAEC,aAAa,KAAO,gBAAgB,CAGnF,UACa,CAAAC,SAAS,EAAAC,IAAA,CADrBX,iBAAiB,CAAC,WAAW,CAAC,CAAAW,IAAA,CAAAC,MAAA,EAAAC,OAAA,kCAAAH,UAAA,EAAAI,eAAA,MAAAJ,SAAA,GAAAK,YAAA,CAAAL,SAAA,QAAAM,GAAA,kBAAAC,KAAA,CAG3B,SAAAC,eAAA,CAAqC,KAAAC,oBAAA,CACjC,GAAI,CAAAC,SAAsB,CAC1B,GAAI,CAAAC,KAAuB,CAAGnB,KAAK,CAACoB,QAAQ,CAAC,CAAC,CAC9C,GAAM,CAAAC,QAAQ,EAAAJ,oBAAA,CAAGE,KAAK,CAACG,aAAa,UAAAL,oBAAA,iBAAnBA,oBAAA,CAAqBM,YAAY,CAClD,GAAGF,QAAQ,CAAE,CACT,GAAM,CAAAG,EAAE,CAAG3B,kBAAkB,CAAC4B,WAAW,CAACJ,QAAQ,CAAC,CACnDH,SAAS,CAAIM,EAAE,CAAIA,EAAE,CAACE,KAAK,CAAG,IAAI,CACtC,CAAC,IAAM,CAAAR,SAAS,CAAG,IAAI,CACvB,MAAO,CAAAA,SAAS,CACpB,CAAC,GAAAJ,GAAA,wBAAAC,KAAA,CAED,SAAAY,qBAAgHR,KAAc,CAAO,KAAAS,qBAAA,CACjIT,KAAK,CAAGA,KAAK,EAAInB,KAAK,CAACoB,QAAQ,CAAC,CAAC,CACjC,GAAI,CAAAI,EAAE,EAAAI,qBAAA,CAAGT,KAAK,CAACG,aAAa,UAAAM,qBAAA,iBAAnBA,qBAAA,CAAqBL,YAAY,CAC1C,GAAI,CAACC,EAAE,CAAE,MAAO,CAAC,CAAC,CAClB,GAAI,CAAAK,GAAQ,CAAG,CAACC,OAAO,CAAEjC,kBAAkB,CAAC4B,WAAW,CAACD,EAAE,CAAEL,KAAK,CAAC,CAAQ,CAC1EU,GAAG,CAACH,KAAK,CAAGG,GAAG,CAACC,OAAO,CAAEJ,KAAK,CAC9B,GAAIG,GAAG,CAACH,KAAK,CAACK,WAAW,CAAEF,GAAG,CAACG,EAAE,CAAGH,GAAG,CAACH,KAAK,CAAC,IACzC,CACDG,GAAG,CAACI,EAAE,CAAGJ,GAAG,CAACH,KAAK,CAClBG,GAAG,CAACG,EAAE,CAAGH,GAAG,CAACI,EAAE,CAACC,UAAU,CAC9B,CACA,MAAO,CAAAL,GAAG,CACd,CAAC,GAAAf,GAAA,sBAAAC,KAAA,CAED,SAAAoB,mBAA0BC,MAAe,CAAkB,CACvD;AACA,GAAM,CAAAjB,KAAsB,CAAGiB,MAAM,EAAIpC,KAAK,CAACoB,QAAQ,CAAC,CAAC,CACzD,GAAM,CAAAiB,IAA6B,CAAGC,MAAM,CAACC,MAAM,CAAEpB,KAAK,CAAEqB,YAAY,CAAC,CACzE,GAAI,CAAAC,KAAqB,CAAGJ,IAAI,CAACK,GAAG,CAAgB,SAACC,GAAG,QAAK,CAAAnD,kBAAkB,CAACiC,WAAW,CAACkB,GAAG,CAAExB,KAAK,CAAC,EAAgB,CAAC,CACxH,MAAO,CAAAsB,KAAK,CAChB,CACA;AAAA,GAAA3B,GAAA,iBAAAC,KAAA,CAEA,SAAA6B,cAAA,CAA6C,CACzC,GAAM,CAAAzB,KAAuB,CAAGnB,KAAK,CAACoB,QAAQ,CAAC,CAAC,CAChD,MAAO,CAAAvB,kBAAkB,CAAC4B,WAAW,CAACN,KAAK,CAAC0B,UAAU,CAAC,CAC3D,CAAC,GAAA/B,GAAA,gBAAAC,KAAA,CACD,SAAA+B,aAAA,CAA0C,CACtC,GAAM,CAAA3B,KAAuB,CAAGnB,KAAK,CAACoB,QAAQ,CAAC,CAAC,CAChD,MAAO,CAAAvB,kBAAkB,CAAC4B,WAAW,CAACN,KAAK,CAAC4B,SAAS,CAAC,CAC1D,CAAC,GAAAjC,GAAA,cAAAC,KAAA,CAED,SAAAiC,WAAA,CAAsC,CAClC,GAAI,CAAA7B,KAAuB,CAAGnB,KAAK,CAACoB,QAAQ,CAAC,CAAC,CAC9C,GAAM,CAAAiB,IAA8B,CAAGC,MAAM,CAACC,MAAM,CAAEpB,KAAK,CAAE8B,OAAO,CAAC,CACrE,GAAM,CAAAC,QAAmB,CAAGb,IAAI,CAACK,GAAG,CAAW,SAACC,GAAG,QAAK,CAAAxB,KAAK,CAACgC,QAAQ,CAACR,GAAG,CAAC,EAAW,CAAC,CACvF,GAAM,CAAAS,QAAmB,CAAG,EAAE,CAAC,IAAAC,SAAA,CAAAC,0BAAA,CACZJ,QAAQ,EAAAK,KAAA,KAA3B,IAAAF,SAAA,CAAAG,CAAA,KAAAD,KAAA,CAAAF,SAAA,CAAAI,CAAA,IAAAC,IAAA,EAA6B,IAArB,CAAAC,OAAO,CAAAJ,KAAA,CAAAxC,KAAA,CACXqC,QAAQ,CAACQ,IAAI,CAAC/D,kBAAkB,CAAC4B,WAAW,CAACkC,OAAO,CAACE,EAAE,CAAC,CAAC,CAC7D,CAAC,OAAAC,GAAA,EAAAT,SAAA,CAAAU,CAAA,CAAAD,GAAA,WAAAT,SAAA,CAAAW,CAAA,IACD,MAAO,CAAAZ,QAAQ,CACnB,CAAC,GAAAtC,GAAA,aAAAC,KAAA,CACD,SAAAkD,UAAA,CAAoC,CAChC,GAAI,CAAA9C,KAAuB,CAAGnB,KAAK,CAACoB,QAAQ,CAAC,CAAC,CAC9C,GAAM,CAAAiB,IAA6B,CAAGC,MAAM,CAACC,MAAM,CAAEpB,KAAK,CAAEoB,MAAM,CAAC,CACnE,GAAM,CAAA2B,OAAiB,CAAG7B,IAAI,CAACK,GAAG,CAAU,SAACC,GAAG,QAAK,CAAAxB,KAAK,CAACgC,QAAQ,CAACR,GAAG,CAAC,EAAU,CAAC,CACnF,GAAM,CAAAwB,OAAiB,CAAG,EAAE,CAAC,IAAAC,UAAA,CAAAd,0BAAA,CACXY,OAAO,EAAAG,MAAA,KAAzB,IAAAD,UAAA,CAAAZ,CAAA,KAAAa,MAAA,CAAAD,UAAA,CAAAX,CAAA,IAAAC,IAAA,EAA2B,IAAnB,CAAAY,MAAM,CAAAD,MAAA,CAAAtD,KAAA,CACV,GAAGuD,MAAM,SAANA,MAAM,iBAANA,MAAM,CAAET,EAAE,CAAE,CACXM,OAAO,CAACP,IAAI,CAAC/D,kBAAkB,CAAC4B,WAAW,CAAC6C,MAAM,CAACT,EAAE,CAAC,CAAC,CAC3D,CACJ,CAAC,OAAAC,GAAA,EAAAM,UAAA,CAAAL,CAAA,CAAAD,GAAA,WAAAM,UAAA,CAAAJ,CAAA,IACD,MAAO,CAAAG,OAAO,CAClB,CAAC,GAAArD,GAAA,cAAAC,KAAA,CAED,SAAAwD,WAAA,CAAsC,CAClC,GAAM,CAAApD,KAAuB,CAAGnB,KAAK,CAACoB,QAAQ,CAAC,CAAC,CAChD,MAAO,CAAAD,KAAK,CAACqD,OAAO,CACxB,CAAC,GAAA1D,GAAA,YAAAC,KAAA,CAED,SAAAK,SAAA,CAA8B,CAC1B,GAAM,CAAAD,KAAuB,CAAGnB,KAAK,CAACoB,QAAQ,CAAC,CAAC,CAChD,MAAO,CAAAD,KAAK,CAChB,CAAC,GAAAL,GAAA,wBAAAC,KAAA,CAED,SAAA0D,qBAA4BC,IAA4C,CAAEvD,KAAc,CAAe,CACnG,GAAI,CAAAwD,SAAiB,CAAG,CAACpE,aAAa,CAACmE,IAAW,CAAC,EAAIA,IAAI,EAAEE,WAAW,CAAC,CAAC,CAC1E,GAAI,CAACzD,KAAK,CAAEA,KAAK,CAAGnB,KAAK,CAACoB,QAAQ,CAAC,CAAC,CACpC;AACA,MAAO,CAAAD,KAAK,CAACgC,QAAQ,CAAC,UAAU,CAAC7C,oBAAoB,CAACuE,OAAO,CAACD,WAAW,CAAC,CAAC,CAAC,CAChF,CAAC,GAAA9D,GAAA,oBAAAC,KAAA,CACD,SAAA+D,iBAAwBJ,IAAsC,CAAEvD,KAAc,CAAe,CACzF,GAAI,CAAAwD,SAAiB,CAAG,CAACzE,YAAY,CAACwE,IAAW,CAAC,EAAIA,IAAI,EAAEE,WAAW,CAAC,CAAC,CACzE,GAAI,CAACzD,KAAK,CAAEA,KAAK,CAAGnB,KAAK,CAACoB,QAAQ,CAAC,CAAC,CACpC,MAAO,CAAAD,KAAK,CAACgC,QAAQ,CAAC,UAAU,CAACwB,SAAS,CAAC,CAC/C,CAAC,GAAA7D,GAAA,wBAAAC,KAAA,CACD,SAAAgE,qBAAA,CAA6C,CACzC,GAAI,CAAA5D,KAAuB,CAAGnB,KAAK,CAACoB,QAAQ,CAAC,CAAC,CAC9C,GAAM,CAAAiB,IAAkC,CAAGC,MAAM,CAACC,MAAM,CAAEpB,KAAK,CAAE6D,cAAc,CAAC,CAChF,GAAM,CAAAC,WAA0B,CAAG5C,IAAI,CAACK,GAAG,CAAe,SAACC,GAAG,QAAK,CAAAxB,KAAK,CAACgC,QAAQ,CAACR,GAAG,CAAC,EAAe,CAAC,CACtG,MAAO,CAAAsC,WAAW,CACtB,CAAC,GAAAnE,GAAA,0BAAAC,KAAA,CACD,SAAAmE,uBAAA,CAA6C,CACzC,MAAO,CAAA1E,SAAS,CAACuE,oBAAoB,CAAC,CAAC,CAAC,CAAC,CAAC,CAC9C,CAAC,GAAAjE,GAAA,eAAAC,KAAA,CACD,SAAAoE,YAAA,CAAiC,CAC7B,GAAM,CAAAhE,KAAuB,CAAGnB,KAAK,CAACoB,QAAQ,CAAC,CAAC,CAChD,GAAM,CAAAgE,QAA6C,CAAG9C,MAAM,CAACC,MAAM,CAAEpB,KAAK,CAAEkE,QAAQ,CAAC,CACrF,GAAM,CAAAC,SAAqB,CAAGF,QAAQ,CAAC1C,GAAG,CAAY,SAACC,GAAG,QAAK,CAAAxB,KAAK,CAACgC,QAAQ,CAACR,GAAG,CAAC,EAAY,CAAC,CAC/F,MAAO,CAAA2C,SAAS,CACpB,CAAC,GAAAxE,GAAA,YAAAC,KAAA,CACD,SAAAwE,SAAgBC,KAAa,CAAY,CACrC,GAAI,CAAArE,KAAuB,CAAGnB,KAAK,CAACoB,QAAQ,CAAC,CAAC,CAC9C,GAAM,CAAAgE,QAAwC,CAAG9C,MAAM,CAACC,MAAM,CAAEpB,KAAK,CAAEqE,KAAK,CAAC,CAAC,CAC9E,MAAO,CAAAJ,QAAQ,CACnB,CAAC,GAAAtE,GAAA,oBAAAC,KAAA,CAED,SAAA0E,iBAAA,CAAoC,CAChC,GAAM,CAAAtE,KAAa,CAAGnB,KAAK,CAACoB,QAAQ,CAAC,CAAC,CACtC,MAAO,CAAAkB,MAAM,CAACC,MAAM,CAAEpB,KAAK,CAAEuE,UAAU,CAAC,CAC5C,CAAC,GAAA5E,GAAA,sBAAAC,KAAA,CACD,SAAA4E,mBAAA,CAAsC,CAClC,GAAM,CAAAxE,KAAa,CAAGnB,KAAK,CAACoB,QAAQ,CAAC,CAAC,CACtC,MAAO,CAAAkB,MAAM,CAACC,MAAM,CAAEpB,KAAK,CAAEyE,YAAY,CAAC,CAC9C,CAAC,GAAA9E,GAAA,oBAAAC,KAAA,CACD,SAAA8E,iBAAA,CAAoC,CAChC,GAAM,CAAA1E,KAAa,CAAGnB,KAAK,CAACoB,QAAQ,CAAC,CAAC,CACtC,MAAO,CAAAkB,MAAM,CAACC,MAAM,CAAEpB,KAAK,CAAE2E,UAAU,CAAC,CAC5C,CACA;AAAA,GAAAhF,GAAA,iBAAAC,KAAA,CACA,SAAAgF,cAAA,CAAiC,CAC7B,GAAM,CAAA5E,KAAa,CAAGnB,KAAK,CAACoB,QAAQ,CAAC,CAAC,CACtC,MAAO,CAAAkB,MAAM,CAACC,MAAM,CAAEpB,KAAK,CAAE6E,MAAM,CAAC,CACxC,CAAC,GAAAlF,GAAA,kBAAAC,KAAA,CACD,SAAAkF,eAAA,CAAkC,CAC9B,GAAM,CAAA9E,KAAa,CAAGnB,KAAK,CAACoB,QAAQ,CAAC,CAAC,CACtC,MAAO,CAAAvB,kBAAkB,CAACqG,IAAI,CAAC5D,MAAM,CAACC,MAAM,CAAEpB,KAAK,CAAEgF,WAAW,CAAC,CAAC,CACtE,CAAC,GAAArF,GAAA,iCAAAC,KAAA,CAED,SAAAqF,8BAAA,CAAiD,CAC7C;AACA;AACA,GAAM,CAAAjF,KAAa,CAAGnB,KAAK,CAACoB,QAAQ,CAAC,CAAC,CACtC,GAAM,CAAAiF,SAAmB,CAAG/D,MAAM,CAACC,MAAM,CAAEpB,KAAK,CAAE6E,MAAM,CAAC,CACzDK,SAAS,CAACC,MAAM,CAAC,CAAC,CAAE9F,SAAS,CAACuE,oBAAoB,CAAC,CAAC,CAACwB,MAAM,CAAC,CAC5D;AACR;AACA;AACA,kCAEQ,MAAO,CAAAF,SAAS,CACpB,CAAC,GAAAvF,GAAA,qBAAAC,KAAA,CAED,SAAAyF,kBAAA,CAAiD,IAAxB,CAAAC,IAAI,CAAAC,SAAA,CAAAH,MAAA,IAAAG,SAAA,MAAAC,SAAA,CAAAD,SAAA,IAAG,KAAK,CACjC,GAAM,CAAAvF,KAAa,CAAGnB,KAAK,CAACoB,QAAQ,CAAC,CAAC,CACtC,MAAO,CAAAkB,MAAM,CAACC,MAAM,CAAEpB,KAAK,CAAEyF,WAAW,CAAC,CAC7C,CAAC,GAAA9F,GAAA,kBAAAC,KAAA,CACD,SAAA8F,eAAA,CAAkC,CAC9B,GAAM,CAAA1F,KAAa,CAAGnB,KAAK,CAACoB,QAAQ,CAAC,CAAC,CACtC,MAAO,CAAAkB,MAAM,CAACC,MAAM,CAAEpB,KAAK,CAAE2F,QAAQ,CAAC,CAC1C,CAAC,GAAAhG,GAAA,oBAAAC,KAAA,CAED,SAAAgG,iBAAA,CAAoC,CAChC,GAAM,CAAA5F,KAAa,CAAGnB,KAAK,CAACoB,QAAQ,CAAC,CAAC,CACtC,MAAO,CAAAkB,MAAM,CAACC,MAAM,CAAEpB,KAAK,CAAE6F,UAAU,CAAC,CAC5C,CAAC,GAAAlG,GAAA,oBAAAC,KAAA,CACD,SAAAkG,iBAAA,CAAoC,CAChC,GAAM,CAAA9F,KAAa,CAAGnB,KAAK,CAACoB,QAAQ,CAAC,CAAC,CACtC,MAAO,CAAAkB,MAAM,CAACC,MAAM,CAAEpB,KAAK,CAAE+F,UAAU,CAAC,CAC5C,CAAC,GAAApG,GAAA,eAAAC,KAAA,CAED,SAAAoG,YAA4CC,OAAe,CAAK,CAC5D,GAAM,CAAAjG,KAAuB,CAAGnB,KAAK,CAACoB,QAAQ,CAAC,CAAC,CAChD,GAAM,CAAAiG,QAAW,CAAGlG,KAAK,CAACgC,QAAQ,CAACiE,OAAO,CAAM,CAChD,MAAO,CAAAC,QAAQ,CACnB,CAAC,GAAAvG,GAAA,oBAAAC,KAAA,CAED,SAAAuG,iBAAA,CAAoC,CAChC,GAAM,CAAAnG,KAAa,CAAGnB,KAAK,CAACoB,QAAQ,CAAC,CAAC,CACtC,GAAM,CAAAmG,OAAO,CAAGjF,MAAM,CAACC,MAAM,CAAEpB,KAAK,CAAEqG,QAAQ,CAAC,CAC/C,MAAO,CAAA3H,kBAAkB,CAAC4B,WAAW,CAAC8F,OAAO,CAAC,CAClD,CAAC,GAAAzG,GAAA,gBAAAC,KAAA,CAED,SAAA0G,aAAA,CAAgC,CAC5B,GAAM,CAAAtG,KAAa,CAAGnB,KAAK,CAACoB,QAAQ,CAAC,CAAC,CACtC,GAAM,CAAAmG,OAAO,CAAGjF,MAAM,CAACC,MAAM,CAAEpB,KAAK,CAAEuG,QAAQ,CAAC,CAC/C,MAAO,CAAA7H,kBAAkB,CAAC4B,WAAW,CAAC8F,OAAO,CAAC,CAClD,CAEA;AAAA,GAAAzG,GAAA,aAAAC,KAAA,CAEA,SAAA4G,UAAsEC,IAAQ,CAAeC,eAAoB,CACI,CACjH,GAAM,CAAA1G,KAAa,CAAGnB,KAAK,CAACoB,QAAQ,CAAC,CAAC,CACtC,GAAI,CAAAiB,IAA4B,CAAG,EAAE,CAErCpC,CAAC,CAAC6H,WAAW,CAAC,KAAK,CAAEzF,IAAI,CACrB;AACAC,MAAM,CAACC,MAAM,CAACpB,KAAK,CAAC4G,WAAW,EAAI,CAAC,CAAC,CAAC,CACtCzF,MAAM,CAACC,MAAM,CAACpB,KAAK,CAAC6G,OAAO,EAAI,CAAC,CAAC,CAAC,CAClC1F,MAAM,CAACC,MAAM,CAACpB,KAAK,CAAC8G,YAAY,EAAI,CAAC,CAAC,CAAC,CACvC3F,MAAM,CAACC,MAAM,CAACpB,KAAK,CAAC+G,UAAU,EAAI,CAAC,CAAC,CAAC,CAAC,CAE1CC,OAAO,CAACC,GAAG,CAAC,sBAAsB,CAAE,CAAC/F,IAAI,CAAJA,IAAI,CAAEgG,CAAC,CAAE/F,MAAM,CAACC,MAAM,CAACpB,KAAK,CAACmH,MAAM,EAAI,CAAC,CAAC,CAAC,CAAEC,EAAE,CAACjG,MAAM,CAACC,MAAM,CAACpB,KAAK,CAAC4G,WAAW,EAAI,CAAC,CAAC,CAAC,CAAES,CAAC,CAAClG,MAAM,CAACC,MAAM,CAACpB,KAAK,CAAC6G,OAAO,EAAI,CAAC,CAAC,CAAC,CAAES,EAAE,CAACnG,MAAM,CAACC,MAAM,CAACpB,KAAK,CAAC8G,YAAY,EAAI,CAAC,CAAC,CAAC,CAAES,EAAE,CAACpG,MAAM,CAACC,MAAM,CAACpB,KAAK,CAAC+G,UAAU,EAAI,CAAC,CAAC,CAAC,CAAC,CAAC,CACxP,GAAIN,IAAI,GAAKjB,SAAS,EAAIiB,IAAI,GAAK,IAAI,CAAE,MAAO,CAAAvF,IAAI,CAACK,GAAG,CAAE,SAAAiG,CAAC,QAAI,CAAAnJ,kBAAkB,CAACoI,IAAI,CAACe,CAAC,CAAC,GAAC,CAC1F,GAAId,eAAe,GAAKlB,SAAS,EAAIkB,eAAe,GAAK,IAAI,CAAE,MAAO,CAAAxF,IAAI,CAACK,GAAG,CAAE,SAAAkG,CAAC,QAAI,CAAAzH,KAAK,CAACgC,QAAQ,CAACyF,CAAC,CAAC,GAAC,CACvG,MAAO,CAAAvG,IAAI,CACf,CAAC,GAAAvB,GAAA,UAAAC,KAAA,CAED,SAAA8H,OAEKC,MAAW,CAAEC,SAA8B,CAAE5H,KAAc,CAAE0G,eAAoB,CAAOD,IAAQ,CAAsB,CACvH,GAAI,CAACzG,KAAK,CAAEA,KAAK,CAAGnB,KAAK,CAACoB,QAAQ,CAAC,CAAC,CACpC,GAAI,CAAA4H,MAAM,CAAIF,MAAM,EAAgB,CAACG,IAAI,CAAC,UAAU,CAAEC,KAAK,CAAC,UAAU,CAAC,CACvE,GAAM,CAAAC,SAAiB,CAAG,CAAC,CAAAH,MAAM,SAANA,MAAM,iBAANA,MAAM,CAAEI,eAAe,GAAIJ,MAAM,CAACE,KAAK,EAAEG,WAAW,CAAC,CAAC,CACjF,GAAM,CAAAC,gBAAuC,CACtCnI,KAAK,CAAagI,SAAS,CAAC,EAC3BhI,KAAK,CAAagI,SAAS,CAACI,MAAM,CAAC,CAAC,CAAC,CAAC,EACtCpI,KAAK,CAAagI,SAAS,CAAG,GAAG,CAAC,EAClChI,KAAK,CAAagI,SAAS,CAACI,MAAM,CAAC,CAAC,CAAC,CAAG,GAAG,CAAC,CACpD3J,GAAG,CAAC4J,KAAK,CAAC,CAACF,gBAAgB,CAAE,wBAAwB,CAAE,CAACnI,KAAK,CAALA,KAAK,CAAEgI,SAAS,CAATA,SAAS,CAAEL,MAAM,CAANA,MAAM,CAAC,CAAC,CAClF,GAAI,CAAAW,eAA2B,CAAG,IAAI,CACtC,GAAI,CAAAC,eAA2B,CAAG,IAAI,CACtC,GAAI7B,eAAe,EAAID,IAAI,CAAE,CACzB6B,eAAe,CAAGH,gBAAgB,CAAC5G,GAAG,CAAE,SAACqB,CAAC,QAAM,CAAA5C,KAAK,CAAYgC,QAAQ,CAACY,CAAC,CAAC,EAAC,CAAQ,CACrF,GAAI6D,IAAI,CAAE,CACN8B,eAAe,CAAGD,eAAe,CAAC/G,GAAG,CAAE,SAAAqB,CAAC,QAAI,CAAAvE,kBAAkB,CAACoI,IAAI,CAAC7D,CAAC,CAAC,GAAe,CACzF,CACJ,CACA,GAAI,CAAAlC,GAAU,CAAIgG,eAAe,EAAID,IAAI,CAAIA,IAAI,CAAG8B,eAAe,CAAGD,eAAe,CAAIH,gBAAmC,CAC5H,GAAI,CAACK,KAAK,CAACC,OAAO,CAAC/H,GAAG,CAAC,CAAEA,GAAG,CAAGS,MAAM,CAACC,MAAM,CAACV,GAAG,CAAC,CAACgI,MAAM,CAAC,SAAA9F,CAAC,QAAI,CAAAA,CAAC,WAAY,CAAAzB,MAAM,GAAU,CAC3F,GAAIyG,SAAS,CAAE,MAAO,CAAAlH,GAAG,CAACgI,MAAM,CAAE,SAAA9F,CAAC,QAAI,CAAAgF,SAAS,CAAChF,CAAC,CAAC,GAAC,CACpD,MAAO,CAAAlC,GAAG,CACd,CAAC,GAAAf,GAAA,aAAAC,KAAA,CAED,SAAA+I,UAAiBf,SAAkC,CAAY,CAAE,MAAO,CAAAvI,SAAS,CAACqI,MAAM,CAACpJ,MAAM,CAAEkH,SAAS,CAAEA,SAAS,CAAE,IAAI,CAAE,KAAK,CAAC,CAAE,CAAC,GAAA7F,GAAA,YAAAC,KAAA,CAEtI,SAAAgJ,SAAgBd,IAAY,CAAiF,IAA/E,CAAAe,aAAsB,CAAAtD,SAAA,CAAAH,MAAA,IAAAG,SAAA,MAAAC,SAAA,CAAAD,SAAA,IAAG,KAAK,IAAE,CAAAkB,IAAa,CAAAlB,SAAA,CAAAH,MAAA,IAAAG,SAAA,MAAAC,SAAA,CAAAD,SAAA,IAAG,KAAK,CAC/E,GAAI,CAACsD,aAAa,CAAEf,IAAI,CAAGA,IAAI,CAACI,WAAW,CAAC,CAAC,CAC7C,GAAI,CAAAxH,GAAG,CAAGrB,SAAS,CAACqI,MAAM,CAAiBpJ,MAAM,CAAE,SAACwK,CAAC,QAAK,CAACD,aAAa,CAAGC,CAAC,CAAChB,IAAI,CAAGgB,CAAC,CAAChB,IAAI,CAACI,WAAW,CAAC,CAAC,IAAMJ,IAAI,GAAEtC,SAAS,CAAE,IAAI,CAAEiB,IAAW,CAAC,CAAC,CAAC,CAAC,CACpJ,MAAO,CAAA/F,GAAG,CACd,CAAC,GAAAf,GAAA,aAAAC,KAAA,CAED,SAAAmJ,UAAiBC,MAAiC,CAAElB,IAAY,CAAyG,IAAvG,CAAAe,aAAsB,CAAAtD,SAAA,CAAAH,MAAA,IAAAG,SAAA,MAAAC,SAAA,CAAAD,SAAA,IAAG,KAAK,IAAE,CAAAkB,IAAa,CAAAlB,SAAA,CAAAH,MAAA,IAAAG,SAAA,MAAAC,SAAA,CAAAD,SAAA,IAAG,KAAK,CACnH,MAAO,CAAAlG,SAAS,CAAC4J,UAAU,CAACD,MAAM,CAAE,MAAM,CAAElB,IAAI,CAAEe,aAAa,CAAEpC,IAAI,CAAC,CAAE,CAAC,GAAA9G,GAAA,cAAAC,KAAA,CAE7E,SAAAqJ,WAAkBD,MAAiC,CAAE3E,KAAa,CAAEzE,KAAa,CAAyG,IAAvG,CAAAiJ,aAAsB,CAAAtD,SAAA,CAAAH,MAAA,IAAAG,SAAA,MAAAC,SAAA,CAAAD,SAAA,IAAG,KAAK,IAAE,CAAAkB,IAAa,CAAAlB,SAAA,CAAAH,MAAA,IAAAG,SAAA,MAAAC,SAAA,CAAAD,SAAA,IAAG,KAAK,CACpI,GAAI,CAACsD,aAAa,CAAEjJ,KAAK,CAAGA,KAAK,CAACsI,WAAW,CAAC,CAAC,CAC/C,GAAI,CAAAN,SAAS,CAAG,QAAZ,CAAAA,SAASA,CAAIkB,CAAM,CAAK,KAAAI,QAAA,CACxB,GAAI,CAAAxI,GAAG,CAAG,CAACmI,aAAa,CAAGC,CAAC,CAACzE,KAAK,CAAC,EAAA6E,QAAA,CAAGJ,CAAC,CAACzE,KAAK,CAAC,UAAA6E,QAAA,iBAARA,QAAA,CAAUhB,WAAW,CAAC,CAAC,IAAMtI,KAAK,CACxEoH,OAAO,CAACC,GAAG,CAAC,4BAA4B,CAAE,CAAC6B,CAAC,CAADA,CAAC,CAAEK,MAAM,CAACL,CAAC,CAACzE,KAAK,CAAC,CAAEzE,KAAK,CAALA,KAAK,CAAEc,GAAG,CAAHA,GAAG,CAAC,CAAC,CAC3E,MAAO,CAAAA,GAAG,CACd,CAAC,CACD,GAAI,CAAAA,GAAG,CAAGrB,SAAS,CAACqI,MAAM,CAACsB,MAAM,CAAEpB,SAAS,CAAEpC,SAAS,CAAE,IAAI,CAAEiB,IAAW,CAAC,CAAC,CAAC,CAAC,CAC9E,MAAO,CAAA/F,GAAG,CAAE,CAAC,GAAAf,GAAA,cAAAC,KAAA,CAEjB,SAAAwJ,WAAkBxB,SAAkC,CAA2B,CAAE,MAAO,CAAAvI,SAAS,CAACqI,MAAM,CAACtJ,YAAY,CAAC,CAAE,CAAC,GAAAuB,GAAA,WAAAC,KAAA,CAIzH,SAAAyJ,QAAuB9I,KAAa,CAAE+I,KAAa,CAAwB,CACvE,GAAI,CACA,MAAO,CAAAC,IAAI,CAACD,KAAK,CAAC,CACtB,CAAE,MAAO1G,CAAC,CAAE,CAAE,MAAO,EAAE,CAAE,CAC7B,CACA;AACJ;AACA;AACA,OAHI,GAAAjD,GAAA,0BAAAC,KAAA,CAKA,SAAA4J,uBAAsCnC,CAAe,CAAEoC,IAAgD,CAAU,CAC7G,GAAI,CAACpC,CAAC,CAAE,MAAO,CAAAnI,eAAe,CAACwK,sBAAsB,CACrD,GAAI,CAACrC,CAAC,CAACsC,kBAAkB,EAAI,CAACtC,CAAC,CAACsC,kBAAkB,CAACvE,MAAM,CAAE,MAAO,CAAAlG,eAAe,CAAC0K,cAAc,CAChG,GAAI,CAACH,IAAI,CAAE,MAAO,CAAAvK,eAAe,CAACwK,sBAAsB,CACxD,GAAI,CAAAG,SAAoC,CAAGjL,sBAAsB,CAACkL,GAAG,CAACL,IAAI,CAACzB,SAAS,CAAC,CACrFvJ,GAAG,CAAC4J,KAAK,CAAC,CAACwB,SAAS,CAAE,4BAA4B,CAAE,CAACxC,CAAC,CAADA,CAAC,CAAEoC,IAAI,CAAJA,IAAI,CAAC,CAAC,CAAE;AAChE,GAAI,CAAAM,gBAAyB,CAAG,KAAK,CAAC,IAAAC,UAAA,CAAA7H,0BAAA,CACdkF,CAAC,CAACsC,kBAAkB,EAAAM,MAAA,KAA5C,IAAAD,UAAA,CAAA3H,CAAA,KAAA4H,MAAA,CAAAD,UAAA,CAAA1H,CAAA,IAAAC,IAAA,EAA8C,IAArC,CAAA2H,WAAW,CAAAD,MAAA,CAAArK,KAAA,CAChB,GAAM,CAAAuK,WAAsC,CAAGvL,sBAAsB,CAACkL,GAAG,CAACI,WAAW,CAAC,CACtF,GAAIL,SAAS,GAAKM,WAAW,CAAE,MAAO,CAAAjL,eAAe,CAACkL,WAAW,CAAE;AACnE,GAAI,CAACL,gBAAgB,EAAIjL,CAAC,CAACuL,gBAAgB,CAACR,SAAS,CAAEM,WAAW,CAAC,CAAEJ,gBAAgB,CAAG,IAAI,CAAE;AAC9F,GAAIA,gBAAgB,CAAE,MAAO,CAAA7K,eAAe,CAACoL,iBAAiB,CAClE,CAAC,OAAA3H,GAAA,EAAAqH,UAAA,CAAApH,CAAA,CAAAD,GAAA,WAAAqH,UAAA,CAAAnH,CAAA,IACD,MAAO,CAAA3D,eAAe,CAACwK,sBAAsB,CACpD,CAAC,GAAA/J,GAAA,gBAAAC,KAAA,CAEE,SAAA2K,aAA4Bd,IAAwB,CAAEe,WAA+C,CAA4C,IAA1C,CAAAC,cAAuB,CAAAlF,SAAA,CAAAH,MAAA,IAAAG,SAAA,MAAAC,SAAA,CAAAD,SAAA,IAAG,KAAK,CAClI,GAAI,CAAAsE,SAAoC,CAAGjL,sBAAsB,CAACkL,GAAG,CAACL,IAAI,CAACzB,SAAS,CAAC,CACrFvJ,GAAG,CAAC4J,KAAK,CAAC,CAACwB,SAAS,CAAE,2CAA2C,CAAE,CAACJ,IAAI,CAAJA,IAAI,CAAC,CAAC,CAC1E,GAAM,CAAAU,WAAsC,CAAG,MAAO,CAAAK,WAAW,GAAK,QAAQ,CAAE5L,sBAAsB,CAACkL,GAAG,CAACU,WAAW,CAAC,CAAGA,WAAW,CACrI,GAAIX,SAAS,GAAKM,WAAW,CAAE,MAAO,CAAAM,cAAc,CACpD,MAAO,CAAA3L,CAAC,CAACuL,gBAAgB,CAACR,SAAS,CAAEM,WAAW,CAAC,CACrD,CAAC,GAAAxK,GAAA,sBAAAC,KAAA,CAGD,SAAA8K,mBAA0B5C,IAA0C,CAAE9H,KAAc,CAA4B,KAAA2K,oBAAA,CAAAC,kBAAA,CAC5G,GAAI,CAAC5K,KAAK,CAAEA,KAAK,CAAGnB,KAAK,CAACoB,QAAQ,CAAC,CAAC,CACpC,GAAI,MAAO,CAAA6H,IAAI,GAAK,QAAQ,CAAE,CAAE,MAAQ,CAAAA,IAAI,CAAS+C,KAAK,EAAI/C,IAAW,CAAE,CAC3E,GAAI,EAAA6C,oBAAA,CAAA3K,KAAK,CAACgC,QAAQ,CAAC8F,IAAI,CAAC,UAAA6C,oBAAA,iBAApBA,oBAAA,CAAsB3C,SAAS,IAAK5J,YAAY,CAAC2J,KAAK,CAAE,MAAO,CAAA/H,KAAK,CAACgC,QAAQ,CAAC8F,IAAI,CAAC,CACvF,GAAI,CAAApF,EAAE,CAAGrD,SAAS,CAACyL,iBAAiB,CAAChD,IAAI,CAAE9H,KAAK,CAAC,CACjD,GAAI0C,EAAE,EAAI,EAAAkI,kBAAA,CAAA5K,KAAK,CAACgC,QAAQ,CAACU,EAAE,CAAC,UAAAkI,kBAAA,iBAAlBA,kBAAA,CAAoB5C,SAAS,IAAK5J,YAAY,CAAC2J,KAAK,CAAE,MAAO,CAAA/H,KAAK,CAACgC,QAAQ,CAACU,EAAE,CAAC,CACzF,MAAO,CAAA8C,SAAS,CACpB,CAGA;AACA;AACA;AACA;AAAA,GAAA7F,GAAA,qBAAAC,KAAA,CACA,SAAAkL,kBAAyBC,QAAgB,CAAE/K,KAAc,CAAqC,CAC1F,GAAI,CAACA,KAAK,CAAEA,KAAK,CAAGnB,KAAK,CAACoB,QAAQ,CAAC,CAAC,CACpC,GAAI,CAAA+K,KAAe,CAAGD,QAAQ,CAACE,KAAK,CAAC,GAAG,CAAC,CACzC,GAAI,CAAAC,kBAA2C,CAAGlL,KAAK,CAACqB,YAAY,CAAC,IAAA8J,KAAA,UAAAA,MAC5DC,CAAC,EACN,GAAI,CAAAtD,IAAI,CAAGkD,KAAK,CAACI,CAAC,CAAC,CACnBF,kBAAkB,CAAGA,kBAAkB,CAACxC,MAAM,CAAC,SAAArB,CAAC,QAAM,CAAArH,KAAK,CAAYgC,QAAQ,CAACqF,CAAC,CAAC,CAAkBS,IAAI,GAAKA,IAAI,GAAC,CAClH,GAAIsD,CAAC,GAAKJ,KAAK,CAAC5F,MAAM,CAAC,CAAC,EAAI8F,kBAAkB,CAAC9F,MAAM,GAAK,CAAC,CAAE,OAAAiC,CAAA,CAAO6D,kBAAkB,CAAC,CAAC,CAAC,EACzFA,kBAAkB,CAAGA,kBAAkB,CAACG,OAAO,CAAC,SAAAhE,CAAC,QAAI,CAAAlG,MAAM,CAACmK,IAAI,CAAGtL,KAAK,CAAYgC,QAAQ,CAACqF,CAAC,CAAC,CAAkBkE,QAAQ,CAAC,GAAC,CAAC,EAJhI,IAAK,GAAI,CAAAH,CAAC,CAAG,CAAC,CAAEA,CAAC,CAAGJ,KAAK,CAAC5F,MAAM,CAAEgG,CAAC,EAAE,CAAE,KAAAI,IAAA,CAAAL,KAAA,CAA9BC,CAAC,YAAAI,IAAA,mBAAAA,IAAA,CAAAnE,CAAA,CAKV,CACA,MAAO,CAAA7B,SAAS,CACpB,CAGA;AAAA,GAAA7F,GAAA,8BAAAC,KAAA,CACqE;AAGrE,SAAA6L,2BAAA,CAA8D,CAC1D;AACA,GAAI,CAAAzL,KAAa,CAAGnB,KAAK,CAACoB,QAAQ,CAAC,CAAC,CACpC,SAAAyL,MAAA,CAAAC,kBAAA,CAAW3L,KAAK,CAACmH,MAAM,EAAAwE,kBAAA,CAAK3L,KAAK,CAAC8G,YAAY,EAAA6E,kBAAA,CAAK3L,KAAK,CAAC4L,aAAa,EAAAD,kBAAA,CAAK3L,KAAK,CAAC6G,OAAO,EAAA8E,kBAAA,CAAK3L,KAAK,CAAC+G,UAAU,EAAA4E,kBAAA,CAAK3L,KAAK,CAAC6L,KAAK,GACjI,CAAC,GAAAlM,GAAA,iBAAAC,KAAA,CAED,SAAAkM,cAA6BC,KAAgB,CAAEC,GAA0B,CAAEC,UAAoC,CAAEC,KAAmB,CAAU,CAC1I,GAAIH,KAAK,CAACI,cAAc,GAAKjN,eAAe,CAACwK,sBAAsB,CAAE,MAAO,CAAAxK,eAAe,CAACkN,QAAQ,CACpG,GAAIL,KAAK,CAACM,cAAc,GAAKnN,eAAe,CAACoN,WAAW,CAAE,MAAO,CAAApN,eAAe,CAACkN,QAAQ,CACzF,GAAIL,KAAK,CAACQ,OAAO,GAAKrN,eAAe,CAACsN,WAAW,EAAIT,KAAK,CAACU,QAAQ,GAAKvN,eAAe,CAACsN,WAAW,CAAE,MAAO,CAAAtN,eAAe,CAACkN,QAAQ,CACpI,GAAI,CAAAM,OAAgB,CAAGT,UAAU,CAAGD,GAAG,GAAI,CAAAC,UAAU,CAACV,QAAQ,CAAG,KAAK,CACtE,GAAI,CAAAoB,OAAe,CAAGD,OAAO,CAAIT,UAAU,CAAkBV,QAAQ,CAACS,GAAG,CAAC,CAAG,CAAC,CAC9E,GAAI,CAAAY,YAAoB,CACxB,GAAI,MAAO,CAAAb,KAAK,CAACQ,OAAO,GAAK,QAAQ,CAAE,CACnCK,YAAY,CAAGb,KAAK,CAACQ,OAAO,CAChC,CAAC,IAAM,IAAIL,KAAK,CAACW,2BAA2B,GAAKrH,SAAS,CAAE,KAAAsH,kBAAA,CAAAC,mBAAA,CACxD;AACAH,YAAY,CAAG,CAAC,EAAAE,kBAAA,CAAAZ,KAAK,CAACc,WAAW,UAAAF,kBAAA,iBAAjBA,kBAAA,CAAmB1H,MAAM,GAAI,CAAC,GAAK,EAAA2H,mBAAA,CAAAb,KAAK,CAACe,YAAY,UAAAF,mBAAA,iBAAlBA,mBAAA,CAAoB3H,MAAM,GAAI,CAAC,CAAC,CACvF,CAAC,IAAM,CAAAwH,YAAY,CAAGV,KAAK,CAACW,2BAA2B,CAEvD,MAAO,CAAAd,KAAK,CAACM,cAAc,CAAGN,KAAK,CAACI,cAAc,CAAGQ,OAAO,CAAGC,YAAY,CAC3E;AACA;AACJ,CAMJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OA/CA,GAAAjN,GAAA,gBAAAC,KAAA,CAoDI,SAAAsN,aAAoBC,KAAgC,CAAEC,IAA+B,CAAEC,GAA2B,CAAEC,EAA4B,CAAC,CAC7I,GAAI,CAAAC,WAAoB,CAAG,KAAK,CAChC,GAAI,CAAAC,sBAA+B,CAAG,KAAK,CAC3C,GAAI,CAAAC,0BAAmC,CAAG,KAAK,CAC/C,GAAI,CAAAC,EAAE,CAAGzO,mBAAmB,CAACmO,IAAI,CAACC,GAAG,CAAC,CACtC,GAAI,CAACK,EAAE,CAAE,CAAEzO,mBAAmB,CAACmO,IAAI,CAACC,GAAG,CAAC,CAAGK,EAAE,CAAG,GAAI,CAAA1O,uBAAuB,CAAC,CAAC,CAAEwO,sBAAsB,CAAG,IAAI,CAAE,CAC9G,GAAI,CAAAG,OAAO,CAAGD,EAAE,CAACE,oBAAqC,CACtD;AACA,GAAM,CAAAnE,IAAmB,CAAG0D,KAAsB,CAClD;AACA,GAAM,CAAAU,IAAuC,CAAGP,EAAE,SAAFA,EAAE,iBAAFA,EAAE,CAAE5K,EAAE,CACtD,GAAM,CAAAoL,KAA+B,CAAGJ,EAAE,CAACK,oBAAoB,CAC/D,GAAI,CAAAC,WAAoB,CAAI,CAAC,CAACvE,IAAI,GAAK,CAAC,CAACkE,OAAO,EAAK,CAAC,EAAElE,IAAI,EAAIkE,OAAO,CAAC,EAAKlE,IAAI,CAACwE,aAAa,GAAKN,OAAO,CAACM,aAAc,CAC1H;AACA,GAAI,CAAAC,iBAA0B,CAAIL,IAAI,IAAKC,KAAK,SAALA,KAAK,iBAALA,KAAK,CAAEpL,EAAE,GAAK,CAAC,EAAE4K,EAAE,EAAIQ,KAAK,CAAC,EAAIA,KAAK,CAACvC,QAAQ,GAAK+B,EAAE,CAAC/B,QAAU,CAAE;AAC9G,GAAI2C,iBAAiB,CAAER,EAAE,CAACK,oBAAoB,CAAGT,EAAE,CACnD;AACA,GAAIU,WAAW,CAAEN,EAAE,CAACE,oBAAoB,CAAGnE,IAAI,CAE/C;AACA;AACA;AACA;AACA;AAEA;AAEA,GAAI,CAAAzJ,KAAa,CAAGnB,KAAK,CAACoB,QAAQ,CAAC,CAAC,CACpC,GAAM,CAAAkO,QAAwB,CAAG9O,SAAS,CAAC2B,kBAAkB,CAAChB,KAAK,CAAC,CAEpE,GAAM,CAAAoO,IAAI,CAAGlQ,KAAK,CAACoC,WAAW,CAACnC,KAAK,CAACkQ,OAAO,CAAC,CAC7C,GAAM,CAAAC,OAAO,CAAGF,IAAI,CAACE,OAAmB,CACxC,GAAI,CAAAC,UAAiC,CAAGD,OAAO,CAACE,eAAe,CAAC9L,EAAE,CAClE;AAAA,IAAA+L,UAAA,CAAAtM,0BAAA,CACoBgM,QAAQ,EAAAO,MAAA,KAA5B,IAAAD,UAAA,CAAApM,CAAA,KAAAqM,MAAA,CAAAD,UAAA,CAAAnM,CAAA,IAAAC,IAAA,EAA8B,IAAnB,CAAA2J,KAAK,CAAAwC,MAAA,CAAA9O,KAAA,CACZ,GAAI,CAAAoM,GAAG,CAAGE,KAAK,CAACxJ,EAAE,CAClB,GAAI,CAAAiM,EAAE,CAAG1P,mBAAmB,CAAC2P,IAAI,CAAC5C,GAAG,CAAC,CACtC,GAAI,CAAC2C,EAAE,CAAE1P,mBAAmB,CAAC2P,IAAI,CAAC5C,GAAG,CAAC,CAAG2C,EAAE,CAAG,CAAC,CAAQ,CACvD,GAAI,CAAAE,GAAG,CAAGnB,EAAE,CAACoB,UAAU,CAAC9C,GAAG,CAAC,CAC5B;AACA;AAEA,GAAI,CAAC6C,GAAG,CAAE,CACN5P,mBAAmB,CAACmO,IAAI,CAACC,GAAG,CAAC,CAACyB,UAAU,CAAC9C,GAAG,CAAC,CAAG6C,GAAG,CAAG,CAAC,CAAQ,CAC/D;AAChB;AACA;AACA;AACA;AACA,2BACgBpB,0BAA0B,CAAG,IAAI,CACrC,CAAC,IAAM,CAAAA,0BAA0B,CAAGoB,GAAG,CAAC1C,cAAc,GAAKjN,eAAe,CAAC6P,iBAAiB,CAAE;AAE9F;AACA,GAAI,CAAAC,GAAe,CAAG3Q,kBAAkB,CAACiC,WAAW,CAAC4L,KAAK,CAACtK,SAAS,CAAE5B,KAAK,CAAC,CAC5E,GAAI,CAAAiP,UAAkB,CAAGJ,GAAG,CAACxC,cAAc,CAC3C;AACA,GAAI2C,GAAG,CAACtM,EAAE,GAAK6L,UAAU,CAAEM,GAAG,CAACxC,cAAc,CAAGnN,eAAe,CAACgQ,WAAW,CAAC,IACvE,IAAIF,GAAG,CAACtM,EAAE,GAAK,0BAA0B,CAAEmM,GAAG,CAACxC,cAAc,CAAGnN,eAAe,CAACiQ,UAAU,CAAC,IAC3F,IAAI,CAACH,GAAG,CAACI,eAAe,CAAEP,GAAG,CAACxC,cAAc,CAAGnN,eAAe,CAACmQ,aAAa,CAAC,IAC7E,CAAAR,GAAG,CAACxC,cAAc,CAAGnN,eAAe,CAACoN,WAAW,CAErD,GAAI,CAACiB,WAAW,EAAK0B,UAAU,GAAKJ,GAAG,CAACxC,cAAe,CAAEkB,WAAW,CAAG,IAAI,CAC3E,GAAIsB,GAAG,CAACxC,cAAc,GAAKnN,eAAe,CAACoN,WAAW,CAAE,CACpDuC,GAAG,CAACS,UAAU,CAAGpQ,eAAe,CAACoN,WAAW,CAC5C,SACJ,CAGA;AACA,GAAImB,0BAA0B,CAAE,CAC5B,GAAM,CAAA8B,QAAQ,CAAGV,GAAG,CAAC1C,cAAc,CACnC0C,GAAG,CAAC1C,cAAc,CAAG,IAAI,CAAC3C,sBAAsB,CAAC0C,KAAK,CAAEzC,IAAI,SAAJA,IAAI,iBAAJA,IAAI,CAAEoB,KAAK,CAAC,CACpE0C,WAAW,CAAG,IAAI,CAAE;AACpB;AACA,GAAIsB,GAAG,CAAC1C,cAAc,GAAKjN,eAAe,CAACwK,sBAAsB,CAAE,CAC/DmF,GAAG,CAACS,UAAU,CAAGpQ,eAAe,CAACkN,QAAQ,CACzC,SACJ,CACJ,CAAC,IAAM,IAAIyC,GAAG,CAAC1C,cAAc,GAAKjN,eAAe,CAACwK,sBAAsB,CAAE,SAE1E,GAAI,IAAI,CAAE,CACN;AACA;AACA,GAAI,CAAA8F,cAAuB,CAAGnQ,SAAS,CAACoQ,aAAa,CAACrC,IAAI,CAAE3D,IAAI,CAAEyC,KAAK,CAAEyC,EAAE,CAAEE,GAAG,CAAC,CACjF,GAAI,CAACtB,WAAW,EAAIiC,cAAc,CAAEjC,WAAW,CAAG,IAAI,CACtD;AACA,GAAIsB,GAAG,CAACtC,OAAO,GAAKrN,eAAe,CAACsN,WAAW,CAAE,CAAEqC,GAAG,CAACS,UAAU,CAAGpQ,eAAe,CAACkN,QAAQ,CAAE,SAAU,CAC5G,CAEA;AACA;AAEA,GAAI4B,WAAW,EAAIa,GAAG,CAACpC,QAAQ,GAAKvN,eAAe,CAAC6P,iBAAiB,CAAE,CACnE;AACA;AACA,GAAI,CAAAQ,SAAQ,CAAGV,GAAG,CAACpC,QAAQ,CAC3BoC,GAAG,CAACpC,QAAQ,CAAGjO,GAAG,CAACkR,IAAI,CAACjG,IAAI,CAAEyC,KAAK,CAAEkB,IAAI,CAAC;AAC1CuB,EAAE,CAACgB,UAAU,CAAG,KAAK,CACrB,GAAI,CAACpC,WAAW,EAAIsB,GAAG,CAACpC,QAAQ,GAAK8C,SAAQ,CAAEhC,WAAW,CAAG,IAAI,CACjE,GAAIsB,GAAG,CAACpC,QAAQ,GAAKvN,eAAe,CAAC0Q,YAAY,CAAE,CAAEf,GAAG,CAACS,UAAU,CAAGpQ,eAAe,CAACkN,QAAQ,CAAE,SAAU,CAC9G,CACJ,CAAC,OAAAzJ,GAAA,EAAA8L,UAAA,CAAA7L,CAAA,CAAAD,GAAA,WAAA8L,UAAA,CAAA5L,CAAA,IAED,GAAIqL,iBAAiB,CAAEX,WAAW,CAAG,IAAI,CAAE;AAC3C,MAAO,CAAAA,WAAW,CACtB,CAEA;AAAA,GAAA5N,GAAA,sBAAAC,KAAA,CACA,SAAAiQ,mBAAAC,IAAA,CAA+M,IAA/K,CAAA3C,KAAK,CAAA2C,IAAA,CAAVrG,IAAI,CAAQ2D,IAAI,CAAA0C,IAAA,CAAJ1C,IAAI,CAAEE,EAAE,CAAAwC,IAAA,CAAFxC,EAAE,CAAED,GAAG,CAAAyC,IAAA,CAAHzC,GAAG,CAChD;AACA,GAAI,CAAAE,WAAoB,CAAGlO,SAAS,CAAC6N,YAAY,CAACC,KAAK,CAAEC,IAAI,CAAEC,GAAG,CAAEC,EAAE,CAAC,CAEvE,GAAI,CAAAI,EAA2B,CAAGzO,mBAAmB,CAACmO,IAAI,CAACC,GAAG,CAAC,CAAE;AAEjE,GAAIE,WAAW,EAAI,CAACG,EAAE,CAACqC,UAAU,CAAE,KAAAC,WAAA,CAC/B,GAAI,CAAAC,SAA2B,CAAG,EAAE,CACpC,GAAI,CAAAC,eAAiC,CAAG,EAAE,CAC1C,GAAI,CAAAlQ,KAAK,CAAGnB,KAAK,CAACoB,QAAQ,CAAC,CAAC,CAC5B,QAAAkQ,EAAA,GAAAC,YAAA,CAAgBjP,MAAM,CAACmK,IAAI,CAACoC,EAAE,CAACoB,UAAU,CAAC,CAAAqB,EAAA,CAAAC,YAAA,CAAAhL,MAAA,CAAA+K,EAAA,GAAE,CAAvC,GAAI,CAAAnE,GAAG,CAAAoE,YAAA,CAAAD,EAAA,EACR,GAAI,CAAAtB,GAAG,CAAGnB,EAAE,CAACoB,UAAU,CAAC9C,GAAG,CAAC,CAC5B,GAAM,CAAAE,KAAmB,CAAG7N,kBAAkB,CAACiC,WAAW,CAAC0L,GAAG,CAAEhM,KAAK,CAAC,CACtE,GAAM,CAAAqQ,MAAK,CAAGxB,GAAG,CAACS,UAAU,CAAGjQ,SAAS,CAACyM,aAAa,CAAC+C,GAAG,CAAE7C,GAAG,CAAEsB,EAAE,CAAEpB,KAAK,CAAC,CAC3E,GAAI,EAAEmE,MAAK,CAAG,CAAC,CAAC,CAAE,SAAU;AAC5B,CAACnE,KAAK,CAACkD,eAAe,CAAGa,SAAS,CAAGC,eAAe,EAAEzN,IAAI,CAAE,CAAC9B,OAAO,CAACqL,GAAG,CAAEqE,KAAK,CAALA,MAAK,CAAEzB,IAAI,CAAElQ,kBAAkB,CAAC4R,KAAK,CAACpE,KAAK,CAAC,CAAE,CAAC,CAC7H,CACAgE,eAAe,CAACK,IAAI,CAAC,SAACC,EAAE,CAAEC,EAAE,QAAI,CAAAA,EAAE,CAACJ,KAAK,CAAGG,EAAE,CAACH,KAAK,GAAC,CAAE;AACtDJ,SAAS,CAACM,IAAI,CAAC,SAACC,EAAE,CAAEC,EAAE,QAAI,CAAAA,EAAE,CAACJ,KAAK,CAAGG,EAAE,CAACH,KAAK,GAAC,CAAE;AAEhD;AACA3C,EAAE,CAACgD,QAAQ,EAAAV,WAAA,CAAGC,SAAS,CAAC,CAAC,CAAC,UAAAD,WAAA,iBAAZA,WAAA,CAAcpB,IAAI,CAChClB,EAAE,CAACiD,cAAc,CAAGV,SAAS,CAAC1O,GAAG,CAAC,SAACc,CAAC,QAAI,CAAAA,CAAC,CAACuM,IAAI,GAAC,CAC/ClB,EAAE,CAACqC,UAAU,CAAGG,eAAe,CAAC3O,GAAG,CAAC,SAACc,CAAC,QAAI,CAAAA,CAAC,CAACuM,IAAI,GAAC,CACrD,CACA;AACA;AAEA;AACA;AAEA;AACA,MAAO,CAAAlB,EAAE,CAEb,CAAC,GAAA/N,GAAA,YAAAC,KAAA,CAED,SAAAgR,SAAgB5Q,KAAc,CAAmB,CAC7C,GAAI,CAACA,KAAK,CAAEA,KAAK,CAAGnB,KAAK,CAACoB,QAAQ,CAAC,CAAC,CACpC,GAAI,CAAA4Q,IAA0B,CAAG1P,MAAM,CAACC,MAAM,CAACpB,KAAK,CAACgC,QAAQ,CAAC,CAC9D,MAAO,CAAA6O,IAAI,CAACnI,MAAM,CAAE,SAACI,CAAqB,QAAK,CAAAhK,CAAC,CAACgS,QAAQ,CAAChI,CAAC,CAAC,EAAIzJ,SAAS,CAACkL,YAAY,CAACzB,CAAC,CAAEvK,aAAa,CAAC,GAAC,CAAqB,CAAC,GAAAoB,GAAA,YAAAC,KAAA,CAEnI,SAAAmR,SAA8C7P,IAAkB,CAAElB,KAAc,CAAM,CAClF,GAAI,CAACA,KAAK,CAAEA,KAAK,CAAGnB,KAAK,CAACoB,QAAQ,CAAC,CAAC,CACpC,MAAO,CAAAiB,IAAI,CAACK,GAAG,CAAC,SAAAiG,CAAC,QAAK,CAAAxH,KAAK,CAAYgC,QAAQ,CAACwF,CAAC,CAAC,GAAC,CAAS,CAAC,GAAA7H,GAAA,QAAAC,KAAA,CAEjE,SAAA6G,KAAwEuK,GAAgC,CAAEhR,KAAc,CAAO,CAC3H,GAAI,CAACgR,GAAG,CAAC5L,MAAM,CAAE,MAAO,EAAE,CAC1B,GAAI,CAACpF,KAAK,CAAEA,KAAK,CAAGnB,KAAK,CAACoB,QAAQ,CAAC,CAAC,CACpC,GAAI,CAAAgR,MAAW,CACf,GAAI,MAAO,CAAAD,GAAG,CAAC,CAAC,CAAC,GAAK,QAAQ,CAAE,CAAEC,MAAM,CAAG5R,SAAS,CAAC0R,QAAQ,CAACC,GAAG,CAAchR,KAAK,CAAC,CAAE,CAAC,IACnF,CAAAiR,MAAM,CAAGD,GAAU,CACxB,MAAO,CAAAC,MAAM,CAAC1P,GAAG,CAAC,SAAAiG,CAAC,QAAI,CAAA5I,sBAAsB,CAAC6H,IAAI,CAACe,CAAC,CAAC,GAAC,CAAS,CAAC,GAAA7H,GAAA,UAAAC,KAAA,CAEpE,SAAAsR,OAA0EF,GAAO,CAAO,CAAE,MAAO,CAAAA,GAAG,CAACzP,GAAG,CAAE,SAAC4P,CAAC,QAAI,CAAAA,CAAC,CAACtG,KAAK,GAAC,CAAW,CAAC,GAAAlL,GAAA,sBAAAC,KAAA,CACpI,SAAAwR,mBAA0BC,QAA+B,CAAoH,IAAlH,CAAAC,UAAmB,CAAA/L,SAAA,CAAAH,MAAA,IAAAG,SAAA,MAAAC,SAAA,CAAAD,SAAA,IAAG,KAAK,IAAE,CAAAkB,IAAa,CAAAlB,SAAA,CAAAH,MAAA,IAAAG,SAAA,MAAAC,SAAA,CAAAD,SAAA,IAAG,KAAK,CACzG,GAAM,CAAAvF,KAAc,CAAGnB,KAAK,CAACoB,QAAQ,CAAC,CAAC,CACvC,GAAM,CAAAiH,CAAS,CAAGlH,KAAK,CAACgC,QAAQ,CAACqP,QAAQ,CAAW,CACpD,GAAIC,UAAU,CAAE,MAAO,CAAApK,CAAC,CAACqK,WAAW,CACpC,GAAM,CAAAC,WAA4B,CAAGtK,CAAC,CAACqK,WAAW,CAAChQ,GAAG,CAAE,SAAAkQ,IAAI,QAAI,CAAAzR,KAAK,CAACgC,QAAQ,CAACyP,IAAI,CAAC,GAAoB,CACxG,GAAIhL,IAAI,CAAE,MAAO,CAAA+K,WAAW,CAACjQ,GAAG,CAAiB,SAACmQ,EAAE,QAAK,CAAAhT,kBAAkB,CAACqG,IAAI,CAAC2M,EAAE,CAAC,GAAC,CACrF,MAAO,CAAAF,WAAW,CAAE,CAKxB;AAAA,GAAA7R,GAAA,wBAAAC,KAAA,CAIA,SAAA+R,qBAAmCjP,EAAU,CAAY,CACrD,GAAM,CAAA+G,IAAI,CAAG/K,kBAAkB,CAACqG,IAAI,CAACrC,EAAE,CAAY,CACnD,GAAI,CAAAkP,QAA+B,CACnC,GAAM,CAAAC,OAAiB,CAAG,EAAE,CAC5B,GAAIpI,IAAI,CAACzB,SAAS,GAAK,YAAY,CAAE,CACjC,GAAM,CAAA8J,MAAc,CAAGpT,kBAAkB,CAACqG,IAAI,CAAC0E,IAAI,CAACsI,MAAM,CAAC,CAC3DH,QAAQ,CAAGlT,kBAAkB,CAACqG,IAAI,CAAC+M,MAAM,CAACC,MAAM,CAAC,CACrD,CACA,GAAItI,IAAI,CAACzB,SAAS,GAAK,YAAY,CAAE,CACjC,GAAM,CAAAgK,UAAsB,CAAGtT,kBAAkB,CAACqG,IAAI,CAAC0E,IAAI,CAACsI,MAAM,CAAC,CACnE,GAAM,CAAAD,OAAc,CAAGpT,kBAAkB,CAACqG,IAAI,CAACiN,UAAU,CAACD,MAAM,CAAC,CACjEH,QAAQ,CAAGlT,kBAAkB,CAAC+H,IAAI,CAACqL,OAAM,CAACC,MAAM,CAAC,CACrD,CACA,GAAItI,IAAI,CAACzB,SAAS,GAAK,YAAY,CAAE,CACjC,GAAM,CAAA8J,QAAc,CAAGpT,kBAAkB,CAACqG,IAAI,CAAC0E,IAAI,CAACsI,MAAM,CAAC,CAC3DH,QAAQ,CAAGlT,kBAAkB,CAAC+H,IAAI,CAACqL,QAAM,CAACC,MAAM,CAAC,CACrD,CACA,GAAIH,QAAQ,CAAE,KAAAK,UAAA,CAAA9P,0BAAA,CACYyP,QAAQ,CAAC9N,WAAW,EAAAoO,MAAA,KAA1C,IAAAD,UAAA,CAAA5P,CAAA,KAAA6P,MAAA,CAAAD,UAAA,CAAA3P,CAAA,IAAAC,IAAA,EAA4C,IAApC,CAAA4P,UAAU,CAAAD,MAAA,CAAAtS,KAAA,CACd,GAAM,CAAAwS,WAAiC,CAAG1T,kBAAkB,CAACqG,IAAI,CAACoN,UAAU,CAAC,CAC7E,GAAGC,WAAW,CAACpK,SAAS,GAAK,QAAQ,CAAE6J,OAAO,CAACpP,IAAI,CAAC2P,WAAqB,CAAC,CAC9E,CAAC,OAAAzP,GAAA,EAAAsP,UAAA,CAAArP,CAAA,CAAAD,GAAA,WAAAsP,UAAA,CAAApP,CAAA,IACL,CACA,MAAO,CAAAgP,OAAO,CAClB,CAAC,GAAAlS,GAAA,4BAAAC,KAAA,CACD,SAAAyS,yBAAuC3P,EAAU,CAAiB,CAC9D,GAAM,CAAA+G,IAAI,CAAG/K,kBAAkB,CAACqG,IAAI,CAACrC,EAAE,CAAY,CACnD,GAAI,CAAAkP,QAA+B,CACnC,GAAM,CAAAnM,WAA0B,CAAG,EAAE,CACrC,GAAGgE,IAAI,CAACzB,SAAS,GAAK,YAAY,CAAE,CAChC,GAAM,CAAA8J,MAAc,CAAGpT,kBAAkB,CAACqG,IAAI,CAAC0E,IAAI,CAACsI,MAAM,CAAC,CAC3DH,QAAQ,CAAGlT,kBAAkB,CAACqG,IAAI,CAAC+M,MAAM,CAACC,MAAM,CAAC,CACrD,CACA,GAAGtI,IAAI,CAACzB,SAAS,GAAK,YAAY,CAAE,CAChC,GAAM,CAAAgK,UAAsB,CAAGtT,kBAAkB,CAACqG,IAAI,CAAC0E,IAAI,CAACsI,MAAM,CAAC,CACnE,GAAM,CAAAD,QAAc,CAAGpT,kBAAkB,CAACqG,IAAI,CAACiN,UAAU,CAACD,MAAM,CAAC,CACjEH,QAAQ,CAAGlT,kBAAkB,CAACqG,IAAI,CAAC+M,QAAM,CAACC,MAAM,CAAC,CACrD,CACA,GAAGtI,IAAI,CAACzB,SAAS,GAAK,YAAY,CAAE,CAChC,GAAM,CAAA8J,QAAc,CAAGpT,kBAAkB,CAACqG,IAAI,CAAC0E,IAAI,CAACsI,MAAM,CAAC,CAC3DH,QAAQ,CAAGlT,kBAAkB,CAACqG,IAAI,CAAC+M,QAAM,CAACC,MAAM,CAAC,CACrD,CACA,GAAGH,QAAQ,CAAE,KAAAU,UAAA,CAAAnQ,0BAAA,CACayP,QAAQ,CAAC9N,WAAW,EAAAyO,MAAA,KAA1C,IAAAD,UAAA,CAAAjQ,CAAA,KAAAkQ,MAAA,CAAAD,UAAA,CAAAhQ,CAAA,IAAAC,IAAA,EAA4C,IAApC,CAAA4P,UAAU,CAAAI,MAAA,CAAA3S,KAAA,CACd,GAAM,CAAAwS,WAAiC,CAAG1T,kBAAkB,CAACqG,IAAI,CAACoN,UAAU,CAAC,CAC7E,GAAGC,WAAW,CAACpK,SAAS,GAAK,aAAa,CAAEvC,WAAW,CAAChD,IAAI,CAAC2P,WAA0B,CAAC,CAC5F,CAAC,OAAAzP,GAAA,EAAA2P,UAAA,CAAA1P,CAAA,CAAAD,GAAA,WAAA2P,UAAA,CAAAzP,CAAA,IACL,CACA,MAAO,CAAA4C,WAAW,CACtB,CAAC,GAAA9F,GAAA,iBAAAC,KAAA,CAED,SAAA6P,cAA6BrC,IAA+B,CAAE3D,IAA+B,CAAEyC,KAAmB,CAAEyC,EAA2B,CAAEE,GAAc,CAAE,CAC7J,GAAI,CAAA2D,UAAU,CAAG3D,GAAG,CAACtC,OAAO,CAC5B,GAAI,CAAAkG,kBAA2B,CAAG9D,EAAE,CAAC8D,kBAAkB,CACvD9D,EAAE,CAAC8D,kBAAkB,CAAG,KAAK,CAE7B;AACA,GAAI,CAAAC,UAAU,CAAG,CAAC5K,IAAI,CAAE2B,IAAI,SAAJA,IAAI,iBAAJA,IAAI,CAAE3B,IAAI,CAAE6K,GAAG,CAAChE,EAAE,CAAC3B,WAAW,CAAE2B,EAAE,CAAAiE,aAAA,IAAKjE,EAAE,CAAC,CAAElF,IAAI,CAACA,IAAI,EAAEA,IAAI,CAACoB,KAAK,CAAEuC,IAAI,CAACA,IAAI,EAAAwF,aAAA,IAAMxF,IAAI,CAACvC,KAAK,CAAC,CAAEgI,IAAI,CAAGzF,IAAI,SAAJA,IAAI,iBAAJA,IAAI,CAAU0F,MAAM,CAAC,CACnJ,GAAInE,EAAE,CAAC3B,WAAW,CAAE,CAChB,GAAI,CACA6B,GAAG,CAACtC,OAAO,CAAGoC,EAAE,CAAC3B,WAAW,CAAC,CAACvD,IAAI,CAAJA,IAAI,CAAE2D,IAAI,CAAJA,IAAI,CAAEwB,IAAI,CAAElQ,kBAAkB,CAAC4R,KAAK,CAACpE,KAAK,CAAC,CAAE6G,SAAS,CAAEpE,EAAE,CAACoE,SAAS,CAAC,CAAC,CAC1G;AACA,OAAQ,MAAO,CAAAlE,GAAG,CAACtC,OAAO,EACtB,IAAK,SAAS,CAAE;AACZ,GAAI,CAACsC,GAAG,CAACtC,OAAO,CAAEsC,GAAG,CAACtC,OAAO,CAAGrN,eAAe,CAACsN,WAAW,CAC3D,MACJ,IAAK,QAAQ,CAAE;AACX,GAAIwG,KAAK,CAACnE,GAAG,CAACtC,OAAO,CAAC,EAAIsC,GAAG,CAACtC,OAAO,CAAG,CAAC,CAAEsC,GAAG,CAACtC,OAAO,CAAGrN,eAAe,CAACsN,WAAW,CACpF,MACJ,QACIqC,GAAG,CAACtC,OAAO,CAAGrN,eAAe,CAACsN,WAAW,CACzC,MACR,CACJ,CACA,MAAO5J,CAAK,CAAE,KAAAqQ,UAAA,CAAE;AACZxU,GAAG,CAACyU,EAAE,CAAC,kCAAkC,GAAAD,UAAA,CAAGrQ,CAAC,CAACuQ,OAAO,UAAAF,UAAA,iBAATA,UAAA,CAAWhI,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,EAAE,CAACrI,CAAC,CAADA,CAAC,CAAE6G,IAAI,CAAJA,IAAI,CAAE2D,IAAI,CAAJA,IAAI,CAAEyB,GAAG,CAAHA,GAAG,CAAE8D,GAAG,CAAChE,EAAE,CAAC3B,WAAW,CAAC,EAAE,CAAC,CAAC,CACnH6B,GAAG,CAACtC,OAAO,CAAGrN,eAAe,CAACsN,WAAW,CAC7C,CACJ,CAAC,IAAM,CAAAqC,GAAG,CAACtC,OAAO,CAAG,IAAI,CAAE;AAE3B;AACA,MAAO,CAAAkG,kBAAkB,EAAI5D,GAAG,CAACtC,OAAO,GAAKiG,UAAU,CAC3D,CAAC,WAAAnT,SAAA,KAAAG,OAAA,CAxVc4T,kBAAkB,CAAG,SAAC9J,KAAa,QAAK,CAAAA,KAAK,CAAClE,MAAM,GAAA5F,OAAA,IAAAD,MAAA,EA2VtE8T,MAAM,CAAShU,SAAS,CAAGA,SAAS,CAAC,GAEhC,CAAAiU,MAAM,CACR,SAAAA,OAAmBjD,KAAa,CAAS1P,OAAU,CAAE,CAAAlB,eAAA,MAAA6T,MAAA,OAAlCjD,KAAa,CAAbA,KAAa,MAAS1P,OAAU,CAAVA,OAAU,CAAG,CAAC"},"metadata":{},"sourceType":"module"}