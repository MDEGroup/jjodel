{"ast":null,"code":"import { DViewElement, UX, GraphElementComponent, ViewEClassMatch, NodeTransientProperties, ViewTransientProperties, Uobj } from '../../joiner';\nimport { Action, CompositeAction, CreateElementAction, DeleteElementAction, DPointerTargetable, DState, DUser, getPath, Log, MyError, PendingPointedByPaths, PointedBy, Pointers, RuntimeAccessibleClass, SetFieldAction, SetRootFieldAction, statehistory } from \"../../joiner\";\nimport React from \"react\";\nimport { BEGIN, END, LoadAction, RedoAction, UndoAction } from \"../action/action\";\nimport Collaborative from \"../../components/collaborative/Collaborative\";\nimport { SimpleTree } from \"../../common/SimpleTree\";\nimport { transientProperties, Selectors } from \"../../joiner\";\nimport { contextFixedKeys } from '../../graph/graphElement/sharedTypes/sharedTypes';\nimport { ProjectsApi } from \"../../api/persistance\";\nimport DSL from \"../../DSL/DSL\";\nlet windoww = window;\nlet U = windoww.U;\nfunction deepCopyButOnlyFollowingPath(oldStateDoNotModify, action, prevAction, newVal) {\n  var _action$path;\n  let newRoot = {\n    ...oldStateDoNotModify\n  };\n  let current = newRoot;\n  if (!((_action$path = action.path) === null || _action$path === void 0 ? void 0 : _action$path.length)) throw new MyError(\"path length must be at least 1\", {\n    action\n  });\n  let gotChanged = false; // dovrebbe cambiare sempre, se non cambia non lancio neanche l'azione e non faccio la shallow copy, ma non si sa mai, così posso evitare un render se succede l' \"insuccedibile\"\n  let alreadyPastDivergencePoint = false; // true dal momento in cui il path dell'azione attuale e della azione precedente divergono, false fino al sotto-segmento in cui combaciano\n  // console.log('deepCopyButOnlyFollowingPath', arguments);\n  for (let i = 0; i < action.pathArray.length; i++) {\n    let key = action.pathArray[i].trim();\n    let prevActionPathKey = prevAction === null || prevAction === void 0 ? void 0 : prevAction.pathArray[i];\n    // middle execution: not on final loop\n    // console.log('deepCopyButOnlyFollowingPath', {current, i, imax:action.pathArray.length, key, gotChanged, alreadyPastDivergencePoint});\n    if (i !== action.pathArray.length - 1) {\n      if (alreadyPastDivergencePoint || key !== prevActionPathKey) {\n        // se l'oggetto è stato già duplicato in una azione composita, non lo duplico 2 volte.\n        alreadyPastDivergencePoint = true;\n        current[key] = Array.isArray(current[key]) ? [...current[key]] : {\n          ...current[key]\n        };\n        current[key].clonedCounter = 1 + (current[key].clonedCounter || 0);\n      }\n      current = current[key];\n      continue;\n    }\n    // Giordano: added this on 03/12/2023 to prevent \"Cannot read properties of undefined\".\n    // if(!current) continue; damiano: temp removed to check if there are invalid actions firing\n    // perform final assignment\n    if (i >= action.pathArray.length - 1) {\n      let isArrayAppend = false;\n      let isArrayRemove = false;\n      let isObjectMerge = false;\n      let isObjectDifference = false;\n      // console.log('isarrayappend?', {endswith: U.endsWith(key, ['+=', '[]', '-1']), key, action, i});\n      // console.log('isarraydelete?', {endswith: U.endsWith(key, ['-='])});\n\n      let oldValue;\n      if (U.endsWith(key, ['+=', '[]'])) {\n        key = key.substr(0, key.length - 2).trim();\n        oldValue = current[key];\n        switch (typeof oldValue) {\n          case 'object':\n            if (Array.isArray(oldValue)) isArrayAppend = true;else isObjectMerge = true;\n            break;\n          default:\n            newVal += oldValue;\n            break;\n        }\n      }\n      if (U.endsWith(key, ['-='])) {\n        key = key.substr(0, key.length - 2).trim();\n        oldValue = current[key];\n        switch (typeof oldValue) {\n          case 'object':\n            if (Array.isArray(oldValue)) isArrayRemove = true;else isObjectDifference = true;\n            break;\n          case \"string\":\n            newVal = U.replaceAll(oldValue, newVal, '');\n            break;\n          case 'number':\n            newVal = oldValue - newVal;\n            break;\n          default:\n            isArrayRemove = true;\n            break;\n        }\n        // isArrayRemove = true;\n      }\n\n      // let unpointedElement: DPointerTargetable | undefined;\n      // perform final assignment\n      if (action.type === CreateElementAction.type && current[key]) {\n        oldValue = current[key];\n        gotChanged = false;\n        Log.ee(\"rejected CreateElementAction, rollback occurring:\", {\n          action,\n          preexistingValue: current[key],\n          isShallowEqual: current[key] === action.value\n        });\n        return false; // warning: use return only when you want to abort and skip subsequent CompositeAction sub-actions like now.\n      }\n      if (isObjectMerge) {\n        if (typeof newVal === 'string') {\n          let tmp = {};\n          tmp[newVal] = true;\n          newVal = tmp;\n        }\n        oldValue = {\n          ...current[key]\n        };\n        current[key] = {\n          ...current[key]\n        };\n        for (let subkey in newVal) {\n          // console.warn(\"object merge\", {current, key, subkey, newVal, old:current[key][subkey], new:newVal[subkey]});\n          if (current[key][subkey] === newVal[subkey]) continue;\n          current[key][subkey] = newVal[subkey];\n          gotChanged = true;\n          if (action.isPointer) {\n            newRoot = PointedBy.add(key, action, newRoot, \"+=\");\n          }\n        }\n      } else if (isObjectDifference) {\n        if (typeof newVal === 'string') {\n          let tmp = {};\n          tmp[newVal] = true;\n          newVal = tmp;\n        }\n        oldValue = {\n          ...current[key]\n        };\n        current[key] = {\n          ...current[key]\n        };\n        for (let subkey in newVal) {\n          if (!(subkey in current[key])) continue;\n          delete current[key][subkey];\n          gotChanged = true;\n          if (action.isPointer) {\n            newRoot = PointedBy.add(key, action, newRoot, \"-=\");\n          }\n        }\n      } else if (isArrayAppend) {\n        gotChanged = true;\n        if (!Array.isArray(current[key])) {\n          current[key] = [];\n        }\n        oldValue = [...current[key]];\n        current[key] = [...current[key]];\n        current[key].push(newVal);\n        // unpointedElement = undefined;\n        if (action.isPointer) {\n          newRoot = PointedBy.add(newVal, action, newRoot, \"+=\");\n        }\n      } else if (isArrayRemove) {\n        if (!Array.isArray(current[key])) {\n          current[key] = [];\n        }\n        oldValue = [...current[key]];\n        let index;\n        if (U.isNumber(newVal)) {\n          // delete by index\n          index = newVal;\n          if (index < 0) index = oldValue.length + index; // if index is -2, i remove the penultimate element\n        } else if (newVal === undefined) {\n          index = oldValue.length - 1;\n        } else {\n          index = oldValue.indexOf(newVal);\n        }\n        // if it's negatively or positively out of boundary, i skip it\n        gotChanged = index >= 0 && index < current[key].length;\n        if (gotChanged) {\n          current[key] = [...current[key]];\n          let removedval = current[key].splice(index, 1); // in-place edit\n          if (action.isPointer) {\n            newRoot = PointedBy.remove(removedval, action, newRoot, '-=');\n          }\n          /*\r\n          fixed problem: se ho [dobj1, dobj2]... e li swappo, cambia un indice nel percorso \"pointedby\" e non me ne accorgo mai e un oggetto risulta \"pointedby\" da oggetti che non lo puntano o non esistono più a quell'indice\r\n          SOLVED! by not including index in pointedBy path, but making it like \"parentObject.arrayKey+=\" instead of \"parentObject.arrayKey.4\"\r\n          and knowing it's in the array it's enough info.\r\n            // a.pointsto = [x, y, z]; a.pointsto = [x, z]       --->    remove a from y.pointedby\r\n          const elementsThatChangedIndex: DPointerTargetable[] = current[key].slice(index);\r\n            for (let j = 0; j < elementsThatChangedIndex.length; j++) {\r\n              let newindex = index + j - 1;\r\n              let oldFullpathTrimmed = action.pathArray.join('.');\r\n              se realizzi \"pointedby\" qui è to do: remove old paths and re-add them with updated index\r\n          }\r\n          unpointedElement = newRoot.idlookup[oldValue];\r\n          */\n        }\n      } else if (action.type === DeleteElementAction.type && !(key in current) || current[key] === newVal) {\n        // value not changed\n        gotChanged = false;\n      } else {\n        // value changed\n        // todo: caso in cui setto manualmente classes.1 = pointer;\n        //  the latest element is array and not DPointerTargetable, so might need to buffer upper level in the tree? or instead of \"current\" keep an array of sub-objects encountered navigating the path in state.\n        oldValue = current[key];\n        gotChanged = true;\n        // unpointedElement = newRoot.idlookup[oldValue];\n        // NB: se elimino un oggetto che contiene array di puntatori, o resetto l'array di puntatori kinda like store.arr= [ptr1, ptr2, ...]; store.arr = [];\n        // i puntati dall'array hanno i loro pointedBY non aggiornati, non voglio fare un deep check di tutto l'oggetto a cercare puntatori per efficienza.\n        // if (newVal === undefined) delete current[key];\n        if (newVal === undefined || false && action.type === DeleteElementAction.type) delete current[key];else current[key] = newVal;\n\n        // update pointedBy's\n        // NB: even if the current action have isPointer=true, it doesn't mean the old value is a pointer as well for sure. so need to check old values.\n        // also what if old val is pointer, and new one isn't? will it be just removed without updating pointedBy's?\n        // already fixed: might need to evaluate this if block always regardless of action.isPointer,\n        // and do checks every time both on old and new value if they actually are ptrs.\n        if (true || action.isPointer) {\n          let oldpointerdestinations;\n          let newpointerdestinations;\n          if (Array.isArray(newVal)) {\n            newpointerdestinations = newVal;\n            if (Array.isArray(oldValue)) {\n              // case: path.array = array;\n              oldpointerdestinations = oldValue;\n            } else {\n              // case: path.object = array; + case: path.value = array;\n              oldpointerdestinations = [oldValue];\n            }\n          } else {\n            // case: path.array = object; + case: path.array = value;\n            newpointerdestinations = [newVal];\n            if (Array.isArray(oldValue)) {\n              oldpointerdestinations = oldValue;\n            } else {\n              // case: path.object = object; and all other cases without arrays involved\n              oldpointerdestinations = [oldValue];\n            }\n          }\n          // after i mapped all cases to path.array = array; i solve it for that case.\n          let difference = U.arrayDifference(oldpointerdestinations, newpointerdestinations); // : {added: Pointer[], removed: Pointer[], starting: Pointer[], final: Pointer[]}\n          for (let rem of difference.removed) {\n            if (Pointers.isPointer(rem)) newRoot = PointedBy.remove(rem, action, newRoot, undefined, oldStateDoNotModify);\n          }\n          for (let add of difference.added) {\n            if (Pointers.isPointer(add)) newRoot = PointedBy.add(add, action, newRoot, undefined, oldStateDoNotModify);\n          }\n          // a.pointsto = [a, b, c];  a.pointsto = [a, b, x];    ------>     c.pointedby.remove(a) & x.pointedby.add(a)\n          // idlookup.somelongid.pointsto = [...b];\n        }\n      }\n      break;\n    }\n    Log.exDevv('should not reach here: reducer');\n  }\n  return gotChanged ? newRoot : oldStateDoNotModify;\n}\n\n// const pendingPointedByPaths: {from: DocString<\"Path in store\">, field: DocString<\"keyof object found in from path\">, to: Pointer}[] = [];\nfunction CompositeActionReducer(oldState, actionBatch) {\n  // per via di thunk se arrivo qui lo stato cambia sicuro in mono-client non synchro (non ri-assegno valori equivalenti)\n  // todo: ma se arrivano in ordine sbagliato da altri client? posso permetterlo?\n  let actions;\n  if (actionBatch.actions) actions = Action.parse(actionBatch.actions);else actions = [Action.parse(actionBatch)]; // else-case is if it's a single action and not an actual compositeaction\n  if (PendingPointedByPaths.all.length) actions.push(...PendingPointedByPaths.getSolveableActions(oldState)); //.all.map( p=> p.resolve() ) );\n\n  Action.possibleInconsistencies = {};\n\n  // estraggo le azioni derivate\n  let derivedActions = [];\n  let newState = oldState;\n  for (let action of actions) {\n    switch (action.type) {\n      default:\n        break;\n      case CreateElementAction.type:\n        const elem = action.value;\n        delete DPointerTargetable.pendingCreation[elem.id];\n        /*\r\n        if (oldState.idlookup[elem.id]) {\r\n            Log.ee(\"rejected CreateElementAction, rollback occurring:\", {action, elem:{...elem},\r\n                preexistingValue: {...oldState.idlookup[elem.id]}, isEqual: elem === oldState.idlookup[elem.id] });\r\n            return oldState; // warning: use return only when you want to abort and skip subsequent CompositeAction sub-actions like now.\r\n              action.value = \"An element with that id already existed.\";\r\n            action.path = action.field = \"CreateActionRejected\";\r\n            action.className = SetRootFieldAction.name;\r\n            action.type = SetRootFieldAction.type;\r\n            action.pathArray = [action.path]; //a\r\n            action.isPointer = false;\r\n            // just to log it in undo-redo action list and have a feedback\r\n            return oldState;}*/\n\n        elem.className = elem.className || elem.constructor.cname || elem.constructor.name;\n        let statefoldername = elem.className.substring(1).toLowerCase() + 's';\n        derivedActions.push(Action.parse(SetRootFieldAction.create(statefoldername, elem.id, '[]', true)));\n        if (!Array.isArray(elem.pointedBy)) elem.pointedBy = [];\n        elem.pointedBy.push(PointedBy.new(statefoldername));\n        /*if (false && action.isPointer) {\r\n            if (Array.isArray(action.value)) {\r\n                const ptr: Pointer[] = action.value;\r\n                // todo but replaced by side actions in execution of the main action instead of triggering derived actions\r\n            }\r\n            else {\r\n                const ptr: Pointer = action.value;\r\n                const target: DPointerTargetable | null = oldState.idlookup[ptr];\r\n                let pendingPointedBy = PendingPointedByPaths.new(action, oldState);\r\n                if (!target) PendingPointedByPaths.new(action, oldState).saveForLater(); // {from: action.path, field: action.field, to: target});\r\n                // @ts-ignore\r\n                else derivedActions.push(pendingPointedBy.resolve());\r\n                // a -> x\r\n                // a -> y     unset x.pointedby(a)\r\n            }\r\n        }*/\n        break;\n    }\n  }\n  // console.error({U, Umip:U.arrayMergeInPlace, WU: windoww.U, WUmip: windoww.U.arrayMergeInPlace});\n  actions = U.arrayMergeInPlace(actions, derivedActions);\n\n  // ordino i path con segmenti comuni\n  actions = actions.sort((a1, a2) => U.stringCompare(a1.path, a2.path));\n\n  // destrutturo solo i nodi intermedi e solo la prima volta che li incontro (richiede le azioni ordinate in base al path)\n\n  for (let i = 0; i < actions.length; i++) {\n    const prevAction = actions[i - 1];\n    const action = actions[i];\n    const actiontype = action.type.indexOf('@@') === 0 ? 'redux' : action.type;\n    console.log('executing action:', {\n      a: action,\n      t: actiontype,\n      field: action.field,\n      v: action.value\n    }); //, count: ++action.executionCount});\n\n    switch (actiontype) {\n      /*\r\n      case '@@redux/INIT' + randomstr:... etc*/\n      default:\n        if (action.type.indexOf('@@redux/') === 0) break;\n        return Log.exDevv('unexpected action type:', action.type);\n      case LoadAction.type:\n        newState = action.value;\n        break;\n      case CreateElementAction.type:\n      case SetRootFieldAction.type:\n      case DeleteElementAction.type:\n      case SetFieldAction.type:\n        let tmp = deepCopyButOnlyFollowingPath(newState, action, prevAction, action.value);\n        if (!tmp) return oldState; // rollback due to invalid action in transaction\n        newState = tmp;\n        break;\n    }\n\n    // and that's all, the reducer is really simple as actions are really simple.\n  }\n\n  // effetti collaterali, aggiornamento di ridondanze\n  newState = updateRedundancies_OBSOLETE(newState, oldState, Action.possibleInconsistencies);\n  return newState;\n}\n_c = CompositeActionReducer;\nfunction updateRedundancies_OBSOLETE(state, oldState, possibleInconsistencies) {\n  for (let subType in possibleInconsistencies) switch (subType) {\n    default:\n      break;\n    case Action.SubType.vertexSubElements: /*\r\n                                           risolto triggrerando più azioni da LGraphElement setter\r\n                                           let dvertexid: Pointer, newdvertex: DGraphElement, olddvertex: DGraphElement;\r\n                                           for (newdvertex of possibleInconsistencies[subType] as DGraphElement[]){\r\n                                           const olddvertex: DGraphElement = oldState.idlookup[newdvertex.id] as DGraphElement;\r\n                                           const notContainedAnymoreOut: Pointer<DGraphElement> = [];\r\n                                           const newlyInsertedOut: Pointer<DGraphElement>[] = [];\r\n                                           U.arraySymmetricDifference(olddvertex.subElements, newdvertex.subElements, notContainedAnymoreOut, newlyInsertedOut);\r\n                                           for (let geid of notContainedAnymoreOut) {\r\n                                           const oldge = oldState.idlookup[geid] as DGraphElement;\r\n                                           const newge = state.idlookup[geid] as DGraphElement;\r\n                                           if (oldge.containedIn === newge.containedIn) continue;\r\n                                           }\r\n                                           for (let geid of notContainedAnymoreOut) {\r\n                                           const ge = idlookup[geid] as DGraphElement;\r\n                                           if (ge.containedIn === context.data.id) set container = context.data.id\r\n                                           meglio se sti 2 cicli li fai nel reducer perchè  potrebbe esserci una azione pending che setta il parent = someotherid e qui faccio partire una azione che setta il parent a null, \"annullando\" una azione pending non ancora eseguita\r\n                                           }\r\n                                           }\r\n                                           break;*/\n  }\n  // if state is updated shallow copy state before returning it\n  return state;\n}\nlet initialState = null;\nlet storeLoaded = false;\nconst UDRegexp = /(?:^|\\s|;|}|\\n|\\t|\\(|,)ret\\s*\\.\\s*[a-zA-Z_$][0-9a-zA-Z_$]*\\s*=/g;\n/* tested with:\r\nif (ret.key = stuff) ret.key2=morestuff;\r\n;ret.k=3;\r\n}ret. kk=3,ret. a = 3\r\n\r\nret .b = 3\r\n*/\n\n// then add to it: content of props, constants, usageDeclarations\n\nexport function reducer() {\n  let oldState = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : initialState;\n  let action = arguments.length > 1 ? arguments[1] : undefined;\n  if (!windoww.actions) windoww.jjactions = [];\n  windoww.jjactions.push(action);\n  try {\n    return unsafereducer(oldState, action);\n  } catch (e) {\n    console.error('unhandled error in reducer', {\n      e,\n      oldState,\n      action\n    });\n    return oldState;\n  }\n}\nfunction unsafereducer() {\n  var _oldState, _ret$VIEWS_RECOMPILE_, _ret$VIEWS_RECOMPILE_2, _ret$VIEWS_RECOMPILE_3, _ret$VIEWS_RECOMPILE_4, _ret$VIEWS_RECOMPILE_5;\n  let oldState = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : initialState;\n  let action = arguments.length > 1 ? arguments[1] : undefined;\n  if (!oldState) {\n    oldState = initialState = DState.new();\n  }\n  // console.log('external REDUCER', {action, CEtype:CreateElementAction.type});\n\n  const ret = _reducer(oldState, action);\n  if (ret === oldState) return oldState;\n  ret.idlookup.__proto__ = DPointerTargetable.pendingCreation;\n  // client synchronization stuff\n  if ((_oldState = oldState) === null || _oldState === void 0 ? void 0 : _oldState.collaborativeSession) {\n    const ignoredFields = ['version', 'env', 'debug', 'isEdgePending', 'contextMenu', '_lastSelected', 'isLoading', 'collaborativeSession', 'VIEWS_RECOMPILE_onDataUpdate', 'VIEWS_RECOMPILE_onDragStart', 'VIEWS_RECOMPILE_onDragEnd', 'VIEWS_RECOMPILE_whileDragging', 'VIEWS_RECOMPILE_onResizeStart', 'VIEWS_RECOMPILE_onResizeEnd', 'VIEWS_RECOMPILE_whileResizing', 'VIEWS_RECOMPILE_onRotationStart', 'VIEWS_RECOMPILE_onRotationEnd', 'VIEWS_RECOMPILE_whileRotating', 'VIEWS_RECOMPILE_constants', 'VIEWS_RECOMPILE_usageDeclarations', 'VIEWS_RECOMPILE_jsxString', 'VIEWS_RECOMPILE_preconditions', 'VIEWS_RECOMPILE_jsCondition', 'VIEWS_RECOMPILE_ocl', 'VIEWS_RECOMPILE_events', 'VIEWS_RECOMPILE_all', 'ClassNameChanged', 'tooltip', 'advanced', 'alert'];\n    /* Checking if CompositeAction has some actions that MUST be ignored */\n    let compositeAction = null;\n    if (action.type === CompositeAction.type) {\n      compositeAction = action;\n      const subActions = compositeAction.actions || [];\n      compositeAction.actions = subActions.filter(a => !ignoredFields.includes(a.field));\n    }\n    if (compositeAction && !compositeAction.actions.length) return ret;\n    action = compositeAction ? compositeAction : action;\n    if (action.sender === DUser.current && !ignoredFields.includes(action.field)) {\n      const parsedAction = JSON.parse(JSON.stringify(action));\n      Collaborative.client.emit('pushAction', parsedAction);\n    }\n  }\n  function filterSet(r) {\n    if (!Array.isArray(r)) r = [];\n    r = r.filter(e => !!e);\n    return new Set(r);\n  }\n  // recompile stuff\n  for (let ptr of filterSet(ret.ELEMENT_CREATED)) {\n    let d = ret.idlookup[ptr];\n    if (!d) continue; // creation rejected, no-op\n    switch (d.className) {\n      default:\n        break;\n      case \"DViewElement\":\n        for (let nid in transientProperties.node) {\n          let tn = transientProperties.node[nid];\n          delete tn.viewScores[d.id]; //= {} as any;\n        }\n    }\n  }\n  ret.ELEMENT_CREATED = [];\n  for (let ptr of filterSet(ret.ELEMENT_DELETED)) {\n    let d = oldState.idlookup[ptr];\n    if (!d) continue; // already deleted, no-op\n    switch (d.className) {\n      default:\n        break;\n      case \"DViewElement\":\n        for (let nid in transientProperties.node) {\n          let tn = transientProperties.node[nid];\n          // delete tn.stackViews; // trigger recalc of all scores.\n          delete tn.viewScores[d.id];\n          tn.needSorting = true;\n        }\n    }\n  }\n  ret.ELEMENT_DELETED = [];\n  if (ret.VIEWS_RECOMPILE_all === true) ret.VIEWS_RECOMPILE_all = Object.keys(ret.idlookup);\n  if ((_ret$VIEWS_RECOMPILE_ = ret.VIEWS_RECOMPILE_all) === null || _ret$VIEWS_RECOMPILE_ === void 0 ? void 0 : _ret$VIEWS_RECOMPILE_.length) {\n    let resetAllNodes = false;\n    let sk;\n    for (let id of filterSet(ret.VIEWS_RECOMPILE_all)) {\n      let d = ret.idlookup[id];\n      if (!d) continue;\n      if (RuntimeAccessibleClass.extends(d.className, \"DViewElement\")) {\n        d.css_MUST_RECOMPILE = true;\n        transientProperties.view[d.id] = {};\n        // for (let k of DViewElement.MeasurableKeys) (ret as any)['VIEWS_RECOMPILE_'+k].push(d.id);\n        // for (let k of DViewElement.RecompileKeys) (ret as any)['VIEWS_RECOMPILE_'+k].push(d.id);\n        for (sk in ret) if (sk.indexOf('VIEWS_RECOMPILE') === 0) ret[sk].push(id);\n        // ret.NODES_RECOMPILE_labels.push(id); ret.NODES_RECOMPILE_longestLabel.push(id);\n        if (!resetAllNodes) resetAllNodes = true;\n      }\n      if (RuntimeAccessibleClass.extends(d.className, \"DModelElement\")) {\n        if (d.className === \"DClass\") {\n          var _oldState$idlookup$d$, _ret$idlookup$d$id;\n          let oldname = (_oldState$idlookup$d$ = oldState.idlookup[d.id]) === null || _oldState$idlookup$d$ === void 0 ? void 0 : _oldState$idlookup$d$.name;\n          let newname = (_ret$idlookup$d$id = ret.idlookup[d.id]) === null || _ret$idlookup$d$id === void 0 ? void 0 : _ret$idlookup$d$id.name;\n          if (oldname !== newname) ret.ClassNameChanged[d.id] = oldname;\n        }\n        for (sk in ret) if (sk.indexOf('MODELS_RECOMPILE') === 0) ret[sk].push(id);\n        // transientProperties.modelElement[d.id] = { } as any; stuff in here does not need replacement, can never be dangerous (currently).\n      }\n      if (RuntimeAccessibleClass.extends(d.className, \"DGraphElement\")) {\n        delete transientProperties.node[d.id]; // = { } as any;\n        // transientProperties.node[d.id as string] = undefined as any;\n        console.warn('tn deleted', {\n          tn: transientProperties.node[d.id],\n          id: d.id\n        });\n        for (sk in ret) if (sk.indexOf('NODES_RECOMPILE') === 0) ret[sk].push(id);\n        //ret.NODES_RECOMPILE_labels.push(id); ret.NODES_RECOMPILE_longestLabel.push(id);\n      }\n    }\n    if (resetAllNodes) for (let nid in transientProperties.node) {\n      delete transientProperties.node[nid]; // = {} as any;\n      // transientProperties.node[nid] = undefined as any;\n      console.warn('tn deleted 2', {\n        tn: transientProperties.node[nid],\n        nid\n      });\n      for (sk in ret) if (sk.indexOf('NODES_RECOMPILE') === 0) ret[sk].push(nid);\n      //ret.NODES_RECOMPILE_labels.push(id); ret.NODES_RECOMPILE_longestLabel.push(id);\n    }\n  }\n  ret.VIEWS_RECOMPILE_all = [];\n  function parseLabel(ptr, key, isNode) {\n    var _mainView;\n    let dv = DPointerTargetable.fromPointer(ptr, ret);\n    let tp = (isNode ? transientProperties.node : transientProperties.view)[ptr];\n    if (!tp) {\n      if (isNode) transientProperties.node[ptr] = tp = new NodeTransientProperties();else transientProperties.view[ptr] = tp = new ViewTransientProperties();\n    }\n    let val = dv[key];\n    if (!val) {\n      tp[key] = undefined;\n      return true;\n    }\n    if (typeof val === \"function\") {\n      tp[key] = val;\n      return true;\n    }\n    let allContextKeys = {\n      ...contextFixedKeys\n    };\n    let vid = isNode ? (_mainView = tp.mainView) === null || _mainView === void 0 ? void 0 : _mainView.id : ptr;\n    if (!vid) return false; // leave pending & recompute them on next reducer action\n    let tv = transientProperties.view[vid];\n    for (let k of tv.constantsList) if (!allContextKeys[k]) allContextKeys[k] = true;\n    for (let k of tv.UDList) if (!allContextKeys[k]) allContextKeys[k] = true;\n    let paramStr = '{' + Object.keys(allContextKeys).join(',') + '}';\n    console.log('labels parse', {\n      allContextKeys,\n      ud: tv.UDList,\n      c: tv.constantsList\n    });\n    const body = 'return (' + val + ')';\n    // if (vid.includes('Model')) console.log(\"modelparse, laels\", {paramStr, body});\n    console.log('labels parse', {\n      vid: ptr,\n      paramStr,\n      body\n    });\n    try {\n      if (isNode) {\n        // need to store the function in tnv instead of tn since if v changes, ud changes as well? in all of them?what if i make a new view?\n      } else {\n        // tp[key] = new Function(paramStr, body) as ((...a: any) => any);\n      }\n      tp[key] = function () {\n        return 'label as an option is disabled, pass it through props instead.';\n      };\n    } catch (e) {\n      /*try{\r\n          let try_to_get_better_error = eval(\"let __f = function(\" + paramStr+\") {\\n\" + body + \"}\");\r\n      } catch(eeval){\r\n          console.error(\"eval error same as func error\", {e, eeval});\r\n          e = eeval;\r\n      }*/\n      console.error('error labels parse', {\n        vid: ptr,\n        e,\n        paramStr,\n        body\n      });\n      tp[key] = val; // (context: GObject) => 'Error during label evaluation';\n    }\n    return true;\n    // implies recompilation of: ... nothing?\n  }\n  let arr;\n  arr = ret.NODES_RECOMPILE_labels;\n  if (arr.length) {\n    let successfullyParsed = {};\n    for (const id of filterSet(arr)) successfullyParsed[id] = parseLabel(id, 'labels', true);\n    ret.NODES_RECOMPILE_labels = arr.filter(e => !successfullyParsed[e]);\n  }\n  arr = ret.NODES_RECOMPILE_longestLabel;\n  if (arr.length) {\n    let successfullyParsed = {};\n    for (const id of filterSet(arr)) successfullyParsed[id] = parseLabel(id, 'longestLabel', true);\n    ret.NODES_RECOMPILE_longestLabel = arr.filter(e => !successfullyParsed[e]);\n  }\n  arr = ret.VIEWS_RECOMPILE_labels;\n  if (arr.length) {\n    let successfullyParsed = {};\n    for (const id of filterSet(arr)) successfullyParsed[id] = parseLabel(id, 'labels', false);\n    ret.VIEWS_RECOMPILE_labels = arr.filter(e => !successfullyParsed[e]);\n  }\n  arr = ret.VIEWS_RECOMPILE_longestLabel;\n  if (arr.length) {\n    let successfullyParsed = {};\n    for (const id of filterSet(arr)) successfullyParsed[id] = parseLabel(id, 'longestLabel', false);\n    ret.VIEWS_RECOMPILE_longestLabel = arr.filter(e => !successfullyParsed[e]);\n  }\n\n  // local changes to out-of-redux stuff\n  if (ret.VIEWS_RECOMPILE_ocl.length) {\n    // for (let gid of filterSet(ret.graphs)) Selectors.updateViewMatchings(gid, ret.modelElements, Object.values(ret.idlookup).map( d => RuntimeAccessibleClass.extends(d, DModelElement.cname)));\n    // for (let vid of filterSet(ret.VIEW_APPLIABLETO_NEEDS_RECALCULATION)) { }\n    for (let vid of filterSet(ret.VIEWS_RECOMPILE_ocl)) {\n      if (!transientProperties.view[vid]) transientProperties.view[vid] = {};\n      transientProperties.view[vid].oclEngine = undefined; // force re-parse\n      transientProperties.view[vid].oclChanged = true;\n      for (let nid in transientProperties.node) {\n        let tnv = transientProperties.node[nid].viewScores[vid];\n        if ((tnv === null || tnv === void 0 ? void 0 : tnv.OCLScore) !== ViewEClassMatch.NOT_EVALUATED_YET) tnv.OCLScore = ViewEClassMatch.NOT_EVALUATED_YET;\n      }\n    }\n    ret.VIEWS_RECOMPILE_ocl = [];\n  }\n  /*\r\n  if (ret.VIEWOCL_UPDATE_NEEDS_RECALCULATION.length) {\r\n      // not implemented for now\r\n      ret.VIEWOCL_UPDATE_NEEDS_RECALCULATION = [];\r\n  }*/\n\n  if (ret.VIEWS_RECOMPILE_preconditions.length) {\n    for (let vid of filterSet(ret.VIEWS_RECOMPILE_preconditions)) {\n      for (let nid in transientProperties.node) {\n        let tnv = transientProperties.node[nid].viewScores[vid];\n        if ((tnv === null || tnv === void 0 ? void 0 : tnv.metaclassScore) !== ViewEClassMatch.NOT_EVALUATED_YET) tnv.metaclassScore = ViewEClassMatch.NOT_EVALUATED_YET;\n      }\n    }\n    ret.VIEWS_RECOMPILE_preconditions = [];\n  }\n  if ((_ret$VIEWS_RECOMPILE_2 = ret.VIEWS_RECOMPILE_constants) === null || _ret$VIEWS_RECOMPILE_2 === void 0 ? void 0 : _ret$VIEWS_RECOMPILE_2.length) for (const vid of filterSet(ret.VIEWS_RECOMPILE_constants)) {\n    // compiled in func, and executed, result does not vary between nodes.\n    let dv = DPointerTargetable.fromPointer(vid, ret);\n    // transientProperties.view[vid].constantsList = dv.constants?.match(UDRegexp).map(s=>s.substring(4, s.length-1).trim()) || [];\n    // let allContextKeys = {...contextFixedKeys};\n    if (!dv.constants) {\n      if (!transientProperties.view[vid]) transientProperties.view[vid] = {};\n      transientProperties.view[vid].constants = {};\n      transientProperties.view[vid].constantsList = [];\n      // no need to recompile UD, jsx or measurables, they will have additional parameters in scope but they are undefined and cause no problems.\n      continue;\n    }\n    const constantsOutput = {};\n    const context = {\n      view: dv\n    }; // context at this point holds only static stuff, which are in gloval scope (window) plus view.\n    let paramStr = '{' + Object.keys(context).join(',') + '}, ret';\n    try {\n      // the scope of new Function() is \"window\" and not the function where is called, unlike eval();\n      let constantsFunction = new Function(paramStr, 'return (' + dv.constants + ')(ret)').bind(context);\n      constantsFunction(context, constantsOutput);\n    } catch (e) {\n      console.error('error constants parse', {\n        vid,\n        e,\n        paramStr,\n        body: 'return (' + dv.constants + ')(ret)'\n      });\n      // todo: how do i render an error from here? even if i set jsx or ud.__invalidDeclarations it will be recompiled. need a constants.__invalidDeclarations too?\n    }\n    transientProperties.view[vid].constants = constantsOutput;\n    transientProperties.view[vid].constantsList = Object.keys(transientProperties.view[vid].constants);\n    // implies recompilation of: jsCondition, ud, jsx and all measurable events\n    ret.VIEWS_RECOMPILE_jsCondition.push(vid);\n    ret.VIEWS_RECOMPILE_usageDeclarations.push(vid);\n    ret.VIEWS_RECOMPILE_jsxString.push(vid);\n    ret.VIEWS_RECOMPILE_events.push(vid);\n    for (let k of DViewElement.MeasurableKeys) ret['VIEWS_RECOMPILE_' + k].push(vid);\n  }\n  ret.VIEWS_RECOMPILE_constants = [];\n  if ((_ret$VIEWS_RECOMPILE_3 = ret.VIEWS_RECOMPILE_usageDeclarations) === null || _ret$VIEWS_RECOMPILE_3 === void 0 ? void 0 : _ret$VIEWS_RECOMPILE_3.length) for (const vid of filterSet(ret.VIEWS_RECOMPILE_usageDeclarations)) {\n    var _dv$usageDeclarations;\n    // compiled in func, but NOT executed, result varies between nodes.\n    let dv = DPointerTargetable.fromPointer(vid, ret);\n    let tv = transientProperties.view[vid];\n    if (!tv) transientProperties.view[vid] = tv = {};\n    if (!dv.usageDeclarations) {\n      tv.UDList = [];\n      tv.UDFunction = undefined;\n      // no need to recompile jsx or measurables, they will have additional parameters in scope but they are undefined and cause no problems.\n      continue;\n    }\n    let matches = ((_dv$usageDeclarations = dv.usageDeclarations) === null || _dv$usageDeclarations === void 0 ? void 0 : _dv$usageDeclarations.match(UDRegexp)) || [];\n    transientProperties.view[vid].UDList = matches.map(s => {\n      s = s.trim();\n      return s.substring(s.indexOf('\\.') + 1, s.length - 2).trim();\n    });\n    // warning for user: do not redeclare ret in nested blocks.\n    // do not use ret[key] syntax.\n    // do not set nested values directly (ret.key.subkey syntax).\n    // do not use ret.key +=, -= or any other operator assignment different than \"=\"\n    // if that is ever required, do instead\n    // do not assign values to ret in block comments\n    // those restrictions only apply to the ret object, all those violations can be done on other objects.\n    // so the following is valid, and a way to overcome the previous limitations:\n    // let subobject = {}; subobject[key] += stuff; ret.somefixedname = subobject;\n\n    let allContextKeys = {\n      ...contextFixedKeys\n    };\n    for (let k of tv.constantsList) if (!allContextKeys[k]) allContextKeys[k] = true;\n    let paramStr = '{' + Object.keys(allContextKeys).join(',') + '}, ret';\n    if (vid.includes('Model')) console.log(\"modelparse, ud\", {\n      paramStr,\n      udstr: dv.usageDeclarations,\n      udlist: transientProperties.view[vid].UDList\n    });\n    try {\n      tv.UDFunction = new Function(paramStr, 'return (' + dv.usageDeclarations + ')(ret)');\n    } catch (e) {\n      // problem: errors cannot be serialized in any way? they have no keys. let strerr = JSON.stringify(e); //(e.message || '').split('\\n')[0]);\n      let udErrors = windoww.udErrors;\n      if (!windoww.udErrors) windoww.udErrors = udErrors = {\n        maxi: 0\n      };\n      udErrors[\"e\" + ++udErrors.maxi] = e;\n      e.isSyntax = true;\n      let errbody = \"ret.__invalidUsageDeclarations = window.udErrors.e\" + udErrors.maxi + \"; return ret;\";\n      console.error('error udparse', {\n        vid,\n        e,\n        paramStr,\n        body: 'return (' + dv.usageDeclarations + ')(ret)',\n        errbody\n      });\n      tv.UDFunction = new Function(\"unusedContext, ret\", errbody);\n    }\n\n    // implies recompilation of: jsx and all measurable events\n    ret.VIEWS_RECOMPILE_jsxString.push(vid);\n    ret.VIEWS_RECOMPILE_events.push(vid);\n    for (let k of DViewElement.MeasurableKeys) ret['VIEWS_RECOMPILE_' + k].push(vid);\n  }\n  ret.VIEWS_RECOMPILE_usageDeclarations = [];\n  if (ret.VIEWS_RECOMPILE_events.length) {\n    // for (let gid of filterSet(ret.graphs)) Selectors.updateViewMatchings(gid, ret.modelElements, Object.values(ret.idlookup).map( d => RuntimeAccessibleClass.extends(d, DModelElement.cname)));\n    // for (let vid of filterSet(ret.VIEW_APPLIABLETO_NEEDS_RECALCULATION)) { }\n    for (let entry of filterSet(ret.VIEWS_RECOMPILE_events)) {\n      let vid;\n      let dv;\n      let keys;\n      if (typeof entry === \"object\") {\n        vid = entry.vid;\n        dv = DPointerTargetable.fromPointer(vid, ret);\n        keys = entry.keys || Object.keys(dv.events);\n      } else {\n        vid = entry;\n        dv = DPointerTargetable.fromPointer(vid, ret);\n        keys = Object.keys(dv.events);\n      }\n      let tv = transientProperties.view[vid];\n      if (!tv) transientProperties.view[vid] = tv = {};\n      if (!tv.events) tv.events = {};\n      // if (!tv.events_raw) tv.events_raw = {};\n      for (let key of keys) {\n        if (!key) {\n          delete tv.events[key];\n          continue;\n        }\n        let allContextKeys = {\n          ...contextFixedKeys\n        };\n        for (let k of transientProperties.view[vid].constantsList) if (!allContextKeys[k]) allContextKeys[k] = true;\n        for (let k of transientProperties.view[vid].UDList) if (!allContextKeys[k]) allContextKeys[k] = true;\n        let paramStr = '{' + Object.keys(allContextKeys).join(',') + '}, ..._params';\n        // dv.events[key] = (...params)=> code\n        const body = 'return (' + dv.events[key] + ')(..._params)';\n        // if (vid.includes('Model')) console.log(\"modelparse, jsx\", {paramStr, body});\n        try {\n          tv.events[key] = new Function(paramStr, body);\n          // tv.events_raw[key] = new Function(paramStr, body) as ((...a:any)=>any);\n          // attempt to auto obtain node context\n          // impossile with view.event.name\n          // could with node.event.name if node.get_event sets a current node thing__, no he must wrap the func!! in the getter\n          // tv.events[key] = (..._params2:any) => { return tv.events_raw[key](context, ..._params2) };\n        } catch (e) {\n          console.error('error jsxparse', {\n            vid,\n            e,\n            paramStr,\n            body\n          });\n          tv.events[key] = context => Log.ee(\"failed to parse function body: \" + e.message.split(\"\\n\")[0], e.message);\n        }\n      }\n    }\n    ret.VIEWS_RECOMPILE_events = [];\n    // triggers recompile of nothing\n  }\n  if ((_ret$VIEWS_RECOMPILE_4 = ret.VIEWS_RECOMPILE_jsCondition) === null || _ret$VIEWS_RECOMPILE_4 === void 0 ? void 0 : _ret$VIEWS_RECOMPILE_4.length) for (const vid of filterSet(ret.VIEWS_RECOMPILE_jsCondition)) {\n    const dv = DPointerTargetable.fromPointer(vid, ret);\n    let tv = transientProperties.view[vid];\n    if (!tv) transientProperties.view[vid] = tv = {};\n    tv.jsConditionChanged = true;\n    if (!dv.jsCondition) {\n      tv.jsCondition = undefined;\n      continue;\n    }\n    const lines = dv.jsCondition.trim().split('\\n');\n    let lastLine = lines[lines.length - 1];\n    if (lastLine.indexOf('return') !== 0) lines[lines.length - 1] = `return (${lastLine})`;\n    if (!dv.jsxString) {\n      transientProperties.view[vid].JSXFunction = undefined;\n      continue;\n    }\n    let allContextKeys = {\n      ...contextFixedKeys\n    };\n    for (let k of transientProperties.view[vid].constantsList) if (!allContextKeys[k]) allContextKeys[k] = true;\n    let paramStr = '{' + Object.keys(allContextKeys).join(',') + '}';\n    const body = lines.join('\\n');\n    try {\n      tv.jsCondition = new Function(paramStr, body);\n    } catch (e) {\n      tv.jsCondition = undefined;\n      console.log('JS Condition parsed error', e);\n    }\n  }\n  ret.VIEWS_RECOMPILE_jsCondition = [];\n  if ((_ret$VIEWS_RECOMPILE_5 = ret.VIEWS_RECOMPILE_jsxString) === null || _ret$VIEWS_RECOMPILE_5 === void 0 ? void 0 : _ret$VIEWS_RECOMPILE_5.length) for (const vid of filterSet(ret.VIEWS_RECOMPILE_jsxString)) {\n    // compiled in func, but NOT executed, result varies between nodes.\n    let dv = DPointerTargetable.fromPointer(vid, ret);\n    let tv = transientProperties.view[vid];\n    if (!tv) transientProperties.view[vid] = tv = {};\n    if (!dv.jsxString) {\n      transientProperties.view[vid].JSXFunction = undefined;\n      continue;\n    }\n    let allContextKeys = {\n      ...contextFixedKeys\n    };\n    for (let k of transientProperties.view[vid].constantsList) if (!allContextKeys[k]) allContextKeys[k] = true;\n    for (let k of transientProperties.view[vid].UDList) if (!allContextKeys[k]) allContextKeys[k] = true;\n    let paramStr = '{' + Object.keys(allContextKeys).join(',') + '}';\n    const body = 'return (' + UX.parseAndInject(DSL.parser(dv.jsxString), dv) + ')';\n    // if (vid.includes('Model')) console.log(\"modelparse, jsx\", {paramStr, body});\n    try {\n      transientProperties.view[vid].JSXFunction = new Function(paramStr, body);\n    } catch (e) {\n      /*try{\r\n          let try_to_get_better_error = eval(\"let __f = function(\" + paramStr+\") {\\n\" + body + \"}\");\r\n      } catch(eeval){\r\n          console.error(\"eval error same as func error\", {e, eeval});\r\n          e = eeval;\r\n      }*/\n      console.error('error jsxparse', {\n        vid,\n        e,\n        paramStr,\n        body\n      });\n      transientProperties.view[vid].JSXFunction = context => GraphElementComponent.displayError(e, 'JSX Syntax', dv);\n    }\n    // implies recompilation of: ... nothing?\n  }\n  ret.VIEWS_RECOMPILE_jsxString = [];\n  for (const key of DViewElement.MeasurableKeys) {\n    var _ref;\n    if ((_ref = ret['VIEWS_RECOMPILE_' + key]) === null || _ref === void 0 ? void 0 : _ref.length) for (let vid of filterSet(ret['VIEWS_RECOMPILE_' + key])) {\n      let dv = DPointerTargetable.fromPointer(vid, ret);\n      let tv = transientProperties.view[vid];\n      if (!tv) transientProperties.view[vid] = tv = {};\n      let str = dv[key];\n      if (!str) {\n        transientProperties.view[vid][key] = undefined;\n        continue;\n      }\n      let allContextKeys = {\n        ...contextFixedKeys\n      };\n      for (let k of transientProperties.view[vid].constantsList) if (!allContextKeys[k]) allContextKeys[k] = true;\n      for (let k of transientProperties.view[vid].UDList) if (!allContextKeys[k]) allContextKeys[k] = true;\n      let paramStr = '{' + Object.keys(allContextKeys).join(',') + '}';\n      console.log('measurable parse ' + key, {\n        allContextKeys,\n        ud: transientProperties.view[vid].UDList,\n        c: transientProperties.view[vid].constantsList\n      });\n      console.log('measurable parse ' + key, {\n        vid,\n        paramStr,\n        body: str\n      });\n      try {\n        transientProperties.view[vid][key] = new Function(paramStr, str);\n      } catch (e) {\n        console.error('error measurable parse ' + key, {\n          vid,\n          e,\n          paramStr,\n          body: str\n        });\n        transientProperties.view[vid][key] = undefined;\n        // display error in jsx\n        transientProperties.view[vid].JSXFunction = context => GraphElementComponent.displayError(e, 'Measurable ' + key + ' Syntax', dv);\n        break;\n      }\n    }\n    ret['VIEWS_RECOMPILE_' + key] = [];\n  }\n  for (let dataid in ret.ClassNameChanged) {\n    if (dataid === 'clonedCounter') continue;\n    // NB: if i ever want to access a constructor's other properties in ocl, like \"context Persona inv: self.$somecounter === Persona.instances.length\",\n    // i would need to update this every time a DClass property changes instead of only when name changes.\n\n    // if it's first creation of a modelpiece\n    if (!transientProperties.modelElement[dataid]) {\n      // transientProperties.modelElement[dataid] = {nodes: {}};\n    }\n    // update ocl type names\n    let data = ret.idlookup[dataid];\n    RuntimeAccessibleClass.makeOCLConstructor(data, ret, oldState);\n    // here i should reset all tnv.oclEngine too and set all ocl scores to notevaluated, but it is too computationally heavy\n    // and it's useful to keep the old ocl condition valid with past names until manually edited.\n  }\n  ret.ClassNameChanged = {};\n  return ret;\n}\nconst mergeTolerance = 300;\nexport function _reducer /*<S extends StateNoFunc, A extends Action>*/() {\n  var _action$type;\n  let oldState = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : initialState;\n  let action = arguments.length > 1 ? arguments[1] : undefined;\n  let times;\n  let state;\n  let removedDeltas = [];\n  switch (action.type) {\n    case UndoAction.type:\n      times = action.value;\n      state = oldState;\n      Log.exDev(times <= 0, \"undo must be positive\", action);\n      // if (desc) { ret.action_title = desc.desc + ': ' + desc.oldval + ' -> ' + desc.newval; ...}\n      //state.action_title = 'undone ' + times + ' steps';\n      //state.action_description = 'undone ' + times + ' steps';\n\n      while (times--) {\n        let forUser = action.forUser;\n        const delta = statehistory[forUser].undoable.pop();\n        for (let user in statehistory) {\n          var _statehistory$user;\n          U.arrayRemoveAll((_statehistory$user = statehistory[user]) === null || _statehistory$user === void 0 ? void 0 : _statehistory$user.undoable, delta);\n        }\n        if (!delta) continue;\n        removedDeltas.push(delta);\n        state = undo(state, action, delta, true);\n      }\n      state.action_title = 'undone ' + times + ' steps' + (state.action_title ? ': ' + state.action_title : '.');\n      state.action_description = 'undone ' + times + ' steps' + (state.action_description ? ': ' + state.action_description : '.');\n      state.VIEWS_RECOMPILE_all = [...new Set(removedDeltas.flatMap(d => Object.keys((d === null || d === void 0 ? void 0 : d.idlookup) || {})))];\n      // state.VIEWS_RECOMPILE_all = true;\n      return state;\n    case RedoAction.type:\n      times = action.value;\n      state = oldState;\n      Log.exDev(times <= 0, \"redo must be positive\", action);\n      // if (desc) { ret.action_title = desc.desc + ': ' + desc.oldval + ' -> ' + desc.newval; ...}\n      // state.action_title = 'redone ' + times + ' steps';\n      // state.action_description =  'redone ' + times + ' steps';\n      while (times--) {\n        let forUser = action.forUser;\n        const delta = statehistory[forUser].redoable.pop();\n        for (let user in statehistory) {\n          var _statehistory$user2;\n          U.arrayRemoveAll((_statehistory$user2 = statehistory[user]) === null || _statehistory$user2 === void 0 ? void 0 : _statehistory$user2.redoable, delta);\n        }\n        if (!delta) continue;\n        removedDeltas.push(delta);\n        state = undo(state, action, delta, false);\n      }\n      state.action_title = 'redone ' + times + ' steps' + (state.action_title ? ': ' + state.action_title : '.');\n      state.action_description = 'redone ' + times + ' steps' + (state.action_description ? ': ' + state.action_description : '.');\n      state.VIEWS_RECOMPILE_all = [...new Set(removedDeltas.flatMap(d => Object.keys((d === null || d === void 0 ? void 0 : d.idlookup) || {})))];\n      // state.VIEWS_RECOMPILE_all = true;\n      return state;\n    // case CombineHistoryAction.type: return combineHistory(oldState); break;\n    // todo: se al posto di \"annullare l'undo\" memorizzo l'azione e la rieseguo, posso ripetere l'ultimo passo N volte e questa azione diventa utile per combinare passi e ripetere blocchi di azioni assieme\n    default:\n      if (((_action$type = action.type) === null || _action$type === void 0 ? void 0 : _action$type.indexOf('@@redux/')) === 0) {\n        console.error('redux init', {\n          action,\n          oldState,\n          initialState\n        });\n        return oldState;\n      }\n      if (!(action === null || action === void 0 ? void 0 : action.className)) {\n        Log.exDevv('unexpected action type:', action.type);\n        return oldState;\n      }\n      let ret = doreducer(oldState, action);\n      if (ret === oldState) return ret;\n      ret.timestamp = Date.now();\n      console.log('00 UNset action descriptor in state', {\n        action\n      });\n      ret.action_title = '';\n      ret.action_description = '';\n      // undo-redo description\n      if (action.className === 'CompositeAction') {\n        let desc = action.descriptor;\n        if (desc) {\n          console.log('set action descriptor in state', {\n            desc,\n            action,\n            t: desc.path,\n            oldt: ret.action_title\n          });\n          ret.action_title = desc.path || '';\n          let valchange;\n          if (desc.oldval !== undefined && desc.newval !== undefined) valchange = ': ' + desc.oldval + ' -> ' + desc.newval;else if (desc.oldval === undefined && desc.newval !== undefined) valchange = ': ' + desc.newval;else valchange = '';\n          ret.action_description = (desc.desc || '') + valchange;\n        } else {\n          console.log('11 UNset action descriptor in state', {\n            action\n          });\n          ret.action_title = '';\n          ret.action_description = '';\n        }\n      }\n      if (!oldState /* || !Object.keys(delta).length*/) return ret;\n\n      // update state history\n      let delta = Uobj.objectDelta(ret, oldState, true, false);\n      let debug = Uobj.applyObjectDelta(ret, delta, false, oldState);\n      delta.timestamp = ret.timestamp;\n      delta.timestampdiff = ret.timestampdiff = ret.timestamp - ((oldState === null || oldState === void 0 ? void 0 : oldState.timestamp) || 0);\n      let pastDelta = statehistory.all.undoable[statehistory.all.undoable.length - 1];\n      const allowMerge = true; // switch for debugging\n      let isRelevantChange = isRelevantChangeCheck(delta, pastDelta);\n      // merge if: there is a past delta, and the delta doesn't pass the filter to exist individually\n      let shouldMerge = !isRelevantChange;\n      let debugMerge = true;\n      if (!shouldMerge && (delta.vertexs || delta.graphvertexs || delta.graphelements || delta.edgepoints || delta.edges || delta.graphs)) shouldMerge = true;\n      if (!pastDelta) shouldMerge = false;\n      if (pastDelta) console.log(\"merge deltas\", {\n        forVertex: delta.vertexs || delta.graphvertexs || delta.graphelements || delta.edgepoints || delta.edges || delta.graphs,\n        isRelevantChange,\n        shouldMerge,\n        irl: pastDelta && delta.timestamp - pastDelta.timestamp < mergeTolerance,\n        mergeTolerance,\n        dt: delta.timestamp,\n        pdt: pastDelta.timestamp,\n        diff: delta.timestamp - pastDelta.timestamp,\n        oldState,\n        delta\n      });\n      //todo: for cooperative prevent merge from different authors, store user in delta from action.sender when you set timestamp.\n      if (shouldMerge && allowMerge) {\n        // pastDelta = Uobj.applyObjectDelta(pastDelta, delta); no because special handling\n        //   of __jjisEmpty etc must not be done at this stage.\n        let gdelta = {};\n        let allkeys = new Set([...Object.keys(delta), ...Object.keys(pastDelta)]);\n        let mergeRecompileArr = k => {\n          var _delta;\n          if (!(k.indexOf('RECOMPILE') >= 0 || k.indexOf('ELEMENT_') >= 0 || k === 'ClassNameChanged')) return;\n          if (k === 'ClassNameChanged') {\n            let merged = {};\n            for (let p of allkeys) {\n              let vnow = delta[k][p];\n              let vpast = pastDelta[k][p];\n              if (vnow === vpast) {\n                merged[p] = vnow;\n                continue;\n              }\n              if (vnow.indexOf('__jjObjDiff') !== -1) {\n                merged[p] = vpast;\n                continue;\n              }\n              merged[p] = vnow;\n            }\n            gdelta.ClassNameChanged = merged;\n            return;\n          }\n          // todo: this is troublesome because ['id1', 'empty'] + ['id2'] =  ['id1', 'empty', 'id2'] but should not have side effects? can the empty sparse arr make problems?\n          if (!Array.isArray(delta[k] || [])) console.error('mergerecompilearr err', {\n            sm: shouldMerge,\n            pd: !!pastDelta,\n            delta,\n            pastDelta,\n            k,\n            dk: (_delta = delta) === null || _delta === void 0 ? void 0 : _delta[k],\n            pdk: pastDelta === null || pastDelta === void 0 ? void 0 : pastDelta[k]\n          });\n          if (!Array.isArray(delta[k] || [])) console.log('err in delta merge', {\n            arr: delta[k] || [],\n            delta,\n            k\n          });\n          if (!Array.isArray(pastDelta[k] || [])) console.log('err in past delta merge', {\n            arr: pastDelta[k] || [],\n            pastDelta,\n            k\n          });\n          // todo: reenable fix past line but remember they can be either true arrays or delta object fake arrays __jjObjDiffIsArr = true\n          // gdelta[k] = [...new Set(U.arrayMergeInPlace((delta as GObject)[k]||[], pastDelta[k]||[]))] as string[];\n        };\n        for (let k of allkeys) mergeRecompileArr(k);\n        U.objectMergeInPlace(pastDelta, delta);\n        delta = pastDelta; // must be inaccessible now as it merged with pastdelta, use that instead\n        for (let k in gdelta) {\n          if (Array.isArray(gdelta[k])) pastDelta[k] = gdelta[k].filter(e => e && e.indexOf('__jjObjDiff') === -1);else pastDelta[k] = gdelta[k];\n        }\n        if (debugMerge) ret.mergeCounter = pastDelta.mergeCounter = 1 + (ret.mergeCounter || 0);\n      } else if (isRelevantChange) {\n        let user = action.sender;\n        statehistory[user].undoable.push(delta);\n        statehistory.all.undoable.push(delta);\n        if (debugMerge) {\n          if (shouldMerge) ret.notMergeCounter = delta.notMergeCounter = 1 + (ret.notMergeCounter || 0);else ret.notMergeCounter = 0;\n        }\n      }\n      return ret;\n  }\n}\nfunction isRelevantChangeCheck(delta, pastDelta) {\n  if (pastDelta && delta.timestamp - pastDelta.timestamp < mergeTolerance) return false;\n  if (!statehistory.globalcanundostate) return false;\n  if (Object.keys(delta).length === 1) {\n    if (\"dragging\" in delta) return false;\n    if (\"_lastSelected\" in delta) return false;\n    if (\"contextMenu\" in delta) return false;\n  }\n  return true;\n}\nfunction undo(state, action, delta) {\n  let isundo = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n  if (!delta) return state;\n  //let undonestate: DState = {...state} as DState;\n  //   controlla se vengono shallow-copied solo e tutti gli oggetti nested lungo la catena del percorso delle modifiche\n  //   es: root.a.b.c=3 + root.a.b.d=3 = 4+1 modifiche, 5 shallow copies including the root\n  //undorecursive(delta, undonestate);\n\n  let undonestate = Uobj.applyObjectDelta(state, delta, false);\n  // todo: check if delta2 === delta or is his opposite in values but same shape\n  let delta2 = Uobj.objectDelta(undonestate, state);\n  let debug = Uobj.applyObjectDelta(undonestate, delta2, false, state);\n  let forUser = action.forUser;\n  let user = action.sender;\n  // reverses from undo to redo and viceversa swapping arguments, so the target result after appliying the delta changes\n  // redo is \"undoing an undo\", reversing his changes just like an undo reverses an ordinary action changes.\n  let key = isundo ? 'redoable' : 'undoable';\n  statehistory[user][key].push(delta2);\n  statehistory.all[key].push(delta2);\n  return undonestate;\n}\n/*\r\nfunction undorecursive(deltalevel: GObject, statelevel: GObject): void {\r\n    // statelevel = {...statelevel}; not working if i do it here, just a new var. first time copy id done in caller func undo(). recursive copies are done before recursive step\r\n    for (let key in deltalevel) {\r\n        let delta = deltalevel[key];\r\n        console.log(\"undoing\", {delta, key, deltalevel, statelevel})\r\n        //if (key.indexOf(\"_-\") === 0) { delete statelevel[key.substring(2)]; continue; }\r\n        if (typeof delta === \"object\") {\r\n        // if (U.isObject(delta, false, false, true)) {\r\n            if (Array.isArray(delta)) statelevel[key] = [...statelevel[key]];\r\n            else statelevel[key] = {...statelevel[key]};\r\n            undorecursive(deltalevel[key], statelevel[key]); }\r\n        else { statelevel[key] = delta; }\r\n    }\r\n}*/\n\nfunction doreducer /*<S extends StateNoFunc, A extends Action>*/() {\n  let oldState = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : initialState;\n  let action = arguments.length > 1 ? arguments[1] : undefined;\n  let ca;\n  switch (action.type) {\n    case CompositeAction.type:\n      ca = action;\n      break;\n    case LoadAction.type:\n    default:\n      /*\r\n      if (action.type.indexOf('@@redux/') === 0) { handled on upper levels\r\n      //storeLoaded = true;\r\n      return oldState;\r\n      }*/\n      ca = new CompositeAction([action], false);\n      break;\n  }\n  let ret = CompositeActionReducer(oldState, ca);\n  /*if (state.current !== ret) {\r\n      state.current = ret;\r\n      state.past.push(ret);\r\n  }*/\n  return ret;\n}\nfunction setSubclasses(roots) {\n  RuntimeAccessibleClass.extendMatrix = new SimpleTree(roots, \"subclasses\").getiIsSubElementMatrix(\"cname\");\n  /*\r\n  let tree = new TreeModel({\r\n      childrenPropertyName: \"subclasses\"\r\n  });\r\n  for (let key in dict){\r\n      let constructor = dict[key];\r\n      if(!constructor.hasOwnProperty(\"subclasses\")) constructor.subclasses = [];\r\n  }\r\n  RuntimeAccessibleClass.extendTree = (tree as any).safe_parse(RuntimeAccessibleClass);*/\n}\n// windoww.TreeModel = TreeModel;\nfunction buildLSingletons(alld, alll) {\n  for (let dname in alld) {\n    switch (dname) {\n      case \"DeleteElementAction\":\n        continue;\n      case \"DV\":\n        continue;\n      case \"Debug\":\n        continue;\n      default:\n        break;\n    }\n    if ((dname[1] || \"\").toLowerCase() === dname[1]) continue; // if second letter is lowercase, it's not a \"D\" class\n    let tagless = dname.substring(1);\n    let d = alld[dname];\n    let l = alll['L' + tagless];\n    if (!d || !l) console.error(\"missing d constructor\", {\n      d,\n      l\n    });\n    d.logic = l;\n    if (!l) console.error('init() could not find L-class during mapping', l, d);\n    // @ts-ignore\n    d.singleton = new l('dwc');\n    d.structure = d;\n    l.logic = d.logic;\n    l.singleton = d.singleton;\n    l.structure = d.structure;\n\n    // if (!d.subclasses) d.subclasses = [];\n    // @ts-ignore\n    // for (let sc of d.subclasses) { if (!sc[\"_extends\"]) sc[\"_extends\"] = [];  sc[\"_extends\"].push(d); }\n  }\n}\nfunction setDocumentEvents() {\n  // do not use typings or class constructors here or it will change import order\n  setTimeout(() => $(document).on(\"mouseup\", e => {\n    statehistory.globalcanundostate = true;\n    RuntimeAccessibleClass.get(\"GraphDragManager\").stopPanning(e);\n  }), 1);\n  // document.body.addEventListener(\"mousedown\", fixResizables, false);\n  setInterval(() => {\n    END();\n    BEGIN();\n  }, 300);\n}\nfunction fixResizables(e) {\n  /*let parents = U.ancestorArray(e.target as HTMLElement);\r\n  for (let e of parents){\r\n      if (e.classList.contains(\"draggable\")) U.makeDraggable(e, e.dataset.draggableOptions, e.attributes.disabled);\r\n      if (e.classList.contains(\"resizable\")) U.makeResizable(e, e.dataset.draggableOptions);\r\n      if (e.classList.contains(\"resizable\")) U.makeRotatable(e, e.dataset.draggableOptions);\r\n  }*/\n}\nexport async function stateInitializer() {\n  console.trace('stateinitializer');\n  RuntimeAccessibleClass.fixStatics();\n  let dClassesMap = {};\n  let lClassesMap = {};\n  for (let name in RuntimeAccessibleClass.classes) {\n    switch (name[0]) {\n      case 'D':\n        dClassesMap[name] = RuntimeAccessibleClass.classes[name];\n        break;\n      case 'L':\n        lClassesMap[name] = RuntimeAccessibleClass.classes[name];\n        break;\n      default:\n        break;\n    }\n  }\n  buildLSingletons(dClassesMap, lClassesMap);\n  setSubclasses(RuntimeAccessibleClass.get('DPointerTargetable'));\n  windoww.defaultContext = {\n    $: windoww.$,\n    getPath,\n    React: React,\n    Selectors,\n    ...RuntimeAccessibleClass.getAllClassesDictionary(),\n    ...windoww.Components\n  };\n  DState.init();\n  await DUser.loadOffline(); // if it's online mode this is a no-op and user should be already loaded\n  console.log('FIRING action pre');\n  await ProjectsApi.getAll();\n  console.log('FIRING action post');\n  //await ProjectsApi.getAll();\n  setDocumentEvents();\n  /*type RecentEntry = {id: Pointer<DProject>[], name: string};\r\n  let recent: RecentEntry[] = JSON.parse(localStorage.getItem('_jjRecent') || '[]') as any[];\r\n  if (window.location.hash.indexOf('#/project') === 0) {\r\n      let user: LUser = LPointerTargetable.from(DUser.current);\r\n      let project = user?.projects.filter(p=>!!p)[0]?.__raw as any;\r\n      //console.log('test recents', {project, user, recent});\r\n      let current: RecentEntry = {name: project.name, id:project.id};\r\n      // the filter looks if the current project was already in recent list, and prevents duplicates\r\n      recent = recent.filter(p=> p.id !== current.id);\r\n      recent.push(current);\r\n      localStorage.setItem('_jjRecent', JSON.stringify(recent));\r\n  }*/\n}\nvar _c;\n$RefreshReg$(_c, \"CompositeActionReducer\");","map":{"version":3,"names":["DViewElement","UX","GraphElementComponent","ViewEClassMatch","NodeTransientProperties","ViewTransientProperties","Uobj","Action","CompositeAction","CreateElementAction","DeleteElementAction","DPointerTargetable","DState","DUser","getPath","Log","MyError","PendingPointedByPaths","PointedBy","Pointers","RuntimeAccessibleClass","SetFieldAction","SetRootFieldAction","statehistory","React","BEGIN","END","LoadAction","RedoAction","UndoAction","Collaborative","SimpleTree","transientProperties","Selectors","contextFixedKeys","ProjectsApi","DSL","windoww","window","U","deepCopyButOnlyFollowingPath","oldStateDoNotModify","action","prevAction","newVal","_action$path","newRoot","current","path","length","gotChanged","alreadyPastDivergencePoint","i","pathArray","key","trim","prevActionPathKey","Array","isArray","clonedCounter","isArrayAppend","isArrayRemove","isObjectMerge","isObjectDifference","oldValue","endsWith","substr","replaceAll","type","ee","preexistingValue","isShallowEqual","value","tmp","subkey","isPointer","add","push","index","isNumber","undefined","indexOf","removedval","splice","remove","oldpointerdestinations","newpointerdestinations","difference","arrayDifference","rem","removed","added","exDevv","CompositeActionReducer","oldState","actionBatch","actions","parse","all","getSolveableActions","possibleInconsistencies","derivedActions","newState","elem","pendingCreation","id","className","constructor","cname","name","statefoldername","substring","toLowerCase","create","pointedBy","new","arrayMergeInPlace","sort","a1","a2","stringCompare","actiontype","console","log","a","t","field","v","updateRedundancies_OBSOLETE","_c","state","subType","SubType","vertexSubElements","initialState","storeLoaded","UDRegexp","reducer","arguments","jjactions","unsafereducer","e","error","_oldState","_ret$VIEWS_RECOMPILE_","_ret$VIEWS_RECOMPILE_2","_ret$VIEWS_RECOMPILE_3","_ret$VIEWS_RECOMPILE_4","_ret$VIEWS_RECOMPILE_5","ret","_reducer","idlookup","__proto__","collaborativeSession","ignoredFields","compositeAction","subActions","filter","includes","sender","parsedAction","JSON","stringify","client","emit","filterSet","r","Set","ptr","ELEMENT_CREATED","d","nid","node","tn","viewScores","ELEMENT_DELETED","needSorting","VIEWS_RECOMPILE_all","Object","keys","resetAllNodes","sk","extends","css_MUST_RECOMPILE","view","_oldState$idlookup$d$","_ret$idlookup$d$id","oldname","newname","ClassNameChanged","warn","parseLabel","isNode","_mainView","dv","fromPointer","tp","val","allContextKeys","vid","mainView","tv","k","constantsList","UDList","paramStr","join","ud","c","body","arr","NODES_RECOMPILE_labels","successfullyParsed","NODES_RECOMPILE_longestLabel","VIEWS_RECOMPILE_labels","VIEWS_RECOMPILE_longestLabel","VIEWS_RECOMPILE_ocl","oclEngine","oclChanged","tnv","OCLScore","NOT_EVALUATED_YET","VIEWS_RECOMPILE_preconditions","metaclassScore","VIEWS_RECOMPILE_constants","constants","constantsOutput","context","constantsFunction","Function","bind","VIEWS_RECOMPILE_jsCondition","VIEWS_RECOMPILE_usageDeclarations","VIEWS_RECOMPILE_jsxString","VIEWS_RECOMPILE_events","MeasurableKeys","_dv$usageDeclarations","usageDeclarations","UDFunction","matches","match","map","s","udstr","udlist","udErrors","maxi","isSyntax","errbody","entry","events","message","split","jsConditionChanged","jsCondition","lines","lastLine","jsxString","JSXFunction","parseAndInject","parser","displayError","_ref","str","dataid","modelElement","data","makeOCLConstructor","mergeTolerance","_action$type","times","removedDeltas","exDev","forUser","delta","undoable","pop","user","_statehistory$user","arrayRemoveAll","undo","action_title","action_description","flatMap","redoable","_statehistory$user2","doreducer","timestamp","Date","now","desc","descriptor","oldt","valchange","oldval","newval","objectDelta","debug","applyObjectDelta","timestampdiff","pastDelta","allowMerge","isRelevantChange","isRelevantChangeCheck","shouldMerge","debugMerge","vertexs","graphvertexs","graphelements","edgepoints","edges","graphs","forVertex","irl","dt","pdt","diff","gdelta","allkeys","mergeRecompileArr","_delta","merged","p","vnow","vpast","sm","pd","dk","pdk","objectMergeInPlace","mergeCounter","notMergeCounter","globalcanundostate","isundo","undonestate","delta2","ca","setSubclasses","roots","extendMatrix","getiIsSubElementMatrix","buildLSingletons","alld","alll","dname","tagless","l","logic","singleton","structure","setDocumentEvents","setTimeout","$","document","on","get","stopPanning","setInterval","fixResizables","stateInitializer","trace","fixStatics","dClassesMap","lClassesMap","classes","defaultContext","getAllClassesDictionary","Components","init","loadOffline","getAll","$RefreshReg$"],"sources":["C:/0Programmi/Dev/projects/frontend/jjodel/frontend/src/redux/reducer/reducer.ts"],"sourcesContent":["import {\r\n    U as UType,\r\n    GraphDragManager,\r\n    MouseUpEvent,\r\n    orArr,\r\n    DModelElement,\r\n    DViewElement,\r\n    DClass,\r\n    DModel,\r\n    UX,\r\n    EdgeOwnProps,\r\n    EdgeStateProps,\r\n    GraphElementComponent,\r\n    ViewEClassMatch,\r\n    bool,\r\n    NodeTransientProperties,\r\n    ViewTransientProperties,\r\n    DGraphElement, Uarr, Uobj, LocalStorage, DProject, LUser\r\n} from '../../joiner';\r\nimport {\r\n    Action,\r\n    CompositeAction,\r\n    CreateElementAction,\r\n    DeleteElementAction,\r\n    Dictionary,\r\n    DocString,\r\n    DPointerTargetable,\r\n    DState,\r\n    DUser,\r\n    getPath,\r\n    GObject,\r\n    Log,\r\n    LPointerTargetable,\r\n    MyError,\r\n    ParsedAction,\r\n    PendingPointedByPaths,\r\n    PointedBy,\r\n    Pointer,\r\n    Pointers,\r\n    RuntimeAccessibleClass,\r\n    SetFieldAction,\r\n    SetRootFieldAction,\r\n    statehistory\r\n} from \"../../joiner\";\r\nimport React from \"react\";\r\nimport {BEGIN, COMMIT, END, LoadAction, RedoAction, UndoAction} from \"../action/action\";\r\nimport Collaborative from \"../../components/collaborative/Collaborative\";\r\nimport {SimpleTree} from \"../../common/SimpleTree\";\r\nimport {transientProperties, Selectors} from \"../../joiner\";\r\nimport {OclEngine} from \"@stekoe/ocl.js\";\r\nimport { contextFixedKeys } from '../../graph/graphElement/sharedTypes/sharedTypes';\r\nimport Storage from \"../../data/storage\";\r\nimport {ProjectsApi} from \"../../api/persistance\";\r\nimport DSL from \"../../DSL/DSL\";\r\n\r\nlet windoww = window as any;\r\nlet U: typeof UType = windoww.U;\r\n\r\n\r\nfunction deepCopyButOnlyFollowingPath(oldStateDoNotModify: DState, action: ParsedAction, prevAction: ParsedAction, newVal: any): DState | false{\r\n    let newRoot: DState = {...oldStateDoNotModify} as DState;\r\n    let current: any = newRoot;\r\n    if (!action.path?.length) throw new MyError(\"path length must be at least 1\", {action});\r\n    let gotChanged: boolean = false; // dovrebbe cambiare sempre, se non cambia non lancio neanche l'azione e non faccio la shallow copy, ma non si sa mai, così posso evitare un render se succede l' \"insuccedibile\"\r\n    let alreadyPastDivergencePoint = false; // true dal momento in cui il path dell'azione attuale e della azione precedente divergono, false fino al sotto-segmento in cui combaciano\r\n    // console.log('deepCopyButOnlyFollowingPath', arguments);\r\n    for (let i = 0; i < action.pathArray.length; i++) {\r\n        let key = action.pathArray[i].trim();\r\n        let prevActionPathKey = prevAction?.pathArray[i];\r\n        // middle execution: not on final loop\r\n        // console.log('deepCopyButOnlyFollowingPath', {current, i, imax:action.pathArray.length, key, gotChanged, alreadyPastDivergencePoint});\r\n        if (i !== action.pathArray.length - 1) {\r\n            if (alreadyPastDivergencePoint || key !== prevActionPathKey) {\r\n                // se l'oggetto è stato già duplicato in una azione composita, non lo duplico 2 volte.\r\n                alreadyPastDivergencePoint = true;\r\n                current[key] = Array.isArray(current[key]) ? [...current[key]] : {...current[key]};\r\n                current[key].clonedCounter = 1 + (current[key].clonedCounter || 0);\r\n            }\r\n            current = current[key];\r\n            continue;\r\n        }\r\n        // Giordano: added this on 03/12/2023 to prevent \"Cannot read properties of undefined\".\r\n        // if(!current) continue; damiano: temp removed to check if there are invalid actions firing\r\n        // perform final assignment\r\n        if (i >= action.pathArray.length - 1) {\r\n            let isArrayAppend = false;\r\n            let isArrayRemove = false;\r\n            let isObjectMerge = false;\r\n            let isObjectDifference = false;\r\n            // console.log('isarrayappend?', {endswith: U.endsWith(key, ['+=', '[]', '-1']), key, action, i});\r\n            // console.log('isarraydelete?', {endswith: U.endsWith(key, ['-='])});\r\n\r\n            let oldValue: any;\r\n            if (U.endsWith(key, ['+=', '[]'])) {\r\n                key = key.substr(0, key.length - 2).trim();\r\n                oldValue = current[key];\r\n                switch (typeof oldValue){\r\n                    case 'object':\r\n                    if (Array.isArray(oldValue)) isArrayAppend = true;\r\n                    else isObjectMerge = true;\r\n                    break;\r\n                    default: newVal += oldValue; break;\r\n                }\r\n            }\r\n            if (U.endsWith(key, ['-='])) {\r\n                key = key.substr(0, key.length - 2).trim();\r\n                oldValue = current[key];\r\n                switch (typeof oldValue){\r\n                    case 'object':\r\n                        if (Array.isArray(oldValue)) isArrayRemove = true;\r\n                        else isObjectDifference = true;\r\n                        break;\r\n                    case \"string\":\r\n                        newVal = U.replaceAll(oldValue, newVal, '');\r\n                        break;\r\n                    case 'number': newVal = oldValue - newVal; break;\r\n                    default: isArrayRemove = true; break;\r\n                }\r\n                // isArrayRemove = true;\r\n            }\r\n\r\n            // let unpointedElement: DPointerTargetable | undefined;\r\n            // perform final assignment\r\n            if (action.type === CreateElementAction.type && current[key]) {\r\n                oldValue = current[key];\r\n                gotChanged = false;\r\n                Log.ee(\"rejected CreateElementAction, rollback occurring:\", {action,\r\n                    preexistingValue: current[key], isShallowEqual: current[key] === action.value });\r\n                return false; // warning: use return only when you want to abort and skip subsequent CompositeAction sub-actions like now.\r\n            }\r\n            if (isObjectMerge) {\r\n                if (typeof newVal === 'string') { let tmp: any = {}; tmp[newVal] = true; newVal = tmp; }\r\n                oldValue = {...current[key]};\r\n                current[key] = {...current[key]};\r\n                for (let subkey in newVal) {\r\n                    // console.warn(\"object merge\", {current, key, subkey, newVal, old:current[key][subkey], new:newVal[subkey]});\r\n                    if (current[key][subkey] === newVal[subkey]) continue;\r\n                    current[key][subkey] = newVal[subkey];\r\n                    gotChanged = true;\r\n                    if (action.isPointer) { newRoot = PointedBy.add(key as Pointer, action, newRoot, \"+=\"); }\r\n                }\r\n            } else\r\n            if (isObjectDifference) {\r\n                if (typeof newVal === 'string') { let tmp: any = {}; tmp[newVal] = true; newVal = tmp; }\r\n                oldValue = {...current[key]};\r\n                current[key] = {...current[key]};\r\n                for (let subkey in newVal) {\r\n                    if (!(subkey in current[key])) continue;\r\n                    delete current[key][subkey];\r\n                    gotChanged = true;\r\n                    if (action.isPointer) { newRoot = PointedBy.add(key as Pointer, action, newRoot, \"-=\"); }\r\n                }\r\n            } else\r\n            if (isArrayAppend) {\r\n                gotChanged = true;\r\n                if (!Array.isArray(current[key])) { current[key] = []; }\r\n                oldValue = [...current[key]];\r\n                current[key] = [...current[key]];\r\n                current[key].push(newVal);\r\n                // unpointedElement = undefined;\r\n                if (action.isPointer) { newRoot = PointedBy.add(newVal as Pointer, action, newRoot, \"+=\"); }\r\n            } else\r\n            if (isArrayRemove) {\r\n                if (!Array.isArray(current[key])) { current[key] = []; }\r\n                oldValue = [...current[key]];\r\n                let index: number;\r\n                if (U.isNumber(newVal)) { // delete by index\r\n                    index = newVal;\r\n                    if (index < 0) index = oldValue.length + index; // if index is -2, i remove the penultimate element\r\n                } else\r\n                if (newVal === undefined) {\r\n                    index = oldValue.length - 1;\r\n                }\r\n                else {\r\n                    index = oldValue.indexOf(newVal);\r\n                }\r\n                // if it's negatively or positively out of boundary, i skip it\r\n                gotChanged = index >= 0 && index < current[key].length;\r\n                if (gotChanged) {\r\n                    current[key] = [...current[key]];\r\n                    let removedval = current[key].splice(index, 1); // in-place edit\r\n                    if (action.isPointer) { newRoot = PointedBy.remove(removedval as Pointer, action, newRoot, '-='); }\r\n                    /*\r\n                    fixed problem: se ho [dobj1, dobj2]... e li swappo, cambia un indice nel percorso \"pointedby\" e non me ne accorgo mai e un oggetto risulta \"pointedby\" da oggetti che non lo puntano o non esistono più a quell'indice\r\n                    SOLVED! by not including index in pointedBy path, but making it like \"parentObject.arrayKey+=\" instead of \"parentObject.arrayKey.4\"\r\n                    and knowing it's in the array it's enough info.\r\n\r\n                    // a.pointsto = [x, y, z]; a.pointsto = [x, z]       --->    remove a from y.pointedby\r\n                    const elementsThatChangedIndex: DPointerTargetable[] = current[key].slice(index);\r\n\r\n                    for (let j = 0; j < elementsThatChangedIndex.length; j++) {\r\n                        let newindex = index + j - 1;\r\n                        let oldFullpathTrimmed = action.pathArray.join('.');\r\n                        se realizzi \"pointedby\" qui è to do: remove old paths and re-add them with updated index\r\n                    }\r\n                    unpointedElement = newRoot.idlookup[oldValue];\r\n                    */\r\n                }\r\n            } else\r\n            if ((action.type === DeleteElementAction.type && !(key in current)) || current[key] === newVal) {\r\n                // value not changed\r\n                gotChanged = false;\r\n            } else {\r\n                // value changed\r\n                // todo: caso in cui setto manualmente classes.1 = pointer;\r\n                //  the latest element is array and not DPointerTargetable, so might need to buffer upper level in the tree? or instead of \"current\" keep an array of sub-objects encountered navigating the path in state.\r\n                oldValue = current[key];\r\n                gotChanged = true;\r\n                // unpointedElement = newRoot.idlookup[oldValue];\r\n                // NB: se elimino un oggetto che contiene array di puntatori, o resetto l'array di puntatori kinda like store.arr= [ptr1, ptr2, ...]; store.arr = [];\r\n                // i puntati dall'array hanno i loro pointedBY non aggiornati, non voglio fare un deep check di tutto l'oggetto a cercare puntatori per efficienza.\r\n                // if (newVal === undefined) delete current[key];\r\n                if ((newVal === undefined) || false && action.type === DeleteElementAction.type) delete current[key];\r\n                else current[key] = newVal;\r\n\r\n                // update pointedBy's\r\n                // NB: even if the current action have isPointer=true, it doesn't mean the old value is a pointer as well for sure. so need to check old values.\r\n                // also what if old val is pointer, and new one isn't? will it be just removed without updating pointedBy's?\r\n                // already fixed: might need to evaluate this if block always regardless of action.isPointer,\r\n                // and do checks every time both on old and new value if they actually are ptrs.\r\n                if (true || action.isPointer) {\r\n                    let oldpointerdestinations: unknown[];\r\n                    let newpointerdestinations: unknown[];\r\n                    if (Array.isArray(newVal)) {\r\n                        newpointerdestinations = newVal;\r\n                        if (Array.isArray(oldValue)) { // case: path.array = array;\r\n                            oldpointerdestinations = oldValue;\r\n                        }\r\n                        else { // case: path.object = array; + case: path.value = array;\r\n                            oldpointerdestinations = [oldValue];\r\n                        }\r\n                    }\r\n                    else {\r\n                        // case: path.array = object; + case: path.array = value;\r\n                        newpointerdestinations = [newVal];\r\n                        if (Array.isArray(oldValue)) {\r\n                            oldpointerdestinations = oldValue;\r\n                        } else {\r\n                            // case: path.object = object; and all other cases without arrays involved\r\n                            oldpointerdestinations = [oldValue];\r\n                        }\r\n                    }\r\n                    // after i mapped all cases to path.array = array; i solve it for that case.\r\n                    let difference = U.arrayDifference(oldpointerdestinations, newpointerdestinations); // : {added: Pointer[], removed: Pointer[], starting: Pointer[], final: Pointer[]}\r\n                    for (let rem of difference.removed) {if (Pointers.isPointer(rem))\r\n                        newRoot = PointedBy.remove(rem, action, newRoot, undefined, oldStateDoNotModify); }\r\n                    for (let add of difference.added) { if (Pointers.isPointer(add))\r\n                        newRoot = PointedBy.add(add, action, newRoot, undefined, oldStateDoNotModify); }\r\n                    // a.pointsto = [a, b, c];  a.pointsto = [a, b, x];    ------>     c.pointedby.remove(a) & x.pointedby.add(a)\r\n                    // idlookup.somelongid.pointsto = [...b];\r\n                }\r\n            }\r\n            break;\r\n        }\r\n        Log.exDevv('should not reach here: reducer');\r\n    }\r\n    return gotChanged ? newRoot : oldStateDoNotModify;\r\n}\r\n\r\n\r\n// const pendingPointedByPaths: {from: DocString<\"Path in store\">, field: DocString<\"keyof object found in from path\">, to: Pointer}[] = [];\r\nfunction CompositeActionReducer(oldState: DState, actionBatch: CompositeAction): DState {\r\n    // per via di thunk se arrivo qui lo stato cambia sicuro in mono-client non synchro (non ri-assegno valori equivalenti)\r\n    // todo: ma se arrivano in ordine sbagliato da altri client? posso permetterlo?\r\n    let actions: ParsedAction[];\r\n    if (actionBatch.actions) actions = Action.parse(actionBatch.actions);\r\n    else actions = [Action.parse(actionBatch)]; // else-case is if it's a single action and not an actual compositeaction\r\n    if (PendingPointedByPaths.all.length) actions.push(...PendingPointedByPaths.getSolveableActions(oldState)); //.all.map( p=> p.resolve() ) );\r\n\r\n    Action.possibleInconsistencies = {};\r\n\r\n    // estraggo le azioni derivate\r\n    let derivedActions: ParsedAction[] = [];\r\n    let newState = oldState;\r\n    for (let action of actions) {\r\n        switch (action.type){\r\n            default: break;\r\n            case CreateElementAction.type:\r\n                const elem: DPointerTargetable = action.value;\r\n                delete DPointerTargetable.pendingCreation[elem.id];\r\n                /*\r\n                if (oldState.idlookup[elem.id]) {\r\n                    Log.ee(\"rejected CreateElementAction, rollback occurring:\", {action, elem:{...elem},\r\n                        preexistingValue: {...oldState.idlookup[elem.id]}, isEqual: elem === oldState.idlookup[elem.id] });\r\n                    return oldState; // warning: use return only when you want to abort and skip subsequent CompositeAction sub-actions like now.\r\n\r\n                    action.value = \"An element with that id already existed.\";\r\n                    action.path = action.field = \"CreateActionRejected\";\r\n                    action.className = SetRootFieldAction.name;\r\n                    action.type = SetRootFieldAction.type;\r\n                    action.pathArray = [action.path]; //a\r\n                    action.isPointer = false;\r\n                    // just to log it in undo-redo action list and have a feedback\r\n                    return oldState;}*/\r\n\r\n                elem.className = elem.className || (elem.constructor as typeof RuntimeAccessibleClass).cname || elem.constructor.name;\r\n                let statefoldername = elem.className.substring(1).toLowerCase() + 's';\r\n                derivedActions.push(\r\n                    Action.parse(SetRootFieldAction.create(statefoldername, elem.id,'[]', true)));\r\n                if (!Array.isArray(elem.pointedBy)) elem.pointedBy = [];\r\n                elem.pointedBy.push(PointedBy.new(statefoldername));\r\n                /*if (false && action.isPointer) {\r\n                    if (Array.isArray(action.value)) {\r\n                        const ptr: Pointer[] = action.value;\r\n                        // todo but replaced by side actions in execution of the main action instead of triggering derived actions\r\n                    }\r\n                    else {\r\n                        const ptr: Pointer = action.value;\r\n                        const target: DPointerTargetable | null = oldState.idlookup[ptr];\r\n                        let pendingPointedBy = PendingPointedByPaths.new(action, oldState);\r\n                        if (!target) PendingPointedByPaths.new(action, oldState).saveForLater(); // {from: action.path, field: action.field, to: target});\r\n                        // @ts-ignore\r\n                        else derivedActions.push(pendingPointedBy.resolve());\r\n                        // a -> x\r\n                        // a -> y     unset x.pointedby(a)\r\n                    }\r\n                }*/\r\n                break;\r\n        }\r\n    }\r\n    // console.error({U, Umip:U.arrayMergeInPlace, WU: windoww.U, WUmip: windoww.U.arrayMergeInPlace});\r\n    actions = U.arrayMergeInPlace<ParsedAction>(actions, derivedActions);\r\n\r\n    // ordino i path con segmenti comuni\r\n    actions = actions.sort( (a1, a2) => U.stringCompare(a1.path, a2.path));\r\n\r\n    // destrutturo solo i nodi intermedi e solo la prima volta che li incontro (richiede le azioni ordinate in base al path)\r\n\r\n    for (let i = 0; i < actions.length; i++) {\r\n        const prevAction: ParsedAction = actions[i-1];\r\n        const action: ParsedAction = actions[i];\r\n        const actiontype = action.type.indexOf('@@') === 0 ? 'redux' : action.type;\r\n        console.log('executing action:', {a:action, t:actiontype, field: action.field, v:action.value}); //, count: ++action.executionCount});\r\n\r\n        switch (actiontype) {\r\n            /*\r\n            case '@@redux/INIT' + randomstr:... etc*/\r\n            default:\r\n                if (action.type.indexOf('@@redux/') === 0) break;\r\n                return Log.exDevv('unexpected action type:', action.type);\r\n            case LoadAction.type: newState = action.value; break;\r\n            case CreateElementAction.type:\r\n            case SetRootFieldAction.type:\r\n            case DeleteElementAction.type:\r\n            case SetFieldAction.type:\r\n                let tmp: false | DState = deepCopyButOnlyFollowingPath(newState, action, prevAction, action.value);\r\n                if (!tmp) return oldState; // rollback due to invalid action in transaction\r\n                newState = tmp;\r\n                break;\r\n        }\r\n\r\n        // and that's all, the reducer is really simple as actions are really simple.\r\n    }\r\n\r\n    // effetti collaterali, aggiornamento di ridondanze\r\n    newState = updateRedundancies_OBSOLETE(newState, oldState, Action.possibleInconsistencies);\r\n    return newState;\r\n}\r\n\r\nfunction updateRedundancies_OBSOLETE(state: DState, oldState:DState, possibleInconsistencies: Dictionary<DocString<'subtype'>, (Pointer | DPointerTargetable)[]>): DState {\r\n    for (let subType in possibleInconsistencies)\r\n    switch (subType) {\r\n        default: break;\r\n        case Action.SubType.vertexSubElements:/*\r\n            risolto triggrerando più azioni da LGraphElement setter\r\n            let dvertexid: Pointer, newdvertex: DGraphElement, olddvertex: DGraphElement;\r\n            for (newdvertex of possibleInconsistencies[subType] as DGraphElement[]){\r\n                const olddvertex: DGraphElement = oldState.idlookup[newdvertex.id] as DGraphElement;\r\n                const notContainedAnymoreOut: Pointer<DGraphElement> = [];\r\n                const newlyInsertedOut: Pointer<DGraphElement>[] = [];\r\n                U.arraySymmetricDifference(olddvertex.subElements, newdvertex.subElements, notContainedAnymoreOut, newlyInsertedOut);\r\n                for (let geid of notContainedAnymoreOut) {\r\n                    const oldge = oldState.idlookup[geid] as DGraphElement;\r\n                    const newge = state.idlookup[geid] as DGraphElement;\r\n                    if (oldge.containedIn === newge.containedIn) continue;\r\n                }\r\n                for (let geid of notContainedAnymoreOut) {\r\n                    const ge = idlookup[geid] as DGraphElement;\r\n                    if (ge.containedIn === context.data.id) set container = context.data.id\r\n                    meglio se sti 2 cicli li fai nel reducer perchè  potrebbe esserci una azione pending che setta il parent = someotherid e qui faccio partire una azione che setta il parent a null, \"annullando\" una azione pending non ancora eseguita\r\n                }\r\n            }\r\n            break;*/\r\n    }\r\n    // if state is updated shallow copy state before returning it\r\n    return state;\r\n}\r\n\r\nlet initialState: DState = null as any;\r\nlet storeLoaded: boolean = false;\r\n\r\nconst UDRegexp = /(?:^|\\s|;|}|\\n|\\t|\\(|,)ret\\s*\\.\\s*[a-zA-Z_$][0-9a-zA-Z_$]*\\s*=/g;\r\n/* tested with:\r\nif (ret.key = stuff) ret.key2=morestuff;\r\n;ret.k=3;\r\n}ret. kk=3,ret. a = 3\r\n\r\nret .b = 3\r\n*/\r\n\r\n\r\n// then add to it: content of props, constants, usageDeclarations\r\n\r\nexport function reducer(oldState: DState = initialState, action: Action): DState {\r\n    if (!windoww.actions) windoww.jjactions = [];\r\n    windoww.jjactions.push(action);\r\n    try{ return unsafereducer(oldState, action); }\r\n    catch(e) {\r\n        console.error('unhandled error in reducer', {e, oldState, action});\r\n        return oldState;\r\n    }\r\n}\r\n\r\nfunction unsafereducer(oldState: DState = initialState, action: Action): DState {\r\n    if (!oldState) { oldState = initialState = DState.new(); }\r\n    // console.log('external REDUCER', {action, CEtype:CreateElementAction.type});\r\n\r\n    const ret = _reducer(oldState, action);\r\n    if (ret === oldState) return oldState;\r\n    ret.idlookup.__proto__ = DPointerTargetable.pendingCreation as any;\r\n    // client synchronization stuff\r\n    if (oldState?.collaborativeSession) {\r\n        const ignoredFields: (keyof DState)[]  = [\r\n            'version',\r\n            'env',\r\n            'debug',\r\n            'isEdgePending',\r\n            'contextMenu',\r\n            '_lastSelected',\r\n            'isLoading',\r\n            'collaborativeSession',\r\n            'VIEWS_RECOMPILE_onDataUpdate',\r\n            'VIEWS_RECOMPILE_onDragStart',\r\n            'VIEWS_RECOMPILE_onDragEnd',\r\n            'VIEWS_RECOMPILE_whileDragging',\r\n            'VIEWS_RECOMPILE_onResizeStart',\r\n            'VIEWS_RECOMPILE_onResizeEnd',\r\n            'VIEWS_RECOMPILE_whileResizing',\r\n            'VIEWS_RECOMPILE_onRotationStart',\r\n            'VIEWS_RECOMPILE_onRotationEnd',\r\n            'VIEWS_RECOMPILE_whileRotating',\r\n            'VIEWS_RECOMPILE_constants',\r\n            'VIEWS_RECOMPILE_usageDeclarations',\r\n            'VIEWS_RECOMPILE_jsxString',\r\n            'VIEWS_RECOMPILE_preconditions',\r\n            'VIEWS_RECOMPILE_jsCondition',\r\n            'VIEWS_RECOMPILE_ocl',\r\n            'VIEWS_RECOMPILE_events',\r\n            'VIEWS_RECOMPILE_all',\r\n            'ClassNameChanged',\r\n            'tooltip',\r\n            'advanced',\r\n            'alert'\r\n        ];\r\n        /* Checking if CompositeAction has some actions that MUST be ignored */\r\n        let compositeAction: CompositeAction|null = null;\r\n        if(action.type === CompositeAction.type) {\r\n            compositeAction = action as CompositeAction;\r\n            const subActions = compositeAction.actions || [];\r\n            compositeAction.actions = subActions.filter(a => !ignoredFields.includes(a.field as keyof DState));\r\n        }\r\n        if(compositeAction && !compositeAction.actions.length) return ret;\r\n        action = (compositeAction) ? compositeAction : action;\r\n        if(action.sender === DUser.current && !ignoredFields.includes(action.field as keyof DState)) {\r\n            const parsedAction: JSON & GObject = JSON.parse(JSON.stringify(action));\r\n            Collaborative.client.emit('pushAction', parsedAction);\r\n        }\r\n    }\r\n\r\n    function filterSet<T extends any>(r: T[]): Set<T>{\r\n        if (!Array.isArray(r)) r = [];\r\n        r = r.filter(e=>!!e);\r\n        return new Set(r);\r\n    }\r\n    // recompile stuff\r\n    for (let ptr of filterSet(ret.ELEMENT_CREATED)){\r\n        let d = ret.idlookup[ptr];\r\n        if (!d) continue; // creation rejected, no-op\r\n        switch(d.className){\r\n            default: break;\r\n            case \"DViewElement\":\r\n                for(let nid in transientProperties.node){\r\n                    let tn = transientProperties.node[nid];\r\n                    delete tn.viewScores[d.id as any]; //= {} as any;\r\n                }\r\n        }\r\n    }\r\n    ret.ELEMENT_CREATED = [];\r\n    for (let ptr of filterSet(ret.ELEMENT_DELETED)){\r\n        let d = oldState.idlookup[ptr];\r\n        if (!d) continue; // already deleted, no-op\r\n        switch(d.className){\r\n            default: break;\r\n            case \"DViewElement\":\r\n                for (let nid in transientProperties.node) {\r\n                    let tn = transientProperties.node[nid];\r\n                    // delete tn.stackViews; // trigger recalc of all scores.\r\n                    delete tn.viewScores[d.id as any];\r\n                    tn.needSorting = true;\r\n                }\r\n        }\r\n    }\r\n    ret.ELEMENT_DELETED = [];\r\n\r\n    if (ret.VIEWS_RECOMPILE_all === true) ret.VIEWS_RECOMPILE_all = Object.keys(ret.idlookup);\r\n    if ((ret.VIEWS_RECOMPILE_all as Pointer[])?.length) {\r\n        let resetAllNodes: boolean = false;\r\n        let sk: keyof DState;\r\n        for (let id of filterSet(ret.VIEWS_RECOMPILE_all as Pointer[])){\r\n            let d = ret.idlookup[id];\r\n            if (!d) continue;\r\n            if (RuntimeAccessibleClass.extends(d.className, \"DViewElement\")) {\r\n                (d as DViewElement).css_MUST_RECOMPILE = true;\r\n                transientProperties.view[d.id as string] = { } as any;\r\n                // for (let k of DViewElement.MeasurableKeys) (ret as any)['VIEWS_RECOMPILE_'+k].push(d.id);\r\n                // for (let k of DViewElement.RecompileKeys) (ret as any)['VIEWS_RECOMPILE_'+k].push(d.id);\r\n                for (sk in ret) if (sk.indexOf('VIEWS_RECOMPILE') === 0) (ret[sk] as Pointer[]).push(id);\r\n                // ret.NODES_RECOMPILE_labels.push(id); ret.NODES_RECOMPILE_longestLabel.push(id);\r\n                if (!resetAllNodes) resetAllNodes = true;\r\n            }\r\n            if (RuntimeAccessibleClass.extends(d.className, \"DModelElement\")) {\r\n                if (d.className === \"DClass\") {\r\n                    let oldname = (oldState.idlookup[d.id] as DClass)?.name;\r\n                    let newname = (ret.idlookup[d.id] as DClass)?.name;\r\n                    if (oldname !== newname) ret.ClassNameChanged[d.id as Pointer<DClass>] = oldname;\r\n                }\r\n                for (sk in ret) if (sk.indexOf('MODELS_RECOMPILE') === 0) (ret[sk] as Pointer[]).push(id);\r\n                // transientProperties.modelElement[d.id] = { } as any; stuff in here does not need replacement, can never be dangerous (currently).\r\n            }\r\n            if (RuntimeAccessibleClass.extends(d.className, \"DGraphElement\")) {\r\n                delete transientProperties.node[d.id as string]; // = { } as any;\r\n                // transientProperties.node[d.id as string] = undefined as any;\r\n                console.warn('tn deleted', {tn:transientProperties.node[d.id as string], id:d.id});\r\n                for (sk in ret) if (sk.indexOf('NODES_RECOMPILE') === 0) (ret[sk] as Pointer[]).push(id);\r\n                //ret.NODES_RECOMPILE_labels.push(id); ret.NODES_RECOMPILE_longestLabel.push(id);\r\n            }\r\n        }\r\n\r\n        if (resetAllNodes) for (let nid in transientProperties.node) {\r\n            delete transientProperties.node[nid];// = {} as any;\r\n            // transientProperties.node[nid] = undefined as any;\r\n            console.warn('tn deleted 2', {tn:transientProperties.node[nid], nid});\r\n            for (sk in ret) if (sk.indexOf('NODES_RECOMPILE') === 0) (ret[sk] as Pointer[]).push(nid);\r\n            //ret.NODES_RECOMPILE_labels.push(id); ret.NODES_RECOMPILE_longestLabel.push(id);\r\n        }\r\n    }\r\n    ret.VIEWS_RECOMPILE_all = [];\r\n\r\n\r\n    function parseLabel(ptr: Pointer, key: \"labels\" | \"longestLabel\", isNode: boolean): boolean{\r\n        let dv: GObject<DViewElement | DGraphElement> = DPointerTargetable.fromPointer(ptr, ret);\r\n        let tp: NodeTransientProperties | ViewTransientProperties = ((isNode ? transientProperties.node : transientProperties.view) as GObject)[ptr];\r\n        if (!tp) {\r\n            if (isNode) transientProperties.node[ptr as any] = tp = new NodeTransientProperties();\r\n            else transientProperties.view[ptr as any] = tp = new ViewTransientProperties();\r\n        }\r\n        let val: string = dv[key];\r\n        if (!val) { tp[key] = undefined as any; return true; }\r\n        if (typeof val === \"function\") { tp[key] = val; return true; }\r\n        let allContextKeys = {...contextFixedKeys};\r\n        let vid: Pointer<DViewElement> = isNode ? (tp as NodeTransientProperties).mainView?.id : ptr as any;\r\n        if (!vid) return false; // leave pending & recompute them on next reducer action\r\n        let tv = transientProperties.view[vid];\r\n        for (let k of tv.constantsList) if (!allContextKeys[k]) allContextKeys[k] = true;\r\n        for (let k of tv.UDList) if (!allContextKeys[k]) allContextKeys[k] = true;\r\n        let paramStr = '{'+Object.keys(allContextKeys).join(',')+'}';\r\n        console.log('labels parse', { allContextKeys, ud:tv.UDList, c:tv.constantsList });\r\n        const body: string =  'return (' + val + ')';\r\n        // if (vid.includes('Model')) console.log(\"modelparse, laels\", {paramStr, body});\r\n        console.log('labels parse', {vid: ptr, paramStr, body});\r\n        try {\r\n            if (isNode) {\r\n                // need to store the function in tnv instead of tn since if v changes, ud changes as well? in all of them?what if i make a new view?\r\n            }\r\n            else {\r\n                // tp[key] = new Function(paramStr, body) as ((...a: any) => any);\r\n            }\r\n            tp[key] = function(){ return 'label as an option is disabled, pass it through props instead.'; }\r\n        }\r\n        catch (e: any) {\r\n            /*try{\r\n                let try_to_get_better_error = eval(\"let __f = function(\" + paramStr+\") {\\n\" + body + \"}\");\r\n            } catch(eeval){\r\n                console.error(\"eval error same as func error\", {e, eeval});\r\n                e = eeval;\r\n            }*/\r\n            console.error('error labels parse', {vid: ptr, e, paramStr, body});\r\n            tp[key] = val;// (context: GObject) => 'Error during label evaluation';\r\n        }\r\n        return true;\r\n        // implies recompilation of: ... nothing?\r\n    }\r\n    let arr: Pointer<any>[]\r\n    arr = ret.NODES_RECOMPILE_labels;\r\n    if (arr.length) {\r\n        let successfullyParsed: Dictionary<string, boolean> = {};\r\n        for (const id of filterSet(arr)) successfullyParsed[id] = parseLabel(id, 'labels', true);\r\n        ret.NODES_RECOMPILE_labels = arr.filter(e => !successfullyParsed[e]);\r\n    }\r\n    arr = ret.NODES_RECOMPILE_longestLabel;\r\n    if (arr.length) {\r\n        let successfullyParsed: Dictionary<string, boolean> = {};\r\n        for (const id of filterSet(arr)) successfullyParsed[id] = parseLabel(id, 'longestLabel', true);\r\n        ret.NODES_RECOMPILE_longestLabel = arr.filter(e => !successfullyParsed[e]);\r\n    }\r\n    arr = ret.VIEWS_RECOMPILE_labels;\r\n    if (arr.length) {\r\n        let successfullyParsed: Dictionary<string, boolean> = {};\r\n        for (const id of filterSet(arr)) successfullyParsed[id] = parseLabel(id, 'labels', false);\r\n        ret.VIEWS_RECOMPILE_labels = arr.filter(e => !successfullyParsed[e]);\r\n    }\r\n    arr = ret.VIEWS_RECOMPILE_longestLabel;\r\n    if (arr.length) {\r\n        let successfullyParsed: Dictionary<string, boolean> = {};\r\n        for (const id of filterSet(arr)) successfullyParsed[id] = parseLabel(id, 'longestLabel', false);\r\n        ret.VIEWS_RECOMPILE_longestLabel = arr.filter(e => !successfullyParsed[e]);\r\n    }\r\n\r\n    // local changes to out-of-redux stuff\r\n    if (ret.VIEWS_RECOMPILE_ocl.length) {\r\n        // for (let gid of filterSet(ret.graphs)) Selectors.updateViewMatchings(gid, ret.modelElements, Object.values(ret.idlookup).map( d => RuntimeAccessibleClass.extends(d, DModelElement.cname)));\r\n        // for (let vid of filterSet(ret.VIEW_APPLIABLETO_NEEDS_RECALCULATION)) { }\r\n        for (let vid of filterSet(ret.VIEWS_RECOMPILE_ocl)) {\r\n            if (!transientProperties.view[vid]) transientProperties.view[vid] = {} as any;\r\n            transientProperties.view[vid].oclEngine = undefined as any; // force re-parse\r\n            transientProperties.view[vid].oclChanged = true;\r\n            for (let nid in transientProperties.node) {\r\n                let tnv = transientProperties.node[nid].viewScores[vid];\r\n                if (tnv?.OCLScore !== ViewEClassMatch.NOT_EVALUATED_YET) tnv.OCLScore = ViewEClassMatch.NOT_EVALUATED_YET as any as boolean;\r\n            }\r\n        }\r\n        ret.VIEWS_RECOMPILE_ocl = [];\r\n    }\r\n    /*\r\n    if (ret.VIEWOCL_UPDATE_NEEDS_RECALCULATION.length) {\r\n        // not implemented for now\r\n        ret.VIEWOCL_UPDATE_NEEDS_RECALCULATION = [];\r\n    }*/\r\n\r\n    if (ret.VIEWS_RECOMPILE_preconditions.length) {\r\n        for (let vid of filterSet(ret.VIEWS_RECOMPILE_preconditions)) {\r\n            for (let nid in transientProperties.node) {\r\n                let tnv = transientProperties.node[nid].viewScores[vid];\r\n                if (tnv?.metaclassScore !== ViewEClassMatch.NOT_EVALUATED_YET) tnv.metaclassScore = ViewEClassMatch.NOT_EVALUATED_YET as any as number;\r\n            }\r\n        }\r\n        ret.VIEWS_RECOMPILE_preconditions = [];\r\n    }\r\n\r\n    if (ret.VIEWS_RECOMPILE_constants?.length)\r\n    for (const vid of filterSet(ret.VIEWS_RECOMPILE_constants)) { // compiled in func, and executed, result does not vary between nodes.\r\n        let dv: DViewElement = DPointerTargetable.fromPointer(vid, ret);\r\n        // transientProperties.view[vid].constantsList = dv.constants?.match(UDRegexp).map(s=>s.substring(4, s.length-1).trim()) || [];\r\n        // let allContextKeys = {...contextFixedKeys};\r\n        if (!dv.constants) {\r\n            if (!transientProperties.view[vid]) transientProperties.view[vid] = {} as any;\r\n            transientProperties.view[vid].constants = {};\r\n            transientProperties.view[vid].constantsList = [];\r\n            // no need to recompile UD, jsx or measurables, they will have additional parameters in scope but they are undefined and cause no problems.\r\n            continue;\r\n        }\r\n        const constantsOutput: GObject = {};\r\n        const context = {view:dv}; // context at this point holds only static stuff, which are in gloval scope (window) plus view.\r\n        let paramStr = '{'+Object.keys(context).join(',')+'}, ret';\r\n        try {\r\n            // the scope of new Function() is \"window\" and not the function where is called, unlike eval();\r\n            let constantsFunction: (context: GObject, ret: GObject) => void = new Function(paramStr, 'return ('+dv.constants+')(ret)').bind(context);\r\n            constantsFunction(context, constantsOutput);\r\n        } catch(e:any){\r\n            console.error('error constants parse', {vid, e, paramStr, body:'return ('+dv.constants+')(ret)'});\r\n            // todo: how do i render an error from here? even if i set jsx or ud.__invalidDeclarations it will be recompiled. need a constants.__invalidDeclarations too?\r\n        }\r\n\r\n        transientProperties.view[vid].constants = constantsOutput;\r\n        transientProperties.view[vid].constantsList = Object.keys(transientProperties.view[vid].constants);\r\n        // implies recompilation of: jsCondition, ud, jsx and all measurable events\r\n        ret.VIEWS_RECOMPILE_jsCondition.push(vid);\r\n        ret.VIEWS_RECOMPILE_usageDeclarations.push(vid);\r\n        ret.VIEWS_RECOMPILE_jsxString.push(vid);\r\n        ret.VIEWS_RECOMPILE_events.push(vid);\r\n        for (let k of DViewElement.MeasurableKeys) (ret as any)['VIEWS_RECOMPILE_'+k].push(vid);\r\n    }\r\n    ret.VIEWS_RECOMPILE_constants = [];\r\n\r\n    if (ret.VIEWS_RECOMPILE_usageDeclarations?.length)\r\n    for (const vid of filterSet(ret.VIEWS_RECOMPILE_usageDeclarations)) { // compiled in func, but NOT executed, result varies between nodes.\r\n        let dv: DViewElement = DPointerTargetable.fromPointer(vid, ret);\r\n        let tv = transientProperties.view[vid];\r\n        if (!tv) transientProperties.view[vid] = tv = {} as any;\r\n        if (!dv.usageDeclarations) {\r\n            tv.UDList = [];\r\n            tv.UDFunction = undefined as any;\r\n            // no need to recompile jsx or measurables, they will have additional parameters in scope but they are undefined and cause no problems.\r\n            continue;\r\n        }\r\n        let matches = dv.usageDeclarations?.match(UDRegexp) || [];\r\n        transientProperties.view[vid].UDList = matches.map(s=>{ s = s.trim(); return s.substring(s.indexOf('\\.')+1, s.length-2).trim()});\r\n        // warning for user: do not redeclare ret in nested blocks.\r\n        // do not use ret[key] syntax.\r\n        // do not set nested values directly (ret.key.subkey syntax).\r\n        // do not use ret.key +=, -= or any other operator assignment different than \"=\"\r\n        // if that is ever required, do instead\r\n        // do not assign values to ret in block comments\r\n        // those restrictions only apply to the ret object, all those violations can be done on other objects.\r\n        // so the following is valid, and a way to overcome the previous limitations:\r\n        // let subobject = {}; subobject[key] += stuff; ret.somefixedname = subobject;\r\n\r\n        let allContextKeys: Dictionary = {...contextFixedKeys};\r\n        for (let k of tv.constantsList) if (!allContextKeys[k]) allContextKeys[k] = true;\r\n        let paramStr = '{'+Object.keys(allContextKeys).join(',')+'}, ret';\r\n        if (vid.includes('Model')) console.log(\"modelparse, ud\", {paramStr, udstr:dv.usageDeclarations, udlist:transientProperties.view[vid].UDList});\r\n        try {\r\n            tv.UDFunction = new Function(paramStr, 'return ('+dv.usageDeclarations+')(ret)') as (...a:any)=>any;\r\n        } catch (e:any) {\r\n            // problem: errors cannot be serialized in any way? they have no keys. let strerr = JSON.stringify(e); //(e.message || '').split('\\n')[0]);\r\n            let udErrors: GObject =  windoww.udErrors;\r\n            if (!windoww.udErrors) windoww.udErrors = udErrors = {maxi: 0};\r\n            udErrors[\"e\"+(++udErrors.maxi)] = e;\r\n            e.isSyntax = true;\r\n            let errbody = \"ret.__invalidUsageDeclarations = window.udErrors.e\"+udErrors.maxi+\"; return ret;\";\r\n            console.error('error udparse', {vid, e, paramStr, body: 'return ('+dv.usageDeclarations+')(ret)', errbody});\r\n            tv.UDFunction = new Function(\"unusedContext, ret\", errbody) as (...a:any)=>any;\r\n        }\r\n\r\n\r\n        // implies recompilation of: jsx and all measurable events\r\n        ret.VIEWS_RECOMPILE_jsxString.push(vid);\r\n        ret.VIEWS_RECOMPILE_events.push(vid);\r\n        for (let k of DViewElement.MeasurableKeys) (ret as any)['VIEWS_RECOMPILE_'+k].push(vid);\r\n    }\r\n    ret.VIEWS_RECOMPILE_usageDeclarations = [];\r\n\r\n    if (ret.VIEWS_RECOMPILE_events.length) {\r\n        // for (let gid of filterSet(ret.graphs)) Selectors.updateViewMatchings(gid, ret.modelElements, Object.values(ret.idlookup).map( d => RuntimeAccessibleClass.extends(d, DModelElement.cname)));\r\n        // for (let vid of filterSet(ret.VIEW_APPLIABLETO_NEEDS_RECALCULATION)) { }\r\n        for (let entry of filterSet(ret.VIEWS_RECOMPILE_events)) {\r\n            let vid: string;\r\n            let dv: DViewElement;\r\n            let keys: string[];\r\n            if (typeof entry === \"object\") {\r\n                vid = entry.vid;\r\n                dv = DPointerTargetable.fromPointer(vid, ret);\r\n                keys = entry.keys || Object.keys(dv.events);\r\n            }\r\n            else {\r\n                vid = entry;\r\n                dv = DPointerTargetable.fromPointer(vid, ret);\r\n                keys = Object.keys(dv.events);\r\n            }\r\n            let tv = transientProperties.view[vid];\r\n            if (!tv) transientProperties.view[vid] = tv = {} as any;\r\n            if (!tv.events) tv.events = {};\r\n            // if (!tv.events_raw) tv.events_raw = {};\r\n            for (let key of keys) {\r\n                if (!key) { delete tv.events[key]; continue; }\r\n                let allContextKeys = {...contextFixedKeys};\r\n                for (let k of transientProperties.view[vid].constantsList) if (!allContextKeys[k]) allContextKeys[k] = true;\r\n                for (let k of transientProperties.view[vid].UDList) if (!allContextKeys[k]) allContextKeys[k] = true;\r\n                let paramStr = '{'+Object.keys(allContextKeys).join(',')+'}, ..._params';\r\n                // dv.events[key] = (...params)=> code\r\n                const body: string = 'return (' +dv.events[key]+')(..._params)';\r\n                // if (vid.includes('Model')) console.log(\"modelparse, jsx\", {paramStr, body});\r\n                try {\r\n                    tv.events[key] = new Function(paramStr, body) as ((...a:any[])=>any);\r\n                    // tv.events_raw[key] = new Function(paramStr, body) as ((...a:any)=>any);\r\n                    // attempt to auto obtain node context\r\n                    // impossile with view.event.name\r\n                    // could with node.event.name if node.get_event sets a current node thing__, no he must wrap the func!! in the getter\r\n                    // tv.events[key] = (..._params2:any) => { return tv.events_raw[key](context, ..._params2) };\r\n                }\r\n                catch (e: any) {\r\n                    console.error('error jsxparse', {vid, e, paramStr, body});\r\n                    tv.events[key] = (context) => Log.ee(\"failed to parse function body: \" + e.message.split(\"\\n\")[0], e.message);\r\n                }\r\n            }\r\n        }\r\n        ret.VIEWS_RECOMPILE_events = [];\r\n        // triggers recompile of nothing\r\n    }\r\n\r\n    if (ret.VIEWS_RECOMPILE_jsCondition?.length)\r\n    for (const vid of filterSet(ret.VIEWS_RECOMPILE_jsCondition)) {\r\n        const dv: DViewElement = DPointerTargetable.fromPointer(vid, ret);\r\n        let tv = transientProperties.view[vid];\r\n        if (!tv) transientProperties.view[vid] = tv = {} as any;\r\n        tv.jsConditionChanged = true;\r\n        if (!dv.jsCondition) {\r\n            tv.jsCondition = undefined;\r\n            continue;\r\n        }\r\n        const lines = dv.jsCondition.trim().split('\\n');\r\n        let lastLine = lines[lines.length - 1];\r\n        if (lastLine.indexOf('return') !== 0) lines[lines.length - 1] = `return (${lastLine})`;\r\n\r\n\r\n        if (!dv.jsxString) { transientProperties.view[vid].JSXFunction = undefined as any; continue; }\r\n        let allContextKeys = {...contextFixedKeys};\r\n        for (let k of transientProperties.view[vid].constantsList) if (!allContextKeys[k]) allContextKeys[k] = true;\r\n\r\n        let paramStr = '{'+Object.keys(allContextKeys).join(',')+'}';\r\n        const body = lines.join('\\n');\r\n        try {\r\n            tv.jsCondition = new Function(paramStr, body) as ((...a:any)=>any);\r\n        } catch (e) {\r\n            tv.jsCondition = undefined;\r\n            console.log('JS Condition parsed error', e);\r\n        }\r\n    }\r\n    ret.VIEWS_RECOMPILE_jsCondition = [];\r\n\r\n\r\n    if (ret.VIEWS_RECOMPILE_jsxString?.length)\r\n    for (const vid of filterSet(ret.VIEWS_RECOMPILE_jsxString)) { // compiled in func, but NOT executed, result varies between nodes.\r\n        let dv: DViewElement = DPointerTargetable.fromPointer(vid, ret);\r\n        let tv = transientProperties.view[vid];\r\n        if (!tv) transientProperties.view[vid] = tv = {} as any;\r\n        if (!dv.jsxString) { transientProperties.view[vid].JSXFunction = undefined as any; continue; }\r\n        let allContextKeys = {...contextFixedKeys};\r\n        for (let k of transientProperties.view[vid].constantsList) if (!allContextKeys[k]) allContextKeys[k] = true;\r\n        for (let k of transientProperties.view[vid].UDList) if (!allContextKeys[k]) allContextKeys[k] = true;\r\n        let paramStr = '{'+Object.keys(allContextKeys).join(',')+'}';\r\n\r\n        const body: string =  'return (' + UX.parseAndInject(DSL.parser(dv.jsxString), dv) + ')';\r\n        // if (vid.includes('Model')) console.log(\"modelparse, jsx\", {paramStr, body});\r\n        try {\r\n            transientProperties.view[vid].JSXFunction = new Function(paramStr, body) as ((...a: any) => any);\r\n        }\r\n        catch (e: any) {\r\n            /*try{\r\n                let try_to_get_better_error = eval(\"let __f = function(\" + paramStr+\") {\\n\" + body + \"}\");\r\n            } catch(eeval){\r\n                console.error(\"eval error same as func error\", {e, eeval});\r\n                e = eeval;\r\n            }*/\r\n            console.error('error jsxparse', {vid, e, paramStr, body});\r\n            transientProperties.view[vid].JSXFunction = (context) => GraphElementComponent.displayError(e, 'JSX Syntax', dv);\r\n        }\r\n        // implies recompilation of: ... nothing?\r\n    }\r\n    ret.VIEWS_RECOMPILE_jsxString = [];\r\n\r\n\r\n\r\n    for (const key of DViewElement.MeasurableKeys) {\r\n        if ((ret as any)['VIEWS_RECOMPILE_'+key]?.length)\r\n        for (let vid of filterSet((ret as any)['VIEWS_RECOMPILE_'+key]) as any) {\r\n            let dv: DViewElement = DPointerTargetable.fromPointer(vid, ret);\r\n            let tv = transientProperties.view[vid];\r\n            if (!tv) transientProperties.view[vid] = tv = {} as any;\r\n            let str: string = (dv as any)[key];\r\n            if (!str) {\r\n                (transientProperties.view[vid] as any)[key] = undefined;\r\n                continue;\r\n            }\r\n            let allContextKeys = {...contextFixedKeys};\r\n            for (let k of transientProperties.view[vid].constantsList) if (!allContextKeys[k]) allContextKeys[k] = true;\r\n            for (let k of transientProperties.view[vid].UDList) if (!allContextKeys[k]) allContextKeys[k] = true;\r\n            let paramStr = '{'+Object.keys(allContextKeys).join(',')+'}';\r\n            console.log('measurable parse '+key, {allContextKeys, ud:transientProperties.view[vid].UDList, c:transientProperties.view[vid].constantsList });\r\n            console.log('measurable parse '+key, {vid, paramStr, body:str});\r\n            try {\r\n                (transientProperties.view[vid] as any)[key] = new Function(paramStr, str);\r\n            }\r\n            catch (e: any) {\r\n                console.error('error measurable parse '+key, {vid, e, paramStr, body:str});\r\n                (transientProperties.view[vid] as any)[key] = undefined;\r\n                // display error in jsx\r\n                transientProperties.view[vid].JSXFunction = (context) => GraphElementComponent.displayError(e, 'Measurable ' + key + ' Syntax', dv);\r\n                break;\r\n            }\r\n        }\r\n        (ret as any)['VIEWS_RECOMPILE_'+key] = [];\r\n    }\r\n\r\n    for (let dataid in ret.ClassNameChanged) {\r\n        if (dataid === 'clonedCounter') continue;\r\n        // NB: if i ever want to access a constructor's other properties in ocl, like \"context Persona inv: self.$somecounter === Persona.instances.length\",\r\n        // i would need to update this every time a DClass property changes instead of only when name changes.\r\n\r\n        // if it's first creation of a modelpiece\r\n        if (!transientProperties.modelElement[dataid]) {\r\n            // transientProperties.modelElement[dataid] = {nodes: {}};\r\n        }\r\n        // update ocl type names\r\n        let data: DClass = ret.idlookup[dataid] as DClass;\r\n        RuntimeAccessibleClass.makeOCLConstructor(data, ret, oldState);\r\n        // here i should reset all tnv.oclEngine too and set all ocl scores to notevaluated, but it is too computationally heavy\r\n        // and it's useful to keep the old ocl condition valid with past names until manually edited.\r\n    }\r\n    ret.ClassNameChanged = {};\r\n\r\n    return ret;\r\n\r\n}\r\nconst mergeTolerance = 300;\r\nexport function _reducer/*<S extends StateNoFunc, A extends Action>*/(oldState: DState = initialState, action: Action): DState{\r\n    let times: number;\r\n    let state: DState;\r\n    let removedDeltas: (GObject | undefined)[] = [];\r\n\r\n    switch (action.type) {\r\n        case UndoAction.type:\r\n            times = action.value;\r\n            state = oldState;\r\n            Log.exDev(times<=0, \"undo must be positive\", action);\r\n            // if (desc) { ret.action_title = desc.desc + ': ' + desc.oldval + ' -> ' + desc.newval; ...}\r\n            //state.action_title = 'undone ' + times + ' steps';\r\n            //state.action_description = 'undone ' + times + ' steps';\r\n\r\n            while (times--) {\r\n                let forUser = (action as UndoAction).forUser;\r\n                const delta = statehistory[forUser].undoable.pop();\r\n                for (let user in statehistory){\r\n                    U.arrayRemoveAll(statehistory[user]?.undoable, delta);\r\n                }\r\n                if (!delta) continue;\r\n                removedDeltas.push(delta);\r\n                state = undo(state, action as UndoAction, delta, true);\r\n            }\r\n\r\n            state.action_title = 'undone ' + times + ' steps' + (state.action_title ? ': '+state.action_title : '.');\r\n            state.action_description =  'undone ' + times + ' steps' + (state.action_description ? ': '+state.action_description : '.');\r\n            state.VIEWS_RECOMPILE_all = [...new Set(removedDeltas.flatMap( d => Object.keys(d?.idlookup||{})))];\r\n            // state.VIEWS_RECOMPILE_all = true;\r\n            return state;\r\n\r\n        case RedoAction.type:\r\n            times = action.value;\r\n            state = oldState;\r\n            Log.exDev(times<=0, \"redo must be positive\", action);\r\n            // if (desc) { ret.action_title = desc.desc + ': ' + desc.oldval + ' -> ' + desc.newval; ...}\r\n            // state.action_title = 'redone ' + times + ' steps';\r\n            // state.action_description =  'redone ' + times + ' steps';\r\n            while (times--) {\r\n                let forUser = (action as UndoAction).forUser;\r\n                const delta = statehistory[forUser].redoable.pop();\r\n                for (let user in statehistory){\r\n                    U.arrayRemoveAll(statehistory[user]?.redoable, delta);\r\n                }\r\n                if (!delta) continue;\r\n                removedDeltas.push(delta);\r\n                state = undo(state, action as RedoAction, delta, false);\r\n            }\r\n\r\n            state.action_title = 'redone ' + times + ' steps' + (state.action_title ? ': '+state.action_title : '.');\r\n            state.action_description =  'redone ' + times + ' steps' + (state.action_description ? ': '+state.action_description : '.');\r\n            state.VIEWS_RECOMPILE_all = [...new Set(removedDeltas.flatMap( d => Object.keys(d?.idlookup||{})))];\r\n            // state.VIEWS_RECOMPILE_all = true;\r\n            return state;\r\n        // case CombineHistoryAction.type: return combineHistory(oldState); break;\r\n        // todo: se al posto di \"annullare l'undo\" memorizzo l'azione e la rieseguo, posso ripetere l'ultimo passo N volte e questa azione diventa utile per combinare passi e ripetere blocchi di azioni assieme\r\n        default:\r\n            if (action.type?.indexOf('@@redux/') === 0) {\r\n                console.error('redux init', {action, oldState, initialState});\r\n                return oldState;\r\n            }\r\n            if (!(action?.className)) { Log.exDevv('unexpected action type:', action.type); return oldState; }\r\n            let ret = doreducer(oldState, action);\r\n            if (ret === oldState) return ret;\r\n            ret.timestamp = Date.now();\r\n            console.log('00 UNset action descriptor in state', {action});\r\n            ret.action_title = '';\r\n            ret.action_description = '';\r\n            // undo-redo description\r\n            if (action.className === 'CompositeAction') {\r\n                let desc = (action as CompositeAction).descriptor;\r\n                if (desc) {\r\n                    console.log('set action descriptor in state', {desc, action, t: desc.path, oldt: ret.action_title});\r\n                    ret.action_title = desc.path||'';\r\n                    let valchange: string;\r\n                    if (desc.oldval !== undefined && desc.newval!== undefined) valchange = ': ' + desc.oldval + ' -> ' + desc.newval;\r\n                    else if (desc.oldval === undefined && desc.newval!== undefined) valchange = ': ' + desc.newval;\r\n                    else valchange = '';\r\n                    ret.action_description = (desc.desc || '') + valchange;\r\n                }\r\n                else {\r\n                    console.log('11 UNset action descriptor in state', {action});\r\n                    ret.action_title = '';\r\n                    ret.action_description = '';\r\n                }\r\n            }\r\n            if (!oldState/* || !Object.keys(delta).length*/) return ret;\r\n\r\n            // update state history\r\n            let delta = Uobj.objectDelta(ret, oldState, true, false);\r\n            let debug = Uobj.applyObjectDelta(ret, delta, false, oldState);\r\n            delta.timestamp = ret.timestamp;\r\n            delta.timestampdiff = ret.timestampdiff = ret.timestamp - (oldState?.timestamp || 0);\r\n            let pastDelta = statehistory.all.undoable[statehistory.all.undoable.length-1];\r\n            const allowMerge = true; // switch for debugging\r\n            let isRelevantChange = isRelevantChangeCheck(delta as GObject<DState>, pastDelta as GObject<DState>);\r\n            // merge if: there is a past delta, and the delta doesn't pass the filter to exist individually\r\n            let shouldMerge = !isRelevantChange;\r\n            let debugMerge = true;\r\n            if (!shouldMerge && (delta.vertexs || delta.graphvertexs || delta.graphelements || delta.edgepoints || delta.edges || delta.graphs)) shouldMerge = true;\r\n            if (!pastDelta) shouldMerge = false;\r\n\r\n            if(pastDelta)console.log(\"merge deltas\", {forVertex:delta.vertexs || delta.graphvertexs || delta.graphelements || delta.edgepoints || delta.edges || delta.graphs,\r\n                isRelevantChange,\r\n                shouldMerge, irl: pastDelta && delta.timestamp - pastDelta.timestamp < mergeTolerance,\r\n                mergeTolerance, dt: delta.timestamp, pdt: pastDelta.timestamp, diff: delta.timestamp - pastDelta.timestamp,\r\n                oldState, delta});\r\n            //todo: for cooperative prevent merge from different authors, store user in delta from action.sender when you set timestamp.\r\n            if (shouldMerge && allowMerge) {\r\n                // pastDelta = Uobj.applyObjectDelta(pastDelta, delta); no because special handling\r\n                //   of __jjisEmpty etc must not be done at this stage.\r\n                let gdelta: Dictionary<string, string[] | GObject> = {};\r\n                let allkeys: Set<string> = new Set([...Object.keys(delta), ...Object.keys(pastDelta)]);\r\n                let mergeRecompileArr = (k: string) => {\r\n                    if (!(k.indexOf('RECOMPILE') >= 0 || k.indexOf('ELEMENT_') >= 0 || k === 'ClassNameChanged')) return;\r\n                    if (k === 'ClassNameChanged') {\r\n                        let merged: Dictionary<string> = {};\r\n                        for (let p of allkeys) {\r\n                            let vnow = (delta as GObject)[k][p];\r\n                            let vpast = pastDelta[k][p];\r\n                            if (vnow === vpast) { merged[p] = vnow; continue; }\r\n                            if (vnow.indexOf('__jjObjDiff') !== -1) { merged[p] = vpast; continue; }\r\n                            merged[p] = vnow;\r\n                        }\r\n                        gdelta.ClassNameChanged = merged;\r\n                        return;\r\n                    }\r\n                    // todo: this is troublesome because ['id1', 'empty'] + ['id2'] =  ['id1', 'empty', 'id2'] but should not have side effects? can the empty sparse arr make problems?\r\n                    if (!Array.isArray((delta as GObject)[k] || [])) console.error('mergerecompilearr err',\r\n                        {sm:shouldMerge, pd:!!pastDelta, delta, pastDelta, k, dk: (delta as any)?.[k], pdk: pastDelta?.[k]});\r\n                    if (!Array.isArray((delta as GObject)[k]||[])) console.log('err in delta merge', {arr:(delta as GObject)[k]||[], delta, k});\r\n                    if (!Array.isArray((pastDelta as GObject)[k]||[])) console.log('err in past delta merge', {arr:(pastDelta as GObject)[k]||[], pastDelta, k});\r\n                    // todo: reenable fix past line but remember they can be either true arrays or delta object fake arrays __jjObjDiffIsArr = true\r\n                    // gdelta[k] = [...new Set(U.arrayMergeInPlace((delta as GObject)[k]||[], pastDelta[k]||[]))] as string[];\r\n                }\r\n\r\n                for (let k of allkeys) mergeRecompileArr(k);\r\n                U.objectMergeInPlace(pastDelta, delta);\r\n                delta = pastDelta; // must be inaccessible now as it merged with pastdelta, use that instead\r\n                for (let k in gdelta) {\r\n                    if (Array.isArray(gdelta[k])) pastDelta[k] = gdelta[k].filter((e:string) => e && e.indexOf('__jjObjDiff') === -1);\r\n                    else pastDelta[k] = gdelta[k];\r\n                }\r\n                if (debugMerge) (ret as any).mergeCounter = (pastDelta as any).mergeCounter = 1+((ret as any).mergeCounter||0)\r\n            }\r\n            else if (isRelevantChange) {\r\n                let user = (action as Action).sender;\r\n                statehistory[user].undoable.push(delta);\r\n                statehistory.all.undoable.push(delta);\r\n                if (debugMerge) {\r\n                    if (shouldMerge) (ret as any).notMergeCounter = (delta as any).notMergeCounter = 1+((ret as any).notMergeCounter || 0)\r\n                    else (ret as any).notMergeCounter = 0;\r\n                }\r\n            }\r\n\r\n            return ret;\r\n    }\r\n}\r\n\r\nfunction isRelevantChangeCheck(delta: GObject<DState>, pastDelta?: GObject<DState>): boolean {\r\n    if (pastDelta && delta.timestamp - pastDelta.timestamp < mergeTolerance) return false;\r\n    if (!statehistory.globalcanundostate) return false;\r\n    if (Object.keys(delta).length === 1) {\r\n        if (\"dragging\" in delta) return false;\r\n        if (\"_lastSelected\" in delta) return false;\r\n        if (\"contextMenu\" in delta) return false;\r\n    }\r\n    return true;\r\n}\r\nfunction undo(state: DState, action: UndoAction | RedoAction, delta: GObject | undefined, isundo = true): DState {\r\n    if (!delta) return state;\r\n    //let undonestate: DState = {...state} as DState;\r\n    //   controlla se vengono shallow-copied solo e tutti gli oggetti nested lungo la catena del percorso delle modifiche\r\n    //   es: root.a.b.c=3 + root.a.b.d=3 = 4+1 modifiche, 5 shallow copies including the root\r\n    //undorecursive(delta, undonestate);\r\n\r\n    let undonestate = Uobj.applyObjectDelta(state, delta, false);\r\n    // todo: check if delta2 === delta or is his opposite in values but same shape\r\n    let delta2 = Uobj.objectDelta(undonestate, state);\r\n    let debug = Uobj.applyObjectDelta(undonestate, delta2, false, state);\r\n    let forUser = action.forUser;\r\n    let user = action.sender;\r\n    // reverses from undo to redo and viceversa swapping arguments, so the target result after appliying the delta changes\r\n    // redo is \"undoing an undo\", reversing his changes just like an undo reverses an ordinary action changes.\r\n    let key: 'redoable'|'undoable' = isundo ? 'redoable' : 'undoable';\r\n    statehistory[user][key].push(delta2);\r\n    statehistory.all[key].push(delta2);\r\n    return undonestate as GObject<DState>;\r\n}\r\n/*\r\nfunction undorecursive(deltalevel: GObject, statelevel: GObject): void {\r\n    // statelevel = {...statelevel}; not working if i do it here, just a new var. first time copy id done in caller func undo(). recursive copies are done before recursive step\r\n    for (let key in deltalevel) {\r\n        let delta = deltalevel[key];\r\n        console.log(\"undoing\", {delta, key, deltalevel, statelevel})\r\n        //if (key.indexOf(\"_-\") === 0) { delete statelevel[key.substring(2)]; continue; }\r\n        if (typeof delta === \"object\") {\r\n        // if (U.isObject(delta, false, false, true)) {\r\n            if (Array.isArray(delta)) statelevel[key] = [...statelevel[key]];\r\n            else statelevel[key] = {...statelevel[key]};\r\n            undorecursive(deltalevel[key], statelevel[key]); }\r\n        else { statelevel[key] = delta; }\r\n    }\r\n}*/\r\n\r\nfunction doreducer/*<S extends StateNoFunc, A extends Action>*/(oldState: DState = initialState, action: Action): DState{\r\n    let ca: CompositeAction;\r\n    switch (action.type) {\r\n        case CompositeAction.type: ca = action as CompositeAction; break;\r\n        case LoadAction.type:\r\n        default:/*\r\n            if (action.type.indexOf('@@redux/') === 0) { handled on upper levels\r\n                //storeLoaded = true;\r\n                return oldState;\r\n            }*/\r\n            ca = new CompositeAction([action], false);\r\n            break;\r\n    }\r\n    let ret = CompositeActionReducer(oldState, ca);\r\n    /*if (state.current !== ret) {\r\n        state.current = ret;\r\n        state.past.push(ret);\r\n    }*/\r\n    return ret;\r\n}\r\nfunction setSubclasses(roots: orArr<typeof RuntimeAccessibleClass>){\r\n    RuntimeAccessibleClass.extendMatrix =\r\n        new SimpleTree<(typeof RuntimeAccessibleClass)>(roots, \"subclasses\")\r\n            .getiIsSubElementMatrix(\"cname\");\r\n    /*\r\n    let tree = new TreeModel({\r\n        childrenPropertyName: \"subclasses\"\r\n    });\r\n    for (let key in dict){\r\n        let constructor = dict[key];\r\n        if(!constructor.hasOwnProperty(\"subclasses\")) constructor.subclasses = [];\r\n    }\r\n    RuntimeAccessibleClass.extendTree = (tree as any).safe_parse(RuntimeAccessibleClass);*/\r\n}\r\n// windoww.TreeModel = TreeModel;\r\nfunction buildLSingletons(alld: Dictionary<string, typeof DPointerTargetable>, alll: Dictionary<string, typeof LPointerTargetable>) {\r\n    for (let dname in alld) {\r\n        switch (dname) {\r\n            case \"DeleteElementAction\": continue;\r\n            case \"DV\": continue;\r\n            case \"Debug\": continue;\r\n            default: break;\r\n        }\r\n        if ((dname[1] || \"\").toLowerCase() === dname[1]) continue; // if second letter is lowercase, it's not a \"D\" class\r\n        let tagless = dname.substring(1);\r\n        let d = alld[dname];\r\n        let l = alll['L'+tagless];\r\n        if (!d||!l) console.error(\"missing d constructor\", {d, l});\r\n        d.logic = l;\r\n        if (!l) console.error('init() could not find L-class during mapping', l, d);\r\n        // @ts-ignore\r\n        d.singleton = new l('dwc');\r\n        d.structure = d;\r\n\r\n        l.logic = d.logic;\r\n        l.singleton = d.singleton;\r\n        l.structure = d.structure;\r\n\r\n        // if (!d.subclasses) d.subclasses = [];\r\n        // @ts-ignore\r\n        // for (let sc of d.subclasses) { if (!sc[\"_extends\"]) sc[\"_extends\"] = [];  sc[\"_extends\"].push(d); }\r\n    }\r\n}\r\nfunction setDocumentEvents(){\r\n    // do not use typings or class constructors here or it will change import order\r\n    setTimeout(\r\n        ()=> $(document).on(\"mouseup\",\r\n            (e: MouseUpEvent) => {\r\n                statehistory.globalcanundostate = true;\r\n                RuntimeAccessibleClass.get<typeof GraphDragManager>(\"GraphDragManager\").stopPanning(e);\r\n            })\r\n        , 1);\r\n    // document.body.addEventListener(\"mousedown\", fixResizables, false);\r\n    setInterval(()=>{ END(); BEGIN(); }, 300);\r\n}\r\nfunction fixResizables(e: MouseEvent){\r\n    /*let parents = U.ancestorArray(e.target as HTMLElement);\r\n    for (let e of parents){\r\n        if (e.classList.contains(\"draggable\")) U.makeDraggable(e, e.dataset.draggableOptions, e.attributes.disabled);\r\n        if (e.classList.contains(\"resizable\")) U.makeResizable(e, e.dataset.draggableOptions);\r\n        if (e.classList.contains(\"resizable\")) U.makeRotatable(e, e.dataset.draggableOptions);\r\n    }*/\r\n}\r\n\r\nexport async function stateInitializer() {\r\n    console.trace('stateinitializer');\r\n    RuntimeAccessibleClass.fixStatics();\r\n    let dClassesMap: Dictionary<string, typeof DPointerTargetable> = {};\r\n    let lClassesMap: Dictionary<string, typeof LPointerTargetable> = {};\r\n    for (let name in RuntimeAccessibleClass.classes) {\r\n        switch(name[0]) {\r\n            case 'D': dClassesMap[name] = RuntimeAccessibleClass.classes[name] as typeof DPointerTargetable; break;\r\n            case 'L': lClassesMap[name] = RuntimeAccessibleClass.classes[name] as typeof LPointerTargetable; break;\r\n            default: break;\r\n        }\r\n    }\r\n\r\n    buildLSingletons(dClassesMap, lClassesMap);\r\n    setSubclasses(RuntimeAccessibleClass.get('DPointerTargetable'));\r\n    windoww.defaultContext = {$: windoww.$, getPath, React: React, Selectors, ...RuntimeAccessibleClass.getAllClassesDictionary(), ...windoww.Components};\r\n\r\n    DState.init();\r\n    await DUser.loadOffline(); // if it's online mode this is a no-op and user should be already loaded\r\n    console.log('FIRING action pre')\r\n    await ProjectsApi.getAll();\r\n    console.log('FIRING action post')\r\n    //await ProjectsApi.getAll();\r\n    setDocumentEvents();\r\n    /*type RecentEntry = {id: Pointer<DProject>[], name: string};\r\n    let recent: RecentEntry[] = JSON.parse(localStorage.getItem('_jjRecent') || '[]') as any[];\r\n    if (window.location.hash.indexOf('#/project') === 0) {\r\n        let user: LUser = LPointerTargetable.from(DUser.current);\r\n        let project = user?.projects.filter(p=>!!p)[0]?.__raw as any;\r\n        //console.log('test recents', {project, user, recent});\r\n        let current: RecentEntry = {name: project.name, id:project.id};\r\n        // the filter looks if the current project was already in recent list, and prevents duplicates\r\n        recent = recent.filter(p=> p.id !== current.id);\r\n        recent.push(current);\r\n        localStorage.setItem('_jjRecent', JSON.stringify(recent));\r\n    }*/\r\n\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}