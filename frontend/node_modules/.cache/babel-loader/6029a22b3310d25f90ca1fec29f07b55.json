{"ast":null,"code":"var _class, _class2, _class3, _class5, _class7, _class9, _class10, _class11;\nimport { DPointerTargetable, RuntimeAccessible, windoww, Log, RuntimeAccessibleClass } from \"../joiner\";\nexport let IPoint = RuntimeAccessible(_class = (_class2 = class IPoint extends RuntimeAccessibleClass {\n  // @ts-ignore static getM is not null but must be declared nullable to achieve subclass mixing\n\n  constructor() {\n    let x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    let y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    super(); // super('dwc');\n    this.x = void 0;\n    this.y = void 0;\n    IPoint.init_constructor(this, x, y);\n  }\n  static init_constructor(thiss) {\n    let x = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    let y = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    thiss.id = \"POINT_\" + DPointerTargetable.maxID++ + \"_\" + new Date().getTime();\n    thiss.className = thiss.constructor.name;\n    if (x === null) thiss.x = null;else if (isNaN(+x)) {\n      thiss.x = 0;\n    } else thiss.x = +x;\n    if (y === null) thiss.y = null;else if (isNaN(+y)) {\n      thiss.y = 0;\n    } else thiss.y = +y;\n    thiss.className = this.name;\n  }\n  toString() {\n    return '(' + this.x + ', ' + this.y + ')';\n  }\n  clone(other) {\n    this.x = other.x;\n    this.y = other.y;\n    return this;\n  }\n  duplicate() {\n    const ret = this.new();\n    ret.clone(this);\n    return ret;\n  }\n  subtract(p2, newInstance) {\n    Log.e(!p2, 'subtract argument must be a valid point: ', p2);\n    let p1;\n    if (!newInstance) {\n      p1 = this;\n    } else {\n      p1 = this.duplicate();\n    }\n    p1.x -= p2.x;\n    p1.y -= p2.y;\n    return p1;\n  }\n  add(p2, newInstance) {\n    Log.e(!p2, 'add argument must be a valid point: ', p2);\n    let p1;\n    if (!newInstance) {\n      p1 = this;\n    } else {\n      p1 = this.duplicate();\n    }\n    p1.x += p2.x;\n    p1.y += p2.y;\n    return p1;\n  }\n  addAll(p, newInstance) {\n    let i;\n    let p0;\n    if (!newInstance) {\n      p0 = this;\n    } else {\n      p0 = this.duplicate();\n    }\n    for (i = 0; i < p.length; i++) {\n      p0.add(p[i], true);\n    }\n    return p0;\n  }\n  subtractAll(p, newInstance) {\n    let i;\n    let p0;\n    if (!newInstance) {\n      p0 = this;\n    } else {\n      p0 = this.duplicate();\n    }\n    for (i = 0; i < p.length; i++) {\n      p0.subtract(p[i], true);\n    }\n    return p0;\n  }\n  multiply(pt) {\n    let newInstance = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    let ret = newInstance ? this.duplicate() : this;\n    ret.x *= pt.x;\n    ret.y *= pt.y;\n    return ret;\n  }\n  divide(pt) {\n    let newInstance = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    let ret = newInstance ? this.duplicate() : this;\n    ret.x /= pt.x;\n    ret.y /= pt.y;\n    return ret;\n  }\n  multiplyScalar(scalar, newInstance) {\n    Log.e(isNaN(+scalar), 'IPoint.multiply()', 'scalar argument must be a valid number: ', scalar);\n    let p1;\n    if (!newInstance) {\n      p1 = this;\n    } else {\n      p1 = this.duplicate();\n    }\n    p1.x *= scalar;\n    p1.y *= scalar;\n    return p1;\n  }\n  divideScalar(scalar, newInstance) {\n    Log.e(isNaN(+scalar), 'IPoint.divide()', 'scalar argument must be a valid number: ', scalar);\n    let p1;\n    if (!newInstance) {\n      p1 = this;\n    } else {\n      p1 = this.duplicate();\n    }\n    p1.x /= scalar;\n    p1.y /= scalar;\n    return p1;\n  }\n  isInTheMiddleOf(firstPt, secondPt, tolleranza) {\n    const rectangle = Size.fromPoints(firstPt, secondPt);\n    const tolleranzaX = tolleranza; // actually should be cos * arctan(m);\n    const tolleranzaY = tolleranza; // actually should be sin * arctan(m);\n    if (this.x < rectangle.x - tolleranzaX || this.x > rectangle.x + rectangle.w + tolleranzaX) {\n      return false;\n    }\n    if (this.y < rectangle.y - tolleranzaX || this.y > rectangle.y + rectangle.h + tolleranzaY) {\n      return false;\n    }\n    // const m = IPoint.getM(firstPt, secondPt);\n    // const q = IPoint.getQ(firstPt, secondPt);\n    const lineDistance = this.distanceFromLine(firstPt, secondPt);\n    // console.log('distance:', lineDistance, ', this:', this, ', p1:', firstPt, ', p2:', secondPt);\n    return lineDistance <= tolleranza;\n  }\n  distanceFromLine(p1, p2) {\n    const top = +(p2.y - p1.y) * this.x - (p2.x - p1.x) * this.y + p2.x * p1.y - p1.x * p2.y;\n    const bot = (p2.y - p1.y) * (p2.y - p1.y) + (p2.x - p1.x) * (p2.x - p1.x);\n    return Math.abs(top) / Math.sqrt(bot);\n  }\n  equals(pt) {\n    let tolleranzaX = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    let tolleranzaY = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    if (pt === null) {\n      return false;\n    }\n    return Math.abs(this.x - pt.x) <= tolleranzaX && Math.abs(this.y - pt.y) <= tolleranzaY;\n  }\n  moveOnNearestBorder(startVertexSize, clone, graph) {\n    let debug = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n    const pt = clone ? this.duplicate() : this;\n    const tl = startVertexSize.tl();\n    const tr = startVertexSize.tr();\n    const bl = startVertexSize.bl();\n    const br = startVertexSize.br();\n    const L = pt.distanceFromLine(tl, bl);\n    const R = pt.distanceFromLine(tr, br);\n    const T = pt.distanceFromLine(tl, tr);\n    const B = pt.distanceFromLine(bl, br);\n    const min = Math.min(L, R, T, B);\n    if (min === L) {\n      pt.x = tl.x;\n    }\n    if (min === R) {\n      pt.x = tr.x;\n    }\n    if (min === T) {\n      pt.y = tr.y;\n    }\n    if (min === B) {\n      pt.y = br.y;\n    }\n    if (debug && graph && pt instanceof GraphPoint) {\n      graph.markg(pt, false, 'purple');\n    }\n    return pt;\n  }\n  getM(pt2) {\n    var _IPoint$getM;\n    return (_IPoint$getM = IPoint.getM) === null || _IPoint$getM === void 0 ? void 0 : _IPoint$getM.call(IPoint, this, pt2);\n  }\n  degreeWith(pt2, toRadians) {\n    const directionVector = this.subtract(pt2, true);\n    const ret = Math.atan2(directionVector.y, directionVector.x);\n    return toRadians ? ret : windoww.U.RadToDegree(ret);\n  }\n  absolute() {\n    return Math.sqrt(this.x * this.x + this.y * this.y);\n  }\n  set(x, y) {\n    this.x = x;\n    this.y = y;\n  }\n}, _class2.getM = function (firstPt, secondPt) {\n  return (firstPt.y - secondPt.y) / (firstPt.x - secondPt.x);\n}, _class2.getQ = function (firstPt, secondPt) {\n  return firstPt.y - _class2.getM(firstPt, secondPt) * firstPt.x;\n}, _class2)) || _class;\nexport let GraphPoint = RuntimeAccessible(_class3 = class GraphPoint extends IPoint {\n  constructor() {\n    super(...arguments);\n    this.dontmixwithPoint = void 0;\n  }\n  static fromEvent(e) {\n    if (!e) {\n      return null;\n    }\n    const p = new Point(e.pageX, e.pageY);\n    const g = null;\n    throw new Error(\"todo: const g: IGraph = Status.status.getActiveModel().graph;\");\n    return g.toGraphCoord(p);\n  }\n  new() {\n    return new GraphPoint();\n  }\n}) || _class3;\nexport let Point = RuntimeAccessible(_class5 = class Point extends IPoint {\n  constructor() {\n    super(...arguments);\n    this.dontmixwithGPoint = void 0;\n  }\n  /// https://stackoverflow.com/questions/6073505/what-is-the-difference-between-screenx-y-clientx-y-and-pagex-y\n  static fromEvent(e) {\n    const p = new Point(e.pageX, e.pageY);\n    return p;\n  }\n  new() {\n    return new Point();\n  }\n}) || _class5;\nexport let ISize = RuntimeAccessible(_class7 = class ISize extends RuntimeAccessibleClass {\n  constructor() {\n    let x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    let y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    let w = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    let h = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n    super(); // super('dwc');\n    // do not override any fields from the DPointerTargetable, otherwise the ! in the override will reinizialize the attribute\n    // erasing the value set in super or in the functions called by the constructor as side effect (static_init called from constructor will be overridden too)\n    // if need to override types, build the \"new\" static function like in DModelElement\n    this.x = void 0;\n    this.y = void 0;\n    this.w = void 0;\n    this.h = void 0;\n    ISize.init_constructor(this, x, y, w, h);\n  }\n  static init_constructor(thiss) {\n    let x = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    let y = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    let w = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n    let h = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n    thiss.id = \"SIZE_\" + DPointerTargetable.maxID++ + \"_\" + new Date().getTime();\n    thiss.className = thiss.constructor.name;\n    if (x === null) thiss.x = null;else if (isNaN(+x)) {\n      thiss.x = 0;\n    } else thiss.x = +x;\n    if (y === null) thiss.y = null;else if (isNaN(+y)) {\n      thiss.y = 0;\n    } else thiss.y = +y;\n    if (w === null) thiss.w = null;else if (isNaN(+w)) {\n      thiss.w = 0;\n    } else thiss.w = +w;\n    if (h === null) thiss.h = null;else if (isNaN(+h)) {\n      thiss.h = 0;\n    } else thiss.h = +h;\n    thiss.className = this.name;\n  }\n  toString() {\n    return JSON.stringify({\n      x: this.x,\n      y: this.y,\n      w: this.w,\n      h: this.h\n    });\n  }\n  set(x, y, w, h) {\n    if (x !== undefined) this.x = +x;\n    if (y !== undefined) this.y = +y;\n    if (w !== undefined) this.w = +w;\n    if (h !== undefined) this.h = +h;\n  }\n  clone(json) {\n    this.x = json.x;\n    this.y = json.y;\n    this.w = json.w;\n    this.h = json.h;\n    return this;\n  }\n  duplicate() {\n    return this.new().clone(this);\n  }\n  add(pt2) {\n    this.x += pt2.x;\n    this.y += pt2.y;\n    if (!('w' in pt2)) return;\n    this.w += pt2.w;\n    this.h += pt2.h;\n  }\n  subtract(pt2) {\n    this.x -= pt2.x;\n    this.y -= pt2.y;\n    if (!('w' in pt2)) return this;\n    this.w -= pt2.w;\n    this.h -= pt2.h;\n    return this;\n  }\n  multiply(pt2) {\n    this.x *= pt2.x;\n    this.y *= pt2.y;\n    if (!('w' in pt2)) return;\n    this.w *= pt2.w;\n    this.h *= pt2.h;\n  }\n  divide(pt2) {\n    this.x /= pt2.x;\n    this.y /= pt2.y;\n    if (!('w' in pt2)) return;\n    this.w /= pt2.w;\n    this.h /= pt2.h;\n  }\n  tl() {\n    return this.makePoint(this.x, this.y);\n  }\n  tr() {\n    return this.makePoint(this.x + this.w, this.y);\n  }\n  bl() {\n    return this.makePoint(this.x, this.y + this.h);\n  }\n  br() {\n    return this.makePoint(this.x + this.w, this.y + this.h);\n  }\n  equals(size) {\n    return this.x === size.x && this.y === size.y && this.w === size.w && this.h === size.h;\n  }\n  /// field-wise Math.min()\n  min(minSize, clone) {\n    const ret = clone ? this.new() : this;\n    if (!isNaN(minSize.x) && ret.x < minSize.x) {\n      ret.x = minSize.x;\n    }\n    if (!isNaN(minSize.y) && ret.y < minSize.y) {\n      ret.y = minSize.y;\n    }\n    if (!isNaN(minSize.w) && ret.w < minSize.w) {\n      ret.w = minSize.w;\n    }\n    if (!isNaN(minSize.h) && ret.h < minSize.h) {\n      ret.h = minSize.h;\n    }\n    return ret;\n  }\n  max(maxSize, clone) {\n    const ret = clone ? this.new() : this;\n    if (!isNaN(maxSize.x) && ret.x > maxSize.x) {\n      ret.x = maxSize.x;\n    }\n    if (!isNaN(maxSize.y) && ret.y > maxSize.y) {\n      ret.y = maxSize.y;\n    }\n    if (!isNaN(maxSize.w) && ret.w > maxSize.w) {\n      ret.w = maxSize.w;\n    }\n    if (!isNaN(maxSize.h) && ret.h > maxSize.h) {\n      ret.h = maxSize.h;\n    }\n    return ret;\n  }\n  intersection(size) {\n    // anche \"isinside\"\n    let startx, starty, endx, endy;\n    startx = Math.max(this.x, size.x);\n    starty = Math.max(this.y, size.y);\n    endx = Math.min(this.x + this.w, size.x + size.w);\n    endy = Math.min(this.y + this.h, size.y + size.h);\n    const intersection = this.new();\n    // intersection.set(0, 0, 0, 0);\n    intersection.x = startx;\n    intersection.y = starty;\n    intersection.w = endx - startx;\n    intersection.h = endy - starty;\n    const doesintersect = intersection.w > 0 && intersection.h > 0;\n    return doesintersect ? intersection : null;\n  }\n  contains(pt) {\n    return pt.x >= this.x && pt.x <= this.x + this.w && pt.y >= this.y && pt.y <= this.y + this.h;\n  }\n  isOverlapping(size2) {\n    return !!this.intersection(size2);\n  }\n  isOverlappingAnyOf(sizes) {\n    if (!sizes) return false;\n    for (let size of sizes) {\n      if (this.isOverlapping(size)) return true;\n    }\n    return false;\n  }\n  multiplyPoint(other, newInstance) {\n    const ret = newInstance ? this.new() : this;\n    ret.x *= other.x;\n    ret.w *= other.x;\n    ret.y *= other.y;\n    ret.h *= other.y;\n    return ret;\n  }\n  dividePoint(other, newInstance) {\n    const ret = newInstance ? this.new() : this;\n    ret.x /= other.x;\n    ret.w /= other.x;\n    ret.y /= other.y;\n    ret.h /= other.y;\n    return ret;\n  }\n  boundary(size2) {\n    /*let minx, maxx, miny, maxy;\r\n    if (size2.y < this.y) { miny = size2.y; /*maxy = this.y;* / } else { miny = this.y; /*maxy = size2.y;* / }\r\n    if (size2.x < this.x) { minx = size2.y; /*maxx = this.x;* / } else { minx = this.x; /*maxy = size2.x;* / }\r\n    if (size2.y + size2.h < this.y + this.h) maxy = this.y + this.h; else maxy = size2.y + size2.h;\r\n    if (size2.x + size2.w < this.x + this.w) maxx = this.x + this.w; else maxx = size2.x + size2.w;\r\n    */\n    this.h = size2.y + size2.h > this.y + this.h ? size2.y + size2.h : this.y + this.h; // -miny\n    this.w = size2.x + size2.w > this.x + this.w ? size2.x + size2.w : this.x + this.w; // -minx\n    if (this.y < size2.y) this.y = size2.y;\n    if (this.x < size2.x) this.x = size2.x;\n    this.h -= this.y;\n    this.w -= this.x;\n  }\n}) || _class7;\nexport let Size = RuntimeAccessible(_class9 = (_class10 = class Size extends ISize {\n  constructor() {\n    super(...arguments);\n    this.dontMixWithGraphSize = void 0;\n  }\n  static of(element0) {\n    let debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    let element = element0;\n    Log.l(debug, 'sizeof()', element);\n    Log.e(element === document, 'trying to measure document.');\n    if (element === document) {\n      element = document.body;\n    }\n    const $element = $(element);\n    Log.e(!element || element.tagName === 'foreignObject', 'sizeof()', 'SvgForeignElementObject have a bug with size, measure a child instead.', element);\n    let tmp;\n    let size;\n    if (!Size.sizeofvar) {\n      Size.sizeofvar = document.createElement('div');\n      document.body.append(Size.sizeofvar);\n    }\n    const isOrphan = element.parentNode === null;\n    // var visible = element.style.display !== 'none';\n    // var visible = $element.is(\":visible\"); crea bug quando un elemento è teoricamente visibile ma orfano\n    const ancestors = windoww.U.ancestorArray(element);\n    const displayStyles = ancestors.map(e => {\n      var _e$style;\n      return e === null || e === void 0 ? void 0 : (_e$style = e.style) === null || _e$style === void 0 ? void 0 : _e$style.display;\n    });\n    if (isOrphan) {\n      Size.sizeofvar.append(element);\n    }\n    // show all and saveToDB visibility to restore it later\n    for (let i = 0; i < ancestors.length; i++) {\n      var _ancestors$i, _ancestors$i$style;\n      // document has undefined style\n      displayStyles[i] = (_ancestors$i = ancestors[i]) === null || _ancestors$i === void 0 ? void 0 : (_ancestors$i$style = _ancestors$i.style) === null || _ancestors$i$style === void 0 ? void 0 : _ancestors$i$style.display;\n      if (displayStyles[i] === 'none' || displayStyles[i] === '' && getComputedStyle(ancestors[i]).display === 'none') {\n        ancestors[i].style.display = 'block';\n      }\n    }\n    tmp = $element.offset(); // made sure cannot be undefined by removing display:none\n    size = new Size(tmp.left, tmp.top, 0, 0);\n    tmp = element.getBoundingClientRect();\n    size.w = tmp.width;\n    size.h = tmp.height;\n    // restore visibility\n    for (let i = 0; i < ancestors.length; i++) {\n      var _ancestors$i$style2;\n      if (displayStyles[i] === ((_ancestors$i$style2 = ancestors[i].style) === null || _ancestors$i$style2 === void 0 ? void 0 : _ancestors$i$style2.display)) continue;\n      if (displayStyles[i]) ancestors[i].style.display = displayStyles[i];else ancestors[i].style.removeProperty('display');\n    }\n    if (isOrphan) {\n      windoww.U.clear(Size.sizeofvar);\n    }\n    // Status.status.getActiveModel().graph.markS(size, false);\n    return size;\n  }\n  static fromPoints(firstPt, secondPt) {\n    const minX = Math.min(firstPt.x, secondPt.x);\n    const maxX = Math.max(firstPt.x, secondPt.x);\n    const minY = Math.min(firstPt.y, secondPt.y);\n    const maxY = Math.max(firstPt.y, secondPt.y);\n    return new Size(minX, minY, maxX - minX, maxY - minY);\n  }\n  makePoint(x, y) {\n    return new Point(x, y);\n  }\n  new() {\n    return new Size();\n  }\n}, _class10.sizeofvar = void 0, _class10.$sizeofvar = void 0, _class10)) || _class9;\nexport let GraphSize = RuntimeAccessible(_class11 = class GraphSize extends ISize {\n  constructor() {\n    super(...arguments);\n    this.dontMixWithSize = void 0;\n  }\n  static fromPoints(firstPt, secondPt) {\n    const minX = Math.min(firstPt.x, secondPt.x);\n    const maxX = Math.max(firstPt.x, secondPt.x);\n    const minY = Math.min(firstPt.y, secondPt.y);\n    const maxY = Math.max(firstPt.y, secondPt.y);\n    return new GraphSize(minX, minY, maxX - minX, maxY - minY);\n  }\n  static closestIntersection(vertexGSize, prevPt, pt0, gridAlign) {\n    var _GraphPoint$getM, _GraphPoint$getQ;\n    let pt = pt0.duplicate();\n    const m = (_GraphPoint$getM = GraphPoint.getM) === null || _GraphPoint$getM === void 0 ? void 0 : _GraphPoint$getM.call(GraphPoint, prevPt, pt);\n    const q = (_GraphPoint$getQ = GraphPoint.getQ) === null || _GraphPoint$getQ === void 0 ? void 0 : _GraphPoint$getQ.call(GraphPoint, prevPt, pt);\n    // U.pe( Math.abs((pt.y - m * pt.x) - (prevPt.y - m * prevPt.x)) > .001, 'wrong math in Q:', (pt.y - m * pt.x), ' vs ', (prevPt.y - m * prevPt.x));\n    /*const isL = prevPt.x < pt.x;\r\n    const isT = prevPt.y < pt.y;\r\n    const isR = !isL;\r\n    const isB = !isT; */\n    if (m === Number.POSITIVE_INFINITY && q === Number.NEGATIVE_INFINITY) {\n      // bottom middle\n      return new GraphPoint(vertexGSize.x + vertexGSize.w / 2, vertexGSize.y + vertexGSize.h);\n    }\n    // console.log('pt:', pt, 'm:', m, 'q:', q);\n    let L = new GraphPoint(0, 0);\n    let T = new GraphPoint(0, 0);\n    let R = new GraphPoint(0, 0);\n    let B = new GraphPoint(0, 0);\n    L.x = vertexGSize.x;\n    L.y = m * L.x + q;\n    R.x = vertexGSize.x + vertexGSize.w;\n    R.y = m * R.x + q;\n    T.y = vertexGSize.y;\n    T.x = (T.y - q) / m;\n    B.y = vertexGSize.y + vertexGSize.h;\n    B.x = (B.y - q) / m;\n    // prendo solo il compreso pt ~ prevPt (escludo così il \"pierce\" sulla faccia opposta), prendo il più vicino al centro.\n    // console.log('4 possibili punti di intersezione (LTBR):', L, T, B, R);\n    /* this.owner.mark(this.owner.toHtmlCoord(T), true, 'blue');\r\n    this.owner.mark(this.owner.toHtmlCoord(B), false, 'violet');\r\n    this.owner.mark(this.owner.toHtmlCoord(L), false, 'red');\r\n    this.owner.mark(this.owner.toHtmlCoord(R), false, 'orange');*/\n    if (B.x >= pt.x && B.x <= prevPt.x || B.x >= prevPt.x && B.x <= pt.x) {} else {\n      B = null;\n    }\n    if (T.x >= pt.x && T.x <= prevPt.x || T.x >= prevPt.x && T.x <= pt.x) {} else {\n      T = null;\n    }\n    if (L.y >= pt.y && L.y <= prevPt.y || L.y >= prevPt.y && L.y <= pt.y) {} else {\n      L = null;\n    }\n    if (R.y >= pt.y && R.y <= prevPt.y || R.y >= prevPt.y && R.y <= pt.y) {} else {\n      R = null;\n    }\n    // console.log('superstiti step1: (LTBR):', L, T, B, R);\n    const vicinanzaT = !T ? Number.POSITIVE_INFINITY : (T.x - pt.x) * (T.x - pt.x) + (T.y - pt.y) * (T.y - pt.y);\n    const vicinanzaB = !B ? Number.POSITIVE_INFINITY : (B.x - pt.x) * (B.x - pt.x) + (B.y - pt.y) * (B.y - pt.y);\n    const vicinanzaL = !L ? Number.POSITIVE_INFINITY : (L.x - pt.x) * (L.x - pt.x) + (L.y - pt.y) * (L.y - pt.y);\n    const vicinanzaR = !R ? Number.POSITIVE_INFINITY : (R.x - pt.x) * (R.x - pt.x) + (R.y - pt.y) * (R.y - pt.y);\n    const closest = Math.min(vicinanzaT, vicinanzaB, vicinanzaL, vicinanzaR);\n    // console.log( 'closest:', closest);\n    // succede quando pt e prevPt sono entrambi all'interno del rettangolo del vertice.\n    // L'edge non è visibile e il valore ritornato è irrilevante.\n    if (closest === Number.POSITIVE_INFINITY) {\n      /* top center */\n      pt = vertexGSize.tl();\n      pt.x += vertexGSize.w / 2;\n    } else if (closest === Number.POSITIVE_INFINITY) {\n      /* bottom center */\n      pt = vertexGSize.br();\n      pt.x -= vertexGSize.w / 2;\n    } else if (closest === vicinanzaT) {\n      pt = T;\n    } else if (closest === vicinanzaB) {\n      pt = B;\n    } else if (closest === vicinanzaR) {\n      pt = R;\n    } else if (closest === vicinanzaL) {\n      pt = L;\n    }\n    if (!gridAlign) {\n      return pt;\n    }\n    if (!pt) return null;\n    if ((pt === T || pt === B || isNaN(closest)) && gridAlign.x) {\n      const floorX = Math.floor(pt.x / gridAlign.x) * gridAlign.x;\n      const ceilX = Math.ceil(pt.x / gridAlign.x) * gridAlign.x;\n      let closestX;\n      let farthestX;\n      if (Math.abs(floorX - pt.x) < Math.abs(ceilX - pt.x)) {\n        closestX = floorX;\n        farthestX = ceilX;\n      } else {\n        closestX = ceilX;\n        farthestX = floorX;\n      }\n\n      // todo: possibile causa del bug che non allinea punti fake a punti reali. nel calcolo realPT questo non viene fatto.\n      // if closest grid intersection is inside the vertex.\n      if (closestX >= vertexGSize.x && closestX <= vertexGSize.x + vertexGSize.w) {\n        pt.x = closestX;\n      } else\n        // if 2° closer grid intersection is inside the vertex.\n        if (closestX >= vertexGSize.x && closestX <= vertexGSize.x + vertexGSize.w) {\n          pt.x = farthestX;\n          // if no intersection are inside the vertex (ignore grid)\n        } else {/* do nothing */}\n    } else if ((pt === L || pt === R) && gridAlign.y) {\n      const floorY = Math.floor(pt.y / gridAlign.y) * gridAlign.y;\n      const ceilY = Math.ceil(pt.y / gridAlign.y) * gridAlign.y;\n      let closestY;\n      let farthestY;\n      if (Math.abs(floorY - pt.y) < Math.abs(ceilY - pt.y)) {\n        closestY = floorY;\n        farthestY = ceilY;\n      } else {\n        closestY = ceilY;\n        farthestY = floorY;\n      }\n\n      // if closest grid intersection is inside the vertex.\n      if (closestY >= vertexGSize.y && closestY <= vertexGSize.y + vertexGSize.h) {\n        pt.y = closestY;\n      } else\n        // if 2° closer grid intersection is inside the vertex.\n        if (closestY >= vertexGSize.y && closestY <= vertexGSize.y + vertexGSize.h) {\n          pt.y = farthestY;\n          // if no intersection are inside the vertex (ignore grid)\n        } else {/* do nothing */}\n    }\n    return pt;\n  }\n  new() {\n    return new GraphSize();\n  }\n  makePoint(x, y) {\n    return new GraphPoint(x, y);\n  }\n}) || _class11;","map":{"version":3,"names":["DPointerTargetable","RuntimeAccessible","windoww","Log","RuntimeAccessibleClass","IPoint","_class","_class2","constructor","x","arguments","length","undefined","y","init_constructor","thiss","id","maxID","Date","getTime","className","name","isNaN","toString","clone","other","duplicate","ret","new","subtract","p2","newInstance","e","p1","add","addAll","p","i","p0","subtractAll","multiply","pt","divide","multiplyScalar","scalar","divideScalar","isInTheMiddleOf","firstPt","secondPt","tolleranza","rectangle","Size","fromPoints","tolleranzaX","tolleranzaY","w","h","lineDistance","distanceFromLine","top","bot","Math","abs","sqrt","equals","moveOnNearestBorder","startVertexSize","graph","debug","tl","tr","bl","br","L","R","T","B","min","GraphPoint","markg","getM","pt2","_IPoint$getM","call","degreeWith","toRadians","directionVector","atan2","U","RadToDegree","absolute","set","getQ","_class3","dontmixwithPoint","fromEvent","Point","pageX","pageY","g","Error","toGraphCoord","_class5","dontmixwithGPoint","ISize","_class7","JSON","stringify","json","makePoint","size","minSize","max","maxSize","intersection","startx","starty","endx","endy","doesintersect","contains","isOverlapping","size2","isOverlappingAnyOf","sizes","multiplyPoint","dividePoint","boundary","_class9","_class10","dontMixWithGraphSize","of","element0","element","l","document","body","$element","$","tagName","tmp","sizeofvar","createElement","append","isOrphan","parentNode","ancestors","ancestorArray","displayStyles","map","_e$style","style","display","_ancestors$i","_ancestors$i$style","getComputedStyle","offset","left","getBoundingClientRect","width","height","_ancestors$i$style2","removeProperty","clear","minX","maxX","minY","maxY","$sizeofvar","GraphSize","_class11","dontMixWithSize","closestIntersection","vertexGSize","prevPt","pt0","gridAlign","_GraphPoint$getM","_GraphPoint$getQ","m","q","Number","POSITIVE_INFINITY","NEGATIVE_INFINITY","vicinanzaT","vicinanzaB","vicinanzaL","vicinanzaR","closest","floorX","floor","ceilX","ceil","closestX","farthestX","floorY","ceilY","closestY","farthestY"],"sources":["C:/0Programmi/Dev/projects/frontend/jjodel/src/common/Geom.ts"],"sourcesContent":["import type { GObject, Temporary, TODO} from \"../joiner\";\r\nimport {DPointerTargetable, RuntimeAccessible, windoww, Log, RuntimeAccessibleClass} from \"../joiner\";\r\n\r\n@RuntimeAccessible\r\nexport abstract class IPoint extends RuntimeAccessibleClass {\r\n    public x!: number;\r\n    public y!: number;\r\n\r\n    public static getM? = function(firstPt: IPoint, secondPt: IPoint): number { return (firstPt.y - secondPt.y) / (firstPt.x - secondPt.x); }\r\n    // @ts-ignore static getM is not null but must be declared nullable to achieve subclass mixing\r\n    public static getQ? = function(firstPt: IPoint, secondPt: IPoint): number { return firstPt.y - (IPoint.getM(firstPt, secondPt) * firstPt.x);  }\r\n\r\n    public constructor(x: number = 0, y: number = 0) {\r\n        super(); // super('dwc');\r\n        IPoint.init_constructor(this, x, y);\r\n    }\r\n\r\n    static init_constructor(thiss: GObject, x: any = 0, y: any = 0, ...a: any): void {\r\n        thiss.id = \"POINT_\" + (DPointerTargetable.maxID++) + \"_\" + new Date().getTime();\r\n        thiss.className = thiss.constructor.name;\r\n        if (x === null) thiss.x = null as Temporary;\r\n        else if (isNaN(+x)) { thiss.x = 0; }\r\n        else thiss.x = +x;\r\n        if (y === null) thiss.y = null as Temporary;\r\n        else if (isNaN(+y)) { thiss.y = 0; }\r\n        else thiss.y = +y;\r\n        thiss.className = this.name;\r\n    }\r\n\r\n    public toString(): string { return '(' + this.x + ', ' + this.y + ')'; }\r\n    public clone(other: { x: number, y: number }): this { this.x = other.x; this.y = other.y; return this; }\r\n\r\n    protected abstract new(): this;\r\n    public duplicate(): this { const ret = this.new(); ret.clone(this); return ret; }\r\n\r\n    public subtract(p2: IPoint, newInstance: boolean): this {\r\n        Log.e(!p2, 'subtract argument must be a valid point: ', p2);\r\n        let p1: this;\r\n        if (!newInstance) { p1 = this; } else { p1 = this.duplicate(); }\r\n        p1.x -= p2.x;\r\n        p1.y -= p2.y;\r\n        return p1; }\r\n\r\n    public add(p2: IPoint, newInstance: boolean): this {\r\n        Log.e(!p2, 'add argument must be a valid point: ', p2);\r\n        let p1: this;\r\n        if (!newInstance) { p1 = this; } else { p1 = this.duplicate(); }\r\n        p1.x += p2.x;\r\n        p1.y += p2.y;\r\n        return p1; }\r\n\r\n    public addAll(p: IPoint[], newInstance: boolean): this {\r\n        let i;\r\n        let p0: this;\r\n        if (!newInstance) { p0 = this; } else { p0 = this.duplicate(); }\r\n        for (i = 0; i < p.length; i++) { p0.add(p[i], true); }\r\n        return p0; }\r\n\r\n    public subtractAll(p: this[], newInstance: boolean): this {\r\n        let i;\r\n        let p0: this;\r\n        if (!newInstance) { p0 = this; } else { p0 = this.duplicate(); }\r\n        for (i = 0; i < p.length; i++) { p0.subtract(p[i], true); }\r\n        return p0; }\r\n\r\n    public multiply(pt: this, newInstance: boolean = false): this {\r\n        let ret: this = (newInstance ? this.duplicate() : this);\r\n        ret.x *= pt.x;\r\n        ret.y *= pt.y;\r\n        return ret; }\r\n\r\n    public divide(pt: this, newInstance: boolean = false): this {\r\n        let ret = (newInstance ? this.duplicate() : this);\r\n        ret.x /= pt.x;\r\n        ret.y /= pt.y;\r\n        return ret; }\r\n\r\n    public multiplyScalar(scalar: number, newInstance: boolean): this {\r\n        Log.e(isNaN(+scalar), 'IPoint.multiply()', 'scalar argument must be a valid number: ', scalar);\r\n        let p1: this;\r\n        if (!newInstance) { p1 = this; } else { p1 = this.duplicate(); }\r\n        p1.x *= scalar;\r\n        p1.y *= scalar;\r\n        return p1; }\r\n\r\n    public divideScalar(scalar: number, newInstance: boolean): this {\r\n        Log.e(isNaN(+scalar), 'IPoint.divide()', 'scalar argument must be a valid number: ', scalar);\r\n        let p1: this;\r\n        if (!newInstance) { p1 = this; } else { p1 = this.duplicate(); }\r\n        p1.x /= scalar;\r\n        p1.y /= scalar;\r\n        return p1; }\r\n\r\n    public isInTheMiddleOf(firstPt: this, secondPt: this, tolleranza: number): boolean {\r\n        const rectangle: Size = Size.fromPoints(firstPt, secondPt);\r\n        const tolleranzaX = tolleranza; // actually should be cos * arctan(m);\r\n        const tolleranzaY = tolleranza; // actually should be sin * arctan(m);\r\n        if (this.x < rectangle.x - tolleranzaX || this.x > rectangle.x + rectangle.w + tolleranzaX) { return false; }\r\n        if (this.y < rectangle.y - tolleranzaX || this.y > rectangle.y + rectangle.h + tolleranzaY) { return false; }\r\n        // const m = IPoint.getM(firstPt, secondPt);\r\n        // const q = IPoint.getQ(firstPt, secondPt);\r\n        const lineDistance = this.distanceFromLine(firstPt, secondPt);\r\n        // console.log('distance:', lineDistance, ', this:', this, ', p1:', firstPt, ', p2:', secondPt);\r\n        return lineDistance <= tolleranza; }\r\n\r\n    public distanceFromLine(p1: IPoint, p2: IPoint): number {\r\n        const top: number =\r\n            + (p2.y - p1.y) * this.x\r\n            - (p2.x - p1.x) * this.y\r\n            + p2.x * p1.y\r\n            - p1.x * p2.y;\r\n        const bot =\r\n            (p2.y - p1.y) * (p2.y - p1.y) +\r\n            (p2.x - p1.x) * (p2.x - p1.x);\r\n        return Math.abs(top) / Math.sqrt(bot);  }\r\n\r\n    public equals(pt: IPoint, tolleranzaX: number = 0, tolleranzaY: number = 0): boolean {\r\n        if (pt === null) { return false; }\r\n        return Math.abs(this.x - pt.x) <= tolleranzaX && Math.abs(this.y - pt.y) <= tolleranzaY; }\r\n\r\n    public moveOnNearestBorder(startVertexSize: ISize, clone: boolean, graph: TODO/*IGraph*/, debug: boolean = true): IPoint {\r\n        const pt: IPoint = clone ? this.duplicate() : this;\r\n        const tl: IPoint = startVertexSize.tl();\r\n        const tr: IPoint = startVertexSize.tr();\r\n        const bl: IPoint = startVertexSize.bl();\r\n        const br: IPoint = startVertexSize.br();\r\n        const L: number = pt.distanceFromLine(tl, bl);\r\n        const R: number = pt.distanceFromLine(tr, br);\r\n        const T: number = pt.distanceFromLine(tl, tr);\r\n        const B: number = pt.distanceFromLine(bl, br);\r\n        const min: number = Math.min(L, R, T, B);\r\n        if (min === L) { pt.x = tl.x; }\r\n        if (min === R) { pt.x = tr.x; }\r\n        if (min === T) { pt.y = tr.y; }\r\n        if (min === B) { pt.y = br.y; }\r\n        if (debug && graph && pt instanceof GraphPoint) { graph.markg(pt, false, 'purple'); }\r\n        return pt; }\r\n\r\n    public getM(pt2: IPoint): number { return IPoint.getM?.(this, pt2) as unknown as number; }\r\n\r\n    public degreeWith(pt2: IPoint, toRadians: boolean): number {\r\n        const directionVector: IPoint = this.subtract(pt2, true);\r\n        const ret: number = Math.atan2(directionVector.y, directionVector.x);\r\n        return toRadians ? ret : windoww.U.RadToDegree(ret); }\r\n\r\n    public absolute(): number { return Math.sqrt(this.x * this.x + this.y * this.y); }\r\n    public set(x: number, y: number) { this.x = x; this.y = y; }\r\n}\r\n\r\n@RuntimeAccessible\r\nexport class GraphPoint extends IPoint{\r\n    private dontmixwithPoint: any;\r\n    public static fromEvent(e: JQuery.ClickEvent | JQuery.MouseMoveEvent | JQuery.MouseUpEvent | JQuery.MouseDownEvent | JQuery.MouseEnterEvent | JQuery.MouseLeaveEvent | JQuery.MouseEventBase)\r\n        : GraphPoint | null {\r\n        if (!e) { return null; }\r\n        const p: Point = new Point(e.pageX, e.pageY);\r\n        const g: any = null;\r\n        throw new Error(\"todo: const g: IGraph = Status.status.getActiveModel().graph;\");\r\n        return g.toGraphCoord(p); }\r\n\r\n    protected new(): this { return new GraphPoint() as this;}\r\n}\r\n\r\n@RuntimeAccessible\r\nexport class Point extends IPoint{\r\n    private dontmixwithGPoint: any;\r\n    /// https://stackoverflow.com/questions/6073505/what-is-the-difference-between-screenx-y-clientx-y-and-pagex-y\r\n    public static fromEvent(e: JQuery.ClickEvent | JQuery.MouseMoveEvent | JQuery.MouseUpEvent | JQuery.MouseDownEvent | JQuery.MouseEnterEvent | JQuery.MouseLeaveEvent | JQuery.MouseEventBase)\r\n        : Point {\r\n        const p: Point = new Point(e.pageX, e.pageY);\r\n        return p; }\r\n\r\n    protected new(): this { return new Point() as this;}\r\n}\r\n\r\n\r\n@RuntimeAccessible\r\nexport abstract class ISize<PT extends IPoint = IPoint> extends RuntimeAccessibleClass {\r\n    public x!: number;\r\n    public y!: number;\r\n    public w!: number;\r\n    public h!: number;\r\n    public constructor(x: number = 0, y: number = 0, w: number = 0, h: number = 0) {\r\n        super(); // super('dwc');\r\n        // do not override any fields from the DPointerTargetable, otherwise the ! in the override will reinizialize the attribute\r\n        // erasing the value set in super or in the functions called by the constructor as side effect (static_init called from constructor will be overridden too)\r\n        // if need to override types, build the \"new\" static function like in DModelElement\r\n        ISize.init_constructor(this, x, y, w, h);\r\n    }\r\n\r\n    static init_constructor(thiss: GObject, x: any = 0, y: any = 0, w: any = 0, h: any = 0, ...a: any): void {\r\n        thiss.id = \"SIZE_\" + (DPointerTargetable.maxID++) + \"_\" + new Date().getTime();\r\n        thiss.className = thiss.constructor.name;\r\n        if (x === null) thiss.x = null as Temporary;\r\n        else if (isNaN(+x)) { thiss.x = 0; }\r\n        else thiss.x = +x;\r\n        if (y === null) thiss.y = null as Temporary;\r\n        else if (isNaN(+y)) { thiss.y = 0; }\r\n        else thiss.y = +y;\r\n        if (w === null) thiss.w = null as Temporary;\r\n        else if (isNaN(+w)) { thiss.w = 0; }\r\n        else thiss.w = +w;\r\n        if (h === null) thiss.h = null as Temporary;\r\n        else if (isNaN(+h)) { thiss.h = 0; }\r\n        else thiss.h = +h;\r\n        thiss.className = this.name; }\r\n\r\n    public toString(): string { return JSON.stringify({x: this.x, y: this.y, w: this.w, h: this.h}); }\r\n\r\n    public set(x?: number, y?: number, w?: number, h?: number): void {\r\n        if (x !== undefined) (this.x = +x);\r\n        if (y !== undefined) (this.y = +y);\r\n        if (w !== undefined) (this.w = +w);\r\n        if (h !== undefined) (this.h = +h);\r\n    }\r\n\r\n    protected abstract makePoint(x: number, y: number): PT;\r\n    protected abstract new(): this;\r\n    public clone(json: this): this { this.x = json.x; this.y = json.y; this.w = json.w; this.h = json.h; return this; }\r\n    public duplicate(): this { return this.new().clone(this); }\r\n\r\n    public add(pt2: this | PT): void {\r\n        this.x += pt2.x;\r\n        this.y += pt2.y;\r\n        if (!('w' in pt2)) return;\r\n        this.w += (pt2 as ISize).w;\r\n        this.h += (pt2 as ISize).h; }\r\n\r\n    public subtract(pt2: this | PT): this {\r\n        this.x -= pt2.x;\r\n        this.y -= pt2.y;\r\n        if (!('w' in pt2)) return this;\r\n        this.w -= (pt2 as ISize).w;\r\n        this.h -= (pt2 as ISize).h; return this; }\r\n\r\n    public multiply(pt2: this | PT): void {\r\n        this.x *= pt2.x;\r\n        this.y *= pt2.y;\r\n        if (!('w' in pt2)) return;\r\n        this.w *= (pt2 as ISize).w;\r\n        this.h *= (pt2 as ISize).h; }\r\n\r\n    public divide(pt2: this | PT): void {\r\n        this.x /= pt2.x;\r\n        this.y /= pt2.y;\r\n        if (!('w' in pt2)) return;\r\n        this.w /= (pt2 as ISize).w;\r\n        this.h /= (pt2 as ISize).h; }\r\n\r\n    public tl(): PT { return this.makePoint(   this.x,             this.y         ); }\r\n    public tr(): PT { return this.makePoint(this.x + this.w,    this.y         ); }\r\n    public bl(): PT { return this.makePoint(   this.x,          this.y + this.h); }\r\n    public br(): PT { return this.makePoint(this.x + this.w, this.y + this.h); }\r\n    public equals(size: this): boolean { return this.x === size.x && this.y === size.y && this.w === size.w && this.h === size.h; }\r\n    /// field-wise Math.min()\r\n    public min(minSize: this, clone: boolean): this {\r\n        const ret: this = clone ? this.new() : this;\r\n        if (!isNaN(minSize.x) && ret.x < minSize.x) { ret.x = minSize.x; }\r\n        if (!isNaN(minSize.y) && ret.y < minSize.y) { ret.y = minSize.y; }\r\n        if (!isNaN(minSize.w) && ret.w < minSize.w) { ret.w = minSize.w; }\r\n        if (!isNaN(minSize.h) && ret.h < minSize.h) { ret.h = minSize.h; }\r\n        return ret; }\r\n    public max(maxSize: this, clone: boolean): this {\r\n        const ret: this = clone ? this.new() : this;\r\n        if (!isNaN(maxSize.x) && ret.x > maxSize.x) { ret.x = maxSize.x; }\r\n        if (!isNaN(maxSize.y) && ret.y > maxSize.y) { ret.y = maxSize.y; }\r\n        if (!isNaN(maxSize.w) && ret.w > maxSize.w) { ret.w = maxSize.w; }\r\n        if (!isNaN(maxSize.h) && ret.h > maxSize.h) { ret.h = maxSize.h; }\r\n        return ret; }\r\n\r\n    public intersection(size: this): this | null {\r\n        // anche \"isinside\"\r\n        let startx, starty, endx, endy;\r\n        startx = Math.max(this.x, size.x);\r\n        starty = Math.max(this.y, size.y);\r\n        endx = Math.min(this.x + this.w, size.x + size.w);\r\n        endy = Math.min(this.y + this.h, size.y + size.h);\r\n        const intersection: this = this.new();\r\n        // intersection.set(0, 0, 0, 0);\r\n        intersection.x = startx;\r\n        intersection.y = starty;\r\n        intersection.w = endx - startx;\r\n        intersection.h = endy - starty;\r\n        const doesintersect: boolean = intersection.w > 0 && intersection.h > 0;\r\n        return (doesintersect) ? intersection: null; }\r\n\r\n    public contains(pt: PT): boolean {\r\n        return  pt.x >= this.x && pt.x <= this.x + this.w && pt.y >= this.y && pt.y <= this.y + this.h; }\r\n\r\n    public isOverlapping(size2: this): boolean { return !!this.intersection(size2); }\r\n    public isOverlappingAnyOf(sizes: this[]): boolean {\r\n        if (!sizes) return false;\r\n        for (let size of sizes) { if (this.isOverlapping(size)) return true; }\r\n        return false;\r\n    }\r\n\r\n    public multiplyPoint(other: PT, newInstance: boolean): this {\r\n        const ret: this = newInstance ? this.new() : this;\r\n        ret.x *= other.x;\r\n        ret.w *= other.x;\r\n        ret.y *= other.y;\r\n        ret.h *= other.y;\r\n        return ret; }\r\n\r\n    public dividePoint(other: PT, newInstance: boolean): this {\r\n        const ret: this = newInstance ? this.new() : this;\r\n        ret.x /= other.x;\r\n        ret.w /= other.x;\r\n        ret.y /= other.y;\r\n        ret.h /= other.y;\r\n        return ret; }\r\n\r\n    public boundary(size2: this): void {\r\n        /*let minx, maxx, miny, maxy;\r\n        if (size2.y < this.y) { miny = size2.y; /*maxy = this.y;* / } else { miny = this.y; /*maxy = size2.y;* / }\r\n        if (size2.x < this.x) { minx = size2.y; /*maxx = this.x;* / } else { minx = this.x; /*maxy = size2.x;* / }\r\n        if (size2.y + size2.h < this.y + this.h) maxy = this.y + this.h; else maxy = size2.y + size2.h;\r\n        if (size2.x + size2.w < this.x + this.w) maxx = this.x + this.w; else maxx = size2.x + size2.w;\r\n        */\r\n        this.h = (size2.y + size2.h > this.y + this.h ? size2.y + size2.h : this.y + this.h); // -miny\r\n        this.w = (size2.x + size2.w > this.x + this.w ? size2.x + size2.w : this.x + this.w); // -minx\r\n        if (this.y < size2.y) this.y = size2.y;\r\n        if (this.x < size2.x) this.x = size2.x;\r\n        this.h -= this.y;\r\n        this.w -= this.x;\r\n    }\r\n}\r\n\r\n@RuntimeAccessible\r\nexport class Size extends ISize<Point> {\r\n    private static sizeofvar: HTMLElement;\r\n    private static $sizeofvar: JQuery<HTMLElement>;\r\n    private dontMixWithGraphSize: any;\r\n\r\n    public static of(element0: Element, debug: boolean = false): Size {\r\n        let element: HTMLElement = element0 as HTMLElement;\r\n        Log.l(debug, 'sizeof()',  element);\r\n        Log.e(element as any === document, 'trying to measure document.');\r\n        if (element as any === document) { element = document.body as any; }\r\n        const $element = $(element);\r\n        Log.e(!element || element.tagName === 'foreignObject', 'sizeof()', 'SvgForeignElementObject have a bug with size, measure a child instead.', element);\r\n        let tmp;\r\n        let size: Size;\r\n        if (!Size.sizeofvar) {\r\n            Size.sizeofvar = document.createElement('div');\r\n            document.body.append(Size.sizeofvar); }\r\n\r\n        const isOrphan = element.parentNode === null;\r\n        // var visible = element.style.display !== 'none';\r\n        // var visible = $element.is(\":visible\"); crea bug quando un elemento è teoricamente visibile ma orfano\r\n        const ancestors =  windoww.U.ancestorArray(element);\r\n        const displayStyles: string[] = ancestors.map( (e: HTMLElement) => e?.style?.display);\r\n        if (isOrphan) { Size.sizeofvar.append(element); }\r\n        // show all and saveToDB visibility to restore it later\r\n        for (let i = 0; i < ancestors.length; i++) { // document has undefined style\r\n            displayStyles[i] = ancestors[i]?.style?.display;\r\n            if (displayStyles[i] === 'none' || (displayStyles[i] === '' && getComputedStyle(ancestors[i]).display === 'none')) { ancestors[i].style.display = 'block' }\r\n        }\r\n        tmp = $element.offset() as JQuery.Coordinates; // made sure cannot be undefined by removing display:none\r\n        size = new Size(tmp.left, tmp.top, 0, 0);\r\n        tmp = element.getBoundingClientRect();\r\n        size.w = tmp.width;\r\n        size.h = tmp.height;\r\n        // restore visibility\r\n        for (let i = 0; i < ancestors.length; i++) {\r\n            if (displayStyles[i] === ancestors[i].style?.display) continue;\r\n            if (displayStyles[i]) ancestors[i].style.display = displayStyles[i];\r\n            else ancestors[i].style.removeProperty('display');\r\n        }\r\n        if (isOrphan) {  windoww.U.clear(Size.sizeofvar); }\r\n        // Status.status.getActiveModel().graph.markS(size, false);\r\n        return size;\r\n    }\r\n\r\n    public static fromPoints(firstPt: IPoint, secondPt: IPoint): Size {\r\n        const minX = Math.min(firstPt.x, secondPt.x);\r\n        const maxX = Math.max(firstPt.x, secondPt.x);\r\n        const minY = Math.min(firstPt.y, secondPt.y);\r\n        const maxY = Math.max(firstPt.y, secondPt.y);\r\n        return new Size(minX, minY, maxX - minX, maxY - minY); }\r\n\r\n    protected makePoint(x: number, y: number): Point { return new Point(x, y); }\r\n    protected new(): this { return new Size() as this; }\r\n}\r\n\r\n@RuntimeAccessible\r\nexport class GraphSize extends ISize<GraphPoint> {\r\n    private dontMixWithSize: any;\r\n\r\n    public static fromPoints(firstPt: GraphPoint, secondPt: GraphPoint): GraphSize {\r\n        const minX = Math.min(firstPt.x, secondPt.x);\r\n        const maxX = Math.max(firstPt.x, secondPt.x);\r\n        const minY = Math.min(firstPt.y, secondPt.y);\r\n        const maxY = Math.max(firstPt.y, secondPt.y);\r\n        return new GraphSize(minX, minY, maxX - minX, maxY - minY); }\r\n\r\n    public static closestIntersection(vertexGSize: GraphSize, prevPt: GraphPoint, pt0: GraphPoint, gridAlign?: GraphPoint): GraphPoint | null {\r\n        let pt: GraphPoint | null = pt0.duplicate();\r\n        const m = GraphPoint.getM?.(prevPt, pt) as number;\r\n        const q = GraphPoint.getQ?.(prevPt, pt) as number;\r\n        // U.pe( Math.abs((pt.y - m * pt.x) - (prevPt.y - m * prevPt.x)) > .001, 'wrong math in Q:', (pt.y - m * pt.x), ' vs ', (prevPt.y - m * prevPt.x));\r\n        /*const isL = prevPt.x < pt.x;\r\n    const isT = prevPt.y < pt.y;\r\n    const isR = !isL;\r\n    const isB = !isT; */\r\n        if (m === Number.POSITIVE_INFINITY && q === Number.NEGATIVE_INFINITY) { // bottom middle\r\n            return new GraphPoint(vertexGSize.x + vertexGSize.w / 2, vertexGSize.y + vertexGSize.h); }\r\n        // console.log('pt:', pt, 'm:', m, 'q:', q);\r\n        let L: GraphPoint | null = new GraphPoint(0, 0);\r\n        let T: GraphPoint | null = new GraphPoint(0, 0);\r\n        let R: GraphPoint | null = new GraphPoint(0, 0);\r\n        let B: GraphPoint | null = new GraphPoint(0, 0);\r\n        L.x = vertexGSize.x;\r\n        L.y = m * L.x + q;\r\n        R.x = vertexGSize.x + vertexGSize.w;\r\n        R.y = m * R.x + q;\r\n        T.y = vertexGSize.y;\r\n        T.x = (T.y - q) / m;\r\n        B.y = vertexGSize.y + vertexGSize.h;\r\n        B.x = (B.y - q) / m;\r\n        // prendo solo il compreso pt ~ prevPt (escludo così il \"pierce\" sulla faccia opposta), prendo il più vicino al centro.\r\n        // console.log('4 possibili punti di intersezione (LTBR):', L, T, B, R);\r\n        /* this.owner.mark(this.owner.toHtmlCoord(T), true, 'blue');\r\n    this.owner.mark(this.owner.toHtmlCoord(B), false, 'violet');\r\n    this.owner.mark(this.owner.toHtmlCoord(L), false, 'red');\r\n    this.owner.mark(this.owner.toHtmlCoord(R), false, 'orange');*/\r\n        if ( (B.x >= pt.x && B.x <= prevPt.x) || (B.x >= prevPt.x && B.x <= pt.x) ) { } else { B = null; }\r\n        if ( (T.x >= pt.x && T.x <= prevPt.x) || (T.x >= prevPt.x && T.x <= pt.x) ) { } else { T = null; }\r\n        if ( (L.y >= pt.y && L.y <= prevPt.y) || (L.y >= prevPt.y && L.y <= pt.y) ) { } else { L = null; }\r\n        if ( (R.y >= pt.y && R.y <= prevPt.y) || (R.y >= prevPt.y && R.y <= pt.y) ) { } else { R = null; }\r\n        // console.log('superstiti step1: (LTBR):', L, T, B, R);\r\n        const vicinanzaT = !T ? Number.POSITIVE_INFINITY : ((T.x - pt.x) * (T.x - pt.x)) + ((T.y - pt.y) * (T.y - pt.y));\r\n        const vicinanzaB = !B ? Number.POSITIVE_INFINITY : ((B.x - pt.x) * (B.x - pt.x)) + ((B.y - pt.y) * (B.y - pt.y));\r\n        const vicinanzaL = !L ? Number.POSITIVE_INFINITY : ((L.x - pt.x) * (L.x - pt.x)) + ((L.y - pt.y) * (L.y - pt.y));\r\n        const vicinanzaR = !R ? Number.POSITIVE_INFINITY : ((R.x - pt.x) * (R.x - pt.x)) + ((R.y - pt.y) * (R.y - pt.y));\r\n        const closest = Math.min(vicinanzaT, vicinanzaB, vicinanzaL, vicinanzaR);\r\n        // console.log( 'closest:', closest);\r\n        // succede quando pt e prevPt sono entrambi all'interno del rettangolo del vertice.\r\n        // L'edge non è visibile e il valore ritornato è irrilevante.\r\n        if (closest === Number.POSITIVE_INFINITY) {\r\n            /* top center */\r\n            pt = vertexGSize.tl();\r\n            pt.x += vertexGSize.w / 2; } else\r\n        if (closest === Number.POSITIVE_INFINITY) {\r\n            /* bottom center */\r\n            pt = vertexGSize.br();\r\n            pt.x -= vertexGSize.w / 2; } else\r\n        if (closest === vicinanzaT) { pt = T; } else\r\n        if (closest === vicinanzaB) { pt = B; } else\r\n        if (closest === vicinanzaR) { pt = R; } else\r\n        if (closest === vicinanzaL) { pt = L; }\r\n\r\n        if (!gridAlign) { return pt; }\r\n        if (!pt) return null;\r\n        if ((pt === T || pt === B || isNaN(closest)) && gridAlign.x) {\r\n            const floorX: number = Math.floor(pt.x / gridAlign.x) * gridAlign.x;\r\n            const ceilX: number = Math.ceil(pt.x / gridAlign.x) * gridAlign.x;\r\n            let closestX;\r\n            let farthestX;\r\n            if (Math.abs(floorX - pt.x) < Math.abs(ceilX - pt.x)) {\r\n                closestX = floorX; farthestX = ceilX;\r\n            } else { closestX = ceilX; farthestX = floorX; }\r\n\r\n            // todo: possibile causa del bug che non allinea punti fake a punti reali. nel calcolo realPT questo non viene fatto.\r\n            // if closest grid intersection is inside the vertex.\r\n            if (closestX >= vertexGSize.x && closestX <= vertexGSize.x + vertexGSize.w) { pt.x = closestX; } else\r\n                // if 2° closer grid intersection is inside the vertex.\r\n            if (closestX >= vertexGSize.x && closestX <= vertexGSize.x + vertexGSize.w) { pt.x = farthestX;\r\n                // if no intersection are inside the vertex (ignore grid)\r\n            } else { /* do nothing */ }\r\n        } else if ((pt === L || pt === R) && gridAlign.y) {\r\n            const floorY: number = Math.floor(pt.y / gridAlign.y) * gridAlign.y;\r\n            const ceilY: number = Math.ceil(pt.y / gridAlign.y) * gridAlign.y;\r\n            let closestY;\r\n            let farthestY;\r\n            if (Math.abs(floorY - pt.y) < Math.abs(ceilY - pt.y)) {\r\n                closestY = floorY; farthestY = ceilY;\r\n            } else { closestY = ceilY; farthestY = floorY; }\r\n\r\n            // if closest grid intersection is inside the vertex.\r\n            if (closestY >= vertexGSize.y && closestY <= vertexGSize.y + vertexGSize.h) { pt.y = closestY; } else\r\n                // if 2° closer grid intersection is inside the vertex.\r\n            if (closestY >= vertexGSize.y && closestY <= vertexGSize.y + vertexGSize.h) { pt.y = farthestY;\r\n                // if no intersection are inside the vertex (ignore grid)\r\n            } else { /* do nothing */ }\r\n        }\r\n        return pt; }\r\n\r\n\r\n    protected new(): this { return new GraphSize() as this; }\r\n    protected makePoint(x: number, y: number): GraphPoint { return new GraphPoint(x, y) as GraphPoint; }\r\n\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}