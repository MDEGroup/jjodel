{"ast":null,"code":"/*\n  Copyright (C) 2013 Ariya Hidayat <ariya.hidayat@gmail.com>\n  Copyright (C) 2013 Thaddee Tyl <thaddee.tyl@gmail.com>\n  Copyright (C) 2012 Ariya Hidayat <ariya.hidayat@gmail.com>\n  Copyright (C) 2012 Mathias Bynens <mathias@qiwi.be>\n  Copyright (C) 2012 Joost-Wim Boekesteijn <joost-wim@boekesteijn.nl>\n  Copyright (C) 2012 Kris Kowal <kris.kowal@cixar.com>\n  Copyright (C) 2012 Yusuke Suzuki <utatane.tea@gmail.com>\n  Copyright (C) 2012 Arpad Borsos <arpad.borsos@googlemail.com>\n  Copyright (C) 2011 Ariya Hidayat <ariya.hidayat@gmail.com>\n\n  Redistribution and use in source and binary forms, with or without\n  modification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n(function (root, factory) {\n  'use strict';\n\n  // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js,\n  // Rhino, and plain browser loading.\n\n  /* istanbul ignore next */\n  if (typeof define === 'function' && define.amd) {\n    define(['exports'], factory);\n  } else if (typeof exports !== 'undefined') {\n    factory(exports);\n  } else {\n    factory(root.esprima = {});\n  }\n})(this, function (exports) {\n  'use strict';\n\n  var Token, TokenName, FnExprTokens, Syntax, PropertyKind, Messages, Regex, SyntaxTreeDelegate, XHTMLEntities, ClassPropertyType, source, strict, index, lineNumber, lineStart, length, delegate, lookahead, state, extra;\n  Token = {\n    BooleanLiteral: 1,\n    EOF: 2,\n    Identifier: 3,\n    Keyword: 4,\n    NullLiteral: 5,\n    NumericLiteral: 6,\n    Punctuator: 7,\n    StringLiteral: 8,\n    RegularExpression: 9,\n    Template: 10,\n    JSXIdentifier: 11,\n    JSXText: 12\n  };\n  TokenName = {};\n  TokenName[Token.BooleanLiteral] = 'Boolean';\n  TokenName[Token.EOF] = '<end>';\n  TokenName[Token.Identifier] = 'Identifier';\n  TokenName[Token.Keyword] = 'Keyword';\n  TokenName[Token.NullLiteral] = 'Null';\n  TokenName[Token.NumericLiteral] = 'Numeric';\n  TokenName[Token.Punctuator] = 'Punctuator';\n  TokenName[Token.StringLiteral] = 'String';\n  TokenName[Token.JSXIdentifier] = 'JSXIdentifier';\n  TokenName[Token.JSXText] = 'JSXText';\n  TokenName[Token.RegularExpression] = 'RegularExpression';\n  TokenName[Token.Template] = 'Template';\n\n  // A function following one of those tokens is an expression.\n  FnExprTokens = ['(', '{', '[', 'in', 'typeof', 'instanceof', 'new', 'return', 'case', 'delete', 'throw', 'void',\n  // assignment operators\n  '=', '+=', '-=', '*=', '/=', '%=', '<<=', '>>=', '>>>=', '&=', '|=', '^=', ',',\n  // binary/unary operators\n  '+', '-', '*', '/', '%', '++', '--', '<<', '>>', '>>>', '&', '|', '^', '!', '~', '&&', '||', '?', ':', '===', '==', '>=', '<=', '<', '>', '!=', '!=='];\n  Syntax = {\n    AnyTypeAnnotation: 'AnyTypeAnnotation',\n    ArrayExpression: 'ArrayExpression',\n    ArrayPattern: 'ArrayPattern',\n    ArrayTypeAnnotation: 'ArrayTypeAnnotation',\n    ArrowFunctionExpression: 'ArrowFunctionExpression',\n    AssignmentExpression: 'AssignmentExpression',\n    BinaryExpression: 'BinaryExpression',\n    BlockStatement: 'BlockStatement',\n    BooleanTypeAnnotation: 'BooleanTypeAnnotation',\n    BreakStatement: 'BreakStatement',\n    CallExpression: 'CallExpression',\n    CatchClause: 'CatchClause',\n    ClassBody: 'ClassBody',\n    ClassDeclaration: 'ClassDeclaration',\n    ClassExpression: 'ClassExpression',\n    ClassImplements: 'ClassImplements',\n    ClassProperty: 'ClassProperty',\n    ComprehensionBlock: 'ComprehensionBlock',\n    ComprehensionExpression: 'ComprehensionExpression',\n    ConditionalExpression: 'ConditionalExpression',\n    ContinueStatement: 'ContinueStatement',\n    DebuggerStatement: 'DebuggerStatement',\n    DeclareClass: 'DeclareClass',\n    DeclareFunction: 'DeclareFunction',\n    DeclareModule: 'DeclareModule',\n    DeclareVariable: 'DeclareVariable',\n    DoWhileStatement: 'DoWhileStatement',\n    EmptyStatement: 'EmptyStatement',\n    ExportDeclaration: 'ExportDeclaration',\n    ExportBatchSpecifier: 'ExportBatchSpecifier',\n    ExportSpecifier: 'ExportSpecifier',\n    ExpressionStatement: 'ExpressionStatement',\n    ForInStatement: 'ForInStatement',\n    ForOfStatement: 'ForOfStatement',\n    ForStatement: 'ForStatement',\n    FunctionDeclaration: 'FunctionDeclaration',\n    FunctionExpression: 'FunctionExpression',\n    FunctionTypeAnnotation: 'FunctionTypeAnnotation',\n    FunctionTypeParam: 'FunctionTypeParam',\n    GenericTypeAnnotation: 'GenericTypeAnnotation',\n    Identifier: 'Identifier',\n    IfStatement: 'IfStatement',\n    ImportDeclaration: 'ImportDeclaration',\n    ImportDefaultSpecifier: 'ImportDefaultSpecifier',\n    ImportNamespaceSpecifier: 'ImportNamespaceSpecifier',\n    ImportSpecifier: 'ImportSpecifier',\n    InterfaceDeclaration: 'InterfaceDeclaration',\n    InterfaceExtends: 'InterfaceExtends',\n    IntersectionTypeAnnotation: 'IntersectionTypeAnnotation',\n    LabeledStatement: 'LabeledStatement',\n    Literal: 'Literal',\n    LogicalExpression: 'LogicalExpression',\n    MemberExpression: 'MemberExpression',\n    MethodDefinition: 'MethodDefinition',\n    NewExpression: 'NewExpression',\n    NullableTypeAnnotation: 'NullableTypeAnnotation',\n    NumberTypeAnnotation: 'NumberTypeAnnotation',\n    ObjectExpression: 'ObjectExpression',\n    ObjectPattern: 'ObjectPattern',\n    ObjectTypeAnnotation: 'ObjectTypeAnnotation',\n    ObjectTypeCallProperty: 'ObjectTypeCallProperty',\n    ObjectTypeIndexer: 'ObjectTypeIndexer',\n    ObjectTypeProperty: 'ObjectTypeProperty',\n    Program: 'Program',\n    Property: 'Property',\n    QualifiedTypeIdentifier: 'QualifiedTypeIdentifier',\n    ReturnStatement: 'ReturnStatement',\n    SequenceExpression: 'SequenceExpression',\n    SpreadElement: 'SpreadElement',\n    SpreadProperty: 'SpreadProperty',\n    StringLiteralTypeAnnotation: 'StringLiteralTypeAnnotation',\n    StringTypeAnnotation: 'StringTypeAnnotation',\n    SwitchCase: 'SwitchCase',\n    SwitchStatement: 'SwitchStatement',\n    TaggedTemplateExpression: 'TaggedTemplateExpression',\n    TemplateElement: 'TemplateElement',\n    TemplateLiteral: 'TemplateLiteral',\n    ThisExpression: 'ThisExpression',\n    ThrowStatement: 'ThrowStatement',\n    TupleTypeAnnotation: 'TupleTypeAnnotation',\n    TryStatement: 'TryStatement',\n    TypeAlias: 'TypeAlias',\n    TypeAnnotation: 'TypeAnnotation',\n    TypeCastExpression: 'TypeCastExpression',\n    TypeofTypeAnnotation: 'TypeofTypeAnnotation',\n    TypeParameterDeclaration: 'TypeParameterDeclaration',\n    TypeParameterInstantiation: 'TypeParameterInstantiation',\n    UnaryExpression: 'UnaryExpression',\n    UnionTypeAnnotation: 'UnionTypeAnnotation',\n    UpdateExpression: 'UpdateExpression',\n    VariableDeclaration: 'VariableDeclaration',\n    VariableDeclarator: 'VariableDeclarator',\n    VoidTypeAnnotation: 'VoidTypeAnnotation',\n    WhileStatement: 'WhileStatement',\n    WithStatement: 'WithStatement',\n    JSXIdentifier: 'JSXIdentifier',\n    JSXNamespacedName: 'JSXNamespacedName',\n    JSXMemberExpression: 'JSXMemberExpression',\n    JSXEmptyExpression: 'JSXEmptyExpression',\n    JSXExpressionContainer: 'JSXExpressionContainer',\n    JSXElement: 'JSXElement',\n    JSXClosingElement: 'JSXClosingElement',\n    JSXOpeningElement: 'JSXOpeningElement',\n    JSXAttribute: 'JSXAttribute',\n    JSXSpreadAttribute: 'JSXSpreadAttribute',\n    JSXText: 'JSXText',\n    YieldExpression: 'YieldExpression',\n    AwaitExpression: 'AwaitExpression'\n  };\n  PropertyKind = {\n    Data: 1,\n    Get: 2,\n    Set: 4\n  };\n  ClassPropertyType = {\n    'static': 'static',\n    prototype: 'prototype'\n  };\n\n  // Error messages should be identical to V8.\n  Messages = {\n    UnexpectedToken: 'Unexpected token %0',\n    UnexpectedNumber: 'Unexpected number',\n    UnexpectedString: 'Unexpected string',\n    UnexpectedIdentifier: 'Unexpected identifier',\n    UnexpectedReserved: 'Unexpected reserved word',\n    UnexpectedTemplate: 'Unexpected quasi %0',\n    UnexpectedEOS: 'Unexpected end of input',\n    NewlineAfterThrow: 'Illegal newline after throw',\n    InvalidRegExp: 'Invalid regular expression',\n    UnterminatedRegExp: 'Invalid regular expression: missing /',\n    InvalidLHSInAssignment: 'Invalid left-hand side in assignment',\n    InvalidLHSInFormalsList: 'Invalid left-hand side in formals list',\n    InvalidLHSInForIn: 'Invalid left-hand side in for-in',\n    MultipleDefaultsInSwitch: 'More than one default clause in switch statement',\n    NoCatchOrFinally: 'Missing catch or finally after try',\n    UnknownLabel: 'Undefined label \\'%0\\'',\n    Redeclaration: '%0 \\'%1\\' has already been declared',\n    IllegalContinue: 'Illegal continue statement',\n    IllegalBreak: 'Illegal break statement',\n    IllegalDuplicateClassProperty: 'Illegal duplicate property in class definition',\n    IllegalClassConstructorProperty: 'Illegal constructor property in class definition',\n    IllegalReturn: 'Illegal return statement',\n    IllegalSpread: 'Illegal spread element',\n    StrictModeWith: 'Strict mode code may not include a with statement',\n    StrictCatchVariable: 'Catch variable may not be eval or arguments in strict mode',\n    StrictVarName: 'Variable name may not be eval or arguments in strict mode',\n    StrictParamName: 'Parameter name eval or arguments is not allowed in strict mode',\n    StrictParamDupe: 'Strict mode function may not have duplicate parameter names',\n    ParameterAfterRestParameter: 'Rest parameter must be final parameter of an argument list',\n    DefaultRestParameter: 'Rest parameter can not have a default value',\n    ElementAfterSpreadElement: 'Spread must be the final element of an element list',\n    PropertyAfterSpreadProperty: 'A rest property must be the final property of an object literal',\n    ObjectPatternAsRestParameter: 'Invalid rest parameter',\n    ObjectPatternAsSpread: 'Invalid spread argument',\n    StrictFunctionName: 'Function name may not be eval or arguments in strict mode',\n    StrictOctalLiteral: 'Octal literals are not allowed in strict mode.',\n    StrictDelete: 'Delete of an unqualified identifier in strict mode.',\n    StrictDuplicateProperty: 'Duplicate data property in object literal not allowed in strict mode',\n    AccessorDataProperty: 'Object literal may not have data and accessor property with the same name',\n    AccessorGetSet: 'Object literal may not have multiple get/set accessors with the same name',\n    StrictLHSAssignment: 'Assignment to eval or arguments is not allowed in strict mode',\n    StrictLHSPostfix: 'Postfix increment/decrement may not have eval or arguments operand in strict mode',\n    StrictLHSPrefix: 'Prefix increment/decrement may not have eval or arguments operand in strict mode',\n    StrictReservedWord: 'Use of future reserved word in strict mode',\n    MissingFromClause: 'Missing from clause',\n    NoAsAfterImportNamespace: 'Missing as after import *',\n    InvalidModuleSpecifier: 'Invalid module specifier',\n    IllegalImportDeclaration: 'Illegal import declaration',\n    IllegalExportDeclaration: 'Illegal export declaration',\n    NoUninitializedConst: 'Const must be initialized',\n    ComprehensionRequiresBlock: 'Comprehension must have at least one block',\n    ComprehensionError: 'Comprehension Error',\n    EachNotAllowed: 'Each is not supported',\n    InvalidJSXAttributeValue: 'JSX value should be either an expression or a quoted JSX text',\n    ExpectedJSXClosingTag: 'Expected corresponding JSX closing tag for %0',\n    AdjacentJSXElements: 'Adjacent JSX elements must be wrapped in an enclosing tag',\n    ConfusedAboutFunctionType: 'Unexpected token =>. It looks like ' + 'you are trying to write a function type, but you ended up ' + 'writing a grouped type followed by an =>, which is a syntax ' + 'error. Remember, function type parameters are named so function ' + 'types look like (name1: type1, name2: type2) => returnType. You ' + 'probably wrote (type1) => returnType'\n  };\n\n  // See also tools/generate-unicode-regex.py.\n  Regex = {\n    NonAsciiIdentifierStart: new RegExp(\"[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u0527\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0620-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u07F4\\u07F5\\u07FA\\u0800-\\u0815\\u081A\\u0824\\u0828\\u0840-\\u0858\\u08A0\\u08A2-\\u08AC\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0971-\\u0977\\u0979-\\u097F\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C33\\u0C35-\\u0C39\\u0C3D\\u0C58\\u0C59\\u0C60\\u0C61\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0CF1\\u0CF2\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D60\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EDC-\\u0EDF\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F0\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u1820-\\u1877\\u1880-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191C\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19C1-\\u19C7\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1AA7\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1BBA-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\\u1CE9-\\u1CEC\\u1CEE-\\u1CF1\\u1CF5\\u1CF6\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CEE\\u2CF2\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2E2F\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FCC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA61F\\uA62A\\uA62B\\uA640-\\uA66E\\uA67F-\\uA697\\uA6A0-\\uA6EF\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA78E\\uA790-\\uA793\\uA7A0-\\uA7AA\\uA7F8-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9CF\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA76\\uAA7A\\uAA80-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEA\\uAAF2-\\uAAF4\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uABC0-\\uABE2\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]\"),\n    NonAsciiIdentifierPart: new RegExp(\"[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0300-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u0483-\\u0487\\u048A-\\u0527\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0610-\\u061A\\u0620-\\u0669\\u066E-\\u06D3\\u06D5-\\u06DC\\u06DF-\\u06E8\\u06EA-\\u06FC\\u06FF\\u0710-\\u074A\\u074D-\\u07B1\\u07C0-\\u07F5\\u07FA\\u0800-\\u082D\\u0840-\\u085B\\u08A0\\u08A2-\\u08AC\\u08E4-\\u08FE\\u0900-\\u0963\\u0966-\\u096F\\u0971-\\u0977\\u0979-\\u097F\\u0981-\\u0983\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BC-\\u09C4\\u09C7\\u09C8\\u09CB-\\u09CE\\u09D7\\u09DC\\u09DD\\u09DF-\\u09E3\\u09E6-\\u09F1\\u0A01-\\u0A03\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A3C\\u0A3E-\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A59-\\u0A5C\\u0A5E\\u0A66-\\u0A75\\u0A81-\\u0A83\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABC-\\u0AC5\\u0AC7-\\u0AC9\\u0ACB-\\u0ACD\\u0AD0\\u0AE0-\\u0AE3\\u0AE6-\\u0AEF\\u0B01-\\u0B03\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3C-\\u0B44\\u0B47\\u0B48\\u0B4B-\\u0B4D\\u0B56\\u0B57\\u0B5C\\u0B5D\\u0B5F-\\u0B63\\u0B66-\\u0B6F\\u0B71\\u0B82\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BBE-\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCD\\u0BD0\\u0BD7\\u0BE6-\\u0BEF\\u0C01-\\u0C03\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C33\\u0C35-\\u0C39\\u0C3D-\\u0C44\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C58\\u0C59\\u0C60-\\u0C63\\u0C66-\\u0C6F\\u0C82\\u0C83\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBC-\\u0CC4\\u0CC6-\\u0CC8\\u0CCA-\\u0CCD\\u0CD5\\u0CD6\\u0CDE\\u0CE0-\\u0CE3\\u0CE6-\\u0CEF\\u0CF1\\u0CF2\\u0D02\\u0D03\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D-\\u0D44\\u0D46-\\u0D48\\u0D4A-\\u0D4E\\u0D57\\u0D60-\\u0D63\\u0D66-\\u0D6F\\u0D7A-\\u0D7F\\u0D82\\u0D83\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0DCA\\u0DCF-\\u0DD4\\u0DD6\\u0DD8-\\u0DDF\\u0DF2\\u0DF3\\u0E01-\\u0E3A\\u0E40-\\u0E4E\\u0E50-\\u0E59\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB9\\u0EBB-\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EC8-\\u0ECD\\u0ED0-\\u0ED9\\u0EDC-\\u0EDF\\u0F00\\u0F18\\u0F19\\u0F20-\\u0F29\\u0F35\\u0F37\\u0F39\\u0F3E-\\u0F47\\u0F49-\\u0F6C\\u0F71-\\u0F84\\u0F86-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u1000-\\u1049\\u1050-\\u109D\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u135D-\\u135F\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F0\\u1700-\\u170C\\u170E-\\u1714\\u1720-\\u1734\\u1740-\\u1753\\u1760-\\u176C\\u176E-\\u1770\\u1772\\u1773\\u1780-\\u17D3\\u17D7\\u17DC\\u17DD\\u17E0-\\u17E9\\u180B-\\u180D\\u1810-\\u1819\\u1820-\\u1877\\u1880-\\u18AA\\u18B0-\\u18F5\\u1900-\\u191C\\u1920-\\u192B\\u1930-\\u193B\\u1946-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u19D0-\\u19D9\\u1A00-\\u1A1B\\u1A20-\\u1A5E\\u1A60-\\u1A7C\\u1A7F-\\u1A89\\u1A90-\\u1A99\\u1AA7\\u1B00-\\u1B4B\\u1B50-\\u1B59\\u1B6B-\\u1B73\\u1B80-\\u1BF3\\u1C00-\\u1C37\\u1C40-\\u1C49\\u1C4D-\\u1C7D\\u1CD0-\\u1CD2\\u1CD4-\\u1CF6\\u1D00-\\u1DE6\\u1DFC-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u200C\\u200D\\u203F\\u2040\\u2054\\u2071\\u207F\\u2090-\\u209C\\u20D0-\\u20DC\\u20E1\\u20E5-\\u20F0\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D7F-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2DE0-\\u2DFF\\u2E2F\\u3005-\\u3007\\u3021-\\u302F\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u3099\\u309A\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FCC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA62B\\uA640-\\uA66F\\uA674-\\uA67D\\uA67F-\\uA697\\uA69F-\\uA6F1\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA78E\\uA790-\\uA793\\uA7A0-\\uA7AA\\uA7F8-\\uA827\\uA840-\\uA873\\uA880-\\uA8C4\\uA8D0-\\uA8D9\\uA8E0-\\uA8F7\\uA8FB\\uA900-\\uA92D\\uA930-\\uA953\\uA960-\\uA97C\\uA980-\\uA9C0\\uA9CF-\\uA9D9\\uAA00-\\uAA36\\uAA40-\\uAA4D\\uAA50-\\uAA59\\uAA60-\\uAA76\\uAA7A\\uAA7B\\uAA80-\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEF\\uAAF2-\\uAAF6\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uABC0-\\uABEA\\uABEC\\uABED\\uABF0-\\uABF9\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE00-\\uFE0F\\uFE20-\\uFE26\\uFE33\\uFE34\\uFE4D-\\uFE4F\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF10-\\uFF19\\uFF21-\\uFF3A\\uFF3F\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]\"),\n    LeadingZeros: new RegExp('^0+(?!$)')\n  };\n\n  // Ensure the condition is true, otherwise throw an error.\n  // This is only to have a better contract semantic, i.e. another safety net\n  // to catch a logic error. The condition shall be fulfilled in normal case.\n  // Do NOT use this to enforce a certain condition on any user input.\n\n  function assert(condition, message) {\n    /* istanbul ignore if */\n    if (!condition) {\n      throw new Error('ASSERT: ' + message);\n    }\n  }\n  function StringMap() {\n    this.$data = {};\n  }\n  StringMap.prototype.get = function (key) {\n    key = '$' + key;\n    return this.$data[key];\n  };\n  StringMap.prototype.set = function (key, value) {\n    key = '$' + key;\n    this.$data[key] = value;\n    return this;\n  };\n  StringMap.prototype.has = function (key) {\n    key = '$' + key;\n    return Object.prototype.hasOwnProperty.call(this.$data, key);\n  };\n  StringMap.prototype.delete = function (key) {\n    key = '$' + key;\n    return delete this.$data[key];\n  };\n  function isDecimalDigit(ch) {\n    return ch >= 48 && ch <= 57; // 0..9\n  }\n\n  function isHexDigit(ch) {\n    return '0123456789abcdefABCDEF'.indexOf(ch) >= 0;\n  }\n  function isOctalDigit(ch) {\n    return '01234567'.indexOf(ch) >= 0;\n  }\n\n  // 7.2 White Space\n\n  function isWhiteSpace(ch) {\n    return ch === 32 ||\n    // space\n    ch === 9 ||\n    // tab\n    ch === 0xB || ch === 0xC || ch === 0xA0 || ch >= 0x1680 && \"\\u1680\\u180E\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u3000\\uFEFF\".indexOf(String.fromCharCode(ch)) > 0;\n  }\n\n  // 7.3 Line Terminators\n\n  function isLineTerminator(ch) {\n    return ch === 10 || ch === 13 || ch === 0x2028 || ch === 0x2029;\n  }\n\n  // 7.6 Identifier Names and Identifiers\n\n  function isIdentifierStart(ch) {\n    return ch === 36 || ch === 95 ||\n    // $ (dollar) and _ (underscore)\n    ch >= 65 && ch <= 90 ||\n    // A..Z\n    ch >= 97 && ch <= 122 ||\n    // a..z\n    ch === 92 ||\n    // \\ (backslash)\n    ch >= 0x80 && Regex.NonAsciiIdentifierStart.test(String.fromCharCode(ch));\n  }\n  function isIdentifierPart(ch) {\n    return ch === 36 || ch === 95 ||\n    // $ (dollar) and _ (underscore)\n    ch >= 65 && ch <= 90 ||\n    // A..Z\n    ch >= 97 && ch <= 122 ||\n    // a..z\n    ch >= 48 && ch <= 57 ||\n    // 0..9\n    ch === 92 ||\n    // \\ (backslash)\n    ch >= 0x80 && Regex.NonAsciiIdentifierPart.test(String.fromCharCode(ch));\n  }\n\n  // 7.6.1.2 Future Reserved Words\n\n  function isFutureReservedWord(id) {\n    switch (id) {\n      case 'class':\n      case 'enum':\n      case 'export':\n      case 'extends':\n      case 'import':\n      case 'super':\n        return true;\n      default:\n        return false;\n    }\n  }\n  function isStrictModeReservedWord(id) {\n    switch (id) {\n      case 'implements':\n      case 'interface':\n      case 'package':\n      case 'private':\n      case 'protected':\n      case 'public':\n      case 'static':\n      case 'yield':\n      case 'let':\n        return true;\n      default:\n        return false;\n    }\n  }\n  function isRestrictedWord(id) {\n    return id === 'eval' || id === 'arguments';\n  }\n\n  // 7.6.1.1 Keywords\n\n  function isKeyword(id) {\n    if (strict && isStrictModeReservedWord(id)) {\n      return true;\n    }\n\n    // 'const' is specialized as Keyword in V8.\n    // 'yield' is only treated as a keyword in strict mode.\n    // 'let' is for compatiblity with SpiderMonkey and ES.next.\n    // Some others are from future reserved words.\n\n    switch (id.length) {\n      case 2:\n        return id === 'if' || id === 'in' || id === 'do';\n      case 3:\n        return id === 'var' || id === 'for' || id === 'new' || id === 'try' || id === 'let';\n      case 4:\n        return id === 'this' || id === 'else' || id === 'case' || id === 'void' || id === 'with' || id === 'enum';\n      case 5:\n        return id === 'while' || id === 'break' || id === 'catch' || id === 'throw' || id === 'const' || id === 'class' || id === 'super';\n      case 6:\n        return id === 'return' || id === 'typeof' || id === 'delete' || id === 'switch' || id === 'export' || id === 'import';\n      case 7:\n        return id === 'default' || id === 'finally' || id === 'extends';\n      case 8:\n        return id === 'function' || id === 'continue' || id === 'debugger';\n      case 10:\n        return id === 'instanceof';\n      default:\n        return false;\n    }\n  }\n\n  // 7.4 Comments\n\n  function addComment(type, value, start, end, loc) {\n    var comment;\n    assert(typeof start === 'number', 'Comment must have valid position');\n\n    // Because the way the actual token is scanned, often the comments\n    // (if any) are skipped twice during the lexical analysis.\n    // Thus, we need to skip adding a comment if the comment array already\n    // handled it.\n    if (state.lastCommentStart >= start) {\n      return;\n    }\n    state.lastCommentStart = start;\n    comment = {\n      type: type,\n      value: value\n    };\n    if (extra.range) {\n      comment.range = [start, end];\n    }\n    if (extra.loc) {\n      comment.loc = loc;\n    }\n    extra.comments.push(comment);\n    if (extra.attachComment) {\n      extra.leadingComments.push(comment);\n      extra.trailingComments.push(comment);\n    }\n  }\n  function skipSingleLineComment() {\n    var start, loc, ch, comment;\n    start = index - 2;\n    loc = {\n      start: {\n        line: lineNumber,\n        column: index - lineStart - 2\n      }\n    };\n    while (index < length) {\n      ch = source.charCodeAt(index);\n      ++index;\n      if (isLineTerminator(ch)) {\n        if (extra.comments) {\n          comment = source.slice(start + 2, index - 1);\n          loc.end = {\n            line: lineNumber,\n            column: index - lineStart - 1\n          };\n          addComment('Line', comment, start, index - 1, loc);\n        }\n        if (ch === 13 && source.charCodeAt(index) === 10) {\n          ++index;\n        }\n        ++lineNumber;\n        lineStart = index;\n        return;\n      }\n    }\n    if (extra.comments) {\n      comment = source.slice(start + 2, index);\n      loc.end = {\n        line: lineNumber,\n        column: index - lineStart\n      };\n      addComment('Line', comment, start, index, loc);\n    }\n  }\n  function skipMultiLineComment() {\n    var start, loc, ch, comment;\n    if (extra.comments) {\n      start = index - 2;\n      loc = {\n        start: {\n          line: lineNumber,\n          column: index - lineStart - 2\n        }\n      };\n    }\n    while (index < length) {\n      ch = source.charCodeAt(index);\n      if (isLineTerminator(ch)) {\n        if (ch === 13 && source.charCodeAt(index + 1) === 10) {\n          ++index;\n        }\n        ++lineNumber;\n        ++index;\n        lineStart = index;\n        if (index >= length) {\n          throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n        }\n      } else if (ch === 42) {\n        // Block comment ends with '*/' (char #42, char #47).\n        if (source.charCodeAt(index + 1) === 47) {\n          ++index;\n          ++index;\n          if (extra.comments) {\n            comment = source.slice(start + 2, index - 2);\n            loc.end = {\n              line: lineNumber,\n              column: index - lineStart\n            };\n            addComment('Block', comment, start, index, loc);\n          }\n          return;\n        }\n        ++index;\n      } else {\n        ++index;\n      }\n    }\n    throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n  }\n  function skipComment() {\n    var ch;\n    while (index < length) {\n      ch = source.charCodeAt(index);\n      if (isWhiteSpace(ch)) {\n        ++index;\n      } else if (isLineTerminator(ch)) {\n        ++index;\n        if (ch === 13 && source.charCodeAt(index) === 10) {\n          ++index;\n        }\n        ++lineNumber;\n        lineStart = index;\n      } else if (ch === 47) {\n        // 47 is '/'\n        ch = source.charCodeAt(index + 1);\n        if (ch === 47) {\n          ++index;\n          ++index;\n          skipSingleLineComment();\n        } else if (ch === 42) {\n          // 42 is '*'\n          ++index;\n          ++index;\n          skipMultiLineComment();\n        } else {\n          break;\n        }\n      } else {\n        break;\n      }\n    }\n  }\n  function scanHexEscape(prefix) {\n    var i,\n      len,\n      ch,\n      code = 0;\n    len = prefix === 'u' ? 4 : 2;\n    for (i = 0; i < len; ++i) {\n      if (index < length && isHexDigit(source[index])) {\n        ch = source[index++];\n        code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());\n      } else {\n        return '';\n      }\n    }\n    return String.fromCharCode(code);\n  }\n  function scanUnicodeCodePointEscape() {\n    var ch, code, cu1, cu2;\n    ch = source[index];\n    code = 0;\n\n    // At least, one hex digit is required.\n    if (ch === '}') {\n      throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n    }\n    while (index < length) {\n      ch = source[index++];\n      if (!isHexDigit(ch)) {\n        break;\n      }\n      code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());\n    }\n    if (code > 0x10FFFF || ch !== '}') {\n      throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n    }\n\n    // UTF-16 Encoding\n    if (code <= 0xFFFF) {\n      return String.fromCharCode(code);\n    }\n    cu1 = (code - 0x10000 >> 10) + 0xD800;\n    cu2 = (code - 0x10000 & 1023) + 0xDC00;\n    return String.fromCharCode(cu1, cu2);\n  }\n  function getEscapedIdentifier() {\n    var ch, id;\n    ch = source.charCodeAt(index++);\n    id = String.fromCharCode(ch);\n\n    // '\\u' (char #92, char #117) denotes an escaped character.\n    if (ch === 92) {\n      if (source.charCodeAt(index) !== 117) {\n        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n      }\n      ++index;\n      ch = scanHexEscape('u');\n      if (!ch || ch === '\\\\' || !isIdentifierStart(ch.charCodeAt(0))) {\n        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n      }\n      id = ch;\n    }\n    while (index < length) {\n      ch = source.charCodeAt(index);\n      if (!isIdentifierPart(ch)) {\n        break;\n      }\n      ++index;\n      id += String.fromCharCode(ch);\n\n      // '\\u' (char #92, char #117) denotes an escaped character.\n      if (ch === 92) {\n        id = id.substr(0, id.length - 1);\n        if (source.charCodeAt(index) !== 117) {\n          throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n        }\n        ++index;\n        ch = scanHexEscape('u');\n        if (!ch || ch === '\\\\' || !isIdentifierPart(ch.charCodeAt(0))) {\n          throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n        }\n        id += ch;\n      }\n    }\n    return id;\n  }\n  function getIdentifier() {\n    var start, ch;\n    start = index++;\n    while (index < length) {\n      ch = source.charCodeAt(index);\n      if (ch === 92) {\n        // Blackslash (char #92) marks Unicode escape sequence.\n        index = start;\n        return getEscapedIdentifier();\n      }\n      if (isIdentifierPart(ch)) {\n        ++index;\n      } else {\n        break;\n      }\n    }\n    return source.slice(start, index);\n  }\n  function scanIdentifier() {\n    var start, id, type;\n    start = index;\n\n    // Backslash (char #92) starts an escaped character.\n    id = source.charCodeAt(index) === 92 ? getEscapedIdentifier() : getIdentifier();\n\n    // There is no keyword or literal with only one character.\n    // Thus, it must be an identifier.\n    if (id.length === 1) {\n      type = Token.Identifier;\n    } else if (isKeyword(id)) {\n      type = Token.Keyword;\n    } else if (id === 'null') {\n      type = Token.NullLiteral;\n    } else if (id === 'true' || id === 'false') {\n      type = Token.BooleanLiteral;\n    } else {\n      type = Token.Identifier;\n    }\n    return {\n      type: type,\n      value: id,\n      lineNumber: lineNumber,\n      lineStart: lineStart,\n      range: [start, index]\n    };\n  }\n\n  // 7.7 Punctuators\n\n  function scanPunctuator() {\n    var start = index,\n      code = source.charCodeAt(index),\n      code2,\n      ch1 = source[index],\n      ch2,\n      ch3,\n      ch4;\n    if (state.inJSXTag || state.inJSXChild) {\n      // Don't need to check for '{' and '}' as it's already handled\n      // correctly by default.\n      switch (code) {\n        case 60: // <\n        case 62:\n          // >\n          ++index;\n          return {\n            type: Token.Punctuator,\n            value: String.fromCharCode(code),\n            lineNumber: lineNumber,\n            lineStart: lineStart,\n            range: [start, index]\n          };\n      }\n    }\n    switch (code) {\n      // Check for most common single-character punctuators.\n      case 40: // ( open bracket\n      case 41: // ) close bracket\n      case 59: // ; semicolon\n      case 44: // , comma\n      case 91: // [\n      case 93: // ]\n      case 58: // :\n      case 63: // ?\n      case 126:\n        // ~\n        ++index;\n        if (extra.tokenize && code === 40) {\n          extra.openParenToken = extra.tokens.length;\n        }\n        return {\n          type: Token.Punctuator,\n          value: String.fromCharCode(code),\n          lineNumber: lineNumber,\n          lineStart: lineStart,\n          range: [start, index]\n        };\n      case 123: // { open curly brace\n      case 125:\n        // } close curly brace\n        ++index;\n        if (extra.tokenize && code === 123) {\n          extra.openCurlyToken = extra.tokens.length;\n        }\n\n        // lookahead2 function can cause tokens to be scanned twice and in doing so\n        // would wreck the curly stack by pushing the same token onto the stack twice.\n        // curlyLastIndex ensures each token is pushed or popped exactly once\n        if (index > state.curlyLastIndex) {\n          state.curlyLastIndex = index;\n          if (code === 123) {\n            state.curlyStack.push('{');\n          } else {\n            state.curlyStack.pop();\n          }\n        }\n        return {\n          type: Token.Punctuator,\n          value: String.fromCharCode(code),\n          lineNumber: lineNumber,\n          lineStart: lineStart,\n          range: [start, index]\n        };\n      default:\n        code2 = source.charCodeAt(index + 1);\n\n        // '=' (char #61) marks an assignment or comparison operator.\n        if (code2 === 61) {\n          switch (code) {\n            case 37: // %\n            case 38: // &\n            case 42: // *:\n            case 43: // +\n            case 45: // -\n            case 47: // /\n            case 60: // <\n            case 62: // >\n            case 94: // ^\n            case 124:\n              // |\n              index += 2;\n              return {\n                type: Token.Punctuator,\n                value: String.fromCharCode(code) + String.fromCharCode(code2),\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                range: [start, index]\n              };\n            case 33: // !\n            case 61:\n              // =\n              index += 2;\n\n              // !== and ===\n              if (source.charCodeAt(index) === 61) {\n                ++index;\n              }\n              return {\n                type: Token.Punctuator,\n                value: source.slice(start, index),\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                range: [start, index]\n              };\n            default:\n              break;\n          }\n        }\n        break;\n    }\n\n    // Peek more characters.\n\n    ch2 = source[index + 1];\n    ch3 = source[index + 2];\n    ch4 = source[index + 3];\n\n    // 4-character punctuator: >>>=\n\n    if (ch1 === '>' && ch2 === '>' && ch3 === '>') {\n      if (ch4 === '=') {\n        index += 4;\n        return {\n          type: Token.Punctuator,\n          value: '>>>=',\n          lineNumber: lineNumber,\n          lineStart: lineStart,\n          range: [start, index]\n        };\n      }\n    }\n\n    // 3-character punctuators: === !== >>> <<= >>=\n\n    if (ch1 === '>' && ch2 === '>' && ch3 === '>' && !state.inType) {\n      index += 3;\n      return {\n        type: Token.Punctuator,\n        value: '>>>',\n        lineNumber: lineNumber,\n        lineStart: lineStart,\n        range: [start, index]\n      };\n    }\n    if (ch1 === '<' && ch2 === '<' && ch3 === '=') {\n      index += 3;\n      return {\n        type: Token.Punctuator,\n        value: '<<=',\n        lineNumber: lineNumber,\n        lineStart: lineStart,\n        range: [start, index]\n      };\n    }\n    if (ch1 === '>' && ch2 === '>' && ch3 === '=') {\n      index += 3;\n      return {\n        type: Token.Punctuator,\n        value: '>>=',\n        lineNumber: lineNumber,\n        lineStart: lineStart,\n        range: [start, index]\n      };\n    }\n    if (ch1 === '.' && ch2 === '.' && ch3 === '.') {\n      index += 3;\n      return {\n        type: Token.Punctuator,\n        value: '...',\n        lineNumber: lineNumber,\n        lineStart: lineStart,\n        range: [start, index]\n      };\n    }\n\n    // Other 2-character punctuators: ++ -- << >> && ||\n\n    // Don't match these tokens if we're in a type, since they never can\n    // occur and can mess up types like Map<string, Array<string>>\n    if (ch1 === ch2 && '+-<>&|'.indexOf(ch1) >= 0 && !state.inType) {\n      index += 2;\n      return {\n        type: Token.Punctuator,\n        value: ch1 + ch2,\n        lineNumber: lineNumber,\n        lineStart: lineStart,\n        range: [start, index]\n      };\n    }\n    if (ch1 === '=' && ch2 === '>') {\n      index += 2;\n      return {\n        type: Token.Punctuator,\n        value: '=>',\n        lineNumber: lineNumber,\n        lineStart: lineStart,\n        range: [start, index]\n      };\n    }\n    if ('<>=!+-*%&|^/'.indexOf(ch1) >= 0) {\n      ++index;\n      return {\n        type: Token.Punctuator,\n        value: ch1,\n        lineNumber: lineNumber,\n        lineStart: lineStart,\n        range: [start, index]\n      };\n    }\n    if (ch1 === '.') {\n      ++index;\n      return {\n        type: Token.Punctuator,\n        value: ch1,\n        lineNumber: lineNumber,\n        lineStart: lineStart,\n        range: [start, index]\n      };\n    }\n    throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n  }\n\n  // 7.8.3 Numeric Literals\n\n  function scanHexLiteral(start) {\n    var number = '';\n    while (index < length) {\n      if (!isHexDigit(source[index])) {\n        break;\n      }\n      number += source[index++];\n    }\n    if (number.length === 0) {\n      throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n    }\n    if (isIdentifierStart(source.charCodeAt(index))) {\n      throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n    }\n    return {\n      type: Token.NumericLiteral,\n      value: parseInt('0x' + number, 16),\n      lineNumber: lineNumber,\n      lineStart: lineStart,\n      range: [start, index]\n    };\n  }\n  function scanBinaryLiteral(start) {\n    var ch, number;\n    number = '';\n    while (index < length) {\n      ch = source[index];\n      if (ch !== '0' && ch !== '1') {\n        break;\n      }\n      number += source[index++];\n    }\n    if (number.length === 0) {\n      // only 0b or 0B\n      throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n    }\n    if (index < length) {\n      ch = source.charCodeAt(index);\n      /* istanbul ignore else */\n      if (isIdentifierStart(ch) || isDecimalDigit(ch)) {\n        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n      }\n    }\n    return {\n      type: Token.NumericLiteral,\n      value: parseInt(number, 2),\n      lineNumber: lineNumber,\n      lineStart: lineStart,\n      range: [start, index]\n    };\n  }\n  function scanOctalLiteral(prefix, start) {\n    var number, octal;\n    if (isOctalDigit(prefix)) {\n      octal = true;\n      number = '0' + source[index++];\n    } else {\n      octal = false;\n      ++index;\n      number = '';\n    }\n    while (index < length) {\n      if (!isOctalDigit(source[index])) {\n        break;\n      }\n      number += source[index++];\n    }\n    if (!octal && number.length === 0) {\n      // only 0o or 0O\n      throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n    }\n    if (isIdentifierStart(source.charCodeAt(index)) || isDecimalDigit(source.charCodeAt(index))) {\n      throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n    }\n    return {\n      type: Token.NumericLiteral,\n      value: parseInt(number, 8),\n      octal: octal,\n      lineNumber: lineNumber,\n      lineStart: lineStart,\n      range: [start, index]\n    };\n  }\n  function scanNumericLiteral() {\n    var number, start, ch;\n    ch = source[index];\n    assert(isDecimalDigit(ch.charCodeAt(0)) || ch === '.', 'Numeric literal must start with a decimal digit or a decimal point');\n    start = index;\n    number = '';\n    if (ch !== '.') {\n      number = source[index++];\n      ch = source[index];\n\n      // Hex number starts with '0x'.\n      // Octal number starts with '0'.\n      // Octal number in ES6 starts with '0o'.\n      // Binary number in ES6 starts with '0b'.\n      if (number === '0') {\n        if (ch === 'x' || ch === 'X') {\n          ++index;\n          return scanHexLiteral(start);\n        }\n        if (ch === 'b' || ch === 'B') {\n          ++index;\n          return scanBinaryLiteral(start);\n        }\n        if (ch === 'o' || ch === 'O' || isOctalDigit(ch)) {\n          return scanOctalLiteral(ch, start);\n        }\n        // decimal number starts with '0' such as '09' is illegal.\n        if (ch && isDecimalDigit(ch.charCodeAt(0))) {\n          throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n        }\n      }\n      while (isDecimalDigit(source.charCodeAt(index))) {\n        number += source[index++];\n      }\n      ch = source[index];\n    }\n    if (ch === '.') {\n      number += source[index++];\n      while (isDecimalDigit(source.charCodeAt(index))) {\n        number += source[index++];\n      }\n      ch = source[index];\n    }\n    if (ch === 'e' || ch === 'E') {\n      number += source[index++];\n      ch = source[index];\n      if (ch === '+' || ch === '-') {\n        number += source[index++];\n      }\n      if (isDecimalDigit(source.charCodeAt(index))) {\n        while (isDecimalDigit(source.charCodeAt(index))) {\n          number += source[index++];\n        }\n      } else {\n        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n      }\n    }\n    if (isIdentifierStart(source.charCodeAt(index))) {\n      throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n    }\n    return {\n      type: Token.NumericLiteral,\n      value: parseFloat(number),\n      lineNumber: lineNumber,\n      lineStart: lineStart,\n      range: [start, index]\n    };\n  }\n\n  // 7.8.4 String Literals\n\n  function scanStringLiteral() {\n    var str = '',\n      quote,\n      start,\n      ch,\n      code,\n      unescaped,\n      restore,\n      octal = false;\n    quote = source[index];\n    assert(quote === '\\'' || quote === '\"', 'String literal must starts with a quote');\n    start = index;\n    ++index;\n    while (index < length) {\n      ch = source[index++];\n      if (ch === quote) {\n        quote = '';\n        break;\n      } else if (ch === '\\\\') {\n        ch = source[index++];\n        if (!ch || !isLineTerminator(ch.charCodeAt(0))) {\n          switch (ch) {\n            case 'n':\n              str += '\\n';\n              break;\n            case 'r':\n              str += '\\r';\n              break;\n            case 't':\n              str += '\\t';\n              break;\n            case 'u':\n            case 'x':\n              if (source[index] === '{') {\n                ++index;\n                str += scanUnicodeCodePointEscape();\n              } else {\n                restore = index;\n                unescaped = scanHexEscape(ch);\n                if (unescaped) {\n                  str += unescaped;\n                } else {\n                  index = restore;\n                  str += ch;\n                }\n              }\n              break;\n            case 'b':\n              str += '\\b';\n              break;\n            case 'f':\n              str += '\\f';\n              break;\n            case 'v':\n              str += '\\x0B';\n              break;\n            default:\n              if (isOctalDigit(ch)) {\n                code = '01234567'.indexOf(ch);\n\n                // \\0 is not octal escape sequence\n                if (code !== 0) {\n                  octal = true;\n                }\n\n                /* istanbul ignore else */\n                if (index < length && isOctalDigit(source[index])) {\n                  octal = true;\n                  code = code * 8 + '01234567'.indexOf(source[index++]);\n\n                  // 3 digits are only allowed when string starts\n                  // with 0, 1, 2, 3\n                  if ('0123'.indexOf(ch) >= 0 && index < length && isOctalDigit(source[index])) {\n                    code = code * 8 + '01234567'.indexOf(source[index++]);\n                  }\n                }\n                str += String.fromCharCode(code);\n              } else {\n                str += ch;\n              }\n              break;\n          }\n        } else {\n          ++lineNumber;\n          if (ch === '\\r' && source[index] === '\\n') {\n            ++index;\n          }\n          lineStart = index;\n        }\n      } else if (isLineTerminator(ch.charCodeAt(0))) {\n        break;\n      } else {\n        str += ch;\n      }\n    }\n    if (quote !== '') {\n      throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n    }\n    return {\n      type: Token.StringLiteral,\n      value: str,\n      octal: octal,\n      lineNumber: lineNumber,\n      lineStart: lineStart,\n      range: [start, index]\n    };\n  }\n  function scanTemplate() {\n    var cooked = '',\n      ch,\n      start,\n      terminated,\n      head,\n      tail,\n      restore,\n      unescaped,\n      code,\n      octal;\n    terminated = false;\n    tail = false;\n    start = index;\n    head = source[index] === '`';\n    ++index;\n    while (index < length) {\n      ch = source[index++];\n      if (ch === '`') {\n        tail = true;\n        terminated = true;\n        break;\n      } else if (ch === '$') {\n        if (source[index] === '{') {\n          ++index;\n          terminated = true;\n          break;\n        }\n        cooked += ch;\n      } else if (ch === '\\\\') {\n        ch = source[index++];\n        if (!isLineTerminator(ch.charCodeAt(0))) {\n          switch (ch) {\n            case 'n':\n              cooked += '\\n';\n              break;\n            case 'r':\n              cooked += '\\r';\n              break;\n            case 't':\n              cooked += '\\t';\n              break;\n            case 'u':\n            case 'x':\n              if (source[index] === '{') {\n                ++index;\n                cooked += scanUnicodeCodePointEscape();\n              } else {\n                restore = index;\n                unescaped = scanHexEscape(ch);\n                if (unescaped) {\n                  cooked += unescaped;\n                } else {\n                  index = restore;\n                  cooked += ch;\n                }\n              }\n              break;\n            case 'b':\n              cooked += '\\b';\n              break;\n            case 'f':\n              cooked += '\\f';\n              break;\n            case 'v':\n              cooked += '\\v';\n              break;\n            default:\n              if (isOctalDigit(ch)) {\n                code = '01234567'.indexOf(ch);\n\n                // \\0 is not octal escape sequence\n                if (code !== 0) {\n                  octal = true;\n                }\n\n                /* istanbul ignore else */\n                if (index < length && isOctalDigit(source[index])) {\n                  octal = true;\n                  code = code * 8 + '01234567'.indexOf(source[index++]);\n\n                  // 3 digits are only allowed when string starts\n                  // with 0, 1, 2, 3\n                  if ('0123'.indexOf(ch) >= 0 && index < length && isOctalDigit(source[index])) {\n                    code = code * 8 + '01234567'.indexOf(source[index++]);\n                  }\n                }\n                cooked += String.fromCharCode(code);\n              } else {\n                cooked += ch;\n              }\n              break;\n          }\n        } else {\n          ++lineNumber;\n          if (ch === '\\r' && source[index] === '\\n') {\n            ++index;\n          }\n          lineStart = index;\n        }\n      } else if (isLineTerminator(ch.charCodeAt(0))) {\n        ++lineNumber;\n        if (ch === '\\r' && source[index] === '\\n') {\n          ++index;\n        }\n        lineStart = index;\n        cooked += '\\n';\n      } else {\n        cooked += ch;\n      }\n    }\n    if (!terminated) {\n      throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n    }\n    if (index > state.curlyLastIndex) {\n      state.curlyLastIndex = index;\n      if (!tail) {\n        state.curlyStack.push('template');\n      }\n      if (!head) {\n        state.curlyStack.pop();\n      }\n    }\n    return {\n      type: Token.Template,\n      value: {\n        cooked: cooked,\n        raw: source.slice(start + 1, index - (tail ? 1 : 2))\n      },\n      head: head,\n      tail: tail,\n      octal: octal,\n      lineNumber: lineNumber,\n      lineStart: lineStart,\n      range: [start, index]\n    };\n  }\n  function testRegExp(pattern, flags) {\n    var tmp = pattern,\n      value;\n    if (flags.indexOf('u') >= 0) {\n      // Replace each astral symbol and every Unicode code point\n      // escape sequence with a single ASCII symbol to avoid throwing on\n      // regular expressions that are only valid in combination with the\n      // `/u` flag.\n      // Note: replacing with the ASCII symbol `x` might cause false\n      // negatives in unlikely scenarios. For example, `[\\u{61}-b]` is a\n      // perfectly valid pattern that is equivalent to `[a-b]`, but it\n      // would be replaced by `[x-b]` which throws an error.\n      tmp = tmp.replace(/\\\\u\\{([0-9a-fA-F]+)\\}/g, function ($0, $1) {\n        if (parseInt($1, 16) <= 0x10FFFF) {\n          return 'x';\n        }\n        throwError({}, Messages.InvalidRegExp);\n      }).replace(/[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g, 'x');\n    }\n\n    // First, detect invalid regular expressions.\n    try {\n      value = new RegExp(tmp);\n    } catch (e) {\n      throwError({}, Messages.InvalidRegExp);\n    }\n\n    // Return a regular expression object for this pattern-flag pair, or\n    // `null` in case the current environment doesn't support the flags it\n    // uses.\n    try {\n      return new RegExp(pattern, flags);\n    } catch (exception) {\n      return null;\n    }\n  }\n  function scanRegExpBody() {\n    var ch, str, classMarker, terminated, body;\n    ch = source[index];\n    assert(ch === '/', 'Regular expression literal must start with a slash');\n    str = source[index++];\n    classMarker = false;\n    terminated = false;\n    while (index < length) {\n      ch = source[index++];\n      str += ch;\n      if (ch === '\\\\') {\n        ch = source[index++];\n        // ECMA-262 7.8.5\n        if (isLineTerminator(ch.charCodeAt(0))) {\n          throwError({}, Messages.UnterminatedRegExp);\n        }\n        str += ch;\n      } else if (isLineTerminator(ch.charCodeAt(0))) {\n        throwError({}, Messages.UnterminatedRegExp);\n      } else if (classMarker) {\n        if (ch === ']') {\n          classMarker = false;\n        }\n      } else {\n        if (ch === '/') {\n          terminated = true;\n          break;\n        } else if (ch === '[') {\n          classMarker = true;\n        }\n      }\n    }\n    if (!terminated) {\n      throwError({}, Messages.UnterminatedRegExp);\n    }\n\n    // Exclude leading and trailing slash.\n    body = str.substr(1, str.length - 2);\n    return {\n      value: body,\n      literal: str\n    };\n  }\n  function scanRegExpFlags() {\n    var ch, str, flags, restore;\n    str = '';\n    flags = '';\n    while (index < length) {\n      ch = source[index];\n      if (!isIdentifierPart(ch.charCodeAt(0))) {\n        break;\n      }\n      ++index;\n      if (ch === '\\\\' && index < length) {\n        ch = source[index];\n        if (ch === 'u') {\n          ++index;\n          restore = index;\n          ch = scanHexEscape('u');\n          if (ch) {\n            flags += ch;\n            for (str += \"\\\\u\"; restore < index; ++restore) {\n              str += source[restore];\n            }\n          } else {\n            index = restore;\n            flags += 'u';\n            str += \"\\\\u\";\n          }\n          throwErrorTolerant({}, Messages.UnexpectedToken, 'ILLEGAL');\n        } else {\n          str += '\\\\';\n          throwErrorTolerant({}, Messages.UnexpectedToken, 'ILLEGAL');\n        }\n      } else {\n        flags += ch;\n        str += ch;\n      }\n    }\n    return {\n      value: flags,\n      literal: str\n    };\n  }\n  function scanRegExp() {\n    var start, body, flags, value;\n    lookahead = null;\n    skipComment();\n    start = index;\n    body = scanRegExpBody();\n    flags = scanRegExpFlags();\n    value = testRegExp(body.value, flags.value);\n    if (extra.tokenize) {\n      return {\n        type: Token.RegularExpression,\n        value: value,\n        regex: {\n          pattern: body.value,\n          flags: flags.value\n        },\n        lineNumber: lineNumber,\n        lineStart: lineStart,\n        range: [start, index]\n      };\n    }\n    return {\n      literal: body.literal + flags.literal,\n      value: value,\n      regex: {\n        pattern: body.value,\n        flags: flags.value\n      },\n      range: [start, index]\n    };\n  }\n  function isIdentifierName(token) {\n    return token.type === Token.Identifier || token.type === Token.Keyword || token.type === Token.BooleanLiteral || token.type === Token.NullLiteral;\n  }\n  function advanceSlash() {\n    var prevToken, checkToken;\n    // Using the following algorithm:\n    // https://github.com/mozilla/sweet.js/wiki/design\n    prevToken = extra.tokens[extra.tokens.length - 1];\n    if (!prevToken) {\n      // Nothing before that: it cannot be a division.\n      return scanRegExp();\n    }\n    if (prevToken.type === 'Punctuator') {\n      if (prevToken.value === ')') {\n        checkToken = extra.tokens[extra.openParenToken - 1];\n        if (checkToken && checkToken.type === 'Keyword' && (checkToken.value === 'if' || checkToken.value === 'while' || checkToken.value === 'for' || checkToken.value === 'with')) {\n          return scanRegExp();\n        }\n        return scanPunctuator();\n      }\n      if (prevToken.value === '}') {\n        // Dividing a function by anything makes little sense,\n        // but we have to check for that.\n        if (extra.tokens[extra.openCurlyToken - 3] && extra.tokens[extra.openCurlyToken - 3].type === 'Keyword') {\n          // Anonymous function.\n          checkToken = extra.tokens[extra.openCurlyToken - 4];\n          if (!checkToken) {\n            return scanPunctuator();\n          }\n        } else if (extra.tokens[extra.openCurlyToken - 4] && extra.tokens[extra.openCurlyToken - 4].type === 'Keyword') {\n          // Named function.\n          checkToken = extra.tokens[extra.openCurlyToken - 5];\n          if (!checkToken) {\n            return scanRegExp();\n          }\n        } else {\n          return scanPunctuator();\n        }\n        // checkToken determines whether the function is\n        // a declaration or an expression.\n        if (FnExprTokens.indexOf(checkToken.value) >= 0) {\n          // It is an expression.\n          return scanPunctuator();\n        }\n        // It is a declaration.\n        return scanRegExp();\n      }\n      return scanRegExp();\n    }\n    if (prevToken.type === 'Keyword' && prevToken.value !== 'this') {\n      return scanRegExp();\n    }\n    return scanPunctuator();\n  }\n  function advance() {\n    var ch;\n    if (!state.inJSXChild) {\n      skipComment();\n    }\n    if (index >= length) {\n      return {\n        type: Token.EOF,\n        lineNumber: lineNumber,\n        lineStart: lineStart,\n        range: [index, index]\n      };\n    }\n    if (state.inJSXChild) {\n      return advanceJSXChild();\n    }\n    ch = source.charCodeAt(index);\n\n    // Very common: ( and ) and ;\n    if (ch === 40 || ch === 41 || ch === 58) {\n      return scanPunctuator();\n    }\n\n    // String literal starts with single quote (#39) or double quote (#34).\n    if (ch === 39 || ch === 34) {\n      if (state.inJSXTag) {\n        return scanJSXStringLiteral();\n      }\n      return scanStringLiteral();\n    }\n    if (state.inJSXTag && isJSXIdentifierStart(ch)) {\n      return scanJSXIdentifier();\n    }\n\n    // Template literals start with backtick (#96) for template head\n    // or close curly (#125) for template middle or template tail.\n    if (ch === 96 || ch === 125 && state.curlyStack[state.curlyStack.length - 1] === 'template') {\n      return scanTemplate();\n    }\n    if (isIdentifierStart(ch)) {\n      return scanIdentifier();\n    }\n\n    // Dot (.) char #46 can also start a floating-point number, hence the need\n    // to check the next character.\n    if (ch === 46) {\n      if (isDecimalDigit(source.charCodeAt(index + 1))) {\n        return scanNumericLiteral();\n      }\n      return scanPunctuator();\n    }\n    if (isDecimalDigit(ch)) {\n      return scanNumericLiteral();\n    }\n\n    // Slash (/) char #47 can also start a regex.\n    if (extra.tokenize && ch === 47) {\n      return advanceSlash();\n    }\n    return scanPunctuator();\n  }\n  function lex() {\n    var token;\n    token = lookahead;\n    index = token.range[1];\n    lineNumber = token.lineNumber;\n    lineStart = token.lineStart;\n    lookahead = advance();\n    index = token.range[1];\n    lineNumber = token.lineNumber;\n    lineStart = token.lineStart;\n    return token;\n  }\n  function peek() {\n    var pos, line, start;\n    pos = index;\n    line = lineNumber;\n    start = lineStart;\n    lookahead = advance();\n    index = pos;\n    lineNumber = line;\n    lineStart = start;\n  }\n  function lookahead2() {\n    var adv, pos, line, start, result;\n\n    // If we are collecting the tokens, don't grab the next one yet.\n    /* istanbul ignore next */\n    adv = typeof extra.advance === 'function' ? extra.advance : advance;\n    pos = index;\n    line = lineNumber;\n    start = lineStart;\n\n    // Scan for the next immediate token.\n    /* istanbul ignore if */\n    if (lookahead === null) {\n      lookahead = adv();\n    }\n    index = lookahead.range[1];\n    lineNumber = lookahead.lineNumber;\n    lineStart = lookahead.lineStart;\n\n    // Grab the token right after.\n    result = adv();\n    index = pos;\n    lineNumber = line;\n    lineStart = start;\n    return result;\n  }\n  function rewind(token) {\n    index = token.range[0];\n    lineNumber = token.lineNumber;\n    lineStart = token.lineStart;\n    lookahead = token;\n  }\n  function markerCreate() {\n    if (!extra.loc && !extra.range) {\n      return undefined;\n    }\n    skipComment();\n    return {\n      offset: index,\n      line: lineNumber,\n      col: index - lineStart\n    };\n  }\n  function markerCreatePreserveWhitespace() {\n    if (!extra.loc && !extra.range) {\n      return undefined;\n    }\n    return {\n      offset: index,\n      line: lineNumber,\n      col: index - lineStart\n    };\n  }\n  function processComment(node) {\n    var lastChild,\n      trailingComments,\n      bottomRight = extra.bottomRightStack,\n      last = bottomRight[bottomRight.length - 1];\n    if (node.type === Syntax.Program) {\n      /* istanbul ignore else */\n      if (node.body.length > 0) {\n        return;\n      }\n    }\n    if (extra.trailingComments.length > 0) {\n      if (extra.trailingComments[0].range[0] >= node.range[1]) {\n        trailingComments = extra.trailingComments;\n        extra.trailingComments = [];\n      } else {\n        extra.trailingComments.length = 0;\n      }\n    } else {\n      if (last && last.trailingComments && last.trailingComments[0].range[0] >= node.range[1]) {\n        trailingComments = last.trailingComments;\n        delete last.trailingComments;\n      }\n    }\n\n    // Eating the stack.\n    if (last) {\n      while (last && last.range[0] >= node.range[0]) {\n        lastChild = last;\n        last = bottomRight.pop();\n      }\n    }\n    if (lastChild) {\n      if (lastChild.leadingComments && lastChild.leadingComments[lastChild.leadingComments.length - 1].range[1] <= node.range[0]) {\n        node.leadingComments = lastChild.leadingComments;\n        delete lastChild.leadingComments;\n      }\n    } else if (extra.leadingComments.length > 0 && extra.leadingComments[extra.leadingComments.length - 1].range[1] <= node.range[0]) {\n      node.leadingComments = extra.leadingComments;\n      extra.leadingComments = [];\n    }\n    if (trailingComments) {\n      node.trailingComments = trailingComments;\n    }\n    bottomRight.push(node);\n  }\n  function markerApply(marker, node) {\n    if (extra.range) {\n      node.range = [marker.offset, index];\n    }\n    if (extra.loc) {\n      node.loc = {\n        start: {\n          line: marker.line,\n          column: marker.col\n        },\n        end: {\n          line: lineNumber,\n          column: index - lineStart\n        }\n      };\n      node = delegate.postProcess(node);\n    }\n    if (extra.attachComment) {\n      processComment(node);\n    }\n    return node;\n  }\n  SyntaxTreeDelegate = {\n    name: 'SyntaxTree',\n    postProcess: function postProcess(node) {\n      return node;\n    },\n    createArrayExpression: function createArrayExpression(elements) {\n      return {\n        type: Syntax.ArrayExpression,\n        elements: elements\n      };\n    },\n    createAssignmentExpression: function createAssignmentExpression(operator, left, right) {\n      return {\n        type: Syntax.AssignmentExpression,\n        operator: operator,\n        left: left,\n        right: right\n      };\n    },\n    createBinaryExpression: function createBinaryExpression(operator, left, right) {\n      var type = operator === '||' || operator === '&&' ? Syntax.LogicalExpression : Syntax.BinaryExpression;\n      return {\n        type: type,\n        operator: operator,\n        left: left,\n        right: right\n      };\n    },\n    createBlockStatement: function createBlockStatement(body) {\n      return {\n        type: Syntax.BlockStatement,\n        body: body\n      };\n    },\n    createBreakStatement: function createBreakStatement(label) {\n      return {\n        type: Syntax.BreakStatement,\n        label: label\n      };\n    },\n    createCallExpression: function createCallExpression(callee, args) {\n      return {\n        type: Syntax.CallExpression,\n        callee: callee,\n        'arguments': args\n      };\n    },\n    createCatchClause: function createCatchClause(param, body) {\n      return {\n        type: Syntax.CatchClause,\n        param: param,\n        body: body\n      };\n    },\n    createConditionalExpression: function createConditionalExpression(test, consequent, alternate) {\n      return {\n        type: Syntax.ConditionalExpression,\n        test: test,\n        consequent: consequent,\n        alternate: alternate\n      };\n    },\n    createContinueStatement: function createContinueStatement(label) {\n      return {\n        type: Syntax.ContinueStatement,\n        label: label\n      };\n    },\n    createDebuggerStatement: function createDebuggerStatement() {\n      return {\n        type: Syntax.DebuggerStatement\n      };\n    },\n    createDoWhileStatement: function createDoWhileStatement(body, test) {\n      return {\n        type: Syntax.DoWhileStatement,\n        body: body,\n        test: test\n      };\n    },\n    createEmptyStatement: function createEmptyStatement() {\n      return {\n        type: Syntax.EmptyStatement\n      };\n    },\n    createExpressionStatement: function createExpressionStatement(expression) {\n      return {\n        type: Syntax.ExpressionStatement,\n        expression: expression\n      };\n    },\n    createForStatement: function createForStatement(init, test, update, body) {\n      return {\n        type: Syntax.ForStatement,\n        init: init,\n        test: test,\n        update: update,\n        body: body\n      };\n    },\n    createForInStatement: function createForInStatement(left, right, body) {\n      return {\n        type: Syntax.ForInStatement,\n        left: left,\n        right: right,\n        body: body,\n        each: false\n      };\n    },\n    createForOfStatement: function createForOfStatement(left, right, body) {\n      return {\n        type: Syntax.ForOfStatement,\n        left: left,\n        right: right,\n        body: body\n      };\n    },\n    createFunctionDeclaration: function createFunctionDeclaration(id, params, defaults, body, rest, generator, expression, isAsync, returnType, typeParameters) {\n      var funDecl = {\n        type: Syntax.FunctionDeclaration,\n        id: id,\n        params: params,\n        defaults: defaults,\n        body: body,\n        rest: rest,\n        generator: generator,\n        expression: expression,\n        returnType: returnType,\n        typeParameters: typeParameters\n      };\n      if (isAsync) {\n        funDecl.async = true;\n      }\n      return funDecl;\n    },\n    createFunctionExpression: function createFunctionExpression(id, params, defaults, body, rest, generator, expression, isAsync, returnType, typeParameters) {\n      var funExpr = {\n        type: Syntax.FunctionExpression,\n        id: id,\n        params: params,\n        defaults: defaults,\n        body: body,\n        rest: rest,\n        generator: generator,\n        expression: expression,\n        returnType: returnType,\n        typeParameters: typeParameters\n      };\n      if (isAsync) {\n        funExpr.async = true;\n      }\n      return funExpr;\n    },\n    createIdentifier: function createIdentifier(name) {\n      return {\n        type: Syntax.Identifier,\n        name: name,\n        // Only here to initialize the shape of the object to ensure\n        // that the 'typeAnnotation' key is ordered before others that\n        // are added later (like 'loc' and 'range'). This just helps\n        // keep the shape of Identifier nodes consistent with everything\n        // else.\n        typeAnnotation: undefined,\n        optional: undefined\n      };\n    },\n    createTypeAnnotation: function createTypeAnnotation(typeAnnotation) {\n      return {\n        type: Syntax.TypeAnnotation,\n        typeAnnotation: typeAnnotation\n      };\n    },\n    createTypeCast: function createTypeCast(expression, typeAnnotation) {\n      return {\n        type: Syntax.TypeCastExpression,\n        expression: expression,\n        typeAnnotation: typeAnnotation\n      };\n    },\n    createFunctionTypeAnnotation: function createFunctionTypeAnnotation(params, returnType, rest, typeParameters) {\n      return {\n        type: Syntax.FunctionTypeAnnotation,\n        params: params,\n        returnType: returnType,\n        rest: rest,\n        typeParameters: typeParameters\n      };\n    },\n    createFunctionTypeParam: function createFunctionTypeParam(name, typeAnnotation, optional) {\n      return {\n        type: Syntax.FunctionTypeParam,\n        name: name,\n        typeAnnotation: typeAnnotation,\n        optional: optional\n      };\n    },\n    createNullableTypeAnnotation: function createNullableTypeAnnotation(typeAnnotation) {\n      return {\n        type: Syntax.NullableTypeAnnotation,\n        typeAnnotation: typeAnnotation\n      };\n    },\n    createArrayTypeAnnotation: function createArrayTypeAnnotation(elementType) {\n      return {\n        type: Syntax.ArrayTypeAnnotation,\n        elementType: elementType\n      };\n    },\n    createGenericTypeAnnotation: function createGenericTypeAnnotation(id, typeParameters) {\n      return {\n        type: Syntax.GenericTypeAnnotation,\n        id: id,\n        typeParameters: typeParameters\n      };\n    },\n    createQualifiedTypeIdentifier: function createQualifiedTypeIdentifier(qualification, id) {\n      return {\n        type: Syntax.QualifiedTypeIdentifier,\n        qualification: qualification,\n        id: id\n      };\n    },\n    createTypeParameterDeclaration: function createTypeParameterDeclaration(params) {\n      return {\n        type: Syntax.TypeParameterDeclaration,\n        params: params\n      };\n    },\n    createTypeParameterInstantiation: function createTypeParameterInstantiation(params) {\n      return {\n        type: Syntax.TypeParameterInstantiation,\n        params: params\n      };\n    },\n    createAnyTypeAnnotation: function createAnyTypeAnnotation() {\n      return {\n        type: Syntax.AnyTypeAnnotation\n      };\n    },\n    createBooleanTypeAnnotation: function createBooleanTypeAnnotation() {\n      return {\n        type: Syntax.BooleanTypeAnnotation\n      };\n    },\n    createNumberTypeAnnotation: function createNumberTypeAnnotation() {\n      return {\n        type: Syntax.NumberTypeAnnotation\n      };\n    },\n    createStringTypeAnnotation: function createStringTypeAnnotation() {\n      return {\n        type: Syntax.StringTypeAnnotation\n      };\n    },\n    createStringLiteralTypeAnnotation: function createStringLiteralTypeAnnotation(token) {\n      return {\n        type: Syntax.StringLiteralTypeAnnotation,\n        value: token.value,\n        raw: source.slice(token.range[0], token.range[1])\n      };\n    },\n    createVoidTypeAnnotation: function createVoidTypeAnnotation() {\n      return {\n        type: Syntax.VoidTypeAnnotation\n      };\n    },\n    createTypeofTypeAnnotation: function createTypeofTypeAnnotation(argument) {\n      return {\n        type: Syntax.TypeofTypeAnnotation,\n        argument: argument\n      };\n    },\n    createTupleTypeAnnotation: function createTupleTypeAnnotation(types) {\n      return {\n        type: Syntax.TupleTypeAnnotation,\n        types: types\n      };\n    },\n    createObjectTypeAnnotation: function createObjectTypeAnnotation(properties, indexers, callProperties) {\n      return {\n        type: Syntax.ObjectTypeAnnotation,\n        properties: properties,\n        indexers: indexers,\n        callProperties: callProperties\n      };\n    },\n    createObjectTypeIndexer: function createObjectTypeIndexer(id, key, value, isStatic) {\n      return {\n        type: Syntax.ObjectTypeIndexer,\n        id: id,\n        key: key,\n        value: value,\n        static: isStatic\n      };\n    },\n    createObjectTypeCallProperty: function createObjectTypeCallProperty(value, isStatic) {\n      return {\n        type: Syntax.ObjectTypeCallProperty,\n        value: value,\n        static: isStatic\n      };\n    },\n    createObjectTypeProperty: function createObjectTypeProperty(key, value, optional, isStatic) {\n      return {\n        type: Syntax.ObjectTypeProperty,\n        key: key,\n        value: value,\n        optional: optional,\n        static: isStatic\n      };\n    },\n    createUnionTypeAnnotation: function createUnionTypeAnnotation(types) {\n      return {\n        type: Syntax.UnionTypeAnnotation,\n        types: types\n      };\n    },\n    createIntersectionTypeAnnotation: function createIntersectionTypeAnnotation(types) {\n      return {\n        type: Syntax.IntersectionTypeAnnotation,\n        types: types\n      };\n    },\n    createTypeAlias: function createTypeAlias(id, typeParameters, right) {\n      return {\n        type: Syntax.TypeAlias,\n        id: id,\n        typeParameters: typeParameters,\n        right: right\n      };\n    },\n    createInterface: function createInterface(id, typeParameters, body, extended) {\n      return {\n        type: Syntax.InterfaceDeclaration,\n        id: id,\n        typeParameters: typeParameters,\n        body: body,\n        extends: extended\n      };\n    },\n    createInterfaceExtends: function createInterfaceExtends(id, typeParameters) {\n      return {\n        type: Syntax.InterfaceExtends,\n        id: id,\n        typeParameters: typeParameters\n      };\n    },\n    createDeclareFunction: function createDeclareFunction(id) {\n      return {\n        type: Syntax.DeclareFunction,\n        id: id\n      };\n    },\n    createDeclareVariable: function createDeclareVariable(id) {\n      return {\n        type: Syntax.DeclareVariable,\n        id: id\n      };\n    },\n    createDeclareModule: function createDeclareModule(id, body) {\n      return {\n        type: Syntax.DeclareModule,\n        id: id,\n        body: body\n      };\n    },\n    createJSXAttribute: function createJSXAttribute(name, value) {\n      return {\n        type: Syntax.JSXAttribute,\n        name: name,\n        value: value || null\n      };\n    },\n    createJSXSpreadAttribute: function createJSXSpreadAttribute(argument) {\n      return {\n        type: Syntax.JSXSpreadAttribute,\n        argument: argument\n      };\n    },\n    createJSXIdentifier: function createJSXIdentifier(name) {\n      return {\n        type: Syntax.JSXIdentifier,\n        name: name\n      };\n    },\n    createJSXNamespacedName: function createJSXNamespacedName(namespace, name) {\n      return {\n        type: Syntax.JSXNamespacedName,\n        namespace: namespace,\n        name: name\n      };\n    },\n    createJSXMemberExpression: function createJSXMemberExpression(object, property) {\n      return {\n        type: Syntax.JSXMemberExpression,\n        object: object,\n        property: property\n      };\n    },\n    createJSXElement: function createJSXElement(openingElement, closingElement, children) {\n      return {\n        type: Syntax.JSXElement,\n        openingElement: openingElement,\n        closingElement: closingElement,\n        children: children\n      };\n    },\n    createJSXEmptyExpression: function createJSXEmptyExpression() {\n      return {\n        type: Syntax.JSXEmptyExpression\n      };\n    },\n    createJSXExpressionContainer: function createJSXExpressionContainer(expression) {\n      return {\n        type: Syntax.JSXExpressionContainer,\n        expression: expression\n      };\n    },\n    createJSXOpeningElement: function createJSXOpeningElement(name, attributes, selfClosing) {\n      return {\n        type: Syntax.JSXOpeningElement,\n        name: name,\n        selfClosing: selfClosing,\n        attributes: attributes\n      };\n    },\n    createJSXClosingElement: function createJSXClosingElement(name) {\n      return {\n        type: Syntax.JSXClosingElement,\n        name: name\n      };\n    },\n    createIfStatement: function createIfStatement(test, consequent, alternate) {\n      return {\n        type: Syntax.IfStatement,\n        test: test,\n        consequent: consequent,\n        alternate: alternate\n      };\n    },\n    createLabeledStatement: function createLabeledStatement(label, body) {\n      return {\n        type: Syntax.LabeledStatement,\n        label: label,\n        body: body\n      };\n    },\n    createLiteral: function createLiteral(token) {\n      var object = {\n        type: Syntax.Literal,\n        value: token.value,\n        raw: source.slice(token.range[0], token.range[1])\n      };\n      if (token.regex) {\n        object.regex = token.regex;\n      }\n      return object;\n    },\n    createMemberExpression: function createMemberExpression(accessor, object, property) {\n      return {\n        type: Syntax.MemberExpression,\n        computed: accessor === '[',\n        object: object,\n        property: property\n      };\n    },\n    createNewExpression: function createNewExpression(callee, args) {\n      return {\n        type: Syntax.NewExpression,\n        callee: callee,\n        'arguments': args\n      };\n    },\n    createObjectExpression: function createObjectExpression(properties) {\n      return {\n        type: Syntax.ObjectExpression,\n        properties: properties\n      };\n    },\n    createPostfixExpression: function createPostfixExpression(operator, argument) {\n      return {\n        type: Syntax.UpdateExpression,\n        operator: operator,\n        argument: argument,\n        prefix: false\n      };\n    },\n    createProgram: function createProgram(body) {\n      return {\n        type: Syntax.Program,\n        body: body\n      };\n    },\n    createProperty: function createProperty(kind, key, value, method, shorthand, computed) {\n      return {\n        type: Syntax.Property,\n        key: key,\n        value: value,\n        kind: kind,\n        method: method,\n        shorthand: shorthand,\n        computed: computed\n      };\n    },\n    createReturnStatement: function createReturnStatement(argument) {\n      return {\n        type: Syntax.ReturnStatement,\n        argument: argument\n      };\n    },\n    createSequenceExpression: function createSequenceExpression(expressions) {\n      return {\n        type: Syntax.SequenceExpression,\n        expressions: expressions\n      };\n    },\n    createSwitchCase: function createSwitchCase(test, consequent) {\n      return {\n        type: Syntax.SwitchCase,\n        test: test,\n        consequent: consequent\n      };\n    },\n    createSwitchStatement: function createSwitchStatement(discriminant, cases) {\n      return {\n        type: Syntax.SwitchStatement,\n        discriminant: discriminant,\n        cases: cases\n      };\n    },\n    createThisExpression: function createThisExpression() {\n      return {\n        type: Syntax.ThisExpression\n      };\n    },\n    createThrowStatement: function createThrowStatement(argument) {\n      return {\n        type: Syntax.ThrowStatement,\n        argument: argument\n      };\n    },\n    createTryStatement: function createTryStatement(block, guardedHandlers, handlers, finalizer) {\n      return {\n        type: Syntax.TryStatement,\n        block: block,\n        guardedHandlers: guardedHandlers,\n        handlers: handlers,\n        finalizer: finalizer\n      };\n    },\n    createUnaryExpression: function createUnaryExpression(operator, argument) {\n      if (operator === '++' || operator === '--') {\n        return {\n          type: Syntax.UpdateExpression,\n          operator: operator,\n          argument: argument,\n          prefix: true\n        };\n      }\n      return {\n        type: Syntax.UnaryExpression,\n        operator: operator,\n        argument: argument,\n        prefix: true\n      };\n    },\n    createVariableDeclaration: function createVariableDeclaration(declarations, kind) {\n      return {\n        type: Syntax.VariableDeclaration,\n        declarations: declarations,\n        kind: kind\n      };\n    },\n    createVariableDeclarator: function createVariableDeclarator(id, init) {\n      return {\n        type: Syntax.VariableDeclarator,\n        id: id,\n        init: init\n      };\n    },\n    createWhileStatement: function createWhileStatement(test, body) {\n      return {\n        type: Syntax.WhileStatement,\n        test: test,\n        body: body\n      };\n    },\n    createWithStatement: function createWithStatement(object, body) {\n      return {\n        type: Syntax.WithStatement,\n        object: object,\n        body: body\n      };\n    },\n    createTemplateElement: function createTemplateElement(value, tail) {\n      return {\n        type: Syntax.TemplateElement,\n        value: value,\n        tail: tail\n      };\n    },\n    createTemplateLiteral: function createTemplateLiteral(quasis, expressions) {\n      return {\n        type: Syntax.TemplateLiteral,\n        quasis: quasis,\n        expressions: expressions\n      };\n    },\n    createSpreadElement: function createSpreadElement(argument) {\n      return {\n        type: Syntax.SpreadElement,\n        argument: argument\n      };\n    },\n    createSpreadProperty: function createSpreadProperty(argument) {\n      return {\n        type: Syntax.SpreadProperty,\n        argument: argument\n      };\n    },\n    createTaggedTemplateExpression: function createTaggedTemplateExpression(tag, quasi) {\n      return {\n        type: Syntax.TaggedTemplateExpression,\n        tag: tag,\n        quasi: quasi\n      };\n    },\n    createArrowFunctionExpression: function createArrowFunctionExpression(params, defaults, body, rest, expression, isAsync) {\n      var arrowExpr = {\n        type: Syntax.ArrowFunctionExpression,\n        id: null,\n        params: params,\n        defaults: defaults,\n        body: body,\n        rest: rest,\n        generator: false,\n        expression: expression\n      };\n      if (isAsync) {\n        arrowExpr.async = true;\n      }\n      return arrowExpr;\n    },\n    createMethodDefinition: function createMethodDefinition(propertyType, kind, key, value, computed) {\n      return {\n        type: Syntax.MethodDefinition,\n        key: key,\n        value: value,\n        kind: kind,\n        'static': propertyType === ClassPropertyType.static,\n        computed: computed\n      };\n    },\n    createClassProperty: function createClassProperty(key, typeAnnotation, computed, isStatic) {\n      return {\n        type: Syntax.ClassProperty,\n        key: key,\n        typeAnnotation: typeAnnotation,\n        computed: computed,\n        static: isStatic\n      };\n    },\n    createClassBody: function createClassBody(body) {\n      return {\n        type: Syntax.ClassBody,\n        body: body\n      };\n    },\n    createClassImplements: function createClassImplements(id, typeParameters) {\n      return {\n        type: Syntax.ClassImplements,\n        id: id,\n        typeParameters: typeParameters\n      };\n    },\n    createClassExpression: function createClassExpression(id, superClass, body, typeParameters, superTypeParameters, implemented) {\n      return {\n        type: Syntax.ClassExpression,\n        id: id,\n        superClass: superClass,\n        body: body,\n        typeParameters: typeParameters,\n        superTypeParameters: superTypeParameters,\n        implements: implemented\n      };\n    },\n    createClassDeclaration: function createClassDeclaration(id, superClass, body, typeParameters, superTypeParameters, implemented) {\n      return {\n        type: Syntax.ClassDeclaration,\n        id: id,\n        superClass: superClass,\n        body: body,\n        typeParameters: typeParameters,\n        superTypeParameters: superTypeParameters,\n        implements: implemented\n      };\n    },\n    createExportSpecifier: function createExportSpecifier(id, name) {\n      return {\n        type: Syntax.ExportSpecifier,\n        id: id,\n        name: name\n      };\n    },\n    createExportBatchSpecifier: function createExportBatchSpecifier() {\n      return {\n        type: Syntax.ExportBatchSpecifier\n      };\n    },\n    createImportDefaultSpecifier: function createImportDefaultSpecifier(id) {\n      return {\n        type: Syntax.ImportDefaultSpecifier,\n        id: id\n      };\n    },\n    createImportNamespaceSpecifier: function createImportNamespaceSpecifier(id) {\n      return {\n        type: Syntax.ImportNamespaceSpecifier,\n        id: id\n      };\n    },\n    createExportDeclaration: function createExportDeclaration(isDefault, declaration, specifiers, src) {\n      return {\n        type: Syntax.ExportDeclaration,\n        'default': !!isDefault,\n        declaration: declaration,\n        specifiers: specifiers,\n        source: src\n      };\n    },\n    createImportSpecifier: function createImportSpecifier(id, name) {\n      return {\n        type: Syntax.ImportSpecifier,\n        id: id,\n        name: name\n      };\n    },\n    createImportDeclaration: function createImportDeclaration(specifiers, src, importKind) {\n      return {\n        type: Syntax.ImportDeclaration,\n        specifiers: specifiers,\n        source: src,\n        importKind: importKind\n      };\n    },\n    createYieldExpression: function createYieldExpression(argument, dlg) {\n      return {\n        type: Syntax.YieldExpression,\n        argument: argument,\n        delegate: dlg\n      };\n    },\n    createAwaitExpression: function createAwaitExpression(argument) {\n      return {\n        type: Syntax.AwaitExpression,\n        argument: argument\n      };\n    },\n    createComprehensionExpression: function createComprehensionExpression(filter, blocks, body) {\n      return {\n        type: Syntax.ComprehensionExpression,\n        filter: filter,\n        blocks: blocks,\n        body: body\n      };\n    }\n  };\n\n  // Return true if there is a line terminator before the next token.\n\n  function peekLineTerminator() {\n    var pos, line, start, found;\n    pos = index;\n    line = lineNumber;\n    start = lineStart;\n    skipComment();\n    found = lineNumber !== line;\n    index = pos;\n    lineNumber = line;\n    lineStart = start;\n    return found;\n  }\n\n  // Throw an exception\n\n  function throwError(token, messageFormat) {\n    var error,\n      args = Array.prototype.slice.call(arguments, 2),\n      msg = messageFormat.replace(/%(\\d)/g, function (whole, idx) {\n        assert(idx < args.length, 'Message reference must be in range');\n        return args[idx];\n      });\n    if (typeof token.lineNumber === 'number') {\n      error = new Error('Line ' + token.lineNumber + ': ' + msg);\n      error.index = token.range[0];\n      error.lineNumber = token.lineNumber;\n      error.column = token.range[0] - lineStart + 1;\n    } else {\n      error = new Error('Line ' + lineNumber + ': ' + msg);\n      error.index = index;\n      error.lineNumber = lineNumber;\n      error.column = index - lineStart + 1;\n    }\n    error.description = msg;\n    throw error;\n  }\n  function throwErrorTolerant() {\n    try {\n      throwError.apply(null, arguments);\n    } catch (e) {\n      if (extra.errors) {\n        extra.errors.push(e);\n      } else {\n        throw e;\n      }\n    }\n  }\n\n  // Throw an exception because of the token.\n\n  function throwUnexpected(token) {\n    if (token.type === Token.EOF) {\n      throwError(token, Messages.UnexpectedEOS);\n    }\n    if (token.type === Token.NumericLiteral) {\n      throwError(token, Messages.UnexpectedNumber);\n    }\n    if (token.type === Token.StringLiteral || token.type === Token.JSXText) {\n      throwError(token, Messages.UnexpectedString);\n    }\n    if (token.type === Token.Identifier) {\n      throwError(token, Messages.UnexpectedIdentifier);\n    }\n    if (token.type === Token.Keyword) {\n      if (isFutureReservedWord(token.value)) {\n        throwError(token, Messages.UnexpectedReserved);\n      } else if (strict && isStrictModeReservedWord(token.value)) {\n        throwErrorTolerant(token, Messages.StrictReservedWord);\n        return;\n      }\n      throwError(token, Messages.UnexpectedToken, token.value);\n    }\n    if (token.type === Token.Template) {\n      throwError(token, Messages.UnexpectedTemplate, token.value.raw);\n    }\n\n    // BooleanLiteral, NullLiteral, or Punctuator.\n    throwError(token, Messages.UnexpectedToken, token.value);\n  }\n\n  // Expect the next token to match the specified punctuator.\n  // If not, an exception will be thrown.\n\n  function expect(value) {\n    var token = lex();\n    if (token.type !== Token.Punctuator || token.value !== value) {\n      throwUnexpected(token);\n    }\n  }\n\n  // Expect the next token to match the specified keyword.\n  // If not, an exception will be thrown.\n\n  function expectKeyword(keyword, contextual) {\n    var token = lex();\n    if (token.type !== (contextual ? Token.Identifier : Token.Keyword) || token.value !== keyword) {\n      throwUnexpected(token);\n    }\n  }\n\n  // Expect the next token to match the specified contextual keyword.\n  // If not, an exception will be thrown.\n\n  function expectContextualKeyword(keyword) {\n    return expectKeyword(keyword, true);\n  }\n\n  // Return true if the next token matches the specified punctuator.\n\n  function match(value) {\n    return lookahead.type === Token.Punctuator && lookahead.value === value;\n  }\n\n  // Return true if the next token matches the specified keyword\n\n  function matchKeyword(keyword, contextual) {\n    var expectedType = contextual ? Token.Identifier : Token.Keyword;\n    return lookahead.type === expectedType && lookahead.value === keyword;\n  }\n\n  // Return true if the next token matches the specified contextual keyword\n\n  function matchContextualKeyword(keyword) {\n    return matchKeyword(keyword, true);\n  }\n\n  // Return true if the next token is an assignment operator\n\n  function matchAssign() {\n    var op;\n    if (lookahead.type !== Token.Punctuator) {\n      return false;\n    }\n    op = lookahead.value;\n    return op === '=' || op === '*=' || op === '/=' || op === '%=' || op === '+=' || op === '-=' || op === '<<=' || op === '>>=' || op === '>>>=' || op === '&=' || op === '^=' || op === '|=';\n  }\n\n  // Note that 'yield' is treated as a keyword in strict mode, but a\n  // contextual keyword (identifier) in non-strict mode, so we need to\n  // use matchKeyword('yield', false) and matchKeyword('yield', true)\n  // (i.e. matchContextualKeyword) appropriately.\n  function matchYield() {\n    return state.yieldAllowed && matchKeyword('yield', !strict);\n  }\n  function matchAsync() {\n    var backtrackToken = lookahead,\n      matches = false;\n    if (matchContextualKeyword('async')) {\n      lex(); // Make sure peekLineTerminator() starts after 'async'.\n      matches = !peekLineTerminator();\n      rewind(backtrackToken); // Revert the lex().\n    }\n\n    return matches;\n  }\n  function matchAwait() {\n    return state.awaitAllowed && matchContextualKeyword('await');\n  }\n  function consumeSemicolon() {\n    var line,\n      oldIndex = index,\n      oldLineNumber = lineNumber,\n      oldLineStart = lineStart,\n      oldLookahead = lookahead;\n\n    // Catch the very common case first: immediately a semicolon (char #59).\n    if (source.charCodeAt(index) === 59) {\n      lex();\n      return;\n    }\n    line = lineNumber;\n    skipComment();\n    if (lineNumber !== line) {\n      index = oldIndex;\n      lineNumber = oldLineNumber;\n      lineStart = oldLineStart;\n      lookahead = oldLookahead;\n      return;\n    }\n    if (match(';')) {\n      lex();\n      return;\n    }\n    if (lookahead.type !== Token.EOF && !match('}')) {\n      throwUnexpected(lookahead);\n    }\n  }\n\n  // Return true if provided expression is LeftHandSideExpression\n\n  function isLeftHandSide(expr) {\n    return expr.type === Syntax.Identifier || expr.type === Syntax.MemberExpression;\n  }\n  function isAssignableLeftHandSide(expr) {\n    return isLeftHandSide(expr) || expr.type === Syntax.ObjectPattern || expr.type === Syntax.ArrayPattern;\n  }\n\n  // 11.1.4 Array Initialiser\n\n  function parseArrayInitialiser() {\n    var elements = [],\n      blocks = [],\n      filter = null,\n      tmp,\n      possiblecomprehension = true,\n      marker = markerCreate();\n    expect('[');\n    while (!match(']')) {\n      if (lookahead.value === 'for' && lookahead.type === Token.Keyword) {\n        if (!possiblecomprehension) {\n          throwError({}, Messages.ComprehensionError);\n        }\n        matchKeyword('for');\n        tmp = parseForStatement({\n          ignoreBody: true\n        });\n        tmp.of = tmp.type === Syntax.ForOfStatement;\n        tmp.type = Syntax.ComprehensionBlock;\n        if (tmp.left.kind) {\n          // can't be let or const\n          throwError({}, Messages.ComprehensionError);\n        }\n        blocks.push(tmp);\n      } else if (lookahead.value === 'if' && lookahead.type === Token.Keyword) {\n        if (!possiblecomprehension) {\n          throwError({}, Messages.ComprehensionError);\n        }\n        expectKeyword('if');\n        expect('(');\n        filter = parseExpression();\n        expect(')');\n      } else if (lookahead.value === ',' && lookahead.type === Token.Punctuator) {\n        possiblecomprehension = false; // no longer allowed.\n        lex();\n        elements.push(null);\n      } else {\n        tmp = parseSpreadOrAssignmentExpression();\n        elements.push(tmp);\n        if (tmp && tmp.type === Syntax.SpreadElement) {\n          if (!match(']')) {\n            throwError({}, Messages.ElementAfterSpreadElement);\n          }\n        } else if (!(match(']') || matchKeyword('for') || matchKeyword('if'))) {\n          expect(','); // this lexes.\n          possiblecomprehension = false;\n        }\n      }\n    }\n    expect(']');\n    if (filter && !blocks.length) {\n      throwError({}, Messages.ComprehensionRequiresBlock);\n    }\n    if (blocks.length) {\n      if (elements.length !== 1) {\n        throwError({}, Messages.ComprehensionError);\n      }\n      return markerApply(marker, delegate.createComprehensionExpression(filter, blocks, elements[0]));\n    }\n    return markerApply(marker, delegate.createArrayExpression(elements));\n  }\n\n  // 11.1.5 Object Initialiser\n\n  function parsePropertyFunction(options) {\n    var previousStrict,\n      previousYieldAllowed,\n      previousAwaitAllowed,\n      params,\n      defaults,\n      body,\n      marker = markerCreate();\n    previousStrict = strict;\n    previousYieldAllowed = state.yieldAllowed;\n    state.yieldAllowed = options.generator;\n    previousAwaitAllowed = state.awaitAllowed;\n    state.awaitAllowed = options.async;\n    params = options.params || [];\n    defaults = options.defaults || [];\n    body = parseConciseBody();\n    if (options.name && strict && isRestrictedWord(params[0].name)) {\n      throwErrorTolerant(options.name, Messages.StrictParamName);\n    }\n    strict = previousStrict;\n    state.yieldAllowed = previousYieldAllowed;\n    state.awaitAllowed = previousAwaitAllowed;\n    return markerApply(marker, delegate.createFunctionExpression(null, params, defaults, body, options.rest || null, options.generator, body.type !== Syntax.BlockStatement, options.async, options.returnType, options.typeParameters));\n  }\n  function parsePropertyMethodFunction(options) {\n    var previousStrict, tmp, method;\n    previousStrict = strict;\n    strict = true;\n    tmp = parseParams();\n    if (tmp.stricted) {\n      throwErrorTolerant(tmp.stricted, tmp.message);\n    }\n    method = parsePropertyFunction({\n      params: tmp.params,\n      defaults: tmp.defaults,\n      rest: tmp.rest,\n      generator: options.generator,\n      async: options.async,\n      returnType: tmp.returnType,\n      typeParameters: options.typeParameters\n    });\n    strict = previousStrict;\n    return method;\n  }\n  function parseObjectPropertyKey() {\n    var marker = markerCreate(),\n      token = lex(),\n      propertyKey,\n      result;\n\n    // Note: This function is called only from parseObjectProperty(), where\n    // EOF and Punctuator tokens are already filtered out.\n\n    if (token.type === Token.StringLiteral || token.type === Token.NumericLiteral) {\n      if (strict && token.octal) {\n        throwErrorTolerant(token, Messages.StrictOctalLiteral);\n      }\n      return markerApply(marker, delegate.createLiteral(token));\n    }\n    if (token.type === Token.Punctuator && token.value === '[') {\n      // For computed properties we should skip the [ and ], and\n      // capture in marker only the assignment expression itself.\n      marker = markerCreate();\n      propertyKey = parseAssignmentExpression();\n      result = markerApply(marker, propertyKey);\n      expect(']');\n      return result;\n    }\n    return markerApply(marker, delegate.createIdentifier(token.value));\n  }\n  function parseObjectProperty() {\n    var token,\n      key,\n      id,\n      param,\n      computed,\n      marker = markerCreate(),\n      returnType,\n      typeParameters;\n    token = lookahead;\n    computed = token.value === '[' && token.type === Token.Punctuator;\n    if (token.type === Token.Identifier || computed || matchAsync()) {\n      id = parseObjectPropertyKey();\n      if (match(':')) {\n        lex();\n        return markerApply(marker, delegate.createProperty('init', id, parseAssignmentExpression(), false, false, computed));\n      }\n      if (match('(') || match('<')) {\n        if (match('<')) {\n          typeParameters = parseTypeParameterDeclaration();\n        }\n        return markerApply(marker, delegate.createProperty('init', id, parsePropertyMethodFunction({\n          generator: false,\n          async: false,\n          typeParameters: typeParameters\n        }), true, false, computed));\n      }\n\n      // Property Assignment: Getter and Setter.\n\n      if (token.value === 'get') {\n        computed = lookahead.value === '[';\n        key = parseObjectPropertyKey();\n        expect('(');\n        expect(')');\n        if (match(':')) {\n          returnType = parseTypeAnnotation();\n        }\n        return markerApply(marker, delegate.createProperty('get', key, parsePropertyFunction({\n          generator: false,\n          async: false,\n          returnType: returnType\n        }), false, false, computed));\n      }\n      if (token.value === 'set') {\n        computed = lookahead.value === '[';\n        key = parseObjectPropertyKey();\n        expect('(');\n        token = lookahead;\n        param = [parseTypeAnnotatableIdentifier()];\n        expect(')');\n        if (match(':')) {\n          returnType = parseTypeAnnotation();\n        }\n        return markerApply(marker, delegate.createProperty('set', key, parsePropertyFunction({\n          params: param,\n          generator: false,\n          async: false,\n          name: token,\n          returnType: returnType\n        }), false, false, computed));\n      }\n      if (token.value === 'async') {\n        computed = lookahead.value === '[';\n        key = parseObjectPropertyKey();\n        if (match('<')) {\n          typeParameters = parseTypeParameterDeclaration();\n        }\n        return markerApply(marker, delegate.createProperty('init', key, parsePropertyMethodFunction({\n          generator: false,\n          async: true,\n          typeParameters: typeParameters\n        }), true, false, computed));\n      }\n      if (computed) {\n        // Computed properties can only be used with full notation.\n        throwUnexpected(lookahead);\n      }\n      return markerApply(marker, delegate.createProperty('init', id, id, false, true, false));\n    }\n    if (token.type === Token.EOF || token.type === Token.Punctuator) {\n      if (!match('*')) {\n        throwUnexpected(token);\n      }\n      lex();\n      computed = lookahead.type === Token.Punctuator && lookahead.value === '[';\n      id = parseObjectPropertyKey();\n      if (match('<')) {\n        typeParameters = parseTypeParameterDeclaration();\n      }\n      if (!match('(')) {\n        throwUnexpected(lex());\n      }\n      return markerApply(marker, delegate.createProperty('init', id, parsePropertyMethodFunction({\n        generator: true,\n        typeParameters: typeParameters\n      }), true, false, computed));\n    }\n    key = parseObjectPropertyKey();\n    if (match(':')) {\n      lex();\n      return markerApply(marker, delegate.createProperty('init', key, parseAssignmentExpression(), false, false, false));\n    }\n    if (match('(') || match('<')) {\n      if (match('<')) {\n        typeParameters = parseTypeParameterDeclaration();\n      }\n      return markerApply(marker, delegate.createProperty('init', key, parsePropertyMethodFunction({\n        generator: false,\n        typeParameters: typeParameters\n      }), true, false, false));\n    }\n    throwUnexpected(lex());\n  }\n  function parseObjectSpreadProperty() {\n    var marker = markerCreate();\n    expect('...');\n    return markerApply(marker, delegate.createSpreadProperty(parseAssignmentExpression()));\n  }\n  function getFieldName(key) {\n    var toString = String;\n    if (key.type === Syntax.Identifier) {\n      return key.name;\n    }\n    return toString(key.value);\n  }\n  function parseObjectInitialiser() {\n    var properties = [],\n      property,\n      name,\n      kind,\n      storedKind,\n      map = new StringMap(),\n      marker = markerCreate(),\n      toString = String;\n    expect('{');\n    while (!match('}')) {\n      if (match('...')) {\n        property = parseObjectSpreadProperty();\n      } else {\n        property = parseObjectProperty();\n        if (property.key.type === Syntax.Identifier) {\n          name = property.key.name;\n        } else {\n          name = toString(property.key.value);\n        }\n        kind = property.kind === 'init' ? PropertyKind.Data : property.kind === 'get' ? PropertyKind.Get : PropertyKind.Set;\n        if (map.has(name)) {\n          storedKind = map.get(name);\n          if (storedKind === PropertyKind.Data) {\n            if (strict && kind === PropertyKind.Data) {\n              throwErrorTolerant({}, Messages.StrictDuplicateProperty);\n            } else if (kind !== PropertyKind.Data) {\n              throwErrorTolerant({}, Messages.AccessorDataProperty);\n            }\n          } else {\n            if (kind === PropertyKind.Data) {\n              throwErrorTolerant({}, Messages.AccessorDataProperty);\n            } else if (storedKind & kind) {\n              throwErrorTolerant({}, Messages.AccessorGetSet);\n            }\n          }\n          map.set(name, storedKind | kind);\n        } else {\n          map.set(name, kind);\n        }\n      }\n      properties.push(property);\n      if (!match('}')) {\n        expect(',');\n      }\n    }\n    expect('}');\n    return markerApply(marker, delegate.createObjectExpression(properties));\n  }\n  function parseTemplateElement(option) {\n    var marker, token;\n    if (lookahead.type !== Token.Template || option.head && !lookahead.head) {\n      throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n    }\n    marker = markerCreate();\n    token = lex();\n    if (strict && token.octal) {\n      throwError(token, Messages.StrictOctalLiteral);\n    }\n    return markerApply(marker, delegate.createTemplateElement({\n      raw: token.value.raw,\n      cooked: token.value.cooked\n    }, token.tail));\n  }\n  function parseTemplateLiteral() {\n    var quasi,\n      quasis,\n      expressions,\n      marker = markerCreate();\n    quasi = parseTemplateElement({\n      head: true\n    });\n    quasis = [quasi];\n    expressions = [];\n    while (!quasi.tail) {\n      expressions.push(parseExpression());\n      quasi = parseTemplateElement({\n        head: false\n      });\n      quasis.push(quasi);\n    }\n    return markerApply(marker, delegate.createTemplateLiteral(quasis, expressions));\n  }\n\n  // 11.1.6 The Grouping Operator\n\n  function parseGroupExpression() {\n    var expr, marker, typeAnnotation;\n    expect('(');\n    ++state.parenthesizedCount;\n    marker = markerCreate();\n    expr = parseExpression();\n    if (match(':')) {\n      typeAnnotation = parseTypeAnnotation();\n      expr = markerApply(marker, delegate.createTypeCast(expr, typeAnnotation));\n    }\n    expect(')');\n    return expr;\n  }\n  function matchAsyncFuncExprOrDecl() {\n    var token;\n    if (matchAsync()) {\n      token = lookahead2();\n      if (token.type === Token.Keyword && token.value === 'function') {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  // 11.1 Primary Expressions\n\n  function parsePrimaryExpression() {\n    var marker, type, token, expr;\n    type = lookahead.type;\n    if (type === Token.Identifier) {\n      marker = markerCreate();\n      return markerApply(marker, delegate.createIdentifier(lex().value));\n    }\n    if (type === Token.StringLiteral || type === Token.NumericLiteral) {\n      if (strict && lookahead.octal) {\n        throwErrorTolerant(lookahead, Messages.StrictOctalLiteral);\n      }\n      marker = markerCreate();\n      return markerApply(marker, delegate.createLiteral(lex()));\n    }\n    if (type === Token.Keyword) {\n      if (matchKeyword('this')) {\n        marker = markerCreate();\n        lex();\n        return markerApply(marker, delegate.createThisExpression());\n      }\n      if (matchKeyword('function')) {\n        return parseFunctionExpression();\n      }\n      if (matchKeyword('class')) {\n        return parseClassExpression();\n      }\n      if (matchKeyword('super')) {\n        marker = markerCreate();\n        lex();\n        return markerApply(marker, delegate.createIdentifier('super'));\n      }\n    }\n    if (type === Token.BooleanLiteral) {\n      marker = markerCreate();\n      token = lex();\n      token.value = token.value === 'true';\n      return markerApply(marker, delegate.createLiteral(token));\n    }\n    if (type === Token.NullLiteral) {\n      marker = markerCreate();\n      token = lex();\n      token.value = null;\n      return markerApply(marker, delegate.createLiteral(token));\n    }\n    if (match('[')) {\n      return parseArrayInitialiser();\n    }\n    if (match('{')) {\n      return parseObjectInitialiser();\n    }\n    if (match('(')) {\n      return parseGroupExpression();\n    }\n    if (match('/') || match('/=')) {\n      marker = markerCreate();\n      expr = delegate.createLiteral(scanRegExp());\n      peek();\n      return markerApply(marker, expr);\n    }\n    if (type === Token.Template) {\n      return parseTemplateLiteral();\n    }\n    if (match('<')) {\n      return parseJSXElement();\n    }\n    throwUnexpected(lex());\n  }\n\n  // 11.2 Left-Hand-Side Expressions\n\n  function parseArguments() {\n    var args = [],\n      arg;\n    expect('(');\n    if (!match(')')) {\n      while (index < length) {\n        arg = parseSpreadOrAssignmentExpression();\n        args.push(arg);\n        if (arg.type === Syntax.SpreadElement) {\n          if (match(')')) {\n            break;\n          } else {\n            throwError({}, Messages.ElementAfterSpreadElement);\n          }\n        }\n        if (match(')')) {\n          break;\n        } else {\n          expect(',');\n          if (match(')')) {\n            break;\n          }\n        }\n      }\n    }\n    expect(')');\n    return args;\n  }\n  function parseSpreadOrAssignmentExpression() {\n    if (match('...')) {\n      var marker = markerCreate();\n      lex();\n      return markerApply(marker, delegate.createSpreadElement(parseAssignmentExpression()));\n    }\n    return parseAssignmentExpression();\n  }\n  function parseNonComputedProperty() {\n    var marker = markerCreate(),\n      token = lex();\n    if (!isIdentifierName(token)) {\n      throwUnexpected(token);\n    }\n    return markerApply(marker, delegate.createIdentifier(token.value));\n  }\n  function parseNonComputedMember() {\n    expect('.');\n    return parseNonComputedProperty();\n  }\n  function parseComputedMember() {\n    var expr;\n    expect('[');\n    expr = parseExpression();\n    expect(']');\n    return expr;\n  }\n  function parseNewExpression() {\n    var callee,\n      args,\n      marker = markerCreate();\n    expectKeyword('new');\n    callee = parseLeftHandSideExpression();\n    args = match('(') ? parseArguments() : [];\n    return markerApply(marker, delegate.createNewExpression(callee, args));\n  }\n  function parseLeftHandSideExpressionAllowCall() {\n    var expr,\n      args,\n      marker = markerCreate();\n    expr = matchKeyword('new') ? parseNewExpression() : parsePrimaryExpression();\n    while (match('.') || match('[') || match('(') || lookahead.type === Token.Template && lookahead.head) {\n      if (match('(')) {\n        args = parseArguments();\n        expr = markerApply(marker, delegate.createCallExpression(expr, args));\n      } else if (match('[')) {\n        expr = markerApply(marker, delegate.createMemberExpression('[', expr, parseComputedMember()));\n      } else if (match('.')) {\n        expr = markerApply(marker, delegate.createMemberExpression('.', expr, parseNonComputedMember()));\n      } else {\n        expr = markerApply(marker, delegate.createTaggedTemplateExpression(expr, parseTemplateLiteral()));\n      }\n    }\n    return expr;\n  }\n  function parseLeftHandSideExpression() {\n    var expr,\n      marker = markerCreate();\n    expr = matchKeyword('new') ? parseNewExpression() : parsePrimaryExpression();\n    while (match('.') || match('[') || lookahead.type === Token.Template && lookahead.head) {\n      if (match('[')) {\n        expr = markerApply(marker, delegate.createMemberExpression('[', expr, parseComputedMember()));\n      } else if (match('.')) {\n        expr = markerApply(marker, delegate.createMemberExpression('.', expr, parseNonComputedMember()));\n      } else {\n        expr = markerApply(marker, delegate.createTaggedTemplateExpression(expr, parseTemplateLiteral()));\n      }\n    }\n    return expr;\n  }\n\n  // 11.3 Postfix Expressions\n\n  function parsePostfixExpression() {\n    var marker = markerCreate(),\n      expr = parseLeftHandSideExpressionAllowCall(),\n      token;\n    if (lookahead.type !== Token.Punctuator) {\n      return expr;\n    }\n    if ((match('++') || match('--')) && !peekLineTerminator()) {\n      // 11.3.1, 11.3.2\n      if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {\n        throwErrorTolerant({}, Messages.StrictLHSPostfix);\n      }\n      if (!isLeftHandSide(expr)) {\n        throwError({}, Messages.InvalidLHSInAssignment);\n      }\n      token = lex();\n      expr = markerApply(marker, delegate.createPostfixExpression(token.value, expr));\n    }\n    return expr;\n  }\n\n  // 11.4 Unary Operators\n\n  function parseUnaryExpression() {\n    var marker, token, expr;\n    if (lookahead.type !== Token.Punctuator && lookahead.type !== Token.Keyword) {\n      return parsePostfixExpression();\n    }\n    if (match('++') || match('--')) {\n      marker = markerCreate();\n      token = lex();\n      expr = parseUnaryExpression();\n      // 11.4.4, 11.4.5\n      if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {\n        throwErrorTolerant({}, Messages.StrictLHSPrefix);\n      }\n      if (!isLeftHandSide(expr)) {\n        throwError({}, Messages.InvalidLHSInAssignment);\n      }\n      return markerApply(marker, delegate.createUnaryExpression(token.value, expr));\n    }\n    if (match('+') || match('-') || match('~') || match('!')) {\n      marker = markerCreate();\n      token = lex();\n      expr = parseUnaryExpression();\n      return markerApply(marker, delegate.createUnaryExpression(token.value, expr));\n    }\n    if (matchKeyword('delete') || matchKeyword('void') || matchKeyword('typeof')) {\n      marker = markerCreate();\n      token = lex();\n      expr = parseUnaryExpression();\n      expr = markerApply(marker, delegate.createUnaryExpression(token.value, expr));\n      if (strict && expr.operator === 'delete' && expr.argument.type === Syntax.Identifier) {\n        throwErrorTolerant({}, Messages.StrictDelete);\n      }\n      return expr;\n    }\n    return parsePostfixExpression();\n  }\n  function binaryPrecedence(token, allowIn) {\n    var prec = 0;\n    if (token.type !== Token.Punctuator && token.type !== Token.Keyword) {\n      return 0;\n    }\n    switch (token.value) {\n      case '||':\n        prec = 1;\n        break;\n      case '&&':\n        prec = 2;\n        break;\n      case '|':\n        prec = 3;\n        break;\n      case '^':\n        prec = 4;\n        break;\n      case '&':\n        prec = 5;\n        break;\n      case '==':\n      case '!=':\n      case '===':\n      case '!==':\n        prec = 6;\n        break;\n      case '<':\n      case '>':\n      case '<=':\n      case '>=':\n      case 'instanceof':\n        prec = 7;\n        break;\n      case 'in':\n        prec = allowIn ? 7 : 0;\n        break;\n      case '<<':\n      case '>>':\n      case '>>>':\n        prec = 8;\n        break;\n      case '+':\n      case '-':\n        prec = 9;\n        break;\n      case '*':\n      case '/':\n      case '%':\n        prec = 11;\n        break;\n      default:\n        break;\n    }\n    return prec;\n  }\n\n  // 11.5 Multiplicative Operators\n  // 11.6 Additive Operators\n  // 11.7 Bitwise Shift Operators\n  // 11.8 Relational Operators\n  // 11.9 Equality Operators\n  // 11.10 Binary Bitwise Operators\n  // 11.11 Binary Logical Operators\n\n  function parseBinaryExpression() {\n    var expr, token, prec, previousAllowIn, stack, right, operator, left, i, marker, markers;\n    previousAllowIn = state.allowIn;\n    state.allowIn = true;\n    marker = markerCreate();\n    left = parseUnaryExpression();\n    token = lookahead;\n    prec = binaryPrecedence(token, previousAllowIn);\n    if (prec === 0) {\n      return left;\n    }\n    token.prec = prec;\n    lex();\n    markers = [marker, markerCreate()];\n    right = parseUnaryExpression();\n    stack = [left, token, right];\n    while ((prec = binaryPrecedence(lookahead, previousAllowIn)) > 0) {\n      // Reduce: make a binary expression from the three topmost entries.\n      while (stack.length > 2 && prec <= stack[stack.length - 2].prec) {\n        right = stack.pop();\n        operator = stack.pop().value;\n        left = stack.pop();\n        expr = delegate.createBinaryExpression(operator, left, right);\n        markers.pop();\n        marker = markers.pop();\n        markerApply(marker, expr);\n        stack.push(expr);\n        markers.push(marker);\n      }\n\n      // Shift.\n      token = lex();\n      token.prec = prec;\n      stack.push(token);\n      markers.push(markerCreate());\n      expr = parseUnaryExpression();\n      stack.push(expr);\n    }\n    state.allowIn = previousAllowIn;\n\n    // Final reduce to clean-up the stack.\n    i = stack.length - 1;\n    expr = stack[i];\n    markers.pop();\n    while (i > 1) {\n      expr = delegate.createBinaryExpression(stack[i - 1].value, stack[i - 2], expr);\n      i -= 2;\n      marker = markers.pop();\n      markerApply(marker, expr);\n    }\n    return expr;\n  }\n\n  // 11.12 Conditional Operator\n\n  function parseConditionalExpression() {\n    var expr,\n      previousAllowIn,\n      consequent,\n      alternate,\n      marker = markerCreate();\n    expr = parseBinaryExpression();\n    if (match('?')) {\n      lex();\n      previousAllowIn = state.allowIn;\n      state.allowIn = true;\n      consequent = parseAssignmentExpression();\n      state.allowIn = previousAllowIn;\n      expect(':');\n      alternate = parseAssignmentExpression();\n      expr = markerApply(marker, delegate.createConditionalExpression(expr, consequent, alternate));\n    }\n    return expr;\n  }\n\n  // 11.13 Assignment Operators\n\n  // 12.14.5 AssignmentPattern\n\n  function reinterpretAsAssignmentBindingPattern(expr) {\n    var i, len, property, element;\n    if (expr.type === Syntax.ObjectExpression) {\n      expr.type = Syntax.ObjectPattern;\n      for (i = 0, len = expr.properties.length; i < len; i += 1) {\n        property = expr.properties[i];\n        if (property.type === Syntax.SpreadProperty) {\n          if (i < len - 1) {\n            throwError({}, Messages.PropertyAfterSpreadProperty);\n          }\n          reinterpretAsAssignmentBindingPattern(property.argument);\n        } else {\n          if (property.kind !== 'init') {\n            throwError({}, Messages.InvalidLHSInAssignment);\n          }\n          reinterpretAsAssignmentBindingPattern(property.value);\n        }\n      }\n    } else if (expr.type === Syntax.ArrayExpression) {\n      expr.type = Syntax.ArrayPattern;\n      for (i = 0, len = expr.elements.length; i < len; i += 1) {\n        element = expr.elements[i];\n        /* istanbul ignore else */\n        if (element) {\n          reinterpretAsAssignmentBindingPattern(element);\n        }\n      }\n    } else if (expr.type === Syntax.Identifier) {\n      if (isRestrictedWord(expr.name)) {\n        throwError({}, Messages.InvalidLHSInAssignment);\n      }\n    } else if (expr.type === Syntax.SpreadElement) {\n      reinterpretAsAssignmentBindingPattern(expr.argument);\n      if (expr.argument.type === Syntax.ObjectPattern) {\n        throwError({}, Messages.ObjectPatternAsSpread);\n      }\n    } else {\n      /* istanbul ignore else */\n      if (expr.type !== Syntax.MemberExpression && expr.type !== Syntax.CallExpression && expr.type !== Syntax.NewExpression) {\n        throwError({}, Messages.InvalidLHSInAssignment);\n      }\n    }\n  }\n\n  // 13.2.3 BindingPattern\n\n  function reinterpretAsDestructuredParameter(options, expr) {\n    var i, len, property, element;\n    if (expr.type === Syntax.ObjectExpression) {\n      expr.type = Syntax.ObjectPattern;\n      for (i = 0, len = expr.properties.length; i < len; i += 1) {\n        property = expr.properties[i];\n        if (property.type === Syntax.SpreadProperty) {\n          if (i < len - 1) {\n            throwError({}, Messages.PropertyAfterSpreadProperty);\n          }\n          reinterpretAsDestructuredParameter(options, property.argument);\n        } else {\n          if (property.kind !== 'init') {\n            throwError({}, Messages.InvalidLHSInFormalsList);\n          }\n          reinterpretAsDestructuredParameter(options, property.value);\n        }\n      }\n    } else if (expr.type === Syntax.ArrayExpression) {\n      expr.type = Syntax.ArrayPattern;\n      for (i = 0, len = expr.elements.length; i < len; i += 1) {\n        element = expr.elements[i];\n        if (element) {\n          reinterpretAsDestructuredParameter(options, element);\n        }\n      }\n    } else if (expr.type === Syntax.Identifier) {\n      validateParam(options, expr, expr.name);\n    } else if (expr.type === Syntax.SpreadElement) {\n      // BindingRestElement only allows BindingIdentifier\n      if (expr.argument.type !== Syntax.Identifier) {\n        throwError({}, Messages.InvalidLHSInFormalsList);\n      }\n      validateParam(options, expr.argument, expr.argument.name);\n    } else {\n      throwError({}, Messages.InvalidLHSInFormalsList);\n    }\n  }\n  function reinterpretAsCoverFormalsList(expressions) {\n    var i, len, param, params, defaults, defaultCount, options, rest;\n    params = [];\n    defaults = [];\n    defaultCount = 0;\n    rest = null;\n    options = {\n      paramSet: new StringMap()\n    };\n    for (i = 0, len = expressions.length; i < len; i += 1) {\n      param = expressions[i];\n      if (param.type === Syntax.Identifier) {\n        params.push(param);\n        defaults.push(null);\n        validateParam(options, param, param.name);\n      } else if (param.type === Syntax.ObjectExpression || param.type === Syntax.ArrayExpression) {\n        reinterpretAsDestructuredParameter(options, param);\n        params.push(param);\n        defaults.push(null);\n      } else if (param.type === Syntax.SpreadElement) {\n        assert(i === len - 1, 'It is guaranteed that SpreadElement is last element by parseExpression');\n        if (param.argument.type !== Syntax.Identifier) {\n          throwError({}, Messages.InvalidLHSInFormalsList);\n        }\n        reinterpretAsDestructuredParameter(options, param.argument);\n        rest = param.argument;\n      } else if (param.type === Syntax.AssignmentExpression) {\n        params.push(param.left);\n        defaults.push(param.right);\n        ++defaultCount;\n        validateParam(options, param.left, param.left.name);\n      } else {\n        return null;\n      }\n    }\n    if (options.message === Messages.StrictParamDupe) {\n      throwError(strict ? options.stricted : options.firstRestricted, options.message);\n    }\n    if (defaultCount === 0) {\n      defaults = [];\n    }\n    return {\n      params: params,\n      defaults: defaults,\n      rest: rest,\n      stricted: options.stricted,\n      firstRestricted: options.firstRestricted,\n      message: options.message\n    };\n  }\n  function parseArrowFunctionExpression(options, marker) {\n    var previousStrict, previousYieldAllowed, previousAwaitAllowed, body;\n    expect('=>');\n    previousStrict = strict;\n    previousYieldAllowed = state.yieldAllowed;\n    state.yieldAllowed = false;\n    previousAwaitAllowed = state.awaitAllowed;\n    state.awaitAllowed = !!options.async;\n    body = parseConciseBody();\n    if (strict && options.firstRestricted) {\n      throwError(options.firstRestricted, options.message);\n    }\n    if (strict && options.stricted) {\n      throwErrorTolerant(options.stricted, options.message);\n    }\n    strict = previousStrict;\n    state.yieldAllowed = previousYieldAllowed;\n    state.awaitAllowed = previousAwaitAllowed;\n    return markerApply(marker, delegate.createArrowFunctionExpression(options.params, options.defaults, body, options.rest, body.type !== Syntax.BlockStatement, !!options.async));\n  }\n  function parseAssignmentExpression() {\n    var marker,\n      expr,\n      token,\n      params,\n      oldParenthesizedCount,\n      startsWithParen = false,\n      backtrackToken = lookahead,\n      possiblyAsync = false;\n    if (matchYield()) {\n      return parseYieldExpression();\n    }\n    if (matchAwait()) {\n      return parseAwaitExpression();\n    }\n    oldParenthesizedCount = state.parenthesizedCount;\n    marker = markerCreate();\n    if (matchAsyncFuncExprOrDecl()) {\n      return parseFunctionExpression();\n    }\n    if (matchAsync()) {\n      // We can't be completely sure that this 'async' token is\n      // actually a contextual keyword modifying a function\n      // expression, so we might have to un-lex() it later by\n      // calling rewind(backtrackToken).\n      possiblyAsync = true;\n      lex();\n    }\n    if (match('(')) {\n      token = lookahead2();\n      if (token.type === Token.Punctuator && token.value === ')' || token.value === '...') {\n        params = parseParams();\n        if (!match('=>')) {\n          throwUnexpected(lex());\n        }\n        params.async = possiblyAsync;\n        return parseArrowFunctionExpression(params, marker);\n      }\n      startsWithParen = true;\n    }\n    token = lookahead;\n\n    // If the 'async' keyword is not followed by a '(' character or an\n    // identifier, then it can't be an arrow function modifier, and we\n    // should interpret it as a normal identifer.\n    if (possiblyAsync && !match('(') && token.type !== Token.Identifier) {\n      possiblyAsync = false;\n      rewind(backtrackToken);\n    }\n    expr = parseConditionalExpression();\n    if (match('=>') && (state.parenthesizedCount === oldParenthesizedCount || state.parenthesizedCount === oldParenthesizedCount + 1)) {\n      if (expr.type === Syntax.Identifier) {\n        params = reinterpretAsCoverFormalsList([expr]);\n      } else if (expr.type === Syntax.AssignmentExpression || expr.type === Syntax.ArrayExpression || expr.type === Syntax.ObjectExpression) {\n        if (!startsWithParen) {\n          throwUnexpected(lex());\n        }\n        params = reinterpretAsCoverFormalsList([expr]);\n      } else if (expr.type === Syntax.SequenceExpression) {\n        params = reinterpretAsCoverFormalsList(expr.expressions);\n      }\n      if (params) {\n        params.async = possiblyAsync;\n        return parseArrowFunctionExpression(params, marker);\n      }\n    }\n\n    // If we haven't returned by now, then the 'async' keyword was not\n    // a function modifier, and we should rewind and interpret it as a\n    // normal identifier.\n    if (possiblyAsync) {\n      possiblyAsync = false;\n      rewind(backtrackToken);\n      expr = parseConditionalExpression();\n    }\n    if (matchAssign()) {\n      // 11.13.1\n      if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {\n        throwErrorTolerant(token, Messages.StrictLHSAssignment);\n      }\n\n      // ES.next draf 11.13 Runtime Semantics step 1\n      if (match('=') && (expr.type === Syntax.ObjectExpression || expr.type === Syntax.ArrayExpression)) {\n        reinterpretAsAssignmentBindingPattern(expr);\n      } else if (!isLeftHandSide(expr)) {\n        throwError({}, Messages.InvalidLHSInAssignment);\n      }\n      expr = markerApply(marker, delegate.createAssignmentExpression(lex().value, expr, parseAssignmentExpression()));\n    }\n    return expr;\n  }\n\n  // 11.14 Comma Operator\n\n  function parseExpression() {\n    var marker, expr, expressions, sequence, spreadFound, possibleArrow;\n    marker = markerCreate();\n    expr = parseAssignmentExpression();\n    expressions = [expr];\n    if (match(',')) {\n      while (index < length) {\n        if (!match(',')) {\n          break;\n        }\n        lex();\n        if (match(')')) {\n          possibleArrow = lookahead2();\n          if (possibleArrow.type === Token.Punctuator && possibleArrow.value === '=>') {\n            break;\n          }\n        }\n        expr = parseSpreadOrAssignmentExpression();\n        expressions.push(expr);\n        if (expr.type === Syntax.SpreadElement) {\n          spreadFound = true;\n          if (!match(')')) {\n            throwError({}, Messages.ElementAfterSpreadElement);\n          }\n          break;\n        }\n      }\n      if (expressions.length > 1) {\n        sequence = markerApply(marker, delegate.createSequenceExpression(expressions));\n      }\n    }\n    if (spreadFound && lookahead2().value !== '=>') {\n      throwError({}, Messages.IllegalSpread);\n    }\n    return sequence || expr;\n  }\n\n  // 12.1 Block\n\n  function parseStatementList() {\n    var list = [],\n      statement;\n    while (index < length) {\n      if (match('}')) {\n        break;\n      }\n      statement = parseSourceElement();\n      if (typeof statement === 'undefined') {\n        break;\n      }\n      list.push(statement);\n    }\n    return list;\n  }\n  function parseBlock() {\n    var block,\n      marker = markerCreate();\n    expect('{');\n    block = parseStatementList();\n    expect('}');\n    return markerApply(marker, delegate.createBlockStatement(block));\n  }\n\n  // 12.2 Variable Statement\n\n  function parseTypeParameterDeclaration() {\n    var marker = markerCreate(),\n      paramTypes = [];\n    expect('<');\n    while (!match('>')) {\n      paramTypes.push(parseTypeAnnotatableIdentifier());\n      if (!match('>')) {\n        expect(',');\n      }\n    }\n    expect('>');\n    return markerApply(marker, delegate.createTypeParameterDeclaration(paramTypes));\n  }\n  function parseTypeParameterInstantiation() {\n    var marker = markerCreate(),\n      oldInType = state.inType,\n      paramTypes = [];\n    state.inType = true;\n    expect('<');\n    while (!match('>')) {\n      paramTypes.push(parseType());\n      if (!match('>')) {\n        expect(',');\n      }\n    }\n    expect('>');\n    state.inType = oldInType;\n    return markerApply(marker, delegate.createTypeParameterInstantiation(paramTypes));\n  }\n  function parseObjectTypeIndexer(marker, isStatic) {\n    var id, key, value;\n    expect('[');\n    id = parseObjectPropertyKey();\n    expect(':');\n    key = parseType();\n    expect(']');\n    expect(':');\n    value = parseType();\n    return markerApply(marker, delegate.createObjectTypeIndexer(id, key, value, isStatic));\n  }\n  function parseObjectTypeMethodish(marker) {\n    var params = [],\n      rest = null,\n      returnType,\n      typeParameters = null;\n    if (match('<')) {\n      typeParameters = parseTypeParameterDeclaration();\n    }\n    expect('(');\n    while (lookahead.type === Token.Identifier) {\n      params.push(parseFunctionTypeParam());\n      if (!match(')')) {\n        expect(',');\n      }\n    }\n    if (match('...')) {\n      lex();\n      rest = parseFunctionTypeParam();\n    }\n    expect(')');\n    expect(':');\n    returnType = parseType();\n    return markerApply(marker, delegate.createFunctionTypeAnnotation(params, returnType, rest, typeParameters));\n  }\n  function parseObjectTypeMethod(marker, isStatic, key) {\n    var optional = false,\n      value;\n    value = parseObjectTypeMethodish(marker);\n    return markerApply(marker, delegate.createObjectTypeProperty(key, value, optional, isStatic));\n  }\n  function parseObjectTypeCallProperty(marker, isStatic) {\n    var valueMarker = markerCreate();\n    return markerApply(marker, delegate.createObjectTypeCallProperty(parseObjectTypeMethodish(valueMarker), isStatic));\n  }\n  function parseObjectType(allowStatic) {\n    var callProperties = [],\n      indexers = [],\n      marker,\n      optional = false,\n      properties = [],\n      propertyKey,\n      propertyTypeAnnotation,\n      token,\n      isStatic,\n      matchStatic;\n    expect('{');\n    while (!match('}')) {\n      marker = markerCreate();\n      matchStatic = strict ? matchKeyword('static') : matchContextualKeyword('static');\n      if (allowStatic && matchStatic) {\n        token = lex();\n        isStatic = true;\n      }\n      if (match('[')) {\n        indexers.push(parseObjectTypeIndexer(marker, isStatic));\n      } else if (match('(') || match('<')) {\n        callProperties.push(parseObjectTypeCallProperty(marker, allowStatic));\n      } else {\n        if (isStatic && match(':')) {\n          propertyKey = markerApply(marker, delegate.createIdentifier(token));\n          throwErrorTolerant(token, Messages.StrictReservedWord);\n        } else {\n          propertyKey = parseObjectPropertyKey();\n        }\n        if (match('<') || match('(')) {\n          // This is a method property\n          properties.push(parseObjectTypeMethod(marker, isStatic, propertyKey));\n        } else {\n          if (match('?')) {\n            lex();\n            optional = true;\n          }\n          expect(':');\n          propertyTypeAnnotation = parseType();\n          properties.push(markerApply(marker, delegate.createObjectTypeProperty(propertyKey, propertyTypeAnnotation, optional, isStatic)));\n        }\n      }\n      if (match(';') || match(',')) {\n        lex();\n      } else if (!match('}')) {\n        throwUnexpected(lookahead);\n      }\n    }\n    expect('}');\n    return delegate.createObjectTypeAnnotation(properties, indexers, callProperties);\n  }\n  function parseGenericType() {\n    var marker = markerCreate(),\n      typeParameters = null,\n      typeIdentifier;\n    typeIdentifier = parseVariableIdentifier();\n    while (match('.')) {\n      expect('.');\n      typeIdentifier = markerApply(marker, delegate.createQualifiedTypeIdentifier(typeIdentifier, parseVariableIdentifier()));\n    }\n    if (match('<')) {\n      typeParameters = parseTypeParameterInstantiation();\n    }\n    return markerApply(marker, delegate.createGenericTypeAnnotation(typeIdentifier, typeParameters));\n  }\n  function parseVoidType() {\n    var marker = markerCreate();\n    expectKeyword('void');\n    return markerApply(marker, delegate.createVoidTypeAnnotation());\n  }\n  function parseTypeofType() {\n    var argument,\n      marker = markerCreate();\n    expectKeyword('typeof');\n    argument = parsePrimaryType();\n    return markerApply(marker, delegate.createTypeofTypeAnnotation(argument));\n  }\n  function parseTupleType() {\n    var marker = markerCreate(),\n      types = [];\n    expect('[');\n    // We allow trailing commas\n    while (index < length && !match(']')) {\n      types.push(parseType());\n      if (match(']')) {\n        break;\n      }\n      expect(',');\n    }\n    expect(']');\n    return markerApply(marker, delegate.createTupleTypeAnnotation(types));\n  }\n  function parseFunctionTypeParam() {\n    var marker = markerCreate(),\n      name,\n      optional = false,\n      typeAnnotation;\n    name = parseVariableIdentifier();\n    if (match('?')) {\n      lex();\n      optional = true;\n    }\n    expect(':');\n    typeAnnotation = parseType();\n    return markerApply(marker, delegate.createFunctionTypeParam(name, typeAnnotation, optional));\n  }\n  function parseFunctionTypeParams() {\n    var ret = {\n      params: [],\n      rest: null\n    };\n    while (lookahead.type === Token.Identifier) {\n      ret.params.push(parseFunctionTypeParam());\n      if (!match(')')) {\n        expect(',');\n      }\n    }\n    if (match('...')) {\n      lex();\n      ret.rest = parseFunctionTypeParam();\n    }\n    return ret;\n  }\n\n  // The parsing of types roughly parallels the parsing of expressions, and\n  // primary types are kind of like primary expressions...they're the\n  // primitives with which other types are constructed.\n  function parsePrimaryType() {\n    var params = null,\n      returnType = null,\n      marker = markerCreate(),\n      rest = null,\n      tmp,\n      typeParameters,\n      token,\n      type,\n      isGroupedType = false;\n    switch (lookahead.type) {\n      case Token.Identifier:\n        switch (lookahead.value) {\n          case 'any':\n            lex();\n            return markerApply(marker, delegate.createAnyTypeAnnotation());\n          case 'bool': // fallthrough\n          case 'boolean':\n            lex();\n            return markerApply(marker, delegate.createBooleanTypeAnnotation());\n          case 'number':\n            lex();\n            return markerApply(marker, delegate.createNumberTypeAnnotation());\n          case 'string':\n            lex();\n            return markerApply(marker, delegate.createStringTypeAnnotation());\n        }\n        return markerApply(marker, parseGenericType());\n      case Token.Punctuator:\n        switch (lookahead.value) {\n          case '{':\n            return markerApply(marker, parseObjectType());\n          case '[':\n            return parseTupleType();\n          case '<':\n            typeParameters = parseTypeParameterDeclaration();\n            expect('(');\n            tmp = parseFunctionTypeParams();\n            params = tmp.params;\n            rest = tmp.rest;\n            expect(')');\n            expect('=>');\n            returnType = parseType();\n            return markerApply(marker, delegate.createFunctionTypeAnnotation(params, returnType, rest, typeParameters));\n          case '(':\n            lex();\n            // Check to see if this is actually a grouped type\n            if (!match(')') && !match('...')) {\n              if (lookahead.type === Token.Identifier) {\n                token = lookahead2();\n                isGroupedType = token.value !== '?' && token.value !== ':';\n              } else {\n                isGroupedType = true;\n              }\n            }\n            if (isGroupedType) {\n              type = parseType();\n              expect(')');\n\n              // If we see a => next then someone was probably confused about\n              // function types, so we can provide a better error message\n              if (match('=>')) {\n                throwError({}, Messages.ConfusedAboutFunctionType);\n              }\n              return type;\n            }\n            tmp = parseFunctionTypeParams();\n            params = tmp.params;\n            rest = tmp.rest;\n            expect(')');\n            expect('=>');\n            returnType = parseType();\n            return markerApply(marker, delegate.createFunctionTypeAnnotation(params, returnType, rest, null /* typeParameters */));\n        }\n\n        break;\n      case Token.Keyword:\n        switch (lookahead.value) {\n          case 'void':\n            return markerApply(marker, parseVoidType());\n          case 'typeof':\n            return markerApply(marker, parseTypeofType());\n        }\n        break;\n      case Token.StringLiteral:\n        token = lex();\n        if (token.octal) {\n          throwError(token, Messages.StrictOctalLiteral);\n        }\n        return markerApply(marker, delegate.createStringLiteralTypeAnnotation(token));\n    }\n    throwUnexpected(lookahead);\n  }\n  function parsePostfixType() {\n    var marker = markerCreate(),\n      t = parsePrimaryType();\n    if (match('[')) {\n      expect('[');\n      expect(']');\n      return markerApply(marker, delegate.createArrayTypeAnnotation(t));\n    }\n    return t;\n  }\n  function parsePrefixType() {\n    var marker = markerCreate();\n    if (match('?')) {\n      lex();\n      return markerApply(marker, delegate.createNullableTypeAnnotation(parsePrefixType()));\n    }\n    return parsePostfixType();\n  }\n  function parseIntersectionType() {\n    var marker = markerCreate(),\n      type,\n      types;\n    type = parsePrefixType();\n    types = [type];\n    while (match('&')) {\n      lex();\n      types.push(parsePrefixType());\n    }\n    return types.length === 1 ? type : markerApply(marker, delegate.createIntersectionTypeAnnotation(types));\n  }\n  function parseUnionType() {\n    var marker = markerCreate(),\n      type,\n      types;\n    type = parseIntersectionType();\n    types = [type];\n    while (match('|')) {\n      lex();\n      types.push(parseIntersectionType());\n    }\n    return types.length === 1 ? type : markerApply(marker, delegate.createUnionTypeAnnotation(types));\n  }\n  function parseType() {\n    var oldInType = state.inType,\n      type;\n    state.inType = true;\n    type = parseUnionType();\n    state.inType = oldInType;\n    return type;\n  }\n  function parseTypeAnnotation() {\n    var marker = markerCreate(),\n      type;\n    expect(':');\n    type = parseType();\n    return markerApply(marker, delegate.createTypeAnnotation(type));\n  }\n  function parseVariableIdentifier() {\n    var marker = markerCreate(),\n      token = lex();\n    if (token.type !== Token.Identifier) {\n      throwUnexpected(token);\n    }\n    return markerApply(marker, delegate.createIdentifier(token.value));\n  }\n  function parseTypeAnnotatableIdentifier(requireTypeAnnotation, canBeOptionalParam) {\n    var marker = markerCreate(),\n      ident = parseVariableIdentifier(),\n      isOptionalParam = false;\n    if (canBeOptionalParam && match('?')) {\n      expect('?');\n      isOptionalParam = true;\n    }\n    if (requireTypeAnnotation || match(':')) {\n      ident.typeAnnotation = parseTypeAnnotation();\n      ident = markerApply(marker, ident);\n    }\n    if (isOptionalParam) {\n      ident.optional = true;\n      ident = markerApply(marker, ident);\n    }\n    return ident;\n  }\n  function parseVariableDeclaration(kind) {\n    var id,\n      marker = markerCreate(),\n      init = null,\n      typeAnnotationMarker = markerCreate();\n    if (match('{')) {\n      id = parseObjectInitialiser();\n      reinterpretAsAssignmentBindingPattern(id);\n      if (match(':')) {\n        id.typeAnnotation = parseTypeAnnotation();\n        markerApply(typeAnnotationMarker, id);\n      }\n    } else if (match('[')) {\n      id = parseArrayInitialiser();\n      reinterpretAsAssignmentBindingPattern(id);\n      if (match(':')) {\n        id.typeAnnotation = parseTypeAnnotation();\n        markerApply(typeAnnotationMarker, id);\n      }\n    } else {\n      /* istanbul ignore next */\n      id = state.allowKeyword ? parseNonComputedProperty() : parseTypeAnnotatableIdentifier();\n      // 12.2.1\n      if (strict && isRestrictedWord(id.name)) {\n        throwErrorTolerant({}, Messages.StrictVarName);\n      }\n    }\n    if (kind === 'const') {\n      if (!match('=')) {\n        throwError({}, Messages.NoUninitializedConst);\n      }\n      expect('=');\n      init = parseAssignmentExpression();\n    } else if (match('=')) {\n      lex();\n      init = parseAssignmentExpression();\n    }\n    return markerApply(marker, delegate.createVariableDeclarator(id, init));\n  }\n  function parseVariableDeclarationList(kind) {\n    var list = [];\n    do {\n      list.push(parseVariableDeclaration(kind));\n      if (!match(',')) {\n        break;\n      }\n      lex();\n    } while (index < length);\n    return list;\n  }\n  function parseVariableStatement() {\n    var declarations,\n      marker = markerCreate();\n    expectKeyword('var');\n    declarations = parseVariableDeclarationList();\n    consumeSemicolon();\n    return markerApply(marker, delegate.createVariableDeclaration(declarations, 'var'));\n  }\n\n  // kind may be `const` or `let`\n  // Both are experimental and not in the specification yet.\n  // see http://wiki.ecmascript.org/doku.php?id=harmony:const\n  // and http://wiki.ecmascript.org/doku.php?id=harmony:let\n  function parseConstLetDeclaration(kind) {\n    var declarations,\n      marker = markerCreate();\n    expectKeyword(kind);\n    declarations = parseVariableDeclarationList(kind);\n    consumeSemicolon();\n    return markerApply(marker, delegate.createVariableDeclaration(declarations, kind));\n  }\n\n  // people.mozilla.org/~jorendorff/es6-draft.html\n\n  function parseModuleSpecifier() {\n    var marker = markerCreate(),\n      specifier;\n    if (lookahead.type !== Token.StringLiteral) {\n      throwError({}, Messages.InvalidModuleSpecifier);\n    }\n    specifier = delegate.createLiteral(lex());\n    return markerApply(marker, specifier);\n  }\n  function parseExportBatchSpecifier() {\n    var marker = markerCreate();\n    expect('*');\n    return markerApply(marker, delegate.createExportBatchSpecifier());\n  }\n  function parseExportSpecifier() {\n    var id,\n      name = null,\n      marker = markerCreate();\n    if (matchKeyword('default')) {\n      lex();\n      id = markerApply(marker, delegate.createIdentifier('default'));\n      // export {default} from \"something\";\n    } else {\n      id = parseVariableIdentifier();\n    }\n    if (matchContextualKeyword('as')) {\n      lex();\n      name = parseNonComputedProperty();\n    }\n    return markerApply(marker, delegate.createExportSpecifier(id, name));\n  }\n  function parseExportDeclaration() {\n    var declaration = null,\n      possibleIdentifierToken,\n      sourceElement,\n      isExportFromIdentifier,\n      src = null,\n      specifiers = [],\n      marker = markerCreate();\n    expectKeyword('export');\n    if (matchKeyword('default')) {\n      // covers:\n      // export default ...\n      lex();\n      if (matchKeyword('function') || matchKeyword('class')) {\n        possibleIdentifierToken = lookahead2();\n        if (isIdentifierName(possibleIdentifierToken)) {\n          // covers:\n          // export default function foo () {}\n          // export default class foo {}\n          sourceElement = parseSourceElement();\n          return markerApply(marker, delegate.createExportDeclaration(true, sourceElement, [sourceElement.id], null));\n        }\n        // covers:\n        // export default function () {}\n        // export default class {}\n        switch (lookahead.value) {\n          case 'class':\n            return markerApply(marker, delegate.createExportDeclaration(true, parseClassExpression(), [], null));\n          case 'function':\n            return markerApply(marker, delegate.createExportDeclaration(true, parseFunctionExpression(), [], null));\n        }\n      }\n      if (matchContextualKeyword('from')) {\n        throwError({}, Messages.UnexpectedToken, lookahead.value);\n      }\n\n      // covers:\n      // export default {};\n      // export default [];\n      if (match('{')) {\n        declaration = parseObjectInitialiser();\n      } else if (match('[')) {\n        declaration = parseArrayInitialiser();\n      } else {\n        declaration = parseAssignmentExpression();\n      }\n      consumeSemicolon();\n      return markerApply(marker, delegate.createExportDeclaration(true, declaration, [], null));\n    }\n\n    // non-default export\n    if (lookahead.type === Token.Keyword || matchContextualKeyword('type')) {\n      // covers:\n      // export var f = 1;\n      switch (lookahead.value) {\n        case 'type':\n        case 'let':\n        case 'const':\n        case 'var':\n        case 'class':\n        case 'function':\n          return markerApply(marker, delegate.createExportDeclaration(false, parseSourceElement(), specifiers, null));\n      }\n    }\n    if (match('*')) {\n      // covers:\n      // export * from \"foo\";\n      specifiers.push(parseExportBatchSpecifier());\n      if (!matchContextualKeyword('from')) {\n        throwError({}, lookahead.value ? Messages.UnexpectedToken : Messages.MissingFromClause, lookahead.value);\n      }\n      lex();\n      src = parseModuleSpecifier();\n      consumeSemicolon();\n      return markerApply(marker, delegate.createExportDeclaration(false, null, specifiers, src));\n    }\n    expect('{');\n    if (!match('}')) {\n      do {\n        isExportFromIdentifier = isExportFromIdentifier || matchKeyword('default');\n        specifiers.push(parseExportSpecifier());\n      } while (match(',') && lex());\n    }\n    expect('}');\n    if (matchContextualKeyword('from')) {\n      // covering:\n      // export {default} from \"foo\";\n      // export {foo} from \"foo\";\n      lex();\n      src = parseModuleSpecifier();\n      consumeSemicolon();\n    } else if (isExportFromIdentifier) {\n      // covering:\n      // export {default}; // missing fromClause\n      throwError({}, lookahead.value ? Messages.UnexpectedToken : Messages.MissingFromClause, lookahead.value);\n    } else {\n      // cover\n      // export {foo};\n      consumeSemicolon();\n    }\n    return markerApply(marker, delegate.createExportDeclaration(false, declaration, specifiers, src));\n  }\n  function parseImportSpecifier() {\n    // import {<foo as bar>} ...;\n    var id,\n      name = null,\n      marker = markerCreate();\n    id = parseNonComputedProperty();\n    if (matchContextualKeyword('as')) {\n      lex();\n      name = parseVariableIdentifier();\n    }\n    return markerApply(marker, delegate.createImportSpecifier(id, name));\n  }\n  function parseNamedImports() {\n    var specifiers = [];\n    // {foo, bar as bas}\n    expect('{');\n    if (!match('}')) {\n      do {\n        specifiers.push(parseImportSpecifier());\n      } while (match(',') && lex());\n    }\n    expect('}');\n    return specifiers;\n  }\n  function parseImportDefaultSpecifier() {\n    // import <foo> ...;\n    var id,\n      marker = markerCreate();\n    id = parseNonComputedProperty();\n    return markerApply(marker, delegate.createImportDefaultSpecifier(id));\n  }\n  function parseImportNamespaceSpecifier() {\n    // import <* as foo> ...;\n    var id,\n      marker = markerCreate();\n    expect('*');\n    if (!matchContextualKeyword('as')) {\n      throwError({}, Messages.NoAsAfterImportNamespace);\n    }\n    lex();\n    id = parseNonComputedProperty();\n    return markerApply(marker, delegate.createImportNamespaceSpecifier(id));\n  }\n  function parseImportDeclaration() {\n    var specifiers,\n      src,\n      marker = markerCreate(),\n      importKind = 'value',\n      token2;\n    expectKeyword('import');\n    if (matchContextualKeyword('type')) {\n      token2 = lookahead2();\n      if (token2.type === Token.Identifier && token2.value !== 'from' || token2.type === Token.Punctuator && (token2.value === '{' || token2.value === '*')) {\n        importKind = 'type';\n        lex();\n      }\n    } else if (matchKeyword('typeof')) {\n      importKind = 'typeof';\n      lex();\n    }\n    specifiers = [];\n    if (lookahead.type === Token.StringLiteral) {\n      // covers:\n      // import \"foo\";\n      src = parseModuleSpecifier();\n      consumeSemicolon();\n      return markerApply(marker, delegate.createImportDeclaration(specifiers, src, importKind));\n    }\n    if (!matchKeyword('default') && isIdentifierName(lookahead)) {\n      // covers:\n      // import foo\n      // import foo, ...\n      specifiers.push(parseImportDefaultSpecifier());\n      if (match(',')) {\n        lex();\n      }\n    }\n    if (match('*')) {\n      // covers:\n      // import foo, * as foo\n      // import * as foo\n      specifiers.push(parseImportNamespaceSpecifier());\n    } else if (match('{')) {\n      // covers:\n      // import foo, {bar}\n      // import {bar}\n      specifiers = specifiers.concat(parseNamedImports());\n    }\n    if (!matchContextualKeyword('from')) {\n      throwError({}, lookahead.value ? Messages.UnexpectedToken : Messages.MissingFromClause, lookahead.value);\n    }\n    lex();\n    src = parseModuleSpecifier();\n    consumeSemicolon();\n    return markerApply(marker, delegate.createImportDeclaration(specifiers, src, importKind));\n  }\n\n  // 12.3 Empty Statement\n\n  function parseEmptyStatement() {\n    var marker = markerCreate();\n    expect(';');\n    return markerApply(marker, delegate.createEmptyStatement());\n  }\n\n  // 12.4 Expression Statement\n\n  function parseExpressionStatement() {\n    var marker = markerCreate(),\n      expr = parseExpression();\n    consumeSemicolon();\n    return markerApply(marker, delegate.createExpressionStatement(expr));\n  }\n\n  // 12.5 If statement\n\n  function parseIfStatement() {\n    var test,\n      consequent,\n      alternate,\n      marker = markerCreate();\n    expectKeyword('if');\n    expect('(');\n    test = parseExpression();\n    expect(')');\n    consequent = parseStatement();\n    if (matchKeyword('else')) {\n      lex();\n      alternate = parseStatement();\n    } else {\n      alternate = null;\n    }\n    return markerApply(marker, delegate.createIfStatement(test, consequent, alternate));\n  }\n\n  // 12.6 Iteration Statements\n\n  function parseDoWhileStatement() {\n    var body,\n      test,\n      oldInIteration,\n      marker = markerCreate();\n    expectKeyword('do');\n    oldInIteration = state.inIteration;\n    state.inIteration = true;\n    body = parseStatement();\n    state.inIteration = oldInIteration;\n    expectKeyword('while');\n    expect('(');\n    test = parseExpression();\n    expect(')');\n    if (match(';')) {\n      lex();\n    }\n    return markerApply(marker, delegate.createDoWhileStatement(body, test));\n  }\n  function parseWhileStatement() {\n    var test,\n      body,\n      oldInIteration,\n      marker = markerCreate();\n    expectKeyword('while');\n    expect('(');\n    test = parseExpression();\n    expect(')');\n    oldInIteration = state.inIteration;\n    state.inIteration = true;\n    body = parseStatement();\n    state.inIteration = oldInIteration;\n    return markerApply(marker, delegate.createWhileStatement(test, body));\n  }\n  function parseForVariableDeclaration() {\n    var marker = markerCreate(),\n      token = lex(),\n      declarations = parseVariableDeclarationList();\n    return markerApply(marker, delegate.createVariableDeclaration(declarations, token.value));\n  }\n  function parseForStatement(opts) {\n    var init,\n      test,\n      update,\n      left,\n      right,\n      body,\n      operator,\n      oldInIteration,\n      marker = markerCreate();\n    init = test = update = null;\n    expectKeyword('for');\n\n    // http://wiki.ecmascript.org/doku.php?id=proposals:iterators_and_generators&s=each\n    if (matchContextualKeyword('each')) {\n      throwError({}, Messages.EachNotAllowed);\n    }\n    expect('(');\n    if (match(';')) {\n      lex();\n    } else {\n      if (matchKeyword('var') || matchKeyword('let') || matchKeyword('const')) {\n        state.allowIn = false;\n        init = parseForVariableDeclaration();\n        state.allowIn = true;\n        if (init.declarations.length === 1) {\n          if (matchKeyword('in') || matchContextualKeyword('of')) {\n            operator = lookahead;\n            if (!((operator.value === 'in' || init.kind !== 'var') && init.declarations[0].init)) {\n              lex();\n              left = init;\n              right = parseExpression();\n              init = null;\n            }\n          }\n        }\n      } else {\n        state.allowIn = false;\n        init = parseExpression();\n        state.allowIn = true;\n        if (matchContextualKeyword('of')) {\n          operator = lex();\n          left = init;\n          right = parseExpression();\n          init = null;\n        } else if (matchKeyword('in')) {\n          // LeftHandSideExpression\n          if (!isAssignableLeftHandSide(init)) {\n            throwError({}, Messages.InvalidLHSInForIn);\n          }\n          operator = lex();\n          left = init;\n          right = parseExpression();\n          init = null;\n        }\n      }\n      if (typeof left === 'undefined') {\n        expect(';');\n      }\n    }\n    if (typeof left === 'undefined') {\n      if (!match(';')) {\n        test = parseExpression();\n      }\n      expect(';');\n      if (!match(')')) {\n        update = parseExpression();\n      }\n    }\n    expect(')');\n    oldInIteration = state.inIteration;\n    state.inIteration = true;\n    if (!(opts !== undefined && opts.ignoreBody)) {\n      body = parseStatement();\n    }\n    state.inIteration = oldInIteration;\n    if (typeof left === 'undefined') {\n      return markerApply(marker, delegate.createForStatement(init, test, update, body));\n    }\n    if (operator.value === 'in') {\n      return markerApply(marker, delegate.createForInStatement(left, right, body));\n    }\n    return markerApply(marker, delegate.createForOfStatement(left, right, body));\n  }\n\n  // 12.7 The continue statement\n\n  function parseContinueStatement() {\n    var label = null,\n      marker = markerCreate();\n    expectKeyword('continue');\n\n    // Optimize the most common form: 'continue;'.\n    if (source.charCodeAt(index) === 59) {\n      lex();\n      if (!state.inIteration) {\n        throwError({}, Messages.IllegalContinue);\n      }\n      return markerApply(marker, delegate.createContinueStatement(null));\n    }\n    if (peekLineTerminator()) {\n      if (!state.inIteration) {\n        throwError({}, Messages.IllegalContinue);\n      }\n      return markerApply(marker, delegate.createContinueStatement(null));\n    }\n    if (lookahead.type === Token.Identifier) {\n      label = parseVariableIdentifier();\n      if (!state.labelSet.has(label.name)) {\n        throwError({}, Messages.UnknownLabel, label.name);\n      }\n    }\n    consumeSemicolon();\n    if (label === null && !state.inIteration) {\n      throwError({}, Messages.IllegalContinue);\n    }\n    return markerApply(marker, delegate.createContinueStatement(label));\n  }\n\n  // 12.8 The break statement\n\n  function parseBreakStatement() {\n    var label = null,\n      marker = markerCreate();\n    expectKeyword('break');\n\n    // Catch the very common case first: immediately a semicolon (char #59).\n    if (source.charCodeAt(index) === 59) {\n      lex();\n      if (!(state.inIteration || state.inSwitch)) {\n        throwError({}, Messages.IllegalBreak);\n      }\n      return markerApply(marker, delegate.createBreakStatement(null));\n    }\n    if (peekLineTerminator()) {\n      if (!(state.inIteration || state.inSwitch)) {\n        throwError({}, Messages.IllegalBreak);\n      }\n      return markerApply(marker, delegate.createBreakStatement(null));\n    }\n    if (lookahead.type === Token.Identifier) {\n      label = parseVariableIdentifier();\n      if (!state.labelSet.has(label.name)) {\n        throwError({}, Messages.UnknownLabel, label.name);\n      }\n    }\n    consumeSemicolon();\n    if (label === null && !(state.inIteration || state.inSwitch)) {\n      throwError({}, Messages.IllegalBreak);\n    }\n    return markerApply(marker, delegate.createBreakStatement(label));\n  }\n\n  // 12.9 The return statement\n\n  function parseReturnStatement() {\n    var argument = null,\n      marker = markerCreate();\n    expectKeyword('return');\n    if (!state.inFunctionBody) {\n      throwErrorTolerant({}, Messages.IllegalReturn);\n    }\n\n    // 'return' followed by a space and an identifier is very common.\n    if (source.charCodeAt(index) === 32) {\n      if (isIdentifierStart(source.charCodeAt(index + 1))) {\n        argument = parseExpression();\n        consumeSemicolon();\n        return markerApply(marker, delegate.createReturnStatement(argument));\n      }\n    }\n    if (peekLineTerminator()) {\n      return markerApply(marker, delegate.createReturnStatement(null));\n    }\n    if (!match(';')) {\n      if (!match('}') && lookahead.type !== Token.EOF) {\n        argument = parseExpression();\n      }\n    }\n    consumeSemicolon();\n    return markerApply(marker, delegate.createReturnStatement(argument));\n  }\n\n  // 12.10 The with statement\n\n  function parseWithStatement() {\n    var object,\n      body,\n      marker = markerCreate();\n    if (strict) {\n      throwErrorTolerant({}, Messages.StrictModeWith);\n    }\n    expectKeyword('with');\n    expect('(');\n    object = parseExpression();\n    expect(')');\n    body = parseStatement();\n    return markerApply(marker, delegate.createWithStatement(object, body));\n  }\n\n  // 12.10 The swith statement\n\n  function parseSwitchCase() {\n    var test,\n      consequent = [],\n      sourceElement,\n      marker = markerCreate();\n    if (matchKeyword('default')) {\n      lex();\n      test = null;\n    } else {\n      expectKeyword('case');\n      test = parseExpression();\n    }\n    expect(':');\n    while (index < length) {\n      if (match('}') || matchKeyword('default') || matchKeyword('case')) {\n        break;\n      }\n      sourceElement = parseSourceElement();\n      if (typeof sourceElement === 'undefined') {\n        break;\n      }\n      consequent.push(sourceElement);\n    }\n    return markerApply(marker, delegate.createSwitchCase(test, consequent));\n  }\n  function parseSwitchStatement() {\n    var discriminant,\n      cases,\n      clause,\n      oldInSwitch,\n      defaultFound,\n      marker = markerCreate();\n    expectKeyword('switch');\n    expect('(');\n    discriminant = parseExpression();\n    expect(')');\n    expect('{');\n    cases = [];\n    if (match('}')) {\n      lex();\n      return markerApply(marker, delegate.createSwitchStatement(discriminant, cases));\n    }\n    oldInSwitch = state.inSwitch;\n    state.inSwitch = true;\n    defaultFound = false;\n    while (index < length) {\n      if (match('}')) {\n        break;\n      }\n      clause = parseSwitchCase();\n      if (clause.test === null) {\n        if (defaultFound) {\n          throwError({}, Messages.MultipleDefaultsInSwitch);\n        }\n        defaultFound = true;\n      }\n      cases.push(clause);\n    }\n    state.inSwitch = oldInSwitch;\n    expect('}');\n    return markerApply(marker, delegate.createSwitchStatement(discriminant, cases));\n  }\n\n  // 12.13 The throw statement\n\n  function parseThrowStatement() {\n    var argument,\n      marker = markerCreate();\n    expectKeyword('throw');\n    if (peekLineTerminator()) {\n      throwError({}, Messages.NewlineAfterThrow);\n    }\n    argument = parseExpression();\n    consumeSemicolon();\n    return markerApply(marker, delegate.createThrowStatement(argument));\n  }\n\n  // 12.14 The try statement\n\n  function parseCatchClause() {\n    var param,\n      body,\n      marker = markerCreate();\n    expectKeyword('catch');\n    expect('(');\n    if (match(')')) {\n      throwUnexpected(lookahead);\n    }\n    param = parseExpression();\n    // 12.14.1\n    if (strict && param.type === Syntax.Identifier && isRestrictedWord(param.name)) {\n      throwErrorTolerant({}, Messages.StrictCatchVariable);\n    }\n    expect(')');\n    body = parseBlock();\n    return markerApply(marker, delegate.createCatchClause(param, body));\n  }\n  function parseTryStatement() {\n    var block,\n      handlers = [],\n      finalizer = null,\n      marker = markerCreate();\n    expectKeyword('try');\n    block = parseBlock();\n    if (matchKeyword('catch')) {\n      handlers.push(parseCatchClause());\n    }\n    if (matchKeyword('finally')) {\n      lex();\n      finalizer = parseBlock();\n    }\n    if (handlers.length === 0 && !finalizer) {\n      throwError({}, Messages.NoCatchOrFinally);\n    }\n    return markerApply(marker, delegate.createTryStatement(block, [], handlers, finalizer));\n  }\n\n  // 12.15 The debugger statement\n\n  function parseDebuggerStatement() {\n    var marker = markerCreate();\n    expectKeyword('debugger');\n    consumeSemicolon();\n    return markerApply(marker, delegate.createDebuggerStatement());\n  }\n\n  // 12 Statements\n\n  function parseStatement() {\n    var type = lookahead.type,\n      marker,\n      expr,\n      labeledBody;\n    if (type === Token.EOF) {\n      throwUnexpected(lookahead);\n    }\n    if (type === Token.Punctuator) {\n      switch (lookahead.value) {\n        case ';':\n          return parseEmptyStatement();\n        case '{':\n          return parseBlock();\n        case '(':\n          return parseExpressionStatement();\n        default:\n          break;\n      }\n    }\n    if (type === Token.Keyword) {\n      switch (lookahead.value) {\n        case 'break':\n          return parseBreakStatement();\n        case 'continue':\n          return parseContinueStatement();\n        case 'debugger':\n          return parseDebuggerStatement();\n        case 'do':\n          return parseDoWhileStatement();\n        case 'for':\n          return parseForStatement();\n        case 'function':\n          return parseFunctionDeclaration();\n        case 'class':\n          return parseClassDeclaration();\n        case 'if':\n          return parseIfStatement();\n        case 'return':\n          return parseReturnStatement();\n        case 'switch':\n          return parseSwitchStatement();\n        case 'throw':\n          return parseThrowStatement();\n        case 'try':\n          return parseTryStatement();\n        case 'var':\n          return parseVariableStatement();\n        case 'while':\n          return parseWhileStatement();\n        case 'with':\n          return parseWithStatement();\n        default:\n          break;\n      }\n    }\n    if (matchAsyncFuncExprOrDecl()) {\n      return parseFunctionDeclaration();\n    }\n    marker = markerCreate();\n    expr = parseExpression();\n\n    // 12.12 Labelled Statements\n    if (expr.type === Syntax.Identifier && match(':')) {\n      lex();\n      if (state.labelSet.has(expr.name)) {\n        throwError({}, Messages.Redeclaration, 'Label', expr.name);\n      }\n      state.labelSet.set(expr.name, true);\n      labeledBody = parseStatement();\n      state.labelSet.delete(expr.name);\n      return markerApply(marker, delegate.createLabeledStatement(expr, labeledBody));\n    }\n    consumeSemicolon();\n    return markerApply(marker, delegate.createExpressionStatement(expr));\n  }\n\n  // 13 Function Definition\n\n  function parseConciseBody() {\n    if (match('{')) {\n      return parseFunctionSourceElements();\n    }\n    return parseAssignmentExpression();\n  }\n  function parseFunctionSourceElements() {\n    var sourceElement,\n      sourceElements = [],\n      token,\n      directive,\n      firstRestricted,\n      oldLabelSet,\n      oldInIteration,\n      oldInSwitch,\n      oldInFunctionBody,\n      oldParenthesizedCount,\n      marker = markerCreate();\n    expect('{');\n    while (index < length) {\n      if (lookahead.type !== Token.StringLiteral) {\n        break;\n      }\n      token = lookahead;\n      sourceElement = parseSourceElement();\n      sourceElements.push(sourceElement);\n      if (sourceElement.expression.type !== Syntax.Literal) {\n        // this is not directive\n        break;\n      }\n      directive = source.slice(token.range[0] + 1, token.range[1] - 1);\n      if (directive === 'use strict') {\n        strict = true;\n        if (firstRestricted) {\n          throwErrorTolerant(firstRestricted, Messages.StrictOctalLiteral);\n        }\n      } else {\n        if (!firstRestricted && token.octal) {\n          firstRestricted = token;\n        }\n      }\n    }\n    oldLabelSet = state.labelSet;\n    oldInIteration = state.inIteration;\n    oldInSwitch = state.inSwitch;\n    oldInFunctionBody = state.inFunctionBody;\n    oldParenthesizedCount = state.parenthesizedCount;\n    state.labelSet = new StringMap();\n    state.inIteration = false;\n    state.inSwitch = false;\n    state.inFunctionBody = true;\n    state.parenthesizedCount = 0;\n    while (index < length) {\n      if (match('}')) {\n        break;\n      }\n      sourceElement = parseSourceElement();\n      if (typeof sourceElement === 'undefined') {\n        break;\n      }\n      sourceElements.push(sourceElement);\n    }\n    expect('}');\n    state.labelSet = oldLabelSet;\n    state.inIteration = oldInIteration;\n    state.inSwitch = oldInSwitch;\n    state.inFunctionBody = oldInFunctionBody;\n    state.parenthesizedCount = oldParenthesizedCount;\n    return markerApply(marker, delegate.createBlockStatement(sourceElements));\n  }\n  function validateParam(options, param, name) {\n    if (strict) {\n      if (isRestrictedWord(name)) {\n        options.stricted = param;\n        options.message = Messages.StrictParamName;\n      }\n      if (options.paramSet.has(name)) {\n        options.stricted = param;\n        options.message = Messages.StrictParamDupe;\n      }\n    } else if (!options.firstRestricted) {\n      if (isRestrictedWord(name)) {\n        options.firstRestricted = param;\n        options.message = Messages.StrictParamName;\n      } else if (isStrictModeReservedWord(name)) {\n        options.firstRestricted = param;\n        options.message = Messages.StrictReservedWord;\n      } else if (options.paramSet.has(name)) {\n        options.firstRestricted = param;\n        options.message = Messages.StrictParamDupe;\n      }\n    }\n    options.paramSet.set(name, true);\n  }\n  function parseParam(options) {\n    var marker, token, rest, param, def;\n    token = lookahead;\n    if (token.value === '...') {\n      token = lex();\n      rest = true;\n    }\n    if (match('[')) {\n      marker = markerCreate();\n      param = parseArrayInitialiser();\n      reinterpretAsDestructuredParameter(options, param);\n      if (match(':')) {\n        param.typeAnnotation = parseTypeAnnotation();\n        markerApply(marker, param);\n      }\n    } else if (match('{')) {\n      marker = markerCreate();\n      if (rest) {\n        throwError({}, Messages.ObjectPatternAsRestParameter);\n      }\n      param = parseObjectInitialiser();\n      reinterpretAsDestructuredParameter(options, param);\n      if (match(':')) {\n        param.typeAnnotation = parseTypeAnnotation();\n        markerApply(marker, param);\n      }\n    } else {\n      param = rest ? parseTypeAnnotatableIdentifier(false, /* requireTypeAnnotation */\n      false /* canBeOptionalParam */) : parseTypeAnnotatableIdentifier(false, /* requireTypeAnnotation */\n      true /* canBeOptionalParam */);\n\n      validateParam(options, token, token.value);\n    }\n    if (match('=')) {\n      if (rest) {\n        throwErrorTolerant(lookahead, Messages.DefaultRestParameter);\n      }\n      lex();\n      def = parseAssignmentExpression();\n      ++options.defaultCount;\n    }\n    if (rest) {\n      if (!match(')')) {\n        throwError({}, Messages.ParameterAfterRestParameter);\n      }\n      options.rest = param;\n      return false;\n    }\n    options.params.push(param);\n    options.defaults.push(def);\n    return !match(')');\n  }\n  function parseParams(firstRestricted) {\n    var options,\n      marker = markerCreate();\n    options = {\n      params: [],\n      defaultCount: 0,\n      defaults: [],\n      rest: null,\n      firstRestricted: firstRestricted\n    };\n    expect('(');\n    if (!match(')')) {\n      options.paramSet = new StringMap();\n      while (index < length) {\n        if (!parseParam(options)) {\n          break;\n        }\n        expect(',');\n        if (!options.rest && match(')')) {\n          break;\n        }\n      }\n    }\n    expect(')');\n    if (options.defaultCount === 0) {\n      options.defaults = [];\n    }\n    if (match(':')) {\n      options.returnType = parseTypeAnnotation();\n    }\n    return markerApply(marker, options);\n  }\n  function parseFunctionDeclaration() {\n    var id,\n      body,\n      token,\n      tmp,\n      firstRestricted,\n      message,\n      generator,\n      isAsync,\n      previousStrict,\n      previousYieldAllowed,\n      previousAwaitAllowed,\n      marker = markerCreate(),\n      typeParameters;\n    isAsync = false;\n    if (matchAsync()) {\n      lex();\n      isAsync = true;\n    }\n    expectKeyword('function');\n    generator = false;\n    if (match('*')) {\n      lex();\n      generator = true;\n    }\n    token = lookahead;\n    id = parseVariableIdentifier();\n    if (match('<')) {\n      typeParameters = parseTypeParameterDeclaration();\n    }\n    if (strict) {\n      if (isRestrictedWord(token.value)) {\n        throwErrorTolerant(token, Messages.StrictFunctionName);\n      }\n    } else {\n      if (isRestrictedWord(token.value)) {\n        firstRestricted = token;\n        message = Messages.StrictFunctionName;\n      } else if (isStrictModeReservedWord(token.value)) {\n        firstRestricted = token;\n        message = Messages.StrictReservedWord;\n      }\n    }\n    tmp = parseParams(firstRestricted);\n    firstRestricted = tmp.firstRestricted;\n    if (tmp.message) {\n      message = tmp.message;\n    }\n    previousStrict = strict;\n    previousYieldAllowed = state.yieldAllowed;\n    state.yieldAllowed = generator;\n    previousAwaitAllowed = state.awaitAllowed;\n    state.awaitAllowed = isAsync;\n    body = parseFunctionSourceElements();\n    if (strict && firstRestricted) {\n      throwError(firstRestricted, message);\n    }\n    if (strict && tmp.stricted) {\n      throwErrorTolerant(tmp.stricted, message);\n    }\n    strict = previousStrict;\n    state.yieldAllowed = previousYieldAllowed;\n    state.awaitAllowed = previousAwaitAllowed;\n    return markerApply(marker, delegate.createFunctionDeclaration(id, tmp.params, tmp.defaults, body, tmp.rest, generator, false, isAsync, tmp.returnType, typeParameters));\n  }\n  function parseFunctionExpression() {\n    var token,\n      id = null,\n      firstRestricted,\n      message,\n      tmp,\n      body,\n      generator,\n      isAsync,\n      previousStrict,\n      previousYieldAllowed,\n      previousAwaitAllowed,\n      marker = markerCreate(),\n      typeParameters;\n    isAsync = false;\n    if (matchAsync()) {\n      lex();\n      isAsync = true;\n    }\n    expectKeyword('function');\n    generator = false;\n    if (match('*')) {\n      lex();\n      generator = true;\n    }\n    if (!match('(')) {\n      if (!match('<')) {\n        token = lookahead;\n        id = parseVariableIdentifier();\n        if (strict) {\n          if (isRestrictedWord(token.value)) {\n            throwErrorTolerant(token, Messages.StrictFunctionName);\n          }\n        } else {\n          if (isRestrictedWord(token.value)) {\n            firstRestricted = token;\n            message = Messages.StrictFunctionName;\n          } else if (isStrictModeReservedWord(token.value)) {\n            firstRestricted = token;\n            message = Messages.StrictReservedWord;\n          }\n        }\n      }\n      if (match('<')) {\n        typeParameters = parseTypeParameterDeclaration();\n      }\n    }\n    tmp = parseParams(firstRestricted);\n    firstRestricted = tmp.firstRestricted;\n    if (tmp.message) {\n      message = tmp.message;\n    }\n    previousStrict = strict;\n    previousYieldAllowed = state.yieldAllowed;\n    state.yieldAllowed = generator;\n    previousAwaitAllowed = state.awaitAllowed;\n    state.awaitAllowed = isAsync;\n    body = parseFunctionSourceElements();\n    if (strict && firstRestricted) {\n      throwError(firstRestricted, message);\n    }\n    if (strict && tmp.stricted) {\n      throwErrorTolerant(tmp.stricted, message);\n    }\n    strict = previousStrict;\n    state.yieldAllowed = previousYieldAllowed;\n    state.awaitAllowed = previousAwaitAllowed;\n    return markerApply(marker, delegate.createFunctionExpression(id, tmp.params, tmp.defaults, body, tmp.rest, generator, false, isAsync, tmp.returnType, typeParameters));\n  }\n  function parseYieldExpression() {\n    var delegateFlag,\n      expr,\n      marker = markerCreate();\n    expectKeyword('yield', !strict);\n    delegateFlag = false;\n    if (match('*')) {\n      lex();\n      delegateFlag = true;\n    }\n    expr = parseAssignmentExpression();\n    return markerApply(marker, delegate.createYieldExpression(expr, delegateFlag));\n  }\n  function parseAwaitExpression() {\n    var expr,\n      marker = markerCreate();\n    expectContextualKeyword('await');\n    expr = parseAssignmentExpression();\n    return markerApply(marker, delegate.createAwaitExpression(expr));\n  }\n\n  // 14 Functions and classes\n\n  // 14.1 Functions is defined above (13 in ES5)\n  // 14.2 Arrow Functions Definitions is defined in (7.3 assignments)\n\n  // 14.3 Method Definitions\n  // 14.3.7\n  function specialMethod(methodDefinition) {\n    return methodDefinition.kind === 'get' || methodDefinition.kind === 'set' || methodDefinition.value.generator;\n  }\n  function parseMethodDefinition(key, isStatic, generator, computed) {\n    var token, param, propType, isAsync, typeParameters, tokenValue, returnType;\n    propType = isStatic ? ClassPropertyType.static : ClassPropertyType.prototype;\n    if (generator) {\n      return delegate.createMethodDefinition(propType, '', key, parsePropertyMethodFunction({\n        generator: true\n      }), computed);\n    }\n    tokenValue = key.type === 'Identifier' && key.name;\n    if (tokenValue === 'get' && !match('(')) {\n      key = parseObjectPropertyKey();\n      expect('(');\n      expect(')');\n      if (match(':')) {\n        returnType = parseTypeAnnotation();\n      }\n      return delegate.createMethodDefinition(propType, 'get', key, parsePropertyFunction({\n        generator: false,\n        returnType: returnType\n      }), computed);\n    }\n    if (tokenValue === 'set' && !match('(')) {\n      key = parseObjectPropertyKey();\n      expect('(');\n      token = lookahead;\n      param = [parseTypeAnnotatableIdentifier()];\n      expect(')');\n      if (match(':')) {\n        returnType = parseTypeAnnotation();\n      }\n      return delegate.createMethodDefinition(propType, 'set', key, parsePropertyFunction({\n        params: param,\n        generator: false,\n        name: token,\n        returnType: returnType\n      }), computed);\n    }\n    if (match('<')) {\n      typeParameters = parseTypeParameterDeclaration();\n    }\n    isAsync = tokenValue === 'async' && !match('(');\n    if (isAsync) {\n      key = parseObjectPropertyKey();\n    }\n    return delegate.createMethodDefinition(propType, '', key, parsePropertyMethodFunction({\n      generator: false,\n      async: isAsync,\n      typeParameters: typeParameters\n    }), computed);\n  }\n  function parseClassProperty(key, computed, isStatic) {\n    var typeAnnotation;\n    typeAnnotation = parseTypeAnnotation();\n    expect(';');\n    return delegate.createClassProperty(key, typeAnnotation, computed, isStatic);\n  }\n  function parseClassElement() {\n    var computed = false,\n      generator = false,\n      key,\n      marker = markerCreate(),\n      isStatic = false,\n      possiblyOpenBracketToken;\n    if (match(';')) {\n      lex();\n      return undefined;\n    }\n    if (lookahead.value === 'static') {\n      lex();\n      isStatic = true;\n    }\n    if (match('*')) {\n      lex();\n      generator = true;\n    }\n    possiblyOpenBracketToken = lookahead;\n    if (matchContextualKeyword('get') || matchContextualKeyword('set')) {\n      possiblyOpenBracketToken = lookahead2();\n    }\n    if (possiblyOpenBracketToken.type === Token.Punctuator && possiblyOpenBracketToken.value === '[') {\n      computed = true;\n    }\n    key = parseObjectPropertyKey();\n    if (!generator && lookahead.value === ':') {\n      return markerApply(marker, parseClassProperty(key, computed, isStatic));\n    }\n    return markerApply(marker, parseMethodDefinition(key, isStatic, generator, computed));\n  }\n  function parseClassBody() {\n    var classElement,\n      classElements = [],\n      existingProps = {},\n      marker = markerCreate(),\n      propName,\n      propType;\n    existingProps[ClassPropertyType.static] = new StringMap();\n    existingProps[ClassPropertyType.prototype] = new StringMap();\n    expect('{');\n    while (index < length) {\n      if (match('}')) {\n        break;\n      }\n      classElement = parseClassElement(existingProps);\n      if (typeof classElement !== 'undefined') {\n        classElements.push(classElement);\n        propName = !classElement.computed && getFieldName(classElement.key);\n        if (propName !== false) {\n          propType = classElement.static ? ClassPropertyType.static : ClassPropertyType.prototype;\n          if (classElement.type === Syntax.MethodDefinition) {\n            if (propName === 'constructor' && !classElement.static) {\n              if (specialMethod(classElement)) {\n                throwError(classElement, Messages.IllegalClassConstructorProperty);\n              }\n              if (existingProps[ClassPropertyType.prototype].has('constructor')) {\n                throwError(classElement.key, Messages.IllegalDuplicateClassProperty);\n              }\n            }\n            existingProps[propType].set(propName, true);\n          }\n        }\n      }\n    }\n    expect('}');\n    return markerApply(marker, delegate.createClassBody(classElements));\n  }\n  function parseClassImplements() {\n    var id,\n      implemented = [],\n      marker,\n      typeParameters;\n    if (strict) {\n      expectKeyword('implements');\n    } else {\n      expectContextualKeyword('implements');\n    }\n    while (index < length) {\n      marker = markerCreate();\n      id = parseVariableIdentifier();\n      if (match('<')) {\n        typeParameters = parseTypeParameterInstantiation();\n      } else {\n        typeParameters = null;\n      }\n      implemented.push(markerApply(marker, delegate.createClassImplements(id, typeParameters)));\n      if (!match(',')) {\n        break;\n      }\n      expect(',');\n    }\n    return implemented;\n  }\n  function parseClassExpression() {\n    var id,\n      implemented,\n      previousYieldAllowed,\n      superClass = null,\n      superTypeParameters,\n      marker = markerCreate(),\n      typeParameters,\n      matchImplements;\n    expectKeyword('class');\n    matchImplements = strict ? matchKeyword('implements') : matchContextualKeyword('implements');\n    if (!matchKeyword('extends') && !matchImplements && !match('{')) {\n      id = parseVariableIdentifier();\n    }\n    if (match('<')) {\n      typeParameters = parseTypeParameterDeclaration();\n    }\n    if (matchKeyword('extends')) {\n      expectKeyword('extends');\n      previousYieldAllowed = state.yieldAllowed;\n      state.yieldAllowed = false;\n      superClass = parseLeftHandSideExpressionAllowCall();\n      if (match('<')) {\n        superTypeParameters = parseTypeParameterInstantiation();\n      }\n      state.yieldAllowed = previousYieldAllowed;\n    }\n    if (strict ? matchKeyword('implements') : matchContextualKeyword('implements')) {\n      implemented = parseClassImplements();\n    }\n    return markerApply(marker, delegate.createClassExpression(id, superClass, parseClassBody(), typeParameters, superTypeParameters, implemented));\n  }\n  function parseClassDeclaration() {\n    var id,\n      implemented,\n      previousYieldAllowed,\n      superClass = null,\n      superTypeParameters,\n      marker = markerCreate(),\n      typeParameters;\n    expectKeyword('class');\n    id = parseVariableIdentifier();\n    if (match('<')) {\n      typeParameters = parseTypeParameterDeclaration();\n    }\n    if (matchKeyword('extends')) {\n      expectKeyword('extends');\n      previousYieldAllowed = state.yieldAllowed;\n      state.yieldAllowed = false;\n      superClass = parseLeftHandSideExpressionAllowCall();\n      if (match('<')) {\n        superTypeParameters = parseTypeParameterInstantiation();\n      }\n      state.yieldAllowed = previousYieldAllowed;\n    }\n    if (strict ? matchKeyword('implements') : matchContextualKeyword('implements')) {\n      implemented = parseClassImplements();\n    }\n    return markerApply(marker, delegate.createClassDeclaration(id, superClass, parseClassBody(), typeParameters, superTypeParameters, implemented));\n  }\n\n  // 15 Program\n\n  function parseSourceElement() {\n    var token;\n    if (lookahead.type === Token.Keyword) {\n      switch (lookahead.value) {\n        case 'const':\n        case 'let':\n          return parseConstLetDeclaration(lookahead.value);\n        case 'function':\n          return parseFunctionDeclaration();\n        case 'export':\n          throwErrorTolerant({}, Messages.IllegalExportDeclaration);\n          return parseExportDeclaration();\n        case 'import':\n          throwErrorTolerant({}, Messages.IllegalImportDeclaration);\n          return parseImportDeclaration();\n        case 'interface':\n          if (lookahead2().type === Token.Identifier) {\n            return parseInterface();\n          }\n          return parseStatement();\n        default:\n          return parseStatement();\n      }\n    }\n    if (matchContextualKeyword('type') && lookahead2().type === Token.Identifier) {\n      return parseTypeAlias();\n    }\n    if (matchContextualKeyword('interface') && lookahead2().type === Token.Identifier) {\n      return parseInterface();\n    }\n    if (matchContextualKeyword('declare')) {\n      token = lookahead2();\n      if (token.type === Token.Keyword) {\n        switch (token.value) {\n          case 'class':\n            return parseDeclareClass();\n          case 'function':\n            return parseDeclareFunction();\n          case 'var':\n            return parseDeclareVariable();\n        }\n      } else if (token.type === Token.Identifier && token.value === 'module') {\n        return parseDeclareModule();\n      }\n    }\n    if (lookahead.type !== Token.EOF) {\n      return parseStatement();\n    }\n  }\n  function parseProgramElement() {\n    var isModule = extra.sourceType === 'module' || extra.sourceType === 'nonStrictModule';\n    if (isModule && lookahead.type === Token.Keyword) {\n      switch (lookahead.value) {\n        case 'export':\n          return parseExportDeclaration();\n        case 'import':\n          return parseImportDeclaration();\n      }\n    }\n    return parseSourceElement();\n  }\n  function parseProgramElements() {\n    var sourceElement,\n      sourceElements = [],\n      token,\n      directive,\n      firstRestricted;\n    while (index < length) {\n      token = lookahead;\n      if (token.type !== Token.StringLiteral) {\n        break;\n      }\n      sourceElement = parseProgramElement();\n      sourceElements.push(sourceElement);\n      if (sourceElement.expression.type !== Syntax.Literal) {\n        // this is not directive\n        break;\n      }\n      directive = source.slice(token.range[0] + 1, token.range[1] - 1);\n      if (directive === 'use strict') {\n        strict = true;\n        if (firstRestricted) {\n          throwErrorTolerant(firstRestricted, Messages.StrictOctalLiteral);\n        }\n      } else {\n        if (!firstRestricted && token.octal) {\n          firstRestricted = token;\n        }\n      }\n    }\n    while (index < length) {\n      sourceElement = parseProgramElement();\n      if (typeof sourceElement === 'undefined') {\n        break;\n      }\n      sourceElements.push(sourceElement);\n    }\n    return sourceElements;\n  }\n  function parseProgram() {\n    var body,\n      marker = markerCreate();\n    strict = extra.sourceType === 'module';\n    peek();\n    body = parseProgramElements();\n    return markerApply(marker, delegate.createProgram(body));\n  }\n\n  // 16 JSX\n\n  XHTMLEntities = {\n    quot: \"\\\"\",\n    amp: '&',\n    apos: \"'\",\n    lt: '<',\n    gt: '>',\n    nbsp: \"\\xA0\",\n    iexcl: \"\\xA1\",\n    cent: \"\\xA2\",\n    pound: \"\\xA3\",\n    curren: \"\\xA4\",\n    yen: \"\\xA5\",\n    brvbar: \"\\xA6\",\n    sect: \"\\xA7\",\n    uml: \"\\xA8\",\n    copy: \"\\xA9\",\n    ordf: \"\\xAA\",\n    laquo: \"\\xAB\",\n    not: \"\\xAC\",\n    shy: \"\\xAD\",\n    reg: \"\\xAE\",\n    macr: \"\\xAF\",\n    deg: \"\\xB0\",\n    plusmn: \"\\xB1\",\n    sup2: \"\\xB2\",\n    sup3: \"\\xB3\",\n    acute: \"\\xB4\",\n    micro: \"\\xB5\",\n    para: \"\\xB6\",\n    middot: \"\\xB7\",\n    cedil: \"\\xB8\",\n    sup1: \"\\xB9\",\n    ordm: \"\\xBA\",\n    raquo: \"\\xBB\",\n    frac14: \"\\xBC\",\n    frac12: \"\\xBD\",\n    frac34: \"\\xBE\",\n    iquest: \"\\xBF\",\n    Agrave: \"\\xC0\",\n    Aacute: \"\\xC1\",\n    Acirc: \"\\xC2\",\n    Atilde: \"\\xC3\",\n    Auml: \"\\xC4\",\n    Aring: \"\\xC5\",\n    AElig: \"\\xC6\",\n    Ccedil: \"\\xC7\",\n    Egrave: \"\\xC8\",\n    Eacute: \"\\xC9\",\n    Ecirc: \"\\xCA\",\n    Euml: \"\\xCB\",\n    Igrave: \"\\xCC\",\n    Iacute: \"\\xCD\",\n    Icirc: \"\\xCE\",\n    Iuml: \"\\xCF\",\n    ETH: \"\\xD0\",\n    Ntilde: \"\\xD1\",\n    Ograve: \"\\xD2\",\n    Oacute: \"\\xD3\",\n    Ocirc: \"\\xD4\",\n    Otilde: \"\\xD5\",\n    Ouml: \"\\xD6\",\n    times: \"\\xD7\",\n    Oslash: \"\\xD8\",\n    Ugrave: \"\\xD9\",\n    Uacute: \"\\xDA\",\n    Ucirc: \"\\xDB\",\n    Uuml: \"\\xDC\",\n    Yacute: \"\\xDD\",\n    THORN: \"\\xDE\",\n    szlig: \"\\xDF\",\n    agrave: \"\\xE0\",\n    aacute: \"\\xE1\",\n    acirc: \"\\xE2\",\n    atilde: \"\\xE3\",\n    auml: \"\\xE4\",\n    aring: \"\\xE5\",\n    aelig: \"\\xE6\",\n    ccedil: \"\\xE7\",\n    egrave: \"\\xE8\",\n    eacute: \"\\xE9\",\n    ecirc: \"\\xEA\",\n    euml: \"\\xEB\",\n    igrave: \"\\xEC\",\n    iacute: \"\\xED\",\n    icirc: \"\\xEE\",\n    iuml: \"\\xEF\",\n    eth: \"\\xF0\",\n    ntilde: \"\\xF1\",\n    ograve: \"\\xF2\",\n    oacute: \"\\xF3\",\n    ocirc: \"\\xF4\",\n    otilde: \"\\xF5\",\n    ouml: \"\\xF6\",\n    divide: \"\\xF7\",\n    oslash: \"\\xF8\",\n    ugrave: \"\\xF9\",\n    uacute: \"\\xFA\",\n    ucirc: \"\\xFB\",\n    uuml: \"\\xFC\",\n    yacute: \"\\xFD\",\n    thorn: \"\\xFE\",\n    yuml: \"\\xFF\",\n    OElig: \"\\u0152\",\n    oelig: \"\\u0153\",\n    Scaron: \"\\u0160\",\n    scaron: \"\\u0161\",\n    Yuml: \"\\u0178\",\n    fnof: \"\\u0192\",\n    circ: \"\\u02C6\",\n    tilde: \"\\u02DC\",\n    Alpha: \"\\u0391\",\n    Beta: \"\\u0392\",\n    Gamma: \"\\u0393\",\n    Delta: \"\\u0394\",\n    Epsilon: \"\\u0395\",\n    Zeta: \"\\u0396\",\n    Eta: \"\\u0397\",\n    Theta: \"\\u0398\",\n    Iota: \"\\u0399\",\n    Kappa: \"\\u039A\",\n    Lambda: \"\\u039B\",\n    Mu: \"\\u039C\",\n    Nu: \"\\u039D\",\n    Xi: \"\\u039E\",\n    Omicron: \"\\u039F\",\n    Pi: \"\\u03A0\",\n    Rho: \"\\u03A1\",\n    Sigma: \"\\u03A3\",\n    Tau: \"\\u03A4\",\n    Upsilon: \"\\u03A5\",\n    Phi: \"\\u03A6\",\n    Chi: \"\\u03A7\",\n    Psi: \"\\u03A8\",\n    Omega: \"\\u03A9\",\n    alpha: \"\\u03B1\",\n    beta: \"\\u03B2\",\n    gamma: \"\\u03B3\",\n    delta: \"\\u03B4\",\n    epsilon: \"\\u03B5\",\n    zeta: \"\\u03B6\",\n    eta: \"\\u03B7\",\n    theta: \"\\u03B8\",\n    iota: \"\\u03B9\",\n    kappa: \"\\u03BA\",\n    lambda: \"\\u03BB\",\n    mu: \"\\u03BC\",\n    nu: \"\\u03BD\",\n    xi: \"\\u03BE\",\n    omicron: \"\\u03BF\",\n    pi: \"\\u03C0\",\n    rho: \"\\u03C1\",\n    sigmaf: \"\\u03C2\",\n    sigma: \"\\u03C3\",\n    tau: \"\\u03C4\",\n    upsilon: \"\\u03C5\",\n    phi: \"\\u03C6\",\n    chi: \"\\u03C7\",\n    psi: \"\\u03C8\",\n    omega: \"\\u03C9\",\n    thetasym: \"\\u03D1\",\n    upsih: \"\\u03D2\",\n    piv: \"\\u03D6\",\n    ensp: \"\\u2002\",\n    emsp: \"\\u2003\",\n    thinsp: \"\\u2009\",\n    zwnj: \"\\u200C\",\n    zwj: \"\\u200D\",\n    lrm: \"\\u200E\",\n    rlm: \"\\u200F\",\n    ndash: \"\\u2013\",\n    mdash: \"\\u2014\",\n    lsquo: \"\\u2018\",\n    rsquo: \"\\u2019\",\n    sbquo: \"\\u201A\",\n    ldquo: \"\\u201C\",\n    rdquo: \"\\u201D\",\n    bdquo: \"\\u201E\",\n    dagger: \"\\u2020\",\n    Dagger: \"\\u2021\",\n    bull: \"\\u2022\",\n    hellip: \"\\u2026\",\n    permil: \"\\u2030\",\n    prime: \"\\u2032\",\n    Prime: \"\\u2033\",\n    lsaquo: \"\\u2039\",\n    rsaquo: \"\\u203A\",\n    oline: \"\\u203E\",\n    frasl: \"\\u2044\",\n    euro: \"\\u20AC\",\n    image: \"\\u2111\",\n    weierp: \"\\u2118\",\n    real: \"\\u211C\",\n    trade: \"\\u2122\",\n    alefsym: \"\\u2135\",\n    larr: \"\\u2190\",\n    uarr: \"\\u2191\",\n    rarr: \"\\u2192\",\n    darr: \"\\u2193\",\n    harr: \"\\u2194\",\n    crarr: \"\\u21B5\",\n    lArr: \"\\u21D0\",\n    uArr: \"\\u21D1\",\n    rArr: \"\\u21D2\",\n    dArr: \"\\u21D3\",\n    hArr: \"\\u21D4\",\n    forall: \"\\u2200\",\n    part: \"\\u2202\",\n    exist: \"\\u2203\",\n    empty: \"\\u2205\",\n    nabla: \"\\u2207\",\n    isin: \"\\u2208\",\n    notin: \"\\u2209\",\n    ni: \"\\u220B\",\n    prod: \"\\u220F\",\n    sum: \"\\u2211\",\n    minus: \"\\u2212\",\n    lowast: \"\\u2217\",\n    radic: \"\\u221A\",\n    prop: \"\\u221D\",\n    infin: \"\\u221E\",\n    ang: \"\\u2220\",\n    and: \"\\u2227\",\n    or: \"\\u2228\",\n    cap: \"\\u2229\",\n    cup: \"\\u222A\",\n    'int': \"\\u222B\",\n    there4: \"\\u2234\",\n    sim: \"\\u223C\",\n    cong: \"\\u2245\",\n    asymp: \"\\u2248\",\n    ne: \"\\u2260\",\n    equiv: \"\\u2261\",\n    le: \"\\u2264\",\n    ge: \"\\u2265\",\n    sub: \"\\u2282\",\n    sup: \"\\u2283\",\n    nsub: \"\\u2284\",\n    sube: \"\\u2286\",\n    supe: \"\\u2287\",\n    oplus: \"\\u2295\",\n    otimes: \"\\u2297\",\n    perp: \"\\u22A5\",\n    sdot: \"\\u22C5\",\n    lceil: \"\\u2308\",\n    rceil: \"\\u2309\",\n    lfloor: \"\\u230A\",\n    rfloor: \"\\u230B\",\n    lang: \"\\u2329\",\n    rang: \"\\u232A\",\n    loz: \"\\u25CA\",\n    spades: \"\\u2660\",\n    clubs: \"\\u2663\",\n    hearts: \"\\u2665\",\n    diams: \"\\u2666\"\n  };\n  function getQualifiedJSXName(object) {\n    if (object.type === Syntax.JSXIdentifier) {\n      return object.name;\n    }\n    if (object.type === Syntax.JSXNamespacedName) {\n      return object.namespace.name + ':' + object.name.name;\n    }\n    /* istanbul ignore else */\n    if (object.type === Syntax.JSXMemberExpression) {\n      return getQualifiedJSXName(object.object) + '.' + getQualifiedJSXName(object.property);\n    }\n    /* istanbul ignore next */\n    throwUnexpected(object);\n  }\n  function isJSXIdentifierStart(ch) {\n    // exclude backslash (\\)\n    return ch !== 92 && isIdentifierStart(ch);\n  }\n  function isJSXIdentifierPart(ch) {\n    // exclude backslash (\\) and add hyphen (-)\n    return ch !== 92 && (ch === 45 || isIdentifierPart(ch));\n  }\n  function scanJSXIdentifier() {\n    var ch,\n      start,\n      value = '';\n    start = index;\n    while (index < length) {\n      ch = source.charCodeAt(index);\n      if (!isJSXIdentifierPart(ch)) {\n        break;\n      }\n      value += source[index++];\n    }\n    return {\n      type: Token.JSXIdentifier,\n      value: value,\n      lineNumber: lineNumber,\n      lineStart: lineStart,\n      range: [start, index]\n    };\n  }\n  function scanJSXEntity() {\n    var ch,\n      str = '',\n      start = index,\n      count = 0,\n      code;\n    ch = source[index];\n    assert(ch === '&', 'Entity must start with an ampersand');\n    index++;\n    while (index < length && count++ < 10) {\n      ch = source[index++];\n      if (ch === ';') {\n        break;\n      }\n      str += ch;\n    }\n\n    // Well-formed entity (ending was found).\n    if (ch === ';') {\n      // Numeric entity.\n      if (str[0] === '#') {\n        if (str[1] === 'x') {\n          code = +('0' + str.substr(1));\n        } else {\n          // Removing leading zeros in order to avoid treating as octal in old browsers.\n          code = +str.substr(1).replace(Regex.LeadingZeros, '');\n        }\n        if (!isNaN(code)) {\n          return String.fromCharCode(code);\n        }\n        /* istanbul ignore else */\n      } else if (XHTMLEntities[str]) {\n        return XHTMLEntities[str];\n      }\n    }\n\n    // Treat non-entity sequences as regular text.\n    index = start + 1;\n    return '&';\n  }\n  function scanJSXText(stopChars) {\n    var ch,\n      str = '',\n      start;\n    start = index;\n    while (index < length) {\n      ch = source[index];\n      if (stopChars.indexOf(ch) !== -1) {\n        break;\n      }\n      if (ch === '&') {\n        str += scanJSXEntity();\n      } else {\n        index++;\n        if (ch === '\\r' && source[index] === '\\n') {\n          str += ch;\n          ch = source[index];\n          index++;\n        }\n        if (isLineTerminator(ch.charCodeAt(0))) {\n          ++lineNumber;\n          lineStart = index;\n        }\n        str += ch;\n      }\n    }\n    return {\n      type: Token.JSXText,\n      value: str,\n      lineNumber: lineNumber,\n      lineStart: lineStart,\n      range: [start, index]\n    };\n  }\n  function scanJSXStringLiteral() {\n    var innerToken, quote, start;\n    quote = source[index];\n    assert(quote === '\\'' || quote === '\"', 'String literal must starts with a quote');\n    start = index;\n    ++index;\n    innerToken = scanJSXText([quote]);\n    if (quote !== source[index]) {\n      throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n    }\n    ++index;\n    innerToken.range = [start, index];\n    return innerToken;\n  }\n\n  /**\n   * Between JSX opening and closing tags (e.g. <foo>HERE</foo>), anything that\n   * is not another JSX tag and is not an expression wrapped by {} is text.\n   */\n  function advanceJSXChild() {\n    var ch = source.charCodeAt(index);\n\n    // '<' 60, '>' 62, '{' 123, '}' 125\n    if (ch !== 60 && ch !== 62 && ch !== 123 && ch !== 125) {\n      return scanJSXText(['<', '>', '{', '}']);\n    }\n    return scanPunctuator();\n  }\n  function parseJSXIdentifier() {\n    var token,\n      marker = markerCreate();\n    if (lookahead.type !== Token.JSXIdentifier) {\n      throwUnexpected(lookahead);\n    }\n    token = lex();\n    return markerApply(marker, delegate.createJSXIdentifier(token.value));\n  }\n  function parseJSXNamespacedName() {\n    var namespace,\n      name,\n      marker = markerCreate();\n    namespace = parseJSXIdentifier();\n    expect(':');\n    name = parseJSXIdentifier();\n    return markerApply(marker, delegate.createJSXNamespacedName(namespace, name));\n  }\n  function parseJSXMemberExpression() {\n    var marker = markerCreate(),\n      expr = parseJSXIdentifier();\n    while (match('.')) {\n      lex();\n      expr = markerApply(marker, delegate.createJSXMemberExpression(expr, parseJSXIdentifier()));\n    }\n    return expr;\n  }\n  function parseJSXElementName() {\n    if (lookahead2().value === ':') {\n      return parseJSXNamespacedName();\n    }\n    if (lookahead2().value === '.') {\n      return parseJSXMemberExpression();\n    }\n    return parseJSXIdentifier();\n  }\n  function parseJSXAttributeName() {\n    if (lookahead2().value === ':') {\n      return parseJSXNamespacedName();\n    }\n    return parseJSXIdentifier();\n  }\n  function parseJSXAttributeValue() {\n    var value, marker;\n    if (match('{')) {\n      value = parseJSXExpressionContainer();\n      if (value.expression.type === Syntax.JSXEmptyExpression) {\n        throwError(value, 'JSX attributes must only be assigned a non-empty ' + 'expression');\n      }\n    } else if (match('<')) {\n      value = parseJSXElement();\n    } else if (lookahead.type === Token.JSXText) {\n      marker = markerCreate();\n      value = markerApply(marker, delegate.createLiteral(lex()));\n    } else {\n      throwError({}, Messages.InvalidJSXAttributeValue);\n    }\n    return value;\n  }\n  function parseJSXEmptyExpression() {\n    var ch,\n      marker = markerCreatePreserveWhitespace();\n    while (index < length) {\n      ch = source.charCodeAt(index);\n      if (ch === 125) {\n        break;\n      } else if (isLineTerminator(ch)) {\n        if (ch === 13 && source.charCodeAt(index + 1) === 10) {\n          ++index;\n        }\n        ++lineNumber;\n        lineStart = index;\n      }\n      ++index;\n    }\n    return markerApply(marker, delegate.createJSXEmptyExpression());\n  }\n  function parseJSXExpressionContainer() {\n    var expression,\n      origInJSXChild,\n      origInJSXTag,\n      marker = markerCreate();\n    origInJSXChild = state.inJSXChild;\n    origInJSXTag = state.inJSXTag;\n    state.inJSXChild = false;\n    state.inJSXTag = false;\n    expect('{');\n    if (match('}')) {\n      expression = parseJSXEmptyExpression();\n    } else {\n      expression = parseExpression();\n    }\n    state.inJSXChild = origInJSXChild;\n    state.inJSXTag = origInJSXTag;\n    expect('}');\n    return markerApply(marker, delegate.createJSXExpressionContainer(expression));\n  }\n  function parseJSXSpreadAttribute() {\n    var expression,\n      origInJSXChild,\n      origInJSXTag,\n      marker = markerCreate();\n    origInJSXChild = state.inJSXChild;\n    origInJSXTag = state.inJSXTag;\n    state.inJSXChild = false;\n    state.inJSXTag = false;\n    expect('{');\n    expect('...');\n    expression = parseAssignmentExpression();\n    state.inJSXChild = origInJSXChild;\n    state.inJSXTag = origInJSXTag;\n    expect('}');\n    return markerApply(marker, delegate.createJSXSpreadAttribute(expression));\n  }\n  function parseJSXAttribute() {\n    var name, marker;\n    if (match('{')) {\n      return parseJSXSpreadAttribute();\n    }\n    marker = markerCreate();\n    name = parseJSXAttributeName();\n\n    // HTML empty attribute\n    if (match('=')) {\n      lex();\n      return markerApply(marker, delegate.createJSXAttribute(name, parseJSXAttributeValue()));\n    }\n    return markerApply(marker, delegate.createJSXAttribute(name));\n  }\n  function parseJSXChild() {\n    var token, marker;\n    if (match('{')) {\n      token = parseJSXExpressionContainer();\n    } else if (lookahead.type === Token.JSXText) {\n      marker = markerCreatePreserveWhitespace();\n      token = markerApply(marker, delegate.createLiteral(lex()));\n    } else if (match('<')) {\n      token = parseJSXElement();\n    } else {\n      throwUnexpected(lookahead);\n    }\n    return token;\n  }\n  function parseJSXClosingElement() {\n    var name,\n      origInJSXChild,\n      origInJSXTag,\n      marker = markerCreate();\n    origInJSXChild = state.inJSXChild;\n    origInJSXTag = state.inJSXTag;\n    state.inJSXChild = false;\n    state.inJSXTag = true;\n    expect('<');\n    expect('/');\n    name = parseJSXElementName();\n    // Because advance() (called by lex() called by expect()) expects there\n    // to be a valid token after >, it needs to know whether to look for a\n    // standard JS token or an JSX text node\n    state.inJSXChild = origInJSXChild;\n    state.inJSXTag = origInJSXTag;\n    expect('>');\n    return markerApply(marker, delegate.createJSXClosingElement(name));\n  }\n  function parseJSXOpeningElement() {\n    var name,\n      attributes = [],\n      selfClosing = false,\n      origInJSXChild,\n      origInJSXTag,\n      marker = markerCreate();\n    origInJSXChild = state.inJSXChild;\n    origInJSXTag = state.inJSXTag;\n    state.inJSXChild = false;\n    state.inJSXTag = true;\n    expect('<');\n    name = parseJSXElementName();\n    while (index < length && lookahead.value !== '/' && lookahead.value !== '>') {\n      attributes.push(parseJSXAttribute());\n    }\n    state.inJSXTag = origInJSXTag;\n    if (lookahead.value === '/') {\n      expect('/');\n      // Because advance() (called by lex() called by expect()) expects\n      // there to be a valid token after >, it needs to know whether to\n      // look for a standard JS token or an JSX text node\n      state.inJSXChild = origInJSXChild;\n      expect('>');\n      selfClosing = true;\n    } else {\n      state.inJSXChild = true;\n      expect('>');\n    }\n    return markerApply(marker, delegate.createJSXOpeningElement(name, attributes, selfClosing));\n  }\n  function parseJSXElement() {\n    var openingElement,\n      closingElement = null,\n      children = [],\n      origInJSXChild,\n      origInJSXTag,\n      marker = markerCreate();\n    origInJSXChild = state.inJSXChild;\n    origInJSXTag = state.inJSXTag;\n    openingElement = parseJSXOpeningElement();\n    if (!openingElement.selfClosing) {\n      while (index < length) {\n        state.inJSXChild = false; // Call lookahead2() with inJSXChild = false because </ should not be considered in the child\n        if (lookahead.value === '<' && lookahead2().value === '/') {\n          break;\n        }\n        state.inJSXChild = true;\n        children.push(parseJSXChild());\n      }\n      state.inJSXChild = origInJSXChild;\n      state.inJSXTag = origInJSXTag;\n      closingElement = parseJSXClosingElement();\n      if (getQualifiedJSXName(closingElement.name) !== getQualifiedJSXName(openingElement.name)) {\n        throwError({}, Messages.ExpectedJSXClosingTag, getQualifiedJSXName(openingElement.name));\n      }\n    }\n\n    // When (erroneously) writing two adjacent tags like\n    //\n    //     var x = <div>one</div><div>two</div>;\n    //\n    // the default error message is a bit incomprehensible. Since it's\n    // rarely (never?) useful to write a less-than sign after an JSX\n    // element, we disallow it here in the parser in order to provide a\n    // better error message. (In the rare case that the less-than operator\n    // was intended, the left tag can be wrapped in parentheses.)\n    if (!origInJSXChild && match('<')) {\n      throwError(lookahead, Messages.AdjacentJSXElements);\n    }\n    return markerApply(marker, delegate.createJSXElement(openingElement, closingElement, children));\n  }\n  function parseTypeAlias() {\n    var id,\n      marker = markerCreate(),\n      typeParameters = null,\n      right;\n    expectContextualKeyword('type');\n    id = parseVariableIdentifier();\n    if (match('<')) {\n      typeParameters = parseTypeParameterDeclaration();\n    }\n    expect('=');\n    right = parseType();\n    consumeSemicolon();\n    return markerApply(marker, delegate.createTypeAlias(id, typeParameters, right));\n  }\n  function parseInterfaceExtends() {\n    var marker = markerCreate(),\n      id,\n      typeParameters = null;\n    id = parseVariableIdentifier();\n    if (match('<')) {\n      typeParameters = parseTypeParameterInstantiation();\n    }\n    return markerApply(marker, delegate.createInterfaceExtends(id, typeParameters));\n  }\n  function parseInterfaceish(marker, allowStatic) {\n    var body,\n      bodyMarker,\n      extended = [],\n      id,\n      typeParameters = null;\n    id = parseVariableIdentifier();\n    if (match('<')) {\n      typeParameters = parseTypeParameterDeclaration();\n    }\n    if (matchKeyword('extends')) {\n      expectKeyword('extends');\n      while (index < length) {\n        extended.push(parseInterfaceExtends());\n        if (!match(',')) {\n          break;\n        }\n        expect(',');\n      }\n    }\n    bodyMarker = markerCreate();\n    body = markerApply(bodyMarker, parseObjectType(allowStatic));\n    return markerApply(marker, delegate.createInterface(id, typeParameters, body, extended));\n  }\n  function parseInterface() {\n    var marker = markerCreate();\n    if (strict) {\n      expectKeyword('interface');\n    } else {\n      expectContextualKeyword('interface');\n    }\n    return parseInterfaceish(marker, /* allowStatic */false);\n  }\n  function parseDeclareClass() {\n    var marker = markerCreate(),\n      ret;\n    expectContextualKeyword('declare');\n    expectKeyword('class');\n    ret = parseInterfaceish(marker, /* allowStatic */true);\n    ret.type = Syntax.DeclareClass;\n    return ret;\n  }\n  function parseDeclareFunction() {\n    var id,\n      idMarker,\n      marker = markerCreate(),\n      params,\n      returnType,\n      rest,\n      tmp,\n      typeParameters = null,\n      value,\n      valueMarker;\n    expectContextualKeyword('declare');\n    expectKeyword('function');\n    idMarker = markerCreate();\n    id = parseVariableIdentifier();\n    valueMarker = markerCreate();\n    if (match('<')) {\n      typeParameters = parseTypeParameterDeclaration();\n    }\n    expect('(');\n    tmp = parseFunctionTypeParams();\n    params = tmp.params;\n    rest = tmp.rest;\n    expect(')');\n    expect(':');\n    returnType = parseType();\n    value = markerApply(valueMarker, delegate.createFunctionTypeAnnotation(params, returnType, rest, typeParameters));\n    id.typeAnnotation = markerApply(valueMarker, delegate.createTypeAnnotation(value));\n    markerApply(idMarker, id);\n    consumeSemicolon();\n    return markerApply(marker, delegate.createDeclareFunction(id));\n  }\n  function parseDeclareVariable() {\n    var id,\n      marker = markerCreate();\n    expectContextualKeyword('declare');\n    expectKeyword('var');\n    id = parseTypeAnnotatableIdentifier();\n    consumeSemicolon();\n    return markerApply(marker, delegate.createDeclareVariable(id));\n  }\n  function parseDeclareModule() {\n    var body = [],\n      bodyMarker,\n      id,\n      idMarker,\n      marker = markerCreate(),\n      token;\n    expectContextualKeyword('declare');\n    expectContextualKeyword('module');\n    if (lookahead.type === Token.StringLiteral) {\n      if (strict && lookahead.octal) {\n        throwErrorTolerant(lookahead, Messages.StrictOctalLiteral);\n      }\n      idMarker = markerCreate();\n      id = markerApply(idMarker, delegate.createLiteral(lex()));\n    } else {\n      id = parseVariableIdentifier();\n    }\n    bodyMarker = markerCreate();\n    expect('{');\n    while (index < length && !match('}')) {\n      token = lookahead2();\n      switch (token.value) {\n        case 'class':\n          body.push(parseDeclareClass());\n          break;\n        case 'function':\n          body.push(parseDeclareFunction());\n          break;\n        case 'var':\n          body.push(parseDeclareVariable());\n          break;\n        default:\n          throwUnexpected(lookahead);\n      }\n    }\n    expect('}');\n    return markerApply(marker, delegate.createDeclareModule(id, markerApply(bodyMarker, delegate.createBlockStatement(body))));\n  }\n  function collectToken() {\n    var loc, token, range, value, entry;\n\n    /* istanbul ignore else */\n    if (!state.inJSXChild) {\n      skipComment();\n    }\n    loc = {\n      start: {\n        line: lineNumber,\n        column: index - lineStart\n      }\n    };\n    token = extra.advance();\n    loc.end = {\n      line: lineNumber,\n      column: index - lineStart\n    };\n    if (token.type !== Token.EOF) {\n      range = [token.range[0], token.range[1]];\n      value = source.slice(token.range[0], token.range[1]);\n      entry = {\n        type: TokenName[token.type],\n        value: value,\n        range: range,\n        loc: loc\n      };\n      if (token.regex) {\n        entry.regex = {\n          pattern: token.regex.pattern,\n          flags: token.regex.flags\n        };\n      }\n      extra.tokens.push(entry);\n    }\n    return token;\n  }\n  function collectRegex() {\n    var pos, loc, regex, token;\n    skipComment();\n    pos = index;\n    loc = {\n      start: {\n        line: lineNumber,\n        column: index - lineStart\n      }\n    };\n    regex = extra.scanRegExp();\n    loc.end = {\n      line: lineNumber,\n      column: index - lineStart\n    };\n    if (!extra.tokenize) {\n      /* istanbul ignore next */\n      // Pop the previous token, which is likely '/' or '/='\n      if (extra.tokens.length > 0) {\n        token = extra.tokens[extra.tokens.length - 1];\n        if (token.range[0] === pos && token.type === 'Punctuator') {\n          if (token.value === '/' || token.value === '/=') {\n            extra.tokens.pop();\n          }\n        }\n      }\n      extra.tokens.push({\n        type: 'RegularExpression',\n        value: regex.literal,\n        regex: regex.regex,\n        range: [pos, index],\n        loc: loc\n      });\n    }\n    return regex;\n  }\n  function filterTokenLocation() {\n    var i,\n      entry,\n      token,\n      tokens = [];\n    for (i = 0; i < extra.tokens.length; ++i) {\n      entry = extra.tokens[i];\n      token = {\n        type: entry.type,\n        value: entry.value\n      };\n      if (entry.regex) {\n        token.regex = {\n          pattern: entry.regex.pattern,\n          flags: entry.regex.flags\n        };\n      }\n      if (extra.range) {\n        token.range = entry.range;\n      }\n      if (extra.loc) {\n        token.loc = entry.loc;\n      }\n      tokens.push(token);\n    }\n    extra.tokens = tokens;\n  }\n  function patch() {\n    if (typeof extra.tokens !== 'undefined') {\n      extra.advance = advance;\n      extra.scanRegExp = scanRegExp;\n      advance = collectToken;\n      scanRegExp = collectRegex;\n    }\n  }\n  function unpatch() {\n    if (typeof extra.scanRegExp === 'function') {\n      advance = extra.advance;\n      scanRegExp = extra.scanRegExp;\n    }\n  }\n\n  // This is used to modify the delegate.\n\n  function extend(object, properties) {\n    var entry,\n      result = {};\n    for (entry in object) {\n      /* istanbul ignore else */\n      if (object.hasOwnProperty(entry)) {\n        result[entry] = object[entry];\n      }\n    }\n    for (entry in properties) {\n      /* istanbul ignore else */\n      if (properties.hasOwnProperty(entry)) {\n        result[entry] = properties[entry];\n      }\n    }\n    return result;\n  }\n  function tokenize(code, options) {\n    var toString, token, tokens;\n    toString = String;\n    if (typeof code !== 'string' && !(code instanceof String)) {\n      code = toString(code);\n    }\n    delegate = SyntaxTreeDelegate;\n    source = code;\n    index = 0;\n    lineNumber = source.length > 0 ? 1 : 0;\n    lineStart = 0;\n    length = source.length;\n    lookahead = null;\n    state = {\n      allowKeyword: true,\n      allowIn: true,\n      labelSet: new StringMap(),\n      inFunctionBody: false,\n      inIteration: false,\n      inSwitch: false,\n      lastCommentStart: -1,\n      curlyStack: [],\n      curlyLastIndex: 0\n    };\n    extra = {};\n\n    // Options matching.\n    options = options || {};\n\n    // Of course we collect tokens here.\n    options.tokens = true;\n    extra.tokens = [];\n    extra.tokenize = true;\n    // The following two fields are necessary to compute the Regex tokens.\n    extra.openParenToken = -1;\n    extra.openCurlyToken = -1;\n    extra.range = typeof options.range === 'boolean' && options.range;\n    extra.loc = typeof options.loc === 'boolean' && options.loc;\n    if (typeof options.comment === 'boolean' && options.comment) {\n      extra.comments = [];\n    }\n    if (typeof options.tolerant === 'boolean' && options.tolerant) {\n      extra.errors = [];\n    }\n    patch();\n    try {\n      peek();\n      if (lookahead.type === Token.EOF) {\n        return extra.tokens;\n      }\n      token = lex();\n      while (lookahead.type !== Token.EOF) {\n        try {\n          token = lex();\n        } catch (lexError) {\n          token = lookahead;\n          if (extra.errors) {\n            extra.errors.push(lexError);\n            // We have to break on the first error\n            // to avoid infinite loops.\n            break;\n          } else {\n            throw lexError;\n          }\n        }\n      }\n      filterTokenLocation();\n      tokens = extra.tokens;\n      if (typeof extra.comments !== 'undefined') {\n        tokens.comments = extra.comments;\n      }\n      if (typeof extra.errors !== 'undefined') {\n        tokens.errors = extra.errors;\n      }\n    } catch (e) {\n      throw e;\n    } finally {\n      unpatch();\n      extra = {};\n    }\n    return tokens;\n  }\n  function parse(code, options) {\n    var program, toString;\n    toString = String;\n    if (typeof code !== 'string' && !(code instanceof String)) {\n      code = toString(code);\n    }\n    delegate = SyntaxTreeDelegate;\n    source = code;\n    index = 0;\n    lineNumber = source.length > 0 ? 1 : 0;\n    lineStart = 0;\n    length = source.length;\n    lookahead = null;\n    state = {\n      allowKeyword: false,\n      allowIn: true,\n      labelSet: new StringMap(),\n      parenthesizedCount: 0,\n      inFunctionBody: false,\n      inIteration: false,\n      inSwitch: false,\n      inJSXChild: false,\n      inJSXTag: false,\n      inType: false,\n      lastCommentStart: -1,\n      yieldAllowed: false,\n      awaitAllowed: false,\n      curlyPosition: 0,\n      curlyStack: [],\n      curlyLastIndex: 0\n    };\n    extra = {};\n    if (typeof options !== 'undefined') {\n      extra.range = typeof options.range === 'boolean' && options.range;\n      extra.loc = typeof options.loc === 'boolean' && options.loc;\n      extra.attachComment = typeof options.attachComment === 'boolean' && options.attachComment;\n      if (extra.loc && options.source !== null && options.source !== undefined) {\n        delegate = extend(delegate, {\n          'postProcess': function postProcess(node) {\n            node.loc.source = toString(options.source);\n            return node;\n          }\n        });\n      }\n      extra.sourceType = options.sourceType;\n      if (typeof options.tokens === 'boolean' && options.tokens) {\n        extra.tokens = [];\n      }\n      if (typeof options.comment === 'boolean' && options.comment) {\n        extra.comments = [];\n      }\n      if (typeof options.tolerant === 'boolean' && options.tolerant) {\n        extra.errors = [];\n      }\n      if (extra.attachComment) {\n        extra.range = true;\n        extra.comments = [];\n        extra.bottomRightStack = [];\n        extra.trailingComments = [];\n        extra.leadingComments = [];\n      }\n    }\n    patch();\n    try {\n      program = parseProgram();\n      if (typeof extra.comments !== 'undefined') {\n        program.comments = extra.comments;\n      }\n      if (typeof extra.tokens !== 'undefined') {\n        filterTokenLocation();\n        program.tokens = extra.tokens;\n      }\n      if (typeof extra.errors !== 'undefined') {\n        program.errors = extra.errors;\n      }\n    } catch (e) {\n      throw e;\n    } finally {\n      unpatch();\n      extra = {};\n    }\n    return program;\n  }\n\n  // Sync with *.json manifests.\n  exports.version = '15001.1.0-dev-harmony-fb';\n  exports.tokenize = tokenize;\n  exports.parse = parse;\n\n  // Deep copy.\n  /* istanbul ignore next */\n  exports.Syntax = function () {\n    var name,\n      types = {};\n    if (typeof Object.create === 'function') {\n      types = Object.create(null);\n    }\n    for (name in Syntax) {\n      if (Syntax.hasOwnProperty(name)) {\n        types[name] = Syntax[name];\n      }\n    }\n    if (typeof Object.freeze === 'function') {\n      Object.freeze(types);\n    }\n    return types;\n  }();\n});\n/* vim: set sw=4 ts=4 et tw=80 : */","map":{"version":3,"names":["root","factory","define","amd","exports","esprima","Token","TokenName","FnExprTokens","Syntax","PropertyKind","Messages","Regex","SyntaxTreeDelegate","XHTMLEntities","ClassPropertyType","source","strict","index","lineNumber","lineStart","length","delegate","lookahead","state","extra","BooleanLiteral","EOF","Identifier","Keyword","NullLiteral","NumericLiteral","Punctuator","StringLiteral","RegularExpression","Template","JSXIdentifier","JSXText","AnyTypeAnnotation","ArrayExpression","ArrayPattern","ArrayTypeAnnotation","ArrowFunctionExpression","AssignmentExpression","BinaryExpression","BlockStatement","BooleanTypeAnnotation","BreakStatement","CallExpression","CatchClause","ClassBody","ClassDeclaration","ClassExpression","ClassImplements","ClassProperty","ComprehensionBlock","ComprehensionExpression","ConditionalExpression","ContinueStatement","DebuggerStatement","DeclareClass","DeclareFunction","DeclareModule","DeclareVariable","DoWhileStatement","EmptyStatement","ExportDeclaration","ExportBatchSpecifier","ExportSpecifier","ExpressionStatement","ForInStatement","ForOfStatement","ForStatement","FunctionDeclaration","FunctionExpression","FunctionTypeAnnotation","FunctionTypeParam","GenericTypeAnnotation","IfStatement","ImportDeclaration","ImportDefaultSpecifier","ImportNamespaceSpecifier","ImportSpecifier","InterfaceDeclaration","InterfaceExtends","IntersectionTypeAnnotation","LabeledStatement","Literal","LogicalExpression","MemberExpression","MethodDefinition","NewExpression","NullableTypeAnnotation","NumberTypeAnnotation","ObjectExpression","ObjectPattern","ObjectTypeAnnotation","ObjectTypeCallProperty","ObjectTypeIndexer","ObjectTypeProperty","Program","Property","QualifiedTypeIdentifier","ReturnStatement","SequenceExpression","SpreadElement","SpreadProperty","StringLiteralTypeAnnotation","StringTypeAnnotation","SwitchCase","SwitchStatement","TaggedTemplateExpression","TemplateElement","TemplateLiteral","ThisExpression","ThrowStatement","TupleTypeAnnotation","TryStatement","TypeAlias","TypeAnnotation","TypeCastExpression","TypeofTypeAnnotation","TypeParameterDeclaration","TypeParameterInstantiation","UnaryExpression","UnionTypeAnnotation","UpdateExpression","VariableDeclaration","VariableDeclarator","VoidTypeAnnotation","WhileStatement","WithStatement","JSXNamespacedName","JSXMemberExpression","JSXEmptyExpression","JSXExpressionContainer","JSXElement","JSXClosingElement","JSXOpeningElement","JSXAttribute","JSXSpreadAttribute","YieldExpression","AwaitExpression","Data","Get","Set","prototype","UnexpectedToken","UnexpectedNumber","UnexpectedString","UnexpectedIdentifier","UnexpectedReserved","UnexpectedTemplate","UnexpectedEOS","NewlineAfterThrow","InvalidRegExp","UnterminatedRegExp","InvalidLHSInAssignment","InvalidLHSInFormalsList","InvalidLHSInForIn","MultipleDefaultsInSwitch","NoCatchOrFinally","UnknownLabel","Redeclaration","IllegalContinue","IllegalBreak","IllegalDuplicateClassProperty","IllegalClassConstructorProperty","IllegalReturn","IllegalSpread","StrictModeWith","StrictCatchVariable","StrictVarName","StrictParamName","StrictParamDupe","ParameterAfterRestParameter","DefaultRestParameter","ElementAfterSpreadElement","PropertyAfterSpreadProperty","ObjectPatternAsRestParameter","ObjectPatternAsSpread","StrictFunctionName","StrictOctalLiteral","StrictDelete","StrictDuplicateProperty","AccessorDataProperty","AccessorGetSet","StrictLHSAssignment","StrictLHSPostfix","StrictLHSPrefix","StrictReservedWord","MissingFromClause","NoAsAfterImportNamespace","InvalidModuleSpecifier","IllegalImportDeclaration","IllegalExportDeclaration","NoUninitializedConst","ComprehensionRequiresBlock","ComprehensionError","EachNotAllowed","InvalidJSXAttributeValue","ExpectedJSXClosingTag","AdjacentJSXElements","ConfusedAboutFunctionType","NonAsciiIdentifierStart","RegExp","NonAsciiIdentifierPart","LeadingZeros","assert","condition","message","Error","StringMap","$data","get","key","set","value","has","Object","hasOwnProperty","call","delete","isDecimalDigit","ch","isHexDigit","indexOf","isOctalDigit","isWhiteSpace","String","fromCharCode","isLineTerminator","isIdentifierStart","test","isIdentifierPart","isFutureReservedWord","id","isStrictModeReservedWord","isRestrictedWord","isKeyword","addComment","type","start","end","loc","comment","lastCommentStart","range","comments","push","attachComment","leadingComments","trailingComments","skipSingleLineComment","line","column","charCodeAt","slice","skipMultiLineComment","throwError","skipComment","scanHexEscape","prefix","i","len","code","toLowerCase","scanUnicodeCodePointEscape","cu1","cu2","getEscapedIdentifier","substr","getIdentifier","scanIdentifier","scanPunctuator","code2","ch1","ch2","ch3","ch4","inJSXTag","inJSXChild","tokenize","openParenToken","tokens","openCurlyToken","curlyLastIndex","curlyStack","pop","inType","scanHexLiteral","number","parseInt","scanBinaryLiteral","scanOctalLiteral","octal","scanNumericLiteral","parseFloat","scanStringLiteral","str","quote","unescaped","restore","scanTemplate","cooked","terminated","head","tail","raw","testRegExp","pattern","flags","tmp","replace","$0","$1","e","exception","scanRegExpBody","classMarker","body","literal","scanRegExpFlags","throwErrorTolerant","scanRegExp","regex","isIdentifierName","token","advanceSlash","prevToken","checkToken","advance","advanceJSXChild","scanJSXStringLiteral","isJSXIdentifierStart","scanJSXIdentifier","lex","peek","pos","lookahead2","adv","result","rewind","markerCreate","undefined","offset","col","markerCreatePreserveWhitespace","processComment","node","lastChild","bottomRight","bottomRightStack","last","markerApply","marker","postProcess","name","createArrayExpression","elements","createAssignmentExpression","operator","left","right","createBinaryExpression","createBlockStatement","createBreakStatement","label","createCallExpression","callee","args","createCatchClause","param","createConditionalExpression","consequent","alternate","createContinueStatement","createDebuggerStatement","createDoWhileStatement","createEmptyStatement","createExpressionStatement","expression","createForStatement","init","update","createForInStatement","each","createForOfStatement","createFunctionDeclaration","params","defaults","rest","generator","isAsync","returnType","typeParameters","funDecl","async","createFunctionExpression","funExpr","createIdentifier","typeAnnotation","optional","createTypeAnnotation","createTypeCast","createFunctionTypeAnnotation","createFunctionTypeParam","createNullableTypeAnnotation","createArrayTypeAnnotation","elementType","createGenericTypeAnnotation","createQualifiedTypeIdentifier","qualification","createTypeParameterDeclaration","createTypeParameterInstantiation","createAnyTypeAnnotation","createBooleanTypeAnnotation","createNumberTypeAnnotation","createStringTypeAnnotation","createStringLiteralTypeAnnotation","createVoidTypeAnnotation","createTypeofTypeAnnotation","argument","createTupleTypeAnnotation","types","createObjectTypeAnnotation","properties","indexers","callProperties","createObjectTypeIndexer","isStatic","static","createObjectTypeCallProperty","createObjectTypeProperty","createUnionTypeAnnotation","createIntersectionTypeAnnotation","createTypeAlias","createInterface","extended","extends","createInterfaceExtends","createDeclareFunction","createDeclareVariable","createDeclareModule","createJSXAttribute","createJSXSpreadAttribute","createJSXIdentifier","createJSXNamespacedName","namespace","createJSXMemberExpression","object","property","createJSXElement","openingElement","closingElement","children","createJSXEmptyExpression","createJSXExpressionContainer","createJSXOpeningElement","attributes","selfClosing","createJSXClosingElement","createIfStatement","createLabeledStatement","createLiteral","createMemberExpression","accessor","computed","createNewExpression","createObjectExpression","createPostfixExpression","createProgram","createProperty","kind","method","shorthand","createReturnStatement","createSequenceExpression","expressions","createSwitchCase","createSwitchStatement","discriminant","cases","createThisExpression","createThrowStatement","createTryStatement","block","guardedHandlers","handlers","finalizer","createUnaryExpression","createVariableDeclaration","declarations","createVariableDeclarator","createWhileStatement","createWithStatement","createTemplateElement","createTemplateLiteral","quasis","createSpreadElement","createSpreadProperty","createTaggedTemplateExpression","tag","quasi","createArrowFunctionExpression","arrowExpr","createMethodDefinition","propertyType","createClassProperty","createClassBody","createClassImplements","createClassExpression","superClass","superTypeParameters","implemented","implements","createClassDeclaration","createExportSpecifier","createExportBatchSpecifier","createImportDefaultSpecifier","createImportNamespaceSpecifier","createExportDeclaration","isDefault","declaration","specifiers","src","createImportSpecifier","createImportDeclaration","importKind","createYieldExpression","dlg","createAwaitExpression","createComprehensionExpression","filter","blocks","peekLineTerminator","found","messageFormat","error","Array","arguments","msg","whole","idx","description","apply","errors","throwUnexpected","expect","expectKeyword","keyword","contextual","expectContextualKeyword","match","matchKeyword","expectedType","matchContextualKeyword","matchAssign","op","matchYield","yieldAllowed","matchAsync","backtrackToken","matches","matchAwait","awaitAllowed","consumeSemicolon","oldIndex","oldLineNumber","oldLineStart","oldLookahead","isLeftHandSide","expr","isAssignableLeftHandSide","parseArrayInitialiser","possiblecomprehension","parseForStatement","ignoreBody","of","parseExpression","parseSpreadOrAssignmentExpression","parsePropertyFunction","options","previousStrict","previousYieldAllowed","previousAwaitAllowed","parseConciseBody","parsePropertyMethodFunction","parseParams","stricted","parseObjectPropertyKey","propertyKey","parseAssignmentExpression","parseObjectProperty","parseTypeParameterDeclaration","parseTypeAnnotation","parseTypeAnnotatableIdentifier","parseObjectSpreadProperty","getFieldName","toString","parseObjectInitialiser","storedKind","map","parseTemplateElement","option","parseTemplateLiteral","parseGroupExpression","parenthesizedCount","matchAsyncFuncExprOrDecl","parsePrimaryExpression","parseFunctionExpression","parseClassExpression","parseJSXElement","parseArguments","arg","parseNonComputedProperty","parseNonComputedMember","parseComputedMember","parseNewExpression","parseLeftHandSideExpression","parseLeftHandSideExpressionAllowCall","parsePostfixExpression","parseUnaryExpression","binaryPrecedence","allowIn","prec","parseBinaryExpression","previousAllowIn","stack","markers","parseConditionalExpression","reinterpretAsAssignmentBindingPattern","element","reinterpretAsDestructuredParameter","validateParam","reinterpretAsCoverFormalsList","defaultCount","paramSet","firstRestricted","parseArrowFunctionExpression","oldParenthesizedCount","startsWithParen","possiblyAsync","parseYieldExpression","parseAwaitExpression","sequence","spreadFound","possibleArrow","parseStatementList","list","statement","parseSourceElement","parseBlock","paramTypes","parseTypeParameterInstantiation","oldInType","parseType","parseObjectTypeIndexer","parseObjectTypeMethodish","parseFunctionTypeParam","parseObjectTypeMethod","parseObjectTypeCallProperty","valueMarker","parseObjectType","allowStatic","propertyTypeAnnotation","matchStatic","parseGenericType","typeIdentifier","parseVariableIdentifier","parseVoidType","parseTypeofType","parsePrimaryType","parseTupleType","parseFunctionTypeParams","ret","isGroupedType","parsePostfixType","t","parsePrefixType","parseIntersectionType","parseUnionType","requireTypeAnnotation","canBeOptionalParam","ident","isOptionalParam","parseVariableDeclaration","typeAnnotationMarker","allowKeyword","parseVariableDeclarationList","parseVariableStatement","parseConstLetDeclaration","parseModuleSpecifier","specifier","parseExportBatchSpecifier","parseExportSpecifier","parseExportDeclaration","possibleIdentifierToken","sourceElement","isExportFromIdentifier","parseImportSpecifier","parseNamedImports","parseImportDefaultSpecifier","parseImportNamespaceSpecifier","parseImportDeclaration","token2","concat","parseEmptyStatement","parseExpressionStatement","parseIfStatement","parseStatement","parseDoWhileStatement","oldInIteration","inIteration","parseWhileStatement","parseForVariableDeclaration","opts","parseContinueStatement","labelSet","parseBreakStatement","inSwitch","parseReturnStatement","inFunctionBody","parseWithStatement","parseSwitchCase","parseSwitchStatement","clause","oldInSwitch","defaultFound","parseThrowStatement","parseCatchClause","parseTryStatement","parseDebuggerStatement","labeledBody","parseFunctionDeclaration","parseClassDeclaration","parseFunctionSourceElements","sourceElements","directive","oldLabelSet","oldInFunctionBody","parseParam","def","delegateFlag","specialMethod","methodDefinition","parseMethodDefinition","propType","tokenValue","parseClassProperty","parseClassElement","possiblyOpenBracketToken","parseClassBody","classElement","classElements","existingProps","propName","parseClassImplements","matchImplements","parseInterface","parseTypeAlias","parseDeclareClass","parseDeclareFunction","parseDeclareVariable","parseDeclareModule","parseProgramElement","isModule","sourceType","parseProgramElements","parseProgram","quot","amp","apos","lt","gt","nbsp","iexcl","cent","pound","curren","yen","brvbar","sect","uml","copy","ordf","laquo","not","shy","reg","macr","deg","plusmn","sup2","sup3","acute","micro","para","middot","cedil","sup1","ordm","raquo","frac14","frac12","frac34","iquest","Agrave","Aacute","Acirc","Atilde","Auml","Aring","AElig","Ccedil","Egrave","Eacute","Ecirc","Euml","Igrave","Iacute","Icirc","Iuml","ETH","Ntilde","Ograve","Oacute","Ocirc","Otilde","Ouml","times","Oslash","Ugrave","Uacute","Ucirc","Uuml","Yacute","THORN","szlig","agrave","aacute","acirc","atilde","auml","aring","aelig","ccedil","egrave","eacute","ecirc","euml","igrave","iacute","icirc","iuml","eth","ntilde","ograve","oacute","ocirc","otilde","ouml","divide","oslash","ugrave","uacute","ucirc","uuml","yacute","thorn","yuml","OElig","oelig","Scaron","scaron","Yuml","fnof","circ","tilde","Alpha","Beta","Gamma","Delta","Epsilon","Zeta","Eta","Theta","Iota","Kappa","Lambda","Mu","Nu","Xi","Omicron","Pi","Rho","Sigma","Tau","Upsilon","Phi","Chi","Psi","Omega","alpha","beta","gamma","delta","epsilon","zeta","eta","theta","iota","kappa","lambda","mu","nu","xi","omicron","pi","rho","sigmaf","sigma","tau","upsilon","phi","chi","psi","omega","thetasym","upsih","piv","ensp","emsp","thinsp","zwnj","zwj","lrm","rlm","ndash","mdash","lsquo","rsquo","sbquo","ldquo","rdquo","bdquo","dagger","Dagger","bull","hellip","permil","prime","Prime","lsaquo","rsaquo","oline","frasl","euro","image","weierp","real","trade","alefsym","larr","uarr","rarr","darr","harr","crarr","lArr","uArr","rArr","dArr","hArr","forall","part","exist","empty","nabla","isin","notin","ni","prod","sum","minus","lowast","radic","prop","infin","ang","and","or","cap","cup","there4","sim","cong","asymp","ne","equiv","le","ge","sub","sup","nsub","sube","supe","oplus","otimes","perp","sdot","lceil","rceil","lfloor","rfloor","lang","rang","loz","spades","clubs","hearts","diams","getQualifiedJSXName","isJSXIdentifierPart","scanJSXEntity","count","isNaN","scanJSXText","stopChars","innerToken","parseJSXIdentifier","parseJSXNamespacedName","parseJSXMemberExpression","parseJSXElementName","parseJSXAttributeName","parseJSXAttributeValue","parseJSXExpressionContainer","parseJSXEmptyExpression","origInJSXChild","origInJSXTag","parseJSXSpreadAttribute","parseJSXAttribute","parseJSXChild","parseJSXClosingElement","parseJSXOpeningElement","parseInterfaceExtends","parseInterfaceish","bodyMarker","idMarker","collectToken","entry","collectRegex","filterTokenLocation","patch","unpatch","extend","tolerant","lexError","parse","program","curlyPosition","version","create","freeze"],"sources":["C:/d/Programming/web/jodel-mde/node_modules/jstransform/node_modules/esprima-fb/esprima.js"],"sourcesContent":["/*\n  Copyright (C) 2013 Ariya Hidayat <ariya.hidayat@gmail.com>\n  Copyright (C) 2013 Thaddee Tyl <thaddee.tyl@gmail.com>\n  Copyright (C) 2012 Ariya Hidayat <ariya.hidayat@gmail.com>\n  Copyright (C) 2012 Mathias Bynens <mathias@qiwi.be>\n  Copyright (C) 2012 Joost-Wim Boekesteijn <joost-wim@boekesteijn.nl>\n  Copyright (C) 2012 Kris Kowal <kris.kowal@cixar.com>\n  Copyright (C) 2012 Yusuke Suzuki <utatane.tea@gmail.com>\n  Copyright (C) 2012 Arpad Borsos <arpad.borsos@googlemail.com>\n  Copyright (C) 2011 Ariya Hidayat <ariya.hidayat@gmail.com>\n\n  Redistribution and use in source and binary forms, with or without\n  modification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n(function (root, factory) {\n    'use strict';\n\n    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js,\n    // Rhino, and plain browser loading.\n\n    /* istanbul ignore next */\n    if (typeof define === 'function' && define.amd) {\n        define(['exports'], factory);\n    } else if (typeof exports !== 'undefined') {\n        factory(exports);\n    } else {\n        factory((root.esprima = {}));\n    }\n}(this, function (exports) {\n    'use strict';\n\n    var Token,\n        TokenName,\n        FnExprTokens,\n        Syntax,\n        PropertyKind,\n        Messages,\n        Regex,\n        SyntaxTreeDelegate,\n        XHTMLEntities,\n        ClassPropertyType,\n        source,\n        strict,\n        index,\n        lineNumber,\n        lineStart,\n        length,\n        delegate,\n        lookahead,\n        state,\n        extra;\n\n    Token = {\n        BooleanLiteral: 1,\n        EOF: 2,\n        Identifier: 3,\n        Keyword: 4,\n        NullLiteral: 5,\n        NumericLiteral: 6,\n        Punctuator: 7,\n        StringLiteral: 8,\n        RegularExpression: 9,\n        Template: 10,\n        JSXIdentifier: 11,\n        JSXText: 12\n    };\n\n    TokenName = {};\n    TokenName[Token.BooleanLiteral] = 'Boolean';\n    TokenName[Token.EOF] = '<end>';\n    TokenName[Token.Identifier] = 'Identifier';\n    TokenName[Token.Keyword] = 'Keyword';\n    TokenName[Token.NullLiteral] = 'Null';\n    TokenName[Token.NumericLiteral] = 'Numeric';\n    TokenName[Token.Punctuator] = 'Punctuator';\n    TokenName[Token.StringLiteral] = 'String';\n    TokenName[Token.JSXIdentifier] = 'JSXIdentifier';\n    TokenName[Token.JSXText] = 'JSXText';\n    TokenName[Token.RegularExpression] = 'RegularExpression';\n    TokenName[Token.Template] = 'Template';\n\n    // A function following one of those tokens is an expression.\n    FnExprTokens = ['(', '{', '[', 'in', 'typeof', 'instanceof', 'new',\n                    'return', 'case', 'delete', 'throw', 'void',\n                    // assignment operators\n                    '=', '+=', '-=', '*=', '/=', '%=', '<<=', '>>=', '>>>=',\n                    '&=', '|=', '^=', ',',\n                    // binary/unary operators\n                    '+', '-', '*', '/', '%', '++', '--', '<<', '>>', '>>>', '&',\n                    '|', '^', '!', '~', '&&', '||', '?', ':', '===', '==', '>=',\n                    '<=', '<', '>', '!=', '!=='];\n\n    Syntax = {\n        AnyTypeAnnotation: 'AnyTypeAnnotation',\n        ArrayExpression: 'ArrayExpression',\n        ArrayPattern: 'ArrayPattern',\n        ArrayTypeAnnotation: 'ArrayTypeAnnotation',\n        ArrowFunctionExpression: 'ArrowFunctionExpression',\n        AssignmentExpression: 'AssignmentExpression',\n        BinaryExpression: 'BinaryExpression',\n        BlockStatement: 'BlockStatement',\n        BooleanTypeAnnotation: 'BooleanTypeAnnotation',\n        BreakStatement: 'BreakStatement',\n        CallExpression: 'CallExpression',\n        CatchClause: 'CatchClause',\n        ClassBody: 'ClassBody',\n        ClassDeclaration: 'ClassDeclaration',\n        ClassExpression: 'ClassExpression',\n        ClassImplements: 'ClassImplements',\n        ClassProperty: 'ClassProperty',\n        ComprehensionBlock: 'ComprehensionBlock',\n        ComprehensionExpression: 'ComprehensionExpression',\n        ConditionalExpression: 'ConditionalExpression',\n        ContinueStatement: 'ContinueStatement',\n        DebuggerStatement: 'DebuggerStatement',\n        DeclareClass: 'DeclareClass',\n        DeclareFunction: 'DeclareFunction',\n        DeclareModule: 'DeclareModule',\n        DeclareVariable: 'DeclareVariable',\n        DoWhileStatement: 'DoWhileStatement',\n        EmptyStatement: 'EmptyStatement',\n        ExportDeclaration: 'ExportDeclaration',\n        ExportBatchSpecifier: 'ExportBatchSpecifier',\n        ExportSpecifier: 'ExportSpecifier',\n        ExpressionStatement: 'ExpressionStatement',\n        ForInStatement: 'ForInStatement',\n        ForOfStatement: 'ForOfStatement',\n        ForStatement: 'ForStatement',\n        FunctionDeclaration: 'FunctionDeclaration',\n        FunctionExpression: 'FunctionExpression',\n        FunctionTypeAnnotation: 'FunctionTypeAnnotation',\n        FunctionTypeParam: 'FunctionTypeParam',\n        GenericTypeAnnotation: 'GenericTypeAnnotation',\n        Identifier: 'Identifier',\n        IfStatement: 'IfStatement',\n        ImportDeclaration: 'ImportDeclaration',\n        ImportDefaultSpecifier: 'ImportDefaultSpecifier',\n        ImportNamespaceSpecifier: 'ImportNamespaceSpecifier',\n        ImportSpecifier: 'ImportSpecifier',\n        InterfaceDeclaration: 'InterfaceDeclaration',\n        InterfaceExtends: 'InterfaceExtends',\n        IntersectionTypeAnnotation: 'IntersectionTypeAnnotation',\n        LabeledStatement: 'LabeledStatement',\n        Literal: 'Literal',\n        LogicalExpression: 'LogicalExpression',\n        MemberExpression: 'MemberExpression',\n        MethodDefinition: 'MethodDefinition',\n        NewExpression: 'NewExpression',\n        NullableTypeAnnotation: 'NullableTypeAnnotation',\n        NumberTypeAnnotation: 'NumberTypeAnnotation',\n        ObjectExpression: 'ObjectExpression',\n        ObjectPattern: 'ObjectPattern',\n        ObjectTypeAnnotation: 'ObjectTypeAnnotation',\n        ObjectTypeCallProperty: 'ObjectTypeCallProperty',\n        ObjectTypeIndexer: 'ObjectTypeIndexer',\n        ObjectTypeProperty: 'ObjectTypeProperty',\n        Program: 'Program',\n        Property: 'Property',\n        QualifiedTypeIdentifier: 'QualifiedTypeIdentifier',\n        ReturnStatement: 'ReturnStatement',\n        SequenceExpression: 'SequenceExpression',\n        SpreadElement: 'SpreadElement',\n        SpreadProperty: 'SpreadProperty',\n        StringLiteralTypeAnnotation: 'StringLiteralTypeAnnotation',\n        StringTypeAnnotation: 'StringTypeAnnotation',\n        SwitchCase: 'SwitchCase',\n        SwitchStatement: 'SwitchStatement',\n        TaggedTemplateExpression: 'TaggedTemplateExpression',\n        TemplateElement: 'TemplateElement',\n        TemplateLiteral: 'TemplateLiteral',\n        ThisExpression: 'ThisExpression',\n        ThrowStatement: 'ThrowStatement',\n        TupleTypeAnnotation: 'TupleTypeAnnotation',\n        TryStatement: 'TryStatement',\n        TypeAlias: 'TypeAlias',\n        TypeAnnotation: 'TypeAnnotation',\n        TypeCastExpression: 'TypeCastExpression',\n        TypeofTypeAnnotation: 'TypeofTypeAnnotation',\n        TypeParameterDeclaration: 'TypeParameterDeclaration',\n        TypeParameterInstantiation: 'TypeParameterInstantiation',\n        UnaryExpression: 'UnaryExpression',\n        UnionTypeAnnotation: 'UnionTypeAnnotation',\n        UpdateExpression: 'UpdateExpression',\n        VariableDeclaration: 'VariableDeclaration',\n        VariableDeclarator: 'VariableDeclarator',\n        VoidTypeAnnotation: 'VoidTypeAnnotation',\n        WhileStatement: 'WhileStatement',\n        WithStatement: 'WithStatement',\n        JSXIdentifier: 'JSXIdentifier',\n        JSXNamespacedName: 'JSXNamespacedName',\n        JSXMemberExpression: 'JSXMemberExpression',\n        JSXEmptyExpression: 'JSXEmptyExpression',\n        JSXExpressionContainer: 'JSXExpressionContainer',\n        JSXElement: 'JSXElement',\n        JSXClosingElement: 'JSXClosingElement',\n        JSXOpeningElement: 'JSXOpeningElement',\n        JSXAttribute: 'JSXAttribute',\n        JSXSpreadAttribute: 'JSXSpreadAttribute',\n        JSXText: 'JSXText',\n        YieldExpression: 'YieldExpression',\n        AwaitExpression: 'AwaitExpression'\n    };\n\n    PropertyKind = {\n        Data: 1,\n        Get: 2,\n        Set: 4\n    };\n\n    ClassPropertyType = {\n        'static': 'static',\n        prototype: 'prototype'\n    };\n\n    // Error messages should be identical to V8.\n    Messages = {\n        UnexpectedToken: 'Unexpected token %0',\n        UnexpectedNumber: 'Unexpected number',\n        UnexpectedString: 'Unexpected string',\n        UnexpectedIdentifier: 'Unexpected identifier',\n        UnexpectedReserved: 'Unexpected reserved word',\n        UnexpectedTemplate: 'Unexpected quasi %0',\n        UnexpectedEOS: 'Unexpected end of input',\n        NewlineAfterThrow: 'Illegal newline after throw',\n        InvalidRegExp: 'Invalid regular expression',\n        UnterminatedRegExp: 'Invalid regular expression: missing /',\n        InvalidLHSInAssignment: 'Invalid left-hand side in assignment',\n        InvalidLHSInFormalsList: 'Invalid left-hand side in formals list',\n        InvalidLHSInForIn: 'Invalid left-hand side in for-in',\n        MultipleDefaultsInSwitch: 'More than one default clause in switch statement',\n        NoCatchOrFinally: 'Missing catch or finally after try',\n        UnknownLabel: 'Undefined label \\'%0\\'',\n        Redeclaration: '%0 \\'%1\\' has already been declared',\n        IllegalContinue: 'Illegal continue statement',\n        IllegalBreak: 'Illegal break statement',\n        IllegalDuplicateClassProperty: 'Illegal duplicate property in class definition',\n        IllegalClassConstructorProperty: 'Illegal constructor property in class definition',\n        IllegalReturn: 'Illegal return statement',\n        IllegalSpread: 'Illegal spread element',\n        StrictModeWith: 'Strict mode code may not include a with statement',\n        StrictCatchVariable: 'Catch variable may not be eval or arguments in strict mode',\n        StrictVarName: 'Variable name may not be eval or arguments in strict mode',\n        StrictParamName: 'Parameter name eval or arguments is not allowed in strict mode',\n        StrictParamDupe: 'Strict mode function may not have duplicate parameter names',\n        ParameterAfterRestParameter: 'Rest parameter must be final parameter of an argument list',\n        DefaultRestParameter: 'Rest parameter can not have a default value',\n        ElementAfterSpreadElement: 'Spread must be the final element of an element list',\n        PropertyAfterSpreadProperty: 'A rest property must be the final property of an object literal',\n        ObjectPatternAsRestParameter: 'Invalid rest parameter',\n        ObjectPatternAsSpread: 'Invalid spread argument',\n        StrictFunctionName: 'Function name may not be eval or arguments in strict mode',\n        StrictOctalLiteral: 'Octal literals are not allowed in strict mode.',\n        StrictDelete: 'Delete of an unqualified identifier in strict mode.',\n        StrictDuplicateProperty: 'Duplicate data property in object literal not allowed in strict mode',\n        AccessorDataProperty: 'Object literal may not have data and accessor property with the same name',\n        AccessorGetSet: 'Object literal may not have multiple get/set accessors with the same name',\n        StrictLHSAssignment: 'Assignment to eval or arguments is not allowed in strict mode',\n        StrictLHSPostfix: 'Postfix increment/decrement may not have eval or arguments operand in strict mode',\n        StrictLHSPrefix: 'Prefix increment/decrement may not have eval or arguments operand in strict mode',\n        StrictReservedWord: 'Use of future reserved word in strict mode',\n        MissingFromClause: 'Missing from clause',\n        NoAsAfterImportNamespace: 'Missing as after import *',\n        InvalidModuleSpecifier: 'Invalid module specifier',\n        IllegalImportDeclaration: 'Illegal import declaration',\n        IllegalExportDeclaration: 'Illegal export declaration',\n        NoUninitializedConst: 'Const must be initialized',\n        ComprehensionRequiresBlock: 'Comprehension must have at least one block',\n        ComprehensionError: 'Comprehension Error',\n        EachNotAllowed: 'Each is not supported',\n        InvalidJSXAttributeValue: 'JSX value should be either an expression or a quoted JSX text',\n        ExpectedJSXClosingTag: 'Expected corresponding JSX closing tag for %0',\n        AdjacentJSXElements: 'Adjacent JSX elements must be wrapped in an enclosing tag',\n        ConfusedAboutFunctionType: 'Unexpected token =>. It looks like ' +\n            'you are trying to write a function type, but you ended up ' +\n            'writing a grouped type followed by an =>, which is a syntax ' +\n            'error. Remember, function type parameters are named so function ' +\n            'types look like (name1: type1, name2: type2) => returnType. You ' +\n            'probably wrote (type1) => returnType'\n    };\n\n    // See also tools/generate-unicode-regex.py.\n    Regex = {\n        NonAsciiIdentifierStart: new RegExp('[\\xaa\\xb5\\xba\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02c1\\u02c6-\\u02d1\\u02e0-\\u02e4\\u02ec\\u02ee\\u0370-\\u0374\\u0376\\u0377\\u037a-\\u037d\\u0386\\u0388-\\u038a\\u038c\\u038e-\\u03a1\\u03a3-\\u03f5\\u03f7-\\u0481\\u048a-\\u0527\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05d0-\\u05ea\\u05f0-\\u05f2\\u0620-\\u064a\\u066e\\u066f\\u0671-\\u06d3\\u06d5\\u06e5\\u06e6\\u06ee\\u06ef\\u06fa-\\u06fc\\u06ff\\u0710\\u0712-\\u072f\\u074d-\\u07a5\\u07b1\\u07ca-\\u07ea\\u07f4\\u07f5\\u07fa\\u0800-\\u0815\\u081a\\u0824\\u0828\\u0840-\\u0858\\u08a0\\u08a2-\\u08ac\\u0904-\\u0939\\u093d\\u0950\\u0958-\\u0961\\u0971-\\u0977\\u0979-\\u097f\\u0985-\\u098c\\u098f\\u0990\\u0993-\\u09a8\\u09aa-\\u09b0\\u09b2\\u09b6-\\u09b9\\u09bd\\u09ce\\u09dc\\u09dd\\u09df-\\u09e1\\u09f0\\u09f1\\u0a05-\\u0a0a\\u0a0f\\u0a10\\u0a13-\\u0a28\\u0a2a-\\u0a30\\u0a32\\u0a33\\u0a35\\u0a36\\u0a38\\u0a39\\u0a59-\\u0a5c\\u0a5e\\u0a72-\\u0a74\\u0a85-\\u0a8d\\u0a8f-\\u0a91\\u0a93-\\u0aa8\\u0aaa-\\u0ab0\\u0ab2\\u0ab3\\u0ab5-\\u0ab9\\u0abd\\u0ad0\\u0ae0\\u0ae1\\u0b05-\\u0b0c\\u0b0f\\u0b10\\u0b13-\\u0b28\\u0b2a-\\u0b30\\u0b32\\u0b33\\u0b35-\\u0b39\\u0b3d\\u0b5c\\u0b5d\\u0b5f-\\u0b61\\u0b71\\u0b83\\u0b85-\\u0b8a\\u0b8e-\\u0b90\\u0b92-\\u0b95\\u0b99\\u0b9a\\u0b9c\\u0b9e\\u0b9f\\u0ba3\\u0ba4\\u0ba8-\\u0baa\\u0bae-\\u0bb9\\u0bd0\\u0c05-\\u0c0c\\u0c0e-\\u0c10\\u0c12-\\u0c28\\u0c2a-\\u0c33\\u0c35-\\u0c39\\u0c3d\\u0c58\\u0c59\\u0c60\\u0c61\\u0c85-\\u0c8c\\u0c8e-\\u0c90\\u0c92-\\u0ca8\\u0caa-\\u0cb3\\u0cb5-\\u0cb9\\u0cbd\\u0cde\\u0ce0\\u0ce1\\u0cf1\\u0cf2\\u0d05-\\u0d0c\\u0d0e-\\u0d10\\u0d12-\\u0d3a\\u0d3d\\u0d4e\\u0d60\\u0d61\\u0d7a-\\u0d7f\\u0d85-\\u0d96\\u0d9a-\\u0db1\\u0db3-\\u0dbb\\u0dbd\\u0dc0-\\u0dc6\\u0e01-\\u0e30\\u0e32\\u0e33\\u0e40-\\u0e46\\u0e81\\u0e82\\u0e84\\u0e87\\u0e88\\u0e8a\\u0e8d\\u0e94-\\u0e97\\u0e99-\\u0e9f\\u0ea1-\\u0ea3\\u0ea5\\u0ea7\\u0eaa\\u0eab\\u0ead-\\u0eb0\\u0eb2\\u0eb3\\u0ebd\\u0ec0-\\u0ec4\\u0ec6\\u0edc-\\u0edf\\u0f00\\u0f40-\\u0f47\\u0f49-\\u0f6c\\u0f88-\\u0f8c\\u1000-\\u102a\\u103f\\u1050-\\u1055\\u105a-\\u105d\\u1061\\u1065\\u1066\\u106e-\\u1070\\u1075-\\u1081\\u108e\\u10a0-\\u10c5\\u10c7\\u10cd\\u10d0-\\u10fa\\u10fc-\\u1248\\u124a-\\u124d\\u1250-\\u1256\\u1258\\u125a-\\u125d\\u1260-\\u1288\\u128a-\\u128d\\u1290-\\u12b0\\u12b2-\\u12b5\\u12b8-\\u12be\\u12c0\\u12c2-\\u12c5\\u12c8-\\u12d6\\u12d8-\\u1310\\u1312-\\u1315\\u1318-\\u135a\\u1380-\\u138f\\u13a0-\\u13f4\\u1401-\\u166c\\u166f-\\u167f\\u1681-\\u169a\\u16a0-\\u16ea\\u16ee-\\u16f0\\u1700-\\u170c\\u170e-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176c\\u176e-\\u1770\\u1780-\\u17b3\\u17d7\\u17dc\\u1820-\\u1877\\u1880-\\u18a8\\u18aa\\u18b0-\\u18f5\\u1900-\\u191c\\u1950-\\u196d\\u1970-\\u1974\\u1980-\\u19ab\\u19c1-\\u19c7\\u1a00-\\u1a16\\u1a20-\\u1a54\\u1aa7\\u1b05-\\u1b33\\u1b45-\\u1b4b\\u1b83-\\u1ba0\\u1bae\\u1baf\\u1bba-\\u1be5\\u1c00-\\u1c23\\u1c4d-\\u1c4f\\u1c5a-\\u1c7d\\u1ce9-\\u1cec\\u1cee-\\u1cf1\\u1cf5\\u1cf6\\u1d00-\\u1dbf\\u1e00-\\u1f15\\u1f18-\\u1f1d\\u1f20-\\u1f45\\u1f48-\\u1f4d\\u1f50-\\u1f57\\u1f59\\u1f5b\\u1f5d\\u1f5f-\\u1f7d\\u1f80-\\u1fb4\\u1fb6-\\u1fbc\\u1fbe\\u1fc2-\\u1fc4\\u1fc6-\\u1fcc\\u1fd0-\\u1fd3\\u1fd6-\\u1fdb\\u1fe0-\\u1fec\\u1ff2-\\u1ff4\\u1ff6-\\u1ffc\\u2071\\u207f\\u2090-\\u209c\\u2102\\u2107\\u210a-\\u2113\\u2115\\u2119-\\u211d\\u2124\\u2126\\u2128\\u212a-\\u212d\\u212f-\\u2139\\u213c-\\u213f\\u2145-\\u2149\\u214e\\u2160-\\u2188\\u2c00-\\u2c2e\\u2c30-\\u2c5e\\u2c60-\\u2ce4\\u2ceb-\\u2cee\\u2cf2\\u2cf3\\u2d00-\\u2d25\\u2d27\\u2d2d\\u2d30-\\u2d67\\u2d6f\\u2d80-\\u2d96\\u2da0-\\u2da6\\u2da8-\\u2dae\\u2db0-\\u2db6\\u2db8-\\u2dbe\\u2dc0-\\u2dc6\\u2dc8-\\u2dce\\u2dd0-\\u2dd6\\u2dd8-\\u2dde\\u2e2f\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303c\\u3041-\\u3096\\u309d-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312d\\u3131-\\u318e\\u31a0-\\u31ba\\u31f0-\\u31ff\\u3400-\\u4db5\\u4e00-\\u9fcc\\ua000-\\ua48c\\ua4d0-\\ua4fd\\ua500-\\ua60c\\ua610-\\ua61f\\ua62a\\ua62b\\ua640-\\ua66e\\ua67f-\\ua697\\ua6a0-\\ua6ef\\ua717-\\ua71f\\ua722-\\ua788\\ua78b-\\ua78e\\ua790-\\ua793\\ua7a0-\\ua7aa\\ua7f8-\\ua801\\ua803-\\ua805\\ua807-\\ua80a\\ua80c-\\ua822\\ua840-\\ua873\\ua882-\\ua8b3\\ua8f2-\\ua8f7\\ua8fb\\ua90a-\\ua925\\ua930-\\ua946\\ua960-\\ua97c\\ua984-\\ua9b2\\ua9cf\\uaa00-\\uaa28\\uaa40-\\uaa42\\uaa44-\\uaa4b\\uaa60-\\uaa76\\uaa7a\\uaa80-\\uaaaf\\uaab1\\uaab5\\uaab6\\uaab9-\\uaabd\\uaac0\\uaac2\\uaadb-\\uaadd\\uaae0-\\uaaea\\uaaf2-\\uaaf4\\uab01-\\uab06\\uab09-\\uab0e\\uab11-\\uab16\\uab20-\\uab26\\uab28-\\uab2e\\uabc0-\\uabe2\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufb00-\\ufb06\\ufb13-\\ufb17\\ufb1d\\ufb1f-\\ufb28\\ufb2a-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40\\ufb41\\ufb43\\ufb44\\ufb46-\\ufbb1\\ufbd3-\\ufd3d\\ufd50-\\ufd8f\\ufd92-\\ufdc7\\ufdf0-\\ufdfb\\ufe70-\\ufe74\\ufe76-\\ufefc\\uff21-\\uff3a\\uff41-\\uff5a\\uff66-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc]'),\n        NonAsciiIdentifierPart: new RegExp('[\\xaa\\xb5\\xba\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02c1\\u02c6-\\u02d1\\u02e0-\\u02e4\\u02ec\\u02ee\\u0300-\\u0374\\u0376\\u0377\\u037a-\\u037d\\u0386\\u0388-\\u038a\\u038c\\u038e-\\u03a1\\u03a3-\\u03f5\\u03f7-\\u0481\\u0483-\\u0487\\u048a-\\u0527\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u05d0-\\u05ea\\u05f0-\\u05f2\\u0610-\\u061a\\u0620-\\u0669\\u066e-\\u06d3\\u06d5-\\u06dc\\u06df-\\u06e8\\u06ea-\\u06fc\\u06ff\\u0710-\\u074a\\u074d-\\u07b1\\u07c0-\\u07f5\\u07fa\\u0800-\\u082d\\u0840-\\u085b\\u08a0\\u08a2-\\u08ac\\u08e4-\\u08fe\\u0900-\\u0963\\u0966-\\u096f\\u0971-\\u0977\\u0979-\\u097f\\u0981-\\u0983\\u0985-\\u098c\\u098f\\u0990\\u0993-\\u09a8\\u09aa-\\u09b0\\u09b2\\u09b6-\\u09b9\\u09bc-\\u09c4\\u09c7\\u09c8\\u09cb-\\u09ce\\u09d7\\u09dc\\u09dd\\u09df-\\u09e3\\u09e6-\\u09f1\\u0a01-\\u0a03\\u0a05-\\u0a0a\\u0a0f\\u0a10\\u0a13-\\u0a28\\u0a2a-\\u0a30\\u0a32\\u0a33\\u0a35\\u0a36\\u0a38\\u0a39\\u0a3c\\u0a3e-\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a59-\\u0a5c\\u0a5e\\u0a66-\\u0a75\\u0a81-\\u0a83\\u0a85-\\u0a8d\\u0a8f-\\u0a91\\u0a93-\\u0aa8\\u0aaa-\\u0ab0\\u0ab2\\u0ab3\\u0ab5-\\u0ab9\\u0abc-\\u0ac5\\u0ac7-\\u0ac9\\u0acb-\\u0acd\\u0ad0\\u0ae0-\\u0ae3\\u0ae6-\\u0aef\\u0b01-\\u0b03\\u0b05-\\u0b0c\\u0b0f\\u0b10\\u0b13-\\u0b28\\u0b2a-\\u0b30\\u0b32\\u0b33\\u0b35-\\u0b39\\u0b3c-\\u0b44\\u0b47\\u0b48\\u0b4b-\\u0b4d\\u0b56\\u0b57\\u0b5c\\u0b5d\\u0b5f-\\u0b63\\u0b66-\\u0b6f\\u0b71\\u0b82\\u0b83\\u0b85-\\u0b8a\\u0b8e-\\u0b90\\u0b92-\\u0b95\\u0b99\\u0b9a\\u0b9c\\u0b9e\\u0b9f\\u0ba3\\u0ba4\\u0ba8-\\u0baa\\u0bae-\\u0bb9\\u0bbe-\\u0bc2\\u0bc6-\\u0bc8\\u0bca-\\u0bcd\\u0bd0\\u0bd7\\u0be6-\\u0bef\\u0c01-\\u0c03\\u0c05-\\u0c0c\\u0c0e-\\u0c10\\u0c12-\\u0c28\\u0c2a-\\u0c33\\u0c35-\\u0c39\\u0c3d-\\u0c44\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c58\\u0c59\\u0c60-\\u0c63\\u0c66-\\u0c6f\\u0c82\\u0c83\\u0c85-\\u0c8c\\u0c8e-\\u0c90\\u0c92-\\u0ca8\\u0caa-\\u0cb3\\u0cb5-\\u0cb9\\u0cbc-\\u0cc4\\u0cc6-\\u0cc8\\u0cca-\\u0ccd\\u0cd5\\u0cd6\\u0cde\\u0ce0-\\u0ce3\\u0ce6-\\u0cef\\u0cf1\\u0cf2\\u0d02\\u0d03\\u0d05-\\u0d0c\\u0d0e-\\u0d10\\u0d12-\\u0d3a\\u0d3d-\\u0d44\\u0d46-\\u0d48\\u0d4a-\\u0d4e\\u0d57\\u0d60-\\u0d63\\u0d66-\\u0d6f\\u0d7a-\\u0d7f\\u0d82\\u0d83\\u0d85-\\u0d96\\u0d9a-\\u0db1\\u0db3-\\u0dbb\\u0dbd\\u0dc0-\\u0dc6\\u0dca\\u0dcf-\\u0dd4\\u0dd6\\u0dd8-\\u0ddf\\u0df2\\u0df3\\u0e01-\\u0e3a\\u0e40-\\u0e4e\\u0e50-\\u0e59\\u0e81\\u0e82\\u0e84\\u0e87\\u0e88\\u0e8a\\u0e8d\\u0e94-\\u0e97\\u0e99-\\u0e9f\\u0ea1-\\u0ea3\\u0ea5\\u0ea7\\u0eaa\\u0eab\\u0ead-\\u0eb9\\u0ebb-\\u0ebd\\u0ec0-\\u0ec4\\u0ec6\\u0ec8-\\u0ecd\\u0ed0-\\u0ed9\\u0edc-\\u0edf\\u0f00\\u0f18\\u0f19\\u0f20-\\u0f29\\u0f35\\u0f37\\u0f39\\u0f3e-\\u0f47\\u0f49-\\u0f6c\\u0f71-\\u0f84\\u0f86-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u1000-\\u1049\\u1050-\\u109d\\u10a0-\\u10c5\\u10c7\\u10cd\\u10d0-\\u10fa\\u10fc-\\u1248\\u124a-\\u124d\\u1250-\\u1256\\u1258\\u125a-\\u125d\\u1260-\\u1288\\u128a-\\u128d\\u1290-\\u12b0\\u12b2-\\u12b5\\u12b8-\\u12be\\u12c0\\u12c2-\\u12c5\\u12c8-\\u12d6\\u12d8-\\u1310\\u1312-\\u1315\\u1318-\\u135a\\u135d-\\u135f\\u1380-\\u138f\\u13a0-\\u13f4\\u1401-\\u166c\\u166f-\\u167f\\u1681-\\u169a\\u16a0-\\u16ea\\u16ee-\\u16f0\\u1700-\\u170c\\u170e-\\u1714\\u1720-\\u1734\\u1740-\\u1753\\u1760-\\u176c\\u176e-\\u1770\\u1772\\u1773\\u1780-\\u17d3\\u17d7\\u17dc\\u17dd\\u17e0-\\u17e9\\u180b-\\u180d\\u1810-\\u1819\\u1820-\\u1877\\u1880-\\u18aa\\u18b0-\\u18f5\\u1900-\\u191c\\u1920-\\u192b\\u1930-\\u193b\\u1946-\\u196d\\u1970-\\u1974\\u1980-\\u19ab\\u19b0-\\u19c9\\u19d0-\\u19d9\\u1a00-\\u1a1b\\u1a20-\\u1a5e\\u1a60-\\u1a7c\\u1a7f-\\u1a89\\u1a90-\\u1a99\\u1aa7\\u1b00-\\u1b4b\\u1b50-\\u1b59\\u1b6b-\\u1b73\\u1b80-\\u1bf3\\u1c00-\\u1c37\\u1c40-\\u1c49\\u1c4d-\\u1c7d\\u1cd0-\\u1cd2\\u1cd4-\\u1cf6\\u1d00-\\u1de6\\u1dfc-\\u1f15\\u1f18-\\u1f1d\\u1f20-\\u1f45\\u1f48-\\u1f4d\\u1f50-\\u1f57\\u1f59\\u1f5b\\u1f5d\\u1f5f-\\u1f7d\\u1f80-\\u1fb4\\u1fb6-\\u1fbc\\u1fbe\\u1fc2-\\u1fc4\\u1fc6-\\u1fcc\\u1fd0-\\u1fd3\\u1fd6-\\u1fdb\\u1fe0-\\u1fec\\u1ff2-\\u1ff4\\u1ff6-\\u1ffc\\u200c\\u200d\\u203f\\u2040\\u2054\\u2071\\u207f\\u2090-\\u209c\\u20d0-\\u20dc\\u20e1\\u20e5-\\u20f0\\u2102\\u2107\\u210a-\\u2113\\u2115\\u2119-\\u211d\\u2124\\u2126\\u2128\\u212a-\\u212d\\u212f-\\u2139\\u213c-\\u213f\\u2145-\\u2149\\u214e\\u2160-\\u2188\\u2c00-\\u2c2e\\u2c30-\\u2c5e\\u2c60-\\u2ce4\\u2ceb-\\u2cf3\\u2d00-\\u2d25\\u2d27\\u2d2d\\u2d30-\\u2d67\\u2d6f\\u2d7f-\\u2d96\\u2da0-\\u2da6\\u2da8-\\u2dae\\u2db0-\\u2db6\\u2db8-\\u2dbe\\u2dc0-\\u2dc6\\u2dc8-\\u2dce\\u2dd0-\\u2dd6\\u2dd8-\\u2dde\\u2de0-\\u2dff\\u2e2f\\u3005-\\u3007\\u3021-\\u302f\\u3031-\\u3035\\u3038-\\u303c\\u3041-\\u3096\\u3099\\u309a\\u309d-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312d\\u3131-\\u318e\\u31a0-\\u31ba\\u31f0-\\u31ff\\u3400-\\u4db5\\u4e00-\\u9fcc\\ua000-\\ua48c\\ua4d0-\\ua4fd\\ua500-\\ua60c\\ua610-\\ua62b\\ua640-\\ua66f\\ua674-\\ua67d\\ua67f-\\ua697\\ua69f-\\ua6f1\\ua717-\\ua71f\\ua722-\\ua788\\ua78b-\\ua78e\\ua790-\\ua793\\ua7a0-\\ua7aa\\ua7f8-\\ua827\\ua840-\\ua873\\ua880-\\ua8c4\\ua8d0-\\ua8d9\\ua8e0-\\ua8f7\\ua8fb\\ua900-\\ua92d\\ua930-\\ua953\\ua960-\\ua97c\\ua980-\\ua9c0\\ua9cf-\\ua9d9\\uaa00-\\uaa36\\uaa40-\\uaa4d\\uaa50-\\uaa59\\uaa60-\\uaa76\\uaa7a\\uaa7b\\uaa80-\\uaac2\\uaadb-\\uaadd\\uaae0-\\uaaef\\uaaf2-\\uaaf6\\uab01-\\uab06\\uab09-\\uab0e\\uab11-\\uab16\\uab20-\\uab26\\uab28-\\uab2e\\uabc0-\\uabea\\uabec\\uabed\\uabf0-\\uabf9\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufb00-\\ufb06\\ufb13-\\ufb17\\ufb1d-\\ufb28\\ufb2a-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40\\ufb41\\ufb43\\ufb44\\ufb46-\\ufbb1\\ufbd3-\\ufd3d\\ufd50-\\ufd8f\\ufd92-\\ufdc7\\ufdf0-\\ufdfb\\ufe00-\\ufe0f\\ufe20-\\ufe26\\ufe33\\ufe34\\ufe4d-\\ufe4f\\ufe70-\\ufe74\\ufe76-\\ufefc\\uff10-\\uff19\\uff21-\\uff3a\\uff3f\\uff41-\\uff5a\\uff66-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc]'),\n        LeadingZeros: new RegExp('^0+(?!$)')\n    };\n\n    // Ensure the condition is true, otherwise throw an error.\n    // This is only to have a better contract semantic, i.e. another safety net\n    // to catch a logic error. The condition shall be fulfilled in normal case.\n    // Do NOT use this to enforce a certain condition on any user input.\n\n    function assert(condition, message) {\n        /* istanbul ignore if */\n        if (!condition) {\n            throw new Error('ASSERT: ' + message);\n        }\n    }\n\n    function StringMap() {\n        this.$data = {};\n    }\n\n    StringMap.prototype.get = function (key) {\n        key = '$' + key;\n        return this.$data[key];\n    };\n\n    StringMap.prototype.set = function (key, value) {\n        key = '$' + key;\n        this.$data[key] = value;\n        return this;\n    };\n\n    StringMap.prototype.has = function (key) {\n        key = '$' + key;\n        return Object.prototype.hasOwnProperty.call(this.$data, key);\n    };\n\n    StringMap.prototype.delete = function (key) {\n        key = '$' + key;\n        return delete this.$data[key];\n    };\n\n    function isDecimalDigit(ch) {\n        return (ch >= 48 && ch <= 57);   // 0..9\n    }\n\n    function isHexDigit(ch) {\n        return '0123456789abcdefABCDEF'.indexOf(ch) >= 0;\n    }\n\n    function isOctalDigit(ch) {\n        return '01234567'.indexOf(ch) >= 0;\n    }\n\n\n    // 7.2 White Space\n\n    function isWhiteSpace(ch) {\n        return (ch === 32) ||  // space\n            (ch === 9) ||      // tab\n            (ch === 0xB) ||\n            (ch === 0xC) ||\n            (ch === 0xA0) ||\n            (ch >= 0x1680 && '\\u1680\\u180E\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u3000\\uFEFF'.indexOf(String.fromCharCode(ch)) > 0);\n    }\n\n    // 7.3 Line Terminators\n\n    function isLineTerminator(ch) {\n        return (ch === 10) || (ch === 13) || (ch === 0x2028) || (ch === 0x2029);\n    }\n\n    // 7.6 Identifier Names and Identifiers\n\n    function isIdentifierStart(ch) {\n        return (ch === 36) || (ch === 95) ||  // $ (dollar) and _ (underscore)\n            (ch >= 65 && ch <= 90) ||         // A..Z\n            (ch >= 97 && ch <= 122) ||        // a..z\n            (ch === 92) ||                    // \\ (backslash)\n            ((ch >= 0x80) && Regex.NonAsciiIdentifierStart.test(String.fromCharCode(ch)));\n    }\n\n    function isIdentifierPart(ch) {\n        return (ch === 36) || (ch === 95) ||  // $ (dollar) and _ (underscore)\n            (ch >= 65 && ch <= 90) ||         // A..Z\n            (ch >= 97 && ch <= 122) ||        // a..z\n            (ch >= 48 && ch <= 57) ||         // 0..9\n            (ch === 92) ||                    // \\ (backslash)\n            ((ch >= 0x80) && Regex.NonAsciiIdentifierPart.test(String.fromCharCode(ch)));\n    }\n\n    // 7.6.1.2 Future Reserved Words\n\n    function isFutureReservedWord(id) {\n        switch (id) {\n        case 'class':\n        case 'enum':\n        case 'export':\n        case 'extends':\n        case 'import':\n        case 'super':\n            return true;\n        default:\n            return false;\n        }\n    }\n\n    function isStrictModeReservedWord(id) {\n        switch (id) {\n        case 'implements':\n        case 'interface':\n        case 'package':\n        case 'private':\n        case 'protected':\n        case 'public':\n        case 'static':\n        case 'yield':\n        case 'let':\n            return true;\n        default:\n            return false;\n        }\n    }\n\n    function isRestrictedWord(id) {\n        return id === 'eval' || id === 'arguments';\n    }\n\n    // 7.6.1.1 Keywords\n\n    function isKeyword(id) {\n        if (strict && isStrictModeReservedWord(id)) {\n            return true;\n        }\n\n        // 'const' is specialized as Keyword in V8.\n        // 'yield' is only treated as a keyword in strict mode.\n        // 'let' is for compatiblity with SpiderMonkey and ES.next.\n        // Some others are from future reserved words.\n\n        switch (id.length) {\n        case 2:\n            return (id === 'if') || (id === 'in') || (id === 'do');\n        case 3:\n            return (id === 'var') || (id === 'for') || (id === 'new') ||\n                (id === 'try') || (id === 'let');\n        case 4:\n            return (id === 'this') || (id === 'else') || (id === 'case') ||\n                (id === 'void') || (id === 'with') || (id === 'enum');\n        case 5:\n            return (id === 'while') || (id === 'break') || (id === 'catch') ||\n                (id === 'throw') || (id === 'const') ||\n                (id === 'class') || (id === 'super');\n        case 6:\n            return (id === 'return') || (id === 'typeof') || (id === 'delete') ||\n                (id === 'switch') || (id === 'export') || (id === 'import');\n        case 7:\n            return (id === 'default') || (id === 'finally') || (id === 'extends');\n        case 8:\n            return (id === 'function') || (id === 'continue') || (id === 'debugger');\n        case 10:\n            return (id === 'instanceof');\n        default:\n            return false;\n        }\n    }\n\n    // 7.4 Comments\n\n    function addComment(type, value, start, end, loc) {\n        var comment;\n        assert(typeof start === 'number', 'Comment must have valid position');\n\n        // Because the way the actual token is scanned, often the comments\n        // (if any) are skipped twice during the lexical analysis.\n        // Thus, we need to skip adding a comment if the comment array already\n        // handled it.\n        if (state.lastCommentStart >= start) {\n            return;\n        }\n        state.lastCommentStart = start;\n\n        comment = {\n            type: type,\n            value: value\n        };\n        if (extra.range) {\n            comment.range = [start, end];\n        }\n        if (extra.loc) {\n            comment.loc = loc;\n        }\n        extra.comments.push(comment);\n        if (extra.attachComment) {\n            extra.leadingComments.push(comment);\n            extra.trailingComments.push(comment);\n        }\n    }\n\n    function skipSingleLineComment() {\n        var start, loc, ch, comment;\n\n        start = index - 2;\n        loc = {\n            start: {\n                line: lineNumber,\n                column: index - lineStart - 2\n            }\n        };\n\n        while (index < length) {\n            ch = source.charCodeAt(index);\n            ++index;\n            if (isLineTerminator(ch)) {\n                if (extra.comments) {\n                    comment = source.slice(start + 2, index - 1);\n                    loc.end = {\n                        line: lineNumber,\n                        column: index - lineStart - 1\n                    };\n                    addComment('Line', comment, start, index - 1, loc);\n                }\n                if (ch === 13 && source.charCodeAt(index) === 10) {\n                    ++index;\n                }\n                ++lineNumber;\n                lineStart = index;\n                return;\n            }\n        }\n\n        if (extra.comments) {\n            comment = source.slice(start + 2, index);\n            loc.end = {\n                line: lineNumber,\n                column: index - lineStart\n            };\n            addComment('Line', comment, start, index, loc);\n        }\n    }\n\n    function skipMultiLineComment() {\n        var start, loc, ch, comment;\n\n        if (extra.comments) {\n            start = index - 2;\n            loc = {\n                start: {\n                    line: lineNumber,\n                    column: index - lineStart - 2\n                }\n            };\n        }\n\n        while (index < length) {\n            ch = source.charCodeAt(index);\n            if (isLineTerminator(ch)) {\n                if (ch === 13 && source.charCodeAt(index + 1) === 10) {\n                    ++index;\n                }\n                ++lineNumber;\n                ++index;\n                lineStart = index;\n                if (index >= length) {\n                    throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n                }\n            } else if (ch === 42) {\n                // Block comment ends with '*/' (char #42, char #47).\n                if (source.charCodeAt(index + 1) === 47) {\n                    ++index;\n                    ++index;\n                    if (extra.comments) {\n                        comment = source.slice(start + 2, index - 2);\n                        loc.end = {\n                            line: lineNumber,\n                            column: index - lineStart\n                        };\n                        addComment('Block', comment, start, index, loc);\n                    }\n                    return;\n                }\n                ++index;\n            } else {\n                ++index;\n            }\n        }\n\n        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n    }\n\n    function skipComment() {\n        var ch;\n\n        while (index < length) {\n            ch = source.charCodeAt(index);\n\n            if (isWhiteSpace(ch)) {\n                ++index;\n            } else if (isLineTerminator(ch)) {\n                ++index;\n                if (ch === 13 && source.charCodeAt(index) === 10) {\n                    ++index;\n                }\n                ++lineNumber;\n                lineStart = index;\n            } else if (ch === 47) { // 47 is '/'\n                ch = source.charCodeAt(index + 1);\n                if (ch === 47) {\n                    ++index;\n                    ++index;\n                    skipSingleLineComment();\n                } else if (ch === 42) {  // 42 is '*'\n                    ++index;\n                    ++index;\n                    skipMultiLineComment();\n                } else {\n                    break;\n                }\n            } else {\n                break;\n            }\n        }\n    }\n\n    function scanHexEscape(prefix) {\n        var i, len, ch, code = 0;\n\n        len = (prefix === 'u') ? 4 : 2;\n        for (i = 0; i < len; ++i) {\n            if (index < length && isHexDigit(source[index])) {\n                ch = source[index++];\n                code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());\n            } else {\n                return '';\n            }\n        }\n        return String.fromCharCode(code);\n    }\n\n    function scanUnicodeCodePointEscape() {\n        var ch, code, cu1, cu2;\n\n        ch = source[index];\n        code = 0;\n\n        // At least, one hex digit is required.\n        if (ch === '}') {\n            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n        }\n\n        while (index < length) {\n            ch = source[index++];\n            if (!isHexDigit(ch)) {\n                break;\n            }\n            code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());\n        }\n\n        if (code > 0x10FFFF || ch !== '}') {\n            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n        }\n\n        // UTF-16 Encoding\n        if (code <= 0xFFFF) {\n            return String.fromCharCode(code);\n        }\n        cu1 = ((code - 0x10000) >> 10) + 0xD800;\n        cu2 = ((code - 0x10000) & 1023) + 0xDC00;\n        return String.fromCharCode(cu1, cu2);\n    }\n\n    function getEscapedIdentifier() {\n        var ch, id;\n\n        ch = source.charCodeAt(index++);\n        id = String.fromCharCode(ch);\n\n        // '\\u' (char #92, char #117) denotes an escaped character.\n        if (ch === 92) {\n            if (source.charCodeAt(index) !== 117) {\n                throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n            }\n            ++index;\n            ch = scanHexEscape('u');\n            if (!ch || ch === '\\\\' || !isIdentifierStart(ch.charCodeAt(0))) {\n                throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n            }\n            id = ch;\n        }\n\n        while (index < length) {\n            ch = source.charCodeAt(index);\n            if (!isIdentifierPart(ch)) {\n                break;\n            }\n            ++index;\n            id += String.fromCharCode(ch);\n\n            // '\\u' (char #92, char #117) denotes an escaped character.\n            if (ch === 92) {\n                id = id.substr(0, id.length - 1);\n                if (source.charCodeAt(index) !== 117) {\n                    throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n                }\n                ++index;\n                ch = scanHexEscape('u');\n                if (!ch || ch === '\\\\' || !isIdentifierPart(ch.charCodeAt(0))) {\n                    throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n                }\n                id += ch;\n            }\n        }\n\n        return id;\n    }\n\n    function getIdentifier() {\n        var start, ch;\n\n        start = index++;\n        while (index < length) {\n            ch = source.charCodeAt(index);\n            if (ch === 92) {\n                // Blackslash (char #92) marks Unicode escape sequence.\n                index = start;\n                return getEscapedIdentifier();\n            }\n            if (isIdentifierPart(ch)) {\n                ++index;\n            } else {\n                break;\n            }\n        }\n\n        return source.slice(start, index);\n    }\n\n    function scanIdentifier() {\n        var start, id, type;\n\n        start = index;\n\n        // Backslash (char #92) starts an escaped character.\n        id = (source.charCodeAt(index) === 92) ? getEscapedIdentifier() : getIdentifier();\n\n        // There is no keyword or literal with only one character.\n        // Thus, it must be an identifier.\n        if (id.length === 1) {\n            type = Token.Identifier;\n        } else if (isKeyword(id)) {\n            type = Token.Keyword;\n        } else if (id === 'null') {\n            type = Token.NullLiteral;\n        } else if (id === 'true' || id === 'false') {\n            type = Token.BooleanLiteral;\n        } else {\n            type = Token.Identifier;\n        }\n\n        return {\n            type: type,\n            value: id,\n            lineNumber: lineNumber,\n            lineStart: lineStart,\n            range: [start, index]\n        };\n    }\n\n\n    // 7.7 Punctuators\n\n    function scanPunctuator() {\n        var start = index,\n            code = source.charCodeAt(index),\n            code2,\n            ch1 = source[index],\n            ch2,\n            ch3,\n            ch4;\n\n        if (state.inJSXTag || state.inJSXChild) {\n            // Don't need to check for '{' and '}' as it's already handled\n            // correctly by default.\n            switch (code) {\n            case 60:  // <\n            case 62:  // >\n                ++index;\n                return {\n                    type: Token.Punctuator,\n                    value: String.fromCharCode(code),\n                    lineNumber: lineNumber,\n                    lineStart: lineStart,\n                    range: [start, index]\n                };\n            }\n        }\n\n        switch (code) {\n        // Check for most common single-character punctuators.\n        case 40:   // ( open bracket\n        case 41:   // ) close bracket\n        case 59:   // ; semicolon\n        case 44:   // , comma\n        case 91:   // [\n        case 93:   // ]\n        case 58:   // :\n        case 63:   // ?\n        case 126:  // ~\n            ++index;\n            if (extra.tokenize && code === 40) {\n                extra.openParenToken = extra.tokens.length;\n            }\n\n            return {\n                type: Token.Punctuator,\n                value: String.fromCharCode(code),\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                range: [start, index]\n            };\n\n        case 123:  // { open curly brace\n        case 125:  // } close curly brace\n            ++index;\n            if (extra.tokenize && code === 123) {\n                extra.openCurlyToken = extra.tokens.length;\n            }\n\n            // lookahead2 function can cause tokens to be scanned twice and in doing so\n            // would wreck the curly stack by pushing the same token onto the stack twice.\n            // curlyLastIndex ensures each token is pushed or popped exactly once\n            if (index > state.curlyLastIndex) {\n                state.curlyLastIndex = index;\n                if (code === 123) {\n                    state.curlyStack.push('{');\n                } else {\n                    state.curlyStack.pop();\n                }\n            }\n\n            return {\n                type: Token.Punctuator,\n                value: String.fromCharCode(code),\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                range: [start, index]\n            };\n\n        default:\n            code2 = source.charCodeAt(index + 1);\n\n            // '=' (char #61) marks an assignment or comparison operator.\n            if (code2 === 61) {\n                switch (code) {\n                case 37:  // %\n                case 38:  // &\n                case 42:  // *:\n                case 43:  // +\n                case 45:  // -\n                case 47:  // /\n                case 60:  // <\n                case 62:  // >\n                case 94:  // ^\n                case 124: // |\n                    index += 2;\n                    return {\n                        type: Token.Punctuator,\n                        value: String.fromCharCode(code) + String.fromCharCode(code2),\n                        lineNumber: lineNumber,\n                        lineStart: lineStart,\n                        range: [start, index]\n                    };\n\n                case 33: // !\n                case 61: // =\n                    index += 2;\n\n                    // !== and ===\n                    if (source.charCodeAt(index) === 61) {\n                        ++index;\n                    }\n                    return {\n                        type: Token.Punctuator,\n                        value: source.slice(start, index),\n                        lineNumber: lineNumber,\n                        lineStart: lineStart,\n                        range: [start, index]\n                    };\n                default:\n                    break;\n                }\n            }\n            break;\n        }\n\n        // Peek more characters.\n\n        ch2 = source[index + 1];\n        ch3 = source[index + 2];\n        ch4 = source[index + 3];\n\n        // 4-character punctuator: >>>=\n\n        if (ch1 === '>' && ch2 === '>' && ch3 === '>') {\n            if (ch4 === '=') {\n                index += 4;\n                return {\n                    type: Token.Punctuator,\n                    value: '>>>=',\n                    lineNumber: lineNumber,\n                    lineStart: lineStart,\n                    range: [start, index]\n                };\n            }\n        }\n\n        // 3-character punctuators: === !== >>> <<= >>=\n\n        if (ch1 === '>' && ch2 === '>' && ch3 === '>' && !state.inType) {\n            index += 3;\n            return {\n                type: Token.Punctuator,\n                value: '>>>',\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                range: [start, index]\n            };\n        }\n\n        if (ch1 === '<' && ch2 === '<' && ch3 === '=') {\n            index += 3;\n            return {\n                type: Token.Punctuator,\n                value: '<<=',\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                range: [start, index]\n            };\n        }\n\n        if (ch1 === '>' && ch2 === '>' && ch3 === '=') {\n            index += 3;\n            return {\n                type: Token.Punctuator,\n                value: '>>=',\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                range: [start, index]\n            };\n        }\n\n        if (ch1 === '.' && ch2 === '.' && ch3 === '.') {\n            index += 3;\n            return {\n                type: Token.Punctuator,\n                value: '...',\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                range: [start, index]\n            };\n        }\n\n        // Other 2-character punctuators: ++ -- << >> && ||\n\n        // Don't match these tokens if we're in a type, since they never can\n        // occur and can mess up types like Map<string, Array<string>>\n        if (ch1 === ch2 && ('+-<>&|'.indexOf(ch1) >= 0) && !state.inType) {\n            index += 2;\n            return {\n                type: Token.Punctuator,\n                value: ch1 + ch2,\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                range: [start, index]\n            };\n        }\n\n        if (ch1 === '=' && ch2 === '>') {\n            index += 2;\n            return {\n                type: Token.Punctuator,\n                value: '=>',\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                range: [start, index]\n            };\n        }\n\n        if ('<>=!+-*%&|^/'.indexOf(ch1) >= 0) {\n            ++index;\n            return {\n                type: Token.Punctuator,\n                value: ch1,\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                range: [start, index]\n            };\n        }\n\n        if (ch1 === '.') {\n            ++index;\n            return {\n                type: Token.Punctuator,\n                value: ch1,\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                range: [start, index]\n            };\n        }\n\n        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n    }\n\n    // 7.8.3 Numeric Literals\n\n    function scanHexLiteral(start) {\n        var number = '';\n\n        while (index < length) {\n            if (!isHexDigit(source[index])) {\n                break;\n            }\n            number += source[index++];\n        }\n\n        if (number.length === 0) {\n            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n        }\n\n        if (isIdentifierStart(source.charCodeAt(index))) {\n            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n        }\n\n        return {\n            type: Token.NumericLiteral,\n            value: parseInt('0x' + number, 16),\n            lineNumber: lineNumber,\n            lineStart: lineStart,\n            range: [start, index]\n        };\n    }\n\n    function scanBinaryLiteral(start) {\n        var ch, number;\n\n        number = '';\n\n        while (index < length) {\n            ch = source[index];\n            if (ch !== '0' && ch !== '1') {\n                break;\n            }\n            number += source[index++];\n        }\n\n        if (number.length === 0) {\n            // only 0b or 0B\n            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n        }\n\n        if (index < length) {\n            ch = source.charCodeAt(index);\n            /* istanbul ignore else */\n            if (isIdentifierStart(ch) || isDecimalDigit(ch)) {\n                throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n            }\n        }\n\n        return {\n            type: Token.NumericLiteral,\n            value: parseInt(number, 2),\n            lineNumber: lineNumber,\n            lineStart: lineStart,\n            range: [start, index]\n        };\n    }\n\n    function scanOctalLiteral(prefix, start) {\n        var number, octal;\n\n        if (isOctalDigit(prefix)) {\n            octal = true;\n            number = '0' + source[index++];\n        } else {\n            octal = false;\n            ++index;\n            number = '';\n        }\n\n        while (index < length) {\n            if (!isOctalDigit(source[index])) {\n                break;\n            }\n            number += source[index++];\n        }\n\n        if (!octal && number.length === 0) {\n            // only 0o or 0O\n            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n        }\n\n        if (isIdentifierStart(source.charCodeAt(index)) || isDecimalDigit(source.charCodeAt(index))) {\n            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n        }\n\n        return {\n            type: Token.NumericLiteral,\n            value: parseInt(number, 8),\n            octal: octal,\n            lineNumber: lineNumber,\n            lineStart: lineStart,\n            range: [start, index]\n        };\n    }\n\n    function scanNumericLiteral() {\n        var number, start, ch;\n\n        ch = source[index];\n        assert(isDecimalDigit(ch.charCodeAt(0)) || (ch === '.'),\n            'Numeric literal must start with a decimal digit or a decimal point');\n\n        start = index;\n        number = '';\n        if (ch !== '.') {\n            number = source[index++];\n            ch = source[index];\n\n            // Hex number starts with '0x'.\n            // Octal number starts with '0'.\n            // Octal number in ES6 starts with '0o'.\n            // Binary number in ES6 starts with '0b'.\n            if (number === '0') {\n                if (ch === 'x' || ch === 'X') {\n                    ++index;\n                    return scanHexLiteral(start);\n                }\n                if (ch === 'b' || ch === 'B') {\n                    ++index;\n                    return scanBinaryLiteral(start);\n                }\n                if (ch === 'o' || ch === 'O' || isOctalDigit(ch)) {\n                    return scanOctalLiteral(ch, start);\n                }\n                // decimal number starts with '0' such as '09' is illegal.\n                if (ch && isDecimalDigit(ch.charCodeAt(0))) {\n                    throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n                }\n            }\n\n            while (isDecimalDigit(source.charCodeAt(index))) {\n                number += source[index++];\n            }\n            ch = source[index];\n        }\n\n        if (ch === '.') {\n            number += source[index++];\n            while (isDecimalDigit(source.charCodeAt(index))) {\n                number += source[index++];\n            }\n            ch = source[index];\n        }\n\n        if (ch === 'e' || ch === 'E') {\n            number += source[index++];\n\n            ch = source[index];\n            if (ch === '+' || ch === '-') {\n                number += source[index++];\n            }\n            if (isDecimalDigit(source.charCodeAt(index))) {\n                while (isDecimalDigit(source.charCodeAt(index))) {\n                    number += source[index++];\n                }\n            } else {\n                throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n            }\n        }\n\n        if (isIdentifierStart(source.charCodeAt(index))) {\n            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n        }\n\n        return {\n            type: Token.NumericLiteral,\n            value: parseFloat(number),\n            lineNumber: lineNumber,\n            lineStart: lineStart,\n            range: [start, index]\n        };\n    }\n\n    // 7.8.4 String Literals\n\n    function scanStringLiteral() {\n        var str = '', quote, start, ch, code, unescaped, restore, octal = false;\n\n        quote = source[index];\n        assert((quote === '\\'' || quote === '\"'),\n            'String literal must starts with a quote');\n\n        start = index;\n        ++index;\n\n        while (index < length) {\n            ch = source[index++];\n\n            if (ch === quote) {\n                quote = '';\n                break;\n            } else if (ch === '\\\\') {\n                ch = source[index++];\n                if (!ch || !isLineTerminator(ch.charCodeAt(0))) {\n                    switch (ch) {\n                    case 'n':\n                        str += '\\n';\n                        break;\n                    case 'r':\n                        str += '\\r';\n                        break;\n                    case 't':\n                        str += '\\t';\n                        break;\n                    case 'u':\n                    case 'x':\n                        if (source[index] === '{') {\n                            ++index;\n                            str += scanUnicodeCodePointEscape();\n                        } else {\n                            restore = index;\n                            unescaped = scanHexEscape(ch);\n                            if (unescaped) {\n                                str += unescaped;\n                            } else {\n                                index = restore;\n                                str += ch;\n                            }\n                        }\n                        break;\n                    case 'b':\n                        str += '\\b';\n                        break;\n                    case 'f':\n                        str += '\\f';\n                        break;\n                    case 'v':\n                        str += '\\x0B';\n                        break;\n\n                    default:\n                        if (isOctalDigit(ch)) {\n                            code = '01234567'.indexOf(ch);\n\n                            // \\0 is not octal escape sequence\n                            if (code !== 0) {\n                                octal = true;\n                            }\n\n                            /* istanbul ignore else */\n                            if (index < length && isOctalDigit(source[index])) {\n                                octal = true;\n                                code = code * 8 + '01234567'.indexOf(source[index++]);\n\n                                // 3 digits are only allowed when string starts\n                                // with 0, 1, 2, 3\n                                if ('0123'.indexOf(ch) >= 0 &&\n                                        index < length &&\n                                        isOctalDigit(source[index])) {\n                                    code = code * 8 + '01234567'.indexOf(source[index++]);\n                                }\n                            }\n                            str += String.fromCharCode(code);\n                        } else {\n                            str += ch;\n                        }\n                        break;\n                    }\n                } else {\n                    ++lineNumber;\n                    if (ch === '\\r' && source[index] === '\\n') {\n                        ++index;\n                    }\n                    lineStart = index;\n                }\n            } else if (isLineTerminator(ch.charCodeAt(0))) {\n                break;\n            } else {\n                str += ch;\n            }\n        }\n\n        if (quote !== '') {\n            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n        }\n\n        return {\n            type: Token.StringLiteral,\n            value: str,\n            octal: octal,\n            lineNumber: lineNumber,\n            lineStart: lineStart,\n            range: [start, index]\n        };\n    }\n\n    function scanTemplate() {\n        var cooked = '', ch, start, terminated, head, tail, restore, unescaped, code, octal;\n\n        terminated = false;\n        tail = false;\n        start = index;\n        head = (source[index] === '`');\n\n        ++index;\n\n        while (index < length) {\n            ch = source[index++];\n            if (ch === '`') {\n                tail = true;\n                terminated = true;\n                break;\n            } else if (ch === '$') {\n                if (source[index] === '{') {\n                    ++index;\n                    terminated = true;\n                    break;\n                }\n                cooked += ch;\n            } else if (ch === '\\\\') {\n                ch = source[index++];\n                if (!isLineTerminator(ch.charCodeAt(0))) {\n                    switch (ch) {\n                    case 'n':\n                        cooked += '\\n';\n                        break;\n                    case 'r':\n                        cooked += '\\r';\n                        break;\n                    case 't':\n                        cooked += '\\t';\n                        break;\n                    case 'u':\n                    case 'x':\n                        if (source[index] === '{') {\n                            ++index;\n                            cooked += scanUnicodeCodePointEscape();\n                        } else {\n                            restore = index;\n                            unescaped = scanHexEscape(ch);\n                            if (unescaped) {\n                                cooked += unescaped;\n                            } else {\n                                index = restore;\n                                cooked += ch;\n                            }\n                        }\n                        break;\n                    case 'b':\n                        cooked += '\\b';\n                        break;\n                    case 'f':\n                        cooked += '\\f';\n                        break;\n                    case 'v':\n                        cooked += '\\v';\n                        break;\n\n                    default:\n                        if (isOctalDigit(ch)) {\n                            code = '01234567'.indexOf(ch);\n\n                            // \\0 is not octal escape sequence\n                            if (code !== 0) {\n                                octal = true;\n                            }\n\n                            /* istanbul ignore else */\n                            if (index < length && isOctalDigit(source[index])) {\n                                octal = true;\n                                code = code * 8 + '01234567'.indexOf(source[index++]);\n\n                                // 3 digits are only allowed when string starts\n                                // with 0, 1, 2, 3\n                                if ('0123'.indexOf(ch) >= 0 &&\n                                        index < length &&\n                                        isOctalDigit(source[index])) {\n                                    code = code * 8 + '01234567'.indexOf(source[index++]);\n                                }\n                            }\n                            cooked += String.fromCharCode(code);\n                        } else {\n                            cooked += ch;\n                        }\n                        break;\n                    }\n                } else {\n                    ++lineNumber;\n                    if (ch === '\\r' && source[index] === '\\n') {\n                        ++index;\n                    }\n                    lineStart = index;\n                }\n            } else if (isLineTerminator(ch.charCodeAt(0))) {\n                ++lineNumber;\n                if (ch === '\\r' && source[index] === '\\n') {\n                    ++index;\n                }\n                lineStart = index;\n                cooked += '\\n';\n            } else {\n                cooked += ch;\n            }\n        }\n\n        if (!terminated) {\n            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n        }\n\n        if (index > state.curlyLastIndex) {\n            state.curlyLastIndex = index;\n            if (!tail) {\n                state.curlyStack.push('template');\n            }\n\n            if (!head) {\n                state.curlyStack.pop();\n            }\n        }\n\n        return {\n            type: Token.Template,\n            value: {\n                cooked: cooked,\n                raw: source.slice(start + 1, index - ((tail) ? 1 : 2))\n            },\n            head: head,\n            tail: tail,\n            octal: octal,\n            lineNumber: lineNumber,\n            lineStart: lineStart,\n            range: [start, index]\n        };\n    }\n\n    function testRegExp(pattern, flags) {\n        var tmp = pattern,\n            value;\n\n        if (flags.indexOf('u') >= 0) {\n            // Replace each astral symbol and every Unicode code point\n            // escape sequence with a single ASCII symbol to avoid throwing on\n            // regular expressions that are only valid in combination with the\n            // `/u` flag.\n            // Note: replacing with the ASCII symbol `x` might cause false\n            // negatives in unlikely scenarios. For example, `[\\u{61}-b]` is a\n            // perfectly valid pattern that is equivalent to `[a-b]`, but it\n            // would be replaced by `[x-b]` which throws an error.\n            tmp = tmp\n                .replace(/\\\\u\\{([0-9a-fA-F]+)\\}/g, function ($0, $1) {\n                    if (parseInt($1, 16) <= 0x10FFFF) {\n                        return 'x';\n                    }\n                    throwError({}, Messages.InvalidRegExp);\n                })\n                .replace(/[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g, 'x');\n        }\n\n        // First, detect invalid regular expressions.\n        try {\n            value = new RegExp(tmp);\n        } catch (e) {\n            throwError({}, Messages.InvalidRegExp);\n        }\n\n        // Return a regular expression object for this pattern-flag pair, or\n        // `null` in case the current environment doesn't support the flags it\n        // uses.\n        try {\n            return new RegExp(pattern, flags);\n        } catch (exception) {\n            return null;\n        }\n    }\n\n    function scanRegExpBody() {\n        var ch, str, classMarker, terminated, body;\n\n        ch = source[index];\n        assert(ch === '/', 'Regular expression literal must start with a slash');\n        str = source[index++];\n\n        classMarker = false;\n        terminated = false;\n        while (index < length) {\n            ch = source[index++];\n            str += ch;\n            if (ch === '\\\\') {\n                ch = source[index++];\n                // ECMA-262 7.8.5\n                if (isLineTerminator(ch.charCodeAt(0))) {\n                    throwError({}, Messages.UnterminatedRegExp);\n                }\n                str += ch;\n            } else if (isLineTerminator(ch.charCodeAt(0))) {\n                throwError({}, Messages.UnterminatedRegExp);\n            } else if (classMarker) {\n                if (ch === ']') {\n                    classMarker = false;\n                }\n            } else {\n                if (ch === '/') {\n                    terminated = true;\n                    break;\n                } else if (ch === '[') {\n                    classMarker = true;\n                }\n            }\n        }\n\n        if (!terminated) {\n            throwError({}, Messages.UnterminatedRegExp);\n        }\n\n        // Exclude leading and trailing slash.\n        body = str.substr(1, str.length - 2);\n        return {\n            value: body,\n            literal: str\n        };\n    }\n\n    function scanRegExpFlags() {\n        var ch, str, flags, restore;\n\n        str = '';\n        flags = '';\n        while (index < length) {\n            ch = source[index];\n            if (!isIdentifierPart(ch.charCodeAt(0))) {\n                break;\n            }\n\n            ++index;\n            if (ch === '\\\\' && index < length) {\n                ch = source[index];\n                if (ch === 'u') {\n                    ++index;\n                    restore = index;\n                    ch = scanHexEscape('u');\n                    if (ch) {\n                        flags += ch;\n                        for (str += '\\\\u'; restore < index; ++restore) {\n                            str += source[restore];\n                        }\n                    } else {\n                        index = restore;\n                        flags += 'u';\n                        str += '\\\\u';\n                    }\n                    throwErrorTolerant({}, Messages.UnexpectedToken, 'ILLEGAL');\n                } else {\n                    str += '\\\\';\n                    throwErrorTolerant({}, Messages.UnexpectedToken, 'ILLEGAL');\n                }\n            } else {\n                flags += ch;\n                str += ch;\n            }\n        }\n\n        return {\n            value: flags,\n            literal: str\n        };\n    }\n\n    function scanRegExp() {\n        var start, body, flags, value;\n\n        lookahead = null;\n        skipComment();\n        start = index;\n\n        body = scanRegExpBody();\n        flags = scanRegExpFlags();\n        value = testRegExp(body.value, flags.value);\n\n        if (extra.tokenize) {\n            return {\n                type: Token.RegularExpression,\n                value: value,\n                regex: {\n                    pattern: body.value,\n                    flags: flags.value\n                },\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                range: [start, index]\n            };\n        }\n\n        return {\n            literal: body.literal + flags.literal,\n            value: value,\n            regex: {\n                pattern: body.value,\n                flags: flags.value\n            },\n            range: [start, index]\n        };\n    }\n\n    function isIdentifierName(token) {\n        return token.type === Token.Identifier ||\n            token.type === Token.Keyword ||\n            token.type === Token.BooleanLiteral ||\n            token.type === Token.NullLiteral;\n    }\n\n    function advanceSlash() {\n        var prevToken,\n            checkToken;\n        // Using the following algorithm:\n        // https://github.com/mozilla/sweet.js/wiki/design\n        prevToken = extra.tokens[extra.tokens.length - 1];\n        if (!prevToken) {\n            // Nothing before that: it cannot be a division.\n            return scanRegExp();\n        }\n        if (prevToken.type === 'Punctuator') {\n            if (prevToken.value === ')') {\n                checkToken = extra.tokens[extra.openParenToken - 1];\n                if (checkToken &&\n                        checkToken.type === 'Keyword' &&\n                        (checkToken.value === 'if' ||\n                         checkToken.value === 'while' ||\n                         checkToken.value === 'for' ||\n                         checkToken.value === 'with')) {\n                    return scanRegExp();\n                }\n                return scanPunctuator();\n            }\n            if (prevToken.value === '}') {\n                // Dividing a function by anything makes little sense,\n                // but we have to check for that.\n                if (extra.tokens[extra.openCurlyToken - 3] &&\n                        extra.tokens[extra.openCurlyToken - 3].type === 'Keyword') {\n                    // Anonymous function.\n                    checkToken = extra.tokens[extra.openCurlyToken - 4];\n                    if (!checkToken) {\n                        return scanPunctuator();\n                    }\n                } else if (extra.tokens[extra.openCurlyToken - 4] &&\n                        extra.tokens[extra.openCurlyToken - 4].type === 'Keyword') {\n                    // Named function.\n                    checkToken = extra.tokens[extra.openCurlyToken - 5];\n                    if (!checkToken) {\n                        return scanRegExp();\n                    }\n                } else {\n                    return scanPunctuator();\n                }\n                // checkToken determines whether the function is\n                // a declaration or an expression.\n                if (FnExprTokens.indexOf(checkToken.value) >= 0) {\n                    // It is an expression.\n                    return scanPunctuator();\n                }\n                // It is a declaration.\n                return scanRegExp();\n            }\n            return scanRegExp();\n        }\n        if (prevToken.type === 'Keyword' && prevToken.value !== 'this') {\n            return scanRegExp();\n        }\n        return scanPunctuator();\n    }\n\n    function advance() {\n        var ch;\n\n        if (!state.inJSXChild) {\n            skipComment();\n        }\n\n        if (index >= length) {\n            return {\n                type: Token.EOF,\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                range: [index, index]\n            };\n        }\n\n        if (state.inJSXChild) {\n            return advanceJSXChild();\n        }\n\n        ch = source.charCodeAt(index);\n\n        // Very common: ( and ) and ;\n        if (ch === 40 || ch === 41 || ch === 58) {\n            return scanPunctuator();\n        }\n\n        // String literal starts with single quote (#39) or double quote (#34).\n        if (ch === 39 || ch === 34) {\n            if (state.inJSXTag) {\n                return scanJSXStringLiteral();\n            }\n            return scanStringLiteral();\n        }\n\n        if (state.inJSXTag && isJSXIdentifierStart(ch)) {\n            return scanJSXIdentifier();\n        }\n\n        // Template literals start with backtick (#96) for template head\n        // or close curly (#125) for template middle or template tail.\n        if (ch === 96 || (ch === 125 && state.curlyStack[state.curlyStack.length - 1] === 'template')) {\n            return scanTemplate();\n        }\n        if (isIdentifierStart(ch)) {\n            return scanIdentifier();\n        }\n\n        // Dot (.) char #46 can also start a floating-point number, hence the need\n        // to check the next character.\n        if (ch === 46) {\n            if (isDecimalDigit(source.charCodeAt(index + 1))) {\n                return scanNumericLiteral();\n            }\n            return scanPunctuator();\n        }\n\n        if (isDecimalDigit(ch)) {\n            return scanNumericLiteral();\n        }\n\n        // Slash (/) char #47 can also start a regex.\n        if (extra.tokenize && ch === 47) {\n            return advanceSlash();\n        }\n\n        return scanPunctuator();\n    }\n\n    function lex() {\n        var token;\n\n        token = lookahead;\n        index = token.range[1];\n        lineNumber = token.lineNumber;\n        lineStart = token.lineStart;\n\n        lookahead = advance();\n\n        index = token.range[1];\n        lineNumber = token.lineNumber;\n        lineStart = token.lineStart;\n\n        return token;\n    }\n\n    function peek() {\n        var pos, line, start;\n\n        pos = index;\n        line = lineNumber;\n        start = lineStart;\n        lookahead = advance();\n        index = pos;\n        lineNumber = line;\n        lineStart = start;\n    }\n\n    function lookahead2() {\n        var adv, pos, line, start, result;\n\n        // If we are collecting the tokens, don't grab the next one yet.\n        /* istanbul ignore next */\n        adv = (typeof extra.advance === 'function') ? extra.advance : advance;\n\n        pos = index;\n        line = lineNumber;\n        start = lineStart;\n\n        // Scan for the next immediate token.\n        /* istanbul ignore if */\n        if (lookahead === null) {\n            lookahead = adv();\n        }\n        index = lookahead.range[1];\n        lineNumber = lookahead.lineNumber;\n        lineStart = lookahead.lineStart;\n\n        // Grab the token right after.\n        result = adv();\n        index = pos;\n        lineNumber = line;\n        lineStart = start;\n\n        return result;\n    }\n\n    function rewind(token) {\n        index = token.range[0];\n        lineNumber = token.lineNumber;\n        lineStart = token.lineStart;\n        lookahead = token;\n    }\n\n    function markerCreate() {\n        if (!extra.loc && !extra.range) {\n            return undefined;\n        }\n        skipComment();\n        return {offset: index, line: lineNumber, col: index - lineStart};\n    }\n\n    function markerCreatePreserveWhitespace() {\n        if (!extra.loc && !extra.range) {\n            return undefined;\n        }\n        return {offset: index, line: lineNumber, col: index - lineStart};\n    }\n\n    function processComment(node) {\n        var lastChild,\n            trailingComments,\n            bottomRight = extra.bottomRightStack,\n            last = bottomRight[bottomRight.length - 1];\n\n        if (node.type === Syntax.Program) {\n            /* istanbul ignore else */\n            if (node.body.length > 0) {\n                return;\n            }\n        }\n\n        if (extra.trailingComments.length > 0) {\n            if (extra.trailingComments[0].range[0] >= node.range[1]) {\n                trailingComments = extra.trailingComments;\n                extra.trailingComments = [];\n            } else {\n                extra.trailingComments.length = 0;\n            }\n        } else {\n            if (last && last.trailingComments && last.trailingComments[0].range[0] >= node.range[1]) {\n                trailingComments = last.trailingComments;\n                delete last.trailingComments;\n            }\n        }\n\n        // Eating the stack.\n        if (last) {\n            while (last && last.range[0] >= node.range[0]) {\n                lastChild = last;\n                last = bottomRight.pop();\n            }\n        }\n\n        if (lastChild) {\n            if (lastChild.leadingComments && lastChild.leadingComments[lastChild.leadingComments.length - 1].range[1] <= node.range[0]) {\n                node.leadingComments = lastChild.leadingComments;\n                delete lastChild.leadingComments;\n            }\n        } else if (extra.leadingComments.length > 0 && extra.leadingComments[extra.leadingComments.length - 1].range[1] <= node.range[0]) {\n            node.leadingComments = extra.leadingComments;\n            extra.leadingComments = [];\n        }\n\n        if (trailingComments) {\n            node.trailingComments = trailingComments;\n        }\n\n        bottomRight.push(node);\n    }\n\n    function markerApply(marker, node) {\n        if (extra.range) {\n            node.range = [marker.offset, index];\n        }\n        if (extra.loc) {\n            node.loc = {\n                start: {\n                    line: marker.line,\n                    column: marker.col\n                },\n                end: {\n                    line: lineNumber,\n                    column: index - lineStart\n                }\n            };\n            node = delegate.postProcess(node);\n        }\n        if (extra.attachComment) {\n            processComment(node);\n        }\n        return node;\n    }\n\n    SyntaxTreeDelegate = {\n\n        name: 'SyntaxTree',\n\n        postProcess: function (node) {\n            return node;\n        },\n\n        createArrayExpression: function (elements) {\n            return {\n                type: Syntax.ArrayExpression,\n                elements: elements\n            };\n        },\n\n        createAssignmentExpression: function (operator, left, right) {\n            return {\n                type: Syntax.AssignmentExpression,\n                operator: operator,\n                left: left,\n                right: right\n            };\n        },\n\n        createBinaryExpression: function (operator, left, right) {\n            var type = (operator === '||' || operator === '&&') ? Syntax.LogicalExpression :\n                        Syntax.BinaryExpression;\n            return {\n                type: type,\n                operator: operator,\n                left: left,\n                right: right\n            };\n        },\n\n        createBlockStatement: function (body) {\n            return {\n                type: Syntax.BlockStatement,\n                body: body\n            };\n        },\n\n        createBreakStatement: function (label) {\n            return {\n                type: Syntax.BreakStatement,\n                label: label\n            };\n        },\n\n        createCallExpression: function (callee, args) {\n            return {\n                type: Syntax.CallExpression,\n                callee: callee,\n                'arguments': args\n            };\n        },\n\n        createCatchClause: function (param, body) {\n            return {\n                type: Syntax.CatchClause,\n                param: param,\n                body: body\n            };\n        },\n\n        createConditionalExpression: function (test, consequent, alternate) {\n            return {\n                type: Syntax.ConditionalExpression,\n                test: test,\n                consequent: consequent,\n                alternate: alternate\n            };\n        },\n\n        createContinueStatement: function (label) {\n            return {\n                type: Syntax.ContinueStatement,\n                label: label\n            };\n        },\n\n        createDebuggerStatement: function () {\n            return {\n                type: Syntax.DebuggerStatement\n            };\n        },\n\n        createDoWhileStatement: function (body, test) {\n            return {\n                type: Syntax.DoWhileStatement,\n                body: body,\n                test: test\n            };\n        },\n\n        createEmptyStatement: function () {\n            return {\n                type: Syntax.EmptyStatement\n            };\n        },\n\n        createExpressionStatement: function (expression) {\n            return {\n                type: Syntax.ExpressionStatement,\n                expression: expression\n            };\n        },\n\n        createForStatement: function (init, test, update, body) {\n            return {\n                type: Syntax.ForStatement,\n                init: init,\n                test: test,\n                update: update,\n                body: body\n            };\n        },\n\n        createForInStatement: function (left, right, body) {\n            return {\n                type: Syntax.ForInStatement,\n                left: left,\n                right: right,\n                body: body,\n                each: false\n            };\n        },\n\n        createForOfStatement: function (left, right, body) {\n            return {\n                type: Syntax.ForOfStatement,\n                left: left,\n                right: right,\n                body: body\n            };\n        },\n\n        createFunctionDeclaration: function (id, params, defaults, body, rest, generator, expression,\n                                             isAsync, returnType, typeParameters) {\n            var funDecl = {\n                type: Syntax.FunctionDeclaration,\n                id: id,\n                params: params,\n                defaults: defaults,\n                body: body,\n                rest: rest,\n                generator: generator,\n                expression: expression,\n                returnType: returnType,\n                typeParameters: typeParameters\n            };\n\n            if (isAsync) {\n                funDecl.async = true;\n            }\n\n            return funDecl;\n        },\n\n        createFunctionExpression: function (id, params, defaults, body, rest, generator, expression,\n                                            isAsync, returnType, typeParameters) {\n            var funExpr = {\n                type: Syntax.FunctionExpression,\n                id: id,\n                params: params,\n                defaults: defaults,\n                body: body,\n                rest: rest,\n                generator: generator,\n                expression: expression,\n                returnType: returnType,\n                typeParameters: typeParameters\n            };\n\n            if (isAsync) {\n                funExpr.async = true;\n            }\n\n            return funExpr;\n        },\n\n        createIdentifier: function (name) {\n            return {\n                type: Syntax.Identifier,\n                name: name,\n                // Only here to initialize the shape of the object to ensure\n                // that the 'typeAnnotation' key is ordered before others that\n                // are added later (like 'loc' and 'range'). This just helps\n                // keep the shape of Identifier nodes consistent with everything\n                // else.\n                typeAnnotation: undefined,\n                optional: undefined\n            };\n        },\n\n        createTypeAnnotation: function (typeAnnotation) {\n            return {\n                type: Syntax.TypeAnnotation,\n                typeAnnotation: typeAnnotation\n            };\n        },\n\n        createTypeCast: function (expression, typeAnnotation) {\n            return {\n                type: Syntax.TypeCastExpression,\n                expression: expression,\n                typeAnnotation: typeAnnotation\n            };\n        },\n\n        createFunctionTypeAnnotation: function (params, returnType, rest, typeParameters) {\n            return {\n                type: Syntax.FunctionTypeAnnotation,\n                params: params,\n                returnType: returnType,\n                rest: rest,\n                typeParameters: typeParameters\n            };\n        },\n\n        createFunctionTypeParam: function (name, typeAnnotation, optional) {\n            return {\n                type: Syntax.FunctionTypeParam,\n                name: name,\n                typeAnnotation: typeAnnotation,\n                optional: optional\n            };\n        },\n\n        createNullableTypeAnnotation: function (typeAnnotation) {\n            return {\n                type: Syntax.NullableTypeAnnotation,\n                typeAnnotation: typeAnnotation\n            };\n        },\n\n        createArrayTypeAnnotation: function (elementType) {\n            return {\n                type: Syntax.ArrayTypeAnnotation,\n                elementType: elementType\n            };\n        },\n\n        createGenericTypeAnnotation: function (id, typeParameters) {\n            return {\n                type: Syntax.GenericTypeAnnotation,\n                id: id,\n                typeParameters: typeParameters\n            };\n        },\n\n        createQualifiedTypeIdentifier: function (qualification, id) {\n            return {\n                type: Syntax.QualifiedTypeIdentifier,\n                qualification: qualification,\n                id: id\n            };\n        },\n\n        createTypeParameterDeclaration: function (params) {\n            return {\n                type: Syntax.TypeParameterDeclaration,\n                params: params\n            };\n        },\n\n        createTypeParameterInstantiation: function (params) {\n            return {\n                type: Syntax.TypeParameterInstantiation,\n                params: params\n            };\n        },\n\n        createAnyTypeAnnotation: function () {\n            return {\n                type: Syntax.AnyTypeAnnotation\n            };\n        },\n\n        createBooleanTypeAnnotation: function () {\n            return {\n                type: Syntax.BooleanTypeAnnotation\n            };\n        },\n\n        createNumberTypeAnnotation: function () {\n            return {\n                type: Syntax.NumberTypeAnnotation\n            };\n        },\n\n        createStringTypeAnnotation: function () {\n            return {\n                type: Syntax.StringTypeAnnotation\n            };\n        },\n\n        createStringLiteralTypeAnnotation: function (token) {\n            return {\n                type: Syntax.StringLiteralTypeAnnotation,\n                value: token.value,\n                raw: source.slice(token.range[0], token.range[1])\n            };\n        },\n\n        createVoidTypeAnnotation: function () {\n            return {\n                type: Syntax.VoidTypeAnnotation\n            };\n        },\n\n        createTypeofTypeAnnotation: function (argument) {\n            return {\n                type: Syntax.TypeofTypeAnnotation,\n                argument: argument\n            };\n        },\n\n        createTupleTypeAnnotation: function (types) {\n            return {\n                type: Syntax.TupleTypeAnnotation,\n                types: types\n            };\n        },\n\n        createObjectTypeAnnotation: function (properties, indexers, callProperties) {\n            return {\n                type: Syntax.ObjectTypeAnnotation,\n                properties: properties,\n                indexers: indexers,\n                callProperties: callProperties\n            };\n        },\n\n        createObjectTypeIndexer: function (id, key, value, isStatic) {\n            return {\n                type: Syntax.ObjectTypeIndexer,\n                id: id,\n                key: key,\n                value: value,\n                static: isStatic\n            };\n        },\n\n        createObjectTypeCallProperty: function (value, isStatic) {\n            return {\n                type: Syntax.ObjectTypeCallProperty,\n                value: value,\n                static: isStatic\n            };\n        },\n\n        createObjectTypeProperty: function (key, value, optional, isStatic) {\n            return {\n                type: Syntax.ObjectTypeProperty,\n                key: key,\n                value: value,\n                optional: optional,\n                static: isStatic\n            };\n        },\n\n        createUnionTypeAnnotation: function (types) {\n            return {\n                type: Syntax.UnionTypeAnnotation,\n                types: types\n            };\n        },\n\n        createIntersectionTypeAnnotation: function (types) {\n            return {\n                type: Syntax.IntersectionTypeAnnotation,\n                types: types\n            };\n        },\n\n        createTypeAlias: function (id, typeParameters, right) {\n            return {\n                type: Syntax.TypeAlias,\n                id: id,\n                typeParameters: typeParameters,\n                right: right\n            };\n        },\n\n        createInterface: function (id, typeParameters, body, extended) {\n            return {\n                type: Syntax.InterfaceDeclaration,\n                id: id,\n                typeParameters: typeParameters,\n                body: body,\n                extends: extended\n            };\n        },\n\n        createInterfaceExtends: function (id, typeParameters) {\n            return {\n                type: Syntax.InterfaceExtends,\n                id: id,\n                typeParameters: typeParameters\n            };\n        },\n\n        createDeclareFunction: function (id) {\n            return {\n                type: Syntax.DeclareFunction,\n                id: id\n            };\n        },\n\n        createDeclareVariable: function (id) {\n            return {\n                type: Syntax.DeclareVariable,\n                id: id\n            };\n        },\n\n        createDeclareModule: function (id, body) {\n            return {\n                type: Syntax.DeclareModule,\n                id: id,\n                body: body\n            };\n        },\n\n        createJSXAttribute: function (name, value) {\n            return {\n                type: Syntax.JSXAttribute,\n                name: name,\n                value: value || null\n            };\n        },\n\n        createJSXSpreadAttribute: function (argument) {\n            return {\n                type: Syntax.JSXSpreadAttribute,\n                argument: argument\n            };\n        },\n\n        createJSXIdentifier: function (name) {\n            return {\n                type: Syntax.JSXIdentifier,\n                name: name\n            };\n        },\n\n        createJSXNamespacedName: function (namespace, name) {\n            return {\n                type: Syntax.JSXNamespacedName,\n                namespace: namespace,\n                name: name\n            };\n        },\n\n        createJSXMemberExpression: function (object, property) {\n            return {\n                type: Syntax.JSXMemberExpression,\n                object: object,\n                property: property\n            };\n        },\n\n        createJSXElement: function (openingElement, closingElement, children) {\n            return {\n                type: Syntax.JSXElement,\n                openingElement: openingElement,\n                closingElement: closingElement,\n                children: children\n            };\n        },\n\n        createJSXEmptyExpression: function () {\n            return {\n                type: Syntax.JSXEmptyExpression\n            };\n        },\n\n        createJSXExpressionContainer: function (expression) {\n            return {\n                type: Syntax.JSXExpressionContainer,\n                expression: expression\n            };\n        },\n\n        createJSXOpeningElement: function (name, attributes, selfClosing) {\n            return {\n                type: Syntax.JSXOpeningElement,\n                name: name,\n                selfClosing: selfClosing,\n                attributes: attributes\n            };\n        },\n\n        createJSXClosingElement: function (name) {\n            return {\n                type: Syntax.JSXClosingElement,\n                name: name\n            };\n        },\n\n        createIfStatement: function (test, consequent, alternate) {\n            return {\n                type: Syntax.IfStatement,\n                test: test,\n                consequent: consequent,\n                alternate: alternate\n            };\n        },\n\n        createLabeledStatement: function (label, body) {\n            return {\n                type: Syntax.LabeledStatement,\n                label: label,\n                body: body\n            };\n        },\n\n        createLiteral: function (token) {\n            var object = {\n                type: Syntax.Literal,\n                value: token.value,\n                raw: source.slice(token.range[0], token.range[1])\n            };\n            if (token.regex) {\n                object.regex = token.regex;\n            }\n            return object;\n        },\n\n        createMemberExpression: function (accessor, object, property) {\n            return {\n                type: Syntax.MemberExpression,\n                computed: accessor === '[',\n                object: object,\n                property: property\n            };\n        },\n\n        createNewExpression: function (callee, args) {\n            return {\n                type: Syntax.NewExpression,\n                callee: callee,\n                'arguments': args\n            };\n        },\n\n        createObjectExpression: function (properties) {\n            return {\n                type: Syntax.ObjectExpression,\n                properties: properties\n            };\n        },\n\n        createPostfixExpression: function (operator, argument) {\n            return {\n                type: Syntax.UpdateExpression,\n                operator: operator,\n                argument: argument,\n                prefix: false\n            };\n        },\n\n        createProgram: function (body) {\n            return {\n                type: Syntax.Program,\n                body: body\n            };\n        },\n\n        createProperty: function (kind, key, value, method, shorthand, computed) {\n            return {\n                type: Syntax.Property,\n                key: key,\n                value: value,\n                kind: kind,\n                method: method,\n                shorthand: shorthand,\n                computed: computed\n            };\n        },\n\n        createReturnStatement: function (argument) {\n            return {\n                type: Syntax.ReturnStatement,\n                argument: argument\n            };\n        },\n\n        createSequenceExpression: function (expressions) {\n            return {\n                type: Syntax.SequenceExpression,\n                expressions: expressions\n            };\n        },\n\n        createSwitchCase: function (test, consequent) {\n            return {\n                type: Syntax.SwitchCase,\n                test: test,\n                consequent: consequent\n            };\n        },\n\n        createSwitchStatement: function (discriminant, cases) {\n            return {\n                type: Syntax.SwitchStatement,\n                discriminant: discriminant,\n                cases: cases\n            };\n        },\n\n        createThisExpression: function () {\n            return {\n                type: Syntax.ThisExpression\n            };\n        },\n\n        createThrowStatement: function (argument) {\n            return {\n                type: Syntax.ThrowStatement,\n                argument: argument\n            };\n        },\n\n        createTryStatement: function (block, guardedHandlers, handlers, finalizer) {\n            return {\n                type: Syntax.TryStatement,\n                block: block,\n                guardedHandlers: guardedHandlers,\n                handlers: handlers,\n                finalizer: finalizer\n            };\n        },\n\n        createUnaryExpression: function (operator, argument) {\n            if (operator === '++' || operator === '--') {\n                return {\n                    type: Syntax.UpdateExpression,\n                    operator: operator,\n                    argument: argument,\n                    prefix: true\n                };\n            }\n            return {\n                type: Syntax.UnaryExpression,\n                operator: operator,\n                argument: argument,\n                prefix: true\n            };\n        },\n\n        createVariableDeclaration: function (declarations, kind) {\n            return {\n                type: Syntax.VariableDeclaration,\n                declarations: declarations,\n                kind: kind\n            };\n        },\n\n        createVariableDeclarator: function (id, init) {\n            return {\n                type: Syntax.VariableDeclarator,\n                id: id,\n                init: init\n            };\n        },\n\n        createWhileStatement: function (test, body) {\n            return {\n                type: Syntax.WhileStatement,\n                test: test,\n                body: body\n            };\n        },\n\n        createWithStatement: function (object, body) {\n            return {\n                type: Syntax.WithStatement,\n                object: object,\n                body: body\n            };\n        },\n\n        createTemplateElement: function (value, tail) {\n            return {\n                type: Syntax.TemplateElement,\n                value: value,\n                tail: tail\n            };\n        },\n\n        createTemplateLiteral: function (quasis, expressions) {\n            return {\n                type: Syntax.TemplateLiteral,\n                quasis: quasis,\n                expressions: expressions\n            };\n        },\n\n        createSpreadElement: function (argument) {\n            return {\n                type: Syntax.SpreadElement,\n                argument: argument\n            };\n        },\n\n        createSpreadProperty: function (argument) {\n            return {\n                type: Syntax.SpreadProperty,\n                argument: argument\n            };\n        },\n\n        createTaggedTemplateExpression: function (tag, quasi) {\n            return {\n                type: Syntax.TaggedTemplateExpression,\n                tag: tag,\n                quasi: quasi\n            };\n        },\n\n        createArrowFunctionExpression: function (params, defaults, body, rest, expression, isAsync) {\n            var arrowExpr = {\n                type: Syntax.ArrowFunctionExpression,\n                id: null,\n                params: params,\n                defaults: defaults,\n                body: body,\n                rest: rest,\n                generator: false,\n                expression: expression\n            };\n\n            if (isAsync) {\n                arrowExpr.async = true;\n            }\n\n            return arrowExpr;\n        },\n\n        createMethodDefinition: function (propertyType, kind, key, value, computed) {\n            return {\n                type: Syntax.MethodDefinition,\n                key: key,\n                value: value,\n                kind: kind,\n                'static': propertyType === ClassPropertyType.static,\n                computed: computed\n            };\n        },\n\n        createClassProperty: function (key, typeAnnotation, computed, isStatic) {\n            return {\n                type: Syntax.ClassProperty,\n                key: key,\n                typeAnnotation: typeAnnotation,\n                computed: computed,\n                static: isStatic\n            };\n        },\n\n        createClassBody: function (body) {\n            return {\n                type: Syntax.ClassBody,\n                body: body\n            };\n        },\n\n        createClassImplements: function (id, typeParameters) {\n            return {\n                type: Syntax.ClassImplements,\n                id: id,\n                typeParameters: typeParameters\n            };\n        },\n\n        createClassExpression: function (id, superClass, body, typeParameters, superTypeParameters, implemented) {\n            return {\n                type: Syntax.ClassExpression,\n                id: id,\n                superClass: superClass,\n                body: body,\n                typeParameters: typeParameters,\n                superTypeParameters: superTypeParameters,\n                implements: implemented\n            };\n        },\n\n        createClassDeclaration: function (id, superClass, body, typeParameters, superTypeParameters, implemented) {\n            return {\n                type: Syntax.ClassDeclaration,\n                id: id,\n                superClass: superClass,\n                body: body,\n                typeParameters: typeParameters,\n                superTypeParameters: superTypeParameters,\n                implements: implemented\n            };\n        },\n\n        createExportSpecifier: function (id, name) {\n            return {\n                type: Syntax.ExportSpecifier,\n                id: id,\n                name: name\n            };\n        },\n\n        createExportBatchSpecifier: function () {\n            return {\n                type: Syntax.ExportBatchSpecifier\n            };\n        },\n\n        createImportDefaultSpecifier: function (id) {\n            return {\n                type: Syntax.ImportDefaultSpecifier,\n                id: id\n            };\n        },\n\n        createImportNamespaceSpecifier: function (id) {\n            return {\n                type: Syntax.ImportNamespaceSpecifier,\n                id: id\n            };\n        },\n\n        createExportDeclaration: function (isDefault, declaration, specifiers, src) {\n            return {\n                type: Syntax.ExportDeclaration,\n                'default': !!isDefault,\n                declaration: declaration,\n                specifiers: specifiers,\n                source: src\n            };\n        },\n\n        createImportSpecifier: function (id, name) {\n            return {\n                type: Syntax.ImportSpecifier,\n                id: id,\n                name: name\n            };\n        },\n\n        createImportDeclaration: function (specifiers, src, importKind) {\n            return {\n                type: Syntax.ImportDeclaration,\n                specifiers: specifiers,\n                source: src,\n                importKind: importKind\n            };\n        },\n\n        createYieldExpression: function (argument, dlg) {\n            return {\n                type: Syntax.YieldExpression,\n                argument: argument,\n                delegate: dlg\n            };\n        },\n\n        createAwaitExpression: function (argument) {\n            return {\n                type: Syntax.AwaitExpression,\n                argument: argument\n            };\n        },\n\n        createComprehensionExpression: function (filter, blocks, body) {\n            return {\n                type: Syntax.ComprehensionExpression,\n                filter: filter,\n                blocks: blocks,\n                body: body\n            };\n        }\n\n    };\n\n    // Return true if there is a line terminator before the next token.\n\n    function peekLineTerminator() {\n        var pos, line, start, found;\n\n        pos = index;\n        line = lineNumber;\n        start = lineStart;\n        skipComment();\n        found = lineNumber !== line;\n        index = pos;\n        lineNumber = line;\n        lineStart = start;\n\n        return found;\n    }\n\n    // Throw an exception\n\n    function throwError(token, messageFormat) {\n        var error,\n            args = Array.prototype.slice.call(arguments, 2),\n            msg = messageFormat.replace(\n                /%(\\d)/g,\n                function (whole, idx) {\n                    assert(idx < args.length, 'Message reference must be in range');\n                    return args[idx];\n                }\n            );\n\n        if (typeof token.lineNumber === 'number') {\n            error = new Error('Line ' + token.lineNumber + ': ' + msg);\n            error.index = token.range[0];\n            error.lineNumber = token.lineNumber;\n            error.column = token.range[0] - lineStart + 1;\n        } else {\n            error = new Error('Line ' + lineNumber + ': ' + msg);\n            error.index = index;\n            error.lineNumber = lineNumber;\n            error.column = index - lineStart + 1;\n        }\n\n        error.description = msg;\n        throw error;\n    }\n\n    function throwErrorTolerant() {\n        try {\n            throwError.apply(null, arguments);\n        } catch (e) {\n            if (extra.errors) {\n                extra.errors.push(e);\n            } else {\n                throw e;\n            }\n        }\n    }\n\n\n    // Throw an exception because of the token.\n\n    function throwUnexpected(token) {\n        if (token.type === Token.EOF) {\n            throwError(token, Messages.UnexpectedEOS);\n        }\n\n        if (token.type === Token.NumericLiteral) {\n            throwError(token, Messages.UnexpectedNumber);\n        }\n\n        if (token.type === Token.StringLiteral || token.type === Token.JSXText) {\n            throwError(token, Messages.UnexpectedString);\n        }\n\n        if (token.type === Token.Identifier) {\n            throwError(token, Messages.UnexpectedIdentifier);\n        }\n\n        if (token.type === Token.Keyword) {\n            if (isFutureReservedWord(token.value)) {\n                throwError(token, Messages.UnexpectedReserved);\n            } else if (strict && isStrictModeReservedWord(token.value)) {\n                throwErrorTolerant(token, Messages.StrictReservedWord);\n                return;\n            }\n            throwError(token, Messages.UnexpectedToken, token.value);\n        }\n\n        if (token.type === Token.Template) {\n            throwError(token, Messages.UnexpectedTemplate, token.value.raw);\n        }\n\n        // BooleanLiteral, NullLiteral, or Punctuator.\n        throwError(token, Messages.UnexpectedToken, token.value);\n    }\n\n    // Expect the next token to match the specified punctuator.\n    // If not, an exception will be thrown.\n\n    function expect(value) {\n        var token = lex();\n        if (token.type !== Token.Punctuator || token.value !== value) {\n            throwUnexpected(token);\n        }\n    }\n\n    // Expect the next token to match the specified keyword.\n    // If not, an exception will be thrown.\n\n    function expectKeyword(keyword, contextual) {\n        var token = lex();\n        if (token.type !== (contextual ? Token.Identifier : Token.Keyword) ||\n                token.value !== keyword) {\n            throwUnexpected(token);\n        }\n    }\n\n    // Expect the next token to match the specified contextual keyword.\n    // If not, an exception will be thrown.\n\n    function expectContextualKeyword(keyword) {\n        return expectKeyword(keyword, true);\n    }\n\n    // Return true if the next token matches the specified punctuator.\n\n    function match(value) {\n        return lookahead.type === Token.Punctuator && lookahead.value === value;\n    }\n\n    // Return true if the next token matches the specified keyword\n\n    function matchKeyword(keyword, contextual) {\n        var expectedType = contextual ? Token.Identifier : Token.Keyword;\n        return lookahead.type === expectedType && lookahead.value === keyword;\n    }\n\n    // Return true if the next token matches the specified contextual keyword\n\n    function matchContextualKeyword(keyword) {\n        return matchKeyword(keyword, true);\n    }\n\n    // Return true if the next token is an assignment operator\n\n    function matchAssign() {\n        var op;\n\n        if (lookahead.type !== Token.Punctuator) {\n            return false;\n        }\n        op = lookahead.value;\n        return op === '=' ||\n            op === '*=' ||\n            op === '/=' ||\n            op === '%=' ||\n            op === '+=' ||\n            op === '-=' ||\n            op === '<<=' ||\n            op === '>>=' ||\n            op === '>>>=' ||\n            op === '&=' ||\n            op === '^=' ||\n            op === '|=';\n    }\n\n    // Note that 'yield' is treated as a keyword in strict mode, but a\n    // contextual keyword (identifier) in non-strict mode, so we need to\n    // use matchKeyword('yield', false) and matchKeyword('yield', true)\n    // (i.e. matchContextualKeyword) appropriately.\n    function matchYield() {\n        return state.yieldAllowed && matchKeyword('yield', !strict);\n    }\n\n    function matchAsync() {\n        var backtrackToken = lookahead, matches = false;\n\n        if (matchContextualKeyword('async')) {\n            lex(); // Make sure peekLineTerminator() starts after 'async'.\n            matches = !peekLineTerminator();\n            rewind(backtrackToken); // Revert the lex().\n        }\n\n        return matches;\n    }\n\n    function matchAwait() {\n        return state.awaitAllowed && matchContextualKeyword('await');\n    }\n\n    function consumeSemicolon() {\n        var line, oldIndex = index, oldLineNumber = lineNumber,\n            oldLineStart = lineStart, oldLookahead = lookahead;\n\n        // Catch the very common case first: immediately a semicolon (char #59).\n        if (source.charCodeAt(index) === 59) {\n            lex();\n            return;\n        }\n\n        line = lineNumber;\n        skipComment();\n        if (lineNumber !== line) {\n            index = oldIndex;\n            lineNumber = oldLineNumber;\n            lineStart = oldLineStart;\n            lookahead = oldLookahead;\n            return;\n        }\n\n        if (match(';')) {\n            lex();\n            return;\n        }\n\n        if (lookahead.type !== Token.EOF && !match('}')) {\n            throwUnexpected(lookahead);\n        }\n    }\n\n    // Return true if provided expression is LeftHandSideExpression\n\n    function isLeftHandSide(expr) {\n        return expr.type === Syntax.Identifier || expr.type === Syntax.MemberExpression;\n    }\n\n    function isAssignableLeftHandSide(expr) {\n        return isLeftHandSide(expr) || expr.type === Syntax.ObjectPattern || expr.type === Syntax.ArrayPattern;\n    }\n\n    // 11.1.4 Array Initialiser\n\n    function parseArrayInitialiser() {\n        var elements = [], blocks = [], filter = null, tmp, possiblecomprehension = true,\n            marker = markerCreate();\n\n        expect('[');\n        while (!match(']')) {\n            if (lookahead.value === 'for' &&\n                    lookahead.type === Token.Keyword) {\n                if (!possiblecomprehension) {\n                    throwError({}, Messages.ComprehensionError);\n                }\n                matchKeyword('for');\n                tmp = parseForStatement({ignoreBody: true});\n                tmp.of = tmp.type === Syntax.ForOfStatement;\n                tmp.type = Syntax.ComprehensionBlock;\n                if (tmp.left.kind) { // can't be let or const\n                    throwError({}, Messages.ComprehensionError);\n                }\n                blocks.push(tmp);\n            } else if (lookahead.value === 'if' &&\n                           lookahead.type === Token.Keyword) {\n                if (!possiblecomprehension) {\n                    throwError({}, Messages.ComprehensionError);\n                }\n                expectKeyword('if');\n                expect('(');\n                filter = parseExpression();\n                expect(')');\n            } else if (lookahead.value === ',' &&\n                           lookahead.type === Token.Punctuator) {\n                possiblecomprehension = false; // no longer allowed.\n                lex();\n                elements.push(null);\n            } else {\n                tmp = parseSpreadOrAssignmentExpression();\n                elements.push(tmp);\n                if (tmp && tmp.type === Syntax.SpreadElement) {\n                    if (!match(']')) {\n                        throwError({}, Messages.ElementAfterSpreadElement);\n                    }\n                } else if (!(match(']') || matchKeyword('for') || matchKeyword('if'))) {\n                    expect(','); // this lexes.\n                    possiblecomprehension = false;\n                }\n            }\n        }\n\n        expect(']');\n\n        if (filter && !blocks.length) {\n            throwError({}, Messages.ComprehensionRequiresBlock);\n        }\n\n        if (blocks.length) {\n            if (elements.length !== 1) {\n                throwError({}, Messages.ComprehensionError);\n            }\n            return markerApply(marker, delegate.createComprehensionExpression(filter, blocks, elements[0]));\n        }\n        return markerApply(marker, delegate.createArrayExpression(elements));\n    }\n\n    // 11.1.5 Object Initialiser\n\n    function parsePropertyFunction(options) {\n        var previousStrict, previousYieldAllowed, previousAwaitAllowed,\n            params, defaults, body, marker = markerCreate();\n\n        previousStrict = strict;\n        previousYieldAllowed = state.yieldAllowed;\n        state.yieldAllowed = options.generator;\n        previousAwaitAllowed = state.awaitAllowed;\n        state.awaitAllowed = options.async;\n        params = options.params || [];\n        defaults = options.defaults || [];\n\n        body = parseConciseBody();\n        if (options.name && strict && isRestrictedWord(params[0].name)) {\n            throwErrorTolerant(options.name, Messages.StrictParamName);\n        }\n        strict = previousStrict;\n        state.yieldAllowed = previousYieldAllowed;\n        state.awaitAllowed = previousAwaitAllowed;\n\n        return markerApply(marker, delegate.createFunctionExpression(\n            null,\n            params,\n            defaults,\n            body,\n            options.rest || null,\n            options.generator,\n            body.type !== Syntax.BlockStatement,\n            options.async,\n            options.returnType,\n            options.typeParameters\n        ));\n    }\n\n\n    function parsePropertyMethodFunction(options) {\n        var previousStrict, tmp, method;\n\n        previousStrict = strict;\n        strict = true;\n\n        tmp = parseParams();\n\n        if (tmp.stricted) {\n            throwErrorTolerant(tmp.stricted, tmp.message);\n        }\n\n        method = parsePropertyFunction({\n            params: tmp.params,\n            defaults: tmp.defaults,\n            rest: tmp.rest,\n            generator: options.generator,\n            async: options.async,\n            returnType: tmp.returnType,\n            typeParameters: options.typeParameters\n        });\n\n        strict = previousStrict;\n\n        return method;\n    }\n\n\n    function parseObjectPropertyKey() {\n        var marker = markerCreate(),\n            token = lex(),\n            propertyKey,\n            result;\n\n        // Note: This function is called only from parseObjectProperty(), where\n        // EOF and Punctuator tokens are already filtered out.\n\n        if (token.type === Token.StringLiteral || token.type === Token.NumericLiteral) {\n            if (strict && token.octal) {\n                throwErrorTolerant(token, Messages.StrictOctalLiteral);\n            }\n            return markerApply(marker, delegate.createLiteral(token));\n        }\n\n        if (token.type === Token.Punctuator && token.value === '[') {\n            // For computed properties we should skip the [ and ], and\n            // capture in marker only the assignment expression itself.\n            marker = markerCreate();\n            propertyKey = parseAssignmentExpression();\n            result = markerApply(marker, propertyKey);\n            expect(']');\n            return result;\n        }\n\n        return markerApply(marker, delegate.createIdentifier(token.value));\n    }\n\n    function parseObjectProperty() {\n        var token, key, id, param, computed,\n            marker = markerCreate(), returnType, typeParameters;\n\n        token = lookahead;\n        computed = (token.value === '[' && token.type === Token.Punctuator);\n\n        if (token.type === Token.Identifier || computed || matchAsync()) {\n            id = parseObjectPropertyKey();\n\n            if (match(':')) {\n                lex();\n\n                return markerApply(\n                    marker,\n                    delegate.createProperty(\n                        'init',\n                        id,\n                        parseAssignmentExpression(),\n                        false,\n                        false,\n                        computed\n                    )\n                );\n            }\n\n            if (match('(') || match('<')) {\n                if (match('<')) {\n                    typeParameters = parseTypeParameterDeclaration();\n                }\n                return markerApply(\n                    marker,\n                    delegate.createProperty(\n                        'init',\n                        id,\n                        parsePropertyMethodFunction({\n                            generator: false,\n                            async: false,\n                            typeParameters: typeParameters\n                        }),\n                        true,\n                        false,\n                        computed\n                    )\n                );\n            }\n\n            // Property Assignment: Getter and Setter.\n\n            if (token.value === 'get') {\n                computed = (lookahead.value === '[');\n                key = parseObjectPropertyKey();\n\n                expect('(');\n                expect(')');\n                if (match(':')) {\n                    returnType = parseTypeAnnotation();\n                }\n\n                return markerApply(\n                    marker,\n                    delegate.createProperty(\n                        'get',\n                        key,\n                        parsePropertyFunction({\n                            generator: false,\n                            async: false,\n                            returnType: returnType\n                        }),\n                        false,\n                        false,\n                        computed\n                    )\n                );\n            }\n\n            if (token.value === 'set') {\n                computed = (lookahead.value === '[');\n                key = parseObjectPropertyKey();\n\n                expect('(');\n                token = lookahead;\n                param = [ parseTypeAnnotatableIdentifier() ];\n                expect(')');\n                if (match(':')) {\n                    returnType = parseTypeAnnotation();\n                }\n\n                return markerApply(\n                    marker,\n                    delegate.createProperty(\n                        'set',\n                        key,\n                        parsePropertyFunction({\n                            params: param,\n                            generator: false,\n                            async: false,\n                            name: token,\n                            returnType: returnType\n                        }),\n                        false,\n                        false,\n                        computed\n                    )\n                );\n            }\n\n            if (token.value === 'async') {\n                computed = (lookahead.value === '[');\n                key = parseObjectPropertyKey();\n\n                if (match('<')) {\n                    typeParameters = parseTypeParameterDeclaration();\n                }\n\n                return markerApply(\n                    marker,\n                    delegate.createProperty(\n                        'init',\n                        key,\n                        parsePropertyMethodFunction({\n                            generator: false,\n                            async: true,\n                            typeParameters: typeParameters\n                        }),\n                        true,\n                        false,\n                        computed\n                    )\n                );\n            }\n\n            if (computed) {\n                // Computed properties can only be used with full notation.\n                throwUnexpected(lookahead);\n            }\n\n            return markerApply(\n                marker,\n                delegate.createProperty('init', id, id, false, true, false)\n            );\n        }\n\n        if (token.type === Token.EOF || token.type === Token.Punctuator) {\n            if (!match('*')) {\n                throwUnexpected(token);\n            }\n            lex();\n\n            computed = (lookahead.type === Token.Punctuator && lookahead.value === '[');\n\n            id = parseObjectPropertyKey();\n\n            if (match('<')) {\n                typeParameters = parseTypeParameterDeclaration();\n            }\n\n            if (!match('(')) {\n                throwUnexpected(lex());\n            }\n\n            return markerApply(marker, delegate.createProperty(\n                'init',\n                id,\n                parsePropertyMethodFunction({\n                    generator: true,\n                    typeParameters: typeParameters\n                }),\n                true,\n                false,\n                computed\n            ));\n        }\n        key = parseObjectPropertyKey();\n        if (match(':')) {\n            lex();\n            return markerApply(marker, delegate.createProperty('init', key, parseAssignmentExpression(), false, false, false));\n        }\n        if (match('(') || match('<')) {\n            if (match('<')) {\n                typeParameters = parseTypeParameterDeclaration();\n            }\n            return markerApply(marker, delegate.createProperty(\n                'init',\n                key,\n                parsePropertyMethodFunction({\n                    generator: false,\n                    typeParameters: typeParameters\n                }),\n                true,\n                false,\n                false\n            ));\n        }\n        throwUnexpected(lex());\n    }\n\n    function parseObjectSpreadProperty() {\n        var marker = markerCreate();\n        expect('...');\n        return markerApply(marker, delegate.createSpreadProperty(parseAssignmentExpression()));\n    }\n\n    function getFieldName(key) {\n        var toString = String;\n        if (key.type === Syntax.Identifier) {\n            return key.name;\n        }\n        return toString(key.value);\n    }\n\n    function parseObjectInitialiser() {\n        var properties = [], property, name, kind, storedKind, map = new StringMap(),\n            marker = markerCreate(), toString = String;\n\n        expect('{');\n\n        while (!match('}')) {\n            if (match('...')) {\n                property = parseObjectSpreadProperty();\n            } else {\n                property = parseObjectProperty();\n\n                if (property.key.type === Syntax.Identifier) {\n                    name = property.key.name;\n                } else {\n                    name = toString(property.key.value);\n                }\n                kind = (property.kind === 'init') ? PropertyKind.Data : (property.kind === 'get') ? PropertyKind.Get : PropertyKind.Set;\n\n                if (map.has(name)) {\n                    storedKind = map.get(name);\n                    if (storedKind === PropertyKind.Data) {\n                        if (strict && kind === PropertyKind.Data) {\n                            throwErrorTolerant({}, Messages.StrictDuplicateProperty);\n                        } else if (kind !== PropertyKind.Data) {\n                            throwErrorTolerant({}, Messages.AccessorDataProperty);\n                        }\n                    } else {\n                        if (kind === PropertyKind.Data) {\n                            throwErrorTolerant({}, Messages.AccessorDataProperty);\n                        } else if (storedKind & kind) {\n                            throwErrorTolerant({}, Messages.AccessorGetSet);\n                        }\n                    }\n                    map.set(name, storedKind | kind);\n                } else {\n                    map.set(name, kind);\n                }\n            }\n\n            properties.push(property);\n\n            if (!match('}')) {\n                expect(',');\n            }\n        }\n\n        expect('}');\n\n        return markerApply(marker, delegate.createObjectExpression(properties));\n    }\n\n    function parseTemplateElement(option) {\n        var marker, token;\n\n        if (lookahead.type !== Token.Template || (option.head && !lookahead.head)) {\n            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n        }\n\n        marker = markerCreate();\n        token = lex();\n\n        if (strict && token.octal) {\n            throwError(token, Messages.StrictOctalLiteral);\n        }\n        return markerApply(marker, delegate.createTemplateElement({ raw: token.value.raw, cooked: token.value.cooked }, token.tail));\n    }\n\n    function parseTemplateLiteral() {\n        var quasi, quasis, expressions, marker = markerCreate();\n\n        quasi = parseTemplateElement({ head: true });\n        quasis = [ quasi ];\n        expressions = [];\n\n        while (!quasi.tail) {\n            expressions.push(parseExpression());\n            quasi = parseTemplateElement({ head: false });\n            quasis.push(quasi);\n        }\n\n        return markerApply(marker, delegate.createTemplateLiteral(quasis, expressions));\n    }\n\n    // 11.1.6 The Grouping Operator\n\n    function parseGroupExpression() {\n        var expr, marker, typeAnnotation;\n\n        expect('(');\n\n        ++state.parenthesizedCount;\n\n        marker = markerCreate();\n\n        expr = parseExpression();\n\n        if (match(':')) {\n            typeAnnotation = parseTypeAnnotation();\n            expr = markerApply(marker, delegate.createTypeCast(\n                expr,\n                typeAnnotation\n            ));\n        }\n\n        expect(')');\n\n        return expr;\n    }\n\n    function matchAsyncFuncExprOrDecl() {\n        var token;\n\n        if (matchAsync()) {\n            token = lookahead2();\n            if (token.type === Token.Keyword && token.value === 'function') {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    // 11.1 Primary Expressions\n\n    function parsePrimaryExpression() {\n        var marker, type, token, expr;\n\n        type = lookahead.type;\n\n        if (type === Token.Identifier) {\n            marker = markerCreate();\n            return markerApply(marker, delegate.createIdentifier(lex().value));\n        }\n\n        if (type === Token.StringLiteral || type === Token.NumericLiteral) {\n            if (strict && lookahead.octal) {\n                throwErrorTolerant(lookahead, Messages.StrictOctalLiteral);\n            }\n            marker = markerCreate();\n            return markerApply(marker, delegate.createLiteral(lex()));\n        }\n\n        if (type === Token.Keyword) {\n            if (matchKeyword('this')) {\n                marker = markerCreate();\n                lex();\n                return markerApply(marker, delegate.createThisExpression());\n            }\n\n            if (matchKeyword('function')) {\n                return parseFunctionExpression();\n            }\n\n            if (matchKeyword('class')) {\n                return parseClassExpression();\n            }\n\n            if (matchKeyword('super')) {\n                marker = markerCreate();\n                lex();\n                return markerApply(marker, delegate.createIdentifier('super'));\n            }\n        }\n\n        if (type === Token.BooleanLiteral) {\n            marker = markerCreate();\n            token = lex();\n            token.value = (token.value === 'true');\n            return markerApply(marker, delegate.createLiteral(token));\n        }\n\n        if (type === Token.NullLiteral) {\n            marker = markerCreate();\n            token = lex();\n            token.value = null;\n            return markerApply(marker, delegate.createLiteral(token));\n        }\n\n        if (match('[')) {\n            return parseArrayInitialiser();\n        }\n\n        if (match('{')) {\n            return parseObjectInitialiser();\n        }\n\n        if (match('(')) {\n            return parseGroupExpression();\n        }\n\n        if (match('/') || match('/=')) {\n            marker = markerCreate();\n            expr = delegate.createLiteral(scanRegExp());\n            peek();\n            return markerApply(marker, expr);\n        }\n\n        if (type === Token.Template) {\n            return parseTemplateLiteral();\n        }\n\n        if (match('<')) {\n            return parseJSXElement();\n        }\n\n        throwUnexpected(lex());\n    }\n\n    // 11.2 Left-Hand-Side Expressions\n\n    function parseArguments() {\n        var args = [], arg;\n\n        expect('(');\n\n        if (!match(')')) {\n            while (index < length) {\n                arg = parseSpreadOrAssignmentExpression();\n                args.push(arg);\n\n                if (arg.type === Syntax.SpreadElement) {\n                    if (match(')')) {\n                        break;\n                    } else {\n                        throwError({}, Messages.ElementAfterSpreadElement);\n                    }\n                }\n\n                if (match(')')) {\n                    break;\n                } else {\n                    expect(',');\n                    if (match(')')) {\n                        break;\n                    }\n                }\n            }\n        }\n\n        expect(')');\n\n        return args;\n    }\n\n    function parseSpreadOrAssignmentExpression() {\n        if (match('...')) {\n            var marker = markerCreate();\n            lex();\n            return markerApply(marker, delegate.createSpreadElement(parseAssignmentExpression()));\n        }\n        return parseAssignmentExpression();\n    }\n\n    function parseNonComputedProperty() {\n        var marker = markerCreate(),\n            token = lex();\n\n        if (!isIdentifierName(token)) {\n            throwUnexpected(token);\n        }\n\n        return markerApply(marker, delegate.createIdentifier(token.value));\n    }\n\n    function parseNonComputedMember() {\n        expect('.');\n\n        return parseNonComputedProperty();\n    }\n\n    function parseComputedMember() {\n        var expr;\n\n        expect('[');\n\n        expr = parseExpression();\n\n        expect(']');\n\n        return expr;\n    }\n\n    function parseNewExpression() {\n        var callee, args, marker = markerCreate();\n\n        expectKeyword('new');\n        callee = parseLeftHandSideExpression();\n        args = match('(') ? parseArguments() : [];\n\n        return markerApply(marker, delegate.createNewExpression(callee, args));\n    }\n\n    function parseLeftHandSideExpressionAllowCall() {\n        var expr, args, marker = markerCreate();\n\n        expr = matchKeyword('new') ? parseNewExpression() : parsePrimaryExpression();\n\n        while (match('.') || match('[') || match('(') || (lookahead.type === Token.Template && lookahead.head)) {\n            if (match('(')) {\n                args = parseArguments();\n                expr = markerApply(marker, delegate.createCallExpression(expr, args));\n            } else if (match('[')) {\n                expr = markerApply(marker, delegate.createMemberExpression('[', expr, parseComputedMember()));\n            } else if (match('.')) {\n                expr = markerApply(marker, delegate.createMemberExpression('.', expr, parseNonComputedMember()));\n            } else {\n                expr = markerApply(marker, delegate.createTaggedTemplateExpression(expr, parseTemplateLiteral()));\n            }\n        }\n\n        return expr;\n    }\n\n    function parseLeftHandSideExpression() {\n        var expr, marker = markerCreate();\n\n        expr = matchKeyword('new') ? parseNewExpression() : parsePrimaryExpression();\n\n        while (match('.') || match('[') || (lookahead.type === Token.Template && lookahead.head)) {\n            if (match('[')) {\n                expr = markerApply(marker, delegate.createMemberExpression('[', expr, parseComputedMember()));\n            } else if (match('.')) {\n                expr = markerApply(marker, delegate.createMemberExpression('.', expr, parseNonComputedMember()));\n            } else {\n                expr = markerApply(marker, delegate.createTaggedTemplateExpression(expr, parseTemplateLiteral()));\n            }\n        }\n\n        return expr;\n    }\n\n    // 11.3 Postfix Expressions\n\n    function parsePostfixExpression() {\n        var marker = markerCreate(),\n            expr = parseLeftHandSideExpressionAllowCall(),\n            token;\n\n        if (lookahead.type !== Token.Punctuator) {\n            return expr;\n        }\n\n        if ((match('++') || match('--')) && !peekLineTerminator()) {\n            // 11.3.1, 11.3.2\n            if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {\n                throwErrorTolerant({}, Messages.StrictLHSPostfix);\n            }\n\n            if (!isLeftHandSide(expr)) {\n                throwError({}, Messages.InvalidLHSInAssignment);\n            }\n\n            token = lex();\n            expr = markerApply(marker, delegate.createPostfixExpression(token.value, expr));\n        }\n\n        return expr;\n    }\n\n    // 11.4 Unary Operators\n\n    function parseUnaryExpression() {\n        var marker, token, expr;\n\n        if (lookahead.type !== Token.Punctuator && lookahead.type !== Token.Keyword) {\n            return parsePostfixExpression();\n        }\n\n        if (match('++') || match('--')) {\n            marker = markerCreate();\n            token = lex();\n            expr = parseUnaryExpression();\n            // 11.4.4, 11.4.5\n            if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {\n                throwErrorTolerant({}, Messages.StrictLHSPrefix);\n            }\n\n            if (!isLeftHandSide(expr)) {\n                throwError({}, Messages.InvalidLHSInAssignment);\n            }\n\n            return markerApply(marker, delegate.createUnaryExpression(token.value, expr));\n        }\n\n        if (match('+') || match('-') || match('~') || match('!')) {\n            marker = markerCreate();\n            token = lex();\n            expr = parseUnaryExpression();\n            return markerApply(marker, delegate.createUnaryExpression(token.value, expr));\n        }\n\n        if (matchKeyword('delete') || matchKeyword('void') || matchKeyword('typeof')) {\n            marker = markerCreate();\n            token = lex();\n            expr = parseUnaryExpression();\n            expr = markerApply(marker, delegate.createUnaryExpression(token.value, expr));\n            if (strict && expr.operator === 'delete' && expr.argument.type === Syntax.Identifier) {\n                throwErrorTolerant({}, Messages.StrictDelete);\n            }\n            return expr;\n        }\n\n        return parsePostfixExpression();\n    }\n\n    function binaryPrecedence(token, allowIn) {\n        var prec = 0;\n\n        if (token.type !== Token.Punctuator && token.type !== Token.Keyword) {\n            return 0;\n        }\n\n        switch (token.value) {\n        case '||':\n            prec = 1;\n            break;\n\n        case '&&':\n            prec = 2;\n            break;\n\n        case '|':\n            prec = 3;\n            break;\n\n        case '^':\n            prec = 4;\n            break;\n\n        case '&':\n            prec = 5;\n            break;\n\n        case '==':\n        case '!=':\n        case '===':\n        case '!==':\n            prec = 6;\n            break;\n\n        case '<':\n        case '>':\n        case '<=':\n        case '>=':\n        case 'instanceof':\n            prec = 7;\n            break;\n\n        case 'in':\n            prec = allowIn ? 7 : 0;\n            break;\n\n        case '<<':\n        case '>>':\n        case '>>>':\n            prec = 8;\n            break;\n\n        case '+':\n        case '-':\n            prec = 9;\n            break;\n\n        case '*':\n        case '/':\n        case '%':\n            prec = 11;\n            break;\n\n        default:\n            break;\n        }\n\n        return prec;\n    }\n\n    // 11.5 Multiplicative Operators\n    // 11.6 Additive Operators\n    // 11.7 Bitwise Shift Operators\n    // 11.8 Relational Operators\n    // 11.9 Equality Operators\n    // 11.10 Binary Bitwise Operators\n    // 11.11 Binary Logical Operators\n\n    function parseBinaryExpression() {\n        var expr, token, prec, previousAllowIn, stack, right, operator, left, i,\n            marker, markers;\n\n        previousAllowIn = state.allowIn;\n        state.allowIn = true;\n\n        marker = markerCreate();\n        left = parseUnaryExpression();\n\n        token = lookahead;\n        prec = binaryPrecedence(token, previousAllowIn);\n        if (prec === 0) {\n            return left;\n        }\n        token.prec = prec;\n        lex();\n\n        markers = [marker, markerCreate()];\n        right = parseUnaryExpression();\n\n        stack = [left, token, right];\n\n        while ((prec = binaryPrecedence(lookahead, previousAllowIn)) > 0) {\n\n            // Reduce: make a binary expression from the three topmost entries.\n            while ((stack.length > 2) && (prec <= stack[stack.length - 2].prec)) {\n                right = stack.pop();\n                operator = stack.pop().value;\n                left = stack.pop();\n                expr = delegate.createBinaryExpression(operator, left, right);\n                markers.pop();\n                marker = markers.pop();\n                markerApply(marker, expr);\n                stack.push(expr);\n                markers.push(marker);\n            }\n\n            // Shift.\n            token = lex();\n            token.prec = prec;\n            stack.push(token);\n            markers.push(markerCreate());\n            expr = parseUnaryExpression();\n            stack.push(expr);\n        }\n\n        state.allowIn = previousAllowIn;\n\n        // Final reduce to clean-up the stack.\n        i = stack.length - 1;\n        expr = stack[i];\n        markers.pop();\n        while (i > 1) {\n            expr = delegate.createBinaryExpression(stack[i - 1].value, stack[i - 2], expr);\n            i -= 2;\n            marker = markers.pop();\n            markerApply(marker, expr);\n        }\n\n        return expr;\n    }\n\n\n    // 11.12 Conditional Operator\n\n    function parseConditionalExpression() {\n        var expr, previousAllowIn, consequent, alternate, marker = markerCreate();\n        expr = parseBinaryExpression();\n\n        if (match('?')) {\n            lex();\n            previousAllowIn = state.allowIn;\n            state.allowIn = true;\n            consequent = parseAssignmentExpression();\n            state.allowIn = previousAllowIn;\n            expect(':');\n            alternate = parseAssignmentExpression();\n\n            expr = markerApply(marker, delegate.createConditionalExpression(expr, consequent, alternate));\n        }\n\n        return expr;\n    }\n\n    // 11.13 Assignment Operators\n\n    // 12.14.5 AssignmentPattern\n\n    function reinterpretAsAssignmentBindingPattern(expr) {\n        var i, len, property, element;\n\n        if (expr.type === Syntax.ObjectExpression) {\n            expr.type = Syntax.ObjectPattern;\n            for (i = 0, len = expr.properties.length; i < len; i += 1) {\n                property = expr.properties[i];\n                if (property.type === Syntax.SpreadProperty) {\n                    if (i < len - 1) {\n                        throwError({}, Messages.PropertyAfterSpreadProperty);\n                    }\n                    reinterpretAsAssignmentBindingPattern(property.argument);\n                } else {\n                    if (property.kind !== 'init') {\n                        throwError({}, Messages.InvalidLHSInAssignment);\n                    }\n                    reinterpretAsAssignmentBindingPattern(property.value);\n                }\n            }\n        } else if (expr.type === Syntax.ArrayExpression) {\n            expr.type = Syntax.ArrayPattern;\n            for (i = 0, len = expr.elements.length; i < len; i += 1) {\n                element = expr.elements[i];\n                /* istanbul ignore else */\n                if (element) {\n                    reinterpretAsAssignmentBindingPattern(element);\n                }\n            }\n        } else if (expr.type === Syntax.Identifier) {\n            if (isRestrictedWord(expr.name)) {\n                throwError({}, Messages.InvalidLHSInAssignment);\n            }\n        } else if (expr.type === Syntax.SpreadElement) {\n            reinterpretAsAssignmentBindingPattern(expr.argument);\n            if (expr.argument.type === Syntax.ObjectPattern) {\n                throwError({}, Messages.ObjectPatternAsSpread);\n            }\n        } else {\n            /* istanbul ignore else */\n            if (expr.type !== Syntax.MemberExpression && expr.type !== Syntax.CallExpression && expr.type !== Syntax.NewExpression) {\n                throwError({}, Messages.InvalidLHSInAssignment);\n            }\n        }\n    }\n\n    // 13.2.3 BindingPattern\n\n    function reinterpretAsDestructuredParameter(options, expr) {\n        var i, len, property, element;\n\n        if (expr.type === Syntax.ObjectExpression) {\n            expr.type = Syntax.ObjectPattern;\n            for (i = 0, len = expr.properties.length; i < len; i += 1) {\n                property = expr.properties[i];\n                if (property.type === Syntax.SpreadProperty) {\n                    if (i < len - 1) {\n                        throwError({}, Messages.PropertyAfterSpreadProperty);\n                    }\n                    reinterpretAsDestructuredParameter(options, property.argument);\n                } else {\n                    if (property.kind !== 'init') {\n                        throwError({}, Messages.InvalidLHSInFormalsList);\n                    }\n                    reinterpretAsDestructuredParameter(options, property.value);\n                }\n            }\n        } else if (expr.type === Syntax.ArrayExpression) {\n            expr.type = Syntax.ArrayPattern;\n            for (i = 0, len = expr.elements.length; i < len; i += 1) {\n                element = expr.elements[i];\n                if (element) {\n                    reinterpretAsDestructuredParameter(options, element);\n                }\n            }\n        } else if (expr.type === Syntax.Identifier) {\n            validateParam(options, expr, expr.name);\n        } else if (expr.type === Syntax.SpreadElement) {\n            // BindingRestElement only allows BindingIdentifier\n            if (expr.argument.type !== Syntax.Identifier) {\n                throwError({}, Messages.InvalidLHSInFormalsList);\n            }\n            validateParam(options, expr.argument, expr.argument.name);\n        } else {\n            throwError({}, Messages.InvalidLHSInFormalsList);\n        }\n    }\n\n    function reinterpretAsCoverFormalsList(expressions) {\n        var i, len, param, params, defaults, defaultCount, options, rest;\n\n        params = [];\n        defaults = [];\n        defaultCount = 0;\n        rest = null;\n        options = {\n            paramSet: new StringMap()\n        };\n\n        for (i = 0, len = expressions.length; i < len; i += 1) {\n            param = expressions[i];\n            if (param.type === Syntax.Identifier) {\n                params.push(param);\n                defaults.push(null);\n                validateParam(options, param, param.name);\n            } else if (param.type === Syntax.ObjectExpression || param.type === Syntax.ArrayExpression) {\n                reinterpretAsDestructuredParameter(options, param);\n                params.push(param);\n                defaults.push(null);\n            } else if (param.type === Syntax.SpreadElement) {\n                assert(i === len - 1, 'It is guaranteed that SpreadElement is last element by parseExpression');\n                if (param.argument.type !== Syntax.Identifier) {\n                    throwError({}, Messages.InvalidLHSInFormalsList);\n                }\n                reinterpretAsDestructuredParameter(options, param.argument);\n                rest = param.argument;\n            } else if (param.type === Syntax.AssignmentExpression) {\n                params.push(param.left);\n                defaults.push(param.right);\n                ++defaultCount;\n                validateParam(options, param.left, param.left.name);\n            } else {\n                return null;\n            }\n        }\n\n        if (options.message === Messages.StrictParamDupe) {\n            throwError(\n                strict ? options.stricted : options.firstRestricted,\n                options.message\n            );\n        }\n\n        if (defaultCount === 0) {\n            defaults = [];\n        }\n\n        return {\n            params: params,\n            defaults: defaults,\n            rest: rest,\n            stricted: options.stricted,\n            firstRestricted: options.firstRestricted,\n            message: options.message\n        };\n    }\n\n    function parseArrowFunctionExpression(options, marker) {\n        var previousStrict, previousYieldAllowed, previousAwaitAllowed, body;\n\n        expect('=>');\n\n        previousStrict = strict;\n        previousYieldAllowed = state.yieldAllowed;\n        state.yieldAllowed = false;\n        previousAwaitAllowed = state.awaitAllowed;\n        state.awaitAllowed = !!options.async;\n        body = parseConciseBody();\n\n        if (strict && options.firstRestricted) {\n            throwError(options.firstRestricted, options.message);\n        }\n        if (strict && options.stricted) {\n            throwErrorTolerant(options.stricted, options.message);\n        }\n\n        strict = previousStrict;\n        state.yieldAllowed = previousYieldAllowed;\n        state.awaitAllowed = previousAwaitAllowed;\n\n        return markerApply(marker, delegate.createArrowFunctionExpression(\n            options.params,\n            options.defaults,\n            body,\n            options.rest,\n            body.type !== Syntax.BlockStatement,\n            !!options.async\n        ));\n    }\n\n    function parseAssignmentExpression() {\n        var marker, expr, token, params, oldParenthesizedCount,\n            startsWithParen = false, backtrackToken = lookahead,\n            possiblyAsync = false;\n\n        if (matchYield()) {\n            return parseYieldExpression();\n        }\n\n        if (matchAwait()) {\n            return parseAwaitExpression();\n        }\n\n        oldParenthesizedCount = state.parenthesizedCount;\n\n        marker = markerCreate();\n\n        if (matchAsyncFuncExprOrDecl()) {\n            return parseFunctionExpression();\n        }\n\n        if (matchAsync()) {\n            // We can't be completely sure that this 'async' token is\n            // actually a contextual keyword modifying a function\n            // expression, so we might have to un-lex() it later by\n            // calling rewind(backtrackToken).\n            possiblyAsync = true;\n            lex();\n        }\n\n        if (match('(')) {\n            token = lookahead2();\n            if ((token.type === Token.Punctuator && token.value === ')') || token.value === '...') {\n                params = parseParams();\n                if (!match('=>')) {\n                    throwUnexpected(lex());\n                }\n                params.async = possiblyAsync;\n                return parseArrowFunctionExpression(params, marker);\n            }\n            startsWithParen = true;\n        }\n\n        token = lookahead;\n\n        // If the 'async' keyword is not followed by a '(' character or an\n        // identifier, then it can't be an arrow function modifier, and we\n        // should interpret it as a normal identifer.\n        if (possiblyAsync && !match('(') && token.type !== Token.Identifier) {\n            possiblyAsync = false;\n            rewind(backtrackToken);\n        }\n\n        expr = parseConditionalExpression();\n\n        if (match('=>') &&\n                (state.parenthesizedCount === oldParenthesizedCount ||\n                state.parenthesizedCount === (oldParenthesizedCount + 1))) {\n            if (expr.type === Syntax.Identifier) {\n                params = reinterpretAsCoverFormalsList([ expr ]);\n            } else if (expr.type === Syntax.AssignmentExpression ||\n                    expr.type === Syntax.ArrayExpression ||\n                    expr.type === Syntax.ObjectExpression) {\n                if (!startsWithParen) {\n                    throwUnexpected(lex());\n                }\n                params = reinterpretAsCoverFormalsList([ expr ]);\n            } else if (expr.type === Syntax.SequenceExpression) {\n                params = reinterpretAsCoverFormalsList(expr.expressions);\n            }\n            if (params) {\n                params.async = possiblyAsync;\n                return parseArrowFunctionExpression(params, marker);\n            }\n        }\n\n        // If we haven't returned by now, then the 'async' keyword was not\n        // a function modifier, and we should rewind and interpret it as a\n        // normal identifier.\n        if (possiblyAsync) {\n            possiblyAsync = false;\n            rewind(backtrackToken);\n            expr = parseConditionalExpression();\n        }\n\n        if (matchAssign()) {\n            // 11.13.1\n            if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {\n                throwErrorTolerant(token, Messages.StrictLHSAssignment);\n            }\n\n            // ES.next draf 11.13 Runtime Semantics step 1\n            if (match('=') && (expr.type === Syntax.ObjectExpression || expr.type === Syntax.ArrayExpression)) {\n                reinterpretAsAssignmentBindingPattern(expr);\n            } else if (!isLeftHandSide(expr)) {\n                throwError({}, Messages.InvalidLHSInAssignment);\n            }\n\n            expr = markerApply(marker, delegate.createAssignmentExpression(lex().value, expr, parseAssignmentExpression()));\n        }\n\n        return expr;\n    }\n\n    // 11.14 Comma Operator\n\n    function parseExpression() {\n        var marker, expr, expressions, sequence, spreadFound, possibleArrow;\n\n        marker = markerCreate();\n        expr = parseAssignmentExpression();\n        expressions = [ expr ];\n\n        if (match(',')) {\n            while (index < length) {\n                if (!match(',')) {\n                    break;\n                }\n\n                lex();\n\n                if (match(')')) {\n                    possibleArrow = lookahead2();\n                    if (\n                        possibleArrow.type === Token.Punctuator &&\n                        possibleArrow.value === '=>'\n                    ) {\n                        break;\n                    }\n                }\n\n                expr = parseSpreadOrAssignmentExpression();\n                expressions.push(expr);\n\n                if (expr.type === Syntax.SpreadElement) {\n                    spreadFound = true;\n                    if (!match(')')) {\n                        throwError({}, Messages.ElementAfterSpreadElement);\n                    }\n                    break;\n                }\n            }\n\n            if (expressions.length > 1) {\n                sequence = markerApply(marker, delegate.createSequenceExpression(expressions));\n            }\n        }\n\n        if (spreadFound && lookahead2().value !== '=>') {\n            throwError({}, Messages.IllegalSpread);\n        }\n\n        return sequence || expr;\n    }\n\n    // 12.1 Block\n\n    function parseStatementList() {\n        var list = [],\n            statement;\n\n        while (index < length) {\n            if (match('}')) {\n                break;\n            }\n            statement = parseSourceElement();\n            if (typeof statement === 'undefined') {\n                break;\n            }\n            list.push(statement);\n        }\n\n        return list;\n    }\n\n    function parseBlock() {\n        var block, marker = markerCreate();\n\n        expect('{');\n\n        block = parseStatementList();\n\n        expect('}');\n\n        return markerApply(marker, delegate.createBlockStatement(block));\n    }\n\n    // 12.2 Variable Statement\n\n    function parseTypeParameterDeclaration() {\n        var marker = markerCreate(), paramTypes = [];\n\n        expect('<');\n        while (!match('>')) {\n            paramTypes.push(parseTypeAnnotatableIdentifier());\n            if (!match('>')) {\n                expect(',');\n            }\n        }\n        expect('>');\n\n        return markerApply(marker, delegate.createTypeParameterDeclaration(\n            paramTypes\n        ));\n    }\n\n    function parseTypeParameterInstantiation() {\n        var marker = markerCreate(), oldInType = state.inType, paramTypes = [];\n\n        state.inType = true;\n\n        expect('<');\n        while (!match('>')) {\n            paramTypes.push(parseType());\n            if (!match('>')) {\n                expect(',');\n            }\n        }\n        expect('>');\n\n        state.inType = oldInType;\n\n        return markerApply(marker, delegate.createTypeParameterInstantiation(\n            paramTypes\n        ));\n    }\n\n    function parseObjectTypeIndexer(marker, isStatic) {\n        var id, key, value;\n\n        expect('[');\n        id = parseObjectPropertyKey();\n        expect(':');\n        key = parseType();\n        expect(']');\n        expect(':');\n        value = parseType();\n\n        return markerApply(marker, delegate.createObjectTypeIndexer(\n            id,\n            key,\n            value,\n            isStatic\n        ));\n    }\n\n    function parseObjectTypeMethodish(marker) {\n        var params = [], rest = null, returnType, typeParameters = null;\n        if (match('<')) {\n            typeParameters = parseTypeParameterDeclaration();\n        }\n\n        expect('(');\n        while (lookahead.type === Token.Identifier) {\n            params.push(parseFunctionTypeParam());\n            if (!match(')')) {\n                expect(',');\n            }\n        }\n\n        if (match('...')) {\n            lex();\n            rest = parseFunctionTypeParam();\n        }\n        expect(')');\n        expect(':');\n        returnType = parseType();\n\n        return markerApply(marker, delegate.createFunctionTypeAnnotation(\n            params,\n            returnType,\n            rest,\n            typeParameters\n        ));\n    }\n\n    function parseObjectTypeMethod(marker, isStatic, key) {\n        var optional = false, value;\n        value = parseObjectTypeMethodish(marker);\n\n        return markerApply(marker, delegate.createObjectTypeProperty(\n            key,\n            value,\n            optional,\n            isStatic\n        ));\n    }\n\n    function parseObjectTypeCallProperty(marker, isStatic) {\n        var valueMarker = markerCreate();\n        return markerApply(marker, delegate.createObjectTypeCallProperty(\n            parseObjectTypeMethodish(valueMarker),\n            isStatic\n        ));\n    }\n\n    function parseObjectType(allowStatic) {\n        var callProperties = [], indexers = [], marker, optional = false,\n            properties = [], propertyKey, propertyTypeAnnotation,\n            token, isStatic, matchStatic;\n\n        expect('{');\n\n        while (!match('}')) {\n            marker = markerCreate();\n            matchStatic =\n                   strict\n                   ? matchKeyword('static')\n                   : matchContextualKeyword('static');\n\n            if (allowStatic && matchStatic) {\n                token = lex();\n                isStatic = true;\n            }\n\n            if (match('[')) {\n                indexers.push(parseObjectTypeIndexer(marker, isStatic));\n            } else if (match('(') || match('<')) {\n                callProperties.push(parseObjectTypeCallProperty(marker, allowStatic));\n            } else {\n                if (isStatic && match(':')) {\n                    propertyKey = markerApply(marker, delegate.createIdentifier(token));\n                    throwErrorTolerant(token, Messages.StrictReservedWord);\n                } else {\n                    propertyKey = parseObjectPropertyKey();\n                }\n                if (match('<') || match('(')) {\n                    // This is a method property\n                    properties.push(parseObjectTypeMethod(marker, isStatic, propertyKey));\n                } else {\n                    if (match('?')) {\n                        lex();\n                        optional = true;\n                    }\n                    expect(':');\n                    propertyTypeAnnotation = parseType();\n                    properties.push(markerApply(marker, delegate.createObjectTypeProperty(\n                        propertyKey,\n                        propertyTypeAnnotation,\n                        optional,\n                        isStatic\n                    )));\n                }\n            }\n\n            if (match(';') || match(',')) {\n                lex();\n            } else if (!match('}')) {\n                throwUnexpected(lookahead);\n            }\n        }\n\n        expect('}');\n\n        return delegate.createObjectTypeAnnotation(\n            properties,\n            indexers,\n            callProperties\n        );\n    }\n\n    function parseGenericType() {\n        var marker = markerCreate(),\n            typeParameters = null, typeIdentifier;\n\n        typeIdentifier = parseVariableIdentifier();\n\n        while (match('.')) {\n            expect('.');\n            typeIdentifier = markerApply(marker, delegate.createQualifiedTypeIdentifier(\n                typeIdentifier,\n                parseVariableIdentifier()\n            ));\n        }\n\n        if (match('<')) {\n            typeParameters = parseTypeParameterInstantiation();\n        }\n\n        return markerApply(marker, delegate.createGenericTypeAnnotation(\n            typeIdentifier,\n            typeParameters\n        ));\n    }\n\n    function parseVoidType() {\n        var marker = markerCreate();\n        expectKeyword('void');\n        return markerApply(marker, delegate.createVoidTypeAnnotation());\n    }\n\n    function parseTypeofType() {\n        var argument, marker = markerCreate();\n        expectKeyword('typeof');\n        argument = parsePrimaryType();\n        return markerApply(marker, delegate.createTypeofTypeAnnotation(\n            argument\n        ));\n    }\n\n    function parseTupleType() {\n        var marker = markerCreate(), types = [];\n        expect('[');\n        // We allow trailing commas\n        while (index < length && !match(']')) {\n            types.push(parseType());\n            if (match(']')) {\n                break;\n            }\n            expect(',');\n        }\n        expect(']');\n        return markerApply(marker, delegate.createTupleTypeAnnotation(\n            types\n        ));\n    }\n\n    function parseFunctionTypeParam() {\n        var marker = markerCreate(), name, optional = false, typeAnnotation;\n        name = parseVariableIdentifier();\n        if (match('?')) {\n            lex();\n            optional = true;\n        }\n        expect(':');\n        typeAnnotation = parseType();\n        return markerApply(marker, delegate.createFunctionTypeParam(\n            name,\n            typeAnnotation,\n            optional\n        ));\n    }\n\n    function parseFunctionTypeParams() {\n        var ret = { params: [], rest: null };\n        while (lookahead.type === Token.Identifier) {\n            ret.params.push(parseFunctionTypeParam());\n            if (!match(')')) {\n                expect(',');\n            }\n        }\n\n        if (match('...')) {\n            lex();\n            ret.rest = parseFunctionTypeParam();\n        }\n        return ret;\n    }\n\n    // The parsing of types roughly parallels the parsing of expressions, and\n    // primary types are kind of like primary expressions...they're the\n    // primitives with which other types are constructed.\n    function parsePrimaryType() {\n        var params = null, returnType = null,\n            marker = markerCreate(), rest = null, tmp,\n            typeParameters, token, type, isGroupedType = false;\n\n        switch (lookahead.type) {\n        case Token.Identifier:\n            switch (lookahead.value) {\n            case 'any':\n                lex();\n                return markerApply(marker, delegate.createAnyTypeAnnotation());\n            case 'bool':  // fallthrough\n            case 'boolean':\n                lex();\n                return markerApply(marker, delegate.createBooleanTypeAnnotation());\n            case 'number':\n                lex();\n                return markerApply(marker, delegate.createNumberTypeAnnotation());\n            case 'string':\n                lex();\n                return markerApply(marker, delegate.createStringTypeAnnotation());\n            }\n            return markerApply(marker, parseGenericType());\n        case Token.Punctuator:\n            switch (lookahead.value) {\n            case '{':\n                return markerApply(marker, parseObjectType());\n            case '[':\n                return parseTupleType();\n            case '<':\n                typeParameters = parseTypeParameterDeclaration();\n                expect('(');\n                tmp = parseFunctionTypeParams();\n                params = tmp.params;\n                rest = tmp.rest;\n                expect(')');\n\n                expect('=>');\n\n                returnType = parseType();\n\n                return markerApply(marker, delegate.createFunctionTypeAnnotation(\n                    params,\n                    returnType,\n                    rest,\n                    typeParameters\n                ));\n            case '(':\n                lex();\n                // Check to see if this is actually a grouped type\n                if (!match(')') && !match('...')) {\n                    if (lookahead.type === Token.Identifier) {\n                        token = lookahead2();\n                        isGroupedType = token.value !== '?' && token.value !== ':';\n                    } else {\n                        isGroupedType = true;\n                    }\n                }\n\n                if (isGroupedType) {\n                    type = parseType();\n                    expect(')');\n\n                    // If we see a => next then someone was probably confused about\n                    // function types, so we can provide a better error message\n                    if (match('=>')) {\n                        throwError({}, Messages.ConfusedAboutFunctionType);\n                    }\n\n                    return type;\n                }\n\n                tmp = parseFunctionTypeParams();\n                params = tmp.params;\n                rest = tmp.rest;\n\n                expect(')');\n\n                expect('=>');\n\n                returnType = parseType();\n\n                return markerApply(marker, delegate.createFunctionTypeAnnotation(\n                    params,\n                    returnType,\n                    rest,\n                    null /* typeParameters */\n                ));\n            }\n            break;\n        case Token.Keyword:\n            switch (lookahead.value) {\n            case 'void':\n                return markerApply(marker, parseVoidType());\n            case 'typeof':\n                return markerApply(marker, parseTypeofType());\n            }\n            break;\n        case Token.StringLiteral:\n            token = lex();\n            if (token.octal) {\n                throwError(token, Messages.StrictOctalLiteral);\n            }\n            return markerApply(marker, delegate.createStringLiteralTypeAnnotation(\n                token\n            ));\n        }\n\n        throwUnexpected(lookahead);\n    }\n\n    function parsePostfixType() {\n        var marker = markerCreate(), t = parsePrimaryType();\n        if (match('[')) {\n            expect('[');\n            expect(']');\n            return markerApply(marker, delegate.createArrayTypeAnnotation(t));\n        }\n        return t;\n    }\n\n    function parsePrefixType() {\n        var marker = markerCreate();\n        if (match('?')) {\n            lex();\n            return markerApply(marker, delegate.createNullableTypeAnnotation(\n                parsePrefixType()\n            ));\n        }\n        return parsePostfixType();\n    }\n\n\n    function parseIntersectionType() {\n        var marker = markerCreate(), type, types;\n        type = parsePrefixType();\n        types = [type];\n        while (match('&')) {\n            lex();\n            types.push(parsePrefixType());\n        }\n\n        return types.length === 1 ?\n                type :\n                markerApply(marker, delegate.createIntersectionTypeAnnotation(\n                    types\n                ));\n    }\n\n    function parseUnionType() {\n        var marker = markerCreate(), type, types;\n        type = parseIntersectionType();\n        types = [type];\n        while (match('|')) {\n            lex();\n            types.push(parseIntersectionType());\n        }\n        return types.length === 1 ?\n                type :\n                markerApply(marker, delegate.createUnionTypeAnnotation(\n                    types\n                ));\n    }\n\n    function parseType() {\n        var oldInType = state.inType, type;\n        state.inType = true;\n\n        type = parseUnionType();\n\n        state.inType = oldInType;\n        return type;\n    }\n\n    function parseTypeAnnotation() {\n        var marker = markerCreate(), type;\n\n        expect(':');\n        type = parseType();\n\n        return markerApply(marker, delegate.createTypeAnnotation(type));\n    }\n\n    function parseVariableIdentifier() {\n        var marker = markerCreate(),\n            token = lex();\n\n        if (token.type !== Token.Identifier) {\n            throwUnexpected(token);\n        }\n\n        return markerApply(marker, delegate.createIdentifier(token.value));\n    }\n\n    function parseTypeAnnotatableIdentifier(requireTypeAnnotation, canBeOptionalParam) {\n        var marker = markerCreate(),\n            ident = parseVariableIdentifier(),\n            isOptionalParam = false;\n\n        if (canBeOptionalParam && match('?')) {\n            expect('?');\n            isOptionalParam = true;\n        }\n\n        if (requireTypeAnnotation || match(':')) {\n            ident.typeAnnotation = parseTypeAnnotation();\n            ident = markerApply(marker, ident);\n        }\n\n        if (isOptionalParam) {\n            ident.optional = true;\n            ident = markerApply(marker, ident);\n        }\n\n        return ident;\n    }\n\n    function parseVariableDeclaration(kind) {\n        var id,\n            marker = markerCreate(),\n            init = null,\n            typeAnnotationMarker = markerCreate();\n        if (match('{')) {\n            id = parseObjectInitialiser();\n            reinterpretAsAssignmentBindingPattern(id);\n            if (match(':')) {\n                id.typeAnnotation = parseTypeAnnotation();\n                markerApply(typeAnnotationMarker, id);\n            }\n        } else if (match('[')) {\n            id = parseArrayInitialiser();\n            reinterpretAsAssignmentBindingPattern(id);\n            if (match(':')) {\n                id.typeAnnotation = parseTypeAnnotation();\n                markerApply(typeAnnotationMarker, id);\n            }\n        } else {\n            /* istanbul ignore next */\n            id = state.allowKeyword ? parseNonComputedProperty() : parseTypeAnnotatableIdentifier();\n            // 12.2.1\n            if (strict && isRestrictedWord(id.name)) {\n                throwErrorTolerant({}, Messages.StrictVarName);\n            }\n        }\n\n        if (kind === 'const') {\n            if (!match('=')) {\n                throwError({}, Messages.NoUninitializedConst);\n            }\n            expect('=');\n            init = parseAssignmentExpression();\n        } else if (match('=')) {\n            lex();\n            init = parseAssignmentExpression();\n        }\n\n        return markerApply(marker, delegate.createVariableDeclarator(id, init));\n    }\n\n    function parseVariableDeclarationList(kind) {\n        var list = [];\n\n        do {\n            list.push(parseVariableDeclaration(kind));\n            if (!match(',')) {\n                break;\n            }\n            lex();\n        } while (index < length);\n\n        return list;\n    }\n\n    function parseVariableStatement() {\n        var declarations, marker = markerCreate();\n\n        expectKeyword('var');\n\n        declarations = parseVariableDeclarationList();\n\n        consumeSemicolon();\n\n        return markerApply(marker, delegate.createVariableDeclaration(declarations, 'var'));\n    }\n\n    // kind may be `const` or `let`\n    // Both are experimental and not in the specification yet.\n    // see http://wiki.ecmascript.org/doku.php?id=harmony:const\n    // and http://wiki.ecmascript.org/doku.php?id=harmony:let\n    function parseConstLetDeclaration(kind) {\n        var declarations, marker = markerCreate();\n\n        expectKeyword(kind);\n\n        declarations = parseVariableDeclarationList(kind);\n\n        consumeSemicolon();\n\n        return markerApply(marker, delegate.createVariableDeclaration(declarations, kind));\n    }\n\n    // people.mozilla.org/~jorendorff/es6-draft.html\n\n    function parseModuleSpecifier() {\n        var marker = markerCreate(),\n            specifier;\n\n        if (lookahead.type !== Token.StringLiteral) {\n            throwError({}, Messages.InvalidModuleSpecifier);\n        }\n        specifier = delegate.createLiteral(lex());\n        return markerApply(marker, specifier);\n    }\n\n    function parseExportBatchSpecifier() {\n        var marker = markerCreate();\n        expect('*');\n        return markerApply(marker, delegate.createExportBatchSpecifier());\n    }\n\n    function parseExportSpecifier() {\n        var id, name = null, marker = markerCreate();\n        if (matchKeyword('default')) {\n            lex();\n            id = markerApply(marker, delegate.createIdentifier('default'));\n            // export {default} from \"something\";\n        } else {\n            id = parseVariableIdentifier();\n        }\n        if (matchContextualKeyword('as')) {\n            lex();\n            name = parseNonComputedProperty();\n        }\n\n        return markerApply(marker, delegate.createExportSpecifier(id, name));\n    }\n\n    function parseExportDeclaration() {\n        var declaration = null,\n            possibleIdentifierToken, sourceElement,\n            isExportFromIdentifier,\n            src = null, specifiers = [],\n            marker = markerCreate();\n\n        expectKeyword('export');\n\n        if (matchKeyword('default')) {\n            // covers:\n            // export default ...\n            lex();\n            if (matchKeyword('function') || matchKeyword('class')) {\n                possibleIdentifierToken = lookahead2();\n                if (isIdentifierName(possibleIdentifierToken)) {\n                    // covers:\n                    // export default function foo () {}\n                    // export default class foo {}\n                    sourceElement = parseSourceElement();\n                    return markerApply(marker, delegate.createExportDeclaration(true, sourceElement, [sourceElement.id], null));\n                }\n                // covers:\n                // export default function () {}\n                // export default class {}\n                switch (lookahead.value) {\n                case 'class':\n                    return markerApply(marker, delegate.createExportDeclaration(true, parseClassExpression(), [], null));\n                case 'function':\n                    return markerApply(marker, delegate.createExportDeclaration(true, parseFunctionExpression(), [], null));\n                }\n            }\n\n            if (matchContextualKeyword('from')) {\n                throwError({}, Messages.UnexpectedToken, lookahead.value);\n            }\n\n            // covers:\n            // export default {};\n            // export default [];\n            if (match('{')) {\n                declaration = parseObjectInitialiser();\n            } else if (match('[')) {\n                declaration = parseArrayInitialiser();\n            } else {\n                declaration = parseAssignmentExpression();\n            }\n            consumeSemicolon();\n            return markerApply(marker, delegate.createExportDeclaration(true, declaration, [], null));\n        }\n\n        // non-default export\n        if (lookahead.type === Token.Keyword || matchContextualKeyword('type')) {\n            // covers:\n            // export var f = 1;\n            switch (lookahead.value) {\n            case 'type':\n            case 'let':\n            case 'const':\n            case 'var':\n            case 'class':\n            case 'function':\n                return markerApply(marker, delegate.createExportDeclaration(false, parseSourceElement(), specifiers, null));\n            }\n        }\n\n        if (match('*')) {\n            // covers:\n            // export * from \"foo\";\n            specifiers.push(parseExportBatchSpecifier());\n\n            if (!matchContextualKeyword('from')) {\n                throwError({}, lookahead.value ?\n                        Messages.UnexpectedToken : Messages.MissingFromClause, lookahead.value);\n            }\n            lex();\n            src = parseModuleSpecifier();\n            consumeSemicolon();\n\n            return markerApply(marker, delegate.createExportDeclaration(false, null, specifiers, src));\n        }\n\n        expect('{');\n        if (!match('}')) {\n            do {\n                isExportFromIdentifier = isExportFromIdentifier || matchKeyword('default');\n                specifiers.push(parseExportSpecifier());\n            } while (match(',') && lex());\n        }\n        expect('}');\n\n        if (matchContextualKeyword('from')) {\n            // covering:\n            // export {default} from \"foo\";\n            // export {foo} from \"foo\";\n            lex();\n            src = parseModuleSpecifier();\n            consumeSemicolon();\n        } else if (isExportFromIdentifier) {\n            // covering:\n            // export {default}; // missing fromClause\n            throwError({}, lookahead.value ?\n                    Messages.UnexpectedToken : Messages.MissingFromClause, lookahead.value);\n        } else {\n            // cover\n            // export {foo};\n            consumeSemicolon();\n        }\n        return markerApply(marker, delegate.createExportDeclaration(false, declaration, specifiers, src));\n    }\n\n\n    function parseImportSpecifier() {\n        // import {<foo as bar>} ...;\n        var id, name = null, marker = markerCreate();\n\n        id = parseNonComputedProperty();\n        if (matchContextualKeyword('as')) {\n            lex();\n            name = parseVariableIdentifier();\n        }\n\n        return markerApply(marker, delegate.createImportSpecifier(id, name));\n    }\n\n    function parseNamedImports() {\n        var specifiers = [];\n        // {foo, bar as bas}\n        expect('{');\n        if (!match('}')) {\n            do {\n                specifiers.push(parseImportSpecifier());\n            } while (match(',') && lex());\n        }\n        expect('}');\n        return specifiers;\n    }\n\n    function parseImportDefaultSpecifier() {\n        // import <foo> ...;\n        var id, marker = markerCreate();\n\n        id = parseNonComputedProperty();\n\n        return markerApply(marker, delegate.createImportDefaultSpecifier(id));\n    }\n\n    function parseImportNamespaceSpecifier() {\n        // import <* as foo> ...;\n        var id, marker = markerCreate();\n\n        expect('*');\n        if (!matchContextualKeyword('as')) {\n            throwError({}, Messages.NoAsAfterImportNamespace);\n        }\n        lex();\n        id = parseNonComputedProperty();\n\n        return markerApply(marker, delegate.createImportNamespaceSpecifier(id));\n    }\n\n    function parseImportDeclaration() {\n        var specifiers, src, marker = markerCreate(), importKind = 'value',\n            token2;\n\n        expectKeyword('import');\n\n        if (matchContextualKeyword('type')) {\n            token2 = lookahead2();\n            if ((token2.type === Token.Identifier && token2.value !== 'from') ||\n                    (token2.type === Token.Punctuator &&\n                        (token2.value === '{' || token2.value === '*'))) {\n                importKind = 'type';\n                lex();\n            }\n        } else if (matchKeyword('typeof')) {\n            importKind = 'typeof';\n            lex();\n        }\n\n        specifiers = [];\n\n        if (lookahead.type === Token.StringLiteral) {\n            // covers:\n            // import \"foo\";\n            src = parseModuleSpecifier();\n            consumeSemicolon();\n            return markerApply(marker, delegate.createImportDeclaration(specifiers, src, importKind));\n        }\n\n        if (!matchKeyword('default') && isIdentifierName(lookahead)) {\n            // covers:\n            // import foo\n            // import foo, ...\n            specifiers.push(parseImportDefaultSpecifier());\n            if (match(',')) {\n                lex();\n            }\n        }\n        if (match('*')) {\n            // covers:\n            // import foo, * as foo\n            // import * as foo\n            specifiers.push(parseImportNamespaceSpecifier());\n        } else if (match('{')) {\n            // covers:\n            // import foo, {bar}\n            // import {bar}\n            specifiers = specifiers.concat(parseNamedImports());\n        }\n\n        if (!matchContextualKeyword('from')) {\n            throwError({}, lookahead.value ?\n                    Messages.UnexpectedToken : Messages.MissingFromClause, lookahead.value);\n        }\n        lex();\n        src = parseModuleSpecifier();\n        consumeSemicolon();\n\n        return markerApply(marker, delegate.createImportDeclaration(specifiers, src, importKind));\n    }\n\n    // 12.3 Empty Statement\n\n    function parseEmptyStatement() {\n        var marker = markerCreate();\n        expect(';');\n        return markerApply(marker, delegate.createEmptyStatement());\n    }\n\n    // 12.4 Expression Statement\n\n    function parseExpressionStatement() {\n        var marker = markerCreate(), expr = parseExpression();\n        consumeSemicolon();\n        return markerApply(marker, delegate.createExpressionStatement(expr));\n    }\n\n    // 12.5 If statement\n\n    function parseIfStatement() {\n        var test, consequent, alternate, marker = markerCreate();\n\n        expectKeyword('if');\n\n        expect('(');\n\n        test = parseExpression();\n\n        expect(')');\n\n        consequent = parseStatement();\n\n        if (matchKeyword('else')) {\n            lex();\n            alternate = parseStatement();\n        } else {\n            alternate = null;\n        }\n\n        return markerApply(marker, delegate.createIfStatement(test, consequent, alternate));\n    }\n\n    // 12.6 Iteration Statements\n\n    function parseDoWhileStatement() {\n        var body, test, oldInIteration, marker = markerCreate();\n\n        expectKeyword('do');\n\n        oldInIteration = state.inIteration;\n        state.inIteration = true;\n\n        body = parseStatement();\n\n        state.inIteration = oldInIteration;\n\n        expectKeyword('while');\n\n        expect('(');\n\n        test = parseExpression();\n\n        expect(')');\n\n        if (match(';')) {\n            lex();\n        }\n\n        return markerApply(marker, delegate.createDoWhileStatement(body, test));\n    }\n\n    function parseWhileStatement() {\n        var test, body, oldInIteration, marker = markerCreate();\n\n        expectKeyword('while');\n\n        expect('(');\n\n        test = parseExpression();\n\n        expect(')');\n\n        oldInIteration = state.inIteration;\n        state.inIteration = true;\n\n        body = parseStatement();\n\n        state.inIteration = oldInIteration;\n\n        return markerApply(marker, delegate.createWhileStatement(test, body));\n    }\n\n    function parseForVariableDeclaration() {\n        var marker = markerCreate(),\n            token = lex(),\n            declarations = parseVariableDeclarationList();\n\n        return markerApply(marker, delegate.createVariableDeclaration(declarations, token.value));\n    }\n\n    function parseForStatement(opts) {\n        var init, test, update, left, right, body, operator, oldInIteration,\n            marker = markerCreate();\n        init = test = update = null;\n        expectKeyword('for');\n\n        // http://wiki.ecmascript.org/doku.php?id=proposals:iterators_and_generators&s=each\n        if (matchContextualKeyword('each')) {\n            throwError({}, Messages.EachNotAllowed);\n        }\n\n        expect('(');\n\n        if (match(';')) {\n            lex();\n        } else {\n            if (matchKeyword('var') || matchKeyword('let') || matchKeyword('const')) {\n                state.allowIn = false;\n                init = parseForVariableDeclaration();\n                state.allowIn = true;\n\n                if (init.declarations.length === 1) {\n                    if (matchKeyword('in') || matchContextualKeyword('of')) {\n                        operator = lookahead;\n                        if (!((operator.value === 'in' || init.kind !== 'var') && init.declarations[0].init)) {\n                            lex();\n                            left = init;\n                            right = parseExpression();\n                            init = null;\n                        }\n                    }\n                }\n            } else {\n                state.allowIn = false;\n                init = parseExpression();\n                state.allowIn = true;\n\n                if (matchContextualKeyword('of')) {\n                    operator = lex();\n                    left = init;\n                    right = parseExpression();\n                    init = null;\n                } else if (matchKeyword('in')) {\n                    // LeftHandSideExpression\n                    if (!isAssignableLeftHandSide(init)) {\n                        throwError({}, Messages.InvalidLHSInForIn);\n                    }\n                    operator = lex();\n                    left = init;\n                    right = parseExpression();\n                    init = null;\n                }\n            }\n\n            if (typeof left === 'undefined') {\n                expect(';');\n            }\n        }\n\n        if (typeof left === 'undefined') {\n\n            if (!match(';')) {\n                test = parseExpression();\n            }\n            expect(';');\n\n            if (!match(')')) {\n                update = parseExpression();\n            }\n        }\n\n        expect(')');\n\n        oldInIteration = state.inIteration;\n        state.inIteration = true;\n\n        if (!(opts !== undefined && opts.ignoreBody)) {\n            body = parseStatement();\n        }\n\n        state.inIteration = oldInIteration;\n\n        if (typeof left === 'undefined') {\n            return markerApply(marker, delegate.createForStatement(init, test, update, body));\n        }\n\n        if (operator.value === 'in') {\n            return markerApply(marker, delegate.createForInStatement(left, right, body));\n        }\n        return markerApply(marker, delegate.createForOfStatement(left, right, body));\n    }\n\n    // 12.7 The continue statement\n\n    function parseContinueStatement() {\n        var label = null, marker = markerCreate();\n\n        expectKeyword('continue');\n\n        // Optimize the most common form: 'continue;'.\n        if (source.charCodeAt(index) === 59) {\n            lex();\n\n            if (!state.inIteration) {\n                throwError({}, Messages.IllegalContinue);\n            }\n\n            return markerApply(marker, delegate.createContinueStatement(null));\n        }\n\n        if (peekLineTerminator()) {\n            if (!state.inIteration) {\n                throwError({}, Messages.IllegalContinue);\n            }\n\n            return markerApply(marker, delegate.createContinueStatement(null));\n        }\n\n        if (lookahead.type === Token.Identifier) {\n            label = parseVariableIdentifier();\n\n            if (!state.labelSet.has(label.name)) {\n                throwError({}, Messages.UnknownLabel, label.name);\n            }\n        }\n\n        consumeSemicolon();\n\n        if (label === null && !state.inIteration) {\n            throwError({}, Messages.IllegalContinue);\n        }\n\n        return markerApply(marker, delegate.createContinueStatement(label));\n    }\n\n    // 12.8 The break statement\n\n    function parseBreakStatement() {\n        var label = null, marker = markerCreate();\n\n        expectKeyword('break');\n\n        // Catch the very common case first: immediately a semicolon (char #59).\n        if (source.charCodeAt(index) === 59) {\n            lex();\n\n            if (!(state.inIteration || state.inSwitch)) {\n                throwError({}, Messages.IllegalBreak);\n            }\n\n            return markerApply(marker, delegate.createBreakStatement(null));\n        }\n\n        if (peekLineTerminator()) {\n            if (!(state.inIteration || state.inSwitch)) {\n                throwError({}, Messages.IllegalBreak);\n            }\n\n            return markerApply(marker, delegate.createBreakStatement(null));\n        }\n\n        if (lookahead.type === Token.Identifier) {\n            label = parseVariableIdentifier();\n\n            if (!state.labelSet.has(label.name)) {\n                throwError({}, Messages.UnknownLabel, label.name);\n            }\n        }\n\n        consumeSemicolon();\n\n        if (label === null && !(state.inIteration || state.inSwitch)) {\n            throwError({}, Messages.IllegalBreak);\n        }\n\n        return markerApply(marker, delegate.createBreakStatement(label));\n    }\n\n    // 12.9 The return statement\n\n    function parseReturnStatement() {\n        var argument = null, marker = markerCreate();\n\n        expectKeyword('return');\n\n        if (!state.inFunctionBody) {\n            throwErrorTolerant({}, Messages.IllegalReturn);\n        }\n\n        // 'return' followed by a space and an identifier is very common.\n        if (source.charCodeAt(index) === 32) {\n            if (isIdentifierStart(source.charCodeAt(index + 1))) {\n                argument = parseExpression();\n                consumeSemicolon();\n                return markerApply(marker, delegate.createReturnStatement(argument));\n            }\n        }\n\n        if (peekLineTerminator()) {\n            return markerApply(marker, delegate.createReturnStatement(null));\n        }\n\n        if (!match(';')) {\n            if (!match('}') && lookahead.type !== Token.EOF) {\n                argument = parseExpression();\n            }\n        }\n\n        consumeSemicolon();\n\n        return markerApply(marker, delegate.createReturnStatement(argument));\n    }\n\n    // 12.10 The with statement\n\n    function parseWithStatement() {\n        var object, body, marker = markerCreate();\n\n        if (strict) {\n            throwErrorTolerant({}, Messages.StrictModeWith);\n        }\n\n        expectKeyword('with');\n\n        expect('(');\n\n        object = parseExpression();\n\n        expect(')');\n\n        body = parseStatement();\n\n        return markerApply(marker, delegate.createWithStatement(object, body));\n    }\n\n    // 12.10 The swith statement\n\n    function parseSwitchCase() {\n        var test,\n            consequent = [],\n            sourceElement,\n            marker = markerCreate();\n\n        if (matchKeyword('default')) {\n            lex();\n            test = null;\n        } else {\n            expectKeyword('case');\n            test = parseExpression();\n        }\n        expect(':');\n\n        while (index < length) {\n            if (match('}') || matchKeyword('default') || matchKeyword('case')) {\n                break;\n            }\n            sourceElement = parseSourceElement();\n            if (typeof sourceElement === 'undefined') {\n                break;\n            }\n            consequent.push(sourceElement);\n        }\n\n        return markerApply(marker, delegate.createSwitchCase(test, consequent));\n    }\n\n    function parseSwitchStatement() {\n        var discriminant, cases, clause, oldInSwitch, defaultFound, marker = markerCreate();\n\n        expectKeyword('switch');\n\n        expect('(');\n\n        discriminant = parseExpression();\n\n        expect(')');\n\n        expect('{');\n\n        cases = [];\n\n        if (match('}')) {\n            lex();\n            return markerApply(marker, delegate.createSwitchStatement(discriminant, cases));\n        }\n\n        oldInSwitch = state.inSwitch;\n        state.inSwitch = true;\n        defaultFound = false;\n\n        while (index < length) {\n            if (match('}')) {\n                break;\n            }\n            clause = parseSwitchCase();\n            if (clause.test === null) {\n                if (defaultFound) {\n                    throwError({}, Messages.MultipleDefaultsInSwitch);\n                }\n                defaultFound = true;\n            }\n            cases.push(clause);\n        }\n\n        state.inSwitch = oldInSwitch;\n\n        expect('}');\n\n        return markerApply(marker, delegate.createSwitchStatement(discriminant, cases));\n    }\n\n    // 12.13 The throw statement\n\n    function parseThrowStatement() {\n        var argument, marker = markerCreate();\n\n        expectKeyword('throw');\n\n        if (peekLineTerminator()) {\n            throwError({}, Messages.NewlineAfterThrow);\n        }\n\n        argument = parseExpression();\n\n        consumeSemicolon();\n\n        return markerApply(marker, delegate.createThrowStatement(argument));\n    }\n\n    // 12.14 The try statement\n\n    function parseCatchClause() {\n        var param, body, marker = markerCreate();\n\n        expectKeyword('catch');\n\n        expect('(');\n        if (match(')')) {\n            throwUnexpected(lookahead);\n        }\n\n        param = parseExpression();\n        // 12.14.1\n        if (strict && param.type === Syntax.Identifier && isRestrictedWord(param.name)) {\n            throwErrorTolerant({}, Messages.StrictCatchVariable);\n        }\n\n        expect(')');\n        body = parseBlock();\n        return markerApply(marker, delegate.createCatchClause(param, body));\n    }\n\n    function parseTryStatement() {\n        var block, handlers = [], finalizer = null, marker = markerCreate();\n\n        expectKeyword('try');\n\n        block = parseBlock();\n\n        if (matchKeyword('catch')) {\n            handlers.push(parseCatchClause());\n        }\n\n        if (matchKeyword('finally')) {\n            lex();\n            finalizer = parseBlock();\n        }\n\n        if (handlers.length === 0 && !finalizer) {\n            throwError({}, Messages.NoCatchOrFinally);\n        }\n\n        return markerApply(marker, delegate.createTryStatement(block, [], handlers, finalizer));\n    }\n\n    // 12.15 The debugger statement\n\n    function parseDebuggerStatement() {\n        var marker = markerCreate();\n        expectKeyword('debugger');\n\n        consumeSemicolon();\n\n        return markerApply(marker, delegate.createDebuggerStatement());\n    }\n\n    // 12 Statements\n\n    function parseStatement() {\n        var type = lookahead.type,\n            marker,\n            expr,\n            labeledBody;\n\n        if (type === Token.EOF) {\n            throwUnexpected(lookahead);\n        }\n\n        if (type === Token.Punctuator) {\n            switch (lookahead.value) {\n            case ';':\n                return parseEmptyStatement();\n            case '{':\n                return parseBlock();\n            case '(':\n                return parseExpressionStatement();\n            default:\n                break;\n            }\n        }\n\n        if (type === Token.Keyword) {\n            switch (lookahead.value) {\n            case 'break':\n                return parseBreakStatement();\n            case 'continue':\n                return parseContinueStatement();\n            case 'debugger':\n                return parseDebuggerStatement();\n            case 'do':\n                return parseDoWhileStatement();\n            case 'for':\n                return parseForStatement();\n            case 'function':\n                return parseFunctionDeclaration();\n            case 'class':\n                return parseClassDeclaration();\n            case 'if':\n                return parseIfStatement();\n            case 'return':\n                return parseReturnStatement();\n            case 'switch':\n                return parseSwitchStatement();\n            case 'throw':\n                return parseThrowStatement();\n            case 'try':\n                return parseTryStatement();\n            case 'var':\n                return parseVariableStatement();\n            case 'while':\n                return parseWhileStatement();\n            case 'with':\n                return parseWithStatement();\n            default:\n                break;\n            }\n        }\n\n        if (matchAsyncFuncExprOrDecl()) {\n            return parseFunctionDeclaration();\n        }\n\n        marker = markerCreate();\n        expr = parseExpression();\n\n        // 12.12 Labelled Statements\n        if ((expr.type === Syntax.Identifier) && match(':')) {\n            lex();\n\n            if (state.labelSet.has(expr.name)) {\n                throwError({}, Messages.Redeclaration, 'Label', expr.name);\n            }\n\n            state.labelSet.set(expr.name, true);\n            labeledBody = parseStatement();\n            state.labelSet.delete(expr.name);\n            return markerApply(marker, delegate.createLabeledStatement(expr, labeledBody));\n        }\n\n        consumeSemicolon();\n\n        return markerApply(marker, delegate.createExpressionStatement(expr));\n    }\n\n    // 13 Function Definition\n\n    function parseConciseBody() {\n        if (match('{')) {\n            return parseFunctionSourceElements();\n        }\n        return parseAssignmentExpression();\n    }\n\n    function parseFunctionSourceElements() {\n        var sourceElement, sourceElements = [], token, directive, firstRestricted,\n            oldLabelSet, oldInIteration, oldInSwitch, oldInFunctionBody, oldParenthesizedCount,\n            marker = markerCreate();\n\n        expect('{');\n\n        while (index < length) {\n            if (lookahead.type !== Token.StringLiteral) {\n                break;\n            }\n            token = lookahead;\n\n            sourceElement = parseSourceElement();\n            sourceElements.push(sourceElement);\n            if (sourceElement.expression.type !== Syntax.Literal) {\n                // this is not directive\n                break;\n            }\n            directive = source.slice(token.range[0] + 1, token.range[1] - 1);\n            if (directive === 'use strict') {\n                strict = true;\n                if (firstRestricted) {\n                    throwErrorTolerant(firstRestricted, Messages.StrictOctalLiteral);\n                }\n            } else {\n                if (!firstRestricted && token.octal) {\n                    firstRestricted = token;\n                }\n            }\n        }\n\n        oldLabelSet = state.labelSet;\n        oldInIteration = state.inIteration;\n        oldInSwitch = state.inSwitch;\n        oldInFunctionBody = state.inFunctionBody;\n        oldParenthesizedCount = state.parenthesizedCount;\n\n        state.labelSet = new StringMap();\n        state.inIteration = false;\n        state.inSwitch = false;\n        state.inFunctionBody = true;\n        state.parenthesizedCount = 0;\n\n        while (index < length) {\n            if (match('}')) {\n                break;\n            }\n            sourceElement = parseSourceElement();\n            if (typeof sourceElement === 'undefined') {\n                break;\n            }\n            sourceElements.push(sourceElement);\n        }\n\n        expect('}');\n\n        state.labelSet = oldLabelSet;\n        state.inIteration = oldInIteration;\n        state.inSwitch = oldInSwitch;\n        state.inFunctionBody = oldInFunctionBody;\n        state.parenthesizedCount = oldParenthesizedCount;\n\n        return markerApply(marker, delegate.createBlockStatement(sourceElements));\n    }\n\n    function validateParam(options, param, name) {\n        if (strict) {\n            if (isRestrictedWord(name)) {\n                options.stricted = param;\n                options.message = Messages.StrictParamName;\n            }\n            if (options.paramSet.has(name)) {\n                options.stricted = param;\n                options.message = Messages.StrictParamDupe;\n            }\n        } else if (!options.firstRestricted) {\n            if (isRestrictedWord(name)) {\n                options.firstRestricted = param;\n                options.message = Messages.StrictParamName;\n            } else if (isStrictModeReservedWord(name)) {\n                options.firstRestricted = param;\n                options.message = Messages.StrictReservedWord;\n            } else if (options.paramSet.has(name)) {\n                options.firstRestricted = param;\n                options.message = Messages.StrictParamDupe;\n            }\n        }\n        options.paramSet.set(name, true);\n    }\n\n    function parseParam(options) {\n        var marker, token, rest, param, def;\n\n        token = lookahead;\n        if (token.value === '...') {\n            token = lex();\n            rest = true;\n        }\n\n        if (match('[')) {\n            marker = markerCreate();\n            param = parseArrayInitialiser();\n            reinterpretAsDestructuredParameter(options, param);\n            if (match(':')) {\n                param.typeAnnotation = parseTypeAnnotation();\n                markerApply(marker, param);\n            }\n        } else if (match('{')) {\n            marker = markerCreate();\n            if (rest) {\n                throwError({}, Messages.ObjectPatternAsRestParameter);\n            }\n            param = parseObjectInitialiser();\n            reinterpretAsDestructuredParameter(options, param);\n            if (match(':')) {\n                param.typeAnnotation = parseTypeAnnotation();\n                markerApply(marker, param);\n            }\n        } else {\n            param =\n                rest\n                ? parseTypeAnnotatableIdentifier(\n                    false, /* requireTypeAnnotation */\n                    false /* canBeOptionalParam */\n                )\n                : parseTypeAnnotatableIdentifier(\n                    false, /* requireTypeAnnotation */\n                    true /* canBeOptionalParam */\n                );\n\n            validateParam(options, token, token.value);\n        }\n\n        if (match('=')) {\n            if (rest) {\n                throwErrorTolerant(lookahead, Messages.DefaultRestParameter);\n            }\n            lex();\n            def = parseAssignmentExpression();\n            ++options.defaultCount;\n        }\n\n        if (rest) {\n            if (!match(')')) {\n                throwError({}, Messages.ParameterAfterRestParameter);\n            }\n            options.rest = param;\n            return false;\n        }\n\n        options.params.push(param);\n        options.defaults.push(def);\n        return !match(')');\n    }\n\n    function parseParams(firstRestricted) {\n        var options, marker = markerCreate();\n\n        options = {\n            params: [],\n            defaultCount: 0,\n            defaults: [],\n            rest: null,\n            firstRestricted: firstRestricted\n        };\n\n        expect('(');\n\n        if (!match(')')) {\n            options.paramSet = new StringMap();\n            while (index < length) {\n                if (!parseParam(options)) {\n                    break;\n                }\n                expect(',');\n                if (!options.rest && match(')')) {\n                    break;\n                }\n            }\n        }\n\n        expect(')');\n\n        if (options.defaultCount === 0) {\n            options.defaults = [];\n        }\n\n        if (match(':')) {\n            options.returnType = parseTypeAnnotation();\n        }\n\n        return markerApply(marker, options);\n    }\n\n    function parseFunctionDeclaration() {\n        var id, body, token, tmp, firstRestricted, message, generator, isAsync,\n            previousStrict, previousYieldAllowed, previousAwaitAllowed,\n            marker = markerCreate(), typeParameters;\n\n        isAsync = false;\n        if (matchAsync()) {\n            lex();\n            isAsync = true;\n        }\n\n        expectKeyword('function');\n\n        generator = false;\n        if (match('*')) {\n            lex();\n            generator = true;\n        }\n\n        token = lookahead;\n\n        id = parseVariableIdentifier();\n\n        if (match('<')) {\n            typeParameters = parseTypeParameterDeclaration();\n        }\n\n        if (strict) {\n            if (isRestrictedWord(token.value)) {\n                throwErrorTolerant(token, Messages.StrictFunctionName);\n            }\n        } else {\n            if (isRestrictedWord(token.value)) {\n                firstRestricted = token;\n                message = Messages.StrictFunctionName;\n            } else if (isStrictModeReservedWord(token.value)) {\n                firstRestricted = token;\n                message = Messages.StrictReservedWord;\n            }\n        }\n\n        tmp = parseParams(firstRestricted);\n        firstRestricted = tmp.firstRestricted;\n        if (tmp.message) {\n            message = tmp.message;\n        }\n\n        previousStrict = strict;\n        previousYieldAllowed = state.yieldAllowed;\n        state.yieldAllowed = generator;\n        previousAwaitAllowed = state.awaitAllowed;\n        state.awaitAllowed = isAsync;\n\n        body = parseFunctionSourceElements();\n\n        if (strict && firstRestricted) {\n            throwError(firstRestricted, message);\n        }\n        if (strict && tmp.stricted) {\n            throwErrorTolerant(tmp.stricted, message);\n        }\n        strict = previousStrict;\n        state.yieldAllowed = previousYieldAllowed;\n        state.awaitAllowed = previousAwaitAllowed;\n\n        return markerApply(\n            marker,\n            delegate.createFunctionDeclaration(\n                id,\n                tmp.params,\n                tmp.defaults,\n                body,\n                tmp.rest,\n                generator,\n                false,\n                isAsync,\n                tmp.returnType,\n                typeParameters\n            )\n        );\n    }\n\n    function parseFunctionExpression() {\n        var token, id = null, firstRestricted, message, tmp, body, generator, isAsync,\n            previousStrict, previousYieldAllowed, previousAwaitAllowed,\n            marker = markerCreate(), typeParameters;\n\n        isAsync = false;\n        if (matchAsync()) {\n            lex();\n            isAsync = true;\n        }\n\n        expectKeyword('function');\n\n        generator = false;\n\n        if (match('*')) {\n            lex();\n            generator = true;\n        }\n\n        if (!match('(')) {\n            if (!match('<')) {\n                token = lookahead;\n                id = parseVariableIdentifier();\n\n                if (strict) {\n                    if (isRestrictedWord(token.value)) {\n                        throwErrorTolerant(token, Messages.StrictFunctionName);\n                    }\n                } else {\n                    if (isRestrictedWord(token.value)) {\n                        firstRestricted = token;\n                        message = Messages.StrictFunctionName;\n                    } else if (isStrictModeReservedWord(token.value)) {\n                        firstRestricted = token;\n                        message = Messages.StrictReservedWord;\n                    }\n                }\n            }\n\n            if (match('<')) {\n                typeParameters = parseTypeParameterDeclaration();\n            }\n        }\n\n        tmp = parseParams(firstRestricted);\n        firstRestricted = tmp.firstRestricted;\n        if (tmp.message) {\n            message = tmp.message;\n        }\n\n        previousStrict = strict;\n        previousYieldAllowed = state.yieldAllowed;\n        state.yieldAllowed = generator;\n        previousAwaitAllowed = state.awaitAllowed;\n        state.awaitAllowed = isAsync;\n\n        body = parseFunctionSourceElements();\n\n        if (strict && firstRestricted) {\n            throwError(firstRestricted, message);\n        }\n        if (strict && tmp.stricted) {\n            throwErrorTolerant(tmp.stricted, message);\n        }\n        strict = previousStrict;\n        state.yieldAllowed = previousYieldAllowed;\n        state.awaitAllowed = previousAwaitAllowed;\n\n        return markerApply(\n            marker,\n            delegate.createFunctionExpression(\n                id,\n                tmp.params,\n                tmp.defaults,\n                body,\n                tmp.rest,\n                generator,\n                false,\n                isAsync,\n                tmp.returnType,\n                typeParameters\n            )\n        );\n    }\n\n    function parseYieldExpression() {\n        var delegateFlag, expr, marker = markerCreate();\n\n        expectKeyword('yield', !strict);\n\n        delegateFlag = false;\n        if (match('*')) {\n            lex();\n            delegateFlag = true;\n        }\n\n        expr = parseAssignmentExpression();\n\n        return markerApply(marker, delegate.createYieldExpression(expr, delegateFlag));\n    }\n\n    function parseAwaitExpression() {\n        var expr, marker = markerCreate();\n        expectContextualKeyword('await');\n        expr = parseAssignmentExpression();\n        return markerApply(marker, delegate.createAwaitExpression(expr));\n    }\n\n    // 14 Functions and classes\n\n    // 14.1 Functions is defined above (13 in ES5)\n    // 14.2 Arrow Functions Definitions is defined in (7.3 assignments)\n\n    // 14.3 Method Definitions\n    // 14.3.7\n    function specialMethod(methodDefinition) {\n        return methodDefinition.kind === 'get' ||\n               methodDefinition.kind === 'set' ||\n               methodDefinition.value.generator;\n    }\n\n    function parseMethodDefinition(key, isStatic, generator, computed) {\n        var token, param, propType,\n            isAsync, typeParameters, tokenValue, returnType;\n\n        propType = isStatic ? ClassPropertyType.static : ClassPropertyType.prototype;\n\n        if (generator) {\n            return delegate.createMethodDefinition(\n                propType,\n                '',\n                key,\n                parsePropertyMethodFunction({ generator: true }),\n                computed\n            );\n        }\n\n        tokenValue = key.type === 'Identifier' && key.name;\n\n        if (tokenValue === 'get' && !match('(')) {\n            key = parseObjectPropertyKey();\n\n            expect('(');\n            expect(')');\n            if (match(':')) {\n                returnType = parseTypeAnnotation();\n            }\n            return delegate.createMethodDefinition(\n                propType,\n                'get',\n                key,\n                parsePropertyFunction({ generator: false, returnType: returnType }),\n                computed\n            );\n        }\n        if (tokenValue === 'set' && !match('(')) {\n            key = parseObjectPropertyKey();\n\n            expect('(');\n            token = lookahead;\n            param = [ parseTypeAnnotatableIdentifier() ];\n            expect(')');\n            if (match(':')) {\n                returnType = parseTypeAnnotation();\n            }\n            return delegate.createMethodDefinition(\n                propType,\n                'set',\n                key,\n                parsePropertyFunction({\n                    params: param,\n                    generator: false,\n                    name: token,\n                    returnType: returnType\n                }),\n                computed\n            );\n        }\n\n        if (match('<')) {\n            typeParameters = parseTypeParameterDeclaration();\n        }\n\n        isAsync = tokenValue === 'async' && !match('(');\n        if (isAsync) {\n            key = parseObjectPropertyKey();\n        }\n\n        return delegate.createMethodDefinition(\n            propType,\n            '',\n            key,\n            parsePropertyMethodFunction({\n                generator: false,\n                async: isAsync,\n                typeParameters: typeParameters\n            }),\n            computed\n        );\n    }\n\n    function parseClassProperty(key, computed, isStatic) {\n        var typeAnnotation;\n\n        typeAnnotation = parseTypeAnnotation();\n        expect(';');\n\n        return delegate.createClassProperty(\n            key,\n            typeAnnotation,\n            computed,\n            isStatic\n        );\n    }\n\n    function parseClassElement() {\n        var computed = false, generator = false, key, marker = markerCreate(),\n            isStatic = false, possiblyOpenBracketToken;\n        if (match(';')) {\n            lex();\n            return undefined;\n        }\n\n        if (lookahead.value === 'static') {\n            lex();\n            isStatic = true;\n        }\n\n        if (match('*')) {\n            lex();\n            generator = true;\n        }\n\n        possiblyOpenBracketToken = lookahead;\n        if (matchContextualKeyword('get') || matchContextualKeyword('set')) {\n            possiblyOpenBracketToken = lookahead2();\n        }\n\n        if (possiblyOpenBracketToken.type === Token.Punctuator\n                && possiblyOpenBracketToken.value === '[') {\n            computed = true;\n        }\n\n        key = parseObjectPropertyKey();\n\n        if (!generator && lookahead.value === ':') {\n            return markerApply(marker, parseClassProperty(key, computed, isStatic));\n        }\n\n        return markerApply(marker, parseMethodDefinition(\n            key,\n            isStatic,\n            generator,\n            computed\n        ));\n    }\n\n    function parseClassBody() {\n        var classElement, classElements = [], existingProps = {},\n            marker = markerCreate(), propName, propType;\n\n        existingProps[ClassPropertyType.static] = new StringMap();\n        existingProps[ClassPropertyType.prototype] = new StringMap();\n\n        expect('{');\n\n        while (index < length) {\n            if (match('}')) {\n                break;\n            }\n            classElement = parseClassElement(existingProps);\n\n            if (typeof classElement !== 'undefined') {\n                classElements.push(classElement);\n\n                propName = !classElement.computed && getFieldName(classElement.key);\n                if (propName !== false) {\n                    propType = classElement.static ?\n                                ClassPropertyType.static :\n                                ClassPropertyType.prototype;\n\n                    if (classElement.type === Syntax.MethodDefinition) {\n                        if (propName === 'constructor' && !classElement.static) {\n                            if (specialMethod(classElement)) {\n                                throwError(classElement, Messages.IllegalClassConstructorProperty);\n                            }\n                            if (existingProps[ClassPropertyType.prototype].has('constructor')) {\n                                throwError(classElement.key, Messages.IllegalDuplicateClassProperty);\n                            }\n                        }\n                        existingProps[propType].set(propName, true);\n                    }\n                }\n            }\n        }\n\n        expect('}');\n\n        return markerApply(marker, delegate.createClassBody(classElements));\n    }\n\n    function parseClassImplements() {\n        var id, implemented = [], marker, typeParameters;\n        if (strict) {\n            expectKeyword('implements');\n        } else {\n            expectContextualKeyword('implements');\n        }\n        while (index < length) {\n            marker = markerCreate();\n            id = parseVariableIdentifier();\n            if (match('<')) {\n                typeParameters = parseTypeParameterInstantiation();\n            } else {\n                typeParameters = null;\n            }\n            implemented.push(markerApply(marker, delegate.createClassImplements(\n                id,\n                typeParameters\n            )));\n            if (!match(',')) {\n                break;\n            }\n            expect(',');\n        }\n        return implemented;\n    }\n\n    function parseClassExpression() {\n        var id, implemented, previousYieldAllowed, superClass = null,\n            superTypeParameters, marker = markerCreate(), typeParameters,\n            matchImplements;\n\n        expectKeyword('class');\n\n        matchImplements =\n                strict\n                ? matchKeyword('implements')\n                : matchContextualKeyword('implements');\n\n        if (!matchKeyword('extends') && !matchImplements && !match('{')) {\n            id = parseVariableIdentifier();\n        }\n\n        if (match('<')) {\n            typeParameters = parseTypeParameterDeclaration();\n        }\n\n        if (matchKeyword('extends')) {\n            expectKeyword('extends');\n            previousYieldAllowed = state.yieldAllowed;\n            state.yieldAllowed = false;\n            superClass = parseLeftHandSideExpressionAllowCall();\n            if (match('<')) {\n                superTypeParameters = parseTypeParameterInstantiation();\n            }\n            state.yieldAllowed = previousYieldAllowed;\n        }\n\n        if (strict ? matchKeyword('implements') : matchContextualKeyword('implements')) {\n            implemented = parseClassImplements();\n        }\n\n        return markerApply(marker, delegate.createClassExpression(\n            id,\n            superClass,\n            parseClassBody(),\n            typeParameters,\n            superTypeParameters,\n            implemented\n        ));\n    }\n\n    function parseClassDeclaration() {\n        var id, implemented, previousYieldAllowed, superClass = null,\n            superTypeParameters, marker = markerCreate(), typeParameters;\n\n        expectKeyword('class');\n\n        id = parseVariableIdentifier();\n\n        if (match('<')) {\n            typeParameters = parseTypeParameterDeclaration();\n        }\n\n        if (matchKeyword('extends')) {\n            expectKeyword('extends');\n            previousYieldAllowed = state.yieldAllowed;\n            state.yieldAllowed = false;\n            superClass = parseLeftHandSideExpressionAllowCall();\n            if (match('<')) {\n                superTypeParameters = parseTypeParameterInstantiation();\n            }\n            state.yieldAllowed = previousYieldAllowed;\n        }\n\n        if (strict ? matchKeyword('implements') : matchContextualKeyword('implements')) {\n            implemented = parseClassImplements();\n        }\n\n        return markerApply(marker, delegate.createClassDeclaration(\n            id,\n            superClass,\n            parseClassBody(),\n            typeParameters,\n            superTypeParameters,\n            implemented\n        ));\n    }\n\n    // 15 Program\n\n    function parseSourceElement() {\n        var token;\n        if (lookahead.type === Token.Keyword) {\n            switch (lookahead.value) {\n            case 'const':\n            case 'let':\n                return parseConstLetDeclaration(lookahead.value);\n            case 'function':\n                return parseFunctionDeclaration();\n            case 'export':\n                throwErrorTolerant({}, Messages.IllegalExportDeclaration);\n                return parseExportDeclaration();\n            case 'import':\n                throwErrorTolerant({}, Messages.IllegalImportDeclaration);\n                return parseImportDeclaration();\n            case 'interface':\n                if (lookahead2().type === Token.Identifier) {\n                    return parseInterface();\n                }\n                return parseStatement();\n            default:\n                return parseStatement();\n            }\n        }\n\n        if (matchContextualKeyword('type')\n                && lookahead2().type === Token.Identifier) {\n            return parseTypeAlias();\n        }\n\n        if (matchContextualKeyword('interface')\n                && lookahead2().type === Token.Identifier) {\n            return parseInterface();\n        }\n\n        if (matchContextualKeyword('declare')) {\n            token = lookahead2();\n            if (token.type === Token.Keyword) {\n                switch (token.value) {\n                case 'class':\n                    return parseDeclareClass();\n                case 'function':\n                    return parseDeclareFunction();\n                case 'var':\n                    return parseDeclareVariable();\n                }\n            } else if (token.type === Token.Identifier\n                    && token.value === 'module') {\n                return parseDeclareModule();\n            }\n        }\n\n        if (lookahead.type !== Token.EOF) {\n            return parseStatement();\n        }\n    }\n\n    function parseProgramElement() {\n        var isModule = extra.sourceType === 'module' || extra.sourceType === 'nonStrictModule';\n\n        if (isModule && lookahead.type === Token.Keyword) {\n            switch (lookahead.value) {\n            case 'export':\n                return parseExportDeclaration();\n            case 'import':\n                return parseImportDeclaration();\n            }\n        }\n\n        return parseSourceElement();\n    }\n\n    function parseProgramElements() {\n        var sourceElement, sourceElements = [], token, directive, firstRestricted;\n\n        while (index < length) {\n            token = lookahead;\n            if (token.type !== Token.StringLiteral) {\n                break;\n            }\n\n            sourceElement = parseProgramElement();\n            sourceElements.push(sourceElement);\n            if (sourceElement.expression.type !== Syntax.Literal) {\n                // this is not directive\n                break;\n            }\n            directive = source.slice(token.range[0] + 1, token.range[1] - 1);\n            if (directive === 'use strict') {\n                strict = true;\n                if (firstRestricted) {\n                    throwErrorTolerant(firstRestricted, Messages.StrictOctalLiteral);\n                }\n            } else {\n                if (!firstRestricted && token.octal) {\n                    firstRestricted = token;\n                }\n            }\n        }\n\n        while (index < length) {\n            sourceElement = parseProgramElement();\n            if (typeof sourceElement === 'undefined') {\n                break;\n            }\n            sourceElements.push(sourceElement);\n        }\n        return sourceElements;\n    }\n\n    function parseProgram() {\n        var body, marker = markerCreate();\n        strict = extra.sourceType === 'module';\n        peek();\n        body = parseProgramElements();\n        return markerApply(marker, delegate.createProgram(body));\n    }\n\n    // 16 JSX\n\n    XHTMLEntities = {\n        quot: '\\u0022',\n        amp: '&',\n        apos: '\\u0027',\n        lt: '<',\n        gt: '>',\n        nbsp: '\\u00A0',\n        iexcl: '\\u00A1',\n        cent: '\\u00A2',\n        pound: '\\u00A3',\n        curren: '\\u00A4',\n        yen: '\\u00A5',\n        brvbar: '\\u00A6',\n        sect: '\\u00A7',\n        uml: '\\u00A8',\n        copy: '\\u00A9',\n        ordf: '\\u00AA',\n        laquo: '\\u00AB',\n        not: '\\u00AC',\n        shy: '\\u00AD',\n        reg: '\\u00AE',\n        macr: '\\u00AF',\n        deg: '\\u00B0',\n        plusmn: '\\u00B1',\n        sup2: '\\u00B2',\n        sup3: '\\u00B3',\n        acute: '\\u00B4',\n        micro: '\\u00B5',\n        para: '\\u00B6',\n        middot: '\\u00B7',\n        cedil: '\\u00B8',\n        sup1: '\\u00B9',\n        ordm: '\\u00BA',\n        raquo: '\\u00BB',\n        frac14: '\\u00BC',\n        frac12: '\\u00BD',\n        frac34: '\\u00BE',\n        iquest: '\\u00BF',\n        Agrave: '\\u00C0',\n        Aacute: '\\u00C1',\n        Acirc: '\\u00C2',\n        Atilde: '\\u00C3',\n        Auml: '\\u00C4',\n        Aring: '\\u00C5',\n        AElig: '\\u00C6',\n        Ccedil: '\\u00C7',\n        Egrave: '\\u00C8',\n        Eacute: '\\u00C9',\n        Ecirc: '\\u00CA',\n        Euml: '\\u00CB',\n        Igrave: '\\u00CC',\n        Iacute: '\\u00CD',\n        Icirc: '\\u00CE',\n        Iuml: '\\u00CF',\n        ETH: '\\u00D0',\n        Ntilde: '\\u00D1',\n        Ograve: '\\u00D2',\n        Oacute: '\\u00D3',\n        Ocirc: '\\u00D4',\n        Otilde: '\\u00D5',\n        Ouml: '\\u00D6',\n        times: '\\u00D7',\n        Oslash: '\\u00D8',\n        Ugrave: '\\u00D9',\n        Uacute: '\\u00DA',\n        Ucirc: '\\u00DB',\n        Uuml: '\\u00DC',\n        Yacute: '\\u00DD',\n        THORN: '\\u00DE',\n        szlig: '\\u00DF',\n        agrave: '\\u00E0',\n        aacute: '\\u00E1',\n        acirc: '\\u00E2',\n        atilde: '\\u00E3',\n        auml: '\\u00E4',\n        aring: '\\u00E5',\n        aelig: '\\u00E6',\n        ccedil: '\\u00E7',\n        egrave: '\\u00E8',\n        eacute: '\\u00E9',\n        ecirc: '\\u00EA',\n        euml: '\\u00EB',\n        igrave: '\\u00EC',\n        iacute: '\\u00ED',\n        icirc: '\\u00EE',\n        iuml: '\\u00EF',\n        eth: '\\u00F0',\n        ntilde: '\\u00F1',\n        ograve: '\\u00F2',\n        oacute: '\\u00F3',\n        ocirc: '\\u00F4',\n        otilde: '\\u00F5',\n        ouml: '\\u00F6',\n        divide: '\\u00F7',\n        oslash: '\\u00F8',\n        ugrave: '\\u00F9',\n        uacute: '\\u00FA',\n        ucirc: '\\u00FB',\n        uuml: '\\u00FC',\n        yacute: '\\u00FD',\n        thorn: '\\u00FE',\n        yuml: '\\u00FF',\n        OElig: '\\u0152',\n        oelig: '\\u0153',\n        Scaron: '\\u0160',\n        scaron: '\\u0161',\n        Yuml: '\\u0178',\n        fnof: '\\u0192',\n        circ: '\\u02C6',\n        tilde: '\\u02DC',\n        Alpha: '\\u0391',\n        Beta: '\\u0392',\n        Gamma: '\\u0393',\n        Delta: '\\u0394',\n        Epsilon: '\\u0395',\n        Zeta: '\\u0396',\n        Eta: '\\u0397',\n        Theta: '\\u0398',\n        Iota: '\\u0399',\n        Kappa: '\\u039A',\n        Lambda: '\\u039B',\n        Mu: '\\u039C',\n        Nu: '\\u039D',\n        Xi: '\\u039E',\n        Omicron: '\\u039F',\n        Pi: '\\u03A0',\n        Rho: '\\u03A1',\n        Sigma: '\\u03A3',\n        Tau: '\\u03A4',\n        Upsilon: '\\u03A5',\n        Phi: '\\u03A6',\n        Chi: '\\u03A7',\n        Psi: '\\u03A8',\n        Omega: '\\u03A9',\n        alpha: '\\u03B1',\n        beta: '\\u03B2',\n        gamma: '\\u03B3',\n        delta: '\\u03B4',\n        epsilon: '\\u03B5',\n        zeta: '\\u03B6',\n        eta: '\\u03B7',\n        theta: '\\u03B8',\n        iota: '\\u03B9',\n        kappa: '\\u03BA',\n        lambda: '\\u03BB',\n        mu: '\\u03BC',\n        nu: '\\u03BD',\n        xi: '\\u03BE',\n        omicron: '\\u03BF',\n        pi: '\\u03C0',\n        rho: '\\u03C1',\n        sigmaf: '\\u03C2',\n        sigma: '\\u03C3',\n        tau: '\\u03C4',\n        upsilon: '\\u03C5',\n        phi: '\\u03C6',\n        chi: '\\u03C7',\n        psi: '\\u03C8',\n        omega: '\\u03C9',\n        thetasym: '\\u03D1',\n        upsih: '\\u03D2',\n        piv: '\\u03D6',\n        ensp: '\\u2002',\n        emsp: '\\u2003',\n        thinsp: '\\u2009',\n        zwnj: '\\u200C',\n        zwj: '\\u200D',\n        lrm: '\\u200E',\n        rlm: '\\u200F',\n        ndash: '\\u2013',\n        mdash: '\\u2014',\n        lsquo: '\\u2018',\n        rsquo: '\\u2019',\n        sbquo: '\\u201A',\n        ldquo: '\\u201C',\n        rdquo: '\\u201D',\n        bdquo: '\\u201E',\n        dagger: '\\u2020',\n        Dagger: '\\u2021',\n        bull: '\\u2022',\n        hellip: '\\u2026',\n        permil: '\\u2030',\n        prime: '\\u2032',\n        Prime: '\\u2033',\n        lsaquo: '\\u2039',\n        rsaquo: '\\u203A',\n        oline: '\\u203E',\n        frasl: '\\u2044',\n        euro: '\\u20AC',\n        image: '\\u2111',\n        weierp: '\\u2118',\n        real: '\\u211C',\n        trade: '\\u2122',\n        alefsym: '\\u2135',\n        larr: '\\u2190',\n        uarr: '\\u2191',\n        rarr: '\\u2192',\n        darr: '\\u2193',\n        harr: '\\u2194',\n        crarr: '\\u21B5',\n        lArr: '\\u21D0',\n        uArr: '\\u21D1',\n        rArr: '\\u21D2',\n        dArr: '\\u21D3',\n        hArr: '\\u21D4',\n        forall: '\\u2200',\n        part: '\\u2202',\n        exist: '\\u2203',\n        empty: '\\u2205',\n        nabla: '\\u2207',\n        isin: '\\u2208',\n        notin: '\\u2209',\n        ni: '\\u220B',\n        prod: '\\u220F',\n        sum: '\\u2211',\n        minus: '\\u2212',\n        lowast: '\\u2217',\n        radic: '\\u221A',\n        prop: '\\u221D',\n        infin: '\\u221E',\n        ang: '\\u2220',\n        and: '\\u2227',\n        or: '\\u2228',\n        cap: '\\u2229',\n        cup: '\\u222A',\n        'int': '\\u222B',\n        there4: '\\u2234',\n        sim: '\\u223C',\n        cong: '\\u2245',\n        asymp: '\\u2248',\n        ne: '\\u2260',\n        equiv: '\\u2261',\n        le: '\\u2264',\n        ge: '\\u2265',\n        sub: '\\u2282',\n        sup: '\\u2283',\n        nsub: '\\u2284',\n        sube: '\\u2286',\n        supe: '\\u2287',\n        oplus: '\\u2295',\n        otimes: '\\u2297',\n        perp: '\\u22A5',\n        sdot: '\\u22C5',\n        lceil: '\\u2308',\n        rceil: '\\u2309',\n        lfloor: '\\u230A',\n        rfloor: '\\u230B',\n        lang: '\\u2329',\n        rang: '\\u232A',\n        loz: '\\u25CA',\n        spades: '\\u2660',\n        clubs: '\\u2663',\n        hearts: '\\u2665',\n        diams: '\\u2666'\n    };\n\n    function getQualifiedJSXName(object) {\n        if (object.type === Syntax.JSXIdentifier) {\n            return object.name;\n        }\n        if (object.type === Syntax.JSXNamespacedName) {\n            return object.namespace.name + ':' + object.name.name;\n        }\n        /* istanbul ignore else */\n        if (object.type === Syntax.JSXMemberExpression) {\n            return (\n                getQualifiedJSXName(object.object) + '.' +\n                getQualifiedJSXName(object.property)\n            );\n        }\n        /* istanbul ignore next */\n        throwUnexpected(object);\n    }\n\n    function isJSXIdentifierStart(ch) {\n        // exclude backslash (\\)\n        return (ch !== 92) && isIdentifierStart(ch);\n    }\n\n    function isJSXIdentifierPart(ch) {\n        // exclude backslash (\\) and add hyphen (-)\n        return (ch !== 92) && (ch === 45 || isIdentifierPart(ch));\n    }\n\n    function scanJSXIdentifier() {\n        var ch, start, value = '';\n\n        start = index;\n        while (index < length) {\n            ch = source.charCodeAt(index);\n            if (!isJSXIdentifierPart(ch)) {\n                break;\n            }\n            value += source[index++];\n        }\n\n        return {\n            type: Token.JSXIdentifier,\n            value: value,\n            lineNumber: lineNumber,\n            lineStart: lineStart,\n            range: [start, index]\n        };\n    }\n\n    function scanJSXEntity() {\n        var ch, str = '', start = index, count = 0, code;\n        ch = source[index];\n        assert(ch === '&', 'Entity must start with an ampersand');\n        index++;\n        while (index < length && count++ < 10) {\n            ch = source[index++];\n            if (ch === ';') {\n                break;\n            }\n            str += ch;\n        }\n\n        // Well-formed entity (ending was found).\n        if (ch === ';') {\n            // Numeric entity.\n            if (str[0] === '#') {\n                if (str[1] === 'x') {\n                    code = +('0' + str.substr(1));\n                } else {\n                    // Removing leading zeros in order to avoid treating as octal in old browsers.\n                    code = +str.substr(1).replace(Regex.LeadingZeros, '');\n                }\n\n                if (!isNaN(code)) {\n                    return String.fromCharCode(code);\n                }\n            /* istanbul ignore else */\n            } else if (XHTMLEntities[str]) {\n                return XHTMLEntities[str];\n            }\n        }\n\n        // Treat non-entity sequences as regular text.\n        index = start + 1;\n        return '&';\n    }\n\n    function scanJSXText(stopChars) {\n        var ch, str = '', start;\n        start = index;\n        while (index < length) {\n            ch = source[index];\n            if (stopChars.indexOf(ch) !== -1) {\n                break;\n            }\n            if (ch === '&') {\n                str += scanJSXEntity();\n            } else {\n                index++;\n                if (ch === '\\r' && source[index] === '\\n') {\n                    str += ch;\n                    ch = source[index];\n                    index++;\n                }\n                if (isLineTerminator(ch.charCodeAt(0))) {\n                    ++lineNumber;\n                    lineStart = index;\n                }\n                str += ch;\n            }\n        }\n        return {\n            type: Token.JSXText,\n            value: str,\n            lineNumber: lineNumber,\n            lineStart: lineStart,\n            range: [start, index]\n        };\n    }\n\n    function scanJSXStringLiteral() {\n        var innerToken, quote, start;\n\n        quote = source[index];\n        assert((quote === '\\'' || quote === '\"'),\n            'String literal must starts with a quote');\n\n        start = index;\n        ++index;\n\n        innerToken = scanJSXText([quote]);\n\n        if (quote !== source[index]) {\n            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n        }\n\n        ++index;\n\n        innerToken.range = [start, index];\n\n        return innerToken;\n    }\n\n    /**\n     * Between JSX opening and closing tags (e.g. <foo>HERE</foo>), anything that\n     * is not another JSX tag and is not an expression wrapped by {} is text.\n     */\n    function advanceJSXChild() {\n        var ch = source.charCodeAt(index);\n\n        // '<' 60, '>' 62, '{' 123, '}' 125\n        if (ch !== 60 && ch !== 62 && ch !== 123 && ch !== 125) {\n            return scanJSXText(['<', '>', '{', '}']);\n        }\n\n        return scanPunctuator();\n    }\n\n    function parseJSXIdentifier() {\n        var token, marker = markerCreate();\n\n        if (lookahead.type !== Token.JSXIdentifier) {\n            throwUnexpected(lookahead);\n        }\n\n        token = lex();\n        return markerApply(marker, delegate.createJSXIdentifier(token.value));\n    }\n\n    function parseJSXNamespacedName() {\n        var namespace, name, marker = markerCreate();\n\n        namespace = parseJSXIdentifier();\n        expect(':');\n        name = parseJSXIdentifier();\n\n        return markerApply(marker, delegate.createJSXNamespacedName(namespace, name));\n    }\n\n    function parseJSXMemberExpression() {\n        var marker = markerCreate(),\n            expr = parseJSXIdentifier();\n\n        while (match('.')) {\n            lex();\n            expr = markerApply(marker, delegate.createJSXMemberExpression(expr, parseJSXIdentifier()));\n        }\n\n        return expr;\n    }\n\n    function parseJSXElementName() {\n        if (lookahead2().value === ':') {\n            return parseJSXNamespacedName();\n        }\n        if (lookahead2().value === '.') {\n            return parseJSXMemberExpression();\n        }\n\n        return parseJSXIdentifier();\n    }\n\n    function parseJSXAttributeName() {\n        if (lookahead2().value === ':') {\n            return parseJSXNamespacedName();\n        }\n\n        return parseJSXIdentifier();\n    }\n\n    function parseJSXAttributeValue() {\n        var value, marker;\n        if (match('{')) {\n            value = parseJSXExpressionContainer();\n            if (value.expression.type === Syntax.JSXEmptyExpression) {\n                throwError(\n                    value,\n                    'JSX attributes must only be assigned a non-empty ' +\n                        'expression'\n                );\n            }\n        } else if (match('<')) {\n            value = parseJSXElement();\n        } else if (lookahead.type === Token.JSXText) {\n            marker = markerCreate();\n            value = markerApply(marker, delegate.createLiteral(lex()));\n        } else {\n            throwError({}, Messages.InvalidJSXAttributeValue);\n        }\n        return value;\n    }\n\n    function parseJSXEmptyExpression() {\n        var ch, marker = markerCreatePreserveWhitespace();\n        while (index < length) {\n            ch = source.charCodeAt(index);\n            if (ch === 125) {\n                break;\n            } else if (isLineTerminator(ch)) {\n                if (ch === 13 && source.charCodeAt(index + 1) === 10) {\n                    ++index;\n                }\n                ++lineNumber;\n                lineStart = index;\n            }\n            ++index;\n        }\n        return markerApply(marker, delegate.createJSXEmptyExpression());\n    }\n\n    function parseJSXExpressionContainer() {\n        var expression, origInJSXChild, origInJSXTag, marker = markerCreate();\n\n        origInJSXChild = state.inJSXChild;\n        origInJSXTag = state.inJSXTag;\n        state.inJSXChild = false;\n        state.inJSXTag = false;\n\n        expect('{');\n\n        if (match('}')) {\n            expression = parseJSXEmptyExpression();\n        } else {\n            expression = parseExpression();\n        }\n\n        state.inJSXChild = origInJSXChild;\n        state.inJSXTag = origInJSXTag;\n\n        expect('}');\n\n        return markerApply(marker, delegate.createJSXExpressionContainer(expression));\n    }\n\n    function parseJSXSpreadAttribute() {\n        var expression, origInJSXChild, origInJSXTag, marker = markerCreate();\n\n        origInJSXChild = state.inJSXChild;\n        origInJSXTag = state.inJSXTag;\n        state.inJSXChild = false;\n        state.inJSXTag = false;\n\n        expect('{');\n        expect('...');\n\n        expression = parseAssignmentExpression();\n\n        state.inJSXChild = origInJSXChild;\n        state.inJSXTag = origInJSXTag;\n\n        expect('}');\n\n        return markerApply(marker, delegate.createJSXSpreadAttribute(expression));\n    }\n\n    function parseJSXAttribute() {\n        var name, marker;\n\n        if (match('{')) {\n            return parseJSXSpreadAttribute();\n        }\n\n        marker = markerCreate();\n\n        name = parseJSXAttributeName();\n\n        // HTML empty attribute\n        if (match('=')) {\n            lex();\n            return markerApply(marker, delegate.createJSXAttribute(name, parseJSXAttributeValue()));\n        }\n\n        return markerApply(marker, delegate.createJSXAttribute(name));\n    }\n\n    function parseJSXChild() {\n        var token, marker;\n        if (match('{')) {\n            token = parseJSXExpressionContainer();\n        } else if (lookahead.type === Token.JSXText) {\n            marker = markerCreatePreserveWhitespace();\n            token = markerApply(marker, delegate.createLiteral(lex()));\n        } else if (match('<')) {\n            token = parseJSXElement();\n        } else {\n            throwUnexpected(lookahead);\n        }\n        return token;\n    }\n\n    function parseJSXClosingElement() {\n        var name, origInJSXChild, origInJSXTag, marker = markerCreate();\n        origInJSXChild = state.inJSXChild;\n        origInJSXTag = state.inJSXTag;\n        state.inJSXChild = false;\n        state.inJSXTag = true;\n        expect('<');\n        expect('/');\n        name = parseJSXElementName();\n        // Because advance() (called by lex() called by expect()) expects there\n        // to be a valid token after >, it needs to know whether to look for a\n        // standard JS token or an JSX text node\n        state.inJSXChild = origInJSXChild;\n        state.inJSXTag = origInJSXTag;\n        expect('>');\n        return markerApply(marker, delegate.createJSXClosingElement(name));\n    }\n\n    function parseJSXOpeningElement() {\n        var name, attributes = [], selfClosing = false, origInJSXChild, origInJSXTag, marker = markerCreate();\n\n        origInJSXChild = state.inJSXChild;\n        origInJSXTag = state.inJSXTag;\n        state.inJSXChild = false;\n        state.inJSXTag = true;\n\n        expect('<');\n\n        name = parseJSXElementName();\n\n        while (index < length &&\n                lookahead.value !== '/' &&\n                lookahead.value !== '>') {\n            attributes.push(parseJSXAttribute());\n        }\n\n        state.inJSXTag = origInJSXTag;\n\n        if (lookahead.value === '/') {\n            expect('/');\n            // Because advance() (called by lex() called by expect()) expects\n            // there to be a valid token after >, it needs to know whether to\n            // look for a standard JS token or an JSX text node\n            state.inJSXChild = origInJSXChild;\n            expect('>');\n            selfClosing = true;\n        } else {\n            state.inJSXChild = true;\n            expect('>');\n        }\n        return markerApply(marker, delegate.createJSXOpeningElement(name, attributes, selfClosing));\n    }\n\n    function parseJSXElement() {\n        var openingElement, closingElement = null, children = [], origInJSXChild, origInJSXTag, marker = markerCreate();\n\n        origInJSXChild = state.inJSXChild;\n        origInJSXTag = state.inJSXTag;\n        openingElement = parseJSXOpeningElement();\n\n        if (!openingElement.selfClosing) {\n            while (index < length) {\n                state.inJSXChild = false; // Call lookahead2() with inJSXChild = false because </ should not be considered in the child\n                if (lookahead.value === '<' && lookahead2().value === '/') {\n                    break;\n                }\n                state.inJSXChild = true;\n                children.push(parseJSXChild());\n            }\n            state.inJSXChild = origInJSXChild;\n            state.inJSXTag = origInJSXTag;\n            closingElement = parseJSXClosingElement();\n            if (getQualifiedJSXName(closingElement.name) !== getQualifiedJSXName(openingElement.name)) {\n                throwError({}, Messages.ExpectedJSXClosingTag, getQualifiedJSXName(openingElement.name));\n            }\n        }\n\n        // When (erroneously) writing two adjacent tags like\n        //\n        //     var x = <div>one</div><div>two</div>;\n        //\n        // the default error message is a bit incomprehensible. Since it's\n        // rarely (never?) useful to write a less-than sign after an JSX\n        // element, we disallow it here in the parser in order to provide a\n        // better error message. (In the rare case that the less-than operator\n        // was intended, the left tag can be wrapped in parentheses.)\n        if (!origInJSXChild && match('<')) {\n            throwError(lookahead, Messages.AdjacentJSXElements);\n        }\n\n        return markerApply(marker, delegate.createJSXElement(openingElement, closingElement, children));\n    }\n\n    function parseTypeAlias() {\n        var id, marker = markerCreate(), typeParameters = null, right;\n        expectContextualKeyword('type');\n        id = parseVariableIdentifier();\n        if (match('<')) {\n            typeParameters = parseTypeParameterDeclaration();\n        }\n        expect('=');\n        right = parseType();\n        consumeSemicolon();\n        return markerApply(marker, delegate.createTypeAlias(id, typeParameters, right));\n    }\n\n    function parseInterfaceExtends() {\n        var marker = markerCreate(), id, typeParameters = null;\n\n        id = parseVariableIdentifier();\n        if (match('<')) {\n            typeParameters = parseTypeParameterInstantiation();\n        }\n\n        return markerApply(marker, delegate.createInterfaceExtends(\n            id,\n            typeParameters\n        ));\n    }\n\n    function parseInterfaceish(marker, allowStatic) {\n        var body, bodyMarker, extended = [], id,\n            typeParameters = null;\n\n        id = parseVariableIdentifier();\n        if (match('<')) {\n            typeParameters = parseTypeParameterDeclaration();\n        }\n\n        if (matchKeyword('extends')) {\n            expectKeyword('extends');\n\n            while (index < length) {\n                extended.push(parseInterfaceExtends());\n                if (!match(',')) {\n                    break;\n                }\n                expect(',');\n            }\n        }\n\n        bodyMarker = markerCreate();\n        body = markerApply(bodyMarker, parseObjectType(allowStatic));\n\n        return markerApply(marker, delegate.createInterface(\n            id,\n            typeParameters,\n            body,\n            extended\n        ));\n    }\n\n    function parseInterface() {\n        var marker = markerCreate();\n\n        if (strict) {\n            expectKeyword('interface');\n        } else {\n            expectContextualKeyword('interface');\n        }\n\n        return parseInterfaceish(marker, /* allowStatic */false);\n    }\n\n    function parseDeclareClass() {\n        var marker = markerCreate(), ret;\n        expectContextualKeyword('declare');\n        expectKeyword('class');\n\n        ret = parseInterfaceish(marker, /* allowStatic */true);\n        ret.type = Syntax.DeclareClass;\n        return ret;\n    }\n\n    function parseDeclareFunction() {\n        var id, idMarker,\n            marker = markerCreate(), params, returnType, rest, tmp,\n            typeParameters = null, value, valueMarker;\n\n        expectContextualKeyword('declare');\n        expectKeyword('function');\n        idMarker = markerCreate();\n        id = parseVariableIdentifier();\n\n        valueMarker = markerCreate();\n        if (match('<')) {\n            typeParameters = parseTypeParameterDeclaration();\n        }\n        expect('(');\n        tmp = parseFunctionTypeParams();\n        params = tmp.params;\n        rest = tmp.rest;\n        expect(')');\n\n        expect(':');\n        returnType = parseType();\n\n        value = markerApply(valueMarker, delegate.createFunctionTypeAnnotation(\n            params,\n            returnType,\n            rest,\n            typeParameters\n        ));\n\n        id.typeAnnotation = markerApply(valueMarker, delegate.createTypeAnnotation(\n            value\n        ));\n        markerApply(idMarker, id);\n\n        consumeSemicolon();\n\n        return markerApply(marker, delegate.createDeclareFunction(\n            id\n        ));\n    }\n\n    function parseDeclareVariable() {\n        var id, marker = markerCreate();\n        expectContextualKeyword('declare');\n        expectKeyword('var');\n        id = parseTypeAnnotatableIdentifier();\n\n        consumeSemicolon();\n\n        return markerApply(marker, delegate.createDeclareVariable(\n            id\n        ));\n    }\n\n    function parseDeclareModule() {\n        var body = [], bodyMarker, id, idMarker, marker = markerCreate(), token;\n        expectContextualKeyword('declare');\n        expectContextualKeyword('module');\n\n        if (lookahead.type === Token.StringLiteral) {\n            if (strict && lookahead.octal) {\n                throwErrorTolerant(lookahead, Messages.StrictOctalLiteral);\n            }\n            idMarker = markerCreate();\n            id = markerApply(idMarker, delegate.createLiteral(lex()));\n        } else {\n            id = parseVariableIdentifier();\n        }\n\n        bodyMarker = markerCreate();\n        expect('{');\n        while (index < length && !match('}')) {\n            token = lookahead2();\n            switch (token.value) {\n            case 'class':\n                body.push(parseDeclareClass());\n                break;\n            case 'function':\n                body.push(parseDeclareFunction());\n                break;\n            case 'var':\n                body.push(parseDeclareVariable());\n                break;\n            default:\n                throwUnexpected(lookahead);\n            }\n        }\n        expect('}');\n\n        return markerApply(marker, delegate.createDeclareModule(\n            id,\n            markerApply(bodyMarker, delegate.createBlockStatement(body))\n        ));\n    }\n\n    function collectToken() {\n        var loc, token, range, value, entry;\n\n        /* istanbul ignore else */\n        if (!state.inJSXChild) {\n            skipComment();\n        }\n\n        loc = {\n            start: {\n                line: lineNumber,\n                column: index - lineStart\n            }\n        };\n\n        token = extra.advance();\n        loc.end = {\n            line: lineNumber,\n            column: index - lineStart\n        };\n\n        if (token.type !== Token.EOF) {\n            range = [token.range[0], token.range[1]];\n            value = source.slice(token.range[0], token.range[1]);\n            entry = {\n                type: TokenName[token.type],\n                value: value,\n                range: range,\n                loc: loc\n            };\n            if (token.regex) {\n                entry.regex = {\n                    pattern: token.regex.pattern,\n                    flags: token.regex.flags\n                };\n            }\n            extra.tokens.push(entry);\n        }\n\n        return token;\n    }\n\n    function collectRegex() {\n        var pos, loc, regex, token;\n\n        skipComment();\n\n        pos = index;\n        loc = {\n            start: {\n                line: lineNumber,\n                column: index - lineStart\n            }\n        };\n\n        regex = extra.scanRegExp();\n        loc.end = {\n            line: lineNumber,\n            column: index - lineStart\n        };\n\n        if (!extra.tokenize) {\n            /* istanbul ignore next */\n            // Pop the previous token, which is likely '/' or '/='\n            if (extra.tokens.length > 0) {\n                token = extra.tokens[extra.tokens.length - 1];\n                if (token.range[0] === pos && token.type === 'Punctuator') {\n                    if (token.value === '/' || token.value === '/=') {\n                        extra.tokens.pop();\n                    }\n                }\n            }\n\n            extra.tokens.push({\n                type: 'RegularExpression',\n                value: regex.literal,\n                regex: regex.regex,\n                range: [pos, index],\n                loc: loc\n            });\n        }\n\n        return regex;\n    }\n\n    function filterTokenLocation() {\n        var i, entry, token, tokens = [];\n\n        for (i = 0; i < extra.tokens.length; ++i) {\n            entry = extra.tokens[i];\n            token = {\n                type: entry.type,\n                value: entry.value\n            };\n            if (entry.regex) {\n                token.regex = {\n                    pattern: entry.regex.pattern,\n                    flags: entry.regex.flags\n                };\n            }\n            if (extra.range) {\n                token.range = entry.range;\n            }\n            if (extra.loc) {\n                token.loc = entry.loc;\n            }\n            tokens.push(token);\n        }\n\n        extra.tokens = tokens;\n    }\n\n    function patch() {\n        if (typeof extra.tokens !== 'undefined') {\n            extra.advance = advance;\n            extra.scanRegExp = scanRegExp;\n\n            advance = collectToken;\n            scanRegExp = collectRegex;\n        }\n    }\n\n    function unpatch() {\n        if (typeof extra.scanRegExp === 'function') {\n            advance = extra.advance;\n            scanRegExp = extra.scanRegExp;\n        }\n    }\n\n    // This is used to modify the delegate.\n\n    function extend(object, properties) {\n        var entry, result = {};\n\n        for (entry in object) {\n            /* istanbul ignore else */\n            if (object.hasOwnProperty(entry)) {\n                result[entry] = object[entry];\n            }\n        }\n\n        for (entry in properties) {\n            /* istanbul ignore else */\n            if (properties.hasOwnProperty(entry)) {\n                result[entry] = properties[entry];\n            }\n        }\n\n        return result;\n    }\n\n    function tokenize(code, options) {\n        var toString,\n            token,\n            tokens;\n\n        toString = String;\n        if (typeof code !== 'string' && !(code instanceof String)) {\n            code = toString(code);\n        }\n\n        delegate = SyntaxTreeDelegate;\n        source = code;\n        index = 0;\n        lineNumber = (source.length > 0) ? 1 : 0;\n        lineStart = 0;\n        length = source.length;\n        lookahead = null;\n        state = {\n            allowKeyword: true,\n            allowIn: true,\n            labelSet: new StringMap(),\n            inFunctionBody: false,\n            inIteration: false,\n            inSwitch: false,\n            lastCommentStart: -1,\n            curlyStack: [],\n            curlyLastIndex: 0\n        };\n\n        extra = {};\n\n        // Options matching.\n        options = options || {};\n\n        // Of course we collect tokens here.\n        options.tokens = true;\n        extra.tokens = [];\n        extra.tokenize = true;\n        // The following two fields are necessary to compute the Regex tokens.\n        extra.openParenToken = -1;\n        extra.openCurlyToken = -1;\n\n        extra.range = (typeof options.range === 'boolean') && options.range;\n        extra.loc = (typeof options.loc === 'boolean') && options.loc;\n\n        if (typeof options.comment === 'boolean' && options.comment) {\n            extra.comments = [];\n        }\n        if (typeof options.tolerant === 'boolean' && options.tolerant) {\n            extra.errors = [];\n        }\n\n        patch();\n\n        try {\n            peek();\n            if (lookahead.type === Token.EOF) {\n                return extra.tokens;\n            }\n\n            token = lex();\n            while (lookahead.type !== Token.EOF) {\n                try {\n                    token = lex();\n                } catch (lexError) {\n                    token = lookahead;\n                    if (extra.errors) {\n                        extra.errors.push(lexError);\n                        // We have to break on the first error\n                        // to avoid infinite loops.\n                        break;\n                    } else {\n                        throw lexError;\n                    }\n                }\n            }\n\n            filterTokenLocation();\n            tokens = extra.tokens;\n            if (typeof extra.comments !== 'undefined') {\n                tokens.comments = extra.comments;\n            }\n            if (typeof extra.errors !== 'undefined') {\n                tokens.errors = extra.errors;\n            }\n        } catch (e) {\n            throw e;\n        } finally {\n            unpatch();\n            extra = {};\n        }\n        return tokens;\n    }\n\n    function parse(code, options) {\n        var program, toString;\n\n        toString = String;\n        if (typeof code !== 'string' && !(code instanceof String)) {\n            code = toString(code);\n        }\n\n        delegate = SyntaxTreeDelegate;\n        source = code;\n        index = 0;\n        lineNumber = (source.length > 0) ? 1 : 0;\n        lineStart = 0;\n        length = source.length;\n        lookahead = null;\n        state = {\n            allowKeyword: false,\n            allowIn: true,\n            labelSet: new StringMap(),\n            parenthesizedCount: 0,\n            inFunctionBody: false,\n            inIteration: false,\n            inSwitch: false,\n            inJSXChild: false,\n            inJSXTag: false,\n            inType: false,\n            lastCommentStart: -1,\n            yieldAllowed: false,\n            awaitAllowed: false,\n            curlyPosition: 0,\n            curlyStack: [],\n            curlyLastIndex: 0\n        };\n\n        extra = {};\n        if (typeof options !== 'undefined') {\n            extra.range = (typeof options.range === 'boolean') && options.range;\n            extra.loc = (typeof options.loc === 'boolean') && options.loc;\n            extra.attachComment = (typeof options.attachComment === 'boolean') && options.attachComment;\n\n            if (extra.loc && options.source !== null && options.source !== undefined) {\n                delegate = extend(delegate, {\n                    'postProcess': function (node) {\n                        node.loc.source = toString(options.source);\n                        return node;\n                    }\n                });\n            }\n\n            extra.sourceType = options.sourceType;\n            if (typeof options.tokens === 'boolean' && options.tokens) {\n                extra.tokens = [];\n            }\n            if (typeof options.comment === 'boolean' && options.comment) {\n                extra.comments = [];\n            }\n            if (typeof options.tolerant === 'boolean' && options.tolerant) {\n                extra.errors = [];\n            }\n            if (extra.attachComment) {\n                extra.range = true;\n                extra.comments = [];\n                extra.bottomRightStack = [];\n                extra.trailingComments = [];\n                extra.leadingComments = [];\n            }\n        }\n\n        patch();\n        try {\n            program = parseProgram();\n            if (typeof extra.comments !== 'undefined') {\n                program.comments = extra.comments;\n            }\n            if (typeof extra.tokens !== 'undefined') {\n                filterTokenLocation();\n                program.tokens = extra.tokens;\n            }\n            if (typeof extra.errors !== 'undefined') {\n                program.errors = extra.errors;\n            }\n        } catch (e) {\n            throw e;\n        } finally {\n            unpatch();\n            extra = {};\n        }\n\n        return program;\n    }\n\n    // Sync with *.json manifests.\n    exports.version = '15001.1.0-dev-harmony-fb';\n\n    exports.tokenize = tokenize;\n\n    exports.parse = parse;\n\n    // Deep copy.\n   /* istanbul ignore next */\n    exports.Syntax = (function () {\n        var name, types = {};\n\n        if (typeof Object.create === 'function') {\n            types = Object.create(null);\n        }\n\n        for (name in Syntax) {\n            if (Syntax.hasOwnProperty(name)) {\n                types[name] = Syntax[name];\n            }\n        }\n\n        if (typeof Object.freeze === 'function') {\n            Object.freeze(types);\n        }\n\n        return types;\n    }());\n\n}));\n/* vim: set sw=4 ts=4 et tw=80 : */\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}