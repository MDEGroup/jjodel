{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.LetExpression = void 0;\nvar Expression_1 = require(\"./Expression\");\n/**\n * @oclSpecification\n * Sometimes a sub-expression is used more than once in a constraint.\n * The let expression allows one to define a variable that can be used in the constraint.\n *\n * @oclExample\n * context Person inv:\n *      let income : Integer = self.job.salary->sum() in\n *      if isUnemployed then\n *          income < 100\n *      else\n *          income >= 100\n *      endif\n */\nvar LetExpression = /** @class */function (_super) {\n  __extends(LetExpression, _super);\n  function LetExpression(variableDeclarationExpressions, inContextDef) {\n    var _this = _super.call(this) || this;\n    _this.variableDeclarationExpressions = variableDeclarationExpressions;\n    _this.inContextDef = inContextDef;\n    return _this;\n  }\n  LetExpression.prototype.evaluate = function (visitor, localVariables) {\n    var _a;\n    var variableExpression = this.variableDeclarationExpressions[0];\n    var variables = (_a = {}, _a[variableExpression.getVariableName()] = variableExpression.evaluate(visitor), _a);\n    return this.inContextDef.evaluate(visitor, __assign(__assign({}, localVariables), variables));\n  };\n  return LetExpression;\n}(Expression_1.Expression);\nexports.LetExpression = LetExpression;","map":{"version":3,"names":["Expression_1","require","LetExpression","_super","__extends","variableDeclarationExpressions","inContextDef","_this","call","prototype","evaluate","visitor","localVariables","variableExpression","variables","_a","getVariableName","__assign","Expression","exports"],"sources":["../../../lib/components/expressions/LetExpression.ts"],"sourcesContent":[null],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAEA,IAAAA,YAAA,GAAAC,OAAA;AAGA;;;;;;;;;;;;;;AAcA,IAAAC,aAAA,0BAAAC,MAAA;EAAmCC,SAAA,CAAAF,aAAA,EAAAC,MAAA;EAC/B,SAAAD,cAAoBG,8BAAoE,EAAUC,YAAwB;IAA1H,IAAAC,KAAA,GACIJ,MAAA,CAAAK,IAAA,MAAO;IADSD,KAAA,CAAAF,8BAA8B,GAA9BA,8BAA8B;IAAgDE,KAAA,CAAAD,YAAY,GAAZA,YAAY;;EAE9G;EAEAJ,aAAA,CAAAO,SAAA,CAAAC,QAAQ,GAAR,UAASC,OAA4B,EAAEC,cAAoB;;IACvD,IAAMC,kBAAkB,GAAG,IAAI,CAACR,8BAA8B,CAAC,CAAC,CAAC;IACjE,IAAMS,SAAS,IAAAC,EAAA,OAAIA,EAAA,CAACF,kBAAkB,CAACG,eAAe,EAAE,IAAGH,kBAAkB,CAACH,QAAQ,CAACC,OAAO,CAAC,EAAAI,EAAA,CAAC;IAEhG,OAAO,IAAI,CAACT,YAAY,CAACI,QAAQ,CAACC,OAAO,EAAAM,QAAA,CAAAA,QAAA,KAAML,cAAc,GAAKE,SAAS,EAAE;EACjF,CAAC;EACL,OAAAZ,aAAC;AAAD,CAAC,CAXkCF,YAAA,CAAAkB,UAAU;AAAhCC,OAAA,CAAAjB,aAAA,GAAAA,aAAA"},"metadata":{},"sourceType":"script"}