{"ast":null,"code":"var _jsxFileName = \"C:\\\\0Programmi\\\\Dev\\\\projects\\\\frontend\\\\jjodel\\\\src\\\\graph\\\\graph\\\\graphContainer.tsx\",\n  _this = this;\nimport React, { PureComponent } from \"react\";\nimport { connect } from \"react-redux\";\nimport './graph.scss';\nimport { DPointerTargetable, LGraph } from \"../../joiner\";\n\n// private\nimport { Fragment as _Fragment } from \"react/jsx-dev-runtime\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nexport class GraphsContainerComponent extends PureComponent {\n  constructor(props, context) {\n    super(props, context);\n  }\n\n  // todo: per ogni vista crea un set di opzioni {enableAutocorrect: \"boolean(true)\", displayEdges: \"boolean(true)\", maximumGraphWidth: \"number(2000)\"} specificate dall\\'utente che deve specificare sia il tipo (Come se osse una funzione) che il valore predefinito\n  // il grafo deve leggere l'oggetto di opzioni e creare un menù che consente di cambiarle (una checkbox al posto dell'enableAutocorrect (bool), uno spinner per maximumGraphWidth (number...)\n\n  render() {\n    // const editinput = \"<input onChange={(e) => this.data.name = e.target.value } value={this.data.name} />\";\n    // const editinput = \"\";\n    // todo: rendi opzionale obj = this.data.id se non è specificato.\n    // const editinput = \"<Input obj={this.data.id} field={'name'} getter={val => val.toUpperCase()} setter={(val) => val.toLowerCase()} />\";\n    // \"<Input obj={this.data} field={'name'} getter={val => val.toUpperCase()} setter={(val) => val.toLowerCase()} />\";\n    return /*#__PURE__*/_jsxDEV(_Fragment, {\n      children: this.props.graphs.map(m => /*#__PURE__*/_jsxDEV(_Fragment, {\n        children: this.props.children /*<QA />*/\n      }, void 0, false))\n    }, void 0, false);\n  }\n}\n\n// private\n\n// private\n\n// private\n\n// private\n\n////// mapper func\n\nfunction mapStateToProps(state, ownProps) {\n  const ret = {};\n  console.log('mapStateToProps', {\n    ret,\n    state,\n    ownProps,\n    models: state.models\n  });\n  ret.models = state.models.length ? state.models.map(mid => mid && DPointerTargetable.wrap(state.idlookup[mid])) : [];\n  ret.graphs = state.graphs.length ? state.graphs.map(mid => mid && LGraph.wrap(state.idlookup[mid])) : [];\n  /// to fill\n  return ret;\n}\nfunction mapDispatchToProps(dispatch) {\n  const ret = {};\n  /// to fill\n  return ret;\n}\nconst GraphsContainerConnected = connect(mapStateToProps, mapDispatchToProps)(GraphsContainerComponent);\nexport const GraphsContainer = function (props) {\n  let childrens = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  return /*#__PURE__*/_jsxDEV(GraphsContainerConnected, {\n    ...props,\n    childrens\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 99,\n    columnNumber: 12\n  }, _this);\n};\n_c = GraphsContainer;\nvar _c;\n$RefreshReg$(_c, \"GraphsContainer\");","map":{"version":3,"names":["React","PureComponent","connect","DPointerTargetable","LGraph","Fragment","_Fragment","jsxDEV","_jsxDEV","GraphsContainerComponent","constructor","props","context","render","children","graphs","map","m","mapStateToProps","state","ownProps","ret","console","log","models","length","mid","wrap","idlookup","mapDispatchToProps","dispatch","GraphsContainerConnected","GraphsContainer","childrens","arguments","undefined","fileName","_jsxFileName","lineNumber","columnNumber","_this","_c","$RefreshReg$"],"sources":["C:/0Programmi/Dev/projects/frontend/jjodel/src/graph/graph/graphContainer.tsx"],"sourcesContent":["import React, {Dispatch, PureComponent, ReactElement, ReactNode} from \"react\";\r\nimport {connect} from \"react-redux\";\r\nimport './graph.scss';\r\nimport {DGraph, DModel, DPointerTargetable, IStore, LGraph, LModel} from \"../../joiner\";\r\n\r\n\r\n// private\r\ninterface ThisState { }\r\n\r\nexport class GraphsContainerComponent extends PureComponent<AllProps, ThisState>{\r\n    constructor(props: AllProps, context: any) {\r\n        super(props, context);\r\n    }\r\n\r\n    // todo: per ogni vista crea un set di opzioni {enableAutocorrect: \"boolean(true)\", displayEdges: \"boolean(true)\", maximumGraphWidth: \"number(2000)\"} specificate dall\\'utente che deve specificare sia il tipo (Come se osse una funzione) che il valore predefinito\r\n    // il grafo deve leggere l'oggetto di opzioni e creare un menù che consente di cambiarle (una checkbox al posto dell'enableAutocorrect (bool), uno spinner per maximumGraphWidth (number...)\r\n\r\n    render(): ReactNode {\r\n        // const editinput = \"<input onChange={(e) => this.data.name = e.target.value } value={this.data.name} />\";\r\n        // const editinput = \"\";\r\n        // todo: rendi opzionale obj = this.data.id se non è specificato.\r\n        // const editinput = \"<Input obj={this.data.id} field={'name'} getter={val => val.toUpperCase()} setter={(val) => val.toLowerCase()} />\";\r\n        // \"<Input obj={this.data} field={'name'} getter={val => val.toUpperCase()} setter={(val) => val.toLowerCase()} />\";\r\n        return (<>\r\n            {\r\n                this.props.graphs.map( (m: LGraph) => (\r\n                    <>\r\n                        {/*<svg style={{backgroundColor: 'red'}}>\r\n                        <Overlap style={{width: '100px'}}>\r\n                            success, now i can test resize handler overlayed to content and dragndrop dnd\r\n                            <foreignObject className={\"rectangle\"} />\r\n                            <foreignObject className={\"ellipse\"} />\r\n                            <foreignObject className={\"point\"} />\r\n                        </Overlap>\r\n                        </svg><svg style={{backgroundColor: 'red'}}>\r\n                            <Overlap>\r\n                                <foreignObject className={\"rectangle\"} style={{width: '100px'}}/>\r\n                                <foreignObject className={\"ellipse\"} style={{width: '300px'}}/>\r\n                                <foreignObject className={\"point\"} />\r\n                            </Overlap>\r\n                        </svg>* /}\r\n                        <GraphElement data={m} />*/}\r\n                        {/*\r\n                            Giordano comment this problem with model's children\r\n                            <Graph graphid={m.id} data={m.model} view={undefined}>\r\n                                <Vertex data={m.model}/>\r\n                            </Graph>\r\n\r\n                        */}\r\n                        {this.props.children/*<QA />*/}\r\n                    </>)\r\n                )\r\n            }\r\n        </>); }\r\n}\r\n\r\n// private\r\ninterface OwnProps {\r\n    // propsRequestedFromHtmlAsAttributes: string;\r\n}\r\n// private\r\ninterface StateProps {\r\n    models: LModel[];\r\n    graphs: LGraph[];\r\n    // propsFromReduxStateOrOtherKindOfStateManagement: boolean; // flux or custom things too, unrelated to this.state of react.\r\n}\r\n\r\n// private\r\ninterface DispatchProps {\r\n    // propsFromReduxActions: typeof funzioneTriggeraAzioneDaImportare;\r\n}\r\n\r\n\r\n// private\r\ntype AllProps = OwnProps & StateProps & DispatchProps;\r\n\r\n////// mapper func\r\n\r\nfunction mapStateToProps(state: IStore, ownProps: OwnProps): StateProps {\r\n    const ret: StateProps = {} as any;\r\n    console.log('mapStateToProps', {ret, state, ownProps, models: state.models})\r\n    ret.models = state.models.length ? state.models.map( (mid) => mid && DPointerTargetable.wrap(state.idlookup[mid] as DModel)) as LModel[] : [];\r\n    ret.graphs = state.graphs.length ? state.graphs.map( (mid) => mid && LGraph.wrap(state.idlookup[mid] as DGraph)) as LGraph[] : [];\r\n    /// to fill\r\n    return ret; }\r\n\r\nfunction mapDispatchToProps(dispatch: Dispatch<any>): DispatchProps {\r\n    const ret: DispatchProps = {} as any;\r\n    /// to fill\r\n    return ret; }\r\n\r\n\r\nconst GraphsContainerConnected = connect<StateProps, DispatchProps, OwnProps, IStore>(\r\n    mapStateToProps,\r\n    mapDispatchToProps\r\n)(GraphsContainerComponent);\r\n\r\nexport const GraphsContainer = (props: OwnProps, childrens: (string | React.Component)[] = []): ReactElement => {\r\n    return <GraphsContainerConnected {...{...props, childrens}} />; }\r\n\r\n"],"mappings":";;AAAA,OAAOA,KAAK,IAAaC,aAAa,QAAgC,OAAO;AAC7E,SAAQC,OAAO,QAAO,aAAa;AACnC,OAAO,cAAc;AACrB,SAAwBC,kBAAkB,EAAUC,MAAM,QAAe,cAAc;;AAGvF;AAAA,SAAAC,QAAA,IAAAC,SAAA;AAAA,SAAAC,MAAA,IAAAC,OAAA;AAGA,OAAO,MAAMC,wBAAwB,SAASR,aAAa,CAAqB;EAC5ES,WAAWA,CAACC,KAAe,EAAEC,OAAY,EAAE;IACvC,KAAK,CAACD,KAAK,EAAEC,OAAO,CAAC;EACzB;;EAEA;EACA;;EAEAC,MAAMA,CAAA,EAAc;IAChB;IACA;IACA;IACA;IACA;IACA,oBAAQL,OAAA,CAAAF,SAAA;MAAAQ,QAAA,EAEA,IAAI,CAACH,KAAK,CAACI,MAAM,CAACC,GAAG,CAAGC,CAAS,iBAC7BT,OAAA,CAAAF,SAAA;QAAAQ,QAAA,EAuBK,IAAI,CAACH,KAAK,CAACG,QAAQ;MAAA,gBACtB,CACN;IAAC,gBAEP,CAAC;EAAG;AACd;;AAEA;;AAIA;;AAOA;;AAMA;;AAGA;;AAEA,SAASI,eAAeA,CAACC,KAAa,EAAEC,QAAkB,EAAc;EACpE,MAAMC,GAAe,GAAG,CAAC,CAAQ;EACjCC,OAAO,CAACC,GAAG,CAAC,iBAAiB,EAAE;IAACF,GAAG;IAAEF,KAAK;IAAEC,QAAQ;IAAEI,MAAM,EAAEL,KAAK,CAACK;EAAM,CAAC,CAAC;EAC5EH,GAAG,CAACG,MAAM,GAAGL,KAAK,CAACK,MAAM,CAACC,MAAM,GAAGN,KAAK,CAACK,MAAM,CAACR,GAAG,CAAGU,GAAG,IAAKA,GAAG,IAAIvB,kBAAkB,CAACwB,IAAI,CAACR,KAAK,CAACS,QAAQ,CAACF,GAAG,CAAW,CAAC,CAAC,GAAe,EAAE;EAC7IL,GAAG,CAACN,MAAM,GAAGI,KAAK,CAACJ,MAAM,CAACU,MAAM,GAAGN,KAAK,CAACJ,MAAM,CAACC,GAAG,CAAGU,GAAG,IAAKA,GAAG,IAAItB,MAAM,CAACuB,IAAI,CAACR,KAAK,CAACS,QAAQ,CAACF,GAAG,CAAW,CAAC,CAAC,GAAe,EAAE;EACjI;EACA,OAAOL,GAAG;AAAE;AAEhB,SAASQ,kBAAkBA,CAACC,QAAuB,EAAiB;EAChE,MAAMT,GAAkB,GAAG,CAAC,CAAQ;EACpC;EACA,OAAOA,GAAG;AAAE;AAGhB,MAAMU,wBAAwB,GAAG7B,OAAO,CACpCgB,eAAe,EACfW,kBACJ,CAAC,CAACpB,wBAAwB,CAAC;AAE3B,OAAO,MAAMuB,eAAe,GAAG,SAAAA,CAACrB,KAAe,EAAiE;EAAA,IAA/DsB,SAAuC,GAAAC,SAAA,CAAAT,MAAA,QAAAS,SAAA,QAAAC,SAAA,GAAAD,SAAA,MAAG,EAAE;EACzF,oBAAO1B,OAAA,CAACuB,wBAAwB;IAAM,GAAGpB,KAAK;IAAEsB;EAAS;IAAAG,QAAA,EAAAC,YAAA;IAAAC,UAAA;IAAAC,YAAA;EAAA,GAAAC,KAAI,CAAC;AAAE,CAAC;AAAAC,EAAA,GADxDT,eAAe;AAAA,IAAAS,EAAA;AAAAC,YAAA,CAAAD,EAAA","ignoreList":[]},"metadata":{},"sourceType":"module"}