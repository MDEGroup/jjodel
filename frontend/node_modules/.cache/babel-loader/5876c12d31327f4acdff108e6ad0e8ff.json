{"ast":null,"code":"var _dec,_class,_class2,_dec2,_class3,_dec3,_class4,_class5,_dec4,_class6,_class7,_dec5,_class8,_class9,_dec6,_class10,_dec7,_class12,_class13,_dec8,_class14,_class15,_dec9,_class16,_class17,_dec10,_class18,_class19,_dec11,_class20,_class21,_dec12,_class22,_class23,_dec13,_class24,_class25,_dec14,_class26,_class27,_dec15,_class28,_class29,_dec16,_class30,_class31,_dec17,_class32,_class33,_dec18,_class34,_class35,_dec19,_class36,_class37,_dec20,_class38,_class39,_dec21,_class40,_class41,_dec22,_class42,_class43,_dec23,_class44,_class45,_dec24,_class46,_class47,_dec25,_class48,_class49,_dec26,_class50,_class51,_dec27,_class52,_class53,_dec28,_class54,_class55,_dec29,_class56,_class57,_dec30,_class58,_class59,_dec31,_class60,_class61,_dec32,_class62,_class63,_dec33,_class64,_dec34,_class66,_dec35,_class68,_class69,_dec36,_class70,_dec37,_class72,_class73,_dec38,_class74,_class75,_dec39,_class76,_class77,_dec40,_class78,_dec41,_class79,_class80,_dec42,_class81,_class82,_dec43,_class83,_class84,_dec44,_class85,_class86,_dec45,_class87,_class88,_dec46,_class89,_class90;import{UX}from\"../../joiner\";import{Abstract,BEGIN,Constructors,Debug,DPointerTargetable,END,Instantiable,Leaf,Log,LPointerTargetable,Node,PointedBy,Pointers,RuntimeAccessible,RuntimeAccessibleClass,Selectors,SetFieldAction,SetRootFieldAction,ShortAttribETypes,ShortAttribSuperTypes,store,TargetableProxyHandler,L,TRANSACTION,U,Uarr}from\"../../joiner\";import{AccessModifier,ECoreAnnotation,ECoreAttribute,ECoreClass,ECoreEnum,EcoreLiteral,ECoreOperation,ECorePackage,EcoreParser,ECoreReference,ECoreRoot}from\"../../api/data\";import{transientProperties}from\"../../joiner/classes\";import React from\"react\";import{jsx as _jsx}from\"react/jsx-runtime\";import{jsxs as _jsxs}from\"react/jsx-runtime\";export let DModelElement=(_dec=RuntimeAccessible('DModelElement'),Node(_class=_dec(_class=(_class2=class DModelElement extends DPointerTargetable{constructor(){super(...arguments);this.id=void 0;this.parent=[];this.father=void 0;this.annotations=[];}// static _super = DPointerTargetable;\n// static logic: typeof LModelElement;\n// static structure: typeof DModelElement;\n// static singleton: LModelElement;\n// instances: Pointer<DModelElement, 0, 'N', LModelElement> = [];\nstatic new(){Log.exx(\"DModelElement is abstract, cannot instantiate\");return null;//return new Constructors(new DModelElement('dwc')).DPointerTargetable().DModelElement().end();\n}static new3(){Log.exx(\"DModelElement is abstract, cannot instantiate\");return null;}static LFromHtml(target){return LPointerTargetable.fromPointer(DModelElement.PtrFromHtml(target));}static DFromHtml(target){return DPointerTargetable.fromPointer(DModelElement.PtrFromHtml(target));}static PtrFromHtml(target){while(target){if(target.attributes.dataid)return target.attributes.dataid.value;target=target.parentElement;}return undefined;}},_class2.subclasses=[],_class2._extends=[],_class2))||_class)||_class);export let DAnnotationDetail=(_dec2=RuntimeAccessible('DAnnotationDetail'),Leaf(_class3=_dec2(_class3=class DAnnotationDetail extends DPointerTargetable{// todo\n})||_class3)||_class3);export let LModelElement=(_dec3=RuntimeAccessible('LModelElement'),Abstract(_class4=_dec3(_class4=(_class5=class LModelElement extends LPointerTargetable{constructor(){super(...arguments);this.__raw=void 0;this.id=void 0;this.parent=void 0;this.father=void 0;this.__info_of__father={type:\"LModelElement\",txt:\"<a href=\\\"https://github.com/DamianoNaraku/jodel-react/wiki/LModelElement\\\"><span>The element containing this object.</span></a>\"};this.fatherList=void 0;this.annotations=void 0;this.children=void 0;this.__info_of__children__={type:\"LModelElement[]\",txt:/*#__PURE__*/_jsx(\"div\",{children:\"Merging of all the subelement collections (attributes, references, parameters...) except annotations\"})};this.nodes=void 0;this.node=void 0;this.model=void 0;this.package=void 0;this.class=void 0;this.enum=void 0;this.operation=void 0;this.subNodes=void 0;this.property=void 0;this.containers=void 0;this.name=void 0;this.isM1=void 0;this.__info_of__isM1={type:'()=>boolean',txt:/*#__PURE__*/_jsx(\"div\",{children:\"Whether the element belong to the metamodel or the model.\"})};this.isM2=void 0;this.__info_of__isM2={type:'()=>boolean',txt:/*#__PURE__*/_jsx(\"div\",{children:\"Whether the element belong to the metamodel or the model.\"})};this.isInstantiable=void 0;this.instantiable=void 0;this.__info_of__isInstantiable={type:'boolean',txt:/*#__PURE__*/_jsx(\"div\",{children:\"Whether the element type (DClass, DAttribute...) can produce an instance in the model.\"})};this.childNames=void 0;this.__info_of__childNames={type:\"(json: object, instanceof?: LClass) => LObject\",txt:\"Array containing the names of all children subelements.\"};this.__info_of__nodes={type:'LGraphElement[]',txt:\"Return all kind of graphic elements representing this modelElement currently displayed in the graph, including edges\"};this.__info_of__node={type:'LGraphElement[]',txt:\"Return the latest updated node representing this ModelElement, including those not currently displayed in the graph.\"};this.edges=void 0;this.edge=void 0;this.__info_of__edges={type:'LEdge[]',txt:\"The subset of \\\"nodes\\\" containing only edges.\"};this.__info_of__edge={type:'LEdge[]',txt:\"The first element of the collection edges\"};this.notEdges=void 0;this.notEdge=void 0;this.__info_of__notEdges={type:'LGraphElement[]',txt:\"The subset of \\\"nodes\\\" excluding only edges.\"};this.__info_of__notEdge={type:'LGraphElement',txt:\"The first element of the collection notEdges\"};this.vertexes=void 0;this.vertex=void 0;this.__info_of__vertexes={type:'LVertex[]',txt:\"The subset of \\\"nodes\\\" containing only vertexes.\"};this.__info_of__vertex={type:'LVertex',txt:\"The first element of the collection vertexes\"};this.edgePoints=void 0;this.edgePoint=void 0;this.__info_of__edgePoints={type:'LVertex[]',txt:\"The subset of \\\"nodes\\\" containing only edgePoints.\"};this.__info_of__edgePoint={type:'LVertex',txt:\"The first element of the collection edgePoints\"};this.graphs=void 0;this.graph=void 0;this.__info_of__graphs={type:'LGraph[]',txt:\"The subset of \\\"nodes\\\" containing only graphs.\"};this.__info_of__graph={type:'LGraph',txt:\"The first element of the collection graphs\"};this.fields=void 0;this.field=void 0;this.__info_of__fields={type:'LGraphElement[]',txt:\"The subset of \\\"nodes\\\" containing only fields.\"};this.__info_of__field={type:'LGraphElement',txt:\"The first element of the collection fields\"};}// extends Mixin(DModelElement0, LPointerTargetable)\n// static logic: typeof LModelElement;\n// static structure: typeof DModelElement;\n/* Alfonso */ /*static ResolvePointer = resolvePointerFunction;\r\n    private static ResolvePointers? = resolvePointersFunction;\r\n    private resolvePointer<T extends DPointerTargetable = DPointerTargetable, LB extends number = 0, UB extends number = 0, RET extends LPointerTargetable = LPointerTargetable>(ptr: Pointer<T, LB, UB, RET>): RET | null {\r\n        return LModelElement.ResolvePointer(ptr); }\r\n    private resolvePointers<T extends DPointerTargetable = DPointerTargetable, LB extends number = 0, RET extends LPointerTargetable = LPointerTargetable>(ptr: Pointer<T, LB, 'N', RET>)\r\n        : (RET | null)[] { return resolvePointersFunction(ptr); }\r\n    */ // annotations can be children of everything. except them fathers are: Model, Package, Classifier(class+enum), Operation\n// chain of fathers going up recursively\n// utilities to go up in the tree (singular names)\n// utility, follow father chain until get a Model parent or null\n// list of fathers until the model is reached.\n// protected _defaultGetter(c: Context, k: keyof Context[\"data\"]): any {}\n_defaultGetter(c,k){let targetObj=c.data;let proxyitself=c.proxyObject;// if not exist check for children names\nif(typeof k===\"string\"&&k!==\"children\"&&!(k in c.data)&&!(k in this)){// __info_of_children__\nlet lchildren;try{lchildren=this.get_children(c);}catch(e){lchildren=[];}// let dchildren: DPointerTargetable[] = lchildren.map<DPointerTargetable>(l => l.__raw as any);\nlet lc;let pk;if(TargetableProxyHandler.childKeys[k[0]]){pk=k.substring(1);}else pk=k;if(Array.isArray(lchildren))for(lc of lchildren){var _lc;let n=(_lc=lc)===null||_lc===void 0?void 0:_lc.name;if(n&&n.toLowerCase()===pk.toLowerCase())return lc;}}return super.__defaultGetter(c,k);}// this one must return true or the js engine throws an exception\n_defaultSetter(val,c,k){if(this._setterFor$stuff_canReturnFalse(val,c,k))return true;super._defaultSetter(val,c,k);return true;}// this one must be able to return false because is called by DObject and DValue default setters and return type is checked\n_setterFor$stuff_canReturnFalse(val,c,k){// if (![\"@\", \"$\"].includes(k[0])) return false;\nif(!TargetableProxyHandler.childKeys[k[0]])return false;let target=c.proxyObject[k];if(!target)return false;let l;let tClassName=target.className;// messanger classNames (pass it to next sublevel)\nnavigationloop:while(true){switch(tClassName){default:break navigationloop;case DPackage.cname:case DClass.cname:case DEnumerator.cname:case DObject.cname:target=target.children[0];continue navigationloop;}}// actiong classNames\nswitch(tClassName){default:Log.exx(\"default setter not supported for model element: \"+c.data.className,{c,k,val,target});return false;case DEnumLiteral.cname:l=target;switch(typeof val){default:return false;case\"string\":l.literal=val;return true;case\"number\":l.ordinal=val;return true;}return false;case DValue.cname:// makes object.$x = 1      be equivalent to object.$x.value = 1 (or values if is arr)\nl=target;l.values=val;return true;}}// Dstrudturalfeature in shapeless obj??\nget_isM1(c){// NB: if called with \"abstract classes\" like DModelElement, DTypedElement... responds they are in m2\nreturn()=>!c.data.isMetamodel&&LModelElement.M1Classes.includes(c.data.className);}get_isM2(c){return()=>!this.get_isM1(c);}get_isInstantiable(c){return this.get_instantiable(c);}get_instantiable(c){return LModelElement.M2InstantiableClasses.includes(c.data.className);}get_childNames(c){return this.get_children(c).map(c=>c.name).filter(c=>!!c);}generateEcoreJson(){let loopDetectionloopDetectionObj=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};throw new Error(\"cannot be called directly, should trigger getter. this is only for correct signature\");}get_generateEcoreJson(context){return loopdetectionobj=>this.generateEcoreJson_impl(context,loopdetectionobj);}generateEcoreJson_impl(context,loopDetectionObj){return Log.exDevv(\"generateEcoreJson() should be overridden\",context);}duplicate(){let deep=arguments.length>0&&arguments[0]!==undefined?arguments[0]:true;return this.cannotCall((this.constructor.cname||this.constructor.name)+\"duplicate() class is abstract\");}addAnnotation(source,details){return this.cannotCall(\"addAnnotation\");}get_addAnnotation(context){return(source,details)=>DAnnotation.new(source,details,context.data.id,true);}set_containers(){return this.cannotSet('containers');}get_containers(context){let thiss=context.proxyObject;const ret=[thiss];while(true){thiss=thiss.father;if(!thiss)break;ret.push(thiss);}return ret;}get_namespace(context){throw new Error(\"?? get namespace ?? todo\");return\"\";}get_subNodes(context){let includingthis=arguments.length>1&&arguments[1]!==undefined?arguments[1]:false;const lclass=context.proxyObject;let $class=$('[data-dataid=\"'+context.data.id+'\"]');let $subnodes=$class.find('[data-nodeid]');function mapfunc(){return this.dataset.nodeid;}let nodehtmlarr=$subnodes.toArray();if(includingthis)nodehtmlarr.push($class[0]);let nodeidarr=nodehtmlarr.map(html=>html.dataset.nodeid);let state=store.getState();let dnodes=nodeidarr.map(id=>state.idlookup[id]).filter(d=>!!d);return dnodes.map(d=>LPointerTargetable.wrap(d));}// name -> redux (es. DClass -> classs)\nget_property(context){return(context.data.className.substring(1)+\"s\").toLowerCase();}targetRemoved(context,field){context.proxyObject.delete();}get_fatherList(context){let ret=[context.proxyObject];let loopdetection={};loopdetection[context.data.id]=true;let current=this.get_father(context);while(current){if(loopdetection[current.id]){console.error(\"found loop\",{loopdetection,ret,current});return ret;}loopdetection[current.id]=true;ret.push(current);current=current.father;}return ret;}// @ts-ignore\nget_until_parent(l,d,father){while(true){var _l;// console.log('get_until_parent', {l, d, father}, {dname: d.className, fname: father.name});\nif(d.className===(father.cname||father.name))return l;l=l.father;let oldd=d;d=(_l=l)===null||_l===void 0?void 0:_l.__raw;if(oldd===d||!l)return null;// reached end of father chain (a model) without finding the desired parent.\n}}get_nodes(context){var _transientProperties$;return Object.values(((_transientProperties$=transientProperties.modelElement[context.data.id])===null||_transientProperties$===void 0?void 0:_transientProperties$.nodes)||{}).filter(n=>n&&n.html);/*\r\n        const nodes: LGraphElement[] = [];\r\n        const nodeElements = $('[data-dataid=\"' + context.data.id + '\"]'); nope, this must become more efficient. when node is created set action to update data.nodes array? or to update a transient property (better)\r\n        for (let nodeElement of nodeElements) {\r\n            const nodeId = nodeElement.id;\r\n            if (nodeId) {\r\n                const lNode: LGraphElement | undefined = LPointerTargetable.wrap(nodeId);\r\n                if (lNode) nodes.push(lNode);\r\n            }\r\n        }\r\n        return nodes;*/}get_node(context){var _transientProperties$2;return(_transientProperties$2=transientProperties.modelElement[context.data.id])===null||_transientProperties$2===void 0?void 0:_transientProperties$2.node;// const nodes = context.proxyObject.nodes;\n// return nodes.filter( n => n.favoriteNode)[0] || nodes[0];\n}get_edges(context){return this.get_nodes(context).filter(l=>{var _l$className;return(_l$className=l.className)===null||_l$className===void 0?void 0:_l$className.includes('Edge');});}get_edge(context){return this.get_nodes(context).find(l=>{var _l$className2;return(_l$className2=l.className)===null||_l$className2===void 0?void 0:_l$className2.includes('Edge');});}get_notEdges(context){return this.get_nodes(context).filter(l=>{var _l$className3;return!((_l$className3=l.className)===null||_l$className3===void 0?void 0:_l$className3.includes('Edge'));});}get_notEdge(context){return this.get_nodes(context).find(l=>{var _l$className4;return!((_l$className4=l.className)===null||_l$className4===void 0?void 0:_l$className4.includes('Edge'));});}get_vertexes(context){return this.get_nodes(context).filter(l=>{var _l$className5;return(_l$className5=l.className)===null||_l$className5===void 0?void 0:_l$className5.includes('Vertex');});}get_vertex(context){return this.get_nodes(context).find(l=>{var _l$className6;return(_l$className6=l.className)===null||_l$className6===void 0?void 0:_l$className6.includes('Vertex');});}get_edgePoints(context){return this.get_nodes(context).filter(l=>{var _l$className7;return(_l$className7=l.className)===null||_l$className7===void 0?void 0:_l$className7.includes('EdgePoint');});}get_edgePoint(context){return this.get_nodes(context).find(l=>{var _l$className8;return(_l$className8=l.className)===null||_l$className8===void 0?void 0:_l$className8.includes('EdgePoint');});}get_graphs(context){return this.get_nodes(context).filter(l=>{let d=l.__raw;return d.className==='DGraph'||d.className==='DGraphVertex';});}get_graph(context){return this.get_nodes(context).find(l=>{let d=l.__raw;return d.className==='DGraph'||d.className==='DGraphVertex';});}get_fields(context){return this.get_nodes(context).filter(l=>l.className==='DGraphElement');}get_field(context){return this.get_nodes(context).find(l=>l.className==='DGraphElement');}/*\r\n    protected get_nodes(context: Context): this[\"nodes\"] {\r\n        return context.data.nodes.map((pointer) => {\r\n            return LPointerTargetable.from(pointer)\r\n        });\r\n    }\r\n    protected set_nodes(val: PackArr<this[\"nodes\"]>, context: Context): boolean {\r\n        const list = val.map((lItem) => { return Pointers.from(lItem) });\r\n        SetFieldAction.new(context.data, 'nodes', list);\r\n        return true;\r\n    }\r\n    */get_model(context){return this.get_until_parent(context.proxyObject,context.data,DModel);}get_package(context){return this.get_until_parent(context.proxyObject,context.data,DPackage);}get_class(context){return this.get_until_parent(context.proxyObject,context.data,DClass);}// todo: might be better for pergormance to erase this universal method and add implementations to every single L-class counting the correct amount of \"father\" navigations for each ( attrib to package? use attrib.father.father)\nget_operation(context){return this.get_until_parent(context.proxyObject,context.data,DOperation);}get_enum(context){return this.get_until_parent(context.proxyObject,context.data,DEnumerator);}get_father(context){return LPointerTargetable.from(context.data.father);}get_children_idlist(context){// LPackage | LClassifier | LTypedElement | LAnnotation | LEnumLiteral | LParameter | LStructuralFeature | LOperation\nreturn context.data.annotations?[...context.data.annotations]:[];}get_children(context){// return this.get_children_idlist(context).map(e => LPointerTargetable.from(e));\nreturn LPointerTargetable.from(this.get_children_idlist(context));}set_children(a,context){return Log.exx('children is a derived read-only collection',context.data);}add_parent(val,logicContext){// todo: when will be used?\nconst ptr=Pointers.from(val);return SetFieldAction.new(logicContext.data,'parent',ptr,'+=',true);// todo: need to update children of the old and new parents\n}remove_parent(logicContext){// todo: perchè senza bersaglio? perchè sempre elimina tutti?\nreturn SetFieldAction.new(logicContext.data,'parent',[],'',true);}get_parent(context){return LPointerTargetable.from(context.data.id);}set_parent(val,context){// val: Pack<DModelElement>\nconst ptrs=Pointers.from(val);SetFieldAction.new(context.data,'father',(ptrs===null||ptrs===void 0?void 0:ptrs[0])||ptrs,'',true);return SetFieldAction.new(context.data,'parent',ptrs,'',true);}add_annotation(val,context){const ptrs=Pointers.from(val);return SetFieldAction.new(context.data,'annotations',ptrs,'+=',true);}remove_annotation(val,context){// todo: when this will be ever used? this should be triggered by LObject but only get_ / set_ and delete of whole elements should be triggerable.\n//todo: remove as any\nconst ptrs=Pointers.from(val);let indexes=ptrs.map(ptr=>context.data.annotations.indexOf(ptr)).filter(p=>p>=0);return SetFieldAction.new(context.data,'annotations',indexes,'-=',true);}get_annotations(context){return LPointerTargetable.fromPointer(context.data.annotations);}set_annotations(val,context){//  if (!Array.isArray(val)) val = [val];\n//         val = val.map( v => (v instanceof LAnnotation ? v.id : ( Pointers.filterValid(v) ? v : null ))) as Pointer<DAnnotation>[];\nconst ptrs=Pointers.from(val);SetFieldAction.new(context.data,'annotations',ptrs,'',true);return true;}get_addChild(c){var _this=this;// just for add new, not for add pre-existing.\nreturn function(type){var _ref,_this$get_class,_this$get_class2,_this$get_enum,_this$get_class3,_this$get_operation;let ret;let type0=type;if(!type||type===\"auto\"){switch(c.data.className){case DModel.cname:if(c.data.isMetamodel)type=\"package\";else type=\"object\";break;case DObject.cname:type=\"value\";break;case DPackage.cname:type=\"package\";break;case DClass.cname:type=\"attribute\";break;case DEnumerator.cname:type=\"literal\";break;case DOperation.cname:type=\"parameter\";break;default:type=\"annotation\";break;}}let fatherElement;switch(type.toLowerCase()){default:Log.ee('cannot find children type requested to add:',{type:(type||'').toLowerCase(),c});ret=()=>undefined;break;case\"package\":ret=(_ref=_this.get_package(c)||_this.get_model(c))===null||_ref===void 0?void 0:_ref.addPackage;break;case\"class\":// let current = c.proxyObject;\nfatherElement=_this.get_package(c);if(!fatherElement){let model=_this.get_model(c);fatherElement=model.packages[0];if(!fatherElement)fatherElement=model.addPackage();}ret=fatherElement.addClass;//ret = (this as any).get_addClass(context as any);\nbreak;case\"enum\":case\"enumerator\":fatherElement=_this.get_package(c);if(!fatherElement){let model=_this.get_model(c);fatherElement=model.packages[0];if(!fatherElement)fatherElement=model.addPackage();}ret=fatherElement.addEnumerator;break;case\"attribute\":ret=(_this$get_class=_this.get_class(c))===null||_this$get_class===void 0?void 0:_this$get_class.addAttribute;break;case\"reference\":ret=(_this$get_class2=_this.get_class(c))===null||_this$get_class2===void 0?void 0:_this$get_class2.addReference;break;case\"literal\":ret=(_this$get_enum=_this.get_enum(c))===null||_this$get_enum===void 0?void 0:_this$get_enum.addLiteral;break;case\"operation\":ret=(_this$get_class3=_this.get_class(c))===null||_this$get_class3===void 0?void 0:_this$get_class3.addOperation;break;case\"parameter\":ret=(_this$get_operation=_this.get_operation(c))===null||_this$get_operation===void 0?void 0:_this$get_operation.addParameter;break;case\"object\":if(c.data.className===\"DValue\"){ret=_this.get_addObject(c);}else{ret=_this.get_model(c).addObject;}//case \"exception\": ret = ((exception: Pack1<LClassifier>) => { let rett = this.get_addException(context as any); rett(exception); }) as any; break;\n/*case \"exception\": exceptions should not be \"added\" here, this is for creating objects. exceptions are not created but just linked. they are classes.\r\n                    ret = (this as any).get_addException(c as any);\r\n                    break; */}// console.log('x6 addchild()', {type0, type, args, fatherElement, ret, rts:ret?.toString()});\nfor(var _len=arguments.length,args=new Array(_len>1?_len-1:0),_key=1;_key<_len;_key++){args[_key-1]=arguments[_key];}return ret?ret(...args):null;};}get_addException(context){var _context$data;let ret=()=>{};const dOperation=((_context$data=context.data)===null||_context$data===void 0?void 0:_context$data.className)===\"DOperation\"?context.data:null;if(dOperation){const dClass=DPointerTargetable.from(dOperation.father);ret=()=>{SetFieldAction.new(dOperation,\"exceptions\",dClass.id,'+=',true);};}ret();return ret;}// activated by user in JSX\n// todo: this.wrongAccessMessage(\"addClass\");\ncannotCall(name){for(var _len2=arguments.length,params=new Array(_len2>1?_len2-1:0),_key2=1;_key2<_len2;_key2++){params[_key2-1]=arguments[_key2];}Log.exDevv(name+' should never be called directly, but should trigger get_'+name+'('+params.join(', ')+'), this is only a signature for type checking.');}addClass(){this.cannotCall('addClass');}addAttribute(){this.cannotCall('addAttribute');}addReference(){this.cannotCall('addReference');}addEnumerator(){this.cannotCall('addEnumerator');}addParameter(){this.cannotCall('addParameter');}// chiedere al prof: cosa può lanciato come eccezione: se tutte le classi o se solo quelle che estendono Exception\naddException(exception){throw this.wrongAccessMessage(\"AddException\");}addChild(type){return this.cannotCall('addChild',type);}},_class5.singleton=void 0,_class5.subclasses=[],_class5._extends=[],_class5.M1Classes=['DModel','DObject','DValue'],_class5.AbstractClasses=['DModelElement','DNamedElement','...'],_class5.M2InstantiableClasses=['DModel','DOperation','DClass','DReference','DAttribute'],_class5))||_class4)||_class4);/*function isValidPointer<T extends DPointerTargetable = DModelElement, LB extends number = 0, UB extends number = 1, RET extends LPointerTargetable = LModelElement>\r\n(p: Pointer<T, LB, UB, RET>, constraintType?: typeof DPointerTargetable): boolean {\r\n    const pointerval: RET | null = LModelElement.ResolvePointer(p);\r\n    if (!pointerval) return false;\r\n    if (!constraintType) return true;\r\n    return (pointerval instanceof constraintType); }*/ /* todo:\r\nnel proxy aggiungi regola di default, se prendi qualcosa che inizia con \"set_X\" esplicitamente (dovrebbe farlo solo il dev)\r\nrichiama _set_X(context, ...params)     <---- nuova funzione set di default, anche this.x = x richiama _set_x\r\n\r\nil dev specifica set_x come public di sola firma senza implementazione (throw exception) e senza context\r\nil dev specifica _set_x come implementazione private\r\n\r\nper la get esiste solo _get_x, non \"get_x\"\r\n\r\n todo2: aggiungi readonly a tutti i campi L per non sbagliarsi e fare in modo che il dev usi sempre i \"set_\" che sono correttamente tipizzati\r\n*\r\n* */ /*todo:\r\n* for every feature X: typed L, in CLASS_L0 with a side effects when they are edited (like need to update other data for consistency)\r\n*\r\n* dev will use this\r\n* protected set_X(val: D | L | Pointer<D> ) { throw new Error(\"set_X should never be executed, the proxy should redirect to get_set_X.\"); }\r\n* protected get_set_X( val: D | L | Pointer<D>, otherparams, ContextD>) { throw new Error(\"set_X should never be executed, the proxy should redirect to get_set_X.\"); }\r\n*\r\n*\r\n* */ // export type WModelElement = DModelElement | LModelElement | _WModelElement;\nRuntimeAccessibleClass.set_extend(DPointerTargetable,DModelElement);RuntimeAccessibleClass.set_extend(DPointerTargetable,LModelElement);export let DAnnotation=(_dec4=RuntimeAccessible('DAnnotation'),Leaf(_class6=_dec4(_class6=(_class7=class DAnnotation extends DModelElement{constructor(){super(...arguments);this.id=void 0;this.parent=[];this.father=void 0;this.annotations=[];this.source=void 0;this.details=void 0;}// extends Mixin(DAnnotation0, DModelElement)\n// static singleton: LAnnotation;\n// static logic: typeof LAnnotation;\n// static structure: typeof DAnnotation;\n// inherit redefine\n// personal\n//Dictionary<string, string>;\nstatic new(source,details,father){let persist=arguments.length>3&&arguments[3]!==undefined?arguments[3]:true;// if (!name) name = this.defaultname(\"annotation \", father);\nreturn new Constructors(new DAnnotation('dwc'),father,persist,undefined).DPointerTargetable().DModelElement().DAnnotation(source,details).end();}},_class7.subclasses=[],_class7._extends=[],_class7))||_class6)||_class6);export let LAnnotation=(_dec5=RuntimeAccessible('LAnnotation'),Node(_class8=_dec5(_class8=(_class9=class LAnnotation extends LModelElement{constructor(){super(...arguments);this.__namee=\"LAnnotation\";this.__raw=void 0;this.id=void 0;this.parent=void 0;this.father=void 0;this.annotations=void 0;this.source=void 0;this.details=void 0;}// Mixin(DAnnotation0, LModelElement)\n// @ts-ignore\n// static singleton: LAnnotation;\n// static logic: typeof LAnnotation;\n// static structure: typeof DAnnotation;\n// inherit redefine\n// personal\n// Dictionary<string, string> = {};\ngenerateEcoreJson_impl(context){let loopDetectionObj=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};loopDetectionObj[context.data.id]=context.data;const json={};EcoreParser.write(json,ECoreAnnotation.source,context.data.source);// EcoreParser.write(json, ECoreAnnotation.references, context.proxyObject.referencesStr);\nEcoreParser.write(json,ECoreAnnotation.details,context.proxyObject.details.map(d=>d.generateEcoreJson(loopDetectionObj)));return json;}duplicate(){let deep=arguments.length>0&&arguments[0]!==undefined?arguments[0]:true;return this.cannotCall((this.constructor.cname||this.constructor.name)+\"duplicate()\");}get_duplicate(context){return function(){let deep=arguments.length>0&&arguments[0]!==undefined?arguments[0]:false;BEGIN();let de=context.proxyObject.father.addAnnotation(context.data.source,deep?context.proxyObject.details.map(ldet=>ldet.duplicate().__raw):context.data.details);let le=LPointerTargetable.fromD(de);let we=le;we.annotations=deep?context.proxyObject.annotations.map(lchild=>lchild.duplicate(deep).id):context.data.annotations;END();return le;};}get_source(context){return context.data.source;}set_source(val,context){SetFieldAction.new(context.data,'source',val,'',false);return true;}get_details(context){return TargetableProxyHandler.wrapAll(context.data.details);}set_details(val,context){SetFieldAction.new(context.data,'details',val);return true;}},_class9.subclasses=[],_class9._extends=[],_class9))||_class8)||_class8);RuntimeAccessibleClass.set_extend(DModelElement,DAnnotation);RuntimeAccessibleClass.set_extend(LModelElement,LAnnotation);export let LAnnotationDetail=(_dec6=RuntimeAccessible('LAnnotationDetail'),Leaf(_class10=_dec6(_class10=class LAnnotationDetail extends LModelElement{constructor(){super(...arguments);this.father=void 0;}// todo\ngenerateEcoreJson_impl(context){let loopDetectionObj=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};// loopDetectionObj[context.data.id] = context.data;\nconst json={};// if (context.data.name !== null) EcoreParser.write(json, ECoreDetail.key, context.data.name);\n// if (context.data.value !== null) EcoreParser.write(json, ECoreDetail.value, context.data.value);\nreturn json;}duplicate(){let deep=arguments.length>0&&arguments[0]!==undefined?arguments[0]:true;return this.cannotCall((this.constructor.cname||this.constructor.name)+\"duplicate()\");}get_duplicate(context){Log.exDevv(\"LAnnotationDetail.getDuplicate(): todo\");return()=>this;// return (deep: boolean = false) => (context.proxyObject as LAnnotationDetail).father.addAnnotationDetail( {...context.data._subMaps})\n}})||_class10)||_class10);RuntimeAccessibleClass.set_extend(DModelElement,DAnnotationDetail);RuntimeAccessibleClass.set_extend(LModelElement,LAnnotationDetail);export let DNamedElement=(_dec7=RuntimeAccessible('DNamedElement'),Node(_class12=_dec7(_class12=(_class13=class DNamedElement extends DPointerTargetable{constructor(){super(...arguments);this.id=void 0;this.parent=[];this.father=void 0;this.annotations=[];this.name=void 0;}// Mixin(DNamedElement0, DAnnotation)\n// static _super = DAnnotation;\n// static singleton: LNamedElement;\n// static logic: typeof LNamedElement;\n// static structure: typeof DNamedElement;\n// inherit redefine\n// personal\nstatic new(name){Log.exx(\"DNamedElement is abstract, cannot instantiate\");return null;// return new Constructors(new DNamedElement('dwc')).DPointerTargetable().DModelElement().DNamedElement(name).end();\n}},_class13.subclasses=[],_class13._extends=[],_class13))||_class12)||_class12);export let LNamedElement=(_dec8=RuntimeAccessible('LNamedElement'),Abstract(_class14=_dec8(_class14=(_class15=class LNamedElement extends LModelElement{constructor(){super(...arguments);this.id=void 0;this.parent=void 0;this.father=void 0;this.annotations=void 0;this.name=void 0;this.namespace=void 0;this.fullname=void 0;}// Mixin(DNamedElement0, DAnnotation)\n// public __raw!: DNamedElement;\n// static singleton: LNamedElement;\n// static logic: typeof LNamedElement;\n// static structure: typeof DNamedElement;\n// inherit redefine\n// personal\nset_containers(){return this.cannotSet('containers');}get_containers(context){let thiss=context.proxyObject;const ret=[thiss];while(true){thiss=thiss.father;if(!thiss)break;ret.push(thiss);}return ret;}// protected get_namespace(context: Context): string { throw new Error(\"?? get namespace ?? todo\"); return \"\"; }\nget_fullName(context){return this.get_fullname(context);}get_fullname(context){const containers=this.get_containers(context).reverse();// let sliceindex = (containers[0] as LModel).dependencies.length ? 1 : 0;\nlet fullname=containers.slice(0,containers.length).map(c=>c.name).join('.');return fullname;}get_name(context){return context.data.name;}set_name(val,context){let name=val;const father=context.proxyObject.father;if(father){const check=father.children.filter(child=>{return DNamedElement.fromPointer(child.id).name===name;});if(check.length>0){U.alert('e','Cannot rename the selected element since this name is already taken.');return true;}}SetFieldAction.new(context.data,'name',name,'',false);return true;/*\r\n        // this autofix removes spaces with _\r\n        if (val.match(/\\s/)) val = this._autofix_name(val, context);\r\n        // todo: validate if operation can be completed or need autocorrection, then either return false (invalid parameter cannot complete) or send newVal at redux\r\n        const fixedVal: string = val;\r\n        SetFieldAction.new(context.data, 'name', fixedVal, '', false);\r\n        return true;\r\n        */}_autofix_name(val,context){// NB: NON fare autofix di univocità nome tra i children o qualsiasi cosa dipendente dal contesto, questo potrebbe essere valido in alcuni modelli e invalido in altri e modificare un oggetto condiviso.\nreturn val.replaceAll(/\\s/g,'_');}get_autofix_name(val,context){return val=>this._autofix_name(val,context);}autofix_name(val){return this.wrongAccessMessage(\"autofix_name\");}},_class15.subclasses=[],_class15._extends=[],_class15))||_class14)||_class14);// export type WNamedElement = DNamedElement | LNamedElement | _WNamedElement;\nRuntimeAccessibleClass.set_extend(DModelElement,DNamedElement);RuntimeAccessibleClass.set_extend(LModelElement,LNamedElement);export let DTypedElement=(_dec9=RuntimeAccessible('DTypedElement'),_dec9(_class16=(_class17=class DTypedElement extends DPointerTargetable{constructor(){super(...arguments);this.id=void 0;this.annotations=[];this.parent=[];this.father=void 0;this.name=void 0;this.instances=void 0;this.type=void 0;this.ordered=true;this.unique=true;this.lowerBound=0;this.upperBound=1;this.many=void 0;this.required=void 0;}// Mixin(DTypedElement0, DNamedElement)\n// static singleton: LTypedElement;\n// static logic: typeof LTypedElement;\n// static structure: typeof DTypedElement;\n// inherit redefine\n// personal\n// ?\n// ?\nstatic new(name,type,father){let persist=arguments.length>3&&arguments[3]!==undefined?arguments[3]:true;Log.exx(\"DTypedElement is abstract, cannot instantiate\");return null;//return new Constructors(new DTypedElement('dwc'), father, persist, undefined).DPointerTargetable().DModelElement().DNamedElement(name).DTypedElement(type).end();\n}},_class17.subclasses=[],_class17._extends=[],_class17))||_class16);export let LTypedElement=(_dec10=RuntimeAccessible('LTypedElement'),Abstract(_class18=_dec10(_class18=(_class19=class LTypedElement extends LNamedElement{constructor(){super(...arguments);this.__raw=void 0;this.id=void 0;this.parent=void 0;this.father=void 0;this.annotations=void 0;this.name=void 0;this.namespace=void 0;this.instances=void 0;this.type=void 0;this.primitiveType=void 0;this.classType=void 0;this.enumType=void 0;this.ordered=void 0;this.unique=void 0;this.lowerBound=void 0;this.upperBound=void 0;this.many=void 0;this.required=void 0;}// extends Mixin(DTypedElement0, LNamedElement)\n// static singleton: LTypedElement;\n// static logic: typeof LTypedElement;\n// static structure: typeof DTypedElement;\n// inherit redefine\n// personal\nget_classType(context){let type=this.get_type(context);return type.isClass?type:undefined;}get_enumType(context){let type=this.get_type(context);return type.isEnum?type:undefined;}get_primitiveType(context){let type=this.get_type(context);return type.isPrimitive?type:undefined;}get_type(context){return LPointerTargetable.from(context.data.type);}set_type(val,context){const data=context.data;let instances=context.proxyObject.instances;SetFieldAction.new(context.data,'type',Pointers.from(val),\"\",true);return true;}get_ordered(context){return context.data.ordered;}set_ordered(val,logicContext){return SetFieldAction.new(logicContext.data,'ordered',val);}get_unique(context){return context.data.unique;}set_unique(val,logicContext){return SetFieldAction.new(logicContext.data,'unique',val);}get_lowerBound(context){return context.data.lowerBound;}set_lowerBound(val,context){val=+val;if(isNaN(val))val=0;else val=Math.max(0,val);SetFieldAction.new(context.data,'lowerBound',val);if(context.data.upperBound!=-1&&val>context.data.upperBound)SetFieldAction.new(context.data,'upperBound',val);return true;}get_upperBound(context){return context.data.upperBound;}set_upperBound(val,context){val=+val;if(isNaN(val))val=-1;else val=Math.max(-1,val);SetFieldAction.new(context.data,'upperBound',val);if(val!==-1&&val<context.data.lowerBound)SetFieldAction.new(context.data,'lowerBound',val);return true;}get_many(context){return context.data.many;}set_many(val,context){SetFieldAction.new(context.data,'many',val);return true;}get_required(context){return context.data.required;}set_required(val,context){SetFieldAction.new(context.data,'required',val);return true;}typeToEcoreString(){return this.cannotCall(\"typeToEcoreString\");}get_typeToEcoreString(context){// if (context.data.classType) return EcoreParser.classTypePrefix + context.proxyObject.classType.name;\n// if (context.data.enumType) return EcoreParser.classTypePrefix + context.proxyObject.enumType.name;\n// if (context.data.primitiveType) return context.proxyObject.primitiveType.long;\nreturn()=>context.proxyObject.type.typeEcoreString;}typeToShortString(){return this.cannotCall(\"typeToShortString\");}get_typeToShortString(context){// if (context.data.classType) return '' + context.data.classType.name;\n// if (context.data.enumType) return '' + context.data.enumType.name;\n// if (context.data.primitiveType) return '' + context.data.primitiveType.getName();\nreturn()=>context.proxyObject.type.typeString;}canOverride(context,other){// i primitivi identici sono compatibili\nif(context.data.type===other.type.id)return true;let t1=context.proxyObject.type;let t2=other.type;// se entrambi primitivi\nif(context.proxyObject.primitiveType&&other.primitiveType){ShortAttribSuperTypes[t1.name].includes(other.name);}if(context.proxyObject.enumType)return t1===t2;// only if they are same enumerator\n// now assumed to be class type\nif(other.classType===other.classType)return true;return context.proxyObject.classType.isExtending(other.classType);}},_class19.subclasses=[],_class19._extends=[],_class19))||_class18)||_class18);// @RuntimeAccessible('') export class _WTypedElement extends _WNamedElement { }\n// export type WTypedElement = DTypedElement | LTypedElement | _WTypedElement;\nRuntimeAccessibleClass.set_extend(DNamedElement,DTypedElement);RuntimeAccessibleClass.set_extend(LNamedElement,LTypedElement);export let DClassifier=(_dec11=RuntimeAccessible('DClassifier'),_dec11(_class20=(_class21=class DClassifier extends DPointerTargetable{constructor(){super(...arguments);this.id=void 0;this.parent=[];this.father=void 0;this.annotations=[];this.name=void 0;this.instanceClassName=void 0;this.defaultValue=void 0;}// extends DNamedElement\n// static singleton: LClassifier;\n// static logic: typeof LClassifier;\n// static structure: typeof DClassifier;\n// inherit redefine\n// personal\n// instanceClass: EJavaClass // ?\n// isInstance(object: EJavaObject): boolean; ?\n// getClassifierID(): number;\nstatic new(name,father){let persist=arguments.length>2&&arguments[2]!==undefined?arguments[2]:true;Log.exx(\"DClassifier is abstract, cannot instantiate\");return null;// return new Constructors(new DClassifier('dwc'), father, persist, undefined).DPointerTargetable().DModelElement().DNamedElement(name).DClassifier().end();\n}},_class21.subclasses=[],_class21._extends=[],_class21))||_class20);export let LClassifier=(_dec12=RuntimeAccessible('LClassifier'),Abstract(_class22=_dec12(_class22=(_class23=class LClassifier extends LNamedElement{constructor(){super(...arguments);this.__raw=void 0;this.id=void 0;this.parent=void 0;this.father=void 0;this.annotations=void 0;this.name=void 0;this.namespace=void 0;this.instanceClassName=void 0;this.defaultValue=void 0;this.isPrimitive=void 0;this.isClass=void 0;this.isEnum=void 0;this.typeEcoreString=void 0;this.typeString=void 0;}// extends DNamedElement\n// static singleton: LClassifier;\n// static logic: typeof LClassifier;\n// static structure: typeof DClassifier;\n// inherit redefine\n// personal\n// instanceClass: EJavaClass // ?\n// isInstance(object: EJavaObject): boolean; ?\n// getClassifierID(): number;\nget_instanceClassName(context){return context.data.instanceClassName;}set_instanceClassName(val,context){SetFieldAction.new(context.data,'instanceClassName',val,\"\",false);return true;}set_isPrimitive(val,context){return this.cannotSet(\"isPrimitive\");}set_isClass(val,context){return this.cannotSet(\"isClass\");}set_isEnum(val,context){return this.cannotSet(\"isEnum\");}get_isPrimitive(context){return!!context.data.isPrimitive;}get_isClass(context){return context.data.isPrimitive?false:context.data.className===DClass.cname;}get_isEnum(context){return context.data.className===DEnumerator.cname;}set_defaultValue(val,context){if(typeof val!==\"object\"&&!Pointers.isPointer(val)){// primitive default value for enums\nSetFieldAction.new(context.data,'defaultValue',val,\"\",false);}else{SetFieldAction.new(context.data,'defaultValue',Pointers.from(val)||[],\"\",true);}return true;}get_typeEcoreString(context){return EcoreParser.classTypePrefix+context.data.name;}get_typeString(context){return context.data.name;}},_class23.subclasses=[],_class23._extends=[],_class23))||_class22)||_class22);// @RuntimeAccessible('') export class _WClassifier extends _WNamedElement { }\n// export type WClassifier = DClassifier | LClassifier | _WClassifier;\nRuntimeAccessibleClass.set_extend(DNamedElement,DClassifier);RuntimeAccessibleClass.set_extend(LNamedElement,LClassifier);export let DPackage=(_dec13=RuntimeAccessible('DPackage'),Leaf(_class24=_dec13(_class24=(_class25=class DPackage extends DPointerTargetable{constructor(){super(...arguments);this.id=void 0;this.parent=[];this.father=void 0;this.annotations=[];this.name=void 0;this.classifiers=[];this.subpackages=[];this.uri=void 0;this.prefix=void 0;}// extends DNamedElement\n// static _super = DNamedElement;\n// static singleton: LPackage;\n// static logic: typeof LPackage;\n// static structure: typeof DPackage;\n// inherit redefine\n// personal\nstatic new(name,uri,prefix,father){let persist=arguments.length>4&&arguments[4]!==undefined?arguments[4]:true;let fatherType=arguments.length>5?arguments[5]:undefined;let dmodel;if(!name){dmodel=father&&DPointerTargetable.from(father);name=this.defaultname(\"pkg_\",dmodel);}/*if (!uri) {\r\n            dmodel = dmodel || father && DPointerTargetable.from(father);\r\n            uri = ('org.jodel-react.') + (dmodel?.name || \"username\"); // (DPointerTargetable.from(DUser.current)).name) todo: when DUser is done\r\n        }*/return new Constructors(new DPackage('dwc'),father,persist,fatherType).DPointerTargetable().DModelElement().DNamedElement(name).DPackage(uri,prefix).end();}/*\r\n    static new15(setter: (d: DPackage) => void, father: DPackage[\"father\"], fatherType: Constructor, name?: string): DPackage {\r\n        if (!name) name = this.defaultname(\"pkg_\", father);\r\n        return new Constructors(new DPackage('dwc'), father, true, fatherType).DPointerTargetable().DModelElement()\r\n            .DNamedElement(name).DPackage().end(setter);\r\n    }\r\n    static new2(setter: Partial<ObjectWithoutPointers<DPackage>>, fatherType: Constructor, persist: boolean = true): DPackage {\r\n        if (!name) name = this.defaultname(\"pkg_\", father);\r\n        return new Constructors(new DPackage('dwc'), father, true, fatherType).DPointerTargetable().DModelElement()\r\n            .DNamedElement(name).DPackage().end((d)=> { Object.assign(d, setter); });\r\n    }*/static new3(a,callback,fatherType){let persist=arguments.length>3&&arguments[3]!==undefined?arguments[3]:true;if(!a.name)a.name=this.defaultname(\"pkg_\",a.father);return new Constructors(new DPackage('dwc'),a.father,persist,fatherType,a.id).DPointerTargetable().DModelElement().DNamedElement(a.name).DPackage().end(callback);}},_class25.subclasses=[],_class25._extends=[],_class25))||_class24)||_class24);export let LPackage=(_dec14=RuntimeAccessible('LPackage'),Leaf(_class26=_dec14(_class26=(_class27=class LPackage extends LNamedElement{constructor(){super(...arguments);this.__raw=void 0;this.id=void 0;this.parent=void 0;this.father=void 0;this.annotations=void 0;this.name=void 0;this.namespace=void 0;this.classifiers=void 0;this.subpackages=void 0;this.uri=void 0;this.prefix='';this.classes=void 0;this.enums=void 0;this.enumerators=void 0;this.allSubPackages=void 0;this.allSubEnums=void 0;this.allSubClasses=void 0;this.operations=void 0;this.parameters=void 0;this.exceptions=void 0;this.attributes=void 0;this.references=void 0;this.literals=void 0;}// extends DNamedElement\n// static singleton: LPackage;\n// static logic: typeof LPackage;\n// static structure: typeof DPackage;\n// inherit redefine\n// ype 'LPackage' is missing the following properties from type 'LModelElement': get_set_parent, set_parent\n// personal\n// derived\n// utilities to go down in the tree (plural names)\nget_name(c){var _$name;let l=c.proxyObject;let ret=((_$name=l['$name'])===null||_$name===void 0?void 0:_$name.value)||c.data.name;if(ret==='default'){let model=this.get_model(c);if(model.__raw.packages[0]===c.data.id)return model.name;}return ret;}generateEcoreJson_impltemplate(context){let loopDetectionObj=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};loopDetectionObj[context.data.id]=context.data;const json={};return json;}generateEcoreJson_impl(context){let loopDetectionObj=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};loopDetectionObj[context.data.id]=context.data;const model={};const d=context.data;let classarr=context.proxyObject.classes.map(c=>c.generateEcoreJson(loopDetectionObj));let enumarr=context.proxyObject.enums.map(e=>e.generateEcoreJson(loopDetectionObj));const classifiers=Array.prototype.concat.call(classarr,enumarr);model[ECorePackage.xmiversion]='2.0';model[ECorePackage.xmlnsxmi]='http://www.omg.org/XMI';model[ECorePackage.xmlnsxsi]='http://www.w3.org/2001/XMLSchema-instance';model[ECorePackage.xmlnsecore]='http://www.eclipse.org/emf/2002/Ecore';model[ECorePackage.namee]=d.name;model[ECorePackage.nsURI]=d.uri;model[ECorePackage.nsPrefix]=d.prefix;//getModelRoot().namespace();\nmodel[ECorePackage.eClassifiers]=classifiers;return model;}duplicate(){let deep=arguments.length>0&&arguments[0]!==undefined?arguments[0]:true;return this.cannotCall((this.constructor.cname||this.constructor.name)+\"duplicate()\");}get_duplicate(context){return function(){let deep=arguments.length>0&&arguments[0]!==undefined?arguments[0]:false;BEGIN();let le=context.proxyObject.father.addPackage(context.data.name,context.data.uri,context.data.prefix);let de=le.__raw;let we=le;we.subpackages=deep?context.proxyObject.subpackages.map(lchild=>lchild.duplicate(deep).id):context.data.subpackages;we.classifiers=deep?context.proxyObject.classifiers.map(lchild=>lchild.duplicate(deep).id):context.data.classifiers;we.annotations=deep?context.proxyObject.annotations.map(lchild=>lchild.duplicate(deep).id):context.data.annotations;END();return le;};}addPackage(name,uri,prefix){return this.cannotCall(\"addPackage\");}get_addPackage(context){console.log(\"Package.get_addPackage()\",{context,thiss:this});return(name,uri,prefix)=>{return LPointerTargetable.fromD(DPackage.new(name,uri,prefix,context.data.id,true,DPackage));};}addClass(name,isInterface,isAbstract,isPrimitive,isPartial,partialDefaultName){return this.cannotCall(\"addClass\");}get_addClass(context){return(name,isInterface,isAbstract,isPrimitive,isPartial,partialDefaultName)=>LPointerTargetable.fromD(DClass.new(name,isInterface,isAbstract,isPrimitive,isPartial,partialDefaultName,context.data.id,true));}addEnum(){return this.addEnumerator(...arguments);}get_addEnum(context){return this.get_addEnumerator(context);}addEnumerator(name){return this.cannotCall(\"addEnumerator\");}get_addEnumerator(context){return name=>LPointerTargetable.fromD(DEnumerator.new(name,context.data.id,true));}get_classes(context,state){let setNameKeys=arguments.length>2&&arguments[2]!==undefined?arguments[2]:true;if(!context.data.classifiers.length)return[];if(!state)state=store.getState();let classifiers=DPointerTargetable.fromPointer(context.data.classifiers,state);let dclasses=classifiers.filter(dc=>(dc===null||dc===void 0?void 0:dc.className)===DClass.cname);let lclasses=LPointerTargetable.fromD(dclasses);if(setNameKeys)for(let i=0;i<dclasses.length;i++)lclasses[\"$\"+dclasses[i].name]=lclasses[i];return lclasses;}get_enums(context){return this.get_enumerators(context);}get_enumerators(context,state){let setNameKeys=arguments.length>2&&arguments[2]!==undefined?arguments[2]:true;if(!context.data.classifiers.length)return[];if(!state)state=store.getState();let classifiers=DPointerTargetable.fromPointer(context.data.classifiers,state);let denums=classifiers.filter(dc=>(dc===null||dc===void 0?void 0:dc.className)===DEnumerator.cname);let lenums=LPointerTargetable.fromD(denums);if(setNameKeys)for(let i=0;i<denums.length;i++)lenums[\"$\"+denums[i].name]=lenums[i];return lenums;}//private get_allClasses(context: Context): LClass[] & Dictionary<DocString<\"$name\">, LClass> { return this.get_allSubClasses(c); }\nget_allSubClasses(context){// if (!context.data.isMetamodel) return (context.data.instanceof?.allSubClasses(context) || [] as any);\nconst s=store.getState();let arr=this.get_allSubPackages(context,s);let ret=[];// this.get_allSubPackages(context, s).flatMap(p => (p.classes || [])); this was losing the naming $keys!\nfor(let a of arr){let classarr=a.classes||[];U.mergeNamedArray(ret,classarr);}return ret;}get_allSubEnums(context){return this.get_allSubEnumerators(context);}get_allSubEnumerators(context){const s=store.getState();let arr=this.get_allSubPackages(context,s);let ret=[];// this.get_allSubPackages(context, s).flatMap(p => (p.enums || [])); this was losing the naming $keys!\nfor(let a of arr){let enumarr=a.enumerators||[];U.mergeNamedArray(ret,enumarr);}return ret;}get_allSubPackages(c,state){// return context.data.packages.map(p => LPointerTargetable.from(p));\nstate=state||store.getState();let tocheck=c.data.subpackages||[];let checked={};checked[c.data.id]=c.data;while(tocheck.length){let newtocheck=[];for(let ptr of tocheck){if(checked[ptr])throw new Error(\"loop in packages containing themselves\");let dpackage=DPointerTargetable.from(ptr,state);checked[ptr]=dpackage;U.arrayMergeInPlace(newtocheck,dpackage===null||dpackage===void 0?void 0:dpackage.subpackages);}tocheck=newtocheck;}let darr=Object.values(checked);let larr=LPointerTargetable.fromArr(darr,state);U.toNamedArray(larr,darr);return larr;}get_children_idlist(context){return[...super.get_children_idlist(context),...context.data.subpackages,...context.data.classifiers];}get_classifiers(context){return context.data.classifiers.map(pointer=>{return LPointerTargetable.from(pointer);});}set_classifiers(val,context){const list=val.map(lItem=>{return Pointers.from(lItem);});const oldList=context.data.classifiers;const diff=U.arrayDifference(oldList,list);BEGIN();SetFieldAction.new(context.data,'classifiers',list,\"\",true);for(let id of diff.added){SetFieldAction.new(id,'father',context.data.id,'',true);SetFieldAction.new(id,'parent',context.data.id,'+=',true);}for(let id of diff.removed){SetFieldAction.new(id,'father',undefined,'',true);const parent=DPointerTargetable.from(id).parent;U.arrayRemoveAll(parent,context.data.id);SetFieldAction.new(id,'parent',parent,'',true);}END();return true;}get_subpackages(context){return context.data.subpackages.map(pointer=>{return LPointerTargetable.from(pointer);});}set_subpackages(val,context){const list=val.map(lItem=>{return Pointers.from(lItem);});const oldList=context.data.subpackages;const diff=U.arrayDifference(oldList,list);BEGIN();SetFieldAction.new(context.data,'subpackages',list,\"\",true);for(let id of diff.added){SetFieldAction.new(id,'father',context.data.id,'',true);SetFieldAction.new(id,'parent',context.data.id,'+=',true);}for(let id of diff.removed){SetFieldAction.new(id,'father',undefined,'',true);const parent=DPointerTargetable.from(id).parent;U.arrayRemoveAll(parent,context.data.id);SetFieldAction.new(id,'parent',parent,'',true);}END();return true;}get_uri(context){var _context$proxyObject$;if(context.data.uri)return context.data.uri+\".\"+context.data.name;return'org.jodel-react.'+(((_context$proxyObject$=context.proxyObject.model)===null||_context$proxyObject$===void 0?void 0:_context$proxyObject$.name)||\"username\")+\".\"+context.data.name;}set_uri(val,context){val=val||'';let pos=val.lastIndexOf(context.data.name);if(pos)val=val.substring(0,pos-1);// removes final name and dot, to keep the name part dinamically added in the getter.\nSetFieldAction.new(context.data,'uri',val,\"\",false);return true;}get_prefix(context){return context.data.prefix;}set_prefix(val,context){SetFieldAction.new(context.data,'prefix',val,\"\",false);return true;}},_class27.subclasses=[],_class27._extends=[],_class27))||_class26)||_class26);// @RuntimeAccessible('') export class _WPackage extends _WNamedElement { }\n// export type WPackage = DPackage | LPackage | _WPackage;\nRuntimeAccessibleClass.set_extend(DNamedElement,DPackage);RuntimeAccessibleClass.set_extend(LNamedElement,LPackage);export let DOperation=(_dec15=RuntimeAccessible('DOperation'),Leaf(_class28=_dec15(_class28=(_class29=class DOperation extends DPointerTargetable{constructor(){super(...arguments);this.instances=void 0;this.id=void 0;this.annotations=[];this.parent=[];this.father=void 0;this.name=void 0;this.type=void 0;this.ordered=true;this.unique=true;this.lowerBound=0;this.upperBound=1;this.many=void 0;this.required=void 0;this.exceptions=[];this.parameters=[];this.visibility=AccessModifier.private;this.implementation=void 0;this.allowCrossReference=void 0;}// extends DTypedElement\n// static singleton: LOperation;\n// static logic: typeof LOperation;\n// static structure: typeof DOperation;\n// inherit redefine\n// personal\nstatic new(name,type){let exceptions=arguments.length>2&&arguments[2]!==undefined?arguments[2]:[];let father=arguments.length>3?arguments[3]:undefined;let persist=arguments.length>4&&arguments[4]!==undefined?arguments[4]:true;if(!name)name=this.defaultname(\"fx_\",father);if(!type)type=father;return new Constructors(new DOperation('dwc'),father,persist,undefined).DPointerTargetable().DModelElement().DNamedElement(name).DTypedElement(type).DOperation(exceptions).end();}static new2(setter,father,type,name){if(!name)name=this.defaultname(\"fx_\",father);if(!type)type=father;return new Constructors(new DOperation('dwc'),father,true).DPointerTargetable().DModelElement().DNamedElement(name).DTypedElement(type).DOperation().end(d=>{Object.assign(d,setter);});}static new3(a,callback){let persist=arguments.length>2&&arguments[2]!==undefined?arguments[2]:true;if(!a.name)a.name=this.defaultname(\"fx_\",a.father);if(!a.type)a.type=a.father;return new Constructors(new DOperation('dwc'),a.father,persist,undefined,a.id).DPointerTargetable().DModelElement().DNamedElement(a.name).DTypedElement(a.type).DOperation().end(callback);}},_class29.subclasses=[],_class29._extends=[],_class29))||_class28)||_class28);export let LOperation=(_dec16=RuntimeAccessible('LOperation'),Node(_class30=_dec16(_class30=(_class31=class LOperation extends LTypedElement{constructor(){super(...arguments);this.__raw=void 0;this.id=void 0;this.instances=void 0;this.annotations=void 0;this.parent=void 0;this.father=void 0;this.name=void 0;this.namespace=void 0;this.type=void 0;this.ordered=true;this.unique=true;this.lowerBound=0;this.upperBound=1;this.many=void 0;this.required=void 0;this.implementation=void 0;this.signatureImplementation=void 0;this.exceptions=void 0;this.parameters=void 0;this.visibility=void 0;this.allowCrossReference=void 0;}// extends DTypedElement\n// static singleton: LOperation;\n// static logic: typeof LOperation;\n// static structure: typeof DOperation;\n// inherit redefine\n// personal\n// (param1 /*type*/, param2 = value, ...) => /*return type*/\ngenerateEcoreJson_impl(context){let loopDetectionObj=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};loopDetectionObj[context.data.id]=context.data;const json={};json[ECoreOperation.eParameters]=context.proxyObject.parameters.map(par=>par.generateEcoreJson(loopDetectionObj));EcoreParser.write(json,ECoreOperation.namee,context.data.name);EcoreParser.write(json,ECoreOperation.eType,context.proxyObject.type.typeEcoreString);EcoreParser.write(json,ECoreOperation.lowerBound,''+context.data.lowerBound);EcoreParser.write(json,ECoreOperation.upperBound,''+context.data.upperBound);EcoreParser.write(json,ECoreOperation.eexceptions,context.proxyObject.exceptions.map(l=>l.typeEcoreString).join(' '));// todo: not really sure it's this format\nEcoreParser.write(json,ECoreOperation.ordered,''+context.data.ordered);EcoreParser.write(json,ECoreOperation.unique,''+context.data.unique);return json;}duplicate(){let deep=arguments.length>0&&arguments[0]!==undefined?arguments[0]:true;return this.cannotCall((this.constructor.cname||this.constructor.name)+\"duplicate()\");}get_duplicate(context){return function(){let deep=arguments.length>0&&arguments[0]!==undefined?arguments[0]:false;BEGIN();let le=context.proxyObject.father.addOperation(context.data.name,context.data.type);let de=le.__raw;de.many=context.data.many;de.lowerBound=context.data.lowerBound;de.upperBound=context.data.upperBound;de.ordered=context.data.ordered;de.required=context.data.required;de.unique=context.data.unique;de.visibility=context.data.visibility;de.exceptions=context.data.exceptions;let we=le;we.annotations=deep?context.proxyObject.annotations.map(lchild=>lchild.duplicate(deep).id):context.data.annotations;we.parameters=deep?context.proxyObject.parameters.map(lchild=>lchild.duplicate(deep).id):context.data.parameters;we.exceptions=context.data.exceptions;END();return le;};}addParameter(name,type){return this.cannotCall(\"addParameter\");}get_addParameter(context){return(name,type)=>LPointerTargetable.fromD(DParameter.new(name,type,context.data.id,true));}execute(thiss){return this.cannotCall(\"execute\");}get_execute(context){var _this2=this;return function(thiss){let func=eval(_this2.get_signatureImplementation(context,true)+\" {\\n\"+context.data.implementation+\"\\n}\");for(var _len3=arguments.length,params=new Array(_len3>1?_len3-1:0),_key3=1;_key3<_len3;_key3++){params[_key3-1]=arguments[_key3];}func.apply(thiss,params);};}set_implementation(val,context){return SetFieldAction.new(context.data.id,\"implementation\",val,undefined,false);}get_implementation(context){return context.data.implementation;}set_signatureImplementation(val,context){return this.cannotSet(\"signatureImplementation\");}get_signatureImplementation(context){let typedComments=arguments.length>1&&arguments[1]!==undefined?arguments[1]:true;let operation=context.proxyObject;let typedcommentpre=typedComments?\"/* :\":': ';let typedcommentpost=typedComments?\" */\":'';return\"(\"+operation.parameters.map(p=>p.name+(p.defaultValue!==undefined?\"=\"+p.defaultValue:typedcommentpre+p.typeToShortString()+typedcommentpost)).join(\", \")+\") => \"+typedcommentpre.replace(\":\",\"\")+operation.type+typedcommentpost;}get_signature(context){return this.get_signatureImplementation(context,false);}get_children_idlist(context){return[...super.get_children_idlist(context),...context.data.exceptions,...context.data.parameters];}get_exceptions(context){return context.data.exceptions.map(pointer=>{return LPointerTargetable.from(pointer);});}set_exceptions(val,context){const list=val.map(lItem=>{return Pointers.from(lItem);});SetFieldAction.new(context.data,'exceptions',list,\"\",true);return true;}get_parameters(context){return context.data.parameters.map(pointer=>{return LPointerTargetable.from(pointer);});}set_parameters(val,context){const list=val.map(lItem=>{return Pointers.from(lItem);});const oldList=context.data.parameters;const diff=U.arrayDifference(oldList,list);BEGIN();SetFieldAction.new(context.data,'parameters',list,\"\",true);for(let id of diff.added){SetFieldAction.new(id,'father',context.data.id,'',true);SetFieldAction.new(id,'parent',context.data.id,'+=',true);}for(let id of diff.removed){SetFieldAction.new(id,'father',undefined,'',true);const parent=DPointerTargetable.from(id).parent;U.arrayRemoveAll(parent,context.data.id);SetFieldAction.new(id,'parent',parent,'',true);}END();return true;}// protected get_type(context: Context): this[\"type\"] { return context.proxyObject.parameters[0].type; }\n// protected set_type(val: Pack1<this[\"type\"]>, context: Context): this[\"type\"] { return super.set_type(val, context); }\n_mark(b,superchildren,override){}_canOverride(superchildren){return undefined;}_canPolymorph(superchildren){return undefined;}},_class31.subclasses=[],_class31._extends=[],_class31))||_class30)||_class30);RuntimeAccessibleClass.set_extend(DTypedElement,DOperation);RuntimeAccessibleClass.set_extend(LTypedElement,LOperation);export let DParameter=(_dec17=RuntimeAccessible('DParameter'),Leaf(_class32=_dec17(_class32=(_class33=class DParameter extends DPointerTargetable{constructor(){super(...arguments);this.instances=void 0;this.id=void 0;this.annotations=[];this.parent=[];this.father=void 0;this.name=void 0;this.type=void 0;this.ordered=true;this.unique=true;this.lowerBound=0;this.upperBound=1;this.many=void 0;this.required=void 0;this.defaultValue=void 0;this.allowCrossReference=void 0;}// extends DTypedElement\n// static singleton: LParameter;\n// static logic: typeof LParameter;\n// static structure: typeof DParameter;\n// inherit redefine\n// personal\nstatic new(name,type,father){let persist=arguments.length>3&&arguments[3]!==undefined?arguments[3]:true;if(!type)type=LPointerTargetable.from(Selectors.getFirstPrimitiveTypes()).id;// default type as string\nif(!name)name=this.defaultname(\"arg\",father);return new Constructors(new DParameter('dwc'),father,persist,undefined).DPointerTargetable().DModelElement().DNamedElement(name).DTypedElement(type).DParameter().end();}static new2(setter,father,type,name){if(!name)name=this.defaultname(name||\"arg\",father);return new Constructors(new DParameter('dwc'),father,true).DPointerTargetable().DModelElement().DNamedElement(name).DTypedElement(type).end(d=>{Object.assign(d,setter);});}static new3(a,callback){let persist=arguments.length>2&&arguments[2]!==undefined?arguments[2]:true;if(!a.name)a.name=this.defaultname(\"arg\",a.father);return new Constructors(new DParameter('dwc'),a.father,persist,undefined,a.id).DPointerTargetable().DModelElement().DNamedElement(a.name).DTypedElement(a.type).DOperation().end(callback);}},_class33.subclasses=[],_class33._extends=[],_class33))||_class32)||_class32);export let LParameter=(_dec18=RuntimeAccessible('LParameter'),Leaf(_class34=_dec18(_class34=(_class35=class LParameter extends LTypedElement{constructor(){super(...arguments);this.__raw=void 0;this.id=void 0;this.instances=void 0;this.annotations=void 0;this.parent=void 0;this.father=void 0;this.name=void 0;this.namespace=void 0;this.type=void 0;this.ordered=true;this.unique=true;this.lowerBound=0;this.upperBound=1;this.many=void 0;this.required=void 0;this.defaultValue=void 0;this.allowCrossReference=void 0;}// extends DTypedElement\n// static singleton: LParameter;\n// static logic: typeof LParameter;\n// static structure: typeof DParameter;\n// inherit redefine\n// personal\ngenerateEcoreJson_impl(context){let loopDetectionObj=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};loopDetectionObj[context.data.id]=context.data;const json={};const l=context.proxyObject;const d=context.data;EcoreParser.write(json,ECoreOperation.lowerBound,''+d.lowerBound);EcoreParser.write(json,ECoreOperation.upperBound,''+d.upperBound);EcoreParser.write(json,ECoreOperation.ordered,''+d.ordered);EcoreParser.write(json,ECoreOperation.unique,''+d.unique);EcoreParser.write(json,ECoreOperation.eType,''+l.type.typeEcoreString);return json;}duplicate(){let deep=arguments.length>0&&arguments[0]!==undefined?arguments[0]:true;return this.cannotCall((this.constructor.cname||this.constructor.name)+\"duplicate()\");}get_duplicate(context){return function(){let deep=arguments.length>0&&arguments[0]!==undefined?arguments[0]:false;BEGIN();let le=context.proxyObject.father.addParameter(context.data.name,context.data.type);let de=le.__raw;de.many=context.data.many;de.lowerBound=context.data.lowerBound;de.upperBound=context.data.upperBound;de.ordered=context.data.ordered;de.required=context.data.required;de.unique=context.data.unique;let we=le;we.annotations=deep?context.proxyObject.annotations.map(lchild=>lchild.duplicate(deep).id):context.data.annotations;END();return le;};}},_class35.subclasses=[],_class35._extends=[],_class35))||_class34)||_class34);RuntimeAccessibleClass.set_extend(DTypedElement,DParameter);RuntimeAccessibleClass.set_extend(LTypedElement,LParameter);export class ClassReferences{constructor(){this.id=void 0;this.parent=void 0;this.father=void 0;this.instances=[];this.operations=[];this.features=[];this.references=[];this.attributes=[];this.referencedBy=[];this.extends=[];this.extendedBy=[];this.implements=[];this.implementedBy=[];}}export let DClass=(_dec19=RuntimeAccessible('DClass'),_dec19(_class36=(_class37=class DClass extends DPointerTargetable{constructor(){super(...arguments);this.id=void 0;this.instanceClassName=void 0;this.parent=[];this.father=void 0;this.annotations=[];this.name=void 0;this.defaultValue=void 0;this.abstract=false;this.interface=false;this.instances=[];this.operations=[];this.features=[];this.references=[];this.attributes=[];this.referencedBy=[];this.extends=[];this.extendedBy=[];this.isPrimitive=void 0;this.implements=[];this.implementedBy=[];this.partial=void 0;this.partialdefaultname=void 0;this.isSingleton=void 0;this.rootable=void 0;this.sealed=void 0;this.final=void 0;this.allowCrossReference=void 0;}// extends DClassifier\n// static _super = DClassifier;\n// static singleton: LClass;\n// static logic: typeof LClass;\n// static structure: typeof DClass;\n// inherit redefine\n// instanceClass: EJavaClass // ?\n// isInstance(object: EJavaObject): boolean; ?\n// getClassifierID(): number;\n// personal\n// isSuperTypeOf(someClass: DClassifier): boolean { return todoret; }\n// getEstructuralFeatureByID(featureID: number): DStructuralFeature { return todoret; }\n// getEstructuralFeature(featureName: string): DStructuralFeature { return todoret; }\n// mia aggiunta:\n//for extend\n// for m1:\n// hideExcessFeatures: boolean = true; // isn't it like partial?? // old comment: se attivo questo e creo una DClass di sistema senza nessuna feature e di nome Object, ho creato lo schema di un oggetto schema-less a cui tutti sono conformi\nstatic new(name){let isInterface=arguments.length>1&&arguments[1]!==undefined?arguments[1]:false;let isAbstract=arguments.length>2&&arguments[2]!==undefined?arguments[2]:false;let isPrimitive=arguments.length>3&&arguments[3]!==undefined?arguments[3]:false;let partial=arguments.length>4?arguments[4]:undefined;let partialDefaultName=arguments.length>5?arguments[5]:undefined;let father=arguments.length>6?arguments[6]:undefined;let persist=arguments.length>7&&arguments[7]!==undefined?arguments[7]:true;let id=arguments.length>8?arguments[8]:undefined;if(!name)name=this.defaultname(\"Concept \",father);// console.log('x6 addchild() new class', {father, arguments, name});\nreturn new Constructors(new DClass('dwc'),father,persist,undefined,id).DPointerTargetable().DModelElement().DNamedElement(name).DClassifier().DClass(isInterface,isAbstract,isPrimitive,partial,partialDefaultName).end();}static new2(setter,father,name){if(!name)name=this.defaultname(name||\"Concept \",father);return new Constructors(new DClass('dwc'),father,true,undefined).DPointerTargetable().DModelElement().DNamedElement(name).DClassifier().DClass().end(d=>{Object.assign(d,setter);});}static new3(a,callback){let persist=arguments.length>2&&arguments[2]!==undefined?arguments[2]:true;if(!a.name)a.name=this.defaultname(\"Concept \",a.father);return new Constructors(new DClass('dwc'),a.father,persist,undefined,a.id).DPointerTargetable().DModelElement().DNamedElement(a.name).DClassifier().DClass().end(callback);}},_class37.subclasses=[],_class37._extends=[],_class37))||_class36);window.dc=DClassifier;window.c=DClass;export let LClass=(_dec20=RuntimeAccessible('LClass'),Instantiable(_class38=Node(_class38=_dec20(_class38=(_class39=class LClass extends LClassifier{constructor(){super(...arguments);this.__raw=void 0;this.id=void 0;this.instanceClassName=void 0;this.parent=void 0;this.father=void 0;this.annotations=void 0;this.name=void 0;this.namespace=void 0;this.defaultValue=void 0;this.abstract=void 0;this.interface=void 0;this.instances=void 0;this.operations=void 0;this.features=void 0;this.references=void 0;this.attributes=void 0;this.referencedBy=void 0;this.extends=void 0;this.__info_of__extends={type:\"LClass[]\",txt:\"classes directly extended by this. check also: \\\"superclasses\\\".\"};this.extendsChain=void 0;this.extendedBy=void 0;this.nodes=void 0;this.allowCrossReference=void 0;this.sealed=void 0;this.__info_of__sealed={type:'LClass[]',txt:'A sealed class can specify a list of other classes that are allowed to extend it.'+'\\n A sealed class that does not allow any class to extend it is a \"final\" class.'};this.final=void 0;this.__info_of__final={type:'boolean',txt:'A final class cannot be extended.'};this.rootable=void 0;this.__info_of__roootable={type:'boolean',txt:'Specifies if the class can become a m1 model root, overriding the usual restriction of not being target of a containment reference.'};this.isSingleton=void 0;this.__info_of__singleton={type:'boolean',txt:'A singleton element is always present exactly 1 time in every model.'+'\\n A single instance is created dynamically and cannot be created by the user.'};this.instantiable=void 0;this.__info_of__intantiable={type:'boolean',txt:'Whether the class can be instantiated.'};this.aggregated=void 0;this.__info_of__aggregated={type:'boolean',txt:'Whether the class is targeted by an aggregation relationship.'};this.composed=void 0;this.__info_of__composed={type:'boolean',txt:'Whether the class is targeted by a composition relationship.'};this.contained=void 0;this.__info_of__contained={type:'boolean',txt:'Whether the class is targeted by a composition or aggregation relationship.'};this.superclasses=void 0;this.__info_of__superclasses={type:\"LClass[]\",txt:\"all classes directly and indirectly extended by this. same as check also: \\\"extends\\\".\"};this.allSubClasses=void 0;this.partialdefaultname=void 0;this.isPrimitive=void 0;this.isClass=void 0;this.isEnum=void 0;this.implements=[];this.implementedBy=[];this.ownAttributes=void 0;this.ownReferences=void 0;this.ownOperations=void 0;this.ownChildren=void 0;this.inheritedAttributes=void 0;this.inheritedReferences=void 0;this.inheritedOperations=void 0;this.inheritedChildren=void 0;this.allAttributes=void 0;this.allReferences=void 0;this.allOperations=void 0;this.allChildren=void 0;this.exceptions=void 0;this.parameters=void 0;this.validTargetsJSX=void 0;this.validTargetOptions=void 0;this.validTargets=void 0;this.allExtends=void 0;this.partial=void 0;this.__info_of__partial={type:'boolean',txt:'A partial object have can add unlisted features as a shapeless (schemaless) object does,'+' on top of a set of fixed listed features.'};this.allInstances=void 0;this.__info_of__allInstances={type:'LObject[]',txt:\"Instances in m1 of this class and of all subclasses.\"};this.__info_of__isSubclassOf={type:\"(superclass: Pointer | LClass, directly: boolean = false) => boolean\",txt:\"Alias for isExtending\"};this.__info_of__isExtending={type:\"(superclass: Pointer | LClass, directly: boolean = false) => boolean\",txt:/*#__PURE__*/_jsxs(\"div\",{children:[\"Tells if \\\"this\\\" is a subclass of the \\\"superclass\\\" parameter.\",/*#__PURE__*/_jsx(\"br\",{}),\"- If \\\"directly\\\" is set to true, it will only include direct subclassing as in \\\"class A extends C\\\" not considering chains.\",/*#__PURE__*/_jsx(\"br\",{}),\"    If \\\"directly\\\" is set to true: \\\"class A extends B\\\" & \\\"Class B extends C\\\". In that case A.isExtending(C, true) will return false.\"]})};}// extends DClassifier\n// static singleton: LClass;\n// static logic: typeof LClass;\n// static structure: typeof DClass;\n// inherit redefine\n// instanceClass: EJavaClass // ?\n// isInstance(object: EJavaObject): boolean; ?\n// getClassifierID(): number;\n// personal\n// isSuperTypeOf(someClass: DClassifier): boolean { return todoret; }\n// getEstructuralFeatureByID(featureID: number): DStructuralFeature { return todoret; }\n// getEstructuralFeature(featureName: string): DStructuralFeature { return todoret; }\n// list of all super classes (father, father of father, ...)  todo: isn't this the same as \"superclasses\" ? check implementation differeces, eventually remove one.\n// ipotesi, non so se tenerlo\n// fittizi:\n// false if it's primitive type\n//todo: interface\n// includes inherited and shadowed features\n// utilities to go down in the tree (plural names)\n// [`@${string}`]: LModelElement; todo: try to put it\nget_validTargetsJSX(c){let opts=[];this.get_validTargets(c,opts);return UX.options(opts);}get_validTargetOptions(c){let opts=[];this.get_validTargets(c,opts);return opts;}get_validTargets(c,out){let lclass=c.proxyObject;// let extendOptions: {value: string, label: string}[] lclass.extends.map(lsubclass=> ({value: lsubclass.id, label: lsubclass.name}));\nlet m2=lclass.model;let dclass=c.data;let extendsarr=lclass.extendsChain.map(l=>l.id);//dclass.extends;\nlet pkgs=dclass.allowCrossReference?m2.allCrossSubPackages:m2.allSubPackages;let extendValue=[];if(!out)out=[];let ret=[];out.push(...pkgs.map(p=>({label:p.fullname,options:p.classes.map(c=>{let opt={value:c.id,label:c.name};if(opt.value===dclass.id)return undefined;if(!extendsarr.includes(opt.value))return opt;extendValue.push(opt);ret.push(c);return undefined;}).filter(e=>!!e)})));return ret;}get_childNames(c){return this.get_allChildren(c).map(c=>c.name).filter(c=>!!c);}//get_isSealed(c: Context): LClass['sealed'] { return this.get_sealed(c); }\nget_sealed(c){return LPointerTargetable.wrapAll(c.data.sealed);}set_sealed(val,c){if(!val)val=[];else if(!Array.isArray(val))val=[val];const ptrs=[...new Set(val.map(val=>{return val&&Pointers.from(val);}).filter(e=>!!e))];if(Uarr.equalsUnsorted(c.data.sealed,ptrs))return true;TRANSACTION(()=>{SetFieldAction.new(c.data,'sealed',ptrs,'',true);if(ptrs.length){SetFieldAction.new(c.data,'isSingleton',false);SetFieldAction.new(c.data,'final',false);}else{SetFieldAction.new(c.data,'final',true);}});return true;}get_isFinal(c){return this.get_final(c);}get_final(c){return c.data.final;}set_final(val,c){if(val===c.data.final)return true;if(c.data.extendedBy.length>0){U.alert('e','Class cannot become final as it is currently extended. Remove the subclasses before.');return true;}TRANSACTION(()=>{SetFieldAction.new(c.data,'final',val);SetFieldAction.new(c.data,'sealed',[],'',true);if(!val)SetFieldAction.new(c.data,'isSingleton',false);});return true;}get_isSingleton(c){return this.get_singleton(c);}get_singleton(c){return c.data.isSingleton;}set_isSingleton(val,c){return this.set_singleton(val,c);}set_singleton(val,c){if(c.data.instances.length>1){U.alert('e','Class cannot become a singleton since there are multiple instances already. Delete some and retry.');return true;}if(c.data.extendedBy.length>0){U.alert('e','Class cannot become a singleton unless is also final, and is currently extended. Remove the subclasses before.');return true;}TRANSACTION(()=>{SetFieldAction.new(c.data,'isSingleton',val);if(val){SetFieldAction.new(c.data,'final',true);let m2=this.get_model(c);let instances=this.get_instances(c);let modelsWithInstance=instances.map(o=>{var _o$model;return(_o$model=o.model)===null||_o$model===void 0?void 0:_o$model.id;});for(let m1 of m2.instances){if(modelsWithInstance.includes(m1.id))continue;m1.addObject({name:c.data.name},c.data,true);}}});return c.data.final;}get_instantiable(c){return!(c.data.abstract||c.data.interface||c.data.isSingleton);}get_isInstantiable(c){return this.get_instantiable(c);}get_isComposed(c){return this.get_composed(c);}get_isAggregated(c){return this.get_aggregated(c);}get_isContained(c){return this.get_contained(c);}get_contained(c){let refs=this.get_referencedBy(c);for(let r of refs){if(r&&(r.aggregation||r.composition))return true;}return false;}get_aggregated(c){let refs=this.get_referencedBy(c);for(let r of refs)if(r&&r.aggregation)return true;return false;}get_composed(c){let refs=this.get_referencedBy(c);for(let r of refs)if(r&&r.composition)return true;return false;}get_isRootable(c){return this.get_rootable(c);}get_rootable(c){if(c.data.rootable!==undefined)return c.data.rootable;else return this.get_instantiable(c)&&!this.get_isComposed(c);}set_rootable(val,c){SetFieldAction.new(c.data,'rootable',val);return true;}get_ownAttributes(context){return LAttribute.fromPointer(context.data.attributes);}get_ownReferences(context){return LReference.fromPointer(context.data.references);}get_ownOperations(context){return LOperation.fromPointer(context.data.operations);}get_ownChildren(context){return U.arrayMergeInPlace(this.get_ownAttributes(context),this.get_ownReferences(context),this.get_ownOperations(context));}get_allExtends(c){return this.get_extendsChain(c);}get_extendsChain(context){let targets=LClass.fromArr(context.data.extends);let alreadyParsed={};while(targets.length){let nextTargets=[];for(let target of targets){if(alreadyParsed[target.id])continue;alreadyParsed[target.id]=target;for(let next of target.extends)nextTargets.push(next);}targets=nextTargets;}return Object.values(alreadyParsed);}isSubClassOf(superClass){let returnIfSameClass=arguments.length>1&&arguments[1]!==undefined?arguments[1]:true;return this.cannotCall(\"isSubClassOf\");}isSuperClassOf(subClass){let returnIfSameClass=arguments.length>1&&arguments[1]!==undefined?arguments[1]:true;return this.cannotCall(\"isSuperClassOf\");}get_isSubClassOf(c){var _this3=this;return function(superClass){let returnIfSameClass=arguments.length>1&&arguments[1]!==undefined?arguments[1]:true;superClass=LPointerTargetable.wrap(superClass);if(!superClass)return false;if(superClass.id===c.data.id)return returnIfSameClass;for(let subclass of _this3.get_extendsChain(c)){if(subclass.id===superClass.id)return true;}return false;};}get_isSuperClassOf(c){return function(subClass){let returnIfSameClass=arguments.length>1&&arguments[1]!==undefined?arguments[1]:true;if(!subClass)return false;if(subClass.id===c.data.id)return returnIfSameClass;return subClass.isSubClassOf(c.proxyObject,returnIfSameClass);};}get_inheritedAttributes(context){return this.get_extendsChain(context).flatMap(superClass=>superClass.ownAttributes);}get_inheritedReferences(context){return this.get_extendsChain(context).flatMap(superClass=>superClass.ownReferences);}get_inheritedOperations(context){return this.get_extendsChain(context).flatMap(superClass=>superClass.ownOperations);}get_inheritedChildren(context){return U.arrayMergeInPlace(this.get_inheritedAttributes(context),this.get_inheritedReferences(context),this.get_inheritedOperations(context));}get_allAttributes(context){return U.arrayMergeInPlace(this.get_ownAttributes(context),this.get_inheritedAttributes(context));}get_allReferences(context){return U.arrayMergeInPlace(this.get_ownReferences(context),this.get_inheritedReferences(context));}get_allOperations(context){return U.arrayMergeInPlace(this.get_ownOperations(context),this.get_inheritedOperations(context));}get_allChildren(context){return U.arrayMergeInPlace(this.get_ownChildren(context),this.get_inheritedChildren(context));}generateEcoreJson_impl(context){let loopDetectionObj=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};loopDetectionObj[context.data.id]=context.data;const json={};const featurearr=[];const operationsarr=[];let supertypesstr=[];const d=context.data;const l=context.proxyObject;for(let att of l.attributes){featurearr.push(att.generateEcoreJson(loopDetectionObj));}for(let ref of l.references){featurearr.push(ref.generateEcoreJson(loopDetectionObj));}for(let op of l.operations){operationsarr.push(op.generateEcoreJson(loopDetectionObj));}json[ECoreClass.xsitype]='ecore:EClass';json[ECoreClass.namee]=d.name;json[ECoreClass.interface]=U.toBoolString(d.interface,false);json[ECoreClass.abstract]=U.toBoolString(d.abstract,false);if(d.instanceClassName)json[ECoreClass.instanceTypeName]=d.instanceClassName;json[ECoreClass.eSuperTypes]=l.extends.map(superclass=>superclass.typeEcoreString).join(\" \");if(featurearr)json[ECoreClass.eStructuralFeatures]=featurearr;if(operationsarr)json[ECoreClass.eOperations]=operationsarr;return json;}duplicate(){let deep=arguments.length>0&&arguments[0]!==undefined?arguments[0]:true;return this.cannotCall((this.constructor.cname||this.constructor.name)+\"duplicate()\");}get_duplicate(context){return function(){let deep=arguments.length>0&&arguments[0]!==undefined?arguments[0]:false;let ret=undefined;TRANSACTION(()=>{let le=context.proxyObject.father.addClass(context.data.name,context.data.interface,context.data.abstract,context.data.isPrimitive);let de=le.__raw;// de.hideExcessFeatures = context.data.hideExcessFeatures;\nlet we=le;we.defaultValue=context.data.defaultValue;we.extends=context.data.extends;we.attributes=deep?context.proxyObject.attributes.map(lchild=>lchild.duplicate(deep).id):context.data.attributes;we.references=deep?context.proxyObject.references.map(lchild=>lchild.duplicate(deep).id):context.data.references;we.operations=deep?context.proxyObject.operations.map(lchild=>lchild.duplicate(deep).id):context.data.operations;ret=le;// set ret = le only if the transaction is complete.\n});return ret;};}get_children_idlist(context){return[...super.get_children_idlist(context),...context.data.attributes,...context.data.references,...context.data.operations];}set_name(val,context){if(context.data.name===val)return true;super.set_name(val,context);SetRootFieldAction.new('ClassNameChanged.'+context.data.id,val,'',false);// it is pointer, but related to transient stuff, so don't need pointedBy's\nreturn true;}set_partial(val,context){return SetFieldAction.new(context.data.id,\"partial\",val);}get_partial(context){return context.data.partial;}set_partialdefaultname(val,context){return SetFieldAction.new(context.data.id,\"partialdefaultname\",val,undefined,false);}get_partialdefaultname(context){return context.data.partialdefaultname;}addAttribute(name,type){return this.cannotCall(\"addAttribute\");}get_addAttribute(context){return(name,type)=>LPointerTargetable.fromD(DAttribute.new(name,type,context.data.id,true));}addReference(name,type){return this.cannotCall(\"addReference\");}get_addReference(context){return(name,type)=>LPointerTargetable.fromD(DReference.new(name,type,context.data.id,true));}addOperation(name,type){return this.cannotCall(\"addOperation\");}get_addOperation(context){return(name,type)=>LPointerTargetable.fromD(DOperation.new(name,type,[],context.data.id,true));}get_abstract(context){return context.data.abstract;}set_abstract(val,context){const data=context.data;if(val&&data.instances.length>0){U.alert('e','Cannot change the abstraction level since there are instances.');}else{SetFieldAction.new(data,'abstract',val);}return true;}set_isPrimitive(val,context){SetFieldAction.new(context.data,'isPrimitive',val);return true;}// get is in classifier with all other \"type\"s getter and setter\nget_interface(context){return context.data.interface;}set_interface(val,c){if(val&&c.data.instances.length>0){U.alert('e','Class cannot become an interface since there are instances.');}else{SetFieldAction.new(c.data,'interface',val);}return true;}get_allInstances(context){let sc=this.get_allSubClasses(context,true);return sc.flatMap(c=>c.instances);}get_instances(context){return context.data.instances.map(pointer=>{return LPointerTargetable.from(pointer);});}set_instances(val,context){const list=val.map(lItem=>{return Pointers.from(lItem);});SetFieldAction.new(context.data,'instances',list,\"\",true);return true;}get_operations(context){return context.data.operations.map(pointer=>{return LPointerTargetable.from(pointer);});}set_operations(val,context){const list=val.map(lItem=>{return Pointers.from(lItem);});const oldList=context.data.operations;const diff=U.arrayDifference(oldList,list);BEGIN();SetFieldAction.new(context.data,'operations',list,\"\",true);for(let id of diff.added){SetFieldAction.new(id,'father',context.data.id,'',true);SetFieldAction.new(id,'parent',context.data.id,'+=',true);}for(let id of diff.removed){SetFieldAction.new(id,'father',undefined,'',true);const parent=DPointerTargetable.from(id).parent;U.arrayRemoveAll(parent,context.data.id);SetFieldAction.new(id,'parent',parent,'',true);}END();return true;}get_features(context){return context.data.features.map(pointer=>{return LPointerTargetable.from(pointer);});}set_features(val,context){const list=val.map(lItem=>{return Pointers.from(lItem);});const oldList=context.data.features;const diff=U.arrayDifference(oldList,list);BEGIN();SetFieldAction.new(context.data,'features',list,\"\",true);for(let id of diff.added){SetFieldAction.new(id,'father',context.data.id,'',true);SetFieldAction.new(id,'parent',context.data.id,'+=',true);}for(let id of diff.removed){SetFieldAction.new(id,'father',undefined,'',true);const parent=DPointerTargetable.from(id).parent;U.arrayRemoveAll(parent,context.data.id);SetFieldAction.new(id,'parent',parent,'',true);}END();return true;}get_references(context){return context.data.references.map(pointer=>{return LPointerTargetable.from(pointer);});}set_references(val,context){const list=val.map(lItem=>{return Pointers.from(lItem);});const oldList=context.data.references;const diff=U.arrayDifference(oldList,list);BEGIN();SetFieldAction.new(context.data,'references',list,\"\",true);for(let id of diff.added){SetFieldAction.new(id,'father',context.data.id,'',true);SetFieldAction.new(id,'parent',context.data.id,'+=',true);}for(let id of diff.removed){SetFieldAction.new(id,'father',undefined,'',true);const parent=DPointerTargetable.from(id).parent;U.arrayRemoveAll(parent,context.data.id);SetFieldAction.new(id,'parent',parent,'',true);}END();return true;}get_attributes(context){return context.data.attributes.map(pointer=>{return LPointerTargetable.from(pointer);});}set_attributes(val,context){const list=val.map(lItem=>{return Pointers.from(lItem);});const oldList=context.data.attributes;const diff=U.arrayDifference(oldList,list);BEGIN();SetFieldAction.new(context.data,'attributes',list,\"\",true);for(let id of diff.added){SetFieldAction.new(id,'father',context.data.id,'',true);SetFieldAction.new(id,'parent',context.data.id,'+=',true);}for(let id of diff.removed){SetFieldAction.new(id,'father',undefined,'',true);const parent=DPointerTargetable.from(id).parent;U.arrayRemoveAll(parent,context.data.id);SetFieldAction.new(id,'parent',parent,'',true);}END();return true;}get_referencedBy(c){let keystr;if(c.data.className==='DClass'){keystr='.type';}// @ts-ignore\nelse if(c.data.className==='DObject'){return LObject.singleton.get_referencedBy(c);}// else if (c.data.className === 'DObject'){ keystr = '.values'; } nope, model also have .values+=\n// and lvalues might be under either \".values\" | \".values+=\" | \".values.0\" (in rightbar)\nelse return[];let ptrs=c.data.pointedBy.map(e=>{/*\r\n            if (c.data.className === 'DObject'){\r\n                let parent = this.get_father(c);\r\n                return parent.className === 'DValue' ? [parent] : [];\r\n            }*/let index=e.source.lastIndexOf(keystr);if(index!==e.source.length-keystr.length)return null;return e.source.substring('idlookup.'.length,index);}).filter(e=>!!e);return LPointerTargetable.fromArr(ptrs);// return context.data.referencedBy.map((pointer) => LPointerTargetable.from(pointer) );\n}set_referencedBy(val,context){return this.cannotSet('referencedBy','is automatically updated through pointedBy');/*if (!val) val = [];\r\n        else if (!Array.isArray(val)) val = [val];\r\n        const ptrs = [...new Set(val.map((val) => { return val && Pointers.from(val) })).filter(e=>!!e)];\r\n        SetFieldAction.new(context.data, 'referencedBy', ptrs, \"\", true);\r\n        return true;*/}get_extends(context){return context.data.extends.map(pointer=>{return LPointerTargetable.from(pointer);});}set_extends(val,c){if(!val)val=[];else if(!Array.isArray(val))val=[val];let ptrs=[...new Set(val.map(val=>{return val&&Pointers.from(val);}).filter(e=>!!e))];let diff=Uarr.arrayDifference(c.data.extends,ptrs);let invalid=[];let invalidPtrs=[];for(let ptr of diff.added){let reason={ptr};if(this.get_canExtend(c)(ptr,reason))continue;invalid.push(reason);invalidPtrs.push(ptr);}if(invalid.length){Log.ww('tried to add invalid extends, they were ignored:',invalid);ptrs=ptrs.filter(e=>!invalid.includes(e));}if(diff.removed.length===0&&diff.added.length===invalid.length)return true;SetFieldAction.new(c.data,'extends',ptrs,\"\",true);return true;}add_extends(val){this.cannotCall('add_extends');}get_add_extends(val,context){return val=>this.impl_add_extends(val,context);}impl_add_extends(val,context){if(!val)val=[];else if(!Array.isArray(val))val=[val];if(!val.length)return;let ptrs=[...new Set(val.map(val=>{return val&&Pointers.from(val);}).filter(e=>!!e&&!context.data.extends.includes(e)))];ptrs=ptrs.filter(ptr=>this.get_canExtend(context)(ptr,{}));if(!ptrs.length)return;// todo: extendedby? or make it derived from pointedby\nSetFieldAction.new(context.data,'extends',[...context.data.extends,...ptrs],'',true);}remove_extends(val,context){if(!val)val=[];else if(!Array.isArray(val))val=[val];if(!val.length)return;let finalVal;if(typeof val[0]===\"number\"){finalVal=context.data.extends.filter((elem,index,arr)=>{return val.includes(index);});}else{finalVal=[...context.data.extends];let ptrs=Pointers.from(val);for(let v of ptrs){U.arrayRemoveAll(finalVal,v);}}SetFieldAction.new(context.data,'extends',finalVal,'',true);}get_extendedBy(context){return context.data.extendedBy.map(pointer=>{return LPointerTargetable.from(pointer);});}set_extendedBy(val,context){if(!val)val=[];else if(!Array.isArray(val))val=[val];const ptrs=[...new Set(val.map(val=>{return val&&Pointers.from(val);}).filter(e=>!!e))];SetFieldAction.new(context.data,'extendedBy',ptrs,\"\",true);return true;}get_implements(context){return context.data.implements;}set_implements(val,context){SetFieldAction.new(context.data,'implements',val,\"\",true);return true;}get_implementedBy(context){return context.data.implementedBy;}set_implementedBy(val,context){SetFieldAction.new(context.data,'implementedBy',val,\"\",true);return true;}canExtend(superclass){let output=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{reason:'',allTargetSuperClasses:[]};this.cannotCall(\"canExtend\");return false;}get_canExtend(context){var _this4=this;return function(superclass){let output=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{reason:'',allTargetSuperClasses:[]};return _this4._canExtend(context,superclass,output);};}isExtending(superclass){let directly=arguments.length>1&&arguments[1]!==undefined?arguments[1]:false;return this.cannotCall(\"isExtending\");}isSubclassOf(superclass){let directly=arguments.length>1&&arguments[1]!==undefined?arguments[1]:false;return this.cannotCall(\"isSubclassOf\");}get_isSubclassOf(c){let plusThis=arguments.length>1&&arguments[1]!==undefined?arguments[1]:true;return this.get_isExtending(c,plusThis);}get_isExtending(c){var _this5=this;let plusThis=arguments.length>1&&arguments[1]!==undefined?arguments[1]:true;return function(superclass){let directly=arguments.length>1&&arguments[1]!==undefined?arguments[1]:false;let ptr=Pointers.from(superclass);if(directly)return c.data.extends.includes(ptr);return _this5.get_superclasses(c,plusThis).map(classe=>classe.id).includes(ptr);};}get_superclasses(context){let plusThis=arguments.length>1&&arguments[1]!==undefined?arguments[1]:false;let i;const thiss=context.proxyObject;const visited={};let queue=thiss.extends;if(plusThis)queue=[thiss,...queue];const ret=[];for(i=0;i<queue.length;i++){let elem=queue[i];if(visited[elem.id])continue;visited[elem.id]=elem;ret.push(elem);queue.push(...elem.extends);}return ret;}get_allSubClasses(context){var _context$data$extende;let plusThis=arguments.length>1&&arguments[1]!==undefined?arguments[1]:false;let state=arguments.length>2?arguments[2]:undefined;const thiss=context.proxyObject;let extendedBy=thiss.extendedBy;let ebyIDS=extendedBy.map(e=>e.id);/* old version, remade longer but more efficient\r\n        const set: Set<LClass> = plusThis ? new Set<LClass>([thiss.id, ...ebyIDS]) : new Set(ebyIDS);\r\n        for (let i = 0; i < extendedBy.length; i++) { U.SetMerge(true, set, extendedBy[i].allSubClasses.map(e=>e.id)); }*/let parsedSubclasses={};parsedSubclasses[context.data.id]=context.data;let stack=[context.data];if(!state&&!((_context$data$extende=context.data.extendedBy)===null||_context$data$extende===void 0?void 0:_context$data$extende.length))state=store.getState();while(stack.length){let newstack=[];for(let d of stack){for(let sid of d.extendedBy){if(!sid||parsedSubclasses[sid])continue;let d=DClass.from(sid,state);if(!d)continue;parsedSubclasses[sid]=d;newstack.push(d);}}stack=newstack;}if(!plusThis)delete parsedSubclasses[context.data.id];return Object.values(parsedSubclasses).map(d=>LPointerTargetable.fromD(d));}_canExtend(c,superclass){let output=arguments.length>2&&arguments[2]!==undefined?arguments[2]:{reason:'',allTargetSuperClasses:[]};if(!output)output={allTargetSuperClasses:[]};superclass=superclass&&LPointerTargetable.wrap(superclass);if(!superclass){output.reason='Invalid extend target: '+superclass;return false;}let sealed=superclass.sealed||[];if(sealed.length){let inSealed=false;for(let allowed of sealed)if(allowed&&allowed.isSubClassOf(c.proxyObject)){inSealed=true;break;}if(!inSealed){output.reason='sealed on attempted superclass';return false;}}if(superclass.final){output.reason='final on attempted superclass';return false;}const thiss=c.proxyObject;if(superclass.id===thiss.id){output.reason='Classes cannot extend themselves.';return false;}// todo: se diversi proxy dello stesso oggetto sono considerati diversi questo fallisce, in tal caso fai thiss.extends.map( l => l.id).indexof(superclass.id)\nif(thiss.extends.map(sc=>sc.id).indexOf(superclass.id)>=0){output.reason='Target class is already directly extended.';return false;}output.allTargetSuperClasses=superclass.superclasses;if(thiss.superclasses.map(sc=>sc.id).indexOf(superclass.id)>=0){output.reason='Target class is already indirectly extended.';return false;}if(output.allTargetSuperClasses.map(sc=>sc.id).indexOf(thiss.id)>=0){output.reason='Cannot set this extend, it would cause a inheritance loop.';return false;}if(thiss.interface&&!superclass.interface){output.reason='An interface cannot extend a class.';return false;}// ora verifico se causa delle violazioni di override (attibuti omonimi string e boolean non possono overridarsi)\nlet i;let j;let children=thiss.operations;//[...thiss.getBasicOperations()];\nlet superchildren=superclass.operations;//[...superclass.getBasicOperations()];\nfor(i=0;i<children.length;i++){let op=children[i];for(j=0;j<superchildren.length;j++){let superchild=superchildren[j];if(op.name!==superchild.name)continue;if(op._canOverride(superchild)||op._canPolymorph(superchild))continue;output.reason='Marked homonymous operations cannot override nor polymorph each others.';setTimeout(()=>{op._mark(true,superchild,'override');//  mark op && superchildren\nsetTimeout(()=>{op._mark(false,superchild,'override');},3000);// unmark\n},1);return false;}}return true;}_isExtending(context,superclass){let orEqual=arguments.length>2&&arguments[2]!==undefined?arguments[2]:true;if(!superclass)return false;return this.get_superclasses(context,orEqual).includes(superclass);}add_Extends(context,superclass){let force=arguments.length>2&&arguments[2]!==undefined?arguments[2]:false;let out={reason:'',allTargetSuperClasses:[]};const thiss=context.proxyObject;if(!force&&!this._canExtend(context,superclass,out)){return false;}SetFieldAction.new(thiss.__raw,'extends',[superclass.id],'+=',true);SetFieldAction.new(superclass.__raw,'extendedBy',[thiss.id],'+=',true);// const extendChildren: LClass[] =  [thiss, ...thiss.superclasses];\n// console.log('calculateViolationsExtend children:'  + extendChildren, this);\n// for (let extChild of extendChildren) { extChild._checkViolations(false); } // after instances have their meta-class changed, they might need to change shape or values.\nreturn true;}unsetExtends(superclass){return this.cannotCall('unsetExtends');}get_unsetExtends(c,superclass){return superclass=>{superclass=LPointerTargetable.wrap(superclass);if(!superclass)return;console.log('UnsetExtend:',c,superclass);// todo: when Object is loaded in m3, set him there for easy access.\n//  if (superclass.id === LClass.genericObjectid) { Log.w(true, 'Cannot un-extend \"Object\"'); return; }\nconst thiss=c.proxyObject;let superclassid=superclass.id;let extendsarr=c.data.extends;let index=extendsarr.indexOf(superclassid);if(index<0)return;// let extendedby = superclass.__raw.extendedBy;\n// @ts-ignore\nSetFieldAction.new(thiss,'extends',superclass.id,'-=',true);// @ts-ignore\nSetFieldAction.new(superclass,'extendedBy',thiss.id,'-=',true);// todo: update instances for (i = 0; i < thiss.instances.length; i++) { thiss.instances[i].unsetExtends(superclass); }\n// todo: check violations\n// const extendedby: LClass[] = [thiss, ...thiss.allSubClasses];\n// for (i = 0; i < extendedby.length; i++) { extendedby[i].checkViolations(true); }\n};}instance(){return this.cannotCall('instance');}/*private get_instance_old(context: Context): () => DObject {\r\n        return () => {\r\n            const dClass: DClass = context.data;\r\n            const lClass: LClass = LClass.from(dClass);\r\n            const dObject = DObject.new(lClass.name.toLowerCase());\r\n            CreateElementAction.new(dObject);\r\n            BEGIN()\r\n            SetFieldAction.new(dObject, 'instanceof', dClass.id, '', true);\r\n            SetFieldAction.new(dClass, 'instances', dObject.id, '+=', true);\r\n\r\n            let father: LClass|undefined = lClass;\r\n            while(father) {\r\n                for(let dFeature of [...father.attributes, ...father.references]) {\r\n                    const dValue = DValue.new(dFeature.name); dValue.value = [U.initializeValue(dFeature.type)];\r\n                    CreateElementAction.new(dValue);\r\n\r\n                    SetFieldAction.new(dValue, 'father', dObject.id, '', true);\r\n                    SetFieldAction.new(dValue, 'instanceof', dFeature.id, '', true);\r\n                    SetFieldAction.new(dFeature, 'instances', dValue.id, '+=', true);\r\n                    SetFieldAction.new(dObject, 'features', dValue.id, '+=', true);\r\n\r\n                }\r\n                father = (father.extends.length > 0) ? father.extends[0] : undefined;\r\n            }\r\n            END()\r\n            return dObject;\r\n        };\r\n    }*/},_class39.subclasses=[],_class39._extends=[],_class39))||_class38)||_class38)||_class38);RuntimeAccessibleClass.set_extend(DClassifier,DClass);RuntimeAccessibleClass.set_extend(LClassifier,LClass);export let DDataType=(_dec21=RuntimeAccessible('DDataType'),_dec21(_class40=(_class41=class DDataType extends DPointerTargetable{constructor(){super(...arguments);this.id=void 0;this.instanceClassName=void 0;this.parent=[];this.father=void 0;this.annotations=[];this.name=void 0;this.defaultValue=void 0;this.serializable=true;}// extends DClassifier\n// static singleton: LDataType;\n// static logic: typeof LDataType;\n// static structure: typeof DDataType;\n// inherit redefine\n// instanceClass: EJavaClass // ?\n// isInstance(object: EJavaObject): boolean; ?\n// getClassifierID(): number;\n// personal\n// usedBy: Pointer<DAttribute, 0, 'N', LAttribute> = [];\nstatic new(name,father){let persist=arguments.length>2&&arguments[2]!==undefined?arguments[2]:true;Log.exx(\"DDataType is abstract, cannot instantiate\");return null;// if (!name) name = this.defaultname(\"datatype_\", father);\n// return new Constructors(new DDataType('dwc'), father, persist, undefined).DPointerTargetable().DModelElement().DNamedElement(name).DClassifier().DDataType().end();\n}},_class41.subclasses=[],_class41._extends=[],_class41))||_class40);export let LDataType=(_dec22=RuntimeAccessible('LDataType'),Abstract(_class42=_dec22(_class42=(_class43=class LDataType extends LClassifier{constructor(){super(...arguments);this.__raw=void 0;this.id=void 0;this.instanceClassName=void 0;this.parent=void 0;this.father=void 0;this.annotations=void 0;this.name=void 0;this.namespace=void 0;this.defaultValue=void 0;this.isPrimitive=void 0;this.isClass=void 0;this.isEnum=void 0;this.serializable=void 0;}// extends DClassifier\n// static singleton: LDataType;\n// static logic: typeof LDataType;\n// static structure: typeof DDataType;\n// inherit redefine\n// instanceClass: EJavaClass // ?\n// isInstance(object: EJavaObject): boolean; ?\n// getClassifierID(): number;\n// personal\nget_serializable(context){return context.data.serializable;}set_serializable(val,context){SetFieldAction.new(context.data,'serializable',val);return true;}},_class43.subclasses=[],_class43._extends=[],_class43))||_class42)||_class42);RuntimeAccessibleClass.set_extend(DClassifier,DDataType);RuntimeAccessibleClass.set_extend(LClassifier,LDataType);export let DStructuralFeature=(_dec23=RuntimeAccessible('DStructuralFeature'),_dec23(_class44=(_class45=class DStructuralFeature extends DPointerTargetable{constructor(){super(...arguments);this.id=void 0;this.annotations=[];this.parent=[];this.father=void 0;this.name=void 0;this.type=void 0;this.ordered=true;this.unique=true;this.lowerBound=0;this.upperBound=1;this.many=void 0;this.required=void 0;this.instances=[];this.changeable=true;this.volatile=true;this.transient=false;this.unsettable=false;this.allowCrossReference=void 0;this.derived=void 0;this.derived_read=void 0;this.derived_write=void 0;this.__info_of__derived={type:'string',txt:'A ECore flag to signal the values of this feature depend on other features.\\n'+'To make it usable at runtime in jjodel check derived_read and derived_write.'};this.__info_of__derived_read={type:'string',txt:'A function in string format with 2 or less attributes: (data, oldValue).\\n'+'- data is the LValue hosting this derived feature\\n'+'- originalValues are the current **non-derived** values actually memorized in the data.values\\n'+'The mandatory return value of this function will be returned when attempted to read data.values.'};this.__info_of__derived_write={type:'string',txt:'A function in string format with 3 or less attributes: (value, data, oldValue).\\n'+'- value is the value currently attempted to be set, which triggered the function call.\\n'+'- data is the LValue hosting this derived feature\\n'+'- originalValues are the current **non-derived** values actually memorized in the data.values\\n'+'The optional return value of this function will be stored inside data, allowing for hybrid dependency-persistant features'+'\\n or for a feature \"depending on itself\". like uppercasing his values before setting them.'};this.defaultValue=void 0;}// DTypedElement\n// static singleton: LStructuralFeature;\n// static logic: typeof LStructuralFeature;\n// static structure: typeof DStructuralFeature;\n// inherit redefine\n// personal\n// if the feature can be \"unsetted\" aka undefined/deleted ?\n/*protected */ /*protected */ /*protected*/ /*protected*/ /*protected*/static new(name,type,father){let persist=arguments.length>3&&arguments[3]!==undefined?arguments[3]:true;Log.exx(\"DStructuralFeature is abstract, cannot instantiate\");return null;// if (!name) name = this.defaultname(\"feature \", father);\n// return new Constructors(new DStructuralFeature('dwc'), father, persist, undefined).DPointerTargetable().DModelElement().DNamedElement(name).DTypedElement(type).DStructuralFeature().end();\n}// getFeatureID(): number;\n// getContainerClass(): EJavaClass\n},_class45.subclasses=[],_class45._extends=[],_class45))||_class44);export let LStructuralFeature=(_dec24=RuntimeAccessible('LStructuralFeature'),Abstract(_class46=_dec24(_class46=(_class47=class LStructuralFeature extends LTypedElement{constructor(){super(...arguments);this.__raw=void 0;this.id=void 0;this.annotations=void 0;this.parent=void 0;this.father=void 0;this.name=void 0;this.namespace=void 0;this.type=void 0;this.ordered=true;this.unique=true;this.lowerBound=0;this.upperBound=1;this.many=void 0;this.required=void 0;this.derived=void 0;this.derived_read=void 0;this.derived_write=void 0;this.__info_of__derived={type:'string',txt:'A ECore flag to signal the values of this feature depend on other features.\\n'+'To make it usable at runtime in jjodel check derived_read and derived_write.'};this.__info_of__derived_read={type:'string',txt:'A function in string format with 2 or less attributes: (data, oldValue).\\n'+'- data is the LValue hosting this derived feature\\n'+'- originalValues are the current **non-derived** values actually memorized in the data.values\\n'+'The mandatory return value of this function will be returned when attempted to read data.values.'};this.__info_of__derived_write={type:'string',txt:'A function in string format with 3 or less attributes: (value, data, oldValue).\\n'+'- value is the value currently attempted to be set, which triggered the function call.\\n'+'- data is the LValue hosting this derived feature\\n'+'- originalValues are the current **non-derived** values actually memorized in the data.values\\n'+'The optional return value of this function will be stored inside data, allowing for hybrid dependency-persistant features'+'\\n or for a feature \"depending on itself\". like uppercasing his values before setting them.'};this.instances=void 0;this.changeable=void 0;this.volatile=void 0;this.transient=void 0;this.unsettable=void 0;this.defaultValue=void 0;this.allowCrossReference=void 0;this.validTargetsJSX=void 0;this.validTargetOptions=void 0;this.validTargets=void 0;}// DTypedElement\n// static singleton: LStructuralFeature;\n// static logic: typeof LStructuralFeature;\n// static structure: typeof DStructuralFeature;\n// inherit redefine\n/*protected */ /*protected */ /*protected*/ /*protected*/ /*protected*/ // personal\n// defaultValueLiteral!: string;\n// getFeatureID(): number;\n// getContainerClass(): EJavaClass\nget_crossReference(c){return this.get_allowCrossReference(c);}get_isCrossReference(c){return this.get_allowCrossReference(c);}set_crossReference(v,c){return this.set_allowCrossReference(v,c);}set_isCrossReference(v,c){return this.set_allowCrossReference(v,c);}get_allowCrossReference(c){return c.data.allowCrossReference;}set_allowCrossReference(v,c){v=!!v;if(v!==c.data.allowCrossReference)SetFieldAction.new(c.data,'allowCrossReference',v);return true;}get_validTargetsJSX(c){let opts=[];this.get_validTargets(c,opts);return UX.options(opts);}get_validTargetOptions(c){let opts=[];this.get_validTargets(c,opts);return opts;}get_validTargets(c,out){let addClasses=false;let addModels=false;let addEnums=false;let addPrimitives=false;let addReturnTypes=false;let isCrossRef=this.get_isCrossReference(c);let d=c.data;switch(d.className){case DModel.cname:addModels=true;break;case DReference.cname:addClasses=true;break;case DAttribute.cname:addPrimitives=addEnums=true;break;case DParameter.cname:addClasses=addPrimitives=addEnums=true;break;case DOperation.cname:addClasses=addPrimitives=addEnums=addReturnTypes=true;break;}let m2=this.get_model(c);let map=object=>{let fname=object.fullname;return{value:object.id,label:isCrossRef?fname:object.name,title:object.fullname};};let map2=object=>{let name=object.name;return{value:object.id,label:name,title:name};};let sort=(a,b)=>a.label>b.label?+1:-1;let validClasses=[];let validEnums=[];let validPrimitives=[];let validModels=[];let state=null;if(addModels){if(!state)state=store.getState();validModels=LPointerTargetable.fromPointer(state.m2models);if(out)out.push({label:'Models',options:validModels.map(map2).sort(sort)});}if(addPrimitives){if(!state)state=store.getState();validPrimitives=LPointerTargetable.fromPointer(state.primitiveTypes);}if(addReturnTypes){if(!state)state=store.getState();U.arrayMergeInPlace(validPrimitives,LPointerTargetable.fromPointer(state.returnTypes));}if(out&&validPrimitives.length)out.push({label:'Primitives',options:validPrimitives.map(map2).sort(sort)});if(addClasses){let m=this.get_model(c);let pkgs=isCrossRef?m.allCrossSubPackages:m.allSubPackages;if(out)for(let pkg of pkgs){let classes=pkg.classes;if(classes.length===0)continue;out.push({label:'Classes ('+pkg.fullname+')',options:classes.map(map2).sort(sort)});U.arrayMergeInPlace(validClasses,classes);}else validClasses=isCrossRef?m2.crossClasses:m2.classes;}if(addEnums){let m=this.get_model(c);let pkgs=isCrossRef?m.allCrossSubPackages:m.allSubPackages;if(out)for(let pkg of pkgs){let enums=pkg.enumerators;if(enums.length===0)continue;out.push({label:'Enumerators ('+pkg.fullname+')',options:enums.map(map2).sort(sort)});U.arrayMergeInPlace(validEnums,enums);}else validEnums=isCrossRef?m2.crossEnumerators:m2.enumerators;//if (out) out.push({label: 'Enumerators', options: validEnums.map(map).sort(sort)});\n}return U.arrayMergeInPlace(validClasses,validPrimitives,validEnums,validModels);}get_instances(context){return context.data.instances.map(pointer=>{return LPointerTargetable.from(pointer);});}set_instances(val,context){const list=val.map(lItem=>{return Pointers.from(lItem);});SetFieldAction.new(context.data,'instances',list,\"\",true);return true;}get_changeable(context){return context.data.changeable;}set_changeable(val,context){SetFieldAction.new(context.data,'changeable',val);return true;}get_volatile(context){return context.data.volatile;}set_volatile(val,context){SetFieldAction.new(context.data,'volatile',val);return true;}get_transient(context){return context.data.transient;}set_transient(val,context){SetFieldAction.new(context.data,'transient',val);return true;}get_unsettable(context){return context.data.unsettable;}set_unsettable(val,context){SetFieldAction.new(context.data,'unsettable',val);return true;}get_derived(context){return context.data.derived;}set_derived(val,context){SetFieldAction.new(context.data,'derived',!!val);return true;}/*\r\n        protected get_defaultValueLiteral(context: Context): this[\"defaultValueLiteral\"] { return context.data.defaultValueLiteral; }\r\n        protected set_defaultValueLiteral(val: this[\"defaultValueLiteral\"], context: Context): boolean {\r\n            SetFieldAction.new(context.data, 'defaultValueLiteral', val, \"\", false);\r\n            return true;\r\n        }*/},_class47.subclasses=[],_class47._extends=[],_class47))||_class46)||_class46);RuntimeAccessibleClass.set_extend(DTypedElement,DStructuralFeature);RuntimeAccessibleClass.set_extend(LTypedElement,LStructuralFeature);export let DReference=(_dec25=RuntimeAccessible('DReference'),Instantiable(_class48=Leaf(_class48=_dec25(_class48=(_class49=class DReference extends DPointerTargetable{constructor(){super(...arguments);this.id=void 0;this.annotations=[];this.name=void 0;this.type=void 0;this.ordered=true;this.unique=true;this.lowerBound=0;this.upperBound=1;this.many=void 0;this.required=void 0;this.changeable=true;this.volatile=true;this.transient=false;this.unsettable=false;this.defaultValueLiteral='';this.parent=[];this.father=void 0;this.instances=[];this.defaultValue=void 0;this.allowCrossReference=void 0;this.derived=void 0;this.derived_read=void 0;this.derived_write=void 0;this.__info_of__derived={type:'string',txt:'A ECore flag to signal the values of this feature depend on other features.\\n'+'To make it usable at runtime in jjodel check derived_read and derived_write.'};this.__info_of__derived_read={type:'string',txt:'A function in string format with 2 or less attributes: (data, oldValue).\\n'+'- data is the LValue hosting this derived feature\\n'+'- originalValues are the current **non-derived** values actually memorized in the data.values\\n'+'The mandatory return value of this function will be returned when attempted to read data.values.'};this.__info_of__derived_write={type:'string',txt:'A function in string format with 3 or less attributes: (value, data, oldValue).\\n'+'- value is the value currently attempted to be set, which triggered the function call.\\n'+'- data is the LValue hosting this derived feature\\n'+'- originalValues are the current **non-derived** values actually memorized in the data.values\\n'+'The optional return value of this function will be stored inside data, allowing for hybrid dependency-persistant features'+'\\n or for a feature \"depending on itself\". like uppercasing his values before setting them.'};this.rootable=void 0;this.composition=false;this.aggregation=false;this.container=false;this.__info_of__container={type:'boolean',txt:\"A reference is a container if it has an opposite that is a containment.\"};this.opposite=void 0;this.target=[];this.edges=[];}// DStructuralFeature\n// static singleton: LReference;\n// static logic: typeof LReference;\n// static structure: typeof DReference;\n// inherit redefine\n/*protected */ /*protected */ /*protected*/ /*protected*/ /*protected*/ // personal\n// exist in uml but not in ecore\nstatic new(name,type,father){let persist=arguments.length>3&&arguments[3]!==undefined?arguments[3]:true;if(!type)type=father;// default type is self-reference\nif(!name)name=this.defaultname(\"ref_\",father);return new Constructors(new DReference('dwc'),father,persist,undefined).DPointerTargetable().DModelElement().DNamedElement(name).DTypedElement(type).DStructuralFeature().DReference().end();}static new2(setter,father,type,name){if(!name)name=this.defaultname(name||\"ref_\",father);return new Constructors(new DReference('dwc'),father,true,undefined).DPointerTargetable().DModelElement().DNamedElement(name).DTypedElement(type).DStructuralFeature().DReference().end(d=>{Object.assign(d,setter);});}static new3(a,callback){let persist=arguments.length>2&&arguments[2]!==undefined?arguments[2]:true;if(!a.name)a.name=this.defaultname(\"ref_\",a.father);return new Constructors(new DReference('dwc'),a.father,persist,undefined,a.id).DPointerTargetable().DModelElement().DPointerTargetable().DModelElement().DNamedElement(a.name).DTypedElement(a.type).DStructuralFeature().DReference().end(callback);}},_class49.subclasses=[],_class49._extends=[],_class49))||_class48)||_class48)||_class48);export let LReference=(_dec26=RuntimeAccessible('LReference'),Instantiable(_class50=Leaf(_class50=_dec26(_class50=(_class51=class LReference extends LStructuralFeature{constructor(){super(...arguments);this.__raw=void 0;this.id=void 0;this.annotations=void 0;this.name=void 0;this.namespace=void 0;this.type=void 0;this.ordered=void 0;this.unique=void 0;this.lowerBound=void 0;this.upperBound=void 0;this.many=void 0;this.required=void 0;this.changeable=void 0;this.volatile=void 0;this.transient=void 0;this.unsettable=void 0;this.allowCrossReference=void 0;this.derived=void 0;this.derived_read=void 0;this.derived_write=void 0;this.__info_of__derived={type:'string',txt:'A ECore flag to signal the values of this feature depend on other features.\\n'+'To make it usable at runtime in jjodel check derived_read and derived_write.'};this.__info_of__derived_read={type:'string',txt:'A function in string format with 2 or less attributes: (data, oldValue).\\n'+'- data is the LValue hosting this derived feature\\n'+'- originalValues are the current **non-derived** values actually memorized in the data.values\\n'+'The mandatory return value of this function will be returned when attempted to read data.values.'};this.__info_of__derived_write={type:'string',txt:'A function in string format with 3 or less attributes: (value, data, oldValue).\\n'+'- value is the value currently attempted to be set, which triggered the function call.\\n'+'- data is the LValue hosting this derived feature\\n'+'- originalValues are the current **non-derived** values actually memorized in the data.values\\n'+'The optional return value of this function will be stored inside data, allowing for hybrid dependency-persistant features'+'\\n or for a feature \"depending on itself\". like uppercasing his values before setting them.'};this.defaultValueLiteral=void 0;this.parent=void 0;this.father=void 0;this.instances=void 0;this.defaultValue=void 0;this.composition=void 0;this.aggregation=void 0;this.containment=void 0;this.container=void 0;this.rootable=void 0;this.__info_of__rootable={type:\"boolean | undefined\",txt:\"if missing, only classes not contained, not abstract and not interface can be a model root. if present this dictates it.\"};this.__info_of__composition={type:\"boolean\",txt:\"Defines a \\\"part of\\\" relationship where the target cannot exist without the source. Building -> Room \\\"A Room cannot exist without a Building\\\"\"};this.__info_of__aggregation={type:\"boolean\",txt:\"Defines a \\\"part of\\\" relationship where the target can exist without the source. Building -> Student \\\"A Student can exist outside a Building\\\"\"};this.opposite=void 0;this.edges=void 0;}// static singleton: LReference;\n// static logic: typeof LReference;\n// static structure: typeof DReference;\n// inherit redefine\n/*protected */ /*protected */ /*protected */ /*protected */ /*protected */ // personal\n// aggregation || containment\n// target!: LClass[]; replaced by type\ngenerateEcoreJson_impl(context){let loopDetectionObj=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};loopDetectionObj[context.data.id]=context.data;const model={};const d=context.data;const l=context.proxyObject;model[ECoreReference.xsitype]='ecore:EReference';model[ECoreReference.eType]=l.type.typeEcoreString;model[ECoreReference.namee]=d.name;if(d.lowerBound!=null&&!isNaN(+d.lowerBound)){model[ECoreReference.lowerbound]=+d.lowerBound;}if(d.upperBound!=null&&!isNaN(+d.upperBound)){model[ECoreReference.upperbound]=+d.upperBound;}let cont=d.aggregation||d.composition;if(cont!=null){model[ECoreReference.containment]=cont;}if(d.container!=null){model[ECoreReference.container]=d.container;}return model;}duplicate(){let deep=arguments.length>0&&arguments[0]!==undefined?arguments[0]:true;return this.cannotCall((this.constructor.cname||this.constructor.name)+\"duplicate()\");}get_duplicate(context){return function(){let deep=arguments.length>0&&arguments[0]!==undefined?arguments[0]:false;BEGIN();let le=context.proxyObject.father.addReference(context.data.name,context.data.type);let de=le.__raw;de.many=context.data.many;de.lowerBound=context.data.lowerBound;de.upperBound=context.data.upperBound;de.ordered=context.data.ordered;de.required=context.data.required;de.unique=context.data.unique;de.changeable=context.data.changeable;de.container=context.data.container;de.composition=context.data.composition;de.aggregation=context.data.aggregation;de.defaultValueLiteral=context.data.defaultValueLiteral;de.derived=context.data.derived;de.transient=context.data.transient;de.unsettable=context.data.unsettable;de.volatile=context.data.unsettable;let we=le;we.opposite=context.data.opposite||undefined;we.defaultValue=context.data.defaultValue;we.type=context.data.type;we.annotations=deep?context.proxyObject.annotations.map(lchild=>lchild.duplicate(deep).id):context.data.annotations;// we.target = deep ? context.proxyObject.target.map(lchild => lchild.duplicate(deep).id) : context.data.target;\nEND();return le;};}set_type(val,context){super.set_type(val,context);return true;}addClass(name,isInterface,isAbstract,isPrimitive,isPartial,partialDefaultName){return this.cannotCall(\"LReference.addClass\");}get_addClass(context){return(name,isInterface,isAbstract,isPrimitive,isPartial,partialDefaultName)=>{BEGIN();let dclass=DClass.new(name,isInterface,isAbstract,isPrimitive,isPartial,partialDefaultName,context.proxyObject.package.id,true);// SetFieldAction.new(context.data.id, \"type\", dclass.id);\nthis.set_type(dclass.id,context);END();return LPointerTargetable.fromD(dclass);};}get_containment(context){return context.data.composition||context.data.aggregation;}set_containment(val,c){let mainkey=arguments.length>2&&arguments[2]!==undefined?arguments[2]:'composition';let altkey=arguments.length>3&&arguments[3]!==undefined?arguments[3]:'aggregation';// return this.cannotSet('containment', 'set aggregation or composition instead');\nval=!!val;if(c.data[mainkey]===val)return true;TRANSACTION(()=>{// set composition and unset aggregation or viceversa\nSetFieldAction.new(c.data,mainkey,val);if(val&&c.data[altkey])SetFieldAction.new(c.data,altkey,!val);let containedObjects={};let removedValues=[];let parentChanges=[];for(let lval of this.get_instances(c)){// todo: in set_values crop the arr to max upperbound\nlet dval=lval.__raw;let values=dval.values;let lmodel=lval.model;let dmodel=lmodel.__raw;for(let ptr of values){if(!Pointers.isPointer(ptr))continue;if(containedObjects[ptr]){// Log.ee('Cannot activate ' + mainkey+ ' on this reference because some objects are referenced twice in the model')\n// todo: ask for confirmation if want to abort or delete those values.\nif(val){SetFieldAction.new(dval,'values',ptr,'-=',true);// if is containment=true prevent the targets from being contained twice}\nremovedValues.push(ptr);continue;}}// update parent\nlet pointedobj=containedObjects[ptr]=LPointerTargetable.fromPointer(ptr);let newid=val?dval.id:dmodel.id;let oldparent=pointedobj.father;if((oldparent===null||oldparent===void 0?void 0:oldparent.id)===newid)continue;pointedobj.father=newid;parentChanges.push(pointedobj);}}if(removedValues.length||parentChanges.length){Log.ww([removedValues.length?removedValues.length+' values were removed':undefined,parentChanges.length?parentChanges.length+' parents were changed':undefined].filter(e=>!!e).join(' and ')+' as result.',//\\n If you want to check chem, write \"containmentSideEffects[\\''+c.data.id+'\\']\" in console.',\n{removedValues,parentChanges});}//if (!windoww.containmentSideEffects) windoww.containmentSideEffects = {};\n//windoww.containmentSideEffects[c.data.id] = {removedValues, parentChanges};\n});return true;}get_aggregation(context){return context.data.aggregation;}get_composition(context){return context.data.composition;}/*\r\n    protected get_container(context: Context): this[\"container\"] { return context.data.container; }\r\n    protected set_container(val: this[\"container\"], context: Context): boolean { return SetFieldAction.new(context.data, 'container', val); }*/set_aggregation(val,c){return this.set_containment(val,c,'aggregation','composition');}set_composition(val,c){return this.set_containment(val,c,'composition','aggregation');}get_opposite(context){return context.data.opposite&&LPointerTargetable.from(context.data.opposite);}set_opposite(val,context){SetFieldAction.new(context.data,'opposite',Pointers.from(val),\"\",true);return true;}/*\r\n        /// todo: why this exist?  why not type?\r\n        protected get_target(context: Context): this[\"target\"] { return context.data.target.map(pointer => LPointerTargetable.from(pointer)); }\r\n        protected set_target(val: PackArr<this[\"target\"]>, context: Context): boolean {\r\n            const list = val.map((lItem) => { return Pointers.from(lItem) });\r\n            SetFieldAction.new(context.data, 'target', list, \"\", true);\r\n            return true;\r\n        }*/get_defaultValue(context){return LPointerTargetable.fromPointer(context.data.defaultValue);}set_defaultValue(val,context){// @ts-ignore\nif(!val)val=[];else if(!Array.isArray(val))val=[val];let ptrs=Pointers.from(val);SetFieldAction.new(context.data,'defaultValue',ptrs,'',false);return true;}get_edges(context){return context.data.edges.map(pointer=>{return LPointerTargetable.from(pointer);});}set_edges(val,context){const list=val.map(lItem=>{return Pointers.from(lItem);});SetFieldAction.new(context.data,'edges',list,\"\",true);return true;}},_class51.subclasses=[],_class51._extends=[],_class51))||_class50)||_class50)||_class50);RuntimeAccessibleClass.set_extend(DStructuralFeature,DReference);RuntimeAccessibleClass.set_extend(LStructuralFeature,LReference);function has_opposite(oppositename){// return (c:Constructor, key:string, ):any =>{}\n}function obsolete_attribute(){return undefined;// function(c:Constructor, key:string,): any {}\n}export let DAttribute=(_dec27=RuntimeAccessible('DAttribute'),Leaf(_class52=_dec27(_class52=(_class53=class DAttribute extends DPointerTargetable{constructor(){super(...arguments);this.id=void 0;this.annotations=[];this.name=void 0;this.type=void 0;this.ordered=true;this.unique=true;this.lowerBound=0;this.upperBound=1;this.many=void 0;this.required=void 0;this.changeable=true;this.volatile=true;this.transient=false;this.unsettable=false;this.defaultValueLiteral='';this.allowCrossReference=void 0;this.derived=void 0;this.derived_read=void 0;this.derived_write=void 0;this.__info_of__derived={type:'string',txt:'A ECore flag to signal the values of this feature depend on other features.\\n'+'To make it usable at runtime in jjodel check derived_read and derived_write.'};this.__info_of__derived_read={type:'string',txt:'A function in string format with 2 or less attributes: (data, oldValue).\\n'+'- data is the LValue hosting this derived feature\\n'+'- originalValues are the current **non-derived** values actually memorized in the data.values\\n'+'The mandatory return value of this function will be returned when attempted to read data.values.'};this.__info_of__derived_write={type:'string',txt:'A function in string format with 3 or less attributes: (value, data, oldValue).\\n'+'- value is the value currently attempted to be set, which triggered the function call.\\n'+'- data is the LValue hosting this derived feature\\n'+'- originalValues are the current **non-derived** values actually memorized in the data.values\\n'+'The optional return value of this function will be stored inside data, allowing for hybrid dependency-persistant features'+'\\n or for a feature \"depending on itself\". like uppercasing his values before setting them.'};this.parent=[];this.father=void 0;this.instances=[];this.defaultValue=void 0;this.isID=false;this.isIoT=false;}// DStructuralFeature\n// static singleton: LAttribute;\n// static logic: typeof LAttribute;\n// static structure: typeof DAttribute;\n// inherit redefine\n// @has_opposite(\"father\")\n/*protected */ /*protected */ /*protected*/ /*protected*/ /*protected*/ //@obsolete_attribute()\n//@has_opposite(\"attributes\")\n//@has_opposite(\"instanceof\")\n// personal\n// ? exist in ecore as \"iD\" ?\nstatic new(name,type,father){let persist=arguments.length>3&&arguments[3]!==undefined?arguments[3]:true;if(!name)name=this.defaultname(\"attr_\",father);if(!type)type=LPointerTargetable.from(Selectors.getFirstPrimitiveTypes()).id;// default type as string\nreturn new Constructors(new DAttribute('dwc'),father,persist,undefined).DPointerTargetable().DModelElement().DNamedElement(name).DTypedElement(type).DStructuralFeature().DAttribute().end();}static new2(setter,father,type,name){if(!name)name=this.defaultname(name||\"ref_\",father);return new Constructors(new DAttribute('dwc'),father,true,undefined).DPointerTargetable().DModelElement().DNamedElement(name).DTypedElement(type).DStructuralFeature().DAttribute().end(d=>{Object.assign(d,setter);});}static new3(a,callback){let persist=arguments.length>2&&arguments[2]!==undefined?arguments[2]:true;if(!a.name)a.name=this.defaultname(\"attr_\",a.father);return new Constructors(new DAttribute('dwc'),a.father,persist,undefined,a.id).DPointerTargetable().DModelElement().DNamedElement(a.name).DTypedElement(a.type).DStructuralFeature().DAttribute().end(callback);}},_class53.subclasses=[],_class53._extends=[],_class53))||_class52)||_class52);export let LAttribute=(_dec28=RuntimeAccessible('LAttribute'),Leaf(_class54=Instantiable(_class54=_dec28(_class54=(_class55=class LAttribute extends LStructuralFeature{constructor(){super(...arguments);this.__raw=void 0;this.id=void 0;this.annotations=void 0;this.name=void 0;this.namespace=void 0;this.type=void 0;this.ordered=void 0;this.unique=void 0;this.lowerBound=void 0;this.upperBound=void 0;this.many=void 0;this.required=void 0;this.changeable=void 0;this.volatile=void 0;this.transient=void 0;this.unsettable=void 0;this.defaultValue=void 0;this.parent=void 0;this.father=void 0;this.instances=void 0;this.isID=false;this.isIoT=false;this.allowCrossReference=void 0;}// DStructuralFeature\n// static singleton: LAttribute;\n// static logic: typeof LAttribute;\n// static structure: typeof DAttribute;\n// inherit redefine\n// defaultValueLiteral!: string;\n// personal\n// ? exist in ecore as \"iD\" ?\ngenerateEcoreJson_impl(context){let loopDetectionObj=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};loopDetectionObj[context.data.id]=context.data;const model={};const d=context.data;const l=context.proxyObject;EcoreParser.write(model,ECoreAttribute.xsitype,'ecore:EAttribute');EcoreParser.write(model,ECoreAttribute.eType,l.type.typeEcoreString);EcoreParser.write(model,ECoreAttribute.namee,d.name);EcoreParser.write(model,ECoreAttribute.lowerbound,''+d.lowerBound);EcoreParser.write(model,ECoreAttribute.upperbound,''+d.upperBound);return model;}duplicate(){let deep=arguments.length>0&&arguments[0]!==undefined?arguments[0]:true;return this.cannotCall((this.constructor.cname||this.constructor.name)+\"duplicate()\");}get_duplicate(context){return function(){let deep=arguments.length>0&&arguments[0]!==undefined?arguments[0]:false;BEGIN();let le=context.proxyObject.father.addAttribute(context.data.name,context.data.type);let de=le.__raw;de.many=context.data.many;de.lowerBound=context.data.lowerBound;de.upperBound=context.data.upperBound;de.ordered=context.data.ordered;de.required=context.data.required;de.unique=context.data.unique;de.changeable=context.data.changeable;de.defaultValue=context.data.defaultValue;de.defaultValueLiteral=context.data.defaultValueLiteral;de.derived=context.data.derived;de.transient=context.data.transient;de.unsettable=context.data.unsettable;de.volatile=context.data.volatile;de.isID=context.data.isID;de.isIoT=context.data.isIoT;let we=le;we.type=context.data.type;we.annotations=deep?context.proxyObject.annotations.map(lchild=>lchild.duplicate(deep).id):context.data.annotations;END();return le;};}addEnum(){return this.addEnumerator(...arguments);}get_addEnum(context){return this.get_addEnumerator(context);}addEnumerator(name,father){return this.cannotCall(\"Attribute.addEnumerator\");}get_addEnumerator(context){return(name,father)=>{var _context$proxyObject$2;return LPointerTargetable.fromD(DEnumerator.new(name,(_context$proxyObject$2=context.proxyObject.package)===null||_context$proxyObject$2===void 0?void 0:_context$proxyObject$2.id,true));};}get_isID(context){return context.data.isID;}set_isID(val,context){SetFieldAction.new(context.data,'isID',val);return true;}get_isIoT(context){return context.data.isIoT;}set_isIoT(val,context){TRANSACTION(()=>{for(const value of context.proxyObject.instances){SetFieldAction.new(value,'topic','','',false);}SetFieldAction.new(context.data,'isIoT',val);});return true;}get_defaultValue(context){return context.data.defaultValue;}set_defaultValue(val,context){// @ts-ignore\nif(!val)val=[];else if(!Array.isArray(val))val=[val];SetFieldAction.new(context.data,'defaultValue',val,'',false);return true;}},_class55.subclasses=[],_class55._extends=[],_class55))||_class54)||_class54)||_class54);RuntimeAccessibleClass.set_extend(DStructuralFeature,DAttribute);RuntimeAccessibleClass.set_extend(LStructuralFeature,LAttribute);export let DEnumLiteral=(_dec29=RuntimeAccessible('DEnumLiteral'),Leaf(_class56=_dec29(_class56=(_class57=class DEnumLiteral extends DPointerTargetable{constructor(){super(...arguments);this.id=void 0;this.parent=[];this.father=void 0;this.annotations=[];this.name=void 0;this.value=void 0;this.literal=void 0;}// DNamedElement\n// static singleton: LAttribute;\n// static logic: typeof LAttribute;\n// static structure: typeof DAttribute;\n// inherit redefine\n// personal\n// ordinal: number=1; replaced by value\nstatic new(name,value,father){let persist=arguments.length>3&&arguments[3]!==undefined?arguments[3]:true;//vv4\nif(!name)name=this.defaultname(\"literal \",father);return new Constructors(new DEnumLiteral('dwc'),father,persist,undefined).DPointerTargetable().DModelElement().DNamedElement(name).DEnumLiteral(value).end();}static new2(setter,father,name){if(!name)name=this.defaultname(\"literal \",father);return new Constructors(new DEnumLiteral('dwc'),father,true,undefined).DPointerTargetable().DModelElement().DNamedElement(name).DEnumLiteral().end(d=>{Object.assign(d,setter);});}static new3(a,callback){let persist=arguments.length>2&&arguments[2]!==undefined?arguments[2]:true;if(!a.name)a.name=this.defaultname(\"literal_\",a.father);return new Constructors(new DEnumLiteral('dwc'),a.father,persist,undefined,a.id).DPointerTargetable().DModelElement().DNamedElement(a.name).DEnumLiteral().end(callback);}},_class57.subclasses=[],_class57._extends=[],_class57))||_class56)||_class56);export let LEnumLiteral=(_dec30=RuntimeAccessible('LEnumLiteral'),Leaf(_class58=_dec30(_class58=(_class59=class LEnumLiteral extends LNamedElement{constructor(){super(...arguments);this.__raw=void 0;this.id=void 0;this.parent=void 0;this.father=void 0;this.annotations=void 0;this.name=void 0;this.namespace=void 0;this.value=void 0;this.ordinal=void 0;this.literal=void 0;}// DNamedElement\n// static singleton: LAttribute;\n// static logic: typeof LAttribute;\n// static structure: typeof DAttribute;\n// inherit redefine\n// personal\ngenerateEcoreJson_impl(context){let loopDetectionObj=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};loopDetectionObj[context.data.id]=context.data;const json={};const d=context.data;json[EcoreLiteral.value]=d.value;json[EcoreLiteral.literal]=d.literal;json[EcoreLiteral.namee]=d.name;return json;}generateEcoreJsonM1(){return this.cannotCall(\"GenerateEcoreJsonM1\");}get_generateEcoreJsonM1(context){return this.impl_generateEcoreJsonM1(context);}impl_generateEcoreJsonM1(context){// loopDetectionObj[context.data.id] = context.data; no loop detection here, the same literal can be exported multiple times in m1\n// return context.data.literal;\n// return context.data.name;\nreturn()=>context.data.value;}duplicate(){let deep=arguments.length>0&&arguments[0]!==undefined?arguments[0]:true;return this.cannotCall((this.constructor.cname||this.constructor.name)+\"duplicate()\");}get_duplicate(context){return function(){let deep=arguments.length>0&&arguments[0]!==undefined?arguments[0]:false;BEGIN();let le=context.proxyObject.father.addLiteral(context.data.name,context.data.value);let de=le.__raw;de.literal=context.data.literal;de.value=context.data.value;let we=le;we.annotations=deep?context.proxyObject.annotations.map(lchild=>lchild.duplicate(deep).id):context.data.annotations;END();return le;};}get_ordinal(context){return this.get_value(context);}set_ordinal(val,context){return this.set_value(val,context);}get_value(context){let ordinalAssumedByPosition=true;// per ottimizzazione forse è disattivabile\nif(!ordinalAssumedByPosition)return context.data.value||0;return context.proxyObject.father.ordinals.map(o=>o===null||o===void 0?void 0:o.id).indexOf(context.data.id);}set_value(val,context){if(val===context.data.value)return true;let ordinals=context.proxyObject.father.ordinals;if(ordinals[val]){Log.e(true,\"that ordinal place is already taken by \"+ordinals[val].name,{sameOrdinalLit:ordinals[val],ordinals,thiss:context.data});return true;}return SetFieldAction.new(context.data,'value',val);}/*\r\n        protected get_literal(context: Context): this[\"literal\"] { return context.data.literal; }\r\n        protected set_literal(val: this[\"literal\"], context: Context): boolean {\r\n            return SetFieldAction.new(context.data, 'literal', val, '', false); }*/get_literal(context){return context.data.name;}set_literal(val,context){if(val===context.data.name)return true;return SetFieldAction.new(context.data,'name',val,'',false);}},_class59.subclasses=[],_class59._extends=[],_class59))||_class58)||_class58);RuntimeAccessibleClass.set_extend(DNamedElement,DEnumLiteral);RuntimeAccessibleClass.set_extend(LNamedElement,LEnumLiteral);export let DEnumerator=(_dec31=RuntimeAccessible('DEnumerator'),Leaf(_class60=_dec31(_class60=(_class61=class DEnumerator extends DPointerTargetable{constructor(){super(...arguments);this.id=void 0;this.instanceClassName=void 0;this.parent=[];this.father=void 0;this.annotations=[];this.name=void 0;this.defaultValue=void 0;this.serializable=true;this.literals=[];}// DDataType\n// static singleton: LEnumerator;\n// static logic: typeof LEnumerator;\n// static structure: typeof DEnumerator;\n// inherit redefine\n// instanceClass: EJavaClass // ?\n// isInstance(object: EJavaObject): boolean; ?\n// getClassifierID(): number;\n// usedBy: Pointer<DAttribute, 0, 'N', LAttribute> = []; obsolete?\n// personal\nstatic new(name,father){let persist=arguments.length>2&&arguments[2]!==undefined?arguments[2]:true;if(!name)name=this.defaultname(\"enum \",father);return new Constructors(new DEnumerator('dwc'),father,persist,undefined).DPointerTargetable().DModelElement().DNamedElement(name).DEnumerator().end();}static new2(setter,father,name){if(!name)name=this.defaultname(\"enum \",father);return new Constructors(new DEnumerator('dwc'),father,true,undefined).DPointerTargetable().DModelElement().DNamedElement(name).DEnumerator().end(d=>{Object.assign(d,setter);});}static new3(a,callback){let persist=arguments.length>2&&arguments[2]!==undefined?arguments[2]:true;if(!a.name)a.name=this.defaultname(\"enum \",a.father);return new Constructors(new DEnumerator('dwc'),a.father,persist,undefined,a.id).DPointerTargetable().DModelElement().DNamedElement(a.name).DEnumerator().end(callback);}},_class61.subclasses=[],_class61._extends=[],_class61))||_class60)||_class60);export let LEnumerator=(_dec32=RuntimeAccessible('LEnumerator'),Node(_class62=_dec32(_class62=(_class63=class LEnumerator extends LDataType{constructor(){super(...arguments);this.__raw=void 0;this.id=void 0;this.instanceClassName=void 0;this.parent=void 0;this.father=void 0;this.annotations=void 0;this.name=void 0;this.namespace=void 0;this.defaultValue=void 0;this.serializable=void 0;this.isPrimitive=void 0;this.isClass=void 0;this.isEnum=void 0;this.literals=void 0;this.ordinals=void 0;}// DDataType\n// static singleton: LEnumerator;\n// static logic: typeof LEnumerator;\n// static structure: typeof DEnumerator;\n// inherit redefine\n// instanceClass: EJavaClass // ?\n// isInstance(object: EJavaObject): boolean; ?\n// getClassifierID(): number;\n// usedBy!: LAttribute[];\n// personal\n// literal array ordered by ordinal number\ngenerateEcoreJson_impl(context){let loopDetectionObj=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};loopDetectionObj[context.data.id]=context.data;const json={};let d=context.data;if(d.instanceClassName)json[ECoreEnum.instanceTypeName]=d.instanceClassName;json[ECoreEnum.xsitype]='ecore:EEnum';json[ECoreEnum.namee]=d.name;json[ECoreEnum.serializable]=d.serializable?\"true\":\"false\";json[ECoreEnum.eLiterals]=context.proxyObject.literals.map(l=>l.generateEcoreJson(loopDetectionObj));return json;}duplicate(){let deep=arguments.length>0&&arguments[0]!==undefined?arguments[0]:true;return this.cannotCall((this.constructor.cname||this.constructor.name)+\"duplicate()\");}get_duplicate(context){return function(){let deep=arguments.length>0&&arguments[0]!==undefined?arguments[0]:false;BEGIN();let le=context.proxyObject.father.addEnumerator(context.data.name);let de=le.__raw;de.defaultValue=context.data.defaultValue;de.serializable=context.data.serializable;let we=le;we.annotations=deep?context.proxyObject.annotations.map(lchild=>lchild.duplicate(deep).id):context.data.annotations;we.literals=deep?context.proxyObject.literals.map(lchild=>lchild.duplicate(deep).id):context.data.literals;END();return le;};}get_children_idlist(context){return[...super.get_children_idlist(context),...context.data.literals];}addLiteral(name,value){return this.cannotCall(\"addLiteral\");}get_addLiteral(context){return(name,value)=>LPointerTargetable.fromD(DEnumLiteral.new(name,value,context.data.id,true));}get_literals(context){return context.data.literals.map(pointer=>{return LPointerTargetable.from(pointer);});}set_literals(val,context){const list=val.map(lItem=>{return Pointers.from(lItem);});const oldList=context.data.literals;const diff=U.arrayDifference(oldList,list);BEGIN();SetFieldAction.new(context.data,'literals',list,\"\",true);for(let id of diff.added){SetFieldAction.new(id,'father',context.data.id,'',true);SetFieldAction.new(id,'parent',context.data.id,'+=',true);}for(let id of diff.removed){SetFieldAction.new(id,'father',undefined,'',true);const parent=DPointerTargetable.from(id).parent;U.arrayRemoveAll(parent,context.data.id);SetFieldAction.new(id,'parent',parent,'',true);}END();return true;}get_ordinals(context){let ret=[];let literals=context.proxyObject.literals;let dliterals=literals.map(d=>d.__raw);/*\r\n        if it happens like:   second=2, third, fourth=4, fifth=3, sixth.(six would be 4 but 4 already exist)\r\n        there are 2 problems:\r\n        1) [3] is already occupied by third, but fith is correctly being the only one explicitly declaring his ordinal 3.\r\n           fixed by first assigning all known ordinals, then starting with the assumed ordinals.\r\n        2) sixth would get in position fourth, but that is already occupied\r\n         */ // adressing 1)\nfor(let i=0;i<dliterals.length;i++){let v=dliterals[i].value;if(v){ret[v]=literals[i];}}// setting assumed literals\nlet currentOrdinal=0;for(let i=0;i<dliterals.length;i++){let v=dliterals[i].value;if(v){currentOrdinal=v;continue;}while(ret[currentOrdinal])currentOrdinal++;// adressing 2)\nret[currentOrdinal]=literals[i];}return ret;}},_class63.subclasses=[],_class63._extends=[],_class63))||_class62)||_class62);RuntimeAccessibleClass.set_extend(DDataType,DEnumerator);RuntimeAccessibleClass.set_extend(LDataType,LEnumerator);export let DModelM1=(_dec33=RuntimeAccessible('DModelM1'),_dec33(_class64=class DModelM1 extends DNamedElement{constructor(){super(...arguments);this.name=void 0;this.roots=void 0;this.children=void 0;}// no package ma LObjects[] (solo quelli isRoot)\n})||_class64);export let LModelM1=(_dec34=RuntimeAccessible('LModelM1'),_dec34(_class66=class LModelM1 extends LNamedElement{constructor(){super(...arguments);this.name=void 0;this.roots=void 0;this.children=void 0;}})||_class66);RuntimeAccessibleClass.set_extend(DModelM1,DNamedElement);RuntimeAccessibleClass.set_extend(LModelM1,LNamedElement);// problema: o costringo l'utente a fare sempre .value per ricevere il valore invece dei metadati\n// oppure ritorno il valore da subito ma dal valore non posso accedere ai metadati (upperbound...) a meno che non trovi un altor sistema.\n// possibile fix: LValue.toString() che ritorna il .value\nexport let DModel=(_dec35=RuntimeAccessible('DModel'),_dec35(_class68=(_class69=class DModel extends DNamedElement{constructor(){super(...arguments);this.id=void 0;this.parent=[];this.father=void 0;this.annotations=[];this.name=void 0;this.packages=[];this.isMetamodel=true;this.objects=[];this.models=[];this.instanceof=void 0;this.instances=void 0;this.dependencies=void 0;}// DNamedElement\n// static singleton: LModel;\n// static logic: typeof LModel;\n// static structure: typeof DModel;\n// inherit redefine\n// personal\nstatic new(name,instanceoff,isMetamodel){let persist=arguments.length>3&&arguments[3]!==undefined?arguments[3]:true;let dmodels=Selectors.getAll(DModel,undefined,undefined,true,false);let dmodelnames=dmodels.map(d=>d.name);if(!name)name=this.defaultname(\"model_\",name=>dmodelnames.includes(name));return new Constructors(new DModel('dwc'),undefined,persist,undefined).DPointerTargetable().DModelElement().DNamedElement(name).DModel(instanceoff,isMetamodel).end();}static new2(setter,name,instanceoff){let dmodels=Selectors.getAll(DModel,undefined,undefined,true,false);let dmodelnames=dmodels.map(d=>d.name);if(!name)name=this.defaultname(\"model_\",name=>dmodelnames.includes(name));return new Constructors(new DModel('dwc'),undefined,true,undefined).DPointerTargetable().DModelElement().DNamedElement(name).DModel(instanceoff).end(d=>{Object.assign(d,setter);});}static new3(a,callback){let persist=arguments.length>2&&arguments[2]!==undefined?arguments[2]:true;let dmodels=Selectors.getAll(DModel,undefined,undefined,true,false);let dmodelnames=dmodels.map(d=>d.name);if(!a.name)a.name=this.defaultname(\"model_\",name=>dmodelnames.includes(name));return new Constructors(new DModel('dwc'),a.father,persist,undefined,a.id).DPointerTargetable().DModelElement().DNamedElement(a.name).DModel(a.instanceof,!a.instanceof).end(callback);}},_class69.subclasses=[],_class69._extends=[],_class69))||_class68);export let EdgeStarter=(_dec36=RuntimeAccessible('EdgeStarter'),_dec36(_class70=class EdgeStarter{// <T1 extends LPointerTargetable = LPointerTargetable, T2 extends LPointerTargetable = LPointerTargetable>{\n// suggested id & key for the element.\n/*\r\n    firstRenderedStartNode: LGraphElement;\r\n    firstRenderedEndNode: LGraphElement;*/ // todo: if you want to get the first visible parent node (like for pkg dependencies), use edgestarter.startNode.firstRenderedNode\nconstructor(start,end,sn,en,otherPossibleEnds,m1refindex,type){var _this$startVertex,_this$endVertex,_this$endGraph,_this$startGraph,_this$startSize,_this$startVertexSize;this.id=void 0;this.start=void 0;this.end=void 0;this.startNode=void 0;this.endNode=void 0;this.startVertex=void 0;this.endVertex=void 0;this.startGraph=void 0;this.endGraph=void 0;this.startSize=void 0;this.endSize=void 0;this.startVertexSize=void 0;this.endVertexSize=void 0;this.otherEnds=void 0;this.extendTargets=void 0;this.sameGraph=void 0;this.isSameGraph=void 0;this.overlaps=void 0;this.vertexOverlaps=void 0;this.start=start;this.end=end;this.startNode=sn;this.endNode=en;this.otherEnds=this.extendTargets=otherPossibleEnds;// || end.nodes;\n//console.log('edgestarter ss', {end, start, sn, en});\nthis.startSize=sn.outerSize;this.endSize=en.outerSize;this.startVertex=sn.vertex;this.endVertex=en.vertex;this.startGraph=(_this$startVertex=this.startVertex)===null||_this$startVertex===void 0?void 0:_this$startVertex.root;this.endGraph=(_this$endVertex=this.endVertex)===null||_this$endVertex===void 0?void 0:_this$endVertex.root;this.sameGraph=this.isSameGraph=((_this$endGraph=this.endGraph)===null||_this$endGraph===void 0?void 0:_this$endGraph.id)===((_this$startGraph=this.startGraph)===null||_this$startGraph===void 0?void 0:_this$startGraph.id);//this.firstRenderedStartNode = this.startNode.firstRenderedNode;\n//this.firstRenderedEndNode = this.startNode.firstRenderedNode;\n// this.firstVisibleStart = this.startNode.firstRenderedNode;\n//console.log('edgestarter evs', {end, start, sn, en});\nthis.startVertexSize=this.startVertex===sn?this.startSize:this.startVertex.outerSize;this.endVertexSize=this.endVertex===en?this.endSize:this.endVertex.outerSize;this.overlaps=(_this$startSize=this.startSize)===null||_this$startSize===void 0?void 0:_this$startSize.isOverlapping(this.endSize);this.vertexOverlaps=(_this$startVertexSize=this.startVertexSize)===null||_this$startVertexSize===void 0?void 0:_this$startVertexSize.isOverlapping(this.endVertexSize);//console.log('edgestarter end', {end, start, sn, en});\n// how to pick edgeid:\n// using nodeid is useless, as a ref might be hidden and take the node of a class or upper, it must be resolved at conceptual model-level\n// mid = model id\n// NB: mid -> mid is safe for extends, why:\n// if a->b1->c && a->b2->c and both b1,b2 are hidden, extend edges might become both a->c, but in that case is fine to have it only once (filter it in suggestions)\n// mid -> mid                   is safe for package-dependencies for the same reason as class inheritance.\n// mid -> mid                   is not safe for dvalues which might have duplicate references. (DValue.a -> [Object.b, Object.b])\n// mid + (valueindex) -> mid    is safe for everything i think.\n// !!!! REMEMBER, DOTS AND ~ ARE NOT ALLOWED IN ID (css selector char) !!!\nthis.id=start.id+('_'+m1refindex)+'-'+end.id+type;}/*\r\n    static oneToMany<T1 extends LModelElement = LModelElement, T2 extends LModelElement = LModelElement>(start: T1, ends:T2[]): EdgeStarter<T1, T2>[] {\r\n        let sn = start.node;\r\n        if (!sn) return [];\r\n        let rett: (EdgeStarter | undefined)[] = ends.map( (e) => {\r\n            if(!e) return undefined;\r\n            let en = e.node;\r\n            return en ? new EdgeStarter(start, e, sn as LGraphElement, en) : undefined;\r\n        });\r\n        let ret: (EdgeStarter)[] = rett.filter<EdgeStarter>(function(e: EdgeStarter|undefined): e is EdgeStarter { return !!e });\r\n        // let ret: (EdgeStarter)[] = rett.filter<EdgeStarter>((e): (e is EdgeStarter) => { return !!e });\r\n        return ret;\r\n    }*/})||_class70);export let LModel=(_dec37=RuntimeAccessible('LModel'),_dec37(_class72=(_class73=class LModel extends LNamedElement{constructor(){super(...arguments);this.__raw=void 0;this.id=void 0;this.parent=void 0;this.father=void 0;this.annotations=void 0;this.name=void 0;this.namespace=void 0;this.isMetamodel=void 0;this.packages=void 0;this.models=void 0;this.instances=void 0;this.dependencies=void 0;this.allDependencies=void 0;this.__info_of__dependencies={type:'LModel[]',txt:'Include other models as prerequisite for this model, it is as if this model is \"extending\" other models.'};this.__info_of__allDependencies={type:'LModel[]',txt:'Same as dependencies, but it solves recursively the dependencies of his dependencies.'};this.instanceof=void 0;this.objects=void 0;this.crossObjects=void 0;this.roots=void 0;this.enums=void 0;this.enumerators=void 0;this.crossEnumerators=void 0;this.classes=void 0;this.crossClasses=void 0;this.operations=void 0;this.parameters=void 0;this.exceptions=void 0;this.attributes=void 0;this.references=void 0;this.literals=void 0;this.values=void 0;this.allSubAnnotations=void 0;this.allCrossSubAnnotations=void 0;this.allSubPackages=void 0;this.allCrossSubPackages=void 0;this.allSubObjects=void 0;this.allCrossSubObjects=void 0;this.allSubValues=void 0;this.allCrossSubValues=void 0;this.suggestedEdges=void 0;this.__info_of__suggestedEdges={type:'Dictionary<\"extend\" | \"reference\" | \"packageDependencies\" | DmodelName, EdgeStarter[]>',txt:\"A map to access all possible kind of edges based on model data.\"+\"<br/>extend and reference are the most commonly used for horizontal references (outside the containment tree schema).\"+\"<br/>packageDependencies links packages using classes from other packages.\"+// \"<br/>other keys are the names of container data types (mode, package, class, object...) from them to their childrens rendered as Nodes (vertical tree schema).\" +\n// todo: implement the commented part as LGrahElement.vertexs.map(v=>{start:v.parentnode.isVertex ? v.parentnode.id : undefined, end:v.id}).filter(e=>e.start) instead. it's a thing of graph more than model.\n\"<br/> EdgeStarter is a collection of data useful to start a &lt;Edge /&gt; in JSX.\"};this.otherObjects=void 0;this.otherInstances=void 0;this.__info_of__otherObjects={type:\"(...excludeInstances: (string|LClass|Pointer)[], excludeSubclasses: boolean = false)=>LObject[]\",txt:/*#__PURE__*/_jsx(\"div\",{children:\"Alias for this.otherInstances.\"})};this.__info_of__otherInstances={type:\"(...excludeInstances: (string|LClass|Pointer)[], excludeSubclasses: boolean = false)=>LObject[]\",txt:/*#__PURE__*/_jsxs(\"div\",{children:[\"Read this.instancesOf documentation first.\",/*#__PURE__*/_jsx(\"br\",{}),\"Retrieves all the objects not obtained between previous calls of this.instancesOf and the last call of this method.\",/*#__PURE__*/_jsx(\"br\",{}),\"Meaning calling it twice without any instancesOf in between, it will return all objects.\"]})};this.__info_of__instancesOf={type:\"(instancetypes: orArr<(string | LClass | Pointer)>, includeSubclasses: boolean = false) => LObject[]\",txt:/*#__PURE__*/_jsxs(\"div\",{children:[\"Retrieves all objects instancing a target class.\",/*#__PURE__*/_jsx(\"br\",{}),\"The first parameter is the targeted class, which can be his name, pointer or object.\",/*#__PURE__*/_jsx(\"br\",{}),\"The second parameter tells if instances of his subclasses needs to be retreieved as well.\"]})};this.__info_of__addObject={type:\"(json: object, instanceof?: LClass) => LObject\",txt:\"Appends an object instancing \\\"instanceof\\\" to the model.\\n<br>Setting his own properties, and DValues according to the content of the parameter object.\"};this.__info_of__instantiableClasses={type:\"(o?: object, loose?: boolean) => LClass[]\",txt:\"List of all classes which can be used to instantiate an object.\"+\"\\n<br>Abstract and Interface classes are excluded.\"+\"\\n<br>If the parameter \\\"o\\\" is specified, it will filter only the instances conforming to the object schema.\"+\"\\n<br>Results are sorted from tightest fit to loosest fit.\"+\"\\n<br>loose parameter set to true makes return instead a list of matching scores of all subclasses.\",hidden:true};}// static singleton: LModel;\n// static logic: typeof LModel;\n// static structure: typeof DModel;\n// inherit redefine\n// personal\n// Metamodel\n// points to other models of the same level\n// Model\n// utilities to go down in the tree (plural names)\n// alias for enumerators\n//, model: EdgeStarter[], package:EdgeStarter[], class:EdgeStarter[]};\ngenerateEcoreJson_impl(context){let loopDetectionObj=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};loopDetectionObj[context.data.id]=context.data;const json={};// if it's M2 metamodel\nif(context.data.isMetamodel){const packageArr=[];for(let pkg of context.proxyObject.packages){packageArr.push(pkg.generateEcoreJson(loopDetectionObj));}// return (context.proxyObject.packages[0])?.generateEcoreJson(loopDetectionObj);\njson[ECoreRoot.ecoreEPackage]=packageArr;return json;}// if it's M1 model\n// let serializeasroot = context.proxyObject.isRoot && loopDetectionObj.length; // if rootobj is nested because you started the serialization from another node, i prevent it generating root content\nfor(let obj of context.proxyObject.roots){json[obj.ecoreRootName]=obj.generateEcoreJson(loopDetectionObj);}return json;}addPackage(name,uri,prefix){return this.cannotCall(\"addPackage\");}get_addPackage(context){console.log(\"Model.addPackage()\",{context,thiss:this});return(name,uri,prefix)=>{return LPointerTargetable.fromD(DPackage.new(name,uri,prefix,context.data.id,true,DModel));};}get_dependencies(c){return LPointerTargetable.fromPointer(c.data.dependencies);}get_allDependencies(c){let targets=L.fromArr(c.data.dependencies);return U.iterateChildProperties(targets,e=>e.dependencies);/*let alreadyParsed: Dictionary<Pointer, LModel> = {};\r\n        while (targets.length) {\r\n            let nextTargets = [];\r\n            for (let target of targets){\r\n                if (alreadyParsed[target.id]) continue;\r\n                alreadyParsed[target.id] = target;\r\n                U.arrayMergeInPlace(nextTargets, target.dependencies);\r\n            }\r\n            targets = nextTargets;\r\n        }\r\n        return Object.values(alreadyParsed);*/}/*public set_dependencies(c: Context): this['dependencies']{\r\n        default setter is fine, should automatically do the difference of pointers and trigger -= or +=\r\n    }*/ // return the first array parameter converted in an array of pointers. The second parameter is the scope where names are allowed to match. if empty all class.names will fail mapping to id's.\n// second parameter is mandatory when the array contain names, to prevent looking into class names of different models.\nstatic namesORDObjectsToID(targets,namedCandidates){// let targets = any[] = (!Array.isArray(targets0)) ? targets0 : [targets0];\nif(!targets)return[];let ret=[];let state=store.getState();if(targets&&!Array.isArray(targets))targets=[targets];let dnamedcandidates=namedCandidates?DPointerTargetable.fromArr(namedCandidates):[];let dAllowedNamesMap=dnamedcandidates.reduce((acc,val)=>{acc[val.name]=val.id;return acc;},{});//let dtargets: DNamedElement[] = targets ? DPointerTargetable.fromArr(targets) as DNamedElement[] : [];\nlet tmp;for(let target of targets){// try as name\ntmp=dAllowedNamesMap[target];if(tmp){ret.push(tmp);continue;}// try as $name\ntmp=dAllowedNamesMap[\"$\"+target];if(tmp){ret.push(tmp);continue;}// try as id\nlet d=DPointerTargetable.from(target,state);if(d&&dAllowedNamesMap[d.name]){ret.push(target);continue;}Log.ww(\"namesORDObjectsToID() could not resolve name:\",{name:target,namedCandidates,targets});}return ret;}_defaultGetter(c,key){//console.log(\"$getter 000\", {key, ism1:!c.data.isMetamodel, ism:c.data.isMetamodel, data:c.data});\nif(!c.data.isMetamodel)return this._defaultGetterM1(c,key);return this._defaultGetterM2(c,key);}_defaultGetterM2(c,key){if(TargetableProxyHandler.childKeys[key[0]]){// look for m1 matches\nlet k=key.substring(1).toLowerCase();let s=store.getState();for(let subelement of this.get_allSubPackages(c,s)){let n=subelement.__raw.name;if(n&&n.toLowerCase()===k)return subelement;}for(let subelement of this.get_classes(c,s)){let n=subelement.__raw.name;if(n&&n.toLowerCase()===k)return subelement;}}return this.__defaultGetter(c,key);// Log.ee(\"Could not find property \" + key + \" on MetaModel\", {c, key});\n}_defaultGetterM1(c,key){// if m1.$m1RootObjectName then --> return that root object\n// if m1.$m1ObjectName then --> return that sub object nested somewhere in the model.\n// if m1.$m2classname\"s\" then --> this.instancesOf(\"m2classname\")\n// if m1.$m2classname then ---> m2.$m2classname (lower priority, if there are 2 metaclasses differing only by final s,\n// the one with 1 more final \"s\" if shadowed by the instances of the one with 1 less final \"s\",\n// in that case you can access the shadowed one through m1.instanceof.$classnames\n// priorities: 1) m1 name natch --> m1object. 2) m2 exact name match --> m2item, 3) m2 name+\"s\" match --> instances\n// to access m2 classes within a package, need to navigate it like model.$packagename.Ssubcpackagename.$classname,\n// path + \"s\" won't work in that case, and need to use this.getInstancesOf instead\nif(TargetableProxyHandler.childKeys[key[0]]){// look for m1 matches\nlet deepmatch;let k=key.substring(1).toLowerCase();console.log(\"$getter 0\",{k,key,deepmatch});const directSubObjects=U.objectFromArrayValues(c.data.objects);for(let subobject of this.get_allSubObjects(c)){let n=subobject.name;if(!n||n.toLowerCase()!==k)continue;// A0) perfect match with direct child object\nif(directSubObjects[subobject.id])return subobject;// actually cannot do direct match, because proxy get function will solve it directly before calling _defaultGetter\nelse if(!deepmatch)deepmatch=subobject;}console.log(\"$getter 1\",{k,key,deepmatch});// A1) match with deep sub-object\nif(deepmatch)return deepmatch;// look for m2 matches\nlet m2=this.get_instanceof(c);console.log(\"$getter 2\",{k,key,m2});if(!m2)return Log.ee(\"Could not find m1 match for data.$name. And the metamodel is missing, so cannot get instances by type.\",{c,key,m2});let m2item;// check for a perfect m2 name match and return it\nm2item=m2[key];console.log(\"$getter 3\",{k,key,m2,m2item});if(m2item)return m2item;//this.instancesOf(key);\nif(!m2)Log.ee(\"Could not find property \"+key+\" on M1 Model\",{c,key,m2});// if not a perfect name match, i try name+s match for instances\nif(key[key.length-1]===\"s\"){let key1=key.substring(0,key.length-1);m2item=m2[key1];console.log(\"$getter 4\",{k,key,key1,m2,m2item});if(m2item){if(m2item.className===\"DClass\")return this.get_instancesOf(c)(m2item);else return Log.ee(\"Could not get instances of \"+key1+\".\",{c,key,m2});}}console.log(\"$getter 5\",{k,key,m2,m2item});if(!m2)return Log.ee(\"Could not find any subelement with name \"+key+\" on M1 or M2 Models\",{c,key,m1:c.data,m2});}return this.__defaultGetter(c,key);}// public otherObjectsSetup(){ LModel.otherObjectsTemp = undefined; LModel.otherObectsAccessedKeys = []; }\nget_otherObjects(c){return this.get_otherInstances(c);}get_otherInstances(c){var _this6=this;// todo:\nreturn function(excludeInstances){let includeSubclasses=arguments.length>1&&arguments[1]!==undefined?arguments[1]:false;let ret;_this6.get_instancesOf(c)(excludeInstances,includeSubclasses);// and drop the result\nif(!LModel.otherObjectsTemp){ret=_this6.get_allSubObjects(c);}else{let dict={...LModel.otherObjectsTemp};for(let key of LModel.otherObectsAccessedKeys)delete dict[key];delete LModel.otherObjectsTemp;delete LModel.otherObectsAccessedKeys;ret=Object.values(dict).flat();}return ret;};}// not meant to be called directly.\n_populateOtherObjects(c,classes){// from names, DClass and ptrs, make them only ptrs. all classes of this model are valid name targets.\n// nb: cannot optimize getting only instantiated classes from this.get_allSubObjects because if a class have 0 instances should have an empty array instead of undefined (risk jsx crash)\nlet state=store.getState();let dinstancetypes=(classes||this.get_classes(c,state)).map(c=>c.__raw);let namemap={};namemap=dinstancetypes.reduce((acc,current)=>{namemap[current.name]=current;return namemap;},namemap);let idtoname={};for(let n in namemap){idtoname[namemap[n].id]=n;}// make it more general, first make a dictionary holding all selected types as keys, including \"_other\"\n// then a SEPARATE (split this) function to return only the selected keys, merging the subarrays in the global naming instance map.\nLModel.otherObjectsTemp={};LModel.otherObectsAccessedKeys=[];// part 1: i add empty arrays for all instances, but not include shapeless objects.\nfor(let name in namemap){LModel.otherObjectsTemp[name]=[];}//LPointerTargetable.fromPointer(namemap[name].instances); }\n// part 2: for shapeless objs too\nLModel.otherObjectsTemp[undefined]=[];let allObjects=this.get_allSubObjects(c,state);// part 3: now i populate the Model.otherObjectsTemp dictionary arrays\nfor(let o of allObjects){// if (o.__instanceof) continue;\nlet name=idtoname[o.__raw.instanceof];if(!LModel.otherObjectsTemp[name]){LModel.otherObjectsTemp[name]=[o];Log.eDevv(\"model._populateOtherObjects() this case should never happen\",{name,o,allObjects,namemap,idtoname});}else LModel.otherObjectsTemp[name].push(o);}}instancesOf(instancetypes0){let includeSubclasses=arguments.length>1&&arguments[1]!==undefined?arguments[1]:false;return this.cannotCall(\"instancesOf\");}// M1\nget_instancesOf(c){var _this7=this;if(c.data.isMetamodel){return function(){Log.ww(\"cannot call instancesOf() on a metamodel\");return[];};}return function(instancetypes0){let includeSubclasses=arguments.length>1&&arguments[1]!==undefined?arguments[1]:false;let state=store.getState();let classes=_this7.get_classes(c,state);if(!LModel.otherObjectsTemp)_this7._populateOtherObjects(c,classes);if(!Array.isArray(instancetypes0))instancetypes0=[instancetypes0];// from names, DClass and ptrs, make them only ptrs. all classes of this model are valid name targets.\nlet instancetypes=LModel.namesORDObjectsToID(instancetypes0,classes);let dinstancetypes=DClass.fromPointer(instancetypes,state);if(includeSubclasses){let arr=dinstancetypes.map(d=>LPointerTargetable.fromD(d));for(let c of arr)dinstancetypes.push(...(c.allSubClasses.map(l=>l.__raw)||[]));dinstancetypes=[...new Set(dinstancetypes)];}let ret=[];for(let c of dinstancetypes){let arr=LModel.otherObjectsTemp[c.name];if(!arr||!arr.length)continue;ret.push(...arr);LModel.otherObectsAccessedKeys.push(c.name);}return ret;};}/*\r\n* instanceof === some class -> instantiate object and forces to conform to that class\r\ninstanceof === null  --> shapeless object\r\ninstanceof === undefined or missing  --> auto-detect and assign the type\r\n */addObject(json){let instanceoff=arguments.length>1&&arguments[1]!==undefined?arguments[1]:undefined;let forceCreation=arguments.length>2&&arguments[2]!==undefined?arguments[2]:false;return this.cannotCall(\"LValue.addObject\");}get_addObject(c){return LValue.singleton.get_addObject.call(this,c);}instantiableClasses(o){let loose=arguments.length>1&&arguments[1]!==undefined?arguments[1]:false;return this.cannotCall(\"instantiableClasses\");}// M1\nget_instantiableClasses(c){if(c.data.isMetamodel){return function(){Log.ww(\"cannot call instantiableClasses() on a metamodel\");return[];};}return LValue.singleton.get_instantiableClasses.call(this,c);}get_suggestedEdges(context){let ret;if(context.data.isMetamodel)ret=this.impl_get_suggestedEdgesM2(context);else ret=this.impl_get_suggestedEdgesM1(context);return ret;}impl_get_suggestedEdgesM1(context,state){let ret={extend:[],reference:[],packageDependencies:[]};if(context.data.isMetamodel){Log.ww(\"cannot call suggestedEdgesM1() on a metamodel\");return ret;}if(Debug.lightMode){return ret;}let s=store.getState();let values=this.get_allSubValues(context,s);let map={};if(!state)state=store.getState();outer:for(let lval of values){if(!lval)continue;let dval=lval.__raw;let values=dval.values||[];// NB: ELiterals can be pointers in L, but string or ordinal numbers in D, but they won't make edges, so i use .__raw\ninner:for(let valindex=0;valindex<values.length;valindex++){let v=values[valindex];if(!Pointers.isPointer(v,state))continue inner;let snode=lval.notEdge;if(!snode||!snode.html)continue outer;if(v===dval.id)continue inner;// pointing to itself\nlet ltarget=LPointerTargetable.fromPointer(v,state);if(!ltarget)continue;if(ltarget.className!==DObject.cname)continue inner;let enode=ltarget.notEdge;if(!enode||!enode.html)continue inner;if(!map[dval.id])map[dval.id]=[];map[dval.id].push(new EdgeStarter(lval,ltarget,snode,enode,[],valindex,'values'));}}ret.reference=Object.values(map).flat();return ret;}impl_get_suggestedEdgesM2(context){let ret={extend:[],reference:[],packageDependencies:[]};if(!context.data.isMetamodel){Log.ww(\"cannot call suggestedEdgesM2() on a model\");return ret;}let s=store.getState();let classes=this.get_classes(context,s);let references=Debug.lightMode?[]:classes.flatMap(c=>c.references);ret.reference=references.map(r=>{let sn=r===null||r===void 0?void 0:r.notEdge;if(!sn||!sn.html)return undefined;let end=r.type;// if (end.id === r.id) return undefined;\nlet en=end===null||end===void 0?void 0:end.notEdge;if(!en||!en.html)return undefined;//console.log('pre edgestarter', {r, end, sn, en});\nreturn new EdgeStarter(r,end,sn,en,[],0,'association');}).filter(function(e){return!!e;});// ret.extend = classes.flatMap( c => EdgeStarter.oneToMany(c, c.extends));\nlet alreadyAdded={};// if A extends B1, B2;    B1 extends C1, C2;    and node B1 is hidden. instead of edge from A to B, i display edge from A~C1, A~C2, A~B2\nfunction SkipExtendNodeHidden(start,end){let rootCall=arguments.length>2&&arguments[2]!==undefined?arguments[2]:true;let ret=[];if(rootCall){alreadyAdded={};alreadyAdded[start.id]=start;}// end classes can get added twice if from a different starting subclass path (in classes.flatMap -> each one should have his own dict).\n// ret.start = start;\nlet sn=start.notEdge;if(!sn||!sn.html)return[];//  let end: LClass[] = start.extends;\nfor(let e of end){if(!e)continue;let eid=e.id;if(alreadyAdded[eid])continue;// without this there might be duplicates if A extends B1, B2;  and both B1 & B2 extends C\nalreadyAdded[eid]=e;let en=e.notEdge;if(en&&en.html){ret.push({start,end:e,sn,en});continue;}let secondTierExtends=e.extends;// for (let eend of secondTierExtends) {\nret.push(...SkipExtendNodeHidden(start,secondTierExtends,false));//}\n}return ret;}ret.extend=classes.flatMap(c=>SkipExtendNodeHidden(c,c.extends,true)).map(es=>{let otherEdgeEnds=es.start.extendsChain.flatMap(c=>(c===null||c===void 0?void 0:c.nodes)||[]).filter(c=>{var _es$sn,_es$sn$root,_c$root;if(!c||!c.rendered)return false;if(((_es$sn=es.sn)===null||_es$sn===void 0?void 0:(_es$sn$root=_es$sn.root)===null||_es$sn$root===void 0?void 0:_es$sn$root.id)!==((_c$root=c.root)===null||_c$root===void 0?void 0:_c$root.id))return false;return true;});return new EdgeStarter(es.start,es.end,es.sn,es.en,otherEdgeEnds,0,'extend');});let dependencies=Debug.lightMode?[]:[...classes.map(c=>{return{src:c,ends:c.superclasses};}),...references.map(r=>{return{src:r,ends:[r.type]};})];let pkgdependencies=[];// transform form in dictionary to prevent duplicates\n//dependencies.map( d=> { let end = d.end.package; return {src:d.src.package, end, endid:end.id}})\nfor(let d of dependencies){let src=d.src.package;if(!src)continue;let srcnode=src.notEdge;if(!srcnode||!srcnode.html)continue;let ends={};for(let end of d.ends){let ep=end.package;if(!ep)continue;let epnode=ep.notEdge;if(!epnode||!epnode.html)continue;ends[ep.id]={end:ep,en:epnode};}pkgdependencies.push({src,sn:srcnode,ends});}// todo: check\nret.packageDependencies=pkgdependencies.flatMap(pd=>Object.values(pd.ends).map(end=>new EdgeStarter(pd.src,end.end,pd.sn,end.en,[],0,'pkg_dep')));return ret;}get_models(context){// todo: should this not be data.instances instead?\nreturn LModel.fromPointer(context.data.models);}set_models(val,context){const list=val.map(lItem=>{return Pointers.from(lItem);});const oldList=context.data.models;const diff=U.arrayDifference(oldList,list);BEGIN();SetFieldAction.new(context.data,'models',list,'',true);for(let id of diff.added){SetFieldAction.new(id,'father',context.data.id,'',true);SetFieldAction.new(id,'parent',context.data.id,'+=',true);}for(let id of diff.removed){SetFieldAction.new(id,'father',undefined,'',true);const parent=DPointerTargetable.from(id).parent;U.arrayRemoveAll(parent,context.data.id);SetFieldAction.new(id,'parent',parent,'',true);}END();return true;}duplicate(){let deep=arguments.length>0&&arguments[0]!==undefined?arguments[0]:true;throw new Error(\"Model.duplicate(): use export/import ecore instead.\");}set_instanceof(val,context){let ptr=Pointers.from(val);SetFieldAction.new(context.data.id,\"instanceof\",ptr,undefined,true);// update father's collections (pointedby's here are set automatically)\n// todo: ptr && SetFieldAction.new(ptr, \"instances\", context.data.id, '+=', true);\nreturn true;}get_instanceof(context){return context.data.instanceof?LPointerTargetable.fromPointer(context.data.instanceof):undefined;}set_name(val,context){const models=LModel.fromPointer(store.getState()['models']);if(models.filter(model=>{return model.name===val;}).length>0){U.alert('e','Cannot rename the selected element since this name is already taken.');}else{SetFieldAction.new(context.data,'name',val,'',false);}return true;}get_children_idlist(context){let children;if(context.data.isMetamodel)children=context.data.packages;else children=context.proxyObject.allSubObjects.map(o=>o.id);return[...super.get_children_idlist(context),...children];}get_isMetamodel(context){return context.data.isMetamodel;}set_isMetamodel(val,context){if(context.data.isMetamodel!==val)SetFieldAction.new(context.data,'isMetamodel',val,'',false);return true;}get_crossObjects(context){return this.get_objects(context,true);}get_objects(context){let includeCrossReferences=arguments.length>1&&arguments[1]!==undefined?arguments[1]:false;let ret=context.data.objects.map(pointer=>LPointerTargetable.from(pointer));if(includeCrossReferences)U.arrayMergeInPlace(ret,context.proxyObject.allDependencies.flatMap(dep=>dep.objects));return ret;}get_crossPackages(context){return this.get_packages(context,true);}get_packages(context){let includeCrossReferences=arguments.length>1&&arguments[1]!==undefined?arguments[1]:false;if(!context.data.isMetamodel){return context.data.instanceof?this.get_instanceof(context).packages:[];}let ret=context.data.packages.map(pointer=>LPointerTargetable.from(pointer));if(includeCrossReferences)U.arrayMergeInPlace(ret,context.proxyObject.allDependencies.flatMap(dep=>dep.packages));return ret;}set_packages(val,context){const list=val.map(lItem=>{return Pointers.from(lItem);});const oldList=context.data.packages;const diff=U.arrayDifference(oldList,list);BEGIN();SetFieldAction.new(context.data,'packages',list,\"\",true);for(let id of diff.added){SetFieldAction.new(id,'father',context.data.id,'',true);SetFieldAction.new(id,'parent',context.data.id,'+=',true);}for(let id of diff.removed){SetFieldAction.new(id,'father',undefined,'',true);const parent=DPointerTargetable.from(id).parent;U.arrayRemoveAll(parent,context.data.id);SetFieldAction.new(id,'parent',parent,'',true);}END();return true;}get_crossRoots(context){return this.get_roots(context,true);}get_roots(context){let includeCross=arguments.length>1&&arguments[1]!==undefined?arguments[1]:false;return this.get_objects(context,includeCross);//.filter( o => o.isRoot);\n}get_crossClasses(c,s){return this.get_classes(c,s,true);}get_classes(c,s){let includeCross=arguments.length>2&&arguments[2]!==undefined?arguments[2]:false;let key='classes';let crossKey='crossClasses';let kind=DClass;if(!c.data.isMetamodel){if(!c.data.instanceof)return[];let meta=this.get_instanceof(c);if(includeCross&&c.data.dependencies.length)return meta[crossKey];return meta[key];}return this._getallSub(c,s,kind,includeCross);}get_crossReferences(c,s){return this.get_references(c,s,true);}get_references(c,s){let includeCross=arguments.length>2&&arguments[2]!==undefined?arguments[2]:false;let key='references';let crossKey='crossReferences';let kind=DReference;if(!c.data.isMetamodel){if(!c.data.instanceof)return[];let meta=this.get_instanceof(c);if(includeCross&&c.data.dependencies.length)return meta[crossKey];return meta[key];}return this._getallSub(c,s,kind,includeCross);}get_crossEnums(context){return this.get_enumerators(context,undefined,true);}get_enums(context){if(!context.data.isMetamodel){return context.data.instanceof?this.get_instanceof(context).enumerators:[];}return this.get_enumerators(context,undefined,false);}get_crossEnumerators(context,s){return this.get_enumerators(context,s,true);}get_enumerators(c,s){let includeCross=arguments.length>2&&arguments[2]!==undefined?arguments[2]:false;let key='enumerators';let crossKey='crossEnumerators';let kind=DEnumerator;if(!c.data.isMetamodel){if(!c.data.instanceof)return[];let meta=this.get_instanceof(c);if(includeCross&&c.data.dependencies.length)return meta[crossKey];return meta[key];}return this._getallSub(c,s,kind,includeCross);}get_allCrossSubPackages(c,s){return this.get_allSubPackages(c,s,true);}get_allSubPackages(c,s){let includeCross=arguments.length>2&&arguments[2]!==undefined?arguments[2]:false;let key='allSubPackages';let crossKey='allCrossSubPackages';let kind=DPackage;if(!c.data.isMetamodel){if(!c.data.instanceof)return[];let meta=this.get_instanceof(c);if(includeCross&&c.data.dependencies.length)return meta[crossKey];return meta[key];}return this._getallSub(c,s,kind,includeCross);/*state = state || store.getState();\r\n        let tocheck: Pointer<DPackage>[] = context.data.packages || [];\r\n        let checked: Dictionary<Pointer, DPackage> = {};\r\n        while (tocheck.length) {\r\n            let newtocheck: Pointer<DPackage>[] = [];\r\n            for (let ptr of tocheck) {\r\n                if (checked[ptr]) throw new Error(\"loop in packages containing themselves\");\r\n                let dpackage: DPackage = DPointerTargetable.from(ptr, state);\r\n                checked[ptr] = dpackage;\r\n                U.arrayMergeInPlace(newtocheck, dpackage?.subpackages);\r\n            }\r\n            tocheck = newtocheck;\r\n        }\r\n        let darr: DPackage[] = Object.values(checked);\r\n        let larr: LPackage[] & Dictionary<DocString<\"$name\">, LPackage> = LPointerTargetable.fromArr(darr, state);\r\n        U.toNamedArray(larr, darr);\r\n        return larr;*/}get_allCrossSubValues(c,s){return this.get_allSubValues(c,s,true);}get_allSubValues(c,s,includeCross){return this._getallSub(c,s,DValue,includeCross);}// allCrossSubAnnotations!: LAnnotation[];     allCrossSubPackages!: LPackage[];     allCrossObjects!: LObject[];     allCrossSubValues!: LValue[];\nget_allCrossSubObjects(c,s){return this.get_allSubObjects(c,s,true);}get_allSubObjects(c,s,includeCross){return this._getallSub(c,s,DObject,includeCross);}_getallSub(context,state,kind,includeCross){state=state||store.getState();let darr=Selectors.getAll(kind,undefined,state,true,false);console.log('get_allSubPackages',{includeCross,kind});// console.log(\"gao\", {darr:[...darr]});\nlet larr=[];// let validModels = includeCross ? [c.data.id, ...c.data.dependencies] : [c.data.id];\nlet allDeps=includeCross?this.get_allDependencies(context):[];let allDepPtrs=allDeps.map(m=>m.id);for(let i=0;i<darr.length;i++){let l=LPointerTargetable.fromD(darr[i]);if(!l)continue;let lmodel=l.model;// Log.exDev(!lmodel, \"missing model in model element\", {l, context}); normal for primitive types in \"m3\"\nif(!lmodel)continue;let lmodelid=l.model.id;if(lmodelid===context.data.id||includeCross&&allDepPtrs.includes(lmodelid)){larr.push(l);}darr[i]=undefined;continue;}// console.log(\"gao\", {darr:[...darr], larr});\ndarr=darr.filter(d=>!!d);// console.log(\"gao\", {darr, larr});\nU.toNamedArray(larr,darr);return larr;}getClassByNameSpace(namespacedclass){return this.cannotCall(\"getClassByNameSpace\");}get_getClassByNameSpace(context){if(!context.data.isMetamodel){return context.data.instanceof?this.get_instanceof(context).getClassByNameSpace:undefined;}return namespacedclass=>{let pos=namespacedclass.lastIndexOf(\":\");let pkguri=namespacedclass.substring(0,pos);let classname=namespacedclass.substring(pos+1);let pkg=this.get_getPackageByUri(context)(pkguri);if(!pkg)return undefined;// return pkg[\"@\" + classname];\nreturn pkg.classes.filter(c=>c.name===classname)[0];};}getPackageByUri(uri){return this.cannotCall(\"getPackageByUri\");}get_getPackageByUri(context){return uri=>context.proxyObject.allSubPackages.filter(p=>p.uri===uri)[0];}/* See src/api/persistance/save.ts */get_attributes(context){if(!context.data.isMetamodel){return context.data.instanceof?this.get_instanceof(context).attributes:[];}return context.proxyObject.classes.flatMap(c=>c.attributes);}get_literals(context){if(!context.data.isMetamodel){return context.data.instanceof?this.get_instanceof(context).literals:[];}return context.proxyObject.enumerators.flatMap(e=>e.literals);}get_values(context){return context.proxyObject.objects.flatMap(o=>o.features);}},_class73.subclasses=[],_class73._extends=[],_class73.otherObjectsTemp=undefined,_class73.otherObectsAccessedKeys=[],_class73))||_class72);RuntimeAccessibleClass.set_extend(DNamedElement,DModel);RuntimeAccessibleClass.set_extend(LNamedElement,LModel);export let DFactory_useless_=(_dec38=RuntimeAccessible('DFactory_useless_'),_dec38(_class74=(_class75=class DFactory_useless_ extends DPointerTargetable{constructor(){super(...arguments);this.id=void 0;this.parent=[];this.father=void 0;this.annotations=[];this.ePackage='';}// DModelElement\n// static singleton: LFactory_useless_;\n// static logic: typeof LFactory_useless_;\n// static structure: typeof DFactory_useless_;\n// inherit redefine\n// personal\n// ********************** my additions inherited ********************* //\n// ********************** my additions personal ********************** //\n},_class75.subclasses=[],_class75._extends=[],_class75))||_class74);export let LFactory_useless_=(_dec39=RuntimeAccessible('LFactory_useless_'),_dec39(_class76=(_class77=class LFactory_useless_ extends LModelElement{constructor(){super(...arguments);this.__raw=void 0;this.id=void 0;this.parent=void 0;this.father=void 0;this.annotations=void 0;this.ePackage=void 0;}// static singleton: LFactory_useless_;\n// static logic: typeof LFactory_useless_;\n// static structure: typeof DFactory_useless_;\n// inherit redefine\n// personal\n// ********************** my additions inherited ********************* //\n// ********************** my additions personal ********************** //\n},_class77.subclasses=[],_class77._extends=[],_class77))||_class76);// DModelElement.subclasses.push('DFactory_useless_'); // because it's abstract and cannot be used as a value, it's pure type definition\n// DModelElement.subclasses.push('LFactory_useless_'); // because it's abstract and cannot be used as a value, it's pure type definition\n// RuntimeAccessibleClass.set_extend(DModelElement, DFactory_useless_);\n// RuntimeAccessibleClass.set_extend(LModelElement, LFactory_useless_);\nexport let EJavaObject=(_dec40=RuntimeAccessible('EJavaObject'),_dec40(_class78=class EJavaObject{})||_class78);// ??? EDataType instance?\nexport let DMap=(_dec41=RuntimeAccessible('DMap'),_dec41(_class79=(_class80=class DMap extends RuntimeAccessibleClass{// DPointerTargetable\n// static logic: typeof LModelElement;\n// static structure: typeof DModelElement;\n// static singleton: LModelElement;\nconstructor(){super();this.__isDMap=void 0;}// id!: Pointer<DModelElement, 1, 1, LModelElement>;\n},_class80.subclasses=[],_class80._extends=[],_class80))||_class79);export let LMap=(_dec42=RuntimeAccessible('LMap'),_dec42(_class81=(_class82=class LMap extends LPointerTargetable{constructor(){super(...arguments);this.__isLMap=void 0;}// static logic: typeof LModelElement;\n// static structure: typeof DModelElement;\n// static singleton: LModelElement;\n// id!: Pointer<DModelElement, 1, 1, LModelElement>;\n},_class82.subclasses=[],_class82._extends=[],_class82))||_class81);RuntimeAccessibleClass.set_extend(DPointerTargetable,DMap);RuntimeAccessibleClass.set_extend(LPointerTargetable,LMap);export let DObject=(_dec43=RuntimeAccessible('DObject'),Leaf(_class83=_dec43(_class83=(_class84=class DObject extends DPointerTargetable{constructor(){super(...arguments);this.annotations=void 0;this.id=void 0;this.parent=[];this.father=void 0;this.name=void 0;this.instanceof=void 0;this.features=[];}// extends DNamedElement, m1 class instance\n// inherit redefine\n// annotations: Pointer<DAnnotation, 0, 'N', LAnnotation> = [];\n// personal\n// actually nullable now, but takes too much type refactoring. be careful to check if it's present\nstatic new(instanceoff,father,fatherType,name){let persist=arguments.length>4&&arguments[4]!==undefined?arguments[4]:true;// if (!name) name = this.defaultname(((meta: LNamedElement) => meta.name + \" \"), father);\nif(!name)name=this.defaultname(meta=>((meta===null||meta===void 0?void 0:meta.name)||\"obj\")+\"_\",father,instanceoff);let ret=new Constructors(new DObject('dwc'),father,persist,fatherType).DPointerTargetable().DModelElement().DNamedElement(name).DObject(instanceoff).end();return ret;}static new3(ptrs,then,fatherType){let persist=arguments.length>3&&arguments[3]!==undefined?arguments[3]:true;if(!ptrs.name)ptrs.name=this.defaultname(meta=>((meta===null||meta===void 0?void 0:meta.name)||\"obj\")+\"_\",ptrs.father,ptrs.instanceof);return new Constructors(new DObject('dwc'),ptrs.father,persist,fatherType,ptrs.id).DPointerTargetable().DModelElement().DNamedElement(ptrs.name).DObject(ptrs.instanceof).end(then);}},_class84.subclasses=[],_class84._extends=[],_class84))||_class83)||_class83);export let LObject=(_dec44=RuntimeAccessible('LObject'),_dec44(_class85=(_class86=class LObject extends LNamedElement{constructor(){super(...arguments);this.__raw=void 0;this.id=void 0;this.annotations=void 0;this.children=void 0;this.allChildren=void 0;this.truechildren=void 0;this.parent=void 0;this.father=void 0;this.model=void 0;this.name=void 0;this.ecoreRootName=void 0;this.namespace=void 0;this.fullname=void 0;this.defaultValue=void 0;this.deepSubObjects=void 0;this.subObjects=void 0;this.referenceFeatures=void 0;this.attributeFeatures=void 0;this.shapelessFeatures=void 0;this.instanceof=void 0;this.features=void 0;this.isRoot=void 0;this.partial=void 0;this.composed=void 0;this.aggregated=void 0;this.contained=void 0;this.referencedBy=void 0;this.typeStr=void 0;this.typeString=void 0;this.__info_of__typeStr={type:ShortAttribETypes.EString,txt:/*#__PURE__*/_jsxs(\"div\",{children:[\"Alias of\",/*#__PURE__*/_jsx(\"i\",{children:\"this.typeString\"})]})};this.__info_of__typeString={type:ShortAttribETypes.EString,txt:/*#__PURE__*/_jsxs(\"div\",{children:[\"Stringified version of \",/*#__PURE__*/_jsx(\"i\",{children:\"this.type\"})]})};}// extends DNamedElement, m1 class instance\n// inherit redefine\n// including hidden values\n// real shape without \"mirage\" values\n// annotations!: LAnnotation[];\n// from LClass\n// abstract!: boolean;\n// interface!: boolean;\n// references!: LReference[];\n// attributes!: LAttribute[];\n// operations!: LOperation[];\n// personal\n// todo: itera features (lvalue[]) deep e vitando di inserire doppioni (salva una mappatura di di già aggiunti e skip se ricompaiono)\n// subset of features that are references.\n// subset of features that are attributes.\n// subset of features that are not mapped and can have any kind of values.\n// + tutte le funzioni di comodità navigazionale del modello, trattarlo un pò come se fosse un modello (e quasi può esserlo)\nget_name(context){var _$name2;return((_$name2=context.proxyObject['$name'])===null||_$name2===void 0?void 0:_$name2.value)||context.data.name||context.proxyObject.instanceof.name;}get_composed(c){return LClass.singleton.get_composed(c);}get_aggregated(c){return LClass.singleton.get_aggregated(c);}get_contained(c){return LClass.singleton.get_contained(c);}/*\r\n    protected get_referencedBy(c: Context): this[\"referencedBy\"] { return (LClass.singleton as LClass).get_referencedBy(c as any) as any; }\r\n    */get_referencedBy(context){let state=store.getState();let targeting=LPointerTargetable.fromArr(context.data.pointedBy.map(p=>{let s=state;for(let key of PointedBy.getPathArr(p)){s=s[key];if(!s)return null;if(s.className===DValue.cname)return s.id;}}));return targeting;}get_truechildren(context){let childs=super.get_children(context);if(!context.data.instanceof)return childs;return childs.filter(c=>!c.isMirage);}get_allChildren(context){return super.get_children(context);}get_children(context){let sort=arguments.length>1&&arguments[1]!==undefined?arguments[1]:true;const pointers=[...new Set(super.get_children(context).map(c=>c.id))];let childs=LValue.fromArr(pointers);let meta=context.proxyObject.instanceof;// if (!sort && (!meta || meta.partial)) return childs;\nlet conformchildren=meta&&!meta.partial?meta.allChildren.map(c=>c.id):undefined;if(!sort){// console.log(\"return get features:\", {context, meta, childs, conformchildren, ret:childs.filter((c) => (c.instanceof?.id) && conformchildren!.includes(c.instanceof?.id))});\nif(!conformchildren)return childs;return childs.filter(c=>{var _c$instanceof,_c$instanceof2;return((_c$instanceof=c.instanceof)===null||_c$instanceof===void 0?void 0:_c$instanceof.id)&&conformchildren.includes((_c$instanceof2=c.instanceof)===null||_c$instanceof2===void 0?void 0:_c$instanceof2.id);});}let bymetaparent={};for(let v of childs){let vmeta=v.instanceof;// console.log(\"get features filtering:\", {context, meta, vmeta, v, childs, conformchildren});\nif(conformchildren&&(!vmeta||!conformchildren.includes(vmeta.id)))continue;let vmetaid=vmeta===null||vmeta===void 0?void 0:vmeta.id;// undef as key is fine even if compiler complains, so i cast it\nif(!bymetaparent[vmetaid])bymetaparent[vmetaid]=[v];else bymetaparent[vmetaid].push(v);}// console.log(\"return get features:\", {context, meta, childs, conformchildren, ret:Object.values(bymetaparent).flat()});\nreturn Object.values(bymetaparent).flat();}// derivate attribute, abstract\n// derivate attribute, abstract\nget_typeString(c){return this.get_typeStr(c);}get_typeStr(c){var _meta$typeToShortStri;let thiss=this;if(!thiss.get_instanceof)return'shapeless';let meta=thiss.get_instanceof(c);return(meta===null||meta===void 0?void 0:(_meta$typeToShortStri=meta.typeToShortString)===null||_meta$typeToShortStri===void 0?void 0:_meta$typeToShortStri.call(meta))||\"shapeless\";}// protected get_fromlclass<T extends keyof (LClass)>(meta: LClass, key: T): LClass[T] { return meta[key]; }\nget_model(context){let l=context.proxyObject;while(l&&l.className!==DModel.cname)l=l.father;return l;}// protected set_name(val: string, context: Context): boolean { return this.cannotSet(\"name\"); }\nset_namespace(val,context){return this.cannotSet(\"namespace\");}// protected get_namespace(context: Context): LClass[\"namespace\"] { return context.proxyObject.instanceof.namespace; }\nset_fullname(val,context){return this.cannotSet(\"fullname\");}// protected get_fullname(context: Context): LClass[\"fullname\"] { return context.proxyObject.instanceof.fullname; }\nset_ecoreRootName(val,context){return this.cannotSet(\"ecoreRootName\");}get_ecoreRootName(context){let instanceoff=context.proxyObject.instanceof;if(!instanceoff)return\"schemaless:Object\";return this.get_uri(context)+\":\"+instanceoff.name;// optimize later in instanceoff.namespace + \":\" + instanceoff.name; and implement namespace all around\n}set_partialdefaultname(val,context){return this.cannotSet(\"DObject.partialdefaultname()\");}get_partialdefaultname(context){return context.data.instanceof?context.proxyObject.instanceof.partialdefaultname:\"val_\";}set_partial(val,context){return this.cannotSet(\"DObject.set_partial()\");}get_partial(context){var _context$proxyObject$3;return context.data.instanceof?(_context$proxyObject$3=context.proxyObject.instanceof)===null||_context$proxyObject$3===void 0?void 0:_context$proxyObject$3.partial:true;}/*    protected set_abstract(val: string, context: Context): boolean { return this.cannotSet(\"abstract\"); }\r\n        protected get_abstract(context: Context): LClass[\"abstract\"] { return context.proxyObject.instanceof.abstract; }\r\n        protected set_interface(val: string, context: Context): boolean { return this.cannotSet(\"interface\"); }\r\n        protected get_interface(context: Context): LClass[\"interface\"] { return context.proxyObject.instanceof.interface; }*/set_defaultValue(val,context){return this.cannotSet(\"defaultValue\");}get_defaultValue(context){return context.proxyObject.instanceof.defaultValue;}set_referencedBy(val,context){return this.wrongAccessMessage(\"referencedBy cannot be set directly. It should be updated automatically as side effect\");}get_subObjects(context){let ref_features=this.get_referenceFeatures(context,false).filter(f=>f.instanceof.containment);let shapeless_features=this.get_shapelessFeatures(context);let vals=[...ref_features.flatMap(f=>f.values).filter(val=>!!val),...shapeless_features.flatMap(f=>f.values).filter(val=>!!val&&val.className===DObject.cname)];return vals;}get_deepSubObjects(context){let alreadyparsed={};let arr=this.get_subObjects(context);while(arr.length){let next=[];for(let obj of arr){if(alreadyparsed[obj.id])continue;alreadyparsed[obj.id]=obj;next.push(...obj.subObjects);}arr=next;}return Object.values(alreadyparsed)||[];}get_referenceFeatures(context){let includeshapeless=arguments.length>1&&arguments[1]!==undefined?arguments[1]:false;return context.proxyObject.features.filter(f=>!f.instanceof?includeshapeless:f.instanceof.className===DReference.cname);}get_attributeFeatures(context){let includeshapeless=arguments.length>1&&arguments[1]!==undefined?arguments[1]:false;return context.proxyObject.features.filter(f=>!f.instanceof?includeshapeless:f.instanceof.className===DAttribute.cname);}get_shapelessFeatures(context){return context.proxyObject.features.filter(f=>!f.instanceof);}get_isRoot(context){return context.proxyObject.father.className===DModel.cname;}set_isRoot(val,context){return this.wrongAccessMessage(\"isRoot cannot be set directly, change father element instead.\");}feature(name){this.cannotCall('feature');return null;}get_feature(context){return name=>{const lObject=context.proxyObject;const features=lObject.features.filter(value=>{var _value$instanceof;return((_value$instanceof=value.instanceof)===null||_value$instanceof===void 0?void 0:_value$instanceof.name)===name;});if(features.length>0){const matchedFeature=features[0];switch(matchedFeature.values.length){case 0:return'';case 1:return matchedFeature.value;default:return matchedFeature.values;}}return'';};}generateEcoreJson_impl(context){let loopDetectionObj=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};loopDetectionObj[context.data.id]=context.data;let asEcoreRoot=context.proxyObject.isRoot;// todo: actually use this loopdetectionobj\nconst json={};if(asEcoreRoot){console.log(\"generate object ecore\",{context,asEcoreRoot,json});const lc=context.proxyObject.instanceof;json[ECorePackage.xmiversion]='2.0';json[ECorePackage.xmlnsxmi]='http://www.omg.org/XMI';// json[ECorePackage.xmlnsxsi] = 'http://www.w3.org/2001/XMLSchema-instance';\njson[\"xmlns:\"+(lc?lc.father.uri+\".\"+lc.father.name:\"shapeless.model.uri\")]='http://www.eclipse.org/emf/2002/Ecore';}let features=context.proxyObject.features||[];console.log(\"features\",{features});for(let f of features){if(!f)continue;let meta=f.instanceof;if(meta===null||meta===void 0?void 0:meta.volatile){continue;}!json[f.name]&&(json[f.name]=f.generateEcoreJson(loopDetectionObj));}return json;}addValue(name,instanceoff,value,isMirage){return this.cannotCall(\"addValue\");}get_addValue(context){return(name,instanceoff,value,isMirage)=>{return LPointerTargetable.fromD(DValue.new(name,instanceoff,value,context.data.id,true,isMirage));};}get_namespace(context){return context.data.instanceof?context.proxyObject.instanceof.father.prefix:\"schemaless\";}get_uri(context){if(!context.data.instanceof)return\"schemaless\";let pkg=context.proxyObject.instanceof.father;return pkg.uri;// + \".\" + pkg.name;\n}// protected get_namespace(context: Context): string { if (!context.data.instanceof) return \"schemaless\"; return context.proxyObject.instanceof.namespace; }\nget_children_idlist(context){return[...super.get_children_idlist(context),...context.data.features];}get_instanceof(context){const pointer=context.data.instanceof;return pointer&&LPointerTargetable.from(pointer);}set_instanceof(val,context){const metaptr=Pointers.from(val);this._removeConformity(context);SetFieldAction.new(context.data.id,\"instanceof\",metaptr,undefined,true);// update father's collections (pointedby's here are set automatically)\nmetaptr&&SetFieldAction.new(metaptr,\"instances\",context.data.id,'+=',true);if(metaptr)this._forceConformity(context,metaptr);return true;}forceConformity(context,meta){let oldinstanceof=context.data.instanceof;// context.data.instanceof = meta;\nlet ret=this._forceConformity(context,meta);// context.data.instanceof = oldinstanceof;\nreturn ret;}_forceConformity(context,meta){let lmeta=meta&&LPointerTargetable.wrap(meta);if(!lmeta)return;let attrs=lmeta.allAttributes;let refs=lmeta.allReferences;let values=context.proxyObject.allChildren;let idmap={};for(let a of attrs){idmap[a.id]=a;}for(let a of refs){idmap[a.id]=a;}console.log({idmap,values,data:context.data,l:context.proxyObject});// damiano: todo quando viene cancellato una feature il puntatore in features e values rimane. use pointedby's\n// then remove attributes and references that are already instantiated in the object\nfor(let v of values){if(v&&v.__raw.instanceof)delete idmap[v.__raw.instanceof];}console.log(\"forceconformity\",{attrs,refs,valuesPre:values.map(v=>v&&v.__raw.instanceof),toadd:idmap});for(let id in idmap){// let l = idmap[id];\ncontext.proxyObject.addValue(undefined,id,[],true);}}_removeConformity(context){let childs=context.proxyObject.features;for(let child of childs)if(child.isMirage)child.delete();}get_delete(context){return()=>{let c=this.get_instanceof(context);if(c&&c.isSingleton){Log.ww('Object is a singleton and cannot be removed, remove his singleton flag in m2 first.',context.data);return;}console.log('test 0');super.get_delete(context)();};}get_features(context){return this.get_children(context);// return context.data.features.map((feature) => { return LPointerTargetable.from(feature) });\n}ecorePointer(){return this.cannotCall(\"ecorePointer\");}get_ecorePointer(context){let lastvisited=context.data.id;return()=>\"@//\"+this.get_fatherList(context).map(f=>{if(f.className===DObject.cname){lastvisited=f.id;return'';}if(f.className===DModel.cname){return'';}console.log(\"get_ecorepointer\",f,f.__raw,lastvisited);return f.name+\".\"+f.__raw.values.indexOf(lastvisited);}).filter(v=>!!v).join(\"@/\");}},_class86.subclasses=[],_class86._extends=[],_class86))||_class85);RuntimeAccessibleClass.set_extend(DNamedElement,DObject);RuntimeAccessibleClass.set_extend(LNamedElement,LObject);export let DValue=(_dec45=RuntimeAccessible('DValue'),Leaf(_class87=_dec45(_class87=(_class88=class DValue extends DModelElement{constructor(){super(...arguments);this.id=void 0;this.parent=[];this.father=void 0;this.annotations=[];this.name=void 0;this.values=[];this.instanceof=void 0;this.edges=void 0;this.isMirage=void 0;this.allowCrossReference=void 0;this.topic='';}// extends DModelElement, m1 value (attribute | reference)\n// static singleton: LValue;\n// static logic: typeof LModelElement;\n// static structure: typeof DValue;\n// inherit redefine\n// nome opzionale solo per modelli schema-less\n// personal\n// value: PrimitiveType | Pointer<DObject, 1, 1, LObject>; // vv4\n// values: PrimitiveType[] | Pointer<DObject, 1, 'N', LObject> | Pointer<DEnumLiteral, 1, 'N', LEnumLiteral> = []; // vv4\n// todo: maybe min lowerbound 0 if you want to allow free shape objects chiedere prof\n// conformsTo!: Pointer<DStructuralFeature, 0, 'N', LStructuralFeature>; // low priority to do: attributo fittizio controlla a quali elementi m2 è conforme quando viene richiesto\n// IoT Section\nstatic new(name,instanceoff,val,father){let persist=arguments.length>4&&arguments[4]!==undefined?arguments[4]:true;let isMirage=arguments.length>5&&arguments[5]!==undefined?arguments[5]:false;if(!name)name=this.defaultname(\"property_\",father);return new Constructors(new DValue('dwc'),typeof father===\"string\"?father:father===null||father===void 0?void 0:father.id,persist,undefined).DPointerTargetable().DModelElement().DNamedElement(name).DValue(instanceoff,val,isMirage).end();}static new3(a,then){let persist=arguments.length>2&&arguments[2]!==undefined?arguments[2]:true;if(!a.name)a.name=this.defaultname(\"property_\",a.father);return new Constructors(new DValue('dwc'),a.father,persist,undefined,a.id).DPointerTargetable().DModelElement().DNamedElement(a.name).DValue(a.instanceof,a.values).end(then);}},_class88.subclasses=[],_class88._extends=[],_class88))||_class87)||_class87);export let LValue=(_dec46=RuntimeAccessible('LValue'),_dec46(_class89=(_class90=class LValue extends LModelElement{constructor(){super(...arguments);this.__raw=void 0;this.id=void 0;this.parent=void 0;this.father=void 0;this.model=void 0;this.name=void 0;this.namespace=void 0;this.fullname=void 0;this.type=void 0;this.primitiveType=void 0;this.classType=void 0;this.enumType=void 0;this.ordered=void 0;this.unique=void 0;this.lowerBound=void 0;this.upperBound=void 0;this.many=void 0;this.required=void 0;this.allowCrossReference=void 0;this.changeable=void 0;this.volatile=void 0;this.transient=void 0;this.unsettable=void 0;this.derived=void 0;this.derived_read=void 0;this.derived_write=void 0;this.__info_of__derived={type:'string',txt:'A ECore flag to signal the values of this feature depend on other features.\\n'+'To make it usable at runtime in jjodel check derived_read and derived_write.'};this.__info_of__derived_read={type:'string',txt:'A function in string format with 2 or less attributes: (data, oldValue).\\n'+'- data is the LValue hosting this derived feature\\n'+'- originalValues are the current **non-derived** values actually memorized in the data.values\\n'+'The mandatory return value of this function will be returned when attempted to read data.values.'};this.__info_of__derived_write={type:'string',txt:'A function in string format with 3 or less attributes: (value, data, oldValue).\\n'+'- value is the value currently attempted to be set, which triggered the function call.\\n'+'- data is the LValue hosting this derived feature\\n'+'- originalValues are the current **non-derived** values actually memorized in the data.values\\n'+'The optional return value of this function will be stored inside data, allowing for hybrid dependency-persistant features'+'\\n or for a feature \"depending on itself\". like uppercasing his values before setting them.'};this.defaultValue=void 0;this.edges=void 0;this.topic=void 0;this.value=void 0;this.isMirage=void 0;this.values=void 0;this.instanceof=void 0;this.conformsTo=void 0;this.length=void 0;this.__info_of__length={type:'number',txt:\"shortcut for data.values.length.\"};this.container=void 0;this.opposite=void 0;this.containment=void 0;this.aggregation=void 0;this.composition=void 0;this.upperbound=void 0;this.lowerbound=void 0;this.__info_of__add={type:\"(...val: any|any[]) => void\",txt:\"Adds a value in the current value collection\"};this.__info_of__remove={type:\"(...val: any) => void\",txt:\"Deletes a value in the current value collection, or none if the element is not found.\"};this.__info_of__removeByIndex={type:\"(...indices: number) => removed[]\",txt:\"Deletes a value in the current value collection, or none if the element is not found.\"};this.__info_of__instantiableClasses={type:\"(o?: object, loose?: boolean) => LClass[]\",txt:\"List of all subclasses of the specified type, which can be used as reference values.\"+\"\\n<br>Abstract and Interface classes are excluded.\"+\"\\n<br>If the parameter \\\"o\\\" is specified, it will filter only the instances conforming to the object schema.\"+\"\\n<br>Results are sorted from tightest fit to loosest fit.\"+\"\\n<br>loose parameter set to true makes return instead a list of matching scores of all subclasses.\",hidden:true};this.__info_of__addObject={type:\"(json: object, instanceof?: LClass | string | null) => LObject\",txt:\"Appends an object instancing \\\"instanceof\\\" to the values.\\n<br>Setting his own properties, and DValues according to the content of the parameter object.\\n<br>\"+\"If instanceof is:<ul><li><b>a class or a class name</b>, it will instance that class, or a valid non-abstract subclass.\"+\"\\n<br/><b>null</b>, it will instantiate a shapeless object.\"+\"\\n<br/><b>undefined or missing</b>, it will first try to find a valid type in m2 or fail.</ul\"};this.typeStr=void 0;this.typeString=void 0;this.__info_of__typeStr={type:ShortAttribETypes.EString,txt:/*#__PURE__*/_jsxs(\"div\",{children:[\"Alias of\",/*#__PURE__*/_jsx(\"i\",{children:\"this.typeString\"})]})};this.__info_of__typeString={type:ShortAttribETypes.EString,txt:/*#__PURE__*/_jsxs(\"div\",{children:[\"Stringified version of \",/*#__PURE__*/_jsx(\"i\",{children:\"this.type\"})]})};this.validTargetOptions=void 0;this.validTargetsJSX=void 0;this.validTargets=void 0;}// extends DModelElement, m1 value (attribute | reference)\n// inherit redefine\n// from namedelement\n// Classifiers describing PrimitiveTypes or the classes that can be pointed.\n// from structuralfeature (ref + attr)\n/*protected */ /*protected */ /*protected*/ /*protected*/ /*protected*/ // defaultValueLiteral!: string;\n// target!: LClass[]; is value[]\n// IoT Section\n// personal\n// value!: PrimitiveType | LObject;\n// low priority to do: attributo fittizio controlla a quali elementi m2 è conforme quando viene richiesto\nget_length(c){return this.get_values(c).length;}set___readonly(val,c){val=!!val;if(val===c.data.__readonly)return true;super.set___readonly(val,c);let lref=this.get_instanceof(c);if(!lref)return true;let dref=lref.__raw;if(dref.composition||dref.aggregation)for(let v0 of this.get_values(c)){if(!v0)continue;let v=v0;if(v.__isproxy)v.__readonly=val;}return true;}get_toPrimitive(c){return()=>this.get_value(c);}// from reference\n// if DRef have opposite DRef, when you set a value ref you also set a opposite value ref from target to this src. they are always mirroring.\n_defaultGetter(c,k){var _this$get_instanceof,_this$get_instanceof2;if(k in c.data||typeof k===\"symbol\")return this.__defaultGetter(c,k);// get from values\nif(typeof k===\"number\")return this.get_values(c)[k];if(TargetableProxyHandler.childKeys[k[0]]){k=k.substring(1);let vals=this.get_values(c);for(let v of vals){if(!v)continue;let ret=v[k];if(ret!==undefined)return ret;}}// get from meta\nlet getk='get_'+k;if(k in LReference.singleton||getk in LReference.singleton)return(_this$get_instanceof=this.get_instanceof(c))===null||_this$get_instanceof===void 0?void 0:_this$get_instanceof[k];if(k in LAttribute.singleton||getk in LAttribute.singleton)return(_this$get_instanceof2=this.get_instanceof(c))===null||_this$get_instanceof2===void 0?void 0:_this$get_instanceof2[k];return this.__defaultGetter(c,k);}_defaultSetter(v,c,k){//\nif(super._setterFor$stuff_canReturnFalse(v,c,k))return true;// try setter for data.$feature = value; shortcut for data.$feature.value = value;\nthis.__defaultSetter(v,c,k);return true;}get_derived(c){return this.get_instanceof(c).derived;}get_derived_read(c){return this.get_instanceof(c).derived_read;}get_derived_write(c){return this.get_instanceof(c).derived_write;}set_derived(val,context){return this.cannotSet('LValue.derived');}set_derived_read(val,context){return this.cannotSet('LValue.derived_read');}set_derived_write(val,context){return this.cannotSet('LValue.derived_write');}add(){return this.cannotCall(\"LValue.add\");}get_add(c){var _this8=this;return function(){for(var _len4=arguments.length,val=new Array(_len4),_key4=0;_key4<_len4;_key4++){val[_key4]=arguments[_key4];}_this8.set_values([...c.data.values,...val.map(v=>(v===null||v===void 0?void 0:v.id)||v)],c);};}remove(){return this.cannotCall(\"LValue.remove\");}get_remove(c){var _this9=this;return function(){for(var _len5=arguments.length,val=new Array(_len5),_key5=0;_key5<_len5;_key5++){val[_key5]=arguments[_key5];}val=val.map(v=>(v===null||v===void 0?void 0:v.id)||v);let indices=[];let values=c.data.values;for(let i=0;i<values.length;i++){if(val.includes(values[i]))indices.push(i);}_this9.get_removeByIndex(c)(...indices);};}removeByIndex(){return this.cannotCall(\"LValue.removeByIndex\");}get_removeByIndex(c){var _this10=this;return function(){for(var _len6=arguments.length,indices=new Array(_len6),_key6=0;_key6<_len6;_key6++){indices[_key6]=arguments[_key6];}// reducer is ill-typed, so must force typings\nconst indexMap=indices.reduce((accumulator,currentValue)=>{accumulator[currentValue]=true;return accumulator;},{});_this10.set_values(c.data.values.filter((v,index)=>!indexMap[index]),c);// this.set_values(c.data.values.filter((v,index) => indices.includes(index)));\n};}instantiableClasses(o){let loose=arguments.length>1&&arguments[1]!==undefined?arguments[1]:false;return this.cannotCall(\"instantiableClasses\");}// warning: this can be called through model, c.data might be either a value or a model.\nget_instantiableClasses(c){var _this11=this;return function(o){let loose=arguments.length>1&&arguments[1]!==undefined?arguments[1]:false;return LValue.getInstantiableClasses(_this11,c,o,loose);};}// @eligibleClasses: search only between those targets.\n// @favoritematch: if this class is a valid match, it is given topmost priority regardless of tightness of excess features over the schema.\n// if a class name actually starts with $ character, it needs to be placed twice to get a match, as in class.$$name\nstatic getInstantiableClasses(thiss,c,schema){let loose=arguments.length>3&&arguments[3]!==undefined?arguments[3]:false;let eligibleClasses=arguments.length>4?arguments[4]:undefined;let favoriteMatch=arguments.length>5?arguments[5]:undefined;// find eligible classes\nlet isDValue=c.data.className===\"DValue\";let isDModel=c.data.className===\"DModel\";let isShapeless=!c.data.instanceof;let type=isShapeless||!isDValue?undefined:thiss.get_type(c);let isReference=!!type&&type.className===\"DClass\";if(isDValue&&!isReference&&!isShapeless)return[];// case DValue<Attribute>\nif(!eligibleClasses){if(isReference&&!isShapeless){eligibleClasses=[type,...type.allSubClasses];}// @ts-ignore\nelse{var _thiss$get_model$inst;eligibleClasses=((_thiss$get_model$inst=thiss.get_model(c).instanceof)===null||_thiss$get_model$inst===void 0?void 0:_thiss$get_model$inst.classes)||[];}}let scoreMap={};for(let c of eligibleClasses){let raw=c.__raw;let instantiable=!(raw.abstract||raw.interface||raw.isSingleton);// if (!loose && instantiable) return false;\nif(scoreMap[raw.id])continue;else scoreMap[raw.id]={class:c,instantiable,isPartial:raw.partial};}if(schema){// const fix$ = (vals: string[]) => vals.map(v=> (TargetableProxyHandler.childKeys[k[0]]) ? v.substring(1) : v);\nconst fix$=obj=>{let ret={};for(let k in obj){let k1=TargetableProxyHandler.childKeys[k[0]]?k.substring(1):k;ret[k1]=obj[k];}return ret;};schema=fix$(schema);let keys=Object.keys(schema);for(let ptr in scoreMap){let score=scoreMap[ptr];score.namesMap=U.objectFromArrayValues(score.class.childNames);let diff=U.objdiff(score.namesMap,schema);console.log(\"objDiff\",{schema,names:score.namesMap,data:score.class});score.id=ptr;score.excessFeatures=diff.removed;score.missingFeatures=diff.added;score.matchingFeatures={...diff.changed,...diff.unchanged};score.excessFeaturesCount=Object.keys(score.excessFeatures).length;score.missingFeaturesCount=Object.keys(score.missingFeatures).length;score.matchingFeaturesCount=Object.keys(score.matchingFeatures).length;score.score=Math.round(((score.instantiable?0:-1)+(keys.length?score.matchingFeaturesCount/keys.length:1))*100)/100;}}let sorted=Object.values(scoreMap);if(!loose)sorted=sorted.filter(s=>s.instantiable&&(!s.missingFeaturesCount||s.isPartial));let favoriteMatchID=favoriteMatch===null||favoriteMatch===void 0?void 0:favoriteMatch.id;sorted=sorted.sort((a,b)=>{// return negative if a is less than b, positive if a is greater than b, and zero if they are equal.\n// but since default order is ascending and i want descending, o reverse it.\nif(a.instantiable&&!b.instantiable)return-1;if(!a.instantiable&&b.instantiable)return+1;if(a.missingFeaturesCount===0&&b.missingFeaturesCount===0){// >100% match case (might have excess, take tighter)\n// nly if they are both valid full matches, explicit preference takes precedence. then tightness.\nif(a.id===favoriteMatchID)return-1;if(b.id===favoriteMatchID)return+1;if(a.matchingFeaturesCount!==b.matchingFeaturesCount)return-a.matchingFeaturesCount+b.matchingFeaturesCount;if(a.excessFeaturesCount!==b.excessFeaturesCount)return+a.excessFeaturesCount-b.excessFeaturesCount;}// <99% match, but might be valid for partial classes.\nif(a.isPartial&&!b.isPartial)return-1;if(!a.isPartial&&b.isPartial)return+1;if(a.isPartial&&b.isPartial){// only if they are both valid partial matches, explicit preference takes precedence. then tightness.\nif(a.id===favoriteMatchID)return-1;if(b.id===favoriteMatchID)return+1;}// if both partials or none is partial\n// if (a.missingFeaturesCount !== b.missingFeaturesCount) return -a.missingFeaturesCount + b.missingFeaturesCount; should be same as matchingFeaturesCount\nif(a.matchingFeaturesCount!==b.matchingFeaturesCount)return-a.matchingFeaturesCount+b.matchingFeaturesCount;if(a.excessFeaturesCount!==b.excessFeaturesCount)return+a.excessFeaturesCount-b.excessFeaturesCount;return 0;});if(loose)return sorted;return sorted.map(score=>score.class);}addObject(json){let metaclass=arguments.length>1&&arguments[1]!==undefined?arguments[1]:undefined;return this.cannotCall(\"LValue.addObject\");}// warning: this can be called through model, c.data might be either a value or a model.\n/*\r\n    @param metaclass: null means \"shapeless\", undefined means automatic or failure, never shapeless.\r\n    type assignment priority:\r\n    1) by explicit type argument\r\n    1.1) treating it as a pointer\r\n    1.2) treating it as a $class_name\r\n    1.3) treating it as a DClass\r\n*/get_addObject(c){var _this12=this;return function(){let json=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};let metaclass=arguments.length>1&&arguments[1]!==undefined?arguments[1]:undefined;let forceCreation=arguments.length>2&&arguments[2]!==undefined?arguments[2]:false;let lobj=undefined;let father='';let isDValue=c.data.className===\"DValue\";let isDModel=c.data.className===\"DModel\";TRANSACTION(()=>{let instanceoff=isDValue?_this12.get_instanceof(c):undefined;let dinstanceoff=instanceoff&&instanceoff.__raw;// let ShapelessObjectID =\nlet isShapeless=!dinstanceoff;// || dinstanceoff && ((dinstanceoff?.id | dinstanceoff) === ShapelessObjectID);\nlet isReference=!!(dinstanceoff&&dinstanceoff.className===\"DReference\");if(isDValue&&!isReference&&!isShapeless)return Log.ee(\"cannot call addObject() on a DValue implementing an attribute\",{dinstanceoff,thiss:c.data});let isContainment=isDValue&&_this12.get_containment(c)||isDModel;// if (metaclass === undefined) metaclass = \"object\"; // in this case, i first check if a class \"object\" exist, then make a shapeless object if not.\nlet state=store.getState();father=isContainment?c.data.id:_this12.get_model(c).id;let constructorPointers={...json,father};// if undefined = explicitly told to make it shapeless. if null, it's automatic selectyion by value.type or m2-model classes.\n//console.log('Object.new3', {metaclass, forceCreation, json});\nif(metaclass!==null){let lmetaclass;// find instance schema: 1) by explicit type argument\nif(metaclass){// find instance schema: 1.1) by pointer AND 1.3) by Dclass\nlmetaclass=LPointerTargetable.from(metaclass,state);// find instance schema: 1.2) by $class_name\nif((!lmetaclass||lmetaclass.className!==\"DClass\")&&typeof metaclass===\"string\"){var _c$proxyObject$model,_c$proxyObject$model$;let m2classes=(_c$proxyObject$model=c.proxyObject.model)===null||_c$proxyObject$model===void 0?void 0:(_c$proxyObject$model$=_c$proxyObject$model.instanceof)===null||_c$proxyObject$model$===void 0?void 0:_c$proxyObject$model$.classes;if(m2classes)lmetaclass=LPointerTargetable.from(m2classes[\"$\"+metaclass]||m2classes[metaclass],state);// if (!lmetaclass && typeof metaclass === \"string\" && metaclass.toLowerCase() === \"object\") lmetaclass = undefined;\n}//(window as any).debugg = LValue.getInstantiableClasses(this, c, json, true, lmetaclass ? [lmetaclass, ...lmetaclass.allSubClasses] : []);\n// check if metaclass is found\nif(!lmetaclass||lmetaclass.className!==\"DClass\")return Log.ee(\"provided schema type does not belong to a Class, cannot intantiate.\",{lmetaclass,schema:metaclass,this:c.data});// check if metaclass is valid (instantiable in the callee collection: .values or .objects)\n// console.log(\"isExtending\", {lmetaclass, type: isDValue && this.get_type?.(c as any)});\nif(isDValue&&!lmetaclass.isExtending(_this12.get_type(c)))return Log.ee(\"provided schema type does not extend this.type, cannot intantiate.\",{lmetaclass,schema:metaclass,this:c.data});}// find instance schema: 2) by dvalue.type\nelse if(isDValue&&!isShapeless){lmetaclass=_this12.get_type(c);}// phase 2: using lmetaclass (if found), i set constructorPointers.instanceof\n// if requested type is found. but might be abstract, so i filter the best subclass match\nif(lmetaclass){if(forceCreation&&metaclass){constructorPointers.instanceof=typeof metaclass==='string'?metaclass:metaclass.id;}else{constructorPointers.instanceof=LValue.getInstantiableClasses(_this12,c,json,false,[lmetaclass,...lmetaclass.allSubClasses],lmetaclass)[0];// actually a L-class, but \"ObjectPointers\" can accept them too.\n}if(!constructorPointers.instanceof){var _lmetaclass;// the whole if is just printing error.\nlet matches=LValue.getInstantiableClasses(_this12,c,json,true,[lmetaclass,...lmetaclass.allSubClasses]);if((_lmetaclass=lmetaclass)===null||_lmetaclass===void 0?void 0:_lmetaclass.isSingleton)Log.ee(\"addObject(schema) cannot instantiate \"+metaclass+\" because it is a singleton.\",{json,matches,this:c.data});return Log.ee(\"addObject(schema) could not find a valid subtype of \"+metaclass+\" conforming ot that schema to instantiate an object.\\n\"+(matches.length?\"closest match was: \"+matches[0].name:\"\"),{json,matches,this:c.data});}}// if not found, i look among all m2classes\nelse if(!isDValue||isShapeless){// if shapelessvalue.addObject() --> infer schema from json keys and ref sub-types best match\n// if model.addObject() --> find best match within all classes\nwindow.debugg=_this12.get_model(c).instantiableClasses(json,true);constructorPointers.instanceof=_this12.get_model(c).instantiableClasses(json,false)[0];// actually a L-class, but \"ObjectPointers\" can accept them too.\nif(!constructorPointers.instanceof){var _matches$;// the whole if is just printing error.\nlet matches=isDValue?_this12.get_instantiableClasses(c)(json,true):_this12.get_model(c).instantiableClasses(json,true);let type=isDValue?_this12.get_type(c):undefined;return Log.ee(\"LValue.addObject(schema) could not find a valid \"+(c.data.className===\"DValue\"?\"subtype of \"+type.name:\"type\")+\" conforming ot that schema to instantiate an object.\\n\"+(matches.length?\"closest match was: \"+((_matches$=matches[0])===null||_matches$===void 0?void 0:_matches$.class.name):\"\"),{json,type,matches,thiss:c.data});}}if(!constructorPointers.instanceof&&isDValue&&!isShapeless){var _instanceoff$type;return Log.ee(\"could not find an instantiable subtype for given schema and type \"+(instanceoff===null||instanceoff===void 0?void 0:(_instanceoff$type=instanceoff.type)===null||_instanceoff$type===void 0?void 0:_instanceoff$type.name),{schema:json,type:instanceoff===null||instanceoff===void 0?void 0:instanceoff.type});}}// both dmodel.objects nad dvalue.values are updated by the Constructors by passing father parameter.\n// phase 3: create object according to schema (or shapeless) and update parent container collection.\nconsole.log(\"Object.new3\",{constructorPointers});if(!constructorPointers.name&&constructorPointers.instanceof){let meta=L.from(constructorPointers.instanceof);if(meta.isSingleton){constructorPointers.name=meta.name;}}let dobj=DObject.new3(constructorPointers,()=>{},isDModel?DModel:DValue,true);if(isReference&&!isContainment){// if is ref containment, object.father is set to value, which also appends the object to this.values\n// if it's model, object.father = model, and it goes in model.objects and not in values.\n// if it's non-containment value, it goes in model but also appended to this.values\n// ? if schemaless acts like a containment ref so still fine ?\n_this12.set_values([...c.data.values,dobj.id],c);}// phase 4: set sub-DDalues.values according to json data provided, or create them if they were missing in partial class match.\nlobj=LPointerTargetable.fromD(dobj);let dobjkeys=Object.keys(dobj);// update lmetaclass from candidate root, to selected instance (sub-type)\nlet lmetaclass=constructorPointers.instanceof&&LPointerTargetable.wrap(constructorPointers.instanceof);let isPartial=!!(lmetaclass===null||lmetaclass===void 0?void 0:lmetaclass.partial);let childnames=lmetaclass?U.objectFromArrayValues(lmetaclass.childNames):{};// because at current time Constructor.setPtr actions are not executed yet. so dobject.features is empty, even through LPoint.from(valueid) canaccess the \"pending\" local dvalue not in store.\nsetTimeout(()=>TRANSACTION(()=>{for(let key in json){if(TargetableProxyHandler.childKeys[key[0]]){// if $ is prepended, priority is first and only child values check\nif(key in childnames){// if child dvalue with that name including char $ exist, like in \"$\" + \"$name\"\nlobj[\"$\"+key].values=json[key];continue;}let key1=key.substring(1);if(key1 in childnames){// if child dvalue with that name excluding char $ exist, like in \"$\" + \"name\" (as normal)\nlobj[\"$\"+key1].values=json[key];continue;}// if child dvalue with that name do not exist\nif(isShapeless||isPartial){lobj.addValue(key,undefined,json[key],false);continue;}// this should never happen, if there is a mismatch in finding the correct type conforming to the schema, the function should have already stopped and returned before.\nLog.eDevv('addObject(schema) error: cannot find value collection named \"'+key+' \" as defined in the schema parameter.',{lmetaclass,this:c.data,instanceof:constructorPointers.instanceof});continue;}// if $ is NOT prepended, priority is inverted: first DObject properties, then child values\nif(key in dobjkeys){lobj[key]=json[key];continue;}else{// redoing the whole childmatch attempt for shaped and shapeless, when first char is not $, as a fallback.\nif(key in childnames){// if child dvalue with that name excluding char $ exist, like in \"$\" + \"name\" (as normal)\nconsole.log(\"get_addObject() adding values\",{lobj,key,json,childnames,d:constructorPointers.instanceof});lobj[\"$\"+key].values=json[key];continue;}else if(isShapeless||isPartial){lobj.addValue(key,undefined,json[key],false);continue;}Log.eDevv('addObject(schema) error: cannot find value collection named \"'+key+' \" as defined in the schema parameter.',{lmetaclass,this:c.data,instanceof:constructorPointers.instanceof,dobjkeys});continue;}}}),100);});return lobj;};}get_edges(context){return LPointerTargetable.fromPointer(context.data.edges)||[];}get_fromlfeature(meta,key){return meta?meta[key]:undefined;}get_opposite(context){return this.get_fromlfeature(context.proxyObject.instanceof,\"opposite\");}get_container(context){return this.get_fromlfeature(context.proxyObject.instanceof,\"container\");}get_isContainment(c){return this.get_containment(c);}get_containment(context){let iof=context.proxyObject.instanceof;if(!iof)return true;// shapeless\nreturn this.get_fromlfeature(iof,\"containment\");}// protected get_defaultValueLiteral(context: Context): LStructuralFeature[\"defaultValueLiteral\"] { return this.get_fromlfeature(context.proxyObject.instanceof, \"defaultValueLiteral\"); }\nget_defaultValue(context){return this.get_fromlfeature(context.proxyObject.instanceof,\"defaultValue\");}get_defaultderived(context){return this.get_fromlfeature(context.proxyObject.instanceof,\"derived\");}get_defaultunsettable(context){return this.get_fromlfeature(context.proxyObject.instanceof,\"unsettable\");}get_defaulttransient(context){return this.get_fromlfeature(context.proxyObject.instanceof,\"transient\");}get_isVolatile(c){return this.get_volatile(c);}get_volatile(context){return this.get_fromlfeature(context.proxyObject.instanceof,\"volatile\");}get_isChangeable(context){return this.get_changeable(context);}get_changeable(context){return this.get_fromlfeature(context.proxyObject.instanceof,\"changeable\");}get_isRequired(context){return this.get_required(context);}get_required(context){return this.get_fromlfeature(context.proxyObject.instanceof,\"required\");}get_isUnique(context){return this.get_unique(context);}get_unique(context){return this.get_fromlfeature(context.proxyObject.instanceof,\"unique\");}get_isMany(context){return this.get_many(context);}get_many(context){return this.get_fromlfeature(context.proxyObject.instanceof,\"many\");}get_upperBound(context){return this.get_fromlfeature(context.proxyObject.instanceof,\"upperBound\");}get_lowerBound(context){return this.get_fromlfeature(context.proxyObject.instanceof,\"lowerBound\");}get_ordered(context){return this.get_fromlfeature(context.proxyObject.instanceof,\"ordered\");}get_enumType(context){return this.get_fromlfeature(context.proxyObject.instanceof,\"enumType\");}get_classType(context){return this.get_fromlfeature(context.proxyObject.instanceof,\"classType\");}get_primitiveType(context){return this.get_fromlfeature(context.proxyObject.instanceof,\"primitiveType\");}get_type(context){return this.get_fromlfeature(context.proxyObject.instanceof,\"type\");}// protected get_fullname(context: Context): LStructuralFeature[\"fullname\"] { return this.get_fromlfeature(context.proxyObject.instanceof, \"fullname\"); }\nget_namespace(context){return this.get_fromlfeature(context.proxyObject.instanceof,\"namespace\");}get_name(context){return context.data.instanceof?this.get_fromlfeature(context.proxyObject.instanceof,\"name\"):context.data.name||'';}get_instanceof(context){const pointer=context.data.instanceof;if(!pointer)return undefined;return LPointerTargetable.from(pointer);}set_instanceof(val,context){// const list = val.map((lItem) => { return Pointers.from(lItem) });\nlet ptr=Pointers.from(val);SetFieldAction.new(context.data,'instanceof',ptr,\"\",true);return true;}get_isMirage(context){return context.data.isMirage;}set_isMirage(val,context){SetFieldAction.new(context.data,'isMirage',val,\"\",false);return true;}// derivate attribute, abstract\n// derivate attribute, abstract\nget_typeString(c){return this.get_typeStr(c);}// @ts-ignore\nget_typeStr(c){return LObject.singleton.get_typeStr.call(this,c);}// individual value getters\n// if withMetaInfo, returns a wrapper for the first non-empty value found containing his index and metainfo\nget_value(context){let namedPointers=arguments.length>1&&arguments[1]!==undefined?arguments[1]:false;let ecorePointers=arguments.length>2&&arguments[2]!==undefined?arguments[2]:false;let shapeless=arguments.length>3&&arguments[3]!==undefined?arguments[3]:false;let keepempties=arguments.length>4&&arguments[4]!==undefined?arguments[4]:true;let withmetainfo=arguments.length>5&&arguments[5]!==undefined?arguments[5]:false;return this.get_values(context,true,namedPointers,ecorePointers,shapeless,keepempties,withmetainfo,1)[0];}getValue(){let namedPointers=arguments.length>0&&arguments[0]!==undefined?arguments[0]:false;let ecorePointers=arguments.length>1&&arguments[1]!==undefined?arguments[1]:false;let shapeless=arguments.length>2&&arguments[2]!==undefined?arguments[2]:false;let keepempties=arguments.length>3&&arguments[3]!==undefined?arguments[3]:true;let withmetainfo=arguments.length>4&&arguments[4]!==undefined?arguments[4]:false;return this.cannotCall(\"getValue\");}get_getValue(context){return function(){let namedPointers=arguments.length>0&&arguments[0]!==undefined?arguments[0]:false;let ecorePointers=arguments.length>1&&arguments[1]!==undefined?arguments[1]:false;let shapeless=arguments.length>2&&arguments[2]!==undefined?arguments[2]:false;let keepempties=arguments.length>3&&arguments[3]!==undefined?arguments[3]:true;let withmetainfo=arguments.length>4&&arguments[4]!==undefined?arguments[4]:false;return LValue.prototype.get_value(context,namedPointers,ecorePointers,shapeless,keepempties,withmetainfo);};}// multiple value getters\nget_values(context){let fitSize=arguments.length>1&&arguments[1]!==undefined?arguments[1]:true;let namedPointers=arguments.length>2&&arguments[2]!==undefined?arguments[2]:false;let ecorePointers=arguments.length>3&&arguments[3]!==undefined?arguments[3]:false;let shapeless=arguments.length>4&&arguments[4]!==undefined?arguments[4]:false;let keepempties=arguments.length>5&&arguments[5]!==undefined?arguments[5]:true;let withmetainfo=arguments.length>6?arguments[6]:undefined;let maxlimit=arguments.length>7?arguments[7]:undefined;let solveLiterals=arguments.length>8&&arguments[8]!==undefined?arguments[8]:\"literal_obj\";const ldata=context.proxyObject;const ddata=context.data;let typestr=this.get_typeString(context);let ret;if(ddata.topic){/*\r\n            let value: any = store.getState()['topics'];\r\n            const path = data.topic.split('.');\r\n            for(const field of path) value = value[field];\r\n            let ret: any = [value];*/const topics=store.getState()['topics'];const val=U.extractValueFromTopic(topics,ddata.topic);ret=Array.isArray(val)?val:[val];//return ret;\n}else ret=[...ddata.values];ret.type=typestr;// 'topic';\nlet meta=shapeless?undefined:ldata.instanceof;let dmeta=meta===null||meta===void 0?void 0:meta.__raw;// if (meta && meta.className === DReference.name) ret = LPointerTargetable.fromArr(ret as DObject[]);\nif(dmeta===null||dmeta===void 0?void 0:dmeta.derived){let td=transientProperties.modelElement[dmeta.id];if(!td.derived_read){try{let txt=dmeta.derived_read||'(data, originalValues)=>{return originalValues}';// data.derived examples: '(d, o)=>3', '(ddd, ooo)=>{return 3}',\ntd.derived_read=new Function('data, originalValues','return ('+txt+')(data, originalValues)');}catch(error){Log.ee('invalid derived (get) attribute expression: '+dmeta.name,{error,derivedText:dmeta.derived_read});}if(td.derived_read)try{ret=td.derived_read(ldata,ret);if(ret===undefined)ret=[];if(!Array.isArray(ret))ret=[ret];}catch(error){Log.ee('Error during derived (get) attribute evaluation: '+dmeta.name,{error,derivedText:dmeta.derived_read});}}}ret.type=typestr;if(!Array.isArray(ret))ret=[];if(dmeta&&fitSize&&ret.length<dmeta.lowerBound&&dmeta.lowerBound>0){let times=dmeta.lowerBound-ret.length;while(times-->0)ret.push(undefined);// ret.length = meta.lowerBound; not really working for expanding, it says \"emptyx10\" or so. doing .map() only iterates \"existing\" elements. behaves like as it's smaller.\n}if(maxlimit!==undefined)ret.length=maxlimit;else if(dmeta&&fitSize&&ret.length>dmeta.upperBound&&dmeta.upperBound>=0)ret.length=dmeta.upperBound;// console.log(\"get_values sizefixed\", {fitSize, arguments, upperbound:dmeta?.upperBound, lowerbound: dmeta?.lowerBound, len: ret.length, len0: context.data.values.length});\nlet numbermax=0,numbermin=0,round=true;// ret is always an array of raw values before this point, eventually padded with lowerbound or trimmed at upperbound\nlet index=0;if(withmetainfo){ret=ret.map(r=>{return{value:r,rawValue:r,index:index++,hidden:false};});}let mapperfunc=undefined;let numbercasting=v=>{if(typeof v!==\"number\"){var _v$constructor;if(!v)v=0;else if(v===\"true\")v=1;else if(((_v$constructor=v.constructor)===null||_v$constructor===void 0?void 0:_v$constructor.name)===\"Date\")v=v.getTime();else if(typeof v===\"string\"){// console.log(\"number casting:\", v,  U.getFirstNumber(v+'', true), {numbermax, numbermin});\nv=U.getFirstNumber(v+'',!round);}else return NaN;}v=Math.min(numbermax,Math.max(numbermin,v));return round?Math.round(v):v;};switch(typestr){case\"shapeless\":let state=store.getState();mapperfunc=val=>{if(!val||typeof val!==\"string\")return val;let l=LPointerTargetable.fromPointer(val,state);if(!l)return val;if(l.className===DEnumLiteral.cname){l=l.literal;}else if(namedPointers){var _ref2,_ref2$__raw,_ref2$__raw$values;l=l.name?\"@\"+l.name:((_ref2=l[\"@\"+l.name])===null||_ref2===void 0?void 0:(_ref2$__raw=_ref2.__raw)===null||_ref2$__raw===void 0?void 0:(_ref2$__raw$values=_ref2$__raw.values)===null||_ref2$__raw$values===void 0?void 0:_ref2$__raw$values[0])||\"#\"+l.className;}else if(ecorePointers){l=l.ecorePointer();}return l;};if(withmetainfo)ret.forEach(struct=>{struct.value=mapperfunc(struct.value);});else ret=ret.map(mapperfunc);break;default:// it's a reference or enum\nlet lenum=undefined;let type=meta===null||meta===void 0?void 0:meta.type;if((type===null||type===void 0?void 0:type.className)===DEnumerator.cname){lenum=type;mapperfunc=r=>{var _lit,_lit2;if(solveLiterals===\"original\")return r;numbermin=0;numbermax=solveLiterals===\"ordinals\"?Number.POSITIVE_INFINITY:0;let lit;if(typeof r===\"string\")lit=Pointers.isPointer(r)?LPointerTargetable.fromPointer(r):lenum[\"@\"+r];else if(typeof r===\"number\")lit=lenum.ordinals[r];switch(solveLiterals){default:case\"literal_obj\":return lit;// if r was a number and a valid ordinal (found literal through him) return r. if r was a string, don't return r but lenum[\"@\"+r].ordinal\ncase\"ordinals\":return typeof r===\"number\"?lit?r:undefined:(_lit=lit)===null||_lit===void 0?void 0:_lit.ordinal;case\"literal_str\":return typeof r===\"string\"?lit?r:undefined:(_lit2=lit)===null||_lit2===void 0?void 0:_lit2.literal;}};}else if(!type.isPrimitive&&(type===null||type===void 0?void 0:type.className)===DClass.cname)mapperfunc=r=>r&&LPointerTargetable.fromPointer(r);else mapperfunc=r=>r;if(withmetainfo)ret.forEach(struct=>{struct.value=mapperfunc(struct.value);});else ret=ret.map(mapperfunc);// now ret is pointed DEnumLiteral or DObject or MetaInfoStructure<>\nif((type===null||type===void 0?void 0:type.className)===DEnumerator.cname){// replace numeric literals, mapped to literal ordinal. can happen with type switches\n/*\r\n                    if (solveLiterals) {\r\n                        mapperfunc = (lit: LEnumLiteral|number) => {\r\n                            numbermax = Number.POSITIVE_INFINITY;\r\n                            numbermin = 0;\r\n                            let ordinal = numbercasting(lit);\r\n                            return isNaN(ordinal) ? lit : (meta!.type as LEnumerator).ordinals[ordinal];\r\n                        }\r\n                        if (withmetainfo) ret.forEach((struct: ValueDetail) => { struct.value = mapperfunc(struct.value); });\r\n                        else ret = ret.map(mapperfunc);\r\n                    }*/let filterfunc=l=>{var _l$father;if(!l)return keepempties;return((_l$father=l.father)===null||_l$father===void 0?void 0:_l$father.id)===meta.type.id;};if(withmetainfo)for(let struct of ret){struct.hidden=!filterfunc(struct.value);}// && 'literal target is not of the correct type requested by metamodel'; }\nelse ret=ret.filter(filterfunc);// todo: questo comportamento implica che quando importo un literal come testo da .ecore, devo assegnargli\n//  il puntatore al suo literal se trovato, altrimenti resta val[i] di tipo string/shapeless\nif(namedPointers){mapperfunc=lit=>lit===null||lit===void 0?void 0:lit.name;if(withmetainfo)ret.forEach(struct=>{struct.value=mapperfunc(struct.value);});else ret=ret.map(mapperfunc);}break;}// is reference with assigned shape (and type) -> filter correct typed targets\nif(meta){let filterfunc=l=>{// hide values with a value that is not a pointer to correct type (but keep empties if requested)\n//let isExtending = l.instanceof?.isExtending((meta as LReference).type); // damiano: todo test & debug isextending\nlet isExtending=true;return keepempties&&!l?true:isExtending;};if(withmetainfo)for(let struct of ret){struct.hidden=!filterfunc(struct.value);}// && \"ref target is not of correct type\"; }\nelse ret=ret.filter(filterfunc);}// shaped (with m2-reference) but pointing to a shapeless object. can happen\nif(namedPointers){let mapperfunc=l=>{var _ref3,_ref3$__raw,_ref3$__raw$values;return l&&(l.name?\"@\"+l.name:((_ref3=l[\"@\"+l.name])===null||_ref3===void 0?void 0:(_ref3$__raw=_ref3.__raw)===null||_ref3$__raw===void 0?void 0:(_ref3$__raw$values=_ref3$__raw.values)===null||_ref3$__raw$values===void 0?void 0:_ref3$__raw$values[0])||\"#\"+l.className);};if(withmetainfo)ret.forEach(struct=>{struct.value=mapperfunc(struct.value);});else ret=ret.map(mapperfunc);}else if(ecorePointers&&!meta.containment){mapperfunc=lval=>lval&&lval.ecorePointer();if(withmetainfo)ret.forEach(struct=>{struct.value=mapperfunc(struct.value);});else ret=ret.map(mapperfunc);// throw new Error(\"values as EcorePointers: todo. for containment do nothing, just nest the obj. for non-containment put the ecore reference string in array vals\")\n}break;case ShortAttribETypes.EByte:numbermin=-128;numbermax=127;break;case ShortAttribETypes.EShort:numbermin=-32768;numbermax=32767;break;case ShortAttribETypes.EInt:numbermin=-2147483648;numbermax=2147483647;break;case ShortAttribETypes.ELong:numbermin=-9223372036854775808;numbermax=9223372036854775807;break;case ShortAttribETypes.EFloat:case ShortAttribETypes.EDouble:numbermin=Number.NEGATIVE_INFINITY;numbermax=Number.POSITIVE_INFINITY;round=false;break;case ShortAttribETypes.EString:case ShortAttribETypes.EDate:mapperfunc=v=>v?v+'':'';if(withmetainfo)ret.forEach(struct=>{struct.value=mapperfunc(struct.value);});else ret=ret.map(mapperfunc);break;case ShortAttribETypes.EChar:mapperfunc=v=>v?(v+'')[0]:'A';if(withmetainfo)ret.forEach(struct=>{struct.value=mapperfunc(struct.value);});else ret=ret.map(mapperfunc);break;case ShortAttribETypes.EBoolean:mapperfunc=v=>typeof v===\"boolean\"?v:U.fromBoolString(v+'',(v===null||v===void 0?void 0:v.length)>0,false);if(withmetainfo)ret.forEach(struct=>{struct.value=mapperfunc(struct.value);});else ret=ret.map(mapperfunc);break;case ShortAttribETypes.EVoid:if(withmetainfo)ret.forEach(struct=>struct.hidden=true);else ret=[];break;}// some kind of numeric type\nif(numbermax!==0){if(withmetainfo)ret.forEach(struct=>{struct.value=numbercasting(struct.value);});else ret=ret.map(numbercasting);}return ret;}getValues(){let fitSize=arguments.length>0&&arguments[0]!==undefined?arguments[0]:true;let namedPointers=arguments.length>1&&arguments[1]!==undefined?arguments[1]:false;let ecorePointers=arguments.length>2&&arguments[2]!==undefined?arguments[2]:false;let shapeless=arguments.length>3&&arguments[3]!==undefined?arguments[3]:false;let keepempties=arguments.length>4&&arguments[4]!==undefined?arguments[4]:true;let withmetainfo=arguments.length>5?arguments[5]:undefined;let maxlimit=arguments.length>6?arguments[6]:undefined;return this.cannotCall(\"getValues\");}get_getValues(context){return function(){let fitSize=arguments.length>0&&arguments[0]!==undefined?arguments[0]:true;let namedPointers=arguments.length>1&&arguments[1]!==undefined?arguments[1]:true;let ecorePointers=arguments.length>2&&arguments[2]!==undefined?arguments[2]:false;let shapeless=arguments.length>3&&arguments[3]!==undefined?arguments[3]:false;let keepempties=arguments.length>4&&arguments[4]!==undefined?arguments[4]:false;let withmetainfo=arguments.length>5&&arguments[5]!==undefined?arguments[5]:false;let limit=arguments.length>6?arguments[6]:undefined;return LValue.prototype.get_values(context,fitSize,namedPointers,ecorePointers,shapeless,keepempties,withmetainfo,limit);};}// stringified value getters\nvaluesString(keepemptyquotes){return this.cannotCall(\"valuestring\");}valuestring(keepemptyquotes){return this.cannotCall(\"valuestring\");}get_valuestring(context){return keepemptyquotes=>this.valuestring_impl(context,keepemptyquotes);}get_valuesString(context){return keepemptyquotes=>this.valuestring_impl(context,keepemptyquotes);}valuestring_impl(context,keepemptyquotes){let val=this.get_values(context,true,true,false,false,true);// console.log(\"valuestring_impl\", {val});\nlet ret;switch(val.length){case 0:ret='';break;case 1:ret=val[0];break;default:let havestrings=val.type===ShortAttribETypes.EString;let havechars=val.type===ShortAttribETypes.EChar;let havepointers=false;let haveLelements=false;for(let vall of[val[0]]){if(vall===null||vall===void 0?void 0:vall.__isProxy)haveLelements=true;/*else if (typeof vall === \"string\") { havestrings = true; havepointers = havepointers || vall.includes(\"Pointer\"); }}\r\n                     */}/*if (havepointers) {\r\n                    val = LPointerTargetable.wrapAll(val);\r\n                    haveLelements = true;\r\n                }*/ /*\r\n                if (haveLelements) {\r\n                    val = val.map( l => l && (l.name ? (\"@\" + l.name) : (\"#\" + l.className)));\r\n                }*/if(havestrings||havechars){let valstr=JSON.stringify(val);if(!keepemptyquotes)valstr=U.replaceAll(valstr,\"\\\"\\\"\",\"\");ret=valstr.substring(1,valstr.length-1);break;}else ret=val.join(', ');}return(ret===undefined||ret===null?'':ret)+'';}setValueAtPosition(index,val,info){return this.cannotCall(\"setValueAtPosition\");}// only use through setValueAtPosition\n_clearValueAtPosition(context,index,info0){let skipSettingUndefined=arguments.length>3&&arguments[3]!==undefined?arguments[3]:false;// if (!outactions) outactions = {clear:[], set:[]};\nlet info=info0||{};let oldVal=context.data.values[index];let oldTarget=typeof oldVal===\"string\"?LObject.fromPointer(oldVal):undefined;/////////////////////// if oldTarget is LObject, update his pointedBy\n// if (oldTarget) SetFieldAction.new(oldTarget, \"pointedBy\" '-=\", ... no need? reducer should do this)\n/////////////////////// if ref is containment assign oldTarget father to DModel\nif(info.isContainment===undefined){if(info.instanceof===undefined)info.instanceof=context.proxyObject.instanceof;if(info.instanceof){if(info.instanceof.className===DReference.cname){info.isContainment=info.instanceof.containment;}else info.isContainment=false;}else{info.isContainment=true;}}if(info.isContainment&&(oldTarget===null||oldTarget===void 0?void 0:oldTarget.className)===\"DObject\"){SetFieldAction.new(oldVal,\"father\",context.proxyObject.model.id,undefined,true);}if(!skipSettingUndefined)SetFieldAction.new(context.data,'values.'+index,undefined,'',info.isPtr);}get_setValueAtPosition(c){return(index,val,info0,outactions)=>{var _val;if(!outactions)outactions={clear:[],set:[],immediatefire:true};let isPtr=undefined;let lval=undefined;if(val===null)val=undefined;let oldval=c.data.values[index];if(oldval===val)return{success:false,reason:\"identical assignment\"};let tmpval_id=Pointers.from(val);if(oldval===tmpval_id)return{success:false,reason:\"identical object assignment\"};let state=store.getState();if(tmpval_id&&((_val=val)===null||_val===void 0?void 0:_val.className)){lval=LPointerTargetable.wrap(val,state);isPtr=!!(lval||Pointers.isPointer(oldval));//LPointerTargetable.wrap(oldval, state));\nval=tmpval_id;}let info=info0||{};if(isPtr===undefined)isPtr=info.isPtr===undefined?Pointers.isPointer(val)||Pointers.isPointer(oldval):info.isPtr;// set sideeffect part\nif(val!==undefined){if(isPtr){if(info.type===undefined)info.type=c.proxyObject.type;if(info.instanceof===undefined)info.instanceof=c.proxyObject.instanceof;if(info.isContainment===undefined){info.isContainment=!info.instanceof||info.instanceof.className===DReference.cname&&info.instanceof.containment;}lval=LPointerTargetable.fromPointer(val);if(!lval)return{success:false,reason:\"invalid pointer: \"+lval};// is enum\nif(lval.className===DEnumLiteral.cname){let lvale=lval;if(info.instanceof&&info.type&&lvale.father.id!==info.type.id)return{success:false,reason:\"target is not of correct literal type\"};// no need to do checks / other sideeffects other than pointedBy i think.\n}// is ref\nif(lval.className===DObject.cname){let lvalo=lval;//let lvalmeta: LClassifier | undefined = lvalo.instanceof;\n// if (info.instanceof && info.type && (!(lvalmeta as LClass)?.isExtending(info.type))) return {success: false, reason: \"target is not of correct type\"}; damiano todo: enable and implement isExtending\nif(info.fatherList===undefined)info.fatherList=c.proxyObject.fatherList;if(info.isContainment){if(info.fatherList.map(father=>father.id).includes(val))return{success:false,reason:\"cannot create a containment loop\"};// todo: in LReference.set_containment need to forbid setting to true if there is a loop\nlet oldContainer=lvalo.father;let oldContainerValue=oldContainer.className===DModel.cname?undefined:oldContainer;// detach contaied object from old parent\nif(oldContainerValue&&oldContainerValue.id!==c.data.id)outactions.clear.push(()=>{let valarr=oldContainerValue.__raw.values;for(let i=0;i<valarr.length;i++){let v=valarr[i];if(v===val)oldContainerValue.setValueAtPosition(i,undefined,undefined);}});outactions.set.push(()=>{SetFieldAction.new(val,\"father\",c.data.id,undefined,true);});}}// automatic? SetFieldAction.new(val as Pointer<DObject>, \"pointedBy\", PointedBy.fromID(c.data.id, \"values.\" + index as any), \"+=\");\n}else{var _info$instanceof;// loose checks, i can assign any primitive to any primitive (will cast on get)\nif(info.instanceof===undefined)info.instanceof=c.proxyObject.instanceof;let metatype=((_info$instanceof=info.instanceof)===null||_info$instanceof===void 0?void 0:_info$instanceof.typeToShortString())||\"shapeless\";if(typeof val===\"object\"){if(val.constructor===Date&&metatype!==\"EString\"&&metatype!==\"EDate\"&&metatype!==\"shapeless\")return{success:false,reason:\"dates can only be assigned to values of type string or Date\"};// return {success: false, reason: \"objects are not assignable except for dates\"}; maybe i allow this instead\n}}}// clear sideeffect part\noutactions.clear.push(()=>this._clearValueAtPosition(c,index,info,true));// console.log('set value index', {index, val, isPtr});\n// actual set\noutactions.set.push(()=>SetFieldAction.new(c.data,'values.'+index,val,'',isPtr));if(info.setMirage!==false)SetFieldAction.new(c.data,'isMirage',false,'',false);if(outactions.immediatefire){for(let a of outactions.clear)a();for(let a of outactions.set)a();}// todo: wrap this func and set toaster with failure message if it fails or better launch Log.w and bind toasts of different colors to Log funcs\nreturn{success:true};};}set_values(val0,c){let val=val0;let modified=false;let meta=this.get_instanceof(c);let dmeta=meta===null||meta===void 0?void 0:meta.__raw;if(dmeta===null||dmeta===void 0?void 0:dmeta.derived){let td=transientProperties.modelElement[dmeta.id];if(!td.derived_write){try{let txt=dmeta.derived_write||'(values, data, oldValues)=>{ data.values = values; }';td.derived_write=new Function('values, data, oldValues','return ('+txt+')(data, originalValues)');}catch(error){Log.ee('invalid derived (set) attribute expression: '+dmeta.name,{error,derivedText:dmeta.derived_write});}if(td.derived_write)try{TRANSACTION(()=>{var _td$derived_write;let ret=td===null||td===void 0?void 0:(_td$derived_write=td.derived_write)===null||_td$derived_write===void 0?void 0:_td$derived_write.call(td,val,c.proxyObject,c.data.values);if(ret!==undefined){val=ret;modified=true;}});}catch(error){Log.ee('Error during derived (set) attribute evaluation: '+dmeta.name,{error,derivedText:dmeta.derived_write});}}}val=Array.isArray(val0)?val0:[val0];// val.length = Math.max(val.length, c.data.values.length);\nlet isContainment=this.get_isContainment(c);if(isContainment){// remove duplicates in containment\nval=val.map(v=>(v===null||v===void 0?void 0:v.id)||v);let idmap={};val=val.filter(e=>{if(typeof e!=='string'||!idmap[e])return true;idmap[e]=true;return true;});}TRANSACTION(()=>{let outactions={clear:[],set:[],immediatefire:false};for(let i=0;i<val.length;i++){let out=this.get_setValueAtPosition(c)(i,val[i],{setMirage:false},outactions);modified=out.success||modified;// console.log('set_values', {val, i, modifiedreason:out});\n}let excess=c.data.values.length-val.length;while(excess-->0){SetFieldAction.new(c.data.id,'values',undefined,'-=',true);}for(let a of outactions.clear)a();for(let a of outactions.set)a();if(modified)c.data.isMirage&&SetFieldAction.new(c.data,'isMirage',false,'',false);});return true;// old implementation\nlet list=val;let context=c;let l=context.proxyObject;let instanceoff=l.instanceof;let isRef=!instanceoff?undefined:(instanceoff===null||instanceoff===void 0?void 0:instanceoff.className)===DReference.cname;SetFieldAction.new(context.data,'values',list,'',false);// console.log(\"pre set_values actions\", l, list, val, context);\nif(!l.instanceof||isRef&&instanceoff.containment){let i=0;for(let v0 of list){// console.log(\"loop set_value actions\", v, context.data, isRef, instanceoff, Pointers.isPointer(v));\ni++;if((isRef||instanceoff===undefined)&&Pointers.isPointer(v0)){// if shapeless obj need to check val by val\nlet v=v0;//Pointer<DObject> | Pointer<DEnumLiteral>;\n// console.log(\"loop set_value actions SET\", {v, data:context.data, isRef, instanceoff, isPtr:Pointers.isPointer(v)});\nlet lval=LPointerTargetable.fromPointer(v);let oldContainer=lval.father;SetFieldAction.new(v,\"pointedBy\",PointedBy.fromID(context.data.id,\"values.\"+i),\"+=\");SetFieldAction.new(v,\"father\",context.data.id,undefined,true);if(oldContainer.className===DModel.cname)continue;let containerValue=oldContainer;// let oldContainerValues = [...containerValue.__raw.value]; U.arrayRemoveAll(oldContainerValues, v);\nlet oldContainerValues=containerValue.__raw.values.map(va=>va===v?undefined:va);SetFieldAction.new(containerValue.id,\"values\",oldContainerValues,\"\",true);// todo: verify if works: remove val from old container\nlet oldv=context.data.values[i];// if (Pointers.isPointer(oldv)) SetFieldAction.new(context.data.id, \"contains\", U.arrayRemoveAll([...context.data.contains], oldv), '', true);\n// SetFieldAction.new(context.data.id, \"contains\", oldv as DObject[\"id\"], undefined, true);\n}}}context.data.isMirage&&SetFieldAction.new(context.data,'isMirage',false,'',false);return true;}set_value(val,c){let v=this.get_value(c,false,false,false,true,true);let val_id=(val===null||val===void 0?void 0:val.id)||val;if(Pointers.isPointer(val_id)&&c.data.values.includes(val_id)&&this.get_isContainment(c)){return true;}let r=this.get_setValueAtPosition(c)((v===null||v===void 0?void 0:v.index)||0,val_id||val);Log.e(!r.success,r.reason);return r.success;}get_crossReference(c){return this.get_allowCrossReference(c);}get_isCrossReference(c){return this.get_allowCrossReference(c);}set_crossReference(v,c){return this.set_allowCrossReference(v,c);}set_isCrossReference(v,c){return this.set_allowCrossReference(v,c);}get_allowCrossReference(c){var _c$proxyObject$instan;return c.data.instanceof?!!((_c$proxyObject$instan=c.proxyObject.instanceof)===null||_c$proxyObject$instan===void 0?void 0:_c$proxyObject$instan.allowCrossReference):true;}set_allowCrossReference(v,c){return this.cannotSet('LValue.allowCrossReference');}get_validTargetOptions(c){let opts=[];this.get_validTargets(c,opts);return opts;}get_validTargetsJSX(c){let opts=[];this.get_validTargets(c,opts);return UX.options(opts);}get_validTargets(c,out){let meta=this.get_instanceof(c);let isShapeless=!meta;let isReference=isShapeless||meta.className==='DReference';let isAttribute=isShapeless||meta.className==='DAttribute';let isCrossRef=this.get_isCrossReference(c);let freeObjects=[];let boundObjects=[];let literals=[];let isContainment=isShapeless||isReference&&meta.containment;let m1=this.get_model(c);let m2=m1.instanceof;// let map = (object: LNamedElement) => ({value:object.id, label: object.name});\nlet map=object=>{let fname=object.fullname;return{value:object.id,label:isCrossRef?fname:object.name,title:object.fullname};};if(isReference){let isContainment=this.get_containment(c);let containerObjectsID=this.get_fatherList(c).map(lm=>lm.id);let validObjects=isCrossRef?m1.allCrossSubObjects:m1.allSubObjects;if(isContainment)validObjects=validObjects.filter(obj=>!containerObjectsID.includes(obj.id));let type=meta.type;if(!isShapeless)validObjects=validObjects.filter(obj=>type.isSuperClassOf(obj.instanceof,true));// avoiding containment loops damiano todo: put this filter in set_value too\nfor(let o of validObjects){//  continue; // no self contain\nif(o.isRoot)freeObjects.push(o);else boundObjects.push(o);}if(out)out.push({label:'Free     Objects',options:freeObjects.map(map)});if(out)out.push({label:'Bound Objects',options:boundObjects.map(map)});}if(isAttribute){let enumm;if(isShapeless){if(!m2)enumm=LPointerTargetable.from(Selectors.getAllEnumerators());else enumm=isCrossRef&&m2?m2.crossEnumerators:m2.enumerators;}else{let type=meta.type;enumm=type.className==='DEnumerator'?[type]:[];}for(let e of enumm){let currLiterals=e.literals;literals.push(...currLiterals);if(out)out.push({label:'Literals of '+e.name,options:currLiterals.map(map)});}}return U.arrayMergeInPlace(freeObjects,boundObjects,literals);}generateEcoreJson_impl(c){let loopDetectionObj=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};loopDetectionObj[c.data.id]=c.data;let values=this.get_values(c,true,false,true,false,false);//, false, undefined, \"literal_str\");\ndelete values[\"type\"];let ret=[];the_loop:for(let v of values){let l=v;if(!(l===null||l===void 0?void 0:l.__isProxy)){ret.push(l);continue;}switch(l.className){case\"DOperation\":continue the_loop;case\"DEnumLiteral\":ret.push(l.generateEcoreJsonM1());break;default:ret.push(l.generateEcoreJson(loopDetectionObj));break;}}// ret = ret.filter((j: any) => (j !== undefined || j !== ''));\nreturn ret.length<=1?ret[0]:ret;}get_toString(context){return()=>this._toString(context);}_toString(context){let val=this.get_values(context,true,true,false,false,true);if(!val)return val+'';if(!Array.isArray(val))val=[val];// if (!context.proxyObject.instanceof) val = val.map( (e: GObject) => { return  e.name ? \"@\" + e.name : e; });\n// else if (context.proxyObject.instanceof?.className === DReference.name) val = val.map( (e: GObject) => { return e.name ? \"@\" + e.name : e; });\nswitch(val.length){case 0:return'';case 1:return val[0]+'';default:return val+'';}}rawValues(){super.cannotCall('rawValues');}get_rawValues(context){return this.get_getValues(context)(false,false,false,true,true,false,undefined);}get_topic(context){return context.data.topic;}set_topic(val,context){SetFieldAction.new(context.data,'topic',val,'',false);return true;}},_class90.subclasses=[],_class90._extends=[],_class90))||_class89);RuntimeAccessibleClass.set_extend(DNamedElement,DValue);RuntimeAccessibleClass.set_extend(LNamedElement,LValue);// export type WJavaObject = getWParams<LJavaObject, DJavaObject>;\nDModelElement.cname='DModelElement';LModelElement.cname='LModelElement';DAnnotationDetail.cname='DAnnotationDetail';LAnnotationDetail.cname='LAnnotationDetail';DAnnotation.cname='DAnnotation';LAnnotation.cname='LAnnotation';DNamedElement.cname='DNamedElement';LNamedElement.cname='LNamedElement';DTypedElement.cname='DTypedElement';LTypedElement.cname='LTypedElement';DClassifier.cname='DTypedElement';LClassifier.cname='LTypedElement';DPackage.cname='DPackage';LPackage.cname='LPackage';DOperation.cname='DOperation';LOperation.cname='LOperation';DParameter.cname='DParameter';LParameter.cname='LParameter';DClass.cname='DClass';LClass.cname='LClass';// ClassReferences.cname = 'ClassReferences';\nDDataType.cname='DDataType';LDataType.cname='LDataType';DStructuralFeature.cname='DStructuralFeature';LStructuralFeature.cname='LStructuralFeature';DReference.cname='DReference';LReference.cname='LReference';DAttribute.cname='DAttribute';LAttribute.cname='LAttribute';DEnumLiteral.cname='DEnumLiteral';LEnumLiteral.cname='LEnumLiteral';DModelM1.cname='DModelM1';LModelM1.cname='LModelM1';DEnumerator.cname='DEnumerator';LEnumerator.cname='LEnumerator';DModel.cname='DModel';LModel.cname='LModel';DMap.cname='DMap';LMap.cname='LMap';DObject.cname='DObject';LObject.cname='LObject';DValue.cname='DValue';LValue.cname='LValue';","map":{"version":3,"names":["UX","Abstract","BEGIN","Constructors","Debug","DPointerTargetable","END","Instantiable","Leaf","Log","LPointerTargetable","Node","PointedBy","Pointers","RuntimeAccessible","RuntimeAccessibleClass","Selectors","SetFieldAction","SetRootFieldAction","ShortAttribETypes","ShortAttribSuperTypes","store","TargetableProxyHandler","L","TRANSACTION","U","Uarr","AccessModifier","ECoreAnnotation","ECoreAttribute","ECoreClass","ECoreEnum","EcoreLiteral","ECoreOperation","ECorePackage","EcoreParser","ECoreReference","ECoreRoot","transientProperties","React","jsx","_jsx","jsxs","_jsxs","DModelElement","_dec","_class","_class2","constructor","arguments","id","parent","father","annotations","new","exx","new3","LFromHtml","target","fromPointer","PtrFromHtml","DFromHtml","attributes","dataid","value","parentElement","undefined","subclasses","_extends","DAnnotationDetail","_dec2","_class3","LModelElement","_dec3","_class4","_class5","__raw","__info_of__father","type","txt","fatherList","children","__info_of__children__","nodes","node","model","package","class","enum","operation","subNodes","property","containers","name","isM1","__info_of__isM1","isM2","__info_of__isM2","isInstantiable","instantiable","__info_of__isInstantiable","childNames","__info_of__childNames","__info_of__nodes","__info_of__node","edges","edge","__info_of__edges","__info_of__edge","notEdges","notEdge","__info_of__notEdges","__info_of__notEdge","vertexes","vertex","__info_of__vertexes","__info_of__vertex","edgePoints","edgePoint","__info_of__edgePoints","__info_of__edgePoint","graphs","graph","__info_of__graphs","__info_of__graph","fields","field","__info_of__fields","__info_of__field","_defaultGetter","c","k","targetObj","data","proxyitself","proxyObject","lchildren","get_children","e","lc","pk","childKeys","substring","Array","isArray","_lc","n","toLowerCase","__defaultGetter","_defaultSetter","val","_setterFor$stuff_canReturnFalse","l","tClassName","className","navigationloop","DPackage","cname","DClass","DEnumerator","DObject","DEnumLiteral","literal","ordinal","DValue","values","get_isM1","isMetamodel","M1Classes","includes","get_isM2","get_isInstantiable","get_instantiable","M2InstantiableClasses","get_childNames","map","filter","generateEcoreJson","loopDetectionloopDetectionObj","length","Error","get_generateEcoreJson","context","loopdetectionobj","generateEcoreJson_impl","loopDetectionObj","exDevv","duplicate","deep","cannotCall","addAnnotation","source","details","get_addAnnotation","DAnnotation","set_containers","cannotSet","get_containers","thiss","ret","push","get_namespace","get_subNodes","includingthis","lclass","$class","$","$subnodes","find","mapfunc","dataset","nodeid","nodehtmlarr","toArray","nodeidarr","html","state","getState","dnodes","idlookup","d","wrap","get_property","targetRemoved","delete","get_fatherList","loopdetection","current","get_father","console","error","get_until_parent","_l","oldd","get_nodes","_transientProperties$","Object","modelElement","get_node","_transientProperties$2","get_edges","_l$className","get_edge","_l$className2","get_notEdges","_l$className3","get_notEdge","_l$className4","get_vertexes","_l$className5","get_vertex","_l$className6","get_edgePoints","_l$className7","get_edgePoint","_l$className8","get_graphs","get_graph","get_fields","get_field","get_model","DModel","get_package","get_class","get_operation","DOperation","get_enum","from","get_children_idlist","set_children","a","add_parent","logicContext","ptr","remove_parent","get_parent","set_parent","ptrs","add_annotation","remove_annotation","indexes","indexOf","p","get_annotations","set_annotations","get_addChild","_this","_ref","_this$get_class","_this$get_class2","_this$get_enum","_this$get_class3","_this$get_operation","type0","fatherElement","ee","addPackage","packages","addClass","addEnumerator","addAttribute","addReference","addLiteral","addOperation","addParameter","get_addObject","addObject","_len","args","_key","get_addException","_context$data","dOperation","dClass","_len2","params","_key2","join","addException","exception","wrongAccessMessage","addChild","singleton","AbstractClasses","set_extend","_dec4","_class6","_class7","persist","end","LAnnotation","_dec5","_class8","_class9","__namee","json","write","get_duplicate","de","ldet","le","fromD","we","lchild","get_source","set_source","get_details","wrapAll","set_details","LAnnotationDetail","_dec6","_class10","DNamedElement","_dec7","_class12","_class13","LNamedElement","_dec8","_class14","_class15","namespace","fullname","get_fullName","get_fullname","reverse","slice","get_name","set_name","check","child","alert","_autofix_name","replaceAll","get_autofix_name","autofix_name","DTypedElement","_dec9","_class16","_class17","instances","ordered","unique","lowerBound","upperBound","many","required","LTypedElement","_dec10","_class18","_class19","primitiveType","classType","enumType","get_classType","get_type","isClass","get_enumType","isEnum","get_primitiveType","isPrimitive","set_type","get_ordered","set_ordered","get_unique","set_unique","get_lowerBound","set_lowerBound","isNaN","Math","max","get_upperBound","set_upperBound","get_many","set_many","get_required","set_required","typeToEcoreString","get_typeToEcoreString","typeEcoreString","typeToShortString","get_typeToShortString","typeString","canOverride","other","t1","t2","isExtending","DClassifier","_dec11","_class20","_class21","instanceClassName","defaultValue","LClassifier","_dec12","_class22","_class23","get_instanceClassName","set_instanceClassName","set_isPrimitive","set_isClass","set_isEnum","get_isPrimitive","get_isClass","get_isEnum","set_defaultValue","isPointer","get_typeEcoreString","classTypePrefix","get_typeString","_dec13","_class24","_class25","classifiers","subpackages","uri","prefix","fatherType","dmodel","defaultname","callback","LPackage","_dec14","_class26","_class27","classes","enums","enumerators","allSubPackages","allSubEnums","allSubClasses","operations","parameters","exceptions","references","literals","_$name","generateEcoreJson_impltemplate","classarr","enumarr","prototype","concat","call","xmiversion","xmlnsxmi","xmlnsxsi","xmlnsecore","namee","nsURI","nsPrefix","eClassifiers","get_addPackage","log","isInterface","isAbstract","isPartial","partialDefaultName","get_addClass","addEnum","get_addEnum","get_addEnumerator","get_classes","setNameKeys","dclasses","dc","lclasses","i","get_enums","get_enumerators","denums","lenums","get_allSubClasses","s","arr","get_allSubPackages","mergeNamedArray","get_allSubEnums","get_allSubEnumerators","tocheck","checked","newtocheck","dpackage","arrayMergeInPlace","darr","larr","fromArr","toNamedArray","get_classifiers","pointer","set_classifiers","list","lItem","oldList","diff","arrayDifference","added","removed","arrayRemoveAll","get_subpackages","set_subpackages","get_uri","_context$proxyObject$","set_uri","pos","lastIndexOf","get_prefix","set_prefix","_dec15","_class28","_class29","visibility","private","implementation","allowCrossReference","new2","setter","assign","LOperation","_dec16","_class30","_class31","signatureImplementation","eParameters","par","eType","eexceptions","get_addParameter","DParameter","execute","get_execute","_this2","func","eval","get_signatureImplementation","_len3","_key3","apply","set_implementation","get_implementation","set_signatureImplementation","typedComments","typedcommentpre","typedcommentpost","replace","get_signature","get_exceptions","set_exceptions","get_parameters","set_parameters","_mark","b","superchildren","override","_canOverride","_canPolymorph","_dec17","_class32","_class33","getFirstPrimitiveTypes","LParameter","_dec18","_class34","_class35","ClassReferences","features","referencedBy","extends","extendedBy","implements","implementedBy","_dec19","_class36","_class37","abstract","interface","partial","partialdefaultname","isSingleton","rootable","sealed","final","window","LClass","_dec20","_class38","_class39","__info_of__extends","extendsChain","__info_of__sealed","__info_of__final","__info_of__roootable","__info_of__singleton","__info_of__intantiable","aggregated","__info_of__aggregated","composed","__info_of__composed","contained","__info_of__contained","superclasses","__info_of__superclasses","ownAttributes","ownReferences","ownOperations","ownChildren","inheritedAttributes","inheritedReferences","inheritedOperations","inheritedChildren","allAttributes","allReferences","allOperations","allChildren","validTargetsJSX","validTargetOptions","validTargets","allExtends","__info_of__partial","allInstances","__info_of__allInstances","__info_of__isSubclassOf","__info_of__isExtending","get_validTargetsJSX","opts","get_validTargets","options","get_validTargetOptions","out","m2","dclass","extendsarr","pkgs","allCrossSubPackages","extendValue","label","opt","get_allChildren","get_sealed","set_sealed","Set","equalsUnsorted","get_isFinal","get_final","set_final","get_isSingleton","get_singleton","set_isSingleton","set_singleton","get_instances","modelsWithInstance","o","_o$model","m1","get_isComposed","get_composed","get_isAggregated","get_aggregated","get_isContained","get_contained","refs","get_referencedBy","r","aggregation","composition","get_isRootable","get_rootable","set_rootable","get_ownAttributes","LAttribute","get_ownReferences","LReference","get_ownOperations","get_ownChildren","get_allExtends","get_extendsChain","targets","alreadyParsed","nextTargets","next","isSubClassOf","superClass","returnIfSameClass","isSuperClassOf","subClass","get_isSubClassOf","_this3","subclass","get_isSuperClassOf","get_inheritedAttributes","flatMap","get_inheritedReferences","get_inheritedOperations","get_inheritedChildren","get_allAttributes","get_allReferences","get_allOperations","featurearr","operationsarr","supertypesstr","att","ref","op","xsitype","toBoolString","instanceTypeName","eSuperTypes","superclass","eStructuralFeatures","eOperations","set_partial","get_partial","set_partialdefaultname","get_partialdefaultname","get_addAttribute","DAttribute","get_addReference","DReference","get_addOperation","get_abstract","set_abstract","get_interface","set_interface","get_allInstances","sc","set_instances","get_operations","set_operations","get_features","set_features","get_references","set_references","get_attributes","set_attributes","keystr","LObject","pointedBy","index","set_referencedBy","get_extends","set_extends","invalid","invalidPtrs","reason","get_canExtend","ww","add_extends","get_add_extends","impl_add_extends","remove_extends","finalVal","elem","v","get_extendedBy","set_extendedBy","get_implements","set_implements","get_implementedBy","set_implementedBy","canExtend","output","allTargetSuperClasses","_this4","_canExtend","directly","isSubclassOf","get_isSubclassOf","plusThis","get_isExtending","_this5","get_superclasses","classe","visited","queue","_context$data$extende","ebyIDS","parsedSubclasses","stack","newstack","sid","inSealed","allowed","j","superchild","setTimeout","_isExtending","orEqual","add_Extends","force","unsetExtends","get_unsetExtends","superclassid","instance","DDataType","_dec21","_class40","_class41","serializable","LDataType","_dec22","_class42","_class43","get_serializable","set_serializable","DStructuralFeature","_dec23","_class44","_class45","changeable","volatile","transient","unsettable","derived","derived_read","derived_write","__info_of__derived","__info_of__derived_read","__info_of__derived_write","LStructuralFeature","_dec24","_class46","_class47","get_crossReference","get_allowCrossReference","get_isCrossReference","set_crossReference","set_allowCrossReference","set_isCrossReference","addClasses","addModels","addEnums","addPrimitives","addReturnTypes","isCrossRef","object","fname","title","map2","sort","validClasses","validEnums","validPrimitives","validModels","m2models","primitiveTypes","returnTypes","m","pkg","crossClasses","crossEnumerators","get_changeable","set_changeable","get_volatile","set_volatile","get_transient","set_transient","get_unsettable","set_unsettable","get_derived","set_derived","_dec25","_class48","_class49","defaultValueLiteral","container","__info_of__container","opposite","_dec26","_class50","_class51","containment","__info_of__rootable","__info_of__composition","__info_of__aggregation","lowerbound","upperbound","cont","get_containment","set_containment","mainkey","altkey","containedObjects","removedValues","parentChanges","lval","dval","lmodel","pointedobj","newid","oldparent","get_aggregation","get_composition","set_aggregation","set_composition","get_opposite","set_opposite","get_defaultValue","set_edges","has_opposite","oppositename","obsolete_attribute","_dec27","_class52","_class53","isID","isIoT","_dec28","_class54","_class55","_context$proxyObject$2","get_isID","set_isID","get_isIoT","set_isIoT","_dec29","_class56","_class57","LEnumLiteral","_dec30","_class58","_class59","generateEcoreJsonM1","get_generateEcoreJsonM1","impl_generateEcoreJsonM1","get_ordinal","get_value","set_ordinal","set_value","ordinalAssumedByPosition","ordinals","sameOrdinalLit","get_literal","set_literal","_dec31","_class60","_class61","LEnumerator","_dec32","_class62","_class63","eLiterals","get_addLiteral","get_literals","set_literals","get_ordinals","dliterals","currentOrdinal","DModelM1","_dec33","_class64","roots","LModelM1","_dec34","_class66","_dec35","_class68","_class69","objects","models","instanceof","dependencies","instanceoff","dmodels","getAll","dmodelnames","EdgeStarter","_dec36","_class70","start","sn","en","otherPossibleEnds","m1refindex","_this$startVertex","_this$endVertex","_this$endGraph","_this$startGraph","_this$startSize","_this$startVertexSize","startNode","endNode","startVertex","endVertex","startGraph","endGraph","startSize","endSize","startVertexSize","endVertexSize","otherEnds","extendTargets","sameGraph","isSameGraph","overlaps","vertexOverlaps","outerSize","root","isOverlapping","LModel","_dec37","_class72","_class73","allDependencies","__info_of__dependencies","__info_of__allDependencies","crossObjects","allSubAnnotations","allCrossSubAnnotations","allSubObjects","allCrossSubObjects","allSubValues","allCrossSubValues","suggestedEdges","__info_of__suggestedEdges","otherObjects","otherInstances","__info_of__otherObjects","__info_of__otherInstances","__info_of__instancesOf","__info_of__addObject","__info_of__instantiableClasses","hidden","packageArr","ecoreEPackage","obj","ecoreRootName","get_dependencies","get_allDependencies","iterateChildProperties","namesORDObjectsToID","namedCandidates","dnamedcandidates","dAllowedNamesMap","reduce","acc","tmp","key","_defaultGetterM1","_defaultGetterM2","subelement","deepmatch","directSubObjects","objectFromArrayValues","subobject","get_allSubObjects","get_instanceof","m2item","key1","get_instancesOf","get_otherObjects","get_otherInstances","_this6","excludeInstances","includeSubclasses","otherObjectsTemp","dict","otherObectsAccessedKeys","flat","_populateOtherObjects","dinstancetypes","namemap","idtoname","allObjects","eDevv","instancesOf","instancetypes0","_this7","instancetypes","forceCreation","LValue","instantiableClasses","loose","get_instantiableClasses","get_suggestedEdges","impl_get_suggestedEdgesM2","impl_get_suggestedEdgesM1","extend","reference","packageDependencies","lightMode","get_allSubValues","outer","inner","valindex","snode","ltarget","enode","alreadyAdded","SkipExtendNodeHidden","rootCall","eid","secondTierExtends","es","otherEdgeEnds","_es$sn","_es$sn$root","_c$root","rendered","src","ends","pkgdependencies","srcnode","ep","epnode","pd","get_models","set_models","set_instanceof","get_isMetamodel","set_isMetamodel","get_crossObjects","get_objects","includeCrossReferences","dep","get_crossPackages","get_packages","set_packages","get_crossRoots","get_roots","includeCross","get_crossClasses","crossKey","kind","meta","_getallSub","get_crossReferences","get_crossEnums","get_crossEnumerators","get_allCrossSubPackages","get_allCrossSubValues","get_allCrossSubObjects","allDeps","allDepPtrs","lmodelid","getClassByNameSpace","namespacedclass","get_getClassByNameSpace","pkguri","classname","get_getPackageByUri","getPackageByUri","get_values","DFactory_useless_","_dec38","_class74","_class75","ePackage","LFactory_useless_","_dec39","_class76","_class77","EJavaObject","_dec40","_class78","DMap","_dec41","_class79","_class80","__isDMap","LMap","_dec42","_class81","_class82","__isLMap","_dec43","_class83","_class84","then","_dec44","_class85","_class86","truechildren","deepSubObjects","subObjects","referenceFeatures","attributeFeatures","shapelessFeatures","isRoot","typeStr","__info_of__typeStr","EString","__info_of__typeString","_$name2","targeting","getPathArr","get_truechildren","childs","isMirage","pointers","conformchildren","_c$instanceof","_c$instanceof2","bymetaparent","vmeta","vmetaid","get_typeStr","_meta$typeToShortStri","set_namespace","set_fullname","set_ecoreRootName","get_ecoreRootName","_context$proxyObject$3","get_subObjects","ref_features","get_referenceFeatures","f","shapeless_features","get_shapelessFeatures","vals","get_deepSubObjects","alreadyparsed","includeshapeless","get_attributeFeatures","get_isRoot","set_isRoot","feature","get_feature","lObject","_value$instanceof","matchedFeature","asEcoreRoot","addValue","get_addValue","metaptr","_removeConformity","_forceConformity","forceConformity","oldinstanceof","lmeta","attrs","idmap","valuesPre","toadd","get_delete","ecorePointer","get_ecorePointer","lastvisited","_dec45","_class87","_class88","topic","_dec46","_class89","_class90","conformsTo","__info_of__length","__info_of__add","__info_of__remove","__info_of__removeByIndex","get_length","set___readonly","__readonly","lref","dref","v0","__isproxy","get_toPrimitive","_this$get_instanceof","_this$get_instanceof2","getk","__defaultSetter","get_derived_read","get_derived_write","set_derived_read","set_derived_write","add","get_add","_this8","_len4","_key4","set_values","remove","get_remove","_this9","_len5","_key5","indices","get_removeByIndex","removeByIndex","_this10","_len6","_key6","indexMap","accumulator","currentValue","_this11","getInstantiableClasses","schema","eligibleClasses","favoriteMatch","isDValue","isDModel","isShapeless","isReference","_thiss$get_model$inst","scoreMap","raw","fix$","k1","keys","score","namesMap","objdiff","names","excessFeatures","missingFeatures","matchingFeatures","changed","unchanged","excessFeaturesCount","missingFeaturesCount","matchingFeaturesCount","round","sorted","favoriteMatchID","metaclass","_this12","lobj","dinstanceoff","isContainment","constructorPointers","lmetaclass","_c$proxyObject$model","_c$proxyObject$model$","m2classes","this","_lmetaclass","matches","debugg","_matches$","_instanceoff$type","dobj","dobjkeys","childnames","get_fromlfeature","get_container","get_isContainment","iof","get_defaultderived","get_defaultunsettable","get_defaulttransient","get_isVolatile","get_isChangeable","get_isRequired","get_isUnique","get_isMany","get_isMirage","set_isMirage","namedPointers","ecorePointers","shapeless","keepempties","withmetainfo","getValue","get_getValue","fitSize","maxlimit","solveLiterals","ldata","ddata","typestr","topics","extractValueFromTopic","dmeta","td","Function","derivedText","times","numbermax","numbermin","rawValue","mapperfunc","numbercasting","_v$constructor","getTime","getFirstNumber","NaN","min","_ref2","_ref2$__raw","_ref2$__raw$values","forEach","struct","lenum","_lit","_lit2","Number","POSITIVE_INFINITY","lit","filterfunc","_l$father","_ref3","_ref3$__raw","_ref3$__raw$values","EByte","EShort","EInt","ELong","EFloat","EDouble","NEGATIVE_INFINITY","EDate","EChar","EBoolean","fromBoolString","EVoid","getValues","get_getValues","limit","valuesString","keepemptyquotes","valuestring","get_valuestring","valuestring_impl","get_valuesString","havestrings","havechars","havepointers","haveLelements","vall","__isProxy","valstr","JSON","stringify","setValueAtPosition","info","_clearValueAtPosition","info0","skipSettingUndefined","oldVal","oldTarget","isPtr","get_setValueAtPosition","outactions","_val","clear","set","immediatefire","oldval","success","tmpval_id","lvale","lvalo","oldContainer","oldContainerValue","valarr","_info$instanceof","metatype","Date","setMirage","val0","modified","_td$derived_write","excess","isRef","fromID","containerValue","oldContainerValues","va","oldv","val_id","_c$proxyObject$instan","isAttribute","freeObjects","boundObjects","containerObjectsID","lm","validObjects","enumm","getAllEnumerators","currLiterals","the_loop","get_toString","_toString","rawValues","get_rawValues","get_topic","set_topic"],"sources":["C:/0Programmi/Dev/projects/frontend/jjodel/src/model/logicWrapper/LModelElement.tsx"],"sourcesContent":["import {\r\n    LVoidVertex,\r\n    PackagePointers,\r\n    EdgePointers,\r\n    AnnotationPointers,\r\n    AttributePointers,\r\n    EnumPointers,\r\n    LiteralPointers,\r\n    OperationPointers,\r\n    ObjectPointers,\r\n    GraphPointers,\r\n    ParameterPointers,\r\n    ReferencePointers,\r\n    VertexPointers,\r\n    ModelPointers,\r\n    LtoD,\r\n    LVertex, LEdgePoint, LGraph, MultiSelectOptGroup, UX, Function2, Any, MultiSelectOption, windoww,\r\n} from \"../../joiner\";\r\nimport {\r\n    Abstract,\r\n    BEGIN,\r\n    ClassPointers,\r\n    Constructor,\r\n    Constructors,\r\n    Debug,\r\n    DEdge, DefaultNode,\r\n    Dictionary,\r\n    DocString,\r\n    DPointerTargetable,\r\n    DState,\r\n    DtoL,\r\n    END,\r\n    getWParams,\r\n    GObject,\r\n    GraphSize,\r\n    Instantiable,\r\n    Leaf,\r\n    LEdge,\r\n    LGraphElement,\r\n    Log,\r\n    LogicContext,\r\n    LPointerTargetable,\r\n    Node,\r\n    Pack,\r\n    Pack1,\r\n    PackArr,\r\n    PointedBy,\r\n    Pointer,\r\n    Pointers,\r\n    RuntimeAccessible,\r\n    RuntimeAccessibleClass,\r\n    Selectors,\r\n    SetFieldAction, SetRootFieldAction,\r\n    ShortAttribETypes,\r\n    ShortAttribSuperTypes,\r\n    store,\r\n    TargetableProxyHandler,\r\n    L,\r\n    TRANSACTION,\r\n    U, Uarr\r\n} from \"../../joiner\";\r\nimport type {Info, Json, ObjectWithoutPointers, orArr, PrimitiveType, unArr} from \"../../joiner/types\";\r\n\r\nimport {\r\n    AccessModifier,\r\n    ECoreAnnotation,\r\n    ECoreAttribute,\r\n    ECoreClass,\r\n    ECoreEnum,\r\n    EcoreLiteral,\r\n    ECoreOperation,\r\n    ECorePackage,\r\n    EcoreParser,\r\n    ECoreReference,\r\n    ECoreRoot\r\n} from \"../../api/data\";\r\nimport {ValuePointers} from \"./PointerDefinitions\";\r\nimport {ShortDefaultEClasses} from \"../../common/U\";\r\nimport {transientProperties} from \"../../joiner/classes\";\r\nimport React, {ReactNode} from \"react\";\r\n\r\ntype outactions = {clear:(()=>void)[], set:(()=>void)[], immediatefire?: boolean};\r\n\r\n\r\n@Node\r\n@RuntimeAccessible('DModelElement')\r\nexport class DModelElement extends DPointerTargetable {\r\n    // static _super = DPointerTargetable;\r\n    // static logic: typeof LModelElement;\r\n    // static structure: typeof DModelElement;\r\n    // static singleton: LModelElement;\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n\r\n    id!: Pointer<DModelElement, 1, 1, LModelElement>;\r\n    parent: Pointer<DModelElement, 0, 'N', LModelElement> = [];\r\n    father!: Pointer<DModelElement, 1, 1, LModelElement>;\r\n    annotations: Pointer<DAnnotation, 0, 'N', LAnnotation> = [];\r\n    // instances: Pointer<DModelElement, 0, 'N', LModelElement> = [];\r\n\r\n    public static new(): DModelElement {\r\n        Log.exx(\"DModelElement is abstract, cannot instantiate\");\r\n        return null as any;\r\n        //return new Constructors(new DModelElement('dwc')).DPointerTargetable().DModelElement().end();\r\n    }\r\n    public static new3(...a:any): DModelElement {\r\n        Log.exx(\"DModelElement is abstract, cannot instantiate\");\r\n        return null as any; }\r\n\r\n    static LFromHtml(target?: Element | null): LModelElement | undefined { return LPointerTargetable.fromPointer(DModelElement.PtrFromHtml(target) as Pointer); }\r\n    static DFromHtml(target?: Element | null): DModelElement | undefined { return DPointerTargetable.fromPointer(DModelElement.PtrFromHtml(target) as Pointer); }\r\n    static PtrFromHtml(target?: Element | null): Pointer<DModelElement> | undefined {\r\n        while (target) {\r\n            if ((target.attributes as any).dataid) return (target.attributes as any).dataid.value;\r\n            target = target.parentElement;\r\n        }\r\n        return undefined;\r\n    }\r\n}\r\n\r\n@Leaf\r\n@RuntimeAccessible('DAnnotationDetail')\r\nexport class DAnnotationDetail extends DPointerTargetable {\r\n    // todo\r\n}\r\n\r\n\r\n\r\n@Abstract\r\n@RuntimeAccessible('LModelElement')\r\nexport class LModelElement<Context extends LogicContext<DModelElement> = any, D extends DModelElement = DModelElement> extends LPointerTargetable {\r\n    // extends Mixin(DModelElement0, LPointerTargetable)\r\n    // static logic: typeof LModelElement;\r\n    // static structure: typeof DModelElement;\r\n\r\n    /* Alfonso */\r\n    static singleton: LModelElement;\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    /*static ResolvePointer = resolvePointerFunction;\r\n    private static ResolvePointers? = resolvePointersFunction;\r\n    private resolvePointer<T extends DPointerTargetable = DPointerTargetable, LB extends number = 0, UB extends number = 0, RET extends LPointerTargetable = LPointerTargetable>(ptr: Pointer<T, LB, UB, RET>): RET | null {\r\n        return LModelElement.ResolvePointer(ptr); }\r\n    private resolvePointers<T extends DPointerTargetable = DPointerTargetable, LB extends number = 0, RET extends LPointerTargetable = LPointerTargetable>(ptr: Pointer<T, LB, 'N', RET>)\r\n        : (RET | null)[] { return resolvePointersFunction(ptr); }\r\n    */\r\n    public __raw!: DModelElement;\r\n    id!: Pointer<DModelElement, 1, 1, LModelElement>;\r\n    parent!: LModelElement[];\r\n    father!: LModelElement; // annotations can be children of everything. except them fathers are: Model, Package, Classifier(class+enum), Operation\r\n\r\n    private __info_of__father = {type: \"LModelElement\", txt:\"<a href=\\\"https://github.com/DamianoNaraku/jodel-react/wiki/LModelElement\\\"><span>The element containing this object.</span></a>\"};\r\n    public fatherList!: LModelElement[]; // chain of fathers going up recursively\r\n    annotations!: LAnnotation[];\r\n    children!: (LPackage | LClassifier | LTypedElement | LAnnotation | LObject | LValue)[];\r\n    __info_of__children__: Info = {type: \"LModelElement[]\", txt: <div>Merging of all the subelement collections (attributes, references, parameters...) except annotations</div>}\r\n    nodes!: LGraphElement[];\r\n    node!: LGraphElement | undefined;\r\n\r\n    // utilities to go up in the tree (singular names)\r\n    model!: LModel; // utility, follow father chain until get a Model parent or null\r\n    package!: LPackage | null;\r\n    class!: LClass | null;\r\n    enum!: LEnumerator | null;\r\n    operation!: LOperation | null;\r\n    subNodes!: LGraphElement[] | null;\r\n\r\n\r\n    property!: keyof DModelElement;\r\n    containers!: LNamedElement[]; // list of fathers until the model is reached.\r\n    name?:string;\r\n\r\n\r\n    [key: `@${string}`]: LModelElement;\r\n    [key: `$${string}`]: LModelElement;\r\n\r\n    // protected _defaultGetter(c: Context, k: keyof Context[\"data\"]): any {}\r\n\r\n    protected _defaultGetter(c: Context, k: keyof any): any {\r\n        let targetObj = c.data;\r\n        let proxyitself = c.proxyObject;\r\n        // if not exist check for children names\r\n        if (typeof k === \"string\" && k !== \"children\" && (!(k in c.data) && !(k in this))) { // __info_of_children__\r\n            let lchildren: LPointerTargetable[];\r\n            try { lchildren = this.get_children(c); }\r\n            catch (e) { lchildren = []; }\r\n            // let dchildren: DPointerTargetable[] = lchildren.map<DPointerTargetable>(l => l.__raw as any);\r\n            let lc: GObject;\r\n            let pk: string;\r\n            if (TargetableProxyHandler.childKeys[k[0]]) { pk = k.substring(1); }\r\n            else pk = k;\r\n            if (Array.isArray(lchildren)) for (lc of lchildren) {\r\n                let n = lc?.name;\r\n                if (n && n.toLowerCase() === pk.toLowerCase()) return lc;\r\n            }\r\n        }\r\n        return super.__defaultGetter(c, k);\r\n    }\r\n\r\n    // this one must return true or the js engine throws an exception\r\n    protected _defaultSetter(val: any, c: GObject<Context>, k: string): true {\r\n        if (this._setterFor$stuff_canReturnFalse(val, c as any, k as any)) return true;\r\n        super._defaultSetter(val, c as any, k);\r\n        return true;\r\n    }\r\n    // this one must be able to return false because is called by DObject and DValue default setters and return type is checked\r\n    protected _setterFor$stuff_canReturnFalse(val: any, c: Context, k: keyof Context[\"data\"] & string): boolean {\r\n        // if (![\"@\", \"$\"].includes(k[0])) return false;\r\n        if (!TargetableProxyHandler.childKeys[k[0]]) return false;\r\n        let target: LPointerTargetable = (c.proxyObject as GObject)[k];\r\n        if (!target) return false;\r\n        let l;\r\n        let tClassName: string = target.className;\r\n\r\n        // messanger classNames (pass it to next sublevel)\r\n        navigationloop: while(true) {\r\n            switch (tClassName) {\r\n                default: break navigationloop;\r\n                case DPackage.cname:\r\n                case DClass.cname:\r\n                case DEnumerator.cname:\r\n                case DObject.cname:\r\n                    target = (target as LModelElement).children[0]; continue navigationloop;\r\n            }\r\n        }\r\n\r\n        // actiong classNames\r\n        switch (tClassName) {\r\n            default: Log.exx(\"default setter not supported for model element: \" + c.data.className, {c, k, val, target}); return false;\r\n            case DEnumLiteral.cname:\r\n                l = target as LEnumLiteral;\r\n                switch (typeof val){\r\n                    default: return false;\r\n                    case \"string\": l.literal = val; return true;\r\n                    case \"number\": l.ordinal = val; return true;\r\n                }\r\n                return false;\r\n            case DValue.cname:\r\n                // makes object.$x = 1      be equivalent to object.$x.value = 1 (or values if is arr)\r\n                l = target as LValue;\r\n                l.values = val;\r\n                return true;\r\n        }\r\n    }\r\n\r\n\r\n    public static M1Classes = ['DModel', 'DObject', 'DValue']; // Dstrudturalfeature in shapeless obj??\r\n    public static AbstractClasses = ['DModelElement', 'DNamedElement', '...'];\r\n    public static M2InstantiableClasses = ['DModel', 'DOperation', 'DClass', 'DReference', 'DAttribute'];\r\n    isM1!: (()=>boolean);\r\n    __info_of__isM1: Info = {type:'()=>boolean', txt:<div>Whether the element belong to the metamodel or the model.</div>}\r\n    get_isM1(c: Context): ()=>boolean {\r\n        // NB: if called with \"abstract classes\" like DModelElement, DTypedElement... responds they are in m2\r\n        return (() => (!(c.data as DModel).isMetamodel && LModelElement.M1Classes.includes(c.data.className)));\r\n    }\r\n    isM2!: (()=>boolean);\r\n    __info_of__isM2: Info = {type:'()=>boolean', txt:<div>Whether the element belong to the metamodel or the model.</div>}\r\n    get_isM2(c: Context): ()=>boolean { return (() => !(this.get_isM1(c))); }\r\n\r\n    isInstantiable!: boolean;\r\n    instantiable!: boolean;\r\n    __info_of__isInstantiable: Info = {type:'boolean', txt:<div>Whether the element type (DClass, DAttribute...) can produce an instance in the model.</div>}\r\n    get_isInstantiable(c: Context): boolean { return this.get_instantiable(c); }\r\n     get_instantiable(c: Context): boolean { return LModelElement.M2InstantiableClasses.includes(c.data.className); }\r\n\r\n    childNames!: string[];\r\n    __info_of__childNames: Info = {type: \"(json: object, instanceof?: LClass) => LObject\", txt: \"Array containing the names of all children subelements.\"};\r\n    get_childNames(c: Context): string[] { return this.get_children(c).map( (c: GObject<LModelElement>) => c.name).filter(c=>!!c) as string[]; }\r\n\r\n    public generateEcoreJson(loopDetectionloopDetectionObj: Dictionary<Pointer, DModelElement> = {}): Json {\r\n        throw new Error(\"cannot be called directly, should trigger getter. this is only for correct signature\");\r\n    }\r\n\r\n    private get_generateEcoreJson(context: Context): (loopdetectionobj: Dictionary<Pointer, DModelElement>) => Json {\r\n        return (loopdetectionobj) => this.generateEcoreJson_impl(context, loopdetectionobj);\r\n    }\r\n\r\n    protected generateEcoreJson_impl(context: Context, loopDetectionObj?: Dictionary<Pointer, DModelElement>): Json {\r\n        return Log.exDevv(\"generateEcoreJson() should be overridden\", context);\r\n    }\r\n\r\n    public duplicate(deep: boolean = true): this {\r\n        return this.cannotCall(((this.constructor as typeof RuntimeAccessibleClass).cname || this.constructor.name) + \"duplicate() class is abstract\");\r\n    }\r\n\r\n    public addAnnotation(source?: DAnnotation[\"source\"], details?: DAnnotation[\"details\"]): DAnnotation {\r\n        return this.cannotCall(\"addAnnotation\");\r\n    }\r\n\r\n    protected get_addAnnotation(context: Context): this[\"addAnnotation\"] {\r\n        return (source?: DAnnotation[\"source\"], details?: DAnnotation[\"details\"]) => DAnnotation.new(source, details, context.data.id, true);\r\n    }\r\n\r\n    protected set_containers(): boolean {\r\n        return this.cannotSet('containers');\r\n    }\r\n\r\n    protected get_containers(context: Context): LModelElement[\"containers\"] {\r\n        let thiss: LModelElement = context.proxyObject;\r\n        const ret: LModelElement[] = [thiss];\r\n        while (true) {\r\n            thiss = thiss.father;\r\n            if (!thiss) break;\r\n            ret.push(thiss);\r\n        }\r\n        return ret as LNamedElement[];\r\n    }\r\n\r\n\r\n    protected get_namespace(context: Context): string {\r\n        throw new Error(\"?? get namespace ?? todo\");\r\n        return \"\";\r\n    }\r\n\r\n    protected get_subNodes(context: LogicContext<LClass>, includingthis: boolean = false): LGraphElement[] {\r\n        const lclass: LClass = context.proxyObject as any;\r\n        let $class = $('[data-dataid=\"' + context.data.id + '\"]');\r\n        let $subnodes = $class.find('[data-nodeid]');\r\n\r\n        function mapfunc(this: HTMLElement) {\r\n            return this.dataset.nodeid;\r\n        }\r\n\r\n        let nodehtmlarr: HTMLElement[] = $subnodes.toArray();\r\n        if (includingthis) nodehtmlarr.push($class[0]);\r\n        let nodeidarr: string[] = nodehtmlarr.map((html: HTMLElement) => html.dataset.nodeid) as string[];\r\n        let state = store.getState();\r\n        let dnodes = nodeidarr.map(id => state.idlookup[id]).filter((d) => !!d);\r\n        return dnodes.map(d => LPointerTargetable.wrap(d)) as any;\r\n    }\r\n\r\n\r\n    // name -> redux (es. DClass -> classs)\r\n    protected get_property(context: Context): this[\"property\"] {\r\n        return (context.data.className.substring(1) + \"s\").toLowerCase() as any;\r\n    }\r\n\r\n    protected targetRemoved(context: Context, field: keyof DPointerTargetable): void {\r\n        context.proxyObject.delete();\r\n    }\r\n\r\n\r\n    protected get_fatherList(context: Context): LModelElement[] {\r\n        let ret: LModelElement[] = [context.proxyObject];\r\n        let loopdetection: Dictionary<Pointer, boolean> = {};\r\n        loopdetection[context.data.id] = true;\r\n        let current = this.get_father(context);\r\n        while (current) {\r\n            if (loopdetection[current.id]) { console.error(\"found loop\", {loopdetection, ret, current}); return ret; }\r\n            loopdetection[current.id] = true;\r\n            ret.push(current);\r\n            current = current.father;\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    // @ts-ignore\r\n    private get_until_parent<D extends Constructor, L extends DtoL<InstanceType<D>>>(l: LModelElement, d: DModelElement, father: typeof D): L | null {\r\n        while (true) {\r\n            // console.log('get_until_parent', {l, d, father}, {dname: d.className, fname: father.name});\r\n            if (d.className === (father.cname || father.name)) return l as L;\r\n            l = l.father;\r\n            let oldd = d;\r\n            d = l?.__raw;\r\n            if (oldd === d || !l) return null; // reached end of father chain (a model) without finding the desired parent.\r\n        }\r\n    }\r\n\r\n    __info_of__nodes:Info={type: 'LGraphElement[]', txt: \"Return all kind of graphic elements representing this modelElement currently displayed in the graph, including edges\"};\r\n    protected get_nodes(context: Context): this[\"nodes\"] {\r\n        return Object.values(transientProperties.modelElement[context.data.id]?.nodes || {}).filter(n=>n&&n.html);/*\r\n        const nodes: LGraphElement[] = [];\r\n        const nodeElements = $('[data-dataid=\"' + context.data.id + '\"]'); nope, this must become more efficient. when node is created set action to update data.nodes array? or to update a transient property (better)\r\n        for (let nodeElement of nodeElements) {\r\n            const nodeId = nodeElement.id;\r\n            if (nodeId) {\r\n                const lNode: LGraphElement | undefined = LPointerTargetable.wrap(nodeId);\r\n                if (lNode) nodes.push(lNode);\r\n            }\r\n        }\r\n        return nodes;*/\r\n    }\r\n\r\n    __info_of__node:Info={type: 'LGraphElement[]', txt: \"Return the latest updated node representing this ModelElement, including those not currently displayed in the graph.\"};\r\n    protected get_node(context: Context): this[\"node\"] {\r\n        return transientProperties.modelElement[context.data.id]?.node;\r\n        // const nodes = context.proxyObject.nodes;\r\n        // return nodes.filter( n => n.favoriteNode)[0] || nodes[0];\r\n    }\r\n    edges!: LEdge[];\r\n    edge!: LEdge;\r\n    __info_of__edges:Info={type: 'LEdge[]', txt: \"The subset of \\\"nodes\\\" containing only edges.\"};\r\n    __info_of__edge:Info={type: 'LEdge[]', txt: \"The first element of the collection edges\"};\r\n    protected get_edges(context: Context): this[\"edges\"] {\r\n        return this.get_nodes(context).filter( l => l.className?.includes('Edge')) as any;\r\n    }\r\n    protected get_edge(context: Context): this[\"edge\"] {\r\n        return this.get_nodes(context).find( l => l.className?.includes('Edge')) as any;\r\n    }\r\n    notEdges!: LGraphElement[];\r\n    notEdge!: LGraphElement;\r\n    __info_of__notEdges:Info={type: 'LGraphElement[]', txt: \"The subset of \\\"nodes\\\" excluding only edges.\"};\r\n    protected get_notEdges(context: Context): this[\"notEdges\"] {\r\n        return this.get_nodes(context).filter( l => !(l.className?.includes('Edge'))) as any;\r\n    }\r\n    __info_of__notEdge:Info={type: 'LGraphElement', txt: \"The first element of the collection notEdges\"};\r\n    protected get_notEdge(context: Context): this[\"notEdge\"] {\r\n        return this.get_nodes(context).find( l => !(l.className?.includes('Edge'))) as any;\r\n    }\r\n    vertexes!: LVertex[];\r\n    vertex!: LVertex;\r\n    __info_of__vertexes:Info={type: 'LVertex[]', txt: \"The subset of \\\"nodes\\\" containing only vertexes.\"};\r\n    __info_of__vertex:Info={type: 'LVertex', txt: \"The first element of the collection vertexes\"};\r\n    protected get_vertexes(context: Context): this[\"vertexes\"] {\r\n        return this.get_nodes(context).filter( l => l.className?.includes('Vertex')) as any;\r\n    }\r\n    protected get_vertex(context: Context): this[\"vertex\"] {\r\n        return this.get_nodes(context).find( l => l.className?.includes('Vertex')) as any;\r\n    }\r\n    edgePoints!: LEdgePoint[];\r\n    edgePoint!: LEdgePoint;\r\n    __info_of__edgePoints:Info={type: 'LVertex[]', txt: \"The subset of \\\"nodes\\\" containing only edgePoints.\"};\r\n    __info_of__edgePoint:Info={type: 'LVertex', txt: \"The first element of the collection edgePoints\"};\r\n    protected get_edgePoints(context: Context): this[\"edgePoints\"] {\r\n        return this.get_nodes(context).filter( l => l.className?.includes('EdgePoint')) as any;\r\n    }\r\n    protected get_edgePoint(context: Context): this[\"edgePoint\"] {\r\n        return this.get_nodes(context).find( l => l.className?.includes('EdgePoint')) as any;\r\n    }\r\n    graphs!: LGraph[];\r\n    graph!: LGraph;\r\n    __info_of__graphs:Info={type: 'LGraph[]', txt: \"The subset of \\\"nodes\\\" containing only graphs.\"};\r\n    __info_of__graph:Info={type: 'LGraph', txt: \"The first element of the collection graphs\"};\r\n    protected get_graphs(context: Context): this[\"graphs\"] {\r\n        return this.get_nodes(context).filter( l => {\r\n            let d = l.__raw;\r\n            return d.className === 'DGraph' || d.className === 'DGraphVertex'\r\n        }) as any;\r\n    }\r\n    protected get_graph(context: Context): this[\"graph\"] {\r\n        return this.get_nodes(context).find( l => {\r\n            let d = l.__raw;\r\n            return d.className === 'DGraph' || d.className === 'DGraphVertex'\r\n        }) as any;\r\n    }\r\n    fields!: LGraphElement[];\r\n    field!: LGraphElement;\r\n    __info_of__fields:Info={type: 'LGraphElement[]', txt: \"The subset of \\\"nodes\\\" containing only fields.\"};\r\n    __info_of__field:Info={type: 'LGraphElement', txt: \"The first element of the collection fields\"};\r\n    protected get_fields(context: Context): this[\"fields\"] {\r\n        return this.get_nodes(context).filter( l => l.className === 'DGraphElement') as any;\r\n    }\r\n    protected get_field(context: Context): this[\"field\"] {\r\n        return this.get_nodes(context).find( l => l.className === 'DGraphElement') as any;\r\n    }\r\n\r\n    /*\r\n    protected get_nodes(context: Context): this[\"nodes\"] {\r\n        return context.data.nodes.map((pointer) => {\r\n            return LPointerTargetable.from(pointer)\r\n        });\r\n    }\r\n    protected set_nodes(val: PackArr<this[\"nodes\"]>, context: Context): boolean {\r\n        const list = val.map((lItem) => { return Pointers.from(lItem) });\r\n        SetFieldAction.new(context.data, 'nodes', list);\r\n        return true;\r\n    }\r\n    */\r\n\r\n    protected get_model(context: Context): LModel {\r\n        return this.get_until_parent(context.proxyObject, context.data, DModel) as LModel;\r\n    }\r\n\r\n    protected get_package(context: Context): LPackage {\r\n        return this.get_until_parent(context.proxyObject, context.data, DPackage) as LPackage;\r\n    }\r\n\r\n    protected get_class(context: Context): LClass | null {\r\n        return this.get_until_parent(context.proxyObject, context.data, DClass);\r\n    } // todo: might be better for pergormance to erase this universal method and add implementations to every single L-class counting the correct amount of \"father\" navigations for each ( attrib to package? use attrib.father.father)\r\n    protected get_operation(context: Context): LOperation | null {\r\n        return this.get_until_parent(context.proxyObject, context.data, DOperation);\r\n    }\r\n\r\n    protected get_enum(context: Context): LEnumerator | null {\r\n        return this.get_until_parent(context.proxyObject, context.data, DEnumerator);\r\n    }\r\n\r\n    protected get_father(context: Context): LModelElement {\r\n        return LPointerTargetable.from(context.data.father);\r\n    }\r\n\r\n    protected get_children_idlist(context: Context): Pointer<DAnnotation | DPackage | DClassifier | DEnumerator | DEnumLiteral | DParameter | DStructuralFeature | DOperation | DObject | DValue, 1, 'N'> { // LPackage | LClassifier | LTypedElement | LAnnotation | LEnumLiteral | LParameter | LStructuralFeature | LOperation\r\n        return context.data.annotations ? [...context.data.annotations] : [];\r\n    }\r\n\r\n    protected get_children(context: Context): this[\"children\"] {\r\n        // return this.get_children_idlist(context).map(e => LPointerTargetable.from(e));\r\n        return LPointerTargetable.from(this.get_children_idlist(context));\r\n    }\r\n\r\n    protected set_children(a: never, context: Context): boolean {\r\n        return Log.exx('children is a derived read-only collection', context.data);\r\n    }\r\n\r\n\r\n    add_parent(val: Pack<this[\"parent\"]>, logicContext: Context): boolean { // todo: when will be used?\r\n        const ptr = Pointers.from(val);\r\n        return SetFieldAction.new(logicContext.data, 'parent', ptr, '+=', true); // todo: need to update children of the old and new parents\r\n    }\r\n\r\n    protected remove_parent(logicContext: Context): boolean { // todo: perchè senza bersaglio? perchè sempre elimina tutti?\r\n        return SetFieldAction.new(logicContext.data, 'parent', [], '', true);\r\n    }\r\n\r\n    protected get_parent(context: Context): this[\"parent\"] {\r\n        return LPointerTargetable.from(context.data.id);\r\n    }\r\n\r\n    protected set_parent(val: Pack<LAnnotation>, context: Context): boolean { // val: Pack<DModelElement>\r\n        const ptrs = Pointers.from(val);\r\n        SetFieldAction.new(context.data, 'father', ptrs?.[0] || ptrs, '', true);\r\n        return SetFieldAction.new(context.data, 'parent', ptrs, '', true);\r\n    }\r\n\r\n    add_annotation(val: Pack<this[\"annotations\"]>, context: Context): boolean {\r\n        const ptrs = Pointers.from(val);\r\n        return SetFieldAction.new(context.data, 'annotations', ptrs, '+=', true);\r\n    }\r\n\r\n    remove_annotation(val: Pack<this[\"annotations\"]>, context: Context): boolean { // todo: when this will be ever used? this should be triggered by LObject but only get_ / set_ and delete of whole elements should be triggerable.\r\n        //todo: remove as any\r\n        const ptrs: Pointer<DAnnotation, 1, 'N', LAnnotation> = Pointers.from(val) as any;\r\n        let indexes = ptrs.map(ptr => context.data.annotations.indexOf(ptr)).filter(p => p >= 0);\r\n        return SetFieldAction.new(context.data, 'annotations', indexes, '-=', true);\r\n    }\r\n\r\n    protected get_annotations(context: Context): this[\"annotations\"] {\r\n        return LPointerTargetable.fromPointer(context.data.annotations);\r\n    }\r\n\r\n    protected set_annotations(val: Pack<LAnnotation>, context: Context): boolean {\r\n        //  if (!Array.isArray(val)) val = [val];\r\n        //         val = val.map( v => (v instanceof LAnnotation ? v.id : ( Pointers.filterValid(v) ? v : null ))) as Pointer<DAnnotation>[];\r\n        const ptrs = Pointers.from(val);\r\n        SetFieldAction.new(context.data, 'annotations', ptrs, '', true);\r\n        return true;\r\n    }\r\n\r\n    protected get_addChild(c: Context): (type?: string, ...params: any[]) => LModelElement { // just for add new, not for add pre-existing.\r\n        return (type, ...args: any) => {\r\n            let ret: undefined | ((...params: any[]) => LModelElement);\r\n            let type0 = type;\r\n            if (!type || type === \"auto\") {\r\n                switch(c.data.className){\r\n                    case DModel.cname: if ((c.data as DModel).isMetamodel) type = \"package\"; else type = \"object\"; break;\r\n                    case DObject.cname: type = \"value\"; break;\r\n                    case DPackage.cname: type = \"package\"; break;\r\n                    case DClass.cname: type = \"attribute\"; break;\r\n                    case DEnumerator.cname: type = \"literal\"; break;\r\n                    case DOperation.cname: type = \"parameter\"; break;\r\n                    default: type = \"annotation\"; break;\r\n                }\r\n            }\r\n            let fatherElement;\r\n            switch (type.toLowerCase()) {\r\n                default:\r\n                    Log.ee('cannot find children type requested to add:', {type: (type || '').toLowerCase(), c});\r\n                    ret = () => undefined as any;\r\n                    break;\r\n                case \"package\":\r\n                    ret = (this.get_package(c) || this.get_model(c))?.addPackage;\r\n                    break;\r\n                case \"class\":\r\n                    // let current = c.proxyObject;\r\n                    fatherElement = this.get_package(c);\r\n                    if (!fatherElement) {\r\n                        let model = this.get_model(c);\r\n                        fatherElement = model.packages[0];\r\n                        if (!fatherElement) fatherElement = model.addPackage();\r\n                    }\r\n                    ret = fatherElement.addClass;\r\n                    //ret = (this as any).get_addClass(context as any);\r\n                    break;\r\n                case \"enum\":\r\n                case \"enumerator\":\r\n                    fatherElement = this.get_package(c);\r\n                    if (!fatherElement) {\r\n                        let model = this.get_model(c);\r\n                        fatherElement = model.packages[0];\r\n                        if (!fatherElement) fatherElement = model.addPackage();\r\n                    }\r\n                    ret = fatherElement.addEnumerator;\r\n                    break;\r\n                case \"attribute\":\r\n                    ret = this.get_class(c)?.addAttribute;\r\n                    break;\r\n                case \"reference\":\r\n                    ret = this.get_class(c)?.addReference;\r\n                    break;\r\n                case \"literal\":\r\n                    ret = this.get_enum(c)?.addLiteral;\r\n                    break;\r\n                case \"operation\":\r\n                    ret = this.get_class(c)?.addOperation;\r\n                    break;\r\n                case \"parameter\":\r\n                    ret = this.get_operation(c)?.addParameter;\r\n                    break;\r\n                case \"object\":\r\n                    if (c.data.className === \"DValue\") {\r\n                        ret = (this as any as LValue).get_addObject(c as any as LogicContext<DValue>);\r\n                    }\r\n                    else {\r\n                        ret = this.get_model(c).addObject;\r\n                    }\r\n\r\n                //case \"exception\": ret = ((exception: Pack1<LClassifier>) => { let rett = this.get_addException(context as any); rett(exception); }) as any; break;\r\n                /*case \"exception\": exceptions should not be \"added\" here, this is for creating objects. exceptions are not created but just linked. they are classes.\r\n                    ret = (this as any).get_addException(c as any);\r\n                    break; */\r\n            }\r\n            // console.log('x6 addchild()', {type0, type, args, fatherElement, ret, rts:ret?.toString()});\r\n            return ret ? ret(...args) : null as any;\r\n        }\r\n    }\r\n\r\n    protected get_addException(context: Context): () => void {\r\n        let ret = () => {\r\n        };\r\n        const dOperation: DOperation | null = (context.data?.className === \"DOperation\") ? context.data as DOperation : null;\r\n        if (dOperation) {\r\n            const dClass = DPointerTargetable.from(dOperation.father);\r\n            ret = () => {\r\n                SetFieldAction.new(dOperation, \"exceptions\", dClass.id, '+=', true);\r\n            }\r\n        }\r\n        ret();\r\n        return ret;\r\n    }\r\n\r\n    // activated by user in JSX\r\n    // todo: this.wrongAccessMessage(\"addClass\");\r\n    protected cannotCall(name: string, ...params: string[]): any {\r\n        Log.exDevv(name + ' should never be called directly, but should trigger get_' + name + '(' + params.join(', ') + '), this is only a signature for type checking.');\r\n    }\r\n\r\n    public addClass(): void {\r\n        this.cannotCall('addClass');\r\n    }\r\n\r\n    public addAttribute(): void {\r\n        this.cannotCall('addAttribute');\r\n    }\r\n\r\n    public addReference(): void {\r\n        this.cannotCall('addReference');\r\n    }\r\n\r\n    public addEnumerator(): void {\r\n        this.cannotCall('addEnumerator');\r\n    }\r\n\r\n    public addParameter(): void {\r\n        this.cannotCall('addParameter');\r\n    }\r\n\r\n    // chiedere al prof: cosa può lanciato come eccezione: se tutte le classi o se solo quelle che estendono Exception\r\n    public addException(exception?: DClassifier): () => void {\r\n        throw this.wrongAccessMessage(\"AddException\");\r\n    }\r\n\r\n    public addChild(type: string): DModelElement {\r\n        return this.cannotCall('addChild', type);\r\n    }\r\n\r\n}\r\n\r\n/*function isValidPointer<T extends DPointerTargetable = DModelElement, LB extends number = 0, UB extends number = 1, RET extends LPointerTargetable = LModelElement>\r\n(p: Pointer<T, LB, UB, RET>, constraintType?: typeof DPointerTargetable): boolean {\r\n    const pointerval: RET | null = LModelElement.ResolvePointer(p);\r\n    if (!pointerval) return false;\r\n    if (!constraintType) return true;\r\n    return (pointerval instanceof constraintType); }*/\r\n\r\n/* todo:\r\nnel proxy aggiungi regola di default, se prendi qualcosa che inizia con \"set_X\" esplicitamente (dovrebbe farlo solo il dev)\r\nrichiama _set_X(context, ...params)     <---- nuova funzione set di default, anche this.x = x richiama _set_x\r\n\r\nil dev specifica set_x come public di sola firma senza implementazione (throw exception) e senza context\r\nil dev specifica _set_x come implementazione private\r\n\r\nper la get esiste solo _get_x, non \"get_x\"\r\n\r\n todo2: aggiungi readonly a tutti i campi L per non sbagliarsi e fare in modo che il dev usi sempre i \"set_\" che sono correttamente tipizzati\r\n*\r\n* */\r\n\r\n/*todo:\r\n* for every feature X: typed L, in CLASS_L0 with a side effects when they are edited (like need to update other data for consistency)\r\n*\r\n* dev will use this\r\n* protected set_X(val: D | L | Pointer<D> ) { throw new Error(\"set_X should never be executed, the proxy should redirect to get_set_X.\"); }\r\n* protected get_set_X( val: D | L | Pointer<D>, otherparams, ContextD>) { throw new Error(\"set_X should never be executed, the proxy should redirect to get_set_X.\"); }\r\n*\r\n*\r\n* */\r\n// export type WModelElement = DModelElement | LModelElement | _WModelElement;\r\nRuntimeAccessibleClass.set_extend(DPointerTargetable, DModelElement);\r\nRuntimeAccessibleClass.set_extend(DPointerTargetable, LModelElement);\r\n\r\n@Leaf\r\n@RuntimeAccessible('DAnnotation')\r\nexport class DAnnotation extends DModelElement { // extends Mixin(DAnnotation0, DModelElement)\r\n    // static singleton: LAnnotation;\r\n    // static logic: typeof LAnnotation;\r\n    // static structure: typeof DAnnotation;\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // inherit redefine\r\n    id!: Pointer<DAnnotation, 1, 1, LAnnotation>;\r\n    parent: Pointer<DModelElement, 0, 'N', LModelElement> = [];\r\n    father!: Pointer<DModelElement, 1, 1, LModelElement>;\r\n    annotations: Pointer<DAnnotation, 0, 'N', LAnnotation> = [];\r\n    // personal\r\n    source!: string;\r\n    details!: DAnnotationDetail[];//Dictionary<string, string>;\r\n\r\n    public static new(source?: DAnnotation[\"source\"], details?: DAnnotation[\"details\"], father?: Pointer, persist: boolean = true): DAnnotation {\r\n        // if (!name) name = this.defaultname(\"annotation \", father);\r\n        return new Constructors(new DAnnotation('dwc'), father, persist, undefined).DPointerTargetable().DModelElement().DAnnotation(source, details).end();\r\n    }\r\n}\r\n\r\n@Node\r\n@RuntimeAccessible('LAnnotation')\r\nexport class LAnnotation<Context extends LogicContext<DAnnotation> = any, D extends DAnnotation = DAnnotation> extends LModelElement {\r\n    // Mixin(DAnnotation0, LModelElement)\r\n    // @ts-ignore\r\n    __namee!: \"LAnnotation\" = \"LAnnotation\";\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    public __raw!: DAnnotation;\r\n    id!: Pointer<DAnnotation, 1, 1, LAnnotation>;\r\n    // static singleton: LAnnotation;\r\n    // static logic: typeof LAnnotation;\r\n    // static structure: typeof DAnnotation;\r\n\r\n    // inherit redefine\r\n    parent!: LModelElement[];\r\n    father!: LModelElement;\r\n    annotations!: LAnnotation[];\r\n    // personal\r\n    source!: string;\r\n    details!: LAnnotationDetail[];// Dictionary<string, string> = {};\r\n\r\n    protected generateEcoreJson_impl(context: Context, loopDetectionObj: Dictionary<Pointer, DModelElement> = {}): Json {\r\n        loopDetectionObj[context.data.id] = context.data;\r\n        const json: Json = {};\r\n        EcoreParser.write(json, ECoreAnnotation.source, context.data.source);\r\n        // EcoreParser.write(json, ECoreAnnotation.references, context.proxyObject.referencesStr);\r\n        EcoreParser.write(json, ECoreAnnotation.details, context.proxyObject.details.map(d => d.generateEcoreJson(loopDetectionObj)));\r\n        return json;\r\n    }\r\n\r\n    public duplicate(deep: boolean = true): this {\r\n        return this.cannotCall(((this.constructor as typeof RuntimeAccessibleClass).cname || this.constructor.name) + \"duplicate()\");\r\n    }\r\n\r\n    protected get_duplicate(context: Context): ((deep?: boolean) => this) {\r\n        return (deep: boolean = false) => {\r\n            BEGIN()\r\n            let de = context.proxyObject.father.addAnnotation(context.data.source, (deep ? context.proxyObject.details.map(ldet => ldet.duplicate().__raw) : context.data.details));\r\n            let le: this = LPointerTargetable.fromD(de);\r\n            let we: WAnnotation = le as any;\r\n            we.annotations = deep ? context.proxyObject.annotations.map(lchild => lchild.duplicate(deep).id) : context.data.annotations;\r\n            END()\r\n            return le;\r\n        }\r\n    }\r\n\r\n    protected get_source(context: Context): this[\"source\"] {\r\n        return context.data.source;\r\n    }\r\n\r\n    protected set_source(val: this[\"source\"], context: Context): boolean {\r\n        SetFieldAction.new(context.data, 'source', val, '', false);\r\n        return true;\r\n    }\r\n\r\n    protected get_details(context: Context): this[\"details\"] {\r\n        return TargetableProxyHandler.wrapAll(context.data.details);\r\n    }\r\n\r\n    protected set_details(val: this[\"details\"], context: Context): boolean {\r\n        SetFieldAction.new(context.data, 'details', val);\r\n        return true;\r\n    }\r\n}\r\n\r\nRuntimeAccessibleClass.set_extend(DModelElement, DAnnotation);\r\nRuntimeAccessibleClass.set_extend(LModelElement, LAnnotation);\r\n@Leaf\r\n@RuntimeAccessible('LAnnotationDetail')\r\nexport class LAnnotationDetail<Context extends LogicContext<DAnnotationDetail> = any> extends LModelElement { // todo\r\n    father!: LAnnotation;\r\n\r\n    protected generateEcoreJson_impl(context: Context, loopDetectionObj: Dictionary<Pointer, DModelElement> = {}): Json {\r\n        // loopDetectionObj[context.data.id] = context.data;\r\n        const json: Json = {};\r\n        // if (context.data.name !== null) EcoreParser.write(json, ECoreDetail.key, context.data.name);\r\n        // if (context.data.value !== null) EcoreParser.write(json, ECoreDetail.value, context.data.value);\r\n        return json;\r\n    }\r\n\r\n    public duplicate(deep: boolean = true): this {\r\n        return this.cannotCall(((this.constructor as typeof RuntimeAccessibleClass).cname || this.constructor.name) + \"duplicate()\");\r\n    }\r\n\r\n    protected get_duplicate(context: Context): ((deep?: boolean) => this) {\r\n        Log.exDevv(\"LAnnotationDetail.getDuplicate(): todo\");\r\n        return () => this;\r\n        // return (deep: boolean = false) => (context.proxyObject as LAnnotationDetail).father.addAnnotationDetail( {...context.data._subMaps})\r\n    }\r\n}\r\n\r\nRuntimeAccessibleClass.set_extend(DModelElement, DAnnotationDetail);\r\nRuntimeAccessibleClass.set_extend(LModelElement, LAnnotationDetail);\r\n@Node\r\n@RuntimeAccessible('DNamedElement')\r\nexport class DNamedElement extends DPointerTargetable { // Mixin(DNamedElement0, DAnnotation)\r\n    // static _super = DAnnotation;\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // static singleton: LNamedElement;\r\n    // static logic: typeof LNamedElement;\r\n    // static structure: typeof DNamedElement;\r\n\r\n    // inherit redefine\r\n    id!: Pointer<DNamedElement, 1, 1, LNamedElement>;\r\n    parent: Pointer<DModelElement, 0, 'N', LModelElement> = [];\r\n    father!: Pointer<DModelElement, 1, 1, LModelElement>;\r\n    annotations: Pointer<DAnnotation, 0, 'N', LAnnotation> = [];\r\n    // personal\r\n    name!: string;\r\n\r\n    public static new(name?: DNamedElement[\"name\"]): DNamedElement {\r\n        Log.exx(\"DNamedElement is abstract, cannot instantiate\");\r\n        return null as any;\r\n        // return new Constructors(new DNamedElement('dwc')).DPointerTargetable().DModelElement().DNamedElement(name).end();\r\n    }\r\n\r\n}\r\n\r\n@Abstract\r\n@RuntimeAccessible('LNamedElement')\r\nexport class LNamedElement<Context extends LogicContext<DNamedElement> = any> extends LModelElement { // Mixin(DNamedElement0, DAnnotation)\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // public __raw!: DNamedElement;\r\n    id!: Pointer<DNamedElement, 1, 1, LNamedElement>;\r\n    // static singleton: LNamedElement;\r\n    // static logic: typeof LNamedElement;\r\n    // static structure: typeof DNamedElement;\r\n\r\n    // inherit redefine\r\n    parent!: LModelElement[];\r\n    father!: LModelElement;\r\n    annotations!: LAnnotation[];\r\n    // personal\r\n    name!: string;\r\n    namespace!: string;\r\n    fullname!: string;\r\n\r\n    protected set_containers(): boolean {\r\n        return this.cannotSet('containers');\r\n    }\r\n\r\n    protected get_containers(context: Context): LNamedElement[\"containers\"] {\r\n        let thiss: LNamedElement = context.proxyObject;\r\n        const ret: LNamedElement[] = [thiss];\r\n        while (true) {\r\n            thiss = thiss.father as LNamedElement;\r\n            if (!thiss) break;\r\n            ret.push(thiss);\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    // protected get_namespace(context: Context): string { throw new Error(\"?? get namespace ?? todo\"); return \"\"; }\r\n\r\n    protected get_fullName(context: Context): this[\"fullname\"] { return this.get_fullname(context); }\r\n    protected get_fullname(context: Context): this[\"fullname\"] {\r\n        const containers = this.get_containers(context).reverse();\r\n        // let sliceindex = (containers[0] as LModel).dependencies.length ? 1 : 0;\r\n        let fullname: string = containers.slice(0, containers.length).map(c => c.name).join('.');\r\n        return fullname;\r\n    }\r\n\r\n\r\n    protected get_name(context: Context): this[\"name\"] {\r\n        return context.data.name;\r\n    }\r\n\r\n    protected set_name(val: this[\"name\"], context: Context): boolean {\r\n        let name = val;\r\n        const father = context.proxyObject.father;\r\n        if (father) {\r\n            const check = father.children.filter((child) => {\r\n                return (DNamedElement.fromPointer(child.id) as DNamedElement).name === name\r\n            });\r\n            if (check.length > 0) {\r\n                U.alert('e', 'Cannot rename the selected element since this name is already taken.');\r\n                return true\r\n            }\r\n        }\r\n        SetFieldAction.new(context.data, 'name', name, '', false);\r\n        return true;\r\n\r\n        /*\r\n        // this autofix removes spaces with _\r\n        if (val.match(/\\s/)) val = this._autofix_name(val, context);\r\n        // todo: validate if operation can be completed or need autocorrection, then either return false (invalid parameter cannot complete) or send newVal at redux\r\n        const fixedVal: string = val;\r\n        SetFieldAction.new(context.data, 'name', fixedVal, '', false);\r\n        return true;\r\n        */\r\n    }\r\n\r\n    protected _autofix_name(val: string, context: Context): string {\r\n        // NB: NON fare autofix di univocità nome tra i children o qualsiasi cosa dipendente dal contesto, questo potrebbe essere valido in alcuni modelli e invalido in altri e modificare un oggetto condiviso.\r\n        return val.replaceAll(/\\s/g, '_');\r\n    }\r\n\r\n    protected get_autofix_name(val: string, context: Context): (val: string) => string {\r\n        return (val: string) => this._autofix_name(val, context);\r\n    }\r\n\r\n    public autofix_name(val: string): string {\r\n        return this.wrongAccessMessage(\"autofix_name\");\r\n    }\r\n}\r\n\r\n\r\n// export type WNamedElement = DNamedElement | LNamedElement | _WNamedElement;\r\nRuntimeAccessibleClass.set_extend(DModelElement, DNamedElement);\r\nRuntimeAccessibleClass.set_extend(LModelElement, LNamedElement);\r\n@RuntimeAccessible('DTypedElement')\r\nexport class DTypedElement extends DPointerTargetable { // Mixin(DTypedElement0, DNamedElement)\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // static singleton: LTypedElement;\r\n    // static logic: typeof LTypedElement;\r\n    // static structure: typeof DTypedElement;\r\n\r\n    // inherit redefine\r\n    id!: Pointer<DTypedElement, 1, 1, LTypedElement>;\r\n    annotations: Pointer<DAnnotation, 0, 'N', LAnnotation> = [];\r\n    parent: Pointer<DModelElement, 0, 'N', LModelElement> = [];\r\n    father!: Pointer<DModelElement, 1, 1, LModelElement>;\r\n    name!: string;\r\n    instances!: Pointer<DValue, 0, 'N', LValue>;\r\n    // personal\r\n    type!: Pointer<DClassifier, 1, 1, LClassifier>;\r\n    ordered: boolean = true;\r\n    unique: boolean = true;\r\n    lowerBound: number = 0;\r\n    upperBound: number = 1;\r\n    many!: boolean; // ?\r\n    required!: boolean; // ?\r\n\r\n\r\n    public static new(name?: DNamedElement[\"name\"], type?: DTypedElement[\"type\"], father?: Pointer, persist: boolean = true): DTypedElement {\r\n        Log.exx(\"DTypedElement is abstract, cannot instantiate\");\r\n        return null as any;\r\n        //return new Constructors(new DTypedElement('dwc'), father, persist, undefined).DPointerTargetable().DModelElement().DNamedElement(name).DTypedElement(type).end();\r\n    }\r\n}\r\n\r\n@Abstract\r\n@RuntimeAccessible('LTypedElement')\r\nexport class LTypedElement<Context extends LogicContext<DTypedElement> = any> extends LNamedElement { // extends Mixin(DTypedElement0, LNamedElement)\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    public __raw!: DTypedElement;\r\n    id!: Pointer<DTypedElement, 1, 1, LTypedElement>;\r\n    // static singleton: LTypedElement;\r\n    // static logic: typeof LTypedElement;\r\n    // static structure: typeof DTypedElement;\r\n\r\n    // inherit redefine\r\n    parent!: LModelElement[];\r\n    father!: LModelElement;\r\n    annotations!: LAnnotation[];\r\n    name!: string;\r\n    namespace!: string;\r\n    instances!: LValue[];\r\n    // personal\r\n    type!: LClassifier;\r\n\r\n    primitiveType?: LClass;\r\n    classType?: LClass;\r\n    enumType?: LEnumerator;\r\n\r\n    ordered!: boolean;\r\n    unique!: boolean;\r\n    lowerBound!: number;\r\n    upperBound!: number;\r\n    many!: boolean;\r\n    required!: boolean;\r\n\r\n\r\n    protected get_classType(context: Context): this[\"classType\"] {\r\n        let type = this.get_type(context);\r\n        return type.isClass ? type as LClass : undefined;\r\n    }\r\n\r\n    protected get_enumType(context: Context): this[\"enumType\"] {\r\n        let type = this.get_type(context);\r\n        return type.isEnum ? type as LEnumerator : undefined;\r\n    }\r\n\r\n    protected get_primitiveType(context: Context): this[\"primitiveType\"] {\r\n        let type = this.get_type(context);\r\n        return type.isPrimitive ? type as LClass : undefined;\r\n    }\r\n\r\n    protected get_type(context: Context): this[\"type\"] {\r\n        return LPointerTargetable.from(context.data.type);\r\n    }\r\n\r\n    protected set_type(val: Pack1<this[\"type\"]>, context: Context): boolean {\r\n        const data = context.data;\r\n        let instances: LValue[] = context.proxyObject.instances;\r\n        SetFieldAction.new(context.data, 'type', Pointers.from(val), \"\", true);\r\n        return true;\r\n    }\r\n\r\n    protected get_ordered(context: Context): this[\"ordered\"] {\r\n        return context.data.ordered;\r\n    }\r\n\r\n    protected set_ordered(val: this[\"ordered\"], logicContext: Context): boolean {\r\n        return SetFieldAction.new(logicContext.data, 'ordered', val);\r\n    }\r\n\r\n    protected get_unique(context: Context): this[\"unique\"] {\r\n        return context.data.unique;\r\n    }\r\n\r\n    protected set_unique(val: this[\"unique\"], logicContext: Context): boolean {\r\n        return SetFieldAction.new(logicContext.data, 'unique', val);\r\n    }\r\n\r\n    protected get_lowerBound(context: Context): this[\"lowerBound\"] {\r\n        return context.data.lowerBound;\r\n    }\r\n\r\n    protected set_lowerBound(val: this[\"lowerBound\"], context: Context): boolean {\r\n        val = +val;\r\n        if (isNaN(val)) val = 0;\r\n        else val = Math.max(0, val);\r\n        SetFieldAction.new(context.data, 'lowerBound', val);\r\n        if (context.data.upperBound !=-1 && val > context.data.upperBound) SetFieldAction.new(context.data, 'upperBound', val);\r\n        return true;\r\n    }\r\n\r\n    protected get_upperBound(context: Context): this[\"upperBound\"] {\r\n        return context.data.upperBound;\r\n    }\r\n\r\n    protected set_upperBound(val: this[\"upperBound\"], context: Context): boolean {\r\n        val = +val;\r\n        if (isNaN(val)) val = -1;\r\n        else val = Math.max(-1, val);\r\n        SetFieldAction.new(context.data, 'upperBound', val);\r\n        if (val !== -1 && val < context.data.lowerBound) SetFieldAction.new(context.data, 'lowerBound', val);\r\n        return true;\r\n    }\r\n\r\n    protected get_many(context: Context): this[\"many\"] {\r\n        return context.data.many;\r\n    }\r\n\r\n    protected set_many(val: this[\"many\"], context: Context): boolean {\r\n        SetFieldAction.new(context.data, 'many', val);\r\n        return true;\r\n    }\r\n\r\n    protected get_required(context: Context): this[\"required\"] {\r\n        return context.data.required;\r\n    }\r\n\r\n    protected set_required(val: this[\"required\"], context: Context): boolean {\r\n        SetFieldAction.new(context.data, 'required', val);\r\n        return true;\r\n    }\r\n\r\n    public typeToEcoreString(): string {\r\n        return this.cannotCall(\"typeToEcoreString\");\r\n    }\r\n\r\n    protected get_typeToEcoreString(context: Context): () => string {\r\n        // if (context.data.classType) return EcoreParser.classTypePrefix + context.proxyObject.classType.name;\r\n        // if (context.data.enumType) return EcoreParser.classTypePrefix + context.proxyObject.enumType.name;\r\n        // if (context.data.primitiveType) return context.proxyObject.primitiveType.long;\r\n        return () => context.proxyObject.type.typeEcoreString;\r\n    }\r\n\r\n    public typeToShortString(): string {\r\n        return this.cannotCall(\"typeToShortString\");\r\n    }\r\n\r\n    protected get_typeToShortString(context: Context): () => string {\r\n        // if (context.data.classType) return '' + context.data.classType.name;\r\n        // if (context.data.enumType) return '' + context.data.enumType.name;\r\n        // if (context.data.primitiveType) return '' + context.data.primitiveType.getName();\r\n        return () => context.proxyObject.type.typeString;\r\n    }\r\n\r\n    canOverride(context: Context, other: LTypedElement): boolean {\r\n        // i primitivi identici sono compatibili\r\n        if (context.data.type === other.type.id) return true;\r\n        let t1 = context.proxyObject.type;\r\n        let t2 = other.type;\r\n        // se entrambi primitivi\r\n        if (context.proxyObject.primitiveType && other.primitiveType) {\r\n            ShortAttribSuperTypes[t1.name as ShortAttribETypes].includes(other.name as ShortAttribETypes);\r\n        }\r\n        if (context.proxyObject.enumType) return t1 === t2; // only if they are same enumerator\r\n        // now assumed to be class type\r\n        if (other.classType === other.classType) return true;\r\n        return (context.proxyObject.classType as LClass).isExtending(other.classType as LClass);\r\n    }\r\n\r\n}\r\n\r\n// @RuntimeAccessible('') export class _WTypedElement extends _WNamedElement { }\r\n// export type WTypedElement = DTypedElement | LTypedElement | _WTypedElement;\r\nRuntimeAccessibleClass.set_extend(DNamedElement, DTypedElement);\r\nRuntimeAccessibleClass.set_extend(LNamedElement, LTypedElement);\r\n@RuntimeAccessible('DClassifier')\r\nexport class DClassifier extends DPointerTargetable { // extends DNamedElement\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // static singleton: LClassifier;\r\n    // static logic: typeof LClassifier;\r\n    // static structure: typeof DClassifier;\r\n\r\n    // inherit redefine\r\n    id!: Pointer<DClassifier, 1, 1, LClassifier>;\r\n    parent: Pointer<DPackage, 0, 'N', LPackage> = [];\r\n    father!: Pointer<DPackage, 1, 1, LPackage>;\r\n    annotations: Pointer<DAnnotation, 0, 'N', LAnnotation> = [];\r\n    name!: string;\r\n    // personal\r\n    instanceClassName!: string;\r\n    // instanceClass: EJavaClass // ?\r\n    defaultValue!: Pointer<DObject, 1, 1, LObject>[] | string[];\r\n    // isInstance(object: EJavaObject): boolean; ?\r\n    // getClassifierID(): number;\r\n\r\n    public static new(name?: DNamedElement[\"name\"], father?: Pointer, persist: boolean = true): DClassifier {\r\n        Log.exx(\"DClassifier is abstract, cannot instantiate\");\r\n        return null as any;\r\n        // return new Constructors(new DClassifier('dwc'), father, persist, undefined).DPointerTargetable().DModelElement().DNamedElement(name).DClassifier().end();\r\n    }\r\n}\r\n\r\n@Abstract\r\n@RuntimeAccessible('LClassifier')\r\nexport class LClassifier<Context extends LogicContext<DClassifier> = any> extends LNamedElement { // extends DNamedElement\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    public __raw!: DClassifier;\r\n    id!: Pointer<DClassifier, 1, 1, LClassifier>;\r\n    // static singleton: LClassifier;\r\n    // static logic: typeof LClassifier;\r\n    // static structure: typeof DClassifier;\r\n\r\n    // inherit redefine\r\n    parent!: LPackage[];\r\n    father!: LPackage;\r\n    annotations!: LAnnotation[];\r\n    name!: string;\r\n    namespace!: string;\r\n    // personal\r\n    instanceClassName!: string;\r\n    // instanceClass: EJavaClass // ?\r\n    defaultValue!: LObject[] | string[];\r\n    isPrimitive!: boolean;\r\n    isClass!: boolean;\r\n    isEnum!: boolean;\r\n    // isInstance(object: EJavaObject): boolean; ?\r\n    // getClassifierID(): number;\r\n\r\n    protected get_instanceClassName(context: Context): this[\"instanceClassName\"] {\r\n        return context.data.instanceClassName;\r\n    }\r\n\r\n    protected set_instanceClassName(val: this[\"instanceClassName\"], context: Context): boolean {\r\n        SetFieldAction.new(context.data, 'instanceClassName', val, \"\", false);\r\n        return true;\r\n    }\r\n\r\n    protected set_isPrimitive(val: this[\"isPrimitive\"], context: Context): boolean {\r\n        return this.cannotSet(\"isPrimitive\");\r\n    }\r\n\r\n    protected set_isClass(val: this[\"isClass\"], context: Context): boolean {\r\n        return this.cannotSet(\"isClass\");\r\n    }\r\n\r\n    protected set_isEnum(val: this[\"isEnum\"], context: Context): boolean {\r\n        return this.cannotSet(\"isEnum\");\r\n    }\r\n\r\n    protected get_isPrimitive(context: Context): this[\"isPrimitive\"] {\r\n        return !!((context.data as DClass).isPrimitive as unknown);\r\n    }\r\n\r\n    protected get_isClass(context: Context): this[\"isClass\"] {\r\n        return (context.data as DClass).isPrimitive ? false : context.data.className === DClass.cname;\r\n    }\r\n\r\n    protected get_isEnum(context: Context): this[\"isEnum\"] {\r\n        return context.data.className === DEnumerator.cname;\r\n    }\r\n\r\n    protected set_defaultValue(val: this[\"defaultValue\"] | DClassifier[\"defaultValue\"], context: Context): boolean {\r\n        if (typeof val !== \"object\" && !Pointers.isPointer(val)) {\r\n            // primitive default value for enums\r\n            SetFieldAction.new(context.data, 'defaultValue', val, \"\", false);\r\n        } else {\r\n            SetFieldAction.new(context.data, 'defaultValue', Pointers.from(val as Pointer[]) || [], \"\", true);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    typeEcoreString!: string;\r\n    typeString!: string;\r\n\r\n    private get_typeEcoreString(context: Context) {\r\n        return EcoreParser.classTypePrefix + context.data.name;\r\n    }\r\n\r\n    get_typeString(context: Context) {\r\n        return context.data.name;\r\n    }\r\n}\r\n\r\n// @RuntimeAccessible('') export class _WClassifier extends _WNamedElement { }\r\n// export type WClassifier = DClassifier | LClassifier | _WClassifier;\r\nRuntimeAccessibleClass.set_extend(DNamedElement, DClassifier);\r\nRuntimeAccessibleClass.set_extend(LNamedElement, LClassifier);\r\n\r\n@Leaf\r\n@RuntimeAccessible('DPackage')\r\nexport class DPackage extends DPointerTargetable { // extends DNamedElement\r\n    // static _super = DNamedElement;\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // static singleton: LPackage;\r\n    // static logic: typeof LPackage;\r\n    // static structure: typeof DPackage;\r\n\r\n    // inherit redefine\r\n    id!: Pointer<DPackage, 1, 1, LPackage>;\r\n    parent: Pointer<DPackage | DModel, 0, 'N', LPackage | LModel> = [];\r\n    father!: Pointer<DPackage | DModel, 1, 1, LPackage | LModel>;\r\n    annotations: Pointer<DAnnotation, 0, 'N', LAnnotation> = [];\r\n    name!: string;\r\n    // personal\r\n    classifiers: Pointer<DClassifier, 0, 'N', LClassifier> = [];\r\n    subpackages: Pointer<DPackage, 0, 'N', LPackage> = [];\r\n    uri!: string;\r\n    prefix!: string;\r\n\r\n    public static new(name?: DNamedElement[\"name\"], uri?: DPackage[\"uri\"], prefix?: DPackage[\"prefix\"], father?: Pointer, persist: boolean = true, fatherType?: Constructor): DPackage {\r\n        let dmodel: DModel | undefined;\r\n        if (!name) {\r\n            dmodel = father && DPointerTargetable.from(father);\r\n            name = this.defaultname(\"pkg_\", dmodel);\r\n        }\r\n        /*if (!uri) {\r\n            dmodel = dmodel || father && DPointerTargetable.from(father);\r\n            uri = ('org.jodel-react.') + (dmodel?.name || \"username\"); // (DPointerTargetable.from(DUser.current)).name) todo: when DUser is done\r\n        }*/\r\n        return new Constructors(new DPackage('dwc'), father, persist, fatherType).DPointerTargetable().DModelElement()\r\n            .DNamedElement(name).DPackage(uri, prefix).end();\r\n    }/*\r\n    static new15(setter: (d: DPackage) => void, father: DPackage[\"father\"], fatherType: Constructor, name?: string): DPackage {\r\n        if (!name) name = this.defaultname(\"pkg_\", father);\r\n        return new Constructors(new DPackage('dwc'), father, true, fatherType).DPointerTargetable().DModelElement()\r\n            .DNamedElement(name).DPackage().end(setter);\r\n    }\r\n    static new2(setter: Partial<ObjectWithoutPointers<DPackage>>, fatherType: Constructor, persist: boolean = true): DPackage {\r\n        if (!name) name = this.defaultname(\"pkg_\", father);\r\n        return new Constructors(new DPackage('dwc'), father, true, fatherType).DPointerTargetable().DModelElement()\r\n            .DNamedElement(name).DPackage().end((d)=> { Object.assign(d, setter); });\r\n    }*/\r\n    static new3(a: Partial<PackagePointers>, callback: undefined | ((d: DPackage, c: Constructors) => void), fatherType: Constructor, persist: boolean = true): DPackage {\r\n        if (!a.name) a.name = this.defaultname(\"pkg_\", a.father);\r\n        return new Constructors(new DPackage('dwc'), a.father, persist, fatherType, a.id).DPointerTargetable().DModelElement()\r\n            .DNamedElement(a.name).DPackage().end(callback);\r\n    }\r\n}\r\n\r\n@Leaf\r\n@RuntimeAccessible('LPackage')\r\nexport class LPackage<Context extends LogicContext<DPackage> = any, C extends Context = Context, D extends DPackage = DPackage> extends LNamedElement { // extends DNamedElement\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    public __raw!: DPackage;\r\n    id!: Pointer<DPackage, 1, 1, LPackage>;\r\n    // static singleton: LPackage;\r\n    // static logic: typeof LPackage;\r\n    // static structure: typeof DPackage;\r\n    // inherit redefine\r\n    parent!: (LPackage| LModel)[];  // ype 'LPackage' is missing the following properties from type 'LModelElement': get_set_parent, set_parent\r\n    father!: LPackage | LModel;\r\n    annotations!: LAnnotation[];\r\n    name!: string;\r\n    namespace!: string;\r\n    // personal\r\n    classifiers!: LClassifier[];\r\n    subpackages!: LPackage[];\r\n    uri!: string;\r\n    prefix: string = '';\r\n    // derived\r\n    classes!: LClass[] & Dictionary<DocString<\"$name\">, LClass>;\r\n    enums!: LEnumerator[] & Dictionary<DocString<\"$name\">, LEnumerator>;\r\n    enumerators!: LEnumerator[];\r\n\r\n    // utilities to go down in the tree (plural names)\r\n    allSubPackages!: LPackage[];\r\n    allSubEnums!: LEnumerator[];\r\n    allSubClasses!: LClass[];\r\n    operations!: LOperation[];\r\n    parameters!: LParameter[];\r\n    exceptions!: LClassifier[];\r\n    attributes!: LAttribute[];\r\n    references!: LReference[];\r\n    literals!: LEnumLiteral[];\r\n\r\n    protected get_name(c: Context): this['name'] {\r\n        let l = c.proxyObject;\r\n        let ret: string = (l as GObject)['$name']?.value || c.data.name;\r\n        if (ret === 'default') {\r\n            let model = this.get_model(c);\r\n            if (model.__raw.packages[0] === c.data.id) return model.name;\r\n        }\r\n        return ret;\r\n    }\r\n    protected generateEcoreJson_impltemplate(context: Context, loopDetectionObj: Dictionary<Pointer, DModelElement> = {}): Json {\r\n        loopDetectionObj[context.data.id] = context.data;\r\n        const json: GObject = {};\r\n        return json; }\r\n\r\n    protected generateEcoreJson_impl(context: Context, loopDetectionObj: Dictionary<Pointer, DModelElement> = {}): Json {\r\n        loopDetectionObj[context.data.id] = context.data;\r\n        const model: GObject = {};\r\n        const d = context.data;\r\n        let classarr = context.proxyObject.classes.map( c => c.generateEcoreJson(loopDetectionObj));\r\n        let enumarr = context.proxyObject.enums.map(e => e.generateEcoreJson(loopDetectionObj));\r\n        const classifiers: Json[] = Array.prototype.concat.call(classarr, enumarr);\r\n        model[ECorePackage.xmiversion] = '2.0';\r\n        model[ECorePackage.xmlnsxmi] = 'http://www.omg.org/XMI';\r\n        model[ECorePackage.xmlnsxsi] = 'http://www.w3.org/2001/XMLSchema-instance';\r\n        model[ECorePackage.xmlnsecore] = 'http://www.eclipse.org/emf/2002/Ecore';\r\n        model[ECorePackage.namee] = d.name;\r\n        model[ECorePackage.nsURI] = d.uri;\r\n        model[ECorePackage.nsPrefix] = d.prefix;//getModelRoot().namespace();\r\n        model[ECorePackage.eClassifiers] = classifiers;\r\n        return model; }\r\n\r\n    public duplicate(deep: boolean = true): this {\r\n        return this.cannotCall( ((this.constructor as typeof RuntimeAccessibleClass).cname || this.constructor.name) + \"duplicate()\"); }\r\n    protected get_duplicate(context: Context): ((deep?: boolean) => LPackage) {\r\n        return (deep: boolean = false) => {\r\n            BEGIN()\r\n            let le: LPackage = context.proxyObject.father.addPackage(context.data.name, context.data.uri, context.data.prefix);\r\n            let de: D = le.__raw as D;\r\n            let we: WPackage = le as any;\r\n            we.subpackages = deep ? context.proxyObject.subpackages.map( lchild => lchild.duplicate(deep).id) : context.data.subpackages;\r\n            we.classifiers = deep ? context.proxyObject.classifiers.map( lchild => lchild.duplicate(deep).id) : context.data.classifiers;\r\n            we.annotations = deep ? context.proxyObject.annotations.map( lchild => lchild.duplicate(deep).id) : context.data.annotations;\r\n            END()\r\n            return le;\r\n        }\r\n    }\r\n\r\n    public addPackage(name?: D[\"name\"], uri?: D[\"uri\"], prefix?: D[\"prefix\"]): LPackage { return this.cannotCall(\"addPackage\"); }\r\n    protected get_addPackage(context: Context): this[\"addPackage\"] {\r\n        console.log(\"Package.get_addPackage()\", {context, thiss:this});\r\n        return (name?: D[\"name\"], uri?: D[\"uri\"], prefix?: D[\"prefix\"]) => {\r\n            return LPointerTargetable.fromD(DPackage.new(name, uri, prefix, context.data.id, true, DPackage));\r\n        }\r\n    }\r\n\r\n    public addClass(name?: DClass[\"name\"], isInterface?: DClass[\"interface\"], isAbstract?: DClass[\"abstract\"], isPrimitive?: DClass[\"isPrimitive\"],\r\n                    isPartial?: DClass[\"partial\"], partialDefaultName?: DClass[\"partialdefaultname\"]): LClass {\r\n        return this.cannotCall(\"addClass\"); }\r\n    protected get_addClass(context: Context): this[\"addClass\"] {\r\n        return (name?: DClass[\"name\"], isInterface?: DClass[\"interface\"], isAbstract?: DClass[\"abstract\"], isPrimitive?: DClass[\"isPrimitive\"],\r\n                isPartial?: DClass[\"partial\"], partialDefaultName?: DClass[\"partialdefaultname\"]\r\n        ) => LPointerTargetable.fromD(DClass.new(name, isInterface, isAbstract, isPrimitive, isPartial, partialDefaultName, context.data.id, true));\r\n    }\r\n\r\n    public addEnum(...p:Parameters<this[\"addEnumerator\"]>): LEnumerator { return this.addEnumerator(...p); }\r\n    protected get_addEnum(context: Context): this[\"addEnumerator\"] { return this.get_addEnumerator(context); }\r\n    public addEnumerator(name?: DEnumerator[\"name\"]): LEnumerator { return this.cannotCall(\"addEnumerator\"); }\r\n    protected get_addEnumerator(context: Context): this[\"addEnumerator\"] {\r\n        return (name?: DEnumerator[\"name\"]) => LPointerTargetable.fromD(DEnumerator.new(name, context.data.id, true)); }\r\n\r\n    protected get_classes(context: Context, state?: DState, setNameKeys: boolean = true): LClass[] & Dictionary<DocString<\"$name\">, LClass> {\r\n        if (!context.data.classifiers.length) return [] as any;\r\n        if (!state) state = store.getState();\r\n        let classifiers = DPointerTargetable.fromPointer(context.data.classifiers as Pointer<DClassifier, 1, 1, LClassifier>[], state);\r\n        let dclasses = classifiers.filter(dc => dc?.className === DClass.cname) as DClass[];\r\n        let lclasses: LClass[] & Dictionary<DocString<\"$name\">, LClass> = LPointerTargetable.fromD(dclasses) as any;\r\n        if (setNameKeys) for (let i = 0; i < dclasses.length; i++) lclasses[\"$\"+dclasses[i].name] = lclasses[i];\r\n        return lclasses;\r\n    }\r\n    protected get_enums(context: Context): (LEnumerator[] & Dictionary<DocString<\"$name\">, LEnumerator>) { return this.get_enumerators(context); }\r\n    protected get_enumerators(context: Context, state?: DState, setNameKeys: boolean = true): (LEnumerator[] & Dictionary<DocString<\"$name\">, LEnumerator>) {\r\n        if (!context.data.classifiers.length) return [] as any;\r\n        if (!state) state = store.getState();\r\n        let classifiers = DPointerTargetable.fromPointer(context.data.classifiers as Pointer<DClassifier, 1, 1, LClassifier>[], state);\r\n        let denums = classifiers.filter(dc => dc?.className === DEnumerator.cname) as DEnumerator[];\r\n        let lenums: LEnumerator[] & Dictionary<DocString<\"$name\">, LEnumerator> = LPointerTargetable.fromD(denums) as any;\r\n        if (setNameKeys) for (let i = 0; i < denums.length; i++) (lenums as GObject)[\"$\"+denums[i].name] = lenums[i];\r\n        return lenums;\r\n    }\r\n    //private get_allClasses(context: Context): LClass[] & Dictionary<DocString<\"$name\">, LClass> { return this.get_allSubClasses(c); }\r\n    private get_allSubClasses(context: Context): LClass[] & Dictionary<DocString<\"$name\">, LClass> {\r\n        // if (!context.data.isMetamodel) return (context.data.instanceof?.allSubClasses(context) || [] as any);\r\n        const s: DState = store.getState();\r\n        let arr = this.get_allSubPackages(context, s);\r\n        let ret: (LClass[] & Dictionary<DocString<\"$name\">, LClass>) = [] as any;\r\n        // this.get_allSubPackages(context, s).flatMap(p => (p.classes || [])); this was losing the naming $keys!\r\n        for (let a of arr) {\r\n            let classarr: LClass[] & Dictionary<DocString<\"$name\">, LClass> = (a.classes || []) as any;\r\n            U.mergeNamedArray(ret, classarr);\r\n        }\r\n        return ret; }\r\n\r\n    private get_allSubEnums(context: Context): (LEnumerator[] & Dictionary<DocString<\"$name\">, LEnumerator>) { return this.get_allSubEnumerators(context); }\r\n    private get_allSubEnumerators(context: Context): (LEnumerator[] & Dictionary<DocString<\"$name\">, LEnumerator>) {\r\n        const s: DState = store.getState();\r\n        let arr = this.get_allSubPackages(context, s);\r\n        let ret: (LEnumerator[] & Dictionary<DocString<\"$name\">, LEnumerator>) = [] as any;\r\n        // this.get_allSubPackages(context, s).flatMap(p => (p.enums || [])); this was losing the naming $keys!\r\n        for (let a of arr) {\r\n            let enumarr: (LEnumerator[] & Dictionary<DocString<\"$name\">, LEnumerator>) = (a.enumerators || []) as any;\r\n            U.mergeNamedArray(ret, enumarr);\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    protected get_allSubPackages(c: Context, state?: DState): this[\"allSubPackages\"] {\r\n        // return context.data.packages.map(p => LPointerTargetable.from(p));\r\n        state = state || store.getState();\r\n        let tocheck: Pointer<DPackage>[] = c.data.subpackages || [];\r\n        let checked: Dictionary<Pointer, DPackage> = {};\r\n        checked[c.data.id] = c.data;\r\n        while (tocheck.length) {\r\n            let newtocheck: Pointer<DPackage>[] = [];\r\n            for (let ptr of tocheck) {\r\n                if (checked[ptr]) throw new Error(\"loop in packages containing themselves\");\r\n                let dpackage: DPackage = DPointerTargetable.from(ptr, state);\r\n                checked[ptr] = dpackage;\r\n                U.arrayMergeInPlace(newtocheck, dpackage?.subpackages);\r\n            }\r\n            tocheck = newtocheck;\r\n        }\r\n        let darr: DPackage[] = Object.values(checked);\r\n        let larr: LPackage[] & Dictionary<DocString<\"$name\">, LPackage> = LPointerTargetable.fromArr(darr, state);\r\n        U.toNamedArray(larr, darr);\r\n        return larr;\r\n    }\r\n\r\n    protected get_children_idlist(context: Context): Pointer<DAnnotation | DPackage | DClassifier, 1, 'N'> {\r\n        return [...super.get_children_idlist(context) as Pointer<DAnnotation | DPackage | DClassifier, 1, 'N'>, ...context.data.subpackages, ...context.data.classifiers]; }\r\n\r\n    protected get_classifiers(context: Context): this[\"classifiers\"] {\r\n        return context.data.classifiers.map((pointer) => {\r\n            return LPointerTargetable.from(pointer)\r\n        });\r\n    }\r\n    protected set_classifiers(val: PackArr<this[\"classifiers\"]>, context: Context): boolean {\r\n        const list: Pointer<DClassifier>[] = val.map((lItem) => { return Pointers.from(lItem) });\r\n        const oldList = context.data.classifiers;\r\n        const diff = U.arrayDifference(oldList, list);\r\n        BEGIN();\r\n        SetFieldAction.new(context.data, 'classifiers', list, \"\", true);\r\n        for (let id of diff.added) {\r\n            SetFieldAction.new(id, 'father', context.data.id, '', true);\r\n            SetFieldAction.new(id, 'parent', context.data.id, '+=', true);\r\n        }\r\n        for (let id of diff.removed as Pointer<DModelElement>[]) {\r\n            SetFieldAction.new(id, 'father', undefined, '', true);\r\n            const parent = DPointerTargetable.from(id).parent;\r\n            U.arrayRemoveAll(parent, context.data.id);\r\n            SetFieldAction.new(id, 'parent', parent, '', true);\r\n        }\r\n        END();\r\n        return true;\r\n    }\r\n\r\n    protected get_subpackages(context: Context): this[\"subpackages\"] {\r\n        return context.data.subpackages.map((pointer) => {\r\n            return LPointerTargetable.from(pointer)\r\n        });\r\n    }\r\n    protected set_subpackages(val: PackArr<this[\"subpackages\"]>, context: Context): boolean {\r\n        const list = val.map((lItem) => { return Pointers.from(lItem) });\r\n        const oldList = context.data.subpackages;\r\n        const diff = U.arrayDifference(oldList, list);\r\n        BEGIN();\r\n        SetFieldAction.new(context.data, 'subpackages', list, \"\", true);\r\n        for (let id of diff.added) {\r\n            SetFieldAction.new(id, 'father', context.data.id, '', true);\r\n            SetFieldAction.new(id, 'parent', context.data.id, '+=', true);\r\n        }\r\n        for (let id of diff.removed as Pointer<DModelElement>[]) {\r\n            SetFieldAction.new(id, 'father', undefined, '', true);\r\n            const parent = DPointerTargetable.from(id).parent;\r\n            U.arrayRemoveAll(parent, context.data.id);\r\n            SetFieldAction.new(id, 'parent', parent, '', true);\r\n        }\r\n        END();\r\n        return true;\r\n    }\r\n\r\n    protected get_uri(context: Context): this[\"uri\"] {\r\n        if (context.data.uri) return context.data.uri + \".\" + context.data.name;\r\n        return ('org.jodel-react.') + (context.proxyObject.model?.name || \"username\") + \".\" + context.data.name;\r\n    }\r\n    protected set_uri(val: this[\"uri\"], context: Context): boolean {\r\n        val = val || '';\r\n        let pos = val.lastIndexOf(context.data.name);\r\n        if (pos) val = val.substring(0, pos - 1); // removes final name and dot, to keep the name part dinamically added in the getter.\r\n        SetFieldAction.new(context.data, 'uri', val, \"\", false);\r\n        return true;\r\n    }\r\n    protected get_prefix(context: Context): this[\"uri\"] { return context.data.prefix; }\r\n    protected set_prefix(val: this[\"prefix\"], context: Context): boolean {\r\n        SetFieldAction.new(context.data, 'prefix', val, \"\", false);\r\n        return true;\r\n    }\r\n\r\n}\r\n// @RuntimeAccessible('') export class _WPackage extends _WNamedElement { }\r\n// export type WPackage = DPackage | LPackage | _WPackage;\r\nRuntimeAccessibleClass.set_extend(DNamedElement, DPackage);\r\nRuntimeAccessibleClass.set_extend(LNamedElement, LPackage);\r\n\r\n@Leaf\r\n@RuntimeAccessible('DOperation')\r\nexport class DOperation extends DPointerTargetable { // extends DTypedElement\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // static singleton: LOperation;\r\n    // static logic: typeof LOperation;\r\n    // static structure: typeof DOperation;\r\n\r\n    // inherit redefine\r\n    instances!: never[];\r\n    id!: Pointer<DOperation, 1, 1, LObject>;\r\n    annotations: Pointer<DAnnotation, 0, 'N', LAnnotation> = [];\r\n    parent: Pointer<DClass, 0, 'N', LClass> = [];\r\n    father!: Pointer<DClass, 1, 1, LClass>;\r\n    name!: string;\r\n    type!: Pointer<DClassifier, 1, 1, LClassifier>;\r\n    ordered: boolean = true;\r\n    unique: boolean = true;\r\n    lowerBound: number = 0;\r\n    upperBound: number = 1;\r\n    many!: boolean;\r\n    required!: boolean;\r\n    // personal\r\n    exceptions: Pointer<DClassifier, 0, 'N', LClassifier> = [];\r\n    parameters: Pointer<DParameter, 0, 'N', LParameter> = [];\r\n    visibility: AccessModifier = AccessModifier.private;\r\n    implementation!: string;\r\n    allowCrossReference!: boolean;\r\n\r\n    public static new(name?: DNamedElement[\"name\"], type?: DOperation[\"type\"], exceptions: DOperation[\"exceptions\"] = [], father?: DOperation[\"father\"], persist: boolean = true): DOperation {\r\n        if (!name) name = this.defaultname(\"fx_\", father);\r\n        if (!type) type = father;\r\n        return new Constructors(new DOperation('dwc'), father, persist, undefined).DPointerTargetable().DModelElement()\r\n            .DNamedElement(name).DTypedElement(type).DOperation(exceptions).end();\r\n    }\r\n\r\n    static new2(setter: Partial<ObjectWithoutPointers<DOperation>>, father: DOperation[\"father\"], type?: DOperation[\"type\"], name?: string): DOperation {\r\n        if (!name) name = this.defaultname(\"fx_\", father);\r\n        if (!type) type = father;\r\n        return new Constructors(new DOperation('dwc'), father, true).DPointerTargetable().DModelElement()\r\n            .DNamedElement(name).DTypedElement(type).DOperation().end((d)=> { Object.assign(d, setter); });\r\n    }\r\n\r\n    static new3(a: Partial<OperationPointers>, callback: undefined | ((d: DOperation, c: Constructors) => void), persist: boolean = true): DOperation {\r\n        if (!a.name) a.name = this.defaultname(\"fx_\", a.father);\r\n        if (!a.type) a.type = a.father;\r\n        return new Constructors(new DOperation('dwc'), a.father, persist, undefined, a.id).DPointerTargetable().DModelElement()\r\n            .DNamedElement(a.name).DTypedElement(a.type).DOperation().end(callback);\r\n    }\r\n\r\n\r\n}\r\n\r\n@Node\r\n@RuntimeAccessible('LOperation')\r\nexport class LOperation<Context extends LogicContext<DOperation> = any, C extends Context = Context, D extends DOperation = DOperation>  extends LTypedElement { // extends DTypedElement\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    public __raw!: DOperation;\r\n    id!: Pointer<DOperation, 1, 1, LOperation>;\r\n    // static singleton: LOperation;\r\n    // static logic: typeof LOperation;\r\n    // static structure: typeof DOperation;\r\n\r\n    // inherit redefine\r\n    instances!: never[];\r\n    annotations!: LAnnotation[];\r\n    parent!: LClass[];\r\n    father!: LClass;\r\n    name!: string;\r\n    namespace!: string;\r\n    type!: LClassifier;\r\n    ordered: boolean = true;\r\n    unique: boolean = true;\r\n    lowerBound: number = 0;\r\n    upperBound: number = 1;\r\n    many!: boolean;\r\n    required!: boolean;\r\n    // personal\r\n    implementation!: string;\r\n    signatureImplementation!: string; // (param1 /*type*/, param2 = value, ...) => /*return type*/\r\n    exceptions!: LClassifier[];\r\n    parameters!: LParameter[];\r\n    visibility!: AccessModifier;\r\n    allowCrossReference!: boolean;\r\n\r\n\r\n    protected generateEcoreJson_impl(context: Context, loopDetectionObj: Dictionary<Pointer, DModelElement> = {}): Json {\r\n        loopDetectionObj[context.data.id] = context.data;\r\n        const json: Json = {};\r\n        json[ECoreOperation.eParameters] = context.proxyObject.parameters.map( par => par.generateEcoreJson(loopDetectionObj));\r\n        EcoreParser.write(json, ECoreOperation.namee, context.data.name);\r\n        EcoreParser.write(json, ECoreOperation.eType, context.proxyObject.type.typeEcoreString);\r\n        EcoreParser.write(json, ECoreOperation.lowerBound, '' + context.data.lowerBound);\r\n        EcoreParser.write(json, ECoreOperation.upperBound, '' + context.data.upperBound);\r\n        EcoreParser.write(json, ECoreOperation.eexceptions, context.proxyObject.exceptions.map( (l: LClassifier) => l.typeEcoreString).join(' ')); // todo: not really sure it's this format\r\n        EcoreParser.write(json, ECoreOperation.ordered, '' + context.data.ordered);\r\n        EcoreParser.write(json, ECoreOperation.unique, '' + context.data.unique);\r\n        return json; }\r\n\r\n    public duplicate(deep: boolean = true): this {\r\n        return this.cannotCall( ((this.constructor as typeof RuntimeAccessibleClass).cname || this.constructor.name) + \"duplicate()\"); }\r\n    protected get_duplicate(context: Context): ((deep?: boolean) => LOperation) {\r\n        return (deep: boolean = false) => {\r\n            BEGIN()\r\n            let le: LOperation = context.proxyObject.father.addOperation(context.data.name, context.data.type);\r\n            let de: D = le.__raw as D;\r\n            de.many = context.data.many;\r\n            de.lowerBound = context.data.lowerBound;\r\n            de.upperBound = context.data.upperBound;\r\n            de.ordered = context.data.ordered;\r\n            de.required = context.data.required;\r\n            de.unique = context.data.unique;\r\n            de.visibility = context.data.visibility;\r\n            de.exceptions = context.data.exceptions;\r\n            let we: WOperation = le as any;\r\n            we.annotations = deep ? context.proxyObject.annotations.map(lchild => lchild.duplicate(deep).id) : context.data.annotations;\r\n            we.parameters = deep ? context.proxyObject.parameters.map(lchild => lchild.duplicate(deep).id) : context.data.parameters;\r\n            we.exceptions = context.data.exceptions;\r\n            END()\r\n            return le; }\r\n    }\r\n\r\n    public addParameter(name?: DParameter[\"name\"], type?: DParameter[\"type\"]): LParameter { return this.cannotCall(\"addParameter\"); }\r\n    protected get_addParameter(context: Context): this[\"addParameter\"] {\r\n        return (name?: DParameter[\"name\"], type?: DParameter[\"type\"]) => LPointerTargetable.fromD(DParameter.new(name, type, context.data.id, true)); }\r\n\r\n    public execute(thiss: LObject, ...params: any): any { return this.cannotCall(\"execute\"); }\r\n    protected get_execute(context: Context): ((thiss: LObject, ...params: any[])=>any) {\r\n        return (thiss: LObject, ...params: any) => {\r\n            let func: Function = eval(this.get_signatureImplementation(context, true) + \" {\\n\"+ context.data.implementation + \"\\n}\");\r\n            func.apply(thiss, params);\r\n        };\r\n    }\r\n    public set_implementation(val: this[\"implementation\"], context: Context): boolean { return SetFieldAction.new(context.data.id, \"implementation\", val, undefined, false); }\r\n    public get_implementation(context: Context): this[\"implementation\"] { return context.data.implementation; }\r\n    public set_signatureImplementation(val: this[\"signatureImplementation\"], context: Context): boolean { return this.cannotSet(\"signatureImplementation\"); }\r\n    public get_signatureImplementation(context: Context, typedComments: boolean = true): this[\"signatureImplementation\"] {\r\n        let operation = context.proxyObject;\r\n        let typedcommentpre = typedComments ? \"/* :\" : ': ' ;\r\n        let typedcommentpost = typedComments ? \" */\" : '';\r\n        return \"(\" +\r\n            operation.parameters.map(\r\n                (p) => p.name + (p.defaultValue !== undefined ? \"=\" + p.defaultValue : typedcommentpre + p.typeToShortString() + typedcommentpost)\r\n            ).join(\", \")\r\n            + \") => \" +typedcommentpre.replace(\":\", \"\") + operation.type + typedcommentpost;\r\n    }\r\n    public get_signature(context: Context): this[\"signatureImplementation\"] { return this.get_signatureImplementation(context, false); }\r\n\r\n    protected get_children_idlist(context: Context): Pointer<DAnnotation | DClassifier | DParameter, 1, 'N'> {\r\n        return [...super.get_children_idlist(context) as Pointer<DAnnotation | DParameter | DClassifier, 1, 'N'>, ...context.data.exceptions, ...context.data.parameters]; }\r\n\r\n    protected get_exceptions(context: Context): this[\"exceptions\"] {\r\n        return context.data.exceptions.map((pointer) => {\r\n            return LPointerTargetable.from(pointer)\r\n        });\r\n    }\r\n    protected set_exceptions(val: PackArr<this[\"exceptions\"]>, context: Context): boolean {\r\n        const list = val.map((lItem) => { return Pointers.from(lItem) });\r\n        SetFieldAction.new(context.data, 'exceptions', list, \"\", true);\r\n        return true;\r\n    }\r\n\r\n    protected get_parameters(context: Context): this[\"parameters\"] {\r\n        return context.data.parameters.map((pointer) => {\r\n            return LPointerTargetable.from(pointer)\r\n        });\r\n    }\r\n    protected set_parameters(val: PackArr<this[\"parameters\"]>, context: Context): boolean {\r\n        const list = val.map((lItem) => { return Pointers.from(lItem) });\r\n        const oldList = context.data.parameters;\r\n        const diff = U.arrayDifference(oldList, list);\r\n        BEGIN();\r\n        SetFieldAction.new(context.data, 'parameters', list, \"\", true);\r\n        for (let id of diff.added) {\r\n            SetFieldAction.new(id, 'father', context.data.id, '', true);\r\n            SetFieldAction.new(id, 'parent', context.data.id, '+=', true);\r\n        }\r\n        for (let id of diff.removed as Pointer<DModelElement>[]) {\r\n            SetFieldAction.new(id, 'father', undefined, '', true);\r\n            const parent = DPointerTargetable.from(id).parent;\r\n            U.arrayRemoveAll(parent, context.data.id);\r\n            SetFieldAction.new(id, 'parent', parent, '', true);\r\n        }\r\n        END();\r\n        return true;\r\n    }\r\n\r\n    // protected get_type(context: Context): this[\"type\"] { return context.proxyObject.parameters[0].type; }\r\n    // protected set_type(val: Pack1<this[\"type\"]>, context: Context): this[\"type\"] { return super.set_type(val, context); }\r\n\r\n    _mark(b: boolean, superchildren: LOperation, override: string) {\r\n\r\n    }\r\n\r\n    _canOverride(superchildren: LOperation) {\r\n        return undefined;\r\n    }\r\n\r\n    _canPolymorph(superchildren: LOperation) {\r\n        return undefined;\r\n    }\r\n}\r\nRuntimeAccessibleClass.set_extend(DTypedElement, DOperation);\r\nRuntimeAccessibleClass.set_extend(LTypedElement, LOperation);\r\n\r\n@Leaf\r\n@RuntimeAccessible('DParameter')\r\nexport class DParameter extends DPointerTargetable { // extends DTypedElement\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // static singleton: LParameter;\r\n    // static logic: typeof LParameter;\r\n    // static structure: typeof DParameter;\r\n\r\n    // inherit redefine\r\n    instances!: never[];\r\n    id!: Pointer<DParameter, 1, 1, LParameter>;\r\n    annotations: Pointer<DAnnotation, 0, 'N', LAnnotation> = [];\r\n    parent: Pointer<DOperation, 0, 'N', LOperation> = [];\r\n    father!: Pointer<DOperation, 1, 1, LOperation>;\r\n    name!: string;\r\n    type!: Pointer<DClassifier, 1, 1, LClassifier>;\r\n    ordered: boolean = true;\r\n    unique: boolean = true;\r\n    lowerBound: number = 0;\r\n    upperBound: number = 1;\r\n    many!: boolean;\r\n    required!: boolean;\r\n    defaultValue!: any;\r\n    // personal\r\n    allowCrossReference!: boolean;\r\n\r\n    public static new(name?: DNamedElement[\"name\"], type?: DTypedElement[\"type\"], father?: Pointer, persist: boolean = true): DParameter {\r\n        if (!type) type = LPointerTargetable.from(Selectors.getFirstPrimitiveTypes()).id; // default type as string\r\n        if (!name) name = this.defaultname(\"arg\", father);\r\n        return new Constructors(new DParameter('dwc'), father, persist, undefined).DPointerTargetable().DModelElement()\r\n            .DNamedElement(name).DTypedElement(type).DParameter().end();\r\n    }\r\n\r\n    static new2(setter: Partial<ObjectWithoutPointers<DParameter>>, father: DParameter[\"father\"], type?: DParameter[\"type\"], name?: DParameter[\"name\"]): DParameter {\r\n        if (!name) name = this.defaultname((name || \"arg\"), father);\r\n        return new Constructors(new DParameter('dwc'), father, true).DPointerTargetable().DModelElement()\r\n            .DNamedElement(name).DTypedElement(type).end((d) => { Object.assign(d, setter); });\r\n    }\r\n\r\n    static new3(a: Partial<ParameterPointers>, callback: undefined | ((d: DParameter, c: Constructors) => void), persist: boolean = true): DParameter {\r\n        if (!a.name) a.name = this.defaultname(\"arg\", a.father);\r\n        return new Constructors(new DParameter('dwc'), a.father, persist, undefined, a.id).DPointerTargetable().DModelElement()\r\n            .DNamedElement(a.name).DTypedElement(a.type).DOperation().end(callback);\r\n    }\r\n}\r\n\r\n@Leaf\r\n@RuntimeAccessible('LParameter')\r\nexport class LParameter<Context extends LogicContext<DParameter> = any, C extends Context = Context, D extends DParameter = DParameter>  extends LTypedElement { // extends DTypedElement\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    public __raw!: DParameter;\r\n    id!: Pointer<DParameter, 1, 1, LParameter>;\r\n    // static singleton: LParameter;\r\n    // static logic: typeof LParameter;\r\n    // static structure: typeof DParameter;\r\n\r\n    // inherit redefine\r\n    instances!: never[];\r\n    annotations!: LAnnotation[];\r\n    parent!: LOperation[];\r\n    father!: LOperation;\r\n    name!: string;\r\n    namespace!: string;\r\n    type!: LClassifier;\r\n    ordered: boolean = true;\r\n    unique: boolean = true;\r\n    lowerBound: number = 0;\r\n    upperBound: number = 1;\r\n    many!: boolean;\r\n    required!: boolean;\r\n    // personal\r\n    defaultValue!: any;\r\n    allowCrossReference!: boolean;\r\n\r\n    protected generateEcoreJson_impl(context: Context, loopDetectionObj: Dictionary<Pointer, DModelElement> = {}): Json {\r\n        loopDetectionObj[context.data.id] = context.data;\r\n        const json: Json = {};\r\n        const l = context.proxyObject;\r\n        const d = context.data;\r\n        EcoreParser.write(json, ECoreOperation.lowerBound, '' + d.lowerBound);\r\n        EcoreParser.write(json, ECoreOperation.upperBound, '' + d.upperBound);\r\n        EcoreParser.write(json, ECoreOperation.ordered, '' + d.ordered);\r\n        EcoreParser.write(json, ECoreOperation.unique, '' + d.unique);\r\n        EcoreParser.write(json, ECoreOperation.eType, '' + l.type.typeEcoreString);\r\n        return json; }\r\n\r\n    public duplicate(deep: boolean = true): this {\r\n        return this.cannotCall( ((this.constructor as typeof RuntimeAccessibleClass).cname || this.constructor.name) + \"duplicate()\"); }\r\n    protected get_duplicate(context: Context): ((deep?: boolean) => LParameter) {\r\n        return (deep: boolean = false) => {\r\n            BEGIN()\r\n            let le: LParameter = context.proxyObject.father.addParameter(context.data.name, context.data.type);\r\n            let de: D = le.__raw as D;\r\n            de.many = context.data.many;\r\n            de.lowerBound = context.data.lowerBound;\r\n            de.upperBound = context.data.upperBound;\r\n            de.ordered = context.data.ordered;\r\n            de.required = context.data.required;\r\n            de.unique = context.data.unique;\r\n            let we: WParameter = le as any;\r\n            we.annotations = deep ? context.proxyObject.annotations.map(lchild => lchild.duplicate(deep).id) : context.data.annotations;\r\n            END()\r\n            return le; }\r\n    }\r\n}\r\nRuntimeAccessibleClass.set_extend(DTypedElement, DParameter);\r\nRuntimeAccessibleClass.set_extend(LTypedElement, LParameter);\r\nexport class ClassReferences{\r\n    id?: Pack1<LClass>\r\n    parent?: this[\"father\"][];\r\n    father?: Pack1<LPackage>;\r\n    instances?: Pointer<DObject, 0, 'N', LObject> = [];\r\n    operations?: Pointer<DOperation, 0, 'N', LOperation> = [];\r\n    features?: Pointer<DStructuralFeature, 0, 'N', LStructuralFeature> = [];\r\n    references?: Pointer<DReference, 0, 'N', LReference> = [];\r\n    attributes?: Pointer<DAttribute, 0, 'N', LAttribute> = [];\r\n    referencedBy?: Pointer<DReference, 0, 'N', LReference> = [];\r\n    extends?: Pointer<DClass, 0, 'N', LClass> = [];\r\n    extendedBy?: Pointer<DClass, 0, 'N', LClass> = [];\r\n    implements?: Pointer<DClass, 0, 'N', LClass> = [];\r\n    implementedBy?: Pointer<DClass, 0, 'N', LClass> = [];\r\n}\r\n\r\n@RuntimeAccessible('DClass')\r\nexport class DClass extends DPointerTargetable { // extends DClassifier\r\n    // static _super = DClassifier;\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // static singleton: LClass;\r\n    // static logic: typeof LClass;\r\n    // static structure: typeof DClass;\r\n\r\n    // inherit redefine\r\n    // instanceClass: EJavaClass // ?\r\n    // isInstance(object: EJavaObject): boolean; ?\r\n    // getClassifierID(): number;\r\n    id!: Pointer<DClass, 1, 1, LClass>;\r\n    instanceClassName!: string;\r\n    parent: Pointer<DPackage, 0, 'N', LPackage> = [];\r\n    father!: Pointer<DPackage, 1, 1, LPackage>;\r\n    annotations: Pointer<DAnnotation, 0, 'N', LAnnotation> = [];\r\n    name!: string;\r\n    defaultValue!: Pointer<DObject, 1, 1, LObject>[];\r\n    // personal\r\n    // isSuperTypeOf(someClass: DClassifier): boolean { return todoret; }\r\n    // getEstructuralFeatureByID(featureID: number): DStructuralFeature { return todoret; }\r\n    // getEstructuralFeature(featureName: string): DStructuralFeature { return todoret; }\r\n    abstract: boolean = false;\r\n    interface: boolean = false;\r\n    instances: Pointer<DObject, 0, 'N', LObject> = [];\r\n    operations: Pointer<DOperation, 0, 'N', LOperation> = [];\r\n    features: Pointer<DStructuralFeature, 0, 'N', LStructuralFeature> = [];\r\n    references: Pointer<DReference, 0, 'N', LReference> = [];\r\n    attributes: Pointer<DAttribute, 0, 'N', LAttribute> = [];\r\n    referencedBy: Pointer<DReference, 0, 'N', LReference> = [];\r\n    extends: Pointer<DClass, 0, 'N', LClass> = [];\r\n    extendedBy: Pointer<DClass, 0, 'N', LClass> = [];\r\n\r\n    // mia aggiunta:\r\n    isPrimitive!: boolean;\r\n    implements: Pointer<DClass, 0, 'N', LClass> = [];\r\n    implementedBy: Pointer<DClass, 0, 'N', LClass> = [];\r\n    partial!: boolean;\r\n    partialdefaultname!: string;\r\n\r\n    isSingleton!: boolean;\r\n    rootable?: boolean;\r\n    sealed!: Pointer<DClass>[];\r\n    final!: boolean;\r\n    allowCrossReference!: boolean;//for extend\r\n\r\n    // for m1:\r\n    // hideExcessFeatures: boolean = true; // isn't it like partial?? // old comment: se attivo questo e creo una DClass di sistema senza nessuna feature e di nome Object, ho creato lo schema di un oggetto schema-less a cui tutti sono conformi\r\n\r\n    public static new(name?: DNamedElement[\"name\"], isInterface: DClass[\"interface\"] = false, isAbstract: DClass[\"abstract\"] = false, isPrimitive: DClass[\"isPrimitive\"] = false, partial?: DClass[\"partial\"],\r\n                      partialDefaultName?: DClass[\"partialdefaultname\"], father?: Pointer, persist: boolean = true, id?: string): DClass {\r\n        if (!name) name = this.defaultname(\"Concept \", father);\r\n\r\n        // console.log('x6 addchild() new class', {father, arguments, name});\r\n        return new Constructors(new DClass('dwc'), father, persist, undefined, id).DPointerTargetable().DModelElement()\r\n            .DNamedElement(name).DClassifier().DClass(isInterface, isAbstract, isPrimitive, partial, partialDefaultName).end();\r\n    }\r\n\r\n    static new2(setter: Partial<ObjectWithoutPointers<DClass>>, father: DClass[\"father\"], name?: DClass[\"name\"]): DClass {\r\n        if (!name) name = this.defaultname((name || \"Concept \"), father);\r\n        return new Constructors(new DClass('dwc'), father, true, undefined).DPointerTargetable().DModelElement()\r\n            .DNamedElement(name).DClassifier().DClass().end((d) => { Object.assign(d, setter); });\r\n    }\r\n\r\n    static new3(a: Partial<ClassPointers>, callback: undefined | ((d: DClass, c: Constructors) => void), persist: boolean = true): DClass {\r\n        if (!a.name) a.name = this.defaultname(\"Concept \", a.father);\r\n        return new Constructors(new DClass('dwc'), a.father, persist, undefined, a.id).DPointerTargetable().DModelElement()\r\n            .DNamedElement(a.name).DClassifier().DClass().end(callback);\r\n    }\r\n\r\n}\r\n\r\n(window as any).dc = DClassifier;\r\n(window as any).c = DClass;\r\n@Instantiable // (LObject)\r\n@Node\r\n@RuntimeAccessible('LClass')\r\nexport class LClass<D extends DClass = DClass, Context extends LogicContext<DClass> = any, C extends Context = Context>  extends LClassifier{ // extends DClassifier\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    public __raw!: DClass;\r\n    id!: Pointer<DClass, 1, 1, LClass>;\r\n    // static singleton: LClass;\r\n    // static logic: typeof LClass;\r\n    // static structure: typeof DClass;\r\n\r\n    // inherit redefine\r\n    // instanceClass: EJavaClass // ?\r\n    // isInstance(object: EJavaObject): boolean; ?\r\n    // getClassifierID(): number;\r\n    instanceClassName!: string;\r\n    parent!: LPackage[];\r\n    father!: LPackage;\r\n    annotations!: LAnnotation[];\r\n    name!: string;\r\n    namespace!: string;\r\n    defaultValue!: LObject[];\r\n    // personal\r\n    // isSuperTypeOf(someClass: DClassifier): boolean { return todoret; }\r\n    // getEstructuralFeatureByID(featureID: number): DStructuralFeature { return todoret; }\r\n    // getEstructuralFeature(featureName: string): DStructuralFeature { return todoret; }\r\n    abstract!: boolean;\r\n    interface!: boolean;\r\n    instances!: LObject[];\r\n    operations!: LOperation[];\r\n    features!: LStructuralFeature[];\r\n    references!: LReference[];\r\n    attributes!: LAttribute[];\r\n    referencedBy!: LReference[];\r\n    extends!: LClass[];\r\n    __info_of__extends: Info = {type:\"LClass[]\", txt: \"classes directly extended by this. check also: \\\"superclasses\\\".\"}\r\n    extendsChain!: LClass[];  // list of all super classes (father, father of father, ...)  todo: isn't this the same as \"superclasses\" ? check implementation differeces, eventually remove one.\r\n    extendedBy!: LClass[];\r\n    nodes!: LGraphElement[]; // ipotesi, non so se tenerlo\r\n    allowCrossReference!: boolean;\r\n    sealed!: LClass[];\r\n    __info_of__sealed: Info = {type: 'LClass[]', txt:'A sealed class can specify a list of other classes that are allowed to extend it.' +\r\n            '\\n A sealed class that does not allow any class to extend it is a \"final\" class.'}\r\n\r\n    final!: boolean;\r\n    __info_of__final: Info = {type: 'boolean', txt:'A final class cannot be extended.'}\r\n\r\n    rootable!: boolean;\r\n    __info_of__roootable: Info = {type: 'boolean', txt:'Specifies if the class can become a m1 model root, overriding the usual restriction of not being target of a containment reference.'}\r\n\r\n    isSingleton!: boolean;\r\n    __info_of__singleton: Info = {type: 'boolean', txt:'A singleton element is always present exactly 1 time in every model.' +\r\n            '\\n A single instance is created dynamically and cannot be created by the user.'}\r\n\r\n    // fittizi:\r\n\r\n    instantiable!: boolean;\r\n    __info_of__intantiable: Info = {type: 'boolean', txt:'Whether the class can be instantiated.'}\r\n\r\n    aggregated!: boolean;\r\n    __info_of__aggregated: Info = {type: 'boolean', txt:'Whether the class is targeted by an aggregation relationship.'}\r\n\r\n    composed!: boolean;\r\n    __info_of__composed: Info = {type: 'boolean', txt:'Whether the class is targeted by a composition relationship.'}\r\n\r\n    contained!: boolean;\r\n    __info_of__contained: Info = {type: 'boolean', txt:'Whether the class is targeted by a composition or aggregation relationship.'}\r\n\r\n    public superclasses!: LClass[];\r\n    __info_of__superclasses: Info = {type:\"LClass[]\", txt: \"all classes directly and indirectly extended by this. same as check also: \\\"extends\\\".\"}\r\n    public allSubClasses!: LClass[];\r\n\r\n    partialdefaultname!: string;\r\n    isPrimitive!: boolean;\r\n    isClass!: boolean; // false if it's primitive type\r\n    isEnum!: false;\r\n    implements: Pointer<DClass, 0, 'N', LClass> = [];  //todo: interface\r\n    implementedBy: Pointer<DClass, 0, 'N', LClass> = [];\r\n\r\n    ownAttributes!: LAttribute[];\r\n    ownReferences!: LReference[];\r\n    ownOperations!: LOperation[];\r\n    ownChildren!: (LStructuralFeature|LOperation)[];\r\n\r\n    inheritedAttributes!: LAttribute[];\r\n    inheritedReferences!: LReference[];\r\n    inheritedOperations!: LOperation[];\r\n    inheritedChildren!: (LStructuralFeature|LOperation)[];\r\n\r\n    allAttributes!: LAttribute[];\r\n    allReferences!: LReference[];\r\n    allOperations!: LOperation[]; // includes inherited and shadowed features\r\n    allChildren!: (LStructuralFeature|LOperation)[];\r\n\r\n\r\n\r\n    // utilities to go down in the tree (plural names)\r\n    exceptions!: LClassifier[] | null;\r\n    parameters!: LParameter[] | null;\r\n    // [`@${string}`]: LModelElement; todo: try to put it\r\n\r\n\r\n    validTargetsJSX!: JSX.Element[];\r\n    get_validTargetsJSX(c: Context): this['validTargetsJSX'] {\r\n        let opts: MultiSelectOptGroup[] = [];\r\n        this.get_validTargets(c, opts);\r\n        return UX.options(opts);\r\n    }\r\n    validTargetOptions!: MultiSelectOptGroup[];\r\n    get_validTargetOptions(c: Context): this['validTargetOptions'] {\r\n        let opts: MultiSelectOptGroup[] = [];\r\n        this.get_validTargets(c, opts);\r\n        return opts;\r\n    }\r\n    validTargets!: LClass[];\r\n    get_validTargets(c: Context, out?: MultiSelectOptGroup[]): this['validTargets'] {\r\n        let lclass: LClass = c.proxyObject as any;\r\n        // let extendOptions: {value: string, label: string}[] lclass.extends.map(lsubclass=> ({value: lsubclass.id, label: lsubclass.name}));\r\n        let m2: LModel = lclass.model;\r\n        let dclass = c.data;\r\n        let extendsarr = lclass.extendsChain.map(l=>l.id); //dclass.extends;\r\n        let pkgs = dclass.allowCrossReference ? m2.allCrossSubPackages : m2.allSubPackages;\r\n        let extendValue: {value: string, label: string}[] = [];\r\n        if (!out) out = [];\r\n        let ret: LClass[] = [];\r\n        out.push(...pkgs.map(p => (\r\n            {label: p.fullname, options: p.classes.map(c => {\r\n                    let opt = {value:c.id, label: c.name};\r\n                    if (opt.value === dclass.id) return undefined;\r\n                    if (!extendsarr.includes(opt.value)) return opt;\r\n                    extendValue.push(opt);\r\n                    ret.push(c);\r\n                    return undefined;\r\n                }).filter(e=>!!e) as {value: string, label: string}[]})));\r\n        return ret;\r\n    }\r\n\r\n    get_childNames(c: Context): string[] { return this.get_allChildren(c).map( c => c.name).filter(c=>!!c) as string[]; }\r\n    //get_isSealed(c: Context): LClass['sealed'] { return this.get_sealed(c); }\r\n    get_sealed(c: Context): LClass['sealed'] { return LPointerTargetable.wrapAll(c.data.sealed); }\r\n    set_sealed(val: PackArr<LClass>, c: Context): boolean{\r\n        if (!val) val = [];\r\n        else if (!Array.isArray(val)) val = [val];\r\n        const ptrs = [...new Set(val.map((val) => { return val && Pointers.from(val) }).filter(e=>!!e))];\r\n        if (Uarr.equalsUnsorted(c.data.sealed, ptrs)) return true;\r\n        TRANSACTION(()=>{\r\n            SetFieldAction.new(c.data, 'sealed', ptrs, '', true);\r\n            if (ptrs.length) {\r\n                SetFieldAction.new(c.data, 'isSingleton', false);\r\n                SetFieldAction.new(c.data, 'final', false);\r\n            } else {\r\n                SetFieldAction.new(c.data, 'final', true);\r\n            }\r\n        });\r\n        return true;\r\n    }\r\n    get_isFinal(c: Context): LClass['final'] { return this.get_final(c); }\r\n    get_final(c: Context): LClass['final']{ return c.data.final; }\r\n    set_final(val: boolean, c: Context): boolean{\r\n        if (val === c.data.final) return true;\r\n        if (c.data.extendedBy.length > 0) { U.alert('e', 'Class cannot become final as it is currently extended. Remove the subclasses before.'); return true; }\r\n        TRANSACTION(()=>{\r\n            SetFieldAction.new(c.data, 'final', val);\r\n            SetFieldAction.new(c.data, 'sealed', [], '', true);\r\n            if (!val) SetFieldAction.new(c.data, 'isSingleton', false);\r\n        });\r\n        return true;\r\n    }\r\n    get_isSingleton(c: Context): LClass['isSingleton'] { return this.get_singleton(c); }\r\n    get_singleton(c: Context): LClass['isSingleton']{ return c.data.isSingleton; }\r\n    set_isSingleton(val: boolean, c: Context): boolean{ return this.set_singleton(val, c); }\r\n    set_singleton(val: boolean, c: Context): boolean{\r\n        if (c.data.instances.length > 1) { U.alert('e', 'Class cannot become a singleton since there are multiple instances already. Delete some and retry.'); return true; }\r\n        if (c.data.extendedBy.length > 0) { U.alert('e', 'Class cannot become a singleton unless is also final, and is currently extended. Remove the subclasses before.'); return true; }\r\n        TRANSACTION(()=>{\r\n            SetFieldAction.new(c.data, 'isSingleton', val);\r\n            if (val) {\r\n                SetFieldAction.new(c.data, 'final', true);\r\n                let m2 = this.get_model(c);\r\n                let instances: LObject[] = this.get_instances(c);\r\n                let modelsWithInstance: Pointer<DModel>[] = instances.map( o => o.model?.id );\r\n                for (let m1 of m2.instances) {\r\n                    if (modelsWithInstance.includes(m1.id)) continue;\r\n                    m1.addObject({name: c.data.name}, c.data, true);\r\n                }\r\n            }\r\n        });\r\n        return c.data.final;\r\n    }\r\n    get_instantiable(c: Context): LClass['instantiable']{ return !(c.data.abstract || c.data.interface || c.data.isSingleton); }\r\n    get_isInstantiable(c: Context): LClass['instantiable'] { return this.get_instantiable(c); }\r\n    get_isComposed(c: Context): LClass['composed'] { return this.get_composed(c); }\r\n    get_isAggregated(c: Context): LClass['aggregated'] { return this.get_aggregated(c); }\r\n    get_isContained(c: Context): LClass['contained'] { return this.get_contained(c); }\r\n    get_contained(c: Context): LClass['contained']{\r\n        let refs = this.get_referencedBy(c);\r\n        for (let r of refs) { if (r && (r.aggregation || r.composition)) return true; }\r\n        return false;\r\n    }\r\n    get_aggregated(c: Context): LClass['aggregated']{\r\n        let refs = this.get_referencedBy(c);\r\n        for (let r of refs) if (r&&r.aggregation) return true;\r\n        return false;\r\n    }\r\n    get_composed(c: Context): LClass['composed']{\r\n        let refs = this.get_referencedBy(c);\r\n        for (let r of refs) if (r&&r.composition) return true;\r\n        return false;\r\n    }\r\n    get_isRootable(c: Context): LClass['rootable'] { return this.get_rootable(c); }\r\n    protected get_rootable(c: Context): this[\"rootable\"] {\r\n        if (c.data.rootable !== undefined) return c.data.rootable;\r\n        else return this.get_instantiable(c) && !this.get_isComposed(c);\r\n    }\r\n    protected set_rootable(val: this[\"rootable\"], c: Context): boolean {\r\n        SetFieldAction.new(c.data, 'rootable', val);\r\n        return true;\r\n    }\r\n\r\n    protected get_ownAttributes(context: Context): this['ownAttributes'] {\r\n        return LAttribute.fromPointer(context.data.attributes);\r\n    }\r\n    protected get_ownReferences(context: Context): this['ownReferences'] {\r\n        return LReference.fromPointer(context.data.references);\r\n    }\r\n    protected get_ownOperations(context: Context): this['ownOperations'] {\r\n        return LOperation.fromPointer(context.data.operations);\r\n    }\r\n    protected get_ownChildren(context: Context): this['ownChildren'] {\r\n        return U.arrayMergeInPlace<any>(this.get_ownAttributes(context), this.get_ownReferences(context),\r\n            this.get_ownOperations(context));\r\n    }\r\n\r\n    allExtends!: this['extendsChain'];\r\n    get_allExtends(c:Context): this['extendsChain']{ return this.get_extendsChain(c); }\r\n    private get_extendsChain(context: Context): this['extendsChain'] {\r\n        let targets: LClass[] = LClass.fromArr(context.data.extends);\r\n        let alreadyParsed: Dictionary<Pointer, LClass> = {};\r\n        while (targets.length) {\r\n            let nextTargets = [];\r\n            for (let target of targets){\r\n                if (alreadyParsed[target.id]) continue;\r\n                alreadyParsed[target.id] = target;\r\n                for (let next of target.extends) nextTargets.push(next);\r\n            }\r\n            targets = nextTargets;\r\n        }\r\n        return Object.values(alreadyParsed);\r\n    }\r\n\r\n    public isSubClassOf(superClass: LClass, returnIfSameClass: boolean = true): boolean { return this.cannotCall(\"isSubClassOf\"); }\r\n    public isSuperClassOf(subClass: LClass, returnIfSameClass: boolean = true): boolean { return this.cannotCall(\"isSuperClassOf\"); }\r\n    protected get_isSubClassOf(c: Context): ((superClass: LClass, returnIfSameClass?: boolean) => boolean) {\r\n        return (superClass?: LClass, returnIfSameClass: boolean = true) => {\r\n            superClass = LPointerTargetable.wrap(superClass);\r\n            if (!superClass) return false;\r\n            if (superClass.id === c.data.id) return returnIfSameClass;\r\n            for (let subclass of this.get_extendsChain(c)) {\r\n                if (subclass.id === superClass.id) return true;\r\n            }\r\n            return false;\r\n        }\r\n    }\r\n    protected get_isSuperClassOf(c: Context): ((subClass: LClass, returnIfSameClass?: boolean) => boolean) {\r\n        return (subClass: LClass, returnIfSameClass: boolean = true) => {\r\n            if (!subClass) return false;\r\n            if (subClass.id === c.data.id) return returnIfSameClass;\r\n            return subClass.isSubClassOf(c.proxyObject, returnIfSameClass);\r\n        }\r\n    }\r\n\r\n    protected get_inheritedAttributes(context: Context): this['inheritedAttributes'] {\r\n        return this.get_extendsChain(context).flatMap((superClass) => superClass.ownAttributes);\r\n    }\r\n    protected get_inheritedReferences(context: Context): this['inheritedReferences'] {\r\n        return this.get_extendsChain(context).flatMap((superClass) => superClass.ownReferences);\r\n    }\r\n    protected get_inheritedOperations(context: Context): this['inheritedOperations'] {\r\n        return this.get_extendsChain(context).flatMap((superClass) => superClass.ownOperations);\r\n    }\r\n    protected get_inheritedChildren(context: Context): this['inheritedChildren'] {\r\n        return U.arrayMergeInPlace<any>(this.get_inheritedAttributes(context), this.get_inheritedReferences(context),\r\n            this.get_inheritedOperations(context));\r\n    }\r\n\r\n    protected get_allAttributes(context: Context): this['allAttributes'] {\r\n        return U.arrayMergeInPlace<any>(this.get_ownAttributes(context), this.get_inheritedAttributes(context));\r\n    }\r\n    protected get_allReferences(context: Context): this['allReferences'] {\r\n        return U.arrayMergeInPlace<any>(this.get_ownReferences(context), this.get_inheritedReferences(context));\r\n    }\r\n    protected get_allOperations(context: Context): this['allOperations'] {\r\n        return U.arrayMergeInPlace<any>(this.get_ownOperations(context), this.get_inheritedOperations(context));\r\n    }\r\n    protected get_allChildren(context: Context): this['allChildren'] {\r\n        return U.arrayMergeInPlace<any>(this.get_ownChildren(context), this.get_inheritedChildren(context));\r\n    }\r\n\r\n    protected generateEcoreJson_impl(context: Context, loopDetectionObj: Dictionary<Pointer, DModelElement> = {}): Json {\r\n        loopDetectionObj[context.data.id] = context.data;\r\n        const json: GObject = {};\r\n        const featurearr: Json[] = [];\r\n        const operationsarr: Json[] = [];\r\n        let supertypesstr = [];\r\n        const d = context.data;\r\n        const l = context.proxyObject;\r\n        for (let att of l.attributes) { featurearr.push(att.generateEcoreJson(loopDetectionObj)); }\r\n        for (let ref of l.references) { featurearr.push(ref.generateEcoreJson(loopDetectionObj)); }\r\n        for (let op of l.operations) { operationsarr.push(op.generateEcoreJson(loopDetectionObj)); }\r\n\r\n        json[ECoreClass.xsitype] = 'ecore:EClass';\r\n        json[ECoreClass.namee] = d.name;\r\n        json[ECoreClass.interface] = U.toBoolString(d.interface, false);\r\n        json[ECoreClass.abstract] = U.toBoolString(d.abstract, false);\r\n        if (d.instanceClassName) json[ECoreClass.instanceTypeName] = d.instanceClassName;\r\n        json[ECoreClass.eSuperTypes] = l.extends.map( superclass => superclass.typeEcoreString).join(\" \");\r\n        if (featurearr) json[ECoreClass.eStructuralFeatures] = featurearr;\r\n        if (operationsarr) json[ECoreClass.eOperations] = operationsarr;\r\n        return json; }\r\n\r\n\r\n    public duplicate(deep: boolean = true): this {\r\n        return this.cannotCall( ((this.constructor as typeof RuntimeAccessibleClass).cname || this.constructor.name) + \"duplicate()\"); }\r\n    protected get_duplicate(context: Context): ((deep?: boolean) => LClass) {\r\n        return (deep: boolean = false) => {\r\n            let ret: LClass = undefined as any;\r\n            TRANSACTION( () => {\r\n                let le: LClass = context.proxyObject.father.addClass(context.data.name, context.data.interface, context.data.abstract, context.data.isPrimitive);\r\n                let de: D = le.__raw as D;\r\n                // de.hideExcessFeatures = context.data.hideExcessFeatures;\r\n                let we: WClass = le as any;\r\n                we.defaultValue = context.data.defaultValue;\r\n                we.extends = context.data.extends;\r\n                we.attributes = deep ? context.proxyObject.attributes.map(lchild => lchild.duplicate(deep).id) : context.data.attributes;\r\n                we.references = deep ? context.proxyObject.references.map(lchild => lchild.duplicate(deep).id) : context.data.references;\r\n                we.operations = deep ? context.proxyObject.operations.map(lchild => lchild.duplicate(deep).id) : context.data.operations;\r\n                ret = le; // set ret = le only if the transaction is complete.\r\n            });\r\n            return ret; }\r\n    }\r\n\r\n    protected get_children_idlist(context: Context): Pointer<DAnnotation | DStructuralFeature | DOperation, 1, 'N'> {\r\n        return [...super.get_children_idlist(context) as Pointer<DAnnotation | DStructuralFeature, 1, 'N'>,\r\n            ...context.data.attributes,\r\n            ...context.data.references,\r\n            ...context.data.operations];\r\n    }\r\n\r\n\r\n    protected set_name(val: this[\"name\"], context: Context): boolean {\r\n        if (context.data.name === val) return true;\r\n        super.set_name(val, context);\r\n        SetRootFieldAction.new('ClassNameChanged.'+context.data.id, val, '', false); // it is pointer, but related to transient stuff, so don't need pointedBy's\r\n        return true;\r\n    }\r\n\r\n    partial!: boolean;\r\n    __info_of__partial: Info = {type: 'boolean', txt:'A partial object have can add unlisted features as a shapeless (schemaless) object does,' +\r\n            ' on top of a set of fixed listed features.'}\r\n    protected set_partial(val: D[\"partial\"], context: Context): boolean { return SetFieldAction.new(context.data.id, \"partial\", val); }\r\n    protected get_partial(context: Context): D[\"partial\"] { return context.data.partial; }\r\n\r\n    protected set_partialdefaultname(val: D[\"partialdefaultname\"], context: Context): boolean { return SetFieldAction.new(context.data.id, \"partialdefaultname\", val, undefined, false); }\r\n    protected get_partialdefaultname(context: Context): D[\"partialdefaultname\"] { return context.data.partialdefaultname; }\r\n\r\n    public addAttribute(name?: DAttribute[\"name\"], type?: DAttribute[\"type\"]): LAttribute { return this.cannotCall(\"addAttribute\"); }\r\n    protected get_addAttribute(context: Context): this[\"addAttribute\"] {\r\n        return (name?: DAttribute[\"name\"], type?: DAttribute[\"type\"]) => LPointerTargetable.fromD(DAttribute.new(name, type, context.data.id, true));\r\n    }\r\n\r\n    public addReference(name?: DReference[\"name\"], type?: DReference[\"type\"]): LReference { return this.cannotCall(\"addReference\"); }\r\n    protected get_addReference(context: Context): this[\"addReference\"] {\r\n        return (name?: DReference[\"name\"], type?: DReference[\"type\"]) => LPointerTargetable.fromD(DReference.new(name, type, context.data.id, true));\r\n    }\r\n\r\n    public addOperation(name?: DOperation[\"name\"], type?: DOperation[\"type\"]): LOperation { return this.cannotCall(\"addOperation\"); }\r\n    protected get_addOperation(context: Context): this[\"addOperation\"] {\r\n        return (name?: DOperation[\"name\"], type?: DOperation[\"type\"]) => LPointerTargetable.fromD(DOperation.new(name, type, [], context.data.id, true));\r\n    }\r\n\r\n\r\n    protected get_abstract(context: Context): this[\"abstract\"] { return context.data.abstract; }\r\n    protected set_abstract(val: this[\"abstract\"], context: Context): boolean {\r\n        const data = context.data;\r\n        if(val && data.instances.length > 0) {\r\n            U.alert('e', 'Cannot change the abstraction level since there are instances.');\r\n        } else {\r\n            SetFieldAction.new(data, 'abstract', val);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    protected set_isPrimitive(val: this[\"isPrimitive\"], context: Context): boolean { SetFieldAction.new(context. data, 'isPrimitive', val); return true; }\r\n    // get is in classifier with all other \"type\"s getter and setter\r\n\r\n    protected get_interface(context: Context): this[\"interface\"] { return context.data.interface; }\r\n    protected set_interface(val: this[\"interface\"], c: Context): boolean {\r\n        if (val && c.data.instances.length > 0) {\r\n            U.alert('e', 'Class cannot become an interface since there are instances.');\r\n        } else {\r\n            SetFieldAction.new(c.data, 'interface', val);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    allInstances!: LObject[];\r\n    __info_of__allInstances: Info = {type: 'LObject[]', txt: \"Instances in m1 of this class and of all subclasses.\"};\r\n    protected get_allInstances(context: Context): this[\"instances\"] {\r\n        let sc = this.get_allSubClasses(context, true);\r\n        return sc.flatMap( (c) => c.instances);\r\n    }\r\n\r\n    protected get_instances(context: Context): this[\"instances\"] {\r\n        return context.data.instances.map((pointer) => {\r\n            return LPointerTargetable.from(pointer)\r\n        });\r\n    }\r\n    protected set_instances(val: PackArr<this[\"instances\"]>, context: Context): boolean {\r\n        const list = val.map((lItem) => { return Pointers.from(lItem) });\r\n        SetFieldAction.new(context.data, 'instances', list, \"\", true);\r\n        return true;\r\n    }\r\n\r\n    protected get_operations(context: Context): this[\"operations\"] {\r\n        return context.data.operations.map((pointer) => {\r\n            return LPointerTargetable.from(pointer)\r\n        });\r\n    }\r\n    protected set_operations(val: PackArr<this[\"operations\"]>, context: Context): boolean {\r\n        const list = val.map((lItem) => { return Pointers.from(lItem) });\r\n        const oldList = context.data.operations;\r\n        const diff = U.arrayDifference(oldList, list);\r\n        BEGIN();\r\n        SetFieldAction.new(context.data, 'operations', list, \"\", true);\r\n        for (let id of diff.added) {\r\n            SetFieldAction.new(id, 'father', context.data.id, '', true);\r\n            SetFieldAction.new(id, 'parent', context.data.id, '+=', true);\r\n        }\r\n        for (let id of diff.removed as Pointer<DModelElement>[]) {\r\n            SetFieldAction.new(id, 'father', undefined, '', true);\r\n            const parent = DPointerTargetable.from(id).parent;\r\n            U.arrayRemoveAll(parent, context.data.id);\r\n            SetFieldAction.new(id, 'parent', parent, '', true);\r\n        }\r\n        END();\r\n        return true;\r\n    }\r\n\r\n    protected get_features(context: Context): this[\"features\"] {\r\n        return context.data.features.map((pointer) => { return LPointerTargetable.from(pointer) });\r\n    }\r\n    protected set_features(val: PackArr<this[\"features\"]>, context: Context): boolean {\r\n        const list = val.map((lItem) => { return Pointers.from(lItem) });\r\n        const oldList = context.data.features;\r\n        const diff = U.arrayDifference(oldList, list);\r\n        BEGIN();\r\n        SetFieldAction.new(context.data, 'features', list, \"\", true);\r\n        for (let id of diff.added) {\r\n            SetFieldAction.new(id, 'father', context.data.id, '', true);\r\n            SetFieldAction.new(id, 'parent', context.data.id, '+=', true);\r\n        }\r\n        for (let id of diff.removed as Pointer<DModelElement>[]) {\r\n            SetFieldAction.new(id, 'father', undefined, '', true);\r\n            const parent = DPointerTargetable.from(id).parent;\r\n            U.arrayRemoveAll(parent, context.data.id);\r\n            SetFieldAction.new(id, 'parent', parent, '', true);\r\n        }\r\n        END();\r\n        return true;\r\n    }\r\n\r\n    protected get_references(context: Context): this[\"references\"] {\r\n        return context.data.references.map((pointer) => {\r\n            return LPointerTargetable.from(pointer)\r\n        });\r\n    }\r\n    protected set_references(val: PackArr<this[\"references\"]>, context: Context): boolean {\r\n        const list = val.map((lItem) => { return Pointers.from(lItem) });\r\n        const oldList = context.data.references;\r\n        const diff = U.arrayDifference(oldList, list);\r\n        BEGIN();\r\n        SetFieldAction.new(context.data, 'references', list, \"\", true);\r\n        for (let id of diff.added) {\r\n            SetFieldAction.new(id, 'father', context.data.id, '', true);\r\n            SetFieldAction.new(id, 'parent', context.data.id, '+=', true);\r\n        }\r\n        for (let id of diff.removed as Pointer<DModelElement>[]) {\r\n            SetFieldAction.new(id, 'father', undefined, '', true);\r\n            const parent = DPointerTargetable.from(id).parent;\r\n            U.arrayRemoveAll(parent, context.data.id);\r\n            SetFieldAction.new(id, 'parent', parent, '', true);\r\n        }\r\n        END();\r\n        return true;\r\n    }\r\n\r\n    protected get_attributes(context: Context): this[\"attributes\"] {\r\n        return context.data.attributes.map((pointer) => {\r\n            return LPointerTargetable.from(pointer)\r\n        });\r\n    }\r\n    protected set_attributes(val: PackArr<this[\"attributes\"]>, context: Context): boolean {\r\n        const list = val.map((lItem) => { return Pointers.from(lItem) });\r\n        const oldList = context.data.attributes;\r\n        const diff = U.arrayDifference(oldList, list);\r\n        BEGIN();\r\n        SetFieldAction.new(context.data, 'attributes', list, \"\", true);\r\n        for (let id of diff.added) {\r\n            SetFieldAction.new(id, 'father', context.data.id, '', true);\r\n            SetFieldAction.new(id, 'parent', context.data.id, '+=', true);\r\n        }\r\n        for (let id of diff.removed as Pointer<DModelElement>[]) {\r\n            SetFieldAction.new(id, 'father', undefined, '', true);\r\n            const parent = DPointerTargetable.from(id).parent;\r\n            U.arrayRemoveAll(parent, context.data.id);\r\n            SetFieldAction.new(id, 'parent', parent, '', true);\r\n        }\r\n        END();\r\n        return true;\r\n    }\r\n\r\n    public get_referencedBy(c: Context): this[\"referencedBy\"] {\r\n        let keystr: string;\r\n        if (c.data.className === 'DClass'){ keystr = '.type'; }\r\n        // @ts-ignore\r\n        else if (c.data.className === 'DObject'){ return LObject.singleton.get_referencedBy(c); }\r\n        // else if (c.data.className === 'DObject'){ keystr = '.values'; } nope, model also have .values+=\r\n        // and lvalues might be under either \".values\" | \".values+=\" | \".values.0\" (in rightbar)\r\n        else return [];\r\n\r\n        let ptrs = c.data.pointedBy.map(e=> {\r\n            /*\r\n            if (c.data.className === 'DObject'){\r\n                let parent = this.get_father(c);\r\n                return parent.className === 'DValue' ? [parent] : [];\r\n            }*/\r\n            let index = e.source.lastIndexOf(keystr);\r\n            if (index !== (e.source.length - keystr.length)) return null;\r\n            return e.source.substring('idlookup.'.length, index);\r\n\r\n        }).filter(e=>!!e);\r\n\r\n        return LPointerTargetable.fromArr(ptrs);\r\n        // return context.data.referencedBy.map((pointer) => LPointerTargetable.from(pointer) );\r\n    }\r\n    protected set_referencedBy(val: PackArr<this[\"referencedBy\"]>, context: Context): boolean {\r\n        return this.cannotSet('referencedBy', 'is automatically updated through pointedBy');\r\n        /*if (!val) val = [];\r\n        else if (!Array.isArray(val)) val = [val];\r\n        const ptrs = [...new Set(val.map((val) => { return val && Pointers.from(val) })).filter(e=>!!e)];\r\n        SetFieldAction.new(context.data, 'referencedBy', ptrs, \"\", true);\r\n        return true;*/\r\n    }\r\n\r\n    protected get_extends(context: Context): this[\"extends\"] {\r\n        return context.data.extends.map((pointer) => {\r\n            return LPointerTargetable.from(pointer)\r\n        });\r\n    }\r\n    protected set_extends(val: PackArr<this[\"extends\"]>, c: Context): boolean {\r\n        if (!val) val = [];\r\n        else if (!Array.isArray(val)) val = [val];\r\n        let ptrs: Pointer[] = [...new Set(val.map((val) => { return val && Pointers.from(val) }).filter(e=>!!e))];\r\n        let diff = Uarr.arrayDifference(c.data.extends, ptrs);\r\n        let invalid: GObject[] = [];\r\n        let invalidPtrs: Pointer[] = [];\r\n        for (let ptr of diff.added){\r\n            let reason: GObject = {ptr};\r\n            if (this.get_canExtend(c)(ptr as any, reason as any)) continue;\r\n            invalid.push(reason);\r\n            invalidPtrs.push(ptr);\r\n        }\r\n        if (invalid.length) {\r\n            Log.ww('tried to add invalid extends, they were ignored:', invalid);\r\n            ptrs = ptrs.filter(e=>!invalid.includes(e));\r\n        }\r\n        if (diff.removed.length === 0 && diff.added.length === invalid.length) return true;\r\n        SetFieldAction.new(c.data, 'extends', ptrs, \"\", true);\r\n        return true;\r\n    }\r\n\r\n    add_extends(val: PackArr<this[\"extends\"]>): void { this.cannotCall('add_extends'); }\r\n    get_add_extends(val: PackArr<this[\"extends\"]>, context: Context): this['add_extends'] {\r\n        return ((val: string[])=>this.impl_add_extends(val as any, context)) as any;\r\n    }\r\n    impl_add_extends(val: PackArr<this[\"extends\"]>, context: Context): void {\r\n        if (!val) val = [];\r\n        else if (!Array.isArray(val)) val = [val];\r\n        if (!val.length) return;\r\n        let ptrs = [...new Set(val.map((val) => { return val && Pointers.from(val) }).filter(e=>!!e && !context.data.extends.includes(e)))];\r\n\r\n        ptrs = ptrs.filter(ptr => this.get_canExtend(context)(ptr as any, {} as any));\r\n        if (!ptrs.length) return;\r\n        // todo: extendedby? or make it derived from pointedby\r\n        SetFieldAction.new(context.data, 'extends', [...context.data.extends, ...ptrs], '', true);\r\n    }\r\n\r\n    protected remove_extends(val: PackArr<this[\"extends\"]> | number | number[], context: Context): void {\r\n        if (!val) val = [];\r\n        else if (!Array.isArray(val)) val = [val];\r\n        if (!val.length) return;\r\n        let finalVal: D[\"extends\"];\r\n        if (typeof val[0] === \"number\") { finalVal = context.data.extends.filter((elem,index,arr)=> { return (val as any[]).includes(index); }); }\r\n        else {\r\n            finalVal = [...context.data.extends];\r\n            let ptrs: Pointer<DClass> = Pointers.from(val as PackArr<this[\"extends\"]>) as any;\r\n            for (let v of ptrs) { U.arrayRemoveAll(finalVal, v); }\r\n        }\r\n        SetFieldAction.new(context.data, 'extends', finalVal, '', true);\r\n    }\r\n\r\n    protected get_extendedBy(context: Context): this[\"extendedBy\"] {\r\n        return context.data.extendedBy.map((pointer) => {\r\n            return LPointerTargetable.from(pointer)\r\n        });\r\n    }\r\n    protected set_extendedBy(val: PackArr<this[\"extendedBy\"]>, context: Context): boolean {\r\n        if (!val) val = [];\r\n        else if (!Array.isArray(val)) val = [val];\r\n        const ptrs = [...new Set(val.map((val) => { return val && Pointers.from(val) }).filter(e=>!!e))];\r\n        SetFieldAction.new(context.data, 'extendedBy', ptrs, \"\", true);\r\n        return true;\r\n    }\r\n\r\n    protected get_implements(context: Context): this[\"implements\"] { return context.data.implements; }\r\n    protected set_implements(val: this[\"implements\"], context: Context): boolean {\r\n        SetFieldAction.new(context.data, 'implements', val, \"\", true);\r\n        return true;\r\n    }\r\n\r\n    protected get_implementedBy(context: Context): this[\"implementedBy\"] { return context.data.implementedBy; }\r\n    protected set_implementedBy(val: this[\"implementedBy\"], context: Context): boolean {\r\n        SetFieldAction.new(context.data, 'implementedBy', val, \"\", true);\r\n        return true;\r\n    }\r\n\r\n\r\n    public canExtend(superclass: LClass, output: {reason: string, allTargetSuperClasses: LClass[]} = {reason: '', allTargetSuperClasses: []}): boolean {\r\n        this.cannotCall(\"canExtend\"); return false;\r\n    }\r\n\r\n    private get_canExtend(context: Context): (superclass: LClass, output: {reason: string, allTargetSuperClasses: LClass[]}) => boolean {\r\n        return (superclass: LClass, output: {reason: string, allTargetSuperClasses: LClass[]} =\r\n            {reason: '', allTargetSuperClasses: []}) => this._canExtend(context, superclass, output);\r\n    }\r\n\r\n    public isExtending(superclass: Pack1<LClass>, directly: boolean = false): boolean { return this.cannotCall(\"isExtending\"); }\r\n    public isSubclassOf(superclass: Pack1<LClass>, directly: boolean = false): boolean { return this.cannotCall(\"isSubclassOf\"); }\r\n    __info_of__isSubclassOf: Info = {type: \"(superclass: Pointer | LClass, directly: boolean = false) => boolean\", txt: \"Alias for isExtending\"};\r\n    __info_of__isExtending: Info = {type: \"(superclass: Pointer | LClass, directly: boolean = false) => boolean\",\r\n        txt:<div>Tells if \"this\" is a subclass of the \"superclass\" parameter.\r\n            <br/>- If \"directly\" is set to true, it will only include direct subclassing as in \"class A extends C\" not considering chains.\r\n            <br/>    If \"directly\" is set to true: \"class A extends B\" & \"Class B extends C\". In that case A.isExtending(C, true) will return false.</div>};\r\n\r\n    private get_isSubclassOf(c: Context, plusThis: boolean = true): this[\"isExtending\"] { return this.get_isExtending(c, plusThis); }\r\n    private get_isExtending(c: Context, plusThis: boolean = true): this[\"isExtending\"] {\r\n        return (superclass: Pack1<LClass>, directly: boolean = false): boolean => {\r\n            let ptr = Pointers.from(superclass);\r\n            if (directly) return c.data.extends.includes(ptr);\r\n            return this.get_superclasses(c, plusThis).map(classe=>classe.id).includes(ptr);\r\n        }\r\n    }\r\n\r\n    private get_superclasses(context: Context, plusThis: boolean = false): LClass[] {\r\n        let i: number;\r\n        const thiss: LClass = context.proxyObject;\r\n        const visited: Dictionary<Pointer, LClass> = {};\r\n        let queue: LClass[] = thiss.extends;\r\n        if (plusThis) queue = [thiss, ...queue];\r\n        const ret: LClass[] = [];\r\n        for (i = 0; i < queue.length; i++) {\r\n            let elem: LClass = queue[i];\r\n            if (visited[elem.id]) continue;\r\n            visited[elem.id] = elem;\r\n            ret.push(elem);\r\n            queue.push(...elem.extends);\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    private get_allSubClasses(context: Context, plusThis: boolean = false, state?: DState): LClass[] {\r\n        const thiss: LClass = context.proxyObject;\r\n        let extendedBy = thiss.extendedBy;\r\n        let ebyIDS = extendedBy.map(e => e.id);\r\n        /* old version, remade longer but more efficient\r\n        const set: Set<LClass> = plusThis ? new Set<LClass>([thiss.id, ...ebyIDS]) : new Set(ebyIDS);\r\n        for (let i = 0; i < extendedBy.length; i++) { U.SetMerge(true, set, extendedBy[i].allSubClasses.map(e=>e.id)); }*/\r\n        let parsedSubclasses: Dictionary<Pointer, DClass> = {}\r\n        parsedSubclasses[context.data.id] = context.data;\r\n        let stack: DClass[] = [context.data];\r\n        if (!state && !context.data.extendedBy?.length) state = store.getState();\r\n        while (stack.length) {\r\n            let newstack: DClass[] = [];\r\n            for (let d of stack) {\r\n                for (let sid of d.extendedBy) {\r\n                    if (!sid || parsedSubclasses[sid]) continue;\r\n                    let d: DClass = DClass.from(sid, state);\r\n                    if (!d) continue;\r\n                    parsedSubclasses[sid] = d;\r\n                    newstack.push(d);\r\n                }\r\n            }\r\n            stack = newstack;\r\n        }\r\n        if (!plusThis) delete parsedSubclasses[context.data.id];\r\n        return Object.values(parsedSubclasses).map(d=>LPointerTargetable.fromD(d)); }\r\n\r\n\r\n    private _canExtend(c: Context, superclass: LClass, output: {reason: string, allTargetSuperClasses: LClass[]} = {reason: '', allTargetSuperClasses: []}): boolean {\r\n        if (!output) output = {allTargetSuperClasses:[]} as any;\r\n        superclass = superclass && LPointerTargetable.wrap(superclass) as any;\r\n        if (!superclass) { output.reason = 'Invalid extend target: ' + superclass; return false; }\r\n        let sealed = superclass.sealed || [];\r\n        if (sealed.length) {\r\n            let inSealed = false;\r\n            for (let allowed of sealed) if (allowed && allowed.isSubClassOf(c.proxyObject)) { inSealed = true; break; }\r\n            if (!inSealed) {\r\n                output.reason = 'sealed on attempted superclass';\r\n                return false;\r\n            }\r\n        }\r\n        if (superclass.final) {\r\n            output.reason = 'final on attempted superclass';\r\n            return false;\r\n        }\r\n        const thiss: LClass = c.proxyObject;\r\n        if (superclass.id === thiss.id) { output.reason = 'Classes cannot extend themselves.'; return false; }\r\n        // todo: se diversi proxy dello stesso oggetto sono considerati diversi questo fallisce, in tal caso fai thiss.extends.map( l => l.id).indexof(superclass.id)\r\n        if (thiss.extends.map(sc=>sc.id).indexOf(superclass.id) >= 0) { output.reason = 'Target class is already directly extended.'; return false; }\r\n        output.allTargetSuperClasses = superclass.superclasses;\r\n        if (thiss.superclasses.map(sc=> sc.id).indexOf(superclass.id) >= 0) { output.reason = 'Target class is already indirectly extended.'; return false; }\r\n        if (output.allTargetSuperClasses.map(sc=>sc.id).indexOf(thiss.id) >= 0) { output.reason = 'Cannot set this extend, it would cause a inheritance loop.'; return false; }\r\n        if (thiss.interface && !superclass.interface) { output.reason = 'An interface cannot extend a class.'; return false; }\r\n        // ora verifico se causa delle violazioni di override (attibuti omonimi string e boolean non possono overridarsi)\r\n        let i: number;\r\n        let j: number;\r\n        let children: LOperation[] =  thiss.operations; //[...thiss.getBasicOperations()];\r\n        let superchildren: LOperation[] = superclass.operations; //[...superclass.getBasicOperations()];\r\n        for (i = 0; i < children.length; i++) {\r\n            let op: LOperation = children[i];\r\n            for (j = 0; j < superchildren.length; j++){\r\n                let superchild: LOperation = superchildren[j];\r\n                if (op.name !== superchild.name) continue;\r\n                if (op._canOverride(superchild) || op._canPolymorph(superchild)) continue;\r\n                output.reason = 'Marked homonymous operations cannot override nor polymorph each others.';\r\n                setTimeout( () => {\r\n                    op._mark(true, superchild, 'override'); //  mark op && superchildren\r\n                    setTimeout( () => { op._mark(false, superchild, 'override'); }, 3000); // unmark\r\n                }, 1);\r\n                return false;\r\n            }\r\n        }\r\n        return true; }\r\n\r\n    private _isExtending(context: Context, superclass: LClass, orEqual: boolean = true): boolean {\r\n        if (!superclass) return false;\r\n        return this.get_superclasses(context, orEqual).includes(superclass); }\r\n\r\n    private add_Extends(context: Context, superclass: LClass, force: boolean = false): boolean {\r\n        let out: {reason: string, allTargetSuperClasses: LClass[]} = {reason: '', allTargetSuperClasses: []};\r\n        const thiss: LClass = context.proxyObject;\r\n        if (!force && !this._canExtend(context, superclass, out)) {  return false; }\r\n        SetFieldAction.new(thiss.__raw, 'extends', [superclass.id], '+=', true);\r\n        SetFieldAction.new(superclass.__raw, 'extendedBy', [thiss.id], '+=', true);\r\n        // const extendChildren: LClass[] =  [thiss, ...thiss.superclasses];\r\n        // console.log('calculateViolationsExtend children:'  + extendChildren, this);\r\n        // for (let extChild of extendChildren) { extChild._checkViolations(false); } // after instances have their meta-class changed, they might need to change shape or values.\r\n        return true; }\r\n\r\n    unsetExtends(superclass: LClass): void { return this.cannotCall('unsetExtends'); }\r\n    get_unsetExtends(c: Context, superclass: LClass): (superclass: LClass)=>void {\r\n        return (superclass: LClass)=>{\r\n            superclass = LPointerTargetable.wrap(superclass) as any;\r\n            if (!superclass) return;\r\n            console.log('UnsetExtend:', c, superclass);\r\n            // todo: when Object is loaded in m3, set him there for easy access.\r\n            //  if (superclass.id === LClass.genericObjectid) { Log.w(true, 'Cannot un-extend \"Object\"'); return; }\r\n            const thiss: LClass = c.proxyObject;\r\n            let superclassid = superclass.id;\r\n            let extendsarr = c.data.extends;\r\n            let index: number = extendsarr.indexOf(superclassid);\r\n            if (index < 0) return;\r\n            // let extendedby = superclass.__raw.extendedBy;\r\n            // @ts-ignore\r\n            SetFieldAction.new(thiss, 'extends', superclass.id, '-=', true);\r\n            // @ts-ignore\r\n            SetFieldAction.new(superclass, 'extendedBy', thiss.id, '-=', true);\r\n            // todo: update instances for (i = 0; i < thiss.instances.length; i++) { thiss.instances[i].unsetExtends(superclass); }\r\n            // todo: check violations\r\n            // const extendedby: LClass[] = [thiss, ...thiss.allSubClasses];\r\n            // for (i = 0; i < extendedby.length; i++) { extendedby[i].checkViolations(true); }\r\n        }\r\n    }\r\n\r\n    public instance(): DObject { return this.cannotCall('instance'); }\r\n    /*private get_instance_old(context: Context): () => DObject {\r\n        return () => {\r\n            const dClass: DClass = context.data;\r\n            const lClass: LClass = LClass.from(dClass);\r\n            const dObject = DObject.new(lClass.name.toLowerCase());\r\n            CreateElementAction.new(dObject);\r\n            BEGIN()\r\n            SetFieldAction.new(dObject, 'instanceof', dClass.id, '', true);\r\n            SetFieldAction.new(dClass, 'instances', dObject.id, '+=', true);\r\n\r\n            let father: LClass|undefined = lClass;\r\n            while(father) {\r\n                for(let dFeature of [...father.attributes, ...father.references]) {\r\n                    const dValue = DValue.new(dFeature.name); dValue.value = [U.initializeValue(dFeature.type)];\r\n                    CreateElementAction.new(dValue);\r\n\r\n                    SetFieldAction.new(dValue, 'father', dObject.id, '', true);\r\n                    SetFieldAction.new(dValue, 'instanceof', dFeature.id, '', true);\r\n                    SetFieldAction.new(dFeature, 'instances', dValue.id, '+=', true);\r\n                    SetFieldAction.new(dObject, 'features', dValue.id, '+=', true);\r\n\r\n                }\r\n                father = (father.extends.length > 0) ? father.extends[0] : undefined;\r\n            }\r\n            END()\r\n            return dObject;\r\n        };\r\n    }*/\r\n\r\n}\r\nRuntimeAccessibleClass.set_extend(DClassifier, DClass);\r\nRuntimeAccessibleClass.set_extend(LClassifier, LClass);\r\n@RuntimeAccessible('DDataType')\r\nexport class DDataType extends DPointerTargetable { // extends DClassifier\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // static singleton: LDataType;\r\n    // static logic: typeof LDataType;\r\n    // static structure: typeof DDataType;\r\n\r\n    // inherit redefine\r\n    // instanceClass: EJavaClass // ?\r\n    // isInstance(object: EJavaObject): boolean; ?\r\n    // getClassifierID(): number;\r\n    id!: Pointer<DDataType, 1, 1, LDataType>;\r\n    instanceClassName!: string;\r\n    parent: Pointer<DPackage, 0, 'N', LPackage> = [];\r\n    father!: Pointer<DPackage, 1, 1, LPackage>;\r\n    annotations: Pointer<DAnnotation, 0, 'N', LAnnotation> = [];\r\n    name!: string;\r\n    defaultValue!: Pointer<DObject, 1, 1, LObject>[] | string[];\r\n    // personal\r\n    serializable: boolean = true;\r\n    // usedBy: Pointer<DAttribute, 0, 'N', LAttribute> = [];\r\n\r\n\r\n    public static new(name?: DNamedElement[\"name\"], father?: Pointer, persist: boolean = true): DDataType {\r\n        Log.exx(\"DDataType is abstract, cannot instantiate\");\r\n        return null as any;\r\n        // if (!name) name = this.defaultname(\"datatype_\", father);\r\n        // return new Constructors(new DDataType('dwc'), father, persist, undefined).DPointerTargetable().DModelElement().DNamedElement(name).DClassifier().DDataType().end();\r\n    }\r\n}\r\n\r\n@Abstract\r\n@RuntimeAccessible('LDataType')\r\nexport class LDataType<Context extends LogicContext<DDataType> = any, C extends Context = Context> extends LClassifier { // extends DClassifier\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    public __raw!: DDataType;\r\n    id!: Pointer<DDataType, 1, 1, LDataType>;\r\n    // static singleton: LDataType;\r\n    // static logic: typeof LDataType;\r\n    // static structure: typeof DDataType;\r\n\r\n    // inherit redefine\r\n    // instanceClass: EJavaClass // ?\r\n    // isInstance(object: EJavaObject): boolean; ?\r\n    // getClassifierID(): number;\r\n    instanceClassName!: string;\r\n    parent!: LPackage[];\r\n    father!: LPackage;\r\n    annotations!: LAnnotation[];\r\n    name!: string;\r\n    namespace!: string;\r\n    defaultValue!: LObject[] | string[];\r\n    isPrimitive!: false;\r\n    isClass!: false;\r\n    isEnum!: true;\r\n    // personal\r\n    serializable!: boolean;\r\n\r\n\r\n    protected get_serializable(context: Context): this[\"serializable\"] { return context.data.serializable; }\r\n    protected set_serializable(val: this[\"serializable\"], context: Context): boolean {\r\n        SetFieldAction.new(context.data, 'serializable', val);\r\n        return true;\r\n    }\r\n\r\n}\r\n\r\nRuntimeAccessibleClass.set_extend(DClassifier, DDataType);\r\nRuntimeAccessibleClass.set_extend(LClassifier, LDataType);\r\n@RuntimeAccessible('DStructuralFeature')\r\nexport class DStructuralFeature extends DPointerTargetable { // DTypedElement\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // static singleton: LStructuralFeature;\r\n    // static logic: typeof LStructuralFeature;\r\n    // static structure: typeof DStructuralFeature;\r\n\r\n    // inherit redefine\r\n    id!: Pointer<DStructuralFeature, 1, 1, LStructuralFeature>;\r\n    annotations: Pointer<DAnnotation, 0, 'N', LAnnotation> = [];\r\n    parent: Pointer<DClass, 0, 'N', LClass> = [];\r\n    father!: Pointer<DClass, 1, 1, LClass>;\r\n    name!: string;\r\n    type!: Pointer<DClassifier, 1, 1, LClassifier>;\r\n    ordered: boolean = true;\r\n    unique: boolean = true;\r\n    lowerBound: number = 0;\r\n    upperBound: number = 1;\r\n    many!: boolean;\r\n    required!: boolean;\r\n    // personal\r\n    instances: Pointer<DValue, 0, 'N', LValue> = [];\r\n    changeable: boolean = true;\r\n    volatile: boolean = true;\r\n    transient: boolean = false;\r\n    unsettable: boolean = false;// if the feature can be \"unsetted\" aka undefined/deleted ?\r\n    allowCrossReference!:boolean;\r\n    public derived!: boolean;\r\n    /*protected */derived_read?: string;\r\n    /*protected */derived_write?: string;\r\n    /*protected*/ __info_of__derived: Info = {type: 'string', txt:'A ECore flag to signal the values of this feature depend on other features.\\n' +\r\n            'To make it usable at runtime in jjodel check derived_read and derived_write.'}\r\n    /*protected*/ __info_of__derived_read: Info = {type: 'string', txt:'A function in string format with 2 or less attributes: (data, oldValue).\\n' +\r\n            '- data is the LValue hosting this derived feature\\n' +\r\n            '- originalValues are the current **non-derived** values actually memorized in the data.values\\n'+\r\n            'The mandatory return value of this function will be returned when attempted to read data.values.'}\r\n    /*protected*/ __info_of__derived_write: Info = {type: 'string', txt:'A function in string format with 3 or less attributes: (value, data, oldValue).\\n' +\r\n            '- value is the value currently attempted to be set, which triggered the function call.\\n' +\r\n            '- data is the LValue hosting this derived feature\\n' +\r\n            '- originalValues are the current **non-derived** values actually memorized in the data.values\\n'+\r\n            'The optional return value of this function will be stored inside data, allowing for hybrid dependency-persistant features' +\r\n            '\\n or for a feature \"depending on itself\". like uppercasing his values before setting them.'}\r\n    defaultValue!: (Pointer<DObject, 1, 1, LObject> | PrimitiveType)[];\r\n\r\n    public static new(name?: DNamedElement[\"name\"], type?: DTypedElement[\"type\"], father?: Pointer, persist: boolean = true): DStructuralFeature {\r\n        Log.exx(\"DStructuralFeature is abstract, cannot instantiate\");\r\n        return null as any;\r\n        // if (!name) name = this.defaultname(\"feature \", father);\r\n        // return new Constructors(new DStructuralFeature('dwc'), father, persist, undefined).DPointerTargetable().DModelElement().DNamedElement(name).DTypedElement(type).DStructuralFeature().end();\r\n    }\r\n    // getFeatureID(): number;\r\n    // getContainerClass(): EJavaClass\r\n}\r\n\r\n@Abstract\r\n@RuntimeAccessible('LStructuralFeature')\r\nexport class LStructuralFeature<Context extends LogicContext<DStructuralFeature> = any,\r\n    C extends Context = Context, D extends DStructuralFeature = DStructuralFeature>  extends LTypedElement { // DTypedElement\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    public __raw!: DStructuralFeature;\r\n    id!: Pointer<DStructuralFeature, 1, 1, LStructuralFeature>;\r\n    // static singleton: LStructuralFeature;\r\n    // static logic: typeof LStructuralFeature;\r\n    // static structure: typeof DStructuralFeature;\r\n\r\n    // inherit redefine\r\n    annotations!: LAnnotation[];\r\n    parent!: LClass[];\r\n    father!: LClass;\r\n    name!: string;\r\n    namespace!: string;\r\n    type!: LClassifier;\r\n    ordered: boolean = true;\r\n    unique: boolean = true;\r\n    lowerBound: number = 0;\r\n    upperBound: number = 1;\r\n    many!: boolean;\r\n    required!: boolean;\r\n    public derived!: boolean;\r\n    /*protected */derived_read?: string;\r\n    /*protected */derived_write?: string;\r\n    /*protected*/ __info_of__derived: Info = {type: 'string', txt:'A ECore flag to signal the values of this feature depend on other features.\\n' +\r\n            'To make it usable at runtime in jjodel check derived_read and derived_write.'}\r\n    /*protected*/ __info_of__derived_read: Info = {type: 'string', txt:'A function in string format with 2 or less attributes: (data, oldValue).\\n' +\r\n            '- data is the LValue hosting this derived feature\\n' +\r\n            '- originalValues are the current **non-derived** values actually memorized in the data.values\\n'+\r\n            'The mandatory return value of this function will be returned when attempted to read data.values.'}\r\n    /*protected*/ __info_of__derived_write: Info = {type: 'string', txt:'A function in string format with 3 or less attributes: (value, data, oldValue).\\n' +\r\n            '- value is the value currently attempted to be set, which triggered the function call.\\n' +\r\n            '- data is the LValue hosting this derived feature\\n' +\r\n            '- originalValues are the current **non-derived** values actually memorized in the data.values\\n'+\r\n            'The optional return value of this function will be stored inside data, allowing for hybrid dependency-persistant features' +\r\n            '\\n or for a feature \"depending on itself\". like uppercasing his values before setting them.'}\r\n    // personal\r\n    instances!: LValue[];\r\n    changeable!: boolean;\r\n    volatile!: boolean;\r\n    transient!: boolean;\r\n    unsettable!: boolean;\r\n    // defaultValueLiteral!: string;\r\n    defaultValue!: (LObject[] | PrimitiveType[]);\r\n    // getFeatureID(): number;\r\n    // getContainerClass(): EJavaClass\r\n    allowCrossReference!:boolean;\r\n\r\n    get_crossReference(c: Context): this['allowCrossReference'] { return this.get_allowCrossReference(c); }\r\n    get_isCrossReference(c: Context): this['allowCrossReference'] { return this.get_allowCrossReference(c); }\r\n    set_crossReference(v: this['allowCrossReference'], c: Context): boolean { return this.set_allowCrossReference(v, c); }\r\n    set_isCrossReference(v: this['allowCrossReference'], c: Context): boolean { return this.set_allowCrossReference(v, c); }\r\n    get_allowCrossReference(c: Context): boolean { return c.data.allowCrossReference; }\r\n    set_allowCrossReference(v: this['allowCrossReference'], c: Context): boolean {\r\n        v = !!v;\r\n        if (v !== c.data.allowCrossReference) SetFieldAction.new(c.data, 'allowCrossReference', v);\r\n        return true;\r\n    }\r\n\r\n    validTargetsJSX!: JSX.Element[];\r\n    get_validTargetsJSX(c: Context): this['validTargetsJSX'] {\r\n        let opts: MultiSelectOptGroup[] = [];\r\n        this.get_validTargets(c, opts);\r\n        return UX.options(opts);\r\n    }\r\n    validTargetOptions!: MultiSelectOptGroup[];\r\n    get_validTargetOptions(c: Context): this['validTargetOptions'] {\r\n        let opts: MultiSelectOptGroup[] = [];\r\n        this.get_validTargets(c, opts);\r\n        return opts;\r\n    }\r\n    validTargets!: (LObject | LEnumLiteral)[];\r\n    get_validTargets(c: Context, out?: MultiSelectOptGroup[]): this['validTargets'] {\r\n        let addClasses: boolean = false;\r\n        let addModels: boolean = false;\r\n        let addEnums: boolean = false;\r\n        let addPrimitives: boolean = false;\r\n        let addReturnTypes: boolean = false;\r\n        let isCrossRef = this.get_isCrossReference(c);\r\n        let d = c.data;\r\n        switch (d.className){\r\n            case DModel.cname:     addModels = true; break;\r\n            case DReference.cname: addClasses = true; break;\r\n            case DAttribute.cname:              addPrimitives = addEnums = true; break;\r\n            case DParameter.cname: addClasses = addPrimitives = addEnums = true; break;\r\n            case DOperation.cname: addClasses = addPrimitives = addEnums = addReturnTypes = true; break;\r\n        }\r\n        let m2: LModel = this.get_model(c);\r\n        let map = (object: LNamedElement): MultiSelectOption => {\r\n            let fname = object.fullname;\r\n            return {value:object.id, label: isCrossRef ? fname : object.name, title: object.fullname}\r\n        };\r\n        let map2 = (object: LNamedElement): MultiSelectOption => {\r\n            let name = object.name;\r\n            return {value:object.id, label: name, title: name}\r\n        };\r\n        let sort = (a:MultiSelectOption, b: MultiSelectOption) => (a.label > b.label ? +1 : -1);\r\n        let validClasses: LClass[] = [];\r\n        let validEnums: LEnumerator[] = [];\r\n        let validPrimitives: LClass[] = [];\r\n        let validModels: LModel[] = [];\r\n        let state: DState | null = null;\r\n        if (addModels) {\r\n            if (!state) state = store.getState();\r\n            validModels = LPointerTargetable.fromPointer(state.m2models);\r\n            if (out) out.push({label: 'Models', options: validModels.map(map2).sort(sort)});\r\n        }\r\n        if (addPrimitives) {\r\n            if (!state) state = store.getState();\r\n            validPrimitives = LPointerTargetable.fromPointer(state.primitiveTypes);\r\n        }\r\n        if (addReturnTypes) {\r\n            if (!state) state = store.getState();\r\n            U.arrayMergeInPlace(validPrimitives, LPointerTargetable.fromPointer(state.returnTypes));\r\n        }\r\n        if (out && validPrimitives.length) out.push({label: 'Primitives', options: validPrimitives.map(map2).sort(sort)});\r\n\r\n        if (addClasses) {\r\n            let m = this.get_model(c);\r\n            let pkgs = isCrossRef ? m.allCrossSubPackages : m.allSubPackages;\r\n            if (out) for (let pkg of pkgs){\r\n                let classes = pkg.classes;\r\n                if (classes.length === 0) continue;\r\n                out.push({label: 'Classes ('+pkg.fullname+')', options: classes.map(map2).sort(sort)});\r\n                U.arrayMergeInPlace(validClasses, classes);\r\n            } else validClasses = (isCrossRef ? m2.crossClasses : m2.classes);\r\n        }\r\n        if (addEnums) {\r\n            let m = this.get_model(c);\r\n            let pkgs = isCrossRef ? m.allCrossSubPackages : m.allSubPackages;\r\n            if (out) for (let pkg of pkgs){\r\n                let enums = pkg.enumerators;\r\n                if (enums.length === 0) continue;\r\n                out.push({label: 'Enumerators ('+pkg.fullname+')', options: enums.map(map2).sort(sort)});\r\n                U.arrayMergeInPlace(validEnums, enums);\r\n            } else validEnums = (isCrossRef ? m2.crossEnumerators : m2.enumerators);\r\n            //if (out) out.push({label: 'Enumerators', options: validEnums.map(map).sort(sort)});\r\n        }\r\n        return U.arrayMergeInPlace(validClasses as any[], validPrimitives, validEnums, validModels);\r\n    }\r\n    protected get_instances(context: Context): this[\"instances\"] {\r\n        return context.data.instances.map((pointer) => {\r\n            return LPointerTargetable.from(pointer)\r\n        });\r\n    }\r\n\r\n    protected set_instances(val: PackArr<this[\"instances\"]>, context: Context): boolean {\r\n        const list = val.map((lItem) => { return Pointers.from(lItem) });\r\n        SetFieldAction.new(context.data, 'instances', list, \"\", true);\r\n        return true;\r\n    }\r\n\r\n    protected get_changeable(context: Context): this[\"changeable\"] { return context.data.changeable; }\r\n    protected set_changeable(val: this[\"changeable\"], context: Context): boolean {\r\n        SetFieldAction.new(context.data, 'changeable', val);\r\n        return true;\r\n    }\r\n\r\n    protected get_volatile(context: Context): this[\"volatile\"] { return context.data.volatile; }\r\n    protected set_volatile(val: this[\"volatile\"], context: Context): boolean {\r\n        SetFieldAction.new(context.data, 'volatile', val);\r\n        return true;\r\n    }\r\n\r\n    protected get_transient(context: Context): this[\"transient\"] { return context.data.transient; }\r\n    protected set_transient(val: this[\"transient\"], context: Context): boolean {\r\n        SetFieldAction.new(context.data, 'transient', val);\r\n        return true;\r\n    }\r\n\r\n    protected get_unsettable(context: Context): this[\"unsettable\"] { return context.data.unsettable; }\r\n    protected set_unsettable(val: this[\"unsettable\"], context: Context): boolean {\r\n        SetFieldAction.new(context.data, 'unsettable', val);\r\n        return true;\r\n    }\r\n\r\n    protected get_derived(context: Context): D[\"derived\"] { return context.data.derived; }\r\n    protected set_derived(val: D[\"derived\"], context: Context): boolean {\r\n        SetFieldAction.new(context.data, 'derived', !!val);\r\n        return true;\r\n    }\r\n    /*\r\n        protected get_defaultValueLiteral(context: Context): this[\"defaultValueLiteral\"] { return context.data.defaultValueLiteral; }\r\n        protected set_defaultValueLiteral(val: this[\"defaultValueLiteral\"], context: Context): boolean {\r\n            SetFieldAction.new(context.data, 'defaultValueLiteral', val, \"\", false);\r\n            return true;\r\n        }*/\r\n}\r\nRuntimeAccessibleClass.set_extend(DTypedElement, DStructuralFeature);\r\nRuntimeAccessibleClass.set_extend(LTypedElement, LStructuralFeature);\r\n\r\n@Instantiable // DValue\r\n@Leaf\r\n@RuntimeAccessible('DReference')\r\nexport class DReference extends DPointerTargetable { // DStructuralFeature\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // static singleton: LReference;\r\n    // static logic: typeof LReference;\r\n    // static structure: typeof DReference;\r\n\r\n\r\n    // inherit redefine\r\n    id!: Pointer<DReference, 1, 1, LReference>;\r\n    annotations: Pointer<DAnnotation, 0, 'N', LAnnotation> = [];\r\n    name!: string;\r\n    type!: Pointer<DClass, 1, 1, LClass>;\r\n    ordered: boolean = true;\r\n    unique: boolean = true;\r\n    lowerBound: number = 0;\r\n    upperBound: number = 1;\r\n    many!: boolean;\r\n    required!: boolean;\r\n    changeable: boolean = true;\r\n    volatile: boolean = true;\r\n    transient: boolean = false;\r\n    unsettable: boolean = false;\r\n    defaultValueLiteral: string = '';\r\n    parent: Pointer<DClass, 0, 'N', LClass> = [];\r\n    father!: Pointer<DClass, 1, 1, LClass>;\r\n    instances: Pointer<DValue, 0, 'N', LValue> = [];\r\n    defaultValue!: Pointer<DObject, 1, 1, LObject>[];\r\n    allowCrossReference!:boolean;\r\n    public derived!: boolean;\r\n    /*protected */derived_read?: string;\r\n    /*protected */derived_write?: string;\r\n    /*protected*/ __info_of__derived: Info = {type: 'string', txt:'A ECore flag to signal the values of this feature depend on other features.\\n' +\r\n            'To make it usable at runtime in jjodel check derived_read and derived_write.'}\r\n    /*protected*/ __info_of__derived_read: Info = {type: 'string', txt:'A function in string format with 2 or less attributes: (data, oldValue).\\n' +\r\n            '- data is the LValue hosting this derived feature\\n' +\r\n            '- originalValues are the current **non-derived** values actually memorized in the data.values\\n'+\r\n            'The mandatory return value of this function will be returned when attempted to read data.values.'}\r\n    /*protected*/__info_of__derived_write: Info = {type: 'string', txt:'A function in string format with 3 or less attributes: (value, data, oldValue).\\n' +\r\n            '- value is the value currently attempted to be set, which triggered the function call.\\n' +\r\n            '- data is the LValue hosting this derived feature\\n' +\r\n            '- originalValues are the current **non-derived** values actually memorized in the data.values\\n'+\r\n            'The optional return value of this function will be stored inside data, allowing for hybrid dependency-persistant features' +\r\n            '\\n or for a feature \"depending on itself\". like uppercasing his values before setting them.'}\r\n\r\n    // personal\r\n    rootable?:boolean;\r\n    composition: boolean = false;\r\n    aggregation: boolean = false; // exist in uml but not in ecore\r\n    container: boolean = false;\r\n    __info_of__container: Info = {type: 'boolean', txt: \"A reference is a container if it has an opposite that is a containment.\"};\r\n    opposite?: Pointer<DReference>;\r\n    target: Pointer<DClass, 0, 'N', LClass> = [];\r\n    edges: Pointer<DEdge, 0, 'N', LEdge> = [];\r\n\r\n    public static new(name?: DReference[\"name\"], type?: DReference[\"type\"], father?: DReference[\"father\"], persist: boolean = true): DReference {\r\n        if (!type) type = father // default type is self-reference\r\n        if (!name) name = this.defaultname(\"ref_\", father);\r\n        return new Constructors(new DReference('dwc'), father, persist, undefined).DPointerTargetable().DModelElement()\r\n            .DNamedElement(name).DTypedElement(type).DStructuralFeature().DReference().end();\r\n    }\r\n\r\n    static new2(setter: Partial<ObjectWithoutPointers<DReference>>, father: DReference[\"father\"], type?: DReference[\"type\"], name?: DReference[\"name\"]): DReference {\r\n        if (!name) name = this.defaultname((name || \"ref_\"), father);\r\n        return new Constructors(new DReference('dwc'), father, true, undefined).DPointerTargetable().DModelElement()\r\n            .DNamedElement(name).DTypedElement(type).DStructuralFeature().DReference()\r\n            .end((d) => { Object.assign(d, setter); });\r\n    }\r\n\r\n    static new3(a: Partial<ReferencePointers>, callback: undefined | ((d: DReference, c: Constructors) => void), persist: boolean = true): DReference {\r\n        if (!a.name) a.name = this.defaultname(\"ref_\", a.father);\r\n        return new Constructors(new DReference('dwc'), a.father, persist, undefined, a.id).DPointerTargetable().DModelElement()\r\n            .DPointerTargetable().DModelElement().DNamedElement(a.name)\r\n            .DTypedElement(a.type).DStructuralFeature().DReference()\r\n            .end(callback);\r\n    }\r\n\r\n}\r\n\r\n@Instantiable // LValue\r\n@Leaf\r\n@RuntimeAccessible('LReference')\r\nexport class LReference<Context extends LogicContext<DReference> = any, C extends Context = Context, D extends DReference = DReference>  extends LStructuralFeature {\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    public __raw!: DReference;\r\n    id!: Pointer<DReference, 1, 1, LReference>;\r\n    // static singleton: LReference;\r\n    // static logic: typeof LReference;\r\n    // static structure: typeof DReference;\r\n\r\n    // inherit redefine\r\n    annotations!: LAnnotation[];\r\n    name!: string;\r\n    namespace!: string;\r\n    type!: LClass;\r\n    ordered!: boolean;\r\n    unique!: boolean;\r\n    lowerBound!: number;\r\n    upperBound!: number;\r\n    many!: boolean;\r\n    required!: boolean;\r\n    changeable!: boolean;\r\n    volatile!: boolean;\r\n    transient!: boolean;\r\n    unsettable!: boolean;\r\n    allowCrossReference!:boolean;\r\n    public derived!: boolean;\r\n    /*protected */derived_read?: string;\r\n    /*protected */derived_write?: string;\r\n    /*protected */__info_of__derived: Info = {type: 'string', txt:'A ECore flag to signal the values of this feature depend on other features.\\n' +\r\n            'To make it usable at runtime in jjodel check derived_read and derived_write.'}\r\n    /*protected */__info_of__derived_read: Info = {type: 'string', txt:'A function in string format with 2 or less attributes: (data, oldValue).\\n' +\r\n            '- data is the LValue hosting this derived feature\\n' +\r\n            '- originalValues are the current **non-derived** values actually memorized in the data.values\\n'+\r\n            'The mandatory return value of this function will be returned when attempted to read data.values.'}\r\n    /*protected */__info_of__derived_write: Info = {type: 'string', txt:'A function in string format with 3 or less attributes: (value, data, oldValue).\\n' +\r\n            '- value is the value currently attempted to be set, which triggered the function call.\\n' +\r\n            '- data is the LValue hosting this derived feature\\n' +\r\n            '- originalValues are the current **non-derived** values actually memorized in the data.values\\n'+\r\n            'The optional return value of this function will be stored inside data, allowing for hybrid dependency-persistant features' +\r\n            '\\n or for a feature \"depending on itself\". like uppercasing his values before setting them.'}\r\n    defaultValueLiteral!: string;\r\n    parent!: LClass[];\r\n    father!: LClass;\r\n    instances!: LValue[];\r\n    defaultValue!: LObject[];\r\n\r\n    // personal\r\n    composition!: boolean; // aggregation || containment\r\n    aggregation!: boolean;\r\n    containment!: boolean;\r\n    container!: boolean;\r\n\r\n    rootable?:boolean;\r\n    __info_of__rootable: Info = {type:\"boolean | undefined\",\r\n        txt: \"if missing, only classes not contained, not abstract and not interface can be a model root. if present this dictates it.\"};\r\n    __info_of__composition: Info = {type:\"boolean\",\r\n        txt: \"Defines a \\\"part of\\\" relationship where the target cannot exist without the source. Building -> Room \\\"A Room cannot exist without a Building\\\"\"};\r\n    __info_of__aggregation: Info = {type:\"boolean\",\r\n        txt: \"Defines a \\\"part of\\\" relationship where the target can exist without the source. Building -> Student \\\"A Student can exist outside a Building\\\"\"};\r\n    opposite?: LReference;\r\n    // target!: LClass[]; replaced by type\r\n    edges!: LEdge[];\r\n\r\n\r\n\r\n    protected generateEcoreJson_impl(context: Context, loopDetectionObj: Dictionary<Pointer, DModelElement> = {}): Json {\r\n        loopDetectionObj[context.data.id] = context.data;\r\n        const model: GObject = {};\r\n        const d = context.data;\r\n        const l = context.proxyObject;\r\n        model[ECoreReference.xsitype] = 'ecore:EReference';\r\n        model[ECoreReference.eType] = l.type.typeEcoreString;\r\n        model[ECoreReference.namee] = d.name;\r\n        if (d.lowerBound != null && !isNaN(+d.lowerBound)) { model[ECoreReference.lowerbound] = +d.lowerBound; }\r\n        if (d.upperBound != null && !isNaN(+d.upperBound)) { model[ECoreReference.upperbound] = +d.upperBound; }\r\n        let cont = d.aggregation || d.composition;\r\n        if (cont != null) { model[ECoreReference.containment] = cont; }\r\n        if (d.container != null) { model[ECoreReference.container] = d.container; }\r\n        return model; }\r\n\r\n    public duplicate(deep: boolean = true): this {\r\n        return this.cannotCall( ((this.constructor as typeof RuntimeAccessibleClass).cname || this.constructor.name) + \"duplicate()\"); }\r\n    protected get_duplicate(context: Context): ((deep?: boolean) => LReference) {\r\n        return (deep: boolean = false) => {\r\n            BEGIN()\r\n            let le: LReference = context.proxyObject.father.addReference(context.data.name, context.data.type);\r\n            let de: D = le.__raw as D;\r\n\r\n            de.many = context.data.many;\r\n            de.lowerBound = context.data.lowerBound;\r\n            de.upperBound = context.data.upperBound;\r\n            de.ordered = context.data.ordered;\r\n            de.required = context.data.required;\r\n            de.unique = context.data.unique;\r\n            de.changeable = context.data.changeable;\r\n            de.container = context.data.container;\r\n            de.composition = context.data.composition;\r\n            de.aggregation = context.data.aggregation;\r\n            de.defaultValueLiteral = context.data.defaultValueLiteral;\r\n            de.derived = context.data.derived;\r\n            de.transient = context.data.transient;\r\n            de.unsettable = context.data.unsettable;\r\n            de.volatile = context.data.unsettable;\r\n            let we: WReference = le as any;\r\n            we.opposite = context.data.opposite || undefined;\r\n            we.defaultValue = context.data.defaultValue;\r\n            we.type = context.data.type;\r\n            we.annotations = deep ? context.proxyObject.annotations.map(lchild => lchild.duplicate(deep).id) : context.data.annotations;\r\n            // we.target = deep ? context.proxyObject.target.map(lchild => lchild.duplicate(deep).id) : context.data.target;\r\n            END()\r\n            return le; }\r\n    }\r\n\r\n    protected set_type(val: Pack1<this[\"type\"]>, context: Context): boolean {\r\n        super.set_type(val, context);\r\n        return true;\r\n    }\r\n\r\n    public addClass(name?: DClass[\"name\"], isInterface?: DClass[\"interface\"], isAbstract?: DClass[\"abstract\"], isPrimitive?: DClass[\"isPrimitive\"],\r\n                    isPartial?: DClass[\"partial\"], partialDefaultName?: DClass[\"partialdefaultname\"]): LClass {\r\n        return this.cannotCall(\"LReference.addClass\"); }\r\n    protected get_addClass(context: Context): this[\"addClass\"] {\r\n        return (name?: DClass[\"name\"], isInterface?: DClass[\"interface\"], isAbstract?: DClass[\"abstract\"], isPrimitive?: DClass[\"isPrimitive\"],\r\n                isPartial?: DClass[\"partial\"], partialDefaultName?: DClass[\"partialdefaultname\"]) => {\r\n            BEGIN()\r\n            let dclass = DClass.new(name, isInterface, isAbstract, isPrimitive, isPartial, partialDefaultName, context.proxyObject.package!.id, true);\r\n            // SetFieldAction.new(context.data.id, \"type\", dclass.id);\r\n            this.set_type(dclass.id as any, context);\r\n            END();\r\n            return LPointerTargetable.fromD(dclass);\r\n        } }\r\n\r\n\r\n    get_containment(context: Context): this[\"containment\"] { return context.data.composition || context.data.aggregation; }\r\n    set_containment(val: this[\"containment\"], c: Context, mainkey:'composition'|'aggregation' = 'composition', altkey:'composition'|'aggregation' = 'aggregation'): boolean {\r\n        // return this.cannotSet('containment', 'set aggregation or composition instead');\r\n        val = !!val;\r\n        if (c.data[mainkey] === val) return true;\r\n        TRANSACTION(()=>{\r\n            // set composition and unset aggregation or viceversa\r\n            SetFieldAction.new(c.data, mainkey, val);\r\n            if (val && c.data[altkey]) SetFieldAction.new(c.data, altkey, !val);\r\n            let containedObjects: Dictionary<Pointer, LObject> = {};\r\n            let removedValues: Pointer[] = [];\r\n            let parentChanges: LObject[] = [];\r\n            for (let lval of this.get_instances(c) as LValue[]) {\r\n                // todo: in set_values crop the arr to max upperbound\r\n                let dval = lval.__raw\r\n                let values = dval.values;\r\n                let lmodel = lval.model;\r\n                let dmodel = lmodel.__raw;\r\n                for (let ptr of values) {\r\n                    if (!Pointers.isPointer(ptr)) continue;\r\n                    if (containedObjects[ptr]) {\r\n                        // Log.ee('Cannot activate ' + mainkey+ ' on this reference because some objects are referenced twice in the model')\r\n                        // todo: ask for confirmation if want to abort or delete those values.\r\n                        if (val) {\r\n                            SetFieldAction.new(dval, 'values', ptr as any, '-=', true); // if is containment=true prevent the targets from being contained twice}\r\n                            removedValues.push(ptr);\r\n                            continue;\r\n                        }\r\n                    }\r\n                    // update parent\r\n                    let pointedobj = containedObjects[ptr] = LPointerTargetable.fromPointer(ptr);\r\n                    let newid = (val ? dval.id : dmodel.id) as any;\r\n                    let oldparent = pointedobj.father;\r\n                    if (oldparent?.id === newid) continue;\r\n                    pointedobj.father = newid;\r\n                    parentChanges.push(pointedobj);\r\n                }\r\n            }\r\n            if (removedValues.length || parentChanges.length){\r\n                Log.ww([\r\n                    removedValues.length ? removedValues.length+' values were removed':undefined,\r\n                    parentChanges.length ? parentChanges.length+' parents were changed':undefined\r\n                ].filter(e=>!!e).join(' and ') + ' as result.',//\\n If you want to check chem, write \"containmentSideEffects[\\''+c.data.id+'\\']\" in console.',\r\n                {removedValues, parentChanges}\r\n                );\r\n            }\r\n            //if (!windoww.containmentSideEffects) windoww.containmentSideEffects = {};\r\n            //windoww.containmentSideEffects[c.data.id] = {removedValues, parentChanges};\r\n        });\r\n        return true;\r\n    }\r\n\r\n    protected get_aggregation(context: Context): this[\"aggregation\"] { return context.data.aggregation; }\r\n    protected get_composition(context: Context): this[\"composition\"] { return context.data.composition; }\r\n    /*\r\n    protected get_container(context: Context): this[\"container\"] { return context.data.container; }\r\n    protected set_container(val: this[\"container\"], context: Context): boolean { return SetFieldAction.new(context.data, 'container', val); }*/\r\n\r\n    protected set_aggregation(val: this[\"aggregation\"], c: Context): boolean { return this.set_containment(val, c, 'aggregation', 'composition'); }\r\n    protected set_composition(val: this[\"composition\"], c: Context): boolean { return this.set_containment(val, c, 'composition', 'aggregation'); }\r\n\r\n    protected get_opposite(context: Context): this[\"opposite\"] { return context.data.opposite && LPointerTargetable.from(context.data.opposite); }\r\n    protected set_opposite(val: Pack<LReference | undefined>, context: Context): boolean {\r\n        SetFieldAction.new(context.data, 'opposite', Pointers.from(val) as any as LAnnotation[\"id\"], \"\", true);\r\n        return true;\r\n    }\r\n    /*\r\n        /// todo: why this exist?  why not type?\r\n        protected get_target(context: Context): this[\"target\"] { return context.data.target.map(pointer => LPointerTargetable.from(pointer)); }\r\n        protected set_target(val: PackArr<this[\"target\"]>, context: Context): boolean {\r\n            const list = val.map((lItem) => { return Pointers.from(lItem) });\r\n            SetFieldAction.new(context.data, 'target', list, \"\", true);\r\n            return true;\r\n        }*/\r\n\r\n    protected get_defaultValue(context: Context): this[\"defaultValue\"] { return LPointerTargetable.fromPointer(context.data.defaultValue); }\r\n    protected set_defaultValue(val: PackArr<this[\"defaultValue\"]>, context: Context): boolean {\r\n        // @ts-ignore\r\n        if (!val) (val) = []; else if (!Array.isArray(val)) val = [val];\r\n        let ptrs = Pointers.from(val);\r\n        SetFieldAction.new(context.data, 'defaultValue', ptrs, '', false);\r\n        return true; }\r\n\r\n    protected get_edges(context: Context): this[\"edges\"] {\r\n        return context.data.edges.map((pointer) => {\r\n            return LPointerTargetable.from(pointer)\r\n        });\r\n    }\r\n    protected set_edges(val: PackArr<this[\"edges\"]>, context: Context): boolean {\r\n        const list = val.map((lItem) => { return Pointers.from(lItem) });\r\n        SetFieldAction.new(context.data, 'edges', list, \"\", true);\r\n        return true;\r\n    }\r\n}\r\nRuntimeAccessibleClass.set_extend(DStructuralFeature, DReference);\r\nRuntimeAccessibleClass.set_extend(LStructuralFeature, LReference);\r\nfunction has_opposite(oppositename: string, ...comments: string[]): any {\r\n    // return (c:Constructor, key:string, ):any =>{}\r\n}\r\nfunction obsolete_attribute(...comments: string[]) {\r\n    return undefined as any; // function(c:Constructor, key:string,): any {}\r\n}\r\n\r\n@Leaf\r\n@RuntimeAccessible('DAttribute')\r\nexport class DAttribute extends DPointerTargetable { // DStructuralFeature\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // static singleton: LAttribute;\r\n    // static logic: typeof LAttribute;\r\n    // static structure: typeof DAttribute;\r\n\r\n    // inherit redefine\r\n    id!: Pointer<DAttribute, 1, 1, LAttribute>;\r\n    // @has_opposite(\"father\")\r\n    annotations: Pointer<DAnnotation, 0, 'N', LAnnotation> = [];\r\n    name!: string;\r\n    type!: Pointer<DClassifier, 1, 1, LClassifier>;\r\n    ordered: boolean = true;\r\n    unique: boolean = true;\r\n    lowerBound: number = 0;\r\n    upperBound: number = 1;\r\n    many!: boolean;\r\n    required!: boolean;\r\n    changeable: boolean = true;\r\n    volatile: boolean = true;\r\n    transient: boolean = false;\r\n    unsettable: boolean = false;\r\n    defaultValueLiteral: string = '';\r\n    allowCrossReference!:boolean;\r\n    public derived!: boolean;\r\n    /*protected */derived_read?: string;\r\n    /*protected */derived_write?: string;\r\n    /*protected*/ __info_of__derived: Info = {type: 'string', txt:'A ECore flag to signal the values of this feature depend on other features.\\n' +\r\n            'To make it usable at runtime in jjodel check derived_read and derived_write.'}\r\n    /*protected*/ __info_of__derived_read: Info = {type: 'string', txt:'A function in string format with 2 or less attributes: (data, oldValue).\\n' +\r\n            '- data is the LValue hosting this derived feature\\n' +\r\n            '- originalValues are the current **non-derived** values actually memorized in the data.values\\n'+\r\n            'The mandatory return value of this function will be returned when attempted to read data.values.'}\r\n    /*protected*/ __info_of__derived_write: Info = {type: 'string', txt:'A function in string format with 3 or less attributes: (value, data, oldValue).\\n' +\r\n            '- value is the value currently attempted to be set, which triggered the function call.\\n' +\r\n            '- data is the LValue hosting this derived feature\\n' +\r\n            '- originalValues are the current **non-derived** values actually memorized in the data.values\\n'+\r\n            'The optional return value of this function will be stored inside data, allowing for hybrid dependency-persistant features' +\r\n            '\\n or for a feature \"depending on itself\". like uppercasing his values before setting them.'}\r\n    //@obsolete_attribute()\r\n    parent: Pointer<DClass, 0, 'N', LClass> = [];\r\n\r\n    //@has_opposite(\"attributes\")\r\n    father!: Pointer<DClass, 1, 1, LClass>;\r\n\r\n    //@has_opposite(\"instanceof\")\r\n    instances: Pointer<DValue, 0, 'N', LValue> = [];\r\n    defaultValue!: PrimitiveType[];\r\n\r\n    // personal\r\n    isID: boolean = false; // ? exist in ecore as \"iD\" ?\r\n    isIoT: boolean = false;\r\n\r\n    public static new(name?: DAttribute[\"name\"], type?: DAttribute[\"type\"], father?: DAttribute[\"father\"], persist: boolean = true): DAttribute {\r\n        if (!name) name = this.defaultname(\"attr_\", father);\r\n        if (!type) type = LPointerTargetable.from(Selectors.getFirstPrimitiveTypes()).id; // default type as string\r\n        return new Constructors(new DAttribute('dwc'), father, persist, undefined).DPointerTargetable().DModelElement()\r\n            .DNamedElement(name).DTypedElement(type).DStructuralFeature().DAttribute().end();\r\n    }\r\n    static new2(setter: Partial<ObjectWithoutPointers<DReference>>, father: DAttribute[\"father\"], type?: DAttribute[\"type\"], name?: DAttribute[\"name\"]): DAttribute {\r\n        if (!name) name = this.defaultname((name || \"ref_\"), father);\r\n        return new Constructors(new DAttribute('dwc'), father, true, undefined).DPointerTargetable().DModelElement()\r\n            .DNamedElement(name).DTypedElement(type).DStructuralFeature().DAttribute()\r\n            .end((d) => { Object.assign(d, setter); });\r\n    }\r\n    static new3(a: Partial<AttributePointers>, callback: undefined | ((d: DAttribute, c: Constructors) => void), persist: boolean = true): DAttribute {\r\n        if (!a.name) a.name = this.defaultname(\"attr_\", a.father);\r\n        return new Constructors(new DAttribute('dwc'), a.father, persist, undefined, a.id)\r\n            .DPointerTargetable().DModelElement().DNamedElement(a.name)\r\n            .DTypedElement(a.type).DStructuralFeature().DAttribute()\r\n            .end(callback);\r\n    }\r\n}\r\n\r\n\r\n@Leaf\r\n@Instantiable // (LValue)\r\n@RuntimeAccessible('LAttribute')\r\nexport class LAttribute <Context extends LogicContext<DAttribute> = any, C extends Context = Context, D extends DAttribute = DAttribute> extends LStructuralFeature { // DStructuralFeature\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    public __raw!: DAttribute;\r\n    id!: Pointer<DAttribute, 1, 1, LAttribute>;\r\n    // static singleton: LAttribute;\r\n    // static logic: typeof LAttribute;\r\n    // static structure: typeof DAttribute;\r\n\r\n    // inherit redefine\r\n    annotations!: LAnnotation[];\r\n    name!: string;\r\n    namespace!: string;\r\n    type!: LClassifier;\r\n    ordered!: boolean;\r\n    unique!: boolean;\r\n    lowerBound!: number;\r\n    upperBound!: number;\r\n    many!: boolean;\r\n    required!: boolean;\r\n    changeable!: boolean;\r\n    volatile!: boolean;\r\n    transient!: boolean;\r\n    unsettable!: boolean;\r\n    // defaultValueLiteral!: string;\r\n    defaultValue!: PrimitiveType[];\r\n    parent!: LClass[];\r\n    father!: LClass;\r\n    instances!: LValue[];\r\n\r\n    // personal\r\n    isID: boolean = false; // ? exist in ecore as \"iD\" ?\r\n    isIoT: boolean = false;\r\n    allowCrossReference!:boolean;\r\n\r\n    protected generateEcoreJson_impl(context: Context, loopDetectionObj: Dictionary<Pointer, DModelElement> = {}): Json {\r\n        loopDetectionObj[context.data.id] = context.data;\r\n        const model = {};\r\n        const d = context.data;\r\n        const l = context.proxyObject;\r\n        EcoreParser.write(model, ECoreAttribute.xsitype, 'ecore:EAttribute');\r\n        EcoreParser.write(model, ECoreAttribute.eType, l.type.typeEcoreString);\r\n        EcoreParser.write(model, ECoreAttribute.namee, d.name);\r\n        EcoreParser.write(model, ECoreAttribute.lowerbound, '' + d.lowerBound);\r\n        EcoreParser.write(model, ECoreAttribute.upperbound, '' + d.upperBound);\r\n        return model; }\r\n\r\n\r\n    public duplicate(deep: boolean = true): this {\r\n        return this.cannotCall( ((this.constructor as typeof RuntimeAccessibleClass).cname || this.constructor.name) + \"duplicate()\"); }\r\n    protected get_duplicate(context: Context): ((deep?: boolean) => LAttribute) {\r\n        return (deep: boolean = false) => {\r\n            BEGIN()\r\n            let le: LAttribute = context.proxyObject.father.addAttribute(context.data.name, context.data.type);\r\n            let de: D = le.__raw as D;\r\n            de.many = context.data.many;\r\n            de.lowerBound = context.data.lowerBound;\r\n            de.upperBound = context.data.upperBound;\r\n            de.ordered = context.data.ordered;\r\n            de.required = context.data.required;\r\n            de.unique = context.data.unique;\r\n            de.changeable = context.data.changeable;\r\n            de.defaultValue = context.data.defaultValue;\r\n            de.defaultValueLiteral = context.data.defaultValueLiteral;\r\n            de.derived = context.data.derived;\r\n            de.transient = context.data.transient;\r\n            de.unsettable = context.data.unsettable;\r\n            de.volatile = context.data.volatile;\r\n            de.isID = context.data.isID;\r\n            de.isIoT = context.data.isIoT;\r\n            let we: WAttribute = le as any;\r\n            we.type = context.data.type;\r\n            we.annotations = deep ? context.proxyObject.annotations.map(lchild => lchild.duplicate(deep).id) : context.data.annotations;\r\n            END()\r\n            return le; }\r\n    }\r\n\r\n    public addEnum(...p:Parameters<this[\"addEnumerator\"]>): LEnumerator { return this.addEnumerator(...p); }\r\n    protected get_addEnum(context: Context): this[\"addEnumerator\"] { return this.get_addEnumerator(context); }\r\n    public addEnumerator(name?: DEnumerator[\"name\"], father?: DEnumerator[\"father\"]): LEnumerator { return this.cannotCall(\"Attribute.addEnumerator\"); }\r\n    protected get_addEnumerator(context: Context): this[\"addEnumerator\"] {\r\n        return (name?: DEnumerator[\"name\"], father?: DEnumerator[\"father\"]) => LPointerTargetable.fromD(DEnumerator.new(name, context.proxyObject.package?.id, true)); }\r\n\r\n    protected get_isID(context: Context): this[\"isID\"] { return context.data.isID; }\r\n    protected set_isID(val: this[\"isID\"], context: Context): boolean {\r\n        SetFieldAction.new(context.data, 'isID', val);\r\n        return true;\r\n    }\r\n    protected get_isIoT(context: Context): this[\"isIoT\"] { return context.data.isIoT; }\r\n    protected set_isIoT(val: this[\"isIoT\"], context: Context): boolean {\r\n        TRANSACTION(() => {\r\n            for(const value of context.proxyObject.instances) {\r\n                SetFieldAction.new(value, 'topic', '', '', false);\r\n            }\r\n            SetFieldAction.new(context.data, 'isIoT', val);\r\n        })\r\n        return true;\r\n    }\r\n    protected get_defaultValue(context: Context): this[\"defaultValue\"] { return context.data.defaultValue; }\r\n    protected set_defaultValue(val: unArr<this[\"defaultValue\"]>, context: Context): boolean {\r\n        // @ts-ignore\r\n        if (!val) (val) = []; else if (!Array.isArray(val)) val = [val];\r\n        SetFieldAction.new(context.data, 'defaultValue', val, '', false);\r\n        return true; }\r\n\r\n}\r\nRuntimeAccessibleClass.set_extend(DStructuralFeature, DAttribute);\r\nRuntimeAccessibleClass.set_extend(LStructuralFeature, LAttribute);\r\n\r\n@Leaf\r\n@RuntimeAccessible('DEnumLiteral')\r\nexport class DEnumLiteral extends DPointerTargetable { // DNamedElement\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // static singleton: LAttribute;\r\n    // static logic: typeof LAttribute;\r\n    // static structure: typeof DAttribute;\r\n\r\n    // inherit redefine\r\n    id!: Pointer<DEnumLiteral, 1, 1, LEnumLiteral>;\r\n    parent: Pointer<DEnumerator, 0, 'N', LEnumerator> = [];\r\n    father!: Pointer<DEnumerator, 1, 1, LEnumerator>;\r\n    annotations: Pointer<DAnnotation, 0, 'N', LAnnotation> = [];\r\n    name!: string;\r\n    // personal\r\n    value!: number;\r\n    // ordinal: number=1; replaced by value\r\n    literal!: string;\r\n\r\n    public static new(name?: DNamedElement[\"name\"], value?: DEnumLiteral[\"value\"], father?: Pointer, persist: boolean = true): DEnumLiteral { //vv4\r\n        if (!name) name = this.defaultname(\"literal \", father);\r\n        return new Constructors(new DEnumLiteral('dwc'), father, persist, undefined).DPointerTargetable().DModelElement()\r\n            .DNamedElement(name).DEnumLiteral(value).end();\r\n    }\r\n    static new2(setter: Partial<ObjectWithoutPointers<DEnumLiteral>>, father: DEnumLiteral[\"father\"], name?: DEnumLiteral[\"name\"]): DEnumLiteral {\r\n        if (!name) name = this.defaultname(\"literal \", father);\r\n        return new Constructors(new DEnumLiteral('dwc'), father, true, undefined).DPointerTargetable().DModelElement()\r\n            .DNamedElement(name).DEnumLiteral()\r\n            .end((d) => { Object.assign(d, setter); });\r\n    }\r\n    static new3(a: Partial<LiteralPointers>, callback: undefined | ((d: DEnumLiteral, c: Constructors) => void), persist: boolean = true): DEnumLiteral {\r\n        if (!a.name) a.name = this.defaultname(\"literal_\", a.father);\r\n        return new Constructors(new DEnumLiteral('dwc'), a.father, persist, undefined, a.id)\r\n            .DPointerTargetable().DModelElement().DNamedElement(a.name)\r\n            .DEnumLiteral()\r\n            .end(callback);\r\n    }\r\n}\r\n\r\n@Leaf\r\n@RuntimeAccessible('LEnumLiteral')\r\nexport class LEnumLiteral<Context extends LogicContext<DEnumLiteral> = any, C extends Context = Context, D extends DEnumLiteral = DEnumLiteral>  extends LNamedElement { // DNamedElement\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    public __raw!: DEnumLiteral;\r\n    id!: Pointer<DEnumLiteral, 1, 1, LEnumLiteral>;\r\n    // static singleton: LAttribute;\r\n    // static logic: typeof LAttribute;\r\n    // static structure: typeof DAttribute;\r\n\r\n    // inherit redefine\r\n    parent!: LEnumerator[];\r\n    father!: LEnumerator;\r\n    annotations!: LAnnotation[];\r\n    name!: string;\r\n    namespace!: string;\r\n    // personal\r\n    value!: this[\"ordinal\"];\r\n    ordinal!: number;\r\n    literal!: string;\r\n\r\n    protected generateEcoreJson_impl(context: Context, loopDetectionObj: Dictionary<Pointer, DModelElement> = {}): Json {\r\n        loopDetectionObj[context.data.id] = context.data;\r\n        const json: Json = {};\r\n        const d = context.data;\r\n        json[EcoreLiteral.value] = d.value;\r\n        json[EcoreLiteral.literal] = d.literal;\r\n        json[EcoreLiteral.namee] = d.name;\r\n        return json; }\r\n\r\n    public generateEcoreJsonM1(): this[\"ordinal\"] { return this.cannotCall(\"GenerateEcoreJsonM1\"); }\r\n    protected get_generateEcoreJsonM1(context: Context): () => this[\"ordinal\"] { return this.impl_generateEcoreJsonM1(context); }\r\n    protected impl_generateEcoreJsonM1(context: Context): () => this[\"ordinal\"] {\r\n        // loopDetectionObj[context.data.id] = context.data; no loop detection here, the same literal can be exported multiple times in m1\r\n        // return context.data.literal;\r\n        // return context.data.name;\r\n        return () => context.data.value; }\r\n\r\n\r\n    public duplicate(deep: boolean = true): this {\r\n        return this.cannotCall( ((this.constructor as typeof RuntimeAccessibleClass).cname || this.constructor.name) + \"duplicate()\"); }\r\n    protected get_duplicate(context: Context): ((deep?: boolean) => LEnumLiteral) {\r\n        return (deep: boolean = false) => {\r\n            BEGIN()\r\n            let le: LEnumLiteral = context.proxyObject.father.addLiteral(context.data.name, context.data.value);\r\n            let de: D = le.__raw as D;\r\n            de.literal = context.data.literal;\r\n            de.value = context.data.value;\r\n            let we: WEnumLiteral = le as any;\r\n            we.annotations = deep ? context.proxyObject.annotations.map(lchild => lchild.duplicate(deep).id) : context.data.annotations;\r\n            END()\r\n            return le; }\r\n    }\r\n\r\n\r\n    protected get_ordinal(context: Context): this[\"ordinal\"] { return this.get_value(context); }\r\n    protected set_ordinal(val: this[\"ordinal\"], context: Context): boolean { return this.set_value(val, context); }\r\n\r\n    protected get_value(context: Context): this[\"value\"] {\r\n        let ordinalAssumedByPosition = true; // per ottimizzazione forse è disattivabile\r\n        if (!ordinalAssumedByPosition) return context.data.value || 0;\r\n        return context.proxyObject.father.ordinals.map( o => o?.id).indexOf(context.data.id);\r\n    }\r\n    protected set_value(val: this[\"value\"], context: Context): boolean {\r\n        if (val === context.data.value) return true;\r\n        let ordinals = context.proxyObject.father.ordinals;\r\n        if (ordinals[val]) {\r\n            Log.e(true, \"that ordinal place is already taken by \" + ordinals[val].name, {sameOrdinalLit:ordinals[val], ordinals, thiss:context.data});\r\n            return true; }\r\n        return SetFieldAction.new(context.data, 'value', val); }\r\n    /*\r\n        protected get_literal(context: Context): this[\"literal\"] { return context.data.literal; }\r\n        protected set_literal(val: this[\"literal\"], context: Context): boolean {\r\n            return SetFieldAction.new(context.data, 'literal', val, '', false); }*/\r\n    protected get_literal(context: Context): this[\"literal\"] { return context.data.name; }\r\n    protected set_literal(val: this[\"literal\"], context: Context): boolean {\r\n        if (val === context.data.name) return true;\r\n        return SetFieldAction.new(context.data, 'name', val, '', false); }\r\n\r\n\r\n}\r\nRuntimeAccessibleClass.set_extend(DNamedElement, DEnumLiteral);\r\nRuntimeAccessibleClass.set_extend(LNamedElement, LEnumLiteral);\r\n\r\n@Leaf\r\n@RuntimeAccessible('DEnumerator')\r\nexport class DEnumerator extends DPointerTargetable { // DDataType\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // static singleton: LEnumerator;\r\n    // static logic: typeof LEnumerator;\r\n    // static structure: typeof DEnumerator;\r\n\r\n    // inherit redefine\r\n    // instanceClass: EJavaClass // ?\r\n    // isInstance(object: EJavaObject): boolean; ?\r\n    // getClassifierID(): number;\r\n    id!: Pointer<DEnumerator, 1, 1, LEnumerator>;\r\n    instanceClassName!: string;\r\n    parent: Pointer<DPackage, 0, 'N', LPackage> = [];\r\n    father!: Pointer<DPackage, 1, 1, LPackage>;\r\n    annotations: Pointer<DAnnotation, 0, 'N', LAnnotation> = [];\r\n    name!: string;\r\n    defaultValue!: string[];\r\n    serializable: boolean = true;\r\n    // usedBy: Pointer<DAttribute, 0, 'N', LAttribute> = []; obsolete?\r\n    // personal\r\n    literals: Pointer<DEnumLiteral, 0, 'N', LEnumLiteral> = [];\r\n\r\n    public static new(name?: DNamedElement[\"name\"], father?: DEnumerator[\"father\"], persist: boolean = true): DEnumerator {\r\n        if (!name) name = this.defaultname(\"enum \", father);\r\n        return new Constructors(new DEnumerator('dwc'), father, persist, undefined).DPointerTargetable().DModelElement()\r\n            .DNamedElement(name).DEnumerator().end();\r\n    }\r\n    static new2(setter: Partial<ObjectWithoutPointers<DEnumerator>>, father: DEnumerator[\"father\"], name?: DEnumerator[\"name\"]): DEnumerator {\r\n        if (!name) name = this.defaultname(\"enum \", father);\r\n        return new Constructors(new DEnumerator('dwc'), father, true, undefined).DPointerTargetable().DModelElement()\r\n            .DNamedElement(name).DEnumerator().end((d) => { Object.assign(d, setter); });\r\n    }\r\n\r\n    static new3(a: Partial<EnumPointers>, callback: undefined | ((d: DEnumerator, c: Constructors) => void), persist: boolean = true): DEnumerator {\r\n        if (!a.name) a.name = this.defaultname(\"enum \", a.father);\r\n        return new Constructors(new DEnumerator('dwc'), a.father, persist, undefined, a.id)\r\n            .DPointerTargetable().DModelElement().DNamedElement(a.name)\r\n            .DEnumerator()\r\n            .end(callback);\r\n    }\r\n}\r\n\r\n@Node\r\n@RuntimeAccessible('LEnumerator')\r\nexport class LEnumerator<Context extends LogicContext<DEnumerator> = any, C extends Context = Context, D extends DEnumerator = DEnumerator> extends LDataType { // DDataType\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    public __raw!: DEnumerator;\r\n    id!: Pointer<DEnumerator, 1, 1, LEnumerator>;\r\n    // static singleton: LEnumerator;\r\n    // static logic: typeof LEnumerator;\r\n    // static structure: typeof DEnumerator;\r\n\r\n    // inherit redefine\r\n    // instanceClass: EJavaClass // ?\r\n    // isInstance(object: EJavaObject): boolean; ?\r\n    // getClassifierID(): number;\r\n    instanceClassName!: string;\r\n    parent!: LPackage [];\r\n    father!: LPackage;\r\n    annotations!: LAnnotation[];\r\n    name!: string;\r\n    namespace!: string;\r\n    defaultValue!:string[];\r\n    serializable!: boolean;\r\n    // usedBy!: LAttribute[];\r\n    isPrimitive!: false;\r\n    isClass!: false;\r\n    isEnum!: true;\r\n    // personal\r\n    literals!: LEnumLiteral[];\r\n    ordinals!: LEnumLiteral[]; // literal array ordered by ordinal number\r\n\r\n    protected generateEcoreJson_impl(context: Context, loopDetectionObj: Dictionary<Pointer, DModelElement> = {}): Json {\r\n        loopDetectionObj[context.data.id] = context.data;\r\n        const json: Json = {};\r\n        let d = context.data;\r\n        if (d.instanceClassName) json[ECoreEnum.instanceTypeName] = d.instanceClassName;\r\n        json[ECoreEnum.xsitype] = 'ecore:EEnum';\r\n        json[ECoreEnum.namee] = d.name;\r\n        json[ECoreEnum.serializable] = d.serializable ? \"true\" : \"false\";\r\n        json[ECoreEnum.eLiterals] = context.proxyObject.literals.map(l => l.generateEcoreJson(loopDetectionObj));\r\n        return json; }\r\n\r\n    public duplicate(deep: boolean = true): this {\r\n        return this.cannotCall( ((this.constructor as typeof RuntimeAccessibleClass).cname || this.constructor.name) + \"duplicate()\"); }\r\n    protected get_duplicate(context: Context): ((deep?: boolean) => LEnumerator) {\r\n        return (deep: boolean = false) => {\r\n            BEGIN()\r\n            let le: LEnumerator = context.proxyObject.father.addEnumerator(context.data.name);\r\n            let de: D = le.__raw as D;\r\n            de.defaultValue = context.data.defaultValue;\r\n            de.serializable = context.data.serializable;\r\n            let we: WEnumerator = le as any;\r\n            we.annotations = deep ? context.proxyObject.annotations.map(lchild => lchild.duplicate(deep).id) : context.data.annotations;\r\n            we.literals = deep ? context.proxyObject.literals.map(lchild => lchild.duplicate(deep).id) : context.data.literals;\r\n            END()\r\n            return le; }\r\n    }\r\n\r\n\r\n    protected get_children_idlist(context: Context): Pointer<DAnnotation | DEnumLiteral, 1, 'N'> {\r\n        return [...super.get_children_idlist(context) as Pointer<DAnnotation | DEnumLiteral, 1, 'N'>, ...context.data.literals]; }\r\n\r\n    public addLiteral(name?: DEnumLiteral[\"name\"], value?: DEnumLiteral[\"value\"]): LEnumLiteral { return this.cannotCall(\"addLiteral\"); }\r\n    protected get_addLiteral(context: Context): this[\"addLiteral\"] {\r\n        return (name?: DEnumLiteral[\"name\"], value?: DEnumLiteral[\"value\"]) => LPointerTargetable.fromD(DEnumLiteral.new(name, value, context.data.id, true)); }\r\n\r\n    protected get_literals(context: Context): this[\"literals\"] {\r\n        return context.data.literals.map((pointer) => {\r\n            return LPointerTargetable.from(pointer)\r\n        }); }\r\n\r\n    protected set_literals(val: PackArr<this[\"literals\"]>, context: Context): boolean {\r\n        const list = val.map((lItem) => { return Pointers.from(lItem) });\r\n        const oldList = context.data.literals;\r\n        const diff = U.arrayDifference(oldList, list);\r\n        BEGIN();\r\n        SetFieldAction.new(context.data, 'literals', list, \"\", true);\r\n        for (let id of diff.added) {\r\n            SetFieldAction.new(id, 'father', context.data.id, '', true);\r\n            SetFieldAction.new(id, 'parent', context.data.id, '+=', true);\r\n        }\r\n        for (let id of diff.removed as Pointer<DModelElement>[]) {\r\n            SetFieldAction.new(id, 'father', undefined, '', true);\r\n            const parent = DPointerTargetable.from(id).parent;\r\n            U.arrayRemoveAll(parent, context.data.id);\r\n            SetFieldAction.new(id, 'parent', parent, '', true);\r\n        }\r\n        END();\r\n        return true; }\r\n\r\n    protected get_ordinals(context: Context): this[\"ordinals\"]{\r\n        let ret: LEnumLiteral[] = [];\r\n        let literals: LEnumLiteral[] = context.proxyObject.literals;\r\n        let dliterals: DEnumLiteral[] = literals.map(d => d.__raw);\r\n        /*\r\n        if it happens like:   second=2, third, fourth=4, fifth=3, sixth.(six would be 4 but 4 already exist)\r\n        there are 2 problems:\r\n        1) [3] is already occupied by third, but fith is correctly being the only one explicitly declaring his ordinal 3.\r\n           fixed by first assigning all known ordinals, then starting with the assumed ordinals.\r\n        2) sixth would get in position fourth, but that is already occupied\r\n         */\r\n\r\n        // adressing 1)\r\n        for (let i = 0; i < dliterals.length; i++) {\r\n            let v = dliterals[i].value;\r\n            if (v) { ret[v] = literals[i]; }\r\n        }\r\n\r\n        // setting assumed literals\r\n        let currentOrdinal = 0;\r\n        for (let i = 0; i < dliterals.length; i++) {\r\n            let v = dliterals[i].value;\r\n            if (v) { currentOrdinal = v; continue; }\r\n            while (ret[currentOrdinal]) currentOrdinal++; // adressing 2)\r\n            ret[currentOrdinal] = literals[i];\r\n        }\r\n        return ret;\r\n    }\r\n}\r\nRuntimeAccessibleClass.set_extend(DDataType, DEnumerator);\r\nRuntimeAccessibleClass.set_extend(LDataType, LEnumerator);\r\n@RuntimeAccessible('DModelM1')\r\nexport class DModelM1 extends DNamedElement{\r\n    name!: string;\r\n    roots!: Pointer<DObject, 1, 'N', LObject> // no package ma LObjects[] (solo quelli isRoot)\r\n    children!: DModelM1[\"roots\"];\r\n}\r\n\r\n@RuntimeAccessible('LModelM1')\r\nexport class LModelM1 extends LNamedElement{\r\n    name!: string;\r\n    roots!: LObject[];\r\n    children!: LModelM1[\"roots\"];\r\n\r\n}\r\nRuntimeAccessibleClass.set_extend(DModelM1, DNamedElement);\r\nRuntimeAccessibleClass.set_extend(LModelM1, LNamedElement);\r\ntype DPrimitiveType = DClass;\r\ntype LPrimitiveType = LClass;\r\n\r\n\r\n// problema: o costringo l'utente a fare sempre .value per ricevere il valore invece dei metadati\r\n// oppure ritorno il valore da subito ma dal valore non posso accedere ai metadati (upperbound...) a meno che non trovi un altor sistema.\r\n\r\n// possibile fix: LValue.toString() che ritorna il .value\r\n\r\n\r\n\r\n\r\n\r\n@RuntimeAccessible('DModel')\r\nexport class DModel extends DNamedElement { // DNamedElement\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // static singleton: LModel;\r\n    // static logic: typeof LModel;\r\n    // static structure: typeof DModel;\r\n\r\n    // inherit redefine\r\n    id!: Pointer<DModel, 1, 1, LModel>;\r\n    parent: Pointer<DModelElement, 0, 'N', LModelElement> = [];\r\n    father!: Pointer<DModelElement, 1, 1, LModelElement>;\r\n    annotations: Pointer<DAnnotation, 0, 'N', LAnnotation> = [];\r\n    name!: string;\r\n    // personal\r\n    packages: Pointer<DPackage, 0, 'N', LPackage> = [];\r\n    isMetamodel: boolean = true;\r\n    objects: Pointer<DObject, 0, 'N', LObject> = [];\r\n    models: Pointer<DModel, 0, 'N', LModel> = [];\r\n    instanceof?: Pointer<DModel>;\r\n    instances!: Pointer<DModelElement>[];\r\n    dependencies!: Pointer<DModel>[];\r\n\r\n    public static new(name?: DNamedElement[\"name\"], instanceoff?: DModel[\"instanceof\"], isMetamodel?: DModel[\"isMetamodel\"], persist: boolean = true): DModel {\r\n        let dmodels: DModel[] = Selectors.getAll(DModel, undefined, undefined, true, false);\r\n        let dmodelnames: string[] = dmodels.map((d: DModel) => d.name);\r\n        if (!name) name = this.defaultname(\"model_\", ((name: string) => dmodelnames.includes(name)));\r\n        return new Constructors(new DModel('dwc'), undefined, persist, undefined).DPointerTargetable().DModelElement()\r\n            .DNamedElement(name).DModel(instanceoff, isMetamodel).end();\r\n    }\r\n    static new2(setter: Partial<ObjectWithoutPointers<DModel>>, name?: DModel[\"name\"], instanceoff?: DModel[\"instanceof\"]): DModel {\r\n        let dmodels: DModel[] = Selectors.getAll(DModel, undefined, undefined, true, false);\r\n        let dmodelnames: string[] = dmodels.map((d: DModel) => d.name);\r\n        if (!name) name = this.defaultname(\"model_\", ((name: string) => dmodelnames.includes(name)));\r\n        return new Constructors(new DModel('dwc'), undefined, true, undefined).DPointerTargetable().DModelElement()\r\n            .DNamedElement(name).DModel(instanceoff).end((d) => { Object.assign(d, setter); });\r\n    }\r\n\r\n    static new3(a: Partial<ModelPointers>, callback: undefined | ((d: DModel, c: Constructors) => void), persist: boolean = true): DModel {\r\n        let dmodels: DModel[] = Selectors.getAll(DModel, undefined, undefined, true, false);\r\n        let dmodelnames: string[] = dmodels.map((d: DModel) => d.name);\r\n        if (!a.name) a.name = this.defaultname(\"model_\", ((name: string) => dmodelnames.includes(name)));\r\n        return new Constructors(new DModel('dwc'), a.father, persist, undefined, a.id)\r\n            .DPointerTargetable().DModelElement().DNamedElement(a.name)\r\n            .DModel(a.instanceof, !a.instanceof)\r\n            .end(callback);\r\n    }\r\n}\r\n\r\n@RuntimeAccessible('EdgeStarter')\r\nexport class EdgeStarter<T1=any, T2=any>{ // <T1 extends LPointerTargetable = LPointerTargetable, T2 extends LPointerTargetable = LPointerTargetable>{\r\n    id: string; // suggested id & key for the element.\r\n    start: LModelElement;\r\n    end: LModelElement;\r\n    startNode: LGraphElement;\r\n    endNode: LGraphElement;\r\n    startVertex: LVoidVertex;\r\n    endVertex: LVoidVertex;\r\n    startGraph: LGraph;\r\n    endGraph: LGraph;\r\n    startSize: GraphSize;\r\n    endSize: GraphSize;\r\n    startVertexSize: GraphSize;\r\n    endVertexSize: GraphSize;\r\n    otherEnds: LGraphElement[];\r\n    extendTargets: LGraphElement[];\r\n    sameGraph: boolean;\r\n    isSameGraph: boolean;\r\n    overlaps: boolean;\r\n    vertexOverlaps: boolean;/*\r\n    firstRenderedStartNode: LGraphElement;\r\n    firstRenderedEndNode: LGraphElement;*/\r\n    // todo: if you want to get the first visible parent node (like for pkg dependencies), use edgestarter.startNode.firstRenderedNode\r\n    constructor(start: LModelElement, end: LModelElement, sn: LGraphElement, en: LGraphElement,\r\n                otherPossibleEnds: LGraphElement[], m1refindex: number, type:string) {\r\n        this.start = start;\r\n        this.end = end;\r\n        this.startNode = sn;\r\n        this.endNode = en;\r\n        this.otherEnds = this.extendTargets = otherPossibleEnds;// || end.nodes;\r\n        //console.log('edgestarter ss', {end, start, sn, en});\r\n\r\n        this.startSize = sn.outerSize;\r\n        this.endSize = en.outerSize;\r\n        this.startVertex = sn.vertex as any;\r\n        this.endVertex = en.vertex as any;\r\n        this.startGraph = this.startVertex?.root;\r\n        this.endGraph = this.endVertex?.root;\r\n        this.sameGraph = this.isSameGraph = this.endGraph?.id === this.startGraph?.id;\r\n        //this.firstRenderedStartNode = this.startNode.firstRenderedNode;\r\n        //this.firstRenderedEndNode = this.startNode.firstRenderedNode;\r\n        // this.firstVisibleStart = this.startNode.firstRenderedNode;\r\n        //console.log('edgestarter evs', {end, start, sn, en});\r\n        this.startVertexSize = this.startVertex === sn ? this.startSize : this.startVertex.outerSize;\r\n        this.endVertexSize = this.endVertex === en ? this.endSize : this.endVertex.outerSize;\r\n        this.overlaps = this.startSize?.isOverlapping(this.endSize);\r\n        this.vertexOverlaps = this.startVertexSize?.isOverlapping(this.endVertexSize);\r\n        //console.log('edgestarter end', {end, start, sn, en});\r\n        // how to pick edgeid:\r\n        // using nodeid is useless, as a ref might be hidden and take the node of a class or upper, it must be resolved at conceptual model-level\r\n        // mid = model id\r\n        // NB: mid -> mid is safe for extends, why:\r\n        // if a->b1->c && a->b2->c and both b1,b2 are hidden, extend edges might become both a->c, but in that case is fine to have it only once (filter it in suggestions)\r\n        // mid -> mid                   is safe for package-dependencies for the same reason as class inheritance.\r\n        // mid -> mid                   is not safe for dvalues which might have duplicate references. (DValue.a -> [Object.b, Object.b])\r\n        // mid + (valueindex) -> mid    is safe for everything i think.\r\n        // !!!! REMEMBER, DOTS AND ~ ARE NOT ALLOWED IN ID (css selector char) !!!\r\n        this.id = start.id + ('_' + m1refindex) + '-' + end.id + type;\r\n    }\r\n    /*\r\n    static oneToMany<T1 extends LModelElement = LModelElement, T2 extends LModelElement = LModelElement>(start: T1, ends:T2[]): EdgeStarter<T1, T2>[] {\r\n        let sn = start.node;\r\n        if (!sn) return [];\r\n        let rett: (EdgeStarter | undefined)[] = ends.map( (e) => {\r\n            if(!e) return undefined;\r\n            let en = e.node;\r\n            return en ? new EdgeStarter(start, e, sn as LGraphElement, en) : undefined;\r\n        });\r\n        let ret: (EdgeStarter)[] = rett.filter<EdgeStarter>(function(e: EdgeStarter|undefined): e is EdgeStarter { return !!e });\r\n        // let ret: (EdgeStarter)[] = rett.filter<EdgeStarter>((e): (e is EdgeStarter) => { return !!e });\r\n        return ret;\r\n    }*/\r\n}\r\n\r\n@RuntimeAccessible('LModel')\r\nexport class LModel<Context extends LogicContext<DModel> = any, C extends Context = Context, D extends DModel = DModel> extends LNamedElement {\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    public __raw!: DModel;\r\n    id!: Pointer<DModel, 1, 1, LModel>;\r\n    // static singleton: LModel;\r\n    // static logic: typeof LModel;\r\n    // static structure: typeof DModel;\r\n\r\n    // inherit redefine\r\n    parent!: LModel[];\r\n    father!: LModel;\r\n    annotations!: LAnnotation[];\r\n    name!: string;\r\n    namespace!: string;\r\n    // personal\r\n    isMetamodel!: boolean;\r\n\r\n    // Metamodel\r\n    packages!: LPackage[];\r\n    models!: LModel[];\r\n    instances!: LModel[];\r\n    dependencies!: LModel[]; // points to other models of the same level\r\n    allDependencies!: LModel[];\r\n    __info_of__dependencies: Info = {type: 'LModel[]',\r\n        txt:'Include other models as prerequisite for this model, it is as if this model is \"extending\" other models.'};\r\n    __info_of__allDependencies: Info = {type: 'LModel[]', txt:'Same as dependencies, but it solves recursively the dependencies of his dependencies.'};\r\n\r\n    // Model\r\n    instanceof?: LModel;\r\n    objects!: LObject[];\r\n    crossObjects!: LObject[];\r\n    roots!: LObject[];\r\n\r\n    // utilities to go down in the tree (plural names)\r\n    enums!: LEnumerator[] & Dictionary<DocString<\"$name\">, LEnumerator>; // alias for enumerators\r\n    enumerators!: LEnumerator[] & Dictionary<DocString<\"$name\">, LEnumerator>;\r\n    crossEnumerators!: LEnumerator[] & Dictionary<DocString<\"$name\">, LEnumerator>;\r\n    classes!: LClass[] & Dictionary<DocString<\"$name\">, LClass>;\r\n    crossClasses!: LClass[] & Dictionary<DocString<\"$name\">, LClass>;\r\n    operations!: LOperation[];\r\n    parameters!: LParameter[];\r\n    exceptions!: LClassifier[];\r\n    attributes!: LAttribute[];\r\n    references!: LReference[];\r\n    literals!: LEnumLiteral[];\r\n    values!: LValue[];\r\n    allSubAnnotations!: LAnnotation[];\r\n    allCrossSubAnnotations!: LAnnotation[];\r\n    allSubPackages!: LPackage[];\r\n    allCrossSubPackages!: LPackage[];\r\n    allSubObjects!: LObject[];\r\n    allCrossSubObjects!: LObject[];\r\n    allSubValues!: LValue[];\r\n    allCrossSubValues!: LValue[];\r\n    suggestedEdges!: {extend: EdgeStarter[], reference:EdgeStarter[], packageDependencies: EdgeStarter[]}; //, model: EdgeStarter[], package:EdgeStarter[], class:EdgeStarter[]};\r\n    __info_of__suggestedEdges: Info = {type: 'Dictionary<\"extend\" | \"reference\" | \"packageDependencies\" | DmodelName, EdgeStarter[]>', txt: \"A map to access all possible kind of edges based on model data.\" +\r\n            \"<br/>extend and reference are the most commonly used for horizontal references (outside the containment tree schema).\" +\r\n            \"<br/>packageDependencies links packages using classes from other packages.\" +\r\n            // \"<br/>other keys are the names of container data types (mode, package, class, object...) from them to their childrens rendered as Nodes (vertical tree schema).\" +\r\n            // todo: implement the commented part as LGrahElement.vertexs.map(v=>{start:v.parentnode.isVertex ? v.parentnode.id : undefined, end:v.id}).filter(e=>e.start) instead. it's a thing of graph more than model.\r\n            \"<br/> EdgeStarter is a collection of data useful to start a &lt;Edge /&gt; in JSX.\"}\r\n\r\n    protected generateEcoreJson_impl(context: Context, loopDetectionObj: Dictionary<Pointer, DModelElement> = {}): Json {\r\n        loopDetectionObj[context.data.id] = context.data;\r\n        const json: GObject = {};\r\n\r\n        // if it's M2 metamodel\r\n        if (context.data.isMetamodel) {\r\n            const packageArr: Json[] = [];\r\n            for (let pkg of context.proxyObject.packages) { packageArr.push(pkg.generateEcoreJson(loopDetectionObj)); }\r\n            // return (context.proxyObject.packages[0])?.generateEcoreJson(loopDetectionObj);\r\n            json[ECoreRoot.ecoreEPackage] = packageArr;\r\n            return json;\r\n        }\r\n\r\n        // if it's M1 model\r\n        // let serializeasroot = context.proxyObject.isRoot && loopDetectionObj.length; // if rootobj is nested because you started the serialization from another node, i prevent it generating root content\r\n        for (let obj of context.proxyObject.roots) { json[obj.ecoreRootName] = obj.generateEcoreJson(loopDetectionObj); }\r\n\r\n        return json; }\r\n\r\n    public addPackage(name?: DPackage[\"name\"], uri?: DPackage[\"uri\"], prefix?: DPackage[\"prefix\"]): LPackage { return this.cannotCall(\"addPackage\"); }\r\n    public get_addPackage(context: Context): ((name?: DPackage[\"name\"], uri?: DPackage[\"uri\"], prefix?: DPackage[\"prefix\"]) => LPackage) {\r\n        console.log(\"Model.addPackage()\", {context, thiss: this});\r\n        return (name?: DPackage[\"name\"], uri?: DPackage[\"uri\"], prefix?: DPackage[\"prefix\"]) => {\r\n            return LPointerTargetable.fromD(DPackage.new(name, uri, prefix, context.data.id, true, DModel));\r\n        }\r\n    }\r\n\r\n    public get_dependencies(c: Context): this['dependencies']{\r\n        return LPointerTargetable.fromPointer(c.data.dependencies);\r\n    }\r\n    public get_allDependencies(c: Context): this['allDependencies']{\r\n        let targets: LModel[] = L.fromArr(c.data.dependencies);\r\n        return U.iterateChildProperties(targets, (e)=>e.dependencies);\r\n        /*let alreadyParsed: Dictionary<Pointer, LModel> = {};\r\n        while (targets.length) {\r\n            let nextTargets = [];\r\n            for (let target of targets){\r\n                if (alreadyParsed[target.id]) continue;\r\n                alreadyParsed[target.id] = target;\r\n                U.arrayMergeInPlace(nextTargets, target.dependencies);\r\n            }\r\n            targets = nextTargets;\r\n        }\r\n        return Object.values(alreadyParsed);*/\r\n    }\r\n    /*public set_dependencies(c: Context): this['dependencies']{\r\n        default setter is fine, should automatically do the difference of pointers and trigger -= or +=\r\n    }*/\r\n\r\n    public static namesORDObjectsToID<T extends DPointerTargetable = DPointerTargetable>(a: T): Pointer<T>[];\r\n    public static namesORDObjectsToID<T extends DPointerTargetable = DPointerTargetable>(a: T[]): Pointer<T>[];\r\n    public static namesORDObjectsToID<L extends LPointerTargetable = LPointerTargetable>(a: L): Pointer<LtoD<L>>[];\r\n    public static namesORDObjectsToID<L extends LPointerTargetable = LPointerTargetable>(a: L[]): Pointer<LtoD<L>>[];\r\n    public static namesORDObjectsToID<T extends DPointerTargetable = DPointerTargetable>(a: Pointer<T>): Pointer<T>[];\r\n    public static namesORDObjectsToID<T extends DPointerTargetable = DPointerTargetable>(a: Pointer<T>[]): Pointer<T>[];\r\n    public static namesORDObjectsToID(a: string, namedCandidates: LModelElement[]): Pointer[];\r\n    public static namesORDObjectsToID(a: string[], namedCandidates: LModelElement[]): Pointer[];\r\n    public static namesORDObjectsToID(a: string | LClass | DClass | Pointer, namedCandidates: LModelElement[]): Pointer[];\r\n    public static namesORDObjectsToID(a: (string | LClass | DClass | Pointer)[], namedCandidates: LModelElement[]): Pointer[];\r\n    public static namesORDObjectsToID<T extends DPointerTargetable = DPointerTargetable>(a: orArr<(string | T | Pointer<T>)>): Pointer<T>[];\r\n    // return the first array parameter converted in an array of pointers. The second parameter is the scope where names are allowed to match. if empty all class.names will fail mapping to id's.\r\n    // second parameter is mandatory when the array contain names, to prevent looking into class names of different models.\r\n    public static namesORDObjectsToID<T extends DPointerTargetable = DPointerTargetable>(targets: orArr<(string | T | Pointer<T>)>, namedCandidates?: LModelElement[]): Pointer<T>[] {\r\n        // let targets = any[] = (!Array.isArray(targets0)) ? targets0 : [targets0];\r\n        if (!targets) return [];\r\n        let ret: Pointer<T>[] = [];\r\n        let state: DState = store.getState();\r\n        if (targets && !Array.isArray(targets)) targets = [targets];\r\n        let dnamedcandidates: DNamedElement[] = namedCandidates ? DPointerTargetable.fromArr(namedCandidates as any) as DNamedElement[] : [];\r\n        let dAllowedNamesMap: Dictionary<DocString<\"name\">, Pointer<T>> = (dnamedcandidates as any[]).reduce( (acc, val) => { acc[val.name] = val.id; return acc; }, {});\r\n        //let dtargets: DNamedElement[] = targets ? DPointerTargetable.fromArr(targets) as DNamedElement[] : [];\r\n        let tmp: Pointer<T> | undefined;\r\n        for (let target of targets) {\r\n            // try as name\r\n            tmp = dAllowedNamesMap[target as string];\r\n            if (tmp) { ret.push(tmp); continue; }\r\n            // try as $name\r\n            tmp = dAllowedNamesMap[\"$\" + target as string];\r\n            if (tmp) { ret.push(tmp); continue; }\r\n            // try as id\r\n            let d: DNamedElement = DPointerTargetable.from(target as Pointer, state);\r\n            if (d && dAllowedNamesMap[d.name]) { ret.push(target as Pointer<T>); continue; }\r\n            Log.ww(\"namesORDObjectsToID() could not resolve name:\", {name: target, namedCandidates, targets});\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    _defaultGetter(c: Context, key: string): any {\r\n        //console.log(\"$getter 000\", {key, ism1:!c.data.isMetamodel, ism:c.data.isMetamodel, data:c.data});\r\n        if (!c.data.isMetamodel) return this._defaultGetterM1(c, key);\r\n        return this._defaultGetterM2(c, key);\r\n    }\r\n    _defaultGetterM2(c: Context, key: string): any{\r\n        if ((TargetableProxyHandler.childKeys[key[0]])){\r\n            // look for m1 matches\r\n            let k = key.substring(1).toLowerCase();\r\n            let s = store.getState();\r\n\r\n            for (let subelement of this.get_allSubPackages(c, s)){\r\n                let n = subelement.__raw.name;\r\n                if (n && n.toLowerCase() === k) return subelement;\r\n            }\r\n            for (let subelement of this.get_classes(c, s)){\r\n                let n = subelement.__raw.name;\r\n                if (n && n.toLowerCase() === k) return subelement;\r\n            }\r\n        }\r\n        return this.__defaultGetter(c, key);\r\n        // Log.ee(\"Could not find property \" + key + \" on MetaModel\", {c, key});\r\n    }\r\n    _defaultGetterM1(c: Context, key: string): any{\r\n        // if m1.$m1RootObjectName then --> return that root object\r\n        // if m1.$m1ObjectName then --> return that sub object nested somewhere in the model.\r\n        // if m1.$m2classname\"s\" then --> this.instancesOf(\"m2classname\")\r\n        // if m1.$m2classname then ---> m2.$m2classname (lower priority, if there are 2 metaclasses differing only by final s,\r\n        // the one with 1 more final \"s\" if shadowed by the instances of the one with 1 less final \"s\",\r\n        // in that case you can access the shadowed one through m1.instanceof.$classnames\r\n        // priorities: 1) m1 name natch --> m1object. 2) m2 exact name match --> m2item, 3) m2 name+\"s\" match --> instances\r\n        // to access m2 classes within a package, need to navigate it like model.$packagename.Ssubcpackagename.$classname,\r\n        // path + \"s\" won't work in that case, and need to use this.getInstancesOf instead\r\n        if (TargetableProxyHandler.childKeys[key[0]]){\r\n            // look for m1 matches\r\n            let deepmatch: LObject | undefined;\r\n            let k = key.substring(1).toLowerCase();\r\n            console.log(\"$getter 0\", {k, key, deepmatch});\r\n\r\n            const directSubObjects: Dictionary<Pointer, boolean> = U.objectFromArrayValues(c.data.objects);\r\n            for (let subobject of this.get_allSubObjects(c)){\r\n                let n = subobject.name;\r\n                if (!n || n.toLowerCase() !== k) continue;\r\n                // A0) perfect match with direct child object\r\n                if (directSubObjects[subobject.id]) return subobject; // actually cannot do direct match, because proxy get function will solve it directly before calling _defaultGetter\r\n                else if (!deepmatch) deepmatch = subobject;\r\n            }\r\n            console.log(\"$getter 1\", {k, key, deepmatch});\r\n            // A1) match with deep sub-object\r\n            if (deepmatch) return deepmatch;\r\n\r\n            // look for m2 matches\r\n            let m2: LModel | undefined = this.get_instanceof(c);\r\n            console.log(\"$getter 2\", {k, key, m2});\r\n            if (!m2) return Log.ee(\"Could not find m1 match for data.$name. And the metamodel is missing, so cannot get instances by type.\", {c, key, m2});\r\n            let m2item: LClass | LPackage;\r\n            // check for a perfect m2 name match and return it\r\n            m2item = (m2 as GObject)[key];\r\n            console.log(\"$getter 3\", {k, key, m2, m2item});\r\n            if (m2item) return m2item; //this.instancesOf(key);\r\n            if (!m2) Log.ee(\"Could not find property \" + key + \" on M1 Model\", {c, key, m2});\r\n            // if not a perfect name match, i try name+s match for instances\r\n            if (key[key.length - 1] === \"s\") {\r\n                let key1 = key.substring(0, key.length - 1);\r\n                m2item = (m2 as GObject)[key1];\r\n                console.log(\"$getter 4\", {k, key, key1, m2, m2item});\r\n                if (m2item) {\r\n                    if (m2item.className === \"DClass\") return this.get_instancesOf(c)(m2item as LClass);\r\n                    else return Log.ee(\"Could not get instances of \" + key1 + \".\", {c, key, m2});\r\n                }\r\n            }\r\n            console.log(\"$getter 5\", {k, key, m2, m2item});\r\n            if (!m2) return Log.ee(\"Could not find any subelement with name \" + key + \" on M1 or M2 Models\", {c, key, m1: c.data, m2});\r\n        }\r\n\r\n        return this.__defaultGetter(c, key);\r\n    }\r\n    private static otherObjectsTemp: Dictionary<DocString<\"className\">, LObject[]> = undefined as any;\r\n    private static otherObectsAccessedKeys: DocString<\"className\">[] = [];\r\n    // public otherObjectsSetup(){ LModel.otherObjectsTemp = undefined; LModel.otherObectsAccessedKeys = []; }\r\n    otherObjects!: (excludeInstances: orArr<(string | LClass | Pointer)>, excludeSubclasses?: boolean)=>LObject[];\r\n    otherInstances!: (excludeInstances: orArr<(string | LClass | Pointer)>, excludeSubclasses?: boolean)=>LObject[];\r\n    __info_of__otherObjects: Info = {type:\"(...excludeInstances: (string|LClass|Pointer)[], excludeSubclasses: boolean = false)=>LObject[]\", txt:<div>Alias for this.otherInstances.</div>};\r\n    __info_of__otherInstances: Info = {type:\"(...excludeInstances: (string|LClass|Pointer)[], excludeSubclasses: boolean = false)=>LObject[]\", txt:<div>Read this.instancesOf documentation first.\r\n            <br/>Retrieves all the objects not obtained between previous calls of this.instancesOf and the last call of this method.\r\n            <br/>Meaning calling it twice without any instancesOf in between, it will return all objects.</div>};\r\n\r\n    public get_otherObjects(c: Context): (excludeInstances: orArr<(string | LClass | Pointer)>, excludeSubclasses?: boolean)=>LObject[]{\r\n        return this.get_otherInstances(c); }\r\n    public get_otherInstances(c: Context): (excludeInstances: orArr<(string | LClass | Pointer)>, excludeSubclasses?: boolean)=>LObject[]{\r\n        // todo:\r\n        return (excludeInstances: orArr<(string | LClass | Pointer)>, includeSubclasses: boolean = false)=>{\r\n            let ret: LObject[];\r\n            this.get_instancesOf(c)(excludeInstances, includeSubclasses) // and drop the result\r\n            if (!LModel.otherObjectsTemp) { ret = this.get_allSubObjects(c); }\r\n            else {\r\n                let dict = {...LModel.otherObjectsTemp};\r\n                for (let key of LModel.otherObectsAccessedKeys) delete dict[key];\r\n                delete (LModel as any).otherObjectsTemp;\r\n                delete (LModel as any).otherObectsAccessedKeys;\r\n                ret = Object.values(dict).flat();\r\n            }\r\n            return ret;\r\n        }\r\n    }\r\n    // not meant to be called directly.\r\n    private _populateOtherObjects(c:Context, classes?: LClass[]): void {\r\n        // from names, DClass and ptrs, make them only ptrs. all classes of this model are valid name targets.\r\n        // nb: cannot optimize getting only instantiated classes from this.get_allSubObjects because if a class have 0 instances should have an empty array instead of undefined (risk jsx crash)\r\n        let state: DState = store.getState();\r\n        let dinstancetypes: DClass[] = (classes || this.get_classes(c, state)).map(c => c.__raw);\r\n        let namemap: Dictionary<DocString<\"className\">, DClass> = {};\r\n        namemap = dinstancetypes.reduce( (acc, current) => { namemap[current.name] = current; return namemap; }, namemap);\r\n        let idtoname: Dictionary<Pointer, string> = {};\r\n        for (let n in namemap) {idtoname[namemap[n].id] = n; }\r\n        // make it more general, first make a dictionary holding all selected types as keys, including \"_other\"\r\n        // then a SEPARATE (split this) function to return only the selected keys, merging the subarrays in the global naming instance map.\r\n        LModel.otherObjectsTemp = {};\r\n        LModel.otherObectsAccessedKeys = [];\r\n        // part 1: i add empty arrays for all instances, but not include shapeless objects.\r\n        for (let name in namemap) { LModel.otherObjectsTemp[name] = []; } //LPointerTargetable.fromPointer(namemap[name].instances); }\r\n        // part 2: for shapeless objs too\r\n        LModel.otherObjectsTemp[undefined as any] = [];\r\n        let allObjects: LObject[] = this.get_allSubObjects(c, state);\r\n        // part 3: now i populate the Model.otherObjectsTemp dictionary arrays\r\n        for (let o of allObjects) {\r\n            // if (o.__instanceof) continue;\r\n            let name: string | undefined = idtoname[o.__raw.instanceof];\r\n            if (!LModel.otherObjectsTemp[name]) {\r\n                LModel.otherObjectsTemp[name] = [o];\r\n                Log.eDevv(\"model._populateOtherObjects() this case should never happen\", {name, o, allObjects, namemap, idtoname});\r\n            }\r\n            else LModel.otherObjectsTemp[name].push(o);\r\n        }\r\n    }\r\n\r\n    public instancesOf(instancetypes0: orArr<(string | LClass | Pointer)>, includeSubclasses: boolean = false): LObject[]{ return this.cannotCall(\"instancesOf\"); }\r\n    public __info_of__instancesOf: Info = {type: \"(instancetypes: orArr<(string | LClass | Pointer)>, includeSubclasses: boolean = false) => LObject[]\",\r\n        txt:<div>Retrieves all objects instancing a target class.\r\n            <br/>The first parameter is the targeted class, which can be his name, pointer or object.\r\n            <br/>The second parameter tells if instances of his subclasses needs to be retreieved as well.</div>\r\n    }\r\n    // M1\r\n    public get_instancesOf(c:Context): (this[\"instancesOf\"]){\r\n        if (c.data.isMetamodel) { return (...a:any) => { Log.ww(\"cannot call instancesOf() on a metamodel\"); return []; } }\r\n        return (instancetypes0: orArr<(string | LClass | Pointer)>, includeSubclasses: boolean = false): LObject[] => {\r\n            let state: DState = store.getState();\r\n            let classes = this.get_classes(c, state);\r\n            if (!LModel.otherObjectsTemp) this._populateOtherObjects(c, classes);\r\n            if (!Array.isArray(instancetypes0)) instancetypes0 = [instancetypes0];\r\n            // from names, DClass and ptrs, make them only ptrs. all classes of this model are valid name targets.\r\n            let instancetypes: Pointer<DClass>[] = LModel.namesORDObjectsToID(instancetypes0, classes) as any;\r\n            let dinstancetypes: DClass[] = DClass.fromPointer(instancetypes, state);\r\n            if (includeSubclasses) {\r\n                let arr: LClass[] = dinstancetypes.map(d => LPointerTargetable.fromD(d));\r\n                for (let c of arr) dinstancetypes.push(...(c.allSubClasses.map(l => l.__raw) || []));\r\n                dinstancetypes = [...new Set(dinstancetypes)];\r\n            }\r\n            let ret: LObject[] = []\r\n            for (let c of dinstancetypes) {\r\n                let arr: LObject[] = LModel.otherObjectsTemp[c.name]\r\n                if (!arr || !arr.length) continue;\r\n                ret.push(...arr);\r\n                LModel.otherObectsAccessedKeys.push(c.name);\r\n            }\r\n            return ret;\r\n        }\r\n    }\r\n/*\r\n* instanceof === some class -> instantiate object and forces to conform to that class\r\ninstanceof === null  --> shapeless object\r\ninstanceof === undefined or missing  --> auto-detect and assign the type\r\n */\r\n    addObject(json: GObject, instanceoff: Pack1<LClass> | DocString<\"ClassName\"> | undefined | null = undefined, forceCreation: boolean = false): ReturnType<LValue[\"addObject\"]>{ return this.cannotCall(\"LValue.addObject\"); }\r\n    __info_of__addObject: Info = {type: \"(json: object, instanceof?: LClass) => LObject\",\r\n        txt: \"Appends an object instancing \\\"instanceof\\\" to the model.\\n<br>Setting his own properties, and DValues according to the content of the parameter object.\"}\r\n    get_addObject(c: Context): ReturnType<LValue[\"get_addObject\"]> { return (LValue.singleton as LValue).get_addObject.call(this, c); }\r\n\r\n    instantiableClasses(o?: GObject, loose: boolean = false):LClass[] { return this.cannotCall(\"instantiableClasses\"); }\r\n    __info_of__instantiableClasses: Info = {type: \"(o?: object, loose?: boolean) => LClass[]\",\r\n        txt: \"List of all classes which can be used to instantiate an object.\" +\r\n            \"\\n<br>Abstract and Interface classes are excluded.\" +\r\n            \"\\n<br>If the parameter \\\"o\\\" is specified, it will filter only the instances conforming to the object schema.\" +\r\n            \"\\n<br>Results are sorted from tightest fit to loosest fit.\" +\r\n            \"\\n<br>loose parameter set to true makes return instead a list of matching scores of all subclasses.\", hidden: true}\r\n    // M1\r\n    get_instantiableClasses(c: Context): LValue[\"instantiableClasses\"] {\r\n        if (c.data.isMetamodel) { return (...a:any)=> { Log.ww(\"cannot call instantiableClasses() on a metamodel\"); return []; } }\r\n        return (LValue.singleton as LValue).get_instantiableClasses.call(this, c)\r\n    }\r\n\r\n    public get_suggestedEdges(context: Context): this[\"suggestedEdges\"]{\r\n        let ret: this[\"suggestedEdges\"];\r\n        if (context.data.isMetamodel) ret = this.impl_get_suggestedEdgesM2(context);\r\n        else ret = this.impl_get_suggestedEdgesM1(context);\r\n\r\n        return ret;\r\n    }\r\n\r\n    private impl_get_suggestedEdgesM1(context: Context, state?: DState): this[\"suggestedEdges\"]{\r\n        let ret: this[\"suggestedEdges\"] = {extend: [], reference: [], packageDependencies: []};\r\n        if (context.data.isMetamodel) { Log.ww(\"cannot call suggestedEdgesM1() on a metamodel\"); return ret; }\r\n        if (Debug.lightMode) { return ret; }\r\n        let s: DState = store.getState();\r\n        let values: LValue[] = this.get_allSubValues(context, s);\r\n        let map: Dictionary<DocString<\"starting dvalue id\">, EdgeStarter[]> = {};\r\n        if (!state) state = store.getState();\r\n        outer:\r\n            for (let lval of values) {\r\n                if (!lval) continue;\r\n                let dval = lval.__raw;\r\n                let values: any[] = dval.values || [];\r\n                // NB: ELiterals can be pointers in L, but string or ordinal numbers in D, but they won't make edges, so i use .__raw\r\n                inner:\r\n                    for (let valindex = 0; valindex < values.length; valindex++) {\r\n                        let v: any = values[valindex];\r\n                        if (!Pointers.isPointer(v, state)) continue inner;\r\n                        let snode = lval.notEdge;\r\n                        if (!snode || !snode.html) continue outer;\r\n                        if (v === dval.id) continue inner; // pointing to itself\r\n                        let ltarget: undefined | LEnumLiteral | LObject = LPointerTargetable.fromPointer(v, state);\r\n                        if (!ltarget) continue;\r\n                        if (ltarget.className !== DObject.cname) continue inner;\r\n                        let enode = ltarget.notEdge;\r\n                        if (!enode || !enode.html) continue inner;\r\n                        if (!map[dval.id]) map[dval.id] = [];\r\n                        map[dval.id].push(new EdgeStarter(lval, ltarget, snode, enode, [], valindex, 'values'));\r\n                    }\r\n            }\r\n        ret.reference = Object.values(map).flat();\r\n        return ret;\r\n    }\r\n    private impl_get_suggestedEdgesM2(context: Context): this[\"suggestedEdges\"]{\r\n        let ret: this[\"suggestedEdges\"] = {extend: [], reference: [], packageDependencies: []};\r\n        if (!context.data.isMetamodel) { Log.ww(\"cannot call suggestedEdgesM2() on a model\"); return ret; }\r\n        let s: DState = store.getState();\r\n        let classes: LClass[] = this.get_classes(context, s);\r\n        let references: LReference[] = Debug.lightMode ? [] : classes.flatMap(c=>c.references);\r\n        ret.reference = references.map( (r) => {\r\n            let sn = r?.notEdge;\r\n            if (!sn || !sn.html) return undefined;\r\n            let end = r.type;\r\n            // if (end.id === r.id) return undefined;\r\n            let en = end?.notEdge;\r\n            if (!en || !en.html) return undefined;\r\n            //console.log('pre edgestarter', {r, end, sn, en});\r\n            return new EdgeStarter(r, end, sn, en, [], 0, 'association');\r\n        }).filter<EdgeStarter>(function(e):e is EdgeStarter{ return !!e});\r\n        // ret.extend = classes.flatMap( c => EdgeStarter.oneToMany(c, c.extends));\r\n\r\n        let alreadyAdded: Dictionary<Pointer, LClass> = {};\r\n        // if A extends B1, B2;    B1 extends C1, C2;    and node B1 is hidden. instead of edge from A to B, i display edge from A~C1, A~C2, A~B2\r\n        function SkipExtendNodeHidden(start: LClass, end: LClass[], rootCall: boolean = true): ({start: LClass, end: LClass, sn: LGraphElement, en: LGraphElement})[] {\r\n            let ret: {start: LClass, end: LClass, sn: LGraphElement, en: LGraphElement}[] = [] as any;\r\n            if (rootCall) { alreadyAdded = {}; alreadyAdded[start.id] = start; } // end classes can get added twice if from a different starting subclass path (in classes.flatMap -> each one should have his own dict).\r\n            // ret.start = start;\r\n            let sn = start.notEdge;\r\n            if (!sn || !sn.html) return [];\r\n            //  let end: LClass[] = start.extends;\r\n            for (let e of end) {\r\n                if (!e) continue;\r\n                let eid = e.id;\r\n                if (alreadyAdded[eid]) continue; // without this there might be duplicates if A extends B1, B2;  and both B1 & B2 extends C\r\n                alreadyAdded[eid] = e;\r\n                let en = e.notEdge;\r\n                if (en && en.html) { ret.push({start, end:e, sn, en}); continue; }\r\n                let secondTierExtends = e.extends;\r\n                // for (let eend of secondTierExtends) {\r\n                ret.push(...SkipExtendNodeHidden(start, secondTierExtends, false));\r\n                //}\r\n            }\r\n            return ret;\r\n        }\r\n        ret.extend = classes.flatMap(c => SkipExtendNodeHidden(c, c.extends, true)).map( (es) => {\r\n            let otherEdgeEnds = es.start.extendsChain.flatMap(c=>(c?.nodes||[])).filter(c=> {\r\n                if (!c || !c.rendered) return false;\r\n                if (es.sn?.root?.id !== c.root?.id) return false;\r\n                return true;\r\n            }) as LGraphElement[];\r\n            return new EdgeStarter(es.start, es.end, es.sn, es.en, otherEdgeEnds, 0, 'extend');\r\n        });\r\n\r\n        let dependencies: {src:LModelElement, ends: LModelElement[]}[] =\r\n            Debug.lightMode ? [] : [\r\n                ...(classes.map(c=>{ return {src:c, ends:c.superclasses}})),\r\n                ...(references.map(r=> { return {src:r, ends:[r.type]}}))\r\n            ]\r\n        let pkgdependencies: {src: LPackage, sn: LGraphElement, ends: Dictionary<Pointer, {end:LPackage, en:LGraphElement}>}[] = []; // transform form in dictionary to prevent duplicates\r\n        //dependencies.map( d=> { let end = d.end.package; return {src:d.src.package, end, endid:end.id}})\r\n\r\n        for (let d of dependencies) {\r\n            let src: LPackage | null = d.src.package;\r\n            if (!src) continue;\r\n            let srcnode: LGraphElement | undefined = src.notEdge;\r\n            if (!srcnode || !srcnode.html) continue;\r\n            let ends: Dictionary<Pointer, {end:LPackage, en:LGraphElement}> = {};\r\n            for (let end of d.ends) {\r\n                let ep: LPackage|null = end.package;\r\n                if (!ep) continue;\r\n                let epnode: LGraphElement | undefined = ep.notEdge;\r\n                if (!epnode || !epnode.html) continue;\r\n                ends[ep.id] = {end:ep, en:epnode};\r\n            }\r\n            pkgdependencies.push( {src, sn:srcnode, ends});\r\n        }\r\n        // todo: check\r\n        ret.packageDependencies = pkgdependencies.flatMap(\r\n            (pd) => ( Object.values(pd.ends).map((end) => new EdgeStarter(pd.src, end.end, pd.sn, end.en, [], 0, 'pkg_dep')))\r\n        );\r\n        return ret;\r\n    }\r\n\r\n\r\n    protected get_models(context: Context): LModel[] { // todo: should this not be data.instances instead?\r\n        return LModel.fromPointer(context.data.models);\r\n    }\r\n    protected set_models(val: PackArr<this['models']>, context: Context): boolean {\r\n        const list = val.map((lItem) => { return Pointers.from(lItem) });\r\n        const oldList = context.data.models;\r\n        const diff = U.arrayDifference(oldList, list);\r\n        BEGIN();\r\n        SetFieldAction.new(context.data, 'models', list, '', true);\r\n        for (let id of diff.added) {\r\n            SetFieldAction.new(id, 'father', context.data.id, '', true);\r\n            SetFieldAction.new(id, 'parent', context.data.id, '+=', true);\r\n        }\r\n        for (let id of diff.removed as Pointer<DModelElement>[]) {\r\n            SetFieldAction.new(id, 'father', undefined, '', true);\r\n            const parent = DPointerTargetable.from(id).parent;\r\n            U.arrayRemoveAll(parent, context.data.id);\r\n            SetFieldAction.new(id, 'parent', parent, '', true);\r\n        }\r\n        END();\r\n        return true;\r\n    }\r\n\r\n    public duplicate(deep: boolean = true): this { throw new Error(\"Model.duplicate(): use export/import ecore instead.\"); }\r\n\r\n    protected set_instanceof(val: Pack1<this[\"instanceof\"]>, context: Context): boolean {\r\n        let ptr = Pointers.from(val);\r\n        SetFieldAction.new(context.data.id, \"instanceof\", ptr, undefined, true);\r\n        // update father's collections (pointedby's here are set automatically)\r\n        // todo: ptr && SetFieldAction.new(ptr, \"instances\", context.data.id, '+=', true);\r\n        return true; }\r\n    protected get_instanceof(context: Context): this[\"instanceof\"] { return context.data.instanceof ? LPointerTargetable.fromPointer(context.data.instanceof) : undefined; }\r\n\r\n    protected set_name(val: this['name'], context: Context): boolean {\r\n        const models: LModel[] = LModel.fromPointer(store.getState()['models']);\r\n        if(models.filter((model) => { return model.name === val }).length > 0) {\r\n            U.alert('e', 'Cannot rename the selected element since this name is already taken.');\r\n        } else {\r\n            SetFieldAction.new(context.data, 'name', val, '', false);\r\n        }\r\n        return true;\r\n    }\r\n    protected get_children_idlist(context: Context): Pointer<DAnnotation | (DPackage|DObject), 1, 'N'> {\r\n        let children: Pointer<(DPackage|DObject), 0, 'N', (LPackage|LObject)>;\r\n        if(context.data.isMetamodel) children = context.data.packages;\r\n        else children = context.proxyObject.allSubObjects.map(o => o.id);\r\n        return [...super.get_children_idlist(context) as Pointer<DAnnotation | (DPackage|DObject), 1, 'N'>,\r\n            ...children];\r\n    }\r\n\r\n    protected get_isMetamodel(context: Context): this['isMetamodel'] {\r\n        return context.data.isMetamodel;\r\n    }\r\n    protected set_isMetamodel(val: this['isMetamodel'], context: Context): boolean {\r\n        if (context.data.isMetamodel !== val) SetFieldAction.new(context.data, 'isMetamodel', val, '', false);\r\n        return true;\r\n    }\r\n\r\n    protected get_crossObjects(context: Context): this[\"objects\"] { return this.get_objects(context, true); }\r\n    protected get_objects(context: Context, includeCrossReferences: boolean = false): this['objects'] {\r\n        let ret: LObject[] = context.data.objects.map((pointer) => LPointerTargetable.from(pointer));\r\n        if (includeCrossReferences) U.arrayMergeInPlace(ret, context.proxyObject.allDependencies.flatMap(dep=>dep.objects));\r\n        return ret;\r\n    }\r\n    protected get_crossPackages(context: Context): this[\"packages\"] { return this.get_packages(context, true); }\r\n\r\n    protected get_packages(context: Context, includeCrossReferences: boolean = false): this[\"packages\"] {\r\n        if (!context.data.isMetamodel) { return context.data.instanceof ? (this.get_instanceof(context) as LModel).packages : []; }\r\n        let ret: LPackage[] = context.data.packages.map((pointer) => LPointerTargetable.from(pointer));\r\n        if (includeCrossReferences) U.arrayMergeInPlace(ret, context.proxyObject.allDependencies.flatMap(dep=>dep.packages));\r\n        return ret;\r\n    }\r\n\r\n    protected set_packages(val: PackArr<this[\"packages\"]>, context: Context): boolean {\r\n        const list = val.map((lItem) => { return Pointers.from(lItem) });\r\n        const oldList = context.data.packages;\r\n        const diff = U.arrayDifference(oldList, list);\r\n        BEGIN();\r\n        SetFieldAction.new(context.data, 'packages', list, \"\", true);\r\n        for (let id of diff.added) {\r\n            SetFieldAction.new(id, 'father', context.data.id, '', true);\r\n            SetFieldAction.new(id, 'parent', context.data.id, '+=', true);\r\n        }\r\n        for (let id of diff.removed as Pointer<DModelElement>[]) {\r\n            SetFieldAction.new(id, 'father', undefined, '', true);\r\n            const parent = DPointerTargetable.from(id).parent;\r\n            U.arrayRemoveAll(parent, context.data.id);\r\n            SetFieldAction.new(id, 'parent', parent, '', true);\r\n        }\r\n        END();\r\n        return true;\r\n    }\r\n\r\n    protected get_crossRoots(context: Context): this[\"roots\"] { return this.get_roots(context, true); }\r\n    protected get_roots(context: Context, includeCross: boolean = false): this[\"roots\"] {\r\n        return this.get_objects(context, includeCross);//.filter( o => o.isRoot);\r\n    }\r\n\r\n    protected get_crossClasses(c: Context, s?: DState): this[\"classes\"] { return this.get_classes(c, s, true); }\r\n    protected get_classes(c: Context, s?: DState, includeCross: boolean = false): this[\"classes\"] {\r\n        let key = 'classes';\r\n        let crossKey = 'crossClasses';\r\n        let kind = DClass;\r\n        if (!c.data.isMetamodel) {\r\n            if (!c.data.instanceof) return [] as any;\r\n            let meta = this.get_instanceof(c) as GObject<LModel>;\r\n            if (includeCross && c.data.dependencies.length) return meta[crossKey];\r\n            return meta[key];\r\n        }\r\n        return this._getallSub(c, s, kind, includeCross);\r\n    }\r\n    protected get_crossReferences(c: Context, s?: DState): this[\"references\"] { return this.get_references(c, s, true); }\r\n    protected get_references(c: Context, s?: DState, includeCross: boolean = false): this[\"references\"] {\r\n        let key = 'references';\r\n        let crossKey = 'crossReferences';\r\n        let kind = DReference;\r\n        if (!c.data.isMetamodel) {\r\n            if (!c.data.instanceof) return [] as any;\r\n            let meta = this.get_instanceof(c) as GObject<LModel>;\r\n            if (includeCross && c.data.dependencies.length) return meta[crossKey];\r\n            return meta[key];\r\n        }\r\n        return this._getallSub(c, s, kind, includeCross);\r\n    }\r\n\r\n    protected get_crossEnums(context: Context): this[\"enums\"] { return this.get_enumerators(context, undefined, true); }\r\n    protected get_enums(context: Context): this[\"enums\"] {\r\n        if (!context.data.isMetamodel) { return context.data.instanceof ? (this.get_instanceof(context) as LModel).enumerators : [] as any; }\r\n        return this.get_enumerators(context, undefined, false);\r\n    }\r\n\r\n    protected get_crossEnumerators(context: Context, s?: DState): this[\"enums\"] { return this.get_enumerators(context, s, true); }\r\n    protected get_enumerators(c: Context, s?: DState, includeCross:boolean = false): this[\"enums\"] {\r\n        let key = 'enumerators';\r\n        let crossKey = 'crossEnumerators';\r\n        let kind = DEnumerator;\r\n        if (!c.data.isMetamodel) {\r\n            if (!c.data.instanceof) return [] as any;\r\n            let meta = this.get_instanceof(c) as GObject<LModel>;\r\n            if (includeCross && c.data.dependencies.length) return meta[crossKey];\r\n            return meta[key];\r\n        }\r\n        return this._getallSub(c, s, kind, includeCross);\r\n    }\r\n    protected get_allCrossSubPackages(c: Context, s?: DState): this[\"allCrossSubPackages\"] { return this.get_allSubPackages(c, s, true); }\r\n\r\n    protected get_allSubPackages(c: Context, s?: DState, includeCross: boolean = false): this[\"allSubPackages\"] {\r\n        let key = 'allSubPackages';\r\n        let crossKey = 'allCrossSubPackages';\r\n        let kind = DPackage;\r\n        if (!c.data.isMetamodel) {\r\n            if (!c.data.instanceof) return [] as any;\r\n            let meta = this.get_instanceof(c) as GObject<LModel>;\r\n            if (includeCross && c.data.dependencies.length) return meta[crossKey];\r\n            return meta[key];\r\n        }\r\n        return this._getallSub(c, s, kind, includeCross);\r\n        /*state = state || store.getState();\r\n        let tocheck: Pointer<DPackage>[] = context.data.packages || [];\r\n        let checked: Dictionary<Pointer, DPackage> = {};\r\n        while (tocheck.length) {\r\n            let newtocheck: Pointer<DPackage>[] = [];\r\n            for (let ptr of tocheck) {\r\n                if (checked[ptr]) throw new Error(\"loop in packages containing themselves\");\r\n                let dpackage: DPackage = DPointerTargetable.from(ptr, state);\r\n                checked[ptr] = dpackage;\r\n                U.arrayMergeInPlace(newtocheck, dpackage?.subpackages);\r\n            }\r\n            tocheck = newtocheck;\r\n        }\r\n        let darr: DPackage[] = Object.values(checked);\r\n        let larr: LPackage[] & Dictionary<DocString<\"$name\">, LPackage> = LPointerTargetable.fromArr(darr, state);\r\n        U.toNamedArray(larr, darr);\r\n        return larr;*/\r\n    }\r\n\r\n    protected get_allCrossSubValues(c: Context, s?: DState): this[\"allCrossSubValues\"] { return this.get_allSubValues(c, s, true); }\r\n    protected get_allSubValues(c: Context, s?: DState, includeCross?:boolean): this[\"allSubValues\"] { return this._getallSub(c, s, DValue, includeCross); }\r\n    // allCrossSubAnnotations!: LAnnotation[];     allCrossSubPackages!: LPackage[];     allCrossObjects!: LObject[];     allCrossSubValues!: LValue[];\r\n    protected get_allCrossSubObjects(c: Context, s?: DState): this[\"allCrossSubObjects\"] { return this.get_allSubObjects(c, s, true); }\r\n\r\n    protected get_allSubObjects(c: Context, s?: DState, includeCross?:boolean): this[\"allSubObjects\"] {\r\n        return this._getallSub(c, s, DObject, includeCross);\r\n    }\r\n    protected _getallSub(context: Context, state: DState|undefined, kind: Any<typeof DModelElement>, includeCross?:boolean): any[]&Dictionary<any, any> {\r\n        state = state || store.getState();\r\n        let darr = Selectors.getAll(kind, undefined, state, true, false) as DModelElement[];\r\n\r\n        console.log('get_allSubPackages', {includeCross, kind});\r\n        // console.log(\"gao\", {darr:[...darr]});\r\n        let larr = [];\r\n        // let validModels = includeCross ? [c.data.id, ...c.data.dependencies] : [c.data.id];\r\n        let allDeps = includeCross ? this.get_allDependencies(context) : [];\r\n        let allDepPtrs = allDeps.map(m=>m.id);\r\n        for (let i = 0; i < darr.length; i++){\r\n            let l = LPointerTargetable.fromD(darr[i]);\r\n            if (!l) continue;\r\n            let lmodel = l.model;\r\n            // Log.exDev(!lmodel, \"missing model in model element\", {l, context}); normal for primitive types in \"m3\"\r\n            if (!lmodel) continue;\r\n            let lmodelid = l.model.id;\r\n            if (lmodelid === context.data.id || includeCross && allDepPtrs.includes(lmodelid)) {\r\n                larr.push(l);\r\n            }\r\n            darr[i] = undefined as any;\r\n            continue;\r\n        }\r\n        // console.log(\"gao\", {darr:[...darr], larr});\r\n        darr = darr.filter(d=>!!d);\r\n        // console.log(\"gao\", {darr, larr});\r\n        U.toNamedArray(larr, darr);\r\n        return larr;\r\n    }\r\n\r\n    public getClassByNameSpace(namespacedclass: string): LClass | undefined { return this.cannotCall(\"getClassByNameSpace\"); }\r\n    protected get_getClassByNameSpace(context: Context): this[\"getClassByNameSpace\"] {\r\n        if (!context.data.isMetamodel) { return context.data.instanceof ? (this.get_instanceof(context) as LModel).getClassByNameSpace : undefined as any; }\r\n        return (namespacedclass: string): LClass | undefined => {\r\n            let pos = namespacedclass.lastIndexOf(\":\");\r\n            let pkguri = namespacedclass.substring(0, pos);\r\n            let classname = namespacedclass.substring(pos+1);\r\n            let pkg: LPackage | undefined = this.get_getPackageByUri(context)(pkguri);\r\n            if (!pkg) return undefined;\r\n            // return pkg[\"@\" + classname];\r\n            return pkg.classes.filter((c) => c.name === classname)[0];\r\n        }; }\r\n    public getPackageByUri(uri: string): LPackage | undefined { return this.cannotCall(\"getPackageByUri\"); }\r\n    protected get_getPackageByUri(context: Context): this[\"getPackageByUri\"] {\r\n        return (uri: string)=>context.proxyObject.allSubPackages.filter((p)=>p.uri === uri)[0]; }\r\n\r\n\r\n    /* See src/api/persistance/save.ts */\r\n\r\n    protected get_attributes(context: Context): this['attributes'] {\r\n        if (!context.data.isMetamodel) { return context.data.instanceof ? (this.get_instanceof(context) as LModel).attributes : []; }\r\n        return context.proxyObject.classes.flatMap(c => c.attributes);\r\n    }\r\n\r\n    protected get_literals(context: Context): this['literals'] {\r\n        if (!context.data.isMetamodel) { return context.data.instanceof ? (this.get_instanceof(context) as LModel).literals : []; }\r\n        return context.proxyObject.enumerators.flatMap(e => e.literals);\r\n    }\r\n\r\n    protected get_values(context: Context): this['values'] {\r\n        return context.proxyObject.objects.flatMap(o => o.features);\r\n    }\r\n}\r\nRuntimeAccessibleClass.set_extend(DNamedElement, DModel);\r\nRuntimeAccessibleClass.set_extend(LNamedElement, LModel);\r\n\r\n\r\n@RuntimeAccessible('DFactory_useless_')\r\nexport abstract class DFactory_useless_ extends DPointerTargetable { // DModelElement\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // static singleton: LFactory_useless_;\r\n    // static logic: typeof LFactory_useless_;\r\n    // static structure: typeof DFactory_useless_;\r\n\r\n    // inherit redefine\r\n    id!: Pointer<DFactory_useless_, 1, 1, LFactory_useless_>;\r\n    parent: Pointer<DModelElement, 0, 'N', LModelElement> = [];\r\n    father!: Pointer<DModelElement, 1, 1, LModelElement>;\r\n    annotations: Pointer<DAnnotation, 0, 'N', LAnnotation> = [];\r\n    // personal\r\n    ePackage: Pointer<DPackage, 1, 1, LPackage> = '';\r\n    abstract create(DClass: DClass): DObject;\r\n    abstract createFromString(eDataType: DDataType, literalValue: string): EJavaObject;\r\n    abstract convertFromString(eDataType: DDataType, instanceValue: EJavaObject): string;\r\n    // ********************** my additions inherited ********************* //\r\n    // ********************** my additions personal ********************** //\r\n}\r\n@RuntimeAccessible('LFactory_useless_')\r\nexport abstract class LFactory_useless_<Context extends LogicContext<DFactory_useless_> = any, C extends Context = Context>  extends LModelElement {\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    public __raw!: DFactory_useless_;\r\n    id!: Pointer<DFactory_useless_, 1, 1, LFactory_useless_>;\r\n    // static singleton: LFactory_useless_;\r\n    // static logic: typeof LFactory_useless_;\r\n    // static structure: typeof DFactory_useless_;\r\n\r\n    // inherit redefine\r\n    parent!: LModelElement[];\r\n    father!: LModelElement;\r\n    annotations!: LAnnotation[];\r\n    // personal\r\n    ePackage!: LPackage;\r\n    abstract create(DClass: DClass): DObject;\r\n    abstract createFromString(eDataType: DDataType, literalValue: string): EJavaObject;\r\n    abstract convertFromString(eDataType: DDataType, instanceValue: EJavaObject): string;\r\n    // ********************** my additions inherited ********************* //\r\n    // ********************** my additions personal ********************** //\r\n}\r\n\r\n// DModelElement.subclasses.push('DFactory_useless_'); // because it's abstract and cannot be used as a value, it's pure type definition\r\n// DModelElement.subclasses.push('LFactory_useless_'); // because it's abstract and cannot be used as a value, it's pure type definition\r\n// RuntimeAccessibleClass.set_extend(DModelElement, DFactory_useless_);\r\n// RuntimeAccessibleClass.set_extend(LModelElement, LFactory_useless_);\r\n\r\n@RuntimeAccessible('EJavaObject')\r\nexport class EJavaObject{\r\n\r\n}// ??? EDataType instance?\r\n\r\n\r\n@RuntimeAccessible('DMap')\r\nexport class DMap extends RuntimeAccessibleClass { // DPointerTargetable\r\n    // static logic: typeof LModelElement;\r\n    // static structure: typeof DModelElement;\r\n    // static singleton: LModelElement;\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    __isDMap!: true;\r\n    constructor() {\r\n        super();\r\n    }\r\n\r\n    // id!: Pointer<DModelElement, 1, 1, LModelElement>;\r\n}\r\n\r\n@RuntimeAccessible('LMap')\r\nexport class LMap<Context extends LogicContext<DMap> = any, C extends Context = Context>  extends LPointerTargetable {\r\n    // static logic: typeof LModelElement;\r\n    // static structure: typeof DModelElement;\r\n    // static singleton: LModelElement;\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    __isLMap!: true;\r\n    // id!: Pointer<DModelElement, 1, 1, LModelElement>;\r\n}\r\nRuntimeAccessibleClass.set_extend(DPointerTargetable, DMap as any);\r\nRuntimeAccessibleClass.set_extend(LPointerTargetable, LMap);\r\n\r\n\r\n@Leaf\r\n@RuntimeAccessible('DObject')\r\nexport class DObject extends DPointerTargetable { // extends DNamedElement, m1 class instance\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n\r\n    // inherit redefine\r\n    annotations!: never[];\r\n    id!: Pointer<DObject, 1, 1, LObject>;\r\n    parent: Pointer<DModel | DValue, 0, 'N', LModel | LValue> = [];\r\n    father!: Pointer<DModel, 1, 1, LModel> |  Pointer<DValue, 1, 1, LValue>;\r\n    // annotations: Pointer<DAnnotation, 0, 'N', LAnnotation> = [];\r\n    name!: string;\r\n\r\n    // personal\r\n    instanceof!: Pointer<DClass>; // actually nullable now, but takes too much type refactoring. be careful to check if it's present\r\n    features: Pointer<DValue>[] = [];\r\n\r\n\r\n    public static new(instanceoff?: DObject[\"instanceof\"], father?: DObject[\"father\"], fatherType?: typeof DModel | typeof DValue, name?: DNamedElement[\"name\"], persist: boolean = true): DObject {\r\n        // if (!name) name = this.defaultname(((meta: LNamedElement) => meta.name + \" \"), father);\r\n        if (!name) name = this.defaultname(((meta: LNamedElement) => (meta?.name || \"obj\") + \"_\"), father, instanceoff);\r\n        let ret = new Constructors(new DObject('dwc'), father, persist, fatherType).DPointerTargetable().DModelElement()\r\n            .DNamedElement(name).DObject(instanceoff).end();\r\n        return ret;\r\n    }\r\n\r\n    public static new3(ptrs:Partial<ObjectPointers>, then:(d:DObject, c: Constructors)=>void, fatherType?: typeof DModel | typeof DValue, persist: boolean = true): DObject{\r\n        if (!ptrs.name) ptrs.name = this.defaultname(((meta: LNamedElement) => (meta?.name || \"obj\") + \"_\"), ptrs.father, ptrs.instanceof);\r\n        return new Constructors(new DObject('dwc'), ptrs.father, persist, fatherType, ptrs.id)\r\n            .DPointerTargetable().DModelElement()\r\n            .DNamedElement(ptrs.name).DObject(ptrs.instanceof).end(then);\r\n    }\r\n\r\n\r\n}\r\n\r\n@RuntimeAccessible('LObject')\r\nexport class LObject<Context extends LogicContext<DObject> = any, C extends Context = Context, D extends DObject = DObject> extends LNamedElement { // extends DNamedElement, m1 class instance\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    public __raw!: DObject;\r\n    id!: Pointer<DObject, 1, 1, LObject>;\r\n\r\n    // inherit redefine\r\n    annotations!: never[];\r\n    children!: LValue[];\r\n    allChildren!: LValue[]; // including hidden values\r\n    truechildren!: LValue[]; // real shape without \"mirage\" values\r\n    parent!: (LModel | LValue)[];\r\n    father!: LModel | LValue;\r\n    model!: LModel;\r\n    // annotations!: LAnnotation[];\r\n    // from LClass\r\n\r\n    name!: string;\r\n    ecoreRootName!: string;\r\n    namespace!: string;\r\n    fullname!:string;\r\n    defaultValue!: DClass[\"defaultValue\"];\r\n    // abstract!: boolean;\r\n    // interface!: boolean;\r\n    // references!: LReference[];\r\n    // attributes!: LAttribute[];\r\n    // operations!: LOperation[];\r\n\r\n    // personal\r\n    deepSubObjects!: LObject[]; // todo: itera features (lvalue[]) deep e vitando di inserire doppioni (salva una mappatura di di già aggiunti e skip se ricompaiono)\r\n    subObjects!: LObject[];\r\n    referenceFeatures!: LValue[]; // subset of features that are references.\r\n    attributeFeatures!: LValue[]; // subset of features that are attributes.\r\n    shapelessFeatures!: LValue[]; // subset of features that are not mapped and can have any kind of values.\r\n    // + tutte le funzioni di comodità navigazionale del modello, trattarlo un pò come se fosse un modello (e quasi può esserlo)\r\n    instanceof!: LClass;\r\n    features!: LValue[];\r\n    isRoot!: boolean;\r\n    readonly partial!: boolean;\r\n\r\n    protected get_name(context: Context): this['name'] {\r\n        return (context.proxyObject as GObject)['$name']?.value || context.data.name || context.proxyObject.instanceof.name;\r\n    }\r\n\r\n    composed!:boolean;\r\n    aggregated!:boolean;\r\n    contained!:boolean;\r\n    referencedBy!: LValue[];\r\n    protected get_composed(c: Context): this['composed'] { return (LClass.singleton as LClass).get_composed(c as any); }\r\n    protected get_aggregated(c: Context): this['aggregated'] { return (LClass.singleton as LClass).get_aggregated(c as any); }\r\n    protected get_contained(c: Context): this['contained'] { return (LClass.singleton as LClass).get_contained(c as any); }\r\n    /*\r\n    protected get_referencedBy(c: Context): this[\"referencedBy\"] { return (LClass.singleton as LClass).get_referencedBy(c as any) as any; }\r\n    */\r\n    get_referencedBy(context: Context): LObject[\"referencedBy\"] {\r\n        let state: DState = store.getState();\r\n        let targeting: LValue[] = LPointerTargetable.fromArr(context.data.pointedBy.map( p => {\r\n            let s: GObject = state;\r\n            for (let key of PointedBy.getPathArr(p)) {\r\n                s = s[key];\r\n                if (!s) return null;\r\n                if (s.className === DValue.cname) return s.id;\r\n            }\r\n        }));\r\n        return targeting;\r\n    }\r\n\r\n    protected get_truechildren(context: Context): this[\"children\"] {\r\n        let childs: LValue[] = super.get_children(context);\r\n        if (!context.data.instanceof) return childs;\r\n        return childs.filter( (c) => !c.isMirage);\r\n    }\r\n\r\n    protected get_allChildren(context: Context): this[\"children\"] { return super.get_children(context); }\r\n\r\n    protected get_children(context: Context, sort: boolean = true): this[\"children\"] {\r\n        const pointers = [...(new Set(super.get_children(context).map(c => c.id)))];\r\n        let childs: LValue[] = LValue.fromArr(pointers);\r\n        let meta: LClass = context.proxyObject.instanceof;\r\n        // if (!sort && (!meta || meta.partial)) return childs;\r\n        let conformchildren: undefined | Pointer[] = meta && !meta.partial ? meta.allChildren.map(c => c.id) : undefined;\r\n        if (!sort) {\r\n            // console.log(\"return get features:\", {context, meta, childs, conformchildren, ret:childs.filter((c) => (c.instanceof?.id) && conformchildren!.includes(c.instanceof?.id))});\r\n            if (!conformchildren) return childs;\r\n            return childs.filter((c) => (c.instanceof?.id) && conformchildren!.includes(c.instanceof?.id));\r\n        }\r\n\r\n        let bymetaparent: Dictionary<DocString<\"metaparent pointer\">, LValue[]> = {};\r\n        for (let v of childs) {\r\n            let vmeta = v.instanceof;\r\n            // console.log(\"get features filtering:\", {context, meta, vmeta, v, childs, conformchildren});\r\n\r\n            if (conformchildren && (!vmeta || !conformchildren.includes(vmeta.id))) continue;\r\n            let vmetaid: string = vmeta?.id as string; // undef as key is fine even if compiler complains, so i cast it\r\n            if (!bymetaparent[vmetaid]) bymetaparent[vmetaid] = [v]; else bymetaparent[vmetaid as any].push(v);\r\n        }\r\n        // console.log(\"return get features:\", {context, meta, childs, conformchildren, ret:Object.values(bymetaparent).flat()});\r\n        return Object.values(bymetaparent).flat();\r\n    }\r\n\r\n    typeStr!:string; // derivate attribute, abstract\r\n    typeString!:string; // derivate attribute, abstract\r\n    __info_of__typeStr: Info = {type: ShortAttribETypes.EString, txt: <div>Alias of<i>this.typeString</i></div>}\r\n    __info_of__typeString: Info = {type: ShortAttribETypes.EString, txt: <div>Stringified version of <i>this.type</i></div>}\r\n    protected get_typeString(c: Context): string { return this.get_typeStr(c); }\r\n    protected get_typeStr(c: Context): string {\r\n        let thiss: GObject<this> = this as any;\r\n        if (!thiss.get_instanceof) return 'shapeless';\r\n        let meta: any = thiss.get_instanceof(c);\r\n        return meta?.typeToShortString?.() || \"shapeless\"; }\r\n\r\n    // protected get_fromlclass<T extends keyof (LClass)>(meta: LClass, key: T): LClass[T] { return meta[key]; }\r\n    protected get_model(context: Context): LModelElement[\"model\"] {\r\n        let l: LValue | LObject | LModel = context.proxyObject;\r\n        while (l && l.className !== DModel.cname) l = l.father;\r\n        return l as LModel; }\r\n    // protected set_name(val: string, context: Context): boolean { return this.cannotSet(\"name\"); }\r\n    protected set_namespace(val: string, context: Context): boolean { return this.cannotSet(\"namespace\"); }\r\n    // protected get_namespace(context: Context): LClass[\"namespace\"] { return context.proxyObject.instanceof.namespace; }\r\n    protected set_fullname(val: string, context: Context): boolean { return this.cannotSet(\"fullname\"); }\r\n    // protected get_fullname(context: Context): LClass[\"fullname\"] { return context.proxyObject.instanceof.fullname; }\r\n    protected set_ecoreRootName(val: string, context: Context): boolean { return this.cannotSet(\"ecoreRootName\"); }\r\n    protected get_ecoreRootName(context: Context): LObject[\"ecoreRootName\"] {\r\n        let instanceoff: LClass = context.proxyObject.instanceof;\r\n        if (!instanceoff) return \"schemaless:Object\";\r\n        return this.get_uri(context) + \":\" + instanceoff.name; // optimize later in instanceoff.namespace + \":\" + instanceoff.name; and implement namespace all around\r\n    }\r\n    protected set_partialdefaultname(val: DClass[\"partialdefaultname\"], context: Context): boolean { return this.cannotSet(\"DObject.partialdefaultname()\"); }\r\n    protected get_partialdefaultname(context: Context): DClass[\"partialdefaultname\"] { return context.data.instanceof ? context.proxyObject.instanceof.partialdefaultname : \"val_\"; }\r\n    protected set_partial(val: DClass[\"partial\"], context: Context): boolean { return this.cannotSet(\"DObject.set_partial()\"); }\r\n    protected get_partial(context: Context): DClass[\"partial\"] { return context.data.instanceof ? context.proxyObject.instanceof?.partial : true; }\r\n\r\n    /*    protected set_abstract(val: string, context: Context): boolean { return this.cannotSet(\"abstract\"); }\r\n        protected get_abstract(context: Context): LClass[\"abstract\"] { return context.proxyObject.instanceof.abstract; }\r\n        protected set_interface(val: string, context: Context): boolean { return this.cannotSet(\"interface\"); }\r\n        protected get_interface(context: Context): LClass[\"interface\"] { return context.proxyObject.instanceof.interface; }*/\r\n    protected set_defaultValue(val: string, context: Context): boolean { return this.cannotSet(\"defaultValue\"); }\r\n    protected get_defaultValue(context: Context): LClass[\"defaultValue\"] { return context.proxyObject.instanceof.defaultValue; }\r\n    protected set_referencedBy(val: string, context: Context): boolean { return this.wrongAccessMessage(\"referencedBy cannot be set directly. It should be updated automatically as side effect\"); }\r\n\r\n    protected get_subObjects(context: Context): this[\"subObjects\"] {\r\n        let ref_features: LValue[] = this.get_referenceFeatures(context, false).filter( (f) => (f.instanceof as LReference)!.containment );\r\n        let shapeless_features: LValue[] = this.get_shapelessFeatures(context);\r\n        let vals: LObject[] = [\r\n            ...ref_features.flatMap((f) => (f.values as LObject[])).filter((val)=>!!val),\r\n            ...shapeless_features.flatMap((f) => (f.values as any))\r\n                .filter((val)=>(!!val && val.className === DObject.cname)) as LObject[]\r\n        ];\r\n        return vals;\r\n    }\r\n\r\n    protected get_deepSubObjects(context: Context): this[\"deepSubObjects\"] {\r\n        let alreadyparsed: Dictionary<Pointer, LObject> = {};\r\n        let arr: LObject[] = this.get_subObjects(context);\r\n        while(arr.length) {\r\n            let next: LObject[] = [];\r\n            for (let obj of arr) {\r\n                if (alreadyparsed[obj.id]) continue;\r\n                alreadyparsed[obj.id] = obj;\r\n                next.push(...obj.subObjects);\r\n            }\r\n            arr = next;\r\n        }\r\n        return Object.values(alreadyparsed) || [];\r\n    }\r\n\r\n    protected get_referenceFeatures(context: Context, includeshapeless: boolean = false): this[\"referenceFeatures\"] {\r\n        return context.proxyObject.features.filter((f) => (!f.instanceof ? includeshapeless : f.instanceof.className === DReference.cname));\r\n    }\r\n    protected get_attributeFeatures(context: Context, includeshapeless: boolean = false): this[\"attributeFeatures\"] {\r\n        return context.proxyObject.features.filter((f) => (!f.instanceof ? includeshapeless : f.instanceof.className === DAttribute.cname));\r\n    }\r\n\r\n    protected get_shapelessFeatures(context: Context): this[\"shapelessFeatures\"] {\r\n        return context.proxyObject.features.filter((f) => (!f.instanceof));\r\n    }\r\n\r\n    protected get_isRoot(context: Context): LObject[\"isRoot\"] { return context.proxyObject.father.className === DModel.cname; }\r\n    protected set_isRoot(val: never, context: Context): boolean { return this.wrongAccessMessage(\"isRoot cannot be set directly, change father element instead.\"); }\r\n\r\n    public feature(name: string): (PrimitiveType|LObject)|(PrimitiveType|LObject)[] { this.cannotCall('feature'); return null; }\r\n    private get_feature(context: Context): (name: string) => LValue[\"value\"] | LValue[\"values\"] {\r\n        return (name: string) => {\r\n            const lObject = context.proxyObject;\r\n            const features = lObject.features.filter((value) => {\r\n                return value.instanceof?.name === name\r\n            });\r\n            if(features.length > 0) {\r\n                const matchedFeature = features[0];\r\n                switch(matchedFeature.values.length) {\r\n                    case 0: return '';\r\n                    case 1: return matchedFeature.value;\r\n                    default: return matchedFeature.values;\r\n                }\r\n            } return '';\r\n        }\r\n    }\r\n\r\n\r\n    protected generateEcoreJson_impl(context: Context, loopDetectionObj: Dictionary<Pointer, DModelElement> = {}): Json {\r\n        loopDetectionObj[context.data.id] = context.data;\r\n        let asEcoreRoot = (context.proxyObject.isRoot);\r\n        // todo: actually use this loopdetectionobj\r\n        const json: GObject = {};\r\n        if (asEcoreRoot) {\r\n            console.log(\"generate object ecore\", {context, asEcoreRoot, json});\r\n            const lc: LClass = context.proxyObject.instanceof;\r\n            json[ECorePackage.xmiversion] = '2.0';\r\n            json[ECorePackage.xmlnsxmi] = 'http://www.omg.org/XMI';\r\n            // json[ECorePackage.xmlnsxsi] = 'http://www.w3.org/2001/XMLSchema-instance';\r\n            json[\"xmlns:\" + ( lc ? (lc.father.uri + \".\" +lc.father.name) : \"shapeless.model.uri\")] = 'http://www.eclipse.org/emf/2002/Ecore';\r\n        }\r\n\r\n        let features = context.proxyObject.features || [];\r\n        console.log(\"features\", {features});\r\n        for (let f of features) {\r\n            if (!f) continue;\r\n            let meta = f.instanceof;\r\n            if (meta?.volatile) { continue; }\r\n            (!json[f.name]) && (json[f.name] = f.generateEcoreJson(loopDetectionObj));\r\n        }\r\n        return json; }\r\n\r\n    public addValue(name?: DValue[\"name\"], instanceoff?: DValue[\"instanceof\"], value?: DValue[\"values\"], isMirage?: boolean): LValue { return this.cannotCall(\"addValue\"); }\r\n    protected get_addValue(context: Context): this[\"addValue\"] {\r\n        return (name?: DValue[\"name\"], instanceoff?: DValue[\"instanceof\"], value?: DValue[\"values\"], isMirage?: boolean) => {\r\n            return LPointerTargetable.fromD(DValue.new(name, instanceoff, value, context.data.id, true, isMirage));\r\n        }\r\n    }\r\n\r\n    protected get_namespace(context: Context): string {\r\n        return context.data.instanceof ? context.proxyObject.instanceof.father.prefix : \"schemaless\"; }\r\n    protected get_uri(context: Context): string {\r\n        if (!context.data.instanceof) return \"schemaless\";\r\n        let pkg = context.proxyObject.instanceof.father;\r\n        return pkg.uri;// + \".\" + pkg.name;\r\n    }\r\n    // protected get_namespace(context: Context): string { if (!context.data.instanceof) return \"schemaless\"; return context.proxyObject.instanceof.namespace; }\r\n\r\n    protected get_children_idlist(context: Context): Pointer<DAnnotation | DValue, 1, 'N'> {\r\n        return [...super.get_children_idlist(context) as Pointer<DAnnotation | DValue, 1, 'N'>,\r\n            ...context.data.features];\r\n    }\r\n\r\n    protected get_instanceof(context: Context): this[\"instanceof\"] {\r\n        const pointer = context.data.instanceof;\r\n        return pointer && LPointerTargetable.from(pointer)\r\n    }\r\n    protected set_instanceof(val: Pack1<this[\"instanceof\"]>, context: Context): boolean {\r\n        const metaptr: D[\"instanceof\"] = Pointers.from(val);\r\n        this._removeConformity(context);\r\n        SetFieldAction.new(context.data.id, \"instanceof\", metaptr, undefined, true);\r\n        // update father's collections (pointedby's here are set automatically)\r\n        metaptr && SetFieldAction.new(metaptr as Pointer<DClass>, \"instances\", context.data.id, '+=', true);\r\n        if (metaptr) this._forceConformity(context, metaptr);\r\n        return true;\r\n    }\r\n\r\n    private forceConformity(context: Context, meta: D[\"instanceof\"]): void {\r\n        let oldinstanceof = context.data.instanceof;\r\n        // context.data.instanceof = meta;\r\n        let ret = this._forceConformity(context, meta);\r\n        // context.data.instanceof = oldinstanceof;\r\n        return ret;\r\n    }\r\n    private _forceConformity(context: Context, meta: D[\"instanceof\"]): void {\r\n        let lmeta = meta && LPointerTargetable.wrap(meta) as this[\"instanceof\"];\r\n        if (!lmeta) return;\r\n        let attrs = lmeta.allAttributes;\r\n        let refs = lmeta.allReferences;\r\n        let values = context.proxyObject.allChildren;\r\n        let idmap: Dictionary<string, LAttribute | LReference> = {};\r\n        for (let a of attrs) { idmap[a.id] = a; }\r\n        for (let a of refs) { idmap[a.id] = a; }\r\n        console.log({idmap, values, data: context.data, l:context.proxyObject});\r\n        // damiano: todo quando viene cancellato una feature il puntatore in features e values rimane. use pointedby's\r\n        // then remove attributes and references that are already instantiated in the object\r\n        for (let v of values) { if(v && v.__raw.instanceof) delete idmap[v.__raw.instanceof]; }\r\n        console.log(\"forceconformity\", {attrs, refs, valuesPre: values.map(v => v && v.__raw.instanceof), toadd:idmap});\r\n        for (let id in idmap) {\r\n            // let l = idmap[id];\r\n            context.proxyObject.addValue(undefined, id, [],true);\r\n        }\r\n    }\r\n    private _removeConformity(context: Context): void {\r\n        let childs = context.proxyObject.features;\r\n        for (let child of childs) if (child.isMirage) child.delete();\r\n    }\r\n\r\n\r\n    protected get_delete(context: Context): () => void {\r\n        return () => {\r\n            let c: LClass = this.get_instanceof(context);\r\n            if(c && c.isSingleton) {\r\n                Log.ww('Object is a singleton and cannot be removed, remove his singleton flag in m2 first.', context.data);\r\n                return;\r\n            }\r\n            console.log('test 0')\r\n            super.get_delete(context)();\r\n        }\r\n    }\r\n    protected get_features(context: Context): this['features'] {\r\n        return this.get_children(context);\r\n        // return context.data.features.map((feature) => { return LPointerTargetable.from(feature) });\r\n    }\r\n\r\n    public ecorePointer(): string { return this.cannotCall(\"ecorePointer\"); }\r\n    protected get_ecorePointer(context: Context): () => string {\r\n        let lastvisited: Pointer<DObject, 1, 1, LObject> = context.data.id;\r\n        return () => \"@//\" + this.get_fatherList(context).map( (f: LModelElement | LObject | LValue) => {\r\n            if (f.className === DObject.cname) { lastvisited = (f as LObject).id; return ''; }\r\n            if (f.className === DModel.cname) { return ''; }\r\n            console.log(\"get_ecorepointer\", f, f.__raw, lastvisited);\r\n            return (f as LValue).name + \".\" + ((f as LValue).__raw.values.indexOf(lastvisited));\r\n        }).filter(v=>!!v).join(\"@/\");\r\n    }\r\n\r\n}\r\nRuntimeAccessibleClass.set_extend(DNamedElement, DObject);\r\nRuntimeAccessibleClass.set_extend(LNamedElement, LObject);\r\n\r\n@Leaf\r\n@RuntimeAccessible('DValue')\r\nexport class DValue extends DModelElement { // extends DModelElement, m1 value (attribute | reference)\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // static singleton: LValue;\r\n    // static logic: typeof LModelElement;\r\n    // static structure: typeof DValue;\r\n\r\n    // inherit redefine\r\n    id!: Pointer<DValue, 1, 1, LValue>;\r\n    parent: Pointer<DObject, 0, 'N', LObject> = [];\r\n    father!: Pointer<DObject, 1, 1, LObject>;\r\n    annotations: Pointer<DAnnotation, 0, 'N', LAnnotation> = [];\r\n    name?: string; // nome opzionale solo per modelli schema-less\r\n\r\n    // personal\r\n    // value: PrimitiveType | Pointer<DObject, 1, 1, LObject>; // vv4\r\n    // values: PrimitiveType[] | Pointer<DObject, 1, 'N', LObject> | Pointer<DEnumLiteral, 1, 'N', LEnumLiteral> = []; // vv4\r\n    values: PrimitiveType[] | Pointer<DObject|DEnumLiteral, 1, 'N', LObject|LEnumLiteral> = [];\r\n    instanceof!: Pointer<DAttribute, 1, 1, LAttribute > | Pointer<DReference, 1, 1, LReference> | undefined; // todo: maybe min lowerbound 0 if you want to allow free shape objects chiedere prof\r\n    edges!: Pointer<DEdge, 0, 'N', LEdge>;\r\n    // conformsTo!: Pointer<DStructuralFeature, 0, 'N', LStructuralFeature>; // low priority to do: attributo fittizio controlla a quali elementi m2 è conforme quando viene richiesto\r\n    isMirage!: boolean;\r\n    allowCrossReference!: boolean;\r\n    // IoT Section\r\n    topic: string = '';\r\n\r\n    public static new(name?: DNamedElement[\"name\"], instanceoff?: DValue[\"instanceof\"], val?: DValue[\"values\"],\r\n                      father?: DValue[\"father\"] | DObject, persist: boolean = true, isMirage: boolean = false): DValue {\r\n        if (!name) name = this.defaultname(\"property_\", father);\r\n        return new Constructors(new DValue('dwc'), (typeof father === \"string\" ? father : (father as DObject)?.id), persist, undefined)\r\n            .DPointerTargetable().DModelElement()\r\n            .DNamedElement(name)\r\n            .DValue(instanceoff, val, isMirage).end();\r\n    }\r\n\r\n    public static new3(a:Partial<ValuePointers>, then?:((d:DValue, c: Constructors)=>void), persist: boolean = true): DValue{\r\n        if (!a.name) a.name = this.defaultname(\"property_\", a.father);\r\n        return new Constructors(new DValue('dwc'), a.father, persist, undefined, a.id)\r\n            .DPointerTargetable().DModelElement()\r\n            .DNamedElement(a.name)\r\n            .DValue(a.instanceof, a.values)\r\n            .end(then);\r\n    }\r\n}\r\n@RuntimeAccessible('LValue')\r\nexport class LValue<Context extends LogicContext<DValue> = any, C extends Context = Context, D extends DValue = DValue> extends LModelElement { // extends DModelElement, m1 value (attribute | reference)\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    public __raw!: DValue;\r\n    id!: Pointer<DValue, 1, 1, LValue>;\r\n\r\n    // inherit redefine\r\n    parent!: (LObject | LModel)[];\r\n    father!: LObject | LModel;\r\n    model!: LModel;\r\n    // from namedelement\r\n    name!: string;\r\n    namespace!: string;\r\n    fullname!:string;\r\n    type!: LClassifier; // Classifiers describing PrimitiveTypes or the classes that can be pointed.\r\n    primitiveType!: LClass;\r\n    classType!: LClass;\r\n    enumType!: LEnumerator;\r\n// from structuralfeature (ref + attr)\r\n    ordered!: boolean;\r\n    unique!: boolean;\r\n    lowerBound!: number;\r\n    upperBound!: number;\r\n    many!: boolean;\r\n    required!: boolean;\r\n    allowCrossReference!: boolean;\r\n\r\n    changeable!: boolean;\r\n    volatile!: boolean;\r\n    transient!: boolean;\r\n    unsettable!: boolean;\r\n    public derived!: boolean;\r\n    /*protected */derived_read?: string;\r\n    /*protected */derived_write?: string;\r\n    /*protected*/ __info_of__derived: Info = {type: 'string', txt:'A ECore flag to signal the values of this feature depend on other features.\\n' +\r\n            'To make it usable at runtime in jjodel check derived_read and derived_write.'}\r\n    /*protected*/ __info_of__derived_read: Info = {type: 'string', txt:'A function in string format with 2 or less attributes: (data, oldValue).\\n' +\r\n            '- data is the LValue hosting this derived feature\\n' +\r\n            '- originalValues are the current **non-derived** values actually memorized in the data.values\\n'+\r\n            'The mandatory return value of this function will be returned when attempted to read data.values.'}\r\n    /*protected*/ __info_of__derived_write: Info = {type: 'string', txt:'A function in string format with 3 or less attributes: (value, data, oldValue).\\n' +\r\n            '- value is the value currently attempted to be set, which triggered the function call.\\n' +\r\n            '- data is the LValue hosting this derived feature\\n' +\r\n            '- originalValues are the current **non-derived** values actually memorized in the data.values\\n'+\r\n            'The optional return value of this function will be stored inside data, allowing for hybrid dependency-persistant features' +\r\n            '\\n or for a feature \"depending on itself\". like uppercasing his values before setting them.'}\r\n    defaultValue!: DStructuralFeature[\"defaultValue\"];\r\n    // defaultValueLiteral!: string;\r\n    // target!: LClass[]; is value[]\r\n    edges!: LEdge[];\r\n    // IoT Section\r\n    topic!: string;\r\n\r\n\r\n    // personal\r\n    value!: PrimitiveType | LObject | LEnumLiteral;\r\n    isMirage!: boolean;\r\n    // value!: PrimitiveType | LObject;\r\n    values!: PrimitiveType[] | LObject[] | LEnumLiteral[];\r\n    instanceof!: LAttribute | LReference | undefined;\r\n    conformsTo!:( LAttribute | LReference)[]; // low priority to do: attributo fittizio controlla a quali elementi m2 è conforme quando viene richiesto\r\n\r\n\r\n    length!: number;\r\n    __info_of__length: Info = {type: 'number', txt: \"shortcut for data.values.length.\"};\r\n    get_length(c: Context): number{\r\n        return this.get_values(c).length;\r\n    }\r\n\r\n\r\n\r\n    protected set___readonly(val: any, c: Context): boolean {\r\n        val = !!val;\r\n        if (val === c.data.__readonly) return true;\r\n        super.set___readonly(val, c);\r\n        let lref: LReference = this.get_instanceof(c) as LReference;\r\n        if (!lref) return true;\r\n        let dref = lref.__raw;\r\n        if (dref.composition || dref.aggregation) for(let v0 of this.get_values(c)) {\r\n            if (!v0) continue;\r\n            let v: GObject = v0 as any;\r\n            if (v.__isproxy) v.__readonly = val;\r\n        }\r\n        return true;\r\n    }\r\n    protected get_toPrimitive(c: Context): ()=>(string | number){\r\n        return ()=>this.get_value(c) as any;\r\n    }\r\n\r\n\r\n// from reference\r\n    container!: boolean;\r\n    opposite?: LValue; // if DRef have opposite DRef, when you set a value ref you also set a opposite value ref from target to this src. they are always mirroring.\r\n    containment!:boolean;\r\n    aggregation!:boolean;\r\n    composition!:boolean;\r\n    upperbound!:boolean;\r\n    lowerbound!:boolean;\r\n    protected _defaultGetter(c: Context, k: string | number): any {\r\n        if (k in c.data || typeof k === \"symbol\") return this.__defaultGetter(c, k);\r\n\r\n        // get from values\r\n        if (typeof k === \"number\") return this.get_values(c)[k];\r\n        if (TargetableProxyHandler.childKeys[k[0]]) {\r\n            k = k.substring(1);\r\n            let vals: any[] = this.get_values(c);\r\n            for (let v of vals) {\r\n                if (!v) continue;\r\n                let ret = v[k];\r\n                if (ret !== undefined) return ret;\r\n            }\r\n        }\r\n\r\n        // get from meta\r\n        let getk = 'get_'+k;\r\n        if (k in LReference.singleton || getk in LReference.singleton) return this.get_instanceof(c)?.[k as any];\r\n        if (k in LAttribute.singleton || getk in LAttribute.singleton) return this.get_instanceof(c)?.[k as any];\r\n\r\n        return this.__defaultGetter(c, k);\r\n    }\r\n\r\n    protected _defaultSetter(v: any, c: Context, k: keyof Context[\"data\"] & string): true { //\r\n        if (super._setterFor$stuff_canReturnFalse(v, c, k as string)) return true; // try setter for data.$feature = value; shortcut for data.$feature.value = value;\r\n        this.__defaultSetter(v, c, k);\r\n        return true;\r\n    }\r\n\r\n\r\n    protected get_derived(c: Context): this[\"derived\"] { return (this.get_instanceof(c) as LReference).derived; }\r\n    protected get_derived_read(c: Context): this[\"derived_read\"] { return (this.get_instanceof(c) as LReference).derived_read; }\r\n    protected get_derived_write(c: Context): this[\"derived_write\"] { return (this.get_instanceof(c) as LReference).derived_write; }\r\n    protected set_derived(val: this[\"derived\"], context: Context): boolean { return this.cannotSet('LValue.derived'); }\r\n    protected set_derived_read(val: this[\"derived_read\"], context: Context): boolean { return this.cannotSet('LValue.derived_read'); }\r\n    protected set_derived_write(val: this[\"derived_write\"], context: Context): boolean { return this.cannotSet('LValue.derived_write'); }\r\n\r\n    add(...val: any[]): void { return this.cannotCall(\"LValue.add\"); }\r\n    __info_of__add: Info = {type: \"(...val: any|any[]) => void\", txt: \"Adds a value in the current value collection\"}\r\n    get_add(c: Context): (...val: any[] | this[\"values\"])=>void{\r\n        return (...val: any[] | this[\"values\"]) => { this.set_values([...c.data.values, ...val.map(v => v?.id || v)], c); }\r\n    }\r\n    remove(...val: any[]): void{ return this.cannotCall(\"LValue.remove\"); }\r\n    __info_of__remove: Info = {type: \"(...val: any) => void\", txt: \"Deletes a value in the current value collection, or none if the element is not found.\"}\r\n    get_remove(c: Context): (...val: this[\"values\"])=>void {\r\n        return (...val: any[] | this[\"values\"]) => {\r\n            val = val.map(v => v?.id || v);\r\n            let indices = [];\r\n            let values = c.data.values;\r\n            for (let i = 0; i < values.length; i++) {\r\n                if (val.includes(values[i])) indices.push(i);\r\n            }\r\n            this.get_removeByIndex(c)(...indices); }\r\n    }\r\n    removeByIndex(...val: number[]): void{ return this.cannotCall(\"LValue.removeByIndex\"); }\r\n    __info_of__removeByIndex: Info = {type: \"(...indices: number) => removed[]\", txt: \"Deletes a value in the current value collection, or none if the element is not found.\"}\r\n    get_removeByIndex(c: Context): (...indices: number[])=>void{ return (...indices: number[]) => {\r\n        // reducer is ill-typed, so must force typings\r\n        const indexMap: GObject = indices.reduce<GObject|number>(((accumulator: GObject, currentValue: number) => { accumulator[currentValue] = true; return accumulator;}) as any, {} as GObject) as any;\r\n        this.set_values(c.data.values.filter((v,index) => !indexMap[index]), c);\r\n        // this.set_values(c.data.values.filter((v,index) => indices.includes(index)));\r\n    }\r\n    }\r\n\r\n    instantiableClasses(o?: GObject, loose: boolean = false):LClass[] { return this.cannotCall(\"instantiableClasses\"); }\r\n    __info_of__instantiableClasses: Info = {type: \"(o?: object, loose?: boolean) => LClass[]\",\r\n        txt: \"List of all subclasses of the specified type, which can be used as reference values.\" +\r\n            \"\\n<br>Abstract and Interface classes are excluded.\" +\r\n            \"\\n<br>If the parameter \\\"o\\\" is specified, it will filter only the instances conforming to the object schema.\" +\r\n            \"\\n<br>Results are sorted from tightest fit to loosest fit.\" +\r\n            \"\\n<br>loose parameter set to true makes return instead a list of matching scores of all subclasses.\", hidden: true}\r\n\r\n    // warning: this can be called through model, c.data might be either a value or a model.\r\n    get_instantiableClasses(c: Context): this[\"instantiableClasses\"] {\r\n        return (o?: GObject, loose: boolean = false) => LValue.getInstantiableClasses(this, c, o, loose); }\r\n\r\n\r\n    // @eligibleClasses: search only between those targets.\r\n    // @favoritematch: if this class is a valid match, it is given topmost priority regardless of tightness of excess features over the schema.\r\n    // if a class name actually starts with $ character, it needs to be placed twice to get a match, as in class.$$name\r\n    public static getInstantiableClasses(thiss: GObject<LValue|LModel>, c: LogicContext<DValue> | LogicContext<DModel>, schema?: GObject, loose: boolean = false, eligibleClasses?: LClass[], favoriteMatch?: LClass): LClass[] {\r\n        // find eligible classes\r\n        let isDValue: boolean =  c.data.className === \"DValue\";\r\n        let isDModel: boolean =  c.data.className === \"DModel\";\r\n        let isShapeless = !c.data.instanceof;\r\n        let type: LClass | undefined = isShapeless || !isDValue ? undefined : thiss.get_type(c) as LClass;\r\n        let isReference = !!type && type.className === \"DClass\";\r\n        if (isDValue && !isReference && !isShapeless) return []; // case DValue<Attribute>\r\n        if (!eligibleClasses) {\r\n            if (isReference && !isShapeless) { eligibleClasses = [type as LClass, ...(type as LClass).allSubClasses]; }\r\n            // @ts-ignore\r\n            else {eligibleClasses = thiss.get_model(c).instanceof?.classes || []; }\r\n        }\r\n        let scoreMap: Dictionary<Pointer, {\r\n            id: Pointer, score: number,\r\n            excessFeatures: Dictionary<string>, matchingFeatures: Dictionary<string>, missingFeatures: Dictionary<string>,\r\n            excessFeaturesCount: number, matchingFeaturesCount: number, missingFeaturesCount: number,\r\n            isPartial: boolean,\r\n            class:LClass, instantiable: boolean, namesMap: Dictionary<DocString<\"feature name\">>}> = {};\r\n        for (let c of eligibleClasses) {\r\n            let raw = c.__raw as DClass;\r\n            let instantiable = !(raw.abstract || raw.interface || raw.isSingleton);\r\n            // if (!loose && instantiable) return false;\r\n            if (scoreMap[raw.id]) continue;\r\n            else scoreMap[raw.id] = {class:c, instantiable, isPartial: raw.partial} as any;\r\n        }\r\n        if (schema) {\r\n            // const fix$ = (vals: string[]) => vals.map(v=> (TargetableProxyHandler.childKeys[k[0]]) ? v.substring(1) : v);\r\n            const fix$ = (obj: GObject) => {\r\n                let ret: GObject = {};\r\n                for (let k in obj) {\r\n                    let k1 :string = (TargetableProxyHandler.childKeys[k[0]]) ? k.substring(1) : k;\r\n                    ret[k1] = obj[k];\r\n                }\r\n                return ret;\r\n            }\r\n            schema = fix$(schema);\r\n            let keys: string[] = Object.keys(schema);\r\n            for (let ptr in scoreMap) {\r\n                let score = scoreMap[ptr];\r\n                score.namesMap = U.objectFromArrayValues(score.class.childNames);\r\n                let diff = U.objdiff(score.namesMap, schema);\r\n                console.log( \"objDiff\", {schema, names:score.namesMap, data:score.class});\r\n                score.id = ptr;\r\n                score.excessFeatures = diff.removed;\r\n                score.missingFeatures = diff.added;\r\n                score.matchingFeatures = {...diff.changed, ...diff.unchanged}\r\n                score.excessFeaturesCount = Object.keys(score.excessFeatures).length;\r\n                score.missingFeaturesCount = Object.keys(score.missingFeatures).length;\r\n                score.matchingFeaturesCount = Object.keys(score.matchingFeatures).length;\r\n                score.score = Math.round(((score.instantiable ? 0 : -1) + (keys.length ? score.matchingFeaturesCount / keys.length : 1))*100)/100;\r\n            }\r\n        }\r\n        let sorted = Object.values(scoreMap);\r\n        if (!loose) sorted = sorted.filter((s) => s.instantiable && (!s.missingFeaturesCount || s.isPartial));\r\n        let favoriteMatchID: undefined | Pointer = favoriteMatch?.id;\r\n        sorted = sorted.sort((a, b): number => {\r\n            // return negative if a is less than b, positive if a is greater than b, and zero if they are equal.\r\n            // but since default order is ascending and i want descending, o reverse it.\r\n            if (a.instantiable && !b.instantiable) return -1;\r\n            if (!a.instantiable && b.instantiable) return +1;\r\n            if (a.missingFeaturesCount === 0 && b.missingFeaturesCount === 0) { // >100% match case (might have excess, take tighter)\r\n                // nly if they are both valid full matches, explicit preference takes precedence. then tightness.\r\n                if (a.id === favoriteMatchID) return -1;\r\n                if (b.id === favoriteMatchID) return +1;\r\n                if (a.matchingFeaturesCount !== b.matchingFeaturesCount) return -a.matchingFeaturesCount + b.matchingFeaturesCount;\r\n                if (a.excessFeaturesCount !== b.excessFeaturesCount) return +a.excessFeaturesCount - b.excessFeaturesCount;\r\n            }\r\n            // <99% match, but might be valid for partial classes.\r\n            if (a.isPartial && !b.isPartial) return -1;\r\n            if (!a.isPartial && b.isPartial) return +1;\r\n            if (a.isPartial && b.isPartial) {\r\n                // only if they are both valid partial matches, explicit preference takes precedence. then tightness.\r\n                if (a.id === favoriteMatchID) return -1;\r\n                if (b.id === favoriteMatchID) return +1;\r\n            }\r\n            // if both partials or none is partial\r\n            // if (a.missingFeaturesCount !== b.missingFeaturesCount) return -a.missingFeaturesCount + b.missingFeaturesCount; should be same as matchingFeaturesCount\r\n            if (a.matchingFeaturesCount !== b.matchingFeaturesCount) return -a.matchingFeaturesCount + b.matchingFeaturesCount;\r\n            if (a.excessFeaturesCount !== b.excessFeaturesCount) return +a.excessFeaturesCount - b.excessFeaturesCount;\r\n            return 0;\r\n        });\r\n        if (loose) return sorted as any;\r\n        return sorted.map(score => score.class);\r\n    }\r\n\r\n    addObject(json?: GObject, metaclass: LClass | Pointer<DClass> | DocString<\"ClassName\"> | undefined | null = undefined): LObject{ return this.cannotCall(\"LValue.addObject\"); }\r\n    __info_of__addObject: Info = {type: \"(json: object, instanceof?: LClass | string | null) => LObject\",\r\n        txt: \"Appends an object instancing \\\"instanceof\\\" to the values.\\n<br>Setting his own properties, and DValues according to the content of the parameter object.\\n<br>\" +\r\n            \"If instanceof is:<ul><li><b>a class or a class name</b>, it will instance that class, or a valid non-abstract subclass.\" +\r\n            \"\\n<br/><b>null</b>, it will instantiate a shapeless object.\" +\r\n            \"\\n<br/><b>undefined or missing</b>, it will first try to find a valid type in m2 or fail.</ul\"}\r\n\r\n    // warning: this can be called through model, c.data might be either a value or a model.\r\n    /*\r\n    @param metaclass: null means \"shapeless\", undefined means automatic or failure, never shapeless.\r\n    type assignment priority:\r\n    1) by explicit type argument\r\n    1.1) treating it as a pointer\r\n    1.2) treating it as a $class_name\r\n    1.3) treating it as a DClass\r\n*/\r\n    get_addObject(c: LogicContext<DValue> | LogicContext<DModel>): (json: GObject, metaclass?: Pack1<LClass> | DocString<\"ClassName\"> | null, forceCreation?:boolean)=>LObject{\r\n        return (json: GObject = {}, metaclass: Pack1<LClass> | DocString<\"ClassName\"> | undefined | null = undefined, forceCreation:boolean = false): LObject => {\r\n            let lobj: LObject = undefined as any;\r\n            let father: Pointer<DValue> | Pointer<DModel> = '';\r\n            let isDValue = c.data.className === \"DValue\";\r\n            let isDModel = c.data.className === \"DModel\";\r\n\r\n            TRANSACTION(() => {\r\n                let instanceoff: undefined | LAttribute | LReference = isDValue ? this.get_instanceof(c as Context) : undefined;\r\n                let dinstanceoff: undefined | DAttribute | DReference = instanceoff && instanceoff.__raw;\r\n                // let ShapelessObjectID =\r\n                let isShapeless: boolean = !dinstanceoff; // || dinstanceoff && ((dinstanceoff?.id | dinstanceoff) === ShapelessObjectID);\r\n                let isReference: boolean = !!(dinstanceoff && dinstanceoff.className === \"DReference\");\r\n                if (isDValue && !isReference && !isShapeless) return Log.ee(\"cannot call addObject() on a DValue implementing an attribute\", {dinstanceoff, thiss:c.data});\r\n                let isContainment: boolean = (isDValue && this.get_containment(c as Context)) || isDModel;\r\n                // if (metaclass === undefined) metaclass = \"object\"; // in this case, i first check if a class \"object\" exist, then make a shapeless object if not.\r\n                let state: DState = store.getState();\r\n\r\n                father = isContainment ? c.data.id : this.get_model(c).id;\r\n                let constructorPointers: Partial<ObjectPointers> = {...json, father};\r\n\r\n                // if undefined = explicitly told to make it shapeless. if null, it's automatic selectyion by value.type or m2-model classes.\r\n                //console.log('Object.new3', {metaclass, forceCreation, json});\r\n                if (metaclass !== null) {\r\n                    let lmetaclass: LClass | undefined;\r\n                    // find instance schema: 1) by explicit type argument\r\n                    if (metaclass) {\r\n                        // find instance schema: 1.1) by pointer AND 1.3) by Dclass\r\n                        lmetaclass = LPointerTargetable.from(metaclass, state);\r\n                        // find instance schema: 1.2) by $class_name\r\n                        if ((!lmetaclass || lmetaclass.className !== \"DClass\") && typeof metaclass === \"string\") {\r\n                            let m2classes = c.proxyObject.model?.instanceof?.classes;\r\n                            if (m2classes) lmetaclass = LPointerTargetable.from(m2classes[\"$\" + metaclass] || m2classes[metaclass], state);\r\n                            // if (!lmetaclass && typeof metaclass === \"string\" && metaclass.toLowerCase() === \"object\") lmetaclass = undefined;\r\n                        }\r\n                        //(window as any).debugg = LValue.getInstantiableClasses(this, c, json, true, lmetaclass ? [lmetaclass, ...lmetaclass.allSubClasses] : []);\r\n                        // check if metaclass is found\r\n                        if (!lmetaclass || lmetaclass.className !== \"DClass\") return Log.ee(\"provided schema type does not belong to a Class, cannot intantiate.\", {lmetaclass, schema:metaclass, this:c.data});\r\n                        // check if metaclass is valid (instantiable in the callee collection: .values or .objects)\r\n                        // console.log(\"isExtending\", {lmetaclass, type: isDValue && this.get_type?.(c as any)});\r\n                        if (isDValue && !lmetaclass.isExtending(this.get_type(c as Context) as LClass)) return Log.ee(\"provided schema type does not extend this.type, cannot intantiate.\", {lmetaclass, schema:metaclass, this:c.data});\r\n                    }\r\n                    // find instance schema: 2) by dvalue.type\r\n                    else if (isDValue && !isShapeless) {\r\n                        lmetaclass = this.get_type(c as Context) as LClass;\r\n                    }\r\n                    // phase 2: using lmetaclass (if found), i set constructorPointers.instanceof\r\n                    // if requested type is found. but might be abstract, so i filter the best subclass match\r\n                    if (lmetaclass) {\r\n                        if (forceCreation && metaclass) {\r\n                            constructorPointers.instanceof = (typeof metaclass === 'string' ? metaclass : (metaclass as any).id);\r\n                        }\r\n                        else {\r\n                            constructorPointers.instanceof = LValue.getInstantiableClasses(this, c, json, false,\r\n                                [lmetaclass, ...lmetaclass.allSubClasses], lmetaclass)[0] as any; // actually a L-class, but \"ObjectPointers\" can accept them too.\r\n                        }\r\n                        if (!constructorPointers.instanceof) { // the whole if is just printing error.\r\n                            let matches = LValue.getInstantiableClasses(this, c, json, true, [lmetaclass, ...lmetaclass.allSubClasses]);\r\n                            if (lmetaclass?.isSingleton) Log.ee(\"addObject(schema) cannot instantiate \" + metaclass + \" because it is a singleton.\", {json, matches, this: c.data});\r\n                            return Log.ee(\"addObject(schema) could not find a valid subtype of \" + metaclass +\r\n                                \" conforming ot that schema to instantiate an object.\\n\" + (matches.length ? \"closest match was: \" + matches[0].name : \"\"),\r\n                                {json, matches, this: c.data});\r\n                        }\r\n                    }\r\n                    // if not found, i look among all m2classes\r\n                    else if (!isDValue || isShapeless) {\r\n                        // if shapelessvalue.addObject() --> infer schema from json keys and ref sub-types best match\r\n                        // if model.addObject() --> find best match within all classes\r\n                        (window as any).debugg = this.get_model(c).instantiableClasses(json, true);\r\n                        constructorPointers.instanceof = this.get_model(c).instantiableClasses(json, false)[0] as any // actually a L-class, but \"ObjectPointers\" can accept them too.\r\n                        if (!constructorPointers.instanceof) { // the whole if is just printing error.\r\n                            let matches = isDValue ? this.get_instantiableClasses(c as Context)(json, true) : this.get_model(c).instantiableClasses(json, true);\r\n                            let type: LClassifier = isDValue ? this.get_type(c as Context) : undefined as any;\r\n                            return Log.ee(\"LValue.addObject(schema) could not find a valid \" + (c.data.className === \"DValue\" ? \"subtype of \" + type.name : \"type\") +\r\n                                \" conforming ot that schema to instantiate an object.\\n\" + (matches.length ? \"closest match was: \" + (matches[0] as any)?.class.name : \"\"), {json, type, matches, thiss: c.data});\r\n                        }\r\n                    }\r\n                    if (!constructorPointers.instanceof && isDValue && !isShapeless) {\r\n                        return Log.ee(\"could not find an instantiable subtype for given schema and type \" + instanceoff?.type?.name, {schema: json, type: instanceoff?.type})\r\n                    }\r\n                }\r\n                // both dmodel.objects nad dvalue.values are updated by the Constructors by passing father parameter.\r\n                // phase 3: create object according to schema (or shapeless) and update parent container collection.\r\n                console.log(\"Object.new3\", {constructorPointers});\r\n                if (!constructorPointers.name && constructorPointers.instanceof){\r\n                    let meta = L.from(constructorPointers.instanceof);\r\n                    if (meta.isSingleton){ constructorPointers.name = meta.name; }\r\n                }\r\n                let dobj = DObject.new3(constructorPointers, () => { }, isDModel?DModel:DValue, true);\r\n                if (isReference && !isContainment){\r\n                    // if is ref containment, object.father is set to value, which also appends the object to this.values\r\n                    // if it's model, object.father = model, and it goes in model.objects and not in values.\r\n                    // if it's non-containment value, it goes in model but also appended to this.values\r\n                    // ? if schemaless acts like a containment ref so still fine ?\r\n                    this.set_values([...(c as Context).data.values, dobj.id], c as Context)\r\n                }\r\n                // phase 4: set sub-DDalues.values according to json data provided, or create them if they were missing in partial class match.\r\n                lobj = LPointerTargetable.fromD(dobj);\r\n                let dobjkeys = Object.keys(dobj);\r\n\r\n                // update lmetaclass from candidate root, to selected instance (sub-type)\r\n                let lmetaclass: LClass | undefined = constructorPointers.instanceof && LPointerTargetable.wrap(constructorPointers.instanceof);\r\n                let isPartial: boolean = !!lmetaclass?.partial;\r\n                let childnames: Dictionary<string> = lmetaclass ? U.objectFromArrayValues(lmetaclass.childNames) : {};\r\n                // because at current time Constructor.setPtr actions are not executed yet. so dobject.features is empty, even through LPoint.from(valueid) canaccess the \"pending\" local dvalue not in store.\r\n                setTimeout(()=>TRANSACTION(()=>{\r\n                    for (let key in json) {\r\n                        if (TargetableProxyHandler.childKeys[key[0]]) { // if $ is prepended, priority is first and only child values check\r\n                            if (key in childnames) { // if child dvalue with that name including char $ exist, like in \"$\" + \"$name\"\r\n                                (lobj as GObject<LObject>)[\"$\" + key].values = json[key];\r\n                                continue;\r\n                            }\r\n                            let key1 = key.substring(1);\r\n                            if (key1 in childnames) { // if child dvalue with that name excluding char $ exist, like in \"$\" + \"name\" (as normal)\r\n                                (lobj as GObject<LObject>)[\"$\" + key1].values = json[key];\r\n                                continue;\r\n                            }\r\n                            // if child dvalue with that name do not exist\r\n                            if (isShapeless || isPartial) { lobj.addValue(key, undefined, json[key], false); continue; }\r\n                            // this should never happen, if there is a mismatch in finding the correct type conforming to the schema, the function should have already stopped and returned before.\r\n                            Log.eDevv('addObject(schema) error: cannot find value collection named \"' + key + ' \" as defined in the schema parameter.',\r\n                                {lmetaclass, this:c.data, instanceof: constructorPointers.instanceof});\r\n                            continue;\r\n                        }\r\n                        // if $ is NOT prepended, priority is inverted: first DObject properties, then child values\r\n                        if (key in dobjkeys) { (lobj as GObject<LObject>)[key] = json[key]; continue; }\r\n                        else {\r\n                            // redoing the whole childmatch attempt for shaped and shapeless, when first char is not $, as a fallback.\r\n                            if (key in childnames) { // if child dvalue with that name excluding char $ exist, like in \"$\" + \"name\" (as normal)\r\n                                console.log(\"get_addObject() adding values\", {lobj, key, json, childnames, d:constructorPointers.instanceof});\r\n                                (lobj as GObject<LObject>)[\"$\" + key].values = json[key];\r\n                                continue;\r\n                            }\r\n                            else if (isShapeless || isPartial) { lobj.addValue(key, undefined, json[key], false); continue; }\r\n                            Log.eDevv('addObject(schema) error: cannot find value collection named \"' + key + ' \" as defined in the schema parameter.',\r\n                                {lmetaclass, this:c.data, instanceof: constructorPointers.instanceof, dobjkeys});\r\n                            continue;\r\n                        }\r\n                    }\r\n                }), 100);\r\n            });\r\n            return lobj;\r\n        }\r\n    }\r\n\r\n\r\n    protected get_edges(context: Context): this[\"edges\"] { return LPointerTargetable.fromPointer(context.data.edges) || []; }\r\n    protected get_fromlfeature<C, T extends keyof (NonNullable<C>)>(meta: C, key: T): NonNullable<C>[T] { return meta ? (meta as any)[key] : undefined; }\r\n    protected get_opposite(context: Context): LReference[\"opposite\"] { return this.get_fromlfeature(context.proxyObject.instanceof as LReference, \"opposite\"); }\r\n    protected get_container(context: Context): LReference[\"container\"] { return this.get_fromlfeature(context.proxyObject.instanceof as LReference, \"container\"); }\r\n    protected get_isContainment(c: Context): LReference[\"containment\"] { return this.get_containment(c); }\r\n    protected get_containment(context: Context): LReference[\"containment\"] {\r\n        let iof = context.proxyObject.instanceof;\r\n        if (!iof) return true; // shapeless\r\n        return this.get_fromlfeature(iof as LReference, \"containment\"); }\r\n    // protected get_defaultValueLiteral(context: Context): LStructuralFeature[\"defaultValueLiteral\"] { return this.get_fromlfeature(context.proxyObject.instanceof, \"defaultValueLiteral\"); }\r\n    protected get_defaultValue(context: Context): LStructuralFeature[\"defaultValue\"] { return this.get_fromlfeature(context.proxyObject.instanceof, \"defaultValue\"); }\r\n    protected get_defaultderived(context: Context): DStructuralFeature[\"derived\"] { return this.get_fromlfeature(context.proxyObject.instanceof, \"derived\"); }\r\n    protected get_defaultunsettable(context: Context): LStructuralFeature[\"unsettable\"] { return this.get_fromlfeature(context.proxyObject.instanceof, \"unsettable\"); }\r\n    protected get_defaulttransient(context: Context): LStructuralFeature[\"transient\"] { return this.get_fromlfeature(context.proxyObject.instanceof, \"transient\"); }\r\n    protected get_isVolatile(c: Context): LReference[\"volatile\"] { return this.get_volatile(c); }\r\n    protected get_volatile(context: Context): LStructuralFeature[\"volatile\"] { return this.get_fromlfeature(context.proxyObject.instanceof, \"volatile\"); }\r\n    protected get_isChangeable(context: Context): LStructuralFeature[\"changeable\"] { return this.get_changeable(context); }\r\n    protected get_changeable(context: Context): LStructuralFeature[\"changeable\"] { return this.get_fromlfeature(context.proxyObject.instanceof, \"changeable\"); }\r\n    protected get_isRequired(context: Context): LStructuralFeature[\"required\"] { return this.get_required(context); }\r\n    protected get_required(context: Context): LStructuralFeature[\"required\"] { return this.get_fromlfeature(context.proxyObject.instanceof, \"required\"); }\r\n    protected get_isUnique(context: Context): LStructuralFeature[\"unique\"] { return this.get_unique(context); }\r\n    protected get_unique(context: Context): LStructuralFeature[\"unique\"] { return this.get_fromlfeature(context.proxyObject.instanceof, \"unique\"); }\r\n    protected get_isMany(context: Context): LStructuralFeature[\"many\"] { return this.get_many(context); }\r\n    protected get_many(context: Context): LStructuralFeature[\"many\"] { return this.get_fromlfeature(context.proxyObject.instanceof, \"many\"); }\r\n    protected get_upperBound(context: Context): LStructuralFeature[\"upperBound\"] { return this.get_fromlfeature(context.proxyObject.instanceof, \"upperBound\"); }\r\n    protected get_lowerBound(context: Context): LStructuralFeature[\"lowerBound\"] { return this.get_fromlfeature(context.proxyObject.instanceof, \"lowerBound\"); }\r\n    protected get_ordered(context: Context): LStructuralFeature[\"ordered\"] { return this.get_fromlfeature(context.proxyObject.instanceof, \"ordered\"); }\r\n    protected get_enumType(context: Context): LStructuralFeature[\"enumType\"] { return this.get_fromlfeature(context.proxyObject.instanceof, \"enumType\"); }\r\n    protected get_classType(context: Context): LStructuralFeature[\"classType\"] { return this.get_fromlfeature(context.proxyObject.instanceof, \"classType\"); }\r\n    protected get_primitiveType(context: Context): LStructuralFeature[\"primitiveType\"] { return this.get_fromlfeature(context.proxyObject.instanceof, \"primitiveType\"); }\r\n    protected get_type(context: Context): LStructuralFeature[\"type\"] { return this.get_fromlfeature(context.proxyObject.instanceof, \"type\"); }\r\n    // protected get_fullname(context: Context): LStructuralFeature[\"fullname\"] { return this.get_fromlfeature(context.proxyObject.instanceof, \"fullname\"); }\r\n    protected get_namespace(context: Context): LStructuralFeature[\"namespace\"] { return this.get_fromlfeature(context.proxyObject.instanceof, \"namespace\"); }\r\n    protected get_name(context: Context): LStructuralFeature[\"name\"] { return context.data.instanceof ? this.get_fromlfeature(context.proxyObject.instanceof, \"name\") : context.data.name || ''; }\r\n\r\n    protected get_instanceof(context: Context): this[\"instanceof\"] {\r\n        const pointer = context.data.instanceof;\r\n        if (!pointer) return undefined;\r\n        return LPointerTargetable.from(pointer)\r\n    }\r\n    protected set_instanceof(val: Pack1<this[\"instanceof\"]>, context: Context): boolean {\r\n        // const list = val.map((lItem) => { return Pointers.from(lItem) });\r\n        let ptr = Pointers.from(val);\r\n        SetFieldAction.new(context.data, 'instanceof', ptr, \"\", true);\r\n        return true;\r\n    }\r\n\r\n    protected get_isMirage(context: Context): this[\"isMirage\"] { return context.data.isMirage; }\r\n    protected set_isMirage(val: this[\"isMirage\"], context: Context): boolean { SetFieldAction.new(context.data, 'isMirage', val, \"\", false); return true; }\r\n\r\n    typeStr!:string; // derivate attribute, abstract\r\n    typeString!:string; // derivate attribute, abstract\r\n    __info_of__typeStr: Info = {type: ShortAttribETypes.EString, txt: <div>Alias of<i>this.typeString</i></div>}\r\n    __info_of__typeString: Info = {type: ShortAttribETypes.EString, txt: <div>Stringified version of <i>this.type</i></div>}\r\n    protected get_typeString(c: Context): string { return this.get_typeStr(c); }\r\n    // @ts-ignore\r\n    protected get_typeStr(c: Context): string { return LObject.singleton.get_typeStr.call(this, c); }\r\n\r\n    // individual value getters\r\n    // if withMetaInfo, returns a wrapper for the first non-empty value found containing his index and metainfo\r\n    protected get_value<T extends boolean>(context: Context, namedPointers: boolean = false, ecorePointers: boolean = false,\r\n                                           shapeless: boolean = false, keepempties: boolean = true, withmetainfo: T = false as T): T extends true ? ValueDetail : this[\"value\"]{\r\n        return this.get_values(context, true, namedPointers, ecorePointers, shapeless, keepempties, withmetainfo, 1)[0] as any;\r\n    }\r\n    public getValue<T extends boolean>(namedPointers: boolean = false, ecorePointers: boolean = false, shapeless: boolean = false, keepempties: boolean = true,\r\n                                       withmetainfo: T = false as T): T extends true ? ValueDetail : this[\"value\"]{ return this.cannotCall(\"getValue\"); }\r\n    protected get_getValue(context: Context): this[\"getValue\"] {\r\n        return function (namedPointers: boolean = false, ecorePointers: boolean = false, shapeless: boolean = false,\r\n                         keepempties: boolean = true, withmetainfo: boolean = false) {\r\n            return LValue.prototype.get_value(context, namedPointers, ecorePointers, shapeless, keepempties, withmetainfo) as any;\r\n        }\r\n    }\r\n\r\n    // multiple value getters\r\n    protected get_values<T extends boolean>(context: Context, fitSize: boolean = true, namedPointers: boolean = false, ecorePointers: boolean = false,\r\n                                            shapeless: boolean = false, keepempties: boolean = true, withmetainfo?: T, maxlimit?: number,\r\n                                            solveLiterals: \"ordinals\" | \"literal_obj\" | \"literal_str\" | \"original\" = \"literal_obj\")\r\n        : (T extends undefined ? this[\"values\"] : T extends false ? this[\"values\"] : ValueDetail[]) & {type?: string}  {\r\n        const ldata = context.proxyObject;\r\n        const ddata = context.data;\r\n        let typestr: string = this.get_typeString(context);\r\n        let ret: any[];\r\n\r\n        if (ddata.topic) {/*\r\n            let value: any = store.getState()['topics'];\r\n            const path = data.topic.split('.');\r\n            for(const field of path) value = value[field];\r\n            let ret: any = [value];*/\r\n            const topics = store.getState()['topics'];\r\n            const val = U.extractValueFromTopic(topics, ddata.topic);\r\n            ret = Array.isArray(val) ? val : [val];\r\n            //return ret;\r\n        }\r\n        else ret = [...ddata.values];\r\n        (ret as any).type = typestr; // 'topic';\r\n\r\n        let meta: LAttribute | LReference | undefined = shapeless ? undefined : ldata.instanceof;\r\n        let dmeta: undefined | DAttribute | DReference = meta?.__raw;\r\n\r\n        // if (meta && meta.className === DReference.name) ret = LPointerTargetable.fromArr(ret as DObject[]);\r\n\r\n\r\n        if (dmeta?.derived) {\r\n            let td = transientProperties.modelElement[dmeta.id];\r\n            if (!td.derived_read) {\r\n                try {\r\n                    let txt = dmeta.derived_read || '(data, originalValues)=>{return originalValues}';\r\n                    // data.derived examples: '(d, o)=>3', '(ddd, ooo)=>{return 3}',\r\n                    td.derived_read = new Function('data, originalValues', 'return ('+txt+')(data, originalValues)') as Function2;\r\n                }\r\n                catch (error: any) {\r\n                    Log.ee('invalid derived (get) attribute expression: ' + dmeta.name, {error, derivedText:dmeta.derived_read});\r\n                }\r\n                if (td.derived_read) try {\r\n                    ret = td.derived_read(ldata, ret);\r\n                    if (ret === undefined) ret = [];\r\n                    if (!Array.isArray(ret)) ret = [ret];\r\n                }\r\n                catch (error: any) {\r\n                    Log.ee('Error during derived (get) attribute evaluation: ' + dmeta.name, {error, derivedText:dmeta.derived_read});\r\n                }\r\n            }\r\n        }\r\n\r\n\r\n        (ret as GObject).type = typestr;\r\n        if (!Array.isArray(ret)) ret = [];\r\n        if (dmeta && fitSize && ret.length < dmeta.lowerBound && dmeta.lowerBound > 0) {\r\n            let times = dmeta.lowerBound - ret.length;\r\n            while (times-- > 0) ret.push(undefined);\r\n            // ret.length = meta.lowerBound; not really working for expanding, it says \"emptyx10\" or so. doing .map() only iterates \"existing\" elements. behaves like as it's smaller.\r\n        }\r\n        if (maxlimit !== undefined) ret.length = maxlimit;\r\n        else if (dmeta && fitSize && ret.length > dmeta.upperBound && dmeta.upperBound >= 0) ret.length = dmeta.upperBound;\r\n\r\n        // console.log(\"get_values sizefixed\", {fitSize, arguments, upperbound:dmeta?.upperBound, lowerbound: dmeta?.lowerBound, len: ret.length, len0: context.data.values.length});\r\n        let numbermax = 0, numbermin = 0, round = true;\r\n        // ret is always an array of raw values before this point, eventually padded with lowerbound or trimmed at upperbound\r\n\r\n        let index = 0;\r\n        if (withmetainfo) { ret = ret.map(r => {return {value:r, rawValue: r, index: index++, hidden: false} as ValueDetail}); }\r\n        let mapperfunc: (a:any)=>any = undefined as any;\r\n        let numbercasting = (v: any): number => {\r\n            if (typeof v !== \"number\") {\r\n                if (!v) v = 0;\r\n                else if (v === \"true\") v = 1;\r\n                else if (v.constructor?.name=== \"Date\") v = v.getTime();\r\n                else if (typeof v === \"string\") {\r\n                    // console.log(\"number casting:\", v,  U.getFirstNumber(v+'', true), {numbermax, numbermin});\r\n                    v = U.getFirstNumber(v+'', !round);\r\n                } else return NaN;\r\n            }\r\n            v = Math.min(numbermax, Math.max(numbermin, v));\r\n            return round ? Math.round(v) : v;\r\n        };\r\n        switch (typestr) {\r\n            case \"shapeless\":\r\n                let state: DState = store.getState();\r\n                mapperfunc = (val: any) => {\r\n                    if (!val || typeof val !== \"string\") return val;\r\n                    let l: any = LPointerTargetable.fromPointer(val, state);\r\n                    if (!l) return val;\r\n                    if (l.className === DEnumLiteral.cname) { l = (l as DEnumLiteral).literal; } else\r\n                    if (namedPointers) { l = (l.name ? (\"@\" + l.name) : (l as GObject)[\"@\"+l.name]?.__raw?.values?.[0] || (\"#\" + l.className));}\r\n                    else if (ecorePointers){ l = l.ecorePointer(); }\r\n                    return l;\r\n                };\r\n                if (withmetainfo) ret.forEach((struct: ValueDetail) => { struct.value = mapperfunc(struct.value); });\r\n                else ret = ret.map(mapperfunc);\r\n                break;\r\n            default: // it's a reference or enum\r\n                let lenum: LEnumerator = undefined as any;\r\n                let type: LClassifier = (meta as LStructuralFeature)?.type;\r\n                if (type?.className === DEnumerator.cname) {\r\n                    lenum = type as LEnumerator;\r\n                    mapperfunc = (r: any) => {\r\n                        if (solveLiterals === \"original\") return r;\r\n                        numbermin = 0;\r\n                        numbermax = (solveLiterals === \"ordinals\") ? Number.POSITIVE_INFINITY : 0;\r\n                        let lit: LEnumLiteral | undefined\r\n                        if (typeof r === \"string\") lit = Pointers.isPointer(r) ? LPointerTargetable.fromPointer(r) : (lenum as any)[\"@\"+r];\r\n                        else if (typeof r === \"number\") lit = lenum.ordinals[r];\r\n                        switch (solveLiterals) {\r\n                            default:\r\n                            case \"literal_obj\": return lit;\r\n                            // if r was a number and a valid ordinal (found literal through him) return r. if r was a string, don't return r but lenum[\"@\"+r].ordinal\r\n                            case \"ordinals\": return (typeof r === \"number\" ? (lit ? r : undefined) : lit?.ordinal);\r\n                            case \"literal_str\": return (typeof r === \"string\" ? (lit ? r : undefined) : lit?.literal);\r\n                        }\r\n                    }\r\n                } else if (!type.isPrimitive && type?.className === DClass.cname) mapperfunc = (r: any) => r && LPointerTargetable.fromPointer(r);\r\n                else mapperfunc = (r: any) => r;\r\n                if (withmetainfo) ret.forEach((struct: ValueDetail) => { struct.value = mapperfunc(struct.value); });\r\n                else ret = ret.map(mapperfunc);\r\n\r\n                // now ret is pointed DEnumLiteral or DObject or MetaInfoStructure<>\r\n                if (type?.className === DEnumerator.cname) {\r\n                    // replace numeric literals, mapped to literal ordinal. can happen with type switches\r\n                    /*\r\n                    if (solveLiterals) {\r\n                        mapperfunc = (lit: LEnumLiteral|number) => {\r\n                            numbermax = Number.POSITIVE_INFINITY;\r\n                            numbermin = 0;\r\n                            let ordinal = numbercasting(lit);\r\n                            return isNaN(ordinal) ? lit : (meta!.type as LEnumerator).ordinals[ordinal];\r\n                        }\r\n                        if (withmetainfo) ret.forEach((struct: ValueDetail) => { struct.value = mapperfunc(struct.value); });\r\n                        else ret = ret.map(mapperfunc);\r\n                    }*/\r\n                    let filterfunc = (l: LEnumLiteral) => { if (!l) return keepempties; return l.father?.id === (meta as LAttribute).type.id; };\r\n                    if (withmetainfo) for(let struct of ret as ValueDetail[]) { struct.hidden = !filterfunc(struct.value as LEnumLiteral); } // && 'literal target is not of the correct type requested by metamodel'; }\r\n                    else ret = ret.filter(filterfunc);\r\n                    // todo: questo comportamento implica che quando importo un literal come testo da .ecore, devo assegnargli\r\n                    //  il puntatore al suo literal se trovato, altrimenti resta val[i] di tipo string/shapeless\r\n                    if (namedPointers) {\r\n                        mapperfunc = (lit?: LEnumLiteral) => lit?.name;\r\n                        if (withmetainfo) ret.forEach((struct: ValueDetail) => { struct.value = mapperfunc(struct.value); });\r\n                        else ret = ret.map(mapperfunc);\r\n                    }\r\n                    break;\r\n                }\r\n                // is reference with assigned shape (and type) -> filter correct typed targets\r\n                if (meta) {\r\n                    let filterfunc = (l: LObject) => {\r\n                        // hide values with a value that is not a pointer to correct type (but keep empties if requested)\r\n                        //let isExtending = l.instanceof?.isExtending((meta as LReference).type); // damiano: todo test & debug isextending\r\n                        let isExtending = true;\r\n                        return keepempties && !l ? true : isExtending;\r\n                    };\r\n                    if (withmetainfo) for(let struct of ret as ValueDetail[]) { struct.hidden = !filterfunc(struct.value as LObject); } // && \"ref target is not of correct type\"; }\r\n                    else ret = ret.filter(filterfunc);\r\n                }\r\n                // shaped (with m2-reference) but pointing to a shapeless object. can happen\r\n                if (namedPointers) {\r\n                    let mapperfunc = (l:LObject) => l && (l.name ? (\"@\" + l.name) : (l as GObject)[\"@\"+l.name]?.__raw?.values?.[0] || (\"#\" + l.className));\r\n                    if (withmetainfo) ret.forEach((struct: ValueDetail)=>{ struct.value = mapperfunc(struct.value as LObject); });\r\n                    else ret = ret.map(mapperfunc);\r\n                }\r\n                else if (ecorePointers && !(meta as LReference).containment){\r\n                    mapperfunc = (lval: LObject) => lval && lval.ecorePointer();\r\n                    if (withmetainfo) ret.forEach((struct: ValueDetail)=>{ struct.value = mapperfunc(struct.value as LObject); });\r\n                    else ret = ret.map(mapperfunc);\r\n                    // throw new Error(\"values as EcorePointers: todo. for containment do nothing, just nest the obj. for non-containment put the ecore reference string in array vals\")\r\n                }\r\n                break;\r\n            case ShortAttribETypes.EByte:\r\n                numbermin = -128;\r\n                numbermax = 127;\r\n                break;\r\n            case ShortAttribETypes.EShort:\r\n                numbermin = -32768;\r\n                numbermax = 32767;\r\n                break;\r\n            case ShortAttribETypes.EInt:\r\n                numbermin = -2147483648;\r\n                numbermax = 2147483647;\r\n                break\r\n            case ShortAttribETypes.ELong:\r\n                numbermin = -9223372036854775808;\r\n                numbermax = 9223372036854775807;\r\n                break;\r\n            case ShortAttribETypes.EFloat:\r\n            case ShortAttribETypes.EDouble:\r\n                numbermin = Number.NEGATIVE_INFINITY;\r\n                numbermax = Number.POSITIVE_INFINITY;\r\n                round = false;\r\n                break;\r\n            case ShortAttribETypes.EString:\r\n            case ShortAttribETypes.EDate:\r\n                mapperfunc = v => v ? v + '' : ''\r\n                if (withmetainfo) ret.forEach((struct: ValueDetail)=>{ struct.value = mapperfunc(struct.value); });\r\n                else ret = ret.map(mapperfunc);\r\n                break;\r\n            case ShortAttribETypes.EChar:\r\n                mapperfunc = v => v ? (v + '')[0] : 'A';\r\n                if (withmetainfo) ret.forEach((struct: ValueDetail)=>{ struct.value = mapperfunc(struct.value); });\r\n                else ret = ret.map(mapperfunc);\r\n                break;\r\n            case ShortAttribETypes.EBoolean:\r\n                mapperfunc = v => typeof v === \"boolean\" ? v : U.fromBoolString(v+'', v?.length>0, false);\r\n                if (withmetainfo) ret.forEach((struct: ValueDetail)=>{ struct.value = mapperfunc(struct.value); });\r\n                else ret = ret.map(mapperfunc);\r\n                break;\r\n            case ShortAttribETypes.EVoid:\r\n                if (withmetainfo) ret.forEach((struct: ValueDetail)=>struct.hidden = true);\r\n                else ret = [];\r\n                break;\r\n        }\r\n        // some kind of numeric type\r\n        if (numbermax !== 0) {\r\n            if (withmetainfo) ret.forEach((struct: ValueDetail)=>{ struct.value = numbercasting(struct.value); });\r\n            else ret = ret.map(numbercasting);\r\n        }\r\n        return ret as any;\r\n    }\r\n\r\n    public getValues<T extends boolean>(fitSize: boolean = true, namedPointers: boolean = false, ecorePointers: boolean = false, shapeless: boolean = false,\r\n                                        keepempties: boolean = true, withmetainfo?: T, maxlimit?: number)\r\n        : (T extends undefined ? this[\"values\"] : T extends false ? this[\"values\"] : ValueDetail[]) & {type?: string} {\r\n        return this.cannotCall(\"getValues\"); }\r\n    protected get_getValues(context: Context): this[\"getValues\"] {\r\n        return function (fitSize: boolean = true, namedPointers: boolean = true, ecorePointers: boolean = false,\r\n                         shapeless: boolean = false, keepempties: boolean = false, withmetainfo: any = false, limit?: number) {\r\n            return LValue.prototype.get_values(context, fitSize, namedPointers, ecorePointers, shapeless, keepempties, withmetainfo, limit) as any;\r\n        }\r\n    }\r\n    // stringified value getters\r\n    public valuesString(keepemptyquotes?: boolean): string { return this.cannotCall(\"valuestring\"); }\r\n    public valuestring(keepemptyquotes?: boolean): string { return this.cannotCall(\"valuestring\"); }\r\n    private get_valuestring(context: Context): this[\"valuestring\"] { return (keepemptyquotes?: boolean) => this.valuestring_impl(context, keepemptyquotes); }\r\n    private get_valuesString(context: Context): this[\"valuestring\"] { return (keepemptyquotes?: boolean) => this.valuestring_impl(context, keepemptyquotes); }\r\n    private valuestring_impl(context: Context, keepemptyquotes?: boolean): string {\r\n        let val = this.get_values(context, true, true, false, false, true);\r\n        // console.log(\"valuestring_impl\", {val});\r\n        let ret: any;\r\n        switch (val.length) {\r\n            case 0: ret = ''; break;\r\n            case 1: ret = val[0]; break;\r\n            default:\r\n                let havestrings: boolean = val.type === ShortAttribETypes.EString;\r\n                let havechars: boolean = val.type === ShortAttribETypes.EChar;\r\n                let havepointers: boolean = false;\r\n                let haveLelements: boolean = false;\r\n                for (let vall of [val[0]]) {\r\n                    if ((vall as any)?.__isProxy) haveLelements = true;\r\n                    /*else if (typeof vall === \"string\") { havestrings = true; havepointers = havepointers || vall.includes(\"Pointer\"); }}\r\n                     */\r\n                }\r\n                /*if (havepointers) {\r\n                    val = LPointerTargetable.wrapAll(val);\r\n                    haveLelements = true;\r\n                }*//*\r\n                if (haveLelements) {\r\n                    val = val.map( l => l && (l.name ? (\"@\" + l.name) : (\"#\" + l.className)));\r\n                }*/\r\n                if (havestrings || havechars) {\r\n                    let valstr = JSON.stringify(val);\r\n                    if (!keepemptyquotes) valstr = U.replaceAll(valstr, \"\\\"\\\"\", \"\");\r\n                    ret = valstr.substring(1, valstr.length-1);\r\n                    break;\r\n                }\r\n                else ret = val.join(', ');\r\n        }\r\n        return (ret === undefined || ret === null ? '' : ret) + '';\r\n    }\r\n\r\n    public setValueAtPosition(index: number, val: this[\"values\"][0], info?: Partial<SetValueAtPositionInfoType>): {success: boolean, reason?: string} {\r\n        return this.cannotCall(\"setValueAtPosition\"); }\r\n\r\n    // only use through setValueAtPosition\r\n    protected _clearValueAtPosition(context: Context, index: number, info0?: Partial<SetValueAtPositionInfoType>, skipSettingUndefined: boolean = false) {\r\n        // if (!outactions) outactions = {clear:[], set:[]};\r\n        let info = (info0 || {}) as unknown as SetValueAtPositionInfoType;\r\n        let oldVal = context.data.values[index];\r\n        let oldTarget: LObject | undefined = typeof oldVal === \"string\" ? LObject.fromPointer(oldVal) : undefined;\r\n        /////////////////////// if oldTarget is LObject, update his pointedBy\r\n        // if (oldTarget) SetFieldAction.new(oldTarget, \"pointedBy\" '-=\", ... no need? reducer should do this)\r\n\r\n        /////////////////////// if ref is containment assign oldTarget father to DModel\r\n\r\n        if (info.isContainment === undefined) {\r\n            if (info.instanceof === undefined) info.instanceof = context.proxyObject.instanceof;\r\n            if (info.instanceof){\r\n                if (info.instanceof.className === DReference.cname) { info.isContainment = (info.instanceof as LReference).containment; }\r\n                else info.isContainment = false;\r\n            }\r\n            else { info.isContainment = true; }\r\n        }\r\n        if (info.isContainment && oldTarget?.className === \"DObject\") {\r\n            SetFieldAction.new(oldVal as Pointer<DObject>, \"father\", context.proxyObject.model.id, undefined, true);\r\n        }\r\n        if (!skipSettingUndefined) SetFieldAction.new(context.data, 'values.' + index as any, undefined, '', info.isPtr);\r\n    }\r\n    protected get_setValueAtPosition(c: Context): ((index: number, val: this[\"values\"][0], info?: Partial<SetValueAtPositionInfoType>, outactions?:outactions) => {success: boolean, reason?: string}) {\r\n        return (index: number, val: this[\"values\"][0] | any, info0?: Partial<SetValueAtPositionInfoType>, outactions?: outactions): { success: boolean, reason?: string } => {\r\n            if (!outactions) outactions = {clear:[], set:[], immediatefire: true}\r\n            let isPtr: boolean = undefined as any;\r\n            let lval: LObject | LEnumLiteral = undefined as any;\r\n            if (val === null) val = undefined;\r\n            let oldval = c.data.values[index];\r\n            if (oldval === val) return { success: false, reason: \"identical assignment\" };\r\n            let tmpval_id = Pointers.from(val) ;\r\n            if (oldval === tmpval_id) return { success: false, reason: \"identical object assignment\" };\r\n            let state = store.getState();\r\n            if (tmpval_id && (val as any)?.className) {\r\n                lval = LPointerTargetable.wrap<DObject>(val, state) as LObject | LEnumLiteral;\r\n                isPtr = !!(lval || Pointers.isPointer(oldval));//LPointerTargetable.wrap(oldval, state));\r\n                val = tmpval_id;\r\n            }\r\n            let info = (info0 || {}) as unknown as SetValueAtPositionInfoType;\r\n            if (isPtr === undefined) isPtr = (info.isPtr === undefined ? Pointers.isPointer(val) || Pointers.isPointer(oldval) : info.isPtr);\r\n\r\n\r\n            // set sideeffect part\r\n            if (val !== undefined) {\r\n                if (isPtr) {\r\n                    if (info.type === undefined) info.type = c.proxyObject.type;\r\n                    if (info.instanceof === undefined) info.instanceof = c.proxyObject.instanceof;\r\n                    if (info.isContainment === undefined) {\r\n                        info.isContainment = !info.instanceof || (info.instanceof.className === DReference.cname && (info.instanceof as LReference).containment);\r\n                    }\r\n                    lval = LPointerTargetable.fromPointer(val);\r\n                    if (!lval) return {success: false, reason: \"invalid pointer: \" + lval};\r\n                    // is enum\r\n                    if (lval.className === DEnumLiteral.cname) {\r\n                        let lvale: LEnumLiteral = lval as LEnumLiteral;\r\n                        if (info.instanceof && info.type && (lvale.father.id !== info.type.id)) return {success: false, reason: \"target is not of correct literal type\"};\r\n                        // no need to do checks / other sideeffects other than pointedBy i think.\r\n                    }\r\n                    // is ref\r\n                    if (lval.className === DObject.cname){\r\n\r\n                        let lvalo = lval as LObject;\r\n                        //let lvalmeta: LClassifier | undefined = lvalo.instanceof;\r\n                        // if (info.instanceof && info.type && (!(lvalmeta as LClass)?.isExtending(info.type))) return {success: false, reason: \"target is not of correct type\"}; damiano todo: enable and implement isExtending\r\n                        if (info.fatherList === undefined) info.fatherList = c.proxyObject.fatherList;\r\n                        if (info.isContainment) {\r\n                            if ((info.fatherList as LPointerTargetable[]).map(father => father.id).includes(val))\r\n                                return {success: false, reason: \"cannot create a containment loop\"}; // todo: in LReference.set_containment need to forbid setting to true if there is a loop\r\n                            let oldContainer: LValue | LModel = lvalo.father;\r\n                            let oldContainerValue: LValue = (oldContainer.className === DModel.cname) ? undefined as any : (oldContainer as LValue);\r\n                            // detach contaied object from old parent\r\n                            if (oldContainerValue && oldContainerValue.id !== c.data.id) outactions.clear.push(()=>{\r\n                                let valarr: any[] = oldContainerValue.__raw.values;\r\n\r\n                                for (let i = 0; i < valarr.length; i++) {\r\n                                    let v = valarr[i];\r\n                                    if (v === val) oldContainerValue.setValueAtPosition(i, undefined as any, undefined);\r\n                                }\r\n\r\n                            });\r\n                            outactions.set.push(()=> {\r\n                                SetFieldAction.new(val as Pointer<DObject>, \"father\", c.data.id, undefined, true)\r\n                            });\r\n                        }\r\n                    }\r\n                    // automatic? SetFieldAction.new(val as Pointer<DObject>, \"pointedBy\", PointedBy.fromID(c.data.id, \"values.\" + index as any), \"+=\");\r\n                } else {\r\n                    // loose checks, i can assign any primitive to any primitive (will cast on get)\r\n                    if (info.instanceof === undefined) info.instanceof = c.proxyObject.instanceof;\r\n                    let metatype: string = (info.instanceof as LAttribute)?.typeToShortString() || \"shapeless\";\r\n                    if (typeof val === \"object\") {\r\n                        if (val.constructor === Date && (metatype !== \"EString\" && metatype !== \"EDate\" && metatype !== \"shapeless\"))\r\n                            return {\r\n                                success: false,\r\n                                reason: \"dates can only be assigned to values of type string or Date\"\r\n                            };\r\n                        // return {success: false, reason: \"objects are not assignable except for dates\"}; maybe i allow this instead\r\n                    }\r\n                }\r\n            }\r\n\r\n            // clear sideeffect part\r\n            outactions.clear.push(()=>this._clearValueAtPosition(c, index, info, true));\r\n            // console.log('set value index', {index, val, isPtr});\r\n            // actual set\r\n            outactions.set.push(()=>SetFieldAction.new(c.data, 'values.' + index as any, val, '', isPtr));\r\n            if (info.setMirage !== false) SetFieldAction.new(c.data, 'isMirage', false, '', false);\r\n\r\n            if (outactions.immediatefire) {\r\n                for (let a of outactions.clear) a();\r\n                for (let a of outactions.set) a();\r\n            }\r\n            // todo: wrap this func and set toaster with failure message if it fails or better launch Log.w and bind toasts of different colors to Log funcs\r\n            return {success: true};\r\n        }\r\n    }\r\n    protected set_values(val0: orArr<D[\"values\"]>, c: Context): boolean {\r\n        let val: any = val0 as any;\r\n        let modified = false;\r\n        let meta = this.get_instanceof(c);\r\n        let dmeta: DReference | DAttribute | undefined = meta?.__raw;\r\n        if (dmeta?.derived) {\r\n            let td = transientProperties.modelElement[dmeta.id];\r\n            if (!td.derived_write) {\r\n                try {\r\n                    let txt = dmeta.derived_write || '(values, data, oldValues)=>{ data.values = values; }';\r\n                    td.derived_write = new Function('values, data, oldValues', 'return ('+txt+')(data, originalValues)') as Function2;\r\n                }\r\n                catch (error: any) {\r\n                    Log.ee('invalid derived (set) attribute expression: ' + dmeta.name, {error, derivedText:dmeta.derived_write});\r\n                }\r\n                if(td.derived_write) try {\r\n                    TRANSACTION(()=>{\r\n                        let ret = td?.derived_write?.(val, c.proxyObject, c.data.values);\r\n                        if (ret !== undefined) {\r\n                            val = ret;\r\n                            modified = true;\r\n                        }\r\n                    })\r\n                }\r\n                catch (error: any) {\r\n                    Log.ee('Error during derived (set) attribute evaluation: ' + dmeta.name, {error, derivedText:dmeta.derived_write});\r\n                }\r\n            }\r\n        }\r\n\r\n        val = (Array.isArray(val0) ? val0 : [val0]) as D[\"values\"];\r\n        // val.length = Math.max(val.length, c.data.values.length);\r\n        let isContainment = this.get_isContainment(c);\r\n        if (isContainment) { // remove duplicates in containment\r\n            val = val.map((v: any) => v?.id || v);\r\n            let idmap: Dictionary<string, true> = {}\r\n            val = val.filter((e: any)=> { if (typeof e !== 'string' || !idmap[e]) return true; idmap[e] = true; return true;} )\r\n        }\r\n        TRANSACTION(()=>{\r\n            let outactions: outactions = {clear:[], set:[], immediatefire: false};\r\n            for (let i = 0; i < val.length; i++) {\r\n                let out = this.get_setValueAtPosition(c)(i, val[i], {setMirage: false} as any, outactions);\r\n                modified = out.success || modified;\r\n                // console.log('set_values', {val, i, modifiedreason:out});\r\n            }\r\n            let excess = c.data.values.length - val.length;\r\n            while (excess-- > 0) {\r\n                SetFieldAction.new(c.data.id, 'values', undefined as any, '-=', true);\r\n            }\r\n            for (let a of outactions.clear) a();\r\n            for (let a of outactions.set) a();\r\n            if (modified) c.data.isMirage && SetFieldAction.new(c.data, 'isMirage', false, '', false);\r\n        });\r\n        return true;\r\n\r\n        // old implementation\r\n        let list: any = val;\r\n        let context = c;\r\n        let l = context.proxyObject;\r\n        let instanceoff: LReference | LAttribute | undefined = l.instanceof;\r\n        let isRef: boolean | undefined = (!instanceoff ? undefined : instanceoff?.className === DReference.cname);\r\n        SetFieldAction.new(context.data, 'values', list as any, '', false);\r\n        // console.log(\"pre set_values actions\", l, list, val, context);\r\n\r\n        if (!l.instanceof || isRef && (instanceoff as LReference).containment) {\r\n            let i = 0;\r\n\r\n            for (let v0 of list) {\r\n                // console.log(\"loop set_value actions\", v, context.data, isRef, instanceoff, Pointers.isPointer(v));\r\n                i++;\r\n                if ((isRef || instanceoff === undefined) && Pointers.isPointer(v0)) { // if shapeless obj need to check val by val\r\n                    let v = v0 as Pointer<DModelElement> //Pointer<DObject> | Pointer<DEnumLiteral>;\r\n                    // console.log(\"loop set_value actions SET\", {v, data:context.data, isRef, instanceoff, isPtr:Pointers.isPointer(v)});\r\n                    let lval: LObject = LPointerTargetable.fromPointer(v);\r\n                    let oldContainer: LValue | LModel = lval.father;\r\n                    SetFieldAction.new(v, \"pointedBy\", PointedBy.fromID(context.data.id, \"values.\" + i as any), \"+=\");\r\n                    SetFieldAction.new(v, \"father\", context.data.id, undefined, true);\r\n                    if (oldContainer.className === DModel.cname) continue;\r\n                    let containerValue = (oldContainer as LValue);\r\n                    // let oldContainerValues = [...containerValue.__raw.value]; U.arrayRemoveAll(oldContainerValues, v);\r\n                    let oldContainerValues: Pointer[] = containerValue.__raw.values.map( va => va===v ? undefined as any : va);\r\n                    SetFieldAction.new(containerValue.id, \"values\", oldContainerValues, \"\", true);\r\n\r\n                    // todo: verify if works: remove val from old container\r\n                    let oldv = context.data.values[i];\r\n                    // if (Pointers.isPointer(oldv)) SetFieldAction.new(context.data.id, \"contains\", U.arrayRemoveAll([...context.data.contains], oldv), '', true);\r\n                    // SetFieldAction.new(context.data.id, \"contains\", oldv as DObject[\"id\"], undefined, true);\r\n\r\n                }\r\n            }\r\n        }\r\n        context.data.isMirage && SetFieldAction.new(context.data, 'isMirage', false, '', false);\r\n        return true;\r\n    }\r\n\r\n    protected set_value(val: D[\"values\"][0], c: Context): boolean {\r\n        let v: ValueDetail = this.get_value(c, false, false, false, true, true);\r\n        let val_id = (val as any)?.id || val;\r\n        if (Pointers.isPointer(val_id) && c.data.values.includes(val_id as any) && this.get_isContainment(c)) { return true; }\r\n        let r = this.get_setValueAtPosition(c)(v?.index || 0, val_id || val);\r\n        Log.e(!r.success,  r.reason);\r\n        return r.success;\r\n    }\r\n\r\n    get_crossReference(c: Context): this['allowCrossReference'] { return this.get_allowCrossReference(c); }\r\n    get_isCrossReference(c: Context): this['allowCrossReference'] { return this.get_allowCrossReference(c); }\r\n    set_crossReference(v: this['allowCrossReference'], c: Context): boolean { return this.set_allowCrossReference(v, c); }\r\n    set_isCrossReference(v: this['allowCrossReference'], c: Context): boolean { return this.set_allowCrossReference(v, c); }\r\n    get_allowCrossReference(c: Context): boolean { return c.data.instanceof ? !!c.proxyObject.instanceof?.allowCrossReference : true; }\r\n    set_allowCrossReference(v: this['allowCrossReference'], c: Context): boolean { return this.cannotSet('LValue.allowCrossReference'); }\r\n\r\n\r\n    validTargetOptions!: MultiSelectOptGroup[];\r\n    get_validTargetOptions(c: Context): this['validTargetOptions'] {\r\n        let opts: MultiSelectOptGroup[] = [];\r\n        this.get_validTargets(c, opts);\r\n        return opts;\r\n    }\r\n    validTargetsJSX!: JSX.Element[];\r\n    get_validTargetsJSX(c: Context): this['validTargetsJSX'] {\r\n        let opts: MultiSelectOptGroup[] = [];\r\n        this.get_validTargets(c, opts);\r\n        return UX.options(opts);\r\n    }\r\n    validTargets!: (LObject | LEnumLiteral)[];\r\n    get_validTargets(c: Context, out?: MultiSelectOptGroup[]): this['validTargets'] {\r\n        let meta: LReference | LAttribute = this.get_instanceof(c) as LReference | LAttribute;\r\n        let isShapeless = !meta;\r\n        let isReference = isShapeless || meta.className === 'DReference';\r\n        let isAttribute = isShapeless || meta.className === 'DAttribute';\r\n        let isCrossRef = this.get_isCrossReference(c);\r\n        let freeObjects: LObject[] = [];\r\n        let boundObjects: LObject[] = [];\r\n        let literals: LEnumLiteral[] = [];\r\n        let isContainment = isShapeless || isReference && (meta as LReference).containment;\r\n        let m1: LModel = this.get_model(c);\r\n        let m2 = m1.instanceof;\r\n        // let map = (object: LNamedElement) => ({value:object.id, label: object.name});\r\n        let map = (object: LNamedElement): MultiSelectOption => {\r\n            let fname = object.fullname;\r\n            return {value:object.id, label: isCrossRef ? fname : object.name, title: object.fullname}\r\n        };\r\n        if (isReference) {\r\n            let isContainment: boolean = this.get_containment(c);\r\n            let containerObjectsID: Pointer[] = this.get_fatherList(c).map(lm => lm.id);\r\n            let validObjects = (isCrossRef ? m1.allCrossSubObjects : m1.allSubObjects)\r\n            if (isContainment) validObjects = validObjects.filter(obj => !containerObjectsID.includes(obj.id));\r\n            let type = meta.type;\r\n            if (!isShapeless) validObjects = validObjects.filter((obj) => (type as LClass).isSuperClassOf(obj.instanceof, true))\r\n            // avoiding containment loops damiano todo: put this filter in set_value too\r\n            for (let o of validObjects) {\r\n                //  continue; // no self contain\r\n                if (o.isRoot) freeObjects.push(o);\r\n                else boundObjects.push(o);\r\n            }\r\n            if (out) out.push({label: 'Free     Objects', options: freeObjects.map(map)});\r\n            if (out) out.push({label: 'Bound Objects', options: boundObjects.map(map)});\r\n        }\r\n        if (isAttribute) {\r\n            let enumm: LEnumerator[];\r\n            if (isShapeless){\r\n                if (!m2) enumm = LPointerTargetable.from(Selectors.getAllEnumerators());\r\n                else enumm = (isCrossRef && m2) ? m2.crossEnumerators : m2.enumerators;\r\n            }\r\n            else {\r\n                let type = meta.type;\r\n                enumm = (type.className === 'DEnumerator') ? [type as LEnumerator] : [];\r\n            }\r\n            for (let e of enumm) {\r\n                let currLiterals = e.literals;\r\n                literals.push(...currLiterals);\r\n                if (out) out.push({label: 'Literals of ' + e.name, options: currLiterals.map(map)});\r\n            }}\r\n        return U.arrayMergeInPlace(freeObjects, boundObjects, literals as any);\r\n    }\r\n\r\n    protected generateEcoreJson_impl(c: Context, loopDetectionObj: Dictionary<Pointer, DModelElement> = {}): Json {\r\n        loopDetectionObj[c.data.id] = c.data;\r\n        let values = this.get_values(c, true, false, true, false, false);//, false, undefined, \"literal_str\");\r\n        delete values[\"type\"];\r\n        let ret: any = [];\r\n        the_loop: for (let v of values){\r\n            let l: LObject | LEnumLiteral = v as any;\r\n            if (!l?.__isProxy) { ret.push(l); continue; }\r\n            switch (l.className){\r\n                case \"DOperation\": continue the_loop;\r\n                case \"DEnumLiteral\": ret.push((l as LEnumLiteral).generateEcoreJsonM1()); break;\r\n                default: ret.push(l.generateEcoreJson(loopDetectionObj)); break;\r\n            }\r\n        }\r\n        // ret = ret.filter((j: any) => (j !== undefined || j !== ''));\r\n        return (ret.length <= 1) ? ret[0] : ret; }\r\n\r\n    protected get_toString(context: Context): () => string { return () => this._toString(context); }\r\n    protected _toString(context: Context): string {\r\n        let val: any = this.get_values(context, true, true, false, false, true);\r\n        if (!val) return val + '';\r\n        if (!Array.isArray(val)) val = [val];\r\n        // if (!context.proxyObject.instanceof) val = val.map( (e: GObject) => { return  e.name ? \"@\" + e.name : e; });\r\n        // else if (context.proxyObject.instanceof?.className === DReference.name) val = val.map( (e: GObject) => { return e.name ? \"@\" + e.name : e; });\r\n        switch(val.length) {\r\n            case 0: return '';\r\n            case 1: return val[0] + '';\r\n            default: return val + '';\r\n        }\r\n    }\r\n\r\n    public rawValues(): void { super.cannotCall('rawValues'); }\r\n    public get_rawValues(context: Context): this[\"values\"]{\r\n        return (this.get_getValues(context))(false, false, false, true, true, false, undefined);\r\n    }\r\n\r\n    protected get_topic(context: Context): this[\"topic\"] {\r\n        return context.data.topic;\r\n    }\r\n    protected set_topic(val: string, context: Context): boolean {\r\n        SetFieldAction.new(context.data, 'topic', val, '', false);\r\n        return true;\r\n    }\r\n}\r\nRuntimeAccessibleClass.set_extend(DNamedElement, DValue);\r\nRuntimeAccessibleClass.set_extend(LNamedElement, LValue);\r\n\r\nexport type ValueDetail = {\r\n    value: LValue['value'];\r\n    rawValue: DValue['values'][0]; // PrimitiveType | Pointer<DObject> | Pointer<DEnumLiteral>\r\n    index: number;\r\n    hidden: boolean;\r\n};\r\nexport type SetValueAtPositionInfoType = {setMirage: boolean, isPtr: boolean, type: LValue['type'], instanceof: LValue['instanceof'], isContainment: boolean, fatherList: LValue['fatherList']};\r\n\r\nexport type WModelElement = getWParams<LModelElement, DModelElement>;\r\nexport type WModel = getWParams<LModel, DModel>;\r\nexport type WValue = getWParams<LValue, DValue>;\r\nexport type WNamedElement = getWParams<LNamedElement, DNamedElement>;\r\nexport type WObject = getWParams<LObject, DObject>;\r\nexport type WEnumerator = getWParams<LEnumerator, DEnumerator>;\r\nexport type WEnumLiteral = getWParams<LEnumLiteral, DEnumLiteral>;\r\nexport type WAttribute = getWParams<LAttribute, DAttribute>;\r\nexport type WReference = getWParams<LReference, DReference>;\r\nexport type WStructuralFeature = getWParams<LStructuralFeature, DStructuralFeature>;\r\nexport type WClassifier = getWParams<LClassifier, DClassifier>;\r\nexport type WDataType = getWParams<LDataType, DDataType>;\r\nexport type WClass = getWParams<LClass, DClass>;\r\nexport type WParameter = getWParams<LParameter, DParameter>;\r\nexport type WOperation = getWParams<LOperation, DOperation>;\r\nexport type WPackage = getWParams<LPackage, DPackage>;\r\nexport type WTypedElement = getWParams<LTypedElement, DTypedElement>;\r\nexport type WAnnotation = getWParams<LAnnotation, DAnnotation>;\r\n// export type WJavaObject = getWParams<LJavaObject, DJavaObject>;\r\nexport type WMap = getWParams<LMap, DMap>;\r\nexport type WFactory_useless_ = getWParams<LFactory_useless_, DFactory_useless_>;\r\n\r\nDModelElement.cname = 'DModelElement';\r\nLModelElement.cname = 'LModelElement';\r\nDAnnotationDetail.cname = 'DAnnotationDetail';\r\nLAnnotationDetail.cname = 'LAnnotationDetail';\r\nDAnnotation.cname = 'DAnnotation';\r\nLAnnotation.cname = 'LAnnotation';\r\nDNamedElement.cname = 'DNamedElement';\r\nLNamedElement.cname = 'LNamedElement';\r\nDTypedElement.cname = 'DTypedElement';\r\nLTypedElement.cname = 'LTypedElement';\r\nDClassifier.cname = 'DTypedElement';\r\nLClassifier.cname = 'LTypedElement';\r\nDPackage.cname = 'DPackage';\r\nLPackage.cname = 'LPackage';\r\nDOperation.cname = 'DOperation';\r\nLOperation.cname = 'LOperation';\r\nDParameter.cname = 'DParameter';\r\nLParameter.cname = 'LParameter';\r\nDClass.cname = 'DClass';\r\nLClass.cname = 'LClass';\r\n// ClassReferences.cname = 'ClassReferences';\r\nDDataType.cname = 'DDataType';\r\nLDataType.cname = 'LDataType';\r\nDStructuralFeature.cname = 'DStructuralFeature';\r\nLStructuralFeature.cname = 'LStructuralFeature';\r\nDReference.cname = 'DReference';\r\nLReference.cname = 'LReference';\r\nDAttribute.cname = 'DAttribute';\r\nLAttribute.cname = 'LAttribute';\r\nDEnumLiteral.cname = 'DEnumLiteral';\r\nLEnumLiteral.cname = 'LEnumLiteral';\r\nDModelM1.cname = 'DModelM1';\r\nLModelM1.cname = 'LModelM1';\r\nDEnumerator.cname = 'DEnumerator';\r\nLEnumerator.cname = 'LEnumerator';\r\nDModel.cname = 'DModel';\r\nLModel.cname = 'LModel';\r\nDMap.cname = 'DMap';\r\nLMap.cname = 'LMap';\r\nDObject.cname = 'DObject';\r\nLObject.cname = 'LObject';\r\nDValue.cname = 'DValue';\r\nLValue.cname = 'LValue';\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}