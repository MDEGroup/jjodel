{"ast":null,"code":"var _dec, _class;\nimport { LUser, DUser, Defaults } from \"../../joiner\";\nimport { DViewElement, DPointerTargetable, DModel, DModelElement, OCL, Log, LPointerTargetable, RuntimeAccessible, RuntimeAccessibleClass, store, U, toShortEType } from \"../../joiner\";\nimport { ShortDefaultEClasses, toShortEClass } from \"../../common/U\";\nvar ViewEClassMatch;\n(function (ViewEClassMatch) {\n  ViewEClassMatch[ViewEClassMatch[\"MISMATCH\"] = 0] = \"MISMATCH\";\n  ViewEClassMatch[ViewEClassMatch[\"IMPLICIT_MATCH\"] = 1] = \"IMPLICIT_MATCH\";\n  ViewEClassMatch[ViewEClassMatch[\"INHERITANCE_MATCH\"] = 2] = \"INHERITANCE_MATCH\";\n  ViewEClassMatch[ViewEClassMatch[\"EXACT_MATCH\"] = 3] = \"EXACT_MATCH\";\n})(ViewEClassMatch || (ViewEClassMatch = {}));\nexport let Selectors = (_dec = RuntimeAccessible('Selectors'), _dec(_class = class Selectors {\n  static getActiveModel() {\n    var _state$_lastSelected;\n    let metamodel;\n    let state = store.getState();\n    const selected = (_state$_lastSelected = state._lastSelected) === null || _state$_lastSelected === void 0 ? void 0 : _state$_lastSelected.modelElement;\n    if (selected) {\n      const me = LPointerTargetable.fromPointer(selected);\n      metamodel = me ? me.model : null;\n    } else metamodel = null;\n    return metamodel;\n  }\n  static getLastSelectedModel(state) {\n    var _state$_lastSelected2;\n    state = state || store.getState();\n    let me = (_state$_lastSelected2 = state._lastSelected) === null || _state$_lastSelected2 === void 0 ? void 0 : _state$_lastSelected2.modelElement;\n    if (!me) return {};\n    let ret = {\n      element: LPointerTargetable.fromPointer(me, state)\n    };\n    ret.model = ret.element.model;\n    if (ret.model.isMetamodel) ret.m2 = ret.model;else {\n      ret.m1 = ret.model;\n      ret.m2 = ret.m1.instanceof;\n    }\n    return ret;\n  }\n  static getAllViewElements() {\n    // return Object.values(store.getState().idlookup).filter(v => v.className === DViewElement.name) as DViewElement[];\n    let state = store.getState();\n    const ptrs = Object.values(state.viewelements);\n    let views = ptrs.map(ptr => state.idlookup[ptr]);\n    return views;\n  }\n  //Giordano: start\n\n  static getViewpoints() {\n    const state = store.getState();\n    return LPointerTargetable.fromPointer(state.viewpoints);\n  }\n  static getViewpoint() {\n    const state = store.getState();\n    return LPointerTargetable.fromPointer(state.viewpoint);\n  }\n  static getObjects() {\n    let state = store.getState();\n    const ptrs = Object.values(state.objects);\n    const dObjects = ptrs.map(ptr => state.idlookup[ptr]);\n    const lObjects = [];\n    for (let dObject of dObjects) {\n      lObjects.push(LPointerTargetable.fromPointer(dObject.id));\n    }\n    return lObjects;\n  }\n  static getValues() {\n    let state = store.getState();\n    const ptrs = Object.values(state.values);\n    const dValues = ptrs.map(ptr => state.idlookup[ptr]);\n    const lValues = [];\n    for (let dValue of dValues) {\n      if (dValue === null || dValue === void 0 ? void 0 : dValue.id) {\n        lValues.push(LPointerTargetable.fromPointer(dValue.id));\n      }\n    }\n    return lValues;\n  }\n  static getDeleted() {\n    const state = store.getState();\n    return state.deleted;\n  }\n  static getState() {\n    const state = store.getState();\n    return state;\n  }\n  static getDefaultEcoreClass(type, state) {\n    let shorttype = (toShortEClass(type) || type).toUpperCase();\n    if (!state) state = store.getState();\n    // todo: make other m3 classes and make this generic like getPrimitiveType\n    return state.idlookup[\"Pointer_\" + ShortDefaultEClasses.EObject.toUpperCase()];\n  }\n  static getPrimitiveType(type, state) {\n    let shorttype = (toShortEType(type) || type).toUpperCase();\n    if (!state) state = store.getState();\n    return state.idlookup[\"Pointer_\" + shorttype];\n  }\n  static getAllPrimitiveTypes() {\n    let state = store.getState();\n    const ptrs = Object.values(state.primitiveTypes);\n    const classifiers = ptrs.map(ptr => state.idlookup[ptr]);\n    return classifiers;\n  }\n  static getFirstPrimitiveTypes() {\n    return Selectors.getAllPrimitiveTypes()[0];\n  }\n  static getRefEdges() {\n    const state = store.getState();\n    const pointers = Object.values(state.refEdges);\n    const dRefEdges = pointers.map(ptr => state.idlookup[ptr]);\n    return dRefEdges;\n  }\n  static getField(field) {\n    let state = store.getState();\n    const pointers = Object.values(state[field]);\n    return pointers;\n  }\n  static getAllAttributes() {\n    const state = store.getState();\n    return Object.values(state.attributes);\n  }\n  static getAllEnumLiterals() {\n    const state = store.getState();\n    return Object.values(state.enumliterals);\n  }\n  static getAllReferences() {\n    const state = store.getState();\n    return Object.values(state.references);\n  }\n  static getAllReferenceEdges() {\n    const state = store.getState();\n    return Object.values(state.refEdges);\n  }\n  static getAllClasses() {\n    const state = store.getState();\n    return Object.values(state.classs);\n  }\n  static getReturnTypes() {\n    const state = store.getState();\n    return LPointerTargetable.from(Object.values(state.returnTypes));\n  }\n  static getAllClassesWithoutPrimitive() {\n    // this solution does not look good. what if a primitive type is inserted at runtime in between?\n    // coould reach the same goal by taking all Classes of a model (m2), excluding classes from other models (types are classes from m3 model)\n    const state = store.getState();\n    const classList = Object.values(state.classs);\n    classList.splice(0, Selectors.getAllPrimitiveTypes().length);\n    /* todo: need to change it in something like this once cross-references between models and instances are implemented\r\n    const m2: LModel;\r\n    m2.isInstanceOf = m3 as LModel;\r\n    m2.isInstanceOf.classes;*/\n\n    return classList;\n  }\n  static getAllEnumerators() {\n    let flag = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    const state = store.getState();\n    return Object.values(state.enumerators);\n  }\n  static getAllPackages() {\n    const state = store.getState();\n    return Object.values(state.packages);\n  }\n  static getAllParameters() {\n    const state = store.getState();\n    return Object.values(state.parameters);\n  }\n  static getAllOperations() {\n    const state = store.getState();\n    return Object.values(state.operations);\n  }\n  static getDElement(pointer) {\n    const state = store.getState();\n    const dElement = state.idlookup[pointer];\n    return dElement;\n  }\n  static getAllMetamodels() {\n    const state = store.getState();\n    const dModels = Object.values(state.m2models);\n    return LPointerTargetable.fromPointer(dModels);\n  }\n  static getAllModels() {\n    const state = store.getState();\n    const dModels = Object.values(state.m1models);\n    return LPointerTargetable.fromPointer(dModels);\n  }\n\n  //Giordano: end\n\n  static getVertex(wrap, resolvePointers) {\n    const state = store.getState();\n    let ptrs = [];\n    U.ArrayMerge0(false, ptrs,\n    // Object.values(state.graphs || {}),\n    Object.values(state.voidvertexs || {}), Object.values(state.vertexs || {}), Object.values(state.graphvertexs || {}), Object.values(state.edgepoints || {}));\n    console.log('selector getvertex: ', {\n      ptrs,\n      g: Object.values(state.graphs || {}),\n      vv: Object.values(state.voidvertexs || {}),\n      v: Object.values(state.vertexs || {}),\n      gv: Object.values(state.graphvertexs || {}),\n      ep: Object.values(state.edgepoints || {})\n    });\n    if (wrap === undefined || wrap === true) return ptrs.map(p => DPointerTargetable.wrap(p));\n    if (resolvePointers === undefined || resolvePointers === true) return ptrs.map(r => state.idlookup[r]);\n    return ptrs;\n  }\n  static getAll(Classe, condition, state, resolvePointers, wrap) {\n    if (!state) state = store.getState();\n    let GClass = Classe || {\n      name: \"idlookup\",\n      cname: \"idlookup\"\n    };\n    const className = ((GClass === null || GClass === void 0 ? void 0 : GClass.staticClassName) || GClass.cname).toLowerCase();\n    const allIdByClassName = state[className] || state[className.substr(1)] || state[className + 's'] || state[className.substr(1) + 's'];\n    Log.exDev(!allIdByClassName, 'cannot find store key:', {\n      state,\n      className,\n      Classe\n    });\n    let allDByClassName = null;\n    let allLByClassName = null;\n    if (resolvePointers || wrap) {\n      allDByClassName = allIdByClassName.map(e => state.idlookup[e]);\n      if (wrap) {\n        allLByClassName = allDByClassName.map(e => DPointerTargetable.wrap(e));\n      }\n    }\n    let ret = resolvePointers || wrap ? wrap ? allLByClassName : allDByClassName : allIdByClassName;\n    if (!Array.isArray(ret)) ret = Object.values(ret).filter(e => e instanceof Object);\n    if (condition) return ret.filter(e => condition(e));\n    return ret;\n  }\n  /*\r\n      static getModels(condition?: (m: DModel) => boolean): DModel[] {\r\n          /*\r\n          const className: Pointer<DPointerTargetable, 1, 1> = DViewElement.name.substr(1).toLowerCase() + 's';\r\n          const allByClassName: DPointerTargetable[] = state[className as string];\r\n          let models: DModel[] = state[className as string].map((mid) => state.idlookup[mid as string]) as DModel[];\r\n          if (condition) models = models.filter(condition);\r\n          return models; * /\r\n          return Selectors.getAll(DModel, undefined, undefined, resolvePointers, wrap); }*/\n\n  static getModel(name) {\n    let caseSensitive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    let wrap = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    if (!caseSensitive) name = name.toLowerCase();\n    let ret = Selectors.getAll(DModel, d => (caseSensitive ? d.name : d.name.toLowerCase()) === name, undefined, true, wrap)[0];\n    return ret;\n  }\n  static getByName(classe, name) {\n    let caseSensitive = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    let wrap = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    return Selectors.getByField(classe, 'name', name, caseSensitive, wrap);\n  }\n  static getByField(classe, field, value) {\n    let caseSensitive = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    let wrap = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n    if (!caseSensitive) value = value.toLowerCase();\n    let condition = d => {\n      var _d$field;\n      let ret = (caseSensitive ? d[field] : (_d$field = d[field]) === null || _d$field === void 0 ? void 0 : _d$field.toLowerCase()) === value;\n      console.log('filtering getall by field:', {\n        d,\n        dfield: d[field],\n        value,\n        ret\n      });\n      return ret;\n    };\n    let ret = Selectors.getAll(classe, condition, undefined, true, wrap)[0];\n    return ret;\n  }\n  static getViews(condition) {\n    return Selectors.getAll(DViewElement);\n  }\n  static queryJS(model, query) {\n    try {\n      return eval(query);\n    } catch (e) {\n      return [];\n    }\n  }\n  /*static getCurrentView(data: LModelElement): DViewElement {\r\n      Log.exDevv('todo');\r\n      return undefined as any;\r\n  }*/\n\n  // 2 = explicit exact match (===), 1 = matches a subclass, 0 = implicit match (any *), -1 = not matches\n  static matchesOclCondition(v, data) {\n    if (!v.oclCondition) return ViewEClassMatch.MISMATCH;\n    const oclCondition = v.oclCondition;\n    const user = LUser.fromPointer(DUser.current); // todo: just avoid presenting invalid views to this function instead of wrapping and filtering inside.\n    const project = user.project;\n    const viewpoint = project.activeViewpoint;\n    const isDefault = Defaults.check(v.id);\n    const isActiveViewpoint = v.viewpoint === viewpoint.id;\n    // console.log('allviews matcher ocl@@', {isDefault, data, dn:(data as any).name, oclCondition});\n    if (!isActiveViewpoint && !isDefault) return ViewEClassMatch.MISMATCH;\n    let constructors = RuntimeAccessibleClass.getAllClasses();\n    try {\n      const flag = OCL.filter(false, 'src', [data], oclCondition, constructors);\n      //console.log('allviews matcher ocl##', {flag, data, dn:(data as any).name, oclCondition});\n      if (flag.length > 0 && isActiveViewpoint) return ViewEClassMatch.EXACT_MATCH;\n      if (flag.length > 0 && !isActiveViewpoint) return ViewEClassMatch.IMPLICIT_MATCH;\n      return ViewEClassMatch.MISMATCH;\n    } catch (e) {\n      console.error('invalid ocl query');\n    }\n    return ViewEClassMatch.MISMATCH;\n  }\n  static matchesMetaClassTarget(v, data) {\n    if (!v) return ViewEClassMatch.MISMATCH;\n    if (!v.appliableToClasses || !v.appliableToClasses.length) return ViewEClassMatch.IMPLICIT_MATCH;\n    if (!data) return ViewEClassMatch.MISMATCH;\n    let ThisClass = RuntimeAccessibleClass.get(data === null || data === void 0 ? void 0 : data.className);\n    Log.exDev(!ThisClass, 'unable to find class type:', {\n      v,\n      data\n    }); // todo: v = view appliable to DModel, data = proxy<LModel>\n    let gotSubclassMatch = false;\n    for (let classtarget of v.appliableToClasses) {\n      const ClassTarget = RuntimeAccessibleClass.get(classtarget);\n      if (ThisClass === ClassTarget) return ViewEClassMatch.EXACT_MATCH; // explicit exact match\n      if (!gotSubclassMatch && U.classIsExtending(ThisClass, ClassTarget)) gotSubclassMatch = true; // explicit subclass match\n      if (gotSubclassMatch) return ViewEClassMatch.INHERITANCE_MATCH;\n    }\n    return ViewEClassMatch.MISMATCH;\n  }\n  static isOfSubclass(data, classTarget) {\n    let acceptEquality = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    let ThisClass = RuntimeAccessibleClass.get(data.className);\n    Log.exDev(!ThisClass, 'isOfSubclass() unable to find class type:', {\n      data\n    });\n    const ClassTarget = typeof classTarget === \"string\" ? RuntimeAccessibleClass.get(classTarget) : classTarget;\n    if (ThisClass === ClassTarget) return acceptEquality;\n    return U.classIsExtending(ThisClass, ClassTarget);\n  }\n  static scoreView(v1, data) {\n    let sameViewPointViews = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n    let datascore = 1;\n    let nodescore = 1;\n    if (data) {\n      // 1° priority: matching by EClass type\n      let v1MatchingEClassScore = this.matchesMetaClassTarget(v1, data === null || data === void 0 ? void 0 : data.__raw);\n      //console.log('allviews matcher meta', {v1MatchingEClassScore, d:data?.name, n:v1.name, v1});\n      // Log.l('score view:', {v1, data, v1MatchingEClassScore});\n      if (v1MatchingEClassScore === ViewEClassMatch.MISMATCH) return ViewEClassMatch.MISMATCH;\n      // 2° priority: by ocl condition matching\n      let v1OclScore = Selectors.matchesOclCondition(v1, data); // todo: not a fixed priority but acording to the \"complexity\" of the query\n      //console.log('allviews matcher ocl_', {v1OclScore, d:data?.name, n:v1.name, v1});\n      if (v1OclScore === ViewEClassMatch.MISMATCH) return ViewEClassMatch.MISMATCH;\n      // 3° priority by sub-view\n      let v1SubViewScore = ViewEClassMatch.EXACT_MATCH; // todo\n      // if (v1SubViewScore === ViewEClassMatch.MISMATCH) return ViewEClassMatch.MISMATCH; probably better permanently off, subviews should be a priority and not a requirement\n      // second priority: matching by viewpoint / subViews\n      datascore = v1MatchingEClassScore * v1OclScore * v1SubViewScore;\n    } /*\r\n      don't use node, check comment at getAppliedViews()\r\n      if (node){\r\n         // 1° priority: matching by DGraphElement type\r\n         let v1MatchingEClassScore: ViewEClassMatch = this.matchesMetaClassTarget(v1, node?.__raw);\r\n         nodescore = 1; // todo: ocl by node position or other node info\r\n      }*/\n    return datascore * nodescore * v1.explicitApplicationPriority;\n  }\n  static getViewByIDOrNameD(name, state) {\n    var _state$idlookup$name, _state$idlookup$id;\n    if (!state) state = store.getState();\n    if (((_state$idlookup$name = state.idlookup[name]) === null || _state$idlookup$name === void 0 ? void 0 : _state$idlookup$name.className) === DViewElement.cname) return state.idlookup[name];\n    let id = Selectors.getViewIdFromName(name, state);\n    if (id && ((_state$idlookup$id = state.idlookup[id]) === null || _state$idlookup$id === void 0 ? void 0 : _state$idlookup$id.className) === DViewElement.cname) return state.idlookup[id];\n    return undefined;\n  }\n\n  // input: \"subview.subview2.targetview\"\n  // output: returns pointer to targetview\n  // path is not required to start with a root, it's also possible to start navigating from a subview (notviewpoint/model view)\n  // in case multiple matches are given due to incomplete path not starting from a viewpoint, the oldest matching view is returned.\n  static getViewIdFromName(namepath, state) {\n    if (!state) state = store.getState();\n    let names = namepath.split(\".\");\n    let eligibleContainers = state.viewelements;\n    for (let i = 0; i < names.length; i++) {\n      let name = names[i];\n      eligibleContainers = eligibleContainers.filter(v => state.idlookup[v].name === name);\n      if (i === names.length - 1 || eligibleContainers.length === 0) return eligibleContainers[0];\n      eligibleContainers = eligibleContainers.flatMap(v => state.idlookup[v].subViews);\n    }\n    return undefined;\n  }\n\n  // NB: node must not be used to determine view.\n  // because node properties depend on the view, and it might cause a loop of swapping back and forth assigned view.\n  // view determines layout, not the other way around.\n  static getAppliedViews(data, selectedViewId, parentViewId) {\n    const state = store.getState();\n    const allViews = [...Selectors.getAllViewElements()];\n    const selectedView = null; // selectedViewId ? state.idlookup[selectedViewId] as DViewElement : null;\n    const parentView = parentViewId ? state.idlookup[parentViewId] : null;\n    const sameViewPointSubViews = parentView ? parentView.subViews : []; // a viewpoint is a simple view that is targeting a model\n    if (selectedView) U.arrayRemoveAll(allViews, selectedView);\n    let sortedPriority = allViews.map(\n    // v => new Scored<DViewElement>(Selectors.scoreView(v, data as any as DModelElement, hisnode, graph, sameViewPointSubViews), v)) as Scored<DViewElement>[];\n    v => {\n      return new Scored(Selectors.scoreView(v, data, sameViewPointSubViews), v);\n    });\n    sortedPriority.sort((e1, e2) => e2.score - e1.score);\n    // todo: prioritize views \"children\" of the view of the graph, so they will display differnet views for the same element in different graphs\n    // then sort by  view selector matching: on classtype (eattribute, eoperation, eclass...), on values, upperbound...\n    if (selectedView) sortedPriority = [new Scored('manually assigned', selectedView), ...sortedPriority];\n    // sortedPriority = sortedPriority.map( s=> s.element) as any] : sortedPriority.map( s=> s.element) as any;\n\n    // Log.exDevv('viewscores', {data, sp:sortedPriority});\n    return sortedPriority;\n  }\n  static getAllMP(state) {\n    if (!state) state = store.getState();\n    let allD = Object.values(state.idlookup);\n    return allD.filter(d => U.isObject(d) && Selectors.isOfSubclass(d, DModelElement));\n  }\n  static toObject(ptrs, state) {\n    if (!state) state = store.getState();\n    return ptrs.map(p => state.idlookup[p]);\n  }\n  static wrap(arr, state) {\n    if (!arr.length) return [];\n    if (!state) state = store.getState();\n    let objarr;\n    if (typeof arr[0] === \"string\") {\n      objarr = Selectors.toObject(arr, state);\n    } else objarr = arr;\n    return objarr.map(p => RuntimeAccessibleClass.wrap(p));\n  }\n  static unwrap(arr) {\n    return arr.map(a => a.__raw);\n  }\n  static getSubNodeElements(forGraph) {\n    let asPointers = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    let wrap = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    const state = store.getState();\n    const g = state.idlookup[forGraph];\n    if (asPointers) return g.subElements;\n    const subelements = g.subElements.map(geid => state.idlookup[geid]);\n    if (wrap) return subelements.map(ge => LPointerTargetable.from(ge));\n    return subelements;\n  }\n\n  //// giordano part\n\n  static getAllPackageClasses(id) {\n    const data = LPointerTargetable.from(id);\n    let lPackage;\n    const classes = [];\n    if (data.className === \"DReference\") {\n      const lClass = LPointerTargetable.from(data.father);\n      lPackage = LPointerTargetable.from(lClass.father);\n    }\n    if (data.className === \"DParameter\") {\n      const lOperation = LPointerTargetable.from(data.father);\n      const lClass = LPointerTargetable.from(lOperation.father);\n      lPackage = LPointerTargetable.wrap(lClass.father);\n    }\n    if (data.className === \"DOperation\") {\n      const lClass = LPointerTargetable.from(data.father);\n      lPackage = LPointerTargetable.wrap(lClass.father);\n    }\n    if (lPackage) {\n      for (let classifier of lPackage.classifiers) {\n        const lClassifier = LPointerTargetable.from(classifier);\n        if (lClassifier.className === \"DClass\") classes.push(lClassifier);\n      }\n    }\n    return classes;\n  }\n  static getAllPackageEnumerators(id) {\n    const data = LPointerTargetable.from(id);\n    let lPackage;\n    const enumerators = [];\n    if (data.className === \"DAttribute\") {\n      const lClass = LPointerTargetable.from(data.father);\n      lPackage = LPointerTargetable.from(lClass.father);\n    }\n    if (data.className === \"DParameter\") {\n      const lOperation = LPointerTargetable.from(data.father);\n      const lClass = LPointerTargetable.from(lOperation.father);\n      lPackage = LPointerTargetable.from(lClass.father);\n    }\n    if (data.className === \"DOperation\") {\n      const lClass = LPointerTargetable.from(data.father);\n      lPackage = LPointerTargetable.from(lClass.father);\n    }\n    if (lPackage) {\n      for (let classifier of lPackage.classifiers) {\n        const lClassifier = LPointerTargetable.from(classifier);\n        if (lClassifier.className === \"DEnumerator\") enumerators.push(lClassifier);\n      }\n    }\n    return enumerators;\n  }\n}) || _class);\nwindow.Selectors = Selectors;\nclass Scored {\n  constructor(score, element) {\n    this.score = score;\n    this.element = element;\n  }\n}","map":{"version":3,"names":["LUser","DUser","Defaults","DViewElement","DPointerTargetable","DModel","DModelElement","OCL","Log","LPointerTargetable","RuntimeAccessible","RuntimeAccessibleClass","store","U","toShortEType","ShortDefaultEClasses","toShortEClass","ViewEClassMatch","Selectors","_dec","_class","getActiveModel","_state$_lastSelected","metamodel","state","getState","selected","_lastSelected","modelElement","me","fromPointer","model","getLastSelectedModel","_state$_lastSelected2","ret","element","isMetamodel","m2","m1","instanceof","getAllViewElements","ptrs","Object","values","viewelements","views","map","ptr","idlookup","getViewpoints","viewpoints","getViewpoint","viewpoint","getObjects","objects","dObjects","lObjects","dObject","push","id","getValues","dValues","lValues","dValue","getDeleted","deleted","getDefaultEcoreClass","type","shorttype","toUpperCase","EObject","getPrimitiveType","getAllPrimitiveTypes","primitiveTypes","classifiers","getFirstPrimitiveTypes","getRefEdges","pointers","refEdges","dRefEdges","getField","field","getAllAttributes","attributes","getAllEnumLiterals","enumliterals","getAllReferences","references","getAllReferenceEdges","getAllClasses","classs","getReturnTypes","from","returnTypes","getAllClassesWithoutPrimitive","classList","splice","length","getAllEnumerators","flag","arguments","undefined","enumerators","getAllPackages","packages","getAllParameters","parameters","getAllOperations","operations","getDElement","pointer","dElement","getAllMetamodels","dModels","m2models","getAllModels","m1models","getVertex","wrap","resolvePointers","ArrayMerge0","voidvertexs","vertexs","graphvertexs","edgepoints","console","log","g","graphs","vv","v","gv","ep","p","r","getAll","Classe","condition","GClass","name","cname","className","staticClassName","toLowerCase","allIdByClassName","substr","exDev","allDByClassName","allLByClassName","e","Array","isArray","filter","getModel","caseSensitive","d","getByName","classe","getByField","value","_d$field","dfield","getViews","queryJS","query","eval","matchesOclCondition","data","oclCondition","MISMATCH","user","current","project","activeViewpoint","isDefault","check","isActiveViewpoint","constructors","EXACT_MATCH","IMPLICIT_MATCH","error","matchesMetaClassTarget","appliableToClasses","ThisClass","get","gotSubclassMatch","classtarget","ClassTarget","classIsExtending","INHERITANCE_MATCH","isOfSubclass","classTarget","acceptEquality","scoreView","v1","sameViewPointViews","datascore","nodescore","v1MatchingEClassScore","__raw","v1OclScore","v1SubViewScore","explicitApplicationPriority","getViewByIDOrNameD","_state$idlookup$name","_state$idlookup$id","getViewIdFromName","namepath","names","split","eligibleContainers","i","flatMap","subViews","getAppliedViews","selectedViewId","parentViewId","allViews","selectedView","parentView","sameViewPointSubViews","arrayRemoveAll","sortedPriority","Scored","sort","e1","e2","score","getAllMP","allD","isObject","toObject","arr","objarr","unwrap","a","getSubNodeElements","forGraph","asPointers","subElements","subelements","geid","ge","getAllPackageClasses","lPackage","classes","lClass","father","lOperation","classifier","lClassifier","getAllPackageEnumerators","window","constructor"],"sources":["C:/0Programmi/Dev/projects/frontend/jjodel/src/redux/selectors/selectors.ts"],"sourcesContent":["import {\r\n    AbstractConstructor,\r\n    AttribETypes,\r\n    Constructor,\r\n    DAttribute,\r\n    DClass,\r\n    DClassifier,\r\n    DEnumerator,\r\n    DGraph,\r\n    DGraphElement,\r\n    DObject,\r\n    DRefEdge,\r\n    DState,\r\n    DValue,\r\n    DVoidVertex,\r\n    GObject,\r\n    LClass,\r\n    LEnumerator,\r\n    LGraphElement,\r\n    LModel,\r\n    LModelElement,\r\n    LObject,\r\n    LOperation,\r\n    LPackage,\r\n    LRefEdge,\r\n    LValue,\r\n    LViewElement,\r\n    LViewPoint,\r\n    LVoidVertex,\r\n    Pointer,\r\n    ShortAttribETypes,\r\n    Dictionary,\r\n    LUser,\r\n    DUser,\r\n    Defaults, LProject,\r\n} from \"../../joiner\";\r\nimport {\r\n    DViewElement,\r\n    DPointerTargetable,\r\n    DModel,\r\n    DModelElement,\r\n    OCL,\r\n    Log,\r\n    LPointerTargetable,\r\n    RuntimeAccessible,\r\n    RuntimeAccessibleClass,\r\n    store,\r\n    U,\r\n    toShortEType\r\n} from \"../../joiner\";\r\nimport {DefaultEClasses, ShortDefaultEClasses, toShortEClass} from \"../../common/U\";\r\nimport { Selected } from \"../../joiner/types\";\r\n\r\nenum ViewEClassMatch { // this acts as a multiplier for explicit priority\r\n    MISMATCH = 0,\r\n    IMPLICIT_MATCH = 1,\r\n    INHERITANCE_MATCH = 2,\r\n    EXACT_MATCH = 3,\r\n}\r\n\r\n@RuntimeAccessible('Selectors')\r\nexport class Selectors{\r\n\r\n    static getActiveModel(): null|LModel {\r\n        let metamodel: null|LModel;\r\n        let state: DState & GObject = store.getState();\r\n        const selected = state._lastSelected?.modelElement;\r\n        if(selected) {\r\n            const me = LPointerTargetable.fromPointer(selected)\r\n            metamodel = (me) ? me.model : null;\r\n        } else metamodel = null;\r\n        return metamodel;\r\n    }\r\n\r\n    public static getLastSelectedModel<RET extends {m1?:LModel, m2?:LModel, model?:LModel, element?:LModelElement}>(state?: DState): RET {\r\n        state = state || store.getState();\r\n        let me = state._lastSelected?.modelElement;\r\n        if (!me) return {} as RET;\r\n        let ret: RET = {element: LPointerTargetable.fromPointer(me, state)} as RET;\r\n        ret.model = ret.element!.model\r\n        if (ret.model.isMetamodel) ret.m2 = ret.model;\r\n        else {\r\n            ret.m1 = ret.model;\r\n            ret.m2 = ret.m1.instanceof;\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    static getAllViewElements(): DViewElement[] {\r\n        // return Object.values(store.getState().idlookup).filter(v => v.className === DViewElement.name) as DViewElement[];\r\n        let state: DState & GObject = store.getState();\r\n        const ptrs: Pointer<DViewElement, 0, 'N'> = Object.values((state).viewelements);\r\n        let views: DViewElement[] = ptrs.map<DViewElement>( (ptr) => state.idlookup[ptr] as DViewElement);\r\n        return views;\r\n    }\r\n    //Giordano: start\r\n\r\n    public static getViewpoints() : LViewPoint[] {\r\n        const state: DState & GObject = store.getState();\r\n        return LPointerTargetable.fromPointer(state.viewpoints);\r\n    }\r\n    public static getViewpoint() : LViewPoint {\r\n        const state: DState & GObject = store.getState();\r\n        return LPointerTargetable.fromPointer(state.viewpoint);\r\n    }\r\n\r\n    public static getObjects(): LObject[] {\r\n        let state: DState & GObject = store.getState();\r\n        const ptrs: Pointer<DObject, 0, 'N'> = Object.values((state).objects);\r\n        const dObjects: DObject[] = ptrs.map<DObject>( (ptr) => state.idlookup[ptr] as DObject);\r\n        const lObjects: LObject[] = [];\r\n        for(let dObject of dObjects) {\r\n            lObjects.push(LPointerTargetable.fromPointer(dObject.id));\r\n        }\r\n        return lObjects;\r\n    }\r\n    public static getValues(): LValue[] {\r\n        let state: DState & GObject = store.getState();\r\n        const ptrs: Pointer<DValue, 0, 'N'> = Object.values((state).values);\r\n        const dValues: DValue[] = ptrs.map<DValue>( (ptr) => state.idlookup[ptr] as DValue);\r\n        const lValues: LValue[] = [];\r\n        for(let dValue of dValues) {\r\n            if(dValue?.id) {\r\n                lValues.push(LPointerTargetable.fromPointer(dValue.id));\r\n            }\r\n        }\r\n        return lValues;\r\n    }\r\n\r\n    public static getDeleted(): string [] {\r\n        const state: DState & GObject = store.getState();\r\n        return state.deleted;\r\n    }\r\n\r\n    public static getState(): any {\r\n        const state: DState & GObject = store.getState();\r\n        return state;\r\n    }\r\n\r\n    static getDefaultEcoreClass(type: DefaultEClasses | ShortDefaultEClasses, state?: DState): DClassifier {\r\n        let shorttype: string = (toShortEClass(type as any) || type).toUpperCase();\r\n        if (!state) state = store.getState();\r\n        // todo: make other m3 classes and make this generic like getPrimitiveType\r\n        return state.idlookup[\"Pointer_\"+ShortDefaultEClasses.EObject.toUpperCase()] as DClassifier;\r\n    }\r\n    static getPrimitiveType(type: AttribETypes | ShortAttribETypes, state?: DState): DClassifier {\r\n        let shorttype: string = (toShortEType(type as any) || type).toUpperCase();\r\n        if (!state) state = store.getState();\r\n        return state.idlookup[\"Pointer_\"+shorttype] as DClassifier;\r\n    }\r\n    static getAllPrimitiveTypes(): DClassifier[] {\r\n        let state: DState & GObject = store.getState();\r\n        const ptrs: Pointer<DClassifier, 0, 'N'> = Object.values((state).primitiveTypes);\r\n        const classifiers: DClassifier[] = ptrs.map<DClassifier>( (ptr) => state.idlookup[ptr] as DClassifier);\r\n        return classifiers;\r\n    }\r\n    static getFirstPrimitiveTypes(): DClassifier {\r\n        return Selectors.getAllPrimitiveTypes()[0];\r\n    }\r\n    static getRefEdges(): DRefEdge[] {\r\n        const state: DState & GObject = store.getState();\r\n        const pointers: Pointer<DRefEdge, 0, 'N', LRefEdge> = Object.values((state).refEdges);\r\n        const dRefEdges: DRefEdge[] = pointers.map<DRefEdge>( (ptr) => state.idlookup[ptr] as DRefEdge);\r\n        return dRefEdges;\r\n    }\r\n    static getField(field: string): string[] {\r\n        let state: DState & GObject = store.getState();\r\n        const pointers: Pointer<DModelElement, 0, 'N'> = Object.values((state)[field]);\r\n        return pointers;\r\n    }\r\n\r\n    static getAllAttributes(): string[] {\r\n        const state: DState = store.getState();\r\n        return Object.values((state).attributes);\r\n    }\r\n    static getAllEnumLiterals(): string[] {\r\n        const state: DState = store.getState();\r\n        return Object.values((state).enumliterals);\r\n    }\r\n    static getAllReferences(): string[] {\r\n        const state: DState = store.getState();\r\n        return Object.values((state).references);\r\n    }\r\n    static getAllReferenceEdges(): string[] {\r\n        const state: DState = store.getState();\r\n        return Object.values((state).refEdges);\r\n    }\r\n    static getAllClasses(): string[] {\r\n        const state: DState = store.getState();\r\n        return Object.values((state).classs);\r\n    }\r\n    static getReturnTypes(): LClass[] {\r\n        const state: DState = store.getState();\r\n        return LPointerTargetable.from(Object.values((state).returnTypes));\r\n    }\r\n\r\n    static getAllClassesWithoutPrimitive(): string[] {\r\n        // this solution does not look good. what if a primitive type is inserted at runtime in between?\r\n        // coould reach the same goal by taking all Classes of a model (m2), excluding classes from other models (types are classes from m3 model)\r\n        const state: DState = store.getState();\r\n        const classList: string[] = Object.values((state).classs);\r\n        classList.splice(0, Selectors.getAllPrimitiveTypes().length);\r\n        /* todo: need to change it in something like this once cross-references between models and instances are implemented\r\n        const m2: LModel;\r\n        m2.isInstanceOf = m3 as LModel;\r\n        m2.isInstanceOf.classes;*/\r\n\r\n        return classList;\r\n    }\r\n\r\n    static getAllEnumerators(flag = false): string[] {\r\n        const state: DState = store.getState();\r\n        return Object.values((state).enumerators);\r\n    }\r\n    static getAllPackages(): string[] {\r\n        const state: DState = store.getState();\r\n        return Object.values((state).packages);\r\n    }\r\n\r\n    static getAllParameters(): string[] {\r\n        const state: DState = store.getState();\r\n        return Object.values((state).parameters);\r\n    }\r\n    static getAllOperations(): string[] {\r\n        const state: DState = store.getState();\r\n        return Object.values((state).operations);\r\n    }\r\n\r\n    static getDElement<T extends DModelElement>(pointer: string): T {\r\n        const state: DState & GObject = store.getState();\r\n        const dElement: T = state.idlookup[pointer] as T;\r\n        return dElement;\r\n    }\r\n\r\n    static getAllMetamodels(): LModel[] {\r\n        const state: DState = store.getState();\r\n        const dModels = Object.values((state).m2models);\r\n        return LPointerTargetable.fromPointer(dModels);\r\n    }\r\n\r\n    static getAllModels(): LModel[] {\r\n        const state: DState = store.getState();\r\n        const dModels = Object.values((state).m1models);\r\n        return LPointerTargetable.fromPointer(dModels);\r\n    }\r\n\r\n    //Giordano: end\r\n\r\n    static getVertex<W extends boolean = true, RP extends boolean = true>(wrap?: W /* = true */, resolvePointers?: RP /**/):\r\n        W extends false ? (RP extends false ? Pointer<DVoidVertex, 1, 1, LVoidVertex>[] : DVoidVertex[]) : LVoidVertex[] {\r\n        const state: DState = store.getState();\r\n        let ptrs: Pointer<DVoidVertex>[] = [];\r\n\r\n        U.ArrayMerge0(false, ptrs,\r\n            // Object.values(state.graphs || {}),\r\n            Object.values(state.voidvertexs || {}),\r\n            Object.values(state.vertexs || {}),\r\n            Object.values(state.graphvertexs || {}),\r\n            Object.values(state.edgepoints || {}));\r\n\r\n        console.log('selector getvertex: ', {ptrs, g: Object.values(state.graphs || {}), vv:Object.values(state.voidvertexs || {}), v:Object.values(state.vertexs || {}), gv:Object.values(state.graphvertexs || {}), ep:Object.values(state.edgepoints || {})});\r\n        if (wrap === undefined || wrap === true) return ptrs.map( p => DPointerTargetable.wrap(p)) as any[];\r\n        if (resolvePointers === undefined || resolvePointers === true) return ptrs.map( r => state.idlookup[r]) as any[];\r\n        return ptrs as any[];\r\n    }\r\n\r\n    static getAll<D extends DPointerTargetable, L extends LPointerTargetable, DT extends typeof DPointerTargetable = typeof DPointerTargetable,\r\n        W extends undefined | true | false = false, RP extends undefined | true | false = true, RET = W extends false ? (RP extends false ? Pointer<D, 1, 1, L> : D) : L>\r\n        (Classe?: DT, condition?: (e:RET) => boolean, state?: DState, resolvePointers?: RP /**/, wrap?: W /* = true */): RET[] {\r\n        if (!state) state = store.getState();\r\n        let GClass = (Classe as GObject) || {name:\"idlookup\", cname:\"idlookup\"};\r\n        const className: string = (GClass?.staticClassName || GClass.cname).toLowerCase();\r\n        const allIdByClassName: Pointer<D, 1, 1, L>[]\r\n            = (state as GObject)[className]\r\n            || (state as GObject)[className.substr(1)]\r\n            || (state as GObject)[className + 's']\r\n            || (state as GObject)[className.substr(1) + 's'];\r\n        Log.exDev(!allIdByClassName, 'cannot find store key:', {state, className, Classe});\r\n        let allDByClassName: D[] | null = null;\r\n        let allLByClassName: L[] | null = null;\r\n        if (resolvePointers || wrap) {\r\n            allDByClassName = allIdByClassName.map( (e) => (state as DState).idlookup[e] ) as D[];\r\n            if (wrap) {\r\n                allLByClassName = allDByClassName.map( e => DPointerTargetable.wrap(e)) as any as L[];\r\n            }\r\n        }\r\n        let ret: RET[] = (resolvePointers || wrap ? (wrap ? allLByClassName : allDByClassName) : allIdByClassName) as any[] as RET[];\r\n        if (!Array.isArray(ret)) ret = Object.values(ret).filter(e => e instanceof Object) as RET[];\r\n        if (condition) return ret.filter( e => condition(e));\r\n        return ret;\r\n    }\r\n/*\r\n    static getModels(condition?: (m: DModel) => boolean): DModel[] {\r\n        /*\r\n        const className: Pointer<DPointerTargetable, 1, 1> = DViewElement.name.substr(1).toLowerCase() + 's';\r\n        const allByClassName: DPointerTargetable[] = state[className as string];\r\n        let models: DModel[] = state[className as string].map((mid) => state.idlookup[mid as string]) as DModel[];\r\n        if (condition) models = models.filter(condition);\r\n        return models; * /\r\n        return Selectors.getAll(DModel, undefined, undefined, resolvePointers, wrap); }*/\r\n\r\n    static getModel(name: string, caseSensitive: boolean = false, wrap: boolean = false): DModel | LModel | null {\r\n        if (!caseSensitive) name = name.toLowerCase();\r\n        let ret = Selectors.getAll<DModel, LModel>(DModel, (d) => (caseSensitive ? d.name : d.name.toLowerCase()) === name, undefined, true, wrap as any)[0];\r\n        return ret;\r\n    }\r\n\r\n    static getByName(classe: typeof DPointerTargetable, name: string, caseSensitive: boolean = false, wrap: boolean = false): DPointerTargetable | LPointerTargetable | null {\r\n        return Selectors.getByField(classe, 'name', name, caseSensitive, wrap); }\r\n\r\n    static getByField(classe: typeof DPointerTargetable, field: string, value: string, caseSensitive: boolean = false, wrap: boolean = false): DPointerTargetable | LPointerTargetable | null {\r\n        if (!caseSensitive) value = value.toLowerCase();\r\n        let condition = (d: any) => {\r\n            let ret = (caseSensitive ? d[field] : d[field]?.toLowerCase()) === value;\r\n            console.log('filtering getall by field:', {d, dfield:d[field], value, ret});\r\n            return ret;\r\n        }\r\n        let ret = Selectors.getAll(classe, condition, undefined, true, wrap as any)[0];\r\n        return ret; }\r\n\r\n    static getViews(condition?: (m: DModel) => boolean): DViewElement[] { return Selectors.getAll(DViewElement); }\r\n\r\n\r\n\r\n    private static queryJS(model: LModel, query: string): LPointerTargetable[] {\r\n        try {\r\n            return eval(query);\r\n        } catch (e) { return []; }\r\n    }\r\n    /*static getCurrentView(data: LModelElement): DViewElement {\r\n        Log.exDevv('todo');\r\n        return undefined as any;\r\n    }*/\r\n\r\n\r\n    // 2 = explicit exact match (===), 1 = matches a subclass, 0 = implicit match (any *), -1 = not matches\r\n    private static matchesOclCondition(v: DViewElement, data: DModelElement | LModelElement): ViewEClassMatch.MISMATCH | ViewEClassMatch.IMPLICIT_MATCH | ViewEClassMatch.EXACT_MATCH {\r\n        if (!v.oclCondition) return ViewEClassMatch.MISMATCH;\r\n        const oclCondition = v.oclCondition;\r\n        const user: LUser = LUser.fromPointer(DUser.current); // todo: just avoid presenting invalid views to this function instead of wrapping and filtering inside.\r\n        const project: LProject = user.project as LProject;\r\n        const viewpoint = project.activeViewpoint;\r\n        const isDefault = Defaults.check(v.id);\r\n        const isActiveViewpoint = v.viewpoint === viewpoint.id;\r\n        // console.log('allviews matcher ocl@@', {isDefault, data, dn:(data as any).name, oclCondition});\r\n        if(!isActiveViewpoint && !isDefault) return ViewEClassMatch.MISMATCH;\r\n        let constructors: Constructor[] = RuntimeAccessibleClass.getAllClasses() as (Constructor|AbstractConstructor)[] as Constructor[];\r\n        try {\r\n            const flag = OCL.filter(false, 'src', [data], oclCondition, constructors);\r\n            //console.log('allviews matcher ocl##', {flag, data, dn:(data as any).name, oclCondition});\r\n            if(flag.length > 0 && isActiveViewpoint) return ViewEClassMatch.EXACT_MATCH;\r\n            if(flag.length > 0 && !isActiveViewpoint) return ViewEClassMatch.IMPLICIT_MATCH;\r\n            return ViewEClassMatch.MISMATCH;\r\n        } catch (e) { console.error('invalid ocl query'); }\r\n        return ViewEClassMatch.MISMATCH;\r\n    }\r\n\r\n\r\n    private static matchesMetaClassTarget(v: DViewElement, data: DModelElement | DGraphElement): ViewEClassMatch {\r\n        if (!v) return ViewEClassMatch.MISMATCH;\r\n        if (!v.appliableToClasses || !v.appliableToClasses.length) return ViewEClassMatch.IMPLICIT_MATCH;\r\n        if (!data) return ViewEClassMatch.MISMATCH;\r\n        let ThisClass: typeof DPointerTargetable = RuntimeAccessibleClass.get(data?.className);\r\n        Log.exDev(!ThisClass, 'unable to find class type:', {v, data}); // todo: v = view appliable to DModel, data = proxy<LModel>\r\n        let gotSubclassMatch: boolean = false;\r\n        for (let classtarget of v.appliableToClasses) {\r\n            const ClassTarget: typeof DPointerTargetable = RuntimeAccessibleClass.get(classtarget);\r\n            if (ThisClass === ClassTarget) return ViewEClassMatch.EXACT_MATCH; // explicit exact match\r\n            if (!gotSubclassMatch && U.classIsExtending(ThisClass, ClassTarget)) gotSubclassMatch = true; // explicit subclass match\r\n            if (gotSubclassMatch) return ViewEClassMatch.INHERITANCE_MATCH;\r\n        }\r\n        return ViewEClassMatch.MISMATCH;\r\n }\r\n\r\n    private static isOfSubclass(data: DPointerTargetable, classTarget: string | typeof DPointerTargetable, acceptEquality: boolean = false): boolean {\r\n        let ThisClass: typeof DPointerTargetable = RuntimeAccessibleClass.get(data.className);\r\n        Log.exDev(!ThisClass, 'isOfSubclass() unable to find class type:', {data});\r\n        const ClassTarget: typeof DPointerTargetable = typeof classTarget === \"string\"? RuntimeAccessibleClass.get(classTarget) : classTarget;\r\n        if (ThisClass === ClassTarget) return acceptEquality;\r\n        return U.classIsExtending(ThisClass, ClassTarget);\r\n    }\r\n\r\n\r\n\r\n    private static scoreView(v1: DViewElement, data: LModelElement | undefined, sameViewPointViews: Pointer<DViewElement, 1, 1>[] = []): number {\r\n        let datascore: number = 1;\r\n        let nodescore: number = 1;\r\n        if (data) {// 1° priority: matching by EClass type\r\n            let v1MatchingEClassScore: ViewEClassMatch = this.matchesMetaClassTarget(v1, data?.__raw);\r\n            //console.log('allviews matcher meta', {v1MatchingEClassScore, d:data?.name, n:v1.name, v1});\r\n            // Log.l('score view:', {v1, data, v1MatchingEClassScore});\r\n            if (v1MatchingEClassScore === ViewEClassMatch.MISMATCH) return ViewEClassMatch.MISMATCH;\r\n            // 2° priority: by ocl condition matching\r\n            let v1OclScore = Selectors.matchesOclCondition(v1, data); // todo: not a fixed priority but acording to the \"complexity\" of the query\r\n            //console.log('allviews matcher ocl_', {v1OclScore, d:data?.name, n:v1.name, v1});\r\n            if (v1OclScore === ViewEClassMatch.MISMATCH) return ViewEClassMatch.MISMATCH;\r\n            // 3° priority by sub-view\r\n            let v1SubViewScore: ViewEClassMatch = ViewEClassMatch.EXACT_MATCH as ViewEClassMatch; // todo\r\n            // if (v1SubViewScore === ViewEClassMatch.MISMATCH) return ViewEClassMatch.MISMATCH; probably better permanently off, subviews should be a priority and not a requirement\r\n            // second priority: matching by viewpoint / subViews\r\n            datascore = (v1MatchingEClassScore * v1OclScore * v1SubViewScore);\r\n        }/*\r\n        don't use node, check comment at getAppliedViews()\r\n        if (node){\r\n            // 1° priority: matching by DGraphElement type\r\n            let v1MatchingEClassScore: ViewEClassMatch = this.matchesMetaClassTarget(v1, node?.__raw);\r\n            nodescore = 1; // todo: ocl by node position or other node info\r\n        }*/\r\n        return datascore * nodescore * v1.explicitApplicationPriority;\r\n    }\r\n\r\n    static getViewByIDOrNameD(name: string, state?: DState): undefined | DViewElement {\r\n        if (!state) state = store.getState();\r\n        if (state.idlookup[name]?.className === DViewElement.cname) return state.idlookup[name] as DViewElement;\r\n        let id = Selectors.getViewIdFromName(name, state);\r\n        if (id && state.idlookup[id]?.className === DViewElement.cname) return state.idlookup[id] as DViewElement;\r\n        return undefined;\r\n    }\r\n\r\n\r\n    // input: \"subview.subview2.targetview\"\r\n    // output: returns pointer to targetview\r\n    // path is not required to start with a root, it's also possible to start navigating from a subview (notviewpoint/model view)\r\n    // in case multiple matches are given due to incomplete path not starting from a viewpoint, the oldest matching view is returned.\r\n    static getViewIdFromName(namepath: string, state?: DState): undefined | Pointer<DViewElement> {\r\n        if (!state) state = store.getState();\r\n        let names: string[] = namepath.split(\".\");\r\n        let eligibleContainers: Pointer<DViewElement>[] = state.viewelements;\r\n        for (let i = 0; i < names.length; i++) {\r\n            let name = names[i];\r\n            eligibleContainers = eligibleContainers.filter(v => ((state as DState).idlookup[v] as DViewElement).name === name);\r\n            if (i === names.length-1 || eligibleContainers.length === 0) return eligibleContainers[0];\r\n            eligibleContainers = eligibleContainers.flatMap(v => ((state as DState).idlookup[v] as DViewElement).subViews);\r\n        }\r\n        return undefined;\r\n    }\r\n\r\n                             // NB: node must not be used to determine view.\r\n    // because node properties depend on the view, and it might cause a loop of swapping back and forth assigned view.\r\n    // view determines layout, not the other way around.\r\n    static getAppliedViews(data: LModelElement|undefined,\r\n                           selectedViewId: Pointer<DViewElement, 0, 1, LViewElement>, parentViewId: Pointer<DViewElement, 0, 1, LViewElement>): Scored<DViewElement>[] {\r\n        const state : DState = store.getState();\r\n        const allViews: DViewElement[] = [...Selectors.getAllViewElements()];\r\n        const selectedView: DViewElement | null = null; // selectedViewId ? state.idlookup[selectedViewId] as DViewElement : null;\r\n        const parentView: DViewElement | null = parentViewId ? state.idlookup[parentViewId] as DViewElement : null;\r\n        const sameViewPointSubViews: Pointer<DViewElement, 1, 1>[] = parentView ? parentView.subViews : []; // a viewpoint is a simple view that is targeting a model\r\n        if (selectedView) U.arrayRemoveAll(allViews, selectedView);\r\n        let sortedPriority: Scored<DViewElement>[] = allViews.map(\r\n            // v => new Scored<DViewElement>(Selectors.scoreView(v, data as any as DModelElement, hisnode, graph, sameViewPointSubViews), v)) as Scored<DViewElement>[];\r\n            (v) => {\r\n                return new Scored<DViewElement>(Selectors.scoreView(v, data, sameViewPointSubViews), v);}\r\n        ) as Scored<DViewElement>[];\r\n        sortedPriority.sort( (e1, e2) => e2.score - e1.score);\r\n        // todo: prioritize views \"children\" of the view of the graph, so they will display differnet views for the same element in different graphs\r\n        // then sort by  view selector matching: on classtype (eattribute, eoperation, eclass...), on values, upperbound...\r\n        if (selectedView) sortedPriority = [new Scored<DViewElement>('manually assigned' as any, selectedView), ...sortedPriority];\r\n        // sortedPriority = sortedPriority.map( s=> s.element) as any] : sortedPriority.map( s=> s.element) as any;\r\n\r\n        // Log.exDevv('viewscores', {data, sp:sortedPriority});\r\n        return sortedPriority;\r\n    }\r\n\r\n    static getAllMP(state?: DState): DModelElement[] {\r\n        if (!state) state = store.getState();\r\n        let allD: DPointerTargetable[] = Object.values(state.idlookup);\r\n        return allD.filter( (d: DPointerTargetable) => U.isObject(d) && Selectors.isOfSubclass(d, DModelElement)) as DModelElement[]; }\r\n\r\n    static toObject<D extends DPointerTargetable>(ptrs: Pointer<D>[], state?: DState):D[] {\r\n        if (!state) state = store.getState();\r\n        return ptrs.map(p => (state as DState).idlookup[p]) as D[]; }\r\n\r\n    static wrap<D extends DPointerTargetable, L extends LPointerTargetable>(arr: (Pointer<D, 1, 1, L> | D)[], state?: DState): L[] {\r\n        if (!arr.length) return [];\r\n        if (!state) state = store.getState();\r\n        let objarr: D[];\r\n        if (typeof arr[0] === \"string\") { objarr = Selectors.toObject(arr as string[], state); }\r\n        else objarr = arr as D[];\r\n        return objarr.map(p => RuntimeAccessibleClass.wrap(p)) as L[]; }\r\n\r\n    static unwrap<D extends DPointerTargetable, L extends LPointerTargetable>(arr:L[]): D[] { return arr.map( (a)=> a.__raw) as any[]; }\r\n    static getSubNodeElements(forGraph: Pointer<DGraph, 1, 1>, asPointers: boolean = false, wrap: boolean = false): Pointer<DGraphElement>[] | DGraphElement[] | LGraphElement[] {\r\n        const state : DState = store.getState();\r\n        const g: DGraph = state.idlookup[forGraph] as DGraph;\r\n        if (asPointers) return g.subElements;\r\n        const subelements: DGraphElement[] = g.subElements.map( geid => state.idlookup[geid]) as DGraphElement[];\r\n        if (wrap) return subelements.map<LGraphElement>( (ge) => LPointerTargetable.from(ge));\r\n        return subelements; }\r\n\r\n\r\n\r\n\r\n    //// giordano part\r\n\r\n\r\n\r\n    public static getAllPackageClasses(id: string): LClass[] {\r\n        const data = LPointerTargetable.from(id) as GObject;\r\n        let lPackage : LPackage | undefined;\r\n        const classes: LClass[] = [];\r\n        if (data.className === \"DReference\") {\r\n            const lClass: LClass = LPointerTargetable.from(data.father);\r\n            lPackage = LPointerTargetable.from(lClass.father);\r\n        }\r\n        if (data.className === \"DParameter\") {\r\n            const lOperation: LOperation = LPointerTargetable.from(data.father);\r\n            const lClass: LClass = LPointerTargetable.from(lOperation.father);\r\n            lPackage = LPointerTargetable.wrap(lClass.father);\r\n        }\r\n        if (data.className === \"DOperation\") {\r\n            const lClass: LClass = LPointerTargetable.from(data.father);\r\n            lPackage = LPointerTargetable.wrap(lClass.father);\r\n        }\r\n        if (lPackage) {\r\n            for(let classifier of lPackage.classifiers) {\r\n                const lClassifier: LClass | LEnumerator = LPointerTargetable.from(classifier);\r\n                if(lClassifier.className === \"DClass\") classes.push(lClassifier as LClass);\r\n            }\r\n        }\r\n        return classes;\r\n    }\r\n    public static getAllPackageEnumerators(id: string): LEnumerator[] {\r\n        const data = LPointerTargetable.from(id) as GObject;\r\n        let lPackage : LPackage | undefined;\r\n        const enumerators: LEnumerator[] = [];\r\n        if(data.className === \"DAttribute\") {\r\n            const lClass: LClass = LPointerTargetable.from(data.father);\r\n            lPackage = LPointerTargetable.from(lClass.father);\r\n        }\r\n        if(data.className === \"DParameter\") {\r\n            const lOperation: LOperation = LPointerTargetable.from(data.father);\r\n            const lClass: LClass = LPointerTargetable.from(lOperation.father);\r\n            lPackage = LPointerTargetable.from(lClass.father);\r\n        }\r\n        if(data.className === \"DOperation\") {\r\n            const lClass: LClass = LPointerTargetable.from(data.father);\r\n            lPackage = LPointerTargetable.from(lClass.father);\r\n        }\r\n        if(lPackage) {\r\n            for(let classifier of lPackage.classifiers) {\r\n                const lClassifier: LClass | LEnumerator = LPointerTargetable.from(classifier);\r\n                if(lClassifier.className === \"DEnumerator\") enumerators.push(lClassifier as LEnumerator);\r\n            }\r\n        }\r\n        return enumerators;\r\n    }\r\n}\r\n(window as any).Selectors = Selectors;\r\n\r\nclass Scored<T extends GObject> {\r\n    constructor(public score: number, public element: T) {}\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}