{"ast":null,"code":"var _dec,_class,_class2;import{Log,RuntimeAccessible}from\"../joiner\";/*\r\n                                    TODO for every update: check the VersionFixer.help() function\r\n*/export let VersionFixer=(_dec=RuntimeAccessible('VersionFixer'),_dec(_class=(_class2=class VersionFixer{// automatically updated from updater function names\nstatic help(){console.clear();let i=1;console.log(\"\\nBefore deploying a new version you should:\\n\\n\".concat(i++,\") Update changelog\\n\\n\").concat(i++,\") make a separate build subfolder (so you can switch versions)\\n\\n\").concat(i++,\") build a new empty versioning function with signature like: private ['2.1 -> 2.3'](s: DState): DState\\n        fill this function in a way that translates from the state shape of the old version, to the state shape of the new one\\n   \\n        \"));// DEPRECATED stuff\nfalse&&console.log(\"\\nBefore deploying a new version you should:\\n\\n\".concat(i++,\"?) ONLY IF IT'S FIRST TIME;\\n   run DState.registerFirstTimeOnly() in the deploy version and export the localStorage variables starting with \").concat(VersionFixer.prefix,\" to the dev version.\\n   or call it in dev version after having temporarly undone the pending updates if possible, otherwise next steps might fail.\\n   \\n\").concat(i++,\"?) ONLY IF there are entirely new kinds of D-objects or optional new sub-structures in D-objects (like View.palette), update buildVersionSignature() method\\n \\n\\n\").concat(i++,\") build a new empty versioning function with signature: private ['2.1 -> 2.3'](s: DState): DState\\n\\n\").concat(i++,\") in DState update DState.version.n (leave date and conversionList unchanged)\\n\\n\").concat(i++,\") open a new empty project (no models no metamodels)\\n   to find out what changed in the state between version without risking human error, i made an automatic detection.\\n   call VersionFixer.checkVersionChanges() in browser console to see what changed need conversion in the function (i would save the result as comment inside the func)\\n\\n\").concat(i++,\") fill the empty function of step (1), in a way that translates from the state shape of the old version, to the state shape of the new one\\n\\n\").concat(i++,\") only after the transition function is complete, call VersionFixer.registerNewVersion();\\n   it will both validate the version update function and store the new version as baseline.\\n   (needs to be done last because checkVersionChanges will stop working until a new version is ready)\\n   \\nBEWARE: this approach cannot detect changes of valid values where the type did not change. eg if view.appliableTo = 'string' change his valid string values but not his type;\\neverytime you put hands into a D-Object shape or valid values, you should document them to be able to write a conversion function later on.\\n        \"));}static get_highestversion(){if(VersionFixer.highestVersion===0)VersionFixer.setup();return VersionFixer.highestVersion;}static setup(){VersionFixer.versionAdapters={};const errormsg=k=>\"Version auto-updater have a updater registered incorrectly: \\\"\"+k+\"\\\", please notify the developers.\";let staticKeys=[];// no need for them Object.getOwnPropertyNames(VersionFixer);\nlet instanceKeys=Object.getOwnPropertyNames(VersionFixer.prototype);// object.keys does not list not-enumarable stuff (like class funcs)\nlet allKeys=[...staticKeys,...instanceKeys];for(let k of allKeys){switch(k){case'constructor':case'd':case'className':case'prefix':case'highestVersion':case'versionAdapters':case'get_highestversion':case'staticClassName':case'cname':case'subclasses':case'help':case'setup':case'update':continue;}let[froms,tos]=k.split(' -> ');Log.exDev(!(froms===null||froms===void 0?void 0:froms.length)||!(tos===null||tos===void 0?void 0:tos.length),errormsg(k));let from=+froms;let to=+tos;Log.exDev(isNaN(from)||isNaN(to),errormsg(k));Log.exDev(!!VersionFixer.versionAdapters[from],\"duplicate version adapter from \\\"\"+from+\"\\\", please notify the developers.\");VersionFixer.highestVersion=Math.max(VersionFixer.highestVersion,to);VersionFixer.versionAdapters[from]={n:to,f:VersionFixer.prototype[k]};}return VersionFixer.versionAdapters;}static update(s){if(!VersionFixer.versionAdapters)VersionFixer.setup();if(!s.version)s.version={n:2.1,date:\"_reconverted\",conversionList:[0]};let prevVer=s.version.n||0;let currVer=prevVer;let singleton=new VersionFixer();while(currVer!==VersionFixer.highestVersion){Log.exDev(!VersionFixer.versionAdapters[currVer],\"missing version adapter from \\\"\"+currVer+\"\\\", please notify the developers.\",{adapers:VersionFixer.versionAdapters,curr:VersionFixer.versionAdapters[currVer]});console.log('versionfixer update pre',{prevVer,currVer,entry:VersionFixer.versionAdapters[currVer]});let{n,f}=VersionFixer.versionAdapters[currVer];s.version.conversionList=[...s.version.conversionList,currVer];s=f.call(singleton,s);currVer=s.version.n=n||0;console.log('versionfixer update post',{prevVer,currVer,n});//Log.exDev(currVer !== n, \"version updater updated to incorrect target versionn \\\"\"+prevVer+\"\\\" -> \\\"\"+n+\"\\\" , please notify the developers.\");\nLog.exDev(currVer<=prevVer,\"version updater found loop at version \\\"\"+currVer+\"\\\", please notify the developers.\");prevVer=currVer;}return s;}d(ptr,s){return s.idlookup[ptr];// {n}\n}['0 -> 2.1'](s){s.version={n:2.1,date:\"_reconverted\",conversionList:[0]};return s;}['2.1 -> 2.2'](s){}['2.2 -> 2.201'](s){// let ls: LState = LPointerTargetable.from(s); nope, avoid L-objects. actions would fire in present state instead of in parameter state\nfor(let c of s.classs.map(p=>this.d(p,s))){c.isSingleton=!!c.isSingleton;// booleanize the undefined\nc.sealed=[];c.final=false;c.rootable=undefined;}for(let c of Object.values(s.idlookup)){if((c===null||c===void 0?void 0:c.className)&&c.id&&c.isCrossReference===undefined)c.isCrossReference=false;}for(let c of s.viewelements.map(p=>this.d(p,s))){c.father=c.viewpoint;}for(let c of s.viewpoints.map(p=>this.d(p,s))){c.cssIsGlobal=true;}for(let c of s.projects.map(p=>this.d(p,s))){c.favorite={};c.description='';}for(let c of s.references.map(p=>this.d(p,s))){if(c.composition===undefined)c.aggregation=!(c.composition=!!c.containment);}for(let c of s.models.map(p=>this.d(p,s))){if(c.dependencies===undefined)c.dependencies=[];}for(let c of s.attributes.map(p=>this.d(p,s))){c.derived=!!c.derived;c.derived_write=undefined;// c.derived ? '' : undefined;\nc.derived_read=undefined;// c.derived ? '' : undefined;\n}return s;}},_class2.cname='VersionFixer',_class2.versionAdapters=_class2.setup(),_class2.highestVersion=0,_class2.prefix='__jodel_versioning_',_class2))||_class);//deprecated stuff\n/*\r\npublic static checkVersionChanges(): GObject{\r\n    let lastVerName = localStorage.getItem(VersionFixer.prefix+'last');\r\n    let lastVerState = localStorage.getItem(VersionFixer.prefix+lastVerName);\r\n    let lastVersionSignature = JSON.parse(lastVerState || '{not:\"found\"}');\r\n    let newVersionSignature = this.buildVersionSignature();\r\n    return VersionFixer.checkVersionChanges_inner(lastVersionSignature, newVersionSignature);\r\n}\r\npublic static checkVersionChanges_inner(s1: DState, s2:DState): GObject{ return U.objectDelta(s1, s2, true); }\r\npublic static registerFirstTimeOnly(): void {\r\n    let newVersionSignature = VersionFixer.buildVersionSignature();\r\n    localStorage.setItem(VersionFixer.prefix+'last', ''+newVersionSignature.version.n);\r\n    localStorage.setItem(VersionFixer.prefix+''+newVersionSignature.version.n, JSON.stringify(newVersionSignature));\r\n}\r\n\r\npublic static registerNewVersion(): boolean {\r\n    let lastVerName = localStorage.getItem(VersionFixer.prefix+'last');\r\n    let prevVersionSignature: DState = JSON.parse(localStorage.getItem(VersionFixer.prefix+lastVerName) || '{not:\"found\"}') as any;\r\n    let newVersionSignature = VersionFixer.buildVersionSignature();\r\n    let updatedVersionSignature = this.update(prevVersionSignature);\r\n    let versionDiff: GObject = VersionFixer.checkVersionChanges_inner(updatedVersionSignature, newVersionSignature);\r\n    if (Object.keys(versionDiff).length !== 0) {\r\n        console.log(\"failed to save new version, the conversion function is not updating state properly.\",\r\n            {versionDiff, prevVersionSignature, newVersionSignature, updatedVersionSignature});\r\n        return false;\r\n    }\r\n    localStorage.setItem(VersionFixer.prefix+'last', ''+newVersionSignature.version.n);\r\n    localStorage.setItem(VersionFixer.prefix+''+newVersionSignature.version.n, JSON.stringify(newVersionSignature));\r\n    return true;\r\n}\r\nprivate static buildVersionSignature(): DState {\r\n    // purpose: save in state 1 of each D-objects with all the possible sub-objects in every possible structure shape\r\n    // values can be dummy but syntactical valid\r\n    //DState.new(); nope, i'm using current state, just call it from an empty project with no models.\r\n    DViewElement.new2(\"View\", \"jsx\", undefined,(d)=>{\r\n        d.appliableTo = 'Any';\r\n        d.subViews = {[\"Sample-fake-subView\"]: 3.5};\r\n        d.oclUpdateCondition = '(view: LViewElement) => { return false; } <--- as a string'\r\n        d.defaultVSize = new GraphSize(5,5,5,5);\r\n        d.palette = {\r\n            \"color\": {type:'color', value: [{r:0, g:0, b:0, a:0}]} as PaletteControl,\r\n            \"number\": {type:'number', value: 4, unit: 'px'} as NumberControl,\r\n            \"text\": {type:'text', value: 'stringa'} as StringControl,\r\n            \"path\": {type:'path', value: 'M 00 L 1 1 Z', x: '5', y: '10', options: [{k: 'optionnale', v:'option path M 0 0 L 5 5 Z'}]} as PathControl,\r\n        };\r\n        d.events = {[\"function name\"]: \"function body\"};\r\n        d.bendingMode = EdgeBendingMode.Bezier_QT;\r\n        d.edgeGapMode = EdgeGapMode.gap;\r\n        d.size = {[\"node or model Pointer\"]: new GraphSize(5,5,5,5)};\r\n        d.edgeStartOffset = new GraphPoint(5,5);\r\n        d.edgeEndOffset = new GraphPoint(5,5);\r\n        d.edgePointCoordMode = CoordinateMode.relativePercent;\r\n        d.edgeHeadSize = new GraphPoint(5,5);\r\n        d.edgeTailSize = new GraphPoint(5,5);\r\n    }, true, 'DViewElement');\r\n\r\n\r\n\r\n    return store.getState();\r\n}\r\n*/","map":{"version":3,"names":["Log","RuntimeAccessible","VersionFixer","_dec","_class","_class2","help","console","clear","i","log","concat","prefix","get_highestversion","highestVersion","setup","versionAdapters","errormsg","k","staticKeys","instanceKeys","Object","getOwnPropertyNames","prototype","allKeys","froms","tos","split","exDev","length","from","to","isNaN","Math","max","n","f","update","s","version","date","conversionList","prevVer","currVer","singleton","adapers","curr","entry","call","d","ptr","idlookup","0 -> 2.1","2.1 -> 2.2","2.2 -> 2.201","c","classs","map","p","isSingleton","sealed","final","rootable","undefined","values","className","id","isCrossReference","viewelements","father","viewpoint","viewpoints","cssIsGlobal","projects","favorite","description","references","composition","aggregation","containment","models","dependencies","attributes","derived","derived_write","derived_read","cname"],"sources":["C:/0Programmi/Dev/projects/frontend/jjodel/frontend/src/redux/VersionFixer.ts"],"sourcesContent":["import {\r\n    CoordinateMode,\r\n    Defaults,\r\n    Dictionary, DocString, DPointerTargetable, DReference,\r\n    DState, DStructuralFeature,\r\n    DViewElement,\r\n    EdgeBendingMode,\r\n    EdgeGapMode,\r\n    GObject,\r\n    GraphPoint,\r\n    GraphSize, LClass,\r\n    Log, LPointerTargetable, LState, Pointer, RuntimeAccessible, RuntimeAccessibleClass, store,\r\n    U\r\n} from \"../joiner\";\r\nimport {NumberControl, PaletteControl, PathControl, StringControl} from \"../view/viewElement/view\";\r\n\r\n/*\r\n                                    TODO for every update: check the VersionFixer.help() function\r\n*/\r\n\r\n@RuntimeAccessible('VersionFixer')\r\nexport class VersionFixer {\r\n    public static cname = 'VersionFixer';\r\n    private static versionAdapters: Dictionary<number/*version*/, {n: number, f:(s: DState)=>DState}> = VersionFixer.setup();\r\n    private static highestVersion: number = 0; // automatically updated from updater function names\r\n    private static prefix: string = '__jodel_versioning_';\r\n    public static help(){\r\n        console.clear();\r\n        let i: number  = 1;\r\n\r\n        console.log(`\r\nBefore deploying a new version you should:\r\n\r\n${i++}) Update changelog\r\n\r\n${i++}) make a separate build subfolder (so you can switch versions)\r\n\r\n${i++}) build a new empty versioning function with signature like: private ['2.1 -> 2.3'](s: DState): DState\r\n        fill this function in a way that translates from the state shape of the old version, to the state shape of the new one\r\n   \r\n        `);\r\n\r\n\r\n\r\n        // DEPRECATED stuff\r\n        false && console.log(`\r\nBefore deploying a new version you should:\r\n\r\n${i++}?) ONLY IF IT'S FIRST TIME;\r\n   run DState.registerFirstTimeOnly() in the deploy version and export the localStorage variables starting with ${VersionFixer.prefix} to the dev version.\r\n   or call it in dev version after having temporarly undone the pending updates if possible, otherwise next steps might fail.\r\n   \r\n${i++}?) ONLY IF there are entirely new kinds of D-objects or optional new sub-structures in D-objects (like View.palette), update buildVersionSignature() method\r\n \r\n\r\n${i++}) build a new empty versioning function with signature: private ['2.1 -> 2.3'](s: DState): DState\r\n\r\n${i++}) in DState update DState.version.n (leave date and conversionList unchanged)\r\n\r\n${i++}) open a new empty project (no models no metamodels)\r\n   to find out what changed in the state between version without risking human error, i made an automatic detection.\r\n   call VersionFixer.checkVersionChanges() in browser console to see what changed need conversion in the function (i would save the result as comment inside the func)\r\n\r\n${i++}) fill the empty function of step (1), in a way that translates from the state shape of the old version, to the state shape of the new one\r\n\r\n${i++}) only after the transition function is complete, call VersionFixer.registerNewVersion();\r\n   it will both validate the version update function and store the new version as baseline.\r\n   (needs to be done last because checkVersionChanges will stop working until a new version is ready)\r\n   \r\nBEWARE: this approach cannot detect changes of valid values where the type did not change. eg if view.appliableTo = 'string' change his valid string values but not his type;\r\neverytime you put hands into a D-Object shape or valid values, you should document them to be able to write a conversion function later on.\r\n        `);\r\n    }\r\n    public static get_highestversion(): number{\r\n        if (VersionFixer.highestVersion === 0) VersionFixer.setup();\r\n        return VersionFixer.highestVersion;\r\n    }\r\n\r\n    private static setup(): (typeof VersionFixer)[\"versionAdapters\"]{\r\n        VersionFixer.versionAdapters = {};\r\n        const errormsg = (k: string)=>\"Version auto-updater have a updater registered incorrectly: \\\"\" + k + \"\\\", please notify the developers.\"\r\n        let staticKeys = [] as string[];// no need for them Object.getOwnPropertyNames(VersionFixer);\r\n        let instanceKeys = Object.getOwnPropertyNames(VersionFixer.prototype); // object.keys does not list not-enumarable stuff (like class funcs)\r\n        let allKeys = [...staticKeys, ...instanceKeys];\r\n        for (let k of allKeys){\r\n            switch(k){\r\n                case 'constructor': case 'd': case 'className':\r\n                case 'prefix': case 'highestVersion': case 'versionAdapters':\r\n                case 'get_highestversion':\r\n                case 'staticClassName': case 'cname': case 'subclasses':\r\n                case 'help': case 'setup': case 'update': continue;\r\n            }\r\n            let [froms, tos] = k.split(' -> ');\r\n            Log.exDev(!froms?.length || !tos?.length, errormsg(k));\r\n            let from = +froms; let to = +tos;\r\n            Log.exDev(isNaN(from) || isNaN(to), errormsg(k));\r\n            Log.exDev(!!VersionFixer.versionAdapters[from], \"duplicate version adapter from \\\"\"+from+\"\\\", please notify the developers.\")\r\n            VersionFixer.highestVersion = Math.max(VersionFixer.highestVersion, to);\r\n            VersionFixer.versionAdapters[from] = {n:to, f: (VersionFixer.prototype as any)[k]}\r\n        }\r\n        return VersionFixer.versionAdapters;\r\n    }\r\n\r\n    public static update(s: DState): DState{\r\n        if (!VersionFixer.versionAdapters) VersionFixer.setup();\r\n        if (!s.version) s.version = {n: 2.1, date:\"_reconverted\", conversionList:[0]};\r\n        let prevVer = s.version.n || 0;\r\n        let currVer = prevVer;\r\n        let singleton = new VersionFixer();\r\n        while (currVer !== VersionFixer.highestVersion) {\r\n            Log.exDev(!VersionFixer.versionAdapters[currVer], \"missing version adapter from \\\"\"+ currVer+\"\\\", please notify the developers.\",\r\n                {adapers: VersionFixer.versionAdapters, curr: VersionFixer.versionAdapters[currVer]});\r\n            console.log('versionfixer update pre', {prevVer, currVer, entry: VersionFixer.versionAdapters[currVer]});\r\n            let {n, f} = VersionFixer.versionAdapters[currVer];\r\n            s.version.conversionList = [...s.version.conversionList, currVer];\r\n            s = f.call(singleton, s);\r\n            currVer = s.version.n = n || 0;\r\n            console.log('versionfixer update post', {prevVer, currVer, n});\r\n            //Log.exDev(currVer !== n, \"version updater updated to incorrect target versionn \\\"\"+prevVer+\"\\\" -> \\\"\"+n+\"\\\" , please notify the developers.\");\r\n            Log.exDev(currVer <= prevVer, \"version updater found loop at version \\\"\"+currVer+\"\\\", please notify the developers.\");\r\n            prevVer = currVer;\r\n        }\r\n        return s;\r\n    }\r\n\r\n\r\n    private d<D extends DPointerTargetable, L extends LPointerTargetable>(ptr: Pointer<D>, s: DState): D{\r\n        return s.idlookup[ptr] as any;\r\n        // {n}\r\n    }\r\n    private ['0 -> 2.1'](s: DState): DState {\r\n        s.version = {n: 2.1, date:\"_reconverted\", conversionList:[0]};\r\n        return s;\r\n    }\r\n    private ['2.1 -> 2.2'](s: DState): void {\r\n\r\n    }\r\n    private ['2.2 -> 2.201'](s: DState): DState {\r\n        // let ls: LState = LPointerTargetable.from(s); nope, avoid L-objects. actions would fire in present state instead of in parameter state\r\n        for (let c of (s.classs).map(p=> this.d(p, s))) {\r\n            c.isSingleton = !!c.isSingleton; // booleanize the undefined\r\n            c.sealed = [];\r\n            c.final = false;\r\n            c.rootable = undefined;\r\n        }\r\n        for (let c of Object.values(s.idlookup) as any[]) { if (c?.className && c.id && c.isCrossReference === undefined) c.isCrossReference = false; }\r\n        for (let c of (s.viewelements).map(p=> this.d(p, s))) { c.father = c.viewpoint; }\r\n        for (let c of (s.viewpoints).map(p=> this.d(p, s))) { c.cssIsGlobal = true; }\r\n        for (let c of (s.projects).map(p=> this.d(p, s))) { c.favorite = {}; c.description = ''; }\r\n        for (let c of (s.references).map(p=> this.d(p, s))) { if (c.composition === undefined) c.aggregation = !(c.composition = !!(c as any).containment); }\r\n        for (let c of (s.models).map(p=> this.d(p, s))) { if (c.dependencies === undefined) c.dependencies = []; }\r\n        for (let c of (s.attributes).map(p=> this.d(p, s))) {\r\n            c.derived = !!c.derived;\r\n            c.derived_write = undefined; // c.derived ? '' : undefined;\r\n            c.derived_read = undefined; // c.derived ? '' : undefined;\r\n        }\r\n\r\n        return s;\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n//deprecated stuff\r\n\r\n\r\n\r\n/*\r\npublic static checkVersionChanges(): GObject{\r\n    let lastVerName = localStorage.getItem(VersionFixer.prefix+'last');\r\n    let lastVerState = localStorage.getItem(VersionFixer.prefix+lastVerName);\r\n    let lastVersionSignature = JSON.parse(lastVerState || '{not:\"found\"}');\r\n    let newVersionSignature = this.buildVersionSignature();\r\n    return VersionFixer.checkVersionChanges_inner(lastVersionSignature, newVersionSignature);\r\n}\r\npublic static checkVersionChanges_inner(s1: DState, s2:DState): GObject{ return U.objectDelta(s1, s2, true); }\r\npublic static registerFirstTimeOnly(): void {\r\n    let newVersionSignature = VersionFixer.buildVersionSignature();\r\n    localStorage.setItem(VersionFixer.prefix+'last', ''+newVersionSignature.version.n);\r\n    localStorage.setItem(VersionFixer.prefix+''+newVersionSignature.version.n, JSON.stringify(newVersionSignature));\r\n}\r\n\r\npublic static registerNewVersion(): boolean {\r\n    let lastVerName = localStorage.getItem(VersionFixer.prefix+'last');\r\n    let prevVersionSignature: DState = JSON.parse(localStorage.getItem(VersionFixer.prefix+lastVerName) || '{not:\"found\"}') as any;\r\n    let newVersionSignature = VersionFixer.buildVersionSignature();\r\n    let updatedVersionSignature = this.update(prevVersionSignature);\r\n    let versionDiff: GObject = VersionFixer.checkVersionChanges_inner(updatedVersionSignature, newVersionSignature);\r\n    if (Object.keys(versionDiff).length !== 0) {\r\n        console.log(\"failed to save new version, the conversion function is not updating state properly.\",\r\n            {versionDiff, prevVersionSignature, newVersionSignature, updatedVersionSignature});\r\n        return false;\r\n    }\r\n    localStorage.setItem(VersionFixer.prefix+'last', ''+newVersionSignature.version.n);\r\n    localStorage.setItem(VersionFixer.prefix+''+newVersionSignature.version.n, JSON.stringify(newVersionSignature));\r\n    return true;\r\n}\r\nprivate static buildVersionSignature(): DState {\r\n    // purpose: save in state 1 of each D-objects with all the possible sub-objects in every possible structure shape\r\n    // values can be dummy but syntactical valid\r\n    //DState.new(); nope, i'm using current state, just call it from an empty project with no models.\r\n    DViewElement.new2(\"View\", \"jsx\", undefined,(d)=>{\r\n        d.appliableTo = 'Any';\r\n        d.subViews = {[\"Sample-fake-subView\"]: 3.5};\r\n        d.oclUpdateCondition = '(view: LViewElement) => { return false; } <--- as a string'\r\n        d.defaultVSize = new GraphSize(5,5,5,5);\r\n        d.palette = {\r\n            \"color\": {type:'color', value: [{r:0, g:0, b:0, a:0}]} as PaletteControl,\r\n            \"number\": {type:'number', value: 4, unit: 'px'} as NumberControl,\r\n            \"text\": {type:'text', value: 'stringa'} as StringControl,\r\n            \"path\": {type:'path', value: 'M 00 L 1 1 Z', x: '5', y: '10', options: [{k: 'optionnale', v:'option path M 0 0 L 5 5 Z'}]} as PathControl,\r\n        };\r\n        d.events = {[\"function name\"]: \"function body\"};\r\n        d.bendingMode = EdgeBendingMode.Bezier_QT;\r\n        d.edgeGapMode = EdgeGapMode.gap;\r\n        d.size = {[\"node or model Pointer\"]: new GraphSize(5,5,5,5)};\r\n        d.edgeStartOffset = new GraphPoint(5,5);\r\n        d.edgeEndOffset = new GraphPoint(5,5);\r\n        d.edgePointCoordMode = CoordinateMode.relativePercent;\r\n        d.edgeHeadSize = new GraphPoint(5,5);\r\n        d.edgeTailSize = new GraphPoint(5,5);\r\n    }, true, 'DViewElement');\r\n\r\n\r\n\r\n    return store.getState();\r\n}\r\n*/"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}