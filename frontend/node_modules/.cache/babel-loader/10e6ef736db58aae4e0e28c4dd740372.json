{"ast":null,"code":"import{Log,LPointerTargetable,SetFieldAction,U,SetRootFieldAction,TRANSACTION}from'../joiner';export class Dummy{static get_dependencies(context){const data=context.data;const dependencies=[];const ret=()=>{for(let pointedBy of data.pointedBy){const raw=pointedBy.source.split('.');let root=raw[0];const obj=raw[1]||'';let field=raw[2]||'';// Delete chars from end that are not in [azAZ].\nconst regex=/[^a-zA-Z]+$/;root=root.replace(regex,'');field=field.replace(regex,'');// damiano: this is likely to cause a bug for sure somewhere when a key ends with \"s\" but is not an array. keep in mind when naming variables.\nlet op=field&&field.endsWith('s')?'-=':'';if(!field&&root.endsWith('s'))op='-=';const dependency={root:root,obj,field:field,op};if(!dependencies.includes(dependency))dependencies.push(dependency);}return dependencies;};return ret;}static get_delete(thiss,context){const lData=context.proxyObject;const dData=context.data;const dependencies=Dummy.get_dependencies(context)();const ret=()=>{var _project;SetRootFieldAction.new('_lastSelected',undefined,'');const dataID=dData.id;if(dData.id.indexOf('Pointer_View')!==-1)return;// cannot delete default views/viewpoints\nif(dData.__readonly)return;for(let child of lData.children){child.delete();// todo: if a m1-dvalue which conforms to a m2-reference with \"containment\" is deleted, need to delete also target.\n// maybe better to do through override?\n// child.node?.delete();\n}// those 2 are exceptions because the pointer is a key in an object instead of a normal value as a field or array member.\nswitch(dData.className){case'DViewElement':SetFieldAction.new(dData.father,'subViews',dataID,'-=',false);break;case'DViewPoint':let projectid=lData===null||lData===void 0?void 0:(_project=lData.project)===null||_project===void 0?void 0:_project.id;Log.eDevv('cannot find project id while deleting a viewpoint',{dData,context,dependencies});if(projectid)SetFieldAction.new(projectid,'viewpoints',dataID,'-=',false);break;}for(let dependency of dependencies){const root=dependency.root;if(root!=='idlookup'){SetRootFieldAction.new(root,dataID,'-=',false);continue;}const pointer=dependency.obj;// the pointing element (delete a DClass => DAttribute)\nconst field=dependency.field;const lObj=LPointerTargetable.wrap(pointer);if(!pointer||!lObj)continue;const dObj=lObj.__raw;switch(field){/* on '-=' pointedby would be removed from the element we are deleting, so it is irrelevant */default:Log.eDevv('Unexpected case in delete:',field,lData);break;case'metamodels':console.log('mm filter',{newmm:dObj.metamodels.filter(id=>id!==dataID),oldmm:dObj.metamodels,dataID});lObj.metamodels=dObj.metamodels.filter(id=>id!==dataID);break;case'dependencies':lObj.dependencies=dObj.dependencies.filter(id=>id!==dataID);break;case'values':lObj.values=dObj.values.filter(o=>o!==dataID);break;case'type':switch(dObj.className){case'DAttribute':lObj.type='Pointer_ESTRING';break;case'DReference':case'DOperation':// would be nice to set dObj.extends[0] instead but i cannot tell if it was deleted too.\n// dobj.father instead is safe as even if it's deleted it does not matter as it will delete the feature together\nlObj.type=dObj.father;break;}break;case'model':if(dObj.className==='DPackage'){lObj.father[field]=lObj.father.__raw[field].filter(id=>id!=dataID);continue;}else{/* Node is deleted in nodes.delete() */continue;}case'packages':case'subpackages':case'classifiers':case'enumerators':case'literals':case'classes':case'attributes':case'references':case'operations':case'parameters':case'features':case'instances':case'objects':lObj[field]=dObj[field].filter(id=>id!=dataID);continue;case'instanceof':lObj.delete();continue;/* No operations required (children) */case'father':case'subElements':case'annotations':break;}/*\r\n                if ((root === 'idlookup') && obj && field) {\r\n                    console.log('Delete', `SetFieldAction.new('${obj}', '${field}', '${val}', '${op}');`, {dependency});\r\n                    SetFieldAction.new(obj, field, val, op, false);\r\n                } else {\r\n                    console.log('Delete', `SetRootFieldAction.new('${root}', '${val}', '${op}');`);\r\n                    SetRootFieldAction.new(root, val, op, false);\r\n                }\r\n                */}if(lData.nodes)lData.nodes.map(node=>node.delete());SetRootFieldAction.new('ELEMENT_DELETED',dataID,'+=',false);// here no need to IsPointer because it only affects Transient stuff\nU.sleep(1).then(()=>SetRootFieldAction.new(\"idlookup.\".concat(dataID),undefined,'',false));// DeleteElementAction.new(data.id);\n};return()=>TRANSACTION(ret);}}","map":{"version":3,"names":["Log","LPointerTargetable","SetFieldAction","U","SetRootFieldAction","TRANSACTION","Dummy","get_dependencies","context","data","dependencies","ret","pointedBy","raw","source","split","root","obj","field","regex","replace","op","endsWith","dependency","includes","push","get_delete","thiss","lData","proxyObject","dData","_project","new","undefined","dataID","id","indexOf","__readonly","child","children","delete","className","father","projectid","project","eDevv","pointer","lObj","wrap","dObj","__raw","console","log","newmm","metamodels","filter","oldmm","values","o","type","nodes","map","node","sleep","then","concat"],"sources":["C:/0Programmi/Dev/projects/frontend/jjodel/frontend/src/common/Dummy.ts"],"sourcesContent":["import {\r\n    DeleteElementAction,\r\n    DState,\r\n    GObject,\r\n    Log,\r\n    LPointerTargetable, Pointer,\r\n    SetFieldAction, U,\r\n    SetRootFieldAction, TRANSACTION, DPointerTargetable, LViewPoint\r\n} from '../joiner';\r\nimport {Dependency} from \"../joiner/types\";\r\n\r\nexport class Dummy {\r\n    protected static get_dependencies(context: any): () => Dependency[] {\r\n        const data = context.data;\r\n        const dependencies: Dependency[] = [];\r\n        const ret = () => {\r\n            for (let pointedBy of data.pointedBy) {\r\n                const raw = pointedBy.source.split('.');\r\n                let root = raw[0];\r\n                const obj = raw[1] || '';\r\n                let field = raw[2] || '';\r\n\r\n                // Delete chars from end that are not in [azAZ].\r\n                const regex = /[^a-zA-Z]+$/;\r\n                root = root.replace(regex, '');\r\n                field = field.replace(regex, '');\r\n                // damiano: this is likely to cause a bug for sure somewhere when a key ends with \"s\" but is not an array. keep in mind when naming variables.\r\n                let op: ''|'-=' = (field && field.endsWith('s')) ? '-=' : '';\r\n                if(!field && root.endsWith('s')) op = '-=';\r\n\r\n                const dependency: Dependency = {root: root  as keyof DState, obj, field: field as keyof DPointerTargetable, op};\r\n                if(!dependencies.includes(dependency)) dependencies.push(dependency);\r\n            }\r\n            return dependencies\r\n        }\r\n        return ret;\r\n    }\r\n    static get_delete(thiss: any, context: any): () => void {\r\n        const lData: LPointerTargetable & GObject = context.proxyObject;\r\n        const dData = context.data;\r\n        const dependencies = Dummy.get_dependencies(context)();\r\n\r\n        const ret = () => {\r\n            SetRootFieldAction.new('_lastSelected', undefined, '');\r\n            const dataID = dData.id as any;\r\n            if (dData.id.indexOf('Pointer_View') !== -1 ) return; // cannot delete default views/viewpoints\r\n            if (dData.__readonly) return;\r\n            for (let child of lData.children) {\r\n                child.delete();\r\n                // todo: if a m1-dvalue which conforms to a m2-reference with \"containment\" is deleted, need to delete also target.\r\n                // maybe better to do through override?\r\n                // child.node?.delete();\r\n            }\r\n\r\n            // those 2 are exceptions because the pointer is a key in an object instead of a normal value as a field or array member.\r\n            switch (dData.className) {\r\n                case 'DViewElement':\r\n                    SetFieldAction.new(dData.father, 'subViews', dataID, '-=', false);\r\n                    break;\r\n                case 'DViewPoint':\r\n                    let projectid = (lData as LViewPoint)?.project?.id;\r\n                    Log.eDevv('cannot find project id while deleting a viewpoint', {dData, context, dependencies});\r\n                    if (projectid) SetFieldAction.new(projectid, 'viewpoints', dataID, '-=', false);\r\n                    break;\r\n            }\r\n\r\n            for (let dependency of dependencies) {\r\n                const root: keyof DState = dependency.root;\r\n                if(root !== 'idlookup') {\r\n                    SetRootFieldAction.new(root, dataID, '-=', false);\r\n                    continue;\r\n                }\r\n                const pointer: Pointer<any>|null = dependency.obj; // the pointing element (delete a DClass => DAttribute)\r\n                const field = dependency.field;\r\n                const lObj: any = LPointerTargetable.wrap(pointer);\r\n                if (!pointer || !lObj) continue;\r\n                const dObj: any = lObj.__raw;\r\n                switch (field as string) {\r\n                    /* on '-=' pointedby would be removed from the element we are deleting, so it is irrelevant */\r\n                    default:\r\n                        Log.eDevv('Unexpected case in delete:', field, lData);\r\n                        break;\r\n                    case 'metamodels':\r\n                        console.log('mm filter', {newmm:dObj.metamodels.filter((id: Pointer) => id !== dataID), oldmm:dObj.metamodels, dataID})\r\n                        lObj.metamodels = dObj.metamodels.filter((id: Pointer) => id !== dataID);\r\n                        break;\r\n                    case 'dependencies':\r\n                        lObj.dependencies = dObj.dependencies.filter((id: Pointer) => id !== dataID);\r\n                        break;\r\n                    case 'values':\r\n                        lObj.values = dObj.values.filter((o: any) => o !== dataID);\r\n                        break;\r\n                    case 'type':\r\n                        switch (dObj.className) {\r\n                            case 'DAttribute': lObj.type = 'Pointer_ESTRING'; break;\r\n                            case 'DReference': case 'DOperation':\r\n                                // would be nice to set dObj.extends[0] instead but i cannot tell if it was deleted too.\r\n                                // dobj.father instead is safe as even if it's deleted it does not matter as it will delete the feature together\r\n                                lObj.type = dObj.father;\r\n                                break;\r\n                        }\r\n                        break;\r\n                    case 'model':\r\n                        if(dObj.className === 'DPackage') {\r\n                            lObj.father[field] = lObj.father.__raw[field].filter((id: any) => id != dataID);\r\n                            continue;\r\n                        } else {\r\n                            /* Node is deleted in nodes.delete() */\r\n                            continue;\r\n                        }\r\n                    case 'packages':\r\n                    case 'subpackages':\r\n                    case 'classifiers':\r\n                    case 'enumerators':\r\n                    case 'literals':\r\n                    case 'classes':\r\n                    case 'attributes':\r\n                    case 'references':\r\n                    case 'operations':\r\n                    case 'parameters':\r\n                    case 'features':\r\n                    case 'instances':\r\n                    case 'objects':\r\n                        lObj[field] = dObj[field].filter((id: any) => id != dataID);\r\n                        continue;\r\n                    case 'instanceof':\r\n                        lObj.delete();\r\n                        continue;\r\n                    /* No operations required (children) */\r\n                    case 'father':\r\n                    case 'subElements':\r\n                    case 'annotations':\r\n                        break;\r\n                }\r\n                /*\r\n                if ((root === 'idlookup') && obj && field) {\r\n                    console.log('Delete', `SetFieldAction.new('${obj}', '${field}', '${val}', '${op}');`, {dependency});\r\n                    SetFieldAction.new(obj, field, val, op, false);\r\n                } else {\r\n                    console.log('Delete', `SetRootFieldAction.new('${root}', '${val}', '${op}');`);\r\n                    SetRootFieldAction.new(root, val, op, false);\r\n                }\r\n                */\r\n            }\r\n            if (lData.nodes) lData.nodes.map((node: any) => node.delete());\r\n            SetRootFieldAction.new('ELEMENT_DELETED', dataID, '+=', false); // here no need to IsPointer because it only affects Transient stuff\r\n            U.sleep(1).then(() => SetRootFieldAction.new(`idlookup.${dataID}`, undefined, '', false));\r\n            // DeleteElementAction.new(data.id);\r\n        };\r\n        return () => TRANSACTION(ret);\r\n    }\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}