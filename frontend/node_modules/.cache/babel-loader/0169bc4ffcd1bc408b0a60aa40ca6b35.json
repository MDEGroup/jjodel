{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.InvariantExpression = void 0;\nvar Expression_1 = require(\"./Expression\");\n/**\n * @oclSpecification\n * The OCL expression can be part of an Invariant which is a Constraint stereotyped as an «invariant».\n * When the invariant is associated with a Classifier, the latter is referred to as a “type” in this clause.\n * An OCL expression is an invariant of the type and must be true for all instances of that type at any time.\n * (Note that all OCL expressions that express invariants are of the type Boolean.)\n *\n * @oclExample context Person inv:\n *     self.age > 0\n */\nvar InvariantExpression = /** @class */function (_super) {\n  __extends(InvariantExpression, _super);\n  function InvariantExpression(oclExpression, name) {\n    var _this = _super.call(this) || this;\n    _this.name = name || 'anonymous';\n    _this.definition = oclExpression;\n    return _this;\n  }\n  InvariantExpression.prototype.getName = function () {\n    return this.name;\n  };\n  InvariantExpression.prototype.getDefinition = function () {\n    return this.definition;\n  };\n  InvariantExpression.prototype.evaluate = function (visitor, localVariables) {\n    var evaluationResult = this.getDefinition().evaluate(visitor, localVariables);\n    return evaluationResult === true;\n  };\n  return InvariantExpression;\n}(Expression_1.Expression);\nexports.InvariantExpression = InvariantExpression;","map":{"version":3,"names":["Expression_1","require","InvariantExpression","_super","__extends","oclExpression","name","_this","call","definition","prototype","getName","getDefinition","evaluate","visitor","localVariables","evaluationResult","Expression","exports"],"sources":["../../../lib/components/expressions/InvariantExpression.ts"],"sourcesContent":[null],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;AAEA,IAAAA,YAAA,GAAAC,OAAA;AAEA;;;;;;;;;;AAUA,IAAAC,mBAAA,0BAAAC,MAAA;EAAyCC,SAAA,CAAAF,mBAAA,EAAAC,MAAA;EAIrC,SAAAD,oBAAYG,aAAa,EAAEC,IAAI;IAA/B,IAAAC,KAAA,GACIJ,MAAA,CAAAK,IAAA,MAAO;IACPD,KAAI,CAACD,IAAI,GAAGA,IAAI,IAAI,WAAW;IAC/BC,KAAI,CAACE,UAAU,GAAGJ,aAAa;;EACnC;EAEAH,mBAAA,CAAAQ,SAAA,CAAAC,OAAO,GAAP;IACI,OAAO,IAAI,CAACL,IAAI;EACpB,CAAC;EAEDJ,mBAAA,CAAAQ,SAAA,CAAAE,aAAa,GAAb;IACI,OAAO,IAAI,CAACH,UAAU;EAC1B,CAAC;EAEDP,mBAAA,CAAAQ,SAAA,CAAAG,QAAQ,GAAR,UAASC,OAA4B,EAAEC,cAAoB;IACvD,IAAMC,gBAAgB,GAAG,IAAI,CAACJ,aAAa,EAAE,CAACC,QAAQ,CAACC,OAAO,EAAEC,cAAc,CAAC;IAE/E,OAAOC,gBAAgB,KAAK,IAAI;EACpC,CAAC;EACL,OAAAd,mBAAC;AAAD,CAAC,CAvBwCF,YAAA,CAAAiB,UAAU;AAAtCC,OAAA,CAAAhB,mBAAA,GAAAA,mBAAA"},"metadata":{},"sourceType":"script"}