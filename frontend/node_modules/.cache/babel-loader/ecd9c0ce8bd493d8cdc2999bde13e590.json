{"ast":null,"code":"import { Log } from \"../joiner\";\nimport { Uarr } from \"../joiner\";\nconst stringify = require('json-stable-stringify');\nexport class Uobj {\n  // difference react-style. lazy check by === equality field by field. parameters are readonly\n  static objdiff(old, neww) {\n    let includeProto = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    // let ret: GObject = {removed:{}, added:{}, changed:{}};\n    let ret = {\n      removed: {},\n      added: {},\n      changed: {},\n      unchanged: {}\n    };\n    if (!neww && !old) {\n      return ret;\n    }\n    if (!neww) {\n      ret.removed = old;\n      if (!includeProto) {\n        ret.removed = {\n          ...ret.removed,\n          __proto__: {}\n        };\n      }\n      return ret;\n    }\n    if (!old) {\n      ret.added = neww;\n      if (!includeProto) {\n        ret.added = {\n          ...ret.added,\n          __proto__: {}\n        };\n      }\n      return ret;\n    }\n    // let oldkeys: string[] = Object.keys(old); let newkeys: string[] = Object.keys(neww);\n\n    let key;\n    for (key in old) {\n      if (!includeProto && !old.hasOwnProperty(key)) continue;\n      // if (neww[key] === undefined){\n      // if neww have a key with undefined value, it counts (and should) as having that property key defined\n      if (!(key in neww)) {\n        ret.removed[key] = old[key];\n      } else if (neww[key] === old[key]) {\n        ret.unchanged[key] = old[key];\n      } else ret.changed[key] = old[key];\n    }\n    for (let key in neww) {\n      if (!includeProto && !neww.hasOwnProperty(key)) continue;\n      if (!(key in old)) {\n        ret.added[key] = neww[key];\n      }\n    }\n    if (Array.isArray(neww)) {\n      if (neww.length === old.length) {\n        ret.unchanged.length = neww.length;\n      } else {\n        let newb = 'length' in neww;\n        let oldb = 'length' in old;\n        if (newb && !oldb) ret.added.length = neww.length;else if (!newb && oldb) ret.removed.length = neww.length;else ret.changed.length = neww.length;\n      }\n    }\n    return ret;\n  }\n\n  // returns <\"what changed from old to neww\"> and in nested objects recursively\n  // todo: how can i tell at what point it's the fina lvalue (might be a nestedobj) and up to when it's a delta to follow and unroll?   using __isAdelta:true ?\n  // NB: this returns the delta that generates the future. if you want the delta that generate the past one, invert parameter order.\n  static objectDelta(old, neww) {\n    let deep = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    let includeProto = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    let newwobj = neww;\n    let oldobj = old;\n    if (old === neww) return {};\n    let diff = Uobj.objdiff(old, neww, includeProto); // todo: optimize this, remove the 3 loops below and add those directly in Uobj.objdiff(old, neww, ret); writing inside the obj in third parameter\n    console.log('objdiff', {\n      diff,\n      old,\n      neww\n    });\n    let isArr = false;\n    if (typeof neww === 'object' && Array.isArray(neww)) {\n      isArr = true;\n    }\n    let ret = {}; // {__isAdelta:true};\n    for (let key in diff.added) {\n      //if (!includeProto && diff.added.hasOwnProperty(key)) continue;\n      ret[key] = newwobj[key];\n    }\n    for (let key in diff.changed) {\n      let subold = oldobj[key];\n      let subnew = newwobj[key];\n      if (typeof subold === typeof subnew && typeof subold === \"object\") {\n        if (deep) {\n          ret[key] = Uobj.objectDelta(subold, subnew, true, includeProto);\n        } else {\n          ret[key] = subnew;\n          /*if (typeof neww === 'object' && Array.isArray(subnew)) {\r\n              ret[key].length = subnew.length;\r\n              ret[key].__jjObjDiffIsArr = true;\r\n          }*/\n        }\n      } else ret[key] = subnew;\n    }\n    // todo: add to variable naming rules: can't start with \"_-\", like in \"_-keyname\", it means \"keyname\" removed in undo delta\n    let removedprefix = \"\"; // \"_-\";\n    for (let key in diff.removed) {\n      ///if (!includeProto && diff.removed.hasOwnProperty(key)) continue;\n      if (ret[removedprefix + key] === undefined) {\n        console.log('undef empty problem', {\n          r: diff.removed,\n          val: ret[removedprefix + key],\n          pkey: removedprefix + key,\n          key,\n          ret,\n          old,\n          neww\n        });\n      }\n      if (key in neww) ret[removedprefix + key] = undefined;else ret[removedprefix + key] = '__jjObjDiffEmptyElem';\n    } //newwobj[key]; }\n    // console.log(\"objdiff\", {old, neww, diff, ret});\n    if (isArr) {\n      ret.length = neww.length;\n      ret.__jjObjDiffIsArr = true;\n    }\n    return ret;\n  }\n  static applyObjectDelta(statelevel, deltalevel) {\n    let inplace = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    let asserteq = arguments.length > 3 ? arguments[3] : undefined;\n    let oldState = {\n      ...statelevel\n    }; // just for debug\n    if (typeof statelevel !== 'object' || !statelevel) return statelevel;\n    let targetIsArr = deltalevel.__jjObjDiffIsArr || Array.isArray(deltalevel);\n    if (!inplace) statelevel = Array.isArray(statelevel) ? Uarr.arrayShallowCopy(statelevel) : {\n      ...statelevel\n    }; // NB: [ ...{obj} ] is invalid, but {...[]} is valid, careful\n    else if (targetIsArr && !Array.isArray(statelevel)) statelevel = Uarr.arrayShallowCopy(statelevel); // forced to ignore inplace requirement due to change of type (obj -> arr)\n\n    // statelevel = {...statelevel}; not working if i do it here, just a new var. first time copy id done in caller func undo(). recursive copies are done before recursive step\n    for (let key in deltalevel) {\n      let delta = deltalevel[key];\n      // console.log(\"undoing\", {delta, key, deltalevel, statelevel})\n      if (key.indexOf(\"_-\") === 0) {\n        delete statelevel[key.substring(2)];\n        continue;\n      } // ????????????????????????????????????? todo: check\n      if (key === '__jjObjDiffIsArr') continue; // the key is the string, the val is true\n      if (deltalevel[key] === '__jjObjDiffEmptyElem') {\n        // the key is the index,the  val is the string\n        delete statelevel[key];\n        continue;\n      }\n      if (typeof delta === \"object\") {\n        // if (Uobj.isObject(delta, false, false, true)) {\n        // if (!inplace) statelevel[key] = Array.isArray(delta) ? Uarr.arrayShallowCopy(statelevel[key]) : {...statelevel[key]};\n        // console.log('handling ', {key});\n        statelevel[key] = Uobj.applyObjectDelta(statelevel[key], deltalevel[key], inplace, asserteq === null || asserteq === void 0 ? void 0 : asserteq[key]);\n      } else {\n        statelevel[key] = delta;\n      }\n    }\n    let old = statelevel;\n    if (targetIsArr) {\n      statelevel = [];\n      for (let k in old) {\n        if (!old.hasOwnProperty(k)) continue;\n        statelevel[k] = old[k]; // it takes array custom keys\n      }\n\n      //delete statelevel.__jjObjDiffIsArr;\n      statelevel.length = old.length;\n    }\n    if (asserteq) {\n      let as = stringify(asserteq);\n      let rs = stringify(statelevel);\n      Log.eDev(as !== rs, 'error in Uobj.diff, UObj.delta or UObj.patch, assertion failed', {\n        oldState,\n        deltalevel,\n        ret: statelevel,\n        asserteq,\n        rs,\n        as,\n        old,\n        targetIsArr\n      });\n    }\n    return statelevel;\n  }\n}","map":{"version":3,"names":["Log","Uarr","stringify","require","Uobj","objdiff","old","neww","includeProto","arguments","length","undefined","ret","removed","added","changed","unchanged","__proto__","key","hasOwnProperty","Array","isArray","newb","oldb","objectDelta","deep","newwobj","oldobj","diff","console","log","isArr","subold","subnew","removedprefix","r","val","pkey","__jjObjDiffIsArr","applyObjectDelta","statelevel","deltalevel","inplace","asserteq","oldState","targetIsArr","arrayShallowCopy","delta","indexOf","substring","k","as","rs","eDev"],"sources":["C:/0Programmi/Dev/projects/frontend/jjodel/frontend/src/common/UObj.ts"],"sourcesContent":["import {GObject, Log, PointedBy} from \"../joiner\";\r\nimport {U, Uarr} from \"../joiner\";\r\nconst stringify = require('json-stable-stringify');\r\n\r\nexport class Uobj {\r\n\r\n    // difference react-style. lazy check by === equality field by field. parameters are readonly\r\n    public static objdiff<T extends GObject>(old:T, neww: T, includeProto: boolean = false): {removed: Partial<T>, added: Partial<T>, changed: Partial<T>, unchanged: Partial<T>} {\r\n        // let ret: GObject = {removed:{}, added:{}, changed:{}};\r\n        let ret: {removed: Partial<T>, added: Partial<T>, changed: Partial<T>, unchanged: Partial<T>}  = {removed:{}, added:{}, changed:{}, unchanged: {}};\r\n        if (!neww && !old) { return ret; }\r\n        if (!neww) {\r\n            ret.removed = old;\r\n            if (!includeProto){\r\n                ret.removed = {...ret.removed, __proto__:{}};\r\n            }\r\n            return ret;\r\n        }\r\n        if (!old) {\r\n            ret.added = neww;\r\n            if (!includeProto) {\r\n                ret.added = {...ret.added, __proto__:{}};\r\n            }\r\n            return ret;\r\n        }\r\n        // let oldkeys: string[] = Object.keys(old); let newkeys: string[] = Object.keys(neww);\r\n\r\n        let key: any;\r\n        for (key in old) {\r\n            if (!includeProto && !old.hasOwnProperty(key)) continue;\r\n            // if (neww[key] === undefined){\r\n            // if neww have a key with undefined value, it counts (and should) as having that property key defined\r\n            if (!(key in neww)){ (ret.removed as GObject)[key] = old[key]; }\r\n            else if (neww[key] === old[key]) { (ret.unchanged as GObject)[key] = old[key] }\r\n            else (ret.changed as GObject)[key] = old[key];\r\n        }\r\n        for (let key in neww) {\r\n            if (!includeProto && !neww.hasOwnProperty(key)) continue;\r\n            if (!(key in old)){ (ret.added as GObject)[key] = neww[key]; }\r\n        }\r\n        if (Array.isArray(neww)) {\r\n            if (neww.length === old.length) { (ret.unchanged as GObject).length = neww.length; }\r\n            else {\r\n                let newb = 'length' in neww;\r\n                let oldb = 'length' in old;\r\n                if (newb && !oldb) (ret.added as GObject).length = neww.length;\r\n                else if (!newb && oldb) (ret.removed as GObject).length = neww.length;\r\n                else (ret.changed as GObject).length = neww.length;\r\n            }\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    // returns <\"what changed from old to neww\"> and in nested objects recursively\r\n    // todo: how can i tell at what point it's the fina lvalue (might be a nestedobj) and up to when it's a delta to follow and unroll?   using __isAdelta:true ?\r\n    // NB: this returns the delta that generates the future. if you want the delta that generate the past one, invert parameter order.\r\n    public static objectDelta<T extends object>(old: T, neww: T, deep: boolean = true, includeProto: boolean = false): Partial<T>{\r\n        let newwobj: GObject = neww;\r\n        let oldobj: GObject = old;\r\n        if (old === neww) return {};\r\n        let diff = Uobj.objdiff(old, neww, includeProto); // todo: optimize this, remove the 3 loops below and add those directly in Uobj.objdiff(old, neww, ret); writing inside the obj in third parameter\r\n        console.log('objdiff', {diff, old, neww})\r\n        let isArr = false;\r\n        if (typeof neww === 'object' && Array.isArray(neww)) {\r\n            isArr = true;\r\n        }\r\n        let ret: GObject = {}; // {__isAdelta:true};\r\n        for (let key in diff.added) {\r\n            //if (!includeProto && diff.added.hasOwnProperty(key)) continue;\r\n            ret[key] = newwobj[key];\r\n        }\r\n        for (let key in diff.changed) {\r\n            let subold = oldobj[key];\r\n            let subnew = newwobj[key];\r\n            if (typeof subold === typeof subnew && typeof subold === \"object\") {\r\n                if (deep) {\r\n                    ret[key] = Uobj.objectDelta(subold, subnew, true, includeProto)\r\n                }\r\n                else {\r\n                    ret[key] = subnew;\r\n                    /*if (typeof neww === 'object' && Array.isArray(subnew)) {\r\n                        ret[key].length = subnew.length;\r\n                        ret[key].__jjObjDiffIsArr = true;\r\n                    }*/\r\n                }\r\n            }\r\n            else ret[key] = subnew;\r\n        }\r\n        // todo: add to variable naming rules: can't start with \"_-\", like in \"_-keyname\", it means \"keyname\" removed in undo delta\r\n        let removedprefix = \"\"; // \"_-\";\r\n        for (let key in diff.removed) {\r\n            ///if (!includeProto && diff.removed.hasOwnProperty(key)) continue;\r\n            if (ret[removedprefix + key] === undefined) { console.log('undef empty problem', {r:diff.removed, val:ret[removedprefix + key], pkey:removedprefix + key, key, ret, old, neww})}\r\n            if (key in neww) ret[removedprefix + key] = undefined;\r\n            else ret[removedprefix + key] = '__jjObjDiffEmptyElem';\r\n        } //newwobj[key]; }\r\n        // console.log(\"objdiff\", {old, neww, diff, ret});\r\n        if (isArr) {\r\n            ret.length = (neww as GObject).length;\r\n            ret.__jjObjDiffIsArr = true;\r\n        }\r\n        return ret as Partial<T>;\r\n    }\r\n\r\n\r\n    public static applyObjectDelta(statelevel: GObject, deltalevel: GObject, inplace: boolean = false, asserteq?: GObject): GObject {\r\n        let oldState = {...statelevel}; // just for debug\r\n        if (typeof statelevel !== 'object' || !statelevel) return statelevel;\r\n        let targetIsArr = deltalevel.__jjObjDiffIsArr || Array.isArray(deltalevel);\r\n        if (!inplace) statelevel = Array.isArray(statelevel) ? Uarr.arrayShallowCopy(statelevel) : {...statelevel}; // NB: [ ...{obj} ] is invalid, but {...[]} is valid, careful\r\n        else if (targetIsArr && !Array.isArray(statelevel)) statelevel = Uarr.arrayShallowCopy(statelevel); // forced to ignore inplace requirement due to change of type (obj -> arr)\r\n\r\n        // statelevel = {...statelevel}; not working if i do it here, just a new var. first time copy id done in caller func undo(). recursive copies are done before recursive step\r\n        for (let key in deltalevel) {\r\n            let delta = deltalevel[key];\r\n            // console.log(\"undoing\", {delta, key, deltalevel, statelevel})\r\n            if (key.indexOf(\"_-\") === 0) { delete statelevel[key.substring(2)]; continue; } // ????????????????????????????????????? todo: check\r\n            if (key === '__jjObjDiffIsArr') continue; // the key is the string, the val is true\r\n            if (deltalevel[key] === '__jjObjDiffEmptyElem') { // the key is the index,the  val is the string\r\n                delete statelevel[key];\r\n                continue;\r\n            }\r\n            if (typeof delta === \"object\") {\r\n                // if (Uobj.isObject(delta, false, false, true)) {\r\n                // if (!inplace) statelevel[key] = Array.isArray(delta) ? Uarr.arrayShallowCopy(statelevel[key]) : {...statelevel[key]};\r\n                // console.log('handling ', {key});\r\n                statelevel[key] = Uobj.applyObjectDelta(statelevel[key], deltalevel[key], inplace, asserteq?.[key]); }\r\n            else { statelevel[key] = delta; }\r\n        }\r\n        let old = statelevel;\r\n\r\n        if (targetIsArr) {\r\n            statelevel = [];\r\n            for (let k in old) {\r\n                if (!old.hasOwnProperty(k)) continue;\r\n                statelevel[k] = old[k]; // it takes array custom keys\r\n            }\r\n\r\n            //delete statelevel.__jjObjDiffIsArr;\r\n            statelevel.length = old.length;\r\n        }\r\n\r\n        if (asserteq) {\r\n            let as = stringify(asserteq);\r\n            let rs = stringify(statelevel);\r\n            Log.eDev(as !== rs, 'error in Uobj.diff, UObj.delta or UObj.patch, assertion failed',\r\n                {oldState, deltalevel, ret:statelevel, asserteq, rs, as, old, targetIsArr});\r\n        }\r\n        return statelevel;\r\n    }\r\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}