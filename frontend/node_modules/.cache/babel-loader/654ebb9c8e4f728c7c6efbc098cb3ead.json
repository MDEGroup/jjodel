{"ast":null,"code":"import _construct from \"C:/d/Programming/web/jodel-mde/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/construct\";\nimport _defineProperty from \"C:/d/Programming/web/jodel-mde/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/defineProperty\";\nimport _toConsumableArray from \"C:/d/Programming/web/jodel-mde/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _createForOfIteratorHelper from \"C:/d/Programming/web/jodel-mde/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\n/**\n * Utility function that works like `Object.apply`, but copies getters and setters properly as well.  Additionally gives\n * the option to exclude properties by name.\n */\nvar copyProps = function copyProps(dest, src) {\n  var exclude = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n  var props = Object.getOwnPropertyDescriptors(src);\n  var _iterator = _createForOfIteratorHelper(exclude),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var prop = _step.value;\n      delete props[prop];\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  Object.defineProperties(dest, props);\n};\n/**\n * Returns the full chain of prototypes up until Object.prototype given a starting object.  The order of prototypes will\n * be closest to farthest in the chain.\n */\nvar protoChain = function protoChain(obj) {\n  var currentChain = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [obj];\n  var proto = Object.getPrototypeOf(obj);\n  if (proto === null) return currentChain;\n  return protoChain(proto, [].concat(_toConsumableArray(currentChain), [proto]));\n};\n/**\n * Identifies the nearest ancestor common to all the given objects in their prototype chains.  For most unrelated\n * objects, this function should return Object.prototype.\n */\nvar nearestCommonProto = function nearestCommonProto() {\n  for (var _len = arguments.length, objs = new Array(_len), _key = 0; _key < _len; _key++) {\n    objs[_key] = arguments[_key];\n  }\n  if (objs.length === 0) return undefined;\n  var commonProto = undefined;\n  var protoChains = objs.map(function (obj) {\n    return protoChain(obj);\n  });\n  var _loop = function _loop() {\n    var protos = protoChains.map(function (protoChain) {\n      return protoChain.pop();\n    });\n    var potentialCommonProto = protos[0];\n    if (protos.every(function (proto) {\n      return proto === potentialCommonProto;\n    })) commonProto = potentialCommonProto;else return \"break\";\n  };\n  while (protoChains.every(function (protoChain) {\n    return protoChain.length > 0;\n  })) {\n    var _ret = _loop();\n    if (_ret === \"break\") break;\n  }\n  return commonProto;\n};\n/**\n * Creates a new prototype object that is a mixture of the given prototypes.  The mixing is achieved by first\n * identifying the nearest common ancestor and using it as the prototype for a new object.  Then all properties/methods\n * downstream of this prototype (ONLY downstream) are copied into the new object.\n *\n * The resulting prototype is more performant than softMixProtos(...), as well as ES5 compatible.  However, it's not as\n * flexible as updates to the source prototypes aren't captured by the mixed result.  See softMixProtos for why you may\n * want to use that instead.\n */\nvar hardMixProtos = function hardMixProtos(ingredients, constructor) {\n  var exclude = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n  var _a;\n  var base = (_a = nearestCommonProto.apply(void 0, _toConsumableArray(ingredients))) !== null && _a !== void 0 ? _a : Object.prototype;\n  var mixedProto = Object.create(base);\n  // Keeps track of prototypes we've already visited to avoid copying the same properties multiple times.  We init the\n  // list with the proto chain below the nearest common ancestor because we don't want any of those methods mixed in\n  // when they will already be accessible via prototype access.\n  var visitedProtos = protoChain(base);\n  var _iterator2 = _createForOfIteratorHelper(ingredients),\n    _step2;\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var prototype = _step2.value;\n      var protos = protoChain(prototype);\n      // Apply the prototype chain in reverse order so that old methods don't override newer ones.\n      for (var i = protos.length - 1; i >= 0; i--) {\n        var newProto = protos[i];\n        if (visitedProtos.indexOf(newProto) === -1) {\n          copyProps(mixedProto, newProto, ['constructor'].concat(_toConsumableArray(exclude)));\n          visitedProtos.push(newProto);\n        }\n      }\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n  mixedProto.constructor = constructor;\n  return mixedProto;\n};\nvar unique = function unique(arr) {\n  return arr.filter(function (e, i) {\n    return arr.indexOf(e) == i;\n  });\n};\n\n/**\n * Finds the ingredient with the given prop, searching in reverse order and breadth-first if searching ingredient\n * prototypes is required.\n */\nvar getIngredientWithProp = function getIngredientWithProp(prop, ingredients) {\n  var protoChains = ingredients.map(function (ingredient) {\n    return protoChain(ingredient);\n  });\n  // since we search breadth-first, we need to keep track of our depth in the prototype chains\n  var protoDepth = 0;\n  // not all prototype chains are the same depth, so this remains true as long as at least one of the ingredients'\n  // prototype chains has an object at this depth\n  var protosAreLeftToSearch = true;\n  while (protosAreLeftToSearch) {\n    // with the start of each horizontal slice, we assume this is the one that's deeper than any of the proto chains\n    protosAreLeftToSearch = false;\n    // scan through the ingredients right to left\n    for (var i = ingredients.length - 1; i >= 0; i--) {\n      var searchTarget = protoChains[i][protoDepth];\n      if (searchTarget !== undefined && searchTarget !== null) {\n        // if we find something, this is proof that this horizontal slice potentially more objects to search\n        protosAreLeftToSearch = true;\n        // eureka, we found it\n        if (Object.getOwnPropertyDescriptor(searchTarget, prop) != undefined) {\n          return protoChains[i][0];\n        }\n      }\n    }\n    protoDepth++;\n  }\n  return undefined;\n};\n/**\n * \"Mixes\" ingredients by wrapping them in a Proxy.  The optional prototype argument allows the mixed object to sit\n * downstream of an existing prototype chain.  Note that \"properties\" cannot be added, deleted, or modified.\n */\nvar proxyMix = function proxyMix(ingredients) {\n  var prototype = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Object.prototype;\n  return new Proxy({}, {\n    getPrototypeOf: function getPrototypeOf() {\n      return prototype;\n    },\n    setPrototypeOf: function setPrototypeOf() {\n      throw Error('Cannot set prototype of Proxies created by ts-mixer');\n    },\n    getOwnPropertyDescriptor: function getOwnPropertyDescriptor(_, prop) {\n      return Object.getOwnPropertyDescriptor(getIngredientWithProp(prop, ingredients) || {}, prop);\n    },\n    defineProperty: function defineProperty() {\n      throw new Error('Cannot define new properties on Proxies created by ts-mixer');\n    },\n    has: function has(_, prop) {\n      return getIngredientWithProp(prop, ingredients) !== undefined || prototype[prop] !== undefined;\n    },\n    get: function get(_, prop) {\n      return (getIngredientWithProp(prop, ingredients) || prototype)[prop];\n    },\n    set: function set(_, prop, val) {\n      var ingredientWithProp = getIngredientWithProp(prop, ingredients);\n      if (ingredientWithProp === undefined) throw new Error('Cannot set new properties on Proxies created by ts-mixer');\n      ingredientWithProp[prop] = val;\n      return true;\n    },\n    deleteProperty: function deleteProperty() {\n      throw new Error('Cannot delete properties on Proxies created by ts-mixer');\n    },\n    ownKeys: function ownKeys() {\n      return ingredients.map(Object.getOwnPropertyNames).reduce(function (prev, curr) {\n        return curr.concat(prev.filter(function (key) {\n          return curr.indexOf(key) < 0;\n        }));\n      });\n    }\n  });\n};\n/**\n * Creates a new proxy-prototype object that is a \"soft\" mixture of the given prototypes.  The mixing is achieved by\n * proxying all property access to the ingredients.  This is not ES5 compatible and less performant.  However, any\n * changes made to the source prototypes will be reflected in the proxy-prototype, which may be desirable.\n */\nvar softMixProtos = function softMixProtos(ingredients, constructor) {\n  return proxyMix([].concat(_toConsumableArray(ingredients), [{\n    constructor: constructor\n  }]));\n};\nvar settings = {\n  initFunction: null,\n  staticsStrategy: 'copy',\n  prototypeStrategy: 'copy',\n  decoratorInheritance: 'deep'\n};\n\n// Keeps track of constituent classes for every mixin class created by ts-mixer.\nvar mixins = new Map();\nvar getMixinsForClass = function getMixinsForClass(clazz) {\n  return mixins.get(clazz);\n};\nvar registerMixins = function registerMixins(mixedClass, constituents) {\n  return mixins.set(mixedClass, constituents);\n};\nvar hasMixin = function hasMixin(instance, mixin) {\n  if (instance instanceof mixin) return true;\n  var constructor = instance.constructor;\n  var visited = new Set();\n  var frontier = new Set();\n  frontier.add(constructor);\n  var _loop2 = function _loop2() {\n    // check if the frontier has the mixin we're looking for.  if not, we can say we visited every item in the frontier\n    if (frontier.has(mixin)) return {\n      v: true\n    };\n    frontier.forEach(function (item) {\n      return visited.add(item);\n    });\n    // build a new frontier based on the associated mixin classes and prototype chains of each frontier item\n    var newFrontier = new Set();\n    frontier.forEach(function (item) {\n      var _a;\n      var itemConstituents = (_a = mixins.get(item)) !== null && _a !== void 0 ? _a : protoChain(item.prototype).map(function (proto) {\n        return proto.constructor;\n      }).filter(function (item) {\n        return item !== null;\n      });\n      if (itemConstituents) itemConstituents.forEach(function (constituent) {\n        if (!visited.has(constituent) && !frontier.has(constituent)) newFrontier.add(constituent);\n      });\n    });\n    // we have a new frontier, now search again\n    frontier = newFrontier;\n  };\n  while (frontier.size > 0) {\n    var _ret2 = _loop2();\n    if (typeof _ret2 === \"object\") return _ret2.v;\n  }\n  // if we get here, we couldn't find the mixin anywhere in the prototype chain or associated mixin classes\n  return false;\n};\nvar mergeObjectsOfDecorators = function mergeObjectsOfDecorators(o1, o2) {\n  var _a, _b;\n  var allKeys = unique([].concat(_toConsumableArray(Object.getOwnPropertyNames(o1)), _toConsumableArray(Object.getOwnPropertyNames(o2))));\n  var mergedObject = {};\n  var _iterator3 = _createForOfIteratorHelper(allKeys),\n    _step3;\n  try {\n    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n      var key = _step3.value;\n      mergedObject[key] = unique([].concat(_toConsumableArray((_a = o1 === null || o1 === void 0 ? void 0 : o1[key]) !== null && _a !== void 0 ? _a : []), _toConsumableArray((_b = o2 === null || o2 === void 0 ? void 0 : o2[key]) !== null && _b !== void 0 ? _b : [])));\n    }\n  } catch (err) {\n    _iterator3.e(err);\n  } finally {\n    _iterator3.f();\n  }\n  return mergedObject;\n};\nvar mergePropertyAndMethodDecorators = function mergePropertyAndMethodDecorators(d1, d2) {\n  var _a, _b, _c, _d;\n  return {\n    property: mergeObjectsOfDecorators((_a = d1 === null || d1 === void 0 ? void 0 : d1.property) !== null && _a !== void 0 ? _a : {}, (_b = d2 === null || d2 === void 0 ? void 0 : d2.property) !== null && _b !== void 0 ? _b : {}),\n    method: mergeObjectsOfDecorators((_c = d1 === null || d1 === void 0 ? void 0 : d1.method) !== null && _c !== void 0 ? _c : {}, (_d = d2 === null || d2 === void 0 ? void 0 : d2.method) !== null && _d !== void 0 ? _d : {})\n  };\n};\nvar mergeDecorators = function mergeDecorators(d1, d2) {\n  var _a, _b, _c, _d, _e, _f;\n  return {\n    class: unique([].concat(_toConsumableArray((_a = d1 === null || d1 === void 0 ? void 0 : d1.class) !== null && _a !== void 0 ? _a : []), _toConsumableArray((_b = d2 === null || d2 === void 0 ? void 0 : d2.class) !== null && _b !== void 0 ? _b : []))),\n    static: mergePropertyAndMethodDecorators((_c = d1 === null || d1 === void 0 ? void 0 : d1.static) !== null && _c !== void 0 ? _c : {}, (_d = d2 === null || d2 === void 0 ? void 0 : d2.static) !== null && _d !== void 0 ? _d : {}),\n    instance: mergePropertyAndMethodDecorators((_e = d1 === null || d1 === void 0 ? void 0 : d1.instance) !== null && _e !== void 0 ? _e : {}, (_f = d2 === null || d2 === void 0 ? void 0 : d2.instance) !== null && _f !== void 0 ? _f : {})\n  };\n};\nvar decorators = new Map();\nvar findAllConstituentClasses = function findAllConstituentClasses() {\n  var _a;\n  var allClasses = new Set();\n  for (var _len2 = arguments.length, classes = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    classes[_key2] = arguments[_key2];\n  }\n  var frontier = new Set([].concat(classes));\n  while (frontier.size > 0) {\n    var _iterator4 = _createForOfIteratorHelper(frontier),\n      _step4;\n    try {\n      for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n        var clazz = _step4.value;\n        var protoChainClasses = protoChain(clazz.prototype).map(function (proto) {\n          return proto.constructor;\n        });\n        var mixinClasses = (_a = getMixinsForClass(clazz)) !== null && _a !== void 0 ? _a : [];\n        var potentiallyNewClasses = [].concat(_toConsumableArray(protoChainClasses), _toConsumableArray(mixinClasses));\n        var newClasses = potentiallyNewClasses.filter(function (c) {\n          return !allClasses.has(c);\n        });\n        var _iterator5 = _createForOfIteratorHelper(newClasses),\n          _step5;\n        try {\n          for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n            var newClass = _step5.value;\n            frontier.add(newClass);\n          }\n        } catch (err) {\n          _iterator5.e(err);\n        } finally {\n          _iterator5.f();\n        }\n        allClasses.add(clazz);\n        frontier.delete(clazz);\n      }\n    } catch (err) {\n      _iterator4.e(err);\n    } finally {\n      _iterator4.f();\n    }\n  }\n  return _toConsumableArray(allClasses);\n};\nvar deepDecoratorSearch = function deepDecoratorSearch() {\n  var decoratorsForClassChain = findAllConstituentClasses.apply(void 0, arguments).map(function (clazz) {\n    return decorators.get(clazz);\n  }).filter(function (decorators) {\n    return !!decorators;\n  });\n  if (decoratorsForClassChain.length == 0) return {};\n  if (decoratorsForClassChain.length == 1) return decoratorsForClassChain[0];\n  return decoratorsForClassChain.reduce(function (d1, d2) {\n    return mergeDecorators(d1, d2);\n  });\n};\nvar directDecoratorSearch = function directDecoratorSearch() {\n  for (var _len3 = arguments.length, classes = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n    classes[_key3] = arguments[_key3];\n  }\n  var classDecorators = classes.map(function (clazz) {\n    return getDecoratorsForClass(clazz);\n  });\n  if (classDecorators.length === 0) return {};\n  if (classDecorators.length === 1) return classDecorators[1];\n  return classDecorators.reduce(function (d1, d2) {\n    return mergeDecorators(d1, d2);\n  });\n};\nvar getDecoratorsForClass = function getDecoratorsForClass(clazz) {\n  var decoratorsForClass = decorators.get(clazz);\n  if (!decoratorsForClass) {\n    decoratorsForClass = {};\n    decorators.set(clazz, decoratorsForClass);\n  }\n  return decoratorsForClass;\n};\nvar decorateClass = function decorateClass(decorator) {\n  return function (clazz) {\n    var decoratorsForClass = getDecoratorsForClass(clazz);\n    var classDecorators = decoratorsForClass.class;\n    if (!classDecorators) {\n      classDecorators = [];\n      decoratorsForClass.class = classDecorators;\n    }\n    classDecorators.push(decorator);\n    return decorator(clazz);\n  };\n};\nvar decorateMember = function decorateMember(decorator) {\n  return function (object, key) {\n    var decoratorTargetType = typeof object === 'function' ? 'static' : 'instance';\n    var decoratorType = typeof object[key] === 'function' ? 'method' : 'property';\n    var clazz = decoratorTargetType === 'static' ? object : object.constructor;\n    var decoratorsForClass = getDecoratorsForClass(clazz);\n    var decoratorsForTargetType = decoratorsForClass === null || decoratorsForClass === void 0 ? void 0 : decoratorsForClass[decoratorTargetType];\n    if (!decoratorsForTargetType) {\n      decoratorsForTargetType = {};\n      decoratorsForClass[decoratorTargetType] = decoratorsForTargetType;\n    }\n    var decoratorsForType = decoratorsForTargetType === null || decoratorsForTargetType === void 0 ? void 0 : decoratorsForTargetType[decoratorType];\n    if (!decoratorsForType) {\n      decoratorsForType = {};\n      decoratorsForTargetType[decoratorType] = decoratorsForType;\n    }\n    var decoratorsForKey = decoratorsForType === null || decoratorsForType === void 0 ? void 0 : decoratorsForType[key];\n    if (!decoratorsForKey) {\n      decoratorsForKey = [];\n      decoratorsForType[key] = decoratorsForKey;\n    }\n    decoratorsForKey.push(decorator);\n    // @ts-ignore\n    for (var _len4 = arguments.length, otherArgs = new Array(_len4 > 2 ? _len4 - 2 : 0), _key4 = 2; _key4 < _len4; _key4++) {\n      otherArgs[_key4 - 2] = arguments[_key4];\n    }\n    return decorator.apply(void 0, [object, key].concat(otherArgs));\n  };\n};\nvar decorate = function decorate(decorator) {\n  return function () {\n    if (arguments.length === 1) return decorateClass(decorator)(arguments.length <= 0 ? undefined : arguments[0]);\n    return decorateMember(decorator).apply(void 0, arguments);\n  };\n};\nfunction Mixin() {\n  for (var _len5 = arguments.length, constructors = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n    constructors[_key5] = arguments[_key5];\n  }\n  var _a, _b, _c;\n  var prototypes = constructors.map(function (constructor) {\n    return constructor.prototype;\n  });\n  // Here we gather up the init functions of the ingredient prototypes, combine them into one init function, and\n  // attach it to the mixed class prototype.  The reason we do this is because we want the init functions to mix\n  // similarly to constructors -- not methods, which simply override each other.\n  var initFunctionName = settings.initFunction;\n  if (initFunctionName !== null) {\n    var initFunctions = prototypes.map(function (proto) {\n      return proto[initFunctionName];\n    }).filter(function (func) {\n      return typeof func === 'function';\n    });\n    var combinedInitFunction = function combinedInitFunction() {\n      for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n        args[_key6] = arguments[_key6];\n      }\n      var _iterator6 = _createForOfIteratorHelper(initFunctions),\n        _step6;\n      try {\n        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n          var initFunction = _step6.value;\n          initFunction.apply(this, args);\n        }\n      } catch (err) {\n        _iterator6.e(err);\n      } finally {\n        _iterator6.f();\n      }\n    };\n    var extraProto = _defineProperty({}, initFunctionName, combinedInitFunction);\n    prototypes.push(extraProto);\n  }\n  function MixedClass() {\n    for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {\n      args[_key7] = arguments[_key7];\n    }\n    var _iterator7 = _createForOfIteratorHelper(constructors),\n      _step7;\n    try {\n      for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n        var _constructor = _step7.value;\n        // @ts-ignore: potentially abstract class\n        copyProps(this, _construct(_constructor, args));\n      }\n    } catch (err) {\n      _iterator7.e(err);\n    } finally {\n      _iterator7.f();\n    }\n    if (initFunctionName !== null && typeof this[initFunctionName] === 'function') this[initFunctionName].apply(this, args);\n  }\n  MixedClass.prototype = settings.prototypeStrategy === 'copy' ? hardMixProtos(prototypes, MixedClass) : softMixProtos(prototypes, MixedClass);\n  Object.setPrototypeOf(MixedClass, settings.staticsStrategy === 'copy' ? hardMixProtos(constructors, null, ['prototype']) : proxyMix(constructors, Function.prototype));\n  var DecoratedMixedClass = MixedClass;\n  if (settings.decoratorInheritance !== 'none') {\n    var classDecorators = settings.decoratorInheritance === 'deep' ? deepDecoratorSearch.apply(void 0, constructors) : directDecoratorSearch.apply(void 0, constructors);\n    var _iterator8 = _createForOfIteratorHelper((_a = classDecorators === null || classDecorators === void 0 ? void 0 : classDecorators.class) !== null && _a !== void 0 ? _a : []),\n      _step8;\n    try {\n      for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n        var decorator = _step8.value;\n        DecoratedMixedClass = decorator(DecoratedMixedClass);\n      }\n    } catch (err) {\n      _iterator8.e(err);\n    } finally {\n      _iterator8.f();\n    }\n    applyPropAndMethodDecorators((_b = classDecorators === null || classDecorators === void 0 ? void 0 : classDecorators.static) !== null && _b !== void 0 ? _b : {}, DecoratedMixedClass);\n    applyPropAndMethodDecorators((_c = classDecorators === null || classDecorators === void 0 ? void 0 : classDecorators.instance) !== null && _c !== void 0 ? _c : {}, DecoratedMixedClass.prototype);\n  }\n  registerMixins(DecoratedMixedClass, constructors);\n  return DecoratedMixedClass;\n}\nvar applyPropAndMethodDecorators = function applyPropAndMethodDecorators(propAndMethodDecorators, target) {\n  var propDecorators = propAndMethodDecorators.property;\n  var methodDecorators = propAndMethodDecorators.method;\n  if (propDecorators) for (var key in propDecorators) {\n    var _iterator9 = _createForOfIteratorHelper(propDecorators[key]),\n      _step9;\n    try {\n      for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n        var decorator = _step9.value;\n        decorator(target, key);\n      }\n    } catch (err) {\n      _iterator9.e(err);\n    } finally {\n      _iterator9.f();\n    }\n  }\n  if (methodDecorators) for (var _key8 in methodDecorators) {\n    var _iterator10 = _createForOfIteratorHelper(methodDecorators[_key8]),\n      _step10;\n    try {\n      for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n        var _decorator = _step10.value;\n        _decorator(target, _key8, Object.getOwnPropertyDescriptor(target, _key8));\n      }\n    } catch (err) {\n      _iterator10.e(err);\n    } finally {\n      _iterator10.f();\n    }\n  }\n};\n/**\n * A decorator version of the `Mixin` function.  You'll want to use this instead of `Mixin` for mixing generic classes.\n */\nvar mix = function mix() {\n  for (var _len8 = arguments.length, ingredients = new Array(_len8), _key9 = 0; _key9 < _len8; _key9++) {\n    ingredients[_key9] = arguments[_key9];\n  }\n  return function (decoratedClass) {\n    // @ts-ignore\n    var mixedClass = Mixin.apply(void 0, _toConsumableArray(ingredients.concat([decoratedClass])));\n    Object.defineProperty(mixedClass, 'name', {\n      value: decoratedClass.name,\n      writable: false\n    });\n    return mixedClass;\n  };\n};\nexport { Mixin, decorate, hasMixin, mix, settings };","map":{"version":3,"names":["copyProps","dest","src","exclude","arguments","length","undefined","props","Object","getOwnPropertyDescriptors","_iterator","_createForOfIteratorHelper","_step","s","n","done","prop","value","err","e","f","defineProperties","protoChain","obj","currentChain","proto","getPrototypeOf","concat","_toConsumableArray","nearestCommonProto","_len","objs","Array","_key","commonProto","protoChains","map","_loop","protos","pop","potentialCommonProto","every","_ret","hardMixProtos","ingredients","constructor","_a","base","apply","prototype","mixedProto","create","visitedProtos","_iterator2","_step2","i","newProto","indexOf","push","unique","arr","filter","getIngredientWithProp","ingredient","protoDepth","protosAreLeftToSearch","searchTarget","getOwnPropertyDescriptor","proxyMix","Proxy","setPrototypeOf","Error","_","defineProperty","has","get","set","val","ingredientWithProp","deleteProperty","ownKeys","getOwnPropertyNames","reduce","prev","curr","key","softMixProtos","settings","initFunction","staticsStrategy","prototypeStrategy","decoratorInheritance","mixins","Map","getMixinsForClass","clazz","registerMixins","mixedClass","constituents","hasMixin","instance","mixin","visited","Set","frontier","add","_loop2","v","forEach","item","newFrontier","itemConstituents","constituent","size","_ret2","mergeObjectsOfDecorators","o1","o2","_b","allKeys","mergedObject","_iterator3","_step3","mergePropertyAndMethodDecorators","d1","d2","_c","_d","property","method","mergeDecorators","_e","_f","class","static","decorators","findAllConstituentClasses","allClasses","_len2","classes","_key2","_iterator4","_step4","protoChainClasses","mixinClasses","potentiallyNewClasses","newClasses","c","_iterator5","_step5","newClass","delete","deepDecoratorSearch","decoratorsForClassChain","directDecoratorSearch","_len3","_key3","classDecorators","getDecoratorsForClass","decoratorsForClass","decorateClass","decorator","decorateMember","object","decoratorTargetType","decoratorType","decoratorsForTargetType","decoratorsForType","decoratorsForKey","_len4","otherArgs","_key4","decorate","Mixin","_len5","constructors","_key5","prototypes","initFunctionName","initFunctions","func","combinedInitFunction","_len6","args","_key6","_iterator6","_step6","extraProto","_defineProperty","MixedClass","_len7","_key7","_iterator7","_step7","_construct","Function","DecoratedMixedClass","_iterator8","_step8","applyPropAndMethodDecorators","propAndMethodDecorators","target","propDecorators","methodDecorators","_iterator9","_step9","_iterator10","_step10","mix","_len8","_key9","decoratedClass","name","writable"],"sources":["C:/d/Programming/web/jodel-mde/node_modules/ts-mixer/dist/esm/index.js"],"sourcesContent":["/**\n * Utility function that works like `Object.apply`, but copies getters and setters properly as well.  Additionally gives\n * the option to exclude properties by name.\n */\nconst copyProps = (dest, src, exclude = []) => {\n    const props = Object.getOwnPropertyDescriptors(src);\n    for (let prop of exclude)\n        delete props[prop];\n    Object.defineProperties(dest, props);\n};\n/**\n * Returns the full chain of prototypes up until Object.prototype given a starting object.  The order of prototypes will\n * be closest to farthest in the chain.\n */\nconst protoChain = (obj, currentChain = [obj]) => {\n    const proto = Object.getPrototypeOf(obj);\n    if (proto === null)\n        return currentChain;\n    return protoChain(proto, [...currentChain, proto]);\n};\n/**\n * Identifies the nearest ancestor common to all the given objects in their prototype chains.  For most unrelated\n * objects, this function should return Object.prototype.\n */\nconst nearestCommonProto = (...objs) => {\n    if (objs.length === 0)\n        return undefined;\n    let commonProto = undefined;\n    const protoChains = objs.map(obj => protoChain(obj));\n    while (protoChains.every(protoChain => protoChain.length > 0)) {\n        const protos = protoChains.map(protoChain => protoChain.pop());\n        const potentialCommonProto = protos[0];\n        if (protos.every(proto => proto === potentialCommonProto))\n            commonProto = potentialCommonProto;\n        else\n            break;\n    }\n    return commonProto;\n};\n/**\n * Creates a new prototype object that is a mixture of the given prototypes.  The mixing is achieved by first\n * identifying the nearest common ancestor and using it as the prototype for a new object.  Then all properties/methods\n * downstream of this prototype (ONLY downstream) are copied into the new object.\n *\n * The resulting prototype is more performant than softMixProtos(...), as well as ES5 compatible.  However, it's not as\n * flexible as updates to the source prototypes aren't captured by the mixed result.  See softMixProtos for why you may\n * want to use that instead.\n */\nconst hardMixProtos = (ingredients, constructor, exclude = []) => {\n    var _a;\n    const base = (_a = nearestCommonProto(...ingredients)) !== null && _a !== void 0 ? _a : Object.prototype;\n    const mixedProto = Object.create(base);\n    // Keeps track of prototypes we've already visited to avoid copying the same properties multiple times.  We init the\n    // list with the proto chain below the nearest common ancestor because we don't want any of those methods mixed in\n    // when they will already be accessible via prototype access.\n    const visitedProtos = protoChain(base);\n    for (let prototype of ingredients) {\n        let protos = protoChain(prototype);\n        // Apply the prototype chain in reverse order so that old methods don't override newer ones.\n        for (let i = protos.length - 1; i >= 0; i--) {\n            let newProto = protos[i];\n            if (visitedProtos.indexOf(newProto) === -1) {\n                copyProps(mixedProto, newProto, ['constructor', ...exclude]);\n                visitedProtos.push(newProto);\n            }\n        }\n    }\n    mixedProto.constructor = constructor;\n    return mixedProto;\n};\nconst unique = (arr) => arr.filter((e, i) => arr.indexOf(e) == i);\n\n/**\n * Finds the ingredient with the given prop, searching in reverse order and breadth-first if searching ingredient\n * prototypes is required.\n */\nconst getIngredientWithProp = (prop, ingredients) => {\n    const protoChains = ingredients.map(ingredient => protoChain(ingredient));\n    // since we search breadth-first, we need to keep track of our depth in the prototype chains\n    let protoDepth = 0;\n    // not all prototype chains are the same depth, so this remains true as long as at least one of the ingredients'\n    // prototype chains has an object at this depth\n    let protosAreLeftToSearch = true;\n    while (protosAreLeftToSearch) {\n        // with the start of each horizontal slice, we assume this is the one that's deeper than any of the proto chains\n        protosAreLeftToSearch = false;\n        // scan through the ingredients right to left\n        for (let i = ingredients.length - 1; i >= 0; i--) {\n            const searchTarget = protoChains[i][protoDepth];\n            if (searchTarget !== undefined && searchTarget !== null) {\n                // if we find something, this is proof that this horizontal slice potentially more objects to search\n                protosAreLeftToSearch = true;\n                // eureka, we found it\n                if (Object.getOwnPropertyDescriptor(searchTarget, prop) != undefined) {\n                    return protoChains[i][0];\n                }\n            }\n        }\n        protoDepth++;\n    }\n    return undefined;\n};\n/**\n * \"Mixes\" ingredients by wrapping them in a Proxy.  The optional prototype argument allows the mixed object to sit\n * downstream of an existing prototype chain.  Note that \"properties\" cannot be added, deleted, or modified.\n */\nconst proxyMix = (ingredients, prototype = Object.prototype) => new Proxy({}, {\n    getPrototypeOf() {\n        return prototype;\n    },\n    setPrototypeOf() {\n        throw Error('Cannot set prototype of Proxies created by ts-mixer');\n    },\n    getOwnPropertyDescriptor(_, prop) {\n        return Object.getOwnPropertyDescriptor(getIngredientWithProp(prop, ingredients) || {}, prop);\n    },\n    defineProperty() {\n        throw new Error('Cannot define new properties on Proxies created by ts-mixer');\n    },\n    has(_, prop) {\n        return getIngredientWithProp(prop, ingredients) !== undefined || prototype[prop] !== undefined;\n    },\n    get(_, prop) {\n        return (getIngredientWithProp(prop, ingredients) || prototype)[prop];\n    },\n    set(_, prop, val) {\n        const ingredientWithProp = getIngredientWithProp(prop, ingredients);\n        if (ingredientWithProp === undefined)\n            throw new Error('Cannot set new properties on Proxies created by ts-mixer');\n        ingredientWithProp[prop] = val;\n        return true;\n    },\n    deleteProperty() {\n        throw new Error('Cannot delete properties on Proxies created by ts-mixer');\n    },\n    ownKeys() {\n        return ingredients\n            .map(Object.getOwnPropertyNames)\n            .reduce((prev, curr) => curr.concat(prev.filter(key => curr.indexOf(key) < 0)));\n    },\n});\n/**\n * Creates a new proxy-prototype object that is a \"soft\" mixture of the given prototypes.  The mixing is achieved by\n * proxying all property access to the ingredients.  This is not ES5 compatible and less performant.  However, any\n * changes made to the source prototypes will be reflected in the proxy-prototype, which may be desirable.\n */\nconst softMixProtos = (ingredients, constructor) => proxyMix([...ingredients, { constructor }]);\n\nconst settings = {\n    initFunction: null,\n    staticsStrategy: 'copy',\n    prototypeStrategy: 'copy',\n    decoratorInheritance: 'deep',\n};\n\n// Keeps track of constituent classes for every mixin class created by ts-mixer.\nconst mixins = new Map();\nconst getMixinsForClass = (clazz) => mixins.get(clazz);\nconst registerMixins = (mixedClass, constituents) => mixins.set(mixedClass, constituents);\nconst hasMixin = (instance, mixin) => {\n    if (instance instanceof mixin)\n        return true;\n    const constructor = instance.constructor;\n    const visited = new Set();\n    let frontier = new Set();\n    frontier.add(constructor);\n    while (frontier.size > 0) {\n        // check if the frontier has the mixin we're looking for.  if not, we can say we visited every item in the frontier\n        if (frontier.has(mixin))\n            return true;\n        frontier.forEach(item => visited.add(item));\n        // build a new frontier based on the associated mixin classes and prototype chains of each frontier item\n        const newFrontier = new Set();\n        frontier.forEach(item => {\n            var _a;\n            const itemConstituents = (_a = mixins.get(item)) !== null && _a !== void 0 ? _a : protoChain(item.prototype).map(proto => proto.constructor).filter(item => item !== null);\n            if (itemConstituents)\n                itemConstituents.forEach(constituent => {\n                    if (!visited.has(constituent) && !frontier.has(constituent))\n                        newFrontier.add(constituent);\n                });\n        });\n        // we have a new frontier, now search again\n        frontier = newFrontier;\n    }\n    // if we get here, we couldn't find the mixin anywhere in the prototype chain or associated mixin classes\n    return false;\n};\n\nconst mergeObjectsOfDecorators = (o1, o2) => {\n    var _a, _b;\n    const allKeys = unique([...Object.getOwnPropertyNames(o1), ...Object.getOwnPropertyNames(o2)]);\n    const mergedObject = {};\n    for (let key of allKeys)\n        mergedObject[key] = unique([...((_a = o1 === null || o1 === void 0 ? void 0 : o1[key]) !== null && _a !== void 0 ? _a : []), ...((_b = o2 === null || o2 === void 0 ? void 0 : o2[key]) !== null && _b !== void 0 ? _b : [])]);\n    return mergedObject;\n};\nconst mergePropertyAndMethodDecorators = (d1, d2) => {\n    var _a, _b, _c, _d;\n    return ({\n        property: mergeObjectsOfDecorators((_a = d1 === null || d1 === void 0 ? void 0 : d1.property) !== null && _a !== void 0 ? _a : {}, (_b = d2 === null || d2 === void 0 ? void 0 : d2.property) !== null && _b !== void 0 ? _b : {}),\n        method: mergeObjectsOfDecorators((_c = d1 === null || d1 === void 0 ? void 0 : d1.method) !== null && _c !== void 0 ? _c : {}, (_d = d2 === null || d2 === void 0 ? void 0 : d2.method) !== null && _d !== void 0 ? _d : {}),\n    });\n};\nconst mergeDecorators = (d1, d2) => {\n    var _a, _b, _c, _d, _e, _f;\n    return ({\n        class: unique([...(_a = d1 === null || d1 === void 0 ? void 0 : d1.class) !== null && _a !== void 0 ? _a : [], ...(_b = d2 === null || d2 === void 0 ? void 0 : d2.class) !== null && _b !== void 0 ? _b : []]),\n        static: mergePropertyAndMethodDecorators((_c = d1 === null || d1 === void 0 ? void 0 : d1.static) !== null && _c !== void 0 ? _c : {}, (_d = d2 === null || d2 === void 0 ? void 0 : d2.static) !== null && _d !== void 0 ? _d : {}),\n        instance: mergePropertyAndMethodDecorators((_e = d1 === null || d1 === void 0 ? void 0 : d1.instance) !== null && _e !== void 0 ? _e : {}, (_f = d2 === null || d2 === void 0 ? void 0 : d2.instance) !== null && _f !== void 0 ? _f : {}),\n    });\n};\nconst decorators = new Map();\nconst findAllConstituentClasses = (...classes) => {\n    var _a;\n    const allClasses = new Set();\n    const frontier = new Set([...classes]);\n    while (frontier.size > 0) {\n        for (let clazz of frontier) {\n            const protoChainClasses = protoChain(clazz.prototype).map(proto => proto.constructor);\n            const mixinClasses = (_a = getMixinsForClass(clazz)) !== null && _a !== void 0 ? _a : [];\n            const potentiallyNewClasses = [...protoChainClasses, ...mixinClasses];\n            const newClasses = potentiallyNewClasses.filter(c => !allClasses.has(c));\n            for (let newClass of newClasses)\n                frontier.add(newClass);\n            allClasses.add(clazz);\n            frontier.delete(clazz);\n        }\n    }\n    return [...allClasses];\n};\nconst deepDecoratorSearch = (...classes) => {\n    const decoratorsForClassChain = findAllConstituentClasses(...classes)\n        .map(clazz => decorators.get(clazz))\n        .filter(decorators => !!decorators);\n    if (decoratorsForClassChain.length == 0)\n        return {};\n    if (decoratorsForClassChain.length == 1)\n        return decoratorsForClassChain[0];\n    return decoratorsForClassChain.reduce((d1, d2) => mergeDecorators(d1, d2));\n};\nconst directDecoratorSearch = (...classes) => {\n    const classDecorators = classes.map(clazz => getDecoratorsForClass(clazz));\n    if (classDecorators.length === 0)\n        return {};\n    if (classDecorators.length === 1)\n        return classDecorators[1];\n    return classDecorators.reduce((d1, d2) => mergeDecorators(d1, d2));\n};\nconst getDecoratorsForClass = (clazz) => {\n    let decoratorsForClass = decorators.get(clazz);\n    if (!decoratorsForClass) {\n        decoratorsForClass = {};\n        decorators.set(clazz, decoratorsForClass);\n    }\n    return decoratorsForClass;\n};\nconst decorateClass = (decorator) => ((clazz) => {\n    const decoratorsForClass = getDecoratorsForClass(clazz);\n    let classDecorators = decoratorsForClass.class;\n    if (!classDecorators) {\n        classDecorators = [];\n        decoratorsForClass.class = classDecorators;\n    }\n    classDecorators.push(decorator);\n    return decorator(clazz);\n});\nconst decorateMember = (decorator) => ((object, key, ...otherArgs) => {\n    const decoratorTargetType = typeof object === 'function' ? 'static' : 'instance';\n    const decoratorType = typeof object[key] === 'function' ? 'method' : 'property';\n    const clazz = decoratorTargetType === 'static' ? object : object.constructor;\n    const decoratorsForClass = getDecoratorsForClass(clazz);\n    let decoratorsForTargetType = decoratorsForClass === null || decoratorsForClass === void 0 ? void 0 : decoratorsForClass[decoratorTargetType];\n    if (!decoratorsForTargetType) {\n        decoratorsForTargetType = {};\n        decoratorsForClass[decoratorTargetType] = decoratorsForTargetType;\n    }\n    let decoratorsForType = decoratorsForTargetType === null || decoratorsForTargetType === void 0 ? void 0 : decoratorsForTargetType[decoratorType];\n    if (!decoratorsForType) {\n        decoratorsForType = {};\n        decoratorsForTargetType[decoratorType] = decoratorsForType;\n    }\n    let decoratorsForKey = decoratorsForType === null || decoratorsForType === void 0 ? void 0 : decoratorsForType[key];\n    if (!decoratorsForKey) {\n        decoratorsForKey = [];\n        decoratorsForType[key] = decoratorsForKey;\n    }\n    decoratorsForKey.push(decorator);\n    // @ts-ignore\n    return decorator(object, key, ...otherArgs);\n});\nconst decorate = (decorator) => ((...args) => {\n    if (args.length === 1)\n        return decorateClass(decorator)(args[0]);\n    return decorateMember(decorator)(...args);\n});\n\nfunction Mixin(...constructors) {\n    var _a, _b, _c;\n    const prototypes = constructors.map(constructor => constructor.prototype);\n    // Here we gather up the init functions of the ingredient prototypes, combine them into one init function, and\n    // attach it to the mixed class prototype.  The reason we do this is because we want the init functions to mix\n    // similarly to constructors -- not methods, which simply override each other.\n    const initFunctionName = settings.initFunction;\n    if (initFunctionName !== null) {\n        const initFunctions = prototypes\n            .map(proto => proto[initFunctionName])\n            .filter(func => typeof func === 'function');\n        const combinedInitFunction = function (...args) {\n            for (let initFunction of initFunctions)\n                initFunction.apply(this, args);\n        };\n        const extraProto = { [initFunctionName]: combinedInitFunction };\n        prototypes.push(extraProto);\n    }\n    function MixedClass(...args) {\n        for (const constructor of constructors)\n            // @ts-ignore: potentially abstract class\n            copyProps(this, new constructor(...args));\n        if (initFunctionName !== null && typeof this[initFunctionName] === 'function')\n            this[initFunctionName].apply(this, args);\n    }\n    MixedClass.prototype = settings.prototypeStrategy === 'copy'\n        ? hardMixProtos(prototypes, MixedClass)\n        : softMixProtos(prototypes, MixedClass);\n    Object.setPrototypeOf(MixedClass, settings.staticsStrategy === 'copy'\n        ? hardMixProtos(constructors, null, ['prototype'])\n        : proxyMix(constructors, Function.prototype));\n    let DecoratedMixedClass = MixedClass;\n    if (settings.decoratorInheritance !== 'none') {\n        const classDecorators = settings.decoratorInheritance === 'deep'\n            ? deepDecoratorSearch(...constructors)\n            : directDecoratorSearch(...constructors);\n        for (let decorator of (_a = classDecorators === null || classDecorators === void 0 ? void 0 : classDecorators.class) !== null && _a !== void 0 ? _a : [])\n            DecoratedMixedClass = decorator(DecoratedMixedClass);\n        applyPropAndMethodDecorators((_b = classDecorators === null || classDecorators === void 0 ? void 0 : classDecorators.static) !== null && _b !== void 0 ? _b : {}, DecoratedMixedClass);\n        applyPropAndMethodDecorators((_c = classDecorators === null || classDecorators === void 0 ? void 0 : classDecorators.instance) !== null && _c !== void 0 ? _c : {}, DecoratedMixedClass.prototype);\n    }\n    registerMixins(DecoratedMixedClass, constructors);\n    return DecoratedMixedClass;\n}\nconst applyPropAndMethodDecorators = (propAndMethodDecorators, target) => {\n    const propDecorators = propAndMethodDecorators.property;\n    const methodDecorators = propAndMethodDecorators.method;\n    if (propDecorators)\n        for (let key in propDecorators)\n            for (let decorator of propDecorators[key])\n                decorator(target, key);\n    if (methodDecorators)\n        for (let key in methodDecorators)\n            for (let decorator of methodDecorators[key])\n                decorator(target, key, Object.getOwnPropertyDescriptor(target, key));\n};\n/**\n * A decorator version of the `Mixin` function.  You'll want to use this instead of `Mixin` for mixing generic classes.\n */\nconst mix = (...ingredients) => decoratedClass => {\n    // @ts-ignore\n    const mixedClass = Mixin(...ingredients.concat([decoratedClass]));\n    Object.defineProperty(mixedClass, 'name', {\n        value: decoratedClass.name,\n        writable: false,\n    });\n    return mixedClass;\n};\n\nexport { Mixin, decorate, hasMixin, mix, settings };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}