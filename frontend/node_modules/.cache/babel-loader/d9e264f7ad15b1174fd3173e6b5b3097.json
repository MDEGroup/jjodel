{"ast":null,"code":"var _dec, _class, _class2;\nimport { LUser, DUser, DViewElement, DPointerTargetable, DModel, DModelElement, OCL, Log, LPointerTargetable, RuntimeAccessible, RuntimeAccessibleClass, store, U, toShortEType, NodeTransientProperties, transientProperties, ViewEClassMatch } from \"../../joiner\";\nimport { ShortDefaultEClasses, toShortEClass } from \"../../common/U\";\nexport let Selectors = (_dec = RuntimeAccessible('Selectors'), _dec(_class = (_class2 = class Selectors {\n  static getActiveModel() {\n    var _state$_lastSelected;\n    let metamodel;\n    let state = store.getState();\n    const selected = (_state$_lastSelected = state._lastSelected) === null || _state$_lastSelected === void 0 ? void 0 : _state$_lastSelected.modelElement;\n    if (selected) {\n      const me = LPointerTargetable.fromPointer(selected);\n      metamodel = me ? me.model : null;\n    } else metamodel = null;\n    return metamodel;\n  }\n  static getLastSelectedModel(state) {\n    var _state$_lastSelected2;\n    state = state || store.getState();\n    let me = (_state$_lastSelected2 = state._lastSelected) === null || _state$_lastSelected2 === void 0 ? void 0 : _state$_lastSelected2.modelElement;\n    if (!me) return {};\n    let ret = {\n      element: LPointerTargetable.fromPointer(me, state)\n    };\n    ret.model = ret.element.model;\n    if (ret.model.isMetamodel) ret.m2 = ret.model;else {\n      ret.m1 = ret.model;\n      ret.m2 = ret.m1.instanceof;\n    }\n    return ret;\n  }\n  static getAllViewElements(state0) {\n    // return Object.values(store.getState().idlookup).filter(v => v.className === DViewElement.name) as DViewElement[];\n    const state = state0 || store.getState();\n    const ptrs = Object.values(state.viewelements);\n    let views = ptrs.map(ptr => DPointerTargetable.fromPointer(ptr, state));\n    return views;\n  }\n  //Giordano: start\n\n  static getViewpoints() {\n    const state = store.getState();\n    return LPointerTargetable.fromPointer(state.viewpoints);\n  }\n  static getViewpoint() {\n    const state = store.getState();\n    return LPointerTargetable.fromPointer(state.viewpoint);\n  }\n  static getObjects() {\n    let state = store.getState();\n    const ptrs = Object.values(state.objects);\n    const dObjects = ptrs.map(ptr => state.idlookup[ptr]);\n    const lObjects = [];\n    for (let dObject of dObjects) {\n      lObjects.push(LPointerTargetable.fromPointer(dObject.id));\n    }\n    return lObjects;\n  }\n  static getValues() {\n    let state = store.getState();\n    const ptrs = Object.values(state.values);\n    const dValues = ptrs.map(ptr => state.idlookup[ptr]);\n    const lValues = [];\n    for (let dValue of dValues) {\n      if (dValue === null || dValue === void 0 ? void 0 : dValue.id) {\n        lValues.push(LPointerTargetable.fromPointer(dValue.id));\n      }\n    }\n    return lValues;\n  }\n  static getDeleted() {\n    const state = store.getState();\n    return state.deleted;\n  }\n  static getState() {\n    const state = store.getState();\n    return state;\n  }\n  static getDefaultEcoreClass(type, state) {\n    let shorttype = (toShortEClass(type) || type).toUpperCase();\n    if (!state) state = store.getState();\n    // todo: make other m3 classes and make this generic like getPrimitiveType\n    return state.idlookup[\"Pointer_\" + ShortDefaultEClasses.EObject.toUpperCase()];\n  }\n  static getPrimitiveType(type, state) {\n    let shorttype = (toShortEType(type) || type).toUpperCase();\n    if (!state) state = store.getState();\n    return state.idlookup[\"Pointer_\" + shorttype];\n  }\n  static getAllPrimitiveTypes() {\n    let state = store.getState();\n    const ptrs = Object.values(state.primitiveTypes);\n    const classifiers = ptrs.map(ptr => state.idlookup[ptr]);\n    return classifiers;\n  }\n  static getFirstPrimitiveTypes() {\n    return Selectors.getAllPrimitiveTypes()[0];\n  }\n  static getRefEdges() {\n    const state = store.getState();\n    const pointers = Object.values(state.refEdges);\n    const dRefEdges = pointers.map(ptr => state.idlookup[ptr]);\n    return dRefEdges;\n  }\n  static getField(field) {\n    let state = store.getState();\n    const pointers = Object.values(state[field]);\n    return pointers;\n  }\n  static getAllAttributes() {\n    const state = store.getState();\n    return Object.values(state.attributes);\n  }\n  static getAllEnumLiterals() {\n    const state = store.getState();\n    return Object.values(state.enumliterals);\n  }\n  static getAllReferences() {\n    const state = store.getState();\n    return Object.values(state.references);\n  }\n  // static getAllReferenceEdges(): string[] { const state: DState = store.getState(); return Object.values((state).refEdges); }\n  static getAllClasses() {\n    const state = store.getState();\n    return Object.values(state.classs);\n  }\n  static getReturnTypes() {\n    const state = store.getState();\n    return LPointerTargetable.from(Object.values(state.returnTypes));\n  }\n  static getAllClassesWithoutPrimitive() {\n    // this solution does not look good. what if a primitive type is inserted at runtime in between?\n    // coould reach the same goal by taking all Classes of a model (m2), excluding classes from other models (types are classes from m3 model)\n    const state = store.getState();\n    const classList = Object.values(state.classs);\n    classList.splice(0, Selectors.getAllPrimitiveTypes().length);\n    /* todo: need to change it in something like this once cross-references between models and instances are implemented\r\n    const m2: LModel;\r\n    m2.isInstanceOf = m3 as LModel;\r\n    m2.isInstanceOf.classes;*/\n\n    return classList;\n  }\n  static getAllEnumerators() {\n    let flag = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    const state = store.getState();\n    return Object.values(state.enumerators);\n  }\n  static getAllPackages() {\n    const state = store.getState();\n    return Object.values(state.packages);\n  }\n  static getAllParameters() {\n    const state = store.getState();\n    return Object.values(state.parameters);\n  }\n  static getAllOperations() {\n    const state = store.getState();\n    return Object.values(state.operations);\n  }\n  static getDElement(pointer) {\n    const state = store.getState();\n    const dElement = state.idlookup[pointer];\n    return dElement;\n  }\n  static getAllMetamodels() {\n    const state = store.getState();\n    const dModels = Object.values(state.m2models);\n    return LPointerTargetable.fromPointer(dModels);\n  }\n  static getAllModels() {\n    const state = store.getState();\n    const dModels = Object.values(state.m1models);\n    return LPointerTargetable.fromPointer(dModels);\n  }\n\n  //Giordano: end\n\n  static getVertex(wrap, resolvePointers) {\n    const state = store.getState();\n    let ptrs = [];\n    U.ArrayMerge0(false, ptrs,\n    // Object.values(state.graphs || {}),\n    Object.values(state.voidvertexs || {}), Object.values(state.vertexs || {}), Object.values(state.graphvertexs || {}), Object.values(state.edgepoints || {}));\n    console.log('selector getvertex: ', {\n      ptrs,\n      g: Object.values(state.graphs || {}),\n      vv: Object.values(state.voidvertexs || {}),\n      v: Object.values(state.vertexs || {}),\n      gv: Object.values(state.graphvertexs || {}),\n      ep: Object.values(state.edgepoints || {})\n    });\n    if (wrap === undefined || wrap === true) return ptrs.map(p => DPointerTargetable.wrap(p));\n    if (resolvePointers === undefined || resolvePointers === true) return ptrs.map(r => state.idlookup[r]);\n    return ptrs;\n  }\n  static getAll(Classe, condition, state, resolvePointers, wrap) {\n    if (!state) state = store.getState();\n    let GClass = Classe || {\n      name: \"idlookup\",\n      cname: \"idlookup\"\n    };\n    const className = ((GClass === null || GClass === void 0 ? void 0 : GClass.staticClassName) || GClass.cname).toLowerCase();\n    const allIdByClassName = state[className] || state[className.substr(1)] || state[className + 's'] || state[className.substr(1) + 's'];\n    Log.exDev(!allIdByClassName, 'cannot find store key:', {\n      state,\n      className,\n      Classe\n    });\n    let allDByClassName = null;\n    let allLByClassName = null;\n    if (resolvePointers || wrap) {\n      allDByClassName = allIdByClassName.map(e => state.idlookup[e]);\n      if (wrap) {\n        allLByClassName = allDByClassName.map(e => DPointerTargetable.wrap(e));\n      }\n    }\n    let ret = resolvePointers || wrap ? wrap ? allLByClassName : allDByClassName : allIdByClassName;\n    if (!Array.isArray(ret)) ret = Object.values(ret).filter(e => e instanceof Object);\n    if (condition) return ret.filter(e => condition(e));\n    return ret;\n  }\n  static getModels(condition) {\n    return Selectors.getAll(DModel, undefined, undefined, true, false);\n  }\n  static getModel(name) {\n    let caseSensitive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    let wrap = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    if (!caseSensitive) name = name.toLowerCase();\n    let ret = Selectors.getAll(DModel, d => (caseSensitive ? d.name : d.name.toLowerCase()) === name, undefined, true, wrap)[0];\n    return ret;\n  }\n  static getByName(classe, name) {\n    let caseSensitive = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    let wrap = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    return Selectors.getByField(classe, 'name', name, caseSensitive, wrap);\n  }\n  static getByField(classe, field, value) {\n    let caseSensitive = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    let wrap = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n    if (!caseSensitive) value = value.toLowerCase();\n    let condition = d => {\n      var _d$field;\n      let ret = (caseSensitive ? d[field] : (_d$field = d[field]) === null || _d$field === void 0 ? void 0 : _d$field.toLowerCase()) === value;\n      console.log('filtering getall by field:', {\n        d,\n        dfield: d[field],\n        value,\n        ret\n      });\n      return ret;\n    };\n    let ret = Selectors.getAll(classe, condition, undefined, true, wrap)[0];\n    return ret;\n  }\n  static getViewIDs(condition) {\n    return Selectors.getAll(DViewElement);\n  }\n  static queryJS(model, query) {\n    try {\n      return eval(query);\n    } catch (e) {\n      return [];\n    }\n  }\n  /*static getCurrentView(data: LModelElement): DViewElement {\r\n      Log.exDevv('todo');\r\n      return undefined as any;\r\n  }*/\n\n  static matchesMetaClassTarget(v, data) {\n    if (!v) return ViewEClassMatch.MISMATCH_PRECONDITIONS;\n    if (!v.appliableToClasses || !v.appliableToClasses.length) return ViewEClassMatch.IMPLICIT_MATCH;\n    if (!data) return ViewEClassMatch.MISMATCH_PRECONDITIONS;\n    let ThisClass = RuntimeAccessibleClass.get(data.className);\n    Log.exDev(!ThisClass, 'unable to find class type:', {\n      v,\n      data\n    }); // todo: v = view appliable to DModel, data = proxy<LModel>\n    let gotSubclassMatch = false;\n    for (let classtarget of v.appliableToClasses) {\n      const ClassTarget = RuntimeAccessibleClass.get(classtarget);\n      if (ThisClass === ClassTarget) return ViewEClassMatch.EXACT_MATCH; // explicit exact match\n      if (!gotSubclassMatch && U.classIsExtending(ThisClass, ClassTarget)) gotSubclassMatch = true; // explicit subclass match\n      if (gotSubclassMatch) return ViewEClassMatch.INHERITANCE_MATCH;\n    }\n    return ViewEClassMatch.MISMATCH_PRECONDITIONS;\n  }\n  static isOfSubclass(data, classTarget) {\n    let acceptEquality = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    let ThisClass = RuntimeAccessibleClass.get(data.className);\n    Log.exDev(!ThisClass, 'isOfSubclass() unable to find class type:', {\n      data\n    });\n    const ClassTarget = typeof classTarget === \"string\" ? RuntimeAccessibleClass.get(classTarget) : classTarget;\n    if (ThisClass === ClassTarget) return acceptEquality;\n    return U.classIsExtending(ThisClass, ClassTarget);\n  }\n  static getViewByIDOrNameD(name, state) {\n    var _state$idlookup$name, _state$idlookup$id;\n    if (!state) state = store.getState();\n    if (typeof name === \"object\") {\n      return name.__raw || name;\n    }\n    if (((_state$idlookup$name = state.idlookup[name]) === null || _state$idlookup$name === void 0 ? void 0 : _state$idlookup$name.className) === DViewElement.cname) return state.idlookup[name];\n    let id = Selectors.getViewIdFromName(name, state);\n    if (id && ((_state$idlookup$id = state.idlookup[id]) === null || _state$idlookup$id === void 0 ? void 0 : _state$idlookup$id.className) === DViewElement.cname) return state.idlookup[id];\n    return undefined;\n  }\n\n  // input: \"subview.subview2.targetview\"\n  // output: returns pointer to targetview\n  // path is not required to start with a root, it's also possible to start navigating from a subview (notviewpoint/model view)\n  // in case multiple matches are given due to incomplete path not starting from a viewpoint, the oldest matching view is returned.\n  static getViewIdFromName(namepath, state) {\n    if (!state) state = store.getState();\n    let names = namepath.split(\".\");\n    let eligibleContainers = state.viewelements;\n    for (let i = 0; i < names.length; i++) {\n      let name = names[i];\n      eligibleContainers = eligibleContainers.filter(v => state.idlookup[v].name === name);\n      if (i === names.length - 1 || eligibleContainers.length === 0) return eligibleContainers[0];\n      eligibleContainers = eligibleContainers.flatMap(v => Object.keys(state.idlookup[v].subViews));\n    }\n    return undefined;\n  }\n\n  // todo: idea, set query complexity = explicitpriority amd autoset explicit priority to query lemgth\n\n  // todo: the more \"or\" and navigations there are, the more a query is \"complex\", the more the query match is a priority.\n\n  static getAllGraphElementPointers() {\n    // graphelements = fields;\n    let state = store.getState();\n    return [...state.graphs, ...state.graphvertexs, ...state.graphelements, ...state.vertexs, ...state.edgepoints, ...state.edges];\n  }\n  static getFinalScore(entry, vid, parentView, dview) {\n    if (entry.metaclassScore === ViewEClassMatch.MISMATCH_PRECONDITIONS) return ViewEClassMatch.MISMATCH;\n    if (entry.viewPointMatch === ViewEClassMatch.VP_MISMATCH) return ViewEClassMatch.MISMATCH;\n    if (entry.jsScore === ViewEClassMatch.MISMATCH_JS || entry.OCLScore === ViewEClassMatch.MISMATCH_JS) return ViewEClassMatch.MISMATCH;\n    let pvMatch = parentView ? vid in parentView.subViews : false;\n    let pvScore = pvMatch ? parentView.subViews[vid] : 1;\n    let explicitprio;\n    if (typeof entry.jsScore === 'number') {\n      explicitprio = entry.jsScore;\n    } else if (dview.explicitApplicationPriority === undefined) {\n      var _dview$jsCondition, _dview$oclCondition;\n      // in editor put placeholder with computed expression\n      explicitprio = (((_dview$jsCondition = dview.jsCondition) === null || _dview$jsCondition === void 0 ? void 0 : _dview$jsCondition.length) || 1) + (((_dview$oclCondition = dview.oclCondition) === null || _dview$oclCondition === void 0 ? void 0 : _dview$oclCondition.length) || 1);\n    } else explicitprio = dview.explicitApplicationPriority;\n    return entry.viewPointMatch * entry.metaclassScore * pvScore * explicitprio;\n    //score = precoditiom * paremtview(comfiguravle) * (explicitprio = jsValid*jslemgth + oclvalid*ocllemgth)\n    // or if jscomditiom returmed mumver --> * jsscore\n  }\n\n  /*\r\n      //this function handles: what i do when view changes? do i recompute the score?\r\n      static updateViewMatchings(dview: DViewElement, updatePreconditions: boolean, updateOCLScore: boolean, store: DState, updateManualViews: boolean = false, forcedUpdateViews: boolean = false): void {\r\n  \r\n          //  event           observed change         ignore change\r\n          //  ocl             data                    node, view (except view.ocl)\r\n          //  jsCondition     all                     none\r\n          //  appliableTo     view.appliableto\r\n          // if (!forcedUpdateViews && (dview.oclUpdateCondition === 'manual') !== updateManualViews) return;\r\n          // modularize getscoresnew split in setpreconditionscore, setoclscorem, setjscscore, and call those only if observed stuff changed\r\n  \r\n          const allNodes: DGraphElement[] = DPointerTargetable.fromPointer(Selectors.getAllGraphElementPointers());\r\n          //let dview = view.__raw;\r\n          let vid = dview.id; // optimize searching multiple usages and replacing\r\n  \r\n          // filter alldata to exclude modelpieces that didn't pass the view.appyto check\r\n          // let oclData: (LModelElement)[] = allData.filter(l => {\r\n          let oclnodes: (DGraphElement)[] = allNodes.filter((dg: DGraphElement) => {\r\n              if (!dg) return false;\r\n              if (true) {\r\n                  let d: DModelElement | undefined = dg.model ? DPointerTargetable.fromPointer(dg.model) : undefined;\r\n                  let firstEvaluationForNodeView: boolean = false;\r\n                  if (!transientProperties.node[dg.id]) { transientProperties.node[dg.id] = {viewScores: {}} as any; firstEvaluationForNodeView = true; }\r\n                  if (!transientProperties.node[dg.id].viewScores[vid]) { transientProperties.node[dg.id].viewScores[vid] = {score: undefined} as any; firstEvaluationForNodeView = true; }\r\n  \r\n                  if (firstEvaluationForNodeView || updatePreconditions) {\r\n                      const oldScore = transientProperties.node[dg.id].viewScores[vid].score;\r\n                      const newScore = transientProperties.node[dg.id].viewScores[vid].score = this.matchesMetaClassTarget(dview, d);\r\n                      if (oldScore !== newScore) transientProperties.node[dg.id].stackViews = undefined as any; // force re-sorting\r\n                      // 67{}[]'?^&&||nb>\r\n                  } /* else {\r\n                      if (!transientProperties.view[dview.id].oclUpdateCondition_PARSED( transientProperties.node[dg.id].viewScores[vid].)) return;\r\n                  }* /\r\n                  // no need to check if parentview changed as well. i optimized by not having parentview affect the numeric scores, but only the view queue array sorting\r\n  \r\n                  // transient.node[dg.id].viewScores[vid].score = MISSING (hasOwnProperty);    if the view or model is new and they are not yet evaluated.\r\n                  // transient.node[dg.id].viewScores[vid].score = Number.NEGATIVE_INFINITY;    if pre-ocl conditions failed (view.appliableTo)\r\n                  // transient.node[dg.id].viewScores[vid].score = 0;                           if preconditions are met, but ocl failed\r\n                  // transient.node[dg.id].viewScores[vid].score = number ocl score;            if preconditions are met and ocl matched\r\n                  // transient.node[dg.id].viewScores[vid].score = number precondition score;   if preconditions are met, and there is no ocl condition\r\n                  // changed: matching score and ocl score are summed.\r\n                  return transientProperties.node[dg.id].viewScores[vid].score !== undefined;\r\n              }\r\n  \r\n              // if (model_viewstack[vid]) { filledElementsInOclData++; return l; } return undefined;\r\n          });\r\n          function mergeViewScores(preconditionScore: number, oclScore: number): number{ return preconditionScore + oclScore; }\r\n      }*/\n\n  static updateScores(data0, node, nid, pv, state) {\n    let needsorting = false;\n    let firstEvaluationForNode = false;\n    let firstEvaluationForNodeView = false;\n    let tn = transientProperties.node[nid];\n    if (!tn) {\n      transientProperties.node[nid] = tn = new NodeTransientProperties();\n      firstEvaluationForNode = true;\n    }\n    let olddata = tn.viewSorted_modelused;\n    //let oldnode = transientProperties.node[nid]?.viewSorted_nodeused as LGraphElement;\n    const data = data0;\n    // console.error('changed', {data, olddata, node, oldnode, cdata:data?.clonedCounter, colddata:olddata?.clonedCounter})\n    const pvid = pv === null || pv === void 0 ? void 0 : pv.id;\n    const oldpv = tn.viewSorted_pvid_used;\n    let datachanged = !!data !== !!olddata || !!(data && olddata) && data.clonedCounter !== olddata.clonedCounter;\n    //let nodechanged: boolean = (!!node !== !!oldnode) || !!(node && oldnode) && (node.clonedCounter !== oldnode.clonedCounter);\n    let parentViewChanged = pvid !== (oldpv === null || oldpv === void 0 ? void 0 : oldpv.id) || !!(pv && oldpv) && oldpv.subViews !== pv.subViews; // shallow comparison is fine.\n    if (parentViewChanged) tn.viewSorted_pvid_used = pv;\n    //if (nodechanged) transientProperties.node[nid].viewSorted_nodeused = node;\n    if (datachanged) tn.viewSorted_modelused = data;\n\n    // let nodechanged: boolean\n    // important to remember: how i'm using parentView in score and storage.\n    // i'm calculating and storing every score without parentView, then i apply it right before sorting the array,\n    // the enhanced value is not sored anyway but affects array sorting.\n    // so if parentView changes, or if his subviews changed, need to resort array without recomputing any score value.\n\n    //console.log('2302, getviews 2', {datachanged, nodechanged, olddata, oldnode, data, node, allViews: Selectors.getAllViewElements()});\n\n    if (!state) state = store.getState();\n    const allViews = Selectors.getAllViewElements(state);\n    const user = LUser.fromPointer(DUser.current);\n    const project = user.project;\n    let activevpid = project.activeViewpoint.id;\n    // check if scores needs to be updated\n    for (const dview of allViews) {\n      let vid = dview.id;\n      let tv = transientProperties.view[vid];\n      if (!tv) transientProperties.view[vid] = tv = {};\n      let tnv = tn.viewScores[vid];\n      //console.log('2302, getviews evaluating view ' + vid, {vid, dview});\n      // check initialization\n\n      if (!tnv) {\n        transientProperties.node[nid].viewScores[vid] = tnv = {};\n        /*{\r\n            score: ViewEClassMatch.NOT_EVALUATED_YET,\r\n            metaclassScore: ViewEClassMatch.NOT_EVALUATED_YET,\r\n            //jsScore:ViewEClassMatch.NOT_EVALUATED_YET,\r\n            //OCLScore: ViewEClassMatch.NOT_EVALUATED_YET\r\n        } as any;*/\n        firstEvaluationForNodeView = true;\n      } else firstEvaluationForNodeView = tnv.metaclassScore === ViewEClassMatch.NOT_EVALUATED_YET; // todo: when changing view.appliableTo, delete all tnv using that view.\n\n      // don't match exclusive views from other vp\n      let dvp = DPointerTargetable.fromPointer(dview.viewpoint, state);\n      let oldVpMatch = tnv.viewPointMatch;\n      // console.log(\"vp matching \" +vid, {vid, dvp, activevpid });\n      if (dvp.id === activevpid) tnv.viewPointMatch = ViewEClassMatch.VP_Explicit;else if (dvp.id === 'Pointer_ViewPointDefault') tnv.viewPointMatch = ViewEClassMatch.VP_Default;else if (!dvp.isExclusiveView) tnv.viewPointMatch = ViewEClassMatch.VP_Decorative;else tnv.viewPointMatch = ViewEClassMatch.VP_MISMATCH;\n      if (!needsorting && oldVpMatch !== tnv.viewPointMatch) needsorting = true;\n      if (tnv.viewPointMatch === ViewEClassMatch.VP_MISMATCH) {\n        tnv.finalScore = ViewEClassMatch.VP_MISMATCH;\n        continue;\n      }\n\n      // check preconditions\n      if (firstEvaluationForNodeView) {\n        const oldScore = tnv.metaclassScore;\n        tnv.metaclassScore = this.matchesMetaClassTarget(dview, data === null || data === void 0 ? void 0 : data.__raw);\n        needsorting = true; // sorting is mandatory here because it's the first evaluation of node-vie\n        // if mismatch i stop computing the score.\n        if (tnv.metaclassScore === ViewEClassMatch.MISMATCH_PRECONDITIONS) {\n          tnv.finalScore = ViewEClassMatch.MISMATCH;\n          continue;\n        }\n      } else if (tnv.metaclassScore === ViewEClassMatch.MISMATCH_PRECONDITIONS) continue;\n      if (true) {\n        // this needs to be called not only if datachanged || nodechanged, but everytime in case it is a reference like data.$value.name.length\n        // also his performances are so fast that it might be more costly to check if it's supposed to be reevaluated than just calling it.\n        let jsScoreChanged = Selectors.updateJSScore(node, data, dview, tv, tnv);\n        if (!needsorting && jsScoreChanged) needsorting = true;\n        // if mismatch i stop computing the score.\n        if (tnv.jsScore === ViewEClassMatch.MISMATCH_JS) {\n          tnv.finalScore = ViewEClassMatch.MISMATCH;\n          continue;\n        }\n      }\n\n      // check pre-ocl guard\n      // if (!tv.oclUpdateCondition_PARSED(data, olddata)) continue;\n\n      if (datachanged || tnv.OCLScore === ViewEClassMatch.NOT_EVALUATED_YET) {\n        // check ocl: this can lead to mis-updating if ocl queries a reference.\n        // but OCL is computationally heavy, so i decided it is now a requirement to update the model to reevaluate ocl.\n        let oldScore = tnv.OCLScore;\n        tnv.OCLScore = OCL.test(data, dview, node); //Selectors.calculateOCLScore({data, node, dview});\n        tv.oclChanged = false;\n        if (!needsorting && tnv.OCLScore !== oldScore) needsorting = true;\n        if (tnv.OCLScore === ViewEClassMatch.MISMATCH_OCL) {\n          tnv.finalScore = ViewEClassMatch.MISMATCH;\n          continue;\n        }\n      }\n    }\n    if (parentViewChanged) needsorting = true; // scores saved in dictionaries are the same, but score in final sorted array changed.\n    return needsorting;\n  }\n\n  // get final viewstack for a node, also updates OCL scores if needed because of a change in model or parentView (NOT from a change in view)\n  static getAppliedViewsNew(_ref) {\n    let {\n      data: data0,\n      node,\n      pv,\n      nid\n    } = _ref;\n    // console.trace('2302, getviews', {tnode: transientProperties.node[nid], nid, pv})\n    let state = store.getState();\n    let needsorting = Selectors.updateScores(data0, node, nid, pv, state);\n    let tn = transientProperties.node[nid]; // needs to be placed after updateScores() which will initialize it.\n\n    if (needsorting || !tn.stackViews) {\n      var _mainViews$;\n      let mainViews = [];\n      let decorativeViews = [];\n      // problem: if view is created or deleted from someone in coop, it might not update tv.viewScores\n      // need to operate on reducer on both creation and removal\n      for (let vid of Object.keys(tn.viewScores)) {\n        let tnv = tn.viewScores[vid];\n        const dview = DPointerTargetable.fromPointer(vid, state);\n        const score = tnv.finalScore = Selectors.getFinalScore(tnv, vid, pv, dview);\n        if (!(score > 0)) continue; // do not flip to <=, because undefined and NEGATIVE_INFINITY always compute to false.\n        (dview.isExclusiveView ? mainViews : decorativeViews).push({\n          element: vid,\n          score,\n          view: LPointerTargetable.fromD(dview)\n        });\n      }\n      decorativeViews.sort((s1, s2) => s2.score - s1.score); // sorted from biggest to smallest\n      mainViews.sort((s1, s2) => s2.score - s1.score); // sorted from biggest to smallest\n\n      // Log.exDev(!mainViews[0], 'cannot find a matching main view', {mainViews, decorativeViews, data0, scores: tn.viewScores})\n      tn.mainView = (_mainViews$ = mainViews[0]) === null || _mainViews$ === void 0 ? void 0 : _mainViews$.view;\n      tn.validMainViews = mainViews.map(s => s.view); // this have duplicates of newly created elements\n      tn.stackViews = decorativeViews.map(s => s.view);\n    }\n    // chamges to view or ocl comditiom are mot hamdled here, ut om multple mp/modes a omce\n    //nb{}[]\n\n    // if data or view changed update the score dict, them re-sort the view arr first, fimally update Sorted_modelused, Sorted_modelused\n    // console.log('2302 getviews ret', {dn: data?.name, data, stack: transientProperties.node[nid].stackViews, stackn: transientProperties.node[nid].stackViews.map(v => v.name), scores: transientProperties.node[nid]});\n\n    // throw new Error(\"stop debug\");\n    return tn;\n  }\n  static getAllMP(state) {\n    if (!state) state = store.getState();\n    let allD = Object.values(state.idlookup);\n    return allD.filter(d => U.isObject(d) && Selectors.isOfSubclass(d, DModelElement));\n  }\n  static toObject(ptrs, state) {\n    if (!state) state = store.getState();\n    return ptrs.map(p => state.idlookup[p]);\n  }\n  static wrap(arr, state) {\n    if (!arr.length) return [];\n    if (!state) state = store.getState();\n    let objarr;\n    if (typeof arr[0] === \"string\") {\n      objarr = Selectors.toObject(arr, state);\n    } else objarr = arr;\n    return objarr.map(p => RuntimeAccessibleClass.wrap(p));\n  }\n  static unwrap(arr) {\n    return arr.map(a => a.__raw);\n  }\n  static getSubNodeElements(forGraph) {\n    let asPointers = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    let wrap = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    const state = store.getState();\n    const g = state.idlookup[forGraph];\n    if (asPointers) return g.subElements;\n    const subelements = g.subElements.map(geid => state.idlookup[geid]);\n    if (wrap) return subelements.map(ge => LPointerTargetable.from(ge));\n    return subelements;\n  }\n\n  //// giordano part\n\n  static getAllPackageClasses(id) {\n    const data = LPointerTargetable.from(id);\n    let lPackage;\n    const classes = [];\n    if (data.className === \"DReference\") {\n      const lClass = LPointerTargetable.from(data.father);\n      lPackage = LPointerTargetable.from(lClass.father);\n    }\n    if (data.className === \"DParameter\") {\n      const lOperation = LPointerTargetable.from(data.father);\n      const lClass = LPointerTargetable.from(lOperation.father);\n      lPackage = LPointerTargetable.wrap(lClass.father);\n    }\n    if (data.className === \"DOperation\") {\n      const lClass = LPointerTargetable.from(data.father);\n      lPackage = LPointerTargetable.wrap(lClass.father);\n    }\n    if (lPackage) {\n      for (let classifier of lPackage.classifiers) {\n        const lClassifier = LPointerTargetable.from(classifier);\n        if (lClassifier.className === \"DClass\") classes.push(lClassifier);\n      }\n    }\n    return classes;\n  }\n  static getAllPackageEnumerators(id) {\n    const data = LPointerTargetable.from(id);\n    let lPackage;\n    const enumerators = [];\n    if (data.className === \"DAttribute\") {\n      const lClass = LPointerTargetable.from(data.father);\n      lPackage = LPointerTargetable.from(lClass.father);\n    }\n    if (data.className === \"DParameter\") {\n      const lOperation = LPointerTargetable.from(data.father);\n      const lClass = LPointerTargetable.from(lOperation.father);\n      lPackage = LPointerTargetable.from(lClass.father);\n    }\n    if (data.className === \"DOperation\") {\n      const lClass = LPointerTargetable.from(data.father);\n      lPackage = LPointerTargetable.from(lClass.father);\n    }\n    if (lPackage) {\n      for (let classifier of lPackage.classifiers) {\n        const lClassifier = LPointerTargetable.from(classifier);\n        if (lClassifier.className === \"DEnumerator\") enumerators.push(lClassifier);\n      }\n    }\n    return enumerators;\n  }\n  static updateJSScore(node, data, dview, tv, tnv) {\n    let oldjsScore = tnv.jsScore;\n    let jsConditionChanged = tv.jsConditionChanged;\n    tv.jsConditionChanged = false;\n\n    // tnv.jsScore = ViewEClassMatch.NOT_EVALUATED_YET as any as number;\n    let printstuff = {\n      name: data === null || data === void 0 ? void 0 : data.name,\n      jsc: tv.jsCondition,\n      tv: {\n        ...tv\n      },\n      data: data && data.__raw,\n      node: node && {\n        ...node.__raw\n      },\n      nerr: node === null || node === void 0 ? void 0 : node.errors\n    };\n    if (tv.jsCondition) {\n      try {\n        tnv.jsScore = tv.jsCondition({\n          data,\n          node,\n          view: LPointerTargetable.fromD(dview),\n          constants: tv.constants\n        });\n        // if (tnv.jsScore === true) tnv.jsScore = dview.jsCondition.length;\n        switch (typeof tnv.jsScore) {\n          case \"boolean\":\n            // bool is fine if true\n            if (!tnv.jsScore) tnv.jsScore = ViewEClassMatch.MISMATCH_JS;\n            break;\n          case \"number\":\n            // number is fine if not NaN and > 0\n            if (isNaN(tnv.jsScore) || tnv.jsScore < 0) tnv.jsScore = ViewEClassMatch.MISMATCH_JS;\n            break;\n          default:\n            tnv.jsScore = ViewEClassMatch.MISMATCH_JS;\n            break;\n        }\n      } catch (e) {\n        var _e$message;\n        // crash = mismatch\n        Log.ee(\"failed to evaluate jsCondition: \" + ((_e$message = e.message) === null || _e$message === void 0 ? void 0 : _e$message.split(\"\\n\")[0]), {\n          e,\n          data,\n          node,\n          tnv,\n          jsc: tv.jsCondition + ''\n        });\n        tnv.jsScore = ViewEClassMatch.MISMATCH_JS;\n      }\n    } else tnv.jsScore = true; // missing condition = match\n\n    // jsConditionChanged: because even if score didn't change, if jsc.length changed the final computed score is affected\n    return jsConditionChanged || tnv.jsScore !== oldjsScore;\n  }\n}, _class2.getQueryComplexity = query => query.length, _class2)) || _class);\nwindow.Selectors = Selectors;\nclass Scored {\n  constructor(score, element) {\n    this.score = score;\n    this.element = element;\n  }\n}","map":{"version":3,"names":["LUser","DUser","DViewElement","DPointerTargetable","DModel","DModelElement","OCL","Log","LPointerTargetable","RuntimeAccessible","RuntimeAccessibleClass","store","U","toShortEType","NodeTransientProperties","transientProperties","ViewEClassMatch","ShortDefaultEClasses","toShortEClass","Selectors","_dec","_class","_class2","getActiveModel","_state$_lastSelected","metamodel","state","getState","selected","_lastSelected","modelElement","me","fromPointer","model","getLastSelectedModel","_state$_lastSelected2","ret","element","isMetamodel","m2","m1","instanceof","getAllViewElements","state0","ptrs","Object","values","viewelements","views","map","ptr","getViewpoints","viewpoints","getViewpoint","viewpoint","getObjects","objects","dObjects","idlookup","lObjects","dObject","push","id","getValues","dValues","lValues","dValue","getDeleted","deleted","getDefaultEcoreClass","type","shorttype","toUpperCase","EObject","getPrimitiveType","getAllPrimitiveTypes","primitiveTypes","classifiers","getFirstPrimitiveTypes","getRefEdges","pointers","refEdges","dRefEdges","getField","field","getAllAttributes","attributes","getAllEnumLiterals","enumliterals","getAllReferences","references","getAllClasses","classs","getReturnTypes","from","returnTypes","getAllClassesWithoutPrimitive","classList","splice","length","getAllEnumerators","flag","arguments","undefined","enumerators","getAllPackages","packages","getAllParameters","parameters","getAllOperations","operations","getDElement","pointer","dElement","getAllMetamodels","dModels","m2models","getAllModels","m1models","getVertex","wrap","resolvePointers","ArrayMerge0","voidvertexs","vertexs","graphvertexs","edgepoints","console","log","g","graphs","vv","v","gv","ep","p","r","getAll","Classe","condition","GClass","name","cname","className","staticClassName","toLowerCase","allIdByClassName","substr","exDev","allDByClassName","allLByClassName","e","Array","isArray","filter","getModels","getModel","caseSensitive","d","getByName","classe","getByField","value","_d$field","dfield","getViewIDs","queryJS","query","eval","matchesMetaClassTarget","data","MISMATCH_PRECONDITIONS","appliableToClasses","IMPLICIT_MATCH","ThisClass","get","gotSubclassMatch","classtarget","ClassTarget","EXACT_MATCH","classIsExtending","INHERITANCE_MATCH","isOfSubclass","classTarget","acceptEquality","getViewByIDOrNameD","_state$idlookup$name","_state$idlookup$id","__raw","getViewIdFromName","namepath","names","split","eligibleContainers","i","flatMap","keys","subViews","getAllGraphElementPointers","graphelements","edges","getFinalScore","entry","vid","parentView","dview","metaclassScore","MISMATCH","viewPointMatch","VP_MISMATCH","jsScore","MISMATCH_JS","OCLScore","pvMatch","pvScore","explicitprio","explicitApplicationPriority","_dview$jsCondition","_dview$oclCondition","jsCondition","oclCondition","updateScores","data0","node","nid","pv","needsorting","firstEvaluationForNode","firstEvaluationForNodeView","tn","olddata","viewSorted_modelused","pvid","oldpv","viewSorted_pvid_used","datachanged","clonedCounter","parentViewChanged","allViews","user","current","project","activevpid","activeViewpoint","tv","view","tnv","viewScores","NOT_EVALUATED_YET","dvp","oldVpMatch","VP_Explicit","VP_Default","isExclusiveView","VP_Decorative","finalScore","oldScore","jsScoreChanged","updateJSScore","test","oclChanged","MISMATCH_OCL","getAppliedViewsNew","_ref","stackViews","_mainViews$","mainViews","decorativeViews","score","fromD","sort","s1","s2","mainView","validMainViews","s","getAllMP","allD","isObject","toObject","arr","objarr","unwrap","a","getSubNodeElements","forGraph","asPointers","subElements","subelements","geid","ge","getAllPackageClasses","lPackage","classes","lClass","father","lOperation","classifier","lClassifier","getAllPackageEnumerators","oldjsScore","jsConditionChanged","printstuff","jsc","nerr","errors","constants","isNaN","_e$message","ee","message","getQueryComplexity","window","Scored","constructor"],"sources":["C:/d/Programming/web/jodel-mde/src/redux/selectors/selectors.ts"],"sourcesContent":["import {\r\n    AbstractConstructor,\r\n    AttribETypes,\r\n    Constructor,\r\n    DAttribute,\r\n    DClass,\r\n    DClassifier,\r\n    DEnumerator,\r\n    DGraph,\r\n    DGraphElement,\r\n    DObject,\r\n    DRefEdge,\r\n    DState,\r\n    DValue,\r\n    DVoidVertex,\r\n    GObject,\r\n    LClass,\r\n    LEnumerator,\r\n    LGraphElement,\r\n    LModel,\r\n    LModelElement,\r\n    LObject,\r\n    LOperation,\r\n    LPackage,\r\n    LRefEdge,\r\n    LValue,\r\n    LViewElement,\r\n    LViewPoint,\r\n    LVoidVertex,\r\n    Pointer,\r\n    ShortAttribETypes,\r\n    Dictionary,\r\n    LUser,\r\n    DUser,\r\n    Defaults, LProject, ViewScore,\r\n    DViewElement,\r\n    DPointerTargetable,\r\n    DModel,\r\n    DModelElement,\r\n    OCL,\r\n    Log,\r\n    LPointerTargetable,\r\n    RuntimeAccessible,\r\n    RuntimeAccessibleClass,\r\n    store,\r\n    U,\r\n    toShortEType,\r\n    NodeTransientProperties, transientProperties, ViewEClassMatch, ViewTransientProperties, DProject, DViewPoint\r\n} from \"../../joiner\";\r\nimport {DefaultEClasses, ShortDefaultEClasses, toShortEClass} from \"../../common/U\";\r\n\r\n\r\n@RuntimeAccessible('Selectors')\r\nexport class Selectors{\r\n\r\n    static getActiveModel(): null|LModel {\r\n        let metamodel: null|LModel;\r\n        let state: DState & GObject = store.getState();\r\n        const selected = state._lastSelected?.modelElement;\r\n        if(selected) {\r\n            const me = LPointerTargetable.fromPointer(selected)\r\n            metamodel = (me) ? me.model : null;\r\n        } else metamodel = null;\r\n        return metamodel;\r\n    }\r\n\r\n    public static getLastSelectedModel<RET extends {m1?:LModel, m2?:LModel, model?:LModel, element?:LModelElement}>(state?: DState): RET {\r\n        state = state || store.getState();\r\n        let me = state._lastSelected?.modelElement;\r\n        if (!me) return {} as RET;\r\n        let ret: RET = {element: LPointerTargetable.fromPointer(me, state)} as RET;\r\n        ret.model = ret.element!.model\r\n        if (ret.model.isMetamodel) ret.m2 = ret.model;\r\n        else {\r\n            ret.m1 = ret.model;\r\n            ret.m2 = ret.m1.instanceof;\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    static getAllViewElements(state0?: DState): DViewElement[] {\r\n        // return Object.values(store.getState().idlookup).filter(v => v.className === DViewElement.name) as DViewElement[];\r\n        const state: GObject<DState> = state0 || store.getState();\r\n        const ptrs: Pointer<DViewElement>[] = Object.values((state).viewelements);\r\n        let views: DViewElement[] = ptrs.map<DViewElement>( (ptr) => DPointerTargetable.fromPointer(ptr, state) as DViewElement);\r\n        return views;\r\n    }\r\n    //Giordano: start\r\n\r\n    public static getViewpoints() : LViewPoint[] {\r\n        const state: DState & GObject = store.getState();\r\n        return LPointerTargetable.fromPointer(state.viewpoints);\r\n    }\r\n    public static getViewpoint() : LViewPoint {\r\n        const state: DState & GObject = store.getState();\r\n        return LPointerTargetable.fromPointer(state.viewpoint);\r\n    }\r\n\r\n    public static getObjects(): LObject[] {\r\n        let state: DState & GObject = store.getState();\r\n        const ptrs: Pointer<DObject, 0, 'N'> = Object.values((state).objects);\r\n        const dObjects: DObject[] = ptrs.map<DObject>( (ptr) => state.idlookup[ptr] as DObject);\r\n        const lObjects: LObject[] = [];\r\n        for(let dObject of dObjects) {\r\n            lObjects.push(LPointerTargetable.fromPointer(dObject.id));\r\n        }\r\n        return lObjects;\r\n    }\r\n    public static getValues(): LValue[] {\r\n        let state: DState & GObject = store.getState();\r\n        const ptrs: Pointer<DValue, 0, 'N'> = Object.values((state).values);\r\n        const dValues: DValue[] = ptrs.map<DValue>( (ptr) => state.idlookup[ptr] as DValue);\r\n        const lValues: LValue[] = [];\r\n        for(let dValue of dValues) {\r\n            if(dValue?.id) {\r\n                lValues.push(LPointerTargetable.fromPointer(dValue.id));\r\n            }\r\n        }\r\n        return lValues;\r\n    }\r\n\r\n    public static getDeleted(): string [] {\r\n        const state: DState & GObject = store.getState();\r\n        return state.deleted;\r\n    }\r\n\r\n    public static getState(): any {\r\n        const state: DState & GObject = store.getState();\r\n        return state;\r\n    }\r\n\r\n    static getDefaultEcoreClass(type: DefaultEClasses | ShortDefaultEClasses, state?: DState): DClassifier {\r\n        let shorttype: string = (toShortEClass(type as any) || type).toUpperCase();\r\n        if (!state) state = store.getState();\r\n        // todo: make other m3 classes and make this generic like getPrimitiveType\r\n        return state.idlookup[\"Pointer_\"+ShortDefaultEClasses.EObject.toUpperCase()] as DClassifier;\r\n    }\r\n    static getPrimitiveType(type: AttribETypes | ShortAttribETypes, state?: DState): DClassifier {\r\n        let shorttype: string = (toShortEType(type as any) || type).toUpperCase();\r\n        if (!state) state = store.getState();\r\n        return state.idlookup[\"Pointer_\"+shorttype] as DClassifier;\r\n    }\r\n    static getAllPrimitiveTypes(): DClassifier[] {\r\n        let state: DState & GObject = store.getState();\r\n        const ptrs: Pointer<DClassifier, 0, 'N'> = Object.values((state).primitiveTypes);\r\n        const classifiers: DClassifier[] = ptrs.map<DClassifier>( (ptr) => state.idlookup[ptr] as DClassifier);\r\n        return classifiers;\r\n    }\r\n    static getFirstPrimitiveTypes(): DClassifier {\r\n        return Selectors.getAllPrimitiveTypes()[0];\r\n    }\r\n    static getRefEdges(): DRefEdge[] {\r\n        const state: DState & GObject = store.getState();\r\n        const pointers: Pointer<DRefEdge, 0, 'N', LRefEdge> = Object.values((state).refEdges);\r\n        const dRefEdges: DRefEdge[] = pointers.map<DRefEdge>( (ptr) => state.idlookup[ptr] as DRefEdge);\r\n        return dRefEdges;\r\n    }\r\n    static getField(field: string): string[] {\r\n        let state: DState & GObject = store.getState();\r\n        const pointers: Pointer<DModelElement, 0, 'N'> = Object.values((state)[field]);\r\n        return pointers;\r\n    }\r\n\r\n    static getAllAttributes(): string[] {\r\n        const state: DState = store.getState();\r\n        return Object.values((state).attributes);\r\n    }\r\n    static getAllEnumLiterals(): string[] {\r\n        const state: DState = store.getState();\r\n        return Object.values((state).enumliterals);\r\n    }\r\n    static getAllReferences(): string[] {\r\n        const state: DState = store.getState();\r\n        return Object.values((state).references);\r\n    }\r\n    // static getAllReferenceEdges(): string[] { const state: DState = store.getState(); return Object.values((state).refEdges); }\r\n    static getAllClasses(): string[] {\r\n        const state: DState = store.getState();\r\n        return Object.values((state).classs);\r\n    }\r\n    static getReturnTypes(): LClass[] {\r\n        const state: DState = store.getState();\r\n        return LPointerTargetable.from(Object.values((state).returnTypes));\r\n    }\r\n\r\n    static getAllClassesWithoutPrimitive(): string[] {\r\n        // this solution does not look good. what if a primitive type is inserted at runtime in between?\r\n        // coould reach the same goal by taking all Classes of a model (m2), excluding classes from other models (types are classes from m3 model)\r\n        const state: DState = store.getState();\r\n        const classList: string[] = Object.values((state).classs);\r\n        classList.splice(0, Selectors.getAllPrimitiveTypes().length);\r\n        /* todo: need to change it in something like this once cross-references between models and instances are implemented\r\n        const m2: LModel;\r\n        m2.isInstanceOf = m3 as LModel;\r\n        m2.isInstanceOf.classes;*/\r\n\r\n        return classList;\r\n    }\r\n\r\n    static getAllEnumerators(flag = false): string[] {\r\n        const state: DState = store.getState();\r\n        return Object.values((state).enumerators);\r\n    }\r\n    static getAllPackages(): string[] {\r\n        const state: DState = store.getState();\r\n        return Object.values((state).packages);\r\n    }\r\n\r\n    static getAllParameters(): string[] {\r\n        const state: DState = store.getState();\r\n        return Object.values((state).parameters);\r\n    }\r\n    static getAllOperations(): string[] {\r\n        const state: DState = store.getState();\r\n        return Object.values((state).operations);\r\n    }\r\n\r\n    static getDElement<T extends DModelElement>(pointer: string): T {\r\n        const state: DState & GObject = store.getState();\r\n        const dElement: T = state.idlookup[pointer] as T;\r\n        return dElement;\r\n    }\r\n\r\n    static getAllMetamodels(): LModel[] {\r\n        const state: DState = store.getState();\r\n        const dModels = Object.values((state).m2models);\r\n        return LPointerTargetable.fromPointer(dModels);\r\n    }\r\n\r\n    static getAllModels(): LModel[] {\r\n        const state: DState = store.getState();\r\n        const dModels = Object.values((state).m1models);\r\n        return LPointerTargetable.fromPointer(dModels);\r\n    }\r\n\r\n    //Giordano: end\r\n\r\n    static getVertex<W extends boolean = true, RP extends boolean = true>(wrap?: W /* = true */, resolvePointers?: RP /**/):\r\n        W extends false ? (RP extends false ? Pointer<DVoidVertex, 1, 1, LVoidVertex>[] : DVoidVertex[]) : LVoidVertex[] {\r\n        const state: DState = store.getState();\r\n        let ptrs: Pointer<DVoidVertex>[] = [];\r\n\r\n        U.ArrayMerge0(false, ptrs,\r\n            // Object.values(state.graphs || {}),\r\n            Object.values(state.voidvertexs || {}),\r\n            Object.values(state.vertexs || {}),\r\n            Object.values(state.graphvertexs || {}),\r\n            Object.values(state.edgepoints || {}));\r\n\r\n        console.log('selector getvertex: ', {ptrs, g: Object.values(state.graphs || {}), vv:Object.values(state.voidvertexs || {}), v:Object.values(state.vertexs || {}), gv:Object.values(state.graphvertexs || {}), ep:Object.values(state.edgepoints || {})});\r\n        if (wrap === undefined || wrap === true) return ptrs.map( p => DPointerTargetable.wrap(p)) as any[];\r\n        if (resolvePointers === undefined || resolvePointers === true) return ptrs.map( r => state.idlookup[r]) as any[];\r\n        return ptrs as any[];\r\n    }\r\n\r\n    static getAll<D extends DPointerTargetable, L extends LPointerTargetable, DT extends typeof DPointerTargetable = typeof DPointerTargetable,\r\n        W extends undefined | true | false = false, RP extends undefined | true | false = true, RET = W extends false ? (RP extends false ? Pointer<D, 1, 1, L> : D) : L>\r\n        (Classe?: DT, condition?: (e:RET) => boolean, state?: DState, resolvePointers?: RP /**/, wrap?: W /* = true */): RET[] {\r\n        if (!state) state = store.getState();\r\n        let GClass = (Classe as GObject) || {name:\"idlookup\", cname:\"idlookup\"};\r\n        const className: string = (GClass?.staticClassName || GClass.cname).toLowerCase();\r\n        const allIdByClassName: Pointer<D, 1, 1, L>[]\r\n            = (state as GObject)[className]\r\n            || (state as GObject)[className.substr(1)]\r\n            || (state as GObject)[className + 's']\r\n            || (state as GObject)[className.substr(1) + 's'];\r\n        Log.exDev(!allIdByClassName, 'cannot find store key:', {state, className, Classe});\r\n        let allDByClassName: D[] | null = null;\r\n        let allLByClassName: L[] | null = null;\r\n        if (resolvePointers || wrap) {\r\n            allDByClassName = allIdByClassName.map( (e) => (state as DState).idlookup[e] ) as D[];\r\n            if (wrap) {\r\n                allLByClassName = allDByClassName.map( e => DPointerTargetable.wrap(e)) as any as L[];\r\n            }\r\n        }\r\n        let ret: RET[] = (resolvePointers || wrap ? (wrap ? allLByClassName : allDByClassName) : allIdByClassName) as any[] as RET[];\r\n        if (!Array.isArray(ret)) ret = Object.values(ret).filter(e => e instanceof Object) as RET[];\r\n        if (condition) return ret.filter( e => condition(e));\r\n        return ret;\r\n    }\r\n\r\n    static getModels(condition?: (m: DModel) => boolean): DModel[] { return Selectors.getAll(DModel, undefined, undefined, true, false); }\r\n\r\n    static getModel(name: string, caseSensitive: boolean = false, wrap: boolean = false): DModel | LModel | null {\r\n        if (!caseSensitive) name = name.toLowerCase();\r\n        let ret = Selectors.getAll<DModel, LModel>(DModel, (d) => (caseSensitive ? d.name : d.name.toLowerCase()) === name, undefined, true, wrap as any)[0];\r\n        return ret;\r\n    }\r\n\r\n    static getByName(classe: typeof DPointerTargetable, name: string, caseSensitive: boolean = false, wrap: boolean = false): DPointerTargetable | LPointerTargetable | null {\r\n        return Selectors.getByField(classe, 'name', name, caseSensitive, wrap); }\r\n\r\n    static getByField(classe: typeof DPointerTargetable, field: string, value: string, caseSensitive: boolean = false, wrap: boolean = false): DPointerTargetable | LPointerTargetable | null {\r\n        if (!caseSensitive) value = value.toLowerCase();\r\n        let condition = (d: any) => {\r\n            let ret = (caseSensitive ? d[field] : d[field]?.toLowerCase()) === value;\r\n            console.log('filtering getall by field:', {d, dfield:d[field], value, ret});\r\n            return ret;\r\n        }\r\n        let ret = Selectors.getAll(classe, condition, undefined, true, wrap as any)[0];\r\n        return ret; }\r\n\r\n    static getViewIDs(condition?: (m: DModel) => boolean): Pointer<DViewElement>[] { return Selectors.getAll(DViewElement); }\r\n\r\n\r\n\r\n    private static queryJS(model: LModel, query: string): LPointerTargetable[] {\r\n        try {\r\n            return eval(query);\r\n        } catch (e) { return []; }\r\n    }\r\n    /*static getCurrentView(data: LModelElement): DViewElement {\r\n        Log.exDevv('todo');\r\n        return undefined as any;\r\n    }*/\r\n\r\n    private static matchesMetaClassTarget(v: DViewElement, data?: DModelElement | DGraphElement | undefined): number {\r\n        if (!v) return ViewEClassMatch.MISMATCH_PRECONDITIONS;\r\n        if (!v.appliableToClasses || !v.appliableToClasses.length) return ViewEClassMatch.IMPLICIT_MATCH;\r\n        if (!data) return ViewEClassMatch.MISMATCH_PRECONDITIONS;\r\n        let ThisClass: typeof DPointerTargetable = RuntimeAccessibleClass.get(data.className);\r\n        Log.exDev(!ThisClass, 'unable to find class type:', {v, data}); // todo: v = view appliable to DModel, data = proxy<LModel>\r\n        let gotSubclassMatch: boolean = false;\r\n        for (let classtarget of v.appliableToClasses) {\r\n            const ClassTarget: typeof DPointerTargetable = RuntimeAccessibleClass.get(classtarget);\r\n            if (ThisClass === ClassTarget) return ViewEClassMatch.EXACT_MATCH; // explicit exact match\r\n            if (!gotSubclassMatch && U.classIsExtending(ThisClass, ClassTarget)) gotSubclassMatch = true; // explicit subclass match\r\n            if (gotSubclassMatch) return ViewEClassMatch.INHERITANCE_MATCH;\r\n        }\r\n        return ViewEClassMatch.MISMATCH_PRECONDITIONS;\r\n }\r\n\r\n    private static isOfSubclass(data: DPointerTargetable, classTarget: string | typeof DPointerTargetable, acceptEquality: boolean = false): boolean {\r\n        let ThisClass: typeof DPointerTargetable = RuntimeAccessibleClass.get(data.className);\r\n        Log.exDev(!ThisClass, 'isOfSubclass() unable to find class type:', {data});\r\n        const ClassTarget: typeof DPointerTargetable = typeof classTarget === \"string\"? RuntimeAccessibleClass.get(classTarget) : classTarget;\r\n        if (ThisClass === ClassTarget) return acceptEquality;\r\n        return U.classIsExtending(ThisClass, ClassTarget);\r\n    }\r\n\r\n\r\n    static getViewByIDOrNameD(name: string | DViewElement | LViewElement, state?: DState): undefined | DViewElement {\r\n        if (!state) state = store.getState();\r\n        if (typeof name === \"object\") { return (name as any).__raw || name as any; }\r\n        if (state.idlookup[name]?.className === DViewElement.cname) return state.idlookup[name] as DViewElement;\r\n        let id = Selectors.getViewIdFromName(name, state);\r\n        if (id && state.idlookup[id]?.className === DViewElement.cname) return state.idlookup[id] as DViewElement;\r\n        return undefined;\r\n    }\r\n\r\n\r\n    // input: \"subview.subview2.targetview\"\r\n    // output: returns pointer to targetview\r\n    // path is not required to start with a root, it's also possible to start navigating from a subview (notviewpoint/model view)\r\n    // in case multiple matches are given due to incomplete path not starting from a viewpoint, the oldest matching view is returned.\r\n    static getViewIdFromName(namepath: string, state?: DState): undefined | Pointer<DViewElement> {\r\n        if (!state) state = store.getState();\r\n        let names: string[] = namepath.split(\".\");\r\n        let eligibleContainers: Pointer<DViewElement>[] = state.viewelements;\r\n        for (let i = 0; i < names.length; i++) {\r\n            let name = names[i];\r\n            eligibleContainers = eligibleContainers.filter(v => ((state as DState).idlookup[v] as DViewElement).name === name);\r\n            if (i === names.length-1 || eligibleContainers.length === 0) return eligibleContainers[0];\r\n            eligibleContainers = eligibleContainers.flatMap(v => Object.keys(((state as DState).idlookup[v] as DViewElement).subViews));\r\n        }\r\n        return undefined;\r\n    }\r\n\r\n\r\n    // todo: idea, set query complexity = explicitpriority amd autoset explicit priority to query lemgth\r\n    private static getQueryComplexity = (query: string) => query.length; // todo: the more \"or\" and navigations there are, the more a query is \"complex\", the more the query match is a priority.\r\n\r\n\r\n    static getAllGraphElementPointers(): Pointer<DGraphElement>[] {\r\n        // graphelements = fields;\r\n        let state: DState = store.getState();\r\n        return [...state.graphs, ...state.graphvertexs, ...state.graphelements, ...state.vertexs, ...state.edgepoints, ...state.edges];\r\n    }\r\n\r\n    private static getFinalScore(entry: ViewScore, vid: Pointer<DViewElement>, parentView: DViewElement | undefined, dview: DViewElement): number {\r\n        if (entry.metaclassScore === ViewEClassMatch.MISMATCH_PRECONDITIONS) return ViewEClassMatch.MISMATCH;\r\n        if (entry.viewPointMatch === ViewEClassMatch.VP_MISMATCH) return ViewEClassMatch.MISMATCH;\r\n        if (entry.jsScore === ViewEClassMatch.MISMATCH_JS || entry.OCLScore === ViewEClassMatch.MISMATCH_JS) return ViewEClassMatch.MISMATCH;\r\n        let pvMatch: boolean = parentView ? vid in parentView.subViews : false;\r\n        let pvScore: number = pvMatch ? (parentView as DViewElement).subViews[vid] : 1;\r\n        let explicitprio: number;\r\n        if (typeof entry.jsScore === 'number') {\r\n            explicitprio = entry.jsScore;\r\n        } else if (dview.explicitApplicationPriority === undefined) {\r\n            // in editor put placeholder with computed expression\r\n            explicitprio = (dview.jsCondition?.length || 1) + (dview.oclCondition?.length || 1);\r\n        } else explicitprio = dview.explicitApplicationPriority;\r\n\r\n        return entry.viewPointMatch * entry.metaclassScore * pvScore * explicitprio;\r\n        //score = precoditiom * paremtview(comfiguravle) * (explicitprio = jsValid*jslemgth + oclvalid*ocllemgth)\r\n        // or if jscomditiom returmed mumver --> * jsscore\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n/*\r\n    //this function handles: what i do when view changes? do i recompute the score?\r\n    static updateViewMatchings(dview: DViewElement, updatePreconditions: boolean, updateOCLScore: boolean, store: DState, updateManualViews: boolean = false, forcedUpdateViews: boolean = false): void {\r\n\r\n        //  event           observed change         ignore change\r\n        //  ocl             data                    node, view (except view.ocl)\r\n        //  jsCondition     all                     none\r\n        //  appliableTo     view.appliableto\r\n        // if (!forcedUpdateViews && (dview.oclUpdateCondition === 'manual') !== updateManualViews) return;\r\n        // modularize getscoresnew split in setpreconditionscore, setoclscorem, setjscscore, and call those only if observed stuff changed\r\n\r\n        const allNodes: DGraphElement[] = DPointerTargetable.fromPointer(Selectors.getAllGraphElementPointers());\r\n        //let dview = view.__raw;\r\n        let vid = dview.id; // optimize searching multiple usages and replacing\r\n\r\n        // filter alldata to exclude modelpieces that didn't pass the view.appyto check\r\n        // let oclData: (LModelElement)[] = allData.filter(l => {\r\n        let oclnodes: (DGraphElement)[] = allNodes.filter((dg: DGraphElement) => {\r\n            if (!dg) return false;\r\n            if (true) {\r\n                let d: DModelElement | undefined = dg.model ? DPointerTargetable.fromPointer(dg.model) : undefined;\r\n                let firstEvaluationForNodeView: boolean = false;\r\n                if (!transientProperties.node[dg.id]) { transientProperties.node[dg.id] = {viewScores: {}} as any; firstEvaluationForNodeView = true; }\r\n                if (!transientProperties.node[dg.id].viewScores[vid]) { transientProperties.node[dg.id].viewScores[vid] = {score: undefined} as any; firstEvaluationForNodeView = true; }\r\n\r\n                if (firstEvaluationForNodeView || updatePreconditions) {\r\n                    const oldScore = transientProperties.node[dg.id].viewScores[vid].score;\r\n                    const newScore = transientProperties.node[dg.id].viewScores[vid].score = this.matchesMetaClassTarget(dview, d);\r\n                    if (oldScore !== newScore) transientProperties.node[dg.id].stackViews = undefined as any; // force re-sorting\r\n                    // 67{}[]'?^&&||nb>\r\n                } /* else {\r\n                    if (!transientProperties.view[dview.id].oclUpdateCondition_PARSED( transientProperties.node[dg.id].viewScores[vid].)) return;\r\n                }* /\r\n                // no need to check if parentview changed as well. i optimized by not having parentview affect the numeric scores, but only the view queue array sorting\r\n\r\n                // transient.node[dg.id].viewScores[vid].score = MISSING (hasOwnProperty);    if the view or model is new and they are not yet evaluated.\r\n                // transient.node[dg.id].viewScores[vid].score = Number.NEGATIVE_INFINITY;    if pre-ocl conditions failed (view.appliableTo)\r\n                // transient.node[dg.id].viewScores[vid].score = 0;                           if preconditions are met, but ocl failed\r\n                // transient.node[dg.id].viewScores[vid].score = number ocl score;            if preconditions are met and ocl matched\r\n                // transient.node[dg.id].viewScores[vid].score = number precondition score;   if preconditions are met, and there is no ocl condition\r\n                // changed: matching score and ocl score are summed.\r\n                return transientProperties.node[dg.id].viewScores[vid].score !== undefined;\r\n            }\r\n\r\n            // if (model_viewstack[vid]) { filledElementsInOclData++; return l; } return undefined;\r\n        });\r\n        function mergeViewScores(preconditionScore: number, oclScore: number): number{ return preconditionScore + oclScore; }\r\n    }*/\r\n\r\n\r\n\r\n\r\n    static updateScores(data0: LModelElement | undefined, node: LGraphElement | undefined, nid: Pointer<DGraphElement>, pv: DViewElement | undefined, state: DState){\r\n        let needsorting: boolean = false;\r\n        let firstEvaluationForNode: boolean = false;\r\n        let firstEvaluationForNodeView: boolean = false;\r\n        let tn = transientProperties.node[nid];\r\n        if (!tn) { transientProperties.node[nid] = tn = new NodeTransientProperties(); firstEvaluationForNode = true; }\r\n        let olddata = tn.viewSorted_modelused as LModelElement;\r\n        //let oldnode = transientProperties.node[nid]?.viewSorted_nodeused as LGraphElement;\r\n        const data: LModelElement = data0 as LModelElement;\r\n        // console.error('changed', {data, olddata, node, oldnode, cdata:data?.clonedCounter, colddata:olddata?.clonedCounter})\r\n        const pvid: Pointer<DViewElement> | undefined = pv?.id;\r\n        const oldpv: DViewElement | undefined = tn.viewSorted_pvid_used;\r\n        let datachanged: boolean = (!!data !== !!olddata) || !!(data && olddata) && (data.clonedCounter !== olddata.clonedCounter);\r\n        //let nodechanged: boolean = (!!node !== !!oldnode) || !!(node && oldnode) && (node.clonedCounter !== oldnode.clonedCounter);\r\n        let parentViewChanged: boolean = (pvid !== oldpv?.id || (!!(pv && oldpv) && oldpv.subViews !== pv.subViews)); // shallow comparison is fine.\r\n        if (parentViewChanged) tn.viewSorted_pvid_used = pv;\r\n        //if (nodechanged) transientProperties.node[nid].viewSorted_nodeused = node;\r\n        if (datachanged) tn.viewSorted_modelused = data;\r\n\r\n        // let nodechanged: boolean\r\n        // important to remember: how i'm using parentView in score and storage.\r\n        // i'm calculating and storing every score without parentView, then i apply it right before sorting the array,\r\n        // the enhanced value is not sored anyway but affects array sorting.\r\n        // so if parentView changes, or if his subviews changed, need to resort array without recomputing any score value.\r\n\r\n        //console.log('2302, getviews 2', {datachanged, nodechanged, olddata, oldnode, data, node, allViews: Selectors.getAllViewElements()});\r\n\r\n        if (!state) state = store.getState();\r\n        const allViews: DViewElement[] = Selectors.getAllViewElements(state);\r\n\r\n        const user = LUser.fromPointer(DUser.current);\r\n        const project = user.project as LProject;\r\n        let activevpid: Pointer<DViewElement> = project.activeViewpoint.id;\r\n        // check if scores needs to be updated\r\n        for (const dview of allViews) {\r\n            let vid = dview.id;\r\n            let tv = transientProperties.view[vid];\r\n            if (!tv) transientProperties.view[vid] = tv = {} as any;\r\n            let tnv = tn.viewScores[vid];\r\n            //console.log('2302, getviews evaluating view ' + vid, {vid, dview});\r\n            // check initialization\r\n\r\n            if (!tnv) {\r\n                transientProperties.node[nid].viewScores[vid] = tnv = {} as any;\r\n                /*{\r\n                    score: ViewEClassMatch.NOT_EVALUATED_YET,\r\n                    metaclassScore: ViewEClassMatch.NOT_EVALUATED_YET,\r\n                    //jsScore:ViewEClassMatch.NOT_EVALUATED_YET,\r\n                    //OCLScore: ViewEClassMatch.NOT_EVALUATED_YET\r\n                } as any;*/\r\n                firstEvaluationForNodeView = true;\r\n            } else firstEvaluationForNodeView = tnv.metaclassScore === ViewEClassMatch.NOT_EVALUATED_YET; // todo: when changing view.appliableTo, delete all tnv using that view.\r\n\r\n            // don't match exclusive views from other vp\r\n            let dvp: DViewPoint = DPointerTargetable.fromPointer(dview.viewpoint, state);\r\n            let oldVpMatch: number = tnv.viewPointMatch;\r\n            // console.log(\"vp matching \" +vid, {vid, dvp, activevpid });\r\n            if (dvp.id === activevpid) tnv.viewPointMatch = ViewEClassMatch.VP_Explicit;\r\n            else if (dvp.id === 'Pointer_ViewPointDefault') tnv.viewPointMatch = ViewEClassMatch.VP_Default;\r\n            else if (!dvp.isExclusiveView) tnv.viewPointMatch = ViewEClassMatch.VP_Decorative;\r\n            else tnv.viewPointMatch = ViewEClassMatch.VP_MISMATCH;\r\n\r\n            if (!needsorting && (oldVpMatch !== tnv.viewPointMatch)) needsorting = true;\r\n            if (tnv.viewPointMatch === ViewEClassMatch.VP_MISMATCH) {\r\n                tnv.finalScore = ViewEClassMatch.VP_MISMATCH;\r\n                continue;\r\n            }\r\n\r\n\r\n            // check preconditions\r\n            if (firstEvaluationForNodeView) {\r\n                const oldScore = tnv.metaclassScore;\r\n                tnv.metaclassScore = this.matchesMetaClassTarget(dview, data?.__raw);\r\n                needsorting = true; // sorting is mandatory here because it's the first evaluation of node-vie\r\n                // if mismatch i stop computing the score.\r\n                if (tnv.metaclassScore === ViewEClassMatch.MISMATCH_PRECONDITIONS) {\r\n                    tnv.finalScore = ViewEClassMatch.MISMATCH;\r\n                    continue;\r\n                }\r\n            } else if (tnv.metaclassScore === ViewEClassMatch.MISMATCH_PRECONDITIONS) continue;\r\n\r\n            if (true) {\r\n                // this needs to be called not only if datachanged || nodechanged, but everytime in case it is a reference like data.$value.name.length\r\n                // also his performances are so fast that it might be more costly to check if it's supposed to be reevaluated than just calling it.\r\n                let jsScoreChanged: boolean = Selectors.updateJSScore(node, data, dview, tv, tnv);\r\n                if (!needsorting && jsScoreChanged) needsorting = true;\r\n                // if mismatch i stop computing the score.\r\n                if (tnv.jsScore === ViewEClassMatch.MISMATCH_JS) { tnv.finalScore = ViewEClassMatch.MISMATCH; continue; }\r\n            }\r\n\r\n            // check pre-ocl guard\r\n            // if (!tv.oclUpdateCondition_PARSED(data, olddata)) continue;\r\n\r\n            if (datachanged || tnv.OCLScore === ViewEClassMatch.NOT_EVALUATED_YET) {\r\n                // check ocl: this can lead to mis-updating if ocl queries a reference.\r\n                // but OCL is computationally heavy, so i decided it is now a requirement to update the model to reevaluate ocl.\r\n                let oldScore = tnv.OCLScore;\r\n                tnv.OCLScore = OCL.test(data, dview, node)//Selectors.calculateOCLScore({data, node, dview});\r\n                tv.oclChanged = false;\r\n                if (!needsorting && tnv.OCLScore !== oldScore) needsorting = true;\r\n                if (tnv.OCLScore === ViewEClassMatch.MISMATCH_OCL) { tnv.finalScore = ViewEClassMatch.MISMATCH; continue; }\r\n            }\r\n        }\r\n\r\n        if (parentViewChanged) needsorting = true; // scores saved in dictionaries are the same, but score in final sorted array changed.\r\n        return needsorting;\r\n    }\r\n\r\n    // get final viewstack for a node, also updates OCL scores if needed because of a change in model or parentView (NOT from a change in view)\r\n    static getAppliedViewsNew({data:data0, node, pv, nid}:{ node: LGraphElement | undefined; data: LModelElement | undefined; pv: DViewElement | undefined; nid: Pointer<DGraphElement>}): NodeTransientProperties {\r\n        // console.trace('2302, getviews', {tnode: transientProperties.node[nid], nid, pv})\r\n        let state = store.getState();\r\n        let needsorting: boolean = Selectors.updateScores(data0, node, nid, pv, state);\r\n\r\n        let tn: NodeTransientProperties = transientProperties.node[nid]; // needs to be placed after updateScores() which will initialize it.\r\n        type ViewScoreEntry = {element: Pointer<DViewElement>, score: number, view: LViewElement};\r\n        if (needsorting || !tn.stackViews) {\r\n            let mainViews: ViewScoreEntry[] = [];\r\n            let decorativeViews: ViewScoreEntry[] = [];\r\n            // problem: if view is created or deleted from someone in coop, it might not update tv.viewScores\r\n            // need to operate on reducer on both creation and removal\r\n            for (let vid of Object.keys(tn.viewScores)) {\r\n                let tnv = tn.viewScores[vid];\r\n                const dview: DViewElement = DPointerTargetable.fromPointer(vid, state);\r\n                const score = tnv.finalScore = Selectors.getFinalScore(tnv, vid, pv, dview);\r\n                if (!(score > 0)) continue; // do not flip to <=, because undefined and NEGATIVE_INFINITY always compute to false.\r\n                (dview.isExclusiveView ? mainViews : decorativeViews).push( {element:vid, score, view: LPointerTargetable.fromD(dview)} );\r\n            }\r\n            decorativeViews.sort((s1, s2)=> s2.score - s1.score); // sorted from biggest to smallest\r\n            mainViews.sort((s1, s2)=> s2.score - s1.score); // sorted from biggest to smallest\r\n\r\n            // Log.exDev(!mainViews[0], 'cannot find a matching main view', {mainViews, decorativeViews, data0, scores: tn.viewScores})\r\n            tn.mainView = mainViews[0]?.view;\r\n            tn.validMainViews = mainViews.map((s)=> s.view); // this have duplicates of newly created elements\r\n            tn.stackViews = decorativeViews.map((s)=> s.view);\r\n        }\r\n        // chamges to view or ocl comditiom are mot hamdled here, ut om multple mp/modes a omce\r\n        //nb{}[]\r\n\r\n        // if data or view changed update the score dict, them re-sort the view arr first, fimally update Sorted_modelused, Sorted_modelused\r\n        // console.log('2302 getviews ret', {dn: data?.name, data, stack: transientProperties.node[nid].stackViews, stackn: transientProperties.node[nid].stackViews.map(v => v.name), scores: transientProperties.node[nid]});\r\n\r\n        // throw new Error(\"stop debug\");\r\n        return tn;\r\n\r\n    }\r\n\r\n    static getAllMP(state?: DState): DModelElement[] {\r\n        if (!state) state = store.getState();\r\n        let allD: DPointerTargetable[] = Object.values(state.idlookup);\r\n        return allD.filter( (d: DPointerTargetable) => U.isObject(d) && Selectors.isOfSubclass(d, DModelElement)) as DModelElement[]; }\r\n\r\n    static toObject<D extends DPointerTargetable>(ptrs: Pointer<D>[], state?: DState):D[] {\r\n        if (!state) state = store.getState();\r\n        return ptrs.map(p => (state as DState).idlookup[p]) as D[]; }\r\n\r\n    static wrap<D extends DPointerTargetable, L extends LPointerTargetable>(arr: (Pointer<D, 1, 1, L> | D)[], state?: DState): L[] {\r\n        if (!arr.length) return [];\r\n        if (!state) state = store.getState();\r\n        let objarr: D[];\r\n        if (typeof arr[0] === \"string\") { objarr = Selectors.toObject(arr as string[], state); }\r\n        else objarr = arr as D[];\r\n        return objarr.map(p => RuntimeAccessibleClass.wrap(p)) as L[]; }\r\n\r\n    static unwrap<D extends DPointerTargetable, L extends LPointerTargetable>(arr:L[]): D[] { return arr.map( (a)=> a.__raw) as any[]; }\r\n    static getSubNodeElements(forGraph: Pointer<DGraph, 1, 1>, asPointers: boolean = false, wrap: boolean = false): Pointer<DGraphElement>[] | DGraphElement[] | LGraphElement[] {\r\n        const state : DState = store.getState();\r\n        const g: DGraph = state.idlookup[forGraph] as DGraph;\r\n        if (asPointers) return g.subElements;\r\n        const subelements: DGraphElement[] = g.subElements.map( geid => state.idlookup[geid]) as DGraphElement[];\r\n        if (wrap) return subelements.map<LGraphElement>( (ge) => LPointerTargetable.from(ge));\r\n        return subelements; }\r\n\r\n\r\n\r\n\r\n    //// giordano part\r\n\r\n\r\n\r\n    public static getAllPackageClasses(id: string): LClass[] {\r\n        const data = LPointerTargetable.from(id) as GObject;\r\n        let lPackage : LPackage | undefined;\r\n        const classes: LClass[] = [];\r\n        if (data.className === \"DReference\") {\r\n            const lClass: LClass = LPointerTargetable.from(data.father);\r\n            lPackage = LPointerTargetable.from(lClass.father);\r\n        }\r\n        if (data.className === \"DParameter\") {\r\n            const lOperation: LOperation = LPointerTargetable.from(data.father);\r\n            const lClass: LClass = LPointerTargetable.from(lOperation.father);\r\n            lPackage = LPointerTargetable.wrap(lClass.father);\r\n        }\r\n        if (data.className === \"DOperation\") {\r\n            const lClass: LClass = LPointerTargetable.from(data.father);\r\n            lPackage = LPointerTargetable.wrap(lClass.father);\r\n        }\r\n        if (lPackage) {\r\n            for(let classifier of lPackage.classifiers) {\r\n                const lClassifier: LClass | LEnumerator = LPointerTargetable.from(classifier);\r\n                if(lClassifier.className === \"DClass\") classes.push(lClassifier as LClass);\r\n            }\r\n        }\r\n        return classes;\r\n    }\r\n    public static getAllPackageEnumerators(id: string): LEnumerator[] {\r\n        const data = LPointerTargetable.from(id) as GObject;\r\n        let lPackage : LPackage | undefined;\r\n        const enumerators: LEnumerator[] = [];\r\n        if(data.className === \"DAttribute\") {\r\n            const lClass: LClass = LPointerTargetable.from(data.father);\r\n            lPackage = LPointerTargetable.from(lClass.father);\r\n        }\r\n        if(data.className === \"DParameter\") {\r\n            const lOperation: LOperation = LPointerTargetable.from(data.father);\r\n            const lClass: LClass = LPointerTargetable.from(lOperation.father);\r\n            lPackage = LPointerTargetable.from(lClass.father);\r\n        }\r\n        if(data.className === \"DOperation\") {\r\n            const lClass: LClass = LPointerTargetable.from(data.father);\r\n            lPackage = LPointerTargetable.from(lClass.father);\r\n        }\r\n        if(lPackage) {\r\n            for(let classifier of lPackage.classifiers) {\r\n                const lClassifier: LClass | LEnumerator = LPointerTargetable.from(classifier);\r\n                if(lClassifier.className === \"DEnumerator\") enumerators.push(lClassifier as LEnumerator);\r\n            }\r\n        }\r\n        return enumerators;\r\n    }\r\n\r\n    private static updateJSScore(node: LGraphElement | undefined, data: LModelElement | undefined, dview: DViewElement, tv: ViewTransientProperties, tnv: ViewScore) {\r\n        let oldjsScore = tnv.jsScore;\r\n        let jsConditionChanged: boolean = tv.jsConditionChanged;\r\n        tv.jsConditionChanged = false;\r\n\r\n        // tnv.jsScore = ViewEClassMatch.NOT_EVALUATED_YET as any as number;\r\n        let printstuff = {name: data?.name, jsc:tv.jsCondition, tv:{...tv}, data:data&&data.__raw, node:node&&{...node.__raw}, nerr: (node as any)?.errors}\r\n        if (tv.jsCondition) {\r\n            try {\r\n                tnv.jsScore = tv.jsCondition({data, node, view: LPointerTargetable.fromD(dview), constants: tv.constants});\r\n                // if (tnv.jsScore === true) tnv.jsScore = dview.jsCondition.length;\r\n                switch (typeof tnv.jsScore) {\r\n                    case \"boolean\": // bool is fine if true\r\n                        if (!tnv.jsScore) tnv.jsScore = ViewEClassMatch.MISMATCH_JS;\r\n                        break;\r\n                    case \"number\": // number is fine if not NaN and > 0\r\n                        if (isNaN(tnv.jsScore) || tnv.jsScore < 0) tnv.jsScore = ViewEClassMatch.MISMATCH_JS;\r\n                        break;\r\n                    default:\r\n                        tnv.jsScore = ViewEClassMatch.MISMATCH_JS;\r\n                        break;\r\n                }\r\n            }\r\n            catch (e:any) { // crash = mismatch\r\n                Log.ee(\"failed to evaluate jsCondition: \" + e.message?.split(\"\\n\")[0], {e, data, node, tnv, jsc:tv.jsCondition+''});\r\n                tnv.jsScore = ViewEClassMatch.MISMATCH_JS;\r\n            }\r\n        } else tnv.jsScore = true; // missing condition = match\r\n\r\n        // jsConditionChanged: because even if score didn't change, if jsc.length changed the final computed score is affected\r\n        return jsConditionChanged || tnv.jsScore !== oldjsScore;\r\n    }\r\n}\r\n\r\n(window as any).Selectors = Selectors;\r\n\r\nclass Scored<T extends GObject> {\r\n    constructor(public score: number, public element: T) {}\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}