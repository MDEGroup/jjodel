{"ast":null,"code":"var _dec,_class,_class2;import{LPointerTargetable,RuntimeAccessible}from\"../joiner\";let windoww=window;export let Debug=(_dec=RuntimeAccessible('Debug'),_dec(_class=(_class2=class Debug{// performance ligher mode for potato pc, huge models or complex simulations / measurables\n// manually activated: counts how many times each node is rendered in a component.\nstatic getComponentMap(){let nodes=Object.values(windoww.GraphElementComponent.all).map(a=>a.props.node).filter(a=>!!a);let nodeids=[...new Set(nodes.map(a=>a.id).filter(a=>!!a))];let allids={};for(let o of nodeids)allids[o]=0;for(let n of nodes)allids[n===null||n===void 0?void 0:n.id]++;allids.nodes=nodeids;allids.components=Object.values(windoww.GraphElementComponent.all);return allids;}static timeoutTasks(){}static largeTimeoutTasks(){var _windoww$s$model;windoww.model=windoww.LPointerTargetable.wrap((_windoww$s$model=windoww.s().model)===null||_windoww$s$model===void 0?void 0:_windoww$s$model[0]);}static remakeEdges(){// warning: might break undo/redo for direct state editing\nlet eids=windoww.LPointerTargetable.wrapAll(windoww.LState.get().edges).map(e=>e.id);let epids=windoww.LPointerTargetable.wrapAll(windoww.LState.get().edgepoints).map(e=>e.id);let ss=windoww.store.getState();ss.edges=[];ss.edgepoints=[];for(let e of eids)delete ss.idlookup[e];for(let e of epids)delete ss.idlookup[e];windoww.SetRootFieldAction.new(\"clonedCounter\",ss.clonedCounter+1,'',false);}static setLightMode(b){// i don't want to use react or actions here because they cause a re-render and are heavy. this is a performance emergency mode.\nif(this.lightMode===b)return;this.lightMode=b;if(!Debug.lightModeInput){Debug.lightModeInput=$(\"#lightmode\")[0];if(!Debug.lightModeInput)return;}Debug.lightModeInput.checked=b;}static refresh(){for(let key in windoww.GraphElementComponent.all){windoww.GraphElementComponent.all[key].forceUpdate();}console.log(windoww.GraphElementComponent.all);}// 16s 50 classi vuote\nstatic benchmarkCreateElement(){let times=arguments.length>0&&arguments[0]!==undefined?arguments[0]:100;let disableConsole=arguments.length>1&&arguments[1]!==undefined?arguments[1]:true;let state=windoww.s();let checkDelayMax=300;let checkDelayMin=50;let diff=checkDelayMax-checkDelayMin;let callbacks={checkCompletionFunction,checkDelayMin,additionalDelayMax:diff,times,disableConsole};callbacks.startTime=new Date();if(disableConsole)windoww.Log.disableConsole();let lmodel=LPointerTargetable.wrap(state.idlookup[state.models[0]]);for(let i=0;i<times;i++){lmodel.addChild(\"Class\");}function checkCompletionFunction(){return $(\".DClass\").length;}Debug.timeMeasurer(callbacks);return callbacks;}// 4s 10 istanze con 5 attributi\nstatic benchmarkCreateInstance(){let metaclassName=arguments.length>0&&arguments[0]!==undefined?arguments[0]:\"Concept 1\";let times=arguments.length>1&&arguments[1]!==undefined?arguments[1]:100;let disableConsole=arguments.length>2&&arguments[2]!==undefined?arguments[2]:true;let checkDelayMax=300;let checkDelayMin=50;let diff=checkDelayMax-checkDelayMin;let callbacks={checkCompletionFunction,checkDelayMin,additionalDelayMax:diff,times,disableConsole};callbacks.startTime=new Date();if(disableConsole)windoww.Log.disableConsole();let state=windoww.s();let lmodel=LPointerTargetable.wrap(state.idlookup[state.models[1]]);let lclass=LPointerTargetable.wrap(state.classs.map(cid=>state.idlookup[cid]).filter(c=>c.name===metaclassName)[0]);for(let i=0;i<times;i++){lmodel.addObject(lclass===null||lclass===void 0?void 0:lclass.id);}function checkCompletionFunction(){return $(\"[data-modelname=\\\"DObject\\\"]\").length;}Debug.timeMeasurer(callbacks);return callbacks;}static timeMeasurer(callbacks0){let callbacks=callbacks0;if(!callbacks)callbacks={};// if (!callbacks.startTime) callbacks.startTime = new Date();\nif(!callbacks.maxStuckTime)callbacks.maxStuckTime=10000;if(!callbacks.checkDelayMin)callbacks.checkDelayMin=300;if(!callbacks.additionalDelayMax)callbacks.additionalDelayMax=2000;if(!callbacks.onStuck)callbacks.onStuck=(time,start,end,$complete)=>{console.log(\"Benchmarked operation stuck at same completion% for: \"+callbacks.maxStuckTime/1000+\" s. \\n\"+\"After \"+time/100+\"s total time passed and \"+$complete*100+\"% of the task was completed. \\nBenchmark aborted.\");};if(!callbacks.onFinish)callbacks.onFinish=(time,start,end)=>{console.log(\"Benchmarked operation completed after: \"+time/1000+\" s.\");};windoww.Log.exDev(!callbacks.times,\".times is a mandatory option\");windoww.Log.exDev(!callbacks.checkCompletionFunction,\".checkCompletionFunction is a mandatory option\");windoww.Log.exDev(!callbacks.checkCompletionFunction,\".startTime is a mandatory option. set it **before** doing the main task, then call the benchmark.\");callbacks.completionHistory=[];if(callbacks.disableConsole)windoww.Log.disableConsole();Debug.timeMeasurer_inner(callbacks);return callbacks;}static timeMeasurer_inner(callbacks){let completedTimes=callbacks.checkCompletionFunction();callbacks.completionHistory.push(completedTimes);if(completedTimes===callbacks.times){callbacks.endTime=new Date();callbacks.totTime=callbacks.endTime.getTime()-callbacks.startTime.getTime();if(callbacks.disableConsole)windoww.Log.enableConsole();callbacks.onFinish(callbacks.totTime,callbacks.startTime,callbacks.endTime);callbacks.endStatus=\"FINISH\";return;}let $complete=completedTimes/callbacks.times;if(callbacks.completedTimes!==completedTimes){callbacks.stuckSince=new Date().getTime();callbacks.completedTimes=completedTimes;}else if(callbacks.stuckSince>callbacks.maxStuckTime){callbacks.endTime=new Date();let $complete=completedTimes/callbacks.times;callbacks.totTime=callbacks.endTime.getTime()-callbacks.startTime.getTime();if(callbacks.disableConsole)windoww.Log.enableConsole();callbacks.onStuck(callbacks.totTime,callbacks.startTime,callbacks.endTime,$complete);callbacks.endStatus=\"STUCK\";return;}let delay=callbacks.checkDelayMin;if($complete!==0)delay+=callbacks.additionalDelayMax*(1-$complete);setTimeout(()=>Debug.timeMeasurer_inner(callbacks),delay);}},_class2.lightMode=false,_class2.lightModeInput=void 0,_class2))||_class);setTimeout(Debug.timeoutTasks,500);setTimeout(Debug.largeTimeoutTasks,5000);windoww.Debug=Debug;","map":{"version":3,"names":["LPointerTargetable","RuntimeAccessible","windoww","window","Debug","_dec","_class","_class2","getComponentMap","nodes","Object","values","GraphElementComponent","all","map","a","props","node","filter","nodeids","Set","id","allids","o","n","components","timeoutTasks","largeTimeoutTasks","_windoww$s$model","model","wrap","s","remakeEdges","eids","wrapAll","LState","get","edges","e","epids","edgepoints","ss","store","getState","idlookup","SetRootFieldAction","new","clonedCounter","setLightMode","b","lightMode","lightModeInput","$","checked","refresh","key","forceUpdate","console","log","benchmarkCreateElement","times","arguments","length","undefined","disableConsole","state","checkDelayMax","checkDelayMin","diff","callbacks","checkCompletionFunction","additionalDelayMax","startTime","Date","Log","lmodel","models","i","addChild","timeMeasurer","benchmarkCreateInstance","metaclassName","lclass","classs","cid","c","name","addObject","callbacks0","maxStuckTime","onStuck","time","start","end","$complete","onFinish","exDev","completionHistory","timeMeasurer_inner","completedTimes","push","endTime","totTime","getTime","enableConsole","endStatus","stuckSince","delay","setTimeout"],"sources":["C:/0Programmi/Dev/projects/frontend/jjodel/src/debugtools/debug.tsx"],"sourcesContent":["import type {DClass, DModel, GObject, LClass, LModel} from \"../joiner\";\r\nimport {LPointerTargetable, RuntimeAccessible, SetRootFieldAction} from \"../joiner\";\r\nlet windoww = window as any;\r\n\r\n@RuntimeAccessible('Debug')\r\nexport class Debug {\r\n    public static lightMode: boolean = false; // performance ligher mode for potato pc, huge models or complex simulations / measurables\r\n    private static lightModeInput: HTMLInputElement;\r\n\r\n    // manually activated: counts how many times each node is rendered in a component.\r\n    static getComponentMap(){\r\n        let nodes = Object.values(windoww.GraphElementComponent.all).map((a:any)=>a.props.node).filter(a=>!!a);\r\n        let nodeids = [...new Set(nodes.map(a=>a.id).filter(a=>!!a))];\r\n        let allids: GObject = {};\r\n        for (let o of nodeids) allids[o] = 0;\r\n        for (let n of nodes) allids[n?.id]++;\r\n        allids.nodes = nodeids;\r\n        allids.components = Object.values(windoww.GraphElementComponent.all);\r\n        return allids; }\r\n\r\n    static timeoutTasks(){}\r\n    static largeTimeoutTasks(){\r\n        windoww.model = windoww.LPointerTargetable.wrap(windoww.s().model?.[0]);\r\n    }\r\n\r\n    static remakeEdges(): void{\r\n        // warning: might break undo/redo for direct state editing\r\n        let eids = windoww.LPointerTargetable.wrapAll(windoww.LState.get().edges).map((e: any)=>e.id)\r\n        let epids = windoww.LPointerTargetable.wrapAll(windoww.LState.get().edgepoints).map((e: any)=>e.id)\r\n        let ss = windoww.store.getState();\r\n        ss.edges = [];\r\n        ss.edgepoints = [];\r\n        for (let e of eids) delete ss.idlookup[e];\r\n        for (let e of epids) delete ss.idlookup[e];\r\n        windoww.SetRootFieldAction.new(\"clonedCounter\" , ss.clonedCounter + 1, '', false);\r\n    }\r\n\r\n    static setLightMode(b: boolean): void {\r\n        // i don't want to use react or actions here because they cause a re-render and are heavy. this is a performance emergency mode.\r\n        if (this.lightMode === b) return;\r\n        this.lightMode = b;\r\n        if (!Debug.lightModeInput) {\r\n            Debug.lightModeInput = ($(\"#lightmode\") as any as HTMLInputElement[])[0];\r\n            if (!Debug.lightModeInput) return;\r\n        }\r\n        Debug.lightModeInput.checked = b;\r\n    }\r\n    public static refresh(): void {\r\n        for (let key in windoww.GraphElementComponent.all) {\r\n            windoww.GraphElementComponent.all[key].forceUpdate();\r\n        }\r\n        console.log(windoww.GraphElementComponent.all);\r\n    }\r\n\r\n    // 16s 50 classi vuote\r\n    static benchmarkCreateElement(times: number = 100, disableConsole: boolean = true): BenchmarkOptions{\r\n        let state = windoww.s();\r\n\r\n        let checkDelayMax = 300;\r\n        let checkDelayMin = 50;\r\n        let diff = checkDelayMax - checkDelayMin;\r\n        let callbacks: any = {checkCompletionFunction, checkDelayMin, additionalDelayMax: diff, times, disableConsole};\r\n        callbacks.startTime = new Date();\r\n        if(disableConsole) windoww.Log.disableConsole();\r\n        let lmodel = (LPointerTargetable.wrap(state.idlookup[ state.models[0] ]) as LModel);\r\n        for (let i = 0; i < times; i++){\r\n            lmodel.addChild(\"Class\");\r\n        }\r\n        function checkCompletionFunction() { return $(\".DClass\").length; }\r\n\r\n        Debug.timeMeasurer(callbacks);\r\n        return callbacks;\r\n    }\r\n    // 4s 10 istanze con 5 attributi\r\n    static benchmarkCreateInstance(metaclassName: string=\"Concept 1\", times: number = 100, disableConsole: boolean = true): BenchmarkOptions{\r\n        let checkDelayMax = 300;\r\n        let checkDelayMin = 50;\r\n        let diff = checkDelayMax - checkDelayMin;\r\n        let callbacks: any = {checkCompletionFunction, checkDelayMin, additionalDelayMax: diff, times, disableConsole};\r\n        callbacks.startTime = new Date();\r\n        if(disableConsole) windoww.Log.disableConsole();\r\n\r\n        let state = windoww.s();\r\n        let lmodel = (LPointerTargetable.wrap(state.idlookup[ state.models[1] ]) as LModel);\r\n        let lclass = LPointerTargetable.wrap(state.classs.map((cid: string)=>state.idlookup[cid]).filter((c:DClass) => c.name === metaclassName)[0]) as LClass;\r\n        for (let i = 0; i < times; i++) {\r\n            lmodel.addObject(lclass?.id);\r\n        }\r\n        function checkCompletionFunction() { return $(\"[data-modelname=\\\"DObject\\\"]\").length; }\r\n\r\n        Debug.timeMeasurer(callbacks);\r\n        return callbacks;\r\n    }\r\n\r\n\r\n    static timeMeasurer(callbacks0:Partial<BenchmarkOptions> | undefined): BenchmarkOptions {\r\n        let callbacks: BenchmarkOptions = callbacks0 as any;\r\n        if (!callbacks) callbacks = {} as any;\r\n        // if (!callbacks.startTime) callbacks.startTime = new Date();\r\n        if (!callbacks.maxStuckTime) callbacks.maxStuckTime = 10000;\r\n        if (!callbacks.checkDelayMin) callbacks.checkDelayMin = 300;\r\n        if (!callbacks.additionalDelayMax) callbacks.additionalDelayMax = 2000;\r\n        if (!callbacks.onStuck) callbacks.onStuck = (time:number, start: Date, end:Date, $complete: number) => {\r\n            console.log(\"Benchmarked operation stuck at same completion% for: \" + callbacks.maxStuckTime/1000+\" s. \\n\" +\r\n                \"After \" + time/100 + \"s total time passed and \" + $complete*100 + \"% of the task was completed. \\nBenchmark aborted.\"); }\r\n        if (!callbacks.onFinish) callbacks.onFinish = (time:number, start: Date, end:Date) => {\r\n            console.log(\"Benchmarked operation completed after: \" + time/1000 + \" s.\"); }\r\n\r\n        windoww.Log.exDev(!callbacks.times, \".times is a mandatory option\");\r\n        windoww.Log.exDev(!callbacks.checkCompletionFunction, \".checkCompletionFunction is a mandatory option\");\r\n        windoww.Log.exDev(!callbacks.checkCompletionFunction, \".startTime is a mandatory option. set it **before** doing the main task, then call the benchmark.\");\r\n        (callbacks as any).completionHistory = [];\r\n\r\n        if(callbacks.disableConsole) windoww.Log.disableConsole();\r\n        Debug.timeMeasurer_inner(callbacks);\r\n        return callbacks;\r\n    }\r\n\r\n    private static timeMeasurer_inner(callbacks:BenchmarkOptions): void {\r\n        let completedTimes = callbacks.checkCompletionFunction();\r\n        (callbacks as any).completionHistory.push(completedTimes);\r\n        if (completedTimes === callbacks.times) {\r\n            callbacks.endTime = new Date();\r\n            callbacks.totTime = callbacks.endTime.getTime() - callbacks.startTime.getTime();\r\n            if(callbacks.disableConsole) windoww.Log.enableConsole();\r\n            callbacks.onFinish(callbacks.totTime, callbacks.startTime, callbacks.endTime);\r\n            callbacks.endStatus = \"FINISH\";\r\n            return;\r\n        }\r\n        let $complete = completedTimes / callbacks.times;\r\n        if (callbacks.completedTimes !== completedTimes) {\r\n            callbacks.stuckSince = new Date().getTime();\r\n            callbacks.completedTimes = completedTimes;\r\n        } else\r\n        if (callbacks.stuckSince > callbacks.maxStuckTime) {\r\n            callbacks.endTime = new Date();\r\n            let $complete = completedTimes / callbacks.times;\r\n            callbacks.totTime = callbacks.endTime.getTime() - callbacks.startTime.getTime();\r\n            if(callbacks.disableConsole) windoww.Log.enableConsole();\r\n            callbacks.onStuck(callbacks.totTime, callbacks.startTime, callbacks.endTime, $complete);\r\n            callbacks.endStatus = \"STUCK\";\r\n            return;\r\n        }\r\n        let delay = callbacks.checkDelayMin;\r\n        if ($complete !== 0) delay += callbacks.additionalDelayMax * (1-$complete);\r\n        setTimeout(()=>Debug.timeMeasurer_inner(callbacks), delay );\r\n\r\n    }\r\n}\r\ntype BenchmarkOptions = {\r\n    onFinish:(time:number, start: Date, end:Date)=>void,\r\n    onStuck:(time:number, start: Date, end:Date, $complete: number)=>void,\r\n    disableConsole: boolean, endStatus: string,\r\n    // completionFunction returns how many steps are completed.\r\n    // times how many steps need to be completed to mark the test as finished.\r\n    checkCompletionFunction: () => number, times: number, completedTimes: number,\r\n    // those are automatically set\r\n    startTime:Date, endTime:Date, stuckSince: number, totTime: number,\r\n    // check how often completion or abortion is checked\r\n    checkDelayMin: number, additionalDelayMax: number, maxStuckTime:number\r\n};\r\n\r\nsetTimeout(Debug.timeoutTasks, 500);\r\nsetTimeout(Debug.largeTimeoutTasks, 5000);\r\nwindoww.Debug = Debug;\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}