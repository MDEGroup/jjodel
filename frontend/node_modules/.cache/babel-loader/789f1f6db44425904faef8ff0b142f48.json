{"ast":null,"code":"import { DViewElement, UX, GraphElementComponent, ViewEClassMatch } from '../../joiner';\nimport { Action, CompositeAction, CreateElementAction, DeleteElementAction, DPointerTargetable, DState, DUser, getPath, Log, MyError, PendingPointedByPaths, PointedBy, Pointers, RuntimeAccessibleClass, SetFieldAction, SetRootFieldAction, statehistory } from \"../../joiner\";\nimport React from \"react\";\nimport { LoadAction, RedoAction, UndoAction } from \"../action/action\";\nimport Collaborative from \"../../components/collaborative/Collaborative\";\nimport { SimpleTree } from \"../../common/SimpleTree\";\nimport { transientProperties, Selectors } from \"../../joiner\";\nimport { contextFixedKeys } from '../../graph/graphElement/sharedTypes/sharedTypes';\nimport Storage from \"../../data/storage\";\nimport { ProjectsApi } from \"../../api/persistance\";\nimport DSL from \"../../DSL/DSL\";\nlet windoww = window;\nlet U = windoww.U;\nfunction deepCopyButOnlyFollowingPath(oldStateDoNotModify, action, prevAction, newVal) {\n  var _action$path;\n  let newRoot = {\n    ...oldStateDoNotModify\n  };\n  let current = newRoot;\n  if (!((_action$path = action.path) === null || _action$path === void 0 ? void 0 : _action$path.length)) throw new MyError(\"path length must be at least 1\", {\n    action\n  });\n  let gotChanged = false; // dovrebbe cambiare sempre, se non cambia non lancio neanche l'azione e non faccio la shallow copy, ma non si sa mai, così posso evitare un render se succede l' \"insuccedibile\"\n  let alreadyPastDivergencePoint = false; // true dal momento in cui il path dell'azione attuale e della azione precedente divergono, false fino al sotto-segmento in cui combaciano\n  // console.log('deepCopyButOnlyFollowingPath', arguments);\n  for (let i = 0; i < action.pathArray.length; i++) {\n    let key = action.pathArray[i].trim();\n    let prevActionPathKey = prevAction === null || prevAction === void 0 ? void 0 : prevAction.pathArray[i];\n    // middle execution: not on final loop\n    // console.log('deepCopyButOnlyFollowingPath', {current, i, imax:action.pathArray.length, key, gotChanged, alreadyPastDivergencePoint});\n    if (i !== action.pathArray.length - 1) {\n      if (alreadyPastDivergencePoint || key !== prevActionPathKey) {\n        // se l'oggetto è stato già duplicato in una azione composita, non lo duplico 2 volte.\n        alreadyPastDivergencePoint = true;\n        current[key] = Array.isArray(current[key]) ? [...current[key]] : {\n          ...current[key]\n        };\n        current[key].clonedCounter = 1 + (current[key].clonedCounter || 0);\n      }\n      current = current[key];\n      continue;\n    }\n    // Giordano: added this on 03/12/2023 to prevent \"Cannot read properties of undefined\".\n    // if(!current) continue; damiano: temp removed to check if there are invalid actions firing\n    // perform final assignment\n    if (i >= action.pathArray.length - 1) {\n      let isArrayAppend = false;\n      let isArrayRemove = false;\n      let isObjectMerge = false;\n      let isObjectDifference = false;\n      // console.log('isarrayappend?', {endswith: U.endsWith(key, ['+=', '[]', '-1']), key, action, i});\n      // console.log('isarraydelete?', {endswith: U.endsWith(key, ['-='])});\n\n      let oldValue;\n      if (U.endsWith(key, ['+=', '[]'])) {\n        key = key.substr(0, key.length - 2).trim();\n        oldValue = current[key];\n        switch (typeof oldValue) {\n          case 'object':\n            if (Array.isArray(oldValue)) isArrayAppend = true;else isObjectMerge = true;\n            break;\n          default:\n            newVal += oldValue;\n            break;\n        }\n      }\n      if (U.endsWith(key, ['-='])) {\n        key = key.substr(0, key.length - 2).trim();\n        oldValue = current[key];\n        switch (typeof oldValue) {\n          case 'object':\n            if (Array.isArray(oldValue)) isArrayRemove = true;else isObjectDifference = true;\n            break;\n          case \"string\":\n            newVal = U.replaceAll(oldValue, newVal, '');\n            break;\n          case 'number':\n            newVal = oldValue - newVal;\n            break;\n          default:\n            isArrayRemove = true;\n            break;\n        }\n        // isArrayRemove = true;\n      }\n\n      // let unpointedElement: DPointerTargetable | undefined;\n      // perform final assignment\n      if (action.type === CreateElementAction.type && current[key]) {\n        oldValue = current[key];\n        gotChanged = false;\n        Log.ee(\"rejected CreateElementAction, rollback occurring:\", {\n          action,\n          preexistingValue: current[key],\n          isShallowEqual: current[key] === action.value\n        });\n        return false; // warning: use return only when you want to abort and skip subsequent CompositeAction sub-actions like now.\n      }\n      if (isObjectMerge) {\n        if (typeof newVal === 'string') {\n          let tmp = {};\n          tmp[newVal] = true;\n          newVal = tmp;\n        }\n        oldValue = {\n          ...current[key]\n        };\n        current[key] = {\n          ...current[key]\n        };\n        for (let subkey in newVal) {\n          // console.warn(\"object merge\", {current, key, subkey, newVal, old:current[key][subkey], new:newVal[subkey]});\n          if (current[key][subkey] === newVal[subkey]) continue;\n          current[key][subkey] = newVal[subkey];\n          gotChanged = true;\n          if (action.isPointer) {\n            newRoot = PointedBy.add(key, action, newRoot, \"+=\");\n          }\n        }\n      } else if (isObjectDifference) {\n        if (typeof newVal === 'string') {\n          let tmp = {};\n          tmp[newVal] = true;\n          newVal = tmp;\n        }\n        oldValue = {\n          ...current[key]\n        };\n        current[key] = {\n          ...current[key]\n        };\n        for (let subkey in newVal) {\n          if (!(subkey in current[key])) continue;\n          delete current[key][subkey];\n          gotChanged = true;\n          if (action.isPointer) {\n            newRoot = PointedBy.add(key, action, newRoot, \"-=\");\n          }\n        }\n      } else if (isArrayAppend) {\n        gotChanged = true;\n        if (!Array.isArray(current[key])) {\n          current[key] = [];\n        }\n        oldValue = [...current[key]];\n        current[key] = [...current[key]];\n        current[key].push(newVal);\n        // unpointedElement = undefined;\n        if (action.isPointer) {\n          newRoot = PointedBy.add(newVal, action, newRoot, \"+=\");\n        }\n      } else if (isArrayRemove) {\n        if (!Array.isArray(current[key])) {\n          current[key] = [];\n        }\n        oldValue = [...current[key]];\n        let index;\n        if (U.isNumber(newVal)) {\n          // delete by index\n          index = newVal;\n          if (index < 0) index = oldValue.length + index; // if index is -2, i remove the penultimate element\n        } else if (newVal === undefined) {\n          index = oldValue.length - 1;\n        } else {\n          index = oldValue.indexOf(newVal);\n        }\n        // if it's negatively or positively out of boundary, i skip it\n        gotChanged = index >= 0 && index < current[key].length;\n        if (gotChanged) {\n          current[key] = [...current[key]];\n          let removedval = current[key].splice(index, 1); // in-place edit\n          if (action.isPointer) {\n            newRoot = PointedBy.remove(removedval, action, newRoot, '-=');\n          }\n          /*\r\n          fixed problem: se ho [dobj1, dobj2]... e li swappo, cambia un indice nel percorso \"pointedby\" e non me ne accorgo mai e un oggetto risulta \"pointedby\" da oggetti che non lo puntano o non esistono più a quell'indice\r\n          SOLVED! by not including index in pointedBy path, but making it like \"parentObject.arrayKey+=\" instead of \"parentObject.arrayKey.4\"\r\n          and knowing it's in the array it's enough info.\r\n            // a.pointsto = [x, y, z]; a.pointsto = [x, z]       --->    remove a from y.pointedby\r\n          const elementsThatChangedIndex: DPointerTargetable[] = current[key].slice(index);\r\n            for (let j = 0; j < elementsThatChangedIndex.length; j++) {\r\n              let newindex = index + j - 1;\r\n              let oldFullpathTrimmed = action.pathArray.join('.');\r\n              se realizzi \"pointedby\" qui è to do: remove old paths and re-add them with updated index\r\n          }\r\n          unpointedElement = newRoot.idlookup[oldValue];\r\n          */\n        }\n      } else if (action.type === DeleteElementAction.type && !(key in current) || current[key] === newVal) {\n        // value not changed\n        gotChanged = false;\n      } else {\n        // value changed\n        // todo: caso in cui setto manualmente classes.1 = pointer;\n        //  the latest element is array and not DPointerTargetable, so might need to buffer upper level in the tree? or instead of \"current\" keep an array of sub-objects encountered navigating the path in state.\n        oldValue = current[key];\n        gotChanged = true;\n        // unpointedElement = newRoot.idlookup[oldValue];\n        // NB: se elimino un oggetto che contiene array di puntatori, o resetto l'array di puntatori kinda like store.arr= [ptr1, ptr2, ...]; store.arr = [];\n        // i puntati dall'array hanno i loro pointedBY non aggiornati, non voglio fare un deep check di tutto l'oggetto a cercare puntatori per efficienza.\n        // if (newVal === undefined) delete current[key];\n        if (newVal === undefined || false && action.type === DeleteElementAction.type) delete current[key];else current[key] = newVal;\n\n        // update pointedBy's\n        // NB: even if the current action have isPointer=true, it doesn't mean the old value is a pointer as well for sure. so need to check old values.\n        // also what if old val is pointer, and new one isn't? will it be just removed without updating pointedBy's?\n        // already fixed: might need to evaluate this if block always regardless of action.isPointer,\n        // and do checks every time both on old and new value if they actually are ptrs.\n        if (true || action.isPointer) {\n          let oldpointerdestinations;\n          let newpointerdestinations;\n          if (Array.isArray(newVal)) {\n            newpointerdestinations = newVal;\n            if (Array.isArray(oldValue)) {\n              // case: path.array = array;\n              oldpointerdestinations = oldValue;\n            } else {\n              // case: path.object = array; + case: path.value = array;\n              oldpointerdestinations = [oldValue];\n            }\n          } else {\n            // case: path.array = object; + case: path.array = value;\n            newpointerdestinations = [newVal];\n            if (Array.isArray(oldValue)) {\n              oldpointerdestinations = oldValue;\n            } else {\n              // case: path.object = object; and all other cases without arrays involved\n              oldpointerdestinations = [oldValue];\n            }\n          }\n          // after i mapped all cases to path.array = array; i solve it for that case.\n          let difference = U.arrayDifference(oldpointerdestinations, newpointerdestinations); // : {added: Pointer[], removed: Pointer[], starting: Pointer[], final: Pointer[]}\n          for (let rem of difference.removed) {\n            if (Pointers.isPointer(rem)) newRoot = PointedBy.remove(rem, action, newRoot, undefined, oldStateDoNotModify);\n          }\n          for (let add of difference.added) {\n            if (Pointers.isPointer(add)) newRoot = PointedBy.add(add, action, newRoot, undefined, oldStateDoNotModify);\n          }\n          // a.pointsto = [a, b, c];  a.pointsto = [a, b, x];    ------>     c.pointedby.remove(a) & x.pointedby.add(a)\n          // idlookup.somelongid.pointsto = [...b];\n        }\n      }\n      break;\n    }\n    Log.exDevv('should not reach here: reducer');\n  }\n  return gotChanged ? newRoot : oldStateDoNotModify;\n}\n\n// const pendingPointedByPaths: {from: DocString<\"Path in store\">, field: DocString<\"keyof object found in from path\">, to: Pointer}[] = [];\nfunction CompositeActionReducer(oldState, actionBatch) {\n  // per via di thunk se arrivo qui lo stato cambia sicuro in mono-client non synchro (non ri-assegno valori equivalenti)\n  // todo: ma se arrivano in ordine sbagliato da altri client? posso permetterlo?\n  let actions;\n  if (actionBatch.actions) actions = Action.parse(actionBatch.actions);else actions = [Action.parse(actionBatch)]; // else-case is if it's a single action and not an actual compositeaction\n  if (PendingPointedByPaths.all.length) actions.push(...PendingPointedByPaths.getSolveableActions(oldState)); //.all.map( p=> p.resolve() ) );\n\n  Action.possibleInconsistencies = {};\n\n  // estraggo le azioni derivate\n  let derivedActions = [];\n  let newState = oldState;\n  for (let action of actions) {\n    switch (action.type) {\n      default:\n        break;\n      case CreateElementAction.type:\n        const elem = action.value;\n        delete DPointerTargetable.pendingCreation[elem.id];\n        /*\r\n        if (oldState.idlookup[elem.id]) {\r\n            Log.ee(\"rejected CreateElementAction, rollback occurring:\", {action, elem:{...elem},\r\n                preexistingValue: {...oldState.idlookup[elem.id]}, isEqual: elem === oldState.idlookup[elem.id] });\r\n            return oldState; // warning: use return only when you want to abort and skip subsequent CompositeAction sub-actions like now.\r\n              action.value = \"An element with that id already existed.\";\r\n            action.path = action.field = \"CreateActionRejected\";\r\n            action.className = SetRootFieldAction.name;\r\n            action.type = SetRootFieldAction.type;\r\n            action.pathArray = [action.path]; //a\r\n            action.isPointer = false;\r\n            // just to log it in undo-redo action list and have a feedback\r\n            return oldState;}*/\n\n        elem.className = elem.className || elem.constructor.cname || elem.constructor.name;\n        let statefoldername = elem.className.substring(1).toLowerCase() + 's';\n        derivedActions.push(Action.parse(SetRootFieldAction.create(statefoldername, elem.id, '[]', true)));\n        if (!Array.isArray(elem.pointedBy)) elem.pointedBy = [];\n        elem.pointedBy.push(PointedBy.new(statefoldername));\n        /*if (false && action.isPointer) {\r\n            if (Array.isArray(action.value)) {\r\n                const ptr: Pointer[] = action.value;\r\n                // todo but replaced by side actions in execution of the main action instead of triggering derived actions\r\n            }\r\n            else {\r\n                const ptr: Pointer = action.value;\r\n                const target: DPointerTargetable | null = oldState.idlookup[ptr];\r\n                let pendingPointedBy = PendingPointedByPaths.new(action, oldState);\r\n                if (!target) PendingPointedByPaths.new(action, oldState).saveForLater(); // {from: action.path, field: action.field, to: target});\r\n                // @ts-ignore\r\n                else derivedActions.push(pendingPointedBy.resolve());\r\n                // a -> x\r\n                // a -> y     unset x.pointedby(a)\r\n            }\r\n        }*/\n        break;\n    }\n  }\n  // console.error({U, Umip:U.arrayMergeInPlace, WU: windoww.U, WUmip: windoww.U.arrayMergeInPlace});\n  actions = U.arrayMergeInPlace(actions, derivedActions);\n\n  // ordino i path con segmenti comuni\n  actions = actions.sort((a1, a2) => U.stringCompare(a1.path, a2.path));\n\n  // destrutturo solo i nodi intermedi e solo la prima volta che li incontro (richiede le azioni ordinate in base al path)\n\n  for (let i = 0; i < actions.length; i++) {\n    const prevAction = actions[i - 1];\n    const action = actions[i];\n    const actiontype = action.type.indexOf('@@') === 0 ? 'redux' : action.type;\n    console.log('executing action:', {\n      a: action,\n      t: actiontype,\n      field: action.field,\n      v: action.value\n    }); //, count: ++action.executionCount});\n\n    switch (actiontype) {\n      /*\r\n      case '@@redux/INIT6.x.f.d.r.e':\r\n      case '@@redux/INITm.f.1.s.o.g':\r\n      case '@@redux/INIT5.t.4.v.d.o':\r\n      case '@@redux/INITy.a.d.r.l.a':\r\n      case '@@redux/INIT4.2.q.u.z.k':\r\n      case '@@redux/INITj.8.e.g.y.p':\r\n      case '@@redux/INITp.k.q.g.z.w':\r\n      case '@@redux/INITq.c.u.w.f.e': ... etc*/\n      default:\n        if (action.type.indexOf('@@redux/') === 0) break;\n        return Log.exDevv('unexpected action type:', action.type);\n      case LoadAction.type:\n        newState = action.value;\n        break;\n      case CreateElementAction.type:\n      case SetRootFieldAction.type:\n      case DeleteElementAction.type:\n      case SetFieldAction.type:\n        let tmp = deepCopyButOnlyFollowingPath(newState, action, prevAction, action.value);\n        if (!tmp) return oldState; // rollback due to invalid action in transaction\n        newState = tmp;\n        break;\n    }\n\n    // and that's all, the reducer is really simple as actions are really simple.\n  }\n\n  // effetti collaterali, aggiornamento di ridondanze\n  newState = updateRedundancies_OBSOLETE(newState, oldState, Action.possibleInconsistencies);\n  return newState;\n}\n_c = CompositeActionReducer;\nfunction updateRedundancies_OBSOLETE(state, oldState, possibleInconsistencies) {\n  for (let subType in possibleInconsistencies) switch (subType) {\n    default:\n      break;\n    case Action.SubType.vertexSubElements: /*\r\n                                           risolto triggrerando più azioni da LGraphElement setter\r\n                                           let dvertexid: Pointer, newdvertex: DGraphElement, olddvertex: DGraphElement;\r\n                                           for (newdvertex of possibleInconsistencies[subType] as DGraphElement[]){\r\n                                           const olddvertex: DGraphElement = oldState.idlookup[newdvertex.id] as DGraphElement;\r\n                                           const notContainedAnymoreOut: Pointer<DGraphElement> = [];\r\n                                           const newlyInsertedOut: Pointer<DGraphElement>[] = [];\r\n                                           U.arraySymmetricDifference(olddvertex.subElements, newdvertex.subElements, notContainedAnymoreOut, newlyInsertedOut);\r\n                                           for (let geid of notContainedAnymoreOut) {\r\n                                           const oldge = oldState.idlookup[geid] as DGraphElement;\r\n                                           const newge = state.idlookup[geid] as DGraphElement;\r\n                                           if (oldge.containedIn === newge.containedIn) continue;\r\n                                           }\r\n                                           for (let geid of notContainedAnymoreOut) {\r\n                                           const ge = idlookup[geid] as DGraphElement;\r\n                                           if (ge.containedIn === context.data.id) set container = context.data.id\r\n                                           meglio se sti 2 cicli li fai nel reducer perchè  potrebbe esserci una azione pending che setta il parent = someotherid e qui faccio partire una azione che setta il parent a null, \"annullando\" una azione pending non ancora eseguita\r\n                                           }\r\n                                           }\r\n                                           break;*/\n  }\n  // if state is updated shallow copy state before returning it\n  return state;\n}\nlet initialState = null;\nlet storeLoaded = false;\nconst UDRegexp = /(?:^|\\s|;|}|\\n|\\t|\\(|,)ret\\s*\\.\\s*[a-zA-Z_$][0-9a-zA-Z_$]*\\s*=/g;\n/* tested with:\r\nif (ret.key = stuff) ret.key2=morestuff;\r\n;ret.k=3;\r\n}ret. kk=3,ret. a = 3\r\n\r\nret .b = 3\r\n*/\n\n// then add to it: content of props, constants, usageDeclarations\n\nexport function reducer() {\n  let oldState = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : initialState;\n  let action = arguments.length > 1 ? arguments[1] : undefined;\n  try {\n    return unsafereducer(oldState, action);\n  } catch (e) {\n    console.error('unhandled error in reducer', {\n      e,\n      oldState,\n      action\n    });\n    return oldState;\n  }\n}\nfunction unsafereducer() {\n  var _ret$VIEWS_RECOMPILE_, _ret$VIEWS_RECOMPILE_2, _ret$VIEWS_RECOMPILE_3, _ret$VIEWS_RECOMPILE_4, _ret$VIEWS_RECOMPILE_5;\n  let oldState = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : initialState;\n  let action = arguments.length > 1 ? arguments[1] : undefined;\n  const ret = _reducer(oldState, action);\n  if (ret === oldState) return oldState;\n  // ret.idlookup.__proto__ = DPointerTargetable.pendingCreation as any;\n  // client synchronization stuff\n  if (oldState === null || oldState === void 0 ? void 0 : oldState.collaborativeSession) {\n    const ignoredFields = ['version', 'env', 'debug', 'isEdgePending', 'contextMenu', '_lastSelected', 'isLoading', 'collaborativeSession', 'VIEWS_RECOMPILE_onDataUpdate', 'VIEWS_RECOMPILE_onDragStart', 'VIEWS_RECOMPILE_onDragEnd', 'VIEWS_RECOMPILE_whileDragging', 'VIEWS_RECOMPILE_onResizeStart', 'VIEWS_RECOMPILE_onResizeEnd', 'VIEWS_RECOMPILE_whileResizing', 'VIEWS_RECOMPILE_onRotationStart', 'VIEWS_RECOMPILE_onRotationEnd', 'VIEWS_RECOMPILE_whileRotating', 'VIEWS_RECOMPILE_constants', 'VIEWS_RECOMPILE_usageDeclarations', 'VIEWS_RECOMPILE_jsxString', 'VIEWS_RECOMPILE_preconditions', 'VIEWS_RECOMPILE_jsCondition', 'VIEWS_RECOMPILE_ocl', 'VIEWS_RECOMPILE_events', 'VIEWS_RECOMPILE_all', 'ClassNameChanged', 'tooltip', 'advanced', 'alert'];\n    /* Checking if CompositeAction has some actions that MUST be ignored */\n    let compositeAction = null;\n    if (action.type === CompositeAction.type) {\n      compositeAction = action;\n      const subActions = compositeAction.actions || [];\n      compositeAction.actions = subActions.filter(a => !ignoredFields.includes(a.field));\n    }\n    if (compositeAction && !compositeAction.actions.length) return ret;\n    action = compositeAction ? compositeAction : action;\n    if (action.sender === DUser.current && !ignoredFields.includes(action.field)) {\n      const parsedAction = JSON.parse(JSON.stringify(action));\n      Collaborative.client.emit('pushAction', parsedAction);\n    }\n  }\n  for (let ptr of ret.ELEMENT_CREATED) {\n    let d = ret.idlookup[ptr];\n    if (!d) continue; // creation rejected, no-op\n    switch (d.className) {\n      default:\n        break;\n      case \"DViewElement\":\n        for (let nid in transientProperties.node) {\n          let tn = transientProperties.node[nid];\n          tn.viewScores[d.id] = {};\n        }\n    }\n  }\n  ret.ELEMENT_CREATED = [];\n  for (let ptr of ret.ELEMENT_DELETED) {\n    let d = oldState.idlookup[ptr];\n    if (!d) continue; // already deleted, no-op\n    switch (d.className) {\n      default:\n        break;\n      case \"DViewElement\":\n        for (let nid in transientProperties.node) {\n          let tn = transientProperties.node[nid];\n          // delete tn.stackViews; // trigger recalc of all scores.\n          delete tn.viewScores[d.id];\n          tn.needSorting = true;\n        }\n    }\n  }\n  ret.ELEMENT_DELETED = [];\n  if (ret.VIEWS_RECOMPILE_all === true) ret.VIEWS_RECOMPILE_all = Object.keys(ret.idlookup);\n  if ((_ret$VIEWS_RECOMPILE_ = ret.VIEWS_RECOMPILE_all) === null || _ret$VIEWS_RECOMPILE_ === void 0 ? void 0 : _ret$VIEWS_RECOMPILE_.length) {\n    let resetAllNodes = false;\n    let sk;\n    for (let id of new Set(ret.VIEWS_RECOMPILE_all)) {\n      let d = ret.idlookup[id];\n      if (!d) continue;\n      if (RuntimeAccessibleClass.extends(d.className, \"DViewElement\")) {\n        d.css_MUST_RECOMPILE = true;\n        transientProperties.view[d.id] = {};\n        // for (let k of DViewElement.MeasurableKeys) (ret as any)['VIEWS_RECOMPILE_'+k].push(d.id);\n        // for (let k of DViewElement.RecompileKeys) (ret as any)['VIEWS_RECOMPILE_'+k].push(d.id);\n        for (sk in ret) if (sk.indexOf('VIEWS_RECOMPILE') === 0) ret[sk].push(id);\n        // ret.NODES_RECOMPILE_labels.push(id); ret.NODES_RECOMPILE_longestLabel.push(id);\n        if (!resetAllNodes) resetAllNodes = true;\n      }\n      if (RuntimeAccessibleClass.extends(d.className, \"DModelElement\")) {\n        if (d.className === \"DClass\") {\n          var _oldState$idlookup$d$, _ret$idlookup$d$id;\n          let oldname = (_oldState$idlookup$d$ = oldState.idlookup[d.id]) === null || _oldState$idlookup$d$ === void 0 ? void 0 : _oldState$idlookup$d$.name;\n          let newname = (_ret$idlookup$d$id = ret.idlookup[d.id]) === null || _ret$idlookup$d$id === void 0 ? void 0 : _ret$idlookup$d$id.name;\n          if (oldname !== newname) ret.ClassNameChanged[d.id] = oldname;\n        }\n        for (sk in ret) if (sk.indexOf('MODELS_RECOMPILE') === 0) ret[sk].push(id);\n        // transientProperties.modelElement[d.id] = { } as any; stuff in here does not need replacement, can never be dangerous (currently).\n      }\n      if (RuntimeAccessibleClass.extends(d.className, \"DGraphElement\")) {\n        transientProperties.node[d.id] = {};\n        for (sk in ret) if (sk.indexOf('NODES_RECOMPILE') === 0) ret[sk].push(id);\n        //ret.NODES_RECOMPILE_labels.push(id); ret.NODES_RECOMPILE_longestLabel.push(id);\n      }\n    }\n    if (resetAllNodes) for (let nid in transientProperties.node) {\n      transientProperties.node[nid] = {};\n      for (sk in ret) if (sk.indexOf('NODES_RECOMPILE') === 0) ret[sk].push(nid);\n      //ret.NODES_RECOMPILE_labels.push(id); ret.NODES_RECOMPILE_longestLabel.push(id);\n    }\n  }\n  ret.VIEWS_RECOMPILE_all = [];\n  function parseLabel(ptr, key, isNode) {\n    var _mainView;\n    let dv = DPointerTargetable.fromPointer(ptr, ret);\n    let tp = (isNode ? transientProperties.node : transientProperties.view)[ptr];\n    if (!tp) (isNode ? transientProperties.node : transientProperties.view)[ptr] = tp = {};\n    let val = dv[key];\n    if (!val) {\n      tp[key] = undefined;\n      return true;\n    }\n    if (typeof val === \"function\") {\n      tp[key] = val;\n      return true;\n    }\n    let allContextKeys = {\n      ...contextFixedKeys\n    };\n    let vid = isNode ? (_mainView = tp.mainView) === null || _mainView === void 0 ? void 0 : _mainView.id : ptr;\n    if (!vid) return false; // leave pending & recompute them on next reducer action\n    let tv = transientProperties.view[vid];\n    for (let k of tv.constantsList) if (!allContextKeys[k]) allContextKeys[k] = true;\n    for (let k of tv.UDList) if (!allContextKeys[k]) allContextKeys[k] = true;\n    let paramStr = '{' + Object.keys(allContextKeys).join(',') + '}';\n    console.log('labels parse', {\n      allContextKeys,\n      ud: tv.UDList,\n      c: tv.constantsList\n    });\n    const body = 'return (' + val + ')';\n    // if (vid.includes('Model')) console.log(\"modelparse, laels\", {paramStr, body});\n    console.log('labels parse', {\n      vid: ptr,\n      paramStr,\n      body\n    });\n    try {\n      if (isNode) {\n        // need to store the function in tnv instead of tn since if v changes, ud changes as well? in all of them?what if i make a new view?\n      } else {\n        // tp[key] = new Function(paramStr, body) as ((...a: any) => any);\n      }\n      tp[key] = function () {\n        return 'label as an option is disabled, pass it through props instead.';\n      };\n    } catch (e) {\n      /*try{\r\n          let try_to_get_better_error = eval(\"let __f = function(\" + paramStr+\") {\\n\" + body + \"}\");\r\n      } catch(eeval){\r\n          console.error(\"eval error same as func error\", {e, eeval});\r\n          e = eeval;\r\n      }*/\n      console.error('error labels parse', {\n        vid: ptr,\n        e,\n        paramStr,\n        body\n      });\n      tp[key] = val; // (context: GObject) => 'Error during label evaluation';\n    }\n    return true;\n    // implies recompilation of: ... nothing?\n  }\n  let arr;\n  arr = ret.NODES_RECOMPILE_labels;\n  if (arr.length) {\n    let successfullyParsed = {};\n    for (const id of new Set(arr)) successfullyParsed[id] = parseLabel(id, 'labels', true);\n    ret.NODES_RECOMPILE_labels = arr.filter(e => !successfullyParsed[e]);\n  }\n  arr = ret.NODES_RECOMPILE_longestLabel;\n  if (arr.length) {\n    let successfullyParsed = {};\n    for (const id of new Set(arr)) successfullyParsed[id] = parseLabel(id, 'longestLabel', true);\n    ret.NODES_RECOMPILE_longestLabel = arr.filter(e => !successfullyParsed[e]);\n  }\n  arr = ret.VIEWS_RECOMPILE_labels;\n  if (arr.length) {\n    let successfullyParsed = {};\n    for (const id of new Set(arr)) successfullyParsed[id] = parseLabel(id, 'labels', false);\n    ret.VIEWS_RECOMPILE_labels = arr.filter(e => !successfullyParsed[e]);\n  }\n  arr = ret.VIEWS_RECOMPILE_longestLabel;\n  if (arr.length) {\n    let successfullyParsed = {};\n    for (const id of new Set(arr)) successfullyParsed[id] = parseLabel(id, 'longestLabel', false);\n    ret.VIEWS_RECOMPILE_longestLabel = arr.filter(e => !successfullyParsed[e]);\n  }\n\n  // local changes to out-of-redux stuff\n  if (ret.VIEWS_RECOMPILE_ocl.length) {\n    // for (let gid of ret.graphs) Selectors.updateViewMatchings(gid, ret.modelElements, Object.values(ret.idlookup).map( d => RuntimeAccessibleClass.extends(d, DModelElement.cname)));\n    // for (let vid of ret.VIEW_APPLIABLETO_NEEDS_RECALCULATION) { }\n    for (let vid of new Set(ret.VIEWS_RECOMPILE_ocl)) {\n      if (!transientProperties.view[vid]) transientProperties.view[vid] = {};\n      transientProperties.view[vid].oclEngine = undefined; // force re-parse\n      transientProperties.view[vid].oclChanged = true;\n      for (let nid in transientProperties.node) {\n        let tnv = transientProperties.node[nid].viewScores[vid];\n        if ((tnv === null || tnv === void 0 ? void 0 : tnv.OCLScore) !== ViewEClassMatch.NOT_EVALUATED_YET) tnv.OCLScore = ViewEClassMatch.NOT_EVALUATED_YET;\n      }\n    }\n    ret.VIEWS_RECOMPILE_ocl = [];\n  }\n  /*\r\n  if (ret.VIEWOCL_UPDATE_NEEDS_RECALCULATION.length) {\r\n      // not implemented for now\r\n      ret.VIEWOCL_UPDATE_NEEDS_RECALCULATION = [];\r\n  }*/\n\n  if (ret.VIEWS_RECOMPILE_preconditions.length) {\n    for (let vid of new Set(ret.VIEWS_RECOMPILE_preconditions)) {\n      for (let nid in transientProperties.node) {\n        let tnv = transientProperties.node[nid].viewScores[vid];\n        if ((tnv === null || tnv === void 0 ? void 0 : tnv.metaclassScore) !== ViewEClassMatch.NOT_EVALUATED_YET) tnv.metaclassScore = ViewEClassMatch.NOT_EVALUATED_YET;\n      }\n    }\n    ret.VIEWS_RECOMPILE_preconditions = [];\n  }\n  if ((_ret$VIEWS_RECOMPILE_2 = ret.VIEWS_RECOMPILE_constants) === null || _ret$VIEWS_RECOMPILE_2 === void 0 ? void 0 : _ret$VIEWS_RECOMPILE_2.length) for (const vid of new Set(ret.VIEWS_RECOMPILE_constants)) {\n    // compiled in func, and executed, result does not vary between nodes.\n    let dv = DPointerTargetable.fromPointer(vid, ret);\n    // transientProperties.view[vid].constantsList = dv.constants?.match(UDRegexp).map(s=>s.substring(4, s.length-1).trim()) || [];\n    // let allContextKeys = {...contextFixedKeys};\n    if (!dv.constants) {\n      if (!transientProperties.view[vid]) transientProperties.view[vid] = {};\n      transientProperties.view[vid].constants = {};\n      transientProperties.view[vid].constantsList = [];\n      // no need to recompile UD, jsx or measurables, they will have additional parameters in scope but they are undefined and cause no problems.\n      continue;\n    }\n    const constantsOutput = {};\n    const context = {\n      view: dv\n    }; // context at this point holds only static stuff, which are in gloval scope (window) plus view.\n    let paramStr = '{' + Object.keys(context).join(',') + '}, ret';\n    try {\n      // the scope of new Function() is \"window\" and not the function where is called, unlike eval();\n      let constantsFunction = new Function(paramStr, 'return (' + dv.constants + ')(ret)').bind(context);\n      constantsFunction(context, constantsOutput);\n    } catch (e) {\n      console.error('error constants parse', {\n        vid,\n        e,\n        paramStr,\n        body: 'return (' + dv.constants + ')(ret)'\n      });\n      // todo: how do i render an error from here? even if i set jsx or ud.__invalidDeclarations it will be recompiled. need a constants.__invalidDeclarations too?\n    }\n    transientProperties.view[vid].constants = constantsOutput;\n    transientProperties.view[vid].constantsList = Object.keys(transientProperties.view[vid].constants);\n    // implies recompilation of: jsCondition, ud, jsx and all measurable events\n    ret.VIEWS_RECOMPILE_jsCondition.push(vid);\n    ret.VIEWS_RECOMPILE_usageDeclarations.push(vid);\n    ret.VIEWS_RECOMPILE_jsxString.push(vid);\n    ret.VIEWS_RECOMPILE_events.push(vid);\n    for (let k of DViewElement.MeasurableKeys) ret['VIEWS_RECOMPILE_' + k].push(vid);\n  }\n  ret.VIEWS_RECOMPILE_constants = [];\n  if ((_ret$VIEWS_RECOMPILE_3 = ret.VIEWS_RECOMPILE_usageDeclarations) === null || _ret$VIEWS_RECOMPILE_3 === void 0 ? void 0 : _ret$VIEWS_RECOMPILE_3.length) for (const vid of new Set(ret.VIEWS_RECOMPILE_usageDeclarations)) {\n    var _dv$usageDeclarations;\n    // compiled in func, but NOT executed, result varies between nodes.\n    let dv = DPointerTargetable.fromPointer(vid, ret);\n    let tv = transientProperties.view[vid];\n    if (!tv) transientProperties.view[vid] = tv = {};\n    if (!dv.usageDeclarations) {\n      tv.UDList = [];\n      tv.UDFunction = undefined;\n      // no need to recompile jsx or measurables, they will have additional parameters in scope but they are undefined and cause no problems.\n      continue;\n    }\n    let matches = ((_dv$usageDeclarations = dv.usageDeclarations) === null || _dv$usageDeclarations === void 0 ? void 0 : _dv$usageDeclarations.match(UDRegexp)) || [];\n    transientProperties.view[vid].UDList = matches.map(s => {\n      s = s.trim();\n      return s.substring(s.indexOf('\\.') + 1, s.length - 2).trim();\n    });\n    // warning for user: do not redeclare ret in nested blocks.\n    // do not use ret[key] syntax.\n    // do not set nested values directly (ret.key.subkey syntax).\n    // do not use ret.key +=, -= or any other operator assignment different than \"=\"\n    // if that is ever required, do instead\n    // do not assign values to ret in block comments\n    // those restrictions only apply to the ret object, all those violations can be done on other objects.\n    // so the following is valid, and a way to overcome the previous limitations:\n    // let subobject = {}; subobject[key] += stuff; ret.somefixedname = subobject;\n\n    let allContextKeys = {\n      ...contextFixedKeys\n    };\n    for (let k of tv.constantsList) if (!allContextKeys[k]) allContextKeys[k] = true;\n    let paramStr = '{' + Object.keys(allContextKeys).join(',') + '}, ret';\n    if (vid.includes('Model')) console.log(\"modelparse, ud\", {\n      paramStr,\n      udstr: dv.usageDeclarations,\n      udlist: transientProperties.view[vid].UDList\n    });\n    try {\n      tv.UDFunction = new Function(paramStr, 'return (' + dv.usageDeclarations + ')(ret)');\n    } catch (e) {\n      // problem: errors cannot be serialized in any way? they have no keys. let strerr = JSON.stringify(e); //(e.message || '').split('\\n')[0]);\n      let udErrors = windoww.udErrors;\n      if (!windoww.udErrors) windoww.udErrors = udErrors = {\n        maxi: 0\n      };\n      udErrors[\"e\" + ++udErrors.maxi] = e;\n      e.isSyntax = true;\n      let errbody = \"ret.__invalidUsageDeclarations = window.udErrors.e\" + udErrors.maxi + \"; return ret;\";\n      console.error('error udparse', {\n        vid,\n        e,\n        paramStr,\n        body: 'return (' + dv.usageDeclarations + ')(ret)',\n        errbody\n      });\n      tv.UDFunction = new Function(\"unusedContext, ret\", errbody);\n    }\n\n    // implies recompilation of: jsx and all measurable events\n    ret.VIEWS_RECOMPILE_jsxString.push(vid);\n    ret.VIEWS_RECOMPILE_events.push(vid);\n    for (let k of DViewElement.MeasurableKeys) ret['VIEWS_RECOMPILE_' + k].push(vid);\n  }\n  ret.VIEWS_RECOMPILE_usageDeclarations = [];\n  if (ret.VIEWS_RECOMPILE_events.length) {\n    // for (let gid of ret.graphs) Selectors.updateViewMatchings(gid, ret.modelElements, Object.values(ret.idlookup).map( d => RuntimeAccessibleClass.extends(d, DModelElement.cname)));\n    // for (let vid of ret.VIEW_APPLIABLETO_NEEDS_RECALCULATION) { }\n    for (let entry of new Set(ret.VIEWS_RECOMPILE_events)) {\n      let vid;\n      let dv;\n      let keys;\n      if (typeof entry === \"object\") {\n        vid = entry.vid;\n        dv = DPointerTargetable.fromPointer(vid, ret);\n        keys = entry.keys || Object.keys(dv.events);\n      } else {\n        vid = entry;\n        dv = DPointerTargetable.fromPointer(vid, ret);\n        keys = Object.keys(dv.events);\n      }\n      let tv = transientProperties.view[vid];\n      if (!tv) transientProperties.view[vid] = tv = {};\n      if (!tv.events) tv.events = {};\n      // if (!tv.events_raw) tv.events_raw = {};\n      for (let key of keys) {\n        if (!key) {\n          delete tv.events[key];\n          continue;\n        }\n        let allContextKeys = {\n          ...contextFixedKeys\n        };\n        for (let k of transientProperties.view[vid].constantsList) if (!allContextKeys[k]) allContextKeys[k] = true;\n        for (let k of transientProperties.view[vid].UDList) if (!allContextKeys[k]) allContextKeys[k] = true;\n        let paramStr = '{' + Object.keys(allContextKeys).join(',') + '}, ..._params';\n        // dv.events[key] = (...params)=> code\n        const body = 'return (' + dv.events[key] + ')(..._params)';\n        // if (vid.includes('Model')) console.log(\"modelparse, jsx\", {paramStr, body});\n        try {\n          tv.events[key] = new Function(paramStr, body);\n          // tv.events_raw[key] = new Function(paramStr, body) as ((...a:any)=>any);\n          // attempt to auto obtain node context\n          // impossile with view.event.name\n          // could with node.event.name if node.get_event sets a current node thing__, no he must wrap the func!! in the getter\n          // tv.events[key] = (..._params2:any) => { return tv.events_raw[key](context, ..._params2) };\n        } catch (e) {\n          console.error('error jsxparse', {\n            vid,\n            e,\n            paramStr,\n            body\n          });\n          tv.events[key] = context => Log.ee(\"failed to parse function body: \" + e.message.split(\"\\n\")[0], e.message);\n        }\n      }\n    }\n    ret.VIEWS_RECOMPILE_events = [];\n    // triggers recompile of nothing\n  }\n  if ((_ret$VIEWS_RECOMPILE_4 = ret.VIEWS_RECOMPILE_jsCondition) === null || _ret$VIEWS_RECOMPILE_4 === void 0 ? void 0 : _ret$VIEWS_RECOMPILE_4.length) for (const vid of new Set(ret.VIEWS_RECOMPILE_jsCondition)) {\n    const dv = DPointerTargetable.fromPointer(vid, ret);\n    let tv = transientProperties.view[vid];\n    if (!tv) transientProperties.view[vid] = tv = {};\n    tv.jsConditionChanged = true;\n    if (!dv.jsCondition) {\n      tv.jsCondition = undefined;\n      continue;\n    }\n    const lines = dv.jsCondition.trim().split('\\n');\n    let lastLine = lines[lines.length - 1];\n    if (lastLine.indexOf('return') !== 0) lines[lines.length - 1] = `return (${lastLine})`;\n    if (!dv.jsxString) {\n      transientProperties.view[vid].JSXFunction = undefined;\n      continue;\n    }\n    let allContextKeys = {\n      ...contextFixedKeys\n    };\n    for (let k of transientProperties.view[vid].constantsList) if (!allContextKeys[k]) allContextKeys[k] = true;\n    let paramStr = '{' + Object.keys(allContextKeys).join(',') + '}';\n    const body = lines.join('\\n');\n    try {\n      tv.jsCondition = new Function(paramStr, body);\n    } catch (e) {\n      tv.jsCondition = undefined;\n      console.log('JS Condition parsed error', e);\n    }\n  }\n  ret.VIEWS_RECOMPILE_jsCondition = [];\n  if ((_ret$VIEWS_RECOMPILE_5 = ret.VIEWS_RECOMPILE_jsxString) === null || _ret$VIEWS_RECOMPILE_5 === void 0 ? void 0 : _ret$VIEWS_RECOMPILE_5.length) for (const vid of new Set(ret.VIEWS_RECOMPILE_jsxString)) {\n    // compiled in func, but NOT executed, result varies between nodes.\n    let dv = DPointerTargetable.fromPointer(vid, ret);\n    let tv = transientProperties.view[vid];\n    if (!tv) transientProperties.view[vid] = tv = {};\n    if (!dv.jsxString) {\n      transientProperties.view[vid].JSXFunction = undefined;\n      continue;\n    }\n    let allContextKeys = {\n      ...contextFixedKeys\n    };\n    for (let k of transientProperties.view[vid].constantsList) if (!allContextKeys[k]) allContextKeys[k] = true;\n    for (let k of transientProperties.view[vid].UDList) if (!allContextKeys[k]) allContextKeys[k] = true;\n    let paramStr = '{' + Object.keys(allContextKeys).join(',') + '}';\n    const body = 'return (' + UX.parseAndInject(DSL.parser(dv.jsxString), dv) + ')';\n    // if (vid.includes('Model')) console.log(\"modelparse, jsx\", {paramStr, body});\n    try {\n      transientProperties.view[vid].JSXFunction = new Function(paramStr, body);\n    } catch (e) {\n      /*try{\r\n          let try_to_get_better_error = eval(\"let __f = function(\" + paramStr+\") {\\n\" + body + \"}\");\r\n      } catch(eeval){\r\n          console.error(\"eval error same as func error\", {e, eeval});\r\n          e = eeval;\r\n      }*/\n      console.error('error jsxparse', {\n        vid,\n        e,\n        paramStr,\n        body\n      });\n      transientProperties.view[vid].JSXFunction = context => GraphElementComponent.displayError(e, 'JSX Syntax', dv);\n    }\n    // implies recompilation of: ... nothing?\n  }\n  ret.VIEWS_RECOMPILE_jsxString = [];\n  for (const key of DViewElement.MeasurableKeys) {\n    var _ref;\n    if ((_ref = ret['VIEWS_RECOMPILE_' + key]) === null || _ref === void 0 ? void 0 : _ref.length) for (let vid of new Set(ret['VIEWS_RECOMPILE_' + key])) {\n      let dv = DPointerTargetable.fromPointer(vid, ret);\n      let tv = transientProperties.view[vid];\n      if (!tv) transientProperties.view[vid] = tv = {};\n      let str = dv[key];\n      if (!str) {\n        transientProperties.view[vid][key] = undefined;\n        continue;\n      }\n      let allContextKeys = {\n        ...contextFixedKeys\n      };\n      for (let k of transientProperties.view[vid].constantsList) if (!allContextKeys[k]) allContextKeys[k] = true;\n      for (let k of transientProperties.view[vid].UDList) if (!allContextKeys[k]) allContextKeys[k] = true;\n      let paramStr = '{' + Object.keys(allContextKeys).join(',') + '}';\n      console.log('measurable parse ' + key, {\n        allContextKeys,\n        ud: transientProperties.view[vid].UDList,\n        c: transientProperties.view[vid].constantsList\n      });\n      console.log('measurable parse ' + key, {\n        vid,\n        paramStr,\n        body: str\n      });\n      try {\n        transientProperties.view[vid][key] = new Function(paramStr, str);\n      } catch (e) {\n        console.error('error measurable parse ' + key, {\n          vid,\n          e,\n          paramStr,\n          body: str\n        });\n        transientProperties.view[vid][key] = undefined;\n        // display error in jsx\n        transientProperties.view[vid].JSXFunction = context => GraphElementComponent.displayError(e, 'Measurable ' + key + ' Syntax', dv);\n        break;\n      }\n    }\n    ret['VIEWS_RECOMPILE_' + key] = [];\n  }\n  for (let dataid in ret.ClassNameChanged) {\n    if (dataid === 'clonedCounter') continue;\n    // NB: if i ever want to access a constructor's other properties in ocl, like \"context Persona inv: self.$somecounter === Persona.instances.length\",\n    // i would need to update this every time a DClass property changes instead of only when name changes.\n\n    // if it's first creation of a modelpiece\n    if (!transientProperties.modelElement[dataid]) {\n      transientProperties.modelElement[dataid] = {\n        nodes: {}\n      };\n    }\n    // update ocl type names\n    let data = ret.idlookup[dataid];\n    RuntimeAccessibleClass.makeOCLConstructor(data, ret, oldState);\n    // here i should reset all tnv.oclEngine too and set all ocl scores to notevaluated, but it is too computationally heavy\n    // and it's useful to keep the old ocl condition valid with past names until manually edited.\n  }\n  ret.ClassNameChanged = {};\n  return ret;\n}\nexport function _reducer /*<S extends StateNoFunc, A extends Action>*/() {\n  let oldState = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : initialState;\n  let action = arguments.length > 1 ? arguments[1] : undefined;\n  let times;\n  let state;\n  let removedDeltas = [];\n  switch (action.type) {\n    case UndoAction.type:\n      times = action.value;\n      state = oldState;\n      Log.exDev(times <= 0, \"undo must be positive\", action);\n      while (times--) {\n        const delta = statehistory[DUser.current].undoable.pop();\n        if (!delta) continue;\n        removedDeltas.push(delta);\n        state = undo(state, delta);\n      }\n      state.VIEWS_RECOMPILE_all = [...new Set(removedDeltas.flatMap(d => Object.keys((d === null || d === void 0 ? void 0 : d.idlookup) || {})))];\n      // state.VIEWS_RECOMPILE_all = true;\n      return state;\n    case RedoAction.type:\n      times = action.value;\n      state = oldState;\n      Log.exDev(times <= 0, \"redo must be positive\", action);\n      while (times--) {\n        const delta = statehistory[DUser.current].redoable.pop();\n        if (!delta) continue;\n        removedDeltas.push(delta);\n        state = undo(state, delta, false);\n      }\n      state.VIEWS_RECOMPILE_all = [...new Set(removedDeltas.flatMap(d => Object.keys((d === null || d === void 0 ? void 0 : d.idlookup) || {})))];\n      // state.VIEWS_RECOMPILE_all = true;\n      return state;\n    // case CombineHistoryAction.type: return combineHistory(oldState); break;\n    // todo: se al posto di \"annullare l'undo\" memorizzo l'azione e la rieseguo, posso ripetere l'ultimo passo N volte e questa azione diventa utile per combinare passi e ripetere blocchi di azioni assieme\n    default:\n      let ret = doreducer(oldState, action);\n      if (ret === oldState) return ret;\n      // statehistory[DUser.current].redoable = [];   <-- Moved to stateInitializer()\n      let delta = U.objectDelta(ret, oldState);\n      if (!filterundoableactions(delta)) return ret;\n      // console.log(\"setting undoable action:\", {ret, oldState0:{...oldState}, oldState, delta});\n      if (oldState !== null) statehistory[DUser.current].undoable.push(delta);\n      return ret;\n  }\n}\nfunction filterundoableactions(delta) {\n  if (!statehistory.globalcanundostate) return false;\n  if (Object.keys(delta).length === 1) {\n    if (\"dragging\" in delta) return false;\n    if (\"_lastSelected\" in delta) return false;\n    if (\"contextMenu\" in delta) return false;\n  }\n  return true;\n}\nfunction undo(state, delta) {\n  let isundo = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n  if (!delta) return state;\n  let undonestate = {\n    ...state\n  };\n  //   controlla se vengono shallow-copied solo e tutti gli oggetti nested lungo la catena del percorso delle modifiche\n  //   es: root.a.b.c=3 + root.a.b.d=3 = 4+1 modifiche, 5 shallow copies including the root\n  undorecursive(delta, undonestate);\n  if (isundo) statehistory[DUser.current].redoable.push(U.objectDelta(undonestate, state)); // reverses from undo to redo and viceversa swapping arguments, so the target result after appliying the delta changes\n  else statehistory[DUser.current].undoable.push(U.objectDelta(undonestate, state)); // redo is \"undoing an undo\", reversing his changes just like an undo reverses an ordinary action changes.\n  return undonestate;\n}\nfunction undorecursive(deltalevel, statelevel) {\n  // statelevel = {...statelevel}; not working if i do it here, just a new var. first time copy id done in caller func undo(). recursive copies are done before recursive step\n  for (let key in deltalevel) {\n    let delta = deltalevel[key];\n    console.log(\"undoing\", {\n      delta,\n      key,\n      deltalevel,\n      statelevel\n    });\n    if (key.indexOf(\"_-\") === 0) {\n      delete statelevel[key.substring(2)];\n      continue;\n    }\n    if (typeof delta === \"object\") {\n      // if (U.isObject(delta, false, false, true)) {\n      statelevel[key] = {\n        ...statelevel[key]\n      };\n      undorecursive(deltalevel[key], statelevel[key]);\n    } else {\n      statelevel[key] = delta;\n    }\n  }\n}\nfunction doreducer /*<S extends StateNoFunc, A extends Action>*/() {\n  let oldState = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : initialState;\n  let action = arguments.length > 1 ? arguments[1] : undefined;\n  if (!oldState) {\n    oldState = initialState = DState.new();\n  }\n  let ca;\n  // console.log('external REDUCER', {action, CEtype:CreateElementAction.type});\n  if (!storeLoaded) {\n    // new SetRootFieldAction('forceinit', true);\n    storeLoaded = true;\n  }\n  if (!oldState.forceinit) {\n    // afterStoreLoad();\n    // new SetRootFieldAction('forceinit', true);\n  } //  setTimeout(afterStoreLoad, 1);\n  switch (action.type) {\n    case CompositeAction.type:\n      ca = action;\n      break;\n    case LoadAction.type:\n    default:\n      if (action.type.indexOf('@@redux/') === 0) {\n        //storeLoaded = true;\n        return oldState;\n      }\n      ca = new CompositeAction([action], false);\n      break;\n  }\n  let ret = CompositeActionReducer(oldState, ca);\n  /*if (state.current !== ret) {\r\n      state.current = ret;\r\n      state.past.push(ret);\r\n  }*/\n  return ret;\n}\nfunction setSubclasses(roots) {\n  RuntimeAccessibleClass.extendMatrix = new SimpleTree(roots, \"subclasses\").getiIsSubElementMatrix(\"cname\");\n  /*\r\n  let tree = new TreeModel({\r\n      childrenPropertyName: \"subclasses\"\r\n  });\r\n  for (let key in dict){\r\n      let constructor = dict[key];\r\n      if(!constructor.hasOwnProperty(\"subclasses\")) constructor.subclasses = [];\r\n  }\r\n  RuntimeAccessibleClass.extendTree = (tree as any).safe_parse(RuntimeAccessibleClass);*/\n}\n// windoww.TreeModel = TreeModel;\nfunction buildLSingletons(alld, alll) {\n  for (let dname in alld) {\n    switch (dname) {\n      case \"DeleteElementAction\":\n        continue;\n      case \"DV\":\n        continue;\n      case \"Debug\":\n        continue;\n      default:\n        break;\n    }\n    if ((dname[1] || \"\").toLowerCase() === dname[1]) continue; // if second letter is lowercase, it's not a \"D\" class\n    let tagless = dname.substring(1);\n    let d = alld[dname];\n    let l = alll['L' + tagless];\n    if (!d || !l) console.error(\"missing d constructor\", {\n      d,\n      l\n    });\n    d.logic = l;\n    if (!l) console.error('init() could not find L-class during mapping', l, d);\n    // @ts-ignore\n    d.singleton = new l('dwc');\n    d.structure = d;\n    l.logic = d.logic;\n    l.singleton = d.singleton;\n    l.structure = d.structure;\n\n    // if (!d.subclasses) d.subclasses = [];\n    // @ts-ignore\n    // for (let sc of d.subclasses) { if (!sc[\"_extends\"]) sc[\"_extends\"] = [];  sc[\"_extends\"].push(d); }\n  }\n}\nfunction setDocumentEvents() {\n  // do not use typings or class constructors here or it will change import order\n  setTimeout(() => $(document).on(\"mouseup\", e => {\n    statehistory.globalcanundostate = true;\n    RuntimeAccessibleClass.get(\"GraphDragManager\").stopPanning(e);\n  }), 1);\n  // document.body.addEventListener(\"mousedown\", fixResizables, false);\n}\nfunction fixResizables(e) {\n  /*let parents = U.ancestorArray(e.target as HTMLElement);\r\n  for (let e of parents){\r\n      if (e.classList.contains(\"draggable\")) U.makeDraggable(e, e.dataset.draggableOptions, e.attributes.disabled);\r\n      if (e.classList.contains(\"resizable\")) U.makeResizable(e, e.dataset.draggableOptions);\r\n      if (e.classList.contains(\"resizable\")) U.makeRotatable(e, e.dataset.draggableOptions);\r\n  }*/\n}\nexport async function stateInitializer() {\n  RuntimeAccessibleClass.fixStatics();\n  let dClassesMap = {};\n  let lClassesMap = {};\n  for (let name in RuntimeAccessibleClass.classes) {\n    switch (name[0]) {\n      case 'D':\n        dClassesMap[name] = RuntimeAccessibleClass.classes[name];\n        break;\n      case 'L':\n        lClassesMap[name] = RuntimeAccessibleClass.classes[name];\n        break;\n      default:\n        break;\n    }\n  }\n  buildLSingletons(dClassesMap, lClassesMap);\n  setSubclasses(RuntimeAccessibleClass.get('DPointerTargetable'));\n  windoww.defaultContext = {\n    $: windoww.$,\n    getPath,\n    React: React,\n    Selectors,\n    ...RuntimeAccessibleClass.getAllClassesDictionary(),\n    ...windoww.Components\n  };\n  setDocumentEvents();\n  DState.init();\n  const user = Storage.read('user');\n  if (user) {\n    DUser.new(user.name, user.surname, user.nickname, user.affiliation, user.country, user.newsletter, user.email, user.token, user.id);\n    DUser.current = user.id;\n    statehistory[user.id] = {\n      redoable: [],\n      undoable: []\n    };\n    await ProjectsApi.getAll();\n  } else DUser.current = '';\n}\nvar _c;\n$RefreshReg$(_c, \"CompositeActionReducer\");","map":{"version":3,"names":["DViewElement","UX","GraphElementComponent","ViewEClassMatch","Action","CompositeAction","CreateElementAction","DeleteElementAction","DPointerTargetable","DState","DUser","getPath","Log","MyError","PendingPointedByPaths","PointedBy","Pointers","RuntimeAccessibleClass","SetFieldAction","SetRootFieldAction","statehistory","React","LoadAction","RedoAction","UndoAction","Collaborative","SimpleTree","transientProperties","Selectors","contextFixedKeys","Storage","ProjectsApi","DSL","windoww","window","U","deepCopyButOnlyFollowingPath","oldStateDoNotModify","action","prevAction","newVal","_action$path","newRoot","current","path","length","gotChanged","alreadyPastDivergencePoint","i","pathArray","key","trim","prevActionPathKey","Array","isArray","clonedCounter","isArrayAppend","isArrayRemove","isObjectMerge","isObjectDifference","oldValue","endsWith","substr","replaceAll","type","ee","preexistingValue","isShallowEqual","value","tmp","subkey","isPointer","add","push","index","isNumber","undefined","indexOf","removedval","splice","remove","oldpointerdestinations","newpointerdestinations","difference","arrayDifference","rem","removed","added","exDevv","CompositeActionReducer","oldState","actionBatch","actions","parse","all","getSolveableActions","possibleInconsistencies","derivedActions","newState","elem","pendingCreation","id","className","constructor","cname","name","statefoldername","substring","toLowerCase","create","pointedBy","new","arrayMergeInPlace","sort","a1","a2","stringCompare","actiontype","console","log","a","t","field","v","updateRedundancies_OBSOLETE","_c","state","subType","SubType","vertexSubElements","initialState","storeLoaded","UDRegexp","reducer","arguments","unsafereducer","e","error","_ret$VIEWS_RECOMPILE_","_ret$VIEWS_RECOMPILE_2","_ret$VIEWS_RECOMPILE_3","_ret$VIEWS_RECOMPILE_4","_ret$VIEWS_RECOMPILE_5","ret","_reducer","collaborativeSession","ignoredFields","compositeAction","subActions","filter","includes","sender","parsedAction","JSON","stringify","client","emit","ptr","ELEMENT_CREATED","d","idlookup","nid","node","tn","viewScores","ELEMENT_DELETED","needSorting","VIEWS_RECOMPILE_all","Object","keys","resetAllNodes","sk","Set","extends","css_MUST_RECOMPILE","view","_oldState$idlookup$d$","_ret$idlookup$d$id","oldname","newname","ClassNameChanged","parseLabel","isNode","_mainView","dv","fromPointer","tp","val","allContextKeys","vid","mainView","tv","k","constantsList","UDList","paramStr","join","ud","c","body","arr","NODES_RECOMPILE_labels","successfullyParsed","NODES_RECOMPILE_longestLabel","VIEWS_RECOMPILE_labels","VIEWS_RECOMPILE_longestLabel","VIEWS_RECOMPILE_ocl","oclEngine","oclChanged","tnv","OCLScore","NOT_EVALUATED_YET","VIEWS_RECOMPILE_preconditions","metaclassScore","VIEWS_RECOMPILE_constants","constants","constantsOutput","context","constantsFunction","Function","bind","VIEWS_RECOMPILE_jsCondition","VIEWS_RECOMPILE_usageDeclarations","VIEWS_RECOMPILE_jsxString","VIEWS_RECOMPILE_events","MeasurableKeys","_dv$usageDeclarations","usageDeclarations","UDFunction","matches","match","map","s","udstr","udlist","udErrors","maxi","isSyntax","errbody","entry","events","message","split","jsConditionChanged","jsCondition","lines","lastLine","jsxString","JSXFunction","parseAndInject","parser","displayError","_ref","str","dataid","modelElement","nodes","data","makeOCLConstructor","times","removedDeltas","exDev","delta","undoable","pop","undo","flatMap","redoable","doreducer","objectDelta","filterundoableactions","globalcanundostate","isundo","undonestate","undorecursive","deltalevel","statelevel","ca","forceinit","setSubclasses","roots","extendMatrix","getiIsSubElementMatrix","buildLSingletons","alld","alll","dname","tagless","l","logic","singleton","structure","setDocumentEvents","setTimeout","$","document","on","get","stopPanning","fixResizables","stateInitializer","fixStatics","dClassesMap","lClassesMap","classes","defaultContext","getAllClassesDictionary","Components","init","user","read","surname","nickname","affiliation","country","newsletter","email","token","getAll","$RefreshReg$"],"sources":["C:/0Programmi/Dev/projects/frontend/jjodel/frontend/src/redux/reducer/reducer.ts"],"sourcesContent":["import {\r\n    U as UType,\r\n    GraphDragManager,\r\n    MouseUpEvent,\r\n    orArr,\r\n    DModelElement,\r\n    DViewElement,\r\n    DClass,\r\n    DModel,\r\n    UX,\r\n    EdgeOwnProps,\r\n    EdgeStateProps,\r\n    GraphElementComponent,\r\n    ViewEClassMatch,\r\n    bool,\r\n    NodeTransientProperties,\r\n    ViewTransientProperties,\r\n    DGraphElement, Uarr\r\n} from '../../joiner';\r\nimport {\r\n    Action,\r\n    CompositeAction,\r\n    CreateElementAction,\r\n    DeleteElementAction,\r\n    Dictionary,\r\n    DocString,\r\n    DPointerTargetable,\r\n    DState,\r\n    DUser,\r\n    getPath,\r\n    GObject,\r\n    Log,\r\n    LPointerTargetable,\r\n    MyError,\r\n    ParsedAction,\r\n    PendingPointedByPaths,\r\n    PointedBy,\r\n    Pointer,\r\n    Pointers,\r\n    RuntimeAccessibleClass,\r\n    SetFieldAction,\r\n    SetRootFieldAction,\r\n    statehistory\r\n} from \"../../joiner\";\r\nimport React from \"react\";\r\nimport {LoadAction, RedoAction, UndoAction} from \"../action/action\";\r\nimport Collaborative from \"../../components/collaborative/Collaborative\";\r\nimport {SimpleTree} from \"../../common/SimpleTree\";\r\nimport {transientProperties, Selectors} from \"../../joiner\";\r\nimport {OclEngine} from \"@stekoe/ocl.js\";\r\nimport { contextFixedKeys } from '../../graph/graphElement/sharedTypes/sharedTypes';\r\nimport Storage from \"../../data/storage\";\r\nimport {ProjectsApi} from \"../../api/persistance\";\r\nimport DSL from \"../../DSL/DSL\";\r\n\r\nlet windoww = window as any;\r\nlet U: typeof UType = windoww.U;\r\n\r\n\r\nfunction deepCopyButOnlyFollowingPath(oldStateDoNotModify: DState, action: ParsedAction, prevAction: ParsedAction, newVal: any): DState | false{\r\n    let newRoot: DState = {...oldStateDoNotModify} as DState;\r\n    let current: any = newRoot;\r\n    if (!action.path?.length) throw new MyError(\"path length must be at least 1\", {action});\r\n    let gotChanged: boolean = false; // dovrebbe cambiare sempre, se non cambia non lancio neanche l'azione e non faccio la shallow copy, ma non si sa mai, così posso evitare un render se succede l' \"insuccedibile\"\r\n    let alreadyPastDivergencePoint = false; // true dal momento in cui il path dell'azione attuale e della azione precedente divergono, false fino al sotto-segmento in cui combaciano\r\n    // console.log('deepCopyButOnlyFollowingPath', arguments);\r\n    for (let i = 0; i < action.pathArray.length; i++) {\r\n        let key = action.pathArray[i].trim();\r\n        let prevActionPathKey = prevAction?.pathArray[i];\r\n        // middle execution: not on final loop\r\n        // console.log('deepCopyButOnlyFollowingPath', {current, i, imax:action.pathArray.length, key, gotChanged, alreadyPastDivergencePoint});\r\n        if (i !== action.pathArray.length - 1) {\r\n            if (alreadyPastDivergencePoint || key !== prevActionPathKey) {\r\n                // se l'oggetto è stato già duplicato in una azione composita, non lo duplico 2 volte.\r\n                alreadyPastDivergencePoint = true;\r\n                current[key] = Array.isArray(current[key]) ? [...current[key]] : {...current[key]};\r\n                current[key].clonedCounter = 1 + (current[key].clonedCounter || 0);\r\n            }\r\n            current = current[key];\r\n            continue;\r\n        }\r\n        // Giordano: added this on 03/12/2023 to prevent \"Cannot read properties of undefined\".\r\n        // if(!current) continue; damiano: temp removed to check if there are invalid actions firing\r\n        // perform final assignment\r\n        if (i >= action.pathArray.length - 1) {\r\n            let isArrayAppend = false;\r\n            let isArrayRemove = false;\r\n            let isObjectMerge = false;\r\n            let isObjectDifference = false;\r\n            // console.log('isarrayappend?', {endswith: U.endsWith(key, ['+=', '[]', '-1']), key, action, i});\r\n            // console.log('isarraydelete?', {endswith: U.endsWith(key, ['-='])});\r\n\r\n            let oldValue: any;\r\n            if (U.endsWith(key, ['+=', '[]'])) {\r\n                key = key.substr(0, key.length - 2).trim();\r\n                oldValue = current[key];\r\n                switch (typeof oldValue){\r\n                    case 'object':\r\n                    if (Array.isArray(oldValue)) isArrayAppend = true;\r\n                    else isObjectMerge = true;\r\n                    break;\r\n                    default: newVal += oldValue; break;\r\n                }\r\n            }\r\n            if (U.endsWith(key, ['-='])) {\r\n                key = key.substr(0, key.length - 2).trim();\r\n                oldValue = current[key];\r\n                switch (typeof oldValue){\r\n                    case 'object':\r\n                        if (Array.isArray(oldValue)) isArrayRemove = true;\r\n                        else isObjectDifference = true;\r\n                        break;\r\n                    case \"string\":\r\n                        newVal = U.replaceAll(oldValue, newVal, '');\r\n                        break;\r\n                    case 'number': newVal = oldValue - newVal; break;\r\n                    default: isArrayRemove = true; break;\r\n                }\r\n                // isArrayRemove = true;\r\n            }\r\n\r\n            // let unpointedElement: DPointerTargetable | undefined;\r\n            // perform final assignment\r\n            if (action.type === CreateElementAction.type && current[key]) {\r\n                oldValue = current[key];\r\n                gotChanged = false;\r\n                Log.ee(\"rejected CreateElementAction, rollback occurring:\", {action,\r\n                    preexistingValue: current[key], isShallowEqual: current[key] === action.value });\r\n                return false; // warning: use return only when you want to abort and skip subsequent CompositeAction sub-actions like now.\r\n            }\r\n            if (isObjectMerge) {\r\n                if (typeof newVal === 'string') { let tmp: any = {}; tmp[newVal] = true; newVal = tmp; }\r\n                oldValue = {...current[key]};\r\n                current[key] = {...current[key]};\r\n                for (let subkey in newVal) {\r\n                    // console.warn(\"object merge\", {current, key, subkey, newVal, old:current[key][subkey], new:newVal[subkey]});\r\n                    if (current[key][subkey] === newVal[subkey]) continue;\r\n                    current[key][subkey] = newVal[subkey];\r\n                    gotChanged = true;\r\n                    if (action.isPointer) { newRoot = PointedBy.add(key as Pointer, action, newRoot, \"+=\"); }\r\n                }\r\n            } else\r\n            if (isObjectDifference) {\r\n                if (typeof newVal === 'string') { let tmp: any = {}; tmp[newVal] = true; newVal = tmp; }\r\n                oldValue = {...current[key]};\r\n                current[key] = {...current[key]};\r\n                for (let subkey in newVal) {\r\n                    if (!(subkey in current[key])) continue;\r\n                    delete current[key][subkey];\r\n                    gotChanged = true;\r\n                    if (action.isPointer) { newRoot = PointedBy.add(key as Pointer, action, newRoot, \"-=\"); }\r\n                }\r\n            } else\r\n            if (isArrayAppend) {\r\n                gotChanged = true;\r\n                if (!Array.isArray(current[key])) { current[key] = []; }\r\n                oldValue = [...current[key]];\r\n                current[key] = [...current[key]];\r\n                current[key].push(newVal);\r\n                // unpointedElement = undefined;\r\n                if (action.isPointer) { newRoot = PointedBy.add(newVal as Pointer, action, newRoot, \"+=\"); }\r\n            } else\r\n            if (isArrayRemove) {\r\n                if (!Array.isArray(current[key])) { current[key] = []; }\r\n                oldValue = [...current[key]];\r\n                let index: number;\r\n                if (U.isNumber(newVal)) { // delete by index\r\n                    index = newVal;\r\n                    if (index < 0) index = oldValue.length + index; // if index is -2, i remove the penultimate element\r\n                } else\r\n                if (newVal === undefined) {\r\n                    index = oldValue.length - 1;\r\n                }\r\n                else {\r\n                    index = oldValue.indexOf(newVal);\r\n                }\r\n                // if it's negatively or positively out of boundary, i skip it\r\n                gotChanged = index >= 0 && index < current[key].length;\r\n                if (gotChanged) {\r\n                    current[key] = [...current[key]];\r\n                    let removedval = current[key].splice(index, 1); // in-place edit\r\n                    if (action.isPointer) { newRoot = PointedBy.remove(removedval as Pointer, action, newRoot, '-='); }\r\n                    /*\r\n                    fixed problem: se ho [dobj1, dobj2]... e li swappo, cambia un indice nel percorso \"pointedby\" e non me ne accorgo mai e un oggetto risulta \"pointedby\" da oggetti che non lo puntano o non esistono più a quell'indice\r\n                    SOLVED! by not including index in pointedBy path, but making it like \"parentObject.arrayKey+=\" instead of \"parentObject.arrayKey.4\"\r\n                    and knowing it's in the array it's enough info.\r\n\r\n                    // a.pointsto = [x, y, z]; a.pointsto = [x, z]       --->    remove a from y.pointedby\r\n                    const elementsThatChangedIndex: DPointerTargetable[] = current[key].slice(index);\r\n\r\n                    for (let j = 0; j < elementsThatChangedIndex.length; j++) {\r\n                        let newindex = index + j - 1;\r\n                        let oldFullpathTrimmed = action.pathArray.join('.');\r\n                        se realizzi \"pointedby\" qui è to do: remove old paths and re-add them with updated index\r\n                    }\r\n                    unpointedElement = newRoot.idlookup[oldValue];\r\n                    */\r\n                }\r\n            } else\r\n            if ((action.type === DeleteElementAction.type && !(key in current)) || current[key] === newVal) {\r\n                // value not changed\r\n                gotChanged = false;\r\n            } else {\r\n                // value changed\r\n                // todo: caso in cui setto manualmente classes.1 = pointer;\r\n                //  the latest element is array and not DPointerTargetable, so might need to buffer upper level in the tree? or instead of \"current\" keep an array of sub-objects encountered navigating the path in state.\r\n                oldValue = current[key];\r\n                gotChanged = true;\r\n                // unpointedElement = newRoot.idlookup[oldValue];\r\n                // NB: se elimino un oggetto che contiene array di puntatori, o resetto l'array di puntatori kinda like store.arr= [ptr1, ptr2, ...]; store.arr = [];\r\n                // i puntati dall'array hanno i loro pointedBY non aggiornati, non voglio fare un deep check di tutto l'oggetto a cercare puntatori per efficienza.\r\n                // if (newVal === undefined) delete current[key];\r\n                if ((newVal === undefined) || false && action.type === DeleteElementAction.type) delete current[key];\r\n                else current[key] = newVal;\r\n\r\n                // update pointedBy's\r\n                // NB: even if the current action have isPointer=true, it doesn't mean the old value is a pointer as well for sure. so need to check old values.\r\n                // also what if old val is pointer, and new one isn't? will it be just removed without updating pointedBy's?\r\n                // already fixed: might need to evaluate this if block always regardless of action.isPointer,\r\n                // and do checks every time both on old and new value if they actually are ptrs.\r\n                if (true || action.isPointer) {\r\n                    let oldpointerdestinations: unknown[];\r\n                    let newpointerdestinations: unknown[];\r\n                    if (Array.isArray(newVal)) {\r\n                        newpointerdestinations = newVal;\r\n                        if (Array.isArray(oldValue)) { // case: path.array = array;\r\n                            oldpointerdestinations = oldValue;\r\n                        }\r\n                        else { // case: path.object = array; + case: path.value = array;\r\n                            oldpointerdestinations = [oldValue];\r\n                        }\r\n                    }\r\n                    else {\r\n                        // case: path.array = object; + case: path.array = value;\r\n                        newpointerdestinations = [newVal];\r\n                        if (Array.isArray(oldValue)) {\r\n                            oldpointerdestinations = oldValue;\r\n                        } else {\r\n                            // case: path.object = object; and all other cases without arrays involved\r\n                            oldpointerdestinations = [oldValue];\r\n                        }\r\n                    }\r\n                    // after i mapped all cases to path.array = array; i solve it for that case.\r\n                    let difference = U.arrayDifference(oldpointerdestinations, newpointerdestinations); // : {added: Pointer[], removed: Pointer[], starting: Pointer[], final: Pointer[]}\r\n                    for (let rem of difference.removed) {if (Pointers.isPointer(rem))\r\n                        newRoot = PointedBy.remove(rem, action, newRoot, undefined, oldStateDoNotModify); }\r\n                    for (let add of difference.added) { if (Pointers.isPointer(add))\r\n                        newRoot = PointedBy.add(add, action, newRoot, undefined, oldStateDoNotModify); }\r\n                    // a.pointsto = [a, b, c];  a.pointsto = [a, b, x];    ------>     c.pointedby.remove(a) & x.pointedby.add(a)\r\n                    // idlookup.somelongid.pointsto = [...b];\r\n                }\r\n            }\r\n            break;\r\n        }\r\n        Log.exDevv('should not reach here: reducer');\r\n    }\r\n    return gotChanged ? newRoot : oldStateDoNotModify;\r\n}\r\n\r\n\r\n// const pendingPointedByPaths: {from: DocString<\"Path in store\">, field: DocString<\"keyof object found in from path\">, to: Pointer}[] = [];\r\nfunction CompositeActionReducer(oldState: DState, actionBatch: CompositeAction): DState {\r\n    // per via di thunk se arrivo qui lo stato cambia sicuro in mono-client non synchro (non ri-assegno valori equivalenti)\r\n    // todo: ma se arrivano in ordine sbagliato da altri client? posso permetterlo?\r\n    let actions: ParsedAction[];\r\n    if (actionBatch.actions) actions = Action.parse(actionBatch.actions);\r\n    else actions = [Action.parse(actionBatch)]; // else-case is if it's a single action and not an actual compositeaction\r\n    if (PendingPointedByPaths.all.length) actions.push(...PendingPointedByPaths.getSolveableActions(oldState)); //.all.map( p=> p.resolve() ) );\r\n\r\n    Action.possibleInconsistencies = {};\r\n\r\n    // estraggo le azioni derivate\r\n    let derivedActions: ParsedAction[] = [];\r\n    let newState = oldState;\r\n    for (let action of actions) {\r\n        switch (action.type){\r\n            default: break;\r\n            case CreateElementAction.type:\r\n                const elem: DPointerTargetable = action.value;\r\n                delete DPointerTargetable.pendingCreation[elem.id];\r\n                /*\r\n                if (oldState.idlookup[elem.id]) {\r\n                    Log.ee(\"rejected CreateElementAction, rollback occurring:\", {action, elem:{...elem},\r\n                        preexistingValue: {...oldState.idlookup[elem.id]}, isEqual: elem === oldState.idlookup[elem.id] });\r\n                    return oldState; // warning: use return only when you want to abort and skip subsequent CompositeAction sub-actions like now.\r\n\r\n                    action.value = \"An element with that id already existed.\";\r\n                    action.path = action.field = \"CreateActionRejected\";\r\n                    action.className = SetRootFieldAction.name;\r\n                    action.type = SetRootFieldAction.type;\r\n                    action.pathArray = [action.path]; //a\r\n                    action.isPointer = false;\r\n                    // just to log it in undo-redo action list and have a feedback\r\n                    return oldState;}*/\r\n\r\n                elem.className = elem.className || (elem.constructor as typeof RuntimeAccessibleClass).cname || elem.constructor.name;\r\n                let statefoldername = elem.className.substring(1).toLowerCase() + 's';\r\n                derivedActions.push(\r\n                    Action.parse(SetRootFieldAction.create(statefoldername, elem.id,'[]', true)));\r\n                if (!Array.isArray(elem.pointedBy)) elem.pointedBy = [];\r\n                elem.pointedBy.push(PointedBy.new(statefoldername));\r\n                /*if (false && action.isPointer) {\r\n                    if (Array.isArray(action.value)) {\r\n                        const ptr: Pointer[] = action.value;\r\n                        // todo but replaced by side actions in execution of the main action instead of triggering derived actions\r\n                    }\r\n                    else {\r\n                        const ptr: Pointer = action.value;\r\n                        const target: DPointerTargetable | null = oldState.idlookup[ptr];\r\n                        let pendingPointedBy = PendingPointedByPaths.new(action, oldState);\r\n                        if (!target) PendingPointedByPaths.new(action, oldState).saveForLater(); // {from: action.path, field: action.field, to: target});\r\n                        // @ts-ignore\r\n                        else derivedActions.push(pendingPointedBy.resolve());\r\n                        // a -> x\r\n                        // a -> y     unset x.pointedby(a)\r\n                    }\r\n                }*/\r\n                break;\r\n        }\r\n    }\r\n    // console.error({U, Umip:U.arrayMergeInPlace, WU: windoww.U, WUmip: windoww.U.arrayMergeInPlace});\r\n    actions = U.arrayMergeInPlace<ParsedAction>(actions, derivedActions);\r\n\r\n    // ordino i path con segmenti comuni\r\n    actions = actions.sort( (a1, a2) => U.stringCompare(a1.path, a2.path));\r\n\r\n    // destrutturo solo i nodi intermedi e solo la prima volta che li incontro (richiede le azioni ordinate in base al path)\r\n\r\n    for (let i = 0; i < actions.length; i++) {\r\n        const prevAction: ParsedAction = actions[i-1];\r\n        const action: ParsedAction = actions[i];\r\n        const actiontype = action.type.indexOf('@@') === 0 ? 'redux' : action.type;\r\n        console.log('executing action:', {a:action, t:actiontype, field: action.field, v:action.value}); //, count: ++action.executionCount});\r\n\r\n        switch (actiontype) {\r\n            /*\r\n            case '@@redux/INIT6.x.f.d.r.e':\r\n            case '@@redux/INITm.f.1.s.o.g':\r\n            case '@@redux/INIT5.t.4.v.d.o':\r\n            case '@@redux/INITy.a.d.r.l.a':\r\n            case '@@redux/INIT4.2.q.u.z.k':\r\n            case '@@redux/INITj.8.e.g.y.p':\r\n            case '@@redux/INITp.k.q.g.z.w':\r\n            case '@@redux/INITq.c.u.w.f.e': ... etc*/\r\n            default:\r\n                if (action.type.indexOf('@@redux/') === 0) break;\r\n                return Log.exDevv('unexpected action type:', action.type);\r\n            case LoadAction.type: newState = action.value; break;\r\n            case CreateElementAction.type:\r\n            case SetRootFieldAction.type:\r\n            case DeleteElementAction.type:\r\n            case SetFieldAction.type:\r\n                let tmp: false | DState = deepCopyButOnlyFollowingPath(newState, action, prevAction, action.value);\r\n                if (!tmp) return oldState; // rollback due to invalid action in transaction\r\n                newState = tmp;\r\n                break;\r\n        }\r\n\r\n        // and that's all, the reducer is really simple as actions are really simple.\r\n    }\r\n\r\n    // effetti collaterali, aggiornamento di ridondanze\r\n    newState = updateRedundancies_OBSOLETE(newState, oldState, Action.possibleInconsistencies);\r\n    return newState;\r\n}\r\n\r\nfunction updateRedundancies_OBSOLETE(state: DState, oldState:DState, possibleInconsistencies: Dictionary<DocString<'subtype'>, (Pointer | DPointerTargetable)[]>): DState {\r\n    for (let subType in possibleInconsistencies)\r\n    switch (subType) {\r\n        default: break;\r\n        case Action.SubType.vertexSubElements:/*\r\n            risolto triggrerando più azioni da LGraphElement setter\r\n            let dvertexid: Pointer, newdvertex: DGraphElement, olddvertex: DGraphElement;\r\n            for (newdvertex of possibleInconsistencies[subType] as DGraphElement[]){\r\n                const olddvertex: DGraphElement = oldState.idlookup[newdvertex.id] as DGraphElement;\r\n                const notContainedAnymoreOut: Pointer<DGraphElement> = [];\r\n                const newlyInsertedOut: Pointer<DGraphElement>[] = [];\r\n                U.arraySymmetricDifference(olddvertex.subElements, newdvertex.subElements, notContainedAnymoreOut, newlyInsertedOut);\r\n                for (let geid of notContainedAnymoreOut) {\r\n                    const oldge = oldState.idlookup[geid] as DGraphElement;\r\n                    const newge = state.idlookup[geid] as DGraphElement;\r\n                    if (oldge.containedIn === newge.containedIn) continue;\r\n                }\r\n                for (let geid of notContainedAnymoreOut) {\r\n                    const ge = idlookup[geid] as DGraphElement;\r\n                    if (ge.containedIn === context.data.id) set container = context.data.id\r\n                    meglio se sti 2 cicli li fai nel reducer perchè  potrebbe esserci una azione pending che setta il parent = someotherid e qui faccio partire una azione che setta il parent a null, \"annullando\" una azione pending non ancora eseguita\r\n                }\r\n            }\r\n            break;*/\r\n    }\r\n    // if state is updated shallow copy state before returning it\r\n    return state;\r\n}\r\n\r\nlet initialState: DState = null as any;\r\nlet storeLoaded: boolean = false;\r\n\r\nconst UDRegexp = /(?:^|\\s|;|}|\\n|\\t|\\(|,)ret\\s*\\.\\s*[a-zA-Z_$][0-9a-zA-Z_$]*\\s*=/g;\r\n/* tested with:\r\nif (ret.key = stuff) ret.key2=morestuff;\r\n;ret.k=3;\r\n}ret. kk=3,ret. a = 3\r\n\r\nret .b = 3\r\n*/\r\n\r\n\r\n// then add to it: content of props, constants, usageDeclarations\r\n\r\nexport function reducer(oldState: DState = initialState, action: Action): DState {\r\n    try{ return unsafereducer(oldState, action); }\r\n    catch(e) {\r\n        console.error('unhandled error in reducer', {e, oldState, action});\r\n        return oldState;\r\n    }\r\n}\r\n\r\nfunction unsafereducer(oldState: DState = initialState, action: Action): DState {\r\n    const ret = _reducer(oldState, action);\r\n    if (ret === oldState) return oldState;\r\n    // ret.idlookup.__proto__ = DPointerTargetable.pendingCreation as any;\r\n    // client synchronization stuff\r\n    if (oldState?.collaborativeSession) {\r\n        const ignoredFields: (keyof DState)[]  = [\r\n            'version',\r\n            'env',\r\n            'debug',\r\n            'isEdgePending',\r\n            'contextMenu',\r\n            '_lastSelected',\r\n            'isLoading',\r\n            'collaborativeSession',\r\n            'VIEWS_RECOMPILE_onDataUpdate',\r\n            'VIEWS_RECOMPILE_onDragStart',\r\n            'VIEWS_RECOMPILE_onDragEnd',\r\n            'VIEWS_RECOMPILE_whileDragging',\r\n            'VIEWS_RECOMPILE_onResizeStart',\r\n            'VIEWS_RECOMPILE_onResizeEnd',\r\n            'VIEWS_RECOMPILE_whileResizing',\r\n            'VIEWS_RECOMPILE_onRotationStart',\r\n            'VIEWS_RECOMPILE_onRotationEnd',\r\n            'VIEWS_RECOMPILE_whileRotating',\r\n            'VIEWS_RECOMPILE_constants',\r\n            'VIEWS_RECOMPILE_usageDeclarations',\r\n            'VIEWS_RECOMPILE_jsxString',\r\n            'VIEWS_RECOMPILE_preconditions',\r\n            'VIEWS_RECOMPILE_jsCondition',\r\n            'VIEWS_RECOMPILE_ocl',\r\n            'VIEWS_RECOMPILE_events',\r\n            'VIEWS_RECOMPILE_all',\r\n            'ClassNameChanged',\r\n            'tooltip',\r\n            'advanced',\r\n            'alert'\r\n        ];\r\n        /* Checking if CompositeAction has some actions that MUST be ignored */\r\n        let compositeAction: CompositeAction|null = null;\r\n        if(action.type === CompositeAction.type) {\r\n            compositeAction = action as CompositeAction;\r\n            const subActions = compositeAction.actions || [];\r\n            compositeAction.actions = subActions.filter(a => !ignoredFields.includes(a.field as keyof DState));\r\n        }\r\n        if(compositeAction && !compositeAction.actions.length) return ret;\r\n        action = (compositeAction) ? compositeAction : action;\r\n        if(action.sender === DUser.current && !ignoredFields.includes(action.field as keyof DState)) {\r\n            const parsedAction: JSON & GObject = JSON.parse(JSON.stringify(action));\r\n            Collaborative.client.emit('pushAction', parsedAction);\r\n        }\r\n    }\r\n\r\n    for (let ptr of ret.ELEMENT_CREATED){\r\n        let d = ret.idlookup[ptr];\r\n        if (!d) continue; // creation rejected, no-op\r\n        switch(d.className){\r\n            default: break;\r\n            case \"DViewElement\":\r\n                for(let nid in transientProperties.node){\r\n                    let tn = transientProperties.node[nid];\r\n                    tn.viewScores[d.id as any] = {} as any;\r\n                }\r\n        }\r\n    }\r\n    ret.ELEMENT_CREATED = [];\r\n    for (let ptr of ret.ELEMENT_DELETED){\r\n        let d = oldState.idlookup[ptr];\r\n        if (!d) continue; // already deleted, no-op\r\n        switch(d.className){\r\n            default: break;\r\n            case \"DViewElement\":\r\n                for (let nid in transientProperties.node) {\r\n                    let tn = transientProperties.node[nid];\r\n                    // delete tn.stackViews; // trigger recalc of all scores.\r\n                    delete tn.viewScores[d.id as any];\r\n                    tn.needSorting = true;\r\n                }\r\n        }\r\n    }\r\n    ret.ELEMENT_DELETED = [];\r\n\r\n    if (ret.VIEWS_RECOMPILE_all === true) ret.VIEWS_RECOMPILE_all = Object.keys(ret.idlookup);\r\n    if ((ret.VIEWS_RECOMPILE_all as Pointer[])?.length) {\r\n        let resetAllNodes: boolean = false;\r\n        let sk: keyof DState;\r\n        for (let id of new Set(ret.VIEWS_RECOMPILE_all as Pointer[])){\r\n            let d = ret.idlookup[id];\r\n            if (!d) continue;\r\n            if (RuntimeAccessibleClass.extends(d.className, \"DViewElement\")) {\r\n                (d as DViewElement).css_MUST_RECOMPILE = true;\r\n                transientProperties.view[d.id as string] = { } as any;\r\n                // for (let k of DViewElement.MeasurableKeys) (ret as any)['VIEWS_RECOMPILE_'+k].push(d.id);\r\n                // for (let k of DViewElement.RecompileKeys) (ret as any)['VIEWS_RECOMPILE_'+k].push(d.id);\r\n                for (sk in ret) if (sk.indexOf('VIEWS_RECOMPILE') === 0) (ret[sk] as Pointer[]).push(id);\r\n                // ret.NODES_RECOMPILE_labels.push(id); ret.NODES_RECOMPILE_longestLabel.push(id);\r\n                if (!resetAllNodes) resetAllNodes = true;\r\n            }\r\n            if (RuntimeAccessibleClass.extends(d.className, \"DModelElement\")) {\r\n                if (d.className === \"DClass\") {\r\n                    let oldname = (oldState.idlookup[d.id] as DClass)?.name;\r\n                    let newname = (ret.idlookup[d.id] as DClass)?.name;\r\n                    if (oldname !== newname) ret.ClassNameChanged[d.id as Pointer<DClass>] = oldname;\r\n                }\r\n                for (sk in ret) if (sk.indexOf('MODELS_RECOMPILE') === 0) (ret[sk] as Pointer[]).push(id);\r\n                // transientProperties.modelElement[d.id] = { } as any; stuff in here does not need replacement, can never be dangerous (currently).\r\n            }\r\n            if (RuntimeAccessibleClass.extends(d.className, \"DGraphElement\")) {\r\n                transientProperties.node[d.id as string] = { } as any;\r\n                for (sk in ret) if (sk.indexOf('NODES_RECOMPILE') === 0) (ret[sk] as Pointer[]).push(id);\r\n                //ret.NODES_RECOMPILE_labels.push(id); ret.NODES_RECOMPILE_longestLabel.push(id);\r\n            }\r\n        }\r\n        if (resetAllNodes) for (let nid in transientProperties.node) {\r\n            transientProperties.node[nid] = {} as any;\r\n            for (sk in ret) if (sk.indexOf('NODES_RECOMPILE') === 0) (ret[sk] as Pointer[]).push(nid);\r\n            //ret.NODES_RECOMPILE_labels.push(id); ret.NODES_RECOMPILE_longestLabel.push(id);\r\n        }\r\n    }\r\n    ret.VIEWS_RECOMPILE_all = [];\r\n\r\n\r\n\r\n    function parseLabel(ptr: Pointer, key: \"labels\" | \"longestLabel\", isNode: boolean): boolean{\r\n        let dv: GObject<DViewElement | DGraphElement> = DPointerTargetable.fromPointer(ptr, ret);\r\n        let tp: NodeTransientProperties | ViewTransientProperties = ((isNode ? transientProperties.node : transientProperties.view) as GObject)[ptr];\r\n        if (!tp) ((isNode ? transientProperties.node : transientProperties.view) as GObject)[ptr] = tp = {} as any;\r\n        let val: string = dv[key];\r\n        if (!val) { tp[key] = undefined as any; return true; }\r\n        if (typeof val === \"function\") { tp[key] = val; return true; }\r\n        let allContextKeys = {...contextFixedKeys};\r\n        let vid: Pointer<DViewElement> = isNode ? (tp as NodeTransientProperties).mainView?.id : ptr as any;\r\n        if (!vid) return false; // leave pending & recompute them on next reducer action\r\n        let tv = transientProperties.view[vid];\r\n        for (let k of tv.constantsList) if (!allContextKeys[k]) allContextKeys[k] = true;\r\n        for (let k of tv.UDList) if (!allContextKeys[k]) allContextKeys[k] = true;\r\n        let paramStr = '{'+Object.keys(allContextKeys).join(',')+'}';\r\n        console.log('labels parse', { allContextKeys, ud:tv.UDList, c:tv.constantsList });\r\n        const body: string =  'return (' + val + ')';\r\n        // if (vid.includes('Model')) console.log(\"modelparse, laels\", {paramStr, body});\r\n        console.log('labels parse', {vid: ptr, paramStr, body});\r\n        try {\r\n            if (isNode) {\r\n                // need to store the function in tnv instead of tn since if v changes, ud changes as well? in all of them?what if i make a new view?\r\n            }\r\n            else {\r\n                // tp[key] = new Function(paramStr, body) as ((...a: any) => any);\r\n            }\r\n            tp[key] = function(){ return 'label as an option is disabled, pass it through props instead.'; }\r\n        }\r\n        catch (e: any) {\r\n            /*try{\r\n                let try_to_get_better_error = eval(\"let __f = function(\" + paramStr+\") {\\n\" + body + \"}\");\r\n            } catch(eeval){\r\n                console.error(\"eval error same as func error\", {e, eeval});\r\n                e = eeval;\r\n            }*/\r\n            console.error('error labels parse', {vid: ptr, e, paramStr, body});\r\n            tp[key] = val;// (context: GObject) => 'Error during label evaluation';\r\n        }\r\n        return true;\r\n        // implies recompilation of: ... nothing?\r\n    }\r\n    let arr: Pointer<any>[]\r\n    arr = ret.NODES_RECOMPILE_labels;\r\n    if (arr.length) {\r\n        let successfullyParsed: Dictionary<string, boolean> = {};\r\n        for (const id of new Set(arr)) successfullyParsed[id] = parseLabel(id, 'labels', true);\r\n        ret.NODES_RECOMPILE_labels = arr.filter(e => !successfullyParsed[e]);\r\n    }\r\n    arr = ret.NODES_RECOMPILE_longestLabel;\r\n    if (arr.length) {\r\n        let successfullyParsed: Dictionary<string, boolean> = {};\r\n        for (const id of new Set(arr)) successfullyParsed[id] = parseLabel(id, 'longestLabel', true);\r\n        ret.NODES_RECOMPILE_longestLabel = arr.filter(e => !successfullyParsed[e]);\r\n    }\r\n    arr = ret.VIEWS_RECOMPILE_labels;\r\n    if (arr.length) {\r\n        let successfullyParsed: Dictionary<string, boolean> = {};\r\n        for (const id of new Set(arr)) successfullyParsed[id] = parseLabel(id, 'labels', false);\r\n        ret.VIEWS_RECOMPILE_labels = arr.filter(e => !successfullyParsed[e]);\r\n    }\r\n    arr = ret.VIEWS_RECOMPILE_longestLabel;\r\n    if (arr.length) {\r\n        let successfullyParsed: Dictionary<string, boolean> = {};\r\n        for (const id of new Set(arr)) successfullyParsed[id] = parseLabel(id, 'longestLabel', false);\r\n        ret.VIEWS_RECOMPILE_longestLabel = arr.filter(e => !successfullyParsed[e]);\r\n    }\r\n\r\n    // local changes to out-of-redux stuff\r\n    if (ret.VIEWS_RECOMPILE_ocl.length) {\r\n        // for (let gid of ret.graphs) Selectors.updateViewMatchings(gid, ret.modelElements, Object.values(ret.idlookup).map( d => RuntimeAccessibleClass.extends(d, DModelElement.cname)));\r\n        // for (let vid of ret.VIEW_APPLIABLETO_NEEDS_RECALCULATION) { }\r\n        for (let vid of new Set(ret.VIEWS_RECOMPILE_ocl)) {\r\n            if (!transientProperties.view[vid]) transientProperties.view[vid] = {} as any;\r\n            transientProperties.view[vid].oclEngine = undefined as any; // force re-parse\r\n            transientProperties.view[vid].oclChanged = true;\r\n            for (let nid in transientProperties.node) {\r\n                let tnv = transientProperties.node[nid].viewScores[vid];\r\n                if (tnv?.OCLScore !== ViewEClassMatch.NOT_EVALUATED_YET) tnv.OCLScore = ViewEClassMatch.NOT_EVALUATED_YET as any as boolean;\r\n            }\r\n        }\r\n        ret.VIEWS_RECOMPILE_ocl = [];\r\n    }\r\n    /*\r\n    if (ret.VIEWOCL_UPDATE_NEEDS_RECALCULATION.length) {\r\n        // not implemented for now\r\n        ret.VIEWOCL_UPDATE_NEEDS_RECALCULATION = [];\r\n    }*/\r\n\r\n    if (ret.VIEWS_RECOMPILE_preconditions.length) {\r\n        for (let vid of new Set(ret.VIEWS_RECOMPILE_preconditions)) {\r\n            for (let nid in transientProperties.node) {\r\n                let tnv = transientProperties.node[nid].viewScores[vid];\r\n                if (tnv?.metaclassScore !== ViewEClassMatch.NOT_EVALUATED_YET) tnv.metaclassScore = ViewEClassMatch.NOT_EVALUATED_YET as any as number;\r\n            }\r\n        }\r\n        ret.VIEWS_RECOMPILE_preconditions = [];\r\n    }\r\n\r\n    if (ret.VIEWS_RECOMPILE_constants?.length)\r\n    for (const vid of new Set(ret.VIEWS_RECOMPILE_constants)) { // compiled in func, and executed, result does not vary between nodes.\r\n        let dv: DViewElement = DPointerTargetable.fromPointer(vid, ret);\r\n        // transientProperties.view[vid].constantsList = dv.constants?.match(UDRegexp).map(s=>s.substring(4, s.length-1).trim()) || [];\r\n        // let allContextKeys = {...contextFixedKeys};\r\n        if (!dv.constants) {\r\n            if (!transientProperties.view[vid]) transientProperties.view[vid] = {} as any;\r\n            transientProperties.view[vid].constants = {};\r\n            transientProperties.view[vid].constantsList = [];\r\n            // no need to recompile UD, jsx or measurables, they will have additional parameters in scope but they are undefined and cause no problems.\r\n            continue;\r\n        }\r\n        const constantsOutput: GObject = {};\r\n        const context = {view:dv}; // context at this point holds only static stuff, which are in gloval scope (window) plus view.\r\n        let paramStr = '{'+Object.keys(context).join(',')+'}, ret';\r\n        try {\r\n            // the scope of new Function() is \"window\" and not the function where is called, unlike eval();\r\n            let constantsFunction: (context: GObject, ret: GObject) => void = new Function(paramStr, 'return ('+dv.constants+')(ret)').bind(context);\r\n            constantsFunction(context, constantsOutput);\r\n        } catch(e:any){\r\n            console.error('error constants parse', {vid, e, paramStr, body:'return ('+dv.constants+')(ret)'});\r\n            // todo: how do i render an error from here? even if i set jsx or ud.__invalidDeclarations it will be recompiled. need a constants.__invalidDeclarations too?\r\n        }\r\n\r\n        transientProperties.view[vid].constants = constantsOutput;\r\n        transientProperties.view[vid].constantsList = Object.keys(transientProperties.view[vid].constants);\r\n        // implies recompilation of: jsCondition, ud, jsx and all measurable events\r\n        ret.VIEWS_RECOMPILE_jsCondition.push(vid);\r\n        ret.VIEWS_RECOMPILE_usageDeclarations.push(vid);\r\n        ret.VIEWS_RECOMPILE_jsxString.push(vid);\r\n        ret.VIEWS_RECOMPILE_events.push(vid);\r\n        for (let k of DViewElement.MeasurableKeys) (ret as any)['VIEWS_RECOMPILE_'+k].push(vid);\r\n    }\r\n    ret.VIEWS_RECOMPILE_constants = [];\r\n\r\n    if (ret.VIEWS_RECOMPILE_usageDeclarations?.length)\r\n    for (const vid of new Set(ret.VIEWS_RECOMPILE_usageDeclarations)) { // compiled in func, but NOT executed, result varies between nodes.\r\n        let dv: DViewElement = DPointerTargetable.fromPointer(vid, ret);\r\n        let tv = transientProperties.view[vid];\r\n        if (!tv) transientProperties.view[vid] = tv = {} as any;\r\n        if (!dv.usageDeclarations) {\r\n            tv.UDList = [];\r\n            tv.UDFunction = undefined as any;\r\n            // no need to recompile jsx or measurables, they will have additional parameters in scope but they are undefined and cause no problems.\r\n            continue;\r\n        }\r\n        let matches = dv.usageDeclarations?.match(UDRegexp) || [];\r\n        transientProperties.view[vid].UDList = matches.map(s=>{ s = s.trim(); return s.substring(s.indexOf('\\.')+1, s.length-2).trim()});\r\n        // warning for user: do not redeclare ret in nested blocks.\r\n        // do not use ret[key] syntax.\r\n        // do not set nested values directly (ret.key.subkey syntax).\r\n        // do not use ret.key +=, -= or any other operator assignment different than \"=\"\r\n        // if that is ever required, do instead\r\n        // do not assign values to ret in block comments\r\n        // those restrictions only apply to the ret object, all those violations can be done on other objects.\r\n        // so the following is valid, and a way to overcome the previous limitations:\r\n        // let subobject = {}; subobject[key] += stuff; ret.somefixedname = subobject;\r\n\r\n        let allContextKeys: Dictionary = {...contextFixedKeys};\r\n        for (let k of tv.constantsList) if (!allContextKeys[k]) allContextKeys[k] = true;\r\n        let paramStr = '{'+Object.keys(allContextKeys).join(',')+'}, ret';\r\n        if (vid.includes('Model')) console.log(\"modelparse, ud\", {paramStr, udstr:dv.usageDeclarations, udlist:transientProperties.view[vid].UDList});\r\n        try {\r\n            tv.UDFunction = new Function(paramStr, 'return ('+dv.usageDeclarations+')(ret)') as (...a:any)=>any;\r\n        } catch (e:any) {\r\n            // problem: errors cannot be serialized in any way? they have no keys. let strerr = JSON.stringify(e); //(e.message || '').split('\\n')[0]);\r\n            let udErrors: GObject =  windoww.udErrors;\r\n            if (!windoww.udErrors) windoww.udErrors = udErrors = {maxi: 0};\r\n            udErrors[\"e\"+(++udErrors.maxi)] = e;\r\n            e.isSyntax = true;\r\n            let errbody = \"ret.__invalidUsageDeclarations = window.udErrors.e\"+udErrors.maxi+\"; return ret;\";\r\n            console.error('error udparse', {vid, e, paramStr, body: 'return ('+dv.usageDeclarations+')(ret)', errbody});\r\n            tv.UDFunction = new Function(\"unusedContext, ret\", errbody) as (...a:any)=>any;\r\n        }\r\n\r\n\r\n        // implies recompilation of: jsx and all measurable events\r\n        ret.VIEWS_RECOMPILE_jsxString.push(vid);\r\n        ret.VIEWS_RECOMPILE_events.push(vid);\r\n        for (let k of DViewElement.MeasurableKeys) (ret as any)['VIEWS_RECOMPILE_'+k].push(vid);\r\n    }\r\n    ret.VIEWS_RECOMPILE_usageDeclarations = [];\r\n\r\n    if (ret.VIEWS_RECOMPILE_events.length) {\r\n        // for (let gid of ret.graphs) Selectors.updateViewMatchings(gid, ret.modelElements, Object.values(ret.idlookup).map( d => RuntimeAccessibleClass.extends(d, DModelElement.cname)));\r\n        // for (let vid of ret.VIEW_APPLIABLETO_NEEDS_RECALCULATION) { }\r\n        for (let entry of new Set(ret.VIEWS_RECOMPILE_events)) {\r\n            let vid: string;\r\n            let dv: DViewElement;\r\n            let keys: string[];\r\n            if (typeof entry === \"object\") {\r\n                vid = entry.vid;\r\n                dv = DPointerTargetable.fromPointer(vid, ret);\r\n                keys = entry.keys || Object.keys(dv.events);\r\n            }\r\n            else {\r\n                vid = entry;\r\n                dv = DPointerTargetable.fromPointer(vid, ret);\r\n                keys = Object.keys(dv.events);\r\n            }\r\n            let tv = transientProperties.view[vid];\r\n            if (!tv) transientProperties.view[vid] = tv = {} as any;\r\n            if (!tv.events) tv.events = {};\r\n            // if (!tv.events_raw) tv.events_raw = {};\r\n            for (let key of keys) {\r\n                if (!key) { delete tv.events[key]; continue; }\r\n                let allContextKeys = {...contextFixedKeys};\r\n                for (let k of transientProperties.view[vid].constantsList) if (!allContextKeys[k]) allContextKeys[k] = true;\r\n                for (let k of transientProperties.view[vid].UDList) if (!allContextKeys[k]) allContextKeys[k] = true;\r\n                let paramStr = '{'+Object.keys(allContextKeys).join(',')+'}, ..._params';\r\n                // dv.events[key] = (...params)=> code\r\n                const body: string = 'return (' +dv.events[key]+')(..._params)';\r\n                // if (vid.includes('Model')) console.log(\"modelparse, jsx\", {paramStr, body});\r\n                try {\r\n                    tv.events[key] = new Function(paramStr, body) as ((...a:any[])=>any);\r\n                    // tv.events_raw[key] = new Function(paramStr, body) as ((...a:any)=>any);\r\n                    // attempt to auto obtain node context\r\n                    // impossile with view.event.name\r\n                    // could with node.event.name if node.get_event sets a current node thing__, no he must wrap the func!! in the getter\r\n                    // tv.events[key] = (..._params2:any) => { return tv.events_raw[key](context, ..._params2) };\r\n                }\r\n                catch (e: any) {\r\n                    console.error('error jsxparse', {vid, e, paramStr, body});\r\n                    tv.events[key] = (context) => Log.ee(\"failed to parse function body: \" + e.message.split(\"\\n\")[0], e.message);\r\n                }\r\n            }\r\n        }\r\n        ret.VIEWS_RECOMPILE_events = [];\r\n        // triggers recompile of nothing\r\n    }\r\n\r\n    if (ret.VIEWS_RECOMPILE_jsCondition?.length)\r\n    for (const vid of new Set(ret.VIEWS_RECOMPILE_jsCondition)) {\r\n        const dv: DViewElement = DPointerTargetable.fromPointer(vid, ret);\r\n        let tv = transientProperties.view[vid];\r\n        if (!tv) transientProperties.view[vid] = tv = {} as any;\r\n        tv.jsConditionChanged = true;\r\n        if (!dv.jsCondition) {\r\n            tv.jsCondition = undefined;\r\n            continue;\r\n        }\r\n        const lines = dv.jsCondition.trim().split('\\n');\r\n        let lastLine = lines[lines.length - 1];\r\n        if (lastLine.indexOf('return') !== 0) lines[lines.length - 1] = `return (${lastLine})`;\r\n\r\n\r\n        if (!dv.jsxString) { transientProperties.view[vid].JSXFunction = undefined as any; continue; }\r\n        let allContextKeys = {...contextFixedKeys};\r\n        for (let k of transientProperties.view[vid].constantsList) if (!allContextKeys[k]) allContextKeys[k] = true;\r\n\r\n        let paramStr = '{'+Object.keys(allContextKeys).join(',')+'}';\r\n        const body = lines.join('\\n');\r\n        try {\r\n            tv.jsCondition = new Function(paramStr, body) as ((...a:any)=>any);\r\n        } catch (e) {\r\n            tv.jsCondition = undefined;\r\n            console.log('JS Condition parsed error', e);\r\n        }\r\n    }\r\n    ret.VIEWS_RECOMPILE_jsCondition = [];\r\n\r\n\r\n    if (ret.VIEWS_RECOMPILE_jsxString?.length)\r\n    for (const vid of new Set(ret.VIEWS_RECOMPILE_jsxString)) { // compiled in func, but NOT executed, result varies between nodes.\r\n        let dv: DViewElement = DPointerTargetable.fromPointer(vid, ret);\r\n        let tv = transientProperties.view[vid];\r\n        if (!tv) transientProperties.view[vid] = tv = {} as any;\r\n        if (!dv.jsxString) { transientProperties.view[vid].JSXFunction = undefined as any; continue; }\r\n        let allContextKeys = {...contextFixedKeys};\r\n        for (let k of transientProperties.view[vid].constantsList) if (!allContextKeys[k]) allContextKeys[k] = true;\r\n        for (let k of transientProperties.view[vid].UDList) if (!allContextKeys[k]) allContextKeys[k] = true;\r\n        let paramStr = '{'+Object.keys(allContextKeys).join(',')+'}';\r\n\r\n        const body: string =  'return (' + UX.parseAndInject(DSL.parser(dv.jsxString), dv) + ')';\r\n        // if (vid.includes('Model')) console.log(\"modelparse, jsx\", {paramStr, body});\r\n        try {\r\n            transientProperties.view[vid].JSXFunction = new Function(paramStr, body) as ((...a: any) => any);\r\n        }\r\n        catch (e: any) {\r\n            /*try{\r\n                let try_to_get_better_error = eval(\"let __f = function(\" + paramStr+\") {\\n\" + body + \"}\");\r\n            } catch(eeval){\r\n                console.error(\"eval error same as func error\", {e, eeval});\r\n                e = eeval;\r\n            }*/\r\n            console.error('error jsxparse', {vid, e, paramStr, body});\r\n            transientProperties.view[vid].JSXFunction = (context) => GraphElementComponent.displayError(e, 'JSX Syntax', dv);\r\n        }\r\n        // implies recompilation of: ... nothing?\r\n    }\r\n    ret.VIEWS_RECOMPILE_jsxString = [];\r\n\r\n\r\n\r\n    for (const key of DViewElement.MeasurableKeys) {\r\n        if ((ret as any)['VIEWS_RECOMPILE_'+key]?.length)\r\n        for (let vid of new Set((ret as any)['VIEWS_RECOMPILE_'+key]) as any) {\r\n            let dv: DViewElement = DPointerTargetable.fromPointer(vid, ret);\r\n            let tv = transientProperties.view[vid];\r\n            if (!tv) transientProperties.view[vid] = tv = {} as any;\r\n            let str: string = (dv as any)[key];\r\n            if (!str) {\r\n                (transientProperties.view[vid] as any)[key] = undefined;\r\n                continue;\r\n            }\r\n            let allContextKeys = {...contextFixedKeys};\r\n            for (let k of transientProperties.view[vid].constantsList) if (!allContextKeys[k]) allContextKeys[k] = true;\r\n            for (let k of transientProperties.view[vid].UDList) if (!allContextKeys[k]) allContextKeys[k] = true;\r\n            let paramStr = '{'+Object.keys(allContextKeys).join(',')+'}';\r\n            console.log('measurable parse '+key, {allContextKeys, ud:transientProperties.view[vid].UDList, c:transientProperties.view[vid].constantsList });\r\n            console.log('measurable parse '+key, {vid, paramStr, body:str});\r\n            try {\r\n                (transientProperties.view[vid] as any)[key] = new Function(paramStr, str);\r\n            }\r\n            catch (e: any) {\r\n                console.error('error measurable parse '+key, {vid, e, paramStr, body:str});\r\n                (transientProperties.view[vid] as any)[key] = undefined;\r\n                // display error in jsx\r\n                transientProperties.view[vid].JSXFunction = (context) => GraphElementComponent.displayError(e, 'Measurable ' + key + ' Syntax', dv);\r\n                break;\r\n            }\r\n        }\r\n        (ret as any)['VIEWS_RECOMPILE_'+key] = [];\r\n    }\r\n\r\n    for (let dataid in ret.ClassNameChanged) {\r\n        if (dataid === 'clonedCounter') continue;\r\n        // NB: if i ever want to access a constructor's other properties in ocl, like \"context Persona inv: self.$somecounter === Persona.instances.length\",\r\n        // i would need to update this every time a DClass property changes instead of only when name changes.\r\n\r\n        // if it's first creation of a modelpiece\r\n        if (!transientProperties.modelElement[dataid]) {\r\n            transientProperties.modelElement[dataid] = {nodes: {}};\r\n        }\r\n        // update ocl type names\r\n        let data: DClass = ret.idlookup[dataid] as DClass;\r\n        RuntimeAccessibleClass.makeOCLConstructor(data, ret, oldState);\r\n        // here i should reset all tnv.oclEngine too and set all ocl scores to notevaluated, but it is too computationally heavy\r\n        // and it's useful to keep the old ocl condition valid with past names until manually edited.\r\n    }\r\n    ret.ClassNameChanged = {};\r\n\r\n    return ret;\r\n\r\n}\r\n\r\nexport function _reducer/*<S extends StateNoFunc, A extends Action>*/(oldState: DState = initialState, action: Action): DState{\r\n    let times: number;\r\n    let state: DState;\r\n    let removedDeltas: (GObject | undefined)[] = [];\r\n    switch (action.type) {\r\n        case UndoAction.type:\r\n            times = action.value;\r\n            state = oldState;\r\n            Log.exDev(times<=0, \"undo must be positive\", action);\r\n            while (times--) {\r\n                const delta = statehistory[DUser.current].undoable.pop();\r\n                if (!delta) continue;\r\n                removedDeltas.push(delta);\r\n                state = undo(state, delta);\r\n            }\r\n            state.VIEWS_RECOMPILE_all = [...new Set(removedDeltas.flatMap( d => Object.keys(d?.idlookup||{})))];\r\n            // state.VIEWS_RECOMPILE_all = true;\r\n            return state;\r\n\r\n        case RedoAction.type:\r\n            times = action.value;\r\n            state = oldState;\r\n            Log.exDev(times<=0, \"redo must be positive\", action);\r\n            while (times--) {\r\n                const delta = statehistory[DUser.current].redoable.pop();\r\n                if (!delta) continue;\r\n                removedDeltas.push(delta);\r\n                state = undo(state, delta, false);\r\n            }\r\n            state.VIEWS_RECOMPILE_all = [...new Set(removedDeltas.flatMap( d => Object.keys(d?.idlookup||{})))];\r\n            // state.VIEWS_RECOMPILE_all = true;\r\n            return state;\r\n        // case CombineHistoryAction.type: return combineHistory(oldState); break;\r\n        // todo: se al posto di \"annullare l'undo\" memorizzo l'azione e la rieseguo, posso ripetere l'ultimo passo N volte e questa azione diventa utile per combinare passi e ripetere blocchi di azioni assieme\r\n        default:\r\n            let ret = doreducer(oldState, action);\r\n            if (ret === oldState) return ret;\r\n            // statehistory[DUser.current].redoable = [];   <-- Moved to stateInitializer()\r\n            let delta =  U.objectDelta(ret, oldState);\r\n            if (!filterundoableactions(delta)) return ret;\r\n            // console.log(\"setting undoable action:\", {ret, oldState0:{...oldState}, oldState, delta});\r\n            if (oldState !== null) statehistory[DUser.current].undoable.push(delta);\r\n            return ret;\r\n    }\r\n}\r\n\r\nfunction filterundoableactions(delta: Partial<DState>): boolean {\r\n    if (!statehistory.globalcanundostate) return false;\r\n    if (Object.keys(delta).length === 1) {\r\n        if (\"dragging\" in delta) return false;\r\n        if (\"_lastSelected\" in delta) return false;\r\n        if (\"contextMenu\" in delta) return false;\r\n    }\r\n    return true;\r\n}\r\nfunction undo(state: DState, delta: GObject | undefined, isundo = true): DState {\r\n    if (!delta) return state;\r\n    let undonestate: DState = {...state} as DState;\r\n    //   controlla se vengono shallow-copied solo e tutti gli oggetti nested lungo la catena del percorso delle modifiche\r\n    //   es: root.a.b.c=3 + root.a.b.d=3 = 4+1 modifiche, 5 shallow copies including the root\r\n    undorecursive(delta, undonestate);\r\n    if (isundo) statehistory[DUser.current].redoable.push( U.objectDelta(undonestate, state) ); // reverses from undo to redo and viceversa swapping arguments, so the target result after appliying the delta changes\r\n    else statehistory[DUser.current].undoable.push( U.objectDelta(undonestate, state) ); // redo is \"undoing an undo\", reversing his changes just like an undo reverses an ordinary action changes.\r\n    return undonestate;\r\n}\r\n\r\nfunction undorecursive(deltalevel: GObject, statelevel: GObject): void {\r\n    // statelevel = {...statelevel}; not working if i do it here, just a new var. first time copy id done in caller func undo(). recursive copies are done before recursive step\r\n    for (let key in deltalevel) {\r\n        let delta = deltalevel[key];\r\n        console.log(\"undoing\", {delta, key, deltalevel, statelevel})\r\n        if (key.indexOf(\"_-\") === 0) { delete statelevel[key.substring(2)]; continue; }\r\n        if (typeof delta === \"object\") {\r\n        // if (U.isObject(delta, false, false, true)) {\r\n            statelevel[key] = {...statelevel[key]};\r\n            undorecursive(deltalevel[key], statelevel[key]); }\r\n        else { statelevel[key] = delta; }\r\n    }\r\n}\r\n\r\nfunction doreducer/*<S extends StateNoFunc, A extends Action>*/(oldState: DState = initialState, action: Action): DState{\r\n    if (!oldState) { oldState = initialState = DState.new(); }\r\n    let ca: CompositeAction;\r\n    // console.log('external REDUCER', {action, CEtype:CreateElementAction.type});\r\n    if (!storeLoaded) {\r\n        // new SetRootFieldAction('forceinit', true);\r\n        storeLoaded = true;\r\n    }\r\n    if (!(oldState as any).forceinit) {\r\n        // afterStoreLoad();\r\n        // new SetRootFieldAction('forceinit', true);\r\n    } //  setTimeout(afterStoreLoad, 1);\r\n    switch (action.type) {\r\n        case CompositeAction.type: ca = action as CompositeAction; break;\r\n        case LoadAction.type:\r\n        default:\r\n            if (action.type.indexOf('@@redux/') === 0) {\r\n                //storeLoaded = true;\r\n                return oldState;\r\n            }\r\n            ca = new CompositeAction([action], false);\r\n            break;\r\n    }\r\n    let ret = CompositeActionReducer(oldState, ca);\r\n    /*if (state.current !== ret) {\r\n        state.current = ret;\r\n        state.past.push(ret);\r\n    }*/\r\n    return ret;\r\n}\r\nfunction setSubclasses(roots: orArr<typeof RuntimeAccessibleClass>){\r\n    RuntimeAccessibleClass.extendMatrix =\r\n        new SimpleTree<(typeof RuntimeAccessibleClass)>(roots, \"subclasses\")\r\n            .getiIsSubElementMatrix(\"cname\");\r\n    /*\r\n    let tree = new TreeModel({\r\n        childrenPropertyName: \"subclasses\"\r\n    });\r\n    for (let key in dict){\r\n        let constructor = dict[key];\r\n        if(!constructor.hasOwnProperty(\"subclasses\")) constructor.subclasses = [];\r\n    }\r\n    RuntimeAccessibleClass.extendTree = (tree as any).safe_parse(RuntimeAccessibleClass);*/\r\n}\r\n// windoww.TreeModel = TreeModel;\r\nfunction buildLSingletons(alld: Dictionary<string, typeof DPointerTargetable>, alll: Dictionary<string, typeof LPointerTargetable>) {\r\n    for (let dname in alld) {\r\n        switch (dname) {\r\n            case \"DeleteElementAction\": continue;\r\n            case \"DV\": continue;\r\n            case \"Debug\": continue;\r\n            default: break;\r\n        }\r\n        if ((dname[1] || \"\").toLowerCase() === dname[1]) continue; // if second letter is lowercase, it's not a \"D\" class\r\n        let tagless = dname.substring(1);\r\n        let d = alld[dname];\r\n        let l = alll['L'+tagless];\r\n        if (!d||!l) console.error(\"missing d constructor\", {d, l});\r\n        d.logic = l;\r\n        if (!l) console.error('init() could not find L-class during mapping', l, d);\r\n        // @ts-ignore\r\n        d.singleton = new l('dwc');\r\n        d.structure = d;\r\n\r\n        l.logic = d.logic;\r\n        l.singleton = d.singleton;\r\n        l.structure = d.structure;\r\n\r\n        // if (!d.subclasses) d.subclasses = [];\r\n        // @ts-ignore\r\n        // for (let sc of d.subclasses) { if (!sc[\"_extends\"]) sc[\"_extends\"] = [];  sc[\"_extends\"].push(d); }\r\n    }\r\n}\r\nfunction setDocumentEvents(){\r\n    // do not use typings or class constructors here or it will change import order\r\n    setTimeout(\r\n        ()=> $(document).on(\"mouseup\",\r\n            (e: MouseUpEvent) => {\r\n                statehistory.globalcanundostate = true;\r\n                RuntimeAccessibleClass.get<typeof GraphDragManager>(\"GraphDragManager\").stopPanning(e);\r\n            })\r\n        , 1);\r\n    // document.body.addEventListener(\"mousedown\", fixResizables, false);\r\n}\r\nfunction fixResizables(e: MouseEvent){\r\n    /*let parents = U.ancestorArray(e.target as HTMLElement);\r\n    for (let e of parents){\r\n        if (e.classList.contains(\"draggable\")) U.makeDraggable(e, e.dataset.draggableOptions, e.attributes.disabled);\r\n        if (e.classList.contains(\"resizable\")) U.makeResizable(e, e.dataset.draggableOptions);\r\n        if (e.classList.contains(\"resizable\")) U.makeRotatable(e, e.dataset.draggableOptions);\r\n    }*/\r\n}\r\n\r\nexport async function stateInitializer() {\r\n    RuntimeAccessibleClass.fixStatics();\r\n    let dClassesMap: Dictionary<string, typeof DPointerTargetable> = {};\r\n    let lClassesMap: Dictionary<string, typeof LPointerTargetable> = {};\r\n    for (let name in RuntimeAccessibleClass.classes) {\r\n        switch(name[0]) {\r\n            case 'D': dClassesMap[name] = RuntimeAccessibleClass.classes[name] as typeof DPointerTargetable; break;\r\n            case 'L': lClassesMap[name] = RuntimeAccessibleClass.classes[name] as typeof LPointerTargetable; break;\r\n            default: break;\r\n        }\r\n    }\r\n\r\n    buildLSingletons(dClassesMap, lClassesMap);\r\n    setSubclasses(RuntimeAccessibleClass.get('DPointerTargetable'));\r\n    windoww.defaultContext = {$: windoww.$, getPath, React: React, Selectors, ...RuntimeAccessibleClass.getAllClassesDictionary(), ...windoww.Components};\r\n\r\n    setDocumentEvents();\r\n\r\n    DState.init();\r\n    const user = Storage.read<DUser>('user');\r\n    if(user) {\r\n        DUser.new(user.name, user.surname, user.nickname, user.affiliation, user.country, user.newsletter, user.email, user.token, user.id);\r\n        DUser.current = user.id;\r\n        statehistory[user.id] = {redoable: [], undoable: []};\r\n        await ProjectsApi.getAll();\r\n    } else DUser.current = '';\r\n\r\n}\r\n"],"mappings":"AAAA,SAMIA,YAAY,EAGZC,EAAE,EAGFC,qBAAqB,EACrBC,eAAe,QAKZ,cAAc;AACrB,SACIC,MAAM,EACNC,eAAe,EACfC,mBAAmB,EACnBC,mBAAmB,EAGnBC,kBAAkB,EAClBC,MAAM,EACNC,KAAK,EACLC,OAAO,EAEPC,GAAG,EAEHC,OAAO,EAEPC,qBAAqB,EACrBC,SAAS,EAETC,QAAQ,EACRC,sBAAsB,EACtBC,cAAc,EACdC,kBAAkB,EAClBC,YAAY,QACT,cAAc;AACrB,OAAOC,KAAK,MAAM,OAAO;AACzB,SAAQC,UAAU,EAAEC,UAAU,EAAEC,UAAU,QAAO,kBAAkB;AACnE,OAAOC,aAAa,MAAM,8CAA8C;AACxE,SAAQC,UAAU,QAAO,yBAAyB;AAClD,SAAQC,mBAAmB,EAAEC,SAAS,QAAO,cAAc;AAE3D,SAASC,gBAAgB,QAAQ,kDAAkD;AACnF,OAAOC,OAAO,MAAM,oBAAoB;AACxC,SAAQC,WAAW,QAAO,uBAAuB;AACjD,OAAOC,GAAG,MAAM,eAAe;AAE/B,IAAIC,OAAO,GAAGC,MAAa;AAC3B,IAAIC,CAAe,GAAGF,OAAO,CAACE,CAAC;AAG/B,SAASC,4BAA4BA,CAACC,mBAA2B,EAAEC,MAAoB,EAAEC,UAAwB,EAAEC,MAAW,EAAiB;EAAA,IAAAC,YAAA;EAC3I,IAAIC,OAAe,GAAG;IAAC,GAAGL;EAAmB,CAAW;EACxD,IAAIM,OAAY,GAAGD,OAAO;EAC1B,IAAI,GAAAD,YAAA,GAACH,MAAM,CAACM,IAAI,cAAAH,YAAA,uBAAXA,YAAA,CAAaI,MAAM,GAAE,MAAM,IAAIhC,OAAO,CAAC,gCAAgC,EAAE;IAACyB;EAAM,CAAC,CAAC;EACvF,IAAIQ,UAAmB,GAAG,KAAK,CAAC,CAAC;EACjC,IAAIC,0BAA0B,GAAG,KAAK,CAAC,CAAC;EACxC;EACA,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGV,MAAM,CAACW,SAAS,CAACJ,MAAM,EAAEG,CAAC,EAAE,EAAE;IAC9C,IAAIE,GAAG,GAAGZ,MAAM,CAACW,SAAS,CAACD,CAAC,CAAC,CAACG,IAAI,CAAC,CAAC;IACpC,IAAIC,iBAAiB,GAAGb,UAAU,aAAVA,UAAU,uBAAVA,UAAU,CAAEU,SAAS,CAACD,CAAC,CAAC;IAChD;IACA;IACA,IAAIA,CAAC,KAAKV,MAAM,CAACW,SAAS,CAACJ,MAAM,GAAG,CAAC,EAAE;MACnC,IAAIE,0BAA0B,IAAIG,GAAG,KAAKE,iBAAiB,EAAE;QACzD;QACAL,0BAA0B,GAAG,IAAI;QACjCJ,OAAO,CAACO,GAAG,CAAC,GAAGG,KAAK,CAACC,OAAO,CAACX,OAAO,CAACO,GAAG,CAAC,CAAC,GAAG,CAAC,GAAGP,OAAO,CAACO,GAAG,CAAC,CAAC,GAAG;UAAC,GAAGP,OAAO,CAACO,GAAG;QAAC,CAAC;QAClFP,OAAO,CAACO,GAAG,CAAC,CAACK,aAAa,GAAG,CAAC,IAAIZ,OAAO,CAACO,GAAG,CAAC,CAACK,aAAa,IAAI,CAAC,CAAC;MACtE;MACAZ,OAAO,GAAGA,OAAO,CAACO,GAAG,CAAC;MACtB;IACJ;IACA;IACA;IACA;IACA,IAAIF,CAAC,IAAIV,MAAM,CAACW,SAAS,CAACJ,MAAM,GAAG,CAAC,EAAE;MAClC,IAAIW,aAAa,GAAG,KAAK;MACzB,IAAIC,aAAa,GAAG,KAAK;MACzB,IAAIC,aAAa,GAAG,KAAK;MACzB,IAAIC,kBAAkB,GAAG,KAAK;MAC9B;MACA;;MAEA,IAAIC,QAAa;MACjB,IAAIzB,CAAC,CAAC0B,QAAQ,CAACX,GAAG,EAAE,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC,EAAE;QAC/BA,GAAG,GAAGA,GAAG,CAACY,MAAM,CAAC,CAAC,EAAEZ,GAAG,CAACL,MAAM,GAAG,CAAC,CAAC,CAACM,IAAI,CAAC,CAAC;QAC1CS,QAAQ,GAAGjB,OAAO,CAACO,GAAG,CAAC;QACvB,QAAQ,OAAOU,QAAQ;UACnB,KAAK,QAAQ;YACb,IAAIP,KAAK,CAACC,OAAO,CAACM,QAAQ,CAAC,EAAEJ,aAAa,GAAG,IAAI,CAAC,KAC7CE,aAAa,GAAG,IAAI;YACzB;UACA;YAASlB,MAAM,IAAIoB,QAAQ;YAAE;QACjC;MACJ;MACA,IAAIzB,CAAC,CAAC0B,QAAQ,CAACX,GAAG,EAAE,CAAC,IAAI,CAAC,CAAC,EAAE;QACzBA,GAAG,GAAGA,GAAG,CAACY,MAAM,CAAC,CAAC,EAAEZ,GAAG,CAACL,MAAM,GAAG,CAAC,CAAC,CAACM,IAAI,CAAC,CAAC;QAC1CS,QAAQ,GAAGjB,OAAO,CAACO,GAAG,CAAC;QACvB,QAAQ,OAAOU,QAAQ;UACnB,KAAK,QAAQ;YACT,IAAIP,KAAK,CAACC,OAAO,CAACM,QAAQ,CAAC,EAAEH,aAAa,GAAG,IAAI,CAAC,KAC7CE,kBAAkB,GAAG,IAAI;YAC9B;UACJ,KAAK,QAAQ;YACTnB,MAAM,GAAGL,CAAC,CAAC4B,UAAU,CAACH,QAAQ,EAAEpB,MAAM,EAAE,EAAE,CAAC;YAC3C;UACJ,KAAK,QAAQ;YAAEA,MAAM,GAAGoB,QAAQ,GAAGpB,MAAM;YAAE;UAC3C;YAASiB,aAAa,GAAG,IAAI;YAAE;QACnC;QACA;MACJ;;MAEA;MACA;MACA,IAAInB,MAAM,CAAC0B,IAAI,KAAK1D,mBAAmB,CAAC0D,IAAI,IAAIrB,OAAO,CAACO,GAAG,CAAC,EAAE;QAC1DU,QAAQ,GAAGjB,OAAO,CAACO,GAAG,CAAC;QACvBJ,UAAU,GAAG,KAAK;QAClBlC,GAAG,CAACqD,EAAE,CAAC,mDAAmD,EAAE;UAAC3B,MAAM;UAC/D4B,gBAAgB,EAAEvB,OAAO,CAACO,GAAG,CAAC;UAAEiB,cAAc,EAAExB,OAAO,CAACO,GAAG,CAAC,KAAKZ,MAAM,CAAC8B;QAAM,CAAC,CAAC;QACpF,OAAO,KAAK,CAAC,CAAC;MAClB;MACA,IAAIV,aAAa,EAAE;QACf,IAAI,OAAOlB,MAAM,KAAK,QAAQ,EAAE;UAAE,IAAI6B,GAAQ,GAAG,CAAC,CAAC;UAAEA,GAAG,CAAC7B,MAAM,CAAC,GAAG,IAAI;UAAEA,MAAM,GAAG6B,GAAG;QAAE;QACvFT,QAAQ,GAAG;UAAC,GAAGjB,OAAO,CAACO,GAAG;QAAC,CAAC;QAC5BP,OAAO,CAACO,GAAG,CAAC,GAAG;UAAC,GAAGP,OAAO,CAACO,GAAG;QAAC,CAAC;QAChC,KAAK,IAAIoB,MAAM,IAAI9B,MAAM,EAAE;UACvB;UACA,IAAIG,OAAO,CAACO,GAAG,CAAC,CAACoB,MAAM,CAAC,KAAK9B,MAAM,CAAC8B,MAAM,CAAC,EAAE;UAC7C3B,OAAO,CAACO,GAAG,CAAC,CAACoB,MAAM,CAAC,GAAG9B,MAAM,CAAC8B,MAAM,CAAC;UACrCxB,UAAU,GAAG,IAAI;UACjB,IAAIR,MAAM,CAACiC,SAAS,EAAE;YAAE7B,OAAO,GAAG3B,SAAS,CAACyD,GAAG,CAACtB,GAAG,EAAaZ,MAAM,EAAEI,OAAO,EAAE,IAAI,CAAC;UAAE;QAC5F;MACJ,CAAC,MACD,IAAIiB,kBAAkB,EAAE;QACpB,IAAI,OAAOnB,MAAM,KAAK,QAAQ,EAAE;UAAE,IAAI6B,GAAQ,GAAG,CAAC,CAAC;UAAEA,GAAG,CAAC7B,MAAM,CAAC,GAAG,IAAI;UAAEA,MAAM,GAAG6B,GAAG;QAAE;QACvFT,QAAQ,GAAG;UAAC,GAAGjB,OAAO,CAACO,GAAG;QAAC,CAAC;QAC5BP,OAAO,CAACO,GAAG,CAAC,GAAG;UAAC,GAAGP,OAAO,CAACO,GAAG;QAAC,CAAC;QAChC,KAAK,IAAIoB,MAAM,IAAI9B,MAAM,EAAE;UACvB,IAAI,EAAE8B,MAAM,IAAI3B,OAAO,CAACO,GAAG,CAAC,CAAC,EAAE;UAC/B,OAAOP,OAAO,CAACO,GAAG,CAAC,CAACoB,MAAM,CAAC;UAC3BxB,UAAU,GAAG,IAAI;UACjB,IAAIR,MAAM,CAACiC,SAAS,EAAE;YAAE7B,OAAO,GAAG3B,SAAS,CAACyD,GAAG,CAACtB,GAAG,EAAaZ,MAAM,EAAEI,OAAO,EAAE,IAAI,CAAC;UAAE;QAC5F;MACJ,CAAC,MACD,IAAIc,aAAa,EAAE;QACfV,UAAU,GAAG,IAAI;QACjB,IAAI,CAACO,KAAK,CAACC,OAAO,CAACX,OAAO,CAACO,GAAG,CAAC,CAAC,EAAE;UAAEP,OAAO,CAACO,GAAG,CAAC,GAAG,EAAE;QAAE;QACvDU,QAAQ,GAAG,CAAC,GAAGjB,OAAO,CAACO,GAAG,CAAC,CAAC;QAC5BP,OAAO,CAACO,GAAG,CAAC,GAAG,CAAC,GAAGP,OAAO,CAACO,GAAG,CAAC,CAAC;QAChCP,OAAO,CAACO,GAAG,CAAC,CAACuB,IAAI,CAACjC,MAAM,CAAC;QACzB;QACA,IAAIF,MAAM,CAACiC,SAAS,EAAE;UAAE7B,OAAO,GAAG3B,SAAS,CAACyD,GAAG,CAAChC,MAAM,EAAaF,MAAM,EAAEI,OAAO,EAAE,IAAI,CAAC;QAAE;MAC/F,CAAC,MACD,IAAIe,aAAa,EAAE;QACf,IAAI,CAACJ,KAAK,CAACC,OAAO,CAACX,OAAO,CAACO,GAAG,CAAC,CAAC,EAAE;UAAEP,OAAO,CAACO,GAAG,CAAC,GAAG,EAAE;QAAE;QACvDU,QAAQ,GAAG,CAAC,GAAGjB,OAAO,CAACO,GAAG,CAAC,CAAC;QAC5B,IAAIwB,KAAa;QACjB,IAAIvC,CAAC,CAACwC,QAAQ,CAACnC,MAAM,CAAC,EAAE;UAAE;UACtBkC,KAAK,GAAGlC,MAAM;UACd,IAAIkC,KAAK,GAAG,CAAC,EAAEA,KAAK,GAAGd,QAAQ,CAACf,MAAM,GAAG6B,KAAK,CAAC,CAAC;QACpD,CAAC,MACD,IAAIlC,MAAM,KAAKoC,SAAS,EAAE;UACtBF,KAAK,GAAGd,QAAQ,CAACf,MAAM,GAAG,CAAC;QAC/B,CAAC,MACI;UACD6B,KAAK,GAAGd,QAAQ,CAACiB,OAAO,CAACrC,MAAM,CAAC;QACpC;QACA;QACAM,UAAU,GAAG4B,KAAK,IAAI,CAAC,IAAIA,KAAK,GAAG/B,OAAO,CAACO,GAAG,CAAC,CAACL,MAAM;QACtD,IAAIC,UAAU,EAAE;UACZH,OAAO,CAACO,GAAG,CAAC,GAAG,CAAC,GAAGP,OAAO,CAACO,GAAG,CAAC,CAAC;UAChC,IAAI4B,UAAU,GAAGnC,OAAO,CAACO,GAAG,CAAC,CAAC6B,MAAM,CAACL,KAAK,EAAE,CAAC,CAAC,CAAC,CAAC;UAChD,IAAIpC,MAAM,CAACiC,SAAS,EAAE;YAAE7B,OAAO,GAAG3B,SAAS,CAACiE,MAAM,CAACF,UAAU,EAAaxC,MAAM,EAAEI,OAAO,EAAE,IAAI,CAAC;UAAE;UAClG;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;QAGgB;MACJ,CAAC,MACD,IAAKJ,MAAM,CAAC0B,IAAI,KAAKzD,mBAAmB,CAACyD,IAAI,IAAI,EAAEd,GAAG,IAAIP,OAAO,CAAC,IAAKA,OAAO,CAACO,GAAG,CAAC,KAAKV,MAAM,EAAE;QAC5F;QACAM,UAAU,GAAG,KAAK;MACtB,CAAC,MAAM;QACH;QACA;QACA;QACAc,QAAQ,GAAGjB,OAAO,CAACO,GAAG,CAAC;QACvBJ,UAAU,GAAG,IAAI;QACjB;QACA;QACA;QACA;QACA,IAAKN,MAAM,KAAKoC,SAAS,IAAK,KAAK,IAAItC,MAAM,CAAC0B,IAAI,KAAKzD,mBAAmB,CAACyD,IAAI,EAAE,OAAOrB,OAAO,CAACO,GAAG,CAAC,CAAC,KAChGP,OAAO,CAACO,GAAG,CAAC,GAAGV,MAAM;;QAE1B;QACA;QACA;QACA;QACA;QACA,IAAI,IAAI,IAAIF,MAAM,CAACiC,SAAS,EAAE;UAC1B,IAAIU,sBAAiC;UACrC,IAAIC,sBAAiC;UACrC,IAAI7B,KAAK,CAACC,OAAO,CAACd,MAAM,CAAC,EAAE;YACvB0C,sBAAsB,GAAG1C,MAAM;YAC/B,IAAIa,KAAK,CAACC,OAAO,CAACM,QAAQ,CAAC,EAAE;cAAE;cAC3BqB,sBAAsB,GAAGrB,QAAQ;YACrC,CAAC,MACI;cAAE;cACHqB,sBAAsB,GAAG,CAACrB,QAAQ,CAAC;YACvC;UACJ,CAAC,MACI;YACD;YACAsB,sBAAsB,GAAG,CAAC1C,MAAM,CAAC;YACjC,IAAIa,KAAK,CAACC,OAAO,CAACM,QAAQ,CAAC,EAAE;cACzBqB,sBAAsB,GAAGrB,QAAQ;YACrC,CAAC,MAAM;cACH;cACAqB,sBAAsB,GAAG,CAACrB,QAAQ,CAAC;YACvC;UACJ;UACA;UACA,IAAIuB,UAAU,GAAGhD,CAAC,CAACiD,eAAe,CAACH,sBAAsB,EAAEC,sBAAsB,CAAC,CAAC,CAAC;UACpF,KAAK,IAAIG,GAAG,IAAIF,UAAU,CAACG,OAAO,EAAE;YAAC,IAAItE,QAAQ,CAACuD,SAAS,CAACc,GAAG,CAAC,EAC5D3C,OAAO,GAAG3B,SAAS,CAACiE,MAAM,CAACK,GAAG,EAAE/C,MAAM,EAAEI,OAAO,EAAEkC,SAAS,EAAEvC,mBAAmB,CAAC;UAAE;UACtF,KAAK,IAAImC,GAAG,IAAIW,UAAU,CAACI,KAAK,EAAE;YAAE,IAAIvE,QAAQ,CAACuD,SAAS,CAACC,GAAG,CAAC,EAC3D9B,OAAO,GAAG3B,SAAS,CAACyD,GAAG,CAACA,GAAG,EAAElC,MAAM,EAAEI,OAAO,EAAEkC,SAAS,EAAEvC,mBAAmB,CAAC;UAAE;UACnF;UACA;QACJ;MACJ;MACA;IACJ;IACAzB,GAAG,CAAC4E,MAAM,CAAC,gCAAgC,CAAC;EAChD;EACA,OAAO1C,UAAU,GAAGJ,OAAO,GAAGL,mBAAmB;AACrD;;AAGA;AACA,SAASoD,sBAAsBA,CAACC,QAAgB,EAAEC,WAA4B,EAAU;EACpF;EACA;EACA,IAAIC,OAAuB;EAC3B,IAAID,WAAW,CAACC,OAAO,EAAEA,OAAO,GAAGxF,MAAM,CAACyF,KAAK,CAACF,WAAW,CAACC,OAAO,CAAC,CAAC,KAChEA,OAAO,GAAG,CAACxF,MAAM,CAACyF,KAAK,CAACF,WAAW,CAAC,CAAC,CAAC,CAAC;EAC5C,IAAI7E,qBAAqB,CAACgF,GAAG,CAACjD,MAAM,EAAE+C,OAAO,CAACnB,IAAI,CAAC,GAAG3D,qBAAqB,CAACiF,mBAAmB,CAACL,QAAQ,CAAC,CAAC,CAAC,CAAC;;EAE5GtF,MAAM,CAAC4F,uBAAuB,GAAG,CAAC,CAAC;;EAEnC;EACA,IAAIC,cAA8B,GAAG,EAAE;EACvC,IAAIC,QAAQ,GAAGR,QAAQ;EACvB,KAAK,IAAIpD,MAAM,IAAIsD,OAAO,EAAE;IACxB,QAAQtD,MAAM,CAAC0B,IAAI;MACf;QAAS;MACT,KAAK1D,mBAAmB,CAAC0D,IAAI;QACzB,MAAMmC,IAAwB,GAAG7D,MAAM,CAAC8B,KAAK;QAC7C,OAAO5D,kBAAkB,CAAC4F,eAAe,CAACD,IAAI,CAACE,EAAE,CAAC;QAClD;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;QAGgBF,IAAI,CAACG,SAAS,GAAGH,IAAI,CAACG,SAAS,IAAKH,IAAI,CAACI,WAAW,CAAmCC,KAAK,IAAIL,IAAI,CAACI,WAAW,CAACE,IAAI;QACrH,IAAIC,eAAe,GAAGP,IAAI,CAACG,SAAS,CAACK,SAAS,CAAC,CAAC,CAAC,CAACC,WAAW,CAAC,CAAC,GAAG,GAAG;QACrEX,cAAc,CAACxB,IAAI,CACfrE,MAAM,CAACyF,KAAK,CAAC1E,kBAAkB,CAAC0F,MAAM,CAACH,eAAe,EAAEP,IAAI,CAACE,EAAE,EAAC,IAAI,EAAE,IAAI,CAAC,CAAC,CAAC;QACjF,IAAI,CAAChD,KAAK,CAACC,OAAO,CAAC6C,IAAI,CAACW,SAAS,CAAC,EAAEX,IAAI,CAACW,SAAS,GAAG,EAAE;QACvDX,IAAI,CAACW,SAAS,CAACrC,IAAI,CAAC1D,SAAS,CAACgG,GAAG,CAACL,eAAe,CAAC,CAAC;QACnD;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;QACgB;IACR;EACJ;EACA;EACAd,OAAO,GAAGzD,CAAC,CAAC6E,iBAAiB,CAAepB,OAAO,EAAEK,cAAc,CAAC;;EAEpE;EACAL,OAAO,GAAGA,OAAO,CAACqB,IAAI,CAAE,CAACC,EAAE,EAAEC,EAAE,KAAKhF,CAAC,CAACiF,aAAa,CAACF,EAAE,CAACtE,IAAI,EAAEuE,EAAE,CAACvE,IAAI,CAAC,CAAC;;EAEtE;;EAEA,KAAK,IAAII,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG4C,OAAO,CAAC/C,MAAM,EAAEG,CAAC,EAAE,EAAE;IACrC,MAAMT,UAAwB,GAAGqD,OAAO,CAAC5C,CAAC,GAAC,CAAC,CAAC;IAC7C,MAAMV,MAAoB,GAAGsD,OAAO,CAAC5C,CAAC,CAAC;IACvC,MAAMqE,UAAU,GAAG/E,MAAM,CAAC0B,IAAI,CAACa,OAAO,CAAC,IAAI,CAAC,KAAK,CAAC,GAAG,OAAO,GAAGvC,MAAM,CAAC0B,IAAI;IAC1EsD,OAAO,CAACC,GAAG,CAAC,mBAAmB,EAAE;MAACC,CAAC,EAAClF,MAAM;MAAEmF,CAAC,EAACJ,UAAU;MAAEK,KAAK,EAAEpF,MAAM,CAACoF,KAAK;MAAEC,CAAC,EAACrF,MAAM,CAAC8B;IAAK,CAAC,CAAC,CAAC,CAAC;;IAEjG,QAAQiD,UAAU;MACd;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;MACY;QACI,IAAI/E,MAAM,CAAC0B,IAAI,CAACa,OAAO,CAAC,UAAU,CAAC,KAAK,CAAC,EAAE;QAC3C,OAAOjE,GAAG,CAAC4E,MAAM,CAAC,yBAAyB,EAAElD,MAAM,CAAC0B,IAAI,CAAC;MAC7D,KAAK1C,UAAU,CAAC0C,IAAI;QAAEkC,QAAQ,GAAG5D,MAAM,CAAC8B,KAAK;QAAE;MAC/C,KAAK9D,mBAAmB,CAAC0D,IAAI;MAC7B,KAAK7C,kBAAkB,CAAC6C,IAAI;MAC5B,KAAKzD,mBAAmB,CAACyD,IAAI;MAC7B,KAAK9C,cAAc,CAAC8C,IAAI;QACpB,IAAIK,GAAmB,GAAGjC,4BAA4B,CAAC8D,QAAQ,EAAE5D,MAAM,EAAEC,UAAU,EAAED,MAAM,CAAC8B,KAAK,CAAC;QAClG,IAAI,CAACC,GAAG,EAAE,OAAOqB,QAAQ,CAAC,CAAC;QAC3BQ,QAAQ,GAAG7B,GAAG;QACd;IACR;;IAEA;EACJ;;EAEA;EACA6B,QAAQ,GAAG0B,2BAA2B,CAAC1B,QAAQ,EAAER,QAAQ,EAAEtF,MAAM,CAAC4F,uBAAuB,CAAC;EAC1F,OAAOE,QAAQ;AACnB;AAAC2B,EAAA,GAvGQpC,sBAAsB;AAyG/B,SAASmC,2BAA2BA,CAACE,KAAa,EAAEpC,QAAe,EAAEM,uBAA2F,EAAU;EACtK,KAAK,IAAI+B,OAAO,IAAI/B,uBAAuB,EAC3C,QAAQ+B,OAAO;IACX;MAAS;IACT,KAAK3H,MAAM,CAAC4H,OAAO,CAACC,iBAAiB,CAAC;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI;EACA;EACA,OAAOH,KAAK;AAChB;AAEA,IAAII,YAAoB,GAAG,IAAW;AACtC,IAAIC,WAAoB,GAAG,KAAK;AAEhC,MAAMC,QAAQ,GAAG,iEAAiE;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA;;AAEA,OAAO,SAASC,OAAOA,CAAA,EAA0D;EAAA,IAAzD3C,QAAgB,GAAA4C,SAAA,CAAAzF,MAAA,QAAAyF,SAAA,QAAA1D,SAAA,GAAA0D,SAAA,MAAGJ,YAAY;EAAA,IAAE5F,MAAc,GAAAgG,SAAA,CAAAzF,MAAA,OAAAyF,SAAA,MAAA1D,SAAA;EACnE,IAAG;IAAE,OAAO2D,aAAa,CAAC7C,QAAQ,EAAEpD,MAAM,CAAC;EAAE,CAAC,CAC9C,OAAMkG,CAAC,EAAE;IACLlB,OAAO,CAACmB,KAAK,CAAC,4BAA4B,EAAE;MAACD,CAAC;MAAE9C,QAAQ;MAAEpD;IAAM,CAAC,CAAC;IAClE,OAAOoD,QAAQ;EACnB;AACJ;AAEA,SAAS6C,aAAaA,CAAA,EAA0D;EAAA,IAAAG,qBAAA,EAAAC,sBAAA,EAAAC,sBAAA,EAAAC,sBAAA,EAAAC,sBAAA;EAAA,IAAzDpD,QAAgB,GAAA4C,SAAA,CAAAzF,MAAA,QAAAyF,SAAA,QAAA1D,SAAA,GAAA0D,SAAA,MAAGJ,YAAY;EAAA,IAAE5F,MAAc,GAAAgG,SAAA,CAAAzF,MAAA,OAAAyF,SAAA,MAAA1D,SAAA;EAClE,MAAMmE,GAAG,GAAGC,QAAQ,CAACtD,QAAQ,EAAEpD,MAAM,CAAC;EACtC,IAAIyG,GAAG,KAAKrD,QAAQ,EAAE,OAAOA,QAAQ;EACrC;EACA;EACA,IAAIA,QAAQ,aAARA,QAAQ,uBAARA,QAAQ,CAAEuD,oBAAoB,EAAE;IAChC,MAAMC,aAA+B,GAAI,CACrC,SAAS,EACT,KAAK,EACL,OAAO,EACP,eAAe,EACf,aAAa,EACb,eAAe,EACf,WAAW,EACX,sBAAsB,EACtB,8BAA8B,EAC9B,6BAA6B,EAC7B,2BAA2B,EAC3B,+BAA+B,EAC/B,+BAA+B,EAC/B,6BAA6B,EAC7B,+BAA+B,EAC/B,iCAAiC,EACjC,+BAA+B,EAC/B,+BAA+B,EAC/B,2BAA2B,EAC3B,mCAAmC,EACnC,2BAA2B,EAC3B,+BAA+B,EAC/B,6BAA6B,EAC7B,qBAAqB,EACrB,wBAAwB,EACxB,qBAAqB,EACrB,kBAAkB,EAClB,SAAS,EACT,UAAU,EACV,OAAO,CACV;IACD;IACA,IAAIC,eAAqC,GAAG,IAAI;IAChD,IAAG7G,MAAM,CAAC0B,IAAI,KAAK3D,eAAe,CAAC2D,IAAI,EAAE;MACrCmF,eAAe,GAAG7G,MAAyB;MAC3C,MAAM8G,UAAU,GAAGD,eAAe,CAACvD,OAAO,IAAI,EAAE;MAChDuD,eAAe,CAACvD,OAAO,GAAGwD,UAAU,CAACC,MAAM,CAAC7B,CAAC,IAAI,CAAC0B,aAAa,CAACI,QAAQ,CAAC9B,CAAC,CAACE,KAAqB,CAAC,CAAC;IACtG;IACA,IAAGyB,eAAe,IAAI,CAACA,eAAe,CAACvD,OAAO,CAAC/C,MAAM,EAAE,OAAOkG,GAAG;IACjEzG,MAAM,GAAI6G,eAAe,GAAIA,eAAe,GAAG7G,MAAM;IACrD,IAAGA,MAAM,CAACiH,MAAM,KAAK7I,KAAK,CAACiC,OAAO,IAAI,CAACuG,aAAa,CAACI,QAAQ,CAAChH,MAAM,CAACoF,KAAqB,CAAC,EAAE;MACzF,MAAM8B,YAA4B,GAAGC,IAAI,CAAC5D,KAAK,CAAC4D,IAAI,CAACC,SAAS,CAACpH,MAAM,CAAC,CAAC;MACvEb,aAAa,CAACkI,MAAM,CAACC,IAAI,CAAC,YAAY,EAAEJ,YAAY,CAAC;IACzD;EACJ;EAEA,KAAK,IAAIK,GAAG,IAAId,GAAG,CAACe,eAAe,EAAC;IAChC,IAAIC,CAAC,GAAGhB,GAAG,CAACiB,QAAQ,CAACH,GAAG,CAAC;IACzB,IAAI,CAACE,CAAC,EAAE,SAAS,CAAC;IAClB,QAAOA,CAAC,CAACzD,SAAS;MACd;QAAS;MACT,KAAK,cAAc;QACf,KAAI,IAAI2D,GAAG,IAAItI,mBAAmB,CAACuI,IAAI,EAAC;UACpC,IAAIC,EAAE,GAAGxI,mBAAmB,CAACuI,IAAI,CAACD,GAAG,CAAC;UACtCE,EAAE,CAACC,UAAU,CAACL,CAAC,CAAC1D,EAAE,CAAQ,GAAG,CAAC,CAAQ;QAC1C;IACR;EACJ;EACA0C,GAAG,CAACe,eAAe,GAAG,EAAE;EACxB,KAAK,IAAID,GAAG,IAAId,GAAG,CAACsB,eAAe,EAAC;IAChC,IAAIN,CAAC,GAAGrE,QAAQ,CAACsE,QAAQ,CAACH,GAAG,CAAC;IAC9B,IAAI,CAACE,CAAC,EAAE,SAAS,CAAC;IAClB,QAAOA,CAAC,CAACzD,SAAS;MACd;QAAS;MACT,KAAK,cAAc;QACf,KAAK,IAAI2D,GAAG,IAAItI,mBAAmB,CAACuI,IAAI,EAAE;UACtC,IAAIC,EAAE,GAAGxI,mBAAmB,CAACuI,IAAI,CAACD,GAAG,CAAC;UACtC;UACA,OAAOE,EAAE,CAACC,UAAU,CAACL,CAAC,CAAC1D,EAAE,CAAQ;UACjC8D,EAAE,CAACG,WAAW,GAAG,IAAI;QACzB;IACR;EACJ;EACAvB,GAAG,CAACsB,eAAe,GAAG,EAAE;EAExB,IAAItB,GAAG,CAACwB,mBAAmB,KAAK,IAAI,EAAExB,GAAG,CAACwB,mBAAmB,GAAGC,MAAM,CAACC,IAAI,CAAC1B,GAAG,CAACiB,QAAQ,CAAC;EACzF,KAAAtB,qBAAA,GAAKK,GAAG,CAACwB,mBAAmB,cAAA7B,qBAAA,uBAAxBA,qBAAA,CAAwC7F,MAAM,EAAE;IAChD,IAAI6H,aAAsB,GAAG,KAAK;IAClC,IAAIC,EAAgB;IACpB,KAAK,IAAItE,EAAE,IAAI,IAAIuE,GAAG,CAAC7B,GAAG,CAACwB,mBAAgC,CAAC,EAAC;MACzD,IAAIR,CAAC,GAAGhB,GAAG,CAACiB,QAAQ,CAAC3D,EAAE,CAAC;MACxB,IAAI,CAAC0D,CAAC,EAAE;MACR,IAAI9I,sBAAsB,CAAC4J,OAAO,CAACd,CAAC,CAACzD,SAAS,EAAE,cAAc,CAAC,EAAE;QAC5DyD,CAAC,CAAkBe,kBAAkB,GAAG,IAAI;QAC7CnJ,mBAAmB,CAACoJ,IAAI,CAAChB,CAAC,CAAC1D,EAAE,CAAW,GAAG,CAAE,CAAQ;QACrD;QACA;QACA,KAAKsE,EAAE,IAAI5B,GAAG,EAAE,IAAI4B,EAAE,CAAC9F,OAAO,CAAC,iBAAiB,CAAC,KAAK,CAAC,EAAGkE,GAAG,CAAC4B,EAAE,CAAC,CAAelG,IAAI,CAAC4B,EAAE,CAAC;QACxF;QACA,IAAI,CAACqE,aAAa,EAAEA,aAAa,GAAG,IAAI;MAC5C;MACA,IAAIzJ,sBAAsB,CAAC4J,OAAO,CAACd,CAAC,CAACzD,SAAS,EAAE,eAAe,CAAC,EAAE;QAC9D,IAAIyD,CAAC,CAACzD,SAAS,KAAK,QAAQ,EAAE;UAAA,IAAA0E,qBAAA,EAAAC,kBAAA;UAC1B,IAAIC,OAAO,IAAAF,qBAAA,GAAItF,QAAQ,CAACsE,QAAQ,CAACD,CAAC,CAAC1D,EAAE,CAAC,cAAA2E,qBAAA,uBAAxBA,qBAAA,CAAqCvE,IAAI;UACvD,IAAI0E,OAAO,IAAAF,kBAAA,GAAIlC,GAAG,CAACiB,QAAQ,CAACD,CAAC,CAAC1D,EAAE,CAAC,cAAA4E,kBAAA,uBAAnBA,kBAAA,CAAgCxE,IAAI;UAClD,IAAIyE,OAAO,KAAKC,OAAO,EAAEpC,GAAG,CAACqC,gBAAgB,CAACrB,CAAC,CAAC1D,EAAE,CAAoB,GAAG6E,OAAO;QACpF;QACA,KAAKP,EAAE,IAAI5B,GAAG,EAAE,IAAI4B,EAAE,CAAC9F,OAAO,CAAC,kBAAkB,CAAC,KAAK,CAAC,EAAGkE,GAAG,CAAC4B,EAAE,CAAC,CAAelG,IAAI,CAAC4B,EAAE,CAAC;QACzF;MACJ;MACA,IAAIpF,sBAAsB,CAAC4J,OAAO,CAACd,CAAC,CAACzD,SAAS,EAAE,eAAe,CAAC,EAAE;QAC9D3E,mBAAmB,CAACuI,IAAI,CAACH,CAAC,CAAC1D,EAAE,CAAW,GAAG,CAAE,CAAQ;QACrD,KAAKsE,EAAE,IAAI5B,GAAG,EAAE,IAAI4B,EAAE,CAAC9F,OAAO,CAAC,iBAAiB,CAAC,KAAK,CAAC,EAAGkE,GAAG,CAAC4B,EAAE,CAAC,CAAelG,IAAI,CAAC4B,EAAE,CAAC;QACxF;MACJ;IACJ;IACA,IAAIqE,aAAa,EAAE,KAAK,IAAIT,GAAG,IAAItI,mBAAmB,CAACuI,IAAI,EAAE;MACzDvI,mBAAmB,CAACuI,IAAI,CAACD,GAAG,CAAC,GAAG,CAAC,CAAQ;MACzC,KAAKU,EAAE,IAAI5B,GAAG,EAAE,IAAI4B,EAAE,CAAC9F,OAAO,CAAC,iBAAiB,CAAC,KAAK,CAAC,EAAGkE,GAAG,CAAC4B,EAAE,CAAC,CAAelG,IAAI,CAACwF,GAAG,CAAC;MACzF;IACJ;EACJ;EACAlB,GAAG,CAACwB,mBAAmB,GAAG,EAAE;EAI5B,SAASc,UAAUA,CAACxB,GAAY,EAAE3G,GAA8B,EAAEoI,MAAe,EAAU;IAAA,IAAAC,SAAA;IACvF,IAAIC,EAAyC,GAAGhL,kBAAkB,CAACiL,WAAW,CAAC5B,GAAG,EAAEd,GAAG,CAAC;IACxF,IAAI2C,EAAqD,GAAG,CAAEJ,MAAM,GAAG3J,mBAAmB,CAACuI,IAAI,GAAGvI,mBAAmB,CAACoJ,IAAI,EAAclB,GAAG,CAAC;IAC5I,IAAI,CAAC6B,EAAE,EAAE,CAAEJ,MAAM,GAAG3J,mBAAmB,CAACuI,IAAI,GAAGvI,mBAAmB,CAACoJ,IAAI,EAAclB,GAAG,CAAC,GAAG6B,EAAE,GAAG,CAAC,CAAQ;IAC1G,IAAIC,GAAW,GAAGH,EAAE,CAACtI,GAAG,CAAC;IACzB,IAAI,CAACyI,GAAG,EAAE;MAAED,EAAE,CAACxI,GAAG,CAAC,GAAG0B,SAAgB;MAAE,OAAO,IAAI;IAAE;IACrD,IAAI,OAAO+G,GAAG,KAAK,UAAU,EAAE;MAAED,EAAE,CAACxI,GAAG,CAAC,GAAGyI,GAAG;MAAE,OAAO,IAAI;IAAE;IAC7D,IAAIC,cAAc,GAAG;MAAC,GAAG/J;IAAgB,CAAC;IAC1C,IAAIgK,GAA0B,GAAGP,MAAM,IAAAC,SAAA,GAAIG,EAAE,CAA6BI,QAAQ,cAAAP,SAAA,uBAAxCA,SAAA,CAA0ClF,EAAE,GAAGwD,GAAU;IACnG,IAAI,CAACgC,GAAG,EAAE,OAAO,KAAK,CAAC,CAAC;IACxB,IAAIE,EAAE,GAAGpK,mBAAmB,CAACoJ,IAAI,CAACc,GAAG,CAAC;IACtC,KAAK,IAAIG,CAAC,IAAID,EAAE,CAACE,aAAa,EAAE,IAAI,CAACL,cAAc,CAACI,CAAC,CAAC,EAAEJ,cAAc,CAACI,CAAC,CAAC,GAAG,IAAI;IAChF,KAAK,IAAIA,CAAC,IAAID,EAAE,CAACG,MAAM,EAAE,IAAI,CAACN,cAAc,CAACI,CAAC,CAAC,EAAEJ,cAAc,CAACI,CAAC,CAAC,GAAG,IAAI;IACzE,IAAIG,QAAQ,GAAG,GAAG,GAAC3B,MAAM,CAACC,IAAI,CAACmB,cAAc,CAAC,CAACQ,IAAI,CAAC,GAAG,CAAC,GAAC,GAAG;IAC5D9E,OAAO,CAACC,GAAG,CAAC,cAAc,EAAE;MAAEqE,cAAc;MAAES,EAAE,EAACN,EAAE,CAACG,MAAM;MAAEI,CAAC,EAACP,EAAE,CAACE;IAAc,CAAC,CAAC;IACjF,MAAMM,IAAY,GAAI,UAAU,GAAGZ,GAAG,GAAG,GAAG;IAC5C;IACArE,OAAO,CAACC,GAAG,CAAC,cAAc,EAAE;MAACsE,GAAG,EAAEhC,GAAG;MAAEsC,QAAQ;MAAEI;IAAI,CAAC,CAAC;IACvD,IAAI;MACA,IAAIjB,MAAM,EAAE;QACR;MAAA,CACH,MACI;QACD;MAAA;MAEJI,EAAE,CAACxI,GAAG,CAAC,GAAG,YAAU;QAAE,OAAO,gEAAgE;MAAE,CAAC;IACpG,CAAC,CACD,OAAOsF,CAAM,EAAE;MACX;AACZ;AACA;AACA;AACA;AACA;MACYlB,OAAO,CAACmB,KAAK,CAAC,oBAAoB,EAAE;QAACoD,GAAG,EAAEhC,GAAG;QAAErB,CAAC;QAAE2D,QAAQ;QAAEI;MAAI,CAAC,CAAC;MAClEb,EAAE,CAACxI,GAAG,CAAC,GAAGyI,GAAG,CAAC;IAClB;IACA,OAAO,IAAI;IACX;EACJ;EACA,IAAIa,GAAmB;EACvBA,GAAG,GAAGzD,GAAG,CAAC0D,sBAAsB;EAChC,IAAID,GAAG,CAAC3J,MAAM,EAAE;IACZ,IAAI6J,kBAA+C,GAAG,CAAC,CAAC;IACxD,KAAK,MAAMrG,EAAE,IAAI,IAAIuE,GAAG,CAAC4B,GAAG,CAAC,EAAEE,kBAAkB,CAACrG,EAAE,CAAC,GAAGgF,UAAU,CAAChF,EAAE,EAAE,QAAQ,EAAE,IAAI,CAAC;IACtF0C,GAAG,CAAC0D,sBAAsB,GAAGD,GAAG,CAACnD,MAAM,CAACb,CAAC,IAAI,CAACkE,kBAAkB,CAAClE,CAAC,CAAC,CAAC;EACxE;EACAgE,GAAG,GAAGzD,GAAG,CAAC4D,4BAA4B;EACtC,IAAIH,GAAG,CAAC3J,MAAM,EAAE;IACZ,IAAI6J,kBAA+C,GAAG,CAAC,CAAC;IACxD,KAAK,MAAMrG,EAAE,IAAI,IAAIuE,GAAG,CAAC4B,GAAG,CAAC,EAAEE,kBAAkB,CAACrG,EAAE,CAAC,GAAGgF,UAAU,CAAChF,EAAE,EAAE,cAAc,EAAE,IAAI,CAAC;IAC5F0C,GAAG,CAAC4D,4BAA4B,GAAGH,GAAG,CAACnD,MAAM,CAACb,CAAC,IAAI,CAACkE,kBAAkB,CAAClE,CAAC,CAAC,CAAC;EAC9E;EACAgE,GAAG,GAAGzD,GAAG,CAAC6D,sBAAsB;EAChC,IAAIJ,GAAG,CAAC3J,MAAM,EAAE;IACZ,IAAI6J,kBAA+C,GAAG,CAAC,CAAC;IACxD,KAAK,MAAMrG,EAAE,IAAI,IAAIuE,GAAG,CAAC4B,GAAG,CAAC,EAAEE,kBAAkB,CAACrG,EAAE,CAAC,GAAGgF,UAAU,CAAChF,EAAE,EAAE,QAAQ,EAAE,KAAK,CAAC;IACvF0C,GAAG,CAAC6D,sBAAsB,GAAGJ,GAAG,CAACnD,MAAM,CAACb,CAAC,IAAI,CAACkE,kBAAkB,CAAClE,CAAC,CAAC,CAAC;EACxE;EACAgE,GAAG,GAAGzD,GAAG,CAAC8D,4BAA4B;EACtC,IAAIL,GAAG,CAAC3J,MAAM,EAAE;IACZ,IAAI6J,kBAA+C,GAAG,CAAC,CAAC;IACxD,KAAK,MAAMrG,EAAE,IAAI,IAAIuE,GAAG,CAAC4B,GAAG,CAAC,EAAEE,kBAAkB,CAACrG,EAAE,CAAC,GAAGgF,UAAU,CAAChF,EAAE,EAAE,cAAc,EAAE,KAAK,CAAC;IAC7F0C,GAAG,CAAC8D,4BAA4B,GAAGL,GAAG,CAACnD,MAAM,CAACb,CAAC,IAAI,CAACkE,kBAAkB,CAAClE,CAAC,CAAC,CAAC;EAC9E;;EAEA;EACA,IAAIO,GAAG,CAAC+D,mBAAmB,CAACjK,MAAM,EAAE;IAChC;IACA;IACA,KAAK,IAAIgJ,GAAG,IAAI,IAAIjB,GAAG,CAAC7B,GAAG,CAAC+D,mBAAmB,CAAC,EAAE;MAC9C,IAAI,CAACnL,mBAAmB,CAACoJ,IAAI,CAACc,GAAG,CAAC,EAAElK,mBAAmB,CAACoJ,IAAI,CAACc,GAAG,CAAC,GAAG,CAAC,CAAQ;MAC7ElK,mBAAmB,CAACoJ,IAAI,CAACc,GAAG,CAAC,CAACkB,SAAS,GAAGnI,SAAgB,CAAC,CAAC;MAC5DjD,mBAAmB,CAACoJ,IAAI,CAACc,GAAG,CAAC,CAACmB,UAAU,GAAG,IAAI;MAC/C,KAAK,IAAI/C,GAAG,IAAItI,mBAAmB,CAACuI,IAAI,EAAE;QACtC,IAAI+C,GAAG,GAAGtL,mBAAmB,CAACuI,IAAI,CAACD,GAAG,CAAC,CAACG,UAAU,CAACyB,GAAG,CAAC;QACvD,IAAI,CAAAoB,GAAG,aAAHA,GAAG,uBAAHA,GAAG,CAAEC,QAAQ,MAAK/M,eAAe,CAACgN,iBAAiB,EAAEF,GAAG,CAACC,QAAQ,GAAG/M,eAAe,CAACgN,iBAAmC;MAC/H;IACJ;IACApE,GAAG,CAAC+D,mBAAmB,GAAG,EAAE;EAChC;EACA;AACJ;AACA;AACA;AACA;;EAEI,IAAI/D,GAAG,CAACqE,6BAA6B,CAACvK,MAAM,EAAE;IAC1C,KAAK,IAAIgJ,GAAG,IAAI,IAAIjB,GAAG,CAAC7B,GAAG,CAACqE,6BAA6B,CAAC,EAAE;MACxD,KAAK,IAAInD,GAAG,IAAItI,mBAAmB,CAACuI,IAAI,EAAE;QACtC,IAAI+C,GAAG,GAAGtL,mBAAmB,CAACuI,IAAI,CAACD,GAAG,CAAC,CAACG,UAAU,CAACyB,GAAG,CAAC;QACvD,IAAI,CAAAoB,GAAG,aAAHA,GAAG,uBAAHA,GAAG,CAAEI,cAAc,MAAKlN,eAAe,CAACgN,iBAAiB,EAAEF,GAAG,CAACI,cAAc,GAAGlN,eAAe,CAACgN,iBAAkC;MAC1I;IACJ;IACApE,GAAG,CAACqE,6BAA6B,GAAG,EAAE;EAC1C;EAEA,KAAAzE,sBAAA,GAAII,GAAG,CAACuE,yBAAyB,cAAA3E,sBAAA,uBAA7BA,sBAAA,CAA+B9F,MAAM,EACzC,KAAK,MAAMgJ,GAAG,IAAI,IAAIjB,GAAG,CAAC7B,GAAG,CAACuE,yBAAyB,CAAC,EAAE;IAAE;IACxD,IAAI9B,EAAgB,GAAGhL,kBAAkB,CAACiL,WAAW,CAACI,GAAG,EAAE9C,GAAG,CAAC;IAC/D;IACA;IACA,IAAI,CAACyC,EAAE,CAAC+B,SAAS,EAAE;MACf,IAAI,CAAC5L,mBAAmB,CAACoJ,IAAI,CAACc,GAAG,CAAC,EAAElK,mBAAmB,CAACoJ,IAAI,CAACc,GAAG,CAAC,GAAG,CAAC,CAAQ;MAC7ElK,mBAAmB,CAACoJ,IAAI,CAACc,GAAG,CAAC,CAAC0B,SAAS,GAAG,CAAC,CAAC;MAC5C5L,mBAAmB,CAACoJ,IAAI,CAACc,GAAG,CAAC,CAACI,aAAa,GAAG,EAAE;MAChD;MACA;IACJ;IACA,MAAMuB,eAAwB,GAAG,CAAC,CAAC;IACnC,MAAMC,OAAO,GAAG;MAAC1C,IAAI,EAACS;IAAE,CAAC,CAAC,CAAC;IAC3B,IAAIW,QAAQ,GAAG,GAAG,GAAC3B,MAAM,CAACC,IAAI,CAACgD,OAAO,CAAC,CAACrB,IAAI,CAAC,GAAG,CAAC,GAAC,QAAQ;IAC1D,IAAI;MACA;MACA,IAAIsB,iBAA2D,GAAG,IAAIC,QAAQ,CAACxB,QAAQ,EAAE,UAAU,GAACX,EAAE,CAAC+B,SAAS,GAAC,QAAQ,CAAC,CAACK,IAAI,CAACH,OAAO,CAAC;MACxIC,iBAAiB,CAACD,OAAO,EAAED,eAAe,CAAC;IAC/C,CAAC,CAAC,OAAMhF,CAAK,EAAC;MACVlB,OAAO,CAACmB,KAAK,CAAC,uBAAuB,EAAE;QAACoD,GAAG;QAAErD,CAAC;QAAE2D,QAAQ;QAAEI,IAAI,EAAC,UAAU,GAACf,EAAE,CAAC+B,SAAS,GAAC;MAAQ,CAAC,CAAC;MACjG;IACJ;IAEA5L,mBAAmB,CAACoJ,IAAI,CAACc,GAAG,CAAC,CAAC0B,SAAS,GAAGC,eAAe;IACzD7L,mBAAmB,CAACoJ,IAAI,CAACc,GAAG,CAAC,CAACI,aAAa,GAAGzB,MAAM,CAACC,IAAI,CAAC9I,mBAAmB,CAACoJ,IAAI,CAACc,GAAG,CAAC,CAAC0B,SAAS,CAAC;IAClG;IACAxE,GAAG,CAAC8E,2BAA2B,CAACpJ,IAAI,CAACoH,GAAG,CAAC;IACzC9C,GAAG,CAAC+E,iCAAiC,CAACrJ,IAAI,CAACoH,GAAG,CAAC;IAC/C9C,GAAG,CAACgF,yBAAyB,CAACtJ,IAAI,CAACoH,GAAG,CAAC;IACvC9C,GAAG,CAACiF,sBAAsB,CAACvJ,IAAI,CAACoH,GAAG,CAAC;IACpC,KAAK,IAAIG,CAAC,IAAIhM,YAAY,CAACiO,cAAc,EAAGlF,GAAG,CAAS,kBAAkB,GAACiD,CAAC,CAAC,CAACvH,IAAI,CAACoH,GAAG,CAAC;EAC3F;EACA9C,GAAG,CAACuE,yBAAyB,GAAG,EAAE;EAElC,KAAA1E,sBAAA,GAAIG,GAAG,CAAC+E,iCAAiC,cAAAlF,sBAAA,uBAArCA,sBAAA,CAAuC/F,MAAM,EACjD,KAAK,MAAMgJ,GAAG,IAAI,IAAIjB,GAAG,CAAC7B,GAAG,CAAC+E,iCAAiC,CAAC,EAAE;IAAA,IAAAI,qBAAA;IAAE;IAChE,IAAI1C,EAAgB,GAAGhL,kBAAkB,CAACiL,WAAW,CAACI,GAAG,EAAE9C,GAAG,CAAC;IAC/D,IAAIgD,EAAE,GAAGpK,mBAAmB,CAACoJ,IAAI,CAACc,GAAG,CAAC;IACtC,IAAI,CAACE,EAAE,EAAEpK,mBAAmB,CAACoJ,IAAI,CAACc,GAAG,CAAC,GAAGE,EAAE,GAAG,CAAC,CAAQ;IACvD,IAAI,CAACP,EAAE,CAAC2C,iBAAiB,EAAE;MACvBpC,EAAE,CAACG,MAAM,GAAG,EAAE;MACdH,EAAE,CAACqC,UAAU,GAAGxJ,SAAgB;MAChC;MACA;IACJ;IACA,IAAIyJ,OAAO,GAAG,EAAAH,qBAAA,GAAA1C,EAAE,CAAC2C,iBAAiB,cAAAD,qBAAA,uBAApBA,qBAAA,CAAsBI,KAAK,CAAClG,QAAQ,CAAC,KAAI,EAAE;IACzDzG,mBAAmB,CAACoJ,IAAI,CAACc,GAAG,CAAC,CAACK,MAAM,GAAGmC,OAAO,CAACE,GAAG,CAACC,CAAC,IAAE;MAAEA,CAAC,GAAGA,CAAC,CAACrL,IAAI,CAAC,CAAC;MAAE,OAAOqL,CAAC,CAAC7H,SAAS,CAAC6H,CAAC,CAAC3J,OAAO,CAAC,IAAI,CAAC,GAAC,CAAC,EAAE2J,CAAC,CAAC3L,MAAM,GAAC,CAAC,CAAC,CAACM,IAAI,CAAC,CAAC;IAAA,CAAC,CAAC;IAChI;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;;IAEA,IAAIyI,cAA0B,GAAG;MAAC,GAAG/J;IAAgB,CAAC;IACtD,KAAK,IAAImK,CAAC,IAAID,EAAE,CAACE,aAAa,EAAE,IAAI,CAACL,cAAc,CAACI,CAAC,CAAC,EAAEJ,cAAc,CAACI,CAAC,CAAC,GAAG,IAAI;IAChF,IAAIG,QAAQ,GAAG,GAAG,GAAC3B,MAAM,CAACC,IAAI,CAACmB,cAAc,CAAC,CAACQ,IAAI,CAAC,GAAG,CAAC,GAAC,QAAQ;IACjE,IAAIP,GAAG,CAACvC,QAAQ,CAAC,OAAO,CAAC,EAAEhC,OAAO,CAACC,GAAG,CAAC,gBAAgB,EAAE;MAAC4E,QAAQ;MAAEsC,KAAK,EAACjD,EAAE,CAAC2C,iBAAiB;MAAEO,MAAM,EAAC/M,mBAAmB,CAACoJ,IAAI,CAACc,GAAG,CAAC,CAACK;IAAM,CAAC,CAAC;IAC7I,IAAI;MACAH,EAAE,CAACqC,UAAU,GAAG,IAAIT,QAAQ,CAACxB,QAAQ,EAAE,UAAU,GAACX,EAAE,CAAC2C,iBAAiB,GAAC,QAAQ,CAAoB;IACvG,CAAC,CAAC,OAAO3F,CAAK,EAAE;MACZ;MACA,IAAImG,QAAiB,GAAI1M,OAAO,CAAC0M,QAAQ;MACzC,IAAI,CAAC1M,OAAO,CAAC0M,QAAQ,EAAE1M,OAAO,CAAC0M,QAAQ,GAAGA,QAAQ,GAAG;QAACC,IAAI,EAAE;MAAC,CAAC;MAC9DD,QAAQ,CAAC,GAAG,GAAE,EAAEA,QAAQ,CAACC,IAAK,CAAC,GAAGpG,CAAC;MACnCA,CAAC,CAACqG,QAAQ,GAAG,IAAI;MACjB,IAAIC,OAAO,GAAG,oDAAoD,GAACH,QAAQ,CAACC,IAAI,GAAC,eAAe;MAChGtH,OAAO,CAACmB,KAAK,CAAC,eAAe,EAAE;QAACoD,GAAG;QAAErD,CAAC;QAAE2D,QAAQ;QAAEI,IAAI,EAAE,UAAU,GAACf,EAAE,CAAC2C,iBAAiB,GAAC,QAAQ;QAAEW;MAAO,CAAC,CAAC;MAC3G/C,EAAE,CAACqC,UAAU,GAAG,IAAIT,QAAQ,CAAC,oBAAoB,EAAEmB,OAAO,CAAoB;IAClF;;IAGA;IACA/F,GAAG,CAACgF,yBAAyB,CAACtJ,IAAI,CAACoH,GAAG,CAAC;IACvC9C,GAAG,CAACiF,sBAAsB,CAACvJ,IAAI,CAACoH,GAAG,CAAC;IACpC,KAAK,IAAIG,CAAC,IAAIhM,YAAY,CAACiO,cAAc,EAAGlF,GAAG,CAAS,kBAAkB,GAACiD,CAAC,CAAC,CAACvH,IAAI,CAACoH,GAAG,CAAC;EAC3F;EACA9C,GAAG,CAAC+E,iCAAiC,GAAG,EAAE;EAE1C,IAAI/E,GAAG,CAACiF,sBAAsB,CAACnL,MAAM,EAAE;IACnC;IACA;IACA,KAAK,IAAIkM,KAAK,IAAI,IAAInE,GAAG,CAAC7B,GAAG,CAACiF,sBAAsB,CAAC,EAAE;MACnD,IAAInC,GAAW;MACf,IAAIL,EAAgB;MACpB,IAAIf,IAAc;MAClB,IAAI,OAAOsE,KAAK,KAAK,QAAQ,EAAE;QAC3BlD,GAAG,GAAGkD,KAAK,CAAClD,GAAG;QACfL,EAAE,GAAGhL,kBAAkB,CAACiL,WAAW,CAACI,GAAG,EAAE9C,GAAG,CAAC;QAC7C0B,IAAI,GAAGsE,KAAK,CAACtE,IAAI,IAAID,MAAM,CAACC,IAAI,CAACe,EAAE,CAACwD,MAAM,CAAC;MAC/C,CAAC,MACI;QACDnD,GAAG,GAAGkD,KAAK;QACXvD,EAAE,GAAGhL,kBAAkB,CAACiL,WAAW,CAACI,GAAG,EAAE9C,GAAG,CAAC;QAC7C0B,IAAI,GAAGD,MAAM,CAACC,IAAI,CAACe,EAAE,CAACwD,MAAM,CAAC;MACjC;MACA,IAAIjD,EAAE,GAAGpK,mBAAmB,CAACoJ,IAAI,CAACc,GAAG,CAAC;MACtC,IAAI,CAACE,EAAE,EAAEpK,mBAAmB,CAACoJ,IAAI,CAACc,GAAG,CAAC,GAAGE,EAAE,GAAG,CAAC,CAAQ;MACvD,IAAI,CAACA,EAAE,CAACiD,MAAM,EAAEjD,EAAE,CAACiD,MAAM,GAAG,CAAC,CAAC;MAC9B;MACA,KAAK,IAAI9L,GAAG,IAAIuH,IAAI,EAAE;QAClB,IAAI,CAACvH,GAAG,EAAE;UAAE,OAAO6I,EAAE,CAACiD,MAAM,CAAC9L,GAAG,CAAC;UAAE;QAAU;QAC7C,IAAI0I,cAAc,GAAG;UAAC,GAAG/J;QAAgB,CAAC;QAC1C,KAAK,IAAImK,CAAC,IAAIrK,mBAAmB,CAACoJ,IAAI,CAACc,GAAG,CAAC,CAACI,aAAa,EAAE,IAAI,CAACL,cAAc,CAACI,CAAC,CAAC,EAAEJ,cAAc,CAACI,CAAC,CAAC,GAAG,IAAI;QAC3G,KAAK,IAAIA,CAAC,IAAIrK,mBAAmB,CAACoJ,IAAI,CAACc,GAAG,CAAC,CAACK,MAAM,EAAE,IAAI,CAACN,cAAc,CAACI,CAAC,CAAC,EAAEJ,cAAc,CAACI,CAAC,CAAC,GAAG,IAAI;QACpG,IAAIG,QAAQ,GAAG,GAAG,GAAC3B,MAAM,CAACC,IAAI,CAACmB,cAAc,CAAC,CAACQ,IAAI,CAAC,GAAG,CAAC,GAAC,eAAe;QACxE;QACA,MAAMG,IAAY,GAAG,UAAU,GAAEf,EAAE,CAACwD,MAAM,CAAC9L,GAAG,CAAC,GAAC,eAAe;QAC/D;QACA,IAAI;UACA6I,EAAE,CAACiD,MAAM,CAAC9L,GAAG,CAAC,GAAG,IAAIyK,QAAQ,CAACxB,QAAQ,EAAEI,IAAI,CAAwB;UACpE;UACA;UACA;UACA;UACA;QACJ,CAAC,CACD,OAAO/D,CAAM,EAAE;UACXlB,OAAO,CAACmB,KAAK,CAAC,gBAAgB,EAAE;YAACoD,GAAG;YAAErD,CAAC;YAAE2D,QAAQ;YAAEI;UAAI,CAAC,CAAC;UACzDR,EAAE,CAACiD,MAAM,CAAC9L,GAAG,CAAC,GAAIuK,OAAO,IAAK7M,GAAG,CAACqD,EAAE,CAAC,iCAAiC,GAAGuE,CAAC,CAACyG,OAAO,CAACC,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,EAAE1G,CAAC,CAACyG,OAAO,CAAC;QACjH;MACJ;IACJ;IACAlG,GAAG,CAACiF,sBAAsB,GAAG,EAAE;IAC/B;EACJ;EAEA,KAAAnF,sBAAA,GAAIE,GAAG,CAAC8E,2BAA2B,cAAAhF,sBAAA,uBAA/BA,sBAAA,CAAiChG,MAAM,EAC3C,KAAK,MAAMgJ,GAAG,IAAI,IAAIjB,GAAG,CAAC7B,GAAG,CAAC8E,2BAA2B,CAAC,EAAE;IACxD,MAAMrC,EAAgB,GAAGhL,kBAAkB,CAACiL,WAAW,CAACI,GAAG,EAAE9C,GAAG,CAAC;IACjE,IAAIgD,EAAE,GAAGpK,mBAAmB,CAACoJ,IAAI,CAACc,GAAG,CAAC;IACtC,IAAI,CAACE,EAAE,EAAEpK,mBAAmB,CAACoJ,IAAI,CAACc,GAAG,CAAC,GAAGE,EAAE,GAAG,CAAC,CAAQ;IACvDA,EAAE,CAACoD,kBAAkB,GAAG,IAAI;IAC5B,IAAI,CAAC3D,EAAE,CAAC4D,WAAW,EAAE;MACjBrD,EAAE,CAACqD,WAAW,GAAGxK,SAAS;MAC1B;IACJ;IACA,MAAMyK,KAAK,GAAG7D,EAAE,CAAC4D,WAAW,CAACjM,IAAI,CAAC,CAAC,CAAC+L,KAAK,CAAC,IAAI,CAAC;IAC/C,IAAII,QAAQ,GAAGD,KAAK,CAACA,KAAK,CAACxM,MAAM,GAAG,CAAC,CAAC;IACtC,IAAIyM,QAAQ,CAACzK,OAAO,CAAC,QAAQ,CAAC,KAAK,CAAC,EAAEwK,KAAK,CAACA,KAAK,CAACxM,MAAM,GAAG,CAAC,CAAC,GAAG,WAAWyM,QAAQ,GAAG;IAGtF,IAAI,CAAC9D,EAAE,CAAC+D,SAAS,EAAE;MAAE5N,mBAAmB,CAACoJ,IAAI,CAACc,GAAG,CAAC,CAAC2D,WAAW,GAAG5K,SAAgB;MAAE;IAAU;IAC7F,IAAIgH,cAAc,GAAG;MAAC,GAAG/J;IAAgB,CAAC;IAC1C,KAAK,IAAImK,CAAC,IAAIrK,mBAAmB,CAACoJ,IAAI,CAACc,GAAG,CAAC,CAACI,aAAa,EAAE,IAAI,CAACL,cAAc,CAACI,CAAC,CAAC,EAAEJ,cAAc,CAACI,CAAC,CAAC,GAAG,IAAI;IAE3G,IAAIG,QAAQ,GAAG,GAAG,GAAC3B,MAAM,CAACC,IAAI,CAACmB,cAAc,CAAC,CAACQ,IAAI,CAAC,GAAG,CAAC,GAAC,GAAG;IAC5D,MAAMG,IAAI,GAAG8C,KAAK,CAACjD,IAAI,CAAC,IAAI,CAAC;IAC7B,IAAI;MACAL,EAAE,CAACqD,WAAW,GAAG,IAAIzB,QAAQ,CAACxB,QAAQ,EAAEI,IAAI,CAAsB;IACtE,CAAC,CAAC,OAAO/D,CAAC,EAAE;MACRuD,EAAE,CAACqD,WAAW,GAAGxK,SAAS;MAC1B0C,OAAO,CAACC,GAAG,CAAC,2BAA2B,EAAEiB,CAAC,CAAC;IAC/C;EACJ;EACAO,GAAG,CAAC8E,2BAA2B,GAAG,EAAE;EAGpC,KAAA/E,sBAAA,GAAIC,GAAG,CAACgF,yBAAyB,cAAAjF,sBAAA,uBAA7BA,sBAAA,CAA+BjG,MAAM,EACzC,KAAK,MAAMgJ,GAAG,IAAI,IAAIjB,GAAG,CAAC7B,GAAG,CAACgF,yBAAyB,CAAC,EAAE;IAAE;IACxD,IAAIvC,EAAgB,GAAGhL,kBAAkB,CAACiL,WAAW,CAACI,GAAG,EAAE9C,GAAG,CAAC;IAC/D,IAAIgD,EAAE,GAAGpK,mBAAmB,CAACoJ,IAAI,CAACc,GAAG,CAAC;IACtC,IAAI,CAACE,EAAE,EAAEpK,mBAAmB,CAACoJ,IAAI,CAACc,GAAG,CAAC,GAAGE,EAAE,GAAG,CAAC,CAAQ;IACvD,IAAI,CAACP,EAAE,CAAC+D,SAAS,EAAE;MAAE5N,mBAAmB,CAACoJ,IAAI,CAACc,GAAG,CAAC,CAAC2D,WAAW,GAAG5K,SAAgB;MAAE;IAAU;IAC7F,IAAIgH,cAAc,GAAG;MAAC,GAAG/J;IAAgB,CAAC;IAC1C,KAAK,IAAImK,CAAC,IAAIrK,mBAAmB,CAACoJ,IAAI,CAACc,GAAG,CAAC,CAACI,aAAa,EAAE,IAAI,CAACL,cAAc,CAACI,CAAC,CAAC,EAAEJ,cAAc,CAACI,CAAC,CAAC,GAAG,IAAI;IAC3G,KAAK,IAAIA,CAAC,IAAIrK,mBAAmB,CAACoJ,IAAI,CAACc,GAAG,CAAC,CAACK,MAAM,EAAE,IAAI,CAACN,cAAc,CAACI,CAAC,CAAC,EAAEJ,cAAc,CAACI,CAAC,CAAC,GAAG,IAAI;IACpG,IAAIG,QAAQ,GAAG,GAAG,GAAC3B,MAAM,CAACC,IAAI,CAACmB,cAAc,CAAC,CAACQ,IAAI,CAAC,GAAG,CAAC,GAAC,GAAG;IAE5D,MAAMG,IAAY,GAAI,UAAU,GAAGtM,EAAE,CAACwP,cAAc,CAACzN,GAAG,CAAC0N,MAAM,CAAClE,EAAE,CAAC+D,SAAS,CAAC,EAAE/D,EAAE,CAAC,GAAG,GAAG;IACxF;IACA,IAAI;MACA7J,mBAAmB,CAACoJ,IAAI,CAACc,GAAG,CAAC,CAAC2D,WAAW,GAAG,IAAI7B,QAAQ,CAACxB,QAAQ,EAAEI,IAAI,CAAyB;IACpG,CAAC,CACD,OAAO/D,CAAM,EAAE;MACX;AACZ;AACA;AACA;AACA;AACA;MACYlB,OAAO,CAACmB,KAAK,CAAC,gBAAgB,EAAE;QAACoD,GAAG;QAAErD,CAAC;QAAE2D,QAAQ;QAAEI;MAAI,CAAC,CAAC;MACzD5K,mBAAmB,CAACoJ,IAAI,CAACc,GAAG,CAAC,CAAC2D,WAAW,GAAI/B,OAAO,IAAKvN,qBAAqB,CAACyP,YAAY,CAACnH,CAAC,EAAE,YAAY,EAAEgD,EAAE,CAAC;IACpH;IACA;EACJ;EACAzC,GAAG,CAACgF,yBAAyB,GAAG,EAAE;EAIlC,KAAK,MAAM7K,GAAG,IAAIlD,YAAY,CAACiO,cAAc,EAAE;IAAA,IAAA2B,IAAA;IAC3C,KAAAA,IAAA,GAAK7G,GAAG,CAAS,kBAAkB,GAAC7F,GAAG,CAAC,cAAA0M,IAAA,uBAApCA,IAAA,CAAsC/M,MAAM,EAChD,KAAK,IAAIgJ,GAAG,IAAI,IAAIjB,GAAG,CAAE7B,GAAG,CAAS,kBAAkB,GAAC7F,GAAG,CAAC,CAAC,EAAS;MAClE,IAAIsI,EAAgB,GAAGhL,kBAAkB,CAACiL,WAAW,CAACI,GAAG,EAAE9C,GAAG,CAAC;MAC/D,IAAIgD,EAAE,GAAGpK,mBAAmB,CAACoJ,IAAI,CAACc,GAAG,CAAC;MACtC,IAAI,CAACE,EAAE,EAAEpK,mBAAmB,CAACoJ,IAAI,CAACc,GAAG,CAAC,GAAGE,EAAE,GAAG,CAAC,CAAQ;MACvD,IAAI8D,GAAW,GAAIrE,EAAE,CAAStI,GAAG,CAAC;MAClC,IAAI,CAAC2M,GAAG,EAAE;QACLlO,mBAAmB,CAACoJ,IAAI,CAACc,GAAG,CAAC,CAAS3I,GAAG,CAAC,GAAG0B,SAAS;QACvD;MACJ;MACA,IAAIgH,cAAc,GAAG;QAAC,GAAG/J;MAAgB,CAAC;MAC1C,KAAK,IAAImK,CAAC,IAAIrK,mBAAmB,CAACoJ,IAAI,CAACc,GAAG,CAAC,CAACI,aAAa,EAAE,IAAI,CAACL,cAAc,CAACI,CAAC,CAAC,EAAEJ,cAAc,CAACI,CAAC,CAAC,GAAG,IAAI;MAC3G,KAAK,IAAIA,CAAC,IAAIrK,mBAAmB,CAACoJ,IAAI,CAACc,GAAG,CAAC,CAACK,MAAM,EAAE,IAAI,CAACN,cAAc,CAACI,CAAC,CAAC,EAAEJ,cAAc,CAACI,CAAC,CAAC,GAAG,IAAI;MACpG,IAAIG,QAAQ,GAAG,GAAG,GAAC3B,MAAM,CAACC,IAAI,CAACmB,cAAc,CAAC,CAACQ,IAAI,CAAC,GAAG,CAAC,GAAC,GAAG;MAC5D9E,OAAO,CAACC,GAAG,CAAC,mBAAmB,GAACrE,GAAG,EAAE;QAAC0I,cAAc;QAAES,EAAE,EAAC1K,mBAAmB,CAACoJ,IAAI,CAACc,GAAG,CAAC,CAACK,MAAM;QAAEI,CAAC,EAAC3K,mBAAmB,CAACoJ,IAAI,CAACc,GAAG,CAAC,CAACI;MAAc,CAAC,CAAC;MAC/I3E,OAAO,CAACC,GAAG,CAAC,mBAAmB,GAACrE,GAAG,EAAE;QAAC2I,GAAG;QAAEM,QAAQ;QAAEI,IAAI,EAACsD;MAAG,CAAC,CAAC;MAC/D,IAAI;QACClO,mBAAmB,CAACoJ,IAAI,CAACc,GAAG,CAAC,CAAS3I,GAAG,CAAC,GAAG,IAAIyK,QAAQ,CAACxB,QAAQ,EAAE0D,GAAG,CAAC;MAC7E,CAAC,CACD,OAAOrH,CAAM,EAAE;QACXlB,OAAO,CAACmB,KAAK,CAAC,yBAAyB,GAACvF,GAAG,EAAE;UAAC2I,GAAG;UAAErD,CAAC;UAAE2D,QAAQ;UAAEI,IAAI,EAACsD;QAAG,CAAC,CAAC;QACzElO,mBAAmB,CAACoJ,IAAI,CAACc,GAAG,CAAC,CAAS3I,GAAG,CAAC,GAAG0B,SAAS;QACvD;QACAjD,mBAAmB,CAACoJ,IAAI,CAACc,GAAG,CAAC,CAAC2D,WAAW,GAAI/B,OAAO,IAAKvN,qBAAqB,CAACyP,YAAY,CAACnH,CAAC,EAAE,aAAa,GAAGtF,GAAG,GAAG,SAAS,EAAEsI,EAAE,CAAC;QACnI;MACJ;IACJ;IACCzC,GAAG,CAAS,kBAAkB,GAAC7F,GAAG,CAAC,GAAG,EAAE;EAC7C;EAEA,KAAK,IAAI4M,MAAM,IAAI/G,GAAG,CAACqC,gBAAgB,EAAE;IACrC,IAAI0E,MAAM,KAAK,eAAe,EAAE;IAChC;IACA;;IAEA;IACA,IAAI,CAACnO,mBAAmB,CAACoO,YAAY,CAACD,MAAM,CAAC,EAAE;MAC3CnO,mBAAmB,CAACoO,YAAY,CAACD,MAAM,CAAC,GAAG;QAACE,KAAK,EAAE,CAAC;MAAC,CAAC;IAC1D;IACA;IACA,IAAIC,IAAY,GAAGlH,GAAG,CAACiB,QAAQ,CAAC8F,MAAM,CAAW;IACjD7O,sBAAsB,CAACiP,kBAAkB,CAACD,IAAI,EAAElH,GAAG,EAAErD,QAAQ,CAAC;IAC9D;IACA;EACJ;EACAqD,GAAG,CAACqC,gBAAgB,GAAG,CAAC,CAAC;EAEzB,OAAOrC,GAAG;AAEd;AAEA,OAAO,SAASC,QAAQ,8CAAAA,CAAA,EAAsG;EAAA,IAAxDtD,QAAgB,GAAA4C,SAAA,CAAAzF,MAAA,QAAAyF,SAAA,QAAA1D,SAAA,GAAA0D,SAAA,MAAGJ,YAAY;EAAA,IAAE5F,MAAc,GAAAgG,SAAA,CAAAzF,MAAA,OAAAyF,SAAA,MAAA1D,SAAA;EACjH,IAAIuL,KAAa;EACjB,IAAIrI,KAAa;EACjB,IAAIsI,aAAsC,GAAG,EAAE;EAC/C,QAAQ9N,MAAM,CAAC0B,IAAI;IACf,KAAKxC,UAAU,CAACwC,IAAI;MAChBmM,KAAK,GAAG7N,MAAM,CAAC8B,KAAK;MACpB0D,KAAK,GAAGpC,QAAQ;MAChB9E,GAAG,CAACyP,KAAK,CAACF,KAAK,IAAE,CAAC,EAAE,uBAAuB,EAAE7N,MAAM,CAAC;MACpD,OAAO6N,KAAK,EAAE,EAAE;QACZ,MAAMG,KAAK,GAAGlP,YAAY,CAACV,KAAK,CAACiC,OAAO,CAAC,CAAC4N,QAAQ,CAACC,GAAG,CAAC,CAAC;QACxD,IAAI,CAACF,KAAK,EAAE;QACZF,aAAa,CAAC3L,IAAI,CAAC6L,KAAK,CAAC;QACzBxI,KAAK,GAAG2I,IAAI,CAAC3I,KAAK,EAAEwI,KAAK,CAAC;MAC9B;MACAxI,KAAK,CAACyC,mBAAmB,GAAG,CAAC,GAAG,IAAIK,GAAG,CAACwF,aAAa,CAACM,OAAO,CAAE3G,CAAC,IAAIS,MAAM,CAACC,IAAI,CAAC,CAAAV,CAAC,aAADA,CAAC,uBAADA,CAAC,CAAEC,QAAQ,KAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;MACnG;MACA,OAAOlC,KAAK;IAEhB,KAAKvG,UAAU,CAACyC,IAAI;MAChBmM,KAAK,GAAG7N,MAAM,CAAC8B,KAAK;MACpB0D,KAAK,GAAGpC,QAAQ;MAChB9E,GAAG,CAACyP,KAAK,CAACF,KAAK,IAAE,CAAC,EAAE,uBAAuB,EAAE7N,MAAM,CAAC;MACpD,OAAO6N,KAAK,EAAE,EAAE;QACZ,MAAMG,KAAK,GAAGlP,YAAY,CAACV,KAAK,CAACiC,OAAO,CAAC,CAACgO,QAAQ,CAACH,GAAG,CAAC,CAAC;QACxD,IAAI,CAACF,KAAK,EAAE;QACZF,aAAa,CAAC3L,IAAI,CAAC6L,KAAK,CAAC;QACzBxI,KAAK,GAAG2I,IAAI,CAAC3I,KAAK,EAAEwI,KAAK,EAAE,KAAK,CAAC;MACrC;MACAxI,KAAK,CAACyC,mBAAmB,GAAG,CAAC,GAAG,IAAIK,GAAG,CAACwF,aAAa,CAACM,OAAO,CAAE3G,CAAC,IAAIS,MAAM,CAACC,IAAI,CAAC,CAAAV,CAAC,aAADA,CAAC,uBAADA,CAAC,CAAEC,QAAQ,KAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;MACnG;MACA,OAAOlC,KAAK;IAChB;IACA;IACA;MACI,IAAIiB,GAAG,GAAG6H,SAAS,CAAClL,QAAQ,EAAEpD,MAAM,CAAC;MACrC,IAAIyG,GAAG,KAAKrD,QAAQ,EAAE,OAAOqD,GAAG;MAChC;MACA,IAAIuH,KAAK,GAAInO,CAAC,CAAC0O,WAAW,CAAC9H,GAAG,EAAErD,QAAQ,CAAC;MACzC,IAAI,CAACoL,qBAAqB,CAACR,KAAK,CAAC,EAAE,OAAOvH,GAAG;MAC7C;MACA,IAAIrD,QAAQ,KAAK,IAAI,EAAEtE,YAAY,CAACV,KAAK,CAACiC,OAAO,CAAC,CAAC4N,QAAQ,CAAC9L,IAAI,CAAC6L,KAAK,CAAC;MACvE,OAAOvH,GAAG;EAClB;AACJ;AAEA,SAAS+H,qBAAqBA,CAACR,KAAsB,EAAW;EAC5D,IAAI,CAAClP,YAAY,CAAC2P,kBAAkB,EAAE,OAAO,KAAK;EAClD,IAAIvG,MAAM,CAACC,IAAI,CAAC6F,KAAK,CAAC,CAACzN,MAAM,KAAK,CAAC,EAAE;IACjC,IAAI,UAAU,IAAIyN,KAAK,EAAE,OAAO,KAAK;IACrC,IAAI,eAAe,IAAIA,KAAK,EAAE,OAAO,KAAK;IAC1C,IAAI,aAAa,IAAIA,KAAK,EAAE,OAAO,KAAK;EAC5C;EACA,OAAO,IAAI;AACf;AACA,SAASG,IAAIA,CAAC3I,KAAa,EAAEwI,KAA0B,EAAyB;EAAA,IAAvBU,MAAM,GAAA1I,SAAA,CAAAzF,MAAA,QAAAyF,SAAA,QAAA1D,SAAA,GAAA0D,SAAA,MAAG,IAAI;EAClE,IAAI,CAACgI,KAAK,EAAE,OAAOxI,KAAK;EACxB,IAAImJ,WAAmB,GAAG;IAAC,GAAGnJ;EAAK,CAAW;EAC9C;EACA;EACAoJ,aAAa,CAACZ,KAAK,EAAEW,WAAW,CAAC;EACjC,IAAID,MAAM,EAAE5P,YAAY,CAACV,KAAK,CAACiC,OAAO,CAAC,CAACgO,QAAQ,CAAClM,IAAI,CAAEtC,CAAC,CAAC0O,WAAW,CAACI,WAAW,EAAEnJ,KAAK,CAAE,CAAC,CAAC,CAAC;EAAA,KACvF1G,YAAY,CAACV,KAAK,CAACiC,OAAO,CAAC,CAAC4N,QAAQ,CAAC9L,IAAI,CAAEtC,CAAC,CAAC0O,WAAW,CAACI,WAAW,EAAEnJ,KAAK,CAAE,CAAC,CAAC,CAAC;EACrF,OAAOmJ,WAAW;AACtB;AAEA,SAASC,aAAaA,CAACC,UAAmB,EAAEC,UAAmB,EAAQ;EACnE;EACA,KAAK,IAAIlO,GAAG,IAAIiO,UAAU,EAAE;IACxB,IAAIb,KAAK,GAAGa,UAAU,CAACjO,GAAG,CAAC;IAC3BoE,OAAO,CAACC,GAAG,CAAC,SAAS,EAAE;MAAC+I,KAAK;MAAEpN,GAAG;MAAEiO,UAAU;MAAEC;IAAU,CAAC,CAAC;IAC5D,IAAIlO,GAAG,CAAC2B,OAAO,CAAC,IAAI,CAAC,KAAK,CAAC,EAAE;MAAE,OAAOuM,UAAU,CAAClO,GAAG,CAACyD,SAAS,CAAC,CAAC,CAAC,CAAC;MAAE;IAAU;IAC9E,IAAI,OAAO2J,KAAK,KAAK,QAAQ,EAAE;MAC/B;MACIc,UAAU,CAAClO,GAAG,CAAC,GAAG;QAAC,GAAGkO,UAAU,CAAClO,GAAG;MAAC,CAAC;MACtCgO,aAAa,CAACC,UAAU,CAACjO,GAAG,CAAC,EAAEkO,UAAU,CAAClO,GAAG,CAAC,CAAC;IAAE,CAAC,MACjD;MAAEkO,UAAU,CAAClO,GAAG,CAAC,GAAGoN,KAAK;IAAE;EACpC;AACJ;AAEA,SAASM,SAAS,8CAAAA,CAAA,EAAsG;EAAA,IAAxDlL,QAAgB,GAAA4C,SAAA,CAAAzF,MAAA,QAAAyF,SAAA,QAAA1D,SAAA,GAAA0D,SAAA,MAAGJ,YAAY;EAAA,IAAE5F,MAAc,GAAAgG,SAAA,CAAAzF,MAAA,OAAAyF,SAAA,MAAA1D,SAAA;EAC3G,IAAI,CAACc,QAAQ,EAAE;IAAEA,QAAQ,GAAGwC,YAAY,GAAGzH,MAAM,CAACsG,GAAG,CAAC,CAAC;EAAE;EACzD,IAAIsK,EAAmB;EACvB;EACA,IAAI,CAAClJ,WAAW,EAAE;IACd;IACAA,WAAW,GAAG,IAAI;EACtB;EACA,IAAI,CAAEzC,QAAQ,CAAS4L,SAAS,EAAE;IAC9B;IACA;EAAA,CACH,CAAC;EACF,QAAQhP,MAAM,CAAC0B,IAAI;IACf,KAAK3D,eAAe,CAAC2D,IAAI;MAAEqN,EAAE,GAAG/O,MAAyB;MAAE;IAC3D,KAAKhB,UAAU,CAAC0C,IAAI;IACpB;MACI,IAAI1B,MAAM,CAAC0B,IAAI,CAACa,OAAO,CAAC,UAAU,CAAC,KAAK,CAAC,EAAE;QACvC;QACA,OAAOa,QAAQ;MACnB;MACA2L,EAAE,GAAG,IAAIhR,eAAe,CAAC,CAACiC,MAAM,CAAC,EAAE,KAAK,CAAC;MACzC;EACR;EACA,IAAIyG,GAAG,GAAGtD,sBAAsB,CAACC,QAAQ,EAAE2L,EAAE,CAAC;EAC9C;AACJ;AACA;AACA;EACI,OAAOtI,GAAG;AACd;AACA,SAASwI,aAAaA,CAACC,KAA2C,EAAC;EAC/DvQ,sBAAsB,CAACwQ,YAAY,GAC/B,IAAI/P,UAAU,CAAkC8P,KAAK,EAAE,YAAY,CAAC,CAC/DE,sBAAsB,CAAC,OAAO,CAAC;EACxC;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,gBAAgBA,CAACC,IAAmD,EAAEC,IAAmD,EAAE;EAChI,KAAK,IAAIC,KAAK,IAAIF,IAAI,EAAE;IACpB,QAAQE,KAAK;MACT,KAAK,qBAAqB;QAAE;MAC5B,KAAK,IAAI;QAAE;MACX,KAAK,OAAO;QAAE;MACd;QAAS;IACb;IACA,IAAI,CAACA,KAAK,CAAC,CAAC,CAAC,IAAI,EAAE,EAAElL,WAAW,CAAC,CAAC,KAAKkL,KAAK,CAAC,CAAC,CAAC,EAAE,SAAS,CAAC;IAC3D,IAAIC,OAAO,GAAGD,KAAK,CAACnL,SAAS,CAAC,CAAC,CAAC;IAChC,IAAIoD,CAAC,GAAG6H,IAAI,CAACE,KAAK,CAAC;IACnB,IAAIE,CAAC,GAAGH,IAAI,CAAC,GAAG,GAACE,OAAO,CAAC;IACzB,IAAI,CAAChI,CAAC,IAAE,CAACiI,CAAC,EAAE1K,OAAO,CAACmB,KAAK,CAAC,uBAAuB,EAAE;MAACsB,CAAC;MAAEiI;IAAC,CAAC,CAAC;IAC1DjI,CAAC,CAACkI,KAAK,GAAGD,CAAC;IACX,IAAI,CAACA,CAAC,EAAE1K,OAAO,CAACmB,KAAK,CAAC,8CAA8C,EAAEuJ,CAAC,EAAEjI,CAAC,CAAC;IAC3E;IACAA,CAAC,CAACmI,SAAS,GAAG,IAAIF,CAAC,CAAC,KAAK,CAAC;IAC1BjI,CAAC,CAACoI,SAAS,GAAGpI,CAAC;IAEfiI,CAAC,CAACC,KAAK,GAAGlI,CAAC,CAACkI,KAAK;IACjBD,CAAC,CAACE,SAAS,GAAGnI,CAAC,CAACmI,SAAS;IACzBF,CAAC,CAACG,SAAS,GAAGpI,CAAC,CAACoI,SAAS;;IAEzB;IACA;IACA;EACJ;AACJ;AACA,SAASC,iBAAiBA,CAAA,EAAE;EACxB;EACAC,UAAU,CACN,MAAKC,CAAC,CAACC,QAAQ,CAAC,CAACC,EAAE,CAAC,SAAS,EACxBhK,CAAe,IAAK;IACjBpH,YAAY,CAAC2P,kBAAkB,GAAG,IAAI;IACtC9P,sBAAsB,CAACwR,GAAG,CAA0B,kBAAkB,CAAC,CAACC,WAAW,CAAClK,CAAC,CAAC;EAC1F,CAAC,CAAC,EACJ,CAAC,CAAC;EACR;AACJ;AACA,SAASmK,aAAaA,CAACnK,CAAa,EAAC;EACjC;AACJ;AACA;AACA;AACA;AACA;AALI;AAQJ,OAAO,eAAeoK,gBAAgBA,CAAA,EAAG;EACrC3R,sBAAsB,CAAC4R,UAAU,CAAC,CAAC;EACnC,IAAIC,WAA0D,GAAG,CAAC,CAAC;EACnE,IAAIC,WAA0D,GAAG,CAAC,CAAC;EACnE,KAAK,IAAItM,IAAI,IAAIxF,sBAAsB,CAAC+R,OAAO,EAAE;IAC7C,QAAOvM,IAAI,CAAC,CAAC,CAAC;MACV,KAAK,GAAG;QAAEqM,WAAW,CAACrM,IAAI,CAAC,GAAGxF,sBAAsB,CAAC+R,OAAO,CAACvM,IAAI,CAA8B;QAAE;MACjG,KAAK,GAAG;QAAEsM,WAAW,CAACtM,IAAI,CAAC,GAAGxF,sBAAsB,CAAC+R,OAAO,CAACvM,IAAI,CAA8B;QAAE;MACjG;QAAS;IACb;EACJ;EAEAkL,gBAAgB,CAACmB,WAAW,EAAEC,WAAW,CAAC;EAC1CxB,aAAa,CAACtQ,sBAAsB,CAACwR,GAAG,CAAC,oBAAoB,CAAC,CAAC;EAC/DxQ,OAAO,CAACgR,cAAc,GAAG;IAACX,CAAC,EAAErQ,OAAO,CAACqQ,CAAC;IAAE3R,OAAO;IAAEU,KAAK,EAAEA,KAAK;IAAEO,SAAS;IAAE,GAAGX,sBAAsB,CAACiS,uBAAuB,CAAC,CAAC;IAAE,GAAGjR,OAAO,CAACkR;EAAU,CAAC;EAErJf,iBAAiB,CAAC,CAAC;EAEnB3R,MAAM,CAAC2S,IAAI,CAAC,CAAC;EACb,MAAMC,IAAI,GAAGvR,OAAO,CAACwR,IAAI,CAAQ,MAAM,CAAC;EACxC,IAAGD,IAAI,EAAE;IACL3S,KAAK,CAACqG,GAAG,CAACsM,IAAI,CAAC5M,IAAI,EAAE4M,IAAI,CAACE,OAAO,EAAEF,IAAI,CAACG,QAAQ,EAAEH,IAAI,CAACI,WAAW,EAAEJ,IAAI,CAACK,OAAO,EAAEL,IAAI,CAACM,UAAU,EAAEN,IAAI,CAACO,KAAK,EAAEP,IAAI,CAACQ,KAAK,EAAER,IAAI,CAAChN,EAAE,CAAC;IACnI3F,KAAK,CAACiC,OAAO,GAAG0Q,IAAI,CAAChN,EAAE;IACvBjF,YAAY,CAACiS,IAAI,CAAChN,EAAE,CAAC,GAAG;MAACsK,QAAQ,EAAE,EAAE;MAAEJ,QAAQ,EAAE;IAAE,CAAC;IACpD,MAAMxO,WAAW,CAAC+R,MAAM,CAAC,CAAC;EAC9B,CAAC,MAAMpT,KAAK,CAACiC,OAAO,GAAG,EAAE;AAE7B;AAAC,IAAAkF,EAAA;AAAAkM,YAAA,CAAAlM,EAAA","ignoreList":[]},"metadata":{},"sourceType":"module"}