{"version":3,"file":"async-lz-string.js","mappings":"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","sources":["webpack://async-lz-string/webpack/universalModuleDefinition","webpack://async-lz-string/./src/async-lz-string.ts","webpack://async-lz-string/./src/compressor.ts","webpack://async-lz-string/./src/decompressor.ts","webpack://async-lz-string/./src/wait.ts","webpack://async-lz-string/webpack/bootstrap","webpack://async-lz-string/webpack/startup"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse {\n\t\tvar a = factory();\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(this, () => {\nreturn ","import { ICompressor, CompressorImpl } from \"./compressor\";\nimport { IDecompressor, DecompressorImpl } from \"./decompressor\";\n\nconst compressor: ICompressor = new CompressorImpl();\nconst decompressor: IDecompressor = new DecompressorImpl();\n\nconst keyStrBase64 =\n  \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\nconst baseReverseDic: Record<string, Record<string, number>> = {};\n\nfunction getBaseValue(alphabet, character): number {\n  if (!baseReverseDic[alphabet]) {\n    baseReverseDic[alphabet] = {};\n    for (let i = 0; i < alphabet.length; i++) {\n      baseReverseDic[alphabet][alphabet.charAt(i)] = i;\n    }\n  }\n  return baseReverseDic[alphabet][character];\n}\n\nexport async function compressToBase64(input: string) {\n  if (input === null) {\n    return \"\";\n  }\n  const compressResult = await compressor.compress(input, 6, function (a) {\n    return keyStrBase64.charAt(a);\n  });\n  switch (\n    compressResult.length % 4 // To produce valid Base64\n  ) {\n    default:\n    case 0:\n      return compressResult;\n    case 1:\n      return compressResult + \"===\";\n    case 2:\n      return compressResult + \"==\";\n    case 3:\n      return compressResult + \"=\";\n  }\n}\n\nexport async function decompressFromBase64(compressed: string) {\n  if (compressed === null) {\n    return \"\";\n  }\n  if (compressed === \"\") {\n    return null;\n  }\n  return await decompressor.decompress(compressed.length, 32, function (index) {\n    return getBaseValue(keyStrBase64, compressed.charAt(index));\n  });\n}\n\nexport async function compressToUTF16(input: string) {\n  if (input === null) {\n    return \"\";\n  }\n  const compressResult = await compressor.compress(\n    input,\n    15,\n    function (a: number) {\n      return String.fromCharCode(a + 32);\n    }\n  );\n  return compressResult + \" \";\n}\n\nexport async function decompressFromUTF16(compressed: string) {\n  if (compressed === null) {\n    return \"\";\n  }\n  if (compressed === \"\") {\n    return null;\n  }\n  return await decompressor.decompress(\n    compressed.length,\n    16384,\n    function (index: number) {\n      return compressed.charCodeAt(index) - 32;\n    }\n  );\n}\n","import { wait } from \"./wait\";\n\nconst REV = [\n    0x0,\n    0x8,\n    0x4,\n    0xc,\n    0x2,\n    0xa,\n    0x6,\n    0xe,\n    0x1,\n    0x9,\n    0x5,\n    0xd,\n    0x3,\n    0xb,\n    0x7,\n    0xf,\n];\n\nfunction reverseBits(n: number, numNibbles: number) {\n    let ret = 0;\n\n    for (let i = 0; i < numNibbles; ++i) {\n        ret <<= 4;\n        ret |= REV[n & 0xF];\n        n >>= 4;\n    }\n\n    return ret;\n}\n\nexport interface ICompressor {\n    compress(uncompressed: string, bitsPerChar: number, getCharFromInt: (a: number) => string);\n}\n\ninterface ICompressorContext {\n    // return value\n    data: string[];\n    // which bit in dataVal we should write next\n    dataPosition: number;\n\n    // value that will be added to data when dataPosition > numBits - 1\n    dataVal: number;\n\n    dictionary: Map<string, number>;\n    dictionaryToCreate: Map<string, boolean>;\n    dictSize: number;\n\n    enlargeIn: number;\n\n    numBits: number;\n\n    // Current string context\n    w: string;\n}\n\nexport class CompressorImpl implements ICompressor {\n    private static writeValueToData(context: ICompressorContext, value: number, bitsToWrite: number, bitsPerChar: number, getCharFromInt: (a: number) => string) {\n        if (bitsToWrite % 4 !== 0 || context.dataPosition + bitsToWrite > bitsPerChar - 1) {\n            for (let i = 0; i < bitsToWrite; i++) {\n                context.dataVal = (context.dataVal << 1) | (value & 1);\n                if (context.dataPosition == bitsPerChar - 1) {\n                    context.dataPosition = 0;\n                    context.data.push(getCharFromInt(context.dataVal));\n                    context.dataVal = 0;\n                } else {\n                    context.dataPosition++;\n                }\n                value >>= 1;\n            }\n        } else {\n            // Fast + simple path for case where iterations is divisible by 4 and we don't spill into a new character\n            context.dataVal <<= bitsToWrite;\n            context.dataVal |= reverseBits(value, bitsToWrite / 4);\n            context.dataPosition += bitsToWrite;\n        }\n    }\n\n    private static writeWToDataVal(context: ICompressorContext, bitsPerChar: number, getCharFromInt: (a: number) => string) {\n        if (context.dictionaryToCreate.has(context.w)) {\n            if (context.w.charCodeAt(0) < 256) {\n                CompressorImpl.writeValueToData(context, 0, context.numBits, bitsPerChar, getCharFromInt);\n\n                CompressorImpl.writeValueToData(context, context.w.charCodeAt(0), 8, bitsPerChar, getCharFromInt);\n            } else {\n                CompressorImpl.writeValueToData(context, 1, context.numBits, bitsPerChar, getCharFromInt);\n\n                CompressorImpl.writeValueToData(context, context.w.charCodeAt(0), 16, bitsPerChar, getCharFromInt);\n            }\n            context.enlargeIn--;\n            if (context.enlargeIn == 0) {\n                context.enlargeIn = Math.pow(2, context.numBits);\n                context.numBits++;\n            }\n            context.dictionaryToCreate.delete(context.w);\n        } else {\n            CompressorImpl.writeValueToData(context, context.dictionary.get(context.w), context.numBits, bitsPerChar, getCharFromInt);\n        }\n        context.enlargeIn--;\n        if (context.enlargeIn == 0) {\n            context.enlargeIn = Math.pow(2, context.numBits);\n            context.numBits++;\n        }\n    }\n\n    private static loopIteration(uncompressed: string, ii: number, bitsPerChar: number, getCharFromInt: (a: number) => string, context: ICompressorContext) {\n        const context_c = uncompressed.charAt(ii);\n        if (!context.dictionary.has(context_c)) {\n            context.dictionary.set(context_c, context.dictSize++);\n            context.dictionaryToCreate.set(context_c, true)\n        }\n\n        const context_wc = context.w + context_c;\n\n        if (context.dictionary.has(context_wc)) {\n            // we have seen the string contained in context_wc before. Update context so on next iteration we will continue building on this string.\n            context.w = context_wc;\n        } else {\n            this.writeWToDataVal(context, bitsPerChar, getCharFromInt);\n            context.dictionary.set(context_wc, context.dictSize++);\n            context.w = String(context_c);\n        }\n    }\n\n    public compress(uncompressed: string, bitsPerChar: number, getCharFromInt: (a: number) => string): Promise<string> {\n        return new Promise(async (resolve) => {\n            if (uncompressed == null) {\n                resolve(\"\");\n                return;\n            }\n\n            let context: ICompressorContext = {\n                data: [],\n                dataPosition: 0,\n                dataVal: 0,\n                dictionary: new Map<string, number>(),\n                dictionaryToCreate: new Map<string, boolean>(),\n                dictSize: 3,\n                enlargeIn: 2,\n                numBits: 2,\n                w: \"\",\n            };\n\n            for (let ii = 0; ii < uncompressed.length; ii += 1) {\n                CompressorImpl.loopIteration(uncompressed, ii, bitsPerChar, getCharFromInt, context);\n                if (ii % 10000 === 0) {\n                    await wait();\n                }\n            }\n\n            // Output the code for w.\n            if (context.w !== \"\") {\n                CompressorImpl.writeWToDataVal(context, bitsPerChar, getCharFromInt);\n            }\n\n            CompressorImpl.writeValueToData(context, 2, context.numBits, bitsPerChar, getCharFromInt);\n\n            context.dataVal <<= bitsPerChar - context.dataPosition;\n            context.data.push(getCharFromInt(context.dataVal));\n\n            resolve(context.data.join(''));\n        });\n    }\n}\n","import { wait } from \"./wait\";\n\nexport interface IDecompressor {\n    decompress(length: number, resetValue: number, getNextValue: (a: number) => number);\n}\n\ninterface IDecompressionContext {\n    bits: number;\n\n    c: string | number;\n\n    dataIndex: number;\n    dataPosition: number;\n    dataVal: number;\n\n    dictionary: Map<number, number>;\n    dictSize: number;\n\n    enlargeIn: number;\n\n    entry: string | number;\n\n    maxPower: number;\n\n    numBits: number;\n\n    power: number;\n\n    resb: number;\n\n    result: string[];\n\n    w: string;\n}\n\nexport class DecompressorImpl implements IDecompressor {\n    public decompress(length: number, resetValue: number, getNextValue: (a: number) => number): Promise<string> {\n        return new Promise(async (resolve) => {\n            let context: IDecompressionContext = {\n                bits: 0,\n\n                c: null,\n\n                dataIndex: 1,\n                dataPosition: resetValue,\n                dataVal: getNextValue(0),\n\n                dictionary: new Map<number, number>(),\n                dictSize: 4,\n\n                enlargeIn: 4,\n\n                entry: \"\",\n\n                maxPower: Math.pow(2, 2),\n\n                numBits: 3,\n\n                power: 1,\n\n                resb: null,\n\n                result: [],\n\n                w: null\n            };\n\n            for (let i = 0; i < 3; i += 1) {\n                context.dictionary.set(i, i);\n            }\n\n            while (context.power != context.maxPower) {\n                context.resb = context.dataVal & context.dataPosition;\n                context.dataPosition >>= 1;\n                if (context.dataPosition == 0) {\n                    context.dataPosition = resetValue;\n                    context.dataVal = getNextValue(context.dataIndex++);\n                }\n                context.bits |= (context.resb > 0 ? 1 : 0) * context.power;\n                context.power <<= 1;\n            }\n\n            const next = context.bits;\n            switch (next) {\n                case 0:\n                    context.bits = 0;\n                    context.maxPower = Math.pow(2, 8);\n                    context.power = 1;\n                    while (context.power != context.maxPower) {\n                        context.resb = context.dataVal & context.dataPosition;\n                        context.dataPosition >>= 1;\n                        if (context.dataPosition == 0) {\n                            context.dataPosition = resetValue;\n                            context.dataVal = getNextValue(context.dataIndex++);\n                        }\n                        context.bits |= (context.resb > 0 ? 1 : 0) * context.power;\n                        context.power <<= 1;\n                    }\n                    context.c = String.fromCharCode(context.bits);\n                    break;\n                case 1:\n                    context.bits = 0;\n                    context.maxPower = Math.pow(2, 16);\n                    context.power = 1;\n                    while (context.power !== context.maxPower) {\n                        context.resb = context.dataVal & context.dataPosition;\n                        context.dataPosition >>= 1;\n                        if (context.dataPosition === 0) {\n                            context.dataPosition = resetValue;\n                            context.dataVal = getNextValue(context.dataIndex++);\n                        }\n                        context.bits |= (context.resb > 0 ? 1 : 0) * context.power;\n                        context.power <<= 1;\n                    }\n                    context.c = String.fromCharCode(context.bits);\n                    break;\n                case 2:\n                    resolve(\"\");\n                    return;\n            }\n            context.dictionary[3] = context.c;\n            context.w = context.c as string;\n            context.result.push(context.c as string);\n            let iteration = 1;\n            while (true) {\n                if (iteration % 20000 === 0) {\n                    await wait();\n                }\n                if (context.dataIndex > length) {\n                    resolve(\"\");\n                    return;\n                }\n\n                context.bits = 0;\n                context.maxPower = Math.pow(2, context.numBits);\n                context.power = 1;\n                while (context.power != context.maxPower) {\n                    context.resb = context.dataVal & context.dataPosition;\n                    context.dataPosition >>= 1;\n                    if (context.dataPosition == 0) {\n                        context.dataPosition = resetValue;\n                        context.dataVal = getNextValue(context.dataIndex++);\n                    }\n                    context.bits |= (context.resb > 0 ? 1 : 0) * context.power;\n                    context.power <<= 1;\n                }\n                switch (context.c = context.bits) {\n                    case 0:\n                        context.bits = 0;\n                        context.maxPower = Math.pow(2, 8);\n                        context.power = 1;\n                        while (context.power !== context.maxPower) {\n                            context.resb = context.dataVal & context.dataPosition;\n                            context.dataPosition >>= 1;\n                            if (context.dataPosition == 0) {\n                                context.dataPosition = resetValue;\n                                context.dataVal = getNextValue(context.dataIndex++);\n                            }\n                            context.bits |= (context.resb > 0 ? 1 : 0) * context.power;\n                            context.power <<= 1;\n                        }\n\n                        context.dictionary[context.dictSize++] = String.fromCharCode(context.bits);\n                        context.c = context.dictSize - 1;\n                        context.enlargeIn--;\n                        break;\n                    case 1:\n                        context.bits = 0;\n                        context.maxPower = Math.pow(2, 16);\n                        context.power = 1;\n                        while (context.power !== context.maxPower) {\n                            context.resb = context.dataVal & context.dataPosition;\n                            context.dataPosition >>= 1;\n                            if (context.dataPosition == 0) {\n                                context.dataPosition = resetValue;\n                                context.dataVal = getNextValue(context.dataIndex++);\n                            }\n                            context.bits |= (context.resb > 0 ? 1 : 0) * context.power;\n                            context.power <<= 1;\n                        }\n                        context.dictionary[context.dictSize++] = String.fromCharCode(context.bits);\n                        context.c = context.dictSize - 1;\n                        context.enlargeIn--;\n                        break;\n                    case 2:\n                        resolve(context.result.join(''));\n                        return;\n                }\n\n                if (context.enlargeIn == 0) {\n                    context.enlargeIn = Math.pow(2, context.numBits);\n                    context.numBits++;\n                }\n\n                if (context.dictionary[context.c]) {\n                    context.entry = context.dictionary[context.c];\n                } else {\n                    if (context.c === context.dictSize) {\n                        context.entry = context.w + context.w.charAt(0);\n                    } else {\n                        resolve(null);\n                        return;\n                    }\n                }\n                context.result.push(context.entry as string);\n\n                // Add w+entry[0] to the dictionary.\n                context.dictionary[context.dictSize++] = context.w + (context.entry as string).charAt(0);\n                context.enlargeIn--;\n\n                context.w = context.entry as string;\n\n                if (context.enlargeIn == 0) {\n                    context.enlargeIn = Math.pow(2, context.numBits);\n                    context.numBits++;\n                }\n\n                iteration++;\n            }\n        });\n    }\n}\n","\nexport async function wait() {\n    return new Promise((resolve) => {\n        setTimeout(resolve, 0);\n    });\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(48);\n"],"names":["root","factory","exports","module","define","amd","a","i","this","compressor","CompressorImpl","decompressor","DecompressorImpl","keyStrBase64","baseReverseDic","input","compress","charAt","compressResult","length","compressed","decompress","index","alphabet","character","getBaseValue","String","fromCharCode","charCodeAt","REV","writeValueToData","context","value","bitsToWrite","bitsPerChar","getCharFromInt","dataPosition","dataVal","data","push","n","numNibbles","ret","reverseBits","writeWToDataVal","dictionaryToCreate","has","w","numBits","enlargeIn","Math","pow","delete","dictionary","get","loopIteration","uncompressed","ii","context_c","set","dictSize","context_wc","Promise","resolve","Map","wait","join","resetValue","getNextValue","bits","c","dataIndex","entry","maxPower","power","resb","result","iteration","setTimeout","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","call"],"sourceRoot":""}