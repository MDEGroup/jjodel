{"ast":null,"code":"var _dec, _class, _dec2, _class3, _dec3, _class5, _dec4, _class7, _class8, _dec5, _class9, _class10, _dec6, _class11;\nimport { DPointerTargetable, JsType, Log, LPointerTargetable, RuntimeAccessible, RuntimeAccessibleClass, SetFieldAction, SetRootFieldAction, U } from \"../joiner\";\n// (DX extends DUser ? LUser : (DX extends DPointerTargetable ? LPointerTargetable : (ERROR))\n// (DX extends DUser ? LUser : (DX extends DPointerTargetable ? LPointerTargetable : (           WViewElement\n//\n// (IN extends WViewElement ? LViewElement : (IN extends WViewTransientProperties ? LWiewTransientProperties : (ERROR)))\n// ))\n// type WtoL<WX extends WPointerTargetable> ='';\n\nconst childrenKeys = [\"@\", \"$\"];\nexport let LogicContext = (_dec = RuntimeAccessible('LogicContext'), _dec(_class = class LogicContext extends RuntimeAccessibleClass {\n  // & GObject;\n\n  constructor(proxyObject, data) {\n    super();\n    this.proxyObject = void 0;\n    this.data = void 0;\n    this.write = void 0;\n    this.className = this.constructor.cname || this.constructor.name;\n    this.data = data;\n    this.proxyObject = proxyObject;\n    this.write = proxyObject;\n  }\n  /*\r\n      saveToRedux(propkey: \"keyof data\" | string, val: \"typeof data[path]\" | any): void { // todo: ask non stackoverflow\r\n          // todo, put data in redux store, path is \"obj1.obj2.obj3...\" might replace it with a path funciton that return the foremost nested object container\r\n          if (!propkey) {\r\n              // todo: set whole object instead of a property\r\n          }\r\n      }*/\n}) || _class);\nRuntimeAccessibleClass.set_extend(RuntimeAccessibleClass, LogicContext);\nexport let MapLogicContext = (_dec2 = RuntimeAccessible('MapLogicContext'), _dec2(_class3 = class MapLogicContext extends LogicContext {\n  constructor(proxy, data, path) {\n    let subMaps = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];\n    super(proxy, data);\n    // this.proxyfyFunction = proxyfyFunction;\n    this.data = void 0;\n    this.path = void 0;\n    this.subMaps = void 0;\n    this.proxyObject = proxy;\n    this.data = data;\n    this.path = path;\n    this.subMaps = subMaps;\n    this.className = this.constructor.cname || this.constructor.name;\n  }\n}) || _class3);\nRuntimeAccessibleClass.set_extend(LogicContext, MapLogicContext);\nexport let MyProxyHandler = (_dec3 = RuntimeAccessible('MyProxyHandler'), _dec3(_class5 = class MyProxyHandler extends RuntimeAccessibleClass {\n  constructor() {\n    super(...arguments);\n    this.s = 'set_';\n    this.g = 'get_';\n  }\n  /*get(target: T, p: string | number | symbol, proxyitself: Proxyfied<T>): boolean {\r\n      switch (p) {\r\n          case '_isProxy': return true;\r\n          case 'init': return (this as any).init;\r\n          case 'init0': return (this as any).init0;\r\n          default: throw new Error('proxy get must be overridden, called for key: ' + (p as string));\r\n      }}*/\n  set(target, p, value, proxyitself) {\n    throw new Error('proxy set must be overridden');\n  }\n  deleteProperty(target, p) {\n    throw new Error('proxy delete must be overridden');\n  }\n  ownKeys(target) {\n    // return Object.getOwnPropertyNames(target);\n    console.log(\"ownkeys trap 1\", {\n      thiss: this,\n      target\n    });\n    console.log(\"ownkeys trap 2\", {\n      thiss: this,\n      target,\n      ret: Reflect.ownKeys(target)\n    });\n    return Reflect.ownKeys(target);\n  }\n  /// proxy methods not used\n  /* setPrototypeOf(target: T, v: object | null): boolean { ?? }\r\n  apply(target: T, thisArg: any, argArray: any[]): any { }\r\n  defineProperty(target: T, p: string | symbol, attributes: PropertyDescriptor): boolean { }\r\n  construct(target: T, argArray: any[], newTarget: Function): object { }\r\n  getOwnPropertyDescriptor(target: T, p: string | symbol): PropertyDescriptor | undefined { }\r\n  has(target: T, p: string | symbol): boolean { return p in target; }\r\n  getPrototypeOf(target: T): object | null { }\r\n  isExtensible(target: T): boolean { }\r\n  preventExtensions(target: T): boolean { }*/\n\n  static wrap(data, baseObjInLookup) {\n    let path = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n    let canThrow = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    //    static wrap<D extends RuntimeAccessibleClass, L extends LPointerTargetable, RET extends boolean = false>\n    //        (data: D | Pointer<DViewElement>, baseObjInLookup?: DPointerTargetable, path: string = '', canthrow: RET = false as RET): RET {\n    return DPointerTargetable.wrap(data, baseObjInLookup, path);\n  }\n  static isProxy(data) {\n    return (data === null || data === void 0 ? void 0 : data.__isProxy) || false;\n  }\n}) || _class5);\nRuntimeAccessibleClass.set_extend(RuntimeAccessibleClass, MyProxyHandler);\n/*\r\n* handling proxy += and proxy -=\r\n*\r\n* will become var = var + add; which will call Symbol.getPrimitive\r\nconsole.log(+obj2);     // 10        — hint is \"number\"         NaN with +array with multiple vals, +array[0] with array of size 1, NaN with functions & objects\r\nconsole.log(`${obj2}`); // \"hello\"   — hint is \"string\"         array => array.join(','), object => \"[object Object]\", function => function.toString() whole func definition with body code\r\nconsole.log(obj2 + \"\"); // \"true\"    — hint is \"default\"        array, object, function => same as with hint \"string\"\r\n*\r\n* */\n// NB: lclass.extends += somepointer will become: lclass.extends = lclass.extends + somepointer;\n// array + string will cause getPrimitive(\"default\") to array, then .join(',') on it, and finally and toString() to be called on all array members.\n// so pointers cannot include \",\" char and toString() must return a pointer to keep lclass.extends += somepointer as a valid expression;\n// -= will call getPrimitive(\"number\") which will result in array -> NaN, so NaN = NaN - pointer and cannot be done.\n// or maybe it can because if getPrimitive fails it calls toString as fallback, and viceversa\nlet GetPathHandler = (_dec4 = RuntimeAccessible('GetPathHandler'), _dec4(_class7 = (_class8 = class GetPathHandler extends MyProxyHandler {\n  constructor() {\n    super();\n    this.strbuilder = '';\n    this.array = [];\n    this.calls = [];\n  }\n  get(targetObj, propKey, proxyitself) {\n    // console.log('GetPathHandler', {targetObj, propKey, proxyitself});\n    if (propKey === \"start\") {\n      this.strbuilder = '';\n      this.array = [];\n    }\n    if (propKey === '$') {\n      const ret = GetPathHandler.__asCalls ? this.calls : GetPathHandler.__asArray ? this.array : this.strbuilder;\n      this.array = [];\n      this.strbuilder = '';\n      return ret;\n    }\n    this.array.push(propKey);\n    this.calls.push(arguments);\n    if (propKey === Symbol.toPrimitive) {\n      console.log(\"toprimitive\");\n      return function () {\n        for (var _len = arguments.length, a = new Array(_len), _key = 0; _key < _len; _key++) {\n          a[_key] = arguments[_key];\n        }\n        console.log(\"toprimitive called with parameters\", a);\n      };\n    }\n    if (!GetPathHandler.__asArray && !GetPathHandler.__asCalls) {\n      if (typeof propKey === \"symbol\") {\n        this.strbuilder += propKey.toString();\n      } else {\n        // Giordano: add ignore for webpack\n        //@ts-ignore\n        this.strbuilder += (this.strbuilder ? '.' : '') + propKey;\n      }\n    }\n    return GetPathHandler.__nested ? proxyitself : {};\n  }\n  set(target, p, value, proxyitself) {\n    switch (p) {\n      case '__asArray':\n      case '__asCalls':\n      case '__nested':\n        GetPathHandler[p] = value;\n        return true;\n      default:\n        throw new Error('getPath proxy cannot be written');\n    }\n  }\n}, _class8.__asCalls = false, _class8.__asArray = false, _class8.__nested = true, _class8)) || _class7);\nRuntimeAccessibleClass.set_extend(MyProxyHandler, GetPathHandler);\nexport let TargetableProxyHandler = (_dec5 = RuntimeAccessible('TargetableProxyHandler'), _dec5(_class9 = (_class10 = class TargetableProxyHandler extends MyProxyHandler {\n  // permette di fare cose tipo: user.name_surname che ritorna la concatenazione di nome e cognome anche se il campo name_surname non esiste.\n  // to disable type check easily and access 'set_' + varname dynamically\n\n  constructor(d, baseObjInLookup) {\n    let additionalPath = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n    let l = arguments.length > 3 ? arguments[3] : undefined;\n    super();\n    this.lg = void 0;\n    this.l = void 0;\n    this.d = void 0;\n    this.additionalPath = void 0;\n    this.baseObjInLookup = void 0;\n    this.d = d;\n    if (!l) {\n      var _RuntimeAccessibleCla, _RuntimeAccessibleCla2;\n      l = (_RuntimeAccessibleCla = RuntimeAccessibleClass.get(d === null || d === void 0 ? void 0 : d.className)) === null || _RuntimeAccessibleCla === void 0 ? void 0 : (_RuntimeAccessibleCla2 = _RuntimeAccessibleCla.logic) === null || _RuntimeAccessibleCla2 === void 0 ? void 0 : _RuntimeAccessibleCla2.singleton;\n      Log.exDev(!l, 'Trying to wrap class without singleton or logic mapped: ' + (d === null || d === void 0 ? void 0 : d.className), {\n        object: d,\n        className: d.className\n      });\n    }\n    this.baseObjInLookup = baseObjInLookup || d;\n    this.additionalPath = additionalPath;\n    this.l = l;\n    this.lg = this.l;\n    this.className = this.constructor.cname || this.constructor.name;\n  }\n\n  // damiano todo: this does not work\n  concatenableHandler(targetObj, propKey, proxyitself) {\n    //console.log(\"concatenableHandler 1\", {targetObj, propKey, proxyitself});\n    if (propKey in targetObj) return null;\n    const propKeyStr = U.asString(propKey, null);\n    let _index = propKeyStr ? propKeyStr.indexOf('_') : -1;\n    //console.log(\"concatenableHandler 2\", {targetObj, propKey, propKeyStr, proxyitself, _index});\n    if (_index < 0) return null;\n    let isConcatenable = true;\n    let ret = propKey.split('_').map(subKey => {\n      //console.log(\"concatenableHandler 3.0\", {targetObj, subKey, propKeyStr, proxyitself});\n      // se trovo multipli ___ li tratto come spazi aggiuntivi invece che come proprietà '' che ritornano undefined, così posso fare name___surname --> \"damiano   di vincenzo\"\n      let val = subKey === '' ? ' ' : this.get(targetObj, subKey, proxyitself);\n      isConcatenable = isConcatenable && JsType.isPrimitive(val);\n      return val;\n    });\n    //console.log(\"concatenableHandler 4\", {targetObj, propKey, propKeyStr, proxyitself, ret, isConcatenable});\n    return isConcatenable ? ret.join(' ') : ret;\n  }\n  get(targetObj, propKey, proxyitself) {\n    let ret;\n    let isError = false;\n    // console.error('_proxy get PRE:', {targetObj, propKey, proxyitself, arguments});\n    try {\n      ret = this.get0(targetObj, propKey, proxyitself);\n    } catch (e) {\n      ret = e;\n      isError = true;\n    }\n\n    // if (isError) throw ret;\n    // console.error('_proxy get POST:', {targetObj, propKey, ret, isError});\n    return ret;\n  }\n  get0(targetObj, propKey, proxyitself) {\n    // console.log('proxy keysearch', {propKey, targetObj, l: this.l, proxyitself, d: this.d});\n    let canThrowErrors = true;\n    switch (typeof propKey) {\n      case \"symbol\":\n        propKey = String(propKey);\n        switch (propKey) {\n          default:\n            Log.exDevv('unexpected symbol in proxy getter:', propKey);\n            break;\n          case 'Symbol(Symbol.toStringTag)':\n            propKey = 'toString';\n            break;\n          //return (()=>\"[Proxy]\");\n          case \"Symbol(Symbol.toPrimitive)\":\n            propKey = 'toPrimitive';\n            break;\n        }\n        break;\n      // case \"number\": return null;\n    }\n    switch (propKey) {\n      case '__l':\n        return this.l;\n      case '__d':\n        return this.d;\n      case 'inspect': // node.js util\n      case \"r\":\n      case \"_refresh\":\n      case \"_reload\":\n        return LPointerTargetable.wrap(targetObj.id);\n      case '__Raw':\n      case '__raw':\n        return targetObj;\n      case '__serialize':\n        return JSON.stringify(targetObj);\n      case '__isproxy':\n      case '__isProxy':\n        return true;\n      case '__random':\n        return Math.random();\n      case 'editCount':\n      case 'clonedcounter':\n      case 'clonedCounter':\n        return targetObj.clonedCounter || 0;\n      case '$$typeof':\n      case \"typeName\":\n        return this.d.className;\n      case 'parent':\n        propKey = 'father';\n        break;\n    }\n    if (propKey[0] === \"_\" && propKey.indexOf(\"__info_of__\") === 0) {\n      return this.l[propKey];\n    }\n\n    // check if exist directly in D.key, L.key or through a get_key\n    if (propKey in this.l || propKey in this.d || this.l[this.g + propKey]) {\n      // todo: il LogicContext passato come parametro risulta nell'autocompletion editor automaticamente generato, come passo un parametro senza passargli il parametro? uso arguments senza dichiararlo?\n      if (typeof propKey !== 'symbol' && this.g + propKey in this.lg) return this.lg[this.g + propKey](new LogicContext(proxyitself, targetObj));\n\n      // if specific custom getter exist\n      if (typeof propKey !== 'symbol' && this.g + propKey in this.lg) {\n        let getterMethod = this.lg[this.g + propKey]; // || this.defaultGetter;\n        // console.log(\"gets method\", {getterMethod, lg:this.lg, thiss: this});\n        if (getterMethod) return getterMethod(new LogicContext(proxyitself, targetObj));\n      }\n    }\n    // @ts-ignore\n    //console.trace(\"proxy $getter 2\", {targetObj, n:targetObj.name, propKey, l:this.lg, dg:this.lg._defaultGetter});\n\n    // if custom generic getter exist\n    // @ts-ignore\n    if (this.lg._defaultGetter) return this.lg._defaultGetter(new LogicContext(proxyitself, targetObj), propKey);\n\n    // if property do not exist, try a concatenation\n    /*let concatenationTentative = null;\r\n    try {concatenationTentative = this.concatenableHandler(targetObj, propKey, proxyitself); } catch(e) {}\r\n    if (concatenationTentative !== null) return concatenationTentative;\r\n    */\n    Log.e(canThrowErrors, 'GET property \"' + propKey + '\" do not exist in object of type \"' + U.getType(this.l) + \" DType:\" + U.getType(this.d), {\n      data: targetObj\n    });\n    return undefined;\n    // todo: credo che con espressioni sui tipi siano tipizzabili tutti i return di proprietà note eccetto quelle ottenute per concatenazione.\n  }\n  defaultGetter(targetObj, key, proxyitself) {\n    if (!targetObj) return targetObj;\n    if (!targetObj._subMaps || !targetObj._subMaps[key]) return targetObj[key];\n    // if is a nexted subobject\n    let context = new MapLogicContext(proxyitself, targetObj, key, []);\n    let retRaw = this.lg[this.s + key];\n    return MapProxyHandler.mapWrap(targetObj[key], targetObj, this.additionalPath + '.' + key);\n  }\n  defaultSetter(targetObj, propKey, value, proxyitself) {\n    SetFieldAction.new(targetObj, propKey, value);\n    return true;\n  }\n  set(targetObj, propKey, value, proxyitself) {\n    // console.error('_proxy set PRE:', {targetObj, propKey, value, proxyitself, arguments});\n    // if (propKey in this.l || propKey in this.d || (this.l as GObject)[this.s + (propKey as string)] || (this.l as GObject)[(propKey as string)]) {\n\n    switch (typeof propKey) {\n      case \"symbol\":\n        propKey = String(propKey);\n        Log.exDevv('unexpected symbol in proxy setter:', propKey);\n        break;\n      default:\n        break;\n    }\n    switch (propKey) {\n      case 'parent':\n        propKey = 'father';\n        break;\n    }\n    if (propKey in this.l || propKey in this.d || this.l[this.s + propKey]) {\n      // todo: il LogicContext passato come parametro risulta nell'autocompletion editor automaticamente generato, come passo un parametro senza passargli il parametro? uso arguments senza dichiararlo?\n      if (typeof propKey !== 'symbol' && this.s + propKey in this.lg) {\n        this.lg[this.s + propKey](value, new LogicContext(proxyitself, targetObj));\n        return true;\n      }\n\n      // if custom generic setter exist\n      // @ts-ignore\n      //if (this.lg._defaultSetter) return this.lg._defaultSetter(value, new LogicContext(proxyitself as any, targetObj), propKey);\n\n      // se esiste la proprietà ma non esiste il setter, che fare? do errore.\n      // Log.eDevv(\"dev error: property exist but setter does not: \", propKey, this);\n      // return false;\n    }\n    // if property do not exist\n\n    // if custom generic setter exist\n    // @ts-ignore private property\n    if (this.lg._defaultSetter) {\n      this.lg._defaultSetter(value, new LogicContext(proxyitself, targetObj), propKey);\n      return true;\n    }\n    /*if (enableFallbackSetter && typeof (propKey === \"string\") && ((propKey as string)[0] === '_' || (propKey as string).indexOf('tmp') > 0)) {\r\n        return this.defaultSetter(targetObj as any as DPointerTargetable, propKey as string, value, proxyitself);\r\n        // new SetFieldAction(new LogicContext(proxyitself as any, targetObj).data as any, propKey as string, value); return true;\r\n    }*/\n    let canThrowErrors = true;\n    Log.ex(canThrowErrors, 'SET property \"set_' + propKey + '\" do not exist in object of type \"' + U.getType(this.l) + \" DType:\" + U.getType(this.l), {\n      'this': this,\n      targetObj\n    });\n    return false;\n  }\n  /*      problema: ogni oggetto deve avere multipli puntatori, quando ne modifico uno devo modificarli tutti, come tengo traccia?\r\n          ipotesi 1: lo memorizzo in un solo posto (store.idlookup) e uso Pointer<type, lb, ub> che è una stringa che simula un puntatore\r\n          problema 1: se fornisco l'intero store ai componenti si aggiornano ad ogni singola modifica, se estraggo i campi interesasti le stringhe puntatore sono invariate ma il contenuto puntato è cambiato e il componente non lo sa...\r\n          problemone 2: non so a quali proprietà dello store devo abbonarmi, devo leggere sempre tutto lo store?\r\n          !!!!! soluzione 2?: dovrei dichiarare le variabili a cui mi abbono, salvarle nello stato e precaricarle tramite mapStateToProps*/\n\n  deleteProperty(target, key, proxyItself) {\n    if (typeof key === \"symbol\") return false;\n    this.set(target, key, undefined, proxyItself);\n    delete target[key];\n    return true;\n  }\n  mergedObject(target) {\n    let ret = {\n      ...target\n    }; // U.arrayMergeInPlace(Object.keys(target), Object.keys(this.l).filter(k => k.indexOf('set_') !== 0 && k.indexOf('get_') !== 0));\n    for (let k in this.l) {\n      if (!(k in ret) && k.lastIndexOf('get_', 4) !== 0 && k.lastIndexOf('set_', 4) !== 0) ret[k] = true;\n    }\n    return ret;\n  }\n  ownKeys(target) {\n    const ret = this.mergedObject(target);\n    // ret = Reflect.ownKeys(ret);\n    return Reflect.ownKeys(ret);\n  }\n\n  // has(target: ME, p: string | symbol): boolean { return p in this.mergedObject(target); }\n  has(target, p) {\n    return p in target || p in this.l;\n  }\n\n  /*\r\n  apply(target: DModelElement, thisArg: any, argArray: any[]): any {\r\n      // will i ever use it? dovrei pasare una funzione invece di una classe, quindi in questo caso credo wrappi solo il costruttore\r\n  }*/\n}, _class10.childKeys = {\n  '$': true,\n  '@': true\n}, _class10)) || _class9);\nRuntimeAccessibleClass.set_extend(MyProxyHandler, TargetableProxyHandler);\nexport let MapProxyHandler = (_dec6 = RuntimeAccessible('MapProxyHandler'), _dec6(_class11 = class MapProxyHandler extends TargetableProxyHandler {\n  // todo: sposta alcune funzioni da TargetableProxy a MyProxy e fai estendere direttamente MyProxy a questa classe\n\n  constructor(d, baseObjInLookup) {\n    let additionalPath = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n    let subMapKeys = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    super(d, baseObjInLookup, additionalPath, LPointerTargetable.singleton);\n    this.subMapKeys = void 0;\n    this.subMapKeys = subMapKeys;\n  }\n  get(target, key, proxyitself) {\n    if (typeof key === \"symbol\") return this.d[key];\n    let val = this.d[key];\n    if (key in this.subMapKeys && !(key in target)) {\n      Log.exx('property not found in dictionary', {\n        target,\n        key,\n        thiss: this,\n        proxyitself,\n        submapkeys: this.subMapKeys\n      });\n      return undefined;\n    }\n    if (key in this.subMapKeys) {\n      this.additionalPath += '.';\n      return MapProxyHandler.mapWrap(this.d, this.baseObjInLookup, this.additionalPath, this.subMapKeys[key]);\n      Log.exDevv('todo: wrap sub-map', {\n        thiss: this\n      });\n    }\n    return target[key];\n  }\n  set(target, key, value, proxyitself) {\n    if (typeof key === \"symbol\") {\n      Log.exx('cannot set a symbol in dictionary', {\n        target,\n        key,\n        value,\n        proxyitself\n      });\n      return false;\n    }\n    SetRootFieldAction.new(this.additionalPath + '.' + key, value, '', false);\n    return true;\n  }\n  deleteProperty(target, key, proxyItself) {\n    if (typeof key === \"symbol\") return false;\n    this.set(target, key, undefined, proxyItself);\n    delete target[key];\n    return true;\n  }\n}) || _class11);\nRuntimeAccessibleClass.set_extend(MyProxyHandler, MapProxyHandler);\n// 15-20 min + 5 di domande entro il 1° ottobre, discussione 10-12 ottobre\nexport const getPath = new Proxy({}, new GetPathHandler());\nwindow.getPath = getPath;\n// usage: pathstring = ((getPath as DType).some.path.to.follow as any).$; // = \"some.path.to.follow\" with compilation-time validation","map":{"version":3,"names":["DPointerTargetable","JsType","Log","LPointerTargetable","RuntimeAccessible","RuntimeAccessibleClass","SetFieldAction","SetRootFieldAction","U","childrenKeys","LogicContext","_dec","_class","constructor","proxyObject","data","write","className","cname","name","set_extend","MapLogicContext","_dec2","_class3","proxy","path","subMaps","arguments","length","undefined","MyProxyHandler","_dec3","_class5","s","g","set","target","p","value","proxyitself","Error","deleteProperty","ownKeys","console","log","thiss","ret","Reflect","wrap","baseObjInLookup","canThrow","isProxy","__isProxy","GetPathHandler","_dec4","_class7","_class8","strbuilder","array","calls","get","targetObj","propKey","__asCalls","__asArray","push","Symbol","toPrimitive","_len","a","Array","_key","toString","__nested","TargetableProxyHandler","_dec5","_class9","_class10","d","additionalPath","l","lg","_RuntimeAccessibleCla","_RuntimeAccessibleCla2","logic","singleton","exDev","object","concatenableHandler","propKeyStr","asString","_index","indexOf","isConcatenable","split","map","subKey","val","isPrimitive","join","isError","get0","e","canThrowErrors","String","exDevv","id","JSON","stringify","Math","random","clonedCounter","getterMethod","_defaultGetter","getType","defaultGetter","key","_subMaps","context","retRaw","MapProxyHandler","mapWrap","defaultSetter","new","_defaultSetter","ex","proxyItself","mergedObject","k","lastIndexOf","has","childKeys","_dec6","_class11","subMapKeys","exx","submapkeys","getPath","Proxy","window"],"sources":["C:/d/Programming/web/jodel-mde/src/joiner/proxy.ts"],"sourcesContent":["import type {DocString, DtoL, DtoW, GObject, Proxyfied, WPointerTargetable,} from \"../joiner\";\r\nimport {\r\n    Dictionary,\r\n    DModelElement,\r\n    DPointerTargetable,\r\n    JsType,\r\n    LModelElement,\r\n    Log,\r\n    LPointerTargetable,\r\n    Pointer,\r\n    RuntimeAccessible,\r\n    RuntimeAccessibleClass,\r\n    SetFieldAction,\r\n    SetRootFieldAction,\r\n    U\r\n} from \"../joiner\";\r\n\r\ntype NotAConcatenation = null;\r\ntype ERROR = \"_Type_Error_\";\r\n\r\n// (DX extends DUser ? LUser : (DX extends DPointerTargetable ? LPointerTargetable : (ERROR))\r\n// (DX extends DUser ? LUser : (DX extends DPointerTargetable ? LPointerTargetable : (           WViewElement\r\n//\r\n// (IN extends WViewElement ? LViewElement : (IN extends WViewTransientProperties ? LWiewTransientProperties : (ERROR)))\r\n// ))\r\n// type WtoL<WX extends WPointerTargetable> ='';\r\n\r\nconst childrenKeys = [\"@\", \"$\"];\r\n@RuntimeAccessible('LogicContext')\r\nexport class LogicContext<\r\n    DX extends GObject = DModelElement,\r\n    LX = DtoL<DX>,\r\n    // PF extends MyProxyHandler<DX> = MyProxyHandler<DX>,\r\n    WX = DtoW<DX>\r\n    > extends RuntimeAccessibleClass{\r\n    public proxyObject: LX;\r\n    public data: DX;// & GObject;\r\n    public write: WX;\r\n    constructor(proxyObject: LX, data: DX) {\r\n        super();\r\n        this.className = (this.constructor as typeof RuntimeAccessibleClass).cname || this.constructor.name;\r\n        this.data = data;\r\n        this.proxyObject = proxyObject;\r\n        this.write = proxyObject as any;\r\n    }\r\n    /*\r\n        saveToRedux(propkey: \"keyof data\" | string, val: \"typeof data[path]\" | any): void { // todo: ask non stackoverflow\r\n            // todo, put data in redux store, path is \"obj1.obj2.obj3...\" might replace it with a path funciton that return the foremost nested object container\r\n            if (!propkey) {\r\n                // todo: set whole object instead of a property\r\n            }\r\n        }*/\r\n}\r\n\r\nRuntimeAccessibleClass.set_extend(RuntimeAccessibleClass, LogicContext);\r\n@RuntimeAccessible('MapLogicContext')\r\nexport class MapLogicContext extends LogicContext<GObject, LPointerTargetable, WPointerTargetable> {\r\n    data: GObject;\r\n    path: string;\r\n    subMaps: string[];\r\n    constructor(proxy: LPointerTargetable, data: GObject, path: string, subMaps: string[] = []) {\r\n        super(proxy, data);\r\n        // this.proxyfyFunction = proxyfyFunction;\r\n        this.proxyObject = proxy;\r\n        this.data = data;\r\n        this.path = path;\r\n        this.subMaps = subMaps;\r\n        this.className = (this.constructor as typeof RuntimeAccessibleClass).cname || this.constructor.name;\r\n    }\r\n}\r\nRuntimeAccessibleClass.set_extend(LogicContext, MapLogicContext);\r\n\r\n@RuntimeAccessible('MyProxyHandler')\r\nexport abstract class MyProxyHandler<T extends GObject> extends RuntimeAccessibleClass implements ProxyHandler<T>{\r\n    s: string = 'set_';\r\n    g: string = 'get_';\r\n    /*get(target: T, p: string | number | symbol, proxyitself: Proxyfied<T>): boolean {\r\n        switch (p) {\r\n            case '_isProxy': return true;\r\n            case 'init': return (this as any).init;\r\n            case 'init0': return (this as any).init0;\r\n            default: throw new Error('proxy get must be overridden, called for key: ' + (p as string));\r\n        }}*/\r\n    set(target: T, p: string | number | symbol, value: any, proxyitself: Proxyfied<T>): boolean { throw new Error('proxy set must be overridden'); }\r\n    deleteProperty(target: T, p: string | symbol): boolean { throw new Error('proxy delete must be overridden'); }\r\n\r\n    ownKeys(target: T): ArrayLike<string | symbol>{\r\n        // return Object.getOwnPropertyNames(target);\r\n        console.log(\"ownkeys trap 1\", {thiss:this, target})\r\n        console.log(\"ownkeys trap 2\", {thiss:this, target, ret:Reflect.ownKeys(target)});\r\n        return Reflect.ownKeys(target);\r\n    }\r\n    /// proxy methods not used\r\n    /* setPrototypeOf(target: T, v: object | null): boolean { ?? }\r\n    apply(target: T, thisArg: any, argArray: any[]): any { }\r\n    defineProperty(target: T, p: string | symbol, attributes: PropertyDescriptor): boolean { }\r\n    construct(target: T, argArray: any[], newTarget: Function): object { }\r\n    getOwnPropertyDescriptor(target: T, p: string | symbol): PropertyDescriptor | undefined { }\r\n    has(target: T, p: string | symbol): boolean { return p in target; }\r\n    getPrototypeOf(target: T): object | null { }\r\n    isExtensible(target: T): boolean { }\r\n    preventExtensions(target: T): boolean { }*/\r\n\r\n    static wrap<D extends RuntimeAccessibleClass, L extends LPointerTargetable = LPointerTargetable, CAN_THROW extends boolean = false,\r\n        RET extends CAN_THROW extends true ? L : L | undefined  = CAN_THROW extends true ? L : L>\r\n    (data: D | Pointer | undefined | null, baseObjInLookup?: DPointerTargetable, path: string = '', canThrow: CAN_THROW = false as CAN_THROW): RET{\r\n\r\n//    static wrap<D extends RuntimeAccessibleClass, L extends LPointerTargetable, RET extends boolean = false>\r\n//        (data: D | Pointer<DViewElement>, baseObjInLookup?: DPointerTargetable, path: string = '', canthrow: RET = false as RET): RET {\r\n        return DPointerTargetable.wrap(data, baseObjInLookup, path) as RET; }\r\n\r\n    static isProxy(data: GObject): boolean { return data?.__isProxy || false; }\r\n}\r\nRuntimeAccessibleClass.set_extend(RuntimeAccessibleClass, MyProxyHandler);\r\nexport type GetPath<T = GObject> = T;\r\n/*\r\n* handling proxy += and proxy -=\r\n*\r\n* will become var = var + add; which will call Symbol.getPrimitive\r\nconsole.log(+obj2);     // 10        — hint is \"number\"         NaN with +array with multiple vals, +array[0] with array of size 1, NaN with functions & objects\r\nconsole.log(`${obj2}`); // \"hello\"   — hint is \"string\"         array => array.join(','), object => \"[object Object]\", function => function.toString() whole func definition with body code\r\nconsole.log(obj2 + \"\"); // \"true\"    — hint is \"default\"        array, object, function => same as with hint \"string\"\r\n*\r\n* */\r\n\r\n// NB: lclass.extends += somepointer will become: lclass.extends = lclass.extends + somepointer;\r\n// array + string will cause getPrimitive(\"default\") to array, then .join(',') on it, and finally and toString() to be called on all array members.\r\n// so pointers cannot include \",\" char and toString() must return a pointer to keep lclass.extends += somepointer as a valid expression;\r\n// -= will call getPrimitive(\"number\") which will result in array -> NaN, so NaN = NaN - pointer and cannot be done.\r\n// or maybe it can because if getPrimitive fails it calls toString as fallback, and viceversa\r\n\r\n@RuntimeAccessible('GetPathHandler')\r\nclass GetPathHandler<T extends GObject> extends MyProxyHandler<T>{\r\n    public static __asCalls: boolean = false;\r\n    public static __asArray: boolean = false;\r\n    public static __nested: boolean = true;\r\n    private strbuilder: string = '';\r\n    private array: (string | number | symbol)[] = [];\r\n    private calls: (GObject<'parameters of get calls'>)[] = [];\r\n\r\n    public constructor() { super(); }\r\n\r\n    get(targetObj: T, propKey: keyof T | string, proxyitself: Proxyfied<T>): any {\r\n        // console.log('GetPathHandler', {targetObj, propKey, proxyitself});\r\n        if (propKey === \"start\") { this.strbuilder = ''; this.array = []; }\r\n        if (propKey === '$') {\r\n            const ret = GetPathHandler.__asCalls ? this.calls : (GetPathHandler.__asArray ? this.array : this.strbuilder);\r\n            this.array = [];\r\n            this.strbuilder = '';\r\n            return ret; }\r\n        this.array.push(propKey);\r\n        this.calls.push(arguments);\r\n        if (propKey === Symbol.toPrimitive) {\r\n            console.log(\"toprimitive\");\r\n            return (...a: any)=> {console.log(\"toprimitive called with parameters\", a); }\r\n        }\r\n        if (!GetPathHandler.__asArray && !GetPathHandler.__asCalls) {\r\n            if (typeof propKey === \"symbol\") { this.strbuilder += propKey.toString(); }\r\n            else {\r\n                // Giordano: add ignore for webpack\r\n                //@ts-ignore\r\n                this.strbuilder += (this.strbuilder ? '.' : '') + propKey;\r\n            }\r\n        }\r\n        return GetPathHandler.__nested ? proxyitself : {};\r\n    }\r\n\r\n    set(target: T, p: string | number | symbol, value: any, proxyitself: Proxyfied<T>): boolean {\r\n        switch(p){\r\n            case '__asArray':\r\n            case '__asCalls':\r\n            case '__nested':\r\n                (GetPathHandler as any)[p] = value;\r\n                return true;\r\n            default:\r\n                throw new Error('getPath proxy cannot be written');\r\n        }\r\n    }\r\n}\r\nRuntimeAccessibleClass.set_extend(MyProxyHandler, GetPathHandler);\r\n@RuntimeAccessible('TargetableProxyHandler')\r\nexport class TargetableProxyHandler<ME extends GObject = DModelElement, LE extends LPointerTargetable = LModelElement> extends MyProxyHandler<ME> {\r\n// permette di fare cose tipo: user.name_surname che ritorna la concatenazione di nome e cognome anche se il campo name_surname non esiste.\r\n    lg: LE & GObject; // to disable type check easily and access 'set_' + varname dynamically\r\n    l: LE;\r\n    d: ME;\r\n    additionalPath: string;\r\n\r\n    public baseObjInLookup: DPointerTargetable;\r\n    static childKeys: Dictionary<string, true> = {'$': true, '@': true};\r\n\r\n    constructor(d: ME, baseObjInLookup?: DPointerTargetable, additionalPath: string = '', l?: LE) {\r\n        super();\r\n        this.d = d;\r\n        if (!l) {\r\n            l = RuntimeAccessibleClass.get(d?.className)?.logic?.singleton as LE;\r\n            Log.exDev(!l, 'Trying to wrap class without singleton or logic mapped: ' + d?.className, { object: d, className: d.className })\r\n        }\r\n        this.baseObjInLookup = baseObjInLookup || d as any;\r\n        this.additionalPath = additionalPath;\r\n        this.l = l as LE;\r\n        this.lg = this.l;\r\n        this.className = (this.constructor as typeof RuntimeAccessibleClass).cname || this.constructor.name;\r\n    }\r\n\r\n    // damiano todo: this does not work\r\n    private concatenableHandler(targetObj: ME, propKey: number | string | symbol, proxyitself: Proxyfied<ME>): NotAConcatenation | any[] | string {\r\n        //console.log(\"concatenableHandler 1\", {targetObj, propKey, proxyitself});\r\n        if (propKey in targetObj)  return null as NotAConcatenation;\r\n        const propKeyStr: null | string = U.asString(propKey, null);\r\n        let _index: number = propKeyStr ? propKeyStr.indexOf('_') : -1;\r\n        //console.log(\"concatenableHandler 2\", {targetObj, propKey, propKeyStr, proxyitself, _index});\r\n        if (_index < 0) return null as NotAConcatenation;\r\n\r\n        let isConcatenable = true;\r\n        let ret: any[] = (propKey as string).split('_').map( (subKey: string) => {\r\n            //console.log(\"concatenableHandler 3.0\", {targetObj, subKey, propKeyStr, proxyitself});\r\n            // se trovo multipli ___ li tratto come spazi aggiuntivi invece che come proprietà '' che ritornano undefined, così posso fare name___surname --> \"damiano   di vincenzo\"\r\n            let val: any = subKey === '' ? ' ' : this.get(targetObj, subKey, proxyitself);\r\n            isConcatenable = isConcatenable && JsType.isPrimitive(val);\r\n            return val;\r\n        });\r\n        //console.log(\"concatenableHandler 4\", {targetObj, propKey, propKeyStr, proxyitself, ret, isConcatenable});\r\n        return isConcatenable ? ret.join(' ') : ret; }\r\n\r\n    public get(targetObj: ME, propKey: string | symbol, proxyitself: Proxyfied<ME>): any {\r\n        let ret;\r\n        let isError = false;\r\n        // console.error('_proxy get PRE:', {targetObj, propKey, proxyitself, arguments});\r\n        try { ret = this.get0(targetObj, propKey, proxyitself); } catch(e) { ret = e; isError = true;}\r\n\r\n        // if (isError) throw ret;\r\n        // console.error('_proxy get POST:', {targetObj, propKey, ret, isError});\r\n        return ret;\r\n    }\r\n\r\n    public get0(targetObj: ME, propKey: string | symbol, proxyitself: Proxyfied<ME>): any {\r\n        // console.log('proxy keysearch', {propKey, targetObj, l: this.l, proxyitself, d: this.d});\r\n        let canThrowErrors = true;\r\n\r\n        switch(typeof propKey) {\r\n            case \"symbol\":\r\n                propKey = String(propKey);\r\n                switch (propKey) {\r\n                    default: Log.exDevv('unexpected symbol in proxy getter:', propKey); break;\r\n                    case 'Symbol(Symbol.toStringTag)': propKey = 'toString'; break; //return (()=>\"[Proxy]\");\r\n                    case \"Symbol(Symbol.toPrimitive)\": propKey = 'toPrimitive'; break;\r\n                }\r\n                break;\r\n            // case \"number\": return null;\r\n        }\r\n\r\n        switch (propKey) {\r\n            case '__l': return this.l;\r\n            case '__d': return this.d;\r\n            case 'inspect': // node.js util\r\n            case \"r\":\r\n            case \"_refresh\":\r\n            case \"_reload\": return LPointerTargetable.wrap(targetObj.id);\r\n            case '__Raw':\r\n            case '__raw': return targetObj;\r\n            case '__serialize': return JSON.stringify(targetObj);\r\n            case '__isproxy':\r\n            case '__isProxy': return true;\r\n            case '__random': return Math.random();\r\n            case 'editCount':\r\n            case 'clonedcounter':\r\n            case 'clonedCounter':\r\n                return targetObj.clonedCounter || 0;\r\n            case '$$typeof':\r\n            case \"typeName\":\r\n                return this.d.className;\r\n            case 'parent': propKey = 'father'; break;\r\n        }\r\n        if (propKey[0] === \"_\" && propKey.indexOf(\"__info_of__\")===0) {\r\n            return (this.l as GObject)[propKey];\r\n        }\r\n\r\n\r\n        // check if exist directly in D.key, L.key or through a get_key\r\n        if (propKey in this.l || propKey in this.d || (this.l as GObject)[this.g + (propKey as string)]) {\r\n            // todo: il LogicContext passato come parametro risulta nell'autocompletion editor automaticamente generato, come passo un parametro senza passargli il parametro? uso arguments senza dichiararlo?\r\n            if (typeof propKey !== 'symbol' && this.g + propKey in this.lg) return this.lg[this.g + propKey](new LogicContext(proxyitself as any, targetObj));\r\n\r\n\r\n\r\n            // if specific custom getter exist\r\n            if (typeof propKey !== 'symbol' && this.g + propKey in this.lg) {\r\n                let getterMethod: Function = this.lg[this.g + propKey]; // || this.defaultGetter;\r\n                // console.log(\"gets method\", {getterMethod, lg:this.lg, thiss: this});\r\n                if (getterMethod) return getterMethod(new LogicContext(proxyitself as any, targetObj));\r\n            }\r\n\r\n        }\r\n        // @ts-ignore\r\n        //console.trace(\"proxy $getter 2\", {targetObj, n:targetObj.name, propKey, l:this.lg, dg:this.lg._defaultGetter});\r\n\r\n\r\n        // if custom generic getter exist\r\n        // @ts-ignore\r\n        if (this.lg._defaultGetter) return this.lg._defaultGetter(new LogicContext(proxyitself as any, targetObj), propKey);\r\n\r\n        // if property do not exist, try a concatenation\r\n        /*let concatenationTentative = null;\r\n        try {concatenationTentative = this.concatenableHandler(targetObj, propKey, proxyitself); } catch(e) {}\r\n        if (concatenationTentative !== null) return concatenationTentative;\r\n        */\r\n        Log.e(canThrowErrors, 'GET property \"'+ (propKey as any)+ '\" do not exist in object of type \"' + U.getType(this.l) + \" DType:\" +  U.getType(this.d), {data: targetObj});\r\n        return undefined;\r\n        // todo: credo che con espressioni sui tipi siano tipizzabili tutti i return di proprietà note eccetto quelle ottenute per concatenazione.\r\n    }\r\n\r\n    public defaultGetter(targetObj: ME, key: string, proxyitself: Proxyfied<ME>): any {\r\n        if (!targetObj) return targetObj;\r\n        if (!targetObj._subMaps || !targetObj._subMaps[key]) return (targetObj as Dictionary)[key];\r\n        // if is a nexted subobject\r\n        let context: MapLogicContext = new MapLogicContext(proxyitself as any, targetObj, key, []);\r\n        let retRaw: Dictionary = this.lg[this.s + key]\r\n        return MapProxyHandler.mapWrap((targetObj as Dictionary)[key], targetObj as any, this.additionalPath + '.' + key)\r\n    }\r\n\r\n    public defaultSetter(targetObj: DPointerTargetable, propKey: string, value: any, proxyitself?: Proxyfied<ME>): boolean {\r\n        SetFieldAction.new(targetObj, propKey as any, value);\r\n        return true;\r\n    }\r\n\r\n    public set(targetObj: ME, propKey: string | symbol, value: any, proxyitself?: Proxyfied<ME>): boolean {\r\n        // console.error('_proxy set PRE:', {targetObj, propKey, value, proxyitself, arguments});\r\n        // if (propKey in this.l || propKey in this.d || (this.l as GObject)[this.s + (propKey as string)] || (this.l as GObject)[(propKey as string)]) {\r\n\r\n        switch (typeof propKey) {\r\n            case \"symbol\":\r\n                propKey = String(propKey);\r\n                Log.exDevv('unexpected symbol in proxy setter:', propKey);\r\n                break;\r\n            default: break;\r\n        }\r\n\r\n        switch (propKey) {\r\n            case 'parent': propKey = 'father'; break;\r\n        }\r\n\r\n        if (propKey in this.l || propKey in this.d || (this.l as GObject)[this.s + (propKey as string)]) {\r\n            // todo: il LogicContext passato come parametro risulta nell'autocompletion editor automaticamente generato, come passo un parametro senza passargli il parametro? uso arguments senza dichiararlo?\r\n            if (typeof propKey !== 'symbol' && this.s + propKey in this.lg) {\r\n                this.lg[this.s + propKey](value, new LogicContext(proxyitself as any, targetObj));\r\n                return true;\r\n            }\r\n\r\n\r\n\r\n            // if custom generic setter exist\r\n            // @ts-ignore\r\n            //if (this.lg._defaultSetter) return this.lg._defaultSetter(value, new LogicContext(proxyitself as any, targetObj), propKey);\r\n\r\n            // se esiste la proprietà ma non esiste il setter, che fare? do errore.\r\n            // Log.eDevv(\"dev error: property exist but setter does not: \", propKey, this);\r\n            // return false;\r\n        }\r\n        // if property do not exist\r\n\r\n        // if custom generic setter exist\r\n        // @ts-ignore private property\r\n        if (this.lg._defaultSetter) { this.lg._defaultSetter(value, new LogicContext(proxyitself as any, targetObj), propKey);\r\n            return true;\r\n        }\r\n        /*if (enableFallbackSetter && typeof (propKey === \"string\") && ((propKey as string)[0] === '_' || (propKey as string).indexOf('tmp') > 0)) {\r\n            return this.defaultSetter(targetObj as any as DPointerTargetable, propKey as string, value, proxyitself);\r\n            // new SetFieldAction(new LogicContext(proxyitself as any, targetObj).data as any, propKey as string, value); return true;\r\n        }*/\r\n        let canThrowErrors = true;\r\n        Log.ex(canThrowErrors,'SET property \"set_' + (propKey as any) + '\" do not exist in object of type \"' + U.getType(this.l) + \" DType:\" +  U.getType(this.l), {'this': this, targetObj});\r\n        return false; }\r\n    /*      problema: ogni oggetto deve avere multipli puntatori, quando ne modifico uno devo modificarli tutti, come tengo traccia?\r\n            ipotesi 1: lo memorizzo in un solo posto (store.idlookup) e uso Pointer<type, lb, ub> che è una stringa che simula un puntatore\r\n            problema 1: se fornisco l'intero store ai componenti si aggiornano ad ogni singola modifica, se estraggo i campi interesasti le stringhe puntatore sono invariate ma il contenuto puntato è cambiato e il componente non lo sa...\r\n            problemone 2: non so a quali proprietà dello store devo abbonarmi, devo leggere sempre tutto lo store?\r\n            !!!!! soluzione 2?: dovrei dichiarare le variabili a cui mi abbono, salvarle nello stato e precaricarle tramite mapStateToProps*/\r\n\r\n    public deleteProperty(target: ME, key: string | symbol, proxyItself?: Proxyfied<any>): boolean {\r\n        if (typeof key === \"symbol\") return false;\r\n        this.set(target, key, undefined, proxyItself);\r\n        delete target[key];\r\n        return true; }\r\n\r\n    private mergedObject(target: ME): GObject{\r\n        let ret: GObject = {...target}; // U.arrayMergeInPlace(Object.keys(target), Object.keys(this.l).filter(k => k.indexOf('set_') !== 0 && k.indexOf('get_') !== 0));\r\n        for (let k in this.l) {\r\n            if (!(k in ret) && k.lastIndexOf('get_', 4) !== 0 && k.lastIndexOf('set_', 4) !== 0) ret[k] = true;\r\n        }\r\n        return ret;\r\n    }\r\n    ownKeys(target: ME): ArrayLike<string | symbol>{\r\n        const ret: GObject = this.mergedObject(target);\r\n        // ret = Reflect.ownKeys(ret);\r\n        return Reflect.ownKeys(ret);\r\n    }\r\n\r\n    // has(target: ME, p: string | symbol): boolean { return p in this.mergedObject(target); }\r\n    has(target: ME, p: string | symbol): boolean { return (p in target) || (p in this.l); }\r\n\r\n    /*\r\n    apply(target: DModelElement, thisArg: any, argArray: any[]): any {\r\n        // will i ever use it? dovrei pasare una funzione invece di una classe, quindi in questo caso credo wrappi solo il costruttore\r\n    }*/\r\n}\r\nRuntimeAccessibleClass.set_extend(MyProxyHandler, TargetableProxyHandler);\r\n@RuntimeAccessible('MapProxyHandler')\r\nexport class MapProxyHandler extends TargetableProxyHandler<Dictionary, LPointerTargetable> {\r\n    // todo: sposta alcune funzioni da TargetableProxy a MyProxy e fai estendere direttamente MyProxy a questa classe\r\n    public subMapKeys: Dictionary<string, any | Dictionary<DocString<'nested map keys'>>>;\r\n\r\n    constructor(d: Dictionary, baseObjInLookup: DPointerTargetable, additionalPath: string = '', subMapKeys: Dictionary<string, any | Dictionary<DocString<'nested map keys'>>> = {}) {\r\n        super(d, baseObjInLookup, additionalPath, LPointerTargetable.singleton);\r\n        this.subMapKeys = subMapKeys;\r\n    }\r\n\r\n    get(target: Dictionary, key: string | number | symbol, proxyitself: Proxyfied<Dictionary>): any {\r\n        if (typeof key === \"symbol\") return this.d[key as any];\r\n        let val: any = this.d[key];\r\n        if (key in this.subMapKeys && !(key in target)) { Log.exx('property not found in dictionary', {target, key, thiss:this, proxyitself, submapkeys: this.subMapKeys}); return undefined; }\r\n        if (key in this.subMapKeys) {\r\n            this.additionalPath += '.';\r\n            return MapProxyHandler.mapWrap( this.d, this.baseObjInLookup, this.additionalPath, this.subMapKeys[key]);\r\n            Log.exDevv('todo: wrap sub-map', {thiss: this});\r\n        }\r\n        return target[key as string]; }\r\n\r\n    set(target: Dictionary, key: string | number | symbol, value: any, proxyitself: Proxyfied<Dictionary>): boolean {\r\n        if (typeof key === \"symbol\") { Log.exx('cannot set a symbol in dictionary', {target, key, value, proxyitself}); return false; }\r\n        SetRootFieldAction.new(this.additionalPath + '.' + key, value, '',false)\r\n        return true;\r\n    }\r\n\r\n    public deleteProperty(target: Dictionary, key: string | symbol, proxyItself?: Proxyfied<any>): boolean {\r\n        if (typeof key === \"symbol\") return false;\r\n        this.set(target, key, undefined, proxyItself);\r\n        delete target[key];\r\n        return true; }\r\n}\r\nRuntimeAccessibleClass.set_extend(MyProxyHandler, MapProxyHandler);\r\n// 15-20 min + 5 di domande entro il 1° ottobre, discussione 10-12 ottobre\r\nexport const getPath: GetPath = new Proxy( {}, new GetPathHandler());\r\n(window as any).getPath = getPath;\r\n// usage: pathstring = ((getPath as DType).some.path.to.follow as any).$; // = \"some.path.to.follow\" with compilation-time validation\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}