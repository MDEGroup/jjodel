{"ast":null,"code":"import _get from\"C:/d/Programming/web/jodel-mde/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/get\";import _getPrototypeOf from\"C:/d/Programming/web/jodel-mde/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";import _objectSpread from\"C:/d/Programming/web/jodel-mde/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2\";import _createForOfIteratorHelper from\"C:/d/Programming/web/jodel-mde/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";import _toConsumableArray from\"C:/d/Programming/web/jodel-mde/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";import _classCallCheck from\"C:/d/Programming/web/jodel-mde/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";import _createClass from\"C:/d/Programming/web/jodel-mde/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";import _inherits from\"C:/d/Programming/web/jodel-mde/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";import _createSuper from\"C:/d/Programming/web/jodel-mde/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";var _dec,_class,_class2,_dec2,_class3,_class4,_dec3,_class5,_class6,_dec4,_class7,_class8,_dec5,_class9,_class10,_dec6,_class11,_class12,_dec7,_class13,_class14,_dec8,_class15,_class16,_dec9,_class17,_class18,_dec10,_class19,_class20,_dec11,_class21,_class22,_dec12,_class23,_class24,_dec13,_class25,_class26,_dec14,_class27,_dec15,_class29,_class30,_dec16,_class31,_class32,_dec17,_class33,_class34,_dec18,_class35,_class36,_dec19,_class37,_class38,_dec20,_class39,_class40,_dec21,_class41,_class42;// import {Mixin} from \"ts-mixer\";\nimport{isDeepStrictEqual}from\"util\";import{BEGIN,Constructors,CoordinateMode,Debug,DModelElement,DPointerTargetable,DUser,EdgeBendingMode,END,GraphElementComponent,GraphPoint,GraphSize,Leaf,Log,LPointerTargetable,MixOnlyFuncs,Node,Point,Pointers,RuntimeAccessible,RuntimeAccessibleClass,SetFieldAction,ShortAttribETypes,Size,store,TargetableProxyHandler,transientProperties,U,Uarr,windoww}from\"../../joiner\";import{EdgeGapMode}from\"../../joiner/types\";import{Geom}from\"../../common/Geom\";import{jsx as _jsx}from\"react/jsx-runtime\";import{jsxs as _jsxs}from\"react/jsx-runtime\";console.warn('ts loading graphDataElement');export var DGraphElement=(_dec=RuntimeAccessible('DGraphElement'),Node(_class=_dec(_class=(_class2=/*#__PURE__*/function(_DPointerTargetable){_inherits(DGraphElement,_DPointerTargetable);var _super=_createSuper(DGraphElement);function DGraphElement(){var _this;_classCallCheck(this,DGraphElement);for(var _len=arguments.length,args=new Array(_len),_key=0;_key<_len;_key++){args[_key]=arguments[_key];}_this=_super.call.apply(_super,[this].concat(args));_this.id=void 0;_this.graph=void 0;_this.model=void 0;_this.isSelected=void 0;_this.subElements=void 0;_this.state=void 0;_this.father=void 0;_this.x=void 0;_this.y=void 0;_this.zIndex=100;_this.w=void 0;_this.h=void 0;_this.view=void 0;_this.favoriteNode=void 0;_this.edgesIn=void 0;_this.edgesOut=void 0;_this.anchors=void 0;return _this;}// static _super = DPointerTargetable;\n// static singleton: LGraphElement;\n// static logic: typeof LGraphElement;\n// static structure: typeof DGraphElement;\n// containedIn!: Pointer<DGraphElement, 0, 1, LGraphElement>;\n// DMap\n// width: number = 300;\n// height: number = 400;\n_createClass(DGraphElement,null,[{key:\"new\",value:function _new(htmlindex,model,parentNodeID,graphID,nodeID,a,b){return new Constructors(new DGraphElement('dwc'),parentNodeID,true,undefined,nodeID).DPointerTargetable().DGraphElement(model,graphID,htmlindex).end();}}]);return DGraphElement;}(DPointerTargetable),_class2.subclasses=[],_class2._extends=[],_class2))||_class)||_class);export var LGraphElement=(_dec2=RuntimeAccessible('LGraphElement'),_dec2(_class3=(_class4=/*#__PURE__*/function(_LPointerTargetable){_inherits(LGraphElement,_LPointerTargetable);var _super2=_createSuper(LGraphElement);function LGraphElement(){var _this2;_classCallCheck(this,LGraphElement);for(var _len2=arguments.length,args=new Array(_len2),_key2=0;_key2<_len2;_key2++){args[_key2]=arguments[_key2];}_this2=_super2.call.apply(_super2,[this].concat(args));_this2.__raw=void 0;_this2.id=void 0;_this2.father=void 0;_this2.graph=void 0;_this2.model=void 0;_this2.subElements=void 0;_this2._state=void 0;_this2.allSubNodes=void 0;_this2.x=void 0;_this2.y=void 0;_this2.width=void 0;_this2.height=void 0;_this2.z=void 0;_this2.zIndex=void 0;_this2.__info_of_z__={type:ShortAttribETypes.EInt,txt:\"alias for zIndex\"};_this2.__info_of_zIndex__={type:ShortAttribETypes.EInt,txt:\"Determine the z-axis priority of the element.<br/>Higher value tende to overlap other elements.<br/>Lower value tends to be on background.\"};_this2.zoom=void 0;_this2.html=void 0;_this2.w=void 0;_this2.h=void 0;_this2.size=void 0;_this2.position=void 0;_this2.htmlSize=void 0;_this2.htmlPosition=void 0;_this2.view=void 0;_this2.component=void 0;_this2.favoriteNode=void 0;_this2.vertex=void 0;_this2.__info__of__vertex={type:\"LVoidVertex\",txt:\"the foremost vertex containing this graphElement, or undefiened.\"};_this2.__info__of__favoriteNode={type:ShortAttribETypes.EBoolean,txt:\"<span>Indicates this is the primarly used (by default) node to refer to a modelling element that might have multiple representations.\"+\"<br> Can be used as favorite target for edges or other.\"};_this2.startPoint=void 0;_this2.endPoint=void 0;_this2.__info_of__startPoint={type:\"GraphPoint\",txt:/*#__PURE__*/_jsxs(\"span\",{children:[\"Where the outgoing edges should start their paths.\",/*#__PURE__*/_jsx(\"br\",{}),\"Obtained by combining anchoring point offset specified in view, before snapping to a Vertex border.\",/*#__PURE__*/_jsx(\"br\",{}),\"Defaults in outer coordinates.\"]})};_this2.__info_of__endPoint={type:\"GraphPoint\",txt:/*#__PURE__*/_jsxs(\"span\",{children:[\"Where the incoming edges should end their paths.\",/*#__PURE__*/_jsx(\"br\",{}),\"Obtained by combining anchoring point offset specified in view, before snapping to a Vertex border.\",/*#__PURE__*/_jsx(\"br\",{}),\"Defaults in outer coordinates.\"]})};_this2.__info_of__graph={type:\"\",txt:\"\"};_this2.innerGraph=void 0;_this2.__info_of__innnerGraph={type:\"\",txt:\"\"};_this2.outerGraph=void 0;_this2.__info_of__outerGraphGraph={type:\"\",txt:\"\"};_this2.__info_of__graphAncestors={type:\"LGraph[]\",txt:\"<span>collection of the stack of Graphs containing the current element where [0] is the most nested graph, and last is root graph.</span>\"};_this2.graphAncestors=void 0;_this2.anchors=void 0;_this2.__info_of__anchors={type:\"Dictionary<string, point>\",txt:/*#__PURE__*/_jsxs(\"div\",{children:[\"A named list of all anchor points where edges are allowed to land or depart from.\",/*#__PURE__*/_jsx(\"br\",{}),\"When writing it must be done in percentages, with the same rules as node.state.\"]})};_this2.edgesIn=void 0;_this2.edgesOut=void 0;_this2.__info_of__edgesIn={type:\"LEdge[]\",txt:/*#__PURE__*/_jsxs(\"div\",{children:[\"Edges incoming into this element. \",/*#__PURE__*/_jsx(\"code\",{children:\"this.edgesOut[i].end\"}),\" always equals to \",/*#__PURE__*/_jsx(\"code\",{children:\"this\"}),\".\"]})};_this2.__info_of__edgesOut={type:\"LEdge[]\",txt:/*#__PURE__*/_jsxs(\"div\",{children:[\"Edges outgoing from this element. \",/*#__PURE__*/_jsx(\"code\",{children:\"this.edgesIn[i].start\"}),\" always equals to \",/*#__PURE__*/_jsx(\"code\",{children:\"this\"}),\".\"]})};_this2.__info_of__edgesStart={type:\"LEdge[]\",txt:/*#__PURE__*/_jsx(\"div\",{children:\"Alias for this.edgesOut\"})};_this2.__info_of__edgesEnd={type:\"LEdge[]\",txt:/*#__PURE__*/_jsx(\"div\",{children:\"Alias for this.edgesIn\"})};_this2.outerSize=void 0;_this2.__info_of__outerSize={type:\"GraphSize\",txt:\"the size of the current element relative to the first (root) graph level.\"};_this2.innerSize=void 0;_this2.__info_of__innerSize={type:\"GraphSize\",txt:\"the size of the current element relative to the last (most nested) graph level.\"};_this2.__info_of__size={type:\"GraphSize\",txt:\"same as innerSize.\"};_this2.assignEdgeAnchor=void 0;_this2.__info_of__assignEdgeAnchor=void 0;_this2.__info_of__isselected={type:\"Dictionary<Pointer<User>, true>\",txt:/*#__PURE__*/_jsxs(\"div\",{children:[\"A map that contains all the users selecting this element as keys, and always true as a value (if present).\",/*#__PURE__*/_jsx(\"br\",{}),\"Edit it through node.select() and node.deselect()\"]})};_this2.__info_of__select={type:\"function(forUser?:Pointer<User>):void\",txt:\"Marks this node as selected by argument user.\"};_this2.__info_of__deselect={type:\"function(forUser?:Pointer<User>):void\",txt:\"Un-marks this node as selected by argument user.\"};_this2.__info_of__toggleSelect={type:\"function(usr?:Pointer<User>):void\",txt:\"Calls this.select(usr) if the node is selected by argument user, this.deselect(usr) otherwise. If omitted, argument \\\"usr\\\" is the current user id.<br>Returns the result of this.isSelected() after the toggle.\"};_this2.__info_of__isSelected={type:\"function(forUser?:Pointer<User>):void\",txt:\"Tells if this node is selected by argument user.\"};return _this2;}_createClass(LGraphElement,[{key:\"get_graph\",value:function get_graph(context){return this.get_innerGraph(context);}},{key:\"get_anchors\",value:function get_anchors(c){return c.data.anchors;}},{key:\"set_anchors\",value:function set_anchors(v,c){if(v!==undefined&&(typeof v!==\"object\"||Array.isArray(v))){Log.ee('cannot set anchors: invalid value provided');return true;}if(v){// if !v it means clear all anchors?\nfor(var ka in v){//for each anchor\nif(!v[ka])continue;if(c.data.anchors[ka]){for(var kk in v[ka]){//for each key within an anchor (x, y, w, h)\n// if i was attempting to set a partial size, complete it with the old size values.\nif(v[ka][kk]===undefined&&c.data.anchors[ka][kk]!==undefined)v[ka][kk]=c.data.anchors[ka][kk];}}if(v[ka].x===undefined||isNaN(v[ka].x))v[ka].x=0.5;if(v[ka].y===undefined||isNaN(v[ka].y))v[ka].y=0.5;// if (v[ka].w === undefined || isNaN(v[ka].w)) v[ka].w = 5;\n// if (v[ka].h === undefined || isNaN(v[ka].h)) v[ka].h = 5;\n}}SetFieldAction.new(c.data,\"anchors\",v,'+=',false);return true;}},{key:\"get_edgesIn\",value:function get_edgesIn(context){return LPointerTargetable.fromArr(context.data.edgesIn);}},{key:\"get_edgesOut\",value:function get_edgesOut(context){return LPointerTargetable.fromArr(context.data.edgesOut);}},{key:\"set_edgesIn\",value:function set_edgesIn(val,c){return SetFieldAction.new(c.data.id,\"edgesIn\",Pointers.fromArr(val),'',true);}},{key:\"set_edgesOut\",value:function set_edgesOut(val,c){return SetFieldAction.new(c.data.id,\"edgesOut\",Pointers.fromArr(val),'',true);}},{key:\"get_edgesStart\",value:function get_edgesStart(context){return this.get_edgesIn(context);}},{key:\"get_edgesEnd\",value:function get_edgesEnd(context){return this.get_edgesOut(context);}},{key:\"set_edgesStart\",value:function set_edgesStart(val,context){return this.set_edgesIn(val,context);}},{key:\"set_edgesEnd\",value:function set_edgesEnd(val,context){return this.set_edgesOut(val,context);}},{key:\"_defaultGetter\",value:function _defaultGetter(c,k){if(k in c.data)return this.__defaultGetter(c,k);// if value not found in node, check in view.\nreturn this.get_view(c)[k];/*let ret: any;\r\n        let view = this.get_view(c);\r\n        try { ret = (view as any)[k] } catch (e) { Log.ee(\"Could not find get_ property \\\"\" + k + \"\\\" in node or view.\", {c, view, k}); return undefined; }\r\n        return ret;*/}},{key:\"_defaultSetter\",value:function _defaultSetter(v,c,k){this.__defaultSetter(v,c,k);return true;}},{key:\"get_graphAncestors\",value:function get_graphAncestors(c){var current=c.proxyObject;var next=current.father;var ret=[];while(next){if(RuntimeAccessibleClass.extends(next.className,DGraph.cname))ret.push(next);if(current.id===next.id)break;current=next;next=next.father;}return ret;}},{key:\"get_outerGraph\",value:function get_outerGraph(context){// todo: this relies on the fact that GraphVertex are not passing their own id to their childrens, but the parent graph id\nreturn TargetableProxyHandler.wrap(context.data.graph);}},{key:\"get_vertex\",value:function get_vertex(context){var lcurrent=LPointerTargetable.fromPointer(context.data.id);var dcurrent=lcurrent.__raw;// iterate parents.\nwhile(dcurrent){switch(dcurrent.className){case DVertex.cname:case DVoidVertex.cname:case DGraphVertex.cname:return lcurrent||LPointerTargetable.fromD(dcurrent);default:if(!dcurrent.father||dcurrent.id===dcurrent.father)return undefined;Log.exDev(!dcurrent.father||dcurrent.id===dcurrent.father,\"node failed to get containing vertex\",context.data,dcurrent,lcurrent);lcurrent=LPointerTargetable.fromPointer(dcurrent.father);dcurrent=lcurrent.__raw;}}return undefined;}},{key:\"get_innerGraph\",value:function get_innerGraph(context){var dcurrent=DPointerTargetable.fromPointer(context.data.father);// if no parent, but it's a graph, return itself.\nif(!dcurrent){dcurrent=context.data;switch(dcurrent.className){case DGraph.cname:case DGraphVertex.cname:return LPointerTargetable.fromD(dcurrent);default:return Log.exDevv(\"root node failed to get containing graph\",{cdata:context.data,dcurrent:dcurrent});}}// if it have a parent, iterate parents.\nwhile(true){var _dcurrent;switch((_dcurrent=dcurrent)===null||_dcurrent===void 0?void 0:_dcurrent.className){case DGraph.cname:case DGraphVertex.cname:return LPointerTargetable.fromD(dcurrent);default:if(!dcurrent.father||dcurrent.id===dcurrent.father){/*switch(dcurrent.className){\r\n                            case DGraph.name:\r\n                            case DGraphVertex.name: return (lcurrent || LPointerTargetable.fromD(dcurrent)) as LGraph;\r\n                            default: */return Log.exDevv(\"node failed to get containing graph\",{cdata:context.data,dcurrent:dcurrent});//}\n}dcurrent=DPointerTargetable.fromPointer(dcurrent.father);}}}// set_x(val: this[\"x\"], context: Context): boolean { SetFieldAction.new(context.data.id, \"x\", val, undefined, false); return true; }\n// get_x(context: Context): this[\"x\"] { return context.data.x; }\n},{key:\"get_x\",value:function get_x(context){return this.get_size(context).x;}},{key:\"set_x\",value:function set_x(val,context){return this.set_size({x:val},context);}},{key:\"get_y\",value:function get_y(context){return this.get_size(context).y;}},{key:\"set_y\",value:function set_y(val,context){return this.set_size({y:val},context);}},{key:\"get_w\",value:function get_w(context){return this.get_size(context).w;}},{key:\"set_w\",value:function set_w(val,context){return this.set_size({w:val},context);}},{key:\"get_h\",value:function get_h(context){return this.get_size(context).h;}},{key:\"set_h\",value:function set_h(val,context){return this.set_size({h:val},context);}},{key:\"get_width\",value:function get_width(context){return this.get_w(context);}},{key:\"set_width\",value:function set_width(val,context){return this.set_w(val,context);}},{key:\"get_height\",value:function get_height(context){return this.get_h(context);}},{key:\"set_height\",value:function set_height(val,context){return this.set_h(val,context);}},{key:\"get_position\",value:function get_position(context){return new GraphPoint(context.data.x,context.data.y);}},{key:\"set_position\",value:function set_position(val,context){BEGIN();SetFieldAction.new(context.data.id,\"x\",val.x,undefined,false);SetFieldAction.new(context.data.id,\"y\",val.y,undefined,false);END();return true;}},{key:\"get_sizeold\",value:function get_sizeold(context){return new GraphSize(context.data.x,context.data.y,context.data.w,context.data.h);}},{key:\"get_component\",value:function get_component(context){// switch(context.data.className) { case DEdgePoint.name: return GraphElementComponent.map[context.data.father]; }\nreturn GraphElementComponent.map[context.data.id];}// get_view(context: Context): this[\"view\"] { return this.get_component(context).props.view; }\n},{key:\"get_view\",value:function get_view(context){var _transientProperties$,_this$get_component;return((_transientProperties$=transientProperties.node[context.data.id])===null||_transientProperties$===void 0?void 0:_transientProperties$.mainView)||LPointerTargetable.from(context.data.view)||((_this$get_component=this.get_component(context))===null||_this$get_component===void 0?void 0:_this$get_component.props.view);}},{key:\"set_view\",value:function set_view(val,context){Log.eDevv(\"node.view is readonly, change it through props or the model\");// let ptr: DGraphElement[\"view\"] = Pointers.from(val as this[\"view\"]);\n// return SetFieldAction.new(context.data.id, \"view\", ptr, '', true);\n}},{key:\"getSize\",value:function getSize(){var outer=arguments.length>0&&arguments[0]!==undefined?arguments[0]:false;var canTriggerSet=arguments.length>1&&arguments[1]!==undefined?arguments[1]:true;return this.wrongAccessMessage(\"getSize()\");}},{key:\"get_getSize\",value:function get_getSize(c){var _this3=this;return function(){var outer=arguments.length>0&&arguments[0]!==undefined?arguments[0]:true;var canTriggerSet=arguments.length>1&&arguments[1]!==undefined?arguments[1]:true;return _this3.get_innerSize(c,canTriggerSet,outer);};}},{key:\"get_outerSize\",value:function get_outerSize(context){var canTriggerSet=arguments.length>1&&arguments[1]!==undefined?arguments[1]:true;return this.get_innerSize(context,canTriggerSet,true);}},{key:\"get_size\",value:function get_size(context){var canTriggerSet=arguments.length>1&&arguments[1]!==undefined?arguments[1]:true;return this.get_innerSize(context,canTriggerSet,false);}},{key:\"get_innerSize\",value:function get_innerSize(context){var canTriggerSet=arguments.length>1&&arguments[1]!==undefined?arguments[1]:true;var outerSize=arguments.length>2&&arguments[2]!==undefined?arguments[2]:false;var r=this.get_innerSize_impl(context,canTriggerSet,outerSize);return new GraphSize(r.x,r.y,r.w,r.h);}},{key:\"get_innerSize_impl\",value:function get_innerSize_impl(context){var _this$get_component2;var canTriggerSet=arguments.length>1&&arguments[1]!==undefined?arguments[1]:true;var outerSize=arguments.length>2&&arguments[2]!==undefined?arguments[2]:false;canTriggerSet=canTriggerSet&&!Debug.lightMode;switch(context.data.className){default:return Log.exDevv(\"unexpected classname in get_size switch: \"+context.data.className);case DEdge.cname:case DVoidEdge.cname:case DGraph.cname:return nosize;// case DField.cname:\ncase DGraphElement.cname:var graph=outerSize?this.get_outerGraph(context):this.get_innerGraph(context);return graph.coord(this.get_htmlSize(context));case DVoidVertex.cname:case DVertex.cname:case DEdgePoint.cname:case DGraphVertex.cname:break;}// low prio todo: memoization in proxy, as long state does not change keep a collection Dictionary[object][key] = returnval. it gets emptied when state is updated.\n// when loading a save, edge segements and edgepoints/nodes are computed before creating the edgepoint component\nvar view=this.get_view(context);// (window as any).retry = ()=>view.getSize(context.data.id);\nvar ret=view.getSize(context.data.id);// (this.props.dataid || this.props.nodeid as string)\n// console.log(\"getSize() from view\", {ret: ret ? {...ret} : ret});\nif(!ret){ret=new GraphSize();ret.x=context.data.x;ret.y=context.data.y;ret.w=context.data.w;ret.h=context.data.h;var def;if(undefined===ret.x){if(!def)def=view.defaultVSize;ret.x=def.x||0;}if(undefined===ret.y){if(!def)def=view.defaultVSize;ret.y=def.y||0;}if(undefined===ret.w){if(!def)def=view.defaultVSize;ret.w=def.w||10;}if(undefined===ret.h){if(!def)def=view.defaultVSize;ret.h=def.h|10;}ret.currentCoordType=context.data.currentCoordType;// console.log(\"getSize() from node merged with defaultVSize\", {ret: ret ? {...ret} : ret});\n}if(context.data.className===DEdgePoint.cname){ret=this.decodePosCoords(context,ret,view);}/*\r\n                if ((context.data as DVoidVertex).isResized) {\r\n                    return ret;\r\n                }*/if(!canTriggerSet){if(outerSize)ret=this.get_outerGraph(context).translateSize(ret,this.get_innerGraph(context));return ret;}var html=(_this$get_component2=this.get_component(context))===null||_this$get_component2===void 0?void 0:_this$get_component2.html;var actualSize=(html===null||html===void 0?void 0:html.current)?Size.of(html.current):{w:0,h:0};var updateSize=false;var isOldElement=context.data.clonedCounter>3;// if w = 0 i don't auto-set it as in first render it has w:0 because is not reredered and not resized.\n// if (canTriggerSet) this.set_size({w:actualSize.w}, context);\nif(view.adaptWidth&&ret.w!==actualSize.w){if(canTriggerSet&&(isOldElement||actualSize.w!==0)){ret.w=actualSize.w;updateSize=true;}}if(view.adaptHeight&&ret.h!==actualSize.h){if(canTriggerSet&&(isOldElement||actualSize.h!==0)){ret.h=actualSize.h;updateSize=true;}}// console.log(\"getSize() from node merged with actualSize\", {ret: {...ret}});\nif(updateSize)this.set_size(ret,context);if(outerSize)ret=this.get_outerGraph(context).translateSize(ret,this.get_innerGraph(context));return ret;}// set_size(size: Partial<this[\"size\"]>, context: Context): boolean {\n},{key:\"set_size\",value:function set_size(size0,c){// console.log(\"setSize(\"+(this.props?.data as any).name+\") thisss\", this);\nif(!size0)return false;var size=size0;var view=this.get_view(c);var testmode=false;if(c.data.className===DEdgePoint.cname&&size.currentCoordType!==CoordinateMode.absolute)size=this.encodePosCoords(c,size,view);if(view.updateSize(c.data.id,size))return true;BEGIN();if(size.x!==c.data.x&&size.x!==undefined)SetFieldAction.new(c.data.id,\"x\",size.x,undefined,false);if(size.y!==c.data.y&&size.y!==undefined)SetFieldAction.new(c.data.id,\"y\",size.y,undefined,false);if(size.w!==c.data.w&&size.w!==undefined)SetFieldAction.new(c.data.id,\"w\",size.w,undefined,false);if(size.h!==c.data.h&&size.h!==undefined)SetFieldAction.new(c.data.id,\"h\",size.h,undefined,false);var epdata=c.data;if(size.currentCoordType!==epdata.currentCoordType&&size.currentCoordType!==undefined)SetFieldAction.new(epdata.id,\"currentCoordType\",size.currentCoordType,undefined,false);END();return true;}},{key:\"get_html\",value:function get_html(c){var component=this.get_component(c);var html=component.html.current;if(html)return html;html=$('[nodeid=\"'+c.data.id+'\"]')[0];if(!html)return undefined;component.html.current=html;return html;}// get_html(context: Context): this[\"html\"] { return $(\"[node-id='\" + context.data.id + \"']\")[0]; }\n},{key:\"set_html\",value:function set_html(val,context){return this.cannotSet(\"set_html(). html is generated through jsx. edit the view instead.\");}},{key:\"get_htmlSize\",value:function get_htmlSize(context){var html=this.get_html(context);return html?Size.of(html):new Size(0,0,0,0);/*\r\n        let graph = this.get_graph(context);\r\n        if (!html) return nosize as any;\r\n        let size = Size.of(html);\r\n        let zoom = graph.zoom;\r\n        size.x /= zoom.x;\r\n        size.y /= zoom.y;\r\n        return size;*/}},{key:\"set_htmlSize\",value:function set_htmlSize(val,context){// might be useful for fixed display size/location elements that stay in place even if you move tab or change zoom. debatable if needed\nthis.cannotSet(\"set_htmlSize(): todo extra low priority. set GraphSize through set_size instead.\");return true;}},{key:\"get_htmlPosition\",value:function get_htmlPosition(context){return this.get_htmlSize(context).tl();}},{key:\"set_htmlPosition\",value:function set_htmlPosition(val,context){// might be useful for fixed display size/location elements that stay in place even if you move tab or change zoom. debatable if needed\nthis.cannotSet(\"set_htmlPosition(): todo extra low priority. set graph position through set_position instead.\");return true;}/* how z-index work, it's really messy.\r\n    * cannot move html position. node id depends on it, and a node moving position would need to change id.\r\n    * so i use css order.\r\n    * first order is assigned through node constructor called by parent component injectProps, according to his last index in html.\r\n    * now z-index is set in node and updated properly.\r\n    * z-index is passed to a prop, rendered as html attribute.\r\n    * css takes the attribute value and uses it in \"order\" css rule.\r\n    * problem: updating node.z doesn't trigger the parent injectprops, so he inject html index and\r\n    * the outernmost html root cannot update his attribute without refreshing the parent and recalling injectprops\r\n    * fixed: by updating it directly in GraphElement.render()\r\n    * */},{key:\"get_zIndex\",value:function get_zIndex(context){return context.data.zIndex;}},{key:\"set_zIndex\",value:function set_zIndex(val,context){SetFieldAction.new(context.data.id,\"zIndex\",val,undefined,false);return true;}},{key:\"get_z\",value:function get_z(context){return context.data.zIndex;}},{key:\"set_z\",value:function set_z(val,context){return this.set_zIndex(val,context);}/*\r\n        get_containedIn(context: Context): this[\"containedIn\"] {\r\n            return context.data.containedIn ? LPointerTargetable.fromPointer(context.data.containedIn) : undefined; }\r\n        set_containedIn(val: Pack1<this[\"containedIn\"]>, context: LogicContext<DGraphElement>): boolean {\r\n            let ptr: DGraphElement[\"containedIn\"] = Pointers.from(val) as any;\r\n            SetFieldAction.new(context.data, 'containedIn', ptr, undefined, true);\r\n            if (ptr) SetFieldAction.new(ptr as any, 'subElements+=', context.data.id);\r\n            return true; }*/},{key:\"get_subElements\",value:function get_subElements(context){return LPointerTargetable.fromArr(_toConsumableArray(new Set(context.data.subElements)));}},{key:\"set_subElements\",value:function set_subElements(val,context){console.log(\"isDeepStrictEqual\",{isDeepStrictEqual:isDeepStrictEqual});Log.eDev(_toConsumableArray(new Set(val)).length!==val.length,\"subelemnts setter have duplicates\",{val:val,context:context});// if (isDeepStrictEqual(context.data.subElements, val)) return true;\nvar pointers=Pointers.from(val)||[];if(Uarr.equals(pointers,context.data.subElements,false))return true;SetFieldAction.new(context.data,'subElements',pointers,'',true);var idlookup=store.getState().idlookup;var arrdiff=U.arrayDifference(context.data.subElements,pointers);// old subelements\nvar _iterator=_createForOfIteratorHelper(arrdiff.removed),_step;try{for(_iterator.s();!(_step=_iterator.n()).done;){var oldsubelementid=_step.value;var subelement=oldsubelementid&&idlookup[oldsubelementid];if(subelement.father!==context.data.id)continue;LPointerTargetable.from(subelement).father=null;// todo: can this happen? è transitorio o causa vertici senza parent permanenti?\n}// new subelements\n}catch(err){_iterator.e(err);}finally{_iterator.f();}var _iterator2=_createForOfIteratorHelper(arrdiff.added),_step2;try{for(_iterator2.s();!(_step2=_iterator2.n()).done;){var newsubelementid=_step2.value;var _subelement=newsubelementid&&idlookup[newsubelementid];if(_subelement.father===context.data.id)continue;LPointerTargetable.from(_subelement).father=context.data.id;// trigger side-action\n}}catch(err){_iterator2.e(err);}finally{_iterator2.f();}return true;}},{key:\"get_isResized\",value:function get_isResized(context){return context.data.isResized;}},{key:\"set_isResized\",value:function set_isResized(val,context){return SetFieldAction.new(context.data.id,\"isResized\",val);}},{key:\"get_model\",value:function get_model(context){var modelElementId=context.data.model;//$('[id=\"' + context.data.id + '\"]')[0].dataset.dataid;\nvar lModelElement=LPointerTargetable.from(modelElementId);return lModelElement;}},{key:\"get_allSubNodes\",value:function get_allSubNodes(context,state){// return context.data.packages.map(p => LPointerTargetable.from(p));\nstate=state||store.getState();var tocheck=context.data.subElements||[];var checked={};var dblcheck={};// <child, parent>  // debug only\nvar _iterator3=_createForOfIteratorHelper(tocheck),_step3;try{for(_iterator3.s();!(_step3=_iterator3.n()).done;){var _e=_step3.value;dblcheck[_e]=context.data.id;}// debug only\n}catch(err){_iterator3.e(err);}finally{_iterator3.f();}checked[context.data.id]=true;//nb6[]{}&\nwhile(tocheck.length){var newtocheck=[];var _iterator4=_createForOfIteratorHelper(tocheck),_step4;try{for(_iterator4.s();!(_step4=_iterator4.n()).done;){var ptr=_step4.value;Log.eDev(checked[ptr],\"loop in GraphElements containing themselves\",{dblcheck:dblcheck,context:context,ptr:ptr,checked:checked,fistContainer:dblcheck[ptr]});if(checked[ptr])continue;checked[ptr]=true;var subnode=DPointerTargetable.from(ptr,state);var se=subnode===null||subnode===void 0?void 0:subnode.subElements;var _iterator5=_createForOfIteratorHelper(se),_step5;try{for(_iterator5.s();!(_step5=_iterator5.n()).done;){var e=_step5.value;dblcheck[e]=ptr;}// debug only\n}catch(err){_iterator5.e(err);}finally{_iterator5.f();}U.arrayMergeInPlace(newtocheck,se);}}catch(err){_iterator4.e(err);}finally{_iterator4.f();}tocheck=newtocheck;}delete checked[context.data.id];return LPointerTargetable.from(Object.keys(checked),state);}},{key:\"get_assignEdgeAnchor\",value:function get_assignEdgeAnchor(c){return function(anchorName){if(anchorName&&!c.data.anchors[anchorName])anchorName=undefined;if(LVoidEdge.startFollow){var de=DPointerTargetable.fromPointer(LVoidEdge.startFollow);if(de.start!==c.data.id)return;// cannot change edge targets, only an anchor within the current targets\nvar le=LPointerTargetable.fromD(de);le.anchorStart=anchorName;le.startFollow=false;}if(LVoidEdge.endFollow){var _de=DPointerTargetable.fromPointer(LVoidEdge.endFollow);if(_de.end!==c.data.id)return;// cannot change edge targets, only an anchor within the current targets\nvar _le=LPointerTargetable.fromD(_de);_le.anchorEnd=anchorName;_le.endFollow=false;}};}},{key:\"get_events\",value:function get_events(c){var tn=transientProperties.node[c.data.id];var mainview=tn.mainView.__raw;var otherViews=tn.stackViews.map(function(v){return v.__raw;});var allviews=[mainview].concat(_toConsumableArray(otherViews)).reverse();var keep_for_closure_original_funcs={};var ret={};var _iterator6=_createForOfIteratorHelper(allviews),_step6;try{for(_iterator6.s();!(_step6=_iterator6.n()).done;){var dv=_step6.value;U.objectMergeInPlace(keep_for_closure_original_funcs,transientProperties.view[dv.id].events);}}catch(err){_iterator6.e(err);}finally{_iterator6.f();}var lastContext=tn.viewScores[mainview.id].evalContext;var keys=Object.keys(keep_for_closure_original_funcs);// for (let k of keys) ret['_raw_'+k] = keep_for_closure_original_funcs[k];\nvar _loop=function _loop(){var k=_keys[_i];if(!keep_for_closure_original_funcs[k])return\"continue\";ret[k]=function(){for(var _len3=arguments.length,_params=new Array(_len3),_key3=0;_key3<_len3;_key3++){_params[_key3]=arguments[_key3];}return keep_for_closure_original_funcs[k].apply(keep_for_closure_original_funcs,[lastContext].concat(_params));};};for(var _i=0,_keys=keys;_i<_keys.length;_i++){var _ret=_loop();if(_ret===\"continue\")continue;}return ret;}},{key:\"get_father\",value:function get_father(context){return LPointerTargetable.fromPointer(context.data.father);}},{key:\"set_father\",value:function set_father(val,context){var ptr=Pointers.from(val);SetFieldAction.new(context.data,'father',ptr,undefined,true);if(ptr)SetFieldAction.new(ptr,'subElements+=',context.data.id);return true;}},{key:\"select\",value:function select(forUser){return this.wrongAccessMessage(\"node.select()\");}},{key:\"deselect\",value:function deselect(forUser){return this.wrongAccessMessage(\"node.deselect()\");}},{key:\"toggleSelected\",value:function toggleSelected(forUser){return this.wrongAccessMessage(\"node.toggleSelected()\");}},{key:\"isSelected\",value:function isSelected(forUser){return this.wrongAccessMessage(\"node.isSelected()\");}},{key:\"get_select\",value:function get_select(c){return function(forUser){if(!forUser)forUser=DUser.current;if(c.data.isSelected[forUser])return;// no-op\nvar map=_objectSpread({},c.data.isSelected);map[forUser]=true;SetFieldAction.new(c.data.id,\"isSelected\",map,undefined,false);// todo: actually they are pointer to users, but i'm assuming users are not erased at runtime. on deselect too\n};}},{key:\"get_deselect\",value:function get_deselect(c){return function(forUser){if(!forUser)forUser=DUser.current;if(!c.data.isSelected[forUser])return;// no-op\nvar map=_objectSpread({},c.data.isSelected);delete map[forUser];SetFieldAction.new(c.data.id,\"isSelected\",map,undefined,false);// todo: actually they are pointer to users, but i'm assuming users are not erased at runtime. on deselect too\n};}},{key:\"get_toggleSelected\",value:function get_toggleSelected(context){var _this4=this;return function(forUser){if(!forUser)forUser=DUser.current;if(_this4.get_isSelected(context)(forUser)){_this4.get_deselect(context)(forUser);return false;}else{_this4.get_select(context)(forUser);return true;}};}},{key:\"get_isSelected\",value:function get_isSelected(context){return function(forUser){if(!forUser)forUser=DUser.current;return!!context.data.isSelected[forUser];};}},{key:\"set_isSelected\",value:function set_isSelected(val,context){return this.cannotSet(\"graphElement.isSelected(): use this.select() or this.deselect() instead.\");}/*\r\n    get_isSelected(context: LogicContext<DVoidVertex>): GObject {\r\n        return DPointerTargetable.mapWrap(context.data.isSelected, context.data, 'idlookup.' + context.data.id + '.isSelected', []);\r\n    }*/ // for edges\n},{key:\"get_startPoint\",value:function get_startPoint(c,size,view){return this.get_startEndPoint(c,size,view,true);}},{key:\"get_endPoint\",value:function get_endPoint(c,size,view){return this.get_startEndPoint(c,size,view,false);}},{key:\"get_startEndPoint\",value:function get_startEndPoint(c,size,view){var isStart=arguments.length>3&&arguments[3]!==undefined?arguments[3]:true;if(!size){if(c)size=this.get_size(c);else size=Log.exDevv(\"invalid arguments in get_startEndPoint\",{arguments:arguments});}if(!view){// if (c) view = this.get_view(c); else view = Log.exDevv(\"invalid arguments in get_startPoint\", {arguments});\nview=c&&this.get_view(c)||Log.exDevv(\"invalid arguments in get_startEndPoint\",{arguments:arguments});}var offset=view[isStart?\"edgeStartOffset\":\"edgeEndOffset\"];var isPercentage=view[isStart?\"edgeStartOffset_isPercentage\":\"edgeEndOffset_isPercentage\"];if(!size)size=new GraphSize(0,0,0,0);if(isPercentage)offset=new GraphPoint(offset.x/100*size.w,offset.y/100*size.h);return size.tl().add(offset,false);}}],[{key:\"getNodeId\",value:function getNodeId(o){var _node;if(!o)return undefined;var node=o;// from L to D\n// let cname = (node.__raw || node).className;\n// from DModelE to LGraphE\nif(RuntimeAccessibleClass.extends(o.className,\"DModelElement\"))node=LPointerTargetable.from(o).node;return typeof node===\"string\"?node:(_node=node)===null||_node===void 0?void 0:_node.id;}// static singleton: LGraphElement;\n// static logic: typeof LGraphElement;\n// static structure: typeof DGraphElement;\n// todo: can be removed and accessed by navigating .father\n// protected isSelected!: Dictionary<DocString<Pointer<DUser>>, boolean>; //  & ((forUser?: Pointer<DUser>) => boolean);\n// containedIn?: LGraphElement;\n// shallow, direct subelements\n// LMap;\n// deep, nested subelements\n// fittizi\n// size and position in global document coordinates.\n}]);return LGraphElement;}(LPointerTargetable),_class4.subclasses=[],_class4._extends=[],_class4))||_class3);RuntimeAccessibleClass.set_extend(DPointerTargetable,DGraphElement);RuntimeAccessibleClass.set_extend(LPointerTargetable,LGraphElement);export var DGraph=(_dec3=RuntimeAccessible('DGraph'),_dec3(_class5=(_class6=/*#__PURE__*/function(_DGraphElement){_inherits(DGraph,_DGraphElement);var _super3=_createSuper(DGraph);function DGraph(){var _this5;_classCallCheck(this,DGraph);for(var _len4=arguments.length,args=new Array(_len4),_key4=0;_key4<_len4;_key4++){args[_key4]=arguments[_key4];}_this5=_super3.call.apply(_super3,[this].concat(args));_this5.father=void 0;_this5.id=void 0;_this5.graph=void 0;_this5.model=void 0;_this5.isSelected=void 0;_this5.subElements=void 0;_this5.state=void 0;_this5.zoom=void 0;_this5.offset=void 0;return _this5;}// static _super = DGraphElement;\n// static singleton: LGraph;\n// static logic: typeof LGraph;\n// static structure: typeof DGraph;\n// inherit redefine\n// containedIn!: Pointer<DGraphElement, 0, 1, LGraphElement>;\n// personal attributes\n_createClass(DGraph,null,[{key:\"new\",value:// in-graph scrolling offset\nfunction _new(htmlindex,model,parentNodeID,// immediate parent\nparentgraphID,// graph containing this subgraph (redudant? could get it from father chain)\nnodeID){return new Constructors(new DGraph('dwc'),parentNodeID,true,undefined,nodeID||Constructors.DGraph_makeID(model)).DPointerTargetable().DGraphElement(model,parentgraphID,htmlindex).DGraph().end();}},{key:\"getNodes\",value:function getNodes(dmp,out){var $allnodes=$('[data-dataid]');var matchedids=(dmp||[]).map(function(d){return d.id;});var matchedidmap=U.objectFromArrayValues(matchedids);if(!out)out={};var allnodesarr=_toConsumableArray($allnodes);var filternode=function filternode(d){var _d$dataset,_d$dataset2;if(!(d===null||d===void 0?void 0:(_d$dataset=d.dataset)===null||_d$dataset===void 0?void 0:_d$dataset.dataid))return false;var id=''+(d===null||d===void 0?void 0:(_d$dataset2=d.dataset)===null||_d$dataset2===void 0?void 0:_d$dataset2.dataid);return matchedidmap[id];};out.$matched=$(allnodesarr.filter(filternode));out.$notMatched=$(allnodesarr.filter(function(n){return!filternode(n);}));return out.$matched;// throw new Error(\"Method not implemented.\");\n}}]);return DGraph;}(DGraphElement),_class6.subclasses=[],_class6._extends=[],_class6))||_class5);var nosize={x:0,y:0,w:0,h:0,nosize:true};var defaultEdgePointSize=undefined;// = {x:0, y:0, w:5, h:5};\nvar defaultVertexSize=undefined;// {x:0, y:0, w:140.6818084716797, h:32.52840805053711};\nexport var LGraph=(_dec4=RuntimeAccessible('LGraph'),_dec4(_class7=(_class8=/*#__PURE__*/function(_LGraphElement){_inherits(LGraph,_LGraphElement);var _super4=_createSuper(LGraph);function LGraph(){var _this6;_classCallCheck(this,LGraph);for(var _len5=arguments.length,args=new Array(_len5),_key5=0;_key5<_len5;_key5++){args[_key5]=arguments[_key5];}_this6=_super4.call.apply(_super4,[this].concat(args));_this6.__raw=void 0;_this6.id=void 0;_this6.graph=void 0;_this6.model=void 0;_this6.subElements=void 0;_this6._state=void 0;_this6.zoom=void 0;_this6.graphSize=void 0;_this6.offset=void 0;_this6.__info_of__zoom={type:GraphPoint.cname,label:\"zoom\",txt:\"Scales the graph and all subelements by a factor.\"};_this6.__info_of__offset={type:GraphPoint.cname,label:\"offset\",txt:\"In-graph scrolling position.\"};_this6.__info_of__graphSize={type:GraphSize.cname,label:\"graphSize\",txt:\"size internal to the graph, including internal scroll and panning.\"};_this6.__info_of__translateSize={type:\"(T, Graph)=>T where T is GraphSize | GraphPoint\",txt:\"Translates a coordinate set from the local coordinates of a SubGraph to this Graph containing it.\"};_this6.__info_of__translateHtmlSize={type:\"(Size|Point) => GraphSize|GraphPoint\",txt:\"Translate page\\'s viewport coordinate set to this graph coordinate set.\"};return _this6;}// static singleton: LGraph;\n// static logic: typeof LGraph;\n// static structure: typeof DGraph;\n// inherit redefine\n_createClass(LGraph,[{key:\"isSelected\",value:// isSelected: Dictionary<DocString<Pointer<DUser>>, boolean> = {};\nfunction isSelected(forUser){return this.wrongAccessMessage(\"node.isSelected()\");}// containedIn?: LGraphElement;\n// LMap;\n// personal attributes\n// derived attribute: bounding rect containing all subnodes, while \"size\" is instead external size of the vertex holding the graph in GraphVertexes\n},{key:\"get_offset\",value:// Scrolling position inside the graph\n// get_graphSize(context: LogicContext<DGraph>):  Readonly<GraphSize> { return todo: get bounding rect containing all subnodes.; }\nfunction get_offset(context){return new GraphSize(context.data.offset.x,context.data.offset.y);}},{key:\"set_offset\",value:function set_offset(val,context){if(!val)val={x:0,y:0};if(context.data.offset.x===val.x&&context.data.offset.y===val.y)return true;if(val.x===undefined&&context.data.offset.x!==val.x)val.x=context.data.offset.x;if(val.y===undefined&&context.data.offset.y!==val.y)val.y=context.data.offset.y;SetFieldAction.new(context.data,\"offset\",val);return true;}},{key:\"get_zoom\",value:function get_zoom(context){var zoom=context.data.zoom;// (zoom as any).debug = {rawgraph: context.data.__raw, zoomx: context.data.zoom.x, zoomy: context.data.zoom.y}\nreturn context.data.zoom;}},{key:\"toGraphSize\",value:function toGraphSize(){return this.wrongAccessMessage(\"toGraphSize\");}},{key:\"coord\",value:function coord(htmlSize){return this.wrongAccessMessage(\"toGraphSize\");}},{key:\"get_coord\",value:function get_coord(context){var _this7=this;return function(htmlSize){var size=_this7.get_htmlSize(context);var zoom=_this7.get_zoom(context);return new GraphSize((htmlSize.x-size.x)/zoom.x,(htmlSize.y-size.y)/zoom.y,htmlSize.w/zoom.x,htmlSize.h/zoom.y);};}// get_htmlSize(context: Context): Size { }\n},{key:\"translateSize\",value:function translateSize(ret,innerGraph){return this.wrongAccessMessage(\"translateSize()\");}},{key:\"translateHtmlSize\",value:function translateHtmlSize(size){return this.wrongAccessMessage(\"translateHtmlSize()\");}},{key:\"set_zoom\",value:function set_zoom(val,c){SetFieldAction.new(c.data,'zoom',val,'+=',false);return true;}},{key:\"get_translateHtmlSize\",value:function get_translateHtmlSize(c){var _this8=this;return function(size){var graphHtmlSize=_this8.get_htmlSize(c);var a=size.subtract(graphHtmlSize.tl(),true);var b=a.add({x:c.data.offset.x,y:c.data.offset.y},false);return b.multiply(c.data.zoom,false);};}},{key:\"get_translateSize\",value:function get_translateSize(c){return function(size,innerGraph){innerGraph=LPointerTargetable.wrap(innerGraph);var ret=size.hasOwnProperty(\"w\")?new GraphSize(size.x,size.y,size.w,size.h):new GraphPoint(size.x,size.y);Log.ex(!innerGraph,\"translateSize() graph parameter is invalid: \"+innerGraph,innerGraph,c);var ancestors=[innerGraph].concat(_toConsumableArray(innerGraph.graphAncestors));Log.ex(ancestors.indexOf(c.proxyObject)!==-1,\"translateSize() graph parameter is invalid: it must be a graph containing the current one.\",innerGraph,c);var _iterator7=_createForOfIteratorHelper(ancestors),_step7;try{for(_iterator7.s();!(_step7=_iterator7.n()).done;){var g=_step7.value;ret.add(g.size.tl(),false);}// console.log(\"translateSize\", {c, thiss:c.proxyObject, ancestors, ancestorSizes: ancestors.map(a=> a.size.tl()), size, ret});\n}catch(err){_iterator7.e(err);}finally{_iterator7.f();}return ret;};}},{key:\"contains\",value:function contains(elem){return this.wrongAccessMessage(\"contains()\");}},{key:\"get_contains\",value:function get_contains(c){return function(elem){var current=elem;var next=elem.father;var targetid=c.proxyObject.id;if(current.id!==targetid)return true;while(next&&current.id!==next.id){current=next;next=next.father;if(current.id!==targetid)return true;}return false;};}}]);return LGraph;}(LGraphElement),_class8.subclasses=[],_class8._extends=[],_class8))||_class7);RuntimeAccessibleClass.set_extend(DGraphElement,DGraph);RuntimeAccessibleClass.set_extend(LGraphElement,LGraph);// export const defaultVSize: GraphSize = new GraphSize(0, 0, 300, 160); // useless, now it's in view.DefaultVSize\n// export const defaultEPSize: GraphSize = new GraphSize(0, 0, 15, 15); // useless, now it's in view.DefaultVSize\nexport var DVoidVertex=(_dec5=RuntimeAccessible('DVoidVertex'),_dec5(_class9=(_class10=/*#__PURE__*/function(_DGraphElement2){_inherits(DVoidVertex,_DGraphElement2);var _super5=_createSuper(DVoidVertex);function DVoidVertex(){var _this9;_classCallCheck(this,DVoidVertex);for(var _len6=arguments.length,args=new Array(_len6),_key6=0;_key6<_len6;_key6++){args[_key6]=arguments[_key6];}_this9=_super5.call.apply(_super5,[this].concat(args));_this9.id=void 0;_this9.graph=void 0;_this9.model=void 0;_this9.isSelected=void 0;_this9.subElements=void 0;_this9.state=void 0;_this9.zoom=void 0;_this9.x=void 0;_this9.y=void 0;_this9.w=void 0;_this9.h=void 0;_this9.isResized=void 0;return _this9;}// static _super = DGraphElement;\n// static singleton: LVoidVertex;\n// static logic: typeof LVoidVertex;\n// static structure: typeof DVoidVertex;\n// inherit redefine\n// containedIn!: Pointer<DGraphElement, 0, 1, LGraphElement>;\n// personal attributes\n_createClass(DVoidVertex,null,[{key:\"new\",value:// size?: GraphSize; // virtual, gets extracted from this. x and y are stored directly here as it extends GraphSize\nfunction _new(htmlindex,model,parentNodeID,graphID,nodeID,size){return new Constructors(new DVoidVertex('dwc'),parentNodeID,true,undefined,nodeID).DPointerTargetable().DGraphElement(model,graphID,htmlindex).DVoidVertex(size||defaultVertexSize).end();}}]);return DVoidVertex;}(DGraphElement),_class10.subclasses=[],_class10._extends=[],_class10))||_class9);export var LVoidVertex=(_dec6=RuntimeAccessible('LVoidVertex'),_dec6(_class11=(_class12=/*#__PURE__*/function(_LGraphElement2){_inherits(LVoidVertex,_LGraphElement2);var _super6=_createSuper(LVoidVertex);function LVoidVertex(){var _this10;_classCallCheck(this,LVoidVertex);for(var _len7=arguments.length,args=new Array(_len7),_key7=0;_key7<_len7;_key7++){args[_key7]=arguments[_key7];}_this10=_super6.call.apply(_super6,[this].concat(args));_this10.__raw=void 0;_this10.id=void 0;_this10.graph=void 0;_this10.model=void 0;_this10.subElements=void 0;_this10._state=void 0;_this10.zoom=void 0;_this10.isResized=void 0;_this10.x=void 0;_this10.y=void 0;_this10.w=void 0;_this10.h=void 0;_this10.size=void 0;_this10.__info_of__size={type:\"?GraphSize\",txt:\"Size of the vertex, if null it means is utilizing the defaultSize from view. recommended to read component.getSize() instead of this.\"};return _this10;}// <D extends DVoidVertex = any>\n// static singleton: LVoidVertex;\n// static logic: typeof LVoidVertex;\n// static structure: typeof DVoidVertex;\n// inherit redefine\n_createClass(LVoidVertex,[{key:\"isSelected\",value:// isSelected: Dictionary<DocString<Pointer<DUser>>, boolean> = {};\nfunction isSelected(forUser){return this.wrongAccessMessage(\"node.isSelected()\");}// containedIn?: LGraphElement;\n// LMap;\n// personal attributes\n// virtual, gets extracted from this. x and y are stored directly here as it extends GraphSize\n},{key:\"get_isResized\",value:function get_isResized(context){return context.data.isResized;}},{key:\"set_isResized\",value:function set_isResized(val,context){return SetFieldAction.new(context.data.id,\"isResized\",val);}}]);return LVoidVertex;}(LGraphElement),_class12.subclasses=[],_class12._extends=[],_class12))||_class11);RuntimeAccessibleClass.set_extend(DGraphElement,DVoidVertex);RuntimeAccessibleClass.set_extend(LGraphElement,LVoidVertex);export var DEdgePoint=(_dec7=RuntimeAccessible('DEdgePoint'),_dec7(_class13=(_class14=/*#__PURE__*/function(_DVoidVertex){_inherits(DEdgePoint,_DVoidVertex);var _super7=_createSuper(DEdgePoint);function DEdgePoint(){var _this11;_classCallCheck(this,DEdgePoint);for(var _len8=arguments.length,args=new Array(_len8),_key8=0;_key8<_len8;_key8++){args[_key8]=arguments[_key8];}_this11=_super7.call.apply(_super7,[this].concat(args));_this11.id=void 0;_this11.father=void 0;_this11.graph=void 0;_this11.model=void 0;_this11.isSelected=void 0;_this11.subElements=void 0;_this11.zoom=void 0;_this11.x=void 0;_this11.y=void 0;_this11.w=void 0;_this11.h=void 0;_this11.size=void 0;_this11.__isDEdgePoint=void 0;_this11.currentCoordType=void 0;return _this11;}// DVoidVertex\n// static singleton: LEdgePoint;\n// static logic: typeof LEdgePoint;\n// static structure: typeof DEdgePoint;\n// inherit redefine\n// todo: if null gets model from this.father (edge)?\n// containedIn!: Pointer<DGraphElement, 0, 1, LGraphElement>;\n//／／ virtual, gets extracted from this. x and y are stored directly here as it extends GraphSize\n// personal attributes\n_createClass(DEdgePoint,null,[{key:\"new\",value:function _new(htmlindex,model,parentNodeID,graphID,nodeID,size){return new Constructors(new DEdgePoint('dwc'),parentNodeID,true,undefined,nodeID).DGraphElement(undefined,graphID,htmlindex).DVoidVertex(size||defaultEdgePointSize).DEdgePoint().end();}}]);return DEdgePoint;}(DVoidVertex),_class14.subclasses=[],_class14._extends=[],_class14))||_class13);export var LEdgePoint=(_dec8=RuntimeAccessible('LEdgePoint'),_dec8(_class15=(_class16=/*#__PURE__*/function(_LVoidVertex){_inherits(LEdgePoint,_LVoidVertex);var _super8=_createSuper(LEdgePoint);function LEdgePoint(){var _this12;_classCallCheck(this,LEdgePoint);for(var _len9=arguments.length,args=new Array(_len9),_key9=0;_key9<_len9;_key9++){args[_key9]=arguments[_key9];}_this12=_super8.call.apply(_super8,[this].concat(args));_this12.father=void 0;_this12.id=void 0;_this12.graph=void 0;_this12.model=void 0;_this12.subElements=void 0;_this12.zoom=void 0;_this12.x=void 0;_this12.y=void 0;_this12.w=void 0;_this12.h=void 0;_this12.size=void 0;_this12.__isLEdgePoint=void 0;_this12.edge=void 0;_this12.__info_of__edge={type:\"?LEdge\",txt:\"returns the containing edge if called on an EdgePoint, \\\"this\\\" if called on an edge, undefined otherwise.\"};return _this12;}// static singleton: LEdgePoint;\n// static logic: typeof LEdgePoint;\n// static structure: typeof DEdgePoint;\n// inherit redefine\n// __raw!: DEdgePoint;\n_createClass(LEdgePoint,[{key:\"isSelected\",value:// isSelected: Dictionary<DocString<Pointer<DUser>>, boolean> = {};\nfunction isSelected(forUser){return this.wrongAccessMessage(\"node.isSelected()\");}// containedIn?: LGraphElement;\n// virtual, gets extracted from this. x and y are stored directly here as it extends GraphSize\n// personal attributes\n// returns container edge\n},{key:\"get_edge\",value:function get_edge(c){return c.proxyObject.father;}},{key:\"set_edge\",value:function set_edge(v,c){return this.set_father(v,c);}},{key:\"decodePosCoords\",value:// from x,y as coords, to x%,y% as % of ((1-val)%*startpt) + ((val)%*endpt)\nfunction decodePosCoords(c,size,view,sp0,ep0){var le=c&&c.proxyObject.father;// console.log(\"decodepos:\", {le, sp0, lesp:le?.startPoint});\nvar sp=sp0||le.startPoint;var ep=ep0||le.endPoint;return LEdgePoint.decodeCoords(size,sp,ep);}},{key:\"encodePosCoords\",value:function encodePosCoords(c,size0,view,sp0,ep0,mode){if(!view)view=this.get_view(c);var size=size0;var edgePointCoordMode=mode||(view.__raw||view).edgePointCoordMode;var le=c&&c.proxyObject.father;var sp=sp0||le.startPoint;var ep=ep0||le.endPoint;return LEdgePoint.encodeCoords(size,edgePointCoordMode,sp,ep);}/* 13/10/2023 Giordano comment (defined in LPointerTargetable\r\n    public get_delete(context: Context): () => void {\r\n        // careful: pointedBy might be broken due to comment x984 (search it)\r\n        return super.get_delete(context);\r\n    }\r\n    */}],[{key:\"decodeCoords\",value:function decodeCoords(size0,sp,ep)/*absolute*/{var size=size0;var ret=\"w\"in size||\"h\"in size?new GraphSize():new GraphPoint();// GObject<Partial<GraphSize>>;\nswitch(size.currentCoordType){default:return Log.exDevv(\"translatePosCoords() invalid coordinate mode\",{mode:size.currentCoordType});// case CoordinateMode.absolute: return size;\ncase CoordinateMode.absolute:case undefined:case null:if(size.x!==undefined)ret.x=size.x;if(size.y!==undefined)ret.y=size.y;break;case CoordinateMode.relativePercent://maybe do: dampening factor on relative % offset? is it possible?\n// let s = this.getBasicSize(c);\n// MATH:\n// size.x = sp.x*x% + ep.x*(1-x%)\n// size.x = sp.x*x% + ep.x - ep.x*x%\n// size.x - ep.x= (sp.x - ep.x)*x%\n// (size.x - ep.x) / (sp.x - ep.x) = x% // actually i inverted <sp, ep> in first equation, so reverse them in result too.\nif(size.x!==undefined)ret.x=(1-size.x)*sp.x+size.x*ep.x;if(size.y!==undefined)ret.y=(1-size.y)*sp.y+size.y*ep.y;break;case CoordinateMode.relativeOffset:case CoordinateMode.relativeOffsetStart:case CoordinateMode.relativeOffsetEnd:var useStart;var useEnd;switch(size.currentCoordType){default:case CoordinateMode.relativeOffset:useStart=true;useEnd=true;break;case CoordinateMode.relativeOffsetStart:useStart=true;useEnd=false;break;case CoordinateMode.relativeOffsetEnd:useStart=false;useEnd=true;break;}// offset = sp - size\n// size = offset - sp\n// in reverse: actualsize = offset, size=offset\n// if coords are already in absolute mode.\nvar xIsAbsolute=size.x&&!Array.isArray(size.x)?size.x:undefined;var yIsAbsolute=size.x&&!Array.isArray(size.x)?size.x:undefined;Log.w(xIsAbsolute||yIsAbsolute,\"decoding relative offset require an array size coordinate system. x=[x1, x2] --> x\",{size:size});var offsetsp=useStart?new GraphPoint(xIsAbsolute||size.x[0]+sp.x,yIsAbsolute||size.y[0]+sp.y):new GraphPoint();var offsetep=useEnd?new GraphPoint(xIsAbsolute||size.x[1]+ep.x,yIsAbsolute||size.y[1]+ep.y):new GraphPoint();// if the start and endpoint of the edge didn't move, offsetsp = offsetep.\n// if they moved, those 2 are discordant --> i pick middle\noffsetsp.add(offsetep,false);if(useStart&&useEnd)offsetsp.divide(2,false);if(!xIsAbsolute&&size.x!==undefined)ret.x=offsetsp.x;if(!yIsAbsolute&&size.y!==undefined)ret.y=offsetsp.y;if(xIsAbsolute){ret.x=size.x;}if(yIsAbsolute){ret.y=size.y;}break;}if(size.x===undefined)delete ret.x;if(size.y===undefined)delete ret.y;if(size.w===undefined)delete ret.w;else ret.w=size.w;if(size.h===undefined)delete ret.h;else ret.h=size.h;ret.currentCoordType=CoordinateMode.absolute;// console.log(\"decode coords\", {size, sp, ep, ret});\nreturn ret;}},{key:\"testCoords\",value:function testCoords(){var range=arguments.length>0&&arguments[0]!==undefined?arguments[0]:30;outer:for(var _i2=0,_arr=[\"absolute\",\"relative%\",\"relativeOffset\",\"relativeOffsetStart\",\"relativeOffsetEnd\"];_i2<_arr.length;_i2++){var mode=_arr[_i2];for(var i=-range;i<range;i++){for(var j=-range;j<range;j++){var s0={x:i,y:j};var sp={x:10,y:10};var ep={x:10,y:-10};// @ts-ignore\nvar s1=LEdgePoint.encodeCoords(s0,mode,sp,ep);// @ts-ignore\nvar s00=LEdgePoint.decodeCoords(s1,sp,ep);// @ts-ignore\nvar error=Object.keys(s0).map(function(k){return s0[k].toFixed(3)===s00[k].toFixed(3)?'':k;}).join('');(mode!=\"relative%\"&&error?console.error:console.log)({diff:[s00.x-s0.x,s00.y-s0.y].join(),i:i,j:j,mode:mode,s1:[s1.x,s1.y].join(),s0:s0,s00:s00,error:error});if(mode!=\"relative%\"&&error)break outer;}}}}// @ts-ignore a\n},{key:\"encodeCoords\",value:function encodeCoords(size0,edgePointCoordMode,sp,ep)/*absolute*/{var size=size0;if(edgePointCoordMode===size.currentCoordType||!size.currentCoordType&&edgePointCoordMode===CoordinateMode.absolute)return size;if(size.currentCoordType&&size.currentCoordType!==CoordinateMode.absolute)size=LEdgePoint.decodeCoords(size,sp,ep);var ret=\"w\"in size||\"h\"in size?new GraphSize():new GraphPoint();// GObject<Partial<GraphSize>>;\nswitch(edgePointCoordMode){default:return Log.exDevv(\"translatePosCoords() invalid coordinate mode\",{mode:edgePointCoordMode});// case CoordinateMode.absolute: return size;\ncase CoordinateMode.relativePercent:// let s = this.getBasicSize(c);\n// MATH:\n// size.x = sp.x*x% + ep.x*(1-x%)\n// size.x = sp.x*x% + ep.x - ep.x*x%\n// size.x - ep.x= (sp.x - ep.x)*x%\n// (size.x - ep.x) / (sp.x - ep.x) = x% // actually i inverted <sp, ep> in first equation, so reverse them in result too.\nif(sp.x===ep.x)ret.x=0.5;// because otherwise it is infinity. so i force him to return in line.\nelse if(size.x!==undefined)ret.x=(size.x-sp.x)/(ep.x-sp.x);if(sp.y===ep.y)ret.y=0.5;else if(size.y!==undefined)ret.y=(size.y-sp.y)/(ep.y-sp.y);break;case CoordinateMode.relativeOffset:case CoordinateMode.relativeOffsetStart:case CoordinateMode.relativeOffsetEnd:var useStart;var useEnd;switch(edgePointCoordMode){default:case CoordinateMode.relativeOffset:useStart=true;useEnd=true;break;case CoordinateMode.relativeOffsetStart:useStart=true;useEnd=false;break;case CoordinateMode.relativeOffsetEnd:useStart=false;useEnd=true;break;}if(size.x)ret.x=[useStart?size.x-sp.x:-1,useEnd?size.x-ep.x:-1];if(size.y)ret.y=[useStart?size.y-sp.y:-1,useEnd?size.y-ep.y:-1];/*\r\n                if (size.x) ret.x = [sp.x - size.x, ep.x - size.x];\r\n                if (size.y) ret.y = [sp.y - size.y, ep.y - size.y];*/break;}if(size.x===undefined)delete ret.x;if(size.y===undefined)delete ret.y;if(size.w===undefined)delete ret.w;else ret.w=size.w;if(size.h===undefined)delete ret.h;else ret.h=size.h;// console.log(\"encode coorde\", {size, sp, ep, ret});\nret.currentCoordType=edgePointCoordMode;return ret;}}]);return LEdgePoint;}(LVoidVertex),_class16.subclasses=[],_class16._extends=[],_class16))||_class15);RuntimeAccessibleClass.set_extend(DVoidVertex,DEdgePoint);RuntimeAccessibleClass.set_extend(LVoidVertex,LEdgePoint);export var DVertex=(_dec9=RuntimeAccessible('DVertex'),_dec9(_class17=(_class18=/*#__PURE__*/function(_DGraphElement3){_inherits(DVertex,_DGraphElement3);var _super9=_createSuper(DVertex);function DVertex(){var _this13;_classCallCheck(this,DVertex);for(var _len10=arguments.length,args=new Array(_len10),_key10=0;_key10<_len10;_key10++){args[_key10]=arguments[_key10];}_this13=_super9.call.apply(_super9,[this].concat(args));_this13.id=void 0;_this13.graph=void 0;_this13.model=void 0;_this13.isSelected=void 0;_this13.subElements=void 0;_this13.zoom=void 0;_this13.x=void 0;_this13.y=void 0;_this13.w=void 0;_this13.h=void 0;_this13.isResized=void 0;_this13.__isDVertex=void 0;return _this13;}// DVoidVertex\n// static _super = DVoidVertex;\n// static singleton: LVertex;\n// static logic: typeof LVertex;\n// static structure: typeof DVertex;\n// inherit redefine\n// containedIn!: Pointer<DGraphElement, 0, 1, LGraphElement>;\n// size!: GraphSize; // virtual, gets extracted from this. x and y are stored directly here as it extends GraphSize\n// personal attributes\n_createClass(DVertex,null,[{key:\"new\",value:function _new(htmlindex,model,parentNodeID,graphID,nodeID,size){return new Constructors(new DVertex('dwc'),parentNodeID,true,undefined,nodeID).DPointerTargetable().DGraphElement(model,graphID,htmlindex).DVoidVertex(size||defaultVertexSize).DVertex().end();}}]);return DVertex;}(DGraphElement),_class18.subclasses=[],_class18._extends=[],_class18))||_class17);export var LVertex=(_dec10=RuntimeAccessible('LVertex'),_dec10(_class19=(_class20=/*#__PURE__*/function(_LVoidVertex2){_inherits(LVertex,_LVoidVertex2);var _super10=_createSuper(LVertex);function LVertex(){var _this14;_classCallCheck(this,LVertex);for(var _len11=arguments.length,args=new Array(_len11),_key11=0;_key11<_len11;_key11++){args[_key11]=arguments[_key11];}_this14=_super10.call.apply(_super10,[this].concat(args));_this14.__raw=void 0;_this14.id=void 0;_this14.graph=void 0;_this14.model=void 0;_this14.subElements=void 0;_this14.zoom=void 0;_this14.x=void 0;_this14.y=void 0;_this14.w=void 0;_this14.h=void 0;_this14.size=void 0;_this14.isResized=void 0;_this14.__isLVertex=void 0;return _this14;}// static singleton: LVertex;\n// static logic: typeof LVertex;\n// static structure: typeof DVertex;\n// inherit redefine\n_createClass(LVertex,[{key:\"isSelected\",value:// isSelected: Dictionary<DocString<Pointer<DUser>>, boolean> = {};\nfunction isSelected(forUser){return this.wrongAccessMessage(\"node.isSelected()\");}// containedIn?: LGraphElement;\n// virtual, gets extracted from this. x and y are stored directly here as it extends GraphSize\n// personal attributes\n}]);return LVertex;}(LVoidVertex),_class20.subclasses=[],_class20._extends=[],_class20))||_class19);RuntimeAccessibleClass.set_extend(DGraphElement,DVertex);RuntimeAccessibleClass.set_extend(LGraphElement,LVertex);export var DGraphVertex=(_dec11=RuntimeAccessible('DGraphVertex'),Leaf(_class21=_dec11(_class21=(_class22=/*#__PURE__*/function(_DGraphElement4){_inherits(DGraphVertex,_DGraphElement4);var _super11=_createSuper(DGraphVertex);function DGraphVertex(){var _this15;_classCallCheck(this,DGraphVertex);for(var _len12=arguments.length,args=new Array(_len12),_key12=0;_key12<_len12;_key12++){args[_key12]=arguments[_key12];}_this15=_super11.call.apply(_super11,[this].concat(args));_this15.id=void 0;_this15.graph=void 0;_this15.model=void 0;_this15.isSelected=void 0;_this15.subElements=void 0;_this15.zoom=void 0;_this15.offset=void 0;_this15.x=void 0;_this15.y=void 0;_this15.w=void 0;_this15.h=void 0;_this15.isResized=void 0;_this15.__isDVertex=void 0;_this15.__isDGraph=void 0;_this15.__isDGraphVertex=void 0;return _this15;}// MixOnlyFuncs(DGraph, DVertex)\n// static _super1 = DGraph;\n// static _super2 = DVertex;\n// static singleton: LGraphVertex;\n// static logic: typeof LGraphVertex;\n// static structure: typeof DGraphVertex;\n// inherit redefine\n// containedIn!: Pointer<DGraphElement, 0, 1, LGraphElement>;\n// from graph\n// in-graph scrolling position\n// from VoidVertex\n// size!: GraphSize; // virtual\n// from graph\n// personal attributes\n_createClass(DGraphVertex,null,[{key:\"new\",value:function _new(htmlindex,model,parentNodeID,graphID,nodeID,size){return new Constructors(new DGraphVertex('dwc'),parentNodeID,true,undefined,nodeID).DPointerTargetable().DGraphElement(model,graphID,htmlindex).DVoidVertex(size||defaultVertexSize).DVertex().DGraph().end();}/*\r\n        static init_constructor(thiss: DGraphVertex, isUser: boolean = false, nodeID: string | undefined, graphID: string | undefined, model: Pointer<DModel>): void {\r\n            DGraph.init_constructor(thiss, isUser, nodeID, graphID, model);\r\n    //isUser: boolean = false, nodeID: string | undefined, graphID: string, model?: Pointer<DModel>\r\n            DVertex.init_constructor(thiss, isUser, nodeID, graphID as string, model);\r\n            thiss.className = this.name;\r\n        }*/}]);return DGraphVertex;}(DGraphElement),_class22.subclasses=[],_class22._extends=[],_class22))||_class21)||_class21);var LG=/*#__PURE__*/function(_LGraph){_inherits(LG,_LGraph);var _super12=_createSuper(LG);function LG(){_classCallCheck(this,LG);return _super12.apply(this,arguments);}return LG;}(LGraph);var LV=/*#__PURE__*/function(_LVertex){_inherits(LV,_LVertex);var _super13=_createSuper(LV);function LV(){_classCallCheck(this,LV);return _super13.apply(this,arguments);}return LV;}(LVertex);var Mixed=MixOnlyFuncs(LG,LV);export var LGraphVertex=(_dec12=RuntimeAccessible('LGraphVertex'),_dec12(_class23=(_class24=/*#__PURE__*/function(_Mixed){_inherits(LGraphVertex,_Mixed);var _super14=_createSuper(LGraphVertex);function LGraphVertex(){var _this16;_classCallCheck(this,LGraphVertex);for(var _len13=arguments.length,args=new Array(_len13),_key13=0;_key13<_len13;_key13++){args[_key13]=arguments[_key13];}_this16=_super14.call.apply(_super14,[this].concat(args));_this16.__raw=void 0;_this16.id=void 0;_this16.graph=void 0;_this16.model=void 0;_this16.zoom=void 0;_this16.offset=void 0;_this16.graphSize=void 0;_this16.x=void 0;_this16.y=void 0;_this16.w=void 0;_this16.h=void 0;_this16.isResized=void 0;_this16.size=void 0;_this16.__isLVertex=void 0;_this16.__isLGraph=void 0;_this16.__isLGraphVertex=void 0;return _this16;}// MixOnlyFuncs(LGraph, LVertex)\n// static singleton: LGraphVertex;\n// static logic: typeof LGraphVertex;\n// static structure: typeof DGraphVertex;\n// inherit redefine\n_createClass(LGraphVertex,[{key:\"isSelected\",value:// isSelected: Dictionary<DocString<Pointer<DUser>>, boolean> = {};\nfunction isSelected(forUser){return this.wrongAccessMessage(\"node.isSelected()\");}// containedIn?: LGraphElement;\n///////////////////////////////////////// subElements!: LGraphElement[];\n// from graph\n// in-graph scrolling position\n// internal size of the graph. can be huge even if the sub-graph is in a small window (scroll)\n// from VoidVertex\n// virtual\n// personal attributes\n}]);return LGraphVertex;}(Mixed),_class24.subclasses=[],_class24._extends=[],_class24))||_class23);RuntimeAccessibleClass.set_extend(DGraph,DGraphVertex);RuntimeAccessibleClass.set_extend(DVertex,DGraphVertex);RuntimeAccessibleClass.set_extend(LGraph,LGraphVertex);RuntimeAccessibleClass.set_extend(LVertex,LGraphVertex);export var DVoidEdge=(_dec13=RuntimeAccessible('DVoidEdge'),_dec13(_class25=(_class26=/*#__PURE__*/function(_DGraphElement5){_inherits(DVoidEdge,_DGraphElement5);var _super15=_createSuper(DVoidEdge);function DVoidEdge(){var _this17;_classCallCheck(this,DVoidEdge);for(var _len14=arguments.length,args=new Array(_len14),_key14=0;_key14<_len14;_key14++){args[_key14]=arguments[_key14];}_this17=_super15.call.apply(_super15,[this].concat(args));_this17.id=void 0;_this17.graph=void 0;_this17.model=void 0;_this17.isSelected=void 0;_this17.subElements=void 0;_this17.start=void 0;_this17.end=void 0;_this17.__isDVoidEdge=void 0;_this17.midPoints=void 0;_this17.midnodes=void 0;_this17.longestLabel=void 0;_this17.labels=void 0;_this17.anchorStart=void 0;_this17.anchorEnd=void 0;return _this17;}// static singleton: LVoidEdge;\n// static logic: typeof LVoidEdge;\n// static structure: typeof DVoidEdge;\n// isSelected: Dictionary<DocString<Pointer<DUser>>, boolean> = {};\n// containedIn!: Pointer<DGraphElement, 0, 1, LGraphElement>;\n// personal attributes\n// the logic part which instructs to generate the midnodes\n// using subelements instead most of times\n// endFollow!: boolean; they became derived attributes from static properties\n// startFollow!: boolean;\n_createClass(DVoidEdge,null,[{key:\"new\",value:function _new(htmlindex,model,parentNodeID,graphID,nodeID,start,end,longestLabel,labels){return new Constructors(new DEdge('dwc'),parentNodeID,true,undefined,nodeID).DPointerTargetable().DGraphElement(model,graphID,htmlindex).DVoidEdge(start,end,longestLabel,labels).end();}},{key:\"new2\",value:function new2(model,parentNodeID,graphID,nodeID,start,end,setter){return new Constructors(new DEdge('dwc'),parentNodeID,true,undefined,nodeID).DPointerTargetable().DGraphElement(model,graphID).DVoidEdge(start,end).end(setter);}}]);return DVoidEdge;}(DGraphElement),_class26.subclasses=[],_class26._extends=[],_class26.isFollowingCoords=void 0,_class26))||_class25);/*\r\n@RuntimeAccessible\r\nexport class MidPoint{\r\n    readonly id: string; // not really a pointer, it's not on store.\r\n    x?: number; y?: number;\r\n    readonly w?: number; // if it's modified it's not ever here (initial size) but on DEdgePoint that is a Node.\r\n    readonly h?: number;/*\r\n    constructor2(x: number=5, y: number=5, w: number=5, h: number=5) {\r\n        this.x = x;\r\n        this.y = y;\r\n        this.w = w;\r\n        this.h = h;\r\n    }* /\r\nconstructor(id: string, w: number=5, h: number=5) {\r\n    this.id = id;\r\n    this.w = w;\r\n    this.h = h;\r\n}\r\n}*/export var EdgeSegment=(_dec14=RuntimeAccessible('EdgeSegment'),_dec14(_class27=/*#__PURE__*/function(){//  a segment of the whole path\n// m coefficient of the line between start and end.\n// for head and tails: radian angle of the segment.\n// for labels: it flips the angle when it's < PI/2 so the text is never upside down\n/*constructor(label: PrimitiveType|undefined, length: number, startp: GraphPoint, endp: GraphPoint, start: LGraphElement, end: LGraphElement,\r\n                bezierpts: GraphPoint[], mid: LGraphElement[],\r\n                svgLetter: EdgeBendingMode, index: number, fillMode: MidNodeHandling) {\r\n        this.label = label;\r\n        this.length = length;\r\n        this.length = length;\r\n        this.startp = startp;\r\n        this.bezierp = bezierpts;\r\n        this.endp = endp;\r\n        this.start = start;\r\n        this.end = end;\r\n        this.mid = mid;\r\n    }*/function EdgeSegment(start,mid,end,svgLetter,gapMode,index,prevSegment){_classCallCheck(this,EdgeSegment);this.index=void 0;this.prev=void 0;this.start=void 0;this.bezier=void 0;this.end=void 0;this.length=void 0;this.d=void 0;this.dpart=void 0;this.m=void 0;this.rad=void 0;this.radLabels=void 0;this.isLongest=void 0;this.label=void 0;this.svgLetter=void 0;// console.log(\"segmentmaker:\", arguments, ((start.ge?.model as any)?.name)+\" ---> \" + ((end.ge?.model as any)?.name));\nthis.start=start;this.bezier=mid;this.end=end;this.index=index;this.prev=prevSegment;//this.segments = segments;\n// the idea: forbid all T and S or transform them in C, Q by calculating and manually adding their mirrored bezier pts\n// if (svgLetter[1]) svgLetter = (svgLetter[0]) as any;\nif(svgLetter===EdgeBendingMode.Bezier_QT){this.svgLetter=EdgeBendingMode.Bezier_QT[0];// this.svgLetter = (index === 0 ? EdgeBendingMode.Bezier_QT[0] : EdgeBendingMode.Bezier_QT[1]) as any as EdgeBendingMode;\nthis.addBezierPoint();}else if(svgLetter===EdgeBendingMode.Bezier_CS){this.svgLetter=EdgeBendingMode.Bezier_CS[0];// this.svgLetter = (index === 0 ? EdgeBendingMode.Bezier_CS[0] : EdgeBendingMode.Bezier_CS[1]) as any as EdgeBendingMode;\nthis.addBezierPoint();}else this.svgLetter=svgLetter;// fix if amount of bezier pts is invalid for current letter\nswitch(this.svgLetter){case EdgeBendingMode.Line:case EdgeBendingMode.Bezier_quadratic:if(this.bezier.length>=1)break;else this.svgLetter=EdgeBendingMode.Line;break;case EdgeBendingMode.Bezier_cubic:if(this.bezier.length>=2)break;else if(this.bezier.length>=1)this.svgLetter=EdgeBendingMode.Bezier_quadratic;else this.svgLetter=EdgeBendingMode.Line;break;case EdgeBendingMode.Elliptical_arc:if(this.bezier.length>=3)break;else this.svgLetter=EdgeBendingMode.Line;// straight to end ignoring midpoints that are NOT coordinates when using elliptical arc.\nbreak;default://case EdgeBendingMode.Bezier_quadratic_mirrored as string:\n//case EdgeBendingMode.Bezier_cubic_mirrored as string: // translated to Q or C by adding mirrored bezier points explicitly\ncase EdgeBendingMode.Bezier_QT:case EdgeBendingMode.Bezier_CS:// translated to Q or C by sending the right letter to each segment\nLog.exDevv(\"this svg letter should not appear here\",this.svgLetter);break;}}_createClass(EdgeSegment,[{key:\"addBezierPoint\",value:function addBezierPoint(){var prev=this.prev;if(!prev)return;var prevedgemakerbezier=prev.bezier[prev.bezier.length-1]||prev.start;var mirroredBezier=_objectSpread(_objectSpread({},prevedgemakerbezier),{},{pt:EdgeSegment.invertLastBezierPt(prevedgemakerbezier.pt,prev.end.pt),uncutPt:EdgeSegment.invertLastBezierPt(prevedgemakerbezier.uncutPt,prev.end.uncutPt)});this.bezier=[mirroredBezier].concat(_toConsumableArray(this.bezier));// always only 1 assumed pt both in cubic and quadratic.\n// let next: this | undefined = this.segments[this.index+1];\n// EdgeSegment.invertLastBezierPt((next.mid[1] || next.end).pt, next.start.pt);\n}},{key:\"makeD\",value:function makeD(index,gapMode){this.m=GraphPoint.getM(this.start.pt,this.end.pt);this.rad=Geom.mToRad(this.m,this.start.pt,this.end.pt);this.radLabels=Math.atan(this.m);var svgLetter=this.svgLetter;// caller makes sure to pass right letter and resolve \"CS\" mixed letters. // this.bendingModeToLetter(bendingMode, index);\n// caller sends inverted pts as normal coords\n// let invertedBezPt = lastSegment && EdgeSegment.invertLastBezierPt(lastSegment.midp[lastSegment.mid.length-1] || lastSegment.startp, lastSegment.endp);\nswitch(this.svgLetter.length){case 2:return Log.exDevv(\"mixed letters are not allowed and should have been resolved to single svg letters before here, found:\"+svgLetter);/*return Log.exDevv(\"dev problem to fix:\\n\" +\r\n            \"the mirrored mode requires the first one to have explicit non-mirrored mode?? like M, C a1 a2 a3, S a1, S a1, S a1\\n\" +\r\n            \"So all segments with mixed modes needs to extract the last bezier point (penultimate coordinate) from previous segments, mirror it and insert in midp[0]\");*/case 1:var bezierpts=[].concat(_toConsumableArray(this.bezier.map(function(b){return b.pt;})),[this.end.pt]);var finalpart=svgLetter+\" \"+bezierpts.map(function(p){return p.x+\" \"+p.y;}).join(\", \");this.dpart=\"M \"+this.start.pt.x+\" \"+this.start.pt.y+\", \"+finalpart;var bezierptsUncut=[].concat(_toConsumableArray(this.bezier.map(function(b){return b.uncutPt;})),[this.end.pt]);// uncutPt exist for start and end too, but i want to use the cut one for those. or edgehead is off\nvar finalpartUncut=svgLetter+\" \"+bezierptsUncut.map(function(p){return p.x+\" \"+p.y;}).join(\", \");this.d=(index===0?\"M\"+this.start.pt.x+\" \"+this.start.pt.y+\", \":\"\")+finalpartUncut;//midp = [this.startp, ...this.midp];\n// d = M sp X mp2 ep // X = custom letter\n// dpart = T sp X mp2 ep // S = S if X = C,\n// sp is the startingpoint from the prev node, which might be != from endpoint of last node if last node have w>0 && h>0\n// so i'm \"filling\" the gap with a T, or L arc wich can use only 1 parameter (they are the only 1-parameter arcs)\n// if (this.prev && this.prev.end.pt.equals(this.start.pt)) gapMode = EdgeGapMode.average; // if the 2 points coincide, i use any 1 of the gapmodes that are continuous\n/*switch (gapMode){\r\n                    case EdgeGapMode.center:\r\n                    case EdgeGapMode.average:\r\n                        // continuous gap modes. they only differ in how the \"joining\" point is found, but not in how they behave after that.\r\n                        /*\r\n                        if (index === 0) {\r\n                             startletter = \"M \";\r\n                         }\r\n                         else {\r\n                             switch (svgLetter) {\r\n                                 case SvgLetter.A: case SvgLetter.C: case SvgLetter.S: case SvgLetter.Q: case SvgLetter.T: default:\r\n                                     startletter = SvgLetter.T + \" \"; break;\r\n                                 case SvgLetter.L: case SvgLetter.M:\r\n                                     startletter = SvgLetter.L + \" \"; break;\r\n                             }\r\n                         }* /\r\n                        if (index) {\r\n                            this.d = finalpart;\r\n                        }\r\n                        else { this.d = this.dpart; }\r\n                        break;\r\n                    case EdgeGapMode.gap:\r\n                    case EdgeGapMode.autoFill:\r\n                    case EdgeGapMode.lineFill:\r\n                    case EdgeGapMode.arcFill:\r\n                        // the filling itself is done by another segment (solving svg letter and simulating i=0), so i treat it as a gap.\r\n                        this.d = this.dpart;\r\n                        break;\r\n                    default:\r\n                        Log.exDevv(\"unexpected EdgeGapMode:\" + gapMode, {gapMode});\r\n                }*/break;default:return Log.exDevv(\"unexpected bending mode length:\"+this.svgLetter+\" or fillMode: \"+gapMode,{bendingMode:this.svgLetter,index:index,gapMode:gapMode});}//using\n/*\r\n        88\r\n\r\n        // d should not have M set (except for segments[0]\r\n        // dpart have M abd beed to add explicit points for \"mirroring\" and transforming bezier quadratic mirrored in bezier quadratic normal etc.\r\n        //88 problem: the mirrored mode requires the first one to have explicit nonmirrored mode?? like M, C a1 a2 a3, S a1, S a1, S a1 .... ?\r\n        in any case the % letter part is wrong because it needs to subtract first element used for M*/return this.d;}},{key:\"calcLength\",value:function calcLength(){this.length=this.start.pt.distanceFromPoint(this.end.pt);}}],[{key:\"invertLastBezierPt\",value:function invertLastBezierPt(bezier,end){// vector = bezier - end\n// end + vector = bezier\n// end - vector = inverted bezier? = 2*end-bezier\nvar vector=bezier.subtract(end,true);return end.subtract(vector,true);}}]);return EdgeSegment;}())||_class27);export var EdgeFillSegment=/*#__PURE__*/function(_EdgeSegment){_inherits(EdgeFillSegment,_EdgeSegment);var _super16=_createSuper(EdgeFillSegment);function EdgeFillSegment(){_classCallCheck(this,EdgeFillSegment);return _super16.apply(this,arguments);}_createClass(EdgeFillSegment,[{key:\"makeD\",value:function makeD(index,gapMode){// if (gapMode === EdgeGapMode.autoFill) { gapMode = this.svgLetter === EdgeBendingMode.Line ? EdgeGapMode.lineFill : EdgeGapMode.arcFill; }\nswitch(gapMode){case\"closest\":// EdgeGapMode.closest:\ncase EdgeGapMode.center:case EdgeGapMode.average:case EdgeGapMode.gap:return\"\";// should not have filler arcs\ndefault:/*\r\n            case EdgeGapMode.autoFill as any:\r\n            case EdgeGapMode.lineFill:\r\n                this.bezier = [];\r\n                this.svgLetter = EdgeBendingMode.Line;\r\n                return super.makeD(index, gapMode);\r\n            case EdgeGapMode.arcFill:*/this.svgLetter=this.svgLetter[0];if(this.svgLetter===\"Q\")this.bezier=this.bezier.length?[this.bezier[0]]:[];return _get(_getPrototypeOf(EdgeFillSegment.prototype),\"makeD\",this).call(this,index,gapMode);}}}]);return EdgeFillSegment;}(EdgeSegment);EdgeFillSegment.cname=\"EdgeFillSegment\";export var LVoidEdge=(_dec15=RuntimeAccessible('LVoidEdge'),_dec15(_class29=(_class30=/*#__PURE__*/function(_LGraphElement3){_inherits(LVoidEdge,_LGraphElement3);var _super17=_createSuper(LVoidEdge);function LVoidEdge(){var _this18;_classCallCheck(this,LVoidEdge);for(var _len15=arguments.length,args=new Array(_len15),_key15=0;_key15<_len15;_key15++){args[_key15]=arguments[_key15];}_this18=_super17.call.apply(_super17,[this].concat(args));_this18.__raw=void 0;_this18.id=void 0;_this18.graph=void 0;_this18.model=void 0;_this18.subElements=void 0;_this18.start=void 0;_this18.end=void 0;_this18.__isLVoidEdge=void 0;_this18.midPoints=void 0;_this18.midnodes=void 0;_this18.edge=void 0;_this18.__info_of__edge={type:\"?LEdge\",txt:\"returns this if called on an edge, the containing edge if called on an EdgePoint, undefined otherwise.\"};_this18.label=void 0;_this18.longestLabel=void 0;_this18.labels=void 0;_this18.allNodes=void 0;_this18.__info_of__longestLabel={label:\"Longest label\",type:\"function(edge)=>string | string\",readType:\"PrimitiveType\",writeType:\"PrimitiveType | (e:this, curr: LGraphElement, next: LGraphElement, curr_index: number, allNodes: LGraphElement[]) => PrimitiveType)\",txt:/*#__PURE__*/_jsx(\"span\",{children:\"Label assigned to the longest path segment.\"})};_this18.__info_of__label={type:\"\",txt:/*#__PURE__*/_jsx(\"span\",{children:\"Alias for longestLabel\"})};_this18.__info_of__labels={label:\"Multiple labels\",type:\"function(edge)=>string | string\",writeType:\"type of label or Array<type of label>\",txt:/*#__PURE__*/_jsx(\"span\",{children:\"Instructions to label to multiple or all path segments in an edge\"})};_this18.__info_of__allNodes={type:\"[LGraphElement, ...Array<LEdgePoint>, LGraphElement]\",txt:/*#__PURE__*/_jsx(\"span\",{children:\"first element is this.start. then all this.midnodes. this.end as last element\"})};_this18.__info_of__startPoint={type:\"GraphPoint\",txt:/*#__PURE__*/_jsx(\"span\",{children:\"startPoint of this.start (element originating the edge). Defaults in outer coordinates.\"})};_this18.__info_of__endPoint={type:\"GraphPoint\",txt:/*#__PURE__*/_jsx(\"span\",{children:\"endPoint of this.end (element originating the edge). Defaults in outer coordinates.\"})};_this18.segments=void 0;_this18.segments_inner=void 0;_this18.segments_outer=void 0;_this18.__info_of__segments={type:\"{all:T, segments:T, fillers:T, head: GraphSize&{rad:number}, tail: as head} where T is EdgeSegment\",txt:/*#__PURE__*/_jsxs(\"span\",{children:[\"Collection of segments connecting in order vertex and EdgePoint without intersecting their area, aimed to be rendered in svg path.\",/*#__PURE__*/_jsx(\"br\",{}),\"fillers are arcs generated by view.edgeGapMode being autofill, arcfill or linefill.\",/*#__PURE__*/_jsx(\"br\",{}),\"length of this.segments array is Math.ceil(allNodes.length / svg_letter_size) specified on view.\",/*#__PURE__*/_jsx(\"br\",{}),\"\\\"head\\\" and \\\"tail\\\" are the position and angle of eventual edge decorators. Refer to this.headPos documentation.\"]})};_this18.d=void 0;_this18.__info_of__d={type:ShortAttribETypes.EString,txt:\"the full suggested path of SVG path \\\"d\\\" attribute, merging all segments.\"};_this18.anchorStart=void 0;_this18.anchorEnd=void 0;_this18.__info_of__anchorStart={writeType:\"string | undefined\",type:\"string\",isEdge:true,txt:\"The name of a node anchor where the edge should originate from.\"};_this18.__info_of__anchorEnd={writeType:\"string | undefined\",type:\"string\",isEdge:true,txt:\"The name of a node anchor where the edge should point to.\"};_this18.endFollow=void 0;_this18.startFollow=void 0;_this18.__info_of__endFollow={writeType:\"boolean\",readType:\"boolean\",type:\"boolean\",isEdge:true,// type:\"read:(()=>void), write:boolean\", readType:\"(()=>void))\",\ntxt:\"makes the ending point of an edge follow the cursor, so it can be assigned to a new anchor or target.\"};_this18.__info_of__startFollow={writeType:\"boolean\",readType:\"boolean\",type:\"boolean\",isEdge:true,// type:\"read:(()=>void), write:boolean\", readType:\"(()=>void))\",\ntxt:\"makes the starting point of an edge follow the cursor, so it can be assigned to a new anchor or source.\"};return _this18;}// static singleton: LVoidEdge;\n// static logic: typeof LVoidEdge;\n// static structure: typeof DVoidEdge;\n_createClass(LVoidEdge,[{key:\"isSelected\",value:// isSelected: Dictionary<DocString<Pointer<DUser>>, boolean> = {};\nfunction isSelected(forUser){return this.wrongAccessMessage(\"node.isSelected()\");}// containedIn?: LGraphElement;\n// the logic part which instructs to generate the midnodes\n// returns self. useful to get edge from edgePoints without triggering error if you are already on edge.\n/*\r\nreplaced by startPoint\r\n    edgeStart!: GraphPoint;\r\n    edgeStart_inner!: GraphPoint;\r\n    edgeStart_outer!: GraphPoint;\r\n    __info_of__edgeStart: Info = {type: \"GraphPoint\", txt: \"Same as edgeStart_outer.\"}\r\n    __info_of__edgeStart_outer: Info = {type: \"GraphPoint\",\r\n     txt: \"Where the edge should start his path, in coordinates relative at the root Graph.\r\n     <br>Computed by combining the anchor offset option in View and the size of the starting node.\"}\r\n    __info_of__edgeStart_inner: Info = {type: \"GraphPoint\",\r\n     txt: \"Where the edge should start his path, in coordinates relative at the most nested Graph.\r\n     <br>Computed by combining the anchor offset option in View and the size of the starting node.\"}\r\n    edgeEnd!: GraphPoint;\r\n    edgeEnd_inner!: GraphPoint;\r\n    edgeEnd_outer!: GraphPoint;\r\n    __info_of__edgeEnd: Info = {type: \"GraphPoint\", txt: \"Same as edgeEnd_outer.\"}\r\n    __info_of__edgeEnd_outer: Info = {type: \"GraphPoint\",\r\n     txt: \"Where the edge should end his path, in coordinates relative at the root Graph.\r\n     <br>Computed by combining the anchor offset option in View and the size of the starting node.\"}\r\n    __info_of__edgeEnd_inner: Info = {type: \"GraphPoint\",\r\n     txt: \"Where the edge should end his path, in coordinates relative at the most nested Graph.\r\n     <br>Computed by combining the anchor offset option in View and the size of the starting node.\"}\r\n*/ // should never be read change their documentation in write only. their values is \"read\" in this.segments\n},{key:\"get_label\",value:function get_label(c){return this.get_longestLabel(c);}},{key:\"set_label\",value:function set_label(val,c){return this.set_longestLabel(val,c);}},{key:\"get_longestLabel\",value:function get_longestLabel(c){return c.data.longestLabel;}},{key:\"set_longestLabel\",value:function set_longestLabel(val,c){SetFieldAction.new(c.data,\"longestLabel\",val);return true;}},{key:\"get_labels\",value:function get_labels(c){return c.data.labels;}},{key:\"set_labels\",value:function set_labels(val,c){SetFieldAction.new(c.data,\"labels\",val);return true;}},{key:\"headPos_impl\",value:function headPos_impl(c,isHead,headSize0,segment0,zoom0){var segment=segment0||this.get_segments(c).segments[0];// let v: LViewElement = this.get_view(c);\nvar tmp=headSize0||(isHead?this.get_view(c).edgeHeadSize:this.get_view(c).edgeTailSize);if(!tmp||tmp.x===0||tmp.y===0){// head or tail missing\ntmp=new GraphSize(0,0,0,0);tmp.rad=0;return tmp;}var zoom=zoom0||this.get_graph(c).zoom;var headPos=new GraphSize(0,0,tmp.x,tmp.y);//.multiply({w:zoom.x, h:zoom.y});\nvar useBezierPoints=true;var start,end;var m;if(useBezierPoints){if(isHead){start=segment.end.pt;end=(segment.bezier[segment.bezier.length-1]||segment.start).pt;}else{start=segment.start.pt;end=(segment.bezier[0]||segment.end).pt;}m=GraphPoint.getM(start,end);}else{if(isHead){start=segment.end.pt;end=segment.start.pt;}else{start=segment.start.pt;end=segment.end.pt;}m=segment.m;}// first find the center of where it should be positioned\n// let center: GraphPoint;\n// let distance: number = Math.sqrt(headPos.w*headPos.w + headPos.h*headPos.h);\n// let isVertical = m >=1 ;\nvar x4headsize=new GraphSize(start.x-headPos.w,start.y-headPos.h,headPos.w*2,headPos.h*2);// first intersection is segment origin. second is found with the box containing all possible edgeHead positions that touch the startPoint\n// (doing x4 his shape and placing 4 \"rectangles\" all around startPoint) to cover all possible segment directions.\n// or finding first direction (vertical if m >1, horizontal if m<0) and vector direction and intersecting with only the \"correct\" placed edgeHead rectangle.\n// then the intersection will likely not fall on the extreme angle of EdgeHead and i can re-center edgeHead\n// so that first and second intersections are equal spaced with the center segment\nvar secondIntersection;var segmentDistance=start.distanceFromPoint(end);if(segmentDistance<=Math.sqrt(Math.pow(headPos.w,2)+Math.pow(headPos.h,2))){var safeDistance=Math.max(headPos.w,headPos.h)*5;end=new GraphPoint(end.y+safeDistance,end.y+m*safeDistance);// move the point away so it doesn't intersect anymore. i just need direction\n// too small to fit edgeHead, i simply put it centered on the whole segment\n// secondIntersection = end;\n}secondIntersection=GraphSize.closestIntersection(x4headsize,start,end,undefined);if(!secondIntersection)return Log.exx(\"failed to intersect edge head\",{x4headsize:x4headsize,segment:segment,headPos:headPos,c:c,start:start,end:end,useBezierPoints:useBezierPoints});tmp=secondIntersection.add(start,false).divide(2);// center of edgehead\nheadPos.x=tmp.x-headPos.w/2;// tl corner\nheadPos.y=tmp.y-headPos.h/2;// tl corner\nheadPos.rad=Geom.mToRad(m,start,end);/*\r\n        devo trovare la distanza tra il centro dell'egeHead e il punto di inizio in termini assoluti, così tramite M trovo distanza in x e y. o trovarla in altro modo\r\n        if (segment.m === Number.POSITIVE_INFINITY || segment.m === Number.NEGATIVE_INFINITY) {\r\n            center = segment.start.pt.add({x:0, y: distance}, true); }\r\n        else { center = segment.start.pt.add({x:segment.m*headPos.w/2, y:segment.m*headPos.h/2\r\n         this is wrong, cannot be the same for x and y, i should invert the line equation for x?}, true); }\r\n        headPos.x = center.x - headPos.w / 2;\r\n        headPos.y = center.y - headPos.h / 2;*/ // console.log(\"head intersected\", {headPos, secondIntersection, x4headsize, segment, c, start, end, useBezierPoints});\nreturn headPos;}},{key:\"headPos\",value:function headPos(headSize0,segment0,zoom0){return this.wrongAccessMessage(\"This is not headPos() implementation. it is just for typings. use the getter\");}},{key:\"tailPos\",value:function tailPos(headSize0,segment0,zoom0){return this.wrongAccessMessage(\"This is not tailPos() implementation. it is just for typings. use the getter\");}},{key:\"get_headPos\",value:function get_headPos(c){var _this19=this;return function(headSize,segment,zoom){return _this19.headPos_impl(c,true,headSize,segment,zoom);};}},{key:\"get_tailPos\",value:function get_tailPos(c){var _this20=this;return function(headSize,segment,zoom){return _this20.headPos_impl(c,false,headSize,segment,zoom);};}},{key:\"get_allNodes\",value:function get_allNodes(c){return[this.get_start(c)].concat(_toConsumableArray(this.get_midnodes(c)),[this.get_end(c)]);}},{key:\"get_edge\",value:function get_edge(c){return c.proxyObject;}},{key:\"set_edge\",value:function set_edge(v,c){return this.cannotSet(\"edge field, on an edge element\");}},{key:\"get_midPoints\",value:function get_midPoints(c){return c.data.midPoints;}},{key:\"addMidPoint\",value:function addMidPoint(v){return this.wrongAccessMessage(\"addMidPoint\");}},{key:\"get_addMidPoint\",value:function get_addMidPoint(c){var _this21=this;return function(v){return _this21.impl_addMidPoints(v,c);};}},{key:\"set_midPoints\",value:function set_midPoints(val,c){return SetFieldAction.new(c.data.id,\"midPoints\",val,undefined,false);}},{key:\"impl_addMidPoints\",value:function impl_addMidPoints(val,c){return SetFieldAction.new(c.data.id,\"midPoints\",val,'+=',false);}},{key:\"get_label_impl\",value:function get_label_impl(c,segment,nodes,segments){var key=segment.isLongest?\"longestLabel\":\"labels\";// : keyof this\n// if (isLongestSegment) return this.get_longestLabel_impl(d, l, nodes, index):\nvar d=c.data;var l=c.proxyObject;var labelmaker=d[key];// orArr<PrimitiveType | JSX | function>\nvar labelmakerfunc=labelmaker;// let lastSeg = segments[i-1];\nswitch(typeof labelmaker){//nb{}[]<>\ncase\"number\":case\"undefined\":case\"boolean\":case\"string\":return labelmaker;// case \"function\": return nodes.map( (o, i) => d.labels(l, nodes, i)).slice(0, nodes.length-1);\ncase\"function\":return labelmakerfunc(l,segment,nodes,segments);default:break;case\"object\":if(labelmaker===null)return null;if(!Array.isArray(labelmaker))break;if(typeof labelmaker[0]===\"function\")return labelmaker[segment.index%labelmaker.length](l,segment,nodes,segments);return labelmaker[segment.index%labelmaker.length];}Log.exx(\"edge labels invalid type, must be a primitive value, a function or an array of such.\",{labelmaker:labelmaker,key:key,d:d});return undefined;}/*\r\n    private get_label_impl_old(d: DVoidEdge, l: LVoidEdge, nodes:this[\"allNodes\"], index: number, longestlabelindex?: number): PrimitiveType {\r\n        if (d.longestLabel !== undefined && index === longestlabelindex) return this.get_longestLabel_impl(d, l, nodes, index);\r\n        switch (typeof d.labels) {//nb{}[]<>\r\n            case \"number\":\r\n            case \"undefined\":\r\n            case \"boolean\":\r\n            case \"string\": return d.labels;\r\n            // case \"function\": return nodes.map( (o, i) => d.labels(l, nodes, i)).slice(0, nodes.length-1);\r\n            case \"function\": return d.labels(l, nodes[index], nodes[index+1], index, nodes);\r\n            default: break;\r\n            case \"object\": if (!Array.isArray(d.labels)) break;\r\n            if (typeof d.labels[0] === \"function\") return (d.labels as any)[index % d.labels.length](l, nodes[index], nodes[index+1], index, nodes);\r\n            return (d.labels as PrimitiveType[])[index % d.labels.length];\r\n        }\r\n        Log.exx(\"edge labels invalid type, must be a primitive value, a function or an array of such.\", d.labels);\r\n    }*/},{key:\"get_startPoint\",value:function get_startPoint(context){return this.get_startPoint_Outer(context);}},{key:\"get_endPoint\",value:function get_endPoint(context){return this.get_endPoint_Outer(context);}},{key:\"get_startPoint_Outer\",value:function get_startPoint_Outer(c){// console.log(\"get_edgeStart_Outer\", {out:this.get_outerGraph(c), pos:this.get_startPoint_inner(c), inner:this.get_start(c).innerGraph});\nreturn this.get_outerGraph(c).translateSize(this.get_startPoint_inner(c),this.get_start(c).innerGraph);}},{key:\"get_endPoint_Outer\",value:function get_endPoint_Outer(c){// console.log(\"get_edgeEnd_Outer\", {out:this.get_outerGraph(c), pos:this.get_endPoint_inner(c), inner:this.get_end(c).innerGraph});\nreturn this.get_outerGraph(c).translateSize(this.get_endPoint_inner(c),this.get_end(c).innerGraph);}},{key:\"get_startPoint_inner\",value:function get_startPoint_inner(c){return this.get_edgeStartEnd_inner(c,true);}},{key:\"get_endPoint_inner\",value:function get_endPoint_inner(c){return this.get_edgeStartEnd_inner(c,false);}},{key:\"get_edgeStartEnd_inner\",value:function get_edgeStartEnd_inner(c,isStart){return isStart?this.get_start(c).startPoint:this.get_end(c).endPoint;}},{key:\"svgLetterSize\",value:function svgLetterSize(s){var addM=arguments.length>1&&arguments[1]!==undefined?arguments[1]:true;var doublingMidPoints=arguments.length>2&&arguments[2]!==undefined?arguments[2]:true;var ret;switch(s){default:ret=Log.exDevv(\"unexpected svg path letter: \\\"\"+s+\"\\\"\",s);break;case EdgeBendingMode.Line://case EdgeBendingMode.Bezier_quadratic_mirrored:\nret={first:1,others:1};break;case EdgeBendingMode.Bezier_quadratic://case EdgeBendingMode.Bezier_cubic_mirrored:\nret={first:2,others:2};break;case EdgeBendingMode.Bezier_cubic:ret={first:3,others:3};break;case EdgeBendingMode.Elliptical_arc:ret={first:4,others:4};break;case EdgeBendingMode.Bezier_QT:ret={first:2,others:1};break;case EdgeBendingMode.Bezier_CS:ret={first:3,others:2};break;}// account for the fact that every midpoint is listed twice: at anchor start and anchor end.\nif(doublingMidPoints){// removing last point (first is already excluded because addM didn't trigger yet)\n// , the remaining are midpoints to double. then i add it back\nret.first=(ret.first-1)*2+1;ret.others=(ret.others-1)*2+1;}// account for the first M letter\n//    (if the segment is not mode.gap or first, M coord still exist in segment but are ignored)\nif(addM){ret.first+=1;ret.others+=1;}return ret;}},{key:\"get_points_impl\",value:function get_points_impl(allNodes,outer,c){function getAnchorOffset(size,offset,isPercentage){var $factor=arguments.length>3&&arguments[3]!==undefined?arguments[3]:100;if(!size)size=new GraphSize(0,0,0,0);// else if (!size.tl) size = new GraphSize(size.x, size.y, size.w, size.h);\nif(isPercentage)offset=new GraphPoint(offset.x/$factor*size.w,offset.y/$factor*size.h);return size.tl().add(offset,false);}var all=allNodes.flatMap(function(ge,i){var dge=ge.__raw;var base={view:ge.view,size:outer?ge.outerSize:ge.innerSize,ge:ge,pt:null,uncutPt:null};Log.exDev(typeof base.size!==\"object\",\"could not get node size:\",{base:base,c:c,outer:outer});var rets;// = base as any;\nvar rete;// = {...base} as any;\nvar debug=true;if(debug){base.anchor_e=dge.anchors[c.data.anchorEnd||0]||dge.anchors[Object.keys(dge.anchors)[0]];base.anchor_s=dge.anchors[c.data.anchorStart||0]||dge.anchors[Object.keys(dge.anchors)[0]];}// get endpoint, then startpoint (land on midnode, then depart from it)\nif(i!==0){rete=_objectSpread({rete:true},base);if(i===allNodes.length-1){// get end anchor from node\nvar anchor=dge.anchors[c.data.anchorEnd||0];if(!anchor)anchor=dge.anchors[Object.keys(dge.anchors)[0]];if(anchor)rete.pt=getAnchorOffset(rete.size,anchor,true,1);}// if no anchor, treat the node as a midpoint\nif(!rete.pt){// get ending point from midpoint\n//rete.pt = (LEdgePoint.singleton as LEdgePoint).get_endPoint(undefined as any, rete.size, rete.view);\nrete.pt=getAnchorOffset(rete.size,rete.view.edgeStartOffset,rete.view.edgeStartOffset_isPercentage);}rete.uncutPt=rete.pt;}if(i!==allNodes.length-1){rets=_objectSpread({rets:true},base);if(i===0){// get start anchor from node\nvar _anchor=dge.anchors[c.data.anchorStart||0];if(!_anchor)_anchor=dge.anchors[Object.keys(dge.anchors)[0]];if(_anchor)rets.pt=getAnchorOffset(rets.size,_anchor,true,1);}if(!rets.pt){// rets starting point from midpoint\n// rets.pt = (LEdgePoint.singleton as LEdgePoint).get_startPoint(undefined as any, rets.size, rets.view);\nrets.pt=getAnchorOffset(rets.size,rets.view.edgeStartOffset,rets.view.edgeStartOffset_isPercentage);}rets.uncutPt=rets.pt;}// ret.pt = ge.startPoint\nreturn rets&&rete?[rete,rets]:rets?[rets]:[rete];});if(DVoidEdge.isFollowingCoords){if(c.data.id===LVoidEdge.endFollow){var seg=all[all.length-1];seg.pt=DVoidEdge.isFollowingCoords;seg.size=new GraphSize(seg.pt.x,seg.pt.y,0.01,0.01);}if(c.data.id===LVoidEdge.startFollow){var _seg=all[0];_seg.pt=DVoidEdge.isFollowingCoords;_seg.size=new GraphSize(_seg.pt.x,_seg.pt.y,0.01,0.01);}}return all;}},{key:\"get_pointsDebug\",value:function get_pointsDebug(c){return this.get_points_impl(this.get_allNodes(c),true,c);}},{key:\"get_points\",value:function get_points(allNodes){var outer=arguments.length>1&&arguments[1]!==undefined?arguments[1]:false;var c=arguments.length>2?arguments[2]:undefined;return this.get_points_impl(allNodes,outer,c);}},{key:\"get_points_outer\",value:function get_points_outer(allNodes,c){return this.get_points_impl(allNodes,true,c);}},{key:\"get_points_inner\",value:function get_points_inner(allNodes,c){return this.get_points_impl(allNodes,false,c);}},{key:\"get_d\",value:function get_d(c){return this.get_segments(c).all.map(function(s){return s.d;}).join(\" \");}/*\r\n    private get_fillingSegments(c: Context): Partial<this[\"segments\"]> {\r\n        return this.get_segments(c).fillers;\r\n    }*/},{key:\"get_segments\",value:function get_segments(c){return this.get_segments_outer(c);}},{key:\"get_segments_outer\",value:function get_segments_outer(c){return this.get_segments_impl(c,true);}},{key:\"get_segments_inner\",value:function get_segments_inner(c){return this.get_segments_impl(c,false);}},{key:\"get_segments_impl\",value:function get_segments_impl(c,outer){var l=c.proxyObject;var v=this.get_view(c);var allNodes=l.allNodes;windoww.edge=l;var all=this.get_points(allNodes,outer,c);//const all: {size: GraphSize, view: LViewElement, ge: LGraphElement}[] = allNodes.map((ge) => { return { view: ge.view, size: ge.size, ge}});\nvar ret=[];var bm=v.bendingMode;var gapMode=v.edgeGapMode;var segmentSize=this.svgLetterSize(bm,false,true);var increase=segmentSize.first;var segment;/// grouping points according to SvgLetter\nfor(var i=0;i<all.length-1;){// let start = all[i], end = all[i+increase];\nvar start=all[i];var endindex=i+increase<all.length-1?i+increase:all.length-1;var mid=all.slice(i+1,endindex).filter(function(e,i){return i%2===0;});var end=all[endindex];// makes sure the edge actually reaches his target even if there is an invalid amount of midnodes fot the current EdgeBendingMode\nif(i===endindex&&segment)start=segment.end;// segment = this.get_segmentv3(start, mid, end, getSvgLetter(i), i, segment, all);\nsegment=new EdgeSegment(start,mid,end,bm,gapMode,i,segment);// segment = this.get_segment(start.ge, start.size, start.view, end.ge, end.size, end.view, cut, v.bendingMode, mid, ret[ret.length -1], fillMode, segment);\nret.push(segment);i+=increase+1;// because increase index is already inserted at the end of prev segment\nif(increase!==segmentSize.others)increase=segmentSize.others;// if (longestLabel !== undefined && longest < s.length) { longest = s.length; longestindex = i; } todo: move to after snapping to borders\n}function printablesegment(s){var r={};for(var k in s){var _v2;var _v=s[k];_v=((_v2=_v)===null||_v2===void 0?void 0:_v2.__raw)||_v;if(typeof _v===\"object\")r[k]=JSON.parse(JSON.stringify(_v));else r[k]=_v;}return r;}var fillSegments=[];this.snapSegmentsToNodeBorders(c,v,ret,fillSegments);var longestLabel=c.data.longestLabel;this.setLabels(c,ret,allNodes);// console.log(\"getSegments() labeled:\", {main:ret, fillSegments});\nvar rett={all:[].concat(ret,fillSegments),segments:ret,fillers:fillSegments};/*switch(bm){\r\n            default: break;\r\n            case EdgeBendingMode.Bezier_QT:\r\n            case EdgeBendingMode.Bezier_CS:\r\n                rett.\r\n        }*/for(var _i3=0;_i3<rett.all.length;_i3++){var s=rett.all[_i3];s.makeD(_i3,gapMode);}var zoom=new GraphPoint(1,1);rett.head=this.headPos_impl(c,true,v.edgeHeadSize,rett.segments[rett.segments.length-1],zoom);rett.tail=this.headPos_impl(c,false,v.edgeTailSize,rett.segments[0],zoom);return rett;}},{key:\"setLabels\",value:function setLabels(c,segments,allNodes){// find longest segment\nvar longestindex=-1;var longest=0;for(var i=0;i<segments.length;i++){var s=segments[i];s.calcLength();if(longest<s.length){longest=s.length;longestindex=i;}s.isLongest=false;}if(longestindex>=0)segments[longestindex].isLongest=true;// apply labels\nvar _iterator8=_createForOfIteratorHelper(segments),_step8;try{for(_iterator8.s();!(_step8=_iterator8.n()).done;){var _s=_step8.value;_s.label=this.get_label_impl(c,_s,allNodes,segments);}}catch(err){_iterator8.e(err);}finally{_iterator8.f();}}},{key:\"snapSegmentsToNodeBorders\",value:function snapSegmentsToNodeBorders(c,v,ret,fillSegments){// snap segment start and end to a node border\nvar canCutStart=v.edgeStartStopAtBoundaries,canCutEnd=v.edgeEndStopAtBoundaries;var grid=undefined;// let fillSegments: EdgeSegment[] = [];\nvar gapMode=v.edgeGapMode;var bm=v.bendingMode;var ci;// cut i === 0 is cut regardless of gapmode.\nif(canCutStart){ci=GraphSize.closestIntersection(ret[0].start.size,ret[0].start.pt,(ret[0].bezier[0]||ret[0].end).pt,grid);if(ci)ret[0].start.pt=ci;/*\r\n            ret[0].start.pt =\r\n                GraphSize.closestIntersection(ret[0].start.size, ret[0].start.pt, (ret[0].bezier[0] || ret[0].end).pt, grid) as any\r\n                || Geom.closestPoint(ret[0].start.size, ret[0].start.pt);*/}// cut middle segments maybe\nvar prev;var curr=ret[0];// if (gapMode === EdgeGapMode.gap) return;\nif(canCutStart||canCutEnd)// do the for below\nfor(var i=1;i<ret.length;i++){prev=ret[i-1];curr=ret[i];var doStartCut=void 0,doEndCut=void 0;switch(gapMode){/*\r\n                    case EdgeGapMode.arcFill:\r\n                    case EdgeGapMode.lineFill:\r\n                    case EdgeGapMode.autoFill:\r\n                        // same as gap, but will insert 1 more segment to fill the hole\r\n                        doStartCut = true;\r\n                        doEndCut = true;\r\n                        if (prev.end.pt.equals(curr.start.pt)) break;\r\n                        fillSegments.push(new EdgeFillSegment(\r\n                            prev.end,\r\n                            [\r\n                                {...prev.end, pt: EdgeSegment.invertLastBezierPt(prev.end.pt, (prev.bezier[prev.bezier.length-1] || prev.start).pt)},\r\n                                {...curr.start, pt: EdgeSegment.invertLastBezierPt(curr.start.pt, (curr.bezier[0] || curr.end).pt)}\r\n                            ],\r\n                            curr.start,\r\n                            bm, gapMode, 0, undefined));\r\n                            / *\r\n                            fillSegments.push(new FillEdgeSegment( // M <start_gap> C <bez1> <bez2> <end_gap>\r\n                               // <start_gap> = end of last seg (start of gap) <end_gap> = first of curr seg (end of gap)\r\n                            prev.end.pt,\r\n                            EdgeSegment.invertLastBezierPt(prev.end.pt, prev.bezier[prev.bezier.length-1].pt || prev.start.pt),\r\n                            EdgeSegment.invertLastBezierPt(curr.start.pt, curr.bezier[0].pt || curr.end.pt),\r\n                            curr.start.pt)* /\r\n\r\n                        break;*/case EdgeGapMode.gap:// just snap to vertex edge         prevSegment.endp and ret.startp\ndoEndCut=true;doStartCut=true;break;// average: todo: maybe rename in join (merges start-end at closest pt to both (avg), then snap on edge)\ncase\"closest\"://EdgeGapMode.closest:\n// does not work properly, i think i need to get next.end instead of curr.end, just disabled for now\nvar nextpt=(curr.bezier[0]||curr.end).pt;var prevpt=(prev.bezier[prev.bezier.length-1]||prev.start).pt;var midexternalpt=prevpt.add(nextpt,true);var midedgepoint=curr.start.size.tl().add(curr.start.size.br(),false).divide(2,false);// od average between the 2 points before and after that are not part of this edgepoint, then raw a line from there to center of ep, find that intersection.\nci=GraphSize.closestIntersection(curr.start.size,midedgepoint,midexternalpt,grid);doEndCut=doStartCut=false;if(canCutEnd&&ci)prev.end.pt=ci;if(canCutStart&&ci)curr.start.pt=ci;break;case EdgeGapMode.average:// first move to average of the 2 points in the gap, then snap to edge\ndoEndCut=true;doStartCut=true;// indipendent from cutStart, cutEnd.\n// they merge if just 1 of cutting sides are true. (and if they are both false we don't even enter the for loop)\ncurr.start.pt=curr.start.pt.add(prev.end.pt,false).divide(2,false);prev.end.pt=curr.start.pt.duplicate();// intentionally not the same pt because during snap to edge they can diverge again.\nprev.start.uncutPt=prev.start.pt;prev.end.uncutPt=prev.end.pt;break;// center: first move it to center of edgePoint/node, then snap to edge.\n// this mode might be as well deleted, it can be specified with anchor points\ncase EdgeGapMode.center:doEndCut=false;doStartCut=false;curr.start.pt=curr.start.size.tl().add(curr.start.size.br(),false).divide(2,false);prev.end.pt=curr.start.pt.duplicate();// intentionally not the same pt because during snap to edge they can diverge again.\nprev.start.uncutPt=prev.start.pt;// only update them when point moves without being cut (average and center)\nprev.end.uncutPt=prev.end.pt;break;default:return Log.exDevv(\"unexpected EdgeGapMode:\"+gapMode);}if(canCutStart&&doStartCut){var _nextpt=(curr.bezier[0]||curr.end).pt;ci=GraphSize.closestIntersection(curr.start.size,curr.start.pt,_nextpt,grid);if(ci)curr.start.pt=ci;// || Geom.closestPoint(curr.start.size, curr.start.pt);\n//if (gapMode === EdgeGapMode.average && prev) { prev.end.pt = curr.start.pt.add(prev.end.pt, false).divide(2, false); }\n}if(canCutEnd&&doEndCut&&prev){var _prevpt=(prev.bezier[prev.bezier.length-1]||prev.start).pt;ci=GraphSize.closestIntersection(prev.end.size,prev.end.pt,_prevpt,grid);if(ci)prev.end.pt=ci;// || Geom.closestPoint(prev.end.size, prev.end.pt);\n// if average: first do average between start anchor points non-snapped. then i snap both,\n// then i do average again, and since it might snap out, i get closestPoint to EdgePoint size\nif(gapMode===EdgeGapMode.average)prev.end.pt=curr.start.pt=Geom.closestPoint(curr.start.size,curr.start.pt.add(prev.end.pt,false).divide(2,false));}}// cut end of last segment regardless of gapMode\nif(canCutEnd){var prevendpt=curr.end.pt;ci=GraphSize.closestIntersection(curr.end.size,curr.end.pt,(curr.bezier[curr.bezier.length-1]||curr.start).pt,grid);if(ci)curr.end.pt=ci;//|| Geom.closestPoint(prev.end.size, prev.end.pt);\n}}},{key:\"get_edgeEnd\",value:function get_edgeEnd(context){return this.get_edgeEnd_outer(context);}},{key:\"get_edgeEnd_outer\",value:function get_edgeEnd_outer(c){// return this.get_outerGraph(c).translateSize(this.get_edgeEnd_inner(c), this.get_innerGraph(c));\nreturn this.get_outerGraph(c).translateSize(this.get_edgeEnd_inner(c),this.get_end(c).innerGraph);}},{key:\"get_edgeEnd_inner\",value:function get_edgeEnd_inner(c){return this.get_edgeStartEnd_inner(c,false);// return context.proxyObject.end?.size || new GraphPoint(0, 0);\n}},{key:\"get_midnodes\",value:function get_midnodes(context){// return LPointerTargetable.wrapAll(context.data.midnodes);\nreturn LPointerTargetable.wrapAll(context.data.subElements);}},{key:\"set_midnodes\",value:function set_midnodes(val,context){return SetFieldAction.new(context.data.id,\"midnodes\",val,'',true);}},{key:\"get_start\",value:function get_start(context){return LPointerTargetable.from(context.data.start);}},{key:\"get_end\",value:function get_end(context){return LPointerTargetable.from(context.data.end);}},{key:\"get_endFollow\",value:function get_endFollow(c){return c.data.id===LVoidEdge.endFollow;}},{key:\"get_startFollow\",value:function get_startFollow(c){return c.data.id===LVoidEdge.startFollow;}// // what in multieditor? needs to be moved in transientstuff?\n},{key:\"set_endFollow\",value:function set_endFollow(val,c){return this._set_start_endFollow(val,c,false);}},{key:\"set_startFollow\",value:function set_startFollow(val,c){return this._set_start_endFollow(val,c,true);}},{key:\"_set_start_endFollow\",value:function _set_start_endFollow(val,c,isStart){val=!!val;console.log(\"_set_start_endFollow\",{val:val,c:c,isStart:isStart});if(val){if(isStart)LVoidEdge.startFollow=c.data.id;else LVoidEdge.endFollow=c.data.id;if(!LVoidEdge.following){console.log(\"_set_start_endFollow event attached\");document.body.addEventListener(\"mousemove\",LVoidEdge.mousemove,false);LVoidEdge.following=true;LVoidEdge.followingContext=c;var $base=$(document.getElementById(isStart?c.data.start:c.data.end)||[]);var $deepAnchors=$base.find(\"[nodeid] .anchor\");var $anchors=$base.find(\".anchor\").not($deepAnchors);$anchors.addClass(\"valid-anchor\");$anchors.filter('[data-anchorname=\"'+((isStart?c.data.anchorStart:c.data.anchorEnd)||0)+'\"]').addClass(\"active-anchor\");var selector=\".Edge[nodeid='\"+(LVoidEdge.endFollow||LVoidEdge.startFollow)+\"']\";// [...document.querySelectorAll(selector)].map(e=>e.classList.add(\"no-transition-following\")); gets refreshed by react\ndocument.body.classList.add(\"no-transition-following\");}}else{if(LVoidEdge.following&&(isStart?LVoidEdge.startFollow:LVoidEdge.endFollow)===c.data.id){document.body.removeEventListener(\"mousemove\",LVoidEdge.mousemove,false);var _selector=\".Edge[nodeid='\"+(LVoidEdge.endFollow||LVoidEdge.startFollow)+\"']\";//[...document.querySelectorAll(selector)].map(e=>e.classList.remove(\"no-transition-following\"));\ndocument.body.classList.remove(\"no-transition-following\");if(isStart)LVoidEdge.startFollow=undefined;else LVoidEdge.endFollow=undefined;LVoidEdge.following=false;var _$base=$(document.getElementById(isStart?c.data.start:c.data.end)||[]);//const $deepAnchors = $base.find(\"[nodeid] .anchor\");\nvar _$anchors=_$base.find(\".anchor\");//.not($deepAnchors);\n_$anchors.removeClass([\"valid-anchor\",\"active-anchor\"]);}}//SetFieldAction.new(c.data, \"startFollow\", !!val, '', false);\nreturn true;}}],[{key:\"getCursorPos\",value:function getCursorPos(e0){return new Point(e0.pageX,e0.pageY);}/*public static getGCursorPos(e0: Event): GraphPoint {\r\n        return LVLoidEdge.getCursorPos(e0).subtract(svgsize.tl(), true).multiply(svgzoom) as any as GraphPoint;\r\n    }*/},{key:\"mousemove\",value:function mousemove(e0){var forcererendermode=true;if(forcererendermode){if(!LVoidEdge.following)return;if(!LVoidEdge.canForceUpdate)return;var c=LVoidEdge.followingContext;var g=c.proxyObject.graph;var _cursorPos=LVoidEdge.getCursorPos(e0);var gcursorpos=g.translateHtmlSize(_cursorPos);DVoidEdge.isFollowingCoords=gcursorpos;var component=GraphElementComponent.map[LVoidEdge.startFollow||LVoidEdge.endFollow];LVoidEdge.canForceUpdate=false;var timer=setTimeout(function(){LVoidEdge.canForceUpdate=true;},5000);var tn=transientProperties.node[c.data.id];for(var vid in tn.viewScores){// required to truly force an update\nvar tnv=tn.viewScores[vid];tnv.jsxOutput=undefined;tnv.usageDeclarations=undefined;tnv.shouldUpdate=true;}component.setState({forceupdate:new Date().getDate()},function(){LVoidEdge.canForceUpdate=true;clearTimeout(timer);});// component.forceUpdate(()=>{LVoidEdge.canForceUpdate = true; clearTimeout(timer)});\nreturn;}LVoidEdge.tmp++;var selector=\".Edge[nodeid='\"+(LVoidEdge.endFollow||LVoidEdge.startFollow)+\"']\";var root=document.querySelector(selector);if(!root)return;var paths=_toConsumableArray(root.querySelectorAll(\"path.full\"));var pathSegments=root.querySelectorAll(\"path.segment.preview\");// if (!paths.length) paths = pathSegments;\nvar pathSegmentContainers=_toConsumableArray(new Set(_toConsumableArray(pathSegments).map(function(e){return e.parentElement;})));var _iterator9=_createForOfIteratorHelper(pathSegmentContainers),_step9;try{for(_iterator9.s();!(_step9=_iterator9.n()).done;){var container=_step9.value;var se=_toConsumableArray(container.querySelectorAll(\"path.segment.preview\"));paths.push(se[LVoidEdge.endFollow?se.length-1:0]);}}catch(err){_iterator9.e(err);}finally{_iterator9.f();}var headTail=_toConsumableArray(root.querySelectorAll(LVoidEdge.endFollow?'.edgeHead':'.edgeTail'));var cursorPos=LVoidEdge.getCursorPos(e0);var segList;var _iterator10=_createForOfIteratorHelper(paths),_step10;try{for(_iterator10.s();!(_step10=_iterator10.n()).done;){var p=_step10.value;var svg=U.parentUntil(\"svg\",p);var svgsize=Size.of(svg);var svgzoom=new Point(1,1);// todo: check viewbox and css zoom\nvar gcursorPos=cursorPos.subtract(svgsize.tl(),true).multiply(svgzoom);segList=_toConsumableArray(p.getPathData());var lastSeg=_objectSpread({},segList[LVoidEdge.endFollow?segList.length-1:0]);switch(lastSeg.type){case'a':case'A':segList.push('fake new segment to get replaced instead of actual last segment which is A');lastSeg.type=\"L\";lastSeg.values=[gcursorPos.x,gcursorPos.y];break;case\"C\":case\"c\":// bezier curves, keep type just change last point\ncase\"Q\":case\"q\":case\"S\":case\"s\":case\"T\":case\"t\":lastSeg.values[lastSeg.values.length-2]=gcursorPos.x;lastSeg.values[lastSeg.values.length-1]=gcursorPos.y;break;case\"M\":case\"m\":lastSeg.type=LVoidEdge.endFollow?\"L\":\"M\";lastSeg.values=[gcursorPos.x,gcursorPos.y];break;case\"V\":case\"v\":// stuff forced to become a line\ncase\"H\":case\"h\":case\"L\":case\"l\":case\"Z\":case\"z\":lastSeg.type=\"L\";lastSeg.values=[gcursorPos.x,gcursorPos.y];break;}segList[LVoidEdge.endFollow?segList.length-1:0]=lastSeg;if(LVoidEdge.tmp%20===0)console.log(\"svg set path data,\",{segList:segList,oldSeglist:p.getPathData(),p:p});p.setPathData(segList);}}catch(err){_iterator10.e(err);}finally{_iterator10.f();}var _iterator11=_createForOfIteratorHelper(headTail),_step11;try{for(_iterator11.s();!(_step11=_iterator11.n()).done;){var ht=_step11.value;var _svg=U.parentUntil(\"svg\",ht);var _svgsize=Size.of(_svg);var _svgzoom=new Point(1,1);// todo: check viewbox and css zoom\nvar _gcursorPos=cursorPos.subtract(_svgsize.tl(),true).multiply(_svgzoom);var rotation=void 0;var lastPt=segList&&segList[LVoidEdge.endFollow?segList.length-2:1].values;if(lastPt){var m=_gcursorPos.getM(new Point(lastPt[LVoidEdge.endFollow?lastPt.length-2:1],lastPt[LVoidEdge.endFollow?lastPt.length-1:0]));if(Number.POSITIVE_INFINITY===m)rotation=Geom.degToRad(90);else if(Number.NEGATIVE_INFINITY===m)rotation=Geom.degToRad(270);else rotation=Math.atan(m);if(lastPt[LVoidEdge.endFollow?lastPt.length-2:1]>_gcursorPos.x)rotation-=Geom.degToRad(180);}else{rotation=0;}var headSize=Size.of(ht);var headPos=_gcursorPos.subtract({x:headSize.w/2,y:headSize.h/2},true);//.subtract({x:Math.cos(rotation)*headSize.w/2, y: -Math.sin(rotation)*headSize.h/2}, true);\nif(LVoidEdge.tmp%20===0)console.log(\"_set_start_endFollow move head\",{selector:LVoidEdge.endFollow?'.edgeHead':'.edgeTail',headTail:headTail,root:root});ht.style.transform='translate('+headPos.x+\"px, \"+headPos.y+\"px) rotate(\"+rotation+\"rad)\";}}catch(err){_iterator11.e(err);}finally{_iterator11.f();}}}]);return LVoidEdge;}(LGraphElement),_class30.subclasses=[],_class30._extends=[],_class30.startFollow=undefined,_class30.endFollow=undefined,_class30.following=false,_class30.followingContext=void 0,_class30.tmp=1,_class30.canForceUpdate=true,_class30))||_class29);RuntimeAccessibleClass.set_extend(DGraphElement,DVoidEdge);RuntimeAccessibleClass.set_extend(LGraphElement,LVoidEdge);export var DEdge=(_dec16=RuntimeAccessible('DEdge'),_dec16(_class31=(_class32=/*#__PURE__*/function(_DVoidEdge){_inherits(DEdge,_DVoidEdge);var _super18=_createSuper(DEdge);function DEdge(){var _this22;_classCallCheck(this,DEdge);for(var _len16=arguments.length,args=new Array(_len16),_key16=0;_key16<_len16;_key16++){args[_key16]=arguments[_key16];}_this22=_super18.call.apply(_super18,[this].concat(args));_this22.id=void 0;_this22.graph=void 0;_this22.model=void 0;_this22.isSelected=void 0;_this22.subElements=void 0;_this22.state=void 0;_this22.start=void 0;_this22.end=void 0;_this22.__isDEdge=void 0;_this22.__isDVoidEdge=void 0;_this22.midnodes=void 0;return _this22;}// DVoidEdge\n// static singleton: LGraphElement;\n// static logic: typeof LGraphElement;\n// static structure: typeof DGraphElement;\n// isSelected: Dictionary<DocString<Pointer<DUser>>, boolean> = {};\n// containedIn!: Pointer<DGraphElement, 0, 1, LGraphElement>;\nreturn DEdge;}(DVoidEdge),_class32.subclasses=[],_class32._extends=[],_class32))||_class31);export var LEdge=(_dec17=RuntimeAccessible('LEdge'),_dec17(_class33=(_class34=/*#__PURE__*/function(_LVoidEdge){_inherits(LEdge,_LVoidEdge);var _super19=_createSuper(LEdge);function LEdge(){var _this23;_classCallCheck(this,LEdge);for(var _len17=arguments.length,args=new Array(_len17),_key17=0;_key17<_len17;_key17++){args[_key17]=arguments[_key17];}_this23=_super19.call.apply(_super19,[this].concat(args));_this23.__raw=void 0;_this23.id=void 0;_this23.graph=void 0;_this23.model=void 0;_this23.subElements=void 0;_this23._state=void 0;_this23.start=void 0;_this23.end=void 0;_this23.midnodes=void 0;_this23.__isLEdge=void 0;_this23.__isLVoidEdge=void 0;return _this23;}// static singleton: LGraphElement;\n// static logic: typeof LGraphElement;\n// static structure: typeof DGraphElement;\n_createClass(LEdge,[{key:\"isSelected\",value:// isSelected: Dictionary<DocString<Pointer<DUser>>, boolean> = {};\nfunction isSelected(forUser){return this.wrongAccessMessage(\"node.isSelected()\");}// containedIn!: LGraphElement;\n// LMap;\n}]);return LEdge;}(LVoidEdge),_class34.subclasses=[],_class34._extends=[],_class34))||_class33);RuntimeAccessibleClass.set_extend(DVoidEdge,DEdge);RuntimeAccessibleClass.set_extend(LVoidEdge,LEdge);export var DExtEdge=(_dec18=RuntimeAccessible('DExtEdge'),Leaf(_class35=_dec18(_class35=(_class36=/*#__PURE__*/function(_DEdge){_inherits(DExtEdge,_DEdge);var _super20=_createSuper(DExtEdge);function DExtEdge(){var _this24;_classCallCheck(this,DExtEdge);for(var _len18=arguments.length,args=new Array(_len18),_key18=0;_key18<_len18;_key18++){args[_key18]=arguments[_key18];}_this24=_super20.call.apply(_super20,[this].concat(args));_this24.id=void 0;_this24.graph=void 0;_this24.model=void 0;_this24.isSelected=void 0;_this24.subElements=void 0;_this24.state=void 0;_this24.start=void 0;_this24.end=void 0;_this24.__isDExtEdge=void 0;_this24.__isDEdge=void 0;_this24.__isDVoidEdge=void 0;return _this24;}// etends DEdge\n// static singleton: LGraphElement;\n// static logic: typeof LGraphElement;\n// static structure: typeof DGraphElement;\n// isSelected: Dictionary<DocString<Pointer<DUser>>, boolean> = {};\n// containedIn!: Pointer<DGraphElement, 0, 1, LGraphElement>;\n/*\r\n        public static new(model: DGraph[\"model\"], parentNodeID: DGraphElement[\"father\"], graphID: DGraphElement[\"graph\"], nodeID?: DGraphElement[\"id\"], size?: GraphSize): DExtEdge {\r\n            return new Constructors(new DExtEdge('dwc')).DPointerTargetable().DGraphElement(model, parentNodeID, graphID, nodeID)\r\n                .DVoidEdge().DEdge().DExtEdge().end();\r\n        }*/return DExtEdge;}(DEdge),_class36.subclasses=[],_class36._extends=[],_class36))||_class35)||_class35);export var LExtEdge=(_dec19=RuntimeAccessible('LExtEdge'),_dec19(_class37=(_class38=/*#__PURE__*/function(_LEdge){_inherits(LExtEdge,_LEdge);var _super21=_createSuper(LExtEdge);function LExtEdge(){var _this25;_classCallCheck(this,LExtEdge);for(var _len19=arguments.length,args=new Array(_len19),_key19=0;_key19<_len19;_key19++){args[_key19]=arguments[_key19];}_this25=_super21.call.apply(_super21,[this].concat(args));_this25.__raw=void 0;_this25.id=void 0;_this25.graph=void 0;_this25.model=void 0;_this25.subElements=void 0;_this25._state=void 0;_this25.start=void 0;_this25.end=void 0;_this25.__isLExtEdge=void 0;_this25.__isLEdge=void 0;_this25.__isLVoidEdge=void 0;return _this25;}// static singleton: LGraphElement;\n// static logic: typeof LGraphElement;\n// static structure: typeof DGraphElement;\n_createClass(LExtEdge,[{key:\"isSelected\",value:// isSelected: Dictionary<DocString<Pointer<DUser>>, boolean> = {};\nfunction isSelected(forUser){return this.wrongAccessMessage(\"node.isSelected()\");}// containedIn!: LGraphElement;\n// LMap;\n}]);return LExtEdge;}(LEdge),_class38.subclasses=[],_class38._extends=[],_class38))||_class37);RuntimeAccessibleClass.set_extend(DEdge,DExtEdge);RuntimeAccessibleClass.set_extend(LEdge,LExtEdge);export var DRefEdge=(_dec20=RuntimeAccessible('DRefEdge'),Leaf(_class39=_dec20(_class39=(_class40=/*#__PURE__*/function(_DEdge2){_inherits(DRefEdge,_DEdge2);var _super22=_createSuper(DRefEdge);function DRefEdge(){var _this26;_classCallCheck(this,DRefEdge);for(var _len20=arguments.length,args=new Array(_len20),_key20=0;_key20<_len20;_key20++){args[_key20]=arguments[_key20];}_this26=_super22.call.apply(_super22,[this].concat(args));_this26.start=void 0;_this26.end=void 0;_this26.isSelected=void 0;_this26.__isDRefEdge=void 0;return _this26;}// extends DEdge\n/*\r\n        public static new(model: DGraph[\"model\"], parentNodeID: DGraphElement[\"father\"], graphID: DGraphElement[\"graph\"], nodeID?: DGraphElement[\"id\"]): DRefEdge {\r\n            return new Constructors(new DRefEdge('dwc')).DPointerTargetable().DGraphElement(model, parentNodeID, graphID, nodeID)\r\n                .DVoidEdge().DEdge().DRefEdge().end();\r\n        }*/return DRefEdge;}(DEdge),_class40.subclasses=[],_class40._extends=[],_class40))||_class39)||_class39);export var LRefEdge=(_dec21=RuntimeAccessible('LRefEdge'),_dec21(_class41=(_class42=/*#__PURE__*/function(_LEdge2){_inherits(LRefEdge,_LEdge2);var _super23=_createSuper(LRefEdge);function LRefEdge(){var _this27;_classCallCheck(this,LRefEdge);for(var _len21=arguments.length,args=new Array(_len21),_key21=0;_key21<_len21;_key21++){args[_key21]=arguments[_key21];}_this27=_super23.call.apply(_super23,[this].concat(args));_this27.start=void 0;_this27.end=void 0;_this27.__isLRefEdge=void 0;return _this27;}// __raw!: DRefEdge;\nreturn LRefEdge;}(LEdge),_class42.subclasses=[],_class42._extends=[],_class42))||_class41);RuntimeAccessibleClass.set_extend(DEdge,DRefEdge);RuntimeAccessibleClass.set_extend(LEdge,LRefEdge);// for edges without a modelling element\n/*\r\n\r\nlet a = `DExtEdge, DRefEdge, DVoidEdge, LGraphVertex, LRefEdge, LEdgePoint, DVoidVertex, DGraphVertex, DEdgePoint,\r\n DVertex, DEdge, LVertex, LGraph, DGraph, LVoidVertex, LVoidEdge, LEdge, LGraphElement, LExtEdge, DGraphElement`;\r\n  // // ... get from export in index.ts\r\na = a.replaceAll(',,', \",\")\r\nlet aa = a.split(\",\").map(a => a.trim().substring(1));\r\n\r\nfunction onlyUnique(value, index, self) { return self.indexOf(value) === index; }\r\n\r\naa = aa.filter(onlyUnique).filter( a=> !!a)\r\nlet r = aa.filter(onlyUnique).filter( a=> !!a).map( a=> `export type W${a} = getWParams<L${a}, D${a}>;`).join('\\n')\r\ndocument.body.innerText = r;\r\n*/ // getWParams<LGraphVertex, DGraphVertex>;\nconsole.warn('ts loading graphDataElement');","map":{"version":3,"names":["isDeepStrictEqual","BEGIN","Constructors","CoordinateMode","Debug","DModelElement","DPointerTargetable","DUser","EdgeBendingMode","END","GraphElementComponent","GraphPoint","GraphSize","Leaf","Log","LPointerTargetable","MixOnlyFuncs","Node","Point","Pointers","RuntimeAccessible","RuntimeAccessibleClass","SetFieldAction","ShortAttribETypes","Size","store","TargetableProxyHandler","transientProperties","U","Uarr","windoww","EdgeGapMode","Geom","jsx","_jsx","jsxs","_jsxs","console","warn","DGraphElement","_dec","_class","_class2","_DPointerTargetable","_inherits","_super","_createSuper","_this","_classCallCheck","_len","arguments","length","args","Array","_key","call","apply","concat","id","graph","model","isSelected","subElements","state","father","x","y","zIndex","w","h","view","favoriteNode","edgesIn","edgesOut","anchors","_createClass","key","value","_new","htmlindex","parentNodeID","graphID","nodeID","a","b","undefined","end","subclasses","_extends","LGraphElement","_dec2","_class3","_class4","_LPointerTargetable","_super2","_this2","_len2","_key2","__raw","_state","allSubNodes","width","height","z","__info_of_z__","type","EInt","txt","__info_of_zIndex__","zoom","html","size","position","htmlSize","htmlPosition","component","vertex","__info__of__vertex","__info__of__favoriteNode","EBoolean","startPoint","endPoint","__info_of__startPoint","children","__info_of__endPoint","__info_of__graph","innerGraph","__info_of__innnerGraph","outerGraph","__info_of__outerGraphGraph","__info_of__graphAncestors","graphAncestors","__info_of__anchors","__info_of__edgesIn","__info_of__edgesOut","__info_of__edgesStart","__info_of__edgesEnd","outerSize","__info_of__outerSize","innerSize","__info_of__innerSize","__info_of__size","assignEdgeAnchor","__info_of__assignEdgeAnchor","__info_of__isselected","__info_of__select","__info_of__deselect","__info_of__toggleSelect","__info_of__isSelected","get_graph","context","get_innerGraph","get_anchors","c","data","set_anchors","v","isArray","ee","ka","kk","isNaN","new","get_edgesIn","fromArr","get_edgesOut","set_edgesIn","val","set_edgesOut","get_edgesStart","get_edgesEnd","set_edgesStart","set_edgesEnd","_defaultGetter","k","__defaultGetter","get_view","_defaultSetter","__defaultSetter","get_graphAncestors","current","proxyObject","next","ret","extends","className","DGraph","cname","push","get_outerGraph","wrap","get_vertex","lcurrent","fromPointer","dcurrent","DVertex","DVoidVertex","DGraphVertex","fromD","exDev","exDevv","cdata","_dcurrent","get_x","get_size","set_x","set_size","get_y","set_y","get_w","set_w","get_h","set_h","get_width","set_width","get_height","set_height","get_position","set_position","get_sizeold","get_component","map","_transientProperties$","_this$get_component","node","mainView","from","props","set_view","eDevv","getSize","outer","canTriggerSet","wrongAccessMessage","get_getSize","_this3","get_innerSize","get_outerSize","r","get_innerSize_impl","_this$get_component2","lightMode","DEdge","DVoidEdge","nosize","coord","get_htmlSize","DEdgePoint","def","defaultVSize","currentCoordType","decodePosCoords","translateSize","actualSize","of","updateSize","isOldElement","clonedCounter","adaptWidth","adaptHeight","size0","testmode","absolute","encodePosCoords","epdata","get_html","$","set_html","cannotSet","set_htmlSize","get_htmlPosition","tl","set_htmlPosition","get_zIndex","set_zIndex","get_z","set_z","get_subElements","_toConsumableArray","Set","set_subElements","log","eDev","pointers","equals","idlookup","getState","arrdiff","arrayDifference","_iterator","_createForOfIteratorHelper","removed","_step","s","n","done","oldsubelementid","subelement","err","e","f","_iterator2","added","_step2","newsubelementid","get_isResized","isResized","set_isResized","get_model","modelElementId","lModelElement","get_allSubNodes","tocheck","checked","dblcheck","_iterator3","_step3","newtocheck","_iterator4","_step4","ptr","fistContainer","subnode","se","_iterator5","_step5","arrayMergeInPlace","Object","keys","get_assignEdgeAnchor","anchorName","LVoidEdge","startFollow","de","start","le","anchorStart","endFollow","anchorEnd","get_events","tn","mainview","otherViews","stackViews","allviews","reverse","keep_for_closure_original_funcs","_iterator6","_step6","dv","objectMergeInPlace","events","lastContext","viewScores","evalContext","_loop","_keys","_i","_len3","_params","_key3","_ret","get_father","set_father","select","forUser","deselect","toggleSelected","get_select","_objectSpread","get_deselect","get_toggleSelected","_this4","get_isSelected","set_isSelected","get_startPoint","get_startEndPoint","get_endPoint","isStart","offset","isPercentage","add","getNodeId","o","_node","set_extend","_dec3","_class5","_class6","_DGraphElement","_super3","_this5","_len4","_key4","parentgraphID","DGraph_makeID","getNodes","dmp","out","$allnodes","matchedids","d","matchedidmap","objectFromArrayValues","allnodesarr","filternode","_d$dataset","_d$dataset2","dataset","dataid","$matched","filter","$notMatched","defaultEdgePointSize","defaultVertexSize","LGraph","_dec4","_class7","_class8","_LGraphElement","_super4","_this6","_len5","_key5","graphSize","__info_of__zoom","label","__info_of__offset","__info_of__graphSize","__info_of__translateSize","__info_of__translateHtmlSize","get_offset","set_offset","get_zoom","toGraphSize","get_coord","_this7","translateHtmlSize","set_zoom","get_translateHtmlSize","_this8","graphHtmlSize","subtract","multiply","get_translateSize","hasOwnProperty","ex","ancestors","indexOf","_iterator7","_step7","g","contains","elem","get_contains","targetid","_dec5","_class9","_class10","_DGraphElement2","_super5","_this9","_len6","_key6","LVoidVertex","_dec6","_class11","_class12","_LGraphElement2","_super6","_this10","_len7","_key7","_dec7","_class13","_class14","_DVoidVertex","_super7","_this11","_len8","_key8","__isDEdgePoint","LEdgePoint","_dec8","_class15","_class16","_LVoidVertex","_super8","_this12","_len9","_key9","__isLEdgePoint","edge","__info_of__edge","get_edge","set_edge","sp0","ep0","sp","ep","decodeCoords","mode","edgePointCoordMode","encodeCoords","relativePercent","relativeOffset","relativeOffsetStart","relativeOffsetEnd","useStart","useEnd","xIsAbsolute","yIsAbsolute","offsetsp","offsetep","divide","testCoords","range","_i2","_arr","i","j","s0","s1","s00","error","toFixed","join","diff","_dec9","_class17","_class18","_DGraphElement3","_super9","_this13","_len10","_key10","__isDVertex","LVertex","_dec10","_class19","_class20","_LVoidVertex2","_super10","_this14","_len11","_key11","__isLVertex","_dec11","_class21","_class22","_DGraphElement4","_super11","_this15","_len12","_key12","__isDGraph","__isDGraphVertex","LG","_LGraph","_super12","LV","_LVertex","_super13","Mixed","LGraphVertex","_dec12","_class23","_class24","_Mixed","_super14","_this16","_len13","_key13","__isLGraph","__isLGraphVertex","_dec13","_class25","_class26","_DGraphElement5","_super15","_this17","_len14","_key14","__isDVoidEdge","midPoints","midnodes","longestLabel","labels","new2","setter","isFollowingCoords","EdgeSegment","_dec14","_class27","mid","svgLetter","gapMode","index","prevSegment","prev","bezier","dpart","m","rad","radLabels","isLongest","Bezier_QT","addBezierPoint","Bezier_CS","Line","Bezier_quadratic","Bezier_cubic","Elliptical_arc","prevedgemakerbezier","mirroredBezier","pt","invertLastBezierPt","uncutPt","makeD","getM","mToRad","Math","atan","bezierpts","finalpart","p","bezierptsUncut","finalpartUncut","bendingMode","calcLength","distanceFromPoint","vector","EdgeFillSegment","_EdgeSegment","_super16","center","average","gap","_get","_getPrototypeOf","prototype","_dec15","_class29","_class30","_LGraphElement3","_super17","_this18","_len15","_key15","__isLVoidEdge","allNodes","__info_of__longestLabel","readType","writeType","__info_of__label","__info_of__labels","__info_of__allNodes","segments","segments_inner","segments_outer","__info_of__segments","__info_of__d","EString","__info_of__anchorStart","isEdge","__info_of__anchorEnd","__info_of__endFollow","__info_of__startFollow","get_label","get_longestLabel","set_label","set_longestLabel","get_labels","set_labels","headPos_impl","isHead","headSize0","segment0","zoom0","segment","get_segments","tmp","edgeHeadSize","edgeTailSize","headPos","useBezierPoints","x4headsize","secondIntersection","segmentDistance","sqrt","pow","safeDistance","max","closestIntersection","exx","tailPos","get_headPos","_this19","headSize","get_tailPos","_this20","get_allNodes","get_start","get_midnodes","get_end","get_midPoints","addMidPoint","get_addMidPoint","_this21","impl_addMidPoints","set_midPoints","get_label_impl","nodes","l","labelmaker","labelmakerfunc","get_startPoint_Outer","get_endPoint_Outer","get_startPoint_inner","get_endPoint_inner","get_edgeStartEnd_inner","svgLetterSize","addM","doublingMidPoints","first","others","get_points_impl","getAnchorOffset","$factor","all","flatMap","ge","dge","base","rets","rete","debug","anchor_e","anchor_s","anchor","edgeStartOffset","edgeStartOffset_isPercentage","seg","get_pointsDebug","get_points","get_points_outer","get_points_inner","get_d","get_segments_outer","get_segments_impl","get_segments_inner","bm","edgeGapMode","segmentSize","increase","endindex","slice","printablesegment","_v2","JSON","parse","stringify","fillSegments","snapSegmentsToNodeBorders","setLabels","rett","fillers","head","tail","longestindex","longest","_iterator8","_step8","canCutStart","edgeStartStopAtBoundaries","canCutEnd","edgeEndStopAtBoundaries","grid","ci","curr","doStartCut","doEndCut","nextpt","prevpt","midexternalpt","midedgepoint","br","duplicate","closestPoint","prevendpt","get_edgeEnd","get_edgeEnd_outer","get_edgeEnd_inner","wrapAll","set_midnodes","get_endFollow","get_startFollow","set_endFollow","_set_start_endFollow","set_startFollow","following","document","body","addEventListener","mousemove","followingContext","$base","getElementById","$deepAnchors","find","$anchors","not","addClass","selector","classList","removeEventListener","remove","removeClass","getCursorPos","e0","pageX","pageY","forcererendermode","canForceUpdate","cursorPos","gcursorpos","timer","setTimeout","vid","tnv","jsxOutput","usageDeclarations","shouldUpdate","setState","forceupdate","Date","getDate","clearTimeout","root","querySelector","paths","querySelectorAll","pathSegments","pathSegmentContainers","parentElement","_iterator9","_step9","container","headTail","segList","_iterator10","_step10","svg","parentUntil","svgsize","svgzoom","gcursorPos","getPathData","lastSeg","values","oldSeglist","setPathData","_iterator11","_step11","ht","rotation","lastPt","Number","POSITIVE_INFINITY","degToRad","NEGATIVE_INFINITY","style","transform","_dec16","_class31","_class32","_DVoidEdge","_super18","_this22","_len16","_key16","__isDEdge","LEdge","_dec17","_class33","_class34","_LVoidEdge","_super19","_this23","_len17","_key17","__isLEdge","DExtEdge","_dec18","_class35","_class36","_DEdge","_super20","_this24","_len18","_key18","__isDExtEdge","LExtEdge","_dec19","_class37","_class38","_LEdge","_super21","_this25","_len19","_key19","__isLExtEdge","DRefEdge","_dec20","_class39","_class40","_DEdge2","_super22","_this26","_len20","_key20","__isDRefEdge","LRefEdge","_dec21","_class41","_class42","_LEdge2","_super23","_this27","_len21","_key21","__isLRefEdge"],"sources":["C:/d/Programming/web/jodel-mde/src/model/dataStructure/GraphDataElements.tsx"],"sourcesContent":["// import {Mixin} from \"ts-mixer\";\r\nimport {isDeepStrictEqual} from \"util\";\r\nimport {\r\n    BEGIN,\r\n    Constructors,\r\n    CoordinateMode,\r\n    Debug,\r\n    Dictionary,\r\n    DModelElement,\r\n    DocString,\r\n    DPointerTargetable,\r\n    DState,\r\n    DUser,\r\n    DViewElement,\r\n    EdgeBendingMode,\r\n    END,\r\n    EPSize,\r\n    getWParams,\r\n    GObject,\r\n    GraphElementComponent,\r\n    GraphPoint,\r\n    GraphSize,\r\n    Info,\r\n    Leaf,\r\n    LModelElement,\r\n    Log,\r\n    LogicContext,\r\n    LPointerTargetable,\r\n    LViewElement,\r\n    MixOnlyFuncs,\r\n    Node,\r\n    Pack1,\r\n    PackArr,\r\n    Point,\r\n    Pointer,\r\n    Pointers,\r\n    PrimitiveType,\r\n    RuntimeAccessible,\r\n    RuntimeAccessibleClass,\r\n    SetFieldAction,\r\n    ShortAttribETypes,\r\n    Size,\r\n    store,\r\n    TargetableProxyHandler,\r\n    transientProperties,\r\n    U,\r\n    Uarr,\r\n    windoww\r\n} from \"../../joiner\";\r\nimport type {RefObject} from \"react\";\r\nimport type {SVGPathElementt, SVGPathSegment} from '../../common/libraries/pathdata';\r\nimport {EdgeGapMode, InitialVertexSize} from \"../../joiner/types\";\r\nimport {labelfunc} from \"../../joiner/classes\";\r\nimport {Geom} from \"../../common/Geom\";\r\n\r\n\r\nconsole.warn('ts loading graphDataElement');\r\n\r\n@Node\r\n@RuntimeAccessible('DGraphElement')\r\nexport class DGraphElement extends DPointerTargetable {\r\n    // static _super = DPointerTargetable;\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // static singleton: LGraphElement;\r\n    // static logic: typeof LGraphElement;\r\n    // static structure: typeof DGraphElement;\r\n    id!: Pointer<DGraphElement, 1, 1, LGraphElement>;\r\n    graph!: Pointer<DGraph, 1, 1, LGraph>;\r\n    model?: Pointer<DModelElement, 0, 1, LModelElement>;\r\n    isSelected!: Dictionary<DocString<Pointer<DUser>>, boolean>;\r\n    // containedIn!: Pointer<DGraphElement, 0, 1, LGraphElement>;\r\n    subElements!: Pointer<DGraphElement, 0, 'N', LGraphElement>;\r\n    state!: GObject; // DMap\r\n    father!: Pointer<DGraphElement, 1, 1, LGraphElement>;\r\n    x!: number;\r\n    y!: number;\r\n    zIndex: number = 100;\r\n    w!: number;\r\n    h!: number;\r\n    // width: number = 300;\r\n    // height: number = 400;\r\n    view!: Pointer<DViewElement, 1, 1, LViewElement>;\r\n    favoriteNode!: boolean;\r\n    edgesIn!: Pointer<DEdge>[];\r\n    edgesOut!: Pointer<DEdge>[];\r\n    anchors!: Dictionary<string, GraphPoint/* as % of node size.*/>;\r\n\r\n\r\n    public static new(htmlindex: number, model: DGraphElement[\"model\"]|null|undefined, parentNodeID: DGraphElement[\"father\"],\r\n                      graphID: DGraphElement[\"graph\"], nodeID?: DGraphElement[\"id\"]|undefined, a?: any, b?:any, ...c:any): DGraphElement {\r\n        return new Constructors(new DGraphElement('dwc'), parentNodeID, true, undefined, nodeID)\r\n            .DPointerTargetable()\r\n            .DGraphElement(model, graphID, htmlindex).end();\r\n    }\r\n\r\n}\r\n@RuntimeAccessible('LGraphElement')\r\nexport class LGraphElement<Context extends LogicContext<DGraphElement> = any, C extends Context = Context> extends LPointerTargetable {\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static getNodeId<L extends LGraphElement, D extends DGraphElement>(o?:L | D | Pointer<D> | LModelElement | DModelElement | Pointer<DModelElement>): Pointer<D> {\r\n        if (!o) return undefined as any;\r\n        let node: any = o;\r\n        // from L to D\r\n        // let cname = (node.__raw || node).className;\r\n        // from DModelE to LGraphE\r\n        if (RuntimeAccessibleClass.extends((o as any).className, \"DModelElement\")) node = LPointerTargetable.from(o as DModelElement).node as LGraphElement;\r\n        return (typeof node === \"string\") ? node : node?.id;\r\n    }\r\n    // static singleton: LGraphElement;\r\n    // static logic: typeof LGraphElement;\r\n    // static structure: typeof DGraphElement;\r\n    __raw!: DGraphElement;\r\n    id!: Pointer<DGraphElement, 1, 1, LGraphElement>;\r\n    father!: LGraphElement;\r\n    graph!: LGraph; // todo: can be removed and accessed by navigating .father\r\n    model?: LModelElement;\r\n    // protected isSelected!: Dictionary<DocString<Pointer<DUser>>, boolean>; //  & ((forUser?: Pointer<DUser>) => boolean);\r\n\r\n    // containedIn?: LGraphElement;\r\n    subElements!: LGraphElement[]; // shallow, direct subelements\r\n    _state!: GObject<\"proxified\">; // LMap;\r\n    allSubNodes!: LGraphElement[]; // deep, nested subelements\r\n    x!: number;\r\n    y!: number;\r\n    width!: number;\r\n    height!: number\r\n\r\n    z!:number;\r\n    zIndex!: number;\r\n    __info_of_z__: Info = {type:ShortAttribETypes.EInt, txt: \"alias for zIndex\"};\r\n    __info_of_zIndex__: Info = {type:ShortAttribETypes.EInt,\r\n        txt: \"Determine the z-axis priority of the element.<br/>Higher value tende to overlap other elements.<br/>Lower value tends to be on background.\"};\r\n    zoom!: GraphPoint;\r\n    html?: Element;\r\n\r\n    // fittizi\r\n    w!:number;\r\n    h!:number;\r\n    size!: GraphSize;\r\n    position!: GraphPoint;\r\n    htmlSize!: Size; // size and position in global document coordinates.\r\n    htmlPosition!: Point;\r\n    view!: LViewElement;\r\n    component!: GraphElementComponent;\r\n    favoriteNode!: boolean;\r\n    vertex?: LVoidVertex;\r\n    __info__of__vertex: Info = {type: \"LVoidVertex\", txt: \"the foremost vertex containing this graphElement, or undefiened.\"}\r\n    __info__of__favoriteNode: Info = {type: ShortAttribETypes.EBoolean,\r\n        txt: \"<span>Indicates this is the primarly used (by default) node to refer to a modelling element that might have multiple representations.\" +\r\n            \"<br> Can be used as favorite target for edges or other.\"}\r\n\r\n    startPoint!: GraphPoint;\r\n    endPoint!: GraphPoint;\r\n    __info_of__startPoint: Info = {type: \"GraphPoint\", txt:<span>Where the outgoing edges should start their paths.\r\n            <br/>Obtained by combining anchoring point offset specified in view, before snapping to a Vertex border.\r\n            <br/>Defaults in outer coordinates.</span>};\r\n    __info_of__endPoint: Info = {type: \"GraphPoint\", txt:<span>Where the incoming edges should end their paths.\r\n            <br/>Obtained by combining anchoring point offset specified in view, before snapping to a Vertex border.\r\n            <br/>Defaults in outer coordinates.</span>};\r\n\r\n    __info_of__graph: Info = {type:\"\", txt:\"\"};\r\n    innerGraph!: LGraph;\r\n    __info_of__innnerGraph: Info = {type:\"\", txt:\"\"};\r\n    outerGraph!: LGraph;\r\n    __info_of__outerGraphGraph: Info = {type:\"\", txt:\"\"};\r\n    get_graph(context: Context): LGraph { return this.get_innerGraph(context); }\r\n\r\n    __info_of__graphAncestors: Info = {type:\"LGraph[]\",\r\n        txt:\"<span>collection of the stack of Graphs containing the current element where [0] is the most nested graph, and last is root graph.</span>\"};\r\n    graphAncestors!: LGraph[];\r\n\r\n    anchors!: Dictionary<string, GraphPoint/* as % of node size.*/>;\r\n    __info_of__anchors: Info = {type:\"Dictionary<string, point>\", txt: <div>A named list of all anchor points where edges are allowed to land or depart from.<br/>\r\n            {/*When reading it is in absolute sizes.<br/>*/}\r\n            When writing it must be done in percentages, with the same rules as node.state.</div>}\r\n    get_anchors(c: Context): this[\"anchors\"]{ return c.data.anchors; }\r\n    set_anchors(v: this[\"anchors\"], c: Context):boolean{\r\n        if (v !== undefined && (typeof v !== \"object\" || Array.isArray(v))){\r\n            Log.ee('cannot set anchors: invalid value provided');\r\n            return true;\r\n        }\r\n        if (v){ // if !v it means clear all anchors?\r\n            for (let ka in v){//for each anchor\r\n                if (!v[ka]) continue;\r\n\r\n                if (c.data.anchors[ka]) {\r\n                    for (let kk in v[ka]) { //for each key within an anchor (x, y, w, h)\r\n                        // if i was attempting to set a partial size, complete it with the old size values.\r\n                        if ((v[ka][kk] === undefined) && (c.data.anchors[ka][kk] !== undefined)) v[ka][kk] = c.data.anchors[ka][kk];\r\n                    }\r\n                }\r\n                if (v[ka].x === undefined || isNaN(v[ka].x)) v[ka].x = 0.5;\r\n                if (v[ka].y === undefined || isNaN(v[ka].y)) v[ka].y = 0.5;\r\n                // if (v[ka].w === undefined || isNaN(v[ka].w)) v[ka].w = 5;\r\n                // if (v[ka].h === undefined || isNaN(v[ka].h)) v[ka].h = 5;\r\n            }\r\n        }\r\n        SetFieldAction.new(c.data, \"anchors\", v, '+=', false);\r\n        return true; }\r\n\r\n    edgesIn!: LVoidEdge[];\r\n    edgesOut!: LVoidEdge[];\r\n    __info_of__edgesIn: Info = {type:\"LEdge[]\", txt:<div>Edges incoming into this element. <code>this.edgesOut[i].end</code> always equals to <code>this</code>.</div>}\r\n    __info_of__edgesOut: Info = {type:\"LEdge[]\", txt:<div>Edges outgoing from this element. <code>this.edgesIn[i].start</code> always equals to <code>this</code>.</div>}\r\n    __info_of__edgesStart: Info = {type:\"LEdge[]\", txt:<div>Alias for this.edgesOut</div>}\r\n    __info_of__edgesEnd: Info = {type:\"LEdge[]\", txt:<div>Alias for this.edgesIn</div>}\r\n    public get_edgesIn(context: Context): this[\"edgesIn\"] { return LPointerTargetable.fromArr(context.data.edgesIn); }\r\n    public get_edgesOut(context: Context): this[\"edgesOut\"]  { return LPointerTargetable.fromArr(context.data.edgesOut); }\r\n    public set_edgesIn(val: PackArr<LVoidEdge>, c: Context): boolean { return SetFieldAction.new(c.data.id, \"edgesIn\", Pointers.fromArr(val), '', true); }\r\n    public set_edgesOut(val: PackArr<LVoidEdge>, c: Context): boolean { return SetFieldAction.new(c.data.id, \"edgesOut\", Pointers.fromArr(val), '', true); }\r\n    public get_edgesStart(context: Context): this[\"edgesIn\"]  { return this.get_edgesIn(context); }\r\n    public get_edgesEnd(context: Context): this[\"edgesOut\"]  { return this.get_edgesOut(context); }\r\n    public set_edgesStart(val: PackArr<LVoidEdge>, context: Context): boolean { return this.set_edgesIn(val, context); }\r\n    public set_edgesEnd(val: PackArr<LVoidEdge>, context: Context): boolean { return this.set_edgesOut(val, context); }\r\n\r\n\r\n    protected _defaultGetter(c: Context, k: keyof Context[\"data\"]): any {\r\n        if (k in c.data) return this.__defaultGetter(c, k);\r\n        // if value not found in node, check in view.\r\n        return (this.get_view(c) as any)[k];\r\n        /*let ret: any;\r\n        let view = this.get_view(c);\r\n        try { ret = (view as any)[k] } catch (e) { Log.ee(\"Could not find get_ property \\\"\" + k + \"\\\" in node or view.\", {c, view, k}); return undefined; }\r\n        return ret;*/\r\n    }\r\n\r\n    protected _defaultSetter(v: any, c: Context, k: keyof Context[\"data\"]): true { this.__defaultSetter(v, c, k); return true; }\r\n\r\n    get_graphAncestors(c: Context): LGraph[] {\r\n        let current = c.proxyObject;\r\n        let next = current.father;\r\n        let ret: LGraph[] = [];\r\n        while(next) {\r\n            if (RuntimeAccessibleClass.extends(next.className, DGraph.cname)) ret.push(next as LGraph);\r\n            if (current.id === next.id) break;\r\n            current = next;\r\n            next = next.father;\r\n        }\r\n        return ret;\r\n    }\r\n    get_outerGraph(context: Context): LGraph {\r\n        // todo: this relies on the fact that GraphVertex are not passing their own id to their childrens, but the parent graph id\r\n        return TargetableProxyHandler.wrap(context.data.graph);\r\n    }\r\n    get_vertex(context: Context): this[\"vertex\"] {\r\n        let lcurrent: LGraphElement = LPointerTargetable.fromPointer(context.data.id);\r\n        let dcurrent = lcurrent.__raw;\r\n        // iterate parents.\r\n        while(dcurrent){\r\n            switch(dcurrent.className){\r\n                case DVertex.cname:\r\n                case DVoidVertex.cname:\r\n                case DGraphVertex.cname: return (lcurrent || LPointerTargetable.fromD(dcurrent)) as LVoidVertex;\r\n                default:\r\n                    if (!dcurrent.father || dcurrent.id === dcurrent.father) return undefined;\r\n                    Log.exDev(!dcurrent.father || dcurrent.id === dcurrent.father, \"node failed to get containing vertex\", context.data, dcurrent, lcurrent);\r\n                    lcurrent = LPointerTargetable.fromPointer(dcurrent.father);\r\n                    dcurrent = lcurrent.__raw;\r\n            }\r\n        }\r\n        return undefined;\r\n    }\r\n\r\n    get_innerGraph(context: Context): LGraph {\r\n        let dcurrent = DPointerTargetable.fromPointer(context.data.father);\r\n\r\n        // if no parent, but it's a graph, return itself.\r\n        if (!dcurrent) {\r\n            dcurrent = context.data;\r\n            switch(dcurrent.className){\r\n                case DGraph.cname:\r\n                case DGraphVertex.cname: return (LPointerTargetable.fromD(dcurrent)) as LGraph;\r\n                default: return Log.exDevv(\"root node failed to get containing graph\", {cdata:context.data, dcurrent});\r\n            }\r\n        }\r\n\r\n        // if it have a parent, iterate parents.\r\n        while(true){\r\n            switch(dcurrent?.className){\r\n                case DGraph.cname:\r\n                case DGraphVertex.cname: return (LPointerTargetable.fromD(dcurrent)) as LGraph;\r\n                default:\r\n                    if (!dcurrent.father || dcurrent.id === dcurrent.father) {\r\n                        /*switch(dcurrent.className){\r\n                            case DGraph.name:\r\n                            case DGraphVertex.name: return (lcurrent || LPointerTargetable.fromD(dcurrent)) as LGraph;\r\n                            default: */return Log.exDevv(\"node failed to get containing graph\", {cdata:context.data, dcurrent});\r\n                        //}\r\n                    }\r\n                    dcurrent = DPointerTargetable.fromPointer(dcurrent.father);\r\n            }\r\n        }\r\n    }\r\n\r\n    // set_x(val: this[\"x\"], context: Context): boolean { SetFieldAction.new(context.data.id, \"x\", val, undefined, false); return true; }\r\n    // get_x(context: Context): this[\"x\"] { return context.data.x; }\r\n    get_x(context: Context): this[\"x\"] { return this.get_size(context).x; }\r\n    set_x(val: this[\"x\"], context: Context): boolean { return this.set_size({x:val}, context); }\r\n    get_y(context: Context): this[\"y\"] { return this.get_size(context).y; }\r\n    set_y(val: this[\"y\"], context: Context): boolean { return this.set_size({y:val}, context); }\r\n\r\n    get_w(context: Context): this[\"w\"] { return this.get_size(context).w; }\r\n    set_w(val: this[\"w\"], context: Context): boolean { return this.set_size({w:val}, context); }\r\n    get_h(context: Context): this[\"h\"] { return this.get_size(context).h; }\r\n    set_h(val: this[\"h\"], context: Context): boolean { return this.set_size({h:val}, context); }\r\n\r\n    get_width(context: Context): this[\"w\"] { return this.get_w(context); }\r\n    set_width(val: this[\"w\"], context: Context): boolean { return this.set_w(val, context); }\r\n    get_height(context: Context): this[\"h\"] { return this.get_h(context); }\r\n    set_height(val: this[\"h\"], context: Context): boolean { return this.set_h(val, context); }\r\n\r\n    get_position(context: Context): this[\"position\"] { return new GraphPoint(context.data.x, context.data.y); }\r\n    set_position(val: this[\"position\"], context: Context): boolean {\r\n        BEGIN()\r\n        SetFieldAction.new(context.data.id, \"x\", val.x, undefined, false);\r\n        SetFieldAction.new(context.data.id, \"y\", val.y, undefined, false);\r\n        END()\r\n        return true; }\r\n\r\n    get_sizeold(context: Context): this[\"size\"] { return new GraphSize(context.data.x, context.data.y, context.data.w, context.data.h); }\r\n    get_component(context: Context): this[\"component\"] {\r\n        // switch(context.data.className) { case DEdgePoint.name: return GraphElementComponent.map[context.data.father]; }\r\n        return GraphElementComponent.map[context.data.id]; }\r\n    // get_view(context: Context): this[\"view\"] { return this.get_component(context).props.view; }\r\n    get_view(context: Context): this[\"view\"] {\r\n        return transientProperties.node[context.data.id]?.mainView || LPointerTargetable.from(context.data.view) || this.get_component(context)?.props.view;\r\n    }\r\n    set_view(val: Pack1<this[\"view\"]>, context: Context){\r\n        Log.eDevv(\"node.view is readonly, change it through props or the model\");\r\n        // let ptr: DGraphElement[\"view\"] = Pointers.from(val as this[\"view\"]);\r\n        // return SetFieldAction.new(context.data.id, \"view\", ptr, '', true);\r\n    }\r\n\r\n    outerSize!: LGraphElement[\"size\"];\r\n    __info_of__outerSize: Info = {type:\"GraphSize\", txt:\"the size of the current element relative to the first (root) graph level.\"};\r\n    innerSize!: LGraphElement[\"size\"];\r\n    __info_of__innerSize: Info = {type:\"GraphSize\", txt:\"the size of the current element relative to the last (most nested) graph level.\"};\r\n    __info_of__size: Info = {type:\"GraphSize\", txt: \"same as innerSize.\"};\r\n\r\n\r\n    getSize(outer: boolean = false, canTriggerSet: boolean = true): Readonly<GraphSize> { return this.wrongAccessMessage(\"getSize()\"); }\r\n    get_getSize(c: Context): ((outer?: boolean, canTriggerSet?: boolean) => Readonly<GraphSize>) {\r\n        return (outer: boolean = true, canTriggerSet: boolean = true) => this.get_innerSize(c, canTriggerSet, outer); }\r\n\r\n    get_outerSize(context: Context, canTriggerSet: boolean = true): Readonly<GraphSize> {\r\n        return this.get_innerSize(context, canTriggerSet, true);\r\n    }\r\n    get_size(context: Context, canTriggerSet: boolean = true): Readonly<GraphSize> { return this.get_innerSize(context, canTriggerSet, false); }\r\n    get_innerSize(context: Context, canTriggerSet: boolean = true, outerSize: boolean = false): Readonly<GraphSize> {\r\n        let r = this.get_innerSize_impl(context, canTriggerSet, outerSize);\r\n        return new GraphSize(r.x, r.y, r.w, r.h);\r\n    }\r\n    protected get_innerSize_impl(context: Context, canTriggerSet: boolean = true, outerSize: boolean = false): Readonly<GraphSize> {\r\n        canTriggerSet = canTriggerSet && !Debug.lightMode;\r\n        switch (context.data.className){\r\n            default: return Log.exDevv(\"unexpected classname in get_size switch: \" + context.data.className);\r\n            case DEdge.cname:\r\n            case DVoidEdge.cname:\r\n            case DGraph.cname: return nosize as any;\r\n            // case DField.cname:\r\n            case DGraphElement.cname:\r\n                let graph = outerSize ? this.get_outerGraph(context) : this.get_innerGraph(context);\r\n                return graph.coord(this.get_htmlSize(context));\r\n            case DVoidVertex.cname:\r\n            case DVertex.cname:\r\n            case DEdgePoint.cname:\r\n            case DGraphVertex.cname: break;\r\n        }\r\n\r\n        // low prio todo: memoization in proxy, as long state does not change keep a collection Dictionary[object][key] = returnval. it gets emptied when state is updated.\r\n\r\n        // when loading a save, edge segements and edgepoints/nodes are computed before creating the edgepoint component\r\n        let view: LViewElement = this.get_view(context);\r\n        // (window as any).retry = ()=>view.getSize(context.data.id);\r\n        let ret: EPSize = view.getSize(context.data.id) as any; // (this.props.dataid || this.props.nodeid as string)\r\n\r\n        // console.log(\"getSize() from view\", {ret: ret ? {...ret} : ret});\r\n        if (!ret) {\r\n            ret = new GraphSize() as EPSize;\r\n            ret.x = context.data.x;\r\n            ret.y = context.data.y;\r\n            ret.w = context.data.w;\r\n            ret.h = context.data.h;\r\n            let def: GraphSize | undefined;\r\n            if (undefined===(ret.x)) { if (!def) def = view.defaultVSize; ret.x = def.x || 0;}\r\n            if (undefined===(ret.y)) { if (!def) def = view.defaultVSize; ret.y = def.y || 0;}\r\n            if (undefined===(ret.w)) { if (!def) def = view.defaultVSize; ret.w = def.w || 10;}\r\n            if (undefined===(ret.h)) { if (!def) def = view.defaultVSize; ret.h = def.h | 10;}\r\n            ret.currentCoordType = (context.data as DEdgePoint).currentCoordType as any;\r\n            // console.log(\"getSize() from node merged with defaultVSize\", {ret: ret ? {...ret} : ret});\r\n        }\r\n        if (context.data.className === DEdgePoint.cname) {\r\n            ret = (this as any as LEdgePoint).decodePosCoords(context, ret, view);\r\n        }\r\n\r\n        /*\r\n                if ((context.data as DVoidVertex).isResized) {\r\n                    return ret;\r\n                }*/\r\n        if (!canTriggerSet) {\r\n            if (outerSize) ret = this.get_outerGraph(context).translateSize(ret, this.get_innerGraph(context));\r\n            return ret;\r\n        }\r\n        let html: RefObject<HTMLElement | undefined> | undefined = this.get_component(context)?.html;\r\n        let actualSize: Partial<Size> & {w:number, h:number} = html?.current ? Size.of(html.current) : {w:0, h:0};\r\n        let updateSize: boolean = false;\r\n        let isOldElement = (context.data.clonedCounter as number) > 3;\r\n        // if w = 0 i don't auto-set it as in first render it has w:0 because is not reredered and not resized.\r\n        // if (canTriggerSet) this.set_size({w:actualSize.w}, context);\r\n        if (view.adaptWidth && ret.w !== actualSize.w) {\r\n            if (canTriggerSet && (isOldElement || actualSize.w !== 0)) {\r\n                ret.w = actualSize.w;\r\n                updateSize = true;\r\n            }\r\n        }\r\n        if (view.adaptHeight && ret.h !== actualSize.h) {\r\n            if (canTriggerSet && (isOldElement || actualSize.h !== 0)) {\r\n                ret.h = actualSize.h;\r\n                updateSize = true;\r\n            }\r\n        }\r\n        // console.log(\"getSize() from node merged with actualSize\", {ret: {...ret}});\r\n\r\n        if (updateSize) this.set_size(ret, context);\r\n        if (outerSize) ret = this.get_outerGraph(context).translateSize(ret, this.get_innerGraph(context));\r\n        return ret;\r\n    }\r\n    // set_size(size: Partial<this[\"size\"]>, context: Context): boolean {\r\n    set_size(size0: Partial<GraphSize>, c: Context): boolean {\r\n        // console.log(\"setSize(\"+(this.props?.data as any).name+\") thisss\", this);\r\n        if (!size0) return false;\r\n        let size = size0 as Partial<EPSize>;\r\n        let view = this.get_view(c);\r\n        let testmode: boolean = false;\r\n        if (c.data.className === DEdgePoint.cname && size.currentCoordType !== CoordinateMode.absolute) size = (this as any as LEdgePoint).encodePosCoords(c as any, size, view);\r\n\r\n        if (view.updateSize(c.data.id, size)) return true;\r\n        BEGIN()\r\n        if (size.x !== c.data.x && size.x !== undefined) SetFieldAction.new(c.data.id, \"x\", size.x, undefined, false);\r\n        if (size.y !== c.data.y && size.y !== undefined) SetFieldAction.new(c.data.id, \"y\", size.y, undefined, false);\r\n        if (size.w !== c.data.w && size.w !== undefined) SetFieldAction.new(c.data.id, \"w\", size.w, undefined, false);\r\n        if (size.h !== c.data.h && size.h !== undefined) SetFieldAction.new(c.data.id, \"h\", size.h, undefined, false);\r\n        let epdata: DEdgePoint = c.data as DEdgePoint;\r\n        if (size.currentCoordType !== epdata.currentCoordType && size.currentCoordType !== undefined) SetFieldAction.new(epdata.id, \"currentCoordType\", size.currentCoordType, undefined, false);\r\n        END()\r\n        return true; }\r\n\r\n    get_html(c: Context): this[\"html\"] {\r\n        let component = this.get_component(c);\r\n        let html = component.html.current;\r\n        if (html) return html;\r\n        html = $('[nodeid=\"' + c.data.id + '\"]')[0];\r\n        if (!html) return undefined;\r\n        (component.html as any).current = html;\r\n        return html;\r\n    }\r\n    // get_html(context: Context): this[\"html\"] { return $(\"[node-id='\" + context.data.id + \"']\")[0]; }\r\n    set_html(val: this[\"htmlSize\"], context: Context): boolean { return this.cannotSet(\"set_html(). html is generated through jsx. edit the view instead.\"); }\r\n\r\n    get_htmlSize(context: Context): this[\"htmlSize\"] {\r\n        let html = this.get_html(context);\r\n        return html ? Size.of(html) : new Size(0, 0, 0, 0);\r\n        /*\r\n        let graph = this.get_graph(context);\r\n        if (!html) return nosize as any;\r\n        let size = Size.of(html);\r\n        let zoom = graph.zoom;\r\n        size.x /= zoom.x;\r\n        size.y /= zoom.y;\r\n        return size;*/}\r\n    set_htmlSize(val: this[\"htmlSize\"], context: Context): boolean {\r\n        // might be useful for fixed display size/location elements that stay in place even if you move tab or change zoom. debatable if needed\r\n        this.cannotSet(\"set_htmlSize(): todo extra low priority. set GraphSize through set_size instead.\");\r\n        return true; }\r\n    get_htmlPosition(context: Context): this[\"htmlPosition\"] { return this.get_htmlSize(context).tl(); }\r\n    set_htmlPosition(val: this[\"htmlPosition\"], context: Context): boolean {\r\n        // might be useful for fixed display size/location elements that stay in place even if you move tab or change zoom. debatable if needed\r\n        this.cannotSet(\"set_htmlPosition(): todo extra low priority. set graph position through set_position instead.\");\r\n        return true; }\r\n\r\n\r\n    /* how z-index work, it's really messy.\r\n    * cannot move html position. node id depends on it, and a node moving position would need to change id.\r\n    * so i use css order.\r\n    * first order is assigned through node constructor called by parent component injectProps, according to his last index in html.\r\n    * now z-index is set in node and updated properly.\r\n    * z-index is passed to a prop, rendered as html attribute.\r\n    * css takes the attribute value and uses it in \"order\" css rule.\r\n    * problem: updating node.z doesn't trigger the parent injectprops, so he inject html index and\r\n    * the outernmost html root cannot update his attribute without refreshing the parent and recalling injectprops\r\n    * fixed: by updating it directly in GraphElement.render()\r\n    * */\r\n    get_zIndex(context: Context): this[\"zIndex\"] { return context.data.zIndex; }\r\n    set_zIndex(val: this[\"zIndex\"], context: Context): boolean {\r\n        SetFieldAction.new(context.data.id, \"zIndex\", val, undefined, false);\r\n        return true; }\r\n    get_z(context: Context): this[\"zIndex\"] { return context.data.zIndex; }\r\n    set_z(val: this[\"zIndex\"], context: Context): boolean { return this.set_zIndex(val, context); }\r\n    /*\r\n        get_containedIn(context: Context): this[\"containedIn\"] {\r\n            return context.data.containedIn ? LPointerTargetable.fromPointer(context.data.containedIn) : undefined; }\r\n        set_containedIn(val: Pack1<this[\"containedIn\"]>, context: LogicContext<DGraphElement>): boolean {\r\n            let ptr: DGraphElement[\"containedIn\"] = Pointers.from(val) as any;\r\n            SetFieldAction.new(context.data, 'containedIn', ptr, undefined, true);\r\n            if (ptr) SetFieldAction.new(ptr as any, 'subElements+=', context.data.id);\r\n            return true; }*/\r\n\r\n    get_subElements(context: Context): this[\"subElements\"] {\r\n        return LPointerTargetable.fromArr([...new Set(context.data.subElements)]);\r\n    }\r\n    set_subElements(val: PackArr<this[\"subElements\"]>, context: LogicContext<DGraphElement>): boolean {\r\n        console.log(\"isDeepStrictEqual\", {isDeepStrictEqual});\r\n        Log.eDev([...new Set(val)].length !== val.length, \"subelemnts setter have duplicates\", {val, context});\r\n        // if (isDeepStrictEqual(context.data.subElements, val)) return true;\r\n        let pointers: Pointer<DGraphElement, 0, 'N', LGraphElement> = Pointers.from(val) || [];\r\n        if (Uarr.equals(pointers, context.data.subElements, false)) return true;\r\n        SetFieldAction.new(context.data, 'subElements', pointers, '', true);\r\n        const idlookup = store.getState().idlookup;\r\n        let arrdiff = U.arrayDifference(context.data.subElements, pointers);\r\n        // old subelements\r\n        for (let oldsubelementid of arrdiff.removed) {\r\n            let subelement: DGraphElement = (oldsubelementid && idlookup[oldsubelementid]) as DGraphElement;\r\n            if (subelement.father !== context.data.id) continue;\r\n            LPointerTargetable.from(subelement).father = null as any; // todo: can this happen? è transitorio o causa vertici senza parent permanenti?\r\n        }\r\n        // new subelements\r\n        for (let newsubelementid of arrdiff.added) {\r\n            let subelement: DGraphElement = (newsubelementid && idlookup[newsubelementid]) as DGraphElement;\r\n            if (subelement.father === context.data.id) continue;\r\n            LPointerTargetable.from(subelement).father = context.data.id as any; // trigger side-action\r\n        }\r\n        return true;\r\n    }\r\n\r\n    get_isResized(context: LogicContext<DVoidVertex>): DVoidVertex[\"isResized\"] { return context.data.isResized; }\r\n    set_isResized(val: DVoidVertex[\"isResized\"], context: LogicContext<DVoidVertex>): DVoidVertex[\"isResized\"] {\r\n        return SetFieldAction.new(context.data.id, \"isResized\", val);\r\n    }\r\n\r\n    get_model(context: Context): this[\"model\"] {\r\n        const modelElementId = context.data.model; //$('[id=\"' + context.data.id + '\"]')[0].dataset.dataid;\r\n        const lModelElement: LModelElement = LPointerTargetable.from(modelElementId as string);\r\n        return lModelElement;\r\n    }\r\n\r\n    private get_allSubNodes(context: Context, state?: DState): this[\"allSubNodes\"] {\r\n        // return context.data.packages.map(p => LPointerTargetable.from(p));\r\n        state = state || store.getState();\r\n        let tocheck: Pointer<DGraphElement>[] = context.data.subElements || [];\r\n        let checked: Dictionary<Pointer, true> = {};\r\n        let dblcheck: Dictionary<Pointer, Pointer> = {}; // <child, parent>  // debug only\r\n        for (let e of tocheck) dblcheck[e] = context.data.id; // debug only\r\n        checked[context.data.id] = true;//nb6[]{}&\r\n        while (tocheck.length) {\r\n            let newtocheck: Pointer<DGraphElement>[] = [];\r\n            for (let ptr of tocheck) {\r\n                Log.eDev(checked[ptr], \"loop in GraphElements containing themselves\", {dblcheck, context, ptr, checked, fistContainer:dblcheck[ptr]});\r\n                if (checked[ptr]) continue;\r\n                checked[ptr] = true;\r\n                let subnode: DGraphElement = DPointerTargetable.from(ptr, state);\r\n                let se = subnode?.subElements;\r\n                for (let e of se) dblcheck[e] = ptr; // debug only\r\n                U.arrayMergeInPlace(newtocheck, se);\r\n            }\r\n            tocheck = newtocheck;\r\n        }\r\n        delete checked[context.data.id];\r\n        return LPointerTargetable.from(Object.keys(checked), state);\r\n    }\r\n    assignEdgeAnchor!: ((anchorName?: string)=>void);\r\n    __info_of__assignEdgeAnchor!: {hidden:true, type:\"(anchorName?: string)=>void\", txt: \"Assign a specific anchor of this node to the edge currently following the cursor, if any.\"};\r\n    get_assignEdgeAnchor(c: Context): ((anchorName?: string)=>void) {\r\n        return (anchorName?: string)=>{\r\n            if (anchorName && !c.data.anchors[anchorName]) anchorName = undefined;\r\n            if (LVoidEdge.startFollow) {\r\n                let de: DEdge = DPointerTargetable.fromPointer(LVoidEdge.startFollow);\r\n                if (de.start !== c.data.id) return; // cannot change edge targets, only an anchor within the current targets\r\n                let le: LVoidEdge = LPointerTargetable.fromD(de);\r\n                le.anchorStart = anchorName;\r\n                le.startFollow = false;\r\n\r\n            }\r\n            if (LVoidEdge.endFollow) {\r\n                let de = DPointerTargetable.fromPointer(LVoidEdge.endFollow);\r\n                if (de.end !== c.data.id) return; // cannot change edge targets, only an anchor within the current targets\r\n                let le = LPointerTargetable.fromD(de);\r\n                le.anchorEnd = anchorName;\r\n                le.endFollow = false;\r\n            }\r\n        }\r\n    }\r\n    get_events(c: Context): LViewElement[\"events\"] {\r\n        const tn = transientProperties.node[c.data.id];\r\n        let mainview: DViewElement = tn.mainView.__raw;\r\n        let otherViews: DViewElement[] = tn.stackViews.map(v=>v.__raw);\r\n        let allviews: DViewElement[] = [mainview, ...otherViews].reverse();\r\n        const keep_for_closure_original_funcs: LViewElement[\"events\"] = {};\r\n        const ret: LViewElement[\"events\"] = {};\r\n        for (let dv of allviews) U.objectMergeInPlace(keep_for_closure_original_funcs, transientProperties.view[dv.id].events);\r\n\r\n        const lastContext: GObject = tn.viewScores[mainview.id].evalContext;\r\n        const keys = Object.keys(keep_for_closure_original_funcs);\r\n        // for (let k of keys) ret['_raw_'+k] = keep_for_closure_original_funcs[k];\r\n        for (let k of keys) {\r\n            if (!keep_for_closure_original_funcs[k]) continue;\r\n            ret[k] = (..._params: any) => keep_for_closure_original_funcs[k](lastContext, ..._params);\r\n        }\r\n\r\n        return ret; }\r\n\r\n\r\n    get_father(context: Context): this[\"father\"] { return LPointerTargetable.fromPointer(context.data.father); }\r\n    set_father(val: Pack1<this[\"father\"]>, context: Context): boolean {\r\n        let ptr: DGraphElement[\"father\"] = Pointers.from(val) as any;\r\n        SetFieldAction.new(context.data, 'father', ptr, undefined, true);\r\n        if (ptr) SetFieldAction.new(ptr as any, 'subElements+=', context.data.id);\r\n        return true; }\r\n\r\n    __info_of__isselected: Info = {type: \"Dictionary<Pointer<User>, true>\",\r\n        txt:<div>A map that contains all the users selecting this element as keys, and always true as a value (if present).\r\n            <br/>Edit it through node.select() and node.deselect()</div>}\r\n    __info_of__select: Info = {type:\"function(forUser?:Pointer<User>):void\", txt:\"Marks this node as selected by argument user.\"};\r\n    __info_of__deselect: Info = {type:\"function(forUser?:Pointer<User>):void\", txt:\"Un-marks this node as selected by argument user.\"};\r\n    __info_of__toggleSelect: Info = {type:\"function(usr?:Pointer<User>):void\", txt:\"Calls this.select(usr) if the node is selected by argument user, this.deselect(usr) otherwise. If omitted, argument \\\"usr\\\" is the current user id.<br>Returns the result of this.isSelected() after the toggle.\"};\r\n    __info_of__isSelected: Info = {type:\"function(forUser?:Pointer<User>):void\", txt:\"Tells if this node is selected by argument user.\"};\r\n    select(forUser?: Pointer<DUser>): void { return this.wrongAccessMessage(\"node.select()\"); }\r\n    deselect(forUser?: Pointer<DUser>): void { return this.wrongAccessMessage(\"node.deselect()\"); }\r\n    toggleSelected(forUser?: Pointer<DUser>): void { return this.wrongAccessMessage(\"node.toggleSelected()\"); }\r\n    isSelected(forUser?: Pointer<DUser>): boolean { return this.wrongAccessMessage(\"node.isSelected()\"); }\r\n    get_select(c: Context): (forUser?: Pointer<DUser>)=>void {\r\n        return (forUser?: Pointer<DUser>)=> {\r\n            if (!forUser) forUser = DUser.current;\r\n            if (c.data.isSelected[forUser]) return; // no-op\r\n            let map = {...c.data.isSelected};\r\n            map[forUser] = true;\r\n            SetFieldAction.new(c.data.id, \"isSelected\", map, undefined, false);\r\n            // todo: actually they are pointer to users, but i'm assuming users are not erased at runtime. on deselect too\r\n        }\r\n    }\r\n    get_deselect(c: Context): (forUser?: Pointer<DUser>)=>void {\r\n        return (forUser?: Pointer<DUser>)=> {\r\n            if (!forUser) forUser = DUser.current;\r\n            if (!c.data.isSelected[forUser]) return; // no-op\r\n            let map = {...c.data.isSelected};\r\n            delete map[forUser];\r\n            SetFieldAction.new(c.data.id, \"isSelected\", map, undefined, false);\r\n            // todo: actually they are pointer to users, but i'm assuming users are not erased at runtime. on deselect too\r\n        }\r\n    }\r\n    get_toggleSelected(context: Context): ((forUser?: Pointer<DUser>) => boolean) {\r\n        return (forUser?: Pointer<DUser>): boolean => {\r\n            if (!forUser) forUser = DUser.current;\r\n            if (this.get_isSelected(context)(forUser)) {\r\n                this.get_deselect(context)(forUser);\r\n                return false;\r\n            } else {\r\n                this.get_select(context)(forUser);\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    get_isSelected(context: Context): ((forUser?: Pointer<DUser>) => boolean) {\r\n        return (forUser?: Pointer<DUser>): boolean => {\r\n            if (!forUser) forUser = DUser.current;\r\n            return !!context.data.isSelected[forUser]; }\r\n    }\r\n    set_isSelected(val: this[\"isSelected\"], context: Context): boolean {\r\n        return this.cannotSet(\"graphElement.isSelected(): use this.select() or this.deselect() instead.\");\r\n    }\r\n    /*\r\n    get_isSelected(context: LogicContext<DVoidVertex>): GObject {\r\n        return DPointerTargetable.mapWrap(context.data.isSelected, context.data, 'idlookup.' + context.data.id + '.isSelected', []);\r\n    }*/\r\n\r\n\r\n\r\n    // for edges\r\n    public get_startPoint(c: Context|undefined, size?: GraphSize, view?: LViewElement): GraphPoint { return this.get_startEndPoint(c, size, view, true); }\r\n    public get_endPoint(c: Context|undefined, size?: GraphSize, view?: LViewElement): GraphPoint { return this.get_startEndPoint(c, size, view, false); }\r\n    private get_startEndPoint(c: Context|undefined, size?: GraphSize, view?: LViewElement, isStart:boolean=true): GraphPoint {\r\n        if (!size) {\r\n            if (c) size = this.get_size(c) as any; else size = Log.exDevv(\"invalid arguments in get_startEndPoint\", {arguments});\r\n        }\r\n        if (!view) {\r\n            // if (c) view = this.get_view(c); else view = Log.exDevv(\"invalid arguments in get_startPoint\", {arguments});\r\n            view = c && this.get_view(c) || Log.exDevv(\"invalid arguments in get_startEndPoint\", {arguments});\r\n        }\r\n        let offset: GraphPoint = (view as LViewElement)[isStart ? \"edgeStartOffset\" : \"edgeEndOffset\"];\r\n        let isPercentage: boolean = (view as LViewElement)[isStart ? \"edgeStartOffset_isPercentage\" : \"edgeEndOffset_isPercentage\"];\r\n        if (!size) size = new GraphSize(0, 0, 0, 0);\r\n        if (isPercentage) offset = new GraphPoint(offset.x/100*(size.w), offset.y/100*(size.h));\r\n        return size.tl().add(offset, false);\r\n    }\r\n\r\n}\r\nRuntimeAccessibleClass.set_extend(DPointerTargetable, DGraphElement);\r\nRuntimeAccessibleClass.set_extend(LPointerTargetable, LGraphElement)\r\n\r\n\r\n@RuntimeAccessible('DGraph')\r\nexport class DGraph extends DGraphElement {\r\n    // static _super = DGraphElement;\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // static singleton: LGraph;\r\n    // static logic: typeof LGraph;\r\n    // static structure: typeof DGraph;\r\n\r\n    // inherit redefine\r\n    father!: Pointer<DGraphElement, 1, 1, LGraphElement>;\r\n    id!: Pointer<DGraph, 1, 1, LGraph>;\r\n    graph!: Pointer<DGraph, 1, 1, LGraph>;\r\n    model!: Pointer<DModelElement, 1, 1, LModelElement>;\r\n    isSelected!: Dictionary<DocString<Pointer<DUser>>, boolean>;\r\n    // containedIn!: Pointer<DGraphElement, 0, 1, LGraphElement>;\r\n    subElements!: Pointer<DGraphElement, 0, 'N', LGraphElement>;\r\n    state!: GObject;\r\n    // personal attributes\r\n    zoom!: GraphPoint;\r\n    offset!: GraphPoint; // in-graph scrolling offset\r\n\r\n    public static new(htmlindex: number, model: DGraph[\"model\"],\r\n                      parentNodeID?: DGraphElement[\"father\"], // immediate parent\r\n                      parentgraphID?: DGraphElement[\"graph\"], // graph containing this subgraph (redudant? could get it from father chain)\r\n                      nodeID?: DGraphElement[\"id\"] // this id\r\n    ): DGraph {\r\n        return new Constructors(new DGraph('dwc'), parentNodeID, true, undefined, nodeID || Constructors.DGraph_makeID(model))\r\n            .DPointerTargetable()\r\n            .DGraphElement(model, parentgraphID, htmlindex).DGraph().end();\r\n    }\r\n\r\n\r\n    static getNodes(dmp: import(\"../logicWrapper/LModelElement\").DModelElement[], out: {$matched: JQuery<HTMLElement>; $notMatched: JQuery<HTMLElement>; }): JQuery<HTMLElement> {\r\n        let $allnodes = $('[data-dataid]');\r\n        let matchedids: Pointer[] = (dmp || []).map(d => d.id);\r\n        let matchedidmap:Dictionary<string, boolean> = U.objectFromArrayValues(matchedids);\r\n        if (!out) out = {} as any;\r\n\r\n        let allnodesarr = [...$allnodes];\r\n        let filternode = (d: HTMLElement) => {\r\n            if (!d?.dataset?.dataid) return false;\r\n            let id: string = ''+d?.dataset?.dataid;\r\n            return matchedidmap[id]; };\r\n        out.$matched = $(allnodesarr.filter(filternode));\r\n        out.$notMatched = $(allnodesarr.filter((n) => !filternode(n)));\r\n        return out.$matched;\r\n        // throw new Error(\"Method not implemented.\");\r\n    }\r\n\r\n}\r\nvar nosize: GraphSize = {x:0, y:0, w:0, h:0, nosize:true} as any;\r\nvar defaultEdgePointSize: GraphSize = undefined as any; // = {x:0, y:0, w:5, h:5};\r\nvar defaultVertexSize: GraphSize = undefined as any; // {x:0, y:0, w:140.6818084716797, h:32.52840805053711};\r\n\r\n\r\n@RuntimeAccessible('LGraph')\r\nexport class LGraph<Context extends LogicContext<DGraph> = any, D extends DGraph = any> extends LGraphElement {\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // static singleton: LGraph;\r\n    // static logic: typeof LGraph;\r\n    // static structure: typeof DGraph;\r\n\r\n    // inherit redefine\r\n    __raw!: DGraph;\r\n    id!: Pointer<DGraph, 1, 1, LGraph>;\r\n    graph!: LGraph;\r\n    model?: LModelElement;\r\n    // isSelected: Dictionary<DocString<Pointer<DUser>>, boolean> = {};\r\n    isSelected(forUser?: Pointer<DUser>): boolean { return this.wrongAccessMessage(\"node.isSelected()\"); }\r\n    // containedIn?: LGraphElement;\r\n    subElements!: LGraphElement[];\r\n    _state!: GObject<\"proxified\">; // LMap;\r\n    // personal attributes\r\n    zoom!: GraphPoint;\r\n    graphSize!: GraphSize; // derived attribute: bounding rect containing all subnodes, while \"size\" is instead external size of the vertex holding the graph in GraphVertexes\r\n    offset!: GraphPoint; // Scrolling position inside the graph\r\n\r\n    // get_graphSize(context: LogicContext<DGraph>):  Readonly<GraphSize> { return todo: get bounding rect containing all subnodes.; }\r\n    get_offset(context: LogicContext<DGraph>):  Readonly<GraphSize> {\r\n        return new GraphSize(context.data.offset.x, context.data.offset.y);\r\n    }\r\n    set_offset(val: Partial<GraphPoint>, context: Context): boolean {\r\n        if (!val) val = {x:0, y:0};\r\n        if (context.data.offset.x === val.x && context.data.offset.y === val.y) return true;\r\n        if (val.x === undefined && context.data.offset.x !== val.x) val.x = context.data.offset.x;\r\n        if (val.y === undefined && context.data.offset.y !== val.y) val.y = context.data.offset.y;\r\n        SetFieldAction.new(context.data, \"offset\", val as GraphPoint);\r\n        return true;\r\n    }\r\n    get_zoom(context: Context): GraphPoint {\r\n        const zoom: GraphPoint = context.data.zoom;\r\n        // (zoom as any).debug = {rawgraph: context.data.__raw, zoomx: context.data.zoom.x, zoomy: context.data.zoom.y}\r\n        return context.data.zoom; }\r\n\r\n    toGraphSize(...a:Parameters<this[\"coord\"]>): ReturnType<this[\"coord\"]>{ return this.wrongAccessMessage(\"toGraphSize\"); }\r\n    coord(htmlSize: Size): GraphSize { return this.wrongAccessMessage(\"toGraphSize\"); }\r\n    get_coord(context: Context): (htmlSize: Size) => GraphSize {\r\n        return (htmlSize: Size)=> {\r\n            let size: Size = this.get_htmlSize(context);\r\n            let zoom: GraphPoint = this.get_zoom(context);\r\n            return new GraphSize((htmlSize.x - size.x) / zoom.x, (htmlSize.y - size.y) / zoom.y, htmlSize.w/zoom.x, htmlSize.h/zoom.y);\r\n        }\r\n    }\r\n    // get_htmlSize(context: Context): Size { }\r\n    translateSize<T extends GraphSize|GraphPoint>(ret: T, innerGraph: LGraph): T { return this.wrongAccessMessage(\"translateSize()\"); }\r\n    translateHtmlSize<T extends Size|Point, G = T extends Size ? GraphSize : GraphPoint>(size: T): G { return this.wrongAccessMessage(\"translateHtmlSize()\"); }\r\n\r\n    __info_of__zoom: Info = {type:GraphPoint.cname, label:\"zoom\", txt:\"Scales the graph and all subelements by a factor.\"};\r\n    set_zoom(val: Partial<GraphPoint>, c: Context): boolean{\r\n        SetFieldAction.new(c.data, 'zoom', val as any, '+=', false);\r\n        return true;\r\n    }\r\n    __info_of__offset: Info = {type:GraphPoint.cname, label:\"offset\", txt:\"In-graph scrolling position.\"};\r\n    __info_of__graphSize: Info = {type:GraphSize.cname, label:\"graphSize\", txt:\"size internal to the graph, including internal scroll and panning.\"};\r\n    __info_of__translateSize: Info = {type:\"(T, Graph)=>T where T is GraphSize | GraphPoint\", txt:\"Translates a coordinate set from the local coordinates of a SubGraph to this Graph containing it.\"};\r\n    __info_of__translateHtmlSize: Info = {type:\"(Size|Point) => GraphSize|GraphPoint\", txt:\"Translate page\\'s viewport coordinate set to this graph coordinate set.\"};\r\n    get_translateHtmlSize<T extends Size|Point, G = T extends Size ? GraphSize : GraphPoint>(c: Context): ((size: T) => G) {\r\n        return (size: T): G => {\r\n            let graphHtmlSize = this.get_htmlSize(c);\r\n            let a = size.subtract(graphHtmlSize.tl(), true);\r\n            let b = a.add({x:c.data.offset.x, y:c.data.offset.y}, false);\r\n            return b.multiply(c.data.zoom, false) as any as G;\r\n        }\r\n    }\r\n\r\n    get_translateSize<T extends GraphSize|GraphPoint>(c: Context): ((size: T, innerGraph: LGraph) => T) {\r\n        return (size: T, innerGraph: LGraph): T => {\r\n            innerGraph = LPointerTargetable.wrap(innerGraph) as LGraph;\r\n            let ret: T = (size.hasOwnProperty(\"w\") ? new GraphSize(size.x, size.y, (size as GraphSize).w, (size as GraphSize).h) : new GraphPoint(size.x, size.y)) as T;\r\n            Log.ex(!innerGraph, \"translateSize() graph parameter is invalid: \"+innerGraph, innerGraph, c);\r\n            let ancestors: LGraph[] = [innerGraph, ...innerGraph.graphAncestors]\r\n            Log.ex(ancestors.indexOf(c.proxyObject) !== -1, \"translateSize() graph parameter is invalid: it must be a graph containing the current one.\", innerGraph, c);\r\n            for (let g of ancestors) ret.add(g.size.tl(), false);\r\n            // console.log(\"translateSize\", {c, thiss:c.proxyObject, ancestors, ancestorSizes: ancestors.map(a=> a.size.tl()), size, ret});\r\n            return ret; }\r\n    }\r\n    contains(elem: LGraphElement): boolean{ return this.wrongAccessMessage(\"contains()\"); }\r\n    get_contains(c: Context): ((elem: LGraphElement)=> boolean) {\r\n        return (elem: LGraphElement): boolean => {\r\n            let current = elem;\r\n            let next = elem.father;\r\n            let targetid = c.proxyObject.id;\r\n            if (current.id !== targetid) return true;\r\n            while(next && current.id !== next.id) {\r\n                current = next;\r\n                next = next.father;\r\n                if (current.id !== targetid) return true;\r\n            }\r\n            return false;\r\n        }}\r\n}\r\nRuntimeAccessibleClass.set_extend(DGraphElement, DGraph);\r\nRuntimeAccessibleClass.set_extend(LGraphElement, LGraph);\r\n// export const defaultVSize: GraphSize = new GraphSize(0, 0, 300, 160); // useless, now it's in view.DefaultVSize\r\n// export const defaultEPSize: GraphSize = new GraphSize(0, 0, 15, 15); // useless, now it's in view.DefaultVSize\r\n\r\n\r\n@RuntimeAccessible('DVoidVertex')\r\nexport class DVoidVertex extends DGraphElement {\r\n    // static _super = DGraphElement;\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // static singleton: LVoidVertex;\r\n    // static logic: typeof LVoidVertex;\r\n    // static structure: typeof DVoidVertex;\r\n\r\n    // inherit redefine\r\n    id!: Pointer<DVoidVertex, 1, 1, LVoidVertex>;\r\n    graph!: Pointer<DGraph, 1, 1, LGraph>;\r\n    model!: Pointer<DModelElement, 0, 1, LModelElement>;\r\n    isSelected!: Dictionary<DocString<Pointer<DUser>>, boolean>;\r\n    // containedIn!: Pointer<DGraphElement, 0, 1, LGraphElement>;\r\n    subElements!: Pointer<DGraphElement, 0, 'N', LGraphElement>;\r\n    state!: GObject;\r\n    zoom!: GraphPoint;\r\n    // personal attributes\r\n    x!: number;\r\n    y!: number;\r\n    w!: number;\r\n    h!: number;\r\n    isResized!: boolean;\r\n    // size?: GraphSize; // virtual, gets extracted from this. x and y are stored directly here as it extends GraphSize\r\n\r\n    public static new(htmlindex: number, model: DGraphElement[\"model\"], parentNodeID: DGraphElement[\"father\"], graphID: DGraphElement[\"graph\"], nodeID?: DGraphElement[\"id\"],\r\n                      size?: InitialVertexSize): DVoidVertex {\r\n        return new Constructors(new DVoidVertex('dwc'), parentNodeID, true, undefined, nodeID)\r\n            .DPointerTargetable()\r\n            .DGraphElement(model, graphID, htmlindex)\r\n            .DVoidVertex(size || defaultVertexSize).end();\r\n    }\r\n\r\n}\r\n\r\n@RuntimeAccessible('LVoidVertex')\r\nexport class LVoidVertex<Context extends LogicContext<DVoidVertex> = any, C extends Context = Context> extends LGraphElement {// <D extends DVoidVertex = any>\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // static singleton: LVoidVertex;\r\n    // static logic: typeof LVoidVertex;\r\n    // static structure: typeof DVoidVertex;\r\n\r\n    // inherit redefine\r\n    __raw!: DVoidVertex;\r\n    id!: Pointer<DVoidVertex, 1, 1, LVoidVertex>;\r\n    graph!: LGraph;\r\n    model?: LModelElement;\r\n    // isSelected: Dictionary<DocString<Pointer<DUser>>, boolean> = {};\r\n    isSelected(forUser?: Pointer<DUser>): boolean { return this.wrongAccessMessage(\"node.isSelected()\"); }\r\n    // containedIn?: LGraphElement;\r\n    subElements!: LGraphElement[];\r\n    _state!: GObject<\"proxified\">; // LMap;\r\n    zoom!: GraphPoint;\r\n    isResized!: boolean;\r\n\r\n    // personal attributes\r\n    x!: number;\r\n    y!: number;\r\n    w!: number;\r\n    h!: number;\r\n    size!: GraphSize; // virtual, gets extracted from this. x and y are stored directly here as it extends GraphSize\r\n    __info_of__size = {type: \"?GraphSize\", txt: \"Size of the vertex, if null it means is utilizing the defaultSize from view. recommended to read component.getSize() instead of this.\"};\r\n\r\n    get_isResized(context: LogicContext<DVoidVertex>): DVoidVertex[\"isResized\"] { return context.data.isResized; }\r\n    set_isResized(val: DVoidVertex[\"isResized\"], context: LogicContext<DVoidVertex>): DVoidVertex[\"isResized\"] {\r\n        return SetFieldAction.new(context.data.id, \"isResized\", val);\r\n    }\r\n\r\n\r\n\r\n}\r\n\r\nRuntimeAccessibleClass.set_extend(DGraphElement, DVoidVertex);\r\nRuntimeAccessibleClass.set_extend(LGraphElement, LVoidVertex);\r\n@RuntimeAccessible('DEdgePoint')\r\nexport class DEdgePoint extends DVoidVertex { // DVoidVertex\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // static singleton: LEdgePoint;\r\n    // static logic: typeof LEdgePoint;\r\n    // static structure: typeof DEdgePoint;\r\n\r\n    // inherit redefine\r\n    id!: Pointer<DEdgePoint, 1, 1, LEdgePoint>;\r\n    father!: Pointer<DVoidEdge, 1, 1, LVoidEdge>;\r\n    graph!: Pointer<DGraph, 1, 1, LGraph>;\r\n    model!: Pointer<DModelElement, 0, 1, LModelElement>; // todo: if null gets model from this.father (edge)?\r\n    isSelected!: Dictionary<DocString<Pointer<DUser>>, boolean>;\r\n    // containedIn!: Pointer<DGraphElement, 0, 1, LGraphElement>;\r\n    subElements!: Pointer<DGraphElement, 0, 'N', LGraphElement>;\r\n    zoom!: GraphPoint;\r\n    x!: number;\r\n    y!: number;\r\n    w!: number;\r\n    h!: number;\r\n    size?: GraphSize; //／／ virtual, gets extracted from this. x and y are stored directly here as it extends GraphSize\r\n    // personal attributes\r\n    __isDEdgePoint!: true;\r\n    currentCoordType?: CoordinateMode;\r\n\r\n    public static new(htmlindex: number, model: DEdgePoint[\"model\"] | undefined, parentNodeID: DEdgePoint[\"father\"], graphID?: DEdgePoint[\"graph\"], nodeID?: DGraphElement[\"id\"],\r\n                      size?: InitialVertexSize): DEdgePoint {\r\n        return new Constructors(new DEdgePoint('dwc'), parentNodeID, true, undefined, nodeID)\r\n            .DGraphElement(undefined, graphID, htmlindex)\r\n            .DVoidVertex(size || defaultEdgePointSize).DEdgePoint().end();\r\n    }\r\n\r\n}\r\n\r\n@RuntimeAccessible('LEdgePoint')\r\nexport class LEdgePoint<Context extends LogicContext<DEdgePoint> = any, C extends Context = Context> extends LVoidVertex {\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // static singleton: LEdgePoint;\r\n    // static logic: typeof LEdgePoint;\r\n    // static structure: typeof DEdgePoint;\r\n\r\n    // inherit redefine\r\n    father!: LVoidEdge;\r\n    // __raw!: DEdgePoint;\r\n    id!: Pointer<DEdgePoint, 1, 1, LEdgePoint>;\r\n    graph!: LGraph;\r\n    model?: LModelElement;\r\n    // isSelected: Dictionary<DocString<Pointer<DUser>>, boolean> = {};\r\n    isSelected(forUser?: Pointer<DUser>): boolean { return this.wrongAccessMessage(\"node.isSelected()\"); }\r\n    // containedIn?: LGraphElement;\r\n    subElements!: LGraphElement[];\r\n    zoom!: GraphPoint;\r\n    x!: number;\r\n    y!: number;\r\n    w!: number;\r\n    h!: number;\r\n    size!: GraphSize; // virtual, gets extracted from this. x and y are stored directly here as it extends GraphSize\r\n    // personal attributes\r\n    __isLEdgePoint!: true;\r\n    edge!: LVoidEdge; // returns container edge\r\n    __info_of__edge: Info = {type:\"?LEdge\", txt:\"returns the containing edge if called on an EdgePoint, \\\"this\\\" if called on an edge, undefined otherwise.\"}\r\n\r\n    public get_edge(c: Context): LVoidEdge { return c.proxyObject.father; }\r\n    public set_edge(v: Pack1<LVoidEdge>, c: Context): boolean { return this.set_father(v as any, c); }\r\n\r\n\r\n\r\n\r\n    static decodeCoords<T extends Partial<EPSize>>(size0: T, sp:GraphPoint, ep: GraphPoint): T/*absolute*/{\r\n        let size: any = size0;\r\n        let ret: any = ((\"w\" in size || \"h\" in size) ? new GraphSize() : new GraphPoint()); // GObject<Partial<GraphSize>>;\r\n        switch (size.currentCoordType) {\r\n            default: return Log.exDevv(\"translatePosCoords() invalid coordinate mode\", {mode:size.currentCoordType});\r\n            // case CoordinateMode.absolute: return size;\r\n            case CoordinateMode.absolute: case undefined: case null:\r\n                if (size.x !== undefined) ret.x = size.x;\r\n                if (size.y !== undefined) ret.y = size.y;\r\n                break;\r\n            case CoordinateMode.relativePercent:\r\n                //maybe do: dampening factor on relative % offset? is it possible?\r\n                // let s = this.getBasicSize(c);\r\n                // MATH:\r\n                // size.x = sp.x*x% + ep.x*(1-x%)\r\n                // size.x = sp.x*x% + ep.x - ep.x*x%\r\n                // size.x - ep.x= (sp.x - ep.x)*x%\r\n                // (size.x - ep.x) / (sp.x - ep.x) = x% // actually i inverted <sp, ep> in first equation, so reverse them in result too.\r\n                if (size.x !== undefined) ret.x = (1 - size.x) * sp.x + (size.x) * ep.x;\r\n                if (size.y !== undefined) ret.y = (1 - size.y) * sp.y + (size.y) * ep.y;\r\n                break;\r\n            case CoordinateMode.relativeOffset:\r\n            case CoordinateMode.relativeOffsetStart:\r\n            case CoordinateMode.relativeOffsetEnd:\r\n                let useStart: boolean;\r\n                let useEnd: boolean;\r\n                switch (size.currentCoordType) {\r\n                    default:\r\n                    case CoordinateMode.relativeOffset: useStart = true; useEnd = true; break;\r\n                    case CoordinateMode.relativeOffsetStart: useStart = true; useEnd = false; break;\r\n                    case CoordinateMode.relativeOffsetEnd: useStart = false; useEnd = true; break;\r\n                }\r\n                // offset = sp - size\r\n                // size = offset - sp\r\n                // in reverse: actualsize = offset, size=offset\r\n\r\n                // if coords are already in absolute mode.\r\n                let xIsAbsolute: number | undefined = (size.x&&!Array.isArray(size.x)) ? size.x : undefined;\r\n                let yIsAbsolute: number | undefined = (size.x&&!Array.isArray(size.x)) ? size.x : undefined;\r\n                Log.w(xIsAbsolute || yIsAbsolute, \"decoding relative offset require an array size coordinate system. x=[x1, x2] --> x\", {size});\r\n\r\n                let offsetsp = useStart ? new GraphPoint(xIsAbsolute || size.x[0] + sp.x, yIsAbsolute || size.y[0] + sp.y) : new GraphPoint();\r\n                let offsetep = useEnd ? new GraphPoint(xIsAbsolute || size.x[1] + ep.x, yIsAbsolute || size.y[1] + ep.y) : new GraphPoint();\r\n                // if the start and endpoint of the edge didn't move, offsetsp = offsetep.\r\n                // if they moved, those 2 are discordant --> i pick middle\r\n                offsetsp.add(offsetep, false);\r\n                if (useStart && useEnd) offsetsp.divide(2, false);\r\n                if (!xIsAbsolute && size.x !== undefined) ret.x = offsetsp.x;\r\n                if (!yIsAbsolute && size.y !== undefined) ret.y = offsetsp.y;\r\n                if (xIsAbsolute) {\r\n                    ret.x = size.x;\r\n                }\r\n                if (yIsAbsolute) {\r\n                    ret.y = size.y;\r\n                }\r\n                break;\r\n        }\r\n        if (size.x === undefined) delete ret.x;\r\n        if (size.y === undefined) delete ret.y;\r\n        if ((size as any).w === undefined) delete ret.w; else ret.w = size.w;\r\n        if ((size as any).h === undefined) delete ret.h; else ret.h = size.h;\r\n        ret.currentCoordType = CoordinateMode.absolute;\r\n        // console.log(\"decode coords\", {size, sp, ep, ret});\r\n        return ret;\r\n    }\r\n    // from x,y as coords, to x%,y% as % of ((1-val)%*startpt) + ((val)%*endpt)\r\n    public decodePosCoords<T extends Partial<GraphSize> | Partial<GraphPoint>>(c: Context, size: T&any, view: LViewElement, sp0?: GraphPoint, ep0?: GraphPoint): T {\r\n        let le: LVoidEdge = c&&c.proxyObject.father;\r\n        // console.log(\"decodepos:\", {le, sp0, lesp:le?.startPoint});\r\n        let sp: GraphPoint = sp0||le.startPoint;\r\n        let ep: GraphPoint = ep0||le.endPoint;\r\n        return LEdgePoint.decodeCoords(size, sp, ep);\r\n    }\r\n\r\n    static testCoords(range: number = 30){\r\n        outer: for (let mode of [\"absolute\", \"relative%\", \"relativeOffset\", \"relativeOffsetStart\", \"relativeOffsetEnd\"])\r\n            for (let i = -range; i < range; i++)\r\n                for (let j = -range; j < range; j++){\r\n                    var s0 = {x:i, y:j};\r\n                    var sp = {x:10, y:10};\r\n                    var ep = {x:10, y:-10};\r\n                    // @ts-ignore\r\n                    var s1 = LEdgePoint.encodeCoords(s0, mode, sp, ep)\r\n                    // @ts-ignore\r\n                    var s00 = LEdgePoint.decodeCoords(s1, sp, ep);\r\n                    // @ts-ignore\r\n                    var error = Object.keys(s0).map( k=> s0[k].toFixed(3) === s00[k].toFixed(3) ? '' : k).join('');\r\n                    (mode != \"relative%\" && error ? console.error : console.log)({diff:[s00.x-s0.x, s00.y-s0.y].join(), i, j, mode, s1:[s1.x, s1.y].join(), s0, s00, error});\r\n                    if (mode != \"relative%\" && error ) break outer;\r\n                }\r\n    }\r\n    // @ts-ignore a\r\n\r\n    static encodeCoords<T extends Partial<EPSize>>(size0: T, edgePointCoordMode: CoordinateMode, sp:GraphPoint, ep: GraphPoint): T/*absolute*/{\r\n        let size: T = size0 as any;\r\n        if (edgePointCoordMode === size.currentCoordType ||\r\n            !size.currentCoordType && edgePointCoordMode === CoordinateMode.absolute) return size;\r\n        if (size.currentCoordType && size.currentCoordType !== CoordinateMode.absolute) size = LEdgePoint.decodeCoords(size, sp, ep);\r\n\r\n        let ret: any = ((\"w\" in size || \"h\" in size) ? new GraphSize() : new GraphPoint()); // GObject<Partial<GraphSize>>;\r\n        switch (edgePointCoordMode) {\r\n            default: return Log.exDevv(\"translatePosCoords() invalid coordinate mode\", {mode:edgePointCoordMode});\r\n            // case CoordinateMode.absolute: return size;\r\n            case CoordinateMode.relativePercent:\r\n                // let s = this.getBasicSize(c);\r\n                // MATH:\r\n                // size.x = sp.x*x% + ep.x*(1-x%)\r\n                // size.x = sp.x*x% + ep.x - ep.x*x%\r\n                // size.x - ep.x= (sp.x - ep.x)*x%\r\n                // (size.x - ep.x) / (sp.x - ep.x) = x% // actually i inverted <sp, ep> in first equation, so reverse them in result too.\r\n\r\n                if (sp.x === ep.x) ret.x = 0.5; // because otherwise it is infinity. so i force him to return in line.\r\n                else if (size.x !== undefined) ret.x = (size.x - sp.x) / (ep.x - sp.x);\r\n                if (sp.y === ep.y) ret.y = 0.5;\r\n                else if (size.y !== undefined) ret.y = (size.y - sp.y) / (ep.y - sp.y);\r\n                break;\r\n            case CoordinateMode.relativeOffset:\r\n            case CoordinateMode.relativeOffsetStart:\r\n            case CoordinateMode.relativeOffsetEnd:\r\n                let useStart: boolean;\r\n                let useEnd: boolean;\r\n                switch (edgePointCoordMode) {\r\n                    default:\r\n                    case CoordinateMode.relativeOffset: useStart = true; useEnd = true; break;\r\n                    case CoordinateMode.relativeOffsetStart: useStart = true; useEnd = false; break;\r\n                    case CoordinateMode.relativeOffsetEnd: useStart = false; useEnd = true; break;\r\n                }\r\n                if (size.x) ret.x = [useStart ? size.x - sp.x : -1, useEnd ? size.x - ep.x : -1];\r\n                if (size.y) ret.y = [useStart ? size.y - sp.y : -1, useEnd ? size.y - ep.y : -1];\r\n                /*\r\n                if (size.x) ret.x = [sp.x - size.x, ep.x - size.x];\r\n                if (size.y) ret.y = [sp.y - size.y, ep.y - size.y];*/\r\n                break;\r\n        }\r\n        if (size.x === undefined) delete ret.x;\r\n        if (size.y === undefined) delete ret.y;\r\n        if ((size as any).w === undefined) delete ret.w; else ret.w = (size as any).w;\r\n        if ((size as any).h === undefined) delete ret.h; else ret.h = (size as any).h;\r\n        // console.log(\"encode coorde\", {size, sp, ep, ret});\r\n        ret.currentCoordType = edgePointCoordMode;\r\n        return ret;\r\n    }\r\n    public encodePosCoords(c: Context, size0: Partial<EPSize>, view: LViewElement, sp0?: GraphPoint, ep0?: GraphPoint, mode?: CoordinateMode): Partial<EPSize> {\r\n        if (!view) view = this.get_view(c);\r\n        let size: Partial<EPSize> = size0 as any;\r\n        let edgePointCoordMode = mode || (view.__raw || view).edgePointCoordMode;\r\n        let le: LVoidEdge = c&&c.proxyObject.father;\r\n        let sp: GraphPoint = sp0 || le.startPoint;\r\n        let ep: GraphPoint = ep0 || le.endPoint;\r\n        return LEdgePoint.encodeCoords(size, edgePointCoordMode, sp, ep);\r\n    }\r\n\r\n    /* 13/10/2023 Giordano comment (defined in LPointerTargetable\r\n    public get_delete(context: Context): () => void {\r\n        // careful: pointedBy might be broken due to comment x984 (search it)\r\n        return super.get_delete(context);\r\n    }\r\n    */\r\n}\r\nRuntimeAccessibleClass.set_extend(DVoidVertex, DEdgePoint);\r\nRuntimeAccessibleClass.set_extend(LVoidVertex, LEdgePoint);\r\n\r\n@RuntimeAccessible('DVertex')\r\nexport class DVertex extends DGraphElement { // DVoidVertex\r\n    // static _super = DVoidVertex;\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // static singleton: LVertex;\r\n    // static logic: typeof LVertex;\r\n    // static structure: typeof DVertex;\r\n\r\n    // inherit redefine\r\n    id!: Pointer<DVertex, 1, 1, LVertex>;\r\n    graph!: Pointer<DGraph, 1, 1, LGraph>;\r\n    model!: Pointer<DModelElement, 0, 1, LModelElement>;\r\n    isSelected!: Dictionary<DocString<Pointer<DUser>>, boolean>;\r\n    // containedIn!: Pointer<DGraphElement, 0, 1, LGraphElement>;\r\n    subElements!: Pointer<DGraphElement, 0, 'N', LGraphElement>;\r\n    zoom!: GraphPoint;\r\n    x!: number;\r\n    y!: number;\r\n    w!: number;\r\n    h!: number;\r\n    isResized!: boolean;\r\n    // size!: GraphSize; // virtual, gets extracted from this. x and y are stored directly here as it extends GraphSize\r\n    // personal attributes\r\n    __isDVertex!: true;\r\n\r\n    public static new(htmlindex: number, model: DGraphElement[\"model\"], parentNodeID: DGraphElement[\"father\"],\r\n                      graphID: DGraphElement[\"graph\"], nodeID?: DGraphElement[\"id\"], size?: GraphSize): DVertex {\r\n        return new Constructors(new DVertex('dwc'), parentNodeID, true, undefined, nodeID)\r\n            .DPointerTargetable()\r\n            .DGraphElement(model, graphID, htmlindex)\r\n            .DVoidVertex(size || defaultVertexSize).DVertex().end();\r\n    }\r\n}\r\n\r\n@RuntimeAccessible('LVertex')\r\nexport class LVertex<Context extends LogicContext<any> = any, D = DVertex> extends LVoidVertex {\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // static singleton: LVertex;\r\n    // static logic: typeof LVertex;\r\n    // static structure: typeof DVertex;\r\n\r\n    // inherit redefine\r\n    __raw!: DVertex;\r\n    id!: Pointer<DVertex, 1, 1, LVertex>;\r\n    graph!: LGraph;\r\n    model?: LModelElement;\r\n    // isSelected: Dictionary<DocString<Pointer<DUser>>, boolean> = {};\r\n    isSelected(forUser?: Pointer<DUser>): boolean { return this.wrongAccessMessage(\"node.isSelected()\"); }\r\n    // containedIn?: LGraphElement;\r\n    subElements!: LGraphElement[];\r\n    zoom!: GraphPoint;\r\n    x!: number;\r\n    y!: number;\r\n    w!: number;\r\n    h!: number;\r\n    size!: GraphSize; // virtual, gets extracted from this. x and y are stored directly here as it extends GraphSize\r\n    isResized!: boolean;\r\n    // personal attributes\r\n    __isLVertex!: true;\r\n}\r\n\r\nRuntimeAccessibleClass.set_extend(DGraphElement, DVertex);\r\nRuntimeAccessibleClass.set_extend(LGraphElement, LVertex);\r\n\r\n@Leaf\r\n@RuntimeAccessible('DGraphVertex')\r\nexport class DGraphVertex extends DGraphElement { // MixOnlyFuncs(DGraph, DVertex)\r\n    // static _super1 = DGraph;\r\n    // static _super2 = DVertex;\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // static singleton: LGraphVertex;\r\n    // static logic: typeof LGraphVertex;\r\n    // static structure: typeof DGraphVertex;\r\n\r\n    // inherit redefine\r\n    id!: Pointer<DGraphVertex, 1, 1>;\r\n    graph!: Pointer<DGraph, 1, 1, LGraph>;\r\n    model!: Pointer<DModelElement, 1, 1, LModelElement>;\r\n    isSelected!: Dictionary<DocString<Pointer<DUser>>, boolean>;\r\n    // containedIn!: Pointer<DGraphElement, 0, 1, LGraphElement>;\r\n    subElements!: Pointer<DGraphElement, 0, 'N', LGraphElement>;\r\n    // from graph\r\n    zoom!: GraphPoint;\r\n    offset!: GraphPoint; // in-graph scrolling position\r\n\r\n    // from VoidVertex\r\n    x!: number;\r\n    y!: number;\r\n    w!: number;\r\n    h!: number;\r\n    isResized!: boolean;\r\n    // size!: GraphSize; // virtual\r\n    // from graph\r\n\r\n    // personal attributes\r\n    __isDVertex!: true;\r\n    __isDGraph!: true;\r\n    __isDGraphVertex!: true;\r\n\r\n    public static new(htmlindex: number, model: DGraph[\"model\"], parentNodeID: DGraphElement[\"father\"],\r\n                      graphID: DGraphElement[\"graph\"], nodeID?: DGraphElement[\"id\"], size?: GraphSize): DGraphVertex {\r\n        return new Constructors(new DGraphVertex('dwc'), parentNodeID, true, undefined, nodeID)\r\n            .DPointerTargetable().DGraphElement(model, graphID, htmlindex)\r\n            .DVoidVertex(size || defaultVertexSize).DVertex().DGraph().end();\r\n    }\r\n\r\n\r\n    /*\r\n        static init_constructor(thiss: DGraphVertex, isUser: boolean = false, nodeID: string | undefined, graphID: string | undefined, model: Pointer<DModel>): void {\r\n            DGraph.init_constructor(thiss, isUser, nodeID, graphID, model);\r\n    //isUser: boolean = false, nodeID: string | undefined, graphID: string, model?: Pointer<DModel>\r\n            DVertex.init_constructor(thiss, isUser, nodeID, graphID as string, model);\r\n            thiss.className = this.name;\r\n        }*/\r\n}\r\nclass LG extends LGraph{}\r\nclass LV extends LVertex{}\r\n\r\nconst Mixed = MixOnlyFuncs(LG, LV) as (typeof LG & typeof LV & typeof RuntimeAccessibleClass);\r\n@RuntimeAccessible('LGraphVertex')\r\n//@ts-ignore TS2510\r\nexport class LGraphVertex<Context extends LogicContext<any> = any, D extends DGraphVertex = any> extends Mixed { // MixOnlyFuncs(LGraph, LVertex)\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // static singleton: LGraphVertex;\r\n    // static logic: typeof LGraphVertex;\r\n    // static structure: typeof DGraphVertex;\r\n\r\n    // inherit redefine\r\n    __raw!: DGraphVertex;\r\n    id!: Pointer<DGraphVertex, 1, 1>;\r\n    graph!: LGraph;\r\n    model?: LModelElement;\r\n    // isSelected: Dictionary<DocString<Pointer<DUser>>, boolean> = {};\r\n    isSelected(forUser?: Pointer<DUser>): boolean { return this.wrongAccessMessage(\"node.isSelected()\"); }\r\n    // containedIn?: LGraphElement;\r\n    ///////////////////////////////////////// subElements!: LGraphElement[];\r\n    // from graph\r\n    zoom!: GraphPoint;\r\n    offset!: GraphPoint; // in-graph scrolling position\r\n    graphSize!: GraphSize; // internal size of the graph. can be huge even if the sub-graph is in a small window (scroll)\r\n\r\n    // from VoidVertex\r\n    x!: number;\r\n    y!: number;\r\n    w!: number;\r\n    h!: number;\r\n    isResized!: boolean;\r\n    size!: GraphSize; // virtual\r\n\r\n\r\n    // personal attributes\r\n    __isLVertex!: true;\r\n    __isLGraph!: true;\r\n    __isLGraphVertex!: true;\r\n}\r\n\r\nRuntimeAccessibleClass.set_extend(DGraph, DGraphVertex);\r\nRuntimeAccessibleClass.set_extend(DVertex, DGraphVertex);\r\nRuntimeAccessibleClass.set_extend(LGraph, LGraphVertex);\r\nRuntimeAccessibleClass.set_extend(LVertex, LGraphVertex);\r\n\r\n\r\n@RuntimeAccessible('DVoidEdge')\r\nexport class DVoidEdge extends DGraphElement {\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // static singleton: LVoidEdge;\r\n    // static logic: typeof LVoidEdge;\r\n    // static structure: typeof DVoidEdge;\r\n    id!: Pointer<DVoidEdge, 1, 1, LVoidEdge>;\r\n    graph!: Pointer<DGraph, 1, 1, LGraph>;\r\n    model!: Pointer<DModelElement, 0, 1, LModelElement>;\r\n    // isSelected: Dictionary<DocString<Pointer<DUser>>, boolean> = {};\r\n    isSelected!: Dictionary<DocString<Pointer<DUser>>, boolean>;\r\n    // containedIn!: Pointer<DGraphElement, 0, 1, LGraphElement>;\r\n    subElements!: Pointer<DGraphElement, 0, 'N', LGraphElement>;\r\n\r\n    // personal attributes\r\n    start!: Pointer<DGraphElement, 1, 1, LGraphElement>;\r\n    end!: Pointer<DGraphElement, 1, 1, LGraphElement>;\r\n    __isDVoidEdge!: true;\r\n\r\n    midPoints!: InitialVertexSize[]; // the logic part which instructs to generate the midnodes\r\n    midnodes!: Pointer<DEdgePoint, 1, 1, LEdgePoint>[]; // using subelements instead most of times\r\n\r\n    longestLabel!: PrimitiveType | labelfunc;\r\n    labels!: PrimitiveType[] | labelfunc[];\r\n    anchorStart?: string;\r\n    anchorEnd?: string;\r\n    // endFollow!: boolean; they became derived attributes from static properties\r\n    // startFollow!: boolean;\r\n\r\n    static isFollowingCoords: GraphPoint;\r\n\r\n    public static new(htmlindex: number, model: DGraph[\"model\"]|null|undefined, parentNodeID: DGraphElement[\"father\"], graphID: DGraphElement[\"graph\"],\r\n                      nodeID: DGraphElement[\"id\"]|undefined, start: DGraphElement[\"id\"], end: DGraphElement[\"id\"],\r\n                      longestLabel?: DEdge[\"longestLabel\"], labels?: DEdge[\"labels\"]): DEdge {\r\n        return new Constructors(new DEdge('dwc'), parentNodeID, true, undefined, nodeID)\r\n            .DPointerTargetable()\r\n            .DGraphElement(model, graphID, htmlindex)\r\n            .DVoidEdge(start, end, longestLabel, labels).end();\r\n    }\r\n    public static new2(model: DGraph[\"model\"]|null|undefined, parentNodeID: DGraphElement[\"father\"], graphID: DGraphElement[\"graph\"],\r\n                       nodeID: DGraphElement[\"id\"]|undefined, start: DGraphElement[\"id\"], end: DGraphElement[\"id\"], setter:((d: DEdge) => any)): DEdge {\r\n        return new Constructors(new DEdge('dwc'), parentNodeID, true, undefined, nodeID)\r\n            .DPointerTargetable()\r\n            .DGraphElement(model, graphID)\r\n            .DVoidEdge(start, end).end(setter);\r\n    }\r\n}\r\n/*\r\n@RuntimeAccessible\r\nexport class MidPoint{\r\n    readonly id: string; // not really a pointer, it's not on store.\r\n    x?: number; y?: number;\r\n    readonly w?: number; // if it's modified it's not ever here (initial size) but on DEdgePoint that is a Node.\r\n    readonly h?: number;/*\r\n    constructor2(x: number=5, y: number=5, w: number=5, h: number=5) {\r\n        this.x = x;\r\n        this.y = y;\r\n        this.w = w;\r\n        this.h = h;\r\n    }* /\r\nconstructor(id: string, w: number=5, h: number=5) {\r\n    this.id = id;\r\n    this.w = w;\r\n    this.h = h;\r\n}\r\n}*/\r\n@RuntimeAccessible('EdgeSegment')\r\nexport class EdgeSegment{\r\n    index: number;\r\n    prev: EdgeSegment | undefined;\r\n    start: segmentmaker;\r\n    bezier: segmentmaker[];\r\n    end: segmentmaker;\r\n    length!: number;\r\n    d!: string;\r\n    dpart!: string; //  a segment of the whole path\r\n    m!: number; // m coefficient of the line between start and end.\r\n    rad!: number; // for head and tails: radian angle of the segment.\r\n    radLabels!: number; // for labels: it flips the angle when it's < PI/2 so the text is never upside down\r\n\r\n    isLongest!: boolean;\r\n    label!: PrimitiveType | JSX.Element | undefined;\r\n    svgLetter: EdgeBendingMode;\r\n    /*constructor(label: PrimitiveType|undefined, length: number, startp: GraphPoint, endp: GraphPoint, start: LGraphElement, end: LGraphElement,\r\n                bezierpts: GraphPoint[], mid: LGraphElement[],\r\n                svgLetter: EdgeBendingMode, index: number, fillMode: MidNodeHandling) {\r\n        this.label = label;\r\n        this.length = length;\r\n        this.length = length;\r\n        this.startp = startp;\r\n        this.bezierp = bezierpts;\r\n        this.endp = endp;\r\n        this.start = start;\r\n        this.end = end;\r\n        this.mid = mid;\r\n    }*/\r\n    constructor(start: segmentmaker, mid: segmentmaker[], end: segmentmaker,\r\n                svgLetter: EdgeBendingMode, gapMode: EdgeGapMode,\r\n                index: number, prevSegment: EdgeSegment | undefined){\r\n        // console.log(\"segmentmaker:\", arguments, ((start.ge?.model as any)?.name)+\" ---> \" + ((end.ge?.model as any)?.name));\r\n        this.start = start;\r\n        this.bezier = mid;\r\n        this.end = end;\r\n        this.index = index;\r\n        this.prev = prevSegment;\r\n        //this.segments = segments;\r\n        // the idea: forbid all T and S or transform them in C, Q by calculating and manually adding their mirrored bezier pts\r\n        // if (svgLetter[1]) svgLetter = (svgLetter[0]) as any;\r\n        if (svgLetter === EdgeBendingMode.Bezier_QT) {\r\n            this.svgLetter = EdgeBendingMode.Bezier_QT[0] as any as EdgeBendingMode;\r\n            // this.svgLetter = (index === 0 ? EdgeBendingMode.Bezier_QT[0] : EdgeBendingMode.Bezier_QT[1]) as any as EdgeBendingMode;\r\n            this.addBezierPoint();\r\n        } else\r\n        if (svgLetter === EdgeBendingMode.Bezier_CS) {\r\n            this.svgLetter = EdgeBendingMode.Bezier_CS[0] as any as EdgeBendingMode;\r\n            // this.svgLetter = (index === 0 ? EdgeBendingMode.Bezier_CS[0] : EdgeBendingMode.Bezier_CS[1]) as any as EdgeBendingMode;\r\n            this.addBezierPoint();\r\n        }\r\n        else this.svgLetter = svgLetter;\r\n\r\n        // fix if amount of bezier pts is invalid for current letter\r\n        switch (this.svgLetter) {\r\n            case EdgeBendingMode.Line:\r\n            case EdgeBendingMode.Bezier_quadratic:\r\n                if (this.bezier.length >= 1) break;\r\n                else this.svgLetter = EdgeBendingMode.Line;\r\n                break;\r\n            case EdgeBendingMode.Bezier_cubic:\r\n                if (this.bezier.length >= 2) break;\r\n                else if (this.bezier.length >= 1) this.svgLetter = EdgeBendingMode.Bezier_quadratic;\r\n                else this.svgLetter = EdgeBendingMode.Line;\r\n                break;\r\n            case EdgeBendingMode.Elliptical_arc:\r\n                if (this.bezier.length >= 3) break;\r\n                else this.svgLetter = EdgeBendingMode.Line; // straight to end ignoring midpoints that are NOT coordinates when using elliptical arc.\r\n                break;\r\n            default:\r\n            //case EdgeBendingMode.Bezier_quadratic_mirrored as string:\r\n            //case EdgeBendingMode.Bezier_cubic_mirrored as string: // translated to Q or C by adding mirrored bezier points explicitly\r\n            case EdgeBendingMode.Bezier_QT:\r\n            case EdgeBendingMode.Bezier_CS: // translated to Q or C by sending the right letter to each segment\r\n                Log.exDevv(\"this svg letter should not appear here\", this.svgLetter);\r\n                break;\r\n        }\r\n    }\r\n    addBezierPoint(): void {\r\n        let prev: EdgeSegment | undefined = this.prev;\r\n        if (!prev) return;\r\n        let prevedgemakerbezier: segmentmaker = (prev.bezier[prev.bezier.length-1] || prev.start);\r\n        let mirroredBezier: segmentmaker = {...prevedgemakerbezier,\r\n            pt: EdgeSegment.invertLastBezierPt(prevedgemakerbezier.pt, prev.end.pt),\r\n            uncutPt: EdgeSegment.invertLastBezierPt(prevedgemakerbezier.uncutPt, prev.end.uncutPt),\r\n        };\r\n        this.bezier = [mirroredBezier, ...this.bezier];\r\n        // always only 1 assumed pt both in cubic and quadratic.\r\n        // let next: this | undefined = this.segments[this.index+1];\r\n        // EdgeSegment.invertLastBezierPt((next.mid[1] || next.end).pt, next.start.pt);\r\n    }\r\n\r\n    makeD(index: number, gapMode: EdgeGapMode): string {\r\n        this.m = GraphPoint.getM(this.start.pt, this.end.pt);\r\n        this.rad = Geom.mToRad(this.m, this.start.pt, this.end.pt);\r\n        this.radLabels = Math.atan(this.m);\r\n\r\n        let svgLetter = this.svgLetter; // caller makes sure to pass right letter and resolve \"CS\" mixed letters. // this.bendingModeToLetter(bendingMode, index);\r\n        // caller sends inverted pts as normal coords\r\n        // let invertedBezPt = lastSegment && EdgeSegment.invertLastBezierPt(lastSegment.midp[lastSegment.mid.length-1] || lastSegment.startp, lastSegment.endp);\r\n        switch (this.svgLetter.length) {\r\n            case 2:\r\n                return Log.exDevv(\"mixed letters are not allowed and should have been resolved to single svg letters before here, found:\" + svgLetter);\r\n            /*return Log.exDevv(\"dev problem to fix:\\n\" +\r\n            \"the mirrored mode requires the first one to have explicit non-mirrored mode?? like M, C a1 a2 a3, S a1, S a1, S a1\\n\" +\r\n            \"So all segments with mixed modes needs to extract the last bezier point (penultimate coordinate) from previous segments, mirror it and insert in midp[0]\");*/\r\n            case 1:\r\n                let bezierpts = [...this.bezier.map( b => b.pt), this.end.pt];\r\n                let finalpart = svgLetter + \" \" + bezierpts.map((p)=> p.x + \" \" + p.y).join(\", \");\r\n                this.dpart = \"M \" + this.start.pt.x + \" \" + this.start.pt.y + \", \" + finalpart;\r\n                let bezierptsUncut = [...this.bezier.map( b => b.uncutPt), this.end.pt]; // uncutPt exist for start and end too, but i want to use the cut one for those. or edgehead is off\r\n                let finalpartUncut = svgLetter + \" \" + bezierptsUncut.map((p)=> p.x + \" \" + p.y).join(\", \");\r\n                this.d = (index === 0 ? \"M\" + this.start.pt.x + \" \" + this.start.pt.y + \", \" : \"\") + finalpartUncut;\r\n\r\n                //midp = [this.startp, ...this.midp];\r\n                // d = M sp X mp2 ep // X = custom letter\r\n                // dpart = T sp X mp2 ep // S = S if X = C,\r\n                // sp is the startingpoint from the prev node, which might be != from endpoint of last node if last node have w>0 && h>0\r\n                // so i'm \"filling\" the gap with a T, or L arc wich can use only 1 parameter (they are the only 1-parameter arcs)\r\n                // if (this.prev && this.prev.end.pt.equals(this.start.pt)) gapMode = EdgeGapMode.average; // if the 2 points coincide, i use any 1 of the gapmodes that are continuous\r\n                /*switch (gapMode){\r\n                    case EdgeGapMode.center:\r\n                    case EdgeGapMode.average:\r\n                        // continuous gap modes. they only differ in how the \"joining\" point is found, but not in how they behave after that.\r\n                        /*\r\n                        if (index === 0) {\r\n                             startletter = \"M \";\r\n                         }\r\n                         else {\r\n                             switch (svgLetter) {\r\n                                 case SvgLetter.A: case SvgLetter.C: case SvgLetter.S: case SvgLetter.Q: case SvgLetter.T: default:\r\n                                     startletter = SvgLetter.T + \" \"; break;\r\n                                 case SvgLetter.L: case SvgLetter.M:\r\n                                     startletter = SvgLetter.L + \" \"; break;\r\n                             }\r\n                         }* /\r\n                        if (index) {\r\n                            this.d = finalpart;\r\n                        }\r\n                        else { this.d = this.dpart; }\r\n                        break;\r\n                    case EdgeGapMode.gap:\r\n                    case EdgeGapMode.autoFill:\r\n                    case EdgeGapMode.lineFill:\r\n                    case EdgeGapMode.arcFill:\r\n                        // the filling itself is done by another segment (solving svg letter and simulating i=0), so i treat it as a gap.\r\n                        this.d = this.dpart;\r\n                        break;\r\n                    default:\r\n                        Log.exDevv(\"unexpected EdgeGapMode:\" + gapMode, {gapMode});\r\n                }*/\r\n                break;\r\n            default: return Log.exDevv(\"unexpected bending mode length:\" + this.svgLetter + \" or fillMode: \" + gapMode, {bendingMode: this.svgLetter, index, gapMode});\r\n        }\r\n\r\n        //using\r\n        /*\r\n        88\r\n\r\n        // d should not have M set (except for segments[0]\r\n        // dpart have M abd beed to add explicit points for \"mirroring\" and transforming bezier quadratic mirrored in bezier quadratic normal etc.\r\n        //88 problem: the mirrored mode requires the first one to have explicit nonmirrored mode?? like M, C a1 a2 a3, S a1, S a1, S a1 .... ?\r\n        in any case the % letter part is wrong because it needs to subtract first element used for M*/\r\n        return this.d;\r\n    }\r\n\r\n    static invertLastBezierPt(bezier: GraphPoint, end: GraphPoint): GraphPoint{\r\n        // vector = bezier - end\r\n        // end + vector = bezier\r\n        // end - vector = inverted bezier? = 2*end-bezier\r\n        let vector = bezier.subtract(end, true);\r\n        return end.subtract(vector, true);\r\n    }\r\n\r\n    calcLength(): void {\r\n        this.length = this.start.pt.distanceFromPoint(this.end.pt);\r\n    }\r\n}\r\n\r\nexport class EdgeFillSegment extends EdgeSegment{\r\n    public static cname: string = \"EdgeFillSegment\";\r\n    makeD(index: number, gapMode: EdgeGapMode): string {\r\n        // if (gapMode === EdgeGapMode.autoFill) { gapMode = this.svgLetter === EdgeBendingMode.Line ? EdgeGapMode.lineFill : EdgeGapMode.arcFill; }\r\n        switch (gapMode) {\r\n            case \"closest\" as any:// EdgeGapMode.closest:\r\n            case EdgeGapMode.center:\r\n            case EdgeGapMode.average:\r\n            case EdgeGapMode.gap:\r\n                return \"\"; // should not have filler arcs\r\n            default:\r\n                /*\r\n            case EdgeGapMode.autoFill as any:\r\n            case EdgeGapMode.lineFill:\r\n                this.bezier = [];\r\n                this.svgLetter = EdgeBendingMode.Line;\r\n                return super.makeD(index, gapMode);\r\n            case EdgeGapMode.arcFill:*/\r\n                this.svgLetter = this.svgLetter[0] as EdgeBendingMode;\r\n                if (this.svgLetter === \"Q\") this.bezier = this.bezier.length ? [this.bezier[0]] : [];\r\n                return super.makeD(index, gapMode);\r\n        }\r\n    }\r\n}\r\n\r\n\r\ntype segmentmaker = {size: GraphSize, view: LViewElement, ge: LGraphElement, pt: GraphPoint, uncutPt: GraphPoint};\r\n@RuntimeAccessible('LVoidEdge')\r\nexport class LVoidEdge<Context extends LogicContext<DVoidEdge> = any, D extends DEdge = DEdge> extends LGraphElement {\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // static singleton: LVoidEdge;\r\n    // static logic: typeof LVoidEdge;\r\n    // static structure: typeof DVoidEdge;\r\n    __raw!: DVoidEdge;\r\n    id!: Pointer<DVoidEdge, 1, 1, LVoidEdge>;\r\n    graph!: LGraph;\r\n    model?: LModelElement;\r\n    // isSelected: Dictionary<DocString<Pointer<DUser>>, boolean> = {};\r\n    isSelected(forUser?: Pointer<DUser>): boolean { return this.wrongAccessMessage(\"node.isSelected()\"); }\r\n    // containedIn?: LGraphElement;\r\n    subElements!: LGraphElement[];\r\n    start!: LGraphElement;\r\n    end!: LGraphElement;\r\n    __isLVoidEdge!: true;\r\n    midPoints!: InitialVertexSize[]; // the logic part which instructs to generate the midnodes\r\n    midnodes!: LEdgePoint[];\r\n    edge!: LVoidEdge; // returns self. useful to get edge from edgePoints without triggering error if you are already on edge.\r\n    __info_of__edge: Info = {type:\"?LEdge\", txt:\"returns this if called on an edge, the containing edge if called on an EdgePoint, undefined otherwise.\"}\r\n\r\n\r\n/*\r\nreplaced by startPoint\r\n    edgeStart!: GraphPoint;\r\n    edgeStart_inner!: GraphPoint;\r\n    edgeStart_outer!: GraphPoint;\r\n    __info_of__edgeStart: Info = {type: \"GraphPoint\", txt: \"Same as edgeStart_outer.\"}\r\n    __info_of__edgeStart_outer: Info = {type: \"GraphPoint\",\r\n     txt: \"Where the edge should start his path, in coordinates relative at the root Graph.\r\n     <br>Computed by combining the anchor offset option in View and the size of the starting node.\"}\r\n    __info_of__edgeStart_inner: Info = {type: \"GraphPoint\",\r\n     txt: \"Where the edge should start his path, in coordinates relative at the most nested Graph.\r\n     <br>Computed by combining the anchor offset option in View and the size of the starting node.\"}\r\n    edgeEnd!: GraphPoint;\r\n    edgeEnd_inner!: GraphPoint;\r\n    edgeEnd_outer!: GraphPoint;\r\n    __info_of__edgeEnd: Info = {type: \"GraphPoint\", txt: \"Same as edgeEnd_outer.\"}\r\n    __info_of__edgeEnd_outer: Info = {type: \"GraphPoint\",\r\n     txt: \"Where the edge should end his path, in coordinates relative at the root Graph.\r\n     <br>Computed by combining the anchor offset option in View and the size of the starting node.\"}\r\n    __info_of__edgeEnd_inner: Info = {type: \"GraphPoint\",\r\n     txt: \"Where the edge should end his path, in coordinates relative at the most nested Graph.\r\n     <br>Computed by combining the anchor offset option in View and the size of the starting node.\"}\r\n*/\r\n\r\n\r\n    label!: PrimitiveType;  // should never be read change their documentation in write only. their values is \"read\" in this.segments\r\n    longestLabel!: PrimitiveType;\r\n    labels!: PrimitiveType[];\r\n    allNodes!: [LGraphElement, ...Array<LEdgePoint>, LGraphElement];\r\n    __info_of__longestLabel: Info = {label:\"Longest label\", type:\"function(edge)=>string | string\", readType: \"PrimitiveType\",\r\n        writeType:\"PrimitiveType | (e:this, curr: LGraphElement, next: LGraphElement, curr_index: number, allNodes: LGraphElement[]) => PrimitiveType)\",\r\n        txt: <span>Label assigned to the longest path segment.</span>}\r\n    __info_of__label: Info = {type: \"\", txt: <span>Alias for longestLabel</span>};\r\n    __info_of__labels: Info = {label:\"Multiple labels\", type: \"function(edge)=>string | string\",\r\n        writeType: \"type of label or Array<type of label>\",\r\n        txt: <span>Instructions to label to multiple or all path segments in an edge</span>};\r\n    __info_of__allNodes: Info = {type: \"[LGraphElement, ...Array<LEdgePoint>, LGraphElement]\", txt: <span>first element is this.start. then all this.midnodes. this.end as last element</span>};\r\n\r\n\r\n    get_label(c: Context): this[\"longestLabel\"] { return this.get_longestLabel(c); }\r\n    set_label(val: this[\"longestLabel\"], c: Context): boolean { return this.set_longestLabel(val, c); }\r\n    get_longestLabel(c: Context): this[\"longestLabel\"] { return c.data.longestLabel as any; }\r\n    set_longestLabel(val: this[\"longestLabel\"], c: Context): boolean { SetFieldAction.new(c.data, \"longestLabel\", val); return true; }\r\n    get_labels(c: Context): this[\"labels\"] { return c.data.labels as any; }\r\n    set_labels(val: this[\"labels\"], c: Context): boolean { SetFieldAction.new(c.data, \"labels\", val); return true; }\r\n    public headPos_impl(c: Context, isHead: boolean, headSize0?: GraphPoint, segment0?: EdgeSegment, zoom0?: GraphPoint): GraphSize & {rad: number} {\r\n        let segment: EdgeSegment = segment0 || this.get_segments(c).segments[0];\r\n        // let v: LViewElement = this.get_view(c);\r\n        let tmp: any = headSize0 || (isHead ? this.get_view(c).edgeHeadSize : this.get_view(c).edgeTailSize);\r\n        if (!tmp || tmp.x === 0 || tmp.y === 0) {\r\n            // head or tail missing\r\n            tmp = new GraphSize(0, 0, 0, 0);\r\n            tmp.rad = 0;\r\n            return tmp;\r\n        }\r\n        let zoom: GraphPoint = zoom0 || this.get_graph(c).zoom;\r\n        let headPos: GraphSize & {rad: number} = (new GraphSize(0, 0, tmp.x, tmp.y) as any); //.multiply({w:zoom.x, h:zoom.y});\r\n        let useBezierPoints = true;\r\n        let start: GraphPoint, end: GraphPoint;\r\n        let m: number;\r\n        if (useBezierPoints) {\r\n            if (isHead) {\r\n                start = segment.end.pt;\r\n                end = (segment.bezier[segment.bezier.length - 1] || segment.start).pt;\r\n            } else {\r\n                start = segment.start.pt;\r\n                end = (segment.bezier[0] || segment.end).pt;\r\n            }\r\n            m = GraphPoint.getM(start, end);\r\n        } else {\r\n            if (isHead) { start = segment.end.pt; end = segment.start.pt; }\r\n            else { start = segment.start.pt; end = segment.end.pt; }\r\n            m = segment.m;\r\n        }\r\n        // first find the center of where it should be positioned\r\n        // let center: GraphPoint;\r\n        // let distance: number = Math.sqrt(headPos.w*headPos.w + headPos.h*headPos.h);\r\n        // let isVertical = m >=1 ;\r\n        let x4headsize = new GraphSize(start.x - headPos.w, start.y - headPos.h, headPos.w*2, headPos.h*2);\r\n        // first intersection is segment origin. second is found with the box containing all possible edgeHead positions that touch the startPoint\r\n        // (doing x4 his shape and placing 4 \"rectangles\" all around startPoint) to cover all possible segment directions.\r\n        // or finding first direction (vertical if m >1, horizontal if m<0) and vector direction and intersecting with only the \"correct\" placed edgeHead rectangle.\r\n        // then the intersection will likely not fall on the extreme angle of EdgeHead and i can re-center edgeHead\r\n        // so that first and second intersections are equal spaced with the center segment\r\n        let secondIntersection: GraphPoint | undefined;\r\n        let segmentDistance = start.distanceFromPoint(end);\r\n        if (segmentDistance <= Math.sqrt(headPos.w**2 + headPos.h**2)){\r\n            let safeDistance = Math.max(headPos.w, headPos.h)*5;\r\n            end = new GraphPoint( end.y + safeDistance, end.y + m * safeDistance); // move the point away so it doesn't intersect anymore. i just need direction\r\n            // too small to fit edgeHead, i simply put it centered on the whole segment\r\n            // secondIntersection = end;\r\n        }\r\n        secondIntersection = GraphSize.closestIntersection(x4headsize, start, end, undefined);\r\n        if (!secondIntersection) return Log.exx(\"failed to intersect edge head\", {x4headsize, segment, headPos, c, start, end, useBezierPoints});\r\n        tmp = secondIntersection.add(start, false).divide(2); // center of edgehead\r\n        headPos.x = tmp.x - headPos.w / 2; // tl corner\r\n        headPos.y = tmp.y - headPos.h / 2; // tl corner\r\n        headPos.rad = Geom.mToRad(m, start, end);\r\n        /*\r\n        devo trovare la distanza tra il centro dell'egeHead e il punto di inizio in termini assoluti, così tramite M trovo distanza in x e y. o trovarla in altro modo\r\n        if (segment.m === Number.POSITIVE_INFINITY || segment.m === Number.NEGATIVE_INFINITY) {\r\n            center = segment.start.pt.add({x:0, y: distance}, true); }\r\n        else { center = segment.start.pt.add({x:segment.m*headPos.w/2, y:segment.m*headPos.h/2\r\n         this is wrong, cannot be the same for x and y, i should invert the line equation for x?}, true); }\r\n        headPos.x = center.x - headPos.w / 2;\r\n        headPos.y = center.y - headPos.h / 2;*/\r\n        // console.log(\"head intersected\", {headPos, secondIntersection, x4headsize, segment, c, start, end, useBezierPoints});\r\n\r\n        return headPos;\r\n    }\r\n\r\n    public headPos(headSize0?: GraphPoint, segment0?: EdgeSegment, zoom0?: GraphPoint): GraphSize & {rad: number} {\r\n        return this.wrongAccessMessage(\"This is not headPos() implementation. it is just for typings. use the getter\"); }\r\n    public tailPos(headSize0?: GraphPoint, segment0?: EdgeSegment, zoom0?: GraphPoint): GraphSize & {rad: number} {\r\n        return this.wrongAccessMessage(\"This is not tailPos() implementation. it is just for typings. use the getter\"); }\r\n    protected get_headPos(c: Context): this[\"headPos\"] {\r\n        return (headSize?: GraphPoint, segment?: EdgeSegment, zoom?: GraphPoint) => this.headPos_impl(c, true, headSize, segment, zoom); }\r\n    protected get_tailPos(c: Context): this[\"tailPos\"] {\r\n        return (headSize?: GraphPoint, segment?: EdgeSegment, zoom?: GraphPoint) => this.headPos_impl(c, false, headSize, segment, zoom); }\r\n    protected get_allNodes(c: Context): this[\"allNodes\"] { return [this.get_start(c), ...this.get_midnodes(c), this.get_end(c)]; }\r\n\r\n    protected get_edge(c: Context): this{ return c.proxyObject as this; }\r\n    protected set_edge(v: any, c: Context): false { return this.cannotSet(\"edge field, on an edge element\"); }\r\n    protected get_midPoints(c: Context):this[\"midPoints\"] { return c.data.midPoints; }\r\n    public addMidPoint(v: this[\"midPoints\"][0]): boolean { return this.wrongAccessMessage(\"addMidPoint\"); }\r\n    protected get_addMidPoint(c: Context): (v: this[\"midPoints\"][0]) => boolean { return (v:this[\"midPoints\"][0]) => this.impl_addMidPoints(v, c); }\r\n    protected set_midPoints(val: this[\"midPoints\"], c: Context): boolean {\r\n        return SetFieldAction.new(c.data.id, \"midPoints\", val, undefined, false);\r\n    }\r\n    protected impl_addMidPoints(val: this[\"midPoints\"][0], c: Context): boolean {\r\n        return SetFieldAction.new(c.data.id, \"midPoints\", val, '+=', false);\r\n    }\r\n    protected get_label_impl(c: Context, segment: EdgeSegment, nodes: this[\"allNodes\"], segments: EdgeSegment[]): PrimitiveType | undefined {\r\n        let key: \"longestLabel\" | \"labels\" = segment.isLongest ? \"longestLabel\" : \"labels\"; // : keyof this\r\n        // if (isLongestSegment) return this.get_longestLabel_impl(d, l, nodes, index):\r\n        const d = c.data;\r\n        const l = c.proxyObject;\r\n        let labelmaker: any = d[key]; // orArr<PrimitiveType | JSX | function>\r\n        let labelmakerfunc: labelfunc = labelmaker as any;\r\n        // let lastSeg = segments[i-1];\r\n        switch (typeof labelmaker) {//nb{}[]<>\r\n            case \"number\":\r\n            case \"undefined\":\r\n            case \"boolean\":\r\n            case \"string\": return labelmaker;\r\n            // case \"function\": return nodes.map( (o, i) => d.labels(l, nodes, i)).slice(0, nodes.length-1);\r\n            case \"function\": return labelmakerfunc(l, segment, nodes, segments);\r\n            default: break;\r\n            case \"object\":\r\n                if (labelmaker === null) return null;\r\n                if (!Array.isArray(labelmaker)) break;\r\n                if (typeof labelmaker[0] === \"function\") return (labelmaker[segment.index % labelmaker.length] as labelfunc)(l, segment, nodes, segments);\r\n                return (labelmaker as PrimitiveType[])[segment.index % labelmaker.length];\r\n        }\r\n        Log.exx(\"edge labels invalid type, must be a primitive value, a function or an array of such.\", {labelmaker, key, d});\r\n        return undefined;\r\n    }/*\r\n    private get_label_impl_old(d: DVoidEdge, l: LVoidEdge, nodes:this[\"allNodes\"], index: number, longestlabelindex?: number): PrimitiveType {\r\n        if (d.longestLabel !== undefined && index === longestlabelindex) return this.get_longestLabel_impl(d, l, nodes, index);\r\n        switch (typeof d.labels) {//nb{}[]<>\r\n            case \"number\":\r\n            case \"undefined\":\r\n            case \"boolean\":\r\n            case \"string\": return d.labels;\r\n            // case \"function\": return nodes.map( (o, i) => d.labels(l, nodes, i)).slice(0, nodes.length-1);\r\n            case \"function\": return d.labels(l, nodes[index], nodes[index+1], index, nodes);\r\n            default: break;\r\n            case \"object\": if (!Array.isArray(d.labels)) break;\r\n            if (typeof d.labels[0] === \"function\") return (d.labels as any)[index % d.labels.length](l, nodes[index], nodes[index+1], index, nodes);\r\n            return (d.labels as PrimitiveType[])[index % d.labels.length];\r\n        }\r\n        Log.exx(\"edge labels invalid type, must be a primitive value, a function or an array of such.\", d.labels);\r\n    }*/\r\n\r\n    __info_of__startPoint: Info = {type: \"GraphPoint\", txt:<span>startPoint of this.start (element originating the edge). Defaults in outer coordinates.</span>};\r\n    __info_of__endPoint: Info = {type: \"GraphPoint\", txt:<span>endPoint of this.end (element originating the edge). Defaults in outer coordinates.</span>};\r\n    public get_startPoint(context: Context): GraphPoint{ return this.get_startPoint_Outer(context); }\r\n    public get_endPoint(context: Context): GraphPoint{ return this.get_endPoint_Outer(context); }\r\n    public get_startPoint_Outer(c: Context): GraphPoint{\r\n        // console.log(\"get_edgeStart_Outer\", {out:this.get_outerGraph(c), pos:this.get_startPoint_inner(c), inner:this.get_start(c).innerGraph});\r\n        return this.get_outerGraph(c).translateSize(this.get_startPoint_inner(c), this.get_start(c).innerGraph);\r\n    }\r\n    public get_endPoint_Outer(c: Context): GraphPoint{\r\n        // console.log(\"get_edgeEnd_Outer\", {out:this.get_outerGraph(c), pos:this.get_endPoint_inner(c), inner:this.get_end(c).innerGraph});\r\n        return this.get_outerGraph(c).translateSize(this.get_endPoint_inner(c), this.get_end(c).innerGraph);\r\n    }\r\n\r\n    public get_startPoint_inner(c: Context): GraphPoint{ return this.get_edgeStartEnd_inner(c, true); }\r\n    public get_endPoint_inner(c: Context): GraphPoint{ return this.get_edgeStartEnd_inner(c, false); }\r\n    private get_edgeStartEnd_inner(c: Context, isStart: boolean): GraphPoint{ return isStart ? this.get_start(c).startPoint : this.get_end(c).endPoint; }\r\n    segments!: {all: EdgeSegment[], segments: EdgeSegment[], fillers: EdgeSegment[], head: GraphSize&{rad:number}, tail: GraphSize&{rad:number}};\r\n    segments_inner!: {all: EdgeSegment[], segments: EdgeSegment[], fillers: EdgeSegment[], head: GraphSize&{rad:number}, tail: GraphSize&{rad:number}};\r\n    segments_outer!: {all: EdgeSegment[], segments: EdgeSegment[], fillers: EdgeSegment[], head: GraphSize&{rad:number}, tail: GraphSize&{rad:number}};\r\n    __info_of__segments: Info = {type: \"{all:T, segments:T, fillers:T, head: GraphSize&{rad:number}, tail: as head} where T is EdgeSegment\",\r\n        txt:<span>Collection of segments connecting in order vertex and EdgePoint without intersecting their area, aimed to be rendered in svg path.\r\n            <br/>fillers are arcs generated by view.edgeGapMode being autofill, arcfill or linefill.\r\n            <br/>length of this.segments array is Math.ceil(allNodes.length / svg_letter_size) specified on view.\r\n            <br/>\"head\" and \"tail\" are the position and angle of eventual edge decorators. Refer to this.headPos documentation.</span>}\r\n\r\n    private svgLetterSize(s: string, addM: boolean = true, doublingMidPoints: boolean = true): {first:number, others: number} {\r\n        let ret: {first:number, others: number};\r\n        switch (s) {\r\n            default: ret = Log.exDevv(\"unexpected svg path letter: \\\"\" + s + \"\\\"\", s); break;\r\n            case EdgeBendingMode.Line:\r\n            //case EdgeBendingMode.Bezier_quadratic_mirrored:\r\n                ret = {first:1, others:1}; break;\r\n            case EdgeBendingMode.Bezier_quadratic:\r\n            //case EdgeBendingMode.Bezier_cubic_mirrored:\r\n                ret = {first:2, others:2}; break;\r\n            case EdgeBendingMode.Bezier_cubic: ret = {first:3, others:3}; break;\r\n            case EdgeBendingMode.Elliptical_arc: ret = {first:4, others:4}; break;\r\n\r\n            case EdgeBendingMode.Bezier_QT: ret = {first:2, others:1}; break;\r\n            case EdgeBendingMode.Bezier_CS: ret = {first:3, others:2}; break;\r\n        }\r\n\r\n        // account for the fact that every midpoint is listed twice: at anchor start and anchor end.\r\n        if (doublingMidPoints) {\r\n            // removing last point (first is already excluded because addM didn't trigger yet)\r\n            // , the remaining are midpoints to double. then i add it back\r\n            ret.first = (ret.first - 1) * 2 + 1;\r\n            ret.others = (ret.others - 1) * 2 + 1;\r\n        }\r\n\r\n        // account for the first M letter\r\n        //    (if the segment is not mode.gap or first, M coord still exist in segment but are ignored)\r\n        if (addM) {\r\n            ret.first += 1;\r\n            ret.others += 1;\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    private get_points_impl(allNodes: LGraphElement[], outer: boolean, c:Context): segmentmaker[] {\r\n        function getAnchorOffset(size: GraphSize, offset: GraphPoint, isPercentage: boolean, $factor: number = 100) {\r\n            if (!size) size = new GraphSize(0, 0, 0, 0);\r\n            // else if (!size.tl) size = new GraphSize(size.x, size.y, size.w, size.h);\r\n            if (isPercentage) offset = new GraphPoint(offset.x/$factor*(size.w), offset.y/$factor*(size.h));\r\n            return size.tl().add(offset, false);\r\n        }\r\n        const all: segmentmaker[] = allNodes.flatMap((ge, i) => {\r\n            let dge = ge.__raw;\r\n            let base: segmentmaker = {view: ge.view, size: outer ? ge.outerSize : ge.innerSize, ge, pt: null as any, uncutPt: null as any};\r\n            Log.exDev(typeof base.size !== \"object\", \"could not get node size:\", {base, c, outer})\r\n            let rets: segmentmaker | undefined;// = base as any;\r\n            let rete: segmentmaker | undefined;// = {...base} as any;\r\n            let debug = true;\r\n            if (debug) {\r\n                (base as any).anchor_e = dge.anchors[c.data.anchorEnd || 0] || dge.anchors[Object.keys(dge.anchors)[0]];\r\n                (base as any).anchor_s = dge.anchors[c.data.anchorStart || 0] || dge.anchors[Object.keys(dge.anchors)[0]];\r\n            }\r\n\r\n            // get endpoint, then startpoint (land on midnode, then depart from it)\r\n            if (i !== 0){\r\n                rete = {rete:true, ...base} as any as segmentmaker;\r\n                if (i === allNodes.length - 1) {\r\n                    // get end anchor from node\r\n                    let anchor = dge.anchors[c.data.anchorEnd || 0];\r\n                    if (!anchor) anchor = dge.anchors[Object.keys(dge.anchors)[0]];\r\n                    if (anchor) rete.pt = getAnchorOffset(rete.size, anchor, true, 1);\r\n                }\r\n                // if no anchor, treat the node as a midpoint\r\n                if (!rete.pt) {\r\n                    // get ending point from midpoint\r\n                    //rete.pt = (LEdgePoint.singleton as LEdgePoint).get_endPoint(undefined as any, rete.size, rete.view);\r\n                    rete.pt = getAnchorOffset(rete.size, rete.view.edgeStartOffset, rete.view.edgeStartOffset_isPercentage);\r\n                }\r\n                rete.uncutPt = rete.pt;\r\n            }\r\n            if (i !== allNodes.length - 1){\r\n                rets = {rets: true, ...base} as any as segmentmaker;\r\n                if (i === 0) {\r\n                    // get start anchor from node\r\n                    let anchor = dge.anchors[c.data.anchorStart || 0];\r\n                    if (!anchor) anchor = dge.anchors[Object.keys(dge.anchors)[0]];\r\n                    if (anchor) rets.pt = getAnchorOffset(rets.size, anchor, true, 1);\r\n                }\r\n                if (!rets.pt) {\r\n                    // rets starting point from midpoint\r\n                    // rets.pt = (LEdgePoint.singleton as LEdgePoint).get_startPoint(undefined as any, rets.size, rets.view);\r\n                    rets.pt = getAnchorOffset(rets.size, rets.view.edgeStartOffset, rets.view.edgeStartOffset_isPercentage);\r\n                }\r\n                rets.uncutPt = rets.pt;\r\n            }\r\n\r\n            // ret.pt = ge.startPoint\r\n            return rets && rete ? [rete, rets] : (rets ? [rets] : [rete as segmentmaker]); }\r\n        );\r\n\r\n        if (DVoidEdge.isFollowingCoords){\r\n            if (c.data.id === LVoidEdge.endFollow) {\r\n                let seg = all[all.length - 1];\r\n                seg.pt = DVoidEdge.isFollowingCoords;\r\n                seg.size = new GraphSize(seg.pt.x, seg.pt.y, 0.01, 0.01);\r\n            }\r\n            if (c.data.id === LVoidEdge.startFollow) {\r\n                let seg = all[0];\r\n                seg.pt = DVoidEdge.isFollowingCoords;\r\n                seg.size = new GraphSize(seg.pt.x, seg.pt.y, 0.01, 0.01);\r\n            }\r\n        }\r\n        return all;\r\n    }\r\n    private get_pointsDebug(c: Context): segmentmaker[]{ return this.get_points_impl(this.get_allNodes(c), true, c); }\r\n    private get_points(allNodes: LGraphElement[], outer: boolean = false, c: Context): segmentmaker[]{ return this.get_points_impl(allNodes, outer, c); }\r\n    private get_points_outer(allNodes: LGraphElement[], c: Context): segmentmaker[]{ return this.get_points_impl(allNodes, true, c); }\r\n    private get_points_inner(allNodes: LGraphElement[], c: Context): segmentmaker[]{ return this.get_points_impl(allNodes, false, c); }\r\n    public d!: string;\r\n    public __info_of__d: Info = {type: ShortAttribETypes.EString, txt:\"the full suggested path of SVG path \\\"d\\\" attribute, merging all segments.\"}\r\n    public get_d(c: Context) {\r\n        return this.get_segments(c).all.map(s => s.d).join(\" \");\r\n    }/*\r\n    private get_fillingSegments(c: Context): Partial<this[\"segments\"]> {\r\n        return this.get_segments(c).fillers;\r\n    }*/\r\n\r\n\r\n    public get_segments(c:Context): this[\"segments\"] { return this.get_segments_outer(c); }\r\n    public get_segments_outer(c:Context): this[\"segments\"] { return this.get_segments_impl(c, true); }\r\n    public get_segments_inner(c: Context): this[\"segments\"] { return this.get_segments_impl(c, false); }\r\n    private get_segments_impl(c: Context, outer: boolean): this[\"segments\"] {\r\n        let l = c.proxyObject;\r\n        let v = this.get_view(c);\r\n        let allNodes = l.allNodes;\r\n        windoww.edge = l;\r\n        let all: segmentmaker[] = this.get_points(allNodes, outer, c);\r\n        //const all: {size: GraphSize, view: LViewElement, ge: LGraphElement}[] = allNodes.map((ge) => { return { view: ge.view, size: ge.size, ge}});\r\n        let ret: EdgeSegment[] = [];\r\n        let bm: EdgeBendingMode = v.bendingMode;\r\n        let gapMode: EdgeGapMode = v.edgeGapMode;\r\n        let segmentSize = this.svgLetterSize(bm, false, true);\r\n        let increase: number = segmentSize.first;\r\n        let segment: EdgeSegment | undefined;\r\n        /// grouping points according to SvgLetter\r\n        for (let i = 0; i < all.length - 1; ) {\r\n            // let start = all[i], end = all[i+increase];\r\n            let start: segmentmaker = all[i];\r\n            let endindex = (i+increase < all.length - 1) ? i+increase : all.length - 1;\r\n            let mid: segmentmaker[] = all.slice(i+1, endindex).filter( (e, i)=> i % 2 === 0);\r\n            let end: segmentmaker = all[endindex];\r\n            // makes sure the edge actually reaches his target even if there is an invalid amount of midnodes fot the current EdgeBendingMode\r\n            if (i === endindex && segment) start = segment.end;\r\n            // segment = this.get_segmentv3(start, mid, end, getSvgLetter(i), i, segment, all);\r\n            segment = new EdgeSegment(start, mid, end, bm, gapMode, i, segment);\r\n            // segment = this.get_segment(start.ge, start.size, start.view, end.ge, end.size, end.view, cut, v.bendingMode, mid, ret[ret.length -1], fillMode, segment);\r\n            ret.push(segment);\r\n            i+= increase+1; // because increase index is already inserted at the end of prev segment\r\n            if (increase !== segmentSize.others) increase = segmentSize.others;\r\n            // if (longestLabel !== undefined && longest < s.length) { longest = s.length; longestindex = i; } todo: move to after snapping to borders\r\n        }\r\n        function printablesegment(s:GObject) {\r\n            let r: GObject = {};\r\n            for (let k in s) {\r\n                let v = s[k];\r\n                v = v?.__raw || v;\r\n                if (typeof v === \"object\") r[k] = JSON.parse(JSON.stringify(v));\r\n                else r[k] = v;\r\n            }\r\n            return r;\r\n        }\r\n\r\n        let fillSegments: EdgeSegment[] = [];\r\n        this.snapSegmentsToNodeBorders(c, v, ret, fillSegments);\r\n        let longestLabel = c.data.longestLabel;\r\n        this.setLabels(c, ret, allNodes);\r\n        // console.log(\"getSegments() labeled:\", {main:ret, fillSegments});\r\n        let rett: this[\"segments\"] = {all: [...ret, ...fillSegments], segments: ret, fillers: fillSegments} as any;\r\n        /*switch(bm){\r\n            default: break;\r\n            case EdgeBendingMode.Bezier_QT:\r\n            case EdgeBendingMode.Bezier_CS:\r\n                rett.\r\n        }*/\r\n        for (let i = 0; i < rett.all.length; i++) {\r\n            let s = rett.all[i];\r\n            s.makeD(i, gapMode);\r\n        }\r\n        let zoom = new GraphPoint(1, 1);\r\n        rett.head = this.headPos_impl(c, true, v.edgeHeadSize, rett.segments[rett.segments.length - 1], zoom);\r\n        rett.tail = this.headPos_impl(c, false, v.edgeTailSize, rett.segments[0], zoom);\r\n        return rett;\r\n    }\r\n    private setLabels(c: Context, segments: EdgeSegment[], allNodes: this[\"allNodes\"]): void {\r\n        // find longest segment\r\n        let longestindex = -1;\r\n        let longest = 0;\r\n        for (let i = 0; i < segments.length; i++) {\r\n            let s = segments[i];\r\n            s.calcLength();\r\n            if (longest < s.length) { longest = s.length; longestindex = i; }\r\n            s.isLongest = false;\r\n        }\r\n        if (longestindex >= 0) segments[longestindex].isLongest = true;\r\n        // apply labels\r\n        for (let s of segments) s.label = this.get_label_impl(c, s, allNodes, segments);\r\n    }\r\n\r\n    private snapSegmentsToNodeBorders(c: Context, v: LViewElement, ret: EdgeSegment[], fillSegments: EdgeSegment[]){\r\n        // snap segment start and end to a node border\r\n        let canCutStart: boolean = v.edgeStartStopAtBoundaries,\r\n            canCutEnd: boolean = v.edgeEndStopAtBoundaries;\r\n        let grid: GraphPoint | undefined = undefined;\r\n        // let fillSegments: EdgeSegment[] = [];\r\n        let gapMode: EdgeGapMode = v.edgeGapMode;\r\n        let bm: EdgeBendingMode = v.bendingMode;\r\n\r\n\r\n        let ci: GraphPoint | undefined;\r\n        // cut i === 0 is cut regardless of gapmode.\r\n        if (canCutStart) {\r\n            ci = GraphSize.closestIntersection(ret[0].start.size, ret[0].start.pt, (ret[0].bezier[0] || ret[0].end).pt, grid);\r\n            if (ci) ret[0].start.pt = ci;\r\n            /*\r\n            ret[0].start.pt =\r\n                GraphSize.closestIntersection(ret[0].start.size, ret[0].start.pt, (ret[0].bezier[0] || ret[0].end).pt, grid) as any\r\n                || Geom.closestPoint(ret[0].start.size, ret[0].start.pt);*/\r\n        }\r\n\r\n        // cut middle segments maybe\r\n        let prev: EdgeSegment;\r\n        let curr: EdgeSegment = ret[0];\r\n\r\n        // if (gapMode === EdgeGapMode.gap) return;\r\n        if (canCutStart || canCutEnd) // do the for below\r\n            for (let i = 1; i < ret.length; i++){\r\n                prev = ret[i-1];\r\n                curr = ret[i];\r\n                let doStartCut: boolean, doEndCut: boolean;\r\n                switch(gapMode){/*\r\n                    case EdgeGapMode.arcFill:\r\n                    case EdgeGapMode.lineFill:\r\n                    case EdgeGapMode.autoFill:\r\n                        // same as gap, but will insert 1 more segment to fill the hole\r\n                        doStartCut = true;\r\n                        doEndCut = true;\r\n                        if (prev.end.pt.equals(curr.start.pt)) break;\r\n                        fillSegments.push(new EdgeFillSegment(\r\n                            prev.end,\r\n                            [\r\n                                {...prev.end, pt: EdgeSegment.invertLastBezierPt(prev.end.pt, (prev.bezier[prev.bezier.length-1] || prev.start).pt)},\r\n                                {...curr.start, pt: EdgeSegment.invertLastBezierPt(curr.start.pt, (curr.bezier[0] || curr.end).pt)}\r\n                            ],\r\n                            curr.start,\r\n                            bm, gapMode, 0, undefined));\r\n                            / *\r\n                            fillSegments.push(new FillEdgeSegment( // M <start_gap> C <bez1> <bez2> <end_gap>\r\n                               // <start_gap> = end of last seg (start of gap) <end_gap> = first of curr seg (end of gap)\r\n                            prev.end.pt,\r\n                            EdgeSegment.invertLastBezierPt(prev.end.pt, prev.bezier[prev.bezier.length-1].pt || prev.start.pt),\r\n                            EdgeSegment.invertLastBezierPt(curr.start.pt, curr.bezier[0].pt || curr.end.pt),\r\n                            curr.start.pt)* /\r\n\r\n                        break;*/\r\n                    case EdgeGapMode.gap:\r\n                        // just snap to vertex edge         prevSegment.endp and ret.startp\r\n                        doEndCut = true; doStartCut = true;\r\n                        break;\r\n                    // average: todo: maybe rename in join (merges start-end at closest pt to both (avg), then snap on edge)\r\n                    case \"closest\" as any: //EdgeGapMode.closest:\r\n                        // does not work properly, i think i need to get next.end instead of curr.end, just disabled for now\r\n                        let nextpt: GraphPoint = (curr.bezier[0] || curr.end).pt;\r\n                        let prevpt: GraphPoint = (prev.bezier[prev.bezier.length-1] || prev.start).pt;\r\n                        let midexternalpt = prevpt.add(nextpt, true);\r\n                        let midedgepoint = curr.start.size.tl().add(curr.start.size.br(), false).divide(2, false);\r\n                        // od average between the 2 points before and after that are not part of this edgepoint, then raw a line from there to center of ep, find that intersection.\r\n                        ci = GraphSize.closestIntersection(curr.start.size, midedgepoint, midexternalpt, grid);\r\n                        doEndCut = doStartCut = false;\r\n                        if (canCutEnd && ci) prev.end.pt = ci;\r\n                        if (canCutStart && ci) curr.start.pt = ci;\r\n                        break;\r\n                    case EdgeGapMode.average:\r\n                        // first move to average of the 2 points in the gap, then snap to edge\r\n                        doEndCut = true; doStartCut = true;\r\n                        // indipendent from cutStart, cutEnd.\r\n                        // they merge if just 1 of cutting sides are true. (and if they are both false we don't even enter the for loop)\r\n                        curr.start.pt = curr.start.pt.add(prev.end.pt, false).divide(2, false);\r\n                        prev.end.pt = curr.start.pt.duplicate(); // intentionally not the same pt because during snap to edge they can diverge again.\r\n                        prev.start.uncutPt = prev.start.pt;\r\n                        prev.end.uncutPt = prev.end.pt;\r\n                        break;\r\n                    // center: first move it to center of edgePoint/node, then snap to edge.\r\n                    // this mode might be as well deleted, it can be specified with anchor points\r\n                    case EdgeGapMode.center:\r\n                        doEndCut = false; doStartCut = false;\r\n                        curr.start.pt = curr.start.size.tl().add(curr.start.size.br(), false).divide(2, false);\r\n                        prev.end.pt = curr.start.pt.duplicate(); // intentionally not the same pt because during snap to edge they can diverge again.\r\n                        prev.start.uncutPt = prev.start.pt; // only update them when point moves without being cut (average and center)\r\n                        prev.end.uncutPt = prev.end.pt;\r\n                        break;\r\n                    default:\r\n                        return Log.exDevv(\"unexpected EdgeGapMode:\" + gapMode);\r\n                }\r\n                if (canCutStart && doStartCut){\r\n                    let nextpt: GraphPoint = (curr.bezier[0] || curr.end).pt;\r\n                    ci = GraphSize.closestIntersection(curr.start.size, curr.start.pt, nextpt, grid);\r\n                    if (ci) curr.start.pt = ci;// || Geom.closestPoint(curr.start.size, curr.start.pt);\r\n                    //if (gapMode === EdgeGapMode.average && prev) { prev.end.pt = curr.start.pt.add(prev.end.pt, false).divide(2, false); }\r\n                }\r\n                if (canCutEnd && doEndCut && prev){\r\n                    let prevpt: GraphPoint = (prev.bezier[prev.bezier.length-1] || prev.start).pt;\r\n                    ci = GraphSize.closestIntersection(prev.end.size, prev.end.pt, prevpt, grid);\r\n                    if (ci) prev.end.pt = ci;// || Geom.closestPoint(prev.end.size, prev.end.pt);\r\n                    // if average: first do average between start anchor points non-snapped. then i snap both,\r\n                    // then i do average again, and since it might snap out, i get closestPoint to EdgePoint size\r\n                    if (gapMode === EdgeGapMode.average) prev.end.pt = curr.start.pt =\r\n                        Geom.closestPoint(curr.start.size, curr.start.pt.add(prev.end.pt, false).divide(2, false));\r\n                }\r\n            }\r\n        // cut end of last segment regardless of gapMode\r\n        if (canCutEnd) {\r\n            let prevendpt = curr.end.pt;\r\n            ci = GraphSize.closestIntersection(curr.end.size, curr.end.pt, (curr.bezier[curr.bezier.length-1] || curr.start).pt, grid);\r\n            if (ci) curr.end.pt = ci; //|| Geom.closestPoint(prev.end.size, prev.end.pt);\r\n        }\r\n\r\n    }\r\n\r\n\r\n\r\n    get_edgeEnd(context: Context){ return this.get_edgeEnd_outer(context); }\r\n    get_edgeEnd_outer(c: Context){\r\n        // return this.get_outerGraph(c).translateSize(this.get_edgeEnd_inner(c), this.get_innerGraph(c));\r\n        return this.get_outerGraph(c).translateSize(this.get_edgeEnd_inner(c), this.get_end(c).innerGraph);\r\n    }\r\n    get_edgeEnd_inner(c: Context){\r\n        return this.get_edgeStartEnd_inner(c, false);\r\n        // return context.proxyObject.end?.size || new GraphPoint(0, 0);\r\n    }\r\n\r\n\r\n    protected get_midnodes(context: Context): this[\"midnodes\"] {\r\n        // return LPointerTargetable.wrapAll(context.data.midnodes);\r\n        return LPointerTargetable.wrapAll(context.data.subElements);\r\n    }\r\n    protected set_midnodes(val: D[\"midnodes\"], context: Context): boolean {\r\n        return SetFieldAction.new(context.data.id, \"midnodes\", val, '', true);\r\n    }\r\n    protected get_start(context: Context): this[\"start\"] { return LPointerTargetable.from(context.data.start); }\r\n    protected get_end(context: Context): this[\"end\"] { return LPointerTargetable.from(context.data.end); }\r\n\r\n\r\n    anchorStart?: string;\r\n    anchorEnd?: string;\r\n    __info_of__anchorStart: Info = {writeType:\"string | undefined\", type:\"string\", isEdge: true,\r\n        txt:\"The name of a node anchor where the edge should originate from.\"};\r\n    __info_of__anchorEnd: Info = {writeType:\"string | undefined\", type:\"string\", isEdge: true,\r\n        txt:\"The name of a node anchor where the edge should point to.\"};\r\n    endFollow!: boolean;\r\n    startFollow!: boolean;\r\n    __info_of__endFollow: Info = {writeType:\"boolean\", readType:\"boolean\", type:\"boolean\", isEdge: true,// type:\"read:(()=>void), write:boolean\", readType:\"(()=>void))\",\r\n        txt:\"makes the ending point of an edge follow the cursor, so it can be assigned to a new anchor or target.\"};\r\n    __info_of__startFollow: Info = {writeType:\"boolean\", readType:\"boolean\", type:\"boolean\", isEdge: true,// type:\"read:(()=>void), write:boolean\", readType:\"(()=>void))\",\r\n        txt:\"makes the starting point of an edge follow the cursor, so it can be assigned to a new anchor or source.\"};\r\n    get_endFollow(c: Context): boolean { return (c.data.id === LVoidEdge.endFollow); }\r\n    get_startFollow(c: Context): boolean { return (c.data.id === LVoidEdge.startFollow); }\r\n    // // what in multieditor? needs to be moved in transientstuff?\r\n    set_endFollow(val: boolean, c: Context): boolean { return this._set_start_endFollow(val, c, false); }\r\n    set_startFollow(val: boolean, c: Context): boolean { return this._set_start_endFollow(val, c, true); }\r\n    _set_start_endFollow(val: boolean, c: Context, isStart: boolean): boolean {\r\n        val = !!val;\r\n        console.log(\"_set_start_endFollow\", {val, c, isStart});\r\n        if (val) {\r\n            if (isStart) LVoidEdge.startFollow = c.data.id;\r\n            else LVoidEdge.endFollow = c.data.id;\r\n            if (!LVoidEdge.following) {\r\n                console.log(\"_set_start_endFollow event attached\");\r\n                document.body.addEventListener(\"mousemove\", LVoidEdge.mousemove, false);\r\n                LVoidEdge.following = true;\r\n                LVoidEdge.followingContext = c as any;\r\n                const $base = $(document.getElementById(isStart ? c.data.start : c.data.end) || []);\r\n                const $deepAnchors = $base.find(\"[nodeid] .anchor\");\r\n                const $anchors = $base.find(\".anchor\").not($deepAnchors);\r\n                $anchors.addClass(\"valid-anchor\");\r\n                $anchors.filter('[data-anchorname=\"'+((isStart ? c.data.anchorStart : c.data.anchorEnd)||0)+'\"]').addClass(\"active-anchor\");\r\n                let selector = \".Edge[nodeid='\" + (LVoidEdge.endFollow || LVoidEdge.startFollow as any)+\"']\";\r\n                // [...document.querySelectorAll(selector)].map(e=>e.classList.add(\"no-transition-following\")); gets refreshed by react\r\n                document.body.classList.add(\"no-transition-following\");\r\n            }\r\n        }\r\n        else {\r\n            if (LVoidEdge.following && ((isStart ? LVoidEdge.startFollow : LVoidEdge.endFollow) === c.data.id)) {\r\n                document.body.removeEventListener(\"mousemove\", LVoidEdge.mousemove, false);\r\n                let selector = \".Edge[nodeid='\" + (LVoidEdge.endFollow || LVoidEdge.startFollow as any)+\"']\";\r\n                //[...document.querySelectorAll(selector)].map(e=>e.classList.remove(\"no-transition-following\"));\r\n                document.body.classList.remove(\"no-transition-following\");\r\n                if (isStart) LVoidEdge.startFollow = undefined;\r\n                else LVoidEdge.endFollow = undefined;\r\n                LVoidEdge.following = false;\r\n                const $base = $(document.getElementById(isStart ? c.data.start : c.data.end) || []);\r\n                //const $deepAnchors = $base.find(\"[nodeid] .anchor\");\r\n                const $anchors = $base.find(\".anchor\")//.not($deepAnchors);\r\n                $anchors.removeClass([\"valid-anchor\", \"active-anchor\"]);\r\n            }\r\n        }\r\n        //SetFieldAction.new(c.data, \"startFollow\", !!val, '', false);\r\n        return true; }\r\n    public static startFollow: Pointer<DVoidEdge> | undefined = undefined;\r\n    public static endFollow: Pointer<DVoidEdge> | undefined = undefined;\r\n    public static following: boolean = false;\r\n    public static followingContext: LogicContext<DVoidVertex, LVoidVertex>;\r\n    public static tmp: number = 1;\r\n    public static canForceUpdate: boolean = true;\r\n    public static getCursorPos(e0: Event): Point { return new Point((e0 as any as MouseEvent).pageX, (e0 as any as MouseEvent).pageY); }\r\n    /*public static getGCursorPos(e0: Event): GraphPoint {\r\n        return LVLoidEdge.getCursorPos(e0).subtract(svgsize.tl(), true).multiply(svgzoom) as any as GraphPoint;\r\n    }*/\r\n    public static mousemove(e0: Event): void {\r\n        let forcererendermode = true;\r\n        if (forcererendermode) {\r\n            if (!LVoidEdge.following) return;\r\n            if (!LVoidEdge.canForceUpdate) return;\r\n\r\n\r\n            let c = LVoidEdge.followingContext;\r\n            let g: LGraph = c.proxyObject.graph;\r\n            let cursorPos = LVoidEdge.getCursorPos(e0);\r\n            let gcursorpos = g.translateHtmlSize(cursorPos);\r\n            DVoidEdge.isFollowingCoords = gcursorpos;\r\n\r\n            let component: GraphElementComponent = GraphElementComponent.map[(LVoidEdge.startFollow || LVoidEdge.endFollow) as string];\r\n            LVoidEdge.canForceUpdate = false;\r\n            let timer = setTimeout(()=>{LVoidEdge.canForceUpdate = true; }, 5000);\r\n            let tn = transientProperties.node[c.data.id];\r\n            for (let vid in tn.viewScores) { // required to truly force an update\r\n                let tnv = tn.viewScores[vid];\r\n                tnv.jsxOutput = undefined;\r\n                tnv.usageDeclarations = undefined as any;\r\n                tnv.shouldUpdate = true;\r\n            }\r\n            component.setState({forceupdate:new Date().getDate()} as any, ()=>{LVoidEdge.canForceUpdate = true; clearTimeout(timer)});\r\n            // component.forceUpdate(()=>{LVoidEdge.canForceUpdate = true; clearTimeout(timer)});\r\n            return;\r\n        }\r\n\r\n        LVoidEdge.tmp++;\r\n        let selector = \".Edge[nodeid='\" + (LVoidEdge.endFollow || LVoidEdge.startFollow as any)+\"']\";\r\n        let root = document.querySelector(selector);\r\n        if (!root) return;\r\n        let paths: SVGPathElementt[] = [...root.querySelectorAll(\"path.full\")] as SVGPathElementt[];\r\n        let pathSegments = root.querySelectorAll(\"path.segment.preview\") as any as SVGPathElementt[];\r\n        // if (!paths.length) paths = pathSegments;\r\n        let pathSegmentContainers: Element[] = [...new Set([...pathSegments].map(e=>e.parentElement))] as Element[];\r\n        for (let container of pathSegmentContainers){\r\n            let se: SVGPathElementt[] = [...container.querySelectorAll(\"path.segment.preview\")] as SVGPathElementt[];\r\n            paths.push(se[LVoidEdge.endFollow ? se.length-1 : 0]);\r\n        }\r\n        let headTail = [...root.querySelectorAll(LVoidEdge.endFollow ? '.edgeHead' : '.edgeTail')] as HTMLElement[];\r\n        let cursorPos = LVoidEdge.getCursorPos(e0)\r\n\r\n        let segList: SVGPathSegment[] | undefined;\r\n        for (let p of paths) {\r\n            let svg: SVGElement = U.parentUntil(\"svg\", p) as SVGElement;\r\n            let svgsize: Size = Size.of(svg);\r\n            let svgzoom: Point = new Point(1,1); // todo: check viewbox and css zoom\r\n            let gcursorPos = cursorPos.subtract(svgsize.tl(), true).multiply(svgzoom) as any as GraphPoint;\r\n            segList = [...p.getPathData()];\r\n            let lastSeg = {...segList[LVoidEdge.endFollow ? segList.length-1 : 0]};\r\n            switch (lastSeg.type){\r\n                case 'a': case 'A':\r\n                    segList.push('fake new segment to get replaced instead of actual last segment which is A' as any);\r\n                    lastSeg.type=\"L\"; lastSeg.values = [gcursorPos.x, gcursorPos.y];\r\n                    break;\r\n                case \"C\": case \"c\": // bezier curves, keep type just change last point\r\n                case \"Q\": case \"q\":\r\n                case \"S\": case \"s\":\r\n                case \"T\": case \"t\":\r\n                    lastSeg.values[lastSeg.values.length-2] = gcursorPos.x;\r\n                    lastSeg.values[lastSeg.values.length-1] = gcursorPos.y; break;\r\n                case \"M\": case \"m\":\r\n                    lastSeg.type = LVoidEdge.endFollow ? \"L\" : \"M\";\r\n                    lastSeg.values = [gcursorPos.x, gcursorPos.y]; break;\r\n                case \"V\": case \"v\": // stuff forced to become a line\r\n                case \"H\": case \"h\":\r\n                case \"L\": case \"l\":\r\n                case \"Z\": case \"z\":\r\n                    lastSeg.type=\"L\"; lastSeg.values = [gcursorPos.x, gcursorPos.y];\r\n                    break;\r\n            }\r\n            segList[LVoidEdge.endFollow ? segList.length-1 : 0] = lastSeg;\r\n            if (LVoidEdge.tmp%20===0) console.log(\"svg set path data,\", {segList, oldSeglist:p.getPathData(), p});\r\n            p.setPathData(segList);\r\n        }\r\n\r\n        for (let ht of headTail){\r\n            let svg: SVGElement = U.parentUntil(\"svg\", ht) as SVGElement;\r\n            let svgsize: Size = Size.of(svg);\r\n            let svgzoom: Point = new Point(1,1); // todo: check viewbox and css zoom\r\n            let gcursorPos = cursorPos.subtract(svgsize.tl(), true).multiply(svgzoom) as any as GraphPoint;\r\n            let rotation: number;\r\n            let lastPt = segList && segList[LVoidEdge.endFollow ? segList.length-2 : 1].values;\r\n\r\n            if (lastPt) {\r\n                let m = gcursorPos.getM(new Point(lastPt[LVoidEdge.endFollow ? lastPt.length-2 : 1], lastPt[LVoidEdge.endFollow ? lastPt.length-1 : 0]));\r\n                if (Number.POSITIVE_INFINITY === m) rotation = Geom.degToRad(90); else\r\n                if (Number.NEGATIVE_INFINITY === m) rotation = Geom.degToRad(270); else\r\n                    rotation = Math.atan(m);\r\n                if (lastPt[LVoidEdge.endFollow ? lastPt.length-2 : 1] > gcursorPos.x) rotation -= Geom.degToRad(180);\r\n            } else { rotation = 0;}\r\n            let headSize = Size.of(ht);\r\n\r\n            let headPos = gcursorPos.subtract({x:headSize.w/2, y:headSize.h/2}, true);//.subtract({x:Math.cos(rotation)*headSize.w/2, y: -Math.sin(rotation)*headSize.h/2}, true);\r\n\r\n            if (LVoidEdge.tmp%20===0) console.log(\"_set_start_endFollow move head\", {selector:LVoidEdge.endFollow ? '.edgeHead' : '.edgeTail', headTail, root});\r\n            ht.style.transform = 'translate('+headPos.x+\"px, \"+headPos.y+\"px) rotate(\"+rotation+\"rad)\";\r\n        }\r\n    }\r\n}\r\nRuntimeAccessibleClass.set_extend(DGraphElement, DVoidEdge);\r\nRuntimeAccessibleClass.set_extend(LGraphElement, LVoidEdge);\r\n\r\n@RuntimeAccessible('DEdge')\r\nexport class DEdge extends DVoidEdge { // DVoidEdge\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // static singleton: LGraphElement;\r\n    // static logic: typeof LGraphElement;\r\n    // static structure: typeof DGraphElement;\r\n    id!: Pointer<DEdge, 1, 1, LEdge>;\r\n    graph!: Pointer<DGraph, 1, 1, LGraph>;\r\n    model!: Pointer<DModelElement, 0, 1, LModelElement>;\r\n    // isSelected: Dictionary<DocString<Pointer<DUser>>, boolean> = {};\r\n    isSelected!: Dictionary<DocString<Pointer<DUser>>, boolean>;\r\n    // containedIn!: Pointer<DGraphElement, 0, 1, LGraphElement>;\r\n    subElements!: Pointer<DGraphElement, 0, 'N', LGraphElement>;\r\n    state!: GObject;\r\n    start!: Pointer<DGraphElement, 1, 1, LGraphElement>;\r\n    end!: Pointer<DGraphElement, 1, 1, LGraphElement>;\r\n    __isDEdge!: true;\r\n    __isDVoidEdge!: true;\r\n    midnodes!: Pointer<DEdgePoint, 1, 1, LEdgePoint>[];\r\n\r\n}\r\n\r\n@RuntimeAccessible('LEdge')\r\nexport class LEdge<Context extends LogicContext<DEdge> = any, D extends DEdge = DEdge> extends LVoidEdge {\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // static singleton: LGraphElement;\r\n    // static logic: typeof LGraphElement;\r\n    // static structure: typeof DGraphElement;\r\n    __raw!: DEdge;\r\n    id!: Pointer<DEdge, 1, 1, LEdge>;\r\n    graph!: LGraph;\r\n    model?: LModelElement;\r\n    // isSelected: Dictionary<DocString<Pointer<DUser>>, boolean> = {};\r\n    isSelected(forUser?: Pointer<DUser>): boolean { return this.wrongAccessMessage(\"node.isSelected()\"); }\r\n    // containedIn!: LGraphElement;\r\n    subElements!: LGraphElement[];\r\n    _state!: GObject<\"proxified\">; // LMap;\r\n    start!: LGraphElement;\r\n    end!: LGraphElement;\r\n    midnodes!: LEdgePoint[];\r\n    __isLEdge!: true;\r\n    __isLVoidEdge!: true;\r\n\r\n}\r\nRuntimeAccessibleClass.set_extend(DVoidEdge, DEdge);\r\nRuntimeAccessibleClass.set_extend(LVoidEdge, LEdge);\r\n@Leaf\r\n@RuntimeAccessible('DExtEdge')\r\nexport class DExtEdge extends DEdge { // etends DEdge\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // static singleton: LGraphElement;\r\n    // static logic: typeof LGraphElement;\r\n    // static structure: typeof DGraphElement;\r\n    id!: Pointer<DExtEdge, 1, 1, LExtEdge>;\r\n    graph!: Pointer<DGraph, 1, 1, LGraph>;\r\n    model!: Pointer<DModelElement, 0, 1, LModelElement>;\r\n    // isSelected: Dictionary<DocString<Pointer<DUser>>, boolean> = {};\r\n    isSelected!: Dictionary<DocString<Pointer<DUser>>, boolean>;\r\n    // containedIn!: Pointer<DGraphElement, 0, 1, LGraphElement>;\r\n    subElements!: Pointer<DGraphElement, 0, 'N', LGraphElement>;\r\n    state!: GObject;\r\n    start!: Pointer<DGraphElement, 1, 1, LGraphElement>;\r\n    end!: Pointer<DGraphElement, 1, 1, LGraphElement>;\r\n    __isDExtEdge!: true;\r\n    __isDEdge!: true;\r\n    __isDVoidEdge!: true;\r\n    /*\r\n        public static new(model: DGraph[\"model\"], parentNodeID: DGraphElement[\"father\"], graphID: DGraphElement[\"graph\"], nodeID?: DGraphElement[\"id\"], size?: GraphSize): DExtEdge {\r\n            return new Constructors(new DExtEdge('dwc')).DPointerTargetable().DGraphElement(model, parentNodeID, graphID, nodeID)\r\n                .DVoidEdge().DEdge().DExtEdge().end();\r\n        }*/\r\n}\r\n\r\n@RuntimeAccessible('LExtEdge')\r\nexport class LExtEdge extends LEdge{\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // static singleton: LGraphElement;\r\n    // static logic: typeof LGraphElement;\r\n    // static structure: typeof DGraphElement;\r\n    __raw!: DExtEdge;\r\n    id!: Pointer<DExtEdge, 1, 1, LExtEdge>;\r\n    graph!: LGraph;\r\n    model?: LModelElement;\r\n    // isSelected: Dictionary<DocString<Pointer<DUser>>, boolean> = {};\r\n    isSelected(forUser?: Pointer<DUser>): boolean { return this.wrongAccessMessage(\"node.isSelected()\"); }\r\n    // containedIn!: LGraphElement;\r\n    subElements!: LGraphElement[];\r\n    _state!: GObject<\"proxified\">; // LMap;\r\n    start!: LGraphElement;\r\n    end!: LGraphElement;\r\n    __isLExtEdge!: true;\r\n    __isLEdge!: true;\r\n    __isLVoidEdge!: true;\r\n}\r\nRuntimeAccessibleClass.set_extend(DEdge, DExtEdge);\r\nRuntimeAccessibleClass.set_extend(LEdge, LExtEdge);\r\n@Leaf\r\n@RuntimeAccessible('DRefEdge')\r\nexport class DRefEdge extends DEdge { // extends DEdge\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    start!: Pointer<DGraphElement, 1, 1, LGraphElement>;\r\n    end!: Pointer<DGraphElement, 1, 1, LGraphElement>;\r\n    isSelected!: Dictionary<DocString<Pointer<DUser>>, boolean>;\r\n    __isDRefEdge!: true;\r\n    /*\r\n        public static new(model: DGraph[\"model\"], parentNodeID: DGraphElement[\"father\"], graphID: DGraphElement[\"graph\"], nodeID?: DGraphElement[\"id\"]): DRefEdge {\r\n            return new Constructors(new DRefEdge('dwc')).DPointerTargetable().DGraphElement(model, parentNodeID, graphID, nodeID)\r\n                .DVoidEdge().DEdge().DRefEdge().end();\r\n        }*/\r\n\r\n}\r\n@RuntimeAccessible('LRefEdge')\r\nexport class LRefEdge extends LEdge {\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // __raw!: DRefEdge;\r\n    start!: LGraphElement;\r\n    end!: LGraphElement;\r\n    __isLRefEdge!: true;\r\n}\r\nRuntimeAccessibleClass.set_extend(DEdge, DRefEdge);\r\nRuntimeAccessibleClass.set_extend(LEdge, LRefEdge);\r\n// for edges without a modelling element\r\n\r\n\r\n/*\r\n\r\nlet a = `DExtEdge, DRefEdge, DVoidEdge, LGraphVertex, LRefEdge, LEdgePoint, DVoidVertex, DGraphVertex, DEdgePoint,\r\n DVertex, DEdge, LVertex, LGraph, DGraph, LVoidVertex, LVoidEdge, LEdge, LGraphElement, LExtEdge, DGraphElement`;\r\n  // // ... get from export in index.ts\r\na = a.replaceAll(',,', \",\")\r\nlet aa = a.split(\",\").map(a => a.trim().substring(1));\r\n\r\nfunction onlyUnique(value, index, self) { return self.indexOf(value) === index; }\r\n\r\naa = aa.filter(onlyUnique).filter( a=> !!a)\r\nlet r = aa.filter(onlyUnique).filter( a=> !!a).map( a=> `export type W${a} = getWParams<L${a}, D${a}>;`).join('\\n')\r\ndocument.body.innerText = r;\r\n*/\r\nexport type WExtEdge = getWParams<LExtEdge, DExtEdge>;\r\nexport type WRefEdge = getWParams<LRefEdge, DRefEdge>;\r\nexport type WVoidEdge = getWParams<LVoidEdge, DVoidEdge>;\r\nexport type WGraphVertex = any; // getWParams<LGraphVertex, DGraphVertex>;\r\nexport type WEdgePoint = getWParams<LEdgePoint, DEdgePoint>;\r\nexport type WVoidVertex = getWParams<LVoidVertex, DVoidVertex>;\r\nexport type WVertex = getWParams<LVertex, DVertex>;\r\nexport type WEdge = getWParams<LEdge, DEdge>;\r\nexport type WGraph = getWParams<LGraph, DGraph>;\r\nexport type WGraphElement = getWParams<LGraphElement, DGraphElement>;\r\n\r\nconsole.warn('ts loading graphDataElement');\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}