{"ast":null,"code":"import _classCallCheck from \"C:/d/Programming/web/jodel-mde/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:/d/Programming/web/jodel-mde/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _assertThisInitialized from \"C:/d/Programming/web/jodel-mde/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/assertThisInitialized\";\nimport _inherits from \"C:/d/Programming/web/jodel-mde/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"C:/d/Programming/web/jodel-mde/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport React from \"react\";\nimport { DockContextType } from \"./DockData\";\nimport { DragDropDiv } from \"./dragdrop/DragDropDiv\";\nimport { DragState } from \"./dragdrop/DragManager\";\nexport var DockDropEdge = /*#__PURE__*/function (_React$PureComponent) {\n  _inherits(DockDropEdge, _React$PureComponent);\n  var _super = _createSuper(DockDropEdge);\n  function DockDropEdge() {\n    var _this;\n    _classCallCheck(this, DockDropEdge);\n    _this = _super.apply(this, arguments);\n    _this.getRef = function (r) {\n      _this._ref = r;\n    };\n    _this.onDragOver = function (e) {\n      var _a;\n      var _this$props = _this.props,\n        panelData = _this$props.panelData,\n        panelElement = _this$props.panelElement,\n        dropFromPanel = _this$props.dropFromPanel;\n      var dockId = _this.context.getDockId();\n      var draggingPanel = DragState.getData('panel', dockId);\n      var fromGroup = _this.context.getGroup(dropFromPanel.group);\n      if (draggingPanel && ((_a = draggingPanel.parent) === null || _a === void 0 ? void 0 : _a.mode) === 'float') {\n        // ignore float panel in edge mode\n        return;\n      }\n      var _this$getDirection = _this.getDirection(e, fromGroup, draggingPanel === panelData),\n        direction = _this$getDirection.direction,\n        mode = _this$getDirection.mode,\n        depth = _this$getDirection.depth;\n      depth = _this.getActualDepth(depth, mode, direction);\n      if (!direction || direction === 'float' && dropFromPanel.panelLock) {\n        _this.context.setDropRect(null, 'remove', _assertThisInitialized(_this));\n        return;\n      }\n      var targetElement = panelElement;\n      for (var i = 0; i < depth; ++i) {\n        targetElement = targetElement.parentElement;\n      }\n      var panelSize = DragState.getData('panelSize', dockId);\n      _this.context.setDropRect(targetElement, direction, _assertThisInitialized(_this), e, panelSize);\n      e.accept('');\n    };\n    _this.onDragLeave = function (e) {\n      _this.context.setDropRect(null, 'remove', _assertThisInitialized(_this));\n    };\n    _this.onDrop = function (e) {\n      var _this$props2 = _this.props,\n        panelData = _this$props2.panelData,\n        dropFromPanel = _this$props2.dropFromPanel;\n      var dockId = _this.context.getDockId();\n      var fromGroup = _this.context.getGroup(dropFromPanel.group);\n      var source = DragState.getData('tab', dockId);\n      var draggingPanel = DragState.getData('panel', dockId);\n      if (!source) {\n        source = draggingPanel;\n      }\n      if (source) {\n        var _this$getDirection2 = _this.getDirection(e, fromGroup, draggingPanel === panelData),\n          direction = _this$getDirection2.direction,\n          mode = _this$getDirection2.mode,\n          depth = _this$getDirection2.depth;\n        depth = _this.getActualDepth(depth, mode, direction);\n        if (!direction) {\n          return;\n        }\n        var target = panelData;\n        for (var i = 0; i < depth; ++i) {\n          target = target.parent;\n        }\n        _this.context.dockMove(source, target, direction);\n      }\n    };\n    return _this;\n  }\n  _createClass(DockDropEdge, [{\n    key: \"getDirection\",\n    value: function getDirection(e, group, samePanel) {\n      var rect = this._ref.getBoundingClientRect();\n      var widthRate = Math.min(rect.width, 500);\n      var heightRate = Math.min(rect.height, 500);\n      var left = (e.clientX - rect.left) / widthRate;\n      var right = (rect.right - e.clientX) / widthRate;\n      var top = (e.clientY - rect.top) / heightRate;\n      var bottom = (rect.bottom - e.clientY) / heightRate;\n      var min = Math.min(left, right, top, bottom);\n      var depth = 0;\n      if (group.disableDock || samePanel) {\n        // use an impossible min value to disable dock drop\n        min = 1;\n      }\n      if (min < 0) {\n        return {\n          direction: null,\n          depth: 0\n        };\n      } else if (min < 0.075) {\n        depth = 3; // depth 3 or 4\n      } else if (min < 0.15) {\n        depth = 1; // depth 1 or 2\n      } else if (min < 0.3) {\n        // default\n      } else if (group.floatable) {\n        return {\n          direction: 'float',\n          mode: 'float',\n          depth: 0\n        };\n      }\n      switch (min) {\n        case left:\n          {\n            return {\n              direction: 'left',\n              mode: 'horizontal',\n              depth: depth\n            };\n          }\n        case right:\n          {\n            return {\n              direction: 'right',\n              mode: 'horizontal',\n              depth: depth\n            };\n          }\n        case top:\n          {\n            return {\n              direction: 'top',\n              mode: 'vertical',\n              depth: depth\n            };\n          }\n        case bottom:\n          {\n            return {\n              direction: 'bottom',\n              mode: 'vertical',\n              depth: depth\n            };\n          }\n      }\n      // probably a invalid input causing everything to be NaN?\n      return {\n        direction: null,\n        depth: 0\n      };\n    }\n  }, {\n    key: \"getActualDepth\",\n    value: function getActualDepth(depth, mode, direction) {\n      var afterPanel = direction === 'bottom' || direction === 'right';\n      if (!depth) {\n        return depth;\n      }\n      var panelData = this.props.panelData;\n      var previousTarget = panelData;\n      var targetBox = panelData.parent;\n      var lastDepth = 0;\n      if (panelData.parent.mode === mode) {\n        ++depth;\n      }\n      while (targetBox && lastDepth < depth) {\n        if (targetBox.mode === mode) {\n          if (afterPanel) {\n            if (targetBox.children[targetBox.children.length - 1] !== previousTarget) {\n              // dont go deeper if current target is on different side of the box\n              break;\n            }\n          } else {\n            if (targetBox.children[0] !== previousTarget) {\n              // dont go deeper if current target is on different side of the box\n              break;\n            }\n          }\n        }\n        previousTarget = targetBox;\n        targetBox = targetBox.parent;\n        ++lastDepth;\n      }\n      while (depth > lastDepth) {\n        depth -= 2;\n      }\n      return depth;\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      return React.createElement(DragDropDiv, {\n        getRef: this.getRef,\n        className: 'dock-drop-edge',\n        onDragOverT: this.onDragOver,\n        onDragLeaveT: this.onDragLeave,\n        onDropT: this.onDrop\n      });\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      this.context.setDropRect(null, 'remove', this);\n    }\n  }]);\n  return DockDropEdge;\n}(React.PureComponent);\nDockDropEdge.contextType = DockContextType;","map":{"version":3,"names":["React","DockContextType","DragDropDiv","DragState","DockDropEdge","_React$PureComponent","_inherits","_super","_createSuper","_this","_classCallCheck","apply","arguments","getRef","r","_ref","onDragOver","e","_a","_this$props","props","panelData","panelElement","dropFromPanel","dockId","context","getDockId","draggingPanel","getData","fromGroup","getGroup","group","parent","mode","_this$getDirection","getDirection","direction","depth","getActualDepth","panelLock","setDropRect","_assertThisInitialized","targetElement","i","parentElement","panelSize","accept","onDragLeave","onDrop","_this$props2","source","_this$getDirection2","target","dockMove","_createClass","key","value","samePanel","rect","getBoundingClientRect","widthRate","Math","min","width","heightRate","height","left","clientX","right","top","clientY","bottom","disableDock","floatable","afterPanel","previousTarget","targetBox","lastDepth","children","length","render","createElement","className","onDragOverT","onDragLeaveT","onDropT","componentWillUnmount","PureComponent","contextType"],"sources":["C:/d/Programming/web/jodel-mde/node_modules/rc-dock/es/DockDropEdge.js"],"sourcesContent":["import React from \"react\";\nimport { DockContextType } from \"./DockData\";\nimport { DragDropDiv } from \"./dragdrop/DragDropDiv\";\nimport { DragState } from \"./dragdrop/DragManager\";\nexport class DockDropEdge extends React.PureComponent {\n    constructor() {\n        super(...arguments);\n        this.getRef = (r) => {\n            this._ref = r;\n        };\n        this.onDragOver = (e) => {\n            var _a;\n            let { panelData, panelElement, dropFromPanel } = this.props;\n            let dockId = this.context.getDockId();\n            let draggingPanel = DragState.getData('panel', dockId);\n            let fromGroup = this.context.getGroup(dropFromPanel.group);\n            if (draggingPanel && ((_a = draggingPanel.parent) === null || _a === void 0 ? void 0 : _a.mode) === 'float') {\n                // ignore float panel in edge mode\n                return;\n            }\n            let { direction, mode, depth } = this.getDirection(e, fromGroup, draggingPanel === panelData);\n            depth = this.getActualDepth(depth, mode, direction);\n            if (!direction || (direction === 'float' && dropFromPanel.panelLock)) {\n                this.context.setDropRect(null, 'remove', this);\n                return;\n            }\n            let targetElement = panelElement;\n            for (let i = 0; i < depth; ++i) {\n                targetElement = targetElement.parentElement;\n            }\n            let panelSize = DragState.getData('panelSize', dockId);\n            this.context.setDropRect(targetElement, direction, this, e, panelSize);\n            e.accept('');\n        };\n        this.onDragLeave = (e) => {\n            this.context.setDropRect(null, 'remove', this);\n        };\n        this.onDrop = (e) => {\n            let { panelData, dropFromPanel } = this.props;\n            let dockId = this.context.getDockId();\n            let fromGroup = this.context.getGroup(dropFromPanel.group);\n            let source = DragState.getData('tab', dockId);\n            let draggingPanel = DragState.getData('panel', dockId);\n            if (!source) {\n                source = draggingPanel;\n            }\n            if (source) {\n                let { direction, mode, depth } = this.getDirection(e, fromGroup, draggingPanel === panelData);\n                depth = this.getActualDepth(depth, mode, direction);\n                if (!direction) {\n                    return;\n                }\n                let target = panelData;\n                for (let i = 0; i < depth; ++i) {\n                    target = target.parent;\n                }\n                this.context.dockMove(source, target, direction);\n            }\n        };\n    }\n    getDirection(e, group, samePanel) {\n        let rect = this._ref.getBoundingClientRect();\n        let widthRate = Math.min(rect.width, 500);\n        let heightRate = Math.min(rect.height, 500);\n        let left = (e.clientX - rect.left) / widthRate;\n        let right = (rect.right - e.clientX) / widthRate;\n        let top = (e.clientY - rect.top) / heightRate;\n        let bottom = (rect.bottom - e.clientY) / heightRate;\n        let min = Math.min(left, right, top, bottom);\n        let depth = 0;\n        if (group.disableDock || samePanel) {\n            // use an impossible min value to disable dock drop\n            min = 1;\n        }\n        if (min < 0) {\n            return { direction: null, depth: 0 };\n        }\n        else if (min < 0.075) {\n            depth = 3; // depth 3 or 4\n        }\n        else if (min < 0.15) {\n            depth = 1; // depth 1 or 2\n        }\n        else if (min < 0.3) {\n            // default\n        }\n        else if (group.floatable) {\n            return { direction: 'float', mode: 'float', depth: 0 };\n        }\n        switch (min) {\n            case left: {\n                return { direction: 'left', mode: 'horizontal', depth };\n            }\n            case right: {\n                return { direction: 'right', mode: 'horizontal', depth };\n            }\n            case top: {\n                return { direction: 'top', mode: 'vertical', depth };\n            }\n            case bottom: {\n                return { direction: 'bottom', mode: 'vertical', depth };\n            }\n        }\n        // probably a invalid input causing everything to be NaN?\n        return { direction: null, depth: 0 };\n    }\n    getActualDepth(depth, mode, direction) {\n        let afterPanel = (direction === 'bottom' || direction === 'right');\n        if (!depth) {\n            return depth;\n        }\n        let { panelData } = this.props;\n        let previousTarget = panelData;\n        let targetBox = panelData.parent;\n        let lastDepth = 0;\n        if (panelData.parent.mode === mode) {\n            ++depth;\n        }\n        while (targetBox && lastDepth < depth) {\n            if (targetBox.mode === mode) {\n                if (afterPanel) {\n                    if (targetBox.children[targetBox.children.length - 1] !== previousTarget) {\n                        // dont go deeper if current target is on different side of the box\n                        break;\n                    }\n                }\n                else {\n                    if (targetBox.children[0] !== previousTarget) {\n                        // dont go deeper if current target is on different side of the box\n                        break;\n                    }\n                }\n            }\n            previousTarget = targetBox;\n            targetBox = targetBox.parent;\n            ++lastDepth;\n        }\n        while (depth > lastDepth) {\n            depth -= 2;\n        }\n        return depth;\n    }\n    render() {\n        return (React.createElement(DragDropDiv, { getRef: this.getRef, className: 'dock-drop-edge', onDragOverT: this.onDragOver, onDragLeaveT: this.onDragLeave, onDropT: this.onDrop }));\n    }\n    componentWillUnmount() {\n        this.context.setDropRect(null, 'remove', this);\n    }\n}\nDockDropEdge.contextType = DockContextType;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}