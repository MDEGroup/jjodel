{"ast":null,"code":"import{Log,LPointerTargetable,SetFieldAction,U,SetRootFieldAction,TRANSACTION}from'../joiner';export class Dummy{static get_dependencies(context){const data=context.data;const dependencies=[];const ret=()=>{for(let pointedBy of data.pointedBy){const raw=pointedBy.source.split('.');let root=raw[0];const obj=raw[1]||'';let field=raw[2]||'';// Delete chars from end that are not in [azAZ].\nconst regex=/[^a-zA-Z]+$/;root=root.replace(regex,'');field=field.replace(regex,'');// damiano: this is likely to cause a bug for sure somewhere when a key ends with \"s\" but is not an array. keep in mind when naming variables.\nlet op=field&&field.endsWith('s')?'-=':'';if(!field&&root.endsWith('s'))op='-=';const dependency={root:root,obj,field:field,op};if(!dependencies.includes(dependency))dependencies.push(dependency);}return dependencies;};return ret;}static get_delete(thiss,context){const lData=context.proxyObject;const dData=context.data;const dependencies=Dummy.get_dependencies(context)();const ret=()=>{SetRootFieldAction.new('_lastSelected',undefined,'');const dataID=dData.id;if(dData.id.indexOf('Pointer_View')!==-1)return;// cannot delete default views/viewpoints\nif(dData.__readonly)return;for(let child of lData.children){child.delete();// todo: if a m1-dvalue which conforms to a m2-reference with \"containment\" is deleted, need to delete also target.\n// maybe better to do through override?\n// child.node?.delete();\n}if(dData.className==='DViewElement')SetFieldAction.new(dData.father,'subViews',dataID,'-=',false);for(let dependency of dependencies){const root=dependency.root;if(root!=='idlookup'){SetRootFieldAction.new(root,dataID,'-=',false);continue;}const pointer=dependency.obj;// the pointing element (delete a DClass => DAttribute)\nconst field=dependency.field;const lObj=LPointerTargetable.wrap(pointer);if(!pointer||!lObj)continue;const dObj=lObj.__raw;switch(field){/* on '-=' pointedby would be removed from the element we are deleting, so it is irrelevant */default:Log.ee('Unexpected case in delete:',field,lData);continue;case'value':case'values':// this is className DModel (M1): inspect better\nlObj.values=lObj.values.filter(o=>(o===null||o===void 0?void 0:o.id)!==dataID);continue;case'type':if(lObj.className==='DAttribute'){lObj.type='Pointer_ESTRING';continue;}if(lObj.className==='DReference'){lObj.type=dObj.father;continue;}break;case'model':if(dObj.className==='DPackage'){lObj.father[field]=lObj.father.__raw[field].filter(id=>id!=dataID);continue;}else{/* Node is deleted in nodes.delete() */continue;}case'packages':case'subpackages':case'classifiers':case'enumerators':case'literals':case'classes':case'attributes':case'references':case'operations':case'parameters':case'features':case'instances':case'objects':lObj[field]=dObj[field].filter(id=>id!=dataID);continue;case'instanceof':lObj.delete();continue;/* No operations required (children) */case'father':case'subElements':case'annotations':break;}/*\r\n                if ((root === 'idlookup') && obj && field) {\r\n                    console.log('Delete', `SetFieldAction.new('${obj}', '${field}', '${val}', '${op}');`, {dependency});\r\n                    SetFieldAction.new(obj, field, val, op, false);\r\n                } else {\r\n                    console.log('Delete', `SetRootFieldAction.new('${root}', '${val}', '${op}');`);\r\n                    SetRootFieldAction.new(root, val, op, false);\r\n                }\r\n                */}if(lData.nodes)lData.nodes.map(node=>node.delete());SetRootFieldAction.new('ELEMENT_DELETED',dataID,'+=',false);// here no need to IsPointer because it only affects Transient stuff\nU.sleep(1).then(()=>SetRootFieldAction.new(\"idlookup.\".concat(dataID),undefined,'',false));// DeleteElementAction.new(data.id);\n};return()=>TRANSACTION(ret);}}","map":{"version":3,"names":["Log","LPointerTargetable","SetFieldAction","U","SetRootFieldAction","TRANSACTION","Dummy","get_dependencies","context","data","dependencies","ret","pointedBy","raw","source","split","root","obj","field","regex","replace","op","endsWith","dependency","includes","push","get_delete","thiss","lData","proxyObject","dData","new","undefined","dataID","id","indexOf","__readonly","child","children","delete","className","father","pointer","lObj","wrap","dObj","__raw","ee","values","filter","o","type","nodes","map","node","sleep","then","concat"],"sources":["C:/0Programmi/Dev/projects/frontend/jjodel/src/common/Dummy.ts"],"sourcesContent":["import {\r\n    DeleteElementAction,\r\n    DState,\r\n    GObject,\r\n    Log,\r\n    LPointerTargetable, Pointer,\r\n    SetFieldAction, U,\r\n    SetRootFieldAction, TRANSACTION, DPointerTargetable\r\n} from '../joiner';\r\nimport {Dependency} from \"../joiner/types\";\r\n\r\nexport class Dummy {\r\n    protected static get_dependencies(context: any): () => Dependency[] {\r\n        const data = context.data;\r\n        const dependencies: Dependency[] = [];\r\n        const ret = () => {\r\n            for (let pointedBy of data.pointedBy) {\r\n                const raw = pointedBy.source.split('.');\r\n                let root = raw[0];\r\n                const obj = raw[1] || '';\r\n                let field = raw[2] || '';\r\n\r\n                // Delete chars from end that are not in [azAZ].\r\n                const regex = /[^a-zA-Z]+$/;\r\n                root = root.replace(regex, '');\r\n                field = field.replace(regex, '');\r\n                // damiano: this is likely to cause a bug for sure somewhere when a key ends with \"s\" but is not an array. keep in mind when naming variables.\r\n                let op: ''|'-=' = (field && field.endsWith('s')) ? '-=' : '';\r\n                if(!field && root.endsWith('s')) op = '-=';\r\n\r\n                const dependency: Dependency = {root: root  as keyof DState, obj, field: field as keyof DPointerTargetable, op};\r\n                if(!dependencies.includes(dependency)) dependencies.push(dependency);\r\n            }\r\n            return dependencies\r\n        }\r\n        return ret;\r\n    }\r\n    static get_delete(thiss: any, context: any): () => void {\r\n\r\n\r\n        const lData: LPointerTargetable & GObject = context.proxyObject;\r\n        const dData = context.data;\r\n        const dependencies = Dummy.get_dependencies(context)();\r\n\r\n        const ret = () => {\r\n            SetRootFieldAction.new('_lastSelected', undefined, '');\r\n            const dataID = dData.id as any;\r\n            if (dData.id.indexOf('Pointer_View') !== -1 ) return; // cannot delete default views/viewpoints\r\n            if (dData.__readonly) return;\r\n            for (let child of lData.children) {\r\n                child.delete();\r\n                // todo: if a m1-dvalue which conforms to a m2-reference with \"containment\" is deleted, need to delete also target.\r\n                // maybe better to do through override?\r\n                // child.node?.delete();\r\n            }\r\n\r\n            if(dData.className === 'DViewElement')\r\n                SetFieldAction.new(dData.father, 'subViews', dataID, '-=', false);\r\n\r\n            for (let dependency of dependencies) {\r\n                const root: keyof DState = dependency.root;\r\n                if(root !== 'idlookup') {\r\n                    SetRootFieldAction.new(root, dataID, '-=', false);\r\n                    continue;\r\n                }\r\n                const pointer: Pointer<any>|null = dependency.obj; // the pointing element (delete a DClass => DAttribute)\r\n                const field = dependency.field;\r\n                const lObj: any = LPointerTargetable.wrap(pointer);\r\n                if (!pointer || !lObj) continue;\r\n                const dObj: any = lObj.__raw;\r\n                switch (field as string) {\r\n                    /* on '-=' pointedby would be removed from the element we are deleting, so it is irrelevant */\r\n                    default:\r\n                        Log.ee('Unexpected case in delete:', field, lData);\r\n                        continue;\r\n                    case 'value':\r\n                    case 'values':\r\n                        // this is className DModel (M1): inspect better\r\n                        lObj.values = lObj.values.filter((o: any) => o?.id !== dataID);\r\n                        continue;\r\n                    case 'type':\r\n                        if (lObj.className === 'DAttribute') {\r\n                            lObj.type = 'Pointer_ESTRING';\r\n                            continue;\r\n                        }\r\n                        if (lObj.className === 'DReference'){\r\n                            lObj.type = dObj.father;\r\n                            continue;\r\n                        }\r\n                        break;\r\n                    case 'model':\r\n                        if(dObj.className === 'DPackage') {\r\n                            lObj.father[field] = lObj.father.__raw[field].filter((id: any) => id != dataID);\r\n                            continue;\r\n                        } else {\r\n                            /* Node is deleted in nodes.delete() */\r\n                            continue;\r\n                        }\r\n                    case 'packages':\r\n                    case 'subpackages':\r\n                    case 'classifiers':\r\n                    case 'enumerators':\r\n                    case 'literals':\r\n                    case 'classes':\r\n                    case 'attributes':\r\n                    case 'references':\r\n                    case 'operations':\r\n                    case 'parameters':\r\n                    case 'features':\r\n                    case 'instances':\r\n                    case 'objects':\r\n                        lObj[field] = dObj[field].filter((id: any) => id != dataID);\r\n                        continue;\r\n                    case 'instanceof':\r\n                        lObj.delete();\r\n                        continue;\r\n                    /* No operations required (children) */\r\n                    case 'father':\r\n                    case 'subElements':\r\n                    case 'annotations':\r\n                        break;\r\n                }\r\n                /*\r\n                if ((root === 'idlookup') && obj && field) {\r\n                    console.log('Delete', `SetFieldAction.new('${obj}', '${field}', '${val}', '${op}');`, {dependency});\r\n                    SetFieldAction.new(obj, field, val, op, false);\r\n                } else {\r\n                    console.log('Delete', `SetRootFieldAction.new('${root}', '${val}', '${op}');`);\r\n                    SetRootFieldAction.new(root, val, op, false);\r\n                }\r\n                */\r\n            }\r\n            if (lData.nodes) lData.nodes.map((node: any) => node.delete());\r\n            SetRootFieldAction.new('ELEMENT_DELETED', dataID, '+=', false); // here no need to IsPointer because it only affects Transient stuff\r\n            U.sleep(1).then(() => SetRootFieldAction.new(`idlookup.${dataID}`, undefined, '', false));\r\n            // DeleteElementAction.new(data.id);\r\n        };\r\n        return () => TRANSACTION(ret);\r\n    }\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}