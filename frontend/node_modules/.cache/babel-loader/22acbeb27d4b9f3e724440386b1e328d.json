{"ast":null,"code":"import { Log, LPointerTargetable, SetFieldAction, U, SetRootFieldAction, TRANSACTION } from '../joiner';\nexport class Dummy {\n  static get_dependencies(context) {\n    const data = context.data;\n    const dependencies = [];\n    const ret = () => {\n      for (let pointedBy of data.pointedBy) {\n        const raw = pointedBy.source.split('.');\n        let root = raw[0];\n        const obj = raw[1] || '';\n        let field = raw[2] || '';\n\n        // Delete chars from end that are not in [azAZ].\n        const regex = /[^a-zA-Z]+$/;\n        root = root.replace(regex, '');\n        field = field.replace(regex, '');\n        // damiano: this is likely to cause a bug for sure somewhere when a key ends with \"s\" but is not an array. keep in mind when naming variables.\n        let op = field && field.endsWith('s') ? '-=' : '';\n        if (!field && root.endsWith('s')) op = '-=';\n        const dependency = {\n          root: root,\n          obj,\n          field: field,\n          op\n        };\n        if (!dependencies.includes(dependency)) dependencies.push(dependency);\n      }\n      return dependencies;\n    };\n    return ret;\n  }\n  static get_delete(thiss, context) {\n    const lData = context.proxyObject;\n    const dData = context.data;\n    const dependencies = Dummy.get_dependencies(context)();\n    const ret = () => {\n      SetRootFieldAction.new('_lastSelected', undefined, '');\n      const dataID = dData.id;\n      if (dData.id.indexOf('Pointer_View') !== -1) return; // cannot delete default views/viewpoints\n      if (dData.__readonly) return;\n      for (let child of lData.children) {\n        child.delete();\n        // todo: if a m1-dvalue which conforms to a m2-reference with \"containment\" is deleted, need to delete also target.\n        // maybe better to do through override?\n        // child.node?.delete();\n      }\n\n      // those 2 are exceptions because the pointer is a key in an object instead of a normal value as a field or array member.\n      switch (dData.className) {\n        case 'DViewElement':\n          SetFieldAction.new(dData.father, 'subViews', dataID, '-=', false);\n          break;\n        case 'DViewPoint':\n          SetFieldAction.new(dData.father, 'viewpoints', dataID, '-=', false);\n          break;\n      }\n      for (let dependency of dependencies) {\n        const root = dependency.root;\n        if (root !== 'idlookup') {\n          SetRootFieldAction.new(root, dataID, '-=', false);\n          continue;\n        }\n        const pointer = dependency.obj; // the pointing element (delete a DClass => DAttribute)\n        const field = dependency.field;\n        const lObj = LPointerTargetable.wrap(pointer);\n        if (!pointer || !lObj) continue;\n        const dObj = lObj.__raw;\n        switch (field) {\n          /* on '-=' pointedby would be removed from the element we are deleting, so it is irrelevant */\n          default:\n            Log.eDevv('Unexpected case in delete:', field, lData);\n            break;\n          case 'metamodels':\n            console.log('mm filter', {\n              newmm: dObj.metamodels.filter(id => id !== dataID),\n              oldmm: dObj.metamodels,\n              dataID\n            });\n            lObj.metamodels = dObj.metamodels.filter(id => id !== dataID);\n            break;\n          case 'dependencies':\n            lObj.dependencies = dObj.dependencies.filter(id => id !== dataID);\n            break;\n          case 'value':\n          case 'values':\n            lObj.values = dObj.values.filter(o => o !== dataID);\n            break;\n          case 'type':\n            switch (dObj.className) {\n              case 'DAttribute':\n                lObj.type = 'Pointer_ESTRING';\n                break;\n              case 'DReference':\n              case 'DOperation':\n                // would be nice to set dObj.extends[0] instead but i cannot tell if it was deleted too.\n                // dobj.father instead is safe as even if it's deleted it does not matter as it will delete the feature together\n                lObj.type = dObj.father;\n                break;\n            }\n            break;\n          case 'model':\n            if (dObj.className === 'DPackage') {\n              lObj.father[field] = lObj.father.__raw[field].filter(id => id != dataID);\n              continue;\n            } else {\n              /* Node is deleted in nodes.delete() */\n              continue;\n            }\n          case 'packages':\n          case 'subpackages':\n          case 'classifiers':\n          case 'enumerators':\n          case 'literals':\n          case 'classes':\n          case 'attributes':\n          case 'references':\n          case 'operations':\n          case 'parameters':\n          case 'features':\n          case 'instances':\n          case 'objects':\n            lObj[field] = dObj[field].filter(id => id != dataID);\n            continue;\n          case 'instanceof':\n            lObj.delete();\n            continue;\n          /* No operations required (children) */\n          case 'father':\n          case 'subElements':\n          case 'annotations':\n            break;\n        }\n        /*\r\n        if ((root === 'idlookup') && obj && field) {\r\n            console.log('Delete', `SetFieldAction.new('${obj}', '${field}', '${val}', '${op}');`, {dependency});\r\n            SetFieldAction.new(obj, field, val, op, false);\r\n        } else {\r\n            console.log('Delete', `SetRootFieldAction.new('${root}', '${val}', '${op}');`);\r\n            SetRootFieldAction.new(root, val, op, false);\r\n        }\r\n        */\n      }\n      if (lData.nodes) lData.nodes.map(node => node.delete());\n      SetRootFieldAction.new('ELEMENT_DELETED', dataID, '+=', false); // here no need to IsPointer because it only affects Transient stuff\n      U.sleep(1).then(() => SetRootFieldAction.new(`idlookup.${dataID}`, undefined, '', false));\n      // DeleteElementAction.new(data.id);\n    };\n    return () => TRANSACTION(ret);\n  }\n}","map":{"version":3,"names":["Log","LPointerTargetable","SetFieldAction","U","SetRootFieldAction","TRANSACTION","Dummy","get_dependencies","context","data","dependencies","ret","pointedBy","raw","source","split","root","obj","field","regex","replace","op","endsWith","dependency","includes","push","get_delete","thiss","lData","proxyObject","dData","new","undefined","dataID","id","indexOf","__readonly","child","children","delete","className","father","pointer","lObj","wrap","dObj","__raw","eDevv","console","log","newmm","metamodels","filter","oldmm","values","o","type","nodes","map","node","sleep","then"],"sources":["C:/0Programmi/Dev/projects/frontend/jjodel/src/common/Dummy.ts"],"sourcesContent":["import {\r\n    DeleteElementAction,\r\n    DState,\r\n    GObject,\r\n    Log,\r\n    LPointerTargetable, Pointer,\r\n    SetFieldAction, U,\r\n    SetRootFieldAction, TRANSACTION, DPointerTargetable\r\n} from '../joiner';\r\nimport {Dependency} from \"../joiner/types\";\r\n\r\nexport class Dummy {\r\n    protected static get_dependencies(context: any): () => Dependency[] {\r\n        const data = context.data;\r\n        const dependencies: Dependency[] = [];\r\n        const ret = () => {\r\n            for (let pointedBy of data.pointedBy) {\r\n                const raw = pointedBy.source.split('.');\r\n                let root = raw[0];\r\n                const obj = raw[1] || '';\r\n                let field = raw[2] || '';\r\n\r\n                // Delete chars from end that are not in [azAZ].\r\n                const regex = /[^a-zA-Z]+$/;\r\n                root = root.replace(regex, '');\r\n                field = field.replace(regex, '');\r\n                // damiano: this is likely to cause a bug for sure somewhere when a key ends with \"s\" but is not an array. keep in mind when naming variables.\r\n                let op: ''|'-=' = (field && field.endsWith('s')) ? '-=' : '';\r\n                if(!field && root.endsWith('s')) op = '-=';\r\n\r\n                const dependency: Dependency = {root: root  as keyof DState, obj, field: field as keyof DPointerTargetable, op};\r\n                if(!dependencies.includes(dependency)) dependencies.push(dependency);\r\n            }\r\n            return dependencies\r\n        }\r\n        return ret;\r\n    }\r\n    static get_delete(thiss: any, context: any): () => void {\r\n        const lData: LPointerTargetable & GObject = context.proxyObject;\r\n        const dData = context.data;\r\n        const dependencies = Dummy.get_dependencies(context)();\r\n\r\n        const ret = () => {\r\n            SetRootFieldAction.new('_lastSelected', undefined, '');\r\n            const dataID = dData.id as any;\r\n            if (dData.id.indexOf('Pointer_View') !== -1 ) return; // cannot delete default views/viewpoints\r\n            if (dData.__readonly) return;\r\n            for (let child of lData.children) {\r\n                child.delete();\r\n                // todo: if a m1-dvalue which conforms to a m2-reference with \"containment\" is deleted, need to delete also target.\r\n                // maybe better to do through override?\r\n                // child.node?.delete();\r\n            }\r\n\r\n            // those 2 are exceptions because the pointer is a key in an object instead of a normal value as a field or array member.\r\n            switch (dData.className) {\r\n                case 'DViewElement':\r\n                    SetFieldAction.new(dData.father, 'subViews', dataID, '-=', false);\r\n                    break;\r\n                case 'DViewPoint':\r\n                    SetFieldAction.new(dData.father, 'viewpoints', dataID, '-=', false);\r\n                    break;\r\n            }\r\n\r\n            for (let dependency of dependencies) {\r\n                const root: keyof DState = dependency.root;\r\n                if(root !== 'idlookup') {\r\n                    SetRootFieldAction.new(root, dataID, '-=', false);\r\n                    continue;\r\n                }\r\n                const pointer: Pointer<any>|null = dependency.obj; // the pointing element (delete a DClass => DAttribute)\r\n                const field = dependency.field;\r\n                const lObj: any = LPointerTargetable.wrap(pointer);\r\n                if (!pointer || !lObj) continue;\r\n                const dObj: any = lObj.__raw;\r\n                switch (field as string) {\r\n                    /* on '-=' pointedby would be removed from the element we are deleting, so it is irrelevant */\r\n                    default:\r\n                        Log.eDevv('Unexpected case in delete:', field, lData);\r\n                        break;\r\n                    case 'metamodels':\r\n                        console.log('mm filter', {newmm:dObj.metamodels.filter((id: Pointer) => id !== dataID), oldmm:dObj.metamodels, dataID})\r\n                        lObj.metamodels = dObj.metamodels.filter((id: Pointer) => id !== dataID);\r\n                        break;\r\n                    case 'dependencies':\r\n                        lObj.dependencies = dObj.dependencies.filter((id: Pointer) => id !== dataID);\r\n                        break;\r\n                    case 'value':\r\n                    case 'values':\r\n                        lObj.values = dObj.values.filter((o: any) => o !== dataID);\r\n                        break;\r\n                    case 'type':\r\n                        switch (dObj.className) {\r\n                            case 'DAttribute': lObj.type = 'Pointer_ESTRING'; break;\r\n                            case 'DReference': case 'DOperation':\r\n                                // would be nice to set dObj.extends[0] instead but i cannot tell if it was deleted too.\r\n                                // dobj.father instead is safe as even if it's deleted it does not matter as it will delete the feature together\r\n                                lObj.type = dObj.father;\r\n                                break;\r\n                        }\r\n                        break;\r\n                    case 'model':\r\n                        if(dObj.className === 'DPackage') {\r\n                            lObj.father[field] = lObj.father.__raw[field].filter((id: any) => id != dataID);\r\n                            continue;\r\n                        } else {\r\n                            /* Node is deleted in nodes.delete() */\r\n                            continue;\r\n                        }\r\n                    case 'packages':\r\n                    case 'subpackages':\r\n                    case 'classifiers':\r\n                    case 'enumerators':\r\n                    case 'literals':\r\n                    case 'classes':\r\n                    case 'attributes':\r\n                    case 'references':\r\n                    case 'operations':\r\n                    case 'parameters':\r\n                    case 'features':\r\n                    case 'instances':\r\n                    case 'objects':\r\n                        lObj[field] = dObj[field].filter((id: any) => id != dataID);\r\n                        continue;\r\n                    case 'instanceof':\r\n                        lObj.delete();\r\n                        continue;\r\n                    /* No operations required (children) */\r\n                    case 'father':\r\n                    case 'subElements':\r\n                    case 'annotations':\r\n                        break;\r\n                }\r\n                /*\r\n                if ((root === 'idlookup') && obj && field) {\r\n                    console.log('Delete', `SetFieldAction.new('${obj}', '${field}', '${val}', '${op}');`, {dependency});\r\n                    SetFieldAction.new(obj, field, val, op, false);\r\n                } else {\r\n                    console.log('Delete', `SetRootFieldAction.new('${root}', '${val}', '${op}');`);\r\n                    SetRootFieldAction.new(root, val, op, false);\r\n                }\r\n                */\r\n            }\r\n            if (lData.nodes) lData.nodes.map((node: any) => node.delete());\r\n            SetRootFieldAction.new('ELEMENT_DELETED', dataID, '+=', false); // here no need to IsPointer because it only affects Transient stuff\r\n            U.sleep(1).then(() => SetRootFieldAction.new(`idlookup.${dataID}`, undefined, '', false));\r\n            // DeleteElementAction.new(data.id);\r\n        };\r\n        return () => TRANSACTION(ret);\r\n    }\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}