{"ast":null,"code":"import { Log, LPointerTargetable, SetFieldAction, U, SetRootFieldAction, TRANSACTION } from '../joiner';\nexport class Dummy {\n  static clickedOutside(currentTarget, callback) {\n    if (!currentTarget) return;\n    if (!Dummy.clickedOutsideMap) {\n      Dummy.clickedOutsideMap = new WeakMap();\n      $(document).on('click', Dummy.clickedOutsideCallback);\n    }\n    if (callback) Dummy.clickedOutsideMap.set(currentTarget, callback);else Dummy.clickedOutsideMap.delete(curentTarget);\n  }\n  static clickedOutsideCallback(e) {\n    let ancestors = Dummy.ancestorArray(e.currentTarget);\n    let map = Dummy.clickedOutsideMap;\n    for (let elem in map) {\n      let callback = map.get(elem);\n      if (!callback) continue;\n      if (!ancestors.includes(elem)) continue;\n      callback(e.target, e);\n    }\n  }\n  static get_dependencies(context) {\n    const data = context.data;\n    const dependencies = [];\n    const ret = () => {\n      for (let pointedBy of data.pointedBy) {\n        const raw = pointedBy.source.split('.');\n        let root = raw[0];\n        const obj = raw[1] || '';\n        let field = raw[2] || '';\n\n        // Delete chars from end that are not in [azAZ].\n        const regex = /[^a-zA-Z]+$/;\n        root = root.replace(regex, '');\n        field = field.replace(regex, '');\n        // damiano: this is likely to cause a bug for sure somewhere when a key ends with \"s\" but is not an array. keep in mind when naming variables.\n        let op = field && field.endsWith('s') ? '-=' : '';\n        if (!field && root.endsWith('s')) op = '-=';\n        const dependency = {\n          root: root,\n          obj,\n          field: field,\n          op\n        };\n        if (!dependencies.includes(dependency)) dependencies.push(dependency);\n      }\n      return dependencies;\n    };\n    return ret;\n  }\n  static get_delete(thiss, context) {\n    const lData = context.proxyObject;\n    const dData = context.data;\n    const dependencies = Dummy.get_dependencies(context)();\n    const ret = () => {\n      var _project;\n      SetRootFieldAction.new('_lastSelected', undefined, '');\n      const dataID = dData.id;\n      if (dData.id.indexOf('Pointer_View') !== -1) return; // cannot delete default views/viewpoints\n      if (dData.__readonly) return;\n      for (let child of lData.children) {\n        child.delete();\n        // todo: if a m1-dvalue which conforms to a m2-reference with \"containment\" is deleted, need to delete also target.\n        // maybe better to do through override?\n        // child.node?.delete();\n      }\n\n      // those 2 are exceptions because the pointer is a key in an object instead of a normal value as a field or array member.\n      switch (dData.className) {\n        case 'DViewElement':\n          SetFieldAction.new(dData.father, 'subViews', dataID, '-=', false);\n          break;\n        case 'DViewPoint':\n          let projectid = lData === null || lData === void 0 ? void 0 : (_project = lData.project) === null || _project === void 0 ? void 0 : _project.id;\n          Log.eDevv('cannot find project id while deleting a viewpoint', {\n            dData,\n            context,\n            dependencies\n          });\n          if (projectid) SetFieldAction.new(projectid, 'viewpoints', dataID, '-=', false);\n          break;\n      }\n      for (let dependency of dependencies) {\n        const root = dependency.root;\n        if (root !== 'idlookup') {\n          SetRootFieldAction.new(root, dataID, '-=', false);\n          continue;\n        }\n        const pointer = dependency.obj; // the pointing element (delete a DClass => DAttribute)\n        const field = dependency.field;\n        const lObj = LPointerTargetable.wrap(pointer);\n        if (!pointer || !lObj) continue;\n        const dObj = lObj.__raw;\n        switch (field) {\n          /* on '-=' pointedby would be removed from the element we are deleting, so it is irrelevant */\n          default:\n            Log.eDevv('Unexpected case in delete:', field, lData);\n            break;\n          case 'metamodels':\n            console.log('mm filter', {\n              newmm: dObj.metamodels.filter(id => id !== dataID),\n              oldmm: dObj.metamodels,\n              dataID\n            });\n            lObj.metamodels = dObj.metamodels.filter(id => id !== dataID);\n            break;\n          case 'dependencies':\n            lObj.dependencies = dObj.dependencies.filter(id => id !== dataID);\n            break;\n          case 'values':\n            lObj.values = dObj.values.filter(o => o !== dataID);\n            break;\n          case 'type':\n            switch (dObj.className) {\n              case 'DAttribute':\n                lObj.type = 'Pointer_ESTRING';\n                break;\n              case 'DReference':\n              case 'DOperation':\n                // would be nice to set dObj.extends[0] instead but i cannot tell if it was deleted too.\n                // dobj.father instead is safe as even if it's deleted it does not matter as it will delete the feature together\n                lObj.type = dObj.father;\n                break;\n            }\n            break;\n          case 'model':\n            if (dObj.className === 'DPackage') {\n              lObj.father[field] = lObj.father.__raw[field].filter(id => id != dataID);\n              continue;\n            } else {\n              /* Node is deleted in nodes.delete() */\n              continue;\n            }\n          case 'packages':\n          case 'subpackages':\n          case 'classifiers':\n          case 'enumerators':\n          case 'literals':\n          case 'classes':\n          case 'attributes':\n          case 'references':\n          case 'operations':\n          case 'parameters':\n          case 'features':\n          case 'instances':\n          case 'objects':\n            lObj[field] = dObj[field].filter(id => id != dataID);\n            continue;\n          case 'instanceof':\n            lObj.delete();\n            continue;\n          /* No operations required (children) */\n          case 'father':\n          case 'subElements':\n          case 'annotations':\n            break;\n        }\n        /*\r\n        if ((root === 'idlookup') && obj && field) {\r\n            console.log('Delete', `SetFieldAction.new('${obj}', '${field}', '${val}', '${op}');`, {dependency});\r\n            SetFieldAction.new(obj, field, val, op, false);\r\n        } else {\r\n            console.log('Delete', `SetRootFieldAction.new('${root}', '${val}', '${op}');`);\r\n            SetRootFieldAction.new(root, val, op, false);\r\n        }\r\n        */\n      }\n      if (lData.nodes) lData.nodes.map(node => node.delete());\n      SetRootFieldAction.new('ELEMENT_DELETED', dataID, '+=', false); // here no need to IsPointer because it only affects Transient stuff\n      U.sleep(1).then(() => SetRootFieldAction.new(`idlookup.${dataID}`, undefined, '', false));\n      // DeleteElementAction.new(data.id);\n    };\n    return () => TRANSACTION(ret);\n  }\n}\nDummy.clickedOutsideMap = null;","map":{"version":3,"names":["Log","LPointerTargetable","SetFieldAction","U","SetRootFieldAction","TRANSACTION","Dummy","clickedOutside","currentTarget","callback","clickedOutsideMap","WeakMap","$","document","on","clickedOutsideCallback","set","delete","curentTarget","e","ancestors","ancestorArray","map","elem","get","includes","target","get_dependencies","context","data","dependencies","ret","pointedBy","raw","source","split","root","obj","field","regex","replace","op","endsWith","dependency","push","get_delete","thiss","lData","proxyObject","dData","_project","new","undefined","dataID","id","indexOf","__readonly","child","children","className","father","projectid","project","eDevv","pointer","lObj","wrap","dObj","__raw","console","log","newmm","metamodels","filter","oldmm","values","o","type","nodes","node","sleep","then"],"sources":["C:/0Programmi/Dev/projects/frontend/jjodel/src/common/Dummy.ts"],"sourcesContent":["import {\r\n    DeleteElementAction,\r\n    DState,\r\n    GObject,\r\n    Log,\r\n    LPointerTargetable, Pointer,\r\n    SetFieldAction, U,\r\n    SetRootFieldAction, TRANSACTION, DPointerTargetable, LViewPoint\r\n} from '../joiner';\r\nimport {Dependency} from \"../joiner/types\";\r\n\r\nexport class Dummy {\r\n\r\n\r\n    private static clickedOutsideMap: WeakMap<Element, (e: Element, evt: JQuery.ClickEvent)=>void> = null as any;\r\n    static clickedOutside(currentTarget: Element, callback: undefined | ((e: Element, evt: JQuery.ClickEvent) => void)) {\r\n        if (!currentTarget) return;\r\n        if (!Dummy.clickedOutsideMap) {\r\n            Dummy.clickedOutsideMap = new WeakMap();\r\n            $(document).on('click', Dummy.clickedOutsideCallback);\r\n        }\r\n        if (callback) Dummy.clickedOutsideMap.set(currentTarget, callback);\r\n        else Dummy.clickedOutsideMap.delete(curentTarget);\r\n    }\r\n    private static clickedOutsideCallback(e: JQuery.ClickEvent){\r\n        let ancestors = Dummy.ancestorArray(e.currentTarget);\r\n        let map = Dummy.clickedOutsideMap;\r\n        for (let elem in map) {\r\n            let callback = map.get(elem);\r\n            if (!callback) continue;\r\n            if (!ancestors.includes(elem)) continue;\r\n            callback(e.target, e);\r\n        }\r\n    }\r\n\r\n\r\n\r\n    protected static get_dependencies(context: any): () => Dependency[] {\r\n        const data = context.data;\r\n        const dependencies: Dependency[] = [];\r\n        const ret = () => {\r\n            for (let pointedBy of data.pointedBy) {\r\n                const raw = pointedBy.source.split('.');\r\n                let root = raw[0];\r\n                const obj = raw[1] || '';\r\n                let field = raw[2] || '';\r\n\r\n                // Delete chars from end that are not in [azAZ].\r\n                const regex = /[^a-zA-Z]+$/;\r\n                root = root.replace(regex, '');\r\n                field = field.replace(regex, '');\r\n                // damiano: this is likely to cause a bug for sure somewhere when a key ends with \"s\" but is not an array. keep in mind when naming variables.\r\n                let op: ''|'-=' = (field && field.endsWith('s')) ? '-=' : '';\r\n                if(!field && root.endsWith('s')) op = '-=';\r\n\r\n                const dependency: Dependency = {root: root  as keyof DState, obj, field: field as keyof DPointerTargetable, op};\r\n                if(!dependencies.includes(dependency)) dependencies.push(dependency);\r\n            }\r\n            return dependencies\r\n        }\r\n        return ret;\r\n    }\r\n    static get_delete(thiss: any, context: any): () => void {\r\n        const lData: LPointerTargetable & GObject = context.proxyObject;\r\n        const dData = context.data;\r\n        const dependencies = Dummy.get_dependencies(context)();\r\n\r\n        const ret = () => {\r\n            SetRootFieldAction.new('_lastSelected', undefined, '');\r\n            const dataID = dData.id as any;\r\n            if (dData.id.indexOf('Pointer_View') !== -1 ) return; // cannot delete default views/viewpoints\r\n            if (dData.__readonly) return;\r\n            for (let child of lData.children) {\r\n                child.delete();\r\n                // todo: if a m1-dvalue which conforms to a m2-reference with \"containment\" is deleted, need to delete also target.\r\n                // maybe better to do through override?\r\n                // child.node?.delete();\r\n            }\r\n\r\n            // those 2 are exceptions because the pointer is a key in an object instead of a normal value as a field or array member.\r\n            switch (dData.className) {\r\n                case 'DViewElement':\r\n                    SetFieldAction.new(dData.father, 'subViews', dataID, '-=', false);\r\n                    break;\r\n                case 'DViewPoint':\r\n                    let projectid = (lData as LViewPoint)?.project?.id;\r\n                    Log.eDevv('cannot find project id while deleting a viewpoint', {dData, context, dependencies});\r\n                    if (projectid) SetFieldAction.new(projectid, 'viewpoints', dataID, '-=', false);\r\n                    break;\r\n            }\r\n\r\n            for (let dependency of dependencies) {\r\n                const root: keyof DState = dependency.root;\r\n                if(root !== 'idlookup') {\r\n                    SetRootFieldAction.new(root, dataID, '-=', false);\r\n                    continue;\r\n                }\r\n                const pointer: Pointer<any>|null = dependency.obj; // the pointing element (delete a DClass => DAttribute)\r\n                const field = dependency.field;\r\n                const lObj: any = LPointerTargetable.wrap(pointer);\r\n                if (!pointer || !lObj) continue;\r\n                const dObj: any = lObj.__raw;\r\n                switch (field as string) {\r\n                    /* on '-=' pointedby would be removed from the element we are deleting, so it is irrelevant */\r\n                    default:\r\n                        Log.eDevv('Unexpected case in delete:', field, lData);\r\n                        break;\r\n                    case 'metamodels':\r\n                        console.log('mm filter', {newmm:dObj.metamodels.filter((id: Pointer) => id !== dataID), oldmm:dObj.metamodels, dataID})\r\n                        lObj.metamodels = dObj.metamodels.filter((id: Pointer) => id !== dataID);\r\n                        break;\r\n                    case 'dependencies':\r\n                        lObj.dependencies = dObj.dependencies.filter((id: Pointer) => id !== dataID);\r\n                        break;\r\n                    case 'values':\r\n                        lObj.values = dObj.values.filter((o: any) => o !== dataID);\r\n                        break;\r\n                    case 'type':\r\n                        switch (dObj.className) {\r\n                            case 'DAttribute': lObj.type = 'Pointer_ESTRING'; break;\r\n                            case 'DReference': case 'DOperation':\r\n                                // would be nice to set dObj.extends[0] instead but i cannot tell if it was deleted too.\r\n                                // dobj.father instead is safe as even if it's deleted it does not matter as it will delete the feature together\r\n                                lObj.type = dObj.father;\r\n                                break;\r\n                        }\r\n                        break;\r\n                    case 'model':\r\n                        if(dObj.className === 'DPackage') {\r\n                            lObj.father[field] = lObj.father.__raw[field].filter((id: any) => id != dataID);\r\n                            continue;\r\n                        } else {\r\n                            /* Node is deleted in nodes.delete() */\r\n                            continue;\r\n                        }\r\n                    case 'packages':\r\n                    case 'subpackages':\r\n                    case 'classifiers':\r\n                    case 'enumerators':\r\n                    case 'literals':\r\n                    case 'classes':\r\n                    case 'attributes':\r\n                    case 'references':\r\n                    case 'operations':\r\n                    case 'parameters':\r\n                    case 'features':\r\n                    case 'instances':\r\n                    case 'objects':\r\n                        lObj[field] = dObj[field].filter((id: any) => id != dataID);\r\n                        continue;\r\n                    case 'instanceof':\r\n                        lObj.delete();\r\n                        continue;\r\n                    /* No operations required (children) */\r\n                    case 'father':\r\n                    case 'subElements':\r\n                    case 'annotations':\r\n                        break;\r\n                }\r\n                /*\r\n                if ((root === 'idlookup') && obj && field) {\r\n                    console.log('Delete', `SetFieldAction.new('${obj}', '${field}', '${val}', '${op}');`, {dependency});\r\n                    SetFieldAction.new(obj, field, val, op, false);\r\n                } else {\r\n                    console.log('Delete', `SetRootFieldAction.new('${root}', '${val}', '${op}');`);\r\n                    SetRootFieldAction.new(root, val, op, false);\r\n                }\r\n                */\r\n            }\r\n            if (lData.nodes) lData.nodes.map((node: any) => node.delete());\r\n            SetRootFieldAction.new('ELEMENT_DELETED', dataID, '+=', false); // here no need to IsPointer because it only affects Transient stuff\r\n            U.sleep(1).then(() => SetRootFieldAction.new(`idlookup.${dataID}`, undefined, '', false));\r\n            // DeleteElementAction.new(data.id);\r\n        };\r\n        return () => TRANSACTION(ret);\r\n    }\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}